multiline_comment|/*&n; * Device driver for the SYMBIOS/LSILOGIC 53C8XX and 53C1010 family &n; * of PCI-SCSI IO processors.&n; *&n; * Copyright (C) 1999-2001  Gerard Roudier &lt;groudier@free.fr&gt;&n; *&n; * This driver is derived from the Linux sym53c8xx driver.&n; * Copyright (C) 1998-2000  Gerard Roudier&n; *&n; * The sym53c8xx driver is derived from the ncr53c8xx driver that had been &n; * a port of the FreeBSD ncr driver to Linux-1.2.13.&n; *&n; * The original ncr driver has been written for 386bsd and FreeBSD by&n; *         Wolfgang Stanglmeier        &lt;wolf@cologne.de&gt;&n; *         Stefan Esser                &lt;se@mi.Uni-Koeln.de&gt;&n; * Copyright (C) 1994  Wolfgang Stanglmeier&n; *&n; * Other major contributions:&n; *&n; * NVRAM detection and reading.&n; * Copyright (C) 1997 Richard Waltham &lt;dormouse@farsrobt.demon.co.uk&gt;&n; *&n; *-----------------------------------------------------------------------------&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions and the following disclaimer.&n; * 2. The name of the author may not be used to endorse or promote products&n; *    derived from this software without specific prior written permission.&n; *&n; * Where this Software is combined with software released under the terms of &n; * the GNU Public License (&quot;GPL&quot;) and the terms of the GPL would require the &n; * combined work to also be released under the terms of the GPL, the terms&n; * and conditions of this License will apply in addition to those of the&n; * GPL with the exception of any terms or conditions of this License that&n; * conflict with, or are expressly prohibited by, the GPL.&n; *&n; * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS&squot;&squot; AND&n; * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE&n; * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE&n; * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR&n; * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS&n; * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT&n; * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY&n; * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF&n; * SUCH DAMAGE.&n; */
DECL|macro|SYM_GLUE_C
mdefine_line|#define SYM_GLUE_C
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &quot;sym_glue.h&quot;
DECL|macro|NAME53C
mdefine_line|#define NAME53C&t;&t;&quot;sym53c&quot;
DECL|macro|NAME53C8XX
mdefine_line|#define NAME53C8XX&t;&quot;sym53c8xx&quot;
multiline_comment|/*&n; *  Simple Wrapper to kernel PCI bus interface.&n; */
DECL|typedef|pcidev_t
r_typedef
r_struct
id|pci_dev
op_star
id|pcidev_t
suffix:semicolon
DECL|macro|PCIDEV_NULL
mdefine_line|#define PCIDEV_NULL&t;&t;(0)
DECL|macro|PciBusNumber
mdefine_line|#define PciBusNumber(d)&t;&t;(d)-&gt;bus-&gt;number
DECL|macro|PciDeviceFn
mdefine_line|#define PciDeviceFn(d)&t;&t;(d)-&gt;devfn
DECL|macro|PciVendorId
mdefine_line|#define PciVendorId(d)&t;&t;(d)-&gt;vendor
DECL|macro|PciDeviceId
mdefine_line|#define PciDeviceId(d)&t;&t;(d)-&gt;device
DECL|macro|PciIrqLine
mdefine_line|#define PciIrqLine(d)&t;&t;(d)-&gt;irq
r_static
id|u_long
id|__init
DECL|function|pci_get_base_cookie
id|pci_get_base_cookie
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_int
id|index
)paren
(brace
id|u_long
id|base
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt; LinuxVersionCode(2,3,12)
id|base
op_assign
id|pdev-&gt;resource
(braket
id|index
)braket
dot
id|start
suffix:semicolon
macro_line|#else
id|base
op_assign
id|pdev-&gt;base_address
(braket
id|index
)braket
suffix:semicolon
macro_line|#if BITS_PER_LONG &gt; 32
r_if
c_cond
(paren
(paren
id|base
op_amp
l_int|0x7
)paren
op_eq
l_int|0x4
)paren
id|base
op_or_assign
(paren
(paren
(paren
id|u_long
)paren
id|pdev-&gt;base_address
(braket
op_increment
id|index
)braket
)paren
op_lshift
l_int|32
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
r_return
(paren
id|base
op_amp
op_complement
l_int|0x7ul
)paren
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|pci_get_base_address
id|pci_get_base_address
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_int
id|index
comma
id|u_long
op_star
id|base
)paren
(brace
id|u32
id|tmp
suffix:semicolon
DECL|macro|PCI_BAR_OFFSET
mdefine_line|#define PCI_BAR_OFFSET(index) (PCI_BASE_ADDRESS_0 + (index&lt;&lt;2))
id|pci_read_config_dword
c_func
(paren
id|pdev
comma
id|PCI_BAR_OFFSET
c_func
(paren
id|index
)paren
comma
op_amp
id|tmp
)paren
suffix:semicolon
op_star
id|base
op_assign
id|tmp
suffix:semicolon
op_increment
id|index
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_amp
l_int|0x7
)paren
op_eq
l_int|0x4
)paren
(brace
macro_line|#if BITS_PER_LONG &gt; 32
id|pci_read_config_dword
c_func
(paren
id|pdev
comma
id|PCI_BAR_OFFSET
c_func
(paren
id|index
)paren
comma
op_amp
id|tmp
)paren
suffix:semicolon
op_star
id|base
op_or_assign
(paren
(paren
(paren
id|u_long
)paren
id|tmp
)paren
op_lshift
l_int|32
)paren
suffix:semicolon
macro_line|#endif
op_increment
id|index
suffix:semicolon
)brace
r_return
id|index
suffix:semicolon
DECL|macro|PCI_BAR_OFFSET
macro_line|#undef PCI_BAR_OFFSET
)brace
macro_line|#if LINUX_VERSION_CODE  &lt; LinuxVersionCode(2,4,0)
DECL|macro|pci_enable_device
mdefine_line|#define pci_enable_device(pdev)&t;&t;(0)
macro_line|#endif
macro_line|#if LINUX_VERSION_CODE  &lt; LinuxVersionCode(2,4,4)
DECL|macro|scsi_set_pci_device
mdefine_line|#define scsi_set_pci_device(inst, pdev)&t;do { ;} while (0)
macro_line|#endif
multiline_comment|/*&n; *  Insert a delay in micro-seconds and milli-seconds.&n; */
DECL|function|sym_udelay
r_void
id|sym_udelay
c_func
(paren
r_int
id|us
)paren
(brace
id|udelay
c_func
(paren
id|us
)paren
suffix:semicolon
)brace
DECL|function|sym_mdelay
r_void
id|sym_mdelay
c_func
(paren
r_int
id|ms
)paren
(brace
id|mdelay
c_func
(paren
id|ms
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  SMP threading.&n; *&n; *  The whole SCSI sub-system under Linux is basically single-threaded.&n; *  Everything, including low-level driver interrupt routine, happens &n; *  whith the `io_request_lock&squot; held.&n; *  The sym53c8xx-1.x drivers series ran their interrupt code using a &n; *  spin mutex per controller. This added complexity without improving &n; *  scalability significantly. the sym-2 driver still use a spinlock &n; *  per controller for safety, but basically runs with the damned &n; *  io_request_lock held.&n; */
DECL|variable|sym53c8xx_lock
id|spinlock_t
id|sym53c8xx_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|macro|SYM_LOCK_DRIVER
mdefine_line|#define&t;SYM_LOCK_DRIVER(flags)    spin_lock_irqsave(&amp;sym53c8xx_lock, flags)
DECL|macro|SYM_UNLOCK_DRIVER
mdefine_line|#define&t;SYM_UNLOCK_DRIVER(flags)  spin_unlock_irqrestore(&amp;sym53c8xx_lock,flags)
DECL|macro|SYM_INIT_LOCK_HCB
mdefine_line|#define SYM_INIT_LOCK_HCB(np)&t;&t;spin_lock_init((np)-&gt;s.host-&gt;host_lock);
DECL|macro|SYM_LOCK_HCB
mdefine_line|#define&t;SYM_LOCK_HCB(np, flags)&t;&t;&bslash;&n;&t;&t;&t;spin_lock_irqsave((np)-&gt;s.host-&gt;host_lock, flags)
DECL|macro|SYM_UNLOCK_HCB
mdefine_line|#define&t;SYM_UNLOCK_HCB(np, flags)&t;&bslash;&n;&t;&t;&t;spin_unlock_irqrestore((np)-&gt;s.host-&gt;host_lock, flags)
multiline_comment|/*&n; *  These simple macros limit expression involving &n; *  kernel time values (jiffies) to some that have &n; *  chance not to be too much incorrect. :-)&n; */
DECL|macro|ktime_get
mdefine_line|#define ktime_get(o)&t;&t;(jiffies + (u_long) o)
DECL|macro|ktime_exp
mdefine_line|#define ktime_exp(b)&t;&t;((long)(jiffies) - (long)(b) &gt;= 0)
DECL|macro|ktime_dif
mdefine_line|#define ktime_dif(a, b)&t;&t;((long)(a) - (long)(b))
DECL|macro|ktime_add
mdefine_line|#define ktime_add(a, o)&t;&t;((a) + (u_long)(o))
DECL|macro|ktime_sub
mdefine_line|#define ktime_sub(a, o)&t;&t;((a) - (u_long)(o))
multiline_comment|/*&n; *  Wrappers to the generic memory allocator.&n; */
DECL|function|sym_calloc
r_void
op_star
id|sym_calloc
c_func
(paren
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
id|u_long
id|flags
suffix:semicolon
r_void
op_star
id|m
suffix:semicolon
id|SYM_LOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
id|m
op_assign
id|sym_calloc_unlocked
c_func
(paren
id|size
comma
id|name
)paren
suffix:semicolon
id|SYM_UNLOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
DECL|function|sym_mfree
r_void
id|sym_mfree
c_func
(paren
r_void
op_star
id|m
comma
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
id|u_long
id|flags
suffix:semicolon
id|SYM_LOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
id|sym_mfree_unlocked
c_func
(paren
id|m
comma
id|size
comma
id|name
)paren
suffix:semicolon
id|SYM_UNLOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#ifdef&t;SYM_LINUX_DYNAMIC_DMA_MAPPING
DECL|function|__sym_calloc_dma
r_void
op_star
id|__sym_calloc_dma
c_func
(paren
id|m_pool_ident_t
id|dev_dmat
comma
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
id|u_long
id|flags
suffix:semicolon
r_void
op_star
id|m
suffix:semicolon
id|SYM_LOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
id|m
op_assign
id|__sym_calloc_dma_unlocked
c_func
(paren
id|dev_dmat
comma
id|size
comma
id|name
)paren
suffix:semicolon
id|SYM_UNLOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
DECL|function|__sym_mfree_dma
r_void
id|__sym_mfree_dma
c_func
(paren
id|m_pool_ident_t
id|dev_dmat
comma
r_void
op_star
id|m
comma
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
id|u_long
id|flags
suffix:semicolon
id|SYM_LOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__sym_mfree_dma_unlocked
c_func
(paren
id|dev_dmat
comma
id|m
comma
id|size
comma
id|name
)paren
suffix:semicolon
id|SYM_UNLOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|__vtobus
id|m_addr_t
id|__vtobus
c_func
(paren
id|m_pool_ident_t
id|dev_dmat
comma
r_void
op_star
id|m
)paren
(brace
id|u_long
id|flags
suffix:semicolon
id|m_addr_t
id|b
suffix:semicolon
id|SYM_LOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
id|b
op_assign
id|__vtobus_unlocked
c_func
(paren
id|dev_dmat
comma
id|m
)paren
suffix:semicolon
id|SYM_UNLOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|b
suffix:semicolon
)brace
macro_line|#endif&t;/* SYM_LINUX_DYNAMIC_DMA_MAPPING */
multiline_comment|/*&n; *  Map/unmap a PCI memory window.&n; */
macro_line|#ifndef SYM_OPT_NO_BUS_MEMORY_MAPPING
DECL|function|pci_map_mem
r_static
id|u_long
id|__init
id|pci_map_mem
c_func
(paren
id|u_long
id|base
comma
id|u_long
id|size
)paren
(brace
id|u_long
id|page_base
op_assign
(paren
(paren
id|u_long
)paren
id|base
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
id|u_long
id|page_offs
op_assign
(paren
(paren
id|u_long
)paren
id|base
)paren
op_minus
id|page_base
suffix:semicolon
id|u_long
id|page_remapped
op_assign
(paren
id|u_long
)paren
id|ioremap
c_func
(paren
id|page_base
comma
id|page_offs
op_plus
id|size
)paren
suffix:semicolon
r_return
id|page_remapped
ques
c_cond
(paren
id|page_remapped
op_plus
id|page_offs
)paren
suffix:colon
l_int|0UL
suffix:semicolon
)brace
DECL|function|pci_unmap_mem
r_static
r_void
id|__init
id|pci_unmap_mem
c_func
(paren
id|u_long
id|vaddr
comma
id|u_long
id|size
)paren
(brace
r_if
c_cond
(paren
id|vaddr
)paren
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|vaddr
op_amp
id|PAGE_MASK
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; *  Used to retrieve the host structure when the &n; *  driver is called from the proc FS.&n; */
DECL|variable|first_host
r_static
r_struct
id|Scsi_Host
op_star
id|first_host
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; *  /proc directory entry and proc_info.&n; */
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2,3,27)
DECL|variable|proc_scsi_sym53c8xx
r_static
r_struct
id|proc_dir_entry
id|proc_scsi_sym53c8xx
op_assign
(brace
id|PROC_SCSI_SYM53C8XX
comma
l_int|9
comma
id|NAME53C8XX
comma
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
comma
l_int|2
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *  Transfer direction&n; *&n; *  Until some linux kernel version near 2.3.40, low-level scsi &n; *  drivers were not told about data transfer direction.&n; */
macro_line|#if LINUX_VERSION_CODE &gt; LinuxVersionCode(2, 3, 40)
DECL|macro|scsi_data_direction
mdefine_line|#define scsi_data_direction(cmd)&t;(cmd-&gt;sc_data_direction)
macro_line|#else
DECL|function|scsi_data_direction
r_static
id|__inline__
r_int
id|scsi_data_direction
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|direction
suffix:semicolon
r_switch
c_cond
(paren
(paren
r_int
)paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|0x08
suffix:colon
multiline_comment|/*&t;READ(6)&t;&t;&t;&t;08 */
r_case
l_int|0x28
suffix:colon
multiline_comment|/*&t;READ(10)&t;&t;&t;28 */
r_case
l_int|0xA8
suffix:colon
multiline_comment|/*&t;READ(12)&t;&t;&t;A8 */
id|direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0A
suffix:colon
multiline_comment|/*&t;WRITE(6)&t;&t;&t;0A */
r_case
l_int|0x2A
suffix:colon
multiline_comment|/*&t;WRITE(10)&t;&t;&t;2A */
r_case
l_int|0xAA
suffix:colon
multiline_comment|/*&t;WRITE(12)&t;&t;&t;AA */
id|direction
op_assign
id|SCSI_DATA_WRITE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|direction
op_assign
id|SCSI_DATA_UNKNOWN
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|direction
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; *  Driver host data structure.&n; */
DECL|struct|host_data
r_struct
id|host_data
(brace
DECL|member|ncb
id|hcb_p
id|ncb
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Some type that fit DMA addresses as seen from BUS.&n; */
macro_line|#ifndef SYM_LINUX_DYNAMIC_DMA_MAPPING
DECL|typedef|bus_addr_t
r_typedef
id|u_long
id|bus_addr_t
suffix:semicolon
macro_line|#else
macro_line|#if&t;SYM_CONF_DMA_ADDRESSING_MODE &gt; 0
DECL|typedef|bus_addr_t
r_typedef
id|dma64_addr_t
id|bus_addr_t
suffix:semicolon
macro_line|#else
DECL|typedef|bus_addr_t
r_typedef
id|dma_addr_t
id|bus_addr_t
suffix:semicolon
macro_line|#endif
macro_line|#endif
multiline_comment|/*&n; *  Used by the eh thread to wait for command completion.&n; *  It is allocated on the eh thread stack.&n; */
DECL|struct|sym_eh_wait
r_struct
id|sym_eh_wait
(brace
DECL|member|sem
r_struct
id|semaphore
id|sem
suffix:semicolon
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
DECL|member|old_done
r_void
(paren
op_star
id|old_done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
DECL|member|to_do
r_int
id|to_do
suffix:semicolon
DECL|member|timed_out
r_int
id|timed_out
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; *  Driver private area in the SCSI command structure.&n; */
DECL|struct|sym_ucmd
r_struct
id|sym_ucmd
(brace
multiline_comment|/* Override the SCSI pointer structure */
DECL|member|link_cmdq
id|SYM_QUEHEAD
id|link_cmdq
suffix:semicolon
multiline_comment|/* Must stay at offset ZERO */
macro_line|#ifdef SYM_LINUX_DYNAMIC_DMA_MAPPING
DECL|member|data_mapping
id|bus_addr_t
id|data_mapping
suffix:semicolon
DECL|member|data_mapped
id|u_char
id|data_mapped
suffix:semicolon
macro_line|#endif
DECL|member|eh_wait
r_struct
id|sym_eh_wait
op_star
id|eh_wait
suffix:semicolon
)brace
suffix:semicolon
DECL|typedef|ucmd_p
r_typedef
r_struct
id|sym_ucmd
op_star
id|ucmd_p
suffix:semicolon
DECL|macro|SYM_UCMD_PTR
mdefine_line|#define SYM_UCMD_PTR(cmd)  ((ucmd_p)(&amp;(cmd)-&gt;SCp))
DECL|macro|SYM_SCMD_PTR
mdefine_line|#define SYM_SCMD_PTR(ucmd) sym_que_entry(ucmd, Scsi_Cmnd, SCp)
DECL|macro|SYM_SOFTC_PTR
mdefine_line|#define SYM_SOFTC_PTR(cmd) (((struct host_data *)cmd-&gt;host-&gt;hostdata)-&gt;ncb)
multiline_comment|/*&n; *  Deal with DMA mapping/unmapping.&n; */
macro_line|#ifndef SYM_LINUX_DYNAMIC_DMA_MAPPING
multiline_comment|/* Linux versions prior to pci bus iommu kernel interface */
DECL|macro|__unmap_scsi_data
mdefine_line|#define __unmap_scsi_data(pdev, cmd)&t;do {; } while (0)
DECL|macro|__map_scsi_single_data
mdefine_line|#define __map_scsi_single_data(pdev, cmd) (__vtobus(pdev,(cmd)-&gt;request_buffer))
DECL|macro|__map_scsi_sg_data
mdefine_line|#define __map_scsi_sg_data(pdev, cmd)&t;((cmd)-&gt;use_sg)
DECL|macro|__sync_scsi_data
mdefine_line|#define __sync_scsi_data(pdev, cmd)&t;do {; } while (0)
DECL|macro|bus_sg_dma_address
mdefine_line|#define bus_sg_dma_address(sc)&t;&t;vtobus((sc)-&gt;address)
DECL|macro|bus_sg_dma_len
mdefine_line|#define bus_sg_dma_len(sc)&t;&t;((sc)-&gt;length)
macro_line|#else /* Linux version with pci bus iommu kernel interface */
DECL|macro|bus_unmap_sg
mdefine_line|#define&t;bus_unmap_sg(pdev, sgptr, sgcnt, dir)&t;&t;&bslash;&n;&t;pci_unmap_sg(pdev, sgptr, sgcnt, dir)
DECL|macro|bus_unmap_single
mdefine_line|#define&t;bus_unmap_single(pdev, mapping, bufptr, dir)&t;&bslash;&n;&t;pci_unmap_single(pdev, mapping, bufptr, dir)
DECL|macro|bus_map_single
mdefine_line|#define&t;bus_map_single(pdev, bufptr, bufsiz, dir)&t;&bslash;&n;&t;pci_map_single(pdev, bufptr, bufsiz, dir)
DECL|macro|bus_map_sg
mdefine_line|#define&t;bus_map_sg(pdev, sgptr, sgcnt, dir)&t;&t;&bslash;&n;&t;pci_map_sg(pdev, sgptr, sgcnt, dir)
DECL|macro|bus_dma_sync_sg
mdefine_line|#define&t;bus_dma_sync_sg(pdev, sgptr, sgcnt, dir)&t;&bslash;&n;&t;pci_dma_sync_sg(pdev, sgptr, sgcnt, dir)
DECL|macro|bus_dma_sync_single
mdefine_line|#define&t;bus_dma_sync_single(pdev, mapping, bufsiz, dir)&t;&bslash;&n;&t;pci_dma_sync_single(pdev, mapping, bufsiz, dir)
DECL|macro|bus_sg_dma_address
mdefine_line|#define bus_sg_dma_address(sc)&t;sg_dma_address(sc)
DECL|macro|bus_sg_dma_len
mdefine_line|#define bus_sg_dma_len(sc)&t;sg_dma_len(sc)
DECL|function|__unmap_scsi_data
r_static
r_void
id|__unmap_scsi_data
c_func
(paren
id|pcidev_t
id|pdev
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|dma_dir
op_assign
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapped
)paren
(brace
r_case
l_int|2
suffix:colon
id|bus_unmap_sg
c_func
(paren
id|pdev
comma
id|cmd-&gt;buffer
comma
id|cmd-&gt;use_sg
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|bus_unmap_single
c_func
(paren
id|pdev
comma
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapping
comma
id|cmd-&gt;request_bufflen
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapped
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|__map_scsi_single_data
r_static
id|bus_addr_t
id|__map_scsi_single_data
c_func
(paren
id|pcidev_t
id|pdev
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|bus_addr_t
id|mapping
suffix:semicolon
r_int
id|dma_dir
op_assign
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
id|mapping
op_assign
id|bus_map_single
c_func
(paren
id|pdev
comma
id|cmd-&gt;request_buffer
comma
id|cmd-&gt;request_bufflen
comma
id|dma_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mapping
)paren
(brace
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapped
op_assign
l_int|1
suffix:semicolon
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapping
op_assign
id|mapping
suffix:semicolon
)brace
r_return
id|mapping
suffix:semicolon
)brace
DECL|function|__map_scsi_sg_data
r_static
r_int
id|__map_scsi_sg_data
c_func
(paren
id|pcidev_t
id|pdev
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|use_sg
suffix:semicolon
r_int
id|dma_dir
op_assign
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
id|use_sg
op_assign
id|bus_map_sg
c_func
(paren
id|pdev
comma
id|cmd-&gt;buffer
comma
id|cmd-&gt;use_sg
comma
id|dma_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|use_sg
OG
l_int|0
)paren
(brace
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapped
op_assign
l_int|2
suffix:semicolon
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapping
op_assign
id|use_sg
suffix:semicolon
)brace
r_return
id|use_sg
suffix:semicolon
)brace
DECL|function|__sync_scsi_data
r_static
r_void
id|__sync_scsi_data
c_func
(paren
id|pcidev_t
id|pdev
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|dma_dir
op_assign
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapped
)paren
(brace
r_case
l_int|2
suffix:colon
id|bus_dma_sync_sg
c_func
(paren
id|pdev
comma
id|cmd-&gt;buffer
comma
id|cmd-&gt;use_sg
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|bus_dma_sync_single
c_func
(paren
id|pdev
comma
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapping
comma
id|cmd-&gt;request_bufflen
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* SYM_LINUX_DYNAMIC_DMA_MAPPING */
DECL|macro|unmap_scsi_data
mdefine_line|#define unmap_scsi_data(np, cmd)&t;&bslash;&n;&t;&t;__unmap_scsi_data(np-&gt;s.device, cmd)
DECL|macro|map_scsi_single_data
mdefine_line|#define map_scsi_single_data(np, cmd)&t;&bslash;&n;&t;&t;__map_scsi_single_data(np-&gt;s.device, cmd)
DECL|macro|map_scsi_sg_data
mdefine_line|#define map_scsi_sg_data(np, cmd)&t;&bslash;&n;&t;&t;__map_scsi_sg_data(np-&gt;s.device, cmd)
DECL|macro|sync_scsi_data
mdefine_line|#define sync_scsi_data(np, cmd)&t;&t;&bslash;&n;&t;&t;__sync_scsi_data(np-&gt;s.device, cmd)
multiline_comment|/*&n; *  Complete a pending CAM CCB.&n; */
DECL|function|sym_xpt_done
r_void
id|sym_xpt_done
c_func
(paren
id|hcb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|ccb
)paren
(brace
id|sym_remque
c_func
(paren
op_amp
id|SYM_UCMD_PTR
c_func
(paren
id|ccb
)paren
op_member_access_from_pointer
id|link_cmdq
)paren
suffix:semicolon
id|unmap_scsi_data
c_func
(paren
id|np
comma
id|ccb
)paren
suffix:semicolon
id|ccb
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|ccb
)paren
suffix:semicolon
)brace
DECL|function|sym_xpt_done2
r_void
id|sym_xpt_done2
c_func
(paren
id|hcb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|ccb
comma
r_int
id|cam_status
)paren
(brace
id|sym_set_cam_status
c_func
(paren
id|ccb
comma
id|cam_status
)paren
suffix:semicolon
id|sym_xpt_done
c_func
(paren
id|np
comma
id|ccb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Print something that identifies the IO.&n; */
DECL|function|sym_print_addr
r_void
id|sym_print_addr
(paren
id|ccb_p
id|cp
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
op_assign
id|cp-&gt;cam_ccb
suffix:semicolon
r_if
c_cond
(paren
id|cmd
)paren
id|printf
c_func
(paren
l_string|&quot;%s:%d:%d:&quot;
comma
id|sym_name
c_func
(paren
id|SYM_SOFTC_PTR
c_func
(paren
id|cmd
)paren
)paren
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Tell the SCSI layer about a BUS RESET.&n; */
DECL|function|sym_xpt_async_bus_reset
r_void
id|sym_xpt_async_bus_reset
c_func
(paren
id|hcb_p
id|np
)paren
(brace
id|printf_notice
c_func
(paren
l_string|&quot;%s: SCSI BUS has been reset.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;s.settle_time
op_assign
id|ktime_get
c_func
(paren
id|sym_driver_setup.settle_delay
op_star
id|HZ
)paren
suffix:semicolon
id|np-&gt;s.settle_time_valid
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sym_verbose
op_ge
l_int|2
)paren
id|printf_info
c_func
(paren
l_string|&quot;%s: command processing suspended for %d seconds&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|sym_driver_setup.settle_delay
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Tell the SCSI layer about a BUS DEVICE RESET message sent.&n; */
DECL|function|sym_xpt_async_sent_bdr
r_void
id|sym_xpt_async_sent_bdr
c_func
(paren
id|hcb_p
id|np
comma
r_int
id|target
)paren
(brace
id|printf_notice
c_func
(paren
l_string|&quot;%s: TARGET %d has been reset.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|target
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Tell the SCSI layer about the new transfer parameters.&n; */
DECL|function|sym_xpt_async_nego_wide
r_void
id|sym_xpt_async_nego_wide
c_func
(paren
id|hcb_p
id|np
comma
r_int
id|target
)paren
(brace
r_if
c_cond
(paren
id|sym_verbose
OL
l_int|3
)paren
r_return
suffix:semicolon
id|sym_announce_transfer_rate
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Choose the more appropriate CAM status if &n; *  the IO encountered an extended error.&n; */
DECL|function|sym_xerr_cam_status
r_static
r_int
id|sym_xerr_cam_status
c_func
(paren
r_int
id|cam_status
comma
r_int
id|x_status
)paren
(brace
r_if
c_cond
(paren
id|x_status
)paren
(brace
r_if
c_cond
(paren
id|x_status
op_amp
id|XE_PARITY_ERR
)paren
id|cam_status
op_assign
id|DID_PARITY
suffix:semicolon
r_else
r_if
c_cond
(paren
id|x_status
op_amp
(paren
id|XE_EXTRA_DATA
op_or
id|XE_SODL_UNRUN
op_or
id|XE_SWIDE_OVRUN
)paren
)paren
id|cam_status
op_assign
id|DID_ERROR
suffix:semicolon
r_else
r_if
c_cond
(paren
id|x_status
op_amp
id|XE_BAD_PHASE
)paren
id|cam_status
op_assign
id|DID_ERROR
suffix:semicolon
r_else
id|cam_status
op_assign
id|DID_ERROR
suffix:semicolon
)brace
r_return
id|cam_status
suffix:semicolon
)brace
multiline_comment|/*&n; *  Build CAM result for a failed or auto-sensed IO.&n; */
DECL|function|sym_set_cam_result_error
r_void
id|sym_set_cam_result_error
c_func
(paren
id|hcb_p
id|np
comma
id|ccb_p
id|cp
comma
r_int
id|resid
)paren
(brace
id|Scsi_Cmnd
op_star
id|csio
op_assign
id|cp-&gt;cam_ccb
suffix:semicolon
id|u_int
id|cam_status
comma
id|scsi_status
comma
id|drv_status
suffix:semicolon
id|drv_status
op_assign
l_int|0
suffix:semicolon
id|cam_status
op_assign
id|DID_OK
suffix:semicolon
id|scsi_status
op_assign
id|cp-&gt;ssss_status
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;host_flags
op_amp
id|HF_SENSE
)paren
(brace
id|scsi_status
op_assign
id|cp-&gt;sv_scsi_status
suffix:semicolon
id|resid
op_assign
id|cp-&gt;sv_resid
suffix:semicolon
r_if
c_cond
(paren
id|sym_verbose
op_logical_and
id|cp-&gt;sv_xerr_status
)paren
id|sym_print_xerr
c_func
(paren
id|cp
comma
id|cp-&gt;sv_xerr_status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
op_logical_and
id|cp-&gt;ssss_status
op_eq
id|S_GOOD
op_logical_and
id|cp-&gt;xerr_status
op_eq
l_int|0
)paren
(brace
id|cam_status
op_assign
id|sym_xerr_cam_status
c_func
(paren
id|DID_OK
comma
id|cp-&gt;sv_xerr_status
)paren
suffix:semicolon
id|drv_status
op_assign
id|DRIVER_SENSE
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  Bounce back the sense data to user.&n;&t;&t;&t; */
id|bzero
c_func
(paren
op_amp
id|csio-&gt;sense_buffer
comma
r_sizeof
(paren
id|csio-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|bcopy
c_func
(paren
id|cp-&gt;sns_bbuf
comma
id|csio-&gt;sense_buffer
comma
id|MIN
c_func
(paren
r_sizeof
(paren
id|csio-&gt;sense_buffer
)paren
comma
id|SYM_SNS_BBUF_LEN
)paren
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n;&t;&t;&t; *  If the device reports a UNIT ATTENTION condition &n;&t;&t;&t; *  due to a RESET condition, we should consider all &n;&t;&t;&t; *  disconnect CCBs for this unit as aborted.&n;&t;&t;&t; */
r_if
c_cond
(paren
l_int|1
)paren
(brace
id|u_char
op_star
id|p
suffix:semicolon
id|p
op_assign
(paren
id|u_char
op_star
)paren
id|csio-&gt;sense_data
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
op_eq
l_int|0x70
op_logical_and
id|p
(braket
l_int|2
)braket
op_eq
l_int|0x6
op_logical_and
id|p
(braket
l_int|12
)braket
op_eq
l_int|0x29
)paren
id|sym_clear_tasks
c_func
(paren
id|np
comma
id|DID_ABORT
comma
id|cp-&gt;target
comma
id|cp-&gt;lun
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_else
id|cam_status
op_assign
id|DID_ERROR
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
multiline_comment|/* Bad SCSI status */
id|cam_status
op_assign
id|DID_OK
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_SEL_TIMEOUT
)paren
multiline_comment|/* Selection timeout */
id|cam_status
op_assign
id|DID_NO_CONNECT
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_UNEXPECTED
)paren
multiline_comment|/* Unexpected BUS FREE*/
id|cam_status
op_assign
id|DID_ERROR
suffix:semicolon
r_else
(brace
multiline_comment|/* Extended error */
r_if
c_cond
(paren
id|sym_verbose
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;COMMAND FAILED (%x %x %x).&bslash;n&quot;
comma
id|cp-&gt;host_status
comma
id|cp-&gt;ssss_status
comma
id|cp-&gt;xerr_status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Set the most appropriate value for CAM status.&n;&t;&t; */
id|cam_status
op_assign
id|sym_xerr_cam_status
c_func
(paren
id|DID_ERROR
comma
id|cp-&gt;xerr_status
)paren
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,3,99)
id|csio-&gt;resid
op_assign
id|resid
suffix:semicolon
macro_line|#endif
id|csio-&gt;result
op_assign
(paren
id|drv_status
op_lshift
l_int|24
)paren
op_plus
(paren
id|cam_status
op_lshift
l_int|16
)paren
op_plus
id|scsi_status
suffix:semicolon
)brace
multiline_comment|/*&n; *  Called on successfull INQUIRY response.&n; */
DECL|function|sym_sniff_inquiry
r_void
id|sym_sniff_inquiry
c_func
(paren
id|hcb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|resid
)paren
(brace
r_int
id|retv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
op_logical_or
id|cmd-&gt;use_sg
)paren
r_return
suffix:semicolon
id|sync_scsi_data
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
id|retv
op_assign
id|__sym_sniff_inquiry
c_func
(paren
id|np
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
(paren
id|u_char
op_star
)paren
id|cmd-&gt;request_buffer
comma
id|cmd-&gt;request_bufflen
op_minus
id|resid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retv
OL
l_int|0
)paren
r_return
suffix:semicolon
r_else
r_if
c_cond
(paren
id|retv
)paren
id|sym_update_trans_settings
c_func
(paren
id|np
comma
op_amp
id|np-&gt;target
(braket
id|cmd-&gt;target
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Build the scatter/gather array for an I/O.&n; */
DECL|function|sym_scatter_no_sglist
r_static
r_int
id|sym_scatter_no_sglist
c_func
(paren
id|hcb_p
id|np
comma
id|ccb_p
id|cp
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|sym_tblmove
op_star
id|data
op_assign
op_amp
id|cp-&gt;phys.data
(braket
id|SYM_CONF_MAX_SG
op_minus
l_int|1
)braket
suffix:semicolon
r_int
id|segment
suffix:semicolon
id|cp-&gt;data_len
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
)paren
(brace
id|bus_addr_t
id|baddr
op_assign
id|map_scsi_single_data
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|baddr
)paren
(brace
id|sym_build_sge
c_func
(paren
id|np
comma
id|data
comma
id|baddr
comma
id|cmd-&gt;request_bufflen
)paren
suffix:semicolon
id|segment
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|segment
op_assign
op_minus
l_int|2
suffix:semicolon
)brace
r_else
id|segment
op_assign
l_int|0
suffix:semicolon
r_return
id|segment
suffix:semicolon
)brace
DECL|function|sym_scatter
r_static
r_int
id|sym_scatter
c_func
(paren
id|hcb_p
id|np
comma
id|ccb_p
id|cp
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|segment
suffix:semicolon
r_int
id|use_sg
op_assign
(paren
r_int
)paren
id|cmd-&gt;use_sg
suffix:semicolon
id|cp-&gt;data_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|use_sg
)paren
id|segment
op_assign
id|sym_scatter_no_sglist
c_func
(paren
id|np
comma
id|cp
comma
id|cmd
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|use_sg
op_assign
id|map_scsi_sg_data
c_func
(paren
id|np
comma
id|cmd
)paren
)paren
OG
l_int|0
)paren
(brace
r_struct
id|scatterlist
op_star
id|scatter
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
suffix:semicolon
r_struct
id|sym_tblmove
op_star
id|data
suffix:semicolon
r_if
c_cond
(paren
id|use_sg
OG
id|SYM_CONF_MAX_SG
)paren
(brace
id|unmap_scsi_data
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|data
op_assign
op_amp
id|cp-&gt;phys.data
(braket
id|SYM_CONF_MAX_SG
op_minus
id|use_sg
)braket
suffix:semicolon
r_for
c_loop
(paren
id|segment
op_assign
l_int|0
suffix:semicolon
id|segment
OL
id|use_sg
suffix:semicolon
id|segment
op_increment
)paren
(brace
id|bus_addr_t
id|baddr
op_assign
id|bus_sg_dma_address
c_func
(paren
op_amp
id|scatter
(braket
id|segment
)braket
)paren
suffix:semicolon
r_int
r_int
id|len
op_assign
id|bus_sg_dma_len
c_func
(paren
op_amp
id|scatter
(braket
id|segment
)braket
)paren
suffix:semicolon
id|sym_build_sge
c_func
(paren
id|np
comma
op_amp
id|data
(braket
id|segment
)braket
comma
id|baddr
comma
id|len
)paren
suffix:semicolon
id|cp-&gt;data_len
op_add_assign
id|len
suffix:semicolon
)brace
)brace
r_else
id|segment
op_assign
op_minus
l_int|2
suffix:semicolon
r_return
id|segment
suffix:semicolon
)brace
multiline_comment|/*&n; *  Queue a SCSI command.&n; */
DECL|function|sym_queue_command
r_static
r_int
id|sym_queue_command
c_func
(paren
id|hcb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|ccb
)paren
(brace
multiline_comment|/*&t;Scsi_Device        *device    = ccb-&gt;device; */
id|tcb_p
id|tp
suffix:semicolon
id|lcb_p
id|lp
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
r_int
id|order
suffix:semicolon
multiline_comment|/*&n;&t; *  Minimal checkings, so that we will not &n;&t; *  go outside our tables.&n;&t; */
r_if
c_cond
(paren
id|ccb-&gt;target
op_eq
id|np-&gt;myaddr
op_logical_or
id|ccb-&gt;target
op_ge
id|SYM_CONF_MAX_TARGET
op_logical_or
id|ccb-&gt;lun
op_ge
id|SYM_CONF_MAX_LUN
)paren
(brace
id|sym_xpt_done2
c_func
(paren
id|np
comma
id|ccb
comma
id|CAM_DEV_NOT_THERE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Retreive the target descriptor.&n;&t; */
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|ccb-&gt;target
)braket
suffix:semicolon
multiline_comment|/*&n;&t; *  Complete the 1st INQUIRY command with error &n;&t; *  condition if the device is flagged NOSCAN &n;&t; *  at BOOT in the NVRAM. This may speed up &n;&t; *  the boot and maintain coherency with BIOS &n;&t; *  device numbering. Clearing the flag allows &n;&t; *  user to rescan skipped devices later.&n;&t; *  We also return error for devices not flagged &n;&t; *  for SCAN LUNS in the NVRAM since some mono-lun &n;&t; *  devices behave badly when asked for some non &n;&t; *  zero LUN. Btw, this is an absolute hack.:-)&n;&t; */
r_if
c_cond
(paren
id|ccb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
l_int|0x12
op_logical_or
id|ccb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
l_int|0x0
)paren
(brace
r_if
c_cond
(paren
(paren
id|tp-&gt;usrflags
op_amp
id|SYM_SCAN_BOOT_DISABLED
)paren
op_logical_or
(paren
(paren
id|tp-&gt;usrflags
op_amp
id|SYM_SCAN_LUNS_DISABLED
)paren
op_logical_and
id|ccb-&gt;lun
op_ne
l_int|0
)paren
)paren
(brace
id|tp-&gt;usrflags
op_and_assign
op_complement
id|SYM_SCAN_BOOT_DISABLED
suffix:semicolon
id|sym_xpt_done2
c_func
(paren
id|np
comma
id|ccb
comma
id|CAM_DEV_NOT_THERE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *  Select tagged/untagged.&n;&t; */
id|lp
op_assign
id|sym_lp
c_func
(paren
id|np
comma
id|tp
comma
id|ccb-&gt;lun
)paren
suffix:semicolon
id|order
op_assign
(paren
id|lp
op_logical_and
id|lp-&gt;s.reqtags
)paren
ques
c_cond
id|M_SIMPLE_TAG
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  Queue the SCSI IO.&n;&t; */
id|cp
op_assign
id|sym_get_ccb
c_func
(paren
id|np
comma
id|ccb-&gt;target
comma
id|ccb-&gt;lun
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Means resource shortage */
(paren
r_void
)paren
id|sym_queue_scsiio
c_func
(paren
id|np
comma
id|ccb
comma
id|cp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Setup buffers and pointers that address the CDB.&n; */
DECL|function|sym_setup_cdb
r_static
r_int
id|__inline
id|sym_setup_cdb
c_func
(paren
id|hcb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|ccb
comma
id|ccb_p
id|cp
)paren
(brace
id|u32
id|cmd_ba
suffix:semicolon
r_int
id|cmd_len
suffix:semicolon
multiline_comment|/*&n;&t; *  CDB is 16 bytes max.&n;&t; */
r_if
c_cond
(paren
id|ccb-&gt;cmd_len
OG
r_sizeof
(paren
id|cp-&gt;cdb_buf
)paren
)paren
(brace
id|sym_set_cam_status
c_func
(paren
id|cp-&gt;cam_ccb
comma
id|CAM_REQ_INVALID
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|bcopy
c_func
(paren
id|ccb-&gt;cmnd
comma
id|cp-&gt;cdb_buf
comma
id|ccb-&gt;cmd_len
)paren
suffix:semicolon
id|cmd_ba
op_assign
id|CCB_BA
(paren
id|cp
comma
id|cdb_buf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|cmd_len
op_assign
id|ccb-&gt;cmd_len
suffix:semicolon
id|cp-&gt;phys.cmd.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|cmd_ba
)paren
suffix:semicolon
id|cp-&gt;phys.cmd.size
op_assign
id|cpu_to_scr
c_func
(paren
id|cmd_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Setup pointers that address the data and start the I/O.&n; */
DECL|function|sym_setup_data_and_start
r_int
id|sym_setup_data_and_start
c_func
(paren
id|hcb_p
id|np
comma
id|Scsi_Cmnd
op_star
id|csio
comma
id|ccb_p
id|cp
)paren
(brace
r_int
id|dir
suffix:semicolon
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cp-&gt;target
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|sym_lp
c_func
(paren
id|np
comma
id|tp
comma
id|cp-&gt;lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Build the CDB.&n;&t; */
r_if
c_cond
(paren
id|sym_setup_cdb
c_func
(paren
id|np
comma
id|csio
comma
id|cp
)paren
)paren
r_goto
id|out_abort
suffix:semicolon
multiline_comment|/*&n;&t; *  No direction means no data.&n;&t; */
id|dir
op_assign
id|scsi_data_direction
c_func
(paren
id|csio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_ne
id|SCSI_DATA_NONE
)paren
(brace
id|cp-&gt;segments
op_assign
id|sym_scatter
(paren
id|np
comma
id|cp
comma
id|csio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;segments
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;segments
op_eq
op_minus
l_int|2
)paren
id|sym_set_cam_status
c_func
(paren
id|csio
comma
id|CAM_RESRC_UNAVAIL
)paren
suffix:semicolon
r_else
id|sym_set_cam_status
c_func
(paren
id|csio
comma
id|CAM_REQ_TOO_BIG
)paren
suffix:semicolon
r_goto
id|out_abort
suffix:semicolon
)brace
)brace
r_else
(brace
id|cp-&gt;data_len
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;segments
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Set data pointers.&n;&t; */
id|sym_setup_data_pointers
c_func
(paren
id|np
comma
id|cp
comma
id|dir
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  When `#ifed 1&squot;, the code below makes the driver &n;&t; *  panic on the first attempt to write to a SCSI device.&n;&t; *  It is the first test we want to do after a driver &n;&t; *  change that does not seem obviously safe. :)&n;&t; */
macro_line|#if 0
r_switch
c_cond
(paren
id|cp-&gt;cdb_buf
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|0x0A
suffix:colon
r_case
l_int|0x2A
suffix:colon
r_case
l_int|0xAA
suffix:colon
id|panic
c_func
(paren
l_string|&quot;XXXXXXXXXXXXX WRITE NOT YET ALLOWED XXXXXXXXXXXXXX&bslash;n&quot;
)paren
suffix:semicolon
id|MDELAY
c_func
(paren
l_int|10000
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; *&t;activate this job.&n;&t; */
r_if
c_cond
(paren
id|lp
)paren
id|sym_start_next_ccbs
c_func
(paren
id|np
comma
id|lp
comma
l_int|2
)paren
suffix:semicolon
r_else
id|sym_put_start_queue
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_abort
suffix:colon
id|sym_free_ccb
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
id|sym_xpt_done
c_func
(paren
id|np
comma
id|csio
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  timer daemon.&n; *&n; *  Misused to keep the driver running when&n; *  interrupts are not configured correctly.&n; */
DECL|function|sym_timer
r_static
r_void
id|sym_timer
(paren
id|hcb_p
id|np
)paren
(brace
id|u_long
id|thistime
op_assign
id|ktime_get
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2, 4, 0)
multiline_comment|/*&n;&t; *  If release process in progress, let&squot;s go&n;&t; *  Set the release stage from 1 to 2 to synchronize&n;&t; *  with the release process.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;s.release_stage
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;s.release_stage
op_eq
l_int|1
)paren
id|np-&gt;s.release_stage
op_assign
l_int|2
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; *  Restart the timer.&n;&t; */
macro_line|#ifdef SYM_CONF_PCIQ_BROKEN_INTR
id|np-&gt;s.timer.expires
op_assign
id|ktime_get
c_func
(paren
(paren
id|HZ
op_plus
l_int|99
)paren
op_div
l_int|100
)paren
suffix:semicolon
macro_line|#else
id|np-&gt;s.timer.expires
op_assign
id|ktime_get
c_func
(paren
id|SYM_CONF_TIMER_INTERVAL
)paren
suffix:semicolon
macro_line|#endif
id|add_timer
c_func
(paren
op_amp
id|np-&gt;s.timer
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  If we are resetting the ncr, wait for settle_time before &n;&t; *  clearing it. Then command processing will be resumed.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;s.settle_time_valid
)paren
(brace
r_if
c_cond
(paren
id|ktime_dif
c_func
(paren
id|np-&gt;s.settle_time
comma
id|thistime
)paren
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|sym_verbose
op_ge
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot;%s: command processing resumed&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;s.settle_time_valid
op_assign
l_int|0
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Nothing to do for now, but that may come.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;s.lasttime
op_plus
l_int|4
op_star
id|HZ
OL
id|thistime
)paren
(brace
id|np-&gt;s.lasttime
op_assign
id|thistime
suffix:semicolon
)brace
macro_line|#ifdef SYM_CONF_PCIQ_MAY_MISS_COMPLETIONS
multiline_comment|/*&n;&t; *  Some way-broken PCI bridges may lead to &n;&t; *  completions being lost when the clearing &n;&t; *  of the INTFLY flag by the CPU occurs &n;&t; *  concurrently with the chip raising this flag.&n;&t; *  If this ever happen, lost completions will &n;&t; * be reaped here.&n;&t; */
id|sym_wakeup_done
c_func
(paren
id|np
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SYM_CONF_PCIQ_BROKEN_INTR
r_if
c_cond
(paren
id|INB
c_func
(paren
id|nc_istat
)paren
op_amp
(paren
id|INTF
op_or
id|SIP
op_or
id|DIP
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;**&t;Process pending interrupts.&n;&t;&t;*/
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;{&quot;
)paren
suffix:semicolon
id|sym_interrupt
c_func
(paren
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printk
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* SYM_CONF_PCIQ_BROKEN_INTR */
)brace
multiline_comment|/*&n; *  PCI BUS error handler.&n; */
DECL|function|sym_log_bus_error
r_void
id|sym_log_bus_error
c_func
(paren
id|hcb_p
id|np
)paren
(brace
id|u_short
id|pci_sts
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|np-&gt;s.device
comma
id|PCI_STATUS
comma
op_amp
id|pci_sts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_sts
op_amp
l_int|0xf900
)paren
(brace
id|pci_write_config_word
c_func
(paren
id|np-&gt;s.device
comma
id|PCI_STATUS
comma
id|pci_sts
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: PCI STATUS = 0x%04x&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|pci_sts
op_amp
l_int|0xf900
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *  Requeue awaiting commands.&n; */
DECL|function|sym_requeue_awaiting_cmds
r_static
r_void
id|sym_requeue_awaiting_cmds
c_func
(paren
id|hcb_p
id|np
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
id|ucmd_p
id|ucp
op_assign
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|SYM_QUEHEAD
id|tmp_cmdq
suffix:semicolon
r_int
id|sts
suffix:semicolon
id|sym_que_move
c_func
(paren
op_amp
id|np-&gt;s.wait_cmdq
comma
op_amp
id|tmp_cmdq
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ucp
op_assign
(paren
id|ucmd_p
)paren
id|sym_remque_head
c_func
(paren
op_amp
id|tmp_cmdq
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|sym_insque_tail
c_func
(paren
op_amp
id|ucp-&gt;link_cmdq
comma
op_amp
id|np-&gt;s.busy_cmdq
)paren
suffix:semicolon
id|cmd
op_assign
id|SYM_SCMD_PTR
c_func
(paren
id|ucp
)paren
suffix:semicolon
id|sts
op_assign
id|sym_queue_command
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sts
)paren
(brace
id|sym_remque
c_func
(paren
op_amp
id|ucp-&gt;link_cmdq
)paren
suffix:semicolon
id|sym_insque_head
c_func
(paren
op_amp
id|ucp-&gt;link_cmdq
comma
op_amp
id|np-&gt;s.wait_cmdq
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; *  Linux entry point of the queuecommand() function&n; */
DECL|function|sym53c8xx_queue_command
r_int
id|sym53c8xx_queue_command
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
id|hcb_p
id|np
op_assign
id|SYM_SOFTC_PTR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|ucmd_p
id|ucp
op_assign
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_int
id|sts
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0
id|u_long
id|flags
suffix:semicolon
macro_line|#endif
id|cmd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|ucp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ucp
)paren
)paren
suffix:semicolon
macro_line|#if 0
id|SYM_LOCK_HCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *  Shorten our settle_time if needed for &n;&t; *  this command not to time out.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;s.settle_time_valid
op_logical_and
id|cmd-&gt;timeout_per_command
)paren
(brace
id|u_long
id|tlimit
op_assign
id|ktime_get
c_func
(paren
id|cmd-&gt;timeout_per_command
)paren
suffix:semicolon
id|tlimit
op_assign
id|ktime_sub
c_func
(paren
id|tlimit
comma
id|SYM_CONF_TIMER_INTERVAL
op_star
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ktime_dif
c_func
(paren
id|np-&gt;s.settle_time
comma
id|tlimit
)paren
OG
l_int|0
)paren
(brace
id|np-&gt;s.settle_time
op_assign
id|tlimit
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|np-&gt;s.settle_time_valid
op_logical_or
op_logical_neg
id|sym_que_empty
c_func
(paren
op_amp
id|np-&gt;s.wait_cmdq
)paren
)paren
(brace
id|sym_insque_tail
c_func
(paren
op_amp
id|ucp-&gt;link_cmdq
comma
op_amp
id|np-&gt;s.wait_cmdq
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|sym_insque_tail
c_func
(paren
op_amp
id|ucp-&gt;link_cmdq
comma
op_amp
id|np-&gt;s.busy_cmdq
)paren
suffix:semicolon
id|sts
op_assign
id|sym_queue_command
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sts
)paren
(brace
id|sym_remque
c_func
(paren
op_amp
id|ucp-&gt;link_cmdq
)paren
suffix:semicolon
id|sym_insque_tail
c_func
(paren
op_amp
id|ucp-&gt;link_cmdq
comma
op_amp
id|np-&gt;s.wait_cmdq
)paren
suffix:semicolon
)brace
id|out
suffix:colon
macro_line|#if 0
id|SYM_UNLOCK_HCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Linux entry point of the interrupt handler.&n; */
DECL|function|sym53c8xx_intr
r_static
r_void
id|sym53c8xx_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|hcb_p
id|np
op_assign
(paren
id|hcb_p
)paren
id|dev_id
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf_debug
(paren
l_string|&quot;[&quot;
)paren
suffix:semicolon
id|SYM_LOCK_HCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|sym_interrupt
c_func
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * push queue walk-through to tasklet&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sym_que_empty
c_func
(paren
op_amp
id|np-&gt;s.wait_cmdq
)paren
op_logical_and
op_logical_neg
id|np-&gt;s.settle_time_valid
)paren
id|sym_requeue_awaiting_cmds
c_func
(paren
id|np
)paren
suffix:semicolon
id|SYM_UNLOCK_HCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf_debug
(paren
l_string|&quot;]&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Linux entry point of the timer handler&n; */
DECL|function|sym53c8xx_timer
r_static
r_void
id|sym53c8xx_timer
c_func
(paren
r_int
r_int
id|npref
)paren
(brace
id|hcb_p
id|np
op_assign
(paren
id|hcb_p
)paren
id|npref
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|SYM_LOCK_HCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|sym_timer
c_func
(paren
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sym_que_empty
c_func
(paren
op_amp
id|np-&gt;s.wait_cmdq
)paren
op_logical_and
op_logical_neg
id|np-&gt;s.settle_time_valid
)paren
id|sym_requeue_awaiting_cmds
c_func
(paren
id|np
)paren
suffix:semicolon
id|SYM_UNLOCK_HCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  What the eh thread wants us to perform.&n; */
DECL|macro|SYM_EH_ABORT
mdefine_line|#define SYM_EH_ABORT&t;&t;0
DECL|macro|SYM_EH_DEVICE_RESET
mdefine_line|#define SYM_EH_DEVICE_RESET&t;1
DECL|macro|SYM_EH_BUS_RESET
mdefine_line|#define SYM_EH_BUS_RESET&t;2
DECL|macro|SYM_EH_HOST_RESET
mdefine_line|#define SYM_EH_HOST_RESET&t;3
multiline_comment|/*&n; *  What we will do regarding the involved SCSI command.&n; */
DECL|macro|SYM_EH_DO_IGNORE
mdefine_line|#define SYM_EH_DO_IGNORE&t;0
DECL|macro|SYM_EH_DO_COMPLETE
mdefine_line|#define SYM_EH_DO_COMPLETE&t;1
DECL|macro|SYM_EH_DO_WAIT
mdefine_line|#define SYM_EH_DO_WAIT&t;&t;2
multiline_comment|/*&n; *  Our general completion handler.&n; */
DECL|function|__sym_eh_done
r_static
r_void
id|__sym_eh_done
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|timed_out
)paren
(brace
r_struct
id|sym_eh_wait
op_star
id|ep
op_assign
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|eh_wait
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
)paren
r_return
suffix:semicolon
multiline_comment|/* Try to avoid a race here (not 100% safe) */
r_if
c_cond
(paren
op_logical_neg
id|timed_out
)paren
(brace
id|ep-&gt;timed_out
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;to_do
op_eq
id|SYM_EH_DO_WAIT
op_logical_and
op_logical_neg
id|del_timer
c_func
(paren
op_amp
id|ep-&gt;timer
)paren
)paren
r_return
suffix:semicolon
)brace
multiline_comment|/* Revert everything */
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|eh_wait
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|ep-&gt;old_done
suffix:semicolon
multiline_comment|/* Wake up the eh thread if it wants to sleep */
r_if
c_cond
(paren
id|ep-&gt;to_do
op_eq
id|SYM_EH_DO_WAIT
)paren
id|up
c_func
(paren
op_amp
id|ep-&gt;sem
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  scsi_done() alias when error recovery is in progress. &n; */
DECL|function|sym_eh_done
r_static
r_void
id|sym_eh_done
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|__sym_eh_done
c_func
(paren
id|cmd
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Some timeout handler to avoid waiting too long.&n; */
DECL|function|sym_eh_timeout
r_static
r_void
id|sym_eh_timeout
c_func
(paren
id|u_long
id|p
)paren
(brace
id|__sym_eh_done
c_func
(paren
(paren
id|Scsi_Cmnd
op_star
)paren
id|p
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Generic method for our eh processing.&n; *  The &squot;op&squot; argument tells what we have to do.&n; */
DECL|function|sym_eh_handler
r_static
r_int
id|sym_eh_handler
c_func
(paren
r_int
id|op
comma
r_char
op_star
id|opname
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|hcb_p
id|np
op_assign
id|SYM_SOFTC_PTR
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|SYM_QUEHEAD
op_star
id|qp
suffix:semicolon
r_int
id|to_do
op_assign
id|SYM_EH_DO_IGNORE
suffix:semicolon
r_int
id|sts
op_assign
op_minus
l_int|1
suffix:semicolon
r_struct
id|sym_eh_wait
id|eh
comma
op_star
id|ep
op_assign
op_amp
id|eh
suffix:semicolon
r_char
id|devname
(braket
l_int|20
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|devname
comma
l_string|&quot;%s:%d:%d&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|printf_warning
c_func
(paren
l_string|&quot;%s: %s operation started.&bslash;n&quot;
comma
id|devname
comma
id|opname
)paren
suffix:semicolon
id|SYM_LOCK_HCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* This one should be the result of some race, thus to ignore */
r_if
c_cond
(paren
id|cmd-&gt;serial_number
op_ne
id|cmd-&gt;serial_number_at_timeout
)paren
r_goto
id|prepare
suffix:semicolon
macro_line|#endif
multiline_comment|/* This one is not queued to the core driver -&gt; to complete here */
id|FOR_EACH_QUEUED_ELEMENT
c_func
(paren
op_amp
id|np-&gt;s.wait_cmdq
comma
id|qp
)paren
(brace
r_if
c_cond
(paren
id|SYM_SCMD_PTR
c_func
(paren
id|qp
)paren
op_eq
id|cmd
)paren
(brace
id|to_do
op_assign
id|SYM_EH_DO_COMPLETE
suffix:semicolon
r_goto
id|prepare
suffix:semicolon
)brace
)brace
multiline_comment|/* This one is queued in some place -&gt; to wait for completion */
id|FOR_EACH_QUEUED_ELEMENT
c_func
(paren
op_amp
id|np-&gt;busy_ccbq
comma
id|qp
)paren
(brace
id|ccb_p
id|cp
op_assign
id|sym_que_entry
c_func
(paren
id|qp
comma
r_struct
id|sym_ccb
comma
id|link_ccbq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;cam_ccb
op_eq
id|cmd
)paren
(brace
id|to_do
op_assign
id|SYM_EH_DO_WAIT
suffix:semicolon
r_goto
id|prepare
suffix:semicolon
)brace
)brace
id|prepare
suffix:colon
multiline_comment|/* Prepare stuff to either ignore, complete or wait for completion */
r_switch
c_cond
(paren
id|to_do
)paren
(brace
r_default
suffix:colon
r_case
id|SYM_EH_DO_IGNORE
suffix:colon
r_goto
id|finish
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYM_EH_DO_WAIT
suffix:colon
macro_line|#if LINUX_VERSION_CODE &gt; LinuxVersionCode(2,3,0)
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
id|ep-&gt;sem
)paren
suffix:semicolon
macro_line|#else
id|ep-&gt;sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
macro_line|#endif
multiline_comment|/* fall through */
r_case
id|SYM_EH_DO_COMPLETE
suffix:colon
id|ep-&gt;old_done
op_assign
id|cmd-&gt;scsi_done
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|sym_eh_done
suffix:semicolon
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|eh_wait
op_assign
id|ep
suffix:semicolon
)brace
multiline_comment|/* Try to proceed the operation we have been asked for */
id|sts
op_assign
op_minus
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|op
)paren
(brace
r_case
id|SYM_EH_ABORT
suffix:colon
id|sts
op_assign
id|sym_abort_scsiio
c_func
(paren
id|np
comma
id|cmd
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYM_EH_DEVICE_RESET
suffix:colon
id|sts
op_assign
id|sym_reset_scsi_target
c_func
(paren
id|np
comma
id|cmd-&gt;target
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYM_EH_BUS_RESET
suffix:colon
id|sym_reset_scsi_bus
c_func
(paren
id|np
comma
l_int|1
)paren
suffix:semicolon
id|sts
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYM_EH_HOST_RESET
suffix:colon
id|sym_reset_scsi_bus
c_func
(paren
id|np
comma
l_int|0
)paren
suffix:semicolon
id|sym_start_up
(paren
id|np
comma
l_int|1
)paren
suffix:semicolon
id|sts
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/* On error, restore everything and cross fingers :) */
r_if
c_cond
(paren
id|sts
)paren
(brace
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|eh_wait
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|ep-&gt;old_done
suffix:semicolon
id|to_do
op_assign
id|SYM_EH_DO_IGNORE
suffix:semicolon
)brace
id|finish
suffix:colon
id|ep-&gt;to_do
op_assign
id|to_do
suffix:semicolon
multiline_comment|/* Complete the command with locks held as required by the driver */
r_if
c_cond
(paren
id|to_do
op_eq
id|SYM_EH_DO_COMPLETE
)paren
id|sym_xpt_done2
c_func
(paren
id|np
comma
id|cmd
comma
id|CAM_REQ_ABORTED
)paren
suffix:semicolon
id|SYM_UNLOCK_HCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Wait for completion with locks released, as required by kernel */
r_if
c_cond
(paren
id|to_do
op_eq
id|SYM_EH_DO_WAIT
)paren
(brace
id|init_timer
c_func
(paren
op_amp
id|ep-&gt;timer
)paren
suffix:semicolon
id|ep-&gt;timer.expires
op_assign
id|jiffies
op_plus
(paren
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
id|ep-&gt;timer.function
op_assign
id|sym_eh_timeout
suffix:semicolon
id|ep-&gt;timer.data
op_assign
(paren
id|u_long
)paren
id|cmd
suffix:semicolon
id|ep-&gt;timed_out
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Be pessimistic for once :) */
id|add_timer
c_func
(paren
op_amp
id|ep-&gt;timer
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ep-&gt;sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;timed_out
)paren
id|sts
op_assign
op_minus
l_int|2
suffix:semicolon
)brace
id|printf_warning
c_func
(paren
l_string|&quot;%s: %s operation %s.&bslash;n&quot;
comma
id|devname
comma
id|opname
comma
id|sts
op_eq
l_int|0
ques
c_cond
l_string|&quot;complete&quot;
suffix:colon
id|sts
op_eq
op_minus
l_int|2
ques
c_cond
l_string|&quot;timed-out&quot;
suffix:colon
l_string|&quot;failed&quot;
)paren
suffix:semicolon
r_return
id|sts
ques
c_cond
id|SCSI_FAILED
suffix:colon
id|SCSI_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Error handlers called from the eh thread (one thread per HBA).&n; */
DECL|function|sym53c8xx_eh_abort_handler
r_int
id|sym53c8xx_eh_abort_handler
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_return
id|sym_eh_handler
c_func
(paren
id|SYM_EH_ABORT
comma
l_string|&quot;ABORT&quot;
comma
id|cmd
)paren
suffix:semicolon
)brace
DECL|function|sym53c8xx_eh_device_reset_handler
r_int
id|sym53c8xx_eh_device_reset_handler
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_return
id|sym_eh_handler
c_func
(paren
id|SYM_EH_DEVICE_RESET
comma
l_string|&quot;DEVICE RESET&quot;
comma
id|cmd
)paren
suffix:semicolon
)brace
DECL|function|sym53c8xx_eh_bus_reset_handler
r_int
id|sym53c8xx_eh_bus_reset_handler
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_return
id|sym_eh_handler
c_func
(paren
id|SYM_EH_BUS_RESET
comma
l_string|&quot;BUS RESET&quot;
comma
id|cmd
)paren
suffix:semicolon
)brace
DECL|function|sym53c8xx_eh_host_reset_handler
r_int
id|sym53c8xx_eh_host_reset_handler
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_return
id|sym_eh_handler
c_func
(paren
id|SYM_EH_HOST_RESET
comma
l_string|&quot;HOST RESET&quot;
comma
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Tune device queuing depth, according to various limits.&n; */
r_static
r_void
DECL|function|sym_tune_dev_queuing
id|sym_tune_dev_queuing
c_func
(paren
id|hcb_p
id|np
comma
r_int
id|target
comma
r_int
id|lun
comma
id|u_short
id|reqtags
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|sym_lp
c_func
(paren
id|np
comma
id|tp
comma
id|lun
)paren
suffix:semicolon
id|u_short
id|oldtags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
r_return
suffix:semicolon
id|oldtags
op_assign
id|lp-&gt;s.reqtags
suffix:semicolon
r_if
c_cond
(paren
id|reqtags
OG
id|lp-&gt;s.scdev_depth
)paren
id|reqtags
op_assign
id|lp-&gt;s.scdev_depth
suffix:semicolon
id|lp-&gt;started_limit
op_assign
id|reqtags
ques
c_cond
id|reqtags
suffix:colon
l_int|2
suffix:semicolon
id|lp-&gt;started_max
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;s.reqtags
op_assign
id|reqtags
suffix:semicolon
r_if
c_cond
(paren
id|reqtags
op_ne
id|oldtags
)paren
(brace
id|printf_info
c_func
(paren
l_string|&quot;%s:%d:%d: &quot;
l_string|&quot;tagged command queuing %s, command queue depth %d.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|target
comma
id|lun
comma
id|lp-&gt;s.reqtags
ques
c_cond
l_string|&quot;enabled&quot;
suffix:colon
l_string|&quot;disabled&quot;
comma
id|lp-&gt;started_limit
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef&t;SYM_LINUX_BOOT_COMMAND_LINE_SUPPORT
multiline_comment|/*&n; *  Linux select queue depths function&n; */
DECL|macro|DEF_DEPTH
mdefine_line|#define DEF_DEPTH&t;(sym_driver_setup.max_tag)
DECL|macro|ALL_TARGETS
mdefine_line|#define ALL_TARGETS&t;-2
DECL|macro|NO_TARGET
mdefine_line|#define NO_TARGET&t;-1
DECL|macro|ALL_LUNS
mdefine_line|#define ALL_LUNS&t;-2
DECL|macro|NO_LUN
mdefine_line|#define NO_LUN&t;&t;-1
DECL|function|device_queue_depth
r_static
r_int
id|device_queue_depth
c_func
(paren
id|hcb_p
id|np
comma
r_int
id|target
comma
r_int
id|lun
)paren
(brace
r_int
id|c
comma
id|h
comma
id|t
comma
id|u
comma
id|v
suffix:semicolon
r_char
op_star
id|p
op_assign
id|sym_driver_setup.tag_ctrl
suffix:semicolon
r_char
op_star
id|ep
suffix:semicolon
id|h
op_assign
op_minus
l_int|1
suffix:semicolon
id|t
op_assign
id|NO_TARGET
suffix:semicolon
id|u
op_assign
id|NO_LUN
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|p
op_increment
)paren
op_ne
l_int|0
)paren
(brace
id|v
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
op_amp
id|ep
comma
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;/&squot;
suffix:colon
op_increment
id|h
suffix:semicolon
id|t
op_assign
id|ALL_TARGETS
suffix:semicolon
id|u
op_assign
id|ALL_LUNS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
r_if
c_cond
(paren
id|t
op_ne
id|target
)paren
id|t
op_assign
(paren
id|target
op_eq
id|v
)paren
ques
c_cond
id|v
suffix:colon
id|NO_TARGET
suffix:semicolon
id|u
op_assign
id|ALL_LUNS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;u&squot;
suffix:colon
r_if
c_cond
(paren
id|u
op_ne
id|lun
)paren
id|u
op_assign
(paren
id|lun
op_eq
id|v
)paren
ques
c_cond
id|v
suffix:colon
id|NO_LUN
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;q&squot;
suffix:colon
r_if
c_cond
(paren
id|h
op_eq
id|np-&gt;s.unit
op_logical_and
(paren
id|t
op_eq
id|ALL_TARGETS
op_logical_or
id|t
op_eq
id|target
)paren
op_logical_and
(paren
id|u
op_eq
id|ALL_LUNS
op_logical_or
id|u
op_eq
id|lun
)paren
)paren
r_return
id|v
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;-&squot;
suffix:colon
id|t
op_assign
id|ALL_TARGETS
suffix:semicolon
id|u
op_assign
id|ALL_LUNS
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|p
op_assign
id|ep
suffix:semicolon
)brace
r_return
id|DEF_DEPTH
suffix:semicolon
)brace
macro_line|#else
DECL|macro|device_queue_depth
mdefine_line|#define device_queue_depth(np, t, l)&t;(sym_driver_setup.max_tag)
macro_line|#endif&t;/* SYM_LINUX_BOOT_COMMAND_LINE_SUPPORT */
multiline_comment|/*&n; * Linux entry point for device queue sizing.&n; */
r_static
r_void
DECL|function|sym53c8xx_select_queue_depths
id|sym53c8xx_select_queue_depths
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|scsi_device
op_star
id|devlist
)paren
(brace
r_struct
id|scsi_device
op_star
id|device
suffix:semicolon
r_for
c_loop
(paren
id|device
op_assign
id|devlist
suffix:semicolon
id|device
suffix:semicolon
id|device
op_assign
id|device-&gt;next
)paren
(brace
id|hcb_p
id|np
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
id|lcb_p
id|lp
suffix:semicolon
r_int
id|reqtags
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;host
op_ne
id|host
)paren
r_continue
suffix:semicolon
id|np
op_assign
(paren
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
)paren
op_member_access_from_pointer
id|ncb
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|device-&gt;id
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Get user settings for transfer parameters.&n;&t;&t; */
id|tp-&gt;inq_byte7_valid
op_assign
(paren
id|INQ7_SYNC
op_or
id|INQ7_WIDE16
)paren
suffix:semicolon
id|sym_update_trans_settings
c_func
(paren
id|np
comma
id|tp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Allocate the LCB if not yet.&n;&t;&t; *  If it fail, we may well be in the sh*t. :)&n;&t;&t; */
id|lp
op_assign
id|sym_alloc_lcb
c_func
(paren
id|np
comma
id|device-&gt;id
comma
id|device-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
(brace
id|device-&gt;queue_depth
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Get user flags.&n;&t;&t; */
id|lp-&gt;curr_flags
op_assign
id|lp-&gt;user_flags
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Select queue depth from driver setup.&n;&t;&t; *  Donnot use more than configured by user.&n;&t;&t; *  Use at least 2.&n;&t;&t; *  Donnot use more than our maximum.&n;&t;&t; */
id|reqtags
op_assign
id|device_queue_depth
c_func
(paren
id|np
comma
id|device-&gt;id
comma
id|device-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reqtags
OG
id|tp-&gt;usrtags
)paren
id|reqtags
op_assign
id|tp-&gt;usrtags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device-&gt;tagged_supported
)paren
id|reqtags
op_assign
l_int|0
suffix:semicolon
macro_line|#if 1 /* Avoid to locally queue commands for no good reasons */
r_if
c_cond
(paren
id|reqtags
OG
id|SYM_CONF_MAX_TAG
)paren
id|reqtags
op_assign
id|SYM_CONF_MAX_TAG
suffix:semicolon
id|device-&gt;queue_depth
op_assign
id|reqtags
ques
c_cond
id|reqtags
suffix:colon
l_int|2
suffix:semicolon
macro_line|#else
id|device-&gt;queue_depth
op_assign
id|reqtags
ques
c_cond
id|SYM_CONF_MAX_TAG
suffix:colon
l_int|2
suffix:semicolon
macro_line|#endif
id|lp-&gt;s.scdev_depth
op_assign
id|device-&gt;queue_depth
suffix:semicolon
id|sym_tune_dev_queuing
c_func
(paren
id|np
comma
id|device-&gt;id
comma
id|device-&gt;lun
comma
id|reqtags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *  Linux entry point for info() function&n; */
DECL|function|sym53c8xx_info
r_const
r_char
op_star
id|sym53c8xx_info
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_return
id|sym_driver_name
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef SYM_LINUX_PROC_INFO_SUPPORT
multiline_comment|/*&n; *  Proc file system stuff&n; *&n; *  A read operation returns adapter information.&n; *  A write operation is a control command.&n; *  The string is parsed in the driver code and the command is passed &n; *  to the sym_usercmd() function.&n; */
macro_line|#ifdef SYM_LINUX_USER_COMMAND_SUPPORT
DECL|struct|sym_usrcmd
r_struct
id|sym_usrcmd
(brace
DECL|member|target
id|u_long
id|target
suffix:semicolon
DECL|member|lun
id|u_long
id|lun
suffix:semicolon
DECL|member|data
id|u_long
id|data
suffix:semicolon
DECL|member|cmd
id|u_long
id|cmd
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|UC_SETSYNC
mdefine_line|#define UC_SETSYNC      10
DECL|macro|UC_SETTAGS
mdefine_line|#define UC_SETTAGS&t;11
DECL|macro|UC_SETDEBUG
mdefine_line|#define UC_SETDEBUG&t;12
DECL|macro|UC_SETWIDE
mdefine_line|#define UC_SETWIDE&t;14
DECL|macro|UC_SETFLAG
mdefine_line|#define UC_SETFLAG&t;15
DECL|macro|UC_SETVERBOSE
mdefine_line|#define UC_SETVERBOSE&t;17
DECL|macro|UC_RESETDEV
mdefine_line|#define UC_RESETDEV&t;18
DECL|macro|UC_CLEARDEV
mdefine_line|#define UC_CLEARDEV&t;19
DECL|function|sym_exec_user_command
r_static
r_void
id|sym_exec_user_command
(paren
id|hcb_p
id|np
comma
r_struct
id|sym_usrcmd
op_star
id|uc
)paren
(brace
id|tcb_p
id|tp
suffix:semicolon
r_int
id|t
comma
id|l
suffix:semicolon
r_switch
c_cond
(paren
id|uc-&gt;cmd
)paren
(brace
r_case
l_int|0
suffix:colon
r_return
suffix:semicolon
macro_line|#ifdef SYM_LINUX_DEBUG_CONTROL_SUPPORT
r_case
id|UC_SETDEBUG
suffix:colon
id|sym_debug_flags
op_assign
id|uc-&gt;data
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
id|UC_SETVERBOSE
suffix:colon
id|np-&gt;verbose
op_assign
id|uc-&gt;data
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/*&n;&t;&t; * We assume that other commands apply to targets.&n;&t;&t; * This should always be the case and avoid the below &n;&t;&t; * 4 lines to be repeated 6 times.&n;&t;&t; */
r_for
c_loop
(paren
id|t
op_assign
l_int|0
suffix:semicolon
id|t
OL
id|SYM_CONF_MAX_TARGET
suffix:semicolon
id|t
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|uc-&gt;target
op_rshift
id|t
)paren
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|t
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|uc-&gt;cmd
)paren
(brace
r_case
id|UC_SETSYNC
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|uc-&gt;data
op_logical_or
id|uc-&gt;data
op_ge
l_int|255
)paren
(brace
id|tp-&gt;tinfo.goal.options
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;tinfo.goal.offset
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uc-&gt;data
op_le
l_int|9
op_logical_and
id|np-&gt;minsync_dt
)paren
(brace
r_if
c_cond
(paren
id|uc-&gt;data
OL
id|np-&gt;minsync_dt
)paren
id|uc-&gt;data
op_assign
id|np-&gt;minsync_dt
suffix:semicolon
id|tp-&gt;tinfo.goal.options
op_assign
id|PPR_OPT_DT
suffix:semicolon
id|tp-&gt;tinfo.goal.width
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;tinfo.goal.period
op_assign
id|uc-&gt;data
suffix:semicolon
id|tp-&gt;tinfo.goal.offset
op_assign
id|np-&gt;maxoffs_dt
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|uc-&gt;data
OL
id|np-&gt;minsync
)paren
id|uc-&gt;data
op_assign
id|np-&gt;minsync
suffix:semicolon
id|tp-&gt;tinfo.goal.options
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;tinfo.goal.period
op_assign
id|uc-&gt;data
suffix:semicolon
id|tp-&gt;tinfo.goal.offset
op_assign
id|np-&gt;maxoffs
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|UC_SETWIDE
suffix:colon
id|tp-&gt;tinfo.goal.width
op_assign
id|uc-&gt;data
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETTAGS
suffix:colon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|SYM_CONF_MAX_LUN
suffix:semicolon
id|l
op_increment
)paren
id|sym_tune_dev_queuing
c_func
(paren
id|np
comma
id|t
comma
id|l
comma
id|uc-&gt;data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_RESETDEV
suffix:colon
id|tp-&gt;to_reset
op_assign
l_int|1
suffix:semicolon
id|np-&gt;istat_sem
op_assign
id|SEM
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
op_or
id|SEM
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_CLEARDEV
suffix:colon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|SYM_CONF_MAX_LUN
suffix:semicolon
id|l
op_increment
)paren
(brace
id|lcb_p
id|lp
op_assign
id|sym_lp
c_func
(paren
id|np
comma
id|tp
comma
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp
)paren
id|lp-&gt;to_clear
op_assign
l_int|1
suffix:semicolon
)brace
id|np-&gt;istat_sem
op_assign
id|SEM
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
op_or
id|SEM
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETFLAG
suffix:colon
id|tp-&gt;usrflags
op_assign
id|uc-&gt;data
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
)brace
DECL|macro|is_digit
mdefine_line|#define is_digit(c)&t;((c) &gt;= &squot;0&squot; &amp;&amp; (c) &lt;= &squot;9&squot;)
DECL|macro|digit_to_bin
mdefine_line|#define digit_to_bin(c)&t;((c) - &squot;0&squot;)
DECL|macro|is_space
mdefine_line|#define is_space(c)&t;((c) == &squot; &squot; || (c) == &squot;&bslash;t&squot;)
DECL|function|skip_spaces
r_static
r_int
id|skip_spaces
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
id|len
)paren
(brace
r_int
id|cnt
comma
id|c
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
id|len
suffix:semicolon
id|cnt
OG
l_int|0
op_logical_and
(paren
id|c
op_assign
op_star
id|ptr
op_increment
)paren
op_logical_and
id|is_space
c_func
(paren
id|c
)paren
suffix:semicolon
id|cnt
op_decrement
)paren
suffix:semicolon
r_return
(paren
id|len
op_minus
id|cnt
)paren
suffix:semicolon
)brace
DECL|function|get_int_arg
r_static
r_int
id|get_int_arg
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
id|len
comma
id|u_long
op_star
id|pv
)paren
(brace
r_int
id|cnt
comma
id|c
suffix:semicolon
id|u_long
id|v
suffix:semicolon
r_for
c_loop
(paren
id|v
op_assign
l_int|0
comma
id|cnt
op_assign
id|len
suffix:semicolon
id|cnt
OG
l_int|0
op_logical_and
(paren
id|c
op_assign
op_star
id|ptr
op_increment
)paren
op_logical_and
id|is_digit
c_func
(paren
id|c
)paren
suffix:semicolon
id|cnt
op_decrement
)paren
(brace
id|v
op_assign
(paren
id|v
op_star
l_int|10
)paren
op_plus
id|digit_to_bin
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pv
)paren
op_star
id|pv
op_assign
id|v
suffix:semicolon
r_return
(paren
id|len
op_minus
id|cnt
)paren
suffix:semicolon
)brace
DECL|function|is_keyword
r_static
r_int
id|is_keyword
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
id|len
comma
r_char
op_star
id|verb
)paren
(brace
r_int
id|verb_len
op_assign
id|strlen
c_func
(paren
id|verb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
id|strlen
c_func
(paren
id|verb
)paren
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|verb
comma
id|ptr
comma
id|verb_len
)paren
)paren
r_return
id|verb_len
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|SKIP_SPACES
mdefine_line|#define SKIP_SPACES(min_spaces)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if ((arg_len = skip_spaces(ptr, len)) &lt; (min_spaces))&t;&t;&bslash;&n;&t;&t;return -EINVAL;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ptr += arg_len; len -= arg_len;
DECL|macro|GET_INT_ARG
mdefine_line|#define GET_INT_ARG(v)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (!(arg_len = get_int_arg(ptr, len, &amp;(v))))&t;&t;&t;&bslash;&n;&t;&t;return -EINVAL;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ptr += arg_len; len -= arg_len;
multiline_comment|/*&n; * Parse a control command&n; */
DECL|function|sym_user_command
r_static
r_int
id|sym_user_command
c_func
(paren
id|hcb_p
id|np
comma
r_char
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
r_char
op_star
id|ptr
op_assign
id|buffer
suffix:semicolon
r_int
id|len
op_assign
id|length
suffix:semicolon
r_struct
id|sym_usrcmd
id|cmd
comma
op_star
id|uc
op_assign
op_amp
id|cmd
suffix:semicolon
r_int
id|arg_len
suffix:semicolon
id|u_long
id|target
suffix:semicolon
id|bzero
c_func
(paren
id|uc
comma
r_sizeof
(paren
op_star
id|uc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
op_logical_and
id|ptr
(braket
id|len
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
op_decrement
id|len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setsync&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETSYNC
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;settags&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETTAGS
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setverbose&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETVERBOSE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setwide&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETWIDE
suffix:semicolon
macro_line|#ifdef SYM_LINUX_DEBUG_CONTROL_SUPPORT
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setdebug&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETDEBUG
suffix:semicolon
macro_line|#endif
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setflag&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETFLAG
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;resetdev&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_RESETDEV
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;cleardev&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_CLEARDEV
suffix:semicolon
r_else
id|arg_len
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;sym_user_command: arg_len=%d, cmd=%ld&bslash;n&quot;
comma
id|arg_len
comma
id|uc-&gt;cmd
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|arg_len
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
r_switch
c_cond
(paren
id|uc-&gt;cmd
)paren
(brace
r_case
id|UC_SETSYNC
suffix:colon
r_case
id|UC_SETTAGS
suffix:colon
r_case
id|UC_SETWIDE
suffix:colon
r_case
id|UC_SETFLAG
suffix:colon
r_case
id|UC_RESETDEV
suffix:colon
r_case
id|UC_CLEARDEV
suffix:colon
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;all&quot;
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
id|uc-&gt;target
op_assign
op_complement
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|GET_INT_ARG
c_func
(paren
id|target
)paren
suffix:semicolon
id|uc-&gt;target
op_assign
(paren
l_int|1
op_lshift
id|target
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;sym_user_command: target=%ld&bslash;n&quot;
comma
id|target
)paren
suffix:semicolon
macro_line|#endif
)brace
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|uc-&gt;cmd
)paren
(brace
r_case
id|UC_SETVERBOSE
suffix:colon
r_case
id|UC_SETSYNC
suffix:colon
r_case
id|UC_SETTAGS
suffix:colon
r_case
id|UC_SETWIDE
suffix:colon
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|GET_INT_ARG
c_func
(paren
id|uc-&gt;data
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;sym_user_command: data=%ld&bslash;n&quot;
comma
id|uc-&gt;data
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
macro_line|#ifdef SYM_LINUX_DEBUG_CONTROL_SUPPORT
r_case
id|UC_SETDEBUG
suffix:colon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;alloc&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_ALLOC
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;phase&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_PHASE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;queue&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_QUEUE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;result&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_RESULT
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;scatter&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_SCATTER
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;script&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_SCRIPT
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;tiny&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_TINY
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;timing&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_TIMING
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;nego&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_NEGO
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;tags&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_TAGS
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;pointer&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_POINTER
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;sym_user_command: data=%ld&bslash;n&quot;
comma
id|uc-&gt;data
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
macro_line|#endif /* SYM_LINUX_DEBUG_CONTROL_SUPPORT */
r_case
id|UC_SETFLAG
suffix:colon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;no_disc&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_and_assign
op_complement
id|SYM_DISC_ENABLED
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
(brace
r_int
id|flags
suffix:semicolon
id|SYM_LOCK_HCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|sym_exec_user_command
(paren
id|np
comma
id|uc
)paren
suffix:semicolon
id|SYM_UNLOCK_HCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|length
suffix:semicolon
)brace
macro_line|#endif&t;/* SYM_LINUX_USER_COMMAND_SUPPORT */
macro_line|#ifdef SYM_LINUX_USER_INFO_SUPPORT
multiline_comment|/*&n; *  Informations through the proc file system.&n; */
DECL|struct|info_str
r_struct
id|info_str
(brace
DECL|member|buffer
r_char
op_star
id|buffer
suffix:semicolon
DECL|member|length
r_int
id|length
suffix:semicolon
DECL|member|offset
r_int
id|offset
suffix:semicolon
DECL|member|pos
r_int
id|pos
suffix:semicolon
)brace
suffix:semicolon
DECL|function|copy_mem_info
r_static
r_void
id|copy_mem_info
c_func
(paren
r_struct
id|info_str
op_star
id|info
comma
r_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pos
op_plus
id|len
OG
id|info-&gt;length
)paren
id|len
op_assign
id|info-&gt;length
op_minus
id|info-&gt;pos
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;pos
op_plus
id|len
OL
id|info-&gt;offset
)paren
(brace
id|info-&gt;pos
op_add_assign
id|len
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;pos
OL
id|info-&gt;offset
)paren
(brace
id|data
op_add_assign
(paren
id|info-&gt;offset
op_minus
id|info-&gt;pos
)paren
suffix:semicolon
id|len
op_sub_assign
(paren
id|info-&gt;offset
op_minus
id|info-&gt;pos
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|info-&gt;buffer
op_plus
id|info-&gt;pos
comma
id|data
comma
id|len
)paren
suffix:semicolon
id|info-&gt;pos
op_add_assign
id|len
suffix:semicolon
)brace
)brace
DECL|function|copy_info
r_static
r_int
id|copy_info
c_func
(paren
r_struct
id|info_str
op_star
id|info
comma
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_char
id|buf
(braket
l_int|81
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|len
op_assign
id|vsprintf
c_func
(paren
id|buf
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
id|copy_mem_info
c_func
(paren
id|info
comma
id|buf
comma
id|len
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; *  Copy formatted information into the input buffer.&n; */
DECL|function|sym_host_info
r_static
r_int
id|sym_host_info
c_func
(paren
id|hcb_p
id|np
comma
r_char
op_star
id|ptr
comma
id|off_t
id|offset
comma
r_int
id|len
)paren
(brace
r_struct
id|info_str
id|info
suffix:semicolon
id|info.buffer
op_assign
id|ptr
suffix:semicolon
id|info.length
op_assign
id|len
suffix:semicolon
id|info.offset
op_assign
id|offset
suffix:semicolon
id|info.pos
op_assign
l_int|0
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Chip &quot;
id|NAME53C
l_string|&quot;%s, device id 0x%x, &quot;
l_string|&quot;revision id 0x%x&bslash;n&quot;
comma
id|np-&gt;s.chip_name
comma
id|np-&gt;device_id
comma
id|np-&gt;revision_id
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;On PCI bus %d, device %d, function %d, &quot;
macro_line|#ifdef __sparc__
l_string|&quot;IRQ %s&bslash;n&quot;
comma
macro_line|#else
l_string|&quot;IRQ %d&bslash;n&quot;
comma
macro_line|#endif
id|np-&gt;s.bus
comma
(paren
id|np-&gt;s.device_fn
op_amp
l_int|0xf8
)paren
op_rshift
l_int|3
comma
id|np-&gt;s.device_fn
op_amp
l_int|7
comma
macro_line|#ifdef __sparc__
id|__irq_itoa
c_func
(paren
id|np-&gt;s.irq
)paren
)paren
suffix:semicolon
macro_line|#else
(paren
r_int
)paren
id|np-&gt;s.irq
)paren
suffix:semicolon
macro_line|#endif
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Min. period factor %d, %s SCSI BUS%s&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|np-&gt;minsync_dt
ques
c_cond
id|np-&gt;minsync_dt
suffix:colon
id|np-&gt;minsync
)paren
comma
id|np-&gt;maxwide
ques
c_cond
l_string|&quot;Wide&quot;
suffix:colon
l_string|&quot;Narrow&quot;
comma
id|np-&gt;minsync_dt
ques
c_cond
l_string|&quot;, DT capable&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Max. started commands %d, &quot;
l_string|&quot;max. commands per LUN %d&bslash;n&quot;
comma
id|SYM_CONF_MAX_START
comma
id|SYM_CONF_MAX_TAG
)paren
suffix:semicolon
r_return
id|info.pos
OG
id|info.offset
ques
c_cond
id|info.pos
op_minus
id|info.offset
suffix:colon
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* SYM_LINUX_USER_INFO_SUPPORT */
multiline_comment|/*&n; *  Entry point of the scsi proc fs of the driver.&n; *  - func = 0 means read  (returns adapter infos)&n; *  - func = 1 means write (not yet merget from sym53c8xx)&n; */
DECL|function|sym53c8xx_proc_info
r_static
r_int
id|sym53c8xx_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|hostno
comma
r_int
id|func
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
r_struct
id|host_data
op_star
id|host_data
suffix:semicolon
id|hcb_p
id|np
op_assign
l_int|0
suffix:semicolon
r_int
id|retv
suffix:semicolon
r_for
c_loop
(paren
id|host
op_assign
id|first_host
suffix:semicolon
id|host
suffix:semicolon
id|host
op_assign
id|host-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|host-&gt;hostt
op_ne
id|first_host-&gt;hostt
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;host_no
op_eq
id|hostno
)paren
(brace
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|np
op_assign
id|host_data-&gt;ncb
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|np
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|func
)paren
(brace
macro_line|#ifdef&t;SYM_LINUX_USER_COMMAND_SUPPORT
id|retv
op_assign
id|sym_user_command
c_func
(paren
id|np
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
macro_line|#else
id|retv
op_assign
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_if
c_cond
(paren
id|start
)paren
op_star
id|start
op_assign
id|buffer
suffix:semicolon
macro_line|#ifdef SYM_LINUX_USER_INFO_SUPPORT
id|retv
op_assign
id|sym_host_info
c_func
(paren
id|np
comma
id|buffer
comma
id|offset
comma
id|length
)paren
suffix:semicolon
macro_line|#else
id|retv
op_assign
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif
)brace
r_return
id|retv
suffix:semicolon
)brace
macro_line|#endif /* SYM_LINUX_PROC_INFO_SUPPORT */
multiline_comment|/*&n; *&t;Free controller resources.&n; */
DECL|function|sym_free_resources
r_static
r_void
id|sym_free_resources
c_func
(paren
id|hcb_p
id|np
)paren
(brace
multiline_comment|/*&n;&t; *  Free O/S specific resources.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;s.irq
)paren
id|free_irq
c_func
(paren
id|np-&gt;s.irq
comma
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;s.io_port
)paren
id|release_region
c_func
(paren
id|np-&gt;s.io_port
comma
id|np-&gt;s.io_ws
)paren
suffix:semicolon
macro_line|#ifndef SYM_OPT_NO_BUS_MEMORY_MAPPING
r_if
c_cond
(paren
id|np-&gt;s.mmio_va
)paren
id|pci_unmap_mem
c_func
(paren
id|np-&gt;s.mmio_va
comma
id|np-&gt;s.io_ws
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;s.ram_va
)paren
id|pci_unmap_mem
c_func
(paren
id|np-&gt;s.ram_va
comma
id|np-&gt;ram_ws
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *  Free O/S independant resources.&n;&t; */
id|sym_hcb_free
c_func
(paren
id|np
)paren
suffix:semicolon
id|sym_mfree_dma
c_func
(paren
id|np
comma
r_sizeof
(paren
op_star
id|np
)paren
comma
l_string|&quot;HCB&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Ask/tell the system about DMA addressing.&n; */
macro_line|#ifdef SYM_LINUX_DYNAMIC_DMA_MAPPING
DECL|function|sym_setup_bus_dma_mask
r_static
r_int
id|sym_setup_bus_dma_mask
c_func
(paren
id|hcb_p
id|np
)paren
(brace
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2,4,3)
r_if
c_cond
(paren
op_logical_neg
id|pci_dma_supported
c_func
(paren
id|np-&gt;s.device
comma
l_int|0xffffffffUL
)paren
)paren
r_goto
id|out_err32
suffix:semicolon
macro_line|#else
macro_line|#if   SYM_CONF_DMA_ADDRESSING_MODE == 0
r_if
c_cond
(paren
id|pci_set_dma_mask
c_func
(paren
id|np-&gt;s.device
comma
l_int|0xffffffffUL
)paren
)paren
r_goto
id|out_err32
suffix:semicolon
macro_line|#else
macro_line|#if   SYM_CONF_DMA_ADDRESSING_MODE == 1
mdefine_line|#define&t;PciDmaMask&t;0xffffffffff
macro_line|#elif SYM_CONF_DMA_ADDRESSING_MODE == 2
mdefine_line|#define&t;PciDmaMask&t;0xffffffffffffffff
macro_line|#endif
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_DAC
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pci_set_dma_mask
c_func
(paren
id|np-&gt;s.device
comma
id|PciDmaMask
)paren
)paren
(brace
id|np-&gt;use_dac
op_assign
l_int|1
suffix:semicolon
id|printf_info
c_func
(paren
l_string|&quot;%s: using 64 bit DMA addressing&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|pci_set_dma_mask
c_func
(paren
id|np-&gt;s.device
comma
l_int|0xffffffffUL
)paren
)paren
r_goto
id|out_err32
suffix:semicolon
)brace
)brace
macro_line|#undef&t;PciDmaMask
macro_line|#endif
macro_line|#endif
r_return
l_int|0
suffix:semicolon
id|out_err32
suffix:colon
id|printf_warning
c_func
(paren
l_string|&quot;%s: 32 BIT DMA ADDRESSING NOT SUPPORTED&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif /* SYM_LINUX_DYNAMIC_DMA_MAPPING */
multiline_comment|/*&n; *  Host attach and initialisations.&n; *&n; *  Allocate host data and ncb structure.&n; *  Request IO region and remap MMIO region.&n; *  Do chip initialization.&n; *  If all is OK, install interrupt handling and&n; *  start the timer daemon.&n; */
r_static
r_int
id|__init
DECL|function|sym_attach
id|sym_attach
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
r_int
id|unit
comma
id|sym_device
op_star
id|dev
)paren
(brace
r_struct
id|host_data
op_star
id|host_data
suffix:semicolon
id|hcb_p
id|np
op_assign
l_int|0
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
op_assign
l_int|0
suffix:semicolon
id|u_long
id|flags
op_assign
l_int|0
suffix:semicolon
id|sym_nvram
op_star
id|nvram
op_assign
id|dev-&gt;nvram
suffix:semicolon
r_struct
id|sym_fw
op_star
id|fw
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;sym%d: &lt;%s&gt; rev 0x%x on pci bus %d device %d function %d &quot;
macro_line|#ifdef __sparc__
l_string|&quot;irq %s&bslash;n&quot;
comma
macro_line|#else
l_string|&quot;irq %d&bslash;n&quot;
comma
macro_line|#endif
id|unit
comma
id|dev-&gt;chip.name
comma
id|dev-&gt;chip.revision_id
comma
id|dev-&gt;s.bus
comma
(paren
id|dev-&gt;s.device_fn
op_amp
l_int|0xf8
)paren
op_rshift
l_int|3
comma
id|dev-&gt;s.device_fn
op_amp
l_int|7
comma
macro_line|#ifdef __sparc__
id|__irq_itoa
c_func
(paren
id|dev-&gt;s.irq
)paren
)paren
suffix:semicolon
macro_line|#else
id|dev-&gt;s.irq
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *  Get the firmware for this chip.&n;&t; */
id|fw
op_assign
id|sym_find_firmware
c_func
(paren
op_amp
id|dev-&gt;chip
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fw
)paren
r_goto
id|attach_failed
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allocate host_data structure&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|instance
op_assign
id|scsi_register
c_func
(paren
id|tpnt
comma
r_sizeof
(paren
op_star
id|host_data
)paren
)paren
)paren
)paren
r_goto
id|attach_failed
suffix:semicolon
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
multiline_comment|/*&n;&t; *  Allocate immediately the host control block, &n;&t; *  since we are only expecting to succeed. :)&n;&t; *  We keep track in the HCB of all the resources that &n;&t; *  are to be released on error.&n;&t; */
macro_line|#ifdef&t;SYM_LINUX_DYNAMIC_DMA_MAPPING
id|np
op_assign
id|__sym_calloc_dma
c_func
(paren
id|dev-&gt;pdev
comma
r_sizeof
(paren
op_star
id|np
)paren
comma
l_string|&quot;HCB&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np
)paren
(brace
id|np-&gt;s.device
op_assign
id|dev-&gt;pdev
suffix:semicolon
id|np-&gt;bus_dmat
op_assign
id|dev-&gt;pdev
suffix:semicolon
multiline_comment|/* Result in 1 DMA pool per HBA */
)brace
r_else
r_goto
id|attach_failed
suffix:semicolon
macro_line|#else
id|np
op_assign
id|sym_calloc_dma
c_func
(paren
r_sizeof
(paren
op_star
id|np
)paren
comma
l_string|&quot;HCB&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np
)paren
r_goto
id|attach_failed
suffix:semicolon
macro_line|#endif
id|host_data-&gt;ncb
op_assign
id|np
suffix:semicolon
id|np-&gt;s.host
op_assign
id|instance
suffix:semicolon
id|SYM_INIT_LOCK_HCB
c_func
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Copy some useful infos to the HCB.&n;&t; */
id|np-&gt;hcb_ba
op_assign
id|vtobus
c_func
(paren
id|np
)paren
suffix:semicolon
id|np-&gt;verbose
op_assign
id|sym_driver_setup.verbose
suffix:semicolon
id|np-&gt;s.device
op_assign
id|dev-&gt;pdev
suffix:semicolon
id|np-&gt;s.unit
op_assign
id|unit
suffix:semicolon
id|np-&gt;device_id
op_assign
id|dev-&gt;chip.device_id
suffix:semicolon
id|np-&gt;revision_id
op_assign
id|dev-&gt;chip.revision_id
suffix:semicolon
id|np-&gt;s.bus
op_assign
id|dev-&gt;s.bus
suffix:semicolon
id|np-&gt;s.device_fn
op_assign
id|dev-&gt;s.device_fn
suffix:semicolon
id|np-&gt;features
op_assign
id|dev-&gt;chip.features
suffix:semicolon
id|np-&gt;clock_divn
op_assign
id|dev-&gt;chip.nr_divisor
suffix:semicolon
id|np-&gt;maxoffs
op_assign
id|dev-&gt;chip.offset_max
suffix:semicolon
id|np-&gt;maxburst
op_assign
id|dev-&gt;chip.burst_max
suffix:semicolon
id|np-&gt;myaddr
op_assign
id|dev-&gt;host_id
suffix:semicolon
multiline_comment|/*&n;&t; *  Edit its name.&n;&t; */
id|strncpy
c_func
(paren
id|np-&gt;s.chip_name
comma
id|dev-&gt;chip.name
comma
r_sizeof
(paren
id|np-&gt;s.chip_name
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|np-&gt;s.inst_name
comma
l_string|&quot;sym%d&quot;
comma
id|np-&gt;s.unit
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Ask/tell the system about DMA addressing.&n;&t; */
macro_line|#ifdef SYM_LINUX_DYNAMIC_DMA_MAPPING
r_if
c_cond
(paren
id|sym_setup_bus_dma_mask
c_func
(paren
id|np
)paren
)paren
r_goto
id|attach_failed
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *  Try to map the controller chip to&n;&t; *  virtual and physical memory.&n;&t; */
id|np-&gt;mmio_ba
op_assign
(paren
id|u32
)paren
id|dev-&gt;s.base
suffix:semicolon
id|np-&gt;s.io_ws
op_assign
(paren
id|np-&gt;features
op_amp
id|FE_IO256
)paren
ques
c_cond
l_int|256
suffix:colon
l_int|128
suffix:semicolon
macro_line|#ifndef SYM_CONF_IOMAPPED
id|np-&gt;s.mmio_va
op_assign
id|pci_map_mem
c_func
(paren
id|dev-&gt;s.base_c
comma
id|np-&gt;s.io_ws
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;s.mmio_va
)paren
(brace
id|printf_err
c_func
(paren
l_string|&quot;%s: can&squot;t map PCI MMIO region&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_goto
id|attach_failed
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sym_verbose
OG
l_int|1
)paren
id|printf_info
c_func
(paren
l_string|&quot;%s: using memory mapped IO&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
macro_line|#endif /* !defined SYM_CONF_IOMAPPED */
multiline_comment|/*&n;&t; *  Try to map the controller chip into iospace.&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;s.io_port
)paren
(brace
id|request_region
c_func
(paren
id|dev-&gt;s.io_port
comma
id|np-&gt;s.io_ws
comma
id|NAME53C8XX
)paren
suffix:semicolon
id|np-&gt;s.io_port
op_assign
id|dev-&gt;s.io_port
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Map on-chip RAM if present and supported.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_RAM
)paren
)paren
id|dev-&gt;s.base_2
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;s.base_2
)paren
(brace
id|np-&gt;ram_ba
op_assign
(paren
id|u32
)paren
id|dev-&gt;s.base_2
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_RAM8K
)paren
id|np-&gt;ram_ws
op_assign
l_int|8192
suffix:semicolon
r_else
id|np-&gt;ram_ws
op_assign
l_int|4096
suffix:semicolon
macro_line|#ifndef SYM_OPT_NO_BUS_MEMORY_MAPPING
id|np-&gt;s.ram_va
op_assign
id|pci_map_mem
c_func
(paren
id|dev-&gt;s.base_2_c
comma
id|np-&gt;ram_ws
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;s.ram_va
)paren
(brace
id|printf_err
c_func
(paren
l_string|&quot;%s: can&squot;t map PCI MEMORY region&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_goto
id|attach_failed
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n;&t; *  Perform O/S independant stuff.&n;&t; */
r_if
c_cond
(paren
id|sym_hcb_attach
c_func
(paren
id|np
comma
id|fw
comma
id|nvram
)paren
)paren
r_goto
id|attach_failed
suffix:semicolon
multiline_comment|/*&n;&t; *  Install the interrupt handler.&n;&t; *  If we synchonize the C code with SCRIPTS on interrupt, &n;&t; *  we donnot want to share the INTR line at all.&n;&t; */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;s.irq
comma
id|sym53c8xx_intr
comma
id|SA_SHIRQ
comma
id|NAME53C8XX
comma
id|np
)paren
)paren
(brace
id|printf_err
c_func
(paren
l_string|&quot;%s: request irq %d failure&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|dev-&gt;s.irq
)paren
suffix:semicolon
r_goto
id|attach_failed
suffix:semicolon
)brace
id|np-&gt;s.irq
op_assign
id|dev-&gt;s.irq
suffix:semicolon
multiline_comment|/*&n;&t; *  After SCSI devices have been opened, we cannot&n;&t; *  reset the bus safely, so we do it here.&n;&t; */
id|SYM_LOCK_HCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sym_reset_scsi_bus
c_func
(paren
id|np
comma
l_int|0
)paren
)paren
(brace
id|printf_err
c_func
(paren
l_string|&quot;%s: FATAL ERROR: CHECK SCSI BUS - CABLES, &quot;
l_string|&quot;TERMINATION, DEVICE POWER etc.!&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|SYM_UNLOCK_HCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
r_goto
id|attach_failed
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Initialize some queue headers.&n;&t; */
id|sym_que_init
c_func
(paren
op_amp
id|np-&gt;s.wait_cmdq
)paren
suffix:semicolon
id|sym_que_init
c_func
(paren
op_amp
id|np-&gt;s.busy_cmdq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Start the SCRIPTS.&n;&t; */
id|sym_start_up
(paren
id|np
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Start the timer daemon&n;&t; */
id|init_timer
c_func
(paren
op_amp
id|np-&gt;s.timer
)paren
suffix:semicolon
id|np-&gt;s.timer.data
op_assign
(paren
r_int
r_int
)paren
id|np
suffix:semicolon
id|np-&gt;s.timer.function
op_assign
id|sym53c8xx_timer
suffix:semicolon
id|np-&gt;s.lasttime
op_assign
l_int|0
suffix:semicolon
id|sym_timer
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Done.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|first_host
)paren
id|first_host
op_assign
id|instance
suffix:semicolon
multiline_comment|/*&n;&t; *  Fill Linux host instance structure&n;&t; *  and return success.&n;&t; */
id|instance-&gt;max_channel
op_assign
l_int|0
suffix:semicolon
id|instance-&gt;this_id
op_assign
id|np-&gt;myaddr
suffix:semicolon
id|instance-&gt;max_id
op_assign
id|np-&gt;maxwide
ques
c_cond
l_int|16
suffix:colon
l_int|8
suffix:semicolon
id|instance-&gt;max_lun
op_assign
id|SYM_CONF_MAX_LUN
suffix:semicolon
macro_line|#ifndef SYM_CONF_IOMAPPED
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,3,29)
id|instance-&gt;base
op_assign
(paren
r_int
r_int
)paren
id|np-&gt;s.mmio_va
suffix:semicolon
macro_line|#else
id|instance-&gt;base
op_assign
(paren
r_char
op_star
)paren
id|np-&gt;s.mmio_va
suffix:semicolon
macro_line|#endif
macro_line|#endif
id|instance-&gt;irq
op_assign
id|np-&gt;s.irq
suffix:semicolon
id|instance-&gt;unique_id
op_assign
id|np-&gt;s.io_port
suffix:semicolon
id|instance-&gt;io_port
op_assign
id|np-&gt;s.io_port
suffix:semicolon
id|instance-&gt;n_io_port
op_assign
id|np-&gt;s.io_ws
suffix:semicolon
id|instance-&gt;dma_channel
op_assign
l_int|0
suffix:semicolon
id|instance-&gt;cmd_per_lun
op_assign
id|SYM_CONF_MAX_TAG
suffix:semicolon
id|instance-&gt;can_queue
op_assign
(paren
id|SYM_CONF_MAX_START
op_minus
l_int|2
)paren
suffix:semicolon
id|instance-&gt;sg_tablesize
op_assign
id|SYM_CONF_MAX_SG
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,4,0)
id|instance-&gt;max_cmd_len
op_assign
l_int|16
suffix:semicolon
macro_line|#endif
id|instance-&gt;select_queue_depths
op_assign
id|sym53c8xx_select_queue_depths
suffix:semicolon
id|instance-&gt;highmem_io
op_assign
l_int|1
suffix:semicolon
id|SYM_UNLOCK_HCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|scsi_set_pci_device
c_func
(paren
id|instance
comma
id|dev-&gt;pdev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Now let the generic SCSI driver&n;&t; *  look for the SCSI devices on the bus ..&n;&t; */
r_return
l_int|0
suffix:semicolon
id|attach_failed
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|instance
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|printf_info
c_func
(paren
l_string|&quot;%s: giving up ...&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np
)paren
id|sym_free_resources
c_func
(paren
id|np
)paren
suffix:semicolon
id|scsi_unregister
c_func
(paren
id|instance
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *    Detect and try to read SYMBIOS and TEKRAM NVRAM.&n; */
macro_line|#if SYM_CONF_NVRAM_SUPPORT
DECL|function|sym_get_nvram
r_static
r_void
id|__init
id|sym_get_nvram
c_func
(paren
id|sym_device
op_star
id|devp
comma
id|sym_nvram
op_star
id|nvp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|nvp
)paren
r_return
suffix:semicolon
id|devp-&gt;nvram
op_assign
id|nvp
suffix:semicolon
id|devp-&gt;device_id
op_assign
id|devp-&gt;chip.device_id
suffix:semicolon
id|nvp-&gt;type
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  Get access to chip IO registers&n;&t; */
macro_line|#ifdef SYM_CONF_IOMAPPED
id|request_region
c_func
(paren
id|devp-&gt;s.io_port
comma
l_int|128
comma
id|NAME53C8XX
)paren
suffix:semicolon
macro_line|#else
id|devp-&gt;s.mmio_va
op_assign
id|pci_map_mem
c_func
(paren
id|devp-&gt;s.base_c
comma
l_int|128
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devp-&gt;s.mmio_va
)paren
r_return
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *  Try to read SYMBIOS|TEKRAM nvram.&n;&t; */
(paren
r_void
)paren
id|sym_read_nvram
c_func
(paren
id|devp
comma
id|nvp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Release access to chip IO registers&n;&t; */
macro_line|#ifdef SYM_CONF_IOMAPPED
id|release_region
c_func
(paren
id|devp-&gt;s.io_port
comma
l_int|128
)paren
suffix:semicolon
macro_line|#else
id|pci_unmap_mem
c_func
(paren
(paren
id|u_long
)paren
id|devp-&gt;s.mmio_va
comma
l_int|128ul
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif&t;/* SYM_CONF_NVRAM_SUPPORT */
multiline_comment|/*&n; *  Driver setup from the boot command line&n; */
macro_line|#ifdef&t;SYM_LINUX_BOOT_COMMAND_LINE_SUPPORT
r_static
r_struct
id|sym_driver_setup
DECL|variable|__initdata
id|sym_driver_safe_setup
id|__initdata
op_assign
id|SYM_LINUX_DRIVER_SAFE_SETUP
suffix:semicolon
macro_line|#ifdef&t;MODULE
DECL|variable|sym53c8xx
r_char
op_star
id|sym53c8xx
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* command line passed by insmod */
id|MODULE_PARM
c_func
(paren
id|sym53c8xx
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
macro_line|#endif
DECL|function|sym53c8xx_print_driver_setup
r_static
r_void
id|__init
id|sym53c8xx_print_driver_setup
c_func
(paren
r_void
)paren
(brace
id|printf_info
(paren
id|NAME53C8XX
l_string|&quot;: setup=&quot;
l_string|&quot;mpar:%d,spar:%d,tags:%d,sync:%d,burst:%d,&quot;
l_string|&quot;led:%d,wide:%d,diff:%d,irqm:%d, buschk:%d&bslash;n&quot;
comma
id|sym_driver_setup.pci_parity
comma
id|sym_driver_setup.scsi_parity
comma
id|sym_driver_setup.max_tag
comma
id|sym_driver_setup.min_sync
comma
id|sym_driver_setup.burst_order
comma
id|sym_driver_setup.scsi_led
comma
id|sym_driver_setup.max_wide
comma
id|sym_driver_setup.scsi_diff
comma
id|sym_driver_setup.irq_mode
comma
id|sym_driver_setup.scsi_bus_check
)paren
suffix:semicolon
id|printf_info
(paren
id|NAME53C8XX
l_string|&quot;: setup=&quot;
l_string|&quot;hostid:%d,offs:%d,luns:%d,pcifix:%d,revprob:%d,&quot;
l_string|&quot;verb:%d,debug:0x%x,setlle_delay:%d&bslash;n&quot;
comma
id|sym_driver_setup.host_id
comma
id|sym_driver_setup.max_offs
comma
id|sym_driver_setup.max_lun
comma
id|sym_driver_setup.pci_fix_up
comma
id|sym_driver_setup.reverse_probe
comma
id|sym_driver_setup.verbose
comma
id|sym_driver_setup.debug
comma
id|sym_driver_setup.settle_delay
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_2_0_X
id|MDELAY
c_func
(paren
l_int|5000
)paren
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
DECL|macro|OPT_PCI_PARITY
mdefine_line|#define OPT_PCI_PARITY&t;&t;1
DECL|macro|OPT_SCSI_PARITY
mdefine_line|#define&t;OPT_SCSI_PARITY&t;&t;2
DECL|macro|OPT_MAX_TAG
mdefine_line|#define OPT_MAX_TAG&t;&t;3
DECL|macro|OPT_MIN_SYNC
mdefine_line|#define OPT_MIN_SYNC&t;&t;4
DECL|macro|OPT_BURST_ORDER
mdefine_line|#define OPT_BURST_ORDER&t;&t;5
DECL|macro|OPT_SCSI_LED
mdefine_line|#define OPT_SCSI_LED&t;&t;6
DECL|macro|OPT_MAX_WIDE
mdefine_line|#define OPT_MAX_WIDE&t;&t;7
DECL|macro|OPT_SCSI_DIFF
mdefine_line|#define OPT_SCSI_DIFF&t;&t;8
DECL|macro|OPT_IRQ_MODE
mdefine_line|#define OPT_IRQ_MODE&t;&t;9
DECL|macro|OPT_SCSI_BUS_CHECK
mdefine_line|#define OPT_SCSI_BUS_CHECK&t;10
DECL|macro|OPT_HOST_ID
mdefine_line|#define&t;OPT_HOST_ID&t;&t;11
DECL|macro|OPT_MAX_OFFS
mdefine_line|#define OPT_MAX_OFFS&t;&t;12
DECL|macro|OPT_MAX_LUN
mdefine_line|#define OPT_MAX_LUN&t;&t;13
DECL|macro|OPT_PCI_FIX_UP
mdefine_line|#define OPT_PCI_FIX_UP&t;&t;14
DECL|macro|OPT_REVERSE_PROBE
mdefine_line|#define OPT_REVERSE_PROBE&t;15
DECL|macro|OPT_VERBOSE
mdefine_line|#define OPT_VERBOSE&t;&t;16
DECL|macro|OPT_DEBUG
mdefine_line|#define OPT_DEBUG&t;&t;17
DECL|macro|OPT_SETTLE_DELAY
mdefine_line|#define OPT_SETTLE_DELAY&t;18
DECL|macro|OPT_USE_NVRAM
mdefine_line|#define OPT_USE_NVRAM&t;&t;19
DECL|macro|OPT_EXCLUDE
mdefine_line|#define OPT_EXCLUDE&t;&t;20
DECL|macro|OPT_SAFE_SETUP
mdefine_line|#define OPT_SAFE_SETUP&t;&t;21
DECL|variable|__initdata
r_static
r_char
id|setup_token
(braket
)braket
id|__initdata
op_assign
l_string|&quot;mpar:&quot;
l_string|&quot;spar:&quot;
l_string|&quot;tags:&quot;
l_string|&quot;sync:&quot;
l_string|&quot;burst:&quot;
l_string|&quot;led:&quot;
l_string|&quot;wide:&quot;
l_string|&quot;diff:&quot;
l_string|&quot;irqm:&quot;
l_string|&quot;buschk:&quot;
l_string|&quot;hostid:&quot;
l_string|&quot;offset:&quot;
l_string|&quot;luns:&quot;
l_string|&quot;pcifix:&quot;
l_string|&quot;revprob:&quot;
l_string|&quot;verb:&quot;
l_string|&quot;debug:&quot;
l_string|&quot;settle:&quot;
l_string|&quot;nvram:&quot;
l_string|&quot;excl:&quot;
l_string|&quot;safe:&quot;
suffix:semicolon
macro_line|#ifdef MODULE
DECL|macro|ARG_SEP
mdefine_line|#define&t;ARG_SEP&t;&squot; &squot;
macro_line|#else
DECL|macro|ARG_SEP
mdefine_line|#define&t;ARG_SEP&t;&squot;,&squot;
macro_line|#endif
DECL|function|get_setup_token
r_static
r_int
id|__init
id|get_setup_token
c_func
(paren
r_char
op_star
id|p
)paren
(brace
r_char
op_star
id|cur
op_assign
id|setup_token
suffix:semicolon
r_char
op_star
id|pc
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cur
op_ne
l_int|NULL
op_logical_and
(paren
id|pc
op_assign
id|strchr
c_func
(paren
id|cur
comma
l_char|&squot;:&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
op_increment
id|pc
suffix:semicolon
op_increment
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|p
comma
id|cur
comma
id|pc
op_minus
id|cur
)paren
)paren
r_return
id|i
suffix:semicolon
id|cur
op_assign
id|pc
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;/* SYM_LINUX_BOOT_COMMAND_LINE_SUPPORT */
DECL|function|sym53c8xx_setup
r_int
id|__init
id|sym53c8xx_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
macro_line|#ifdef&t;SYM_LINUX_BOOT_COMMAND_LINE_SUPPORT
r_char
op_star
id|cur
op_assign
id|str
suffix:semicolon
r_char
op_star
id|pc
comma
op_star
id|pv
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
r_int
id|i
comma
id|c
suffix:semicolon
r_int
id|xi
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cur
op_ne
l_int|NULL
op_logical_and
(paren
id|pc
op_assign
id|strchr
c_func
(paren
id|cur
comma
l_char|&squot;:&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_char
op_star
id|pe
suffix:semicolon
id|val
op_assign
l_int|0
suffix:semicolon
id|pv
op_assign
id|pc
suffix:semicolon
id|c
op_assign
op_star
op_increment
id|pv
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;n&squot;
)paren
id|val
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;y&squot;
)paren
id|val
op_assign
l_int|1
suffix:semicolon
r_else
id|val
op_assign
(paren
r_int
)paren
id|simple_strtoul
c_func
(paren
id|pv
comma
op_amp
id|pe
comma
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|get_setup_token
c_func
(paren
id|cur
)paren
)paren
(brace
r_case
id|OPT_MAX_TAG
suffix:colon
id|sym_driver_setup.max_tag
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pe
op_logical_and
op_star
id|pe
op_eq
l_char|&squot;/&squot;
)paren
)paren
r_break
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pe
op_logical_and
op_star
id|pe
op_ne
id|ARG_SEP
op_logical_and
id|i
OL
r_sizeof
(paren
id|sym_driver_setup.tag_ctrl
)paren
op_minus
l_int|1
)paren
(brace
id|sym_driver_setup.tag_ctrl
(braket
id|i
op_increment
)braket
op_assign
op_star
id|pe
op_increment
suffix:semicolon
)brace
id|sym_driver_setup.tag_ctrl
(braket
id|i
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_SAFE_SETUP
suffix:colon
id|memcpy
c_func
(paren
op_amp
id|sym_driver_setup
comma
op_amp
id|sym_driver_safe_setup
comma
r_sizeof
(paren
id|sym_driver_setup
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_EXCLUDE
suffix:colon
r_if
c_cond
(paren
id|xi
OL
l_int|8
)paren
id|sym_driver_setup.excludes
(braket
id|xi
op_increment
)braket
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
DECL|macro|__SIMPLE_OPTION
mdefine_line|#define __SIMPLE_OPTION(NAME, name) &bslash;&n;&t;&t;case OPT_ ## NAME :&t;&t;&bslash;&n;&t;&t;&t;sym_driver_setup.name = val;&bslash;&n;&t;&t;&t;break;
id|__SIMPLE_OPTION
c_func
(paren
id|PCI_PARITY
comma
id|pci_parity
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|SCSI_PARITY
comma
id|scsi_parity
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|MIN_SYNC
comma
id|min_sync
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|BURST_ORDER
comma
id|burst_order
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|SCSI_LED
comma
id|scsi_led
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|MAX_WIDE
comma
id|max_wide
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|SCSI_DIFF
comma
id|scsi_diff
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|IRQ_MODE
comma
id|irq_mode
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|SCSI_BUS_CHECK
comma
id|scsi_bus_check
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|HOST_ID
comma
id|host_id
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|MAX_OFFS
comma
id|max_offs
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|MAX_LUN
comma
id|max_lun
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|PCI_FIX_UP
comma
id|pci_fix_up
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|REVERSE_PROBE
comma
id|reverse_probe
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|VERBOSE
comma
id|verbose
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|DEBUG
comma
id|debug
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|SETTLE_DELAY
comma
id|settle_delay
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|USE_NVRAM
comma
id|use_nvram
)paren
DECL|macro|__SIMPLE_OPTION
macro_line|#undef __SIMPLE_OPTION
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;sym53c8xx_setup: unexpected boot option &squot;%.*s&squot; ignored&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|pc
op_minus
id|cur
op_plus
l_int|1
)paren
comma
id|cur
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|cur
op_assign
id|strchr
c_func
(paren
id|cur
comma
id|ARG_SEP
)paren
)paren
op_ne
l_int|NULL
)paren
op_increment
id|cur
suffix:semicolon
)brace
macro_line|#endif&t;/* SYM_LINUX_BOOT_COMMAND_LINE_SUPPORT */
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,3,13)
macro_line|#ifndef MODULE
id|__setup
c_func
(paren
l_string|&quot;sym53c8xx=&quot;
comma
id|sym53c8xx_setup
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
macro_line|#ifdef&t;SYM_CONF_PQS_PDS_SUPPORT
multiline_comment|/*&n; *  Detect all NCR PQS/PDS boards and keep track of their bus nr.&n; *&n; *  The NCR PQS or PDS card is constructed as a DEC bridge&n; *  behind which sit a proprietary NCR memory controller and&n; *  four or two 53c875s as separate devices.  In its usual mode&n; *  of operation, the 875s are slaved to the memory controller&n; *  for all transfers.  We can tell if an 875 is part of a&n; *  PQS/PDS or not since if it is, it will be on the same bus&n; *  as the memory controller.  To operate with the Linux&n; *  driver, the memory controller is disabled and the 875s&n; *  freed to function independently.  The only wrinkle is that&n; *  the preset SCSI ID (which may be zero) must be read in from&n; *  a special configuration space register of the 875&n; */
macro_line|#ifndef SYM_CONF_MAX_PQS_BUS
DECL|macro|SYM_CONF_MAX_PQS_BUS
mdefine_line|#define SYM_CONF_MAX_PQS_BUS 16
macro_line|#endif
DECL|variable|__initdata
r_static
r_int
id|pqs_bus
(braket
id|SYM_CONF_MAX_PQS_BUS
)braket
id|__initdata
op_assign
(brace
l_int|0
)brace
suffix:semicolon
DECL|function|sym_detect_pqs_pds
r_static
r_void
id|__init
id|sym_detect_pqs_pds
c_func
(paren
r_void
)paren
(brace
r_int
id|index
suffix:semicolon
id|pcidev_t
id|dev
op_assign
id|PCIDEV_NULL
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|SYM_CONF_MAX_PQS_BUS
suffix:semicolon
id|index
op_increment
)paren
(brace
id|u_char
id|tmp
suffix:semicolon
id|dev
op_assign
id|pci_find_device
c_func
(paren
l_int|0x101a
comma
l_int|0x0009
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
id|PCIDEV_NULL
)paren
(brace
id|pqs_bus
(braket
id|index
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printf_info
c_func
(paren
id|NAME53C8XX
l_string|&quot;: NCR PQS/PDS memory controller detected on bus %d&bslash;n&quot;
comma
id|PciBusNumber
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|dev
comma
l_int|0x44
comma
op_amp
id|tmp
)paren
suffix:semicolon
multiline_comment|/* bit 1: allow individual 875 configuration */
id|tmp
op_or_assign
l_int|0x2
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|dev
comma
l_int|0x44
comma
id|tmp
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|dev
comma
l_int|0x45
comma
op_amp
id|tmp
)paren
suffix:semicolon
multiline_comment|/* bit 2: drive individual 875 interrupts to the bus */
id|tmp
op_or_assign
l_int|0x4
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|dev
comma
l_int|0x45
comma
id|tmp
)paren
suffix:semicolon
id|pqs_bus
(braket
id|index
)braket
op_assign
id|PciBusNumber
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* SYM_CONF_PQS_PDS_SUPPORT */
multiline_comment|/*&n; *  Read and check the PCI configuration for any detected NCR &n; *  boards and save data for attaching after all boards have &n; *  been detected.&n; */
r_static
r_int
id|__init
DECL|function|sym53c8xx_pci_init
id|sym53c8xx_pci_init
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
comma
id|pcidev_t
id|pdev
comma
id|sym_device
op_star
id|device
)paren
(brace
id|u_short
id|vendor_id
comma
id|device_id
comma
id|command
comma
id|status_reg
suffix:semicolon
id|u_char
id|cache_line_size
suffix:semicolon
id|u_char
id|suggested_cache_line_size
op_assign
l_int|0
suffix:semicolon
id|u_char
id|pci_fix_up
op_assign
id|SYM_SETUP_PCI_FIX_UP
suffix:semicolon
id|u_char
id|revision
suffix:semicolon
id|u_int
id|irq
suffix:semicolon
id|u_long
id|base
comma
id|base_2
comma
id|base_io
suffix:semicolon
id|u_long
id|base_c
comma
id|base_2_c
comma
id|io_port
suffix:semicolon
r_int
id|i
suffix:semicolon
id|sym_chip
op_star
id|chip
suffix:semicolon
multiline_comment|/* Choose some short name for this device */
id|sprintf
c_func
(paren
id|device-&gt;s.inst_name
comma
l_string|&quot;sym.%d.%d.%d&quot;
comma
id|PciBusNumber
c_func
(paren
id|pdev
)paren
comma
(paren
r_int
)paren
(paren
id|PciDeviceFn
c_func
(paren
id|pdev
)paren
op_amp
l_int|0xf8
)paren
op_rshift
l_int|3
comma
(paren
r_int
)paren
(paren
id|PciDeviceFn
c_func
(paren
id|pdev
)paren
op_amp
l_int|7
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Read needed minimal info from the PCI config space.&n;&t; */
id|vendor_id
op_assign
id|PciVendorId
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|device_id
op_assign
id|PciDeviceId
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|irq
op_assign
id|PciIrqLine
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|i
op_assign
id|pci_get_base_address
c_func
(paren
id|pdev
comma
l_int|0
comma
op_amp
id|base_io
)paren
suffix:semicolon
id|io_port
op_assign
id|pci_get_base_cookie
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
id|base_c
op_assign
id|pci_get_base_cookie
c_func
(paren
id|pdev
comma
id|i
)paren
suffix:semicolon
id|i
op_assign
id|pci_get_base_address
c_func
(paren
id|pdev
comma
id|i
comma
op_amp
id|base
)paren
suffix:semicolon
id|base_2_c
op_assign
id|pci_get_base_cookie
c_func
(paren
id|pdev
comma
id|i
)paren
suffix:semicolon
(paren
r_void
)paren
id|pci_get_base_address
c_func
(paren
id|pdev
comma
id|i
comma
op_amp
id|base_2
)paren
suffix:semicolon
id|io_port
op_and_assign
id|PCI_BASE_ADDRESS_IO_MASK
suffix:semicolon
id|base
op_and_assign
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
id|base_2
op_and_assign
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
id|PCI_CLASS_REVISION
comma
op_amp
id|revision
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  If user excluded this chip, donnot initialize it.&n;&t; */
r_if
c_cond
(paren
id|base_io
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sym_driver_setup.excludes
(braket
id|i
)braket
op_eq
id|base_io
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *  Leave here if another driver attached the chip.&n;&t; */
r_if
c_cond
(paren
id|io_port
op_logical_and
id|check_region
(paren
id|io_port
comma
l_int|128
)paren
)paren
(brace
id|printf_info
c_func
(paren
l_string|&quot;%s: IO region 0x%lx[0..127] is in use&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|device
)paren
comma
(paren
r_int
)paren
id|io_port
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Check if the chip is supported.&n;&t; */
id|chip
op_assign
id|sym_lookup_pci_chip_table
c_func
(paren
id|device_id
comma
id|revision
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chip
)paren
(brace
id|printf_info
c_func
(paren
l_string|&quot;%s: device not supported&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Check if the chip has been assigned resources we need.&n;&t; */
macro_line|#ifdef SYM_CONF_IOMAPPED
r_if
c_cond
(paren
op_logical_neg
id|io_port
)paren
(brace
id|printf_info
c_func
(paren
l_string|&quot;%s: IO base address disabled.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
id|base
)paren
(brace
id|printf_info
c_func
(paren
l_string|&quot;%s: MMIO base address disabled.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; *  Ignore Symbios chips controlled by various RAID controllers.&n;&t; *  These controllers set value 0x52414944 at RAM end - 16.&n;&t; */
macro_line|#if defined(__i386__) &amp;&amp; !defined(SYM_OPT_NO_BUS_MEMORY_MAPPING)
r_if
c_cond
(paren
id|base_2_c
)paren
(brace
r_int
r_int
id|ram_size
comma
id|ram_val
suffix:semicolon
id|u_long
id|ram_ptr
suffix:semicolon
r_if
c_cond
(paren
id|chip-&gt;features
op_amp
id|FE_RAM8K
)paren
id|ram_size
op_assign
l_int|8192
suffix:semicolon
r_else
id|ram_size
op_assign
l_int|4096
suffix:semicolon
id|ram_ptr
op_assign
id|pci_map_mem
c_func
(paren
id|base_2_c
comma
id|ram_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ram_ptr
)paren
(brace
id|ram_val
op_assign
id|readl_raw
c_func
(paren
id|ram_ptr
op_plus
id|ram_size
op_minus
l_int|16
)paren
suffix:semicolon
id|pci_unmap_mem
c_func
(paren
id|ram_ptr
comma
id|ram_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ram_val
op_eq
l_int|0x52414944
)paren
(brace
id|printf_info
c_func
(paren
l_string|&quot;%s: not initializing, &quot;
l_string|&quot;driven by RAID controller.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* i386 and PCI MEMORY accessible */
multiline_comment|/*&n;&t; *  Copy the chip description to our device structure, &n;&t; *  so we can make it match the actual device and options.&n;&t; */
id|bcopy
c_func
(paren
id|chip
comma
op_amp
id|device-&gt;chip
comma
r_sizeof
(paren
id|device-&gt;chip
)paren
)paren
suffix:semicolon
id|device-&gt;chip.revision_id
op_assign
id|revision
suffix:semicolon
multiline_comment|/*&n;&t; *  Read additionnal info from the configuration space.&n;&t; */
id|pci_read_config_word
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
op_amp
id|command
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
id|PCI_CACHE_LINE_SIZE
comma
op_amp
id|cache_line_size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Enable missing capabilities in the PCI COMMAND register.&n;&t; */
macro_line|#ifdef SYM_CONF_IOMAPPED
DECL|macro|PCI_COMMAND_BITS_TO_ENABLE
mdefine_line|#define&t;PCI_COMMAND_BITS_TO_ENABLE (PCI_COMMAND_IO | &bslash;&n;&t;PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_PARITY)
macro_line|#else
mdefine_line|#define&t;PCI_COMMAND_BITS_TO_ENABLE &bslash;&n;&t;(PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_PARITY)
macro_line|#endif
r_if
c_cond
(paren
(paren
id|command
op_amp
id|PCI_COMMAND_BITS_TO_ENABLE
)paren
op_ne
id|PCI_COMMAND_BITS_TO_ENABLE
)paren
(brace
id|printf_info
c_func
(paren
l_string|&quot;%s: setting%s%s%s%s...&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|device
)paren
comma
(paren
id|command
op_amp
id|PCI_COMMAND_IO
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; PCI_COMMAND_IO&quot;
comma
(paren
id|command
op_amp
id|PCI_COMMAND_MEMORY
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; PCI_COMMAND_MEMORY&quot;
comma
(paren
id|command
op_amp
id|PCI_COMMAND_MASTER
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; PCI_COMMAND_MASTER&quot;
comma
(paren
id|command
op_amp
id|PCI_COMMAND_PARITY
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; PCI_COMMAND_PARITY&quot;
)paren
suffix:semicolon
id|command
op_or_assign
id|PCI_COMMAND_BITS_TO_ENABLE
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
id|command
)paren
suffix:semicolon
)brace
DECL|macro|PCI_COMMAND_BITS_TO_ENABLE
macro_line|#undef&t;PCI_COMMAND_BITS_TO_ENABLE
multiline_comment|/*&n;&t; *  If cache line size is not configured, suggest&n;&t; *  a value for well known CPUs.&n;&t; */
macro_line|#if defined(__i386__) &amp;&amp; !defined(MODULE)
r_if
c_cond
(paren
op_logical_neg
id|cache_line_size
op_logical_and
id|boot_cpu_data.x86_vendor
op_eq
id|X86_VENDOR_INTEL
)paren
(brace
r_switch
c_cond
(paren
id|boot_cpu_data.x86
)paren
(brace
r_case
l_int|4
suffix:colon
id|suggested_cache_line_size
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
r_if
c_cond
(paren
id|boot_cpu_data.x86_model
OG
l_int|8
)paren
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|suggested_cache_line_size
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* __i386__ */
multiline_comment|/*&n;&t; *  Some features are required to be enabled in order to &n;&t; *  work around some chip problems. :) ;)&n;&t; *  (ITEM 12 of a DEL about the 896 I haven&squot;t yet).&n;&t; *  We must ensure the chip will use WRITE AND INVALIDATE.&n;&t; *  The revision number limit is for now arbitrary.&n;&t; */
r_if
c_cond
(paren
id|device_id
op_eq
id|PCI_DEVICE_ID_NCR_53C896
op_logical_and
id|revision
OL
l_int|0x4
)paren
(brace
id|chip-&gt;features
op_or_assign
(paren
id|FE_WRIE
op_or
id|FE_CLSE
)paren
suffix:semicolon
id|pci_fix_up
op_or_assign
l_int|3
suffix:semicolon
multiline_comment|/* Force appropriate PCI fix-up */
)brace
macro_line|#ifdef&t;SYM_CONF_PCI_FIX_UP
multiline_comment|/*&n;&t; *  Try to fix up PCI config according to wished features.&n;&t; */
r_if
c_cond
(paren
(paren
id|pci_fix_up
op_amp
l_int|1
)paren
op_logical_and
(paren
id|chip-&gt;features
op_amp
id|FE_CLSE
)paren
op_logical_and
op_logical_neg
id|cache_line_size
op_logical_and
id|suggested_cache_line_size
)paren
(brace
id|cache_line_size
op_assign
id|suggested_cache_line_size
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|pdev
comma
id|PCI_CACHE_LINE_SIZE
comma
id|cache_line_size
)paren
suffix:semicolon
id|printf_info
c_func
(paren
l_string|&quot;%s: PCI_CACHE_LINE_SIZE set to %d.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|device
)paren
comma
id|cache_line_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|pci_fix_up
op_amp
l_int|2
)paren
op_logical_and
id|cache_line_size
op_logical_and
(paren
id|chip-&gt;features
op_amp
id|FE_WRIE
)paren
op_logical_and
op_logical_neg
(paren
id|command
op_amp
id|PCI_COMMAND_INVALIDATE
)paren
)paren
(brace
id|printf_info
c_func
(paren
l_string|&quot;%s: setting PCI_COMMAND_INVALIDATE.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
id|command
op_or_assign
id|PCI_COMMAND_INVALIDATE
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
id|command
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* SYM_CONF_PCI_FIX_UP */
multiline_comment|/*&n;&t; *  Work around for errant bit in 895A. The 66Mhz&n;&t; *  capable bit is set erroneously. Clear this bit.&n;&t; *  (Item 1 DEL 533)&n;&t; *&n;&t; *  Make sure Config space and Features agree.&n;&t; *&n;&t; *  Recall: writes are not normal to status register -&n;&t; *  write a 1 to clear and a 0 to leave unchanged.&n;&t; *  Can only reset bits.&n;&t; */
id|pci_read_config_word
c_func
(paren
id|pdev
comma
id|PCI_STATUS
comma
op_amp
id|status_reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chip-&gt;features
op_amp
id|FE_66MHZ
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|status_reg
op_amp
id|PCI_STATUS_66MHZ
)paren
)paren
id|chip-&gt;features
op_and_assign
op_complement
id|FE_66MHZ
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|status_reg
op_amp
id|PCI_STATUS_66MHZ
)paren
(brace
id|status_reg
op_assign
id|PCI_STATUS_66MHZ
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|pdev
comma
id|PCI_STATUS
comma
id|status_reg
)paren
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|pdev
comma
id|PCI_STATUS
comma
op_amp
id|status_reg
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *  Initialise device structure with items required by sym_attach.&n;&t; */
id|device-&gt;pdev
op_assign
id|pdev
suffix:semicolon
id|device-&gt;s.bus
op_assign
id|PciBusNumber
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|device-&gt;s.device_fn
op_assign
id|PciDeviceFn
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|device-&gt;s.base
op_assign
id|base
suffix:semicolon
id|device-&gt;s.base_2
op_assign
id|base_2
suffix:semicolon
id|device-&gt;s.base_c
op_assign
id|base_c
suffix:semicolon
id|device-&gt;s.base_2_c
op_assign
id|base_2_c
suffix:semicolon
id|device-&gt;s.io_port
op_assign
id|io_port
suffix:semicolon
id|device-&gt;s.irq
op_assign
id|irq
suffix:semicolon
id|device-&gt;attach_done
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  List of supported NCR chip ids&n; */
DECL|variable|__initdata
r_static
id|u_short
id|sym_chip_ids
(braket
)braket
id|__initdata
op_assign
(brace
id|PCI_ID_SYM53C810
comma
id|PCI_ID_SYM53C815
comma
id|PCI_ID_SYM53C825
comma
id|PCI_ID_SYM53C860
comma
id|PCI_ID_SYM53C875
comma
id|PCI_ID_SYM53C875_2
comma
id|PCI_ID_SYM53C885
comma
id|PCI_ID_SYM53C875A
comma
id|PCI_ID_SYM53C895
comma
id|PCI_ID_SYM53C896
comma
id|PCI_ID_SYM53C895A
comma
id|PCI_ID_LSI53C1510D
comma
id|PCI_ID_LSI53C1010
comma
id|PCI_ID_LSI53C1010_2
)brace
suffix:semicolon
multiline_comment|/*&n; *  Detect all 53c8xx hosts and then attach them.&n; *&n; *  If we are using NVRAM, once all hosts are detected, we need to &n; *  check any NVRAM for boot order in case detect and boot order &n; *  differ and attach them using the order in the NVRAM.&n; *&n; *  If no NVRAM is found or data appears invalid attach boards in &n; *  the the order they are detected.&n; */
DECL|function|sym53c8xx_detect
r_int
id|__init
id|sym53c8xx_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
id|pcidev_t
id|pcidev
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|chips
comma
id|hosts
comma
id|count
suffix:semicolon
r_int
id|attach_count
op_assign
l_int|0
suffix:semicolon
id|sym_device
op_star
id|devtbl
comma
op_star
id|devp
suffix:semicolon
id|sym_nvram
id|nvram
suffix:semicolon
macro_line|#if SYM_CONF_NVRAM_SUPPORT
id|sym_nvram
id|nvram0
comma
op_star
id|nvp
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *  PCI is required.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|pci_present
c_func
(paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *    Initialize driver general stuff.&n;&t; */
macro_line|#ifdef SYM_LINUX_PROC_INFO_SUPPORT
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2,3,27)
id|tpnt-&gt;proc_dir
op_assign
op_amp
id|proc_scsi_sym53c8xx
suffix:semicolon
macro_line|#else
id|tpnt-&gt;proc_name
op_assign
id|NAME53C8XX
suffix:semicolon
macro_line|#endif
id|tpnt-&gt;proc_info
op_assign
id|sym53c8xx_proc_info
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SYM_LINUX_BOOT_COMMAND_LINE_SUPPORT
macro_line|#ifdef MODULE
r_if
c_cond
(paren
id|sym53c8xx
)paren
id|sym53c8xx_setup
c_func
(paren
id|sym53c8xx
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SYM_LINUX_DEBUG_CONTROL_SUPPORT
id|sym_debug_flags
op_assign
id|sym_driver_setup.debug
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|boot_verbose
op_ge
l_int|2
)paren
id|sym53c8xx_print_driver_setup
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* SYM_LINUX_BOOT_COMMAND_LINE_SUPPORT */
multiline_comment|/*&n;&t; *  Allocate the device table since we donnot want to &n;&t; *  overflow the kernel stack.&n;&t; *  1 x 4K PAGE is enough for more than 40 devices for i386.&n;&t; */
id|devtbl
op_assign
id|sym_calloc
c_func
(paren
id|PAGE_SIZE
comma
l_string|&quot;DEVTBL&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devtbl
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  Detect all NCR PQS/PDS memory controllers.&n;&t; */
macro_line|#ifdef&t;SYM_CONF_PQS_PDS_SUPPORT
id|sym_detect_pqs_pds
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t; *  Detect all 53c8xx hosts.&n;&t; *  Save the first Symbios NVRAM content if any &n;&t; *  for the boot order.&n;&t; */
id|chips
op_assign
r_sizeof
(paren
id|sym_chip_ids
)paren
op_div
r_sizeof
(paren
id|sym_chip_ids
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|hosts
op_assign
id|PAGE_SIZE
op_div
r_sizeof
(paren
op_star
id|devtbl
)paren
suffix:semicolon
macro_line|#if SYM_CONF_NVRAM_SUPPORT
id|nvp
op_assign
(paren
id|sym_driver_setup.use_nvram
op_amp
l_int|0x1
)paren
ques
c_cond
op_amp
id|nvram0
suffix:colon
l_int|0
suffix:semicolon
macro_line|#endif
id|j
op_assign
l_int|0
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
id|pcidev
op_assign
id|PCIDEV_NULL
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_char
op_star
id|msg
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ge
id|hosts
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|j
op_ge
id|chips
)paren
r_break
suffix:semicolon
id|i
op_assign
id|sym_driver_setup.reverse_probe
ques
c_cond
id|chips
op_minus
l_int|1
op_minus
id|j
suffix:colon
id|j
suffix:semicolon
id|pcidev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_NCR
comma
id|sym_chip_ids
(braket
id|i
)braket
comma
id|pcidev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcidev
op_eq
id|PCIDEV_NULL
)paren
(brace
op_increment
id|j
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* This one is guaranteed by AC to do nothing :-) */
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|pcidev
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Some HW as the HP LH4 may report twice PCI devices */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|devtbl
(braket
id|i
)braket
dot
id|s.bus
op_eq
id|PciBusNumber
c_func
(paren
id|pcidev
)paren
op_logical_and
id|devtbl
(braket
id|i
)braket
dot
id|s.device_fn
op_eq
id|PciDeviceFn
c_func
(paren
id|pcidev
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ne
id|count
)paren
multiline_comment|/* Ignore this device if we already have it */
r_continue
suffix:semicolon
id|devp
op_assign
op_amp
id|devtbl
(braket
id|count
)braket
suffix:semicolon
id|devp-&gt;host_id
op_assign
id|SYM_SETUP_HOST_ID
suffix:semicolon
id|devp-&gt;attach_done
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sym53c8xx_pci_init
c_func
(paren
id|tpnt
comma
id|pcidev
comma
id|devp
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
op_increment
id|count
suffix:semicolon
macro_line|#if SYM_CONF_NVRAM_SUPPORT
r_if
c_cond
(paren
id|nvp
)paren
(brace
id|sym_get_nvram
c_func
(paren
id|devp
comma
id|nvp
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|nvp-&gt;type
)paren
(brace
r_case
id|SYM_SYMBIOS_NVRAM
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; *   Switch to the other nvram buffer, so that &n;&t;&t;&t;&t; *   nvram0 will contain the first Symbios &n;&t;&t;&t;&t; *   format NVRAM content with boot order.&n;&t;&t;&t;&t; */
id|nvp
op_assign
op_amp
id|nvram
suffix:semicolon
id|msg
op_assign
l_string|&quot;with Symbios NVRAM&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYM_TEKRAM_NVRAM
suffix:colon
id|msg
op_assign
l_string|&quot;with Tekram NVRAM&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#ifdef&t;SYM_CONF_PQS_PDS_SUPPORT
multiline_comment|/*&n;&t;&t; *  Match the BUS number for PQS/PDS devices.&n;&t;&t; *  Read the SCSI ID from a special register mapped&n;&t;&t; *  into the configuration space of the individual&n;&t;&t; *  875s.  This register is set up by the PQS bios&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SYM_CONF_MAX_PQS_BUS
op_logical_and
id|pqs_bus
(braket
id|i
)braket
op_ne
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|u_char
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|pqs_bus
(braket
id|i
)braket
op_eq
id|PciBusNumber
c_func
(paren
id|pcidev
)paren
)paren
(brace
id|pci_read_config_byte
c_func
(paren
id|pcidev
comma
l_int|0x84
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|devp-&gt;pqs_pds
op_assign
l_int|1
suffix:semicolon
id|devp-&gt;host_id
op_assign
id|tmp
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|devp-&gt;pqs_pds
)paren
id|msg
op_assign
l_string|&quot;(NCR PQS/PDS)&quot;
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|boot_verbose
)paren
id|printf_info
c_func
(paren
l_string|&quot;%s: 53c%s detected %s&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|devp
)paren
comma
id|devp-&gt;chip.name
comma
id|msg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  If we have found a SYMBIOS NVRAM, use first the NVRAM boot &n;&t; *  sequence as device boot order.&n;&t; *  check devices in the boot record against devices detected. &n;&t; *  attach devices if we find a match. boot table records that &n;&t; *  do not match any detected devices will be ignored. &n;&t; *  devices that do not match any boot table will not be attached&n;&t; *  here but will attempt to be attached during the device table &n;&t; *  rescan.&n;&t; */
macro_line|#if SYM_CONF_NVRAM_SUPPORT
r_if
c_cond
(paren
op_logical_neg
id|nvp
op_logical_or
id|nvram0.type
op_ne
id|SYM_SYMBIOS_NVRAM
)paren
r_goto
id|next
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|Symbios_host
op_star
id|h
op_assign
op_amp
id|nvram0.data.Symbios.host
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|count
suffix:semicolon
id|j
op_increment
)paren
(brace
id|devp
op_assign
op_amp
id|devtbl
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
id|h-&gt;device_fn
op_ne
id|devp-&gt;s.device_fn
op_logical_or
id|h-&gt;bus_nr
op_ne
id|devp-&gt;s.bus
op_logical_or
id|h-&gt;device_id
op_ne
id|devp-&gt;chip.device_id
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|devp-&gt;attach_done
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|h-&gt;flags
op_amp
id|SYMBIOS_INIT_SCAN_AT_BOOT
)paren
(brace
id|sym_get_nvram
c_func
(paren
id|devp
comma
id|nvp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sym_attach
(paren
id|tpnt
comma
id|attach_count
comma
id|devp
)paren
)paren
id|attach_count
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|sym_driver_setup.use_nvram
op_amp
l_int|0x80
)paren
)paren
id|printf_info
c_func
(paren
l_string|&quot;%s: 53c%s state OFF thus not attached&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|devp
)paren
comma
id|devp-&gt;chip.name
)paren
suffix:semicolon
r_else
r_continue
suffix:semicolon
id|devp-&gt;attach_done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|next
suffix:colon
macro_line|#endif
multiline_comment|/* &n;&t; *  Rescan device list to make sure all boards attached.&n;&t; *  Devices without boot records will not be attached yet&n;&t; *  so try to attach them here.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|devp
op_assign
op_amp
id|devtbl
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devp-&gt;attach_done
)paren
(brace
id|devp-&gt;nvram
op_assign
op_amp
id|nvram
suffix:semicolon
id|nvram.type
op_assign
l_int|0
suffix:semicolon
macro_line|#if SYM_CONF_NVRAM_SUPPORT
id|sym_get_nvram
c_func
(paren
id|devp
comma
id|nvp
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|sym_attach
(paren
id|tpnt
comma
id|attach_count
comma
id|devp
)paren
)paren
id|attach_count
op_increment
suffix:semicolon
)brace
)brace
id|sym_mfree
c_func
(paren
id|devtbl
comma
id|PAGE_SIZE
comma
l_string|&quot;DEVTBL&quot;
)paren
suffix:semicolon
r_return
id|attach_count
suffix:semicolon
)brace
macro_line|#ifdef MODULE
multiline_comment|/*&n; *  Linux release module stuff.&n; *&n; *  Called before unloading the module.&n; *  Detach the host.&n; *  We have to free resources and halt the NCR chip.&n; *&n; */
DECL|function|sym_detach
r_static
r_int
id|sym_detach
c_func
(paren
id|hcb_p
id|np
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: detaching ...&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Try to delete the timer.&n;&t; *  In the unlikely situation where this failed,&n;&t; *  try to synchronize with the timer handler.&n;&t; */
macro_line|#if LINUX_VERSION_CODE &lt; LinuxVersionCode(2, 4, 0)
id|np-&gt;s.release_stage
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|del_timer
c_func
(paren
op_amp
id|np-&gt;s.timer
)paren
)paren
(brace
r_int
id|i
op_assign
l_int|1000
suffix:semicolon
r_int
id|k
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|u_long
id|flags
suffix:semicolon
id|SYM_LOCK_HCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
id|k
op_assign
id|np-&gt;s.release_stage
suffix:semicolon
id|SYM_UNLOCK_HCB
c_func
(paren
id|np
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|k
op_eq
l_int|2
op_logical_or
op_logical_neg
op_decrement
id|i
)paren
r_break
suffix:semicolon
id|MDELAY
c_func
(paren
l_int|5
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|printk
c_func
(paren
l_string|&quot;%s: failed to kill timer!&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
)brace
id|np-&gt;s.release_stage
op_assign
l_int|2
suffix:semicolon
macro_line|#else
(paren
r_void
)paren
id|del_timer_sync
c_func
(paren
op_amp
id|np-&gt;s.timer
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *  Reset NCR chip.&n;&t; *  We should use sym_soft_reset(), but we donnot want to do &n;&t; *  so, since we may not be safe if interrupts occur.&n;&t; */
id|printk
c_func
(paren
l_string|&quot;%s: resetting chip&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|10
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Free host resources&n;&t; */
id|sym_free_resources
c_func
(paren
id|np
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|sym53c8xx_release
r_int
id|sym53c8xx_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
id|sym_detach
c_func
(paren
(paren
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
)paren
op_member_access_from_pointer
id|ncb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
multiline_comment|/*&n; * For bigots to keep silent. :)&n; */
macro_line|#ifdef MODULE_LICENSE
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;Dual BSD/GPL&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Driver host template.&n; */
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,4,0)
r_static
macro_line|#endif
macro_line|#if LINUX_VERSION_CODE &gt;= LinuxVersionCode(2,4,0) || defined(MODULE)
DECL|variable|driver_template
id|Scsi_Host_Template
id|driver_template
op_assign
id|SYM53C8XX
suffix:semicolon
macro_line|#include &quot;../scsi_module.c&quot;
macro_line|#endif
eof
