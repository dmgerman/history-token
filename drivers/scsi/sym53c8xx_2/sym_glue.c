multiline_comment|/*&n; * Device driver for the SYMBIOS/LSILOGIC 53C8XX and 53C1010 family &n; * of PCI-SCSI IO processors.&n; *&n; * Copyright (C) 1999-2001  Gerard Roudier &lt;groudier@free.fr&gt;&n; * Copyright (c) 2003-2005  Matthew Wilcox &lt;matthew@wil.cx&gt;&n; *&n; * This driver is derived from the Linux sym53c8xx driver.&n; * Copyright (C) 1998-2000  Gerard Roudier&n; *&n; * The sym53c8xx driver is derived from the ncr53c8xx driver that had been &n; * a port of the FreeBSD ncr driver to Linux-1.2.13.&n; *&n; * The original ncr driver has been written for 386bsd and FreeBSD by&n; *         Wolfgang Stanglmeier        &lt;wolf@cologne.de&gt;&n; *         Stefan Esser                &lt;se@mi.Uni-Koeln.de&gt;&n; * Copyright (C) 1994  Wolfgang Stanglmeier&n; *&n; * Other major contributions:&n; *&n; * NVRAM detection and reading.&n; * Copyright (C) 1997 Richard Waltham &lt;dormouse@farsrobt.demon.co.uk&gt;&n; *&n; *-----------------------------------------------------------------------------&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;scsi/scsi.h&gt;
macro_line|#include &lt;scsi/scsi_tcq.h&gt;
macro_line|#include &lt;scsi/scsi_device.h&gt;
macro_line|#include &lt;scsi/scsi_transport.h&gt;
macro_line|#include &quot;sym_glue.h&quot;
macro_line|#include &quot;sym_nvram.h&quot;
DECL|macro|NAME53C
mdefine_line|#define NAME53C&t;&t;&quot;sym53c&quot;
DECL|macro|NAME53C8XX
mdefine_line|#define NAME53C8XX&t;&quot;sym53c8xx&quot;
multiline_comment|/* SPARC just has to be different ... */
macro_line|#ifdef __sparc__
DECL|macro|IRQ_FMT
mdefine_line|#define IRQ_FMT &quot;%s&quot;
DECL|macro|IRQ_PRM
mdefine_line|#define IRQ_PRM(x) __irq_itoa(x)
macro_line|#else
DECL|macro|IRQ_FMT
mdefine_line|#define IRQ_FMT &quot;%d&quot;
DECL|macro|IRQ_PRM
mdefine_line|#define IRQ_PRM(x) (x)
macro_line|#endif
DECL|variable|sym_driver_setup
r_struct
id|sym_driver_setup
id|sym_driver_setup
op_assign
id|SYM_LINUX_DRIVER_SETUP
suffix:semicolon
DECL|variable|sym_debug_flags
r_int
r_int
id|sym_debug_flags
op_assign
l_int|0
suffix:semicolon
DECL|variable|excl_string
r_static
r_char
op_star
id|excl_string
suffix:semicolon
DECL|variable|safe_string
r_static
r_char
op_star
id|safe_string
suffix:semicolon
id|module_param_named
c_func
(paren
id|cmd_per_lun
comma
id|sym_driver_setup.max_tag
comma
id|ushort
comma
l_int|0
)paren
suffix:semicolon
id|module_param_string
c_func
(paren
id|tag_ctrl
comma
id|sym_driver_setup.tag_ctrl
comma
l_int|100
comma
l_int|0
)paren
suffix:semicolon
id|module_param_named
c_func
(paren
id|burst
comma
id|sym_driver_setup.burst_order
comma
id|byte
comma
l_int|0
)paren
suffix:semicolon
id|module_param_named
c_func
(paren
id|led
comma
id|sym_driver_setup.scsi_led
comma
id|byte
comma
l_int|0
)paren
suffix:semicolon
id|module_param_named
c_func
(paren
id|diff
comma
id|sym_driver_setup.scsi_diff
comma
id|byte
comma
l_int|0
)paren
suffix:semicolon
id|module_param_named
c_func
(paren
id|irqm
comma
id|sym_driver_setup.irq_mode
comma
id|byte
comma
l_int|0
)paren
suffix:semicolon
id|module_param_named
c_func
(paren
id|buschk
comma
id|sym_driver_setup.scsi_bus_check
comma
id|byte
comma
l_int|0
)paren
suffix:semicolon
id|module_param_named
c_func
(paren
id|hostid
comma
id|sym_driver_setup.host_id
comma
id|byte
comma
l_int|0
)paren
suffix:semicolon
id|module_param_named
c_func
(paren
id|verb
comma
id|sym_driver_setup.verbose
comma
id|byte
comma
l_int|0
)paren
suffix:semicolon
id|module_param_named
c_func
(paren
id|debug
comma
id|sym_debug_flags
comma
id|uint
comma
l_int|0
)paren
suffix:semicolon
id|module_param_named
c_func
(paren
id|settle
comma
id|sym_driver_setup.settle_delay
comma
id|byte
comma
l_int|0
)paren
suffix:semicolon
id|module_param_named
c_func
(paren
id|nvram
comma
id|sym_driver_setup.use_nvram
comma
id|byte
comma
l_int|0
)paren
suffix:semicolon
id|module_param_named
c_func
(paren
id|excl
comma
id|excl_string
comma
id|charp
comma
l_int|0
)paren
suffix:semicolon
id|module_param_named
c_func
(paren
id|safe
comma
id|safe_string
comma
id|charp
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|cmd_per_lun
comma
l_string|&quot;The maximum number of tags to use by default&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|tag_ctrl
comma
l_string|&quot;More detailed control over tags per LUN&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|burst
comma
l_string|&quot;Maximum burst.  0 to disable, 255 to read from registers&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|led
comma
l_string|&quot;Set to 1 to enable LED support&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|diff
comma
l_string|&quot;0 for no differential mode, 1 for BIOS, 2 for always, 3 for not GPIO3&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|irqm
comma
l_string|&quot;0 for open drain, 1 to leave alone, 2 for totem pole&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|buschk
comma
l_string|&quot;0 to not check, 1 for detach on error, 2 for warn on error&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|hostid
comma
l_string|&quot;The SCSI ID to use for the host adapters&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|verb
comma
l_string|&quot;0 for minimal verbosity, 1 for normal, 2 for excessive&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|debug
comma
l_string|&quot;Set bits to enable debugging&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|settle
comma
l_string|&quot;Settle delay in seconds.  Default 3&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|nvram
comma
l_string|&quot;Option currently not used&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|excl
comma
l_string|&quot;List ioport addresses here to prevent controllers from being attached&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|safe
comma
l_string|&quot;Set other settings to a &bslash;&quot;safe mode&bslash;&quot;&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|SYM_VERSION
id|MODULE_VERSION
c_func
(paren
id|SYM_VERSION
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Matthew Wilcox &lt;matthew@wil.cx&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;NCR, Symbios and LSI 8xx and 1010 PCI SCSI adapters&quot;
)paren
suffix:semicolon
DECL|function|sym2_setup_params
r_static
r_void
id|sym2_setup_params
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|p
op_assign
id|excl_string
suffix:semicolon
r_int
id|xi
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|p
op_logical_and
(paren
id|xi
OL
l_int|8
)paren
)paren
(brace
r_char
op_star
id|next_p
suffix:semicolon
r_int
id|val
op_assign
(paren
r_int
)paren
id|simple_strtoul
c_func
(paren
id|p
comma
op_amp
id|next_p
comma
l_int|0
)paren
suffix:semicolon
id|sym_driver_setup.excludes
(braket
id|xi
op_increment
)braket
op_assign
id|val
suffix:semicolon
id|p
op_assign
id|next_p
suffix:semicolon
)brace
r_if
c_cond
(paren
id|safe_string
)paren
(brace
r_if
c_cond
(paren
op_star
id|safe_string
op_eq
l_char|&squot;y&squot;
)paren
(brace
id|sym_driver_setup.max_tag
op_assign
l_int|0
suffix:semicolon
id|sym_driver_setup.burst_order
op_assign
l_int|0
suffix:semicolon
id|sym_driver_setup.scsi_led
op_assign
l_int|0
suffix:semicolon
id|sym_driver_setup.scsi_diff
op_assign
l_int|1
suffix:semicolon
id|sym_driver_setup.irq_mode
op_assign
l_int|0
suffix:semicolon
id|sym_driver_setup.scsi_bus_check
op_assign
l_int|2
suffix:semicolon
id|sym_driver_setup.host_id
op_assign
l_int|7
suffix:semicolon
id|sym_driver_setup.verbose
op_assign
l_int|2
suffix:semicolon
id|sym_driver_setup.settle_delay
op_assign
l_int|10
suffix:semicolon
id|sym_driver_setup.use_nvram
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|safe_string
op_ne
l_char|&squot;n&squot;
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|NAME53C8XX
l_string|&quot;Ignoring parameter %s&quot;
l_string|&quot; passed to safe option&quot;
comma
id|safe_string
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * We used to try to deal with 64-bit BARs here, but don&squot;t any more.&n; * There are many parts of this driver which would need to be modified&n; * to handle a 64-bit base address, including scripts.  I&squot;m uncomfortable&n; * with making those changes when I have no way of testing it, so I&squot;m&n; * just going to disable it.&n; *&n; * Note that some machines (eg HP rx8620 and Superdome) have bus addresses&n; * below 4GB and physical addresses above 4GB.  These will continue to work.&n; */
r_static
r_int
id|__devinit
DECL|function|pci_get_base_address
id|pci_get_base_address
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_int
id|index
comma
r_int
r_int
op_star
id|basep
)paren
(brace
id|u32
id|tmp
suffix:semicolon
r_int
r_int
id|base
suffix:semicolon
DECL|macro|PCI_BAR_OFFSET
mdefine_line|#define PCI_BAR_OFFSET(index) (PCI_BASE_ADDRESS_0 + (index&lt;&lt;2))
id|pci_read_config_dword
c_func
(paren
id|pdev
comma
id|PCI_BAR_OFFSET
c_func
(paren
id|index
op_increment
)paren
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|base
op_assign
id|tmp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_amp
l_int|0x7
)paren
op_eq
id|PCI_BASE_ADDRESS_MEM_TYPE_64
)paren
(brace
id|pci_read_config_dword
c_func
(paren
id|pdev
comma
id|PCI_BAR_OFFSET
c_func
(paren
id|index
op_increment
)paren
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OG
l_int|0
)paren
id|dev_err
c_func
(paren
op_amp
id|pdev-&gt;dev
comma
l_string|&quot;BAR %d is 64-bit, disabling&bslash;n&quot;
comma
id|index
op_minus
l_int|1
)paren
suffix:semicolon
id|base
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|base
op_amp
id|PCI_BASE_ADDRESS_SPACE
)paren
op_eq
id|PCI_BASE_ADDRESS_SPACE_IO
)paren
(brace
id|base
op_and_assign
id|PCI_BASE_ADDRESS_IO_MASK
suffix:semicolon
)brace
r_else
(brace
id|base
op_and_assign
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
)brace
op_star
id|basep
op_assign
id|base
suffix:semicolon
r_return
id|index
suffix:semicolon
DECL|macro|PCI_BAR_OFFSET
macro_line|#undef PCI_BAR_OFFSET
)brace
DECL|variable|sym2_transport_template
r_static
r_struct
id|scsi_transport_template
op_star
id|sym2_transport_template
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; *  Used by the eh thread to wait for command completion.&n; *  It is allocated on the eh thread stack.&n; */
DECL|struct|sym_eh_wait
r_struct
id|sym_eh_wait
(brace
DECL|member|done
r_struct
id|completion
id|done
suffix:semicolon
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
DECL|member|old_done
r_void
(paren
op_star
id|old_done
)paren
(paren
r_struct
id|scsi_cmnd
op_star
)paren
suffix:semicolon
DECL|member|to_do
r_int
id|to_do
suffix:semicolon
DECL|member|timed_out
r_int
id|timed_out
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; *  Driver private area in the SCSI command structure.&n; */
DECL|struct|sym_ucmd
r_struct
id|sym_ucmd
(brace
multiline_comment|/* Override the SCSI pointer structure */
DECL|member|data_mapping
id|dma_addr_t
id|data_mapping
suffix:semicolon
DECL|member|data_mapped
id|u_char
id|data_mapped
suffix:semicolon
DECL|member|eh_wait
r_struct
id|sym_eh_wait
op_star
id|eh_wait
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|SYM_UCMD_PTR
mdefine_line|#define SYM_UCMD_PTR(cmd)  ((struct sym_ucmd *)(&amp;(cmd)-&gt;SCp))
DECL|macro|SYM_SOFTC_PTR
mdefine_line|#define SYM_SOFTC_PTR(cmd) sym_get_hcb(cmd-&gt;device-&gt;host)
DECL|function|__unmap_scsi_data
r_static
r_void
id|__unmap_scsi_data
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_int
id|dma_dir
op_assign
id|cmd-&gt;sc_data_direction
suffix:semicolon
r_switch
c_cond
(paren
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapped
)paren
(brace
r_case
l_int|2
suffix:colon
id|pci_unmap_sg
c_func
(paren
id|pdev
comma
id|cmd-&gt;buffer
comma
id|cmd-&gt;use_sg
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|pci_unmap_single
c_func
(paren
id|pdev
comma
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapping
comma
id|cmd-&gt;request_bufflen
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapped
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|__map_scsi_single_data
r_static
id|dma_addr_t
id|__map_scsi_single_data
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
id|dma_addr_t
id|mapping
suffix:semicolon
r_int
id|dma_dir
op_assign
id|cmd-&gt;sc_data_direction
suffix:semicolon
id|mapping
op_assign
id|pci_map_single
c_func
(paren
id|pdev
comma
id|cmd-&gt;request_buffer
comma
id|cmd-&gt;request_bufflen
comma
id|dma_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mapping
)paren
(brace
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapped
op_assign
l_int|1
suffix:semicolon
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapping
op_assign
id|mapping
suffix:semicolon
)brace
r_return
id|mapping
suffix:semicolon
)brace
DECL|function|__map_scsi_sg_data
r_static
r_int
id|__map_scsi_sg_data
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_int
id|use_sg
suffix:semicolon
r_int
id|dma_dir
op_assign
id|cmd-&gt;sc_data_direction
suffix:semicolon
id|use_sg
op_assign
id|pci_map_sg
c_func
(paren
id|pdev
comma
id|cmd-&gt;buffer
comma
id|cmd-&gt;use_sg
comma
id|dma_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|use_sg
OG
l_int|0
)paren
(brace
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapped
op_assign
l_int|2
suffix:semicolon
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapping
op_assign
id|use_sg
suffix:semicolon
)brace
r_return
id|use_sg
suffix:semicolon
)brace
DECL|macro|unmap_scsi_data
mdefine_line|#define unmap_scsi_data(np, cmd)&t;&bslash;&n;&t;&t;__unmap_scsi_data(np-&gt;s.device, cmd)
DECL|macro|map_scsi_single_data
mdefine_line|#define map_scsi_single_data(np, cmd)&t;&bslash;&n;&t;&t;__map_scsi_single_data(np-&gt;s.device, cmd)
DECL|macro|map_scsi_sg_data
mdefine_line|#define map_scsi_sg_data(np, cmd)&t;&bslash;&n;&t;&t;__map_scsi_sg_data(np-&gt;s.device, cmd)
multiline_comment|/*&n; *  Complete a pending CAM CCB.&n; */
DECL|function|sym_xpt_done
r_void
id|sym_xpt_done
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
id|unmap_scsi_data
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
DECL|function|sym_xpt_done2
r_static
r_void
id|sym_xpt_done2
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_int
id|cam_status
)paren
(brace
id|sym_set_cam_status
c_func
(paren
id|cmd
comma
id|cam_status
)paren
suffix:semicolon
id|sym_xpt_done
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Tell the SCSI layer about a BUS RESET.&n; */
DECL|function|sym_xpt_async_bus_reset
r_void
id|sym_xpt_async_bus_reset
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
)paren
(brace
id|printf_notice
c_func
(paren
l_string|&quot;%s: SCSI BUS has been reset.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;s.settle_time
op_assign
id|jiffies
op_plus
id|sym_driver_setup.settle_delay
op_star
id|HZ
suffix:semicolon
id|np-&gt;s.settle_time_valid
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sym_verbose
op_ge
l_int|2
)paren
id|printf_info
c_func
(paren
l_string|&quot;%s: command processing suspended for %d seconds&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|sym_driver_setup.settle_delay
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Tell the SCSI layer about a BUS DEVICE RESET message sent.&n; */
DECL|function|sym_xpt_async_sent_bdr
r_void
id|sym_xpt_async_sent_bdr
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_int
id|target
)paren
(brace
id|printf_notice
c_func
(paren
l_string|&quot;%s: TARGET %d has been reset.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|target
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Choose the more appropriate CAM status if &n; *  the IO encountered an extended error.&n; */
DECL|function|sym_xerr_cam_status
r_static
r_int
id|sym_xerr_cam_status
c_func
(paren
r_int
id|cam_status
comma
r_int
id|x_status
)paren
(brace
r_if
c_cond
(paren
id|x_status
)paren
(brace
r_if
c_cond
(paren
id|x_status
op_amp
id|XE_PARITY_ERR
)paren
id|cam_status
op_assign
id|DID_PARITY
suffix:semicolon
r_else
r_if
c_cond
(paren
id|x_status
op_amp
(paren
id|XE_EXTRA_DATA
op_or
id|XE_SODL_UNRUN
op_or
id|XE_SWIDE_OVRUN
)paren
)paren
id|cam_status
op_assign
id|DID_ERROR
suffix:semicolon
r_else
r_if
c_cond
(paren
id|x_status
op_amp
id|XE_BAD_PHASE
)paren
id|cam_status
op_assign
id|DID_ERROR
suffix:semicolon
r_else
id|cam_status
op_assign
id|DID_ERROR
suffix:semicolon
)brace
r_return
id|cam_status
suffix:semicolon
)brace
multiline_comment|/*&n; *  Build CAM result for a failed or auto-sensed IO.&n; */
DECL|function|sym_set_cam_result_error
r_void
id|sym_set_cam_result_error
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_struct
id|sym_ccb
op_star
id|cp
comma
r_int
id|resid
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|cmd
op_assign
id|cp-&gt;cmd
suffix:semicolon
id|u_int
id|cam_status
comma
id|scsi_status
comma
id|drv_status
suffix:semicolon
id|drv_status
op_assign
l_int|0
suffix:semicolon
id|cam_status
op_assign
id|DID_OK
suffix:semicolon
id|scsi_status
op_assign
id|cp-&gt;ssss_status
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;host_flags
op_amp
id|HF_SENSE
)paren
(brace
id|scsi_status
op_assign
id|cp-&gt;sv_scsi_status
suffix:semicolon
id|resid
op_assign
id|cp-&gt;sv_resid
suffix:semicolon
r_if
c_cond
(paren
id|sym_verbose
op_logical_and
id|cp-&gt;sv_xerr_status
)paren
id|sym_print_xerr
c_func
(paren
id|cmd
comma
id|cp-&gt;sv_xerr_status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
op_logical_and
id|cp-&gt;ssss_status
op_eq
id|S_GOOD
op_logical_and
id|cp-&gt;xerr_status
op_eq
l_int|0
)paren
(brace
id|cam_status
op_assign
id|sym_xerr_cam_status
c_func
(paren
id|DID_OK
comma
id|cp-&gt;sv_xerr_status
)paren
suffix:semicolon
id|drv_status
op_assign
id|DRIVER_SENSE
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  Bounce back the sense data to user.&n;&t;&t;&t; */
id|memset
c_func
(paren
op_amp
id|cmd-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|cmd-&gt;sense_buffer
comma
id|cp-&gt;sns_bbuf
comma
id|min
c_func
(paren
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
comma
(paren
r_int
)paren
id|SYM_SNS_BBUF_LEN
)paren
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n;&t;&t;&t; *  If the device reports a UNIT ATTENTION condition &n;&t;&t;&t; *  due to a RESET condition, we should consider all &n;&t;&t;&t; *  disconnect CCBs for this unit as aborted.&n;&t;&t;&t; */
r_if
c_cond
(paren
l_int|1
)paren
(brace
id|u_char
op_star
id|p
suffix:semicolon
id|p
op_assign
(paren
id|u_char
op_star
)paren
id|cmd-&gt;sense_data
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
op_eq
l_int|0x70
op_logical_and
id|p
(braket
l_int|2
)braket
op_eq
l_int|0x6
op_logical_and
id|p
(braket
l_int|12
)braket
op_eq
l_int|0x29
)paren
id|sym_clear_tasks
c_func
(paren
id|np
comma
id|DID_ABORT
comma
id|cp-&gt;target
comma
id|cp-&gt;lun
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Error return from our internal request sense.  This&n;&t;&t;&t; * is bad: we must clear the contingent allegiance&n;&t;&t;&t; * condition otherwise the device will always return&n;&t;&t;&t; * BUSY.  Use a big stick.&n;&t;&t;&t; */
id|sym_reset_scsi_target
c_func
(paren
id|np
comma
id|cmd-&gt;device-&gt;id
)paren
suffix:semicolon
id|cam_status
op_assign
id|DID_ERROR
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
multiline_comment|/* Bad SCSI status */
id|cam_status
op_assign
id|DID_OK
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_SEL_TIMEOUT
)paren
multiline_comment|/* Selection timeout */
id|cam_status
op_assign
id|DID_NO_CONNECT
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_UNEXPECTED
)paren
multiline_comment|/* Unexpected BUS FREE*/
id|cam_status
op_assign
id|DID_ERROR
suffix:semicolon
r_else
(brace
multiline_comment|/* Extended error */
r_if
c_cond
(paren
id|sym_verbose
)paren
(brace
id|sym_print_addr
c_func
(paren
id|cmd
comma
l_string|&quot;COMMAND FAILED (%x %x %x).&bslash;n&quot;
comma
id|cp-&gt;host_status
comma
id|cp-&gt;ssss_status
comma
id|cp-&gt;xerr_status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Set the most appropriate value for CAM status.&n;&t;&t; */
id|cam_status
op_assign
id|sym_xerr_cam_status
c_func
(paren
id|DID_ERROR
comma
id|cp-&gt;xerr_status
)paren
suffix:semicolon
)brace
id|cmd-&gt;resid
op_assign
id|resid
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|drv_status
op_lshift
l_int|24
)paren
op_plus
(paren
id|cam_status
op_lshift
l_int|16
)paren
op_plus
id|scsi_status
suffix:semicolon
)brace
multiline_comment|/*&n; *  Build the scatter/gather array for an I/O.&n; */
DECL|function|sym_scatter_no_sglist
r_static
r_int
id|sym_scatter_no_sglist
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_struct
id|sym_ccb
op_star
id|cp
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|sym_tblmove
op_star
id|data
op_assign
op_amp
id|cp-&gt;phys.data
(braket
id|SYM_CONF_MAX_SG
op_minus
l_int|1
)braket
suffix:semicolon
r_int
id|segment
suffix:semicolon
id|cp-&gt;data_len
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
)paren
(brace
id|dma_addr_t
id|baddr
op_assign
id|map_scsi_single_data
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|baddr
)paren
(brace
id|sym_build_sge
c_func
(paren
id|np
comma
id|data
comma
id|baddr
comma
id|cmd-&gt;request_bufflen
)paren
suffix:semicolon
id|segment
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|segment
op_assign
op_minus
l_int|2
suffix:semicolon
)brace
)brace
r_else
(brace
id|segment
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|segment
suffix:semicolon
)brace
DECL|function|sym_scatter
r_static
r_int
id|sym_scatter
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_struct
id|sym_ccb
op_star
id|cp
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_int
id|segment
suffix:semicolon
r_int
id|use_sg
op_assign
(paren
r_int
)paren
id|cmd-&gt;use_sg
suffix:semicolon
id|cp-&gt;data_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|use_sg
)paren
id|segment
op_assign
id|sym_scatter_no_sglist
c_func
(paren
id|np
comma
id|cp
comma
id|cmd
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|use_sg
op_assign
id|map_scsi_sg_data
c_func
(paren
id|np
comma
id|cmd
)paren
)paren
OG
l_int|0
)paren
(brace
r_struct
id|scatterlist
op_star
id|scatter
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
suffix:semicolon
r_struct
id|sym_tblmove
op_star
id|data
suffix:semicolon
r_if
c_cond
(paren
id|use_sg
OG
id|SYM_CONF_MAX_SG
)paren
(brace
id|unmap_scsi_data
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|data
op_assign
op_amp
id|cp-&gt;phys.data
(braket
id|SYM_CONF_MAX_SG
op_minus
id|use_sg
)braket
suffix:semicolon
r_for
c_loop
(paren
id|segment
op_assign
l_int|0
suffix:semicolon
id|segment
OL
id|use_sg
suffix:semicolon
id|segment
op_increment
)paren
(brace
id|dma_addr_t
id|baddr
op_assign
id|sg_dma_address
c_func
(paren
op_amp
id|scatter
(braket
id|segment
)braket
)paren
suffix:semicolon
r_int
r_int
id|len
op_assign
id|sg_dma_len
c_func
(paren
op_amp
id|scatter
(braket
id|segment
)braket
)paren
suffix:semicolon
id|sym_build_sge
c_func
(paren
id|np
comma
op_amp
id|data
(braket
id|segment
)braket
comma
id|baddr
comma
id|len
)paren
suffix:semicolon
id|cp-&gt;data_len
op_add_assign
id|len
suffix:semicolon
)brace
)brace
r_else
(brace
id|segment
op_assign
op_minus
l_int|2
suffix:semicolon
)brace
r_return
id|segment
suffix:semicolon
)brace
multiline_comment|/*&n; *  Queue a SCSI command.&n; */
DECL|function|sym_queue_command
r_static
r_int
id|sym_queue_command
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
op_assign
id|cmd-&gt;device
suffix:semicolon
r_struct
id|sym_tcb
op_star
id|tp
suffix:semicolon
r_struct
id|sym_lcb
op_star
id|lp
suffix:semicolon
r_struct
id|sym_ccb
op_star
id|cp
suffix:semicolon
r_int
id|order
suffix:semicolon
multiline_comment|/*&n;&t; *  Minimal checkings, so that we will not &n;&t; *  go outside our tables.&n;&t; */
r_if
c_cond
(paren
id|sdev-&gt;id
op_eq
id|np-&gt;myaddr
op_logical_or
id|sdev-&gt;id
op_ge
id|SYM_CONF_MAX_TARGET
op_logical_or
id|sdev-&gt;lun
op_ge
id|SYM_CONF_MAX_LUN
)paren
(brace
id|sym_xpt_done2
c_func
(paren
id|np
comma
id|cmd
comma
id|CAM_DEV_NOT_THERE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Retrieve the target descriptor.&n;&t; */
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|sdev-&gt;id
)braket
suffix:semicolon
multiline_comment|/*&n;&t; *  Complete the 1st INQUIRY command with error &n;&t; *  condition if the device is flagged NOSCAN &n;&t; *  at BOOT in the NVRAM. This may speed up &n;&t; *  the boot and maintain coherency with BIOS &n;&t; *  device numbering. Clearing the flag allows &n;&t; *  user to rescan skipped devices later.&n;&t; *  We also return error for devices not flagged &n;&t; *  for SCAN LUNS in the NVRAM since some mono-lun &n;&t; *  devices behave badly when asked for some non &n;&t; *  zero LUN. Btw, this is an absolute hack.:-)&n;&t; */
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
l_int|0x12
op_logical_or
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
l_int|0x0
)paren
(brace
r_if
c_cond
(paren
(paren
id|tp-&gt;usrflags
op_amp
id|SYM_SCAN_BOOT_DISABLED
)paren
op_logical_or
(paren
(paren
id|tp-&gt;usrflags
op_amp
id|SYM_SCAN_LUNS_DISABLED
)paren
op_logical_and
id|sdev-&gt;lun
op_ne
l_int|0
)paren
)paren
(brace
id|tp-&gt;usrflags
op_and_assign
op_complement
id|SYM_SCAN_BOOT_DISABLED
suffix:semicolon
id|sym_xpt_done2
c_func
(paren
id|np
comma
id|cmd
comma
id|CAM_DEV_NOT_THERE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *  Select tagged/untagged.&n;&t; */
id|lp
op_assign
id|sym_lp
c_func
(paren
id|tp
comma
id|sdev-&gt;lun
)paren
suffix:semicolon
id|order
op_assign
(paren
id|lp
op_logical_and
id|lp-&gt;s.reqtags
)paren
ques
c_cond
id|M_SIMPLE_TAG
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  Queue the SCSI IO.&n;&t; */
id|cp
op_assign
id|sym_get_ccb
c_func
(paren
id|np
comma
id|cmd
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Means resource shortage */
id|sym_queue_scsiio
c_func
(paren
id|np
comma
id|cmd
comma
id|cp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Setup buffers and pointers that address the CDB.&n; */
DECL|function|sym_setup_cdb
r_static
r_inline
r_int
id|sym_setup_cdb
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_struct
id|sym_ccb
op_star
id|cp
)paren
(brace
id|u32
id|cmd_ba
suffix:semicolon
r_int
id|cmd_len
suffix:semicolon
multiline_comment|/*&n;&t; *  CDB is 16 bytes max.&n;&t; */
r_if
c_cond
(paren
id|cmd-&gt;cmd_len
OG
r_sizeof
(paren
id|cp-&gt;cdb_buf
)paren
)paren
(brace
id|sym_set_cam_status
c_func
(paren
id|cp-&gt;cmd
comma
id|CAM_REQ_INVALID
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|cp-&gt;cdb_buf
comma
id|cmd-&gt;cmnd
comma
id|cmd-&gt;cmd_len
)paren
suffix:semicolon
id|cmd_ba
op_assign
id|CCB_BA
(paren
id|cp
comma
id|cdb_buf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|cmd_len
op_assign
id|cmd-&gt;cmd_len
suffix:semicolon
id|cp-&gt;phys.cmd.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|cmd_ba
)paren
suffix:semicolon
id|cp-&gt;phys.cmd.size
op_assign
id|cpu_to_scr
c_func
(paren
id|cmd_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Setup pointers that address the data and start the I/O.&n; */
DECL|function|sym_setup_data_and_start
r_int
id|sym_setup_data_and_start
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_struct
id|sym_ccb
op_star
id|cp
)paren
(brace
r_int
id|dir
suffix:semicolon
r_struct
id|sym_tcb
op_star
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cp-&gt;target
)braket
suffix:semicolon
r_struct
id|sym_lcb
op_star
id|lp
op_assign
id|sym_lp
c_func
(paren
id|tp
comma
id|cp-&gt;lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Build the CDB.&n;&t; */
r_if
c_cond
(paren
id|sym_setup_cdb
c_func
(paren
id|np
comma
id|cmd
comma
id|cp
)paren
)paren
r_goto
id|out_abort
suffix:semicolon
multiline_comment|/*&n;&t; *  No direction means no data.&n;&t; */
id|dir
op_assign
id|cmd-&gt;sc_data_direction
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_ne
id|DMA_NONE
)paren
(brace
id|cp-&gt;segments
op_assign
id|sym_scatter
c_func
(paren
id|np
comma
id|cp
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;segments
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;segments
op_eq
op_minus
l_int|2
)paren
id|sym_set_cam_status
c_func
(paren
id|cmd
comma
id|CAM_RESRC_UNAVAIL
)paren
suffix:semicolon
r_else
id|sym_set_cam_status
c_func
(paren
id|cmd
comma
id|CAM_REQ_TOO_BIG
)paren
suffix:semicolon
r_goto
id|out_abort
suffix:semicolon
)brace
)brace
r_else
(brace
id|cp-&gt;data_len
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;segments
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Set data pointers.&n;&t; */
id|sym_setup_data_pointers
c_func
(paren
id|np
comma
id|cp
comma
id|dir
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  When `#ifed 1&squot;, the code below makes the driver &n;&t; *  panic on the first attempt to write to a SCSI device.&n;&t; *  It is the first test we want to do after a driver &n;&t; *  change that does not seem obviously safe. :)&n;&t; */
macro_line|#if 0
r_switch
c_cond
(paren
id|cp-&gt;cdb_buf
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|0x0A
suffix:colon
r_case
l_int|0x2A
suffix:colon
r_case
l_int|0xAA
suffix:colon
id|panic
c_func
(paren
l_string|&quot;XXXXXXXXXXXXX WRITE NOT YET ALLOWED XXXXXXXXXXXXXX&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; *&t;activate this job.&n;&t; */
r_if
c_cond
(paren
id|lp
)paren
id|sym_start_next_ccbs
c_func
(paren
id|np
comma
id|lp
comma
l_int|2
)paren
suffix:semicolon
r_else
id|sym_put_start_queue
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_abort
suffix:colon
id|sym_free_ccb
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
id|sym_xpt_done
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  timer daemon.&n; *&n; *  Misused to keep the driver running when&n; *  interrupts are not configured correctly.&n; */
DECL|function|sym_timer
r_static
r_void
id|sym_timer
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
)paren
(brace
r_int
r_int
id|thistime
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/*&n;&t; *  Restart the timer.&n;&t; */
id|np-&gt;s.timer.expires
op_assign
id|thistime
op_plus
id|SYM_CONF_TIMER_INTERVAL
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|np-&gt;s.timer
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  If we are resetting the ncr, wait for settle_time before &n;&t; *  clearing it. Then command processing will be resumed.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;s.settle_time_valid
)paren
(brace
r_if
c_cond
(paren
id|time_before_eq
c_func
(paren
id|np-&gt;s.settle_time
comma
id|thistime
)paren
)paren
(brace
r_if
c_cond
(paren
id|sym_verbose
op_ge
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot;%s: command processing resumed&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;s.settle_time_valid
op_assign
l_int|0
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Nothing to do for now, but that may come.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;s.lasttime
op_plus
l_int|4
op_star
id|HZ
OL
id|thistime
)paren
(brace
id|np-&gt;s.lasttime
op_assign
id|thistime
suffix:semicolon
)brace
macro_line|#ifdef SYM_CONF_PCIQ_MAY_MISS_COMPLETIONS
multiline_comment|/*&n;&t; *  Some way-broken PCI bridges may lead to &n;&t; *  completions being lost when the clearing &n;&t; *  of the INTFLY flag by the CPU occurs &n;&t; *  concurrently with the chip raising this flag.&n;&t; *  If this ever happen, lost completions will &n;&t; * be reaped here.&n;&t; */
id|sym_wakeup_done
c_func
(paren
id|np
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; *  PCI BUS error handler.&n; */
DECL|function|sym_log_bus_error
r_void
id|sym_log_bus_error
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
)paren
(brace
id|u_short
id|pci_sts
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|np-&gt;s.device
comma
id|PCI_STATUS
comma
op_amp
id|pci_sts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_sts
op_amp
l_int|0xf900
)paren
(brace
id|pci_write_config_word
c_func
(paren
id|np-&gt;s.device
comma
id|PCI_STATUS
comma
id|pci_sts
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: PCI STATUS = 0x%04x&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|pci_sts
op_amp
l_int|0xf900
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * queuecommand method.  Entered with the host adapter lock held and&n; * interrupts disabled.&n; */
DECL|function|sym53c8xx_queue_command
r_static
r_int
id|sym53c8xx_queue_command
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
r_struct
id|scsi_cmnd
op_star
)paren
)paren
(brace
r_struct
id|sym_hcb
op_star
id|np
op_assign
id|SYM_SOFTC_PTR
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_struct
id|sym_ucmd
op_star
id|ucp
op_assign
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_int
id|sts
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|memset
c_func
(paren
id|ucp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ucp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Shorten our settle_time if needed for &n;&t; *  this command not to time out.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;s.settle_time_valid
op_logical_and
id|cmd-&gt;timeout_per_command
)paren
(brace
r_int
r_int
id|tlimit
op_assign
id|jiffies
op_plus
id|cmd-&gt;timeout_per_command
suffix:semicolon
id|tlimit
op_sub_assign
id|SYM_CONF_TIMER_INTERVAL
op_star
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|np-&gt;s.settle_time
comma
id|tlimit
)paren
)paren
(brace
id|np-&gt;s.settle_time
op_assign
id|tlimit
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|np-&gt;s.settle_time_valid
)paren
r_return
id|SCSI_MLQUEUE_HOST_BUSY
suffix:semicolon
id|sts
op_assign
id|sym_queue_command
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sts
)paren
r_return
id|SCSI_MLQUEUE_HOST_BUSY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Linux entry point of the interrupt handler.&n; */
DECL|function|sym53c8xx_intr
r_static
id|irqreturn_t
id|sym53c8xx_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sym_hcb
op_star
id|np
op_assign
(paren
r_struct
id|sym_hcb
op_star
)paren
id|dev_id
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf_debug
(paren
l_string|&quot;[&quot;
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|np-&gt;s.host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|sym_interrupt
c_func
(paren
id|np
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|np-&gt;s.host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf_debug
(paren
l_string|&quot;]&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/*&n; *  Linux entry point of the timer handler&n; */
DECL|function|sym53c8xx_timer
r_static
r_void
id|sym53c8xx_timer
c_func
(paren
r_int
r_int
id|npref
)paren
(brace
r_struct
id|sym_hcb
op_star
id|np
op_assign
(paren
r_struct
id|sym_hcb
op_star
)paren
id|npref
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|np-&gt;s.host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|sym_timer
c_func
(paren
id|np
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|np-&gt;s.host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  What the eh thread wants us to perform.&n; */
DECL|macro|SYM_EH_ABORT
mdefine_line|#define SYM_EH_ABORT&t;&t;0
DECL|macro|SYM_EH_DEVICE_RESET
mdefine_line|#define SYM_EH_DEVICE_RESET&t;1
DECL|macro|SYM_EH_BUS_RESET
mdefine_line|#define SYM_EH_BUS_RESET&t;2
DECL|macro|SYM_EH_HOST_RESET
mdefine_line|#define SYM_EH_HOST_RESET&t;3
multiline_comment|/*&n; *  What we will do regarding the involved SCSI command.&n; */
DECL|macro|SYM_EH_DO_IGNORE
mdefine_line|#define SYM_EH_DO_IGNORE&t;0
DECL|macro|SYM_EH_DO_COMPLETE
mdefine_line|#define SYM_EH_DO_COMPLETE&t;1
DECL|macro|SYM_EH_DO_WAIT
mdefine_line|#define SYM_EH_DO_WAIT&t;&t;2
multiline_comment|/*&n; *  Our general completion handler.&n; */
DECL|function|__sym_eh_done
r_static
r_void
id|__sym_eh_done
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_int
id|timed_out
)paren
(brace
r_struct
id|sym_eh_wait
op_star
id|ep
op_assign
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|eh_wait
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
)paren
r_return
suffix:semicolon
multiline_comment|/* Try to avoid a race here (not 100% safe) */
r_if
c_cond
(paren
op_logical_neg
id|timed_out
)paren
(brace
id|ep-&gt;timed_out
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;to_do
op_eq
id|SYM_EH_DO_WAIT
op_logical_and
op_logical_neg
id|del_timer
c_func
(paren
op_amp
id|ep-&gt;timer
)paren
)paren
r_return
suffix:semicolon
)brace
multiline_comment|/* Revert everything */
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|eh_wait
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|ep-&gt;old_done
suffix:semicolon
multiline_comment|/* Wake up the eh thread if it wants to sleep */
r_if
c_cond
(paren
id|ep-&gt;to_do
op_eq
id|SYM_EH_DO_WAIT
)paren
id|complete
c_func
(paren
op_amp
id|ep-&gt;done
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  scsi_done() alias when error recovery is in progress. &n; */
DECL|function|sym_eh_done
r_static
r_void
id|sym_eh_done
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
id|__sym_eh_done
c_func
(paren
id|cmd
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Some timeout handler to avoid waiting too long.&n; */
DECL|function|sym_eh_timeout
r_static
r_void
id|sym_eh_timeout
c_func
(paren
id|u_long
id|p
)paren
(brace
id|__sym_eh_done
c_func
(paren
(paren
r_struct
id|scsi_cmnd
op_star
)paren
id|p
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Generic method for our eh processing.&n; *  The &squot;op&squot; argument tells what we have to do.&n; */
DECL|function|sym_eh_handler
r_static
r_int
id|sym_eh_handler
c_func
(paren
r_int
id|op
comma
r_char
op_star
id|opname
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|sym_hcb
op_star
id|np
op_assign
id|SYM_SOFTC_PTR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|SYM_QUEHEAD
op_star
id|qp
suffix:semicolon
r_int
id|to_do
op_assign
id|SYM_EH_DO_IGNORE
suffix:semicolon
r_int
id|sts
op_assign
op_minus
l_int|1
suffix:semicolon
r_struct
id|sym_eh_wait
id|eh
comma
op_star
id|ep
op_assign
op_amp
id|eh
suffix:semicolon
id|dev_warn
c_func
(paren
op_amp
id|cmd-&gt;device-&gt;sdev_gendev
comma
l_string|&quot;%s operation started.&bslash;n&quot;
comma
id|opname
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* This one should be the result of some race, thus to ignore */
r_if
c_cond
(paren
id|cmd-&gt;serial_number
op_ne
id|cmd-&gt;serial_number_at_timeout
)paren
r_goto
id|prepare
suffix:semicolon
macro_line|#endif
multiline_comment|/* This one is queued in some place -&gt; to wait for completion */
id|FOR_EACH_QUEUED_ELEMENT
c_func
(paren
op_amp
id|np-&gt;busy_ccbq
comma
id|qp
)paren
(brace
r_struct
id|sym_ccb
op_star
id|cp
op_assign
id|sym_que_entry
c_func
(paren
id|qp
comma
r_struct
id|sym_ccb
comma
id|link_ccbq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;cmd
op_eq
id|cmd
)paren
(brace
id|to_do
op_assign
id|SYM_EH_DO_WAIT
suffix:semicolon
r_goto
id|prepare
suffix:semicolon
)brace
)brace
id|prepare
suffix:colon
multiline_comment|/* Prepare stuff to either ignore, complete or wait for completion */
r_switch
c_cond
(paren
id|to_do
)paren
(brace
r_default
suffix:colon
r_case
id|SYM_EH_DO_IGNORE
suffix:colon
r_break
suffix:semicolon
r_case
id|SYM_EH_DO_WAIT
suffix:colon
id|init_completion
c_func
(paren
op_amp
id|ep-&gt;done
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|SYM_EH_DO_COMPLETE
suffix:colon
id|ep-&gt;old_done
op_assign
id|cmd-&gt;scsi_done
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|sym_eh_done
suffix:semicolon
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|eh_wait
op_assign
id|ep
suffix:semicolon
)brace
multiline_comment|/* Try to proceed the operation we have been asked for */
id|sts
op_assign
op_minus
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|op
)paren
(brace
r_case
id|SYM_EH_ABORT
suffix:colon
id|sts
op_assign
id|sym_abort_scsiio
c_func
(paren
id|np
comma
id|cmd
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYM_EH_DEVICE_RESET
suffix:colon
id|sts
op_assign
id|sym_reset_scsi_target
c_func
(paren
id|np
comma
id|cmd-&gt;device-&gt;id
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYM_EH_BUS_RESET
suffix:colon
id|sym_reset_scsi_bus
c_func
(paren
id|np
comma
l_int|1
)paren
suffix:semicolon
id|sts
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYM_EH_HOST_RESET
suffix:colon
id|sym_reset_scsi_bus
c_func
(paren
id|np
comma
l_int|0
)paren
suffix:semicolon
id|sym_start_up
(paren
id|np
comma
l_int|1
)paren
suffix:semicolon
id|sts
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/* On error, restore everything and cross fingers :) */
r_if
c_cond
(paren
id|sts
)paren
(brace
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|eh_wait
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|ep-&gt;old_done
suffix:semicolon
id|to_do
op_assign
id|SYM_EH_DO_IGNORE
suffix:semicolon
)brace
id|ep-&gt;to_do
op_assign
id|to_do
suffix:semicolon
multiline_comment|/* Complete the command with locks held as required by the driver */
r_if
c_cond
(paren
id|to_do
op_eq
id|SYM_EH_DO_COMPLETE
)paren
id|sym_xpt_done2
c_func
(paren
id|np
comma
id|cmd
comma
id|CAM_REQ_ABORTED
)paren
suffix:semicolon
multiline_comment|/* Wait for completion with locks released, as required by kernel */
r_if
c_cond
(paren
id|to_do
op_eq
id|SYM_EH_DO_WAIT
)paren
(brace
id|init_timer
c_func
(paren
op_amp
id|ep-&gt;timer
)paren
suffix:semicolon
id|ep-&gt;timer.expires
op_assign
id|jiffies
op_plus
(paren
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
id|ep-&gt;timer.function
op_assign
id|sym_eh_timeout
suffix:semicolon
id|ep-&gt;timer.data
op_assign
(paren
id|u_long
)paren
id|cmd
suffix:semicolon
id|ep-&gt;timed_out
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Be pessimistic for once :) */
id|add_timer
c_func
(paren
op_amp
id|ep-&gt;timer
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|np-&gt;s.host-&gt;host_lock
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|ep-&gt;done
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|np-&gt;s.host-&gt;host_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;timed_out
)paren
id|sts
op_assign
op_minus
l_int|2
suffix:semicolon
)brace
id|dev_warn
c_func
(paren
op_amp
id|cmd-&gt;device-&gt;sdev_gendev
comma
l_string|&quot;%s operation %s.&bslash;n&quot;
comma
id|opname
comma
id|sts
op_eq
l_int|0
ques
c_cond
l_string|&quot;complete&quot;
suffix:colon
id|sts
op_eq
op_minus
l_int|2
ques
c_cond
l_string|&quot;timed-out&quot;
suffix:colon
l_string|&quot;failed&quot;
)paren
suffix:semicolon
r_return
id|sts
ques
c_cond
id|SCSI_FAILED
suffix:colon
id|SCSI_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Error handlers called from the eh thread (one thread per HBA).&n; */
DECL|function|sym53c8xx_eh_abort_handler
r_static
r_int
id|sym53c8xx_eh_abort_handler
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_return
id|sym_eh_handler
c_func
(paren
id|SYM_EH_ABORT
comma
l_string|&quot;ABORT&quot;
comma
id|cmd
)paren
suffix:semicolon
)brace
DECL|function|sym53c8xx_eh_device_reset_handler
r_static
r_int
id|sym53c8xx_eh_device_reset_handler
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_return
id|sym_eh_handler
c_func
(paren
id|SYM_EH_DEVICE_RESET
comma
l_string|&quot;DEVICE RESET&quot;
comma
id|cmd
)paren
suffix:semicolon
)brace
DECL|function|sym53c8xx_eh_bus_reset_handler
r_static
r_int
id|sym53c8xx_eh_bus_reset_handler
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_return
id|sym_eh_handler
c_func
(paren
id|SYM_EH_BUS_RESET
comma
l_string|&quot;BUS RESET&quot;
comma
id|cmd
)paren
suffix:semicolon
)brace
DECL|function|sym53c8xx_eh_host_reset_handler
r_static
r_int
id|sym53c8xx_eh_host_reset_handler
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_return
id|sym_eh_handler
c_func
(paren
id|SYM_EH_HOST_RESET
comma
l_string|&quot;HOST RESET&quot;
comma
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Tune device queuing depth, according to various limits.&n; */
DECL|function|sym_tune_dev_queuing
r_static
r_void
id|sym_tune_dev_queuing
c_func
(paren
r_struct
id|sym_tcb
op_star
id|tp
comma
r_int
id|lun
comma
id|u_short
id|reqtags
)paren
(brace
r_struct
id|sym_lcb
op_star
id|lp
op_assign
id|sym_lp
c_func
(paren
id|tp
comma
id|lun
)paren
suffix:semicolon
id|u_short
id|oldtags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
r_return
suffix:semicolon
id|oldtags
op_assign
id|lp-&gt;s.reqtags
suffix:semicolon
r_if
c_cond
(paren
id|reqtags
OG
id|lp-&gt;s.scdev_depth
)paren
id|reqtags
op_assign
id|lp-&gt;s.scdev_depth
suffix:semicolon
id|lp-&gt;started_limit
op_assign
id|reqtags
ques
c_cond
id|reqtags
suffix:colon
l_int|2
suffix:semicolon
id|lp-&gt;started_max
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;s.reqtags
op_assign
id|reqtags
suffix:semicolon
r_if
c_cond
(paren
id|reqtags
op_ne
id|oldtags
)paren
(brace
id|dev_info
c_func
(paren
op_amp
id|tp-&gt;sdev-&gt;sdev_target-&gt;dev
comma
l_string|&quot;tagged command queuing %s, command queue depth %d.&bslash;n&quot;
comma
id|lp-&gt;s.reqtags
ques
c_cond
l_string|&quot;enabled&quot;
suffix:colon
l_string|&quot;disabled&quot;
comma
id|lp-&gt;started_limit
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *  Linux select queue depths function&n; */
DECL|macro|DEF_DEPTH
mdefine_line|#define DEF_DEPTH&t;(sym_driver_setup.max_tag)
DECL|macro|ALL_TARGETS
mdefine_line|#define ALL_TARGETS&t;-2
DECL|macro|NO_TARGET
mdefine_line|#define NO_TARGET&t;-1
DECL|macro|ALL_LUNS
mdefine_line|#define ALL_LUNS&t;-2
DECL|macro|NO_LUN
mdefine_line|#define NO_LUN&t;&t;-1
DECL|function|device_queue_depth
r_static
r_int
id|device_queue_depth
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_int
id|target
comma
r_int
id|lun
)paren
(brace
r_int
id|c
comma
id|h
comma
id|t
comma
id|u
comma
id|v
suffix:semicolon
r_char
op_star
id|p
op_assign
id|sym_driver_setup.tag_ctrl
suffix:semicolon
r_char
op_star
id|ep
suffix:semicolon
id|h
op_assign
op_minus
l_int|1
suffix:semicolon
id|t
op_assign
id|NO_TARGET
suffix:semicolon
id|u
op_assign
id|NO_LUN
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|p
op_increment
)paren
op_ne
l_int|0
)paren
(brace
id|v
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
op_amp
id|ep
comma
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;/&squot;
suffix:colon
op_increment
id|h
suffix:semicolon
id|t
op_assign
id|ALL_TARGETS
suffix:semicolon
id|u
op_assign
id|ALL_LUNS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
r_if
c_cond
(paren
id|t
op_ne
id|target
)paren
id|t
op_assign
(paren
id|target
op_eq
id|v
)paren
ques
c_cond
id|v
suffix:colon
id|NO_TARGET
suffix:semicolon
id|u
op_assign
id|ALL_LUNS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;u&squot;
suffix:colon
r_if
c_cond
(paren
id|u
op_ne
id|lun
)paren
id|u
op_assign
(paren
id|lun
op_eq
id|v
)paren
ques
c_cond
id|v
suffix:colon
id|NO_LUN
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;q&squot;
suffix:colon
r_if
c_cond
(paren
id|h
op_eq
id|np-&gt;s.unit
op_logical_and
(paren
id|t
op_eq
id|ALL_TARGETS
op_logical_or
id|t
op_eq
id|target
)paren
op_logical_and
(paren
id|u
op_eq
id|ALL_LUNS
op_logical_or
id|u
op_eq
id|lun
)paren
)paren
r_return
id|v
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;-&squot;
suffix:colon
id|t
op_assign
id|ALL_TARGETS
suffix:semicolon
id|u
op_assign
id|ALL_LUNS
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|p
op_assign
id|ep
suffix:semicolon
)brace
r_return
id|DEF_DEPTH
suffix:semicolon
)brace
DECL|function|sym53c8xx_slave_alloc
r_static
r_int
id|sym53c8xx_slave_alloc
c_func
(paren
r_struct
id|scsi_device
op_star
id|device
)paren
(brace
r_struct
id|sym_hcb
op_star
id|np
op_assign
id|sym_get_hcb
c_func
(paren
id|device-&gt;host
)paren
suffix:semicolon
r_struct
id|sym_tcb
op_star
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|device-&gt;id
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;sdev
)paren
id|tp-&gt;sdev
op_assign
id|device
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sym53c8xx_slave_destroy
r_static
r_void
id|sym53c8xx_slave_destroy
c_func
(paren
r_struct
id|scsi_device
op_star
id|device
)paren
(brace
r_struct
id|sym_hcb
op_star
id|np
op_assign
id|sym_get_hcb
c_func
(paren
id|device-&gt;host
)paren
suffix:semicolon
r_struct
id|sym_tcb
op_star
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|device-&gt;id
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;sdev
op_eq
id|device
)paren
id|tp-&gt;sdev
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Linux entry point for device queue sizing.&n; */
DECL|function|sym53c8xx_slave_configure
r_static
r_int
id|sym53c8xx_slave_configure
c_func
(paren
r_struct
id|scsi_device
op_star
id|device
)paren
(brace
r_struct
id|sym_hcb
op_star
id|np
op_assign
id|sym_get_hcb
c_func
(paren
id|device-&gt;host
)paren
suffix:semicolon
r_struct
id|sym_tcb
op_star
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|device-&gt;id
)braket
suffix:semicolon
r_struct
id|sym_lcb
op_star
id|lp
suffix:semicolon
r_int
id|reqtags
comma
id|depth_to_use
suffix:semicolon
multiline_comment|/*&n;&t; *  Allocate the LCB if not yet.&n;&t; *  If it fail, we may well be in the sh*t. :)&n;&t; */
id|lp
op_assign
id|sym_alloc_lcb
c_func
(paren
id|np
comma
id|device-&gt;id
comma
id|device-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/*&n;&t; *  Get user flags.&n;&t; */
id|lp-&gt;curr_flags
op_assign
id|lp-&gt;user_flags
suffix:semicolon
multiline_comment|/*&n;&t; *  Select queue depth from driver setup.&n;&t; *  Donnot use more than configured by user.&n;&t; *  Use at least 2.&n;&t; *  Donnot use more than our maximum.&n;&t; */
id|reqtags
op_assign
id|device_queue_depth
c_func
(paren
id|np
comma
id|device-&gt;id
comma
id|device-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reqtags
OG
id|tp-&gt;usrtags
)paren
id|reqtags
op_assign
id|tp-&gt;usrtags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device-&gt;tagged_supported
)paren
id|reqtags
op_assign
l_int|0
suffix:semicolon
macro_line|#if 1 /* Avoid to locally queue commands for no good reasons */
r_if
c_cond
(paren
id|reqtags
OG
id|SYM_CONF_MAX_TAG
)paren
id|reqtags
op_assign
id|SYM_CONF_MAX_TAG
suffix:semicolon
id|depth_to_use
op_assign
(paren
id|reqtags
ques
c_cond
id|reqtags
suffix:colon
l_int|2
)paren
suffix:semicolon
macro_line|#else
id|depth_to_use
op_assign
(paren
id|reqtags
ques
c_cond
id|SYM_CONF_MAX_TAG
suffix:colon
l_int|2
)paren
suffix:semicolon
macro_line|#endif
id|scsi_adjust_queue_depth
c_func
(paren
id|device
comma
(paren
id|device-&gt;tagged_supported
ques
c_cond
id|MSG_SIMPLE_TAG
suffix:colon
l_int|0
)paren
comma
id|depth_to_use
)paren
suffix:semicolon
id|lp-&gt;s.scdev_depth
op_assign
id|depth_to_use
suffix:semicolon
id|sym_tune_dev_queuing
c_func
(paren
id|tp
comma
id|device-&gt;lun
comma
id|reqtags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|spi_initial_dv
c_func
(paren
id|device-&gt;sdev_target
)paren
)paren
id|spi_dv_device
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Linux entry point for info() function&n; */
DECL|function|sym53c8xx_info
r_static
r_const
r_char
op_star
id|sym53c8xx_info
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_return
id|SYM_DRIVER_NAME
suffix:semicolon
)brace
macro_line|#ifdef SYM_LINUX_PROC_INFO_SUPPORT
multiline_comment|/*&n; *  Proc file system stuff&n; *&n; *  A read operation returns adapter information.&n; *  A write operation is a control command.&n; *  The string is parsed in the driver code and the command is passed &n; *  to the sym_usercmd() function.&n; */
macro_line|#ifdef SYM_LINUX_USER_COMMAND_SUPPORT
DECL|struct|sym_usrcmd
r_struct
id|sym_usrcmd
(brace
DECL|member|target
id|u_long
id|target
suffix:semicolon
DECL|member|lun
id|u_long
id|lun
suffix:semicolon
DECL|member|data
id|u_long
id|data
suffix:semicolon
DECL|member|cmd
id|u_long
id|cmd
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|UC_SETSYNC
mdefine_line|#define UC_SETSYNC      10
DECL|macro|UC_SETTAGS
mdefine_line|#define UC_SETTAGS&t;11
DECL|macro|UC_SETDEBUG
mdefine_line|#define UC_SETDEBUG&t;12
DECL|macro|UC_SETWIDE
mdefine_line|#define UC_SETWIDE&t;14
DECL|macro|UC_SETFLAG
mdefine_line|#define UC_SETFLAG&t;15
DECL|macro|UC_SETVERBOSE
mdefine_line|#define UC_SETVERBOSE&t;17
DECL|macro|UC_RESETDEV
mdefine_line|#define UC_RESETDEV&t;18
DECL|macro|UC_CLEARDEV
mdefine_line|#define UC_CLEARDEV&t;19
DECL|function|sym_exec_user_command
r_static
r_void
id|sym_exec_user_command
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_struct
id|sym_usrcmd
op_star
id|uc
)paren
(brace
r_struct
id|sym_tcb
op_star
id|tp
suffix:semicolon
r_int
id|t
comma
id|l
suffix:semicolon
r_switch
c_cond
(paren
id|uc-&gt;cmd
)paren
(brace
r_case
l_int|0
suffix:colon
r_return
suffix:semicolon
macro_line|#ifdef SYM_LINUX_DEBUG_CONTROL_SUPPORT
r_case
id|UC_SETDEBUG
suffix:colon
id|sym_debug_flags
op_assign
id|uc-&gt;data
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
id|UC_SETVERBOSE
suffix:colon
id|np-&gt;verbose
op_assign
id|uc-&gt;data
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/*&n;&t;&t; * We assume that other commands apply to targets.&n;&t;&t; * This should always be the case and avoid the below &n;&t;&t; * 4 lines to be repeated 6 times.&n;&t;&t; */
r_for
c_loop
(paren
id|t
op_assign
l_int|0
suffix:semicolon
id|t
OL
id|SYM_CONF_MAX_TARGET
suffix:semicolon
id|t
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|uc-&gt;target
op_rshift
id|t
)paren
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|t
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|uc-&gt;cmd
)paren
(brace
r_case
id|UC_SETSYNC
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|uc-&gt;data
op_logical_or
id|uc-&gt;data
op_ge
l_int|255
)paren
(brace
id|tp-&gt;tgoal.iu
op_assign
id|tp-&gt;tgoal.dt
op_assign
id|tp-&gt;tgoal.qas
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;tgoal.offset
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|uc-&gt;data
op_le
l_int|9
op_logical_and
id|np-&gt;minsync_dt
)paren
(brace
r_if
c_cond
(paren
id|uc-&gt;data
OL
id|np-&gt;minsync_dt
)paren
id|uc-&gt;data
op_assign
id|np-&gt;minsync_dt
suffix:semicolon
id|tp-&gt;tgoal.iu
op_assign
id|tp-&gt;tgoal.dt
op_assign
id|tp-&gt;tgoal.qas
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;tgoal.width
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;tgoal.period
op_assign
id|uc-&gt;data
suffix:semicolon
id|tp-&gt;tgoal.offset
op_assign
id|np-&gt;maxoffs_dt
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|uc-&gt;data
OL
id|np-&gt;minsync
)paren
id|uc-&gt;data
op_assign
id|np-&gt;minsync
suffix:semicolon
id|tp-&gt;tgoal.iu
op_assign
id|tp-&gt;tgoal.dt
op_assign
id|tp-&gt;tgoal.qas
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;tgoal.period
op_assign
id|uc-&gt;data
suffix:semicolon
id|tp-&gt;tgoal.offset
op_assign
id|np-&gt;maxoffs
suffix:semicolon
)brace
id|tp-&gt;tgoal.check_nego
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETWIDE
suffix:colon
id|tp-&gt;tgoal.width
op_assign
id|uc-&gt;data
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|tp-&gt;tgoal.check_nego
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETTAGS
suffix:colon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|SYM_CONF_MAX_LUN
suffix:semicolon
id|l
op_increment
)paren
id|sym_tune_dev_queuing
c_func
(paren
id|tp
comma
id|l
comma
id|uc-&gt;data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_RESETDEV
suffix:colon
id|tp-&gt;to_reset
op_assign
l_int|1
suffix:semicolon
id|np-&gt;istat_sem
op_assign
id|SEM
suffix:semicolon
id|OUTB
c_func
(paren
id|np
comma
id|nc_istat
comma
id|SIGP
op_or
id|SEM
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_CLEARDEV
suffix:colon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|SYM_CONF_MAX_LUN
suffix:semicolon
id|l
op_increment
)paren
(brace
r_struct
id|sym_lcb
op_star
id|lp
op_assign
id|sym_lp
c_func
(paren
id|tp
comma
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp
)paren
id|lp-&gt;to_clear
op_assign
l_int|1
suffix:semicolon
)brace
id|np-&gt;istat_sem
op_assign
id|SEM
suffix:semicolon
id|OUTB
c_func
(paren
id|np
comma
id|nc_istat
comma
id|SIGP
op_or
id|SEM
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETFLAG
suffix:colon
id|tp-&gt;usrflags
op_assign
id|uc-&gt;data
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
)brace
DECL|function|skip_spaces
r_static
r_int
id|skip_spaces
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
id|len
)paren
(brace
r_int
id|cnt
comma
id|c
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
id|len
suffix:semicolon
id|cnt
OG
l_int|0
op_logical_and
(paren
id|c
op_assign
op_star
id|ptr
op_increment
)paren
op_logical_and
id|isspace
c_func
(paren
id|c
)paren
suffix:semicolon
id|cnt
op_decrement
)paren
suffix:semicolon
r_return
(paren
id|len
op_minus
id|cnt
)paren
suffix:semicolon
)brace
DECL|function|get_int_arg
r_static
r_int
id|get_int_arg
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
id|len
comma
id|u_long
op_star
id|pv
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
op_star
id|pv
op_assign
id|simple_strtoul
c_func
(paren
id|ptr
comma
op_amp
id|end
comma
l_int|10
)paren
suffix:semicolon
r_return
(paren
id|end
op_minus
id|ptr
)paren
suffix:semicolon
)brace
DECL|function|is_keyword
r_static
r_int
id|is_keyword
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
id|len
comma
r_char
op_star
id|verb
)paren
(brace
r_int
id|verb_len
op_assign
id|strlen
c_func
(paren
id|verb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
id|verb_len
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|verb
comma
id|ptr
comma
id|verb_len
)paren
)paren
r_return
id|verb_len
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|SKIP_SPACES
mdefine_line|#define SKIP_SPACES(ptr, len)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if ((arg_len = skip_spaces(ptr, len)) &lt; 1)&t;&t;&t;&bslash;&n;&t;&t;return -EINVAL;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ptr += arg_len; len -= arg_len;
DECL|macro|GET_INT_ARG
mdefine_line|#define GET_INT_ARG(ptr, len, v)&t;&t;&t;&t;&t;&bslash;&n;&t;if (!(arg_len = get_int_arg(ptr, len, &amp;(v))))&t;&t;&t;&bslash;&n;&t;&t;return -EINVAL;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ptr += arg_len; len -= arg_len;
multiline_comment|/*&n; * Parse a control command&n; */
DECL|function|sym_user_command
r_static
r_int
id|sym_user_command
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_char
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
r_char
op_star
id|ptr
op_assign
id|buffer
suffix:semicolon
r_int
id|len
op_assign
id|length
suffix:semicolon
r_struct
id|sym_usrcmd
id|cmd
comma
op_star
id|uc
op_assign
op_amp
id|cmd
suffix:semicolon
r_int
id|arg_len
suffix:semicolon
id|u_long
id|target
suffix:semicolon
id|memset
c_func
(paren
id|uc
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|uc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
op_logical_and
id|ptr
(braket
id|len
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
op_decrement
id|len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setsync&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETSYNC
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;settags&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETTAGS
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setverbose&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETVERBOSE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setwide&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETWIDE
suffix:semicolon
macro_line|#ifdef SYM_LINUX_DEBUG_CONTROL_SUPPORT
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setdebug&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETDEBUG
suffix:semicolon
macro_line|#endif
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setflag&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETFLAG
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;resetdev&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_RESETDEV
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;cleardev&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_CLEARDEV
suffix:semicolon
r_else
id|arg_len
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;sym_user_command: arg_len=%d, cmd=%ld&bslash;n&quot;
comma
id|arg_len
comma
id|uc-&gt;cmd
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|arg_len
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
r_switch
c_cond
(paren
id|uc-&gt;cmd
)paren
(brace
r_case
id|UC_SETSYNC
suffix:colon
r_case
id|UC_SETTAGS
suffix:colon
r_case
id|UC_SETWIDE
suffix:colon
r_case
id|UC_SETFLAG
suffix:colon
r_case
id|UC_RESETDEV
suffix:colon
r_case
id|UC_CLEARDEV
suffix:colon
id|SKIP_SPACES
c_func
(paren
id|ptr
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;all&quot;
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
id|uc-&gt;target
op_assign
op_complement
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|GET_INT_ARG
c_func
(paren
id|ptr
comma
id|len
comma
id|target
)paren
suffix:semicolon
id|uc-&gt;target
op_assign
(paren
l_int|1
op_lshift
id|target
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;sym_user_command: target=%ld&bslash;n&quot;
comma
id|target
)paren
suffix:semicolon
macro_line|#endif
)brace
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|uc-&gt;cmd
)paren
(brace
r_case
id|UC_SETVERBOSE
suffix:colon
r_case
id|UC_SETSYNC
suffix:colon
r_case
id|UC_SETTAGS
suffix:colon
r_case
id|UC_SETWIDE
suffix:colon
id|SKIP_SPACES
c_func
(paren
id|ptr
comma
id|len
)paren
suffix:semicolon
id|GET_INT_ARG
c_func
(paren
id|ptr
comma
id|len
comma
id|uc-&gt;data
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;sym_user_command: data=%ld&bslash;n&quot;
comma
id|uc-&gt;data
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
macro_line|#ifdef SYM_LINUX_DEBUG_CONTROL_SUPPORT
r_case
id|UC_SETDEBUG
suffix:colon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|SKIP_SPACES
c_func
(paren
id|ptr
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;alloc&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_ALLOC
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;phase&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_PHASE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;queue&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_QUEUE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;result&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_RESULT
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;scatter&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_SCATTER
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;script&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_SCRIPT
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;tiny&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_TINY
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;timing&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_TIMING
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;nego&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_NEGO
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;tags&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_TAGS
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;pointer&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_POINTER
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;sym_user_command: data=%ld&bslash;n&quot;
comma
id|uc-&gt;data
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
macro_line|#endif /* SYM_LINUX_DEBUG_CONTROL_SUPPORT */
r_case
id|UC_SETFLAG
suffix:colon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|SKIP_SPACES
c_func
(paren
id|ptr
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;no_disc&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_and_assign
op_complement
id|SYM_DISC_ENABLED
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|np-&gt;s.host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|sym_exec_user_command
(paren
id|np
comma
id|uc
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|np-&gt;s.host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|length
suffix:semicolon
)brace
macro_line|#endif&t;/* SYM_LINUX_USER_COMMAND_SUPPORT */
macro_line|#ifdef SYM_LINUX_USER_INFO_SUPPORT
multiline_comment|/*&n; *  Informations through the proc file system.&n; */
DECL|struct|info_str
r_struct
id|info_str
(brace
DECL|member|buffer
r_char
op_star
id|buffer
suffix:semicolon
DECL|member|length
r_int
id|length
suffix:semicolon
DECL|member|offset
r_int
id|offset
suffix:semicolon
DECL|member|pos
r_int
id|pos
suffix:semicolon
)brace
suffix:semicolon
DECL|function|copy_mem_info
r_static
r_void
id|copy_mem_info
c_func
(paren
r_struct
id|info_str
op_star
id|info
comma
r_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pos
op_plus
id|len
OG
id|info-&gt;length
)paren
id|len
op_assign
id|info-&gt;length
op_minus
id|info-&gt;pos
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;pos
op_plus
id|len
OL
id|info-&gt;offset
)paren
(brace
id|info-&gt;pos
op_add_assign
id|len
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;pos
OL
id|info-&gt;offset
)paren
(brace
id|data
op_add_assign
(paren
id|info-&gt;offset
op_minus
id|info-&gt;pos
)paren
suffix:semicolon
id|len
op_sub_assign
(paren
id|info-&gt;offset
op_minus
id|info-&gt;pos
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|info-&gt;buffer
op_plus
id|info-&gt;pos
comma
id|data
comma
id|len
)paren
suffix:semicolon
id|info-&gt;pos
op_add_assign
id|len
suffix:semicolon
)brace
)brace
DECL|function|copy_info
r_static
r_int
id|copy_info
c_func
(paren
r_struct
id|info_str
op_star
id|info
comma
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_char
id|buf
(braket
l_int|81
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|len
op_assign
id|vsprintf
c_func
(paren
id|buf
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
id|copy_mem_info
c_func
(paren
id|info
comma
id|buf
comma
id|len
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; *  Copy formatted information into the input buffer.&n; */
DECL|function|sym_host_info
r_static
r_int
id|sym_host_info
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_char
op_star
id|ptr
comma
id|off_t
id|offset
comma
r_int
id|len
)paren
(brace
r_struct
id|info_str
id|info
suffix:semicolon
id|info.buffer
op_assign
id|ptr
suffix:semicolon
id|info.length
op_assign
id|len
suffix:semicolon
id|info.offset
op_assign
id|offset
suffix:semicolon
id|info.pos
op_assign
l_int|0
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Chip &quot;
id|NAME53C
l_string|&quot;%s, device id 0x%x, &quot;
l_string|&quot;revision id 0x%x&bslash;n&quot;
comma
id|np-&gt;s.chip_name
comma
id|np-&gt;device_id
comma
id|np-&gt;revision_id
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;At PCI address %s, IRQ &quot;
id|IRQ_FMT
l_string|&quot;&bslash;n&quot;
comma
id|pci_name
c_func
(paren
id|np-&gt;s.device
)paren
comma
id|IRQ_PRM
c_func
(paren
id|np-&gt;s.irq
)paren
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Min. period factor %d, %s SCSI BUS%s&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|np-&gt;minsync_dt
ques
c_cond
id|np-&gt;minsync_dt
suffix:colon
id|np-&gt;minsync
)paren
comma
id|np-&gt;maxwide
ques
c_cond
l_string|&quot;Wide&quot;
suffix:colon
l_string|&quot;Narrow&quot;
comma
id|np-&gt;minsync_dt
ques
c_cond
l_string|&quot;, DT capable&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Max. started commands %d, &quot;
l_string|&quot;max. commands per LUN %d&bslash;n&quot;
comma
id|SYM_CONF_MAX_START
comma
id|SYM_CONF_MAX_TAG
)paren
suffix:semicolon
r_return
id|info.pos
OG
id|info.offset
ques
c_cond
id|info.pos
op_minus
id|info.offset
suffix:colon
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* SYM_LINUX_USER_INFO_SUPPORT */
multiline_comment|/*&n; *  Entry point of the scsi proc fs of the driver.&n; *  - func = 0 means read  (returns adapter infos)&n; *  - func = 1 means write (not yet merget from sym53c8xx)&n; */
DECL|function|sym53c8xx_proc_info
r_static
r_int
id|sym53c8xx_proc_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|func
)paren
(brace
r_struct
id|sym_hcb
op_star
id|np
op_assign
id|sym_get_hcb
c_func
(paren
id|host
)paren
suffix:semicolon
r_int
id|retv
suffix:semicolon
r_if
c_cond
(paren
id|func
)paren
(brace
macro_line|#ifdef&t;SYM_LINUX_USER_COMMAND_SUPPORT
id|retv
op_assign
id|sym_user_command
c_func
(paren
id|np
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
macro_line|#else
id|retv
op_assign
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_if
c_cond
(paren
id|start
)paren
op_star
id|start
op_assign
id|buffer
suffix:semicolon
macro_line|#ifdef SYM_LINUX_USER_INFO_SUPPORT
id|retv
op_assign
id|sym_host_info
c_func
(paren
id|np
comma
id|buffer
comma
id|offset
comma
id|length
)paren
suffix:semicolon
macro_line|#else
id|retv
op_assign
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif
)brace
r_return
id|retv
suffix:semicolon
)brace
macro_line|#endif /* SYM_LINUX_PROC_INFO_SUPPORT */
multiline_comment|/*&n; *&t;Free controller resources.&n; */
DECL|function|sym_free_resources
r_static
r_void
id|sym_free_resources
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
multiline_comment|/*&n;&t; *  Free O/S specific resources.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;s.irq
)paren
id|free_irq
c_func
(paren
id|np-&gt;s.irq
comma
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;s.ioaddr
)paren
id|pci_iounmap
c_func
(paren
id|pdev
comma
id|np-&gt;s.ioaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;s.ramaddr
)paren
id|pci_iounmap
c_func
(paren
id|pdev
comma
id|np-&gt;s.ramaddr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Free O/S independent resources.&n;&t; */
id|sym_hcb_free
c_func
(paren
id|np
)paren
suffix:semicolon
id|sym_mfree_dma
c_func
(paren
id|np
comma
r_sizeof
(paren
op_star
id|np
)paren
comma
l_string|&quot;HCB&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Ask/tell the system about DMA addressing.&n; */
DECL|function|sym_setup_bus_dma_mask
r_static
r_int
id|sym_setup_bus_dma_mask
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
)paren
(brace
macro_line|#if SYM_CONF_DMA_ADDRESSING_MODE &gt; 0
macro_line|#if   SYM_CONF_DMA_ADDRESSING_MODE == 1
DECL|macro|DMA_DAC_MASK
mdefine_line|#define&t;DMA_DAC_MASK&t;0x000000ffffffffffULL /* 40-bit */
macro_line|#elif SYM_CONF_DMA_ADDRESSING_MODE == 2
mdefine_line|#define&t;DMA_DAC_MASK&t;DMA_64BIT_MASK
macro_line|#endif
r_if
c_cond
(paren
(paren
id|np-&gt;features
op_amp
id|FE_DAC
)paren
op_logical_and
op_logical_neg
id|pci_set_dma_mask
c_func
(paren
id|np-&gt;s.device
comma
id|DMA_DAC_MASK
)paren
)paren
(brace
id|np-&gt;use_dac
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|pci_set_dma_mask
c_func
(paren
id|np-&gt;s.device
comma
id|DMA_32BIT_MASK
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|printf_warning
c_func
(paren
l_string|&quot;%s: No suitable DMA available&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *  Host attach and initialisations.&n; *&n; *  Allocate host data and ncb structure.&n; *  Remap MMIO region.&n; *  Do chip initialization.&n; *  If all is OK, install interrupt handling and&n; *  start the timer daemon.&n; */
DECL|function|sym_attach
r_static
r_struct
id|Scsi_Host
op_star
id|__devinit
id|sym_attach
c_func
(paren
r_struct
id|scsi_host_template
op_star
id|tpnt
comma
r_int
id|unit
comma
r_struct
id|sym_device
op_star
id|dev
)paren
(brace
r_struct
id|host_data
op_star
id|host_data
suffix:semicolon
r_struct
id|sym_hcb
op_star
id|np
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pdev
op_assign
id|dev-&gt;pdev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sym_fw
op_star
id|fw
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;sym%d: &lt;%s&gt; rev 0x%x at pci %s irq &quot;
id|IRQ_FMT
l_string|&quot;&bslash;n&quot;
comma
id|unit
comma
id|dev-&gt;chip.name
comma
id|dev-&gt;chip.revision_id
comma
id|pci_name
c_func
(paren
id|pdev
)paren
comma
id|IRQ_PRM
c_func
(paren
id|pdev-&gt;irq
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Get the firmware for this chip.&n;&t; */
id|fw
op_assign
id|sym_find_firmware
c_func
(paren
op_amp
id|dev-&gt;chip
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fw
)paren
r_goto
id|attach_failed
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allocate host_data structure&n;&t; */
id|instance
op_assign
id|scsi_host_alloc
c_func
(paren
id|tpnt
comma
r_sizeof
(paren
op_star
id|host_data
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|instance
)paren
r_goto
id|attach_failed
suffix:semicolon
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
multiline_comment|/*&n;&t; *  Allocate immediately the host control block, &n;&t; *  since we are only expecting to succeed. :)&n;&t; *  We keep track in the HCB of all the resources that &n;&t; *  are to be released on error.&n;&t; */
id|np
op_assign
id|__sym_calloc_dma
c_func
(paren
op_amp
id|pdev-&gt;dev
comma
r_sizeof
(paren
op_star
id|np
)paren
comma
l_string|&quot;HCB&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np
)paren
r_goto
id|attach_failed
suffix:semicolon
id|np-&gt;s.device
op_assign
id|pdev
suffix:semicolon
id|np-&gt;bus_dmat
op_assign
op_amp
id|pdev-&gt;dev
suffix:semicolon
multiline_comment|/* Result in 1 DMA pool per HBA */
id|host_data-&gt;ncb
op_assign
id|np
suffix:semicolon
id|np-&gt;s.host
op_assign
id|instance
suffix:semicolon
id|pci_set_drvdata
c_func
(paren
id|pdev
comma
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Copy some useful infos to the HCB.&n;&t; */
id|np-&gt;hcb_ba
op_assign
id|vtobus
c_func
(paren
id|np
)paren
suffix:semicolon
id|np-&gt;verbose
op_assign
id|sym_driver_setup.verbose
suffix:semicolon
id|np-&gt;s.device
op_assign
id|pdev
suffix:semicolon
id|np-&gt;s.unit
op_assign
id|unit
suffix:semicolon
id|np-&gt;device_id
op_assign
id|dev-&gt;chip.device_id
suffix:semicolon
id|np-&gt;revision_id
op_assign
id|dev-&gt;chip.revision_id
suffix:semicolon
id|np-&gt;features
op_assign
id|dev-&gt;chip.features
suffix:semicolon
id|np-&gt;clock_divn
op_assign
id|dev-&gt;chip.nr_divisor
suffix:semicolon
id|np-&gt;maxoffs
op_assign
id|dev-&gt;chip.offset_max
suffix:semicolon
id|np-&gt;maxburst
op_assign
id|dev-&gt;chip.burst_max
suffix:semicolon
id|np-&gt;myaddr
op_assign
id|dev-&gt;host_id
suffix:semicolon
multiline_comment|/*&n;&t; *  Edit its name.&n;&t; */
id|strlcpy
c_func
(paren
id|np-&gt;s.chip_name
comma
id|dev-&gt;chip.name
comma
r_sizeof
(paren
id|np-&gt;s.chip_name
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|np-&gt;s.inst_name
comma
l_string|&quot;sym%d&quot;
comma
id|np-&gt;s.unit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sym_setup_bus_dma_mask
c_func
(paren
id|np
)paren
)paren
r_goto
id|attach_failed
suffix:semicolon
multiline_comment|/*&n;&t; *  Try to map the controller chip to&n;&t; *  virtual and physical memory.&n;&t; */
id|np-&gt;mmio_ba
op_assign
(paren
id|u32
)paren
id|dev-&gt;mmio_base
suffix:semicolon
id|np-&gt;s.ioaddr
op_assign
id|dev-&gt;s.ioaddr
suffix:semicolon
id|np-&gt;s.ramaddr
op_assign
id|dev-&gt;s.ramaddr
suffix:semicolon
id|np-&gt;s.io_ws
op_assign
(paren
id|np-&gt;features
op_amp
id|FE_IO256
)paren
ques
c_cond
l_int|256
suffix:colon
l_int|128
suffix:semicolon
multiline_comment|/*&n;&t; *  Map on-chip RAM if present and supported.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_RAM
)paren
)paren
id|dev-&gt;ram_base
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;ram_base
)paren
(brace
id|np-&gt;ram_ba
op_assign
(paren
id|u32
)paren
id|dev-&gt;ram_base
suffix:semicolon
id|np-&gt;ram_ws
op_assign
(paren
id|np-&gt;features
op_amp
id|FE_RAM8K
)paren
ques
c_cond
l_int|8192
suffix:colon
l_int|4096
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sym_hcb_attach
c_func
(paren
id|instance
comma
id|fw
comma
id|dev-&gt;nvram
)paren
)paren
r_goto
id|attach_failed
suffix:semicolon
multiline_comment|/*&n;&t; *  Install the interrupt handler.&n;&t; *  If we synchonize the C code with SCRIPTS on interrupt, &n;&t; *  we do not want to share the INTR line at all.&n;&t; */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|pdev-&gt;irq
comma
id|sym53c8xx_intr
comma
id|SA_SHIRQ
comma
id|NAME53C8XX
comma
id|np
)paren
)paren
(brace
id|printf_err
c_func
(paren
l_string|&quot;%s: request irq %d failure&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|pdev-&gt;irq
)paren
suffix:semicolon
r_goto
id|attach_failed
suffix:semicolon
)brace
id|np-&gt;s.irq
op_assign
id|pdev-&gt;irq
suffix:semicolon
multiline_comment|/*&n;&t; *  After SCSI devices have been opened, we cannot&n;&t; *  reset the bus safely, so we do it here.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
id|instance-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sym_reset_scsi_bus
c_func
(paren
id|np
comma
l_int|0
)paren
)paren
r_goto
id|reset_failed
suffix:semicolon
multiline_comment|/*&n;&t; *  Start the SCRIPTS.&n;&t; */
id|sym_start_up
(paren
id|np
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Start the timer daemon&n;&t; */
id|init_timer
c_func
(paren
op_amp
id|np-&gt;s.timer
)paren
suffix:semicolon
id|np-&gt;s.timer.data
op_assign
(paren
r_int
r_int
)paren
id|np
suffix:semicolon
id|np-&gt;s.timer.function
op_assign
id|sym53c8xx_timer
suffix:semicolon
id|np-&gt;s.lasttime
op_assign
l_int|0
suffix:semicolon
id|sym_timer
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Fill Linux host instance structure&n;&t; *  and return success.&n;&t; */
id|instance-&gt;max_channel
op_assign
l_int|0
suffix:semicolon
id|instance-&gt;this_id
op_assign
id|np-&gt;myaddr
suffix:semicolon
id|instance-&gt;max_id
op_assign
id|np-&gt;maxwide
ques
c_cond
l_int|16
suffix:colon
l_int|8
suffix:semicolon
id|instance-&gt;max_lun
op_assign
id|SYM_CONF_MAX_LUN
suffix:semicolon
id|instance-&gt;unique_id
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
id|instance-&gt;cmd_per_lun
op_assign
id|SYM_CONF_MAX_TAG
suffix:semicolon
id|instance-&gt;can_queue
op_assign
(paren
id|SYM_CONF_MAX_START
op_minus
l_int|2
)paren
suffix:semicolon
id|instance-&gt;sg_tablesize
op_assign
id|SYM_CONF_MAX_SG
suffix:semicolon
id|instance-&gt;max_cmd_len
op_assign
l_int|16
suffix:semicolon
id|BUG_ON
c_func
(paren
id|sym2_transport_template
op_eq
l_int|NULL
)paren
suffix:semicolon
id|instance-&gt;transportt
op_assign
id|sym2_transport_template
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|instance-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|instance
suffix:semicolon
id|reset_failed
suffix:colon
id|printf_err
c_func
(paren
l_string|&quot;%s: FATAL ERROR: CHECK SCSI BUS - CABLES, &quot;
l_string|&quot;TERMINATION, DEVICE POWER etc.!&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|instance-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|attach_failed
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|instance
)paren
r_return
l_int|NULL
suffix:semicolon
id|printf_info
c_func
(paren
l_string|&quot;%s: giving up ...&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np
)paren
id|sym_free_resources
c_func
(paren
id|np
comma
id|pdev
)paren
suffix:semicolon
id|scsi_host_put
c_func
(paren
id|instance
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *    Detect and try to read SYMBIOS and TEKRAM NVRAM.&n; */
macro_line|#if SYM_CONF_NVRAM_SUPPORT
DECL|function|sym_get_nvram
r_static
r_void
id|__devinit
id|sym_get_nvram
c_func
(paren
r_struct
id|sym_device
op_star
id|devp
comma
r_struct
id|sym_nvram
op_star
id|nvp
)paren
(brace
id|devp-&gt;nvram
op_assign
id|nvp
suffix:semicolon
id|devp-&gt;device_id
op_assign
id|devp-&gt;chip.device_id
suffix:semicolon
id|nvp-&gt;type
op_assign
l_int|0
suffix:semicolon
id|sym_read_nvram
c_func
(paren
id|devp
comma
id|nvp
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|function|sym_get_nvram
r_static
r_inline
r_void
id|sym_get_nvram
c_func
(paren
r_struct
id|sym_device
op_star
id|devp
comma
r_struct
id|sym_nvram
op_star
id|nvp
)paren
(brace
)brace
macro_line|#endif&t;/* SYM_CONF_NVRAM_SUPPORT */
DECL|function|sym_check_supported
r_static
r_int
id|__devinit
id|sym_check_supported
c_func
(paren
r_struct
id|sym_device
op_star
id|device
)paren
(brace
r_struct
id|sym_chip
op_star
id|chip
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pdev
op_assign
id|device-&gt;pdev
suffix:semicolon
id|u_char
id|revision
suffix:semicolon
r_int
r_int
id|io_port
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; *  If user excluded this chip, do not initialize it.&n;&t; *  I hate this code so much.  Must kill it.&n;&t; */
r_if
c_cond
(paren
id|io_port
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sym_driver_setup.excludes
(braket
id|i
)braket
op_eq
id|io_port
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Check if the chip is supported.  Then copy the chip description&n;&t; * to our device structure so we can make it match the actual device&n;&t; * and options.&n;&t; */
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
id|PCI_CLASS_REVISION
comma
op_amp
id|revision
)paren
suffix:semicolon
id|chip
op_assign
id|sym_lookup_chip_table
c_func
(paren
id|pdev-&gt;device
comma
id|revision
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chip
)paren
(brace
id|dev_info
c_func
(paren
op_amp
id|pdev-&gt;dev
comma
l_string|&quot;device not supported&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|device-&gt;chip
comma
id|chip
comma
r_sizeof
(paren
id|device-&gt;chip
)paren
)paren
suffix:semicolon
id|device-&gt;chip.revision_id
op_assign
id|revision
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Ignore Symbios chips controlled by various RAID controllers.&n; * These controllers set value 0x52414944 at RAM end - 16.&n; */
DECL|function|sym_check_raid
r_static
r_int
id|__devinit
id|sym_check_raid
c_func
(paren
r_struct
id|sym_device
op_star
id|device
)paren
(brace
r_int
r_int
id|ram_size
comma
id|ram_val
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device-&gt;s.ramaddr
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;chip.features
op_amp
id|FE_RAM8K
)paren
id|ram_size
op_assign
l_int|8192
suffix:semicolon
r_else
id|ram_size
op_assign
l_int|4096
suffix:semicolon
id|ram_val
op_assign
id|readl
c_func
(paren
id|device-&gt;s.ramaddr
op_plus
id|ram_size
op_minus
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ram_val
op_ne
l_int|0x52414944
)paren
r_return
l_int|0
suffix:semicolon
id|dev_info
c_func
(paren
op_amp
id|device-&gt;pdev-&gt;dev
comma
l_string|&quot;not initializing, driven by RAID controller.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|sym_set_workarounds
r_static
r_int
id|__devinit
id|sym_set_workarounds
c_func
(paren
r_struct
id|sym_device
op_star
id|device
)paren
(brace
r_struct
id|sym_chip
op_star
id|chip
op_assign
op_amp
id|device-&gt;chip
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pdev
op_assign
id|device-&gt;pdev
suffix:semicolon
id|u_short
id|status_reg
suffix:semicolon
multiline_comment|/*&n;&t; *  (ITEM 12 of a DEL about the 896 I haven&squot;t yet).&n;&t; *  We must ensure the chip will use WRITE AND INVALIDATE.&n;&t; *  The revision number limit is for now arbitrary.&n;&t; */
r_if
c_cond
(paren
id|pdev-&gt;device
op_eq
id|PCI_DEVICE_ID_NCR_53C896
op_logical_and
id|chip-&gt;revision_id
OL
l_int|0x4
)paren
(brace
id|chip-&gt;features
op_or_assign
(paren
id|FE_WRIE
op_or
id|FE_CLSE
)paren
suffix:semicolon
)brace
multiline_comment|/* If the chip can do Memory Write Invalidate, enable it */
r_if
c_cond
(paren
id|chip-&gt;features
op_amp
id|FE_WRIE
)paren
(brace
r_if
c_cond
(paren
id|pci_set_mwi
c_func
(paren
id|pdev
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Work around for errant bit in 895A. The 66Mhz&n;&t; *  capable bit is set erroneously. Clear this bit.&n;&t; *  (Item 1 DEL 533)&n;&t; *&n;&t; *  Make sure Config space and Features agree.&n;&t; *&n;&t; *  Recall: writes are not normal to status register -&n;&t; *  write a 1 to clear and a 0 to leave unchanged.&n;&t; *  Can only reset bits.&n;&t; */
id|pci_read_config_word
c_func
(paren
id|pdev
comma
id|PCI_STATUS
comma
op_amp
id|status_reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chip-&gt;features
op_amp
id|FE_66MHZ
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|status_reg
op_amp
id|PCI_STATUS_66MHZ
)paren
)paren
id|chip-&gt;features
op_and_assign
op_complement
id|FE_66MHZ
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|status_reg
op_amp
id|PCI_STATUS_66MHZ
)paren
(brace
id|status_reg
op_assign
id|PCI_STATUS_66MHZ
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|pdev
comma
id|PCI_STATUS
comma
id|status_reg
)paren
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|pdev
comma
id|PCI_STATUS
comma
op_amp
id|status_reg
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Read and check the PCI configuration for any detected NCR &n; *  boards and save data for attaching after all boards have &n; *  been detected.&n; */
r_static
r_void
id|__devinit
DECL|function|sym_init_device
id|sym_init_device
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_struct
id|sym_device
op_star
id|device
)paren
(brace
r_int
id|i
suffix:semicolon
id|device-&gt;host_id
op_assign
id|SYM_SETUP_HOST_ID
suffix:semicolon
id|device-&gt;pdev
op_assign
id|pdev
suffix:semicolon
id|i
op_assign
id|pci_get_base_address
c_func
(paren
id|pdev
comma
l_int|1
comma
op_amp
id|device-&gt;mmio_base
)paren
suffix:semicolon
id|pci_get_base_address
c_func
(paren
id|pdev
comma
id|i
comma
op_amp
id|device-&gt;ram_base
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_SCSI_SYM53C8XX_IOMAPPED
r_if
c_cond
(paren
id|device-&gt;mmio_base
)paren
id|device-&gt;s.ioaddr
op_assign
id|pci_iomap
c_func
(paren
id|pdev
comma
l_int|1
comma
id|pci_resource_len
c_func
(paren
id|pdev
comma
l_int|1
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|device-&gt;s.ioaddr
)paren
id|device-&gt;s.ioaddr
op_assign
id|pci_iomap
c_func
(paren
id|pdev
comma
l_int|0
comma
id|pci_resource_len
c_func
(paren
id|pdev
comma
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;ram_base
)paren
id|device-&gt;s.ramaddr
op_assign
id|pci_iomap
c_func
(paren
id|pdev
comma
id|i
comma
id|pci_resource_len
c_func
(paren
id|pdev
comma
id|i
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The NCR PQS and PDS cards are constructed as a DEC bridge&n; * behind which sits a proprietary NCR memory controller and&n; * either four or two 53c875s as separate devices.  We can tell&n; * if an 875 is part of a PQS/PDS or not since if it is, it will&n; * be on the same bus as the memory controller.  In its usual&n; * mode of operation, the 875s are slaved to the memory&n; * controller for all transfers.  To operate with the Linux&n; * driver, the memory controller is disabled and the 875s&n; * freed to function independently.  The only wrinkle is that&n; * the preset SCSI ID (which may be zero) must be read in from&n; * a special configuration space register of the 875.&n; */
DECL|function|sym_config_pqs
r_static
r_void
id|sym_config_pqs
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_struct
id|sym_device
op_star
id|sym_dev
)paren
(brace
r_int
id|slot
suffix:semicolon
id|u8
id|tmp
suffix:semicolon
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|256
suffix:semicolon
id|slot
op_increment
)paren
(brace
r_struct
id|pci_dev
op_star
id|memc
op_assign
id|pci_get_slot
c_func
(paren
id|pdev-&gt;bus
comma
id|slot
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memc
op_logical_or
id|memc-&gt;vendor
op_ne
l_int|0x101a
op_logical_or
id|memc-&gt;device
op_eq
l_int|0x0009
)paren
(brace
id|pci_dev_put
c_func
(paren
id|memc
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* bit 1: allow individual 875 configuration */
id|pci_read_config_byte
c_func
(paren
id|memc
comma
l_int|0x44
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_amp
l_int|0x2
)paren
op_eq
l_int|0
)paren
(brace
id|tmp
op_or_assign
l_int|0x2
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|memc
comma
l_int|0x44
comma
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/* bit 2: drive individual 875 interrupts to the bus */
id|pci_read_config_byte
c_func
(paren
id|memc
comma
l_int|0x45
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_amp
l_int|0x4
)paren
op_eq
l_int|0
)paren
(brace
id|tmp
op_or_assign
l_int|0x4
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|memc
comma
l_int|0x45
comma
id|tmp
)paren
suffix:semicolon
)brace
id|pci_dev_put
c_func
(paren
id|memc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
l_int|0x84
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|sym_dev-&gt;host_id
op_assign
id|tmp
suffix:semicolon
)brace
multiline_comment|/*&n; *  Called before unloading the module.&n; *  Detach the host.&n; *  We have to free resources and halt the NCR chip.&n; */
DECL|function|sym_detach
r_static
r_int
id|sym_detach
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: detaching ...&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|np-&gt;s.timer
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reset NCR chip.&n;&t; * We should use sym_soft_reset(), but we don&squot;t want to do &n;&t; * so, since we may not be safe if interrupts occur.&n;&t; */
id|printk
c_func
(paren
l_string|&quot;%s: resetting chip&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|np
comma
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|np
comma
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
id|sym_free_resources
c_func
(paren
id|np
comma
id|pdev
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Driver host template.&n; */
DECL|variable|sym2_template
r_static
r_struct
id|scsi_host_template
id|sym2_template
op_assign
(brace
dot
id|module
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;sym53c8xx&quot;
comma
dot
id|info
op_assign
id|sym53c8xx_info
comma
dot
id|queuecommand
op_assign
id|sym53c8xx_queue_command
comma
dot
id|slave_alloc
op_assign
id|sym53c8xx_slave_alloc
comma
dot
id|slave_configure
op_assign
id|sym53c8xx_slave_configure
comma
dot
id|slave_destroy
op_assign
id|sym53c8xx_slave_destroy
comma
dot
id|eh_abort_handler
op_assign
id|sym53c8xx_eh_abort_handler
comma
dot
id|eh_device_reset_handler
op_assign
id|sym53c8xx_eh_device_reset_handler
comma
dot
id|eh_bus_reset_handler
op_assign
id|sym53c8xx_eh_bus_reset_handler
comma
dot
id|eh_host_reset_handler
op_assign
id|sym53c8xx_eh_host_reset_handler
comma
dot
id|this_id
op_assign
l_int|7
comma
dot
id|use_clustering
op_assign
id|DISABLE_CLUSTERING
comma
macro_line|#ifdef SYM_LINUX_PROC_INFO_SUPPORT
dot
id|proc_info
op_assign
id|sym53c8xx_proc_info
comma
dot
id|proc_name
op_assign
id|NAME53C8XX
comma
macro_line|#endif
)brace
suffix:semicolon
DECL|variable|attach_count
r_static
r_int
id|attach_count
suffix:semicolon
DECL|function|sym2_probe
r_static
r_int
id|__devinit
id|sym2_probe
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_const
r_struct
id|pci_device_id
op_star
id|ent
)paren
(brace
r_struct
id|sym_device
id|sym_dev
suffix:semicolon
r_struct
id|sym_nvram
id|nvram
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|sym_dev
comma
l_int|0
comma
r_sizeof
(paren
id|sym_dev
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|nvram
comma
l_int|0
comma
r_sizeof
(paren
id|nvram
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|pdev
)paren
)paren
r_goto
id|leave
suffix:semicolon
id|pci_set_master
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_request_regions
c_func
(paren
id|pdev
comma
id|NAME53C8XX
)paren
)paren
r_goto
id|disable
suffix:semicolon
id|sym_init_device
c_func
(paren
id|pdev
comma
op_amp
id|sym_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sym_check_supported
c_func
(paren
op_amp
id|sym_dev
)paren
)paren
r_goto
id|free
suffix:semicolon
r_if
c_cond
(paren
id|sym_check_raid
c_func
(paren
op_amp
id|sym_dev
)paren
)paren
r_goto
id|leave
suffix:semicolon
multiline_comment|/* Don&squot;t disable the device */
r_if
c_cond
(paren
id|sym_set_workarounds
c_func
(paren
op_amp
id|sym_dev
)paren
)paren
r_goto
id|free
suffix:semicolon
id|sym_config_pqs
c_func
(paren
id|pdev
comma
op_amp
id|sym_dev
)paren
suffix:semicolon
id|sym_get_nvram
c_func
(paren
op_amp
id|sym_dev
comma
op_amp
id|nvram
)paren
suffix:semicolon
id|instance
op_assign
id|sym_attach
c_func
(paren
op_amp
id|sym2_template
comma
id|attach_count
comma
op_amp
id|sym_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|instance
)paren
r_goto
id|free
suffix:semicolon
r_if
c_cond
(paren
id|scsi_add_host
c_func
(paren
id|instance
comma
op_amp
id|pdev-&gt;dev
)paren
)paren
r_goto
id|detach
suffix:semicolon
id|scsi_scan_host
c_func
(paren
id|instance
)paren
suffix:semicolon
id|attach_count
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|detach
suffix:colon
id|sym_detach
c_func
(paren
id|pci_get_drvdata
c_func
(paren
id|pdev
)paren
comma
id|pdev
)paren
suffix:semicolon
id|free
suffix:colon
id|pci_release_regions
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|disable
suffix:colon
id|pci_disable_device
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|leave
suffix:colon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|sym2_remove
r_static
r_void
id|__devexit
id|sym2_remove
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
r_struct
id|sym_hcb
op_star
id|np
op_assign
id|pci_get_drvdata
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|np-&gt;s.host
suffix:semicolon
id|scsi_remove_host
c_func
(paren
id|host
)paren
suffix:semicolon
id|scsi_host_put
c_func
(paren
id|host
)paren
suffix:semicolon
id|sym_detach
c_func
(paren
id|np
comma
id|pdev
)paren
suffix:semicolon
id|pci_release_regions
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|pci_disable_device
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|attach_count
op_decrement
suffix:semicolon
)brace
DECL|function|sym2_get_signalling
r_static
r_void
id|sym2_get_signalling
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
r_struct
id|sym_hcb
op_star
id|np
op_assign
id|sym_get_hcb
c_func
(paren
id|shost
)paren
suffix:semicolon
r_enum
id|spi_signal_type
id|type
suffix:semicolon
r_switch
c_cond
(paren
id|np-&gt;scsi_mode
)paren
(brace
r_case
id|SMODE_SE
suffix:colon
id|type
op_assign
id|SPI_SIGNAL_SE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SMODE_LVD
suffix:colon
id|type
op_assign
id|SPI_SIGNAL_LVD
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SMODE_HVD
suffix:colon
id|type
op_assign
id|SPI_SIGNAL_HVD
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|type
op_assign
id|SPI_SIGNAL_UNKNOWN
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spi_signalling
c_func
(paren
id|shost
)paren
op_assign
id|type
suffix:semicolon
)brace
DECL|function|sym2_set_offset
r_static
r_void
id|sym2_set_offset
c_func
(paren
r_struct
id|scsi_target
op_star
id|starget
comma
r_int
id|offset
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shost
op_assign
id|dev_to_shost
c_func
(paren
id|starget-&gt;dev.parent
)paren
suffix:semicolon
r_struct
id|sym_hcb
op_star
id|np
op_assign
id|sym_get_hcb
c_func
(paren
id|shost
)paren
suffix:semicolon
r_struct
id|sym_tcb
op_star
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|starget-&gt;id
)braket
suffix:semicolon
id|tp-&gt;tgoal.offset
op_assign
id|offset
suffix:semicolon
id|tp-&gt;tgoal.check_nego
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|sym2_set_period
r_static
r_void
id|sym2_set_period
c_func
(paren
r_struct
id|scsi_target
op_star
id|starget
comma
r_int
id|period
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shost
op_assign
id|dev_to_shost
c_func
(paren
id|starget-&gt;dev.parent
)paren
suffix:semicolon
r_struct
id|sym_hcb
op_star
id|np
op_assign
id|sym_get_hcb
c_func
(paren
id|shost
)paren
suffix:semicolon
r_struct
id|sym_tcb
op_star
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|starget-&gt;id
)braket
suffix:semicolon
multiline_comment|/* have to have DT for these transfers */
r_if
c_cond
(paren
id|period
op_le
id|np-&gt;minsync
)paren
id|tp-&gt;tgoal.dt
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;tgoal.period
op_assign
id|period
suffix:semicolon
id|tp-&gt;tgoal.check_nego
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|sym2_set_width
r_static
r_void
id|sym2_set_width
c_func
(paren
r_struct
id|scsi_target
op_star
id|starget
comma
r_int
id|width
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shost
op_assign
id|dev_to_shost
c_func
(paren
id|starget-&gt;dev.parent
)paren
suffix:semicolon
r_struct
id|sym_hcb
op_star
id|np
op_assign
id|sym_get_hcb
c_func
(paren
id|shost
)paren
suffix:semicolon
r_struct
id|sym_tcb
op_star
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|starget-&gt;id
)braket
suffix:semicolon
multiline_comment|/* It is illegal to have DT set on narrow transfers.  If DT is&n;&t; * clear, we must also clear IU and QAS.  */
r_if
c_cond
(paren
id|width
op_eq
l_int|0
)paren
id|tp-&gt;tgoal.iu
op_assign
id|tp-&gt;tgoal.dt
op_assign
id|tp-&gt;tgoal.qas
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;tgoal.width
op_assign
id|width
suffix:semicolon
id|tp-&gt;tgoal.check_nego
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|sym2_set_dt
r_static
r_void
id|sym2_set_dt
c_func
(paren
r_struct
id|scsi_target
op_star
id|starget
comma
r_int
id|dt
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shost
op_assign
id|dev_to_shost
c_func
(paren
id|starget-&gt;dev.parent
)paren
suffix:semicolon
r_struct
id|sym_hcb
op_star
id|np
op_assign
id|sym_get_hcb
c_func
(paren
id|shost
)paren
suffix:semicolon
r_struct
id|sym_tcb
op_star
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|starget-&gt;id
)braket
suffix:semicolon
multiline_comment|/* We must clear QAS and IU if DT is clear */
r_if
c_cond
(paren
id|dt
)paren
id|tp-&gt;tgoal.dt
op_assign
l_int|1
suffix:semicolon
r_else
id|tp-&gt;tgoal.iu
op_assign
id|tp-&gt;tgoal.dt
op_assign
id|tp-&gt;tgoal.qas
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;tgoal.check_nego
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|sym2_set_iu
r_static
r_void
id|sym2_set_iu
c_func
(paren
r_struct
id|scsi_target
op_star
id|starget
comma
r_int
id|iu
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shost
op_assign
id|dev_to_shost
c_func
(paren
id|starget-&gt;dev.parent
)paren
suffix:semicolon
r_struct
id|sym_hcb
op_star
id|np
op_assign
id|sym_get_hcb
c_func
(paren
id|shost
)paren
suffix:semicolon
r_struct
id|sym_tcb
op_star
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|starget-&gt;id
)braket
suffix:semicolon
r_if
c_cond
(paren
id|iu
)paren
id|tp-&gt;tgoal.iu
op_assign
id|tp-&gt;tgoal.dt
op_assign
l_int|1
suffix:semicolon
r_else
id|tp-&gt;tgoal.iu
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;tgoal.check_nego
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|sym2_set_qas
r_static
r_void
id|sym2_set_qas
c_func
(paren
r_struct
id|scsi_target
op_star
id|starget
comma
r_int
id|qas
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shost
op_assign
id|dev_to_shost
c_func
(paren
id|starget-&gt;dev.parent
)paren
suffix:semicolon
r_struct
id|sym_hcb
op_star
id|np
op_assign
id|sym_get_hcb
c_func
(paren
id|shost
)paren
suffix:semicolon
r_struct
id|sym_tcb
op_star
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|starget-&gt;id
)braket
suffix:semicolon
r_if
c_cond
(paren
id|qas
)paren
id|tp-&gt;tgoal.dt
op_assign
id|tp-&gt;tgoal.qas
op_assign
l_int|1
suffix:semicolon
r_else
id|tp-&gt;tgoal.qas
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;tgoal.check_nego
op_assign
l_int|1
suffix:semicolon
)brace
DECL|variable|sym2_transport_functions
r_static
r_struct
id|spi_function_template
id|sym2_transport_functions
op_assign
(brace
dot
id|set_offset
op_assign
id|sym2_set_offset
comma
dot
id|show_offset
op_assign
l_int|1
comma
dot
id|set_period
op_assign
id|sym2_set_period
comma
dot
id|show_period
op_assign
l_int|1
comma
dot
id|set_width
op_assign
id|sym2_set_width
comma
dot
id|show_width
op_assign
l_int|1
comma
dot
id|set_dt
op_assign
id|sym2_set_dt
comma
dot
id|show_dt
op_assign
l_int|1
comma
dot
id|set_iu
op_assign
id|sym2_set_iu
comma
dot
id|show_iu
op_assign
l_int|1
comma
dot
id|set_qas
op_assign
id|sym2_set_qas
comma
dot
id|show_qas
op_assign
l_int|1
comma
dot
id|get_signalling
op_assign
id|sym2_get_signalling
comma
)brace
suffix:semicolon
DECL|variable|__devinitdata
r_static
r_struct
id|pci_device_id
id|sym2_id_table
(braket
)braket
id|__devinitdata
op_assign
(brace
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_NCR_53C810
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_NCR_53C820
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
multiline_comment|/* new */
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_NCR_53C825
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_NCR_53C815
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_LSI_53C810AP
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
multiline_comment|/* new */
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_NCR_53C860
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_LSI_53C1510
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_NCR_53C896
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_NCR_53C895
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_NCR_53C885
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_NCR_53C875
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_NCR_53C1510
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
multiline_comment|/* new */
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_LSI_53C895A
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_LSI_53C875A
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_LSI_53C1010_33
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_LSI_53C1010_66
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_NCR_53C875J
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
l_int|0
comma
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|pci
comma
id|sym2_id_table
)paren
suffix:semicolon
DECL|variable|sym2_driver
r_static
r_struct
id|pci_driver
id|sym2_driver
op_assign
(brace
dot
id|name
op_assign
id|NAME53C8XX
comma
dot
id|id_table
op_assign
id|sym2_id_table
comma
dot
id|probe
op_assign
id|sym2_probe
comma
dot
id|remove
op_assign
id|__devexit_p
c_func
(paren
id|sym2_remove
)paren
comma
)brace
suffix:semicolon
DECL|function|sym2_init
r_static
r_int
id|__init
id|sym2_init
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
id|sym2_setup_params
c_func
(paren
)paren
suffix:semicolon
id|sym2_transport_template
op_assign
id|spi_attach_transport
c_func
(paren
op_amp
id|sym2_transport_functions
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sym2_transport_template
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|error
op_assign
id|pci_register_driver
c_func
(paren
op_amp
id|sym2_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
id|spi_release_transport
c_func
(paren
id|sym2_transport_template
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sym2_exit
r_static
r_void
id|__exit
id|sym2_exit
c_func
(paren
r_void
)paren
(brace
id|pci_unregister_driver
c_func
(paren
op_amp
id|sym2_driver
)paren
suffix:semicolon
id|spi_release_transport
c_func
(paren
id|sym2_transport_template
)paren
suffix:semicolon
)brace
DECL|variable|sym2_init
id|module_init
c_func
(paren
id|sym2_init
)paren
suffix:semicolon
DECL|variable|sym2_exit
id|module_exit
c_func
(paren
id|sym2_exit
)paren
suffix:semicolon
eof
