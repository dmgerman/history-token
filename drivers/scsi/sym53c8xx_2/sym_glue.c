multiline_comment|/*&n; * Device driver for the SYMBIOS/LSILOGIC 53C8XX and 53C1010 family &n; * of PCI-SCSI IO processors.&n; *&n; * Copyright (C) 1999-2001  Gerard Roudier &lt;groudier@free.fr&gt;&n; *&n; * This driver is derived from the Linux sym53c8xx driver.&n; * Copyright (C) 1998-2000  Gerard Roudier&n; *&n; * The sym53c8xx driver is derived from the ncr53c8xx driver that had been &n; * a port of the FreeBSD ncr driver to Linux-1.2.13.&n; *&n; * The original ncr driver has been written for 386bsd and FreeBSD by&n; *         Wolfgang Stanglmeier        &lt;wolf@cologne.de&gt;&n; *         Stefan Esser                &lt;se@mi.Uni-Koeln.de&gt;&n; * Copyright (C) 1994  Wolfgang Stanglmeier&n; *&n; * Other major contributions:&n; *&n; * NVRAM detection and reading.&n; * Copyright (C) 1997 Richard Waltham &lt;dormouse@farsrobt.demon.co.uk&gt;&n; *&n; *-----------------------------------------------------------------------------&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions and the following disclaimer.&n; * 2. The name of the author may not be used to endorse or promote products&n; *    derived from this software without specific prior written permission.&n; *&n; * Where this Software is combined with software released under the terms of &n; * the GNU Public License (&quot;GPL&quot;) and the terms of the GPL would require the &n; * combined work to also be released under the terms of the GPL, the terms&n; * and conditions of this License will apply in addition to those of the&n; * GPL with the exception of any terms or conditions of this License that&n; * conflict with, or are expressly prohibited by, the GPL.&n; *&n; * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS&squot;&squot; AND&n; * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE&n; * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE&n; * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR&n; * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS&n; * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT&n; * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY&n; * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF&n; * SUCH DAMAGE.&n; */
DECL|macro|SYM_GLUE_C
mdefine_line|#define SYM_GLUE_C
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;scsi/scsi.h&gt;
macro_line|#include &quot;sym_glue.h&quot;
DECL|macro|NAME53C
mdefine_line|#define NAME53C&t;&t;&quot;sym53c&quot;
DECL|macro|NAME53C8XX
mdefine_line|#define NAME53C8XX&t;&quot;sym53c8xx&quot;
r_static
r_int
id|__devinit
DECL|function|pci_get_base_address
id|pci_get_base_address
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_int
id|index
comma
id|u_long
op_star
id|base
)paren
(brace
id|u32
id|tmp
suffix:semicolon
DECL|macro|PCI_BAR_OFFSET
mdefine_line|#define PCI_BAR_OFFSET(index) (PCI_BASE_ADDRESS_0 + (index&lt;&lt;2))
id|pci_read_config_dword
c_func
(paren
id|pdev
comma
id|PCI_BAR_OFFSET
c_func
(paren
id|index
)paren
comma
op_amp
id|tmp
)paren
suffix:semicolon
op_star
id|base
op_assign
id|tmp
suffix:semicolon
op_increment
id|index
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_amp
l_int|0x7
)paren
op_eq
id|PCI_BASE_ADDRESS_MEM_TYPE_64
)paren
(brace
macro_line|#if BITS_PER_LONG &gt; 32
id|pci_read_config_dword
c_func
(paren
id|pdev
comma
id|PCI_BAR_OFFSET
c_func
(paren
id|index
)paren
comma
op_amp
id|tmp
)paren
suffix:semicolon
op_star
id|base
op_or_assign
(paren
(paren
(paren
id|u_long
)paren
id|tmp
)paren
op_lshift
l_int|32
)paren
suffix:semicolon
macro_line|#endif
op_increment
id|index
suffix:semicolon
)brace
r_return
id|index
suffix:semicolon
DECL|macro|PCI_BAR_OFFSET
macro_line|#undef PCI_BAR_OFFSET
)brace
multiline_comment|/* This lock protects only the memory allocation/free.  */
DECL|variable|sym53c8xx_lock
id|spinlock_t
id|sym53c8xx_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; *  Wrappers to the generic memory allocator.&n; */
DECL|function|sym_calloc
r_void
op_star
id|sym_calloc
c_func
(paren
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_void
op_star
id|m
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sym53c8xx_lock
comma
id|flags
)paren
suffix:semicolon
id|m
op_assign
id|sym_calloc_unlocked
c_func
(paren
id|size
comma
id|name
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sym53c8xx_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
DECL|function|sym_mfree
r_void
id|sym_mfree
c_func
(paren
r_void
op_star
id|m
comma
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sym53c8xx_lock
comma
id|flags
)paren
suffix:semicolon
id|sym_mfree_unlocked
c_func
(paren
id|m
comma
id|size
comma
id|name
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sym53c8xx_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|__sym_calloc_dma
r_void
op_star
id|__sym_calloc_dma
c_func
(paren
id|m_pool_ident_t
id|dev_dmat
comma
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_void
op_star
id|m
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sym53c8xx_lock
comma
id|flags
)paren
suffix:semicolon
id|m
op_assign
id|__sym_calloc_dma_unlocked
c_func
(paren
id|dev_dmat
comma
id|size
comma
id|name
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sym53c8xx_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
DECL|function|__sym_mfree_dma
r_void
id|__sym_mfree_dma
c_func
(paren
id|m_pool_ident_t
id|dev_dmat
comma
r_void
op_star
id|m
comma
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sym53c8xx_lock
comma
id|flags
)paren
suffix:semicolon
id|__sym_mfree_dma_unlocked
c_func
(paren
id|dev_dmat
comma
id|m
comma
id|size
comma
id|name
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sym53c8xx_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|__vtobus
id|m_addr_t
id|__vtobus
c_func
(paren
id|m_pool_ident_t
id|dev_dmat
comma
r_void
op_star
id|m
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|m_addr_t
id|b
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sym53c8xx_lock
comma
id|flags
)paren
suffix:semicolon
id|b
op_assign
id|__vtobus_unlocked
c_func
(paren
id|dev_dmat
comma
id|m
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sym53c8xx_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|b
suffix:semicolon
)brace
multiline_comment|/*&n; *  Driver host data structure.&n; */
DECL|struct|host_data
r_struct
id|host_data
(brace
DECL|member|ncb
r_struct
id|sym_hcb
op_star
id|ncb
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; *  Used by the eh thread to wait for command completion.&n; *  It is allocated on the eh thread stack.&n; */
DECL|struct|sym_eh_wait
r_struct
id|sym_eh_wait
(brace
DECL|member|sem
r_struct
id|semaphore
id|sem
suffix:semicolon
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
DECL|member|old_done
r_void
(paren
op_star
id|old_done
)paren
(paren
r_struct
id|scsi_cmnd
op_star
)paren
suffix:semicolon
DECL|member|to_do
r_int
id|to_do
suffix:semicolon
DECL|member|timed_out
r_int
id|timed_out
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; *  Driver private area in the SCSI command structure.&n; */
DECL|struct|sym_ucmd
r_struct
id|sym_ucmd
(brace
multiline_comment|/* Override the SCSI pointer structure */
DECL|member|link_cmdq
id|SYM_QUEHEAD
id|link_cmdq
suffix:semicolon
multiline_comment|/* Must stay at offset ZERO */
DECL|member|data_mapping
id|dma_addr_t
id|data_mapping
suffix:semicolon
DECL|member|data_mapped
id|u_char
id|data_mapped
suffix:semicolon
DECL|member|eh_wait
r_struct
id|sym_eh_wait
op_star
id|eh_wait
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|SYM_UCMD_PTR
mdefine_line|#define SYM_UCMD_PTR(cmd)  ((struct sym_ucmd *)(&amp;(cmd)-&gt;SCp))
DECL|macro|SYM_SCMD_PTR
mdefine_line|#define SYM_SCMD_PTR(ucmd) sym_que_entry(ucmd, struct scsi_cmnd, SCp)
DECL|macro|SYM_SOFTC_PTR
mdefine_line|#define SYM_SOFTC_PTR(cmd) (((struct host_data *)cmd-&gt;device-&gt;host-&gt;hostdata)-&gt;ncb)
DECL|function|__unmap_scsi_data
r_static
r_void
id|__unmap_scsi_data
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_int
id|dma_dir
op_assign
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapped
)paren
(brace
r_case
l_int|2
suffix:colon
id|pci_unmap_sg
c_func
(paren
id|pdev
comma
id|cmd-&gt;buffer
comma
id|cmd-&gt;use_sg
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|pci_unmap_single
c_func
(paren
id|pdev
comma
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapping
comma
id|cmd-&gt;request_bufflen
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapped
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|__map_scsi_single_data
r_static
id|dma_addr_t
id|__map_scsi_single_data
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
id|dma_addr_t
id|mapping
suffix:semicolon
r_int
id|dma_dir
op_assign
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
id|mapping
op_assign
id|pci_map_single
c_func
(paren
id|pdev
comma
id|cmd-&gt;request_buffer
comma
id|cmd-&gt;request_bufflen
comma
id|dma_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mapping
)paren
(brace
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapped
op_assign
l_int|1
suffix:semicolon
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapping
op_assign
id|mapping
suffix:semicolon
)brace
r_return
id|mapping
suffix:semicolon
)brace
DECL|function|__map_scsi_sg_data
r_static
r_int
id|__map_scsi_sg_data
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_int
id|use_sg
suffix:semicolon
r_int
id|dma_dir
op_assign
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
id|use_sg
op_assign
id|pci_map_sg
c_func
(paren
id|pdev
comma
id|cmd-&gt;buffer
comma
id|cmd-&gt;use_sg
comma
id|dma_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|use_sg
OG
l_int|0
)paren
(brace
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapped
op_assign
l_int|2
suffix:semicolon
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapping
op_assign
id|use_sg
suffix:semicolon
)brace
r_return
id|use_sg
suffix:semicolon
)brace
DECL|function|__sync_scsi_data_for_cpu
r_static
r_void
id|__sync_scsi_data_for_cpu
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_int
id|dma_dir
op_assign
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapped
)paren
(brace
r_case
l_int|2
suffix:colon
id|pci_dma_sync_sg_for_cpu
c_func
(paren
id|pdev
comma
id|cmd-&gt;buffer
comma
id|cmd-&gt;use_sg
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|pci_dma_sync_single_for_cpu
c_func
(paren
id|pdev
comma
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapping
comma
id|cmd-&gt;request_bufflen
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|__sync_scsi_data_for_device
r_static
r_void
id|__sync_scsi_data_for_device
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_int
id|dma_dir
op_assign
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapped
)paren
(brace
r_case
l_int|2
suffix:colon
id|pci_dma_sync_sg_for_device
c_func
(paren
id|pdev
comma
id|cmd-&gt;buffer
comma
id|cmd-&gt;use_sg
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|pci_dma_sync_single_for_device
c_func
(paren
id|pdev
comma
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|data_mapping
comma
id|cmd-&gt;request_bufflen
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|macro|unmap_scsi_data
mdefine_line|#define unmap_scsi_data(np, cmd)&t;&bslash;&n;&t;&t;__unmap_scsi_data(np-&gt;s.device, cmd)
DECL|macro|map_scsi_single_data
mdefine_line|#define map_scsi_single_data(np, cmd)&t;&bslash;&n;&t;&t;__map_scsi_single_data(np-&gt;s.device, cmd)
DECL|macro|map_scsi_sg_data
mdefine_line|#define map_scsi_sg_data(np, cmd)&t;&bslash;&n;&t;&t;__map_scsi_sg_data(np-&gt;s.device, cmd)
DECL|macro|sync_scsi_data_for_cpu
mdefine_line|#define sync_scsi_data_for_cpu(np, cmd)&t;&t;&bslash;&n;&t;&t;__sync_scsi_data_for_cpu(np-&gt;s.device, cmd)
DECL|macro|sync_scsi_data_for_device
mdefine_line|#define sync_scsi_data_for_device(np, cmd)&t;&t;&bslash;&n;&t;&t;__sync_scsi_data_for_device(np-&gt;s.device, cmd)
multiline_comment|/*&n; *  Complete a pending CAM CCB.&n; */
DECL|function|sym_xpt_done
r_void
id|sym_xpt_done
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_struct
id|scsi_cmnd
op_star
id|ccb
)paren
(brace
id|sym_remque
c_func
(paren
op_amp
id|SYM_UCMD_PTR
c_func
(paren
id|ccb
)paren
op_member_access_from_pointer
id|link_cmdq
)paren
suffix:semicolon
id|unmap_scsi_data
c_func
(paren
id|np
comma
id|ccb
)paren
suffix:semicolon
id|ccb
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|ccb
)paren
suffix:semicolon
)brace
DECL|function|sym_xpt_done2
r_void
id|sym_xpt_done2
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_struct
id|scsi_cmnd
op_star
id|ccb
comma
r_int
id|cam_status
)paren
(brace
id|sym_set_cam_status
c_func
(paren
id|ccb
comma
id|cam_status
)paren
suffix:semicolon
id|sym_xpt_done
c_func
(paren
id|np
comma
id|ccb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Print something that identifies the IO.&n; */
DECL|function|sym_print_addr
r_void
id|sym_print_addr
c_func
(paren
r_struct
id|sym_ccb
op_star
id|cp
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|cmd
op_assign
id|cp-&gt;cam_ccb
suffix:semicolon
r_if
c_cond
(paren
id|cmd
)paren
id|printf
c_func
(paren
l_string|&quot;%s:%d:%d:&quot;
comma
id|sym_name
c_func
(paren
id|SYM_SOFTC_PTR
c_func
(paren
id|cmd
)paren
)paren
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;lun
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Tell the SCSI layer about a BUS RESET.&n; */
DECL|function|sym_xpt_async_bus_reset
r_void
id|sym_xpt_async_bus_reset
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
)paren
(brace
id|printf_notice
c_func
(paren
l_string|&quot;%s: SCSI BUS has been reset.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;s.settle_time
op_assign
id|jiffies
op_plus
id|sym_driver_setup.settle_delay
op_star
id|HZ
suffix:semicolon
id|np-&gt;s.settle_time_valid
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sym_verbose
op_ge
l_int|2
)paren
id|printf_info
c_func
(paren
l_string|&quot;%s: command processing suspended for %d seconds&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|sym_driver_setup.settle_delay
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Tell the SCSI layer about a BUS DEVICE RESET message sent.&n; */
DECL|function|sym_xpt_async_sent_bdr
r_void
id|sym_xpt_async_sent_bdr
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_int
id|target
)paren
(brace
id|printf_notice
c_func
(paren
l_string|&quot;%s: TARGET %d has been reset.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|target
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Tell the SCSI layer about the new transfer parameters.&n; */
DECL|function|sym_xpt_async_nego_wide
r_void
id|sym_xpt_async_nego_wide
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_int
id|target
)paren
(brace
r_if
c_cond
(paren
id|sym_verbose
OL
l_int|3
)paren
r_return
suffix:semicolon
id|sym_announce_transfer_rate
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Choose the more appropriate CAM status if &n; *  the IO encountered an extended error.&n; */
DECL|function|sym_xerr_cam_status
r_static
r_int
id|sym_xerr_cam_status
c_func
(paren
r_int
id|cam_status
comma
r_int
id|x_status
)paren
(brace
r_if
c_cond
(paren
id|x_status
)paren
(brace
r_if
c_cond
(paren
id|x_status
op_amp
id|XE_PARITY_ERR
)paren
id|cam_status
op_assign
id|DID_PARITY
suffix:semicolon
r_else
r_if
c_cond
(paren
id|x_status
op_amp
(paren
id|XE_EXTRA_DATA
op_or
id|XE_SODL_UNRUN
op_or
id|XE_SWIDE_OVRUN
)paren
)paren
id|cam_status
op_assign
id|DID_ERROR
suffix:semicolon
r_else
r_if
c_cond
(paren
id|x_status
op_amp
id|XE_BAD_PHASE
)paren
id|cam_status
op_assign
id|DID_ERROR
suffix:semicolon
r_else
id|cam_status
op_assign
id|DID_ERROR
suffix:semicolon
)brace
r_return
id|cam_status
suffix:semicolon
)brace
multiline_comment|/*&n; *  Build CAM result for a failed or auto-sensed IO.&n; */
DECL|function|sym_set_cam_result_error
r_void
id|sym_set_cam_result_error
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_struct
id|sym_ccb
op_star
id|cp
comma
r_int
id|resid
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|csio
op_assign
id|cp-&gt;cam_ccb
suffix:semicolon
id|u_int
id|cam_status
comma
id|scsi_status
comma
id|drv_status
suffix:semicolon
id|drv_status
op_assign
l_int|0
suffix:semicolon
id|cam_status
op_assign
id|DID_OK
suffix:semicolon
id|scsi_status
op_assign
id|cp-&gt;ssss_status
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;host_flags
op_amp
id|HF_SENSE
)paren
(brace
id|scsi_status
op_assign
id|cp-&gt;sv_scsi_status
suffix:semicolon
id|resid
op_assign
id|cp-&gt;sv_resid
suffix:semicolon
r_if
c_cond
(paren
id|sym_verbose
op_logical_and
id|cp-&gt;sv_xerr_status
)paren
id|sym_print_xerr
c_func
(paren
id|cp
comma
id|cp-&gt;sv_xerr_status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
op_logical_and
id|cp-&gt;ssss_status
op_eq
id|S_GOOD
op_logical_and
id|cp-&gt;xerr_status
op_eq
l_int|0
)paren
(brace
id|cam_status
op_assign
id|sym_xerr_cam_status
c_func
(paren
id|DID_OK
comma
id|cp-&gt;sv_xerr_status
)paren
suffix:semicolon
id|drv_status
op_assign
id|DRIVER_SENSE
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  Bounce back the sense data to user.&n;&t;&t;&t; */
id|bzero
c_func
(paren
op_amp
id|csio-&gt;sense_buffer
comma
r_sizeof
(paren
id|csio-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|csio-&gt;sense_buffer
comma
id|cp-&gt;sns_bbuf
comma
id|min
c_func
(paren
r_sizeof
(paren
id|csio-&gt;sense_buffer
)paren
comma
(paren
r_int
)paren
id|SYM_SNS_BBUF_LEN
)paren
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n;&t;&t;&t; *  If the device reports a UNIT ATTENTION condition &n;&t;&t;&t; *  due to a RESET condition, we should consider all &n;&t;&t;&t; *  disconnect CCBs for this unit as aborted.&n;&t;&t;&t; */
r_if
c_cond
(paren
l_int|1
)paren
(brace
id|u_char
op_star
id|p
suffix:semicolon
id|p
op_assign
(paren
id|u_char
op_star
)paren
id|csio-&gt;sense_data
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
op_eq
l_int|0x70
op_logical_and
id|p
(braket
l_int|2
)braket
op_eq
l_int|0x6
op_logical_and
id|p
(braket
l_int|12
)braket
op_eq
l_int|0x29
)paren
id|sym_clear_tasks
c_func
(paren
id|np
comma
id|DID_ABORT
comma
id|cp-&gt;target
comma
id|cp-&gt;lun
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_else
(brace
id|cam_status
op_assign
id|DID_ERROR
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
multiline_comment|/* Bad SCSI status */
id|cam_status
op_assign
id|DID_OK
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_SEL_TIMEOUT
)paren
multiline_comment|/* Selection timeout */
id|cam_status
op_assign
id|DID_NO_CONNECT
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_UNEXPECTED
)paren
multiline_comment|/* Unexpected BUS FREE*/
id|cam_status
op_assign
id|DID_ERROR
suffix:semicolon
r_else
(brace
multiline_comment|/* Extended error */
r_if
c_cond
(paren
id|sym_verbose
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;COMMAND FAILED (%x %x %x).&bslash;n&quot;
comma
id|cp-&gt;host_status
comma
id|cp-&gt;ssss_status
comma
id|cp-&gt;xerr_status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Set the most appropriate value for CAM status.&n;&t;&t; */
id|cam_status
op_assign
id|sym_xerr_cam_status
c_func
(paren
id|DID_ERROR
comma
id|cp-&gt;xerr_status
)paren
suffix:semicolon
)brace
id|csio-&gt;resid
op_assign
id|resid
suffix:semicolon
id|csio-&gt;result
op_assign
(paren
id|drv_status
op_lshift
l_int|24
)paren
op_plus
(paren
id|cam_status
op_lshift
l_int|16
)paren
op_plus
id|scsi_status
suffix:semicolon
)brace
multiline_comment|/*&n; *  Called on successfull INQUIRY response.&n; */
DECL|function|sym_sniff_inquiry
r_void
id|sym_sniff_inquiry
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_int
id|resid
)paren
(brace
r_int
id|retv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
op_logical_or
id|cmd-&gt;use_sg
)paren
r_return
suffix:semicolon
id|sync_scsi_data_for_cpu
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
id|retv
op_assign
id|__sym_sniff_inquiry
c_func
(paren
id|np
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;lun
comma
(paren
id|u_char
op_star
)paren
id|cmd-&gt;request_buffer
comma
id|cmd-&gt;request_bufflen
op_minus
id|resid
)paren
suffix:semicolon
id|sync_scsi_data_for_device
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retv
OL
l_int|0
)paren
r_return
suffix:semicolon
r_else
r_if
c_cond
(paren
id|retv
)paren
id|sym_update_trans_settings
c_func
(paren
id|np
comma
op_amp
id|np-&gt;target
(braket
id|cmd-&gt;device-&gt;id
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Build the scatter/gather array for an I/O.&n; */
DECL|function|sym_scatter_no_sglist
r_static
r_int
id|sym_scatter_no_sglist
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_struct
id|sym_ccb
op_star
id|cp
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|sym_tblmove
op_star
id|data
op_assign
op_amp
id|cp-&gt;phys.data
(braket
id|SYM_CONF_MAX_SG
op_minus
l_int|1
)braket
suffix:semicolon
r_int
id|segment
suffix:semicolon
id|cp-&gt;data_len
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
)paren
(brace
id|dma_addr_t
id|baddr
op_assign
id|map_scsi_single_data
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|baddr
)paren
(brace
id|sym_build_sge
c_func
(paren
id|np
comma
id|data
comma
id|baddr
comma
id|cmd-&gt;request_bufflen
)paren
suffix:semicolon
id|segment
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|segment
op_assign
op_minus
l_int|2
suffix:semicolon
)brace
)brace
r_else
(brace
id|segment
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|segment
suffix:semicolon
)brace
DECL|function|sym_scatter
r_static
r_int
id|sym_scatter
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_struct
id|sym_ccb
op_star
id|cp
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_int
id|segment
suffix:semicolon
r_int
id|use_sg
op_assign
(paren
r_int
)paren
id|cmd-&gt;use_sg
suffix:semicolon
id|cp-&gt;data_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|use_sg
)paren
id|segment
op_assign
id|sym_scatter_no_sglist
c_func
(paren
id|np
comma
id|cp
comma
id|cmd
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|use_sg
op_assign
id|map_scsi_sg_data
c_func
(paren
id|np
comma
id|cmd
)paren
)paren
OG
l_int|0
)paren
(brace
r_struct
id|scatterlist
op_star
id|scatter
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
suffix:semicolon
r_struct
id|sym_tblmove
op_star
id|data
suffix:semicolon
r_if
c_cond
(paren
id|use_sg
OG
id|SYM_CONF_MAX_SG
)paren
(brace
id|unmap_scsi_data
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|data
op_assign
op_amp
id|cp-&gt;phys.data
(braket
id|SYM_CONF_MAX_SG
op_minus
id|use_sg
)braket
suffix:semicolon
r_for
c_loop
(paren
id|segment
op_assign
l_int|0
suffix:semicolon
id|segment
OL
id|use_sg
suffix:semicolon
id|segment
op_increment
)paren
(brace
id|dma_addr_t
id|baddr
op_assign
id|sg_dma_address
c_func
(paren
op_amp
id|scatter
(braket
id|segment
)braket
)paren
suffix:semicolon
r_int
r_int
id|len
op_assign
id|sg_dma_len
c_func
(paren
op_amp
id|scatter
(braket
id|segment
)braket
)paren
suffix:semicolon
id|sym_build_sge
c_func
(paren
id|np
comma
op_amp
id|data
(braket
id|segment
)braket
comma
id|baddr
comma
id|len
)paren
suffix:semicolon
id|cp-&gt;data_len
op_add_assign
id|len
suffix:semicolon
)brace
)brace
r_else
(brace
id|segment
op_assign
op_minus
l_int|2
suffix:semicolon
)brace
r_return
id|segment
suffix:semicolon
)brace
multiline_comment|/*&n; *  Queue a SCSI command.&n; */
DECL|function|sym_queue_command
r_static
r_int
id|sym_queue_command
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_struct
id|scsi_cmnd
op_star
id|ccb
)paren
(brace
multiline_comment|/*&t;struct scsi_device        *device    = ccb-&gt;device; */
r_struct
id|sym_tcb
op_star
id|tp
suffix:semicolon
r_struct
id|sym_lcb
op_star
id|lp
suffix:semicolon
r_struct
id|sym_ccb
op_star
id|cp
suffix:semicolon
r_int
id|order
suffix:semicolon
multiline_comment|/*&n;&t; *  Minimal checkings, so that we will not &n;&t; *  go outside our tables.&n;&t; */
r_if
c_cond
(paren
id|ccb-&gt;device-&gt;id
op_eq
id|np-&gt;myaddr
op_logical_or
id|ccb-&gt;device-&gt;id
op_ge
id|SYM_CONF_MAX_TARGET
op_logical_or
id|ccb-&gt;device-&gt;lun
op_ge
id|SYM_CONF_MAX_LUN
)paren
(brace
id|sym_xpt_done2
c_func
(paren
id|np
comma
id|ccb
comma
id|CAM_DEV_NOT_THERE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Retreive the target descriptor.&n;&t; */
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|ccb-&gt;device-&gt;id
)braket
suffix:semicolon
multiline_comment|/*&n;&t; *  Complete the 1st INQUIRY command with error &n;&t; *  condition if the device is flagged NOSCAN &n;&t; *  at BOOT in the NVRAM. This may speed up &n;&t; *  the boot and maintain coherency with BIOS &n;&t; *  device numbering. Clearing the flag allows &n;&t; *  user to rescan skipped devices later.&n;&t; *  We also return error for devices not flagged &n;&t; *  for SCAN LUNS in the NVRAM since some mono-lun &n;&t; *  devices behave badly when asked for some non &n;&t; *  zero LUN. Btw, this is an absolute hack.:-)&n;&t; */
r_if
c_cond
(paren
id|ccb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
l_int|0x12
op_logical_or
id|ccb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
l_int|0x0
)paren
(brace
r_if
c_cond
(paren
(paren
id|tp-&gt;usrflags
op_amp
id|SYM_SCAN_BOOT_DISABLED
)paren
op_logical_or
(paren
(paren
id|tp-&gt;usrflags
op_amp
id|SYM_SCAN_LUNS_DISABLED
)paren
op_logical_and
id|ccb-&gt;device-&gt;lun
op_ne
l_int|0
)paren
)paren
(brace
id|tp-&gt;usrflags
op_and_assign
op_complement
id|SYM_SCAN_BOOT_DISABLED
suffix:semicolon
id|sym_xpt_done2
c_func
(paren
id|np
comma
id|ccb
comma
id|CAM_DEV_NOT_THERE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *  Select tagged/untagged.&n;&t; */
id|lp
op_assign
id|sym_lp
c_func
(paren
id|np
comma
id|tp
comma
id|ccb-&gt;device-&gt;lun
)paren
suffix:semicolon
id|order
op_assign
(paren
id|lp
op_logical_and
id|lp-&gt;s.reqtags
)paren
ques
c_cond
id|M_SIMPLE_TAG
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  Queue the SCSI IO.&n;&t; */
id|cp
op_assign
id|sym_get_ccb
c_func
(paren
id|np
comma
id|ccb-&gt;device-&gt;id
comma
id|ccb-&gt;device-&gt;lun
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Means resource shortage */
id|sym_queue_scsiio
c_func
(paren
id|np
comma
id|ccb
comma
id|cp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Setup buffers and pointers that address the CDB.&n; */
DECL|function|sym_setup_cdb
r_static
r_int
id|__inline
id|sym_setup_cdb
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_struct
id|scsi_cmnd
op_star
id|ccb
comma
r_struct
id|sym_ccb
op_star
id|cp
)paren
(brace
id|u32
id|cmd_ba
suffix:semicolon
r_int
id|cmd_len
suffix:semicolon
multiline_comment|/*&n;&t; *  CDB is 16 bytes max.&n;&t; */
r_if
c_cond
(paren
id|ccb-&gt;cmd_len
OG
r_sizeof
(paren
id|cp-&gt;cdb_buf
)paren
)paren
(brace
id|sym_set_cam_status
c_func
(paren
id|cp-&gt;cam_ccb
comma
id|CAM_REQ_INVALID
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|cp-&gt;cdb_buf
comma
id|ccb-&gt;cmnd
comma
id|ccb-&gt;cmd_len
)paren
suffix:semicolon
id|cmd_ba
op_assign
id|CCB_BA
(paren
id|cp
comma
id|cdb_buf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|cmd_len
op_assign
id|ccb-&gt;cmd_len
suffix:semicolon
id|cp-&gt;phys.cmd.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|cmd_ba
)paren
suffix:semicolon
id|cp-&gt;phys.cmd.size
op_assign
id|cpu_to_scr
c_func
(paren
id|cmd_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Setup pointers that address the data and start the I/O.&n; */
DECL|function|sym_setup_data_and_start
r_int
id|sym_setup_data_and_start
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_struct
id|scsi_cmnd
op_star
id|csio
comma
r_struct
id|sym_ccb
op_star
id|cp
)paren
(brace
r_int
id|dir
suffix:semicolon
r_struct
id|sym_tcb
op_star
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cp-&gt;target
)braket
suffix:semicolon
r_struct
id|sym_lcb
op_star
id|lp
op_assign
id|sym_lp
c_func
(paren
id|np
comma
id|tp
comma
id|cp-&gt;lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Build the CDB.&n;&t; */
r_if
c_cond
(paren
id|sym_setup_cdb
c_func
(paren
id|np
comma
id|csio
comma
id|cp
)paren
)paren
r_goto
id|out_abort
suffix:semicolon
multiline_comment|/*&n;&t; *  No direction means no data.&n;&t; */
id|dir
op_assign
id|csio-&gt;sc_data_direction
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_ne
id|SCSI_DATA_NONE
)paren
(brace
id|cp-&gt;segments
op_assign
id|sym_scatter
c_func
(paren
id|np
comma
id|cp
comma
id|csio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;segments
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;segments
op_eq
op_minus
l_int|2
)paren
id|sym_set_cam_status
c_func
(paren
id|csio
comma
id|CAM_RESRC_UNAVAIL
)paren
suffix:semicolon
r_else
id|sym_set_cam_status
c_func
(paren
id|csio
comma
id|CAM_REQ_TOO_BIG
)paren
suffix:semicolon
r_goto
id|out_abort
suffix:semicolon
)brace
)brace
r_else
(brace
id|cp-&gt;data_len
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;segments
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Set data pointers.&n;&t; */
id|sym_setup_data_pointers
c_func
(paren
id|np
comma
id|cp
comma
id|dir
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  When `#ifed 1&squot;, the code below makes the driver &n;&t; *  panic on the first attempt to write to a SCSI device.&n;&t; *  It is the first test we want to do after a driver &n;&t; *  change that does not seem obviously safe. :)&n;&t; */
macro_line|#if 0
r_switch
c_cond
(paren
id|cp-&gt;cdb_buf
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|0x0A
suffix:colon
r_case
l_int|0x2A
suffix:colon
r_case
l_int|0xAA
suffix:colon
id|panic
c_func
(paren
l_string|&quot;XXXXXXXXXXXXX WRITE NOT YET ALLOWED XXXXXXXXXXXXXX&bslash;n&quot;
)paren
suffix:semicolon
id|MDELAY
c_func
(paren
l_int|10000
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; *&t;activate this job.&n;&t; */
r_if
c_cond
(paren
id|lp
)paren
id|sym_start_next_ccbs
c_func
(paren
id|np
comma
id|lp
comma
l_int|2
)paren
suffix:semicolon
r_else
id|sym_put_start_queue
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_abort
suffix:colon
id|sym_free_ccb
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
id|sym_xpt_done
c_func
(paren
id|np
comma
id|csio
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  timer daemon.&n; *&n; *  Misused to keep the driver running when&n; *  interrupts are not configured correctly.&n; */
DECL|function|sym_timer
r_static
r_void
id|sym_timer
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
)paren
(brace
r_int
r_int
id|thistime
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/*&n;&t; *  Restart the timer.&n;&t; */
id|np-&gt;s.timer.expires
op_assign
id|thistime
op_plus
id|SYM_CONF_TIMER_INTERVAL
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|np-&gt;s.timer
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  If we are resetting the ncr, wait for settle_time before &n;&t; *  clearing it. Then command processing will be resumed.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;s.settle_time_valid
)paren
(brace
r_if
c_cond
(paren
id|time_before_eq
c_func
(paren
id|np-&gt;s.settle_time
comma
id|thistime
)paren
)paren
(brace
r_if
c_cond
(paren
id|sym_verbose
op_ge
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot;%s: command processing resumed&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;s.settle_time_valid
op_assign
l_int|0
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Nothing to do for now, but that may come.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;s.lasttime
op_plus
l_int|4
op_star
id|HZ
OL
id|thistime
)paren
(brace
id|np-&gt;s.lasttime
op_assign
id|thistime
suffix:semicolon
)brace
macro_line|#ifdef SYM_CONF_PCIQ_MAY_MISS_COMPLETIONS
multiline_comment|/*&n;&t; *  Some way-broken PCI bridges may lead to &n;&t; *  completions being lost when the clearing &n;&t; *  of the INTFLY flag by the CPU occurs &n;&t; *  concurrently with the chip raising this flag.&n;&t; *  If this ever happen, lost completions will &n;&t; * be reaped here.&n;&t; */
id|sym_wakeup_done
c_func
(paren
id|np
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; *  PCI BUS error handler.&n; */
DECL|function|sym_log_bus_error
r_void
id|sym_log_bus_error
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
)paren
(brace
id|u_short
id|pci_sts
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|np-&gt;s.device
comma
id|PCI_STATUS
comma
op_amp
id|pci_sts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_sts
op_amp
l_int|0xf900
)paren
(brace
id|pci_write_config_word
c_func
(paren
id|np-&gt;s.device
comma
id|PCI_STATUS
comma
id|pci_sts
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: PCI STATUS = 0x%04x&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|pci_sts
op_amp
l_int|0xf900
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *  Requeue awaiting commands.&n; */
DECL|function|sym_requeue_awaiting_cmds
r_static
r_void
id|sym_requeue_awaiting_cmds
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|cmd
suffix:semicolon
r_struct
id|sym_ucmd
op_star
id|ucp
op_assign
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|SYM_QUEHEAD
id|tmp_cmdq
suffix:semicolon
r_int
id|sts
suffix:semicolon
id|sym_que_move
c_func
(paren
op_amp
id|np-&gt;s.wait_cmdq
comma
op_amp
id|tmp_cmdq
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ucp
op_assign
(paren
r_struct
id|sym_ucmd
op_star
)paren
id|sym_remque_head
c_func
(paren
op_amp
id|tmp_cmdq
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|sym_insque_tail
c_func
(paren
op_amp
id|ucp-&gt;link_cmdq
comma
op_amp
id|np-&gt;s.busy_cmdq
)paren
suffix:semicolon
id|cmd
op_assign
id|SYM_SCMD_PTR
c_func
(paren
id|ucp
)paren
suffix:semicolon
id|sts
op_assign
id|sym_queue_command
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sts
)paren
(brace
id|sym_remque
c_func
(paren
op_amp
id|ucp-&gt;link_cmdq
)paren
suffix:semicolon
id|sym_insque_head
c_func
(paren
op_amp
id|ucp-&gt;link_cmdq
comma
op_amp
id|np-&gt;s.wait_cmdq
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * queuecommand method.  Entered with the host adapter lock held and&n; * interrupts disabled.&n; */
DECL|function|sym53c8xx_queue_command
r_static
r_int
id|sym53c8xx_queue_command
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
r_struct
id|scsi_cmnd
op_star
)paren
)paren
(brace
r_struct
id|sym_hcb
op_star
id|np
op_assign
id|SYM_SOFTC_PTR
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_struct
id|sym_ucmd
op_star
id|ucp
op_assign
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_int
id|sts
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|ucp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ucp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Shorten our settle_time if needed for &n;&t; *  this command not to time out.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;s.settle_time_valid
op_logical_and
id|cmd-&gt;timeout_per_command
)paren
(brace
r_int
r_int
id|tlimit
op_assign
id|jiffies
op_plus
id|cmd-&gt;timeout_per_command
suffix:semicolon
id|tlimit
op_sub_assign
id|SYM_CONF_TIMER_INTERVAL
op_star
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|np-&gt;s.settle_time
comma
id|tlimit
)paren
)paren
(brace
id|np-&gt;s.settle_time
op_assign
id|tlimit
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|np-&gt;s.settle_time_valid
op_logical_or
op_logical_neg
id|sym_que_empty
c_func
(paren
op_amp
id|np-&gt;s.wait_cmdq
)paren
)paren
(brace
id|sym_insque_tail
c_func
(paren
op_amp
id|ucp-&gt;link_cmdq
comma
op_amp
id|np-&gt;s.wait_cmdq
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|sym_insque_tail
c_func
(paren
op_amp
id|ucp-&gt;link_cmdq
comma
op_amp
id|np-&gt;s.busy_cmdq
)paren
suffix:semicolon
id|sts
op_assign
id|sym_queue_command
c_func
(paren
id|np
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sts
)paren
(brace
id|sym_remque
c_func
(paren
op_amp
id|ucp-&gt;link_cmdq
)paren
suffix:semicolon
id|sym_insque_tail
c_func
(paren
op_amp
id|ucp-&gt;link_cmdq
comma
op_amp
id|np-&gt;s.wait_cmdq
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Linux entry point of the interrupt handler.&n; */
DECL|function|sym53c8xx_intr
r_static
id|irqreturn_t
id|sym53c8xx_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sym_hcb
op_star
id|np
op_assign
(paren
r_struct
id|sym_hcb
op_star
)paren
id|dev_id
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf_debug
(paren
l_string|&quot;[&quot;
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|np-&gt;s.host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|sym_interrupt
c_func
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * push queue walk-through to tasklet&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sym_que_empty
c_func
(paren
op_amp
id|np-&gt;s.wait_cmdq
)paren
op_logical_and
op_logical_neg
id|np-&gt;s.settle_time_valid
)paren
id|sym_requeue_awaiting_cmds
c_func
(paren
id|np
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|np-&gt;s.host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf_debug
(paren
l_string|&quot;]&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/*&n; *  Linux entry point of the timer handler&n; */
DECL|function|sym53c8xx_timer
r_static
r_void
id|sym53c8xx_timer
c_func
(paren
r_int
r_int
id|npref
)paren
(brace
r_struct
id|sym_hcb
op_star
id|np
op_assign
(paren
r_struct
id|sym_hcb
op_star
)paren
id|npref
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|np-&gt;s.host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|sym_timer
c_func
(paren
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sym_que_empty
c_func
(paren
op_amp
id|np-&gt;s.wait_cmdq
)paren
op_logical_and
op_logical_neg
id|np-&gt;s.settle_time_valid
)paren
id|sym_requeue_awaiting_cmds
c_func
(paren
id|np
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|np-&gt;s.host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  What the eh thread wants us to perform.&n; */
DECL|macro|SYM_EH_ABORT
mdefine_line|#define SYM_EH_ABORT&t;&t;0
DECL|macro|SYM_EH_DEVICE_RESET
mdefine_line|#define SYM_EH_DEVICE_RESET&t;1
DECL|macro|SYM_EH_BUS_RESET
mdefine_line|#define SYM_EH_BUS_RESET&t;2
DECL|macro|SYM_EH_HOST_RESET
mdefine_line|#define SYM_EH_HOST_RESET&t;3
multiline_comment|/*&n; *  What we will do regarding the involved SCSI command.&n; */
DECL|macro|SYM_EH_DO_IGNORE
mdefine_line|#define SYM_EH_DO_IGNORE&t;0
DECL|macro|SYM_EH_DO_COMPLETE
mdefine_line|#define SYM_EH_DO_COMPLETE&t;1
DECL|macro|SYM_EH_DO_WAIT
mdefine_line|#define SYM_EH_DO_WAIT&t;&t;2
multiline_comment|/*&n; *  Our general completion handler.&n; */
DECL|function|__sym_eh_done
r_static
r_void
id|__sym_eh_done
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_int
id|timed_out
)paren
(brace
r_struct
id|sym_eh_wait
op_star
id|ep
op_assign
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|eh_wait
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
)paren
r_return
suffix:semicolon
multiline_comment|/* Try to avoid a race here (not 100% safe) */
r_if
c_cond
(paren
op_logical_neg
id|timed_out
)paren
(brace
id|ep-&gt;timed_out
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;to_do
op_eq
id|SYM_EH_DO_WAIT
op_logical_and
op_logical_neg
id|del_timer
c_func
(paren
op_amp
id|ep-&gt;timer
)paren
)paren
r_return
suffix:semicolon
)brace
multiline_comment|/* Revert everything */
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|eh_wait
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|ep-&gt;old_done
suffix:semicolon
multiline_comment|/* Wake up the eh thread if it wants to sleep */
r_if
c_cond
(paren
id|ep-&gt;to_do
op_eq
id|SYM_EH_DO_WAIT
)paren
id|up
c_func
(paren
op_amp
id|ep-&gt;sem
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  scsi_done() alias when error recovery is in progress. &n; */
DECL|function|sym_eh_done
r_static
r_void
id|sym_eh_done
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
id|__sym_eh_done
c_func
(paren
id|cmd
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Some timeout handler to avoid waiting too long.&n; */
DECL|function|sym_eh_timeout
r_static
r_void
id|sym_eh_timeout
c_func
(paren
id|u_long
id|p
)paren
(brace
id|__sym_eh_done
c_func
(paren
(paren
r_struct
id|scsi_cmnd
op_star
)paren
id|p
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Generic method for our eh processing.&n; *  The &squot;op&squot; argument tells what we have to do.&n; */
DECL|function|sym_eh_handler
r_static
r_int
id|sym_eh_handler
c_func
(paren
r_int
id|op
comma
r_char
op_star
id|opname
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|sym_hcb
op_star
id|np
op_assign
id|SYM_SOFTC_PTR
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|SYM_QUEHEAD
op_star
id|qp
suffix:semicolon
r_int
id|to_do
op_assign
id|SYM_EH_DO_IGNORE
suffix:semicolon
r_int
id|sts
op_assign
op_minus
l_int|1
suffix:semicolon
r_struct
id|sym_eh_wait
id|eh
comma
op_star
id|ep
op_assign
op_amp
id|eh
suffix:semicolon
r_char
id|devname
(braket
l_int|20
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|devname
comma
l_string|&quot;%s:%d:%d&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;lun
)paren
suffix:semicolon
id|printf_warning
c_func
(paren
l_string|&quot;%s: %s operation started.&bslash;n&quot;
comma
id|devname
comma
id|opname
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* This one should be the result of some race, thus to ignore */
r_if
c_cond
(paren
id|cmd-&gt;serial_number
op_ne
id|cmd-&gt;serial_number_at_timeout
)paren
r_goto
id|prepare
suffix:semicolon
macro_line|#endif
multiline_comment|/* This one is not queued to the core driver -&gt; to complete here */
id|FOR_EACH_QUEUED_ELEMENT
c_func
(paren
op_amp
id|np-&gt;s.wait_cmdq
comma
id|qp
)paren
(brace
r_if
c_cond
(paren
id|SYM_SCMD_PTR
c_func
(paren
id|qp
)paren
op_eq
id|cmd
)paren
(brace
id|to_do
op_assign
id|SYM_EH_DO_COMPLETE
suffix:semicolon
r_goto
id|prepare
suffix:semicolon
)brace
)brace
multiline_comment|/* This one is queued in some place -&gt; to wait for completion */
id|FOR_EACH_QUEUED_ELEMENT
c_func
(paren
op_amp
id|np-&gt;busy_ccbq
comma
id|qp
)paren
(brace
r_struct
id|sym_ccb
op_star
id|cp
op_assign
id|sym_que_entry
c_func
(paren
id|qp
comma
r_struct
id|sym_ccb
comma
id|link_ccbq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;cam_ccb
op_eq
id|cmd
)paren
(brace
id|to_do
op_assign
id|SYM_EH_DO_WAIT
suffix:semicolon
r_goto
id|prepare
suffix:semicolon
)brace
)brace
id|prepare
suffix:colon
multiline_comment|/* Prepare stuff to either ignore, complete or wait for completion */
r_switch
c_cond
(paren
id|to_do
)paren
(brace
r_default
suffix:colon
r_case
id|SYM_EH_DO_IGNORE
suffix:colon
r_goto
id|finish
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYM_EH_DO_WAIT
suffix:colon
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
id|ep-&gt;sem
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|SYM_EH_DO_COMPLETE
suffix:colon
id|ep-&gt;old_done
op_assign
id|cmd-&gt;scsi_done
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|sym_eh_done
suffix:semicolon
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|eh_wait
op_assign
id|ep
suffix:semicolon
)brace
multiline_comment|/* Try to proceed the operation we have been asked for */
id|sts
op_assign
op_minus
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|op
)paren
(brace
r_case
id|SYM_EH_ABORT
suffix:colon
id|sts
op_assign
id|sym_abort_scsiio
c_func
(paren
id|np
comma
id|cmd
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYM_EH_DEVICE_RESET
suffix:colon
id|sts
op_assign
id|sym_reset_scsi_target
c_func
(paren
id|np
comma
id|cmd-&gt;device-&gt;id
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYM_EH_BUS_RESET
suffix:colon
id|sym_reset_scsi_bus
c_func
(paren
id|np
comma
l_int|1
)paren
suffix:semicolon
id|sts
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SYM_EH_HOST_RESET
suffix:colon
id|sym_reset_scsi_bus
c_func
(paren
id|np
comma
l_int|0
)paren
suffix:semicolon
id|sym_start_up
(paren
id|np
comma
l_int|1
)paren
suffix:semicolon
id|sts
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/* On error, restore everything and cross fingers :) */
r_if
c_cond
(paren
id|sts
)paren
(brace
id|SYM_UCMD_PTR
c_func
(paren
id|cmd
)paren
op_member_access_from_pointer
id|eh_wait
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|ep-&gt;old_done
suffix:semicolon
id|to_do
op_assign
id|SYM_EH_DO_IGNORE
suffix:semicolon
)brace
id|finish
suffix:colon
id|ep-&gt;to_do
op_assign
id|to_do
suffix:semicolon
multiline_comment|/* Complete the command with locks held as required by the driver */
r_if
c_cond
(paren
id|to_do
op_eq
id|SYM_EH_DO_COMPLETE
)paren
id|sym_xpt_done2
c_func
(paren
id|np
comma
id|cmd
comma
id|CAM_REQ_ABORTED
)paren
suffix:semicolon
multiline_comment|/* Wait for completion with locks released, as required by kernel */
r_if
c_cond
(paren
id|to_do
op_eq
id|SYM_EH_DO_WAIT
)paren
(brace
id|init_timer
c_func
(paren
op_amp
id|ep-&gt;timer
)paren
suffix:semicolon
id|ep-&gt;timer.expires
op_assign
id|jiffies
op_plus
(paren
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
id|ep-&gt;timer.function
op_assign
id|sym_eh_timeout
suffix:semicolon
id|ep-&gt;timer.data
op_assign
(paren
id|u_long
)paren
id|cmd
suffix:semicolon
id|ep-&gt;timed_out
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Be pessimistic for once :) */
id|add_timer
c_func
(paren
op_amp
id|ep-&gt;timer
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|np-&gt;s.host-&gt;host_lock
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ep-&gt;sem
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|np-&gt;s.host-&gt;host_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;timed_out
)paren
id|sts
op_assign
op_minus
l_int|2
suffix:semicolon
)brace
id|printf_warning
c_func
(paren
l_string|&quot;%s: %s operation %s.&bslash;n&quot;
comma
id|devname
comma
id|opname
comma
id|sts
op_eq
l_int|0
ques
c_cond
l_string|&quot;complete&quot;
suffix:colon
id|sts
op_eq
op_minus
l_int|2
ques
c_cond
l_string|&quot;timed-out&quot;
suffix:colon
l_string|&quot;failed&quot;
)paren
suffix:semicolon
r_return
id|sts
ques
c_cond
id|SCSI_FAILED
suffix:colon
id|SCSI_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Error handlers called from the eh thread (one thread per HBA).&n; */
DECL|function|sym53c8xx_eh_abort_handler
r_static
r_int
id|sym53c8xx_eh_abort_handler
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_return
id|sym_eh_handler
c_func
(paren
id|SYM_EH_ABORT
comma
l_string|&quot;ABORT&quot;
comma
id|cmd
)paren
suffix:semicolon
)brace
DECL|function|sym53c8xx_eh_device_reset_handler
r_static
r_int
id|sym53c8xx_eh_device_reset_handler
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_return
id|sym_eh_handler
c_func
(paren
id|SYM_EH_DEVICE_RESET
comma
l_string|&quot;DEVICE RESET&quot;
comma
id|cmd
)paren
suffix:semicolon
)brace
DECL|function|sym53c8xx_eh_bus_reset_handler
r_static
r_int
id|sym53c8xx_eh_bus_reset_handler
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_return
id|sym_eh_handler
c_func
(paren
id|SYM_EH_BUS_RESET
comma
l_string|&quot;BUS RESET&quot;
comma
id|cmd
)paren
suffix:semicolon
)brace
DECL|function|sym53c8xx_eh_host_reset_handler
r_static
r_int
id|sym53c8xx_eh_host_reset_handler
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_return
id|sym_eh_handler
c_func
(paren
id|SYM_EH_HOST_RESET
comma
l_string|&quot;HOST RESET&quot;
comma
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Tune device queuing depth, according to various limits.&n; */
DECL|function|sym_tune_dev_queuing
r_static
r_void
id|sym_tune_dev_queuing
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_int
id|target
comma
r_int
id|lun
comma
id|u_short
id|reqtags
)paren
(brace
r_struct
id|sym_tcb
op_star
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_struct
id|sym_lcb
op_star
id|lp
op_assign
id|sym_lp
c_func
(paren
id|np
comma
id|tp
comma
id|lun
)paren
suffix:semicolon
id|u_short
id|oldtags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
r_return
suffix:semicolon
id|oldtags
op_assign
id|lp-&gt;s.reqtags
suffix:semicolon
r_if
c_cond
(paren
id|reqtags
OG
id|lp-&gt;s.scdev_depth
)paren
id|reqtags
op_assign
id|lp-&gt;s.scdev_depth
suffix:semicolon
id|lp-&gt;started_limit
op_assign
id|reqtags
ques
c_cond
id|reqtags
suffix:colon
l_int|2
suffix:semicolon
id|lp-&gt;started_max
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;s.reqtags
op_assign
id|reqtags
suffix:semicolon
r_if
c_cond
(paren
id|reqtags
op_ne
id|oldtags
)paren
(brace
id|printf_info
c_func
(paren
l_string|&quot;%s:%d:%d: &quot;
l_string|&quot;tagged command queuing %s, command queue depth %d.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|target
comma
id|lun
comma
id|lp-&gt;s.reqtags
ques
c_cond
l_string|&quot;enabled&quot;
suffix:colon
l_string|&quot;disabled&quot;
comma
id|lp-&gt;started_limit
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef&t;SYM_LINUX_BOOT_COMMAND_LINE_SUPPORT
multiline_comment|/*&n; *  Linux select queue depths function&n; */
DECL|macro|DEF_DEPTH
mdefine_line|#define DEF_DEPTH&t;(sym_driver_setup.max_tag)
DECL|macro|ALL_TARGETS
mdefine_line|#define ALL_TARGETS&t;-2
DECL|macro|NO_TARGET
mdefine_line|#define NO_TARGET&t;-1
DECL|macro|ALL_LUNS
mdefine_line|#define ALL_LUNS&t;-2
DECL|macro|NO_LUN
mdefine_line|#define NO_LUN&t;&t;-1
DECL|function|device_queue_depth
r_static
r_int
id|device_queue_depth
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_int
id|target
comma
r_int
id|lun
)paren
(brace
r_int
id|c
comma
id|h
comma
id|t
comma
id|u
comma
id|v
suffix:semicolon
r_char
op_star
id|p
op_assign
id|sym_driver_setup.tag_ctrl
suffix:semicolon
r_char
op_star
id|ep
suffix:semicolon
id|h
op_assign
op_minus
l_int|1
suffix:semicolon
id|t
op_assign
id|NO_TARGET
suffix:semicolon
id|u
op_assign
id|NO_LUN
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|p
op_increment
)paren
op_ne
l_int|0
)paren
(brace
id|v
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
op_amp
id|ep
comma
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;/&squot;
suffix:colon
op_increment
id|h
suffix:semicolon
id|t
op_assign
id|ALL_TARGETS
suffix:semicolon
id|u
op_assign
id|ALL_LUNS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
r_if
c_cond
(paren
id|t
op_ne
id|target
)paren
id|t
op_assign
(paren
id|target
op_eq
id|v
)paren
ques
c_cond
id|v
suffix:colon
id|NO_TARGET
suffix:semicolon
id|u
op_assign
id|ALL_LUNS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;u&squot;
suffix:colon
r_if
c_cond
(paren
id|u
op_ne
id|lun
)paren
id|u
op_assign
(paren
id|lun
op_eq
id|v
)paren
ques
c_cond
id|v
suffix:colon
id|NO_LUN
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;q&squot;
suffix:colon
r_if
c_cond
(paren
id|h
op_eq
id|np-&gt;s.unit
op_logical_and
(paren
id|t
op_eq
id|ALL_TARGETS
op_logical_or
id|t
op_eq
id|target
)paren
op_logical_and
(paren
id|u
op_eq
id|ALL_LUNS
op_logical_or
id|u
op_eq
id|lun
)paren
)paren
r_return
id|v
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;-&squot;
suffix:colon
id|t
op_assign
id|ALL_TARGETS
suffix:semicolon
id|u
op_assign
id|ALL_LUNS
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|p
op_assign
id|ep
suffix:semicolon
)brace
r_return
id|DEF_DEPTH
suffix:semicolon
)brace
macro_line|#else
DECL|macro|device_queue_depth
mdefine_line|#define device_queue_depth(np, t, l)&t;(sym_driver_setup.max_tag)
macro_line|#endif&t;/* SYM_LINUX_BOOT_COMMAND_LINE_SUPPORT */
multiline_comment|/*&n; * Linux entry point for device queue sizing.&n; */
DECL|function|sym53c8xx_slave_configure
r_static
r_int
id|sym53c8xx_slave_configure
c_func
(paren
r_struct
id|scsi_device
op_star
id|device
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|device-&gt;host
suffix:semicolon
r_struct
id|sym_hcb
op_star
id|np
suffix:semicolon
r_struct
id|sym_tcb
op_star
id|tp
suffix:semicolon
r_struct
id|sym_lcb
op_star
id|lp
suffix:semicolon
r_int
id|reqtags
comma
id|depth_to_use
suffix:semicolon
id|np
op_assign
(paren
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
)paren
op_member_access_from_pointer
id|ncb
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|device-&gt;id
)braket
suffix:semicolon
multiline_comment|/*&n;&t; *  Get user settings for transfer parameters.&n;&t; */
id|tp-&gt;inq_byte7_valid
op_assign
(paren
id|INQ7_SYNC
op_or
id|INQ7_WIDE16
)paren
suffix:semicolon
id|sym_update_trans_settings
c_func
(paren
id|np
comma
id|tp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Allocate the LCB if not yet.&n;&t; *  If it fail, we may well be in the sh*t. :)&n;&t; */
id|lp
op_assign
id|sym_alloc_lcb
c_func
(paren
id|np
comma
id|device-&gt;id
comma
id|device-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/*&n;&t; *  Get user flags.&n;&t; */
id|lp-&gt;curr_flags
op_assign
id|lp-&gt;user_flags
suffix:semicolon
multiline_comment|/*&n;&t; *  Select queue depth from driver setup.&n;&t; *  Donnot use more than configured by user.&n;&t; *  Use at least 2.&n;&t; *  Donnot use more than our maximum.&n;&t; */
id|reqtags
op_assign
id|device_queue_depth
c_func
(paren
id|np
comma
id|device-&gt;id
comma
id|device-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reqtags
OG
id|tp-&gt;usrtags
)paren
id|reqtags
op_assign
id|tp-&gt;usrtags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device-&gt;tagged_supported
)paren
id|reqtags
op_assign
l_int|0
suffix:semicolon
macro_line|#if 1 /* Avoid to locally queue commands for no good reasons */
r_if
c_cond
(paren
id|reqtags
OG
id|SYM_CONF_MAX_TAG
)paren
id|reqtags
op_assign
id|SYM_CONF_MAX_TAG
suffix:semicolon
id|depth_to_use
op_assign
(paren
id|reqtags
ques
c_cond
id|reqtags
suffix:colon
l_int|2
)paren
suffix:semicolon
macro_line|#else
id|depth_to_use
op_assign
(paren
id|reqtags
ques
c_cond
id|SYM_CONF_MAX_TAG
suffix:colon
l_int|2
)paren
suffix:semicolon
macro_line|#endif
id|scsi_adjust_queue_depth
c_func
(paren
id|device
comma
(paren
id|device-&gt;tagged_supported
ques
c_cond
id|MSG_SIMPLE_TAG
suffix:colon
l_int|0
)paren
comma
id|depth_to_use
)paren
suffix:semicolon
id|lp-&gt;s.scdev_depth
op_assign
id|depth_to_use
suffix:semicolon
id|sym_tune_dev_queuing
c_func
(paren
id|np
comma
id|device-&gt;id
comma
id|device-&gt;lun
comma
id|reqtags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Linux entry point for info() function&n; */
DECL|function|sym53c8xx_info
r_static
r_const
r_char
op_star
id|sym53c8xx_info
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_return
id|sym_driver_name
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef SYM_LINUX_PROC_INFO_SUPPORT
multiline_comment|/*&n; *  Proc file system stuff&n; *&n; *  A read operation returns adapter information.&n; *  A write operation is a control command.&n; *  The string is parsed in the driver code and the command is passed &n; *  to the sym_usercmd() function.&n; */
macro_line|#ifdef SYM_LINUX_USER_COMMAND_SUPPORT
DECL|struct|sym_usrcmd
r_struct
id|sym_usrcmd
(brace
DECL|member|target
id|u_long
id|target
suffix:semicolon
DECL|member|lun
id|u_long
id|lun
suffix:semicolon
DECL|member|data
id|u_long
id|data
suffix:semicolon
DECL|member|cmd
id|u_long
id|cmd
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|UC_SETSYNC
mdefine_line|#define UC_SETSYNC      10
DECL|macro|UC_SETTAGS
mdefine_line|#define UC_SETTAGS&t;11
DECL|macro|UC_SETDEBUG
mdefine_line|#define UC_SETDEBUG&t;12
DECL|macro|UC_SETWIDE
mdefine_line|#define UC_SETWIDE&t;14
DECL|macro|UC_SETFLAG
mdefine_line|#define UC_SETFLAG&t;15
DECL|macro|UC_SETVERBOSE
mdefine_line|#define UC_SETVERBOSE&t;17
DECL|macro|UC_RESETDEV
mdefine_line|#define UC_RESETDEV&t;18
DECL|macro|UC_CLEARDEV
mdefine_line|#define UC_CLEARDEV&t;19
DECL|function|sym_exec_user_command
r_static
r_void
id|sym_exec_user_command
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_struct
id|sym_usrcmd
op_star
id|uc
)paren
(brace
r_struct
id|sym_tcb
op_star
id|tp
suffix:semicolon
r_int
id|t
comma
id|l
suffix:semicolon
r_switch
c_cond
(paren
id|uc-&gt;cmd
)paren
(brace
r_case
l_int|0
suffix:colon
r_return
suffix:semicolon
macro_line|#ifdef SYM_LINUX_DEBUG_CONTROL_SUPPORT
r_case
id|UC_SETDEBUG
suffix:colon
id|sym_debug_flags
op_assign
id|uc-&gt;data
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
id|UC_SETVERBOSE
suffix:colon
id|np-&gt;verbose
op_assign
id|uc-&gt;data
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/*&n;&t;&t; * We assume that other commands apply to targets.&n;&t;&t; * This should always be the case and avoid the below &n;&t;&t; * 4 lines to be repeated 6 times.&n;&t;&t; */
r_for
c_loop
(paren
id|t
op_assign
l_int|0
suffix:semicolon
id|t
OL
id|SYM_CONF_MAX_TARGET
suffix:semicolon
id|t
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|uc-&gt;target
op_rshift
id|t
)paren
op_amp
l_int|1
)paren
)paren
r_continue
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|t
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|uc-&gt;cmd
)paren
(brace
r_case
id|UC_SETSYNC
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|uc-&gt;data
op_logical_or
id|uc-&gt;data
op_ge
l_int|255
)paren
(brace
id|tp-&gt;tinfo.goal.options
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;tinfo.goal.offset
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uc-&gt;data
op_le
l_int|9
op_logical_and
id|np-&gt;minsync_dt
)paren
(brace
r_if
c_cond
(paren
id|uc-&gt;data
OL
id|np-&gt;minsync_dt
)paren
id|uc-&gt;data
op_assign
id|np-&gt;minsync_dt
suffix:semicolon
id|tp-&gt;tinfo.goal.options
op_assign
id|PPR_OPT_DT
suffix:semicolon
id|tp-&gt;tinfo.goal.width
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;tinfo.goal.period
op_assign
id|uc-&gt;data
suffix:semicolon
id|tp-&gt;tinfo.goal.offset
op_assign
id|np-&gt;maxoffs_dt
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|uc-&gt;data
OL
id|np-&gt;minsync
)paren
id|uc-&gt;data
op_assign
id|np-&gt;minsync
suffix:semicolon
id|tp-&gt;tinfo.goal.options
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;tinfo.goal.period
op_assign
id|uc-&gt;data
suffix:semicolon
id|tp-&gt;tinfo.goal.offset
op_assign
id|np-&gt;maxoffs
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|UC_SETWIDE
suffix:colon
id|tp-&gt;tinfo.goal.width
op_assign
id|uc-&gt;data
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETTAGS
suffix:colon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|SYM_CONF_MAX_LUN
suffix:semicolon
id|l
op_increment
)paren
id|sym_tune_dev_queuing
c_func
(paren
id|np
comma
id|t
comma
id|l
comma
id|uc-&gt;data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_RESETDEV
suffix:colon
id|tp-&gt;to_reset
op_assign
l_int|1
suffix:semicolon
id|np-&gt;istat_sem
op_assign
id|SEM
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
op_or
id|SEM
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_CLEARDEV
suffix:colon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|SYM_CONF_MAX_LUN
suffix:semicolon
id|l
op_increment
)paren
(brace
r_struct
id|sym_lcb
op_star
id|lp
op_assign
id|sym_lp
c_func
(paren
id|np
comma
id|tp
comma
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp
)paren
id|lp-&gt;to_clear
op_assign
l_int|1
suffix:semicolon
)brace
id|np-&gt;istat_sem
op_assign
id|SEM
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
op_or
id|SEM
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UC_SETFLAG
suffix:colon
id|tp-&gt;usrflags
op_assign
id|uc-&gt;data
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
)brace
DECL|macro|digit_to_bin
mdefine_line|#define digit_to_bin(c)&t;((c) - &squot;0&squot;)
DECL|function|skip_spaces
r_static
r_int
id|skip_spaces
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
id|len
)paren
(brace
r_int
id|cnt
comma
id|c
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
id|len
suffix:semicolon
id|cnt
OG
l_int|0
op_logical_and
(paren
id|c
op_assign
op_star
id|ptr
op_increment
)paren
op_logical_and
id|isspace
c_func
(paren
id|c
)paren
suffix:semicolon
id|cnt
op_decrement
)paren
suffix:semicolon
r_return
(paren
id|len
op_minus
id|cnt
)paren
suffix:semicolon
)brace
DECL|function|get_int_arg
r_static
r_int
id|get_int_arg
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
id|len
comma
id|u_long
op_star
id|pv
)paren
(brace
r_int
id|cnt
comma
id|c
suffix:semicolon
id|u_long
id|v
suffix:semicolon
r_for
c_loop
(paren
id|v
op_assign
l_int|0
comma
id|cnt
op_assign
id|len
suffix:semicolon
id|cnt
OG
l_int|0
op_logical_and
(paren
id|c
op_assign
op_star
id|ptr
op_increment
)paren
op_logical_and
id|isdigit
c_func
(paren
id|c
)paren
suffix:semicolon
id|cnt
op_decrement
)paren
(brace
id|v
op_assign
(paren
id|v
op_star
l_int|10
)paren
op_plus
id|digit_to_bin
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pv
)paren
op_star
id|pv
op_assign
id|v
suffix:semicolon
r_return
(paren
id|len
op_minus
id|cnt
)paren
suffix:semicolon
)brace
DECL|function|is_keyword
r_static
r_int
id|is_keyword
c_func
(paren
r_char
op_star
id|ptr
comma
r_int
id|len
comma
r_char
op_star
id|verb
)paren
(brace
r_int
id|verb_len
op_assign
id|strlen
c_func
(paren
id|verb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
id|strlen
c_func
(paren
id|verb
)paren
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|verb
comma
id|ptr
comma
id|verb_len
)paren
)paren
r_return
id|verb_len
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|SKIP_SPACES
mdefine_line|#define SKIP_SPACES(min_spaces)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if ((arg_len = skip_spaces(ptr, len)) &lt; (min_spaces))&t;&t;&bslash;&n;&t;&t;return -EINVAL;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ptr += arg_len; len -= arg_len;
DECL|macro|GET_INT_ARG
mdefine_line|#define GET_INT_ARG(v)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (!(arg_len = get_int_arg(ptr, len, &amp;(v))))&t;&t;&t;&bslash;&n;&t;&t;return -EINVAL;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ptr += arg_len; len -= arg_len;
multiline_comment|/*&n; * Parse a control command&n; */
DECL|function|sym_user_command
r_static
r_int
id|sym_user_command
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_char
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
r_char
op_star
id|ptr
op_assign
id|buffer
suffix:semicolon
r_int
id|len
op_assign
id|length
suffix:semicolon
r_struct
id|sym_usrcmd
id|cmd
comma
op_star
id|uc
op_assign
op_amp
id|cmd
suffix:semicolon
r_int
id|arg_len
suffix:semicolon
id|u_long
id|target
suffix:semicolon
id|bzero
c_func
(paren
id|uc
comma
r_sizeof
(paren
op_star
id|uc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
op_logical_and
id|ptr
(braket
id|len
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
op_decrement
id|len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setsync&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETSYNC
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;settags&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETTAGS
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setverbose&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETVERBOSE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setwide&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETWIDE
suffix:semicolon
macro_line|#ifdef SYM_LINUX_DEBUG_CONTROL_SUPPORT
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setdebug&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETDEBUG
suffix:semicolon
macro_line|#endif
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;setflag&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_SETFLAG
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;resetdev&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_RESETDEV
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;cleardev&quot;
)paren
)paren
op_ne
l_int|0
)paren
id|uc-&gt;cmd
op_assign
id|UC_CLEARDEV
suffix:semicolon
r_else
id|arg_len
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;sym_user_command: arg_len=%d, cmd=%ld&bslash;n&quot;
comma
id|arg_len
comma
id|uc-&gt;cmd
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|arg_len
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
r_switch
c_cond
(paren
id|uc-&gt;cmd
)paren
(brace
r_case
id|UC_SETSYNC
suffix:colon
r_case
id|UC_SETTAGS
suffix:colon
r_case
id|UC_SETWIDE
suffix:colon
r_case
id|UC_SETFLAG
suffix:colon
r_case
id|UC_RESETDEV
suffix:colon
r_case
id|UC_CLEARDEV
suffix:colon
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;all&quot;
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
id|uc-&gt;target
op_assign
op_complement
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|GET_INT_ARG
c_func
(paren
id|target
)paren
suffix:semicolon
id|uc-&gt;target
op_assign
(paren
l_int|1
op_lshift
id|target
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;sym_user_command: target=%ld&bslash;n&quot;
comma
id|target
)paren
suffix:semicolon
macro_line|#endif
)brace
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|uc-&gt;cmd
)paren
(brace
r_case
id|UC_SETVERBOSE
suffix:colon
r_case
id|UC_SETSYNC
suffix:colon
r_case
id|UC_SETTAGS
suffix:colon
r_case
id|UC_SETWIDE
suffix:colon
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|GET_INT_ARG
c_func
(paren
id|uc-&gt;data
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;sym_user_command: data=%ld&bslash;n&quot;
comma
id|uc-&gt;data
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
macro_line|#ifdef SYM_LINUX_DEBUG_CONTROL_SUPPORT
r_case
id|UC_SETDEBUG
suffix:colon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;alloc&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_ALLOC
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;phase&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_PHASE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;queue&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_QUEUE
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;result&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_RESULT
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;scatter&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_SCATTER
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;script&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_SCRIPT
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;tiny&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_TINY
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;timing&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_TIMING
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;nego&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_NEGO
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;tags&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_TAGS
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;pointer&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_or_assign
id|DEBUG_POINTER
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_PROC_INFO
id|printk
c_func
(paren
l_string|&quot;sym_user_command: data=%ld&bslash;n&quot;
comma
id|uc-&gt;data
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
macro_line|#endif /* SYM_LINUX_DEBUG_CONTROL_SUPPORT */
r_case
id|UC_SETFLAG
suffix:colon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|SKIP_SPACES
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg_len
op_assign
id|is_keyword
c_func
(paren
id|ptr
comma
id|len
comma
l_string|&quot;no_disc&quot;
)paren
)paren
)paren
id|uc-&gt;data
op_and_assign
op_complement
id|SYM_DISC_ENABLED
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr
op_add_assign
id|arg_len
suffix:semicolon
id|len
op_sub_assign
id|arg_len
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|np-&gt;s.host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|sym_exec_user_command
(paren
id|np
comma
id|uc
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|np-&gt;s.host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|length
suffix:semicolon
)brace
macro_line|#endif&t;/* SYM_LINUX_USER_COMMAND_SUPPORT */
macro_line|#ifdef SYM_LINUX_USER_INFO_SUPPORT
multiline_comment|/*&n; *  Informations through the proc file system.&n; */
DECL|struct|info_str
r_struct
id|info_str
(brace
DECL|member|buffer
r_char
op_star
id|buffer
suffix:semicolon
DECL|member|length
r_int
id|length
suffix:semicolon
DECL|member|offset
r_int
id|offset
suffix:semicolon
DECL|member|pos
r_int
id|pos
suffix:semicolon
)brace
suffix:semicolon
DECL|function|copy_mem_info
r_static
r_void
id|copy_mem_info
c_func
(paren
r_struct
id|info_str
op_star
id|info
comma
r_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pos
op_plus
id|len
OG
id|info-&gt;length
)paren
id|len
op_assign
id|info-&gt;length
op_minus
id|info-&gt;pos
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;pos
op_plus
id|len
OL
id|info-&gt;offset
)paren
(brace
id|info-&gt;pos
op_add_assign
id|len
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;pos
OL
id|info-&gt;offset
)paren
(brace
id|data
op_add_assign
(paren
id|info-&gt;offset
op_minus
id|info-&gt;pos
)paren
suffix:semicolon
id|len
op_sub_assign
(paren
id|info-&gt;offset
op_minus
id|info-&gt;pos
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|info-&gt;buffer
op_plus
id|info-&gt;pos
comma
id|data
comma
id|len
)paren
suffix:semicolon
id|info-&gt;pos
op_add_assign
id|len
suffix:semicolon
)brace
)brace
DECL|function|copy_info
r_static
r_int
id|copy_info
c_func
(paren
r_struct
id|info_str
op_star
id|info
comma
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_char
id|buf
(braket
l_int|81
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|len
op_assign
id|vsprintf
c_func
(paren
id|buf
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
id|copy_mem_info
c_func
(paren
id|info
comma
id|buf
comma
id|len
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; *  Copy formatted information into the input buffer.&n; */
DECL|function|sym_host_info
r_static
r_int
id|sym_host_info
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
comma
r_char
op_star
id|ptr
comma
id|off_t
id|offset
comma
r_int
id|len
)paren
(brace
r_struct
id|info_str
id|info
suffix:semicolon
id|info.buffer
op_assign
id|ptr
suffix:semicolon
id|info.length
op_assign
id|len
suffix:semicolon
id|info.offset
op_assign
id|offset
suffix:semicolon
id|info.pos
op_assign
l_int|0
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Chip &quot;
id|NAME53C
l_string|&quot;%s, device id 0x%x, &quot;
l_string|&quot;revision id 0x%x&bslash;n&quot;
comma
id|np-&gt;s.chip_name
comma
id|np-&gt;device_id
comma
id|np-&gt;revision_id
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;At PCI address %s, &quot;
macro_line|#ifdef __sparc__
l_string|&quot;IRQ %s&bslash;n&quot;
comma
macro_line|#else
l_string|&quot;IRQ %d&bslash;n&quot;
comma
macro_line|#endif
id|pci_name
c_func
(paren
id|np-&gt;s.device
)paren
comma
macro_line|#ifdef __sparc__
id|__irq_itoa
c_func
(paren
id|np-&gt;s.irq
)paren
)paren
suffix:semicolon
macro_line|#else
(paren
r_int
)paren
id|np-&gt;s.irq
)paren
suffix:semicolon
macro_line|#endif
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Min. period factor %d, %s SCSI BUS%s&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|np-&gt;minsync_dt
ques
c_cond
id|np-&gt;minsync_dt
suffix:colon
id|np-&gt;minsync
)paren
comma
id|np-&gt;maxwide
ques
c_cond
l_string|&quot;Wide&quot;
suffix:colon
l_string|&quot;Narrow&quot;
comma
id|np-&gt;minsync_dt
ques
c_cond
l_string|&quot;, DT capable&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|copy_info
c_func
(paren
op_amp
id|info
comma
l_string|&quot;Max. started commands %d, &quot;
l_string|&quot;max. commands per LUN %d&bslash;n&quot;
comma
id|SYM_CONF_MAX_START
comma
id|SYM_CONF_MAX_TAG
)paren
suffix:semicolon
r_return
id|info.pos
OG
id|info.offset
ques
c_cond
id|info.pos
op_minus
id|info.offset
suffix:colon
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* SYM_LINUX_USER_INFO_SUPPORT */
multiline_comment|/*&n; *  Entry point of the scsi proc fs of the driver.&n; *  - func = 0 means read  (returns adapter infos)&n; *  - func = 1 means write (not yet merget from sym53c8xx)&n; */
DECL|function|sym53c8xx_proc_info
r_static
r_int
id|sym53c8xx_proc_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|func
)paren
(brace
r_struct
id|host_data
op_star
id|host_data
suffix:semicolon
r_struct
id|sym_hcb
op_star
id|np
op_assign
l_int|0
suffix:semicolon
r_int
id|retv
suffix:semicolon
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|np
op_assign
id|host_data-&gt;ncb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|func
)paren
(brace
macro_line|#ifdef&t;SYM_LINUX_USER_COMMAND_SUPPORT
id|retv
op_assign
id|sym_user_command
c_func
(paren
id|np
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
macro_line|#else
id|retv
op_assign
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_if
c_cond
(paren
id|start
)paren
op_star
id|start
op_assign
id|buffer
suffix:semicolon
macro_line|#ifdef SYM_LINUX_USER_INFO_SUPPORT
id|retv
op_assign
id|sym_host_info
c_func
(paren
id|np
comma
id|buffer
comma
id|offset
comma
id|length
)paren
suffix:semicolon
macro_line|#else
id|retv
op_assign
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif
)brace
r_return
id|retv
suffix:semicolon
)brace
macro_line|#endif /* SYM_LINUX_PROC_INFO_SUPPORT */
multiline_comment|/*&n; *&t;Free controller resources.&n; */
DECL|function|sym_free_resources
r_static
r_void
id|sym_free_resources
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
)paren
(brace
multiline_comment|/*&n;&t; *  Free O/S specific resources.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;s.irq
)paren
id|free_irq
c_func
(paren
id|np-&gt;s.irq
comma
id|np
)paren
suffix:semicolon
macro_line|#ifndef SYM_CONF_IOMAPPED
r_if
c_cond
(paren
id|np-&gt;s.mmio_va
)paren
id|iounmap
c_func
(paren
id|np-&gt;s.mmio_va
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|np-&gt;s.ram_va
)paren
id|iounmap
c_func
(paren
id|np-&gt;s.ram_va
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Free O/S independent resources.&n;&t; */
id|sym_hcb_free
c_func
(paren
id|np
)paren
suffix:semicolon
id|sym_mfree_dma
c_func
(paren
id|np
comma
r_sizeof
(paren
op_star
id|np
)paren
comma
l_string|&quot;HCB&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Ask/tell the system about DMA addressing.&n; */
DECL|function|sym_setup_bus_dma_mask
r_static
r_int
id|sym_setup_bus_dma_mask
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
)paren
(brace
macro_line|#if   SYM_CONF_DMA_ADDRESSING_MODE == 0
r_if
c_cond
(paren
id|pci_set_dma_mask
c_func
(paren
id|np-&gt;s.device
comma
l_int|0xffffffffUL
)paren
)paren
r_goto
id|out_err32
suffix:semicolon
macro_line|#else
macro_line|#if   SYM_CONF_DMA_ADDRESSING_MODE == 1
mdefine_line|#define&t;PciDmaMask&t;0xffffffffffULL
macro_line|#elif SYM_CONF_DMA_ADDRESSING_MODE == 2
mdefine_line|#define&t;PciDmaMask&t;0xffffffffffffffffULL
macro_line|#endif
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_DAC
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pci_set_dma_mask
c_func
(paren
id|np-&gt;s.device
comma
id|PciDmaMask
)paren
)paren
(brace
id|np-&gt;use_dac
op_assign
l_int|1
suffix:semicolon
id|printf_info
c_func
(paren
l_string|&quot;%s: using 64 bit DMA addressing&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|pci_set_dma_mask
c_func
(paren
id|np-&gt;s.device
comma
l_int|0xffffffffUL
)paren
)paren
r_goto
id|out_err32
suffix:semicolon
)brace
)brace
macro_line|#undef&t;PciDmaMask
macro_line|#endif
r_return
l_int|0
suffix:semicolon
id|out_err32
suffix:colon
id|printf_warning
c_func
(paren
l_string|&quot;%s: 32 BIT DMA ADDRESSING NOT SUPPORTED&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *  Host attach and initialisations.&n; *&n; *  Allocate host data and ncb structure.&n; *  Remap MMIO region.&n; *  Do chip initialization.&n; *  If all is OK, install interrupt handling and&n; *  start the timer daemon.&n; */
DECL|function|sym_attach
r_static
r_struct
id|Scsi_Host
op_star
id|__devinit
id|sym_attach
c_func
(paren
r_struct
id|scsi_host_template
op_star
id|tpnt
comma
r_int
id|unit
comma
r_struct
id|sym_device
op_star
id|dev
)paren
(brace
r_struct
id|host_data
op_star
id|host_data
suffix:semicolon
r_struct
id|sym_hcb
op_star
id|np
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sym_fw
op_star
id|fw
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;sym%d: &lt;%s&gt; rev 0x%x at pci %s &quot;
macro_line|#ifdef __sparc__
l_string|&quot;irq %s&bslash;n&quot;
comma
macro_line|#else
l_string|&quot;irq %d&bslash;n&quot;
comma
macro_line|#endif
id|unit
comma
id|dev-&gt;chip.name
comma
id|dev-&gt;chip.revision_id
comma
id|pci_name
c_func
(paren
id|dev-&gt;pdev
)paren
comma
macro_line|#ifdef __sparc__
id|__irq_itoa
c_func
(paren
id|dev-&gt;s.irq
)paren
)paren
suffix:semicolon
macro_line|#else
id|dev-&gt;s.irq
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *  Get the firmware for this chip.&n;&t; */
id|fw
op_assign
id|sym_find_firmware
c_func
(paren
op_amp
id|dev-&gt;chip
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fw
)paren
r_goto
id|attach_failed
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allocate host_data structure&n;&t; */
id|instance
op_assign
id|scsi_host_alloc
c_func
(paren
id|tpnt
comma
r_sizeof
(paren
op_star
id|host_data
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|instance
)paren
r_goto
id|attach_failed
suffix:semicolon
id|host_data
op_assign
(paren
r_struct
id|host_data
op_star
)paren
id|instance-&gt;hostdata
suffix:semicolon
multiline_comment|/*&n;&t; *  Allocate immediately the host control block, &n;&t; *  since we are only expecting to succeed. :)&n;&t; *  We keep track in the HCB of all the resources that &n;&t; *  are to be released on error.&n;&t; */
id|np
op_assign
id|__sym_calloc_dma
c_func
(paren
id|dev-&gt;pdev
comma
r_sizeof
(paren
op_star
id|np
)paren
comma
l_string|&quot;HCB&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np
)paren
r_goto
id|attach_failed
suffix:semicolon
id|np-&gt;s.device
op_assign
id|dev-&gt;pdev
suffix:semicolon
id|np-&gt;bus_dmat
op_assign
id|dev-&gt;pdev
suffix:semicolon
multiline_comment|/* Result in 1 DMA pool per HBA */
id|host_data-&gt;ncb
op_assign
id|np
suffix:semicolon
id|np-&gt;s.host
op_assign
id|instance
suffix:semicolon
id|pci_set_drvdata
c_func
(paren
id|dev-&gt;pdev
comma
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Copy some useful infos to the HCB.&n;&t; */
id|np-&gt;hcb_ba
op_assign
id|vtobus
c_func
(paren
id|np
)paren
suffix:semicolon
id|np-&gt;verbose
op_assign
id|sym_driver_setup.verbose
suffix:semicolon
id|np-&gt;s.device
op_assign
id|dev-&gt;pdev
suffix:semicolon
id|np-&gt;s.unit
op_assign
id|unit
suffix:semicolon
id|np-&gt;device_id
op_assign
id|dev-&gt;chip.device_id
suffix:semicolon
id|np-&gt;revision_id
op_assign
id|dev-&gt;chip.revision_id
suffix:semicolon
id|np-&gt;features
op_assign
id|dev-&gt;chip.features
suffix:semicolon
id|np-&gt;clock_divn
op_assign
id|dev-&gt;chip.nr_divisor
suffix:semicolon
id|np-&gt;maxoffs
op_assign
id|dev-&gt;chip.offset_max
suffix:semicolon
id|np-&gt;maxburst
op_assign
id|dev-&gt;chip.burst_max
suffix:semicolon
id|np-&gt;myaddr
op_assign
id|dev-&gt;host_id
suffix:semicolon
multiline_comment|/*&n;&t; *  Edit its name.&n;&t; */
id|strlcpy
c_func
(paren
id|np-&gt;s.chip_name
comma
id|dev-&gt;chip.name
comma
r_sizeof
(paren
id|np-&gt;s.chip_name
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|np-&gt;s.inst_name
comma
l_string|&quot;sym%d&quot;
comma
id|np-&gt;s.unit
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Ask/tell the system about DMA addressing.&n;&t; */
r_if
c_cond
(paren
id|sym_setup_bus_dma_mask
c_func
(paren
id|np
)paren
)paren
r_goto
id|attach_failed
suffix:semicolon
multiline_comment|/*&n;&t; *  Try to map the controller chip to&n;&t; *  virtual and physical memory.&n;&t; */
id|np-&gt;mmio_ba
op_assign
(paren
id|u32
)paren
id|dev-&gt;s.base
suffix:semicolon
id|np-&gt;s.io_ws
op_assign
(paren
id|np-&gt;features
op_amp
id|FE_IO256
)paren
ques
c_cond
l_int|256
suffix:colon
l_int|128
suffix:semicolon
macro_line|#ifndef SYM_CONF_IOMAPPED
id|np-&gt;s.mmio_va
op_assign
id|ioremap
c_func
(paren
id|dev-&gt;s.base_c
comma
id|np-&gt;s.io_ws
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;s.mmio_va
)paren
(brace
id|printf_err
c_func
(paren
l_string|&quot;%s: can&squot;t map PCI MMIO region&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_goto
id|attach_failed
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sym_verbose
OG
l_int|1
)paren
id|printf_info
c_func
(paren
l_string|&quot;%s: using memory mapped IO&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
macro_line|#endif /* !defined SYM_CONF_IOMAPPED */
id|np-&gt;s.io_port
op_assign
id|dev-&gt;s.io_port
suffix:semicolon
multiline_comment|/*&n;&t; *  Map on-chip RAM if present and supported.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_RAM
)paren
)paren
id|dev-&gt;s.base_2
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;s.base_2
)paren
(brace
id|np-&gt;ram_ba
op_assign
(paren
id|u32
)paren
id|dev-&gt;s.base_2
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_RAM8K
)paren
id|np-&gt;ram_ws
op_assign
l_int|8192
suffix:semicolon
r_else
id|np-&gt;ram_ws
op_assign
l_int|4096
suffix:semicolon
id|np-&gt;s.ram_va
op_assign
id|ioremap
c_func
(paren
id|dev-&gt;s.base_2_c
comma
id|np-&gt;ram_ws
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;s.ram_va
)paren
(brace
id|printf_err
c_func
(paren
l_string|&quot;%s: can&squot;t map PCI MEMORY region&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_goto
id|attach_failed
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *  Perform O/S independent stuff.&n;&t; */
r_if
c_cond
(paren
id|sym_hcb_attach
c_func
(paren
id|np
comma
id|fw
comma
id|dev-&gt;nvram
)paren
)paren
r_goto
id|attach_failed
suffix:semicolon
multiline_comment|/*&n;&t; *  Install the interrupt handler.&n;&t; *  If we synchonize the C code with SCRIPTS on interrupt, &n;&t; *  we donnot want to share the INTR line at all.&n;&t; */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;s.irq
comma
id|sym53c8xx_intr
comma
id|SA_SHIRQ
comma
id|NAME53C8XX
comma
id|np
)paren
)paren
(brace
id|printf_err
c_func
(paren
l_string|&quot;%s: request irq %d failure&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|dev-&gt;s.irq
)paren
suffix:semicolon
r_goto
id|attach_failed
suffix:semicolon
)brace
id|np-&gt;s.irq
op_assign
id|dev-&gt;s.irq
suffix:semicolon
multiline_comment|/*&n;&t; *  After SCSI devices have been opened, we cannot&n;&t; *  reset the bus safely, so we do it here.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
id|instance-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sym_reset_scsi_bus
c_func
(paren
id|np
comma
l_int|0
)paren
)paren
r_goto
id|reset_failed
suffix:semicolon
multiline_comment|/*&n;&t; *  Initialize some queue headers.&n;&t; */
id|sym_que_init
c_func
(paren
op_amp
id|np-&gt;s.wait_cmdq
)paren
suffix:semicolon
id|sym_que_init
c_func
(paren
op_amp
id|np-&gt;s.busy_cmdq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Start the SCRIPTS.&n;&t; */
id|sym_start_up
(paren
id|np
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Start the timer daemon&n;&t; */
id|init_timer
c_func
(paren
op_amp
id|np-&gt;s.timer
)paren
suffix:semicolon
id|np-&gt;s.timer.data
op_assign
(paren
r_int
r_int
)paren
id|np
suffix:semicolon
id|np-&gt;s.timer.function
op_assign
id|sym53c8xx_timer
suffix:semicolon
id|np-&gt;s.lasttime
op_assign
l_int|0
suffix:semicolon
id|sym_timer
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Fill Linux host instance structure&n;&t; *  and return success.&n;&t; */
id|instance-&gt;max_channel
op_assign
l_int|0
suffix:semicolon
id|instance-&gt;this_id
op_assign
id|np-&gt;myaddr
suffix:semicolon
id|instance-&gt;max_id
op_assign
id|np-&gt;maxwide
ques
c_cond
l_int|16
suffix:colon
l_int|8
suffix:semicolon
id|instance-&gt;max_lun
op_assign
id|SYM_CONF_MAX_LUN
suffix:semicolon
macro_line|#ifndef SYM_CONF_IOMAPPED
id|instance-&gt;base
op_assign
(paren
r_int
r_int
)paren
id|np-&gt;s.mmio_va
suffix:semicolon
macro_line|#endif
id|instance-&gt;irq
op_assign
id|np-&gt;s.irq
suffix:semicolon
id|instance-&gt;unique_id
op_assign
id|np-&gt;s.io_port
suffix:semicolon
id|instance-&gt;io_port
op_assign
id|np-&gt;s.io_port
suffix:semicolon
id|instance-&gt;n_io_port
op_assign
id|np-&gt;s.io_ws
suffix:semicolon
id|instance-&gt;dma_channel
op_assign
l_int|0
suffix:semicolon
id|instance-&gt;cmd_per_lun
op_assign
id|SYM_CONF_MAX_TAG
suffix:semicolon
id|instance-&gt;can_queue
op_assign
(paren
id|SYM_CONF_MAX_START
op_minus
l_int|2
)paren
suffix:semicolon
id|instance-&gt;sg_tablesize
op_assign
id|SYM_CONF_MAX_SG
suffix:semicolon
id|instance-&gt;max_cmd_len
op_assign
l_int|16
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|instance-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|instance
suffix:semicolon
id|reset_failed
suffix:colon
id|printf_err
c_func
(paren
l_string|&quot;%s: FATAL ERROR: CHECK SCSI BUS - CABLES, &quot;
l_string|&quot;TERMINATION, DEVICE POWER etc.!&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|instance-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|attach_failed
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|instance
)paren
r_return
l_int|NULL
suffix:semicolon
id|printf_info
c_func
(paren
l_string|&quot;%s: giving up ...&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np
)paren
id|sym_free_resources
c_func
(paren
id|np
)paren
suffix:semicolon
id|scsi_host_put
c_func
(paren
id|instance
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *    Detect and try to read SYMBIOS and TEKRAM NVRAM.&n; */
macro_line|#if SYM_CONF_NVRAM_SUPPORT
DECL|function|sym_get_nvram
r_static
r_void
id|__devinit
id|sym_get_nvram
c_func
(paren
r_struct
id|sym_device
op_star
id|devp
comma
r_struct
id|sym_nvram
op_star
id|nvp
)paren
(brace
id|devp-&gt;nvram
op_assign
id|nvp
suffix:semicolon
id|devp-&gt;device_id
op_assign
id|devp-&gt;chip.device_id
suffix:semicolon
id|nvp-&gt;type
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  Get access to chip IO registers&n;&t; */
macro_line|#ifndef SYM_CONF_IOMAPPED
id|devp-&gt;s.mmio_va
op_assign
id|ioremap
c_func
(paren
id|devp-&gt;s.base_c
comma
l_int|128
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devp-&gt;s.mmio_va
)paren
r_return
suffix:semicolon
macro_line|#endif
id|sym_read_nvram
c_func
(paren
id|devp
comma
id|nvp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Release access to chip IO registers&n;&t; */
macro_line|#ifndef SYM_CONF_IOMAPPED
id|iounmap
c_func
(paren
id|devp-&gt;s.mmio_va
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#else
DECL|function|sym_get_nvram
r_static
r_inline
r_void
id|sym_get_nvram
c_func
(paren
r_struct
id|sym_device
op_star
id|devp
comma
r_struct
id|sym_nvram
op_star
id|nvp
)paren
(brace
)brace
macro_line|#endif&t;/* SYM_CONF_NVRAM_SUPPORT */
multiline_comment|/*&n; *  Driver setup from the boot command line&n; */
macro_line|#ifdef&t;SYM_LINUX_BOOT_COMMAND_LINE_SUPPORT
r_static
r_struct
id|sym_driver_setup
DECL|variable|__initdata
id|sym_driver_safe_setup
id|__initdata
op_assign
id|SYM_LINUX_DRIVER_SAFE_SETUP
suffix:semicolon
macro_line|#ifdef&t;MODULE
DECL|variable|sym53c8xx
r_char
op_star
id|sym53c8xx
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* command line passed by insmod */
id|MODULE_PARM
c_func
(paren
id|sym53c8xx
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
macro_line|#endif
DECL|macro|OPT_MAX_TAG
mdefine_line|#define OPT_MAX_TAG&t;&t;1
DECL|macro|OPT_BURST_ORDER
mdefine_line|#define OPT_BURST_ORDER&t;&t;2
DECL|macro|OPT_SCSI_LED
mdefine_line|#define OPT_SCSI_LED&t;&t;3
DECL|macro|OPT_SCSI_DIFF
mdefine_line|#define OPT_SCSI_DIFF&t;&t;4
DECL|macro|OPT_IRQ_MODE
mdefine_line|#define OPT_IRQ_MODE&t;&t;5
DECL|macro|OPT_SCSI_BUS_CHECK
mdefine_line|#define OPT_SCSI_BUS_CHECK&t;6
DECL|macro|OPT_HOST_ID
mdefine_line|#define&t;OPT_HOST_ID&t;&t;7
DECL|macro|OPT_REVERSE_PROBE
mdefine_line|#define OPT_REVERSE_PROBE&t;8
DECL|macro|OPT_VERBOSE
mdefine_line|#define OPT_VERBOSE&t;&t;9
DECL|macro|OPT_DEBUG
mdefine_line|#define OPT_DEBUG&t;&t;10
DECL|macro|OPT_SETTLE_DELAY
mdefine_line|#define OPT_SETTLE_DELAY&t;11
DECL|macro|OPT_USE_NVRAM
mdefine_line|#define OPT_USE_NVRAM&t;&t;12
DECL|macro|OPT_EXCLUDE
mdefine_line|#define OPT_EXCLUDE&t;&t;13
DECL|macro|OPT_SAFE_SETUP
mdefine_line|#define OPT_SAFE_SETUP&t;&t;14
DECL|variable|__initdata
r_static
r_char
id|setup_token
(braket
)braket
id|__initdata
op_assign
l_string|&quot;tags:&quot;
l_string|&quot;burst:&quot;
l_string|&quot;led:&quot;
l_string|&quot;diff:&quot;
l_string|&quot;irqm:&quot;
l_string|&quot;buschk:&quot;
l_string|&quot;hostid:&quot;
l_string|&quot;revprob:&quot;
l_string|&quot;verb:&quot;
l_string|&quot;debug:&quot;
l_string|&quot;settle:&quot;
l_string|&quot;nvram:&quot;
l_string|&quot;excl:&quot;
l_string|&quot;safe:&quot;
suffix:semicolon
macro_line|#ifdef MODULE
DECL|macro|ARG_SEP
mdefine_line|#define&t;ARG_SEP&t;&squot; &squot;
macro_line|#else
DECL|macro|ARG_SEP
mdefine_line|#define&t;ARG_SEP&t;&squot;,&squot;
macro_line|#endif
DECL|function|get_setup_token
r_static
r_int
id|__init
id|get_setup_token
c_func
(paren
r_char
op_star
id|p
)paren
(brace
r_char
op_star
id|cur
op_assign
id|setup_token
suffix:semicolon
r_char
op_star
id|pc
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cur
op_ne
l_int|NULL
op_logical_and
(paren
id|pc
op_assign
id|strchr
c_func
(paren
id|cur
comma
l_char|&squot;:&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
op_increment
id|pc
suffix:semicolon
op_increment
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|p
comma
id|cur
comma
id|pc
op_minus
id|cur
)paren
)paren
r_return
id|i
suffix:semicolon
id|cur
op_assign
id|pc
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;/* SYM_LINUX_BOOT_COMMAND_LINE_SUPPORT */
DECL|function|sym53c8xx_setup
r_int
id|__init
id|sym53c8xx_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
macro_line|#ifdef&t;SYM_LINUX_BOOT_COMMAND_LINE_SUPPORT
r_char
op_star
id|cur
op_assign
id|str
suffix:semicolon
r_char
op_star
id|pc
comma
op_star
id|pv
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
r_int
id|i
comma
id|c
suffix:semicolon
r_int
id|xi
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cur
op_ne
l_int|NULL
op_logical_and
(paren
id|pc
op_assign
id|strchr
c_func
(paren
id|cur
comma
l_char|&squot;:&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_char
op_star
id|pe
suffix:semicolon
id|val
op_assign
l_int|0
suffix:semicolon
id|pv
op_assign
id|pc
suffix:semicolon
id|c
op_assign
op_star
op_increment
id|pv
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;n&squot;
)paren
id|val
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;y&squot;
)paren
id|val
op_assign
l_int|1
suffix:semicolon
r_else
id|val
op_assign
(paren
r_int
)paren
id|simple_strtoul
c_func
(paren
id|pv
comma
op_amp
id|pe
comma
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|get_setup_token
c_func
(paren
id|cur
)paren
)paren
(brace
r_case
id|OPT_MAX_TAG
suffix:colon
id|sym_driver_setup.max_tag
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pe
op_logical_and
op_star
id|pe
op_eq
l_char|&squot;/&squot;
)paren
)paren
r_break
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pe
op_logical_and
op_star
id|pe
op_ne
id|ARG_SEP
op_logical_and
id|i
OL
r_sizeof
(paren
id|sym_driver_setup.tag_ctrl
)paren
op_minus
l_int|1
)paren
(brace
id|sym_driver_setup.tag_ctrl
(braket
id|i
op_increment
)braket
op_assign
op_star
id|pe
op_increment
suffix:semicolon
)brace
id|sym_driver_setup.tag_ctrl
(braket
id|i
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_SAFE_SETUP
suffix:colon
id|memcpy
c_func
(paren
op_amp
id|sym_driver_setup
comma
op_amp
id|sym_driver_safe_setup
comma
r_sizeof
(paren
id|sym_driver_setup
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_EXCLUDE
suffix:colon
r_if
c_cond
(paren
id|xi
OL
l_int|8
)paren
id|sym_driver_setup.excludes
(braket
id|xi
op_increment
)braket
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
DECL|macro|__SIMPLE_OPTION
mdefine_line|#define __SIMPLE_OPTION(NAME, name) &bslash;&n;&t;&t;case OPT_ ## NAME :&t;&t;&bslash;&n;&t;&t;&t;sym_driver_setup.name = val;&bslash;&n;&t;&t;&t;break;
id|__SIMPLE_OPTION
c_func
(paren
id|BURST_ORDER
comma
id|burst_order
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|SCSI_LED
comma
id|scsi_led
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|SCSI_DIFF
comma
id|scsi_diff
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|IRQ_MODE
comma
id|irq_mode
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|SCSI_BUS_CHECK
comma
id|scsi_bus_check
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|HOST_ID
comma
id|host_id
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|REVERSE_PROBE
comma
id|reverse_probe
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|VERBOSE
comma
id|verbose
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|DEBUG
comma
id|debug
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|SETTLE_DELAY
comma
id|settle_delay
)paren
id|__SIMPLE_OPTION
c_func
(paren
id|USE_NVRAM
comma
id|use_nvram
)paren
DECL|macro|__SIMPLE_OPTION
macro_line|#undef __SIMPLE_OPTION
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;sym53c8xx_setup: unexpected boot option &squot;%.*s&squot; ignored&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|pc
op_minus
id|cur
op_plus
l_int|1
)paren
comma
id|cur
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|cur
op_assign
id|strchr
c_func
(paren
id|cur
comma
id|ARG_SEP
)paren
)paren
op_ne
l_int|NULL
)paren
op_increment
id|cur
suffix:semicolon
)brace
macro_line|#endif&t;/* SYM_LINUX_BOOT_COMMAND_LINE_SUPPORT */
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifndef MODULE
id|__setup
c_func
(paren
l_string|&quot;sym53c8xx=&quot;
comma
id|sym53c8xx_setup
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *  Read and check the PCI configuration for any detected NCR &n; *  boards and save data for attaching after all boards have &n; *  been detected.&n; */
r_static
r_int
id|__devinit
DECL|function|sym53c8xx_pci_init
id|sym53c8xx_pci_init
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_struct
id|sym_device
op_star
id|device
)paren
(brace
r_struct
id|sym_pci_chip
op_star
id|chip
suffix:semicolon
id|u_long
id|base
comma
id|base_2
suffix:semicolon
id|u_long
id|base_c
comma
id|base_2_c
comma
id|io_port
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u_short
id|device_id
comma
id|status_reg
suffix:semicolon
id|u_char
id|revision
suffix:semicolon
multiline_comment|/* Choose some short name for this device */
id|sprintf
c_func
(paren
id|device-&gt;s.inst_name
comma
l_string|&quot;sym.%d.%d.%d&quot;
comma
id|pdev-&gt;bus-&gt;number
comma
id|PCI_SLOT
c_func
(paren
id|pdev-&gt;devfn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|pdev-&gt;devfn
)paren
)paren
suffix:semicolon
id|device_id
op_assign
id|pdev-&gt;device
suffix:semicolon
id|io_port
op_assign
id|pdev-&gt;resource
(braket
l_int|0
)braket
dot
id|start
suffix:semicolon
id|base_c
op_assign
id|pdev-&gt;resource
(braket
l_int|1
)braket
dot
id|start
suffix:semicolon
id|i
op_assign
id|pci_get_base_address
c_func
(paren
id|pdev
comma
l_int|1
comma
op_amp
id|base
)paren
suffix:semicolon
id|base_2_c
op_assign
id|pdev-&gt;resource
(braket
id|i
)braket
dot
id|start
suffix:semicolon
id|pci_get_base_address
c_func
(paren
id|pdev
comma
id|i
comma
op_amp
id|base_2
)paren
suffix:semicolon
id|base
op_and_assign
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
id|base_2
op_and_assign
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
id|PCI_CLASS_REVISION
comma
op_amp
id|revision
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  If user excluded this chip, do not initialize it.&n;&t; */
r_if
c_cond
(paren
id|io_port
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sym_driver_setup.excludes
(braket
id|i
)braket
op_eq
id|io_port
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *  Check if the chip is supported.&n;&t; */
id|chip
op_assign
id|sym_lookup_pci_chip_table
c_func
(paren
id|device_id
comma
id|revision
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chip
)paren
(brace
id|printf_info
c_func
(paren
l_string|&quot;%s: device not supported&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Check if the chip has been assigned resources we need.&n;&t; *  XXX: can this still happen with Linux 2.6&squot;s PCI layer?&n;&t; */
macro_line|#ifdef SYM_CONF_IOMAPPED
r_if
c_cond
(paren
op_logical_neg
id|io_port
)paren
(brace
id|printf_info
c_func
(paren
l_string|&quot;%s: IO base address disabled.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
id|base
)paren
(brace
id|printf_info
c_func
(paren
l_string|&quot;%s: MMIO base address disabled.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; *  Ignore Symbios chips controlled by various RAID controllers.&n;&t; *  These controllers set value 0x52414944 at RAM end - 16.&n;&t; */
macro_line|#if defined(__i386__)
r_if
c_cond
(paren
id|base_2_c
)paren
(brace
r_int
r_int
id|ram_size
comma
id|ram_val
suffix:semicolon
r_void
op_star
id|ram_ptr
suffix:semicolon
r_if
c_cond
(paren
id|chip-&gt;features
op_amp
id|FE_RAM8K
)paren
id|ram_size
op_assign
l_int|8192
suffix:semicolon
r_else
id|ram_size
op_assign
l_int|4096
suffix:semicolon
id|ram_ptr
op_assign
id|ioremap
c_func
(paren
id|base_2_c
comma
id|ram_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ram_ptr
)paren
(brace
id|ram_val
op_assign
id|readl_raw
c_func
(paren
id|ram_ptr
op_plus
id|ram_size
op_minus
l_int|16
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|ram_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ram_val
op_eq
l_int|0x52414944
)paren
(brace
id|printf_info
c_func
(paren
l_string|&quot;%s: not initializing, &quot;
l_string|&quot;driven by RAID controller.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* i386 and PCI MEMORY accessible */
multiline_comment|/*&n;&t; *  Copy the chip description to our device structure, &n;&t; *  so we can make it match the actual device and options.&n;&t; */
id|memcpy
c_func
(paren
op_amp
id|device-&gt;chip
comma
id|chip
comma
r_sizeof
(paren
id|device-&gt;chip
)paren
)paren
suffix:semicolon
id|device-&gt;chip.revision_id
op_assign
id|revision
suffix:semicolon
multiline_comment|/*&n;&t; *  Some features are required to be enabled in order to &n;&t; *  work around some chip problems. :) ;)&n;&t; *  (ITEM 12 of a DEL about the 896 I haven&squot;t yet).&n;&t; *  We must ensure the chip will use WRITE AND INVALIDATE.&n;&t; *  The revision number limit is for now arbitrary.&n;&t; */
r_if
c_cond
(paren
id|device_id
op_eq
id|PCI_DEVICE_ID_NCR_53C896
op_logical_and
id|revision
OL
l_int|0x4
)paren
(brace
id|chip-&gt;features
op_or_assign
(paren
id|FE_WRIE
op_or
id|FE_CLSE
)paren
suffix:semicolon
)brace
multiline_comment|/* If the chip can do Memory Write Invalidate, enable it */
r_if
c_cond
(paren
id|chip-&gt;features
op_amp
id|FE_WRIE
)paren
(brace
r_if
c_cond
(paren
id|pci_set_mwi
c_func
(paren
id|pdev
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Work around for errant bit in 895A. The 66Mhz&n;&t; *  capable bit is set erroneously. Clear this bit.&n;&t; *  (Item 1 DEL 533)&n;&t; *&n;&t; *  Make sure Config space and Features agree.&n;&t; *&n;&t; *  Recall: writes are not normal to status register -&n;&t; *  write a 1 to clear and a 0 to leave unchanged.&n;&t; *  Can only reset bits.&n;&t; */
id|pci_read_config_word
c_func
(paren
id|pdev
comma
id|PCI_STATUS
comma
op_amp
id|status_reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chip-&gt;features
op_amp
id|FE_66MHZ
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|status_reg
op_amp
id|PCI_STATUS_66MHZ
)paren
)paren
id|chip-&gt;features
op_and_assign
op_complement
id|FE_66MHZ
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|status_reg
op_amp
id|PCI_STATUS_66MHZ
)paren
(brace
id|status_reg
op_assign
id|PCI_STATUS_66MHZ
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|pdev
comma
id|PCI_STATUS
comma
id|status_reg
)paren
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|pdev
comma
id|PCI_STATUS
comma
op_amp
id|status_reg
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *  Initialise device structure with items required by sym_attach.&n;&t; */
id|device-&gt;pdev
op_assign
id|pdev
suffix:semicolon
id|device-&gt;s.base
op_assign
id|base
suffix:semicolon
id|device-&gt;s.base_2
op_assign
id|base_2
suffix:semicolon
id|device-&gt;s.base_c
op_assign
id|base_c
suffix:semicolon
id|device-&gt;s.base_2_c
op_assign
id|base_2_c
suffix:semicolon
id|device-&gt;s.io_port
op_assign
id|io_port
suffix:semicolon
id|device-&gt;s.irq
op_assign
id|pdev-&gt;irq
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Called before unloading the module.&n; *  Detach the host.&n; *  We have to free resources and halt the NCR chip.&n; */
DECL|function|sym_detach
r_static
r_int
id|sym_detach
c_func
(paren
r_struct
id|sym_hcb
op_star
id|np
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: detaching ...&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|np-&gt;s.timer
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reset NCR chip.&n;&t; * We should use sym_soft_reset(), but we don&squot;t want to do &n;&t; * so, since we may not be safe if interrupts occur.&n;&t; */
id|printk
c_func
(paren
l_string|&quot;%s: resetting chip&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|10
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
id|sym_free_resources
c_func
(paren
id|np
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;Dual BSD/GPL&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * Driver host template.&n; */
DECL|variable|sym2_template
r_static
r_struct
id|scsi_host_template
id|sym2_template
op_assign
(brace
dot
id|module
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;sym53c8xx&quot;
comma
dot
id|info
op_assign
id|sym53c8xx_info
comma
dot
id|queuecommand
op_assign
id|sym53c8xx_queue_command
comma
dot
id|slave_configure
op_assign
id|sym53c8xx_slave_configure
comma
dot
id|eh_abort_handler
op_assign
id|sym53c8xx_eh_abort_handler
comma
dot
id|eh_device_reset_handler
op_assign
id|sym53c8xx_eh_device_reset_handler
comma
dot
id|eh_bus_reset_handler
op_assign
id|sym53c8xx_eh_bus_reset_handler
comma
dot
id|eh_host_reset_handler
op_assign
id|sym53c8xx_eh_host_reset_handler
comma
dot
id|this_id
op_assign
l_int|7
comma
dot
id|use_clustering
op_assign
id|DISABLE_CLUSTERING
comma
macro_line|#ifdef SYM_LINUX_PROC_INFO_SUPPORT
dot
id|proc_info
op_assign
id|sym53c8xx_proc_info
comma
dot
id|proc_name
op_assign
id|NAME53C8XX
comma
macro_line|#endif
)brace
suffix:semicolon
macro_line|#ifdef _SYM_CONF_PQS_PDS_SUPPORT
macro_line|#if 0
multiline_comment|/*&n; *  Detect all NCR PQS/PDS boards and keep track of their bus nr.&n; *&n; *  The NCR PQS or PDS card is constructed as a DEC bridge&n; *  behind which sit a proprietary NCR memory controller and&n; *  four or two 53c875s as separate devices.  In its usual mode&n; *  of operation, the 875s are slaved to the memory controller&n; *  for all transfers.  We can tell if an 875 is part of a&n; *  PQS/PDS or not since if it is, it will be on the same bus&n; *  as the memory controller.  To operate with the Linux&n; *  driver, the memory controller is disabled and the 875s&n; *  freed to function independently.  The only wrinkle is that&n; *  the preset SCSI ID (which may be zero) must be read in from&n; *  a special configuration space register of the 875&n; */
macro_line|#ifndef SYM_CONF_MAX_PQS_BUS
mdefine_line|#define SYM_CONF_MAX_PQS_BUS 16
macro_line|#endif
r_static
r_int
id|pqs_bus
(braket
id|SYM_CONF_MAX_PQS_BUS
)braket
id|__initdata
op_assign
(brace
l_int|0
)brace
suffix:semicolon
r_static
r_void
id|__init
id|sym_detect_pqs_pds
c_func
(paren
r_void
)paren
(brace
r_int
id|index
suffix:semicolon
r_struct
id|pci_dev
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|SYM_CONF_MAX_PQS_BUS
suffix:semicolon
id|index
op_increment
)paren
(brace
id|u_char
id|tmp
suffix:semicolon
id|dev
op_assign
id|pci_find_device
c_func
(paren
l_int|0x101a
comma
l_int|0x0009
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|pqs_bus
(braket
id|index
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printf_info
c_func
(paren
id|NAME53C8XX
l_string|&quot;: NCR PQS/PDS memory controller detected on bus %d&bslash;n&quot;
comma
id|dev-&gt;bus-&gt;number
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|dev
comma
l_int|0x44
comma
op_amp
id|tmp
)paren
suffix:semicolon
multiline_comment|/* bit 1: allow individual 875 configuration */
id|tmp
op_or_assign
l_int|0x2
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|dev
comma
l_int|0x44
comma
id|tmp
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|dev
comma
l_int|0x45
comma
op_amp
id|tmp
)paren
suffix:semicolon
multiline_comment|/* bit 2: drive individual 875 interrupts to the bus */
id|tmp
op_or_assign
l_int|0x4
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|dev
comma
l_int|0x45
comma
id|tmp
)paren
suffix:semicolon
id|pqs_bus
(braket
id|index
)braket
op_assign
id|dev-&gt;bus-&gt;number
suffix:semicolon
)brace
)brace
macro_line|#endif
DECL|function|pqs_probe
r_static
r_int
id|pqs_probe
c_func
(paren
)paren
(brace
)brace
DECL|function|pqs_remove
r_static
r_void
id|pqs_remove
c_func
(paren
)paren
(brace
)brace
DECL|variable|__devinitdata
r_static
r_struct
id|pci_device_id
id|pqs_id_table
(braket
)braket
id|__devinitdata
op_assign
(brace
(brace
l_int|0x101a
comma
l_int|0x0009
comma
)brace
comma
(brace
l_int|0
comma
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|pci
comma
id|pqs_id_table
)paren
suffix:semicolon
DECL|variable|pqs_driver
r_static
r_struct
id|pci_driver
id|pqs_driver
op_assign
(brace
dot
id|name
op_assign
id|NAME53C8XX
l_string|&quot; (PQS)&quot;
comma
dot
id|id_table
op_assign
id|pqs_id_table
comma
dot
id|probe
op_assign
id|pqs_probe
comma
dot
id|remove
op_assign
id|__devexit_p
c_func
(paren
id|pqs_remove
)paren
comma
)brace
suffix:semicolon
macro_line|#endif /* PQS */
DECL|variable|attach_count
r_static
r_int
id|attach_count
suffix:semicolon
DECL|function|sym2_probe
r_static
r_int
id|__devinit
id|sym2_probe
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_const
r_struct
id|pci_device_id
op_star
id|ent
)paren
(brace
r_struct
id|sym_device
id|sym_dev
suffix:semicolon
r_struct
id|sym_nvram
id|nvram
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|instance
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|sym_dev
comma
l_int|0
comma
r_sizeof
(paren
id|sym_dev
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|nvram
comma
l_int|0
comma
r_sizeof
(paren
id|nvram
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|pdev
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|pci_set_master
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_request_regions
c_func
(paren
id|pdev
comma
id|NAME53C8XX
)paren
)paren
r_goto
id|disable
suffix:semicolon
id|sym_dev.host_id
op_assign
id|SYM_SETUP_HOST_ID
suffix:semicolon
r_if
c_cond
(paren
id|sym53c8xx_pci_init
c_func
(paren
id|pdev
comma
op_amp
id|sym_dev
)paren
)paren
r_goto
id|free
suffix:semicolon
id|sym_get_nvram
c_func
(paren
op_amp
id|sym_dev
comma
op_amp
id|nvram
)paren
suffix:semicolon
id|instance
op_assign
id|sym_attach
c_func
(paren
op_amp
id|sym2_template
comma
id|attach_count
comma
op_amp
id|sym_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|instance
)paren
r_goto
id|free
suffix:semicolon
r_if
c_cond
(paren
id|scsi_add_host
c_func
(paren
id|instance
comma
op_amp
id|pdev-&gt;dev
)paren
)paren
r_goto
id|detach
suffix:semicolon
id|scsi_scan_host
c_func
(paren
id|instance
)paren
suffix:semicolon
id|attach_count
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|detach
suffix:colon
id|sym_detach
c_func
(paren
id|pci_get_drvdata
c_func
(paren
id|pdev
)paren
)paren
suffix:semicolon
id|free
suffix:colon
id|pci_release_regions
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|disable
suffix:colon
id|pci_disable_device
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|sym2_remove
r_static
r_void
id|__devexit
id|sym2_remove
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
r_struct
id|sym_hcb
op_star
id|np
op_assign
id|pci_get_drvdata
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|np-&gt;s.host
suffix:semicolon
id|scsi_remove_host
c_func
(paren
id|host
)paren
suffix:semicolon
id|scsi_host_put
c_func
(paren
id|host
)paren
suffix:semicolon
id|sym_detach
c_func
(paren
id|np
)paren
suffix:semicolon
id|pci_release_regions
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|pci_disable_device
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|attach_count
op_decrement
suffix:semicolon
)brace
DECL|variable|__devinitdata
r_static
r_struct
id|pci_device_id
id|sym2_id_table
(braket
)braket
id|__devinitdata
op_assign
(brace
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_NCR_53C810
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_NCR_53C820
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
multiline_comment|/* new */
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_NCR_53C825
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_NCR_53C815
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_LSI_53C810AP
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
multiline_comment|/* new */
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_NCR_53C860
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_LSI_53C1510
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_NCR_53C896
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_NCR_53C895
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_NCR_53C885
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_NCR_53C875
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_NCR_53C1510
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
multiline_comment|/* new */
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_LSI_53C895A
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_LSI_53C875A
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_LSI_53C1010_33
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_LSI_53C1010_66
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_NCR_53C875J
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
l_int|0UL
)brace
comma
(brace
l_int|0
comma
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|pci
comma
id|sym2_id_table
)paren
suffix:semicolon
DECL|variable|sym2_driver
r_static
r_struct
id|pci_driver
id|sym2_driver
op_assign
(brace
dot
id|name
op_assign
id|NAME53C8XX
comma
dot
id|id_table
op_assign
id|sym2_id_table
comma
dot
id|probe
op_assign
id|sym2_probe
comma
dot
id|remove
op_assign
id|__devexit_p
c_func
(paren
id|sym2_remove
)paren
comma
)brace
suffix:semicolon
DECL|function|sym2_init
r_static
r_int
id|__init
id|sym2_init
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef _SYM_CONF_PQS_PDS_SUPPORT
id|pci_register_driver
c_func
(paren
op_amp
id|pqs_driver
)paren
suffix:semicolon
macro_line|#endif
id|pci_register_driver
c_func
(paren
op_amp
id|sym2_driver
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sym2_exit
r_static
r_void
id|__exit
id|sym2_exit
c_func
(paren
r_void
)paren
(brace
id|pci_unregister_driver
c_func
(paren
op_amp
id|sym2_driver
)paren
suffix:semicolon
macro_line|#ifdef _SYM_CONF_PQS_PDS_SUPPORT
id|pci_unregister_driver
c_func
(paren
op_amp
id|pqs_driver
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|variable|sym2_init
id|module_init
c_func
(paren
id|sym2_init
)paren
suffix:semicolon
DECL|variable|sym2_exit
id|module_exit
c_func
(paren
id|sym2_exit
)paren
suffix:semicolon
eof
