multiline_comment|/*&n; * Device driver for the SYMBIOS/LSILOGIC 53C8XX and 53C1010 family &n; * of PCI-SCSI IO processors.&n; *&n; * Copyright (C) 1999-2001  Gerard Roudier &lt;groudier@free.fr&gt;&n; *&n; * This driver is derived from the Linux sym53c8xx driver.&n; * Copyright (C) 1998-2000  Gerard Roudier&n; *&n; * The sym53c8xx driver is derived from the ncr53c8xx driver that had been &n; * a port of the FreeBSD ncr driver to Linux-1.2.13.&n; *&n; * The original ncr driver has been written for 386bsd and FreeBSD by&n; *         Wolfgang Stanglmeier        &lt;wolf@cologne.de&gt;&n; *         Stefan Esser                &lt;se@mi.Uni-Koeln.de&gt;&n; * Copyright (C) 1994  Wolfgang Stanglmeier&n; *&n; * Other major contributions:&n; *&n; * NVRAM detection and reading.&n; * Copyright (C) 1997 Richard Waltham &lt;dormouse@farsrobt.demon.co.uk&gt;&n; *&n; *-----------------------------------------------------------------------------&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions and the following disclaimer.&n; * 2. The name of the author may not be used to endorse or promote products&n; *    derived from this software without specific prior written permission.&n; *&n; * Where this Software is combined with software released under the terms of &n; * the GNU Public License (&quot;GPL&quot;) and the terms of the GPL would require the &n; * combined work to also be released under the terms of the GPL, the terms&n; * and conditions of this License will apply in addition to those of the&n; * GPL with the exception of any terms or conditions of this License that&n; * conflict with, or are expressly prohibited by, the GPL.&n; *&n; * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS&squot;&squot; AND&n; * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE&n; * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE&n; * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR&n; * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS&n; * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT&n; * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY&n; * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF&n; * SUCH DAMAGE.&n; */
macro_line|#ifndef SYM_MISC_H
DECL|macro|SYM_MISC_H
mdefine_line|#define SYM_MISC_H
multiline_comment|/*&n; *  A la VMS/CAM-3 queue management.&n; */
DECL|struct|sym_quehead
r_typedef
r_struct
id|sym_quehead
(brace
DECL|member|flink
r_struct
id|sym_quehead
op_star
id|flink
suffix:semicolon
multiline_comment|/* Forward  pointer */
DECL|member|blink
r_struct
id|sym_quehead
op_star
id|blink
suffix:semicolon
multiline_comment|/* Backward pointer */
DECL|typedef|SYM_QUEHEAD
)brace
id|SYM_QUEHEAD
suffix:semicolon
DECL|macro|sym_que_init
mdefine_line|#define sym_que_init(ptr) do { &bslash;&n;&t;(ptr)-&gt;flink = (ptr); (ptr)-&gt;blink = (ptr); &bslash;&n;} while (0)
DECL|function|sym_que_first
r_static
id|__inline
r_struct
id|sym_quehead
op_star
id|sym_que_first
c_func
(paren
r_struct
id|sym_quehead
op_star
id|head
)paren
(brace
r_return
(paren
id|head-&gt;flink
op_eq
id|head
)paren
ques
c_cond
l_int|0
suffix:colon
id|head-&gt;flink
suffix:semicolon
)brace
DECL|function|sym_que_last
r_static
id|__inline
r_struct
id|sym_quehead
op_star
id|sym_que_last
c_func
(paren
r_struct
id|sym_quehead
op_star
id|head
)paren
(brace
r_return
(paren
id|head-&gt;blink
op_eq
id|head
)paren
ques
c_cond
l_int|0
suffix:colon
id|head-&gt;blink
suffix:semicolon
)brace
DECL|function|__sym_que_add
r_static
id|__inline
r_void
id|__sym_que_add
c_func
(paren
r_struct
id|sym_quehead
op_star
r_new
comma
r_struct
id|sym_quehead
op_star
id|blink
comma
r_struct
id|sym_quehead
op_star
id|flink
)paren
(brace
id|flink-&gt;blink
op_assign
r_new
suffix:semicolon
r_new
op_member_access_from_pointer
id|flink
op_assign
id|flink
suffix:semicolon
r_new
op_member_access_from_pointer
id|blink
op_assign
id|blink
suffix:semicolon
id|blink-&gt;flink
op_assign
r_new
suffix:semicolon
)brace
DECL|function|__sym_que_del
r_static
id|__inline
r_void
id|__sym_que_del
c_func
(paren
r_struct
id|sym_quehead
op_star
id|blink
comma
r_struct
id|sym_quehead
op_star
id|flink
)paren
(brace
id|flink-&gt;blink
op_assign
id|blink
suffix:semicolon
id|blink-&gt;flink
op_assign
id|flink
suffix:semicolon
)brace
DECL|function|sym_que_empty
r_static
id|__inline
r_int
id|sym_que_empty
c_func
(paren
r_struct
id|sym_quehead
op_star
id|head
)paren
(brace
r_return
id|head-&gt;flink
op_eq
id|head
suffix:semicolon
)brace
DECL|function|sym_que_splice
r_static
id|__inline
r_void
id|sym_que_splice
c_func
(paren
r_struct
id|sym_quehead
op_star
id|list
comma
r_struct
id|sym_quehead
op_star
id|head
)paren
(brace
r_struct
id|sym_quehead
op_star
id|first
op_assign
id|list-&gt;flink
suffix:semicolon
r_if
c_cond
(paren
id|first
op_ne
id|list
)paren
(brace
r_struct
id|sym_quehead
op_star
id|last
op_assign
id|list-&gt;blink
suffix:semicolon
r_struct
id|sym_quehead
op_star
id|at
op_assign
id|head-&gt;flink
suffix:semicolon
id|first-&gt;blink
op_assign
id|head
suffix:semicolon
id|head-&gt;flink
op_assign
id|first
suffix:semicolon
id|last-&gt;flink
op_assign
id|at
suffix:semicolon
id|at-&gt;blink
op_assign
id|last
suffix:semicolon
)brace
)brace
DECL|function|sym_que_move
r_static
id|__inline
r_void
id|sym_que_move
c_func
(paren
r_struct
id|sym_quehead
op_star
id|orig
comma
r_struct
id|sym_quehead
op_star
id|dest
)paren
(brace
r_struct
id|sym_quehead
op_star
id|first
comma
op_star
id|last
suffix:semicolon
id|first
op_assign
id|orig-&gt;flink
suffix:semicolon
r_if
c_cond
(paren
id|first
op_ne
id|orig
)paren
(brace
id|first-&gt;blink
op_assign
id|dest
suffix:semicolon
id|dest-&gt;flink
op_assign
id|first
suffix:semicolon
id|last
op_assign
id|orig-&gt;blink
suffix:semicolon
id|last-&gt;flink
op_assign
id|dest
suffix:semicolon
id|dest-&gt;blink
op_assign
id|last
suffix:semicolon
id|orig-&gt;flink
op_assign
id|orig
suffix:semicolon
id|orig-&gt;blink
op_assign
id|orig
suffix:semicolon
)brace
r_else
(brace
id|dest-&gt;flink
op_assign
id|dest
suffix:semicolon
id|dest-&gt;blink
op_assign
id|dest
suffix:semicolon
)brace
)brace
DECL|macro|sym_que_entry
mdefine_line|#define sym_que_entry(ptr, type, member) &bslash;&n;&t;((type *)((char *)(ptr)-(unsigned int)(&amp;((type *)0)-&gt;member)))
DECL|macro|sym_insque
mdefine_line|#define sym_insque(new, pos)&t;&t;__sym_que_add(new, pos, (pos)-&gt;flink)
DECL|macro|sym_remque
mdefine_line|#define sym_remque(el)&t;&t;&t;__sym_que_del((el)-&gt;blink, (el)-&gt;flink)
DECL|macro|sym_insque_head
mdefine_line|#define sym_insque_head(new, head)&t;__sym_que_add(new, head, (head)-&gt;flink)
DECL|function|sym_remque_head
r_static
id|__inline
r_struct
id|sym_quehead
op_star
id|sym_remque_head
c_func
(paren
r_struct
id|sym_quehead
op_star
id|head
)paren
(brace
r_struct
id|sym_quehead
op_star
id|elem
op_assign
id|head-&gt;flink
suffix:semicolon
r_if
c_cond
(paren
id|elem
op_ne
id|head
)paren
id|__sym_que_del
c_func
(paren
id|head
comma
id|elem-&gt;flink
)paren
suffix:semicolon
r_else
id|elem
op_assign
l_int|NULL
suffix:semicolon
r_return
id|elem
suffix:semicolon
)brace
DECL|macro|sym_insque_tail
mdefine_line|#define sym_insque_tail(new, head)&t;__sym_que_add(new, (head)-&gt;blink, head)
DECL|function|sym_remque_tail
r_static
id|__inline
r_struct
id|sym_quehead
op_star
id|sym_remque_tail
c_func
(paren
r_struct
id|sym_quehead
op_star
id|head
)paren
(brace
r_struct
id|sym_quehead
op_star
id|elem
op_assign
id|head-&gt;blink
suffix:semicolon
r_if
c_cond
(paren
id|elem
op_ne
id|head
)paren
id|__sym_que_del
c_func
(paren
id|elem-&gt;blink
comma
id|head
)paren
suffix:semicolon
r_else
id|elem
op_assign
l_int|0
suffix:semicolon
r_return
id|elem
suffix:semicolon
)brace
multiline_comment|/*&n; *  This one may be useful.&n; */
DECL|macro|FOR_EACH_QUEUED_ELEMENT
mdefine_line|#define FOR_EACH_QUEUED_ELEMENT(head, qp) &bslash;&n;&t;for (qp = (head)-&gt;flink; qp != (head); qp = qp-&gt;flink)
multiline_comment|/*&n; *  FreeBSD does not offer our kind of queue in the CAM CCB.&n; *  So, we have to cast.&n; */
DECL|macro|sym_qptr
mdefine_line|#define sym_qptr(p)&t;((struct sym_quehead *) (p))
multiline_comment|/*&n; *  Simple bitmap operations.&n; */
DECL|macro|sym_set_bit
mdefine_line|#define sym_set_bit(p, n)&t;(((u32 *)(p))[(n)&gt;&gt;5] |=  (1&lt;&lt;((n)&amp;0x1f)))
DECL|macro|sym_clr_bit
mdefine_line|#define sym_clr_bit(p, n)&t;(((u32 *)(p))[(n)&gt;&gt;5] &amp;= ~(1&lt;&lt;((n)&amp;0x1f)))
DECL|macro|sym_is_bit
mdefine_line|#define sym_is_bit(p, n)&t;(((u32 *)(p))[(n)&gt;&gt;5] &amp;   (1&lt;&lt;((n)&amp;0x1f)))
multiline_comment|/*&n; * The below round up/down macros are to be used with a constant &n; * as argument (sizeof(...) for example), for the compiler to &n; * optimize the whole thing.&n; */
DECL|macro|_U_
mdefine_line|#define _U_(a,m)&t;(a)&lt;=(1&lt;&lt;m)?m:
multiline_comment|/*&n; * Round up logarithm to base 2 of a 16 bit constant.&n; */
DECL|macro|_LGRU16_
mdefine_line|#define _LGRU16_(a) &bslash;&n;( &bslash;&n; _U_(a, 0)_U_(a, 1)_U_(a, 2)_U_(a, 3)_U_(a, 4)_U_(a, 5)_U_(a, 6)_U_(a, 7) &bslash;&n; _U_(a, 8)_U_(a, 9)_U_(a,10)_U_(a,11)_U_(a,12)_U_(a,13)_U_(a,14)_U_(a,15) &bslash;&n; 16)
macro_line|#endif /* SYM_MISC_H */
eof
