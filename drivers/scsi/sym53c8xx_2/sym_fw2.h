multiline_comment|/*&n; * Device driver for the SYMBIOS/LSILOGIC 53C8XX and 53C1010 family &n; * of PCI-SCSI IO processors.&n; *&n; * Copyright (C) 1999-2001  Gerard Roudier &lt;groudier@free.fr&gt;&n; *&n; * This driver is derived from the Linux sym53c8xx driver.&n; * Copyright (C) 1998-2000  Gerard Roudier&n; *&n; * The sym53c8xx driver is derived from the ncr53c8xx driver that had been &n; * a port of the FreeBSD ncr driver to Linux-1.2.13.&n; *&n; * The original ncr driver has been written for 386bsd and FreeBSD by&n; *         Wolfgang Stanglmeier        &lt;wolf@cologne.de&gt;&n; *         Stefan Esser                &lt;se@mi.Uni-Koeln.de&gt;&n; * Copyright (C) 1994  Wolfgang Stanglmeier&n; *&n; * Other major contributions:&n; *&n; * NVRAM detection and reading.&n; * Copyright (C) 1997 Richard Waltham &lt;dormouse@farsrobt.demon.co.uk&gt;&n; *&n; *-----------------------------------------------------------------------------&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions and the following disclaimer.&n; * 2. The name of the author may not be used to endorse or promote products&n; *    derived from this software without specific prior written permission.&n; *&n; * Where this Software is combined with software released under the terms of &n; * the GNU Public License (&quot;GPL&quot;) and the terms of the GPL would require the &n; * combined work to also be released under the terms of the GPL, the terms&n; * and conditions of this License will apply in addition to those of the&n; * GPL with the exception of any terms or conditions of this License that&n; * conflict with, or are expressly prohibited by, the GPL.&n; *&n; * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS&squot;&squot; AND&n; * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE&n; * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE&n; * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR&n; * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS&n; * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT&n; * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY&n; * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF&n; * SUCH DAMAGE.&n; */
multiline_comment|/*&n; *  Scripts for SYMBIOS-Processor&n; *&n; *  We have to know the offsets of all labels before we reach &n; *  them (for forward jumps). Therefore we declare a struct &n; *  here. If you make changes inside the script,&n; *&n; *  DONT FORGET TO CHANGE THE LENGTHS HERE!&n; */
multiline_comment|/*&n; *  Script fragments which are loaded into the on-chip RAM &n; *  of 825A, 875, 876, 895, 895A, 896 and 1010 chips.&n; *  Must not exceed 4K bytes.&n; */
DECL|struct|SYM_FWA_SCR
r_struct
id|SYM_FWA_SCR
(brace
DECL|member|start
id|u32
id|start
(braket
l_int|14
)braket
suffix:semicolon
DECL|member|getjob_begin
id|u32
id|getjob_begin
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|getjob_end
id|u32
id|getjob_end
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#ifdef SYM_CONF_TARGET_ROLE_SUPPORT
DECL|member|select
id|u32
id|select
(braket
l_int|6
)braket
suffix:semicolon
macro_line|#else
DECL|member|select
id|u32
id|select
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#endif
macro_line|#if&t;SYM_CONF_DMA_ADDRESSING_MODE == 2
DECL|member|is_dmap_dirty
id|u32
id|is_dmap_dirty
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#endif
DECL|member|wf_sel_done
id|u32
id|wf_sel_done
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|sel_done
id|u32
id|sel_done
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|send_ident
id|u32
id|send_ident
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#ifdef SYM_CONF_IARB_SUPPORT
DECL|member|select2
id|u32
id|select2
(braket
l_int|8
)braket
suffix:semicolon
macro_line|#else
DECL|member|select2
id|u32
id|select2
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#endif
DECL|member|command
id|u32
id|command
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|dispatch
id|u32
id|dispatch
(braket
l_int|28
)braket
suffix:semicolon
DECL|member|sel_no_cmd
id|u32
id|sel_no_cmd
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|init
id|u32
id|init
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|clrack
id|u32
id|clrack
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|datai_done
id|u32
id|datai_done
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|datai_done_wsr
id|u32
id|datai_done_wsr
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|datao_done
id|u32
id|datao_done
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|datao_done_wss
id|u32
id|datao_done_wss
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|datai_phase
id|u32
id|datai_phase
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|datao_phase
id|u32
id|datao_phase
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|msg_in
id|u32
id|msg_in
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|msg_in2
id|u32
id|msg_in2
(braket
l_int|10
)braket
suffix:semicolon
macro_line|#ifdef SYM_CONF_IARB_SUPPORT
DECL|member|status
id|u32
id|status
(braket
l_int|14
)braket
suffix:semicolon
macro_line|#else
DECL|member|status
id|u32
id|status
(braket
l_int|10
)braket
suffix:semicolon
macro_line|#endif
DECL|member|complete
id|u32
id|complete
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|complete2
id|u32
id|complete2
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|done
id|u32
id|done
(braket
l_int|14
)braket
suffix:semicolon
DECL|member|done_end
id|u32
id|done_end
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|complete_error
id|u32
id|complete_error
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|save_dp
id|u32
id|save_dp
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|restore_dp
id|u32
id|restore_dp
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|disconnect
id|u32
id|disconnect
(braket
l_int|12
)braket
suffix:semicolon
macro_line|#ifdef SYM_CONF_IARB_SUPPORT
DECL|member|idle
id|u32
id|idle
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#else
DECL|member|idle
id|u32
id|idle
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SYM_CONF_IARB_SUPPORT
DECL|member|ungetjob
id|u32
id|ungetjob
(braket
l_int|6
)braket
suffix:semicolon
macro_line|#else
DECL|member|ungetjob
id|u32
id|ungetjob
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SYM_CONF_TARGET_ROLE_SUPPORT
DECL|member|reselect
id|u32
id|reselect
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#else
DECL|member|reselect
id|u32
id|reselect
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#endif
DECL|member|reselected
id|u32
id|reselected
(braket
l_int|22
)braket
suffix:semicolon
DECL|member|resel_scntl4
id|u32
id|resel_scntl4
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|resel_lun0
id|u32
id|resel_lun0
(braket
l_int|6
)braket
suffix:semicolon
macro_line|#if   SYM_CONF_MAX_TASK*4 &gt; 512
DECL|member|resel_tag
id|u32
id|resel_tag
(braket
l_int|26
)braket
suffix:semicolon
macro_line|#elif SYM_CONF_MAX_TASK*4 &gt; 256
DECL|member|resel_tag
id|u32
id|resel_tag
(braket
l_int|20
)braket
suffix:semicolon
macro_line|#else
DECL|member|resel_tag
id|u32
id|resel_tag
(braket
l_int|16
)braket
suffix:semicolon
macro_line|#endif
DECL|member|resel_dsa
id|u32
id|resel_dsa
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|resel_dsa1
id|u32
id|resel_dsa1
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|resel_no_tag
id|u32
id|resel_no_tag
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|data_in
id|u32
id|data_in
(braket
id|SYM_CONF_MAX_SG
op_star
l_int|2
)braket
suffix:semicolon
DECL|member|data_in2
id|u32
id|data_in2
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|data_out
id|u32
id|data_out
(braket
id|SYM_CONF_MAX_SG
op_star
l_int|2
)braket
suffix:semicolon
DECL|member|data_out2
id|u32
id|data_out2
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|pm0_data
id|u32
id|pm0_data
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|pm0_data_out
id|u32
id|pm0_data_out
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|pm0_data_end
id|u32
id|pm0_data_end
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|pm1_data
id|u32
id|pm1_data
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|pm1_data_out
id|u32
id|pm1_data_out
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|pm1_data_end
id|u32
id|pm1_data_end
(braket
l_int|6
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; *  Script fragments which stay in main memory for all chips &n; *  except for chips that support 8K on-chip RAM.&n; */
DECL|struct|SYM_FWB_SCR
r_struct
id|SYM_FWB_SCR
(brace
DECL|member|start64
id|u32
id|start64
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|no_data
id|u32
id|no_data
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#ifdef SYM_CONF_TARGET_ROLE_SUPPORT
DECL|member|sel_for_abort
id|u32
id|sel_for_abort
(braket
l_int|18
)braket
suffix:semicolon
macro_line|#else
DECL|member|sel_for_abort
id|u32
id|sel_for_abort
(braket
l_int|16
)braket
suffix:semicolon
macro_line|#endif
DECL|member|sel_for_abort_1
id|u32
id|sel_for_abort_1
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|msg_in_etc
id|u32
id|msg_in_etc
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|msg_received
id|u32
id|msg_received
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|msg_weird_seen
id|u32
id|msg_weird_seen
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|msg_extended
id|u32
id|msg_extended
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|msg_bad
id|u32
id|msg_bad
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|msg_weird
id|u32
id|msg_weird
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|msg_weird1
id|u32
id|msg_weird1
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|wdtr_resp
id|u32
id|wdtr_resp
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|send_wdtr
id|u32
id|send_wdtr
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|sdtr_resp
id|u32
id|sdtr_resp
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|send_sdtr
id|u32
id|send_sdtr
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|ppr_resp
id|u32
id|ppr_resp
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|send_ppr
id|u32
id|send_ppr
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|nego_bad_phase
id|u32
id|nego_bad_phase
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|msg_out
id|u32
id|msg_out
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|msg_out_done
id|u32
id|msg_out_done
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|data_ovrun
id|u32
id|data_ovrun
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|data_ovrun1
id|u32
id|data_ovrun1
(braket
l_int|22
)braket
suffix:semicolon
DECL|member|data_ovrun2
id|u32
id|data_ovrun2
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|abort_resel
id|u32
id|abort_resel
(braket
l_int|16
)braket
suffix:semicolon
DECL|member|resend_ident
id|u32
id|resend_ident
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|ident_break
id|u32
id|ident_break
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|ident_break_atn
id|u32
id|ident_break_atn
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|sdata_in
id|u32
id|sdata_in
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|resel_bad_lun
id|u32
id|resel_bad_lun
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|bad_i_t_l
id|u32
id|bad_i_t_l
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|bad_i_t_l_q
id|u32
id|bad_i_t_l_q
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|bad_status
id|u32
id|bad_status
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|pm_handle
id|u32
id|pm_handle
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|pm_handle1
id|u32
id|pm_handle1
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|pm_save
id|u32
id|pm_save
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|pm0_save
id|u32
id|pm0_save
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|pm_save_end
id|u32
id|pm_save_end
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|pm1_save
id|u32
id|pm1_save
(braket
l_int|14
)braket
suffix:semicolon
multiline_comment|/* WSR handling */
DECL|member|pm_wsr_handle
id|u32
id|pm_wsr_handle
(braket
l_int|38
)braket
suffix:semicolon
DECL|member|wsr_ma_helper
id|u32
id|wsr_ma_helper
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#ifdef SYM_OPT_HANDLE_DIR_UNKNOWN
multiline_comment|/* Unknown direction handling */
DECL|member|data_io
id|u32
id|data_io
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|data_io_in
id|u32
id|data_io_in
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|data_io_com
id|u32
id|data_io_com
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|data_io_out
id|u32
id|data_io_out
(braket
l_int|8
)braket
suffix:semicolon
macro_line|#endif
multiline_comment|/* Data area */
DECL|member|zero
id|u32
id|zero
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|scratch
id|u32
id|scratch
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|pm0_data_addr
id|u32
id|pm0_data_addr
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|pm1_data_addr
id|u32
id|pm1_data_addr
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|done_pos
id|u32
id|done_pos
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|startpos
id|u32
id|startpos
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|targtbl
id|u32
id|targtbl
(braket
l_int|1
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; *  Script fragments used at initialisations.&n; *  Only runs out of main memory.&n; */
DECL|struct|SYM_FWZ_SCR
r_struct
id|SYM_FWZ_SCR
(brace
DECL|member|snooptest
id|u32
id|snooptest
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|snoopend
id|u32
id|snoopend
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#ifdef SYM_OPT_NO_BUS_MEMORY_MAPPING
DECL|member|start_ram
id|u32
id|start_ram
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|scripta0_ba
id|u32
id|scripta0_ba
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|start_ram64
id|u32
id|start_ram64
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|scripta0_ba64
id|u32
id|scripta0_ba64
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|scriptb0_ba64
id|u32
id|scriptb0_ba64
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|ram_seg64
id|u32
id|ram_seg64
(braket
l_int|1
)braket
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
DECL|variable|SYM_FWA_SCR
r_static
r_struct
id|SYM_FWA_SCR
id|SYM_FWA_SCR
op_assign
(brace
multiline_comment|/*--------------------------&lt; START &gt;----------------------------*/
(brace
multiline_comment|/*&n;&t; *  Switch the LED on.&n;&t; *  Will be patched with a NO_OP if LED&n;&t; *  not needed or not desired.&n;&t; */
id|SCR_REG_REG
(paren
id|gpreg
comma
id|SCR_AND
comma
l_int|0xfe
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *      Clear SIGP.&n;&t; */
id|SCR_FROM_REG
(paren
id|ctest2
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Stop here if the C code wants to perform &n;&t; *  some error recovery procedure manually.&n;&t; *  (Indicate this by setting SEM in ISTAT)&n;&t; */
id|SCR_FROM_REG
(paren
id|istat
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Report to the C code the next position in &n;&t; *  the start queue the SCRIPTS will schedule.&n;&t; *  The C code must not change SCRATCHA.&n;&t; */
id|SCR_LOAD_ABS
(paren
id|scratcha
comma
l_int|4
)paren
comma
id|PADDR_B
(paren
id|startpos
)paren
comma
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|SEM
comma
id|SEM
)paren
)paren
comma
id|SIR_SCRIPT_STOPPED
comma
multiline_comment|/*&n;&t; *  Start the next job.&n;&t; *&n;&t; *  @DSA     = start point for this job.&n;&t; *  SCRATCHA = address of this job in the start queue.&n;&t; *&n;&t; *  We will restore startpos with SCRATCHA if we fails the &n;&t; *  arbitration or if it is the idle job.&n;&t; *&n;&t; *  The below GETJOB_BEGIN to GETJOB_END section of SCRIPTS &n;&t; *  is a critical path. If it is partially executed, it then &n;&t; *  may happen that the job address is not yet in the DSA &n;&t; *  and the next queue position points to the next JOB.&n;&t; */
id|SCR_LOAD_ABS
(paren
id|dsa
comma
l_int|4
)paren
comma
id|PADDR_B
(paren
id|startpos
)paren
comma
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
l_int|4
comma
)brace
multiline_comment|/*-------------------------&lt; GETJOB_BEGIN &gt;---------------------*/
comma
(brace
id|SCR_STORE_ABS
(paren
id|temp
comma
l_int|4
)paren
comma
id|PADDR_B
(paren
id|startpos
)paren
comma
id|SCR_LOAD_REL
(paren
id|dsa
comma
l_int|4
)paren
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; GETJOB_END &gt;-----------------------*/
comma
(brace
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
l_int|0
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; SELECT &gt;---------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  DSA&t;contains the address of a scheduled&n;&t; *  &t;data structure.&n;&t; *&n;&t; *  SCRATCHA contains the address of the start queue  &n;&t; *  &t;entry which points to the next job.&n;&t; *&n;&t; *  Set Initiator mode.&n;&t; *&n;&t; *  (Target mode is left as an exercise for the reader)&n;&t; */
macro_line|#ifdef SYM_CONF_TARGET_ROLE_SUPPORT
id|SCR_CLR
(paren
id|SCR_TRG
)paren
comma
l_int|0
comma
macro_line|#endif
multiline_comment|/*&n;&t; *      And try to select this target.&n;&t; */
id|SCR_SEL_TBL_ATN
op_xor
m_offsetof
(paren
r_struct
id|sym_dsb
comma
id|select
)paren
comma
id|PADDR_A
(paren
id|ungetjob
)paren
comma
multiline_comment|/*&n;&t; *  Now there are 4 possibilities:&n;&t; *&n;&t; *  (1) The chip looses arbitration.&n;&t; *  This is ok, because it will try again,&n;&t; *  when the bus becomes idle.&n;&t; *  (But beware of the timeout function!)&n;&t; *&n;&t; *  (2) The chip is reselected.&n;&t; *  Then the script processor takes the jump&n;&t; *  to the RESELECT label.&n;&t; *&n;&t; *  (3) The chip wins arbitration.&n;&t; *  Then it will execute SCRIPTS instruction until &n;&t; *  the next instruction that checks SCSI phase.&n;&t; *  Then will stop and wait for selection to be &n;&t; *  complete or selection time-out to occur.&n;&t; *&n;&t; *  After having won arbitration, the SCRIPTS  &n;&t; *  processor is able to execute instructions while &n;&t; *  the SCSI core is performing SCSI selection.&n;&t; */
multiline_comment|/*&n;&t; *      Initialize the status registers&n;&t; */
id|SCR_LOAD_REL
(paren
id|scr0
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.head.status
)paren
comma
multiline_comment|/*&n;&t; *  We may need help from CPU if the DMA segment &n;&t; *  registers aren&squot;t up-to-date for this IO.&n;&t; *  Patched with NOOP for chips that donnot &n;&t; *  support DAC addressing.&n;&t; */
macro_line|#if&t;SYM_CONF_DMA_ADDRESSING_MODE == 2
)brace
multiline_comment|/*-------------------------&lt; IS_DMAP_DIRTY &gt;--------------------*/
comma
(brace
id|SCR_FROM_REG
(paren
id|HX_REG
)paren
comma
l_int|0
comma
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|HX_DMAP_DIRTY
comma
id|HX_DMAP_DIRTY
)paren
)paren
comma
id|SIR_DMAP_DIRTY
comma
macro_line|#endif
)brace
multiline_comment|/*-------------------------&lt; WF_SEL_DONE &gt;----------------------*/
comma
(brace
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|SIR_SEL_ATN_NO_MSG_OUT
comma
)brace
multiline_comment|/*-------------------------&lt; SEL_DONE &gt;-------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  C1010-33 errata work-around.&n;&t; *  Due to a race, the SCSI core may not have &n;&t; *  loaded SCNTL3 on SEL_TBL instruction.&n;&t; *  We reload it once phase is stable.&n;&t; *  Patched with a NOOP for other chips.&n;&t; */
id|SCR_LOAD_REL
(paren
id|scntl3
comma
l_int|1
)paren
comma
m_offsetof
(paren
r_struct
id|sym_dsb
comma
id|select.sel_scntl3
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SEND_IDENT &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Selection complete.&n;&t; *  Send the IDENTIFY and possibly the TAG message &n;&t; *  and negotiation message if present.&n;&t; */
id|SCR_MOVE_TBL
op_xor
id|SCR_MSG_OUT
comma
m_offsetof
(paren
r_struct
id|sym_dsb
comma
id|smsg
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SELECT2 &gt;--------------------------*/
comma
(brace
macro_line|#ifdef SYM_CONF_IARB_SUPPORT
multiline_comment|/*&n;&t; *  Set IMMEDIATE ARBITRATION if we have been given &n;&t; *  a hint to do so. (Some job to do after this one).&n;&t; */
id|SCR_FROM_REG
(paren
id|HF_REG
)paren
comma
l_int|0
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|HF_HINT_IARB
comma
id|HF_HINT_IARB
)paren
)paren
comma
l_int|8
comma
id|SCR_REG_REG
(paren
id|scntl1
comma
id|SCR_OR
comma
id|IARB
)paren
comma
l_int|0
comma
macro_line|#endif
multiline_comment|/*&n;&t; *  Anticipate the COMMAND phase.&n;&t; *  This is the PHASE we expect at this point.&n;&t; */
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_COMMAND
)paren
)paren
comma
id|PADDR_A
(paren
id|sel_no_cmd
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; COMMAND &gt;--------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  ... and send the command&n;&t; */
id|SCR_MOVE_TBL
op_xor
id|SCR_COMMAND
comma
m_offsetof
(paren
r_struct
id|sym_dsb
comma
id|cmd
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DISPATCH &gt;-------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  MSG_IN is the only phase that shall be &n;&t; *  entered at least once for each (re)selection.&n;&t; *  So we test it first.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR_A
(paren
id|msg_in
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_DATA_OUT
)paren
)paren
comma
id|PADDR_A
(paren
id|datao_phase
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_DATA_IN
)paren
)paren
comma
id|PADDR_A
(paren
id|datai_phase
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_STATUS
)paren
)paren
comma
id|PADDR_A
(paren
id|status
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_COMMAND
)paren
)paren
comma
id|PADDR_A
(paren
id|command
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDR_B
(paren
id|msg_out
)paren
comma
multiline_comment|/*&n;&t; *  Discard as many illegal phases as &n;&t; *  required and tell the C code about.&n;&t; */
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_ILG_OUT
)paren
)paren
comma
l_int|16
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_ILG_OUT
comma
id|HADDR_1
(paren
id|scratch
)paren
comma
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_ILG_OUT
)paren
)paren
comma
op_minus
l_int|16
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_ILG_IN
)paren
)paren
comma
l_int|16
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_ILG_IN
comma
id|HADDR_1
(paren
id|scratch
)paren
comma
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_ILG_IN
)paren
)paren
comma
op_minus
l_int|16
comma
id|SCR_INT
comma
id|SIR_BAD_PHASE
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SEL_NO_CMD &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  The target does not switch to command &n;&t; *  phase after IDENTIFY has been sent.&n;&t; *&n;&t; *  If it stays in MSG OUT phase send it &n;&t; *  the IDENTIFY again.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDR_B
(paren
id|resend_ident
)paren
comma
multiline_comment|/*&n;&t; *  If target does not switch to MSG IN phase &n;&t; *  and we sent a negotiation, assert the &n;&t; *  failure immediately.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
id|SCR_FROM_REG
(paren
id|HS_REG
)paren
comma
l_int|0
comma
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|HS_NEGOTIATE
)paren
)paren
comma
id|SIR_NEGO_FAILED
comma
multiline_comment|/*&n;&t; *  Jump to dispatcher.&n;&t; */
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; INIT &gt;-----------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Wait for the SCSI RESET signal to be &n;&t; *  inactive before restarting operations, &n;&t; *  since the chip may hang on SEL_ATN &n;&t; *  if SCSI RESET is active.&n;&t; */
id|SCR_FROM_REG
(paren
id|sstat0
)paren
comma
l_int|0
comma
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|IRST
comma
id|IRST
)paren
)paren
comma
op_minus
l_int|16
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; CLRACK &gt;---------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Terminate possible pending message phase.&n;&t; */
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATAI_DONE &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Save current pointer to LASTP.&n;&t; */
id|SCR_STORE_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.head.lastp
)paren
comma
multiline_comment|/*&n;&t; *  If the SWIDE is not full, jump to dispatcher.&n;&t; *  We anticipate a STATUS phase.&n;&t; */
id|SCR_FROM_REG
(paren
id|scntl2
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|WSR
comma
id|WSR
)paren
)paren
comma
id|PADDR_A
(paren
id|datai_done_wsr
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_STATUS
)paren
)paren
comma
id|PADDR_A
(paren
id|status
)paren
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATAI_DONE_WSR &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  The SWIDE is full.&n;&t; *  Clear this condition.&n;&t; */
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_OR
comma
id|WSR
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  We are expecting an IGNORE RESIDUE message &n;&t; *  from the device, otherwise we are in data &n;&t; *  overrun condition. Check against MSG_IN phase.&n;&t; */
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|SIR_SWIDE_OVERRUN
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t; *  We are in MSG_IN phase,&n;&t; *  Read the first byte of the message.&n;&t; *  If it is not an IGNORE RESIDUE message,&n;&t; *  signal overrun and jump to message &n;&t; *  processing.&n;&t; */
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|HADDR_1
(paren
id|msgin
(braket
l_int|0
)braket
)paren
comma
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|M_IGN_RESIDUE
)paren
)paren
comma
id|SIR_SWIDE_OVERRUN
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|M_IGN_RESIDUE
)paren
)paren
comma
id|PADDR_A
(paren
id|msg_in2
)paren
comma
multiline_comment|/*&n;&t; *  We got the message we expected.&n;&t; *  Read the 2nd byte, and jump to dispatcher.&n;&t; */
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|HADDR_1
(paren
id|msgin
(braket
l_int|1
)braket
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATAO_DONE &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Save current pointer to LASTP.&n;&t; */
id|SCR_STORE_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.head.lastp
)paren
comma
multiline_comment|/*&n;&t; *  If the SODL is not full jump to dispatcher.&n;&t; *  We anticipate a STATUS phase.&n;&t; */
id|SCR_FROM_REG
(paren
id|scntl2
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|WSS
comma
id|WSS
)paren
)paren
comma
id|PADDR_A
(paren
id|datao_done_wss
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_STATUS
)paren
)paren
comma
id|PADDR_A
(paren
id|status
)paren
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATAO_DONE_WSS &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  The SODL is full, clear this condition.&n;&t; */
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_OR
comma
id|WSS
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  And signal a DATA UNDERRUN condition &n;&t; *  to the C code.&n;&t; */
id|SCR_INT
comma
id|SIR_SODL_UNDERRUN
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATAI_PHASE &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Jump to current pointer.&n;&t; */
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.head.lastp
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; DATAO_PHASE &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  C1010-66 errata work-around.&n;&t; *  Extra clocks of data hold must be inserted &n;&t; *  in DATA OUT phase on 33 MHz PCI BUS.&n;&t; *  Patched with a NOOP for other chips.&n;&t; */
id|SCR_REG_REG
(paren
id|scntl4
comma
id|SCR_OR
comma
(paren
id|XCLKH_DT
op_or
id|XCLKH_ST
)paren
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Jump to current pointer.&n;&t; */
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.head.lastp
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_IN &gt;---------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Get the first byte of the message.&n;&t; *&n;&t; *  The script processor doesn&squot;t negate the&n;&t; *  ACK signal after this transfer.&n;&t; */
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|HADDR_1
(paren
id|msgin
(braket
l_int|0
)braket
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_IN2 &gt;--------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Check first against 1 byte messages &n;&t; *  that we handle from SCRIPTS.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_COMPLETE
)paren
)paren
comma
id|PADDR_A
(paren
id|complete
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_DISCONNECT
)paren
)paren
comma
id|PADDR_A
(paren
id|disconnect
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_SAVE_DP
)paren
)paren
comma
id|PADDR_A
(paren
id|save_dp
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_RESTORE_DP
)paren
)paren
comma
id|PADDR_A
(paren
id|restore_dp
)paren
comma
multiline_comment|/*&n;&t; *  We handle all other messages from the &n;&t; *  C code, so no need to waste on-chip RAM &n;&t; *  for those ones.&n;&t; */
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|msg_in_etc
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; STATUS &gt;---------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  get the status&n;&t; */
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_STATUS
comma
id|HADDR_1
(paren
id|scratch
)paren
comma
macro_line|#ifdef SYM_CONF_IARB_SUPPORT
multiline_comment|/*&n;&t; *  If STATUS is not GOOD, clear IMMEDIATE ARBITRATION, &n;&t; *  since we may have to tamper the start queue from &n;&t; *  the C code.&n;&t; */
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|S_GOOD
)paren
)paren
comma
l_int|8
comma
id|SCR_REG_REG
(paren
id|scntl1
comma
id|SCR_AND
comma
op_complement
id|IARB
)paren
comma
l_int|0
comma
macro_line|#endif
multiline_comment|/*&n;&t; *  save status to scsi_status.&n;&t; *  mark as complete.&n;&t; */
id|SCR_TO_REG
(paren
id|SS_REG
)paren
comma
l_int|0
comma
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
id|HS_COMPLETE
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Anticipate the MESSAGE PHASE for &n;&t; *  the TASK COMPLETE message.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR_A
(paren
id|msg_in
)paren
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; COMPLETE &gt;-------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Complete message.&n;&t; *&n;&t; *  When we terminate the cycle by clearing ACK,&n;&t; *  the target may disconnect immediately.&n;&t; *&n;&t; *  We don&squot;t want to be told of an &quot;unexpected disconnect&quot;,&n;&t; *  so we disable this feature.&n;&t; */
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Terminate cycle ...&n;&t; */
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  ... and wait for the disconnect.&n;&t; */
id|SCR_WAIT_DISC
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; COMPLETE2 &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Save host status.&n;&t; */
id|SCR_STORE_REL
(paren
id|scr0
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.head.status
)paren
comma
multiline_comment|/*&n;&t; *  Some bridges may reorder DMA writes to memory.&n;&t; *  We donnot want the CPU to deal with completions  &n;&t; *  without all the posted write having been flushed &n;&t; *  to memory. This DUMMY READ should flush posted &n;&t; *  buffers prior to the CPU having to deal with &n;&t; *  completions.&n;&t; */
id|SCR_LOAD_REL
(paren
id|scr0
comma
l_int|4
)paren
comma
multiline_comment|/* DUMMY READ */
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.head.status
)paren
comma
multiline_comment|/*&n;&t; *  If command resulted in not GOOD status,&n;&t; *  call the C code if needed.&n;&t; */
id|SCR_FROM_REG
(paren
id|SS_REG
)paren
comma
l_int|0
comma
id|SCR_CALL
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|S_GOOD
)paren
)paren
comma
id|PADDR_B
(paren
id|bad_status
)paren
comma
multiline_comment|/*&n;&t; *  If we performed an auto-sense, call &n;&t; *  the C code to synchronyze task aborts &n;&t; *  with UNIT ATTENTION conditions.&n;&t; */
id|SCR_FROM_REG
(paren
id|HF_REG
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|MASK
(paren
l_int|0
comma
(paren
id|HF_SENSE
op_or
id|HF_EXT_ERR
)paren
)paren
)paren
comma
id|PADDR_A
(paren
id|complete_error
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DONE &gt;-----------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Copy the DSA to the DONE QUEUE and &n;&t; *  signal completion to the host.&n;&t; *  If we are interrupted between DONE &n;&t; *  and DONE_END, we must reset, otherwise &n;&t; *  the completed CCB may be lost.&n;&t; */
id|SCR_STORE_ABS
(paren
id|dsa
comma
l_int|4
)paren
comma
id|PADDR_B
(paren
id|scratch
)paren
comma
id|SCR_LOAD_ABS
(paren
id|dsa
comma
l_int|4
)paren
comma
id|PADDR_B
(paren
id|done_pos
)paren
comma
id|SCR_LOAD_ABS
(paren
id|scratcha
comma
l_int|4
)paren
comma
id|PADDR_B
(paren
id|scratch
)paren
comma
id|SCR_STORE_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  The instruction below reads the DONE QUEUE next &n;&t; *  free position from memory.&n;&t; *  In addition it ensures that all PCI posted writes  &n;&t; *  are flushed and so the DSA value of the done &n;&t; *  CCB is visible by the CPU before INTFLY is raised.&n;&t; */
id|SCR_LOAD_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
l_int|4
comma
id|SCR_INT_FLY
comma
l_int|0
comma
id|SCR_STORE_ABS
(paren
id|scratcha
comma
l_int|4
)paren
comma
id|PADDR_B
(paren
id|done_pos
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DONE_END &gt;-------------------------*/
comma
(brace
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; COMPLETE_ERROR &gt;-------------------*/
comma
(brace
id|SCR_LOAD_ABS
(paren
id|scratcha
comma
l_int|4
)paren
comma
id|PADDR_B
(paren
id|startpos
)paren
comma
id|SCR_INT
comma
id|SIR_COMPLETE_ERROR
comma
)brace
multiline_comment|/*-------------------------&lt; SAVE_DP &gt;--------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Clear ACK immediately.&n;&t; *  No need to delay it.&n;&t; */
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Keep track we received a SAVE DP, so &n;&t; *  we will switch to the other PM context &n;&t; *  on the next PM since the DP may point &n;&t; *  to the current PM context.&n;&t; */
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_OR
comma
id|HF_DP_SAVED
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  SAVE_DP message:&n;&t; *  Copy LASTP to SAVEP.&n;&t; */
id|SCR_LOAD_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.head.lastp
)paren
comma
id|SCR_STORE_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.head.savep
)paren
comma
multiline_comment|/*&n;&t; *  Anticipate the MESSAGE PHASE for &n;&t; *  the DISCONNECT message.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR_A
(paren
id|msg_in
)paren
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESTORE_DP &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Clear ACK immediately.&n;&t; *  No need to delay it.&n;&t; */
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Copy SAVEP to LASTP.&n;&t; */
id|SCR_LOAD_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.head.savep
)paren
comma
id|SCR_STORE_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.head.lastp
)paren
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DISCONNECT &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  DISCONNECTing  ...&n;&t; *&n;&t; *  disable the &quot;unexpected disconnect&quot; feature,&n;&t; *  and remove the ACK signal.&n;&t; */
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Wait for the disconnect.&n;&t; */
id|SCR_WAIT_DISC
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Status is: DISCONNECTED.&n;&t; */
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
id|HS_DISCONNECT
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Save host status.&n;&t; */
id|SCR_STORE_REL
(paren
id|scr0
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.head.status
)paren
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; IDLE &gt;-----------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Nothing to do?&n;&t; *  Switch the LED off and wait for reselect.&n;&t; *  Will be patched with a NO_OP if LED&n;&t; *  not needed or not desired.&n;&t; */
id|SCR_REG_REG
(paren
id|gpreg
comma
id|SCR_OR
comma
l_int|0x01
)paren
comma
l_int|0
comma
macro_line|#ifdef SYM_CONF_IARB_SUPPORT
id|SCR_JUMPR
comma
l_int|8
comma
macro_line|#endif
)brace
multiline_comment|/*-------------------------&lt; UNGETJOB &gt;-------------------------*/
comma
(brace
macro_line|#ifdef SYM_CONF_IARB_SUPPORT
multiline_comment|/*&n;&t; *  Set IMMEDIATE ARBITRATION, for the next time.&n;&t; *  This will give us better chance to win arbitration &n;&t; *  for the job we just wanted to do.&n;&t; */
id|SCR_REG_REG
(paren
id|scntl1
comma
id|SCR_OR
comma
id|IARB
)paren
comma
l_int|0
comma
macro_line|#endif
multiline_comment|/*&n;&t; *  We are not able to restart the SCRIPTS if we are &n;&t; *  interrupted and these instruction haven&squot;t been &n;&t; *  all executed. BTW, this is very unlikely to &n;&t; *  happen, but we check that from the C code.&n;&t; */
id|SCR_LOAD_REG
(paren
id|dsa
comma
l_int|0xff
)paren
comma
l_int|0
comma
id|SCR_STORE_ABS
(paren
id|scratcha
comma
l_int|4
)paren
comma
id|PADDR_B
(paren
id|startpos
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESELECT &gt;-------------------------*/
comma
(brace
macro_line|#ifdef SYM_CONF_TARGET_ROLE_SUPPORT
multiline_comment|/*&n;&t; *  Make sure we are in initiator mode.&n;&t; */
id|SCR_CLR
(paren
id|SCR_TRG
)paren
comma
l_int|0
comma
macro_line|#endif
multiline_comment|/*&n;&t; *  Sleep waiting for a reselection.&n;&t; */
id|SCR_WAIT_RESEL
comma
id|PADDR_A
c_func
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESELECTED &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Switch the LED on.&n;&t; *  Will be patched with a NO_OP if LED&n;&t; *  not needed or not desired.&n;&t; */
id|SCR_REG_REG
(paren
id|gpreg
comma
id|SCR_AND
comma
l_int|0xfe
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  load the target id into the sdid&n;&t; */
id|SCR_REG_SFBR
(paren
id|ssid
comma
id|SCR_AND
comma
l_int|0x8F
)paren
comma
l_int|0
comma
id|SCR_TO_REG
(paren
id|sdid
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Load the target control block address&n;&t; */
id|SCR_LOAD_ABS
(paren
id|dsa
comma
l_int|4
)paren
comma
id|PADDR_B
(paren
id|targtbl
)paren
comma
id|SCR_SFBR_REG
(paren
id|dsa
comma
id|SCR_SHL
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|dsa
comma
id|SCR_SHL
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|dsa
comma
id|SCR_AND
comma
l_int|0x3c
)paren
comma
l_int|0
comma
id|SCR_LOAD_REL
(paren
id|dsa
comma
l_int|4
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  We expect MESSAGE IN phase.&n;&t; *  If not, get help from the C code.&n;&t; */
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|SIR_RESEL_NO_MSG_IN
comma
multiline_comment|/*&n;&t; *  Load the legacy synchronous transfer registers.&n;&t; */
id|SCR_LOAD_REL
(paren
id|scntl3
comma
l_int|1
)paren
comma
m_offsetof
(paren
r_struct
id|sym_tcb
comma
id|head.wval
)paren
comma
id|SCR_LOAD_REL
(paren
id|sxfer
comma
l_int|1
)paren
comma
m_offsetof
(paren
r_struct
id|sym_tcb
comma
id|head.sval
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_SCNTL4 &gt;---------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  The C1010 uses a new synchronous timing scheme.&n;&t; *  Will be patched with a NO_OP if not a C1010.&n;&t; */
id|SCR_LOAD_REL
(paren
id|scntl4
comma
l_int|1
)paren
comma
m_offsetof
(paren
r_struct
id|sym_tcb
comma
id|head.uval
)paren
comma
multiline_comment|/*&n;&t; *  Get the IDENTIFY message.&n;&t; */
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|HADDR_1
(paren
id|msgin
)paren
comma
multiline_comment|/*&n;&t; *  If IDENTIFY LUN #0, use a faster path &n;&t; *  to find the LCB structure.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
l_int|0x80
comma
l_int|0xbf
)paren
)paren
comma
id|PADDR_A
(paren
id|resel_lun0
)paren
comma
multiline_comment|/*&n;&t; *  If message isn&squot;t an IDENTIFY, &n;&t; *  tell the C code about.&n;&t; */
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|MASK
(paren
l_int|0x80
comma
l_int|0x80
)paren
)paren
comma
id|SIR_RESEL_NO_IDENTIFY
comma
multiline_comment|/*&n;&t; *  It is an IDENTIFY message,&n;&t; *  Load the LUN control block address.&n;&t; */
id|SCR_LOAD_REL
(paren
id|dsa
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_tcb
comma
id|head.luntbl_sa
)paren
comma
id|SCR_SFBR_REG
(paren
id|dsa
comma
id|SCR_SHL
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|dsa
comma
id|SCR_SHL
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|dsa
comma
id|SCR_AND
comma
l_int|0xfc
)paren
comma
l_int|0
comma
id|SCR_LOAD_REL
(paren
id|dsa
comma
l_int|4
)paren
comma
l_int|0
comma
id|SCR_JUMPR
comma
l_int|8
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_LUN0 &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  LUN 0 special case (but usual one :))&n;&t; */
id|SCR_LOAD_REL
(paren
id|dsa
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_tcb
comma
id|head.lun0_sa
)paren
comma
multiline_comment|/*&n;&t; *  Jump indirectly to the reselect action for this LUN.&n;&t; */
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_lcb
comma
id|head.resel_sa
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
multiline_comment|/* In normal situations, we jump to RESEL_TAG or RESEL_NO_TAG */
)brace
multiline_comment|/*-------------------------&lt; RESEL_TAG &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  ACK the IDENTIFY previously received.&n;&t; */
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  It shall be a tagged command.&n;&t; *  Read SIMPLE+TAG.&n;&t; *  The C code will deal with errors.&n;&t; *  Agressive optimization, is&squot;nt it? :)&n;&t; */
id|SCR_MOVE_ABS
(paren
l_int|2
)paren
op_xor
id|SCR_MSG_IN
comma
id|HADDR_1
(paren
id|msgin
)paren
comma
multiline_comment|/*&n;&t; *  Load the pointer to the tagged task &n;&t; *  table for this LUN.&n;&t; */
id|SCR_LOAD_REL
(paren
id|dsa
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_lcb
comma
id|head.itlq_tbl_sa
)paren
comma
multiline_comment|/*&n;&t; *  The SIDL still contains the TAG value.&n;&t; *  Agressive optimization, isn&squot;t it? :):)&n;&t; */
id|SCR_REG_SFBR
(paren
id|sidl
comma
id|SCR_SHL
comma
l_int|0
)paren
comma
l_int|0
comma
macro_line|#if SYM_CONF_MAX_TASK*4 &gt; 512
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|CARRYSET
)paren
comma
l_int|8
comma
id|SCR_REG_REG
(paren
id|dsa1
comma
id|SCR_OR
comma
l_int|2
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|sfbr
comma
id|SCR_SHL
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|CARRYSET
)paren
comma
l_int|8
comma
id|SCR_REG_REG
(paren
id|dsa1
comma
id|SCR_OR
comma
l_int|1
)paren
comma
l_int|0
comma
macro_line|#elif SYM_CONF_MAX_TASK*4 &gt; 256
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|CARRYSET
)paren
comma
l_int|8
comma
id|SCR_REG_REG
(paren
id|dsa1
comma
id|SCR_OR
comma
l_int|1
)paren
comma
l_int|0
comma
macro_line|#endif
multiline_comment|/*&n;&t; *  Retrieve the DSA of this task.&n;&t; *  JUMP indirectly to the restart point of the CCB.&n;&t; */
id|SCR_SFBR_REG
(paren
id|dsa
comma
id|SCR_AND
comma
l_int|0xfc
)paren
comma
l_int|0
comma
id|SCR_LOAD_REL
(paren
id|dsa
comma
l_int|4
)paren
comma
l_int|0
comma
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.head.go.restart
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
multiline_comment|/* In normal situations we branch to RESEL_DSA */
)brace
multiline_comment|/*-------------------------&lt; RESEL_DSA &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  ACK the IDENTIFY or TAG previously received.&n;&t; */
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_DSA1 &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *      Initialize the status registers&n;&t; */
id|SCR_LOAD_REL
(paren
id|scr0
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.head.status
)paren
comma
multiline_comment|/*&n;&t; *  Jump to dispatcher.&n;&t; */
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_NO_TAG &gt;---------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Load the DSA with the unique ITL task.&n;&t; */
id|SCR_LOAD_REL
(paren
id|dsa
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_lcb
comma
id|head.itl_task_sa
)paren
comma
multiline_comment|/*&n;&t; *  JUMP indirectly to the restart point of the CCB.&n;&t; */
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.head.go.restart
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
multiline_comment|/* In normal situations we branch to RESEL_DSA */
)brace
multiline_comment|/*-------------------------&lt; DATA_IN &gt;--------------------------*/
comma
(brace
multiline_comment|/*&n; *  Because the size depends on the&n; *  #define SYM_CONF_MAX_SG parameter,&n; *  it is filled in at runtime.&n; *&n; *  ##===========&lt; i=0; i&lt;SYM_CONF_MAX_SG &gt;=========&n; *  ||&t;SCR_CHMOV_TBL ^ SCR_DATA_IN,&n; *  ||&t;&t;offsetof (struct sym_dsb, data[ i]),&n; *  ##==========================================&n; */
l_int|0
)brace
multiline_comment|/*-------------------------&lt; DATA_IN2 &gt;-------------------------*/
comma
(brace
id|SCR_CALL
comma
id|PADDR_A
(paren
id|datai_done
)paren
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|data_ovrun
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_OUT &gt;-------------------------*/
comma
(brace
multiline_comment|/*&n; *  Because the size depends on the&n; *  #define SYM_CONF_MAX_SG parameter,&n; *  it is filled in at runtime.&n; *&n; *  ##===========&lt; i=0; i&lt;SYM_CONF_MAX_SG &gt;=========&n; *  ||&t;SCR_CHMOV_TBL ^ SCR_DATA_OUT,&n; *  ||&t;&t;offsetof (struct sym_dsb, data[ i]),&n; *  ##==========================================&n; */
l_int|0
)brace
multiline_comment|/*-------------------------&lt; DATA_OUT2 &gt;------------------------*/
comma
(brace
id|SCR_CALL
comma
id|PADDR_A
(paren
id|datao_done
)paren
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|data_ovrun
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM0_DATA &gt;-------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Read our host flags to SFBR, so we will be able &n;&t; *  to check against the data direction we expect.&n;&t; */
id|SCR_FROM_REG
(paren
id|HF_REG
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Check against actual DATA PHASE.&n;&t; */
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_IN
)paren
)paren
comma
id|PADDR_A
(paren
id|pm0_data_out
)paren
comma
multiline_comment|/*&n;&t; *  Actual phase is DATA IN.&n;&t; *  Check against expected direction.&n;&t; */
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|HF_DATA_IN
comma
id|HF_DATA_IN
)paren
)paren
comma
id|PADDR_B
(paren
id|data_ovrun
)paren
comma
multiline_comment|/*&n;&t; *  Keep track we are moving data from the &n;&t; *  PM0 DATA mini-script.&n;&t; */
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_OR
comma
id|HF_IN_PM0
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Move the data to memory.&n;&t; */
id|SCR_CHMOV_TBL
op_xor
id|SCR_DATA_IN
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.pm0.sg
)paren
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|pm0_data_end
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM0_DATA_OUT &gt;---------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Actual phase is DATA OUT.&n;&t; *  Check against expected direction.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|HF_DATA_IN
comma
id|HF_DATA_IN
)paren
)paren
comma
id|PADDR_B
(paren
id|data_ovrun
)paren
comma
multiline_comment|/*&n;&t; *  Keep track we are moving data from the &n;&t; *  PM0 DATA mini-script.&n;&t; */
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_OR
comma
id|HF_IN_PM0
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Move the data from memory.&n;&t; */
id|SCR_CHMOV_TBL
op_xor
id|SCR_DATA_OUT
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.pm0.sg
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM0_DATA_END &gt;---------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Clear the flag that told we were moving  &n;&t; *  data from the PM0 DATA mini-script.&n;&t; */
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_AND
comma
(paren
op_complement
id|HF_IN_PM0
)paren
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Return to the previous DATA script which &n;&t; *  is guaranteed by design (if no bug) to be &n;&t; *  the main DATA script for this transfer.&n;&t; */
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.pm0.ret
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; PM1_DATA &gt;-------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Read our host flags to SFBR, so we will be able &n;&t; *  to check against the data direction we expect.&n;&t; */
id|SCR_FROM_REG
(paren
id|HF_REG
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Check against actual DATA PHASE.&n;&t; */
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_IN
)paren
)paren
comma
id|PADDR_A
(paren
id|pm1_data_out
)paren
comma
multiline_comment|/*&n;&t; *  Actual phase is DATA IN.&n;&t; *  Check against expected direction.&n;&t; */
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|HF_DATA_IN
comma
id|HF_DATA_IN
)paren
)paren
comma
id|PADDR_B
(paren
id|data_ovrun
)paren
comma
multiline_comment|/*&n;&t; *  Keep track we are moving data from the &n;&t; *  PM1 DATA mini-script.&n;&t; */
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_OR
comma
id|HF_IN_PM1
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Move the data to memory.&n;&t; */
id|SCR_CHMOV_TBL
op_xor
id|SCR_DATA_IN
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.pm1.sg
)paren
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|pm1_data_end
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM1_DATA_OUT &gt;---------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Actual phase is DATA OUT.&n;&t; *  Check against expected direction.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|HF_DATA_IN
comma
id|HF_DATA_IN
)paren
)paren
comma
id|PADDR_B
(paren
id|data_ovrun
)paren
comma
multiline_comment|/*&n;&t; *  Keep track we are moving data from the &n;&t; *  PM1 DATA mini-script.&n;&t; */
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_OR
comma
id|HF_IN_PM1
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Move the data from memory.&n;&t; */
id|SCR_CHMOV_TBL
op_xor
id|SCR_DATA_OUT
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.pm1.sg
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM1_DATA_END &gt;---------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Clear the flag that told we were moving  &n;&t; *  data from the PM1 DATA mini-script.&n;&t; */
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_AND
comma
(paren
op_complement
id|HF_IN_PM1
)paren
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Return to the previous DATA script which &n;&t; *  is guaranteed by design (if no bug) to be &n;&t; *  the main DATA script for this transfer.&n;&t; */
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.pm1.ret
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt;&gt;-----------------------------------*/
)brace
suffix:semicolon
DECL|variable|SYM_FWB_SCR
r_static
r_struct
id|SYM_FWB_SCR
id|SYM_FWB_SCR
op_assign
(brace
multiline_comment|/*--------------------------&lt; START64 &gt;--------------------------*/
(brace
multiline_comment|/*&n;&t; *  SCRIPT entry point for the 895A, 896 and 1010.&n;&t; *  For now, there is no specific stuff for those &n;&t; *  chips at this point, but this may come.&n;&t; */
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|init
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; NO_DATA &gt;--------------------------*/
comma
(brace
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|data_ovrun
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SEL_FOR_ABORT &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  We are jumped here by the C code, if we have &n;&t; *  some target to reset or some disconnected &n;&t; *  job to abort. Since error recovery is a serious &n;&t; *  busyness, we will really reset the SCSI BUS, if &n;&t; *  case of a SCSI interrupt occurring in this path.&n;&t; */
macro_line|#ifdef SYM_CONF_TARGET_ROLE_SUPPORT
multiline_comment|/*&n;&t; *  Set initiator mode.&n;&t; */
id|SCR_CLR
(paren
id|SCR_TRG
)paren
comma
l_int|0
comma
macro_line|#endif
multiline_comment|/*&n;&t; *      And try to select this target.&n;&t; */
id|SCR_SEL_TBL_ATN
op_xor
m_offsetof
(paren
r_struct
id|sym_hcb
comma
id|abrt_sel
)paren
comma
id|PADDR_A
(paren
id|reselect
)paren
comma
multiline_comment|/*&n;&t; *  Wait for the selection to complete or &n;&t; *  the selection to time out.&n;&t; */
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
op_minus
l_int|8
comma
multiline_comment|/*&n;&t; *  Call the C code.&n;&t; */
id|SCR_INT
comma
id|SIR_TARGET_SELECTED
comma
multiline_comment|/*&n;&t; *  The C code should let us continue here. &n;&t; *  Send the &squot;kiss of death&squot; message.&n;&t; *  We expect an immediate disconnect once &n;&t; *  the target has eaten the message.&n;&t; */
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
id|SCR_MOVE_TBL
op_xor
id|SCR_MSG_OUT
comma
m_offsetof
(paren
r_struct
id|sym_hcb
comma
id|abrt_tbl
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_WAIT_DISC
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Tell the C code that we are done.&n;&t; */
id|SCR_INT
comma
id|SIR_ABORT_SENT
comma
)brace
multiline_comment|/*-------------------------&lt; SEL_FOR_ABORT_1 &gt;------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Jump at scheduler.&n;&t; */
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_IN_ETC &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  If it is an EXTENDED (variable size message)&n;&t; *  Handle it.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_EXTENDED
)paren
)paren
comma
id|PADDR_B
(paren
id|msg_extended
)paren
comma
multiline_comment|/*&n;&t; *  Let the C code handle any other &n;&t; *  1 byte message.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
l_int|0x00
comma
l_int|0xf0
)paren
)paren
comma
id|PADDR_B
(paren
id|msg_received
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
l_int|0x10
comma
l_int|0xf0
)paren
)paren
comma
id|PADDR_B
(paren
id|msg_received
)paren
comma
multiline_comment|/*&n;&t; *  We donnot handle 2 bytes messages from SCRIPTS.&n;&t; *  So, let the C code deal with these ones too.&n;&t; */
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|MASK
(paren
l_int|0x20
comma
l_int|0xf0
)paren
)paren
comma
id|PADDR_B
(paren
id|msg_weird_seen
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|HADDR_1
(paren
id|msgin
(braket
l_int|1
)braket
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_RECEIVED &gt;---------------------*/
comma
(brace
id|SCR_LOAD_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
multiline_comment|/* DUMMY READ */
l_int|0
comma
id|SCR_INT
comma
id|SIR_MSG_RECEIVED
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_WEIRD_SEEN &gt;-------------------*/
comma
(brace
id|SCR_LOAD_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
multiline_comment|/* DUMMY READ */
l_int|0
comma
id|SCR_INT
comma
id|SIR_MSG_WEIRD
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_EXTENDED &gt;---------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Clear ACK and get the next byte &n;&t; *  assumed to be the message length.&n;&t; */
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|HADDR_1
(paren
id|msgin
(braket
l_int|1
)braket
)paren
comma
multiline_comment|/*&n;&t; *  Try to catch some unlikely situations as 0 length &n;&t; *  or too large the length.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
l_int|0
)paren
)paren
comma
id|PADDR_B
(paren
id|msg_weird_seen
)paren
comma
id|SCR_TO_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|sfbr
comma
id|SCR_ADD
comma
(paren
l_int|256
op_minus
l_int|8
)paren
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|CARRYSET
)paren
comma
id|PADDR_B
(paren
id|msg_weird_seen
)paren
comma
multiline_comment|/*&n;&t; *  We donnot handle extended messages from SCRIPTS.&n;&t; *  Read the amount of data correponding to the &n;&t; *  message length and call the C code.&n;&t; */
id|SCR_STORE_REL
(paren
id|scratcha
comma
l_int|1
)paren
comma
m_offsetof
(paren
r_struct
id|sym_dsb
comma
id|smsg_ext.size
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_MOVE_TBL
op_xor
id|SCR_MSG_IN
comma
m_offsetof
(paren
r_struct
id|sym_dsb
comma
id|smsg_ext
)paren
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|msg_received
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_BAD &gt;--------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  unimplemented message - reject it.&n;&t; */
id|SCR_INT
comma
id|SIR_REJECT_TO_SEND
comma
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|clrack
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_WEIRD &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  weird message received&n;&t; *  ignore all MSG IN phases and reject it.&n;&t; */
id|SCR_INT
comma
id|SIR_REJECT_TO_SEND
comma
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_WEIRD1 &gt;-----------------------*/
comma
(brace
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|HADDR_1
(paren
id|scratch
)paren
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|msg_weird1
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; WDTR_RESP &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  let the target fetch our answer.&n;&t; */
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDR_B
(paren
id|nego_bad_phase
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SEND_WDTR &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Send the M_X_WIDE_REQ&n;&t; */
id|SCR_MOVE_ABS
(paren
l_int|4
)paren
op_xor
id|SCR_MSG_OUT
comma
id|HADDR_1
(paren
id|msgout
)paren
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|msg_out_done
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SDTR_RESP &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  let the target fetch our answer.&n;&t; */
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDR_B
(paren
id|nego_bad_phase
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SEND_SDTR &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Send the M_X_SYNC_REQ&n;&t; */
id|SCR_MOVE_ABS
(paren
l_int|5
)paren
op_xor
id|SCR_MSG_OUT
comma
id|HADDR_1
(paren
id|msgout
)paren
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|msg_out_done
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PPR_RESP &gt;-------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  let the target fetch our answer.&n;&t; */
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDR_B
(paren
id|nego_bad_phase
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SEND_PPR &gt;-------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Send the M_X_PPR_REQ&n;&t; */
id|SCR_MOVE_ABS
(paren
l_int|8
)paren
op_xor
id|SCR_MSG_OUT
comma
id|HADDR_1
(paren
id|msgout
)paren
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|msg_out_done
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; NEGO_BAD_PHASE &gt;-------------------*/
comma
(brace
id|SCR_INT
comma
id|SIR_NEGO_PROTO
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_OUT &gt;--------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  The target requests a message.&n;&t; *  We donnot send messages that may &n;&t; *  require the device to go to bus free.&n;&t; */
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_OUT
comma
id|HADDR_1
(paren
id|msgout
)paren
comma
multiline_comment|/*&n;&t; *  ... wait for the next phase&n;&t; *  if it&squot;s a message out, send it again, ...&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDR_B
(paren
id|msg_out
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_OUT_DONE &gt;---------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Let the C code be aware of the &n;&t; *  sent message and clear the message.&n;&t; */
id|SCR_INT
comma
id|SIR_MSG_OUT_DONE
comma
multiline_comment|/*&n;&t; *  ... and process the next phase&n;&t; */
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_OVRUN &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Use scratcha to count the extra bytes.&n;&t; */
id|SCR_LOAD_ABS
(paren
id|scratcha
comma
l_int|4
)paren
comma
id|PADDR_B
(paren
id|zero
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_OVRUN1 &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  The target may want to transfer too much data.&n;&t; *&n;&t; *  If phase is DATA OUT write 1 byte and count it.&n;&t; */
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_OUT
)paren
)paren
comma
l_int|16
comma
id|SCR_CHMOV_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_DATA_OUT
comma
id|HADDR_1
(paren
id|scratch
)paren
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|data_ovrun2
)paren
comma
multiline_comment|/*&n;&t; *  If WSR is set, clear this condition, and &n;&t; *  count this byte.&n;&t; */
id|SCR_FROM_REG
(paren
id|scntl2
)paren
comma
l_int|0
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|WSR
comma
id|WSR
)paren
)paren
comma
l_int|16
comma
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_OR
comma
id|WSR
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|data_ovrun2
)paren
comma
multiline_comment|/*&n;&t; *  Finally check against DATA IN phase.&n;&t; *  Signal data overrun to the C code &n;&t; *  and jump to dispatcher if not so.&n;&t; *  Read 1 byte otherwise and count it.&n;&t; */
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_DATA_IN
)paren
)paren
comma
l_int|16
comma
id|SCR_INT
comma
id|SIR_DATA_OVERRUN
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
id|SCR_CHMOV_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_DATA_IN
comma
id|HADDR_1
(paren
id|scratch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_OVRUN2 &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Count this byte.&n;&t; *  This will allow to return a negative &n;&t; *  residual to user.&n;&t; */
id|SCR_REG_REG
(paren
id|scratcha
comma
id|SCR_ADD
comma
l_int|0x01
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|scratcha1
comma
id|SCR_ADDC
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|scratcha2
comma
id|SCR_ADDC
comma
l_int|0
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  .. and repeat as required.&n;&t; */
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|data_ovrun1
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; ABORT_RESEL &gt;----------------------*/
comma
(brace
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  send the abort/abortag/reset message&n;&t; *  we expect an immediate disconnect&n;&t; */
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_OUT
comma
id|HADDR_1
(paren
id|msgout
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_WAIT_DISC
comma
l_int|0
comma
id|SCR_INT
comma
id|SIR_RESEL_ABORTED
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESEND_IDENT &gt;---------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  The target stays in MSG OUT phase after having acked &n;&t; *  Identify [+ Tag [+ Extended message ]]. Targets shall&n;&t; *  behave this way on parity error.&n;&t; *  We must send it again all the messages.&n;&t; */
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
multiline_comment|/* Shall be asserted 2 deskew delays before the  */
l_int|0
comma
multiline_comment|/* 1rst ACK = 90 ns. Hope the chip isn&squot;t too fast */
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|send_ident
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; IDENT_BREAK &gt;----------------------*/
comma
(brace
id|SCR_CLR
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|select2
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; IDENT_BREAK_ATN &gt;------------------*/
comma
(brace
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|select2
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SDATA_IN &gt;-------------------------*/
comma
(brace
id|SCR_CHMOV_TBL
op_xor
id|SCR_DATA_IN
comma
m_offsetof
(paren
r_struct
id|sym_dsb
comma
id|sense
)paren
comma
id|SCR_CALL
comma
id|PADDR_A
(paren
id|datai_done
)paren
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|data_ovrun
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_BAD_LUN &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Message is an IDENTIFY, but lun is unknown.&n;&t; *  Signal problem to C code for logging the event.&n;&t; *  Send a M_ABORT to clear all pending tasks.&n;&t; */
id|SCR_INT
comma
id|SIR_RESEL_BAD_LUN
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|abort_resel
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; BAD_I_T_L &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  We donnot have a task for that I_T_L.&n;&t; *  Signal problem to C code for logging the event.&n;&t; *  Send a M_ABORT message.&n;&t; */
id|SCR_INT
comma
id|SIR_RESEL_BAD_I_T_L
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|abort_resel
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; BAD_I_T_L_Q &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  We donnot have a task that matches the tag.&n;&t; *  Signal problem to C code for logging the event.&n;&t; *  Send a M_ABORTTAG message.&n;&t; */
id|SCR_INT
comma
id|SIR_RESEL_BAD_I_T_L_Q
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|abort_resel
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; BAD_STATUS &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Anything different from INTERMEDIATE &n;&t; *  CONDITION MET should be a bad SCSI status, &n;&t; *  given that GOOD status has already been tested.&n;&t; *  Call the C code.&n;&t; */
id|SCR_LOAD_ABS
(paren
id|scratcha
comma
l_int|4
)paren
comma
id|PADDR_B
(paren
id|startpos
)paren
comma
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|S_COND_MET
)paren
)paren
comma
id|SIR_BAD_SCSI_STATUS
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; PM_HANDLE &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Phase mismatch handling.&n;&t; *&n;&t; *  Since we have to deal with 2 SCSI data pointers  &n;&t; *  (current and saved), we need at least 2 contexts.&n;&t; *  Each context (pm0 and pm1) has a saved area, a &n;&t; *  SAVE mini-script and a DATA phase mini-script.&n;&t; */
multiline_comment|/*&n;&t; *  Get the PM handling flags.&n;&t; */
id|SCR_FROM_REG
(paren
id|HF_REG
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  If no flags (1rst PM for example), avoid &n;&t; *  all the below heavy flags testing.&n;&t; *  This makes the normal case a bit faster.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
l_int|0
comma
(paren
id|HF_IN_PM0
op_or
id|HF_IN_PM1
op_or
id|HF_DP_SAVED
)paren
)paren
)paren
comma
id|PADDR_B
(paren
id|pm_handle1
)paren
comma
multiline_comment|/*&n;&t; *  If we received a SAVE DP, switch to the &n;&t; *  other PM context since the savep may point &n;&t; *  to the current PM context.&n;&t; */
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|HF_DP_SAVED
comma
id|HF_DP_SAVED
)paren
)paren
comma
l_int|8
comma
id|SCR_REG_REG
(paren
id|sfbr
comma
id|SCR_XOR
comma
id|HF_ACT_PM
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  If we have been interrupt in a PM DATA mini-script,&n;&t; *  we take the return address from the corresponding &n;&t; *  saved area.&n;&t; *  This ensure the return address always points to the &n;&t; *  main DATA script for this transfer.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
l_int|0
comma
(paren
id|HF_IN_PM0
op_or
id|HF_IN_PM1
)paren
)paren
)paren
comma
id|PADDR_B
(paren
id|pm_handle1
)paren
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|HF_IN_PM0
comma
id|HF_IN_PM0
)paren
)paren
comma
l_int|16
comma
id|SCR_LOAD_REL
(paren
id|ia
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.pm0.ret
)paren
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|pm_save
)paren
comma
id|SCR_LOAD_REL
(paren
id|ia
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.pm1.ret
)paren
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|pm_save
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM_HANDLE1 &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Normal case.&n;&t; *  Update the return address so that it &n;&t; *  will point after the interrupted MOVE.&n;&t; */
id|SCR_REG_REG
(paren
id|ia
comma
id|SCR_ADD
comma
l_int|8
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|ia1
comma
id|SCR_ADDC
comma
l_int|0
)paren
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; PM_SAVE &gt;--------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Clear all the flags that told us if we were &n;&t; *  interrupted in a PM DATA mini-script and/or &n;&t; *  we received a SAVE DP.&n;&t; */
id|SCR_SFBR_REG
(paren
id|HF_REG
comma
id|SCR_AND
comma
(paren
op_complement
(paren
id|HF_IN_PM0
op_or
id|HF_IN_PM1
op_or
id|HF_DP_SAVED
)paren
)paren
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Choose the current PM context.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|HF_ACT_PM
comma
id|HF_ACT_PM
)paren
)paren
comma
id|PADDR_B
(paren
id|pm1_save
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM0_SAVE &gt;-------------------------*/
comma
(brace
id|SCR_STORE_REL
(paren
id|ia
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.pm0.ret
)paren
comma
multiline_comment|/*&n;&t; *  If WSR bit is set, either UA and RBC may &n;&t; *  have to be changed whether the device wants &n;&t; *  to ignore this residue or not.&n;&t; */
id|SCR_FROM_REG
(paren
id|scntl2
)paren
comma
l_int|0
comma
id|SCR_CALL
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|WSR
comma
id|WSR
)paren
)paren
comma
id|PADDR_B
(paren
id|pm_wsr_handle
)paren
comma
multiline_comment|/*&n;&t; *  Save the remaining byte count, the updated &n;&t; *  address and the return address.&n;&t; */
id|SCR_STORE_REL
(paren
id|rbc
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.pm0.sg.size
)paren
comma
id|SCR_STORE_REL
(paren
id|ua
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.pm0.sg.addr
)paren
comma
multiline_comment|/*&n;&t; *  Set the current pointer at the PM0 DATA mini-script.&n;&t; */
id|SCR_LOAD_ABS
(paren
id|ia
comma
l_int|4
)paren
comma
id|PADDR_B
(paren
id|pm0_data_addr
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM_SAVE_END &gt;----------------------*/
comma
(brace
id|SCR_STORE_REL
(paren
id|ia
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.head.lastp
)paren
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM1_SAVE &gt;-------------------------*/
comma
(brace
id|SCR_STORE_REL
(paren
id|ia
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.pm1.ret
)paren
comma
multiline_comment|/*&n;&t; *  If WSR bit is set, either UA and RBC may &n;&t; *  have to be changed whether the device wants &n;&t; *  to ignore this residue or not.&n;&t; */
id|SCR_FROM_REG
(paren
id|scntl2
)paren
comma
l_int|0
comma
id|SCR_CALL
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|WSR
comma
id|WSR
)paren
)paren
comma
id|PADDR_B
(paren
id|pm_wsr_handle
)paren
comma
multiline_comment|/*&n;&t; *  Save the remaining byte count, the updated &n;&t; *  address and the return address.&n;&t; */
id|SCR_STORE_REL
(paren
id|rbc
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.pm1.sg.size
)paren
comma
id|SCR_STORE_REL
(paren
id|ua
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.pm1.sg.addr
)paren
comma
multiline_comment|/*&n;&t; *  Set the current pointer at the PM1 DATA mini-script.&n;&t; */
id|SCR_LOAD_ABS
(paren
id|ia
comma
l_int|4
)paren
comma
id|PADDR_B
(paren
id|pm1_data_addr
)paren
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|pm_save_end
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM_WSR_HANDLE &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Phase mismatch handling from SCRIPT with WSR set.&n;&t; *  Such a condition can occur if the chip wants to &n;&t; *  execute a CHMOV(size &gt; 1) when the WSR bit is &n;&t; *  set and the target changes PHASE.&n;&t; *&n;&t; *  We must move the residual byte to memory.&n;&t; *&n;&t; *  UA contains bit 0..31 of the address to &n;&t; *  move the residual byte.&n;&t; *  Move it to the table indirect.&n;&t; */
id|SCR_STORE_REL
(paren
id|ua
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.wresid.addr
)paren
comma
multiline_comment|/*&n;&t; *  Increment UA (move address to next position).&n;&t; */
id|SCR_REG_REG
(paren
id|ua
comma
id|SCR_ADD
comma
l_int|1
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|ua1
comma
id|SCR_ADDC
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|ua2
comma
id|SCR_ADDC
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|ua3
comma
id|SCR_ADDC
comma
l_int|0
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Compute SCRATCHA as:&n;&t; *  - size to transfer = 1 byte.&n;&t; *  - bit 24..31 = high address bit [32...39].&n;&t; */
id|SCR_LOAD_ABS
(paren
id|scratcha
comma
l_int|4
)paren
comma
id|PADDR_B
(paren
id|zero
)paren
comma
id|SCR_REG_REG
(paren
id|scratcha
comma
id|SCR_OR
comma
l_int|1
)paren
comma
l_int|0
comma
id|SCR_FROM_REG
(paren
id|rbc3
)paren
comma
l_int|0
comma
id|SCR_TO_REG
(paren
id|scratcha3
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Move this value to the table indirect.&n;&t; */
id|SCR_STORE_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.wresid.size
)paren
comma
multiline_comment|/*&n;&t; *  Wait for a valid phase.&n;&t; *  While testing with bogus QUANTUM drives, the C1010 &n;&t; *  sometimes raised a spurious phase mismatch with &n;&t; *  WSR and the CHMOV(1) triggered another PM.&n;&t; *  Waiting explicitely for the PHASE seemed to avoid &n;&t; *  the nested phase mismatch. Btw, this didn&squot;t happen &n;&t; *  using my IBM drives.&n;&t; */
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_IN
)paren
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Perform the move of the residual byte.&n;&t; */
id|SCR_CHMOV_TBL
op_xor
id|SCR_DATA_IN
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.wresid
)paren
comma
multiline_comment|/*&n;&t; *  We can now handle the phase mismatch with UA fixed.&n;&t; *  RBC[0..23]=0 is a special case that does not require &n;&t; *  a PM context. The C code also checks against this.&n;&t; */
id|SCR_FROM_REG
(paren
id|rbc
)paren
comma
l_int|0
comma
id|SCR_RETURN
op_xor
id|IFFALSE
(paren
id|DATA
(paren
l_int|0
)paren
)paren
comma
l_int|0
comma
id|SCR_FROM_REG
(paren
id|rbc1
)paren
comma
l_int|0
comma
id|SCR_RETURN
op_xor
id|IFFALSE
(paren
id|DATA
(paren
l_int|0
)paren
)paren
comma
l_int|0
comma
id|SCR_FROM_REG
(paren
id|rbc2
)paren
comma
l_int|0
comma
id|SCR_RETURN
op_xor
id|IFFALSE
(paren
id|DATA
(paren
l_int|0
)paren
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  RBC[0..23]=0.&n;&t; *  Not only we donnot need a PM context, but this would &n;&t; *  lead to a bogus CHMOV(0). This condition means that &n;&t; *  the residual was the last byte to move from this CHMOV.&n;&t; *  So, we just have to move the current data script pointer &n;&t; *  (i.e. TEMP) to the SCRIPTS address following the &n;&t; *  interrupted CHMOV and jump to dispatcher.&n;&t; *  IA contains the data pointer to save.&n;&t; */
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|pm_save_end
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; WSR_MA_HELPER &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Helper for the C code when WSR bit is set.&n;&t; *  Perform the move of the residual byte.&n;&t; */
id|SCR_CHMOV_TBL
op_xor
id|SCR_DATA_IN
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.wresid
)paren
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
macro_line|#ifdef SYM_OPT_HANDLE_DIR_UNKNOWN
)brace
multiline_comment|/*-------------------------&lt; DATA_IO &gt;--------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  We jump here if the data direction was unknown at the &n;&t; *  time we had to queue the command to the scripts processor.&n;&t; *  Pointers had been set as follow in this situation:&n;&t; *    savep   --&gt;   DATA_IO&n;&t; *    lastp   --&gt;   start pointer when DATA_IN&n;&t; *    wlastp  --&gt;   start pointer when DATA_OUT&n;&t; *  This script sets savep and lastp according to the &n;&t; *  direction chosen by the target.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_DATA_OUT
)paren
)paren
comma
id|PADDR_B
(paren
id|data_io_out
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_IO_IN &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Direction is DATA IN.&n;&t; */
id|SCR_LOAD_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.head.lastp
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_IO_COM &gt;----------------------*/
comma
(brace
id|SCR_STORE_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.head.savep
)paren
comma
multiline_comment|/*&n;&t; *  Jump to the SCRIPTS according to actual direction.&n;&t; */
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.head.savep
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_IO_OUT &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Direction is DATA OUT.&n;&t; */
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_AND
comma
(paren
op_complement
id|HF_DATA_IN
)paren
)paren
comma
l_int|0
comma
id|SCR_LOAD_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.head.wlastp
)paren
comma
id|SCR_STORE_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.head.lastp
)paren
comma
id|SCR_JUMP
comma
id|PADDR_B
c_func
(paren
id|data_io_com
)paren
comma
macro_line|#endif /* SYM_OPT_HANDLE_DIR_UNKNOWN */
)brace
multiline_comment|/*-------------------------&lt; ZERO &gt;-----------------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*-------------------------&lt; SCRATCH &gt;--------------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*-------------------------&lt; PM0_DATA_ADDR &gt;--------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*-------------------------&lt; PM1_DATA_ADDR &gt;--------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*-------------------------&lt; DONE_POS &gt;-------------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*-------------------------&lt; STARTPOS &gt;-------------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*-------------------------&lt; TARGTBL &gt;--------------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*-------------------------&lt;&gt;-----------------------------------*/
)brace
suffix:semicolon
DECL|variable|SYM_FWZ_SCR
r_static
r_struct
id|SYM_FWZ_SCR
id|SYM_FWZ_SCR
op_assign
(brace
multiline_comment|/*-------------------------&lt; SNOOPTEST &gt;------------------------*/
(brace
multiline_comment|/*&n;&t; *  Read the variable from memory.&n;&t; */
id|SCR_LOAD_REL
(paren
id|scratcha
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_hcb
comma
id|scratch
)paren
comma
multiline_comment|/*&n;&t; *  Write the variable to memory.&n;&t; */
id|SCR_STORE_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_hcb
comma
id|scratch
)paren
comma
multiline_comment|/*&n;&t; *  Read back the variable from memory.&n;&t; */
id|SCR_LOAD_REL
(paren
id|temp
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_hcb
comma
id|scratch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SNOOPEND &gt;-------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  And stop.&n;&t; */
id|SCR_INT
comma
l_int|99
comma
macro_line|#ifdef SYM_OPT_NO_BUS_MEMORY_MAPPING
multiline_comment|/*&n;&t; *  We may use MEMORY MOVE instructions to load the on chip-RAM,&n;&t; *  if it happens that mapping PCI memory is not possible.&n;&t; *  But writing the RAM from the CPU is the preferred method, &n;&t; *  since PCI 2.2 seems to disallow PCI self-mastering.&n;&t; */
)brace
multiline_comment|/*-------------------------&lt; START_RAM &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Load the script into on-chip RAM, &n;&t; *  and jump to start point.&n;&t; */
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|SYM_FWA_SCR
)paren
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SCRIPTA0_BA &gt;----------------------*/
comma
(brace
l_int|0
comma
id|PADDR_A
(paren
id|start
)paren
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|init
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; START_RAM64 &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Load the RAM and start for 64 bit PCI (895A,896).&n;&t; *  Both scripts (script and scripth) are loaded into &n;&t; *  the RAM which is 8K (4K for 825A/875/895).&n;&t; *  We also need to load some 32-63 bit segments &n;&t; *  address of the SCRIPTS processor.&n;&t; *  LOAD/STORE ABSOLUTE always refers to on-chip RAM &n;&t; *  in our implementation. The main memory is &n;&t; *  accessed using LOAD/STORE DSA RELATIVE.&n;&t; */
id|SCR_LOAD_REL
(paren
id|mmws
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_hcb
comma
id|scr_ram_seg
)paren
comma
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|SYM_FWA_SCR
)paren
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SCRIPTA0_BA64 &gt;--------------------*/
comma
(brace
l_int|0
comma
id|PADDR_A
(paren
id|start
)paren
comma
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|SYM_FWB_SCR
)paren
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SCRIPTB0_BA64 &gt;--------------------*/
comma
(brace
l_int|0
comma
id|PADDR_B
(paren
id|start64
)paren
comma
id|SCR_LOAD_REL
(paren
id|mmrs
comma
l_int|4
)paren
comma
m_offsetof
(paren
r_struct
id|sym_hcb
comma
id|scr_ram_seg
)paren
comma
id|SCR_JUMP64
comma
id|PADDR_B
(paren
id|start64
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RAM_SEG64 &gt;------------------------*/
comma
(brace
l_int|0
comma
macro_line|#endif /* SYM_OPT_NO_BUS_MEMORY_MAPPING */
)brace
multiline_comment|/*-------------------------&lt;&gt;-----------------------------------*/
)brace
suffix:semicolon
eof
