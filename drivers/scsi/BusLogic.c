multiline_comment|/*&n;&n;  Linux Driver for BusLogic MultiMaster and FlashPoint SCSI Host Adapters&n;&n;  Copyright 1995-1998 by Leonard N. Zubkoff &lt;lnz@dandelion.com&gt;&n;&n;  This program is free software; you may redistribute and/or modify it under&n;  the terms of the GNU General Public License Version 2 as published by the&n;  Free Software Foundation.&n;&n;  This program is distributed in the hope that it will be useful, but&n;  WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY&n;  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License&n;  for complete details.&n;&n;  The author respectfully requests that any modifications to this software be&n;  sent directly to him for evaluation and testing.&n;&n;  Special thanks to Wayne Yen, Jin-Lon Hon, and Alex Win of BusLogic, whose&n;  advice has been invaluable, to David Gentzel, for writing the original Linux&n;  BusLogic driver, and to Paul Gortmaker, for being such a dedicated test site.&n;&n;  Finally, special thanks to Mylex/BusLogic for making the FlashPoint SCCB&n;  Manager available as freely redistributable source code.&n;&n;*/
DECL|macro|BusLogic_DriverVersion
mdefine_line|#define BusLogic_DriverVersion&t;&t;&quot;2.1.16&quot;
DECL|macro|BusLogic_DriverDate
mdefine_line|#define BusLogic_DriverDate&t;&t;&quot;18 July 2002&quot;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;scsi/scsicam.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;scsi/scsi.h&gt;
macro_line|#include &lt;scsi/scsi_cmnd.h&gt;
macro_line|#include &lt;scsi/scsi_device.h&gt;
macro_line|#include &lt;scsi/scsi_host.h&gt;
macro_line|#include &lt;scsi/scsi_tcq.h&gt;
macro_line|#include &quot;BusLogic.h&quot;
macro_line|#include &quot;FlashPoint.c&quot;
macro_line|#ifndef FAILURE
DECL|macro|FAILURE
mdefine_line|#define FAILURE (-1)
macro_line|#endif
DECL|variable|Bus_Logic_template
r_static
r_struct
id|scsi_host_template
id|Bus_Logic_template
suffix:semicolon
multiline_comment|/*&n;  BusLogic_DriverOptionsCount is a count of the number of BusLogic Driver&n;  Options specifications provided via the Linux Kernel Command Line or via&n;  the Loadable Kernel Module Installation Facility.&n;*/
DECL|variable|BusLogic_DriverOptionsCount
r_static
r_int
id|BusLogic_DriverOptionsCount
suffix:semicolon
multiline_comment|/*&n;  BusLogic_DriverOptions is an array of Driver Options structures representing&n;  BusLogic Driver Options specifications provided via the Linux Kernel Command&n;  Line or via the Loadable Kernel Module Installation Facility.&n;*/
DECL|variable|BusLogic_DriverOptions
r_static
r_struct
id|BusLogic_DriverOptions
id|BusLogic_DriverOptions
(braket
id|BusLogic_MaxHostAdapters
)braket
suffix:semicolon
multiline_comment|/*&n;  BusLogic can be assigned a string by insmod.&n;*/
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
macro_line|#ifdef MODULE
DECL|variable|BusLogic
r_static
r_char
op_star
id|BusLogic
suffix:semicolon
id|module_param
c_func
(paren
id|BusLogic
comma
id|charp
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;  BusLogic_ProbeOptions is a set of Probe Options to be applied across&n;  all BusLogic Host Adapters.&n;*/
DECL|variable|BusLogic_ProbeOptions
r_static
r_struct
id|BusLogic_ProbeOptions
id|BusLogic_ProbeOptions
suffix:semicolon
multiline_comment|/*&n;  BusLogic_GlobalOptions is a set of Global Options to be applied across&n;  all BusLogic Host Adapters.&n;*/
DECL|variable|BusLogic_GlobalOptions
r_static
r_struct
id|BusLogic_GlobalOptions
id|BusLogic_GlobalOptions
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|BusLogic_host_list
)paren
suffix:semicolon
multiline_comment|/*&n;  BusLogic_ProbeInfoCount is the number of entries in BusLogic_ProbeInfoList.&n;*/
DECL|variable|BusLogic_ProbeInfoCount
r_static
r_int
id|BusLogic_ProbeInfoCount
suffix:semicolon
multiline_comment|/*&n;  BusLogic_ProbeInfoList is the list of I/O Addresses and Bus Probe Information&n;  to be checked for potential BusLogic Host Adapters.  It is initialized by&n;  interrogating the PCI Configuration Space on PCI machines as well as from the&n;  list of standard BusLogic I/O Addresses.&n;*/
DECL|variable|BusLogic_ProbeInfoList
r_static
r_struct
id|BusLogic_ProbeInfo
op_star
id|BusLogic_ProbeInfoList
suffix:semicolon
multiline_comment|/*&n;  BusLogic_CommandFailureReason holds a string identifying the reason why a&n;  call to BusLogic_Command failed.  It is only non-NULL when BusLogic_Command&n;  returns a failure code.&n;*/
DECL|variable|BusLogic_CommandFailureReason
r_static
r_char
op_star
id|BusLogic_CommandFailureReason
suffix:semicolon
multiline_comment|/*&n;  BusLogic_AnnounceDriver announces the Driver Version and Date, Author&squot;s&n;  Name, Copyright Notice, and Electronic Mail Address.&n;*/
DECL|function|BusLogic_AnnounceDriver
r_static
r_void
id|BusLogic_AnnounceDriver
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
)paren
(brace
id|BusLogic_Announce
c_func
(paren
l_string|&quot;***** BusLogic SCSI Driver Version &quot;
id|BusLogic_DriverVersion
l_string|&quot; of &quot;
id|BusLogic_DriverDate
l_string|&quot; *****&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_Announce
c_func
(paren
l_string|&quot;Copyright 1995-1998 by Leonard N. Zubkoff &quot;
l_string|&quot;&lt;lnz@dandelion.com&gt;&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_DriverInfo returns the Host Adapter Name to identify this SCSI&n;  Driver and Host Adapter.&n;*/
DECL|function|BusLogic_DriverInfo
r_static
r_const
r_char
op_star
id|BusLogic_DriverInfo
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|Host
)paren
(brace
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
op_assign
(paren
r_struct
id|BusLogic_HostAdapter
op_star
)paren
id|Host-&gt;hostdata
suffix:semicolon
r_return
id|HostAdapter-&gt;FullModelName
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_InitializeCCBs initializes a group of Command Control Blocks (CCBs)&n;  for Host Adapter from the BlockSize bytes located at BlockPointer.  The newly&n;  created CCBs are added to Host Adapter&squot;s free list.&n;*/
DECL|function|BusLogic_InitializeCCBs
r_static
r_void
id|BusLogic_InitializeCCBs
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
comma
r_void
op_star
id|BlockPointer
comma
r_int
id|BlockSize
comma
id|dma_addr_t
id|BlockPointerHandle
)paren
(brace
r_struct
id|BusLogic_CCB
op_star
id|CCB
op_assign
(paren
r_struct
id|BusLogic_CCB
op_star
)paren
id|BlockPointer
suffix:semicolon
r_int
r_int
id|offset
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|BlockPointer
comma
l_int|0
comma
id|BlockSize
)paren
suffix:semicolon
id|CCB-&gt;AllocationGroupHead
op_assign
id|BlockPointerHandle
suffix:semicolon
id|CCB-&gt;AllocationGroupSize
op_assign
id|BlockSize
suffix:semicolon
r_while
c_loop
(paren
(paren
id|BlockSize
op_sub_assign
r_sizeof
(paren
r_struct
id|BusLogic_CCB
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|CCB-&gt;Status
op_assign
id|BusLogic_CCB_Free
suffix:semicolon
id|CCB-&gt;HostAdapter
op_assign
id|HostAdapter
suffix:semicolon
id|CCB-&gt;DMA_Handle
op_assign
(paren
id|u32
)paren
id|BlockPointerHandle
op_plus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_FlashPointHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
(brace
id|CCB-&gt;CallbackFunction
op_assign
id|BusLogic_QueueCompletedCCB
suffix:semicolon
id|CCB-&gt;BaseAddress
op_assign
id|HostAdapter-&gt;FlashPointInfo.BaseAddress
suffix:semicolon
)brace
id|CCB-&gt;Next
op_assign
id|HostAdapter-&gt;Free_CCBs
suffix:semicolon
id|CCB-&gt;NextAll
op_assign
id|HostAdapter-&gt;All_CCBs
suffix:semicolon
id|HostAdapter-&gt;Free_CCBs
op_assign
id|CCB
suffix:semicolon
id|HostAdapter-&gt;All_CCBs
op_assign
id|CCB
suffix:semicolon
id|HostAdapter-&gt;AllocatedCCBs
op_increment
suffix:semicolon
id|CCB
op_increment
suffix:semicolon
id|offset
op_add_assign
r_sizeof
(paren
r_struct
id|BusLogic_CCB
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;  BusLogic_CreateInitialCCBs allocates the initial CCBs for Host Adapter.&n;*/
DECL|function|BusLogic_CreateInitialCCBs
r_static
id|boolean
id|__init
id|BusLogic_CreateInitialCCBs
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
)paren
(brace
r_int
id|BlockSize
op_assign
id|BusLogic_CCB_AllocationGroupSize
op_star
r_sizeof
(paren
r_struct
id|BusLogic_CCB
)paren
suffix:semicolon
r_void
op_star
id|BlockPointer
suffix:semicolon
id|dma_addr_t
id|BlockPointerHandle
suffix:semicolon
r_while
c_loop
(paren
id|HostAdapter-&gt;AllocatedCCBs
OL
id|HostAdapter-&gt;InitialCCBs
)paren
(brace
id|BlockPointer
op_assign
id|pci_alloc_consistent
c_func
(paren
id|HostAdapter-&gt;PCI_Device
comma
id|BlockSize
comma
op_amp
id|BlockPointerHandle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BlockPointer
op_eq
l_int|NULL
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;UNABLE TO ALLOCATE CCB GROUP - DETACHING&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
id|BusLogic_InitializeCCBs
c_func
(paren
id|HostAdapter
comma
id|BlockPointer
comma
id|BlockSize
comma
id|BlockPointerHandle
)paren
suffix:semicolon
)brace
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_DestroyCCBs deallocates the CCBs for Host Adapter.&n;*/
DECL|function|BusLogic_DestroyCCBs
r_static
r_void
id|BusLogic_DestroyCCBs
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
)paren
(brace
r_struct
id|BusLogic_CCB
op_star
id|NextCCB
op_assign
id|HostAdapter-&gt;All_CCBs
comma
op_star
id|CCB
comma
op_star
id|Last_CCB
op_assign
l_int|NULL
suffix:semicolon
id|HostAdapter-&gt;All_CCBs
op_assign
l_int|NULL
suffix:semicolon
id|HostAdapter-&gt;Free_CCBs
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
(paren
id|CCB
op_assign
id|NextCCB
)paren
op_ne
l_int|NULL
)paren
(brace
id|NextCCB
op_assign
id|CCB-&gt;NextAll
suffix:semicolon
r_if
c_cond
(paren
id|CCB-&gt;AllocationGroupHead
)paren
(brace
r_if
c_cond
(paren
id|Last_CCB
)paren
id|pci_free_consistent
c_func
(paren
id|HostAdapter-&gt;PCI_Device
comma
id|Last_CCB-&gt;AllocationGroupSize
comma
id|Last_CCB
comma
id|Last_CCB-&gt;AllocationGroupHead
)paren
suffix:semicolon
id|Last_CCB
op_assign
id|CCB
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|Last_CCB
)paren
id|pci_free_consistent
c_func
(paren
id|HostAdapter-&gt;PCI_Device
comma
id|Last_CCB-&gt;AllocationGroupSize
comma
id|Last_CCB
comma
id|Last_CCB-&gt;AllocationGroupHead
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_CreateAdditionalCCBs allocates Additional CCBs for Host Adapter.  If&n;  allocation fails and there are no remaining CCBs available, the Driver Queue&n;  Depth is decreased to a known safe value to avoid potential deadlocks when&n;  multiple host adapters share the same IRQ Channel.&n;*/
DECL|function|BusLogic_CreateAdditionalCCBs
r_static
r_void
id|BusLogic_CreateAdditionalCCBs
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
comma
r_int
id|AdditionalCCBs
comma
id|boolean
id|SuccessMessageP
)paren
(brace
r_int
id|BlockSize
op_assign
id|BusLogic_CCB_AllocationGroupSize
op_star
r_sizeof
(paren
r_struct
id|BusLogic_CCB
)paren
suffix:semicolon
r_int
id|PreviouslyAllocated
op_assign
id|HostAdapter-&gt;AllocatedCCBs
suffix:semicolon
r_void
op_star
id|BlockPointer
suffix:semicolon
id|dma_addr_t
id|BlockPointerHandle
suffix:semicolon
r_if
c_cond
(paren
id|AdditionalCCBs
op_le
l_int|0
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|HostAdapter-&gt;AllocatedCCBs
op_minus
id|PreviouslyAllocated
OL
id|AdditionalCCBs
)paren
(brace
id|BlockPointer
op_assign
id|pci_alloc_consistent
c_func
(paren
id|HostAdapter-&gt;PCI_Device
comma
id|BlockSize
comma
op_amp
id|BlockPointerHandle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BlockPointer
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|BusLogic_InitializeCCBs
c_func
(paren
id|HostAdapter
comma
id|BlockPointer
comma
id|BlockSize
comma
id|BlockPointerHandle
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HostAdapter-&gt;AllocatedCCBs
OG
id|PreviouslyAllocated
)paren
(brace
r_if
c_cond
(paren
id|SuccessMessageP
)paren
id|BusLogic_Notice
c_func
(paren
l_string|&quot;Allocated %d additional CCBs (total now %d)&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;AllocatedCCBs
op_minus
id|PreviouslyAllocated
comma
id|HostAdapter-&gt;AllocatedCCBs
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|BusLogic_Notice
c_func
(paren
l_string|&quot;Failed to allocate additional CCBs&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;DriverQueueDepth
OG
id|HostAdapter-&gt;AllocatedCCBs
op_minus
id|HostAdapter-&gt;TargetDeviceCount
)paren
(brace
id|HostAdapter-&gt;DriverQueueDepth
op_assign
id|HostAdapter-&gt;AllocatedCCBs
op_minus
id|HostAdapter-&gt;TargetDeviceCount
suffix:semicolon
id|HostAdapter-&gt;SCSI_Host-&gt;can_queue
op_assign
id|HostAdapter-&gt;DriverQueueDepth
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;  BusLogic_AllocateCCB allocates a CCB from Host Adapter&squot;s free list,&n;  allocating more memory from the Kernel if necessary.  The Host Adapter&squot;s&n;  Lock should already have been acquired by the caller.&n;*/
DECL|function|BusLogic_AllocateCCB
r_static
r_struct
id|BusLogic_CCB
op_star
id|BusLogic_AllocateCCB
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
)paren
(brace
r_static
r_int
r_int
id|SerialNumber
op_assign
l_int|0
suffix:semicolon
r_struct
id|BusLogic_CCB
op_star
id|CCB
suffix:semicolon
id|CCB
op_assign
id|HostAdapter-&gt;Free_CCBs
suffix:semicolon
r_if
c_cond
(paren
id|CCB
op_ne
l_int|NULL
)paren
(brace
id|CCB-&gt;SerialNumber
op_assign
op_increment
id|SerialNumber
suffix:semicolon
id|HostAdapter-&gt;Free_CCBs
op_assign
id|CCB-&gt;Next
suffix:semicolon
id|CCB-&gt;Next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;Free_CCBs
op_eq
l_int|NULL
)paren
id|BusLogic_CreateAdditionalCCBs
c_func
(paren
id|HostAdapter
comma
id|HostAdapter-&gt;IncrementalCCBs
comma
l_bool|true
)paren
suffix:semicolon
r_return
id|CCB
suffix:semicolon
)brace
id|BusLogic_CreateAdditionalCCBs
c_func
(paren
id|HostAdapter
comma
id|HostAdapter-&gt;IncrementalCCBs
comma
l_bool|true
)paren
suffix:semicolon
id|CCB
op_assign
id|HostAdapter-&gt;Free_CCBs
suffix:semicolon
r_if
c_cond
(paren
id|CCB
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|CCB-&gt;SerialNumber
op_assign
op_increment
id|SerialNumber
suffix:semicolon
id|HostAdapter-&gt;Free_CCBs
op_assign
id|CCB-&gt;Next
suffix:semicolon
id|CCB-&gt;Next
op_assign
l_int|NULL
suffix:semicolon
r_return
id|CCB
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_DeallocateCCB deallocates a CCB, returning it to the Host Adapter&squot;s&n;  free list.  The Host Adapter&squot;s Lock should already have been acquired by the&n;  caller.&n;*/
DECL|function|BusLogic_DeallocateCCB
r_static
r_void
id|BusLogic_DeallocateCCB
c_func
(paren
r_struct
id|BusLogic_CCB
op_star
id|CCB
)paren
(brace
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
op_assign
id|CCB-&gt;HostAdapter
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|cmd
op_assign
id|CCB-&gt;Command
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;use_sg
op_ne
l_int|0
)paren
(brace
id|pci_unmap_sg
c_func
(paren
id|HostAdapter-&gt;PCI_Device
comma
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;request_buffer
comma
id|cmd-&gt;use_sg
comma
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
op_ne
l_int|0
)paren
(brace
id|pci_unmap_single
c_func
(paren
id|HostAdapter-&gt;PCI_Device
comma
id|CCB-&gt;DataPointer
comma
id|CCB-&gt;DataLength
comma
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
)brace
id|pci_unmap_single
c_func
(paren
id|HostAdapter-&gt;PCI_Device
comma
id|CCB-&gt;SenseDataPointer
comma
id|CCB-&gt;SenseDataLength
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|CCB-&gt;Command
op_assign
l_int|NULL
suffix:semicolon
id|CCB-&gt;Status
op_assign
id|BusLogic_CCB_Free
suffix:semicolon
id|CCB-&gt;Next
op_assign
id|HostAdapter-&gt;Free_CCBs
suffix:semicolon
id|HostAdapter-&gt;Free_CCBs
op_assign
id|CCB
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_Command sends the command OperationCode to HostAdapter, optionally&n;  providing ParameterLength bytes of ParameterData and receiving at most&n;  ReplyLength bytes of ReplyData; any excess reply data is received but&n;  discarded.&n;&n;  On success, this function returns the number of reply bytes read from&n;  the Host Adapter (including any discarded data); on failure, it returns&n;  -1 if the command was invalid, or -2 if a timeout occurred.&n;&n;  BusLogic_Command is called exclusively during host adapter detection and&n;  initialization, so performance and latency are not critical, and exclusive&n;  access to the Host Adapter hardware is assumed.  Once the host adapter and&n;  driver are initialized, the only Host Adapter command that is issued is the&n;  single byte Execute Mailbox Command operation code, which does not require&n;  waiting for the Host Adapter Ready bit to be set in the Status Register.&n;*/
DECL|function|BusLogic_Command
r_static
r_int
id|BusLogic_Command
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
comma
r_enum
id|BusLogic_OperationCode
id|OperationCode
comma
r_void
op_star
id|ParameterData
comma
r_int
id|ParameterLength
comma
r_void
op_star
id|ReplyData
comma
r_int
id|ReplyLength
)paren
(brace
r_int
r_char
op_star
id|ParameterPointer
op_assign
(paren
r_int
r_char
op_star
)paren
id|ParameterData
suffix:semicolon
r_int
r_char
op_star
id|ReplyPointer
op_assign
(paren
r_int
r_char
op_star
)paren
id|ReplyData
suffix:semicolon
r_union
id|BusLogic_StatusRegister
id|StatusRegister
suffix:semicolon
r_union
id|BusLogic_InterruptRegister
id|InterruptRegister
suffix:semicolon
r_int
r_int
id|ProcessorFlags
op_assign
l_int|0
suffix:semicolon
r_int
id|ReplyBytes
op_assign
l_int|0
comma
id|Result
suffix:semicolon
r_int
id|TimeoutCounter
suffix:semicolon
multiline_comment|/*&n;&t;   Clear out the Reply Data if provided.&n;&t; */
r_if
c_cond
(paren
id|ReplyLength
OG
l_int|0
)paren
id|memset
c_func
(paren
id|ReplyData
comma
l_int|0
comma
id|ReplyLength
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   If the IRQ Channel has not yet been acquired, then interrupts must be&n;&t;   disabled while issuing host adapter commands since a Command Complete&n;&t;   interrupt could occur if the IRQ Channel was previously enabled by another&n;&t;   BusLogic Host Adapter or another driver sharing the same IRQ Channel.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|HostAdapter-&gt;IRQ_ChannelAcquired
)paren
(brace
id|local_irq_save
c_func
(paren
id|ProcessorFlags
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Wait for the Host Adapter Ready bit to be set and the Command/Parameter&n;&t;   Register Busy bit to be reset in the Status Register.&n;&t; */
id|TimeoutCounter
op_assign
l_int|10000
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|TimeoutCounter
op_ge
l_int|0
)paren
(brace
id|StatusRegister.All
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister.sr.HostAdapterReady
op_logical_and
op_logical_neg
id|StatusRegister.sr.CommandParameterRegisterBusy
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TimeoutCounter
OL
l_int|0
)paren
(brace
id|BusLogic_CommandFailureReason
op_assign
l_string|&quot;Timeout waiting for Host Adapter Ready&quot;
suffix:semicolon
id|Result
op_assign
op_minus
l_int|2
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Write the OperationCode to the Command/Parameter Register.&n;&t; */
id|HostAdapter-&gt;HostAdapterCommandCompleted
op_assign
l_bool|false
suffix:semicolon
id|BusLogic_WriteCommandParameterRegister
c_func
(paren
id|HostAdapter
comma
id|OperationCode
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   Write any additional Parameter Bytes.&n;&t; */
id|TimeoutCounter
op_assign
l_int|10000
suffix:semicolon
r_while
c_loop
(paren
id|ParameterLength
OG
l_int|0
op_logical_and
op_decrement
id|TimeoutCounter
op_ge
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;   Wait 100 microseconds to give the Host Adapter enough time to determine&n;&t;&t;   whether the last value written to the Command/Parameter Register was&n;&t;&t;   valid or not.  If the Command Complete bit is set in the Interrupt&n;&t;&t;   Register, then the Command Invalid bit in the Status Register will be&n;&t;&t;   reset if the Operation Code or Parameter was valid and the command&n;&t;&t;   has completed, or set if the Operation Code or Parameter was invalid.&n;&t;&t;   If the Data In Register Ready bit is set in the Status Register, then&n;&t;&t;   the Operation Code was valid, and data is waiting to be read back&n;&t;&t;   from the Host Adapter.  Otherwise, wait for the Command/Parameter&n;&t;&t;   Register Busy bit in the Status Register to be reset.&n;&t;&t; */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|InterruptRegister.All
op_assign
id|BusLogic_ReadInterruptRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|StatusRegister.All
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|InterruptRegister.ir.CommandComplete
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterCommandCompleted
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister.sr.DataInRegisterReady
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister.sr.CommandParameterRegisterBusy
)paren
r_continue
suffix:semicolon
id|BusLogic_WriteCommandParameterRegister
c_func
(paren
id|HostAdapter
comma
op_star
id|ParameterPointer
op_increment
)paren
suffix:semicolon
id|ParameterLength
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TimeoutCounter
OL
l_int|0
)paren
(brace
id|BusLogic_CommandFailureReason
op_assign
l_string|&quot;Timeout waiting for Parameter Acceptance&quot;
suffix:semicolon
id|Result
op_assign
op_minus
l_int|2
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   The Modify I/O Address command does not cause a Command Complete Interrupt.&n;&t; */
r_if
c_cond
(paren
id|OperationCode
op_eq
id|BusLogic_ModifyIOAddress
)paren
(brace
id|StatusRegister.All
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister.sr.CommandInvalid
)paren
(brace
id|BusLogic_CommandFailureReason
op_assign
l_string|&quot;Modify I/O Address Invalid&quot;
suffix:semicolon
id|Result
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BusLogic_GlobalOptions.TraceConfiguration
)paren
id|BusLogic_Notice
c_func
(paren
l_string|&quot;BusLogic_Command(%02X) Status = %02X: &quot;
l_string|&quot;(Modify I/O Address)&bslash;n&quot;
comma
id|HostAdapter
comma
id|OperationCode
comma
id|StatusRegister.All
)paren
suffix:semicolon
id|Result
op_assign
l_int|0
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Select an appropriate timeout value for awaiting command completion.&n;&t; */
r_switch
c_cond
(paren
id|OperationCode
)paren
(brace
r_case
id|BusLogic_InquireInstalledDevicesID0to7
suffix:colon
r_case
id|BusLogic_InquireInstalledDevicesID8to15
suffix:colon
r_case
id|BusLogic_InquireTargetDevices
suffix:colon
multiline_comment|/* Approximately 60 seconds. */
id|TimeoutCounter
op_assign
l_int|60
op_star
l_int|10000
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Approximately 1 second. */
id|TimeoutCounter
op_assign
l_int|10000
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Receive any Reply Bytes, waiting for either the Command Complete bit to&n;&t;   be set in the Interrupt Register, or for the Interrupt Handler to set the&n;&t;   Host Adapter Command Completed bit in the Host Adapter structure.&n;&t; */
r_while
c_loop
(paren
op_decrement
id|TimeoutCounter
op_ge
l_int|0
)paren
(brace
id|InterruptRegister.All
op_assign
id|BusLogic_ReadInterruptRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|StatusRegister.All
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|InterruptRegister.ir.CommandComplete
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterCommandCompleted
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister.sr.DataInRegisterReady
)paren
(brace
r_if
c_cond
(paren
op_increment
id|ReplyBytes
op_le
id|ReplyLength
)paren
op_star
id|ReplyPointer
op_increment
op_assign
id|BusLogic_ReadDataInRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_else
id|BusLogic_ReadDataInRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|OperationCode
op_eq
id|BusLogic_FetchHostAdapterLocalRAM
op_logical_and
id|StatusRegister.sr.HostAdapterReady
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TimeoutCounter
OL
l_int|0
)paren
(brace
id|BusLogic_CommandFailureReason
op_assign
l_string|&quot;Timeout waiting for Command Complete&quot;
suffix:semicolon
id|Result
op_assign
op_minus
l_int|2
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Clear any pending Command Complete Interrupt.&n;&t; */
id|BusLogic_InterruptReset
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   Provide tracing information if requested.&n;&t; */
r_if
c_cond
(paren
id|BusLogic_GlobalOptions.TraceConfiguration
)paren
(brace
r_int
id|i
suffix:semicolon
id|BusLogic_Notice
c_func
(paren
l_string|&quot;BusLogic_Command(%02X) Status = %02X: %2d ==&gt; %2d:&quot;
comma
id|HostAdapter
comma
id|OperationCode
comma
id|StatusRegister.All
comma
id|ReplyLength
comma
id|ReplyBytes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ReplyLength
OG
id|ReplyBytes
)paren
id|ReplyLength
op_assign
id|ReplyBytes
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ReplyLength
suffix:semicolon
id|i
op_increment
)paren
id|BusLogic_Notice
c_func
(paren
l_string|&quot; %02X&quot;
comma
id|HostAdapter
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|ReplyData
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|BusLogic_Notice
c_func
(paren
l_string|&quot;&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Process Command Invalid conditions.&n;&t; */
r_if
c_cond
(paren
id|StatusRegister.sr.CommandInvalid
)paren
(brace
multiline_comment|/*&n;&t;&t;   Some early BusLogic Host Adapters may not recover properly from&n;&t;&t;   a Command Invalid condition, so if this appears to be the case,&n;&t;&t;   a Soft Reset is issued to the Host Adapter.  Potentially invalid&n;&t;&t;   commands are never attempted after Mailbox Initialization is&n;&t;&t;   performed, so there should be no Host Adapter state lost by a&n;&t;&t;   Soft Reset in response to a Command Invalid condition.&n;&t;&t; */
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|StatusRegister.All
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister.sr.CommandInvalid
op_logical_or
id|StatusRegister.sr.Reserved
op_logical_or
id|StatusRegister.sr.DataInRegisterReady
op_logical_or
id|StatusRegister.sr.CommandParameterRegisterBusy
op_logical_or
op_logical_neg
id|StatusRegister.sr.HostAdapterReady
op_logical_or
op_logical_neg
id|StatusRegister.sr.InitializationRequired
op_logical_or
id|StatusRegister.sr.DiagnosticActive
op_logical_or
id|StatusRegister.sr.DiagnosticFailure
)paren
(brace
id|BusLogic_SoftReset
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
id|BusLogic_CommandFailureReason
op_assign
l_string|&quot;Command Invalid&quot;
suffix:semicolon
id|Result
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Handle Excess Parameters Supplied conditions.&n;&t; */
r_if
c_cond
(paren
id|ParameterLength
OG
l_int|0
)paren
(brace
id|BusLogic_CommandFailureReason
op_assign
l_string|&quot;Excess Parameters Supplied&quot;
suffix:semicolon
id|Result
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Indicate the command completed successfully.&n;&t; */
id|BusLogic_CommandFailureReason
op_assign
l_int|NULL
suffix:semicolon
id|Result
op_assign
id|ReplyBytes
suffix:semicolon
multiline_comment|/*&n;&t;   Restore the interrupt status if necessary and return.&n;&t; */
id|Done
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|HostAdapter-&gt;IRQ_ChannelAcquired
)paren
id|local_irq_restore
c_func
(paren
id|ProcessorFlags
)paren
suffix:semicolon
r_return
id|Result
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_AppendProbeAddressISA appends a single ISA I/O Address to the list&n;  of I/O Address and Bus Probe Information to be checked for potential BusLogic&n;  Host Adapters.&n;*/
DECL|function|BusLogic_AppendProbeAddressISA
r_static
r_void
id|__init
id|BusLogic_AppendProbeAddressISA
c_func
(paren
r_int
r_int
id|IO_Address
)paren
(brace
r_struct
id|BusLogic_ProbeInfo
op_star
id|ProbeInfo
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_ProbeInfoCount
op_ge
id|BusLogic_MaxHostAdapters
)paren
r_return
suffix:semicolon
id|ProbeInfo
op_assign
op_amp
id|BusLogic_ProbeInfoList
(braket
id|BusLogic_ProbeInfoCount
op_increment
)braket
suffix:semicolon
id|ProbeInfo-&gt;HostAdapterType
op_assign
id|BusLogic_MultiMaster
suffix:semicolon
id|ProbeInfo-&gt;HostAdapterBusType
op_assign
id|BusLogic_ISA_Bus
suffix:semicolon
id|ProbeInfo-&gt;IO_Address
op_assign
id|IO_Address
suffix:semicolon
id|ProbeInfo-&gt;PCI_Device
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_InitializeProbeInfoListISA initializes the list of I/O Address and&n;  Bus Probe Information to be checked for potential BusLogic SCSI Host Adapters&n;  only from the list of standard BusLogic MultiMaster ISA I/O Addresses.&n;*/
DECL|function|BusLogic_InitializeProbeInfoListISA
r_static
r_void
id|__init
id|BusLogic_InitializeProbeInfoListISA
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|PrototypeHostAdapter
)paren
(brace
multiline_comment|/*&n;&t;   If BusLogic Driver Options specifications requested that ISA Bus Probes&n;&t;   be inhibited, do not proceed further.&n;&t; */
r_if
c_cond
(paren
id|BusLogic_ProbeOptions.NoProbeISA
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;   Append the list of standard BusLogic MultiMaster ISA I/O Addresses.&n;&t; */
r_if
c_cond
(paren
id|BusLogic_ProbeOptions.LimitedProbeISA
ques
c_cond
id|BusLogic_ProbeOptions.Probe330
suffix:colon
id|check_region
c_func
(paren
l_int|0x330
comma
id|BusLogic_MultiMasterAddressCount
)paren
op_eq
l_int|0
)paren
id|BusLogic_AppendProbeAddressISA
c_func
(paren
l_int|0x330
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_ProbeOptions.LimitedProbeISA
ques
c_cond
id|BusLogic_ProbeOptions.Probe334
suffix:colon
id|check_region
c_func
(paren
l_int|0x334
comma
id|BusLogic_MultiMasterAddressCount
)paren
op_eq
l_int|0
)paren
id|BusLogic_AppendProbeAddressISA
c_func
(paren
l_int|0x334
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_ProbeOptions.LimitedProbeISA
ques
c_cond
id|BusLogic_ProbeOptions.Probe230
suffix:colon
id|check_region
c_func
(paren
l_int|0x230
comma
id|BusLogic_MultiMasterAddressCount
)paren
op_eq
l_int|0
)paren
id|BusLogic_AppendProbeAddressISA
c_func
(paren
l_int|0x230
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_ProbeOptions.LimitedProbeISA
ques
c_cond
id|BusLogic_ProbeOptions.Probe234
suffix:colon
id|check_region
c_func
(paren
l_int|0x234
comma
id|BusLogic_MultiMasterAddressCount
)paren
op_eq
l_int|0
)paren
id|BusLogic_AppendProbeAddressISA
c_func
(paren
l_int|0x234
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_ProbeOptions.LimitedProbeISA
ques
c_cond
id|BusLogic_ProbeOptions.Probe130
suffix:colon
id|check_region
c_func
(paren
l_int|0x130
comma
id|BusLogic_MultiMasterAddressCount
)paren
op_eq
l_int|0
)paren
id|BusLogic_AppendProbeAddressISA
c_func
(paren
l_int|0x130
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_ProbeOptions.LimitedProbeISA
ques
c_cond
id|BusLogic_ProbeOptions.Probe134
suffix:colon
id|check_region
c_func
(paren
l_int|0x134
comma
id|BusLogic_MultiMasterAddressCount
)paren
op_eq
l_int|0
)paren
id|BusLogic_AppendProbeAddressISA
c_func
(paren
l_int|0x134
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PCI
multiline_comment|/*&n;  BusLogic_SortProbeInfo sorts a section of BusLogic_ProbeInfoList in order&n;  of increasing PCI Bus and Device Number.&n;*/
DECL|function|BusLogic_SortProbeInfo
r_static
r_void
id|__init
id|BusLogic_SortProbeInfo
c_func
(paren
r_struct
id|BusLogic_ProbeInfo
op_star
id|ProbeInfoList
comma
r_int
id|ProbeInfoCount
)paren
(brace
r_int
id|LastInterchange
op_assign
id|ProbeInfoCount
op_minus
l_int|1
comma
id|Bound
comma
id|j
suffix:semicolon
r_while
c_loop
(paren
id|LastInterchange
OG
l_int|0
)paren
(brace
id|Bound
op_assign
id|LastInterchange
suffix:semicolon
id|LastInterchange
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|Bound
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|BusLogic_ProbeInfo
op_star
id|ProbeInfo1
op_assign
op_amp
id|ProbeInfoList
(braket
id|j
)braket
suffix:semicolon
r_struct
id|BusLogic_ProbeInfo
op_star
id|ProbeInfo2
op_assign
op_amp
id|ProbeInfoList
(braket
id|j
op_plus
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ProbeInfo1-&gt;Bus
OG
id|ProbeInfo2-&gt;Bus
op_logical_or
(paren
id|ProbeInfo1-&gt;Bus
op_eq
id|ProbeInfo2-&gt;Bus
op_logical_and
(paren
id|ProbeInfo1-&gt;Device
OG
id|ProbeInfo2-&gt;Device
)paren
)paren
)paren
(brace
r_struct
id|BusLogic_ProbeInfo
id|TempProbeInfo
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|TempProbeInfo
comma
id|ProbeInfo1
comma
r_sizeof
(paren
r_struct
id|BusLogic_ProbeInfo
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ProbeInfo1
comma
id|ProbeInfo2
comma
r_sizeof
(paren
r_struct
id|BusLogic_ProbeInfo
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ProbeInfo2
comma
op_amp
id|TempProbeInfo
comma
r_sizeof
(paren
r_struct
id|BusLogic_ProbeInfo
)paren
)paren
suffix:semicolon
id|LastInterchange
op_assign
id|j
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n;  BusLogic_InitializeMultiMasterProbeInfo initializes the list of I/O Address&n;  and Bus Probe Information to be checked for potential BusLogic MultiMaster&n;  SCSI Host Adapters by interrogating the PCI Configuration Space on PCI&n;  machines as well as from the list of standard BusLogic MultiMaster ISA&n;  I/O Addresses.  It returns the number of PCI MultiMaster Host Adapters found.&n;*/
DECL|function|BusLogic_InitializeMultiMasterProbeInfo
r_static
r_int
id|__init
id|BusLogic_InitializeMultiMasterProbeInfo
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|PrototypeHostAdapter
)paren
(brace
r_struct
id|BusLogic_ProbeInfo
op_star
id|PrimaryProbeInfo
op_assign
op_amp
id|BusLogic_ProbeInfoList
(braket
id|BusLogic_ProbeInfoCount
)braket
suffix:semicolon
r_int
id|NonPrimaryPCIMultiMasterIndex
op_assign
id|BusLogic_ProbeInfoCount
op_plus
l_int|1
suffix:semicolon
r_int
id|NonPrimaryPCIMultiMasterCount
op_assign
l_int|0
comma
id|PCIMultiMasterCount
op_assign
l_int|0
suffix:semicolon
id|boolean
id|ForceBusDeviceScanningOrder
op_assign
l_bool|false
suffix:semicolon
id|boolean
id|ForceBusDeviceScanningOrderChecked
op_assign
l_bool|false
suffix:semicolon
id|boolean
id|StandardAddressSeen
(braket
l_int|6
)braket
suffix:semicolon
r_struct
id|pci_dev
op_star
id|PCI_Device
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_ProbeInfoCount
op_ge
id|BusLogic_MaxHostAdapters
)paren
r_return
l_int|0
suffix:semicolon
id|BusLogic_ProbeInfoCount
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|StandardAddressSeen
(braket
id|i
)braket
op_assign
l_bool|false
suffix:semicolon
multiline_comment|/*&n;&t;   Iterate over the MultiMaster PCI Host Adapters.  For each enumerated host&n;&t;   adapter, determine whether its ISA Compatible I/O Port is enabled and if&n;&t;   so, whether it is assigned the Primary I/O Address.  A host adapter that is&n;&t;   assigned the Primary I/O Address will always be the preferred boot device.&n;&t;   The MultiMaster BIOS will first recognize a host adapter at the Primary I/O&n;&t;   Address, then any other PCI host adapters, and finally any host adapters&n;&t;   located at the remaining standard ISA I/O Addresses.  When a PCI host&n;&t;   adapter is found with its ISA Compatible I/O Port enabled, a command is&n;&t;   issued to disable the ISA Compatible I/O Port, and it is noted that the&n;&t;   particular standard ISA I/O Address need not be probed.&n;&t; */
id|PrimaryProbeInfo-&gt;IO_Address
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|PCI_Device
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_BUSLOGIC
comma
id|PCI_DEVICE_ID_BUSLOGIC_MULTIMASTER
comma
id|PCI_Device
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
op_assign
id|PrototypeHostAdapter
suffix:semicolon
r_struct
id|BusLogic_PCIHostAdapterInformation
id|PCIHostAdapterInformation
suffix:semicolon
r_enum
id|BusLogic_ISACompatibleIOPort
id|ModifyIOAddressRequest
suffix:semicolon
r_int
r_char
id|Bus
suffix:semicolon
r_int
r_char
id|Device
suffix:semicolon
r_int
r_int
id|IRQ_Channel
suffix:semicolon
r_int
r_int
id|BaseAddress0
suffix:semicolon
r_int
r_int
id|BaseAddress1
suffix:semicolon
r_int
r_int
id|IO_Address
suffix:semicolon
r_int
r_int
id|PCI_Address
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|PCI_Device
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pci_set_dma_mask
c_func
(paren
id|PCI_Device
comma
(paren
id|u64
)paren
l_int|0xffffffff
)paren
)paren
r_continue
suffix:semicolon
id|Bus
op_assign
id|PCI_Device-&gt;bus-&gt;number
suffix:semicolon
id|Device
op_assign
id|PCI_Device-&gt;devfn
op_rshift
l_int|3
suffix:semicolon
id|IRQ_Channel
op_assign
id|PCI_Device-&gt;irq
suffix:semicolon
id|IO_Address
op_assign
id|BaseAddress0
op_assign
id|pci_resource_start
c_func
(paren
id|PCI_Device
comma
l_int|0
)paren
suffix:semicolon
id|PCI_Address
op_assign
id|BaseAddress1
op_assign
id|pci_resource_start
c_func
(paren
id|PCI_Device
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_resource_flags
c_func
(paren
id|PCI_Device
comma
l_int|0
)paren
op_amp
id|IORESOURCE_MEM
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Base Address0 0x%X not I/O for &quot;
l_string|&quot;MultiMaster Host Adapter&bslash;n&quot;
comma
l_int|NULL
comma
id|BaseAddress0
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;at PCI Bus %d Device %d I/O Address 0x%X&bslash;n&quot;
comma
l_int|NULL
comma
id|Bus
comma
id|Device
comma
id|IO_Address
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pci_resource_flags
c_func
(paren
id|PCI_Device
comma
l_int|1
)paren
op_amp
id|IORESOURCE_IO
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Base Address1 0x%X not Memory for &quot;
l_string|&quot;MultiMaster Host Adapter&bslash;n&quot;
comma
l_int|NULL
comma
id|BaseAddress1
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;at PCI Bus %d Device %d PCI Address 0x%X&bslash;n&quot;
comma
l_int|NULL
comma
id|Bus
comma
id|Device
comma
id|PCI_Address
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IRQ_Channel
op_eq
l_int|0
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: IRQ Channel %d invalid for &quot;
l_string|&quot;MultiMaster Host Adapter&bslash;n&quot;
comma
l_int|NULL
comma
id|IRQ_Channel
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;at PCI Bus %d Device %d I/O Address 0x%X&bslash;n&quot;
comma
l_int|NULL
comma
id|Bus
comma
id|Device
comma
id|IO_Address
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BusLogic_GlobalOptions.TraceProbe
)paren
(brace
id|BusLogic_Notice
c_func
(paren
l_string|&quot;BusLogic: PCI MultiMaster Host Adapter &quot;
l_string|&quot;detected at&bslash;n&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|BusLogic_Notice
c_func
(paren
l_string|&quot;BusLogic: PCI Bus %d Device %d I/O Address &quot;
l_string|&quot;0x%X PCI Address 0x%X&bslash;n&quot;
comma
l_int|NULL
comma
id|Bus
comma
id|Device
comma
id|IO_Address
comma
id|PCI_Address
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;   Issue the Inquire PCI Host Adapter Information command to determine&n;&t;&t;   the ISA Compatible I/O Port.  If the ISA Compatible I/O Port is&n;&t;&t;   known and enabled, note that the particular Standard ISA I/O&n;&t;&t;   Address should not be probed.&n;&t;&t; */
id|HostAdapter-&gt;IO_Address
op_assign
id|IO_Address
suffix:semicolon
id|BusLogic_InterruptReset
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquirePCIHostAdapterInformation
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|PCIHostAdapterInformation
comma
r_sizeof
(paren
id|PCIHostAdapterInformation
)paren
)paren
op_eq
r_sizeof
(paren
id|PCIHostAdapterInformation
)paren
)paren
(brace
r_if
c_cond
(paren
id|PCIHostAdapterInformation.ISACompatibleIOPort
OL
l_int|6
)paren
id|StandardAddressSeen
(braket
id|PCIHostAdapterInformation.ISACompatibleIOPort
)braket
op_assign
l_bool|true
suffix:semicolon
)brace
r_else
id|PCIHostAdapterInformation.ISACompatibleIOPort
op_assign
id|BusLogic_IO_Disable
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Issue the Modify I/O Address command to disable the ISA Compatible&n;&t;&t; * I/O Port.  On PCI Host Adapters, the Modify I/O Address command&n;&t;&t; * allows modification of the ISA compatible I/O Address that the Host&n;&t;&t; * Adapter responds to; it does not affect the PCI compliant I/O Address&n;&t;&t; * assigned at system initialization.&n;&t;&t; */
id|ModifyIOAddressRequest
op_assign
id|BusLogic_IO_Disable
suffix:semicolon
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_ModifyIOAddress
comma
op_amp
id|ModifyIOAddressRequest
comma
r_sizeof
(paren
id|ModifyIOAddressRequest
)paren
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;   For the first MultiMaster Host Adapter enumerated, issue the Fetch&n;&t;&t;   Host Adapter Local RAM command to read byte 45 of the AutoSCSI area,&n;&t;&t;   for the setting of the &quot;Use Bus And Device # For PCI Scanning Seq.&quot;&n;&t;&t;   option.  Issue the Inquire Board ID command since this option is&n;&t;&t;   only valid for the BT-948/958/958D.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ForceBusDeviceScanningOrderChecked
)paren
(brace
r_struct
id|BusLogic_FetchHostAdapterLocalRAMRequest
id|FetchHostAdapterLocalRAMRequest
suffix:semicolon
r_struct
id|BusLogic_AutoSCSIByte45
id|AutoSCSIByte45
suffix:semicolon
r_struct
id|BusLogic_BoardID
id|BoardID
suffix:semicolon
id|FetchHostAdapterLocalRAMRequest.ByteOffset
op_assign
id|BusLogic_AutoSCSI_BaseOffset
op_plus
l_int|45
suffix:semicolon
id|FetchHostAdapterLocalRAMRequest.ByteCount
op_assign
r_sizeof
(paren
id|AutoSCSIByte45
)paren
suffix:semicolon
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_FetchHostAdapterLocalRAM
comma
op_amp
id|FetchHostAdapterLocalRAMRequest
comma
r_sizeof
(paren
id|FetchHostAdapterLocalRAMRequest
)paren
comma
op_amp
id|AutoSCSIByte45
comma
r_sizeof
(paren
id|AutoSCSIByte45
)paren
)paren
suffix:semicolon
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireBoardID
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|BoardID
comma
r_sizeof
(paren
id|BoardID
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BoardID.FirmwareVersion1stDigit
op_eq
l_char|&squot;5&squot;
)paren
id|ForceBusDeviceScanningOrder
op_assign
id|AutoSCSIByte45.ForceBusDeviceScanningOrder
suffix:semicolon
id|ForceBusDeviceScanningOrderChecked
op_assign
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;   Determine whether this MultiMaster Host Adapter has its ISA&n;&t;&t;   Compatible I/O Port enabled and is assigned the Primary I/O Address.&n;&t;&t;   If it does, then it is the Primary MultiMaster Host Adapter and must&n;&t;&t;   be recognized first.  If it does not, then it is added to the list&n;&t;&t;   for probing after any Primary MultiMaster Host Adapter is probed.&n;&t;&t; */
r_if
c_cond
(paren
id|PCIHostAdapterInformation.ISACompatibleIOPort
op_eq
id|BusLogic_IO_330
)paren
(brace
id|PrimaryProbeInfo-&gt;HostAdapterType
op_assign
id|BusLogic_MultiMaster
suffix:semicolon
id|PrimaryProbeInfo-&gt;HostAdapterBusType
op_assign
id|BusLogic_PCI_Bus
suffix:semicolon
id|PrimaryProbeInfo-&gt;IO_Address
op_assign
id|IO_Address
suffix:semicolon
id|PrimaryProbeInfo-&gt;PCI_Address
op_assign
id|PCI_Address
suffix:semicolon
id|PrimaryProbeInfo-&gt;Bus
op_assign
id|Bus
suffix:semicolon
id|PrimaryProbeInfo-&gt;Device
op_assign
id|Device
suffix:semicolon
id|PrimaryProbeInfo-&gt;IRQ_Channel
op_assign
id|IRQ_Channel
suffix:semicolon
id|PrimaryProbeInfo-&gt;PCI_Device
op_assign
id|PCI_Device
suffix:semicolon
id|PCIMultiMasterCount
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|BusLogic_ProbeInfoCount
OL
id|BusLogic_MaxHostAdapters
)paren
(brace
r_struct
id|BusLogic_ProbeInfo
op_star
id|ProbeInfo
op_assign
op_amp
id|BusLogic_ProbeInfoList
(braket
id|BusLogic_ProbeInfoCount
op_increment
)braket
suffix:semicolon
id|ProbeInfo-&gt;HostAdapterType
op_assign
id|BusLogic_MultiMaster
suffix:semicolon
id|ProbeInfo-&gt;HostAdapterBusType
op_assign
id|BusLogic_PCI_Bus
suffix:semicolon
id|ProbeInfo-&gt;IO_Address
op_assign
id|IO_Address
suffix:semicolon
id|ProbeInfo-&gt;PCI_Address
op_assign
id|PCI_Address
suffix:semicolon
id|ProbeInfo-&gt;Bus
op_assign
id|Bus
suffix:semicolon
id|ProbeInfo-&gt;Device
op_assign
id|Device
suffix:semicolon
id|ProbeInfo-&gt;IRQ_Channel
op_assign
id|IRQ_Channel
suffix:semicolon
id|ProbeInfo-&gt;PCI_Device
op_assign
id|PCI_Device
suffix:semicolon
id|NonPrimaryPCIMultiMasterCount
op_increment
suffix:semicolon
id|PCIMultiMasterCount
op_increment
suffix:semicolon
)brace
r_else
id|BusLogic_Warning
c_func
(paren
l_string|&quot;BusLogic: Too many Host Adapters &quot;
l_string|&quot;detected&bslash;n&quot;
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   If the AutoSCSI &quot;Use Bus And Device # For PCI Scanning Seq.&quot; option is ON&n;&t;   for the first enumerated MultiMaster Host Adapter, and if that host adapter&n;&t;   is a BT-948/958/958D, then the MultiMaster BIOS will recognize MultiMaster&n;&t;   Host Adapters in the order of increasing PCI Bus and Device Number.  In&n;&t;   that case, sort the probe information into the same order the BIOS uses.&n;&t;   If this option is OFF, then the MultiMaster BIOS will recognize MultiMaster&n;&t;   Host Adapters in the order they are enumerated by the PCI BIOS, and hence&n;&t;   no sorting is necessary.&n;&t; */
r_if
c_cond
(paren
id|ForceBusDeviceScanningOrder
)paren
id|BusLogic_SortProbeInfo
c_func
(paren
op_amp
id|BusLogic_ProbeInfoList
(braket
id|NonPrimaryPCIMultiMasterIndex
)braket
comma
id|NonPrimaryPCIMultiMasterCount
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   If no PCI MultiMaster Host Adapter is assigned the Primary I/O Address,&n;&t;   then the Primary I/O Address must be probed explicitly before any PCI&n;&t;   host adapters are probed.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|BusLogic_ProbeOptions.NoProbeISA
)paren
r_if
c_cond
(paren
id|PrimaryProbeInfo-&gt;IO_Address
op_eq
l_int|0
op_logical_and
(paren
id|BusLogic_ProbeOptions.LimitedProbeISA
ques
c_cond
id|BusLogic_ProbeOptions.Probe330
suffix:colon
id|check_region
c_func
(paren
l_int|0x330
comma
id|BusLogic_MultiMasterAddressCount
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|PrimaryProbeInfo-&gt;HostAdapterType
op_assign
id|BusLogic_MultiMaster
suffix:semicolon
id|PrimaryProbeInfo-&gt;HostAdapterBusType
op_assign
id|BusLogic_ISA_Bus
suffix:semicolon
id|PrimaryProbeInfo-&gt;IO_Address
op_assign
l_int|0x330
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Append the list of standard BusLogic MultiMaster ISA I/O Addresses,&n;&t;   omitting the Primary I/O Address which has already been handled.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|BusLogic_ProbeOptions.NoProbeISA
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|StandardAddressSeen
(braket
l_int|1
)braket
op_logical_and
(paren
id|BusLogic_ProbeOptions.LimitedProbeISA
ques
c_cond
id|BusLogic_ProbeOptions.Probe334
suffix:colon
id|check_region
c_func
(paren
l_int|0x334
comma
id|BusLogic_MultiMasterAddressCount
)paren
op_eq
l_int|0
)paren
)paren
id|BusLogic_AppendProbeAddressISA
c_func
(paren
l_int|0x334
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|StandardAddressSeen
(braket
l_int|2
)braket
op_logical_and
(paren
id|BusLogic_ProbeOptions.LimitedProbeISA
ques
c_cond
id|BusLogic_ProbeOptions.Probe230
suffix:colon
id|check_region
c_func
(paren
l_int|0x230
comma
id|BusLogic_MultiMasterAddressCount
)paren
op_eq
l_int|0
)paren
)paren
id|BusLogic_AppendProbeAddressISA
c_func
(paren
l_int|0x230
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|StandardAddressSeen
(braket
l_int|3
)braket
op_logical_and
(paren
id|BusLogic_ProbeOptions.LimitedProbeISA
ques
c_cond
id|BusLogic_ProbeOptions.Probe234
suffix:colon
id|check_region
c_func
(paren
l_int|0x234
comma
id|BusLogic_MultiMasterAddressCount
)paren
op_eq
l_int|0
)paren
)paren
id|BusLogic_AppendProbeAddressISA
c_func
(paren
l_int|0x234
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|StandardAddressSeen
(braket
l_int|4
)braket
op_logical_and
(paren
id|BusLogic_ProbeOptions.LimitedProbeISA
ques
c_cond
id|BusLogic_ProbeOptions.Probe130
suffix:colon
id|check_region
c_func
(paren
l_int|0x130
comma
id|BusLogic_MultiMasterAddressCount
)paren
op_eq
l_int|0
)paren
)paren
id|BusLogic_AppendProbeAddressISA
c_func
(paren
l_int|0x130
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|StandardAddressSeen
(braket
l_int|5
)braket
op_logical_and
(paren
id|BusLogic_ProbeOptions.LimitedProbeISA
ques
c_cond
id|BusLogic_ProbeOptions.Probe134
suffix:colon
id|check_region
c_func
(paren
l_int|0x134
comma
id|BusLogic_MultiMasterAddressCount
)paren
op_eq
l_int|0
)paren
)paren
id|BusLogic_AppendProbeAddressISA
c_func
(paren
l_int|0x134
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Iterate over the older non-compliant MultiMaster PCI Host Adapters,&n;&t;   noting the PCI bus location and assigned IRQ Channel.&n;&t; */
id|PCI_Device
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
(paren
id|PCI_Device
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_BUSLOGIC
comma
id|PCI_DEVICE_ID_BUSLOGIC_MULTIMASTER_NC
comma
id|PCI_Device
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
r_char
id|Bus
suffix:semicolon
r_int
r_char
id|Device
suffix:semicolon
r_int
r_int
id|IRQ_Channel
suffix:semicolon
r_int
r_int
id|IO_Address
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|PCI_Device
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pci_set_dma_mask
c_func
(paren
id|PCI_Device
comma
(paren
id|u64
)paren
l_int|0xffffffff
)paren
)paren
r_continue
suffix:semicolon
id|Bus
op_assign
id|PCI_Device-&gt;bus-&gt;number
suffix:semicolon
id|Device
op_assign
id|PCI_Device-&gt;devfn
op_rshift
l_int|3
suffix:semicolon
id|IRQ_Channel
op_assign
id|PCI_Device-&gt;irq
suffix:semicolon
id|IO_Address
op_assign
id|pci_resource_start
c_func
(paren
id|PCI_Device
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IO_Address
op_eq
l_int|0
op_logical_or
id|IRQ_Channel
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|BusLogic_ProbeInfoCount
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|BusLogic_ProbeInfo
op_star
id|ProbeInfo
op_assign
op_amp
id|BusLogic_ProbeInfoList
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ProbeInfo-&gt;IO_Address
op_eq
id|IO_Address
op_logical_and
id|ProbeInfo-&gt;HostAdapterType
op_eq
id|BusLogic_MultiMaster
)paren
(brace
id|ProbeInfo-&gt;HostAdapterBusType
op_assign
id|BusLogic_PCI_Bus
suffix:semicolon
id|ProbeInfo-&gt;PCI_Address
op_assign
l_int|0
suffix:semicolon
id|ProbeInfo-&gt;Bus
op_assign
id|Bus
suffix:semicolon
id|ProbeInfo-&gt;Device
op_assign
id|Device
suffix:semicolon
id|ProbeInfo-&gt;IRQ_Channel
op_assign
id|IRQ_Channel
suffix:semicolon
id|ProbeInfo-&gt;PCI_Device
op_assign
id|PCI_Device
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_return
id|PCIMultiMasterCount
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_InitializeFlashPointProbeInfo initializes the list of I/O Address&n;  and Bus Probe Information to be checked for potential BusLogic FlashPoint&n;  Host Adapters by interrogating the PCI Configuration Space.  It returns the&n;  number of FlashPoint Host Adapters found.&n;*/
DECL|function|BusLogic_InitializeFlashPointProbeInfo
r_static
r_int
id|__init
id|BusLogic_InitializeFlashPointProbeInfo
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|PrototypeHostAdapter
)paren
(brace
r_int
id|FlashPointIndex
op_assign
id|BusLogic_ProbeInfoCount
comma
id|FlashPointCount
op_assign
l_int|0
suffix:semicolon
r_struct
id|pci_dev
op_star
id|PCI_Device
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;   Interrogate PCI Configuration Space for any FlashPoint Host Adapters.&n;&t; */
r_while
c_loop
(paren
(paren
id|PCI_Device
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_BUSLOGIC
comma
id|PCI_DEVICE_ID_BUSLOGIC_FLASHPOINT
comma
id|PCI_Device
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
r_char
id|Bus
suffix:semicolon
r_int
r_char
id|Device
suffix:semicolon
r_int
r_int
id|IRQ_Channel
suffix:semicolon
r_int
r_int
id|BaseAddress0
suffix:semicolon
r_int
r_int
id|BaseAddress1
suffix:semicolon
r_int
r_int
id|IO_Address
suffix:semicolon
r_int
r_int
id|PCI_Address
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|PCI_Device
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pci_set_dma_mask
c_func
(paren
id|PCI_Device
comma
(paren
id|u64
)paren
l_int|0xffffffff
)paren
)paren
r_continue
suffix:semicolon
id|Bus
op_assign
id|PCI_Device-&gt;bus-&gt;number
suffix:semicolon
id|Device
op_assign
id|PCI_Device-&gt;devfn
op_rshift
l_int|3
suffix:semicolon
id|IRQ_Channel
op_assign
id|PCI_Device-&gt;irq
suffix:semicolon
id|IO_Address
op_assign
id|BaseAddress0
op_assign
id|pci_resource_start
c_func
(paren
id|PCI_Device
comma
l_int|0
)paren
suffix:semicolon
id|PCI_Address
op_assign
id|BaseAddress1
op_assign
id|pci_resource_start
c_func
(paren
id|PCI_Device
comma
l_int|1
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_SCSI_OMIT_FLASHPOINT
r_if
c_cond
(paren
id|pci_resource_flags
c_func
(paren
id|PCI_Device
comma
l_int|0
)paren
op_amp
id|IORESOURCE_MEM
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Base Address0 0x%X not I/O for &quot;
l_string|&quot;FlashPoint Host Adapter&bslash;n&quot;
comma
l_int|NULL
comma
id|BaseAddress0
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;at PCI Bus %d Device %d I/O Address 0x%X&bslash;n&quot;
comma
l_int|NULL
comma
id|Bus
comma
id|Device
comma
id|IO_Address
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pci_resource_flags
c_func
(paren
id|PCI_Device
comma
l_int|1
)paren
op_amp
id|IORESOURCE_IO
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Base Address1 0x%X not Memory for &quot;
l_string|&quot;FlashPoint Host Adapter&bslash;n&quot;
comma
l_int|NULL
comma
id|BaseAddress1
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;at PCI Bus %d Device %d PCI Address 0x%X&bslash;n&quot;
comma
l_int|NULL
comma
id|Bus
comma
id|Device
comma
id|PCI_Address
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IRQ_Channel
op_eq
l_int|0
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: IRQ Channel %d invalid for &quot;
l_string|&quot;FlashPoint Host Adapter&bslash;n&quot;
comma
l_int|NULL
comma
id|IRQ_Channel
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;at PCI Bus %d Device %d I/O Address 0x%X&bslash;n&quot;
comma
l_int|NULL
comma
id|Bus
comma
id|Device
comma
id|IO_Address
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BusLogic_GlobalOptions.TraceProbe
)paren
(brace
id|BusLogic_Notice
c_func
(paren
l_string|&quot;BusLogic: FlashPoint Host Adapter &quot;
l_string|&quot;detected at&bslash;n&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|BusLogic_Notice
c_func
(paren
l_string|&quot;BusLogic: PCI Bus %d Device %d I/O Address &quot;
l_string|&quot;0x%X PCI Address 0x%X&bslash;n&quot;
comma
l_int|NULL
comma
id|Bus
comma
id|Device
comma
id|IO_Address
comma
id|PCI_Address
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BusLogic_ProbeInfoCount
OL
id|BusLogic_MaxHostAdapters
)paren
(brace
r_struct
id|BusLogic_ProbeInfo
op_star
id|ProbeInfo
op_assign
op_amp
id|BusLogic_ProbeInfoList
(braket
id|BusLogic_ProbeInfoCount
op_increment
)braket
suffix:semicolon
id|ProbeInfo-&gt;HostAdapterType
op_assign
id|BusLogic_FlashPoint
suffix:semicolon
id|ProbeInfo-&gt;HostAdapterBusType
op_assign
id|BusLogic_PCI_Bus
suffix:semicolon
id|ProbeInfo-&gt;IO_Address
op_assign
id|IO_Address
suffix:semicolon
id|ProbeInfo-&gt;PCI_Address
op_assign
id|PCI_Address
suffix:semicolon
id|ProbeInfo-&gt;Bus
op_assign
id|Bus
suffix:semicolon
id|ProbeInfo-&gt;Device
op_assign
id|Device
suffix:semicolon
id|ProbeInfo-&gt;IRQ_Channel
op_assign
id|IRQ_Channel
suffix:semicolon
id|ProbeInfo-&gt;PCI_Device
op_assign
id|PCI_Device
suffix:semicolon
id|FlashPointCount
op_increment
suffix:semicolon
)brace
r_else
id|BusLogic_Warning
c_func
(paren
l_string|&quot;BusLogic: Too many Host Adapters &quot;
l_string|&quot;detected&bslash;n&quot;
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#else
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: FlashPoint Host Adapter detected at &quot;
l_string|&quot;PCI Bus %d Device %d&bslash;n&quot;
comma
l_int|NULL
comma
id|Bus
comma
id|Device
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: I/O Address 0x%X PCI Address 0x%X, irq %d, &quot;
l_string|&quot;but FlashPoint&bslash;n&quot;
comma
l_int|NULL
comma
id|IO_Address
comma
id|PCI_Address
comma
id|IRQ_Channel
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: support was omitted in this kernel &quot;
l_string|&quot;configuration.&bslash;n&quot;
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t;   The FlashPoint BIOS will scan for FlashPoint Host Adapters in the order of&n;&t;   increasing PCI Bus and Device Number, so sort the probe information into&n;&t;   the same order the BIOS uses.&n;&t; */
id|BusLogic_SortProbeInfo
c_func
(paren
op_amp
id|BusLogic_ProbeInfoList
(braket
id|FlashPointIndex
)braket
comma
id|FlashPointCount
)paren
suffix:semicolon
r_return
id|FlashPointCount
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_InitializeProbeInfoList initializes the list of I/O Address and Bus&n;  Probe Information to be checked for potential BusLogic SCSI Host Adapters by&n;  interrogating the PCI Configuration Space on PCI machines as well as from the&n;  list of standard BusLogic MultiMaster ISA I/O Addresses.  By default, if both&n;  FlashPoint and PCI MultiMaster Host Adapters are present, this driver will&n;  probe for FlashPoint Host Adapters first unless the BIOS primary disk is&n;  controlled by the first PCI MultiMaster Host Adapter, in which case&n;  MultiMaster Host Adapters will be probed first.  The BusLogic Driver Options&n;  specifications &quot;MultiMasterFirst&quot; and &quot;FlashPointFirst&quot; can be used to force&n;  a particular probe order.&n;*/
DECL|function|BusLogic_InitializeProbeInfoList
r_static
r_void
id|__init
id|BusLogic_InitializeProbeInfoList
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|PrototypeHostAdapter
)paren
(brace
multiline_comment|/*&n;&t;   If a PCI BIOS is present, interrogate it for MultiMaster and FlashPoint&n;&t;   Host Adapters; otherwise, default to the standard ISA MultiMaster probe.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|BusLogic_ProbeOptions.NoProbePCI
)paren
(brace
r_if
c_cond
(paren
id|BusLogic_ProbeOptions.MultiMasterFirst
)paren
(brace
id|BusLogic_InitializeMultiMasterProbeInfo
c_func
(paren
id|PrototypeHostAdapter
)paren
suffix:semicolon
id|BusLogic_InitializeFlashPointProbeInfo
c_func
(paren
id|PrototypeHostAdapter
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|BusLogic_ProbeOptions.FlashPointFirst
)paren
(brace
id|BusLogic_InitializeFlashPointProbeInfo
c_func
(paren
id|PrototypeHostAdapter
)paren
suffix:semicolon
id|BusLogic_InitializeMultiMasterProbeInfo
c_func
(paren
id|PrototypeHostAdapter
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|FlashPointCount
op_assign
id|BusLogic_InitializeFlashPointProbeInfo
c_func
(paren
id|PrototypeHostAdapter
)paren
suffix:semicolon
r_int
id|PCIMultiMasterCount
op_assign
id|BusLogic_InitializeMultiMasterProbeInfo
c_func
(paren
id|PrototypeHostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FlashPointCount
OG
l_int|0
op_logical_and
id|PCIMultiMasterCount
OG
l_int|0
)paren
(brace
r_struct
id|BusLogic_ProbeInfo
op_star
id|ProbeInfo
op_assign
op_amp
id|BusLogic_ProbeInfoList
(braket
id|FlashPointCount
)braket
suffix:semicolon
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
op_assign
id|PrototypeHostAdapter
suffix:semicolon
r_struct
id|BusLogic_FetchHostAdapterLocalRAMRequest
id|FetchHostAdapterLocalRAMRequest
suffix:semicolon
r_struct
id|BusLogic_BIOSDriveMapByte
id|Drive0MapByte
suffix:semicolon
r_while
c_loop
(paren
id|ProbeInfo-&gt;HostAdapterBusType
op_ne
id|BusLogic_PCI_Bus
)paren
id|ProbeInfo
op_increment
suffix:semicolon
id|HostAdapter-&gt;IO_Address
op_assign
id|ProbeInfo-&gt;IO_Address
suffix:semicolon
id|FetchHostAdapterLocalRAMRequest.ByteOffset
op_assign
id|BusLogic_BIOS_BaseOffset
op_plus
id|BusLogic_BIOS_DriveMapOffset
op_plus
l_int|0
suffix:semicolon
id|FetchHostAdapterLocalRAMRequest.ByteCount
op_assign
r_sizeof
(paren
id|Drive0MapByte
)paren
suffix:semicolon
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_FetchHostAdapterLocalRAM
comma
op_amp
id|FetchHostAdapterLocalRAMRequest
comma
r_sizeof
(paren
id|FetchHostAdapterLocalRAMRequest
)paren
comma
op_amp
id|Drive0MapByte
comma
r_sizeof
(paren
id|Drive0MapByte
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;   If the Map Byte for BIOS Drive 0 indicates that BIOS Drive 0&n;&t;&t;&t;&t;   is controlled by this PCI MultiMaster Host Adapter, then&n;&t;&t;&t;&t;   reverse the probe order so that MultiMaster Host Adapters are&n;&t;&t;&t;&t;   probed before FlashPoint Host Adapters.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Drive0MapByte.DiskGeometry
op_ne
id|BusLogic_BIOS_Disk_Not_Installed
)paren
(brace
r_struct
id|BusLogic_ProbeInfo
id|SavedProbeInfo
(braket
id|BusLogic_MaxHostAdapters
)braket
suffix:semicolon
r_int
id|MultiMasterCount
op_assign
id|BusLogic_ProbeInfoCount
op_minus
id|FlashPointCount
suffix:semicolon
id|memcpy
c_func
(paren
id|SavedProbeInfo
comma
id|BusLogic_ProbeInfoList
comma
id|BusLogic_ProbeInfoCount
op_star
r_sizeof
(paren
r_struct
id|BusLogic_ProbeInfo
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|BusLogic_ProbeInfoList
(braket
l_int|0
)braket
comma
op_amp
id|SavedProbeInfo
(braket
id|FlashPointCount
)braket
comma
id|MultiMasterCount
op_star
r_sizeof
(paren
r_struct
id|BusLogic_ProbeInfo
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|BusLogic_ProbeInfoList
(braket
id|MultiMasterCount
)braket
comma
op_amp
id|SavedProbeInfo
(braket
l_int|0
)braket
comma
id|FlashPointCount
op_star
r_sizeof
(paren
r_struct
id|BusLogic_ProbeInfo
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
id|BusLogic_InitializeProbeInfoListISA
c_func
(paren
id|PrototypeHostAdapter
)paren
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* CONFIG_PCI */
multiline_comment|/*&n;  BusLogic_Failure prints a standardized error message, and then returns false.&n;*/
DECL|function|BusLogic_Failure
r_static
id|boolean
id|BusLogic_Failure
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
comma
r_char
op_star
id|ErrorMessage
)paren
(brace
id|BusLogic_AnnounceDriver
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterBusType
op_eq
id|BusLogic_PCI_Bus
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;While configuring BusLogic PCI Host Adapter at&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;Bus %d Device %d I/O Address 0x%X PCI Address 0x%X:&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;Bus
comma
id|HostAdapter-&gt;Device
comma
id|HostAdapter-&gt;IO_Address
comma
id|HostAdapter-&gt;PCI_Address
)paren
suffix:semicolon
)brace
r_else
id|BusLogic_Error
c_func
(paren
l_string|&quot;While configuring BusLogic Host Adapter at &quot;
l_string|&quot;I/O Address 0x%X:&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;IO_Address
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;%s FAILED - DETACHING&bslash;n&quot;
comma
id|HostAdapter
comma
id|ErrorMessage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_CommandFailureReason
op_ne
l_int|NULL
)paren
id|BusLogic_Error
c_func
(paren
l_string|&quot;ADDITIONAL FAILURE INFO - %s&bslash;n&quot;
comma
id|HostAdapter
comma
id|BusLogic_CommandFailureReason
)paren
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ProbeHostAdapter probes for a BusLogic Host Adapter.&n;*/
DECL|function|BusLogic_ProbeHostAdapter
r_static
id|boolean
id|__init
id|BusLogic_ProbeHostAdapter
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
)paren
(brace
r_union
id|BusLogic_StatusRegister
id|StatusRegister
suffix:semicolon
r_union
id|BusLogic_InterruptRegister
id|InterruptRegister
suffix:semicolon
r_union
id|BusLogic_GeometryRegister
id|GeometryRegister
suffix:semicolon
multiline_comment|/*&n;&t;   FlashPoint Host Adapters are Probed by the FlashPoint SCCB Manager.&n;&t; */
r_if
c_cond
(paren
id|BusLogic_FlashPointHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
(brace
r_struct
id|FlashPoint_Info
op_star
id|FlashPointInfo
op_assign
op_amp
id|HostAdapter-&gt;FlashPointInfo
suffix:semicolon
id|FlashPointInfo-&gt;BaseAddress
op_assign
(paren
id|u32
)paren
id|HostAdapter-&gt;IO_Address
suffix:semicolon
id|FlashPointInfo-&gt;IRQ_Channel
op_assign
id|HostAdapter-&gt;IRQ_Channel
suffix:semicolon
id|FlashPointInfo-&gt;Present
op_assign
l_bool|false
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|FlashPoint_ProbeHostAdapter
c_func
(paren
id|FlashPointInfo
)paren
op_eq
l_int|0
op_logical_and
id|FlashPointInfo-&gt;Present
)paren
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: FlashPoint Host Adapter detected at &quot;
l_string|&quot;PCI Bus %d Device %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;Bus
comma
id|HostAdapter-&gt;Device
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: I/O Address 0x%X PCI Address 0x%X, &quot;
l_string|&quot;but FlashPoint&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;IO_Address
comma
id|HostAdapter-&gt;PCI_Address
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Probe Function failed to validate it.&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BusLogic_GlobalOptions.TraceProbe
)paren
id|BusLogic_Notice
c_func
(paren
l_string|&quot;BusLogic_Probe(0x%X): FlashPoint Found&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;IO_Address
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;   Indicate the Host Adapter Probe completed successfully.&n;&t;&t; */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Read the Status, Interrupt, and Geometry Registers to test if there are I/O&n;&t;   ports that respond, and to check the values to determine if they are from a&n;&t;   BusLogic Host Adapter.  A nonexistent I/O port will return 0xFF, in which&n;&t;   case there is definitely no BusLogic Host Adapter at this base I/O Address.&n;&t;   The test here is a subset of that used by the BusLogic Host Adapter BIOS.&n;&t; */
id|StatusRegister.All
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|InterruptRegister.All
op_assign
id|BusLogic_ReadInterruptRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|GeometryRegister.All
op_assign
id|BusLogic_ReadGeometryRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_GlobalOptions.TraceProbe
)paren
id|BusLogic_Notice
c_func
(paren
l_string|&quot;BusLogic_Probe(0x%X): Status 0x%02X, Interrupt 0x%02X, &quot;
l_string|&quot;Geometry 0x%02X&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;IO_Address
comma
id|StatusRegister.All
comma
id|InterruptRegister.All
comma
id|GeometryRegister.All
)paren
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister.All
op_eq
l_int|0
op_logical_or
id|StatusRegister.sr.DiagnosticActive
op_logical_or
id|StatusRegister.sr.CommandParameterRegisterBusy
op_logical_or
id|StatusRegister.sr.Reserved
op_logical_or
id|StatusRegister.sr.CommandInvalid
op_logical_or
id|InterruptRegister.ir.Reserved
op_ne
l_int|0
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/*&n;&t;   Check the undocumented Geometry Register to test if there is an I/O port&n;&t;   that responded.  Adaptec Host Adapters do not implement the Geometry&n;&t;   Register, so this test helps serve to avoid incorrectly recognizing an&n;&t;   Adaptec 1542A or 1542B as a BusLogic.  Unfortunately, the Adaptec 1542C&n;&t;   series does respond to the Geometry Register I/O port, but it will be&n;&t;   rejected later when the Inquire Extended Setup Information command is&n;&t;   issued in BusLogic_CheckHostAdapter.  The AMI FastDisk Host Adapter is a&n;&t;   BusLogic clone that implements the same interface as earlier BusLogic&n;&t;   Host Adapters, including the undocumented commands, and is therefore&n;&t;   supported by this driver.  However, the AMI FastDisk always returns 0x00&n;&t;   upon reading the Geometry Register, so the extended translation option&n;&t;   should always be left disabled on the AMI FastDisk.&n;&t; */
r_if
c_cond
(paren
id|GeometryRegister.All
op_eq
l_int|0xFF
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/*&n;&t;   Indicate the Host Adapter Probe completed successfully.&n;&t; */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_HardwareResetHostAdapter issues a Hardware Reset to the Host Adapter&n;  and waits for Host Adapter Diagnostics to complete.  If HardReset is true, a&n;  Hard Reset is performed which also initiates a SCSI Bus Reset.  Otherwise, a&n;  Soft Reset is performed which only resets the Host Adapter without forcing a&n;  SCSI Bus Reset.&n;*/
DECL|function|BusLogic_HardwareResetHostAdapter
r_static
id|boolean
id|BusLogic_HardwareResetHostAdapter
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
comma
id|boolean
id|HardReset
)paren
(brace
r_union
id|BusLogic_StatusRegister
id|StatusRegister
suffix:semicolon
r_int
id|TimeoutCounter
suffix:semicolon
multiline_comment|/*&n;&t;   FlashPoint Host Adapters are Hard Reset by the FlashPoint SCCB Manager.&n;&t; */
r_if
c_cond
(paren
id|BusLogic_FlashPointHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
(brace
r_struct
id|FlashPoint_Info
op_star
id|FlashPointInfo
op_assign
op_amp
id|HostAdapter-&gt;FlashPointInfo
suffix:semicolon
id|FlashPointInfo-&gt;HostSoftReset
op_assign
op_logical_neg
id|HardReset
suffix:semicolon
id|FlashPointInfo-&gt;ReportDataUnderrun
op_assign
l_bool|true
suffix:semicolon
id|HostAdapter-&gt;CardHandle
op_assign
id|FlashPoint_HardwareResetHostAdapter
c_func
(paren
id|FlashPointInfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;CardHandle
op_eq
id|FlashPoint_BadCardHandle
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/*&n;&t;&t;   Indicate the Host Adapter Hard Reset completed successfully.&n;&t;&t; */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Issue a Hard Reset or Soft Reset Command to the Host Adapter.  The Host&n;&t;   Adapter should respond by setting Diagnostic Active in the Status Register.&n;&t; */
r_if
c_cond
(paren
id|HardReset
)paren
id|BusLogic_HardReset
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_else
id|BusLogic_SoftReset
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   Wait until Diagnostic Active is set in the Status Register.&n;&t; */
id|TimeoutCounter
op_assign
l_int|5
op_star
l_int|10000
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|TimeoutCounter
op_ge
l_int|0
)paren
(brace
id|StatusRegister.All
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister.sr.DiagnosticActive
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BusLogic_GlobalOptions.TraceHardwareReset
)paren
id|BusLogic_Notice
c_func
(paren
l_string|&quot;BusLogic_HardwareReset(0x%X): Diagnostic Active, &quot;
l_string|&quot;Status 0x%02X&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;IO_Address
comma
id|StatusRegister.All
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TimeoutCounter
OL
l_int|0
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/*&n;&t;   Wait 100 microseconds to allow completion of any initial diagnostic&n;&t;   activity which might leave the contents of the Status Register&n;&t;   unpredictable.&n;&t; */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   Wait until Diagnostic Active is reset in the Status Register.&n;&t; */
id|TimeoutCounter
op_assign
l_int|10
op_star
l_int|10000
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|TimeoutCounter
op_ge
l_int|0
)paren
(brace
id|StatusRegister.All
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|StatusRegister.sr.DiagnosticActive
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BusLogic_GlobalOptions.TraceHardwareReset
)paren
id|BusLogic_Notice
c_func
(paren
l_string|&quot;BusLogic_HardwareReset(0x%X): Diagnostic Completed, &quot;
l_string|&quot;Status 0x%02X&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;IO_Address
comma
id|StatusRegister.All
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TimeoutCounter
OL
l_int|0
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/*&n;&t;   Wait until at least one of the Diagnostic Failure, Host Adapter Ready,&n;&t;   or Data In Register Ready bits is set in the Status Register.&n;&t; */
id|TimeoutCounter
op_assign
l_int|10000
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|TimeoutCounter
op_ge
l_int|0
)paren
(brace
id|StatusRegister.All
op_assign
id|BusLogic_ReadStatusRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister.sr.DiagnosticFailure
op_logical_or
id|StatusRegister.sr.HostAdapterReady
op_logical_or
id|StatusRegister.sr.DataInRegisterReady
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BusLogic_GlobalOptions.TraceHardwareReset
)paren
id|BusLogic_Notice
c_func
(paren
l_string|&quot;BusLogic_HardwareReset(0x%X): Host Adapter Ready, &quot;
l_string|&quot;Status 0x%02X&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;IO_Address
comma
id|StatusRegister.All
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TimeoutCounter
OL
l_int|0
)paren
r_return
l_bool|false
suffix:semicolon
multiline_comment|/*&n;&t;   If Diagnostic Failure is set or Host Adapter Ready is reset, then an&n;&t;   error occurred during the Host Adapter diagnostics.  If Data In Register&n;&t;   Ready is set, then there is an Error Code available.&n;&t; */
r_if
c_cond
(paren
id|StatusRegister.sr.DiagnosticFailure
op_logical_or
op_logical_neg
id|StatusRegister.sr.HostAdapterReady
)paren
(brace
id|BusLogic_CommandFailureReason
op_assign
l_int|NULL
suffix:semicolon
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;HARD RESET DIAGNOSTICS&quot;
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;HOST ADAPTER STATUS REGISTER = %02X&bslash;n&quot;
comma
id|HostAdapter
comma
id|StatusRegister.All
)paren
suffix:semicolon
r_if
c_cond
(paren
id|StatusRegister.sr.DataInRegisterReady
)paren
(brace
r_int
r_char
id|ErrorCode
op_assign
id|BusLogic_ReadDataInRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;HOST ADAPTER ERROR CODE = %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|ErrorCode
)paren
suffix:semicolon
)brace
r_return
l_bool|false
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Indicate the Host Adapter Hard Reset completed successfully.&n;&t; */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_CheckHostAdapter checks to be sure this really is a BusLogic&n;  Host Adapter.&n;*/
DECL|function|BusLogic_CheckHostAdapter
r_static
id|boolean
id|__init
id|BusLogic_CheckHostAdapter
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
)paren
(brace
r_struct
id|BusLogic_ExtendedSetupInformation
id|ExtendedSetupInformation
suffix:semicolon
r_int
r_char
id|RequestedReplyLength
suffix:semicolon
id|boolean
id|Result
op_assign
l_bool|true
suffix:semicolon
multiline_comment|/*&n;&t;   FlashPoint Host Adapters do not require this protection.&n;&t; */
r_if
c_cond
(paren
id|BusLogic_FlashPointHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
r_return
l_bool|true
suffix:semicolon
multiline_comment|/*&n;&t;   Issue the Inquire Extended Setup Information command.  Only genuine&n;&t;   BusLogic Host Adapters and true clones support this command.  Adaptec 1542C&n;&t;   series Host Adapters that respond to the Geometry Register I/O port will&n;&t;   fail this command.&n;&t; */
id|RequestedReplyLength
op_assign
r_sizeof
(paren
id|ExtendedSetupInformation
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireExtendedSetupInformation
comma
op_amp
id|RequestedReplyLength
comma
r_sizeof
(paren
id|RequestedReplyLength
)paren
comma
op_amp
id|ExtendedSetupInformation
comma
r_sizeof
(paren
id|ExtendedSetupInformation
)paren
)paren
op_ne
r_sizeof
(paren
id|ExtendedSetupInformation
)paren
)paren
id|Result
op_assign
l_bool|false
suffix:semicolon
multiline_comment|/*&n;&t;   Provide tracing information if requested and return.&n;&t; */
r_if
c_cond
(paren
id|BusLogic_GlobalOptions.TraceProbe
)paren
id|BusLogic_Notice
c_func
(paren
l_string|&quot;BusLogic_Check(0x%X): MultiMaster %s&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;IO_Address
comma
(paren
id|Result
ques
c_cond
l_string|&quot;Found&quot;
suffix:colon
l_string|&quot;Not Found&quot;
)paren
)paren
suffix:semicolon
r_return
id|Result
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ReadHostAdapterConfiguration reads the Configuration Information&n;  from Host Adapter and initializes the Host Adapter structure.&n;*/
DECL|function|BusLogic_ReadHostAdapterConfiguration
r_static
id|boolean
id|__init
id|BusLogic_ReadHostAdapterConfiguration
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
)paren
(brace
r_struct
id|BusLogic_BoardID
id|BoardID
suffix:semicolon
r_struct
id|BusLogic_Configuration
id|Configuration
suffix:semicolon
r_struct
id|BusLogic_SetupInformation
id|SetupInformation
suffix:semicolon
r_struct
id|BusLogic_ExtendedSetupInformation
id|ExtendedSetupInformation
suffix:semicolon
r_int
r_char
id|HostAdapterModelNumber
(braket
l_int|5
)braket
suffix:semicolon
r_int
r_char
id|FirmwareVersion3rdDigit
suffix:semicolon
r_int
r_char
id|FirmwareVersionLetter
suffix:semicolon
r_struct
id|BusLogic_PCIHostAdapterInformation
id|PCIHostAdapterInformation
suffix:semicolon
r_struct
id|BusLogic_FetchHostAdapterLocalRAMRequest
id|FetchHostAdapterLocalRAMRequest
suffix:semicolon
r_struct
id|BusLogic_AutoSCSIData
id|AutoSCSIData
suffix:semicolon
r_union
id|BusLogic_GeometryRegister
id|GeometryRegister
suffix:semicolon
r_int
r_char
id|RequestedReplyLength
suffix:semicolon
r_int
r_char
op_star
id|TargetPointer
comma
id|Character
suffix:semicolon
r_int
id|TargetID
comma
id|i
suffix:semicolon
multiline_comment|/*&n;&t;   Configuration Information for FlashPoint Host Adapters is provided in the&n;&t;   FlashPoint_Info structure by the FlashPoint SCCB Manager&squot;s Probe Function.&n;&t;   Initialize fields in the Host Adapter structure from the FlashPoint_Info&n;&t;   structure.&n;&t; */
r_if
c_cond
(paren
id|BusLogic_FlashPointHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
(brace
r_struct
id|FlashPoint_Info
op_star
id|FlashPointInfo
op_assign
op_amp
id|HostAdapter-&gt;FlashPointInfo
suffix:semicolon
id|TargetPointer
op_assign
id|HostAdapter-&gt;ModelName
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
l_char|&squot;B&squot;
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
l_char|&squot;T&squot;
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
l_char|&squot;-&squot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|FlashPointInfo-&gt;ModelNumber
)paren
suffix:semicolon
id|i
op_increment
)paren
op_star
id|TargetPointer
op_increment
op_assign
id|FlashPointInfo-&gt;ModelNumber
(braket
id|i
)braket
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|strcpy
c_func
(paren
id|HostAdapter-&gt;FirmwareVersion
comma
id|FlashPoint_FirmwareVersion
)paren
suffix:semicolon
id|HostAdapter-&gt;SCSI_ID
op_assign
id|FlashPointInfo-&gt;SCSI_ID
suffix:semicolon
id|HostAdapter-&gt;ExtendedTranslationEnabled
op_assign
id|FlashPointInfo-&gt;ExtendedTranslationEnabled
suffix:semicolon
id|HostAdapter-&gt;ParityCheckingEnabled
op_assign
id|FlashPointInfo-&gt;ParityCheckingEnabled
suffix:semicolon
id|HostAdapter-&gt;BusResetEnabled
op_assign
op_logical_neg
id|FlashPointInfo-&gt;HostSoftReset
suffix:semicolon
id|HostAdapter-&gt;LevelSensitiveInterrupt
op_assign
l_bool|true
suffix:semicolon
id|HostAdapter-&gt;HostWideSCSI
op_assign
id|FlashPointInfo-&gt;HostWideSCSI
suffix:semicolon
id|HostAdapter-&gt;HostDifferentialSCSI
op_assign
l_bool|false
suffix:semicolon
id|HostAdapter-&gt;HostSupportsSCAM
op_assign
l_bool|true
suffix:semicolon
id|HostAdapter-&gt;HostUltraSCSI
op_assign
l_bool|true
suffix:semicolon
id|HostAdapter-&gt;ExtendedLUNSupport
op_assign
l_bool|true
suffix:semicolon
id|HostAdapter-&gt;TerminationInfoValid
op_assign
l_bool|true
suffix:semicolon
id|HostAdapter-&gt;LowByteTerminated
op_assign
id|FlashPointInfo-&gt;LowByteTerminated
suffix:semicolon
id|HostAdapter-&gt;HighByteTerminated
op_assign
id|FlashPointInfo-&gt;HighByteTerminated
suffix:semicolon
id|HostAdapter-&gt;SCAM_Enabled
op_assign
id|FlashPointInfo-&gt;SCAM_Enabled
suffix:semicolon
id|HostAdapter-&gt;SCAM_Level2
op_assign
id|FlashPointInfo-&gt;SCAM_Level2
suffix:semicolon
id|HostAdapter-&gt;DriverScatterGatherLimit
op_assign
id|BusLogic_ScatterGatherLimit
suffix:semicolon
id|HostAdapter-&gt;MaxTargetDevices
op_assign
(paren
id|HostAdapter-&gt;HostWideSCSI
ques
c_cond
l_int|16
suffix:colon
l_int|8
)paren
suffix:semicolon
id|HostAdapter-&gt;MaxLogicalUnits
op_assign
l_int|32
suffix:semicolon
id|HostAdapter-&gt;InitialCCBs
op_assign
l_int|4
op_star
id|BusLogic_CCB_AllocationGroupSize
suffix:semicolon
id|HostAdapter-&gt;IncrementalCCBs
op_assign
id|BusLogic_CCB_AllocationGroupSize
suffix:semicolon
id|HostAdapter-&gt;DriverQueueDepth
op_assign
l_int|255
suffix:semicolon
id|HostAdapter-&gt;HostAdapterQueueDepth
op_assign
id|HostAdapter-&gt;DriverQueueDepth
suffix:semicolon
id|HostAdapter-&gt;SynchronousPermitted
op_assign
id|FlashPointInfo-&gt;SynchronousPermitted
suffix:semicolon
id|HostAdapter-&gt;FastPermitted
op_assign
id|FlashPointInfo-&gt;FastPermitted
suffix:semicolon
id|HostAdapter-&gt;UltraPermitted
op_assign
id|FlashPointInfo-&gt;UltraPermitted
suffix:semicolon
id|HostAdapter-&gt;WidePermitted
op_assign
id|FlashPointInfo-&gt;WidePermitted
suffix:semicolon
id|HostAdapter-&gt;DisconnectPermitted
op_assign
id|FlashPointInfo-&gt;DisconnectPermitted
suffix:semicolon
id|HostAdapter-&gt;TaggedQueuingPermitted
op_assign
l_int|0xFFFF
suffix:semicolon
r_goto
id|Common
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Issue the Inquire Board ID command.&n;&t; */
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireBoardID
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|BoardID
comma
r_sizeof
(paren
id|BoardID
)paren
)paren
op_ne
r_sizeof
(paren
id|BoardID
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE BOARD ID&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   Issue the Inquire Configuration command.&n;&t; */
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireConfiguration
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|Configuration
comma
r_sizeof
(paren
id|Configuration
)paren
)paren
op_ne
r_sizeof
(paren
id|Configuration
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE CONFIGURATION&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   Issue the Inquire Setup Information command.&n;&t; */
id|RequestedReplyLength
op_assign
r_sizeof
(paren
id|SetupInformation
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireSetupInformation
comma
op_amp
id|RequestedReplyLength
comma
r_sizeof
(paren
id|RequestedReplyLength
)paren
comma
op_amp
id|SetupInformation
comma
r_sizeof
(paren
id|SetupInformation
)paren
)paren
op_ne
r_sizeof
(paren
id|SetupInformation
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE SETUP INFORMATION&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   Issue the Inquire Extended Setup Information command.&n;&t; */
id|RequestedReplyLength
op_assign
r_sizeof
(paren
id|ExtendedSetupInformation
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireExtendedSetupInformation
comma
op_amp
id|RequestedReplyLength
comma
r_sizeof
(paren
id|RequestedReplyLength
)paren
comma
op_amp
id|ExtendedSetupInformation
comma
r_sizeof
(paren
id|ExtendedSetupInformation
)paren
)paren
op_ne
r_sizeof
(paren
id|ExtendedSetupInformation
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE EXTENDED SETUP INFORMATION&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   Issue the Inquire Firmware Version 3rd Digit command.&n;&t; */
id|FirmwareVersion3rdDigit
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|BoardID.FirmwareVersion1stDigit
OG
l_char|&squot;0&squot;
)paren
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireFirmwareVersion3rdDigit
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|FirmwareVersion3rdDigit
comma
r_sizeof
(paren
id|FirmwareVersion3rdDigit
)paren
)paren
op_ne
r_sizeof
(paren
id|FirmwareVersion3rdDigit
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE FIRMWARE 3RD DIGIT&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   Issue the Inquire Host Adapter Model Number command.&n;&t; */
r_if
c_cond
(paren
id|ExtendedSetupInformation.BusType
op_eq
l_char|&squot;A&squot;
op_logical_and
id|BoardID.FirmwareVersion1stDigit
op_eq
l_char|&squot;2&squot;
)paren
multiline_comment|/* BusLogic BT-542B ISA 2.xx */
id|strcpy
c_func
(paren
id|HostAdapterModelNumber
comma
l_string|&quot;542B&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ExtendedSetupInformation.BusType
op_eq
l_char|&squot;E&squot;
op_logical_and
id|BoardID.FirmwareVersion1stDigit
op_eq
l_char|&squot;2&squot;
op_logical_and
(paren
id|BoardID.FirmwareVersion2ndDigit
op_le
l_char|&squot;1&squot;
op_logical_or
(paren
id|BoardID.FirmwareVersion2ndDigit
op_eq
l_char|&squot;2&squot;
op_logical_and
id|FirmwareVersion3rdDigit
op_eq
l_char|&squot;0&squot;
)paren
)paren
)paren
multiline_comment|/* BusLogic BT-742A EISA 2.1x or 2.20 */
id|strcpy
c_func
(paren
id|HostAdapterModelNumber
comma
l_string|&quot;742A&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ExtendedSetupInformation.BusType
op_eq
l_char|&squot;E&squot;
op_logical_and
id|BoardID.FirmwareVersion1stDigit
op_eq
l_char|&squot;0&squot;
)paren
multiline_comment|/* AMI FastDisk EISA Series 441 0.x */
id|strcpy
c_func
(paren
id|HostAdapterModelNumber
comma
l_string|&quot;747A&quot;
)paren
suffix:semicolon
r_else
(brace
id|RequestedReplyLength
op_assign
r_sizeof
(paren
id|HostAdapterModelNumber
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireHostAdapterModelNumber
comma
op_amp
id|RequestedReplyLength
comma
r_sizeof
(paren
id|RequestedReplyLength
)paren
comma
op_amp
id|HostAdapterModelNumber
comma
r_sizeof
(paren
id|HostAdapterModelNumber
)paren
)paren
op_ne
r_sizeof
(paren
id|HostAdapterModelNumber
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE HOST ADAPTER MODEL NUMBER&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   BusLogic MultiMaster Host Adapters can be identified by their model number&n;&t;   and the major version number of their firmware as follows:&n;&n;&t;   5.xx       BusLogic &quot;W&quot; Series Host Adapters:&n;&t;   BT-948/958/958D&n;&t;   4.xx       BusLogic &quot;C&quot; Series Host Adapters:&n;&t;   BT-946C/956C/956CD/747C/757C/757CD/445C/545C/540CF&n;&t;   3.xx       BusLogic &quot;S&quot; Series Host Adapters:&n;&t;   BT-747S/747D/757S/757D/445S/545S/542D&n;&t;   BT-542B/742A (revision H)&n;&t;   2.xx       BusLogic &quot;A&quot; Series Host Adapters:&n;&t;   BT-542B/742A (revision G and below)&n;&t;   0.xx       AMI FastDisk VLB/EISA BusLogic Clone Host Adapter&n;&t; */
multiline_comment|/*&n;&t;   Save the Model Name and Host Adapter Name in the Host Adapter structure.&n;&t; */
id|TargetPointer
op_assign
id|HostAdapter-&gt;ModelName
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
l_char|&squot;B&squot;
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
l_char|&squot;T&squot;
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
l_char|&squot;-&squot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|HostAdapterModelNumber
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|Character
op_assign
id|HostAdapterModelNumber
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|Character
op_eq
l_char|&squot; &squot;
op_logical_or
id|Character
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_break
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
id|Character
suffix:semicolon
)brace
op_star
id|TargetPointer
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/*&n;&t;   Save the Firmware Version in the Host Adapter structure.&n;&t; */
id|TargetPointer
op_assign
id|HostAdapter-&gt;FirmwareVersion
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
id|BoardID.FirmwareVersion1stDigit
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
l_char|&squot;.&squot;
suffix:semicolon
op_star
id|TargetPointer
op_increment
op_assign
id|BoardID.FirmwareVersion2ndDigit
suffix:semicolon
r_if
c_cond
(paren
id|FirmwareVersion3rdDigit
op_ne
l_char|&squot; &squot;
op_logical_and
id|FirmwareVersion3rdDigit
op_ne
l_char|&squot;&bslash;0&squot;
)paren
op_star
id|TargetPointer
op_increment
op_assign
id|FirmwareVersion3rdDigit
suffix:semicolon
op_star
id|TargetPointer
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/*&n;&t;   Issue the Inquire Firmware Version Letter command.&n;&t; */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|HostAdapter-&gt;FirmwareVersion
comma
l_string|&quot;3.3&quot;
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireFirmwareVersionLetter
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|FirmwareVersionLetter
comma
r_sizeof
(paren
id|FirmwareVersionLetter
)paren
)paren
op_ne
r_sizeof
(paren
id|FirmwareVersionLetter
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE FIRMWARE VERSION LETTER&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FirmwareVersionLetter
op_ne
l_char|&squot; &squot;
op_logical_and
id|FirmwareVersionLetter
op_ne
l_char|&squot;&bslash;0&squot;
)paren
op_star
id|TargetPointer
op_increment
op_assign
id|FirmwareVersionLetter
suffix:semicolon
op_star
id|TargetPointer
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Save the Host Adapter SCSI ID in the Host Adapter structure.&n;&t; */
id|HostAdapter-&gt;SCSI_ID
op_assign
id|Configuration.HostAdapterID
suffix:semicolon
multiline_comment|/*&n;&t;   Determine the Bus Type and save it in the Host Adapter structure, determine&n;&t;   and save the IRQ Channel if necessary, and determine and save the DMA&n;&t;   Channel for ISA Host Adapters.&n;&t; */
id|HostAdapter-&gt;HostAdapterBusType
op_assign
id|BusLogic_HostAdapterBusTypes
(braket
id|HostAdapter-&gt;ModelName
(braket
l_int|3
)braket
op_minus
l_char|&squot;4&squot;
)braket
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;IRQ_Channel
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|Configuration.IRQ_Channel9
)paren
id|HostAdapter-&gt;IRQ_Channel
op_assign
l_int|9
suffix:semicolon
r_else
r_if
c_cond
(paren
id|Configuration.IRQ_Channel10
)paren
id|HostAdapter-&gt;IRQ_Channel
op_assign
l_int|10
suffix:semicolon
r_else
r_if
c_cond
(paren
id|Configuration.IRQ_Channel11
)paren
id|HostAdapter-&gt;IRQ_Channel
op_assign
l_int|11
suffix:semicolon
r_else
r_if
c_cond
(paren
id|Configuration.IRQ_Channel12
)paren
id|HostAdapter-&gt;IRQ_Channel
op_assign
l_int|12
suffix:semicolon
r_else
r_if
c_cond
(paren
id|Configuration.IRQ_Channel14
)paren
id|HostAdapter-&gt;IRQ_Channel
op_assign
l_int|14
suffix:semicolon
r_else
r_if
c_cond
(paren
id|Configuration.IRQ_Channel15
)paren
id|HostAdapter-&gt;IRQ_Channel
op_assign
l_int|15
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterBusType
op_eq
id|BusLogic_ISA_Bus
)paren
(brace
r_if
c_cond
(paren
id|Configuration.DMA_Channel5
)paren
id|HostAdapter-&gt;DMA_Channel
op_assign
l_int|5
suffix:semicolon
r_else
r_if
c_cond
(paren
id|Configuration.DMA_Channel6
)paren
id|HostAdapter-&gt;DMA_Channel
op_assign
l_int|6
suffix:semicolon
r_else
r_if
c_cond
(paren
id|Configuration.DMA_Channel7
)paren
id|HostAdapter-&gt;DMA_Channel
op_assign
l_int|7
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Determine whether Extended Translation is enabled and save it in&n;&t;   the Host Adapter structure.&n;&t; */
id|GeometryRegister.All
op_assign
id|BusLogic_ReadGeometryRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|HostAdapter-&gt;ExtendedTranslationEnabled
op_assign
id|GeometryRegister.gr.ExtendedTranslationEnabled
suffix:semicolon
multiline_comment|/*&n;&t;   Save the Scatter Gather Limits, Level Sensitive Interrupt flag, Wide&n;&t;   SCSI flag, Differential SCSI flag, SCAM Supported flag, and&n;&t;   Ultra SCSI flag in the Host Adapter structure.&n;&t; */
id|HostAdapter-&gt;HostAdapterScatterGatherLimit
op_assign
id|ExtendedSetupInformation.ScatterGatherLimit
suffix:semicolon
id|HostAdapter-&gt;DriverScatterGatherLimit
op_assign
id|HostAdapter-&gt;HostAdapterScatterGatherLimit
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterScatterGatherLimit
OG
id|BusLogic_ScatterGatherLimit
)paren
id|HostAdapter-&gt;DriverScatterGatherLimit
op_assign
id|BusLogic_ScatterGatherLimit
suffix:semicolon
r_if
c_cond
(paren
id|ExtendedSetupInformation.Misc.LevelSensitiveInterrupt
)paren
id|HostAdapter-&gt;LevelSensitiveInterrupt
op_assign
l_bool|true
suffix:semicolon
id|HostAdapter-&gt;HostWideSCSI
op_assign
id|ExtendedSetupInformation.HostWideSCSI
suffix:semicolon
id|HostAdapter-&gt;HostDifferentialSCSI
op_assign
id|ExtendedSetupInformation.HostDifferentialSCSI
suffix:semicolon
id|HostAdapter-&gt;HostSupportsSCAM
op_assign
id|ExtendedSetupInformation.HostSupportsSCAM
suffix:semicolon
id|HostAdapter-&gt;HostUltraSCSI
op_assign
id|ExtendedSetupInformation.HostUltraSCSI
suffix:semicolon
multiline_comment|/*&n;&t;   Determine whether Extended LUN Format CCBs are supported and save the&n;&t;   information in the Host Adapter structure.&n;&t; */
r_if
c_cond
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
op_eq
l_char|&squot;5&squot;
op_logical_or
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
op_eq
l_char|&squot;4&squot;
op_logical_and
id|HostAdapter-&gt;HostWideSCSI
)paren
)paren
id|HostAdapter-&gt;ExtendedLUNSupport
op_assign
l_bool|true
suffix:semicolon
multiline_comment|/*&n;&t;   Issue the Inquire PCI Host Adapter Information command to read the&n;&t;   Termination Information from &quot;W&quot; series MultiMaster Host Adapters.&n;&t; */
r_if
c_cond
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
op_eq
l_char|&squot;5&squot;
)paren
(brace
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquirePCIHostAdapterInformation
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|PCIHostAdapterInformation
comma
r_sizeof
(paren
id|PCIHostAdapterInformation
)paren
)paren
op_ne
r_sizeof
(paren
id|PCIHostAdapterInformation
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE PCI HOST ADAPTER INFORMATION&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;   Save the Termination Information in the Host Adapter structure.&n;&t;&t; */
r_if
c_cond
(paren
id|PCIHostAdapterInformation.GenericInfoValid
)paren
(brace
id|HostAdapter-&gt;TerminationInfoValid
op_assign
l_bool|true
suffix:semicolon
id|HostAdapter-&gt;LowByteTerminated
op_assign
id|PCIHostAdapterInformation.LowByteTerminated
suffix:semicolon
id|HostAdapter-&gt;HighByteTerminated
op_assign
id|PCIHostAdapterInformation.HighByteTerminated
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;   Issue the Fetch Host Adapter Local RAM command to read the AutoSCSI data&n;&t;   from &quot;W&quot; and &quot;C&quot; series MultiMaster Host Adapters.&n;&t; */
r_if
c_cond
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
op_ge
l_char|&squot;4&squot;
)paren
(brace
id|FetchHostAdapterLocalRAMRequest.ByteOffset
op_assign
id|BusLogic_AutoSCSI_BaseOffset
suffix:semicolon
id|FetchHostAdapterLocalRAMRequest.ByteCount
op_assign
r_sizeof
(paren
id|AutoSCSIData
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_FetchHostAdapterLocalRAM
comma
op_amp
id|FetchHostAdapterLocalRAMRequest
comma
r_sizeof
(paren
id|FetchHostAdapterLocalRAMRequest
)paren
comma
op_amp
id|AutoSCSIData
comma
r_sizeof
(paren
id|AutoSCSIData
)paren
)paren
op_ne
r_sizeof
(paren
id|AutoSCSIData
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;FETCH HOST ADAPTER LOCAL RAM&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;   Save the Parity Checking Enabled, Bus Reset Enabled, and Termination&n;&t;&t;   Information in the Host Adapter structure.&n;&t;&t; */
id|HostAdapter-&gt;ParityCheckingEnabled
op_assign
id|AutoSCSIData.ParityCheckingEnabled
suffix:semicolon
id|HostAdapter-&gt;BusResetEnabled
op_assign
id|AutoSCSIData.BusResetEnabled
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
op_eq
l_char|&squot;4&squot;
)paren
(brace
id|HostAdapter-&gt;TerminationInfoValid
op_assign
l_bool|true
suffix:semicolon
id|HostAdapter-&gt;LowByteTerminated
op_assign
id|AutoSCSIData.LowByteTerminated
suffix:semicolon
id|HostAdapter-&gt;HighByteTerminated
op_assign
id|AutoSCSIData.HighByteTerminated
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;   Save the Wide Permitted, Fast Permitted, Synchronous Permitted,&n;&t;&t;   Disconnect Permitted, Ultra Permitted, and SCAM Information in the&n;&t;&t;   Host Adapter structure.&n;&t;&t; */
id|HostAdapter-&gt;WidePermitted
op_assign
id|AutoSCSIData.WidePermitted
suffix:semicolon
id|HostAdapter-&gt;FastPermitted
op_assign
id|AutoSCSIData.FastPermitted
suffix:semicolon
id|HostAdapter-&gt;SynchronousPermitted
op_assign
id|AutoSCSIData.SynchronousPermitted
suffix:semicolon
id|HostAdapter-&gt;DisconnectPermitted
op_assign
id|AutoSCSIData.DisconnectPermitted
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;HostUltraSCSI
)paren
id|HostAdapter-&gt;UltraPermitted
op_assign
id|AutoSCSIData.UltraPermitted
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;HostSupportsSCAM
)paren
(brace
id|HostAdapter-&gt;SCAM_Enabled
op_assign
id|AutoSCSIData.SCAM_Enabled
suffix:semicolon
id|HostAdapter-&gt;SCAM_Level2
op_assign
id|AutoSCSIData.SCAM_Level2
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;   Initialize fields in the Host Adapter structure for &quot;S&quot; and &quot;A&quot; series&n;&t;   MultiMaster Host Adapters.&n;&t; */
r_if
c_cond
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
OL
l_char|&squot;4&squot;
)paren
(brace
r_if
c_cond
(paren
id|SetupInformation.SynchronousInitiationEnabled
)paren
(brace
id|HostAdapter-&gt;SynchronousPermitted
op_assign
l_int|0xFF
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterBusType
op_eq
id|BusLogic_EISA_Bus
)paren
(brace
r_if
c_cond
(paren
id|ExtendedSetupInformation.Misc.FastOnEISA
)paren
id|HostAdapter-&gt;FastPermitted
op_assign
l_int|0xFF
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|HostAdapter-&gt;ModelName
comma
l_string|&quot;BT-757&quot;
)paren
op_eq
l_int|0
)paren
id|HostAdapter-&gt;WidePermitted
op_assign
l_int|0xFF
suffix:semicolon
)brace
)brace
id|HostAdapter-&gt;DisconnectPermitted
op_assign
l_int|0xFF
suffix:semicolon
id|HostAdapter-&gt;ParityCheckingEnabled
op_assign
id|SetupInformation.ParityCheckingEnabled
suffix:semicolon
id|HostAdapter-&gt;BusResetEnabled
op_assign
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Determine the maximum number of Target IDs and Logical Units supported by&n;&t;   this driver for Wide and Narrow Host Adapters.&n;&t; */
id|HostAdapter-&gt;MaxTargetDevices
op_assign
(paren
id|HostAdapter-&gt;HostWideSCSI
ques
c_cond
l_int|16
suffix:colon
l_int|8
)paren
suffix:semicolon
id|HostAdapter-&gt;MaxLogicalUnits
op_assign
(paren
id|HostAdapter-&gt;ExtendedLUNSupport
ques
c_cond
l_int|32
suffix:colon
l_int|8
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   Select appropriate values for the Mailbox Count, Driver Queue Depth,&n;&t;   Initial CCBs, and Incremental CCBs variables based on whether or not Strict&n;&t;   Round Robin Mode is supported.  If Strict Round Robin Mode is supported,&n;&t;   then there is no performance degradation in using the maximum possible&n;&t;   number of Outgoing and Incoming Mailboxes and allowing the Tagged and&n;&t;   Untagged Queue Depths to determine the actual utilization.  If Strict Round&n;&t;   Robin Mode is not supported, then the Host Adapter must scan all the&n;&t;   Outgoing Mailboxes whenever an Outgoing Mailbox entry is made, which can&n;&t;   cause a substantial performance penalty.  The host adapters actually have&n;&t;   room to store the following number of CCBs internally; that is, they can&n;&t;   internally queue and manage this many active commands on the SCSI bus&n;&t;   simultaneously.  Performance measurements demonstrate that the Driver Queue&n;&t;   Depth should be set to the Mailbox Count, rather than the Host Adapter&n;&t;   Queue Depth (internal CCB capacity), as it is more efficient to have the&n;&t;   queued commands waiting in Outgoing Mailboxes if necessary than to block&n;&t;   the process in the higher levels of the SCSI Subsystem.&n;&n;&t;   192          BT-948/958/958D&n;&t;   100          BT-946C/956C/956CD/747C/757C/757CD/445C&n;&t;   50   BT-545C/540CF&n;&t;   30   BT-747S/747D/757S/757D/445S/545S/542D/542B/742A&n;&t; */
r_if
c_cond
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
op_eq
l_char|&squot;5&squot;
)paren
id|HostAdapter-&gt;HostAdapterQueueDepth
op_assign
l_int|192
suffix:semicolon
r_else
r_if
c_cond
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
op_eq
l_char|&squot;4&squot;
)paren
id|HostAdapter-&gt;HostAdapterQueueDepth
op_assign
(paren
id|HostAdapter-&gt;HostAdapterBusType
op_ne
id|BusLogic_ISA_Bus
ques
c_cond
l_int|100
suffix:colon
l_int|50
)paren
suffix:semicolon
r_else
id|HostAdapter-&gt;HostAdapterQueueDepth
op_assign
l_int|30
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|HostAdapter-&gt;FirmwareVersion
comma
l_string|&quot;3.31&quot;
)paren
op_ge
l_int|0
)paren
(brace
id|HostAdapter-&gt;StrictRoundRobinModeSupport
op_assign
l_bool|true
suffix:semicolon
id|HostAdapter-&gt;MailboxCount
op_assign
id|BusLogic_MaxMailboxes
suffix:semicolon
)brace
r_else
(brace
id|HostAdapter-&gt;StrictRoundRobinModeSupport
op_assign
l_bool|false
suffix:semicolon
id|HostAdapter-&gt;MailboxCount
op_assign
l_int|32
suffix:semicolon
)brace
id|HostAdapter-&gt;DriverQueueDepth
op_assign
id|HostAdapter-&gt;MailboxCount
suffix:semicolon
id|HostAdapter-&gt;InitialCCBs
op_assign
l_int|4
op_star
id|BusLogic_CCB_AllocationGroupSize
suffix:semicolon
id|HostAdapter-&gt;IncrementalCCBs
op_assign
id|BusLogic_CCB_AllocationGroupSize
suffix:semicolon
multiline_comment|/*&n;&t;   Tagged Queuing support is available and operates properly on all &quot;W&quot; series&n;&t;   MultiMaster Host Adapters, on &quot;C&quot; series MultiMaster Host Adapters with&n;&t;   firmware version 4.22 and above, and on &quot;S&quot; series MultiMaster Host&n;&t;   Adapters with firmware version 3.35 and above.&n;&t; */
id|HostAdapter-&gt;TaggedQueuingPermitted
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;5&squot;
suffix:colon
id|HostAdapter-&gt;TaggedQueuingPermitted
op_assign
l_int|0xFFFF
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;4&squot;
suffix:colon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|HostAdapter-&gt;FirmwareVersion
comma
l_string|&quot;4.22&quot;
)paren
op_ge
l_int|0
)paren
id|HostAdapter-&gt;TaggedQueuingPermitted
op_assign
l_int|0xFFFF
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;3&squot;
suffix:colon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|HostAdapter-&gt;FirmwareVersion
comma
l_string|&quot;3.35&quot;
)paren
op_ge
l_int|0
)paren
id|HostAdapter-&gt;TaggedQueuingPermitted
op_assign
l_int|0xFFFF
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Determine the Host Adapter BIOS Address if the BIOS is enabled and&n;&t;   save it in the Host Adapter structure.  The BIOS is disabled if the&n;&t;   BIOS_Address is 0.&n;&t; */
id|HostAdapter-&gt;BIOS_Address
op_assign
id|ExtendedSetupInformation.BIOS_Address
op_lshift
l_int|12
suffix:semicolon
multiline_comment|/*&n;&t;   ISA Host Adapters require Bounce Buffers if there is more than 16MB memory.&n;&t; */
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterBusType
op_eq
id|BusLogic_ISA_Bus
op_logical_and
(paren
r_void
op_star
)paren
id|high_memory
OG
(paren
r_void
op_star
)paren
id|MAX_DMA_ADDRESS
)paren
id|HostAdapter-&gt;BounceBuffersRequired
op_assign
l_bool|true
suffix:semicolon
multiline_comment|/*&n;&t;   BusLogic BT-445S Host Adapters prior to board revision E have a hardware&n;&t;   bug whereby when the BIOS is enabled, transfers to/from the same address&n;&t;   range the BIOS occupies modulo 16MB are handled incorrectly.  Only properly&n;&t;   functioning BT-445S Host Adapters have firmware version 3.37, so require&n;&t;   that ISA Bounce Buffers be used for the buggy BT-445S models if there is&n;&t;   more than 16MB memory.&n;&t; */
r_if
c_cond
(paren
id|HostAdapter-&gt;BIOS_Address
OG
l_int|0
op_logical_and
id|strcmp
c_func
(paren
id|HostAdapter-&gt;ModelName
comma
l_string|&quot;BT-445S&quot;
)paren
op_eq
l_int|0
op_logical_and
id|strcmp
c_func
(paren
id|HostAdapter-&gt;FirmwareVersion
comma
l_string|&quot;3.37&quot;
)paren
template_param
(paren
r_void
op_star
)paren
id|MAX_DMA_ADDRESS
)paren
id|HostAdapter-&gt;BounceBuffersRequired
op_assign
l_bool|true
suffix:semicolon
multiline_comment|/*&n;&t;   Initialize parameters common to MultiMaster and FlashPoint Host Adapters.&n;&t; */
id|Common
suffix:colon
multiline_comment|/*&n;&t;   Initialize the Host Adapter Full Model Name from the Model Name.&n;&t; */
id|strcpy
c_func
(paren
id|HostAdapter-&gt;FullModelName
comma
l_string|&quot;BusLogic &quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|HostAdapter-&gt;FullModelName
comma
id|HostAdapter-&gt;ModelName
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   Select an appropriate value for the Tagged Queue Depth either from a&n;&t;   BusLogic Driver Options specification, or based on whether this Host&n;&t;   Adapter requires that ISA Bounce Buffers be used.  The Tagged Queue Depth&n;&t;   is left at 0 for automatic determination in BusLogic_SelectQueueDepths.&n;&t;   Initialize the Untagged Queue Depth.&n;&t; */
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|BusLogic_MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
(brace
r_int
r_char
id|QueueDepth
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;DriverOptions
op_ne
l_int|NULL
op_logical_and
id|HostAdapter-&gt;DriverOptions-&gt;QueueDepth
(braket
id|TargetID
)braket
OG
l_int|0
)paren
id|QueueDepth
op_assign
id|HostAdapter-&gt;DriverOptions-&gt;QueueDepth
(braket
id|TargetID
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|HostAdapter-&gt;BounceBuffersRequired
)paren
id|QueueDepth
op_assign
id|BusLogic_TaggedQueueDepthBB
suffix:semicolon
id|HostAdapter-&gt;QueueDepth
(braket
id|TargetID
)braket
op_assign
id|QueueDepth
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HostAdapter-&gt;BounceBuffersRequired
)paren
id|HostAdapter-&gt;UntaggedQueueDepth
op_assign
id|BusLogic_UntaggedQueueDepthBB
suffix:semicolon
r_else
id|HostAdapter-&gt;UntaggedQueueDepth
op_assign
id|BusLogic_UntaggedQueueDepth
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;DriverOptions
op_ne
l_int|NULL
)paren
id|HostAdapter-&gt;CommonQueueDepth
op_assign
id|HostAdapter-&gt;DriverOptions-&gt;CommonQueueDepth
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;CommonQueueDepth
OG
l_int|0
op_logical_and
id|HostAdapter-&gt;CommonQueueDepth
OL
id|HostAdapter-&gt;UntaggedQueueDepth
)paren
id|HostAdapter-&gt;UntaggedQueueDepth
op_assign
id|HostAdapter-&gt;CommonQueueDepth
suffix:semicolon
multiline_comment|/*&n;&t;   Tagged Queuing is only allowed if Disconnect/Reconnect is permitted.&n;&t;   Therefore, mask the Tagged Queuing Permitted Default bits with the&n;&t;   Disconnect/Reconnect Permitted bits.&n;&t; */
id|HostAdapter-&gt;TaggedQueuingPermitted
op_and_assign
id|HostAdapter-&gt;DisconnectPermitted
suffix:semicolon
multiline_comment|/*&n;&t;   Combine the default Tagged Queuing Permitted bits with any BusLogic Driver&n;&t;   Options Tagged Queuing specification.&n;&t; */
r_if
c_cond
(paren
id|HostAdapter-&gt;DriverOptions
op_ne
l_int|NULL
)paren
id|HostAdapter-&gt;TaggedQueuingPermitted
op_assign
(paren
id|HostAdapter-&gt;DriverOptions-&gt;TaggedQueuingPermitted
op_amp
id|HostAdapter-&gt;DriverOptions-&gt;TaggedQueuingPermittedMask
)paren
op_or
(paren
id|HostAdapter-&gt;TaggedQueuingPermitted
op_amp
op_complement
id|HostAdapter-&gt;DriverOptions-&gt;TaggedQueuingPermittedMask
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   Select an appropriate value for Bus Settle Time either from a BusLogic&n;&t;   Driver Options specification, or from BusLogic_DefaultBusSettleTime.&n;&t; */
r_if
c_cond
(paren
id|HostAdapter-&gt;DriverOptions
op_ne
l_int|NULL
op_logical_and
id|HostAdapter-&gt;DriverOptions-&gt;BusSettleTime
OG
l_int|0
)paren
id|HostAdapter-&gt;BusSettleTime
op_assign
id|HostAdapter-&gt;DriverOptions-&gt;BusSettleTime
suffix:semicolon
r_else
id|HostAdapter-&gt;BusSettleTime
op_assign
id|BusLogic_DefaultBusSettleTime
suffix:semicolon
multiline_comment|/*&n;&t;   Indicate reading the Host Adapter Configuration completed successfully.&n;&t; */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ReportHostAdapterConfiguration reports the configuration of&n;  Host Adapter.&n;*/
DECL|function|BusLogic_ReportHostAdapterConfiguration
r_static
id|boolean
id|__init
id|BusLogic_ReportHostAdapterConfiguration
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
)paren
(brace
r_int
r_int
id|AllTargetsMask
op_assign
(paren
l_int|1
op_lshift
id|HostAdapter-&gt;MaxTargetDevices
)paren
op_minus
l_int|1
suffix:semicolon
r_int
r_int
id|SynchronousPermitted
comma
id|FastPermitted
suffix:semicolon
r_int
r_int
id|UltraPermitted
comma
id|WidePermitted
suffix:semicolon
r_int
r_int
id|DisconnectPermitted
comma
id|TaggedQueuingPermitted
suffix:semicolon
id|boolean
id|CommonSynchronousNegotiation
comma
id|CommonTaggedQueueDepth
suffix:semicolon
r_char
id|SynchronousString
(braket
id|BusLogic_MaxTargetDevices
op_plus
l_int|1
)braket
suffix:semicolon
r_char
id|WideString
(braket
id|BusLogic_MaxTargetDevices
op_plus
l_int|1
)braket
suffix:semicolon
r_char
id|DisconnectString
(braket
id|BusLogic_MaxTargetDevices
op_plus
l_int|1
)braket
suffix:semicolon
r_char
id|TaggedQueuingString
(braket
id|BusLogic_MaxTargetDevices
op_plus
l_int|1
)braket
suffix:semicolon
r_char
op_star
id|SynchronousMessage
op_assign
id|SynchronousString
suffix:semicolon
r_char
op_star
id|WideMessage
op_assign
id|WideString
suffix:semicolon
r_char
op_star
id|DisconnectMessage
op_assign
id|DisconnectString
suffix:semicolon
r_char
op_star
id|TaggedQueuingMessage
op_assign
id|TaggedQueuingString
suffix:semicolon
r_int
id|TargetID
suffix:semicolon
id|BusLogic_Info
c_func
(paren
l_string|&quot;Configuring BusLogic Model %s %s%s%s%s SCSI Host Adapter&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;ModelName
comma
id|BusLogic_HostAdapterBusNames
(braket
id|HostAdapter-&gt;HostAdapterBusType
)braket
comma
(paren
id|HostAdapter-&gt;HostWideSCSI
ques
c_cond
l_string|&quot; Wide&quot;
suffix:colon
l_string|&quot;&quot;
)paren
comma
(paren
id|HostAdapter-&gt;HostDifferentialSCSI
ques
c_cond
l_string|&quot; Differential&quot;
suffix:colon
l_string|&quot;&quot;
)paren
comma
(paren
id|HostAdapter-&gt;HostUltraSCSI
ques
c_cond
l_string|&quot; Ultra&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
id|BusLogic_Info
c_func
(paren
l_string|&quot;  Firmware Version: %s, I/O Address: 0x%X, &quot;
l_string|&quot;IRQ Channel: %d/%s&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;FirmwareVersion
comma
id|HostAdapter-&gt;IO_Address
comma
id|HostAdapter-&gt;IRQ_Channel
comma
(paren
id|HostAdapter-&gt;LevelSensitiveInterrupt
ques
c_cond
l_string|&quot;Level&quot;
suffix:colon
l_string|&quot;Edge&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterBusType
op_ne
id|BusLogic_PCI_Bus
)paren
(brace
id|BusLogic_Info
c_func
(paren
l_string|&quot;  DMA Channel: &quot;
comma
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;DMA_Channel
OG
l_int|0
)paren
id|BusLogic_Info
c_func
(paren
l_string|&quot;%d, &quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;DMA_Channel
)paren
suffix:semicolon
r_else
id|BusLogic_Info
c_func
(paren
l_string|&quot;None, &quot;
comma
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;BIOS_Address
OG
l_int|0
)paren
id|BusLogic_Info
c_func
(paren
l_string|&quot;BIOS Address: 0x%X, &quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;BIOS_Address
)paren
suffix:semicolon
r_else
id|BusLogic_Info
c_func
(paren
l_string|&quot;BIOS Address: None, &quot;
comma
id|HostAdapter
)paren
suffix:semicolon
)brace
r_else
(brace
id|BusLogic_Info
c_func
(paren
l_string|&quot;  PCI Bus: %d, Device: %d, Address: &quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;Bus
comma
id|HostAdapter-&gt;Device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;PCI_Address
OG
l_int|0
)paren
id|BusLogic_Info
c_func
(paren
l_string|&quot;0x%X, &quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;PCI_Address
)paren
suffix:semicolon
r_else
id|BusLogic_Info
c_func
(paren
l_string|&quot;Unassigned, &quot;
comma
id|HostAdapter
)paren
suffix:semicolon
)brace
id|BusLogic_Info
c_func
(paren
l_string|&quot;Host Adapter SCSI ID: %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;SCSI_ID
)paren
suffix:semicolon
id|BusLogic_Info
c_func
(paren
l_string|&quot;  Parity Checking: %s, Extended Translation: %s&bslash;n&quot;
comma
id|HostAdapter
comma
(paren
id|HostAdapter-&gt;ParityCheckingEnabled
ques
c_cond
l_string|&quot;Enabled&quot;
suffix:colon
l_string|&quot;Disabled&quot;
)paren
comma
(paren
id|HostAdapter-&gt;ExtendedTranslationEnabled
ques
c_cond
l_string|&quot;Enabled&quot;
suffix:colon
l_string|&quot;Disabled&quot;
)paren
)paren
suffix:semicolon
id|AllTargetsMask
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|HostAdapter-&gt;SCSI_ID
)paren
suffix:semicolon
id|SynchronousPermitted
op_assign
id|HostAdapter-&gt;SynchronousPermitted
op_amp
id|AllTargetsMask
suffix:semicolon
id|FastPermitted
op_assign
id|HostAdapter-&gt;FastPermitted
op_amp
id|AllTargetsMask
suffix:semicolon
id|UltraPermitted
op_assign
id|HostAdapter-&gt;UltraPermitted
op_amp
id|AllTargetsMask
suffix:semicolon
r_if
c_cond
(paren
(paren
id|BusLogic_MultiMasterHostAdapterP
c_func
(paren
id|HostAdapter
)paren
op_logical_and
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
op_ge
l_char|&squot;4&squot;
op_logical_or
id|HostAdapter-&gt;HostAdapterBusType
op_eq
id|BusLogic_EISA_Bus
)paren
)paren
op_logical_or
id|BusLogic_FlashPointHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
(brace
id|CommonSynchronousNegotiation
op_assign
l_bool|false
suffix:semicolon
r_if
c_cond
(paren
id|SynchronousPermitted
op_eq
l_int|0
)paren
(brace
id|SynchronousMessage
op_assign
l_string|&quot;Disabled&quot;
suffix:semicolon
id|CommonSynchronousNegotiation
op_assign
l_bool|true
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SynchronousPermitted
op_eq
id|AllTargetsMask
)paren
(brace
r_if
c_cond
(paren
id|FastPermitted
op_eq
l_int|0
)paren
(brace
id|SynchronousMessage
op_assign
l_string|&quot;Slow&quot;
suffix:semicolon
id|CommonSynchronousNegotiation
op_assign
l_bool|true
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FastPermitted
op_eq
id|AllTargetsMask
)paren
(brace
r_if
c_cond
(paren
id|UltraPermitted
op_eq
l_int|0
)paren
(brace
id|SynchronousMessage
op_assign
l_string|&quot;Fast&quot;
suffix:semicolon
id|CommonSynchronousNegotiation
op_assign
l_bool|true
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|UltraPermitted
op_eq
id|AllTargetsMask
)paren
(brace
id|SynchronousMessage
op_assign
l_string|&quot;Ultra&quot;
suffix:semicolon
id|CommonSynchronousNegotiation
op_assign
l_bool|true
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|CommonSynchronousNegotiation
)paren
(brace
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|SynchronousString
(braket
id|TargetID
)braket
op_assign
(paren
(paren
op_logical_neg
(paren
id|SynchronousPermitted
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
)paren
)paren
ques
c_cond
l_char|&squot;N&squot;
suffix:colon
(paren
op_logical_neg
(paren
id|FastPermitted
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
)paren
ques
c_cond
l_char|&squot;S&squot;
suffix:colon
(paren
op_logical_neg
(paren
id|UltraPermitted
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
)paren
ques
c_cond
l_char|&squot;F&squot;
suffix:colon
l_char|&squot;U&squot;
)paren
)paren
)paren
suffix:semicolon
id|SynchronousString
(braket
id|HostAdapter-&gt;SCSI_ID
)braket
op_assign
l_char|&squot;#&squot;
suffix:semicolon
id|SynchronousString
(braket
id|HostAdapter-&gt;MaxTargetDevices
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
)brace
r_else
id|SynchronousMessage
op_assign
(paren
id|SynchronousPermitted
op_eq
l_int|0
ques
c_cond
l_string|&quot;Disabled&quot;
suffix:colon
l_string|&quot;Enabled&quot;
)paren
suffix:semicolon
id|WidePermitted
op_assign
id|HostAdapter-&gt;WidePermitted
op_amp
id|AllTargetsMask
suffix:semicolon
r_if
c_cond
(paren
id|WidePermitted
op_eq
l_int|0
)paren
id|WideMessage
op_assign
l_string|&quot;Disabled&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|WidePermitted
op_eq
id|AllTargetsMask
)paren
id|WideMessage
op_assign
l_string|&quot;Enabled&quot;
suffix:semicolon
r_else
(brace
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|WideString
(braket
id|TargetID
)braket
op_assign
(paren
(paren
id|WidePermitted
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
)paren
ques
c_cond
l_char|&squot;Y&squot;
suffix:colon
l_char|&squot;N&squot;
)paren
suffix:semicolon
id|WideString
(braket
id|HostAdapter-&gt;SCSI_ID
)braket
op_assign
l_char|&squot;#&squot;
suffix:semicolon
id|WideString
(braket
id|HostAdapter-&gt;MaxTargetDevices
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
id|DisconnectPermitted
op_assign
id|HostAdapter-&gt;DisconnectPermitted
op_amp
id|AllTargetsMask
suffix:semicolon
r_if
c_cond
(paren
id|DisconnectPermitted
op_eq
l_int|0
)paren
id|DisconnectMessage
op_assign
l_string|&quot;Disabled&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|DisconnectPermitted
op_eq
id|AllTargetsMask
)paren
id|DisconnectMessage
op_assign
l_string|&quot;Enabled&quot;
suffix:semicolon
r_else
(brace
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|DisconnectString
(braket
id|TargetID
)braket
op_assign
(paren
(paren
id|DisconnectPermitted
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
)paren
ques
c_cond
l_char|&squot;Y&squot;
suffix:colon
l_char|&squot;N&squot;
)paren
suffix:semicolon
id|DisconnectString
(braket
id|HostAdapter-&gt;SCSI_ID
)braket
op_assign
l_char|&squot;#&squot;
suffix:semicolon
id|DisconnectString
(braket
id|HostAdapter-&gt;MaxTargetDevices
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
id|TaggedQueuingPermitted
op_assign
id|HostAdapter-&gt;TaggedQueuingPermitted
op_amp
id|AllTargetsMask
suffix:semicolon
r_if
c_cond
(paren
id|TaggedQueuingPermitted
op_eq
l_int|0
)paren
id|TaggedQueuingMessage
op_assign
l_string|&quot;Disabled&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|TaggedQueuingPermitted
op_eq
id|AllTargetsMask
)paren
id|TaggedQueuingMessage
op_assign
l_string|&quot;Enabled&quot;
suffix:semicolon
r_else
(brace
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|TaggedQueuingString
(braket
id|TargetID
)braket
op_assign
(paren
(paren
id|TaggedQueuingPermitted
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
)paren
ques
c_cond
l_char|&squot;Y&squot;
suffix:colon
l_char|&squot;N&squot;
)paren
suffix:semicolon
id|TaggedQueuingString
(braket
id|HostAdapter-&gt;SCSI_ID
)braket
op_assign
l_char|&squot;#&squot;
suffix:semicolon
id|TaggedQueuingString
(braket
id|HostAdapter-&gt;MaxTargetDevices
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
id|BusLogic_Info
c_func
(paren
l_string|&quot;  Synchronous Negotiation: %s, Wide Negotiation: %s&bslash;n&quot;
comma
id|HostAdapter
comma
id|SynchronousMessage
comma
id|WideMessage
)paren
suffix:semicolon
id|BusLogic_Info
c_func
(paren
l_string|&quot;  Disconnect/Reconnect: %s, Tagged Queuing: %s&bslash;n&quot;
comma
id|HostAdapter
comma
id|DisconnectMessage
comma
id|TaggedQueuingMessage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_MultiMasterHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
(brace
id|BusLogic_Info
c_func
(paren
l_string|&quot;  Scatter/Gather Limit: %d of %d segments, &quot;
l_string|&quot;Mailboxes: %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;DriverScatterGatherLimit
comma
id|HostAdapter-&gt;HostAdapterScatterGatherLimit
comma
id|HostAdapter-&gt;MailboxCount
)paren
suffix:semicolon
id|BusLogic_Info
c_func
(paren
l_string|&quot;  Driver Queue Depth: %d, &quot;
l_string|&quot;Host Adapter Queue Depth: %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;DriverQueueDepth
comma
id|HostAdapter-&gt;HostAdapterQueueDepth
)paren
suffix:semicolon
)brace
r_else
id|BusLogic_Info
c_func
(paren
l_string|&quot;  Driver Queue Depth: %d, &quot;
l_string|&quot;Scatter/Gather Limit: %d segments&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;DriverQueueDepth
comma
id|HostAdapter-&gt;DriverScatterGatherLimit
)paren
suffix:semicolon
id|BusLogic_Info
c_func
(paren
l_string|&quot;  Tagged Queue Depth: &quot;
comma
id|HostAdapter
)paren
suffix:semicolon
id|CommonTaggedQueueDepth
op_assign
l_bool|true
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|1
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
r_if
c_cond
(paren
id|HostAdapter-&gt;QueueDepth
(braket
id|TargetID
)braket
op_ne
id|HostAdapter-&gt;QueueDepth
(braket
l_int|0
)braket
)paren
(brace
id|CommonTaggedQueueDepth
op_assign
l_bool|false
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CommonTaggedQueueDepth
)paren
(brace
r_if
c_cond
(paren
id|HostAdapter-&gt;QueueDepth
(braket
l_int|0
)braket
OG
l_int|0
)paren
id|BusLogic_Info
c_func
(paren
l_string|&quot;%d&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;QueueDepth
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_else
id|BusLogic_Info
c_func
(paren
l_string|&quot;Automatic&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
)brace
r_else
id|BusLogic_Info
c_func
(paren
l_string|&quot;Individual&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_Info
c_func
(paren
l_string|&quot;, Untagged Queue Depth: %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;UntaggedQueueDepth
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;TerminationInfoValid
)paren
(brace
r_if
c_cond
(paren
id|HostAdapter-&gt;HostWideSCSI
)paren
id|BusLogic_Info
c_func
(paren
l_string|&quot;  SCSI Bus Termination: %s&quot;
comma
id|HostAdapter
comma
(paren
id|HostAdapter-&gt;LowByteTerminated
ques
c_cond
(paren
id|HostAdapter-&gt;HighByteTerminated
ques
c_cond
l_string|&quot;Both Enabled&quot;
suffix:colon
l_string|&quot;Low Enabled&quot;
)paren
suffix:colon
(paren
id|HostAdapter-&gt;HighByteTerminated
ques
c_cond
l_string|&quot;High Enabled&quot;
suffix:colon
l_string|&quot;Both Disabled&quot;
)paren
)paren
)paren
suffix:semicolon
r_else
id|BusLogic_Info
c_func
(paren
l_string|&quot;  SCSI Bus Termination: %s&quot;
comma
id|HostAdapter
comma
(paren
id|HostAdapter-&gt;LowByteTerminated
ques
c_cond
l_string|&quot;Enabled&quot;
suffix:colon
l_string|&quot;Disabled&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;HostSupportsSCAM
)paren
id|BusLogic_Info
c_func
(paren
l_string|&quot;, SCAM: %s&quot;
comma
id|HostAdapter
comma
(paren
id|HostAdapter-&gt;SCAM_Enabled
ques
c_cond
(paren
id|HostAdapter-&gt;SCAM_Level2
ques
c_cond
l_string|&quot;Enabled, Level 2&quot;
suffix:colon
l_string|&quot;Enabled, Level 1&quot;
)paren
suffix:colon
l_string|&quot;Disabled&quot;
)paren
)paren
suffix:semicolon
id|BusLogic_Info
c_func
(paren
l_string|&quot;&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Indicate reporting the Host Adapter configuration completed successfully.&n;&t; */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_AcquireResources acquires the system resources necessary to use&n;  Host Adapter.&n;*/
DECL|function|BusLogic_AcquireResources
r_static
id|boolean
id|__init
id|BusLogic_AcquireResources
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
)paren
(brace
r_if
c_cond
(paren
id|HostAdapter-&gt;IRQ_Channel
op_eq
l_int|0
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;NO LEGAL INTERRUPT CHANNEL ASSIGNED - DETACHING&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Acquire shared access to the IRQ Channel.&n;&t; */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|HostAdapter-&gt;IRQ_Channel
comma
id|BusLogic_InterruptHandler
comma
id|SA_SHIRQ
comma
id|HostAdapter-&gt;FullModelName
comma
id|HostAdapter
)paren
OL
l_int|0
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;UNABLE TO ACQUIRE IRQ CHANNEL %d - DETACHING&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;IRQ_Channel
)paren
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
id|HostAdapter-&gt;IRQ_ChannelAcquired
op_assign
l_bool|true
suffix:semicolon
multiline_comment|/*&n;&t;   Acquire exclusive access to the DMA Channel.&n;&t; */
r_if
c_cond
(paren
id|HostAdapter-&gt;DMA_Channel
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|HostAdapter-&gt;DMA_Channel
comma
id|HostAdapter-&gt;FullModelName
)paren
OL
l_int|0
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;UNABLE TO ACQUIRE DMA CHANNEL %d - DETACHING&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;DMA_Channel
)paren
suffix:semicolon
r_return
l_bool|false
suffix:semicolon
)brace
id|set_dma_mode
c_func
(paren
id|HostAdapter-&gt;DMA_Channel
comma
id|DMA_MODE_CASCADE
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|HostAdapter-&gt;DMA_Channel
)paren
suffix:semicolon
id|HostAdapter-&gt;DMA_ChannelAcquired
op_assign
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Indicate the System Resource Acquisition completed successfully,&n;&t; */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ReleaseResources releases any system resources previously acquired&n;  by BusLogic_AcquireResources.&n;*/
DECL|function|BusLogic_ReleaseResources
r_static
r_void
id|BusLogic_ReleaseResources
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
)paren
(brace
multiline_comment|/*&n;&t;   Release shared access to the IRQ Channel.&n;&t; */
r_if
c_cond
(paren
id|HostAdapter-&gt;IRQ_ChannelAcquired
)paren
id|free_irq
c_func
(paren
id|HostAdapter-&gt;IRQ_Channel
comma
id|HostAdapter
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   Release exclusive access to the DMA Channel.&n;&t; */
r_if
c_cond
(paren
id|HostAdapter-&gt;DMA_ChannelAcquired
)paren
id|free_dma
c_func
(paren
id|HostAdapter-&gt;DMA_Channel
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   Release any allocated memory structs not released elsewhere&n;&t; */
r_if
c_cond
(paren
id|HostAdapter-&gt;MailboxSpace
)paren
id|pci_free_consistent
c_func
(paren
id|HostAdapter-&gt;PCI_Device
comma
id|HostAdapter-&gt;MailboxSize
comma
id|HostAdapter-&gt;MailboxSpace
comma
id|HostAdapter-&gt;MailboxSpaceHandle
)paren
suffix:semicolon
id|HostAdapter-&gt;MailboxSpace
op_assign
l_int|NULL
suffix:semicolon
id|HostAdapter-&gt;MailboxSpaceHandle
op_assign
l_int|0
suffix:semicolon
id|HostAdapter-&gt;MailboxSize
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_InitializeHostAdapter initializes Host Adapter.  This is the only&n;  function called during SCSI Host Adapter detection which modifies the state&n;  of the Host Adapter from its initial power on or hard reset state.&n;*/
DECL|function|BusLogic_InitializeHostAdapter
r_static
id|boolean
id|BusLogic_InitializeHostAdapter
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
)paren
(brace
r_struct
id|BusLogic_ExtendedMailboxRequest
id|ExtendedMailboxRequest
suffix:semicolon
r_enum
id|BusLogic_RoundRobinModeRequest
id|RoundRobinModeRequest
suffix:semicolon
r_enum
id|BusLogic_SetCCBFormatRequest
id|SetCCBFormatRequest
suffix:semicolon
r_int
id|TargetID
suffix:semicolon
multiline_comment|/*&n;&t;   Initialize the pointers to the first and last CCBs that are queued for&n;&t;   completion processing.&n;&t; */
id|HostAdapter-&gt;FirstCompletedCCB
op_assign
l_int|NULL
suffix:semicolon
id|HostAdapter-&gt;LastCompletedCCB
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;   Initialize the Bus Device Reset Pending CCB, Tagged Queuing Active,&n;&t;   Command Successful Flag, Active Commands, and Commands Since Reset&n;&t;   for each Target Device.&n;&t; */
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
(brace
id|HostAdapter-&gt;BusDeviceResetPendingCCB
(braket
id|TargetID
)braket
op_assign
l_int|NULL
suffix:semicolon
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
dot
id|TaggedQueuingActive
op_assign
l_bool|false
suffix:semicolon
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
dot
id|CommandSuccessfulFlag
op_assign
l_bool|false
suffix:semicolon
id|HostAdapter-&gt;ActiveCommands
(braket
id|TargetID
)braket
op_assign
l_int|0
suffix:semicolon
id|HostAdapter-&gt;CommandsSinceReset
(braket
id|TargetID
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   FlashPoint Host Adapters do not use Outgoing and Incoming Mailboxes.&n;&t; */
r_if
c_cond
(paren
id|BusLogic_FlashPointHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
r_goto
id|Done
suffix:semicolon
multiline_comment|/*&n;&t;   Initialize the Outgoing and Incoming Mailbox pointers.&n;&t; */
id|HostAdapter-&gt;MailboxSize
op_assign
id|HostAdapter-&gt;MailboxCount
op_star
(paren
r_sizeof
(paren
r_struct
id|BusLogic_OutgoingMailbox
)paren
op_plus
r_sizeof
(paren
r_struct
id|BusLogic_IncomingMailbox
)paren
)paren
suffix:semicolon
id|HostAdapter-&gt;MailboxSpace
op_assign
id|pci_alloc_consistent
c_func
(paren
id|HostAdapter-&gt;PCI_Device
comma
id|HostAdapter-&gt;MailboxSize
comma
op_amp
id|HostAdapter-&gt;MailboxSpaceHandle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;MailboxSpace
op_eq
l_int|NULL
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;MAILBOX ALLOCATION&quot;
)paren
suffix:semicolon
id|HostAdapter-&gt;FirstOutgoingMailbox
op_assign
(paren
r_struct
id|BusLogic_OutgoingMailbox
op_star
)paren
id|HostAdapter-&gt;MailboxSpace
suffix:semicolon
id|HostAdapter-&gt;LastOutgoingMailbox
op_assign
id|HostAdapter-&gt;FirstOutgoingMailbox
op_plus
id|HostAdapter-&gt;MailboxCount
op_minus
l_int|1
suffix:semicolon
id|HostAdapter-&gt;NextOutgoingMailbox
op_assign
id|HostAdapter-&gt;FirstOutgoingMailbox
suffix:semicolon
id|HostAdapter-&gt;FirstIncomingMailbox
op_assign
(paren
r_struct
id|BusLogic_IncomingMailbox
op_star
)paren
(paren
id|HostAdapter-&gt;LastOutgoingMailbox
op_plus
l_int|1
)paren
suffix:semicolon
id|HostAdapter-&gt;LastIncomingMailbox
op_assign
id|HostAdapter-&gt;FirstIncomingMailbox
op_plus
id|HostAdapter-&gt;MailboxCount
op_minus
l_int|1
suffix:semicolon
id|HostAdapter-&gt;NextIncomingMailbox
op_assign
id|HostAdapter-&gt;FirstIncomingMailbox
suffix:semicolon
multiline_comment|/*&n;&t;   Initialize the Outgoing and Incoming Mailbox structures.&n;&t; */
id|memset
c_func
(paren
id|HostAdapter-&gt;FirstOutgoingMailbox
comma
l_int|0
comma
id|HostAdapter-&gt;MailboxCount
op_star
r_sizeof
(paren
r_struct
id|BusLogic_OutgoingMailbox
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|HostAdapter-&gt;FirstIncomingMailbox
comma
l_int|0
comma
id|HostAdapter-&gt;MailboxCount
op_star
r_sizeof
(paren
r_struct
id|BusLogic_IncomingMailbox
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   Initialize the Host Adapter&squot;s Pointer to the Outgoing/Incoming Mailboxes.&n;&t; */
id|ExtendedMailboxRequest.MailboxCount
op_assign
id|HostAdapter-&gt;MailboxCount
suffix:semicolon
id|ExtendedMailboxRequest.BaseMailboxAddress
op_assign
(paren
id|u32
)paren
id|HostAdapter-&gt;MailboxSpaceHandle
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InitializeExtendedMailbox
comma
op_amp
id|ExtendedMailboxRequest
comma
r_sizeof
(paren
id|ExtendedMailboxRequest
)paren
comma
l_int|NULL
comma
l_int|0
)paren
OL
l_int|0
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;MAILBOX INITIALIZATION&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   Enable Strict Round Robin Mode if supported by the Host Adapter.  In&n;&t;   Strict Round Robin Mode, the Host Adapter only looks at the next Outgoing&n;&t;   Mailbox for each new command, rather than scanning through all the&n;&t;   Outgoing Mailboxes to find any that have new commands in them.  Strict&n;&t;   Round Robin Mode is significantly more efficient.&n;&t; */
r_if
c_cond
(paren
id|HostAdapter-&gt;StrictRoundRobinModeSupport
)paren
(brace
id|RoundRobinModeRequest
op_assign
id|BusLogic_StrictRoundRobinMode
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_EnableStrictRoundRobinMode
comma
op_amp
id|RoundRobinModeRequest
comma
r_sizeof
(paren
id|RoundRobinModeRequest
)paren
comma
l_int|NULL
comma
l_int|0
)paren
OL
l_int|0
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;ENABLE STRICT ROUND ROBIN MODE&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   For Host Adapters that support Extended LUN Format CCBs, issue the Set CCB&n;&t;   Format command to allow 32 Logical Units per Target Device.&n;&t; */
r_if
c_cond
(paren
id|HostAdapter-&gt;ExtendedLUNSupport
)paren
(brace
id|SetCCBFormatRequest
op_assign
id|BusLogic_ExtendedLUNFormatCCB
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_SetCCBFormat
comma
op_amp
id|SetCCBFormatRequest
comma
r_sizeof
(paren
id|SetCCBFormatRequest
)paren
comma
l_int|NULL
comma
l_int|0
)paren
OL
l_int|0
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;SET CCB FORMAT&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Announce Successful Initialization.&n;&t; */
id|Done
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|HostAdapter-&gt;HostAdapterInitialized
)paren
(brace
id|BusLogic_Info
c_func
(paren
l_string|&quot;*** %s Initialized Successfully ***&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;FullModelName
)paren
suffix:semicolon
id|BusLogic_Info
c_func
(paren
l_string|&quot;&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
)brace
r_else
id|BusLogic_Warning
c_func
(paren
l_string|&quot;*** %s Initialized Successfully ***&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;FullModelName
)paren
suffix:semicolon
id|HostAdapter-&gt;HostAdapterInitialized
op_assign
l_bool|true
suffix:semicolon
multiline_comment|/*&n;&t;   Indicate the Host Adapter Initialization completed successfully.&n;&t; */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_TargetDeviceInquiry inquires about the Target Devices accessible&n;  through Host Adapter.&n;*/
DECL|function|BusLogic_TargetDeviceInquiry
r_static
id|boolean
id|__init
id|BusLogic_TargetDeviceInquiry
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
)paren
(brace
id|u16
id|InstalledDevices
suffix:semicolon
id|u8
id|InstalledDevicesID0to7
(braket
l_int|8
)braket
suffix:semicolon
r_struct
id|BusLogic_SetupInformation
id|SetupInformation
suffix:semicolon
id|u8
id|SynchronousPeriod
(braket
id|BusLogic_MaxTargetDevices
)braket
suffix:semicolon
r_int
r_char
id|RequestedReplyLength
suffix:semicolon
r_int
id|TargetID
suffix:semicolon
multiline_comment|/*&n;&t;   Wait a few seconds between the Host Adapter Hard Reset which initiates&n;&t;   a SCSI Bus Reset and issuing any SCSI Commands.  Some SCSI devices get&n;&t;   confused if they receive SCSI Commands too soon after a SCSI Bus Reset.&n;&t; */
id|BusLogic_Delay
c_func
(paren
id|HostAdapter-&gt;BusSettleTime
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   FlashPoint Host Adapters do not provide for Target Device Inquiry.&n;&t; */
r_if
c_cond
(paren
id|BusLogic_FlashPointHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
r_return
l_bool|true
suffix:semicolon
multiline_comment|/*&n;&t;   Inhibit the Target Device Inquiry if requested.&n;&t; */
r_if
c_cond
(paren
id|HostAdapter-&gt;DriverOptions
op_ne
l_int|NULL
op_logical_and
id|HostAdapter-&gt;DriverOptions-&gt;LocalOptions.InhibitTargetInquiry
)paren
r_return
l_bool|true
suffix:semicolon
multiline_comment|/*&n;&t;   Issue the Inquire Target Devices command for host adapters with firmware&n;&t;   version 4.25 or later, or the Inquire Installed Devices ID 0 to 7 command&n;&t;   for older host adapters.  This is necessary to force Synchronous Transfer&n;&t;   Negotiation so that the Inquire Setup Information and Inquire Synchronous&n;&t;   Period commands will return valid data.  The Inquire Target Devices command&n;&t;   is preferable to Inquire Installed Devices ID 0 to 7 since it only probes&n;&t;   Logical Unit 0 of each Target Device.&n;&t; */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|HostAdapter-&gt;FirmwareVersion
comma
l_string|&quot;4.25&quot;
)paren
op_ge
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Issue a Inquire Target Devices command.  Inquire Target Devices only&n;&t;&t; * tests Logical Unit 0 of each Target Device unlike the Inquire Installed&n;&t;&t; * Devices commands which test Logical Units 0 - 7.  Two bytes are&n;&t;&t; * returned, where byte 0 bit 0 set indicates that Target Device 0 exists,&n;&t;&t; * and so on.&n;&t;&t; */
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireTargetDevices
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|InstalledDevices
comma
r_sizeof
(paren
id|InstalledDevices
)paren
)paren
op_ne
r_sizeof
(paren
id|InstalledDevices
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE TARGET DEVICES&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
dot
id|TargetExists
op_assign
(paren
id|InstalledDevices
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
ques
c_cond
l_bool|true
suffix:colon
l_bool|false
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Issue an Inquire Installed Devices command.  For each Target Device,&n;&t;&t; * a byte is returned where bit 0 set indicates that Logical Unit 0&n;&t;&t; * exists, bit 1 set indicates that Logical Unit 1 exists, and so on.&n;&t;&t; */
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireInstalledDevicesID0to7
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|InstalledDevicesID0to7
comma
r_sizeof
(paren
id|InstalledDevicesID0to7
)paren
)paren
op_ne
r_sizeof
(paren
id|InstalledDevicesID0to7
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE INSTALLED DEVICES ID 0 TO 7&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
l_int|8
suffix:semicolon
id|TargetID
op_increment
)paren
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
dot
id|TargetExists
op_assign
(paren
id|InstalledDevicesID0to7
(braket
id|TargetID
)braket
op_ne
l_int|0
ques
c_cond
l_bool|true
suffix:colon
l_bool|false
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Issue the Inquire Setup Information command.&n;&t; */
id|RequestedReplyLength
op_assign
r_sizeof
(paren
id|SetupInformation
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireSetupInformation
comma
op_amp
id|RequestedReplyLength
comma
r_sizeof
(paren
id|RequestedReplyLength
)paren
comma
op_amp
id|SetupInformation
comma
r_sizeof
(paren
id|SetupInformation
)paren
)paren
op_ne
r_sizeof
(paren
id|SetupInformation
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE SETUP INFORMATION&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|HostAdapter-&gt;SynchronousOffset
(braket
id|TargetID
)braket
op_assign
(paren
id|TargetID
OL
l_int|8
ques
c_cond
id|SetupInformation.SynchronousValuesID0to7
(braket
id|TargetID
)braket
dot
id|Offset
suffix:colon
id|SetupInformation.SynchronousValuesID8to15
(braket
id|TargetID
op_minus
l_int|8
)braket
dot
id|Offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|HostAdapter-&gt;FirmwareVersion
comma
l_string|&quot;5.06L&quot;
)paren
op_ge
l_int|0
)paren
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
dot
id|WideTransfersActive
op_assign
(paren
id|TargetID
OL
l_int|8
ques
c_cond
(paren
id|SetupInformation.WideTransfersActiveID0to7
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
ques
c_cond
l_bool|true
suffix:colon
l_bool|false
)paren
suffix:colon
(paren
id|SetupInformation.WideTransfersActiveID8to15
op_amp
(paren
l_int|1
op_lshift
(paren
id|TargetID
op_minus
l_int|8
)paren
)paren
ques
c_cond
l_bool|true
suffix:colon
l_bool|false
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   Issue the Inquire Synchronous Period command.&n;&t; */
r_if
c_cond
(paren
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
op_ge
l_char|&squot;3&squot;
)paren
(brace
multiline_comment|/* Issue a Inquire Synchronous Period command.  For each Target Device,&n;&t;&t; * a byte is returned which represents the Synchronous Transfer Period&n;&t;&t; * in units of 10 nanoseconds.&n;&t;&t; */
id|RequestedReplyLength
op_assign
r_sizeof
(paren
id|SynchronousPeriod
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_Command
c_func
(paren
id|HostAdapter
comma
id|BusLogic_InquireSynchronousPeriod
comma
op_amp
id|RequestedReplyLength
comma
r_sizeof
(paren
id|RequestedReplyLength
)paren
comma
op_amp
id|SynchronousPeriod
comma
r_sizeof
(paren
id|SynchronousPeriod
)paren
)paren
op_ne
r_sizeof
(paren
id|SynchronousPeriod
)paren
)paren
r_return
id|BusLogic_Failure
c_func
(paren
id|HostAdapter
comma
l_string|&quot;INQUIRE SYNCHRONOUS PERIOD&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|HostAdapter-&gt;SynchronousPeriod
(braket
id|TargetID
)braket
op_assign
id|SynchronousPeriod
(braket
id|TargetID
)braket
suffix:semicolon
)brace
r_else
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
r_if
c_cond
(paren
id|SetupInformation.SynchronousValuesID0to7
(braket
id|TargetID
)braket
dot
id|Offset
OG
l_int|0
)paren
id|HostAdapter-&gt;SynchronousPeriod
(braket
id|TargetID
)braket
op_assign
l_int|20
op_plus
l_int|5
op_star
id|SetupInformation.SynchronousValuesID0to7
(braket
id|TargetID
)braket
dot
id|TransferPeriod
suffix:semicolon
multiline_comment|/*&n;&t;   Indicate the Target Device Inquiry completed successfully.&n;&t; */
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_InitializeHostStructure initializes the fields in the SCSI Host&n;  structure.  The base, io_port, n_io_ports, irq, and dma_channel fields in the&n;  SCSI Host structure are intentionally left uninitialized, as this driver&n;  handles acquisition and release of these resources explicitly, as well as&n;  ensuring exclusive access to the Host Adapter hardware and data structures&n;  through explicit acquisition and release of the Host Adapter&squot;s Lock.&n;*/
DECL|function|BusLogic_InitializeHostStructure
r_static
r_void
id|__init
id|BusLogic_InitializeHostStructure
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
comma
r_struct
id|Scsi_Host
op_star
id|Host
)paren
(brace
id|Host-&gt;max_id
op_assign
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|Host-&gt;max_lun
op_assign
id|HostAdapter-&gt;MaxLogicalUnits
suffix:semicolon
id|Host-&gt;max_channel
op_assign
l_int|0
suffix:semicolon
id|Host-&gt;unique_id
op_assign
id|HostAdapter-&gt;IO_Address
suffix:semicolon
id|Host-&gt;this_id
op_assign
id|HostAdapter-&gt;SCSI_ID
suffix:semicolon
id|Host-&gt;can_queue
op_assign
id|HostAdapter-&gt;DriverQueueDepth
suffix:semicolon
id|Host-&gt;sg_tablesize
op_assign
id|HostAdapter-&gt;DriverScatterGatherLimit
suffix:semicolon
id|Host-&gt;unchecked_isa_dma
op_assign
id|HostAdapter-&gt;BounceBuffersRequired
suffix:semicolon
id|Host-&gt;cmd_per_lun
op_assign
id|HostAdapter-&gt;UntaggedQueueDepth
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_SlaveConfigure will actually set the queue depth on individual&n;  scsi devices as they are permanently added to the device chain.  We&n;  shamelessly rip off the SelectQueueDepths code to make this work mostly&n;  like it used to.  Since we don&squot;t get called once at the end of the scan&n;  but instead get called for each device, we have to do things a bit&n;  differently.&n;*/
DECL|function|BusLogic_SlaveConfigure
r_static
r_int
id|BusLogic_SlaveConfigure
c_func
(paren
r_struct
id|scsi_device
op_star
id|Device
)paren
(brace
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
op_assign
(paren
r_struct
id|BusLogic_HostAdapter
op_star
)paren
id|Device-&gt;host-&gt;hostdata
suffix:semicolon
r_int
id|TargetID
op_assign
id|Device-&gt;id
suffix:semicolon
r_int
id|QueueDepth
op_assign
id|HostAdapter-&gt;QueueDepth
(braket
id|TargetID
)braket
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
dot
id|TaggedQueuingSupported
op_logical_and
(paren
id|HostAdapter-&gt;TaggedQueuingPermitted
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|QueueDepth
op_eq
l_int|0
)paren
id|QueueDepth
op_assign
id|BusLogic_MaxAutomaticTaggedQueueDepth
suffix:semicolon
id|HostAdapter-&gt;QueueDepth
(braket
id|TargetID
)braket
op_assign
id|QueueDepth
suffix:semicolon
id|scsi_adjust_queue_depth
c_func
(paren
id|Device
comma
id|MSG_SIMPLE_TAG
comma
id|QueueDepth
)paren
suffix:semicolon
)brace
r_else
(brace
id|HostAdapter-&gt;TaggedQueuingPermitted
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|TargetID
)paren
suffix:semicolon
id|QueueDepth
op_assign
id|HostAdapter-&gt;UntaggedQueueDepth
suffix:semicolon
id|HostAdapter-&gt;QueueDepth
(braket
id|TargetID
)braket
op_assign
id|QueueDepth
suffix:semicolon
id|scsi_adjust_queue_depth
c_func
(paren
id|Device
comma
l_int|0
comma
id|QueueDepth
)paren
suffix:semicolon
)brace
id|QueueDepth
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
r_if
c_cond
(paren
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
dot
id|TargetExists
)paren
(brace
id|QueueDepth
op_add_assign
id|HostAdapter-&gt;QueueDepth
(braket
id|TargetID
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|QueueDepth
OG
id|HostAdapter-&gt;AllocatedCCBs
)paren
id|BusLogic_CreateAdditionalCCBs
c_func
(paren
id|HostAdapter
comma
id|QueueDepth
op_minus
id|HostAdapter-&gt;AllocatedCCBs
comma
l_bool|false
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_DetectHostAdapter probes for BusLogic Host Adapters at the standard&n;  I/O Addresses where they may be located, initializing, registering, and&n;  reporting the configuration of each BusLogic Host Adapter it finds.  It&n;  returns the number of BusLogic Host Adapters successfully initialized and&n;  registered.&n;*/
DECL|function|BusLogic_init
r_static
r_int
id|__init
id|BusLogic_init
c_func
(paren
r_void
)paren
(brace
r_int
id|BusLogicHostAdapterCount
op_assign
l_int|0
comma
id|DriverOptionsIndex
op_assign
l_int|0
comma
id|ProbeIndex
suffix:semicolon
r_struct
id|BusLogic_HostAdapter
op_star
id|PrototypeHostAdapter
suffix:semicolon
macro_line|#ifdef MODULE
r_if
c_cond
(paren
id|BusLogic
)paren
id|BusLogic_Setup
c_func
(paren
id|BusLogic
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|BusLogic_ProbeOptions.NoProbe
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|BusLogic_ProbeInfoList
op_assign
(paren
r_struct
id|BusLogic_ProbeInfo
op_star
)paren
id|kmalloc
c_func
(paren
id|BusLogic_MaxHostAdapters
op_star
r_sizeof
(paren
r_struct
id|BusLogic_ProbeInfo
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_ProbeInfoList
op_eq
l_int|NULL
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Unable to allocate Probe Info List&bslash;n&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|BusLogic_ProbeInfoList
comma
l_int|0
comma
id|BusLogic_MaxHostAdapters
op_star
r_sizeof
(paren
r_struct
id|BusLogic_ProbeInfo
)paren
)paren
suffix:semicolon
id|PrototypeHostAdapter
op_assign
(paren
r_struct
id|BusLogic_HostAdapter
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|BusLogic_HostAdapter
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PrototypeHostAdapter
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|BusLogic_ProbeInfoList
)paren
suffix:semicolon
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Unable to allocate Prototype &quot;
l_string|&quot;Host Adapter&bslash;n&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|PrototypeHostAdapter
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|BusLogic_HostAdapter
)paren
)paren
suffix:semicolon
macro_line|#ifdef MODULE
r_if
c_cond
(paren
id|BusLogic
op_ne
l_int|NULL
)paren
id|BusLogic_Setup
c_func
(paren
id|BusLogic
)paren
suffix:semicolon
macro_line|#endif
id|BusLogic_InitializeProbeInfoList
c_func
(paren
id|PrototypeHostAdapter
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ProbeIndex
op_assign
l_int|0
suffix:semicolon
id|ProbeIndex
OL
id|BusLogic_ProbeInfoCount
suffix:semicolon
id|ProbeIndex
op_increment
)paren
(brace
r_struct
id|BusLogic_ProbeInfo
op_star
id|ProbeInfo
op_assign
op_amp
id|BusLogic_ProbeInfoList
(braket
id|ProbeIndex
)braket
suffix:semicolon
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
op_assign
id|PrototypeHostAdapter
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|Host
suffix:semicolon
r_if
c_cond
(paren
id|ProbeInfo-&gt;IO_Address
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|memset
c_func
(paren
id|HostAdapter
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|BusLogic_HostAdapter
)paren
)paren
suffix:semicolon
id|HostAdapter-&gt;HostAdapterType
op_assign
id|ProbeInfo-&gt;HostAdapterType
suffix:semicolon
id|HostAdapter-&gt;HostAdapterBusType
op_assign
id|ProbeInfo-&gt;HostAdapterBusType
suffix:semicolon
id|HostAdapter-&gt;IO_Address
op_assign
id|ProbeInfo-&gt;IO_Address
suffix:semicolon
id|HostAdapter-&gt;PCI_Address
op_assign
id|ProbeInfo-&gt;PCI_Address
suffix:semicolon
id|HostAdapter-&gt;Bus
op_assign
id|ProbeInfo-&gt;Bus
suffix:semicolon
id|HostAdapter-&gt;Device
op_assign
id|ProbeInfo-&gt;Device
suffix:semicolon
id|HostAdapter-&gt;IRQ_Channel
op_assign
id|ProbeInfo-&gt;IRQ_Channel
suffix:semicolon
id|HostAdapter-&gt;AddressCount
op_assign
id|BusLogic_HostAdapterAddressCount
(braket
id|HostAdapter-&gt;HostAdapterType
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t;   Probe the Host Adapter.  If unsuccessful, abort further initialization.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|BusLogic_ProbeHostAdapter
c_func
(paren
id|HostAdapter
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;   Hard Reset the Host Adapter.  If unsuccessful, abort further&n;&t;&t;   initialization.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|BusLogic_HardwareResetHostAdapter
c_func
(paren
id|HostAdapter
comma
l_bool|true
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;   Check the Host Adapter.  If unsuccessful, abort further initialization.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|BusLogic_CheckHostAdapter
c_func
(paren
id|HostAdapter
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;   Initialize the Driver Options field if provided.&n;&t;&t; */
r_if
c_cond
(paren
id|DriverOptionsIndex
OL
id|BusLogic_DriverOptionsCount
)paren
id|HostAdapter-&gt;DriverOptions
op_assign
op_amp
id|BusLogic_DriverOptions
(braket
id|DriverOptionsIndex
op_increment
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t;   Announce the Driver Version and Date, Author&squot;s Name, Copyright Notice,&n;&t;&t;   and Electronic Mail Address.&n;&t;&t; */
id|BusLogic_AnnounceDriver
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;   Register usage of the I/O Address range.  From this point onward, any&n;&t;&t;   failure will be assumed to be due to a problem with the Host Adapter,&n;&t;&t;   rather than due to having mistakenly identified this port as belonging&n;&t;&t;   to a BusLogic Host Adapter.  The I/O Address range will not be&n;&t;&t;   released, thereby preventing it from being incorrectly identified as&n;&t;&t;   any other type of Host Adapter.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|HostAdapter-&gt;IO_Address
comma
id|HostAdapter-&gt;AddressCount
comma
l_string|&quot;BusLogic&quot;
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;   Register the SCSI Host structure.&n;&t;&t; */
id|Host
op_assign
id|scsi_host_alloc
c_func
(paren
op_amp
id|Bus_Logic_template
comma
r_sizeof
(paren
r_struct
id|BusLogic_HostAdapter
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Host
op_eq
l_int|NULL
)paren
(brace
id|release_region
c_func
(paren
id|HostAdapter-&gt;IO_Address
comma
id|HostAdapter-&gt;AddressCount
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|HostAdapter
op_assign
(paren
r_struct
id|BusLogic_HostAdapter
op_star
)paren
id|Host-&gt;hostdata
suffix:semicolon
id|memcpy
c_func
(paren
id|HostAdapter
comma
id|PrototypeHostAdapter
comma
r_sizeof
(paren
r_struct
id|BusLogic_HostAdapter
)paren
)paren
suffix:semicolon
id|HostAdapter-&gt;SCSI_Host
op_assign
id|Host
suffix:semicolon
id|HostAdapter-&gt;HostNumber
op_assign
id|Host-&gt;host_no
suffix:semicolon
multiline_comment|/*&n;&t;&t;   Add Host Adapter to the end of the list of registered BusLogic&n;&t;&t;   Host Adapters.&n;&t;&t; */
id|list_add_tail
c_func
(paren
op_amp
id|HostAdapter-&gt;host_list
comma
op_amp
id|BusLogic_host_list
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;   Read the Host Adapter Configuration, Configure the Host Adapter,&n;&t;&t;   Acquire the System Resources necessary to use the Host Adapter, then&n;&t;&t;   Create the Initial CCBs, Initialize the Host Adapter, and finally&n;&t;&t;   perform Target Device Inquiry.&n;&t;&t; */
r_if
c_cond
(paren
id|BusLogic_ReadHostAdapterConfiguration
c_func
(paren
id|HostAdapter
)paren
op_logical_and
id|BusLogic_ReportHostAdapterConfiguration
c_func
(paren
id|HostAdapter
)paren
op_logical_and
id|BusLogic_AcquireResources
c_func
(paren
id|HostAdapter
)paren
op_logical_and
id|BusLogic_CreateInitialCCBs
c_func
(paren
id|HostAdapter
)paren
op_logical_and
id|BusLogic_InitializeHostAdapter
c_func
(paren
id|HostAdapter
)paren
op_logical_and
id|BusLogic_TargetDeviceInquiry
c_func
(paren
id|HostAdapter
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;   Initialization has been completed successfully.  Release and&n;&t;&t;&t;   re-register usage of the I/O Address range so that the Model&n;&t;&t;&t;   Name of the Host Adapter will appear, and initialize the SCSI&n;&t;&t;&t;   Host structure.&n;&t;&t;&t; */
id|release_region
c_func
(paren
id|HostAdapter-&gt;IO_Address
comma
id|HostAdapter-&gt;AddressCount
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|HostAdapter-&gt;IO_Address
comma
id|HostAdapter-&gt;AddressCount
comma
id|HostAdapter-&gt;FullModelName
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;BusLogic: Release and re-register of &quot;
l_string|&quot;port 0x%04lx failed &bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|HostAdapter-&gt;IO_Address
)paren
suffix:semicolon
id|BusLogic_DestroyCCBs
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_ReleaseResources
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|HostAdapter-&gt;host_list
)paren
suffix:semicolon
id|scsi_host_put
c_func
(paren
id|Host
)paren
suffix:semicolon
)brace
r_else
(brace
id|BusLogic_InitializeHostStructure
c_func
(paren
id|HostAdapter
comma
id|Host
)paren
suffix:semicolon
id|scsi_add_host
c_func
(paren
id|Host
comma
l_int|NULL
)paren
suffix:semicolon
id|scsi_scan_host
c_func
(paren
id|Host
)paren
suffix:semicolon
id|BusLogicHostAdapterCount
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;   An error occurred during Host Adapter Configuration Querying, Host&n;&t;&t;&t;   Adapter Configuration, Resource Acquisition, CCB Creation, Host&n;&t;&t;&t;   Adapter Initialization, or Target Device Inquiry, so remove Host&n;&t;&t;&t;   Adapter from the list of registered BusLogic Host Adapters, destroy&n;&t;&t;&t;   the CCBs, Release the System Resources, and Unregister the SCSI&n;&t;&t;&t;   Host.&n;&t;&t;&t; */
id|BusLogic_DestroyCCBs
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_ReleaseResources
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|HostAdapter-&gt;host_list
)paren
suffix:semicolon
id|scsi_host_put
c_func
(paren
id|Host
)paren
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|PrototypeHostAdapter
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|BusLogic_ProbeInfoList
)paren
suffix:semicolon
id|BusLogic_ProbeInfoList
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ReleaseHostAdapter releases all resources previously acquired to&n;  support a specific Host Adapter, including the I/O Address range, and&n;  unregisters the BusLogic Host Adapter.&n;*/
DECL|function|BusLogic_ReleaseHostAdapter
r_static
r_int
id|__exit
id|BusLogic_ReleaseHostAdapter
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|Host
op_assign
id|HostAdapter-&gt;SCSI_Host
suffix:semicolon
id|scsi_remove_host
c_func
(paren
id|Host
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   FlashPoint Host Adapters must first be released by the FlashPoint&n;&t;   SCCB Manager.&n;&t; */
r_if
c_cond
(paren
id|BusLogic_FlashPointHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
id|FlashPoint_ReleaseHostAdapter
c_func
(paren
id|HostAdapter-&gt;CardHandle
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   Destroy the CCBs and release any system resources acquired to&n;&t;   support Host Adapter.&n;&t; */
id|BusLogic_DestroyCCBs
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_ReleaseResources
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   Release usage of the I/O Address range.&n;&t; */
id|release_region
c_func
(paren
id|HostAdapter-&gt;IO_Address
comma
id|HostAdapter-&gt;AddressCount
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   Remove Host Adapter from the list of registered BusLogic Host Adapters.&n;&t; */
id|list_del
c_func
(paren
op_amp
id|HostAdapter-&gt;host_list
)paren
suffix:semicolon
id|scsi_host_put
c_func
(paren
id|Host
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_QueueCompletedCCB queues CCB for completion processing.&n;*/
DECL|function|BusLogic_QueueCompletedCCB
r_static
r_void
id|BusLogic_QueueCompletedCCB
c_func
(paren
r_struct
id|BusLogic_CCB
op_star
id|CCB
)paren
(brace
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
op_assign
id|CCB-&gt;HostAdapter
suffix:semicolon
id|CCB-&gt;Status
op_assign
id|BusLogic_CCB_Completed
suffix:semicolon
id|CCB-&gt;Next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;FirstCompletedCCB
op_eq
l_int|NULL
)paren
(brace
id|HostAdapter-&gt;FirstCompletedCCB
op_assign
id|CCB
suffix:semicolon
id|HostAdapter-&gt;LastCompletedCCB
op_assign
id|CCB
suffix:semicolon
)brace
r_else
(brace
id|HostAdapter-&gt;LastCompletedCCB-&gt;Next
op_assign
id|CCB
suffix:semicolon
id|HostAdapter-&gt;LastCompletedCCB
op_assign
id|CCB
suffix:semicolon
)brace
id|HostAdapter-&gt;ActiveCommands
(braket
id|CCB-&gt;TargetID
)braket
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ComputeResultCode computes a SCSI Subsystem Result Code from&n;  the Host Adapter Status and Target Device Status.&n;*/
DECL|function|BusLogic_ComputeResultCode
r_static
r_int
id|BusLogic_ComputeResultCode
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
comma
r_enum
id|BusLogic_HostAdapterStatus
id|HostAdapterStatus
comma
r_enum
id|BusLogic_TargetDeviceStatus
id|TargetDeviceStatus
)paren
(brace
r_int
id|HostStatus
suffix:semicolon
r_switch
c_cond
(paren
id|HostAdapterStatus
)paren
(brace
r_case
id|BusLogic_CommandCompletedNormally
suffix:colon
r_case
id|BusLogic_LinkedCommandCompleted
suffix:colon
r_case
id|BusLogic_LinkedCommandCompletedWithFlag
suffix:colon
id|HostStatus
op_assign
id|DID_OK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BusLogic_SCSISelectionTimeout
suffix:colon
id|HostStatus
op_assign
id|DID_TIME_OUT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BusLogic_InvalidOutgoingMailboxActionCode
suffix:colon
r_case
id|BusLogic_InvalidCommandOperationCode
suffix:colon
r_case
id|BusLogic_InvalidCommandParameter
suffix:colon
id|BusLogic_Warning
c_func
(paren
l_string|&quot;BusLogic Driver Protocol Error 0x%02X&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapterStatus
)paren
suffix:semicolon
r_case
id|BusLogic_DataUnderRun
suffix:colon
r_case
id|BusLogic_DataOverRun
suffix:colon
r_case
id|BusLogic_UnexpectedBusFree
suffix:colon
r_case
id|BusLogic_LinkedCCBhasInvalidLUN
suffix:colon
r_case
id|BusLogic_AutoRequestSenseFailed
suffix:colon
r_case
id|BusLogic_TaggedQueuingMessageRejected
suffix:colon
r_case
id|BusLogic_UnsupportedMessageReceived
suffix:colon
r_case
id|BusLogic_HostAdapterHardwareFailed
suffix:colon
r_case
id|BusLogic_TargetDeviceReconnectedImproperly
suffix:colon
r_case
id|BusLogic_AbortQueueGenerated
suffix:colon
r_case
id|BusLogic_HostAdapterSoftwareError
suffix:colon
r_case
id|BusLogic_HostAdapterHardwareTimeoutError
suffix:colon
r_case
id|BusLogic_SCSIParityErrorDetected
suffix:colon
id|HostStatus
op_assign
id|DID_ERROR
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BusLogic_InvalidBusPhaseRequested
suffix:colon
r_case
id|BusLogic_TargetFailedResponseToATN
suffix:colon
r_case
id|BusLogic_HostAdapterAssertedRST
suffix:colon
r_case
id|BusLogic_OtherDeviceAssertedRST
suffix:colon
r_case
id|BusLogic_HostAdapterAssertedBusDeviceReset
suffix:colon
id|HostStatus
op_assign
id|DID_RESET
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unknown Host Adapter Status 0x%02X&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapterStatus
)paren
suffix:semicolon
id|HostStatus
op_assign
id|DID_ERROR
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
(paren
id|HostStatus
op_lshift
l_int|16
)paren
op_or
id|TargetDeviceStatus
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ScanIncomingMailboxes scans the Incoming Mailboxes saving any&n;  Incoming Mailbox entries for completion processing.&n;*/
DECL|function|BusLogic_ScanIncomingMailboxes
r_static
r_void
id|BusLogic_ScanIncomingMailboxes
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
)paren
(brace
multiline_comment|/*&n;&t;   Scan through the Incoming Mailboxes in Strict Round Robin fashion, saving&n;&t;   any completed CCBs for further processing.  It is essential that for each&n;&t;   CCB and SCSI Command issued, command completion processing is performed&n;&t;   exactly once.  Therefore, only Incoming Mailboxes with completion code&n;&t;   Command Completed Without Error, Command Completed With Error, or Command&n;&t;   Aborted At Host Request are saved for completion processing.  When an&n;&t;   Incoming Mailbox has a completion code of Aborted Command Not Found, the&n;&t;   CCB had already completed or been aborted before the current Abort request&n;&t;   was processed, and so completion processing has already occurred and no&n;&t;   further action should be taken.&n;&t; */
r_struct
id|BusLogic_IncomingMailbox
op_star
id|NextIncomingMailbox
op_assign
id|HostAdapter-&gt;NextIncomingMailbox
suffix:semicolon
r_enum
id|BusLogic_CompletionCode
id|CompletionCode
suffix:semicolon
r_while
c_loop
(paren
(paren
id|CompletionCode
op_assign
id|NextIncomingMailbox-&gt;CompletionCode
)paren
op_ne
id|BusLogic_IncomingMailboxFree
)paren
(brace
multiline_comment|/*&n;&t;&t;   We are only allowed to do this because we limit our architectures we&n;&t;&t;   run on to machines where bus_to_virt() actually works.  There *needs*&n;&t;&t;   to be a dma_addr_to_virt() in the new PCI DMA mapping interface to&n;&t;&t;   replace bus_to_virt() or else this code is going to become very&n;&t;&t;   innefficient.&n;&t;&t; */
r_struct
id|BusLogic_CCB
op_star
id|CCB
op_assign
(paren
r_struct
id|BusLogic_CCB
op_star
)paren
id|Bus_to_Virtual
c_func
(paren
id|NextIncomingMailbox-&gt;CCB
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CompletionCode
op_ne
id|BusLogic_AbortedCommandNotFound
)paren
(brace
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Active
op_logical_or
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Reset
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;   Save the Completion Code for this CCB and queue the CCB&n;&t;&t;&t;&t;   for completion processing.&n;&t;&t;&t;&t; */
id|CCB-&gt;CompletionCode
op_assign
id|CompletionCode
suffix:semicolon
id|BusLogic_QueueCompletedCCB
c_func
(paren
id|CCB
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;   If a CCB ever appears in an Incoming Mailbox and is not marked&n;&t;&t;&t;&t;   as status Active or Reset, then there is most likely a bug in&n;&t;&t;&t;&t;   the Host Adapter firmware.&n;&t;&t;&t;&t; */
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Illegal CCB #%ld status %d in &quot;
l_string|&quot;Incoming Mailbox&bslash;n&quot;
comma
id|HostAdapter
comma
id|CCB-&gt;SerialNumber
comma
id|CCB-&gt;Status
)paren
suffix:semicolon
)brace
)brace
id|NextIncomingMailbox-&gt;CompletionCode
op_assign
id|BusLogic_IncomingMailboxFree
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|NextIncomingMailbox
OG
id|HostAdapter-&gt;LastIncomingMailbox
)paren
id|NextIncomingMailbox
op_assign
id|HostAdapter-&gt;FirstIncomingMailbox
suffix:semicolon
)brace
id|HostAdapter-&gt;NextIncomingMailbox
op_assign
id|NextIncomingMailbox
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ProcessCompletedCCBs iterates over the completed CCBs for Host&n;  Adapter setting the SCSI Command Result Codes, deallocating the CCBs, and&n;  calling the SCSI Subsystem Completion Routines.  The Host Adapter&squot;s Lock&n;  should already have been acquired by the caller.&n;*/
DECL|function|BusLogic_ProcessCompletedCCBs
r_static
r_void
id|BusLogic_ProcessCompletedCCBs
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
)paren
(brace
r_if
c_cond
(paren
id|HostAdapter-&gt;ProcessCompletedCCBsActive
)paren
r_return
suffix:semicolon
id|HostAdapter-&gt;ProcessCompletedCCBsActive
op_assign
l_bool|true
suffix:semicolon
r_while
c_loop
(paren
id|HostAdapter-&gt;FirstCompletedCCB
op_ne
l_int|NULL
)paren
(brace
r_struct
id|BusLogic_CCB
op_star
id|CCB
op_assign
id|HostAdapter-&gt;FirstCompletedCCB
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|Command
op_assign
id|CCB-&gt;Command
suffix:semicolon
id|HostAdapter-&gt;FirstCompletedCCB
op_assign
id|CCB-&gt;Next
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;FirstCompletedCCB
op_eq
l_int|NULL
)paren
id|HostAdapter-&gt;LastCompletedCCB
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t;   Process the Completed CCB.&n;&t;&t; */
r_if
c_cond
(paren
id|CCB-&gt;Opcode
op_eq
id|BusLogic_BusDeviceReset
)paren
(brace
r_int
id|TargetID
op_assign
id|CCB-&gt;TargetID
suffix:semicolon
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Bus Device Reset CCB #%ld to Target &quot;
l_string|&quot;%d Completed&bslash;n&quot;
comma
id|HostAdapter
comma
id|CCB-&gt;SerialNumber
comma
id|TargetID
)paren
suffix:semicolon
id|BusLogic_IncrementErrorCounter
c_func
(paren
op_amp
id|HostAdapter-&gt;TargetStatistics
(braket
id|TargetID
)braket
dot
id|BusDeviceResetsCompleted
)paren
suffix:semicolon
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
dot
id|TaggedQueuingActive
op_assign
l_bool|false
suffix:semicolon
id|HostAdapter-&gt;CommandsSinceReset
(braket
id|TargetID
)braket
op_assign
l_int|0
suffix:semicolon
id|HostAdapter-&gt;LastResetCompleted
(braket
id|TargetID
)braket
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;   Place CCB back on the Host Adapter&squot;s free list.&n;&t;&t;&t; */
id|BusLogic_DeallocateCCB
c_func
(paren
id|CCB
)paren
suffix:semicolon
macro_line|#if 0&t;&t;&t;&t;/* this needs to be redone different for new EH */
multiline_comment|/*&n;&t;&t;&t;   Bus Device Reset CCBs have the Command field non-NULL only when a&n;&t;&t;&t;   Bus Device Reset was requested for a Command that did not have a&n;&t;&t;&t;   currently active CCB in the Host Adapter (i.e., a Synchronous&n;&t;&t;&t;   Bus Device Reset), and hence would not have its Completion Routine&n;&t;&t;&t;   called otherwise.&n;&t;&t;&t; */
r_while
c_loop
(paren
id|Command
op_ne
l_int|NULL
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|NextCommand
op_assign
id|Command-&gt;reset_chain
suffix:semicolon
id|Command-&gt;reset_chain
op_assign
l_int|NULL
suffix:semicolon
id|Command-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|Command
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|Command
)paren
suffix:semicolon
id|Command
op_assign
id|NextCommand
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t;   Iterate over the CCBs for this Host Adapter performing completion&n;&t;&t;&t;   processing for any CCBs marked as Reset for this Target.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|CCB
op_assign
id|HostAdapter-&gt;All_CCBs
suffix:semicolon
id|CCB
op_ne
l_int|NULL
suffix:semicolon
id|CCB
op_assign
id|CCB-&gt;NextAll
)paren
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Reset
op_logical_and
id|CCB-&gt;TargetID
op_eq
id|TargetID
)paren
(brace
id|Command
op_assign
id|CCB-&gt;Command
suffix:semicolon
id|BusLogic_DeallocateCCB
c_func
(paren
id|CCB
)paren
suffix:semicolon
id|HostAdapter-&gt;ActiveCommands
(braket
id|TargetID
)braket
op_decrement
suffix:semicolon
id|Command-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|Command
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|Command
)paren
suffix:semicolon
)brace
id|HostAdapter-&gt;BusDeviceResetPendingCCB
(braket
id|TargetID
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;   Translate the Completion Code, Host Adapter Status, and Target&n;&t;&t;&t;   Device Status into a SCSI Subsystem Result Code.&n;&t;&t;&t; */
r_switch
c_cond
(paren
id|CCB-&gt;CompletionCode
)paren
(brace
r_case
id|BusLogic_IncomingMailboxFree
suffix:colon
r_case
id|BusLogic_AbortedCommandNotFound
suffix:colon
r_case
id|BusLogic_InvalidCCB
suffix:colon
id|BusLogic_Warning
c_func
(paren
l_string|&quot;CCB #%ld to Target %d Impossible State&bslash;n&quot;
comma
id|HostAdapter
comma
id|CCB-&gt;SerialNumber
comma
id|CCB-&gt;TargetID
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BusLogic_CommandCompletedWithoutError
suffix:colon
id|HostAdapter-&gt;TargetStatistics
(braket
id|CCB-&gt;TargetID
)braket
dot
id|CommandsCompleted
op_increment
suffix:semicolon
id|HostAdapter-&gt;TargetFlags
(braket
id|CCB-&gt;TargetID
)braket
dot
id|CommandSuccessfulFlag
op_assign
l_bool|true
suffix:semicolon
id|Command-&gt;result
op_assign
id|DID_OK
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BusLogic_CommandAbortedAtHostRequest
suffix:colon
id|BusLogic_Warning
c_func
(paren
l_string|&quot;CCB #%ld to Target %d Aborted&bslash;n&quot;
comma
id|HostAdapter
comma
id|CCB-&gt;SerialNumber
comma
id|CCB-&gt;TargetID
)paren
suffix:semicolon
id|BusLogic_IncrementErrorCounter
c_func
(paren
op_amp
id|HostAdapter-&gt;TargetStatistics
(braket
id|CCB-&gt;TargetID
)braket
dot
id|CommandAbortsCompleted
)paren
suffix:semicolon
id|Command-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BusLogic_CommandCompletedWithError
suffix:colon
id|Command-&gt;result
op_assign
id|BusLogic_ComputeResultCode
c_func
(paren
id|HostAdapter
comma
id|CCB-&gt;HostAdapterStatus
comma
id|CCB-&gt;TargetDeviceStatus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CCB-&gt;HostAdapterStatus
op_ne
id|BusLogic_SCSISelectionTimeout
)paren
(brace
id|HostAdapter-&gt;TargetStatistics
(braket
id|CCB-&gt;TargetID
)braket
dot
id|CommandsCompleted
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_GlobalOptions.TraceErrors
)paren
(brace
r_int
id|i
suffix:semicolon
id|BusLogic_Notice
c_func
(paren
l_string|&quot;CCB #%ld Target %d: Result %X Host &quot;
l_string|&quot;Adapter Status %02X &quot;
l_string|&quot;Target Status %02X&bslash;n&quot;
comma
id|HostAdapter
comma
id|CCB-&gt;SerialNumber
comma
id|CCB-&gt;TargetID
comma
id|Command-&gt;result
comma
id|CCB-&gt;HostAdapterStatus
comma
id|CCB-&gt;TargetDeviceStatus
)paren
suffix:semicolon
id|BusLogic_Notice
c_func
(paren
l_string|&quot;CDB   &quot;
comma
id|HostAdapter
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CCB-&gt;CDB_Length
suffix:semicolon
id|i
op_increment
)paren
id|BusLogic_Notice
c_func
(paren
l_string|&quot; %02X&quot;
comma
id|HostAdapter
comma
id|CCB-&gt;CDB
(braket
id|i
)braket
)paren
suffix:semicolon
id|BusLogic_Notice
c_func
(paren
l_string|&quot;&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_Notice
c_func
(paren
l_string|&quot;Sense &quot;
comma
id|HostAdapter
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CCB-&gt;SenseDataLength
suffix:semicolon
id|i
op_increment
)paren
id|BusLogic_Notice
c_func
(paren
l_string|&quot; %02X&quot;
comma
id|HostAdapter
comma
id|Command-&gt;sense_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
id|BusLogic_Notice
c_func
(paren
l_string|&quot;&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;   When an INQUIRY command completes normally, save the&n;&t;&t;&t;   CmdQue (Tagged Queuing Supported) and WBus16 (16 Bit&n;&t;&t;&t;   Wide Data Transfers Supported) bits.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|CCB-&gt;CDB
(braket
l_int|0
)braket
op_eq
id|INQUIRY
op_logical_and
id|CCB-&gt;CDB
(braket
l_int|1
)braket
op_eq
l_int|0
op_logical_and
id|CCB-&gt;HostAdapterStatus
op_eq
id|BusLogic_CommandCompletedNormally
)paren
(brace
r_struct
id|BusLogic_TargetFlags
op_star
id|TargetFlags
op_assign
op_amp
id|HostAdapter-&gt;TargetFlags
(braket
id|CCB-&gt;TargetID
)braket
suffix:semicolon
r_struct
id|SCSI_Inquiry
op_star
id|InquiryResult
op_assign
(paren
r_struct
id|SCSI_Inquiry
op_star
)paren
id|Command-&gt;request_buffer
suffix:semicolon
id|TargetFlags-&gt;TargetExists
op_assign
l_bool|true
suffix:semicolon
id|TargetFlags-&gt;TaggedQueuingSupported
op_assign
id|InquiryResult-&gt;CmdQue
suffix:semicolon
id|TargetFlags-&gt;WideTransfersSupported
op_assign
id|InquiryResult-&gt;WBus16
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;   Place CCB back on the Host Adapter&squot;s free list.&n;&t;&t;&t; */
id|BusLogic_DeallocateCCB
c_func
(paren
id|CCB
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;   Call the SCSI Command Completion Routine.&n;&t;&t;&t; */
id|Command
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|Command
)paren
suffix:semicolon
)brace
)brace
id|HostAdapter-&gt;ProcessCompletedCCBsActive
op_assign
l_bool|false
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_InterruptHandler handles hardware interrupts from BusLogic Host&n;  Adapters.&n;*/
DECL|function|BusLogic_InterruptHandler
r_static
id|irqreturn_t
id|BusLogic_InterruptHandler
c_func
(paren
r_int
id|IRQ_Channel
comma
r_void
op_star
id|DeviceIdentifier
comma
r_struct
id|pt_regs
op_star
id|InterruptRegisters
)paren
(brace
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
op_assign
(paren
r_struct
id|BusLogic_HostAdapter
op_star
)paren
id|DeviceIdentifier
suffix:semicolon
r_int
r_int
id|ProcessorFlags
suffix:semicolon
multiline_comment|/*&n;&t;   Acquire exclusive access to Host Adapter.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
id|HostAdapter-&gt;SCSI_Host-&gt;host_lock
comma
id|ProcessorFlags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   Handle Interrupts appropriately for each Host Adapter type.&n;&t; */
r_if
c_cond
(paren
id|BusLogic_MultiMasterHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
(brace
r_union
id|BusLogic_InterruptRegister
id|InterruptRegister
suffix:semicolon
multiline_comment|/*&n;&t;&t;   Read the Host Adapter Interrupt Register.&n;&t;&t; */
id|InterruptRegister.All
op_assign
id|BusLogic_ReadInterruptRegister
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|InterruptRegister.ir.InterruptValid
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;   Acknowledge the interrupt and reset the Host Adapter&n;&t;&t;&t;   Interrupt Register.&n;&t;&t;&t; */
id|BusLogic_InterruptReset
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;   Process valid External SCSI Bus Reset and Incoming Mailbox&n;&t;&t;&t;   Loaded Interrupts.  Command Complete Interrupts are noted,&n;&t;&t;&t;   and Outgoing Mailbox Available Interrupts are ignored, as&n;&t;&t;&t;   they are never enabled.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|InterruptRegister.ir.ExternalBusReset
)paren
id|HostAdapter-&gt;HostAdapterExternalReset
op_assign
l_bool|true
suffix:semicolon
r_else
r_if
c_cond
(paren
id|InterruptRegister.ir.IncomingMailboxLoaded
)paren
id|BusLogic_ScanIncomingMailboxes
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|InterruptRegister.ir.CommandComplete
)paren
id|HostAdapter-&gt;HostAdapterCommandCompleted
op_assign
l_bool|true
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;   Check if there is a pending interrupt for this Host Adapter.&n;&t;&t; */
r_if
c_cond
(paren
id|FlashPoint_InterruptPending
c_func
(paren
id|HostAdapter-&gt;CardHandle
)paren
)paren
r_switch
c_cond
(paren
id|FlashPoint_HandleInterrupt
c_func
(paren
id|HostAdapter-&gt;CardHandle
)paren
)paren
(brace
r_case
id|FlashPoint_NormalInterrupt
suffix:colon
r_break
suffix:semicolon
r_case
id|FlashPoint_ExternalBusReset
suffix:colon
id|HostAdapter-&gt;HostAdapterExternalReset
op_assign
l_bool|true
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FlashPoint_InternalError
suffix:colon
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Internal FlashPoint Error detected&quot;
l_string|&quot; - Resetting Host Adapter&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
id|HostAdapter-&gt;HostAdapterInternalError
op_assign
l_bool|true
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;   Process any completed CCBs.&n;&t; */
r_if
c_cond
(paren
id|HostAdapter-&gt;FirstCompletedCCB
op_ne
l_int|NULL
)paren
id|BusLogic_ProcessCompletedCCBs
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   Reset the Host Adapter if requested.&n;&t; */
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterExternalReset
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Resetting %s due to External SCSI Bus Reset&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;FullModelName
)paren
suffix:semicolon
id|BusLogic_IncrementErrorCounter
c_func
(paren
op_amp
id|HostAdapter-&gt;ExternalHostAdapterResets
)paren
suffix:semicolon
id|BusLogic_ResetHostAdapter
c_func
(paren
id|HostAdapter
comma
l_bool|false
)paren
suffix:semicolon
id|HostAdapter-&gt;HostAdapterExternalReset
op_assign
l_bool|false
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|HostAdapter-&gt;HostAdapterInternalError
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Resetting %s due to Host Adapter Internal Error&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;FullModelName
)paren
suffix:semicolon
id|BusLogic_IncrementErrorCounter
c_func
(paren
op_amp
id|HostAdapter-&gt;HostAdapterInternalErrors
)paren
suffix:semicolon
id|BusLogic_ResetHostAdapter
c_func
(paren
id|HostAdapter
comma
l_bool|true
)paren
suffix:semicolon
id|HostAdapter-&gt;HostAdapterInternalError
op_assign
l_bool|false
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Release exclusive access to Host Adapter.&n;&t; */
id|spin_unlock_irqrestore
c_func
(paren
id|HostAdapter-&gt;SCSI_Host-&gt;host_lock
comma
id|ProcessorFlags
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_WriteOutgoingMailbox places CCB and Action Code into an Outgoing&n;  Mailbox for execution by Host Adapter.  The Host Adapter&squot;s Lock should&n;  already have been acquired by the caller.&n;*/
DECL|function|BusLogic_WriteOutgoingMailbox
r_static
id|boolean
id|BusLogic_WriteOutgoingMailbox
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
comma
r_enum
id|BusLogic_ActionCode
id|ActionCode
comma
r_struct
id|BusLogic_CCB
op_star
id|CCB
)paren
(brace
r_struct
id|BusLogic_OutgoingMailbox
op_star
id|NextOutgoingMailbox
suffix:semicolon
id|NextOutgoingMailbox
op_assign
id|HostAdapter-&gt;NextOutgoingMailbox
suffix:semicolon
r_if
c_cond
(paren
id|NextOutgoingMailbox-&gt;ActionCode
op_eq
id|BusLogic_OutgoingMailboxFree
)paren
(brace
id|CCB-&gt;Status
op_assign
id|BusLogic_CCB_Active
suffix:semicolon
multiline_comment|/*&n;&t;&t;   The CCB field must be written before the Action Code field since&n;&t;&t;   the Host Adapter is operating asynchronously and the locking code&n;&t;&t;   does not protect against simultaneous access by the Host Adapter.&n;&t;&t; */
id|NextOutgoingMailbox-&gt;CCB
op_assign
id|CCB-&gt;DMA_Handle
suffix:semicolon
id|NextOutgoingMailbox-&gt;ActionCode
op_assign
id|ActionCode
suffix:semicolon
id|BusLogic_StartMailboxCommand
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|NextOutgoingMailbox
OG
id|HostAdapter-&gt;LastOutgoingMailbox
)paren
id|NextOutgoingMailbox
op_assign
id|HostAdapter-&gt;FirstOutgoingMailbox
suffix:semicolon
id|HostAdapter-&gt;NextOutgoingMailbox
op_assign
id|NextOutgoingMailbox
suffix:semicolon
r_if
c_cond
(paren
id|ActionCode
op_eq
id|BusLogic_MailboxStartCommand
)paren
(brace
id|HostAdapter-&gt;ActiveCommands
(braket
id|CCB-&gt;TargetID
)braket
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|CCB-&gt;Opcode
op_ne
id|BusLogic_BusDeviceReset
)paren
id|HostAdapter-&gt;TargetStatistics
(braket
id|CCB-&gt;TargetID
)braket
dot
id|CommandsAttempted
op_increment
suffix:semicolon
)brace
r_return
l_bool|true
suffix:semicolon
)brace
r_return
l_bool|false
suffix:semicolon
)brace
multiline_comment|/* Error Handling (EH) support */
DECL|function|BusLogic_host_reset
r_static
r_int
id|BusLogic_host_reset
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|SCpnt
)paren
(brace
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
op_assign
(paren
r_struct
id|BusLogic_HostAdapter
op_star
)paren
id|SCpnt-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|id
op_assign
id|SCpnt-&gt;device-&gt;id
suffix:semicolon
r_struct
id|BusLogic_TargetStatistics
op_star
id|stats
op_assign
op_amp
id|HostAdapter-&gt;TargetStatistics
(braket
id|id
)braket
suffix:semicolon
id|BusLogic_IncrementErrorCounter
c_func
(paren
op_amp
id|stats-&gt;HostAdapterResetsRequested
)paren
suffix:semicolon
r_return
id|BusLogic_ResetHostAdapter
c_func
(paren
id|HostAdapter
comma
l_bool|false
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_QueueCommand creates a CCB for Command and places it into an&n;  Outgoing Mailbox for execution by the associated Host Adapter.&n;*/
DECL|function|BusLogic_QueueCommand
r_static
r_int
id|BusLogic_QueueCommand
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|Command
comma
r_void
(paren
op_star
id|CompletionRoutine
)paren
(paren
r_struct
id|scsi_cmnd
op_star
)paren
)paren
(brace
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
op_assign
(paren
r_struct
id|BusLogic_HostAdapter
op_star
)paren
id|Command-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
r_struct
id|BusLogic_TargetFlags
op_star
id|TargetFlags
op_assign
op_amp
id|HostAdapter-&gt;TargetFlags
(braket
id|Command-&gt;device-&gt;id
)braket
suffix:semicolon
r_struct
id|BusLogic_TargetStatistics
op_star
id|TargetStatistics
op_assign
id|HostAdapter-&gt;TargetStatistics
suffix:semicolon
r_int
r_char
op_star
id|CDB
op_assign
id|Command-&gt;cmnd
suffix:semicolon
r_int
id|CDB_Length
op_assign
id|Command-&gt;cmd_len
suffix:semicolon
r_int
id|TargetID
op_assign
id|Command-&gt;device-&gt;id
suffix:semicolon
r_int
id|LogicalUnit
op_assign
id|Command-&gt;device-&gt;lun
suffix:semicolon
r_void
op_star
id|BufferPointer
op_assign
id|Command-&gt;request_buffer
suffix:semicolon
r_int
id|BufferLength
op_assign
id|Command-&gt;request_bufflen
suffix:semicolon
r_int
id|SegmentCount
op_assign
id|Command-&gt;use_sg
suffix:semicolon
r_struct
id|BusLogic_CCB
op_star
id|CCB
suffix:semicolon
multiline_comment|/*&n;&t;   SCSI REQUEST_SENSE commands will be executed automatically by the Host&n;&t;   Adapter for any errors, so they should not be executed explicitly unless&n;&t;   the Sense Data is zero indicating that no error occurred.&n;&t; */
r_if
c_cond
(paren
id|CDB
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
op_logical_and
id|Command-&gt;sense_buffer
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
(brace
id|Command-&gt;result
op_assign
id|DID_OK
op_lshift
l_int|16
suffix:semicolon
id|CompletionRoutine
c_func
(paren
id|Command
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Allocate a CCB from the Host Adapter&squot;s free list.  In the unlikely event&n;&t;   that there are none available and memory allocation fails, wait 1 second&n;&t;   and try again.  If that fails, the Host Adapter is probably hung so signal&n;&t;   an error as a Host Adapter Hard Reset should be initiated soon.&n;&t; */
id|CCB
op_assign
id|BusLogic_AllocateCCB
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CCB
op_eq
l_int|NULL
)paren
(brace
id|spin_unlock_irq
c_func
(paren
id|HostAdapter-&gt;SCSI_Host-&gt;host_lock
)paren
suffix:semicolon
id|BusLogic_Delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|HostAdapter-&gt;SCSI_Host-&gt;host_lock
)paren
suffix:semicolon
id|CCB
op_assign
id|BusLogic_AllocateCCB
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CCB
op_eq
l_int|NULL
)paren
(brace
id|Command-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|CompletionRoutine
c_func
(paren
id|Command
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;   Initialize the fields in the BusLogic Command Control Block (CCB).&n;&t; */
r_if
c_cond
(paren
id|SegmentCount
op_eq
l_int|0
op_logical_and
id|BufferLength
op_ne
l_int|0
)paren
(brace
id|CCB-&gt;Opcode
op_assign
id|BusLogic_InitiatorCCB
suffix:semicolon
id|CCB-&gt;DataLength
op_assign
id|BufferLength
suffix:semicolon
id|CCB-&gt;DataPointer
op_assign
id|pci_map_single
c_func
(paren
id|HostAdapter-&gt;PCI_Device
comma
id|BufferPointer
comma
id|BufferLength
comma
id|Command-&gt;sc_data_direction
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SegmentCount
op_ne
l_int|0
)paren
(brace
r_struct
id|scatterlist
op_star
id|ScatterList
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|BufferPointer
suffix:semicolon
r_int
id|Segment
comma
id|Count
suffix:semicolon
id|Count
op_assign
id|pci_map_sg
c_func
(paren
id|HostAdapter-&gt;PCI_Device
comma
id|ScatterList
comma
id|SegmentCount
comma
id|Command-&gt;sc_data_direction
)paren
suffix:semicolon
id|CCB-&gt;Opcode
op_assign
id|BusLogic_InitiatorCCB_ScatterGather
suffix:semicolon
id|CCB-&gt;DataLength
op_assign
id|Count
op_star
r_sizeof
(paren
r_struct
id|BusLogic_ScatterGatherSegment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_MultiMasterHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
id|CCB-&gt;DataPointer
op_assign
(paren
r_int
r_int
)paren
id|CCB-&gt;DMA_Handle
op_plus
(paren
(paren
r_int
r_int
)paren
op_amp
id|CCB-&gt;ScatterGatherList
op_minus
(paren
r_int
r_int
)paren
id|CCB
)paren
suffix:semicolon
r_else
id|CCB-&gt;DataPointer
op_assign
id|Virtual_to_32Bit_Virtual
c_func
(paren
id|CCB-&gt;ScatterGatherList
)paren
suffix:semicolon
r_for
c_loop
(paren
id|Segment
op_assign
l_int|0
suffix:semicolon
id|Segment
OL
id|Count
suffix:semicolon
id|Segment
op_increment
)paren
(brace
id|CCB-&gt;ScatterGatherList
(braket
id|Segment
)braket
dot
id|SegmentByteCount
op_assign
id|sg_dma_len
c_func
(paren
id|ScatterList
op_plus
id|Segment
)paren
suffix:semicolon
id|CCB-&gt;ScatterGatherList
(braket
id|Segment
)braket
dot
id|SegmentDataPointer
op_assign
id|sg_dma_address
c_func
(paren
id|ScatterList
op_plus
id|Segment
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|CCB-&gt;Opcode
op_assign
id|BusLogic_InitiatorCCB
suffix:semicolon
id|CCB-&gt;DataLength
op_assign
id|BufferLength
suffix:semicolon
id|CCB-&gt;DataPointer
op_assign
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|CDB
(braket
l_int|0
)braket
)paren
(brace
r_case
id|READ_6
suffix:colon
r_case
id|READ_10
suffix:colon
id|CCB-&gt;DataDirection
op_assign
id|BusLogic_DataInLengthChecked
suffix:semicolon
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommands
op_increment
suffix:semicolon
id|BusLogic_IncrementByteCounter
c_func
(paren
op_amp
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|TotalBytesRead
comma
id|BufferLength
)paren
suffix:semicolon
id|BusLogic_IncrementSizeBucket
c_func
(paren
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommandSizeBuckets
comma
id|BufferLength
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WRITE_6
suffix:colon
r_case
id|WRITE_10
suffix:colon
id|CCB-&gt;DataDirection
op_assign
id|BusLogic_DataOutLengthChecked
suffix:semicolon
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommands
op_increment
suffix:semicolon
id|BusLogic_IncrementByteCounter
c_func
(paren
op_amp
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|TotalBytesWritten
comma
id|BufferLength
)paren
suffix:semicolon
id|BusLogic_IncrementSizeBucket
c_func
(paren
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommandSizeBuckets
comma
id|BufferLength
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|CCB-&gt;DataDirection
op_assign
id|BusLogic_UncheckedDataTransfer
suffix:semicolon
r_break
suffix:semicolon
)brace
id|CCB-&gt;CDB_Length
op_assign
id|CDB_Length
suffix:semicolon
id|CCB-&gt;HostAdapterStatus
op_assign
l_int|0
suffix:semicolon
id|CCB-&gt;TargetDeviceStatus
op_assign
l_int|0
suffix:semicolon
id|CCB-&gt;TargetID
op_assign
id|TargetID
suffix:semicolon
id|CCB-&gt;LogicalUnit
op_assign
id|LogicalUnit
suffix:semicolon
id|CCB-&gt;TagEnable
op_assign
l_bool|false
suffix:semicolon
id|CCB-&gt;LegacyTagEnable
op_assign
l_bool|false
suffix:semicolon
multiline_comment|/*&n;&t;   BusLogic recommends that after a Reset the first couple of commands that&n;&t;   are sent to a Target Device be sent in a non Tagged Queue fashion so that&n;&t;   the Host Adapter and Target Device can establish Synchronous and Wide&n;&t;   Transfer before Queue Tag messages can interfere with the Synchronous and&n;&t;   Wide Negotiation messages.  By waiting to enable Tagged Queuing until after&n;&t;   the first BusLogic_MaxTaggedQueueDepth commands have been queued, it is&n;&t;   assured that after a Reset any pending commands are requeued before Tagged&n;&t;   Queuing is enabled and that the Tagged Queuing message will not occur while&n;&t;   the partition table is being printed.  In addition, some devices do not&n;&t;   properly handle the transition from non-tagged to tagged commands, so it is&n;&t;   necessary to wait until there are no pending commands for a target device&n;&t;   before queuing tagged commands.&n;&t; */
r_if
c_cond
(paren
id|HostAdapter-&gt;CommandsSinceReset
(braket
id|TargetID
)braket
op_increment
op_ge
id|BusLogic_MaxTaggedQueueDepth
op_logical_and
op_logical_neg
id|TargetFlags-&gt;TaggedQueuingActive
op_logical_and
id|HostAdapter-&gt;ActiveCommands
(braket
id|TargetID
)braket
op_eq
l_int|0
op_logical_and
id|TargetFlags-&gt;TaggedQueuingSupported
op_logical_and
(paren
id|HostAdapter-&gt;TaggedQueuingPermitted
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
)paren
)paren
(brace
id|TargetFlags-&gt;TaggedQueuingActive
op_assign
l_bool|true
suffix:semicolon
id|BusLogic_Notice
c_func
(paren
l_string|&quot;Tagged Queuing now active for Target %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|TargetID
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TargetFlags-&gt;TaggedQueuingActive
)paren
(brace
r_enum
id|BusLogic_QueueTag
id|QueueTag
op_assign
id|BusLogic_SimpleQueueTag
suffix:semicolon
multiline_comment|/*&n;&t;&t;   When using Tagged Queuing with Simple Queue Tags, it appears that disk&n;&t;&t;   drive controllers do not guarantee that a queued command will not&n;&t;&t;   remain in a disconnected state indefinitely if commands that read or&n;&t;&t;   write nearer the head position continue to arrive without interruption.&n;&t;&t;   Therefore, for each Target Device this driver keeps track of the last&n;&t;&t;   time either the queue was empty or an Ordered Queue Tag was issued.  If&n;&t;&t;   more than 4 seconds (one fifth of the 20 second disk timeout) have&n;&t;&t;   elapsed since this last sequence point, this command will be issued&n;&t;&t;   with an Ordered Queue Tag rather than a Simple Queue Tag, which forces&n;&t;&t;   the Target Device to complete all previously queued commands before&n;&t;&t;   this command may be executed.&n;&t;&t; */
r_if
c_cond
(paren
id|HostAdapter-&gt;ActiveCommands
(braket
id|TargetID
)braket
op_eq
l_int|0
)paren
id|HostAdapter-&gt;LastSequencePoint
(braket
id|TargetID
)braket
op_assign
id|jiffies
suffix:semicolon
r_else
r_if
c_cond
(paren
id|jiffies
op_minus
id|HostAdapter-&gt;LastSequencePoint
(braket
id|TargetID
)braket
OG
l_int|4
op_star
id|HZ
)paren
(brace
id|HostAdapter-&gt;LastSequencePoint
(braket
id|TargetID
)braket
op_assign
id|jiffies
suffix:semicolon
id|QueueTag
op_assign
id|BusLogic_OrderedQueueTag
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HostAdapter-&gt;ExtendedLUNSupport
)paren
(brace
id|CCB-&gt;TagEnable
op_assign
l_bool|true
suffix:semicolon
id|CCB-&gt;QueueTag
op_assign
id|QueueTag
suffix:semicolon
)brace
r_else
(brace
id|CCB-&gt;LegacyTagEnable
op_assign
l_bool|true
suffix:semicolon
id|CCB-&gt;LegacyQueueTag
op_assign
id|QueueTag
suffix:semicolon
)brace
)brace
id|memcpy
c_func
(paren
id|CCB-&gt;CDB
comma
id|CDB
comma
id|CDB_Length
)paren
suffix:semicolon
id|CCB-&gt;SenseDataLength
op_assign
r_sizeof
(paren
id|Command-&gt;sense_buffer
)paren
suffix:semicolon
id|CCB-&gt;SenseDataPointer
op_assign
id|pci_map_single
c_func
(paren
id|HostAdapter-&gt;PCI_Device
comma
id|Command-&gt;sense_buffer
comma
id|CCB-&gt;SenseDataLength
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|CCB-&gt;Command
op_assign
id|Command
suffix:semicolon
id|Command-&gt;scsi_done
op_assign
id|CompletionRoutine
suffix:semicolon
r_if
c_cond
(paren
id|BusLogic_MultiMasterHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;   Place the CCB in an Outgoing Mailbox.  The higher levels of the SCSI&n;&t;&t;   Subsystem should not attempt to queue more commands than can be placed&n;&t;&t;   in Outgoing Mailboxes, so there should always be one free.  In the&n;&t;&t;   unlikely event that there are none available, wait 1 second and try&n;&t;&t;   again.  If that fails, the Host Adapter is probably hung so signal an&n;&t;&t;   error as a Host Adapter Hard Reset should be initiated soon.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|BusLogic_WriteOutgoingMailbox
c_func
(paren
id|HostAdapter
comma
id|BusLogic_MailboxStartCommand
comma
id|CCB
)paren
)paren
(brace
id|spin_unlock_irq
c_func
(paren
id|HostAdapter-&gt;SCSI_Host-&gt;host_lock
)paren
suffix:semicolon
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unable to write Outgoing Mailbox - &quot;
l_string|&quot;Pausing for 1 second&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_Delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|HostAdapter-&gt;SCSI_Host-&gt;host_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|BusLogic_WriteOutgoingMailbox
c_func
(paren
id|HostAdapter
comma
id|BusLogic_MailboxStartCommand
comma
id|CCB
)paren
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Still unable to write Outgoing Mailbox - &quot;
l_string|&quot;Host Adapter Dead?&bslash;n&quot;
comma
id|HostAdapter
)paren
suffix:semicolon
id|BusLogic_DeallocateCCB
c_func
(paren
id|CCB
)paren
suffix:semicolon
id|Command-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|Command
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|Command
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;   Call the FlashPoint SCCB Manager to start execution of the CCB.&n;&t;&t; */
id|CCB-&gt;Status
op_assign
id|BusLogic_CCB_Active
suffix:semicolon
id|HostAdapter-&gt;ActiveCommands
(braket
id|TargetID
)braket
op_increment
suffix:semicolon
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|CommandsAttempted
op_increment
suffix:semicolon
id|FlashPoint_StartCCB
c_func
(paren
id|HostAdapter-&gt;CardHandle
comma
id|CCB
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;   The Command may have already completed and BusLogic_QueueCompletedCCB&n;&t;&t;   been called, or it may still be pending.&n;&t;&t; */
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Completed
)paren
id|BusLogic_ProcessCompletedCCBs
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_AbortCommand aborts Command if possible.&n;*/
DECL|function|BusLogic_AbortCommand
r_static
r_int
id|BusLogic_AbortCommand
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|Command
)paren
(brace
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
op_assign
(paren
r_struct
id|BusLogic_HostAdapter
op_star
)paren
id|Command-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
r_int
id|TargetID
op_assign
id|Command-&gt;device-&gt;id
suffix:semicolon
r_struct
id|BusLogic_CCB
op_star
id|CCB
suffix:semicolon
id|BusLogic_IncrementErrorCounter
c_func
(paren
op_amp
id|HostAdapter-&gt;TargetStatistics
(braket
id|TargetID
)braket
dot
id|CommandAbortsRequested
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   If this Command has already completed, then no Abort is necessary.&n;&t; */
r_if
c_cond
(paren
id|Command-&gt;serial_number
op_ne
id|Command-&gt;serial_number_at_timeout
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unable to Abort Command to Target %d - &quot;
l_string|&quot;Already Completed&bslash;n&quot;
comma
id|HostAdapter
comma
id|TargetID
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   Attempt to find an Active CCB for this Command.  If no Active CCB for this&n;&t;   Command is found, then no Abort is necessary.&n;&t; */
r_for
c_loop
(paren
id|CCB
op_assign
id|HostAdapter-&gt;All_CCBs
suffix:semicolon
id|CCB
op_ne
l_int|NULL
suffix:semicolon
id|CCB
op_assign
id|CCB-&gt;NextAll
)paren
r_if
c_cond
(paren
id|CCB-&gt;Command
op_eq
id|Command
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|CCB
op_eq
l_int|NULL
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unable to Abort Command to Target %d - &quot;
l_string|&quot;No CCB Found&bslash;n&quot;
comma
id|HostAdapter
comma
id|TargetID
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Completed
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unable to Abort Command to Target %d - &quot;
l_string|&quot;CCB Completed&bslash;n&quot;
comma
id|HostAdapter
comma
id|TargetID
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Reset
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unable to Abort Command to Target %d - &quot;
l_string|&quot;CCB Reset&bslash;n&quot;
comma
id|HostAdapter
comma
id|TargetID
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BusLogic_MultiMasterHostAdapterP
c_func
(paren
id|HostAdapter
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;   Attempt to Abort this CCB.  MultiMaster Firmware versions prior to 5.xx&n;&t;&t;   do not generate Abort Tag messages, but only generate the non-tagged&n;&t;&t;   Abort message.  Since non-tagged commands are not sent by the Host&n;&t;&t;   Adapter until the queue of outstanding tagged commands has completed,&n;&t;&t;   and the Abort message is treated as a non-tagged command, it is&n;&t;&t;   effectively impossible to abort commands when Tagged Queuing is active.&n;&t;&t;   Firmware version 5.xx does generate Abort Tag messages, so it is&n;&t;&t;   possible to abort commands when Tagged Queuing is active.&n;&t;&t; */
r_if
c_cond
(paren
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
dot
id|TaggedQueuingActive
op_logical_and
id|HostAdapter-&gt;FirmwareVersion
(braket
l_int|0
)braket
OL
l_char|&squot;5&squot;
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unable to Abort CCB #%ld to Target %d - &quot;
l_string|&quot;Abort Tag Not Supported&bslash;n&quot;
comma
id|HostAdapter
comma
id|CCB-&gt;SerialNumber
comma
id|TargetID
)paren
suffix:semicolon
r_return
id|FAILURE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|BusLogic_WriteOutgoingMailbox
c_func
(paren
id|HostAdapter
comma
id|BusLogic_MailboxAbortCommand
comma
id|CCB
)paren
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Aborting CCB #%ld to Target %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|CCB-&gt;SerialNumber
comma
id|TargetID
)paren
suffix:semicolon
id|BusLogic_IncrementErrorCounter
c_func
(paren
op_amp
id|HostAdapter-&gt;TargetStatistics
(braket
id|TargetID
)braket
dot
id|CommandAbortsAttempted
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
r_else
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Unable to Abort CCB #%ld to Target %d - &quot;
l_string|&quot;No Outgoing Mailboxes&bslash;n&quot;
comma
id|HostAdapter
comma
id|CCB-&gt;SerialNumber
comma
id|TargetID
)paren
suffix:semicolon
r_return
id|FAILURE
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;   Call the FlashPoint SCCB Manager to abort execution of the CCB.&n;&t;&t; */
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Aborting CCB #%ld to Target %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|CCB-&gt;SerialNumber
comma
id|TargetID
)paren
suffix:semicolon
id|BusLogic_IncrementErrorCounter
c_func
(paren
op_amp
id|HostAdapter-&gt;TargetStatistics
(braket
id|TargetID
)braket
dot
id|CommandAbortsAttempted
)paren
suffix:semicolon
id|FlashPoint_AbortCCB
c_func
(paren
id|HostAdapter-&gt;CardHandle
comma
id|CCB
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;   The Abort may have already been completed and&n;&t;&t;   BusLogic_QueueCompletedCCB been called, or it&n;&t;&t;   may still be pending.&n;&t;&t; */
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Completed
)paren
(brace
id|BusLogic_ProcessCompletedCCBs
c_func
(paren
id|HostAdapter
)paren
suffix:semicolon
)brace
r_return
id|SUCCESS
suffix:semicolon
)brace
r_return
id|SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ResetHostAdapter resets Host Adapter if possible, marking all&n;  currently executing SCSI Commands as having been Reset.&n;*/
DECL|function|BusLogic_ResetHostAdapter
r_static
r_int
id|BusLogic_ResetHostAdapter
c_func
(paren
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
comma
id|boolean
id|HardReset
)paren
(brace
r_struct
id|BusLogic_CCB
op_star
id|CCB
suffix:semicolon
r_int
id|TargetID
suffix:semicolon
multiline_comment|/*&n;&t; * Attempt to Reset and Reinitialize the Host Adapter.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|BusLogic_HardwareResetHostAdapter
c_func
(paren
id|HostAdapter
comma
id|HardReset
)paren
op_logical_and
id|BusLogic_InitializeHostAdapter
c_func
(paren
id|HostAdapter
)paren
)paren
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;Resetting %s Failed&bslash;n&quot;
comma
id|HostAdapter
comma
id|HostAdapter-&gt;FullModelName
)paren
suffix:semicolon
r_return
id|FAILURE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Deallocate all currently executing CCBs.&n;&t; */
r_for
c_loop
(paren
id|CCB
op_assign
id|HostAdapter-&gt;All_CCBs
suffix:semicolon
id|CCB
op_ne
l_int|NULL
suffix:semicolon
id|CCB
op_assign
id|CCB-&gt;NextAll
)paren
r_if
c_cond
(paren
id|CCB-&gt;Status
op_eq
id|BusLogic_CCB_Active
)paren
id|BusLogic_DeallocateCCB
c_func
(paren
id|CCB
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wait a few seconds between the Host Adapter Hard Reset which&n;&t; * initiates a SCSI Bus Reset and issuing any SCSI Commands.  Some&n;&t; * SCSI devices get confused if they receive SCSI Commands too soon&n;&t; * after a SCSI Bus Reset.&n;&t; */
r_if
c_cond
(paren
id|HardReset
)paren
(brace
id|spin_unlock_irq
c_func
(paren
id|HostAdapter-&gt;SCSI_Host-&gt;host_lock
)paren
suffix:semicolon
id|BusLogic_Delay
c_func
(paren
id|HostAdapter-&gt;BusSettleTime
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|HostAdapter-&gt;SCSI_Host-&gt;host_lock
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
(brace
id|HostAdapter-&gt;LastResetAttempted
(braket
id|TargetID
)braket
op_assign
id|jiffies
suffix:semicolon
id|HostAdapter-&gt;LastResetCompleted
(braket
id|TargetID
)braket
op_assign
id|jiffies
suffix:semicolon
)brace
r_return
id|SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_BIOSDiskParameters returns the Heads/Sectors/Cylinders BIOS Disk&n;  Parameters for Disk.  The default disk geometry is 64 heads, 32 sectors, and&n;  the appropriate number of cylinders so as not to exceed drive capacity.  In&n;  order for disks equal to or larger than 1 GB to be addressable by the BIOS&n;  without exceeding the BIOS limitation of 1024 cylinders, Extended Translation&n;  may be enabled in AutoSCSI on FlashPoint Host Adapters and on &quot;W&quot; and &quot;C&quot;&n;  series MultiMaster Host Adapters, or by a dip switch setting on &quot;S&quot; and &quot;A&quot;&n;  series MultiMaster Host Adapters.  With Extended Translation enabled, drives&n;  between 1 GB inclusive and 2 GB exclusive are given a disk geometry of 128&n;  heads and 32 sectors, and drives above 2 GB inclusive are given a disk&n;  geometry of 255 heads and 63 sectors.  However, if the BIOS detects that the&n;  Extended Translation setting does not match the geometry in the partition&n;  table, then the translation inferred from the partition table will be used by&n;  the BIOS, and a warning may be displayed.&n;*/
DECL|function|BusLogic_BIOSDiskParameters
r_static
r_int
id|BusLogic_BIOSDiskParameters
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
comma
r_struct
id|block_device
op_star
id|Device
comma
id|sector_t
id|capacity
comma
r_int
op_star
id|Parameters
)paren
(brace
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
op_assign
(paren
r_struct
id|BusLogic_HostAdapter
op_star
)paren
id|sdev-&gt;host-&gt;hostdata
suffix:semicolon
r_struct
id|BIOS_DiskParameters
op_star
id|DiskParameters
op_assign
(paren
r_struct
id|BIOS_DiskParameters
op_star
)paren
id|Parameters
suffix:semicolon
r_int
r_char
op_star
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|HostAdapter-&gt;ExtendedTranslationEnabled
op_logical_and
id|capacity
op_ge
l_int|2
op_star
l_int|1024
op_star
l_int|1024
multiline_comment|/* 1 GB in 512 byte sectors */
)paren
(brace
r_if
c_cond
(paren
id|capacity
op_ge
l_int|4
op_star
l_int|1024
op_star
l_int|1024
multiline_comment|/* 2 GB in 512 byte sectors */
)paren
(brace
id|DiskParameters-&gt;Heads
op_assign
l_int|255
suffix:semicolon
id|DiskParameters-&gt;Sectors
op_assign
l_int|63
suffix:semicolon
)brace
r_else
(brace
id|DiskParameters-&gt;Heads
op_assign
l_int|128
suffix:semicolon
id|DiskParameters-&gt;Sectors
op_assign
l_int|32
suffix:semicolon
)brace
)brace
r_else
(brace
id|DiskParameters-&gt;Heads
op_assign
l_int|64
suffix:semicolon
id|DiskParameters-&gt;Sectors
op_assign
l_int|32
suffix:semicolon
)brace
id|DiskParameters-&gt;Cylinders
op_assign
(paren
r_int
r_int
)paren
id|capacity
op_div
(paren
id|DiskParameters-&gt;Heads
op_star
id|DiskParameters-&gt;Sectors
)paren
suffix:semicolon
id|buf
op_assign
id|scsi_bios_ptable
c_func
(paren
id|Device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;   If the boot sector partition table flag is valid, search for a partition&n;&t;   table entry whose end_head matches one of the standard BusLogic geometry&n;&t;   translations (64/32, 128/32, or 255/63).&n;&t; */
r_if
c_cond
(paren
op_star
(paren
r_int
r_int
op_star
)paren
(paren
id|buf
op_plus
l_int|64
)paren
op_eq
l_int|0xAA55
)paren
(brace
r_struct
id|partition
op_star
id|FirstPartitionEntry
op_assign
(paren
r_struct
id|partition
op_star
)paren
id|buf
suffix:semicolon
r_struct
id|partition
op_star
id|PartitionEntry
op_assign
id|FirstPartitionEntry
suffix:semicolon
r_int
id|SavedCylinders
op_assign
id|DiskParameters-&gt;Cylinders
comma
id|PartitionNumber
suffix:semicolon
r_int
r_char
id|PartitionEntryEndHead
op_assign
l_int|0
comma
id|PartitionEntryEndSector
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|PartitionNumber
op_assign
l_int|0
suffix:semicolon
id|PartitionNumber
OL
l_int|4
suffix:semicolon
id|PartitionNumber
op_increment
)paren
(brace
id|PartitionEntryEndHead
op_assign
id|PartitionEntry-&gt;end_head
suffix:semicolon
id|PartitionEntryEndSector
op_assign
id|PartitionEntry-&gt;end_sector
op_amp
l_int|0x3F
suffix:semicolon
r_if
c_cond
(paren
id|PartitionEntryEndHead
op_eq
l_int|64
op_minus
l_int|1
)paren
(brace
id|DiskParameters-&gt;Heads
op_assign
l_int|64
suffix:semicolon
id|DiskParameters-&gt;Sectors
op_assign
l_int|32
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|PartitionEntryEndHead
op_eq
l_int|128
op_minus
l_int|1
)paren
(brace
id|DiskParameters-&gt;Heads
op_assign
l_int|128
suffix:semicolon
id|DiskParameters-&gt;Sectors
op_assign
l_int|32
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|PartitionEntryEndHead
op_eq
l_int|255
op_minus
l_int|1
)paren
(brace
id|DiskParameters-&gt;Heads
op_assign
l_int|255
suffix:semicolon
id|DiskParameters-&gt;Sectors
op_assign
l_int|63
suffix:semicolon
r_break
suffix:semicolon
)brace
id|PartitionEntry
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PartitionNumber
op_eq
l_int|4
)paren
(brace
id|PartitionEntryEndHead
op_assign
id|FirstPartitionEntry-&gt;end_head
suffix:semicolon
id|PartitionEntryEndSector
op_assign
id|FirstPartitionEntry-&gt;end_sector
op_amp
l_int|0x3F
suffix:semicolon
)brace
id|DiskParameters-&gt;Cylinders
op_assign
(paren
r_int
r_int
)paren
id|capacity
op_div
(paren
id|DiskParameters-&gt;Heads
op_star
id|DiskParameters-&gt;Sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PartitionNumber
OL
l_int|4
op_logical_and
id|PartitionEntryEndSector
op_eq
id|DiskParameters-&gt;Sectors
)paren
(brace
r_if
c_cond
(paren
id|DiskParameters-&gt;Cylinders
op_ne
id|SavedCylinders
)paren
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Adopting Geometry %d/%d from Partition Table&bslash;n&quot;
comma
id|HostAdapter
comma
id|DiskParameters-&gt;Heads
comma
id|DiskParameters-&gt;Sectors
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|PartitionEntryEndHead
OG
l_int|0
op_logical_or
id|PartitionEntryEndSector
OG
l_int|0
)paren
(brace
id|BusLogic_Warning
c_func
(paren
l_string|&quot;Warning: Partition Table appears to &quot;
l_string|&quot;have Geometry %d/%d which is&bslash;n&quot;
comma
id|HostAdapter
comma
id|PartitionEntryEndHead
op_plus
l_int|1
comma
id|PartitionEntryEndSector
)paren
suffix:semicolon
id|BusLogic_Warning
c_func
(paren
l_string|&quot;not compatible with current BusLogic &quot;
l_string|&quot;Host Adapter Geometry %d/%d&bslash;n&quot;
comma
id|HostAdapter
comma
id|DiskParameters-&gt;Heads
comma
id|DiskParameters-&gt;Sectors
)paren
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;  BugLogic_ProcDirectoryInfo implements /proc/scsi/BusLogic/&lt;N&gt;.&n;*/
DECL|function|BusLogic_ProcDirectoryInfo
r_static
r_int
id|BusLogic_ProcDirectoryInfo
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
r_char
op_star
id|ProcBuffer
comma
r_char
op_star
op_star
id|StartPointer
comma
id|off_t
id|Offset
comma
r_int
id|BytesAvailable
comma
r_int
id|WriteFlag
)paren
(brace
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
op_assign
(paren
r_struct
id|BusLogic_HostAdapter
op_star
)paren
id|shost-&gt;hostdata
suffix:semicolon
r_struct
id|BusLogic_TargetStatistics
op_star
id|TargetStatistics
suffix:semicolon
r_int
id|TargetID
comma
id|Length
suffix:semicolon
r_char
op_star
id|Buffer
suffix:semicolon
id|TargetStatistics
op_assign
id|HostAdapter-&gt;TargetStatistics
suffix:semicolon
r_if
c_cond
(paren
id|WriteFlag
)paren
(brace
id|HostAdapter-&gt;ExternalHostAdapterResets
op_assign
l_int|0
suffix:semicolon
id|HostAdapter-&gt;HostAdapterInternalErrors
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|TargetStatistics
comma
l_int|0
comma
id|BusLogic_MaxTargetDevices
op_star
r_sizeof
(paren
r_struct
id|BusLogic_TargetStatistics
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|Buffer
op_assign
id|HostAdapter-&gt;MessageBuffer
suffix:semicolon
id|Length
op_assign
id|HostAdapter-&gt;MessageBufferLength
suffix:semicolon
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;&bslash;n&bslash;&n;Current Driver Queue Depth:&t;%d&bslash;n&bslash;&n;Currently Allocated CCBs:&t;%d&bslash;n&quot;
comma
id|HostAdapter-&gt;DriverQueueDepth
comma
id|HostAdapter-&gt;AllocatedCCBs
)paren
suffix:semicolon
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;&bslash;n&bslash;n&bslash;&n;&t;&t;&t;   DATA TRANSFER STATISTICS&bslash;n&bslash;&n;&bslash;n&bslash;&n;Target&t;Tagged Queuing&t;Queue Depth  Active  Attempted&t;Completed&bslash;n&bslash;&n;======&t;==============&t;===========  ======  =========&t;=========&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
(brace
r_struct
id|BusLogic_TargetFlags
op_star
id|TargetFlags
op_assign
op_amp
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TargetFlags-&gt;TargetExists
)paren
r_continue
suffix:semicolon
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;  %2d&t;%s&quot;
comma
id|TargetID
comma
(paren
id|TargetFlags-&gt;TaggedQueuingSupported
ques
c_cond
(paren
id|TargetFlags-&gt;TaggedQueuingActive
ques
c_cond
l_string|&quot;    Active&quot;
suffix:colon
(paren
id|HostAdapter-&gt;TaggedQueuingPermitted
op_amp
(paren
l_int|1
op_lshift
id|TargetID
)paren
ques
c_cond
l_string|&quot;  Permitted&quot;
suffix:colon
l_string|&quot;   Disabled&quot;
)paren
)paren
suffix:colon
l_string|&quot;Not Supported&quot;
)paren
)paren
suffix:semicolon
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;&t;    %3d       %3u    %9u&t;%9u&bslash;n&quot;
comma
id|HostAdapter-&gt;QueueDepth
(braket
id|TargetID
)braket
comma
id|HostAdapter-&gt;ActiveCommands
(braket
id|TargetID
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|CommandsAttempted
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|CommandsCompleted
)paren
suffix:semicolon
)brace
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;&bslash;n&bslash;&n;Target  Read Commands  Write Commands   Total Bytes Read    Total Bytes Written&bslash;n&bslash;&n;======  =============  ==============  ===================  ===================&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
(brace
r_struct
id|BusLogic_TargetFlags
op_star
id|TargetFlags
op_assign
op_amp
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TargetFlags-&gt;TargetExists
)paren
r_continue
suffix:semicolon
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;  %2d&t;  %9u&t; %9u&quot;
comma
id|TargetID
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommands
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommands
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|TotalBytesRead.Billions
OG
l_int|0
)paren
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;     %9u%09u&quot;
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|TotalBytesRead.Billions
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|TotalBytesRead.Units
)paren
suffix:semicolon
r_else
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;&t;&t;%9u&quot;
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|TotalBytesRead.Units
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|TotalBytesWritten.Billions
OG
l_int|0
)paren
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;   %9u%09u&bslash;n&quot;
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|TotalBytesWritten.Billions
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|TotalBytesWritten.Units
)paren
suffix:semicolon
r_else
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;&t;     %9u&bslash;n&quot;
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|TotalBytesWritten.Units
)paren
suffix:semicolon
)brace
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;&bslash;n&bslash;&n;Target  Command    0-1KB      1-2KB      2-4KB      4-8KB     8-16KB&bslash;n&bslash;&n;======  =======  =========  =========  =========  =========  =========&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
(brace
r_struct
id|BusLogic_TargetFlags
op_star
id|TargetFlags
op_assign
op_amp
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TargetFlags-&gt;TargetExists
)paren
r_continue
suffix:semicolon
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;  %2d&t; Read&t; %9u  %9u  %9u  %9u  %9u&bslash;n&quot;
comma
id|TargetID
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommandSizeBuckets
(braket
l_int|0
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommandSizeBuckets
(braket
l_int|1
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommandSizeBuckets
(braket
l_int|2
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommandSizeBuckets
(braket
l_int|3
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommandSizeBuckets
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;  %2d&t; Write&t; %9u  %9u  %9u  %9u  %9u&bslash;n&quot;
comma
id|TargetID
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommandSizeBuckets
(braket
l_int|0
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommandSizeBuckets
(braket
l_int|1
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommandSizeBuckets
(braket
l_int|2
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommandSizeBuckets
(braket
l_int|3
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommandSizeBuckets
(braket
l_int|4
)braket
)paren
suffix:semicolon
)brace
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;&bslash;n&bslash;&n;Target  Command   16-32KB    32-64KB   64-128KB   128-256KB   256KB+&bslash;n&bslash;&n;======  =======  =========  =========  =========  =========  =========&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
(brace
r_struct
id|BusLogic_TargetFlags
op_star
id|TargetFlags
op_assign
op_amp
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TargetFlags-&gt;TargetExists
)paren
r_continue
suffix:semicolon
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;  %2d&t; Read&t; %9u  %9u  %9u  %9u  %9u&bslash;n&quot;
comma
id|TargetID
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommandSizeBuckets
(braket
l_int|5
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommandSizeBuckets
(braket
l_int|6
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommandSizeBuckets
(braket
l_int|7
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommandSizeBuckets
(braket
l_int|8
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|ReadCommandSizeBuckets
(braket
l_int|9
)braket
)paren
suffix:semicolon
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;  %2d&t; Write&t; %9u  %9u  %9u  %9u  %9u&bslash;n&quot;
comma
id|TargetID
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommandSizeBuckets
(braket
l_int|5
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommandSizeBuckets
(braket
l_int|6
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommandSizeBuckets
(braket
l_int|7
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommandSizeBuckets
(braket
l_int|8
)braket
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|WriteCommandSizeBuckets
(braket
l_int|9
)braket
)paren
suffix:semicolon
)brace
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;&bslash;n&bslash;n&bslash;&n;&t;&t;&t;   ERROR RECOVERY STATISTICS&bslash;n&bslash;&n;&bslash;n&bslash;&n;&t;  Command Aborts      Bus Device Resets&t;  Host Adapter Resets&bslash;n&bslash;&n;Target&t;Requested Completed  Requested Completed  Requested Completed&bslash;n&bslash;&n;  ID&t;&bslash;&bslash;&bslash;&bslash;&bslash;&bslash;&bslash;&bslash; Attempted ////  &bslash;&bslash;&bslash;&bslash;&bslash;&bslash;&bslash;&bslash; Attempted ////  &bslash;&bslash;&bslash;&bslash;&bslash;&bslash;&bslash;&bslash; Attempted ////&bslash;n&bslash;&n;======&t; ===== ===== =====    ===== ===== =====&t;   ===== ===== =====&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|HostAdapter-&gt;MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
(brace
r_struct
id|BusLogic_TargetFlags
op_star
id|TargetFlags
op_assign
op_amp
id|HostAdapter-&gt;TargetFlags
(braket
id|TargetID
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TargetFlags-&gt;TargetExists
)paren
r_continue
suffix:semicolon
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;&bslash;&n;  %2d&t; %5d %5d %5d    %5d %5d %5d&t;   %5d %5d %5d&bslash;n&quot;
comma
id|TargetID
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|CommandAbortsRequested
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|CommandAbortsAttempted
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|CommandAbortsCompleted
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|BusDeviceResetsRequested
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|BusDeviceResetsAttempted
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|BusDeviceResetsCompleted
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|HostAdapterResetsRequested
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|HostAdapterResetsAttempted
comma
id|TargetStatistics
(braket
id|TargetID
)braket
dot
id|HostAdapterResetsCompleted
)paren
suffix:semicolon
)brace
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;&bslash;nExternal Host Adapter Resets: %d&bslash;n&quot;
comma
id|HostAdapter-&gt;ExternalHostAdapterResets
)paren
suffix:semicolon
id|Length
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|Buffer
(braket
id|Length
)braket
comma
l_string|&quot;Host Adapter Internal Errors: %d&bslash;n&quot;
comma
id|HostAdapter-&gt;HostAdapterInternalErrors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Length
op_ge
id|BusLogic_MessageBufferSize
)paren
id|BusLogic_Error
c_func
(paren
l_string|&quot;Message Buffer length %d exceeds size %d&bslash;n&quot;
comma
id|HostAdapter
comma
id|Length
comma
id|BusLogic_MessageBufferSize
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|Length
op_sub_assign
id|Offset
)paren
op_le
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|Length
op_ge
id|BytesAvailable
)paren
id|Length
op_assign
id|BytesAvailable
suffix:semicolon
id|memcpy
c_func
(paren
id|ProcBuffer
comma
id|HostAdapter-&gt;MessageBuffer
op_plus
id|Offset
comma
id|Length
)paren
suffix:semicolon
op_star
id|StartPointer
op_assign
id|ProcBuffer
suffix:semicolon
r_return
id|Length
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_Message prints Driver Messages.&n;*/
DECL|function|BusLogic_Message
r_static
r_void
id|BusLogic_Message
c_func
(paren
r_enum
id|BusLogic_MessageLevel
id|MessageLevel
comma
r_char
op_star
id|Format
comma
r_struct
id|BusLogic_HostAdapter
op_star
id|HostAdapter
comma
dot
dot
dot
)paren
(brace
r_static
r_char
id|Buffer
(braket
id|BusLogic_LineBufferSize
)braket
suffix:semicolon
r_static
id|boolean
id|BeginningOfLine
op_assign
l_bool|true
suffix:semicolon
id|va_list
id|Arguments
suffix:semicolon
r_int
id|Length
op_assign
l_int|0
suffix:semicolon
id|va_start
c_func
(paren
id|Arguments
comma
id|HostAdapter
)paren
suffix:semicolon
id|Length
op_assign
id|vsprintf
c_func
(paren
id|Buffer
comma
id|Format
comma
id|Arguments
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|Arguments
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MessageLevel
op_eq
id|BusLogic_AnnounceLevel
)paren
(brace
r_static
r_int
id|AnnouncementLines
op_assign
l_int|0
suffix:semicolon
id|strcpy
c_func
(paren
op_amp
id|HostAdapter-&gt;MessageBuffer
(braket
id|HostAdapter-&gt;MessageBufferLength
)braket
comma
id|Buffer
)paren
suffix:semicolon
id|HostAdapter-&gt;MessageBufferLength
op_add_assign
id|Length
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|AnnouncementLines
op_le
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot;%sscsi: %s&quot;
comma
id|BusLogic_MessageLevelMap
(braket
id|MessageLevel
)braket
comma
id|Buffer
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|MessageLevel
op_eq
id|BusLogic_InfoLevel
)paren
(brace
id|strcpy
c_func
(paren
op_amp
id|HostAdapter-&gt;MessageBuffer
(braket
id|HostAdapter-&gt;MessageBufferLength
)braket
comma
id|Buffer
)paren
suffix:semicolon
id|HostAdapter-&gt;MessageBufferLength
op_add_assign
id|Length
suffix:semicolon
r_if
c_cond
(paren
id|BeginningOfLine
)paren
(brace
r_if
c_cond
(paren
id|Buffer
(braket
l_int|0
)braket
op_ne
l_char|&squot;&bslash;n&squot;
op_logical_or
id|Length
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%sscsi%d: %s&quot;
comma
id|BusLogic_MessageLevelMap
(braket
id|MessageLevel
)braket
comma
id|HostAdapter-&gt;HostNumber
comma
id|Buffer
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|Buffer
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|BeginningOfLine
)paren
(brace
r_if
c_cond
(paren
id|HostAdapter
op_ne
l_int|NULL
op_logical_and
id|HostAdapter-&gt;HostAdapterInitialized
)paren
id|printk
c_func
(paren
l_string|&quot;%sscsi%d: %s&quot;
comma
id|BusLogic_MessageLevelMap
(braket
id|MessageLevel
)braket
comma
id|HostAdapter-&gt;HostNumber
comma
id|Buffer
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;%s%s&quot;
comma
id|BusLogic_MessageLevelMap
(braket
id|MessageLevel
)braket
comma
id|Buffer
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|Buffer
)paren
suffix:semicolon
)brace
id|BeginningOfLine
op_assign
(paren
id|Buffer
(braket
id|Length
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ParseKeyword parses an individual option keyword.  It returns true&n;  and updates the pointer if the keyword is recognized and false otherwise.&n;*/
DECL|function|BusLogic_ParseKeyword
r_static
id|boolean
id|__init
id|BusLogic_ParseKeyword
c_func
(paren
r_char
op_star
op_star
id|StringPointer
comma
r_char
op_star
id|Keyword
)paren
(brace
r_char
op_star
id|Pointer
op_assign
op_star
id|StringPointer
suffix:semicolon
r_while
c_loop
(paren
op_star
id|Keyword
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
r_char
id|StringChar
op_assign
op_star
id|Pointer
op_increment
suffix:semicolon
r_char
id|KeywordChar
op_assign
op_star
id|Keyword
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|StringChar
op_ge
l_char|&squot;A&squot;
op_logical_and
id|StringChar
op_le
l_char|&squot;Z&squot;
)paren
id|StringChar
op_add_assign
l_char|&squot;a&squot;
op_minus
l_char|&squot;Z&squot;
suffix:semicolon
r_if
c_cond
(paren
id|KeywordChar
op_ge
l_char|&squot;A&squot;
op_logical_and
id|KeywordChar
op_le
l_char|&squot;Z&squot;
)paren
id|KeywordChar
op_add_assign
l_char|&squot;a&squot;
op_minus
l_char|&squot;Z&squot;
suffix:semicolon
r_if
c_cond
(paren
id|StringChar
op_ne
id|KeywordChar
)paren
r_return
l_bool|false
suffix:semicolon
)brace
op_star
id|StringPointer
op_assign
id|Pointer
suffix:semicolon
r_return
l_bool|true
suffix:semicolon
)brace
multiline_comment|/*&n;  BusLogic_ParseDriverOptions handles processing of BusLogic Driver Options&n;  specifications.&n;&n;  BusLogic Driver Options may be specified either via the Linux Kernel Command&n;  Line or via the Loadable Kernel Module Installation Facility.  Driver Options&n;  for multiple host adapters may be specified either by separating the option&n;  strings by a semicolon, or by specifying multiple &quot;BusLogic=&quot; strings on the&n;  command line.  Individual option specifications for a single host adapter are&n;  separated by commas.  The Probing and Debugging Options apply to all host&n;  adapters whereas the remaining options apply individually only to the&n;  selected host adapter.&n;&n;  The BusLogic Driver Probing Options are described in&n;  &lt;file:Documentation/scsi/BusLogic.txt&gt;.&n;*/
DECL|function|BusLogic_ParseDriverOptions
r_static
r_int
id|__init
id|BusLogic_ParseDriverOptions
c_func
(paren
r_char
op_star
id|OptionsString
)paren
(brace
r_while
c_loop
(paren
l_bool|true
)paren
(brace
r_struct
id|BusLogic_DriverOptions
op_star
id|DriverOptions
op_assign
op_amp
id|BusLogic_DriverOptions
(braket
id|BusLogic_DriverOptionsCount
op_increment
)braket
suffix:semicolon
r_int
id|TargetID
suffix:semicolon
id|memset
c_func
(paren
id|DriverOptions
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|BusLogic_DriverOptions
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|OptionsString
op_ne
l_char|&squot;&bslash;0&squot;
op_logical_and
op_star
id|OptionsString
op_ne
l_char|&squot;;&squot;
)paren
(brace
multiline_comment|/* Probing Options. */
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;IO:&quot;
)paren
)paren
(brace
r_int
r_int
id|IO_Address
op_assign
id|simple_strtoul
c_func
(paren
id|OptionsString
comma
op_amp
id|OptionsString
comma
l_int|0
)paren
suffix:semicolon
id|BusLogic_ProbeOptions.LimitedProbeISA
op_assign
l_bool|true
suffix:semicolon
r_switch
c_cond
(paren
id|IO_Address
)paren
(brace
r_case
l_int|0x330
suffix:colon
id|BusLogic_ProbeOptions.Probe330
op_assign
l_bool|true
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x334
suffix:colon
id|BusLogic_ProbeOptions.Probe334
op_assign
l_bool|true
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x230
suffix:colon
id|BusLogic_ProbeOptions.Probe230
op_assign
l_bool|true
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x234
suffix:colon
id|BusLogic_ProbeOptions.Probe234
op_assign
l_bool|true
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x130
suffix:colon
id|BusLogic_ProbeOptions.Probe130
op_assign
l_bool|true
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x134
suffix:colon
id|BusLogic_ProbeOptions.Probe134
op_assign
l_bool|true
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Invalid Driver Options &quot;
l_string|&quot;(invalid I/O Address 0x%X)&bslash;n&quot;
comma
l_int|NULL
comma
id|IO_Address
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;NoProbeISA&quot;
)paren
)paren
id|BusLogic_ProbeOptions.NoProbeISA
op_assign
l_bool|true
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;NoProbePCI&quot;
)paren
)paren
id|BusLogic_ProbeOptions.NoProbePCI
op_assign
l_bool|true
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;NoProbe&quot;
)paren
)paren
id|BusLogic_ProbeOptions.NoProbe
op_assign
l_bool|true
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;NoSortPCI&quot;
)paren
)paren
id|BusLogic_ProbeOptions.NoSortPCI
op_assign
l_bool|true
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;MultiMasterFirst&quot;
)paren
)paren
id|BusLogic_ProbeOptions.MultiMasterFirst
op_assign
l_bool|true
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;FlashPointFirst&quot;
)paren
)paren
id|BusLogic_ProbeOptions.FlashPointFirst
op_assign
l_bool|true
suffix:semicolon
multiline_comment|/* Tagged Queuing Options. */
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;QueueDepth:[&quot;
)paren
op_logical_or
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;QD:[&quot;
)paren
)paren
(brace
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|BusLogic_MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
(brace
r_int
r_int
id|QueueDepth
op_assign
id|simple_strtoul
c_func
(paren
id|OptionsString
comma
op_amp
id|OptionsString
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|QueueDepth
OG
id|BusLogic_MaxTaggedQueueDepth
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Invalid Driver Options &quot;
l_string|&quot;(invalid Queue Depth %d)&bslash;n&quot;
comma
l_int|NULL
comma
id|QueueDepth
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DriverOptions-&gt;QueueDepth
(braket
id|TargetID
)braket
op_assign
id|QueueDepth
suffix:semicolon
r_if
c_cond
(paren
op_star
id|OptionsString
op_eq
l_char|&squot;,&squot;
)paren
id|OptionsString
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|OptionsString
op_eq
l_char|&squot;]&squot;
)paren
r_break
suffix:semicolon
r_else
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Invalid Driver Options &quot;
l_string|&quot;(&squot;,&squot; or &squot;]&squot; expected at &squot;%s&squot;)&bslash;n&quot;
comma
l_int|NULL
comma
id|OptionsString
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_star
id|OptionsString
op_ne
l_char|&squot;]&squot;
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Invalid Driver Options &quot;
l_string|&quot;(&squot;]&squot; expected at &squot;%s&squot;)&bslash;n&quot;
comma
l_int|NULL
comma
id|OptionsString
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
id|OptionsString
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;QueueDepth:&quot;
)paren
op_logical_or
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;QD:&quot;
)paren
)paren
(brace
r_int
r_int
id|QueueDepth
op_assign
id|simple_strtoul
c_func
(paren
id|OptionsString
comma
op_amp
id|OptionsString
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|QueueDepth
op_eq
l_int|0
op_logical_or
id|QueueDepth
OG
id|BusLogic_MaxTaggedQueueDepth
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Invalid Driver Options &quot;
l_string|&quot;(invalid Queue Depth %d)&bslash;n&quot;
comma
l_int|NULL
comma
id|QueueDepth
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DriverOptions-&gt;CommonQueueDepth
op_assign
id|QueueDepth
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|BusLogic_MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
id|DriverOptions-&gt;QueueDepth
(braket
id|TargetID
)braket
op_assign
id|QueueDepth
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;TaggedQueuing:&quot;
)paren
op_logical_or
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;TQ:&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;Default&quot;
)paren
)paren
(brace
id|DriverOptions-&gt;TaggedQueuingPermitted
op_assign
l_int|0x0000
suffix:semicolon
id|DriverOptions-&gt;TaggedQueuingPermittedMask
op_assign
l_int|0x0000
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;Enable&quot;
)paren
)paren
(brace
id|DriverOptions-&gt;TaggedQueuingPermitted
op_assign
l_int|0xFFFF
suffix:semicolon
id|DriverOptions-&gt;TaggedQueuingPermittedMask
op_assign
l_int|0xFFFF
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;Disable&quot;
)paren
)paren
(brace
id|DriverOptions-&gt;TaggedQueuingPermitted
op_assign
l_int|0x0000
suffix:semicolon
id|DriverOptions-&gt;TaggedQueuingPermittedMask
op_assign
l_int|0xFFFF
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|TargetBit
suffix:semicolon
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
comma
id|TargetBit
op_assign
l_int|1
suffix:semicolon
id|TargetID
OL
id|BusLogic_MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
comma
id|TargetBit
op_lshift_assign
l_int|1
)paren
r_switch
c_cond
(paren
op_star
id|OptionsString
op_increment
)paren
(brace
r_case
l_char|&squot;Y&squot;
suffix:colon
id|DriverOptions-&gt;TaggedQueuingPermitted
op_or_assign
id|TargetBit
suffix:semicolon
id|DriverOptions-&gt;TaggedQueuingPermittedMask
op_or_assign
id|TargetBit
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;N&squot;
suffix:colon
id|DriverOptions-&gt;TaggedQueuingPermitted
op_and_assign
op_complement
id|TargetBit
suffix:semicolon
id|DriverOptions-&gt;TaggedQueuingPermittedMask
op_or_assign
id|TargetBit
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;X&squot;
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|OptionsString
op_decrement
suffix:semicolon
id|TargetID
op_assign
id|BusLogic_MaxTargetDevices
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Miscellaneous Options. */
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;BusSettleTime:&quot;
)paren
op_logical_or
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;BST:&quot;
)paren
)paren
(brace
r_int
r_int
id|BusSettleTime
op_assign
id|simple_strtoul
c_func
(paren
id|OptionsString
comma
op_amp
id|OptionsString
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BusSettleTime
OG
l_int|5
op_star
l_int|60
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Invalid Driver Options &quot;
l_string|&quot;(invalid Bus Settle Time %d)&bslash;n&quot;
comma
l_int|NULL
comma
id|BusSettleTime
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DriverOptions-&gt;BusSettleTime
op_assign
id|BusSettleTime
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;InhibitTargetInquiry&quot;
)paren
)paren
id|DriverOptions-&gt;LocalOptions.InhibitTargetInquiry
op_assign
l_bool|true
suffix:semicolon
multiline_comment|/* Debugging Options. */
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;TraceProbe&quot;
)paren
)paren
id|BusLogic_GlobalOptions.TraceProbe
op_assign
l_bool|true
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;TraceHardwareReset&quot;
)paren
)paren
id|BusLogic_GlobalOptions.TraceHardwareReset
op_assign
l_bool|true
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;TraceConfiguration&quot;
)paren
)paren
id|BusLogic_GlobalOptions.TraceConfiguration
op_assign
l_bool|true
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;TraceErrors&quot;
)paren
)paren
id|BusLogic_GlobalOptions.TraceErrors
op_assign
l_bool|true
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BusLogic_ParseKeyword
c_func
(paren
op_amp
id|OptionsString
comma
l_string|&quot;Debug&quot;
)paren
)paren
(brace
id|BusLogic_GlobalOptions.TraceProbe
op_assign
l_bool|true
suffix:semicolon
id|BusLogic_GlobalOptions.TraceHardwareReset
op_assign
l_bool|true
suffix:semicolon
id|BusLogic_GlobalOptions.TraceConfiguration
op_assign
l_bool|true
suffix:semicolon
id|BusLogic_GlobalOptions.TraceErrors
op_assign
l_bool|true
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|OptionsString
op_eq
l_char|&squot;,&squot;
)paren
id|OptionsString
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|OptionsString
op_ne
l_char|&squot;;&squot;
op_logical_and
op_star
id|OptionsString
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Unexpected Driver Option &squot;%s&squot; &quot;
l_string|&quot;ignored&bslash;n&quot;
comma
l_int|NULL
comma
id|OptionsString
)paren
suffix:semicolon
op_star
id|OptionsString
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|BusLogic_DriverOptionsCount
op_eq
l_int|0
op_logical_or
id|BusLogic_ProbeInfoCount
op_eq
l_int|0
op_logical_or
id|BusLogic_DriverOptionsCount
op_eq
id|BusLogic_ProbeInfoCount
)paren
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Invalid Driver Options &quot;
l_string|&quot;(all or no I/O Addresses must be specified)&bslash;n&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;   Tagged Queuing is disabled when the Queue Depth is 1 since queuing&n;&t;&t;   multiple commands is not possible.&n;&t;&t; */
r_for
c_loop
(paren
id|TargetID
op_assign
l_int|0
suffix:semicolon
id|TargetID
OL
id|BusLogic_MaxTargetDevices
suffix:semicolon
id|TargetID
op_increment
)paren
r_if
c_cond
(paren
id|DriverOptions-&gt;QueueDepth
(braket
id|TargetID
)braket
op_eq
l_int|1
)paren
(brace
r_int
r_int
id|TargetBit
op_assign
l_int|1
op_lshift
id|TargetID
suffix:semicolon
id|DriverOptions-&gt;TaggedQueuingPermitted
op_and_assign
op_complement
id|TargetBit
suffix:semicolon
id|DriverOptions-&gt;TaggedQueuingPermittedMask
op_or_assign
id|TargetBit
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|OptionsString
op_eq
l_char|&squot;;&squot;
)paren
id|OptionsString
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|OptionsString
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;  Get it all started&n;*/
DECL|variable|Bus_Logic_template
r_static
r_struct
id|scsi_host_template
id|Bus_Logic_template
op_assign
(brace
dot
id|module
op_assign
id|THIS_MODULE
comma
dot
id|proc_name
op_assign
l_string|&quot;BusLogic&quot;
comma
dot
id|proc_info
op_assign
id|BusLogic_ProcDirectoryInfo
comma
dot
id|name
op_assign
l_string|&quot;BusLogic&quot;
comma
dot
id|info
op_assign
id|BusLogic_DriverInfo
comma
dot
id|queuecommand
op_assign
id|BusLogic_QueueCommand
comma
dot
id|slave_configure
op_assign
id|BusLogic_SlaveConfigure
comma
dot
id|bios_param
op_assign
id|BusLogic_BIOSDiskParameters
comma
dot
id|eh_host_reset_handler
op_assign
id|BusLogic_host_reset
comma
macro_line|#if 0
dot
id|eh_abort_handler
op_assign
id|BusLogic_AbortCommand
comma
macro_line|#endif
dot
id|unchecked_isa_dma
op_assign
l_int|1
comma
dot
id|max_sectors
op_assign
l_int|128
comma
dot
id|use_clustering
op_assign
id|ENABLE_CLUSTERING
comma
)brace
suffix:semicolon
multiline_comment|/*&n;  BusLogic_Setup handles processing of Kernel Command Line Arguments.&n;*/
DECL|function|BusLogic_Setup
r_static
r_int
id|__init
id|BusLogic_Setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|ints
(braket
l_int|3
)braket
suffix:semicolon
(paren
r_void
)paren
id|get_options
c_func
(paren
id|str
comma
id|ARRAY_SIZE
c_func
(paren
id|ints
)paren
comma
id|ints
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
(brace
id|BusLogic_Error
c_func
(paren
l_string|&quot;BusLogic: Obsolete Command Line Entry &quot;
l_string|&quot;Format Ignored&bslash;n&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|str
op_eq
l_int|NULL
op_logical_or
op_star
id|str
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|BusLogic_ParseDriverOptions
c_func
(paren
id|str
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Exit function.  Deletes all hosts associated with this driver.&n; */
DECL|function|BusLogic_exit
r_static
r_void
id|__exit
id|BusLogic_exit
c_func
(paren
r_void
)paren
(brace
r_struct
id|BusLogic_HostAdapter
op_star
id|ha
comma
op_star
id|next
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|ha
comma
id|next
comma
op_amp
id|BusLogic_host_list
comma
id|host_list
)paren
id|BusLogic_ReleaseHostAdapter
c_func
(paren
id|ha
)paren
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;BusLogic=&quot;
comma
id|BusLogic_Setup
)paren
suffix:semicolon
DECL|variable|BusLogic_init
id|module_init
c_func
(paren
id|BusLogic_init
)paren
suffix:semicolon
DECL|variable|BusLogic_exit
id|module_exit
c_func
(paren
id|BusLogic_exit
)paren
suffix:semicolon
eof
