multiline_comment|/*==========================================================================&n;  NinjaSCSI-3 message handler&n;      By: YOKOTA Hiroshi &lt;yokota@netlab.is.tsukuba.ac.jp&gt;&n;&n;   This software may be used and distributed according to the terms of&n;   the GNU Public License.&n; */
multiline_comment|/* $Id: nsp_message.c,v 1.6 2001/07/05 10:56:37 elca Exp $ */
DECL|function|nsp_message_in
r_static
r_void
id|nsp_message_in
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
id|nsp_hw_data
op_star
id|data
)paren
(brace
r_int
r_int
id|base
op_assign
id|SCpnt-&gt;host-&gt;io_port
suffix:semicolon
r_int
r_char
id|data_reg
comma
id|control_reg
suffix:semicolon
r_int
id|ret
comma
id|len
suffix:semicolon
multiline_comment|/*&n;&t; * XXX: NSP QUIRK&n;&t; * NSP invoke interrupts only in the case of scsi phase changes,&n;&t; * therefore we should poll the scsi phase here to catch &n;&t; * the next &quot;msg in&quot; if exists (no scsi phase changes).&n;&t; */
id|ret
op_assign
l_int|16
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot; msgin loop&bslash;n&quot;
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* read data */
id|data_reg
op_assign
id|nsp_index_read
c_func
(paren
id|base
comma
id|SCSIDATAIN
)paren
suffix:semicolon
multiline_comment|/* assert ACK */
id|control_reg
op_assign
id|nsp_index_read
c_func
(paren
id|base
comma
id|SCSIBUSCTRL
)paren
suffix:semicolon
id|control_reg
op_or_assign
id|SCSI_ACK
suffix:semicolon
id|nsp_index_write
c_func
(paren
id|base
comma
id|SCSIBUSCTRL
comma
id|control_reg
)paren
suffix:semicolon
id|nsp_negate_signal
c_func
(paren
id|SCpnt
comma
id|BUSMON_REQ
comma
l_string|&quot;msgin&lt;REQ&gt;&quot;
)paren
suffix:semicolon
id|data-&gt;MsgBuffer
(braket
id|len
)braket
op_assign
id|data_reg
suffix:semicolon
id|len
op_increment
suffix:semicolon
multiline_comment|/* deassert ACK */
id|control_reg
op_assign
id|nsp_index_read
c_func
(paren
id|base
comma
id|SCSIBUSCTRL
)paren
suffix:semicolon
id|control_reg
op_and_assign
op_complement
id|SCSI_ACK
suffix:semicolon
id|nsp_index_write
c_func
(paren
id|base
comma
id|SCSIBUSCTRL
comma
id|control_reg
)paren
suffix:semicolon
multiline_comment|/* catch a next signal */
id|ret
op_assign
id|nsp_expect_signal
c_func
(paren
id|SCpnt
comma
id|BUSPHASE_MESSAGE_IN
comma
id|BUSMON_REQ
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ret
OG
l_int|0
op_logical_and
id|MSGBUF_SIZE
OG
id|len
)paren
suffix:semicolon
id|data-&gt;MsgLen
op_assign
id|len
suffix:semicolon
)brace
DECL|function|nsp_message_out
r_static
r_void
id|nsp_message_out
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
id|nsp_hw_data
op_star
id|data
)paren
(brace
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
r_int
id|len
op_assign
id|data-&gt;MsgLen
suffix:semicolon
multiline_comment|/*&n;&t; * XXX: NSP QUIRK&n;&t; * NSP invoke interrupts only in the case of scsi phase changes,&n;&t; * therefore we should poll the scsi phase here to catch &n;&t; * the next &quot;msg out&quot; if exists (no scsi phase changes).&n;&t; */
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot; msgout loop&bslash;n&quot;
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|nsp_xfer
c_func
(paren
id|SCpnt
comma
id|data
comma
id|BUSPHASE_MESSAGE_OUT
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; &quot;
id|__FUNCTION__
l_string|&quot; msgout: xfer short&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* catch a next signal */
id|ret
op_assign
id|nsp_expect_signal
c_func
(paren
id|SCpnt
comma
id|BUSPHASE_MESSAGE_OUT
comma
id|BUSMON_REQ
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ret
OG
l_int|0
op_logical_and
id|len
op_decrement
OG
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* end */
eof
