multiline_comment|/*&n; *&t;Adaptec AAC series RAID controller driver&n; *&t;(c) Copyright 2001 Red Hat Inc.&t;&lt;alan@redhat.com&gt;&n; *&n; * based on the old aacraid driver that is..&n; * Adaptec aacraid device driver for Linux.&n; *&n; * Copyright (c) 2000 Adaptec, Inc. (aacraid@adaptec.com)&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; see the file COPYING.  If not, write to&n; * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; * Module Name:&n; *  commctrl.c&n; *&n; * Abstract: Contains all routines for control of the AFA comm layer&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;aacraid.h&quot;
multiline_comment|/**&n; *&t;ioctl_send_fib&t;-&t;send a FIB from userspace&n; *&t;@dev:&t;adapter is being processed&n; *&t;@arg:&t;arguments to the ioctl call&n; *&t;&n; *&t;This routine sends a fib to the adapter on behalf of a user level&n; *&t;program.&n; */
DECL|function|ioctl_send_fib
r_static
r_int
id|ioctl_send_fib
c_func
(paren
r_struct
id|aac_dev
op_star
id|dev
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|hw_fib
op_star
id|kfib
suffix:semicolon
r_struct
id|fib
op_star
id|fibptr
suffix:semicolon
id|fibptr
op_assign
id|fib_alloc
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fibptr
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|kfib
op_assign
id|fibptr-&gt;hw_fib
suffix:semicolon
multiline_comment|/*&n;&t; *&t;First copy in the header so that we can check the size field.&n;&t; */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
(paren
r_void
op_star
)paren
id|kfib
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|aac_fibhdr
)paren
)paren
)paren
(brace
id|fib_free
c_func
(paren
id|fibptr
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Since we copy based on the fib header size, make sure that we&n;&t; *&t;will not overrun the buffer when we copy the memory. Return&n;&t; *&t;an error if we would.&n;&t; */
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|kfib-&gt;header.Size
)paren
OG
r_sizeof
(paren
r_struct
id|hw_fib
)paren
op_minus
r_sizeof
(paren
r_struct
id|aac_fibhdr
)paren
)paren
(brace
id|fib_free
c_func
(paren
id|fibptr
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
(paren
r_void
op_star
)paren
id|kfib
comma
id|arg
comma
id|le32_to_cpu
c_func
(paren
id|kfib-&gt;header.Size
)paren
op_plus
r_sizeof
(paren
r_struct
id|aac_fibhdr
)paren
)paren
)paren
(brace
id|fib_free
c_func
(paren
id|fibptr
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kfib-&gt;header.Command
op_eq
id|cpu_to_le32
c_func
(paren
id|TakeABreakPt
)paren
)paren
(brace
id|aac_adapter_interrupt
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Since we didn&squot;t really send a fib, zero out the state to allow &n;&t;&t; * cleanup code not to assert.&n;&t;&t; */
id|kfib-&gt;header.XferState
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|fib_send
c_func
(paren
id|kfib-&gt;header.Command
comma
id|fibptr
comma
id|le32_to_cpu
c_func
(paren
id|kfib-&gt;header.Size
)paren
comma
id|FsaNormal
comma
l_int|1
comma
l_int|1
comma
l_int|NULL
comma
l_int|NULL
)paren
op_ne
l_int|0
)paren
(brace
id|fib_free
c_func
(paren
id|fibptr
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fib_complete
c_func
(paren
id|fibptr
)paren
op_ne
l_int|0
)paren
(brace
id|fib_free
c_func
(paren
id|fibptr
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Make sure that the size returned by the adapter (which includes&n;&t; *&t;the header) is less than or equal to the size of a fib, so we&n;&t; *&t;don&squot;t corrupt application data. Then copy that size to the user&n;&t; *&t;buffer. (Don&squot;t try to add the header information again, since it&n;&t; *&t;was already included by the adapter.)&n;&t; */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
(paren
r_void
op_star
)paren
id|kfib
comma
id|kfib-&gt;header.Size
)paren
)paren
(brace
id|fib_free
c_func
(paren
id|fibptr
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|fib_free
c_func
(paren
id|fibptr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;open_getadapter_fib&t;-&t;Get the next fib&n; *&n; *&t;This routine will get the next Fib, if available, from the AdapterFibContext&n; *&t;passed in from the user.&n; */
DECL|function|open_getadapter_fib
r_static
r_int
id|open_getadapter_fib
c_func
(paren
r_struct
id|aac_dev
op_star
id|dev
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|aac_fib_context
op_star
id|fibctx
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|fibctx
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|aac_fib_context
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fibctx
op_eq
l_int|NULL
)paren
(brace
id|status
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
id|fibctx-&gt;type
op_assign
id|FSAFS_NTC_GET_ADAPTER_FIB_CONTEXT
suffix:semicolon
id|fibctx-&gt;size
op_assign
r_sizeof
(paren
r_struct
id|aac_fib_context
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Initialize the mutex used to wait for the next AIF.&n;&t;&t; */
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
id|fibctx-&gt;wait_sem
)paren
suffix:semicolon
id|fibctx-&gt;wait
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Initialize the fibs and set the count of fibs on&n;&t;&t; *&t;the list to 0.&n;&t;&t; */
id|fibctx-&gt;count
op_assign
l_int|0
suffix:semicolon
id|AAC_INIT_LIST_HEAD
c_func
(paren
op_amp
id|fibctx-&gt;hw_fib_list
)paren
suffix:semicolon
id|fibctx-&gt;jiffies
op_assign
id|jiffies
op_div
id|HZ
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Now add this context onto the adapter&squot;s &n;&t;&t; *&t;AdapterFibContext list.&n;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|dev-&gt;fib_lock
comma
id|flags
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|fibctx-&gt;next
comma
op_amp
id|dev-&gt;fib_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dev-&gt;fib_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|fibctx
comma
r_sizeof
(paren
r_struct
id|aac_fib_context
op_star
)paren
)paren
)paren
(brace
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;next_getadapter_fib&t;-&t;get the next fib&n; *&t;@dev: adapter to use&n; *&t;@arg: ioctl argument&n; *&t;&n; * &t;This routine will get the next Fib, if available, from the AdapterFibContext&n; *&t;passed in from the user.&n; */
DECL|function|next_getadapter_fib
r_static
r_int
id|next_getadapter_fib
c_func
(paren
r_struct
id|aac_dev
op_star
id|dev
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|fib_ioctl
id|f
suffix:semicolon
r_struct
id|aac_fib_context
op_star
id|fibctx
comma
op_star
id|aifcp
suffix:semicolon
r_struct
id|hw_fib
op_star
id|hw_fib
suffix:semicolon
r_int
id|status
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
r_int
id|found
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|f
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|fib_ioctl
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Extract the AdapterFibContext from the Input parameters.&n;&t; */
id|fibctx
op_assign
(paren
r_struct
id|aac_fib_context
op_star
)paren
id|f.fibctx
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Verify that the HANDLE passed in was a valid AdapterFibContext&n;&t; *&n;&t; *&t;Search the list of AdapterFibContext addresses on the adapter&n;&t; *&t;to be sure this is a valid address&n;&t; */
id|found
op_assign
l_int|0
suffix:semicolon
id|entry
op_assign
id|dev-&gt;fib_list.next
suffix:semicolon
r_while
c_loop
(paren
id|entry
op_ne
op_amp
id|dev-&gt;fib_list
)paren
(brace
id|aifcp
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|aac_fib_context
comma
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fibctx
op_eq
id|aifcp
)paren
(brace
multiline_comment|/* We found a winner */
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|entry
op_assign
id|entry-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|found
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fibctx-&gt;type
op_ne
id|FSAFS_NTC_GET_ADAPTER_FIB_CONTEXT
)paren
op_logical_or
(paren
id|fibctx-&gt;size
op_ne
r_sizeof
(paren
r_struct
id|aac_fib_context
)paren
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|status
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|dev-&gt;fib_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If there are no fibs to send back, then either wait or return&n;&t; *&t;-EAGAIN&n;&t; */
id|return_fib
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|aac_list_empty
c_func
(paren
op_amp
id|fibctx-&gt;hw_fib_list
)paren
)paren
(brace
r_struct
id|aac_list_head
op_star
id|entry
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Pull the next fib from the fibs&n;&t;&t; */
id|entry
op_assign
(paren
r_struct
id|aac_list_head
op_star
)paren
(paren
id|ulong
)paren
id|fibctx-&gt;hw_fib_list.next
suffix:semicolon
id|aac_list_del
c_func
(paren
id|entry
)paren
suffix:semicolon
id|hw_fib
op_assign
id|aac_list_entry
c_func
(paren
id|entry
comma
r_struct
id|hw_fib
comma
id|header.FibLinks
)paren
suffix:semicolon
id|fibctx-&gt;count
op_decrement
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dev-&gt;fib_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|f.fib
comma
id|hw_fib
comma
r_sizeof
(paren
r_struct
id|hw_fib
)paren
)paren
)paren
(brace
id|kfree
c_func
(paren
id|hw_fib
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Free the space occupied by this copy of the fib.&n;&t;&t; */
id|kfree
c_func
(paren
id|hw_fib
)paren
suffix:semicolon
id|status
op_assign
l_int|0
suffix:semicolon
id|fibctx-&gt;jiffies
op_assign
id|jiffies
op_div
id|HZ
suffix:semicolon
)brace
r_else
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dev-&gt;fib_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f.wait
)paren
(brace
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|fibctx-&gt;wait_sem
)paren
OL
l_int|0
)paren
(brace
id|status
op_assign
op_minus
id|EINTR
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Lock again and retry */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|dev-&gt;fib_lock
comma
id|flags
)paren
suffix:semicolon
r_goto
id|return_fib
suffix:semicolon
)brace
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
)brace
r_return
id|status
suffix:semicolon
)brace
DECL|function|aac_close_fib_context
r_int
id|aac_close_fib_context
c_func
(paren
r_struct
id|aac_dev
op_star
id|dev
comma
r_struct
id|aac_fib_context
op_star
id|fibctx
)paren
(brace
r_struct
id|hw_fib
op_star
id|hw_fib
suffix:semicolon
multiline_comment|/*&n;&t; *&t;First free any FIBs that have not been consumed.&n;&t; */
r_while
c_loop
(paren
op_logical_neg
id|aac_list_empty
c_func
(paren
op_amp
id|fibctx-&gt;hw_fib_list
)paren
)paren
(brace
r_struct
id|aac_list_head
op_star
id|entry
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Pull the next fib from the fibs&n;&t;&t; */
id|entry
op_assign
(paren
r_struct
id|aac_list_head
op_star
)paren
(paren
id|ulong
)paren
(paren
id|fibctx-&gt;hw_fib_list.next
)paren
suffix:semicolon
id|aac_list_del
c_func
(paren
id|entry
)paren
suffix:semicolon
id|hw_fib
op_assign
id|aac_list_entry
c_func
(paren
id|entry
comma
r_struct
id|hw_fib
comma
id|header.FibLinks
)paren
suffix:semicolon
id|fibctx-&gt;count
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Free the space occupied by this copy of the fib.&n;&t;&t; */
id|kfree
c_func
(paren
id|hw_fib
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Remove the Context from the AdapterFibContext List&n;&t; */
id|list_del
c_func
(paren
op_amp
id|fibctx-&gt;next
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Invalidate context&n;&t; */
id|fibctx-&gt;type
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Free the space occupied by the Context&n;&t; */
id|kfree
c_func
(paren
id|fibctx
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;close_getadapter_fib&t;-&t;close down user fib context&n; *&t;@dev: adapter&n; *&t;@arg: ioctl arguments&n; *&n; *&t;This routine will close down the fibctx passed in from the user.&n; */
DECL|function|close_getadapter_fib
r_static
r_int
id|close_getadapter_fib
c_func
(paren
r_struct
id|aac_dev
op_star
id|dev
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|aac_fib_context
op_star
id|fibctx
comma
op_star
id|aifcp
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
r_int
id|found
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Extract the fibctx from the input parameters&n;&t; */
id|fibctx
op_assign
id|arg
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Verify that the HANDLE passed in was a valid AdapterFibContext&n;&t; *&n;&t; *&t;Search the list of AdapterFibContext addresses on the adapter&n;&t; *&t;to be sure this is a valid address&n;&t; */
id|found
op_assign
l_int|0
suffix:semicolon
id|entry
op_assign
id|dev-&gt;fib_list.next
suffix:semicolon
r_while
c_loop
(paren
id|entry
op_ne
op_amp
id|dev-&gt;fib_list
)paren
(brace
id|aifcp
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|aac_fib_context
comma
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fibctx
op_eq
id|aifcp
)paren
(brace
multiline_comment|/* We found a winner */
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|entry
op_assign
id|entry-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|found
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Already gone */
r_if
c_cond
(paren
(paren
id|fibctx-&gt;type
op_ne
id|FSAFS_NTC_GET_ADAPTER_FIB_CONTEXT
)paren
op_logical_or
(paren
id|fibctx-&gt;size
op_ne
r_sizeof
(paren
r_struct
id|aac_fib_context
)paren
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|dev-&gt;fib_lock
comma
id|flags
)paren
suffix:semicolon
id|status
op_assign
id|aac_close_fib_context
c_func
(paren
id|dev
comma
id|fibctx
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dev-&gt;fib_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;check_revision&t;-&t;close down user fib context&n; *&t;@dev: adapter&n; *&t;@arg: ioctl arguments&n; *&n; *&t;This routine returns the firmware version.&n; *      Under Linux, there have been no version incompatibilities, so this is simple!&n; */
DECL|function|check_revision
r_static
r_int
id|check_revision
c_func
(paren
r_struct
id|aac_dev
op_star
id|dev
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|revision
id|response
suffix:semicolon
id|response.compat
op_assign
l_int|1
suffix:semicolon
id|response.version
op_assign
id|dev-&gt;adapter_info.kernelrev
suffix:semicolon
id|response.build
op_assign
id|dev-&gt;adapter_info.kernelbuild
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|response
comma
r_sizeof
(paren
id|response
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&n; * aac_send_raw_scb&n; *&n; */
DECL|function|aac_send_raw_srb
r_int
id|aac_send_raw_srb
c_func
(paren
r_struct
id|aac_dev
op_star
id|dev
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|fib
op_star
id|srbfib
suffix:semicolon
r_int
id|status
suffix:semicolon
r_struct
id|aac_srb
op_star
id|srbcmd
suffix:semicolon
r_struct
id|aac_srb
op_star
id|user_srb
op_assign
id|arg
suffix:semicolon
r_struct
id|aac_srb_reply
op_star
id|user_reply
suffix:semicolon
r_struct
id|aac_srb_reply
op_star
id|reply
suffix:semicolon
id|u32
id|fibsize
op_assign
l_int|0
suffix:semicolon
id|u32
id|flags
op_assign
l_int|0
suffix:semicolon
id|s32
id|rcode
op_assign
l_int|0
suffix:semicolon
id|u32
id|data_dir
suffix:semicolon
id|ulong
id|sg_user
(braket
l_int|32
)braket
suffix:semicolon
id|ulong
id|sg_list
(braket
l_int|32
)braket
suffix:semicolon
id|u32
id|sg_indx
op_assign
l_int|0
suffix:semicolon
id|u32
id|byte_count
op_assign
l_int|0
suffix:semicolon
id|u32
id|actual_fibsize
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;aacraid: No permission to send raw srb&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Allocate and initialize a Fib then setup a BlockWrite command&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|srbfib
op_assign
id|fib_alloc
c_func
(paren
id|dev
)paren
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|fib_init
c_func
(paren
id|srbfib
)paren
suffix:semicolon
id|srbcmd
op_assign
(paren
r_struct
id|aac_srb
op_star
)paren
id|fib_data
c_func
(paren
id|srbfib
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|fibsize
comma
(paren
r_void
op_star
)paren
op_amp
id|user_srb-&gt;count
comma
r_sizeof
(paren
id|u32
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;aacraid: Could not copy data size from user&bslash;n&quot;
)paren
suffix:semicolon
id|rcode
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|srbcmd
comma
id|user_srb
comma
id|fibsize
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;aacraid: Could not copy srb from user&bslash;n&quot;
)paren
suffix:semicolon
id|rcode
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
id|user_reply
op_assign
id|arg
op_plus
id|fibsize
suffix:semicolon
id|flags
op_assign
id|srbcmd-&gt;flags
suffix:semicolon
singleline_comment|// Fix up srb for endian and force some values
id|srbcmd-&gt;function
op_assign
id|cpu_to_le32
c_func
(paren
id|SRBF_ExecuteScsi
)paren
suffix:semicolon
singleline_comment|// Force this
id|srbcmd-&gt;channel
op_assign
id|cpu_to_le32
c_func
(paren
id|srbcmd-&gt;channel
)paren
suffix:semicolon
id|srbcmd-&gt;target
op_assign
id|cpu_to_le32
c_func
(paren
id|srbcmd-&gt;target
)paren
suffix:semicolon
id|srbcmd-&gt;lun
op_assign
id|cpu_to_le32
c_func
(paren
id|srbcmd-&gt;lun
)paren
suffix:semicolon
id|srbcmd-&gt;flags
op_assign
id|cpu_to_le32
c_func
(paren
id|srbcmd-&gt;flags
)paren
suffix:semicolon
id|srbcmd-&gt;timeout
op_assign
id|cpu_to_le32
c_func
(paren
id|srbcmd-&gt;timeout
)paren
suffix:semicolon
id|srbcmd-&gt;retry_limit
op_assign
id|cpu_to_le32
c_func
(paren
l_int|0
)paren
suffix:semicolon
singleline_comment|// Obsolete parameter
id|srbcmd-&gt;cdb_size
op_assign
id|cpu_to_le32
c_func
(paren
id|srbcmd-&gt;cdb_size
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|srbcmd-&gt;flags
)paren
(brace
r_case
id|SRB_DataOut
suffix:colon
id|data_dir
op_assign
id|SCSI_DATA_WRITE
suffix:semicolon
r_break
suffix:semicolon
r_case
(paren
id|SRB_DataIn
op_or
id|SRB_DataOut
)paren
suffix:colon
id|data_dir
op_assign
id|SCSI_DATA_UNKNOWN
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SRB_DataIn
suffix:colon
id|data_dir
op_assign
id|SCSI_DATA_READ
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|data_dir
op_assign
id|SCSI_DATA_NONE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;pae_support
op_eq
l_int|1
)paren
(brace
r_struct
id|sgmap64
op_star
id|psg
op_assign
(paren
r_struct
id|sgmap64
op_star
)paren
op_amp
id|srbcmd-&gt;sg
suffix:semicolon
id|byte_count
op_assign
l_int|0
suffix:semicolon
singleline_comment|// This should also catch if user used the 32 bit sgmap
id|actual_fibsize
op_assign
r_sizeof
(paren
r_struct
id|aac_srb
)paren
op_plus
(paren
(paren
(paren
id|srbcmd-&gt;sg.count
op_amp
l_int|0xff
)paren
op_minus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|sgentry64
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|actual_fibsize
op_ne
id|fibsize
)paren
(brace
singleline_comment|// User made a mistake - should not continue
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;aacraid: Bad Size specified in Raw SRB command&bslash;n&quot;
)paren
suffix:semicolon
id|rcode
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|psg-&gt;count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dma_addr_t
id|addr
suffix:semicolon
id|u64
id|le_addr
suffix:semicolon
r_void
op_star
id|p
suffix:semicolon
id|p
op_assign
id|kmalloc
c_func
(paren
id|psg-&gt;sg
(braket
id|i
)braket
dot
id|count
comma
id|GFP_KERNEL
op_or
id|__GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d&bslash;n&quot;
comma
id|psg-&gt;sg
(braket
id|i
)braket
dot
id|count
comma
id|i
comma
id|psg-&gt;count
)paren
suffix:semicolon
id|rcode
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
id|sg_user
(braket
id|i
)braket
op_assign
(paren
id|ulong
)paren
id|psg-&gt;sg
(braket
id|i
)braket
dot
id|addr
suffix:semicolon
id|sg_list
(braket
id|i
)braket
op_assign
(paren
id|ulong
)paren
id|p
suffix:semicolon
singleline_comment|// save so we can clean up later
id|sg_indx
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SRB_DataOut
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|p
comma
id|psg-&gt;sg
(braket
id|i
)braket
dot
id|addr
comma
id|psg-&gt;sg
(braket
id|i
)braket
dot
id|count
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;aacraid: Could not copy sg data from user&bslash;n&quot;
)paren
suffix:semicolon
id|rcode
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
)brace
id|addr
op_assign
id|pci_map_single
c_func
(paren
id|dev-&gt;pdev
comma
id|p
comma
id|psg-&gt;sg
(braket
id|i
)braket
dot
id|count
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|data_dir
)paren
)paren
suffix:semicolon
id|le_addr
op_assign
id|cpu_to_le64
c_func
(paren
id|addr
)paren
suffix:semicolon
id|psg-&gt;sg
(braket
id|i
)braket
dot
id|addr
(braket
l_int|1
)braket
op_assign
(paren
id|u32
)paren
(paren
id|le_addr
op_rshift
l_int|32
)paren
suffix:semicolon
id|psg-&gt;sg
(braket
id|i
)braket
dot
id|addr
(braket
l_int|0
)braket
op_assign
(paren
id|u32
)paren
(paren
id|le_addr
op_amp
l_int|0xffffffff
)paren
suffix:semicolon
id|psg-&gt;sg
(braket
id|i
)braket
dot
id|count
op_assign
id|cpu_to_le32
c_func
(paren
id|psg-&gt;sg
(braket
id|i
)braket
dot
id|count
)paren
suffix:semicolon
id|byte_count
op_add_assign
id|psg-&gt;sg
(braket
id|i
)braket
dot
id|count
suffix:semicolon
)brace
id|srbcmd-&gt;count
op_assign
id|cpu_to_le32
c_func
(paren
id|byte_count
)paren
suffix:semicolon
id|status
op_assign
id|fib_send
c_func
(paren
id|ScsiPortCommand64
comma
id|srbfib
comma
id|actual_fibsize
comma
id|FsaNormal
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|sgmap
op_star
id|psg
op_assign
op_amp
id|srbcmd-&gt;sg
suffix:semicolon
id|byte_count
op_assign
l_int|0
suffix:semicolon
id|actual_fibsize
op_assign
r_sizeof
(paren
r_struct
id|aac_srb
)paren
op_plus
(paren
(paren
(paren
id|srbcmd-&gt;sg.count
op_amp
l_int|0xff
)paren
op_minus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|sgentry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|actual_fibsize
op_ne
id|fibsize
)paren
(brace
singleline_comment|// User made a mistake - should not continue
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;aacraid: Bad Size specified in Raw SRB command&bslash;n&quot;
)paren
suffix:semicolon
id|rcode
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|psg-&gt;count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dma_addr_t
id|addr
suffix:semicolon
r_void
op_star
id|p
suffix:semicolon
id|p
op_assign
id|kmalloc
c_func
(paren
id|psg-&gt;sg
(braket
id|i
)braket
dot
id|count
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d&bslash;n&quot;
comma
id|psg-&gt;sg
(braket
id|i
)braket
dot
id|count
comma
id|i
comma
id|psg-&gt;count
)paren
suffix:semicolon
id|rcode
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
id|sg_user
(braket
id|i
)braket
op_assign
(paren
id|ulong
)paren
(paren
id|psg-&gt;sg
(braket
id|i
)braket
dot
id|addr
)paren
suffix:semicolon
id|sg_list
(braket
id|i
)braket
op_assign
(paren
id|ulong
)paren
id|p
suffix:semicolon
singleline_comment|// save so we can clean up later
id|sg_indx
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SRB_DataOut
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
(paren
r_void
op_star
)paren
id|p
comma
(paren
r_void
op_star
)paren
(paren
id|ulong
)paren
(paren
id|psg-&gt;sg
(braket
id|i
)braket
dot
id|addr
)paren
comma
id|psg-&gt;sg
(braket
id|i
)braket
dot
id|count
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;aacraid: Could not copy sg data from user&bslash;n&quot;
)paren
suffix:semicolon
id|rcode
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
)brace
id|addr
op_assign
id|pci_map_single
c_func
(paren
id|dev-&gt;pdev
comma
id|p
comma
id|psg-&gt;sg
(braket
id|i
)braket
dot
id|count
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|data_dir
)paren
)paren
suffix:semicolon
id|psg-&gt;sg
(braket
id|i
)braket
dot
id|addr
op_assign
id|cpu_to_le32
c_func
(paren
id|addr
)paren
suffix:semicolon
id|psg-&gt;sg
(braket
id|i
)braket
dot
id|count
op_assign
id|cpu_to_le32
c_func
(paren
id|psg-&gt;sg
(braket
id|i
)braket
dot
id|count
)paren
suffix:semicolon
id|byte_count
op_add_assign
id|psg-&gt;sg
(braket
id|i
)braket
dot
id|count
suffix:semicolon
)brace
id|srbcmd-&gt;count
op_assign
id|cpu_to_le32
c_func
(paren
id|byte_count
)paren
suffix:semicolon
id|status
op_assign
id|fib_send
c_func
(paren
id|ScsiPortCommand
comma
id|srbfib
comma
id|actual_fibsize
comma
id|FsaNormal
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;aacraid: Could not send raw srb fib to hba&bslash;n&quot;
)paren
suffix:semicolon
id|rcode
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|SRB_DataIn
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|sg_indx
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|sg_user
(braket
id|i
)braket
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|sg_list
(braket
id|i
)braket
)paren
comma
id|le32_to_cpu
c_func
(paren
id|srbcmd-&gt;sg.sg
(braket
id|i
)braket
dot
id|count
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;aacraid: Could not copy sg data to user&bslash;n&quot;
)paren
suffix:semicolon
id|rcode
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
)brace
)brace
id|reply
op_assign
(paren
r_struct
id|aac_srb_reply
op_star
)paren
id|fib_data
c_func
(paren
id|srbfib
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|user_reply
comma
id|reply
comma
r_sizeof
(paren
r_struct
id|aac_srb_reply
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;aacraid: Could not copy reply to user&bslash;n&quot;
)paren
suffix:semicolon
id|rcode
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
id|cleanup
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|sg_indx
suffix:semicolon
id|i
op_increment
)paren
(brace
id|kfree
c_func
(paren
(paren
r_void
op_star
)paren
id|sg_list
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|fib_complete
c_func
(paren
id|srbfib
)paren
suffix:semicolon
id|fib_free
c_func
(paren
id|srbfib
)paren
suffix:semicolon
r_return
id|rcode
suffix:semicolon
)brace
DECL|struct|aac_pci_info
r_struct
id|aac_pci_info
(brace
DECL|member|bus
id|u32
id|bus
suffix:semicolon
DECL|member|slot
id|u32
id|slot
suffix:semicolon
)brace
suffix:semicolon
DECL|function|aac_get_pci_info
r_int
id|aac_get_pci_info
c_func
(paren
r_struct
id|aac_dev
op_star
id|dev
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|aac_pci_info
id|pci_info
suffix:semicolon
id|pci_info.bus
op_assign
id|dev-&gt;pdev-&gt;bus-&gt;number
suffix:semicolon
id|pci_info.slot
op_assign
id|PCI_SLOT
c_func
(paren
id|dev-&gt;pdev-&gt;devfn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
(paren
r_void
op_star
)paren
op_amp
id|pci_info
comma
r_sizeof
(paren
r_struct
id|aac_pci_info
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;aacraid: Could not copy pci info&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|aac_do_ioctl
r_int
id|aac_do_ioctl
c_func
(paren
r_struct
id|aac_dev
op_star
id|dev
comma
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_int
id|status
suffix:semicolon
multiline_comment|/*&n;&t; *&t;HBA gets first crack&n;&t; */
id|status
op_assign
id|aac_dev_ioctl
c_func
(paren
id|dev
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
op_minus
id|ENOTTY
)paren
(brace
r_return
id|status
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|FSACTL_MINIPORT_REV_CHECK
suffix:colon
id|status
op_assign
id|check_revision
c_func
(paren
id|dev
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FSACTL_SENDFIB
suffix:colon
id|status
op_assign
id|ioctl_send_fib
c_func
(paren
id|dev
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FSACTL_OPEN_GET_ADAPTER_FIB
suffix:colon
id|status
op_assign
id|open_getadapter_fib
c_func
(paren
id|dev
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FSACTL_GET_NEXT_ADAPTER_FIB
suffix:colon
id|status
op_assign
id|next_getadapter_fib
c_func
(paren
id|dev
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FSACTL_CLOSE_GET_ADAPTER_FIB
suffix:colon
id|status
op_assign
id|close_getadapter_fib
c_func
(paren
id|dev
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FSACTL_SEND_RAW_SRB
suffix:colon
id|status
op_assign
id|aac_send_raw_srb
c_func
(paren
id|dev
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FSACTL_GET_PCI_INFO
suffix:colon
id|status
op_assign
id|aac_get_pci_info
c_func
(paren
id|dev
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|status
op_assign
op_minus
id|ENOTTY
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
eof
