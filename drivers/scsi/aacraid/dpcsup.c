multiline_comment|/*&n; *&t;Adaptec AAC series RAID controller driver&n; *&t;(c) Copyright 2001 Red Hat Inc.&t;&lt;alan@redhat.com&gt;&n; *&n; * based on the old aacraid driver that is..&n; * Adaptec aacraid device driver for Linux.&n; *&n; * Copyright (c) 2000 Adaptec, Inc. (aacraid@adaptec.com)&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; see the file COPYING.  If not, write to&n; * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; * Module Name:&n; *  dpcsup.c&n; *&n; * Abstract: All DPC processing routines for the cyclone board occur here.&n; *&n; *&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &quot;aacraid.h&quot;
multiline_comment|/**&n; *&t;aac_response_normal&t;-&t;Handle command replies&n; *&t;@q: Queue to read from&n; *&n; *&t;This DPC routine will be run when the adapter interrupts us to let us&n; *&t;know there is a response on our normal priority queue. We will pull off&n; *&t;all QE there are and wake up all the waiters before exiting. We will&n; *&t;take a spinlock out on the queue before operating on it.&n; */
DECL|function|aac_response_normal
r_int
r_int
id|aac_response_normal
c_func
(paren
r_struct
id|aac_queue
op_star
id|q
)paren
(brace
r_struct
id|aac_dev
op_star
id|dev
op_assign
id|q-&gt;dev
suffix:semicolon
r_struct
id|aac_entry
op_star
id|entry
suffix:semicolon
r_struct
id|hw_fib
op_star
id|hwfib
suffix:semicolon
r_struct
id|fib
op_star
id|fib
suffix:semicolon
r_int
id|consumed
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Keep pulling response QEs off the response queue and waking&n;&t; *&t;up the waiters until there are no more QEs. We then return&n;&t; *&t;back to the system. If no response was requesed we just&n;&t; *&t;deallocate the Fib here and continue.&n;&t; */
r_while
c_loop
(paren
id|aac_consumer_get
c_func
(paren
id|dev
comma
id|q
comma
op_amp
id|entry
)paren
)paren
(brace
r_int
id|fast
suffix:semicolon
id|u32
id|index
op_assign
id|le32_to_cpu
c_func
(paren
id|entry-&gt;addr
)paren
suffix:semicolon
id|fast
op_assign
id|index
op_amp
l_int|0x01
suffix:semicolon
id|fib
op_assign
op_amp
id|dev-&gt;fibs
(braket
id|index
op_rshift
l_int|1
)braket
suffix:semicolon
id|hwfib
op_assign
id|fib-&gt;hw_fib
suffix:semicolon
id|aac_consumer_free
c_func
(paren
id|dev
comma
id|q
comma
id|HostNormRespQueue
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Remove this fib from the Outstanding I/O queue.&n;&t;&t; *&t;But only if it has not already been timed out.&n;&t;&t; *&n;&t;&t; *&t;If the fib has been timed out already, then just &n;&t;&t; *&t;continue. The caller has already been notified that&n;&t;&t; *&t;the fib timed out.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|fib-&gt;flags
op_amp
id|FIB_CONTEXT_FLAG_TIMED_OUT
)paren
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|fib-&gt;queue
)paren
suffix:semicolon
id|dev-&gt;queues-&gt;queue
(braket
id|AdapNormCmdQueue
)braket
dot
id|numpending
op_decrement
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;aacraid: FIB timeout (%x).&bslash;n&quot;
comma
id|fib-&gt;flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;aacraid: hwfib=%p fib index=%i fib=%p&bslash;n&quot;
comma
id|hwfib
comma
id|hwfib-&gt;header.SenderData
comma
id|fib
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fast
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Doctor the fib&n;&t;&t;&t; */
op_star
(paren
id|u32
op_star
)paren
id|hwfib-&gt;data
op_assign
id|cpu_to_le32
c_func
(paren
id|ST_OK
)paren
suffix:semicolon
id|hwfib-&gt;header.XferState
op_or_assign
id|cpu_to_le32
c_func
(paren
id|AdapterProcessed
)paren
suffix:semicolon
)brace
id|FIB_COUNTER_INCREMENT
c_func
(paren
id|aac_config.FibRecved
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwfib-&gt;header.Command
op_eq
id|cpu_to_le16
c_func
(paren
id|NuFileSystem
)paren
)paren
(brace
id|u32
op_star
id|pstatus
op_assign
(paren
id|u32
op_star
)paren
id|hwfib-&gt;data
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pstatus
op_amp
id|cpu_to_le32
c_func
(paren
l_int|0xffff0000
)paren
)paren
op_star
id|pstatus
op_assign
id|cpu_to_le32
c_func
(paren
id|ST_OK
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwfib-&gt;header.XferState
op_amp
id|cpu_to_le32
c_func
(paren
id|NoResponseExpected
op_or
id|Async
)paren
)paren
(brace
r_if
c_cond
(paren
id|hwfib-&gt;header.XferState
op_amp
id|cpu_to_le32
c_func
(paren
id|NoResponseExpected
)paren
)paren
id|FIB_COUNTER_INCREMENT
c_func
(paren
id|aac_config.NoResponseRecved
)paren
suffix:semicolon
r_else
id|FIB_COUNTER_INCREMENT
c_func
(paren
id|aac_config.AsyncRecved
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;NOTE:  we cannot touch the fib after this&n;&t;&t;&t; *&t;    call, because it may have been deallocated.&n;&t;&t;&t; */
id|fib
op_member_access_from_pointer
id|callback
c_func
(paren
id|fib-&gt;callback_data
comma
id|fib
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|flagv
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|fib-&gt;event_lock
comma
id|flagv
)paren
suffix:semicolon
id|fib-&gt;done
op_assign
l_int|1
suffix:semicolon
id|up
c_func
(paren
op_amp
id|fib-&gt;event_wait
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|fib-&gt;event_lock
comma
id|flagv
)paren
suffix:semicolon
id|FIB_COUNTER_INCREMENT
c_func
(paren
id|aac_config.NormalRecved
)paren
suffix:semicolon
)brace
id|consumed
op_increment
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|consumed
OG
id|aac_config.peak_fibs
)paren
id|aac_config.peak_fibs
op_assign
id|consumed
suffix:semicolon
r_if
c_cond
(paren
id|consumed
op_eq
l_int|0
)paren
id|aac_config.zero_fibs
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;aac_command_normal&t;-&t;handle commands&n; *&t;@q: queue to process&n; *&n; *&t;This DPC routine will be queued when the adapter interrupts us to &n; *&t;let us know there is a command on our normal priority queue. We will &n; *&t;pull off all QE there are and wake up all the waiters before exiting.&n; *&t;We will take a spinlock out on the queue before operating on it.&n; */
DECL|function|aac_command_normal
r_int
r_int
id|aac_command_normal
c_func
(paren
r_struct
id|aac_queue
op_star
id|q
)paren
(brace
r_struct
id|aac_dev
op_star
id|dev
op_assign
id|q-&gt;dev
suffix:semicolon
r_struct
id|aac_entry
op_star
id|entry
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Keep pulling response QEs off the response queue and waking&n;&t; *&t;up the waiters until there are no more QEs. We then return&n;&t; *&t;back to the system.&n;&t; */
r_while
c_loop
(paren
id|aac_consumer_get
c_func
(paren
id|dev
comma
id|q
comma
op_amp
id|entry
)paren
)paren
(brace
r_struct
id|fib
id|fibctx
suffix:semicolon
r_struct
id|hw_fib
op_star
id|hw_fib
suffix:semicolon
id|u32
id|index
suffix:semicolon
r_struct
id|fib
op_star
id|fib
op_assign
op_amp
id|fibctx
suffix:semicolon
id|index
op_assign
id|le32_to_cpu
c_func
(paren
id|entry-&gt;addr
)paren
op_div
r_sizeof
(paren
r_struct
id|hw_fib
)paren
suffix:semicolon
id|hw_fib
op_assign
op_amp
id|dev-&gt;aif_base_va
(braket
id|index
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Allocate a FIB at all costs. For non queued stuff&n;&t;&t; *&t;we can just use the stack so we are happy. We need&n;&t;&t; *&t;a fib object in order to manage the linked lists&n;&t;&t; */
r_if
c_cond
(paren
id|dev-&gt;aif_thread
)paren
r_if
c_cond
(paren
(paren
id|fib
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|fib
)paren
comma
id|GFP_ATOMIC
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|fib
op_assign
op_amp
id|fibctx
suffix:semicolon
)brace
id|memset
c_func
(paren
id|fib
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|fib
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|fib-&gt;fiblink
)paren
suffix:semicolon
id|fib-&gt;type
op_assign
id|FSAFS_NTC_FIB_CONTEXT
suffix:semicolon
id|fib-&gt;size
op_assign
r_sizeof
(paren
r_struct
id|fib
)paren
suffix:semicolon
id|fib-&gt;hw_fib
op_assign
id|hw_fib
suffix:semicolon
id|fib-&gt;data
op_assign
id|hw_fib-&gt;data
suffix:semicolon
id|fib-&gt;dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;aif_thread
op_logical_and
id|fib
op_ne
op_amp
id|fibctx
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|fib-&gt;fiblink
comma
op_amp
id|q-&gt;cmdq
)paren
suffix:semicolon
id|aac_consumer_free
c_func
(paren
id|dev
comma
id|q
comma
id|HostNormCmdQueue
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|q-&gt;cmdready
)paren
suffix:semicolon
)brace
r_else
(brace
id|aac_consumer_free
c_func
(paren
id|dev
comma
id|q
comma
id|HostNormCmdQueue
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Set the status of this FIB&n;&t;&t;&t; */
op_star
(paren
id|u32
op_star
)paren
id|hw_fib-&gt;data
op_assign
id|cpu_to_le32
c_func
(paren
id|ST_OK
)paren
suffix:semicolon
id|fib_adapter_complete
c_func
(paren
id|fib
comma
r_sizeof
(paren
id|u32
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
