multiline_comment|/*&n; *&t;Adaptec AAC series RAID controller driver&n; *&t;(c) Copyright 2001 Red Hat Inc.&t;&lt;alan@redhat.com&gt;&n; *&n; * based on the old aacraid driver that is..&n; * Adaptec aacraid device driver for Linux.&n; *&n; * Copyright (c) 2000 Adaptec, Inc. (aacraid@adaptec.com)&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; see the file COPYING.  If not, write to&n; * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; * Module Name:&n; *  commsup.c&n; *&n; * Abstract: Contain all routines that are required for FSA host/adapter&n; *    commuication.&n; *&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &quot;aacraid.h&quot;
multiline_comment|/**&n; *&t;fib_map_alloc&t;&t;-&t;allocate the fib objects&n; *&t;@dev: Adapter to allocate for&n; *&n; *&t;Allocate and map the shared PCI space for the FIB blocks used to&n; *&t;talk to the Adaptec firmware.&n; */
DECL|function|fib_map_alloc
r_static
r_int
id|fib_map_alloc
c_func
(paren
r_struct
id|aac_dev
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev-&gt;hw_fib_va
op_assign
id|pci_alloc_consistent
c_func
(paren
id|dev-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|hw_fib
)paren
op_star
id|AAC_NUM_FIB
comma
op_amp
id|dev-&gt;hw_fib_pa
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;fib_map_free&t;&t;-&t;free the fib objects&n; *&t;@dev: Adapter to free&n; *&n; *&t;Free the PCI mappings and the memory allocated for FIB blocks&n; *&t;on this adapter.&n; */
DECL|function|fib_map_free
r_void
id|fib_map_free
c_func
(paren
r_struct
id|aac_dev
op_star
id|dev
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|dev-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|hw_fib
)paren
op_star
id|AAC_NUM_FIB
comma
id|dev-&gt;hw_fib_va
comma
id|dev-&gt;hw_fib_pa
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;fib_setup&t;-&t;setup the fibs&n; *&t;@dev: Adapter to set up&n; *&n; *&t;Allocate the PCI space for the fibs, map it and then intialise the&n; *&t;fib area, the unmapped fib data and also the free list&n; */
DECL|function|fib_setup
r_int
id|fib_setup
c_func
(paren
r_struct
id|aac_dev
op_star
id|dev
)paren
(brace
r_struct
id|fib
op_star
id|fibptr
suffix:semicolon
r_struct
id|hw_fib
op_star
id|hw_fib_va
suffix:semicolon
id|dma_addr_t
id|hw_fib_pa
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|fib_map_alloc
c_func
(paren
id|dev
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|hw_fib_va
op_assign
id|dev-&gt;hw_fib_va
suffix:semicolon
id|hw_fib_pa
op_assign
id|dev-&gt;hw_fib_pa
suffix:semicolon
id|memset
c_func
(paren
id|hw_fib_va
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|hw_fib
)paren
op_star
id|AAC_NUM_FIB
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Initialise the fibs&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|fibptr
op_assign
op_amp
id|dev-&gt;fibs
(braket
id|i
)braket
suffix:semicolon
id|i
OL
id|AAC_NUM_FIB
suffix:semicolon
id|i
op_increment
comma
id|fibptr
op_increment
)paren
(brace
id|fibptr-&gt;dev
op_assign
id|dev
suffix:semicolon
id|fibptr-&gt;hw_fib
op_assign
id|hw_fib_va
suffix:semicolon
id|fibptr-&gt;data
op_assign
(paren
r_void
op_star
)paren
id|fibptr-&gt;hw_fib-&gt;data
suffix:semicolon
id|fibptr-&gt;next
op_assign
id|fibptr
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Forward chain the fibs */
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
id|fibptr-&gt;event_wait
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|fibptr-&gt;event_lock
)paren
suffix:semicolon
id|hw_fib_va-&gt;header.XferState
op_assign
id|cpu_to_le32
c_func
(paren
l_int|0xffffffff
)paren
suffix:semicolon
id|hw_fib_va-&gt;header.SenderSize
op_assign
id|cpu_to_le16
c_func
(paren
r_sizeof
(paren
r_struct
id|hw_fib
)paren
)paren
suffix:semicolon
id|fibptr-&gt;hw_fib_pa
op_assign
id|hw_fib_pa
suffix:semicolon
id|hw_fib_va
op_assign
(paren
r_struct
id|hw_fib
op_star
)paren
(paren
(paren
r_int
r_char
op_star
)paren
id|hw_fib_va
op_plus
r_sizeof
(paren
r_struct
id|hw_fib
)paren
)paren
suffix:semicolon
id|hw_fib_pa
op_assign
id|hw_fib_pa
op_plus
r_sizeof
(paren
r_struct
id|hw_fib
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Add the fib chain to the free list&n;&t; */
id|dev-&gt;fibs
(braket
id|AAC_NUM_FIB
op_minus
l_int|1
)braket
dot
id|next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Enable this to debug out of queue space&n;&t; */
id|dev-&gt;free_fib
op_assign
op_amp
id|dev-&gt;fibs
(braket
l_int|0
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;fib_alloc&t;-&t;allocate a fib&n; *&t;@dev: Adapter to allocate the fib for&n; *&n; *&t;Allocate a fib from the adapter fib pool. If the pool is empty we&n; *&t;wait for fibs to become free.&n; */
DECL|function|fib_alloc
r_struct
id|fib
op_star
id|fib_alloc
c_func
(paren
r_struct
id|aac_dev
op_star
id|dev
)paren
(brace
r_struct
id|fib
op_star
id|fibptr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|dev-&gt;fib_lock
comma
id|flags
)paren
suffix:semicolon
id|fibptr
op_assign
id|dev-&gt;free_fib
suffix:semicolon
multiline_comment|/* Cannot sleep here or you get hangs. Instead we did the&n;&t;   maths at compile time. */
r_if
c_cond
(paren
op_logical_neg
id|fibptr
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|dev-&gt;free_fib
op_assign
id|fibptr-&gt;next
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dev-&gt;fib_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Set the proper node type code and node byte size&n;&t; */
id|fibptr-&gt;type
op_assign
id|FSAFS_NTC_FIB_CONTEXT
suffix:semicolon
id|fibptr-&gt;size
op_assign
r_sizeof
(paren
r_struct
id|fib
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Null out fields that depend on being zero at the start of&n;&t; *&t;each I/O&n;&t; */
id|fibptr-&gt;hw_fib-&gt;header.XferState
op_assign
id|cpu_to_le32
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|fibptr-&gt;callback
op_assign
l_int|NULL
suffix:semicolon
id|fibptr-&gt;callback_data
op_assign
l_int|NULL
suffix:semicolon
r_return
id|fibptr
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;fib_free&t;-&t;free a fib&n; *&t;@fibptr: fib to free up&n; *&n; *&t;Frees up a fib and places it on the appropriate queue&n; *&t;(either free or timed out)&n; */
DECL|function|fib_free
r_void
id|fib_free
c_func
(paren
r_struct
id|fib
op_star
id|fibptr
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|fibptr-&gt;dev-&gt;fib_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fibptr-&gt;flags
op_amp
id|FIB_CONTEXT_FLAG_TIMED_OUT
)paren
(brace
id|aac_config.fib_timeouts
op_increment
suffix:semicolon
id|fibptr-&gt;next
op_assign
id|fibptr-&gt;dev-&gt;timeout_fib
suffix:semicolon
id|fibptr-&gt;dev-&gt;timeout_fib
op_assign
id|fibptr
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|fibptr-&gt;hw_fib-&gt;header.XferState
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;fib_free, XferState != 0, fibptr = 0x%p, XferState = 0x%x&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|fibptr
comma
id|fibptr-&gt;hw_fib-&gt;header.XferState
)paren
suffix:semicolon
)brace
id|fibptr-&gt;next
op_assign
id|fibptr-&gt;dev-&gt;free_fib
suffix:semicolon
id|fibptr-&gt;dev-&gt;free_fib
op_assign
id|fibptr
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|fibptr-&gt;dev-&gt;fib_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;fib_init&t;-&t;initialise a fib&n; *&t;@fibptr: The fib to initialize&n; *&t;&n; *&t;Set up the generic fib fields ready for use&n; */
DECL|function|fib_init
r_void
id|fib_init
c_func
(paren
r_struct
id|fib
op_star
id|fibptr
)paren
(brace
r_struct
id|hw_fib
op_star
id|hw_fib
op_assign
id|fibptr-&gt;hw_fib
suffix:semicolon
id|hw_fib-&gt;header.StructType
op_assign
id|FIB_MAGIC
suffix:semicolon
id|hw_fib-&gt;header.Size
op_assign
id|cpu_to_le16
c_func
(paren
r_sizeof
(paren
r_struct
id|hw_fib
)paren
)paren
suffix:semicolon
id|hw_fib-&gt;header.XferState
op_assign
id|cpu_to_le32
c_func
(paren
id|HostOwned
op_or
id|FibInitialized
op_or
id|FibEmpty
op_or
id|FastResponseCapable
)paren
suffix:semicolon
id|hw_fib-&gt;header.SenderFibAddress
op_assign
id|cpu_to_le32
c_func
(paren
id|fibptr-&gt;hw_fib_pa
)paren
suffix:semicolon
id|hw_fib-&gt;header.ReceiverFibAddress
op_assign
id|cpu_to_le32
c_func
(paren
id|fibptr-&gt;hw_fib_pa
)paren
suffix:semicolon
id|hw_fib-&gt;header.SenderSize
op_assign
id|cpu_to_le16
c_func
(paren
r_sizeof
(paren
r_struct
id|hw_fib
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;fib_deallocate&t;&t;-&t;deallocate a fib&n; *&t;@fibptr: fib to deallocate&n; *&n; *&t;Will deallocate and return to the free pool the FIB pointed to by the&n; *&t;caller.&n; */
DECL|function|fib_dealloc
r_void
id|fib_dealloc
c_func
(paren
r_struct
id|fib
op_star
id|fibptr
)paren
(brace
r_struct
id|hw_fib
op_star
id|hw_fib
op_assign
id|fibptr-&gt;hw_fib
suffix:semicolon
r_if
c_cond
(paren
id|hw_fib-&gt;header.StructType
op_ne
id|FIB_MAGIC
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|hw_fib-&gt;header.XferState
op_assign
id|cpu_to_le32
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Commuication primitives define and support the queuing method we use to&n; *&t;support host to adapter commuication. All queue accesses happen through&n; *&t;these routines and are the only routines which have a knowledge of the&n; *&t; how these queues are implemented.&n; */
multiline_comment|/**&n; *&t;aac_get_entry&t;&t;-&t;get a queue entry&n; *&t;@dev: Adapter&n; *&t;@qid: Queue Number&n; *&t;@entry: Entry return&n; *&t;@index: Index return&n; *&t;@nonotify: notification control&n; *&n; *&t;With a priority the routine returns a queue entry if the queue has free entries. If the queue&n; *&t;is full(no free entries) than no entry is returned and the function returns 0 otherwise 1 is&n; *&t;returned.&n; */
DECL|function|aac_get_entry
r_static
r_int
id|aac_get_entry
(paren
r_struct
id|aac_dev
op_star
id|dev
comma
id|u32
id|qid
comma
r_struct
id|aac_entry
op_star
op_star
id|entry
comma
id|u32
op_star
id|index
comma
r_int
r_int
op_star
id|nonotify
)paren
(brace
r_struct
id|aac_queue
op_star
id|q
suffix:semicolon
multiline_comment|/*&n;&t; *&t;All of the queues wrap when they reach the end, so we check&n;&t; *&t;to see if they have reached the end and if they have we just&n;&t; *&t;set the index back to zero. This is a wrap. You could or off&n;&t; *&t;the high bits in all updates but this is a bit faster I think.&n;&t; */
id|q
op_assign
op_amp
id|dev-&gt;queues-&gt;queue
(braket
id|qid
)braket
suffix:semicolon
op_star
id|index
op_assign
id|le32_to_cpu
c_func
(paren
op_star
(paren
id|q-&gt;headers.producer
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|index
op_minus
l_int|2
)paren
op_eq
id|le32_to_cpu
c_func
(paren
op_star
(paren
id|q-&gt;headers.consumer
)paren
)paren
)paren
op_star
id|nonotify
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|qid
op_eq
id|AdapHighCmdQueue
)paren
(brace
r_if
c_cond
(paren
op_star
id|index
op_ge
id|ADAP_HIGH_CMD_ENTRIES
)paren
op_star
id|index
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|qid
op_eq
id|AdapNormCmdQueue
)paren
(brace
r_if
c_cond
(paren
op_star
id|index
op_ge
id|ADAP_NORM_CMD_ENTRIES
)paren
op_star
id|index
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Wrap to front of the Producer Queue. */
)brace
r_else
r_if
c_cond
(paren
id|qid
op_eq
id|AdapHighRespQueue
)paren
(brace
r_if
c_cond
(paren
op_star
id|index
op_ge
id|ADAP_HIGH_RESP_ENTRIES
)paren
op_star
id|index
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|qid
op_eq
id|AdapNormRespQueue
)paren
(brace
r_if
c_cond
(paren
op_star
id|index
op_ge
id|ADAP_NORM_RESP_ENTRIES
)paren
op_star
id|index
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Wrap to front of the Producer Queue. */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;aacraid: invalid qid&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_star
id|index
op_plus
l_int|1
)paren
op_eq
id|le32_to_cpu
c_func
(paren
op_star
(paren
id|q-&gt;headers.consumer
)paren
)paren
)paren
(brace
multiline_comment|/* Queue is full */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Queue %d full, %d outstanding.&bslash;n&quot;
comma
id|qid
comma
id|q-&gt;numpending
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
op_star
id|entry
op_assign
id|q-&gt;base
op_plus
op_star
id|index
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;aac_queue_get&t;&t;-&t;get the next free QE&n; *&t;@dev: Adapter&n; *&t;@index: Returned index&n; *&t;@priority: Priority of fib&n; *&t;@fib: Fib to associate with the queue entry&n; *&t;@wait: Wait if queue full&n; *&t;@fibptr: Driver fib object to go with fib&n; *&t;@nonotify: Don&squot;t notify the adapter&n; *&n; *&t;Gets the next free QE off the requested priorty adapter command&n; *&t;queue and associates the Fib with the QE. The QE represented by&n; *&t;index is ready to insert on the queue when this routine returns&n; *&t;success.&n; */
DECL|function|aac_queue_get
r_static
r_int
id|aac_queue_get
c_func
(paren
r_struct
id|aac_dev
op_star
id|dev
comma
id|u32
op_star
id|index
comma
id|u32
id|qid
comma
r_struct
id|hw_fib
op_star
id|hw_fib
comma
r_int
id|wait
comma
r_struct
id|fib
op_star
id|fibptr
comma
r_int
r_int
op_star
id|nonotify
)paren
(brace
r_struct
id|aac_entry
op_star
id|entry
op_assign
l_int|NULL
suffix:semicolon
r_int
id|map
op_assign
l_int|0
suffix:semicolon
r_struct
id|aac_queue
op_star
id|q
op_assign
op_amp
id|dev-&gt;queues-&gt;queue
(braket
id|qid
)braket
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|q-&gt;lock
comma
id|q-&gt;SavedIrql
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qid
op_eq
id|AdapHighCmdQueue
op_logical_or
id|qid
op_eq
id|AdapNormCmdQueue
)paren
(brace
multiline_comment|/*  if no entries wait for some if caller wants to */
r_while
c_loop
(paren
op_logical_neg
id|aac_get_entry
c_func
(paren
id|dev
comma
id|qid
comma
op_amp
id|entry
comma
id|index
comma
id|nonotify
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;GetEntries failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;         *&t;Setup queue entry with a command, status and fib mapped&n;&t;         */
id|entry-&gt;size
op_assign
id|cpu_to_le32
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|hw_fib-&gt;header.Size
)paren
)paren
suffix:semicolon
id|map
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|qid
op_eq
id|AdapHighRespQueue
op_logical_or
id|qid
op_eq
id|AdapNormRespQueue
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|aac_get_entry
c_func
(paren
id|dev
comma
id|qid
comma
op_amp
id|entry
comma
id|index
comma
id|nonotify
)paren
)paren
(brace
multiline_comment|/* if no entries wait for some if caller wants to */
)brace
multiline_comment|/*&n;        &t; *&t;Setup queue entry with command, status and fib mapped&n;        &t; */
id|entry-&gt;size
op_assign
id|cpu_to_le32
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|hw_fib-&gt;header.Size
)paren
)paren
suffix:semicolon
id|entry-&gt;addr
op_assign
id|hw_fib-&gt;header.SenderFibAddress
suffix:semicolon
multiline_comment|/* Restore adapters pointer to the FIB */
id|hw_fib-&gt;header.ReceiverFibAddress
op_assign
id|hw_fib-&gt;header.SenderFibAddress
suffix:semicolon
multiline_comment|/* Let the adapter now where to find its data */
id|map
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;If MapFib is true than we need to map the Fib and put pointers&n;&t; *&t;in the queue entry.&n;&t; */
r_if
c_cond
(paren
id|map
)paren
id|entry-&gt;addr
op_assign
id|fibptr-&gt;hw_fib_pa
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;aac_insert_entry&t;-&t;insert a queue entry&n; *&t;@dev: Adapter&n; *&t;@index: Index of entry to insert&n; *&t;@qid: Queue number&n; *&t;@nonotify: Suppress adapter notification&n; *&n; *&t;Gets the next free QE off the requested priorty adapter command&n; *&t;queue and associates the Fib with the QE. The QE represented by&n; *&t;index is ready to insert on the queue when this routine returns&n; *&t;success.&n; */
DECL|function|aac_insert_entry
r_static
r_int
id|aac_insert_entry
c_func
(paren
r_struct
id|aac_dev
op_star
id|dev
comma
id|u32
id|index
comma
id|u32
id|qid
comma
r_int
r_int
id|nonotify
)paren
(brace
r_struct
id|aac_queue
op_star
id|q
op_assign
op_amp
id|dev-&gt;queues-&gt;queue
(braket
id|qid
)braket
suffix:semicolon
r_if
c_cond
(paren
id|q
op_eq
l_int|NULL
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
op_star
(paren
id|q-&gt;headers.producer
)paren
op_assign
id|cpu_to_le32
c_func
(paren
id|index
op_plus
l_int|1
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|q-&gt;lock
comma
id|q-&gt;SavedIrql
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qid
op_eq
id|AdapHighCmdQueue
op_logical_or
id|qid
op_eq
id|AdapNormCmdQueue
op_logical_or
id|qid
op_eq
id|AdapHighRespQueue
op_logical_or
id|qid
op_eq
id|AdapNormRespQueue
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|nonotify
)paren
id|aac_adapter_notify
c_func
(paren
id|dev
comma
id|qid
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;Suprise insert!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Define the highest level of host to adapter communication routines. &n; *&t;These routines will support host to adapter FS commuication. These &n; *&t;routines have no knowledge of the commuication method used. This level&n; *&t;sends and receives FIBs. This level has no knowledge of how these FIBs&n; *&t;get passed back and forth.&n; */
multiline_comment|/**&n; *&t;fib_send&t;-&t;send a fib to the adapter&n; *&t;@command: Command to send&n; *&t;@fibptr: The fib&n; *&t;@size: Size of fib data area&n; *&t;@priority: Priority of Fib&n; *&t;@wait: Async/sync select&n; *&t;@reply: True if a reply is wanted&n; *&t;@callback: Called with reply&n; *&t;@callback_data: Passed to callback&n; *&n; *&t;Sends the requested FIB to the adapter and optionally will wait for a&n; *&t;response FIB. If the caller does not wish to wait for a response than&n; *&t;an event to wait on must be supplied. This event will be set when a&n; *&t;response FIB is received from the adapter.&n; */
DECL|function|fib_send
r_int
id|fib_send
c_func
(paren
id|u16
id|command
comma
r_struct
id|fib
op_star
id|fibptr
comma
r_int
r_int
id|size
comma
r_int
id|priority
comma
r_int
id|wait
comma
r_int
id|reply
comma
id|fib_callback
id|callback
comma
r_void
op_star
id|callback_data
)paren
(brace
id|u32
id|index
suffix:semicolon
id|u32
id|qid
suffix:semicolon
r_struct
id|aac_dev
op_star
id|dev
op_assign
id|fibptr-&gt;dev
suffix:semicolon
r_int
r_int
id|nointr
op_assign
l_int|0
suffix:semicolon
r_struct
id|hw_fib
op_star
id|hw_fib
op_assign
id|fibptr-&gt;hw_fib
suffix:semicolon
r_struct
id|aac_queue
op_star
id|q
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|le32_to_cpu
c_func
(paren
id|hw_fib-&gt;header.XferState
)paren
op_amp
id|HostOwned
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/*&n;&t; *&t;There are 5 cases with the wait and reponse requested flags. &n;&t; *&t;The only invalid cases are if the caller requests to wait and&n;&t; *&t;does not request a response and if the caller does not want a&n;&t; *&t;response and the Fibis not allocated from pool. If a response&n;&t; *&t;is not requesed the Fib will just be deallocaed by the DPC&n;&t; *&t;routine when the response comes back from the adapter. No&n;&t; *&t;further processing will be done besides deleting the Fib. We &n;&t; *&t;will have a debug mode where the adapter can notify the host&n;&t; *&t;it had a problem and the host can log that fact.&n;&t; */
r_if
c_cond
(paren
id|wait
op_logical_and
op_logical_neg
id|reply
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|wait
op_logical_and
id|reply
)paren
(brace
id|hw_fib-&gt;header.XferState
op_or_assign
id|cpu_to_le32
c_func
(paren
id|Async
op_or
id|ResponseExpected
)paren
suffix:semicolon
id|FIB_COUNTER_INCREMENT
c_func
(paren
id|aac_config.AsyncSent
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|wait
op_logical_and
op_logical_neg
id|reply
)paren
(brace
id|hw_fib-&gt;header.XferState
op_or_assign
id|cpu_to_le32
c_func
(paren
id|NoResponseExpected
)paren
suffix:semicolon
id|FIB_COUNTER_INCREMENT
c_func
(paren
id|aac_config.NoResponseSent
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|wait
op_logical_and
id|reply
)paren
(brace
id|hw_fib-&gt;header.XferState
op_or_assign
id|cpu_to_le32
c_func
(paren
id|ResponseExpected
)paren
suffix:semicolon
id|FIB_COUNTER_INCREMENT
c_func
(paren
id|aac_config.NormalSent
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Map the fib into 32bits by using the fib number&n;&t; */
id|hw_fib-&gt;header.SenderFibAddress
op_assign
id|cpu_to_le32
c_func
(paren
(paren
(paren
id|u32
)paren
(paren
id|fibptr
op_minus
id|dev-&gt;fibs
)paren
)paren
op_lshift
l_int|1
)paren
suffix:semicolon
id|hw_fib-&gt;header.SenderData
op_assign
(paren
id|u32
)paren
(paren
id|fibptr
op_minus
id|dev-&gt;fibs
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Set FIB state to indicate where it came from and if we want a&n;&t; *&t;response from the adapter. Also load the command from the&n;&t; *&t;caller.&n;&t; *&n;&t; *&t;Map the hw fib pointer as a 32bit value&n;&t; */
id|hw_fib-&gt;header.Command
op_assign
id|cpu_to_le16
c_func
(paren
id|command
)paren
suffix:semicolon
id|hw_fib-&gt;header.XferState
op_or_assign
id|cpu_to_le32
c_func
(paren
id|SentFromHost
)paren
suffix:semicolon
id|fibptr-&gt;hw_fib-&gt;header.Flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 0 the flags field - internal only*/
multiline_comment|/*&n;&t; *&t;Set the size of the Fib we want to send to the adapter&n;&t; */
id|hw_fib-&gt;header.Size
op_assign
id|cpu_to_le16
c_func
(paren
r_sizeof
(paren
r_struct
id|aac_fibhdr
)paren
op_plus
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|hw_fib-&gt;header.Size
)paren
OG
id|le16_to_cpu
c_func
(paren
id|hw_fib-&gt;header.SenderSize
)paren
)paren
(brace
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Get a queue entry connect the FIB to it and send an notify&n;&t; *&t;the adapter a command is ready.&n;&t; */
r_if
c_cond
(paren
id|priority
op_eq
id|FsaHigh
)paren
(brace
id|hw_fib-&gt;header.XferState
op_or_assign
id|cpu_to_le32
c_func
(paren
id|HighPriority
)paren
suffix:semicolon
id|qid
op_assign
id|AdapHighCmdQueue
suffix:semicolon
)brace
r_else
(brace
id|hw_fib-&gt;header.XferState
op_or_assign
id|cpu_to_le32
c_func
(paren
id|NormalPriority
)paren
suffix:semicolon
id|qid
op_assign
id|AdapNormCmdQueue
suffix:semicolon
)brace
id|q
op_assign
op_amp
id|dev-&gt;queues-&gt;queue
(braket
id|qid
)braket
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|fibptr-&gt;event_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aac_queue_get
c_func
(paren
id|dev
comma
op_amp
id|index
comma
id|qid
comma
id|hw_fib
comma
l_int|1
comma
id|fibptr
comma
op_amp
id|nointr
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EWOULDBLOCK
suffix:semicolon
)brace
id|dprintk
c_func
(paren
(paren
id|KERN_DEBUG
l_string|&quot;fib_send: inserting a queue entry at index %d.&bslash;n&quot;
comma
id|index
)paren
)paren
suffix:semicolon
id|dprintk
c_func
(paren
(paren
id|KERN_DEBUG
l_string|&quot;Fib contents:.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|dprintk
c_func
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  Command =               %d.&bslash;n&quot;
comma
id|hw_fib-&gt;header.Command
)paren
)paren
suffix:semicolon
id|dprintk
c_func
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  XferState  =            %x.&bslash;n&quot;
comma
id|hw_fib-&gt;header.XferState
)paren
)paren
suffix:semicolon
id|dprintk
c_func
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  hw_fib va being sent=%p&bslash;n&quot;
comma
id|fibptr-&gt;hw_fib
)paren
)paren
suffix:semicolon
id|dprintk
c_func
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  hw_fib pa being sent=%lx&bslash;n&quot;
comma
(paren
id|ulong
)paren
id|fibptr-&gt;hw_fib_pa
)paren
)paren
suffix:semicolon
id|dprintk
c_func
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  fib being sent=%p&bslash;n&quot;
comma
id|fibptr
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Fill in the Callback and CallbackContext if we are not&n;&t; *&t;going to wait.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|wait
)paren
(brace
id|fibptr-&gt;callback
op_assign
id|callback
suffix:semicolon
id|fibptr-&gt;callback_data
op_assign
id|callback_data
suffix:semicolon
)brace
id|FIB_COUNTER_INCREMENT
c_func
(paren
id|aac_config.FibsSent
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|fibptr-&gt;queue
comma
op_amp
id|q-&gt;pendingq
)paren
suffix:semicolon
id|q-&gt;numpending
op_increment
suffix:semicolon
id|fibptr-&gt;done
op_assign
l_int|0
suffix:semicolon
id|fibptr-&gt;flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|aac_insert_entry
c_func
(paren
id|dev
comma
id|index
comma
id|qid
comma
(paren
id|nointr
op_amp
id|aac_config.irq_mod
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EWOULDBLOCK
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;If the caller wanted us to wait for response wait now. &n;&t; */
r_if
c_cond
(paren
id|wait
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|fibptr-&gt;event_lock
comma
id|flags
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|fibptr-&gt;event_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fibptr-&gt;done
op_eq
l_int|0
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|fibptr-&gt;flags
op_amp
id|FIB_CONTEXT_FLAG_TIMED_OUT
)paren
)paren
(brace
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;If the user does not want a response than return success otherwise&n;&t; *&t;return pending&n;&t; */
r_if
c_cond
(paren
id|reply
)paren
r_return
op_minus
id|EINPROGRESS
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/** &n; *&t;aac_consumer_get&t;-&t;get the top of the queue&n; *&t;@dev: Adapter&n; *&t;@q: Queue&n; *&t;@entry: Return entry&n; *&n; *&t;Will return a pointer to the entry on the top of the queue requested that&n; * &t;we are a consumer of, and return the address of the queue entry. It does&n; *&t;not change the state of the queue. &n; */
DECL|function|aac_consumer_get
r_int
id|aac_consumer_get
c_func
(paren
r_struct
id|aac_dev
op_star
id|dev
comma
r_struct
id|aac_queue
op_star
id|q
comma
r_struct
id|aac_entry
op_star
op_star
id|entry
)paren
(brace
id|u32
id|index
suffix:semicolon
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
op_star
id|q-&gt;headers.producer
)paren
op_eq
id|le32_to_cpu
c_func
(paren
op_star
id|q-&gt;headers.consumer
)paren
)paren
(brace
id|status
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; *&t;The consumer index must be wrapped if we have reached&n;&t;&t; *&t;the end of the queue, else we just use the entry&n;&t;&t; *&t;pointed to by the header index&n;&t;&t; */
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
op_star
id|q-&gt;headers.consumer
)paren
op_ge
id|q-&gt;entries
)paren
id|index
op_assign
l_int|0
suffix:semicolon
r_else
id|index
op_assign
id|le32_to_cpu
c_func
(paren
op_star
id|q-&gt;headers.consumer
)paren
suffix:semicolon
op_star
id|entry
op_assign
id|q-&gt;base
op_plus
id|index
suffix:semicolon
id|status
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
DECL|function|aac_consumer_avail
r_int
id|aac_consumer_avail
c_func
(paren
r_struct
id|aac_dev
op_star
id|dev
comma
r_struct
id|aac_queue
op_star
id|q
)paren
(brace
r_return
(paren
id|le32_to_cpu
c_func
(paren
op_star
id|q-&gt;headers.producer
)paren
op_ne
id|le32_to_cpu
c_func
(paren
op_star
id|q-&gt;headers.consumer
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;aac_consumer_free&t;-&t;free consumer entry&n; *&t;@dev: Adapter&n; *&t;@q: Queue&n; *&t;@qid: Queue ident&n; *&n; *&t;Frees up the current top of the queue we are a consumer of. If the&n; *&t;queue was full notify the producer that the queue is no longer full.&n; */
DECL|function|aac_consumer_free
r_void
id|aac_consumer_free
c_func
(paren
r_struct
id|aac_dev
op_star
id|dev
comma
r_struct
id|aac_queue
op_star
id|q
comma
id|u32
id|qid
)paren
(brace
r_int
id|wasfull
op_assign
l_int|0
suffix:semicolon
id|u32
id|notify
suffix:semicolon
r_if
c_cond
(paren
(paren
id|le32_to_cpu
c_func
(paren
op_star
id|q-&gt;headers.producer
)paren
op_plus
l_int|1
)paren
op_eq
id|le32_to_cpu
c_func
(paren
op_star
id|q-&gt;headers.consumer
)paren
)paren
id|wasfull
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
op_star
id|q-&gt;headers.consumer
)paren
op_ge
id|q-&gt;entries
)paren
op_star
id|q-&gt;headers.consumer
op_assign
id|cpu_to_le32
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_else
op_star
id|q-&gt;headers.consumer
op_assign
id|cpu_to_le32
c_func
(paren
id|le32_to_cpu
c_func
(paren
op_star
id|q-&gt;headers.consumer
)paren
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wasfull
)paren
(brace
r_switch
c_cond
(paren
id|qid
)paren
(brace
r_case
id|HostNormCmdQueue
suffix:colon
id|notify
op_assign
id|HostNormCmdNotFull
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HostHighCmdQueue
suffix:colon
id|notify
op_assign
id|HostHighCmdNotFull
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HostNormRespQueue
suffix:colon
id|notify
op_assign
id|HostNormRespNotFull
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HostHighRespQueue
suffix:colon
id|notify
op_assign
id|HostHighRespNotFull
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|aac_adapter_notify
c_func
(paren
id|dev
comma
id|notify
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;fib_adapter_complete&t;-&t;complete adapter issued fib&n; *&t;@fibptr: fib to complete&n; *&t;@size: size of fib&n; *&n; *&t;Will do all necessary work to complete a FIB that was sent from&n; *&t;the adapter.&n; */
DECL|function|fib_adapter_complete
r_int
id|fib_adapter_complete
c_func
(paren
r_struct
id|fib
op_star
id|fibptr
comma
r_int
r_int
id|size
)paren
(brace
r_struct
id|hw_fib
op_star
id|hw_fib
op_assign
id|fibptr-&gt;hw_fib
suffix:semicolon
r_struct
id|aac_dev
op_star
id|dev
op_assign
id|fibptr-&gt;dev
suffix:semicolon
r_int
r_int
id|nointr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|hw_fib-&gt;header.XferState
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If we plan to do anything check the structure type first.&n;&t; */
r_if
c_cond
(paren
id|hw_fib-&gt;header.StructType
op_ne
id|FIB_MAGIC
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;This block handles the case where the adapter had sent us a&n;&t; *&t;command and we have finished processing the command. We&n;&t; *&t;call completeFib when we are done processing the command &n;&t; *&t;and want to send a response back to the adapter. This will &n;&t; *&t;send the completed cdb to the adapter.&n;&t; */
r_if
c_cond
(paren
id|hw_fib-&gt;header.XferState
op_amp
id|cpu_to_le32
c_func
(paren
id|SentFromAdapter
)paren
)paren
(brace
id|hw_fib-&gt;header.XferState
op_or_assign
id|cpu_to_le32
c_func
(paren
id|HostProcessed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hw_fib-&gt;header.XferState
op_amp
id|cpu_to_le32
c_func
(paren
id|HighPriority
)paren
)paren
(brace
id|u32
id|index
suffix:semicolon
r_if
c_cond
(paren
id|size
)paren
(brace
id|size
op_add_assign
r_sizeof
(paren
r_struct
id|aac_fibhdr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|le16_to_cpu
c_func
(paren
id|hw_fib-&gt;header.SenderSize
)paren
)paren
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
id|hw_fib-&gt;header.Size
op_assign
id|cpu_to_le16
c_func
(paren
id|size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aac_queue_get
c_func
(paren
id|dev
comma
op_amp
id|index
comma
id|AdapHighRespQueue
comma
id|hw_fib
comma
l_int|1
comma
l_int|NULL
comma
op_amp
id|nointr
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EWOULDBLOCK
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aac_insert_entry
c_func
(paren
id|dev
comma
id|index
comma
id|AdapHighRespQueue
comma
(paren
id|nointr
op_amp
(paren
r_int
)paren
id|aac_config.irq_mod
)paren
)paren
op_ne
l_int|0
)paren
(brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|hw_fib-&gt;header.XferState
op_amp
id|NormalPriority
)paren
(brace
id|u32
id|index
suffix:semicolon
r_if
c_cond
(paren
id|size
)paren
(brace
id|size
op_add_assign
r_sizeof
(paren
r_struct
id|aac_fibhdr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|le16_to_cpu
c_func
(paren
id|hw_fib-&gt;header.SenderSize
)paren
)paren
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
id|hw_fib-&gt;header.Size
op_assign
id|cpu_to_le16
c_func
(paren
id|size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aac_queue_get
c_func
(paren
id|dev
comma
op_amp
id|index
comma
id|AdapNormRespQueue
comma
id|hw_fib
comma
l_int|1
comma
l_int|NULL
comma
op_amp
id|nointr
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EWOULDBLOCK
suffix:semicolon
r_if
c_cond
(paren
id|aac_insert_entry
c_func
(paren
id|dev
comma
id|index
comma
id|AdapNormRespQueue
comma
(paren
id|nointr
op_amp
(paren
r_int
)paren
id|aac_config.irq_mod
)paren
)paren
op_ne
l_int|0
)paren
(brace
)brace
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;fib_adapter_complete: Unknown xferstate detected.&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;fib_complete&t;-&t;fib completion handler&n; *&t;@fib: FIB to complete&n; *&n; *&t;Will do all necessary work to complete a FIB.&n; */
DECL|function|fib_complete
r_int
id|fib_complete
c_func
(paren
r_struct
id|fib
op_star
id|fibptr
)paren
(brace
r_struct
id|hw_fib
op_star
id|hw_fib
op_assign
id|fibptr-&gt;hw_fib
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Check for a fib which has already been completed&n;&t; */
r_if
c_cond
(paren
id|hw_fib-&gt;header.XferState
op_eq
id|cpu_to_le32
c_func
(paren
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If we plan to do anything check the structure type first.&n;&t; */
r_if
c_cond
(paren
id|hw_fib-&gt;header.StructType
op_ne
id|FIB_MAGIC
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; *&t;This block completes a cdb which orginated on the host and we &n;&t; *&t;just need to deallocate the cdb or reinit it. At this point the&n;&t; *&t;command is complete that we had sent to the adapter and this&n;&t; *&t;cdb could be reused.&n;&t; */
r_if
c_cond
(paren
(paren
id|hw_fib-&gt;header.XferState
op_amp
id|cpu_to_le32
c_func
(paren
id|SentFromHost
)paren
)paren
op_logical_and
(paren
id|hw_fib-&gt;header.XferState
op_amp
id|cpu_to_le32
c_func
(paren
id|AdapterProcessed
)paren
)paren
)paren
(brace
id|fib_dealloc
c_func
(paren
id|fibptr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hw_fib-&gt;header.XferState
op_amp
id|cpu_to_le32
c_func
(paren
id|SentFromHost
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;This handles the case when the host has aborted the I/O&n;&t;&t; *&t;to the adapter because the adapter is not responding&n;&t;&t; */
id|fib_dealloc
c_func
(paren
id|fibptr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hw_fib-&gt;header.XferState
op_amp
id|cpu_to_le32
c_func
(paren
id|HostOwned
)paren
)paren
(brace
id|fib_dealloc
c_func
(paren
id|fibptr
)paren
suffix:semicolon
)brace
r_else
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;aac_printf&t;-&t;handle printf from firmware&n; *&t;@dev: Adapter&n; *&t;@val: Message info&n; *&n; *&t;Print a message passed to us by the controller firmware on the&n; *&t;Adaptec board&n; */
DECL|function|aac_printf
r_void
id|aac_printf
c_func
(paren
r_struct
id|aac_dev
op_star
id|dev
comma
id|u32
id|val
)paren
(brace
r_int
id|length
op_assign
id|val
op_amp
l_int|0xffff
suffix:semicolon
r_int
id|level
op_assign
(paren
id|val
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
suffix:semicolon
r_char
op_star
id|cp
op_assign
id|dev-&gt;printfbuf
suffix:semicolon
multiline_comment|/*&n;&t; *&t;The size of the printfbuf is set in port.c&n;&t; *&t;There is no variable or define for it&n;&t; */
r_if
c_cond
(paren
id|length
OG
l_int|255
)paren
id|length
op_assign
l_int|255
suffix:semicolon
r_if
c_cond
(paren
id|cp
(braket
id|length
)braket
op_ne
l_int|0
)paren
id|cp
(braket
id|length
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
id|LOG_AAC_HIGH_ERROR
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;aacraid:%s&quot;
comma
id|cp
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;aacraid:%s&quot;
comma
id|cp
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cp
comma
l_int|0
comma
l_int|256
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;aac_command_thread&t;-&t;command processing thread&n; *&t;@dev: Adapter to monitor&n; *&n; *&t;Waits on the commandready event in it&squot;s queue. When the event gets set&n; *&t;it will pull FIBs off it&squot;s queue. It will continue to pull FIBs off&n; *&t;until the queue is empty. When the queue is empty it will wait for&n; *&t;more FIBs.&n; */
DECL|function|aac_command_thread
r_int
id|aac_command_thread
c_func
(paren
r_struct
id|aac_dev
op_star
id|dev
)paren
(brace
r_struct
id|hw_fib
op_star
id|hw_fib
comma
op_star
id|hw_newfib
suffix:semicolon
r_struct
id|fib
op_star
id|fib
comma
op_star
id|newfib
suffix:semicolon
r_struct
id|aac_queue_block
op_star
id|queues
op_assign
id|dev-&gt;queues
suffix:semicolon
r_struct
id|aac_fib_context
op_star
id|fibctx
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We can only have one thread per adapter for AIF&squot;s.&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;aif_thread
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Set up the name that will appear in &squot;ps&squot;&n;&t; *&t;stored in  task_struct.comm[16].&n;&t; */
id|daemonize
c_func
(paren
l_string|&quot;aacraid&quot;
)paren
suffix:semicolon
id|allow_signal
c_func
(paren
id|SIGKILL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Let the DPC know it has a place to send the AIF&squot;s to.&n;&t; */
id|dev-&gt;aif_thread
op_assign
l_int|1
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|queues-&gt;queue
(braket
id|HostNormCmdQueue
)braket
dot
id|cmdready
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
id|queues-&gt;queue
(braket
id|HostNormCmdQueue
)braket
dot
id|lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
(paren
id|queues-&gt;queue
(braket
id|HostNormCmdQueue
)braket
dot
id|cmdq
)paren
)paren
)paren
(brace
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
r_struct
id|aac_aifcmd
op_star
id|aifcmd
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|entry
op_assign
id|queues-&gt;queue
(braket
id|HostNormCmdQueue
)braket
dot
id|cmdq.next
suffix:semicolon
id|list_del
c_func
(paren
id|entry
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|queues-&gt;queue
(braket
id|HostNormCmdQueue
)braket
dot
id|lock
comma
id|flags
)paren
suffix:semicolon
id|fib
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|fib
comma
id|fiblink
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;We will process the FIB here or pass it to a &n;&t;&t;&t; *&t;worker thread that is TBD. We Really can&squot;t &n;&t;&t;&t; *&t;do anything at this point since we don&squot;t have&n;&t;&t;&t; *&t;anything defined for this thread to do.&n;&t;&t;&t; */
id|hw_fib
op_assign
id|fib-&gt;hw_fib
suffix:semicolon
id|memset
c_func
(paren
id|fib
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|fib
)paren
)paren
suffix:semicolon
id|fib-&gt;type
op_assign
id|FSAFS_NTC_FIB_CONTEXT
suffix:semicolon
id|fib-&gt;size
op_assign
r_sizeof
(paren
r_struct
id|fib
)paren
suffix:semicolon
id|fib-&gt;hw_fib
op_assign
id|hw_fib
suffix:semicolon
id|fib-&gt;data
op_assign
id|hw_fib-&gt;data
suffix:semicolon
id|fib-&gt;dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;We only handle AifRequest fibs from the adapter.&n;&t;&t;&t; */
id|aifcmd
op_assign
(paren
r_struct
id|aac_aifcmd
op_star
)paren
id|hw_fib-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|aifcmd-&gt;command
op_eq
id|cpu_to_le32
c_func
(paren
id|AifCmdDriverNotify
)paren
)paren
(brace
multiline_comment|/* Handle Driver Notify Events */
op_star
(paren
id|u32
op_star
)paren
id|hw_fib-&gt;data
op_assign
id|cpu_to_le32
c_func
(paren
id|ST_OK
)paren
suffix:semicolon
id|fib_adapter_complete
c_func
(paren
id|fib
comma
r_sizeof
(paren
id|u32
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
multiline_comment|/* The u32 here is important and intended. We are using&n;&t;&t;&t;&t;   32bit wrapping time to fit the adapter field */
id|u32
id|time_now
comma
id|time_last
suffix:semicolon
r_int
r_int
id|flagv
suffix:semicolon
id|time_now
op_assign
id|jiffies
op_div
id|HZ
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|dev-&gt;fib_lock
comma
id|flagv
)paren
suffix:semicolon
id|entry
op_assign
id|dev-&gt;fib_list.next
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * For each Context that is on the &n;&t;&t;&t;&t; * fibctxList, make a copy of the&n;&t;&t;&t;&t; * fib, and then set the event to wake up the&n;&t;&t;&t;&t; * thread that is waiting for it.&n;&t;&t;&t;&t; */
r_while
c_loop
(paren
id|entry
op_ne
op_amp
id|dev-&gt;fib_list
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Extract the fibctx&n;&t;&t;&t;&t;&t; */
id|fibctx
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|aac_fib_context
comma
id|next
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Check if the queue is getting&n;&t;&t;&t;&t;&t; * backlogged&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|fibctx-&gt;count
OG
l_int|20
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * It&squot;s *not* jiffies folks,&n;&t;&t;&t;&t;&t;&t; * but jiffies / HZ so do not&n;&t;&t;&t;&t;&t;&t; * panic ...&n;&t;&t;&t;&t;&t;&t; */
id|time_last
op_assign
id|fibctx-&gt;jiffies
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Has it been &gt; 2 minutes &n;&t;&t;&t;&t;&t;&t; * since the last read off&n;&t;&t;&t;&t;&t;&t; * the queue?&n;&t;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|time_now
op_minus
id|time_last
)paren
OG
l_int|120
)paren
(brace
id|entry
op_assign
id|entry-&gt;next
suffix:semicolon
id|aac_close_fib_context
c_func
(paren
id|dev
comma
id|fibctx
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Warning: no sleep allowed while&n;&t;&t;&t;&t;&t; * holding spinlock&n;&t;&t;&t;&t;&t; */
id|hw_newfib
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|hw_fib
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|newfib
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|fib
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newfib
op_logical_and
id|hw_newfib
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Make the copy of the FIB&n;&t;&t;&t;&t;&t;&t; */
id|memcpy
c_func
(paren
id|hw_newfib
comma
id|hw_fib
comma
r_sizeof
(paren
r_struct
id|hw_fib
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|newfib
comma
id|fib
comma
r_sizeof
(paren
r_struct
id|fib
)paren
)paren
suffix:semicolon
id|newfib-&gt;hw_fib
op_assign
id|hw_newfib
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Put the FIB onto the&n;&t;&t;&t;&t;&t;&t; * fibctx&squot;s fibs&n;&t;&t;&t;&t;&t;&t; */
id|list_add_tail
c_func
(paren
op_amp
id|newfib-&gt;fiblink
comma
op_amp
id|fibctx-&gt;fib_list
)paren
suffix:semicolon
id|fibctx-&gt;count
op_increment
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t; * Set the event to wake up the&n;&t;&t;&t;&t;&t;&t; * thread that will waiting.&n;&t;&t;&t;&t;&t;&t; */
id|up
c_func
(paren
op_amp
id|fibctx-&gt;wait_sem
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;aifd: didn&squot;t allocate NewFib.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newfib
)paren
(brace
id|kfree
c_func
(paren
id|newfib
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hw_newfib
)paren
(brace
id|kfree
c_func
(paren
id|hw_newfib
)paren
suffix:semicolon
)brace
)brace
id|entry
op_assign
id|entry-&gt;next
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Set the status of this FIB&n;&t;&t;&t;&t; */
op_star
(paren
id|u32
op_star
)paren
id|hw_fib-&gt;data
op_assign
id|cpu_to_le32
c_func
(paren
id|ST_OK
)paren
suffix:semicolon
id|fib_adapter_complete
c_func
(paren
id|fib
comma
r_sizeof
(paren
id|u32
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dev-&gt;fib_lock
comma
id|flagv
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
id|queues-&gt;queue
(braket
id|HostNormCmdQueue
)braket
dot
id|lock
comma
id|flags
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|fib
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;There are no more AIF&squot;s&n;&t;&t; */
id|spin_unlock_irqrestore
c_func
(paren
id|queues-&gt;queue
(braket
id|HostNormCmdQueue
)braket
dot
id|lock
comma
id|flags
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|queues-&gt;queue
(braket
id|HostNormCmdQueue
)braket
dot
id|cmdready
comma
op_amp
id|wait
)paren
suffix:semicolon
id|dev-&gt;aif_thread
op_assign
l_int|0
suffix:semicolon
id|complete_and_exit
c_func
(paren
op_amp
id|dev-&gt;aif_completion
comma
l_int|0
)paren
suffix:semicolon
)brace
eof
