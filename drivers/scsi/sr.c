multiline_comment|/*&n; *  sr.c Copyright (C) 1992 David Giller&n; *           Copyright (C) 1993, 1994, 1995, 1999 Eric Youngdale&n; *&n; *  adapted from:&n; *      sd.c Copyright (C) 1992 Drew Eckhardt&n; *      Linux scsi disk driver by&n; *              Drew Eckhardt &lt;drew@colorado.edu&gt;&n; *&n; *&t;Modified by Eric Youngdale ericy@andante.org to&n; *&t;add scatter-gather, multiple outstanding request, and other&n; *&t;enhancements.&n; *&n; *      Modified by Eric Youngdale eric@andante.org to support loadable&n; *      low-level scsi drivers.&n; *&n; *      Modified by Thomas Quinot thomas@melchior.cuivre.fdn.fr to&n; *      provide auto-eject.&n; *&n; *      Modified by Gerd Knorr &lt;kraxel@cs.tu-berlin.de&gt; to support the&n; *      generic cdrom interface&n; *&n; *      Modified by Jens Axboe &lt;axboe@suse.de&gt; - Uniform sr_packet()&n; *      interface, capabilities probe additions, ioctl cleanups, etc.&n; *&n; *&t;Modified by Richard Gooch &lt;rgooch@atnf.csiro.au&gt; to support devfs&n; *&n; *&t;Modified by Jens Axboe &lt;axboe@suse.de&gt; - support DVD-RAM&n; *&t;transparently and lose the GHOST hack&n; *&n; *&t;Modified by Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt;&n; *&t;check resource allocation in sr_init and some cleanups&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;scsi/scsi.h&gt;
macro_line|#include &lt;scsi/scsi_dbg.h&gt;
macro_line|#include &lt;scsi/scsi_device.h&gt;
macro_line|#include &lt;scsi/scsi_driver.h&gt;
macro_line|#include &lt;scsi/scsi_eh.h&gt;
macro_line|#include &lt;scsi/scsi_host.h&gt;
macro_line|#include &lt;scsi/scsi_ioctl.h&gt;&t;/* For the door lock/unlock commands */
macro_line|#include &lt;scsi/scsi_request.h&gt;
macro_line|#include &quot;scsi_logging.h&quot;
macro_line|#include &quot;sr.h&quot;
DECL|macro|SR_DISKS
mdefine_line|#define SR_DISKS&t;256
DECL|macro|MAX_RETRIES
mdefine_line|#define MAX_RETRIES&t;3
DECL|macro|SR_TIMEOUT
mdefine_line|#define SR_TIMEOUT&t;(30 * HZ)
DECL|macro|SR_CAPABILITIES
mdefine_line|#define SR_CAPABILITIES &bslash;&n;&t;(CDC_CLOSE_TRAY|CDC_OPEN_TRAY|CDC_LOCK|CDC_SELECT_SPEED| &bslash;&n;&t; CDC_SELECT_DISC|CDC_MULTI_SESSION|CDC_MCN|CDC_MEDIA_CHANGED| &bslash;&n;&t; CDC_PLAY_AUDIO|CDC_RESET|CDC_IOCTLS|CDC_DRIVE_STATUS| &bslash;&n;&t; CDC_CD_R|CDC_CD_RW|CDC_DVD|CDC_DVD_R|CDC_DVD_RAM|CDC_GENERIC_PACKET| &bslash;&n;&t; CDC_MRW|CDC_MRW_W|CDC_RAM)
r_static
r_int
id|sr_probe
c_func
(paren
r_struct
id|device
op_star
)paren
suffix:semicolon
r_static
r_int
id|sr_remove
c_func
(paren
r_struct
id|device
op_star
)paren
suffix:semicolon
r_static
r_int
id|sr_init_command
c_func
(paren
r_struct
id|scsi_cmnd
op_star
)paren
suffix:semicolon
DECL|variable|sr_template
r_static
r_struct
id|scsi_driver
id|sr_template
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|gendrv
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;sr&quot;
comma
dot
id|probe
op_assign
id|sr_probe
comma
dot
id|remove
op_assign
id|sr_remove
comma
)brace
comma
dot
id|init_command
op_assign
id|sr_init_command
comma
)brace
suffix:semicolon
DECL|variable|sr_index_bits
r_static
r_int
r_int
id|sr_index_bits
(braket
id|SR_DISKS
op_div
id|BITS_PER_LONG
)braket
suffix:semicolon
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|sr_index_lock
)paren
suffix:semicolon
multiline_comment|/* This semaphore is used to mediate the 0-&gt;1 reference get in the&n; * face of object destruction (i.e. we can&squot;t allow a get on an&n; * object after last put) */
r_static
id|DECLARE_MUTEX
c_func
(paren
id|sr_ref_sem
)paren
suffix:semicolon
r_static
r_int
id|sr_open
c_func
(paren
r_struct
id|cdrom_device_info
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|sr_release
c_func
(paren
r_struct
id|cdrom_device_info
op_star
)paren
suffix:semicolon
r_static
r_void
id|get_sectorsize
c_func
(paren
r_struct
id|scsi_cd
op_star
)paren
suffix:semicolon
r_static
r_void
id|get_capabilities
c_func
(paren
r_struct
id|scsi_cd
op_star
)paren
suffix:semicolon
r_static
r_int
id|sr_media_change
c_func
(paren
r_struct
id|cdrom_device_info
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|sr_packet
c_func
(paren
r_struct
id|cdrom_device_info
op_star
comma
r_struct
id|packet_command
op_star
)paren
suffix:semicolon
DECL|variable|sr_dops
r_static
r_struct
id|cdrom_device_ops
id|sr_dops
op_assign
(brace
dot
id|open
op_assign
id|sr_open
comma
dot
id|release
op_assign
id|sr_release
comma
dot
id|drive_status
op_assign
id|sr_drive_status
comma
dot
id|media_changed
op_assign
id|sr_media_change
comma
dot
id|tray_move
op_assign
id|sr_tray_move
comma
dot
id|lock_door
op_assign
id|sr_lock_door
comma
dot
id|select_speed
op_assign
id|sr_select_speed
comma
dot
id|get_last_session
op_assign
id|sr_get_last_session
comma
dot
id|get_mcn
op_assign
id|sr_get_mcn
comma
dot
id|reset
op_assign
id|sr_reset
comma
dot
id|audio_ioctl
op_assign
id|sr_audio_ioctl
comma
dot
id|dev_ioctl
op_assign
id|sr_dev_ioctl
comma
dot
id|capability
op_assign
id|SR_CAPABILITIES
comma
dot
id|generic_packet
op_assign
id|sr_packet
comma
)brace
suffix:semicolon
r_static
r_void
id|sr_kref_release
c_func
(paren
r_struct
id|kref
op_star
id|kref
)paren
suffix:semicolon
DECL|function|scsi_cd
r_static
r_inline
r_struct
id|scsi_cd
op_star
id|scsi_cd
c_func
(paren
r_struct
id|gendisk
op_star
id|disk
)paren
(brace
r_return
id|container_of
c_func
(paren
id|disk-&gt;private_data
comma
r_struct
id|scsi_cd
comma
id|driver
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The get and put routines for the struct scsi_cd.  Note this entity&n; * has a scsi_device pointer and owns a reference to this.&n; */
DECL|function|scsi_cd_get
r_static
r_inline
r_struct
id|scsi_cd
op_star
id|scsi_cd_get
c_func
(paren
r_struct
id|gendisk
op_star
id|disk
)paren
(brace
r_struct
id|scsi_cd
op_star
id|cd
op_assign
l_int|NULL
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sr_ref_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|disk-&gt;private_data
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
id|cd
op_assign
id|scsi_cd
c_func
(paren
id|disk
)paren
suffix:semicolon
id|kref_get
c_func
(paren
op_amp
id|cd-&gt;kref
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_device_get
c_func
(paren
id|cd-&gt;device
)paren
)paren
r_goto
id|out_put
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|out_put
suffix:colon
id|kref_put
c_func
(paren
op_amp
id|cd-&gt;kref
comma
id|sr_kref_release
)paren
suffix:semicolon
id|cd
op_assign
l_int|NULL
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|sr_ref_sem
)paren
suffix:semicolon
r_return
id|cd
suffix:semicolon
)brace
DECL|function|scsi_cd_put
r_static
r_inline
r_void
id|scsi_cd_put
c_func
(paren
r_struct
id|scsi_cd
op_star
id|cd
)paren
(brace
id|down
c_func
(paren
op_amp
id|sr_ref_sem
)paren
suffix:semicolon
id|kref_put
c_func
(paren
op_amp
id|cd-&gt;kref
comma
id|sr_kref_release
)paren
suffix:semicolon
id|scsi_device_put
c_func
(paren
id|cd-&gt;device
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|sr_ref_sem
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function checks to see if the media has been changed in the&n; * CDROM drive.  It is possible that we have already sensed a change,&n; * or the drive may have sensed one and not yet reported it.  We must&n; * be ready for either case. This function always reports the current&n; * value of the changed bit.  If flag is 0, then the changed bit is reset.&n; * This function could be done as an ioctl, but we would need to have&n; * an inode for that to work, and we do not always have one.&n; */
DECL|function|sr_media_change
r_int
id|sr_media_change
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|slot
)paren
(brace
r_struct
id|scsi_cd
op_star
id|cd
op_assign
id|cdi-&gt;handle
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|CDSL_CURRENT
op_ne
id|slot
)paren
(brace
multiline_comment|/* no changer support */
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|retval
op_assign
id|scsi_test_unit_ready
c_func
(paren
id|cd-&gt;device
comma
id|SR_TIMEOUT
comma
id|MAX_RETRIES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
multiline_comment|/* Unable to test, unit probably not ready.  This usually&n;&t;&t; * means there is no disc in the drive.  Mark as changed,&n;&t;&t; * and we will figure it out later once the drive is&n;&t;&t; * available again.  */
id|cd-&gt;device-&gt;changed
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* This will force a flush, if called from&n;&t;&t;&t;&t; * check_disk_change */
)brace
suffix:semicolon
id|retval
op_assign
id|cd-&gt;device-&gt;changed
suffix:semicolon
id|cd-&gt;device-&gt;changed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If the disk changed, the capacity will now be different,&n;&t; * so we force a re-read of this information */
r_if
c_cond
(paren
id|retval
)paren
(brace
multiline_comment|/* check multisession offset etc */
id|sr_cd_check
c_func
(paren
id|cdi
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * If the disk changed, the capacity will now be different,&n;&t;&t; * so we force a re-read of this information &n;&t;&t; * Force 2048 for the sector size so that filesystems won&squot;t&n;&t;&t; * be trying to use something that is too small if the disc&n;&t;&t; * has changed.&n;&t;&t; */
id|cd-&gt;needs_sector_size
op_assign
l_int|1
suffix:semicolon
id|cd-&gt;device-&gt;sector_size
op_assign
l_int|2048
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * rw_intr is the interrupt routine for the device driver.&n; *&n; * It will be notified on the end of a SCSI read / write, and will take on&n; * of several actions based on success or failure.&n; */
DECL|function|rw_intr
r_static
r_void
id|rw_intr
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|result
op_assign
id|SCpnt-&gt;result
suffix:semicolon
r_int
id|this_count
op_assign
id|SCpnt-&gt;bufflen
suffix:semicolon
r_int
id|good_bytes
op_assign
(paren
id|result
op_eq
l_int|0
ques
c_cond
id|this_count
suffix:colon
l_int|0
)paren
suffix:semicolon
r_int
id|block_sectors
op_assign
l_int|0
suffix:semicolon
r_int
id|error_sector
suffix:semicolon
r_struct
id|scsi_cd
op_star
id|cd
op_assign
id|scsi_cd
c_func
(paren
id|SCpnt-&gt;request-&gt;rq_disk
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;sr.c done: %x&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Handle MEDIUM ERRORs or VOLUME OVERFLOWs that indicate partial&n;&t; * success.  Since this is a relatively rare error condition, no&n;&t; * care is taken to avoid unnecessary additional work such as&n;&t; * memcpy&squot;s that could be avoided.&n;&t; */
r_if
c_cond
(paren
id|driver_byte
c_func
(paren
id|result
)paren
op_ne
l_int|0
op_logical_and
multiline_comment|/* An error occurred */
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x7f
)paren
op_eq
l_int|0x70
)paren
(brace
multiline_comment|/* Sense current */
r_switch
c_cond
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
)paren
(brace
r_case
id|MEDIUM_ERROR
suffix:colon
r_case
id|VOLUME_OVERFLOW
suffix:colon
r_case
id|ILLEGAL_REQUEST
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x90
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|blk_fs_request
c_func
(paren
id|SCpnt-&gt;request
)paren
)paren
r_break
suffix:semicolon
id|error_sector
op_assign
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|3
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|4
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|5
)braket
op_lshift
l_int|8
)paren
op_or
id|SCpnt-&gt;sense_buffer
(braket
l_int|6
)braket
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;request-&gt;bio
op_ne
l_int|NULL
)paren
id|block_sectors
op_assign
id|bio_sectors
c_func
(paren
id|SCpnt-&gt;request-&gt;bio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block_sectors
OL
l_int|4
)paren
id|block_sectors
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|cd-&gt;device-&gt;sector_size
op_eq
l_int|2048
)paren
id|error_sector
op_lshift_assign
l_int|2
suffix:semicolon
id|error_sector
op_and_assign
op_complement
(paren
id|block_sectors
op_minus
l_int|1
)paren
suffix:semicolon
id|good_bytes
op_assign
(paren
id|error_sector
op_minus
id|SCpnt-&gt;request-&gt;sector
)paren
op_lshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|good_bytes
OL
l_int|0
op_logical_or
id|good_bytes
op_ge
id|this_count
)paren
id|good_bytes
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * The SCSI specification allows for the value&n;&t;&t;&t; * returned by READ CAPACITY to be up to 75 2K&n;&t;&t;&t; * sectors past the last readable block.&n;&t;&t;&t; * Therefore, if we hit a medium error within the&n;&t;&t;&t; * last 75 2K sectors, we decrease the saved size&n;&t;&t;&t; * value.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|error_sector
OL
id|get_capacity
c_func
(paren
id|cd-&gt;disk
)paren
op_logical_and
id|cd-&gt;capacity
op_minus
id|error_sector
OL
l_int|4
op_star
l_int|75
)paren
id|set_capacity
c_func
(paren
id|cd-&gt;disk
comma
id|error_sector
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RECOVERED_ERROR
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * An error occured, but it recovered.  Inform the&n;&t;&t;&t; * user, but make sure that it&squot;s not treated as a&n;&t;&t;&t; * hard error.&n;&t;&t;&t; */
id|scsi_print_sense
c_func
(paren
l_string|&quot;sr&quot;
comma
id|SCpnt
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x0
suffix:semicolon
id|good_bytes
op_assign
id|this_count
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * This calls the generic completion function, now that we know&n;&t; * how many actual sectors finished, and how many sectors we need&n;&t; * to say have failed.&n;&t; */
id|scsi_io_completion
c_func
(paren
id|SCpnt
comma
id|good_bytes
comma
id|block_sectors
op_lshift
l_int|9
)paren
suffix:semicolon
)brace
DECL|function|sr_init_command
r_static
r_int
id|sr_init_command
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|block
op_assign
l_int|0
comma
id|this_count
comma
id|s_size
comma
id|timeout
op_assign
id|SR_TIMEOUT
suffix:semicolon
r_struct
id|scsi_cd
op_star
id|cd
op_assign
id|scsi_cd
c_func
(paren
id|SCpnt-&gt;request-&gt;rq_disk
)paren
suffix:semicolon
id|SCSI_LOG_HLQUEUE
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;Doing sr request, dev = %s, block = %d&bslash;n&quot;
comma
id|cd-&gt;disk-&gt;disk_name
comma
id|block
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cd-&gt;device
op_logical_or
op_logical_neg
id|scsi_device_online
c_func
(paren
id|cd-&gt;device
)paren
)paren
(brace
id|SCSI_LOG_HLQUEUE
c_func
(paren
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;Finishing %ld sectors&bslash;n&quot;
comma
id|SCpnt-&gt;request-&gt;nr_sectors
)paren
)paren
suffix:semicolon
id|SCSI_LOG_HLQUEUE
c_func
(paren
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;Retry with 0x%p&bslash;n&quot;
comma
id|SCpnt
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cd-&gt;device-&gt;changed
)paren
(brace
multiline_comment|/*&n;&t;&t; * quietly refuse to do anything to a changed disc until the&n;&t;&t; * changed bit has been reset&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * these are already setup, just copy cdb basically&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;request-&gt;flags
op_amp
id|REQ_BLOCK_PC
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|SCpnt-&gt;request
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
id|rq-&gt;cmd
)paren
OG
r_sizeof
(paren
id|SCpnt-&gt;cmnd
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|memcpy
c_func
(paren
id|SCpnt-&gt;cmnd
comma
id|rq-&gt;cmd
comma
r_sizeof
(paren
id|SCpnt-&gt;cmnd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;data_len
)paren
id|SCpnt-&gt;sc_data_direction
op_assign
id|DMA_NONE
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|rq
)paren
op_eq
id|WRITE
)paren
id|SCpnt-&gt;sc_data_direction
op_assign
id|DMA_TO_DEVICE
suffix:semicolon
r_else
id|SCpnt-&gt;sc_data_direction
op_assign
id|DMA_FROM_DEVICE
suffix:semicolon
id|this_count
op_assign
id|rq-&gt;data_len
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;timeout
)paren
id|timeout
op_assign
id|rq-&gt;timeout
suffix:semicolon
id|SCpnt-&gt;transfersize
op_assign
id|rq-&gt;data_len
suffix:semicolon
r_goto
id|queue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|SCpnt-&gt;request-&gt;flags
op_amp
id|REQ_CMD
)paren
)paren
(brace
id|blk_dump_rq_flags
c_func
(paren
id|SCpnt-&gt;request
comma
l_string|&quot;sr unsup command&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we do lazy blocksize switching (when reading XA sectors,&n;&t; * see CDROMREADMODE2 ioctl) &n;&t; */
id|s_size
op_assign
id|cd-&gt;device-&gt;sector_size
suffix:semicolon
r_if
c_cond
(paren
id|s_size
OG
l_int|2048
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|in_interrupt
c_func
(paren
)paren
)paren
id|sr_set_blocklength
c_func
(paren
id|cd
comma
l_int|2048
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;sr: can&squot;t switch blocksize: in interrupt&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s_size
op_ne
l_int|512
op_logical_and
id|s_size
op_ne
l_int|1024
op_logical_and
id|s_size
op_ne
l_int|2048
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sr: bad sector size %d&bslash;n&quot;
comma
id|s_size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|SCpnt-&gt;request
)paren
op_eq
id|WRITE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cd-&gt;device-&gt;writeable
)paren
r_return
l_int|0
suffix:semicolon
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|WRITE_10
suffix:semicolon
id|SCpnt-&gt;sc_data_direction
op_assign
id|DMA_TO_DEVICE
suffix:semicolon
id|cd-&gt;cdi.media_written
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|SCpnt-&gt;request
)paren
op_eq
id|READ
)paren
(brace
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|READ_10
suffix:semicolon
id|SCpnt-&gt;sc_data_direction
op_assign
id|DMA_FROM_DEVICE
suffix:semicolon
)brace
r_else
(brace
id|blk_dump_rq_flags
c_func
(paren
id|SCpnt-&gt;request
comma
l_string|&quot;Unknown sr command&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
(brace
r_struct
id|scatterlist
op_star
id|sg
op_assign
id|SCpnt-&gt;request_buffer
suffix:semicolon
r_int
id|i
comma
id|size
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCpnt-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
id|size
op_add_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
r_if
c_cond
(paren
id|size
op_ne
id|SCpnt-&gt;request_bufflen
op_logical_and
id|SCpnt-&gt;use_sg
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sr: mismatch count %d, bytes %d&bslash;n&quot;
comma
id|size
comma
id|SCpnt-&gt;request_bufflen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;request_bufflen
OG
id|size
)paren
id|SCpnt-&gt;request_bufflen
op_assign
id|SCpnt-&gt;bufflen
op_assign
id|size
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * request doesn&squot;t start on hw block boundary, add scatter pads&n;&t; */
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|SCpnt-&gt;request-&gt;sector
op_mod
(paren
id|s_size
op_rshift
l_int|9
)paren
)paren
op_logical_or
(paren
id|SCpnt-&gt;request_bufflen
op_mod
id|s_size
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sr: unaligned transfer&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|this_count
op_assign
(paren
id|SCpnt-&gt;request_bufflen
op_rshift
l_int|9
)paren
op_div
(paren
id|s_size
op_rshift
l_int|9
)paren
suffix:semicolon
id|SCSI_LOG_HLQUEUE
c_func
(paren
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;%s : %s %d/%ld 512 byte blocks.&bslash;n&quot;
comma
id|cd-&gt;cdi.name
comma
(paren
id|rq_data_dir
c_func
(paren
id|SCpnt-&gt;request
)paren
op_eq
id|WRITE
)paren
ques
c_cond
l_string|&quot;writing&quot;
suffix:colon
l_string|&quot;reading&quot;
comma
id|this_count
comma
id|SCpnt-&gt;request-&gt;nr_sectors
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;cmnd
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|block
op_assign
(paren
r_int
r_int
)paren
id|SCpnt-&gt;request-&gt;sector
op_div
(paren
id|s_size
op_rshift
l_int|9
)paren
suffix:semicolon
r_if
c_cond
(paren
id|this_count
OG
l_int|0xffff
)paren
(brace
id|this_count
op_assign
l_int|0xffff
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
id|SCpnt-&gt;bufflen
op_assign
id|this_count
op_star
id|s_size
suffix:semicolon
)brace
id|SCpnt-&gt;cmnd
(braket
l_int|2
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|block
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
suffix:semicolon
id|SCpnt-&gt;cmnd
(braket
l_int|3
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|block
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|SCpnt-&gt;cmnd
(braket
l_int|4
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|block
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|SCpnt-&gt;cmnd
(braket
l_int|5
)braket
op_assign
(paren
r_int
r_char
)paren
id|block
op_amp
l_int|0xff
suffix:semicolon
id|SCpnt-&gt;cmnd
(braket
l_int|6
)braket
op_assign
id|SCpnt-&gt;cmnd
(braket
l_int|9
)braket
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;cmnd
(braket
l_int|7
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|this_count
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|SCpnt-&gt;cmnd
(braket
l_int|8
)braket
op_assign
(paren
r_int
r_char
)paren
id|this_count
op_amp
l_int|0xff
suffix:semicolon
multiline_comment|/*&n;&t; * We shouldn&squot;t disconnect in the middle of a sector, so with a dumb&n;&t; * host adapter, it&squot;s safe to assume that we can at least transfer&n;&t; * this many bytes between each connect / disconnect.&n;&t; */
id|SCpnt-&gt;transfersize
op_assign
id|cd-&gt;device-&gt;sector_size
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
id|this_count
op_lshift
l_int|9
suffix:semicolon
id|queue
suffix:colon
id|SCpnt-&gt;allowed
op_assign
id|MAX_RETRIES
suffix:semicolon
id|SCpnt-&gt;timeout_per_command
op_assign
id|timeout
suffix:semicolon
multiline_comment|/*&n;&t; * This is the completion routine we use.  This is matched in terms&n;&t; * of capability to this function.&n;&t; */
id|SCpnt-&gt;done
op_assign
id|rw_intr
suffix:semicolon
multiline_comment|/*&n;&t; * This indicates that the command is ready from our end to be&n;&t; * queued.&n;&t; */
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|sr_block_open
r_static
r_int
id|sr_block_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|inode-&gt;i_bdev-&gt;bd_disk
suffix:semicolon
r_struct
id|scsi_cd
op_star
id|cd
op_assign
id|scsi_cd
c_func
(paren
id|inode-&gt;i_bdev-&gt;bd_disk
)paren
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cd
op_assign
id|scsi_cd_get
c_func
(paren
id|disk
)paren
)paren
)paren
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdrom_open
c_func
(paren
op_amp
id|cd-&gt;cdi
comma
id|inode
comma
id|file
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|scsi_cd_put
c_func
(paren
id|cd
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|sr_block_release
r_static
r_int
id|sr_block_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|scsi_cd
op_star
id|cd
op_assign
id|scsi_cd
c_func
(paren
id|inode-&gt;i_bdev-&gt;bd_disk
)paren
suffix:semicolon
id|ret
op_assign
id|cdrom_release
c_func
(paren
op_amp
id|cd-&gt;cdi
comma
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
id|scsi_cd_put
c_func
(paren
id|cd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sr_block_ioctl
r_static
r_int
id|sr_block_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|scsi_cd
op_star
id|cd
op_assign
id|scsi_cd
c_func
(paren
id|inode-&gt;i_bdev-&gt;bd_disk
)paren
suffix:semicolon
r_struct
id|scsi_device
op_star
id|sdev
op_assign
id|cd-&gt;device
suffix:semicolon
multiline_comment|/*&n;         * Send SCSI addressing ioctls directly to mid level, send other&n;         * ioctls to cdrom/block level.&n;         */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SCSI_IOCTL_GET_IDLUN
suffix:colon
r_case
id|SCSI_IOCTL_GET_BUS_NUMBER
suffix:colon
r_return
id|scsi_ioctl
c_func
(paren
id|sdev
comma
id|cmd
comma
(paren
r_void
id|__user
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_return
id|cdrom_ioctl
c_func
(paren
id|file
comma
op_amp
id|cd-&gt;cdi
comma
id|inode
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
DECL|function|sr_block_media_changed
r_static
r_int
id|sr_block_media_changed
c_func
(paren
r_struct
id|gendisk
op_star
id|disk
)paren
(brace
r_struct
id|scsi_cd
op_star
id|cd
op_assign
id|scsi_cd
c_func
(paren
id|disk
)paren
suffix:semicolon
r_return
id|cdrom_media_changed
c_func
(paren
op_amp
id|cd-&gt;cdi
)paren
suffix:semicolon
)brace
DECL|variable|sr_bdops
r_struct
id|block_device_operations
id|sr_bdops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|open
op_assign
id|sr_block_open
comma
dot
id|release
op_assign
id|sr_block_release
comma
dot
id|ioctl
op_assign
id|sr_block_ioctl
comma
dot
id|media_changed
op_assign
id|sr_block_media_changed
comma
)brace
suffix:semicolon
DECL|function|sr_open
r_static
r_int
id|sr_open
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|purpose
)paren
(brace
r_struct
id|scsi_cd
op_star
id|cd
op_assign
id|cdi-&gt;handle
suffix:semicolon
r_struct
id|scsi_device
op_star
id|sdev
op_assign
id|cd-&gt;device
suffix:semicolon
r_int
id|retval
suffix:semicolon
multiline_comment|/*&n;&t; * If the device is in error recovery, wait until it is done.&n;&t; * If the device is offline, then disallow any access to it.&n;&t; */
id|retval
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_block_when_processing_errors
c_func
(paren
id|sdev
)paren
)paren
r_goto
id|error_out
suffix:semicolon
multiline_comment|/*&n;&t; * If this device did not have media in the drive at boot time, then&n;&t; * we would have been unable to get the sector size.  Check to see if&n;&t; * this is the case, and try again.&n;&t; */
r_if
c_cond
(paren
id|cd-&gt;needs_sector_size
)paren
id|get_sectorsize
c_func
(paren
id|cd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error_out
suffix:colon
id|scsi_cd_put
c_func
(paren
id|cd
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|sr_release
r_static
r_void
id|sr_release
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
)paren
(brace
r_struct
id|scsi_cd
op_star
id|cd
op_assign
id|cdi-&gt;handle
suffix:semicolon
r_if
c_cond
(paren
id|cd-&gt;device-&gt;sector_size
OG
l_int|2048
)paren
id|sr_set_blocklength
c_func
(paren
id|cd
comma
l_int|2048
)paren
suffix:semicolon
)brace
DECL|function|sr_probe
r_static
r_int
id|sr_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
op_assign
id|to_scsi_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|gendisk
op_star
id|disk
suffix:semicolon
r_struct
id|scsi_cd
op_star
id|cd
suffix:semicolon
r_int
id|minor
comma
id|error
suffix:semicolon
id|error
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;type
op_ne
id|TYPE_ROM
op_logical_and
id|sdev-&gt;type
op_ne
id|TYPE_WORM
)paren
r_goto
id|fail
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|cd
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|cd
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cd
)paren
r_goto
id|fail
suffix:semicolon
id|memset
c_func
(paren
id|cd
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|cd
)paren
)paren
suffix:semicolon
id|kref_init
c_func
(paren
op_amp
id|cd-&gt;kref
)paren
suffix:semicolon
id|disk
op_assign
id|alloc_disk
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|disk
)paren
r_goto
id|fail_free
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sr_index_lock
)paren
suffix:semicolon
id|minor
op_assign
id|find_first_zero_bit
c_func
(paren
id|sr_index_bits
comma
id|SR_DISKS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_eq
id|SR_DISKS
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|sr_index_lock
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|fail_put
suffix:semicolon
)brace
id|__set_bit
c_func
(paren
id|minor
comma
id|sr_index_bits
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|sr_index_lock
)paren
suffix:semicolon
id|disk-&gt;major
op_assign
id|SCSI_CDROM_MAJOR
suffix:semicolon
id|disk-&gt;first_minor
op_assign
id|minor
suffix:semicolon
id|sprintf
c_func
(paren
id|disk-&gt;disk_name
comma
l_string|&quot;sr%d&quot;
comma
id|minor
)paren
suffix:semicolon
id|disk-&gt;fops
op_assign
op_amp
id|sr_bdops
suffix:semicolon
id|disk-&gt;flags
op_assign
id|GENHD_FL_CD
suffix:semicolon
id|cd-&gt;device
op_assign
id|sdev
suffix:semicolon
id|cd-&gt;disk
op_assign
id|disk
suffix:semicolon
id|cd-&gt;driver
op_assign
op_amp
id|sr_template
suffix:semicolon
id|cd-&gt;disk
op_assign
id|disk
suffix:semicolon
id|cd-&gt;capacity
op_assign
l_int|0x1fffff
suffix:semicolon
id|cd-&gt;needs_sector_size
op_assign
l_int|1
suffix:semicolon
id|cd-&gt;device-&gt;changed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* force recheck CD type */
id|cd-&gt;use
op_assign
l_int|1
suffix:semicolon
id|cd-&gt;readcd_known
op_assign
l_int|0
suffix:semicolon
id|cd-&gt;readcd_cdda
op_assign
l_int|0
suffix:semicolon
id|cd-&gt;cdi.ops
op_assign
op_amp
id|sr_dops
suffix:semicolon
id|cd-&gt;cdi.handle
op_assign
id|cd
suffix:semicolon
id|cd-&gt;cdi.mask
op_assign
l_int|0
suffix:semicolon
id|cd-&gt;cdi.capacity
op_assign
l_int|1
suffix:semicolon
id|sprintf
c_func
(paren
id|cd-&gt;cdi.name
comma
l_string|&quot;sr%d&quot;
comma
id|minor
)paren
suffix:semicolon
id|sdev-&gt;sector_size
op_assign
l_int|2048
suffix:semicolon
multiline_comment|/* A guess, just in case */
multiline_comment|/* FIXME: need to handle a get_capabilities failure properly ?? */
id|get_capabilities
c_func
(paren
id|cd
)paren
suffix:semicolon
id|sr_vendor_init
c_func
(paren
id|cd
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|disk-&gt;devfs_name
comma
r_sizeof
(paren
id|disk-&gt;devfs_name
)paren
comma
l_string|&quot;%s/cd&quot;
comma
id|sdev-&gt;devfs_name
)paren
suffix:semicolon
id|disk-&gt;driverfs_dev
op_assign
op_amp
id|sdev-&gt;sdev_gendev
suffix:semicolon
id|set_capacity
c_func
(paren
id|disk
comma
id|cd-&gt;capacity
)paren
suffix:semicolon
id|disk-&gt;private_data
op_assign
op_amp
id|cd-&gt;driver
suffix:semicolon
id|disk-&gt;queue
op_assign
id|sdev-&gt;request_queue
suffix:semicolon
id|cd-&gt;cdi.disk
op_assign
id|disk
suffix:semicolon
r_if
c_cond
(paren
id|register_cdrom
c_func
(paren
op_amp
id|cd-&gt;cdi
)paren
)paren
r_goto
id|fail_put
suffix:semicolon
id|dev_set_drvdata
c_func
(paren
id|dev
comma
id|cd
)paren
suffix:semicolon
id|disk-&gt;flags
op_or_assign
id|GENHD_FL_REMOVABLE
suffix:semicolon
id|add_disk
c_func
(paren
id|disk
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Attached scsi CD-ROM %s at scsi%d, channel %d, id %d, lun %d&bslash;n&quot;
comma
id|cd-&gt;cdi.name
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail_put
suffix:colon
id|put_disk
c_func
(paren
id|disk
)paren
suffix:semicolon
id|fail_free
suffix:colon
id|kfree
c_func
(paren
id|cd
)paren
suffix:semicolon
id|fail
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|get_sectorsize
r_static
r_void
id|get_sectorsize
c_func
(paren
r_struct
id|scsi_cd
op_star
id|cd
)paren
(brace
r_int
r_char
id|cmd
(braket
l_int|10
)braket
suffix:semicolon
r_int
r_char
op_star
id|buffer
suffix:semicolon
r_int
id|the_result
comma
id|retries
op_assign
l_int|3
suffix:semicolon
r_int
id|sector_size
suffix:semicolon
r_struct
id|scsi_request
op_star
id|SRpnt
op_assign
l_int|NULL
suffix:semicolon
id|request_queue_t
op_star
id|queue
suffix:semicolon
id|buffer
op_assign
id|kmalloc
c_func
(paren
l_int|512
comma
id|GFP_KERNEL
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
)paren
r_goto
id|Enomem
suffix:semicolon
id|SRpnt
op_assign
id|scsi_allocate_request
c_func
(paren
id|cd-&gt;device
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SRpnt
)paren
r_goto
id|Enomem
suffix:semicolon
r_do
(brace
id|cmd
(braket
l_int|0
)braket
op_assign
id|READ_CAPACITY
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|cmd
(braket
l_int|1
)braket
comma
l_int|0
comma
l_int|9
)paren
suffix:semicolon
multiline_comment|/* Mark as really busy */
id|SRpnt-&gt;sr_request-&gt;rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
id|SRpnt-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|buffer
comma
l_int|0
comma
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Do the command and wait.. */
id|SRpnt-&gt;sr_data_direction
op_assign
id|DMA_FROM_DEVICE
suffix:semicolon
id|scsi_wait_req
c_func
(paren
id|SRpnt
comma
(paren
r_void
op_star
)paren
id|cmd
comma
(paren
r_void
op_star
)paren
id|buffer
comma
l_int|8
comma
id|SR_TIMEOUT
comma
id|MAX_RETRIES
)paren
suffix:semicolon
id|the_result
op_assign
id|SRpnt-&gt;sr_result
suffix:semicolon
id|retries
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|the_result
op_logical_and
id|retries
)paren
suffix:semicolon
id|scsi_release_request
c_func
(paren
id|SRpnt
)paren
suffix:semicolon
id|SRpnt
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|the_result
)paren
(brace
id|cd-&gt;capacity
op_assign
l_int|0x1fffff
suffix:semicolon
id|sector_size
op_assign
l_int|2048
suffix:semicolon
multiline_comment|/* A guess, just in case */
id|cd-&gt;needs_sector_size
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
macro_line|#if 0
r_if
c_cond
(paren
id|cdrom_get_last_written
c_func
(paren
op_amp
id|cd-&gt;cdi
comma
op_amp
id|cd-&gt;capacity
)paren
)paren
macro_line|#endif
id|cd-&gt;capacity
op_assign
l_int|1
op_plus
(paren
(paren
id|buffer
(braket
l_int|0
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|buffer
(braket
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|buffer
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_or
id|buffer
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|sector_size
op_assign
(paren
id|buffer
(braket
l_int|4
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|buffer
(braket
l_int|5
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|buffer
(braket
l_int|6
)braket
op_lshift
l_int|8
)paren
op_or
id|buffer
(braket
l_int|7
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|sector_size
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * HP 4020i CD-Recorder reports 2340 byte sectors&n;&t;&t;&t; * Philips CD-Writers report 2352 byte sectors&n;&t;&t;&t; *&n;&t;&t;&t; * Use 2k sectors for them..&n;&t;&t;&t; */
r_case
l_int|0
suffix:colon
r_case
l_int|2340
suffix:colon
r_case
l_int|2352
suffix:colon
id|sector_size
op_assign
l_int|2048
suffix:semicolon
multiline_comment|/* fall through */
r_case
l_int|2048
suffix:colon
id|cd-&gt;capacity
op_mul_assign
l_int|4
suffix:semicolon
multiline_comment|/* fall through */
r_case
l_int|512
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: unsupported sector size %d.&bslash;n&quot;
comma
id|cd-&gt;cdi.name
comma
id|sector_size
)paren
suffix:semicolon
id|cd-&gt;capacity
op_assign
l_int|0
suffix:semicolon
id|cd-&gt;needs_sector_size
op_assign
l_int|1
suffix:semicolon
)brace
id|cd-&gt;device-&gt;sector_size
op_assign
id|sector_size
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Add this so that we have the ability to correctly gauge&n;&t;&t; * what the device is capable of.&n;&t;&t; */
id|cd-&gt;needs_sector_size
op_assign
l_int|0
suffix:semicolon
id|set_capacity
c_func
(paren
id|cd-&gt;disk
comma
id|cd-&gt;capacity
)paren
suffix:semicolon
)brace
id|queue
op_assign
id|cd-&gt;device-&gt;request_queue
suffix:semicolon
id|blk_queue_hardsect_size
c_func
(paren
id|queue
comma
id|sector_size
)paren
suffix:semicolon
id|out
suffix:colon
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
suffix:semicolon
id|Enomem
suffix:colon
id|cd-&gt;capacity
op_assign
l_int|0x1fffff
suffix:semicolon
id|sector_size
op_assign
l_int|2048
suffix:semicolon
multiline_comment|/* A guess, just in case */
id|cd-&gt;needs_sector_size
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|SRpnt
)paren
id|scsi_release_request
c_func
(paren
id|SRpnt
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|function|get_capabilities
r_static
r_void
id|get_capabilities
c_func
(paren
r_struct
id|scsi_cd
op_star
id|cd
)paren
(brace
r_int
r_char
op_star
id|buffer
suffix:semicolon
r_struct
id|scsi_mode_data
id|data
suffix:semicolon
r_struct
id|scsi_request
op_star
id|SRpnt
suffix:semicolon
r_int
r_char
id|cmd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
r_int
r_int
id|the_result
suffix:semicolon
r_int
id|retries
comma
id|rc
comma
id|n
suffix:semicolon
r_static
r_char
op_star
id|loadmech
(braket
)braket
op_assign
(brace
l_string|&quot;caddy&quot;
comma
l_string|&quot;tray&quot;
comma
l_string|&quot;pop-up&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;changer&quot;
comma
l_string|&quot;cartridge changer&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;&quot;
)brace
suffix:semicolon
multiline_comment|/* allocate a request for the TEST_UNIT_READY */
id|SRpnt
op_assign
id|scsi_allocate_request
c_func
(paren
id|cd-&gt;device
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SRpnt
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(get_capabilities:) Request allocation &quot;
l_string|&quot;failure.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* allocate transfer buffer */
id|buffer
op_assign
id|kmalloc
c_func
(paren
l_int|512
comma
id|GFP_KERNEL
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sr: out of memory.&bslash;n&quot;
)paren
suffix:semicolon
id|scsi_release_request
c_func
(paren
id|SRpnt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* issue TEST_UNIT_READY until the initial startup UNIT_ATTENTION&n;&t; * conditions are gone, or a timeout happens&n;&t; */
id|retries
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|cmd
comma
l_int|0
comma
id|MAX_COMMAND_SIZE
)paren
suffix:semicolon
id|cmd
(braket
l_int|0
)braket
op_assign
id|TEST_UNIT_READY
suffix:semicolon
id|SRpnt-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|SRpnt-&gt;sr_sense_buffer
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|SRpnt-&gt;sr_sense_buffer
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|SRpnt-&gt;sr_data_direction
op_assign
id|DMA_NONE
suffix:semicolon
id|scsi_wait_req
(paren
id|SRpnt
comma
(paren
r_void
op_star
)paren
id|cmd
comma
id|buffer
comma
l_int|0
comma
id|SR_TIMEOUT
comma
id|MAX_RETRIES
)paren
suffix:semicolon
id|the_result
op_assign
id|SRpnt-&gt;sr_result
suffix:semicolon
id|retries
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|retries
OL
l_int|5
op_logical_and
(paren
op_logical_neg
id|scsi_status_is_good
c_func
(paren
id|the_result
)paren
op_logical_or
(paren
(paren
id|driver_byte
c_func
(paren
id|the_result
)paren
op_amp
id|DRIVER_SENSE
)paren
op_logical_and
id|SRpnt-&gt;sr_sense_buffer
(braket
l_int|2
)braket
op_eq
id|UNIT_ATTENTION
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* ask for mode page 0x2a */
id|rc
op_assign
id|scsi_mode_sense
c_func
(paren
id|cd-&gt;device
comma
l_int|0
comma
l_int|0x2a
comma
id|buffer
comma
l_int|128
comma
id|SR_TIMEOUT
comma
l_int|3
comma
op_amp
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_status_is_good
c_func
(paren
id|rc
)paren
)paren
(brace
multiline_comment|/* failed, drive doesn&squot;t have capabilities mode page */
id|cd-&gt;cdi.speed
op_assign
l_int|1
suffix:semicolon
id|cd-&gt;cdi.mask
op_or_assign
(paren
id|CDC_CD_R
op_or
id|CDC_CD_RW
op_or
id|CDC_DVD_R
op_or
id|CDC_DVD
op_or
id|CDC_DVD_RAM
op_or
id|CDC_SELECT_DISC
op_or
id|CDC_SELECT_SPEED
)paren
suffix:semicolon
id|scsi_release_request
c_func
(paren
id|SRpnt
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: scsi-1 drive&bslash;n&quot;
comma
id|cd-&gt;cdi.name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|n
op_assign
id|data.header_length
op_plus
id|data.block_descriptor_length
suffix:semicolon
id|cd-&gt;cdi.speed
op_assign
(paren
(paren
id|buffer
(braket
id|n
op_plus
l_int|8
)braket
op_lshift
l_int|8
)paren
op_plus
id|buffer
(braket
id|n
op_plus
l_int|9
)braket
)paren
op_div
l_int|176
suffix:semicolon
id|cd-&gt;readcd_known
op_assign
l_int|1
suffix:semicolon
id|cd-&gt;readcd_cdda
op_assign
id|buffer
(braket
id|n
op_plus
l_int|5
)braket
op_amp
l_int|0x01
suffix:semicolon
multiline_comment|/* print some capability bits */
id|printk
c_func
(paren
l_string|&quot;%s: scsi3-mmc drive: %dx/%dx %s%s%s%s%s%s&bslash;n&quot;
comma
id|cd-&gt;cdi.name
comma
(paren
(paren
id|buffer
(braket
id|n
op_plus
l_int|14
)braket
op_lshift
l_int|8
)paren
op_plus
id|buffer
(braket
id|n
op_plus
l_int|15
)braket
)paren
op_div
l_int|176
comma
id|cd-&gt;cdi.speed
comma
id|buffer
(braket
id|n
op_plus
l_int|3
)braket
op_amp
l_int|0x01
ques
c_cond
l_string|&quot;writer &quot;
suffix:colon
l_string|&quot;&quot;
comma
multiline_comment|/* CD Writer */
id|buffer
(braket
id|n
op_plus
l_int|3
)braket
op_amp
l_int|0x20
ques
c_cond
l_string|&quot;dvd-ram &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|buffer
(braket
id|n
op_plus
l_int|2
)braket
op_amp
l_int|0x02
ques
c_cond
l_string|&quot;cd/rw &quot;
suffix:colon
l_string|&quot;&quot;
comma
multiline_comment|/* can read rewriteable */
id|buffer
(braket
id|n
op_plus
l_int|4
)braket
op_amp
l_int|0x20
ques
c_cond
l_string|&quot;xa/form2 &quot;
suffix:colon
l_string|&quot;&quot;
comma
multiline_comment|/* can read xa/from2 */
id|buffer
(braket
id|n
op_plus
l_int|5
)braket
op_amp
l_int|0x01
ques
c_cond
l_string|&quot;cdda &quot;
suffix:colon
l_string|&quot;&quot;
comma
multiline_comment|/* can read audio data */
id|loadmech
(braket
id|buffer
(braket
id|n
op_plus
l_int|6
)braket
op_rshift
l_int|5
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|buffer
(braket
id|n
op_plus
l_int|6
)braket
op_rshift
l_int|5
)paren
op_eq
l_int|0
)paren
multiline_comment|/* caddy drives can&squot;t close tray... */
id|cd-&gt;cdi.mask
op_or_assign
id|CDC_CLOSE_TRAY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|buffer
(braket
id|n
op_plus
l_int|2
)braket
op_amp
l_int|0x8
)paren
op_eq
l_int|0
)paren
multiline_comment|/* not a DVD drive */
id|cd-&gt;cdi.mask
op_or_assign
id|CDC_DVD
suffix:semicolon
r_if
c_cond
(paren
(paren
id|buffer
(braket
id|n
op_plus
l_int|3
)braket
op_amp
l_int|0x20
)paren
op_eq
l_int|0
)paren
multiline_comment|/* can&squot;t write DVD-RAM media */
id|cd-&gt;cdi.mask
op_or_assign
id|CDC_DVD_RAM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|buffer
(braket
id|n
op_plus
l_int|3
)braket
op_amp
l_int|0x10
)paren
op_eq
l_int|0
)paren
multiline_comment|/* can&squot;t write DVD-R media */
id|cd-&gt;cdi.mask
op_or_assign
id|CDC_DVD_R
suffix:semicolon
r_if
c_cond
(paren
(paren
id|buffer
(braket
id|n
op_plus
l_int|3
)braket
op_amp
l_int|0x2
)paren
op_eq
l_int|0
)paren
multiline_comment|/* can&squot;t write CD-RW media */
id|cd-&gt;cdi.mask
op_or_assign
id|CDC_CD_RW
suffix:semicolon
r_if
c_cond
(paren
(paren
id|buffer
(braket
id|n
op_plus
l_int|3
)braket
op_amp
l_int|0x1
)paren
op_eq
l_int|0
)paren
multiline_comment|/* can&squot;t write CD-R media */
id|cd-&gt;cdi.mask
op_or_assign
id|CDC_CD_R
suffix:semicolon
r_if
c_cond
(paren
(paren
id|buffer
(braket
id|n
op_plus
l_int|6
)braket
op_amp
l_int|0x8
)paren
op_eq
l_int|0
)paren
multiline_comment|/* can&squot;t eject */
id|cd-&gt;cdi.mask
op_or_assign
id|CDC_OPEN_TRAY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|buffer
(braket
id|n
op_plus
l_int|6
)braket
op_rshift
l_int|5
)paren
op_eq
id|mechtype_individual_changer
op_logical_or
(paren
id|buffer
(braket
id|n
op_plus
l_int|6
)braket
op_rshift
l_int|5
)paren
op_eq
id|mechtype_cartridge_changer
)paren
id|cd-&gt;cdi.capacity
op_assign
id|cdrom_number_of_slots
c_func
(paren
op_amp
id|cd-&gt;cdi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cd-&gt;cdi.capacity
op_le
l_int|1
)paren
multiline_comment|/* not a changer */
id|cd-&gt;cdi.mask
op_or_assign
id|CDC_SELECT_DISC
suffix:semicolon
multiline_comment|/*else    I don&squot;t think it can close its tray&n;&t;&t;cd-&gt;cdi.mask |= CDC_CLOSE_TRAY; */
multiline_comment|/*&n;&t; * if DVD-RAM, MRW-W or CD-RW, we are randomly writable&n;&t; */
r_if
c_cond
(paren
(paren
id|cd-&gt;cdi.mask
op_amp
(paren
id|CDC_DVD_RAM
op_or
id|CDC_MRW_W
op_or
id|CDC_RAM
op_or
id|CDC_CD_RW
)paren
)paren
op_ne
(paren
id|CDC_DVD_RAM
op_or
id|CDC_MRW_W
op_or
id|CDC_RAM
op_or
id|CDC_CD_RW
)paren
)paren
(brace
id|cd-&gt;device-&gt;writeable
op_assign
l_int|1
suffix:semicolon
)brace
id|scsi_release_request
c_func
(paren
id|SRpnt
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sr_packet() is the entry point for the generic commands generated&n; * by the Uniform CD-ROM layer. &n; */
DECL|function|sr_packet
r_static
r_int
id|sr_packet
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_struct
id|packet_command
op_star
id|cgc
)paren
(brace
r_if
c_cond
(paren
id|cgc-&gt;timeout
op_le
l_int|0
)paren
id|cgc-&gt;timeout
op_assign
id|IOCTL_TIMEOUT
suffix:semicolon
id|sr_do_ioctl
c_func
(paren
id|cdi-&gt;handle
comma
id|cgc
)paren
suffix:semicolon
r_return
id|cgc-&gt;stat
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;sr_kref_release - Called to free the scsi_cd structure&n; *&t;@kref: pointer to embedded kref&n; *&n; *&t;sr_ref_sem must be held entering this routine.  Because it is&n; *&t;called on last put, you should always use the scsi_cd_get()&n; *&t;scsi_cd_put() helpers which manipulate the semaphore directly&n; *&t;and never do a direct kref_put().&n; **/
DECL|function|sr_kref_release
r_static
r_void
id|sr_kref_release
c_func
(paren
r_struct
id|kref
op_star
id|kref
)paren
(brace
r_struct
id|scsi_cd
op_star
id|cd
op_assign
id|container_of
c_func
(paren
id|kref
comma
r_struct
id|scsi_cd
comma
id|kref
)paren
suffix:semicolon
r_struct
id|gendisk
op_star
id|disk
op_assign
id|cd-&gt;disk
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sr_index_lock
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|disk-&gt;first_minor
comma
id|sr_index_bits
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|sr_index_lock
)paren
suffix:semicolon
id|unregister_cdrom
c_func
(paren
op_amp
id|cd-&gt;cdi
)paren
suffix:semicolon
id|disk-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
id|put_disk
c_func
(paren
id|disk
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|cd
)paren
suffix:semicolon
)brace
DECL|function|sr_remove
r_static
r_int
id|sr_remove
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|scsi_cd
op_star
id|cd
op_assign
id|dev_get_drvdata
c_func
(paren
id|dev
)paren
suffix:semicolon
id|del_gendisk
c_func
(paren
id|cd-&gt;disk
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sr_ref_sem
)paren
suffix:semicolon
id|kref_put
c_func
(paren
op_amp
id|cd-&gt;kref
comma
id|sr_kref_release
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|sr_ref_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|init_sr
r_static
r_int
id|__init
id|init_sr
c_func
(paren
r_void
)paren
(brace
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|register_blkdev
c_func
(paren
id|SCSI_CDROM_MAJOR
comma
l_string|&quot;sr&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
r_return
id|scsi_register_driver
c_func
(paren
op_amp
id|sr_template.gendrv
)paren
suffix:semicolon
)brace
DECL|function|exit_sr
r_static
r_void
id|__exit
id|exit_sr
c_func
(paren
r_void
)paren
(brace
id|scsi_unregister_driver
c_func
(paren
op_amp
id|sr_template.gendrv
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|SCSI_CDROM_MAJOR
comma
l_string|&quot;sr&quot;
)paren
suffix:semicolon
)brace
DECL|variable|init_sr
id|module_init
c_func
(paren
id|init_sr
)paren
suffix:semicolon
DECL|variable|exit_sr
id|module_exit
c_func
(paren
id|exit_sr
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
