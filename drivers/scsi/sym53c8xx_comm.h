multiline_comment|/******************************************************************************&n;**  High Performance device driver for the Symbios 53C896 controller.&n;**&n;**  Copyright (C) 1998-2001  Gerard Roudier &lt;groudier@free.fr&gt;&n;**&n;**  This driver also supports all the Symbios 53C8XX controller family, &n;**  except 53C810 revisions &lt; 16, 53C825 revisions &lt; 16 and all &n;**  revisions of 53C815 controllers.&n;**&n;**  This driver is based on the Linux port of the FreeBSD ncr driver.&n;** &n;**  Copyright (C) 1994  Wolfgang Stanglmeier&n;**  &n;**-----------------------------------------------------------------------------&n;**  &n;**  This program is free software; you can redistribute it and/or modify&n;**  it under the terms of the GNU General Public License as published by&n;**  the Free Software Foundation; either version 2 of the License, or&n;**  (at your option) any later version.&n;**&n;**  This program is distributed in the hope that it will be useful,&n;**  but WITHOUT ANY WARRANTY; without even the implied warranty of&n;**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;**  GNU General Public License for more details.&n;**&n;**  You should have received a copy of the GNU General Public License&n;**  along with this program; if not, write to the Free Software&n;**  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;**&n;**-----------------------------------------------------------------------------&n;**&n;**  The Linux port of the FreeBSD ncr driver has been achieved in &n;**  november 1995 by:&n;**&n;**          Gerard Roudier              &lt;groudier@free.fr&gt;&n;**&n;**  Being given that this driver originates from the FreeBSD version, and&n;**  in order to keep synergy on both, any suggested enhancements and corrections&n;**  received on Linux are automatically a potential candidate for the FreeBSD &n;**  version.&n;**&n;**  The original driver has been written for 386bsd and FreeBSD by&n;**          Wolfgang Stanglmeier        &lt;wolf@cologne.de&gt;&n;**          Stefan Esser                &lt;se@mi.Uni-Koeln.de&gt;&n;**&n;**-----------------------------------------------------------------------------&n;**&n;**  Major contributions:&n;**  --------------------&n;**&n;**  NVRAM detection and reading.&n;**    Copyright (C) 1997 Richard Waltham &lt;dormouse@farsrobt.demon.co.uk&gt;&n;**&n;*******************************************************************************&n;*/
multiline_comment|/*&n;**&t;This file contains definitions and code that the &n;**&t;sym53c8xx and ncr53c8xx drivers should share.&n;**&t;The sharing will be achieved in a further version  &n;**&t;of the driver bundle. For now, only the ncr53c8xx &n;**&t;driver includes this file.&n;*/
multiline_comment|/*==========================================================&n;**&n;**&t;Hmmm... What complex some PCI-HOST bridges actually &n;**&t;are, despite the fact that the PCI specifications &n;**&t;are looking so smart and simple! ;-)&n;**&n;**==========================================================&n;*/
DECL|macro|SCSI_NCR_DYNAMIC_DMA_MAPPING
mdefine_line|#define SCSI_NCR_DYNAMIC_DMA_MAPPING
multiline_comment|/*==========================================================&n;**&n;**&t;Miscallaneous defines.&n;**&n;**==========================================================&n;*/
DECL|macro|u_char
mdefine_line|#define u_char&t;&t;unsigned char
DECL|macro|u_short
mdefine_line|#define u_short&t;&t;unsigned short
DECL|macro|u_int
mdefine_line|#define u_int&t;&t;unsigned int
DECL|macro|u_long
mdefine_line|#define u_long&t;&t;unsigned long
macro_line|#ifndef bcmp
DECL|macro|bcmp
mdefine_line|#define bcmp(s, d, n)&t;memcmp((d), (s), (n))
macro_line|#endif
macro_line|#ifndef bzero
DECL|macro|bzero
mdefine_line|#define bzero(d, n)&t;memset((d), 0, (n))
macro_line|#endif
macro_line|#ifndef offsetof
DECL|macro|offsetof
mdefine_line|#define offsetof(t, m)&t;((size_t) (&amp;((t *)0)-&gt;m))
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&t;assert ()&n;**&n;**==========================================================&n;**&n;**&t;modified copy from 386bsd:/usr/include/sys/assert.h&n;**&n;**----------------------------------------------------------&n;*/
DECL|macro|assert
mdefine_line|#define&t;assert(expression) { &bslash;&n;&t;if (!(expression)) { &bslash;&n;&t;&t;(void)panic( &bslash;&n;&t;&t;&t;&quot;assertion &bslash;&quot;%s&bslash;&quot; failed: file &bslash;&quot;%s&bslash;&quot;, line %d&bslash;n&quot;, &bslash;&n;&t;&t;&t;#expression, &bslash;&n;&t;&t;&t;__FILE__, __LINE__); &bslash;&n;&t;} &bslash;&n;}
multiline_comment|/*==========================================================&n;**&n;**&t;Debugging tags&n;**&n;**==========================================================&n;*/
DECL|macro|DEBUG_ALLOC
mdefine_line|#define DEBUG_ALLOC    (0x0001)
DECL|macro|DEBUG_PHASE
mdefine_line|#define DEBUG_PHASE    (0x0002)
DECL|macro|DEBUG_QUEUE
mdefine_line|#define DEBUG_QUEUE    (0x0008)
DECL|macro|DEBUG_RESULT
mdefine_line|#define DEBUG_RESULT   (0x0010)
DECL|macro|DEBUG_POINTER
mdefine_line|#define DEBUG_POINTER  (0x0020)
DECL|macro|DEBUG_SCRIPT
mdefine_line|#define DEBUG_SCRIPT   (0x0040)
DECL|macro|DEBUG_TINY
mdefine_line|#define DEBUG_TINY     (0x0080)
DECL|macro|DEBUG_TIMING
mdefine_line|#define DEBUG_TIMING   (0x0100)
DECL|macro|DEBUG_NEGO
mdefine_line|#define DEBUG_NEGO     (0x0200)
DECL|macro|DEBUG_TAGS
mdefine_line|#define DEBUG_TAGS     (0x0400)
DECL|macro|DEBUG_SCATTER
mdefine_line|#define DEBUG_SCATTER  (0x0800)
DECL|macro|DEBUG_IC
mdefine_line|#define DEBUG_IC        (0x1000)
multiline_comment|/*&n;**    Enable/Disable debug messages.&n;**    Can be changed at runtime too.&n;*/
macro_line|#ifdef SCSI_NCR_DEBUG_INFO_SUPPORT
DECL|variable|ncr_debug
r_static
r_int
id|ncr_debug
op_assign
id|SCSI_NCR_DEBUG_FLAGS
suffix:semicolon
DECL|macro|DEBUG_FLAGS
mdefine_line|#define DEBUG_FLAGS ncr_debug
macro_line|#else
DECL|macro|DEBUG_FLAGS
mdefine_line|#define DEBUG_FLAGS&t;SCSI_NCR_DEBUG_FLAGS
macro_line|#endif
multiline_comment|/*==========================================================&n;**&n;**&t;A la VMS/CAM-3 queue management.&n;**&t;Implemented from linux list management.&n;**&n;**==========================================================&n;*/
DECL|struct|xpt_quehead
r_typedef
r_struct
id|xpt_quehead
(brace
DECL|member|flink
r_struct
id|xpt_quehead
op_star
id|flink
suffix:semicolon
multiline_comment|/* Forward  pointer */
DECL|member|blink
r_struct
id|xpt_quehead
op_star
id|blink
suffix:semicolon
multiline_comment|/* Backward pointer */
DECL|typedef|XPT_QUEHEAD
)brace
id|XPT_QUEHEAD
suffix:semicolon
DECL|macro|xpt_que_init
mdefine_line|#define xpt_que_init(ptr) do { &bslash;&n;&t;(ptr)-&gt;flink = (ptr); (ptr)-&gt;blink = (ptr); &bslash;&n;} while (0)
DECL|function|__xpt_que_add
r_static
r_inline
r_void
id|__xpt_que_add
c_func
(paren
r_struct
id|xpt_quehead
op_star
r_new
comma
r_struct
id|xpt_quehead
op_star
id|blink
comma
r_struct
id|xpt_quehead
op_star
id|flink
)paren
(brace
id|flink-&gt;blink
op_assign
r_new
suffix:semicolon
r_new
op_member_access_from_pointer
id|flink
op_assign
id|flink
suffix:semicolon
r_new
op_member_access_from_pointer
id|blink
op_assign
id|blink
suffix:semicolon
id|blink-&gt;flink
op_assign
r_new
suffix:semicolon
)brace
DECL|function|__xpt_que_del
r_static
r_inline
r_void
id|__xpt_que_del
c_func
(paren
r_struct
id|xpt_quehead
op_star
id|blink
comma
r_struct
id|xpt_quehead
op_star
id|flink
)paren
(brace
id|flink-&gt;blink
op_assign
id|blink
suffix:semicolon
id|blink-&gt;flink
op_assign
id|flink
suffix:semicolon
)brace
DECL|function|xpt_que_empty
r_static
r_inline
r_int
id|xpt_que_empty
c_func
(paren
r_struct
id|xpt_quehead
op_star
id|head
)paren
(brace
r_return
id|head-&gt;flink
op_eq
id|head
suffix:semicolon
)brace
DECL|function|xpt_que_splice
r_static
r_inline
r_void
id|xpt_que_splice
c_func
(paren
r_struct
id|xpt_quehead
op_star
id|list
comma
r_struct
id|xpt_quehead
op_star
id|head
)paren
(brace
r_struct
id|xpt_quehead
op_star
id|first
op_assign
id|list-&gt;flink
suffix:semicolon
r_if
c_cond
(paren
id|first
op_ne
id|list
)paren
(brace
r_struct
id|xpt_quehead
op_star
id|last
op_assign
id|list-&gt;blink
suffix:semicolon
r_struct
id|xpt_quehead
op_star
id|at
op_assign
id|head-&gt;flink
suffix:semicolon
id|first-&gt;blink
op_assign
id|head
suffix:semicolon
id|head-&gt;flink
op_assign
id|first
suffix:semicolon
id|last-&gt;flink
op_assign
id|at
suffix:semicolon
id|at-&gt;blink
op_assign
id|last
suffix:semicolon
)brace
)brace
DECL|macro|xpt_que_entry
mdefine_line|#define xpt_que_entry(ptr, type, member) &bslash;&n;&t;((type *)((char *)(ptr)-(unsigned long)(&amp;((type *)0)-&gt;member)))
DECL|macro|xpt_insque
mdefine_line|#define xpt_insque(new, pos)&t;&t;__xpt_que_add(new, pos, (pos)-&gt;flink)
DECL|macro|xpt_remque
mdefine_line|#define xpt_remque(el)&t;&t;&t;__xpt_que_del((el)-&gt;blink, (el)-&gt;flink)
DECL|macro|xpt_insque_head
mdefine_line|#define xpt_insque_head(new, head)&t;__xpt_que_add(new, head, (head)-&gt;flink)
DECL|function|xpt_remque_head
r_static
r_inline
r_struct
id|xpt_quehead
op_star
id|xpt_remque_head
c_func
(paren
r_struct
id|xpt_quehead
op_star
id|head
)paren
(brace
r_struct
id|xpt_quehead
op_star
id|elem
op_assign
id|head-&gt;flink
suffix:semicolon
r_if
c_cond
(paren
id|elem
op_ne
id|head
)paren
id|__xpt_que_del
c_func
(paren
id|head
comma
id|elem-&gt;flink
)paren
suffix:semicolon
r_else
id|elem
op_assign
l_int|0
suffix:semicolon
r_return
id|elem
suffix:semicolon
)brace
DECL|macro|xpt_insque_tail
mdefine_line|#define xpt_insque_tail(new, head)&t;__xpt_que_add(new, (head)-&gt;blink, head)
DECL|function|xpt_remque_tail
r_static
r_inline
r_struct
id|xpt_quehead
op_star
id|xpt_remque_tail
c_func
(paren
r_struct
id|xpt_quehead
op_star
id|head
)paren
(brace
r_struct
id|xpt_quehead
op_star
id|elem
op_assign
id|head-&gt;blink
suffix:semicolon
r_if
c_cond
(paren
id|elem
op_ne
id|head
)paren
id|__xpt_que_del
c_func
(paren
id|elem-&gt;blink
comma
id|head
)paren
suffix:semicolon
r_else
id|elem
op_assign
l_int|0
suffix:semicolon
r_return
id|elem
suffix:semicolon
)brace
multiline_comment|/*==========================================================&n;**&n;**&t;SMP threading.&n;**&n;**&t;Assuming that SMP systems are generally high end &n;**&t;systems and may use several SCSI adapters, we are &n;**&t;using one lock per controller instead of some global &n;**&t;one. For the moment (linux-2.1.95), driver&squot;s entry &n;**&t;points are called with the &squot;io_request_lock&squot; lock &n;**&t;held, so:&n;**&t;- We are uselessly loosing a couple of micro-seconds &n;**&t;  to lock the controller data structure.&n;**&t;- But the driver is not broken by design for SMP and &n;**&t;  so can be more resistant to bugs or bad changes in &n;**&t;  the IO sub-system code.&n;**&t;- A small advantage could be that the interrupt code &n;**&t;  is grained as wished (e.g.: by controller).&n;**&n;**==========================================================&n;*/
DECL|variable|DRIVER_SMP_LOCK
id|spinlock_t
id|DRIVER_SMP_LOCK
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|macro|NCR_LOCK_DRIVER
mdefine_line|#define&t;NCR_LOCK_DRIVER(flags)     spin_lock_irqsave(&amp;DRIVER_SMP_LOCK, flags)
DECL|macro|NCR_UNLOCK_DRIVER
mdefine_line|#define&t;NCR_UNLOCK_DRIVER(flags)   &bslash;&n;&t;&t;spin_unlock_irqrestore(&amp;DRIVER_SMP_LOCK, flags)
DECL|macro|NCR_INIT_LOCK_NCB
mdefine_line|#define NCR_INIT_LOCK_NCB(np)      spin_lock_init(&amp;np-&gt;smp_lock)
DECL|macro|NCR_LOCK_NCB
mdefine_line|#define&t;NCR_LOCK_NCB(np, flags)    spin_lock_irqsave(&amp;np-&gt;smp_lock, flags)
DECL|macro|NCR_UNLOCK_NCB
mdefine_line|#define&t;NCR_UNLOCK_NCB(np, flags)  spin_unlock_irqrestore(&amp;np-&gt;smp_lock, flags)
DECL|macro|NCR_LOCK_SCSI_DONE
mdefine_line|#define&t;NCR_LOCK_SCSI_DONE(host, flags) &bslash;&n;&t;&t;spin_lock_irqsave((host)-&gt;host_lock, flags)
DECL|macro|NCR_UNLOCK_SCSI_DONE
mdefine_line|#define&t;NCR_UNLOCK_SCSI_DONE(host, flags) &bslash;&n;&t;&t;spin_unlock_irqrestore(((host)-&gt;host_lock), flags)
multiline_comment|/*==========================================================&n;**&n;**&t;Memory mapped IO&n;**&n;**&t;Since linux-2.1, we must use ioremap() to map the io &n;**&t;memory space and iounmap() to unmap it. This allows &n;**&t;portability. Linux 1.3.X and 2.0.X allow to remap &n;**&t;physical pages addresses greater than the highest &n;**&t;physical memory address to kernel virtual pages with &n;**&t;vremap() / vfree(). That was not portable but worked &n;**&t;with i386 architecture.&n;**&n;**==========================================================&n;*/
macro_line|#ifdef __sparc__
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#endif
DECL|macro|memcpy_to_pci
mdefine_line|#define memcpy_to_pci(a, b, c)&t;memcpy_toio((a), (b), (c))
multiline_comment|/*==========================================================&n;**&n;**&t;Insert a delay in micro-seconds and milli-seconds.&n;**&n;**&t;Under Linux, udelay() is restricted to delay &lt; &n;**&t;1 milli-second. In fact, it generally works for up &n;**&t;to 1 second delay. Since 2.1.105, the mdelay() function &n;**&t;is provided for delays in milli-seconds.&n;**&t;Under 2.0 kernels, udelay() is an inline function &n;**&t;that is very inaccurate on Pentium processors.&n;**&n;**==========================================================&n;*/
DECL|macro|UDELAY
mdefine_line|#define UDELAY udelay
DECL|macro|MDELAY
mdefine_line|#define MDELAY mdelay
multiline_comment|/*==========================================================&n;**&n;**&t;Simple power of two buddy-like allocator.&n;**&n;**&t;This simple code is not intended to be fast, but to &n;**&t;provide power of 2 aligned memory allocations.&n;**&t;Since the SCRIPTS processor only supplies 8 bit &n;**&t;arithmetic, this allocator allows simple and fast &n;**&t;address calculations  from the SCRIPTS code.&n;**&t;In addition, cache line alignment is guaranteed for &n;**&t;power of 2 cache line size.&n;**&t;Enhanced in linux-2.3.44 to provide a memory pool &n;**&t;per pcidev to support dynamic dma mapping. (I would &n;**&t;have preferred a real bus astraction, btw).&n;**&n;**==========================================================&n;*/
DECL|macro|__GetFreePages
mdefine_line|#define __GetFreePages(flags, order) __get_free_pages(flags, order)
DECL|macro|MEMO_SHIFT
mdefine_line|#define MEMO_SHIFT&t;4&t;/* 16 bytes minimum memory chunk */
macro_line|#if PAGE_SIZE &gt;= 8192
DECL|macro|MEMO_PAGE_ORDER
mdefine_line|#define MEMO_PAGE_ORDER&t;0&t;/* 1 PAGE  maximum */
macro_line|#else
DECL|macro|MEMO_PAGE_ORDER
mdefine_line|#define MEMO_PAGE_ORDER&t;1&t;/* 2 PAGES maximum */
macro_line|#endif
DECL|macro|MEMO_FREE_UNUSED
mdefine_line|#define MEMO_FREE_UNUSED&t;/* Free unused pages immediately */
DECL|macro|MEMO_WARN
mdefine_line|#define MEMO_WARN&t;1
DECL|macro|MEMO_GFP_FLAGS
mdefine_line|#define MEMO_GFP_FLAGS&t;GFP_ATOMIC
DECL|macro|MEMO_CLUSTER_SHIFT
mdefine_line|#define MEMO_CLUSTER_SHIFT&t;(PAGE_SHIFT+MEMO_PAGE_ORDER)
DECL|macro|MEMO_CLUSTER_SIZE
mdefine_line|#define MEMO_CLUSTER_SIZE&t;(1UL &lt;&lt; MEMO_CLUSTER_SHIFT)
DECL|macro|MEMO_CLUSTER_MASK
mdefine_line|#define MEMO_CLUSTER_MASK&t;(MEMO_CLUSTER_SIZE-1)
DECL|typedef|m_addr_t
r_typedef
id|u_long
id|m_addr_t
suffix:semicolon
multiline_comment|/* Enough bits to bit-hack addresses */
DECL|typedef|m_bush_t
r_typedef
r_struct
id|device
op_star
id|m_bush_t
suffix:semicolon
multiline_comment|/* Something that addresses DMAable */
DECL|struct|m_link
r_typedef
r_struct
id|m_link
(brace
multiline_comment|/* Link between free memory chunks */
DECL|member|next
r_struct
id|m_link
op_star
id|next
suffix:semicolon
DECL|typedef|m_link_s
)brace
id|m_link_s
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_DYNAMIC_DMA_MAPPING
DECL|struct|m_vtob
r_typedef
r_struct
id|m_vtob
(brace
multiline_comment|/* Virtual to Bus address translation */
DECL|member|next
r_struct
id|m_vtob
op_star
id|next
suffix:semicolon
DECL|member|vaddr
id|m_addr_t
id|vaddr
suffix:semicolon
DECL|member|baddr
id|m_addr_t
id|baddr
suffix:semicolon
DECL|typedef|m_vtob_s
)brace
id|m_vtob_s
suffix:semicolon
DECL|macro|VTOB_HASH_SHIFT
mdefine_line|#define VTOB_HASH_SHIFT&t;&t;5
DECL|macro|VTOB_HASH_SIZE
mdefine_line|#define VTOB_HASH_SIZE&t;&t;(1UL &lt;&lt; VTOB_HASH_SHIFT)
DECL|macro|VTOB_HASH_MASK
mdefine_line|#define VTOB_HASH_MASK&t;&t;(VTOB_HASH_SIZE-1)
DECL|macro|VTOB_HASH_CODE
mdefine_line|#define VTOB_HASH_CODE(m)&t;&bslash;&n;&t;((((m_addr_t) (m)) &gt;&gt; MEMO_CLUSTER_SHIFT) &amp; VTOB_HASH_MASK)
macro_line|#endif
DECL|struct|m_pool
r_typedef
r_struct
id|m_pool
(brace
multiline_comment|/* Memory pool of a given kind */
macro_line|#ifdef&t;SCSI_NCR_DYNAMIC_DMA_MAPPING
DECL|member|bush
id|m_bush_t
id|bush
suffix:semicolon
DECL|member|getp
id|m_addr_t
(paren
op_star
id|getp
)paren
(paren
r_struct
id|m_pool
op_star
)paren
suffix:semicolon
DECL|member|freep
r_void
(paren
op_star
id|freep
)paren
(paren
r_struct
id|m_pool
op_star
comma
id|m_addr_t
)paren
suffix:semicolon
DECL|macro|M_GETP
mdefine_line|#define M_GETP()&t;&t;mp-&gt;getp(mp)
DECL|macro|M_FREEP
mdefine_line|#define M_FREEP(p)&t;&t;mp-&gt;freep(mp, p)
DECL|macro|GetPages
mdefine_line|#define GetPages()&t;&t;__GetFreePages(MEMO_GFP_FLAGS, MEMO_PAGE_ORDER)
DECL|macro|FreePages
mdefine_line|#define FreePages(p)&t;&t;free_pages(p, MEMO_PAGE_ORDER)
DECL|member|nump
r_int
id|nump
suffix:semicolon
DECL|member|vtob
id|m_vtob_s
op_star
(paren
id|vtob
(braket
id|VTOB_HASH_SIZE
)braket
)paren
suffix:semicolon
DECL|member|next
r_struct
id|m_pool
op_star
id|next
suffix:semicolon
macro_line|#else
mdefine_line|#define M_GETP()&t;&t;__GetFreePages(MEMO_GFP_FLAGS, MEMO_PAGE_ORDER)
mdefine_line|#define M_FREEP(p)&t;&t;free_pages(p, MEMO_PAGE_ORDER)
macro_line|#endif&t;/* SCSI_NCR_DYNAMIC_DMA_MAPPING */
DECL|member|h
r_struct
id|m_link
id|h
(braket
id|PAGE_SHIFT
op_minus
id|MEMO_SHIFT
op_plus
id|MEMO_PAGE_ORDER
op_plus
l_int|1
)braket
suffix:semicolon
DECL|typedef|m_pool_s
)brace
id|m_pool_s
suffix:semicolon
DECL|function|___m_alloc
r_static
r_void
op_star
id|___m_alloc
c_func
(paren
id|m_pool_s
op_star
id|mp
comma
r_int
id|size
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|s
op_assign
(paren
l_int|1
op_lshift
id|MEMO_SHIFT
)paren
suffix:semicolon
r_int
id|j
suffix:semicolon
id|m_addr_t
id|a
suffix:semicolon
id|m_link_s
op_star
id|h
op_assign
id|mp-&gt;h
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
(paren
id|PAGE_SIZE
op_lshift
id|MEMO_PAGE_ORDER
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
id|s
)paren
(brace
id|s
op_lshift_assign
l_int|1
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
id|j
op_assign
id|i
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|h
(braket
id|j
)braket
dot
id|next
)paren
(brace
r_if
c_cond
(paren
id|s
op_eq
(paren
id|PAGE_SIZE
op_lshift
id|MEMO_PAGE_ORDER
)paren
)paren
(brace
id|h
(braket
id|j
)braket
dot
id|next
op_assign
(paren
id|m_link_s
op_star
)paren
id|M_GETP
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|h
(braket
id|j
)braket
dot
id|next
)paren
id|h
(braket
id|j
)braket
dot
id|next-&gt;next
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
op_increment
id|j
suffix:semicolon
id|s
op_lshift_assign
l_int|1
suffix:semicolon
)brace
id|a
op_assign
(paren
id|m_addr_t
)paren
id|h
(braket
id|j
)braket
dot
id|next
suffix:semicolon
r_if
c_cond
(paren
id|a
)paren
(brace
id|h
(braket
id|j
)braket
dot
id|next
op_assign
id|h
(braket
id|j
)braket
dot
id|next-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|j
OG
id|i
)paren
(brace
id|j
op_sub_assign
l_int|1
suffix:semicolon
id|s
op_rshift_assign
l_int|1
suffix:semicolon
id|h
(braket
id|j
)braket
dot
id|next
op_assign
(paren
id|m_link_s
op_star
)paren
(paren
id|a
op_plus
id|s
)paren
suffix:semicolon
id|h
(braket
id|j
)braket
dot
id|next-&gt;next
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;___m_alloc(%d) = %p&bslash;n&quot;
comma
id|size
comma
(paren
r_void
op_star
)paren
id|a
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
r_void
op_star
)paren
id|a
suffix:semicolon
)brace
DECL|function|___m_free
r_static
r_void
id|___m_free
c_func
(paren
id|m_pool_s
op_star
id|mp
comma
r_void
op_star
id|ptr
comma
r_int
id|size
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|s
op_assign
(paren
l_int|1
op_lshift
id|MEMO_SHIFT
)paren
suffix:semicolon
id|m_link_s
op_star
id|q
suffix:semicolon
id|m_addr_t
id|a
comma
id|b
suffix:semicolon
id|m_link_s
op_star
id|h
op_assign
id|mp-&gt;h
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;___m_free(%p, %d)&bslash;n&quot;
comma
id|ptr
comma
id|size
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|size
OG
(paren
id|PAGE_SIZE
op_lshift
id|MEMO_PAGE_ORDER
)paren
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
id|s
)paren
(brace
id|s
op_lshift_assign
l_int|1
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
id|a
op_assign
(paren
id|m_addr_t
)paren
id|ptr
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
macro_line|#ifdef MEMO_FREE_UNUSED
r_if
c_cond
(paren
id|s
op_eq
(paren
id|PAGE_SIZE
op_lshift
id|MEMO_PAGE_ORDER
)paren
)paren
(brace
id|M_FREEP
c_func
(paren
id|a
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
id|b
op_assign
id|a
op_xor
id|s
suffix:semicolon
id|q
op_assign
op_amp
id|h
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
id|q-&gt;next
op_logical_and
id|q-&gt;next
op_ne
(paren
id|m_link_s
op_star
)paren
id|b
)paren
(brace
id|q
op_assign
id|q-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|q-&gt;next
)paren
(brace
(paren
(paren
id|m_link_s
op_star
)paren
id|a
)paren
op_member_access_from_pointer
id|next
op_assign
id|h
(braket
id|i
)braket
dot
id|next
suffix:semicolon
id|h
(braket
id|i
)braket
dot
id|next
op_assign
(paren
id|m_link_s
op_star
)paren
id|a
suffix:semicolon
r_break
suffix:semicolon
)brace
id|q-&gt;next
op_assign
id|q-&gt;next-&gt;next
suffix:semicolon
id|a
op_assign
id|a
op_amp
id|b
suffix:semicolon
id|s
op_lshift_assign
l_int|1
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
)brace
DECL|function|__m_calloc2
r_static
r_void
op_star
id|__m_calloc2
c_func
(paren
id|m_pool_s
op_star
id|mp
comma
r_int
id|size
comma
r_char
op_star
id|name
comma
r_int
id|uflags
)paren
(brace
r_void
op_star
id|p
suffix:semicolon
id|p
op_assign
id|___m_alloc
c_func
(paren
id|mp
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_ALLOC
)paren
id|printk
(paren
l_string|&quot;new %-10s[%4d] @%p.&bslash;n&quot;
comma
id|name
comma
id|size
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|bzero
c_func
(paren
id|p
comma
id|size
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|uflags
op_amp
id|MEMO_WARN
)paren
id|printk
(paren
id|NAME53C8XX
l_string|&quot;: failed to allocate %s[%d]&bslash;n&quot;
comma
id|name
comma
id|size
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|macro|__m_calloc
mdefine_line|#define __m_calloc(mp, s, n)&t;__m_calloc2(mp, s, n, MEMO_WARN)
DECL|function|__m_free
r_static
r_void
id|__m_free
c_func
(paren
id|m_pool_s
op_star
id|mp
comma
r_void
op_star
id|ptr
comma
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_ALLOC
)paren
id|printk
(paren
l_string|&quot;freeing %-10s[%4d] @%p.&bslash;n&quot;
comma
id|name
comma
id|size
comma
id|ptr
)paren
suffix:semicolon
id|___m_free
c_func
(paren
id|mp
comma
id|ptr
comma
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * With pci bus iommu support, we use a default pool of unmapped memory &n; * for memory we donnot need to DMA from/to and one pool per pcidev for &n; * memory accessed by the PCI chip. `mp0&squot; is the default not DMAable pool.&n; */
macro_line|#ifndef&t;SCSI_NCR_DYNAMIC_DMA_MAPPING
DECL|variable|mp0
r_static
id|m_pool_s
id|mp0
suffix:semicolon
macro_line|#else
DECL|function|___mp0_getp
r_static
id|m_addr_t
id|___mp0_getp
c_func
(paren
id|m_pool_s
op_star
id|mp
)paren
(brace
id|m_addr_t
id|m
op_assign
id|GetPages
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
)paren
op_increment
id|mp-&gt;nump
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
DECL|function|___mp0_freep
r_static
r_void
id|___mp0_freep
c_func
(paren
id|m_pool_s
op_star
id|mp
comma
id|m_addr_t
id|m
)paren
(brace
id|FreePages
c_func
(paren
id|m
)paren
suffix:semicolon
op_decrement
id|mp-&gt;nump
suffix:semicolon
)brace
DECL|variable|mp0
r_static
id|m_pool_s
id|mp0
op_assign
(brace
l_int|0
comma
id|___mp0_getp
comma
id|___mp0_freep
)brace
suffix:semicolon
macro_line|#endif&t;/* SCSI_NCR_DYNAMIC_DMA_MAPPING */
multiline_comment|/*&n; * DMAable pools.&n; */
macro_line|#ifndef&t;SCSI_NCR_DYNAMIC_DMA_MAPPING
multiline_comment|/* Without pci bus iommu support, all the memory is assumed DMAable */
DECL|macro|__m_calloc_dma
mdefine_line|#define __m_calloc_dma(b, s, n)&t;&t;m_calloc(s, n)
DECL|macro|__m_free_dma
mdefine_line|#define __m_free_dma(b, p, s, n)&t;m_free(p, s, n)
DECL|macro|__vtobus
mdefine_line|#define __vtobus(b, p)&t;&t;&t;virt_to_bus(p)
macro_line|#else
multiline_comment|/*&n; * With pci bus iommu support, we maintain one pool per pcidev and a &n; * hashed reverse table for virtual to bus physical address translations.&n; */
DECL|function|___dma_getp
r_static
id|m_addr_t
id|___dma_getp
c_func
(paren
id|m_pool_s
op_star
id|mp
)paren
(brace
id|m_addr_t
id|vp
suffix:semicolon
id|m_vtob_s
op_star
id|vbp
suffix:semicolon
id|vbp
op_assign
id|__m_calloc
c_func
(paren
op_amp
id|mp0
comma
r_sizeof
(paren
op_star
id|vbp
)paren
comma
l_string|&quot;VTOB&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vbp
)paren
(brace
id|dma_addr_t
id|daddr
suffix:semicolon
id|vp
op_assign
(paren
id|m_addr_t
)paren
id|dma_alloc_coherent
c_func
(paren
id|mp-&gt;bush
comma
id|PAGE_SIZE
op_lshift
id|MEMO_PAGE_ORDER
comma
op_amp
id|daddr
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vp
)paren
(brace
r_int
id|hc
op_assign
id|VTOB_HASH_CODE
c_func
(paren
id|vp
)paren
suffix:semicolon
id|vbp-&gt;vaddr
op_assign
id|vp
suffix:semicolon
id|vbp-&gt;baddr
op_assign
id|daddr
suffix:semicolon
id|vbp-&gt;next
op_assign
id|mp-&gt;vtob
(braket
id|hc
)braket
suffix:semicolon
id|mp-&gt;vtob
(braket
id|hc
)braket
op_assign
id|vbp
suffix:semicolon
op_increment
id|mp-&gt;nump
suffix:semicolon
r_return
id|vp
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|vbp
)paren
id|__m_free
c_func
(paren
op_amp
id|mp0
comma
id|vbp
comma
r_sizeof
(paren
op_star
id|vbp
)paren
comma
l_string|&quot;VTOB&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|___dma_freep
r_static
r_void
id|___dma_freep
c_func
(paren
id|m_pool_s
op_star
id|mp
comma
id|m_addr_t
id|m
)paren
(brace
id|m_vtob_s
op_star
op_star
id|vbpp
comma
op_star
id|vbp
suffix:semicolon
r_int
id|hc
op_assign
id|VTOB_HASH_CODE
c_func
(paren
id|m
)paren
suffix:semicolon
id|vbpp
op_assign
op_amp
id|mp-&gt;vtob
(braket
id|hc
)braket
suffix:semicolon
r_while
c_loop
(paren
op_star
id|vbpp
op_logical_and
(paren
op_star
id|vbpp
)paren
op_member_access_from_pointer
id|vaddr
op_ne
id|m
)paren
id|vbpp
op_assign
op_amp
(paren
op_star
id|vbpp
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
r_if
c_cond
(paren
op_star
id|vbpp
)paren
(brace
id|vbp
op_assign
op_star
id|vbpp
suffix:semicolon
op_star
id|vbpp
op_assign
(paren
op_star
id|vbpp
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|dma_free_coherent
c_func
(paren
id|mp-&gt;bush
comma
id|PAGE_SIZE
op_lshift
id|MEMO_PAGE_ORDER
comma
(paren
r_void
op_star
)paren
id|vbp-&gt;vaddr
comma
(paren
id|dma_addr_t
)paren
id|vbp-&gt;baddr
)paren
suffix:semicolon
id|__m_free
c_func
(paren
op_amp
id|mp0
comma
id|vbp
comma
r_sizeof
(paren
op_star
id|vbp
)paren
comma
l_string|&quot;VTOB&quot;
)paren
suffix:semicolon
op_decrement
id|mp-&gt;nump
suffix:semicolon
)brace
)brace
DECL|function|___get_dma_pool
r_static
r_inline
id|m_pool_s
op_star
id|___get_dma_pool
c_func
(paren
id|m_bush_t
id|bush
)paren
(brace
id|m_pool_s
op_star
id|mp
suffix:semicolon
r_for
c_loop
(paren
id|mp
op_assign
id|mp0.next
suffix:semicolon
id|mp
op_logical_and
id|mp-&gt;bush
op_ne
id|bush
suffix:semicolon
id|mp
op_assign
id|mp-&gt;next
)paren
suffix:semicolon
r_return
id|mp
suffix:semicolon
)brace
DECL|function|___cre_dma_pool
r_static
id|m_pool_s
op_star
id|___cre_dma_pool
c_func
(paren
id|m_bush_t
id|bush
)paren
(brace
id|m_pool_s
op_star
id|mp
suffix:semicolon
id|mp
op_assign
id|__m_calloc
c_func
(paren
op_amp
id|mp0
comma
r_sizeof
(paren
op_star
id|mp
)paren
comma
l_string|&quot;MPOOL&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
)paren
(brace
id|bzero
c_func
(paren
id|mp
comma
r_sizeof
(paren
op_star
id|mp
)paren
)paren
suffix:semicolon
id|mp-&gt;bush
op_assign
id|bush
suffix:semicolon
id|mp-&gt;getp
op_assign
id|___dma_getp
suffix:semicolon
id|mp-&gt;freep
op_assign
id|___dma_freep
suffix:semicolon
id|mp-&gt;next
op_assign
id|mp0.next
suffix:semicolon
id|mp0.next
op_assign
id|mp
suffix:semicolon
)brace
r_return
id|mp
suffix:semicolon
)brace
DECL|function|___del_dma_pool
r_static
r_void
id|___del_dma_pool
c_func
(paren
id|m_pool_s
op_star
id|p
)paren
(brace
r_struct
id|m_pool
op_star
op_star
id|pp
op_assign
op_amp
id|mp0.next
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pp
op_logical_and
op_star
id|pp
op_ne
id|p
)paren
id|pp
op_assign
op_amp
(paren
op_star
id|pp
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pp
)paren
(brace
op_star
id|pp
op_assign
(paren
op_star
id|pp
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|__m_free
c_func
(paren
op_amp
id|mp0
comma
id|p
comma
r_sizeof
(paren
op_star
id|p
)paren
comma
l_string|&quot;MPOOL&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|__m_calloc_dma
r_static
r_void
op_star
id|__m_calloc_dma
c_func
(paren
id|m_bush_t
id|bush
comma
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
id|u_long
id|flags
suffix:semicolon
r_struct
id|m_pool
op_star
id|mp
suffix:semicolon
r_void
op_star
id|m
op_assign
l_int|0
suffix:semicolon
id|NCR_LOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
id|mp
op_assign
id|___get_dma_pool
c_func
(paren
id|bush
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mp
)paren
id|mp
op_assign
id|___cre_dma_pool
c_func
(paren
id|bush
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
)paren
id|m
op_assign
id|__m_calloc
c_func
(paren
id|mp
comma
id|size
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_logical_and
op_logical_neg
id|mp-&gt;nump
)paren
id|___del_dma_pool
c_func
(paren
id|mp
)paren
suffix:semicolon
id|NCR_UNLOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
DECL|function|__m_free_dma
r_static
r_void
id|__m_free_dma
c_func
(paren
id|m_bush_t
id|bush
comma
r_void
op_star
id|m
comma
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
id|u_long
id|flags
suffix:semicolon
r_struct
id|m_pool
op_star
id|mp
suffix:semicolon
id|NCR_LOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
id|mp
op_assign
id|___get_dma_pool
c_func
(paren
id|bush
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
)paren
id|__m_free
c_func
(paren
id|mp
comma
id|m
comma
id|size
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_logical_and
op_logical_neg
id|mp-&gt;nump
)paren
id|___del_dma_pool
c_func
(paren
id|mp
)paren
suffix:semicolon
id|NCR_UNLOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|__vtobus
r_static
id|m_addr_t
id|__vtobus
c_func
(paren
id|m_bush_t
id|bush
comma
r_void
op_star
id|m
)paren
(brace
id|u_long
id|flags
suffix:semicolon
id|m_pool_s
op_star
id|mp
suffix:semicolon
r_int
id|hc
op_assign
id|VTOB_HASH_CODE
c_func
(paren
id|m
)paren
suffix:semicolon
id|m_vtob_s
op_star
id|vp
op_assign
l_int|0
suffix:semicolon
id|m_addr_t
id|a
op_assign
(paren
(paren
id|m_addr_t
)paren
id|m
)paren
op_amp
op_complement
id|MEMO_CLUSTER_MASK
suffix:semicolon
id|NCR_LOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
id|mp
op_assign
id|___get_dma_pool
c_func
(paren
id|bush
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
)paren
(brace
id|vp
op_assign
id|mp-&gt;vtob
(braket
id|hc
)braket
suffix:semicolon
r_while
c_loop
(paren
id|vp
op_logical_and
(paren
id|m_addr_t
)paren
id|vp-&gt;vaddr
op_ne
id|a
)paren
id|vp
op_assign
id|vp-&gt;next
suffix:semicolon
)brace
id|NCR_UNLOCK_DRIVER
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|vp
ques
c_cond
id|vp-&gt;baddr
op_plus
(paren
(paren
(paren
id|m_addr_t
)paren
id|m
)paren
op_minus
id|a
)paren
suffix:colon
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;/* SCSI_NCR_DYNAMIC_DMA_MAPPING */
DECL|macro|_m_calloc_dma
mdefine_line|#define _m_calloc_dma(np, s, n)&t;&t;__m_calloc_dma(np-&gt;dev, s, n)
DECL|macro|_m_free_dma
mdefine_line|#define _m_free_dma(np, p, s, n)&t;__m_free_dma(np-&gt;dev, p, s, n)
DECL|macro|m_calloc_dma
mdefine_line|#define m_calloc_dma(s, n)&t;&t;_m_calloc_dma(np, s, n)
DECL|macro|m_free_dma
mdefine_line|#define m_free_dma(p, s, n)&t;&t;_m_free_dma(np, p, s, n)
DECL|macro|_vtobus
mdefine_line|#define _vtobus(np, p)&t;&t;&t;__vtobus(np-&gt;dev, p)
DECL|macro|vtobus
mdefine_line|#define vtobus(p)&t;&t;&t;_vtobus(np, p)
multiline_comment|/*&n; *  Deal with DMA mapping/unmapping.&n; */
macro_line|#ifndef SCSI_NCR_DYNAMIC_DMA_MAPPING
multiline_comment|/* Linux versions prior to pci bus iommu kernel interface */
DECL|macro|__unmap_scsi_data
mdefine_line|#define __unmap_scsi_data(dev, cmd)&t;do {; } while (0)
DECL|macro|__map_scsi_single_data
mdefine_line|#define __map_scsi_single_data(dev, cmd) (__vtobus(dev,(cmd)-&gt;request_buffer))
DECL|macro|__map_scsi_sg_data
mdefine_line|#define __map_scsi_sg_data(dev, cmd)&t;((cmd)-&gt;use_sg)
DECL|macro|__sync_scsi_data_for_cpu
mdefine_line|#define __sync_scsi_data_for_cpu(dev, cmd)&t;do {; } while (0)
DECL|macro|__sync_scsi_data_for_device
mdefine_line|#define __sync_scsi_data_for_device(dev, cmd)&t;do {; } while (0)
DECL|macro|scsi_sg_dma_address
mdefine_line|#define scsi_sg_dma_address(sc)&t;&t;vtobus((sc)-&gt;address)
DECL|macro|scsi_sg_dma_len
mdefine_line|#define scsi_sg_dma_len(sc)&t;&t;((sc)-&gt;length)
macro_line|#else
multiline_comment|/* Linux version with pci bus iommu kernel interface */
multiline_comment|/* To keep track of the dma mapping (sg/single) that has been set */
DECL|macro|__data_mapped
mdefine_line|#define __data_mapped&t;SCp.phase
DECL|macro|__data_mapping
mdefine_line|#define __data_mapping&t;SCp.have_data_in
DECL|function|__unmap_scsi_data
r_static
r_void
id|__unmap_scsi_data
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_enum
id|dma_data_direction
id|dma_dir
op_assign
(paren
r_enum
id|dma_data_direction
)paren
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd-&gt;__data_mapped
)paren
(brace
r_case
l_int|2
suffix:colon
id|dma_unmap_sg
c_func
(paren
id|dev
comma
id|cmd-&gt;buffer
comma
id|cmd-&gt;use_sg
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|dma_unmap_single
c_func
(paren
id|dev
comma
id|cmd-&gt;__data_mapping
comma
id|cmd-&gt;request_bufflen
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cmd-&gt;__data_mapped
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|__map_scsi_single_data
r_static
id|u_long
id|__map_scsi_single_data
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|dma_addr_t
id|mapping
suffix:semicolon
r_enum
id|dma_data_direction
id|dma_dir
op_assign
(paren
r_enum
id|dma_data_direction
)paren
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|mapping
op_assign
id|dma_map_single
c_func
(paren
id|dev
comma
id|cmd-&gt;request_buffer
comma
id|cmd-&gt;request_bufflen
comma
id|dma_dir
)paren
suffix:semicolon
id|cmd-&gt;__data_mapped
op_assign
l_int|1
suffix:semicolon
id|cmd-&gt;__data_mapping
op_assign
id|mapping
suffix:semicolon
r_return
id|mapping
suffix:semicolon
)brace
DECL|function|__map_scsi_sg_data
r_static
r_int
id|__map_scsi_sg_data
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|use_sg
suffix:semicolon
r_enum
id|dma_data_direction
id|dma_dir
op_assign
(paren
r_enum
id|dma_data_direction
)paren
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;use_sg
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|use_sg
op_assign
id|dma_map_sg
c_func
(paren
id|dev
comma
id|cmd-&gt;buffer
comma
id|cmd-&gt;use_sg
comma
id|dma_dir
)paren
suffix:semicolon
id|cmd-&gt;__data_mapped
op_assign
l_int|2
suffix:semicolon
id|cmd-&gt;__data_mapping
op_assign
id|use_sg
suffix:semicolon
r_return
id|use_sg
suffix:semicolon
)brace
DECL|function|__sync_scsi_data_for_cpu
r_static
r_void
id|__sync_scsi_data_for_cpu
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_enum
id|dma_data_direction
id|dma_dir
op_assign
(paren
r_enum
id|dma_data_direction
)paren
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd-&gt;__data_mapped
)paren
(brace
r_case
l_int|2
suffix:colon
id|dma_sync_sg_for_cpu
c_func
(paren
id|dev
comma
id|cmd-&gt;buffer
comma
id|cmd-&gt;use_sg
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|dma_sync_single_for_cpu
c_func
(paren
id|dev
comma
id|cmd-&gt;__data_mapping
comma
id|cmd-&gt;request_bufflen
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|__sync_scsi_data_for_device
r_static
r_void
id|__sync_scsi_data_for_device
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_enum
id|dma_data_direction
id|dma_dir
op_assign
(paren
r_enum
id|dma_data_direction
)paren
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd-&gt;__data_mapped
)paren
(brace
r_case
l_int|2
suffix:colon
id|dma_sync_sg_for_device
c_func
(paren
id|dev
comma
id|cmd-&gt;buffer
comma
id|cmd-&gt;use_sg
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|dma_sync_single_for_device
c_func
(paren
id|dev
comma
id|cmd-&gt;__data_mapping
comma
id|cmd-&gt;request_bufflen
comma
id|dma_dir
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|macro|scsi_sg_dma_address
mdefine_line|#define scsi_sg_dma_address(sc)&t;&t;sg_dma_address(sc)
DECL|macro|scsi_sg_dma_len
mdefine_line|#define scsi_sg_dma_len(sc)&t;&t;sg_dma_len(sc)
macro_line|#endif&t;/* SCSI_NCR_DYNAMIC_DMA_MAPPING */
DECL|macro|unmap_scsi_data
mdefine_line|#define unmap_scsi_data(np, cmd)&t;__unmap_scsi_data(np-&gt;dev, cmd)
DECL|macro|map_scsi_single_data
mdefine_line|#define map_scsi_single_data(np, cmd)&t;__map_scsi_single_data(np-&gt;dev, cmd)
DECL|macro|map_scsi_sg_data
mdefine_line|#define map_scsi_sg_data(np, cmd)&t;__map_scsi_sg_data(np-&gt;dev, cmd)
DECL|macro|sync_scsi_data_for_cpu
mdefine_line|#define sync_scsi_data_for_cpu(np, cmd)&t;__sync_scsi_data_for_cpu(np-&gt;dev, cmd)
DECL|macro|sync_scsi_data_for_device
mdefine_line|#define sync_scsi_data_for_device(np, cmd) __sync_scsi_data_for_device(np-&gt;dev, cmd)
multiline_comment|/*==========================================================&n;**&n;**&t;SCSI data transfer direction&n;**&n;**&t;Until some linux kernel version near 2.3.40, &n;**&t;low-level scsi drivers were not told about data &n;**&t;transfer direction. We check the existence of this &n;**&t;feature that has been expected for a _long_ time by &n;**&t;all SCSI driver developers by just testing against &n;**&t;the definition of SCSI_DATA_UNKNOWN. Indeed this is &n;**&t;a hack, but testing against a kernel version would &n;**&t;have been a shame. ;-)&n;**&n;**==========================================================&n;*/
macro_line|#ifdef&t;SCSI_DATA_UNKNOWN
DECL|macro|scsi_data_direction
mdefine_line|#define scsi_data_direction(cmd)&t;(cmd-&gt;sc_data_direction)
macro_line|#else
DECL|macro|SCSI_DATA_UNKNOWN
mdefine_line|#define&t;SCSI_DATA_UNKNOWN&t;0
DECL|macro|SCSI_DATA_WRITE
mdefine_line|#define&t;SCSI_DATA_WRITE&t;&t;1
DECL|macro|SCSI_DATA_READ
mdefine_line|#define&t;SCSI_DATA_READ&t;&t;2
DECL|macro|SCSI_DATA_NONE
mdefine_line|#define&t;SCSI_DATA_NONE&t;&t;3
DECL|function|scsi_data_direction
r_static
id|__inline__
r_int
id|scsi_data_direction
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|direction
suffix:semicolon
r_switch
c_cond
(paren
(paren
r_int
)paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|0x08
suffix:colon
multiline_comment|/*&t;READ(6)&t;&t;&t;&t;08 */
r_case
l_int|0x28
suffix:colon
multiline_comment|/*&t;READ(10)&t;&t;&t;28 */
r_case
l_int|0xA8
suffix:colon
multiline_comment|/*&t;READ(12)&t;&t;&t;A8 */
id|direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0A
suffix:colon
multiline_comment|/*&t;WRITE(6)&t;&t;&t;0A */
r_case
l_int|0x2A
suffix:colon
multiline_comment|/*&t;WRITE(10)&t;&t;&t;2A */
r_case
l_int|0xAA
suffix:colon
multiline_comment|/*&t;WRITE(12)&t;&t;&t;AA */
id|direction
op_assign
id|SCSI_DATA_WRITE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|direction
op_assign
id|SCSI_DATA_UNKNOWN
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|direction
suffix:semicolon
)brace
macro_line|#endif&t;/* SCSI_DATA_UNKNOWN */
multiline_comment|/*==========================================================&n;**&n;**&t;Driver setup.&n;**&n;**&t;This structure is initialized from linux config &n;**&t;options. It can be overridden at boot-up by the boot &n;**&t;command line.&n;**&n;**==========================================================&n;*/
r_static
r_struct
id|ncr_driver_setup
DECL|variable|driver_setup
id|driver_setup
op_assign
id|SCSI_NCR_DRIVER_SETUP
suffix:semicolon
macro_line|#ifdef&t;SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT
r_static
r_struct
id|ncr_driver_setup
DECL|variable|__initdata
id|driver_safe_setup
id|__initdata
op_assign
id|SCSI_NCR_DRIVER_SAFE_SETUP
suffix:semicolon
macro_line|#endif
DECL|macro|initverbose
mdefine_line|#define initverbose (driver_setup.verbose)
DECL|macro|bootverbose
mdefine_line|#define bootverbose (np-&gt;verbose)
multiline_comment|/*==========================================================&n;**&n;**&t;NVRAM detection and reading.&n;**&t; &n;**&t;Currently supported:&n;**&t;- 24C16 EEPROM with both Symbios and Tekram layout.&n;**&t;- 93C46 EEPROM with Tekram layout.&n;**&n;**==========================================================&n;*/
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
multiline_comment|/*&n; *  24C16 EEPROM reading.&n; *&n; *  GPOI0 - data in/data out&n; *  GPIO1 - clock&n; *  Symbios NVRAM wiring now also used by Tekram.&n; */
DECL|macro|SET_BIT
mdefine_line|#define SET_BIT 0
DECL|macro|CLR_BIT
mdefine_line|#define CLR_BIT 1
DECL|macro|SET_CLK
mdefine_line|#define SET_CLK 2
DECL|macro|CLR_CLK
mdefine_line|#define CLR_CLK 3
multiline_comment|/*&n; *  Set/clear data/clock bit in GPIO0&n; */
r_static
r_void
id|__init
DECL|function|S24C16_set_bit
id|S24C16_set_bit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
comma
r_int
id|bit_mode
)paren
(brace
id|UDELAY
(paren
l_int|5
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|bit_mode
)paren
(brace
r_case
id|SET_BIT
suffix:colon
op_star
id|gpreg
op_or_assign
id|write_bit
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CLR_BIT
suffix:colon
op_star
id|gpreg
op_and_assign
l_int|0xfe
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SET_CLK
suffix:colon
op_star
id|gpreg
op_or_assign
l_int|0x02
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CLR_CLK
suffix:colon
op_star
id|gpreg
op_and_assign
l_int|0xfd
suffix:semicolon
r_break
suffix:semicolon
)brace
id|OUTB
(paren
id|nc_gpreg
comma
op_star
id|gpreg
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|5
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Send START condition to NVRAM to wake it up.&n; */
DECL|function|S24C16_start
r_static
r_void
id|__init
id|S24C16_start
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
(brace
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|1
comma
id|gpreg
comma
id|SET_BIT
)paren
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|SET_CLK
)paren
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|CLR_BIT
)paren
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|CLR_CLK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Send STOP condition to NVRAM - puts NVRAM to sleep... ZZzzzz!!&n; */
DECL|function|S24C16_stop
r_static
r_void
id|__init
id|S24C16_stop
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
(brace
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|SET_CLK
)paren
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|1
comma
id|gpreg
comma
id|SET_BIT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Read or write a bit to the NVRAM,&n; *  read if GPIO0 input else write if GPIO0 output&n; */
r_static
r_void
id|__init
DECL|function|S24C16_do_bit
id|S24C16_do_bit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
)paren
(brace
id|S24C16_set_bit
c_func
(paren
id|np
comma
id|write_bit
comma
id|gpreg
comma
id|SET_BIT
)paren
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|SET_CLK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_bit
)paren
op_star
id|read_bit
op_assign
id|INB
(paren
id|nc_gpreg
)paren
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|CLR_CLK
)paren
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
id|gpreg
comma
id|CLR_BIT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Output an ACK to the NVRAM after reading,&n; *  change GPIO0 to output and when done back to an input&n; */
r_static
r_void
id|__init
DECL|function|S24C16_write_ack
id|S24C16_write_ack
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
(brace
id|OUTB
(paren
id|nc_gpcntl
comma
op_star
id|gpcntl
op_amp
l_int|0xfe
)paren
suffix:semicolon
id|S24C16_do_bit
c_func
(paren
id|np
comma
l_int|0
comma
id|write_bit
comma
id|gpreg
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
op_star
id|gpcntl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Input an ACK from NVRAM after writing,&n; *  change GPIO0 to input and when done back to an output&n; */
r_static
r_void
id|__init
DECL|function|S24C16_read_ack
id|S24C16_read_ack
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
(brace
id|OUTB
(paren
id|nc_gpcntl
comma
op_star
id|gpcntl
op_or
l_int|0x01
)paren
suffix:semicolon
id|S24C16_do_bit
c_func
(paren
id|np
comma
id|read_bit
comma
l_int|1
comma
id|gpreg
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
op_star
id|gpcntl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  WRITE a byte to the NVRAM and then get an ACK to see it was accepted OK,&n; *  GPIO0 must already be set as an output&n; */
r_static
r_void
id|__init
DECL|function|S24C16_write_byte
id|S24C16_write_byte
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|ack_data
comma
id|u_char
id|write_data
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
(brace
r_int
id|x
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|8
suffix:semicolon
id|x
op_increment
)paren
id|S24C16_do_bit
c_func
(paren
id|np
comma
l_int|0
comma
(paren
id|write_data
op_rshift
(paren
l_int|7
op_minus
id|x
)paren
)paren
op_amp
l_int|0x01
comma
id|gpreg
)paren
suffix:semicolon
id|S24C16_read_ack
c_func
(paren
id|np
comma
id|ack_data
comma
id|gpreg
comma
id|gpcntl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  READ a byte from the NVRAM and then send an ACK to say we have got it,&n; *  GPIO0 must already be set as an input&n; */
r_static
r_void
id|__init
DECL|function|S24C16_read_byte
id|S24C16_read_byte
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_data
comma
id|u_char
id|ack_data
comma
id|u_char
op_star
id|gpreg
comma
id|u_char
op_star
id|gpcntl
)paren
(brace
r_int
id|x
suffix:semicolon
id|u_char
id|read_bit
suffix:semicolon
op_star
id|read_data
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|8
suffix:semicolon
id|x
op_increment
)paren
(brace
id|S24C16_do_bit
c_func
(paren
id|np
comma
op_amp
id|read_bit
comma
l_int|1
comma
id|gpreg
)paren
suffix:semicolon
op_star
id|read_data
op_or_assign
(paren
(paren
id|read_bit
op_amp
l_int|0x01
)paren
op_lshift
(paren
l_int|7
op_minus
id|x
)paren
)paren
suffix:semicolon
)brace
id|S24C16_write_ack
c_func
(paren
id|np
comma
id|ack_data
comma
id|gpreg
comma
id|gpcntl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Read &squot;len&squot; bytes starting at &squot;offset&squot;.&n; */
r_static
r_int
id|__init
DECL|function|sym_read_S24C16_nvram
id|sym_read_S24C16_nvram
(paren
id|ncr_slot
op_star
id|np
comma
r_int
id|offset
comma
id|u_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
id|u_char
id|gpcntl
comma
id|gpreg
suffix:semicolon
id|u_char
id|old_gpcntl
comma
id|old_gpreg
suffix:semicolon
id|u_char
id|ack_data
suffix:semicolon
r_int
id|retv
op_assign
l_int|1
suffix:semicolon
r_int
id|x
suffix:semicolon
multiline_comment|/* save current state of GPCNTL and GPREG */
id|old_gpreg
op_assign
id|INB
(paren
id|nc_gpreg
)paren
suffix:semicolon
id|old_gpcntl
op_assign
id|INB
(paren
id|nc_gpcntl
)paren
suffix:semicolon
id|gpcntl
op_assign
id|old_gpcntl
op_amp
l_int|0x1c
suffix:semicolon
multiline_comment|/* set up GPREG &amp; GPCNTL to set GPIO0 and GPIO1 in to known state */
id|OUTB
(paren
id|nc_gpreg
comma
id|old_gpreg
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
id|gpcntl
)paren
suffix:semicolon
multiline_comment|/* this is to set NVRAM into a known state with GPIO0/1 both low */
id|gpreg
op_assign
id|old_gpreg
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
op_amp
id|gpreg
comma
id|CLR_CLK
)paren
suffix:semicolon
id|S24C16_set_bit
c_func
(paren
id|np
comma
l_int|0
comma
op_amp
id|gpreg
comma
id|CLR_BIT
)paren
suffix:semicolon
multiline_comment|/* now set NVRAM inactive with GPIO0/1 both high */
id|S24C16_stop
c_func
(paren
id|np
comma
op_amp
id|gpreg
)paren
suffix:semicolon
multiline_comment|/* activate NVRAM */
id|S24C16_start
c_func
(paren
id|np
comma
op_amp
id|gpreg
)paren
suffix:semicolon
multiline_comment|/* write device code and random address MSB */
id|S24C16_write_byte
c_func
(paren
id|np
comma
op_amp
id|ack_data
comma
l_int|0xa0
op_or
(paren
(paren
id|offset
op_rshift
l_int|7
)paren
op_amp
l_int|0x0e
)paren
comma
op_amp
id|gpreg
comma
op_amp
id|gpcntl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ack_data
op_amp
l_int|0x01
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* write random address LSB */
id|S24C16_write_byte
c_func
(paren
id|np
comma
op_amp
id|ack_data
comma
id|offset
op_amp
l_int|0xff
comma
op_amp
id|gpreg
comma
op_amp
id|gpcntl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ack_data
op_amp
l_int|0x01
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* regenerate START state to set up for reading */
id|S24C16_start
c_func
(paren
id|np
comma
op_amp
id|gpreg
)paren
suffix:semicolon
multiline_comment|/* rewrite device code and address MSB with read bit set (lsb = 0x01) */
id|S24C16_write_byte
c_func
(paren
id|np
comma
op_amp
id|ack_data
comma
l_int|0xa1
op_or
(paren
(paren
id|offset
op_rshift
l_int|7
)paren
op_amp
l_int|0x0e
)paren
comma
op_amp
id|gpreg
comma
op_amp
id|gpcntl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ack_data
op_amp
l_int|0x01
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* now set up GPIO0 for inputting data */
id|gpcntl
op_or_assign
l_int|0x01
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
id|gpcntl
)paren
suffix:semicolon
multiline_comment|/* input all requested data - only part of total NVRAM */
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|len
suffix:semicolon
id|x
op_increment
)paren
id|S24C16_read_byte
c_func
(paren
id|np
comma
op_amp
id|data
(braket
id|x
)braket
comma
(paren
id|x
op_eq
(paren
id|len
op_minus
l_int|1
)paren
)paren
comma
op_amp
id|gpreg
comma
op_amp
id|gpcntl
)paren
suffix:semicolon
multiline_comment|/* finally put NVRAM back in inactive mode */
id|gpcntl
op_and_assign
l_int|0xfe
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
id|gpcntl
)paren
suffix:semicolon
id|S24C16_stop
c_func
(paren
id|np
comma
op_amp
id|gpreg
)paren
suffix:semicolon
id|retv
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
multiline_comment|/* return GPIO0/1 to original states after having accessed NVRAM */
id|OUTB
(paren
id|nc_gpcntl
comma
id|old_gpcntl
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
id|old_gpreg
)paren
suffix:semicolon
r_return
id|retv
suffix:semicolon
)brace
DECL|macro|SET_BIT
macro_line|#undef SET_BIT
DECL|macro|CLR_BIT
macro_line|#undef CLR_BIT
DECL|macro|SET_CLK
macro_line|#undef SET_CLK
DECL|macro|CLR_CLK
macro_line|#undef CLR_CLK
multiline_comment|/*&n; *  Try reading Symbios NVRAM.&n; *  Return 0 if OK.&n; */
DECL|function|sym_read_Symbios_nvram
r_static
r_int
id|__init
id|sym_read_Symbios_nvram
(paren
id|ncr_slot
op_star
id|np
comma
id|Symbios_nvram
op_star
id|nvram
)paren
(brace
r_static
id|u_char
id|Symbios_trailer
(braket
l_int|6
)braket
op_assign
(brace
l_int|0xfe
comma
l_int|0xfe
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|u_char
op_star
id|data
op_assign
(paren
id|u_char
op_star
)paren
id|nvram
suffix:semicolon
r_int
id|len
op_assign
r_sizeof
(paren
op_star
id|nvram
)paren
suffix:semicolon
id|u_short
id|csum
suffix:semicolon
r_int
id|x
suffix:semicolon
multiline_comment|/* probe the 24c16 and read the SYMBIOS 24c16 area */
r_if
c_cond
(paren
id|sym_read_S24C16_nvram
(paren
id|np
comma
id|SYMBIOS_NVRAM_ADDRESS
comma
id|data
comma
id|len
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* check valid NVRAM signature, verify byte count and checksum */
r_if
c_cond
(paren
id|nvram-&gt;type
op_ne
l_int|0
op_logical_or
id|memcmp
c_func
(paren
id|nvram-&gt;trailer
comma
id|Symbios_trailer
comma
l_int|6
)paren
op_logical_or
id|nvram-&gt;byte_count
op_ne
id|len
op_minus
l_int|12
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* verify checksum */
r_for
c_loop
(paren
id|x
op_assign
l_int|6
comma
id|csum
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|len
op_minus
l_int|6
suffix:semicolon
id|x
op_increment
)paren
id|csum
op_add_assign
id|data
(braket
id|x
)braket
suffix:semicolon
r_if
c_cond
(paren
id|csum
op_ne
id|nvram-&gt;checksum
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  93C46 EEPROM reading.&n; *&n; *  GPOI0 - data in&n; *  GPIO1 - data out&n; *  GPIO2 - clock&n; *  GPIO4 - chip select&n; *&n; *  Used by Tekram.&n; */
multiline_comment|/*&n; *  Pulse clock bit in GPIO0&n; */
DECL|function|T93C46_Clk
r_static
r_void
id|__init
id|T93C46_Clk
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
(brace
id|OUTB
(paren
id|nc_gpreg
comma
op_star
id|gpreg
op_or
l_int|0x04
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|2
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
op_star
id|gpreg
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; *  Read bit from NVRAM&n; */
DECL|function|T93C46_Read_Bit
r_static
r_void
id|__init
id|T93C46_Read_Bit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
op_star
id|gpreg
)paren
(brace
id|UDELAY
(paren
l_int|2
)paren
suffix:semicolon
id|T93C46_Clk
c_func
(paren
id|np
comma
id|gpreg
)paren
suffix:semicolon
op_star
id|read_bit
op_assign
id|INB
(paren
id|nc_gpreg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Write bit to GPIO0&n; */
DECL|function|T93C46_Write_Bit
r_static
r_void
id|__init
id|T93C46_Write_Bit
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
id|write_bit
comma
id|u_char
op_star
id|gpreg
)paren
(brace
r_if
c_cond
(paren
id|write_bit
op_amp
l_int|0x01
)paren
op_star
id|gpreg
op_or_assign
l_int|0x02
suffix:semicolon
r_else
op_star
id|gpreg
op_and_assign
l_int|0xfd
suffix:semicolon
op_star
id|gpreg
op_or_assign
l_int|0x10
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
op_star
id|gpreg
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|2
)paren
suffix:semicolon
id|T93C46_Clk
c_func
(paren
id|np
comma
id|gpreg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Send STOP condition to NVRAM - puts NVRAM to sleep... ZZZzzz!!&n; */
DECL|function|T93C46_Stop
r_static
r_void
id|__init
id|T93C46_Stop
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_char
op_star
id|gpreg
)paren
(brace
op_star
id|gpreg
op_and_assign
l_int|0xef
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
op_star
id|gpreg
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|2
)paren
suffix:semicolon
id|T93C46_Clk
c_func
(paren
id|np
comma
id|gpreg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Send read command and address to NVRAM&n; */
r_static
r_void
id|__init
DECL|function|T93C46_Send_Command
id|T93C46_Send_Command
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_short
id|write_data
comma
id|u_char
op_star
id|read_bit
comma
id|u_char
op_star
id|gpreg
)paren
(brace
r_int
id|x
suffix:semicolon
multiline_comment|/* send 9 bits, start bit (1), command (2), address (6)  */
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|9
suffix:semicolon
id|x
op_increment
)paren
id|T93C46_Write_Bit
c_func
(paren
id|np
comma
(paren
id|u_char
)paren
(paren
id|write_data
op_rshift
(paren
l_int|8
op_minus
id|x
)paren
)paren
comma
id|gpreg
)paren
suffix:semicolon
op_star
id|read_bit
op_assign
id|INB
(paren
id|nc_gpreg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  READ 2 bytes from the NVRAM&n; */
r_static
r_void
id|__init
DECL|function|T93C46_Read_Word
id|T93C46_Read_Word
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_short
op_star
id|nvram_data
comma
id|u_char
op_star
id|gpreg
)paren
(brace
r_int
id|x
suffix:semicolon
id|u_char
id|read_bit
suffix:semicolon
op_star
id|nvram_data
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
l_int|16
suffix:semicolon
id|x
op_increment
)paren
(brace
id|T93C46_Read_Bit
c_func
(paren
id|np
comma
op_amp
id|read_bit
comma
id|gpreg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_bit
op_amp
l_int|0x01
)paren
op_star
id|nvram_data
op_or_assign
(paren
l_int|0x01
op_lshift
(paren
l_int|15
op_minus
id|x
)paren
)paren
suffix:semicolon
r_else
op_star
id|nvram_data
op_and_assign
op_complement
(paren
l_int|0x01
op_lshift
(paren
l_int|15
op_minus
id|x
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *  Read Tekram NvRAM data.&n; */
r_static
r_int
id|__init
DECL|function|T93C46_Read_Data
id|T93C46_Read_Data
c_func
(paren
id|ncr_slot
op_star
id|np
comma
id|u_short
op_star
id|data
comma
r_int
id|len
comma
id|u_char
op_star
id|gpreg
)paren
(brace
id|u_char
id|read_bit
suffix:semicolon
r_int
id|x
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|len
suffix:semicolon
id|x
op_increment
)paren
(brace
multiline_comment|/* output read command and address */
id|T93C46_Send_Command
c_func
(paren
id|np
comma
l_int|0x180
op_or
id|x
comma
op_amp
id|read_bit
comma
id|gpreg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_bit
op_amp
l_int|0x01
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Bad */
id|T93C46_Read_Word
c_func
(paren
id|np
comma
op_amp
id|data
(braket
id|x
)braket
comma
id|gpreg
)paren
suffix:semicolon
id|T93C46_Stop
c_func
(paren
id|np
comma
id|gpreg
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Try reading 93C46 Tekram NVRAM.&n; */
r_static
r_int
id|__init
DECL|function|sym_read_T93C46_nvram
id|sym_read_T93C46_nvram
(paren
id|ncr_slot
op_star
id|np
comma
id|Tekram_nvram
op_star
id|nvram
)paren
(brace
id|u_char
id|gpcntl
comma
id|gpreg
suffix:semicolon
id|u_char
id|old_gpcntl
comma
id|old_gpreg
suffix:semicolon
r_int
id|retv
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* save current state of GPCNTL and GPREG */
id|old_gpreg
op_assign
id|INB
(paren
id|nc_gpreg
)paren
suffix:semicolon
id|old_gpcntl
op_assign
id|INB
(paren
id|nc_gpcntl
)paren
suffix:semicolon
multiline_comment|/* set up GPREG &amp; GPCNTL to set GPIO0/1/2/4 in to known state, 0 in,&n;&t;   1/2/4 out */
id|gpreg
op_assign
id|old_gpreg
op_amp
l_int|0xe9
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
id|gpreg
)paren
suffix:semicolon
id|gpcntl
op_assign
(paren
id|old_gpcntl
op_amp
l_int|0xe9
)paren
op_or
l_int|0x09
suffix:semicolon
id|OUTB
(paren
id|nc_gpcntl
comma
id|gpcntl
)paren
suffix:semicolon
multiline_comment|/* input all of NVRAM, 64 words */
id|retv
op_assign
id|T93C46_Read_Data
c_func
(paren
id|np
comma
(paren
id|u_short
op_star
)paren
id|nvram
comma
r_sizeof
(paren
op_star
id|nvram
)paren
op_div
r_sizeof
(paren
r_int
)paren
comma
op_amp
id|gpreg
)paren
suffix:semicolon
multiline_comment|/* return GPIO0/1/2/4 to original states after having accessed NVRAM */
id|OUTB
(paren
id|nc_gpcntl
comma
id|old_gpcntl
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_gpreg
comma
id|old_gpreg
)paren
suffix:semicolon
r_return
id|retv
suffix:semicolon
)brace
multiline_comment|/*&n; *  Try reading Tekram NVRAM.&n; *  Return 0 if OK.&n; */
r_static
r_int
id|__init
DECL|function|sym_read_Tekram_nvram
id|sym_read_Tekram_nvram
(paren
id|ncr_slot
op_star
id|np
comma
id|u_short
id|device_id
comma
id|Tekram_nvram
op_star
id|nvram
)paren
(brace
id|u_char
op_star
id|data
op_assign
(paren
id|u_char
op_star
)paren
id|nvram
suffix:semicolon
r_int
id|len
op_assign
r_sizeof
(paren
op_star
id|nvram
)paren
suffix:semicolon
id|u_short
id|csum
suffix:semicolon
r_int
id|x
suffix:semicolon
r_switch
c_cond
(paren
id|device_id
)paren
(brace
r_case
id|PCI_DEVICE_ID_NCR_53C885
suffix:colon
r_case
id|PCI_DEVICE_ID_NCR_53C895
suffix:colon
r_case
id|PCI_DEVICE_ID_NCR_53C896
suffix:colon
id|x
op_assign
id|sym_read_S24C16_nvram
c_func
(paren
id|np
comma
id|TEKRAM_24C16_NVRAM_ADDRESS
comma
id|data
comma
id|len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCI_DEVICE_ID_NCR_53C875
suffix:colon
id|x
op_assign
id|sym_read_S24C16_nvram
c_func
(paren
id|np
comma
id|TEKRAM_24C16_NVRAM_ADDRESS
comma
id|data
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|x
)paren
r_break
suffix:semicolon
r_default
suffix:colon
id|x
op_assign
id|sym_read_T93C46_nvram
c_func
(paren
id|np
comma
id|nvram
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* verify checksum */
r_for
c_loop
(paren
id|x
op_assign
l_int|0
comma
id|csum
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|len
op_minus
l_int|1
suffix:semicolon
id|x
op_add_assign
l_int|2
)paren
id|csum
op_add_assign
id|data
(braket
id|x
)braket
op_plus
(paren
id|data
(braket
id|x
op_plus
l_int|1
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|csum
op_ne
l_int|0x1234
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;/* SCSI_NCR_NVRAM_SUPPORT */
multiline_comment|/*===================================================================&n;**&n;**    Detect and try to read SYMBIOS and TEKRAM NVRAM.&n;**&n;**    Data can be used to order booting of boards.&n;**&n;**    Data is saved in ncr_device structure if NVRAM found. This&n;**    is then used to find drive boot order for ncr_attach().&n;**&n;**    NVRAM data is passed to Scsi_Host_Template later during &n;**    ncr_attach() for any device set up.&n;**&n;**===================================================================&n;*/
macro_line|#ifdef SCSI_NCR_NVRAM_SUPPORT
DECL|function|ncr_get_nvram
r_static
r_void
id|__init
id|ncr_get_nvram
c_func
(paren
r_struct
id|ncr_device
op_star
id|devp
comma
id|ncr_nvram
op_star
id|nvp
)paren
(brace
id|devp-&gt;nvram
op_assign
id|nvp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nvp
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;**    Get access to chip IO registers&n;&t;*/
macro_line|#ifdef SCSI_NCR_IOMAPPED
id|request_region
c_func
(paren
id|devp-&gt;slot.io_port
comma
l_int|128
comma
id|NAME53C8XX
)paren
suffix:semicolon
id|devp-&gt;slot.base_io
op_assign
id|devp-&gt;slot.io_port
suffix:semicolon
macro_line|#else
id|devp-&gt;slot.reg
op_assign
(paren
r_struct
id|ncr_reg
op_star
)paren
id|remap_pci_mem
c_func
(paren
id|devp-&gt;slot.base_c
comma
l_int|128
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devp-&gt;slot.reg
)paren
r_return
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;**    Try to read SYMBIOS nvram.&n;&t;**    Try to read TEKRAM nvram if Symbios nvram not found.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|sym_read_Symbios_nvram
c_func
(paren
op_amp
id|devp-&gt;slot
comma
op_amp
id|nvp-&gt;data.Symbios
)paren
)paren
id|nvp-&gt;type
op_assign
id|SCSI_NCR_SYMBIOS_NVRAM
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|sym_read_Tekram_nvram
c_func
(paren
op_amp
id|devp-&gt;slot
comma
id|devp-&gt;chip.device_id
comma
op_amp
id|nvp-&gt;data.Tekram
)paren
)paren
id|nvp-&gt;type
op_assign
id|SCSI_NCR_TEKRAM_NVRAM
suffix:semicolon
r_else
(brace
id|nvp-&gt;type
op_assign
l_int|0
suffix:semicolon
id|devp-&gt;nvram
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** Release access to chip IO registers&n;&t;*/
macro_line|#ifdef SCSI_NCR_IOMAPPED
id|release_region
c_func
(paren
id|devp-&gt;slot.base_io
comma
l_int|128
)paren
suffix:semicolon
macro_line|#else
id|unmap_pci_mem
c_func
(paren
(paren
id|u_long
)paren
id|devp-&gt;slot.reg
comma
l_int|128ul
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*===================================================================&n;**&n;**&t;Display the content of NVRAM for debugging purpose.&n;**&n;**===================================================================&n;*/
macro_line|#ifdef&t;SCSI_NCR_DEBUG_NVRAM
DECL|function|ncr_display_Symbios_nvram
r_static
r_void
id|__init
id|ncr_display_Symbios_nvram
c_func
(paren
id|Symbios_nvram
op_star
id|nvram
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* display Symbios nvram host data */
id|printk
c_func
(paren
id|KERN_DEBUG
id|NAME53C8XX
l_string|&quot;: HOST ID=%d%s%s%s%s%s&bslash;n&quot;
comma
id|nvram-&gt;host_id
op_amp
l_int|0x0f
comma
(paren
id|nvram-&gt;flags
op_amp
id|SYMBIOS_SCAM_ENABLE
)paren
ques
c_cond
l_string|&quot; SCAM&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|SYMBIOS_PARITY_ENABLE
)paren
ques
c_cond
l_string|&quot; PARITY&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|SYMBIOS_VERBOSE_MSGS
)paren
ques
c_cond
l_string|&quot; VERBOSE&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|SYMBIOS_CHS_MAPPING
)paren
ques
c_cond
l_string|&quot; CHS_ALT&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags1
op_amp
id|SYMBIOS_SCAN_HI_LO
)paren
ques
c_cond
l_string|&quot; HI_LO&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
multiline_comment|/* display Symbios nvram drive data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|Symbios_target
op_star
id|tn
op_assign
op_amp
id|nvram-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
id|NAME53C8XX
l_string|&quot;-%d:%s%s%s%s WIDTH=%d SYNC=%d TMO=%d&bslash;n&quot;
comma
id|i
comma
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_DISCONNECT_ENABLE
)paren
ques
c_cond
l_string|&quot; DISC&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_SCAN_AT_BOOT_TIME
)paren
ques
c_cond
l_string|&quot; SCAN_BOOT&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_SCAN_LUNS
)paren
ques
c_cond
l_string|&quot; SCAN_LUNS&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|SYMBIOS_QUEUE_TAGS_ENABLED
)paren
ques
c_cond
l_string|&quot; TCQ&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|tn-&gt;bus_width
comma
id|tn-&gt;sync_period
op_div
l_int|4
comma
id|tn-&gt;timeout
)paren
suffix:semicolon
)brace
)brace
DECL|variable|__initdata
r_static
id|u_char
id|Tekram_boot_delay
(braket
l_int|7
)braket
id|__initdata
op_assign
(brace
l_int|3
comma
l_int|5
comma
l_int|10
comma
l_int|20
comma
l_int|30
comma
l_int|60
comma
l_int|120
)brace
suffix:semicolon
DECL|function|ncr_display_Tekram_nvram
r_static
r_void
id|__init
id|ncr_display_Tekram_nvram
c_func
(paren
id|Tekram_nvram
op_star
id|nvram
)paren
(brace
r_int
id|i
comma
id|tags
comma
id|boot_delay
suffix:semicolon
r_char
op_star
id|rem
suffix:semicolon
multiline_comment|/* display Tekram nvram host data */
id|tags
op_assign
l_int|2
op_lshift
id|nvram-&gt;max_tags_index
suffix:semicolon
id|boot_delay
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nvram-&gt;boot_delay_index
OL
l_int|6
)paren
id|boot_delay
op_assign
id|Tekram_boot_delay
(braket
id|nvram-&gt;boot_delay_index
)braket
suffix:semicolon
r_switch
c_cond
(paren
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_REMOVABLE_FLAGS
)paren
op_rshift
l_int|6
)paren
(brace
r_default
suffix:colon
r_case
l_int|0
suffix:colon
id|rem
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|rem
op_assign
l_string|&quot; REMOVABLE=boot device&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|rem
op_assign
l_string|&quot; REMOVABLE=all&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_DEBUG
id|NAME53C8XX
l_string|&quot;: HOST ID=%d%s%s%s%s%s%s%s%s%s BOOT DELAY=%d tags=%d&bslash;n&quot;
comma
id|nvram-&gt;host_id
op_amp
l_int|0x0f
comma
(paren
id|nvram-&gt;flags1
op_amp
id|SYMBIOS_SCAM_ENABLE
)paren
ques
c_cond
l_string|&quot; SCAM&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_MORE_THAN_2_DRIVES
)paren
ques
c_cond
l_string|&quot; &gt;2DRIVES&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_DRIVES_SUP_1GB
)paren
ques
c_cond
l_string|&quot; &gt;1GB&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_RESET_ON_POWER_ON
)paren
ques
c_cond
l_string|&quot; RESET&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_ACTIVE_NEGATION
)paren
ques
c_cond
l_string|&quot; ACT_NEG&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_IMMEDIATE_SEEK
)paren
ques
c_cond
l_string|&quot; IMM_SEEK&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags
op_amp
id|TEKRAM_SCAN_LUNS
)paren
ques
c_cond
l_string|&quot; SCAN_LUNS&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nvram-&gt;flags1
op_amp
id|TEKRAM_F2_F6_ENABLED
)paren
ques
c_cond
l_string|&quot; F2_F6&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|rem
comma
id|boot_delay
comma
id|tags
)paren
suffix:semicolon
multiline_comment|/* display Tekram nvram drive data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|sync
comma
id|j
suffix:semicolon
r_struct
id|Tekram_target
op_star
id|tn
op_assign
op_amp
id|nvram-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|j
op_assign
id|tn-&gt;sync_index
op_amp
l_int|0xf
suffix:semicolon
id|sync
op_assign
id|Tekram_sync
(braket
id|j
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
id|NAME53C8XX
l_string|&quot;-%d:%s%s%s%s%s%s PERIOD=%d&bslash;n&quot;
comma
id|i
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_PARITY_CHECK
)paren
ques
c_cond
l_string|&quot; PARITY&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_SYNC_NEGO
)paren
ques
c_cond
l_string|&quot; SYNC&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_DISCONNECT_ENABLE
)paren
ques
c_cond
l_string|&quot; DISC&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_START_CMD
)paren
ques
c_cond
l_string|&quot; START&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_TAGGED_COMMANDS
)paren
ques
c_cond
l_string|&quot; TCQ&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|tn-&gt;flags
op_amp
id|TEKRAM_WIDE_NEGO
)paren
ques
c_cond
l_string|&quot; WIDE&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|sync
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* SCSI_NCR_DEBUG_NVRAM */
macro_line|#endif&t;/* SCSI_NCR_NVRAM_SUPPORT */
multiline_comment|/*===================================================================&n;**&n;**&t;Utility routines that protperly return data through /proc FS.&n;**&n;**===================================================================&n;*/
macro_line|#ifdef SCSI_NCR_USER_INFO_SUPPORT
DECL|struct|info_str
r_struct
id|info_str
(brace
DECL|member|buffer
r_char
op_star
id|buffer
suffix:semicolon
DECL|member|length
r_int
id|length
suffix:semicolon
DECL|member|offset
r_int
id|offset
suffix:semicolon
DECL|member|pos
r_int
id|pos
suffix:semicolon
)brace
suffix:semicolon
DECL|function|copy_mem_info
r_static
r_void
id|copy_mem_info
c_func
(paren
r_struct
id|info_str
op_star
id|info
comma
r_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pos
op_plus
id|len
OG
id|info-&gt;length
)paren
id|len
op_assign
id|info-&gt;length
op_minus
id|info-&gt;pos
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;pos
op_plus
id|len
OL
id|info-&gt;offset
)paren
(brace
id|info-&gt;pos
op_add_assign
id|len
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;pos
OL
id|info-&gt;offset
)paren
(brace
id|data
op_add_assign
(paren
id|info-&gt;offset
op_minus
id|info-&gt;pos
)paren
suffix:semicolon
id|len
op_sub_assign
(paren
id|info-&gt;offset
op_minus
id|info-&gt;pos
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|info-&gt;buffer
op_plus
id|info-&gt;pos
comma
id|data
comma
id|len
)paren
suffix:semicolon
id|info-&gt;pos
op_add_assign
id|len
suffix:semicolon
)brace
)brace
DECL|function|copy_info
r_static
r_int
id|copy_info
c_func
(paren
r_struct
id|info_str
op_star
id|info
comma
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_char
id|buf
(braket
l_int|81
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|len
op_assign
id|vsprintf
c_func
(paren
id|buf
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
id|copy_mem_info
c_func
(paren
id|info
comma
id|buf
comma
id|len
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*===================================================================&n;**&n;**&t;Driver setup from the boot command line&n;**&n;**===================================================================&n;*/
macro_line|#ifdef MODULE
DECL|macro|ARG_SEP
mdefine_line|#define&t;ARG_SEP&t;&squot; &squot;
macro_line|#else
DECL|macro|ARG_SEP
mdefine_line|#define&t;ARG_SEP&t;&squot;,&squot;
macro_line|#endif
DECL|macro|OPT_TAGS
mdefine_line|#define OPT_TAGS&t;&t;1
DECL|macro|OPT_MASTER_PARITY
mdefine_line|#define OPT_MASTER_PARITY&t;2
DECL|macro|OPT_SCSI_PARITY
mdefine_line|#define OPT_SCSI_PARITY&t;&t;3
DECL|macro|OPT_DISCONNECTION
mdefine_line|#define OPT_DISCONNECTION&t;4
DECL|macro|OPT_SPECIAL_FEATURES
mdefine_line|#define OPT_SPECIAL_FEATURES&t;5
DECL|macro|OPT_UNUSED_1
mdefine_line|#define OPT_UNUSED_1&t;&t;6
DECL|macro|OPT_FORCE_SYNC_NEGO
mdefine_line|#define OPT_FORCE_SYNC_NEGO&t;7
DECL|macro|OPT_REVERSE_PROBE
mdefine_line|#define OPT_REVERSE_PROBE&t;8
DECL|macro|OPT_DEFAULT_SYNC
mdefine_line|#define OPT_DEFAULT_SYNC&t;9
DECL|macro|OPT_VERBOSE
mdefine_line|#define OPT_VERBOSE&t;&t;10
DECL|macro|OPT_DEBUG
mdefine_line|#define OPT_DEBUG&t;&t;11
DECL|macro|OPT_BURST_MAX
mdefine_line|#define OPT_BURST_MAX&t;&t;12
DECL|macro|OPT_LED_PIN
mdefine_line|#define OPT_LED_PIN&t;&t;13
DECL|macro|OPT_MAX_WIDE
mdefine_line|#define OPT_MAX_WIDE&t;&t;14
DECL|macro|OPT_SETTLE_DELAY
mdefine_line|#define OPT_SETTLE_DELAY&t;15
DECL|macro|OPT_DIFF_SUPPORT
mdefine_line|#define OPT_DIFF_SUPPORT&t;16
DECL|macro|OPT_IRQM
mdefine_line|#define OPT_IRQM&t;&t;17
DECL|macro|OPT_PCI_FIX_UP
mdefine_line|#define OPT_PCI_FIX_UP&t;&t;18
DECL|macro|OPT_BUS_CHECK
mdefine_line|#define OPT_BUS_CHECK&t;&t;19
DECL|macro|OPT_OPTIMIZE
mdefine_line|#define OPT_OPTIMIZE&t;&t;20
DECL|macro|OPT_RECOVERY
mdefine_line|#define OPT_RECOVERY&t;&t;21
DECL|macro|OPT_SAFE_SETUP
mdefine_line|#define OPT_SAFE_SETUP&t;&t;22
DECL|macro|OPT_USE_NVRAM
mdefine_line|#define OPT_USE_NVRAM&t;&t;23
DECL|macro|OPT_EXCLUDE
mdefine_line|#define OPT_EXCLUDE&t;&t;24
DECL|macro|OPT_HOST_ID
mdefine_line|#define OPT_HOST_ID&t;&t;25
macro_line|#ifdef SCSI_NCR_IARB_SUPPORT
DECL|macro|OPT_IARB
mdefine_line|#define OPT_IARB&t;&t;26
macro_line|#endif
DECL|variable|__initdata
r_static
r_char
id|setup_token
(braket
)braket
id|__initdata
op_assign
l_string|&quot;tags:&quot;
l_string|&quot;mpar:&quot;
l_string|&quot;spar:&quot;
l_string|&quot;disc:&quot;
l_string|&quot;specf:&quot;
l_string|&quot;ultra:&quot;
l_string|&quot;fsn:&quot;
l_string|&quot;revprob:&quot;
l_string|&quot;sync:&quot;
l_string|&quot;verb:&quot;
l_string|&quot;debug:&quot;
l_string|&quot;burst:&quot;
l_string|&quot;led:&quot;
l_string|&quot;wide:&quot;
l_string|&quot;settle:&quot;
l_string|&quot;diff:&quot;
l_string|&quot;irqm:&quot;
l_string|&quot;pcifix:&quot;
l_string|&quot;buschk:&quot;
l_string|&quot;optim:&quot;
l_string|&quot;recovery:&quot;
l_string|&quot;safe:&quot;
l_string|&quot;nvram:&quot;
l_string|&quot;excl:&quot;
l_string|&quot;hostid:&quot;
macro_line|#ifdef SCSI_NCR_IARB_SUPPORT
l_string|&quot;iarb:&quot;
macro_line|#endif
suffix:semicolon
multiline_comment|/* DONNOT REMOVE THIS &squot;;&squot; */
macro_line|#ifdef MODULE
DECL|macro|ARG_SEP
mdefine_line|#define&t;ARG_SEP&t;&squot; &squot;
macro_line|#else
DECL|macro|ARG_SEP
mdefine_line|#define&t;ARG_SEP&t;&squot;,&squot;
macro_line|#endif
DECL|function|get_setup_token
r_static
r_int
id|__init
id|get_setup_token
c_func
(paren
r_char
op_star
id|p
)paren
(brace
r_char
op_star
id|cur
op_assign
id|setup_token
suffix:semicolon
r_char
op_star
id|pc
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cur
op_ne
l_int|NULL
op_logical_and
(paren
id|pc
op_assign
id|strchr
c_func
(paren
id|cur
comma
l_char|&squot;:&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
op_increment
id|pc
suffix:semicolon
op_increment
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|p
comma
id|cur
comma
id|pc
op_minus
id|cur
)paren
)paren
r_return
id|i
suffix:semicolon
id|cur
op_assign
id|pc
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sym53c8xx__setup
r_static
r_int
id|__init
id|sym53c8xx__setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
macro_line|#ifdef SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT
r_char
op_star
id|cur
op_assign
id|str
suffix:semicolon
r_char
op_star
id|pc
comma
op_star
id|pv
suffix:semicolon
r_int
id|i
comma
id|val
comma
id|c
suffix:semicolon
r_int
id|xi
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cur
op_ne
l_int|NULL
op_logical_and
(paren
id|pc
op_assign
id|strchr
c_func
(paren
id|cur
comma
l_char|&squot;:&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_char
op_star
id|pe
suffix:semicolon
id|val
op_assign
l_int|0
suffix:semicolon
id|pv
op_assign
id|pc
suffix:semicolon
id|c
op_assign
op_star
op_increment
id|pv
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;n&squot;
)paren
id|val
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;y&squot;
)paren
id|val
op_assign
l_int|1
suffix:semicolon
r_else
id|val
op_assign
(paren
r_int
)paren
id|simple_strtoul
c_func
(paren
id|pv
comma
op_amp
id|pe
comma
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|get_setup_token
c_func
(paren
id|cur
)paren
)paren
(brace
r_case
id|OPT_TAGS
suffix:colon
id|driver_setup.default_tags
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
id|pe
op_logical_and
op_star
id|pe
op_eq
l_char|&squot;/&squot;
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pe
op_logical_and
op_star
id|pe
op_ne
id|ARG_SEP
op_logical_and
id|i
OL
r_sizeof
(paren
id|driver_setup.tag_ctrl
)paren
op_minus
l_int|1
)paren
(brace
id|driver_setup.tag_ctrl
(braket
id|i
op_increment
)braket
op_assign
op_star
id|pe
op_increment
suffix:semicolon
)brace
id|driver_setup.tag_ctrl
(braket
id|i
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OPT_MASTER_PARITY
suffix:colon
id|driver_setup.master_parity
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_SCSI_PARITY
suffix:colon
id|driver_setup.scsi_parity
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_DISCONNECTION
suffix:colon
id|driver_setup.disconnection
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_SPECIAL_FEATURES
suffix:colon
id|driver_setup.special_features
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_FORCE_SYNC_NEGO
suffix:colon
id|driver_setup.force_sync_nego
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_REVERSE_PROBE
suffix:colon
id|driver_setup.reverse_probe
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_DEFAULT_SYNC
suffix:colon
id|driver_setup.default_sync
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_VERBOSE
suffix:colon
id|driver_setup.verbose
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_DEBUG
suffix:colon
id|driver_setup.debug
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_BURST_MAX
suffix:colon
id|driver_setup.burst_max
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_LED_PIN
suffix:colon
id|driver_setup.led_pin
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_MAX_WIDE
suffix:colon
id|driver_setup.max_wide
op_assign
id|val
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_SETTLE_DELAY
suffix:colon
id|driver_setup.settle_delay
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_DIFF_SUPPORT
suffix:colon
id|driver_setup.diff_support
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_IRQM
suffix:colon
id|driver_setup.irqm
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_PCI_FIX_UP
suffix:colon
id|driver_setup.pci_fix_up
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_BUS_CHECK
suffix:colon
id|driver_setup.bus_check
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_OPTIMIZE
suffix:colon
id|driver_setup.optimize
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_RECOVERY
suffix:colon
id|driver_setup.recovery
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_USE_NVRAM
suffix:colon
id|driver_setup.use_nvram
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_SAFE_SETUP
suffix:colon
id|memcpy
c_func
(paren
op_amp
id|driver_setup
comma
op_amp
id|driver_safe_setup
comma
r_sizeof
(paren
id|driver_setup
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_EXCLUDE
suffix:colon
r_if
c_cond
(paren
id|xi
OL
id|SCSI_NCR_MAX_EXCLUDES
)paren
id|driver_setup.excludes
(braket
id|xi
op_increment
)braket
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPT_HOST_ID
suffix:colon
id|driver_setup.host_id
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef SCSI_NCR_IARB_SUPPORT
r_case
id|OPT_IARB
suffix:colon
id|driver_setup.iarb
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;sym53c8xx_setup: unexpected boot option &squot;%.*s&squot; ignored&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|pc
op_minus
id|cur
op_plus
l_int|1
)paren
comma
id|cur
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|cur
op_assign
id|strchr
c_func
(paren
id|cur
comma
id|ARG_SEP
)paren
)paren
op_ne
l_int|NULL
)paren
op_increment
id|cur
suffix:semicolon
)brace
macro_line|#endif /* SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*===================================================================&n;**&n;**&t;Get device queue depth from boot command line.&n;**&n;**===================================================================&n;*/
DECL|macro|DEF_DEPTH
mdefine_line|#define DEF_DEPTH&t;(driver_setup.default_tags)
DECL|macro|ALL_TARGETS
mdefine_line|#define ALL_TARGETS&t;-2
DECL|macro|NO_TARGET
mdefine_line|#define NO_TARGET&t;-1
DECL|macro|ALL_LUNS
mdefine_line|#define ALL_LUNS&t;-2
DECL|macro|NO_LUN
mdefine_line|#define NO_LUN&t;&t;-1
DECL|function|device_queue_depth
r_static
r_int
id|device_queue_depth
c_func
(paren
r_int
id|unit
comma
r_int
id|target
comma
r_int
id|lun
)paren
(brace
r_int
id|c
comma
id|h
comma
id|t
comma
id|u
comma
id|v
suffix:semicolon
r_char
op_star
id|p
op_assign
id|driver_setup.tag_ctrl
suffix:semicolon
r_char
op_star
id|ep
suffix:semicolon
id|h
op_assign
op_minus
l_int|1
suffix:semicolon
id|t
op_assign
id|NO_TARGET
suffix:semicolon
id|u
op_assign
id|NO_LUN
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|p
op_increment
)paren
op_ne
l_int|0
)paren
(brace
id|v
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
op_amp
id|ep
comma
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;/&squot;
suffix:colon
op_increment
id|h
suffix:semicolon
id|t
op_assign
id|ALL_TARGETS
suffix:semicolon
id|u
op_assign
id|ALL_LUNS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
r_if
c_cond
(paren
id|t
op_ne
id|target
)paren
id|t
op_assign
(paren
id|target
op_eq
id|v
)paren
ques
c_cond
id|v
suffix:colon
id|NO_TARGET
suffix:semicolon
id|u
op_assign
id|ALL_LUNS
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;u&squot;
suffix:colon
r_if
c_cond
(paren
id|u
op_ne
id|lun
)paren
id|u
op_assign
(paren
id|lun
op_eq
id|v
)paren
ques
c_cond
id|v
suffix:colon
id|NO_LUN
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;q&squot;
suffix:colon
r_if
c_cond
(paren
id|h
op_eq
id|unit
op_logical_and
(paren
id|t
op_eq
id|ALL_TARGETS
op_logical_or
id|t
op_eq
id|target
)paren
op_logical_and
(paren
id|u
op_eq
id|ALL_LUNS
op_logical_or
id|u
op_eq
id|lun
)paren
)paren
r_return
id|v
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;-&squot;
suffix:colon
id|t
op_assign
id|ALL_TARGETS
suffix:semicolon
id|u
op_assign
id|ALL_LUNS
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|p
op_assign
id|ep
suffix:semicolon
)brace
r_return
id|DEF_DEPTH
suffix:semicolon
)brace
eof
