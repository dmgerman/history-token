multiline_comment|/*&n; * NinjaSCSI-32Bi Cardbus, NinjaSCSI-32UDE PCI/CardBus SCSI driver&n; * Copyright (C) 2001, 2002, 2003&n; *      YOKOTA Hiroshi &lt;yokota@netlab.is.tsukuba.ac.jp&gt;&n; *      GOTO Masanori &lt;gotom@debian.or.jp&gt;, &lt;gotom@debian.org&gt;&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; *&n; * Revision History:&n; *   1.0: Initial Release.&n; *   1.1: Add /proc SDTR status.&n; *        Remove obsolete error handler nsp32_reset.&n; *        Some clean up.&n; *   1.2: PowerPC (big endian) support.&n; */
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &lt;scsi/scsi_ioctl.h&gt;
macro_line|#include &lt;scsi/scsi.h&gt;
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,0))
macro_line|# include &lt;linux/blk.h&gt;
macro_line|#endif
macro_line|#include &quot;nsp32.h&quot;
multiline_comment|/***********************************************************************&n; * Module parameters&n; */
DECL|variable|trans_mode
r_static
r_int
id|trans_mode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* default: BIOS */
id|MODULE_PARM
(paren
id|trans_mode
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|trans_mode
comma
l_string|&quot;transfer mode (0: BIOS(default) 1: Async 2: Ultra20M&quot;
)paren
suffix:semicolon
DECL|macro|ASYNC_MODE
mdefine_line|#define ASYNC_MODE    1
DECL|macro|ULTRA20M_MODE
mdefine_line|#define ULTRA20M_MODE 2
DECL|variable|auto_param
r_static
r_int
id|auto_param
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* default: ON */
id|MODULE_PARM
(paren
id|auto_param
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|auto_param
comma
l_string|&quot;AutoParameter mode (0: ON(default) 1: OFF)&quot;
)paren
suffix:semicolon
DECL|variable|disc_priv
r_static
r_int
id|disc_priv
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* default: OFF */
id|MODULE_PARM
(paren
id|disc_priv
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|disc_priv
comma
l_string|&quot;disconnection privilege mode (0: ON 1: OFF(default))&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;YOKOTA Hiroshi &lt;yokota@netlab.is.tsukuba.ac.jp&gt;, GOTO Masanori &lt;gotom@debian.or.jp&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Workbit NinjaSCSI-32Bi/UDE CardBus/PCI SCSI host bus adapter module&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|nsp32_release_version
r_static
r_const
r_char
op_star
id|nsp32_release_version
op_assign
l_string|&quot;1.2&quot;
suffix:semicolon
multiline_comment|/****************************************************************************&n; * Supported hardware&n; */
DECL|variable|__devinitdata
r_static
r_struct
id|pci_device_id
id|nsp32_pci_table
(braket
)braket
id|__devinitdata
op_assign
(brace
(brace
dot
id|vendor
op_assign
id|PCI_VENDOR_ID_IODATA
comma
dot
id|device
op_assign
id|PCI_DEVICE_ID_NINJASCSI_32BI_CBSC_II
comma
dot
id|subvendor
op_assign
id|PCI_ANY_ID
comma
dot
id|subdevice
op_assign
id|PCI_ANY_ID
comma
dot
id|driver_data
op_assign
id|MODEL_IODATA
comma
)brace
comma
(brace
dot
id|vendor
op_assign
id|PCI_VENDOR_ID_WORKBIT
comma
dot
id|device
op_assign
id|PCI_DEVICE_ID_NINJASCSI_32BI_KME
comma
dot
id|subvendor
op_assign
id|PCI_ANY_ID
comma
dot
id|subdevice
op_assign
id|PCI_ANY_ID
comma
dot
id|driver_data
op_assign
id|MODEL_KME
comma
)brace
comma
(brace
dot
id|vendor
op_assign
id|PCI_VENDOR_ID_WORKBIT
comma
dot
id|device
op_assign
id|PCI_DEVICE_ID_NINJASCSI_32BI_WBT
comma
dot
id|subvendor
op_assign
id|PCI_ANY_ID
comma
dot
id|subdevice
op_assign
id|PCI_ANY_ID
comma
dot
id|driver_data
op_assign
id|MODEL_WORKBIT
comma
)brace
comma
(brace
dot
id|vendor
op_assign
id|PCI_VENDOR_ID_WORKBIT
comma
dot
id|device
op_assign
id|PCI_DEVICE_ID_WORKBIT_STANDARD
comma
dot
id|subvendor
op_assign
id|PCI_ANY_ID
comma
dot
id|subdevice
op_assign
id|PCI_ANY_ID
comma
dot
id|driver_data
op_assign
id|MODEL_PCI_WORKBIT
comma
)brace
comma
(brace
dot
id|vendor
op_assign
id|PCI_VENDOR_ID_WORKBIT
comma
dot
id|device
op_assign
id|PCI_DEVICE_ID_NINJASCSI_32BI_LOGITEC
comma
dot
id|subvendor
op_assign
id|PCI_ANY_ID
comma
dot
id|subdevice
op_assign
id|PCI_ANY_ID
comma
dot
id|driver_data
op_assign
id|MODEL_LOGITEC
comma
)brace
comma
(brace
dot
id|vendor
op_assign
id|PCI_VENDOR_ID_WORKBIT
comma
dot
id|device
op_assign
id|PCI_DEVICE_ID_NINJASCSI_32BIB_LOGITEC
comma
dot
id|subvendor
op_assign
id|PCI_ANY_ID
comma
dot
id|subdevice
op_assign
id|PCI_ANY_ID
comma
dot
id|driver_data
op_assign
id|MODEL_PCI_LOGITEC
comma
)brace
comma
(brace
dot
id|vendor
op_assign
id|PCI_VENDOR_ID_WORKBIT
comma
dot
id|device
op_assign
id|PCI_DEVICE_ID_NINJASCSI_32UDE_MELCO
comma
dot
id|subvendor
op_assign
id|PCI_ANY_ID
comma
dot
id|subdevice
op_assign
id|PCI_ANY_ID
comma
dot
id|driver_data
op_assign
id|MODEL_PCI_MELCO
comma
)brace
comma
(brace
dot
id|vendor
op_assign
id|PCI_VENDOR_ID_WORKBIT
comma
dot
id|device
op_assign
id|PCI_DEVICE_ID_NINJASCSI_32UDE_MELCO_II
comma
dot
id|subvendor
op_assign
id|PCI_ANY_ID
comma
dot
id|subdevice
op_assign
id|PCI_ANY_ID
comma
dot
id|driver_data
op_assign
id|MODEL_PCI_MELCO
comma
)brace
comma
(brace
l_int|0
comma
l_int|0
comma
)brace
comma
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|pci
comma
id|nsp32_pci_table
)paren
suffix:semicolon
DECL|variable|nsp32_data_base
r_static
id|nsp32_hw_data
id|nsp32_data_base
suffix:semicolon
multiline_comment|/* probe &lt;-&gt; detect glue */
multiline_comment|/*&n; * Period/AckWidth speed conversion table&n; *&n; * Note: This period/ackwidth speed table must be in descending order.&n; */
DECL|variable|nsp32_sync_table_40M
r_static
id|nsp32_sync_table
id|nsp32_sync_table_40M
(braket
)braket
op_assign
(brace
multiline_comment|/* {PNo, AW,   SP,   EP, SREQ smpl}  Speed(MB/s) Period AckWidth */
(brace
l_int|0x1
comma
l_int|0
comma
l_int|0x0c
comma
l_int|0x0c
comma
id|SMPL_40M
)brace
comma
multiline_comment|/*  20.0 :  50ns,  25ns */
(brace
l_int|0x2
comma
l_int|0
comma
l_int|0x0d
comma
l_int|0x18
comma
id|SMPL_40M
)brace
comma
multiline_comment|/*  13.3 :  75ns,  25ns */
(brace
l_int|0x3
comma
l_int|1
comma
l_int|0x19
comma
l_int|0x19
comma
id|SMPL_40M
)brace
comma
multiline_comment|/*  10.0 : 100ns,  50ns */
(brace
l_int|0x4
comma
l_int|1
comma
l_int|0x1a
comma
l_int|0x1f
comma
id|SMPL_20M
)brace
comma
multiline_comment|/*   8.0 : 125ns,  50ns */
(brace
l_int|0x5
comma
l_int|2
comma
l_int|0x20
comma
l_int|0x25
comma
id|SMPL_20M
)brace
comma
multiline_comment|/*   6.7 : 150ns,  75ns */
(brace
l_int|0x6
comma
l_int|2
comma
l_int|0x26
comma
l_int|0x31
comma
id|SMPL_20M
)brace
comma
multiline_comment|/*   5.7 : 175ns,  75ns */
(brace
l_int|0x7
comma
l_int|3
comma
l_int|0x32
comma
l_int|0x32
comma
id|SMPL_20M
)brace
comma
multiline_comment|/*   5.0 : 200ns, 100ns */
(brace
l_int|0x8
comma
l_int|3
comma
l_int|0x33
comma
l_int|0x38
comma
id|SMPL_10M
)brace
comma
multiline_comment|/*   4.4 : 225ns, 100ns */
(brace
l_int|0x9
comma
l_int|3
comma
l_int|0x39
comma
l_int|0x3e
comma
id|SMPL_10M
)brace
comma
multiline_comment|/*   4.0 : 250ns, 100ns */
)brace
suffix:semicolon
DECL|variable|nsp32_sync_table_20M
r_static
id|nsp32_sync_table
id|nsp32_sync_table_20M
(braket
)braket
op_assign
(brace
(brace
l_int|0x1
comma
l_int|0
comma
l_int|0x19
comma
l_int|0x19
comma
id|SMPL_40M
)brace
comma
multiline_comment|/* 10.0 : 100ns,  50ns */
(brace
l_int|0x2
comma
l_int|0
comma
l_int|0x1a
comma
l_int|0x25
comma
id|SMPL_20M
)brace
comma
multiline_comment|/*  6.7 : 150ns,  50ns */
(brace
l_int|0x3
comma
l_int|1
comma
l_int|0x26
comma
l_int|0x32
comma
id|SMPL_20M
)brace
comma
multiline_comment|/*  5.0 : 200ns, 100ns */
(brace
l_int|0x4
comma
l_int|1
comma
l_int|0x33
comma
l_int|0x3e
comma
id|SMPL_10M
)brace
comma
multiline_comment|/*  4.0 : 250ns, 100ns */
(brace
l_int|0x5
comma
l_int|2
comma
l_int|0x3f
comma
l_int|0x4b
comma
id|SMPL_10M
)brace
comma
multiline_comment|/*  3.3 : 300ns, 150ns */
(brace
l_int|0x6
comma
l_int|2
comma
l_int|0x4c
comma
l_int|0x57
comma
id|SMPL_10M
)brace
comma
multiline_comment|/*  2.8 : 350ns, 150ns */
(brace
l_int|0x7
comma
l_int|3
comma
l_int|0x58
comma
l_int|0x64
comma
id|SMPL_10M
)brace
comma
multiline_comment|/*  2.5 : 400ns, 200ns */
(brace
l_int|0x8
comma
l_int|3
comma
l_int|0x65
comma
l_int|0x70
comma
id|SMPL_10M
)brace
comma
multiline_comment|/*  2.2 : 450ns, 200ns */
(brace
l_int|0x9
comma
l_int|3
comma
l_int|0x71
comma
l_int|0x7d
comma
id|SMPL_10M
)brace
comma
multiline_comment|/*  2.0 : 500ns, 200ns */
)brace
suffix:semicolon
DECL|variable|nsp32_sync_table_pci
r_static
id|nsp32_sync_table
id|nsp32_sync_table_pci
(braket
)braket
op_assign
(brace
(brace
l_int|0x1
comma
l_int|0
comma
l_int|0x0c
comma
l_int|0x0f
comma
id|SMPL_40M
)brace
comma
multiline_comment|/* 16.6 :  60ns,  30ns */
(brace
l_int|0x2
comma
l_int|0
comma
l_int|0x10
comma
l_int|0x16
comma
id|SMPL_40M
)brace
comma
multiline_comment|/* 11.1 :  90ns,  30ns */
(brace
l_int|0x3
comma
l_int|1
comma
l_int|0x17
comma
l_int|0x1e
comma
id|SMPL_20M
)brace
comma
multiline_comment|/*  8.3 : 120ns,  60ns */
(brace
l_int|0x4
comma
l_int|1
comma
l_int|0x1f
comma
l_int|0x25
comma
id|SMPL_20M
)brace
comma
multiline_comment|/*  6.7 : 150ns,  60ns */
(brace
l_int|0x5
comma
l_int|2
comma
l_int|0x26
comma
l_int|0x2d
comma
id|SMPL_20M
)brace
comma
multiline_comment|/*  5.6 : 180ns,  90ns */
(brace
l_int|0x6
comma
l_int|2
comma
l_int|0x2e
comma
l_int|0x34
comma
id|SMPL_10M
)brace
comma
multiline_comment|/*  4.8 : 210ns,  90ns */
(brace
l_int|0x7
comma
l_int|3
comma
l_int|0x35
comma
l_int|0x3c
comma
id|SMPL_10M
)brace
comma
multiline_comment|/*  4.2 : 240ns, 120ns */
(brace
l_int|0x8
comma
l_int|3
comma
l_int|0x3d
comma
l_int|0x43
comma
id|SMPL_10M
)brace
comma
multiline_comment|/*  3.7 : 270ns, 120ns */
(brace
l_int|0x9
comma
l_int|3
comma
l_int|0x44
comma
l_int|0x4b
comma
id|SMPL_10M
)brace
comma
multiline_comment|/*  3.3 : 300ns, 120ns */
)brace
suffix:semicolon
multiline_comment|/*&n; * function declaration&n; */
multiline_comment|/* module entry point */
r_static
r_int
id|__devinit
id|nsp32_probe
(paren
r_struct
id|pci_dev
op_star
comma
r_const
r_struct
id|pci_device_id
op_star
)paren
suffix:semicolon
r_static
r_void
id|__devexit
id|nsp32_remove
c_func
(paren
r_struct
id|pci_dev
op_star
)paren
suffix:semicolon
r_static
r_int
id|__init
id|init_nsp32
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|__exit
id|exit_nsp32
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* struct Scsi_Host_Template */
macro_line|#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,5,73))
r_static
r_int
id|nsp32_proc_info
(paren
r_struct
id|Scsi_Host
op_star
comma
r_char
op_star
comma
r_char
op_star
op_star
comma
id|off_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
macro_line|#else
r_static
r_int
id|nsp32_proc_info
(paren
r_char
op_star
comma
r_char
op_star
op_star
comma
id|off_t
comma
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,5,73))
r_static
r_int
id|nsp32_detect
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
suffix:semicolon
macro_line|#else
r_static
r_int
id|nsp32_detect
(paren
id|Scsi_Host_Template
op_star
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
id|nsp32_queuecommand
c_func
(paren
id|Scsi_Cmnd
op_star
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
suffix:semicolon
r_static
r_const
r_char
op_star
id|nsp32_info
(paren
r_struct
id|Scsi_Host
op_star
)paren
suffix:semicolon
r_static
r_int
id|nsp32_release
(paren
r_struct
id|Scsi_Host
op_star
)paren
suffix:semicolon
multiline_comment|/* SCSI error handler */
r_static
r_int
id|nsp32_eh_abort
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
r_static
r_int
id|nsp32_eh_bus_reset
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
r_static
r_int
id|nsp32_eh_host_reset
c_func
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
multiline_comment|/* generate SCSI message */
r_static
r_void
id|nsp32_build_identify
c_func
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
r_static
r_void
id|nsp32_build_nop
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
r_static
r_void
id|nsp32_build_reject
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
r_static
r_void
id|nsp32_build_sdtr
(paren
id|Scsi_Cmnd
op_star
comma
r_int
r_char
comma
r_int
r_char
)paren
suffix:semicolon
multiline_comment|/* SCSI message handler */
r_static
r_int
id|nsp32_busfree_occur
c_func
(paren
id|Scsi_Cmnd
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|nsp32_msgout_occur
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
r_static
r_void
id|nsp32_msgin_occur
(paren
id|Scsi_Cmnd
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_int
id|nsp32_setup_sg_table
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
r_static
r_int
id|nsp32_selection_autopara
c_func
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
r_static
r_int
id|nsp32_selection_autoscsi
c_func
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
r_static
r_void
id|nsp32_scsi_done
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
r_static
r_int
id|nsp32_arbitration
(paren
id|Scsi_Cmnd
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_int
id|nsp32_reselection
(paren
id|Scsi_Cmnd
op_star
comma
r_int
r_char
)paren
suffix:semicolon
r_static
r_void
id|nsp32_adjust_busfree
(paren
id|Scsi_Cmnd
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|nsp32_restart_autoscsi
(paren
id|Scsi_Cmnd
op_star
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* SCSI SDTR */
r_static
r_void
id|nsp32_analyze_sdtr
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
r_static
r_int
id|nsp32_search_period_entry
c_func
(paren
id|nsp32_hw_data
op_star
comma
id|nsp32_target
op_star
comma
r_int
r_char
)paren
suffix:semicolon
r_static
r_void
id|nsp32_set_async
(paren
id|nsp32_hw_data
op_star
comma
id|nsp32_target
op_star
)paren
suffix:semicolon
r_static
r_void
id|nsp32_set_max_sync
(paren
id|nsp32_hw_data
op_star
comma
id|nsp32_target
op_star
comma
r_int
r_char
op_star
comma
r_int
r_char
op_star
)paren
suffix:semicolon
r_static
r_void
id|nsp32_set_sync_entry
(paren
id|nsp32_hw_data
op_star
comma
id|nsp32_target
op_star
comma
r_int
comma
r_int
r_char
)paren
suffix:semicolon
multiline_comment|/* SCSI bus status handler */
r_static
r_void
id|nsp32_wait_req
(paren
id|nsp32_hw_data
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|nsp32_wait_sack
(paren
id|nsp32_hw_data
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|nsp32_sack_assert
(paren
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
r_static
r_void
id|nsp32_sack_negate
(paren
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
r_static
r_void
id|nsp32_do_bus_reset
c_func
(paren
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
multiline_comment|/* hardware interrupt handler */
r_static
id|irqreturn_t
id|do_nsp32_isr
c_func
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
multiline_comment|/* initialize hardware */
r_static
r_int
id|nsp32hw_init
c_func
(paren
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
multiline_comment|/* EEPROM handler */
r_static
r_int
id|nsp32_getprom_param
(paren
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
r_static
r_int
id|nsp32_getprom_at24
(paren
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
r_static
r_int
id|nsp32_getprom_c16
(paren
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
r_static
r_void
id|nsp32_prom_start
(paren
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
r_static
r_void
id|nsp32_prom_stop
(paren
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
r_static
r_int
id|nsp32_prom_read
(paren
id|nsp32_hw_data
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|nsp32_prom_read_bit
(paren
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
r_static
r_void
id|nsp32_prom_write_bit
c_func
(paren
id|nsp32_hw_data
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_inline
r_void
id|nsp32_prom_set
(paren
id|nsp32_hw_data
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_static
r_inline
r_int
id|nsp32_prom_get
(paren
id|nsp32_hw_data
op_star
comma
r_int
)paren
suffix:semicolon
multiline_comment|/* debug/warning/info message */
r_static
r_void
id|nsp32_message
(paren
r_const
r_char
op_star
comma
r_int
comma
r_char
op_star
comma
r_char
op_star
comma
dot
dot
dot
)paren
suffix:semicolon
macro_line|#ifdef NSP32_DEBUG
r_static
r_void
id|nsp32_dmessage
c_func
(paren
r_const
r_char
op_star
comma
r_int
comma
r_int
comma
r_char
op_star
comma
dot
dot
dot
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * max_sectors is currently limited up to 128.&n; */
DECL|variable|nsp32_template
r_static
id|Scsi_Host_Template
id|nsp32_template
op_assign
(brace
dot
id|proc_name
op_assign
l_string|&quot;nsp32&quot;
comma
dot
id|name
op_assign
l_string|&quot;Workbit NinjaSCSI-32Bi/UDE&quot;
comma
dot
id|proc_info
op_assign
id|nsp32_proc_info
comma
dot
id|info
op_assign
id|nsp32_info
comma
dot
id|queuecommand
op_assign
id|nsp32_queuecommand
comma
dot
id|can_queue
op_assign
l_int|1
comma
dot
id|sg_tablesize
op_assign
id|NSP32_SG_SIZE
comma
dot
id|max_sectors
op_assign
l_int|128
comma
dot
id|cmd_per_lun
op_assign
l_int|1
comma
dot
id|this_id
op_assign
id|NSP32_HOST_SCSIID
comma
dot
id|use_clustering
op_assign
id|DISABLE_CLUSTERING
comma
dot
id|eh_abort_handler
op_assign
id|nsp32_eh_abort
comma
multiline_comment|/*&t;.eh_device_reset_handler&t;= NULL, */
dot
id|eh_bus_reset_handler
op_assign
id|nsp32_eh_bus_reset
comma
dot
id|eh_host_reset_handler
op_assign
id|nsp32_eh_host_reset
comma
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,74))
dot
id|detect
op_assign
id|nsp32_detect
comma
dot
id|release
op_assign
id|nsp32_release
comma
macro_line|#endif
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,2))
dot
id|use_new_eh_code
op_assign
l_int|1
comma
macro_line|#else
multiline_comment|/*&t;.highmem_io&t;&t;&t;= 1, */
macro_line|#endif
)brace
suffix:semicolon
macro_line|#include &quot;nsp32_io.h&quot;
multiline_comment|/***********************************************************************&n; * debug, error print&n; */
macro_line|#ifndef NSP32_DEBUG
DECL|macro|NSP32_DEBUG_MASK
macro_line|# define NSP32_DEBUG_MASK&t;      0x000000
DECL|macro|nsp32_msg
macro_line|# define nsp32_msg(type, args...)     nsp32_message (&quot;&quot;, 0, (type), args)
DECL|macro|nsp32_dbg
macro_line|# define nsp32_dbg(mask, args...)     /* */
macro_line|#else
DECL|macro|NSP32_DEBUG_MASK
macro_line|# define NSP32_DEBUG_MASK&t;      0xffffff
DECL|macro|nsp32_msg
macro_line|# define nsp32_msg(type, args...) &bslash;&n;&t;nsp32_message (__FUNCTION__, __LINE__, (type), args)
DECL|macro|nsp32_dbg
macro_line|# define nsp32_dbg(mask, args...) &bslash;&n;&t;nsp32_dmessage(__FUNCTION__, __LINE__, (mask), args)
macro_line|#endif
DECL|macro|NSP32_DEBUG_QUEUECOMMAND
mdefine_line|#define NSP32_DEBUG_QUEUECOMMAND&t;BIT(0)
DECL|macro|NSP32_DEBUG_REGISTER
mdefine_line|#define NSP32_DEBUG_REGISTER&t;&t;BIT(1)
DECL|macro|NSP32_DEBUG_AUTOSCSI
mdefine_line|#define NSP32_DEBUG_AUTOSCSI&t;&t;BIT(2)
DECL|macro|NSP32_DEBUG_INTR
mdefine_line|#define NSP32_DEBUG_INTR&t;&t;BIT(3)
DECL|macro|NSP32_DEBUG_SGLIST
mdefine_line|#define NSP32_DEBUG_SGLIST&t;&t;BIT(4)
DECL|macro|NSP32_DEBUG_BUSFREE
mdefine_line|#define NSP32_DEBUG_BUSFREE&t;&t;BIT(5)
DECL|macro|NSP32_DEBUG_CDB_CONTENTS
mdefine_line|#define NSP32_DEBUG_CDB_CONTENTS&t;BIT(6)
DECL|macro|NSP32_DEBUG_RESELECTION
mdefine_line|#define NSP32_DEBUG_RESELECTION&t;&t;BIT(7)
DECL|macro|NSP32_DEBUG_MSGINOCCUR
mdefine_line|#define NSP32_DEBUG_MSGINOCCUR&t;&t;BIT(8)
DECL|macro|NSP32_DEBUG_EEPROM
mdefine_line|#define NSP32_DEBUG_EEPROM&t;&t;BIT(9)
DECL|macro|NSP32_DEBUG_MSGOUTOCCUR
mdefine_line|#define NSP32_DEBUG_MSGOUTOCCUR&t;&t;BIT(10)
DECL|macro|NSP32_DEBUG_BUSRESET
mdefine_line|#define NSP32_DEBUG_BUSRESET&t;&t;BIT(11)
DECL|macro|NSP32_DEBUG_RESTART
mdefine_line|#define NSP32_DEBUG_RESTART&t;&t;BIT(12)
DECL|macro|NSP32_DEBUG_SYNC
mdefine_line|#define NSP32_DEBUG_SYNC&t;&t;BIT(13)
DECL|macro|NSP32_DEBUG_WAIT
mdefine_line|#define NSP32_DEBUG_WAIT&t;&t;BIT(14)
DECL|macro|NSP32_DEBUG_TARGETFLAG
mdefine_line|#define NSP32_DEBUG_TARGETFLAG&t;&t;BIT(15)
DECL|macro|NSP32_DEBUG_PROC
mdefine_line|#define NSP32_DEBUG_PROC&t;&t;BIT(16)
DECL|macro|NSP32_DEBUG_INIT
mdefine_line|#define NSP32_DEBUG_INIT&t;&t;BIT(17)
DECL|macro|NSP32_SPECIAL_PRINT_REGISTER
mdefine_line|#define NSP32_SPECIAL_PRINT_REGISTER&t;BIT(20)
DECL|macro|NSP32_DEBUG_BUF_LEN
mdefine_line|#define NSP32_DEBUG_BUF_LEN&t;&t;100
DECL|function|nsp32_message
r_static
r_void
id|nsp32_message
c_func
(paren
r_const
r_char
op_star
id|func
comma
r_int
id|line
comma
r_char
op_star
id|type
comma
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_char
id|buf
(braket
id|NSP32_DEBUG_BUF_LEN
)braket
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|vsnprintf
c_func
(paren
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
macro_line|#ifndef NSP32_DEBUG
id|printk
c_func
(paren
l_string|&quot;%snsp32: %s&bslash;n&quot;
comma
id|type
comma
id|buf
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;%snsp32: %s (%d): %s&bslash;n&quot;
comma
id|type
comma
id|func
comma
id|line
comma
id|buf
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef NSP32_DEBUG
DECL|function|nsp32_dmessage
r_static
r_void
id|nsp32_dmessage
c_func
(paren
r_const
r_char
op_star
id|func
comma
r_int
id|line
comma
r_int
id|mask
comma
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_char
id|buf
(braket
id|NSP32_DEBUG_BUF_LEN
)braket
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|vsnprintf
c_func
(paren
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
id|NSP32_DEBUG_MASK
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;nsp32-debug: 0x%x %s (%d): %s&bslash;n&quot;
comma
id|mask
comma
id|func
comma
id|line
comma
id|buf
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#ifdef NSP32_DEBUG
macro_line|# include &quot;nsp32_debug.c&quot;
macro_line|#else
DECL|macro|show_command
macro_line|# define show_command(arg)   /* */
DECL|macro|show_busphase
macro_line|# define show_busphase(arg)  /* */
DECL|macro|show_autophase
macro_line|# define show_autophase(arg) /* */
macro_line|#endif
multiline_comment|/*&n; * IDENTIFY Message&n; */
DECL|function|nsp32_build_identify
r_static
r_void
id|nsp32_build_identify
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|SCpnt-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
r_int
id|pos
op_assign
id|data-&gt;msgout_len
suffix:semicolon
r_int
id|mode
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* XXX: Auto DiscPriv detection is progressing... */
r_if
c_cond
(paren
id|disc_priv
op_eq
l_int|0
)paren
(brace
multiline_comment|/* mode = TRUE; */
)brace
id|data-&gt;msgoutbuf
(braket
id|pos
)braket
op_assign
id|IDENTIFY
c_func
(paren
id|mode
comma
id|SCpnt-&gt;device-&gt;lun
)paren
suffix:semicolon
id|pos
op_increment
suffix:semicolon
id|data-&gt;msgout_len
op_assign
id|pos
suffix:semicolon
)brace
multiline_comment|/*&n; * SDTR Message Routine&n; */
DECL|function|nsp32_build_sdtr
r_static
r_void
id|nsp32_build_sdtr
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
r_char
id|period
comma
r_int
r_char
id|offset
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|SCpnt-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
r_int
id|pos
op_assign
id|data-&gt;msgout_len
suffix:semicolon
id|data-&gt;msgoutbuf
(braket
id|pos
)braket
op_assign
id|EXTENDED_MESSAGE
suffix:semicolon
id|pos
op_increment
suffix:semicolon
id|data-&gt;msgoutbuf
(braket
id|pos
)braket
op_assign
id|EXTENDED_SDTR_LEN
suffix:semicolon
id|pos
op_increment
suffix:semicolon
id|data-&gt;msgoutbuf
(braket
id|pos
)braket
op_assign
id|EXTENDED_SDTR
suffix:semicolon
id|pos
op_increment
suffix:semicolon
id|data-&gt;msgoutbuf
(braket
id|pos
)braket
op_assign
id|period
suffix:semicolon
id|pos
op_increment
suffix:semicolon
id|data-&gt;msgoutbuf
(braket
id|pos
)braket
op_assign
id|offset
suffix:semicolon
id|pos
op_increment
suffix:semicolon
id|data-&gt;msgout_len
op_assign
id|pos
suffix:semicolon
)brace
multiline_comment|/*&n; * No Operation Message&n; */
DECL|function|nsp32_build_nop
r_static
r_void
id|nsp32_build_nop
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|SCpnt-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
r_int
id|pos
op_assign
id|data-&gt;msgout_len
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ne
l_int|0
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;Some messages are already contained!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|data-&gt;msgoutbuf
(braket
id|pos
)braket
op_assign
id|NOP
suffix:semicolon
id|pos
op_increment
suffix:semicolon
id|data-&gt;msgout_len
op_assign
id|pos
suffix:semicolon
)brace
multiline_comment|/*&n; * Reject Message&n; */
DECL|function|nsp32_build_reject
r_static
r_void
id|nsp32_build_reject
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|SCpnt-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
r_int
id|pos
op_assign
id|data-&gt;msgout_len
suffix:semicolon
id|data-&gt;msgoutbuf
(braket
id|pos
)braket
op_assign
id|MESSAGE_REJECT
suffix:semicolon
id|pos
op_increment
suffix:semicolon
id|data-&gt;msgout_len
op_assign
id|pos
suffix:semicolon
)brace
multiline_comment|/*&n; * timer&n; */
macro_line|#if 0
r_static
r_void
id|nsp32_start_timer
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|time
)paren
(brace
r_int
r_int
id|base
op_assign
id|SCpnt-&gt;host-&gt;io_port
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;timer=%d&quot;
comma
id|time
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time
op_amp
(paren
op_complement
id|TIMER_CNT_MASK
)paren
)paren
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;timer set overflow&quot;
)paren
suffix:semicolon
)brace
id|nsp32_write2
c_func
(paren
id|base
comma
id|TIMER_SET
comma
id|time
op_amp
id|TIMER_CNT_MASK
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * set SCSI command and other parameter to asic, and start selection phase&n; */
DECL|function|nsp32_selection_autopara
r_static
r_int
id|nsp32_selection_autopara
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|SCpnt-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|base
op_assign
id|SCpnt-&gt;device-&gt;host-&gt;io_port
suffix:semicolon
r_int
r_int
id|host_id
op_assign
id|SCpnt-&gt;device-&gt;host-&gt;this_id
suffix:semicolon
r_int
r_char
id|target
op_assign
id|SCpnt-&gt;device-&gt;id
suffix:semicolon
id|nsp32_autoparam
op_star
id|param
op_assign
id|data-&gt;autoparam
suffix:semicolon
r_int
r_char
id|phase
suffix:semicolon
r_int
id|i
comma
id|ret
suffix:semicolon
r_int
r_int
id|msgout
suffix:semicolon
id|u16_le
id|s
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_AUTOSCSI
comma
l_string|&quot;in&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * check bus free&n;&t; */
id|phase
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_BUS_MONITOR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|phase
op_ne
id|BUSMON_BUS_FREE
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;bus busy&quot;
)paren
suffix:semicolon
id|show_busphase
c_func
(paren
id|phase
op_amp
id|BUSMON_PHASE_MASK
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * message out&n;&t; *&n;&t; * Note: If the range of msgout_len is 1 - 3, fill scsi_msgout.&n;&t; *       over 3 messages needs another routine.&n;&t; */
r_if
c_cond
(paren
id|data-&gt;msgout_len
op_eq
l_int|0
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;SCSI MsgOut without any message!&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|data-&gt;msgout_len
OG
l_int|0
op_logical_and
id|data-&gt;msgout_len
op_le
l_int|3
)paren
(brace
id|msgout
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|data-&gt;msgout_len
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * the sending order of the message is:&n;&t;&t;&t; *  MCNT 3: MSG#0 -&gt; MSG#1 -&gt; MSG#2&n;&t;&t;&t; *  MCNT 2:          MSG#1 -&gt; MSG#2&n;&t;&t;&t; *  MCNT 1:                   MSG#2    &n;&t;&t;&t; */
id|msgout
op_rshift_assign
l_int|8
suffix:semicolon
id|msgout
op_or_assign
(paren
(paren
r_int
r_int
)paren
(paren
id|data-&gt;msgoutbuf
(braket
id|i
)braket
)paren
op_lshift
l_int|24
)paren
suffix:semicolon
)brace
id|msgout
op_or_assign
id|MV_VALID
suffix:semicolon
multiline_comment|/* MV valid */
id|msgout
op_or_assign
(paren
r_int
r_int
)paren
id|data-&gt;msgout_len
suffix:semicolon
multiline_comment|/* len */
)brace
r_else
(brace
multiline_comment|/* data-&gt;msgout_len &gt; 3 */
id|msgout
op_assign
l_int|0
suffix:semicolon
)brace
singleline_comment|// nsp_dbg(NSP32_DEBUG_AUTOSCSI, &quot;sel time out=0x%x&bslash;n&quot;, nsp32_read2(base, SEL_TIME_OUT));
singleline_comment|// nsp32_write2(base, SEL_TIME_OUT,   SEL_TIMEOUT_TIME);
multiline_comment|/*&n;&t; * setup asic parameter&n;&t; */
id|memset
c_func
(paren
id|param
comma
l_int|0
comma
r_sizeof
(paren
id|nsp32_autoparam
)paren
)paren
suffix:semicolon
multiline_comment|/* cdb */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCpnt-&gt;cmd_len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|param-&gt;cdb
(braket
l_int|4
op_star
id|i
)braket
op_assign
id|SCpnt-&gt;cmnd
(braket
id|i
)braket
suffix:semicolon
)brace
multiline_comment|/* outgoing messages */
id|param-&gt;msgout
op_assign
id|cpu_to_le32
c_func
(paren
id|msgout
)paren
suffix:semicolon
multiline_comment|/* syncreg, ackwidth, target id, SREQ sampling rate */
id|param-&gt;syncreg
op_assign
id|data-&gt;cur_target-&gt;syncreg
suffix:semicolon
id|param-&gt;ackwidth
op_assign
id|data-&gt;cur_target-&gt;ackwidth
suffix:semicolon
id|param-&gt;target_id
op_assign
id|BIT
c_func
(paren
id|host_id
)paren
op_or
id|BIT
c_func
(paren
id|target
)paren
suffix:semicolon
id|param-&gt;sample_reg
op_assign
id|data-&gt;cur_target-&gt;sample_reg
suffix:semicolon
singleline_comment|// nsp32_dbg(NSP32_DEBUG_AUTOSCSI, &quot;sample rate=0x%x&bslash;n&quot;, data-&gt;cur_target-&gt;sample_reg);
multiline_comment|/* command control */
id|param-&gt;command_control
op_assign
id|cpu_to_le16
c_func
(paren
id|CLEAR_CDB_FIFO_POINTER
op_or
id|AUTOSCSI_START
op_or
id|AUTO_MSGIN_00_OR_04
op_or
id|AUTO_MSGIN_02
op_or
id|AUTO_ATN
)paren
suffix:semicolon
multiline_comment|/* transfer control */
id|s
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|data-&gt;trans_method
)paren
(brace
r_case
id|NSP32_TRANSFER_BUSMASTER
suffix:colon
id|s
op_or_assign
id|BM_START
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NSP32_TRANSFER_MMIO
suffix:colon
id|s
op_or_assign
id|CB_MMIO_MODE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NSP32_TRANSFER_PIO
suffix:colon
id|s
op_or_assign
id|CB_IO_MODE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;unknown trans_method&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * OR-ed BLIEND_MODE, FIFO intr is decreased, instead of PCI bus waits.&n;&t; * For bus master transfer, it&squot;s taken off.&n;&t; */
id|s
op_or_assign
(paren
id|TRANSFER_GO
op_or
id|ALL_COUNTER_CLR
)paren
suffix:semicolon
id|param-&gt;transfer_control
op_assign
id|cpu_to_le16
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/* sg table addr */
id|param-&gt;sgt_pointer
op_assign
id|cpu_to_le32
c_func
(paren
id|data-&gt;cur_lunt-&gt;sglun_paddr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * transfer parameter to ASIC&n;&t; */
id|nsp32_write4
c_func
(paren
id|base
comma
id|SGT_ADR
comma
id|data-&gt;auto_paddr
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|COMMAND_CONTROL
comma
id|CLEAR_CDB_FIFO_POINTER
op_or
id|AUTO_PARAMETER
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check arbitration&n;&t; */
id|ret
op_assign
id|nsp32_arbitration
c_func
(paren
id|SCpnt
comma
id|base
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Selection with AUTO SCSI (without AUTO PARAMETER)&n; */
DECL|function|nsp32_selection_autoscsi
r_static
r_int
id|nsp32_selection_autoscsi
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|SCpnt-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|base
op_assign
id|SCpnt-&gt;device-&gt;host-&gt;io_port
suffix:semicolon
r_int
r_int
id|host_id
op_assign
id|SCpnt-&gt;device-&gt;host-&gt;this_id
suffix:semicolon
r_int
r_char
id|target
op_assign
id|SCpnt-&gt;device-&gt;id
suffix:semicolon
r_int
r_char
id|phase
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
r_int
id|command
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|msgout
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|execph
suffix:semicolon
r_int
id|i
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_AUTOSCSI
comma
l_string|&quot;in&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * IRQ disable&n;&t; */
id|nsp32_write2
c_func
(paren
id|base
comma
id|IRQ_CONTROL
comma
id|IRQ_CONTROL_ALL_IRQ_MASK
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * check bus line&n;&t; */
id|phase
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_BUS_MONITOR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|phase
op_amp
id|BUSMON_BSY
)paren
op_eq
l_int|1
)paren
op_logical_or
(paren
id|phase
op_amp
id|BUSMON_SEL
)paren
op_eq
l_int|1
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;bus busy&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
id|status
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * clear execph&n;&t; */
id|execph
op_assign
id|nsp32_read2
c_func
(paren
id|base
comma
id|SCSI_EXECUTE_PHASE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * clear FIFO counter to set CDBs&n;&t; */
id|nsp32_write2
c_func
(paren
id|base
comma
id|COMMAND_CONTROL
comma
id|CLEAR_CDB_FIFO_POINTER
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set CDB0 - CDB15&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCpnt-&gt;cmd_len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|nsp32_write1
c_func
(paren
id|base
comma
id|COMMAND_DATA
comma
id|SCpnt-&gt;cmnd
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_CDB_CONTENTS
comma
l_string|&quot;CDB[0]=[0x%x]&quot;
comma
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set SCSIOUT LATCH(initiator)/TARGET(target) (OR-ed) ID&n;&t; */
id|nsp32_write1
c_func
(paren
id|base
comma
id|SCSI_OUT_LATCH_TARGET_ID
comma
id|BIT
c_func
(paren
id|host_id
)paren
op_or
id|BIT
c_func
(paren
id|target
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set SCSI MSGOUT REG&n;&t; *&n;&t; * Note: If the range of msgout_len is 1 - 3, fill scsi_msgout.&n;&t; *       over 3 messages needs another routine.&n;&t; */
r_if
c_cond
(paren
id|data-&gt;msgout_len
op_eq
l_int|0
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;SCSI MsgOut without any message!&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|status
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|data-&gt;msgout_len
OG
l_int|0
op_logical_and
id|data-&gt;msgout_len
op_le
l_int|3
)paren
(brace
id|msgout
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|data-&gt;msgout_len
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * the sending order of the message is:&n;&t;&t;&t; *  MCNT 3: MSG#0 -&gt; MSG#1 -&gt; MSG#2&n;&t;&t;&t; *  MCNT 2:          MSG#1 -&gt; MSG#2&n;&t;&t;&t; *  MCNT 1:                   MSG#2    &n;&t;&t;&t; */
id|msgout
op_rshift_assign
l_int|8
suffix:semicolon
id|msgout
op_or_assign
(paren
(paren
r_int
r_int
)paren
(paren
id|data-&gt;msgoutbuf
(braket
id|i
)braket
)paren
op_lshift
l_int|24
)paren
suffix:semicolon
)brace
id|msgout
op_or_assign
id|MV_VALID
suffix:semicolon
multiline_comment|/* MV valid */
id|msgout
op_or_assign
(paren
r_int
r_int
)paren
id|data-&gt;msgout_len
suffix:semicolon
multiline_comment|/* len */
id|nsp32_write4
c_func
(paren
id|base
comma
id|SCSI_MSG_OUT
comma
id|msgout
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* data-&gt;msgout_len &gt; 3 */
id|nsp32_write4
c_func
(paren
id|base
comma
id|SCSI_MSG_OUT
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * set selection timeout(= 250ms)&n;&t; */
id|nsp32_write2
c_func
(paren
id|base
comma
id|SEL_TIME_OUT
comma
id|SEL_TIMEOUT_TIME
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set SREQ hazard killer sampling rate&n;&t; * &n;&t; * TODO: sample_rate (BASE+0F) is 0 when internal clock = 40MHz.&n;&t; *      check other internal clock!&n;&t; */
id|nsp32_write1
c_func
(paren
id|base
comma
id|SREQ_SMPL_RATE
comma
id|data-&gt;cur_target-&gt;sample_reg
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * clear Arbit&n;&t; */
id|nsp32_write1
c_func
(paren
id|base
comma
id|SET_ARBIT
comma
id|ARBIT_CLEAR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set SYNCREG&n;&t; * Don&squot;t set BM_START_ADR before setting this register.&n;&t; */
id|nsp32_write1
c_func
(paren
id|base
comma
id|SYNC_REG
comma
id|data-&gt;cur_target-&gt;syncreg
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set ACKWIDTH&n;&t; */
id|nsp32_write1
c_func
(paren
id|base
comma
id|ACK_WIDTH
comma
id|data-&gt;cur_target-&gt;ackwidth
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_AUTOSCSI
comma
l_string|&quot;syncreg=0x%x, ackwidth=0x%x, sgtpaddr=0x%x, id=0x%x&quot;
comma
id|nsp32_read1
c_func
(paren
id|base
comma
id|SYNC_REG
)paren
comma
id|nsp32_read1
c_func
(paren
id|base
comma
id|ACK_WIDTH
)paren
comma
id|nsp32_read4
c_func
(paren
id|base
comma
id|SGT_ADR
)paren
comma
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_OUT_LATCH_TARGET_ID
)paren
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_AUTOSCSI
comma
l_string|&quot;msgout_len=%d, msgout=0x%x&quot;
comma
id|data-&gt;msgout_len
comma
id|msgout
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set SGT ADDR (physical address)&n;&t; */
id|nsp32_write4
c_func
(paren
id|base
comma
id|SGT_ADR
comma
id|data-&gt;cur_lunt-&gt;sglun_paddr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set TRANSFER CONTROL REG&n;&t; */
id|command
op_assign
l_int|0
suffix:semicolon
id|command
op_or_assign
(paren
id|TRANSFER_GO
op_or
id|ALL_COUNTER_CLR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;trans_method
op_amp
id|NSP32_TRANSFER_BUSMASTER
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;request_bufflen
OG
l_int|0
)paren
(brace
id|command
op_or_assign
id|BM_START
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|data-&gt;trans_method
op_amp
id|NSP32_TRANSFER_MMIO
)paren
(brace
id|command
op_or_assign
id|CB_MMIO_MODE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|data-&gt;trans_method
op_amp
id|NSP32_TRANSFER_PIO
)paren
(brace
id|command
op_or_assign
id|CB_IO_MODE
suffix:semicolon
)brace
id|nsp32_write2
c_func
(paren
id|base
comma
id|TRANSFER_CONTROL
comma
id|command
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * start AUTO SCSI, kick off arbitration&n;&t; */
id|command
op_assign
(paren
id|CLEAR_CDB_FIFO_POINTER
op_or
id|AUTOSCSI_START
op_or
id|AUTO_MSGIN_00_OR_04
op_or
id|AUTO_MSGIN_02
op_or
id|AUTO_ATN
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|COMMAND_CONTROL
comma
id|command
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check arbitration&n;&t; */
id|status
op_assign
id|nsp32_arbitration
c_func
(paren
id|SCpnt
comma
id|base
)paren
suffix:semicolon
id|out
suffix:colon
multiline_comment|/*&n;&t; * IRQ enable&n;&t; */
id|nsp32_write2
c_func
(paren
id|base
comma
id|IRQ_CONTROL
comma
l_int|0
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * Arbitration Status Check&n; *&t;&n; * Note: Arbitration counter is waited during ARBIT_GO is not lifting.&n; *&t; Using udelay(1) consumes CPU time and system time, but &n; *&t; arbitration delay time is defined minimal 2.4us in SCSI&n; *&t; specification, thus udelay works as coarse grained wait timer.&n; */
DECL|function|nsp32_arbitration
r_static
r_int
id|nsp32_arbitration
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
r_int
id|base
)paren
(brace
r_int
r_char
id|arbit
suffix:semicolon
r_int
id|status
op_assign
id|TRUE
suffix:semicolon
r_int
id|time
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|arbit
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|ARBIT_STATUS
)paren
suffix:semicolon
id|time
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|arbit
op_amp
(paren
id|ARBIT_WIN
op_or
id|ARBIT_FAIL
)paren
)paren
op_eq
l_int|0
op_logical_and
(paren
id|time
op_le
id|ARBIT_TIMEOUT_TIME
)paren
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_AUTOSCSI
comma
l_string|&quot;arbit: 0x%x, delay time: %d&quot;
comma
id|arbit
comma
id|time
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arbit
op_amp
id|ARBIT_WIN
)paren
(brace
multiline_comment|/* Arbitration succeeded */
id|SCpnt-&gt;result
op_assign
id|DID_OK
op_lshift
l_int|16
suffix:semicolon
id|nsp32_index_write1
c_func
(paren
id|base
comma
id|EXT_PORT
comma
id|LED_ON
)paren
suffix:semicolon
multiline_comment|/* PCI LED on */
)brace
r_else
r_if
c_cond
(paren
id|arbit
op_amp
id|ARBIT_FAIL
)paren
(brace
multiline_comment|/* Arbitration failed */
id|SCpnt-&gt;result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
id|status
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * unknown error or ARBIT_GO timeout,&n;&t;&t; * something lock up! guess no connection.&n;&t;&t; */
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_AUTOSCSI
comma
l_string|&quot;arbit timeout&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
id|status
op_assign
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * clear Arbit&n;&t; */
id|nsp32_write1
c_func
(paren
id|base
comma
id|SET_ARBIT
comma
id|ARBIT_CLEAR
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * reselection&n; *&n; * Note: This reselection routine is called from msgin_occur,&n; *&t; reselection target id&amp;lun must be already set.&n; *&t; SCSI-2 says IDENTIFY implies RESTORE_POINTER operation.&n; */
DECL|function|nsp32_reselection
r_static
r_int
id|nsp32_reselection
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
r_char
id|newlun
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|SCpnt-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|host_id
op_assign
id|SCpnt-&gt;device-&gt;host-&gt;this_id
suffix:semicolon
r_int
r_int
id|base
op_assign
id|SCpnt-&gt;device-&gt;host-&gt;io_port
suffix:semicolon
r_int
r_char
id|tmpid
comma
id|newid
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_RESELECTION
comma
l_string|&quot;enter&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * calculate reselected SCSI ID&n;&t; */
id|tmpid
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|RESELECT_ID
)paren
suffix:semicolon
id|tmpid
op_and_assign
(paren
op_complement
id|BIT
c_func
(paren
id|host_id
)paren
)paren
suffix:semicolon
id|newid
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|tmpid
)paren
(brace
r_if
c_cond
(paren
id|tmpid
op_amp
l_int|1
)paren
(brace
r_break
suffix:semicolon
)brace
id|tmpid
op_rshift_assign
l_int|1
suffix:semicolon
id|newid
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If reselected New ID:LUN is not existed&n;&t; * or current nexus is not existed, unexpected&n;&t; * reselection is occurred. Send reject message.&n;&t; */
r_if
c_cond
(paren
id|newid
op_ge
id|ARRAY_SIZE
c_func
(paren
id|data-&gt;lunt
)paren
op_logical_or
id|newlun
op_ge
id|ARRAY_SIZE
c_func
(paren
id|data-&gt;lunt
(braket
l_int|0
)braket
)paren
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;unknown id/lun&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|data-&gt;lunt
(braket
id|newid
)braket
(braket
id|newlun
)braket
dot
id|SCpnt
op_eq
l_int|NULL
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;no SCSI command is processing&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|data-&gt;cur_id
op_assign
id|newid
suffix:semicolon
id|data-&gt;cur_lun
op_assign
id|newlun
suffix:semicolon
id|data-&gt;cur_target
op_assign
op_amp
(paren
id|data-&gt;target
(braket
id|newid
)braket
)paren
suffix:semicolon
id|data-&gt;cur_lunt
op_assign
op_amp
(paren
id|data-&gt;lunt
(braket
id|newid
)braket
(braket
id|newlun
)braket
)paren
suffix:semicolon
multiline_comment|/* reset SACK/SavedACK counter (or ALL clear?) */
id|nsp32_write4
c_func
(paren
id|base
comma
id|CLR_COUNTER
comma
id|CLRCOUNTER_ALLMASK
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n; * nsp32_setup_sg_table - build scatter gather list for transfer data&n; *&t;&t;&t;    with bus master.&n; *&n; * Note: NinjaSCSI-32Bi/UDE bus master can not transfer over 64KB at a time.&n; */
DECL|function|nsp32_setup_sg_table
r_static
r_int
id|nsp32_setup_sg_table
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|SCpnt-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sgl
suffix:semicolon
id|nsp32_sgtable
op_star
id|sgt
op_assign
id|data-&gt;cur_lunt-&gt;sglun-&gt;sgt
suffix:semicolon
r_int
id|num
comma
id|i
suffix:semicolon
id|u32_le
id|l
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;request_bufflen
op_eq
l_int|0
)paren
(brace
r_return
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sgt
op_eq
l_int|NULL
)paren
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_SGLIST
comma
l_string|&quot;SGT == null&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
)paren
(brace
id|sgl
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|SCpnt-&gt;request_buffer
suffix:semicolon
id|num
op_assign
id|pci_map_sg
c_func
(paren
id|data-&gt;Pci
comma
id|sgl
comma
id|SCpnt-&gt;use_sg
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|SCpnt-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Build nsp32_sglist, substitute sg dma addresses.&n;&t;&t;&t; */
id|sgt
(braket
id|i
)braket
dot
id|addr
op_assign
id|cpu_to_le32
c_func
(paren
id|sg_dma_address
c_func
(paren
id|sgl
)paren
)paren
suffix:semicolon
id|sgt
(braket
id|i
)braket
dot
id|len
op_assign
id|cpu_to_le32
c_func
(paren
id|sg_dma_len
c_func
(paren
id|sgl
)paren
)paren
suffix:semicolon
id|sgl
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|sgt
(braket
id|i
)braket
dot
id|len
)paren
OG
l_int|0x10000
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;can&squot;t transfer over 64KB at a time, size=0x%lx&quot;
comma
id|le32_to_cpu
c_func
(paren
id|sgt
(braket
id|i
)braket
dot
id|len
)paren
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_SGLIST
comma
l_string|&quot;num 0x%x : addr 0x%lx len 0x%lx&quot;
comma
id|i
comma
id|le32_to_cpu
c_func
(paren
id|sgt
(braket
id|i
)braket
dot
id|addr
)paren
comma
id|le32_to_cpu
c_func
(paren
id|sgt
(braket
id|i
)braket
dot
id|len
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* set end mark */
id|l
op_assign
id|le32_to_cpu
c_func
(paren
id|sgt
(braket
id|num
op_minus
l_int|1
)braket
dot
id|len
)paren
suffix:semicolon
id|sgt
(braket
id|num
op_minus
l_int|1
)braket
dot
id|len
op_assign
id|cpu_to_le32
c_func
(paren
id|l
op_or
id|SGTEND
)paren
suffix:semicolon
)brace
r_else
(brace
id|SCpnt-&gt;SCp.have_data_in
op_assign
id|pci_map_single
c_func
(paren
id|data-&gt;Pci
comma
id|SCpnt-&gt;request_buffer
comma
id|SCpnt-&gt;request_bufflen
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|SCpnt-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
id|sgt
(braket
l_int|0
)braket
dot
id|addr
op_assign
id|cpu_to_le32
c_func
(paren
id|SCpnt-&gt;SCp.have_data_in
)paren
suffix:semicolon
id|sgt
(braket
l_int|0
)braket
dot
id|len
op_assign
id|cpu_to_le32
c_func
(paren
id|SCpnt-&gt;request_bufflen
op_or
id|SGTEND
)paren
suffix:semicolon
multiline_comment|/* set end mark */
r_if
c_cond
(paren
id|SCpnt-&gt;request_bufflen
OG
l_int|0x10000
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;can&squot;t transfer over 64KB at a time, size=0x%lx&quot;
comma
id|SCpnt-&gt;request_bufflen
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_SGLIST
comma
l_string|&quot;single : addr 0x%lx len=0x%lx&quot;
comma
id|le32_to_cpu
c_func
(paren
id|sgt
(braket
l_int|0
)braket
dot
id|addr
)paren
comma
id|le32_to_cpu
c_func
(paren
id|sgt
(braket
l_int|0
)braket
dot
id|len
)paren
)paren
suffix:semicolon
)brace
r_return
id|TRUE
suffix:semicolon
)brace
DECL|function|nsp32_queuecommand
r_static
r_int
id|nsp32_queuecommand
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|SCpnt-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
id|nsp32_target
op_star
id|target
suffix:semicolon
id|nsp32_lunt
op_star
id|cur_lunt
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_QUEUECOMMAND
comma
l_string|&quot;enter. target: 0x%x LUN: 0x%x cmnd: 0x%x cmndlen: 0x%x &quot;
l_string|&quot;use_sg: 0x%x reqbuf: 0x%lx reqlen: 0x%x&quot;
comma
id|SCpnt-&gt;device-&gt;id
comma
id|SCpnt-&gt;device-&gt;lun
comma
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
comma
id|SCpnt-&gt;cmd_len
comma
id|SCpnt-&gt;use_sg
comma
id|SCpnt-&gt;request_buffer
comma
id|SCpnt-&gt;request_bufflen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;CurrentSC
op_ne
l_int|NULL
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;Currentsc != NULL. Cancel this command request&quot;
)paren
suffix:semicolon
id|data-&gt;CurrentSC
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
id|done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
id|SCSI_MLQUEUE_HOST_BUSY
suffix:semicolon
)brace
multiline_comment|/* check target ID is not same as this initiator ID */
r_if
c_cond
(paren
id|SCpnt-&gt;device-&gt;id
op_eq
id|SCpnt-&gt;device-&gt;host-&gt;this_id
)paren
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_QUEUECOMMAND
comma
l_string|&quot;terget==host???&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
id|done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
id|SCSI_MLQUEUE_DEVICE_BUSY
suffix:semicolon
)brace
multiline_comment|/* check target LUN is allowable value */
r_if
c_cond
(paren
id|SCpnt-&gt;device-&gt;lun
op_ge
id|MAX_LUN
)paren
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_QUEUECOMMAND
comma
l_string|&quot;no more lun&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
id|done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
id|SCSI_MLQUEUE_DEVICE_BUSY
suffix:semicolon
)brace
id|show_command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|SCpnt-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|data-&gt;CurrentSC
op_assign
id|SCpnt
suffix:semicolon
id|SCpnt-&gt;SCp.Status
op_assign
id|CHECK_CONDITION
suffix:semicolon
id|SCpnt-&gt;SCp.Message
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;resid
op_assign
id|SCpnt-&gt;request_bufflen
suffix:semicolon
id|SCpnt-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
id|SCpnt-&gt;request_buffer
suffix:semicolon
id|SCpnt-&gt;SCp.this_residual
op_assign
id|SCpnt-&gt;request_bufflen
suffix:semicolon
id|SCpnt-&gt;SCp.buffer
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;SCp.buffers_residual
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* initialize data */
id|data-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
id|data-&gt;msgin_len
op_assign
l_int|0
suffix:semicolon
id|cur_lunt
op_assign
op_amp
(paren
id|data-&gt;lunt
(braket
id|SCpnt-&gt;device-&gt;id
)braket
(braket
id|SCpnt-&gt;device-&gt;lun
)braket
)paren
suffix:semicolon
id|cur_lunt-&gt;SCpnt
op_assign
id|SCpnt
suffix:semicolon
id|cur_lunt-&gt;save_datp
op_assign
l_int|0
suffix:semicolon
id|cur_lunt-&gt;msgin03
op_assign
id|FALSE
suffix:semicolon
id|data-&gt;cur_lunt
op_assign
id|cur_lunt
suffix:semicolon
id|data-&gt;cur_id
op_assign
id|SCpnt-&gt;device-&gt;id
suffix:semicolon
id|data-&gt;cur_lun
op_assign
id|SCpnt-&gt;device-&gt;lun
suffix:semicolon
id|ret
op_assign
id|nsp32_setup_sg_table
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|FALSE
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;SGT fail&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|nsp32_scsi_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
id|SCSI_MLQUEUE_HOST_BUSY
suffix:semicolon
)brace
multiline_comment|/* Build IDENTIFY */
id|nsp32_build_identify
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * If target is the first time to transfer after the reset&n;&t; * (target don&squot;t have SDTR_DONE and SDTR_INITIATOR), sync&n;&t; * message SDTR is needed to do synchronous transfer.&n;&t; */
id|target
op_assign
op_amp
id|data-&gt;target
(braket
id|SCpnt-&gt;device-&gt;id
)braket
suffix:semicolon
id|data-&gt;cur_target
op_assign
id|target
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|target-&gt;sync_flag
op_amp
(paren
id|SDTR_DONE
op_or
id|SDTR_INITIATOR
op_or
id|SDTR_TARGET
)paren
)paren
)paren
(brace
r_int
r_char
id|period
comma
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|trans_mode
op_ne
id|ASYNC_MODE
)paren
(brace
id|nsp32_set_max_sync
c_func
(paren
id|data
comma
id|target
comma
op_amp
id|period
comma
op_amp
id|offset
)paren
suffix:semicolon
id|nsp32_build_sdtr
c_func
(paren
id|SCpnt
comma
id|period
comma
id|offset
)paren
suffix:semicolon
id|target-&gt;sync_flag
op_or_assign
id|SDTR_INITIATOR
suffix:semicolon
)brace
r_else
(brace
id|nsp32_set_async
c_func
(paren
id|data
comma
id|target
)paren
suffix:semicolon
id|target-&gt;sync_flag
op_or_assign
id|SDTR_DONE
suffix:semicolon
)brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_QUEUECOMMAND
comma
l_string|&quot;SDTR: entry: %d start_period: 0x%x offset: 0x%x&bslash;n&quot;
comma
id|target-&gt;limit_entry
comma
id|period
comma
id|offset
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|target-&gt;sync_flag
op_amp
id|SDTR_INITIATOR
)paren
(brace
multiline_comment|/*&n;&t;&t; * It was negotiating SDTR with target, sending from the&n;&t;&t; * initiator, but there are no chance to remove this flag.&n;&t;&t; * Set async because we don&squot;t get proper negotiation.&n;&t;&t; */
id|nsp32_set_async
c_func
(paren
id|data
comma
id|target
)paren
suffix:semicolon
id|target-&gt;sync_flag
op_and_assign
op_complement
id|SDTR_INITIATOR
suffix:semicolon
id|target-&gt;sync_flag
op_or_assign
id|SDTR_DONE
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_QUEUECOMMAND
comma
l_string|&quot;SDTR_INITIATOR: fall back to async&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|target-&gt;sync_flag
op_amp
id|SDTR_TARGET
)paren
(brace
multiline_comment|/*&n;&t;&t; * It was negotiating SDTR with target, sending from target,&n;&t;&t; * but there are no chance to remove this flag.  Set async&n;&t;&t; * because we don&squot;t get proper negotiation.&n;&t;&t; */
id|nsp32_set_async
c_func
(paren
id|data
comma
id|target
)paren
suffix:semicolon
id|target-&gt;sync_flag
op_and_assign
op_complement
id|SDTR_TARGET
suffix:semicolon
id|target-&gt;sync_flag
op_or_assign
id|SDTR_DONE
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_QUEUECOMMAND
comma
l_string|&quot;Unknown SDTR from target is reached, fall back to async.&quot;
)paren
suffix:semicolon
)brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_TARGETFLAG
comma
l_string|&quot;target: %d sync_flag: 0x%x syncreg: 0x%x ackwidth: 0x%x&quot;
comma
id|SCpnt-&gt;device-&gt;id
comma
id|target-&gt;sync_flag
comma
id|target-&gt;syncreg
comma
id|target-&gt;ackwidth
)paren
suffix:semicolon
multiline_comment|/* Selection */
r_if
c_cond
(paren
id|auto_param
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|nsp32_selection_autopara
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
id|nsp32_selection_autoscsi
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_ne
id|TRUE
)paren
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_QUEUECOMMAND
comma
l_string|&quot;selection fail&quot;
)paren
suffix:semicolon
id|nsp32_scsi_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
id|SCSI_MLQUEUE_DEVICE_BUSY
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* initialize asic */
DECL|function|nsp32hw_init
r_static
r_int
id|nsp32hw_init
c_func
(paren
id|nsp32_hw_data
op_star
id|data
)paren
(brace
r_int
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
r_int
r_int
id|irq_stat
suffix:semicolon
r_int
r_int
id|lc_reg
suffix:semicolon
r_int
r_char
id|power
suffix:semicolon
id|lc_reg
op_assign
id|nsp32_index_read4
c_func
(paren
id|base
comma
id|CFG_LATE_CACHE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lc_reg
op_amp
l_int|0xff00
)paren
op_eq
l_int|0
)paren
(brace
id|lc_reg
op_or_assign
(paren
l_int|0x20
op_lshift
l_int|8
)paren
suffix:semicolon
id|nsp32_index_write2
c_func
(paren
id|base
comma
id|CFG_LATE_CACHE
comma
id|lc_reg
op_amp
l_int|0xffff
)paren
suffix:semicolon
)brace
id|nsp32_write2
c_func
(paren
id|base
comma
id|IRQ_CONTROL
comma
id|IRQ_CONTROL_ALL_IRQ_MASK
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|TRANSFER_CONTROL
comma
l_int|0
)paren
suffix:semicolon
id|nsp32_write4
c_func
(paren
id|base
comma
id|BM_CNT
comma
l_int|0
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|SCSI_EXECUTE_PHASE
comma
l_int|0
)paren
suffix:semicolon
r_do
(brace
id|irq_stat
op_assign
id|nsp32_read2
c_func
(paren
id|base
comma
id|IRQ_STATUS
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INIT
comma
l_string|&quot;irq_stat 0x%x&quot;
comma
id|irq_stat
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|irq_stat
op_amp
id|IRQSTATUS_ANY_IRQ
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill FIFO_FULL_SHLD, FIFO_EMPTY_SHLD. Below parameter is&n;&t; *  designated by specification.&n;&t; */
r_if
c_cond
(paren
(paren
id|data-&gt;trans_method
op_amp
id|NSP32_TRANSFER_PIO
)paren
op_logical_or
(paren
id|data-&gt;trans_method
op_amp
id|NSP32_TRANSFER_MMIO
)paren
)paren
(brace
id|nsp32_index_write1
c_func
(paren
id|base
comma
id|FIFO_FULL_SHLD_COUNT
comma
l_int|0x40
)paren
suffix:semicolon
id|nsp32_index_write1
c_func
(paren
id|base
comma
id|FIFO_EMPTY_SHLD_COUNT
comma
l_int|0x40
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|data-&gt;trans_method
op_amp
id|NSP32_TRANSFER_BUSMASTER
)paren
(brace
id|nsp32_index_write1
c_func
(paren
id|base
comma
id|FIFO_FULL_SHLD_COUNT
comma
l_int|0x10
)paren
suffix:semicolon
id|nsp32_index_write1
c_func
(paren
id|base
comma
id|FIFO_EMPTY_SHLD_COUNT
comma
l_int|0x60
)paren
suffix:semicolon
)brace
r_else
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INIT
comma
l_string|&quot;unknown transfer mode&quot;
)paren
suffix:semicolon
)brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INIT
comma
l_string|&quot;full 0x%x emp 0x%x&quot;
comma
id|nsp32_index_read1
c_func
(paren
id|base
comma
id|FIFO_FULL_SHLD_COUNT
)paren
comma
id|nsp32_index_read1
c_func
(paren
id|base
comma
id|FIFO_EMPTY_SHLD_COUNT
)paren
)paren
suffix:semicolon
id|nsp32_index_write1
c_func
(paren
id|base
comma
id|CLOCK_DIV
comma
id|data-&gt;clock
)paren
suffix:semicolon
id|nsp32_index_write1
c_func
(paren
id|base
comma
id|BM_CYCLE
comma
id|MEMRD_CMD1
op_or
id|SGT_AUTO_PARA_MEMED_CMD
)paren
suffix:semicolon
id|nsp32_write1
c_func
(paren
id|base
comma
id|PARITY_CONTROL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* parity check is disable */
multiline_comment|/*&n;&t; * initialize MISC_WRRD register&n;&t; * &n;&t; * Note: Designated parameters is obeyed as following:&n;&t; *&t;MISC_SCSI_DIRECTION_DETECTOR_SELECT: It must be set.&n;&t; *&t;MISC_MASTER_TERMINATION_SELECT:      It must be set.&n;&t; *&t;MISC_BMREQ_NEGATE_TIMING_SEL:&t;     It should be set.&n;&t; *&t;MISC_AUTOSEL_TIMING_SEL:&t;     It should be set.&n;&t; *&t;MISC_BMSTOP_CHANGE2_NONDATA_PHASE:   It should be set.&n;&t; *&t;MISC_DELAYED_BMSTART:&t;&t;     It&squot;s selected for safety.&n;&t; *&n;&t; * Note: If MISC_BMSTOP_CHANGE2_NONDATA_PHASE is set, then&n;&t; *&t;we have to set TRANSFERCONTROL_BM_START as 0 and set&n;&t; *&t;appropriate value before restarting bus master transfer.&n;&t; */
id|nsp32_index_write2
c_func
(paren
id|base
comma
id|MISC_WR
comma
(paren
id|SCSI_DIRECTION_DETECTOR_SELECT
op_or
id|DELAYED_BMSTART
op_or
id|MASTER_TERMINATION_SELECT
op_or
id|BMREQ_NEGATE_TIMING_SEL
op_or
id|AUTOSEL_TIMING_SEL
op_or
id|BMSTOP_CHANGE2_NONDATA_PHASE
)paren
)paren
suffix:semicolon
id|nsp32_index_write1
c_func
(paren
id|base
comma
id|TERM_PWR_CONTROL
comma
l_int|0
)paren
suffix:semicolon
id|power
op_assign
id|nsp32_index_read1
c_func
(paren
id|base
comma
id|TERM_PWR_CONTROL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|power
op_amp
id|SENSE
)paren
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;term power on&quot;
)paren
suffix:semicolon
id|nsp32_index_write1
c_func
(paren
id|base
comma
id|TERM_PWR_CONTROL
comma
id|BPWR
)paren
suffix:semicolon
)brace
id|nsp32_write2
c_func
(paren
id|base
comma
id|TIMER_SET
comma
id|TIMER_STOP
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|TIMER_SET
comma
id|TIMER_STOP
)paren
suffix:semicolon
multiline_comment|/* Required 2 times */
id|nsp32_write1
c_func
(paren
id|base
comma
id|SYNC_REG
comma
l_int|0
)paren
suffix:semicolon
id|nsp32_write1
c_func
(paren
id|base
comma
id|ACK_WIDTH
comma
l_int|0
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|SEL_TIME_OUT
comma
id|SEL_TIMEOUT_TIME
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * enable to select designated IRQ (except for&n;&t; * IRQSELECT_SERR, IRQSELECT_PERR, IRQSELECT_BMCNTERR)&n;&t; */
id|nsp32_index_write2
c_func
(paren
id|base
comma
id|IRQ_SELECT
comma
id|IRQSELECT_TIMER_IRQ
op_or
id|IRQSELECT_SCSIRESET_IRQ
op_or
id|IRQSELECT_FIFO_SHLD_IRQ
op_or
id|IRQSELECT_RESELECT_IRQ
op_or
id|IRQSELECT_PHASE_CHANGE_IRQ
op_or
id|IRQSELECT_AUTO_SCSI_SEQ_IRQ
op_or
singleline_comment|//   IRQSELECT_BMCNTERR_IRQ      |
id|IRQSELECT_TARGET_ABORT_IRQ
op_or
id|IRQSELECT_MASTER_ABORT_IRQ
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|IRQ_CONTROL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* PCI LED off */
id|nsp32_index_write1
c_func
(paren
id|base
comma
id|EXT_PORT_DDR
comma
id|LED_OFF
)paren
suffix:semicolon
id|nsp32_index_write1
c_func
(paren
id|base
comma
id|EXT_PORT
comma
id|LED_OFF
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/* interrupt routine */
DECL|function|do_nsp32_isr
r_static
id|irqreturn_t
id|do_nsp32_isr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
id|dev_id
suffix:semicolon
r_int
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
op_assign
id|data-&gt;CurrentSC
suffix:semicolon
r_int
r_int
id|auto_stat
comma
id|irq_stat
comma
id|trans_stat
suffix:semicolon
r_int
r_char
id|busmon
comma
id|busphase
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|handled
op_assign
l_int|0
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,5,0))
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|data-&gt;Host
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#else
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * IRQ check, then enable IRQ mask&n;&t; */
id|irq_stat
op_assign
id|nsp32_read2
c_func
(paren
id|base
comma
id|IRQ_STATUS
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;enter IRQ: %d, IRQstatus: 0x%x&quot;
comma
id|irq
comma
id|irq_stat
)paren
suffix:semicolon
multiline_comment|/* is this interrupt comes from Ninja asic? */
r_if
c_cond
(paren
(paren
id|irq_stat
op_amp
id|IRQSTATUS_ANY_IRQ
)paren
op_eq
l_int|0
)paren
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;shared interrupt: irq other 0x%x&quot;
comma
id|irq_stat
)paren
suffix:semicolon
r_goto
id|out2
suffix:semicolon
)brace
id|handled
op_assign
l_int|1
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|IRQ_CONTROL
comma
id|IRQ_CONTROL_ALL_IRQ_MASK
)paren
suffix:semicolon
id|busmon
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_BUS_MONITOR
)paren
suffix:semicolon
id|busphase
op_assign
id|busmon
op_amp
id|BUSMON_PHASE_MASK
suffix:semicolon
id|trans_stat
op_assign
id|nsp32_read2
c_func
(paren
id|base
comma
id|TRANSFER_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|irq_stat
op_eq
l_int|0xffff
)paren
op_logical_and
(paren
id|trans_stat
op_eq
l_int|0xffff
)paren
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;card disconnect&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;CurrentSC
op_ne
l_int|NULL
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;clean up current SCSI command&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
id|nsp32_scsi_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Timer IRQ */
r_if
c_cond
(paren
id|irq_stat
op_amp
id|IRQSTATUS_TIMER_IRQ
)paren
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;timer stop&quot;
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|TIMER_SET
comma
id|TIMER_STOP
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* SCSI reset */
r_if
c_cond
(paren
id|irq_stat
op_amp
id|IRQSTATUS_SCSIRESET_IRQ
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;detected someone do bus reset&quot;
)paren
suffix:semicolon
id|nsp32_do_bus_reset
c_func
(paren
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt
op_ne
l_int|NULL
)paren
(brace
id|SCpnt-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|nsp32_scsi_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt
op_eq
l_int|NULL
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;SCpnt==NULL this can&squot;t be happened&quot;
)paren
suffix:semicolon
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;irq_stat=0x%x trans_stat=0x%x&quot;
comma
id|irq_stat
comma
id|trans_stat
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * AutoSCSI Interrupt.&n;&t; * Note: This interrupt is occurred when AutoSCSI is finished.  Then&n;&t; * check SCSIEXECUTEPHASE, and do appropriate action.  Each phases are&n;&t; * recorded when AutoSCSI sequencer has been processed.&n;&t; */
r_if
c_cond
(paren
id|irq_stat
op_amp
id|IRQSTATUS_AUTOSCSI_IRQ
)paren
(brace
multiline_comment|/* getting SCSI executed phase */
id|auto_stat
op_assign
id|nsp32_read2
c_func
(paren
id|base
comma
id|SCSI_EXECUTE_PHASE
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|SCSI_EXECUTE_PHASE
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Selection Timeout, go busfree phase. */
r_if
c_cond
(paren
id|auto_stat
op_amp
id|SELECTION_TIMEOUT
)paren
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;selection timeout occurred&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_TIME_OUT
op_lshift
l_int|16
suffix:semicolon
id|nsp32_scsi_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|auto_stat
op_amp
id|MSGOUT_PHASE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * MsgOut phase was processed.&n;&t;&t;&t; * If MSG_IN_OCCUER is not set, then MsgOut phase is&n;&t;&t;&t; * completed. Thus, msgout_len must reset.  Otherwise,&n;&t;&t;&t; * nothing to do here. If MSG_OUT_OCCUER is occurred,&n;&t;&t;&t; * then we will encounter the condition and check.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|auto_stat
op_amp
id|MSG_IN_OCCUER
)paren
op_logical_and
(paren
id|data-&gt;msgout_len
op_le
l_int|3
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * !MSG_IN_OCCUER &amp;&amp; msgout_len &lt;=3&n;&t;&t;&t;&t; *   ---&gt; AutoSCSI with MSGOUTreg is processed.&n;&t;&t;&t;&t; */
id|data-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
)brace
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;MsgOut phase processed&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|auto_stat
op_amp
id|DATA_IN_PHASE
)paren
op_logical_and
(paren
id|SCpnt-&gt;resid
OG
l_int|0
)paren
op_logical_and
(paren
(paren
id|nsp32_read2
c_func
(paren
id|base
comma
id|FIFO_REST_CNT
)paren
op_amp
id|FIFO_REST_MASK
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;auto+fifo&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|//nsp32_pio_read(SCpnt);
)brace
r_if
c_cond
(paren
id|auto_stat
op_amp
(paren
id|DATA_IN_PHASE
op_or
id|DATA_OUT_PHASE
)paren
)paren
(brace
multiline_comment|/* DATA_IN_PHASE/DATA_OUT_PHASE was processed. */
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;Data in/out phase processed&quot;
)paren
suffix:semicolon
multiline_comment|/* read BMCNT, SGT pointer addr */
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;BMCNT=0x%lx&quot;
comma
id|nsp32_read4
c_func
(paren
id|base
comma
id|BM_CNT
)paren
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;addr=0x%lx&quot;
comma
id|nsp32_read4
c_func
(paren
id|base
comma
id|SGT_ADR
)paren
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;SACK=0x%lx&quot;
comma
id|nsp32_read4
c_func
(paren
id|base
comma
id|SACK_CNT
)paren
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;SSACK=0x%lx&quot;
comma
id|nsp32_read4
c_func
(paren
id|base
comma
id|SAVED_SACK_CNT
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;resid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* all data transfered! */
)brace
multiline_comment|/*&n;&t;&t; * MsgIn Occur&n;&t;&t; */
r_if
c_cond
(paren
id|auto_stat
op_amp
id|MSG_IN_OCCUER
)paren
(brace
id|nsp32_msgin_occur
c_func
(paren
id|SCpnt
comma
id|irq_stat
comma
id|auto_stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * MsgOut Occur&n;&t;&t; */
r_if
c_cond
(paren
id|auto_stat
op_amp
id|MSG_OUT_OCCUER
)paren
(brace
id|nsp32_msgout_occur
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Bus Free Occur&n;&t;&t; */
r_if
c_cond
(paren
id|auto_stat
op_amp
id|BUS_FREE_OCCUER
)paren
(brace
id|ret
op_assign
id|nsp32_busfree_occur
c_func
(paren
id|SCpnt
comma
id|auto_stat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|TRUE
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|auto_stat
op_amp
id|STATUS_PHASE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Read CSB and substitute CSB for SCpnt-&gt;result&n;&t;&t;&t; * to save status phase stutas byte.&n;&t;&t;&t; * scsi error handler checks host_byte (DID_*:&n;&t;&t;&t; * low level driver to indicate status), then checks &n;&t;&t;&t; * status_byte (SCSI status byte).&n;&t;&t;&t; */
id|SCpnt-&gt;result
op_assign
(paren
r_int
)paren
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_CSB_IN
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|auto_stat
op_amp
id|ILLEGAL_PHASE
)paren
(brace
multiline_comment|/* Illegal phase is detected. SACK is not back. */
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;AUTO SCSI ILLEGAL PHASE OCCUR!!!!&quot;
)paren
suffix:semicolon
multiline_comment|/* TODO: currently we don&squot;t have any action... bus reset? */
multiline_comment|/*&n;&t;&t;&t; * To send back SACK, assert, wait, and negate.&n;&t;&t;&t; */
id|nsp32_sack_assert
c_func
(paren
id|data
)paren
suffix:semicolon
id|nsp32_wait_req
c_func
(paren
id|data
comma
id|NEGATE
)paren
suffix:semicolon
id|nsp32_sack_negate
c_func
(paren
id|data
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|auto_stat
op_amp
id|COMMAND_PHASE
)paren
(brace
multiline_comment|/* nothing to do */
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;Command phase processed&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|auto_stat
op_amp
id|AUTOSCSI_BUSY
)paren
(brace
multiline_comment|/* AutoSCSI is running */
)brace
id|show_autophase
c_func
(paren
id|auto_stat
)paren
suffix:semicolon
)brace
multiline_comment|/* FIFO_SHLD_IRQ */
r_if
c_cond
(paren
id|irq_stat
op_amp
id|IRQSTATUS_FIFO_SHLD_IRQ
)paren
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;FIFO IRQ&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|busphase
)paren
(brace
r_case
id|BUSPHASE_DATA_OUT
suffix:colon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;fifo/write&quot;
)paren
suffix:semicolon
singleline_comment|//nsp32_pio_write(SCpnt);
r_break
suffix:semicolon
r_case
id|BUSPHASE_DATA_IN
suffix:colon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;fifo/read&quot;
)paren
suffix:semicolon
singleline_comment|//nsp32_pio_read(SCpnt);
r_break
suffix:semicolon
r_case
id|BUSPHASE_STATUS
suffix:colon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;fifo/status&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;SCp.Status
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_CSB_IN
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;fifo/other phase&quot;
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;irq_stat=0x%x trans_stat=0x%x&quot;
comma
id|irq_stat
comma
id|trans_stat
)paren
suffix:semicolon
id|show_busphase
c_func
(paren
id|busphase
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Phase Change IRQ */
r_if
c_cond
(paren
id|irq_stat
op_amp
id|IRQSTATUS_PHASE_CHANGE_IRQ
)paren
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;phase change IRQ&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|busphase
)paren
(brace
r_case
id|BUSPHASE_MESSAGE_IN
suffix:colon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;phase chg/msg in&quot;
)paren
suffix:semicolon
id|nsp32_msgin_occur
c_func
(paren
id|SCpnt
comma
id|irq_stat
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;phase chg/other phase?&quot;
)paren
suffix:semicolon
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;irq_stat=0x%x trans_stat=0x%x&bslash;n&quot;
comma
id|irq_stat
comma
id|trans_stat
)paren
suffix:semicolon
id|show_busphase
c_func
(paren
id|busphase
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* PCI_IRQ */
r_if
c_cond
(paren
id|irq_stat
op_amp
id|IRQSTATUS_PCI_IRQ
)paren
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;PCI IRQ occurred&quot;
)paren
suffix:semicolon
multiline_comment|/* Do nothing */
)brace
multiline_comment|/* BMCNTERR_IRQ */
r_if
c_cond
(paren
id|irq_stat
op_amp
id|IRQSTATUS_BMCNTERR_IRQ
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;Received unexpected BMCNTERR IRQ! &quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * TODO: To be implemented improving bus master&n;&t;&t; * transfer reliablity when BMCNTERR is occurred in&n;&t;&t; * AutoSCSI phase described in specification.&n;&t;&t; */
)brace
macro_line|#if 0
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;irq_stat=0x%x trans_stat=0x%x&quot;
comma
id|irq_stat
comma
id|trans_stat
)paren
suffix:semicolon
id|show_busphase
c_func
(paren
id|busphase
)paren
suffix:semicolon
macro_line|#endif
id|out
suffix:colon
multiline_comment|/* disable IRQ mask */
id|nsp32_write2
c_func
(paren
id|base
comma
id|IRQ_CONTROL
comma
l_int|0
)paren
suffix:semicolon
id|out2
suffix:colon
macro_line|#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,5,0))
id|spin_unlock_irqrestore
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#else
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#endif
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;exit&quot;
)paren
suffix:semicolon
r_return
id|IRQ_RETVAL
c_func
(paren
id|handled
)paren
suffix:semicolon
)brace
DECL|macro|SPRINTF
macro_line|#undef SPRINTF
DECL|macro|SPRINTF
mdefine_line|#define SPRINTF(args...) &bslash;&n;&t;do { &bslash;&n;&t;&t;if(length &gt; (pos - buffer)) { &bslash;&n;&t;&t;&t;pos += snprintf(pos, length - (pos - buffer) + 1, ## args); &bslash;&n;&t;&t;&t;nsp32_dbg(NSP32_DEBUG_PROC, &quot;buffer=0x%p pos=0x%p length=%d %d&bslash;n&quot;, buffer, pos, length,  length - (pos - buffer));&bslash;&n;&t;&t;} &bslash;&n;&t;} while(0)
DECL|function|nsp32_proc_info
r_static
r_int
id|nsp32_proc_info
c_func
(paren
macro_line|#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,5,73)) 
r_struct
id|Scsi_Host
op_star
id|host
comma
macro_line|#endif
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
macro_line|#if !(LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,5,73)) 
r_int
id|hostno
comma
macro_line|#endif
r_int
id|inout
)paren
(brace
r_char
op_star
id|pos
op_assign
id|buffer
suffix:semicolon
r_int
id|thislength
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|nsp32_hw_data
op_star
id|data
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,5,73)) 
r_int
id|hostno
suffix:semicolon
macro_line|#else
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
macro_line|#endif
r_int
r_int
id|base
suffix:semicolon
r_int
r_char
id|mode_reg
suffix:semicolon
r_int
id|id
comma
id|speed
suffix:semicolon
r_int
id|model
suffix:semicolon
multiline_comment|/* Write is not supported, just return. */
r_if
c_cond
(paren
id|inout
op_eq
id|TRUE
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,5,73)) 
id|hostno
op_assign
id|host-&gt;host_no
suffix:semicolon
macro_line|#else
multiline_comment|/* search this HBA host */
id|host
op_assign
id|scsi_host_hn_get
c_func
(paren
id|hostno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|host
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ESRCH
suffix:semicolon
)brace
macro_line|#endif
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|base
op_assign
id|host-&gt;io_port
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;NinjaSCSI-32 status&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;Driver version:        %s, $Revision: 1.33 $&bslash;n&quot;
comma
id|nsp32_release_version
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;SCSI host No.:         %d&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;IRQ:                   %d&bslash;n&quot;
comma
id|host-&gt;irq
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;IO:                    0x%lx-0x%lx&bslash;n&quot;
comma
id|host-&gt;io_port
comma
id|host-&gt;io_port
op_plus
id|host-&gt;n_io_port
op_minus
l_int|1
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;MMIO(virtual address): 0x%lx-0x%lx&bslash;n&quot;
comma
id|host-&gt;base
comma
id|host-&gt;base
op_plus
id|data-&gt;MmioLength
op_minus
l_int|1
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;sg_tablesize:          %d&bslash;n&quot;
comma
id|host-&gt;sg_tablesize
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;Chip revision:         0x%x&bslash;n&quot;
comma
(paren
id|nsp32_read2
c_func
(paren
id|base
comma
id|INDEX_REG
)paren
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|mode_reg
op_assign
id|nsp32_index_read1
c_func
(paren
id|base
comma
id|CHIP_MODE
)paren
suffix:semicolon
id|model
op_assign
id|data-&gt;pci_devid-&gt;driver_data
suffix:semicolon
macro_line|#ifdef CONFIG_PM
id|SPRINTF
c_func
(paren
l_string|&quot;Power Management:      %s&bslash;n&quot;
comma
(paren
id|mode_reg
op_amp
id|OPTF
)paren
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
macro_line|#endif
id|SPRINTF
c_func
(paren
l_string|&quot;OEM:                   %ld, %s&bslash;n&quot;
comma
(paren
id|mode_reg
op_amp
(paren
id|OEM0
op_or
id|OEM1
)paren
)paren
comma
id|nsp32_model
(braket
id|model
)braket
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|data-&gt;Lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;CurrentSC:             0x%p&bslash;n&bslash;n&quot;
comma
id|data-&gt;CurrentSC
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|data-&gt;Lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;SDTR status&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|id
op_assign
l_int|0
suffix:semicolon
id|id
OL
id|ARRAY_SIZE
c_func
(paren
id|data-&gt;target
)paren
suffix:semicolon
id|id
op_increment
)paren
(brace
id|SPRINTF
c_func
(paren
l_string|&quot;id %d: &quot;
comma
id|id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
op_eq
id|host-&gt;this_id
)paren
(brace
id|SPRINTF
c_func
(paren
l_string|&quot;----- NinjaSCSI-32 host adapter&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|data-&gt;target
(braket
id|id
)braket
dot
id|sync_flag
op_eq
id|SDTR_DONE
)paren
(brace
r_if
c_cond
(paren
id|data-&gt;target
(braket
id|id
)braket
dot
id|period
op_eq
l_int|0
op_logical_and
id|data-&gt;target
(braket
id|id
)braket
dot
id|offset
op_eq
id|ASYNC_OFFSET
)paren
(brace
id|SPRINTF
c_func
(paren
l_string|&quot;async&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|SPRINTF
c_func
(paren
l_string|&quot; sync&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|SPRINTF
c_func
(paren
l_string|&quot; none&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|data-&gt;target
(braket
id|id
)braket
dot
id|period
op_ne
l_int|0
)paren
(brace
id|speed
op_assign
l_int|1000000
op_div
(paren
id|data-&gt;target
(braket
id|id
)braket
dot
id|period
op_star
l_int|4
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot; transfer %d.%dMB/s, offset %d&quot;
comma
id|speed
op_div
l_int|1000
comma
id|speed
op_mod
l_int|1000
comma
id|data-&gt;target
(braket
id|id
)braket
dot
id|offset
)paren
suffix:semicolon
)brace
id|SPRINTF
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|thislength
op_assign
id|pos
op_minus
(paren
id|buffer
op_plus
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|thislength
OL
l_int|0
)paren
(brace
op_star
id|start
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|thislength
op_assign
id|min
c_func
(paren
id|thislength
comma
id|length
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|offset
suffix:semicolon
r_return
id|thislength
suffix:semicolon
)brace
DECL|macro|SPRINTF
macro_line|#undef SPRINTF
multiline_comment|/*&n; * Reset parameters and call scsi_done for data-&gt;cur_lunt.&n; * Be careful setting SCpnt-&gt;result = DID_* before calling this function.&n; */
DECL|function|nsp32_scsi_done
r_static
r_void
id|nsp32_scsi_done
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|SCpnt-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|base
op_assign
id|SCpnt-&gt;device-&gt;host-&gt;io_port
suffix:semicolon
multiline_comment|/*&n;&t; * unmap pci&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;request_bufflen
op_eq
l_int|0
)paren
(brace
r_goto
id|skip
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
)paren
(brace
id|pci_unmap_sg
c_func
(paren
id|data-&gt;Pci
comma
(paren
r_struct
id|scatterlist
op_star
)paren
id|SCpnt-&gt;buffer
comma
id|SCpnt-&gt;use_sg
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|SCpnt-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pci_unmap_single
c_func
(paren
id|data-&gt;Pci
comma
(paren
id|u32
)paren
id|SCpnt-&gt;SCp.have_data_in
comma
id|SCpnt-&gt;request_bufflen
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|SCpnt-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
)brace
id|skip
suffix:colon
multiline_comment|/*&n;&t; * clear TRANSFERCONTROL_BM_START&n;&t; */
id|nsp32_write2
c_func
(paren
id|base
comma
id|TRANSFER_CONTROL
comma
l_int|0
)paren
suffix:semicolon
id|nsp32_write4
c_func
(paren
id|base
comma
id|BM_CNT
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * call scsi_done&n;&t; */
(paren
op_star
id|SCpnt-&gt;scsi_done
)paren
(paren
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * reset parameters&n;&t; */
id|data-&gt;cur_lunt-&gt;SCpnt
op_assign
l_int|NULL
suffix:semicolon
id|data-&gt;cur_lunt
op_assign
l_int|NULL
suffix:semicolon
id|data-&gt;cur_target
op_assign
l_int|NULL
suffix:semicolon
id|data-&gt;CurrentSC
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Bus Free Occur&n; *&n; * Current Phase is BUSFREE. AutoSCSI is automatically execute BUSFREE phase&n; * with ACK reply when below condition is matched:&n; *&t;MsgIn 00: Command Complete.&n; *&t;MsgIn 02: Save Data Pointer.&n; *&t;MsgIn 04: Diconnect.&n; * In other case, unexpected BUSFREE is detected.&n; */
DECL|function|nsp32_busfree_occur
r_static
r_int
id|nsp32_busfree_occur
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
r_int
id|execph
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|SCpnt-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|base
op_assign
id|SCpnt-&gt;device-&gt;host-&gt;io_port
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_BUSFREE
comma
l_string|&quot;enter execph=0x%x&quot;
comma
id|execph
)paren
suffix:semicolon
id|show_autophase
c_func
(paren
id|execph
)paren
suffix:semicolon
id|nsp32_write4
c_func
(paren
id|base
comma
id|BM_CNT
comma
l_int|0
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|TRANSFER_CONTROL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * MsgIn 02: Save Data Pointer&n;&t; *&n;&t; * VALID:&n;&t; *   Save Data Pointer is received. Adjust pointer.&n;&t; *   &n;&t; * NO-VALID:&n;&t; *   SCSI-3 says if Save Data Pointer is not received, then we restart&n;&t; *   processing and we can&squot;t adjust any SCSI data pointer in next data&n;&t; *   phase.&n;&t; */
r_if
c_cond
(paren
id|execph
op_amp
id|MSGIN_02_VALID
)paren
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_BUSFREE
comma
l_string|&quot;MsgIn02_Valid&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check sack_cnt/saved_sack_cnt, then adjust sg table if&n;&t;&t; * needed.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|execph
op_amp
id|MSGIN_00_VALID
)paren
op_logical_and
(paren
(paren
id|execph
op_amp
id|DATA_IN_PHASE
)paren
op_logical_or
(paren
id|execph
op_amp
id|DATA_OUT_PHASE
)paren
)paren
)paren
(brace
r_int
r_int
id|sacklen
comma
id|s_sacklen
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Read SACK count and SAVEDSACK count, then compare.&n;&t;&t;&t; */
id|sacklen
op_assign
id|nsp32_read4
c_func
(paren
id|base
comma
id|SACK_CNT
)paren
suffix:semicolon
id|s_sacklen
op_assign
id|nsp32_read4
c_func
(paren
id|base
comma
id|SAVED_SACK_CNT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If SAVEDSACKCNT == 0, it means SavedDataPointer is&n;&t;&t;&t; * come after data transfering.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|s_sacklen
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Comparing between sack and savedsack to&n;&t;&t;&t;&t; * check the condition of AutoMsgIn03.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * If they are same, set msgin03 == TRUE,&n;&t;&t;&t;&t; * COMMANDCONTROL_AUTO_MSGIN_03 is enabled at&n;&t;&t;&t;&t; * reselection.  On the other hand, if they&n;&t;&t;&t;&t; * aren&squot;t same, set msgin03 == FALSE, and&n;&t;&t;&t;&t; * COMMANDCONTROL_AUTO_MSGIN_03 is disabled at&n;&t;&t;&t;&t; * reselection.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|sacklen
op_ne
id|s_sacklen
)paren
(brace
id|data-&gt;cur_lunt-&gt;msgin03
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
(brace
id|data-&gt;cur_lunt-&gt;msgin03
op_assign
id|TRUE
suffix:semicolon
)brace
id|nsp32_adjust_busfree
c_func
(paren
id|SCpnt
comma
id|s_sacklen
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* This value has not substitude with valid value yet... */
singleline_comment|//data-&gt;cur_lunt-&gt;save_datp = data-&gt;cur_datp;
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * no processing.&n;&t;&t; */
)brace
r_if
c_cond
(paren
id|execph
op_amp
id|MSGIN_03_VALID
)paren
(brace
multiline_comment|/* MsgIn03 was valid to be processed. No need processing. */
)brace
multiline_comment|/*&n;&t; * target SDTR check&n;&t; */
r_if
c_cond
(paren
id|data-&gt;cur_target-&gt;sync_flag
op_amp
id|SDTR_INITIATOR
)paren
(brace
multiline_comment|/*&n;&t;&t; * SDTR negotiation pulled by the initiator has not&n;&t;&t; * finished yet. Fall back to ASYNC mode.&n;&t;&t; */
id|nsp32_set_async
c_func
(paren
id|data
comma
id|data-&gt;cur_target
)paren
suffix:semicolon
id|data-&gt;cur_target-&gt;sync_flag
op_and_assign
op_complement
id|SDTR_INITIATOR
suffix:semicolon
id|data-&gt;cur_target-&gt;sync_flag
op_or_assign
id|SDTR_DONE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|data-&gt;cur_target-&gt;sync_flag
op_amp
id|SDTR_TARGET
)paren
(brace
multiline_comment|/*&n;&t;&t; * SDTR negotiation pulled by the target has been&n;&t;&t; * negotiating.&n;&t;&t; */
r_if
c_cond
(paren
id|execph
op_amp
(paren
id|MSGIN_00_VALID
op_or
id|MSGIN_04_VALID
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t; * If valid message is received, then&n;&t;&t;&t; * negotiation is succeeded.&n;&t;&t;&t; */
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * On the contrary, if unexpected bus free is&n;&t;&t;&t; * occurred, then negotiation is failed. Fall&n;&t;&t;&t; * back to ASYNC mode.&n;&t;&t;&t; */
id|nsp32_set_async
c_func
(paren
id|data
comma
id|data-&gt;cur_target
)paren
suffix:semicolon
)brace
id|data-&gt;cur_target-&gt;sync_flag
op_and_assign
op_complement
id|SDTR_TARGET
suffix:semicolon
id|data-&gt;cur_target-&gt;sync_flag
op_or_assign
id|SDTR_DONE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * It is always ensured by SCSI standard that initiator&n;&t; * switches into Bus Free Phase after&n;&t; * receiving message 00 (Command Complete), 04 (Disconnect).&n;&t; * It&squot;s the reason that processing here is valid.&n;&t; */
r_if
c_cond
(paren
id|execph
op_amp
id|MSGIN_00_VALID
)paren
(brace
multiline_comment|/* MsgIn 00: Command Complete */
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_BUSFREE
comma
l_string|&quot;command complete&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;SCp.Status
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_CSB_IN
)paren
suffix:semicolon
id|SCpnt-&gt;SCp.Message
op_assign
l_int|0
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_BUSFREE
comma
l_string|&quot;normal end stat=0x%x resid=0x%x&bslash;n&quot;
comma
id|SCpnt-&gt;SCp.Status
comma
id|SCpnt-&gt;resid
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
(paren
id|DID_OK
op_lshift
l_int|16
)paren
op_or
(paren
id|SCpnt-&gt;SCp.Message
op_lshift
l_int|8
)paren
op_or
(paren
id|SCpnt-&gt;SCp.Status
op_lshift
l_int|0
)paren
suffix:semicolon
id|nsp32_scsi_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/* All operation is done */
r_return
id|TRUE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|execph
op_amp
id|MSGIN_04_VALID
)paren
(brace
multiline_comment|/* MsgIn 04: Disconnect */
id|SCpnt-&gt;SCp.Status
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_CSB_IN
)paren
suffix:semicolon
id|SCpnt-&gt;SCp.Message
op_assign
l_int|4
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_BUSFREE
comma
l_string|&quot;disconnect&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Unexpected bus free */
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;unexpected bus free occurred&quot;
)paren
suffix:semicolon
multiline_comment|/* DID_ERROR? */
singleline_comment|//SCpnt-&gt;result   = (DID_OK &lt;&lt; 16) | (SCpnt-&gt;SCp.Message &lt;&lt; 8) | (SCpnt-&gt;SCp.Status &lt;&lt; 0);
id|SCpnt-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|nsp32_scsi_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n; * nsp32_adjust_busfree - adjusting SG table&n; *&n; * Note: This driver adjust the SG table using SCSI ACK&n; *       counter instead of BMCNT counter!&n; */
DECL|function|nsp32_adjust_busfree
r_static
r_void
id|nsp32_adjust_busfree
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
r_int
id|s_sacklen
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|SCpnt-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
r_int
id|old_entry
op_assign
id|data-&gt;cur_entry
suffix:semicolon
r_int
id|new_entry
suffix:semicolon
r_int
id|sg_num
op_assign
id|data-&gt;cur_lunt-&gt;sg_num
suffix:semicolon
id|nsp32_sgtable
op_star
id|sgt
op_assign
id|data-&gt;cur_lunt-&gt;sglun-&gt;sgt
suffix:semicolon
r_int
r_int
id|restlen
comma
id|sentlen
suffix:semicolon
id|u32_le
id|len
comma
id|addr
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_SGLIST
comma
l_string|&quot;old resid=0x%x&quot;
comma
id|SCpnt-&gt;resid
)paren
suffix:semicolon
multiline_comment|/* adjust saved SACK count with 4 byte start address boundary */
id|s_sacklen
op_sub_assign
id|le32_to_cpu
c_func
(paren
id|sgt
(braket
id|old_entry
)braket
dot
id|addr
)paren
op_amp
l_int|3
suffix:semicolon
multiline_comment|/*&n;&t; * calculate new_entry from sack count and each sgt[].len &n;&t; * calculate the byte which is intent to send&n;&t; */
id|sentlen
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|new_entry
op_assign
id|old_entry
suffix:semicolon
id|new_entry
OL
id|sg_num
suffix:semicolon
id|new_entry
op_increment
)paren
(brace
id|sentlen
op_add_assign
(paren
id|le32_to_cpu
c_func
(paren
id|sgt
(braket
id|new_entry
)braket
dot
id|len
)paren
op_amp
op_complement
id|SGTEND
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sentlen
OG
id|s_sacklen
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* all sgt is processed */
r_if
c_cond
(paren
id|new_entry
op_eq
id|sg_num
)paren
(brace
r_goto
id|last
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sentlen
op_eq
id|s_sacklen
)paren
(brace
multiline_comment|/* XXX: confirm it&squot;s ok or not */
multiline_comment|/* In this case, it&squot;s ok because we are at &n;&t;&t;   the head element of the sg. restlen is correctly calculated. */
)brace
multiline_comment|/* calculate the rest length for transfering */
id|restlen
op_assign
id|sentlen
op_minus
id|s_sacklen
suffix:semicolon
multiline_comment|/* update adjusting current SG table entry */
id|len
op_assign
id|le32_to_cpu
c_func
(paren
id|sgt
(braket
id|new_entry
)braket
dot
id|len
)paren
suffix:semicolon
id|addr
op_assign
id|le32_to_cpu
c_func
(paren
id|sgt
(braket
id|new_entry
)braket
dot
id|addr
)paren
suffix:semicolon
id|addr
op_add_assign
(paren
id|len
op_minus
id|restlen
)paren
suffix:semicolon
id|sgt
(braket
id|new_entry
)braket
dot
id|addr
op_assign
id|cpu_to_le32
c_func
(paren
id|addr
)paren
suffix:semicolon
id|sgt
(braket
id|new_entry
)braket
dot
id|len
op_assign
id|cpu_to_le32
c_func
(paren
id|restlen
)paren
suffix:semicolon
multiline_comment|/* set cur_entry with new_entry */
id|data-&gt;cur_entry
op_assign
id|new_entry
suffix:semicolon
r_return
suffix:semicolon
id|last
suffix:colon
r_if
c_cond
(paren
id|SCpnt-&gt;resid
OL
id|sentlen
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;resid underflow&quot;
)paren
suffix:semicolon
)brace
id|SCpnt-&gt;resid
op_sub_assign
id|sentlen
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_SGLIST
comma
l_string|&quot;new resid=0x%x&quot;
comma
id|SCpnt-&gt;resid
)paren
suffix:semicolon
multiline_comment|/* update hostdata and lun */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * It&squot;s called MsgOut phase occur.&n; * NinjaSCSI-32Bi/UDE automatically processes up to 3 messages in&n; * message out phase. It, however, has more than 3 messages,&n; * HBA creates the interrupt and we have to process by hand.&n; */
DECL|function|nsp32_msgout_occur
r_static
r_void
id|nsp32_msgout_occur
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|SCpnt-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|base
op_assign
id|SCpnt-&gt;device-&gt;host-&gt;io_port
suffix:semicolon
singleline_comment|//unsigned short command;
r_int
id|new_sgtp
suffix:semicolon
r_int
id|i
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_MSGOUTOCCUR
comma
l_string|&quot;enter: msgout_len: 0x%x&quot;
comma
id|data-&gt;msgout_len
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If MsgOut phase is occurred without having any&n;&t; * message, then No_Operation is sent (SCSI-2).&n;&t; */
r_if
c_cond
(paren
id|data-&gt;msgout_len
op_eq
l_int|0
)paren
(brace
id|nsp32_build_nop
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set SGTP ADDR current entry for restarting AUTOSCSI, &n;&t; * because SGTP is incremented next point.&n;&t; * There is few statement in the specification...&n;&t; */
id|new_sgtp
op_assign
id|data-&gt;cur_lunt-&gt;sglun_paddr
op_plus
(paren
id|data-&gt;cur_lunt-&gt;cur_entry
op_star
r_sizeof
(paren
id|nsp32_sgtable
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * send messages&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|data-&gt;msgout_len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_MSGOUTOCCUR
comma
l_string|&quot;%d : 0x%x&quot;
comma
id|i
comma
id|data-&gt;msgoutbuf
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check REQ is asserted.&n;&t;&t; */
id|nsp32_wait_req
c_func
(paren
id|data
comma
id|ASSERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
(paren
id|data-&gt;msgout_len
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If the last message, set the AutoSCSI restart&n;&t;&t;&t; * before send back the ack message. AutoSCSI&n;&t;&t;&t; * restart automatically negate ATN signal.&n;&t;&t;&t; */
singleline_comment|//command = (AUTO_MSGIN_00_OR_04 | AUTO_MSGIN_02);
singleline_comment|//nsp32_restart_autoscsi(SCpnt, command);
id|nsp32_write2
c_func
(paren
id|base
comma
id|COMMAND_CONTROL
comma
(paren
id|CLEAR_CDB_FIFO_POINTER
op_or
id|AUTO_COMMAND_PHASE
op_or
id|AUTOSCSI_RESTART
op_or
id|AUTO_MSGIN_00_OR_04
op_or
id|AUTO_MSGIN_02
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Write data with SACK, then wait sack is&n;&t;&t; * automatically negated.&n;&t;&t; */
id|nsp32_write1
c_func
(paren
id|base
comma
id|SCSI_DATA_WITH_ACK
comma
id|data-&gt;msgoutbuf
(braket
id|i
)braket
)paren
suffix:semicolon
id|nsp32_wait_sack
c_func
(paren
id|data
comma
id|NEGATE
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_MSGOUTOCCUR
comma
l_string|&quot;bus: 0x%x&bslash;n&quot;
comma
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_BUS_MONITOR
)paren
)paren
suffix:semicolon
)brace
suffix:semicolon
id|data-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_MSGOUTOCCUR
comma
l_string|&quot;exit&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Restart AutoSCSI&n; *&n; * Note: Restarting AutoSCSI needs set:&n; *&t;&t;SYNC_REG, ACK_WIDTH, SGT_ADR, TRANSFER_CONTROL&n; */
DECL|function|nsp32_restart_autoscsi
r_static
r_void
id|nsp32_restart_autoscsi
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
r_int
id|command
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|SCpnt-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
r_int
r_int
id|transfer
op_assign
l_int|0
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_RESTART
comma
l_string|&quot;enter&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;cur_target
op_eq
l_int|NULL
op_logical_or
id|data-&gt;cur_lunt
op_eq
l_int|NULL
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;Target or Lun is invalid&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * set SYNC_REG&n;&t; * Don&squot;t set BM_START_ADR before setting this register.&n;&t; */
id|nsp32_write1
c_func
(paren
id|base
comma
id|SYNC_REG
comma
id|data-&gt;cur_target-&gt;syncreg
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set ACKWIDTH&n;&t; */
id|nsp32_write1
c_func
(paren
id|base
comma
id|ACK_WIDTH
comma
id|data-&gt;cur_target-&gt;ackwidth
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set SREQ hazard killer sampling rate&n;&t; */
id|nsp32_write1
c_func
(paren
id|base
comma
id|SREQ_SMPL_RATE
comma
id|data-&gt;cur_target-&gt;sample_reg
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set SGT ADDR (physical address)&n;&t; */
id|nsp32_write4
c_func
(paren
id|base
comma
id|SGT_ADR
comma
id|data-&gt;cur_lunt-&gt;sglun_paddr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set TRANSFER CONTROL REG&n;&t; */
id|transfer
op_assign
l_int|0
suffix:semicolon
id|transfer
op_or_assign
(paren
id|TRANSFER_GO
op_or
id|ALL_COUNTER_CLR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;trans_method
op_amp
id|NSP32_TRANSFER_BUSMASTER
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;request_bufflen
OG
l_int|0
)paren
(brace
id|transfer
op_or_assign
id|BM_START
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|data-&gt;trans_method
op_amp
id|NSP32_TRANSFER_MMIO
)paren
(brace
id|transfer
op_or_assign
id|CB_MMIO_MODE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|data-&gt;trans_method
op_amp
id|NSP32_TRANSFER_PIO
)paren
(brace
id|transfer
op_or_assign
id|CB_IO_MODE
suffix:semicolon
)brace
id|nsp32_write2
c_func
(paren
id|base
comma
id|TRANSFER_CONTROL
comma
id|transfer
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * restart AutoSCSI&n;&t; *&n;&t; * TODO: COMMANDCONTROL_AUTO_COMMAND_PHASE is needed ?&n;&t; */
id|command
op_or_assign
(paren
id|CLEAR_CDB_FIFO_POINTER
op_or
id|AUTO_COMMAND_PHASE
op_or
id|AUTOSCSI_RESTART
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|COMMAND_CONTROL
comma
id|command
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_RESTART
comma
l_string|&quot;exit&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * cannot run automatically message in occur&n; */
DECL|function|nsp32_msgin_occur
r_static
r_void
id|nsp32_msgin_occur
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
r_int
id|irq_status
comma
r_int
r_int
id|execph
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|SCpnt-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|base
op_assign
id|SCpnt-&gt;device-&gt;host-&gt;io_port
suffix:semicolon
r_int
r_char
id|msg
suffix:semicolon
r_int
r_char
id|msgtype
suffix:semicolon
r_int
r_char
id|newlun
suffix:semicolon
r_int
r_int
id|command
op_assign
l_int|0
suffix:semicolon
r_int
id|msgclear
op_assign
id|TRUE
suffix:semicolon
r_int
id|new_sgtp
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/*&n;&t; * read first message&n;&t; *    Use SCSIDATA_W_ACK instead of SCSIDATAIN, because the procedure&n;&t; *    of Message-In have to be processed before sending back SCSI ACK.&n;&t; */
id|msg
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_DATA_IN
)paren
suffix:semicolon
id|data-&gt;msginbuf
(braket
(paren
r_int
r_char
)paren
id|data-&gt;msgin_len
)braket
op_assign
id|msg
suffix:semicolon
id|msgtype
op_assign
id|data-&gt;msginbuf
(braket
l_int|0
)braket
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_MSGINOCCUR
comma
l_string|&quot;enter: msglen: 0x%x msgin: 0x%x msgtype: 0x%x&quot;
comma
id|data-&gt;msgin_len
comma
id|msg
comma
id|msgtype
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * TODO: We need checking whether bus phase is message in?&n;&t; */
multiline_comment|/*&n;&t; * assert SCSI ACK&n;&t; */
id|nsp32_sack_assert
c_func
(paren
id|data
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * processing IDENTIFY&n;&t; */
r_if
c_cond
(paren
id|msgtype
op_amp
l_int|0x80
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|irq_status
op_amp
id|IRQSTATUS_RESELECT_OCCUER
)paren
)paren
(brace
multiline_comment|/* Invalid (non reselect) phase */
r_goto
id|reject
suffix:semicolon
)brace
id|newlun
op_assign
id|msgtype
op_amp
l_int|0x1f
suffix:semicolon
multiline_comment|/* TODO: SPI-3 compliant? */
id|ret
op_assign
id|nsp32_reselection
c_func
(paren
id|SCpnt
comma
id|newlun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|TRUE
)paren
(brace
r_goto
id|restart
suffix:semicolon
)brace
r_else
(brace
r_goto
id|reject
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * processing messages except for IDENTIFY&n;&t; *&n;&t; * TODO: Messages are all SCSI-2 terminology. SCSI-3 compliance is TODO.&n;&t; */
r_switch
c_cond
(paren
id|msgtype
)paren
(brace
multiline_comment|/*&n;&t; * 1-byte message&n;&t; */
r_case
id|COMMAND_COMPLETE
suffix:colon
r_case
id|DISCONNECT
suffix:colon
multiline_comment|/*&n;&t;&t; * These messages should not be occurred.&n;&t;&t; * They should be processed on AutoSCSI sequencer.&n;&t;&t; */
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;unexpected message of AutoSCSI MsgIn: 0x%x&quot;
comma
id|msg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RESTORE_POINTERS
suffix:colon
multiline_comment|/*&n;&t;&t; * AutoMsgIn03 is disabled, and HBA gets this message.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|execph
op_amp
id|DATA_IN_PHASE
)paren
op_logical_or
(paren
id|execph
op_amp
id|DATA_OUT_PHASE
)paren
)paren
(brace
r_int
r_int
id|s_sacklen
suffix:semicolon
id|s_sacklen
op_assign
id|nsp32_read4
c_func
(paren
id|base
comma
id|SAVED_SACK_CNT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|execph
op_amp
id|MSGIN_02_VALID
)paren
op_logical_and
(paren
id|s_sacklen
OG
l_int|0
)paren
)paren
(brace
id|nsp32_adjust_busfree
c_func
(paren
id|SCpnt
comma
id|s_sacklen
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* No need to rewrite SGT */
)brace
)brace
id|data-&gt;cur_lunt-&gt;msgin03
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Update with the new value */
multiline_comment|/* reset SACK/SavedACK counter (or ALL clear?) */
id|nsp32_write4
c_func
(paren
id|base
comma
id|CLR_COUNTER
comma
id|CLRCOUNTER_ALLMASK
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * set new sg pointer&n;&t;&t; */
id|new_sgtp
op_assign
id|data-&gt;cur_lunt-&gt;sglun_paddr
op_plus
(paren
id|data-&gt;cur_lunt-&gt;cur_entry
op_star
r_sizeof
(paren
id|nsp32_sgtable
)paren
)paren
suffix:semicolon
id|nsp32_write4
c_func
(paren
id|base
comma
id|SGT_ADR
comma
id|new_sgtp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SAVE_POINTERS
suffix:colon
multiline_comment|/*&n;&t;&t; * These messages should not be occurred.&n;&t;&t; * They should be processed on AutoSCSI sequencer.&n;&t;&t; */
id|nsp32_msg
(paren
id|KERN_WARNING
comma
l_string|&quot;unexpected message of AutoSCSI MsgIn: SAVE_POINTERS&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MESSAGE_REJECT
suffix:colon
multiline_comment|/* If previous message_out is sending SDTR, and get &n;&t;&t;   message_reject from target, SDTR negotiation is failed */
r_if
c_cond
(paren
id|data-&gt;cur_target-&gt;sync_flag
op_amp
(paren
id|SDTR_INITIATOR
op_or
id|SDTR_TARGET
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Current target is negotiating SDTR, but it&squot;s&n;&t;&t;&t; * failed.  Fall back to async transfer mode, and set&n;&t;&t;&t; * SDTR_DONE.&n;&t;&t;&t; */
id|nsp32_set_async
c_func
(paren
id|data
comma
id|data-&gt;cur_target
)paren
suffix:semicolon
id|data-&gt;cur_target-&gt;sync_flag
op_and_assign
op_complement
id|SDTR_INITIATOR
suffix:semicolon
id|data-&gt;cur_target-&gt;sync_flag
op_or_assign
id|SDTR_DONE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|LINKED_CMD_COMPLETE
suffix:colon
r_case
id|LINKED_FLG_CMD_COMPLETE
suffix:colon
multiline_comment|/* queue tag is not supported currently */
id|nsp32_msg
(paren
id|KERN_WARNING
comma
l_string|&quot;unsupported message: 0x%x&quot;
comma
id|msgtype
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INITIATE_RECOVERY
suffix:colon
multiline_comment|/* staring ECA (Extended Contingent Allegiance) state. */
multiline_comment|/* This message is declined in SPI2 or later. */
r_goto
id|reject
suffix:semicolon
multiline_comment|/*&n;&t; * 2-byte message&n;&t; */
r_case
id|SIMPLE_QUEUE_TAG
suffix:colon
r_case
l_int|0x23
suffix:colon
multiline_comment|/*&n;&t;&t; * 0x23: Ignore_Wide_Residue is not declared in scsi.h.&n;&t;&t; * No support is needed.&n;&t;&t; */
r_if
c_cond
(paren
id|data-&gt;msgin_len
op_ge
l_int|1
)paren
(brace
r_goto
id|reject
suffix:semicolon
)brace
multiline_comment|/* current position is 1-byte of 2 byte */
id|msgclear
op_assign
id|FALSE
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t; * extended message&n;&t; */
r_case
id|EXTENDED_MESSAGE
suffix:colon
r_if
c_cond
(paren
id|data-&gt;msgin_len
OL
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Current position does not reach 2-byte&n;&t;&t;&t; * (2-byte is extended message length).&n;&t;&t;&t; */
id|msgclear
op_assign
id|FALSE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|data-&gt;msginbuf
(braket
l_int|1
)braket
op_plus
l_int|1
)paren
OG
id|data-&gt;msgin_len
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Current extended message has msginbuf[1] + 2&n;&t;&t;&t; * (msgin_len starts counting from 0, so buf[1] + 1).&n;&t;&t;&t; * If current message position is not finished,&n;&t;&t;&t; * continue receiving message.&n;&t;&t;&t; */
id|msgclear
op_assign
id|FALSE
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Reach here means regular length of each type of &n;&t;&t; * extended messages.&n;&t;&t; */
r_switch
c_cond
(paren
id|data-&gt;msginbuf
(braket
l_int|2
)braket
)paren
(brace
r_case
id|EXTENDED_MODIFY_DATA_POINTER
suffix:colon
multiline_comment|/* TODO */
r_goto
id|reject
suffix:semicolon
multiline_comment|/* not implemented yet */
r_break
suffix:semicolon
r_case
id|EXTENDED_SDTR
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Exchange this message between initiator and target.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|data-&gt;msgin_len
op_ne
id|EXTENDED_SDTR_LEN
op_plus
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * received inappropriate message.&n;&t;&t;&t;&t; */
r_goto
id|reject
suffix:semicolon
r_break
suffix:semicolon
)brace
id|nsp32_analyze_sdtr
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EXTENDED_EXTENDED_IDENTIFY
suffix:colon
multiline_comment|/* SCSI-I only, not supported. */
r_goto
id|reject
suffix:semicolon
multiline_comment|/* not implemented yet */
r_break
suffix:semicolon
r_case
id|EXTENDED_WDTR
suffix:colon
r_goto
id|reject
suffix:semicolon
multiline_comment|/* not implemented yet */
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|reject
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|reject
suffix:semicolon
)brace
id|restart
suffix:colon
r_if
c_cond
(paren
id|msgclear
op_eq
id|TRUE
)paren
(brace
id|data-&gt;msgin_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If restarting AutoSCSI, but there are some message to out&n;&t;&t; * (msgout_len &gt; 0), set AutoATN, and set SCSIMSGOUT as 0&n;&t;&t; * (MV_VALID = 0). When commandcontrol is written with&n;&t;&t; * AutoSCSI restart, at the same time MsgOutOccur should be&n;&t;&t; * happened (however, such situation is really possible...?).&n;&t;&t; */
r_if
c_cond
(paren
id|data-&gt;msgout_len
OG
l_int|0
)paren
(brace
id|nsp32_write4
c_func
(paren
id|base
comma
id|SCSI_MSG_OUT
comma
l_int|0
)paren
suffix:semicolon
id|command
op_or_assign
id|AUTO_ATN
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * restart AutoSCSI&n;&t;&t; * If it&squot;s failed, COMMANDCONTROL_AUTO_COMMAND_PHASE is needed.&n;&t;&t; */
id|command
op_or_assign
(paren
id|AUTO_MSGIN_00_OR_04
op_or
id|AUTO_MSGIN_02
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If current msgin03 is TRUE, then flag on.&n;&t;&t; */
r_if
c_cond
(paren
id|data-&gt;cur_lunt-&gt;msgin03
op_eq
id|TRUE
)paren
(brace
id|command
op_or_assign
id|AUTO_MSGIN_03
suffix:semicolon
)brace
id|data-&gt;cur_lunt-&gt;msgin03
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
(brace
id|data-&gt;msgin_len
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * restart AutoSCSI&n;&t; */
id|nsp32_restart_autoscsi
c_func
(paren
id|SCpnt
comma
id|command
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * wait SCSI REQ negate for REQ-ACK handshake&n;&t; */
id|nsp32_wait_req
c_func
(paren
id|data
comma
id|NEGATE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * negate SCSI ACK&n;&t; */
id|nsp32_sack_negate
c_func
(paren
id|data
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_MSGINOCCUR
comma
l_string|&quot;exit&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
id|reject
suffix:colon
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;invalid or unsupported MessageIn, rejected. &quot;
l_string|&quot;current msg: 0x%x (len: 0x%x), processing msg: 0x%x&quot;
comma
id|msg
comma
id|data-&gt;msgin_len
comma
id|msgtype
)paren
suffix:semicolon
id|nsp32_build_reject
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|data-&gt;msgin_len
op_assign
l_int|0
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
multiline_comment|/*&n; * &n; */
DECL|function|nsp32_analyze_sdtr
r_static
r_void
id|nsp32_analyze_sdtr
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|SCpnt-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
id|nsp32_target
op_star
id|target
op_assign
id|data-&gt;cur_target
suffix:semicolon
id|nsp32_sync_table
op_star
id|synct
suffix:semicolon
r_int
r_char
id|get_period
op_assign
id|data-&gt;msginbuf
(braket
l_int|3
)braket
suffix:semicolon
r_int
r_char
id|get_offset
op_assign
id|data-&gt;msginbuf
(braket
l_int|4
)braket
suffix:semicolon
r_int
id|entry
suffix:semicolon
r_int
id|syncnum
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_MSGINOCCUR
comma
l_string|&quot;enter&quot;
)paren
suffix:semicolon
id|synct
op_assign
id|data-&gt;synct
suffix:semicolon
id|syncnum
op_assign
id|data-&gt;syncnum
suffix:semicolon
multiline_comment|/*&n;&t; * If this inititor sent the SDTR message, then target responds SDTR,&n;&t; * initiator SYNCREG, ACKWIDTH from SDTR parameter.&n;&t; * Messages are not appropriate, then send back reject message.&n;&t; * If initiator did not send the SDTR, but target sends SDTR, &n;&t; * initiator calculator the appropriate parameter and send back SDTR.&n;&t; */
r_if
c_cond
(paren
id|target-&gt;sync_flag
op_amp
id|SDTR_INITIATOR
)paren
(brace
multiline_comment|/*&n;&t;&t; * Initiator sent SDTR, the target responds and&n;&t;&t; * send back negotiation SDTR.&n;&t;&t; */
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_MSGINOCCUR
comma
l_string|&quot;target responds SDTR&quot;
)paren
suffix:semicolon
id|target-&gt;sync_flag
op_and_assign
op_complement
id|SDTR_INITIATOR
suffix:semicolon
id|target-&gt;sync_flag
op_or_assign
id|SDTR_DONE
suffix:semicolon
multiline_comment|/*&n;&t;&t; * offset:&n;&t;&t; */
r_if
c_cond
(paren
id|get_offset
OG
id|SYNC_OFFSET
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Negotiation is failed, the target send back&n;&t;&t;&t; * unexpected offset value.&n;&t;&t;&t; */
r_goto
id|reject
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_offset
op_eq
id|ASYNC_OFFSET
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Negotiation is succeeded, the target want&n;&t;&t;&t; * to fall back into asynchronous transfer mode.&n;&t;&t;&t; */
r_goto
id|async
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * period:&n;&t;&t; *    Check whether sync period is too short. If too short,&n;&t;&t; *    fall back to async mode. If it&squot;s ok, then investigate&n;&t;&t; *    the received sync period. If sync period is acceptable&n;&t;&t; *    between sync table start_period and end_period, then&n;&t;&t; *    set this I_T nexus as sent offset and period.&n;&t;&t; *    If it&squot;s not acceptable, send back reject and fall back&n;&t;&t; *    to async mode.&n;&t;&t; */
r_if
c_cond
(paren
id|get_period
OL
id|data-&gt;synct
(braket
l_int|0
)braket
dot
id|period_num
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Negotiation is failed, the target send back&n;&t;&t;&t; * unexpected period value.&n;&t;&t;&t; */
r_goto
id|reject
suffix:semicolon
)brace
id|entry
op_assign
id|nsp32_search_period_entry
c_func
(paren
id|data
comma
id|target
comma
id|get_period
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
OL
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Target want to use long period which is not &n;&t;&t;&t; * acceptable NinjaSCSI-32Bi/UDE.&n;&t;&t;&t; */
r_goto
id|reject
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Set new sync table and offset in this I_T nexus.&n;&t;&t; */
id|nsp32_set_sync_entry
c_func
(paren
id|data
comma
id|target
comma
id|entry
comma
id|get_offset
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Target send SDTR to initiator. */
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_MSGINOCCUR
comma
l_string|&quot;target send SDTR&quot;
)paren
suffix:semicolon
id|target-&gt;sync_flag
op_or_assign
id|SDTR_INITIATOR
suffix:semicolon
multiline_comment|/* offset: */
r_if
c_cond
(paren
id|get_offset
OG
id|SYNC_OFFSET
)paren
(brace
multiline_comment|/* send back as SYNC_OFFSET */
id|get_offset
op_assign
id|SYNC_OFFSET
suffix:semicolon
)brace
multiline_comment|/* period: */
r_if
c_cond
(paren
id|get_period
OL
id|data-&gt;synct
(braket
l_int|0
)braket
dot
id|period_num
)paren
(brace
id|get_period
op_assign
id|data-&gt;synct
(braket
l_int|0
)braket
dot
id|period_num
suffix:semicolon
)brace
id|entry
op_assign
id|nsp32_search_period_entry
c_func
(paren
id|data
comma
id|target
comma
id|get_period
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_offset
op_eq
id|ASYNC_OFFSET
op_logical_or
id|entry
OL
l_int|0
)paren
(brace
id|nsp32_set_async
c_func
(paren
id|data
comma
id|target
)paren
suffix:semicolon
id|nsp32_build_sdtr
c_func
(paren
id|SCpnt
comma
l_int|0
comma
id|ASYNC_OFFSET
)paren
suffix:semicolon
)brace
r_else
(brace
id|nsp32_set_sync_entry
c_func
(paren
id|data
comma
id|target
comma
id|entry
comma
id|get_offset
)paren
suffix:semicolon
id|nsp32_build_sdtr
c_func
(paren
id|SCpnt
comma
id|get_period
comma
id|get_offset
)paren
suffix:semicolon
)brace
)brace
id|target-&gt;period
op_assign
id|get_period
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_MSGINOCCUR
comma
l_string|&quot;exit&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
id|reject
suffix:colon
multiline_comment|/*&n;&t; * If the current message is unacceptable, send back to the target&n;&t; * with reject message.&n;&t; */
id|nsp32_build_reject
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|async
suffix:colon
id|nsp32_set_async
c_func
(paren
id|data
comma
id|target
)paren
suffix:semicolon
multiline_comment|/* set as ASYNC transfer mode */
id|target-&gt;period
op_assign
l_int|0
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_MSGINOCCUR
comma
l_string|&quot;exit: set async&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Search config entry number matched in sync_table from given&n; * target and speed period value. If failed to search, return negative value.&n; */
DECL|function|nsp32_search_period_entry
r_static
r_int
id|nsp32_search_period_entry
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
id|nsp32_target
op_star
id|target
comma
r_int
r_char
id|period
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|target-&gt;limit_entry
op_ge
id|data-&gt;syncnum
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;limit_entry exceeds syncnum!&quot;
)paren
suffix:semicolon
id|target-&gt;limit_entry
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|target-&gt;limit_entry
suffix:semicolon
id|i
OL
id|data-&gt;syncnum
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|period
op_ge
id|data-&gt;synct
(braket
id|i
)braket
dot
id|start_period
op_logical_and
id|period
op_le
id|data-&gt;synct
(braket
id|i
)braket
dot
id|end_period
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Check given period value is over the sync_table value.&n;&t; * If so, return max value.&n;&t; */
r_if
c_cond
(paren
id|i
op_eq
id|data-&gt;syncnum
)paren
(brace
id|i
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; * target &lt;-&gt; initiator use ASYNC transfer&n; */
DECL|function|nsp32_set_async
r_static
r_void
id|nsp32_set_async
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
id|nsp32_target
op_star
id|target
)paren
(brace
r_int
r_char
id|period
op_assign
id|data-&gt;synct
(braket
id|target-&gt;limit_entry
)braket
dot
id|period_num
suffix:semicolon
id|target-&gt;offset
op_assign
id|ASYNC_OFFSET
suffix:semicolon
id|target-&gt;period
op_assign
l_int|0
suffix:semicolon
id|target-&gt;syncreg
op_assign
id|TO_SYNCREG
c_func
(paren
id|period
comma
id|ASYNC_OFFSET
)paren
suffix:semicolon
id|target-&gt;ackwidth
op_assign
l_int|0
suffix:semicolon
id|target-&gt;sample_reg
op_assign
l_int|0
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_SYNC
comma
l_string|&quot;set async&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * target &lt;-&gt; initiator use maximum SYNC transfer&n; */
DECL|function|nsp32_set_max_sync
r_static
r_void
id|nsp32_set_max_sync
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
id|nsp32_target
op_star
id|target
comma
r_int
r_char
op_star
id|period
comma
r_int
r_char
op_star
id|offset
)paren
(brace
r_int
r_char
id|period_num
comma
id|ackwidth
suffix:semicolon
id|period_num
op_assign
id|data-&gt;synct
(braket
id|target-&gt;limit_entry
)braket
dot
id|period_num
suffix:semicolon
op_star
id|period
op_assign
id|data-&gt;synct
(braket
id|target-&gt;limit_entry
)braket
dot
id|start_period
suffix:semicolon
id|ackwidth
op_assign
id|data-&gt;synct
(braket
id|target-&gt;limit_entry
)braket
dot
id|ackwidth
suffix:semicolon
op_star
id|offset
op_assign
id|SYNC_OFFSET
suffix:semicolon
id|target-&gt;syncreg
op_assign
id|TO_SYNCREG
c_func
(paren
id|period_num
comma
op_star
id|offset
)paren
suffix:semicolon
id|target-&gt;ackwidth
op_assign
id|ackwidth
suffix:semicolon
id|target-&gt;offset
op_assign
op_star
id|offset
suffix:semicolon
id|target-&gt;sample_reg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* disable SREQ sampling */
)brace
multiline_comment|/*&n; * target &lt;-&gt; initiator use entry number speed&n; */
DECL|function|nsp32_set_sync_entry
r_static
r_void
id|nsp32_set_sync_entry
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
id|nsp32_target
op_star
id|target
comma
r_int
id|entry
comma
r_int
r_char
id|offset
)paren
(brace
r_int
r_char
id|period
comma
id|ackwidth
comma
id|sample_rate
suffix:semicolon
id|period
op_assign
id|data-&gt;synct
(braket
id|entry
)braket
dot
id|period_num
suffix:semicolon
id|ackwidth
op_assign
id|data-&gt;synct
(braket
id|entry
)braket
dot
id|ackwidth
suffix:semicolon
id|offset
op_assign
id|offset
suffix:semicolon
id|sample_rate
op_assign
id|data-&gt;synct
(braket
id|entry
)braket
dot
id|sample_rate
suffix:semicolon
id|target-&gt;syncreg
op_assign
id|TO_SYNCREG
c_func
(paren
id|period
comma
id|offset
)paren
suffix:semicolon
id|target-&gt;ackwidth
op_assign
id|ackwidth
suffix:semicolon
id|target-&gt;offset
op_assign
id|offset
suffix:semicolon
id|target-&gt;sample_reg
op_assign
id|sample_rate
op_or
id|SAMPLING_ENABLE
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_SYNC
comma
l_string|&quot;set sync&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * It waits until SCSI REQ becomes assertion or negation state.&n; *&n; * Note: If nsp32_msgin_occur is called, we asserts SCSI ACK. Then&n; *     connected target responds SCSI REQ negation.  We have to wait&n; *     SCSI REQ becomes negation in order to negate SCSI ACK signal for&n; *     REQ-ACK handshake.&n; */
DECL|function|nsp32_wait_req
r_static
r_void
id|nsp32_wait_req
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
r_int
id|state
)paren
(brace
r_int
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
r_int
id|wait_time
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|bus
comma
id|req_bit
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|state
op_eq
id|ASSERT
)paren
op_logical_or
(paren
id|state
op_eq
id|NEGATE
)paren
)paren
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;unknown state designation&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* REQ is BIT(5) */
id|req_bit
op_assign
(paren
id|state
op_eq
id|ASSERT
ques
c_cond
id|BUSMON_REQ
suffix:colon
l_int|0
)paren
suffix:semicolon
r_do
(brace
id|bus
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_BUS_MONITOR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bus
op_amp
id|BUSMON_REQ
)paren
op_eq
id|req_bit
)paren
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_WAIT
comma
l_string|&quot;wait_time: %d&quot;
comma
id|wait_time
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|wait_time
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|wait_time
OL
id|REQSACK_TIMEOUT_TIME
)paren
suffix:semicolon
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;wait REQ timeout, req_bit: 0x%x&quot;
comma
id|req_bit
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * It waits until SCSI SACK becomes assertion or negation state.&n; */
DECL|function|nsp32_wait_sack
r_static
r_void
id|nsp32_wait_sack
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
r_int
id|state
)paren
(brace
r_int
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
r_int
id|wait_time
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|bus
comma
id|ack_bit
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|state
op_eq
id|ASSERT
)paren
op_logical_or
(paren
id|state
op_eq
id|NEGATE
)paren
)paren
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;unknown state designation&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* ACK is BIT(4) */
id|ack_bit
op_assign
(paren
id|state
op_eq
id|ASSERT
ques
c_cond
id|BUSMON_ACK
suffix:colon
l_int|0
)paren
suffix:semicolon
r_do
(brace
id|bus
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_BUS_MONITOR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bus
op_amp
id|BUSMON_ACK
)paren
op_eq
id|ack_bit
)paren
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_WAIT
comma
l_string|&quot;wait_time: %d&quot;
comma
id|wait_time
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|wait_time
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|wait_time
OL
id|REQSACK_TIMEOUT_TIME
)paren
suffix:semicolon
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;wait SACK timeout, ack_bit: 0x%x&quot;
comma
id|ack_bit
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * assert SCSI ACK&n; *&n; * Note: SCSI ACK assertion needs with ACKENB=1, AUTODIRECTION=1.&n; */
DECL|function|nsp32_sack_assert
r_static
r_void
id|nsp32_sack_assert
c_func
(paren
id|nsp32_hw_data
op_star
id|data
)paren
(brace
r_int
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
r_int
r_char
id|busctrl
suffix:semicolon
id|busctrl
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_BUS_CONTROL
)paren
suffix:semicolon
id|busctrl
op_or_assign
(paren
id|BUSCTL_ACK
op_or
id|AUTODIRECTION
op_or
id|ACKENB
)paren
suffix:semicolon
id|nsp32_write1
c_func
(paren
id|base
comma
id|SCSI_BUS_CONTROL
comma
id|busctrl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * negate SCSI ACK&n; */
DECL|function|nsp32_sack_negate
r_static
r_void
id|nsp32_sack_negate
c_func
(paren
id|nsp32_hw_data
op_star
id|data
)paren
(brace
r_int
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
r_int
r_char
id|busctrl
suffix:semicolon
id|busctrl
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_BUS_CONTROL
)paren
suffix:semicolon
id|busctrl
op_and_assign
op_complement
id|BUSCTL_ACK
suffix:semicolon
id|nsp32_write1
c_func
(paren
id|base
comma
id|SCSI_BUS_CONTROL
comma
id|busctrl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Note: n_io_port is defined as 0x7f because I/O register port is&n; *&t; assigned as:&n; *&t;0x800-0x8ff: memory mapped I/O port&n; *&t;0x900-0xbff: (map same 0x800-0x8ff I/O port image repeatedly)&n; *&t;0xc00-0xfff: CardBus status registers&n; */
macro_line|#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,5,73))
DECL|macro|DETECT_OK
mdefine_line|#define DETECT_OK 0
DECL|macro|DETECT_NG
mdefine_line|#define DETECT_NG 1
DECL|macro|PCIDEV
mdefine_line|#define PCIDEV    pdev
DECL|function|nsp32_detect
r_static
r_int
id|nsp32_detect
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
macro_line|#else
mdefine_line|#define DETECT_OK 1
mdefine_line|#define DETECT_NG 0
mdefine_line|#define PCIDEV    (data-&gt;Pci)
r_static
r_int
id|nsp32_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|sht
)paren
macro_line|#endif
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
multiline_comment|/* registered host structure */
r_struct
id|resource
op_star
id|res
suffix:semicolon
id|nsp32_hw_data
op_star
id|data
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_REGISTER
comma
l_string|&quot;enter&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * register this HBA as SCSI device&n;&t; */
macro_line|#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,5,73))
id|host
op_assign
id|scsi_host_alloc
c_func
(paren
op_amp
id|nsp32_template
comma
r_sizeof
(paren
id|nsp32_hw_data
)paren
)paren
suffix:semicolon
macro_line|#else
id|host
op_assign
id|scsi_register
c_func
(paren
id|sht
comma
r_sizeof
(paren
id|nsp32_hw_data
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|host
op_eq
l_int|NULL
)paren
(brace
id|nsp32_msg
(paren
id|KERN_ERR
comma
l_string|&quot;failed to scsi register&quot;
)paren
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * set nsp32_hw_data&n;&t; */
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|memcpy
c_func
(paren
id|data
comma
op_amp
id|nsp32_data_base
comma
r_sizeof
(paren
id|nsp32_hw_data
)paren
)paren
suffix:semicolon
id|host-&gt;irq
op_assign
id|data-&gt;IrqNumber
suffix:semicolon
id|host-&gt;io_port
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
id|host-&gt;unique_id
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
id|host-&gt;n_io_port
op_assign
id|data-&gt;NumAddress
suffix:semicolon
id|host-&gt;base
op_assign
id|data-&gt;MmioAddress
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,5,63))
id|scsi_set_device
c_func
(paren
id|host
comma
op_amp
id|PCIDEV-&gt;dev
)paren
suffix:semicolon
macro_line|#else
id|scsi_set_pci_device
c_func
(paren
id|host
comma
id|PCIDEV
)paren
suffix:semicolon
macro_line|#endif
id|data-&gt;Host
op_assign
id|host
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|data-&gt;Lock
)paren
)paren
suffix:semicolon
id|data-&gt;cur_lunt
op_assign
l_int|NULL
suffix:semicolon
id|data-&gt;cur_target
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Bus master transfer mode is supported currently.&n;&t; */
id|data-&gt;trans_method
op_assign
id|NSP32_TRANSFER_BUSMASTER
suffix:semicolon
multiline_comment|/*&n;&t; * Set clock div, CLOCK_4 (HBA has own external clock, and&n;&t; * dividing * 100ns/4).&n;&t; * Currently CLOCK_4 has only tested, not for CLOCK_2/PCICLK yet.&n;&t; */
id|data-&gt;clock
op_assign
id|CLOCK_4
suffix:semicolon
multiline_comment|/*&n;&t; * Select appropriate nsp32_sync_table and set I_CLOCKDIV.&n;&t; */
r_switch
c_cond
(paren
id|data-&gt;clock
)paren
(brace
r_case
id|CLOCK_4
suffix:colon
multiline_comment|/* If data-&gt;clock is CLOCK_4, then select 40M sync table. */
id|data-&gt;synct
op_assign
id|nsp32_sync_table_40M
suffix:semicolon
id|data-&gt;syncnum
op_assign
id|ARRAY_SIZE
c_func
(paren
id|nsp32_sync_table_40M
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CLOCK_2
suffix:colon
multiline_comment|/* If data-&gt;clock is CLOCK_2, then select 20M sync table. */
id|data-&gt;synct
op_assign
id|nsp32_sync_table_20M
suffix:semicolon
id|data-&gt;syncnum
op_assign
id|ARRAY_SIZE
c_func
(paren
id|nsp32_sync_table_20M
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCICLK
suffix:colon
multiline_comment|/* If data-&gt;clock is PCICLK, then select pci sync table. */
id|data-&gt;synct
op_assign
id|nsp32_sync_table_pci
suffix:semicolon
id|data-&gt;syncnum
op_assign
id|ARRAY_SIZE
c_func
(paren
id|nsp32_sync_table_pci
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;Invalid clock div is selected, set CLOCK_4.&quot;
)paren
suffix:semicolon
multiline_comment|/* Use default value CLOCK_4 */
id|data-&gt;clock
op_assign
id|CLOCK_4
suffix:semicolon
id|data-&gt;synct
op_assign
id|nsp32_sync_table_40M
suffix:semicolon
id|data-&gt;syncnum
op_assign
id|ARRAY_SIZE
c_func
(paren
id|nsp32_sync_table_40M
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * setup nsp32_lunt&n;&t; */
multiline_comment|/*&n;&t; * setup DMA &n;&t; */
r_if
c_cond
(paren
id|pci_set_dma_mask
c_func
(paren
id|PCIDEV
comma
l_int|0xffffffffUL
)paren
op_ne
l_int|0
)paren
(brace
id|nsp32_msg
(paren
id|KERN_ERR
comma
l_string|&quot;failed to set PCI DMA mask&quot;
)paren
suffix:semicolon
r_goto
id|scsi_unregister
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * allocate autoparam DMA resource.&n;&t; */
id|data-&gt;autoparam
op_assign
id|pci_alloc_consistent
c_func
(paren
id|PCIDEV
comma
r_sizeof
(paren
id|nsp32_autoparam
)paren
comma
op_amp
(paren
id|data-&gt;auto_paddr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;autoparam
op_eq
l_int|NULL
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;failed to allocate DMA memory&quot;
)paren
suffix:semicolon
r_goto
id|scsi_unregister
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * allocate scatter-gather DMA resource.&n;&t; */
id|data-&gt;sg_list
op_assign
id|pci_alloc_consistent
c_func
(paren
id|PCIDEV
comma
id|NSP32_SG_TABLE_SIZE
comma
op_amp
(paren
id|data-&gt;sg_paddr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;sg_list
op_eq
l_int|NULL
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;failed to allocate DMA memory&quot;
)paren
suffix:semicolon
r_goto
id|free_autoparam
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|data-&gt;lunt
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ARRAY_SIZE
c_func
(paren
id|data-&gt;lunt
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|j
op_increment
)paren
(brace
r_int
id|offset
op_assign
id|i
op_star
id|ARRAY_SIZE
c_func
(paren
id|data-&gt;lunt
(braket
l_int|0
)braket
)paren
op_plus
id|j
suffix:semicolon
id|nsp32_lunt
id|tmp
op_assign
(brace
dot
id|SCpnt
op_assign
l_int|NULL
comma
dot
id|save_datp
op_assign
l_int|0
comma
dot
id|msgin03
op_assign
id|FALSE
comma
dot
id|sg_num
op_assign
l_int|0
comma
dot
id|cur_entry
op_assign
l_int|0
comma
dot
id|sglun
op_assign
op_amp
(paren
id|data-&gt;sg_list
(braket
id|offset
)braket
)paren
comma
dot
id|sglun_paddr
op_assign
id|data-&gt;sg_paddr
op_plus
(paren
id|offset
op_star
r_sizeof
(paren
id|nsp32_sglun
)paren
)paren
comma
)brace
suffix:semicolon
id|data-&gt;lunt
(braket
id|i
)braket
(braket
id|j
)braket
op_assign
id|tmp
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * setup target&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|data-&gt;target
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|nsp32_target
op_star
id|target
op_assign
op_amp
(paren
id|data-&gt;target
(braket
id|i
)braket
)paren
suffix:semicolon
id|target-&gt;limit_entry
op_assign
l_int|0
suffix:semicolon
id|target-&gt;sync_flag
op_assign
l_int|0
suffix:semicolon
id|nsp32_set_async
c_func
(paren
id|data
comma
id|target
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * EEPROM check&n;&t; */
id|ret
op_assign
id|nsp32_getprom_param
c_func
(paren
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|FALSE
)paren
(brace
id|data-&gt;resettime
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* default 3 */
)brace
multiline_comment|/*&n;&t; * setup HBA&n;&t; */
id|nsp32hw_init
c_func
(paren
id|data
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|data-&gt;info_str
comma
r_sizeof
(paren
id|data-&gt;info_str
)paren
comma
l_string|&quot;NinjaSCSI-32Bi/UDE: irq %d, io 0x%lx+0x%x&quot;
comma
id|host-&gt;irq
comma
id|host-&gt;io_port
comma
id|host-&gt;n_io_port
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * SCSI bus reset&n;&t; *&n;&t; * Note: It&squot;s important to reset SCSI bus in initialization phase.&n;&t; *     NinjaSCSI-32Bi/UDE HBA EEPROM seems to exchange SDTR when&n;&t; *     system is coming up, so SCSI devices connected to HBA is set as&n;&t; *     un-asynchronous mode.  It brings the merit that this HBA is&n;&t; *     ready to start synchronous transfer without any preparation,&n;&t; *     but we are difficult to control transfer speed.  In addition,&n;&t; *     it prevents device transfer speed from effecting EEPROM start-up&n;&t; *     SDTR.  NinjaSCSI-32Bi/UDE has the feature if EEPROM is set as&n;&t; *     Auto Mode, then FAST-10M is selected when SCSI devices are&n;&t; *     connected same or more than 4 devices.  It should be avoided&n;&t; *     depending on this specification. Thus, resetting the SCSI bus&n;&t; *     restores all connected SCSI devices to asynchronous mode, then&n;&t; *     this driver set SDTR safely later, and we can control all SCSI&n;&t; *     device transfer mode.&n;&t; */
id|nsp32_do_bus_reset
c_func
(paren
id|data
)paren
suffix:semicolon
id|ret
op_assign
id|request_irq
c_func
(paren
id|host-&gt;irq
comma
id|do_nsp32_isr
comma
id|SA_SHIRQ
op_or
id|SA_SAMPLE_RANDOM
comma
l_string|&quot;nsp32&quot;
comma
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;Unable to allocate IRQ for NinjaSCSI32 &quot;
l_string|&quot;SCSI PCI controller. Interrupt: %d&quot;
comma
id|host-&gt;irq
)paren
suffix:semicolon
r_goto
id|free_sg_list
suffix:semicolon
)brace
multiline_comment|/*&n;         * PCI IO register&n;         */
id|res
op_assign
id|request_region
c_func
(paren
id|host-&gt;io_port
comma
id|host-&gt;n_io_port
comma
l_string|&quot;nsp32&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
l_int|NULL
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;I/O region 0x%lx+0x%lx is already used&quot;
comma
id|data-&gt;BaseAddress
comma
id|data-&gt;NumAddress
)paren
suffix:semicolon
r_goto
id|free_irq
suffix:semicolon
)brace
macro_line|#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,5,73))
id|scsi_add_host
(paren
id|host
comma
op_amp
id|PCIDEV-&gt;dev
)paren
suffix:semicolon
id|scsi_scan_host
c_func
(paren
id|host
)paren
suffix:semicolon
macro_line|#endif
id|pci_set_drvdata
c_func
(paren
id|PCIDEV
comma
id|host
)paren
suffix:semicolon
r_return
id|DETECT_OK
suffix:semicolon
id|free_irq
suffix:colon
id|free_irq
c_func
(paren
id|host-&gt;irq
comma
id|data
)paren
suffix:semicolon
id|free_sg_list
suffix:colon
id|pci_free_consistent
c_func
(paren
id|PCIDEV
comma
id|NSP32_SG_TABLE_SIZE
comma
id|data-&gt;sg_list
comma
id|data-&gt;sg_paddr
)paren
suffix:semicolon
id|free_autoparam
suffix:colon
id|pci_free_consistent
c_func
(paren
id|PCIDEV
comma
r_sizeof
(paren
id|nsp32_autoparam
)paren
comma
id|data-&gt;autoparam
comma
id|data-&gt;auto_paddr
)paren
suffix:semicolon
id|scsi_unregister
suffix:colon
id|scsi_host_put
c_func
(paren
id|host
)paren
suffix:semicolon
id|err
suffix:colon
r_return
id|DETECT_NG
suffix:semicolon
)brace
DECL|macro|DETECT_OK
macro_line|#undef DETECT_OK
DECL|macro|DETECT_NG
macro_line|#undef DETECT_NG
DECL|macro|PCIDEV
macro_line|#undef PCIDEV
DECL|function|nsp32_release
r_static
r_int
id|nsp32_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;autoparam
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|data-&gt;Pci
comma
r_sizeof
(paren
id|nsp32_autoparam
)paren
comma
id|data-&gt;autoparam
comma
id|data-&gt;auto_paddr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|data-&gt;sg_list
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|data-&gt;Pci
comma
id|NSP32_SG_TABLE_SIZE
comma
id|data-&gt;sg_list
comma
id|data-&gt;sg_paddr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|host-&gt;irq
)paren
(brace
id|free_irq
c_func
(paren
id|host-&gt;irq
comma
id|data
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|host-&gt;io_port
op_logical_and
id|host-&gt;n_io_port
)paren
(brace
id|release_region
c_func
(paren
id|host-&gt;io_port
comma
id|host-&gt;n_io_port
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|data-&gt;MmioAddress
op_ne
l_int|0
)paren
(brace
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|data-&gt;MmioAddress
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|nsp32_info
r_static
r_const
r_char
op_star
id|nsp32_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|shpnt-&gt;hostdata
suffix:semicolon
r_return
id|data-&gt;info_str
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; * error handler&n; */
DECL|function|nsp32_eh_abort
r_static
r_int
id|nsp32_eh_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|SCpnt-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|base
op_assign
id|SCpnt-&gt;device-&gt;host-&gt;io_port
suffix:semicolon
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;abort&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;cur_lunt-&gt;SCpnt
op_eq
l_int|NULL
)paren
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_BUSRESET
comma
l_string|&quot;abort failed&quot;
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|data-&gt;cur_target-&gt;sync_flag
op_amp
(paren
id|SDTR_INITIATOR
op_or
id|SDTR_TARGET
)paren
)paren
(brace
multiline_comment|/* reset SDTR negotiation */
id|data-&gt;cur_target-&gt;sync_flag
op_assign
l_int|0
suffix:semicolon
id|nsp32_set_async
c_func
(paren
id|data
comma
id|data-&gt;cur_target
)paren
suffix:semicolon
)brace
id|nsp32_write2
c_func
(paren
id|base
comma
id|TRANSFER_CONTROL
comma
l_int|0
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|BM_CNT
comma
l_int|0
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|nsp32_scsi_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_BUSRESET
comma
l_string|&quot;abort success&quot;
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
DECL|function|nsp32_eh_bus_reset
r_static
r_int
id|nsp32_eh_bus_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|SCpnt-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|base
op_assign
id|SCpnt-&gt;device-&gt;host-&gt;io_port
suffix:semicolon
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;Bus Reset&quot;
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_BUSRESET
comma
l_string|&quot;SCpnt=0x%x&quot;
comma
id|SCpnt
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|IRQ_CONTROL
comma
id|IRQ_CONTROL_ALL_IRQ_MASK
)paren
suffix:semicolon
id|nsp32_do_bus_reset
c_func
(paren
id|data
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|IRQ_CONTROL
comma
l_int|0
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
multiline_comment|/* SCSI bus reset is succeeded at any time. */
)brace
DECL|function|nsp32_do_bus_reset
r_static
r_void
id|nsp32_do_bus_reset
c_func
(paren
id|nsp32_hw_data
op_star
id|data
)paren
(brace
r_int
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
r_int
r_int
id|intrdat
suffix:semicolon
r_int
id|i
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_BUSRESET
comma
l_string|&quot;in&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * stop all transfer&n;&t; * clear TRANSFERCONTROL_BM_START&n;&t; * clear counter&n;&t; */
id|nsp32_write2
c_func
(paren
id|base
comma
id|TRANSFER_CONTROL
comma
l_int|0
)paren
suffix:semicolon
id|nsp32_write4
c_func
(paren
id|base
comma
id|BM_CNT
comma
l_int|0
)paren
suffix:semicolon
id|nsp32_write4
c_func
(paren
id|base
comma
id|CLR_COUNTER
comma
id|CLRCOUNTER_ALLMASK
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * fall back to asynchronous transfer mode&n;&t; * initialize SDTR negotiation flag&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|data-&gt;target
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|nsp32_target
op_star
id|target
op_assign
op_amp
id|data-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|target-&gt;sync_flag
op_assign
l_int|0
suffix:semicolon
id|nsp32_set_async
c_func
(paren
id|data
comma
id|target
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * reset SCSI bus&n;&t; */
id|nsp32_write1
c_func
(paren
id|base
comma
id|SCSI_BUS_CONTROL
comma
id|BUSCTL_RST
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|RESET_HOLD_TIME
)paren
suffix:semicolon
id|nsp32_write1
c_func
(paren
id|base
comma
id|SCSI_BUS_CONTROL
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
(brace
id|intrdat
op_assign
id|nsp32_read2
c_func
(paren
id|base
comma
id|IRQ_STATUS
)paren
suffix:semicolon
multiline_comment|/* dummy read */
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_BUSRESET
comma
l_string|&quot;irq:1: 0x%x&quot;
comma
id|intrdat
)paren
suffix:semicolon
)brace
id|data-&gt;CurrentSC
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|nsp32_eh_host_reset
r_static
r_int
id|nsp32_eh_host_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|SCpnt-&gt;device-&gt;host
suffix:semicolon
r_int
r_int
id|base
op_assign
id|SCpnt-&gt;device-&gt;host-&gt;io_port
suffix:semicolon
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;Host Reset&quot;
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_BUSRESET
comma
l_string|&quot;SCpnt=0x%x&quot;
comma
id|SCpnt
)paren
suffix:semicolon
id|nsp32hw_init
c_func
(paren
id|data
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|IRQ_CONTROL
comma
id|IRQ_CONTROL_ALL_IRQ_MASK
)paren
suffix:semicolon
id|nsp32_do_bus_reset
c_func
(paren
id|data
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|IRQ_CONTROL
comma
l_int|0
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
multiline_comment|/* Host reset is succeeded at any time. */
)brace
multiline_comment|/**************************************************************************&n; * EEPROM handler&n; */
multiline_comment|/*&n; * getting EEPROM parameter&n; */
DECL|function|nsp32_getprom_param
r_static
r_int
id|nsp32_getprom_param
c_func
(paren
id|nsp32_hw_data
op_star
id|data
)paren
(brace
r_int
id|vendor
op_assign
id|data-&gt;pci_devid-&gt;vendor
suffix:semicolon
r_int
id|device
op_assign
id|data-&gt;pci_devid-&gt;device
suffix:semicolon
r_int
id|ret
comma
id|val
comma
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * EEPROM checking.&n;&t; */
id|ret
op_assign
id|nsp32_prom_read
c_func
(paren
id|data
comma
l_int|0x7e
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0x55
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;No EEPROM detected: 0x%x&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|ret
op_assign
id|nsp32_prom_read
c_func
(paren
id|data
comma
l_int|0x7f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0xaa
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;Invalid number: 0x%x&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * check EEPROM type&n;&t; */
r_if
c_cond
(paren
id|vendor
op_eq
id|PCI_VENDOR_ID_WORKBIT
op_logical_and
id|device
op_eq
id|PCI_DEVICE_ID_WORKBIT_STANDARD
)paren
(brace
id|ret
op_assign
id|nsp32_getprom_c16
c_func
(paren
id|data
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vendor
op_eq
id|PCI_VENDOR_ID_WORKBIT
op_logical_and
id|device
op_eq
id|PCI_DEVICE_ID_NINJASCSI_32BIB_LOGITEC
)paren
(brace
id|ret
op_assign
id|nsp32_getprom_at24
c_func
(paren
id|data
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vendor
op_eq
id|PCI_VENDOR_ID_WORKBIT
op_logical_and
id|device
op_eq
id|PCI_DEVICE_ID_NINJASCSI_32UDE_MELCO
)paren
(brace
id|ret
op_assign
id|nsp32_getprom_at24
c_func
(paren
id|data
)paren
suffix:semicolon
)brace
r_else
(brace
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;Unknown EEPROM&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* for debug : SPROM data full checking */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
l_int|0x1f
suffix:semicolon
id|i
op_increment
)paren
(brace
id|val
op_assign
id|nsp32_prom_read
c_func
(paren
id|data
comma
id|i
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_EEPROM
comma
l_string|&quot;rom address 0x%x : 0x%x&quot;
comma
id|i
comma
id|val
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * AT24C01A (Logitec: LHA-600S), AT24C02 (Melco Buffalo: IFC-USLP) data map:&n; *&n; *   ROMADDR&n; *   0x00 - 0x06 :  Device Synchronous Transfer Period (SCSI ID 0 - 6) &n; *&t;&t;&t;Value 0x0: ASYNC, 0x0c: Ultra-20M, 0x19: Fast-10M&n; *   0x07        :  HBA Synchronous Transfer Period&n; *&t;&t;&t;Value 0: AutoSync, 1: Manual Setting&n; *   0x08 - 0x0f :  Not Used? (0x0)&n; *   0x10        :  Bus Termination&n; * &t;&t;&t;Value 0: Auto[ON], 1: ON, 2: OFF&n; *   0x11        :  Not Used? (0)&n; *   0x12        :  Bus Reset Delay Time (0x03)&n; *   0x13        :  Bootable CD Support&n; *&t;&t;&t;Value 0: Disable, 1: Enable&n; *   0x14        :  Device Scan&n; *&t;&t;&t;Bit   7  6  5  4  3  2  1  0&n; *&t;&t;&t;      |  &lt;-----------------&gt;&n; * &t;&t;&t;      |    SCSI ID: Value 0: Skip, 1: YES&n; *&t;&t;&t;      |-&gt;  Value 0: ALL scan,  Value 1: Manual&n; *   0x15 - 0x1b :  Not Used? (0)&n; *   0x1c        :  Constant? (0x01) (clock div?)&n; *   0x1d - 0x7c :  Not Used (0xff)&n; *   0x7d&t; :  Not Used? (0xff)&n; *   0x7e        :  Constant (0x55), Validity signature&n; *   0x7f        :  Constant (0xaa), Validity signature&n; */
DECL|function|nsp32_getprom_at24
r_static
r_int
id|nsp32_getprom_at24
c_func
(paren
id|nsp32_hw_data
op_star
id|data
)paren
(brace
r_int
id|ret
comma
id|i
suffix:semicolon
r_int
id|auto_sync
suffix:semicolon
id|nsp32_target
op_star
id|target
suffix:semicolon
r_int
id|entry
suffix:semicolon
multiline_comment|/*&n;&t; * Reset time which is designated by EEPROM.&n;&t; *&n;&t; * TODO: Not used yet.&n;&t; */
id|data-&gt;resettime
op_assign
id|nsp32_prom_read
c_func
(paren
id|data
comma
l_int|0x12
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * HBA Synchronous Transfer Period&n;&t; *&n;&t; * Note: auto_sync = 0: auto, 1: manual.  Ninja SCSI HBA spec says&n;&t; *&t;that if auto_sync is 0 (auto), and connected SCSI devices are&n;&t; *&t;same or lower than 3, then transfer speed is set as ULTRA-20M.&n;&t; *&t;On the contrary if connected SCSI devices are same or higher&n;&t; *&t;than 4, then transfer speed is set as FAST-10M.&n;&t; *&n;&t; *&t;I break this rule. The number of connected SCSI devices are&n;&t; *&t;only ignored. If auto_sync is 0 (auto), then transfer speed is&n;&t; *&t;forced as ULTRA-20M.&n;&t; */
id|ret
op_assign
id|nsp32_prom_read
c_func
(paren
id|data
comma
l_int|0x07
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ret
)paren
(brace
r_case
l_int|0
suffix:colon
id|auto_sync
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|auto_sync
op_assign
id|FALSE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;Unsupported Auto Sync mode. Fall back to manual mode.&quot;
)paren
suffix:semicolon
id|auto_sync
op_assign
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|trans_mode
op_eq
id|ULTRA20M_MODE
)paren
(brace
id|auto_sync
op_assign
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * each device Synchronous Transfer Period&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NSP32_HOST_SCSIID
suffix:semicolon
id|i
op_increment
)paren
(brace
id|target
op_assign
op_amp
id|data-&gt;target
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|auto_sync
op_eq
id|TRUE
)paren
(brace
id|target-&gt;limit_entry
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set as ULTRA20M */
)brace
r_else
(brace
id|ret
op_assign
id|nsp32_prom_read
c_func
(paren
id|data
comma
id|i
)paren
suffix:semicolon
id|entry
op_assign
id|nsp32_search_period_entry
c_func
(paren
id|data
comma
id|target
comma
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
OL
l_int|0
)paren
(brace
multiline_comment|/* search failed... set maximum speed */
id|entry
op_assign
l_int|0
suffix:semicolon
)brace
id|target-&gt;limit_entry
op_assign
id|entry
suffix:semicolon
)brace
)brace
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n; * C16 110 (I-O Data: SC-NBD) data map:&n; *&n; *   ROMADDR&n; *   0x00 - 0x06 :  Device Synchronous Transfer Period (SCSI ID 0 - 6) &n; *&t;&t;&t;Value 0x0: 20MB/S, 0x1: 10MB/S, 0x2: 5MB/S, 0x3: ASYNC&n; *   0x07        :  0 (HBA Synchronous Transfer Period: Auto Sync)&n; *   0x08 - 0x0f :  Not Used? (0x0)&n; *   0x10        :  Transfer Mode&n; *&t;&t;&t;Value 0: PIO, 1: Busmater&n; *   0x11        :  Bus Reset Delay Time (0x00-0x20)&n; *   0x12        :  Bus Termination&n; * &t;&t;&t;Value 0: Disable, 1: Enable&n; *   0x13 - 0x19 :  Disconnection&n; *&t;&t;&t;Value 0: Disable, 1: Enable&n; *   0x1a - 0x7c :  Not Used? (0)&n; *   0x7d&t; :  Not Used? (0xf8)&n; *   0x7e        :  Constant (0x55), Validity signature&n; *   0x7f        :  Constant (0xaa), Validity signature&n; */
DECL|function|nsp32_getprom_c16
r_static
r_int
id|nsp32_getprom_c16
c_func
(paren
id|nsp32_hw_data
op_star
id|data
)paren
(brace
r_int
id|ret
comma
id|i
suffix:semicolon
id|nsp32_target
op_star
id|target
suffix:semicolon
r_int
id|entry
comma
id|val
suffix:semicolon
multiline_comment|/*&n;&t; * Reset time which is designated by EEPROM.&n;&t; *&n;&t; * TODO: Not used yet.&n;&t; */
id|data-&gt;resettime
op_assign
id|nsp32_prom_read
c_func
(paren
id|data
comma
l_int|0x11
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * each device Synchronous Transfer Period&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NSP32_HOST_SCSIID
suffix:semicolon
id|i
op_increment
)paren
(brace
id|target
op_assign
op_amp
id|data-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|ret
op_assign
id|nsp32_prom_read
c_func
(paren
id|data
comma
id|i
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ret
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* 20MB/s */
id|val
op_assign
l_int|0x0c
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* 10MB/s */
id|val
op_assign
l_int|0x19
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* 5MB/s */
id|val
op_assign
l_int|0x32
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* ASYNC */
id|val
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* default 20MB/s */
id|val
op_assign
l_int|0x0c
suffix:semicolon
r_break
suffix:semicolon
)brace
id|entry
op_assign
id|nsp32_search_period_entry
c_func
(paren
id|data
comma
id|target
comma
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
OL
l_int|0
op_logical_or
id|trans_mode
op_eq
id|ULTRA20M_MODE
)paren
(brace
multiline_comment|/* search failed... set maximum speed */
id|entry
op_assign
l_int|0
suffix:semicolon
)brace
id|target-&gt;limit_entry
op_assign
id|entry
suffix:semicolon
)brace
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n; * Atmel AT24C01A (drived in 5V) serial EEPROM routines&n; */
DECL|function|nsp32_prom_read
r_static
r_int
id|nsp32_prom_read
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
r_int
id|romaddr
)paren
(brace
r_int
id|i
comma
id|val
suffix:semicolon
multiline_comment|/* start condition */
id|nsp32_prom_start
c_func
(paren
id|data
)paren
suffix:semicolon
multiline_comment|/* device address */
id|nsp32_prom_write_bit
c_func
(paren
id|data
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* 1 */
id|nsp32_prom_write_bit
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* 0 */
id|nsp32_prom_write_bit
c_func
(paren
id|data
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* 1 */
id|nsp32_prom_write_bit
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* 0 */
id|nsp32_prom_write_bit
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* A2: 0 (GND) */
id|nsp32_prom_write_bit
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* A1: 0 (GND) */
id|nsp32_prom_write_bit
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* A0: 0 (GND) */
multiline_comment|/* R/W: W for dummy write */
id|nsp32_prom_write_bit
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* ack */
id|nsp32_prom_write_bit
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* word address */
r_for
c_loop
(paren
id|i
op_assign
l_int|7
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|nsp32_prom_write_bit
c_func
(paren
id|data
comma
(paren
(paren
id|romaddr
op_rshift
id|i
)paren
op_amp
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* ack */
id|nsp32_prom_write_bit
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* start condition */
id|nsp32_prom_start
c_func
(paren
id|data
)paren
suffix:semicolon
multiline_comment|/* device address */
id|nsp32_prom_write_bit
c_func
(paren
id|data
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* 1 */
id|nsp32_prom_write_bit
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* 0 */
id|nsp32_prom_write_bit
c_func
(paren
id|data
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* 1 */
id|nsp32_prom_write_bit
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* 0 */
id|nsp32_prom_write_bit
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* A2: 0 (GND) */
id|nsp32_prom_write_bit
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* A1: 0 (GND) */
id|nsp32_prom_write_bit
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* A0: 0 (GND) */
multiline_comment|/* R/W: R */
id|nsp32_prom_write_bit
c_func
(paren
id|data
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* ack */
id|nsp32_prom_write_bit
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* data... */
id|val
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|7
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|val
op_add_assign
(paren
id|nsp32_prom_read_bit
c_func
(paren
id|data
)paren
op_lshift
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* no ack */
id|nsp32_prom_write_bit
c_func
(paren
id|data
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* stop condition */
id|nsp32_prom_stop
c_func
(paren
id|data
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
DECL|function|nsp32_prom_start
r_static
r_void
id|nsp32_prom_start
(paren
id|nsp32_hw_data
op_star
id|data
)paren
(brace
multiline_comment|/* start condition */
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SCL
comma
l_int|1
)paren
suffix:semicolon
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SDA
comma
l_int|1
)paren
suffix:semicolon
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|ENA
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* output mode */
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SDA
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* keeping SCL=1 and transiting&n;&t;&t;&t;&t;&t; * SDA 1-&gt;0 is start condition */
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SCL
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|nsp32_prom_stop
r_static
r_void
id|nsp32_prom_stop
(paren
id|nsp32_hw_data
op_star
id|data
)paren
(brace
multiline_comment|/* stop condition */
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SCL
comma
l_int|1
)paren
suffix:semicolon
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SDA
comma
l_int|0
)paren
suffix:semicolon
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|ENA
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* output mode */
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SDA
comma
l_int|1
)paren
suffix:semicolon
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SCL
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|nsp32_prom_write_bit
r_static
r_void
id|nsp32_prom_write_bit
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
r_int
id|val
)paren
(brace
multiline_comment|/* write */
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SDA
comma
id|val
)paren
suffix:semicolon
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SCL
comma
l_int|1
)paren
suffix:semicolon
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SCL
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|nsp32_prom_read_bit
r_static
r_int
id|nsp32_prom_read_bit
c_func
(paren
id|nsp32_hw_data
op_star
id|data
)paren
(brace
r_int
id|val
suffix:semicolon
multiline_comment|/* read */
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|ENA
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* input mode */
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SCL
comma
l_int|1
)paren
suffix:semicolon
id|val
op_assign
id|nsp32_prom_get
c_func
(paren
id|data
comma
id|SDA
)paren
suffix:semicolon
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SCL
comma
l_int|0
)paren
suffix:semicolon
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|ENA
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* output mode */
r_return
id|val
suffix:semicolon
)brace
DECL|function|nsp32_prom_set
r_static
r_inline
r_void
id|nsp32_prom_set
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
r_int
id|bit
comma
r_int
id|val
)paren
(brace
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|tmp
op_assign
id|nsp32_index_read1
c_func
(paren
id|base
comma
id|SERIAL_ROM_CTL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_eq
l_int|0
)paren
(brace
id|tmp
op_and_assign
op_complement
id|bit
suffix:semicolon
)brace
r_else
(brace
id|tmp
op_or_assign
id|bit
suffix:semicolon
)brace
id|nsp32_index_write1
c_func
(paren
id|base
comma
id|SERIAL_ROM_CTL
comma
id|tmp
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
DECL|function|nsp32_prom_get
r_static
r_inline
r_int
id|nsp32_prom_get
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
r_int
id|bit
)paren
(brace
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
r_int
id|tmp
comma
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|bit
op_ne
id|SDA
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;return value is not appropriate&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|tmp
op_assign
id|nsp32_index_read1
c_func
(paren
id|base
comma
id|SERIAL_ROM_CTL
)paren
op_amp
id|bit
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n; * Power Management&n; */
macro_line|#ifdef CONFIG_PM
multiline_comment|/* Device suspended */
DECL|function|nsp32_suspend
r_static
r_int
id|nsp32_suspend
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
id|u32
id|state
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|pci_get_drvdata
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;pci-suspend: pdev=0x%p, state=%ld, slot=%s, host=0x%p&quot;
comma
id|pdev
comma
id|state
comma
id|pci_name
c_func
(paren
id|pdev
)paren
comma
id|host
)paren
suffix:semicolon
id|pci_save_state
(paren
id|pdev
comma
id|data-&gt;PciState
)paren
suffix:semicolon
id|pci_disable_device
(paren
id|pdev
)paren
suffix:semicolon
id|pci_set_power_state
c_func
(paren
id|pdev
comma
id|state
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Device woken up */
DECL|function|nsp32_resume
r_static
r_int
id|nsp32_resume
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|pci_get_drvdata
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|reg
suffix:semicolon
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;pci-resume: pdev=0x%p, slot=%s, host=0x%p&quot;
comma
id|pdev
comma
id|pci_name
c_func
(paren
id|pdev
)paren
comma
id|host
)paren
suffix:semicolon
id|pci_set_power_state
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
id|pci_enable_wake
(paren
id|pdev
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|pci_restore_state
(paren
id|pdev
comma
id|data-&gt;PciState
)paren
suffix:semicolon
id|reg
op_assign
id|nsp32_read2
c_func
(paren
id|data-&gt;BaseAddress
comma
id|INDEX_REG
)paren
suffix:semicolon
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;io=0x%x reg=0x%x&quot;
comma
id|data-&gt;BaseAddress
comma
id|reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_eq
l_int|0xffff
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;missing device. abort resume.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|nsp32hw_init
(paren
id|data
)paren
suffix:semicolon
id|nsp32_do_bus_reset
c_func
(paren
id|data
)paren
suffix:semicolon
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;resume success&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Enable wake event */
DECL|function|nsp32_enable_wake
r_static
r_int
id|nsp32_enable_wake
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
id|u32
id|state
comma
r_int
id|enable
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|pci_get_drvdata
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;pci-enable_wake: stub, pdev=0x%p, enable=%d, slot=%s, host=0x%p&quot;
comma
id|pdev
comma
id|enable
comma
id|pci_name
c_func
(paren
id|pdev
)paren
comma
id|host
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/************************************************************************&n; * PCI/Cardbus probe/remove routine&n; */
DECL|function|nsp32_probe
r_static
r_int
id|__devinit
id|nsp32_probe
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_const
r_struct
id|pci_device_id
op_star
id|id
)paren
(brace
r_int
id|ret
suffix:semicolon
id|nsp32_hw_data
op_star
id|data
op_assign
op_amp
id|nsp32_data_base
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_REGISTER
comma
l_string|&quot;enter&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|pci_enable_device
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;failed to enable pci device&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|data-&gt;Pci
op_assign
id|pdev
suffix:semicolon
id|data-&gt;pci_devid
op_assign
id|id
suffix:semicolon
id|data-&gt;IrqNumber
op_assign
id|pdev-&gt;irq
suffix:semicolon
id|data-&gt;BaseAddress
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
id|data-&gt;NumAddress
op_assign
id|pci_resource_len
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
id|data-&gt;MmioAddress
op_assign
(paren
r_int
r_int
)paren
id|ioremap_nocache
c_func
(paren
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|1
)paren
comma
id|pci_resource_len
(paren
id|pdev
comma
l_int|1
)paren
)paren
suffix:semicolon
id|data-&gt;MmioLength
op_assign
id|pci_resource_len
(paren
id|pdev
comma
l_int|1
)paren
suffix:semicolon
id|pci_set_master
c_func
(paren
id|pdev
)paren
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,5,73))
id|ret
op_assign
id|nsp32_detect
c_func
(paren
id|pdev
)paren
suffix:semicolon
macro_line|#else
id|ret
op_assign
id|scsi_register_host
c_func
(paren
op_amp
id|nsp32_template
)paren
suffix:semicolon
macro_line|#endif
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;irq: %i mmio: 0x%lx+0x%lx slot: %s model: %s&quot;
comma
id|pdev-&gt;irq
comma
id|data-&gt;MmioAddress
comma
id|data-&gt;MmioLength
comma
id|pci_name
c_func
(paren
id|pdev
)paren
comma
id|nsp32_model
(braket
id|id-&gt;driver_data
)braket
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_REGISTER
comma
l_string|&quot;exit %d&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|nsp32_remove
r_static
r_void
id|__devexit
id|nsp32_remove
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
macro_line|#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,5,73))
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|pci_get_drvdata
c_func
(paren
id|pdev
)paren
suffix:semicolon
macro_line|#endif
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_REGISTER
comma
l_string|&quot;enter&quot;
)paren
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,5,73))
id|scsi_remove_host
c_func
(paren
id|host
)paren
suffix:semicolon
id|nsp32_release
c_func
(paren
id|host
)paren
suffix:semicolon
id|scsi_host_put
c_func
(paren
id|host
)paren
suffix:semicolon
macro_line|#else
id|scsi_unregister_host
c_func
(paren
op_amp
id|nsp32_template
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|variable|nsp32_driver
r_static
r_struct
id|pci_driver
id|nsp32_driver
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;nsp32&quot;
comma
dot
id|id_table
op_assign
id|nsp32_pci_table
comma
dot
id|probe
op_assign
id|nsp32_probe
comma
dot
id|remove
op_assign
id|__devexit_p
c_func
(paren
id|nsp32_remove
)paren
comma
macro_line|#ifdef CONFIG_PM
dot
id|suspend
op_assign
id|nsp32_suspend
comma
dot
id|resume
op_assign
id|nsp32_resume
comma
dot
id|enable_wake
op_assign
id|nsp32_enable_wake
comma
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/*********************************************************************&n; * Moule entry point&n; */
DECL|function|init_nsp32
r_static
r_int
id|__init
id|init_nsp32
c_func
(paren
r_void
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;loading...&quot;
)paren
suffix:semicolon
r_return
id|pci_module_init
c_func
(paren
op_amp
id|nsp32_driver
)paren
suffix:semicolon
)brace
DECL|function|exit_nsp32
r_static
r_void
id|__exit
id|exit_nsp32
c_func
(paren
r_void
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;unloading...&quot;
)paren
suffix:semicolon
id|pci_unregister_driver
c_func
(paren
op_amp
id|nsp32_driver
)paren
suffix:semicolon
)brace
DECL|variable|init_nsp32
id|module_init
c_func
(paren
id|init_nsp32
)paren
suffix:semicolon
DECL|variable|exit_nsp32
id|module_exit
c_func
(paren
id|exit_nsp32
)paren
suffix:semicolon
multiline_comment|/* end */
eof
