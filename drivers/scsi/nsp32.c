multiline_comment|/*&n; * NinjaSCSI-32Bi Cardbus, NinjaSCSI-32UDE PCI/CardBus SCSI driver&n; * Copyright (C) 2001, 2002&n; *      YOKOTA Hiroshi &lt;yokota@netlab.is.tsukuba.ac.jp&gt;&n; *      GOTO Masanori &lt;gotom@debian.or.jp&gt;&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; */
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &lt;scsi/scsi_ioctl.h&gt;
macro_line|#include &lt;scsi/scsi.h&gt;
macro_line|#include &quot;nsp32.h&quot;
DECL|variable|trans_mode
r_static
r_int
id|trans_mode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* default: BIOS */
DECL|variable|auto_param
r_static
r_int
id|auto_param
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* default: ON */
id|MODULE_PARM
c_func
(paren
id|trans_mode
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|auto_param
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|trans_mode
comma
l_string|&quot;transfer mode (0: BIOS 1: Async 2: Ultra20M&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|auto_param
comma
l_string|&quot;AutoParameter mode (0: ON 1: OFF)&quot;
)paren
suffix:semicolon
DECL|macro|ASYNC_MODE
mdefine_line|#define ASYNC_MODE    1
DECL|macro|ULTRA20M_MODE
mdefine_line|#define ULTRA20M_MODE 2
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;YOKOTA Hiroshi &lt;yokota@netlab.is.tsukuba.ac.jp&gt;, GOTO Masanori &lt;gotom@debian.or.jp&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Workbit NinjaSCSI-32Bi/UDE PCI/CardBus SCSI host bus adapter module&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|nsp32_release_version
r_static
r_const
r_char
op_star
id|nsp32_release_version
op_assign
l_string|&quot;1.0&quot;
suffix:semicolon
multiline_comment|/*&n; * structure for DMA/Scatter Gather list&n; */
DECL|macro|AUTOPARAM_SIZE
mdefine_line|#define AUTOPARAM_SIZE&t;&t;(sizeof(int)*0x15)&t;/* 4x15H = 0x60 */
DECL|macro|NSP_SG_SIZE
mdefine_line|#define NSP_SG_SIZE&t;&t;SG_ALL
DECL|macro|NSP32_SG_END_SGT
mdefine_line|#define NSP32_SG_END_SGT&t;0x80000000&t;&t;/* Last SGT marker */
DECL|macro|NSP32_SG_CNT_MASK
mdefine_line|#define NSP32_SG_CNT_MASK&t;0x1FFFF
DECL|struct|nsp32_sgtable
r_struct
id|nsp32_sgtable
(brace
DECL|member|addr
r_int
r_int
id|addr
suffix:semicolon
multiline_comment|/* transfer address */
DECL|member|len
r_int
r_int
id|len
suffix:semicolon
multiline_comment|/* transfer length.&n;&t;&t;&t;&t;&t;&t;   Bit (24-32) is for SGT_END */
)brace
suffix:semicolon
DECL|struct|nsp32_sglun
r_struct
id|nsp32_sglun
(brace
DECL|member|sgt
r_struct
id|nsp32_sgtable
id|sgt
(braket
id|NSP_SG_SIZE
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* SG table */
)brace
suffix:semicolon
multiline_comment|/*&n; * host data structure&n; */
multiline_comment|/* message in/out buffer */
DECL|macro|MSGOUTBUF_MAX
mdefine_line|#define MSGOUTBUF_MAX&t;13  /* 13 is ok ? */
DECL|macro|MSGINBUF_MAX
mdefine_line|#define MSGINBUF_MAX&t;13
multiline_comment|/* flag for trans_method */
DECL|macro|NSP32_TRANSFER_BUSMASTER
mdefine_line|#define NSP32_TRANSFER_BUSMASTER&t;BIT(0)
DECL|macro|NSP32_TRANSFER_MMIO
mdefine_line|#define NSP32_TRANSFER_MMIO&t;&t;BIT(1)&t;/* Not supported yet */
DECL|macro|NSP32_TRANSFER_PIO
mdefine_line|#define NSP32_TRANSFER_PIO&t;&t;BIT(2)&t;/* Not supported yet */
multiline_comment|/*&n; * SCSI TARGET/LUN definition&n; */
DECL|macro|NSP32_HOST_SCSIID
mdefine_line|#define NSP32_HOST_SCSIID&t;7&t;/* SCSI initiator is everytime defined as 7 */
DECL|macro|MAX_TARGET
mdefine_line|#define MAX_TARGET&t;&t;8
DECL|macro|MAX_LUN
mdefine_line|#define MAX_LUN&t;&t;&t;8&t;/* XXX: In SPI3, max number of LUN is 64. */
multiline_comment|/*&n; * structure for synchronous transfer negotiation data&n; */
DECL|macro|SYNC_NOT_YET
mdefine_line|#define SYNC_NOT_YET&t;0
DECL|macro|SYNC_OK
mdefine_line|#define SYNC_OK&t;&t;1
DECL|macro|SYNC_NG
mdefine_line|#define SYNC_NG&t;&t;2
DECL|struct|nsp32_sync_table
r_struct
id|nsp32_sync_table
(brace
DECL|member|period_num
r_int
r_char
id|period_num
suffix:semicolon
multiline_comment|/* period number */
DECL|member|ackwidth
r_int
r_char
id|ackwidth
suffix:semicolon
multiline_comment|/* ack width designated by period */
DECL|member|start_period
r_int
r_char
id|start_period
suffix:semicolon
multiline_comment|/* search range - start period */
DECL|member|end_period
r_int
r_char
id|end_period
suffix:semicolon
multiline_comment|/* search range - end period */
)brace
suffix:semicolon
multiline_comment|/*&n; * structure for target device static data&n; */
multiline_comment|/* flag for nsp32_target.sync_flag */
DECL|macro|SDTR_INITIATOR
mdefine_line|#define SDTR_INITIATOR&t;&t;BIT(0)&t;/* sending SDTR from initiator */
DECL|macro|SDTR_TARGET
mdefine_line|#define SDTR_TARGET&t;&t;BIT(1)&t;/* sending SDTR from target */
DECL|macro|SDTR_DONE
mdefine_line|#define SDTR_DONE&t;&t;BIT(2)&t;/* exchanging SDTR has been processed */
multiline_comment|/* syncronous period value for nsp32_target.config_max */
DECL|macro|FAST5M
mdefine_line|#define FAST5M&t;&t;&t;0x32
DECL|macro|FAST10M
mdefine_line|#define FAST10M&t;&t;&t;0x19
DECL|macro|ULTRA20M
mdefine_line|#define ULTRA20M&t;&t;0x0c
multiline_comment|/* flag for nsp32_target.{sync_offset}, period */
DECL|macro|ASYNC_OFFSET
mdefine_line|#define ASYNC_OFFSET&t;&t;0&t;/* asynchronous transfer */
DECL|macro|SYNC_OFFSET
mdefine_line|#define SYNC_OFFSET&t;&t;0xf&t;/* synchronous transfer max offset */
multiline_comment|/* syncreg:&n;      07 06 05 04 03 02 01 00&n;      ---PERIOD-- ---OFFSET--   */
DECL|macro|TO_SYNCREG
mdefine_line|#define TO_SYNCREG(period, offset)&t;(period &lt;&lt; 4 | offset)
DECL|struct|nsp32_target
r_struct
id|nsp32_target
(brace
DECL|member|syncreg
r_int
r_char
id|syncreg
suffix:semicolon
multiline_comment|/* value for SYNCREG  */
DECL|member|ackwidth
r_int
r_char
id|ackwidth
suffix:semicolon
multiline_comment|/* value for ACKWIDTH */
DECL|member|offset
r_int
r_char
id|offset
suffix:semicolon
multiline_comment|/* sync offset (0-15) */
DECL|member|sync_flag
r_int
id|sync_flag
suffix:semicolon
multiline_comment|/* SDTR_*, 0 */
DECL|member|limit_entry
r_int
id|limit_entry
suffix:semicolon
multiline_comment|/* max speed limit entry designated&n;&t;&t;&t;&t;&t;   by EEPROM configuration */
)brace
suffix:semicolon
DECL|struct|_nsp32_hw_data
r_typedef
r_struct
id|_nsp32_hw_data
(brace
DECL|member|IrqNumber
r_int
id|IrqNumber
suffix:semicolon
DECL|member|BaseAddress
r_int
id|BaseAddress
suffix:semicolon
DECL|member|NumAddress
r_int
id|NumAddress
suffix:semicolon
DECL|macro|NSP32_MMIO_OFFSET
mdefine_line|#define NSP32_MMIO_OFFSET 0x0800
DECL|member|MmioAddress
r_int
r_int
id|MmioAddress
suffix:semicolon
DECL|member|length
r_int
r_int
id|length
suffix:semicolon
DECL|member|CurrentSC
id|Scsi_Cmnd
op_star
id|CurrentSC
suffix:semicolon
DECL|member|Pci
r_struct
id|pci_dev
op_star
id|Pci
suffix:semicolon
DECL|member|pci_devid
r_const
r_struct
id|pci_device_id
op_star
id|pci_devid
suffix:semicolon
DECL|member|Host
r_struct
id|Scsi_Host
op_star
id|Host
suffix:semicolon
DECL|member|Lock
id|spinlock_t
id|Lock
suffix:semicolon
DECL|member|info_str
r_char
id|info_str
(braket
l_int|100
)braket
suffix:semicolon
multiline_comment|/* allocated memory region */
DECL|member|lunt_list
r_struct
id|nsp32_lunt
op_star
id|lunt_list
suffix:semicolon
multiline_comment|/* kmalloc region for lunt */
DECL|member|sg_list
r_struct
id|nsp32_sglun
op_star
id|sg_list
suffix:semicolon
multiline_comment|/* sglist virtual address */
DECL|member|sgaddr
id|dma_addr_t
id|sgaddr
suffix:semicolon
multiline_comment|/* physical address of hw_sg_table */
DECL|member|autoparam
r_int
r_char
op_star
id|autoparam
suffix:semicolon
multiline_comment|/* auto parameter transfer region */
DECL|member|apaddr
id|dma_addr_t
id|apaddr
suffix:semicolon
multiline_comment|/* physical address of autoparam */
DECL|member|cur_entry
r_int
id|cur_entry
suffix:semicolon
multiline_comment|/* current sgt entry */
multiline_comment|/* target/LUN */
DECL|member|curlunt
r_struct
id|nsp32_lunt
op_star
id|curlunt
suffix:semicolon
multiline_comment|/* Current connected LUN table */
DECL|member|lunt
r_struct
id|nsp32_lunt
op_star
id|lunt
(braket
id|MAX_TARGET
)braket
(braket
id|MAX_LUN
)braket
suffix:semicolon
multiline_comment|/* All LUN table */
DECL|member|curtarget
r_struct
id|nsp32_target
op_star
id|curtarget
suffix:semicolon
multiline_comment|/* Current connected SCSI ID */
DECL|member|target
r_struct
id|nsp32_target
id|target
(braket
id|MAX_TARGET
)braket
suffix:semicolon
multiline_comment|/* SCSI ID */
DECL|member|pid
r_int
id|pid
suffix:semicolon
multiline_comment|/* Current connected target ID */
DECL|member|plun
r_int
id|plun
suffix:semicolon
multiline_comment|/* Current connected target LUN */
multiline_comment|/* behavior setting parameters */
DECL|member|trans_method
r_int
id|trans_method
suffix:semicolon
multiline_comment|/* transfer method flag */
DECL|member|resettime
r_int
id|resettime
suffix:semicolon
multiline_comment|/* Reset time */
DECL|member|clock
r_int
id|clock
suffix:semicolon
multiline_comment|/* clock dividing flag */
DECL|member|synct
r_struct
id|nsp32_sync_table
op_star
id|synct
suffix:semicolon
multiline_comment|/* sync_table determined by clock */
DECL|member|syncnum
r_int
id|syncnum
suffix:semicolon
multiline_comment|/* the max number of synct element */
multiline_comment|/* message buffer */
DECL|member|msgoutbuf
r_int
r_char
id|msgoutbuf
(braket
id|MSGOUTBUF_MAX
)braket
suffix:semicolon
multiline_comment|/* msgout buffer */
DECL|member|msgoutlen
r_char
id|msgoutlen
suffix:semicolon
multiline_comment|/* msgoutbuf length */
DECL|member|msginbuf
r_int
r_char
id|msginbuf
(braket
id|MSGINBUF_MAX
)braket
suffix:semicolon
multiline_comment|/* megin buffer */
DECL|member|msginlen
r_char
id|msginlen
suffix:semicolon
multiline_comment|/* msginbuf length */
DECL|typedef|nsp32_hw_data
)brace
id|nsp32_hw_data
suffix:semicolon
DECL|variable|nsp32_data_base
r_static
id|nsp32_hw_data
id|nsp32_data_base
suffix:semicolon
multiline_comment|/* probe &lt;-&gt; detect glue */
multiline_comment|/*&n; * TIME definition&n; */
DECL|macro|RESET_HOLD_TIME
mdefine_line|#define RESET_HOLD_TIME&t;&t;10000&t;/* reset time in us (SCSI-2 says the&n;&t;&t;&t;&t;&t;   minimum is 25us) */
DECL|macro|SEL_TIMEOUT_TIME
mdefine_line|#define SEL_TIMEOUT_TIME&t;10000&t;/* 250ms defined in SCSI specification&n;&t;&t;&t;&t;&t;   (25.6us/1unit) */
DECL|macro|ARBIT_TIMEOUT_TIME
mdefine_line|#define ARBIT_TIMEOUT_TIME&t;100&t;/* 100us */
DECL|macro|REQSACK_TIMEOUT_TIME
mdefine_line|#define REQSACK_TIMEOUT_TIME&t;10000&t;/* max wait time for REQ/SACK assertion&n;&t;&t;&t;&t;&t;   or negation, 10000us == 10ms */
multiline_comment|/*&n; * structure for connected LUN dynamic data&n; *&n; * Note: Currently tagged queuing is disabled, each nsp32_lunt holds&n; *       one SCSI command and one state.&n; */
DECL|macro|DISCPRIV_OK
mdefine_line|#define DISCPRIV_OK&t;&t;BIT(0)&t;&t;/* DISCPRIV Enable mode */
DECL|macro|MSGIN03
mdefine_line|#define MSGIN03&t;&t;&t;BIT(1)&t;&t;/* Auto Msg In 03 Flag */
DECL|struct|nsp32_lunt
r_struct
id|nsp32_lunt
(brace
DECL|member|SCpnt
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
multiline_comment|/* Current Handling Scsi_Cmnd */
DECL|member|save_datp
r_int
r_int
id|save_datp
suffix:semicolon
multiline_comment|/* Save Data Pointer - saved position from initial address */
DECL|member|msgin03
r_int
id|msgin03
suffix:semicolon
multiline_comment|/* auto msg in 03 flag */
DECL|member|sg_num
r_int
r_int
id|sg_num
suffix:semicolon
multiline_comment|/* Total number of SG entries */
DECL|member|cur_entry
r_int
id|cur_entry
suffix:semicolon
multiline_comment|/* Current SG entry number */
DECL|member|sglun
r_struct
id|nsp32_sglun
op_star
id|sglun
suffix:semicolon
multiline_comment|/* sg table per lun */
DECL|member|sglun_paddr
r_int
id|sglun_paddr
suffix:semicolon
multiline_comment|/* sglun physical address */
)brace
suffix:semicolon
multiline_comment|/*&n; * Period/AckWidth speed conversion table&n; *&n; * Note: This period/ackwidth speed table must be in descending order.&n; */
DECL|variable|nsp32_sync_table_40M
r_static
r_struct
id|nsp32_sync_table
id|nsp32_sync_table_40M
(braket
)braket
op_assign
(brace
multiline_comment|/* {PNo, AW,  SP,   EP}  Speed(MB/s) Period AckWidth */
(brace
l_int|0x1
comma
l_int|0
comma
l_int|0x0c
comma
l_int|0x0c
)brace
comma
multiline_comment|/*  20.0 :  50ns,  25ns */
(brace
l_int|0x2
comma
l_int|0
comma
l_int|0x0d
comma
l_int|0x18
)brace
comma
multiline_comment|/*  13.3 :  75ns,  25ns */
(brace
l_int|0x3
comma
l_int|1
comma
l_int|0x19
comma
l_int|0x19
)brace
comma
multiline_comment|/*  10.0 : 100ns,  50ns */
(brace
l_int|0x4
comma
l_int|1
comma
l_int|0x1a
comma
l_int|0x1f
)brace
comma
multiline_comment|/*   8.0 : 125ns,  50ns */
(brace
l_int|0x5
comma
l_int|2
comma
l_int|0x20
comma
l_int|0x25
)brace
comma
multiline_comment|/*   6.7 : 150ns,  75ns */
(brace
l_int|0x6
comma
l_int|2
comma
l_int|0x26
comma
l_int|0x31
)brace
comma
multiline_comment|/*   5.7 : 175ns,  75ns */
(brace
l_int|0x7
comma
l_int|3
comma
l_int|0x32
comma
l_int|0x32
)brace
comma
multiline_comment|/*   5.0 : 200ns, 100ns */
(brace
l_int|0x8
comma
l_int|3
comma
l_int|0x33
comma
l_int|0x38
)brace
comma
multiline_comment|/*   4.4 : 225ns, 100ns */
(brace
l_int|0x9
comma
l_int|3
comma
l_int|0x39
comma
l_int|0x3e
)brace
comma
multiline_comment|/*   4.0 : 250ns, 100ns */
)brace
suffix:semicolon
DECL|variable|nsp32_table_40M_num
r_static
r_const
r_int
id|nsp32_table_40M_num
op_assign
r_sizeof
(paren
id|nsp32_sync_table_40M
)paren
op_div
r_sizeof
(paren
r_struct
id|nsp32_sync_table
)paren
suffix:semicolon
DECL|variable|nsp32_sync_table_20M
r_static
r_struct
id|nsp32_sync_table
id|nsp32_sync_table_20M
(braket
)braket
op_assign
(brace
(brace
l_int|0x1
comma
l_int|0
comma
l_int|0x19
comma
l_int|0x19
)brace
comma
multiline_comment|/* 10.0 : 100ns,  50ns */
(brace
l_int|0x2
comma
l_int|0
comma
l_int|0x1a
comma
l_int|0x25
)brace
comma
multiline_comment|/*  6.7 : 150ns,  50ns */
(brace
l_int|0x3
comma
l_int|1
comma
l_int|0x26
comma
l_int|0x32
)brace
comma
multiline_comment|/*  5.0 : 200ns, 100ns */
(brace
l_int|0x4
comma
l_int|1
comma
l_int|0x33
comma
l_int|0x3e
)brace
comma
multiline_comment|/*  4.0 : 250ns, 100ns */
(brace
l_int|0x5
comma
l_int|2
comma
l_int|0x3f
comma
l_int|0x4b
)brace
comma
multiline_comment|/*  3.3 : 300ns, 150ns */
(brace
l_int|0x6
comma
l_int|2
comma
l_int|0x4c
comma
l_int|0x57
)brace
comma
multiline_comment|/*  2.8 : 350ns, 150ns */
(brace
l_int|0x7
comma
l_int|3
comma
l_int|0x58
comma
l_int|0x64
)brace
comma
multiline_comment|/*  2.5 : 400ns, 200ns */
(brace
l_int|0x8
comma
l_int|3
comma
l_int|0x65
comma
l_int|0x70
)brace
comma
multiline_comment|/*  2.2 : 450ns, 200ns */
(brace
l_int|0x9
comma
l_int|3
comma
l_int|0x71
comma
l_int|0x7d
)brace
comma
multiline_comment|/*  2.0 : 500ns, 200ns */
)brace
suffix:semicolon
DECL|variable|nsp32_table_20M_num
r_static
r_const
r_int
id|nsp32_table_20M_num
op_assign
r_sizeof
(paren
id|nsp32_sync_table_20M
)paren
op_div
r_sizeof
(paren
r_struct
id|nsp32_sync_table
)paren
suffix:semicolon
DECL|variable|nsp32_sync_table_pci
r_static
r_struct
id|nsp32_sync_table
id|nsp32_sync_table_pci
(braket
)braket
op_assign
(brace
(brace
l_int|0x1
comma
l_int|0
comma
l_int|0x0c
comma
l_int|0x0f
)brace
comma
multiline_comment|/* 16.6 :  60ns,  30ns */
(brace
l_int|0x2
comma
l_int|0
comma
l_int|0x10
comma
l_int|0x16
)brace
comma
multiline_comment|/* 11.1 :  90ns,  30ns */
(brace
l_int|0x3
comma
l_int|1
comma
l_int|0x17
comma
l_int|0x1e
)brace
comma
multiline_comment|/*  8.3 : 120ns,  60ns */
(brace
l_int|0x4
comma
l_int|1
comma
l_int|0x1f
comma
l_int|0x25
)brace
comma
multiline_comment|/*  6.7 : 150ns,  60ns */
(brace
l_int|0x5
comma
l_int|2
comma
l_int|0x26
comma
l_int|0x2d
)brace
comma
multiline_comment|/*  5.6 : 180ns,  90ns */
(brace
l_int|0x6
comma
l_int|2
comma
l_int|0x2e
comma
l_int|0x34
)brace
comma
multiline_comment|/*  4.8 : 210ns,  90ns */
(brace
l_int|0x7
comma
l_int|3
comma
l_int|0x35
comma
l_int|0x3c
)brace
comma
multiline_comment|/*  4.2 : 240ns, 120ns */
(brace
l_int|0x8
comma
l_int|3
comma
l_int|0x3d
comma
l_int|0x43
)brace
comma
multiline_comment|/*  3.7 : 270ns, 120ns */
(brace
l_int|0x9
comma
l_int|3
comma
l_int|0x44
comma
l_int|0x4b
)brace
comma
multiline_comment|/*  3.3 : 300ns, 120ns */
)brace
suffix:semicolon
DECL|variable|nsp32_table_pci_num
r_static
r_const
r_int
id|nsp32_table_pci_num
op_assign
r_sizeof
(paren
id|nsp32_sync_table_pci
)paren
op_div
r_sizeof
(paren
r_struct
id|nsp32_sync_table
)paren
suffix:semicolon
multiline_comment|/*&n; * function declaration&n; */
r_static
r_int
id|nsp32_queuecommand
c_func
(paren
id|Scsi_Cmnd
op_star
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
suffix:semicolon
r_static
r_const
r_char
op_star
id|nsp32_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
)paren
suffix:semicolon
r_static
r_int
id|nsp32_eh_abort
c_func
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
r_static
r_int
id|nsp32_eh_bus_reset
c_func
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
r_static
r_int
id|nsp32_eh_host_reset
c_func
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
r_static
r_int
id|nsp32_proc_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
comma
r_char
op_star
comma
r_char
op_star
op_star
comma
id|off_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|__devinit
id|nsp32_probe
c_func
(paren
r_struct
id|pci_dev
op_star
comma
r_const
r_struct
id|pci_device_id
op_star
)paren
suffix:semicolon
r_static
r_void
id|__devexit
id|nsp32_remove
c_func
(paren
r_struct
id|pci_dev
op_star
)paren
suffix:semicolon
r_static
r_int
id|__init
id|init_nsp32
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|__exit
id|exit_nsp32
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|nsp32_message
c_func
(paren
r_const
r_char
op_star
comma
r_int
comma
r_char
op_star
comma
r_char
op_star
comma
dot
dot
dot
)paren
suffix:semicolon
r_static
r_void
id|nsp32_dmessage
c_func
(paren
r_const
r_char
op_star
comma
r_int
comma
r_int
comma
r_char
op_star
comma
dot
dot
dot
)paren
suffix:semicolon
r_static
r_void
id|nsp32_build_identify
c_func
(paren
id|nsp32_hw_data
op_star
comma
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
r_static
r_void
id|nsp32_build_sdtr
c_func
(paren
id|nsp32_hw_data
op_star
comma
r_int
r_char
comma
r_int
r_char
)paren
suffix:semicolon
r_static
r_void
id|nsp32_build_nop
c_func
(paren
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
r_static
r_void
id|nsp32_build_reject
c_func
(paren
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
r_static
r_int
id|nsp32hw_start_selection
c_func
(paren
id|Scsi_Cmnd
op_star
comma
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
r_static
r_int
id|nsp32_selection_autoscsi
c_func
(paren
id|Scsi_Cmnd
op_star
comma
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
r_static
r_int
id|nsp32_reselection
c_func
(paren
id|nsp32_hw_data
op_star
comma
r_int
r_char
)paren
suffix:semicolon
r_static
r_int
id|nsp32hw_setup_sg_table
c_func
(paren
id|Scsi_Cmnd
op_star
comma
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
r_static
r_int
id|nsp32hw_init
c_func
(paren
r_struct
id|Scsi_Host
op_star
)paren
suffix:semicolon
r_static
r_void
id|nsp32_scsi_done
c_func
(paren
id|nsp32_hw_data
op_star
comma
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
r_static
r_int
id|nsp32_busfree_occur
c_func
(paren
id|nsp32_hw_data
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|nsp32_adjust_busfree
c_func
(paren
id|nsp32_hw_data
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|nsp32_msgout_occur
c_func
(paren
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
r_static
r_void
id|nsp32_restart_autoscsi
c_func
(paren
id|nsp32_hw_data
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|nsp32_msgin_occur
c_func
(paren
id|nsp32_hw_data
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|nsp32_analyze_sdtr
c_func
(paren
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
r_static
r_int
id|nsp32_search_period_entry
c_func
(paren
id|nsp32_hw_data
op_star
comma
r_struct
id|nsp32_target
op_star
comma
r_int
r_char
)paren
suffix:semicolon
r_static
r_void
id|nsp32_set_async
c_func
(paren
id|nsp32_hw_data
op_star
comma
r_struct
id|nsp32_target
op_star
)paren
suffix:semicolon
r_static
r_void
id|nsp32_set_max_sync
c_func
(paren
id|nsp32_hw_data
op_star
comma
r_struct
id|nsp32_target
op_star
comma
r_int
r_char
op_star
comma
r_int
r_char
op_star
)paren
suffix:semicolon
r_static
r_void
id|nsp32_set_sync_entry
c_func
(paren
id|nsp32_hw_data
op_star
comma
r_struct
id|nsp32_target
op_star
comma
r_int
comma
r_int
r_char
)paren
suffix:semicolon
r_static
r_void
id|nsp32_wait_req
c_func
(paren
id|nsp32_hw_data
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|nsp32_wait_sack
c_func
(paren
id|nsp32_hw_data
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|nsp32_sack_assert
c_func
(paren
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
r_static
r_void
id|nsp32_sack_negate
c_func
(paren
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
r_static
r_void
id|nsp32_do_bus_reset
c_func
(paren
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
r_static
r_int
id|nsp32_getprom_param
c_func
(paren
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
r_static
r_int
id|nsp32_getprom_new
c_func
(paren
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
r_static
r_int
id|nsp32_getprom_standard
c_func
(paren
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
r_static
r_int
id|nsp32_prom_read
c_func
(paren
id|nsp32_hw_data
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|nsp32_prom_start
c_func
(paren
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
r_static
r_void
id|nsp32_prom_stop
c_func
(paren
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
r_static
r_void
id|nsp32_prom_write
c_func
(paren
id|nsp32_hw_data
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|nsp32_prom_fetch
c_func
(paren
id|nsp32_hw_data
op_star
)paren
suffix:semicolon
r_static
r_inline
r_void
id|nsp32_prom_set
c_func
(paren
id|nsp32_hw_data
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_static
r_inline
r_int
id|nsp32_prom_get
c_func
(paren
id|nsp32_hw_data
op_star
comma
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * max_sectors is currently limited up to 128.&n; */
DECL|variable|nsp32_template
r_static
id|Scsi_Host_Template
id|nsp32_template
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;Workbit NinjaSCSI-32Bi/UDE&quot;
comma
dot
id|proc_name
op_assign
l_string|&quot;nsp32&quot;
comma
dot
id|proc_info
op_assign
id|nsp32_proc_info
comma
dot
id|info
op_assign
id|nsp32_info
comma
dot
id|queuecommand
op_assign
id|nsp32_queuecommand
comma
dot
id|can_queue
op_assign
l_int|1
comma
dot
id|sg_tablesize
op_assign
id|NSP_SG_SIZE
comma
dot
id|max_sectors
op_assign
l_int|128
comma
dot
id|cmd_per_lun
op_assign
l_int|1
comma
dot
id|this_id
op_assign
l_int|7
comma
dot
id|use_clustering
op_assign
id|DISABLE_CLUSTERING
comma
dot
id|eh_abort_handler
op_assign
id|nsp32_eh_abort
comma
dot
id|eh_device_reset_handler
op_assign
l_int|NULL
comma
dot
id|eh_bus_reset_handler
op_assign
id|nsp32_eh_bus_reset
comma
dot
id|eh_host_reset_handler
op_assign
id|nsp32_eh_host_reset
comma
)brace
suffix:semicolon
macro_line|#include &quot;nsp32_io.h&quot;
multiline_comment|/*&n; * debug, error print&n; */
DECL|macro|nsp32_msg
mdefine_line|#define nsp32_msg(type, args...) &bslash;&n;&t;nsp32_message(__FUNCTION__, __LINE__, (type), ## args)
DECL|macro|nsp32_dbg
mdefine_line|#define nsp32_dbg(mask, args...) &bslash;&n;&t;nsp32_dmessage(__FUNCTION__, __LINE__, (mask), ## args)
macro_line|#ifndef NSP32_DEBUG
DECL|macro|NSP32_DEBUG_MASK
macro_line|# define NSP32_DEBUG_MASK&t;&t;0x000000
macro_line|#else
DECL|macro|NSP32_DEBUG_MASK
macro_line|# define NSP32_DEBUG_MASK&t;&t;0xffffff
macro_line|#endif
DECL|macro|NSP32_DEBUG_QUEUECOMMAND
mdefine_line|#define NSP32_DEBUG_QUEUECOMMAND&t;0x000001
DECL|macro|NSP32_DEBUG_REGISTER
mdefine_line|#define NSP32_DEBUG_REGISTER&t;&t;0x000002
DECL|macro|NSP32_DEBUG_AUTOSCSI
mdefine_line|#define NSP32_DEBUG_AUTOSCSI&t;&t;0x000004
DECL|macro|NSP32_DEBUG_INTR
mdefine_line|#define NSP32_DEBUG_INTR&t;&t;0x000008
DECL|macro|NSP32_DEBUG_SGLIST
mdefine_line|#define NSP32_DEBUG_SGLIST&t;&t;0x000010
DECL|macro|NSP32_DEBUG_BUSFREE
mdefine_line|#define NSP32_DEBUG_BUSFREE&t;&t;0x000020
DECL|macro|NSP32_DEBUG_CDB_CONTENTS
mdefine_line|#define NSP32_DEBUG_CDB_CONTENTS&t;0x000040
DECL|macro|NSP32_DEBUG_RESELECTION
mdefine_line|#define NSP32_DEBUG_RESELECTION&t;&t;0x000080
DECL|macro|NSP32_DEBUG_MSGINOCCUR
mdefine_line|#define NSP32_DEBUG_MSGINOCCUR&t;&t;0x000100
DECL|macro|NSP32_DEBUG_EEPROM
mdefine_line|#define NSP32_DEBUG_EEPROM&t;&t;0x000200
DECL|macro|NSP32_DEBUG_MSGOUTOCCUR
mdefine_line|#define NSP32_DEBUG_MSGOUTOCCUR&t;&t;0x000400
DECL|macro|NSP32_DEBUG_BUSRESET
mdefine_line|#define NSP32_DEBUG_BUSRESET&t;&t;0x000800
DECL|macro|NSP32_DEBUG_RESTART
mdefine_line|#define NSP32_DEBUG_RESTART&t;&t;0x001000
DECL|macro|NSP32_DEBUG_SYNC
mdefine_line|#define NSP32_DEBUG_SYNC&t;&t;0x002000
DECL|macro|NSP32_DEBUG_WAIT
mdefine_line|#define NSP32_DEBUG_WAIT&t;&t;0x004000
DECL|macro|NSP32_DEBUG_TARGETFLAG
mdefine_line|#define NSP32_DEBUG_TARGETFLAG&t;&t;0x008000
DECL|macro|NSP32_DEBUG_PROC
mdefine_line|#define NSP32_DEBUG_PROC&t;&t;0x010000
DECL|macro|NSP32_DEBUG_INIT
mdefine_line|#define NSP32_DEBUG_INIT&t;&t;0x020000
DECL|macro|NSP32_SPECIAL_PRINT_REGISTER
mdefine_line|#define NSP32_SPECIAL_PRINT_REGISTER&t;0x100000
DECL|macro|NSP32_DEBUG_BUF_LEN
mdefine_line|#define NSP32_DEBUG_BUF_LEN&t;&t;100
DECL|function|nsp32_message
r_static
r_void
id|nsp32_message
c_func
(paren
r_const
r_char
op_star
id|func
comma
r_int
id|line
comma
r_char
op_star
id|type
comma
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_char
id|buf
(braket
id|NSP32_DEBUG_BUF_LEN
)braket
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|vsprintf
c_func
(paren
id|buf
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
macro_line|#ifndef NSP32_DEBUG
id|printk
c_func
(paren
l_string|&quot;%snsp32: %s&bslash;n&quot;
comma
id|type
comma
id|buf
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;%snsp32: %s (%d): %s&bslash;n&quot;
comma
id|type
comma
id|func
comma
id|line
comma
id|buf
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|nsp32_dmessage
r_static
r_void
id|nsp32_dmessage
c_func
(paren
r_const
r_char
op_star
id|func
comma
r_int
id|line
comma
r_int
id|mask
comma
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_char
id|buf
(braket
id|NSP32_DEBUG_BUF_LEN
)braket
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|vsprintf
c_func
(paren
id|buf
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
id|NSP32_DEBUG_MASK
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Ninja: %d %s (%d): %s&bslash;n&quot;
comma
id|mask
comma
id|func
comma
id|line
comma
id|buf
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef NSP32_DEBUG
macro_line|# include &quot;nsp32_debug.c&quot;
macro_line|#else
DECL|macro|show_command
macro_line|# define show_command(arg)   /* */
DECL|macro|show_busphase
macro_line|# define show_busphase(arg)  /* */
DECL|macro|show_autophase
macro_line|# define show_autophase(arg) /* */
macro_line|#endif
macro_line|#ifdef NSP32_DEBUG
DECL|variable|pc_debug
r_static
r_int
id|pc_debug
op_assign
id|NSP32_DEBUG
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|pc_debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|macro|DEBUG
mdefine_line|#define DEBUG(n, args...) if (pc_debug&gt;(n)) printk(/*KERN_DEBUG*/ args)
macro_line|#else
DECL|macro|DEBUG
mdefine_line|#define DEBUG(n, args...)
macro_line|#endif
multiline_comment|/*&n; * IDENTIFY Message&n; */
DECL|function|nsp32_build_identify
r_static
r_void
id|nsp32_build_identify
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|pos
op_assign
id|data-&gt;msgoutlen
suffix:semicolon
id|data-&gt;msgoutbuf
(braket
id|pos
op_increment
)braket
op_assign
l_int|0x80
op_or
multiline_comment|/* Identify */
macro_line|#if 0
multiline_comment|/* XXX: Auto DiscPriv detection is progressing... */
l_int|0x40
op_or
multiline_comment|/* DiscPriv */
macro_line|#endif
id|SCpnt-&gt;device-&gt;lun
suffix:semicolon
multiline_comment|/* LUNTRN */
id|data-&gt;msgoutlen
op_assign
id|pos
suffix:semicolon
)brace
multiline_comment|/*&n; * SDTR Message Routine&n; */
DECL|function|nsp32_build_sdtr
r_static
r_void
id|nsp32_build_sdtr
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
r_int
r_char
id|period
comma
r_int
r_char
id|offset
)paren
(brace
r_int
id|pos
op_assign
id|data-&gt;msgoutlen
suffix:semicolon
id|data-&gt;msgoutbuf
(braket
id|pos
op_increment
)braket
op_assign
id|EXTENDED_MESSAGE
suffix:semicolon
id|data-&gt;msgoutbuf
(braket
id|pos
op_increment
)braket
op_assign
id|EXTENDED_SDTR_LEN
suffix:semicolon
id|data-&gt;msgoutbuf
(braket
id|pos
op_increment
)braket
op_assign
id|EXTENDED_SDTR
suffix:semicolon
id|data-&gt;msgoutbuf
(braket
id|pos
op_increment
)braket
op_assign
id|period
suffix:semicolon
id|data-&gt;msgoutbuf
(braket
id|pos
op_increment
)braket
op_assign
id|offset
suffix:semicolon
id|data-&gt;msgoutlen
op_assign
id|pos
suffix:semicolon
)brace
multiline_comment|/*&n; * No Operation Message&n; */
DECL|function|nsp32_build_nop
r_static
r_void
id|nsp32_build_nop
c_func
(paren
id|nsp32_hw_data
op_star
id|data
)paren
(brace
r_int
id|pos
op_assign
id|data-&gt;msgoutlen
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ne
l_int|0
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;Some messages are already contained!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|data-&gt;msgoutbuf
(braket
id|pos
op_increment
)braket
op_assign
id|NOP
suffix:semicolon
id|data-&gt;msgoutlen
op_assign
id|pos
suffix:semicolon
)brace
multiline_comment|/*&n; * Reject Message&n; */
DECL|function|nsp32_build_reject
r_static
r_void
id|nsp32_build_reject
c_func
(paren
id|nsp32_hw_data
op_star
id|data
)paren
(brace
r_int
id|pos
op_assign
id|data-&gt;msgoutlen
suffix:semicolon
id|data-&gt;msgoutbuf
(braket
id|pos
op_increment
)braket
op_assign
id|MESSAGE_REJECT
suffix:semicolon
id|data-&gt;msgoutlen
op_assign
id|pos
suffix:semicolon
)brace
multiline_comment|/*&n; * timer&n; */
macro_line|#if 0
r_static
r_void
id|nsp32_start_timer
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|time
)paren
(brace
r_int
r_int
id|base
op_assign
id|SCpnt-&gt;host-&gt;io_port
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
id|__func__
l_string|&quot; time=%d&bslash;n&quot;
comma
id|time
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time
op_amp
(paren
op_complement
id|TIMER_CNT_MASK
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;timer set overflow&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|nsp32_write2
c_func
(paren
id|base
comma
id|TIMER_SET
comma
id|time
op_amp
id|TIMER_CNT_MASK
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * set SCSI command and other parameter to asic, and start selection phase&n; */
DECL|function|nsp32hw_start_selection
r_static
r_int
id|nsp32hw_start_selection
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
id|nsp32_hw_data
op_star
id|data
)paren
(brace
r_int
r_int
id|host_id
op_assign
id|SCpnt-&gt;device-&gt;host-&gt;this_id
suffix:semicolon
r_int
r_int
id|base
op_assign
id|SCpnt-&gt;device-&gt;host-&gt;io_port
suffix:semicolon
r_int
r_char
id|target
op_assign
id|SCpnt-&gt;device-&gt;id
suffix:semicolon
r_int
r_char
op_star
id|param
op_assign
id|data-&gt;autoparam
suffix:semicolon
r_int
r_char
id|phase
comma
id|arbit
suffix:semicolon
r_int
id|i
comma
id|time
suffix:semicolon
r_int
r_int
id|msgout
suffix:semicolon
r_int
r_int
id|l
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
multiline_comment|/*&n;&t; * check bus free&n;&t; */
id|phase
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_BUS_MONITOR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|phase
op_ne
id|BUSMON_BUS_FREE
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;bus busy&quot;
)paren
suffix:semicolon
id|show_busphase
c_func
(paren
id|phase
op_amp
id|BUSMON_PHASE_MASK
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * message out&n;&t; *&n;&t; * Note: If the range of msgoutlen is 1 - 3, fill scsi_msgout.&n;&t; *       over 3 messages needs another routine.&n;&t; */
r_if
c_cond
(paren
id|data-&gt;msgoutlen
op_eq
l_int|0
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;SCSI MsgOut without any message!&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|data-&gt;msgoutlen
OG
l_int|0
op_logical_and
id|data-&gt;msgoutlen
op_le
l_int|3
)paren
(brace
id|msgout
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|data-&gt;msgoutlen
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * the sending order of the message is:&n;&t;&t;&t; *  MCNT 3: MSG#0 -&gt; MSG#1 -&gt; MSG#2&n;&t;&t;&t; *  MCNT 2:          MSG#1 -&gt; MSG#2&n;&t;&t;&t; *  MCNT 1:                   MSG#2    &n;&t;&t;&t; */
id|msgout
op_rshift_assign
l_int|8
suffix:semicolon
id|msgout
op_or_assign
(paren
r_int
r_int
)paren
(paren
id|data-&gt;msgoutbuf
(braket
id|i
)braket
op_lshift
l_int|24
)paren
suffix:semicolon
)brace
id|msgout
op_or_assign
id|MV_VALID
suffix:semicolon
multiline_comment|/* MV valid */
id|msgout
op_or_assign
(paren
r_int
r_int
)paren
id|data-&gt;msgoutlen
suffix:semicolon
multiline_comment|/* len */
)brace
r_else
(brace
multiline_comment|/* data-&gt;msgoutlen &gt; 3 */
id|msgout
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * setup asic parameter&n;&t; */
id|memset
c_func
(paren
id|param
comma
l_int|0
comma
id|AUTOPARAM_SIZE
)paren
suffix:semicolon
multiline_comment|/* cdb */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCpnt-&gt;cmd_len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|param
(braket
l_int|4
op_star
id|i
)braket
op_assign
id|SCpnt-&gt;cmnd
(braket
id|i
)braket
suffix:semicolon
)brace
multiline_comment|/* message out */
id|param
(braket
l_int|4
op_star
l_int|0x10
op_plus
l_int|0
)braket
op_assign
(paren
id|msgout
op_amp
l_int|0x000000ff
)paren
op_rshift
l_int|0
suffix:semicolon
id|param
(braket
l_int|4
op_star
l_int|0x10
op_plus
l_int|1
)braket
op_assign
(paren
id|msgout
op_amp
l_int|0x0000ff00
)paren
op_rshift
l_int|8
suffix:semicolon
id|param
(braket
l_int|4
op_star
l_int|0x10
op_plus
l_int|2
)braket
op_assign
(paren
id|msgout
op_amp
l_int|0x00ff0000
)paren
op_rshift
l_int|16
suffix:semicolon
id|param
(braket
l_int|4
op_star
l_int|0x10
op_plus
l_int|3
)braket
op_assign
(paren
id|msgout
op_amp
l_int|0xff000000
)paren
op_rshift
l_int|24
suffix:semicolon
multiline_comment|/* syncreg, ackwidth, target id, sampleing rate */
id|param
(braket
l_int|4
op_star
l_int|0x11
op_plus
l_int|0
)braket
op_assign
id|data-&gt;curtarget-&gt;syncreg
suffix:semicolon
id|param
(braket
l_int|4
op_star
l_int|0x11
op_plus
l_int|1
)braket
op_assign
id|data-&gt;curtarget-&gt;ackwidth
suffix:semicolon
id|param
(braket
l_int|4
op_star
l_int|0x11
op_plus
l_int|2
)braket
op_assign
id|BIT
c_func
(paren
id|host_id
)paren
op_or
id|BIT
c_func
(paren
id|target
)paren
suffix:semicolon
id|param
(braket
l_int|4
op_star
l_int|0x11
op_plus
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* command control */
id|s
op_assign
(paren
id|CLEAR_CDB_FIFO_POINTER
op_or
id|AUTOSCSI_START
op_or
id|AUTO_MSGIN_00_OR_04
op_or
id|AUTO_MSGIN_02
op_or
id|AUTO_ATN
)paren
suffix:semicolon
id|param
(braket
l_int|4
op_star
l_int|0x12
op_plus
l_int|0
)braket
op_assign
(paren
id|s
op_amp
l_int|0x00ff
)paren
op_rshift
l_int|0
suffix:semicolon
id|param
(braket
l_int|4
op_star
l_int|0x12
op_plus
l_int|1
)braket
op_assign
(paren
id|s
op_amp
l_int|0xff00
)paren
op_rshift
l_int|8
suffix:semicolon
multiline_comment|/* transfer control */
id|s
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|data-&gt;trans_method
)paren
(brace
r_case
id|NSP32_TRANSFER_BUSMASTER
suffix:colon
id|s
op_or_assign
id|BM_START
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NSP32_TRANSFER_MMIO
suffix:colon
id|s
op_or_assign
id|CB_MMIO_MODE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NSP32_TRANSFER_PIO
suffix:colon
id|s
op_or_assign
id|CB_IO_MODE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;unknown trans_method&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * ORed BLIEND_MODE, FIFO intr is decreased, instead of PCI bus waits.&n;&t; * For bus master transfer, it&squot;s taken off.&n;&t; */
id|s
op_or_assign
(paren
id|TRANSFER_GO
op_or
id|ALL_COUNTER_CLR
)paren
suffix:semicolon
id|param
(braket
l_int|4
op_star
l_int|0x12
op_plus
l_int|2
)braket
op_assign
(paren
id|s
op_amp
l_int|0x00ff
)paren
op_rshift
l_int|0
suffix:semicolon
id|param
(braket
l_int|4
op_star
l_int|0x12
op_plus
l_int|3
)braket
op_assign
(paren
id|s
op_amp
l_int|0xff00
)paren
op_rshift
l_int|8
suffix:semicolon
multiline_comment|/* sg table addr */
id|l
op_assign
id|data-&gt;curlunt-&gt;sglun_paddr
suffix:semicolon
id|param
(braket
l_int|4
op_star
l_int|0x13
op_plus
l_int|0
)braket
op_assign
(paren
id|l
op_amp
l_int|0x000000ff
)paren
op_rshift
l_int|0
suffix:semicolon
id|param
(braket
l_int|4
op_star
l_int|0x13
op_plus
l_int|1
)braket
op_assign
(paren
id|l
op_amp
l_int|0x0000ff00
)paren
op_rshift
l_int|8
suffix:semicolon
id|param
(braket
l_int|4
op_star
l_int|0x13
op_plus
l_int|2
)braket
op_assign
(paren
id|l
op_amp
l_int|0x00ff0000
)paren
op_rshift
l_int|16
suffix:semicolon
id|param
(braket
l_int|4
op_star
l_int|0x13
op_plus
l_int|3
)braket
op_assign
(paren
id|l
op_amp
l_int|0xff000000
)paren
op_rshift
l_int|24
suffix:semicolon
multiline_comment|/*&n;&t; * transfer parameter to asic&n;&t; */
id|nsp32_write4
c_func
(paren
id|base
comma
id|SGT_ADR
comma
id|virt_to_bus
c_func
(paren
id|param
)paren
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|COMMAND_CONTROL
comma
id|CLEAR_CDB_FIFO_POINTER
op_or
id|AUTO_PARAMETER
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Arbitration Status Check&n;&t; *&t;&n;&t; * Note: Arbitration counter is wait during ARBIT_GO is not lifting.&n;&t; *&t; Using udelay(1) consumes CPU time and system time, but &n;&t; *&t; arbitration delay time is defined minimal 2.4us in SCSI&n;&t; *&t; specification, thus udelay works as coarse grained wait timer.&n;&t; */
id|time
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|arbit
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|ARBIT_STATUS
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_AUTOSCSI
comma
l_string|&quot;arbit=0x%x&quot;
comma
id|arbit
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|arbit
op_amp
(paren
id|ARBIT_WIN
op_or
id|ARBIT_FAIL
)paren
)paren
op_eq
l_int|0
op_logical_and
(paren
id|time
op_increment
op_le
l_int|1000
)paren
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_AUTOSCSI
comma
l_string|&quot;arbit: 0x%x, delay time: %d&quot;
comma
id|arbit
comma
id|time
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arbit
op_amp
id|ARBIT_WIN
)paren
(brace
id|SCpnt-&gt;result
op_assign
id|DID_OK
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* PCI LED on! */
id|nsp32_index_write1
c_func
(paren
id|base
comma
id|EXT_PORT
comma
id|LED_ON
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|arbit
op_amp
id|ARBIT_FAIL
)paren
(brace
id|SCpnt-&gt;result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
id|nsp32_write1
c_func
(paren
id|base
comma
id|SET_ARBIT
comma
id|ARBIT_CLEAR
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* unknown error or ARBIT_GO timeout */
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_AUTOSCSI
comma
l_string|&quot;arbit fail&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
id|nsp32_write1
c_func
(paren
id|base
comma
id|SET_ARBIT
comma
id|ARBIT_CLEAR
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * clear Arbit&n;&t; */
id|nsp32_write1
c_func
(paren
id|base
comma
id|SET_ARBIT
comma
id|ARBIT_CLEAR
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n; * Selection with AUTO SCSI (without AUTO PARAMETER)&n; */
DECL|function|nsp32_selection_autoscsi
r_static
r_int
id|nsp32_selection_autoscsi
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
id|nsp32_hw_data
op_star
id|data
)paren
(brace
r_int
r_char
id|phase
suffix:semicolon
r_int
r_char
id|arbit
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|command
op_assign
l_int|0
suffix:semicolon
r_int
id|time
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|msgout
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|execph
suffix:semicolon
r_int
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
multiline_comment|/*&n;&t; * IRQ disable&n;&t; */
id|nsp32_write2
c_func
(paren
id|base
comma
id|IRQ_CONTROL
comma
id|IRQ_CONTROL_ALL_IRQ_MASK
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * check bus line&n;&t; */
id|phase
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_BUS_MONITOR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|phase
op_amp
id|BUSMON_BSY
)paren
op_eq
l_int|1
)paren
op_logical_or
(paren
id|phase
op_amp
id|BUSMON_SEL
)paren
op_eq
l_int|1
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;bus busy&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
id|status
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * clear execph&n;&t; */
id|execph
op_assign
id|nsp32_read2
c_func
(paren
id|base
comma
id|SCSI_EXECUTE_PHASE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * clear FIFO counter to set CDBs&n;&t; */
id|nsp32_write2
c_func
(paren
id|base
comma
id|COMMAND_CONTROL
comma
id|CLEAR_CDB_FIFO_POINTER
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set CDB0 - CDB15&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCpnt-&gt;cmd_len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|nsp32_write1
c_func
(paren
id|base
comma
id|COMMAND_DATA
comma
id|SCpnt-&gt;cmnd
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_CDB_CONTENTS
comma
l_string|&quot;CDB[0]=[0x%x]&quot;
comma
id|SCpnt-&gt;cmnd
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set SCSIOUT LATCH(initiator)/TARGET(target) (ORed) ID&n;&t; */
id|nsp32_write1
c_func
(paren
id|base
comma
id|SCSI_OUT_LATCH_TARGET_ID
comma
(paren
(paren
l_int|1
op_lshift
id|NSP32_HOST_SCSIID
)paren
op_or
(paren
l_int|1
op_lshift
id|SCpnt-&gt;device-&gt;id
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set SCSI MSGOUT REG&n;&t; *&n;&t; * Note: If the range of msgoutlen is 1 - 3, fill scsi_msgout.&n;&t; *       over 3 messages needs another routine.&n;&t; */
r_if
c_cond
(paren
id|data-&gt;msgoutlen
op_eq
l_int|0
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;SCSI MsgOut without any message!&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|status
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|data-&gt;msgoutlen
OG
l_int|0
op_logical_and
id|data-&gt;msgoutlen
op_le
l_int|3
)paren
(brace
id|msgout
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|data-&gt;msgoutlen
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * the sending order of the message is:&n;&t;&t;&t; *  MCNT 3: MSG#0 -&gt; MSG#1 -&gt; MSG#2&n;&t;&t;&t; *  MCNT 2:          MSG#1 -&gt; MSG#2&n;&t;&t;&t; *  MCNT 1:                   MSG#2    &n;&t;&t;&t; */
id|msgout
op_rshift_assign
l_int|8
suffix:semicolon
id|msgout
op_or_assign
(paren
r_int
r_int
)paren
(paren
id|data-&gt;msgoutbuf
(braket
id|i
)braket
op_lshift
l_int|24
)paren
suffix:semicolon
)brace
id|msgout
op_or_assign
id|MV_VALID
suffix:semicolon
multiline_comment|/* MV valid */
id|msgout
op_or_assign
(paren
r_int
r_int
)paren
id|data-&gt;msgoutlen
suffix:semicolon
multiline_comment|/* len */
id|nsp32_write4
c_func
(paren
id|base
comma
id|SCSI_MSG_OUT
comma
id|msgout
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* data-&gt;msgoutlen &gt; 3 */
id|nsp32_write4
c_func
(paren
id|base
comma
id|SCSI_MSG_OUT
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * set selection timeout(= 250ms)&n;&t; */
id|nsp32_write2
c_func
(paren
id|base
comma
id|SEL_TIME_OUT
comma
id|SEL_TIMEOUT_TIME
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set smpl rate&n;&t; * &n;&t; * TODO: smpl_rate (BASE+0F) is 0 when internal clock = 40MHz.&n;&t; *      check other internal clock!&n;&t; */
id|nsp32_write1
c_func
(paren
id|base
comma
id|SREQ_SMPL_RATE
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * clear Arbit&n;&t; */
id|nsp32_write1
c_func
(paren
id|base
comma
id|SET_ARBIT
comma
id|ARBIT_CLEAR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set SYNCREG&n;&t; * Don&squot;t set BM_START_ADR before setting this register.&n;&t; */
id|nsp32_write1
c_func
(paren
id|base
comma
id|SYNC_REG
comma
id|data-&gt;curtarget-&gt;syncreg
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set ACKWIDTH&n;&t; */
id|nsp32_write1
c_func
(paren
id|base
comma
id|ACK_WIDTH
comma
id|data-&gt;curtarget-&gt;ackwidth
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_AUTOSCSI
comma
l_string|&quot;syncreg=0x%x, ackwidth=0x%x, sgtpaddr=0x%x, id=0x%x&quot;
comma
id|nsp32_read1
c_func
(paren
id|base
comma
id|SYNC_REG
)paren
comma
id|nsp32_read1
c_func
(paren
id|base
comma
id|ACK_WIDTH
)paren
comma
id|nsp32_read4
c_func
(paren
id|base
comma
id|SGT_ADR
)paren
comma
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_OUT_LATCH_TARGET_ID
)paren
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_AUTOSCSI
comma
l_string|&quot;msgoutlen=%d, msgout=0x%x&quot;
comma
id|data-&gt;msgoutlen
comma
id|msgout
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set SGT ADDR (physical address)&n;&t; */
id|nsp32_write4
c_func
(paren
id|base
comma
id|SGT_ADR
comma
id|data-&gt;curlunt-&gt;sglun_paddr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set TRANSFER CONTROL REG&n;&t; */
id|command
op_assign
l_int|0
suffix:semicolon
id|command
op_or_assign
(paren
id|TRANSFER_GO
op_or
id|ALL_COUNTER_CLR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;trans_method
op_amp
id|NSP32_TRANSFER_BUSMASTER
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;request_bufflen
OG
l_int|0
)paren
(brace
id|command
op_or_assign
id|BM_START
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|data-&gt;trans_method
op_amp
id|NSP32_TRANSFER_MMIO
)paren
(brace
id|command
op_or_assign
id|CB_MMIO_MODE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|data-&gt;trans_method
op_amp
id|NSP32_TRANSFER_PIO
)paren
(brace
id|command
op_or_assign
id|CB_IO_MODE
suffix:semicolon
)brace
id|nsp32_write2
c_func
(paren
id|base
comma
id|TRANSFER_CONTROL
comma
id|command
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * start AUTO SCSI, kick off arbitration&n;&t; */
id|command
op_assign
l_int|0
suffix:semicolon
id|command
op_or_assign
(paren
id|CLEAR_CDB_FIFO_POINTER
op_or
id|AUTOSCSI_START
op_or
id|AUTO_MSGIN_00_OR_04
op_or
id|AUTO_MSGIN_02
op_or
id|AUTO_ATN
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|COMMAND_CONTROL
comma
id|command
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Arbitration Status Check&n;&t; *&t;&n;&t; * Note: Arbitration counter is wait during ARBIT_GO is not lifting.&n;&t; *&t; Using udelay(1) consumes CPU time and system time, but &n;&t; *&t; arbitration delay time is defined minimal 2.4us in SCSI&n;&t; *&t; specification, thus udelay works as coarse grained wait timer.&n;&t; */
id|time
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|arbit
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|ARBIT_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arbit
op_amp
id|ARBIT_GO
)paren
(brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|time
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|time
OG
id|ARBIT_TIMEOUT_TIME
)paren
(brace
multiline_comment|/* something lock up! guess no connection */
id|SCpnt-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
id|status
op_assign
id|FALSE
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_AUTOSCSI
comma
l_string|&quot;arbit: 0x%x, delay time: %d&quot;
comma
id|arbit
comma
id|time
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * check Arbitration Status Result&n;&t; */
r_if
c_cond
(paren
id|arbit
op_amp
id|ARBIT_WIN
)paren
(brace
multiline_comment|/* Arbitration succeeded */
id|status
op_assign
id|TRUE
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_OK
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* PCI LED on! */
id|nsp32_index_write1
c_func
(paren
id|base
comma
id|EXT_PORT
comma
id|LED_ON
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|arbit
op_amp
id|ARBIT_FAIL
)paren
(brace
multiline_comment|/* Arbitration failed */
id|status
op_assign
id|FALSE
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* unknown error? */
id|status
op_assign
id|FALSE
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * clear Arbit&n;&t; */
id|nsp32_write1
c_func
(paren
id|base
comma
id|SET_ARBIT
comma
id|ARBIT_CLEAR
)paren
suffix:semicolon
id|out
suffix:colon
multiline_comment|/*&n;&t; * IRQ enable&n;&t; */
id|nsp32_write2
c_func
(paren
id|base
comma
id|IRQ_CONTROL
comma
l_int|0
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * reselection&n; *&n; * Note: This reselection routine is called from msgin_occur,&n; *&t; reselection target id&amp;lun must be already set.&n; *&t; SCSI-2 says IDENTIFY implies RESTORE_POINTER operation.&n; */
DECL|function|nsp32_reselection
r_static
r_int
id|nsp32_reselection
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
r_int
r_char
id|newlun
)paren
(brace
r_int
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
r_int
r_char
id|tmpid
comma
id|newid
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_RESELECTION
comma
l_string|&quot;enter&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * calculate reselected SCSI ID&n;&t; */
id|tmpid
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|RESELECT_ID
)paren
suffix:semicolon
id|tmpid
op_and_assign
l_int|0x7f
suffix:semicolon
id|newid
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|tmpid
)paren
(brace
r_if
c_cond
(paren
id|tmpid
op_amp
l_int|1
)paren
(brace
r_break
suffix:semicolon
)brace
id|tmpid
op_rshift_assign
l_int|1
suffix:semicolon
id|newid
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If reselected New ID:LUN is not existed&n;&t; * or current nexus is not existed, unexpected&n;&t; * reselection is occurred. Send reject message.&n;&t; */
r_if
c_cond
(paren
id|newid
op_ge
id|MAX_TARGET
op_logical_or
id|newlun
op_ge
id|MAX_LUN
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;unknown id/lun&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|data-&gt;lunt
(braket
id|newid
)braket
(braket
id|newlun
)braket
op_member_access_from_pointer
id|SCpnt
op_eq
l_int|NULL
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;no SCSI command is processing&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|data-&gt;pid
op_assign
id|newid
suffix:semicolon
id|data-&gt;plun
op_assign
id|newlun
suffix:semicolon
id|data-&gt;curtarget
op_assign
op_amp
id|data-&gt;target
(braket
id|newid
)braket
suffix:semicolon
id|data-&gt;curlunt
op_assign
id|data-&gt;lunt
(braket
id|newid
)braket
(braket
id|newlun
)braket
suffix:semicolon
multiline_comment|/* reset SACK/SavedACK counter (or ALL clear?) */
id|nsp32_write4
c_func
(paren
id|base
comma
id|CLR_COUNTER
comma
id|CLRCOUNTER_ALLMASK
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n; * nsp32hw_setup_sg_table - build scatter gather list for transfer data&n; *&t;&t;&t;    with bus master.&n; *&n; * Note: NinjaSCSI-32Bi/UDE bus master can not transfer over 64KB at a time.&n; */
DECL|function|nsp32hw_setup_sg_table
r_static
r_int
id|nsp32hw_setup_sg_table
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
id|nsp32_hw_data
op_star
id|data
)paren
(brace
r_struct
id|scatterlist
op_star
id|sgl
suffix:semicolon
r_struct
id|nsp32_sgtable
op_star
id|sgt
op_assign
id|data-&gt;curlunt-&gt;sglun-&gt;sgt
suffix:semicolon
r_int
id|num
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;request_bufflen
op_eq
l_int|0
)paren
(brace
r_return
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sgt
op_eq
l_int|NULL
)paren
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_SGLIST
comma
l_string|&quot;SGT == null&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
)paren
(brace
id|sgl
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|SCpnt-&gt;request_buffer
suffix:semicolon
id|num
op_assign
id|pci_map_sg
c_func
(paren
id|data-&gt;Pci
comma
id|sgl
comma
id|SCpnt-&gt;use_sg
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|SCpnt-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Build nsp32_sglist, substitute sg dma addresses.&n;&t;&t;&t; */
id|sgt
(braket
id|i
)braket
dot
id|addr
op_assign
id|cpu_to_le32
c_func
(paren
id|sg_dma_address
c_func
(paren
id|sgl
)paren
)paren
suffix:semicolon
id|sgt
(braket
id|i
)braket
dot
id|len
op_assign
id|cpu_to_le32
c_func
(paren
id|sg_dma_len
c_func
(paren
id|sgl
)paren
)paren
suffix:semicolon
id|sgl
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sgt
(braket
id|i
)braket
dot
id|len
OG
l_int|65536
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;can&squot;t transfer over 64KB at a time&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_SGLIST
comma
l_string|&quot;num 0x%x : addr 0x%lx len 0x%x&quot;
comma
id|i
comma
id|sgt
(braket
id|i
)braket
dot
id|addr
comma
id|sgt
(braket
id|i
)braket
dot
id|len
)paren
suffix:semicolon
)brace
id|sgt
(braket
id|num
op_minus
l_int|1
)braket
dot
id|len
op_or_assign
id|NSP32_SG_END_SGT
suffix:semicolon
multiline_comment|/* set end mark */
)brace
r_else
(brace
id|SCpnt-&gt;SCp.have_data_in
op_assign
id|pci_map_single
c_func
(paren
id|data-&gt;Pci
comma
id|SCpnt-&gt;request_buffer
comma
id|SCpnt-&gt;request_bufflen
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|SCpnt-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
id|sgt
(braket
l_int|0
)braket
dot
id|addr
op_assign
id|cpu_to_le32
c_func
(paren
id|SCpnt-&gt;SCp.have_data_in
)paren
suffix:semicolon
id|sgt
(braket
l_int|0
)braket
dot
id|len
op_assign
id|cpu_to_le32
c_func
(paren
id|SCpnt-&gt;request_bufflen
)paren
suffix:semicolon
id|sgt
(braket
l_int|0
)braket
dot
id|len
op_or_assign
id|NSP32_SG_END_SGT
suffix:semicolon
multiline_comment|/* set end mark */
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_SGLIST
comma
l_string|&quot;single : addr 0x%lx len=0x%x&quot;
comma
id|sgt
(braket
l_int|0
)braket
dot
id|addr
comma
id|sgt
(braket
l_int|0
)braket
dot
id|len
)paren
suffix:semicolon
)brace
r_return
id|TRUE
suffix:semicolon
)brace
DECL|function|nsp32_queuecommand
r_static
r_int
id|nsp32_queuecommand
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|SCpnt-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
r_struct
id|nsp32_target
op_star
id|target
suffix:semicolon
r_struct
id|nsp32_lunt
op_star
id|curlunt
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_QUEUECOMMAND
comma
l_string|&quot;enter. target: 0x%x LUN: 0x%x cmnd: 0x%x cmndlen: 0x%x &quot;
l_string|&quot;use_sg: 0x%x reqbuf: 0x%lx reqlen: 0x%x&quot;
comma
id|SCpnt-&gt;device-&gt;id
comma
id|SCpnt-&gt;device-&gt;lun
comma
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
comma
id|SCpnt-&gt;cmd_len
comma
id|SCpnt-&gt;use_sg
comma
id|SCpnt-&gt;request_buffer
comma
id|SCpnt-&gt;request_bufflen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;CurrentSC
op_ne
l_int|NULL
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;Currentsc != NULL. Cancel this command request&quot;
)paren
suffix:semicolon
id|data-&gt;CurrentSC
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
id|done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* check target ID is not same as this initiator ID */
r_if
c_cond
(paren
id|SCpnt-&gt;device-&gt;id
op_eq
id|NSP32_HOST_SCSIID
)paren
(brace
id|SCpnt-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
id|done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* check target LUN is allowable value */
r_if
c_cond
(paren
id|SCpnt-&gt;device-&gt;lun
op_ge
id|MAX_LUN
)paren
(brace
id|SCpnt-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
id|done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|show_command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|SCpnt-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|data-&gt;CurrentSC
op_assign
id|SCpnt
suffix:semicolon
id|SCpnt-&gt;SCp.Status
op_assign
id|CHECK_CONDITION
suffix:semicolon
id|SCpnt-&gt;SCp.Message
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;resid
op_assign
l_int|0
suffix:semicolon
singleline_comment|//SCpnt-&gt;request_bufflen;
id|SCpnt-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
id|SCpnt-&gt;request_buffer
suffix:semicolon
id|SCpnt-&gt;SCp.this_residual
op_assign
id|SCpnt-&gt;request_bufflen
suffix:semicolon
id|SCpnt-&gt;SCp.buffer
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;SCp.buffers_residual
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* initialize data */
id|data-&gt;msgoutlen
op_assign
l_int|0
suffix:semicolon
id|data-&gt;msginlen
op_assign
l_int|0
suffix:semicolon
id|curlunt
op_assign
id|data-&gt;lunt
(braket
id|SCpnt-&gt;device-&gt;id
)braket
(braket
id|SCpnt-&gt;device-&gt;lun
)braket
suffix:semicolon
id|curlunt-&gt;SCpnt
op_assign
id|SCpnt
suffix:semicolon
id|curlunt-&gt;save_datp
op_assign
l_int|0
suffix:semicolon
id|curlunt-&gt;msgin03
op_assign
id|FALSE
suffix:semicolon
id|data-&gt;curlunt
op_assign
id|curlunt
suffix:semicolon
id|data-&gt;pid
op_assign
id|SCpnt-&gt;device-&gt;id
suffix:semicolon
id|data-&gt;plun
op_assign
id|SCpnt-&gt;device-&gt;lun
suffix:semicolon
id|ret
op_assign
id|nsp32hw_setup_sg_table
c_func
(paren
id|SCpnt
comma
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|FALSE
)paren
(brace
id|SCpnt-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|nsp32_scsi_done
c_func
(paren
id|data
comma
id|SCpnt
)paren
suffix:semicolon
)brace
multiline_comment|/* Build IDENTIFY */
id|nsp32_build_identify
c_func
(paren
id|data
comma
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * If target is the first time to transfer after the reset&n;&t; * (target don&squot;t have SDTR_DONE and SDTR_INITIATOR), sync&n;&t; * message SDTR is needed to do synchronous transfer.&n;&t; */
id|target
op_assign
op_amp
id|data-&gt;target
(braket
id|SCpnt-&gt;device-&gt;id
)braket
suffix:semicolon
id|data-&gt;curtarget
op_assign
id|target
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|target-&gt;sync_flag
op_amp
(paren
id|SDTR_DONE
op_or
id|SDTR_INITIATOR
op_or
id|SDTR_TARGET
)paren
)paren
)paren
(brace
r_int
r_char
id|period
comma
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|trans_mode
op_ne
id|ASYNC_MODE
)paren
(brace
id|nsp32_set_max_sync
c_func
(paren
id|data
comma
id|target
comma
op_amp
id|period
comma
op_amp
id|offset
)paren
suffix:semicolon
id|nsp32_build_sdtr
c_func
(paren
id|data
comma
id|period
comma
id|offset
)paren
suffix:semicolon
id|target-&gt;sync_flag
op_or_assign
id|SDTR_INITIATOR
suffix:semicolon
)brace
r_else
(brace
id|nsp32_set_async
c_func
(paren
id|data
comma
id|target
)paren
suffix:semicolon
id|target-&gt;sync_flag
op_or_assign
id|SDTR_DONE
suffix:semicolon
)brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_QUEUECOMMAND
comma
l_string|&quot;SDTR: entry: %d start_period: 0x%x offset: 0x%x&bslash;n&quot;
comma
id|target-&gt;limit_entry
comma
id|period
comma
id|offset
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|target-&gt;sync_flag
op_amp
id|SDTR_INITIATOR
)paren
(brace
multiline_comment|/*&n;&t;&t; * It was negotiating SDTR with target, sending from the&n;&t;&t; * initiator, but there are no chance to remove this flag.&n;&t;&t; * Set async because we don&squot;t get proper negotiation.&n;&t;&t; */
id|nsp32_set_async
c_func
(paren
id|data
comma
id|target
)paren
suffix:semicolon
id|target-&gt;sync_flag
op_and_assign
op_complement
id|SDTR_INITIATOR
suffix:semicolon
id|target-&gt;sync_flag
op_or_assign
id|SDTR_DONE
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_QUEUECOMMAND
comma
l_string|&quot;SDTR_INITIATOR: fall back to async&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|target-&gt;sync_flag
op_amp
id|SDTR_TARGET
)paren
(brace
multiline_comment|/*&n;&t;&t; * It was negotiating SDTR with target, sending from target,&n;&t;&t; * but there are no chance to remove this flag.  Set async&n;&t;&t; * because we don&squot;t get proper negotiation.&n;&t;&t; */
id|nsp32_set_async
c_func
(paren
id|data
comma
id|target
)paren
suffix:semicolon
id|target-&gt;sync_flag
op_and_assign
op_complement
id|SDTR_TARGET
suffix:semicolon
id|target-&gt;sync_flag
op_or_assign
id|SDTR_DONE
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_QUEUECOMMAND
comma
l_string|&quot;Unknown SDTR from target is reached, fall back to async.&quot;
)paren
suffix:semicolon
)brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_TARGETFLAG
comma
l_string|&quot;target: %d sync_flag: 0x%x syncreg: 0x%x ackwidth: 0x%x&quot;
comma
id|SCpnt-&gt;device-&gt;id
comma
id|target-&gt;sync_flag
comma
id|target-&gt;syncreg
comma
id|target-&gt;ackwidth
)paren
suffix:semicolon
multiline_comment|/* Selection */
r_if
c_cond
(paren
id|auto_param
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|nsp32hw_start_selection
c_func
(paren
id|SCpnt
comma
id|data
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
id|nsp32_selection_autoscsi
c_func
(paren
id|SCpnt
comma
id|data
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_ne
id|TRUE
)paren
(brace
id|nsp32_scsi_done
c_func
(paren
id|data
comma
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* initialize asic */
DECL|function|nsp32hw_init
r_static
r_int
id|nsp32hw_init
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_int
r_int
id|base
op_assign
id|host-&gt;io_port
suffix:semicolon
r_int
r_int
id|irq_stat
suffix:semicolon
r_int
r_int
id|lc_reg
suffix:semicolon
r_int
r_char
id|power
suffix:semicolon
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|lc_reg
op_assign
id|nsp32_index_read4
c_func
(paren
id|base
comma
id|CFG_LATE_CACHE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lc_reg
op_amp
l_int|0xff00
)paren
op_eq
l_int|0
)paren
(brace
id|lc_reg
op_or_assign
(paren
l_int|0x20
op_lshift
l_int|8
)paren
suffix:semicolon
id|nsp32_index_write2
c_func
(paren
id|base
comma
id|CFG_LATE_CACHE
comma
id|lc_reg
op_amp
l_int|0xffff
)paren
suffix:semicolon
)brace
id|nsp32_write2
c_func
(paren
id|base
comma
id|IRQ_CONTROL
comma
id|IRQ_CONTROL_ALL_IRQ_MASK
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|TRANSFER_CONTROL
comma
l_int|0
)paren
suffix:semicolon
id|nsp32_write4
c_func
(paren
id|base
comma
id|BM_CNT
comma
l_int|0
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|SCSI_EXECUTE_PHASE
comma
l_int|0
)paren
suffix:semicolon
r_do
(brace
id|irq_stat
op_assign
id|nsp32_read2
c_func
(paren
id|base
comma
id|IRQ_STATUS
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|irq_stat
op_amp
id|IRQSTATUS_ANY_IRQ
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INIT
comma
l_string|&quot;irq_stat 0x%x&quot;
comma
id|irq_stat
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill FIFO_FULL_SHLD, FIFO_EMPTY_SHLD. Below parameter is&n;&t; *  designated by specification.&n;&t; */
r_if
c_cond
(paren
(paren
id|data-&gt;trans_method
op_amp
id|NSP32_TRANSFER_PIO
)paren
op_logical_or
(paren
id|data-&gt;trans_method
op_amp
id|NSP32_TRANSFER_MMIO
)paren
)paren
(brace
id|nsp32_index_write1
c_func
(paren
id|base
comma
id|FIFO_FULL_SHLD_COUNT
comma
l_int|0x40
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|data-&gt;trans_method
op_amp
id|NSP32_TRANSFER_BUSMASTER
)paren
(brace
id|nsp32_index_write1
c_func
(paren
id|base
comma
id|FIFO_FULL_SHLD_COUNT
comma
l_int|0x10
)paren
suffix:semicolon
)brace
id|nsp32_index_write1
c_func
(paren
id|base
comma
id|FIFO_EMPTY_SHLD_COUNT
comma
l_int|0x60
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INIT
comma
l_string|&quot;full 0x%x emp 0x%x&quot;
comma
id|nsp32_index_read1
c_func
(paren
id|base
comma
id|FIFO_FULL_SHLD_COUNT
)paren
comma
id|nsp32_index_read1
c_func
(paren
id|base
comma
id|FIFO_EMPTY_SHLD_COUNT
)paren
)paren
suffix:semicolon
id|nsp32_index_write1
c_func
(paren
id|base
comma
id|CLOCK_DIV
comma
id|data-&gt;clock
)paren
suffix:semicolon
id|nsp32_index_write1
c_func
(paren
id|base
comma
id|BM_CYCLE
comma
id|MEMRD_CMD1
op_or
id|SGT_AUTO_PARA_MEMED_CMD
)paren
suffix:semicolon
id|nsp32_write1
c_func
(paren
id|base
comma
id|PARITY_CONTROL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* parity check is disable */
multiline_comment|/*&n;&t; * initialize I_MISC_WRRD register&n;&t; * &n;&t; * Note: Designated parameters is obeyed as following:&n;&t; *&t;MISC_SCSI_DIRECTION_DETECTOR_SELECT: It must be set.&n;&t; *&t;MISC_MASTER_TERMINATION_SELECT:      It must be set.&n;&t; *&t;MISC_BMREQ_NEGATE_TIMING_SEL:&t;     It should be set.&n;&t; *&t;MISC_AUTOSEL_TIMING_SEL:&t;     It should be set.&n;&t; *&t;MISC_BMSTOP_CHANGE2_NONDATA_PHASE:   It should be set.&n;&t; *&t;MISC_DELAYED_BMSTART:&t;&t;     It&squot;s selected for safety.&n;&t; *&n;&t; * Note: If MISC_BMSTOP_CHANGE2_NONDATA_PHASE is set, then&n;&t; *&t;we have to set TRANSFERCONTROL_BM_START as 0 and set&n;&t; *&t;appropriate value before restarting bus master transfer.&n;&t; */
id|nsp32_index_write2
c_func
(paren
id|base
comma
id|MISC_WR
comma
(paren
id|SCSI_DIRECTION_DETECTOR_SELECT
op_or
id|DELAYED_BMSTART
op_or
id|MASTER_TERMINATION_SELECT
op_or
id|BMREQ_NEGATE_TIMING_SEL
op_or
id|AUTOSEL_TIMING_SEL
op_or
id|BMSTOP_CHANGE2_NONDATA_PHASE
)paren
)paren
suffix:semicolon
id|nsp32_index_write1
c_func
(paren
id|base
comma
id|TERM_PWR_CONTROL
comma
l_int|0
)paren
suffix:semicolon
id|power
op_assign
id|nsp32_index_read1
c_func
(paren
id|base
comma
id|TERM_PWR_CONTROL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|power
op_amp
id|SENSE
)paren
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;term power on&quot;
)paren
suffix:semicolon
id|nsp32_index_write1
c_func
(paren
id|base
comma
id|TERM_PWR_CONTROL
comma
id|BPWR
)paren
suffix:semicolon
)brace
id|nsp32_write2
c_func
(paren
id|base
comma
id|TIMER_SET
comma
id|TIMER_STOP
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|TIMER_SET
comma
id|TIMER_STOP
)paren
suffix:semicolon
id|nsp32_write1
c_func
(paren
id|base
comma
id|SYNC_REG
comma
l_int|0
)paren
suffix:semicolon
id|nsp32_write1
c_func
(paren
id|base
comma
id|ACK_WIDTH
comma
l_int|0
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|SEL_TIME_OUT
comma
l_int|10000
)paren
suffix:semicolon
multiline_comment|/* 25us x10000 = 250ms defined in SCSI */
multiline_comment|/*&n;&t; * enable to select designated IRQ (except for&n;&t; * IRQSELECT_SERR, IRQSELECT_PERR, IRQSELECT_BMCNTERR)&n;&t; */
id|nsp32_index_write2
c_func
(paren
id|base
comma
id|IRQ_SELECT
comma
id|IRQSELECT_TIMER_IRQ
op_or
id|IRQSELECT_SCSIRESET_IRQ
op_or
id|IRQSELECT_FIFO_SHLD_IRQ
op_or
id|IRQSELECT_RESELECT_IRQ
op_or
id|IRQSELECT_PHASE_CHANGE_IRQ
op_or
id|IRQSELECT_AUTO_SCSI_SEQ_IRQ
op_or
singleline_comment|//IRQSELECT_BMCNTERR_IRQ    |
id|IRQSELECT_TARGET_ABORT_IRQ
op_or
id|IRQSELECT_MASTER_ABORT_IRQ
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|IRQ_CONTROL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* PCI LED off */
id|nsp32_index_write1
c_func
(paren
id|base
comma
id|EXT_PORT_DDR
comma
id|LED_OFF
)paren
suffix:semicolon
id|nsp32_index_write1
c_func
(paren
id|base
comma
id|EXT_PORT
comma
id|LED_OFF
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/* interrupt routine */
DECL|function|do_nsp32_isr
r_static
id|irqreturn_t
id|do_nsp32_isr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
id|dev_id
suffix:semicolon
r_int
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
op_assign
id|data-&gt;CurrentSC
suffix:semicolon
r_int
r_int
id|auto_stat
comma
id|irq_stat
comma
id|trans_stat
suffix:semicolon
r_int
r_char
id|busmon
comma
id|busphase
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|handled
op_assign
l_int|0
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,5,0)
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|data-&gt;Host
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#else
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * IRQ check, then enable IRQ mask&n;&t; */
id|irq_stat
op_assign
id|nsp32_read2
c_func
(paren
id|base
comma
id|IRQ_STATUS
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;enter IRQ: %d, IRQstatus: 0x%x&quot;
comma
id|irq
comma
id|irq_stat
)paren
suffix:semicolon
multiline_comment|/* is this interrupt comes from Ninja asic? */
r_if
c_cond
(paren
(paren
id|irq_stat
op_amp
id|IRQSTATUS_ANY_IRQ
)paren
op_eq
l_int|0
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;spurious interrupt: irq other 0x%x&quot;
comma
id|irq_stat
)paren
suffix:semicolon
r_goto
id|out2
suffix:semicolon
)brace
id|handled
op_assign
l_int|1
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|IRQ_CONTROL
comma
id|IRQ_CONTROL_ALL_IRQ_MASK
)paren
suffix:semicolon
id|busmon
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_BUS_MONITOR
)paren
suffix:semicolon
id|busphase
op_assign
id|busmon
op_amp
id|BUSMON_PHASE_MASK
suffix:semicolon
id|trans_stat
op_assign
id|nsp32_read2
c_func
(paren
id|base
comma
id|TRANSFER_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|irq_stat
op_eq
l_int|0xffff
)paren
op_logical_and
(paren
id|trans_stat
op_eq
l_int|0xffff
)paren
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;card disconnect&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;CurrentSC
op_ne
l_int|NULL
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;clean up current SCSI command&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
id|nsp32_scsi_done
c_func
(paren
id|data
comma
id|SCpnt
)paren
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Timer IRQ */
r_if
c_cond
(paren
id|irq_stat
op_amp
id|IRQSTATUS_TIMER_IRQ
)paren
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;timer stop&bslash;n&quot;
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|TIMER_SET
comma
id|TIMER_STOP
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* SCSI reset */
r_if
c_cond
(paren
id|irq_stat
op_amp
id|IRQSTATUS_SCSIRESET_IRQ
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;detected someone do bus reset&quot;
)paren
suffix:semicolon
id|nsp32_do_bus_reset
c_func
(paren
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt
op_ne
l_int|NULL
)paren
(brace
id|SCpnt-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
id|nsp32_scsi_done
c_func
(paren
id|data
comma
id|SCpnt
)paren
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt
op_eq
l_int|NULL
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;SCpnt==NULL this can&squot;t be happen&bslash;n&quot;
)paren
suffix:semicolon
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;irq_stat=0x%x trans_stat=0x%x&bslash;n&quot;
comma
id|irq_stat
comma
id|trans_stat
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * AutoSCSI Interrupt.&n;&t; * Note: This interrupt is occurred when AutoSCSI is finished.  Then&n;&t; * check SCSIEXECUTEPHASE, and do appropriate action.  Each phases are&n;&t; * recorded when AutoSCSI sequencer has been processed.&n;&t; */
r_if
c_cond
(paren
id|irq_stat
op_amp
id|IRQSTATUS_AUTOSCSI_IRQ
)paren
(brace
multiline_comment|/* getting SCSI executed phase */
id|auto_stat
op_assign
id|nsp32_read2
c_func
(paren
id|base
comma
id|SCSI_EXECUTE_PHASE
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|SCSI_EXECUTE_PHASE
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Selection Timeout, go busfree phase. */
r_if
c_cond
(paren
id|auto_stat
op_amp
id|SELECTION_TIMEOUT
)paren
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;selection timeout occurred&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_TIME_OUT
op_lshift
l_int|16
suffix:semicolon
id|nsp32_scsi_done
c_func
(paren
id|data
comma
id|SCpnt
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|auto_stat
op_amp
id|MSGOUT_PHASE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * MsgOut phase was processed.&n;&t;&t;&t; * If MSG_IN_OCCUER is not set, then MsgOut phase is&n;&t;&t;&t; * completed. Thus, msgoutlen must reset.  Otherwise,&n;&t;&t;&t; * nothing to do here. If MSG_OUT_OCCUER is occurred,&n;&t;&t;&t; * then we will encounter the condition and check.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|auto_stat
op_amp
id|MSG_IN_OCCUER
)paren
op_logical_and
(paren
id|data-&gt;msgoutlen
op_le
l_int|3
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * !MSG_IN_OCCUER &amp;&amp; msgoutlen &lt;=3&n;&t;&t;&t;&t; *   ---&gt; AutoSCSI with MSGOUTreg is processed.&n;&t;&t;&t;&t; */
id|data-&gt;msgoutlen
op_assign
l_int|0
suffix:semicolon
)brace
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;MsgOut phase processed&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|auto_stat
op_amp
id|DATA_IN_PHASE
)paren
op_logical_and
(paren
id|SCpnt-&gt;resid
OG
l_int|0
)paren
op_logical_and
(paren
(paren
id|nsp32_read2
c_func
(paren
id|base
comma
id|FIFO_REST_CNT
)paren
op_amp
id|FIFO_REST_MASK
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;auto+fifo&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|//nsp32_pio_read(SCpnt);
)brace
r_if
c_cond
(paren
id|auto_stat
op_amp
(paren
id|DATA_IN_PHASE
op_or
id|DATA_OUT_PHASE
)paren
)paren
(brace
multiline_comment|/* DATA_IN_PHASE/DATA_OUT_PHASE was processed. */
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;Data in/out phase processed&quot;
)paren
suffix:semicolon
multiline_comment|/* read BMCNT, SGT pointer addr */
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;BMCNT=0x%lx&quot;
comma
id|nsp32_read4
c_func
(paren
id|base
comma
id|BM_CNT
)paren
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;addr=0x%lx&quot;
comma
id|nsp32_read4
c_func
(paren
id|base
comma
id|SGT_ADR
)paren
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;SACK=0x%lx&quot;
comma
id|nsp32_read4
c_func
(paren
id|base
comma
id|SACK_CNT
)paren
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;SSACK=0x%lx&quot;
comma
id|nsp32_read4
c_func
(paren
id|base
comma
id|SAVED_SACK_CNT
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * MsgIn Occur&n;&t;&t; */
r_if
c_cond
(paren
id|auto_stat
op_amp
id|MSG_IN_OCCUER
)paren
(brace
id|nsp32_msgin_occur
c_func
(paren
id|data
comma
id|irq_stat
comma
id|auto_stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * MsgOut Occur&n;&t;&t; */
r_if
c_cond
(paren
id|auto_stat
op_amp
id|MSG_OUT_OCCUER
)paren
(brace
id|nsp32_msgout_occur
c_func
(paren
id|data
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Bus Free Occur&n;&t;&t; */
r_if
c_cond
(paren
id|auto_stat
op_amp
id|BUS_FREE_OCCUER
)paren
(brace
id|ret
op_assign
id|nsp32_busfree_occur
c_func
(paren
id|data
comma
id|auto_stat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|TRUE
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|auto_stat
op_amp
id|STATUS_PHASE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Read CSB and substitute CSB for SCpnt-&gt;result&n;&t;&t;&t; * to save status phase stutas byte.&n;&t;&t;&t; * scsi error handler checks host_byte (DID_*:&n;&t;&t;&t; * low level driver to indicate status), then checks &n;&t;&t;&t; * status_byte (SCSI status byte).&n;&t;&t;&t; */
id|SCpnt-&gt;result
op_assign
(paren
r_int
)paren
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_CSB_IN
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|auto_stat
op_amp
id|ILLEGAL_PHASE
)paren
(brace
multiline_comment|/* Illegal phase is detected. SACK is not back. */
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;AUTO SCSI ILLEGAL PHASE OCCUR!!!!&quot;
)paren
suffix:semicolon
multiline_comment|/* TODO: currently we don&squot;t have any action... bus reset? */
multiline_comment|/*&n;&t;&t;&t; * To send back SACK, assert, wait, and negate.&n;&t;&t;&t; */
id|nsp32_sack_assert
c_func
(paren
id|data
)paren
suffix:semicolon
id|nsp32_wait_req
c_func
(paren
id|data
comma
id|NEGATE
)paren
suffix:semicolon
id|nsp32_sack_negate
c_func
(paren
id|data
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|auto_stat
op_amp
id|COMMAND_PHASE
)paren
(brace
multiline_comment|/* nothing to do */
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;Command phase processed&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|auto_stat
op_amp
id|AUTOSCSI_BUSY
)paren
(brace
multiline_comment|/* AutoSCSI is running */
)brace
id|show_autophase
c_func
(paren
id|auto_stat
)paren
suffix:semicolon
)brace
multiline_comment|/* FIFO_SHLD_IRQ */
r_if
c_cond
(paren
id|irq_stat
op_amp
id|IRQSTATUS_FIFO_SHLD_IRQ
)paren
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;FIFO IRQ&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|busphase
)paren
(brace
r_case
id|BUSPHASE_DATA_OUT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;write&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|//nsp32_pio_write(SCpnt);
r_break
suffix:semicolon
r_case
id|BUSPHASE_DATA_IN
suffix:colon
id|printk
c_func
(paren
l_string|&quot;read&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|//nsp32_pio_read(SCpnt);
r_break
suffix:semicolon
r_case
id|BUSPHASE_STATUS
suffix:colon
singleline_comment|//DEBUG(0, &quot;fifo/status&bslash;n&quot;);
id|SCpnt-&gt;SCp.Status
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_CSB_IN
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;fifo/other phase?&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;irq_stat=0x%x trans_stat=0x%x&bslash;n&quot;
comma
id|irq_stat
comma
id|trans_stat
)paren
suffix:semicolon
id|show_busphase
c_func
(paren
id|busphase
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Phase Change IRQ */
r_if
c_cond
(paren
id|irq_stat
op_amp
id|IRQSTATUS_PHASE_CHANGE_IRQ
)paren
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;phase change IRQ&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|busphase
)paren
(brace
r_case
id|BUSPHASE_MESSAGE_IN
suffix:colon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;phase chg/msg in&quot;
)paren
suffix:semicolon
id|nsp32_msgin_occur
c_func
(paren
id|data
comma
id|irq_stat
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;phase chg/other phase?&quot;
)paren
suffix:semicolon
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;irq_stat=0x%x trans_stat=0x%x&bslash;n&quot;
comma
id|irq_stat
comma
id|trans_stat
)paren
suffix:semicolon
id|show_busphase
c_func
(paren
id|busphase
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* PCI_IRQ */
r_if
c_cond
(paren
id|irq_stat
op_amp
id|IRQSTATUS_PCI_IRQ
)paren
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;PCI IRQ occurred&quot;
)paren
suffix:semicolon
multiline_comment|/* Do nothing */
)brace
multiline_comment|/* BMCNTERR_IRQ */
r_if
c_cond
(paren
id|irq_stat
op_amp
id|IRQSTATUS_BMCNTERR_IRQ
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;Received unexpected BMCNTERR IRQ! &quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * TODO: To be implemented improving bus master&n;&t;&t; * transfer reliablity when BMCNTERR is occurred in&n;&t;&t; * AutoSCSI phase described in specification.&n;&t;&t; */
)brace
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;irq_stat=0x%x trans_stat=0x%x&bslash;n&quot;
comma
id|irq_stat
comma
id|trans_stat
)paren
suffix:semicolon
id|show_busphase
c_func
(paren
id|busphase
)paren
suffix:semicolon
macro_line|#endif
id|out
suffix:colon
multiline_comment|/* disable IRQ mask */
id|nsp32_write2
c_func
(paren
id|base
comma
id|IRQ_CONTROL
comma
l_int|0
)paren
suffix:semicolon
id|out2
suffix:colon
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,0)
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#else
id|spin_unlock_irqrestore
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#endif
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_INTR
comma
l_string|&quot;exit&quot;
)paren
suffix:semicolon
r_return
id|IRQ_RETVAL
c_func
(paren
id|handled
)paren
suffix:semicolon
)brace
DECL|macro|SPRINTF
macro_line|#undef SPRINTF
DECL|macro|SPRINTF
mdefine_line|#define SPRINTF(args...) &bslash;&n;        do { if(pos &lt; buffer + length) pos += sprintf(pos, ## args); } while(0)
DECL|function|nsp32_proc_info
r_static
r_int
id|nsp32_proc_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|inout
)paren
(brace
r_char
op_star
id|pos
op_assign
id|buffer
suffix:semicolon
r_int
id|thislength
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|nsp32_hw_data
op_star
id|data
suffix:semicolon
r_int
r_int
id|base
suffix:semicolon
r_int
r_char
id|mode_reg
suffix:semicolon
multiline_comment|/* Write is not supported, just return. */
r_if
c_cond
(paren
id|inout
op_eq
id|TRUE
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|base
op_assign
id|host-&gt;io_port
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;NinjaSCSI-32 status&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;Driver version:        %s&bslash;n&quot;
comma
id|nsp32_release_version
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;SCSI host No.:         %d&bslash;n&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;IRQ:                   %d&bslash;n&quot;
comma
id|host-&gt;irq
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;IO:                    0x%lx-0x%lx&bslash;n&quot;
comma
id|host-&gt;io_port
comma
id|host-&gt;io_port
op_plus
id|host-&gt;n_io_port
op_minus
l_int|1
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;MMIO(virtual address): 0x%lx&bslash;n&quot;
comma
id|host-&gt;base
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;sg_tablesize:          %d&bslash;n&quot;
comma
id|host-&gt;sg_tablesize
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;Chip revision:         %d&bslash;n&quot;
comma
(paren
id|nsp32_read2
c_func
(paren
id|base
comma
id|INDEX_REG
)paren
op_rshift
l_int|8
)paren
op_minus
l_int|0x4f
)paren
suffix:semicolon
id|mode_reg
op_assign
id|nsp32_index_read1
c_func
(paren
id|base
comma
id|CHIP_MODE
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PM
singleline_comment|//SPRINTF(&quot;Power Management:      %s&bslash;n&quot;,          (mode_reg &amp; OPTF) ? &quot;yes&quot; : &quot;no&quot;);
macro_line|#endif
id|SPRINTF
c_func
(paren
l_string|&quot;OEM:                   %s&bslash;n&quot;
comma
id|nsp32_model
(braket
id|mode_reg
op_amp
(paren
id|OEM0
op_or
id|OEM1
)paren
)braket
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|data-&gt;Lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;CurrentSC:             0x%p&bslash;n&bslash;n&quot;
comma
id|data-&gt;CurrentSC
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|data-&gt;Lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|thislength
op_assign
id|pos
op_minus
(paren
id|buffer
op_plus
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|thislength
OL
l_int|0
)paren
(brace
op_star
id|start
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|thislength
op_assign
id|MIN
c_func
(paren
id|thislength
comma
id|length
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|offset
suffix:semicolon
r_return
id|thislength
suffix:semicolon
)brace
DECL|macro|SPRINTF
macro_line|#undef SPRINTF
multiline_comment|/*&n; * Note: n_io_port is defined as 0x7f because I/O register port is&n; *&t; assigned as:&n; *&t;0x800-0x8ff: memory mapped I/O port&n; *&t;0x900-0xbff: (map same 0x800-0x8ff I/O port image repeatedly)&n; *&t;0xc00-0xfff: CardBus status registers&n; */
DECL|function|nsp32_detect
r_static
r_int
id|nsp32_detect
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
multiline_comment|/* registered host structure */
r_int
id|ret
suffix:semicolon
id|nsp32_hw_data
op_star
id|data
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_REGISTER
comma
l_string|&quot;enter&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * register this HBA as SCSI device&n;&t; */
id|host
op_assign
id|scsi_host_alloc
c_func
(paren
op_amp
id|nsp32_template
comma
r_sizeof
(paren
id|nsp32_hw_data
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|host
op_eq
l_int|NULL
)paren
(brace
id|nsp32_msg
(paren
id|KERN_ERR
comma
l_string|&quot;failed to scsi register&quot;
)paren
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * set nsp32_hw_data&n;&t; */
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|memset
c_func
(paren
id|data
comma
l_int|0
comma
r_sizeof
(paren
id|nsp32_hw_data
)paren
)paren
suffix:semicolon
id|data-&gt;IrqNumber
op_assign
id|nsp32_data_base.IrqNumber
suffix:semicolon
id|data-&gt;BaseAddress
op_assign
id|nsp32_data_base.BaseAddress
suffix:semicolon
id|data-&gt;NumAddress
op_assign
id|nsp32_data_base.NumAddress
suffix:semicolon
id|data-&gt;MmioAddress
op_assign
id|nsp32_data_base.MmioAddress
suffix:semicolon
id|data-&gt;Pci
op_assign
id|nsp32_data_base.Pci
suffix:semicolon
id|data-&gt;pci_devid
op_assign
id|nsp32_data_base.pci_devid
suffix:semicolon
id|host-&gt;irq
op_assign
id|data-&gt;IrqNumber
suffix:semicolon
id|host-&gt;io_port
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
id|host-&gt;unique_id
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
id|host-&gt;n_io_port
op_assign
id|data-&gt;NumAddress
suffix:semicolon
id|host-&gt;base
op_assign
id|data-&gt;MmioAddress
suffix:semicolon
id|scsi_set_device
c_func
(paren
id|host
comma
op_amp
id|data-&gt;Pci-&gt;dev
)paren
suffix:semicolon
id|data-&gt;Host
op_assign
id|host
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|data-&gt;Lock
)paren
)paren
suffix:semicolon
id|data-&gt;curlunt
op_assign
l_int|NULL
suffix:semicolon
id|data-&gt;curtarget
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Bus master transfer mode is supported currently.&n;&t; */
id|data-&gt;trans_method
op_assign
id|NSP32_TRANSFER_BUSMASTER
suffix:semicolon
multiline_comment|/*&n;&t; * Set clock div, CLOCK_4 (HBA has external clock, and&n;&t; * dividing * 100ns/4).&n;&t; * Currently CLOCK_4 has only tested, not for CLOCK_2/PCICLK yet.&n;&t; */
id|data-&gt;clock
op_assign
id|CLOCK_4
suffix:semicolon
multiline_comment|/*&n;&t; * Select appropriate nsp32_sync_table and set I_CLOCKDIV.&n;&t; */
r_switch
c_cond
(paren
id|data-&gt;clock
)paren
(brace
r_case
id|CLOCK_4
suffix:colon
multiline_comment|/* If data-&gt;clock is CLOCK_4, then select 40M sync table. */
id|data-&gt;synct
op_assign
id|nsp32_sync_table_40M
suffix:semicolon
id|data-&gt;syncnum
op_assign
id|nsp32_table_40M_num
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CLOCK_2
suffix:colon
multiline_comment|/* If data-&gt;clock is CLOCK_2, then select 20M sync table. */
id|data-&gt;synct
op_assign
id|nsp32_sync_table_20M
suffix:semicolon
id|data-&gt;syncnum
op_assign
id|nsp32_table_20M_num
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCICLK
suffix:colon
multiline_comment|/* If data-&gt;clock is PCICLK, then select pci sync table. */
id|data-&gt;synct
op_assign
id|nsp32_sync_table_pci
suffix:semicolon
id|data-&gt;syncnum
op_assign
id|nsp32_table_pci_num
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;Invalid clock div is selected, set CLOCK_4.&quot;
)paren
suffix:semicolon
multiline_comment|/* Use default value CLOCK_4 */
id|data-&gt;clock
op_assign
id|CLOCK_4
suffix:semicolon
id|data-&gt;synct
op_assign
id|nsp32_sync_table_40M
suffix:semicolon
id|data-&gt;syncnum
op_assign
id|nsp32_table_40M_num
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * setup nsp32_lunt&n;&t; */
id|data-&gt;lunt_list
op_assign
(paren
r_struct
id|nsp32_lunt
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|nsp32_lunt
)paren
op_star
id|MAX_TARGET
op_star
id|MAX_LUN
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;lunt_list
op_eq
l_int|NULL
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;cannot allocate LUN memory&quot;
)paren
suffix:semicolon
r_goto
id|scsi_unregister
suffix:semicolon
)brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_REGISTER
comma
l_string|&quot;0x%x 0x%x&quot;
comma
id|data-&gt;lunt_list
comma
r_sizeof
(paren
r_struct
id|nsp32_lunt
)paren
op_star
id|MAX_TARGET
op_star
id|MAX_LUN
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * setup DMA &n;&t; */
r_if
c_cond
(paren
id|pci_set_dma_mask
c_func
(paren
id|data-&gt;Pci
comma
l_int|0xffffffffUL
)paren
)paren
(brace
id|nsp32_msg
(paren
id|KERN_ERR
comma
l_string|&quot;failed to set PCI DMA mask&quot;
)paren
suffix:semicolon
r_goto
id|kfree_lunt
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * allocate autoparam DMA resource.&n;&t; */
id|data-&gt;autoparam
op_assign
id|pci_alloc_consistent
c_func
(paren
id|data-&gt;Pci
comma
id|AUTOPARAM_SIZE
comma
op_amp
id|data-&gt;apaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;autoparam
op_eq
l_int|NULL
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;failed to allocate DMA memory&quot;
)paren
suffix:semicolon
r_goto
id|kfree_lunt
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * allocate scatter-gather DMA resource.&n;&t; */
id|data-&gt;sg_list
op_assign
id|pci_alloc_consistent
c_func
(paren
id|data-&gt;Pci
comma
(paren
r_sizeof
(paren
r_struct
id|nsp32_sgtable
)paren
op_star
id|NSP_SG_SIZE
op_star
id|MAX_TARGET
op_star
id|MAX_LUN
)paren
comma
op_amp
id|data-&gt;sgaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;sg_list
op_eq
l_int|NULL
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;failed to allocate DMA memory&quot;
)paren
suffix:semicolon
r_goto
id|free_autoparam
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TARGET
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|MAX_LUN
suffix:semicolon
id|j
op_increment
)paren
(brace
id|data-&gt;lunt
(braket
id|i
)braket
(braket
id|j
)braket
op_assign
id|data-&gt;lunt_list
op_plus
(paren
id|i
op_star
id|MAX_LUN
op_plus
id|j
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TARGET
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|MAX_LUN
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|nsp32_lunt
op_star
id|lp
op_assign
id|data-&gt;lunt
(braket
id|i
)braket
(braket
id|j
)braket
suffix:semicolon
id|lp-&gt;sglun
op_assign
(paren
r_struct
id|nsp32_sglun
op_star
)paren
(paren
id|data-&gt;sg_list
op_plus
(paren
id|i
op_star
id|MAX_LUN
op_plus
id|j
)paren
)paren
suffix:semicolon
id|lp-&gt;sglun_paddr
op_assign
id|data-&gt;sgaddr
op_plus
(paren
r_int
)paren
(paren
(paren
id|i
op_star
id|MAX_LUN
op_plus
id|j
)paren
op_star
r_sizeof
(paren
r_struct
id|nsp32_sglun
)paren
)paren
suffix:semicolon
id|lp-&gt;SCpnt
op_assign
l_int|NULL
suffix:semicolon
id|lp-&gt;save_datp
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;msgin03
op_assign
id|FALSE
suffix:semicolon
id|lp-&gt;sg_num
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;cur_entry
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * setup target&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TARGET
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|nsp32_target
op_star
id|target
op_assign
op_amp
id|data-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|target-&gt;limit_entry
op_assign
l_int|0
suffix:semicolon
id|target-&gt;sync_flag
op_assign
l_int|0
suffix:semicolon
id|nsp32_set_async
c_func
(paren
id|data
comma
id|target
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * EEPROM check&n;&t; */
id|ret
op_assign
id|nsp32_getprom_param
c_func
(paren
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|FALSE
)paren
(brace
id|data-&gt;resettime
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* default 3 */
)brace
multiline_comment|/*&n;&t; * setup HBA&n;&t; */
id|nsp32hw_init
c_func
(paren
id|host
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|data-&gt;info_str
comma
r_sizeof
(paren
id|data-&gt;info_str
)paren
comma
l_string|&quot;NinjaSCSI-32Bi/UDE: irq %d, io 0x%lx+0x%x&quot;
comma
id|host-&gt;irq
comma
id|host-&gt;io_port
comma
id|host-&gt;n_io_port
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * SCSI bus reset&n;&t; *&n;&t; * Note: It&squot;s important to reset SCSI bus in initialization phase.&n;&t; *     NinjaSCSI-32Bi/UDE HBA EEPROM seems to exchange SDTR when system is&n;&t; *     coming up, so SCSI devices connected to HBA is set as&n;&t; *     un-asynchronous mode.  It brings the merit that this HBA is&n;&t; *     ready to start synchronous transfer without any preparation,&n;&t; *     but we are difficult to control transfer speed.  In addition,&n;&t; *     it prevents device transfer speed from effecting EEPROM start-up&n;&t; *     SDTR.  NinjaSCSI-32Bi/UDE has the feature if EEPROM is set as Auto&n;&t; *     Mode, then FAST-10M is selected when SCSI devices are connected&n;&t; *     same or more than 4 devices.  It should be avoided depending on&n;&t; *     this specification Thus, resetting the SCSI bus restores all&n;&t; *     connected SCSI devices to asynchronous mode, then this driver&n;&t; *     put SDTR safely later, and we can control all SCSI device&n;&t; *     transfer mode.&n;&t; */
id|nsp32_do_bus_reset
c_func
(paren
id|data
)paren
suffix:semicolon
id|ret
op_assign
id|request_irq
c_func
(paren
id|host-&gt;irq
comma
id|do_nsp32_isr
comma
id|SA_SHIRQ
comma
l_string|&quot;nsp32&quot;
comma
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;Unable to allocate IRQ for NSP32 &quot;
l_string|&quot;SCSI PCI controller. Interrupt: %d&bslash;n&quot;
comma
id|host-&gt;irq
)paren
suffix:semicolon
r_goto
id|free_sg_list
suffix:semicolon
)brace
multiline_comment|/*&n;         * PCI IO register&n;         */
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|host-&gt;io_port
comma
id|host-&gt;n_io_port
comma
l_string|&quot;nsp32&quot;
)paren
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;I/O region 0x%lx+0x%lx is already used&quot;
comma
id|data-&gt;BaseAddress
comma
id|data-&gt;length
)paren
suffix:semicolon
r_goto
id|free_irq
suffix:semicolon
)brace
id|scsi_add_host
c_func
(paren
id|host
comma
op_amp
id|pdev-&gt;dev
)paren
suffix:semicolon
multiline_comment|/* XXX handle failure */
id|scsi_scan_host
c_func
(paren
id|host
)paren
suffix:semicolon
id|pci_set_drvdata
c_func
(paren
id|pdev
comma
id|host
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|free_irq
suffix:colon
id|free_irq
c_func
(paren
id|host-&gt;irq
comma
id|data
)paren
suffix:semicolon
id|free_autoparam
suffix:colon
id|pci_free_consistent
c_func
(paren
id|data-&gt;Pci
comma
id|AUTOPARAM_SIZE
comma
id|data-&gt;autoparam
comma
id|data-&gt;apaddr
)paren
suffix:semicolon
id|free_sg_list
suffix:colon
id|pci_free_consistent
c_func
(paren
id|data-&gt;Pci
comma
(paren
r_sizeof
(paren
r_struct
id|nsp32_sgtable
)paren
op_star
id|NSP_SG_SIZE
op_star
id|MAX_TARGET
op_star
id|MAX_LUN
)paren
comma
id|data-&gt;sg_list
comma
id|data-&gt;sgaddr
)paren
suffix:semicolon
id|kfree_lunt
suffix:colon
id|kfree
c_func
(paren
id|data-&gt;lunt_list
)paren
suffix:semicolon
id|scsi_unregister
suffix:colon
id|scsi_host_put
c_func
(paren
id|host
)paren
suffix:semicolon
id|err
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|nsp32_info
r_static
r_const
r_char
op_star
id|nsp32_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|shpnt-&gt;hostdata
suffix:semicolon
r_return
id|data-&gt;info_str
suffix:semicolon
)brace
DECL|function|nsp32_eh_abort
r_static
r_int
id|nsp32_eh_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|SCpnt-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;abort&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;curlunt-&gt;SCpnt
op_eq
l_int|NULL
)paren
(brace
r_return
(paren
id|FAILED
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|data-&gt;curtarget-&gt;sync_flag
op_amp
(paren
id|SDTR_INITIATOR
op_or
id|SDTR_TARGET
)paren
)paren
(brace
multiline_comment|/* reset SDTR negotiation */
id|data-&gt;curtarget-&gt;sync_flag
op_assign
l_int|0
suffix:semicolon
)brace
id|nsp32_write2
c_func
(paren
id|base
comma
id|TRANSFER_CONTROL
comma
l_int|0
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|BM_CNT
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|FAILED
)paren
suffix:semicolon
)brace
DECL|function|nsp32_eh_bus_reset
r_static
r_int
id|nsp32_eh_bus_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|SCpnt-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;Bus Reset&quot;
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_BUSRESET
comma
l_string|&quot;SCpnt=0x%x&quot;
comma
id|SCpnt
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|IRQ_CONTROL
comma
id|IRQ_CONTROL_ALL_IRQ_MASK
)paren
suffix:semicolon
id|nsp32_do_bus_reset
c_func
(paren
id|data
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|IRQ_CONTROL
comma
l_int|0
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
multiline_comment|/* SCSI bus reset is succeeded at any time. */
)brace
DECL|function|nsp32_do_bus_reset
r_static
r_void
id|nsp32_do_bus_reset
c_func
(paren
id|nsp32_hw_data
op_star
id|data
)paren
(brace
r_int
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
r_int
r_int
id|intrdat
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * stop all transfer&n;&t; * clear TRANSFERCONTROL_BM_START&n;&t; * clear counter&n;&t; */
id|nsp32_write2
c_func
(paren
id|base
comma
id|TRANSFER_CONTROL
comma
l_int|0
)paren
suffix:semicolon
id|nsp32_write4
c_func
(paren
id|base
comma
id|BM_CNT
comma
l_int|0
)paren
suffix:semicolon
id|nsp32_write4
c_func
(paren
id|base
comma
id|CLR_COUNTER
comma
id|CLRCOUNTER_ALLMASK
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * fall back to asynchronous transfer mode&n;&t; * initialize SDTR negotiation flag&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TARGET
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|nsp32_target
op_star
id|target
op_assign
op_amp
id|data-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|target-&gt;sync_flag
op_assign
l_int|0
suffix:semicolon
id|nsp32_set_async
c_func
(paren
id|data
comma
id|target
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * reset SCSI bus&n;&t; */
id|nsp32_write1
c_func
(paren
id|base
comma
id|SCSI_BUS_CONTROL
comma
id|BUSCTL_RST
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|RESET_HOLD_TIME
)paren
suffix:semicolon
id|nsp32_write1
c_func
(paren
id|base
comma
id|SCSI_BUS_CONTROL
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
(brace
id|intrdat
op_assign
id|nsp32_read2
c_func
(paren
id|base
comma
id|IRQ_STATUS
)paren
suffix:semicolon
multiline_comment|/* dummy read */
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_BUSRESET
comma
l_string|&quot;irq:1: 0x%x&quot;
comma
id|intrdat
)paren
suffix:semicolon
)brace
id|data-&gt;CurrentSC
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|nsp32_eh_host_reset
r_static
r_int
id|nsp32_eh_host_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|SCpnt-&gt;device-&gt;host
suffix:semicolon
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
r_int
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;Host Reset&quot;
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_BUSRESET
comma
l_string|&quot;SCpnt=0x%x&quot;
comma
id|SCpnt
)paren
suffix:semicolon
id|nsp32hw_init
c_func
(paren
id|host
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|IRQ_CONTROL
comma
id|IRQ_CONTROL_ALL_IRQ_MASK
)paren
suffix:semicolon
id|nsp32_do_bus_reset
c_func
(paren
id|data
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|IRQ_CONTROL
comma
l_int|0
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
multiline_comment|/* Host reset is succeeded at any time. */
)brace
multiline_comment|/*&n; * PCI/Cardbus probe/remove routine&n; */
DECL|function|nsp32_probe
r_static
r_int
id|__devinit
id|nsp32_probe
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_const
r_struct
id|pci_device_id
op_star
id|id
)paren
(brace
r_int
id|ret
suffix:semicolon
id|nsp32_hw_data
op_star
id|data
op_assign
op_amp
id|nsp32_data_base
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_REGISTER
comma
l_string|&quot;enter&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|pci_enable_device
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;failed to enable pci device&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|data-&gt;Pci
op_assign
id|pdev
suffix:semicolon
id|data-&gt;pci_devid
op_assign
id|id
suffix:semicolon
id|data-&gt;IrqNumber
op_assign
id|pdev-&gt;irq
suffix:semicolon
id|data-&gt;BaseAddress
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
id|data-&gt;NumAddress
op_assign
id|pci_resource_len
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
id|data-&gt;MmioAddress
op_assign
(paren
r_int
r_int
)paren
id|ioremap_nocache
c_func
(paren
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|1
)paren
comma
id|pci_resource_len
c_func
(paren
id|pdev
comma
l_int|1
)paren
)paren
suffix:semicolon
id|pci_set_master
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|ret
op_assign
id|nsp32_detect
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;nsp32 irq: %i mmio: 0x%lx slot: %s model: %s&quot;
comma
id|pdev-&gt;irq
comma
id|data-&gt;MmioAddress
comma
id|pdev-&gt;slot_name
comma
id|nsp32_model
(braket
id|id-&gt;driver_data
)braket
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_REGISTER
comma
l_string|&quot;exit&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|nsp32_remove
r_static
r_void
id|__devexit
id|nsp32_remove
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shpnt
op_assign
id|pci_get_drvdata
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|nsp32_hw_data
op_star
id|data
op_assign
(paren
id|nsp32_hw_data
op_star
)paren
id|shpnt-&gt;hostdata
suffix:semicolon
id|kfree
c_func
(paren
id|data-&gt;lunt_list
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|data-&gt;Pci
comma
id|AUTOPARAM_SIZE
comma
id|data-&gt;autoparam
comma
id|data-&gt;apaddr
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|data-&gt;Pci
comma
(paren
r_sizeof
(paren
r_struct
id|nsp32_sgtable
)paren
op_star
id|NSP_SG_SIZE
op_star
id|MAX_TARGET
op_star
id|MAX_LUN
)paren
comma
id|data-&gt;sg_list
comma
id|data-&gt;sgaddr
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|shpnt-&gt;irq
comma
id|data
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|shpnt-&gt;io_port
comma
id|shpnt-&gt;n_io_port
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|data-&gt;MmioAddress
)paren
)paren
suffix:semicolon
)brace
DECL|variable|__devinitdata
r_static
r_struct
id|pci_device_id
id|nsp32_pci_table
(braket
)braket
id|__devinitdata
op_assign
(brace
(brace
dot
id|vendor
op_assign
id|PCI_VENDOR_ID_IODATA
comma
dot
id|device
op_assign
id|PCI_DEVICE_ID_NINJASCSI_32BI_CBSC_II
comma
dot
id|subvendor
op_assign
id|PCI_ANY_ID
comma
dot
id|subdevice
op_assign
id|PCI_ANY_ID
comma
dot
id|driver_data
op_assign
id|MODEL_IODATA
comma
)brace
comma
(brace
dot
id|vendor
op_assign
id|PCI_VENDOR_ID_WORKBIT
comma
dot
id|device
op_assign
id|PCI_DEVICE_ID_NINJASCSI_32BI_KME
comma
dot
id|subvendor
op_assign
id|PCI_ANY_ID
comma
dot
id|subdevice
op_assign
id|PCI_ANY_ID
comma
dot
id|driver_data
op_assign
id|MODEL_KME
comma
)brace
comma
(brace
dot
id|vendor
op_assign
id|PCI_VENDOR_ID_WORKBIT
comma
dot
id|device
op_assign
id|PCI_DEVICE_ID_NINJASCSI_32BI_WBT
comma
dot
id|subvendor
op_assign
id|PCI_ANY_ID
comma
dot
id|subdevice
op_assign
id|PCI_ANY_ID
comma
dot
id|driver_data
op_assign
id|MODEL_WORKBIT
comma
)brace
comma
(brace
dot
id|vendor
op_assign
id|PCI_VENDOR_ID_WORKBIT
comma
dot
id|device
op_assign
id|PCI_DEVICE_ID_WORKBIT_STANDARD
comma
dot
id|subvendor
op_assign
id|PCI_ANY_ID
comma
dot
id|subdevice
op_assign
id|PCI_ANY_ID
comma
dot
id|driver_data
op_assign
id|MODEL_PCI_WORKBIT
comma
)brace
comma
(brace
dot
id|vendor
op_assign
id|PCI_VENDOR_ID_WORKBIT
comma
dot
id|device
op_assign
id|PCI_DEVICE_ID_NINJASCSI_32BI_LOGITEC
comma
dot
id|subvendor
op_assign
id|PCI_ANY_ID
comma
dot
id|subdevice
op_assign
id|PCI_ANY_ID
comma
dot
id|driver_data
op_assign
id|MODEL_EXT_ROM
comma
)brace
comma
(brace
dot
id|vendor
op_assign
id|PCI_VENDOR_ID_WORKBIT
comma
dot
id|device
op_assign
id|PCI_DEVICE_ID_NINJASCSI_32BIB_LOGITEC
comma
dot
id|subvendor
op_assign
id|PCI_ANY_ID
comma
dot
id|subdevice
op_assign
id|PCI_ANY_ID
comma
dot
id|driver_data
op_assign
id|MODEL_PCI_LOGITEC
comma
)brace
comma
(brace
dot
id|vendor
op_assign
id|PCI_VENDOR_ID_WORKBIT
comma
dot
id|device
op_assign
id|PCI_DEVICE_ID_NINJASCSI_32UDE_MELCO
comma
dot
id|subvendor
op_assign
id|PCI_ANY_ID
comma
dot
id|subdevice
op_assign
id|PCI_ANY_ID
comma
dot
id|driver_data
op_assign
id|MODEL_PCI_MELCO
comma
)brace
comma
(brace
l_int|0
comma
l_int|0
comma
)brace
comma
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|pci
comma
id|nsp32_pci_table
)paren
suffix:semicolon
DECL|variable|nsp32_driver
r_static
r_struct
id|pci_driver
id|nsp32_driver
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;nsp32&quot;
comma
dot
id|id_table
op_assign
id|nsp32_pci_table
comma
dot
id|probe
op_assign
id|nsp32_probe
comma
dot
id|remove
op_assign
id|nsp32_remove
comma
macro_line|#ifdef CONFIG_PM
multiline_comment|/*&t;.suspend =&t;nsp32_suspend,*/
multiline_comment|/*&t;.resume =&t;nsp32_resume,*/
macro_line|#endif
)brace
suffix:semicolon
DECL|function|init_nsp32
r_static
r_int
id|__init
id|init_nsp32
c_func
(paren
r_void
)paren
(brace
r_return
id|pci_module_init
c_func
(paren
op_amp
id|nsp32_driver
)paren
suffix:semicolon
)brace
DECL|function|exit_nsp32
r_static
r_void
id|__exit
id|exit_nsp32
c_func
(paren
r_void
)paren
(brace
id|pci_unregister_driver
c_func
(paren
op_amp
id|nsp32_driver
)paren
suffix:semicolon
)brace
DECL|variable|init_nsp32
id|module_init
c_func
(paren
id|init_nsp32
)paren
suffix:semicolon
DECL|variable|exit_nsp32
id|module_exit
c_func
(paren
id|exit_nsp32
)paren
suffix:semicolon
multiline_comment|/*&n; * Reset parameters and call scsi_done for data-&gt;curlunt.&n; * Be careful setting SCpnt-&gt;result = DID_* before calling this function.&n; */
DECL|function|nsp32_scsi_done
r_static
r_void
id|nsp32_scsi_done
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
multiline_comment|/*&n;&t; * unmap pci&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;request_bufflen
op_eq
l_int|0
)paren
(brace
r_goto
id|skip
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
)paren
(brace
id|pci_unmap_sg
c_func
(paren
id|data-&gt;Pci
comma
(paren
r_struct
id|scatterlist
op_star
)paren
id|SCpnt-&gt;buffer
comma
id|SCpnt-&gt;use_sg
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|SCpnt-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pci_unmap_single
c_func
(paren
id|data-&gt;Pci
comma
(paren
id|u32
)paren
id|SCpnt-&gt;SCp.have_data_in
comma
id|SCpnt-&gt;request_bufflen
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|SCpnt-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
)brace
id|skip
suffix:colon
multiline_comment|/*&n;&t; * clear TRANSFERCONTROL_BM_START&n;&t; */
id|nsp32_write2
c_func
(paren
id|base
comma
id|TRANSFER_CONTROL
comma
l_int|0
)paren
suffix:semicolon
id|nsp32_write4
c_func
(paren
id|base
comma
id|BM_CNT
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * call scsi_done&n;&t; */
(paren
op_star
id|SCpnt-&gt;scsi_done
)paren
(paren
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * reset parameters&n;&t; */
id|data-&gt;curlunt-&gt;SCpnt
op_assign
l_int|NULL
suffix:semicolon
id|data-&gt;curlunt
op_assign
l_int|NULL
suffix:semicolon
id|data-&gt;curtarget
op_assign
l_int|NULL
suffix:semicolon
id|data-&gt;CurrentSC
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Bus Free Occur&n; *&n; * Current Phase is BUSFREE. AutoSCSI is automatically execute BUSFREE phase&n; * with ACK reply when below condition is matched:&n; *&t;MsgIn 00: Command Complete.&n; *&t;MsgIn 02: Save Data Pointer.&n; *&t;MsgIn 04: Diconnect.&n; * In other case, unexpected BUSFREE is detected.&n; */
DECL|function|nsp32_busfree_occur
r_static
r_int
id|nsp32_busfree_occur
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
r_int
r_int
id|execph
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
op_assign
id|data-&gt;curlunt-&gt;SCpnt
suffix:semicolon
r_int
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_BUSFREE
comma
l_string|&quot;enter&quot;
)paren
suffix:semicolon
id|nsp32_write4
c_func
(paren
id|base
comma
id|BM_CNT
comma
l_int|0
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|TRANSFER_CONTROL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * MsgIn 02: Save Data Pointer&n;&t; *&n;&t; * VALID:&n;&t; *   Save Data Pointer is received. Adjust pointer.&n;&t; *   &n;&t; * NO-VALID:&n;&t; *   SCSI-3 says if Save Data Pointer is not received, then we restart&n;&t; *   processing and we can&squot;t adjust any SCSI data pointer in next data&n;&t; *   phase.&n;&t; */
r_if
c_cond
(paren
id|execph
op_amp
id|MSGIN_02_VALID
)paren
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_BUSFREE
comma
l_string|&quot;MsgIn02_Valid&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check sack_cnt/saved_sack_cnt, then adjust sg table if&n;&t;&t; * needed.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|execph
op_amp
id|MSGIN_00_VALID
)paren
op_logical_and
(paren
(paren
id|execph
op_amp
id|DATA_IN_PHASE
)paren
op_logical_or
(paren
id|execph
op_amp
id|DATA_OUT_PHASE
)paren
)paren
)paren
(brace
r_int
r_int
id|sacklen
comma
id|s_sacklen
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Read SACK count and SAVEDSACK count, then compare.&n;&t;&t;&t; */
id|sacklen
op_assign
id|nsp32_read4
c_func
(paren
id|base
comma
id|SACK_CNT
)paren
suffix:semicolon
id|s_sacklen
op_assign
id|nsp32_read4
c_func
(paren
id|base
comma
id|SAVED_SACK_CNT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If SAVEDSACKCNT == 0, it means SavedDataPointer is&n;&t;&t;&t; * come after data transfering.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|s_sacklen
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Comparing between sack and savedsack to&n;&t;&t;&t;&t; * check the condition of AutoMsgIn03.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * If they are same, set msgin03 == TRUE,&n;&t;&t;&t;&t; * COMMANDCONTROL_AUTO_MSGIN_03 is enabled at&n;&t;&t;&t;&t; * reselection.  On the other hand, if they&n;&t;&t;&t;&t; * aren&squot;t same, set msgin03 == FALSE, and&n;&t;&t;&t;&t; * COMMANDCONTROL_AUTO_MSGIN_03 is disabled at&n;&t;&t;&t;&t; * reselection.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|sacklen
op_ne
id|s_sacklen
)paren
(brace
id|data-&gt;curlunt-&gt;msgin03
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
(brace
id|data-&gt;curlunt-&gt;msgin03
op_assign
id|TRUE
suffix:semicolon
)brace
id|nsp32_adjust_busfree
c_func
(paren
id|data
comma
id|s_sacklen
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* This value has not substitude with valid value yet... */
singleline_comment|//data-&gt;curlunt-&gt;save_datp = data-&gt;cur_datp;
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * no processing.&n;&t;&t; */
)brace
r_if
c_cond
(paren
id|execph
op_amp
id|MSGIN_03_VALID
)paren
(brace
multiline_comment|/* MsgIn03 was valid to be processed. No need processing. */
)brace
multiline_comment|/*&n;&t; * target SDTR check&n;&t; */
r_if
c_cond
(paren
id|data-&gt;curtarget-&gt;sync_flag
op_amp
id|SDTR_INITIATOR
)paren
(brace
multiline_comment|/*&n;&t;&t; * SDTR negotiation pulled by the initiator has not&n;&t;&t; * finished yet. Fall back to ASYNC mode.&n;&t;&t; */
id|nsp32_set_async
c_func
(paren
id|data
comma
id|data-&gt;curtarget
)paren
suffix:semicolon
id|data-&gt;curtarget-&gt;sync_flag
op_and_assign
op_complement
id|SDTR_INITIATOR
suffix:semicolon
id|data-&gt;curtarget-&gt;sync_flag
op_or_assign
id|SDTR_DONE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|data-&gt;curtarget-&gt;sync_flag
op_amp
id|SDTR_TARGET
)paren
(brace
multiline_comment|/*&n;&t;&t; * SDTR negotiation pulled by the target has been&n;&t;&t; * negotiating.&n;&t;&t; */
r_if
c_cond
(paren
id|execph
op_amp
(paren
id|MSGIN_00_VALID
op_or
id|MSGIN_04_VALID
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t; * If valid message is received, then&n;&t;&t;&t; * negotiation is succeeded.&n;&t;&t;&t; */
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * On the contrary, if unexpected bus free is&n;&t;&t;&t; * occurred, then negotiation is failed. Fall&n;&t;&t;&t; * back to ASYNC mode.&n;&t;&t;&t; */
id|nsp32_set_async
c_func
(paren
id|data
comma
id|data-&gt;curtarget
)paren
suffix:semicolon
)brace
id|data-&gt;curtarget-&gt;sync_flag
op_and_assign
op_complement
id|SDTR_TARGET
suffix:semicolon
id|data-&gt;curtarget-&gt;sync_flag
op_or_assign
id|SDTR_DONE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * It is always ensured by SCSI standard that initiator&n;&t; * switches into Bus Free Phase after&n;&t; * receiving message 00 (Command Complete), 04 (Disconnect).&n;&t; * It&squot;s the reason that processing here is valid.&n;&t; */
r_if
c_cond
(paren
id|execph
op_amp
id|MSGIN_00_VALID
)paren
(brace
multiline_comment|/* MsgIn 00: Command Complete */
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_BUSFREE
comma
l_string|&quot;command complete&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;SCp.Status
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_CSB_IN
)paren
suffix:semicolon
id|SCpnt-&gt;SCp.Message
op_assign
l_int|0
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_BUSFREE
comma
l_string|&quot;normal end stat=0x%x resid=0x%x&bslash;n&quot;
comma
id|SCpnt-&gt;SCp.Status
comma
id|SCpnt-&gt;resid
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
(paren
id|DID_OK
op_lshift
l_int|16
)paren
op_or
(paren
id|SCpnt-&gt;SCp.Message
op_lshift
l_int|8
)paren
op_or
(paren
id|SCpnt-&gt;SCp.Status
op_lshift
l_int|0
)paren
suffix:semicolon
id|nsp32_scsi_done
c_func
(paren
id|data
comma
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/* All operation is done */
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|execph
op_amp
id|MSGIN_04_VALID
)paren
(brace
multiline_comment|/* MsgIn 04: Disconnect */
id|SCpnt-&gt;SCp.Status
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_CSB_IN
)paren
suffix:semicolon
id|SCpnt-&gt;SCp.Message
op_assign
l_int|4
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_BUSFREE
comma
l_string|&quot;disconnect&quot;
)paren
suffix:semicolon
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Unexpected bus free */
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;unexpected bus free occurred&quot;
)paren
suffix:semicolon
multiline_comment|/* DID_ERROR? */
singleline_comment|//SCpnt-&gt;result   = (DID_OK &lt;&lt; 16) | (SCpnt-&gt;SCp.Message &lt;&lt; 8) | (SCpnt-&gt;SCp.Status &lt;&lt; 0);
id|SCpnt-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|nsp32_scsi_done
c_func
(paren
id|data
comma
id|SCpnt
)paren
suffix:semicolon
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * nsp32_adjust_busfree - adjusting SG table&n; *&n; * Note: This driver adjust the SG table using SCSI ACK&n; *       counter instead of BMCNT counter!&n; */
DECL|function|nsp32_adjust_busfree
r_static
r_void
id|nsp32_adjust_busfree
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
r_int
r_int
id|s_sacklen
)paren
(brace
r_int
id|old_entry
op_assign
id|data-&gt;cur_entry
suffix:semicolon
r_int
id|new_entry
suffix:semicolon
r_struct
id|nsp32_sgtable
op_star
id|sgt
op_assign
id|data-&gt;curlunt-&gt;sglun-&gt;sgt
suffix:semicolon
r_int
r_int
id|restlen
comma
id|sentlen
suffix:semicolon
r_int
id|sg_num
op_assign
id|data-&gt;curlunt-&gt;sg_num
suffix:semicolon
multiline_comment|/* adjust saved SACK count with 4 byte start address boundary */
id|s_sacklen
op_sub_assign
id|sgt
(braket
id|old_entry
)braket
dot
id|addr
op_amp
l_int|3
suffix:semicolon
multiline_comment|/*&n;&t; * calculate new_entry from sack count and each sgt[].len &n;&t; * calculate the byte which is intent to send&n;&t; */
id|sentlen
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|new_entry
op_assign
id|old_entry
suffix:semicolon
id|new_entry
OL
id|sg_num
suffix:semicolon
id|new_entry
op_increment
)paren
(brace
id|sentlen
op_add_assign
(paren
id|sgt
(braket
id|new_entry
)braket
dot
id|len
op_amp
op_complement
id|NSP32_SG_END_SGT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sentlen
OG
id|s_sacklen
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* all sgt is processed */
r_if
c_cond
(paren
id|new_entry
op_eq
id|sg_num
)paren
(brace
r_goto
id|last
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sentlen
op_eq
id|s_sacklen
)paren
(brace
multiline_comment|/* XXX: confirm it&squot;s ok or not */
multiline_comment|/* In this case, it&squot;s ok because we are at &n;&t;&t;   the head element of the sg. restlen is correctly calculated. */
)brace
multiline_comment|/* calculate the rest length for transfering */
id|restlen
op_assign
id|sentlen
op_minus
id|s_sacklen
suffix:semicolon
multiline_comment|/* update adjusting current SG table entry */
id|sgt
(braket
id|new_entry
)braket
dot
id|addr
op_add_assign
(paren
id|sgt
(braket
id|new_entry
)braket
dot
id|len
op_minus
id|restlen
)paren
suffix:semicolon
id|sgt
(braket
id|new_entry
)braket
dot
id|len
op_assign
id|restlen
suffix:semicolon
multiline_comment|/* set cur_entry with new_entry */
id|data-&gt;cur_entry
op_assign
id|new_entry
suffix:semicolon
r_return
suffix:semicolon
id|last
suffix:colon
multiline_comment|/* update hostdata and lun */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * It&squot;s called MsgOut phase occur.&n; * NinjaSCSI-32Bi/UDE automatically processes up to 3 messages in&n; * message out phase. It, however, has more than 3 messages,&n; * HBA creates the interrupt and we have to process by hand.&n; */
DECL|function|nsp32_msgout_occur
r_static
r_void
id|nsp32_msgout_occur
c_func
(paren
id|nsp32_hw_data
op_star
id|data
)paren
(brace
r_int
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
r_int
id|new_sgtp
suffix:semicolon
r_int
id|i
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_MSGOUTOCCUR
comma
l_string|&quot;enter: msgoutlen: 0x%x&quot;
comma
id|data-&gt;msgoutlen
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If MsgOut phase is occurred without having any&n;&t; * message, then No_Operation is sent (SCSI-2).&n;&t; */
r_if
c_cond
(paren
id|data-&gt;msgoutlen
op_eq
l_int|0
)paren
(brace
id|nsp32_build_nop
c_func
(paren
id|data
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set SGTP ADDR current entry for restarting AUTOSCSI, &n;&t; * because SGTP is incremented next point.&n;&t; * There is few statement in the specification...&n;&t; */
id|new_sgtp
op_assign
id|data-&gt;curlunt-&gt;sglun_paddr
op_plus
id|data-&gt;curlunt-&gt;cur_entry
op_star
r_sizeof
(paren
r_struct
id|nsp32_sgtable
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * send messages&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|data-&gt;msgoutlen
suffix:semicolon
id|i
op_increment
)paren
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_MSGOUTOCCUR
comma
l_string|&quot;%d : 0x%x&quot;
comma
id|i
comma
id|data-&gt;msgoutbuf
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check REQ is asserted.&n;&t;&t; */
id|nsp32_wait_req
c_func
(paren
id|data
comma
id|ASSERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
(paren
id|data-&gt;msgoutlen
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If the last message, set the AutoSCSI restart&n;&t;&t;&t; * before send back the ack message. AutoSCSI&n;&t;&t;&t; * restart automatically negate ATN signal.&n;&t;&t;&t; */
singleline_comment|//command = (AUTO_MSGIN_00_OR_04 | AUTO_MSGIN_02);
singleline_comment|//nsp32_restart_autoscsi(data, command);
id|nsp32_write2
c_func
(paren
id|base
comma
id|COMMAND_CONTROL
comma
(paren
id|CLEAR_CDB_FIFO_POINTER
op_or
id|AUTO_COMMAND_PHASE
op_or
id|AUTOSCSI_RESTART
op_or
id|AUTO_MSGIN_00_OR_04
op_or
id|AUTO_MSGIN_02
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Write data with SACK, then wait sack is&n;&t;&t; * automatically negated.&n;&t;&t; */
id|nsp32_write1
c_func
(paren
id|base
comma
id|SCSI_DATA_WITH_ACK
comma
id|data-&gt;msgoutbuf
(braket
id|i
)braket
)paren
suffix:semicolon
id|nsp32_wait_sack
c_func
(paren
id|data
comma
id|NEGATE
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_MSGOUTOCCUR
comma
l_string|&quot;bus: 0x%x&bslash;n&quot;
comma
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_BUS_MONITOR
)paren
)paren
suffix:semicolon
)brace
suffix:semicolon
id|data-&gt;msgoutlen
op_assign
l_int|0
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_MSGOUTOCCUR
comma
l_string|&quot;exit&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Restart AutoSCSI&n; *&n; * Note: Restarting AutoSCSI needs set:&n; *&t;&t;SYNC_REG, ACK_WIDTH, SGT_ADR, TRANSFER_CONTROL&n; */
DECL|function|nsp32_restart_autoscsi
r_static
r_void
id|nsp32_restart_autoscsi
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
r_int
r_int
id|command
)paren
(brace
r_int
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
r_int
r_int
id|transfer
op_assign
l_int|0
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
op_assign
id|data-&gt;curlunt-&gt;SCpnt
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_RESTART
comma
l_string|&quot;enter&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;curtarget
op_eq
l_int|NULL
op_logical_or
id|data-&gt;curlunt
op_eq
l_int|NULL
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;Target or Lun is invalid&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * set SYNC_REG&n;&t; * Don&squot;t set BM_START_ADR before setting this register.&n;&t; */
id|nsp32_write1
c_func
(paren
id|base
comma
id|SYNC_REG
comma
id|data-&gt;curtarget-&gt;syncreg
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set ACKWIDTH&n;&t; */
id|nsp32_write1
c_func
(paren
id|base
comma
id|ACK_WIDTH
comma
id|data-&gt;curtarget-&gt;ackwidth
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set SGT ADDR (physical address)&n;&t; */
id|nsp32_write4
c_func
(paren
id|base
comma
id|SGT_ADR
comma
id|data-&gt;curlunt-&gt;sglun_paddr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set TRANSFER CONTROL REG&n;&t; */
id|transfer
op_assign
l_int|0
suffix:semicolon
id|transfer
op_or_assign
(paren
id|TRANSFER_GO
op_or
id|ALL_COUNTER_CLR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;trans_method
op_amp
id|NSP32_TRANSFER_BUSMASTER
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;request_bufflen
OG
l_int|0
)paren
(brace
id|transfer
op_or_assign
id|BM_START
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|data-&gt;trans_method
op_amp
id|NSP32_TRANSFER_MMIO
)paren
(brace
id|transfer
op_or_assign
id|CB_MMIO_MODE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|data-&gt;trans_method
op_amp
id|NSP32_TRANSFER_PIO
)paren
(brace
id|transfer
op_or_assign
id|CB_IO_MODE
suffix:semicolon
)brace
id|nsp32_write2
c_func
(paren
id|base
comma
id|TRANSFER_CONTROL
comma
id|transfer
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * restart AutoSCSI&n;&t; *&n;&t; * TODO: COMMANDCONTROL_AUTO_COMMAND_PHASE is needed ?&n;&t; */
id|command
op_or_assign
(paren
id|CLEAR_CDB_FIFO_POINTER
op_or
id|AUTO_COMMAND_PHASE
op_or
id|AUTOSCSI_RESTART
)paren
suffix:semicolon
id|nsp32_write2
c_func
(paren
id|base
comma
id|COMMAND_CONTROL
comma
id|command
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_RESTART
comma
l_string|&quot;exit&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * cannot run automatically message in occur&n; */
DECL|function|nsp32_msgin_occur
r_static
r_void
id|nsp32_msgin_occur
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
r_int
r_int
id|irq_status
comma
r_int
r_int
id|execph
)paren
(brace
r_int
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
r_int
r_char
id|msg
suffix:semicolon
r_int
r_char
id|msgtype
suffix:semicolon
r_int
r_char
id|newlun
suffix:semicolon
r_int
r_int
id|command
op_assign
l_int|0
suffix:semicolon
r_int
id|msgclear
op_assign
id|TRUE
suffix:semicolon
r_int
id|new_sgtp
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/*&n;&t; * read first message&n;&t; *    Use SCSIDATA_W_ACK instead of SCSIDATAIN, because the procedure&n;&t; *    of Message-In have to be processed before sending back SCSI ACK.&n;&t; */
id|msg
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_DATA_IN
)paren
suffix:semicolon
id|data-&gt;msginbuf
(braket
(paren
r_int
r_char
)paren
id|data-&gt;msginlen
)braket
op_assign
id|msg
suffix:semicolon
id|msgtype
op_assign
id|data-&gt;msginbuf
(braket
l_int|0
)braket
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_MSGINOCCUR
comma
l_string|&quot;enter: msglen: 0x%x msgin: 0x%x msgtype: 0x%x&quot;
comma
id|data-&gt;msginlen
comma
id|msg
comma
id|msgtype
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * TODO: We need checking whether bus phase is message in?&n;&t; */
multiline_comment|/*&n;&t; * assert SCSI ACK&n;&t; */
id|nsp32_sack_assert
c_func
(paren
id|data
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * processing IDENTIFY&n;&t; */
r_if
c_cond
(paren
id|msgtype
op_amp
l_int|0x80
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|irq_status
op_amp
id|IRQSTATUS_RESELECT_OCCUER
)paren
)paren
(brace
multiline_comment|/* Invalid (non reselect) phase */
r_goto
id|reject
suffix:semicolon
)brace
id|newlun
op_assign
id|msgtype
op_amp
l_int|0x1f
suffix:semicolon
multiline_comment|/* TODO: SPI-3 compliant? */
id|ret
op_assign
id|nsp32_reselection
c_func
(paren
id|data
comma
id|newlun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|TRUE
)paren
(brace
r_goto
id|restart
suffix:semicolon
)brace
r_else
(brace
r_goto
id|reject
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * processing messages except for IDENTIFY&n;&t; *&n;&t; * TODO: Messages are all SCSI-2 terminology. SCSI-3 compliance is TODO.&n;&t; */
r_switch
c_cond
(paren
id|msgtype
)paren
(brace
multiline_comment|/*&n;&t; * 1-byte message&n;&t; */
r_case
id|COMMAND_COMPLETE
suffix:colon
r_case
id|DISCONNECT
suffix:colon
multiline_comment|/*&n;&t;&t; * These messages should not be occurred.&n;&t;&t; * They should be processed on AutoSCSI sequencer.&n;&t;&t; */
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;unexpected message of AutoSCSI MsgIn: 0x%x&quot;
comma
id|msg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RESTORE_POINTERS
suffix:colon
multiline_comment|/*&n;&t;&t; * AutoMsgIn03 is disabled, and HBA gets this message.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|execph
op_amp
id|DATA_IN_PHASE
)paren
op_logical_or
(paren
id|execph
op_amp
id|DATA_OUT_PHASE
)paren
)paren
(brace
r_int
r_int
id|s_sacklen
suffix:semicolon
id|s_sacklen
op_assign
id|nsp32_read4
c_func
(paren
id|base
comma
id|SAVED_SACK_CNT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|execph
op_amp
id|MSGIN_02_VALID
)paren
op_logical_and
(paren
id|s_sacklen
OG
l_int|0
)paren
)paren
(brace
id|nsp32_adjust_busfree
c_func
(paren
id|data
comma
id|s_sacklen
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* No need to rewrite SGT */
)brace
)brace
id|data-&gt;curlunt-&gt;msgin03
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Update with the new value */
multiline_comment|/* reset SACK/SavedACK counter (or ALL clear?) */
id|nsp32_write4
c_func
(paren
id|base
comma
id|CLR_COUNTER
comma
id|CLRCOUNTER_ALLMASK
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * set new sg pointer&n;&t;&t; */
id|new_sgtp
op_assign
id|data-&gt;curlunt-&gt;sglun_paddr
op_plus
id|data-&gt;curlunt-&gt;cur_entry
op_star
r_sizeof
(paren
r_struct
id|nsp32_sgtable
)paren
suffix:semicolon
id|nsp32_write4
c_func
(paren
id|base
comma
id|SGT_ADR
comma
id|new_sgtp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SAVE_POINTERS
suffix:colon
multiline_comment|/*&n;&t;&t; * These messages should not be occurred.&n;&t;&t; * They should be processed on AutoSCSI sequencer.&n;&t;&t; */
id|nsp32_msg
(paren
id|KERN_WARNING
comma
l_string|&quot;unexpected message of AutoSCSI MsgIn: SAVE_POINTERS&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MESSAGE_REJECT
suffix:colon
multiline_comment|/* If previous message_out is sending SDTR, and get &n;&t;&t;   message_reject from target, SDTR negotiation is failed */
r_if
c_cond
(paren
id|data-&gt;curtarget-&gt;sync_flag
op_amp
(paren
id|SDTR_INITIATOR
op_or
id|SDTR_TARGET
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Current target is negotiating SDTR, but it&squot;s&n;&t;&t;&t; * failed.  Fall back to async transfer mode, and set&n;&t;&t;&t; * SDTR_DONE.&n;&t;&t;&t; */
id|nsp32_set_async
c_func
(paren
id|data
comma
id|data-&gt;curtarget
)paren
suffix:semicolon
id|data-&gt;curtarget-&gt;sync_flag
op_and_assign
op_complement
id|SDTR_INITIATOR
suffix:semicolon
id|data-&gt;curtarget-&gt;sync_flag
op_or_assign
id|SDTR_DONE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|LINKED_CMD_COMPLETE
suffix:colon
r_case
id|LINKED_FLG_CMD_COMPLETE
suffix:colon
multiline_comment|/* queue tag is not supported currently */
id|nsp32_msg
(paren
id|KERN_WARNING
comma
l_string|&quot;unsupported message: 0x%x&quot;
comma
id|msgtype
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INITIATE_RECOVERY
suffix:colon
multiline_comment|/* staring ECA (Extended Contingent Allegiance) state. */
multiline_comment|/* This message is declined in SPI2 or later. */
r_goto
id|reject
suffix:semicolon
multiline_comment|/*&n;&t; * 2-byte message&n;&t; */
r_case
id|SIMPLE_QUEUE_TAG
suffix:colon
r_case
l_int|0x23
suffix:colon
multiline_comment|/*&n;&t;&t; * 0x23: Ignore_Wide_Residue is not declared in scsi.h.&n;&t;&t; * No support is needed.&n;&t;&t; */
r_if
c_cond
(paren
id|data-&gt;msginlen
op_ge
l_int|1
)paren
(brace
r_goto
id|reject
suffix:semicolon
)brace
multiline_comment|/* current position is 1-byte of 2 byte */
id|msgclear
op_assign
id|FALSE
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t; * extended message&n;&t; */
r_case
id|EXTENDED_MESSAGE
suffix:colon
r_if
c_cond
(paren
id|data-&gt;msginlen
OL
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Current position does not reach 2-byte&n;&t;&t;&t; * (2-byte is extended message length).&n;&t;&t;&t; */
id|msgclear
op_assign
id|FALSE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|data-&gt;msginbuf
(braket
l_int|1
)braket
op_plus
l_int|1
)paren
OG
id|data-&gt;msginlen
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Current extended message has msginbuf[1] + 2&n;&t;&t;&t; * (msginlen starts counting from 0, so buf[1] + 1).&n;&t;&t;&t; * If current message position is not finished,&n;&t;&t;&t; * continue receiving message.&n;&t;&t;&t; */
id|msgclear
op_assign
id|FALSE
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Reach here means regular length of each type of &n;&t;&t; * extended messages.&n;&t;&t; */
r_switch
c_cond
(paren
id|data-&gt;msginbuf
(braket
l_int|2
)braket
)paren
(brace
r_case
id|EXTENDED_MODIFY_DATA_POINTER
suffix:colon
multiline_comment|/* TODO */
r_goto
id|reject
suffix:semicolon
multiline_comment|/* not implemented yet */
r_break
suffix:semicolon
r_case
id|EXTENDED_SDTR
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Exchange this message between initiator and target.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|data-&gt;msginlen
op_ne
id|EXTENDED_SDTR_LEN
op_plus
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * received inappropriate message.&n;&t;&t;&t;&t; */
r_goto
id|reject
suffix:semicolon
r_break
suffix:semicolon
)brace
id|nsp32_analyze_sdtr
c_func
(paren
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EXTENDED_EXTENDED_IDENTIFY
suffix:colon
multiline_comment|/* SCSI-I only, not supported. */
r_goto
id|reject
suffix:semicolon
multiline_comment|/* not implemented yet */
r_break
suffix:semicolon
r_case
id|EXTENDED_WDTR
suffix:colon
r_goto
id|reject
suffix:semicolon
multiline_comment|/* not implemented yet */
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|reject
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|reject
suffix:semicolon
)brace
id|restart
suffix:colon
r_if
c_cond
(paren
id|msgclear
op_eq
id|TRUE
)paren
(brace
id|data-&gt;msginlen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If restarting AutoSCSI, but there are some message to out&n;&t;&t; * (msgoutlen &gt; 0), set AutoATN, and set SCSIMSGOUT as 0&n;&t;&t; * (MV_VALID = 0). When commandcontrol is written with&n;&t;&t; * AutoSCSI restart, at the same time MsgOutOccur should be&n;&t;&t; * happened (however, such situation is really possible...?).&n;&t;&t; */
r_if
c_cond
(paren
id|data-&gt;msgoutlen
OG
l_int|0
)paren
(brace
id|nsp32_write4
c_func
(paren
id|base
comma
id|SCSI_MSG_OUT
comma
l_int|0
)paren
suffix:semicolon
id|command
op_or_assign
id|AUTO_ATN
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * restart AutoSCSI&n;&t;&t; * If it&squot;s failed, COMMANDCONTROL_AUTO_COMMAND_PHASE is needed.&n;&t;&t; */
id|command
op_or_assign
(paren
id|AUTO_MSGIN_00_OR_04
op_or
id|AUTO_MSGIN_02
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If current msgin03 is TRUE, then flag on.&n;&t;&t; */
r_if
c_cond
(paren
id|data-&gt;curlunt-&gt;msgin03
op_eq
id|TRUE
)paren
(brace
id|command
op_or_assign
id|AUTO_MSGIN_03
suffix:semicolon
)brace
id|data-&gt;curlunt-&gt;msgin03
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
(brace
id|data-&gt;msginlen
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * restart AutoSCSI&n;&t; */
id|nsp32_restart_autoscsi
c_func
(paren
id|data
comma
id|command
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * wait SCSI REQ negate for REQ-ACK handshake&n;&t; */
id|nsp32_wait_req
c_func
(paren
id|data
comma
id|NEGATE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * negate SCSI ACK&n;&t; */
id|nsp32_sack_negate
c_func
(paren
id|data
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_MSGINOCCUR
comma
l_string|&quot;exit&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
id|reject
suffix:colon
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;invalid or unsupported MessageIn, rejected. &quot;
l_string|&quot;current msg: 0x%x (len: 0x%x), processing msg: 0x%x&quot;
comma
id|msg
comma
id|data-&gt;msginlen
comma
id|msgtype
)paren
suffix:semicolon
id|nsp32_build_reject
c_func
(paren
id|data
)paren
suffix:semicolon
id|data-&gt;msginlen
op_assign
l_int|0
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
multiline_comment|/*&n; * &n; */
DECL|function|nsp32_analyze_sdtr
r_static
r_void
id|nsp32_analyze_sdtr
c_func
(paren
id|nsp32_hw_data
op_star
id|data
)paren
(brace
r_struct
id|nsp32_target
op_star
id|target
op_assign
id|data-&gt;curtarget
suffix:semicolon
r_struct
id|nsp32_sync_table
op_star
id|synct
suffix:semicolon
r_int
r_char
id|get_period
op_assign
id|data-&gt;msginbuf
(braket
l_int|3
)braket
suffix:semicolon
r_int
r_char
id|get_offset
op_assign
id|data-&gt;msginbuf
(braket
l_int|4
)braket
suffix:semicolon
r_int
id|entry
suffix:semicolon
r_int
id|syncnum
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_MSGINOCCUR
comma
l_string|&quot;enter&quot;
)paren
suffix:semicolon
id|synct
op_assign
id|data-&gt;synct
suffix:semicolon
id|syncnum
op_assign
id|data-&gt;syncnum
suffix:semicolon
multiline_comment|/*&n;&t; * If this inititor sent the SDTR message, then target responds SDTR,&n;&t; * initiator SYNCREG, ACKWIDTH from SDTR parameter.&n;&t; * Messages are not appropriate, then send back reject message.&n;&t; * If initiator did not send the SDTR, but target sends SDTR, &n;&t; * initiator calculator the appropriate parameter and send back SDTR.&n;&t; */
r_if
c_cond
(paren
id|target-&gt;sync_flag
op_amp
id|SDTR_INITIATOR
)paren
(brace
multiline_comment|/*&n;&t;&t; * Initiator sent SDTR, the target responds and&n;&t;&t; * send back negotiation SDTR.&n;&t;&t; */
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_MSGINOCCUR
comma
l_string|&quot;target responds SDTR&quot;
)paren
suffix:semicolon
id|target-&gt;sync_flag
op_and_assign
op_complement
id|SDTR_INITIATOR
suffix:semicolon
id|target-&gt;sync_flag
op_or_assign
id|SDTR_DONE
suffix:semicolon
multiline_comment|/*&n;&t;&t; * offset:&n;&t;&t; */
r_if
c_cond
(paren
id|get_offset
OG
id|SYNC_OFFSET
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Negotiation is failed, the target send back&n;&t;&t;&t; * unexpected offset value.&n;&t;&t;&t; */
r_goto
id|reject
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_offset
op_eq
id|ASYNC_OFFSET
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Negotiation is succeeded, the target want&n;&t;&t;&t; * to fall back into asynchronous transfer mode.&n;&t;&t;&t; */
r_goto
id|async
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * period:&n;&t;&t; *    Check whether sync period is too short. If too short,&n;&t;&t; *    fall back to async mode. If it&squot;s ok, then investigate&n;&t;&t; *    the received sync period. If sync period is acceptable&n;&t;&t; *    between sync table start_period and end_period, then&n;&t;&t; *    set this I_T nexus as sent offset and period.&n;&t;&t; *    If it&squot;s not acceptable, send back reject and fall back&n;&t;&t; *    to async mode.&n;&t;&t; */
r_if
c_cond
(paren
id|get_period
OL
id|data-&gt;synct
(braket
l_int|0
)braket
dot
id|period_num
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Negotiation is failed, the target send back&n;&t;&t;&t; * unexpected period value.&n;&t;&t;&t; */
r_goto
id|reject
suffix:semicolon
)brace
id|entry
op_assign
id|nsp32_search_period_entry
c_func
(paren
id|data
comma
id|target
comma
id|get_period
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
OL
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Target want to use long period which is not &n;&t;&t;&t; * acceptable NinjaSCSI-32Bi/UDE.&n;&t;&t;&t; */
r_goto
id|reject
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Set new sync table and offset in this I_T nexus.&n;&t;&t; */
id|nsp32_set_sync_entry
c_func
(paren
id|data
comma
id|target
comma
id|entry
comma
id|get_offset
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Target send SDTR to initiator. */
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_MSGINOCCUR
comma
l_string|&quot;target send SDTR&quot;
)paren
suffix:semicolon
id|target-&gt;sync_flag
op_or_assign
id|SDTR_INITIATOR
suffix:semicolon
multiline_comment|/* offset: */
r_if
c_cond
(paren
id|get_offset
OG
id|SYNC_OFFSET
)paren
(brace
multiline_comment|/* send back as SYNC_OFFSET */
id|get_offset
op_assign
id|SYNC_OFFSET
suffix:semicolon
)brace
multiline_comment|/* period: */
r_if
c_cond
(paren
id|get_period
OL
id|data-&gt;synct
(braket
l_int|0
)braket
dot
id|period_num
)paren
(brace
id|get_period
op_assign
id|data-&gt;synct
(braket
l_int|0
)braket
dot
id|period_num
suffix:semicolon
)brace
id|entry
op_assign
id|nsp32_search_period_entry
c_func
(paren
id|data
comma
id|target
comma
id|get_period
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_offset
op_eq
id|ASYNC_OFFSET
op_logical_or
id|entry
OL
l_int|0
)paren
(brace
id|nsp32_set_async
c_func
(paren
id|data
comma
id|target
)paren
suffix:semicolon
id|nsp32_build_sdtr
c_func
(paren
id|data
comma
l_int|0
comma
id|ASYNC_OFFSET
)paren
suffix:semicolon
)brace
r_else
(brace
id|nsp32_set_sync_entry
c_func
(paren
id|data
comma
id|target
comma
id|entry
comma
id|get_offset
)paren
suffix:semicolon
id|nsp32_build_sdtr
c_func
(paren
id|data
comma
id|get_period
comma
id|get_offset
)paren
suffix:semicolon
)brace
)brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_MSGINOCCUR
comma
l_string|&quot;exit&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
id|reject
suffix:colon
multiline_comment|/*&n;&t; * If the current message is unacceptable, send back to the target&n;&t; * with reject message.&n;&t; */
id|nsp32_build_reject
c_func
(paren
id|data
)paren
suffix:semicolon
id|async
suffix:colon
id|nsp32_set_async
c_func
(paren
id|data
comma
id|target
)paren
suffix:semicolon
multiline_comment|/* set as ASYNC transfer mode */
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_MSGINOCCUR
comma
l_string|&quot;exit: set async&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Search config entry number matched in sync_table from given&n; * target and speed period value. If failed to search, return negative value.&n; */
DECL|function|nsp32_search_period_entry
r_static
r_int
id|nsp32_search_period_entry
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
r_struct
id|nsp32_target
op_star
id|target
comma
r_int
r_char
id|period
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|target-&gt;limit_entry
op_ge
id|data-&gt;syncnum
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;limit_entry exceeds syncnum!&quot;
)paren
suffix:semicolon
id|target-&gt;limit_entry
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|target-&gt;limit_entry
suffix:semicolon
id|i
OL
id|data-&gt;syncnum
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|period
op_ge
id|data-&gt;synct
(braket
id|i
)braket
dot
id|start_period
op_logical_and
id|period
op_le
id|data-&gt;synct
(braket
id|i
)braket
dot
id|end_period
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Check given period value is over the sync_table value.&n;&t; * If so, return max value.&n;&t; */
r_if
c_cond
(paren
id|i
op_eq
id|data-&gt;syncnum
)paren
(brace
id|i
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; * target &lt;-&gt; initiator use ASYNC transfer&n; */
DECL|function|nsp32_set_async
r_static
r_void
id|nsp32_set_async
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
r_struct
id|nsp32_target
op_star
id|target
)paren
(brace
r_int
r_char
id|period
op_assign
id|data-&gt;synct
(braket
id|target-&gt;limit_entry
)braket
dot
id|period_num
suffix:semicolon
id|target-&gt;offset
op_assign
id|ASYNC_OFFSET
suffix:semicolon
id|target-&gt;syncreg
op_assign
id|TO_SYNCREG
c_func
(paren
id|period
comma
id|ASYNC_OFFSET
)paren
suffix:semicolon
id|target-&gt;ackwidth
op_assign
l_int|0
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_SYNC
comma
l_string|&quot;set async&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * target &lt;-&gt; initiator use maximum SYNC transfer&n; */
DECL|function|nsp32_set_max_sync
r_static
r_void
id|nsp32_set_max_sync
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
r_struct
id|nsp32_target
op_star
id|target
comma
r_int
r_char
op_star
id|period
comma
r_int
r_char
op_star
id|offset
)paren
(brace
r_int
r_char
id|period_num
comma
id|ackwidth
suffix:semicolon
id|period_num
op_assign
id|data-&gt;synct
(braket
id|target-&gt;limit_entry
)braket
dot
id|period_num
suffix:semicolon
op_star
id|period
op_assign
id|data-&gt;synct
(braket
id|target-&gt;limit_entry
)braket
dot
id|start_period
suffix:semicolon
id|ackwidth
op_assign
id|data-&gt;synct
(braket
id|target-&gt;limit_entry
)braket
dot
id|ackwidth
suffix:semicolon
op_star
id|offset
op_assign
id|SYNC_OFFSET
suffix:semicolon
id|target-&gt;syncreg
op_assign
id|TO_SYNCREG
c_func
(paren
id|period_num
comma
op_star
id|offset
)paren
suffix:semicolon
id|target-&gt;ackwidth
op_assign
id|ackwidth
suffix:semicolon
id|target-&gt;offset
op_assign
op_star
id|offset
suffix:semicolon
)brace
multiline_comment|/*&n; * target &lt;-&gt; initiator use entry number speed&n; */
DECL|function|nsp32_set_sync_entry
r_static
r_void
id|nsp32_set_sync_entry
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
r_struct
id|nsp32_target
op_star
id|target
comma
r_int
id|entry
comma
r_int
r_char
id|offset
)paren
(brace
r_int
r_char
id|period
comma
id|ackwidth
suffix:semicolon
id|period
op_assign
id|data-&gt;synct
(braket
id|entry
)braket
dot
id|period_num
suffix:semicolon
id|ackwidth
op_assign
id|data-&gt;synct
(braket
id|entry
)braket
dot
id|ackwidth
suffix:semicolon
id|offset
op_assign
id|offset
suffix:semicolon
id|target-&gt;syncreg
op_assign
id|TO_SYNCREG
c_func
(paren
id|period
comma
id|offset
)paren
suffix:semicolon
id|target-&gt;ackwidth
op_assign
id|ackwidth
suffix:semicolon
id|target-&gt;offset
op_assign
id|offset
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_SYNC
comma
l_string|&quot;set sync&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * It waits until SCSI REQ becomes assertion or negation state.&n; *&n; * Note: If nsp32_msgin_occur is called, we asserts SCSI ACK. Then&n; *     connected target responds SCSI REQ negation.  We have to wait&n; *     SCSI REQ becomes negation in order to negate SCSI ACK signal for&n; *     REQ-ACK handshake.&n; */
DECL|function|nsp32_wait_req
r_static
r_void
id|nsp32_wait_req
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
r_int
id|state
)paren
(brace
r_int
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
r_int
id|wait_time
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|bus
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|state
op_eq
id|ASSERT
)paren
op_logical_or
(paren
id|state
op_eq
id|NEGATE
)paren
)paren
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;unknown state designation&quot;
)paren
suffix:semicolon
)brace
id|state
op_lshift_assign
l_int|5
suffix:semicolon
multiline_comment|/* REQ is BIT(5) */
r_do
(brace
id|bus
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_BUS_MONITOR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bus
op_amp
id|BUSMON_REQ
)paren
op_eq
id|state
)paren
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_WAIT
comma
l_string|&quot;wait_time: %d&quot;
comma
id|wait_time
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|wait_time
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|wait_time
OL
id|REQSACK_TIMEOUT_TIME
)paren
suffix:semicolon
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;wait REQ timeout, state: %d&quot;
comma
id|state
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * It waits until SCSI SACK becomes assertion or negation state.&n; */
DECL|function|nsp32_wait_sack
r_static
r_void
id|nsp32_wait_sack
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
r_int
id|state
)paren
(brace
r_int
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
r_int
id|wait_time
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|bus
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|state
op_eq
id|ASSERT
)paren
op_logical_or
(paren
id|state
op_eq
id|NEGATE
)paren
)paren
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;unknown state designation&quot;
)paren
suffix:semicolon
)brace
id|state
op_lshift_assign
l_int|4
suffix:semicolon
multiline_comment|/* ACK is BIT(4) */
r_do
(brace
id|bus
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_BUS_MONITOR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bus
op_amp
id|BUSMON_ACK
)paren
op_eq
id|state
)paren
(brace
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_WAIT
comma
l_string|&quot;wait_time: %d&quot;
comma
id|wait_time
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|wait_time
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|wait_time
OL
id|REQSACK_TIMEOUT_TIME
)paren
suffix:semicolon
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;wait SACK timeout, state: %d&quot;
comma
id|state
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * assert SCSI ACK&n; *&n; * Note: SCSI ACK assertion needs with ACKENB=1, AUTODIRECTION=1.&n; */
DECL|function|nsp32_sack_assert
r_static
r_void
id|nsp32_sack_assert
c_func
(paren
id|nsp32_hw_data
op_star
id|data
)paren
(brace
r_int
r_char
id|busctrl
suffix:semicolon
r_int
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
id|busctrl
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_BUS_CONTROL
)paren
suffix:semicolon
id|busctrl
op_or_assign
(paren
id|BUSCTL_ACK
op_or
id|AUTODIRECTION
op_or
id|ACKENB
)paren
suffix:semicolon
id|nsp32_write1
c_func
(paren
id|base
comma
id|SCSI_BUS_CONTROL
comma
id|busctrl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * negate SCSI ACK&n; */
DECL|function|nsp32_sack_negate
r_static
r_void
id|nsp32_sack_negate
c_func
(paren
id|nsp32_hw_data
op_star
id|data
)paren
(brace
r_int
r_char
id|busctrl
suffix:semicolon
r_int
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
id|busctrl
op_assign
id|nsp32_read1
c_func
(paren
id|base
comma
id|SCSI_BUS_CONTROL
)paren
suffix:semicolon
id|busctrl
op_and_assign
op_complement
id|BUSCTL_ACK
suffix:semicolon
id|nsp32_write1
c_func
(paren
id|base
comma
id|SCSI_BUS_CONTROL
comma
id|busctrl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * getting EEPROM parameter&n; */
DECL|function|nsp32_getprom_param
r_static
r_int
id|nsp32_getprom_param
c_func
(paren
id|nsp32_hw_data
op_star
id|data
)paren
(brace
r_int
id|vendor
op_assign
id|data-&gt;pci_devid-&gt;vendor
suffix:semicolon
r_int
id|device
op_assign
id|data-&gt;pci_devid-&gt;device
suffix:semicolon
r_int
id|ret
comma
id|val
comma
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * EEPROM checking.&n;&t; */
id|ret
op_assign
id|nsp32_prom_read
c_func
(paren
id|data
comma
l_int|0x7e
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0x55
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;No EEPROM detected: 0x%x&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|nsp32_prom_read
c_func
(paren
id|data
comma
l_int|0x7f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0xaa
)paren
(brace
id|nsp32_msg
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;Invalid number: 0x%x&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * check EEPROM type&n;&t; */
r_if
c_cond
(paren
id|vendor
op_eq
id|PCI_VENDOR_ID_WORKBIT
op_logical_and
id|device
op_eq
id|PCI_DEVICE_ID_WORKBIT_STANDARD
)paren
(brace
id|ret
op_assign
id|nsp32_getprom_standard
c_func
(paren
id|data
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vendor
op_eq
id|PCI_VENDOR_ID_WORKBIT
op_logical_and
id|device
op_eq
id|PCI_DEVICE_ID_NINJASCSI_32BIB_LOGITEC
)paren
(brace
id|ret
op_assign
id|nsp32_getprom_new
c_func
(paren
id|data
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vendor
op_eq
id|PCI_VENDOR_ID_WORKBIT
op_logical_and
id|device
op_eq
id|PCI_DEVICE_ID_NINJASCSI_32UDE_MELCO
)paren
(brace
id|ret
op_assign
id|nsp32_getprom_new
c_func
(paren
id|data
)paren
suffix:semicolon
)brace
r_else
(brace
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;Unknown EEPROM&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* for debug : SPROM data full checking */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
l_int|0x1f
suffix:semicolon
id|i
op_increment
)paren
(brace
id|val
op_assign
id|nsp32_prom_read
c_func
(paren
id|data
comma
id|i
)paren
suffix:semicolon
id|nsp32_dbg
c_func
(paren
id|NSP32_DEBUG_EEPROM
comma
l_string|&quot;rom address 0x%x : 0x%x&quot;
comma
id|i
comma
id|val
)paren
suffix:semicolon
)brace
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * AT24C01A (Logitec: LHA-600S), AT24C02 (Melco Buffalo: IFC-USLP) data map:&n; *&n; *   ROMADDR&n; *   0x00 - 0x06 :  Device Synchronous Transfer Period (SCSI ID 0 - 6) &n; *&t;&t;&t;Value 0x0: ASYNC, 0x0c: Ultra-20M, 0x19: Fast-10M&n; *   0x07        :  HBA Synchronous Transfer Period&n; *&t;&t;&t;Value 0: AutoSync, 1: Manual Setting&n; *   0x08 - 0x0f :  Not Used? (0x0)&n; *   0x10        :  Bus Termination&n; * &t;&t;&t;Value 0: Auto[ON], 1: ON, 2: OFF&n; *   0x11        :  Not Used? (0)&n; *   0x12        :  Bus Reset Delay Time (0x03)&n; *   0x13        :  Bootable CD Support&n; *&t;&t;&t;Value 0: Disable, 1: Enable&n; *   0x14        :  Device Scan&n; *&t;&t;&t;Bit   7  6  5  4  3  2  1  0&n; *&t;&t;&t;      |  &lt;-----------------&gt;&n; * &t;&t;&t;      |    SCSI ID: Value 0: Skip, 1: YES&n; *&t;&t;&t;      |-&gt;  Value 0: ALL scan,  Value 1: Manual&n; *   0x15 - 0x1b :  Not Used? (0)&n; *   0x1c        :  Constant? (0x01) (clock div?)&n; *   0x1d - 0x7c :  Not Used (0xff)&n; *   0x7d&t; :  Not Used? (0xff)&n; *   0x7e        :  Constant (0x55), HBA chip revision&n; *   0x7f        :  Constant (0xaa), HBA value&n; */
DECL|function|nsp32_getprom_new
r_static
r_int
id|nsp32_getprom_new
c_func
(paren
id|nsp32_hw_data
op_star
id|data
)paren
(brace
r_int
id|ret
comma
id|i
suffix:semicolon
r_int
id|auto_sync
suffix:semicolon
r_struct
id|nsp32_target
op_star
id|target
suffix:semicolon
r_int
id|entry
suffix:semicolon
multiline_comment|/*&n;&t; * Reset time which is designated by EEPROM.&n;&t; *&n;&t; * TODO: Not used yet.&n;&t; */
id|data-&gt;resettime
op_assign
id|nsp32_prom_read
c_func
(paren
id|data
comma
l_int|0x12
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * HBA Synchronous Transfer Period&n;&t; *&n;&t; * Note: auto_sync = 0: auto, 1: manual.  Ninja SCSI HBA spec says&n;&t; *&t;that if auto_sync is 0 (auto), and connected SCSI devices are&n;&t; *&t;same or lower than 3, then transfer speed is set as ULTRA-20M.&n;&t; *&t;On the contrary if connected SCSI devices are same or higher&n;&t; *&t;than 4, then transfer speed is set as FAST-10M.&n;&t; *&n;&t; *&t;I break this rule. The number of connected SCSI devices are&n;&t; *&t;only ignored. If auto_sync is 0 (auto), then transfer speed is&n;&t; *&t;forced as ULTRA-20M.&n;&t; */
id|ret
op_assign
id|nsp32_prom_read
c_func
(paren
id|data
comma
l_int|0x07
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ret
)paren
(brace
r_case
l_int|0
suffix:colon
id|auto_sync
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|auto_sync
op_assign
id|FALSE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|nsp32_msg
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;Unsupported Auto Sync mode.&quot;
l_string|&quot;Fall back to manual mode.&quot;
)paren
suffix:semicolon
id|auto_sync
op_assign
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|trans_mode
op_eq
id|ULTRA20M_MODE
)paren
(brace
id|auto_sync
op_assign
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * each device Synchronous Transfer Period&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NSP32_HOST_SCSIID
suffix:semicolon
id|i
op_increment
)paren
(brace
id|target
op_assign
op_amp
id|data-&gt;target
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|auto_sync
op_eq
id|TRUE
)paren
(brace
id|target-&gt;limit_entry
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set as ULTRA20M */
)brace
r_else
(brace
id|ret
op_assign
id|nsp32_prom_read
c_func
(paren
id|data
comma
id|i
)paren
suffix:semicolon
id|entry
op_assign
id|nsp32_search_period_entry
c_func
(paren
id|data
comma
id|target
comma
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
OL
l_int|0
)paren
(brace
multiline_comment|/* search failed... set maximum speed */
id|entry
op_assign
l_int|0
suffix:semicolon
)brace
id|target-&gt;limit_entry
op_assign
id|entry
suffix:semicolon
)brace
)brace
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ? (I-O Data: SC-NBD) data map:&n; *&n; *   ROMADDR&n; *   0x00 - 0x06 :  Device Synchronous Transfer Period (SCSI ID 0 - 6) &n; *&t;&t;&t;Value 0x0: 20MB/S, 0x1: 10MB/S, 0x2: 5MB/S, 0x3: ASYNC&n; *   0x07        :  0 (HBA Synchronous Transfer Period: Auto Sync)&n; *   0x08 - 0x0f :  Not Used? (0x0)&n; *   0x10        :  Transfer Mode&n; *&t;&t;&t;Value 0: PIO, 1: Busmater&n; *   0x11        :  Bus Reset Delay Time (0x00-0x20)&n; *   0x12        :  Bus Termination&n; * &t;&t;&t;Value 0: Disable, 1: Enable&n; *   0x13 - 0x19 :  Disconnection&n; *&t;&t;&t;Value 0: Disable, 1: Enable&n; *   0x1a - 0x7c :  Not Used? (0)&n; *   0x7d&t; :  Not Used? (0xf8)&n; *   0x7e        :  Constant (0x55), HBA chip revision&n; *   0x7f        :  Constant (0xaa), HBA value&n; */
DECL|function|nsp32_getprom_standard
r_static
r_int
id|nsp32_getprom_standard
c_func
(paren
id|nsp32_hw_data
op_star
id|data
)paren
(brace
r_int
id|ret
comma
id|i
suffix:semicolon
r_struct
id|nsp32_target
op_star
id|target
suffix:semicolon
r_int
id|entry
comma
id|val
suffix:semicolon
multiline_comment|/*&n;&t; * Reset time which is designated by EEPROM.&n;&t; *&n;&t; * TODO: Not used yet.&n;&t; */
id|data-&gt;resettime
op_assign
id|nsp32_prom_read
c_func
(paren
id|data
comma
l_int|0x11
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * each device Synchronous Transfer Period&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NSP32_HOST_SCSIID
suffix:semicolon
id|i
op_increment
)paren
(brace
id|target
op_assign
op_amp
id|data-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|ret
op_assign
id|nsp32_prom_read
c_func
(paren
id|data
comma
id|i
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ret
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* 20MB/s */
id|val
op_assign
l_int|0x0c
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* 10MB/s */
id|val
op_assign
l_int|0x19
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* 5MB/s */
id|val
op_assign
l_int|0x32
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* ASYNC */
id|val
op_assign
l_int|0x0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* default 20MB/s */
id|val
op_assign
l_int|0x0c
suffix:semicolon
)brace
id|entry
op_assign
id|nsp32_search_period_entry
c_func
(paren
id|data
comma
id|target
comma
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
OL
l_int|0
op_logical_or
id|trans_mode
op_eq
id|ULTRA20M_MODE
)paren
(brace
multiline_comment|/* search failed... set maximum speed */
id|entry
op_assign
l_int|0
suffix:semicolon
)brace
id|target-&gt;limit_entry
op_assign
id|entry
suffix:semicolon
)brace
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Atmel AT24C01A (drived in 5V) serial EEPROM routines&n; */
DECL|function|nsp32_prom_read
r_static
r_int
id|nsp32_prom_read
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
r_int
id|romaddr
)paren
(brace
r_int
id|i
comma
id|val
suffix:semicolon
multiline_comment|/* start condition */
id|nsp32_prom_start
c_func
(paren
id|data
)paren
suffix:semicolon
multiline_comment|/* device address */
id|nsp32_prom_write
c_func
(paren
id|data
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* 1 */
id|nsp32_prom_write
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* 0 */
id|nsp32_prom_write
c_func
(paren
id|data
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* 1 */
id|nsp32_prom_write
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* 0 */
id|nsp32_prom_write
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* A2: 0 (GND) */
id|nsp32_prom_write
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* A1: 0 (GND) */
id|nsp32_prom_write
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* A0: 0 (GND) */
multiline_comment|/* R/W: W for dummy write */
id|nsp32_prom_write
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* ack */
id|nsp32_prom_write
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* word address */
r_for
c_loop
(paren
id|i
op_assign
l_int|7
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|nsp32_prom_write
c_func
(paren
id|data
comma
(paren
(paren
id|romaddr
op_rshift
id|i
)paren
op_amp
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* ack */
id|nsp32_prom_write
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* start condition */
id|nsp32_prom_start
c_func
(paren
id|data
)paren
suffix:semicolon
multiline_comment|/* device address */
id|nsp32_prom_write
c_func
(paren
id|data
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* 1 */
id|nsp32_prom_write
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* 0 */
id|nsp32_prom_write
c_func
(paren
id|data
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* 1 */
id|nsp32_prom_write
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* 0 */
id|nsp32_prom_write
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* A2: 0 (GND) */
id|nsp32_prom_write
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* A1: 0 (GND) */
id|nsp32_prom_write
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* A0: 0 (GND) */
multiline_comment|/* R/W: R */
id|nsp32_prom_write
c_func
(paren
id|data
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* ack */
id|nsp32_prom_write
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* data... */
id|val
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|7
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|val
op_add_assign
(paren
id|nsp32_prom_fetch
c_func
(paren
id|data
)paren
op_lshift
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* no ack */
id|nsp32_prom_write
c_func
(paren
id|data
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* stop condition */
id|nsp32_prom_stop
c_func
(paren
id|data
)paren
suffix:semicolon
r_return
(paren
id|val
)paren
suffix:semicolon
)brace
DECL|function|nsp32_prom_start
r_static
r_void
id|nsp32_prom_start
(paren
id|nsp32_hw_data
op_star
id|data
)paren
(brace
multiline_comment|/* start condition */
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SCL
comma
l_int|1
)paren
suffix:semicolon
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SDA
comma
l_int|1
)paren
suffix:semicolon
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|ENA
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* output mode */
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SDA
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* keeping SCL=1 and transiting&n;&t;&t;&t;&t;&t; * SDA 1-&gt;0 is start condition */
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SCL
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|nsp32_prom_stop
r_static
r_void
id|nsp32_prom_stop
(paren
id|nsp32_hw_data
op_star
id|data
)paren
(brace
multiline_comment|/* stop condition */
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SCL
comma
l_int|1
)paren
suffix:semicolon
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SDA
comma
l_int|0
)paren
suffix:semicolon
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|ENA
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* output mode */
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SDA
comma
l_int|1
)paren
suffix:semicolon
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SCL
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|nsp32_prom_write
r_static
r_void
id|nsp32_prom_write
(paren
id|nsp32_hw_data
op_star
id|data
comma
r_int
id|val
)paren
(brace
multiline_comment|/* write */
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SDA
comma
id|val
)paren
suffix:semicolon
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SCL
comma
l_int|1
)paren
suffix:semicolon
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SCL
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|nsp32_prom_fetch
r_static
r_int
id|nsp32_prom_fetch
(paren
id|nsp32_hw_data
op_star
id|data
)paren
(brace
r_int
id|val
suffix:semicolon
multiline_comment|/* read */
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|ENA
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* input mode */
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SCL
comma
l_int|1
)paren
suffix:semicolon
id|val
op_assign
id|nsp32_prom_get
c_func
(paren
id|data
comma
id|SDA
)paren
suffix:semicolon
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|SCL
comma
l_int|0
)paren
suffix:semicolon
id|nsp32_prom_set
c_func
(paren
id|data
comma
id|ENA
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* output mode */
r_return
(paren
id|val
)paren
suffix:semicolon
)brace
DECL|function|nsp32_prom_set
r_static
r_inline
r_void
id|nsp32_prom_set
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
r_int
id|bit
comma
r_int
id|val
)paren
(brace
r_int
id|cur
suffix:semicolon
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
r_switch
c_cond
(paren
id|val
)paren
(brace
r_case
l_int|0
suffix:colon
id|cur
op_assign
id|nsp32_index_read1
c_func
(paren
id|base
comma
id|SERIAL_ROM_CTL
)paren
suffix:semicolon
id|nsp32_index_write1
c_func
(paren
id|base
comma
id|SERIAL_ROM_CTL
comma
id|cur
op_amp
op_complement
id|bit
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|cur
op_assign
id|nsp32_index_read1
c_func
(paren
id|base
comma
id|SERIAL_ROM_CTL
)paren
suffix:semicolon
id|nsp32_index_write1
c_func
(paren
id|base
comma
id|SERIAL_ROM_CTL
comma
id|cur
op_or
id|bit
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;val must be 0 or 1&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
DECL|function|nsp32_prom_get
r_static
r_inline
r_int
id|nsp32_prom_get
c_func
(paren
id|nsp32_hw_data
op_star
id|data
comma
r_int
id|bit
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|base
op_assign
id|data-&gt;BaseAddress
suffix:semicolon
id|ret
op_assign
id|nsp32_index_read1
c_func
(paren
id|base
comma
id|SERIAL_ROM_CTL
)paren
op_amp
id|bit
suffix:semicolon
r_switch
c_cond
(paren
id|ret
)paren
(brace
r_case
l_int|0
suffix:colon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDA
suffix:colon
id|ret
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|nsp32_msg
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;return value is not appropriate&quot;
)paren
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/* end */
eof
