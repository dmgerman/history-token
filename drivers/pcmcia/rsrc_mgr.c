multiline_comment|/*&n; * rsrc_mgr.c -- Resource management routines&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License version 2 as&n; * published by the Free Software Foundation.&n; *&n; * The initial developer of the original code is David A. Hinds&n; * &lt;dahinds@users.sourceforge.net&gt;.  Portions created by David A. Hinds&n; * are Copyright (C) 1999 David A. Hinds.  All Rights Reserved.&n; *&n; * (C) 1999&t;&t;David A. Hinds&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;pcmcia/cs_types.h&gt;
macro_line|#include &lt;pcmcia/ss.h&gt;
macro_line|#include &lt;pcmcia/cs.h&gt;
macro_line|#include &lt;pcmcia/bulkmem.h&gt;
macro_line|#include &lt;pcmcia/cistpl.h&gt;
macro_line|#include &quot;cs_internal.h&quot;
multiline_comment|/*====================================================================*/
multiline_comment|/* Parameters that can be set with &squot;insmod&squot; */
DECL|macro|INT_MODULE_PARM
mdefine_line|#define INT_MODULE_PARM(n, v) static int n = v; module_param(n, int, 0444)
id|INT_MODULE_PARM
c_func
(paren
id|probe_mem
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* memory probe? */
macro_line|#ifdef CONFIG_PCMCIA_PROBE
id|INT_MODULE_PARM
c_func
(paren
id|probe_io
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* IO port probe? */
id|INT_MODULE_PARM
c_func
(paren
id|mem_limit
comma
l_int|0x10000
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*======================================================================&n;&n;    The resource_map_t structures are used to track what resources are&n;    available for allocation for PC Card devices.&n;&n;======================================================================*/
DECL|typedef|resource_map_t
r_typedef
r_struct
id|resource_map_t
id|resource_map_t
suffix:semicolon
r_static
id|DECLARE_MUTEX
c_func
(paren
id|rsrc_sem
)paren
suffix:semicolon
DECL|macro|MEM_PROBE_LOW
mdefine_line|#define MEM_PROBE_LOW&t;(1 &lt;&lt; 0)
DECL|macro|MEM_PROBE_HIGH
mdefine_line|#define MEM_PROBE_HIGH&t;(1 &lt;&lt; 1)
macro_line|#ifdef CONFIG_PCMCIA_PROBE
DECL|struct|irq_info_t
r_typedef
r_struct
id|irq_info_t
(brace
DECL|member|Attributes
id|u_int
id|Attributes
suffix:semicolon
DECL|member|time_share
DECL|member|dyn_share
r_int
id|time_share
comma
id|dyn_share
suffix:semicolon
DECL|member|Socket
r_struct
id|pcmcia_socket
op_star
id|Socket
suffix:semicolon
DECL|typedef|irq_info_t
)brace
id|irq_info_t
suffix:semicolon
multiline_comment|/* Table of IRQ assignments */
DECL|variable|irq_table
r_static
id|irq_info_t
id|irq_table
(braket
id|NR_IRQS
)braket
suffix:semicolon
macro_line|#endif
multiline_comment|/*======================================================================&n;&n;    Linux resource management extensions&n;&n;======================================================================*/
r_static
r_struct
id|resource
op_star
DECL|function|make_resource
id|make_resource
c_func
(paren
r_int
r_int
id|b
comma
r_int
r_int
id|n
comma
r_int
id|flags
comma
r_char
op_star
id|name
)paren
(brace
r_struct
id|resource
op_star
id|res
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|res
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
id|memset
c_func
(paren
id|res
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|res
)paren
)paren
suffix:semicolon
id|res-&gt;name
op_assign
id|name
suffix:semicolon
id|res-&gt;start
op_assign
id|b
suffix:semicolon
id|res-&gt;end
op_assign
id|b
op_plus
id|n
op_minus
l_int|1
suffix:semicolon
id|res-&gt;flags
op_assign
id|flags
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
r_static
r_struct
id|resource
op_star
DECL|function|claim_region
id|claim_region
c_func
(paren
r_struct
id|pcmcia_socket
op_star
id|s
comma
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
r_int
id|type
comma
r_char
op_star
id|name
)paren
(brace
r_struct
id|resource
op_star
id|res
comma
op_star
id|parent
suffix:semicolon
id|parent
op_assign
id|type
op_amp
id|IORESOURCE_MEM
ques
c_cond
op_amp
id|iomem_resource
suffix:colon
op_amp
id|ioport_resource
suffix:semicolon
id|res
op_assign
id|make_resource
c_func
(paren
id|base
comma
id|size
comma
id|type
op_or
id|IORESOURCE_BUSY
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
macro_line|#ifdef CONFIG_PCI
r_if
c_cond
(paren
id|s
op_logical_and
id|s-&gt;cb_dev
)paren
id|parent
op_assign
id|pci_find_parent_resource
c_func
(paren
id|s-&gt;cb_dev
comma
id|res
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|parent
op_logical_or
id|request_resource
c_func
(paren
id|parent
comma
id|res
)paren
)paren
(brace
id|kfree
c_func
(paren
id|res
)paren
suffix:semicolon
id|res
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|res
suffix:semicolon
)brace
DECL|function|free_region
r_static
r_void
id|free_region
c_func
(paren
r_struct
id|resource
op_star
id|res
)paren
(brace
r_if
c_cond
(paren
id|res
)paren
(brace
id|release_resource
c_func
(paren
id|res
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|res
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*======================================================================&n;&n;    These manage the internal databases of available resources.&n;    &n;======================================================================*/
DECL|function|add_interval
r_static
r_int
id|add_interval
c_func
(paren
id|resource_map_t
op_star
id|map
comma
id|u_long
id|base
comma
id|u_long
id|num
)paren
(brace
id|resource_map_t
op_star
id|p
comma
op_star
id|q
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|map
suffix:semicolon
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|p
op_ne
id|map
)paren
op_logical_and
(paren
id|p-&gt;base
op_plus
id|p-&gt;num
op_minus
l_int|1
op_ge
id|base
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;next
op_eq
id|map
)paren
op_logical_or
(paren
id|p-&gt;next-&gt;base
OG
id|base
op_plus
id|num
op_minus
l_int|1
)paren
)paren
r_break
suffix:semicolon
)brace
id|q
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|resource_map_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q
)paren
r_return
id|CS_OUT_OF_RESOURCE
suffix:semicolon
id|q-&gt;base
op_assign
id|base
suffix:semicolon
id|q-&gt;num
op_assign
id|num
suffix:semicolon
id|q-&gt;next
op_assign
id|p-&gt;next
suffix:semicolon
id|p-&gt;next
op_assign
id|q
suffix:semicolon
r_return
id|CS_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*====================================================================*/
DECL|function|sub_interval
r_static
r_int
id|sub_interval
c_func
(paren
id|resource_map_t
op_star
id|map
comma
id|u_long
id|base
comma
id|u_long
id|num
)paren
(brace
id|resource_map_t
op_star
id|p
comma
op_star
id|q
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|map
suffix:semicolon
suffix:semicolon
id|p
op_assign
id|q
)paren
(brace
id|q
op_assign
id|p-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|q
op_eq
id|map
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|q-&gt;base
op_plus
id|q-&gt;num
OG
id|base
)paren
op_logical_and
(paren
id|base
op_plus
id|num
OG
id|q-&gt;base
)paren
)paren
(brace
r_if
c_cond
(paren
id|q-&gt;base
op_ge
id|base
)paren
(brace
r_if
c_cond
(paren
id|q-&gt;base
op_plus
id|q-&gt;num
op_le
id|base
op_plus
id|num
)paren
(brace
multiline_comment|/* Delete whole block */
id|p-&gt;next
op_assign
id|q-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|q
)paren
suffix:semicolon
multiline_comment|/* don&squot;t advance the pointer yet */
id|q
op_assign
id|p
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Cut off bit from the front */
id|q-&gt;num
op_assign
id|q-&gt;base
op_plus
id|q-&gt;num
op_minus
id|base
op_minus
id|num
suffix:semicolon
id|q-&gt;base
op_assign
id|base
op_plus
id|num
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|q-&gt;base
op_plus
id|q-&gt;num
op_le
id|base
op_plus
id|num
)paren
(brace
multiline_comment|/* Cut off bit from the end */
id|q-&gt;num
op_assign
id|base
op_minus
id|q-&gt;base
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Split the block into two pieces */
id|p
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|resource_map_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
id|CS_OUT_OF_RESOURCE
suffix:semicolon
id|p-&gt;base
op_assign
id|base
op_plus
id|num
suffix:semicolon
id|p-&gt;num
op_assign
id|q-&gt;base
op_plus
id|q-&gt;num
op_minus
id|p-&gt;base
suffix:semicolon
id|q-&gt;num
op_assign
id|base
op_minus
id|q-&gt;base
suffix:semicolon
id|p-&gt;next
op_assign
id|q-&gt;next
suffix:semicolon
id|q-&gt;next
op_assign
id|p
suffix:semicolon
)brace
)brace
)brace
r_return
id|CS_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*======================================================================&n;&n;    These routines examine a region of IO or memory addresses to&n;    determine what ranges might be genuinely available.&n;    &n;======================================================================*/
macro_line|#ifdef CONFIG_PCMCIA_PROBE
DECL|function|do_io_probe
r_static
r_void
id|do_io_probe
c_func
(paren
r_struct
id|pcmcia_socket
op_star
id|s
comma
id|ioaddr_t
id|base
comma
id|ioaddr_t
id|num
)paren
(brace
r_struct
id|resource
op_star
id|res
suffix:semicolon
id|ioaddr_t
id|i
comma
id|j
comma
id|bad
comma
id|any
suffix:semicolon
id|u_char
op_star
id|b
comma
id|hole
comma
id|most
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs: IO port probe 0x%04x-0x%04x:&quot;
comma
id|base
comma
id|base
op_plus
id|num
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* First, what does a floating port look like? */
id|b
op_assign
id|kmalloc
c_func
(paren
l_int|256
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|b
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;do_io_probe: unable to kmalloc 256 bytes&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|b
comma
l_int|0
comma
l_int|256
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|base
comma
id|most
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|base
op_plus
id|num
suffix:semicolon
id|i
op_add_assign
l_int|8
)paren
(brace
id|res
op_assign
id|claim_region
c_func
(paren
l_int|NULL
comma
id|i
comma
l_int|8
comma
id|IORESOURCE_IO
comma
l_string|&quot;PCMCIA IO probe&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
r_continue
suffix:semicolon
id|hole
op_assign
id|inb
c_func
(paren
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|inb
c_func
(paren
id|i
op_plus
id|j
)paren
op_ne
id|hole
)paren
r_break
suffix:semicolon
id|free_region
c_func
(paren
id|res
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|j
op_eq
l_int|8
)paren
op_logical_and
(paren
op_increment
id|b
(braket
id|hole
)braket
OG
id|b
(braket
id|most
)braket
)paren
)paren
id|most
op_assign
id|hole
suffix:semicolon
r_if
c_cond
(paren
id|b
(braket
id|most
)braket
op_eq
l_int|127
)paren
r_break
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|b
)paren
suffix:semicolon
id|bad
op_assign
id|any
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|base
suffix:semicolon
id|i
OL
id|base
op_plus
id|num
suffix:semicolon
id|i
op_add_assign
l_int|8
)paren
(brace
id|res
op_assign
id|claim_region
c_func
(paren
l_int|NULL
comma
id|i
comma
l_int|8
comma
id|IORESOURCE_IO
comma
l_string|&quot;PCMCIA IO probe&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|inb
c_func
(paren
id|i
op_plus
id|j
)paren
op_ne
id|most
)paren
r_break
suffix:semicolon
id|free_region
c_func
(paren
id|res
)paren
suffix:semicolon
r_if
c_cond
(paren
id|j
OL
l_int|8
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|any
)paren
id|printk
c_func
(paren
l_string|&quot; excluding&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bad
)paren
id|bad
op_assign
id|any
op_assign
id|i
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|bad
)paren
(brace
id|sub_interval
c_func
(paren
op_amp
id|s-&gt;io_db
comma
id|bad
comma
id|i
op_minus
id|bad
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %#04x-%#04x&quot;
comma
id|bad
comma
id|i
op_minus
l_int|1
)paren
suffix:semicolon
id|bad
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|bad
)paren
(brace
r_if
c_cond
(paren
(paren
id|num
OG
l_int|16
)paren
op_logical_and
(paren
id|bad
op_eq
id|base
)paren
op_logical_and
(paren
id|i
op_eq
id|base
op_plus
id|num
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; nothing: probe failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|sub_interval
c_func
(paren
op_amp
id|s-&gt;io_db
comma
id|bad
comma
id|i
op_minus
id|bad
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %#04x-%#04x&quot;
comma
id|bad
comma
id|i
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|any
ques
c_cond
l_string|&quot;&bslash;n&quot;
suffix:colon
l_string|&quot; clean.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*======================================================================&n;&n;    This is tricky... when we set up CIS memory, we try to validate&n;    the memory window space allocations.&n;    &n;======================================================================*/
multiline_comment|/* Validation function for cards with a valid CIS */
DECL|function|readable
r_static
r_int
id|readable
c_func
(paren
r_struct
id|pcmcia_socket
op_star
id|s
comma
r_struct
id|resource
op_star
id|res
comma
id|cisinfo_t
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
id|s-&gt;cis_mem.res
op_assign
id|res
suffix:semicolon
id|s-&gt;cis_virt
op_assign
id|ioremap
c_func
(paren
id|res-&gt;start
comma
id|s-&gt;map_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;cis_virt
)paren
(brace
id|ret
op_assign
id|pccard_validate_cis
c_func
(paren
id|s
comma
id|BIND_FN_ALL
comma
id|info
)paren
suffix:semicolon
multiline_comment|/* invalidate mapping and CIS cache */
id|iounmap
c_func
(paren
id|s-&gt;cis_virt
)paren
suffix:semicolon
id|s-&gt;cis_virt
op_assign
l_int|NULL
suffix:semicolon
id|destroy_cis_cache
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
id|s-&gt;cis_mem.res
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_ne
l_int|0
)paren
op_logical_or
(paren
id|info-&gt;Chains
op_eq
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Validation function for simple memory cards */
DECL|function|checksum
r_static
r_int
id|checksum
c_func
(paren
r_struct
id|pcmcia_socket
op_star
id|s
comma
r_struct
id|resource
op_star
id|res
)paren
(brace
id|pccard_mem_map
id|map
suffix:semicolon
r_int
id|i
comma
id|a
op_assign
l_int|0
comma
id|b
op_assign
op_minus
l_int|1
comma
id|d
suffix:semicolon
r_void
id|__iomem
op_star
id|virt
suffix:semicolon
id|virt
op_assign
id|ioremap
c_func
(paren
id|res-&gt;start
comma
id|s-&gt;map_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|virt
)paren
(brace
id|map.map
op_assign
l_int|0
suffix:semicolon
id|map.flags
op_assign
id|MAP_ACTIVE
suffix:semicolon
id|map.speed
op_assign
l_int|0
suffix:semicolon
id|map.res
op_assign
id|res
suffix:semicolon
id|map.card_start
op_assign
l_int|0
suffix:semicolon
id|s-&gt;ops
op_member_access_from_pointer
id|set_mem_map
c_func
(paren
id|s
comma
op_amp
id|map
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t bother checking every word... */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|s-&gt;map_size
suffix:semicolon
id|i
op_add_assign
l_int|44
)paren
(brace
id|d
op_assign
id|readl
c_func
(paren
id|virt
op_plus
id|i
)paren
suffix:semicolon
id|a
op_add_assign
id|d
suffix:semicolon
id|b
op_and_assign
id|d
suffix:semicolon
)brace
id|map.flags
op_assign
l_int|0
suffix:semicolon
id|s-&gt;ops
op_member_access_from_pointer
id|set_mem_map
c_func
(paren
id|s
comma
op_amp
id|map
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|virt
)paren
suffix:semicolon
)brace
r_return
(paren
id|b
op_eq
op_minus
l_int|1
)paren
ques
c_cond
op_minus
l_int|1
suffix:colon
(paren
id|a
op_rshift
l_int|1
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cis_readable
id|cis_readable
c_func
(paren
r_struct
id|pcmcia_socket
op_star
id|s
comma
r_int
r_int
id|base
comma
r_int
r_int
id|size
)paren
(brace
r_struct
id|resource
op_star
id|res1
comma
op_star
id|res2
suffix:semicolon
id|cisinfo_t
id|info1
comma
id|info2
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|res1
op_assign
id|claim_region
c_func
(paren
id|s
comma
id|base
comma
id|size
op_div
l_int|2
comma
id|IORESOURCE_MEM
comma
l_string|&quot;cs memory probe&quot;
)paren
suffix:semicolon
id|res2
op_assign
id|claim_region
c_func
(paren
id|s
comma
id|base
op_plus
id|size
op_div
l_int|2
comma
id|size
op_div
l_int|2
comma
id|IORESOURCE_MEM
comma
l_string|&quot;cs memory probe&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res1
op_logical_and
id|res2
)paren
(brace
id|ret
op_assign
id|readable
c_func
(paren
id|s
comma
id|res1
comma
op_amp
id|info1
)paren
suffix:semicolon
id|ret
op_add_assign
id|readable
c_func
(paren
id|s
comma
id|res2
comma
op_amp
id|info2
)paren
suffix:semicolon
)brace
id|free_region
c_func
(paren
id|res2
)paren
suffix:semicolon
id|free_region
c_func
(paren
id|res1
)paren
suffix:semicolon
r_return
(paren
id|ret
op_eq
l_int|2
)paren
op_logical_and
(paren
id|info1.Chains
op_eq
id|info2.Chains
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|checksum_match
id|checksum_match
c_func
(paren
r_struct
id|pcmcia_socket
op_star
id|s
comma
r_int
r_int
id|base
comma
r_int
r_int
id|size
)paren
(brace
r_struct
id|resource
op_star
id|res1
comma
op_star
id|res2
suffix:semicolon
r_int
id|a
op_assign
op_minus
l_int|1
comma
id|b
op_assign
op_minus
l_int|1
suffix:semicolon
id|res1
op_assign
id|claim_region
c_func
(paren
id|s
comma
id|base
comma
id|size
op_div
l_int|2
comma
id|IORESOURCE_MEM
comma
l_string|&quot;cs memory probe&quot;
)paren
suffix:semicolon
id|res2
op_assign
id|claim_region
c_func
(paren
id|s
comma
id|base
op_plus
id|size
op_div
l_int|2
comma
id|size
op_div
l_int|2
comma
id|IORESOURCE_MEM
comma
l_string|&quot;cs memory probe&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res1
op_logical_and
id|res2
)paren
(brace
id|a
op_assign
id|checksum
c_func
(paren
id|s
comma
id|res1
)paren
suffix:semicolon
id|b
op_assign
id|checksum
c_func
(paren
id|s
comma
id|res2
)paren
suffix:semicolon
)brace
id|free_region
c_func
(paren
id|res2
)paren
suffix:semicolon
id|free_region
c_func
(paren
id|res1
)paren
suffix:semicolon
r_return
(paren
id|a
op_eq
id|b
)paren
op_logical_and
(paren
id|a
op_ge
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*======================================================================&n;&n;    The memory probe.  If the memory list includes a 64K-aligned block&n;    below 1MB, we probe in 64K chunks, and as soon as we accumulate at&n;    least mem_limit free space, we quit.&n;    &n;======================================================================*/
DECL|function|do_mem_probe
r_static
r_int
id|do_mem_probe
c_func
(paren
id|u_long
id|base
comma
id|u_long
id|num
comma
r_struct
id|pcmcia_socket
op_star
id|s
)paren
(brace
id|u_long
id|i
comma
id|j
comma
id|bad
comma
id|fail
comma
id|step
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cs: memory probe 0x%06lx-0x%06lx:&quot;
comma
id|base
comma
id|base
op_plus
id|num
op_minus
l_int|1
)paren
suffix:semicolon
id|bad
op_assign
id|fail
op_assign
l_int|0
suffix:semicolon
id|step
op_assign
(paren
id|num
OL
l_int|0x20000
)paren
ques
c_cond
l_int|0x2000
suffix:colon
(paren
(paren
id|num
op_rshift
l_int|4
)paren
op_amp
op_complement
l_int|0x1fff
)paren
suffix:semicolon
multiline_comment|/* cis_readable wants to map 2x map_size */
r_if
c_cond
(paren
id|step
OL
l_int|2
op_star
id|s-&gt;map_size
)paren
id|step
op_assign
l_int|2
op_star
id|s-&gt;map_size
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|j
op_assign
id|base
suffix:semicolon
id|i
OL
id|base
op_plus
id|num
suffix:semicolon
id|i
op_assign
id|j
op_plus
id|step
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fail
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
id|i
suffix:semicolon
id|j
OL
id|base
op_plus
id|num
suffix:semicolon
id|j
op_add_assign
id|step
)paren
(brace
r_if
c_cond
(paren
id|cis_readable
c_func
(paren
id|s
comma
id|j
comma
id|step
)paren
)paren
r_break
suffix:semicolon
)brace
id|fail
op_assign
(paren
(paren
id|i
op_eq
id|base
)paren
op_logical_and
(paren
id|j
op_eq
id|base
op_plus
id|num
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fail
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
id|i
suffix:semicolon
id|j
OL
id|base
op_plus
id|num
suffix:semicolon
id|j
op_add_assign
l_int|2
op_star
id|step
)paren
r_if
c_cond
(paren
id|checksum_match
c_func
(paren
id|s
comma
id|j
comma
id|step
)paren
op_logical_and
id|checksum_match
c_func
(paren
id|s
comma
id|j
op_plus
id|step
comma
id|step
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ne
id|j
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bad
)paren
id|printk
c_func
(paren
l_string|&quot; excluding&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %#05lx-%#05lx&quot;
comma
id|i
comma
id|j
op_minus
l_int|1
)paren
suffix:semicolon
id|sub_interval
c_func
(paren
op_amp
id|s-&gt;mem_db
comma
id|i
comma
id|j
op_minus
id|i
)paren
suffix:semicolon
id|bad
op_add_assign
id|j
op_minus
id|i
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|bad
ques
c_cond
l_string|&quot;&bslash;n&quot;
suffix:colon
l_string|&quot; clean.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|num
op_minus
id|bad
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PCMCIA_PROBE
DECL|function|inv_probe
r_static
id|u_long
id|inv_probe
c_func
(paren
id|resource_map_t
op_star
id|m
comma
r_struct
id|pcmcia_socket
op_star
id|s
)paren
(brace
id|u_long
id|ok
suffix:semicolon
r_if
c_cond
(paren
id|m
op_eq
op_amp
id|s-&gt;mem_db
)paren
r_return
l_int|0
suffix:semicolon
id|ok
op_assign
id|inv_probe
c_func
(paren
id|m-&gt;next
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ok
)paren
(brace
r_if
c_cond
(paren
id|m-&gt;base
op_ge
l_int|0x100000
)paren
id|sub_interval
c_func
(paren
op_amp
id|s-&gt;mem_db
comma
id|m-&gt;base
comma
id|m-&gt;num
)paren
suffix:semicolon
r_return
id|ok
suffix:semicolon
)brace
r_if
c_cond
(paren
id|m-&gt;base
OL
l_int|0x100000
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|do_mem_probe
c_func
(paren
id|m-&gt;base
comma
id|m-&gt;num
comma
id|s
)paren
suffix:semicolon
)brace
DECL|function|validate_mem
r_static
r_void
id|validate_mem
c_func
(paren
r_struct
id|pcmcia_socket
op_star
id|s
comma
r_int
r_int
id|probe_mask
)paren
(brace
id|resource_map_t
op_star
id|m
comma
id|mm
suffix:semicolon
r_static
id|u_char
id|order
(braket
)braket
op_assign
(brace
l_int|0xd0
comma
l_int|0xe0
comma
l_int|0xc0
comma
l_int|0xf0
)brace
suffix:semicolon
id|u_long
id|b
comma
id|i
comma
id|ok
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We do up to four passes through the list */
r_if
c_cond
(paren
id|probe_mask
op_amp
id|MEM_PROBE_HIGH
)paren
(brace
r_if
c_cond
(paren
id|inv_probe
c_func
(paren
id|s-&gt;mem_db.next
comma
id|s
)paren
OG
l_int|0
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;cs: warning: no high memory space &quot;
l_string|&quot;available!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|probe_mask
op_amp
id|MEM_PROBE_LOW
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
id|s-&gt;mem_db.next
suffix:semicolon
id|m
op_ne
op_amp
id|s-&gt;mem_db
suffix:semicolon
id|m
op_assign
id|mm.next
)paren
(brace
id|mm
op_assign
op_star
id|m
suffix:semicolon
multiline_comment|/* Only probe &lt; 1 MB */
r_if
c_cond
(paren
id|mm.base
op_ge
l_int|0x100000
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mm.base
op_or
id|mm.num
)paren
op_amp
l_int|0xffff
)paren
(brace
id|ok
op_add_assign
id|do_mem_probe
c_func
(paren
id|mm.base
comma
id|mm.num
comma
id|s
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Special probe for 64K-aligned block */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|b
op_assign
id|order
(braket
id|i
)braket
op_lshift
l_int|12
suffix:semicolon
r_if
c_cond
(paren
(paren
id|b
op_ge
id|mm.base
)paren
op_logical_and
(paren
id|b
op_plus
l_int|0x10000
op_le
id|mm.base
op_plus
id|mm.num
)paren
)paren
(brace
r_if
c_cond
(paren
id|ok
op_ge
id|mem_limit
)paren
id|sub_interval
c_func
(paren
op_amp
id|s-&gt;mem_db
comma
id|b
comma
l_int|0x10000
)paren
suffix:semicolon
r_else
id|ok
op_add_assign
id|do_mem_probe
c_func
(paren
id|b
comma
l_int|0x10000
comma
id|s
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
macro_line|#else /* CONFIG_PCMCIA_PROBE */
DECL|function|validate_mem
r_static
r_void
id|validate_mem
c_func
(paren
r_struct
id|pcmcia_socket
op_star
id|s
comma
r_int
r_int
id|probe_mask
)paren
(brace
id|resource_map_t
op_star
id|m
comma
id|mm
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
id|s-&gt;mem_db.next
suffix:semicolon
id|m
op_ne
op_amp
id|s-&gt;mem_db
suffix:semicolon
id|m
op_assign
id|mm.next
)paren
(brace
id|mm
op_assign
op_star
id|m
suffix:semicolon
r_if
c_cond
(paren
id|do_mem_probe
c_func
(paren
id|mm.base
comma
id|mm.num
comma
id|s
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_PCMCIA_PROBE */
multiline_comment|/*&n; * Locking note: this is the only place where we take&n; * both rsrc_sem and skt_sem.&n; */
DECL|function|pcmcia_nonstatic_validate_mem
r_static
r_void
id|pcmcia_nonstatic_validate_mem
c_func
(paren
r_struct
id|pcmcia_socket
op_star
id|s
)paren
(brace
r_if
c_cond
(paren
id|probe_mem
)paren
(brace
r_int
r_int
id|probe_mask
suffix:semicolon
id|down
c_func
(paren
op_amp
id|rsrc_sem
)paren
suffix:semicolon
id|probe_mask
op_assign
id|MEM_PROBE_LOW
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;features
op_amp
id|SS_CAP_PAGE_REGS
)paren
id|probe_mask
op_assign
id|MEM_PROBE_HIGH
suffix:semicolon
r_if
c_cond
(paren
id|probe_mask
op_amp
op_complement
id|s-&gt;rsrc_mem_probe
)paren
(brace
id|s-&gt;rsrc_mem_probe
op_or_assign
id|probe_mask
suffix:semicolon
id|down
c_func
(paren
op_amp
id|s-&gt;skt_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;state
op_amp
id|SOCKET_PRESENT
)paren
id|validate_mem
c_func
(paren
id|s
comma
id|probe_mask
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|s-&gt;skt_sem
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|rsrc_sem
)paren
suffix:semicolon
)brace
)brace
DECL|struct|pcmcia_align_data
r_struct
id|pcmcia_align_data
(brace
DECL|member|mask
r_int
r_int
id|mask
suffix:semicolon
DECL|member|offset
r_int
r_int
id|offset
suffix:semicolon
DECL|member|map
id|resource_map_t
op_star
id|map
suffix:semicolon
)brace
suffix:semicolon
r_static
r_void
DECL|function|pcmcia_common_align
id|pcmcia_common_align
c_func
(paren
r_void
op_star
id|align_data
comma
r_struct
id|resource
op_star
id|res
comma
r_int
r_int
id|size
comma
r_int
r_int
id|align
)paren
(brace
r_struct
id|pcmcia_align_data
op_star
id|data
op_assign
id|align_data
suffix:semicolon
r_int
r_int
id|start
suffix:semicolon
multiline_comment|/*&n;&t; * Ensure that we have the correct start address&n;&t; */
id|start
op_assign
(paren
id|res-&gt;start
op_amp
op_complement
id|data-&gt;mask
)paren
op_plus
id|data-&gt;offset
suffix:semicolon
r_if
c_cond
(paren
id|start
OL
id|res-&gt;start
)paren
id|start
op_add_assign
id|data-&gt;mask
op_plus
l_int|1
suffix:semicolon
id|res-&gt;start
op_assign
id|start
suffix:semicolon
)brace
r_static
r_void
DECL|function|pcmcia_align
id|pcmcia_align
c_func
(paren
r_void
op_star
id|align_data
comma
r_struct
id|resource
op_star
id|res
comma
r_int
r_int
id|size
comma
r_int
r_int
id|align
)paren
(brace
r_struct
id|pcmcia_align_data
op_star
id|data
op_assign
id|align_data
suffix:semicolon
id|resource_map_t
op_star
id|m
suffix:semicolon
id|pcmcia_common_align
c_func
(paren
id|data
comma
id|res
comma
id|size
comma
id|align
)paren
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
id|data-&gt;map-&gt;next
suffix:semicolon
id|m
op_ne
id|data-&gt;map
suffix:semicolon
id|m
op_assign
id|m-&gt;next
)paren
(brace
r_int
r_int
id|start
op_assign
id|m-&gt;base
suffix:semicolon
r_int
r_int
id|end
op_assign
id|m-&gt;base
op_plus
id|m-&gt;num
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the lower resources are not available, try aligning&n;&t;&t; * to this entry of the resource database to see if it&squot;ll&n;&t;&t; * fit here.&n;&t;&t; */
r_if
c_cond
(paren
id|res-&gt;start
OL
id|start
)paren
(brace
id|res-&gt;start
op_assign
id|start
suffix:semicolon
id|pcmcia_common_align
c_func
(paren
id|data
comma
id|res
comma
id|size
comma
id|align
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If we&squot;re above the area which was passed in, there&squot;s&n;&t;&t; * no point proceeding.&n;&t;&t; */
r_if
c_cond
(paren
id|res-&gt;start
op_ge
id|res-&gt;end
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res-&gt;start
op_plus
id|size
op_minus
l_int|1
)paren
op_le
id|end
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we failed to find something suitable, ensure we fail.&n;&t; */
r_if
c_cond
(paren
id|m
op_eq
id|data-&gt;map
)paren
id|res-&gt;start
op_assign
id|res-&gt;end
suffix:semicolon
)brace
multiline_comment|/*&n; * Adjust an existing IO region allocation, but making sure that we don&squot;t&n; * encroach outside the resources which the user supplied.&n; */
DECL|function|nonstatic_adjust_io_region
r_static
r_int
id|nonstatic_adjust_io_region
c_func
(paren
r_struct
id|resource
op_star
id|res
comma
r_int
r_int
id|r_start
comma
r_int
r_int
id|r_end
comma
r_struct
id|pcmcia_socket
op_star
id|s
)paren
(brace
id|resource_map_t
op_star
id|m
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|down
c_func
(paren
op_amp
id|rsrc_sem
)paren
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
id|s-&gt;io_db.next
suffix:semicolon
id|m
op_ne
op_amp
id|s-&gt;io_db
suffix:semicolon
id|m
op_assign
id|m-&gt;next
)paren
(brace
r_int
r_int
id|start
op_assign
id|m-&gt;base
suffix:semicolon
r_int
r_int
id|end
op_assign
id|m-&gt;base
op_plus
id|m-&gt;num
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|start
OG
id|r_start
op_logical_or
id|r_end
OG
id|end
)paren
r_continue
suffix:semicolon
id|ret
op_assign
id|adjust_resource
c_func
(paren
id|res
comma
id|r_start
comma
id|r_end
op_minus
id|r_start
op_plus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|rsrc_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*======================================================================&n;&n;    These find ranges of I/O ports or memory addresses that are not&n;    currently allocated by other devices.&n;&n;    The &squot;align&squot; field should reflect the number of bits of address&n;    that need to be preserved from the initial value of *base.  It&n;    should be a power of two, greater than or equal to &squot;num&squot;.  A value&n;    of 0 means that all bits of *base are significant.  *base should&n;    also be strictly less than &squot;align&squot;.&n;    &n;======================================================================*/
DECL|function|nonstatic_find_io_region
r_struct
id|resource
op_star
id|nonstatic_find_io_region
c_func
(paren
r_int
r_int
id|base
comma
r_int
id|num
comma
r_int
r_int
id|align
comma
r_struct
id|pcmcia_socket
op_star
id|s
)paren
(brace
r_struct
id|resource
op_star
id|res
op_assign
id|make_resource
c_func
(paren
l_int|0
comma
id|num
comma
id|IORESOURCE_IO
comma
id|s-&gt;dev.class_id
)paren
suffix:semicolon
r_struct
id|pcmcia_align_data
id|data
suffix:semicolon
r_int
r_int
id|min
op_assign
id|base
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|align
op_eq
l_int|0
)paren
id|align
op_assign
l_int|0x10000
suffix:semicolon
id|data.mask
op_assign
id|align
op_minus
l_int|1
suffix:semicolon
id|data.offset
op_assign
id|base
op_amp
id|data.mask
suffix:semicolon
id|data.map
op_assign
op_amp
id|s-&gt;io_db
suffix:semicolon
id|down
c_func
(paren
op_amp
id|rsrc_sem
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
r_if
c_cond
(paren
id|s-&gt;cb_dev
)paren
(brace
id|ret
op_assign
id|pci_bus_alloc_resource
c_func
(paren
id|s-&gt;cb_dev-&gt;bus
comma
id|res
comma
id|num
comma
l_int|1
comma
id|min
comma
l_int|0
comma
id|pcmcia_align
comma
op_amp
id|data
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
id|ret
op_assign
id|allocate_resource
c_func
(paren
op_amp
id|ioport_resource
comma
id|res
comma
id|num
comma
id|min
comma
op_complement
l_int|0UL
comma
l_int|1
comma
id|pcmcia_align
comma
op_amp
id|data
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|rsrc_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|res
)paren
suffix:semicolon
id|res
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
DECL|function|nonstatic_find_mem_region
r_struct
id|resource
op_star
id|nonstatic_find_mem_region
c_func
(paren
id|u_long
id|base
comma
id|u_long
id|num
comma
id|u_long
id|align
comma
r_int
id|low
comma
r_struct
id|pcmcia_socket
op_star
id|s
)paren
(brace
r_struct
id|resource
op_star
id|res
op_assign
id|make_resource
c_func
(paren
l_int|0
comma
id|num
comma
id|IORESOURCE_MEM
comma
id|s-&gt;dev.class_id
)paren
suffix:semicolon
r_struct
id|pcmcia_align_data
id|data
suffix:semicolon
r_int
r_int
id|min
comma
id|max
suffix:semicolon
r_int
id|ret
comma
id|i
suffix:semicolon
id|low
op_assign
id|low
op_logical_or
op_logical_neg
(paren
id|s-&gt;features
op_amp
id|SS_CAP_PAGE_REGS
)paren
suffix:semicolon
id|data.mask
op_assign
id|align
op_minus
l_int|1
suffix:semicolon
id|data.offset
op_assign
id|base
op_amp
id|data.mask
suffix:semicolon
id|data.map
op_assign
op_amp
id|s-&gt;mem_db
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|low
)paren
(brace
id|max
op_assign
l_int|0x100000UL
suffix:semicolon
id|min
op_assign
id|base
OL
id|max
ques
c_cond
id|base
suffix:colon
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|max
op_assign
op_complement
l_int|0UL
suffix:semicolon
id|min
op_assign
l_int|0x100000UL
op_plus
id|base
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|rsrc_sem
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
r_if
c_cond
(paren
id|s-&gt;cb_dev
)paren
(brace
id|ret
op_assign
id|pci_bus_alloc_resource
c_func
(paren
id|s-&gt;cb_dev-&gt;bus
comma
id|res
comma
id|num
comma
l_int|1
comma
id|min
comma
l_int|0
comma
id|pcmcia_align
comma
op_amp
id|data
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
id|ret
op_assign
id|allocate_resource
c_func
(paren
op_amp
id|iomem_resource
comma
id|res
comma
id|num
comma
id|min
comma
id|max
comma
l_int|1
comma
id|pcmcia_align
comma
op_amp
id|data
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|rsrc_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
op_logical_or
id|low
)paren
r_break
suffix:semicolon
id|low
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|res
)paren
suffix:semicolon
id|res
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/*======================================================================&n;&n;    This checks to see if an interrupt is available, with support&n;    for interrupt sharing.  We don&squot;t support reserving interrupts&n;    yet.  If the interrupt is available, we allocate it.&n;    &n;======================================================================*/
macro_line|#ifdef CONFIG_PCMCIA_PROBE
DECL|function|fake_irq
r_static
id|irqreturn_t
id|fake_irq
c_func
(paren
r_int
id|i
comma
r_void
op_star
id|d
comma
r_struct
id|pt_regs
op_star
id|r
)paren
(brace
r_return
id|IRQ_NONE
suffix:semicolon
)brace
DECL|function|check_irq
r_static
r_inline
r_int
id|check_irq
c_func
(paren
r_int
id|irq
)paren
(brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|irq
comma
id|fake_irq
comma
l_int|0
comma
l_string|&quot;bogus&quot;
comma
l_int|NULL
)paren
op_ne
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|free_irq
c_func
(paren
id|irq
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|try_irq
r_int
id|try_irq
c_func
(paren
id|u_int
id|Attributes
comma
r_int
id|irq
comma
r_int
id|specific
)paren
(brace
id|irq_info_t
op_star
id|info
op_assign
op_amp
id|irq_table
(braket
id|irq
)braket
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|down
c_func
(paren
op_amp
id|rsrc_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;Attributes
op_amp
id|RES_ALLOCATED
)paren
(brace
r_switch
c_cond
(paren
id|Attributes
op_amp
id|IRQ_TYPE
)paren
(brace
r_case
id|IRQ_TYPE_EXCLUSIVE
suffix:colon
id|ret
op_assign
id|CS_IN_USE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRQ_TYPE_TIME
suffix:colon
r_if
c_cond
(paren
(paren
id|info-&gt;Attributes
op_amp
id|RES_IRQ_TYPE
)paren
op_ne
id|RES_IRQ_TYPE_TIME
)paren
(brace
id|ret
op_assign
id|CS_IN_USE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Attributes
op_amp
id|IRQ_FIRST_SHARED
)paren
(brace
id|ret
op_assign
id|CS_BAD_ATTRIBUTE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|info-&gt;Attributes
op_or_assign
id|RES_IRQ_TYPE_TIME
op_or
id|RES_ALLOCATED
suffix:semicolon
id|info-&gt;time_share
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRQ_TYPE_DYNAMIC_SHARING
suffix:colon
r_if
c_cond
(paren
(paren
id|info-&gt;Attributes
op_amp
id|RES_IRQ_TYPE
)paren
op_ne
id|RES_IRQ_TYPE_DYNAMIC
)paren
(brace
id|ret
op_assign
id|CS_IN_USE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Attributes
op_amp
id|IRQ_FIRST_SHARED
)paren
(brace
id|ret
op_assign
id|CS_BAD_ATTRIBUTE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|info-&gt;Attributes
op_or_assign
id|RES_IRQ_TYPE_DYNAMIC
op_or
id|RES_ALLOCATED
suffix:semicolon
id|info-&gt;dyn_share
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|info-&gt;Attributes
op_amp
id|RES_RESERVED
)paren
op_logical_and
op_logical_neg
id|specific
)paren
(brace
id|ret
op_assign
id|CS_IN_USE
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_irq
c_func
(paren
id|irq
)paren
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
id|CS_IN_USE
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|Attributes
op_amp
id|IRQ_TYPE
)paren
(brace
r_case
id|IRQ_TYPE_EXCLUSIVE
suffix:colon
id|info-&gt;Attributes
op_or_assign
id|RES_ALLOCATED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRQ_TYPE_TIME
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|Attributes
op_amp
id|IRQ_FIRST_SHARED
)paren
)paren
(brace
id|ret
op_assign
id|CS_BAD_ATTRIBUTE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|info-&gt;Attributes
op_or_assign
id|RES_IRQ_TYPE_TIME
op_or
id|RES_ALLOCATED
suffix:semicolon
id|info-&gt;time_share
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRQ_TYPE_DYNAMIC_SHARING
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|Attributes
op_amp
id|IRQ_FIRST_SHARED
)paren
)paren
(brace
id|ret
op_assign
id|CS_BAD_ATTRIBUTE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|info-&gt;Attributes
op_or_assign
id|RES_IRQ_TYPE_DYNAMIC
op_or
id|RES_ALLOCATED
suffix:semicolon
id|info-&gt;dyn_share
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|rsrc_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*====================================================================*/
macro_line|#ifdef CONFIG_PCMCIA_PROBE
DECL|function|undo_irq
r_void
id|undo_irq
c_func
(paren
id|u_int
id|Attributes
comma
r_int
id|irq
)paren
(brace
id|irq_info_t
op_star
id|info
suffix:semicolon
id|info
op_assign
op_amp
id|irq_table
(braket
id|irq
)braket
suffix:semicolon
id|down
c_func
(paren
op_amp
id|rsrc_sem
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|Attributes
op_amp
id|IRQ_TYPE
)paren
(brace
r_case
id|IRQ_TYPE_EXCLUSIVE
suffix:colon
id|info-&gt;Attributes
op_and_assign
id|RES_RESERVED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRQ_TYPE_TIME
suffix:colon
id|info-&gt;time_share
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;time_share
op_eq
l_int|0
)paren
id|info-&gt;Attributes
op_and_assign
id|RES_RESERVED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IRQ_TYPE_DYNAMIC_SHARING
suffix:colon
id|info-&gt;dyn_share
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;dyn_share
op_eq
l_int|0
)paren
id|info-&gt;Attributes
op_and_assign
id|RES_RESERVED
suffix:semicolon
r_break
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|rsrc_sem
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*======================================================================&n;&n;    The various adjust_* calls form the external interface to the&n;    resource database.&n;    &n;======================================================================*/
DECL|function|adjust_memory
r_static
r_int
id|adjust_memory
c_func
(paren
r_struct
id|pcmcia_socket
op_star
id|s
comma
id|adjust_t
op_star
id|adj
)paren
(brace
id|u_long
id|base
comma
id|num
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|base
op_assign
id|adj-&gt;resource.memory.Base
suffix:semicolon
id|num
op_assign
id|adj-&gt;resource.memory.Size
suffix:semicolon
r_if
c_cond
(paren
(paren
id|num
op_eq
l_int|0
)paren
op_logical_or
(paren
id|base
op_plus
id|num
op_minus
l_int|1
OL
id|base
)paren
)paren
r_return
id|CS_BAD_SIZE
suffix:semicolon
id|ret
op_assign
id|CS_SUCCESS
suffix:semicolon
id|down
c_func
(paren
op_amp
id|rsrc_sem
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|adj-&gt;Action
)paren
(brace
r_case
id|ADD_MANAGED_RESOURCE
suffix:colon
id|ret
op_assign
id|add_interval
c_func
(paren
op_amp
id|s-&gt;mem_db
comma
id|base
comma
id|num
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REMOVE_MANAGED_RESOURCE
suffix:colon
id|ret
op_assign
id|sub_interval
c_func
(paren
op_amp
id|s-&gt;mem_db
comma
id|base
comma
id|num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|CS_SUCCESS
)paren
(brace
r_struct
id|pcmcia_socket
op_star
id|socket
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|pcmcia_socket_list_rwsem
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|socket
comma
op_amp
id|pcmcia_socket_list
comma
id|socket_list
)paren
id|release_cis_mem
c_func
(paren
id|socket
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|pcmcia_socket_list_rwsem
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
id|CS_UNSUPPORTED_FUNCTION
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|rsrc_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*====================================================================*/
DECL|function|adjust_io
r_static
r_int
id|adjust_io
c_func
(paren
r_struct
id|pcmcia_socket
op_star
id|s
comma
id|adjust_t
op_star
id|adj
)paren
(brace
r_int
id|base
comma
id|num
comma
id|ret
op_assign
id|CS_SUCCESS
suffix:semicolon
id|base
op_assign
id|adj-&gt;resource.io.BasePort
suffix:semicolon
id|num
op_assign
id|adj-&gt;resource.io.NumPorts
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base
OL
l_int|0
)paren
op_logical_or
(paren
id|base
OG
l_int|0xffff
)paren
)paren
r_return
id|CS_BAD_BASE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|num
op_le
l_int|0
)paren
op_logical_or
(paren
id|base
op_plus
id|num
OG
l_int|0x10000
)paren
op_logical_or
(paren
id|base
op_plus
id|num
op_le
id|base
)paren
)paren
r_return
id|CS_BAD_SIZE
suffix:semicolon
id|down
c_func
(paren
op_amp
id|rsrc_sem
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|adj-&gt;Action
)paren
(brace
r_case
id|ADD_MANAGED_RESOURCE
suffix:colon
r_if
c_cond
(paren
id|add_interval
c_func
(paren
op_amp
id|s-&gt;io_db
comma
id|base
comma
id|num
)paren
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
id|CS_IN_USE
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PCMCIA_PROBE
r_if
c_cond
(paren
id|probe_io
)paren
id|do_io_probe
c_func
(paren
id|s
comma
id|base
comma
id|num
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|REMOVE_MANAGED_RESOURCE
suffix:colon
id|sub_interval
c_func
(paren
op_amp
id|s-&gt;io_db
comma
id|base
comma
id|num
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
id|CS_UNSUPPORTED_FUNCTION
suffix:semicolon
r_break
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|rsrc_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*====================================================================*/
DECL|function|adjust_irq
r_static
r_int
id|adjust_irq
c_func
(paren
id|adjust_t
op_star
id|adj
)paren
(brace
r_int
id|ret
op_assign
id|CS_SUCCESS
suffix:semicolon
macro_line|#ifdef CONFIG_PCMCIA_PROBE
r_int
id|irq
suffix:semicolon
id|irq_info_t
op_star
id|info
suffix:semicolon
id|irq
op_assign
id|adj-&gt;resource.irq.IRQ
suffix:semicolon
r_if
c_cond
(paren
(paren
id|irq
OL
l_int|0
)paren
op_logical_or
(paren
id|irq
OG
l_int|15
)paren
)paren
r_return
id|CS_BAD_IRQ
suffix:semicolon
id|info
op_assign
op_amp
id|irq_table
(braket
id|irq
)braket
suffix:semicolon
id|down
c_func
(paren
op_amp
id|rsrc_sem
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|adj-&gt;Action
)paren
(brace
r_case
id|ADD_MANAGED_RESOURCE
suffix:colon
r_if
c_cond
(paren
id|info-&gt;Attributes
op_amp
id|RES_REMOVED
)paren
id|info-&gt;Attributes
op_and_assign
op_complement
(paren
id|RES_REMOVED
op_or
id|RES_ALLOCATED
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|adj-&gt;Attributes
op_amp
id|RES_ALLOCATED
)paren
(brace
id|ret
op_assign
id|CS_IN_USE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|adj-&gt;Attributes
op_amp
id|RES_RESERVED
)paren
id|info-&gt;Attributes
op_or_assign
id|RES_RESERVED
suffix:semicolon
r_else
id|info-&gt;Attributes
op_and_assign
op_complement
id|RES_RESERVED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REMOVE_MANAGED_RESOURCE
suffix:colon
r_if
c_cond
(paren
id|info-&gt;Attributes
op_amp
id|RES_REMOVED
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;Attributes
op_amp
id|RES_ALLOCATED
)paren
(brace
id|ret
op_assign
id|CS_IN_USE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|info-&gt;Attributes
op_or_assign
id|RES_ALLOCATED
op_or
id|RES_REMOVED
suffix:semicolon
id|info-&gt;Attributes
op_and_assign
op_complement
id|RES_RESERVED
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
id|CS_UNSUPPORTED_FUNCTION
suffix:semicolon
r_break
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|rsrc_sem
)paren
suffix:semicolon
macro_line|#endif
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*====================================================================*/
DECL|function|pcmcia_adjust_resource_info
r_int
id|pcmcia_adjust_resource_info
c_func
(paren
id|adjust_t
op_star
id|adj
)paren
(brace
r_struct
id|pcmcia_socket
op_star
id|s
suffix:semicolon
r_int
id|ret
op_assign
id|CS_UNSUPPORTED_FUNCTION
suffix:semicolon
r_if
c_cond
(paren
id|adj-&gt;Resource
op_eq
id|RES_IRQ
)paren
r_return
id|adjust_irq
c_func
(paren
id|adj
)paren
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|pcmcia_socket_list_rwsem
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|s
comma
op_amp
id|pcmcia_socket_list
comma
id|socket_list
)paren
(brace
r_switch
c_cond
(paren
id|adj-&gt;Resource
)paren
(brace
r_case
id|RES_MEMORY_RANGE
suffix:colon
id|ret
op_assign
id|adjust_memory
c_func
(paren
id|s
comma
id|adj
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RES_IO_RANGE
suffix:colon
id|ret
op_assign
id|adjust_io
c_func
(paren
id|s
comma
id|adj
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|up_read
c_func
(paren
op_amp
id|pcmcia_socket_list_rwsem
)paren
suffix:semicolon
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
DECL|variable|pcmcia_adjust_resource_info
id|EXPORT_SYMBOL
c_func
(paren
id|pcmcia_adjust_resource_info
)paren
suffix:semicolon
multiline_comment|/*====================================================================*/
DECL|function|release_resource_db
r_void
id|release_resource_db
c_func
(paren
r_struct
id|pcmcia_socket
op_star
id|s
)paren
(brace
id|resource_map_t
op_star
id|p
comma
op_star
id|q
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|s-&gt;mem_db.next
suffix:semicolon
id|p
op_ne
op_amp
id|s-&gt;mem_db
suffix:semicolon
id|p
op_assign
id|q
)paren
(brace
id|q
op_assign
id|p-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|p
op_assign
id|s-&gt;io_db.next
suffix:semicolon
id|p
op_ne
op_amp
id|s-&gt;io_db
suffix:semicolon
id|p
op_assign
id|q
)paren
(brace
id|q
op_assign
id|p-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
DECL|function|pcmcia_validate_mem
r_void
id|pcmcia_validate_mem
c_func
(paren
r_struct
id|pcmcia_socket
op_star
id|s
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;resource_ops-&gt;validate_mem
)paren
id|s-&gt;resource_ops
op_member_access_from_pointer
id|validate_mem
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
DECL|variable|pcmcia_validate_mem
id|EXPORT_SYMBOL
c_func
(paren
id|pcmcia_validate_mem
)paren
suffix:semicolon
DECL|function|adjust_io_region
r_int
id|adjust_io_region
c_func
(paren
r_struct
id|resource
op_star
id|res
comma
r_int
r_int
id|r_start
comma
r_int
r_int
id|r_end
comma
r_struct
id|pcmcia_socket
op_star
id|s
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;resource_ops-&gt;adjust_io_region
)paren
r_return
id|s-&gt;resource_ops
op_member_access_from_pointer
id|adjust_io_region
c_func
(paren
id|res
comma
id|r_start
comma
id|r_end
comma
id|s
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
DECL|function|find_io_region
r_struct
id|resource
op_star
id|find_io_region
c_func
(paren
r_int
r_int
id|base
comma
r_int
id|num
comma
r_int
r_int
id|align
comma
r_struct
id|pcmcia_socket
op_star
id|s
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;resource_ops-&gt;find_io
)paren
r_return
id|s-&gt;resource_ops
op_member_access_from_pointer
id|find_io
c_func
(paren
id|base
comma
id|num
comma
id|align
comma
id|s
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|find_mem_region
r_struct
id|resource
op_star
id|find_mem_region
c_func
(paren
id|u_long
id|base
comma
id|u_long
id|num
comma
id|u_long
id|align
comma
r_int
id|low
comma
r_struct
id|pcmcia_socket
op_star
id|s
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;resource_ops-&gt;find_mem
)paren
r_return
id|s-&gt;resource_ops
op_member_access_from_pointer
id|find_mem
c_func
(paren
id|base
comma
id|num
comma
id|align
comma
id|low
comma
id|s
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|variable|pccard_static_ops
r_struct
id|pccard_resource_ops
id|pccard_static_ops
op_assign
(brace
dot
id|validate_mem
op_assign
l_int|NULL
comma
dot
id|adjust_io_region
op_assign
l_int|NULL
comma
dot
id|find_io
op_assign
l_int|NULL
comma
dot
id|find_mem
op_assign
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|pccard_nonstatic_ops
r_struct
id|pccard_resource_ops
id|pccard_nonstatic_ops
op_assign
(brace
dot
id|validate_mem
op_assign
id|pcmcia_nonstatic_validate_mem
comma
dot
id|adjust_io_region
op_assign
id|nonstatic_adjust_io_region
comma
dot
id|find_io
op_assign
id|nonstatic_find_io_region
comma
dot
id|find_mem
op_assign
id|nonstatic_find_mem_region
comma
)brace
suffix:semicolon
eof
