multiline_comment|/*&n; *&n; * Alchemy Semi Au1000 pcmcia driver&n; *&n; * Copyright 2001-2003 MontaVista Software Inc.&n; * Author: MontaVista Software, Inc.&n; *         &t;ppopov@embeddedalley.com or source@mvista.com&n; *&n; * Copyright 2004 Pete Popov, Embedded Alley Solutions, Inc.&n; * Updated the driver to 2.6. Followed the sa11xx API and largely&n; * copied many of the hardware independent functions.&n; *&n; * ########################################################################&n; *&n; *  This program is free software; you can distribute it and/or modify it&n; *  under the terms of the GNU General Public License (Version 2) as&n; *  published by the Free Software Foundation.&n; *&n; *  This program is distributed in the hope it will be useful, but WITHOUT&n; *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or&n; *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License&n; *  for more details.&n; *&n; *  You should have received a copy of the GNU General Public License along&n; *  with this program; if not, write to the Free Software Foundation, Inc.,&n; *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * ########################################################################&n; *&n; * &n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/cpufreq.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/mach-au1x00/au1000.h&gt;
macro_line|#include &quot;au1000_generic.h&quot;
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Pete Popov &lt;ppopov@embeddedalley.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Linux PCMCIA Card Services: Au1x00 Socket Controller&quot;
)paren
suffix:semicolon
macro_line|#if 0
mdefine_line|#define debug(x,args...) printk(KERN_DEBUG &quot;%s: &quot; x, __func__ , ##args)
macro_line|#else
DECL|macro|debug
mdefine_line|#define debug(x,args...)
macro_line|#endif
DECL|macro|MAP_SIZE
mdefine_line|#define MAP_SIZE 0x100000
r_extern
r_struct
id|au1000_pcmcia_socket
id|au1000_pcmcia_socket
(braket
)braket
suffix:semicolon
DECL|macro|PCMCIA_SOCKET
mdefine_line|#define PCMCIA_SOCKET(x)&t;(au1000_pcmcia_socket + (x))
DECL|macro|to_au1000_socket
mdefine_line|#define to_au1000_socket(x)&t;container_of(x, struct au1000_pcmcia_socket, socket)
multiline_comment|/* Some boards like to support CF cards as IDE root devices, so they&n; * grab pcmcia sockets directly.&n; */
DECL|variable|pcmcia_base_vaddrs
id|u32
op_star
id|pcmcia_base_vaddrs
(braket
l_int|2
)braket
suffix:semicolon
r_extern
r_const
r_int
r_int
id|mips_io_port_base
suffix:semicolon
DECL|variable|pcmcia_sockets_lock
id|DECLARE_MUTEX
c_func
(paren
id|pcmcia_sockets_lock
)paren
suffix:semicolon
DECL|variable|au1x00_pcmcia_hw_init
r_static
r_int
(paren
op_star
id|au1x00_pcmcia_hw_init
(braket
)braket
)paren
(paren
r_struct
id|device
op_star
id|dev
)paren
op_assign
(brace
id|au1x_board_init
comma
)brace
suffix:semicolon
r_static
r_int
DECL|function|au1x00_pcmcia_skt_state
id|au1x00_pcmcia_skt_state
c_func
(paren
r_struct
id|au1000_pcmcia_socket
op_star
id|skt
)paren
(brace
r_struct
id|pcmcia_state
id|state
suffix:semicolon
r_int
r_int
id|stat
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|state
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|pcmcia_state
)paren
)paren
suffix:semicolon
id|skt-&gt;ops
op_member_access_from_pointer
id|socket_state
c_func
(paren
id|skt
comma
op_amp
id|state
)paren
suffix:semicolon
id|stat
op_assign
id|state.detect
ques
c_cond
id|SS_DETECT
suffix:colon
l_int|0
suffix:semicolon
id|stat
op_or_assign
id|state.ready
ques
c_cond
id|SS_READY
suffix:colon
l_int|0
suffix:semicolon
id|stat
op_or_assign
id|state.wrprot
ques
c_cond
id|SS_WRPROT
suffix:colon
l_int|0
suffix:semicolon
id|stat
op_or_assign
id|state.vs_3v
ques
c_cond
id|SS_3VCARD
suffix:colon
l_int|0
suffix:semicolon
id|stat
op_or_assign
id|state.vs_Xv
ques
c_cond
id|SS_XVCARD
suffix:colon
l_int|0
suffix:semicolon
id|stat
op_or_assign
id|skt-&gt;cs_state.Vcc
ques
c_cond
id|SS_POWERON
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|skt-&gt;cs_state.flags
op_amp
id|SS_IOCARD
)paren
id|stat
op_or_assign
id|state.bvd1
ques
c_cond
id|SS_STSCHG
suffix:colon
l_int|0
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|state.bvd1
op_eq
l_int|0
)paren
id|stat
op_or_assign
id|SS_BATDEAD
suffix:semicolon
r_else
r_if
c_cond
(paren
id|state.bvd2
op_eq
l_int|0
)paren
id|stat
op_or_assign
id|SS_BATWARN
suffix:semicolon
)brace
r_return
id|stat
suffix:semicolon
)brace
multiline_comment|/*&n; * au100_pcmcia_config_skt&n; *&n; * Convert PCMCIA socket state to our socket configure structure.&n; */
r_static
r_int
DECL|function|au1x00_pcmcia_config_skt
id|au1x00_pcmcia_config_skt
c_func
(paren
r_struct
id|au1000_pcmcia_socket
op_star
id|skt
comma
id|socket_state_t
op_star
id|state
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|skt-&gt;ops
op_member_access_from_pointer
id|configure_socket
c_func
(paren
id|skt
comma
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|skt-&gt;cs_state
op_assign
op_star
id|state
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
id|debug
c_func
(paren
l_string|&quot;unable to configure socket %d&bslash;n&quot;
comma
id|skt-&gt;nr
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* au1x00_pcmcia_sock_init()&n; *&n; * (Re-)Initialise the socket, turning on status interrupts&n; * and PCMCIA bus.  This must wait for power to stabilise&n; * so that the card status signals report correctly.&n; *&n; * Returns: 0&n; */
DECL|function|au1x00_pcmcia_sock_init
r_static
r_int
id|au1x00_pcmcia_sock_init
c_func
(paren
r_struct
id|pcmcia_socket
op_star
id|sock
)paren
(brace
r_struct
id|au1000_pcmcia_socket
op_star
id|skt
op_assign
id|to_au1000_socket
c_func
(paren
id|sock
)paren
suffix:semicolon
id|debug
c_func
(paren
l_string|&quot;initializing socket %u&bslash;n&quot;
comma
id|skt-&gt;nr
)paren
suffix:semicolon
id|skt-&gt;ops
op_member_access_from_pointer
id|socket_init
c_func
(paren
id|skt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * au1x00_pcmcia_suspend()&n; *&n; * Remove power on the socket, disable IRQs from the card.&n; * Turn off status interrupts, and disable the PCMCIA bus.&n; *&n; * Returns: 0&n; */
DECL|function|au1x00_pcmcia_suspend
r_static
r_int
id|au1x00_pcmcia_suspend
c_func
(paren
r_struct
id|pcmcia_socket
op_star
id|sock
)paren
(brace
r_struct
id|au1000_pcmcia_socket
op_star
id|skt
op_assign
id|to_au1000_socket
c_func
(paren
id|sock
)paren
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|debug
c_func
(paren
l_string|&quot;suspending socket %u&bslash;n&quot;
comma
id|skt-&gt;nr
)paren
suffix:semicolon
id|ret
op_assign
id|au1x00_pcmcia_config_skt
c_func
(paren
id|skt
comma
op_amp
id|dead_socket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|skt-&gt;ops
op_member_access_from_pointer
id|socket_suspend
c_func
(paren
id|skt
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|status_lock
)paren
suffix:semicolon
multiline_comment|/*&n; * au1x00_check_status()&n; */
DECL|function|au1x00_check_status
r_static
r_void
id|au1x00_check_status
c_func
(paren
r_struct
id|au1000_pcmcia_socket
op_star
id|skt
)paren
(brace
r_int
r_int
id|events
suffix:semicolon
id|debug
c_func
(paren
l_string|&quot;entering PCMCIA monitoring thread&bslash;n&quot;
)paren
suffix:semicolon
r_do
(brace
r_int
r_int
id|status
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|status
op_assign
id|au1x00_pcmcia_skt_state
c_func
(paren
id|skt
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|status_lock
comma
id|flags
)paren
suffix:semicolon
id|events
op_assign
(paren
id|status
op_xor
id|skt-&gt;status
)paren
op_amp
id|skt-&gt;cs_state.csc_mask
suffix:semicolon
id|skt-&gt;status
op_assign
id|status
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|status_lock
comma
id|flags
)paren
suffix:semicolon
id|debug
c_func
(paren
l_string|&quot;events: %s%s%s%s%s%s&bslash;n&quot;
comma
id|events
op_eq
l_int|0
ques
c_cond
l_string|&quot;&lt;NONE&gt;&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|events
op_amp
id|SS_DETECT
ques
c_cond
l_string|&quot;DETECT &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|events
op_amp
id|SS_READY
ques
c_cond
l_string|&quot;READY &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|events
op_amp
id|SS_BATDEAD
ques
c_cond
l_string|&quot;BATDEAD &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|events
op_amp
id|SS_BATWARN
ques
c_cond
l_string|&quot;BATWARN &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|events
op_amp
id|SS_STSCHG
ques
c_cond
l_string|&quot;STSCHG &quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|events
)paren
id|pcmcia_parse_events
c_func
(paren
op_amp
id|skt-&gt;socket
comma
id|events
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|events
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * au1x00_pcmcia_poll_event()&n; * Let&squot;s poll for events in addition to IRQs since IRQ only is unreliable...&n; */
DECL|function|au1x00_pcmcia_poll_event
r_static
r_void
id|au1x00_pcmcia_poll_event
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
r_struct
id|au1000_pcmcia_socket
op_star
id|skt
op_assign
(paren
r_struct
id|au1000_pcmcia_socket
op_star
)paren
id|dummy
suffix:semicolon
id|debug
c_func
(paren
l_string|&quot;polling for events&bslash;n&quot;
)paren
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|skt-&gt;poll_timer
comma
id|jiffies
op_plus
id|AU1000_PCMCIA_POLL_PERIOD
)paren
suffix:semicolon
id|au1x00_check_status
c_func
(paren
id|skt
)paren
suffix:semicolon
)brace
multiline_comment|/* au1x00_pcmcia_get_status()&n; *&n; * From the sa11xx_core.c:&n; * Implements the get_status() operation for the in-kernel PCMCIA&n; * service (formerly SS_GetStatus in Card Services). Essentially just&n; * fills in bits in `status&squot; according to internal driver state or&n; * the value of the voltage detect chipselect register.&n; *&n; * As a debugging note, during card startup, the PCMCIA core issues&n; * three set_socket() commands in a row the first with RESET deasserted,&n; * the second with RESET asserted, and the last with RESET deasserted&n; * again. Following the third set_socket(), a get_status() command will&n; * be issued. The kernel is looking for the SS_READY flag (see&n; * setup_socket(), reset_socket(), and unreset_socket() in cs.c).&n; *&n; * Returns: 0&n; */
r_static
r_int
DECL|function|au1x00_pcmcia_get_status
id|au1x00_pcmcia_get_status
c_func
(paren
r_struct
id|pcmcia_socket
op_star
id|sock
comma
r_int
r_int
op_star
id|status
)paren
(brace
r_struct
id|au1000_pcmcia_socket
op_star
id|skt
op_assign
id|to_au1000_socket
c_func
(paren
id|sock
)paren
suffix:semicolon
id|skt-&gt;status
op_assign
id|au1x00_pcmcia_skt_state
c_func
(paren
id|skt
)paren
suffix:semicolon
op_star
id|status
op_assign
id|skt-&gt;status
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* au1x00_pcmcia_get_socket()&n; * Implements the get_socket() operation for the in-kernel PCMCIA&n; * service (formerly SS_GetSocket in Card Services). Not a very&n; * exciting routine.&n; *&n; * Returns: 0&n; */
r_static
r_int
DECL|function|au1x00_pcmcia_get_socket
id|au1x00_pcmcia_get_socket
c_func
(paren
r_struct
id|pcmcia_socket
op_star
id|sock
comma
id|socket_state_t
op_star
id|state
)paren
(brace
r_struct
id|au1000_pcmcia_socket
op_star
id|skt
op_assign
id|to_au1000_socket
c_func
(paren
id|sock
)paren
suffix:semicolon
id|debug
c_func
(paren
l_string|&quot;for sock %u&bslash;n&quot;
comma
id|skt-&gt;nr
)paren
suffix:semicolon
op_star
id|state
op_assign
id|skt-&gt;cs_state
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* au1x00_pcmcia_set_socket()&n; * Implements the set_socket() operation for the in-kernel PCMCIA&n; * service (formerly SS_SetSocket in Card Services). We more or&n; * less punt all of this work and let the kernel handle the details&n; * of power configuration, reset, &amp;c. We also record the value of&n; * `state&squot; in order to regurgitate it to the PCMCIA core later.&n; *&n; * Returns: 0&n; */
r_static
r_int
DECL|function|au1x00_pcmcia_set_socket
id|au1x00_pcmcia_set_socket
c_func
(paren
r_struct
id|pcmcia_socket
op_star
id|sock
comma
id|socket_state_t
op_star
id|state
)paren
(brace
r_struct
id|au1000_pcmcia_socket
op_star
id|skt
op_assign
id|to_au1000_socket
c_func
(paren
id|sock
)paren
suffix:semicolon
id|debug
c_func
(paren
l_string|&quot;for sock %u&bslash;n&quot;
comma
id|skt-&gt;nr
)paren
suffix:semicolon
id|debug
c_func
(paren
l_string|&quot;&bslash;tmask:  %s%s%s%s%s%s&bslash;n&bslash;tflags: %s%s%s%s%s%s&bslash;n&quot;
comma
(paren
id|state-&gt;csc_mask
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;&lt;NONE&gt;&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|state-&gt;csc_mask
op_amp
id|SS_DETECT
)paren
ques
c_cond
l_string|&quot;DETECT &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|state-&gt;csc_mask
op_amp
id|SS_READY
)paren
ques
c_cond
l_string|&quot;READY &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|state-&gt;csc_mask
op_amp
id|SS_BATDEAD
)paren
ques
c_cond
l_string|&quot;BATDEAD &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|state-&gt;csc_mask
op_amp
id|SS_BATWARN
)paren
ques
c_cond
l_string|&quot;BATWARN &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|state-&gt;csc_mask
op_amp
id|SS_STSCHG
)paren
ques
c_cond
l_string|&quot;STSCHG &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|state-&gt;flags
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;&lt;NONE&gt;&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|state-&gt;flags
op_amp
id|SS_PWR_AUTO
)paren
ques
c_cond
l_string|&quot;PWR_AUTO &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|state-&gt;flags
op_amp
id|SS_IOCARD
)paren
ques
c_cond
l_string|&quot;IOCARD &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|state-&gt;flags
op_amp
id|SS_RESET
)paren
ques
c_cond
l_string|&quot;RESET &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|state-&gt;flags
op_amp
id|SS_SPKR_ENA
)paren
ques
c_cond
l_string|&quot;SPKR_ENA &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|state-&gt;flags
op_amp
id|SS_OUTPUT_ENA
)paren
ques
c_cond
l_string|&quot;OUTPUT_ENA &quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|debug
c_func
(paren
l_string|&quot;&bslash;tVcc %d  Vpp %d  irq %d&bslash;n&quot;
comma
id|state-&gt;Vcc
comma
id|state-&gt;Vpp
comma
id|state-&gt;io_irq
)paren
suffix:semicolon
r_return
id|au1x00_pcmcia_config_skt
c_func
(paren
id|skt
comma
id|state
)paren
suffix:semicolon
)brace
r_int
DECL|function|au1x00_pcmcia_set_io_map
id|au1x00_pcmcia_set_io_map
c_func
(paren
r_struct
id|pcmcia_socket
op_star
id|sock
comma
r_struct
id|pccard_io_map
op_star
id|map
)paren
(brace
r_struct
id|au1000_pcmcia_socket
op_star
id|skt
op_assign
id|to_au1000_socket
c_func
(paren
id|sock
)paren
suffix:semicolon
r_int
r_int
id|speed
suffix:semicolon
r_if
c_cond
(paren
id|map-&gt;map
op_ge
id|MAX_IO_WIN
)paren
(brace
id|debug
c_func
(paren
l_string|&quot;map (%d) out of range&bslash;n&quot;
comma
id|map-&gt;map
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|map-&gt;flags
op_amp
id|MAP_ACTIVE
)paren
(brace
id|speed
op_assign
(paren
id|map-&gt;speed
OG
l_int|0
)paren
ques
c_cond
id|map-&gt;speed
suffix:colon
id|AU1000_PCMCIA_IO_SPEED
suffix:semicolon
id|skt-&gt;spd_io
(braket
id|map-&gt;map
)braket
op_assign
id|speed
suffix:semicolon
)brace
id|map-&gt;start
op_assign
(paren
id|ioaddr_t
)paren
(paren
id|u32
)paren
id|skt-&gt;virt_io
suffix:semicolon
id|map-&gt;stop
op_assign
id|map-&gt;start
op_plus
id|MAP_SIZE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* au1x00_pcmcia_set_io_map() */
r_static
r_int
DECL|function|au1x00_pcmcia_set_mem_map
id|au1x00_pcmcia_set_mem_map
c_func
(paren
r_struct
id|pcmcia_socket
op_star
id|sock
comma
r_struct
id|pccard_mem_map
op_star
id|map
)paren
(brace
r_struct
id|au1000_pcmcia_socket
op_star
id|skt
op_assign
id|to_au1000_socket
c_func
(paren
id|sock
)paren
suffix:semicolon
r_int
r_int
id|speed
op_assign
id|map-&gt;speed
suffix:semicolon
r_if
c_cond
(paren
id|map-&gt;map
op_ge
id|MAX_WIN
)paren
(brace
id|debug
c_func
(paren
l_string|&quot;map (%d) out of range&bslash;n&quot;
comma
id|map-&gt;map
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|map-&gt;flags
op_amp
id|MAP_ATTRIB
)paren
(brace
id|skt-&gt;spd_attr
(braket
id|map-&gt;map
)braket
op_assign
id|speed
suffix:semicolon
id|skt-&gt;spd_mem
(braket
id|map-&gt;map
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|skt-&gt;spd_attr
(braket
id|map-&gt;map
)braket
op_assign
l_int|0
suffix:semicolon
id|skt-&gt;spd_mem
(braket
id|map-&gt;map
)braket
op_assign
id|speed
suffix:semicolon
)brace
r_if
c_cond
(paren
id|map-&gt;flags
op_amp
id|MAP_ATTRIB
)paren
(brace
id|map-&gt;static_start
op_assign
id|skt-&gt;phys_attr
op_plus
id|map-&gt;card_start
suffix:semicolon
)brace
r_else
(brace
id|map-&gt;static_start
op_assign
id|skt-&gt;phys_mem
op_plus
id|map-&gt;card_start
suffix:semicolon
)brace
id|debug
c_func
(paren
l_string|&quot;set_mem_map %d start %08lx card_start %08x&bslash;n&quot;
comma
id|map-&gt;map
comma
id|map-&gt;static_start
comma
id|map-&gt;card_start
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* au1x00_pcmcia_set_mem_map() */
DECL|variable|au1x00_pcmcia_operations
r_static
r_struct
id|pccard_operations
id|au1x00_pcmcia_operations
op_assign
(brace
dot
id|init
op_assign
id|au1x00_pcmcia_sock_init
comma
dot
id|suspend
op_assign
id|au1x00_pcmcia_suspend
comma
dot
id|get_status
op_assign
id|au1x00_pcmcia_get_status
comma
dot
id|get_socket
op_assign
id|au1x00_pcmcia_get_socket
comma
dot
id|set_socket
op_assign
id|au1x00_pcmcia_set_socket
comma
dot
id|set_io_map
op_assign
id|au1x00_pcmcia_set_io_map
comma
dot
id|set_mem_map
op_assign
id|au1x00_pcmcia_set_mem_map
comma
)brace
suffix:semicolon
DECL|variable|skt_names
r_static
r_const
r_char
op_star
id|skt_names
(braket
)braket
op_assign
(brace
l_string|&quot;PCMCIA socket 0&quot;
comma
l_string|&quot;PCMCIA socket 1&quot;
comma
)brace
suffix:semicolon
DECL|struct|skt_dev_info
r_struct
id|skt_dev_info
(brace
DECL|member|nskt
r_int
id|nskt
suffix:semicolon
)brace
suffix:semicolon
DECL|function|au1x00_pcmcia_socket_probe
r_int
id|au1x00_pcmcia_socket_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|pcmcia_low_level
op_star
id|ops
comma
r_int
id|first
comma
r_int
id|nr
)paren
(brace
r_struct
id|skt_dev_info
op_star
id|sinfo
suffix:semicolon
r_int
id|ret
comma
id|i
suffix:semicolon
id|sinfo
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|skt_dev_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sinfo
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|memset
c_func
(paren
id|sinfo
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|skt_dev_info
)paren
)paren
suffix:semicolon
id|sinfo-&gt;nskt
op_assign
id|nr
suffix:semicolon
multiline_comment|/*&n;&t; * Initialise the per-socket structure.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|au1000_pcmcia_socket
op_star
id|skt
op_assign
id|PCMCIA_SOCKET
c_func
(paren
id|i
)paren
suffix:semicolon
id|memset
c_func
(paren
id|skt
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|skt
)paren
)paren
suffix:semicolon
id|skt-&gt;socket.ops
op_assign
op_amp
id|au1x00_pcmcia_operations
suffix:semicolon
id|skt-&gt;socket.owner
op_assign
id|ops-&gt;owner
suffix:semicolon
id|skt-&gt;socket.dev.dev
op_assign
id|dev
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|skt-&gt;poll_timer
)paren
suffix:semicolon
id|skt-&gt;poll_timer.function
op_assign
id|au1x00_pcmcia_poll_event
suffix:semicolon
id|skt-&gt;poll_timer.data
op_assign
(paren
r_int
r_int
)paren
id|skt
suffix:semicolon
id|skt-&gt;poll_timer.expires
op_assign
id|jiffies
op_plus
id|AU1000_PCMCIA_POLL_PERIOD
suffix:semicolon
id|skt-&gt;nr
op_assign
id|first
op_plus
id|i
suffix:semicolon
id|skt-&gt;irq
op_assign
l_int|255
suffix:semicolon
id|skt-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skt-&gt;ops
op_assign
id|ops
suffix:semicolon
id|skt-&gt;res_skt.name
op_assign
id|skt_names
(braket
id|skt-&gt;nr
)braket
suffix:semicolon
id|skt-&gt;res_io.name
op_assign
l_string|&quot;io&quot;
suffix:semicolon
id|skt-&gt;res_io.flags
op_assign
id|IORESOURCE_MEM
op_or
id|IORESOURCE_BUSY
suffix:semicolon
id|skt-&gt;res_mem.name
op_assign
l_string|&quot;memory&quot;
suffix:semicolon
id|skt-&gt;res_mem.flags
op_assign
id|IORESOURCE_MEM
suffix:semicolon
id|skt-&gt;res_attr.name
op_assign
l_string|&quot;attribute&quot;
suffix:semicolon
id|skt-&gt;res_attr.flags
op_assign
id|IORESOURCE_MEM
suffix:semicolon
multiline_comment|/*&n;&t;&t; * PCMCIA client drivers use the inb/outb macros to access the&n;&t;&t; * IO registers. Since mips_io_port_base is added to the&n;&t;&t; * access address of the mips implementation of inb/outb,&n;&t;&t; * we need to subtract it here because we want to access the&n;&t;&t; * I/O or MEM address directly, without going through this&n;&t;&t; * &quot;mips_io_port_base&quot; mechanism.&n;&t;&t; */
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|skt-&gt;virt_io
op_assign
(paren
r_void
op_star
)paren
(paren
id|ioremap
c_func
(paren
(paren
id|phys_t
)paren
id|AU1X_SOCK0_IO
comma
l_int|0x1000
)paren
op_minus
(paren
id|u32
)paren
id|mips_io_port_base
)paren
suffix:semicolon
id|skt-&gt;phys_attr
op_assign
id|AU1X_SOCK0_PSEUDO_PHYS_ATTR
suffix:semicolon
id|skt-&gt;phys_mem
op_assign
id|AU1X_SOCK0_PSEUDO_PHYS_MEM
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_MIPS_XXS1500
r_else
(brace
id|skt-&gt;virt_io
op_assign
(paren
r_void
op_star
)paren
(paren
id|ioremap
c_func
(paren
(paren
id|phys_t
)paren
id|AU1X_SOCK1_IO
comma
l_int|0x1000
)paren
op_minus
(paren
id|u32
)paren
id|mips_io_port_base
)paren
suffix:semicolon
id|skt-&gt;phys_attr
op_assign
id|AU1X_SOCK1_PSEUDO_PHYS_ATTR
suffix:semicolon
id|skt-&gt;phys_mem
op_assign
id|AU1X_SOCK1_PSEUDO_PHYS_MEM
suffix:semicolon
)brace
macro_line|#endif
id|pcmcia_base_vaddrs
(braket
id|i
)braket
op_assign
(paren
id|u32
op_star
)paren
id|skt-&gt;virt_io
suffix:semicolon
id|ret
op_assign
id|ops
op_member_access_from_pointer
id|hw_init
c_func
(paren
id|skt
)paren
suffix:semicolon
id|skt-&gt;socket.features
op_assign
id|SS_CAP_STATIC_MAP
op_or
id|SS_CAP_PCCARD
suffix:semicolon
id|skt-&gt;socket.irq_mask
op_assign
l_int|0
suffix:semicolon
id|skt-&gt;socket.map_size
op_assign
id|MAP_SIZE
suffix:semicolon
id|skt-&gt;socket.pci_irq
op_assign
id|skt-&gt;irq
suffix:semicolon
id|skt-&gt;socket.io_offset
op_assign
(paren
r_int
r_int
)paren
id|skt-&gt;virt_io
suffix:semicolon
id|skt-&gt;status
op_assign
id|au1x00_pcmcia_skt_state
c_func
(paren
id|skt
)paren
suffix:semicolon
id|ret
op_assign
id|pcmcia_register_socket
c_func
(paren
op_amp
id|skt-&gt;socket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out_err
suffix:semicolon
id|WARN_ON
c_func
(paren
id|skt-&gt;socket.sock
op_ne
id|i
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|skt-&gt;poll_timer
)paren
suffix:semicolon
)brace
id|dev_set_drvdata
c_func
(paren
id|dev
comma
id|sinfo
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_do
(brace
r_struct
id|au1000_pcmcia_socket
op_star
id|skt
op_assign
id|PCMCIA_SOCKET
c_func
(paren
id|i
)paren
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|skt-&gt;poll_timer
)paren
suffix:semicolon
id|pcmcia_unregister_socket
c_func
(paren
op_amp
id|skt-&gt;socket
)paren
suffix:semicolon
id|out_err
suffix:colon
id|flush_scheduled_work
c_func
(paren
)paren
suffix:semicolon
id|ops
op_member_access_from_pointer
id|hw_shutdown
c_func
(paren
id|skt
)paren
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
OG
l_int|0
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sinfo
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|au1x00_drv_pcmcia_remove
r_int
id|au1x00_drv_pcmcia_remove
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|skt_dev_info
op_star
id|sinfo
op_assign
id|dev_get_drvdata
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|down
c_func
(paren
op_amp
id|pcmcia_sockets_lock
)paren
suffix:semicolon
id|dev_set_drvdata
c_func
(paren
id|dev
comma
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sinfo-&gt;nskt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|au1000_pcmcia_socket
op_star
id|skt
op_assign
id|PCMCIA_SOCKET
c_func
(paren
id|i
)paren
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|skt-&gt;poll_timer
)paren
suffix:semicolon
id|pcmcia_unregister_socket
c_func
(paren
op_amp
id|skt-&gt;socket
)paren
suffix:semicolon
id|flush_scheduled_work
c_func
(paren
)paren
suffix:semicolon
id|skt-&gt;ops
op_member_access_from_pointer
id|hw_shutdown
c_func
(paren
id|skt
)paren
suffix:semicolon
id|au1x00_pcmcia_config_skt
c_func
(paren
id|skt
comma
op_amp
id|dead_socket
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|skt-&gt;virt_io
)paren
suffix:semicolon
id|skt-&gt;virt_io
op_assign
l_int|NULL
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|sinfo
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|pcmcia_sockets_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * PCMCIA &quot;Driver&quot; API&n; */
DECL|function|au1x00_drv_pcmcia_probe
r_static
r_int
id|au1x00_drv_pcmcia_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|i
comma
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|down
c_func
(paren
op_amp
id|pcmcia_sockets_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|au1x00_pcmcia_hw_init
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ret
op_assign
id|au1x00_pcmcia_hw_init
(braket
id|i
)braket
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|pcmcia_sockets_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|au1x00_drv_pcmcia_suspend
r_static
r_int
id|au1x00_drv_pcmcia_suspend
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u32
id|state
comma
id|u32
id|level
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
id|SUSPEND_SAVE_STATE
)paren
id|ret
op_assign
id|pcmcia_socket_dev_suspend
c_func
(paren
id|dev
comma
id|state
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|au1x00_drv_pcmcia_resume
r_static
r_int
id|au1x00_drv_pcmcia_resume
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u32
id|level
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
id|RESUME_RESTORE_STATE
)paren
id|ret
op_assign
id|pcmcia_socket_dev_resume
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|au1x00_pcmcia_driver
r_static
r_struct
id|device_driver
id|au1x00_pcmcia_driver
op_assign
(brace
dot
id|probe
op_assign
id|au1x00_drv_pcmcia_probe
comma
dot
id|remove
op_assign
id|au1x00_drv_pcmcia_remove
comma
dot
id|name
op_assign
l_string|&quot;au1x00-pcmcia&quot;
comma
dot
id|bus
op_assign
op_amp
id|platform_bus_type
comma
dot
id|suspend
op_assign
id|au1x00_drv_pcmcia_suspend
comma
dot
id|resume
op_assign
id|au1x00_drv_pcmcia_resume
)brace
suffix:semicolon
DECL|variable|au1x00_device
r_static
r_struct
id|platform_device
id|au1x00_device
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;au1x00-pcmcia&quot;
comma
dot
id|id
op_assign
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* au1x00_pcmcia_init()&n; *&n; * This routine performs low-level PCMCIA initialization and then&n; * registers this socket driver with Card Services.&n; *&n; * Returns: 0 on success, -ve error code on failure&n; */
DECL|function|au1x00_pcmcia_init
r_static
r_int
id|__init
id|au1x00_pcmcia_init
c_func
(paren
r_void
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|driver_register
c_func
(paren
op_amp
id|au1x00_pcmcia_driver
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|platform_device_register
c_func
(paren
op_amp
id|au1x00_device
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* au1x00_pcmcia_exit()&n; * Invokes the low-level kernel service to free IRQs associated with this&n; * socket controller and reset GPIO edge detection.&n; */
DECL|function|au1x00_pcmcia_exit
r_static
r_void
id|__exit
id|au1x00_pcmcia_exit
c_func
(paren
r_void
)paren
(brace
id|driver_unregister
c_func
(paren
op_amp
id|au1x00_pcmcia_driver
)paren
suffix:semicolon
id|platform_device_unregister
c_func
(paren
op_amp
id|au1x00_device
)paren
suffix:semicolon
)brace
DECL|variable|au1x00_pcmcia_init
id|module_init
c_func
(paren
id|au1x00_pcmcia_init
)paren
suffix:semicolon
DECL|variable|au1x00_pcmcia_exit
id|module_exit
c_func
(paren
id|au1x00_pcmcia_exit
)paren
suffix:semicolon
eof
