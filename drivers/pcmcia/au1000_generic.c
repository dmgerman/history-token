multiline_comment|/*&n; *&n; * Alchemy Semi Au1000 pcmcia driver&n; *&n; * Copyright 2001 MontaVista Software Inc.&n; * Author: MontaVista Software, Inc.&n; *         &t;ppopov@mvista.com or source@mvista.com&n; *&n; * ########################################################################&n; *&n; *  This program is free software; you can distribute it and/or modify it&n; *  under the terms of the GNU General Public License (Version 2) as&n; *  published by the Free Software Foundation.&n; *&n; *  This program is distributed in the hope it will be useful, but WITHOUT&n; *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or&n; *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License&n; *  for more details.&n; *&n; *  You should have received a copy of the GNU General Public License along&n; *  with this program; if not, write to the Free Software Foundation, Inc.,&n; *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * ########################################################################&n; *&n; * &n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/tqueue.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;pcmcia/version.h&gt;
macro_line|#include &lt;pcmcia/cs_types.h&gt;
macro_line|#include &lt;pcmcia/cs.h&gt;
macro_line|#include &lt;pcmcia/ss.h&gt;
macro_line|#include &lt;pcmcia/bulkmem.h&gt;
macro_line|#include &lt;pcmcia/cistpl.h&gt;
macro_line|#include &lt;pcmcia/bus_ops.h&gt;
macro_line|#include &quot;cs_internal.h&quot;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/au1000.h&gt;
macro_line|#include &lt;asm/au1000_pcmcia.h&gt;
macro_line|#ifdef DEBUG
DECL|variable|pc_debug
r_static
r_int
id|pc_debug
suffix:semicolon
id|module_param
c_func
(paren
id|pc_debug
comma
r_int
comma
l_int|0644
)paren
suffix:semicolon
DECL|macro|debug
mdefine_line|#define debug(lvl,fmt) do {&t;&t;&t;&bslash;&n;&t;if (pc_debug &gt; (lvl))&t;&t;&t;&bslash;&n;&t;&t;printk(KERN_DEBUG fmt);&t;&t;&bslash;&n;} while (0)
macro_line|#else
DECL|macro|debug
mdefine_line|#define debug(lvl,fmt) do { } while (0)
macro_line|#endif
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Pete Popov, MontaVista Software &lt;ppopov@mvista.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Linux PCMCIA Card Services: Au1x00 Socket Controller&quot;
)paren
suffix:semicolon
DECL|macro|MAP_SIZE
mdefine_line|#define MAP_SIZE 0x1000000
multiline_comment|/* This structure maintains housekeeping state for each socket, such&n; * as the last known values of the card detect pins, or the Card Services&n; * callback value associated with the socket:&n; */
DECL|variable|pcmcia_socket
r_static
r_struct
id|au1000_pcmcia_socket
op_star
id|pcmcia_socket
suffix:semicolon
DECL|variable|socket_count
r_static
r_int
id|socket_count
suffix:semicolon
multiline_comment|/* Returned by the low-level PCMCIA interface: */
DECL|variable|pcmcia_low_level
r_static
r_struct
id|pcmcia_low_level
op_star
id|pcmcia_low_level
suffix:semicolon
multiline_comment|/* Event poll timer structure */
DECL|variable|poll_timer
r_static
r_struct
id|timer_list
id|poll_timer
suffix:semicolon
multiline_comment|/* Prototypes for routines which are used internally: */
r_static
r_int
id|au1000_pcmcia_driver_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|au1000_pcmcia_driver_shutdown
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|au1000_pcmcia_task_handler
c_func
(paren
r_void
op_star
id|data
)paren
suffix:semicolon
r_static
r_void
id|au1000_pcmcia_poll_event
c_func
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
r_static
r_void
id|au1000_pcmcia_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|variable|au1000_pcmcia_task
r_static
r_struct
id|tq_struct
id|au1000_pcmcia_task
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
r_static
r_int
id|au1000_pcmcia_proc_status
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|pos
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Prototypes for operations which are exported to the&n; * new-and-impr^H^H^H^H^H^H^H^H^H^H in-kernel PCMCIA core:&n; */
r_static
r_int
id|au1000_pcmcia_init
c_func
(paren
id|u32
id|sock
)paren
suffix:semicolon
r_static
r_int
id|au1000_pcmcia_suspend
c_func
(paren
id|u32
id|sock
)paren
suffix:semicolon
r_static
r_int
id|au1000_pcmcia_register_callback
c_func
(paren
id|u32
id|sock
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_void
op_star
comma
id|u32
)paren
comma
r_void
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|au1000_pcmcia_inquire_socket
c_func
(paren
id|u32
id|sock
comma
id|socket_cap_t
op_star
id|cap
)paren
suffix:semicolon
r_static
r_int
id|au1000_pcmcia_get_status
c_func
(paren
id|u32
id|sock
comma
id|u_int
op_star
id|value
)paren
suffix:semicolon
r_static
r_int
id|au1000_pcmcia_get_socket
c_func
(paren
id|u32
id|sock
comma
id|socket_state_t
op_star
id|state
)paren
suffix:semicolon
r_static
r_int
id|au1000_pcmcia_set_socket
c_func
(paren
id|u32
id|sock
comma
id|socket_state_t
op_star
id|state
)paren
suffix:semicolon
r_static
r_int
id|au1000_pcmcia_get_io_map
c_func
(paren
id|u32
id|sock
comma
r_struct
id|pccard_io_map
op_star
id|io
)paren
suffix:semicolon
r_static
r_int
id|au1000_pcmcia_set_io_map
c_func
(paren
id|u32
id|sock
comma
r_struct
id|pccard_io_map
op_star
id|io
)paren
suffix:semicolon
r_static
r_int
id|au1000_pcmcia_get_mem_map
c_func
(paren
id|u32
id|sock
comma
r_struct
id|pccard_mem_map
op_star
id|mem
)paren
suffix:semicolon
r_static
r_int
id|au1000_pcmcia_set_mem_map
c_func
(paren
id|u32
id|sock
comma
r_struct
id|pccard_mem_map
op_star
id|mem
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
r_static
r_void
id|au1000_pcmcia_proc_setup
c_func
(paren
id|u32
id|sock
comma
r_struct
id|proc_dir_entry
op_star
id|base
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|au1000_pcmcia_operations
r_static
r_struct
id|pccard_operations
id|au1000_pcmcia_operations
op_assign
(brace
id|au1000_pcmcia_init
comma
id|au1000_pcmcia_suspend
comma
id|au1000_pcmcia_register_callback
comma
id|au1000_pcmcia_inquire_socket
comma
id|au1000_pcmcia_get_status
comma
id|au1000_pcmcia_get_socket
comma
id|au1000_pcmcia_set_socket
comma
id|au1000_pcmcia_get_io_map
comma
id|au1000_pcmcia_set_io_map
comma
id|au1000_pcmcia_get_mem_map
comma
id|au1000_pcmcia_set_mem_map
comma
macro_line|#ifdef CONFIG_PROC_FS
id|au1000_pcmcia_proc_setup
macro_line|#endif
)brace
suffix:semicolon
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|pcmcia_lock
)paren
suffix:semicolon
DECL|function|au1000_pcmcia_driver_init
r_static
r_int
id|__init
id|au1000_pcmcia_driver_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|pcmcia_init
id|pcmcia_init
suffix:semicolon
r_struct
id|pcmcia_state
id|state
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nAu1x00 PCMCIA&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_64BIT_PHYS_ADDR
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Au1x00 PCMCIA 36 bit IO support not enabled&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_MIPS_PB1000) || defined(CONFIG_MIPS_PB1100) || defined(CONFIG_MIPS_PB1500)
id|pcmcia_low_level
op_assign
op_amp
id|pb1x00_pcmcia_ops
suffix:semicolon
macro_line|#else
macro_line|#error Unsupported AU1000 board.
macro_line|#endif
id|pcmcia_init.handler
op_assign
id|au1000_pcmcia_interrupt
suffix:semicolon
r_if
c_cond
(paren
(paren
id|socket_count
op_assign
id|pcmcia_low_level
op_member_access_from_pointer
id|init
c_func
(paren
op_amp
id|pcmcia_init
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unable to initialize PCMCIA service.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* NOTE: the chip select must already be setup */
id|pcmcia_socket
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|au1000_pcmcia_socket
)paren
op_star
id|socket_count
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcmcia_socket
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Card Services can&squot;t get memory &bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|pcmcia_socket
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|au1000_pcmcia_socket
)paren
op_star
id|socket_count
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Assuming max of 2 sockets, which the Au1000 supports.&n;&t; * WARNING: the Pb1000 has two sockets, and both work, but you&n;&t; * can&squot;t use them both at the same time due to glue logic conflicts.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|socket_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pcmcia_low_level
op_member_access_from_pointer
id|socket_state
c_func
(paren
id|i
comma
op_amp
id|state
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unable to get PCMCIA status&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|pcmcia_socket
(braket
id|i
)braket
dot
id|k_state
op_assign
id|state
suffix:semicolon
id|pcmcia_socket
(braket
id|i
)braket
dot
id|cs_state.csc_mask
op_assign
id|SS_DETECT
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|pcmcia_socket
(braket
id|i
)braket
dot
id|virt_io
op_assign
(paren
id|u32
)paren
id|ioremap
c_func
(paren
(paren
id|ioaddr_t
)paren
l_int|0xF00000000
comma
l_int|0x1000
)paren
suffix:semicolon
id|pcmcia_socket
(braket
id|i
)braket
dot
id|phys_attr
op_assign
(paren
id|memaddr_t
)paren
l_int|0xF40000000
suffix:semicolon
id|pcmcia_socket
(braket
id|i
)braket
dot
id|phys_mem
op_assign
(paren
id|memaddr_t
)paren
l_int|0xF80000000
suffix:semicolon
)brace
r_else
(brace
id|pcmcia_socket
(braket
id|i
)braket
dot
id|virt_io
op_assign
(paren
id|u32
)paren
id|ioremap
c_func
(paren
(paren
id|ioaddr_t
)paren
l_int|0xF08000000
comma
l_int|0x1000
)paren
suffix:semicolon
id|pcmcia_socket
(braket
id|i
)braket
dot
id|phys_attr
op_assign
(paren
id|memaddr_t
)paren
l_int|0xF48000000
suffix:semicolon
id|pcmcia_socket
(braket
id|i
)braket
dot
id|phys_mem
op_assign
(paren
id|memaddr_t
)paren
l_int|0xF88000000
suffix:semicolon
)brace
)brace
multiline_comment|/* Only advertise as many sockets as we can detect: */
r_if
c_cond
(paren
id|register_ss_entry
c_func
(paren
id|socket_count
comma
op_amp
id|au1000_pcmcia_operations
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unable to register socket service routine&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* Start the event poll timer.  &n;&t; * It will reschedule by itself afterwards. &n;&t; */
id|au1000_pcmcia_poll_event
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|debug
c_func
(paren
l_int|1
comma
l_string|&quot;au1000: initialization complete&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* au1000_pcmcia_driver_init() */
DECL|variable|au1000_pcmcia_driver_init
id|module_init
c_func
(paren
id|au1000_pcmcia_driver_init
)paren
suffix:semicolon
DECL|function|au1000_pcmcia_driver_shutdown
r_static
r_void
id|__exit
id|au1000_pcmcia_driver_shutdown
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|poll_timer
)paren
suffix:semicolon
id|unregister_ss_entry
c_func
(paren
op_amp
id|au1000_pcmcia_operations
)paren
suffix:semicolon
id|pcmcia_low_level
op_member_access_from_pointer
id|shutdown
c_func
(paren
)paren
suffix:semicolon
id|flush_scheduled_tasks
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|socket_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pcmcia_socket
(braket
id|i
)braket
dot
id|virt_io
)paren
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|pcmcia_socket
(braket
id|i
)braket
dot
id|virt_io
)paren
suffix:semicolon
)brace
id|debug
c_func
(paren
l_int|1
comma
l_string|&quot;au1000: shutdown complete&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|au1000_pcmcia_driver_shutdown
id|module_exit
c_func
(paren
id|au1000_pcmcia_driver_shutdown
)paren
suffix:semicolon
DECL|function|au1000_pcmcia_init
r_static
r_int
id|au1000_pcmcia_init
c_func
(paren
r_int
r_int
id|sock
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|au1000_pcmcia_suspend
r_static
r_int
id|au1000_pcmcia_suspend
c_func
(paren
r_int
r_int
id|sock
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|au1000_pcmcia_events
id|au1000_pcmcia_events
c_func
(paren
r_struct
id|pcmcia_state
op_star
id|state
comma
r_struct
id|pcmcia_state
op_star
id|prev_state
comma
r_int
r_int
id|mask
comma
r_int
r_int
id|flags
)paren
(brace
r_int
r_int
id|events
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;detect
op_ne
id|prev_state-&gt;detect
)paren
(brace
id|debug
c_func
(paren
l_int|2
comma
l_string|&quot;%s(): card detect value %u&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|state-&gt;detect
)paren
suffix:semicolon
id|events
op_or_assign
id|mask
op_amp
id|SS_DETECT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|state-&gt;ready
op_ne
id|prev_state-&gt;ready
)paren
(brace
id|debug
c_func
(paren
l_int|2
comma
l_string|&quot;%s(): card ready value %u&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|state-&gt;ready
)paren
suffix:semicolon
id|events
op_or_assign
id|mask
op_amp
(paren
(paren
id|flags
op_amp
id|SS_IOCARD
)paren
ques
c_cond
l_int|0
suffix:colon
id|SS_READY
)paren
suffix:semicolon
)brace
op_star
id|prev_state
op_assign
op_star
id|state
suffix:semicolon
r_return
id|events
suffix:semicolon
)brace
multiline_comment|/* au1000_pcmcia_events() */
multiline_comment|/* &n; * Au1000_pcmcia_task_handler()&n; * Processes socket events.&n; */
DECL|function|au1000_pcmcia_task_handler
r_static
r_void
id|au1000_pcmcia_task_handler
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|pcmcia_state
id|state
suffix:semicolon
r_int
id|i
comma
id|events
comma
id|irq_status
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|socket_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|irq_status
op_assign
id|pcmcia_low_level
op_member_access_from_pointer
id|socket_state
c_func
(paren
id|i
comma
op_amp
id|state
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;low-level PCMCIA error&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|events
op_assign
id|au1000_pcmcia_events
c_func
(paren
op_amp
id|state
comma
op_amp
id|pcmcia_socket
(braket
id|i
)braket
dot
id|k_state
comma
id|pcmcia_socket
(braket
id|i
)braket
dot
id|cs_state.csc_mask
comma
id|pcmcia_socket
(braket
id|i
)braket
dot
id|cs_state.flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcmcia_socket
(braket
id|i
)braket
dot
id|handler
op_ne
l_int|NULL
)paren
(brace
id|pcmcia_socket
(braket
id|i
)braket
dot
id|handler
c_func
(paren
id|pcmcia_socket
(braket
id|i
)braket
dot
id|handler_info
comma
id|events
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* au1000_pcmcia_task_handler() */
DECL|variable|au1000_pcmcia_task
r_static
r_struct
id|tq_struct
id|au1000_pcmcia_task
op_assign
(brace
id|routine
suffix:colon
id|au1000_pcmcia_task_handler
)brace
suffix:semicolon
DECL|function|au1000_pcmcia_poll_event
r_static
r_void
id|au1000_pcmcia_poll_event
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
id|poll_timer.function
op_assign
id|au1000_pcmcia_poll_event
suffix:semicolon
id|poll_timer.expires
op_assign
id|jiffies
op_plus
id|AU1000_PCMCIA_POLL_PERIOD
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|poll_timer
)paren
suffix:semicolon
id|schedule_task
c_func
(paren
op_amp
id|au1000_pcmcia_task
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * au1000_pcmcia_interrupt()&n; * The actual interrupt work is performed by au1000_pcmcia_task(), &n; * because the Card Services event handling code performs scheduling &n; * operations which cannot be executed from within an interrupt context.&n; */
r_static
r_void
DECL|function|au1000_pcmcia_interrupt
id|au1000_pcmcia_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|schedule_task
c_func
(paren
op_amp
id|au1000_pcmcia_task
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|au1000_pcmcia_register_callback
id|au1000_pcmcia_register_callback
c_func
(paren
r_int
r_int
id|sock
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_void
op_star
comma
r_int
r_int
)paren
comma
r_void
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
id|handler
op_eq
l_int|NULL
)paren
(brace
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|handler
op_assign
l_int|NULL
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
r_else
(brace
id|MOD_INC_USE_COUNT
suffix:semicolon
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|handler
op_assign
id|handler
suffix:semicolon
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|handler_info
op_assign
id|info
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* au1000_pcmcia_inquire_socket()&n; *&n; * From the sa1100 socket driver : &n; *&n; * Implements the inquire_socket() operation for the in-kernel PCMCIA&n; * service (formerly SS_InquireSocket in Card Services).  We set &n; * SS_CAP_STATIC_MAP, which disables the memory resource database check. &n; * (Mapped memory is set up within the socket driver itself.)&n; *&n; * In conjunction with the STATIC_MAP capability is a new field,&n; * `io_offset&squot;, recommended by David Hinds. Rather than go through&n; * the SetIOMap interface (which is not quite suited for communicating&n; * window locations up from the socket driver), we just pass up &n; * an offset which is applied to client-requested base I/O addresses&n; * in alloc_io_space().&n; *&n; * Returns: 0 on success, -1 if no pin has been configured for `sock&squot;&n; */
DECL|function|au1000_pcmcia_inquire_socket
r_static
r_int
id|au1000_pcmcia_inquire_socket
c_func
(paren
r_int
r_int
id|sock
comma
id|socket_cap_t
op_star
id|cap
)paren
(brace
r_struct
id|pcmcia_irq_info
id|irq_info
suffix:semicolon
r_if
c_cond
(paren
id|sock
OG
id|socket_count
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;au1000: socket %u not configured&bslash;n&quot;
comma
id|sock
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* from the sa1100_generic driver: */
multiline_comment|/* SS_CAP_PAGE_REGS: used by setup_cis_mem() in cistpl.c to set the&n;&t;*   force_low argument to validate_mem() in rsrc_mgr.c -- since in&n;&t;*   general, the mapped * addresses of the PCMCIA memory regions&n;&t;*   will not be within 0xffff, setting force_low would be&n;&t;*   undesirable.&n;&t;*&n;&t;* SS_CAP_STATIC_MAP: don&squot;t bother with the (user-configured) memory&n;&t;*   resource database; we instead pass up physical address ranges&n;&t;*   and allow other parts of Card Services to deal with remapping.&n;&t;*&n;&t;* SS_CAP_PCCARD: we can deal with 16-bit PCMCIA &amp; CF cards, but&n;&t;*   not 32-bit CardBus devices.&n;&t;*/
id|cap-&gt;features
op_assign
(paren
id|SS_CAP_PAGE_REGS
op_or
id|SS_CAP_STATIC_MAP
op_or
id|SS_CAP_PCCARD
)paren
suffix:semicolon
id|irq_info.sock
op_assign
id|sock
suffix:semicolon
id|irq_info.irq
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pcmcia_low_level
op_member_access_from_pointer
id|get_irq_info
c_func
(paren
op_amp
id|irq_info
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Error obtaining IRQ info socket %u&bslash;n&quot;
comma
id|sock
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|cap-&gt;irq_mask
op_assign
l_int|0
suffix:semicolon
id|cap-&gt;map_size
op_assign
id|MAP_SIZE
suffix:semicolon
id|cap-&gt;pci_irq
op_assign
id|irq_info.irq
suffix:semicolon
id|cap-&gt;io_offset
op_assign
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|virt_io
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* au1000_pcmcia_inquire_socket() */
r_static
r_int
DECL|function|au1000_pcmcia_get_status
id|au1000_pcmcia_get_status
c_func
(paren
r_int
r_int
id|sock
comma
r_int
r_int
op_star
id|status
)paren
(brace
r_struct
id|pcmcia_state
id|state
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pcmcia_low_level
op_member_access_from_pointer
id|socket_state
c_func
(paren
id|sock
comma
op_amp
id|state
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unable to get PCMCIA status from kernel.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|k_state
op_assign
id|state
suffix:semicolon
op_star
id|status
op_assign
id|state.detect
ques
c_cond
id|SS_DETECT
suffix:colon
l_int|0
suffix:semicolon
op_star
id|status
op_or_assign
id|state.ready
ques
c_cond
id|SS_READY
suffix:colon
l_int|0
suffix:semicolon
op_star
id|status
op_or_assign
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|cs_state.Vcc
ques
c_cond
id|SS_POWERON
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|cs_state.flags
op_amp
id|SS_IOCARD
)paren
(brace
op_star
id|status
op_or_assign
id|state.bvd1
ques
c_cond
id|SS_STSCHG
suffix:colon
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|state.bvd1
op_eq
l_int|0
)paren
(brace
op_star
id|status
op_or_assign
id|SS_BATDEAD
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|state.bvd2
op_eq
l_int|0
)paren
(brace
op_star
id|status
op_or_assign
id|SS_BATWARN
suffix:semicolon
)brace
)brace
op_star
id|status
op_or_assign
id|state.vs_3v
ques
c_cond
id|SS_3VCARD
suffix:colon
l_int|0
suffix:semicolon
op_star
id|status
op_or_assign
id|state.vs_Xv
ques
c_cond
id|SS_XVCARD
suffix:colon
l_int|0
suffix:semicolon
id|debug
c_func
(paren
l_int|2
comma
l_string|&quot;&bslash;tstatus: %s%s%s%s%s%s%s%s&bslash;n&quot;
comma
(paren
op_star
id|status
op_amp
id|SS_DETECT
)paren
ques
c_cond
l_string|&quot;DETECT &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
op_star
id|status
op_amp
id|SS_READY
)paren
ques
c_cond
l_string|&quot;READY &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
op_star
id|status
op_amp
id|SS_BATDEAD
)paren
ques
c_cond
l_string|&quot;BATDEAD &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
op_star
id|status
op_amp
id|SS_BATWARN
)paren
ques
c_cond
l_string|&quot;BATWARN &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
op_star
id|status
op_amp
id|SS_POWERON
)paren
ques
c_cond
l_string|&quot;POWERON &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
op_star
id|status
op_amp
id|SS_STSCHG
)paren
ques
c_cond
l_string|&quot;STSCHG &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
op_star
id|status
op_amp
id|SS_3VCARD
)paren
ques
c_cond
l_string|&quot;3VCARD &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
op_star
id|status
op_amp
id|SS_XVCARD
)paren
ques
c_cond
l_string|&quot;XVCARD &quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* au1000_pcmcia_get_status() */
r_static
r_int
DECL|function|au1000_pcmcia_get_socket
id|au1000_pcmcia_get_socket
c_func
(paren
r_int
r_int
id|sock
comma
id|socket_state_t
op_star
id|state
)paren
(brace
op_star
id|state
op_assign
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|cs_state
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|au1000_pcmcia_set_socket
id|au1000_pcmcia_set_socket
c_func
(paren
r_int
r_int
id|sock
comma
id|socket_state_t
op_star
id|state
)paren
(brace
r_struct
id|pcmcia_configure
id|configure
suffix:semicolon
id|debug
c_func
(paren
l_int|2
comma
l_string|&quot;&bslash;tmask:  %s%s%s%s%s%s&bslash;n&bslash;tflags: %s%s%s%s%s%s&bslash;n&quot;
l_string|&quot;&bslash;tVcc %d  Vpp %d  irq %d&bslash;n&quot;
comma
(paren
id|state-&gt;csc_mask
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;&lt;NONE&gt;&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|state-&gt;csc_mask
op_amp
id|SS_DETECT
)paren
ques
c_cond
l_string|&quot;DETECT &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|state-&gt;csc_mask
op_amp
id|SS_READY
)paren
ques
c_cond
l_string|&quot;READY &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|state-&gt;csc_mask
op_amp
id|SS_BATDEAD
)paren
ques
c_cond
l_string|&quot;BATDEAD &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|state-&gt;csc_mask
op_amp
id|SS_BATWARN
)paren
ques
c_cond
l_string|&quot;BATWARN &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|state-&gt;csc_mask
op_amp
id|SS_STSCHG
)paren
ques
c_cond
l_string|&quot;STSCHG &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|state-&gt;flags
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;&lt;NONE&gt;&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|state-&gt;flags
op_amp
id|SS_PWR_AUTO
)paren
ques
c_cond
l_string|&quot;PWR_AUTO &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|state-&gt;flags
op_amp
id|SS_IOCARD
)paren
ques
c_cond
l_string|&quot;IOCARD &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|state-&gt;flags
op_amp
id|SS_RESET
)paren
ques
c_cond
l_string|&quot;RESET &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|state-&gt;flags
op_amp
id|SS_SPKR_ENA
)paren
ques
c_cond
l_string|&quot;SPKR_ENA &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|state-&gt;flags
op_amp
id|SS_OUTPUT_ENA
)paren
ques
c_cond
l_string|&quot;OUTPUT_ENA &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|state-&gt;Vcc
comma
id|state-&gt;Vpp
comma
id|state-&gt;io_irq
)paren
suffix:semicolon
id|configure.sock
op_assign
id|sock
suffix:semicolon
id|configure.vcc
op_assign
id|state-&gt;Vcc
suffix:semicolon
id|configure.vpp
op_assign
id|state-&gt;Vpp
suffix:semicolon
id|configure.output
op_assign
(paren
id|state-&gt;flags
op_amp
id|SS_OUTPUT_ENA
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|configure.speaker
op_assign
(paren
id|state-&gt;flags
op_amp
id|SS_SPKR_ENA
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|configure.reset
op_assign
(paren
id|state-&gt;flags
op_amp
id|SS_RESET
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pcmcia_low_level
op_member_access_from_pointer
id|configure_socket
c_func
(paren
op_amp
id|configure
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unable to configure socket %u&bslash;n&quot;
comma
id|sock
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|cs_state
op_assign
op_star
id|state
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* au1000_pcmcia_set_socket() */
r_static
r_int
DECL|function|au1000_pcmcia_get_io_map
id|au1000_pcmcia_get_io_map
c_func
(paren
r_int
r_int
id|sock
comma
r_struct
id|pccard_io_map
op_star
id|map
)paren
(brace
id|debug
c_func
(paren
l_int|1
comma
l_string|&quot;au1000_pcmcia_get_io_map: sock %d&bslash;n&quot;
comma
id|sock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|map-&gt;map
op_ge
id|MAX_IO_WIN
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s(): map (%d) out of range&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|map-&gt;map
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
op_star
id|map
op_assign
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|io_map
(braket
id|map-&gt;map
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|au1000_pcmcia_set_io_map
id|au1000_pcmcia_set_io_map
c_func
(paren
r_int
r_int
id|sock
comma
r_struct
id|pccard_io_map
op_star
id|map
)paren
(brace
r_int
r_int
id|speed
suffix:semicolon
r_int
r_int
id|start
suffix:semicolon
r_if
c_cond
(paren
id|map-&gt;map
op_ge
id|MAX_IO_WIN
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s(): map (%d) out of range&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|map-&gt;map
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|map-&gt;flags
op_amp
id|MAP_ACTIVE
)paren
(brace
id|speed
op_assign
(paren
id|map-&gt;speed
OG
l_int|0
)paren
ques
c_cond
id|map-&gt;speed
suffix:colon
id|AU1000_PCMCIA_IO_SPEED
suffix:semicolon
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|speed_io
op_assign
id|speed
suffix:semicolon
)brace
id|start
op_assign
id|map-&gt;start
suffix:semicolon
r_if
c_cond
(paren
id|map-&gt;stop
op_eq
l_int|1
)paren
(brace
id|map-&gt;stop
op_assign
id|PAGE_SIZE
op_minus
l_int|1
suffix:semicolon
)brace
id|map-&gt;start
op_assign
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|virt_io
suffix:semicolon
id|map-&gt;stop
op_assign
id|map-&gt;start
op_plus
(paren
id|map-&gt;stop
op_minus
id|start
)paren
suffix:semicolon
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|io_map
(braket
id|map-&gt;map
)braket
op_assign
op_star
id|map
suffix:semicolon
id|debug
c_func
(paren
l_int|3
comma
l_string|&quot;set_io_map %d start %x stop %x&bslash;n&quot;
comma
id|map-&gt;map
comma
id|map-&gt;start
comma
id|map-&gt;stop
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* au1000_pcmcia_set_io_map() */
r_static
r_int
DECL|function|au1000_pcmcia_get_mem_map
id|au1000_pcmcia_get_mem_map
c_func
(paren
r_int
r_int
id|sock
comma
r_struct
id|pccard_mem_map
op_star
id|map
)paren
(brace
r_if
c_cond
(paren
id|map-&gt;map
op_ge
id|MAX_WIN
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s(): map (%d) out of range&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|map-&gt;map
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
op_star
id|map
op_assign
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|mem_map
(braket
id|map-&gt;map
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|au1000_pcmcia_set_mem_map
id|au1000_pcmcia_set_mem_map
c_func
(paren
r_int
r_int
id|sock
comma
r_struct
id|pccard_mem_map
op_star
id|map
)paren
(brace
r_int
r_int
id|speed
suffix:semicolon
id|u_long
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|map-&gt;map
op_ge
id|MAX_WIN
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s(): map (%d) out of range&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|map-&gt;map
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|map-&gt;flags
op_amp
id|MAP_ACTIVE
)paren
(brace
id|speed
op_assign
(paren
id|map-&gt;speed
OG
l_int|0
)paren
ques
c_cond
id|map-&gt;speed
suffix:colon
id|AU1000_PCMCIA_MEM_SPEED
suffix:semicolon
multiline_comment|/* TBD */
r_if
c_cond
(paren
id|map-&gt;flags
op_amp
id|MAP_ATTRIB
)paren
(brace
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|speed_attr
op_assign
id|speed
suffix:semicolon
)brace
r_else
(brace
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|speed_mem
op_assign
id|speed
suffix:semicolon
)brace
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pcmcia_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|map-&gt;flags
op_amp
id|MAP_ATTRIB
)paren
(brace
id|map-&gt;static_start
op_assign
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|phys_attr
op_plus
id|map-&gt;card_start
suffix:semicolon
)brace
r_else
(brace
id|map-&gt;static_start
op_assign
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|phys_mem
op_plus
id|map-&gt;card_start
suffix:semicolon
)brace
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|mem_map
(braket
id|map-&gt;map
)braket
op_assign
op_star
id|map
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pcmcia_lock
comma
id|flags
)paren
suffix:semicolon
id|debug
c_func
(paren
l_int|3
comma
l_string|&quot;set_mem_map %d start %x card_start %x&bslash;n&quot;
comma
id|map-&gt;map
comma
id|map-&gt;static_start
comma
id|map-&gt;card_start
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* au1000_pcmcia_set_mem_map() */
macro_line|#if defined(CONFIG_PROC_FS)
r_static
r_void
DECL|function|au1000_pcmcia_proc_setup
id|au1000_pcmcia_proc_setup
c_func
(paren
r_int
r_int
id|sock
comma
r_struct
id|proc_dir_entry
op_star
id|base
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|entry
suffix:semicolon
r_if
c_cond
(paren
(paren
id|entry
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;status&quot;
comma
l_int|0
comma
id|base
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unable to install &bslash;&quot;status&bslash;&quot; procfs entry&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|entry-&gt;read_proc
op_assign
id|au1000_pcmcia_proc_status
suffix:semicolon
id|entry-&gt;data
op_assign
(paren
r_void
op_star
)paren
id|sock
suffix:semicolon
)brace
multiline_comment|/* au1000_pcmcia_proc_status()&n; * Implements the /proc/bus/pccard/??/status file.&n; *&n; * Returns: the number of characters added to the buffer&n; */
r_static
r_int
DECL|function|au1000_pcmcia_proc_status
id|au1000_pcmcia_proc_status
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|pos
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_char
op_star
id|p
op_assign
id|buf
suffix:semicolon
r_int
r_int
id|sock
op_assign
(paren
r_int
r_int
)paren
id|data
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;k_flags  : %s%s%s%s%s%s%s&bslash;n&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|k_state.detect
ques
c_cond
l_string|&quot;detect &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|k_state.ready
ques
c_cond
l_string|&quot;ready &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|k_state.bvd1
ques
c_cond
l_string|&quot;bvd1 &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|k_state.bvd2
ques
c_cond
l_string|&quot;bvd2 &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|k_state.wrprot
ques
c_cond
l_string|&quot;wrprot &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|k_state.vs_3v
ques
c_cond
l_string|&quot;vs_3v &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|k_state.vs_Xv
ques
c_cond
l_string|&quot;vs_Xv &quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;status   : %s%s%s%s%s%s%s%s%s&bslash;n&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|k_state.detect
ques
c_cond
l_string|&quot;SS_DETECT &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|k_state.ready
ques
c_cond
l_string|&quot;SS_READY &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|cs_state.Vcc
ques
c_cond
l_string|&quot;SS_POWERON &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|cs_state.flags
op_amp
id|SS_IOCARD
ques
c_cond
"&bslash;"
l_string|&quot;SS_IOCARD &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|cs_state.flags
op_amp
id|SS_IOCARD
op_logical_and
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|k_state.bvd1
)paren
ques
c_cond
l_string|&quot;SS_STSCHG &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
(paren
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|cs_state.flags
op_amp
id|SS_IOCARD
)paren
op_eq
l_int|0
op_logical_and
(paren
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|k_state.bvd1
op_eq
l_int|0
)paren
)paren
ques
c_cond
l_string|&quot;SS_BATDEAD &quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
(paren
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|cs_state.flags
op_amp
id|SS_IOCARD
)paren
op_eq
l_int|0
op_logical_and
(paren
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|k_state.bvd2
op_eq
l_int|0
)paren
)paren
ques
c_cond
l_string|&quot;SS_BATWARN &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|k_state.vs_3v
ques
c_cond
l_string|&quot;SS_3VCARD &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|k_state.vs_Xv
ques
c_cond
l_string|&quot;SS_XVCARD &quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;mask     : %s%s%s%s%s&bslash;n&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|cs_state.csc_mask
op_amp
id|SS_DETECT
ques
c_cond
"&bslash;"
l_string|&quot;SS_DETECT &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|cs_state.csc_mask
op_amp
id|SS_READY
ques
c_cond
"&bslash;"
l_string|&quot;SS_READY &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|cs_state.csc_mask
op_amp
id|SS_BATDEAD
ques
c_cond
"&bslash;"
l_string|&quot;SS_BATDEAD &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|cs_state.csc_mask
op_amp
id|SS_BATWARN
ques
c_cond
"&bslash;"
l_string|&quot;SS_BATWARN &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|cs_state.csc_mask
op_amp
id|SS_STSCHG
ques
c_cond
"&bslash;"
l_string|&quot;SS_STSCHG &quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;cs_flags : %s%s%s%s%s&bslash;n&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|cs_state.flags
op_amp
id|SS_PWR_AUTO
ques
c_cond
"&bslash;"
l_string|&quot;SS_PWR_AUTO &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|cs_state.flags
op_amp
id|SS_IOCARD
ques
c_cond
"&bslash;"
l_string|&quot;SS_IOCARD &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|cs_state.flags
op_amp
id|SS_RESET
ques
c_cond
"&bslash;"
l_string|&quot;SS_RESET &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|cs_state.flags
op_amp
id|SS_SPKR_ENA
ques
c_cond
"&bslash;"
l_string|&quot;SS_SPKR_ENA &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|cs_state.flags
op_amp
id|SS_OUTPUT_ENA
ques
c_cond
"&bslash;"
l_string|&quot;SS_OUTPUT_ENA &quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Vcc      : %d&bslash;n&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|cs_state.Vcc
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Vpp      : %d&bslash;n&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|cs_state.Vpp
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;irq      : %d&bslash;n&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|cs_state.io_irq
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;I/O      : %u&bslash;n&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|speed_io
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;attribute: %u&bslash;n&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|speed_attr
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;common   : %u&bslash;n&quot;
comma
id|pcmcia_socket
(braket
id|sock
)braket
dot
id|speed_mem
)paren
suffix:semicolon
r_return
id|p
op_minus
id|buf
suffix:semicolon
)brace
macro_line|#endif  /* defined(CONFIG_PROC_FS) */
eof
