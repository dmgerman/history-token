macro_line|#ifndef _IEEE1394_HOSTS_H
DECL|macro|_IEEE1394_HOSTS_H
mdefine_line|#define _IEEE1394_HOSTS_H
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/tqueue.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &quot;ieee1394_types.h&quot;
macro_line|#include &quot;csr.h&quot;
r_struct
id|hpsb_packet
suffix:semicolon
DECL|struct|hpsb_host
r_struct
id|hpsb_host
(brace
DECL|member|host_list
r_struct
id|list_head
id|host_list
suffix:semicolon
DECL|member|ops
r_struct
id|hpsb_host_operations
op_star
id|ops
suffix:semicolon
DECL|member|hostdata
r_void
op_star
id|hostdata
suffix:semicolon
DECL|member|generation
id|atomic_t
id|generation
suffix:semicolon
DECL|member|refcount
r_int
id|refcount
suffix:semicolon
DECL|member|pending_packets
r_struct
id|list_head
id|pending_packets
suffix:semicolon
DECL|member|pending_pkt_lock
id|spinlock_t
id|pending_pkt_lock
suffix:semicolon
DECL|member|timeout_tq
r_struct
id|tq_struct
id|timeout_tq
suffix:semicolon
multiline_comment|/* A bitmask where a set bit means that this tlabel is in use.&n;         * FIXME - should be handled per node instead of per bus. */
DECL|member|tlabel_pool
id|u32
id|tlabel_pool
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|tlabel_count
r_struct
id|semaphore
id|tlabel_count
suffix:semicolon
DECL|member|tlabel_lock
id|spinlock_t
id|tlabel_lock
suffix:semicolon
DECL|member|iso_listen_count
r_int
r_char
id|iso_listen_count
(braket
l_int|64
)braket
suffix:semicolon
DECL|member|node_count
r_int
id|node_count
suffix:semicolon
multiline_comment|/* number of identified nodes on this bus */
DECL|member|selfid_count
r_int
id|selfid_count
suffix:semicolon
multiline_comment|/* total number of SelfIDs received */
DECL|member|node_id
id|nodeid_t
id|node_id
suffix:semicolon
multiline_comment|/* node ID of this host */
DECL|member|irm_id
id|nodeid_t
id|irm_id
suffix:semicolon
multiline_comment|/* ID of this bus&squot; isochronous resource manager */
DECL|member|busmgr_id
id|nodeid_t
id|busmgr_id
suffix:semicolon
multiline_comment|/* ID of this bus&squot; bus manager */
multiline_comment|/* this nodes state */
DECL|member|in_bus_reset
r_int
id|in_bus_reset
suffix:colon
l_int|1
suffix:semicolon
DECL|member|is_shutdown
r_int
id|is_shutdown
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* this nodes&squot; duties on the bus */
DECL|member|is_root
r_int
id|is_root
suffix:colon
l_int|1
suffix:semicolon
DECL|member|is_cycmst
r_int
id|is_cycmst
suffix:colon
l_int|1
suffix:semicolon
DECL|member|is_irm
r_int
id|is_irm
suffix:colon
l_int|1
suffix:semicolon
DECL|member|is_busmgr
r_int
id|is_busmgr
suffix:colon
l_int|1
suffix:semicolon
DECL|member|reset_retries
r_int
id|reset_retries
suffix:semicolon
DECL|member|topology_map
id|quadlet_t
op_star
id|topology_map
suffix:semicolon
DECL|member|speed_map
id|u8
op_star
id|speed_map
suffix:semicolon
DECL|member|csr
r_struct
id|csr_control
id|csr
suffix:semicolon
DECL|member|driver
r_struct
id|hpsb_host_driver
op_star
id|driver
suffix:semicolon
DECL|member|driver_list
r_struct
id|list_head
id|driver_list
suffix:semicolon
DECL|member|pdev
r_struct
id|pci_dev
op_star
id|pdev
suffix:semicolon
)brace
suffix:semicolon
DECL|enum|devctl_cmd
r_enum
id|devctl_cmd
(brace
multiline_comment|/* Host is requested to reset its bus and cancel all outstanding async&n;         * requests.  If arg == 1, it shall also attempt to become root on the&n;         * bus.  Return void. */
DECL|enumerator|RESET_BUS
id|RESET_BUS
comma
multiline_comment|/* Arg is void, return value is the hardware cycle counter value. */
DECL|enumerator|GET_CYCLE_COUNTER
id|GET_CYCLE_COUNTER
comma
multiline_comment|/* Set the hardware cycle counter to the value in arg, return void.&n;         * FIXME - setting is probably not required. */
DECL|enumerator|SET_CYCLE_COUNTER
id|SET_CYCLE_COUNTER
comma
multiline_comment|/* Configure hardware for new bus ID in arg, return void. */
DECL|enumerator|SET_BUS_ID
id|SET_BUS_ID
comma
multiline_comment|/* If arg true, start sending cycle start packets, stop if arg == 0.&n;         * Return void. */
DECL|enumerator|ACT_CYCLE_MASTER
id|ACT_CYCLE_MASTER
comma
multiline_comment|/* Cancel all outstanding async requests without resetting the bus.&n;         * Return void. */
DECL|enumerator|CANCEL_REQUESTS
id|CANCEL_REQUESTS
comma
multiline_comment|/* Decrease host usage count if arg == 0, increase otherwise.  Return&n;         * 1 for success, 0 for failure.  Increase usage may fail if the driver&n;         * is in the process of shutting itself down.  Decrease usage can not&n;         * fail. */
DECL|enumerator|MODIFY_USAGE
id|MODIFY_USAGE
comma
multiline_comment|/* Start or stop receiving isochronous channel in arg.  Return void.&n;         * This acts as an optimization hint, hosts are not required not to&n;         * listen on unrequested channels. */
DECL|enumerator|ISO_LISTEN_CHANNEL
id|ISO_LISTEN_CHANNEL
comma
DECL|enumerator|ISO_UNLISTEN_CHANNEL
id|ISO_UNLISTEN_CHANNEL
)brace
suffix:semicolon
DECL|enum|reset_types
r_enum
id|reset_types
(brace
multiline_comment|/* 166 microsecond reset -- only type of reset available on&n;           non-1394a capable IEEE 1394 controllers */
DECL|enumerator|LONG_RESET
id|LONG_RESET
comma
multiline_comment|/* Short (arbitrated) reset -- only available on 1394a capable&n;           IEEE 1394 capable controllers */
DECL|enumerator|SHORT_RESET
id|SHORT_RESET
)brace
suffix:semicolon
DECL|struct|hpsb_host_operations
r_struct
id|hpsb_host_operations
(brace
multiline_comment|/* This function must store a pointer to the configuration ROM into the&n;         * location referenced to by pointer and return the size of the ROM. It&n;         * may not fail.  If any allocation is required, it must be done&n;         * earlier.&n;         */
DECL|member|get_rom
r_int
(paren
op_star
id|get_rom
)paren
(paren
r_struct
id|hpsb_host
op_star
id|host
comma
r_const
id|quadlet_t
op_star
op_star
id|pointer
)paren
suffix:semicolon
multiline_comment|/* This function shall implement packet transmission based on&n;         * packet-&gt;type.  It shall CRC both parts of the packet (unless&n;         * packet-&gt;type == raw) and do byte-swapping as necessary or instruct&n;         * the hardware to do so.  It can return immediately after the packet&n;         * was queued for sending.  After sending, hpsb_sent_packet() has to be&n;         * called.  Return 0 for failure.&n;         * NOTE: The function must be callable in interrupt context.&n;         */
DECL|member|transmit_packet
r_int
(paren
op_star
id|transmit_packet
)paren
(paren
r_struct
id|hpsb_host
op_star
id|host
comma
r_struct
id|hpsb_packet
op_star
id|packet
)paren
suffix:semicolon
multiline_comment|/* This function requests miscellanous services from the driver, see&n;         * above for command codes and expected actions.  Return -1 for unknown&n;         * command, though that should never happen.&n;         */
DECL|member|devctl
r_int
(paren
op_star
id|devctl
)paren
(paren
r_struct
id|hpsb_host
op_star
id|host
comma
r_enum
id|devctl_cmd
id|command
comma
r_int
id|arg
)paren
suffix:semicolon
multiline_comment|/* This function is mainly to redirect local CSR reads/locks to the iso&n;         * management registers (bus manager id, bandwidth available, channels&n;         * available) to the hardware registers in OHCI.  reg is 0,1,2,3 for bus&n;         * mgr, bwdth avail, ch avail hi, ch avail lo respectively (the same ids&n;         * as OHCI uses).  data and compare are the new data and expected data&n;         * respectively, return value is the old value.&n;         */
DECL|member|hw_csr_reg
id|quadlet_t
(paren
op_star
id|hw_csr_reg
)paren
(paren
r_struct
id|hpsb_host
op_star
id|host
comma
r_int
id|reg
comma
id|quadlet_t
id|data
comma
id|quadlet_t
id|compare
)paren
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|hpsb_host_driver
r_struct
id|hpsb_host_driver
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|hosts
r_struct
id|list_head
id|hosts
suffix:semicolon
DECL|member|number_of_hosts
r_int
id|number_of_hosts
suffix:semicolon
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|ops
r_struct
id|hpsb_host_operations
op_star
id|ops
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* core internal use */
r_void
id|register_builtin_lowlevels
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* high level internal use */
r_struct
id|hpsb_highlevel
suffix:semicolon
r_void
id|hl_all_hosts
c_func
(paren
r_void
(paren
op_star
id|function
)paren
(paren
r_struct
id|hpsb_host
op_star
)paren
)paren
suffix:semicolon
multiline_comment|/*&n; * In order to prevent hosts from unloading, use hpsb_ref_host().  This prevents&n; * the host from going away (e.g. makes module unloading of the driver&n; * impossible), but still can not guarantee it (e.g. PC-Card being pulled by the&n; * user).  hpsb_ref_host() returns false if host could not be locked.  If it is&n; * successful, host is valid as a pointer until hpsb_unref_host() (not just&n; * until after remove_host).&n; */
r_int
id|hpsb_ref_host
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
suffix:semicolon
r_void
id|hpsb_unref_host
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
suffix:semicolon
r_struct
id|hpsb_host
op_star
id|hpsb_alloc_host
c_func
(paren
r_struct
id|hpsb_host_driver
op_star
id|drv
comma
r_int
id|extra
)paren
suffix:semicolon
r_void
id|hpsb_add_host
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
suffix:semicolon
r_void
id|hpsb_remove_host
c_func
(paren
r_struct
id|hpsb_host
op_star
id|h
)paren
suffix:semicolon
r_struct
id|hpsb_host_driver
op_star
id|hpsb_register_lowlevel
c_func
(paren
r_struct
id|hpsb_host_operations
op_star
id|op
comma
r_const
r_char
op_star
id|name
)paren
suffix:semicolon
r_void
id|hpsb_unregister_lowlevel
c_func
(paren
r_struct
id|hpsb_host_driver
op_star
id|drv
)paren
suffix:semicolon
macro_line|#endif /* _IEEE1394_HOSTS_H */
eof
