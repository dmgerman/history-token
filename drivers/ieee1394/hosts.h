macro_line|#ifndef _IEEE1394_HOSTS_H
DECL|macro|_IEEE1394_HOSTS_H
mdefine_line|#define _IEEE1394_HOSTS_H
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &quot;ieee1394_types.h&quot;
macro_line|#include &quot;csr.h&quot;
multiline_comment|/* size of the array used to store config rom (in quadlets)&n;   maximum is 0x100. About 0x40 is needed for the default&n;   entries. So 0x80 should provide enough space for additional&n;   directories etc. &n;   Note: All lowlevel drivers are required to allocate at least&n;         this amount of memory for the configuration rom!&n;*/
DECL|macro|CSR_CONFIG_ROM_SIZE
mdefine_line|#define CSR_CONFIG_ROM_SIZE       0x100
r_struct
id|hpsb_packet
suffix:semicolon
r_struct
id|hpsb_iso
suffix:semicolon
DECL|struct|hpsb_host
r_struct
id|hpsb_host
(brace
DECL|member|host_list
r_struct
id|list_head
id|host_list
suffix:semicolon
DECL|member|hostdata
r_void
op_star
id|hostdata
suffix:semicolon
DECL|member|generation
id|atomic_t
id|generation
suffix:semicolon
DECL|member|refcount
r_int
id|refcount
suffix:semicolon
DECL|member|pending_packets
r_struct
id|list_head
id|pending_packets
suffix:semicolon
DECL|member|pending_pkt_lock
id|spinlock_t
id|pending_pkt_lock
suffix:semicolon
DECL|member|timeout_tq
r_struct
id|hpsb_queue_struct
id|timeout_tq
suffix:semicolon
DECL|member|iso_listen_count
r_int
r_char
id|iso_listen_count
(braket
l_int|64
)braket
suffix:semicolon
DECL|member|node_count
r_int
id|node_count
suffix:semicolon
multiline_comment|/* number of identified nodes on this bus */
DECL|member|selfid_count
r_int
id|selfid_count
suffix:semicolon
multiline_comment|/* total number of SelfIDs received */
DECL|member|nodes_active
r_int
id|nodes_active
suffix:semicolon
multiline_comment|/* number of nodes that are actually active */
DECL|member|node_id
id|nodeid_t
id|node_id
suffix:semicolon
multiline_comment|/* node ID of this host */
DECL|member|irm_id
id|nodeid_t
id|irm_id
suffix:semicolon
multiline_comment|/* ID of this bus&squot; isochronous resource manager */
DECL|member|busmgr_id
id|nodeid_t
id|busmgr_id
suffix:semicolon
multiline_comment|/* ID of this bus&squot; bus manager */
multiline_comment|/* this nodes state */
DECL|member|in_bus_reset
r_int
id|in_bus_reset
suffix:colon
l_int|1
suffix:semicolon
DECL|member|is_shutdown
r_int
id|is_shutdown
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* this nodes&squot; duties on the bus */
DECL|member|is_root
r_int
id|is_root
suffix:colon
l_int|1
suffix:semicolon
DECL|member|is_cycmst
r_int
id|is_cycmst
suffix:colon
l_int|1
suffix:semicolon
DECL|member|is_irm
r_int
id|is_irm
suffix:colon
l_int|1
suffix:semicolon
DECL|member|is_busmgr
r_int
id|is_busmgr
suffix:colon
l_int|1
suffix:semicolon
DECL|member|reset_retries
r_int
id|reset_retries
suffix:semicolon
DECL|member|topology_map
id|quadlet_t
op_star
id|topology_map
suffix:semicolon
DECL|member|speed_map
id|u8
op_star
id|speed_map
suffix:semicolon
DECL|member|csr
r_struct
id|csr_control
id|csr
suffix:semicolon
multiline_comment|/* Per node tlabel pool allocation */
DECL|member|tpool
r_struct
id|hpsb_tlabel_pool
id|tpool
(braket
l_int|64
)braket
suffix:semicolon
DECL|member|driver
r_struct
id|hpsb_host_driver
op_star
id|driver
suffix:semicolon
DECL|member|pdev
r_struct
id|pci_dev
op_star
id|pdev
suffix:semicolon
)brace
suffix:semicolon
DECL|enum|devctl_cmd
r_enum
id|devctl_cmd
(brace
multiline_comment|/* Host is requested to reset its bus and cancel all outstanding async&n;         * requests.  If arg == 1, it shall also attempt to become root on the&n;         * bus.  Return void. */
DECL|enumerator|RESET_BUS
id|RESET_BUS
comma
multiline_comment|/* Arg is void, return value is the hardware cycle counter value. */
DECL|enumerator|GET_CYCLE_COUNTER
id|GET_CYCLE_COUNTER
comma
multiline_comment|/* Set the hardware cycle counter to the value in arg, return void.&n;         * FIXME - setting is probably not required. */
DECL|enumerator|SET_CYCLE_COUNTER
id|SET_CYCLE_COUNTER
comma
multiline_comment|/* Configure hardware for new bus ID in arg, return void. */
DECL|enumerator|SET_BUS_ID
id|SET_BUS_ID
comma
multiline_comment|/* If arg true, start sending cycle start packets, stop if arg == 0.&n;         * Return void. */
DECL|enumerator|ACT_CYCLE_MASTER
id|ACT_CYCLE_MASTER
comma
multiline_comment|/* Cancel all outstanding async requests without resetting the bus.&n;         * Return void. */
DECL|enumerator|CANCEL_REQUESTS
id|CANCEL_REQUESTS
comma
multiline_comment|/* Decrease host usage count if arg == 0, increase otherwise.  Return&n;         * 1 for success, 0 for failure.  Increase usage may fail if the driver&n;         * is in the process of shutting itself down.  Decrease usage can not&n;         * fail. */
DECL|enumerator|MODIFY_USAGE
id|MODIFY_USAGE
comma
multiline_comment|/* Start or stop receiving isochronous channel in arg.  Return void.&n;         * This acts as an optimization hint, hosts are not required not to&n;         * listen on unrequested channels. */
DECL|enumerator|ISO_LISTEN_CHANNEL
id|ISO_LISTEN_CHANNEL
comma
DECL|enumerator|ISO_UNLISTEN_CHANNEL
id|ISO_UNLISTEN_CHANNEL
)brace
suffix:semicolon
DECL|enum|isoctl_cmd
r_enum
id|isoctl_cmd
(brace
multiline_comment|/* rawiso API - see iso.h for the meanings of these commands&n;&t; * INIT = allocate resources&n;&t; * START = begin transmission/reception (arg: cycle to start on)&n;&t; * STOP = halt transmission/reception&n;&t; * QUEUE/RELEASE = produce/consume packets (arg: # of packets)&n;&t; * SHUTDOWN = deallocate resources&n;&t; */
DECL|enumerator|XMIT_INIT
id|XMIT_INIT
comma
DECL|enumerator|XMIT_START
id|XMIT_START
comma
DECL|enumerator|XMIT_STOP
id|XMIT_STOP
comma
DECL|enumerator|XMIT_QUEUE
id|XMIT_QUEUE
comma
DECL|enumerator|XMIT_SHUTDOWN
id|XMIT_SHUTDOWN
comma
DECL|enumerator|RECV_INIT
id|RECV_INIT
comma
DECL|enumerator|RECV_START
id|RECV_START
comma
DECL|enumerator|RECV_STOP
id|RECV_STOP
comma
DECL|enumerator|RECV_RELEASE
id|RECV_RELEASE
comma
DECL|enumerator|RECV_SHUTDOWN
id|RECV_SHUTDOWN
comma
)brace
suffix:semicolon
DECL|enum|reset_types
r_enum
id|reset_types
(brace
multiline_comment|/* 166 microsecond reset -- only type of reset available on&n;           non-1394a capable IEEE 1394 controllers */
DECL|enumerator|LONG_RESET
id|LONG_RESET
comma
multiline_comment|/* Short (arbitrated) reset -- only available on 1394a capable&n;           IEEE 1394 capable controllers */
DECL|enumerator|SHORT_RESET
id|SHORT_RESET
comma
multiline_comment|/* Variants, that set force_root before issueing the bus reset */
DECL|enumerator|LONG_RESET_FORCE_ROOT
DECL|enumerator|SHORT_RESET_FORCE_ROOT
id|LONG_RESET_FORCE_ROOT
comma
id|SHORT_RESET_FORCE_ROOT
comma
multiline_comment|/* Variants, that clear force_root before issueing the bus reset */
DECL|enumerator|LONG_RESET_NO_FORCE_ROOT
DECL|enumerator|SHORT_RESET_NO_FORCE_ROOT
id|LONG_RESET_NO_FORCE_ROOT
comma
id|SHORT_RESET_NO_FORCE_ROOT
)brace
suffix:semicolon
DECL|struct|hpsb_host_driver
r_struct
id|hpsb_host_driver
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
multiline_comment|/* This function must store a pointer to the configuration ROM into the&n;         * location referenced to by pointer and return the size of the ROM. It&n;         * may not fail.  If any allocation is required, it must be done&n;         * earlier.&n;         */
DECL|member|get_rom
r_int
(paren
op_star
id|get_rom
)paren
(paren
r_struct
id|hpsb_host
op_star
id|host
comma
id|quadlet_t
op_star
op_star
id|pointer
)paren
suffix:semicolon
multiline_comment|/* This function shall implement packet transmission based on&n;         * packet-&gt;type.  It shall CRC both parts of the packet (unless&n;         * packet-&gt;type == raw) and do byte-swapping as necessary or instruct&n;         * the hardware to do so.  It can return immediately after the packet&n;         * was queued for sending.  After sending, hpsb_sent_packet() has to be&n;         * called.  Return 0 for failure.&n;         * NOTE: The function must be callable in interrupt context.&n;         */
DECL|member|transmit_packet
r_int
(paren
op_star
id|transmit_packet
)paren
(paren
r_struct
id|hpsb_host
op_star
id|host
comma
r_struct
id|hpsb_packet
op_star
id|packet
)paren
suffix:semicolon
multiline_comment|/* This function requests miscellanous services from the driver, see&n;         * above for command codes and expected actions.  Return -1 for unknown&n;         * command, though that should never happen.&n;         */
DECL|member|devctl
r_int
(paren
op_star
id|devctl
)paren
(paren
r_struct
id|hpsb_host
op_star
id|host
comma
r_enum
id|devctl_cmd
id|command
comma
r_int
id|arg
)paren
suffix:semicolon
multiline_comment|/* ISO transmission/reception functions. Return 0 on success, -1 on failure.&n;&t;  * If the low-level driver does not support the new ISO API, set isoctl to NULL.&n;&t;  */
DECL|member|isoctl
r_int
(paren
op_star
id|isoctl
)paren
(paren
r_struct
id|hpsb_iso
op_star
id|iso
comma
r_enum
id|isoctl_cmd
id|command
comma
r_int
id|arg
)paren
suffix:semicolon
multiline_comment|/* This function is mainly to redirect local CSR reads/locks to the iso&n;         * management registers (bus manager id, bandwidth available, channels&n;         * available) to the hardware registers in OHCI.  reg is 0,1,2,3 for bus&n;         * mgr, bwdth avail, ch avail hi, ch avail lo respectively (the same ids&n;         * as OHCI uses).  data and compare are the new data and expected data&n;         * respectively, return value is the old value.&n;         */
DECL|member|hw_csr_reg
id|quadlet_t
(paren
op_star
id|hw_csr_reg
)paren
(paren
r_struct
id|hpsb_host
op_star
id|host
comma
r_int
id|reg
comma
id|quadlet_t
id|data
comma
id|quadlet_t
id|compare
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* high level internal use */
r_struct
id|hpsb_highlevel
suffix:semicolon
r_void
id|hl_all_hosts
c_func
(paren
r_void
(paren
op_star
id|function
)paren
(paren
r_struct
id|hpsb_host
op_star
)paren
)paren
suffix:semicolon
multiline_comment|/*&n; * In order to prevent hosts from unloading, use hpsb_ref_host().  This prevents&n; * the host from going away (e.g. makes module unloading of the driver&n; * impossible), but still can not guarantee it (e.g. PC-Card being pulled by the&n; * user).  hpsb_ref_host() returns false if host could not be locked.  If it is&n; * successful, host is valid as a pointer until hpsb_unref_host() (not just&n; * until after remove_host).&n; */
r_int
id|hpsb_ref_host
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
suffix:semicolon
r_void
id|hpsb_unref_host
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
suffix:semicolon
r_struct
id|hpsb_host
op_star
id|hpsb_alloc_host
c_func
(paren
r_struct
id|hpsb_host_driver
op_star
id|drv
comma
r_int
id|extra
)paren
suffix:semicolon
r_void
id|hpsb_add_host
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
suffix:semicolon
r_void
id|hpsb_remove_host
c_func
(paren
r_struct
id|hpsb_host
op_star
id|h
)paren
suffix:semicolon
multiline_comment|/* updates the configuration rom of a host.&n; * rom_version must be the current version,&n; * otherwise it will fail with return value -1.&n; * Return value -2 indicates that the new&n; * rom version is too big.&n; * Return value 0 indicates success&n; */
r_int
id|hpsb_update_config_rom
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
comma
r_const
id|quadlet_t
op_star
id|new_rom
comma
r_int
id|size
comma
r_int
r_char
id|rom_version
)paren
suffix:semicolon
multiline_comment|/* reads the current version of the configuration rom of a host.&n; * buffersize is the size of the buffer, rom_size&n; * returns the size of the current rom image.&n; * rom_version is the version number of the fetched rom.&n; * return value -1 indicates, that the buffer was&n; * too small, 0 indicates success.&n; */
r_int
id|hpsb_get_config_rom
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
comma
id|quadlet_t
op_star
id|buffer
comma
r_int
id|buffersize
comma
r_int
op_star
id|rom_size
comma
r_int
r_char
op_star
id|rom_version
)paren
suffix:semicolon
macro_line|#endif /* _IEEE1394_HOSTS_H */
eof
