multiline_comment|/* -*- c-basic-offset: 8 -*-&n; *&n; * amdtp.c - Audio and Music Data Transmission Protocol Driver&n; * Copyright (C) 2001 Kristian H&#xfffd;gsberg&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software Foundation,&n; * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.&n; */
multiline_comment|/* OVERVIEW&n; * --------&n; *&n; * The AMDTP driver is designed to expose the IEEE1394 bus as a&n; * regular OSS soundcard, i.e. you can link /dev/dsp to /dev/amdtp and&n; * then your favourite MP3 player, game or whatever sound program will&n; * output to an IEEE1394 isochronous channel.  The signal destination&n; * could be a set of IEEE1394 loudspeakers (if and when such things&n; * become available) or an amplifier with IEEE1394 input (like the&n; * Sony STR-LSA1).  The driver only handles the actual streaming, some&n; * connection management is also required for this to actually work.&n; * That is outside the scope of this driver, and furthermore it is not&n; * really standardized yet.&n; *&n; * The Audio and Music Data Tranmission Protocol is avaiable at&n; *&n; *     http://www.1394ta.org/Download/Technology/Specifications/2001/AM20Final-jf2.pdf&n; *&n; *&n; * TODO&n; * ----&n; *&n; * - We should be able to change input sample format between LE/BE, as&n; *   we already shift the bytes around when we construct the iso&n; *   packets.&n; *&n; * - Fix DMA stop after bus reset!&n; *&n; * - Implement poll.&n; *&n; * - Clean up iso context handling in ohci1394.&n; *&n; *&n; * MAYBE TODO&n; * ----------&n; *&n; * - Receive data for local playback or recording.  Playback requires&n; *   soft syncing with the sound card.&n; *&n; * - Signal processing, i.e. receive packets, do some processing, and&n; *   transmit them again using the same packet structure and timestamps&n; *   offset by processing time.&n; *&n; * - Maybe make an ALSA interface, that is, create a file_ops&n; *   implementation that recognizes ALSA ioctls and uses defaults for&n; *   things that can&squot;t be controlled through ALSA (iso channel).&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/ioctl.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;highlevel.h&quot;
macro_line|#include &quot;ieee1394.h&quot;
macro_line|#include &quot;ieee1394_core.h&quot;
macro_line|#include &quot;ohci1394.h&quot;
macro_line|#include &quot;amdtp.h&quot;
macro_line|#include &quot;cmp.h&quot;
DECL|macro|FMT_AMDTP
mdefine_line|#define FMT_AMDTP 0x10
DECL|macro|FDF_AM824
mdefine_line|#define FDF_AM824 0x00
DECL|macro|FDF_SFC_32KHZ
mdefine_line|#define FDF_SFC_32KHZ  0x00 /* 32kHz */
DECL|macro|FDF_SFC_44K1HZ
mdefine_line|#define FDF_SFC_44K1HZ 0x01 /* 44.1kHz */
DECL|macro|FDF_SFC_48KHZ
mdefine_line|#define FDF_SFC_48KHZ  0x02 /* 44.1kHz */
DECL|struct|descriptor_block
r_struct
id|descriptor_block
(brace
DECL|struct|output_more_immediate
r_struct
id|output_more_immediate
(brace
DECL|member|control
id|u32
id|control
suffix:semicolon
DECL|member|pad0
id|u32
id|pad0
suffix:semicolon
DECL|member|skip
id|u32
id|skip
suffix:semicolon
DECL|member|pad1
id|u32
id|pad1
suffix:semicolon
DECL|member|header
id|u32
id|header
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|header_desc
)brace
id|header_desc
suffix:semicolon
DECL|struct|output_last
r_struct
id|output_last
(brace
DECL|member|control
id|u32
id|control
suffix:semicolon
DECL|member|data_address
id|u32
id|data_address
suffix:semicolon
DECL|member|branch
id|u32
id|branch
suffix:semicolon
DECL|member|status
id|u32
id|status
suffix:semicolon
DECL|member|payload_desc
)brace
id|payload_desc
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|packet
r_struct
id|packet
(brace
DECL|member|db
r_struct
id|descriptor_block
op_star
id|db
suffix:semicolon
DECL|member|db_bus
id|dma_addr_t
id|db_bus
suffix:semicolon
DECL|member|payload
id|quadlet_t
op_star
id|payload
suffix:semicolon
DECL|member|payload_bus
id|dma_addr_t
id|payload_bus
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|fraction
r_struct
id|fraction
(brace
DECL|member|integer
r_int
id|integer
suffix:semicolon
DECL|member|numerator
r_int
id|numerator
suffix:semicolon
DECL|member|denominator
r_int
id|denominator
suffix:semicolon
DECL|member|counter
r_int
id|counter
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|PACKET_LIST_SIZE
mdefine_line|#define PACKET_LIST_SIZE 256
DECL|macro|MAX_PACKET_LISTS
mdefine_line|#define MAX_PACKET_LISTS 4
DECL|struct|packet_list
r_struct
id|packet_list
(brace
DECL|member|link
r_struct
id|list_head
id|link
suffix:semicolon
DECL|member|last_cycle_count
r_int
id|last_cycle_count
suffix:semicolon
DECL|member|packets
r_struct
id|packet
id|packets
(braket
id|PACKET_LIST_SIZE
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|BUFFER_SIZE
mdefine_line|#define BUFFER_SIZE 128
multiline_comment|/* This implements a circular buffer for incoming samples. */
DECL|struct|buffer
r_struct
id|buffer
(brace
DECL|member|head
DECL|member|tail
DECL|member|length
DECL|member|size
r_int
id|head
comma
id|tail
comma
id|length
comma
id|size
suffix:semicolon
DECL|member|data
r_int
r_char
id|data
(braket
l_int|0
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|stream
r_struct
id|stream
(brace
DECL|member|iso_channel
r_int
id|iso_channel
suffix:semicolon
DECL|member|format
r_int
id|format
suffix:semicolon
DECL|member|rate
r_int
id|rate
suffix:semicolon
DECL|member|dimension
r_int
id|dimension
suffix:semicolon
DECL|member|fdf
r_int
id|fdf
suffix:semicolon
DECL|member|opcr
r_struct
id|cmp_pcr
op_star
id|opcr
suffix:semicolon
multiline_comment|/* Input samples are copied here. */
DECL|member|input
r_struct
id|buffer
op_star
id|input
suffix:semicolon
multiline_comment|/* ISO Packer state */
DECL|member|dbc
r_int
r_char
id|dbc
suffix:semicolon
DECL|member|current_packet_list
r_struct
id|packet_list
op_star
id|current_packet_list
suffix:semicolon
DECL|member|current_packet
r_int
id|current_packet
suffix:semicolon
DECL|member|packet_size_fraction
r_struct
id|fraction
id|packet_size_fraction
suffix:semicolon
multiline_comment|/* We use these to generate control bits when we are packing&n;&t; * iec958 data.&n;&t; */
DECL|member|iec958_frame_count
r_int
id|iec958_frame_count
suffix:semicolon
DECL|member|iec958_rate_code
r_int
id|iec958_rate_code
suffix:semicolon
multiline_comment|/* The cycle_count and cycle_offset fields are used for the&n;&t; * synchronization timestamps (syt) in the cip header.  They&n;&t; * are incremented by at least a cycle every time we put a&n;&t; * time stamp in a packet.  As we dont time stamp all&n;&t; * packages, cycle_count isn&squot;t updated in every cycle, and&n;&t; * sometimes it&squot;s incremented by 2.  Thus, we have&n;&t; * cycle_count2, which is simply incremented by one with each&n;&t; * packet, so we can compare it to the transmission time&n;&t; * written back in the dma programs.&n;&t; */
DECL|member|cycle_count
DECL|member|cycle_count2
id|atomic_t
id|cycle_count
comma
id|cycle_count2
suffix:semicolon
DECL|member|cycle_offset
r_int
id|cycle_offset
suffix:semicolon
DECL|member|syt_fraction
r_struct
id|fraction
id|syt_fraction
suffix:semicolon
DECL|member|syt_interval
r_int
id|syt_interval
suffix:semicolon
DECL|member|stale_count
r_int
id|stale_count
suffix:semicolon
multiline_comment|/* Theses fields control the sample output to the DMA engine.&n;&t; * The dma_packet_lists list holds packet lists currently&n;&t; * queued for dma; the head of the list is currently being&n;&t; * processed.  The last program in a packet list generates an&n;&t; * interrupt, which removes the head from dma_packet_lists and&n;&t; * puts it back on the free list.&n;&t; */
DECL|member|dma_packet_lists
r_struct
id|list_head
id|dma_packet_lists
suffix:semicolon
DECL|member|free_packet_lists
r_struct
id|list_head
id|free_packet_lists
suffix:semicolon
DECL|member|packet_list_wait
id|wait_queue_head_t
id|packet_list_wait
suffix:semicolon
DECL|member|packet_list_lock
id|spinlock_t
id|packet_list_lock
suffix:semicolon
DECL|member|iso_context
r_int
id|iso_context
suffix:semicolon
DECL|member|descriptor_pool
DECL|member|packet_pool
r_struct
id|pci_pool
op_star
id|descriptor_pool
comma
op_star
id|packet_pool
suffix:semicolon
multiline_comment|/* Streams at a host controller are chained through this field. */
DECL|member|link
r_struct
id|list_head
id|link
suffix:semicolon
DECL|member|host
r_struct
id|amdtp_host
op_star
id|host
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|amdtp_host
r_struct
id|amdtp_host
(brace
DECL|member|host
r_struct
id|hpsb_host
op_star
id|host
suffix:semicolon
DECL|member|ohci
r_struct
id|ti_ohci
op_star
id|ohci
suffix:semicolon
DECL|member|stream_list
r_struct
id|list_head
id|stream_list
suffix:semicolon
DECL|member|stream_list_lock
id|spinlock_t
id|stream_list_lock
suffix:semicolon
DECL|member|link
r_struct
id|list_head
id|link
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|amdtp_highlevel
r_static
r_struct
id|hpsb_highlevel
op_star
id|amdtp_highlevel
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|host_list
)paren
suffix:semicolon
DECL|variable|host_list_lock
r_static
id|spinlock_t
id|host_list_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* FIXME: This doesn&squot;t belong here... */
DECL|macro|OHCI1394_CONTEXT_CYCLE_MATCH
mdefine_line|#define OHCI1394_CONTEXT_CYCLE_MATCH 0x80000000
DECL|macro|OHCI1394_CONTEXT_RUN
mdefine_line|#define OHCI1394_CONTEXT_RUN         0x00008000
DECL|macro|OHCI1394_CONTEXT_WAKE
mdefine_line|#define OHCI1394_CONTEXT_WAKE        0x00001000
DECL|macro|OHCI1394_CONTEXT_DEAD
mdefine_line|#define OHCI1394_CONTEXT_DEAD        0x00000800
DECL|macro|OHCI1394_CONTEXT_ACTIVE
mdefine_line|#define OHCI1394_CONTEXT_ACTIVE      0x00000400
DECL|function|ohci1394_alloc_it_ctx
r_static
r_inline
r_int
id|ohci1394_alloc_it_ctx
c_func
(paren
r_struct
id|ti_ohci
op_star
id|ohci
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ohci-&gt;nb_iso_xmit_ctx
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|i
comma
op_amp
id|ohci-&gt;it_ctx_usage
)paren
)paren
r_return
id|i
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
DECL|function|ohci1394_free_it_ctx
r_static
r_inline
r_void
id|ohci1394_free_it_ctx
c_func
(paren
r_struct
id|ti_ohci
op_star
id|ohci
comma
r_int
id|ctx
)paren
(brace
id|clear_bit
c_func
(paren
id|ctx
comma
op_amp
id|ohci-&gt;it_ctx_usage
)paren
suffix:semicolon
)brace
DECL|function|ohci1394_start_it_ctx
r_void
id|ohci1394_start_it_ctx
c_func
(paren
r_struct
id|ti_ohci
op_star
id|ohci
comma
r_int
id|ctx
comma
id|dma_addr_t
id|first_cmd
comma
r_int
id|z
comma
r_int
id|cycle_match
)paren
(brace
id|reg_write
c_func
(paren
id|ohci
comma
id|OHCI1394_IsoXmitIntMaskSet
comma
l_int|1
op_lshift
id|ctx
)paren
suffix:semicolon
id|reg_write
c_func
(paren
id|ohci
comma
id|OHCI1394_IsoXmitCommandPtr
op_plus
id|ctx
op_star
l_int|16
comma
id|first_cmd
op_or
id|z
)paren
suffix:semicolon
id|reg_write
c_func
(paren
id|ohci
comma
id|OHCI1394_IsoXmitContextControlClear
op_plus
id|ctx
op_star
l_int|16
comma
op_complement
l_int|0
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|reg_write
c_func
(paren
id|ohci
comma
id|OHCI1394_IsoXmitContextControlSet
op_plus
id|ctx
op_star
l_int|16
comma
id|OHCI1394_CONTEXT_CYCLE_MATCH
op_or
(paren
id|cycle_match
op_lshift
l_int|16
)paren
op_or
id|OHCI1394_CONTEXT_RUN
)paren
suffix:semicolon
)brace
DECL|function|ohci1394_wake_it_ctx
r_void
id|ohci1394_wake_it_ctx
c_func
(paren
r_struct
id|ti_ohci
op_star
id|ohci
comma
r_int
id|ctx
)paren
(brace
id|reg_write
c_func
(paren
id|ohci
comma
id|OHCI1394_IsoXmitContextControlSet
op_plus
id|ctx
op_star
l_int|16
comma
id|OHCI1394_CONTEXT_WAKE
)paren
suffix:semicolon
)brace
DECL|function|ohci1394_stop_it_ctx
r_void
id|ohci1394_stop_it_ctx
c_func
(paren
r_struct
id|ti_ohci
op_star
id|ohci
comma
r_int
id|ctx
)paren
(brace
id|u32
id|control
suffix:semicolon
r_int
id|wait
suffix:semicolon
id|reg_write
c_func
(paren
id|ohci
comma
id|OHCI1394_IsoXmitIntMaskClear
comma
l_int|1
op_lshift
id|ctx
)paren
suffix:semicolon
id|reg_write
c_func
(paren
id|ohci
comma
id|OHCI1394_IsoXmitContextControlClear
op_plus
id|ctx
op_star
l_int|16
comma
id|OHCI1394_CONTEXT_RUN
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|wait
op_assign
l_int|0
suffix:semicolon
id|wait
OL
l_int|5
suffix:semicolon
id|wait
op_increment
)paren
(brace
id|control
op_assign
id|reg_read
c_func
(paren
id|ohci
comma
id|OHCI1394_IsoXmitContextControlSet
op_plus
id|ctx
op_star
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|control
op_amp
id|OHCI1394_CONTEXT_ACTIVE
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Note: we can test if free_packet_lists is empty without aquiring&n; * the packet_list_lock.  The interrupt handler only adds to the free&n; * list, there is no race condition between testing the list non-empty&n; * and acquiring the lock.&n; */
DECL|function|stream_get_free_packet_list
r_static
r_struct
id|packet_list
op_star
id|stream_get_free_packet_list
c_func
(paren
r_struct
id|stream
op_star
id|s
)paren
(brace
r_struct
id|packet_list
op_star
id|pl
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|s-&gt;free_packet_lists
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;packet_list_lock
comma
id|flags
)paren
suffix:semicolon
id|pl
op_assign
id|list_entry
c_func
(paren
id|s-&gt;free_packet_lists.next
comma
r_struct
id|packet_list
comma
id|link
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|pl-&gt;link
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;packet_list_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|pl
suffix:semicolon
)brace
DECL|function|stream_put_dma_packet_list
r_static
r_void
id|stream_put_dma_packet_list
c_func
(paren
r_struct
id|stream
op_star
id|s
comma
r_struct
id|packet_list
op_star
id|pl
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|packet_list
op_star
id|prev
suffix:semicolon
multiline_comment|/* Remember the cycle_count used for timestamping the last packet. */
id|pl-&gt;last_cycle_count
op_assign
id|atomic_read
c_func
(paren
op_amp
id|s-&gt;cycle_count2
)paren
op_minus
l_int|1
suffix:semicolon
id|pl-&gt;packets
(braket
id|PACKET_LIST_SIZE
op_minus
l_int|1
)braket
dot
id|db-&gt;payload_desc.branch
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;packet_list_lock
comma
id|flags
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|pl-&gt;link
comma
op_amp
id|s-&gt;dma_packet_lists
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;packet_list_lock
comma
id|flags
)paren
suffix:semicolon
id|prev
op_assign
id|list_entry
c_func
(paren
id|pl-&gt;link.prev
comma
r_struct
id|packet_list
comma
id|link
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pl-&gt;link.prev
op_ne
op_amp
id|s-&gt;dma_packet_lists
)paren
(brace
r_struct
id|packet
op_star
id|last
op_assign
op_amp
id|prev-&gt;packets
(braket
id|PACKET_LIST_SIZE
op_minus
l_int|1
)braket
suffix:semicolon
id|last-&gt;db-&gt;payload_desc.branch
op_assign
id|pl-&gt;packets
(braket
l_int|0
)braket
dot
id|db_bus
op_or
l_int|3
suffix:semicolon
id|ohci1394_wake_it_ctx
c_func
(paren
id|s-&gt;host-&gt;ohci
comma
id|s-&gt;iso_context
)paren
suffix:semicolon
)brace
r_else
(brace
id|u32
id|syt
comma
id|cycle_count
suffix:semicolon
id|cycle_count
op_assign
id|reg_read
c_func
(paren
id|s-&gt;host-&gt;host-&gt;hostdata
comma
id|OHCI1394_IsochronousCycleTimer
)paren
op_rshift
l_int|12
suffix:semicolon
id|syt
op_assign
(paren
id|pl-&gt;packets
(braket
l_int|0
)braket
dot
id|payload
(braket
l_int|1
)braket
op_rshift
l_int|12
)paren
op_amp
l_int|0x0f
suffix:semicolon
id|cycle_count
op_assign
(paren
id|cycle_count
op_amp
op_complement
l_int|0x0f
)paren
op_plus
l_int|32
op_plus
id|syt
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cycle_count
op_amp
l_int|0x1fff
)paren
op_ge
l_int|8000
)paren
id|cycle_count
op_assign
id|cycle_count
op_minus
l_int|8000
op_plus
l_int|0x2000
suffix:semicolon
id|ohci1394_start_it_ctx
c_func
(paren
id|s-&gt;host-&gt;ohci
comma
id|s-&gt;iso_context
comma
id|pl-&gt;packets
(braket
l_int|0
)braket
dot
id|db_bus
comma
l_int|3
comma
id|cycle_count
op_amp
l_int|0x7fff
)paren
suffix:semicolon
)brace
)brace
DECL|function|stream_shift_packet_lists
r_static
r_void
id|stream_shift_packet_lists
c_func
(paren
r_struct
id|stream
op_star
id|s
)paren
(brace
r_struct
id|packet_list
op_star
id|pl
suffix:semicolon
r_struct
id|packet
op_star
id|last
suffix:semicolon
r_int
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|s-&gt;dma_packet_lists
)paren
)paren
(brace
id|HPSB_ERR
c_func
(paren
l_string|&quot;empty dma_packet_lists in %s&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Now that we know the list is non-empty, we can get the head&n;&t; * of the list without locking, because the process context&n;&t; * only adds to the tail.  &n;&t; */
id|pl
op_assign
id|list_entry
c_func
(paren
id|s-&gt;dma_packet_lists.next
comma
r_struct
id|packet_list
comma
id|link
)paren
suffix:semicolon
id|last
op_assign
op_amp
id|pl-&gt;packets
(braket
id|PACKET_LIST_SIZE
op_minus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* This is weird... if we stop dma processing in the middle of&n;&t; * a packet list, the dma context immediately generates an&n;&t; * interrupt if we enable it again later.  This only happens&n;&t; * when amdtp_release is interrupted while waiting for dma to&n;&t; * complete, though.  Anyway, we detect this by seeing that&n;&t; * the status of the dma descriptor that we expected an&n;&t; * interrupt from is still 0.&n;&t; */
r_if
c_cond
(paren
id|last-&gt;db-&gt;payload_desc.status
op_eq
l_int|0
)paren
(brace
id|HPSB_INFO
c_func
(paren
l_string|&quot;weird interrupt...&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* If the last descriptor block does not specify a branch&n;&t; * address, we have a sample underflow.&n;&t; */
r_if
c_cond
(paren
id|last-&gt;db-&gt;payload_desc.branch
op_eq
l_int|0
)paren
id|HPSB_INFO
c_func
(paren
l_string|&quot;FIXME: sample underflow...&quot;
)paren
suffix:semicolon
multiline_comment|/* Here we check when (which cycle) the last packet was sent&n;&t; * and compare it to what the iso packer was using at the&n;&t; * time.  If there is a mismatch, we adjust the cycle count in&n;&t; * the iso packer.  However, there are still up to&n;&t; * MAX_PACKET_LISTS packet lists queued with bad time stamps,&n;&t; * so we disable time stamp monitoring for the next&n;&t; * MAX_PACKET_LISTS packet lists.&n;&t; */
id|diff
op_assign
(paren
id|last-&gt;db-&gt;payload_desc.status
op_minus
id|pl-&gt;last_cycle_count
)paren
op_amp
l_int|0xf
suffix:semicolon
r_if
c_cond
(paren
id|diff
OG
l_int|0
op_logical_and
id|s-&gt;stale_count
op_eq
l_int|0
)paren
(brace
id|atomic_add
c_func
(paren
id|diff
comma
op_amp
id|s-&gt;cycle_count
)paren
suffix:semicolon
id|atomic_add
c_func
(paren
id|diff
comma
op_amp
id|s-&gt;cycle_count2
)paren
suffix:semicolon
id|s-&gt;stale_count
op_assign
id|MAX_PACKET_LISTS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;stale_count
OG
l_int|0
)paren
id|s-&gt;stale_count
op_decrement
suffix:semicolon
multiline_comment|/* Finally, we move the packet list that was just processed&n;&t; * back to the free list, and notify any waiters.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|s-&gt;packet_list_lock
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|pl-&gt;link
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|pl-&gt;link
comma
op_amp
id|s-&gt;free_packet_lists
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|s-&gt;packet_list_lock
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|s-&gt;packet_list_wait
)paren
suffix:semicolon
)brace
DECL|function|stream_current_packet
r_static
r_struct
id|packet
op_star
id|stream_current_packet
c_func
(paren
r_struct
id|stream
op_star
id|s
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;current_packet_list
op_eq
l_int|NULL
op_logical_and
(paren
id|s-&gt;current_packet_list
op_assign
id|stream_get_free_packet_list
c_func
(paren
id|s
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
op_amp
id|s-&gt;current_packet_list-&gt;packets
(braket
id|s-&gt;current_packet
)braket
suffix:semicolon
)brace
DECL|function|stream_queue_packet
r_static
r_void
id|stream_queue_packet
c_func
(paren
r_struct
id|stream
op_star
id|s
)paren
(brace
id|s-&gt;current_packet
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;current_packet
op_eq
id|PACKET_LIST_SIZE
)paren
(brace
id|stream_put_dma_packet_list
c_func
(paren
id|s
comma
id|s-&gt;current_packet_list
)paren
suffix:semicolon
id|s-&gt;current_packet_list
op_assign
l_int|NULL
suffix:semicolon
id|s-&gt;current_packet
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Integer fractional math.  When we transmit a 44k1Hz signal we must&n; * send 5 41/80 samples per isochronous cycle, as these occur 8000&n; * times a second.  Of course, we must send an integral number of&n; * samples in a packet, so we use the integer math to alternate&n; * between sending 5 and 6 samples per packet.&n; */
DECL|function|fraction_init
r_static
r_void
id|fraction_init
c_func
(paren
r_struct
id|fraction
op_star
id|f
comma
r_int
id|numerator
comma
r_int
id|denominator
)paren
(brace
id|f-&gt;integer
op_assign
id|numerator
op_div
id|denominator
suffix:semicolon
id|f-&gt;numerator
op_assign
id|numerator
op_mod
id|denominator
suffix:semicolon
id|f-&gt;denominator
op_assign
id|denominator
suffix:semicolon
id|f-&gt;counter
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|fraction_next_size
r_static
r_int
id|fraction_next_size
c_func
(paren
r_struct
id|fraction
op_star
id|f
)paren
(brace
r_return
id|f-&gt;integer
op_plus
(paren
(paren
id|f-&gt;counter
op_plus
id|f-&gt;numerator
)paren
op_div
id|f-&gt;denominator
)paren
suffix:semicolon
)brace
DECL|function|fraction_inc
r_static
r_void
id|fraction_inc
c_func
(paren
r_struct
id|fraction
op_star
id|f
)paren
(brace
id|f-&gt;counter
op_assign
(paren
id|f-&gt;counter
op_plus
id|f-&gt;numerator
)paren
op_mod
id|f-&gt;denominator
suffix:semicolon
)brace
DECL|function|amdtp_irq_handler
r_static
r_void
id|amdtp_irq_handler
c_func
(paren
r_int
id|card
comma
id|quadlet_t
id|isoRecvIntEvent
comma
id|quadlet_t
id|isoXmitIntEvent
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|amdtp_host
op_star
id|host
op_assign
id|data
suffix:semicolon
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|stream
op_star
id|s
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|host-&gt;stream_list_lock
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|lh
comma
op_amp
id|host-&gt;stream_list
)paren
(brace
id|s
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|stream
comma
id|link
)paren
suffix:semicolon
r_if
c_cond
(paren
id|isoXmitIntEvent
op_amp
(paren
l_int|1
op_lshift
id|s-&gt;iso_context
)paren
)paren
r_break
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|host-&gt;stream_list_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_ne
l_int|NULL
)paren
id|stream_shift_packet_lists
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
DECL|function|packet_initialize
r_void
id|packet_initialize
c_func
(paren
r_struct
id|packet
op_star
id|p
comma
r_struct
id|packet
op_star
id|next
)paren
(brace
multiline_comment|/* Here we initialize the dma descriptor block for&n;&t; * transferring one iso packet.  We use two descriptors per&n;&t; * packet: an OUTPUT_MORE_IMMMEDIATE descriptor for the&n;&t; * IEEE1394 iso packet header and an OUTPUT_LAST descriptor&n;&t; * for the payload.&n;&t; */
id|p-&gt;db-&gt;header_desc.control
op_assign
id|DMA_CTL_OUTPUT_MORE
op_or
id|DMA_CTL_IMMEDIATE
op_or
l_int|8
suffix:semicolon
id|p-&gt;db-&gt;header_desc.skip
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|next
)paren
(brace
id|p-&gt;db-&gt;payload_desc.control
op_assign
id|DMA_CTL_OUTPUT_LAST
op_or
id|DMA_CTL_BRANCH
suffix:semicolon
id|p-&gt;db-&gt;payload_desc.branch
op_assign
id|next-&gt;db_bus
op_or
l_int|3
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;db-&gt;payload_desc.control
op_assign
id|DMA_CTL_OUTPUT_LAST
op_or
id|DMA_CTL_BRANCH
op_or
id|DMA_CTL_UPDATE
op_or
id|DMA_CTL_IRQ
suffix:semicolon
id|p-&gt;db-&gt;payload_desc.branch
op_assign
l_int|0
suffix:semicolon
)brace
id|p-&gt;db-&gt;payload_desc.data_address
op_assign
id|p-&gt;payload_bus
suffix:semicolon
id|p-&gt;db-&gt;payload_desc.status
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|packet_list_alloc
r_struct
id|packet_list
op_star
id|packet_list_alloc
c_func
(paren
r_struct
id|stream
op_star
id|s
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|packet_list
op_star
id|pl
suffix:semicolon
r_struct
id|packet
op_star
id|next
suffix:semicolon
id|pl
op_assign
id|kmalloc
c_func
(paren
r_sizeof
op_star
id|pl
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pl
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PACKET_LIST_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|packet
op_star
id|p
op_assign
op_amp
id|pl-&gt;packets
(braket
id|i
)braket
suffix:semicolon
id|p-&gt;db
op_assign
id|pci_pool_alloc
c_func
(paren
id|s-&gt;descriptor_pool
comma
id|SLAB_KERNEL
comma
op_amp
id|p-&gt;db_bus
)paren
suffix:semicolon
id|p-&gt;payload
op_assign
id|pci_pool_alloc
c_func
(paren
id|s-&gt;packet_pool
comma
id|SLAB_KERNEL
comma
op_amp
id|p-&gt;payload_bus
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PACKET_LIST_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
id|PACKET_LIST_SIZE
op_minus
l_int|1
)paren
id|next
op_assign
op_amp
id|pl-&gt;packets
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
r_else
id|next
op_assign
l_int|NULL
suffix:semicolon
id|packet_initialize
c_func
(paren
op_amp
id|pl-&gt;packets
(braket
id|i
)braket
comma
id|next
)paren
suffix:semicolon
)brace
r_return
id|pl
suffix:semicolon
)brace
DECL|function|packet_list_free
r_void
id|packet_list_free
c_func
(paren
r_struct
id|packet_list
op_star
id|pl
comma
r_struct
id|stream
op_star
id|s
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PACKET_LIST_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|packet
op_star
id|p
op_assign
op_amp
id|pl-&gt;packets
(braket
id|i
)braket
suffix:semicolon
id|pci_pool_free
c_func
(paren
id|s-&gt;descriptor_pool
comma
id|p-&gt;db
comma
id|p-&gt;db_bus
)paren
suffix:semicolon
id|pci_pool_free
c_func
(paren
id|s-&gt;packet_pool
comma
id|p-&gt;payload
comma
id|p-&gt;payload_bus
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|pl
)paren
suffix:semicolon
)brace
DECL|function|buffer_alloc
r_static
r_struct
id|buffer
op_star
id|buffer_alloc
c_func
(paren
r_int
id|size
)paren
(brace
r_struct
id|buffer
op_star
id|b
suffix:semicolon
id|b
op_assign
id|kmalloc
c_func
(paren
r_sizeof
op_star
id|b
op_plus
id|size
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
id|b-&gt;head
op_assign
l_int|0
suffix:semicolon
id|b-&gt;tail
op_assign
l_int|0
suffix:semicolon
id|b-&gt;length
op_assign
l_int|0
suffix:semicolon
id|b-&gt;size
op_assign
id|size
suffix:semicolon
r_return
id|b
suffix:semicolon
)brace
DECL|function|buffer_get_bytes
r_static
r_int
r_char
op_star
id|buffer_get_bytes
c_func
(paren
r_struct
id|buffer
op_star
id|buffer
comma
r_int
id|size
)paren
(brace
r_int
r_char
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|buffer-&gt;head
op_plus
id|size
OG
id|buffer-&gt;size
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|p
op_assign
op_amp
id|buffer-&gt;data
(braket
id|buffer-&gt;head
)braket
suffix:semicolon
id|buffer-&gt;head
op_add_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|buffer-&gt;head
op_eq
id|buffer-&gt;size
)paren
id|buffer-&gt;head
op_assign
l_int|0
suffix:semicolon
id|buffer-&gt;length
op_sub_assign
id|size
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|function|buffer_put_bytes
r_static
r_int
r_char
op_star
id|buffer_put_bytes
c_func
(paren
r_struct
id|buffer
op_star
id|buffer
comma
r_int
id|max
comma
r_int
op_star
id|actual
)paren
(brace
r_int
id|length
suffix:semicolon
r_int
r_char
op_star
id|p
suffix:semicolon
id|p
op_assign
op_amp
id|buffer-&gt;data
(braket
id|buffer-&gt;tail
)braket
suffix:semicolon
id|length
op_assign
id|min
c_func
(paren
id|buffer-&gt;size
op_minus
id|buffer-&gt;length
comma
id|max
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer-&gt;tail
op_plus
id|length
OL
id|buffer-&gt;size
)paren
(brace
op_star
id|actual
op_assign
id|length
suffix:semicolon
id|buffer-&gt;tail
op_add_assign
id|length
suffix:semicolon
)brace
r_else
(brace
op_star
id|actual
op_assign
id|buffer-&gt;size
op_minus
id|buffer-&gt;tail
suffix:semicolon
id|buffer-&gt;tail
op_assign
l_int|0
suffix:semicolon
)brace
id|buffer-&gt;length
op_add_assign
op_star
id|actual
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|function|get_iec958_header_bits
r_static
id|u32
id|get_iec958_header_bits
c_func
(paren
r_struct
id|stream
op_star
id|s
comma
r_int
id|sub_frame
comma
id|u32
id|sample
)paren
(brace
r_int
id|csi
comma
id|parity
comma
id|shift
suffix:semicolon
r_int
id|block_start
suffix:semicolon
id|u32
id|bits
suffix:semicolon
r_switch
c_cond
(paren
id|s-&gt;iec958_frame_count
)paren
(brace
r_case
l_int|1
suffix:colon
id|csi
op_assign
id|s-&gt;format
op_eq
id|AMDTP_FORMAT_IEC958_AC3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_case
l_int|9
suffix:colon
id|csi
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|24
dot
dot
dot
l_int|27
suffix:colon
id|csi
op_assign
(paren
id|s-&gt;iec958_rate_code
op_rshift
(paren
l_int|27
op_minus
id|s-&gt;iec958_frame_count
)paren
)paren
op_amp
l_int|0x01
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|csi
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|block_start
op_assign
(paren
id|s-&gt;iec958_frame_count
op_eq
l_int|0
op_logical_and
id|sub_frame
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* The parity bit is the xor of the sample bits and the&n;&t; * channel status info bit. */
r_for
c_loop
(paren
id|shift
op_assign
l_int|16
comma
id|parity
op_assign
id|sample
op_xor
id|csi
suffix:semicolon
id|shift
OG
l_int|0
suffix:semicolon
id|shift
op_rshift_assign
l_int|1
)paren
id|parity
op_xor_assign
(paren
id|parity
op_rshift
id|shift
)paren
suffix:semicolon
id|bits
op_assign
(paren
id|block_start
op_lshift
l_int|5
)paren
op_or
multiline_comment|/* Block start bit */
(paren
(paren
id|sub_frame
op_eq
l_int|0
)paren
op_lshift
l_int|4
)paren
op_or
multiline_comment|/* Subframe bit */
(paren
(paren
id|parity
op_amp
l_int|1
)paren
op_lshift
l_int|3
)paren
op_or
multiline_comment|/* Parity bit */
(paren
id|csi
op_lshift
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Channel status info bit */
r_return
id|bits
suffix:semicolon
)brace
DECL|function|get_header_bits
r_static
id|u32
id|get_header_bits
c_func
(paren
r_struct
id|stream
op_star
id|s
comma
r_int
id|sub_frame
comma
id|u32
id|sample
)paren
(brace
r_switch
c_cond
(paren
id|s-&gt;format
)paren
(brace
r_case
id|AMDTP_FORMAT_IEC958_PCM
suffix:colon
r_case
id|AMDTP_FORMAT_IEC958_AC3
suffix:colon
r_return
id|get_iec958_header_bits
c_func
(paren
id|s
comma
id|sub_frame
comma
id|sample
)paren
suffix:semicolon
r_case
id|AMDTP_FORMAT_RAW
suffix:colon
r_return
l_int|0x40000000
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|fill_packet
r_static
r_void
id|fill_packet
c_func
(paren
r_struct
id|stream
op_star
id|s
comma
r_struct
id|packet
op_star
id|packet
comma
r_int
id|nevents
)paren
(brace
r_int
id|size
comma
id|node_id
comma
id|i
comma
id|j
suffix:semicolon
id|quadlet_t
op_star
id|event
suffix:semicolon
r_int
r_char
op_star
id|p
suffix:semicolon
id|u32
id|control
comma
id|sample
comma
id|bits
suffix:semicolon
r_int
id|syt_index
comma
id|syt
comma
id|next
suffix:semicolon
id|size
op_assign
(paren
id|nevents
op_star
id|s-&gt;dimension
op_plus
l_int|2
)paren
op_star
r_sizeof
(paren
id|quadlet_t
)paren
suffix:semicolon
id|node_id
op_assign
id|s-&gt;host-&gt;host-&gt;node_id
op_amp
l_int|0x3f
suffix:semicolon
multiline_comment|/* Update DMA descriptors */
id|packet-&gt;db-&gt;payload_desc.status
op_assign
l_int|0
suffix:semicolon
id|control
op_assign
id|packet-&gt;db-&gt;payload_desc.control
op_amp
l_int|0xffff0000
suffix:semicolon
id|packet-&gt;db-&gt;payload_desc.control
op_assign
id|control
op_or
id|size
suffix:semicolon
multiline_comment|/* Fill IEEE1394 headers */
id|packet-&gt;db-&gt;header_desc.header
(braket
l_int|0
)braket
op_assign
(paren
id|SPEED_100
op_lshift
l_int|16
)paren
op_or
(paren
l_int|0x01
op_lshift
l_int|14
)paren
op_or
(paren
id|s-&gt;iso_channel
op_lshift
l_int|8
)paren
op_or
(paren
id|TCODE_ISO_DATA
op_lshift
l_int|4
)paren
suffix:semicolon
id|packet-&gt;db-&gt;header_desc.header
(braket
l_int|1
)braket
op_assign
id|size
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* Fill cip header */
id|syt_index
op_assign
id|s-&gt;dbc
op_amp
(paren
id|s-&gt;syt_interval
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|syt_index
op_eq
l_int|0
op_logical_or
id|syt_index
op_plus
id|nevents
OG
id|s-&gt;syt_interval
)paren
(brace
id|syt
op_assign
(paren
(paren
id|atomic_read
c_func
(paren
op_amp
id|s-&gt;cycle_count
)paren
op_lshift
l_int|12
)paren
op_or
id|s-&gt;cycle_offset
)paren
op_amp
l_int|0xffff
suffix:semicolon
id|next
op_assign
id|fraction_next_size
c_func
(paren
op_amp
id|s-&gt;syt_fraction
)paren
op_plus
id|s-&gt;cycle_offset
suffix:semicolon
multiline_comment|/* This next addition should be modulo 8000 (0x1f40),&n;&t;&t; * but we only use the lower 4 bits of cycle_count, so&n;&t;&t; * we dont need the modulo. */
id|atomic_add
c_func
(paren
id|next
op_div
l_int|3072
comma
op_amp
id|s-&gt;cycle_count
)paren
suffix:semicolon
id|s-&gt;cycle_offset
op_assign
id|next
op_mod
l_int|3072
suffix:semicolon
id|fraction_inc
c_func
(paren
op_amp
id|s-&gt;syt_fraction
)paren
suffix:semicolon
)brace
r_else
(brace
id|syt
op_assign
l_int|0xffff
suffix:semicolon
id|next
op_assign
l_int|0
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
id|s-&gt;cycle_count2
)paren
suffix:semicolon
id|packet-&gt;payload
(braket
l_int|0
)braket
op_assign
id|cpu_to_be32
c_func
(paren
(paren
id|node_id
op_lshift
l_int|24
)paren
op_or
(paren
id|s-&gt;dimension
op_lshift
l_int|16
)paren
op_or
id|s-&gt;dbc
)paren
suffix:semicolon
id|packet-&gt;payload
(braket
l_int|1
)braket
op_assign
id|cpu_to_be32
c_func
(paren
(paren
l_int|1
op_lshift
l_int|31
)paren
op_or
(paren
id|FMT_AMDTP
op_lshift
l_int|24
)paren
op_or
(paren
id|s-&gt;fdf
op_lshift
l_int|16
)paren
op_or
id|syt
)paren
suffix:semicolon
multiline_comment|/* Fill payload */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|event
op_assign
op_amp
id|packet-&gt;payload
(braket
l_int|2
)braket
suffix:semicolon
id|i
OL
id|nevents
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|s-&gt;dimension
suffix:semicolon
id|j
op_increment
)paren
(brace
id|p
op_assign
id|buffer_get_bytes
c_func
(paren
id|s-&gt;input
comma
l_int|2
)paren
suffix:semicolon
id|sample
op_assign
(paren
id|p
(braket
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|p
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
id|bits
op_assign
id|get_header_bits
c_func
(paren
id|s
comma
id|j
comma
id|sample
)paren
suffix:semicolon
id|event
(braket
id|j
)braket
op_assign
id|cpu_to_be32
c_func
(paren
(paren
id|bits
op_lshift
l_int|24
)paren
op_or
id|sample
)paren
suffix:semicolon
)brace
id|event
op_add_assign
id|s-&gt;dimension
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|s-&gt;iec958_frame_count
op_eq
l_int|192
)paren
id|s-&gt;iec958_frame_count
op_assign
l_int|0
suffix:semicolon
)brace
id|s-&gt;dbc
op_add_assign
id|nevents
suffix:semicolon
)brace
DECL|function|stream_flush
r_static
r_void
id|stream_flush
c_func
(paren
r_struct
id|stream
op_star
id|s
)paren
(brace
r_struct
id|packet
op_star
id|p
suffix:semicolon
r_int
id|nevents
suffix:semicolon
r_while
c_loop
(paren
id|nevents
op_assign
id|fraction_next_size
c_func
(paren
op_amp
id|s-&gt;packet_size_fraction
)paren
comma
id|p
op_assign
id|stream_current_packet
c_func
(paren
id|s
)paren
comma
id|nevents
op_star
id|s-&gt;dimension
op_star
l_int|2
op_le
id|s-&gt;input-&gt;length
op_logical_and
id|p
op_ne
l_int|NULL
)paren
(brace
id|fill_packet
c_func
(paren
id|s
comma
id|p
comma
id|nevents
)paren
suffix:semicolon
id|fraction_inc
c_func
(paren
op_amp
id|s-&gt;packet_size_fraction
)paren
suffix:semicolon
id|stream_queue_packet
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
)brace
DECL|function|stream_alloc_packet_lists
r_static
r_int
id|stream_alloc_packet_lists
c_func
(paren
r_struct
id|stream
op_star
id|s
)paren
(brace
r_int
id|max_nevents
comma
id|max_packet_size
comma
id|i
suffix:semicolon
id|max_nevents
op_assign
id|s-&gt;packet_size_fraction.integer
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;packet_size_fraction.numerator
OG
l_int|0
)paren
id|max_nevents
op_increment
suffix:semicolon
id|max_packet_size
op_assign
id|max_nevents
op_star
id|s-&gt;dimension
op_star
l_int|4
op_plus
l_int|8
suffix:semicolon
id|s-&gt;packet_pool
op_assign
id|pci_pool_create
c_func
(paren
l_string|&quot;packet pool&quot;
comma
id|s-&gt;host-&gt;ohci-&gt;dev
comma
id|max_packet_size
comma
l_int|0
comma
l_int|0
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;packet_pool
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|s-&gt;free_packet_lists
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|s-&gt;dma_packet_lists
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_PACKET_LISTS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|packet_list
op_star
id|pl
op_assign
id|packet_list_alloc
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pl
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|pl-&gt;link
comma
op_amp
id|s-&gt;free_packet_lists
)paren
suffix:semicolon
)brace
r_return
id|i
OL
id|MAX_PACKET_LISTS
ques
c_cond
op_minus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|stream_free_packet_lists
r_static
r_void
id|stream_free_packet_lists
c_func
(paren
r_struct
id|stream
op_star
id|s
)paren
(brace
r_struct
id|list_head
op_star
id|lh
comma
op_star
id|next
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;current_packet_list
op_ne
l_int|NULL
)paren
id|packet_list_free
c_func
(paren
id|s-&gt;current_packet_list
comma
id|s
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|lh
comma
id|next
comma
op_amp
id|s-&gt;dma_packet_lists
)paren
id|packet_list_free
c_func
(paren
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|packet_list
comma
id|link
)paren
comma
id|s
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|lh
comma
id|next
comma
op_amp
id|s-&gt;free_packet_lists
)paren
id|packet_list_free
c_func
(paren
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|packet_list
comma
id|link
)paren
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;packet_pool
op_ne
l_int|NULL
)paren
id|pci_pool_destroy
c_func
(paren
id|s-&gt;packet_pool
)paren
suffix:semicolon
id|s-&gt;current_packet_list
op_assign
l_int|NULL
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|s-&gt;free_packet_lists
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|s-&gt;dma_packet_lists
)paren
suffix:semicolon
id|s-&gt;packet_pool
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|plug_update
r_static
r_void
id|plug_update
c_func
(paren
r_struct
id|cmp_pcr
op_star
id|plug
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|stream
op_star
id|s
op_assign
id|data
suffix:semicolon
id|HPSB_INFO
c_func
(paren
l_string|&quot;plug update: p2p_count=%d, channel=%d&quot;
comma
id|plug-&gt;p2p_count
comma
id|plug-&gt;channel
)paren
suffix:semicolon
id|s-&gt;iso_channel
op_assign
id|plug-&gt;channel
suffix:semicolon
r_if
c_cond
(paren
id|plug-&gt;p2p_count
OG
l_int|0
)paren
(brace
multiline_comment|/* start streaming */
)brace
r_else
(brace
multiline_comment|/* stop streaming */
)brace
)brace
DECL|function|stream_configure
r_static
r_int
id|stream_configure
c_func
(paren
r_struct
id|stream
op_star
id|s
comma
r_int
id|cmd
comma
r_struct
id|amdtp_ioctl
op_star
id|cfg
)paren
(brace
r_if
c_cond
(paren
id|cfg-&gt;format
op_le
id|AMDTP_FORMAT_IEC958_AC3
)paren
id|s-&gt;format
op_assign
id|cfg-&gt;format
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|cfg-&gt;rate
)paren
(brace
r_case
l_int|32000
suffix:colon
id|s-&gt;syt_interval
op_assign
l_int|8
suffix:semicolon
id|s-&gt;fdf
op_assign
id|FDF_SFC_32KHZ
suffix:semicolon
id|s-&gt;iec958_rate_code
op_assign
l_int|0x0c
suffix:semicolon
id|s-&gt;rate
op_assign
id|cfg-&gt;rate
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|44100
suffix:colon
id|s-&gt;syt_interval
op_assign
l_int|8
suffix:semicolon
id|s-&gt;fdf
op_assign
id|FDF_SFC_44K1HZ
suffix:semicolon
id|s-&gt;iec958_rate_code
op_assign
l_int|0x00
suffix:semicolon
id|s-&gt;rate
op_assign
id|cfg-&gt;rate
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|48000
suffix:colon
id|s-&gt;syt_interval
op_assign
l_int|8
suffix:semicolon
id|s-&gt;fdf
op_assign
id|FDF_SFC_48KHZ
suffix:semicolon
id|s-&gt;iec958_rate_code
op_assign
l_int|0x04
suffix:semicolon
id|s-&gt;rate
op_assign
id|cfg-&gt;rate
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|fraction_init
c_func
(paren
op_amp
id|s-&gt;packet_size_fraction
comma
id|s-&gt;rate
comma
l_int|8000
)paren
suffix:semicolon
multiline_comment|/* The syt_fraction is initialized to the number of ticks&n;&t; * between syt_interval events.  The number of ticks per&n;&t; * second is 24.576e6, so the number of ticks between&n;&t; * syt_interval events is 24.576e6 * syt_interval / rate.&n;&t; */
id|fraction_init
c_func
(paren
op_amp
id|s-&gt;syt_fraction
comma
l_int|24576000
op_star
id|s-&gt;syt_interval
comma
id|s-&gt;rate
)paren
suffix:semicolon
multiline_comment|/* When using the AM824 raw subformat we can stream signals of&n;&t; * any dimension.  The IEC958 subformat, however, only&n;&t; * supports 2 channels.&n;&t; */
r_if
c_cond
(paren
id|s-&gt;format
op_eq
id|AMDTP_FORMAT_RAW
op_logical_or
id|cfg-&gt;dimension
op_eq
l_int|2
)paren
id|s-&gt;dimension
op_assign
id|cfg-&gt;dimension
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;opcr
op_ne
l_int|NULL
)paren
(brace
id|cmp_unregister_opcr
c_func
(paren
id|s-&gt;host-&gt;host
comma
id|s-&gt;opcr
)paren
suffix:semicolon
id|s-&gt;opcr
op_assign
l_int|NULL
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|AMDTP_IOC_PLUG
suffix:colon
id|s-&gt;opcr
op_assign
id|cmp_register_opcr
c_func
(paren
id|s-&gt;host-&gt;host
comma
id|cfg-&gt;u.plug
comma
multiline_comment|/*payload*/
l_int|12
comma
id|plug_update
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;opcr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|s-&gt;iso_channel
op_assign
id|s-&gt;opcr-&gt;channel
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AMDTP_IOC_CHANNEL
suffix:colon
r_if
c_cond
(paren
id|cfg-&gt;u.channel
op_ge
l_int|0
op_logical_and
id|cfg-&gt;u.channel
OL
l_int|64
)paren
id|s-&gt;iso_channel
op_assign
id|cfg-&gt;u.channel
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* The ioctl settings were all valid, so we realloc the packet&n;&t; * lists to make sure the packet size is big enough.&n;&t; */
r_if
c_cond
(paren
id|s-&gt;packet_pool
op_ne
l_int|NULL
)paren
id|stream_free_packet_lists
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stream_alloc_packet_lists
c_func
(paren
id|s
)paren
OL
l_int|0
)paren
(brace
id|stream_free_packet_lists
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|stream_alloc
r_struct
id|stream
op_star
id|stream_alloc
c_func
(paren
r_struct
id|amdtp_host
op_star
id|host
)paren
(brace
r_struct
id|stream
op_star
id|s
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_const
r_int
id|transfer_delay
op_assign
l_int|8651
suffix:semicolon
multiline_comment|/* approx 352 us */
id|s
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|stream
)paren
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|s
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|stream
)paren
)paren
suffix:semicolon
id|s-&gt;host
op_assign
id|host
suffix:semicolon
id|s-&gt;input
op_assign
id|buffer_alloc
c_func
(paren
id|BUFFER_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;input
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|s-&gt;cycle_offset
op_assign
id|transfer_delay
op_mod
l_int|3072
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|s-&gt;cycle_count
comma
id|transfer_delay
op_div
l_int|3072
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|s-&gt;cycle_count2
comma
l_int|0
)paren
suffix:semicolon
id|s-&gt;descriptor_pool
op_assign
id|pci_pool_create
c_func
(paren
l_string|&quot;descriptor pool&quot;
comma
id|host-&gt;ohci-&gt;dev
comma
r_sizeof
(paren
r_struct
id|descriptor_block
)paren
comma
l_int|16
comma
l_int|0
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;descriptor_pool
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|s-&gt;input
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|s-&gt;free_packet_lists
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|s-&gt;dma_packet_lists
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|s-&gt;packet_list_wait
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|s-&gt;packet_list_lock
)paren
suffix:semicolon
id|s-&gt;iso_context
op_assign
id|ohci1394_alloc_it_ctx
c_func
(paren
id|host-&gt;ohci
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;iso_context
OL
l_int|0
)paren
(brace
id|pci_pool_destroy
c_func
(paren
id|s-&gt;descriptor_pool
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|s-&gt;input
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|host-&gt;stream_list_lock
comma
id|flags
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|s-&gt;link
comma
op_amp
id|host-&gt;stream_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|host-&gt;stream_list_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|s
suffix:semicolon
)brace
DECL|function|stream_free
r_void
id|stream_free
c_func
(paren
r_struct
id|stream
op_star
id|s
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Stop the DMA.  We wait for the dma packet list to become&n;&t; * empty and let the dma controller run out of programs.  This&n;&t; * seems to be more reliable than stopping it directly, since&n;&t; * that sometimes generates an it transmit interrupt if we&n;&t; * later re-enable the context.&n;&t; */
id|wait_event_interruptible
c_func
(paren
id|s-&gt;packet_list_wait
comma
id|list_empty
c_func
(paren
op_amp
id|s-&gt;dma_packet_lists
)paren
)paren
suffix:semicolon
id|ohci1394_stop_it_ctx
c_func
(paren
id|s-&gt;host-&gt;ohci
comma
id|s-&gt;iso_context
)paren
suffix:semicolon
id|ohci1394_free_it_ctx
c_func
(paren
id|s-&gt;host-&gt;ohci
comma
id|s-&gt;iso_context
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;opcr
op_ne
l_int|NULL
)paren
id|cmp_unregister_opcr
c_func
(paren
id|s-&gt;host-&gt;host
comma
id|s-&gt;opcr
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;host-&gt;stream_list_lock
comma
id|flags
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|s-&gt;link
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;host-&gt;stream_list_lock
comma
id|flags
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|s-&gt;input
)paren
suffix:semicolon
id|stream_free_packet_lists
c_func
(paren
id|s
)paren
suffix:semicolon
id|pci_pool_destroy
c_func
(paren
id|s-&gt;descriptor_pool
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/* File operations */
DECL|function|amdtp_write
r_static
id|ssize_t
id|amdtp_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|offset_is_ignored
)paren
(brace
r_struct
id|stream
op_star
id|s
op_assign
id|file-&gt;private_data
suffix:semicolon
r_int
r_char
op_star
id|p
suffix:semicolon
r_int
id|i
comma
id|length
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;packet_pool
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EBADFD
suffix:semicolon
multiline_comment|/* Fill the circular buffer from the input buffer and call the&n;&t; * iso packer when the buffer is full.  The iso packer may&n;&t; * leave bytes in the buffer for two reasons: either the&n;&t; * remaining bytes wasn&squot;t enough to build a new packet, or&n;&t; * there were no free packet lists.  In the first case we&n;&t; * re-fill the buffer and call the iso packer again or return&n;&t; * if we used all the data from userspace.  In the second&n;&t; * case, the wait_event_interruptible will block until the irq&n;&t; * handler frees a packet list.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_add_assign
id|length
)paren
(brace
id|p
op_assign
id|buffer_put_bytes
c_func
(paren
id|s-&gt;input
comma
id|count
comma
op_amp
id|length
)paren
suffix:semicolon
id|copy_from_user
c_func
(paren
id|p
comma
id|buffer
op_plus
id|i
comma
id|length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;input-&gt;length
OL
id|s-&gt;input-&gt;size
)paren
r_continue
suffix:semicolon
id|stream_flush
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;current_packet_list
op_eq
l_int|NULL
op_logical_and
id|wait_event_interruptible
c_func
(paren
id|s-&gt;packet_list_wait
comma
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|s-&gt;free_packet_lists
)paren
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
DECL|function|amdtp_ioctl
r_static
r_int
id|amdtp_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|stream
op_star
id|s
op_assign
id|file-&gt;private_data
suffix:semicolon
r_struct
id|amdtp_ioctl
id|cfg
suffix:semicolon
r_int
r_new
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|AMDTP_IOC_PLUG
suffix:colon
r_case
id|AMDTP_IOC_CHANNEL
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|cfg
comma
(paren
r_struct
id|amdtp_ioctl
op_star
)paren
id|arg
comma
r_sizeof
id|cfg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
id|stream_configure
c_func
(paren
id|s
comma
id|cmd
comma
op_amp
id|cfg
)paren
suffix:semicolon
r_case
id|AMDTP_IOC_PING
suffix:colon
id|HPSB_INFO
c_func
(paren
l_string|&quot;ping: offsetting timpestamps %ld ticks&quot;
comma
id|arg
)paren
suffix:semicolon
r_new
op_assign
id|s-&gt;cycle_offset
op_plus
id|arg
suffix:semicolon
id|s-&gt;cycle_offset
op_assign
r_new
op_mod
l_int|3072
suffix:semicolon
id|atomic_add
c_func
(paren
r_new
op_div
l_int|3072
comma
op_amp
id|s-&gt;cycle_count
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|AMDTP_IOC_ZAP
suffix:colon
r_while
c_loop
(paren
id|MOD_IN_USE
)paren
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|amdtp_open
r_static
r_int
id|amdtp_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|amdtp_host
op_star
id|host
suffix:semicolon
multiline_comment|/* FIXME: We just grab the first registered host */
id|spin_lock
c_func
(paren
op_amp
id|host_list_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|host_list
)paren
)paren
id|host
op_assign
id|list_entry
c_func
(paren
id|host_list.next
comma
r_struct
id|amdtp_host
comma
id|link
)paren
suffix:semicolon
r_else
id|host
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|host_list_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|host
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|file-&gt;private_data
op_assign
id|stream_alloc
c_func
(paren
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;private_data
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|amdtp_release
r_static
r_int
id|amdtp_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|stream
op_star
id|s
op_assign
id|file-&gt;private_data
suffix:semicolon
id|stream_free
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|amdtp_fops
r_static
r_struct
id|file_operations
id|amdtp_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|write
suffix:colon
id|amdtp_write
comma
id|ioctl
suffix:colon
id|amdtp_ioctl
comma
id|open
suffix:colon
id|amdtp_open
comma
id|release
suffix:colon
id|amdtp_release
)brace
suffix:semicolon
multiline_comment|/* IEEE1394 Subsystem functions */
DECL|function|amdtp_add_host
r_static
r_void
id|amdtp_add_host
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
(brace
r_struct
id|amdtp_host
op_star
id|ah
suffix:semicolon
multiline_comment|/* FIXME: check it&squot;s an ohci host. */
id|ah
op_assign
id|kmalloc
c_func
(paren
r_sizeof
op_star
id|ah
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
id|ah-&gt;host
op_assign
id|host
suffix:semicolon
id|ah-&gt;ohci
op_assign
id|host-&gt;hostdata
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ah-&gt;stream_list
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|ah-&gt;stream_list_lock
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|host_list_lock
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|ah-&gt;link
comma
op_amp
id|host_list
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|host_list_lock
)paren
suffix:semicolon
id|ohci1394_hook_irq
c_func
(paren
id|ah-&gt;ohci
comma
id|amdtp_irq_handler
comma
id|ah
)paren
suffix:semicolon
)brace
DECL|function|amdtp_remove_host
r_static
r_void
id|amdtp_remove_host
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|amdtp_host
op_star
id|ah
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|host_list_lock
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|lh
comma
op_amp
id|host_list
)paren
(brace
r_if
c_cond
(paren
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|amdtp_host
comma
id|link
)paren
op_member_access_from_pointer
id|host
op_eq
id|host
)paren
(brace
id|list_del
c_func
(paren
id|lh
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|host_list_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lh
op_ne
op_amp
id|host_list
)paren
(brace
id|ah
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|amdtp_host
comma
id|link
)paren
suffix:semicolon
id|ohci1394_unhook_irq
c_func
(paren
id|ah-&gt;ohci
comma
id|amdtp_irq_handler
comma
id|ah
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ah
)paren
suffix:semicolon
)brace
r_else
id|HPSB_ERR
c_func
(paren
l_string|&quot;remove_host: bogus ohci host: %p&quot;
comma
id|host
)paren
suffix:semicolon
)brace
DECL|variable|amdtp_highlevel_ops
r_static
r_struct
id|hpsb_highlevel_ops
id|amdtp_highlevel_ops
op_assign
(brace
id|add_host
suffix:colon
id|amdtp_add_host
comma
id|remove_host
suffix:colon
id|amdtp_remove_host
comma
)brace
suffix:semicolon
multiline_comment|/* Module interface */
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Kristian Hogsberg &lt;hogsberg@users.sf.net&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Driver for Audio &amp; Music Data Transmission Protocol &quot;
l_string|&quot;on OHCI boards.&quot;
)paren
suffix:semicolon
id|MODULE_SUPPORTED_DEVICE
c_func
(paren
l_string|&quot;amdtp&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|function|amdtp_init_module
r_static
r_int
id|__init
id|amdtp_init_module
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|ieee1394_register_chardev
c_func
(paren
id|IEEE1394_MINOR_BLOCK_EXPERIMENTAL
comma
id|THIS_MODULE
comma
op_amp
id|amdtp_fops
)paren
)paren
(brace
id|HPSB_ERR
c_func
(paren
l_string|&quot;amdtp: unable to get minor device block&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|amdtp_highlevel
op_assign
id|hpsb_register_highlevel
(paren
l_string|&quot;amdtp&quot;
comma
op_amp
id|amdtp_highlevel_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|amdtp_highlevel
op_eq
l_int|NULL
)paren
(brace
id|HPSB_ERR
c_func
(paren
l_string|&quot;amdtp: unable to register highlevel ops&quot;
)paren
suffix:semicolon
id|ieee1394_unregister_chardev
c_func
(paren
id|IEEE1394_MINOR_BLOCK_EXPERIMENTAL
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|HPSB_INFO
c_func
(paren
l_string|&quot;Loaded AMDTP driver&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|amdtp_exit_module
r_static
r_void
id|__exit
id|amdtp_exit_module
(paren
r_void
)paren
(brace
id|hpsb_unregister_highlevel
c_func
(paren
id|amdtp_highlevel
)paren
suffix:semicolon
id|ieee1394_unregister_chardev
c_func
(paren
id|IEEE1394_MINOR_BLOCK_EXPERIMENTAL
)paren
suffix:semicolon
id|HPSB_INFO
c_func
(paren
l_string|&quot;Unloaded AMDTP driver&quot;
)paren
suffix:semicolon
)brace
DECL|variable|amdtp_init_module
id|module_init
c_func
(paren
id|amdtp_init_module
)paren
suffix:semicolon
DECL|variable|amdtp_exit_module
id|module_exit
c_func
(paren
id|amdtp_exit_module
)paren
suffix:semicolon
eof
