multiline_comment|/* -*- c-basic-offset: 8 -*-&n; *&n; * amdtp.c - Audio and Music Data Transmission Protocol Driver&n; * Copyright (C) 2001 Kristian H&#xfffd;gsberg&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software Foundation,&n; * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.&n; */
multiline_comment|/* OVERVIEW&n; * --------&n; *&n; * The AMDTP driver is designed to expose the IEEE1394 bus as a&n; * regular OSS soundcard, i.e. you can link /dev/dsp to /dev/amdtp and&n; * then your favourite MP3 player, game or whatever sound program will&n; * output to an IEEE1394 isochronous channel.  The signal destination&n; * could be a set of IEEE1394 loudspeakers (if and when such things&n; * become available) or an amplifier with IEEE1394 input (like the&n; * Sony STR-LSA1).  The driver only handles the actual streaming, some&n; * connection management is also required for this to actually work.&n; * That is outside the scope of this driver, and furthermore it is not&n; * really standardized yet.&n; *&n; * The Audio and Music Data Tranmission Protocol is available at&n; *&n; *     http://www.1394ta.org/Download/Technology/Specifications/2001/AM20Final-jf2.pdf&n; *&n; *&n; * TODO&n; * ----&n; *&n; * - We should be able to change input sample format between LE/BE, as&n; *   we already shift the bytes around when we construct the iso&n; *   packets.&n; *&n; * - Fix DMA stop after bus reset!&n; *&n; * - Clean up iso context handling in ohci1394.&n; *&n; *&n; * MAYBE TODO&n; * ----------&n; *&n; * - Receive data for local playback or recording.  Playback requires&n; *   soft syncing with the sound card.&n; *&n; * - Signal processing, i.e. receive packets, do some processing, and&n; *   transmit them again using the same packet structure and timestamps&n; *   offset by processing time.&n; *&n; * - Maybe make an ALSA interface, that is, create a file_ops&n; *   implementation that recognizes ALSA ioctls and uses defaults for&n; *   things that can&squot;t be controlled through ALSA (iso channel).&n; *&n; *   Changes:&n; *&n; * - Audit copy_from_user in amdtp_write.&n; *                           Daniele Bellucci &lt;bellucda@tiscali.it&gt;&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/ioctl.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/ioctl32.h&gt;
macro_line|#include &lt;linux/compat.h&gt;
macro_line|#include &lt;linux/cdev.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;highlevel.h&quot;
macro_line|#include &quot;ieee1394.h&quot;
macro_line|#include &quot;ieee1394_core.h&quot;
macro_line|#include &quot;ohci1394.h&quot;
macro_line|#include &quot;amdtp.h&quot;
macro_line|#include &quot;cmp.h&quot;
DECL|macro|FMT_AMDTP
mdefine_line|#define FMT_AMDTP 0x10
DECL|macro|FDF_AM824
mdefine_line|#define FDF_AM824 0x00
DECL|macro|FDF_SFC_32KHZ
mdefine_line|#define FDF_SFC_32KHZ   0x00
DECL|macro|FDF_SFC_44K1HZ
mdefine_line|#define FDF_SFC_44K1HZ  0x01
DECL|macro|FDF_SFC_48KHZ
mdefine_line|#define FDF_SFC_48KHZ   0x02
DECL|macro|FDF_SFC_88K2HZ
mdefine_line|#define FDF_SFC_88K2HZ  0x03
DECL|macro|FDF_SFC_96KHZ
mdefine_line|#define FDF_SFC_96KHZ   0x04
DECL|macro|FDF_SFC_176K4HZ
mdefine_line|#define FDF_SFC_176K4HZ 0x05
DECL|macro|FDF_SFC_192KHZ
mdefine_line|#define FDF_SFC_192KHZ  0x06
DECL|struct|descriptor_block
r_struct
id|descriptor_block
(brace
DECL|struct|output_more_immediate
r_struct
id|output_more_immediate
(brace
DECL|member|control
id|u32
id|control
suffix:semicolon
DECL|member|pad0
id|u32
id|pad0
suffix:semicolon
DECL|member|skip
id|u32
id|skip
suffix:semicolon
DECL|member|pad1
id|u32
id|pad1
suffix:semicolon
DECL|member|header
id|u32
id|header
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|header_desc
)brace
id|header_desc
suffix:semicolon
DECL|struct|output_last
r_struct
id|output_last
(brace
DECL|member|control
id|u32
id|control
suffix:semicolon
DECL|member|data_address
id|u32
id|data_address
suffix:semicolon
DECL|member|branch
id|u32
id|branch
suffix:semicolon
DECL|member|status
id|u32
id|status
suffix:semicolon
DECL|member|payload_desc
)brace
id|payload_desc
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|packet
r_struct
id|packet
(brace
DECL|member|db
r_struct
id|descriptor_block
op_star
id|db
suffix:semicolon
DECL|member|db_bus
id|dma_addr_t
id|db_bus
suffix:semicolon
DECL|member|payload
r_struct
id|iso_packet
op_star
id|payload
suffix:semicolon
DECL|member|payload_bus
id|dma_addr_t
id|payload_bus
suffix:semicolon
)brace
suffix:semicolon
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#if defined __BIG_ENDIAN_BITFIELD
DECL|struct|iso_packet
r_struct
id|iso_packet
(brace
multiline_comment|/* First quadlet */
DECL|member|dbs
r_int
r_int
id|dbs
suffix:colon
l_int|8
suffix:semicolon
DECL|member|eoh0
r_int
r_int
id|eoh0
suffix:colon
l_int|2
suffix:semicolon
DECL|member|sid
r_int
r_int
id|sid
suffix:colon
l_int|6
suffix:semicolon
DECL|member|dbc
r_int
r_int
id|dbc
suffix:colon
l_int|8
suffix:semicolon
DECL|member|fn
r_int
r_int
id|fn
suffix:colon
l_int|2
suffix:semicolon
DECL|member|qpc
r_int
r_int
id|qpc
suffix:colon
l_int|3
suffix:semicolon
DECL|member|sph
r_int
r_int
id|sph
suffix:colon
l_int|1
suffix:semicolon
DECL|member|reserved
r_int
r_int
id|reserved
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* Second quadlet */
DECL|member|fdf
r_int
r_int
id|fdf
suffix:colon
l_int|8
suffix:semicolon
DECL|member|eoh1
r_int
r_int
id|eoh1
suffix:colon
l_int|2
suffix:semicolon
DECL|member|fmt
r_int
r_int
id|fmt
suffix:colon
l_int|6
suffix:semicolon
DECL|member|syt
r_int
r_int
id|syt
suffix:colon
l_int|16
suffix:semicolon
DECL|member|data
id|quadlet_t
id|data
(braket
l_int|0
)braket
suffix:semicolon
)brace
suffix:semicolon
macro_line|#elif defined __LITTLE_ENDIAN_BITFIELD
DECL|struct|iso_packet
r_struct
id|iso_packet
(brace
multiline_comment|/* First quadlet */
DECL|member|sid
r_int
r_int
id|sid
suffix:colon
l_int|6
suffix:semicolon
DECL|member|eoh0
r_int
r_int
id|eoh0
suffix:colon
l_int|2
suffix:semicolon
DECL|member|dbs
r_int
r_int
id|dbs
suffix:colon
l_int|8
suffix:semicolon
DECL|member|reserved
r_int
r_int
id|reserved
suffix:colon
l_int|2
suffix:semicolon
DECL|member|sph
r_int
r_int
id|sph
suffix:colon
l_int|1
suffix:semicolon
DECL|member|qpc
r_int
r_int
id|qpc
suffix:colon
l_int|3
suffix:semicolon
DECL|member|fn
r_int
r_int
id|fn
suffix:colon
l_int|2
suffix:semicolon
DECL|member|dbc
r_int
r_int
id|dbc
suffix:colon
l_int|8
suffix:semicolon
multiline_comment|/* Second quadlet */
DECL|member|fmt
r_int
r_int
id|fmt
suffix:colon
l_int|6
suffix:semicolon
DECL|member|eoh1
r_int
r_int
id|eoh1
suffix:colon
l_int|2
suffix:semicolon
DECL|member|fdf
r_int
r_int
id|fdf
suffix:colon
l_int|8
suffix:semicolon
DECL|member|syt
r_int
r_int
id|syt
suffix:colon
l_int|16
suffix:semicolon
DECL|member|data
id|quadlet_t
id|data
(braket
l_int|0
)braket
suffix:semicolon
)brace
suffix:semicolon
macro_line|#else
macro_line|#error Unknown bitfield type
macro_line|#endif
DECL|struct|fraction
r_struct
id|fraction
(brace
DECL|member|integer
r_int
id|integer
suffix:semicolon
DECL|member|numerator
r_int
id|numerator
suffix:semicolon
DECL|member|denominator
r_int
id|denominator
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|PACKET_LIST_SIZE
mdefine_line|#define PACKET_LIST_SIZE 256
DECL|macro|MAX_PACKET_LISTS
mdefine_line|#define MAX_PACKET_LISTS 4
DECL|struct|packet_list
r_struct
id|packet_list
(brace
DECL|member|link
r_struct
id|list_head
id|link
suffix:semicolon
DECL|member|last_cycle_count
r_int
id|last_cycle_count
suffix:semicolon
DECL|member|packets
r_struct
id|packet
id|packets
(braket
id|PACKET_LIST_SIZE
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|BUFFER_SIZE
mdefine_line|#define BUFFER_SIZE 128
multiline_comment|/* This implements a circular buffer for incoming samples. */
DECL|struct|buffer
r_struct
id|buffer
(brace
DECL|member|head
DECL|member|tail
DECL|member|length
DECL|member|size
r_int
id|head
comma
id|tail
comma
id|length
comma
id|size
suffix:semicolon
DECL|member|data
r_int
r_char
id|data
(braket
l_int|0
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|stream
r_struct
id|stream
(brace
DECL|member|iso_channel
r_int
id|iso_channel
suffix:semicolon
DECL|member|format
r_int
id|format
suffix:semicolon
DECL|member|rate
r_int
id|rate
suffix:semicolon
DECL|member|dimension
r_int
id|dimension
suffix:semicolon
DECL|member|fdf
r_int
id|fdf
suffix:semicolon
DECL|member|mode
r_int
id|mode
suffix:semicolon
DECL|member|sample_format
r_int
id|sample_format
suffix:semicolon
DECL|member|opcr
r_struct
id|cmp_pcr
op_star
id|opcr
suffix:semicolon
multiline_comment|/* Input samples are copied here. */
DECL|member|input
r_struct
id|buffer
op_star
id|input
suffix:semicolon
multiline_comment|/* ISO Packer state */
DECL|member|dbc
r_int
r_char
id|dbc
suffix:semicolon
DECL|member|current_packet_list
r_struct
id|packet_list
op_star
id|current_packet_list
suffix:semicolon
DECL|member|current_packet
r_int
id|current_packet
suffix:semicolon
DECL|member|ready_samples
DECL|member|samples_per_cycle
r_struct
id|fraction
id|ready_samples
comma
id|samples_per_cycle
suffix:semicolon
multiline_comment|/* We use these to generate control bits when we are packing&n;&t; * iec958 data.&n;&t; */
DECL|member|iec958_frame_count
r_int
id|iec958_frame_count
suffix:semicolon
DECL|member|iec958_rate_code
r_int
id|iec958_rate_code
suffix:semicolon
multiline_comment|/* The cycle_count and cycle_offset fields are used for the&n;&t; * synchronization timestamps (syt) in the cip header.  They&n;&t; * are incremented by at least a cycle every time we put a&n;&t; * time stamp in a packet.  As we don&squot;t time stamp all&n;&t; * packages, cycle_count isn&squot;t updated in every cycle, and&n;&t; * sometimes it&squot;s incremented by 2.  Thus, we have&n;&t; * cycle_count2, which is simply incremented by one with each&n;&t; * packet, so we can compare it to the transmission time&n;&t; * written back in the dma programs.&n;&t; */
DECL|member|cycle_count
DECL|member|cycle_count2
id|atomic_t
id|cycle_count
comma
id|cycle_count2
suffix:semicolon
DECL|member|cycle_offset
DECL|member|ticks_per_syt_offset
r_struct
id|fraction
id|cycle_offset
comma
id|ticks_per_syt_offset
suffix:semicolon
DECL|member|syt_interval
r_int
id|syt_interval
suffix:semicolon
DECL|member|stale_count
r_int
id|stale_count
suffix:semicolon
multiline_comment|/* Theses fields control the sample output to the DMA engine.&n;&t; * The dma_packet_lists list holds packet lists currently&n;&t; * queued for dma; the head of the list is currently being&n;&t; * processed.  The last program in a packet list generates an&n;&t; * interrupt, which removes the head from dma_packet_lists and&n;&t; * puts it back on the free list.&n;&t; */
DECL|member|dma_packet_lists
r_struct
id|list_head
id|dma_packet_lists
suffix:semicolon
DECL|member|free_packet_lists
r_struct
id|list_head
id|free_packet_lists
suffix:semicolon
DECL|member|packet_list_wait
id|wait_queue_head_t
id|packet_list_wait
suffix:semicolon
DECL|member|packet_list_lock
id|spinlock_t
id|packet_list_lock
suffix:semicolon
DECL|member|iso_tasklet
r_struct
id|ohci1394_iso_tasklet
id|iso_tasklet
suffix:semicolon
DECL|member|descriptor_pool
DECL|member|packet_pool
r_struct
id|pci_pool
op_star
id|descriptor_pool
comma
op_star
id|packet_pool
suffix:semicolon
multiline_comment|/* Streams at a host controller are chained through this field. */
DECL|member|link
r_struct
id|list_head
id|link
suffix:semicolon
DECL|member|host
r_struct
id|amdtp_host
op_star
id|host
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|amdtp_host
r_struct
id|amdtp_host
(brace
DECL|member|host
r_struct
id|hpsb_host
op_star
id|host
suffix:semicolon
DECL|member|ohci
r_struct
id|ti_ohci
op_star
id|ohci
suffix:semicolon
DECL|member|stream_list
r_struct
id|list_head
id|stream_list
suffix:semicolon
DECL|member|stream_list_lock
id|spinlock_t
id|stream_list_lock
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|amdtp_highlevel
r_static
r_struct
id|hpsb_highlevel
id|amdtp_highlevel
suffix:semicolon
multiline_comment|/* FIXME: This doesn&squot;t belong here... */
DECL|macro|OHCI1394_CONTEXT_CYCLE_MATCH
mdefine_line|#define OHCI1394_CONTEXT_CYCLE_MATCH 0x80000000
DECL|macro|OHCI1394_CONTEXT_RUN
mdefine_line|#define OHCI1394_CONTEXT_RUN         0x00008000
DECL|macro|OHCI1394_CONTEXT_WAKE
mdefine_line|#define OHCI1394_CONTEXT_WAKE        0x00001000
DECL|macro|OHCI1394_CONTEXT_DEAD
mdefine_line|#define OHCI1394_CONTEXT_DEAD        0x00000800
DECL|macro|OHCI1394_CONTEXT_ACTIVE
mdefine_line|#define OHCI1394_CONTEXT_ACTIVE      0x00000400
DECL|function|ohci1394_start_it_ctx
r_void
id|ohci1394_start_it_ctx
c_func
(paren
r_struct
id|ti_ohci
op_star
id|ohci
comma
r_int
id|ctx
comma
id|dma_addr_t
id|first_cmd
comma
r_int
id|z
comma
r_int
id|cycle_match
)paren
(brace
id|reg_write
c_func
(paren
id|ohci
comma
id|OHCI1394_IsoXmitIntMaskSet
comma
l_int|1
op_lshift
id|ctx
)paren
suffix:semicolon
id|reg_write
c_func
(paren
id|ohci
comma
id|OHCI1394_IsoXmitCommandPtr
op_plus
id|ctx
op_star
l_int|16
comma
id|first_cmd
op_or
id|z
)paren
suffix:semicolon
id|reg_write
c_func
(paren
id|ohci
comma
id|OHCI1394_IsoXmitContextControlClear
op_plus
id|ctx
op_star
l_int|16
comma
op_complement
l_int|0
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|reg_write
c_func
(paren
id|ohci
comma
id|OHCI1394_IsoXmitContextControlSet
op_plus
id|ctx
op_star
l_int|16
comma
id|OHCI1394_CONTEXT_CYCLE_MATCH
op_or
(paren
id|cycle_match
op_lshift
l_int|16
)paren
op_or
id|OHCI1394_CONTEXT_RUN
)paren
suffix:semicolon
)brace
DECL|function|ohci1394_wake_it_ctx
r_void
id|ohci1394_wake_it_ctx
c_func
(paren
r_struct
id|ti_ohci
op_star
id|ohci
comma
r_int
id|ctx
)paren
(brace
id|reg_write
c_func
(paren
id|ohci
comma
id|OHCI1394_IsoXmitContextControlSet
op_plus
id|ctx
op_star
l_int|16
comma
id|OHCI1394_CONTEXT_WAKE
)paren
suffix:semicolon
)brace
DECL|function|ohci1394_stop_it_ctx
r_void
id|ohci1394_stop_it_ctx
c_func
(paren
r_struct
id|ti_ohci
op_star
id|ohci
comma
r_int
id|ctx
comma
r_int
id|synchronous
)paren
(brace
id|u32
id|control
suffix:semicolon
r_int
id|wait
suffix:semicolon
id|reg_write
c_func
(paren
id|ohci
comma
id|OHCI1394_IsoXmitIntMaskClear
comma
l_int|1
op_lshift
id|ctx
)paren
suffix:semicolon
id|reg_write
c_func
(paren
id|ohci
comma
id|OHCI1394_IsoXmitContextControlClear
op_plus
id|ctx
op_star
l_int|16
comma
id|OHCI1394_CONTEXT_RUN
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|synchronous
)paren
(brace
r_for
c_loop
(paren
id|wait
op_assign
l_int|0
suffix:semicolon
id|wait
OL
l_int|5
suffix:semicolon
id|wait
op_increment
)paren
(brace
id|control
op_assign
id|reg_read
c_func
(paren
id|ohci
comma
id|OHCI1394_IsoXmitContextControlSet
op_plus
id|ctx
op_star
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|control
op_amp
id|OHCI1394_CONTEXT_ACTIVE
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Note: we can test if free_packet_lists is empty without aquiring&n; * the packet_list_lock.  The interrupt handler only adds to the free&n; * list, there is no race condition between testing the list non-empty&n; * and acquiring the lock.&n; */
DECL|function|stream_get_free_packet_list
r_static
r_struct
id|packet_list
op_star
id|stream_get_free_packet_list
c_func
(paren
r_struct
id|stream
op_star
id|s
)paren
(brace
r_struct
id|packet_list
op_star
id|pl
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|s-&gt;free_packet_lists
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;packet_list_lock
comma
id|flags
)paren
suffix:semicolon
id|pl
op_assign
id|list_entry
c_func
(paren
id|s-&gt;free_packet_lists.next
comma
r_struct
id|packet_list
comma
id|link
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|pl-&gt;link
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;packet_list_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|pl
suffix:semicolon
)brace
DECL|function|stream_start_dma
r_static
r_void
id|stream_start_dma
c_func
(paren
r_struct
id|stream
op_star
id|s
comma
r_struct
id|packet_list
op_star
id|pl
)paren
(brace
id|u32
id|syt_cycle
comma
id|cycle_count
comma
id|start_cycle
suffix:semicolon
id|cycle_count
op_assign
id|reg_read
c_func
(paren
id|s-&gt;host-&gt;ohci
comma
id|OHCI1394_IsochronousCycleTimer
)paren
op_rshift
l_int|12
suffix:semicolon
id|syt_cycle
op_assign
(paren
id|pl-&gt;last_cycle_count
op_minus
id|PACKET_LIST_SIZE
op_plus
l_int|1
)paren
op_amp
l_int|0x0f
suffix:semicolon
multiline_comment|/* We program the DMA controller to start transmission at&n;&t; * least 17 cycles from now - this happens when the lower four&n;&t; * bits of cycle_count is 0x0f and syt_cycle is 0, in this&n;&t; * case the start cycle is cycle_count - 15 + 32. */
id|start_cycle
op_assign
(paren
id|cycle_count
op_amp
op_complement
l_int|0x0f
)paren
op_plus
l_int|32
op_plus
id|syt_cycle
suffix:semicolon
r_if
c_cond
(paren
(paren
id|start_cycle
op_amp
l_int|0x1fff
)paren
op_ge
l_int|8000
)paren
id|start_cycle
op_assign
id|start_cycle
op_minus
l_int|8000
op_plus
l_int|0x2000
suffix:semicolon
id|ohci1394_start_it_ctx
c_func
(paren
id|s-&gt;host-&gt;ohci
comma
id|s-&gt;iso_tasklet.context
comma
id|pl-&gt;packets
(braket
l_int|0
)braket
dot
id|db_bus
comma
l_int|3
comma
id|start_cycle
op_amp
l_int|0x7fff
)paren
suffix:semicolon
)brace
DECL|function|stream_put_dma_packet_list
r_static
r_void
id|stream_put_dma_packet_list
c_func
(paren
r_struct
id|stream
op_star
id|s
comma
r_struct
id|packet_list
op_star
id|pl
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|packet_list
op_star
id|prev
suffix:semicolon
multiline_comment|/* Remember the cycle_count used for timestamping the last packet. */
id|pl-&gt;last_cycle_count
op_assign
id|atomic_read
c_func
(paren
op_amp
id|s-&gt;cycle_count2
)paren
op_minus
l_int|1
suffix:semicolon
id|pl-&gt;packets
(braket
id|PACKET_LIST_SIZE
op_minus
l_int|1
)braket
dot
id|db-&gt;payload_desc.branch
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;packet_list_lock
comma
id|flags
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|pl-&gt;link
comma
op_amp
id|s-&gt;dma_packet_lists
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;packet_list_lock
comma
id|flags
)paren
suffix:semicolon
id|prev
op_assign
id|list_entry
c_func
(paren
id|pl-&gt;link.prev
comma
r_struct
id|packet_list
comma
id|link
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pl-&gt;link.prev
op_ne
op_amp
id|s-&gt;dma_packet_lists
)paren
(brace
r_struct
id|packet
op_star
id|last
op_assign
op_amp
id|prev-&gt;packets
(braket
id|PACKET_LIST_SIZE
op_minus
l_int|1
)braket
suffix:semicolon
id|last-&gt;db-&gt;payload_desc.branch
op_assign
id|pl-&gt;packets
(braket
l_int|0
)braket
dot
id|db_bus
op_or
l_int|3
suffix:semicolon
id|last-&gt;db-&gt;header_desc.skip
op_assign
id|pl-&gt;packets
(braket
l_int|0
)braket
dot
id|db_bus
op_or
l_int|3
suffix:semicolon
id|ohci1394_wake_it_ctx
c_func
(paren
id|s-&gt;host-&gt;ohci
comma
id|s-&gt;iso_tasklet.context
)paren
suffix:semicolon
)brace
r_else
id|stream_start_dma
c_func
(paren
id|s
comma
id|pl
)paren
suffix:semicolon
)brace
DECL|function|stream_shift_packet_lists
r_static
r_void
id|stream_shift_packet_lists
c_func
(paren
r_int
r_int
id|l
)paren
(brace
r_struct
id|stream
op_star
id|s
op_assign
(paren
r_struct
id|stream
op_star
)paren
id|l
suffix:semicolon
r_struct
id|packet_list
op_star
id|pl
suffix:semicolon
r_struct
id|packet
op_star
id|last
suffix:semicolon
r_int
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|s-&gt;dma_packet_lists
)paren
)paren
(brace
id|HPSB_ERR
c_func
(paren
l_string|&quot;empty dma_packet_lists in %s&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Now that we know the list is non-empty, we can get the head&n;&t; * of the list without locking, because the process context&n;&t; * only adds to the tail.  &n;&t; */
id|pl
op_assign
id|list_entry
c_func
(paren
id|s-&gt;dma_packet_lists.next
comma
r_struct
id|packet_list
comma
id|link
)paren
suffix:semicolon
id|last
op_assign
op_amp
id|pl-&gt;packets
(braket
id|PACKET_LIST_SIZE
op_minus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* This is weird... if we stop dma processing in the middle of&n;&t; * a packet list, the dma context immediately generates an&n;&t; * interrupt if we enable it again later.  This only happens&n;&t; * when amdtp_release is interrupted while waiting for dma to&n;&t; * complete, though.  Anyway, we detect this by seeing that&n;&t; * the status of the dma descriptor that we expected an&n;&t; * interrupt from is still 0.&n;&t; */
r_if
c_cond
(paren
id|last-&gt;db-&gt;payload_desc.status
op_eq
l_int|0
)paren
(brace
id|HPSB_INFO
c_func
(paren
l_string|&quot;weird interrupt...&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* If the last descriptor block does not specify a branch&n;&t; * address, we have a sample underflow.&n;&t; */
r_if
c_cond
(paren
id|last-&gt;db-&gt;payload_desc.branch
op_eq
l_int|0
)paren
id|HPSB_INFO
c_func
(paren
l_string|&quot;FIXME: sample underflow...&quot;
)paren
suffix:semicolon
multiline_comment|/* Here we check when (which cycle) the last packet was sent&n;&t; * and compare it to what the iso packer was using at the&n;&t; * time.  If there is a mismatch, we adjust the cycle count in&n;&t; * the iso packer.  However, there are still up to&n;&t; * MAX_PACKET_LISTS packet lists queued with bad time stamps,&n;&t; * so we disable time stamp monitoring for the next&n;&t; * MAX_PACKET_LISTS packet lists.&n;&t; */
id|diff
op_assign
(paren
id|last-&gt;db-&gt;payload_desc.status
op_minus
id|pl-&gt;last_cycle_count
)paren
op_amp
l_int|0xf
suffix:semicolon
r_if
c_cond
(paren
id|diff
OG
l_int|0
op_logical_and
id|s-&gt;stale_count
op_eq
l_int|0
)paren
(brace
id|atomic_add
c_func
(paren
id|diff
comma
op_amp
id|s-&gt;cycle_count
)paren
suffix:semicolon
id|atomic_add
c_func
(paren
id|diff
comma
op_amp
id|s-&gt;cycle_count2
)paren
suffix:semicolon
id|s-&gt;stale_count
op_assign
id|MAX_PACKET_LISTS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;stale_count
OG
l_int|0
)paren
id|s-&gt;stale_count
op_decrement
suffix:semicolon
multiline_comment|/* Finally, we move the packet list that was just processed&n;&t; * back to the free list, and notify any waiters.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|s-&gt;packet_list_lock
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|pl-&gt;link
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|pl-&gt;link
comma
op_amp
id|s-&gt;free_packet_lists
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|s-&gt;packet_list_lock
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|s-&gt;packet_list_wait
)paren
suffix:semicolon
)brace
DECL|function|stream_current_packet
r_static
r_struct
id|packet
op_star
id|stream_current_packet
c_func
(paren
r_struct
id|stream
op_star
id|s
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;current_packet_list
op_eq
l_int|NULL
op_logical_and
(paren
id|s-&gt;current_packet_list
op_assign
id|stream_get_free_packet_list
c_func
(paren
id|s
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
op_amp
id|s-&gt;current_packet_list-&gt;packets
(braket
id|s-&gt;current_packet
)braket
suffix:semicolon
)brace
DECL|function|stream_queue_packet
r_static
r_void
id|stream_queue_packet
c_func
(paren
r_struct
id|stream
op_star
id|s
)paren
(brace
id|s-&gt;current_packet
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;current_packet
op_eq
id|PACKET_LIST_SIZE
)paren
(brace
id|stream_put_dma_packet_list
c_func
(paren
id|s
comma
id|s-&gt;current_packet_list
)paren
suffix:semicolon
id|s-&gt;current_packet_list
op_assign
l_int|NULL
suffix:semicolon
id|s-&gt;current_packet
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Integer fractional math.  When we transmit a 44k1Hz signal we must&n; * send 5 41/80 samples per isochronous cycle, as these occur 8000&n; * times a second.  Of course, we must send an integral number of&n; * samples in a packet, so we use the integer math to alternate&n; * between sending 5 and 6 samples per packet.&n; */
DECL|function|fraction_init
r_static
r_void
id|fraction_init
c_func
(paren
r_struct
id|fraction
op_star
id|f
comma
r_int
id|numerator
comma
r_int
id|denominator
)paren
(brace
id|f-&gt;integer
op_assign
id|numerator
op_div
id|denominator
suffix:semicolon
id|f-&gt;numerator
op_assign
id|numerator
op_mod
id|denominator
suffix:semicolon
id|f-&gt;denominator
op_assign
id|denominator
suffix:semicolon
)brace
DECL|function|fraction_add
r_static
id|__inline__
r_void
id|fraction_add
c_func
(paren
r_struct
id|fraction
op_star
id|dst
comma
r_struct
id|fraction
op_star
id|src1
comma
r_struct
id|fraction
op_star
id|src2
)paren
(brace
multiline_comment|/* assert: src1-&gt;denominator == src2-&gt;denominator */
r_int
id|sum
comma
id|denom
suffix:semicolon
multiline_comment|/* We use these two local variables to allow gcc to optimize&n;&t; * the division and the modulo into only one division. */
id|sum
op_assign
id|src1-&gt;numerator
op_plus
id|src2-&gt;numerator
suffix:semicolon
id|denom
op_assign
id|src1-&gt;denominator
suffix:semicolon
id|dst-&gt;integer
op_assign
id|src1-&gt;integer
op_plus
id|src2-&gt;integer
op_plus
id|sum
op_div
id|denom
suffix:semicolon
id|dst-&gt;numerator
op_assign
id|sum
op_mod
id|denom
suffix:semicolon
id|dst-&gt;denominator
op_assign
id|denom
suffix:semicolon
)brace
DECL|function|fraction_sub_int
r_static
id|__inline__
r_void
id|fraction_sub_int
c_func
(paren
r_struct
id|fraction
op_star
id|dst
comma
r_struct
id|fraction
op_star
id|src
comma
r_int
id|integer
)paren
(brace
id|dst-&gt;integer
op_assign
id|src-&gt;integer
op_minus
id|integer
suffix:semicolon
id|dst-&gt;numerator
op_assign
id|src-&gt;numerator
suffix:semicolon
id|dst-&gt;denominator
op_assign
id|src-&gt;denominator
suffix:semicolon
)brace
DECL|function|fraction_floor
r_static
id|__inline__
r_int
id|fraction_floor
c_func
(paren
r_struct
id|fraction
op_star
id|frac
)paren
(brace
r_return
id|frac-&gt;integer
suffix:semicolon
)brace
DECL|function|fraction_ceil
r_static
id|__inline__
r_int
id|fraction_ceil
c_func
(paren
r_struct
id|fraction
op_star
id|frac
)paren
(brace
r_return
id|frac-&gt;integer
op_plus
(paren
id|frac-&gt;numerator
OG
l_int|0
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|packet_initialize
r_void
id|packet_initialize
c_func
(paren
r_struct
id|packet
op_star
id|p
comma
r_struct
id|packet
op_star
id|next
)paren
(brace
multiline_comment|/* Here we initialize the dma descriptor block for&n;&t; * transferring one iso packet.  We use two descriptors per&n;&t; * packet: an OUTPUT_MORE_IMMMEDIATE descriptor for the&n;&t; * IEEE1394 iso packet header and an OUTPUT_LAST descriptor&n;&t; * for the payload.&n;&t; */
id|p-&gt;db-&gt;header_desc.control
op_assign
id|DMA_CTL_OUTPUT_MORE
op_or
id|DMA_CTL_IMMEDIATE
op_or
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|next
)paren
(brace
id|p-&gt;db-&gt;payload_desc.control
op_assign
id|DMA_CTL_OUTPUT_LAST
op_or
id|DMA_CTL_BRANCH
suffix:semicolon
id|p-&gt;db-&gt;payload_desc.branch
op_assign
id|next-&gt;db_bus
op_or
l_int|3
suffix:semicolon
id|p-&gt;db-&gt;header_desc.skip
op_assign
id|next-&gt;db_bus
op_or
l_int|3
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;db-&gt;payload_desc.control
op_assign
id|DMA_CTL_OUTPUT_LAST
op_or
id|DMA_CTL_BRANCH
op_or
id|DMA_CTL_UPDATE
op_or
id|DMA_CTL_IRQ
suffix:semicolon
id|p-&gt;db-&gt;payload_desc.branch
op_assign
l_int|0
suffix:semicolon
id|p-&gt;db-&gt;header_desc.skip
op_assign
l_int|0
suffix:semicolon
)brace
id|p-&gt;db-&gt;payload_desc.data_address
op_assign
id|p-&gt;payload_bus
suffix:semicolon
id|p-&gt;db-&gt;payload_desc.status
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|packet_list_alloc
r_struct
id|packet_list
op_star
id|packet_list_alloc
c_func
(paren
r_struct
id|stream
op_star
id|s
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|packet_list
op_star
id|pl
suffix:semicolon
r_struct
id|packet
op_star
id|next
suffix:semicolon
id|pl
op_assign
id|kmalloc
c_func
(paren
r_sizeof
op_star
id|pl
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pl
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PACKET_LIST_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|packet
op_star
id|p
op_assign
op_amp
id|pl-&gt;packets
(braket
id|i
)braket
suffix:semicolon
id|p-&gt;db
op_assign
id|pci_pool_alloc
c_func
(paren
id|s-&gt;descriptor_pool
comma
id|SLAB_KERNEL
comma
op_amp
id|p-&gt;db_bus
)paren
suffix:semicolon
id|p-&gt;payload
op_assign
id|pci_pool_alloc
c_func
(paren
id|s-&gt;packet_pool
comma
id|SLAB_KERNEL
comma
op_amp
id|p-&gt;payload_bus
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PACKET_LIST_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
id|PACKET_LIST_SIZE
op_minus
l_int|1
)paren
id|next
op_assign
op_amp
id|pl-&gt;packets
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
r_else
id|next
op_assign
l_int|NULL
suffix:semicolon
id|packet_initialize
c_func
(paren
op_amp
id|pl-&gt;packets
(braket
id|i
)braket
comma
id|next
)paren
suffix:semicolon
)brace
r_return
id|pl
suffix:semicolon
)brace
DECL|function|packet_list_free
r_void
id|packet_list_free
c_func
(paren
r_struct
id|packet_list
op_star
id|pl
comma
r_struct
id|stream
op_star
id|s
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PACKET_LIST_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|packet
op_star
id|p
op_assign
op_amp
id|pl-&gt;packets
(braket
id|i
)braket
suffix:semicolon
id|pci_pool_free
c_func
(paren
id|s-&gt;descriptor_pool
comma
id|p-&gt;db
comma
id|p-&gt;db_bus
)paren
suffix:semicolon
id|pci_pool_free
c_func
(paren
id|s-&gt;packet_pool
comma
id|p-&gt;payload
comma
id|p-&gt;payload_bus
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|pl
)paren
suffix:semicolon
)brace
DECL|function|buffer_alloc
r_static
r_struct
id|buffer
op_star
id|buffer_alloc
c_func
(paren
r_int
id|size
)paren
(brace
r_struct
id|buffer
op_star
id|b
suffix:semicolon
id|b
op_assign
id|kmalloc
c_func
(paren
r_sizeof
op_star
id|b
op_plus
id|size
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|b
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|b-&gt;head
op_assign
l_int|0
suffix:semicolon
id|b-&gt;tail
op_assign
l_int|0
suffix:semicolon
id|b-&gt;length
op_assign
l_int|0
suffix:semicolon
id|b-&gt;size
op_assign
id|size
suffix:semicolon
r_return
id|b
suffix:semicolon
)brace
DECL|function|buffer_get_bytes
r_static
r_int
r_char
op_star
id|buffer_get_bytes
c_func
(paren
r_struct
id|buffer
op_star
id|buffer
comma
r_int
id|size
)paren
(brace
r_int
r_char
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|buffer-&gt;head
op_plus
id|size
OG
id|buffer-&gt;size
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|p
op_assign
op_amp
id|buffer-&gt;data
(braket
id|buffer-&gt;head
)braket
suffix:semicolon
id|buffer-&gt;head
op_add_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|buffer-&gt;head
op_eq
id|buffer-&gt;size
)paren
id|buffer-&gt;head
op_assign
l_int|0
suffix:semicolon
id|buffer-&gt;length
op_sub_assign
id|size
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|function|buffer_put_bytes
r_static
r_int
r_char
op_star
id|buffer_put_bytes
c_func
(paren
r_struct
id|buffer
op_star
id|buffer
comma
r_int
id|max
comma
r_int
op_star
id|actual
)paren
(brace
r_int
id|length
suffix:semicolon
r_int
r_char
op_star
id|p
suffix:semicolon
id|p
op_assign
op_amp
id|buffer-&gt;data
(braket
id|buffer-&gt;tail
)braket
suffix:semicolon
id|length
op_assign
id|min
c_func
(paren
id|buffer-&gt;size
op_minus
id|buffer-&gt;length
comma
id|max
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer-&gt;tail
op_plus
id|length
OL
id|buffer-&gt;size
)paren
(brace
op_star
id|actual
op_assign
id|length
suffix:semicolon
id|buffer-&gt;tail
op_add_assign
id|length
suffix:semicolon
)brace
r_else
(brace
op_star
id|actual
op_assign
id|buffer-&gt;size
op_minus
id|buffer-&gt;tail
suffix:semicolon
id|buffer-&gt;tail
op_assign
l_int|0
suffix:semicolon
)brace
id|buffer-&gt;length
op_add_assign
op_star
id|actual
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|function|get_iec958_header_bits
r_static
id|u32
id|get_iec958_header_bits
c_func
(paren
r_struct
id|stream
op_star
id|s
comma
r_int
id|sub_frame
comma
id|u32
id|sample
)paren
(brace
r_int
id|csi
comma
id|parity
comma
id|shift
suffix:semicolon
r_int
id|block_start
suffix:semicolon
id|u32
id|bits
suffix:semicolon
r_switch
c_cond
(paren
id|s-&gt;iec958_frame_count
)paren
(brace
r_case
l_int|1
suffix:colon
id|csi
op_assign
id|s-&gt;format
op_eq
id|AMDTP_FORMAT_IEC958_AC3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_case
l_int|9
suffix:colon
id|csi
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|24
dot
dot
dot
l_int|27
suffix:colon
id|csi
op_assign
(paren
id|s-&gt;iec958_rate_code
op_rshift
(paren
l_int|27
op_minus
id|s-&gt;iec958_frame_count
)paren
)paren
op_amp
l_int|0x01
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|csi
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|block_start
op_assign
(paren
id|s-&gt;iec958_frame_count
op_eq
l_int|0
op_logical_and
id|sub_frame
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* The parity bit is the xor of the sample bits and the&n;&t; * channel status info bit. */
r_for
c_loop
(paren
id|shift
op_assign
l_int|16
comma
id|parity
op_assign
id|sample
op_xor
id|csi
suffix:semicolon
id|shift
OG
l_int|0
suffix:semicolon
id|shift
op_rshift_assign
l_int|1
)paren
id|parity
op_xor_assign
(paren
id|parity
op_rshift
id|shift
)paren
suffix:semicolon
id|bits
op_assign
(paren
id|block_start
op_lshift
l_int|5
)paren
op_or
multiline_comment|/* Block start bit */
(paren
(paren
id|sub_frame
op_eq
l_int|0
)paren
op_lshift
l_int|4
)paren
op_or
multiline_comment|/* Subframe bit */
(paren
(paren
id|parity
op_amp
l_int|1
)paren
op_lshift
l_int|3
)paren
op_or
multiline_comment|/* Parity bit */
(paren
id|csi
op_lshift
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Channel status info bit */
r_return
id|bits
suffix:semicolon
)brace
DECL|function|get_header_bits
r_static
id|u32
id|get_header_bits
c_func
(paren
r_struct
id|stream
op_star
id|s
comma
r_int
id|sub_frame
comma
id|u32
id|sample
)paren
(brace
r_switch
c_cond
(paren
id|s-&gt;format
)paren
(brace
r_case
id|AMDTP_FORMAT_IEC958_PCM
suffix:colon
r_case
id|AMDTP_FORMAT_IEC958_AC3
suffix:colon
r_return
id|get_iec958_header_bits
c_func
(paren
id|s
comma
id|sub_frame
comma
id|sample
)paren
suffix:semicolon
r_case
id|AMDTP_FORMAT_RAW
suffix:colon
r_return
l_int|0x40
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|fill_payload_le16
r_static
r_void
id|fill_payload_le16
c_func
(paren
r_struct
id|stream
op_star
id|s
comma
id|quadlet_t
op_star
id|data
comma
r_int
id|nevents
)paren
(brace
id|quadlet_t
op_star
id|event
comma
id|sample
comma
id|bits
suffix:semicolon
r_int
r_char
op_star
id|p
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|event
op_assign
id|data
suffix:semicolon
id|i
OL
id|nevents
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|s-&gt;dimension
suffix:semicolon
id|j
op_increment
)paren
(brace
id|p
op_assign
id|buffer_get_bytes
c_func
(paren
id|s-&gt;input
comma
l_int|2
)paren
suffix:semicolon
id|sample
op_assign
(paren
id|p
(braket
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|p
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
id|bits
op_assign
id|get_header_bits
c_func
(paren
id|s
comma
id|j
comma
id|sample
)paren
suffix:semicolon
id|event
(braket
id|j
)braket
op_assign
id|cpu_to_be32
c_func
(paren
(paren
id|bits
op_lshift
l_int|24
)paren
op_or
id|sample
)paren
suffix:semicolon
)brace
id|event
op_add_assign
id|s-&gt;dimension
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|s-&gt;iec958_frame_count
op_eq
l_int|192
)paren
id|s-&gt;iec958_frame_count
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|fill_packet
r_static
r_void
id|fill_packet
c_func
(paren
r_struct
id|stream
op_star
id|s
comma
r_struct
id|packet
op_star
id|packet
comma
r_int
id|nevents
)paren
(brace
r_int
id|syt_index
comma
id|syt
comma
id|size
suffix:semicolon
id|u32
id|control
suffix:semicolon
id|size
op_assign
(paren
id|nevents
op_star
id|s-&gt;dimension
op_plus
l_int|2
)paren
op_star
r_sizeof
(paren
id|quadlet_t
)paren
suffix:semicolon
multiline_comment|/* Update DMA descriptors */
id|packet-&gt;db-&gt;payload_desc.status
op_assign
l_int|0
suffix:semicolon
id|control
op_assign
id|packet-&gt;db-&gt;payload_desc.control
op_amp
l_int|0xffff0000
suffix:semicolon
id|packet-&gt;db-&gt;payload_desc.control
op_assign
id|control
op_or
id|size
suffix:semicolon
multiline_comment|/* Fill IEEE1394 headers */
id|packet-&gt;db-&gt;header_desc.header
(braket
l_int|0
)braket
op_assign
(paren
id|IEEE1394_SPEED_100
op_lshift
l_int|16
)paren
op_or
(paren
l_int|0x01
op_lshift
l_int|14
)paren
op_or
(paren
id|s-&gt;iso_channel
op_lshift
l_int|8
)paren
op_or
(paren
id|TCODE_ISO_DATA
op_lshift
l_int|4
)paren
suffix:semicolon
id|packet-&gt;db-&gt;header_desc.header
(braket
l_int|1
)braket
op_assign
id|size
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* Calculate synchronization timestamp (syt). First we&n;&t; * determine syt_index, that is, the index in the packet of&n;&t; * the sample for which the timestamp is valid. */
id|syt_index
op_assign
(paren
id|s-&gt;syt_interval
op_minus
id|s-&gt;dbc
)paren
op_amp
(paren
id|s-&gt;syt_interval
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|syt_index
OL
id|nevents
)paren
(brace
id|syt
op_assign
(paren
(paren
id|atomic_read
c_func
(paren
op_amp
id|s-&gt;cycle_count
)paren
op_lshift
l_int|12
)paren
op_or
id|s-&gt;cycle_offset.integer
)paren
op_amp
l_int|0xffff
suffix:semicolon
id|fraction_add
c_func
(paren
op_amp
id|s-&gt;cycle_offset
comma
op_amp
id|s-&gt;cycle_offset
comma
op_amp
id|s-&gt;ticks_per_syt_offset
)paren
suffix:semicolon
multiline_comment|/* This next addition should be modulo 8000 (0x1f40),&n;&t;&t; * but we only use the lower 4 bits of cycle_count, so&n;&t;&t; * we don&squot;t need the modulo. */
id|atomic_add
c_func
(paren
id|s-&gt;cycle_offset.integer
op_div
l_int|3072
comma
op_amp
id|s-&gt;cycle_count
)paren
suffix:semicolon
id|s-&gt;cycle_offset.integer
op_mod_assign
l_int|3072
suffix:semicolon
)brace
r_else
id|syt
op_assign
l_int|0xffff
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|s-&gt;cycle_count2
)paren
suffix:semicolon
multiline_comment|/* Fill cip header */
id|packet-&gt;payload-&gt;eoh0
op_assign
l_int|0
suffix:semicolon
id|packet-&gt;payload-&gt;sid
op_assign
id|s-&gt;host-&gt;host-&gt;node_id
op_amp
l_int|0x3f
suffix:semicolon
id|packet-&gt;payload-&gt;dbs
op_assign
id|s-&gt;dimension
suffix:semicolon
id|packet-&gt;payload-&gt;fn
op_assign
l_int|0
suffix:semicolon
id|packet-&gt;payload-&gt;qpc
op_assign
l_int|0
suffix:semicolon
id|packet-&gt;payload-&gt;sph
op_assign
l_int|0
suffix:semicolon
id|packet-&gt;payload-&gt;reserved
op_assign
l_int|0
suffix:semicolon
id|packet-&gt;payload-&gt;dbc
op_assign
id|s-&gt;dbc
suffix:semicolon
id|packet-&gt;payload-&gt;eoh1
op_assign
l_int|2
suffix:semicolon
id|packet-&gt;payload-&gt;fmt
op_assign
id|FMT_AMDTP
suffix:semicolon
id|packet-&gt;payload-&gt;fdf
op_assign
id|s-&gt;fdf
suffix:semicolon
id|packet-&gt;payload-&gt;syt
op_assign
id|cpu_to_be16
c_func
(paren
id|syt
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|s-&gt;sample_format
)paren
(brace
r_case
id|AMDTP_INPUT_LE16
suffix:colon
id|fill_payload_le16
c_func
(paren
id|s
comma
id|packet-&gt;payload-&gt;data
comma
id|nevents
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|s-&gt;dbc
op_add_assign
id|nevents
suffix:semicolon
)brace
DECL|function|stream_flush
r_static
r_void
id|stream_flush
c_func
(paren
r_struct
id|stream
op_star
id|s
)paren
(brace
r_struct
id|packet
op_star
id|p
suffix:semicolon
r_int
id|nevents
suffix:semicolon
r_struct
id|fraction
id|next
suffix:semicolon
multiline_comment|/* The AMDTP specifies two transmission modes: blocking and&n;&t; * non-blocking.  In blocking mode you always transfer&n;&t; * syt_interval or zero samples, whereas in non-blocking mode&n;&t; * you send as many samples as you have available at transfer&n;&t; * time.&n;&t; *&n;&t; * The fraction samples_per_cycle specifies the number of&n;&t; * samples that become available per cycle.  We add this to&n;&t; * the fraction ready_samples, which specifies the number of&n;&t; * leftover samples from the previous transmission.  The sum,&n;&t; * stored in the fraction next, specifies the number of&n;&t; * samples available for transmission, and from this we&n;&t; * determine the number of samples to actually transmit.&n;&t; */
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|fraction_add
c_func
(paren
op_amp
id|next
comma
op_amp
id|s-&gt;ready_samples
comma
op_amp
id|s-&gt;samples_per_cycle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;mode
op_eq
id|AMDTP_MODE_BLOCKING
)paren
(brace
r_if
c_cond
(paren
id|fraction_floor
c_func
(paren
op_amp
id|next
)paren
op_ge
id|s-&gt;syt_interval
)paren
id|nevents
op_assign
id|s-&gt;syt_interval
suffix:semicolon
r_else
id|nevents
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|nevents
op_assign
id|fraction_floor
c_func
(paren
op_amp
id|next
)paren
suffix:semicolon
id|p
op_assign
id|stream_current_packet
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;input-&gt;length
OL
id|nevents
op_star
id|s-&gt;dimension
op_star
l_int|2
op_logical_or
id|p
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|fill_packet
c_func
(paren
id|s
comma
id|p
comma
id|nevents
)paren
suffix:semicolon
id|stream_queue_packet
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/* Now that we have successfully queued the packet for&n;&t;&t; * transmission, we update the fraction ready_samples. */
id|fraction_sub_int
c_func
(paren
op_amp
id|s-&gt;ready_samples
comma
op_amp
id|next
comma
id|nevents
)paren
suffix:semicolon
)brace
)brace
DECL|function|stream_alloc_packet_lists
r_static
r_int
id|stream_alloc_packet_lists
c_func
(paren
r_struct
id|stream
op_star
id|s
)paren
(brace
r_int
id|max_nevents
comma
id|max_packet_size
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;mode
op_eq
id|AMDTP_MODE_BLOCKING
)paren
id|max_nevents
op_assign
id|s-&gt;syt_interval
suffix:semicolon
r_else
id|max_nevents
op_assign
id|fraction_ceil
c_func
(paren
op_amp
id|s-&gt;samples_per_cycle
)paren
suffix:semicolon
id|max_packet_size
op_assign
id|max_nevents
op_star
id|s-&gt;dimension
op_star
l_int|4
op_plus
l_int|8
suffix:semicolon
id|s-&gt;packet_pool
op_assign
id|pci_pool_create
c_func
(paren
l_string|&quot;packet pool&quot;
comma
id|s-&gt;host-&gt;ohci-&gt;dev
comma
id|max_packet_size
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;packet_pool
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|s-&gt;free_packet_lists
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|s-&gt;dma_packet_lists
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_PACKET_LISTS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|packet_list
op_star
id|pl
op_assign
id|packet_list_alloc
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pl
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|pl-&gt;link
comma
op_amp
id|s-&gt;free_packet_lists
)paren
suffix:semicolon
)brace
r_return
id|i
OL
id|MAX_PACKET_LISTS
ques
c_cond
op_minus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|stream_free_packet_lists
r_static
r_void
id|stream_free_packet_lists
c_func
(paren
r_struct
id|stream
op_star
id|s
)paren
(brace
r_struct
id|packet_list
op_star
id|packet_l
comma
op_star
id|packet_l_next
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;current_packet_list
op_ne
l_int|NULL
)paren
id|packet_list_free
c_func
(paren
id|s-&gt;current_packet_list
comma
id|s
)paren
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|packet_l
comma
id|packet_l_next
comma
op_amp
id|s-&gt;dma_packet_lists
comma
id|link
)paren
id|packet_list_free
c_func
(paren
id|packet_l
comma
id|s
)paren
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|packet_l
comma
id|packet_l_next
comma
op_amp
id|s-&gt;free_packet_lists
comma
id|link
)paren
id|packet_list_free
c_func
(paren
id|packet_l
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;packet_pool
op_ne
l_int|NULL
)paren
id|pci_pool_destroy
c_func
(paren
id|s-&gt;packet_pool
)paren
suffix:semicolon
id|s-&gt;current_packet_list
op_assign
l_int|NULL
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|s-&gt;free_packet_lists
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|s-&gt;dma_packet_lists
)paren
suffix:semicolon
id|s-&gt;packet_pool
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|plug_update
r_static
r_void
id|plug_update
c_func
(paren
r_struct
id|cmp_pcr
op_star
id|plug
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|stream
op_star
id|s
op_assign
id|data
suffix:semicolon
id|HPSB_INFO
c_func
(paren
l_string|&quot;plug update: p2p_count=%d, channel=%d&quot;
comma
id|plug-&gt;p2p_count
comma
id|plug-&gt;channel
)paren
suffix:semicolon
id|s-&gt;iso_channel
op_assign
id|plug-&gt;channel
suffix:semicolon
r_if
c_cond
(paren
id|plug-&gt;p2p_count
OG
l_int|0
)paren
(brace
r_struct
id|packet_list
op_star
id|pl
suffix:semicolon
id|pl
op_assign
id|list_entry
c_func
(paren
id|s-&gt;dma_packet_lists.next
comma
r_struct
id|packet_list
comma
id|link
)paren
suffix:semicolon
id|stream_start_dma
c_func
(paren
id|s
comma
id|pl
)paren
suffix:semicolon
)brace
r_else
(brace
id|ohci1394_stop_it_ctx
c_func
(paren
id|s-&gt;host-&gt;ohci
comma
id|s-&gt;iso_tasklet.context
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
DECL|function|stream_configure
r_static
r_int
id|stream_configure
c_func
(paren
r_struct
id|stream
op_star
id|s
comma
r_int
id|cmd
comma
r_struct
id|amdtp_ioctl
op_star
id|cfg
)paren
(brace
r_const
r_int
id|transfer_delay
op_assign
l_int|9000
suffix:semicolon
r_if
c_cond
(paren
id|cfg-&gt;format
op_le
id|AMDTP_FORMAT_IEC958_AC3
)paren
id|s-&gt;format
op_assign
id|cfg-&gt;format
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|cfg-&gt;rate
)paren
(brace
r_case
l_int|32000
suffix:colon
id|s-&gt;syt_interval
op_assign
l_int|8
suffix:semicolon
id|s-&gt;fdf
op_assign
id|FDF_SFC_32KHZ
suffix:semicolon
id|s-&gt;iec958_rate_code
op_assign
l_int|0x0c
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|44100
suffix:colon
id|s-&gt;syt_interval
op_assign
l_int|8
suffix:semicolon
id|s-&gt;fdf
op_assign
id|FDF_SFC_44K1HZ
suffix:semicolon
id|s-&gt;iec958_rate_code
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|48000
suffix:colon
id|s-&gt;syt_interval
op_assign
l_int|8
suffix:semicolon
id|s-&gt;fdf
op_assign
id|FDF_SFC_48KHZ
suffix:semicolon
id|s-&gt;iec958_rate_code
op_assign
l_int|0x04
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|88200
suffix:colon
id|s-&gt;syt_interval
op_assign
l_int|16
suffix:semicolon
id|s-&gt;fdf
op_assign
id|FDF_SFC_88K2HZ
suffix:semicolon
id|s-&gt;iec958_rate_code
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|96000
suffix:colon
id|s-&gt;syt_interval
op_assign
l_int|16
suffix:semicolon
id|s-&gt;fdf
op_assign
id|FDF_SFC_96KHZ
suffix:semicolon
id|s-&gt;iec958_rate_code
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|176400
suffix:colon
id|s-&gt;syt_interval
op_assign
l_int|32
suffix:semicolon
id|s-&gt;fdf
op_assign
id|FDF_SFC_176K4HZ
suffix:semicolon
id|s-&gt;iec958_rate_code
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|192000
suffix:colon
id|s-&gt;syt_interval
op_assign
l_int|32
suffix:semicolon
id|s-&gt;fdf
op_assign
id|FDF_SFC_192KHZ
suffix:semicolon
id|s-&gt;iec958_rate_code
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|s-&gt;rate
op_assign
id|cfg-&gt;rate
suffix:semicolon
id|fraction_init
c_func
(paren
op_amp
id|s-&gt;samples_per_cycle
comma
id|s-&gt;rate
comma
l_int|8000
)paren
suffix:semicolon
id|fraction_init
c_func
(paren
op_amp
id|s-&gt;ready_samples
comma
l_int|0
comma
l_int|8000
)paren
suffix:semicolon
multiline_comment|/* The ticks_per_syt_offset is initialized to the number of&n;&t; * ticks between syt_interval events.  The number of ticks per&n;&t; * second is 24.576e6, so the number of ticks between&n;&t; * syt_interval events is 24.576e6 * syt_interval / rate.&n;&t; */
id|fraction_init
c_func
(paren
op_amp
id|s-&gt;ticks_per_syt_offset
comma
l_int|24576000
op_star
id|s-&gt;syt_interval
comma
id|s-&gt;rate
)paren
suffix:semicolon
id|fraction_init
c_func
(paren
op_amp
id|s-&gt;cycle_offset
comma
(paren
id|transfer_delay
op_mod
l_int|3072
)paren
op_star
id|s-&gt;rate
comma
id|s-&gt;rate
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|s-&gt;cycle_count
comma
id|transfer_delay
op_div
l_int|3072
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|s-&gt;cycle_count2
comma
l_int|0
)paren
suffix:semicolon
id|s-&gt;mode
op_assign
id|cfg-&gt;mode
suffix:semicolon
id|s-&gt;sample_format
op_assign
id|AMDTP_INPUT_LE16
suffix:semicolon
multiline_comment|/* When using the AM824 raw subformat we can stream signals of&n;&t; * any dimension.  The IEC958 subformat, however, only&n;&t; * supports 2 channels.&n;&t; */
r_if
c_cond
(paren
id|s-&gt;format
op_eq
id|AMDTP_FORMAT_RAW
op_logical_or
id|cfg-&gt;dimension
op_eq
l_int|2
)paren
id|s-&gt;dimension
op_assign
id|cfg-&gt;dimension
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;opcr
op_ne
l_int|NULL
)paren
(brace
id|cmp_unregister_opcr
c_func
(paren
id|s-&gt;host-&gt;host
comma
id|s-&gt;opcr
)paren
suffix:semicolon
id|s-&gt;opcr
op_assign
l_int|NULL
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|AMDTP_IOC_PLUG
suffix:colon
id|s-&gt;opcr
op_assign
id|cmp_register_opcr
c_func
(paren
id|s-&gt;host-&gt;host
comma
id|cfg-&gt;u.plug
comma
multiline_comment|/*payload*/
l_int|12
comma
id|plug_update
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;opcr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|s-&gt;iso_channel
op_assign
id|s-&gt;opcr-&gt;channel
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AMDTP_IOC_CHANNEL
suffix:colon
r_if
c_cond
(paren
id|cfg-&gt;u.channel
op_ge
l_int|0
op_logical_and
id|cfg-&gt;u.channel
OL
l_int|64
)paren
id|s-&gt;iso_channel
op_assign
id|cfg-&gt;u.channel
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* The ioctl settings were all valid, so we realloc the packet&n;&t; * lists to make sure the packet size is big enough.&n;&t; */
r_if
c_cond
(paren
id|s-&gt;packet_pool
op_ne
l_int|NULL
)paren
id|stream_free_packet_lists
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stream_alloc_packet_lists
c_func
(paren
id|s
)paren
OL
l_int|0
)paren
(brace
id|stream_free_packet_lists
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|stream_alloc
r_struct
id|stream
op_star
id|stream_alloc
c_func
(paren
r_struct
id|amdtp_host
op_star
id|host
)paren
(brace
r_struct
id|stream
op_star
id|s
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|s
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|stream
)paren
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|s
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|stream
)paren
)paren
suffix:semicolon
id|s-&gt;host
op_assign
id|host
suffix:semicolon
id|s-&gt;input
op_assign
id|buffer_alloc
c_func
(paren
id|BUFFER_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;input
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|s-&gt;descriptor_pool
op_assign
id|pci_pool_create
c_func
(paren
l_string|&quot;descriptor pool&quot;
comma
id|host-&gt;ohci-&gt;dev
comma
r_sizeof
(paren
r_struct
id|descriptor_block
)paren
comma
l_int|16
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;descriptor_pool
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|s-&gt;input
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|s-&gt;free_packet_lists
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|s-&gt;dma_packet_lists
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|s-&gt;packet_list_wait
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|s-&gt;packet_list_lock
)paren
suffix:semicolon
id|ohci1394_init_iso_tasklet
c_func
(paren
op_amp
id|s-&gt;iso_tasklet
comma
id|OHCI_ISO_TRANSMIT
comma
id|stream_shift_packet_lists
comma
(paren
r_int
r_int
)paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ohci1394_register_iso_tasklet
c_func
(paren
id|host-&gt;ohci
comma
op_amp
id|s-&gt;iso_tasklet
)paren
OL
l_int|0
)paren
(brace
id|pci_pool_destroy
c_func
(paren
id|s-&gt;descriptor_pool
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|s-&gt;input
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|host-&gt;stream_list_lock
comma
id|flags
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|s-&gt;link
comma
op_amp
id|host-&gt;stream_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|host-&gt;stream_list_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|s
suffix:semicolon
)brace
DECL|function|stream_free
r_void
id|stream_free
c_func
(paren
r_struct
id|stream
op_star
id|s
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Stop the DMA.  We wait for the dma packet list to become&n;&t; * empty and let the dma controller run out of programs.  This&n;&t; * seems to be more reliable than stopping it directly, since&n;&t; * that sometimes generates an it transmit interrupt if we&n;&t; * later re-enable the context.&n;&t; */
id|wait_event_interruptible
c_func
(paren
id|s-&gt;packet_list_wait
comma
id|list_empty
c_func
(paren
op_amp
id|s-&gt;dma_packet_lists
)paren
)paren
suffix:semicolon
id|ohci1394_stop_it_ctx
c_func
(paren
id|s-&gt;host-&gt;ohci
comma
id|s-&gt;iso_tasklet.context
comma
l_int|1
)paren
suffix:semicolon
id|ohci1394_unregister_iso_tasklet
c_func
(paren
id|s-&gt;host-&gt;ohci
comma
op_amp
id|s-&gt;iso_tasklet
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;opcr
op_ne
l_int|NULL
)paren
id|cmp_unregister_opcr
c_func
(paren
id|s-&gt;host-&gt;host
comma
id|s-&gt;opcr
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;host-&gt;stream_list_lock
comma
id|flags
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|s-&gt;link
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;host-&gt;stream_list_lock
comma
id|flags
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|s-&gt;input
)paren
suffix:semicolon
id|stream_free_packet_lists
c_func
(paren
id|s
)paren
suffix:semicolon
id|pci_pool_destroy
c_func
(paren
id|s-&gt;descriptor_pool
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/* File operations */
DECL|function|amdtp_write
r_static
id|ssize_t
id|amdtp_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|offset_is_ignored
)paren
(brace
r_struct
id|stream
op_star
id|s
op_assign
id|file-&gt;private_data
suffix:semicolon
r_int
r_char
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|length
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;packet_pool
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EBADFD
suffix:semicolon
multiline_comment|/* Fill the circular buffer from the input buffer and call the&n;&t; * iso packer when the buffer is full.  The iso packer may&n;&t; * leave bytes in the buffer for two reasons: either the&n;&t; * remaining bytes wasn&squot;t enough to build a new packet, or&n;&t; * there were no free packet lists.  In the first case we&n;&t; * re-fill the buffer and call the iso packer again or return&n;&t; * if we used all the data from userspace.  In the second&n;&t; * case, the wait_event_interruptible will block until the irq&n;&t; * handler frees a packet list.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_add_assign
id|length
)paren
(brace
id|p
op_assign
id|buffer_put_bytes
c_func
(paren
id|s-&gt;input
comma
id|count
op_minus
id|i
comma
op_amp
id|length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|p
comma
id|buffer
op_plus
id|i
comma
id|length
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;input-&gt;length
OL
id|s-&gt;input-&gt;size
)paren
r_continue
suffix:semicolon
id|stream_flush
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;current_packet_list
op_ne
l_int|NULL
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
id|i
op_plus
id|length
OG
l_int|0
ques
c_cond
id|i
op_plus
id|length
suffix:colon
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|wait_event_interruptible
c_func
(paren
id|s-&gt;packet_list_wait
comma
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|s-&gt;free_packet_lists
)paren
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
DECL|function|amdtp_ioctl
r_static
r_int
id|amdtp_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|stream
op_star
id|s
op_assign
id|file-&gt;private_data
suffix:semicolon
r_struct
id|amdtp_ioctl
id|cfg
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|AMDTP_IOC_PLUG
suffix:colon
r_case
id|AMDTP_IOC_CHANNEL
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|cfg
comma
(paren
r_struct
id|amdtp_ioctl
op_star
)paren
id|arg
comma
r_sizeof
id|cfg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
id|stream_configure
c_func
(paren
id|s
comma
id|cmd
comma
op_amp
id|cfg
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|amdtp_poll
r_static
r_int
r_int
id|amdtp_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|pt
)paren
(brace
r_struct
id|stream
op_star
id|s
op_assign
id|file-&gt;private_data
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|s-&gt;packet_list_wait
comma
id|pt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|s-&gt;free_packet_lists
)paren
)paren
r_return
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|amdtp_open
r_static
r_int
id|amdtp_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|amdtp_host
op_star
id|host
suffix:semicolon
r_int
id|i
op_assign
id|ieee1394_file_to_instance
c_func
(paren
id|file
)paren
suffix:semicolon
id|host
op_assign
id|hpsb_get_hostinfo_bykey
c_func
(paren
op_amp
id|amdtp_highlevel
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|host
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|file-&gt;private_data
op_assign
id|stream_alloc
c_func
(paren
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;private_data
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|amdtp_release
r_static
r_int
id|amdtp_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|stream
op_star
id|s
op_assign
id|file-&gt;private_data
suffix:semicolon
id|stream_free
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|amdtp_cdev
r_static
r_struct
id|cdev
id|amdtp_cdev
suffix:semicolon
DECL|variable|amdtp_fops
r_static
r_struct
id|file_operations
id|amdtp_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|write
op_assign
id|amdtp_write
comma
dot
id|poll
op_assign
id|amdtp_poll
comma
dot
id|ioctl
op_assign
id|amdtp_ioctl
comma
dot
id|open
op_assign
id|amdtp_open
comma
dot
id|release
op_assign
id|amdtp_release
)brace
suffix:semicolon
multiline_comment|/* IEEE1394 Subsystem functions */
DECL|function|amdtp_add_host
r_static
r_void
id|amdtp_add_host
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
(brace
r_struct
id|amdtp_host
op_star
id|ah
suffix:semicolon
r_int
id|minor
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|host-&gt;driver-&gt;name
comma
id|OHCI1394_DRIVER_NAME
)paren
op_ne
l_int|0
)paren
r_return
suffix:semicolon
id|ah
op_assign
id|hpsb_create_hostinfo
c_func
(paren
op_amp
id|amdtp_highlevel
comma
id|host
comma
r_sizeof
(paren
op_star
id|ah
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ah
)paren
(brace
id|HPSB_ERR
c_func
(paren
l_string|&quot;amdtp: Unable able to alloc hostinfo&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ah-&gt;host
op_assign
id|host
suffix:semicolon
id|ah-&gt;ohci
op_assign
id|host-&gt;hostdata
suffix:semicolon
id|hpsb_set_hostinfo_key
c_func
(paren
op_amp
id|amdtp_highlevel
comma
id|host
comma
id|ah-&gt;host-&gt;id
)paren
suffix:semicolon
id|minor
op_assign
id|IEEE1394_MINOR_BLOCK_AMDTP
op_star
l_int|16
op_plus
id|ah-&gt;host-&gt;id
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ah-&gt;stream_list
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|ah-&gt;stream_list_lock
)paren
suffix:semicolon
id|devfs_mk_cdev
c_func
(paren
id|MKDEV
c_func
(paren
id|IEEE1394_MAJOR
comma
id|minor
)paren
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
l_string|&quot;amdtp/%d&quot;
comma
id|ah-&gt;host-&gt;id
)paren
suffix:semicolon
)brace
DECL|function|amdtp_remove_host
r_static
r_void
id|amdtp_remove_host
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
(brace
r_struct
id|amdtp_host
op_star
id|ah
op_assign
id|hpsb_get_hostinfo
c_func
(paren
op_amp
id|amdtp_highlevel
comma
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ah
)paren
id|devfs_remove
c_func
(paren
l_string|&quot;amdtp/%d&quot;
comma
id|ah-&gt;host-&gt;id
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|variable|amdtp_highlevel
r_static
r_struct
id|hpsb_highlevel
id|amdtp_highlevel
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;amdtp&quot;
comma
dot
id|add_host
op_assign
id|amdtp_add_host
comma
dot
id|remove_host
op_assign
id|amdtp_remove_host
comma
)brace
suffix:semicolon
multiline_comment|/* Module interface */
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Kristian Hogsberg &lt;hogsberg@users.sf.net&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Driver for Audio &amp; Music Data Transmission Protocol &quot;
l_string|&quot;on OHCI boards.&quot;
)paren
suffix:semicolon
id|MODULE_SUPPORTED_DEVICE
c_func
(paren
l_string|&quot;amdtp&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|function|amdtp_init_module
r_static
r_int
id|__init
id|amdtp_init_module
(paren
r_void
)paren
(brace
id|cdev_init
c_func
(paren
op_amp
id|amdtp_cdev
comma
op_amp
id|amdtp_fops
)paren
suffix:semicolon
id|amdtp_cdev.owner
op_assign
id|THIS_MODULE
suffix:semicolon
r_if
c_cond
(paren
id|cdev_add
c_func
(paren
op_amp
id|amdtp_cdev
comma
id|IEEE1394_AMDTP_DEV
comma
l_int|16
)paren
)paren
(brace
id|HPSB_ERR
c_func
(paren
l_string|&quot;amdtp: unable to add char device&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|devfs_mk_dir
c_func
(paren
l_string|&quot;amdtp&quot;
)paren
suffix:semicolon
id|hpsb_register_highlevel
c_func
(paren
op_amp
id|amdtp_highlevel
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_COMPAT
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|register_ioctl32_conversion
c_func
(paren
id|AMDTP_IOC_CHANNEL
comma
l_int|NULL
)paren
suffix:semicolon
id|ret
op_or_assign
id|register_ioctl32_conversion
c_func
(paren
id|AMDTP_IOC_PLUG
comma
l_int|NULL
)paren
suffix:semicolon
id|ret
op_or_assign
id|register_ioctl32_conversion
c_func
(paren
id|AMDTP_IOC_PING
comma
l_int|NULL
)paren
suffix:semicolon
id|ret
op_or_assign
id|register_ioctl32_conversion
c_func
(paren
id|AMDTP_IOC_ZAP
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|HPSB_ERR
c_func
(paren
l_string|&quot;amdtp: Error registering ioctl32 translations&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|HPSB_INFO
c_func
(paren
l_string|&quot;Loaded AMDTP driver&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|amdtp_exit_module
r_static
r_void
id|__exit
id|amdtp_exit_module
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_COMPAT
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|unregister_ioctl32_conversion
c_func
(paren
id|AMDTP_IOC_CHANNEL
)paren
suffix:semicolon
id|ret
op_or_assign
id|unregister_ioctl32_conversion
c_func
(paren
id|AMDTP_IOC_PLUG
)paren
suffix:semicolon
id|ret
op_or_assign
id|unregister_ioctl32_conversion
c_func
(paren
id|AMDTP_IOC_PING
)paren
suffix:semicolon
id|ret
op_or_assign
id|unregister_ioctl32_conversion
c_func
(paren
id|AMDTP_IOC_ZAP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|HPSB_ERR
c_func
(paren
l_string|&quot;amdtp: Error unregistering ioctl32 translations&quot;
)paren
suffix:semicolon
macro_line|#endif
id|hpsb_unregister_highlevel
c_func
(paren
op_amp
id|amdtp_highlevel
)paren
suffix:semicolon
id|devfs_remove
c_func
(paren
l_string|&quot;amdtp&quot;
)paren
suffix:semicolon
id|cdev_del
c_func
(paren
op_amp
id|amdtp_cdev
)paren
suffix:semicolon
id|HPSB_INFO
c_func
(paren
l_string|&quot;Unloaded AMDTP driver&quot;
)paren
suffix:semicolon
)brace
DECL|variable|amdtp_init_module
id|module_init
c_func
(paren
id|amdtp_init_module
)paren
suffix:semicolon
DECL|variable|amdtp_exit_module
id|module_exit
c_func
(paren
id|amdtp_exit_module
)paren
suffix:semicolon
id|MODULE_ALIAS_CHARDEV
c_func
(paren
id|IEEE1394_MAJOR
comma
id|IEEE1394_MINOR_BLOCK_AMDTP
op_star
l_int|16
)paren
suffix:semicolon
eof
