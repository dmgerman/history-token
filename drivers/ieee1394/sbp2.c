multiline_comment|/*&n; * sbp2.c - SBP-2 protocol driver for IEEE-1394&n; *&n; * Copyright (C) 2000 James Goodwin, Filanet Corporation (www.filanet.com)&n; * jamesg@filanet.com&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software Foundation,&n; * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.&n; */
multiline_comment|/*&n; * Brief Description:&n; *&n; * This driver implements the Serial Bus Protocol 2 (SBP-2) over IEEE-1394&n; * under Linux. The SBP-2 driver is implemented as an IEEE-1394 high-level&n; * driver. It also registers as a SCSI lower-level driver in order to accept&n; * SCSI commands for transport using SBP-2.&n; *&n; * Driver Loading:&n; *&n; * Currently, the SBP-2 driver is supported only as a module. Because the &n; * Linux SCSI stack is not Plug-N-Play aware, module load order is &n; * important. Assuming the SCSI core drivers are either built into the &n; * kernel or already loaded as modules, you should load the IEEE-1394 modules &n; * in the following order:&n; *&n; * &t;ieee1394 (e.g. insmod ieee1394)&n; *&t;ohci1394 (e.g. insmod ohci1394)&n; *&t;sbp2 (e.g. insmod sbp2)&n; *&n; * The SBP-2 driver will attempt to discover any attached SBP-2 devices when first&n; * loaded, or after any IEEE-1394 bus reset (e.g. a hot-plug). It will then print &n; * out a debug message indicating if it was able to discover a SBP-2 device.&n; *&n; * Currently, the SBP-2 driver will catch any attached SBP-2 devices during the&n; * initial scsi bus scan (when the driver is first loaded). To add or remove&n; * SBP-2 devices after this initial scan (i.e. if you plug-in or un-plug a &n; * device after the SBP-2 driver is loaded), you must either use the scsi procfs&n; * add-single-device, remove-single-device, or a shell script such as &n; * rescan-scsi-bus.sh.&n; *&n; * The easiest way to add/detect new SBP-2 devices is to run the shell script&n; * rescan-scsi-bus.sh (or re-load the SBP-2 driver). This script may be &n; * found at:&n; * http://www.garloff.de/kurt/linux/rescan-scsi-bus.sh&n; *&n; * As an alternative, you may manually add/remove SBP-2 devices via the procfs with&n; * add-single-device &lt;h&gt; &lt;b&gt; &lt;t&gt; &lt;l&gt; or remove-single-device &lt;h&gt; &lt;b&gt; &lt;t&gt; &lt;l&gt;, where:&n; *&t;&lt;h&gt; = host (starting at zero for first SCSI adapter)&n; *&t;&lt;b&gt; = bus (normally zero)&n; *&t;&lt;t&gt; = target (starting at zero for first SBP-2 device)&n; *&t;&lt;l&gt; = lun (normally zero)&n; *&n; * e.g. To manually add/detect a new SBP-2 device&n; *&t;echo &quot;scsi add-single-device 0 0 0 0&quot; &gt; /proc/scsi/scsi&n; *&n; * e.g. To manually remove a SBP-2 device after it&squot;s been unplugged&n; *&t;echo &quot;scsi remove-single-device 0 0 0 0&quot; &gt; /proc/scsi/scsi&n; *&n; * e.g. To check to see which SBP-2/SCSI devices are currently registered&n; * &t;cat /proc/scsi/scsi&n; *&n; * After scanning for new SCSI devices (above), you may access any attached &n; * SBP-2 storage devices as if they were SCSI devices (e.g. mount /dev/sda1, &n; * fdisk, mkfs, etc.).&n; *&n; *&n; * Current Support:&n; *&n; * The SBP-2 driver is still in an early state, but supports a variety of devices.&n; * I have read/written many gigabytes of data from/to SBP-2 drives, and have seen &n; * performance of more than 16 MBytes/s on individual drives (limit of the media &n; * transfer rate).&n; *&n; * Following are the devices that have been tested successfully:&n; *&n; *&t;- Western Digital IEEE-1394 hard drives&n; *&t;- Maxtor IEEE-1394 hard drives&n; *&t;- VST (SmartDisk) IEEE-1394 hard drives and Zip drives (several flavors)&n; *&t;- LaCie IEEE-1394 hard drives (several flavors)&n; *&t;- QPS IEEE-1394 CD-RW/DVD drives and hard drives&n; *&t;- BusLink IEEE-1394 hard drives&n; *&t;- Iomega IEEE-1394 Zip/Jazz drives&n; *&t;- ClubMac IEEE-1394 hard drives&n; *&t;- FirePower IEEE-1394 hard drives&n; *&t;- EzQuest IEEE-1394 hard drives and CD-RW drives&n; *&t;- Castlewood/ADS IEEE-1394 ORB drives&n; *&t;- Evergreen IEEE-1394 hard drives and CD-RW drives&n; *&t;- Addonics IEEE-1394 CD-RW drives&n; *&t;- Bellstor IEEE-1394 hard drives and CD-RW drives&n; *&t;- APDrives IEEE-1394 hard drives&n; *&t;- Fujitsu IEEE-1394 MO drives&n; *&t;- Sony IEEE-1394 CD-RW drives&n; *&t;- Epson IEEE-1394 scanner&n; *&t;- ADS IEEE-1394 memory stick and compact flash readers &n; *&t;  (e.g. &quot;insmod sbp2 mode_sense_hack=1&quot; for mem stick and flash readers))&n; *&t;- SBP-2 bridge-based devices (LSI, Oxford Semiconductor, Indigita bridges)&n; *&t;- Various other standard IEEE-1394 hard drives and enclosures&n; *&n; *&n; * Performance Issues:&n; *&n; *&t;- Make sure you are &quot;not&quot; running fat/fat32 on your attached SBP-2 drives. You&squot;ll&n; *&t;  get much better performance formatting the drive ext2 (but you will lose the&n; *&t;  ability to easily move the drive between Windows/Linux).&n; *&n; *&n; * Current Issues:&n; *&n; *&t;- Currently, all I/O from the scsi stack is serialized by default, as there&n; *&t;  are some stress issues under investigation with deserialized I/O. To enable&n; *&t;  deserialized I/O for testing, do &quot;insmod sbp2 serialize_io=0&quot;&n; *&n; *&t;- Hot-Plugging: Need to add procfs support and integration with linux&n; *&t;  hot-plug support (http://linux-hotplug.sourceforge.net) for auto-mounting &n; *&t;  of drives.&n; *&n; *&t;- Error Handling: SCSI aborts and bus reset requests are handled somewhat&n; *&t;  but the code needs additional debugging.&n; *&n; *&t;- IEEE-1394 Bus Management: There is currently little bus management&n; *&t;  in the core IEEE-1394 stack. Because of this, the SBP-2 driver handles&n; *&t;  detection of SBP-2 devices itself. This should be moved to the core&n; *&t;  stack.&n; *&n; *&t;- The SBP-2 driver is currently only supported as a module. It would not take&n; *&t;  much work to allow it to be compiled into the kernel, but you&squot;d have to &n; *&t;  add some init code to the kernel to support this... and modules are much&n; *&t;  more flexible anyway.   ;-)&n; *&n; *&t;- Workaround for PPC pismo firewire chipset (enable SBP2_PPC_PISMO_WORKAROUND&n; *&t;  define below).&n; *&n; *&n; * History:&n; *&n; *&t;07/25/00 - Initial revision (JSG)&n; *&t;08/11/00 - Following changes/bug fixes were made (JSG):&n; *&t;&t;   * Bug fix to SCSI procfs code (still needs to be synched with 2.4 kernel).&n; *&t;&t;   * Bug fix where request sense commands were actually sent on the bus.&n; *&t;&t;   * Changed bus reset/abort code to deal with devices that spin up quite&n; *&t;&t;     slowly (which result in SCSI time-outs).&n; *&t;&t;   * &quot;More&quot; properly pull information from device&squot;s config rom, for enumeration&n; *&t;&t;     of SBP-2 devices, and determining SBP-2 register offsets.&n; *&t;&t;   * Change Simplified Direct Access Device type to Direct Access Device type in&n; *&t;&t;     returned inquiry data, in order to make the SCSI stack happy.&n; *&t;&t;   * Modified driver to register with the SCSI stack &quot;before&quot; enumerating any attached&n; *&t;&t;     SBP-2 devices. This means that you&squot;ll have to use procfs scsi-add-device or &n; *&t;&t;     some sort of script to discover new SBP-2 devices.&n; *&t;&t;   * Minor re-write of some code and other minor changes.&n; *&t;08/28/00 - Following changes/bug fixes were made (JSG):&n; *&t;&t;   * Bug fixes to scatter/gather support (case of one s/g element)&n; *&t;&t;   * Updated direction table for scsi commands (mostly DVD commands)&n; *&t;&t;   * Retries when trying to detect SBP-2 devices (for slow devices)&n; *&t;&t;   * Slightly better error handling (previously none) when commands time-out.&n; *&t;&t;   * Misc. other bug fixes and code reorganization.&n; *&t;09/13/00 - Following changes/bug fixes were made (JSG)&n; *&t;&t;   * Moved detection/enumeration code to a kernel thread which is woken up when IEEE-1394&n; *&t;&t;     bus resets occur.&n; *&t;&t;   * Added code to handle bus resets and hot-plugging while devices are mounted, but full&n; *&t;&t;     hot-plug support is not quite there yet.&n; *&t;&t;   * Now use speed map to determine speed and max payload sizes for ORBs&n; *&t;&t;   * Clean-up of code and reorganization &n; *&t;09/19/00 - Added better hot-plug support and other minor changes (JSG)&n; *&t;10/15/00 - Fixes for latest 2.4.0 test kernel, minor fix for hot-plug race. (JSG)&n; *&t;12/03/00 - Created pool of request packet structures for use in sending out sbp2 command&n; *&t;&t;   and agent reset requests. This removes the kmallocs/kfrees in the critical I/O paths,&n; *&t;&t;   and also deals with some subtle race conditions related to allocating and freeing&n; *&t;&t;   packets. (JSG)&n; *      12/09/00 - Improved the sbp2 device detection by actually reading the root and unit &n; *&t;&t;   directory (khk@khk.net)&n; *&t;12/23/00 - Following changes/enhancements were made (JSG)&n; *&t;&t;   * Only do SCSI to RBC command conversion for Direct Access and Simplified&n; *&t;&t;     Direct Access Devices (this is pulled from the config rom root directory).&n; *&t;&t;     This is needed because doing the conversion for all device types broke the&n; *&t;&t;     Epson scanner. Still looking for a better way of determining when to convert&n; *&t;&t;     commands (for RBC devices). Thanks to khk for helping on this!&n; *&t;&t;   * Added ability to &quot;emulate&quot; physical dma support, for host adapters such as TILynx.&n; *&t;&t;   * Determine max payload and speed by also looking at the host adapter&squot;s max_rec field.&n; *&t;01/19/01 - Added checks to sbp2 login and made the login time-out longer. Also fixed a compile &n; *&t;&t;   problem for 2.4.0. (JSG)&n; *&t;01/24/01 - Fixed problem when individual s/g elements are 64KB or larger. Needed to break&n; *&t;&t;   up these larger elements, since the sbp2 page table element size is only 16 bits. (JSG)&n; *&t;01/29/01 - Minor byteswap fix for login response (used for reconnect and log out).&n; *&t;03/07/01 - Following changes/enhancements were made (JSG)&n; *&t;&t;   * Changes to allow us to catch the initial scsi bus scan (for detecting sbp2&n; *&t;&t;     devices when first loading sbp2.o). To disable this, un-define &n; *&t;&t;     SBP2_SUPPORT_INITIAL_BUS_SCAN.&n; *&t;&t;   * Temporary fix to deal with many sbp2 devices that do not support individual&n; *&t;&t;     transfers of greater than 128KB in size. &n; *&t;&t;   * Mode sense conversion from 6 byte to 10 byte versions for CDRW/DVD devices. (Mark Burton)&n; *&t;&t;   * Define allowing support for goofy sbp2 devices that do not support mode&n; *&t;&t;     sense command at all, allowing them to be mounted rw (such as 1394 memory&n; *&t;&t;     stick and compact flash readers). Define SBP2_MODE_SENSE_WRITE_PROTECT_HACK&n; *&t;&t;     if you need this fix.&n; *&t;03/29/01 - Major performance enhancements and misc. other changes. Thanks to Daniel Berlin for many of&n; *&t;&t;   changes and suggestions for change:&n; *&t;&t;   * Now use sbp2 doorbell and link commands on the fly (instead of serializing requests)&n; *&t;&t;   * Removed all bit fields in an attempt to run on PPC machines (still needs a little more work)&n; *&t;&t;   * Added large request break-up/linking support for sbp2 chipsets that do not support transfers &n; *&t;&t;     greater than 128KB in size.&n; *&t;&t;   * Bumped up max commands per lun to two, and max total outstanding commands to eight.&n; *&t;04/03/01 - Minor clean-up. Write orb pointer directly if no outstanding commands (saves one 1394 bus&n; *&t;&t;   transaction). Added module load options (bus scan, mode sense hack, max speed, serialize_io,&n; *&t;&t;   no_large_transfers). Better bus reset handling while I/O pending. Set serialize_io to 1 by &n; *&t;&t;   default (debugging of deserialized I/O in progress).&n; *&t;04/04/01 - Added workaround for PPC Pismo firewire chipset. See #define below. (Daniel Berlin)&n; *&t;04/20/01 - Minor clean-up. Allocate more orb structures when running with sbp2 target chipsets with&n; *&t;&t;   128KB max transfer limit.&n; *&t;06/16/01 - Converted DMA interfaces to pci_dma - Ben Collins&n; *&t;&t;&t;&t;&t;&t;&t; &lt;bcollins@debian.org&n; *&t;07/22/01 - Use NodeMngr to get info about the local host and&n; *&t;&t;   attached devices. Ben Collins&n; */
multiline_comment|/*&n; * Includes&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/current.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/scatterlist.h&gt;
macro_line|#include &quot;ieee1394.h&quot;
macro_line|#include &quot;ieee1394_types.h&quot;
macro_line|#include &quot;ieee1394_core.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;nodemgr.h&quot;
macro_line|#include &quot;highlevel.h&quot;
macro_line|#include &quot;ieee1394_transactions.h&quot;
macro_line|#include &quot;ieee1394_hotplug.h&quot;
macro_line|#include &quot;../scsi/scsi.h&quot;
macro_line|#include &quot;../scsi/hosts.h&quot;
macro_line|#include &quot;../scsi/sd.h&quot;
macro_line|#include &quot;sbp2.h&quot;
multiline_comment|/*&n; * PPC firewire Pismo chipset workaround!!!&n; *&n; * This is a workaround for a bug in the firewire pismo chipset. For some odd reason the status&n; * fifo address hi/lo must be byteswapped and the response address byteswapped, but no other&n; * parts of the structure. Apple&squot;s drivers seem to specifically check for the pismo and do&n; * the same workaround for sbp2. (Daniel Berlin)&n; *&n; * Please enable the following define if you&squot;re running on the PPC Pismo chipset.&n; */
macro_line|#ifdef CONFIG_IEEE1394_SBP2_PISMO
DECL|macro|SBP2_NEED_LOGIN_DESCRIPTOR_WORKAROUND
mdefine_line|#define SBP2_NEED_LOGIN_DESCRIPTOR_WORKAROUND
macro_line|#endif
multiline_comment|/*&n; * Module load parameter definitions&n; */
multiline_comment|/*&n; * Normally the sbp2 driver tries to catch the initial scsi bus scan to pick up any &n; * attached sbp2 devices. Setting no_bus_scan to 1 tells the sbp2 driver not to catch&n; * this initial scsi bus scan on module load. You can always either add or remove devices &n; * later through the rescan-scsi-bus.sh script or scsi procfs.&n; */
id|MODULE_PARM
c_func
(paren
id|no_bus_scan
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|no_bus_scan
comma
l_string|&quot;Skip the initial scsi bus scan during module load&quot;
)paren
suffix:semicolon
DECL|variable|no_bus_scan
r_static
r_int
id|no_bus_scan
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Set mode_sense_hack to 1 if you have some sort of unusual sbp2 device, like a 1394 memory &n; * stick reader, compact flash reader, or MO drive that does not support mode sense. Allows&n; * you to mount the media rw instead of ro.&n; */
id|MODULE_PARM
c_func
(paren
id|mode_sense_hack
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|mode_sense_hack
comma
l_string|&quot;Emulate mode sense for devices like 1394 memory stick readers&quot;
)paren
suffix:semicolon
DECL|variable|mode_sense_hack
r_static
r_int
id|mode_sense_hack
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Change max_speed on module load if you have a bad IEEE-1394 controller that has trouble running&n; * 2KB packets at 400mb.&n; *&n; * NOTE: On certain OHCI parts I have seen short packets on async transmit (probably &n; * due to PCI latency/throughput issues with the part). You can bump down the speed if&n; * you are running into problems.&n; *&n; * Valid values:&n; * max_speed = 2 (default: max speed 400mb)&n; * max_speed = 1 (max speed 200mb)&n; * max_speed = 0 (max speed 100mb)&n; */
id|MODULE_PARM
c_func
(paren
id|max_speed
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|max_speed
comma
l_string|&quot;Force down max speed (2 = 400mb default, 1 = 200mb, 0 = 100mb)&quot;
)paren
suffix:semicolon
DECL|variable|max_speed
r_static
r_int
id|max_speed
op_assign
id|SPEED_400
suffix:semicolon
multiline_comment|/*&n; * Set serialize_io to 1 if you&squot;d like only one scsi command sent down to us at a time (debugging).&n; */
id|MODULE_PARM
c_func
(paren
id|serialize_io
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|serialize_io
comma
l_string|&quot;Serialize all I/O coming down from the scsi drivers (debugging)&quot;
)paren
suffix:semicolon
DECL|variable|serialize_io
r_static
r_int
id|serialize_io
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* serialize I/O until stress issues are resolved */
multiline_comment|/*&n; * Set no_large_packets to 1 if you&squot;d like to limit the size of requests sent down to us (normally&n; * the sbp2 driver will break up any requests to any individual devices with 128KB transfer size limits).&n; * Sets max s/g list elements to 0x1f in size and disables s/g clustering.&n; */
id|MODULE_PARM
c_func
(paren
id|no_large_packets
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|no_large_packets
comma
l_string|&quot;Do not allow large transfers from scsi drivers (debugging)&quot;
)paren
suffix:semicolon
DECL|variable|no_large_packets
r_static
r_int
id|no_large_packets
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Export information about protocols/devices supported by this driver&n; */
DECL|variable|sbp2_id_table
r_static
r_struct
id|ieee1394_device_id
id|sbp2_id_table
(braket
)braket
op_assign
(brace
id|IEEE1394_PROTOCOL
c_func
(paren
id|SBP2_UNIT_SPEC_ID_ENTRY
comma
id|SBP2_SW_VERSION_ENTRY
)paren
comma
(brace
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|ieee1394
comma
id|sbp2_id_table
)paren
suffix:semicolon
multiline_comment|/*&n; * Debug levels, configured via kernel config.&n; */
macro_line|#ifdef CONFIG_IEEE1394_SBP2_DEBUG_ORBS
DECL|macro|SBP2_ORB_DEBUG
mdefine_line|#define SBP2_ORB_DEBUG(fmt, args...)&t;HPSB_ERR(&quot;sbp2(&quot;__FUNCTION__&quot;): &quot;fmt, ## args)
DECL|variable|global_outstanding_command_orbs
r_static
id|u32
id|global_outstanding_command_orbs
op_assign
l_int|0
suffix:semicolon
DECL|macro|outstanding_orb_incr
mdefine_line|#define outstanding_orb_incr global_outstanding_command_orbs++
DECL|macro|outstanding_orb_decr
mdefine_line|#define outstanding_orb_decr global_outstanding_command_orbs--
macro_line|#else
DECL|macro|SBP2_ORB_DEBUG
mdefine_line|#define SBP2_ORB_DEBUG(fmt, args...)
DECL|macro|outstanding_orb_incr
mdefine_line|#define outstanding_orb_incr
DECL|macro|outstanding_orb_decr
mdefine_line|#define outstanding_orb_decr
macro_line|#endif
macro_line|#ifdef CONFIG_IEEE1394_SBP2_DEBUG_DMA
DECL|macro|SBP2_DMA_ALLOC
mdefine_line|#define SBP2_DMA_ALLOC(fmt, args...) &bslash;&n;&t;HPSB_ERR(&quot;sbp2(&quot;__FUNCTION__&quot;)alloc(%d): &quot;fmt, &bslash;&n;&t;&t; ++global_outstanding_dmas, ## args)
DECL|macro|SBP2_DMA_FREE
mdefine_line|#define SBP2_DMA_FREE(fmt, args...) &bslash;&n;&t;HPSB_ERR(&quot;sbp2(&quot;__FUNCTION__&quot;)free(%d): &quot;fmt, &bslash;&n;&t;&t; --global_outstanding_dmas, ## args)
DECL|variable|global_outstanding_dmas
r_static
id|u32
id|global_outstanding_dmas
op_assign
l_int|0
suffix:semicolon
macro_line|#else
DECL|macro|SBP2_DMA_ALLOC
mdefine_line|#define SBP2_DMA_ALLOC(fmt, args...)
DECL|macro|SBP2_DMA_FREE
mdefine_line|#define SBP2_DMA_FREE(fmt, args...)
macro_line|#endif
macro_line|#if CONFIG_IEEE1394_SBP2_DEBUG &gt;= 2
DECL|macro|SBP2_DEBUG
mdefine_line|#define SBP2_DEBUG(fmt, args...)&t;HPSB_ERR(fmt, ## args)&t;
DECL|macro|SBP2_INFO
mdefine_line|#define SBP2_INFO(fmt, args...)&t;&t;HPSB_ERR(fmt, ## args)&t;
DECL|macro|SBP2_NOTICE
mdefine_line|#define SBP2_NOTICE(fmt, args...)&t;HPSB_ERR(fmt, ## args)&t;
DECL|macro|SBP2_WARN
mdefine_line|#define SBP2_WARN(fmt, args...)&t;&t;HPSB_ERR(fmt, ## args)
macro_line|#elif CONFIG_IEEE1394_SBP2_DEBUG == 1
DECL|macro|SBP2_DEBUG
mdefine_line|#define SBP2_DEBUG(fmt, args...)&t;HPSB_DEBUG(fmt, ## args)
DECL|macro|SBP2_INFO
mdefine_line|#define SBP2_INFO(fmt, args...)&t;&t;HPSB_INFO(fmt, ## args)
DECL|macro|SBP2_NOTICE
mdefine_line|#define SBP2_NOTICE(fmt, args...)&t;HPSB_NOTICE(fmt, ## args)
DECL|macro|SBP2_WARN
mdefine_line|#define SBP2_WARN(fmt, args...)&t;&t;HPSB_WARN(fmt, ## args)
macro_line|#else 
DECL|macro|SBP2_DEBUG
mdefine_line|#define SBP2_DEBUG(fmt, args...)&t;
DECL|macro|SBP2_INFO
mdefine_line|#define SBP2_INFO(fmt, args...)&t;
DECL|macro|SBP2_NOTICE
mdefine_line|#define SBP2_NOTICE(fmt, args...)&t;
DECL|macro|SBP2_WARN
mdefine_line|#define SBP2_WARN(fmt, args...)&t;
macro_line|#endif
DECL|macro|SBP2_ERR
mdefine_line|#define SBP2_ERR(fmt, args...)&t;&t;HPSB_ERR(fmt, ## args)
multiline_comment|/*&n; * Spinlock debugging stuff. I&squot;m playing it safe until the driver has been debugged on SMP. (JSG)&n; */
multiline_comment|/* #define SBP2_USE_REAL_SPINLOCKS */
macro_line|#ifdef SBP2_USE_REAL_SPINLOCKS
DECL|macro|sbp2_spin_lock
mdefine_line|#define sbp2_spin_lock(lock, flags)&t;spin_lock_irqsave(lock, flags)&t;
DECL|macro|sbp2_spin_unlock
mdefine_line|#define sbp2_spin_unlock(lock, flags)&t;spin_unlock_irqrestore(lock, flags);
macro_line|#else
DECL|macro|sbp2_spin_lock
mdefine_line|#define sbp2_spin_lock(lock, flags)&t;do {save_flags(flags); cli();} while (0)&t;
DECL|macro|sbp2_spin_unlock
mdefine_line|#define sbp2_spin_unlock(lock, flags)&t;do {restore_flags(flags);} while (0)
macro_line|#endif
multiline_comment|/*&n; * Globals&n; */
DECL|variable|global_scsi_tpnt
id|Scsi_Host_Template
op_star
id|global_scsi_tpnt
op_assign
l_int|NULL
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|sbp2_host_info_list
)paren
suffix:semicolon
DECL|variable|sbp2_host_count
r_static
r_int
id|sbp2_host_count
op_assign
l_int|0
suffix:semicolon
DECL|variable|sbp2_host_info_lock
r_static
id|spinlock_t
id|sbp2_host_info_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|sbp2_hl_handle
r_static
r_struct
id|hpsb_highlevel
op_star
id|sbp2_hl_handle
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|sbp2_hl_ops
r_static
r_struct
id|hpsb_highlevel_ops
id|sbp2_hl_ops
op_assign
(brace
id|sbp2_add_host
comma
id|sbp2_remove_host
comma
id|sbp2_host_reset
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|sbp2_ops
r_static
r_struct
id|hpsb_address_ops
id|sbp2_ops
op_assign
(brace
id|write
suffix:colon
id|sbp2_handle_status_write
comma
)brace
suffix:semicolon
macro_line|#if 0
r_static
r_struct
id|hpsb_address_ops
id|sbp2_physdma_ops
op_assign
(brace
id|read
suffix:colon
id|sbp2_handle_physdma_read
comma
id|write
suffix:colon
id|sbp2_handle_physdma_write
comma
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/**************************************&n; * General utility functions&n; **************************************/
macro_line|#ifndef __BIG_ENDIAN
multiline_comment|/*&n; * Converts a buffer from be32 to cpu byte ordering. Length is in bytes.&n; */
DECL|function|sbp2util_be32_to_cpu_buffer
r_static
id|__inline__
r_void
id|sbp2util_be32_to_cpu_buffer
c_func
(paren
r_void
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
id|u32
op_star
id|temp
op_assign
id|buffer
suffix:semicolon
r_for
c_loop
(paren
id|length
op_assign
(paren
id|length
op_rshift
l_int|2
)paren
suffix:semicolon
id|length
op_decrement
suffix:semicolon
)paren
id|temp
(braket
id|length
)braket
op_assign
id|be32_to_cpu
c_func
(paren
id|temp
(braket
id|length
)braket
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Converts a buffer from cpu to be32 byte ordering. Length is in bytes.&n; */
DECL|function|sbp2util_cpu_to_be32_buffer
r_static
id|__inline__
r_void
id|sbp2util_cpu_to_be32_buffer
c_func
(paren
r_void
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
id|u32
op_star
id|temp
op_assign
id|buffer
suffix:semicolon
r_for
c_loop
(paren
id|length
op_assign
(paren
id|length
op_rshift
l_int|2
)paren
suffix:semicolon
id|length
op_decrement
suffix:semicolon
)paren
id|temp
(braket
id|length
)braket
op_assign
id|cpu_to_be32
c_func
(paren
id|temp
(braket
id|length
)braket
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#else /* BIG_ENDIAN */
multiline_comment|/* Why waste the cpu cycles? */
DECL|macro|sbp2util_be32_to_cpu_buffer
mdefine_line|#define sbp2util_be32_to_cpu_buffer(x,y)
DECL|macro|sbp2util_cpu_to_be32_buffer
mdefine_line|#define sbp2util_cpu_to_be32_buffer(x,y)
macro_line|#endif
multiline_comment|/*&n; * This function does quadlet sized reads (used by detection code)&n; */
DECL|function|sbp2util_read_quadlet
r_static
r_int
id|sbp2util_read_quadlet
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
id|nodeid_t
id|node
comma
id|u64
id|addr
comma
id|quadlet_t
op_star
id|buffer
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
id|retry_count
op_assign
l_int|3
suffix:semicolon
multiline_comment|/*&n;&t; * Retry a couple times if needed (for slow devices)&n;&t; */
r_do
(brace
id|retval
op_assign
id|hpsb_read
c_func
(paren
id|hi-&gt;host
comma
id|node
comma
id|addr
comma
id|buffer
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2util_read_quadlet data packet error&quot;
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|50
)paren
suffix:semicolon
multiline_comment|/* 20ms delay */
)brace
id|retry_count
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|retval
op_logical_and
id|retry_count
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * This function returns the address of the unit directory.&n; */
DECL|function|sbp2util_unit_directory
r_static
r_int
id|sbp2util_unit_directory
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
id|nodeid_t
id|node_id
comma
id|u64
op_star
id|unit_directory_addr
)paren
(brace
id|quadlet_t
id|root_directory_length
comma
id|current_quadlet
suffix:semicolon
id|u64
id|current_addr
suffix:semicolon
r_int
id|length
comma
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * First, read the first quadlet of the root directory to determine its size&n;&t; */
r_if
c_cond
(paren
id|sbp2util_read_quadlet
c_func
(paren
id|hi
comma
id|LOCAL_BUS
op_or
id|node_id
comma
id|CONFIG_ROM_ROOT_DIR_BASE
comma
op_amp
id|root_directory_length
)paren
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: Error reading root directory length - bad status&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|current_addr
op_assign
id|CONFIG_ROM_ROOT_DIR_BASE
suffix:semicolon
id|length
op_assign
id|be32_to_cpu
c_func
(paren
id|root_directory_length
)paren
op_rshift
l_int|16
suffix:semicolon
multiline_comment|/*&n;&t; * Step through the root directory and look for the &quot;Unit_Directory entry&quot;, which&n;&t; * contains the offset to the unit directory.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|length
suffix:semicolon
id|i
op_increment
)paren
(brace
id|current_addr
op_add_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|sbp2util_read_quadlet
c_func
(paren
id|hi
comma
id|LOCAL_BUS
op_or
id|node_id
comma
id|current_addr
comma
op_amp
id|current_quadlet
)paren
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: Error reading at address 0x%08x%08x - bad status&quot;
comma
(paren
r_int
r_int
)paren
(paren
(paren
id|current_addr
)paren
op_rshift
l_int|32
)paren
comma
(paren
r_int
r_int
)paren
(paren
(paren
id|current_addr
)paren
op_amp
l_int|0xffffffff
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*  &n;&t;&t; * Check for unit directory offset tag &n;&t;&t; */
r_if
c_cond
(paren
(paren
id|be32_to_cpu
c_func
(paren
id|current_quadlet
)paren
op_rshift
l_int|24
)paren
op_eq
id|SBP2_UNIT_DIRECTORY_OFFSET_KEY
)paren
(brace
op_star
id|unit_directory_addr
op_assign
id|current_addr
op_plus
l_int|4
op_star
(paren
(paren
id|be32_to_cpu
c_func
(paren
id|current_quadlet
)paren
op_amp
l_int|0xffffff
)paren
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: unit_directory_addr = %lu&quot;
comma
op_star
id|unit_directory_addr
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called to initially create a packet pool for use in sbp2 I/O requests.&n; * This packet pool is used when sending out sbp2 command and agent reset requests, and &n; * allows us to remove all kmallocs/kfrees from the critical I/O paths.&n; */
DECL|function|sbp2util_create_request_packet_pool
r_static
r_int
id|sbp2util_create_request_packet_pool
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
)paren
(brace
r_struct
id|hpsb_packet
op_star
id|packet
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * Create SBP2_MAX_REQUEST_PACKETS number of request packets.&n;&t; */
id|sbp2_spin_lock
c_func
(paren
op_amp
id|hi-&gt;sbp2_request_packet_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SBP2_MAX_REQUEST_PACKETS
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Max payload of 8 bytes since the sbp2 command request uses a payload of &n;&t;&t; * 8 bytes, and agent reset is a quadlet write request. Bump this up if we&n;&t;&t; * plan on using this pool for other stuff.&n;&t;&t; */
id|packet
op_assign
id|alloc_hpsb_packet
c_func
(paren
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|packet
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: sbp2util_create_request_packet_pool - packet allocation failed!&quot;
)paren
suffix:semicolon
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|hi-&gt;sbp2_request_packet_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * Put these request packets into a free list&n;&t;&t; */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|hi-&gt;request_packet
(braket
id|i
)braket
dot
id|list
)paren
suffix:semicolon
id|hi-&gt;request_packet
(braket
id|i
)braket
dot
id|packet
op_assign
id|packet
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|hi-&gt;request_packet
(braket
id|i
)braket
dot
id|list
comma
op_amp
id|hi-&gt;sbp2_req_free
)paren
suffix:semicolon
)brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|hi-&gt;sbp2_request_packet_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called to remove the packet pool. It is called when the sbp2 driver is unloaded.&n; */
DECL|function|sbp2util_remove_request_packet_pool
r_static
r_void
id|sbp2util_remove_request_packet_pool
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|sbp2_request_packet
op_star
id|request_packet
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* &n;&t; * Go through free list releasing packets&n;&t; */
id|sbp2_spin_lock
c_func
(paren
op_amp
id|hi-&gt;sbp2_request_packet_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|hi-&gt;sbp2_req_free
)paren
)paren
(brace
id|lh
op_assign
id|hi-&gt;sbp2_req_free.next
suffix:semicolon
id|list_del
c_func
(paren
id|lh
)paren
suffix:semicolon
id|request_packet
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|sbp2_request_packet
comma
id|list
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Free the hpsb packets that we allocated for the pool&n;&t;&t; */
r_if
c_cond
(paren
id|request_packet
)paren
(brace
id|free_hpsb_packet
c_func
(paren
id|request_packet-&gt;packet
)paren
suffix:semicolon
)brace
)brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|hi-&gt;sbp2_request_packet_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called to retrieve a block write packet from our packet pool. This function is&n; * used in place of calling alloc_hpsb_packet (which costs us three kmallocs). Instead we &n; * just pull out a free request packet and re-initialize values in it. I&squot;m sure this can still&n; * stand some more optimization. &n; */
DECL|function|sbp2util_allocate_write_request_packet
r_static
r_struct
id|sbp2_request_packet
op_star
id|sbp2util_allocate_write_request_packet
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
id|nodeid_t
id|node
comma
id|u64
id|addr
comma
r_int
id|data_size
comma
id|quadlet_t
id|data
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|sbp2_request_packet
op_star
id|request_packet
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|hpsb_packet
op_star
id|packet
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|sbp2_spin_lock
c_func
(paren
op_amp
id|hi-&gt;sbp2_request_packet_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|hi-&gt;sbp2_req_free
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Pull out a free request packet&n;&t;&t; */
id|lh
op_assign
id|hi-&gt;sbp2_req_free.next
suffix:semicolon
id|list_del
c_func
(paren
id|lh
)paren
suffix:semicolon
id|request_packet
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|sbp2_request_packet
comma
id|list
)paren
suffix:semicolon
id|packet
op_assign
id|request_packet-&gt;packet
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Initialize the packet (this is really initialization the core 1394 stack should do,&n;&t;&t; * but I&squot;m doing it myself to avoid the overhead).&n;&t;&t; */
id|packet-&gt;data_size
op_assign
id|data_size
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|packet-&gt;list
)paren
suffix:semicolon
id|sema_init
c_func
(paren
op_amp
id|packet-&gt;state_change
comma
l_int|0
)paren
suffix:semicolon
id|packet-&gt;state
op_assign
id|unused
suffix:semicolon
id|packet-&gt;generation
op_assign
id|get_hpsb_generation
c_func
(paren
id|hi-&gt;host
)paren
suffix:semicolon
id|packet-&gt;data_be
op_assign
l_int|1
suffix:semicolon
id|packet-&gt;host
op_assign
id|hi-&gt;host
suffix:semicolon
id|packet-&gt;tlabel
op_assign
id|get_tlabel
c_func
(paren
id|hi-&gt;host
comma
id|node
comma
l_int|1
)paren
suffix:semicolon
id|packet-&gt;node_id
op_assign
id|node
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data_size
)paren
(brace
id|fill_async_writequad
c_func
(paren
id|packet
comma
id|addr
comma
id|data
)paren
suffix:semicolon
)brace
r_else
(brace
id|fill_async_writeblock
c_func
(paren
id|packet
comma
id|addr
comma
id|data_size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Set up a task queue completion routine, which returns the packet to the free list&n;&t;&t; * and releases the tlabel&n;&t;&t; */
id|request_packet-&gt;tq.routine
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_void
op_star
)paren
)paren
id|sbp2util_free_request_packet
suffix:semicolon
id|request_packet-&gt;tq.data
op_assign
id|request_packet
suffix:semicolon
id|request_packet-&gt;hi_context
op_assign
id|hi
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|request_packet-&gt;tq
comma
op_amp
id|packet-&gt;complete_tq
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Now, put the packet on the in-use list&n;&t;&t; */
id|list_add_tail
c_func
(paren
op_amp
id|request_packet-&gt;list
comma
op_amp
id|hi-&gt;sbp2_req_inuse
)paren
suffix:semicolon
)brace
r_else
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: sbp2util_allocate_request_packet - no packets available!&quot;
)paren
suffix:semicolon
)brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|hi-&gt;sbp2_request_packet_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|request_packet
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called to return a packet to our packet pool. It is also called as a &n; * completion routine when a request packet is completed.&n; */
DECL|function|sbp2util_free_request_packet
r_static
r_void
id|sbp2util_free_request_packet
c_func
(paren
r_struct
id|sbp2_request_packet
op_star
id|request_packet
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sbp2scsi_host_info
op_star
id|hi
op_assign
id|request_packet-&gt;hi_context
suffix:semicolon
multiline_comment|/*&n;&t; * Free the tlabel, and return the packet to the free pool&n;&t; */
id|sbp2_spin_lock
c_func
(paren
op_amp
id|hi-&gt;sbp2_request_packet_lock
comma
id|flags
)paren
suffix:semicolon
id|free_tlabel
c_func
(paren
id|hi-&gt;host
comma
id|LOCAL_BUS
op_or
id|request_packet-&gt;packet-&gt;node_id
comma
id|request_packet-&gt;packet-&gt;tlabel
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|request_packet-&gt;list
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|request_packet-&gt;list
comma
op_amp
id|hi-&gt;sbp2_req_free
)paren
suffix:semicolon
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|hi-&gt;sbp2_request_packet_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called to create a pool of command orbs used for command processing. It is called&n; * when a new sbp2 device is detected.&n; */
DECL|function|sbp2util_create_command_orb_pool
r_static
r_int
id|sbp2util_create_command_orb_pool
c_func
(paren
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
r_struct
id|sbp2scsi_host_info
op_star
id|hi
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sbp2_command_info
op_star
id|command
suffix:semicolon
id|sbp2_spin_lock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|scsi_id-&gt;sbp2_total_command_orbs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|command
op_assign
(paren
r_struct
id|sbp2_command_info
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sbp2_command_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|command
)paren
(brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|command
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
r_struct
id|sbp2_command_info
)paren
)paren
suffix:semicolon
id|command-&gt;command_orb_dma
op_assign
id|pci_map_single
(paren
id|hi-&gt;host-&gt;pdev
comma
op_amp
id|command-&gt;command_orb
comma
r_sizeof
(paren
r_struct
id|sbp2_command_orb
)paren
comma
id|PCI_DMA_BIDIRECTIONAL
)paren
suffix:semicolon
id|SBP2_DMA_ALLOC
c_func
(paren
l_string|&quot;single command orb DMA&quot;
)paren
suffix:semicolon
id|command-&gt;sge_dma
op_assign
id|pci_map_single
(paren
id|hi-&gt;host-&gt;pdev
comma
op_amp
id|command-&gt;scatter_gather_element
comma
r_sizeof
(paren
id|command-&gt;scatter_gather_element
)paren
comma
id|PCI_DMA_BIDIRECTIONAL
)paren
suffix:semicolon
id|SBP2_DMA_ALLOC
c_func
(paren
l_string|&quot;scatter_gather_element&quot;
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|command-&gt;list
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|command-&gt;list
comma
op_amp
id|scsi_id-&gt;sbp2_command_orb_completed
)paren
suffix:semicolon
)brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called to delete a pool of command orbs.&n; */
DECL|function|sbp2util_remove_command_orb_pool
r_static
r_void
id|sbp2util_remove_command_orb_pool
c_func
(paren
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
r_struct
id|sbp2scsi_host_info
op_star
id|hi
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|sbp2_command_info
op_star
id|command
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|sbp2_spin_lock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_completed
)paren
)paren
(brace
id|list_for_each
c_func
(paren
id|lh
comma
op_amp
id|scsi_id-&gt;sbp2_command_orb_completed
)paren
(brace
id|command
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|sbp2_command_info
comma
id|list
)paren
suffix:semicolon
multiline_comment|/* Release our generic DMA&squot;s */
id|pci_unmap_single
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
id|command-&gt;command_orb_dma
comma
r_sizeof
(paren
r_struct
id|sbp2_command_orb
)paren
comma
id|PCI_DMA_BIDIRECTIONAL
)paren
suffix:semicolon
id|SBP2_DMA_FREE
c_func
(paren
l_string|&quot;single command orb DMA&quot;
)paren
suffix:semicolon
id|pci_unmap_single
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
id|command-&gt;sge_dma
comma
r_sizeof
(paren
id|command-&gt;scatter_gather_element
)paren
comma
id|PCI_DMA_BIDIRECTIONAL
)paren
suffix:semicolon
id|SBP2_DMA_FREE
c_func
(paren
l_string|&quot;scatter_gather_element&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|command
)paren
suffix:semicolon
)brace
)brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* &n; * This functions finds the sbp2_command for a given outstanding&n; * command orb. Only looks at the inuse list.&n; */
DECL|function|sbp2util_find_command_for_orb
r_static
r_struct
id|sbp2_command_info
op_star
id|sbp2util_find_command_for_orb
c_func
(paren
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
id|dma_addr_t
id|orb
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|sbp2_command_info
op_star
id|command
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|sbp2_spin_lock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_inuse
)paren
)paren
(brace
id|list_for_each
c_func
(paren
id|lh
comma
op_amp
id|scsi_id-&gt;sbp2_command_orb_inuse
)paren
(brace
id|command
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|sbp2_command_info
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|command-&gt;command_orb_dma
op_eq
id|orb
)paren
(brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
r_return
(paren
id|command
)paren
suffix:semicolon
)brace
)brace
)brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
id|SBP2_ORB_DEBUG
c_func
(paren
l_string|&quot;could not match command orb %x&quot;
comma
(paren
r_int
r_int
)paren
id|orb
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* &n; * This functions finds the sbp2_command for a given outstanding SCpnt. Only looks at the inuse list &n; */
DECL|function|sbp2util_find_command_for_SCpnt
r_static
r_struct
id|sbp2_command_info
op_star
id|sbp2util_find_command_for_SCpnt
c_func
(paren
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
r_void
op_star
id|SCpnt
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|sbp2_command_info
op_star
id|command
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|sbp2_spin_lock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_inuse
)paren
)paren
(brace
id|list_for_each
c_func
(paren
id|lh
comma
op_amp
id|scsi_id-&gt;sbp2_command_orb_inuse
)paren
(brace
id|command
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|sbp2_command_info
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|command-&gt;Current_SCpnt
op_eq
id|SCpnt
)paren
(brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
r_return
(paren
id|command
)paren
suffix:semicolon
)brace
)brace
)brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * This function allocates a command orb used to send a scsi command.&n; */
DECL|function|sbp2util_allocate_command_orb
r_static
r_struct
id|sbp2_command_info
op_star
id|sbp2util_allocate_command_orb
c_func
(paren
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
id|Scsi_Cmnd
op_star
id|Current_SCpnt
comma
r_void
(paren
op_star
id|Current_done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
comma
r_struct
id|sbp2scsi_host_info
op_star
id|hi
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|sbp2_command_info
op_star
id|command
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|sbp2_spin_lock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_completed
)paren
)paren
(brace
id|lh
op_assign
id|scsi_id-&gt;sbp2_command_orb_completed.next
suffix:semicolon
id|list_del
c_func
(paren
id|lh
)paren
suffix:semicolon
id|command
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|sbp2_command_info
comma
id|list
)paren
suffix:semicolon
id|command-&gt;Current_done
op_assign
id|Current_done
suffix:semicolon
id|command-&gt;Current_SCpnt
op_assign
id|Current_SCpnt
suffix:semicolon
id|command-&gt;linked
op_assign
l_int|0
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|command-&gt;list
comma
op_amp
id|scsi_id-&gt;sbp2_command_orb_inuse
)paren
suffix:semicolon
)brace
r_else
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: sbp2util_allocate_command_orb - No orbs available!&quot;
)paren
suffix:semicolon
)brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
r_return
(paren
id|command
)paren
suffix:semicolon
)brace
multiline_comment|/* Free our DMA&squot;s */
DECL|function|sbp2util_free_command_dma
r_static
r_void
id|sbp2util_free_command_dma
c_func
(paren
r_struct
id|sbp2_command_info
op_star
id|command
)paren
(brace
r_struct
id|sbp2scsi_host_info
op_star
id|hi
suffix:semicolon
id|hi
op_assign
(paren
r_struct
id|sbp2scsi_host_info
op_star
)paren
id|command-&gt;Current_SCpnt-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hi
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|__FUNCTION__
l_string|&quot;: hi == NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|command-&gt;cmd_dma
)paren
(brace
id|pci_unmap_single
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
id|command-&gt;cmd_dma
comma
id|command-&gt;dma_size
comma
id|command-&gt;dma_dir
)paren
suffix:semicolon
id|SBP2_DMA_FREE
c_func
(paren
l_string|&quot;single bulk&quot;
)paren
suffix:semicolon
id|command-&gt;cmd_dma
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|command-&gt;sge_buffer
)paren
(brace
id|pci_unmap_sg
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
id|command-&gt;sge_buffer
comma
id|command-&gt;dma_size
comma
id|command-&gt;dma_dir
)paren
suffix:semicolon
id|SBP2_DMA_FREE
c_func
(paren
l_string|&quot;scatter list&quot;
)paren
suffix:semicolon
id|command-&gt;sge_buffer
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This function moves a command to the completed orb list.&n; */
DECL|function|sbp2util_mark_command_completed
r_static
r_void
id|sbp2util_mark_command_completed
c_func
(paren
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
r_struct
id|sbp2_command_info
op_star
id|command
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|sbp2_spin_lock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|command-&gt;list
)paren
suffix:semicolon
id|sbp2util_free_command_dma
c_func
(paren
id|command
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|command-&gt;list
comma
op_amp
id|scsi_id-&gt;sbp2_command_orb_completed
)paren
suffix:semicolon
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*********************************************&n; * IEEE-1394 core driver stack related section&n; *********************************************/
multiline_comment|/*&n; * This function is called at SCSI init in order to register our driver with the&n; * IEEE-1394 stack&n; */
DECL|function|sbp2_init
r_int
id|sbp2_init
c_func
(paren
r_void
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_init&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Register our high level driver with 1394 stack&n;&t; */
id|sbp2_hl_handle
op_assign
id|hpsb_register_highlevel
c_func
(paren
id|SBP2_DEVICE_NAME
comma
op_amp
id|sbp2_hl_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbp2_hl_handle
op_eq
l_int|NULL
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: sbp2 failed to register with ieee1394 highlevel&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Register our sbp2 status address space...&n;&t; */
id|hpsb_register_addrspace
c_func
(paren
id|sbp2_hl_handle
comma
op_amp
id|sbp2_ops
comma
id|SBP2_STATUS_FIFO_ADDRESS
comma
id|SBP2_STATUS_FIFO_ADDRESS
op_plus
r_sizeof
(paren
r_struct
id|sbp2_status_block
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Register physical dma address space... used for&n;&t; * adapters not supporting hardware phys dma.&n;&t; *&n;&t; * XXX: Disabled for now.&n;&t; */
multiline_comment|/* hpsb_register_addrspace(sbp2_hl_handle, &amp;sbp2_physdma_ops,&n;&t;&t;&t;&t;   0x0ULL, 0xfffffffcULL); */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called from cleanup module, or during shut-down, in order to &n; * unregister our driver&n; */
DECL|function|sbp2_cleanup
r_void
id|sbp2_cleanup
c_func
(paren
r_void
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_cleanup&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbp2_hl_handle
)paren
(brace
id|hpsb_unregister_highlevel
c_func
(paren
id|sbp2_hl_handle
)paren
suffix:semicolon
id|sbp2_hl_handle
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called after registering our operations in sbp2_init. We go ahead and&n; * allocate some memory for our host info structure, and init some structures.&n; */
DECL|function|sbp2_add_host
r_static
r_void
id|sbp2_add_host
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
(brace
r_struct
id|sbp2scsi_host_info
op_star
id|hi
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_add_host&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate some memory for our host info structure&n;&t; */
id|hi
op_assign
(paren
r_struct
id|sbp2scsi_host_info
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sbp2scsi_host_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hi
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * Initialize some host stuff&n;&t;&t; */
id|memset
c_func
(paren
id|hi
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sbp2scsi_host_info
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|hi-&gt;list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|hi-&gt;sbp2_req_inuse
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|hi-&gt;sbp2_req_free
)paren
suffix:semicolon
id|hi-&gt;host
op_assign
id|host
suffix:semicolon
id|hi-&gt;sbp2_command_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|hi-&gt;sbp2_request_packet_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Create our request packet pool (pool of packets for use in I/O)&n;&t;&t; */
r_if
c_cond
(paren
id|sbp2util_create_request_packet_pool
c_func
(paren
id|hi
)paren
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: sbp2util_create_request_packet_pool failed!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sbp2_spin_lock
c_func
(paren
op_amp
id|sbp2_host_info_lock
comma
id|flags
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|hi-&gt;list
comma
op_amp
id|sbp2_host_info_list
)paren
suffix:semicolon
id|sbp2_host_count
op_increment
suffix:semicolon
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|sbp2_host_info_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Initialize us to bus reset in progress&n;&t;&t; */
id|hi-&gt;bus_reset_in_progress
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Register our host with the SCSI stack. &n;&t;&t; */
id|sbp2scsi_register_scsi_host
c_func
(paren
id|hi
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Start our kernel thread to deal with sbp2 device detection&n;&t;&t; */
id|init_waitqueue_head
c_func
(paren
op_amp
id|hi-&gt;sbp2_detection_wait
)paren
suffix:semicolon
id|hi-&gt;sbp2_detection_pid
op_assign
l_int|0
suffix:semicolon
id|hi-&gt;sbp2_detection_pid
op_assign
id|kernel_thread
c_func
(paren
id|sbp2_detection_thread
comma
id|hi
comma
id|CLONE_FS
op_or
id|CLONE_FILES
op_or
id|CLONE_SIGHAND
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This fuction returns a host info structure from the host structure,&n; * in case we have multiple hosts&n; */
DECL|function|sbp2_find_host_info
r_static
r_struct
id|sbp2scsi_host_info
op_star
id|sbp2_find_host_info
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|sbp2scsi_host_info
op_star
id|hi
suffix:semicolon
id|list_for_each
(paren
id|lh
comma
op_amp
id|sbp2_host_info_list
)paren
(brace
id|hi
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|sbp2scsi_host_info
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hi-&gt;host
op_eq
id|host
)paren
(brace
r_return
id|hi
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called when the host is removed&n; */
DECL|function|sbp2_remove_host
r_static
r_void
id|sbp2_remove_host
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
(brace
r_struct
id|sbp2scsi_host_info
op_star
id|hi
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_remove_host&quot;
)paren
suffix:semicolon
id|sbp2_spin_lock
c_func
(paren
op_amp
id|sbp2_host_info_lock
comma
id|flags
)paren
suffix:semicolon
id|hi
op_assign
id|sbp2_find_host_info
c_func
(paren
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hi
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * Need to remove any attached SBP-2 devices. Also make sure to logout of all devices.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SBP2SCSI_MAX_SCSI_IDS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hi-&gt;scsi_id
(braket
id|i
)braket
)paren
(brace
id|sbp2_logout_device
c_func
(paren
id|hi
comma
id|hi-&gt;scsi_id
(braket
id|i
)braket
)paren
suffix:semicolon
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|validated
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|sbp2_remove_unvalidated_devices
c_func
(paren
id|hi
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|hi-&gt;list
)paren
suffix:semicolon
id|sbp2_host_count
op_decrement
suffix:semicolon
)brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|sbp2_host_info_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hi
op_eq
l_int|NULL
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: attempt to remove unknown host %p&quot;
comma
id|host
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Remove the packet pool (release the packets)&n;&t; */
id|sbp2util_remove_request_packet_pool
c_func
(paren
id|hi
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Kill our detection thread &n;&t; */
r_if
c_cond
(paren
id|hi-&gt;sbp2_detection_pid
op_ge
l_int|0
)paren
(brace
id|kill_proc
c_func
(paren
id|hi-&gt;sbp2_detection_pid
comma
id|SIGINT
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Give the detection thread a little time to exit&n;&t; */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
)paren
suffix:semicolon
multiline_comment|/* 1 second delay */
id|kfree
c_func
(paren
id|hi
)paren
suffix:semicolon
id|hi
op_assign
l_int|NULL
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This is our sbp2 detection thread. It is signalled when bus resets occur&n; * so that we can find and initialize any sbp2 devices. &n; */
DECL|function|sbp2_detection_thread
r_static
r_int
id|sbp2_detection_thread
c_func
(paren
r_void
op_star
id|__hi
)paren
(brace
r_struct
id|sbp2scsi_host_info
op_star
id|hi
op_assign
(paren
r_struct
id|sbp2scsi_host_info
op_star
)paren
id|__hi
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_detection_thread&quot;
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This thread doesn&squot;t need any user-level access,&n;&t; * so get rid of all our resources&n;&t; */
macro_line|#if LINUX_VERSION_CODE &gt; 0x20300
id|daemonize
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t; * Set-up a nice name&n;&t; */
id|strcpy
c_func
(paren
id|current-&gt;comm
comma
id|SBP2_DEVICE_NAME
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
op_logical_neg
id|signal_pending
c_func
(paren
id|current
)paren
)paren
op_logical_and
id|hi
)paren
(brace
multiline_comment|/*&n;&t;&t; * Process our bus reset now&n;&t;&t; */
r_if
c_cond
(paren
id|hi
)paren
(brace
id|MOD_INC_USE_COUNT
suffix:semicolon
id|sbp2_bus_reset_handler
c_func
(paren
id|hi
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Sleep until next bus reset&n;&t;&t; */
r_if
c_cond
(paren
id|hi
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|hi-&gt;sbp2_detection_wait
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is where we first pull the node unique ids, and then allocate memory and register&n; * a SBP-2 device&n; */
DECL|function|sbp2_start_device
r_static
r_int
id|sbp2_start_device
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_int
id|node_id
)paren
(brace
id|u64
id|node_unique_id
suffix:semicolon
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|node_entry
op_star
id|ne
suffix:semicolon
r_int
id|i
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_start_device&quot;
)paren
suffix:semicolon
multiline_comment|/* XXX: This will go away once we start using the nodemgr&squot;s&n;&t; * feature subscription API.  */
id|ne
op_assign
id|hpsb_nodeid_get_entry
c_func
(paren
id|node_id
op_or
(paren
id|hi-&gt;host-&gt;node_id
op_amp
id|BUS_MASK
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ne
)paren
(brace
id|HPSB_ERR
c_func
(paren
l_string|&quot;sbp2: Could not find device node&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|node_unique_id
op_assign
id|ne-&gt;guid
suffix:semicolon
multiline_comment|/*&n;&t; * First, we need to find out whether this is a &quot;new&quot; SBP-2 device plugged in, or one that already&n;&t; * exists and is initialized. We do this by looping through our scsi id instance data structures&n;&t; * looking for matching node unique ids.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SBP2SCSI_MAX_SCSI_IDS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hi-&gt;scsi_id
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|node_unique_id
op_eq
id|node_unique_id
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Update our node id&n;&t;&t;&t;&t; */
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|node_id
op_assign
id|node_id
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Mark the device as validated, since it still exists on the bus&n;&t;&t;&t;&t; */
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|validated
op_assign
l_int|1
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: SBP-2 device re-validated, SCSI ID = %x&quot;
comma
(paren
r_int
r_int
)paren
id|i
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Reconnect to the sbp-2 device&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|sbp2_reconnect_device
c_func
(paren
id|hi
comma
id|hi-&gt;scsi_id
(braket
id|i
)braket
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Ok, reconnect has failed. Perhaps we didn&squot;t reconnect fast enough. Try&n;&t;&t;&t;&t;&t; * doing a regular login.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|sbp2_login_device
c_func
(paren
id|hi
comma
id|hi-&gt;scsi_id
(braket
id|i
)braket
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Login failed too... so, just mark him as unvalidated, so that he gets cleaned up&n;&t;&t;&t;&t;&t;&t; * later&n;&t;&t;&t;&t;&t;&t; */
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: sbp2_reconnect_device failed!&quot;
)paren
suffix:semicolon
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|validated
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|validated
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Set max retries to something large on the device&n;&t;&t;&t;&t;&t; */
id|sbp2_set_busy_timeout
c_func
(paren
id|hi
comma
id|hi-&gt;scsi_id
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Do a SBP-2 fetch agent reset&n;&t;&t;&t;&t;&t; */
id|sbp2_agent_reset
c_func
(paren
id|hi
comma
id|hi-&gt;scsi_id
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Get the max speed and packet size that we can use&n;&t;&t;&t;&t;&t; */
id|sbp2_max_speed_and_size
c_func
(paren
id|hi
comma
id|hi-&gt;scsi_id
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Nothing more to do, since we found the device&n;&t;&t;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * This really is a &quot;new&quot; device plugged in. Let&squot;s allocate memory for our scsi id instance data&n;&t; */
id|scsi_id
op_assign
(paren
r_struct
id|scsi_id_instance_data
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|scsi_id_instance_data
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_id
)paren
r_goto
id|alloc_fail_first
suffix:semicolon
id|memset
c_func
(paren
id|scsi_id
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|scsi_id_instance_data
)paren
)paren
suffix:semicolon
multiline_comment|/* Login FIFO DMA */
id|scsi_id-&gt;login_response
op_assign
id|pci_alloc_consistent
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|sbp2_login_response
)paren
comma
op_amp
id|scsi_id-&gt;login_response_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_id-&gt;login_response
)paren
r_goto
id|alloc_fail
suffix:semicolon
id|SBP2_DMA_ALLOC
c_func
(paren
l_string|&quot;consistent DMA region for login FIFO&quot;
)paren
suffix:semicolon
multiline_comment|/* Reconnect ORB DMA */
id|scsi_id-&gt;reconnect_orb
op_assign
id|pci_alloc_consistent
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|sbp2_reconnect_orb
)paren
comma
op_amp
id|scsi_id-&gt;reconnect_orb_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_id-&gt;reconnect_orb
)paren
r_goto
id|alloc_fail
suffix:semicolon
id|SBP2_DMA_ALLOC
c_func
(paren
l_string|&quot;consistent DMA region for reconnect ORB&quot;
)paren
suffix:semicolon
multiline_comment|/* Logout ORB DMA */
id|scsi_id-&gt;logout_orb
op_assign
id|pci_alloc_consistent
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|sbp2_logout_orb
)paren
comma
op_amp
id|scsi_id-&gt;logout_orb_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_id-&gt;logout_orb
)paren
r_goto
id|alloc_fail
suffix:semicolon
id|SBP2_DMA_ALLOC
c_func
(paren
l_string|&quot;consistent DMA region for logout ORB&quot;
)paren
suffix:semicolon
multiline_comment|/* Login ORB DMA */
id|scsi_id-&gt;login_orb
op_assign
id|pci_alloc_consistent
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|sbp2_login_orb
)paren
comma
op_amp
id|scsi_id-&gt;login_orb_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_id-&gt;login_orb
op_eq
l_int|NULL
)paren
(brace
id|alloc_fail
suffix:colon
r_if
c_cond
(paren
id|scsi_id-&gt;logout_orb
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|sbp2_logout_orb
)paren
comma
id|scsi_id-&gt;logout_orb
comma
id|scsi_id-&gt;logout_orb_dma
)paren
suffix:semicolon
id|SBP2_DMA_FREE
c_func
(paren
l_string|&quot;logout ORB DMA&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scsi_id-&gt;reconnect_orb
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|sbp2_reconnect_orb
)paren
comma
id|scsi_id-&gt;reconnect_orb
comma
id|scsi_id-&gt;reconnect_orb_dma
)paren
suffix:semicolon
id|SBP2_DMA_FREE
c_func
(paren
l_string|&quot;reconnect ORB DMA&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scsi_id-&gt;login_response
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|sbp2_login_response
)paren
comma
id|scsi_id-&gt;login_response
comma
id|scsi_id-&gt;login_response_dma
)paren
suffix:semicolon
id|SBP2_DMA_FREE
c_func
(paren
l_string|&quot;login FIFO DMA&quot;
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|scsi_id
)paren
suffix:semicolon
id|alloc_fail_first
suffix:colon
id|SBP2_ERR
(paren
l_string|&quot;sbp2: Could not allocate memory for scsi_id&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|SBP2_DMA_ALLOC
c_func
(paren
l_string|&quot;consistent DMA region for login ORB&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize some of the fields in this structure&n;&t; */
id|scsi_id-&gt;node_id
op_assign
id|node_id
suffix:semicolon
id|scsi_id-&gt;node_unique_id
op_assign
id|node_unique_id
suffix:semicolon
id|scsi_id-&gt;validated
op_assign
l_int|1
suffix:semicolon
id|scsi_id-&gt;speed_code
op_assign
id|SPEED_100
suffix:semicolon
id|scsi_id-&gt;max_payload_size
op_assign
id|MAX_PAYLOAD_S100
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_login_wait
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Initialize structures needed for the command orb pool.&n;&t; */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_inuse
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_completed
)paren
suffix:semicolon
id|scsi_id-&gt;sbp2_command_orb_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|scsi_id-&gt;sbp2_total_command_orbs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure that we&squot;ve gotten ahold of the sbp2 management agent address. Also figure out the&n;&t; * command set being used (SCSI or RBC).&n;&t; */
r_if
c_cond
(paren
id|sbp2_parse_unit_directory
c_func
(paren
id|hi
comma
id|scsi_id
)paren
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: Error while parsing sbp2 unit directory&quot;
)paren
suffix:semicolon
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|validated
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|scsi_id-&gt;sbp2_total_command_orbs
op_assign
id|SBP2_MAX_COMMAND_ORBS
suffix:semicolon
multiline_comment|/* &n;&t; * Knock the total command orbs down if we are serializing I/O&n;&t; */
r_if
c_cond
(paren
id|serialize_io
)paren
(brace
id|scsi_id-&gt;sbp2_total_command_orbs
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* one extra for good measure */
)brace
multiline_comment|/*&n;&t; * Allocate some extra command orb structures for devices with 128KB limit&n;&t; */
r_if
c_cond
(paren
id|scsi_id-&gt;sbp2_firmware_revision
op_eq
id|SBP2_128KB_BROKEN_FIRMWARE
)paren
(brace
id|scsi_id-&gt;sbp2_total_command_orbs
op_mul_assign
l_int|4
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Create our command orb pool&n;&t; */
r_if
c_cond
(paren
id|sbp2util_create_command_orb_pool
c_func
(paren
id|scsi_id
comma
id|hi
)paren
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: sbp2util_create_command_orb_pool failed!&quot;
)paren
suffix:semicolon
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|validated
op_assign
l_int|0
suffix:semicolon
r_return
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Find an empty spot to stick our scsi id instance data. &n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SBP2SCSI_MAX_SCSI_IDS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hi-&gt;scsi_id
(braket
id|i
)braket
)paren
(brace
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_assign
id|scsi_id
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: New SBP-2 device inserted, SCSI ID = %x&quot;
comma
(paren
r_int
r_int
)paren
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Make sure we are not out of space&n;&t; */
r_if
c_cond
(paren
id|i
op_ge
id|SBP2SCSI_MAX_SCSI_IDS
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: No slots left for SBP-2 device&quot;
)paren
suffix:semicolon
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|validated
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Login to the sbp-2 device&n;&t; */
r_if
c_cond
(paren
id|sbp2_login_device
c_func
(paren
id|hi
comma
id|hi-&gt;scsi_id
(braket
id|i
)braket
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Login failed... so, just mark him as unvalidated, so that he gets cleaned up later&n;&t;&t; */
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: sbp2_login_device failed&quot;
)paren
suffix:semicolon
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|validated
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|validated
)paren
(brace
multiline_comment|/*&n;&t;&t; * Set max retries to something large on the device&n;&t;&t; */
id|sbp2_set_busy_timeout
c_func
(paren
id|hi
comma
id|hi-&gt;scsi_id
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Do a SBP-2 fetch agent reset&n;&t;&t; */
id|sbp2_agent_reset
c_func
(paren
id|hi
comma
id|hi-&gt;scsi_id
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Get the max speed and packet size that we can use&n;&t;&t; */
id|sbp2_max_speed_and_size
c_func
(paren
id|hi
comma
id|hi-&gt;scsi_id
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function tries to determine if a device is a valid SBP-2 device&n; */
DECL|function|sbp2_check_device
r_static
r_int
id|sbp2_check_device
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_int
id|node_id
)paren
(brace
id|quadlet_t
id|unit_spec_id_data
op_assign
l_int|0
comma
id|unit_sw_ver_data
op_assign
l_int|0
suffix:semicolon
id|quadlet_t
id|unit_directory_length
comma
id|current_quadlet
suffix:semicolon
id|u64
id|unit_directory_addr
comma
id|current_addr
suffix:semicolon
r_int
r_int
id|i
comma
id|length
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_check_device&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Let&squot;s try and read the unit spec id and unit sw ver to determine if this is an SBP2 device...&n;&t; */
r_if
c_cond
(paren
id|sbp2util_unit_directory
c_func
(paren
id|hi
comma
id|LOCAL_BUS
op_or
id|node_id
comma
op_amp
id|unit_directory_addr
)paren
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: Error reading unit directory address - bad status&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Read the size of the unit directory&n;&t; */
r_if
c_cond
(paren
id|sbp2util_read_quadlet
c_func
(paren
id|hi
comma
id|LOCAL_BUS
op_or
id|node_id
comma
id|unit_directory_addr
comma
op_amp
id|unit_directory_length
)paren
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: Error reading root directory length - bad status&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|current_addr
op_assign
id|unit_directory_addr
suffix:semicolon
id|length
op_assign
id|be32_to_cpu
c_func
(paren
id|unit_directory_length
)paren
op_rshift
l_int|16
suffix:semicolon
multiline_comment|/*&n;&t; * Now, step through the unit directory and look for the unit_spec_ID and the unit_sw_version&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|length
suffix:semicolon
id|i
op_increment
)paren
(brace
id|current_addr
op_add_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|sbp2util_read_quadlet
c_func
(paren
id|hi
comma
id|LOCAL_BUS
op_or
id|node_id
comma
id|current_addr
comma
op_amp
id|current_quadlet
)paren
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: Error reading at address 0x%08x%08x - bad status&quot;
comma
(paren
r_int
r_int
)paren
(paren
(paren
id|current_addr
)paren
op_rshift
l_int|32
)paren
comma
(paren
r_int
r_int
)paren
(paren
(paren
id|current_addr
)paren
op_amp
l_int|0xffffffff
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * Check for unit_spec_ID tag &n;&t;&t; */
r_if
c_cond
(paren
(paren
id|be32_to_cpu
c_func
(paren
id|current_quadlet
)paren
op_rshift
l_int|24
)paren
op_eq
id|SBP2_UNIT_SPEC_ID_KEY
)paren
(brace
id|unit_spec_id_data
op_assign
id|current_quadlet
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: Node %x, unit spec id = %x&quot;
comma
(paren
id|LOCAL_BUS
op_or
id|node_id
)paren
comma
(paren
r_int
r_int
)paren
id|be32_to_cpu
c_func
(paren
id|unit_spec_id_data
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * Check for unit_sw_version tag &n;&t;&t; */
r_if
c_cond
(paren
(paren
id|be32_to_cpu
c_func
(paren
id|current_quadlet
)paren
op_rshift
l_int|24
)paren
op_eq
id|SBP2_UNIT_SW_VERSION_KEY
)paren
(brace
id|unit_sw_ver_data
op_assign
id|current_quadlet
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: Node %x, unit sw version = %x&quot;
comma
(paren
id|LOCAL_BUS
op_or
id|node_id
)paren
comma
(paren
r_int
r_int
)paren
id|be32_to_cpu
c_func
(paren
id|unit_sw_ver_data
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Validate unit spec id and unit sw ver to see if this is an SBP-2 device&n;&t; */
r_if
c_cond
(paren
(paren
id|be32_to_cpu
c_func
(paren
id|unit_spec_id_data
)paren
op_ne
id|SBP2_UNIT_SPEC_ID_ENTRY
)paren
op_logical_or
(paren
id|be32_to_cpu
c_func
(paren
id|unit_sw_ver_data
)paren
op_ne
id|SBP2_SW_VERSION_ENTRY
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Not an sbp2 device&n;&t;&t; */
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This device is a valid SBP-2 device&n;&t; */
id|SBP2_INFO
c_func
(paren
l_string|&quot;sbp2: Node 0x%04x, Found SBP-2 device&quot;
comma
(paren
id|LOCAL_BUS
op_or
id|node_id
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function removes (cleans-up after) any unvalidated sbp2 devices&n; */
DECL|function|sbp2_remove_unvalidated_devices
r_static
r_void
id|sbp2_remove_unvalidated_devices
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Loop through and free any unvalidated scsi id instance data structures&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SBP2SCSI_MAX_SCSI_IDS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hi-&gt;scsi_id
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|validated
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Complete any pending commands with selection timeout&n;&t;&t;&t;&t; */
id|sbp2scsi_complete_all_commands
c_func
(paren
id|hi
comma
id|hi-&gt;scsi_id
(braket
id|i
)braket
comma
id|DID_NO_CONNECT
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Clean up any other structures&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|sbp2_total_command_orbs
)paren
(brace
id|sbp2util_remove_command_orb_pool
c_func
(paren
id|hi-&gt;scsi_id
(braket
id|i
)braket
comma
id|hi
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|login_response
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|sbp2_login_response
)paren
comma
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|login_response
comma
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|login_response_dma
)paren
suffix:semicolon
id|SBP2_DMA_FREE
c_func
(paren
l_string|&quot;single login FIFO&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|login_orb
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|sbp2_login_orb
)paren
comma
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|login_orb
comma
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|login_orb_dma
)paren
suffix:semicolon
id|SBP2_DMA_FREE
c_func
(paren
l_string|&quot;single login ORB&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|reconnect_orb
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|sbp2_reconnect_orb
)paren
comma
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|reconnect_orb
comma
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|reconnect_orb_dma
)paren
suffix:semicolon
id|SBP2_DMA_FREE
c_func
(paren
l_string|&quot;single reconnect orb&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|logout_orb
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|sbp2_logout_orb
)paren
comma
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|logout_orb
comma
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|reconnect_orb_dma
)paren
suffix:semicolon
id|SBP2_DMA_FREE
c_func
(paren
l_string|&quot;single logout orb&quot;
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|hi-&gt;scsi_id
(braket
id|i
)braket
)paren
suffix:semicolon
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: Unvalidated SBP-2 device removed, SCSI ID = %x&quot;
comma
(paren
r_int
r_int
)paren
id|i
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is our reset handler. It is run out of a thread, since we get &n; * notified of a bus reset from a bh (or interrupt).&n; */
DECL|function|sbp2_bus_reset_handler
r_static
r_void
id|sbp2_bus_reset_handler
c_func
(paren
r_void
op_star
id|context
)paren
(brace
r_struct
id|sbp2scsi_host_info
op_star
id|hi
op_assign
id|context
suffix:semicolon
id|quadlet_t
id|signature_data
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_bus_reset_handler&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * TODO. Check and keep track of generation number of all requests, in case a&n;&t; * bus reset occurs while trying to find and login to SBP-2 devices.&n;&t; */
multiline_comment|/*&n;&t; * First thing to do. Invalidate all SBP-2 devices. This is needed so that&n;&t; * we stop sending down I/O requests to the device, and also so that we can&n;&t; * figure out which devices have disappeared after a bus reset.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SBP2SCSI_MAX_SCSI_IDS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hi-&gt;scsi_id
(braket
id|i
)braket
)paren
(brace
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|validated
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Give the sbp2 devices a little time to recover after the bus reset&n;&t; */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|2
)paren
suffix:semicolon
multiline_comment|/* 1/2 second delay */
multiline_comment|/*&n;&t; * Spit out what we know from the host&n;&t; */
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;host: node_count = %x&quot;
comma
(paren
r_int
r_int
)paren
id|hi-&gt;host-&gt;node_count
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;host: selfid_count = %x&quot;
comma
(paren
r_int
r_int
)paren
id|hi-&gt;host-&gt;selfid_count
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;host: node_id = %x&quot;
comma
(paren
r_int
r_int
)paren
id|hi-&gt;host-&gt;node_id
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;host: irm_id = %x&quot;
comma
(paren
r_int
r_int
)paren
id|hi-&gt;host-&gt;irm_id
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;host: busmgr_id = %x&quot;
comma
(paren
r_int
r_int
)paren
id|hi-&gt;host-&gt;busmgr_id
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;host: is_root = %x&quot;
comma
(paren
r_int
r_int
)paren
id|hi-&gt;host-&gt;is_root
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;host: is_cycmst = %x&quot;
comma
(paren
r_int
r_int
)paren
id|hi-&gt;host-&gt;is_cycmst
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;host: is_irm = %x&quot;
comma
(paren
r_int
r_int
)paren
id|hi-&gt;host-&gt;is_irm
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;host: is_busmgr = %x&quot;
comma
(paren
r_int
r_int
)paren
id|hi-&gt;host-&gt;is_busmgr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Let&squot;s try and figure out which devices out there are SBP-2 devices! Loop through all &n;&t; * nodes out there.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hi-&gt;host-&gt;node_count
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Don&squot;t read from ourselves!&n;&t;&t; */
r_if
c_cond
(paren
id|i
op_ne
(paren
(paren
id|hi-&gt;host-&gt;node_id
)paren
op_amp
id|NODE_MASK
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Try and send a request for a config rom signature. This is expected to fail for&n;&t;&t;&t; * some nodes, as they might be repeater phys or not be initialized.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sbp2util_read_quadlet
c_func
(paren
id|hi
comma
id|LOCAL_BUS
op_or
id|i
comma
id|CONFIG_ROM_SIGNATURE_ADDRESS
comma
op_amp
id|signature_data
)paren
)paren
(brace
r_if
c_cond
(paren
id|be32_to_cpu
c_func
(paren
id|signature_data
)paren
op_eq
id|IEEE1394_CONFIG_ROM_SIGNATURE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Hey, we&squot;ve got a valid responding IEEE1394 node. Need to now see if it&squot;s an SBP-2 device&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sbp2_check_device
c_func
(paren
id|hi
comma
id|i
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Found an SBP-2 device. Now, actually start the device.&n;&t;&t;&t;&t;&t;&t; */
id|sbp2_start_device
c_func
(paren
id|hi
comma
id|i
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
multiline_comment|/*&n;&t; * This code needs protection&n;&t; */
id|sbp2_spin_lock
c_func
(paren
op_amp
id|hi-&gt;sbp2_command_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, we&squot;ve discovered and re-validated all SBP-2 devices out there. Let&squot;s remove structures of all&n;&t; * devices not re-validated (meaning they&squot;ve been removed).&n;&t; */
id|sbp2_remove_unvalidated_devices
c_func
(paren
id|hi
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Complete any pending commands with busy (so they get retried) and remove them from our queue&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SBP2SCSI_MAX_SCSI_IDS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hi-&gt;scsi_id
(braket
id|i
)braket
)paren
(brace
id|sbp2scsi_complete_all_commands
c_func
(paren
id|hi
comma
id|hi-&gt;scsi_id
(braket
id|i
)braket
comma
id|DID_BUS_BUSY
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Now, note that the bus reset is complete (finally!)&n;&t; */
id|hi-&gt;bus_reset_in_progress
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Deal with the initial scsi bus scan if needed (since we only now know if there are&n;&t; * any sbp2 devices attached)&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|no_bus_scan
op_logical_and
op_logical_neg
id|hi-&gt;initial_scsi_bus_scan_complete
op_logical_and
id|hi-&gt;bus_scan_SCpnt
)paren
(brace
id|hi-&gt;initial_scsi_bus_scan_complete
op_assign
l_int|1
suffix:semicolon
id|scsi_id
op_assign
id|hi-&gt;scsi_id
(braket
id|hi-&gt;bus_scan_SCpnt-&gt;target
)braket
suffix:semicolon
multiline_comment|/* &n;&t;&t; * If the sbp2 device exists, then let&squot;s now execute the command.&n;&t;&t; * If not, then just complete it as a selection time-out. &n;&t;&t; */
r_if
c_cond
(paren
id|scsi_id
)paren
(brace
r_if
c_cond
(paren
id|sbp2_send_command
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|hi-&gt;bus_scan_SCpnt
comma
id|hi-&gt;bus_scan_done
)paren
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: Error sending SCSI command&quot;
)paren
suffix:semicolon
id|sbp2scsi_complete_command
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|SBP2_SCSI_STATUS_SELECTION_TIMEOUT
comma
id|hi-&gt;bus_scan_SCpnt
comma
id|hi-&gt;bus_scan_done
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
op_assign
id|hi-&gt;bus_scan_done
suffix:semicolon
id|hi-&gt;bus_scan_SCpnt-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
id|done
(paren
id|hi-&gt;bus_scan_SCpnt
)paren
suffix:semicolon
)brace
)brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|hi-&gt;sbp2_command_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called from the host&squot;s bh when a bus reset is complete. We wake up our detection thread&n; * to deal with the reset&n; */
DECL|function|sbp2_host_reset
r_static
r_void
id|sbp2_host_reset
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sbp2scsi_host_info
op_star
id|hi
suffix:semicolon
r_int
id|i
suffix:semicolon
id|SBP2_INFO
c_func
(paren
l_string|&quot;sbp2: IEEE-1394 bus reset&quot;
)paren
suffix:semicolon
id|sbp2_spin_lock
c_func
(paren
op_amp
id|sbp2_host_info_lock
comma
id|flags
)paren
suffix:semicolon
id|hi
op_assign
id|sbp2_find_host_info
c_func
(paren
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hi
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * Wake up our detection thread, only if it&squot;s not already handling a reset&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|hi-&gt;bus_reset_in_progress
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * First thing to do. Invalidate all SBP-2 devices. This is needed so that&n;&t;&t;&t; * we stop sending down I/O requests to the device, and also so that we can&n;&t;&t;&t; * figure out which devices have disappeared after a bus reset.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SBP2SCSI_MAX_SCSI_IDS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hi-&gt;scsi_id
(braket
id|i
)braket
)paren
(brace
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|validated
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|hi-&gt;bus_reset_in_progress
op_assign
l_int|1
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|hi-&gt;sbp2_detection_wait
)paren
suffix:semicolon
)brace
)brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|sbp2_host_info_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* XXX: How best to handle these with DMA interface? */
macro_line|#if 0
multiline_comment|/*&n; * This function deals with physical dma write requests (for adapters that do not support&n; * physical dma in hardware).&n; */
r_static
r_int
id|sbp2_handle_physdma_write
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
comma
r_int
id|nodeid
comma
id|quadlet_t
op_star
id|data
comma
id|u64
id|addr
comma
r_int
r_int
id|length
)paren
(brace
multiline_comment|/*&n;&t; * Manually put the data in the right place.&n;&t; */
id|memcpy
c_func
(paren
id|bus_to_virt
c_func
(paren
(paren
id|u32
)paren
id|addr
)paren
comma
id|data
comma
id|length
)paren
suffix:semicolon
r_return
id|RCODE_COMPLETE
suffix:semicolon
)brace
multiline_comment|/*&n; * This function deals with physical dma read requests (for adapters that do not support&n; * physical dma in hardware).&n; */
r_static
r_int
id|sbp2_handle_physdma_read
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
comma
r_int
id|nodeid
comma
id|quadlet_t
op_star
id|data
comma
id|u64
id|addr
comma
r_int
r_int
id|length
)paren
(brace
multiline_comment|/*&n;&t; * Grab data from memory and send a read response.&n;&t; */
id|memcpy
c_func
(paren
id|data
comma
id|bus_to_virt
c_func
(paren
(paren
id|u32
)paren
id|addr
)paren
comma
id|length
)paren
suffix:semicolon
r_return
id|RCODE_COMPLETE
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**************************************&n; * SBP-2 protocol related section&n; **************************************/
multiline_comment|/*&n; * This function is called in order to login to a particular SBP-2 device, after a bus reset&n; */
DECL|function|sbp2_login_device
r_static
r_int
id|sbp2_login_device
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
)paren
(brace
id|quadlet_t
id|data
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_login_device&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_id-&gt;login_orb
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_login_device: login_orb not alloc&squot;d!&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set-up login ORB&n;&t; */
id|scsi_id-&gt;login_orb-&gt;password_hi
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Assume no password */
id|scsi_id-&gt;login_orb-&gt;password_lo
op_assign
l_int|0
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_login_device: password_hi/lo initialized&quot;
)paren
suffix:semicolon
macro_line|#ifdef SBP2_NEED_LOGIN_DESCRIPTOR_WORKAROUND
id|scsi_id-&gt;login_orb-&gt;login_response_lo
op_assign
id|cpu_to_le32
c_func
(paren
id|scsi_id-&gt;login_response_dma
)paren
suffix:semicolon
id|scsi_id-&gt;login_orb-&gt;login_response_hi
op_assign
id|cpu_to_le32
c_func
(paren
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
)paren
suffix:semicolon
macro_line|#else
id|scsi_id-&gt;login_orb-&gt;login_response_lo
op_assign
id|scsi_id-&gt;login_response_dma
suffix:semicolon
id|scsi_id-&gt;login_orb-&gt;login_response_hi
op_assign
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
suffix:semicolon
macro_line|#endif
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_login_device: login_response_hi/lo initialized&quot;
)paren
suffix:semicolon
id|scsi_id-&gt;login_orb-&gt;lun_misc
op_assign
id|ORB_SET_FUNCTION
c_func
(paren
id|LOGIN_REQUEST
)paren
suffix:semicolon
id|scsi_id-&gt;login_orb-&gt;lun_misc
op_or_assign
id|ORB_SET_RECONNECT
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* One second reconnect time */
id|scsi_id-&gt;login_orb-&gt;lun_misc
op_or_assign
id|ORB_SET_EXCLUSIVE
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Exclusive access to device */
id|scsi_id-&gt;login_orb-&gt;lun_misc
op_or_assign
id|ORB_SET_NOTIFY
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Notify us of login complete */
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_login_device: lun_misc initialized&quot;
)paren
suffix:semicolon
id|scsi_id-&gt;login_orb-&gt;passwd_resp_lengths
op_assign
id|ORB_SET_LOGIN_RESP_LENGTH
c_func
(paren
r_sizeof
(paren
r_struct
id|sbp2_login_response
)paren
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_login_device: passwd_resp_lengths initialized&quot;
)paren
suffix:semicolon
macro_line|#ifdef SBP2_NEED_LOGIN_DESCRIPTOR_WORKAROUND
id|scsi_id-&gt;login_orb-&gt;status_FIFO_lo
op_assign
id|cpu_to_le32
c_func
(paren
(paren
id|u32
)paren
id|SBP2_STATUS_FIFO_ADDRESS_LO
)paren
suffix:semicolon
id|scsi_id-&gt;login_orb-&gt;status_FIFO_hi
op_assign
(paren
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
op_or
id|cpu_to_le16
c_func
(paren
id|SBP2_STATUS_FIFO_ADDRESS_HI
)paren
)paren
suffix:semicolon
macro_line|#else
id|scsi_id-&gt;login_orb-&gt;status_FIFO_lo
op_assign
id|SBP2_STATUS_FIFO_ADDRESS_LO
suffix:semicolon
id|scsi_id-&gt;login_orb-&gt;status_FIFO_hi
op_assign
(paren
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
op_or
id|SBP2_STATUS_FIFO_ADDRESS_HI
)paren
suffix:semicolon
macro_line|#endif
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_login_device: status FIFO initialized&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Byte swap ORB if necessary&n;&t; */
id|sbp2util_cpu_to_be32_buffer
c_func
(paren
id|scsi_id-&gt;login_orb
comma
r_sizeof
(paren
r_struct
id|sbp2_login_orb
)paren
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_login_device: orb byte-swapped&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize login response and status fifo&n;&t; */
id|memset
c_func
(paren
id|scsi_id-&gt;login_response
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sbp2_login_response
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|scsi_id-&gt;status_block
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sbp2_status_block
)paren
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_login_device: login_response/status FIFO memset&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, let&squot;s write to the target&squot;s management agent register&n;&t; */
id|data
(braket
l_int|0
)braket
op_assign
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
suffix:semicolon
id|data
(braket
l_int|1
)braket
op_assign
id|scsi_id-&gt;login_orb_dma
suffix:semicolon
id|sbp2util_cpu_to_be32_buffer
c_func
(paren
id|data
comma
l_int|8
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_login_device: prepared to write&quot;
)paren
suffix:semicolon
id|hpsb_write
c_func
(paren
id|hi-&gt;host
comma
id|LOCAL_BUS
op_or
id|scsi_id-&gt;node_id
comma
id|scsi_id-&gt;sbp2_management_agent_addr
comma
id|data
comma
l_int|8
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wait for login status... but, only if the device has not already logged-in (some devices are fast)&n;&t; */
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_login_device: written&quot;
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_id-&gt;status_block.ORB_offset_lo
op_ne
id|scsi_id-&gt;login_orb_dma
)paren
(brace
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_login_wait
comma
l_int|10
op_star
id|HZ
)paren
suffix:semicolon
multiline_comment|/* 10 second timeout */
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_login_device: initial check&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Match status to the login orb. If they do not match, it&squot;s probably because the login timed-out&n;&t; */
r_if
c_cond
(paren
id|scsi_id-&gt;status_block.ORB_offset_lo
op_ne
id|scsi_id-&gt;login_orb_dma
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: Error logging into SBP-2 device - login timed-out&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_login_device: second check&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check status&n;&t; */
r_if
c_cond
(paren
id|STATUS_GET_RESP
c_func
(paren
id|scsi_id-&gt;status_block.ORB_offset_hi_misc
)paren
op_logical_or
id|STATUS_GET_DEAD_BIT
c_func
(paren
id|scsi_id-&gt;status_block.ORB_offset_hi_misc
)paren
op_logical_or
id|STATUS_GET_SBP_STATUS
c_func
(paren
id|scsi_id-&gt;status_block.ORB_offset_hi_misc
)paren
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: Error logging into SBP-2 device - login failed&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Byte swap the login response, for use when reconnecting or logging out.&n;&t; */
id|sbp2util_cpu_to_be32_buffer
c_func
(paren
id|scsi_id-&gt;login_response
comma
r_sizeof
(paren
r_struct
id|sbp2_login_response
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Grab our command block agent address from the login response&n;&t; */
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: command_block_agent_hi = %x&quot;
comma
(paren
r_int
r_int
)paren
id|scsi_id-&gt;login_response-&gt;command_block_agent_hi
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: command_block_agent_lo = %x&quot;
comma
(paren
r_int
r_int
)paren
id|scsi_id-&gt;login_response-&gt;command_block_agent_lo
)paren
suffix:semicolon
id|scsi_id-&gt;sbp2_command_block_agent_addr
op_assign
(paren
(paren
id|u64
)paren
id|scsi_id-&gt;login_response-&gt;command_block_agent_hi
)paren
op_lshift
l_int|32
suffix:semicolon
id|scsi_id-&gt;sbp2_command_block_agent_addr
op_or_assign
(paren
(paren
id|u64
)paren
id|scsi_id-&gt;login_response-&gt;command_block_agent_lo
)paren
suffix:semicolon
id|scsi_id-&gt;sbp2_command_block_agent_addr
op_and_assign
l_int|0x0000ffffffffffffULL
suffix:semicolon
id|SBP2_INFO
c_func
(paren
l_string|&quot;sbp2: Logged into SBP-2 device&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called in order to logout from a particular SBP-2 device, usually called during driver&n; * unload&n; */
DECL|function|sbp2_logout_device
r_static
r_int
id|sbp2_logout_device
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
)paren
(brace
id|quadlet_t
id|data
(braket
l_int|2
)braket
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_logout_device&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set-up logout ORB&n;&t; */
id|scsi_id-&gt;logout_orb-&gt;reserved1
op_assign
l_int|0x0
suffix:semicolon
id|scsi_id-&gt;logout_orb-&gt;reserved2
op_assign
l_int|0x0
suffix:semicolon
id|scsi_id-&gt;logout_orb-&gt;reserved3
op_assign
l_int|0x0
suffix:semicolon
id|scsi_id-&gt;logout_orb-&gt;reserved4
op_assign
l_int|0x0
suffix:semicolon
id|scsi_id-&gt;logout_orb-&gt;login_ID_misc
op_assign
id|ORB_SET_FUNCTION
c_func
(paren
id|LOGOUT_REQUEST
)paren
suffix:semicolon
id|scsi_id-&gt;logout_orb-&gt;login_ID_misc
op_or_assign
id|ORB_SET_LOGIN_ID
c_func
(paren
id|scsi_id-&gt;login_response-&gt;length_login_ID
)paren
suffix:semicolon
id|scsi_id-&gt;logout_orb-&gt;login_ID_misc
op_or_assign
id|ORB_SET_NOTIFY
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Notify us when complete */
id|scsi_id-&gt;logout_orb-&gt;reserved5
op_assign
l_int|0x0
suffix:semicolon
macro_line|#ifdef SBP2_NEED_LOGIN_DESCRIPTOR_WORKAROUND
id|scsi_id-&gt;logout_orb-&gt;status_FIFO_lo
op_assign
id|cpu_to_le32
c_func
(paren
(paren
id|u32
)paren
id|SBP2_STATUS_FIFO_ADDRESS_LO
)paren
suffix:semicolon
id|scsi_id-&gt;logout_orb-&gt;status_FIFO_hi
op_assign
(paren
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
op_or
id|cpu_to_le16
c_func
(paren
id|SBP2_STATUS_FIFO_ADDRESS_HI
)paren
)paren
suffix:semicolon
macro_line|#else
id|scsi_id-&gt;logout_orb-&gt;status_FIFO_lo
op_assign
id|SBP2_STATUS_FIFO_ADDRESS_LO
suffix:semicolon
id|scsi_id-&gt;logout_orb-&gt;status_FIFO_hi
op_assign
(paren
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
op_or
id|SBP2_STATUS_FIFO_ADDRESS_HI
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Byte swap ORB if necessary&n;&t; */
id|sbp2util_cpu_to_be32_buffer
c_func
(paren
id|scsi_id-&gt;logout_orb
comma
r_sizeof
(paren
r_struct
id|sbp2_logout_orb
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, let&squot;s write to the target&squot;s management agent register&n;&t; */
id|data
(braket
l_int|0
)braket
op_assign
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
suffix:semicolon
id|data
(braket
l_int|1
)braket
op_assign
id|scsi_id-&gt;logout_orb_dma
suffix:semicolon
id|sbp2util_cpu_to_be32_buffer
c_func
(paren
id|data
comma
l_int|8
)paren
suffix:semicolon
id|hpsb_write
c_func
(paren
id|hi-&gt;host
comma
id|LOCAL_BUS
op_or
id|scsi_id-&gt;node_id
comma
id|scsi_id-&gt;sbp2_management_agent_addr
comma
id|data
comma
l_int|8
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wait for device to logout... &n;&t; */
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_login_wait
comma
id|HZ
)paren
suffix:semicolon
multiline_comment|/* 1 second timeout */
id|SBP2_INFO
c_func
(paren
l_string|&quot;sbp2: Logged out of SBP-2 device&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called in order to reconnect to a particular SBP-2 device, after a bus reset&n; */
DECL|function|sbp2_reconnect_device
r_static
r_int
id|sbp2_reconnect_device
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
)paren
(brace
id|quadlet_t
id|data
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_reconnect_device&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set-up reconnect ORB&n;&t; */
id|scsi_id-&gt;reconnect_orb-&gt;reserved1
op_assign
l_int|0x0
suffix:semicolon
id|scsi_id-&gt;reconnect_orb-&gt;reserved2
op_assign
l_int|0x0
suffix:semicolon
id|scsi_id-&gt;reconnect_orb-&gt;reserved3
op_assign
l_int|0x0
suffix:semicolon
id|scsi_id-&gt;reconnect_orb-&gt;reserved4
op_assign
l_int|0x0
suffix:semicolon
id|scsi_id-&gt;reconnect_orb-&gt;login_ID_misc
op_assign
id|ORB_SET_FUNCTION
c_func
(paren
id|RECONNECT_REQUEST
)paren
suffix:semicolon
id|scsi_id-&gt;reconnect_orb-&gt;login_ID_misc
op_or_assign
id|ORB_SET_LOGIN_ID
c_func
(paren
id|scsi_id-&gt;login_response-&gt;length_login_ID
)paren
suffix:semicolon
id|scsi_id-&gt;reconnect_orb-&gt;login_ID_misc
op_or_assign
id|ORB_SET_NOTIFY
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Notify us when complete */
id|scsi_id-&gt;reconnect_orb-&gt;reserved5
op_assign
l_int|0x0
suffix:semicolon
macro_line|#ifdef SBP2_NEED_LOGIN_DESCRIPTOR_WORKAROUND
id|scsi_id-&gt;reconnect_orb-&gt;status_FIFO_lo
op_assign
id|cpu_to_le32
c_func
(paren
(paren
id|u32
)paren
id|SBP2_STATUS_FIFO_ADDRESS_LO
)paren
suffix:semicolon
id|scsi_id-&gt;reconnect_orb-&gt;status_FIFO_hi
op_assign
(paren
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
op_or
id|cpu_to_le16
c_func
(paren
id|SBP2_STATUS_FIFO_ADDRESS_HI
)paren
)paren
suffix:semicolon
macro_line|#else
id|scsi_id-&gt;reconnect_orb-&gt;status_FIFO_lo
op_assign
id|SBP2_STATUS_FIFO_ADDRESS_LO
suffix:semicolon
id|scsi_id-&gt;reconnect_orb-&gt;status_FIFO_hi
op_assign
(paren
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
op_or
id|SBP2_STATUS_FIFO_ADDRESS_HI
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Byte swap ORB if necessary&n;&t; */
id|sbp2util_cpu_to_be32_buffer
c_func
(paren
id|scsi_id-&gt;reconnect_orb
comma
r_sizeof
(paren
r_struct
id|sbp2_reconnect_orb
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize status fifo&n;&t; */
id|memset
c_func
(paren
op_amp
id|scsi_id-&gt;status_block
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sbp2_status_block
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, let&squot;s write to the target&squot;s management agent register&n;&t; */
id|data
(braket
l_int|0
)braket
op_assign
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
suffix:semicolon
id|data
(braket
l_int|1
)braket
op_assign
id|scsi_id-&gt;reconnect_orb_dma
suffix:semicolon
id|sbp2util_cpu_to_be32_buffer
c_func
(paren
id|data
comma
l_int|8
)paren
suffix:semicolon
id|hpsb_write
c_func
(paren
id|hi-&gt;host
comma
id|LOCAL_BUS
op_or
id|scsi_id-&gt;node_id
comma
id|scsi_id-&gt;sbp2_management_agent_addr
comma
id|data
comma
l_int|8
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wait for reconnect status... but, only if the device has not already reconnected (some devices are fast)&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_id-&gt;status_block.ORB_offset_lo
op_ne
id|scsi_id-&gt;reconnect_orb_dma
)paren
(brace
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_login_wait
comma
id|HZ
)paren
suffix:semicolon
multiline_comment|/* one second timeout */
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Match status to the reconnect orb. If they do not match, it&squot;s probably because the reconnect timed-out&n;&t; */
r_if
c_cond
(paren
id|scsi_id-&gt;status_block.ORB_offset_lo
op_ne
id|scsi_id-&gt;reconnect_orb_dma
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: Error reconnecting to SBP-2 device - reconnect timed-out&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check status&n;&t; */
r_if
c_cond
(paren
id|STATUS_GET_RESP
c_func
(paren
id|scsi_id-&gt;status_block.ORB_offset_hi_misc
)paren
op_logical_or
id|STATUS_GET_DEAD_BIT
c_func
(paren
id|scsi_id-&gt;status_block.ORB_offset_hi_misc
)paren
op_logical_or
id|STATUS_GET_SBP_STATUS
c_func
(paren
id|scsi_id-&gt;status_block.ORB_offset_hi_misc
)paren
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: Error reconnecting to SBP-2 device - reconnect failed&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|SBP2_INFO
c_func
(paren
l_string|&quot;sbp2: Reconnected to SBP-2 device&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called in order to set the busy timeout (number of retries to attempt) on the sbp2 device. &n; */
DECL|function|sbp2_set_busy_timeout
r_static
r_int
id|sbp2_set_busy_timeout
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
)paren
(brace
id|quadlet_t
id|data
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_set_busy_timeout&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, let&squot;s write to the target&squot;s busy timeout register&n;&t; */
id|data
op_assign
id|cpu_to_be32
c_func
(paren
id|SBP2_BUSY_TIMEOUT_VALUE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hpsb_write
c_func
(paren
id|hi-&gt;host
comma
id|LOCAL_BUS
op_or
id|scsi_id-&gt;node_id
comma
id|SBP2_BUSY_TIMEOUT_ADDRESS
comma
op_amp
id|data
comma
l_int|4
)paren
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: sbp2_set_busy_timeout error&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called to parse sbp2 device&squot;s config rom unit directory. Used to determine&n; * things like sbp2 management agent offset, and command set used (SCSI or RBC). &n; */
DECL|function|sbp2_parse_unit_directory
r_static
r_int
id|sbp2_parse_unit_directory
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
)paren
(brace
id|quadlet_t
id|unit_directory_length
comma
id|unit_directory_data
suffix:semicolon
id|u64
id|unit_directory_addr
suffix:semicolon
id|u32
id|i
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_parse_unit_directory&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbp2util_unit_directory
c_func
(paren
id|hi
comma
id|LOCAL_BUS
op_or
id|scsi_id-&gt;node_id
comma
op_amp
id|unit_directory_addr
)paren
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: Error reading unit directory address - bad status&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Read the size of the unit directory&n;&t; */
r_if
c_cond
(paren
id|sbp2util_read_quadlet
c_func
(paren
id|hi
comma
id|LOCAL_BUS
op_or
id|scsi_id-&gt;node_id
comma
id|unit_directory_addr
comma
op_amp
id|unit_directory_length
)paren
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: Error reading unit directory length - bad status&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|unit_directory_length
op_assign
(paren
(paren
id|be32_to_cpu
c_func
(paren
id|unit_directory_length
)paren
)paren
op_rshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now, sweep through the unit directory looking for the management agent offset&n;&t; * Give up if we hit any error or somehow miss it...&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|unit_directory_length
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sbp2util_read_quadlet
c_func
(paren
id|hi
comma
id|LOCAL_BUS
op_or
id|scsi_id-&gt;node_id
comma
id|unit_directory_addr
op_plus
(paren
id|i
op_lshift
l_int|2
)paren
op_plus
l_int|4
comma
op_amp
id|unit_directory_data
)paren
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: Error reading unit directory - bad status&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * Handle different fields in the unit directory, based on keys&n;&t;&t; */
id|unit_directory_data
op_assign
id|be32_to_cpu
c_func
(paren
id|unit_directory_data
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|unit_directory_data
op_rshift
l_int|24
)paren
(brace
r_case
id|SBP2_CSR_OFFSET_KEY
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Save off the management agent address&n;&t;&t;&t;&t; */
id|scsi_id-&gt;sbp2_management_agent_addr
op_assign
id|CONFIG_ROM_INITIAL_MEMORY_SPACE
op_plus
(paren
(paren
id|unit_directory_data
op_amp
l_int|0x00ffffff
)paren
op_lshift
l_int|2
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_management_agent_addr = %x&quot;
comma
(paren
r_int
r_int
)paren
id|scsi_id-&gt;sbp2_management_agent_addr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBP2_COMMAND_SET_SPEC_ID_KEY
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Command spec organization&n;&t;&t;&t;&t; */
id|scsi_id-&gt;sbp2_command_set_spec_id
op_assign
id|unit_directory_data
op_amp
l_int|0xffffff
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_command_set_spec_id = %x&quot;
comma
(paren
r_int
r_int
)paren
id|scsi_id-&gt;sbp2_command_set_spec_id
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBP2_COMMAND_SET_KEY
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Command set used by sbp2 device&n;&t;&t;&t;&t; */
id|scsi_id-&gt;sbp2_command_set
op_assign
id|unit_directory_data
op_amp
l_int|0xffffff
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_command_set = %x&quot;
comma
(paren
r_int
r_int
)paren
id|scsi_id-&gt;sbp2_command_set
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBP2_UNIT_CHARACTERISTICS_KEY
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Unit characterisitcs (orb related stuff that I&squot;m not yet paying attention to)&n;&t;&t;&t;&t; */
id|scsi_id-&gt;sbp2_unit_characteristics
op_assign
id|unit_directory_data
op_amp
l_int|0xffffff
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_unit_characteristics = %x&quot;
comma
(paren
r_int
r_int
)paren
id|scsi_id-&gt;sbp2_unit_characteristics
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBP2_DEVICE_TYPE_AND_LUN_KEY
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Device type and lun (used for detemining type of sbp2 device)&n;&t;&t;&t;&t; */
id|scsi_id-&gt;sbp2_device_type_and_lun
op_assign
id|unit_directory_data
op_amp
l_int|0xffffff
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_device_type_and_lun = %x&quot;
comma
(paren
r_int
r_int
)paren
id|scsi_id-&gt;sbp2_device_type_and_lun
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBP2_UNIT_SPEC_ID_KEY
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Unit spec id (used for protocol detection)&n;&t;&t;&t;&t; */
id|scsi_id-&gt;sbp2_unit_spec_id
op_assign
id|unit_directory_data
op_amp
l_int|0xffffff
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_unit_spec_id = %x&quot;
comma
(paren
r_int
r_int
)paren
id|scsi_id-&gt;sbp2_unit_spec_id
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBP2_UNIT_SW_VERSION_KEY
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Unit sw version (used for protocol detection) &n;&t;&t;&t;&t; */
id|scsi_id-&gt;sbp2_unit_sw_version
op_assign
id|unit_directory_data
op_amp
l_int|0xffffff
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_unit_sw_version = %x&quot;
comma
(paren
r_int
r_int
)paren
id|scsi_id-&gt;sbp2_unit_sw_version
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBP2_FIRMWARE_REVISION_KEY
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Firmware revision (used to find broken devices). If the vendor id is 0xa0b8 &n;&t;&t;&t;&t; * (Symbios vendor id), then we have a bridge with 128KB max transfer size limitation.&n;&t;&t;&t;&t; */
id|scsi_id-&gt;sbp2_firmware_revision
op_assign
id|unit_directory_data
op_amp
l_int|0xffff00
suffix:semicolon
r_if
c_cond
(paren
id|scsi_id-&gt;sbp2_firmware_revision
op_eq
id|SBP2_128KB_BROKEN_FIRMWARE
)paren
(brace
id|SBP2_WARN
c_func
(paren
l_string|&quot;sbp2: warning: Bridge chipset supports 128KB max transfer size&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called in order to determine the max speed and packet size we can use in our ORBs. &n; */
DECL|function|sbp2_max_speed_and_size
r_static
r_int
id|sbp2_max_speed_and_size
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
)paren
(brace
id|u8
id|speed_code
suffix:semicolon
r_struct
id|node_entry
op_star
id|ne
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_max_speed_and_size&quot;
)paren
suffix:semicolon
multiline_comment|/* Get this nodes information */
id|ne
op_assign
id|hpsb_nodeid_get_entry
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ne
)paren
(brace
id|HPSB_ERR
c_func
(paren
l_string|&quot;sbp2: Unknown device, using S100, payload 512 bytes&quot;
)paren
suffix:semicolon
id|scsi_id-&gt;speed_code
op_assign
id|SPEED_100
suffix:semicolon
id|scsi_id-&gt;max_payload_size
op_assign
id|MAX_PAYLOAD_S100
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|speed_code
op_assign
id|ne-&gt;busopt.lnkspd
suffix:semicolon
multiline_comment|/* Bump down our speed if there is a module parameter forcing us slower */
r_if
c_cond
(paren
id|speed_code
OG
id|max_speed
)paren
(brace
id|speed_code
op_assign
id|max_speed
suffix:semicolon
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: Reducing SBP-2 max speed allowed (%x)&quot;
comma
id|max_speed
)paren
suffix:semicolon
)brace
multiline_comment|/* Support the devices max_rec and max speed. We choose a setting&n;&t; * that fits both values, since they may differ.  */
r_if
c_cond
(paren
id|speed_code
op_ge
id|SPEED_400
op_logical_and
id|ne-&gt;busopt.max_rec
op_ge
id|MAX_REC_S400
)paren
(brace
id|HPSB_INFO
c_func
(paren
l_string|&quot;sbp2: SBP-2 device max speed S400 and payload 2KB&quot;
)paren
suffix:semicolon
id|scsi_id-&gt;speed_code
op_assign
id|SPEED_400
suffix:semicolon
id|scsi_id-&gt;max_payload_size
op_assign
id|MAX_PAYLOAD_S400
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|speed_code
op_ge
id|SPEED_200
op_logical_and
id|ne-&gt;busopt.max_rec
op_ge
id|MAX_REC_S200
)paren
(brace
id|HPSB_INFO
c_func
(paren
l_string|&quot;sbp2: SBP-2 device max speed S200 and payload 1KB&quot;
)paren
suffix:semicolon
id|scsi_id-&gt;speed_code
op_assign
id|SPEED_200
suffix:semicolon
id|scsi_id-&gt;max_payload_size
op_assign
id|MAX_PAYLOAD_S200
suffix:semicolon
)brace
r_else
(brace
id|HPSB_INFO
c_func
(paren
l_string|&quot;sbp2: SBP-2 device max speed S100 and payload 512 bytes&quot;
)paren
suffix:semicolon
id|scsi_id-&gt;speed_code
op_assign
id|SPEED_100
suffix:semicolon
id|scsi_id-&gt;max_payload_size
op_assign
id|MAX_PAYLOAD_S100
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called in order to perform a SBP-2 agent reset. &n; */
DECL|function|sbp2_agent_reset
r_static
r_int
id|sbp2_agent_reset
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
id|u32
id|flags
)paren
(brace
r_struct
id|sbp2_request_packet
op_star
id|agent_reset_request_packet
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_agent_reset&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, let&squot;s write to the target&squot;s management agent register&n;&t; */
id|agent_reset_request_packet
op_assign
id|sbp2util_allocate_write_request_packet
c_func
(paren
id|hi
comma
id|LOCAL_BUS
op_or
id|scsi_id-&gt;node_id
comma
id|scsi_id-&gt;sbp2_command_block_agent_addr
op_plus
id|SBP2_AGENT_RESET_OFFSET
comma
l_int|0
comma
id|ntohl
c_func
(paren
id|SBP2_AGENT_RESET_DATA
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|agent_reset_request_packet
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: sbp2util_allocate_write_request_packet failed&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|hpsb_send_packet
c_func
(paren
id|agent_reset_request_packet-&gt;packet
)paren
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: hpsb_send_packet failed&quot;
)paren
suffix:semicolon
id|sbp2util_free_request_packet
c_func
(paren
id|agent_reset_request_packet
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|SBP2_SEND_NO_WAIT
)paren
)paren
(brace
id|down
c_func
(paren
op_amp
id|agent_reset_request_packet-&gt;packet-&gt;state_change
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|agent_reset_request_packet-&gt;packet-&gt;state_change
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Need to make sure orb pointer is written on next command&n;&t; */
id|scsi_id-&gt;last_orb
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called to create the actual command orb and s/g list out of the &n; * scsi command itself. &n; */
DECL|function|sbp2_create_command_orb
r_static
r_int
id|sbp2_create_command_orb
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
r_struct
id|sbp2_command_info
op_star
id|command
comma
id|unchar
op_star
id|scsi_cmd
comma
r_int
r_int
id|scsi_use_sg
comma
r_int
r_int
id|scsi_request_bufflen
comma
r_void
op_star
id|scsi_request_buffer
comma
r_int
id|dma_dir
)paren
(brace
r_struct
id|scatterlist
op_star
id|sgpnt
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|scsi_request_buffer
suffix:semicolon
r_struct
id|sbp2_command_orb
op_star
id|command_orb
op_assign
op_amp
id|command-&gt;command_orb
suffix:semicolon
r_struct
id|sbp2_unrestricted_page_table
op_star
id|scatter_gather_element
op_assign
op_amp
id|command-&gt;scatter_gather_element
(braket
l_int|0
)braket
suffix:semicolon
id|u32
id|sg_count
comma
id|sg_len
suffix:semicolon
id|dma_addr_t
id|sg_addr
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Set-up our command ORB..&n;&t; *&n;&t; * NOTE: We&squot;re doing unrestricted page tables (s/g), as this is best performance &n;&t; * (at least with the devices I have). This means that data_size becomes the number &n;&t; * of s/g elements, and page_size should be zero (for unrestricted).&n;&t; */
id|command_orb-&gt;next_ORB_hi
op_assign
l_int|0xffffffff
suffix:semicolon
id|command_orb-&gt;next_ORB_lo
op_assign
l_int|0xffffffff
suffix:semicolon
id|command_orb-&gt;misc
op_assign
id|ORB_SET_MAX_PAYLOAD
c_func
(paren
id|scsi_id-&gt;max_payload_size
)paren
suffix:semicolon
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_SPEED
c_func
(paren
id|scsi_id-&gt;speed_code
)paren
suffix:semicolon
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_NOTIFY
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Notify us when complete */
multiline_comment|/*&n;&t; * Set-up our pagetable stuff... unfortunately, this has become messier than I&squot;d like. Need to &n;&t; * clean this up a bit.   ;-)&n;&t; */
r_if
c_cond
(paren
id|sbp2scsi_direction_table
(braket
op_star
id|scsi_cmd
)braket
op_eq
id|ORB_DIRECTION_NO_DATA_TRANSFER
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: No data transfer&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Handle no data transfer&n;&t;&t; */
id|command_orb-&gt;data_descriptor_hi
op_assign
l_int|0xffffffff
suffix:semicolon
id|command_orb-&gt;data_descriptor_lo
op_assign
l_int|0xffffffff
suffix:semicolon
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_DIRECTION
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scsi_use_sg
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: Use scatter/gather&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Special case if only one element (and less than 64KB in size)&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|scsi_use_sg
op_eq
l_int|1
)paren
op_logical_and
(paren
id|sgpnt
(braket
l_int|0
)braket
dot
id|length
op_le
id|SBP2_MAX_SG_ELEMENT_LENGTH
)paren
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: Only one s/g element&quot;
)paren
suffix:semicolon
id|command-&gt;dma_dir
op_assign
id|dma_dir
suffix:semicolon
id|command-&gt;dma_size
op_assign
id|sgpnt
(braket
l_int|0
)braket
dot
id|length
suffix:semicolon
id|command-&gt;cmd_dma
op_assign
id|pci_map_single
(paren
id|hi-&gt;host-&gt;pdev
comma
id|sgpnt
(braket
l_int|0
)braket
dot
id|address
comma
id|command-&gt;dma_size
comma
id|command-&gt;dma_dir
)paren
suffix:semicolon
id|SBP2_DMA_ALLOC
c_func
(paren
l_string|&quot;single scatter element&quot;
)paren
suffix:semicolon
id|command_orb-&gt;data_descriptor_hi
op_assign
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
suffix:semicolon
id|command_orb-&gt;data_descriptor_lo
op_assign
id|command-&gt;cmd_dma
suffix:semicolon
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_DATA_SIZE
c_func
(paren
id|command-&gt;dma_size
)paren
suffix:semicolon
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_DIRECTION
c_func
(paren
id|sbp2scsi_direction_table
(braket
op_star
id|scsi_cmd
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|count
op_assign
id|pci_map_sg
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
id|sgpnt
comma
id|scsi_use_sg
comma
id|dma_dir
)paren
suffix:semicolon
id|SBP2_DMA_ALLOC
c_func
(paren
l_string|&quot;scatter list&quot;
)paren
suffix:semicolon
id|command-&gt;dma_size
op_assign
id|scsi_use_sg
suffix:semicolon
id|command-&gt;dma_dir
op_assign
id|dma_dir
suffix:semicolon
id|command-&gt;sge_buffer
op_assign
id|sgpnt
suffix:semicolon
multiline_comment|/* use page tables (s/g) */
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_PAGE_TABLE_PRESENT
c_func
(paren
l_int|0x1
)paren
suffix:semicolon
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_DIRECTION
c_func
(paren
id|sbp2scsi_direction_table
(braket
op_star
id|scsi_cmd
)braket
)paren
suffix:semicolon
id|command_orb-&gt;data_descriptor_hi
op_assign
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
suffix:semicolon
id|command_orb-&gt;data_descriptor_lo
op_assign
id|command-&gt;sge_dma
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Loop through and fill out our sbp-2 page tables&n;&t;&t;&t; * (and split up anything too large)&n;&t;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|sg_count
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|sgpnt
op_increment
)paren
(brace
id|sg_len
op_assign
id|sg_dma_len
c_func
(paren
id|sgpnt
)paren
suffix:semicolon
id|sg_addr
op_assign
id|sg_dma_address
c_func
(paren
id|sgpnt
)paren
suffix:semicolon
r_while
c_loop
(paren
id|sg_len
)paren
(brace
id|scatter_gather_element
(braket
id|sg_count
)braket
dot
id|segment_base_lo
op_assign
id|sg_addr
suffix:semicolon
r_if
c_cond
(paren
id|sg_len
OG
id|SBP2_MAX_SG_ELEMENT_LENGTH
)paren
(brace
id|scatter_gather_element
(braket
id|sg_count
)braket
dot
id|length_segment_base_hi
op_assign
id|PAGE_TABLE_SET_SEGMENT_LENGTH
c_func
(paren
id|SBP2_MAX_SG_ELEMENT_LENGTH
)paren
suffix:semicolon
id|sg_addr
op_add_assign
id|SBP2_MAX_SG_ELEMENT_LENGTH
suffix:semicolon
id|sg_len
op_sub_assign
id|SBP2_MAX_SG_ELEMENT_LENGTH
suffix:semicolon
)brace
r_else
(brace
id|scatter_gather_element
(braket
id|sg_count
)braket
dot
id|length_segment_base_hi
op_assign
id|PAGE_TABLE_SET_SEGMENT_LENGTH
c_func
(paren
id|sg_len
)paren
suffix:semicolon
id|sg_len
op_assign
l_int|0
suffix:semicolon
)brace
id|sg_count
op_increment
suffix:semicolon
)brace
)brace
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_DATA_SIZE
c_func
(paren
id|sg_count
)paren
suffix:semicolon
multiline_comment|/* number of page table (s/g) elements */
multiline_comment|/*&n;&t;&t;&t; * Byte swap page tables if necessary&n;&t;&t;&t; */
id|sbp2util_cpu_to_be32_buffer
c_func
(paren
id|scatter_gather_element
comma
(paren
r_sizeof
(paren
r_struct
id|sbp2_unrestricted_page_table
)paren
)paren
op_star
id|sg_count
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: No scatter/gather&quot;
)paren
suffix:semicolon
id|command-&gt;dma_dir
op_assign
id|dma_dir
suffix:semicolon
id|command-&gt;dma_size
op_assign
id|scsi_request_bufflen
suffix:semicolon
id|command-&gt;cmd_dma
op_assign
id|pci_map_single
(paren
id|hi-&gt;host-&gt;pdev
comma
id|scsi_request_buffer
comma
id|command-&gt;dma_size
comma
id|command-&gt;dma_dir
)paren
suffix:semicolon
id|SBP2_DMA_ALLOC
c_func
(paren
l_string|&quot;single bulk&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Handle case where we get a command w/o s/g enabled (but check&n;&t;&t; * for transfers larger than 64K)&n;&t;&t; */
r_if
c_cond
(paren
id|scsi_request_bufflen
op_le
id|SBP2_MAX_SG_ELEMENT_LENGTH
)paren
(brace
id|command_orb-&gt;data_descriptor_hi
op_assign
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
suffix:semicolon
id|command_orb-&gt;data_descriptor_lo
op_assign
id|command-&gt;cmd_dma
suffix:semicolon
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_DATA_SIZE
c_func
(paren
id|scsi_request_bufflen
)paren
suffix:semicolon
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_DIRECTION
c_func
(paren
id|sbp2scsi_direction_table
(braket
op_star
id|scsi_cmd
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Sanity, in case our direction table is not up-to-date&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|scsi_request_bufflen
)paren
(brace
id|command_orb-&gt;data_descriptor_hi
op_assign
l_int|0xffffffff
suffix:semicolon
id|command_orb-&gt;data_descriptor_lo
op_assign
l_int|0xffffffff
suffix:semicolon
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_DIRECTION
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Need to turn this into page tables, since the buffer is too large.&n;&t;&t;&t; */
id|command_orb-&gt;data_descriptor_hi
op_assign
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
suffix:semicolon
id|command_orb-&gt;data_descriptor_lo
op_assign
id|command-&gt;sge_dma
suffix:semicolon
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_PAGE_TABLE_PRESENT
c_func
(paren
l_int|0x1
)paren
suffix:semicolon
multiline_comment|/* use page tables (s/g) */
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_DIRECTION
c_func
(paren
id|sbp2scsi_direction_table
(braket
op_star
id|scsi_cmd
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * fill out our sbp-2 page tables (and split up the large buffer)&n;&t;&t;&t; */
id|sg_count
op_assign
l_int|0
suffix:semicolon
id|sg_len
op_assign
id|scsi_request_bufflen
suffix:semicolon
id|sg_addr
op_assign
id|command-&gt;cmd_dma
suffix:semicolon
r_while
c_loop
(paren
id|sg_len
)paren
(brace
id|scatter_gather_element
(braket
id|sg_count
)braket
dot
id|segment_base_lo
op_assign
id|sg_addr
suffix:semicolon
r_if
c_cond
(paren
id|sg_len
OG
id|SBP2_MAX_SG_ELEMENT_LENGTH
)paren
(brace
id|scatter_gather_element
(braket
id|sg_count
)braket
dot
id|length_segment_base_hi
op_assign
id|PAGE_TABLE_SET_SEGMENT_LENGTH
c_func
(paren
id|SBP2_MAX_SG_ELEMENT_LENGTH
)paren
suffix:semicolon
id|sg_addr
op_add_assign
id|SBP2_MAX_SG_ELEMENT_LENGTH
suffix:semicolon
id|sg_len
op_sub_assign
id|SBP2_MAX_SG_ELEMENT_LENGTH
suffix:semicolon
)brace
r_else
(brace
id|scatter_gather_element
(braket
id|sg_count
)braket
dot
id|length_segment_base_hi
op_assign
id|PAGE_TABLE_SET_SEGMENT_LENGTH
c_func
(paren
id|sg_len
)paren
suffix:semicolon
id|sg_len
op_assign
l_int|0
suffix:semicolon
)brace
id|sg_count
op_increment
suffix:semicolon
)brace
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_DATA_SIZE
c_func
(paren
id|sg_count
)paren
suffix:semicolon
multiline_comment|/* number of page table (s/g) elements */
multiline_comment|/*&n;&t;&t;&t; * Byte swap page tables if necessary&n;&t;&t;&t; */
id|sbp2util_cpu_to_be32_buffer
c_func
(paren
id|scatter_gather_element
comma
(paren
r_sizeof
(paren
r_struct
id|sbp2_unrestricted_page_table
)paren
)paren
op_star
id|sg_count
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Byte swap command ORB if necessary&n;&t; */
id|sbp2util_cpu_to_be32_buffer
c_func
(paren
id|command_orb
comma
r_sizeof
(paren
r_struct
id|sbp2_command_orb
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Put our scsi command in the command ORB&n;&t; */
id|memset
c_func
(paren
id|command_orb-&gt;cdb
comma
l_int|0
comma
l_int|12
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|command_orb-&gt;cdb
comma
id|scsi_cmd
comma
id|COMMAND_SIZE
c_func
(paren
op_star
id|scsi_cmd
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called in order to begin a regular SBP-2 command. &n; */
DECL|function|sbp2_link_orb_command
r_static
r_int
id|sbp2_link_orb_command
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
r_struct
id|sbp2_command_info
op_star
id|command
)paren
(brace
r_struct
id|sbp2_request_packet
op_star
id|command_request_packet
suffix:semicolon
r_struct
id|sbp2_command_orb
op_star
id|command_orb
op_assign
op_amp
id|command-&gt;command_orb
suffix:semicolon
id|outstanding_orb_incr
suffix:semicolon
id|SBP2_ORB_DEBUG
c_func
(paren
l_string|&quot;sending command orb %p, linked = %x, total orbs = %x&quot;
comma
id|command_orb
comma
id|command-&gt;linked
comma
id|global_outstanding_command_orbs
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check to see if there are any previous orbs to use&n;&t; */
r_if
c_cond
(paren
id|scsi_id-&gt;last_orb
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * Ok, let&squot;s write to the target&squot;s management agent register&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|hi-&gt;bus_reset_in_progress
)paren
(brace
id|command_request_packet
op_assign
id|sbp2util_allocate_write_request_packet
c_func
(paren
id|hi
comma
id|LOCAL_BUS
op_or
id|scsi_id-&gt;node_id
comma
id|scsi_id-&gt;sbp2_command_block_agent_addr
op_plus
id|SBP2_ORB_POINTER_OFFSET
comma
l_int|8
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|command_request_packet
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: sbp2util_allocate_write_request_packet failed&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|command_request_packet-&gt;packet-&gt;data
(braket
l_int|0
)braket
op_assign
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
suffix:semicolon
id|command_request_packet-&gt;packet-&gt;data
(braket
l_int|1
)braket
op_assign
id|command-&gt;command_orb_dma
suffix:semicolon
id|sbp2util_cpu_to_be32_buffer
c_func
(paren
id|command_request_packet-&gt;packet-&gt;data
comma
l_int|8
)paren
suffix:semicolon
id|SBP2_ORB_DEBUG
c_func
(paren
l_string|&quot;write command agent, command orb %p&quot;
comma
id|command_orb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hpsb_send_packet
c_func
(paren
id|command_request_packet-&gt;packet
)paren
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: hpsb_send_packet failed&quot;
)paren
suffix:semicolon
id|sbp2util_free_request_packet
c_func
(paren
id|command_request_packet
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|SBP2_ORB_DEBUG
c_func
(paren
l_string|&quot;write command agent complete&quot;
)paren
suffix:semicolon
)brace
id|scsi_id-&gt;last_orb
op_assign
id|command_orb
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * We have an orb already sent (maybe or maybe not&n;&t;&t; * processed) that we can append this orb to. So do so,&n;&t;&t; * and ring the doorbell. Have to be very careful&n;&t;&t; * modifying these next orb pointers, as they are accessed&n;&t;&t; * both by the sbp2 device and us.&n;&t;&t; */
id|scsi_id-&gt;last_orb-&gt;next_ORB_lo
op_assign
id|cpu_to_be32
c_func
(paren
id|command-&gt;command_orb_dma
)paren
suffix:semicolon
id|scsi_id-&gt;last_orb-&gt;next_ORB_hi
op_assign
l_int|0x0
suffix:semicolon
multiline_comment|/* Tells hardware that this pointer is valid */
multiline_comment|/*&n;&t;&t; * Only ring the doorbell if we need to (first parts of linked orbs don&squot;t need this)&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|command-&gt;linked
op_logical_and
op_logical_neg
id|hi-&gt;bus_reset_in_progress
)paren
(brace
id|command_request_packet
op_assign
id|sbp2util_allocate_write_request_packet
c_func
(paren
id|hi
comma
id|LOCAL_BUS
op_or
id|scsi_id-&gt;node_id
comma
id|scsi_id-&gt;sbp2_command_block_agent_addr
op_plus
id|SBP2_DOORBELL_OFFSET
comma
l_int|0
comma
id|cpu_to_be32
c_func
(paren
id|command-&gt;command_orb_dma
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|command_request_packet
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: sbp2util_allocate_write_request_packet failed&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|SBP2_ORB_DEBUG
c_func
(paren
l_string|&quot;ring doorbell, command orb %p&quot;
comma
id|command_orb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hpsb_send_packet
c_func
(paren
id|command_request_packet-&gt;packet
)paren
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: hpsb_send_packet failed&quot;
)paren
suffix:semicolon
id|sbp2util_free_request_packet
c_func
(paren
id|command_request_packet
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
id|scsi_id-&gt;last_orb
op_assign
id|command_orb
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called in order to begin a regular SBP-2 command. &n; */
DECL|function|sbp2_send_command
r_static
r_int
id|sbp2_send_command
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
id|unchar
op_star
id|cmd
op_assign
(paren
id|unchar
op_star
)paren
id|SCpnt-&gt;cmnd
suffix:semicolon
id|u32
id|device_type
op_assign
(paren
id|scsi_id-&gt;sbp2_device_type_and_lun
op_amp
l_int|0x00ff0000
)paren
op_rshift
l_int|16
suffix:semicolon
r_struct
id|sbp2_command_info
op_star
id|command
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_send_command&quot;
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: SCSI command = %02x&quot;
comma
op_star
id|cmd
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: SCSI transfer size = %x&quot;
comma
id|SCpnt-&gt;request_bufflen
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: SCSI s/g elements = %x&quot;
comma
(paren
r_int
r_int
)paren
id|SCpnt-&gt;use_sg
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check for broken devices that can&squot;t handle greater than 128K transfers, and deal with them in a &n;&t; * hacked ugly way.&n;&t; */
r_if
c_cond
(paren
(paren
id|scsi_id-&gt;sbp2_firmware_revision
op_eq
id|SBP2_128KB_BROKEN_FIRMWARE
)paren
op_logical_and
(paren
id|SCpnt-&gt;request_bufflen
OG
id|SBP2_BROKEN_FIRMWARE_MAX_TRANSFER
)paren
op_logical_and
(paren
id|device_type
op_eq
id|TYPE_DISK
)paren
op_logical_and
(paren
id|SCpnt-&gt;use_sg
)paren
op_logical_and
(paren
op_star
id|cmd
op_eq
l_int|0x28
op_logical_or
op_star
id|cmd
op_eq
l_int|0x2a
op_logical_or
op_star
id|cmd
op_eq
l_int|0x0a
op_logical_or
op_star
id|cmd
op_eq
l_int|0x08
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Darn, a broken device. We&squot;ll need to split up the transfer ourselves&n;&t;&t; */
id|sbp2_send_split_command
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|SCpnt
comma
id|done
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Allocate a command orb and s/g structure&n;&t; */
id|command
op_assign
id|sbp2util_allocate_command_orb
c_func
(paren
id|scsi_id
comma
id|SCpnt
comma
id|done
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|command
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now actually fill in the comamnd orb and sbp2 s/g list&n;&t; */
id|sbp2_create_command_orb
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|command
comma
id|cmd
comma
id|SCpnt-&gt;use_sg
comma
id|SCpnt-&gt;request_bufflen
comma
id|SCpnt-&gt;request_buffer
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|SCpnt-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Update our cdb if necessary (to handle sbp2 RBC command set differences).&n;&t; * This is where the command set hacks go!   =)&n;&t; */
r_if
c_cond
(paren
(paren
id|device_type
op_eq
id|TYPE_DISK
)paren
op_logical_or
(paren
id|device_type
op_eq
id|TYPE_SDAD
)paren
op_logical_or
(paren
id|device_type
op_eq
id|TYPE_ROM
)paren
)paren
(brace
id|sbp2_check_sbp2_command
c_func
(paren
id|command-&gt;command_orb.cdb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Initialize status fifo&n;&t; */
id|memset
c_func
(paren
op_amp
id|scsi_id-&gt;status_block
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sbp2_status_block
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Link up the orb, and ring the doorbell if needed&n;&t; */
id|sbp2_link_orb_command
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|command
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called for broken sbp2 device, where we have to break up large transfers. &n; */
DECL|function|sbp2_send_split_command
r_static
r_int
id|sbp2_send_split_command
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
id|unchar
op_star
id|cmd
op_assign
(paren
id|unchar
op_star
)paren
id|SCpnt-&gt;cmnd
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sgpnt
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|SCpnt-&gt;request_buffer
suffix:semicolon
r_struct
id|sbp2_command_info
op_star
id|command
suffix:semicolon
r_int
r_int
id|i
comma
id|block_count
comma
id|block_address
comma
id|block_size
suffix:semicolon
r_int
r_int
id|current_sg
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|total_transfer
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|total_sg
op_assign
l_int|0
suffix:semicolon
id|unchar
id|new_cmd
(braket
l_int|12
)braket
suffix:semicolon
id|memset
c_func
(paren
id|new_cmd
comma
l_int|0
comma
l_int|12
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|new_cmd
comma
id|cmd
comma
id|COMMAND_SIZE
c_func
(paren
op_star
id|cmd
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Turns command into 10 byte version&n;&t; */
id|sbp2_check_sbp2_command
c_func
(paren
id|new_cmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Pull block size, block address, block count from command sent down&n;&t; */
id|block_count
op_assign
(paren
id|cmd
(braket
l_int|7
)braket
op_lshift
l_int|8
)paren
op_or
id|cmd
(braket
l_int|8
)braket
suffix:semicolon
id|block_address
op_assign
(paren
id|cmd
(braket
l_int|2
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|cmd
(braket
l_int|3
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|cmd
(braket
l_int|4
)braket
op_lshift
l_int|8
)paren
op_or
id|cmd
(braket
l_int|5
)braket
suffix:semicolon
id|block_size
op_assign
id|SCpnt-&gt;request_bufflen
op_div
id|block_count
suffix:semicolon
multiline_comment|/*&n;&t; * Walk the scsi s/g list to determine how much we can transfer in one pop&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCpnt-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
id|total_transfer
op_add_assign
id|sgpnt
(braket
id|i
)braket
dot
id|length
suffix:semicolon
id|total_sg
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|total_transfer
OG
id|SBP2_BROKEN_FIRMWARE_MAX_TRANSFER
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Back everything up one, so that we&squot;re less than 128KB&n;&t;&t;&t; */
id|total_transfer
op_sub_assign
id|sgpnt
(braket
id|i
)braket
dot
id|length
suffix:semicolon
id|total_sg
op_decrement
suffix:semicolon
id|i
op_decrement
suffix:semicolon
id|command
op_assign
id|sbp2util_allocate_command_orb
c_func
(paren
id|scsi_id
comma
id|SCpnt
comma
id|done
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|command
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * This is not the final piece, so mark it as linked&n;&t;&t;&t; */
id|command-&gt;linked
op_assign
l_int|1
suffix:semicolon
id|block_count
op_assign
id|total_transfer
op_div
id|block_size
suffix:semicolon
id|new_cmd
(braket
l_int|2
)braket
op_assign
(paren
id|unchar
)paren
(paren
id|block_address
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
suffix:semicolon
id|new_cmd
(braket
l_int|3
)braket
op_assign
(paren
id|unchar
)paren
(paren
id|block_address
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|new_cmd
(braket
l_int|4
)braket
op_assign
(paren
id|unchar
)paren
(paren
id|block_address
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|new_cmd
(braket
l_int|5
)braket
op_assign
(paren
id|unchar
)paren
id|block_address
op_amp
l_int|0xff
suffix:semicolon
id|new_cmd
(braket
l_int|7
)braket
op_assign
(paren
id|unchar
)paren
(paren
id|block_count
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|new_cmd
(braket
l_int|8
)braket
op_assign
(paren
id|unchar
)paren
id|block_count
op_amp
l_int|0xff
suffix:semicolon
id|block_address
op_add_assign
id|block_count
suffix:semicolon
id|sbp2_create_command_orb
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|command
comma
id|new_cmd
comma
id|total_sg
comma
id|total_transfer
comma
op_amp
id|sgpnt
(braket
id|current_sg
)braket
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|SCpnt-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Link up the orb, and ring the doorbell if needed&n;&t;&t;&t; */
id|memset
c_func
(paren
op_amp
id|scsi_id-&gt;status_block
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sbp2_status_block
)paren
)paren
suffix:semicolon
id|sbp2_link_orb_command
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|command
)paren
suffix:semicolon
id|current_sg
op_add_assign
id|total_sg
suffix:semicolon
id|total_sg
op_assign
l_int|0
suffix:semicolon
id|total_transfer
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Get the last piece...&n;&t; */
id|command
op_assign
id|sbp2util_allocate_command_orb
c_func
(paren
id|scsi_id
comma
id|SCpnt
comma
id|done
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|command
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|block_count
op_assign
id|total_transfer
op_div
id|block_size
suffix:semicolon
id|new_cmd
(braket
l_int|2
)braket
op_assign
(paren
id|unchar
)paren
(paren
id|block_address
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
suffix:semicolon
id|new_cmd
(braket
l_int|3
)braket
op_assign
(paren
id|unchar
)paren
(paren
id|block_address
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|new_cmd
(braket
l_int|4
)braket
op_assign
(paren
id|unchar
)paren
(paren
id|block_address
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|new_cmd
(braket
l_int|5
)braket
op_assign
(paren
id|unchar
)paren
id|block_address
op_amp
l_int|0xff
suffix:semicolon
id|new_cmd
(braket
l_int|7
)braket
op_assign
(paren
id|unchar
)paren
(paren
id|block_count
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|new_cmd
(braket
l_int|8
)braket
op_assign
(paren
id|unchar
)paren
id|block_count
op_amp
l_int|0xff
suffix:semicolon
id|sbp2_create_command_orb
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|command
comma
id|new_cmd
comma
id|total_sg
comma
id|total_transfer
comma
op_amp
id|sgpnt
(braket
id|current_sg
)braket
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|SCpnt-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Link up the orb, and ring the doorbell if needed&n;&t; */
id|memset
c_func
(paren
op_amp
id|scsi_id-&gt;status_block
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sbp2_status_block
)paren
)paren
suffix:semicolon
id|sbp2_link_orb_command
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|command
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function deals with command set differences between Linux scsi command set and sbp2 RBC&n; * command set.&n; */
DECL|function|sbp2_check_sbp2_command
r_static
r_void
id|sbp2_check_sbp2_command
c_func
(paren
id|unchar
op_star
id|cmd
)paren
(brace
id|unchar
id|new_cmd
(braket
l_int|16
)braket
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_check_sbp2_command&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
op_star
id|cmd
)paren
(brace
r_case
id|READ_6
suffix:colon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: Convert READ_6 to READ_10&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Need to turn read_6 into read_10&n;&t;&t;&t; */
id|new_cmd
(braket
l_int|0
)braket
op_assign
l_int|0x28
suffix:semicolon
id|new_cmd
(braket
l_int|1
)braket
op_assign
(paren
id|cmd
(braket
l_int|1
)braket
op_amp
l_int|0xe0
)paren
suffix:semicolon
id|new_cmd
(braket
l_int|2
)braket
op_assign
l_int|0x0
suffix:semicolon
id|new_cmd
(braket
l_int|3
)braket
op_assign
(paren
id|cmd
(braket
l_int|1
)braket
op_amp
l_int|0x1f
)paren
suffix:semicolon
id|new_cmd
(braket
l_int|4
)braket
op_assign
id|cmd
(braket
l_int|2
)braket
suffix:semicolon
id|new_cmd
(braket
l_int|5
)braket
op_assign
id|cmd
(braket
l_int|3
)braket
suffix:semicolon
id|new_cmd
(braket
l_int|6
)braket
op_assign
l_int|0x0
suffix:semicolon
id|new_cmd
(braket
l_int|7
)braket
op_assign
l_int|0x0
suffix:semicolon
id|new_cmd
(braket
l_int|8
)braket
op_assign
id|cmd
(braket
l_int|4
)braket
suffix:semicolon
id|new_cmd
(braket
l_int|9
)braket
op_assign
id|cmd
(braket
l_int|5
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|cmd
comma
id|new_cmd
comma
l_int|10
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WRITE_6
suffix:colon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: Convert WRITE_6 to WRITE_10&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Need to turn write_6 into write_10&n;&t;&t;&t; */
id|new_cmd
(braket
l_int|0
)braket
op_assign
l_int|0x2a
suffix:semicolon
id|new_cmd
(braket
l_int|1
)braket
op_assign
(paren
id|cmd
(braket
l_int|1
)braket
op_amp
l_int|0xe0
)paren
suffix:semicolon
id|new_cmd
(braket
l_int|2
)braket
op_assign
l_int|0x0
suffix:semicolon
id|new_cmd
(braket
l_int|3
)braket
op_assign
(paren
id|cmd
(braket
l_int|1
)braket
op_amp
l_int|0x1f
)paren
suffix:semicolon
id|new_cmd
(braket
l_int|4
)braket
op_assign
id|cmd
(braket
l_int|2
)braket
suffix:semicolon
id|new_cmd
(braket
l_int|5
)braket
op_assign
id|cmd
(braket
l_int|3
)braket
suffix:semicolon
id|new_cmd
(braket
l_int|6
)braket
op_assign
l_int|0x0
suffix:semicolon
id|new_cmd
(braket
l_int|7
)braket
op_assign
l_int|0x0
suffix:semicolon
id|new_cmd
(braket
l_int|8
)braket
op_assign
id|cmd
(braket
l_int|4
)braket
suffix:semicolon
id|new_cmd
(braket
l_int|9
)braket
op_assign
id|cmd
(braket
l_int|5
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|cmd
comma
id|new_cmd
comma
l_int|10
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MODE_SENSE
suffix:colon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: Convert MODE_SENSE_6 to MOSE_SENSE_10&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Need to turn mode_sense_6 into mode_sense_10&n;&t;&t;&t; */
id|new_cmd
(braket
l_int|0
)braket
op_assign
l_int|0x5a
suffix:semicolon
id|new_cmd
(braket
l_int|1
)braket
op_assign
id|cmd
(braket
l_int|1
)braket
suffix:semicolon
id|new_cmd
(braket
l_int|2
)braket
op_assign
id|cmd
(braket
l_int|2
)braket
suffix:semicolon
id|new_cmd
(braket
l_int|3
)braket
op_assign
l_int|0x0
suffix:semicolon
id|new_cmd
(braket
l_int|4
)braket
op_assign
l_int|0x0
suffix:semicolon
id|new_cmd
(braket
l_int|5
)braket
op_assign
l_int|0x0
suffix:semicolon
id|new_cmd
(braket
l_int|6
)braket
op_assign
l_int|0x0
suffix:semicolon
id|new_cmd
(braket
l_int|7
)braket
op_assign
l_int|0x0
suffix:semicolon
id|new_cmd
(braket
l_int|8
)braket
op_assign
id|cmd
(braket
l_int|4
)braket
suffix:semicolon
id|new_cmd
(braket
l_int|9
)braket
op_assign
id|cmd
(braket
l_int|5
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|cmd
comma
id|new_cmd
comma
l_int|10
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MODE_SELECT
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * TODO. Probably need to change mode select to 10 byte version&n;&t;&t;&t; */
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Translates SBP-2 status into SCSI sense data for check conditions&n; */
DECL|function|sbp2_status_to_sense_data
r_static
r_int
r_int
id|sbp2_status_to_sense_data
c_func
(paren
id|unchar
op_star
id|sbp2_status
comma
id|unchar
op_star
id|sense_data
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_status_to_sense_data&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, it&squot;s pretty ugly...   ;-)&n;&t; */
id|sense_data
(braket
l_int|0
)braket
op_assign
l_int|0x70
suffix:semicolon
id|sense_data
(braket
l_int|1
)braket
op_assign
l_int|0x0
suffix:semicolon
id|sense_data
(braket
l_int|2
)braket
op_assign
id|sbp2_status
(braket
l_int|9
)braket
suffix:semicolon
id|sense_data
(braket
l_int|3
)braket
op_assign
id|sbp2_status
(braket
l_int|12
)braket
suffix:semicolon
id|sense_data
(braket
l_int|4
)braket
op_assign
id|sbp2_status
(braket
l_int|13
)braket
suffix:semicolon
id|sense_data
(braket
l_int|5
)braket
op_assign
id|sbp2_status
(braket
l_int|14
)braket
suffix:semicolon
id|sense_data
(braket
l_int|6
)braket
op_assign
id|sbp2_status
(braket
l_int|15
)braket
suffix:semicolon
id|sense_data
(braket
l_int|7
)braket
op_assign
l_int|10
suffix:semicolon
id|sense_data
(braket
l_int|8
)braket
op_assign
id|sbp2_status
(braket
l_int|16
)braket
suffix:semicolon
id|sense_data
(braket
l_int|9
)braket
op_assign
id|sbp2_status
(braket
l_int|17
)braket
suffix:semicolon
id|sense_data
(braket
l_int|10
)braket
op_assign
id|sbp2_status
(braket
l_int|18
)braket
suffix:semicolon
id|sense_data
(braket
l_int|11
)braket
op_assign
id|sbp2_status
(braket
l_int|19
)braket
suffix:semicolon
id|sense_data
(braket
l_int|12
)braket
op_assign
id|sbp2_status
(braket
l_int|10
)braket
suffix:semicolon
id|sense_data
(braket
l_int|13
)braket
op_assign
id|sbp2_status
(braket
l_int|11
)braket
suffix:semicolon
id|sense_data
(braket
l_int|14
)braket
op_assign
id|sbp2_status
(braket
l_int|20
)braket
suffix:semicolon
id|sense_data
(braket
l_int|15
)braket
op_assign
id|sbp2_status
(braket
l_int|21
)braket
suffix:semicolon
r_return
id|sbp2_status
(braket
l_int|8
)braket
op_amp
l_int|0x3f
suffix:semicolon
multiline_comment|/* return scsi status */
)brace
multiline_comment|/*&n; * This function is called after a command is completed, in order to do any necessary SBP-2&n; * response data translations for the SCSI stack&n; */
DECL|function|sbp2_check_sbp2_response
r_static
r_void
id|sbp2_check_sbp2_response
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|u8
op_star
id|scsi_buf
op_assign
id|SCpnt-&gt;request_buffer
suffix:semicolon
id|u32
id|device_type
op_assign
(paren
id|scsi_id-&gt;sbp2_device_type_and_lun
op_amp
l_int|0x00ff0000
)paren
op_rshift
l_int|16
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_check_sbp2_response&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|INQUIRY
suffix:colon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: Check Inquiry data&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Check for Simple Direct Access Device and change it to TYPE_DISK&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|scsi_buf
(braket
l_int|0
)braket
op_amp
l_int|0x1f
)paren
op_eq
id|TYPE_SDAD
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: Changing TYPE_SDAD to TYPE_DISK&quot;
)paren
suffix:semicolon
id|scsi_buf
(braket
l_int|0
)braket
op_and_assign
l_int|0xe0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Fix ansi revision and response data format&n;&t;&t;&t; */
id|scsi_buf
(braket
l_int|2
)braket
op_or_assign
l_int|2
suffix:semicolon
id|scsi_buf
(braket
l_int|3
)braket
op_assign
(paren
id|scsi_buf
(braket
l_int|3
)braket
op_amp
l_int|0xf0
)paren
op_or
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MODE_SENSE
suffix:colon
r_if
c_cond
(paren
(paren
id|device_type
op_eq
id|TYPE_DISK
)paren
op_logical_or
(paren
id|device_type
op_eq
id|TYPE_SDAD
)paren
op_logical_or
(paren
id|device_type
op_eq
id|TYPE_ROM
)paren
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: Modify mode sense response (10 byte version)&quot;
)paren
suffix:semicolon
id|scsi_buf
(braket
l_int|0
)braket
op_assign
id|scsi_buf
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Mode data length */
id|scsi_buf
(braket
l_int|1
)braket
op_assign
id|scsi_buf
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Medium type */
id|scsi_buf
(braket
l_int|2
)braket
op_assign
id|scsi_buf
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Device specific parameter */
id|scsi_buf
(braket
l_int|3
)braket
op_assign
id|scsi_buf
(braket
l_int|7
)braket
suffix:semicolon
multiline_comment|/* Block descriptor length */
id|memcpy
c_func
(paren
id|scsi_buf
op_plus
l_int|4
comma
id|scsi_buf
op_plus
l_int|8
comma
id|scsi_buf
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|MODE_SELECT
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * TODO. Probably need to change mode select to 10 byte version&n;&t;&t;&t; */
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This function deals with status writes from the SBP-2 device&n; */
DECL|function|sbp2_handle_status_write
r_static
r_int
id|sbp2_handle_status_write
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
comma
r_int
id|nodeid
comma
r_int
id|destid
comma
id|quadlet_t
op_star
id|data
comma
id|u64
id|addr
comma
r_int
r_int
id|length
)paren
(brace
r_struct
id|sbp2scsi_host_info
op_star
id|hi
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
id|u32
id|scsi_status
op_assign
id|SBP2_SCSI_STATUS_GOOD
suffix:semicolon
r_struct
id|sbp2_command_info
op_star
id|command
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_handle_status_write&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|host
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: host is NULL - this is bad!&quot;
)paren
suffix:semicolon
r_return
id|RCODE_ADDRESS_ERROR
suffix:semicolon
)brace
id|sbp2_spin_lock
c_func
(paren
op_amp
id|sbp2_host_info_lock
comma
id|flags
)paren
suffix:semicolon
id|hi
op_assign
id|sbp2_find_host_info
c_func
(paren
id|host
)paren
suffix:semicolon
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|sbp2_host_info_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hi
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: host info is NULL - this is bad!&quot;
)paren
suffix:semicolon
r_return
id|RCODE_ADDRESS_ERROR
suffix:semicolon
)brace
id|sbp2_spin_lock
c_func
(paren
op_amp
id|hi-&gt;sbp2_command_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Find our scsi_id structure&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SBP2SCSI_MAX_SCSI_IDS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hi-&gt;scsi_id
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|node_id
op_eq
(paren
id|nodeid
op_amp
id|NODE_MASK
)paren
)paren
(brace
id|scsi_id
op_assign
id|hi-&gt;scsi_id
(braket
id|i
)braket
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: SBP-2 status write from node %x&quot;
comma
id|scsi_id-&gt;node_id
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|scsi_id
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: scsi_id is NULL - device is gone?&quot;
)paren
suffix:semicolon
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|hi-&gt;sbp2_command_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|RCODE_ADDRESS_ERROR
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Put response into scsi_id status fifo... &n;&t; */
id|memcpy
c_func
(paren
op_amp
id|scsi_id-&gt;status_block
comma
id|data
comma
id|length
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Byte swap first two quadlets (8 bytes) of status for processing&n;&t; */
id|sbp2util_be32_to_cpu_buffer
c_func
(paren
op_amp
id|scsi_id-&gt;status_block
comma
l_int|8
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Handle command ORB status here if necessary. First, need to match status with command.&n;&t; */
id|command
op_assign
id|sbp2util_find_command_for_orb
c_func
(paren
id|scsi_id
comma
id|scsi_id-&gt;status_block.ORB_offset_lo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|command
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: Found status for command ORB&quot;
)paren
suffix:semicolon
id|SBP2_ORB_DEBUG
c_func
(paren
l_string|&quot;matched command orb %p&quot;
comma
op_amp
id|command-&gt;command_orb
)paren
suffix:semicolon
id|outstanding_orb_decr
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Matched status with command, now grab scsi command pointers and check status&n;&t;&t; */
id|SCpnt
op_assign
id|command-&gt;Current_SCpnt
suffix:semicolon
id|sbp2util_mark_command_completed
c_func
(paren
id|scsi_id
comma
id|command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt
op_logical_and
op_logical_neg
id|command-&gt;linked
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Handle check conditions&n;&t;&t;&t; */
r_if
c_cond
(paren
id|STATUS_GET_SBP_STATUS
c_func
(paren
id|scsi_id-&gt;status_block.ORB_offset_hi_misc
)paren
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: CHECK CONDITION&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Translate SBP-2 status to SCSI sense data&n;&t;&t;&t;&t; */
id|scsi_status
op_assign
id|sbp2_status_to_sense_data
c_func
(paren
(paren
id|unchar
op_star
)paren
op_amp
id|scsi_id-&gt;status_block
comma
id|SCpnt-&gt;sense_buffer
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Initiate a fetch agent reset. &n;&t;&t;&t;&t; */
id|sbp2_agent_reset
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|SBP2_SEND_NO_WAIT
)paren
suffix:semicolon
)brace
id|SBP2_ORB_DEBUG
c_func
(paren
l_string|&quot;completing command orb %p&quot;
comma
op_amp
id|command-&gt;command_orb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Complete the SCSI command&n;&t;&t;&t; */
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: Completing SCSI command&quot;
)paren
suffix:semicolon
id|sbp2scsi_complete_command
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|scsi_status
comma
id|SCpnt
comma
id|command-&gt;Current_done
)paren
suffix:semicolon
id|SBP2_ORB_DEBUG
c_func
(paren
l_string|&quot;command orb completed&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Check here to see if there are no commands in-use. If there are none, we can&n;&t;&t; * null out last orb so that next time around we write directly to the orb pointer... &n;&t;&t; * Quick start saves one 1394 bus transaction.&n;&t;&t; */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_inuse
)paren
)paren
(brace
id|scsi_id-&gt;last_orb
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|hi-&gt;sbp2_command_lock
comma
id|flags
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_login_wait
)paren
suffix:semicolon
r_return
id|RCODE_COMPLETE
suffix:semicolon
)brace
multiline_comment|/**************************************&n; * SCSI interface related section&n; **************************************/
multiline_comment|/*&n; * This routine is the main request entry routine for doing I/O. It is &n; * called from the scsi stack directly.&n; */
DECL|function|sbp2scsi_queuecommand
r_static
r_int
id|sbp2scsi_queuecommand
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_struct
id|sbp2scsi_host_info
op_star
id|hi
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2scsi_queuecommand&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Pull our host info and scsi id instance data from the scsi command&n;&t; */
id|hi
op_assign
(paren
r_struct
id|sbp2scsi_host_info
op_star
)paren
id|SCpnt-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hi
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: sbp2scsi_host_info is NULL - this is bad!&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
id|done
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|scsi_id
op_assign
id|hi-&gt;scsi_id
(braket
id|SCpnt-&gt;target
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Save off the command if this is the initial bus scan... so that we can&n;&t; * complete it after we find all our sbp2 devices on the 1394 bus&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|no_bus_scan
op_logical_and
op_logical_neg
id|hi-&gt;initial_scsi_bus_scan_complete
)paren
(brace
id|hi-&gt;bus_scan_SCpnt
op_assign
id|SCpnt
suffix:semicolon
id|hi-&gt;bus_scan_done
op_assign
id|done
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If scsi_id is null, it means there is no device in this slot, so we should return &n;&t; * selection timeout.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|scsi_id
)paren
(brace
id|SCpnt-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
id|done
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Until we handle multiple luns, just return selection time-out to any IO directed at non-zero LUNs&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;lun
)paren
(brace
id|SCpnt-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
id|done
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check for request sense command, and handle it here (autorequest sense)&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: REQUEST_SENSE&quot;
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|SCpnt-&gt;request_buffer
comma
id|SCpnt-&gt;sense_buffer
comma
id|SCpnt-&gt;request_bufflen
)paren
suffix:semicolon
id|memset
c_func
(paren
id|SCpnt-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
(paren
id|SCpnt-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|sbp2scsi_complete_command
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|SBP2_SCSI_STATUS_GOOD
comma
id|SCpnt
comma
id|done
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check to see if there is a command in progress and just return busy (to be queued later)&n;&t; */
r_if
c_cond
(paren
id|hi-&gt;bus_reset_in_progress
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: Bus reset in progress - rejecting command&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
id|done
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Try and send our SCSI command&n;&t; */
id|sbp2_spin_lock
c_func
(paren
op_amp
id|hi-&gt;sbp2_command_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbp2_send_command
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|SCpnt
comma
id|done
)paren
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: Error sending SCSI command&quot;
)paren
suffix:semicolon
id|sbp2scsi_complete_command
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|SBP2_SCSI_STATUS_SELECTION_TIMEOUT
comma
id|SCpnt
comma
id|done
)paren
suffix:semicolon
)brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|hi-&gt;sbp2_command_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called in order to complete all outstanding SBP-2 commands (in case of resets, etc.). &n; */
DECL|function|sbp2scsi_complete_all_commands
r_static
r_void
id|sbp2scsi_complete_all_commands
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
id|u32
id|status
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|sbp2_command_info
op_star
id|command
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2_complete_all_commands&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_inuse
)paren
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: Found pending command to complete&quot;
)paren
suffix:semicolon
id|lh
op_assign
id|scsi_id-&gt;sbp2_command_orb_inuse.next
suffix:semicolon
id|command
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|sbp2_command_info
comma
id|list
)paren
suffix:semicolon
id|sbp2util_mark_command_completed
c_func
(paren
id|scsi_id
comma
id|command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|command-&gt;Current_SCpnt
op_logical_and
op_logical_neg
id|command-&gt;linked
)paren
(brace
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
op_assign
id|command-&gt;Current_done
suffix:semicolon
id|command-&gt;Current_SCpnt-&gt;result
op_assign
id|status
op_lshift
l_int|16
suffix:semicolon
id|done
(paren
id|command-&gt;Current_SCpnt
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called in order to complete a regular SBP-2 command. &n; */
DECL|function|sbp2scsi_complete_command
r_static
r_void
id|sbp2scsi_complete_command
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
id|u32
id|scsi_status
comma
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2scsi_complete_command&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Sanity&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|SCpnt
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: SCpnt is NULL&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If a bus reset is in progress and there was an error, don&squot;t complete the command,&n;&t; * just let it get retried at the end of the bus reset.&n;&t; */
r_if
c_cond
(paren
(paren
id|hi-&gt;bus_reset_in_progress
)paren
op_logical_and
(paren
id|scsi_status
op_ne
id|SBP2_SCSI_STATUS_GOOD
)paren
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: Bus reset in progress - retry command later&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Switch on scsi status&n;&t; */
r_switch
c_cond
(paren
id|scsi_status
)paren
(brace
r_case
id|SBP2_SCSI_STATUS_GOOD
suffix:colon
id|SCpnt-&gt;result
op_assign
id|DID_OK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBP2_SCSI_STATUS_BUSY
suffix:colon
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: SBP2_SCSI_STATUS_BUSY&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBP2_SCSI_STATUS_CHECK_CONDITION
suffix:colon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: SBP2_SCSI_STATUS_CHECK_CONDITION&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|CHECK_CONDITION
op_lshift
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Debug stuff&n;&t;&t;&t; */
id|print_sense
c_func
(paren
l_string|&quot;bh&quot;
comma
id|SCpnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBP2_SCSI_STATUS_SELECTION_TIMEOUT
suffix:colon
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: SBP2_SCSI_STATUS_SELECTION_TIMEOUT&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBP2_SCSI_STATUS_CONDITION_MET
suffix:colon
r_case
id|SBP2_SCSI_STATUS_RESERVATION_CONFLICT
suffix:colon
r_case
id|SBP2_SCSI_STATUS_COMMAND_TERMINATED
suffix:colon
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: Bad SCSI status = %x&quot;
comma
id|scsi_status
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: Unsupported SCSI status = %x&quot;
comma
id|scsi_status
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Take care of any sbp2 response data mucking here (RBC stuff, etc.)&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;result
op_eq
id|DID_OK
)paren
(brace
id|sbp2_check_sbp2_response
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|SCpnt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * One more quick hack (not enabled by default). Some sbp2 devices do not support &n;&t; * mode sense. Turn-on this hack to allow the device to pass the sd driver&squot;s &n;&t; * write-protect test (so that you can mount the device rw).&n;&t; */
r_if
c_cond
(paren
id|mode_sense_hack
op_logical_and
id|SCpnt-&gt;result
op_ne
id|DID_OK
op_logical_and
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SENSE
)paren
(brace
id|SBP2_INFO
c_func
(paren
l_string|&quot;sbp2: Returning success to mode sense command&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_OK
suffix:semicolon
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|memset
(paren
id|SCpnt-&gt;request_buffer
comma
l_int|0
comma
l_int|8
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If a bus reset is in progress and there was an error, complete the command&n;&t; * as busy so that it will get retried.&n;&t; */
r_if
c_cond
(paren
(paren
id|hi-&gt;bus_reset_in_progress
)paren
op_logical_and
(paren
id|scsi_status
op_ne
id|SBP2_SCSI_STATUS_GOOD
)paren
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: Completing command with busy (bus reset)&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If a unit attention occurs, return busy status so it gets retried... it could have happened because&n;&t; * of a 1394 bus reset or hot-plug...&n;&t; */
r_if
c_cond
(paren
(paren
id|scsi_status
op_eq
id|SBP2_SCSI_STATUS_CHECK_CONDITION
)paren
op_logical_and
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_eq
id|UNIT_ATTENTION
)paren
)paren
(brace
id|SBP2_INFO
c_func
(paren
l_string|&quot;sbp2: UNIT ATTENTION - return busy&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Tell scsi stack that we&squot;re done with this command&n;&t; */
id|done
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by scsi stack when something has really gone wrong.&n; * Usually called when a command has timed-out for some reason. &n; */
DECL|function|sbp2scsi_abort
r_static
r_int
id|sbp2scsi_abort
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_struct
id|sbp2scsi_host_info
op_star
id|hi
op_assign
(paren
r_struct
id|sbp2scsi_host_info
op_star
)paren
id|SCpnt-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
op_assign
id|hi-&gt;scsi_id
(braket
id|SCpnt-&gt;target
)braket
suffix:semicolon
r_struct
id|sbp2_command_info
op_star
id|command
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: aborting sbp2 command&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_id
)paren
(brace
multiline_comment|/*&n;&t;&t; * Right now, just return any matching command structures to the free pool (there may&n;&t;&t; * be more than one because of broken up/linked commands).&n;&t;&t; */
id|sbp2_spin_lock
c_func
(paren
op_amp
id|hi-&gt;sbp2_command_lock
comma
id|flags
)paren
suffix:semicolon
r_do
(brace
id|command
op_assign
id|sbp2util_find_command_for_SCpnt
c_func
(paren
id|scsi_id
comma
id|SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|command
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: Found command to abort&quot;
)paren
suffix:semicolon
id|sbp2util_mark_command_completed
c_func
(paren
id|scsi_id
comma
id|command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|command-&gt;Current_SCpnt
op_logical_and
op_logical_neg
id|command-&gt;linked
)paren
(brace
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
op_assign
id|command-&gt;Current_done
suffix:semicolon
id|command-&gt;Current_SCpnt-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|done
(paren
id|command-&gt;Current_SCpnt
)paren
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|command
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Initiate a fetch agent reset. &n;&t;&t; */
id|sbp2_agent_reset
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|SBP2_SEND_NO_WAIT
)paren
suffix:semicolon
id|sbp2scsi_complete_all_commands
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|DID_BUS_BUSY
)paren
suffix:semicolon
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|hi-&gt;sbp2_command_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by scsi stack when something has really gone wrong.&n; */
DECL|function|sbp2scsi_reset
r_static
r_int
id|sbp2scsi_reset
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
r_int
id|reset_flags
)paren
(brace
r_struct
id|sbp2scsi_host_info
op_star
id|hi
op_assign
(paren
r_struct
id|sbp2scsi_host_info
op_star
)paren
id|SCpnt-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: reset requested&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hi
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: generating IEEE-1394 bus reset&quot;
)paren
suffix:semicolon
id|hpsb_reset_bus
c_func
(paren
id|hi-&gt;host
comma
id|LONG_RESET
)paren
suffix:semicolon
)brace
r_return
id|SCSI_RESET_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by scsi stack to get bios parameters (used by fdisk, and at boot).&n; */
DECL|function|sbp2scsi_biosparam
r_static
r_int
id|sbp2scsi_biosparam
(paren
id|Scsi_Disk
op_star
id|disk
comma
id|kdev_t
id|dev
comma
r_int
id|geom
(braket
)braket
)paren
(brace
r_int
id|heads
comma
id|sectors
comma
id|cylinders
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: request for bios parameters&quot;
)paren
suffix:semicolon
id|heads
op_assign
l_int|64
suffix:semicolon
id|sectors
op_assign
l_int|32
suffix:semicolon
id|cylinders
op_assign
id|disk-&gt;capacity
op_div
(paren
id|heads
op_star
id|sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cylinders
OG
l_int|1024
)paren
(brace
id|heads
op_assign
l_int|255
suffix:semicolon
id|sectors
op_assign
l_int|63
suffix:semicolon
id|cylinders
op_assign
id|disk-&gt;capacity
op_div
(paren
id|heads
op_star
id|sectors
)paren
suffix:semicolon
)brace
id|geom
(braket
l_int|0
)braket
op_assign
id|heads
suffix:semicolon
id|geom
(braket
l_int|1
)braket
op_assign
id|sectors
suffix:semicolon
id|geom
(braket
l_int|2
)braket
op_assign
id|cylinders
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called at setup (init) and does nothing. Not used here.   =)&n; */
DECL|function|sbp2scsi_setup
r_void
id|sbp2scsi_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2scsi_setup&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This is our detection routine, and is where we init everything.&n; */
DECL|function|sbp2scsi_detect
r_static
r_int
id|sbp2scsi_detect
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2scsi_detect&quot;
)paren
suffix:semicolon
id|global_scsi_tpnt
op_assign
id|tpnt
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,3,26)
id|global_scsi_tpnt-&gt;proc_name
op_assign
id|SBP2_DEVICE_NAME
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Module load option for force one command at a time&n;&t; */
r_if
c_cond
(paren
id|serialize_io
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: Driver forced to serialize I/O (serialize_io = 1)&quot;
)paren
suffix:semicolon
id|global_scsi_tpnt-&gt;can_queue
op_assign
l_int|1
suffix:semicolon
id|global_scsi_tpnt-&gt;cmd_per_lun
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Module load option to limit max size of requests from the scsi drivers&n;&t; */
r_if
c_cond
(paren
id|no_large_packets
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: Driver forced to limit max transfer size (no_large_packets = 1)&quot;
)paren
suffix:semicolon
id|global_scsi_tpnt-&gt;sg_tablesize
op_assign
l_int|0x1f
suffix:semicolon
id|global_scsi_tpnt-&gt;use_clustering
op_assign
id|DISABLE_CLUSTERING
suffix:semicolon
)brace
r_if
c_cond
(paren
id|no_bus_scan
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: Initial scsi bus scan deferred (no_bus_scan = 1)&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mode_sense_hack
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: Mode sense emulation enabled (mode_sense_hack = 1)&quot;
)paren
suffix:semicolon
)brace
id|sbp2_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sbp2_host_count
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2: Please load the lower level IEEE-1394 driver (e.g. ohci1394) before sbp2...&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbp2_hl_handle
)paren
(brace
id|hpsb_unregister_highlevel
c_func
(paren
id|sbp2_hl_handle
)paren
suffix:semicolon
id|sbp2_hl_handle
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Since we are returning this count, it means that sbp2 must be loaded &quot;after&quot; the &n;&t; * host adapter module... &t; &n;&t; */
r_return
id|sbp2_host_count
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called from sbp2_add_host, and is where we register our scsi host&n; */
DECL|function|sbp2scsi_register_scsi_host
r_static
r_void
id|sbp2scsi_register_scsi_host
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shpnt
op_assign
l_int|NULL
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2scsi_register_scsi_host&quot;
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2scsi_host_info = %p&quot;
comma
id|hi
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Let&squot;s register with the scsi stack&n;&t; */
r_if
c_cond
(paren
id|global_scsi_tpnt
)paren
(brace
id|shpnt
op_assign
id|scsi_register
(paren
id|global_scsi_tpnt
comma
r_sizeof
(paren
r_void
op_star
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If successful, save off a context (to be used when SCSI commands are received)&n;&t;&t; */
r_if
c_cond
(paren
id|shpnt
)paren
(brace
id|shpnt-&gt;hostdata
(braket
l_int|0
)braket
op_assign
(paren
r_int
r_int
)paren
id|hi
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Called when our module is released */
DECL|function|sbp2scsi_release
r_static
r_int
id|sbp2scsi_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2: sbp2scsi_release&quot;
)paren
suffix:semicolon
id|sbp2_cleanup
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Called for contents of procfs */
DECL|function|sbp2scsi_info
r_static
r_const
r_char
op_star
id|sbp2scsi_info
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_return
l_string|&quot;IEEE-1394 SBP-2 protocol driver&quot;
suffix:semicolon
)brace
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;James Goodwin &lt;jamesg@filanet.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;IEEE-1394 SBP-2 protocol driver&quot;
)paren
suffix:semicolon
DECL|variable|SBP2_DEVICE_NAME
id|MODULE_SUPPORTED_DEVICE
c_func
(paren
id|SBP2_DEVICE_NAME
)paren
suffix:semicolon
multiline_comment|/* SCSI host template */
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
(brace
id|name
suffix:colon
l_string|&quot;IEEE1394 SBP-2&quot;
comma
id|detect
suffix:colon
id|sbp2scsi_detect
comma
id|release
suffix:colon
id|sbp2scsi_release
comma
id|info
suffix:colon
id|sbp2scsi_info
comma
id|queuecommand
suffix:colon
id|sbp2scsi_queuecommand
comma
m_abort
suffix:colon
id|sbp2scsi_abort
comma
id|reset
suffix:colon
id|sbp2scsi_reset
comma
id|bios_param
suffix:colon
id|sbp2scsi_biosparam
comma
id|can_queue
suffix:colon
id|SBP2SCSI_MAX_OUTSTANDING_CMDS
comma
id|this_id
suffix:colon
op_minus
l_int|1
comma
id|sg_tablesize
suffix:colon
id|SBP2_MAX_SG_ELEMENTS
comma
id|cmd_per_lun
suffix:colon
id|SBP2SCSI_MAX_CMDS_PER_LUN
comma
id|use_clustering
suffix:colon
id|SBP2_CLUSTERING
comma
id|emulated
suffix:colon
l_int|1
)brace
suffix:semicolon
macro_line|#include &quot;../scsi/scsi_module.c&quot;
eof
