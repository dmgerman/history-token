multiline_comment|/*&n; * sbp2.c - SBP-2 protocol driver for IEEE-1394&n; *&n; * Copyright (C) 2000 James Goodwin, Filanet Corporation (www.filanet.com)&n; * jamesg@filanet.com&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software Foundation,&n; * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.&n; */
multiline_comment|/*&n; * Brief Description:&n; *&n; * This driver implements the Serial Bus Protocol 2 (SBP-2) over IEEE-1394&n; * under Linux. The SBP-2 driver is implemented as an IEEE-1394 high-level&n; * driver. It also registers as a SCSI lower-level driver in order to accept&n; * SCSI commands for transport using SBP-2.&n; *&n; * Driver Loading:&n; *&n; * Currently, the SBP-2 driver is supported only as a module. Because the &n; * Linux SCSI stack is not Plug-N-Play aware, module load order is &n; * important. Assuming the SCSI core drivers are either built into the &n; * kernel or already loaded as modules, you should load the IEEE-1394 modules &n; * in the following order:&n; *&n; * &t;ieee1394 (e.g. insmod ieee1394)&n; *&t;ohci1394 (e.g. insmod ohci1394)&n; *&t;sbp2 (e.g. insmod sbp2)&n; *&n; * The SBP-2 driver will attempt to discover any attached SBP-2 devices when first&n; * loaded, or after any IEEE-1394 bus reset (e.g. a hot-plug). It will then print &n; * out a debug message indicating if it was able to discover a SBP-2 device.&n; *&n; * Currently, the SBP-2 driver will catch any attached SBP-2 devices during the&n; * initial scsi bus scan (when the driver is first loaded). To add or remove&n; * SBP-2 devices after this initial scan (i.e. if you plug-in or un-plug a &n; * device after the SBP-2 driver is loaded), you must either use the scsi procfs&n; * add-single-device, remove-single-device, or a shell script such as &n; * rescan-scsi-bus.sh.&n; *&n; * The easiest way to add/detect new SBP-2 devices is to run the shell script&n; * rescan-scsi-bus.sh (or re-load the SBP-2 driver). This script may be &n; * found at:&n; * http://www.garloff.de/kurt/linux/rescan-scsi-bus.sh&n; *&n; * As an alternative, you may manually add/remove SBP-2 devices via the procfs with&n; * add-single-device &lt;h&gt; &lt;b&gt; &lt;t&gt; &lt;l&gt; or remove-single-device &lt;h&gt; &lt;b&gt; &lt;t&gt; &lt;l&gt;, where:&n; *&t;&lt;h&gt; = host (starting at zero for first SCSI adapter)&n; *&t;&lt;b&gt; = bus (normally zero)&n; *&t;&lt;t&gt; = target (starting at zero for first SBP-2 device)&n; *&t;&lt;l&gt; = lun (normally zero)&n; *&n; * e.g. To manually add/detect a new SBP-2 device&n; *&t;echo &quot;scsi add-single-device 0 0 0 0&quot; &gt; /proc/scsi/scsi&n; *&n; * e.g. To manually remove a SBP-2 device after it&squot;s been unplugged&n; *&t;echo &quot;scsi remove-single-device 0 0 0 0&quot; &gt; /proc/scsi/scsi&n; *&n; * e.g. To check to see which SBP-2/SCSI devices are currently registered&n; * &t;cat /proc/scsi/scsi&n; *&n; * After scanning for new SCSI devices (above), you may access any attached &n; * SBP-2 storage devices as if they were SCSI devices (e.g. mount /dev/sda1, &n; * fdisk, mkfs, etc.).&n; *&n; *&n; * Current Support:&n; *&n; * The SBP-2 driver is still in an early state, but supports a variety of devices.&n; * I have read/written many gigabytes of data from/to SBP-2 drives, and have seen &n; * performance of more than 16 MBytes/s on individual drives (limit of the media &n; * transfer rate).&n; *&n; * Following are the devices that have been tested successfully:&n; *&n; *&t;- Western Digital IEEE-1394 hard drives&n; *&t;- Maxtor IEEE-1394 hard drives&n; *&t;- VST (SmartDisk) IEEE-1394 hard drives and Zip drives (several flavors)&n; *&t;- LaCie IEEE-1394 hard drives (several flavors)&n; *&t;- QPS IEEE-1394 CD-RW/DVD drives and hard drives&n; *&t;- BusLink IEEE-1394 hard drives&n; *&t;- Iomega IEEE-1394 Zip/Jazz drives&n; *&t;- ClubMac IEEE-1394 hard drives&n; *&t;- FirePower IEEE-1394 hard drives&n; *&t;- EzQuest IEEE-1394 hard drives and CD-RW drives&n; *&t;- Castlewood/ADS IEEE-1394 ORB drives&n; *&t;- Evergreen IEEE-1394 hard drives and CD-RW drives&n; *&t;- Addonics IEEE-1394 CD-RW drives&n; *&t;- Bellstor IEEE-1394 hard drives and CD-RW drives&n; *&t;- APDrives IEEE-1394 hard drives&n; *&t;- Fujitsu IEEE-1394 MO drives&n; *&t;- Sony IEEE-1394 CD-RW drives&n; *&t;- Epson IEEE-1394 scanner&n; *&t;- ADS IEEE-1394 memory stick and compact flash readers &n; *&t;  (e.g. &quot;insmod sbp2 mode_sense_hack=1&quot; for mem stick and flash readers))&n; *&t;- SBP-2 bridge-based devices (LSI, Oxford Semiconductor, Indigita bridges)&n; *&t;- Various other standard IEEE-1394 hard drives and enclosures&n; *&n; *&n; * Performance Issues:&n; *&n; *&t;- Make sure you are &quot;not&quot; running fat/fat32 on your attached SBP-2 drives. You&squot;ll&n; *&t;  get much better performance formatting the drive ext2 (but you will lose the&n; *&t;  ability to easily move the drive between Windows/Linux).&n; *&n; *&n; * Current Issues:&n; *&n; *&t;- Currently, all I/O from the scsi stack is serialized by default, as there&n; *&t;  are some stress issues under investigation with deserialized I/O. To enable&n; *&t;  deserialized I/O for testing, do &quot;insmod sbp2 serialize_io=0&quot;&n; *&n; *&t;- Error Handling: SCSI aborts and bus reset requests are handled somewhat&n; *&t;  but the code needs additional debugging.&n; *&n; *&t;- The SBP-2 driver is currently only supported as a module. It would not take&n; *&t;  much work to allow it to be compiled into the kernel, but you&squot;d have to &n; *&t;  add some init code to the kernel to support this... and modules are much&n; *&t;  more flexible anyway.   ;-)&n; *&n; *     - The scsi stack in recent kernels pass down the data transfer&n; *       direction as scsicmd-&gt;sc_data_direction, which we should use&n; *       instead of the sbp2scsi_direction_table.&n; *&n; *&n; * History:&n; *&n; *&t;07/25/00 - Initial revision (JSG)&n; *&t;08/11/00 - Following changes/bug fixes were made (JSG):&n; *&t;&t;   * Bug fix to SCSI procfs code (still needs to be synched with 2.4 kernel).&n; *&t;&t;   * Bug fix where request sense commands were actually sent on the bus.&n; *&t;&t;   * Changed bus reset/abort code to deal with devices that spin up quite&n; *&t;&t;     slowly (which result in SCSI time-outs).&n; *&t;&t;   * &quot;More&quot; properly pull information from device&squot;s config rom, for enumeration&n; *&t;&t;     of SBP-2 devices, and determining SBP-2 register offsets.&n; *&t;&t;   * Change Simplified Direct Access Device type to Direct Access Device type in&n; *&t;&t;     returned inquiry data, in order to make the SCSI stack happy.&n; *&t;&t;   * Modified driver to register with the SCSI stack &quot;before&quot; enumerating any attached&n; *&t;&t;     SBP-2 devices. This means that you&squot;ll have to use procfs scsi-add-device or &n; *&t;&t;     some sort of script to discover new SBP-2 devices.&n; *&t;&t;   * Minor re-write of some code and other minor changes.&n; *&t;08/28/00 - Following changes/bug fixes were made (JSG):&n; *&t;&t;   * Bug fixes to scatter/gather support (case of one s/g element)&n; *&t;&t;   * Updated direction table for scsi commands (mostly DVD commands)&n; *&t;&t;   * Retries when trying to detect SBP-2 devices (for slow devices)&n; *&t;&t;   * Slightly better error handling (previously none) when commands time-out.&n; *&t;&t;   * Misc. other bug fixes and code reorganization.&n; *&t;09/13/00 - Following changes/bug fixes were made (JSG)&n; *&t;&t;   * Moved detection/enumeration code to a kernel thread which is woken up when IEEE-1394&n; *&t;&t;     bus resets occur.&n; *&t;&t;   * Added code to handle bus resets and hot-plugging while devices are mounted, but full&n; *&t;&t;     hot-plug support is not quite there yet.&n; *&t;&t;   * Now use speed map to determine speed and max payload sizes for ORBs&n; *&t;&t;   * Clean-up of code and reorganization &n; *&t;09/19/00 - Added better hot-plug support and other minor changes (JSG)&n; *&t;10/15/00 - Fixes for latest 2.4.0 test kernel, minor fix for hot-plug race. (JSG)&n; *&t;12/03/00 - Created pool of request packet structures for use in sending out sbp2 command&n; *&t;&t;   and agent reset requests. This removes the kmallocs/kfrees in the critical I/O paths,&n; *&t;&t;   and also deals with some subtle race conditions related to allocating and freeing&n; *&t;&t;   packets. (JSG)&n; *      12/09/00 - Improved the sbp2 device detection by actually reading the root and unit &n; *&t;&t;   directory (khk@khk.net)&n; *&t;12/23/00 - Following changes/enhancements were made (JSG)&n; *&t;&t;   * Only do SCSI to RBC command conversion for Direct Access and Simplified&n; *&t;&t;     Direct Access Devices (this is pulled from the config rom root directory).&n; *&t;&t;     This is needed because doing the conversion for all device types broke the&n; *&t;&t;     Epson scanner. Still looking for a better way of determining when to convert&n; *&t;&t;     commands (for RBC devices). Thanks to khk for helping on this!&n; *&t;&t;   * Added ability to &quot;emulate&quot; physical dma support, for host adapters such as TILynx.&n; *&t;&t;   * Determine max payload and speed by also looking at the host adapter&squot;s max_rec field.&n; *&t;01/19/01 - Added checks to sbp2 login and made the login time-out longer. Also fixed a compile &n; *&t;&t;   problem for 2.4.0. (JSG)&n; *&t;01/24/01 - Fixed problem when individual s/g elements are 64KB or larger. Needed to break&n; *&t;&t;   up these larger elements, since the sbp2 page table element size is only 16 bits. (JSG)&n; *&t;01/29/01 - Minor byteswap fix for login response (used for reconnect and log out).&n; *&t;03/07/01 - Following changes/enhancements were made (JSG)&n; *&t;&t;   * Changes to allow us to catch the initial scsi bus scan (for detecting sbp2&n; *&t;&t;     devices when first loading sbp2.o). To disable this, un-define &n; *&t;&t;     SBP2_SUPPORT_INITIAL_BUS_SCAN.&n; *&t;&t;   * Temporary fix to deal with many sbp2 devices that do not support individual&n; *&t;&t;     transfers of greater than 128KB in size. &n; *&t;&t;   * Mode sense conversion from 6 byte to 10 byte versions for CDRW/DVD devices. (Mark Burton)&n; *&t;&t;   * Define allowing support for goofy sbp2 devices that do not support mode&n; *&t;&t;     sense command at all, allowing them to be mounted rw (such as 1394 memory&n; *&t;&t;     stick and compact flash readers). Define SBP2_MODE_SENSE_WRITE_PROTECT_HACK&n; *&t;&t;     if you need this fix.&n; *&t;03/29/01 - Major performance enhancements and misc. other changes. Thanks to Daniel Berlin for many of&n; *&t;&t;   changes and suggestions for change:&n; *&t;&t;   * Now use sbp2 doorbell and link commands on the fly (instead of serializing requests)&n; *&t;&t;   * Removed all bit fields in an attempt to run on PPC machines (still needs a little more work)&n; *&t;&t;   * Added large request break-up/linking support for sbp2 chipsets that do not support transfers &n; *&t;&t;     greater than 128KB in size.&n; *&t;&t;   * Bumped up max commands per lun to two, and max total outstanding commands to eight.&n; *&t;04/03/01 - Minor clean-up. Write orb pointer directly if no outstanding commands (saves one 1394 bus&n; *&t;&t;   transaction). Added module load options (bus scan, mode sense hack, max speed, serialize_io,&n; *&t;&t;   no_large_transfers). Better bus reset handling while I/O pending. Set serialize_io to 1 by &n; *&t;&t;   default (debugging of deserialized I/O in progress).&n; *&t;04/04/01 - Added workaround for PPC Pismo firewire chipset. See #define below. (Daniel Berlin)&n; *&t;04/20/01 - Minor clean-up. Allocate more orb structures when running with sbp2 target chipsets with&n; *&t;&t;   128KB max transfer limit.&n; *&t;06/16/01 - Converted DMA interfaces to pci_dma - Ben Collins&n; *&t;&t;&t;&t;&t;&t;&t; &lt;bcollins@debian.org&n; *&t;07/22/01 - Use NodeMngr to get info about the local host and&n; *&t;&t;   attached devices. Ben Collins&n; *&n; *      09/15/01 - Remove detection code, instead subscribe to the nodemgr&n; *                 driver management interface.  This also removes the&n; *                 initial bus scan stuff since the nodemgr calls&n; *                 sbp2_probe for each sbp2 device already on the bus,&n; *                 when we register our driver.  This change &n; *                 automtically adds hotplug support to the driver.&n; *                                 Kristian Hogsberg &lt;hogsberg@users.sf.net&gt;&n; */
"&f;"
multiline_comment|/*&n; * Includes&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/current.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/scatterlist.h&gt;
macro_line|#include &quot;ieee1394.h&quot;
macro_line|#include &quot;ieee1394_types.h&quot;
macro_line|#include &quot;ieee1394_core.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;nodemgr.h&quot;
macro_line|#include &quot;highlevel.h&quot;
macro_line|#include &quot;ieee1394_transactions.h&quot;
macro_line|#include &quot;ieee1394_hotplug.h&quot;
macro_line|#include &quot;../scsi/scsi.h&quot;
macro_line|#include &quot;../scsi/hosts.h&quot;
macro_line|#include &quot;../scsi/sd.h&quot;
macro_line|#include &quot;sbp2.h&quot;
multiline_comment|/*&n; * Module load parameter definitions&n; */
multiline_comment|/*&n; * Set mode_sense_hack to 1 if you have some sort of unusual sbp2 device,&n; * like a 1394 memory stick reader, compact flash reader, or MO drive that&n; * does not support mode sense. Allows you to mount the media rw instead&n; * of ro.&n; */
id|MODULE_PARM
c_func
(paren
id|mode_sense_hack
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|mode_sense_hack
comma
l_string|&quot;Emulate mode sense for devices like 1394 memory stick readers&quot;
)paren
suffix:semicolon
DECL|variable|mode_sense_hack
r_static
r_int
id|mode_sense_hack
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Change max_speed on module load if you have a bad IEEE-1394 controller&n; * that has trouble running 2KB packets at 400mb.&n; *&n; * NOTE: On certain OHCI parts I have seen short packets on async transmit&n; * (probably due to PCI latency/throughput issues with the part). You can&n; * bump down the speed if you are running into problems.&n; *&n; * Valid values:&n; * max_speed = 2 (default: max speed 400mb)&n; * max_speed = 1 (max speed 200mb)&n; * max_speed = 0 (max speed 100mb)&n; */
id|MODULE_PARM
c_func
(paren
id|max_speed
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|max_speed
comma
l_string|&quot;Force down max speed (2 = 400mb default, 1 = 200mb, 0 = 100mb)&quot;
)paren
suffix:semicolon
DECL|variable|max_speed
r_static
r_int
id|max_speed
op_assign
id|SPEED_400
suffix:semicolon
multiline_comment|/*&n; * Set serialize_io to 1 if you&squot;d like only one scsi command sent down to&n; * us at a time (debugging).&n; */
id|MODULE_PARM
c_func
(paren
id|serialize_io
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|serialize_io
comma
l_string|&quot;Serialize all I/O coming down from the scsi drivers (debugging)&quot;
)paren
suffix:semicolon
DECL|variable|serialize_io
r_static
r_int
id|serialize_io
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* serialize I/O until stress issues are resolved */
multiline_comment|/*&n; * Set no_large_packets to 1 if you&squot;d like to limit the size of requests&n; * sent down to us (normally the sbp2 driver will break up any requests to&n; * any individual devices with 128KB transfer size limits).  Sets max s/g&n; * list elements to 0x1f in size and disables s/g clustering.&n; */
id|MODULE_PARM
c_func
(paren
id|no_large_packets
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|no_large_packets
comma
l_string|&quot;Do not allow large transfers from scsi drivers (debugging)&quot;
)paren
suffix:semicolon
DECL|variable|no_large_packets
r_static
r_int
id|no_large_packets
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Export information about protocols/devices supported by this driver.&n; */
DECL|variable|sbp2_id_table
r_static
r_struct
id|ieee1394_device_id
id|sbp2_id_table
(braket
)braket
op_assign
(brace
(brace
id|match_flags
suffix:colon
id|IEEE1394_MATCH_SPECIFIER_ID
op_or
id|IEEE1394_MATCH_VERSION
comma
id|specifier_id
suffix:colon
id|SBP2_UNIT_SPEC_ID_ENTRY
op_amp
l_int|0xffffff
comma
id|version
suffix:colon
id|SBP2_SW_VERSION_ENTRY
op_amp
l_int|0xffffff
)brace
comma
(brace
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|ieee1394
comma
id|sbp2_id_table
)paren
suffix:semicolon
multiline_comment|/*&n; * Debug levels, configured via kernel config.&n; */
macro_line|#ifdef CONFIG_IEEE1394_SBP2_DEBUG_ORBS
DECL|macro|SBP2_ORB_DEBUG
mdefine_line|#define SBP2_ORB_DEBUG(fmt, args...)&t;HPSB_ERR(&quot;sbp2(&quot;__FUNCTION__&quot;): &quot;fmt, ## args)
DECL|variable|global_outstanding_command_orbs
r_static
id|u32
id|global_outstanding_command_orbs
op_assign
l_int|0
suffix:semicolon
DECL|macro|outstanding_orb_incr
mdefine_line|#define outstanding_orb_incr global_outstanding_command_orbs++
DECL|macro|outstanding_orb_decr
mdefine_line|#define outstanding_orb_decr global_outstanding_command_orbs--
macro_line|#else
DECL|macro|SBP2_ORB_DEBUG
mdefine_line|#define SBP2_ORB_DEBUG(fmt, args...)
DECL|macro|outstanding_orb_incr
mdefine_line|#define outstanding_orb_incr
DECL|macro|outstanding_orb_decr
mdefine_line|#define outstanding_orb_decr
macro_line|#endif
macro_line|#ifdef CONFIG_IEEE1394_SBP2_DEBUG_DMA
DECL|macro|SBP2_DMA_ALLOC
mdefine_line|#define SBP2_DMA_ALLOC(fmt, args...) &bslash;&n;&t;HPSB_ERR(&quot;sbp2(&quot;__FUNCTION__&quot;)alloc(%d): &quot;fmt, &bslash;&n;&t;&t; ++global_outstanding_dmas, ## args)
DECL|macro|SBP2_DMA_FREE
mdefine_line|#define SBP2_DMA_FREE(fmt, args...) &bslash;&n;&t;HPSB_ERR(&quot;sbp2(&quot;__FUNCTION__&quot;)free(%d): &quot;fmt, &bslash;&n;&t;&t; --global_outstanding_dmas, ## args)
DECL|variable|global_outstanding_dmas
r_static
id|u32
id|global_outstanding_dmas
op_assign
l_int|0
suffix:semicolon
macro_line|#else
DECL|macro|SBP2_DMA_ALLOC
mdefine_line|#define SBP2_DMA_ALLOC(fmt, args...)
DECL|macro|SBP2_DMA_FREE
mdefine_line|#define SBP2_DMA_FREE(fmt, args...)
macro_line|#endif
macro_line|#if CONFIG_IEEE1394_SBP2_DEBUG &gt;= 2
DECL|macro|SBP2_DEBUG
mdefine_line|#define SBP2_DEBUG(fmt, args...)&t;HPSB_ERR(&quot;sbp2: &quot;fmt, ## args)
DECL|macro|SBP2_INFO
mdefine_line|#define SBP2_INFO(fmt, args...)&t;&t;HPSB_ERR(&quot;sbp2: &quot;fmt, ## args)
DECL|macro|SBP2_NOTICE
mdefine_line|#define SBP2_NOTICE(fmt, args...)&t;HPSB_ERR(&quot;sbp2: &quot;fmt, ## args)
DECL|macro|SBP2_WARN
mdefine_line|#define SBP2_WARN(fmt, args...)&t;&t;HPSB_ERR(&quot;sbp2: &quot;fmt, ## args)
macro_line|#elif CONFIG_IEEE1394_SBP2_DEBUG == 1
DECL|macro|SBP2_DEBUG
mdefine_line|#define SBP2_DEBUG(fmt, args...)&t;HPSB_DEBUG(&quot;sbp2: &quot;fmt, ## args)
DECL|macro|SBP2_INFO
mdefine_line|#define SBP2_INFO(fmt, args...)&t;&t;HPSB_INFO(&quot;sbp2: &quot;fmt, ## args)
DECL|macro|SBP2_NOTICE
mdefine_line|#define SBP2_NOTICE(fmt, args...)&t;HPSB_NOTICE(&quot;sbp2: &quot;fmt, ## args)
DECL|macro|SBP2_WARN
mdefine_line|#define SBP2_WARN(fmt, args...)&t;&t;HPSB_WARN(&quot;sbp2: &quot;fmt, ## args)
macro_line|#else 
DECL|macro|SBP2_DEBUG
mdefine_line|#define SBP2_DEBUG(fmt, args...)
DECL|macro|SBP2_INFO
mdefine_line|#define SBP2_INFO(fmt, args...)
DECL|macro|SBP2_NOTICE
mdefine_line|#define SBP2_NOTICE(fmt, args...)
DECL|macro|SBP2_WARN
mdefine_line|#define SBP2_WARN(fmt, args...)
macro_line|#endif
DECL|macro|SBP2_ERR
mdefine_line|#define SBP2_ERR(fmt, args...)&t;&t;HPSB_ERR(&quot;sbp2: &quot;fmt, ## args)
multiline_comment|/*&n; * Spinlock debugging stuff. I&squot;m playing it safe until the driver has been&n; * debugged on SMP. (JSG)&n; */
multiline_comment|/* #define SBP2_USE_REAL_SPINLOCKS */
macro_line|#ifdef SBP2_USE_REAL_SPINLOCKS
DECL|macro|sbp2_spin_lock
mdefine_line|#define sbp2_spin_lock(lock, flags)&t;spin_lock_irqsave(lock, flags)&t;
DECL|macro|sbp2_spin_unlock
mdefine_line|#define sbp2_spin_unlock(lock, flags)&t;spin_unlock_irqrestore(lock, flags);
DECL|variable|sbp2_host_info_lock
r_static
id|spinlock_t
id|sbp2_host_info_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
macro_line|#else
DECL|macro|sbp2_spin_lock
mdefine_line|#define sbp2_spin_lock(lock, flags)&t;do {save_flags(flags); cli();} while (0)&t;
DECL|macro|sbp2_spin_unlock
mdefine_line|#define sbp2_spin_unlock(lock, flags)&t;do {restore_flags(flags);} while (0)
macro_line|#endif
multiline_comment|/*&n; * Globals&n; */
DECL|variable|global_scsi_tpnt
id|Scsi_Host_Template
op_star
id|global_scsi_tpnt
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|sbp2_speedto_maxrec
r_static
id|u8
id|sbp2_speedto_maxrec
(braket
)braket
op_assign
(brace
l_int|0x7
comma
l_int|0x8
comma
l_int|0x9
)brace
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|sbp2_host_info_list
)paren
suffix:semicolon
DECL|variable|sbp2_host_count
r_static
r_int
id|sbp2_host_count
op_assign
l_int|0
suffix:semicolon
DECL|variable|sbp2_hl_handle
r_static
r_struct
id|hpsb_highlevel
op_star
id|sbp2_hl_handle
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|sbp2_hl_ops
r_static
r_struct
id|hpsb_highlevel_ops
id|sbp2_hl_ops
op_assign
(brace
id|add_host
suffix:colon
id|sbp2_add_host
comma
id|remove_host
suffix:colon
id|sbp2_remove_host
comma
)brace
suffix:semicolon
DECL|variable|sbp2_ops
r_static
r_struct
id|hpsb_address_ops
id|sbp2_ops
op_assign
(brace
id|write
suffix:colon
id|sbp2_handle_status_write
)brace
suffix:semicolon
DECL|variable|sbp2_driver
r_static
r_struct
id|hpsb_protocol_driver
id|sbp2_driver
op_assign
(brace
id|name
suffix:colon
l_string|&quot;SBP2 Driver&quot;
comma
id|id_table
suffix:colon
id|sbp2_id_table
comma
id|probe
suffix:colon
id|sbp2_probe
comma
id|disconnect
suffix:colon
id|sbp2_disconnect
comma
id|update
suffix:colon
id|sbp2_update
)brace
suffix:semicolon
"&f;"
multiline_comment|/**************************************&n; * General utility functions&n; **************************************/
macro_line|#ifndef __BIG_ENDIAN
multiline_comment|/*&n; * Converts a buffer from be32 to cpu byte ordering. Length is in bytes.&n; */
DECL|function|sbp2util_be32_to_cpu_buffer
r_static
id|__inline__
r_void
id|sbp2util_be32_to_cpu_buffer
c_func
(paren
r_void
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
id|u32
op_star
id|temp
op_assign
id|buffer
suffix:semicolon
r_for
c_loop
(paren
id|length
op_assign
(paren
id|length
op_rshift
l_int|2
)paren
suffix:semicolon
id|length
op_decrement
suffix:semicolon
)paren
id|temp
(braket
id|length
)braket
op_assign
id|be32_to_cpu
c_func
(paren
id|temp
(braket
id|length
)braket
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Converts a buffer from cpu to be32 byte ordering. Length is in bytes.&n; */
DECL|function|sbp2util_cpu_to_be32_buffer
r_static
id|__inline__
r_void
id|sbp2util_cpu_to_be32_buffer
c_func
(paren
r_void
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
id|u32
op_star
id|temp
op_assign
id|buffer
suffix:semicolon
r_for
c_loop
(paren
id|length
op_assign
(paren
id|length
op_rshift
l_int|2
)paren
suffix:semicolon
id|length
op_decrement
suffix:semicolon
)paren
id|temp
(braket
id|length
)braket
op_assign
id|cpu_to_be32
c_func
(paren
id|temp
(braket
id|length
)braket
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#else /* BIG_ENDIAN */
multiline_comment|/* Why waste the cpu cycles? */
DECL|macro|sbp2util_be32_to_cpu_buffer
mdefine_line|#define sbp2util_be32_to_cpu_buffer(x,y)
DECL|macro|sbp2util_cpu_to_be32_buffer
mdefine_line|#define sbp2util_cpu_to_be32_buffer(x,y)
macro_line|#endif
multiline_comment|/*&n; * This function is called to initially create a packet pool for use in&n; * sbp2 I/O requests. This packet pool is used when sending out sbp2&n; * command and agent reset requests, and allows us to remove all&n; * kmallocs/kfrees from the critical I/O paths.&n; */
DECL|function|sbp2util_create_request_packet_pool
r_static
r_int
id|sbp2util_create_request_packet_pool
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
)paren
(brace
r_struct
id|hpsb_packet
op_star
id|packet
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Create SBP2_MAX_REQUEST_PACKETS number of request packets. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SBP2_MAX_REQUEST_PACKETS
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Max payload of 8 bytes since the sbp2 command request&n;&t;&t; * uses a payload of 8 bytes, and agent reset is a quadlet&n;&t;&t; * write request. Bump this up if we plan on using this&n;&t;&t; * pool for other stuff.&n;&t;&t; */
id|packet
op_assign
id|alloc_hpsb_packet
c_func
(paren
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|packet
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2util_create_request_packet_pool - packet allocation failed!&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * Put these request packets into a free list&n;&t;&t; */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|hi-&gt;request_packet
(braket
id|i
)braket
dot
id|list
)paren
suffix:semicolon
id|hi-&gt;request_packet
(braket
id|i
)braket
dot
id|packet
op_assign
id|packet
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|hi-&gt;request_packet
(braket
id|i
)braket
dot
id|list
comma
op_amp
id|hi-&gt;sbp2_req_free
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called to remove the packet pool. It is called when&n; * the sbp2 driver is unloaded.&n; */
DECL|function|sbp2util_remove_request_packet_pool
r_static
r_void
id|sbp2util_remove_request_packet_pool
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|sbp2_request_packet
op_star
id|request_packet
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* &n;&t; * Go through free list releasing packets&n;&t; */
id|sbp2_spin_lock
c_func
(paren
op_amp
id|hi-&gt;sbp2_request_packet_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|hi-&gt;sbp2_req_free
)paren
)paren
(brace
id|lh
op_assign
id|hi-&gt;sbp2_req_free.next
suffix:semicolon
id|list_del
c_func
(paren
id|lh
)paren
suffix:semicolon
id|request_packet
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|sbp2_request_packet
comma
id|list
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Free the hpsb packets that we allocated for the pool&n;&t;&t; */
r_if
c_cond
(paren
id|request_packet
)paren
(brace
id|free_hpsb_packet
c_func
(paren
id|request_packet-&gt;packet
)paren
suffix:semicolon
)brace
)brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|hi-&gt;sbp2_request_packet_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called to retrieve a block write packet from our&n; * packet pool. This function is used in place of calling&n; * alloc_hpsb_packet (which costs us three kmallocs). Instead we just pull&n; * out a free request packet and re-initialize values in it. I&squot;m sure this&n; * can still stand some more optimization.&n; */
r_static
r_struct
id|sbp2_request_packet
op_star
DECL|function|sbp2util_allocate_write_request_packet
id|sbp2util_allocate_write_request_packet
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
id|nodeid_t
id|node
comma
id|u64
id|addr
comma
r_int
id|data_size
comma
id|quadlet_t
id|data
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|sbp2_request_packet
op_star
id|request_packet
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|hpsb_packet
op_star
id|packet
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|sbp2_spin_lock
c_func
(paren
op_amp
id|hi-&gt;sbp2_request_packet_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|hi-&gt;sbp2_req_free
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Pull out a free request packet&n;&t;&t; */
id|lh
op_assign
id|hi-&gt;sbp2_req_free.next
suffix:semicolon
id|list_del
c_func
(paren
id|lh
)paren
suffix:semicolon
id|request_packet
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|sbp2_request_packet
comma
id|list
)paren
suffix:semicolon
id|packet
op_assign
id|request_packet-&gt;packet
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Initialize the packet (this is really initialization&n;&t;&t; * the core 1394 stack should do, but I&squot;m doing it myself&n;&t;&t; * to avoid the overhead).&n;&t;&t; */
id|packet-&gt;data_size
op_assign
id|data_size
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|packet-&gt;list
)paren
suffix:semicolon
id|sema_init
c_func
(paren
op_amp
id|packet-&gt;state_change
comma
l_int|0
)paren
suffix:semicolon
id|packet-&gt;state
op_assign
id|hpsb_unused
suffix:semicolon
id|packet-&gt;generation
op_assign
id|get_hpsb_generation
c_func
(paren
id|hi-&gt;host
)paren
suffix:semicolon
id|packet-&gt;data_be
op_assign
l_int|1
suffix:semicolon
id|packet-&gt;host
op_assign
id|hi-&gt;host
suffix:semicolon
id|packet-&gt;tlabel
op_assign
id|get_tlabel
c_func
(paren
id|hi-&gt;host
comma
id|node
comma
l_int|1
)paren
suffix:semicolon
id|packet-&gt;node_id
op_assign
id|node
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data_size
)paren
(brace
id|fill_async_writequad
c_func
(paren
id|packet
comma
id|addr
comma
id|data
)paren
suffix:semicolon
)brace
r_else
(brace
id|fill_async_writeblock
c_func
(paren
id|packet
comma
id|addr
comma
id|data_size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Set up a task queue completion routine, which returns&n;&t;&t; * the packet to the free list and releases the tlabel.&n;&t;&t; */
id|request_packet-&gt;tq.routine
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_void
op_star
)paren
)paren
id|sbp2util_free_request_packet
suffix:semicolon
id|request_packet-&gt;tq.data
op_assign
id|request_packet
suffix:semicolon
id|request_packet-&gt;hi_context
op_assign
id|hi
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|request_packet-&gt;tq
comma
op_amp
id|packet-&gt;complete_tq
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Now, put the packet on the in-use list.&n;&t;&t; */
id|list_add_tail
c_func
(paren
op_amp
id|request_packet-&gt;list
comma
op_amp
id|hi-&gt;sbp2_req_inuse
)paren
suffix:semicolon
)brace
r_else
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2util_allocate_request_packet - no packets available!&quot;
)paren
suffix:semicolon
)brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|hi-&gt;sbp2_request_packet_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|request_packet
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called to return a packet to our packet pool. It is&n; * also called as a completion routine when a request packet is completed.&n; */
DECL|function|sbp2util_free_request_packet
r_static
r_void
id|sbp2util_free_request_packet
c_func
(paren
r_struct
id|sbp2_request_packet
op_star
id|request_packet
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sbp2scsi_host_info
op_star
id|hi
op_assign
id|request_packet-&gt;hi_context
suffix:semicolon
multiline_comment|/*&n;&t; * Free the tlabel, and return the packet to the free pool.&n;&t; */
id|sbp2_spin_lock
c_func
(paren
op_amp
id|hi-&gt;sbp2_request_packet_lock
comma
id|flags
)paren
suffix:semicolon
id|free_tlabel
c_func
(paren
id|hi-&gt;host
comma
id|LOCAL_BUS
op_or
id|request_packet-&gt;packet-&gt;node_id
comma
id|request_packet-&gt;packet-&gt;tlabel
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|request_packet-&gt;list
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|request_packet-&gt;list
comma
op_amp
id|hi-&gt;sbp2_req_free
)paren
suffix:semicolon
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|hi-&gt;sbp2_request_packet_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called to create a pool of command orbs used for&n; * command processing. It is called when a new sbp2 device is detected.&n; */
DECL|function|sbp2util_create_command_orb_pool
r_static
r_int
id|sbp2util_create_command_orb_pool
c_func
(paren
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
r_struct
id|sbp2scsi_host_info
op_star
id|hi
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sbp2_command_info
op_star
id|command
suffix:semicolon
id|sbp2_spin_lock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|scsi_id-&gt;sbp2_total_command_orbs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|command
op_assign
(paren
r_struct
id|sbp2_command_info
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sbp2_command_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|command
)paren
(brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|command
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
r_struct
id|sbp2_command_info
)paren
)paren
suffix:semicolon
id|command-&gt;command_orb_dma
op_assign
id|pci_map_single
(paren
id|hi-&gt;host-&gt;pdev
comma
op_amp
id|command-&gt;command_orb
comma
r_sizeof
(paren
r_struct
id|sbp2_command_orb
)paren
comma
id|PCI_DMA_BIDIRECTIONAL
)paren
suffix:semicolon
id|SBP2_DMA_ALLOC
c_func
(paren
l_string|&quot;single command orb DMA&quot;
)paren
suffix:semicolon
id|command-&gt;sge_dma
op_assign
id|pci_map_single
(paren
id|hi-&gt;host-&gt;pdev
comma
op_amp
id|command-&gt;scatter_gather_element
comma
r_sizeof
(paren
id|command-&gt;scatter_gather_element
)paren
comma
id|PCI_DMA_BIDIRECTIONAL
)paren
suffix:semicolon
id|SBP2_DMA_ALLOC
c_func
(paren
l_string|&quot;scatter_gather_element&quot;
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|command-&gt;list
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|command-&gt;list
comma
op_amp
id|scsi_id-&gt;sbp2_command_orb_completed
)paren
suffix:semicolon
)brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called to delete a pool of command orbs.&n; */
DECL|function|sbp2util_remove_command_orb_pool
r_static
r_void
id|sbp2util_remove_command_orb_pool
c_func
(paren
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
r_struct
id|sbp2scsi_host_info
op_star
id|hi
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|sbp2_command_info
op_star
id|command
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|sbp2_spin_lock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_completed
)paren
)paren
(brace
id|list_for_each
c_func
(paren
id|lh
comma
op_amp
id|scsi_id-&gt;sbp2_command_orb_completed
)paren
(brace
id|command
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|sbp2_command_info
comma
id|list
)paren
suffix:semicolon
multiline_comment|/* Release our generic DMA&squot;s */
id|pci_unmap_single
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
id|command-&gt;command_orb_dma
comma
r_sizeof
(paren
r_struct
id|sbp2_command_orb
)paren
comma
id|PCI_DMA_BIDIRECTIONAL
)paren
suffix:semicolon
id|SBP2_DMA_FREE
c_func
(paren
l_string|&quot;single command orb DMA&quot;
)paren
suffix:semicolon
id|pci_unmap_single
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
id|command-&gt;sge_dma
comma
r_sizeof
(paren
id|command-&gt;scatter_gather_element
)paren
comma
id|PCI_DMA_BIDIRECTIONAL
)paren
suffix:semicolon
id|SBP2_DMA_FREE
c_func
(paren
l_string|&quot;scatter_gather_element&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|command
)paren
suffix:semicolon
)brace
)brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* &n; * This functions finds the sbp2_command for a given outstanding command&n; * orb. Only looks at the inuse list.&n; */
DECL|function|sbp2util_find_command_for_orb
r_static
r_struct
id|sbp2_command_info
op_star
id|sbp2util_find_command_for_orb
c_func
(paren
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
id|dma_addr_t
id|orb
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|sbp2_command_info
op_star
id|command
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|sbp2_spin_lock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_inuse
)paren
)paren
(brace
id|list_for_each
c_func
(paren
id|lh
comma
op_amp
id|scsi_id-&gt;sbp2_command_orb_inuse
)paren
(brace
id|command
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|sbp2_command_info
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|command-&gt;command_orb_dma
op_eq
id|orb
)paren
(brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
r_return
(paren
id|command
)paren
suffix:semicolon
)brace
)brace
)brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
id|SBP2_ORB_DEBUG
c_func
(paren
l_string|&quot;could not match command orb %x&quot;
comma
(paren
r_int
r_int
)paren
id|orb
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* &n; * This functions finds the sbp2_command for a given outstanding SCpnt.&n; * Only looks at the inuse list.&n; */
DECL|function|sbp2util_find_command_for_SCpnt
r_static
r_struct
id|sbp2_command_info
op_star
id|sbp2util_find_command_for_SCpnt
c_func
(paren
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
r_void
op_star
id|SCpnt
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|sbp2_command_info
op_star
id|command
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|sbp2_spin_lock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_inuse
)paren
)paren
(brace
id|list_for_each
c_func
(paren
id|lh
comma
op_amp
id|scsi_id-&gt;sbp2_command_orb_inuse
)paren
(brace
id|command
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|sbp2_command_info
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|command-&gt;Current_SCpnt
op_eq
id|SCpnt
)paren
(brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
r_return
(paren
id|command
)paren
suffix:semicolon
)brace
)brace
)brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * This function allocates a command orb used to send a scsi command.&n; */
DECL|function|sbp2util_allocate_command_orb
r_static
r_struct
id|sbp2_command_info
op_star
id|sbp2util_allocate_command_orb
c_func
(paren
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
id|Scsi_Cmnd
op_star
id|Current_SCpnt
comma
r_void
(paren
op_star
id|Current_done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
comma
r_struct
id|sbp2scsi_host_info
op_star
id|hi
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|sbp2_command_info
op_star
id|command
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|sbp2_spin_lock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_completed
)paren
)paren
(brace
id|lh
op_assign
id|scsi_id-&gt;sbp2_command_orb_completed.next
suffix:semicolon
id|list_del
c_func
(paren
id|lh
)paren
suffix:semicolon
id|command
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|sbp2_command_info
comma
id|list
)paren
suffix:semicolon
id|command-&gt;Current_done
op_assign
id|Current_done
suffix:semicolon
id|command-&gt;Current_SCpnt
op_assign
id|Current_SCpnt
suffix:semicolon
id|command-&gt;linked
op_assign
l_int|0
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|command-&gt;list
comma
op_amp
id|scsi_id-&gt;sbp2_command_orb_inuse
)paren
suffix:semicolon
)brace
r_else
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2util_allocate_command_orb - No orbs available!&quot;
)paren
suffix:semicolon
)brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
r_return
(paren
id|command
)paren
suffix:semicolon
)brace
multiline_comment|/* Free our DMA&squot;s */
DECL|function|sbp2util_free_command_dma
r_static
r_void
id|sbp2util_free_command_dma
c_func
(paren
r_struct
id|sbp2_command_info
op_star
id|command
)paren
(brace
r_struct
id|sbp2scsi_host_info
op_star
id|hi
suffix:semicolon
id|hi
op_assign
(paren
r_struct
id|sbp2scsi_host_info
op_star
)paren
id|command-&gt;Current_SCpnt-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hi
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|__FUNCTION__
l_string|&quot;: hi == NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|command-&gt;cmd_dma
)paren
(brace
id|pci_unmap_single
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
id|command-&gt;cmd_dma
comma
id|command-&gt;dma_size
comma
id|command-&gt;dma_dir
)paren
suffix:semicolon
id|SBP2_DMA_FREE
c_func
(paren
l_string|&quot;single bulk&quot;
)paren
suffix:semicolon
id|command-&gt;cmd_dma
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|command-&gt;sge_buffer
)paren
(brace
id|pci_unmap_sg
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
id|command-&gt;sge_buffer
comma
id|command-&gt;dma_size
comma
id|command-&gt;dma_dir
)paren
suffix:semicolon
id|SBP2_DMA_FREE
c_func
(paren
l_string|&quot;scatter list&quot;
)paren
suffix:semicolon
id|command-&gt;sge_buffer
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This function moves a command to the completed orb list.&n; */
DECL|function|sbp2util_mark_command_completed
r_static
r_void
id|sbp2util_mark_command_completed
c_func
(paren
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
r_struct
id|sbp2_command_info
op_star
id|command
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|sbp2_spin_lock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|command-&gt;list
)paren
suffix:semicolon
id|sbp2util_free_command_dma
c_func
(paren
id|command
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|command-&gt;list
comma
op_amp
id|scsi_id-&gt;sbp2_command_orb_completed
)paren
suffix:semicolon
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_lock
comma
id|flags
)paren
suffix:semicolon
)brace
"&f;"
multiline_comment|/*********************************************&n; * IEEE-1394 core driver stack related section&n; *********************************************/
multiline_comment|/*&n; * This function is called at SCSI init in order to register our driver&n; * with the IEEE-1394 stack.&n; */
DECL|function|sbp2_init
r_int
id|sbp2_init
c_func
(paren
r_void
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_init&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Register our high level driver with 1394 stack&n;&t; */
id|sbp2_hl_handle
op_assign
id|hpsb_register_highlevel
c_func
(paren
id|SBP2_DEVICE_NAME
comma
op_amp
id|sbp2_hl_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbp2_hl_handle
op_eq
l_int|NULL
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2 failed to register with ieee1394 highlevel&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Register our sbp2 status address space...&n;&t; */
id|hpsb_register_addrspace
c_func
(paren
id|sbp2_hl_handle
comma
op_amp
id|sbp2_ops
comma
id|SBP2_STATUS_FIFO_ADDRESS
comma
id|SBP2_STATUS_FIFO_ADDRESS
op_plus
r_sizeof
(paren
r_struct
id|sbp2_status_block
)paren
)paren
suffix:semicolon
id|hpsb_register_protocol
c_func
(paren
op_amp
id|sbp2_driver
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called from cleanup module, or during shut-down, in&n; * order to unregister our driver.&n; */
DECL|function|sbp2_cleanup
r_void
id|sbp2_cleanup
c_func
(paren
r_void
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_cleanup&quot;
)paren
suffix:semicolon
id|hpsb_unregister_protocol
c_func
(paren
op_amp
id|sbp2_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbp2_hl_handle
)paren
(brace
id|hpsb_unregister_highlevel
c_func
(paren
id|sbp2_hl_handle
)paren
suffix:semicolon
id|sbp2_hl_handle
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|sbp2_probe
r_static
r_int
id|sbp2_probe
c_func
(paren
r_struct
id|unit_directory
op_star
id|ud
)paren
(brace
r_struct
id|sbp2scsi_host_info
op_star
id|hi
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_probe&quot;
)paren
suffix:semicolon
id|hi
op_assign
id|sbp2_find_host_info
c_func
(paren
id|ud-&gt;ne-&gt;host
)paren
suffix:semicolon
r_return
id|sbp2_start_device
c_func
(paren
id|hi
comma
id|ud
)paren
suffix:semicolon
)brace
DECL|function|sbp2_disconnect
r_static
r_void
id|sbp2_disconnect
c_func
(paren
r_struct
id|unit_directory
op_star
id|ud
)paren
(brace
r_struct
id|sbp2scsi_host_info
op_star
id|hi
suffix:semicolon
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
op_assign
id|ud-&gt;driver_data
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_disconnect&quot;
)paren
suffix:semicolon
id|hi
op_assign
id|sbp2_find_host_info
c_func
(paren
id|ud-&gt;ne-&gt;host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hi
op_ne
l_int|NULL
)paren
id|sbp2_remove_device
c_func
(paren
id|hi
comma
id|scsi_id
)paren
suffix:semicolon
)brace
DECL|function|sbp2_update
r_static
r_void
id|sbp2_update
c_func
(paren
r_struct
id|unit_directory
op_star
id|ud
)paren
(brace
r_struct
id|sbp2scsi_host_info
op_star
id|hi
suffix:semicolon
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
op_assign
id|ud-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_update&quot;
)paren
suffix:semicolon
id|hi
op_assign
id|sbp2_find_host_info
c_func
(paren
id|ud-&gt;ne-&gt;host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbp2_reconnect_device
c_func
(paren
id|hi
comma
id|scsi_id
)paren
)paren
(brace
multiline_comment|/* Ok, reconnect has failed.  Perhaps we didn&squot;t&n;&t;&t; * reconnect fast enough. Try doing a regular login.&n;&t;&t; */
r_if
c_cond
(paren
id|sbp2_login_device
c_func
(paren
id|hi
comma
id|scsi_id
)paren
)paren
(brace
multiline_comment|/* Login failed too... so, just mark him as&n;&t;&t;&t; * unvalidated, so that he gets cleaned up&n;&t;&t;&t; * later.&n;&t;&t;&t; */
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2_reconnect_device failed!&quot;
)paren
suffix:semicolon
id|sbp2_remove_device
c_func
(paren
id|hi
comma
id|scsi_id
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Set max retries to something large on the device. */
id|sbp2_set_busy_timeout
c_func
(paren
id|hi
comma
id|scsi_id
)paren
suffix:semicolon
multiline_comment|/* Do a SBP-2 fetch agent reset. */
id|sbp2_agent_reset
c_func
(paren
id|hi
comma
id|scsi_id
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Get the max speed and packet size that we can use. */
id|sbp2_max_speed_and_size
c_func
(paren
id|hi
comma
id|scsi_id
)paren
suffix:semicolon
multiline_comment|/* Complete any pending commands with busy (so they get&n;&t; * retried) and remove them from our queue&n;&t; */
id|sbp2_spin_lock
c_func
(paren
op_amp
id|hi-&gt;sbp2_command_lock
comma
id|flags
)paren
suffix:semicolon
id|sbp2scsi_complete_all_commands
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|DID_BUS_BUSY
)paren
suffix:semicolon
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|hi-&gt;sbp2_command_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called after registering our operations in sbp2_init.&n; * We go ahead and allocate some memory for our host info structure, and&n; * init some structures.&n; */
DECL|function|sbp2_add_host
r_static
r_void
id|sbp2_add_host
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
(brace
r_struct
id|sbp2scsi_host_info
op_star
id|hi
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_add_host&quot;
)paren
suffix:semicolon
multiline_comment|/* Allocate some memory for our host info structure */
id|hi
op_assign
(paren
r_struct
id|sbp2scsi_host_info
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sbp2scsi_host_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hi
op_eq
l_int|NULL
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;out of memory in sbp2_add_host&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Initialize some host stuff */
id|memset
c_func
(paren
id|hi
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sbp2scsi_host_info
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|hi-&gt;list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|hi-&gt;sbp2_req_inuse
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|hi-&gt;sbp2_req_free
)paren
suffix:semicolon
id|hi-&gt;host
op_assign
id|host
suffix:semicolon
id|hi-&gt;sbp2_command_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|hi-&gt;sbp2_request_packet_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* Create our request packet pool (pool of packets for use in I/O) */
r_if
c_cond
(paren
id|sbp2util_create_request_packet_pool
c_func
(paren
id|hi
)paren
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2util_create_request_packet_pool failed!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sbp2_spin_lock
c_func
(paren
op_amp
id|sbp2_host_info_lock
comma
id|flags
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|hi-&gt;list
comma
op_amp
id|sbp2_host_info_list
)paren
suffix:semicolon
id|sbp2_host_count
op_increment
suffix:semicolon
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|sbp2_host_info_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Register our host with the SCSI stack. */
id|sbp2scsi_register_scsi_host
c_func
(paren
id|hi
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This fuction returns a host info structure from the host structure, in&n; * case we have multiple hosts.&n; */
DECL|function|sbp2_find_host_info
r_static
r_struct
id|sbp2scsi_host_info
op_star
id|sbp2_find_host_info
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|sbp2scsi_host_info
op_star
id|hi
suffix:semicolon
id|list_for_each
(paren
id|lh
comma
op_amp
id|sbp2_host_info_list
)paren
(brace
id|hi
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|sbp2scsi_host_info
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hi-&gt;host
op_eq
id|host
)paren
(brace
r_return
id|hi
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called when the host is removed&n; */
DECL|function|sbp2_remove_host
r_static
r_void
id|sbp2_remove_host
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
(brace
r_struct
id|sbp2scsi_host_info
op_star
id|hi
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_remove_host&quot;
)paren
suffix:semicolon
id|sbp2_spin_lock
c_func
(paren
op_amp
id|sbp2_host_info_lock
comma
id|flags
)paren
suffix:semicolon
id|hi
op_assign
id|sbp2_find_host_info
c_func
(paren
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hi
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Here&squot;s an annoying hack: we get a disconnect&n;&t;&t; * callback for each device, so this loop shouldn&squot;t be&n;&t;&t; * necessary.  However, the sbp2 driver receives the&n;&t;&t; * remove_host callback before the nodemgr, so when we&n;&t;&t; * get the disconnect callback, we&squot;ve already freed&n;&t;&t; * the host.  Thus, we free the devices here...&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SBP2SCSI_MAX_SCSI_IDS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
id|sbp2_logout_device
c_func
(paren
id|hi
comma
id|hi-&gt;scsi_id
(braket
id|i
)braket
)paren
suffix:semicolon
id|sbp2_remove_device
c_func
(paren
id|hi
comma
id|hi-&gt;scsi_id
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
id|sbp2util_remove_request_packet_pool
c_func
(paren
id|hi
)paren
suffix:semicolon
id|sbp2_host_count
op_decrement
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|hi-&gt;list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hi
)paren
suffix:semicolon
)brace
r_else
id|SBP2_ERR
c_func
(paren
l_string|&quot;attempt to remove unknown host %p&quot;
comma
id|host
)paren
suffix:semicolon
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|sbp2_host_info_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is where we first pull the node unique ids, and then&n; * allocate memory and register a SBP-2 device.&n; */
DECL|function|sbp2_start_device
r_static
r_int
id|sbp2_start_device
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|unit_directory
op_star
id|ud
)paren
(brace
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|node_entry
op_star
id|ne
suffix:semicolon
r_int
id|i
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_start_device&quot;
)paren
suffix:semicolon
id|ne
op_assign
id|ud-&gt;ne
suffix:semicolon
multiline_comment|/*&n;&t; * This really is a &quot;new&quot; device plugged in. Let&squot;s allocate memory&n;&t; * for our scsi id instance data.&n;&t; */
id|scsi_id
op_assign
(paren
r_struct
id|scsi_id_instance_data
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|scsi_id_instance_data
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_id
)paren
r_goto
id|alloc_fail_first
suffix:semicolon
id|memset
c_func
(paren
id|scsi_id
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|scsi_id_instance_data
)paren
)paren
suffix:semicolon
multiline_comment|/* Login FIFO DMA */
id|scsi_id-&gt;login_response
op_assign
id|pci_alloc_consistent
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|sbp2_login_response
)paren
comma
op_amp
id|scsi_id-&gt;login_response_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_id-&gt;login_response
)paren
r_goto
id|alloc_fail
suffix:semicolon
id|SBP2_DMA_ALLOC
c_func
(paren
l_string|&quot;consistent DMA region for login FIFO&quot;
)paren
suffix:semicolon
multiline_comment|/* Reconnect ORB DMA */
id|scsi_id-&gt;reconnect_orb
op_assign
id|pci_alloc_consistent
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|sbp2_reconnect_orb
)paren
comma
op_amp
id|scsi_id-&gt;reconnect_orb_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_id-&gt;reconnect_orb
)paren
r_goto
id|alloc_fail
suffix:semicolon
id|SBP2_DMA_ALLOC
c_func
(paren
l_string|&quot;consistent DMA region for reconnect ORB&quot;
)paren
suffix:semicolon
multiline_comment|/* Logout ORB DMA */
id|scsi_id-&gt;logout_orb
op_assign
id|pci_alloc_consistent
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|sbp2_logout_orb
)paren
comma
op_amp
id|scsi_id-&gt;logout_orb_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_id-&gt;logout_orb
)paren
r_goto
id|alloc_fail
suffix:semicolon
id|SBP2_DMA_ALLOC
c_func
(paren
l_string|&quot;consistent DMA region for logout ORB&quot;
)paren
suffix:semicolon
multiline_comment|/* Login ORB DMA */
id|scsi_id-&gt;login_orb
op_assign
id|pci_alloc_consistent
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|sbp2_login_orb
)paren
comma
op_amp
id|scsi_id-&gt;login_orb_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_id-&gt;login_orb
op_eq
l_int|NULL
)paren
(brace
id|alloc_fail
suffix:colon
r_if
c_cond
(paren
id|scsi_id-&gt;logout_orb
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|sbp2_logout_orb
)paren
comma
id|scsi_id-&gt;logout_orb
comma
id|scsi_id-&gt;logout_orb_dma
)paren
suffix:semicolon
id|SBP2_DMA_FREE
c_func
(paren
l_string|&quot;logout ORB DMA&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scsi_id-&gt;reconnect_orb
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|sbp2_reconnect_orb
)paren
comma
id|scsi_id-&gt;reconnect_orb
comma
id|scsi_id-&gt;reconnect_orb_dma
)paren
suffix:semicolon
id|SBP2_DMA_FREE
c_func
(paren
l_string|&quot;reconnect ORB DMA&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scsi_id-&gt;login_response
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|sbp2_login_response
)paren
comma
id|scsi_id-&gt;login_response
comma
id|scsi_id-&gt;login_response_dma
)paren
suffix:semicolon
id|SBP2_DMA_FREE
c_func
(paren
l_string|&quot;login FIFO DMA&quot;
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|scsi_id
)paren
suffix:semicolon
id|alloc_fail_first
suffix:colon
id|SBP2_ERR
(paren
l_string|&quot;Could not allocate memory for scsi_id&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|SBP2_DMA_ALLOC
c_func
(paren
l_string|&quot;consistent DMA region for login ORB&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize some of the fields in this structure&n;&t; */
id|scsi_id-&gt;ne
op_assign
id|ne
suffix:semicolon
id|scsi_id-&gt;ud
op_assign
id|ud
suffix:semicolon
id|scsi_id-&gt;speed_code
op_assign
id|SPEED_100
suffix:semicolon
id|scsi_id-&gt;max_payload_size
op_assign
id|sbp2_speedto_maxrec
(braket
id|SPEED_100
)braket
suffix:semicolon
id|ud-&gt;driver_data
op_assign
id|scsi_id
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_login_wait
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Initialize structures needed for the command orb pool.&n;&t; */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_inuse
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_completed
)paren
suffix:semicolon
id|scsi_id-&gt;sbp2_command_orb_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|scsi_id-&gt;sbp2_total_command_orbs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure that we&squot;ve gotten ahold of the sbp2 management agent&n;&t; * address. Also figure out the command set being used (SCSI or&n;&t; * RBC).&n;&t; */
id|sbp2_parse_unit_directory
c_func
(paren
id|scsi_id
)paren
suffix:semicolon
id|scsi_id-&gt;sbp2_total_command_orbs
op_assign
id|SBP2_MAX_COMMAND_ORBS
suffix:semicolon
multiline_comment|/* &n;&t; * Knock the total command orbs down if we are serializing I/O&n;&t; */
r_if
c_cond
(paren
id|serialize_io
)paren
(brace
id|scsi_id-&gt;sbp2_total_command_orbs
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* one extra for good measure */
)brace
multiline_comment|/*&n;&t; * Allocate some extra command orb structures for devices with&n;&t; * 128KB limit.&n;&t; */
r_if
c_cond
(paren
id|scsi_id-&gt;sbp2_firmware_revision
op_eq
id|SBP2_128KB_BROKEN_FIRMWARE
)paren
(brace
id|scsi_id-&gt;sbp2_total_command_orbs
op_mul_assign
l_int|4
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Find an empty spot to stick our scsi id instance data. &n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SBP2SCSI_MAX_SCSI_IDS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hi-&gt;scsi_id
(braket
id|i
)braket
)paren
(brace
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_assign
id|scsi_id
suffix:semicolon
id|scsi_id-&gt;id
op_assign
id|i
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;New SBP-2 device inserted, SCSI ID = %x&quot;
comma
(paren
r_int
r_int
)paren
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Create our command orb pool&n;&t; */
r_if
c_cond
(paren
id|sbp2util_create_command_orb_pool
c_func
(paren
id|scsi_id
comma
id|hi
)paren
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2util_create_command_orb_pool failed!&quot;
)paren
suffix:semicolon
id|sbp2_remove_device
c_func
(paren
id|hi
comma
id|scsi_id
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Make sure we are not out of space&n;&t; */
r_if
c_cond
(paren
id|i
op_eq
id|SBP2SCSI_MAX_SCSI_IDS
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;No slots left for SBP-2 device&quot;
)paren
suffix:semicolon
id|sbp2_remove_device
c_func
(paren
id|hi
comma
id|scsi_id
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Login to the sbp-2 device&n;&t; */
r_if
c_cond
(paren
id|sbp2_login_device
c_func
(paren
id|hi
comma
id|scsi_id
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Login failed... so, just mark him as unvalidated, so&n;&t;&t; * that he gets cleaned up later.&n;&t;&t; */
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2_login_device failed&quot;
)paren
suffix:semicolon
id|sbp2_remove_device
c_func
(paren
id|hi
comma
id|scsi_id
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set max retries to something large on the device&n;&t; */
id|sbp2_set_busy_timeout
c_func
(paren
id|hi
comma
id|scsi_id
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do a SBP-2 fetch agent reset&n;&t; */
id|sbp2_agent_reset
c_func
(paren
id|hi
comma
id|scsi_id
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the max speed and packet size that we can use&n;&t; */
id|sbp2_max_speed_and_size
c_func
(paren
id|hi
comma
id|scsi_id
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function removes (cleans-up after) any unvalidated sbp2 devices&n; */
DECL|function|sbp2_remove_device
r_static
r_void
id|sbp2_remove_device
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
)paren
(brace
multiline_comment|/* Complete any pending commands with selection timeout */
id|sbp2scsi_complete_all_commands
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|DID_NO_CONNECT
)paren
suffix:semicolon
multiline_comment|/* Clean up any other structures */
r_if
c_cond
(paren
id|scsi_id-&gt;sbp2_total_command_orbs
)paren
(brace
id|sbp2util_remove_command_orb_pool
c_func
(paren
id|scsi_id
comma
id|hi
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scsi_id-&gt;login_response
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|sbp2_login_response
)paren
comma
id|scsi_id-&gt;login_response
comma
id|scsi_id-&gt;login_response_dma
)paren
suffix:semicolon
id|SBP2_DMA_FREE
c_func
(paren
l_string|&quot;single login FIFO&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scsi_id-&gt;login_orb
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|sbp2_login_orb
)paren
comma
id|scsi_id-&gt;login_orb
comma
id|scsi_id-&gt;login_orb_dma
)paren
suffix:semicolon
id|SBP2_DMA_FREE
c_func
(paren
l_string|&quot;single login ORB&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scsi_id-&gt;reconnect_orb
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|sbp2_reconnect_orb
)paren
comma
id|scsi_id-&gt;reconnect_orb
comma
id|scsi_id-&gt;reconnect_orb_dma
)paren
suffix:semicolon
id|SBP2_DMA_FREE
c_func
(paren
l_string|&quot;single reconnect orb&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scsi_id-&gt;logout_orb
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
r_sizeof
(paren
r_struct
id|sbp2_logout_orb
)paren
comma
id|scsi_id-&gt;logout_orb
comma
id|scsi_id-&gt;reconnect_orb_dma
)paren
suffix:semicolon
id|SBP2_DMA_FREE
c_func
(paren
l_string|&quot;single logout orb&quot;
)paren
suffix:semicolon
)brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;Unvalidated SBP-2 device removed, SCSI ID = %d&quot;
comma
id|scsi_id-&gt;id
)paren
suffix:semicolon
id|hi-&gt;scsi_id
(braket
id|scsi_id-&gt;id
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|scsi_id
)paren
suffix:semicolon
)brace
"&f;"
multiline_comment|/**************************************&n; * SBP-2 protocol related section&n; **************************************/
multiline_comment|/*&n; * This function is called in order to login to a particular SBP-2 device,&n; * after a bus reset.&n; */
DECL|function|sbp2_login_device
r_static
r_int
id|sbp2_login_device
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
)paren
(brace
id|quadlet_t
id|data
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_login_device&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_id-&gt;login_orb
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_login_device: login_orb not alloc&squot;d!&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Set-up login ORB, assume no password */
id|scsi_id-&gt;login_orb-&gt;password_hi
op_assign
l_int|0
suffix:semicolon
id|scsi_id-&gt;login_orb-&gt;password_lo
op_assign
l_int|0
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_login_device: password_hi/lo initialized&quot;
)paren
suffix:semicolon
id|scsi_id-&gt;login_orb-&gt;login_response_lo
op_assign
id|scsi_id-&gt;login_response_dma
suffix:semicolon
id|scsi_id-&gt;login_orb-&gt;login_response_hi
op_assign
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_login_device: login_response_hi/lo initialized&quot;
)paren
suffix:semicolon
id|scsi_id-&gt;login_orb-&gt;lun_misc
op_assign
id|ORB_SET_FUNCTION
c_func
(paren
id|LOGIN_REQUEST
)paren
suffix:semicolon
id|scsi_id-&gt;login_orb-&gt;lun_misc
op_or_assign
id|ORB_SET_RECONNECT
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* One second reconnect time */
id|scsi_id-&gt;login_orb-&gt;lun_misc
op_or_assign
id|ORB_SET_EXCLUSIVE
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Exclusive access to device */
id|scsi_id-&gt;login_orb-&gt;lun_misc
op_or_assign
id|ORB_SET_NOTIFY
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Notify us of login complete */
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_login_device: lun_misc initialized&quot;
)paren
suffix:semicolon
id|scsi_id-&gt;login_orb-&gt;passwd_resp_lengths
op_assign
id|ORB_SET_LOGIN_RESP_LENGTH
c_func
(paren
r_sizeof
(paren
r_struct
id|sbp2_login_response
)paren
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_login_device: passwd_resp_lengths initialized&quot;
)paren
suffix:semicolon
id|scsi_id-&gt;login_orb-&gt;status_FIFO_lo
op_assign
id|SBP2_STATUS_FIFO_ADDRESS_LO
suffix:semicolon
id|scsi_id-&gt;login_orb-&gt;status_FIFO_hi
op_assign
(paren
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
op_or
id|SBP2_STATUS_FIFO_ADDRESS_HI
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_login_device: status FIFO initialized&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Byte swap ORB if necessary&n;&t; */
id|sbp2util_cpu_to_be32_buffer
c_func
(paren
id|scsi_id-&gt;login_orb
comma
r_sizeof
(paren
r_struct
id|sbp2_login_orb
)paren
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_login_device: orb byte-swapped&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize login response and status fifo&n;&t; */
id|memset
c_func
(paren
id|scsi_id-&gt;login_response
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sbp2_login_response
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|scsi_id-&gt;status_block
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sbp2_status_block
)paren
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_login_device: login_response/status FIFO memset&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, let&squot;s write to the target&squot;s management agent register&n;&t; */
id|data
(braket
l_int|0
)braket
op_assign
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
suffix:semicolon
id|data
(braket
l_int|1
)braket
op_assign
id|scsi_id-&gt;login_orb_dma
suffix:semicolon
id|sbp2util_cpu_to_be32_buffer
c_func
(paren
id|data
comma
l_int|8
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_login_device: prepared to write&quot;
)paren
suffix:semicolon
id|hpsb_write
c_func
(paren
id|hi-&gt;host
comma
id|LOCAL_BUS
op_or
id|scsi_id-&gt;ne-&gt;nodeid
comma
id|scsi_id-&gt;sbp2_management_agent_addr
comma
id|data
comma
l_int|8
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_login_device: written&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wait for login status... but, only if the device has not&n;&t; * already logged-in (some devices are fast)&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* 10 second timeout */
r_if
c_cond
(paren
id|scsi_id-&gt;status_block.ORB_offset_lo
op_ne
id|scsi_id-&gt;login_orb_dma
)paren
id|sleep_on_timeout
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_login_wait
comma
l_int|10
op_star
id|HZ
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_login_device: initial check&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Match status to the login orb. If they do not match, it&squot;s&n;&t; * probably because the login timed-out.&n;&t; */
r_if
c_cond
(paren
id|scsi_id-&gt;status_block.ORB_offset_lo
op_ne
id|scsi_id-&gt;login_orb_dma
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;Error logging into SBP-2 device - login timed-out&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_login_device: second check&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check status&n;&t; */
r_if
c_cond
(paren
id|STATUS_GET_RESP
c_func
(paren
id|scsi_id-&gt;status_block.ORB_offset_hi_misc
)paren
op_logical_or
id|STATUS_GET_DEAD_BIT
c_func
(paren
id|scsi_id-&gt;status_block.ORB_offset_hi_misc
)paren
op_logical_or
id|STATUS_GET_SBP_STATUS
c_func
(paren
id|scsi_id-&gt;status_block.ORB_offset_hi_misc
)paren
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;Error logging into SBP-2 device - login failed&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Byte swap the login response, for use when reconnecting or&n;&t; * logging out.&n;&t; */
id|sbp2util_cpu_to_be32_buffer
c_func
(paren
id|scsi_id-&gt;login_response
comma
r_sizeof
(paren
r_struct
id|sbp2_login_response
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Grab our command block agent address from the login response.&n;&t; */
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;command_block_agent_hi = %x&quot;
comma
(paren
r_int
r_int
)paren
id|scsi_id-&gt;login_response-&gt;command_block_agent_hi
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;command_block_agent_lo = %x&quot;
comma
(paren
r_int
r_int
)paren
id|scsi_id-&gt;login_response-&gt;command_block_agent_lo
)paren
suffix:semicolon
id|scsi_id-&gt;sbp2_command_block_agent_addr
op_assign
(paren
(paren
id|u64
)paren
id|scsi_id-&gt;login_response-&gt;command_block_agent_hi
)paren
op_lshift
l_int|32
suffix:semicolon
id|scsi_id-&gt;sbp2_command_block_agent_addr
op_or_assign
(paren
(paren
id|u64
)paren
id|scsi_id-&gt;login_response-&gt;command_block_agent_lo
)paren
suffix:semicolon
id|scsi_id-&gt;sbp2_command_block_agent_addr
op_and_assign
l_int|0x0000ffffffffffffULL
suffix:semicolon
id|SBP2_INFO
c_func
(paren
l_string|&quot;Logged into SBP-2 device&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called in order to logout from a particular SBP-2&n; * device, usually called during driver unload.&n; */
DECL|function|sbp2_logout_device
r_static
r_int
id|sbp2_logout_device
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
)paren
(brace
id|quadlet_t
id|data
(braket
l_int|2
)braket
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_logout_device&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set-up logout ORB&n;&t; */
id|scsi_id-&gt;logout_orb-&gt;reserved1
op_assign
l_int|0x0
suffix:semicolon
id|scsi_id-&gt;logout_orb-&gt;reserved2
op_assign
l_int|0x0
suffix:semicolon
id|scsi_id-&gt;logout_orb-&gt;reserved3
op_assign
l_int|0x0
suffix:semicolon
id|scsi_id-&gt;logout_orb-&gt;reserved4
op_assign
l_int|0x0
suffix:semicolon
id|scsi_id-&gt;logout_orb-&gt;login_ID_misc
op_assign
id|ORB_SET_FUNCTION
c_func
(paren
id|LOGOUT_REQUEST
)paren
suffix:semicolon
id|scsi_id-&gt;logout_orb-&gt;login_ID_misc
op_or_assign
id|ORB_SET_LOGIN_ID
c_func
(paren
id|scsi_id-&gt;login_response-&gt;length_login_ID
)paren
suffix:semicolon
multiline_comment|/* Notify us when complete */
id|scsi_id-&gt;logout_orb-&gt;login_ID_misc
op_or_assign
id|ORB_SET_NOTIFY
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|scsi_id-&gt;logout_orb-&gt;reserved5
op_assign
l_int|0x0
suffix:semicolon
id|scsi_id-&gt;logout_orb-&gt;status_FIFO_lo
op_assign
id|SBP2_STATUS_FIFO_ADDRESS_LO
suffix:semicolon
id|scsi_id-&gt;logout_orb-&gt;status_FIFO_hi
op_assign
(paren
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
op_or
id|SBP2_STATUS_FIFO_ADDRESS_HI
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Byte swap ORB if necessary&n;&t; */
id|sbp2util_cpu_to_be32_buffer
c_func
(paren
id|scsi_id-&gt;logout_orb
comma
r_sizeof
(paren
r_struct
id|sbp2_logout_orb
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, let&squot;s write to the target&squot;s management agent register&n;&t; */
id|data
(braket
l_int|0
)braket
op_assign
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
suffix:semicolon
id|data
(braket
l_int|1
)braket
op_assign
id|scsi_id-&gt;logout_orb_dma
suffix:semicolon
id|sbp2util_cpu_to_be32_buffer
c_func
(paren
id|data
comma
l_int|8
)paren
suffix:semicolon
id|hpsb_write
c_func
(paren
id|hi-&gt;host
comma
id|LOCAL_BUS
op_or
id|scsi_id-&gt;ne-&gt;nodeid
comma
id|scsi_id-&gt;sbp2_management_agent_addr
comma
id|data
comma
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Wait for device to logout...1 second. */
id|sleep_on_timeout
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_login_wait
comma
id|HZ
)paren
suffix:semicolon
id|SBP2_INFO
c_func
(paren
l_string|&quot;Logged out of SBP-2 device&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called in order to reconnect to a particular SBP-2&n; * device, after a bus reset.&n; */
DECL|function|sbp2_reconnect_device
r_static
r_int
id|sbp2_reconnect_device
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
)paren
(brace
id|quadlet_t
id|data
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_reconnect_device&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set-up reconnect ORB&n;&t; */
id|scsi_id-&gt;reconnect_orb-&gt;reserved1
op_assign
l_int|0x0
suffix:semicolon
id|scsi_id-&gt;reconnect_orb-&gt;reserved2
op_assign
l_int|0x0
suffix:semicolon
id|scsi_id-&gt;reconnect_orb-&gt;reserved3
op_assign
l_int|0x0
suffix:semicolon
id|scsi_id-&gt;reconnect_orb-&gt;reserved4
op_assign
l_int|0x0
suffix:semicolon
id|scsi_id-&gt;reconnect_orb-&gt;login_ID_misc
op_assign
id|ORB_SET_FUNCTION
c_func
(paren
id|RECONNECT_REQUEST
)paren
suffix:semicolon
id|scsi_id-&gt;reconnect_orb-&gt;login_ID_misc
op_or_assign
id|ORB_SET_LOGIN_ID
c_func
(paren
id|scsi_id-&gt;login_response-&gt;length_login_ID
)paren
suffix:semicolon
multiline_comment|/* Notify us when complete */
id|scsi_id-&gt;reconnect_orb-&gt;login_ID_misc
op_or_assign
id|ORB_SET_NOTIFY
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|scsi_id-&gt;reconnect_orb-&gt;reserved5
op_assign
l_int|0x0
suffix:semicolon
id|scsi_id-&gt;reconnect_orb-&gt;status_FIFO_lo
op_assign
id|SBP2_STATUS_FIFO_ADDRESS_LO
suffix:semicolon
id|scsi_id-&gt;reconnect_orb-&gt;status_FIFO_hi
op_assign
(paren
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
op_or
id|SBP2_STATUS_FIFO_ADDRESS_HI
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Byte swap ORB if necessary&n;&t; */
id|sbp2util_cpu_to_be32_buffer
c_func
(paren
id|scsi_id-&gt;reconnect_orb
comma
r_sizeof
(paren
r_struct
id|sbp2_reconnect_orb
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize status fifo&n;&t; */
id|memset
c_func
(paren
op_amp
id|scsi_id-&gt;status_block
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sbp2_status_block
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, let&squot;s write to the target&squot;s management agent register&n;&t; */
id|data
(braket
l_int|0
)braket
op_assign
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
suffix:semicolon
id|data
(braket
l_int|1
)braket
op_assign
id|scsi_id-&gt;reconnect_orb_dma
suffix:semicolon
id|sbp2util_cpu_to_be32_buffer
c_func
(paren
id|data
comma
l_int|8
)paren
suffix:semicolon
id|hpsb_write
c_func
(paren
id|hi-&gt;host
comma
id|LOCAL_BUS
op_or
id|scsi_id-&gt;ne-&gt;nodeid
comma
id|scsi_id-&gt;sbp2_management_agent_addr
comma
id|data
comma
l_int|8
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wait for reconnect status... but, only if the device has not&n;&t; * already reconnected (some devices are fast).&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* One second timout */
r_if
c_cond
(paren
id|scsi_id-&gt;status_block.ORB_offset_lo
op_ne
id|scsi_id-&gt;reconnect_orb_dma
)paren
id|sleep_on_timeout
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_login_wait
comma
id|HZ
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Match status to the reconnect orb. If they do not match, it&squot;s&n;&t; * probably because the reconnect timed-out.&n;&t; */
r_if
c_cond
(paren
id|scsi_id-&gt;status_block.ORB_offset_lo
op_ne
id|scsi_id-&gt;reconnect_orb_dma
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;Error reconnecting to SBP-2 device - reconnect timed-out&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check status&n;&t; */
r_if
c_cond
(paren
id|STATUS_GET_RESP
c_func
(paren
id|scsi_id-&gt;status_block.ORB_offset_hi_misc
)paren
op_logical_or
id|STATUS_GET_DEAD_BIT
c_func
(paren
id|scsi_id-&gt;status_block.ORB_offset_hi_misc
)paren
op_logical_or
id|STATUS_GET_SBP_STATUS
c_func
(paren
id|scsi_id-&gt;status_block.ORB_offset_hi_misc
)paren
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;Error reconnecting to SBP-2 device - reconnect failed&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|SBP2_INFO
c_func
(paren
l_string|&quot;Reconnected to SBP-2 device&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called in order to set the busy timeout (number of&n; * retries to attempt) on the sbp2 device. &n; */
DECL|function|sbp2_set_busy_timeout
r_static
r_int
id|sbp2_set_busy_timeout
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
)paren
(brace
id|quadlet_t
id|data
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_set_busy_timeout&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, let&squot;s write to the target&squot;s busy timeout register&n;&t; */
id|data
op_assign
id|cpu_to_be32
c_func
(paren
id|SBP2_BUSY_TIMEOUT_VALUE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hpsb_write
c_func
(paren
id|hi-&gt;host
comma
id|LOCAL_BUS
op_or
id|scsi_id-&gt;ne-&gt;nodeid
comma
id|SBP2_BUSY_TIMEOUT_ADDRESS
comma
op_amp
id|data
comma
l_int|4
)paren
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2_set_busy_timeout error&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called to parse sbp2 device&squot;s config rom unit&n; * directory. Used to determine things like sbp2 management agent offset,&n; * and command set used (SCSI or RBC). &n; */
DECL|function|sbp2_parse_unit_directory
r_static
r_void
id|sbp2_parse_unit_directory
c_func
(paren
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
)paren
(brace
r_struct
id|unit_directory
op_star
id|ud
suffix:semicolon
r_int
id|i
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_parse_unit_directory&quot;
)paren
suffix:semicolon
id|ud
op_assign
id|scsi_id-&gt;ud
suffix:semicolon
multiline_comment|/* Handle different fields in the unit directory, based on keys */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ud-&gt;arb_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|ud-&gt;arb_keys
(braket
id|i
)braket
)paren
(brace
r_case
id|SBP2_CSR_OFFSET_KEY
suffix:colon
multiline_comment|/* Save off the management agent address */
id|scsi_id-&gt;sbp2_management_agent_addr
op_assign
id|CONFIG_ROM_INITIAL_MEMORY_SPACE
op_plus
(paren
id|ud-&gt;arb_values
(braket
id|i
)braket
op_lshift
l_int|2
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_management_agent_addr = %x&quot;
comma
(paren
r_int
r_int
)paren
id|scsi_id-&gt;sbp2_management_agent_addr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBP2_COMMAND_SET_SPEC_ID_KEY
suffix:colon
multiline_comment|/* Command spec organization */
id|scsi_id-&gt;sbp2_command_set_spec_id
op_assign
id|ud-&gt;arb_values
(braket
id|i
)braket
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_command_set_spec_id = %x&quot;
comma
(paren
r_int
r_int
)paren
id|scsi_id-&gt;sbp2_command_set_spec_id
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBP2_COMMAND_SET_KEY
suffix:colon
multiline_comment|/* Command set used by sbp2 device */
id|scsi_id-&gt;sbp2_command_set
op_assign
id|ud-&gt;arb_values
(braket
id|i
)braket
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_command_set = %x&quot;
comma
(paren
r_int
r_int
)paren
id|scsi_id-&gt;sbp2_command_set
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBP2_UNIT_CHARACTERISTICS_KEY
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Unit characterisitcs (orb related stuff&n;&t;&t;&t; * that I&squot;m not yet paying attention to)&n;&t;&t;&t; */
id|scsi_id-&gt;sbp2_unit_characteristics
op_assign
id|ud-&gt;arb_values
(braket
id|i
)braket
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_unit_characteristics = %x&quot;
comma
(paren
r_int
r_int
)paren
id|scsi_id-&gt;sbp2_unit_characteristics
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBP2_DEVICE_TYPE_AND_LUN_KEY
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Device type and lun (used for&n;&t;&t;&t; * detemining type of sbp2 device)&n;&t;&t;&t; */
id|scsi_id-&gt;sbp2_device_type_and_lun
op_assign
id|ud-&gt;arb_values
(braket
id|i
)braket
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_device_type_and_lun = %x&quot;
comma
(paren
r_int
r_int
)paren
id|scsi_id-&gt;sbp2_device_type_and_lun
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBP2_FIRMWARE_REVISION_KEY
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Firmware revision (used to find broken&n;&t;&t;&t; * devices). If the vendor id is 0xa0b8&n;&t;&t;&t; * (Symbios vendor id), then we have a&n;&t;&t;&t; * bridge with 128KB max transfer size&n;&t;&t;&t; * limitation.&n;&t;&t;&t; */
id|scsi_id-&gt;sbp2_firmware_revision
op_assign
id|ud-&gt;arb_values
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|scsi_id-&gt;sbp2_firmware_revision
op_eq
id|SBP2_128KB_BROKEN_FIRMWARE
)paren
(brace
id|SBP2_WARN
c_func
(paren
l_string|&quot;warning: Bridge chipset supports 128KB max transfer size&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * This function is called in order to determine the max speed and packet&n; * size we can use in our ORBs. Note, that we (the driver and host) only&n; * initiate the transaction. The SBP-2 device actually transfers the data&n; * (by reading from the DMA area we tell it). This means that the SBP-2&n; * device decides the actual maximum data it can transfer. We just tell it&n; * the speed that it needs to use, and the max_rec the host supports, and&n; * it takes care of the rest.&n; */
DECL|function|sbp2_max_speed_and_size
r_static
r_int
id|sbp2_max_speed_and_size
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_max_speed_and_size&quot;
)paren
suffix:semicolon
multiline_comment|/* Initial setting comes from the hosts speed map */
id|scsi_id-&gt;speed_code
op_assign
id|hi-&gt;host-&gt;speed_map
(braket
(paren
id|hi-&gt;host-&gt;node_id
op_amp
id|NODE_MASK
)paren
op_star
l_int|64
op_plus
(paren
id|scsi_id-&gt;ne-&gt;nodeid
op_amp
id|NODE_MASK
)paren
)braket
suffix:semicolon
multiline_comment|/* Bump down our speed if the user requested it */
r_if
c_cond
(paren
id|scsi_id-&gt;speed_code
OG
id|max_speed
)paren
(brace
id|scsi_id-&gt;speed_code
op_assign
id|max_speed
suffix:semicolon
id|SBP2_ERR
c_func
(paren
l_string|&quot;Forcing SBP-2 max speed down to %s&quot;
comma
id|hpsb_speedto_str
(braket
id|scsi_id-&gt;speed_code
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Payload size is the lesser of what our speed supports and what&n;&t; * our host supports.  */
id|scsi_id-&gt;max_payload_size
op_assign
id|min
c_func
(paren
id|sbp2_speedto_maxrec
(braket
id|scsi_id-&gt;speed_code
)braket
comma
(paren
id|u8
)paren
(paren
(paren
(paren
id|be32_to_cpu
c_func
(paren
id|hi-&gt;host-&gt;csr.rom
(braket
l_int|2
)braket
)paren
op_rshift
l_int|12
)paren
op_amp
l_int|0xf
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|SBP2_ERR
c_func
(paren
l_string|&quot;Node &quot;
id|NODE_BUS_FMT
l_string|&quot;: Max speed [%s] - Max payload [0x%02x/%u]&quot;
comma
id|NODE_BUS_ARGS
c_func
(paren
id|scsi_id-&gt;ne-&gt;nodeid
)paren
comma
id|hpsb_speedto_str
(braket
id|scsi_id-&gt;speed_code
)braket
comma
id|scsi_id-&gt;max_payload_size
comma
l_int|1
op_lshift
(paren
(paren
id|u32
)paren
id|scsi_id-&gt;max_payload_size
op_plus
l_int|2
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called in order to perform a SBP-2 agent reset. &n; */
DECL|function|sbp2_agent_reset
r_static
r_int
id|sbp2_agent_reset
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
id|u32
id|flags
)paren
(brace
r_struct
id|sbp2_request_packet
op_star
id|agent_reset_request_packet
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_agent_reset&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, let&squot;s write to the target&squot;s management agent register&n;&t; */
id|agent_reset_request_packet
op_assign
id|sbp2util_allocate_write_request_packet
c_func
(paren
id|hi
comma
id|LOCAL_BUS
op_or
id|scsi_id-&gt;ne-&gt;nodeid
comma
id|scsi_id-&gt;sbp2_command_block_agent_addr
op_plus
id|SBP2_AGENT_RESET_OFFSET
comma
l_int|0
comma
id|ntohl
c_func
(paren
id|SBP2_AGENT_RESET_DATA
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|agent_reset_request_packet
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2util_allocate_write_request_packet failed&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|hpsb_send_packet
c_func
(paren
id|agent_reset_request_packet-&gt;packet
)paren
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;hpsb_send_packet failed&quot;
)paren
suffix:semicolon
id|sbp2util_free_request_packet
c_func
(paren
id|agent_reset_request_packet
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|SBP2_SEND_NO_WAIT
)paren
)paren
(brace
id|down
c_func
(paren
op_amp
id|agent_reset_request_packet-&gt;packet-&gt;state_change
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|agent_reset_request_packet-&gt;packet-&gt;state_change
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Need to make sure orb pointer is written on next command&n;&t; */
id|scsi_id-&gt;last_orb
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called to create the actual command orb and s/g list&n; * out of the scsi command itself.&n; */
DECL|function|sbp2_create_command_orb
r_static
r_int
id|sbp2_create_command_orb
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
r_struct
id|sbp2_command_info
op_star
id|command
comma
id|unchar
op_star
id|scsi_cmd
comma
r_int
r_int
id|scsi_use_sg
comma
r_int
r_int
id|scsi_request_bufflen
comma
r_void
op_star
id|scsi_request_buffer
comma
r_int
id|dma_dir
)paren
(brace
r_struct
id|scatterlist
op_star
id|sgpnt
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|scsi_request_buffer
suffix:semicolon
r_struct
id|sbp2_command_orb
op_star
id|command_orb
op_assign
op_amp
id|command-&gt;command_orb
suffix:semicolon
r_struct
id|sbp2_unrestricted_page_table
op_star
id|scatter_gather_element
op_assign
op_amp
id|command-&gt;scatter_gather_element
(braket
l_int|0
)braket
suffix:semicolon
id|u32
id|sg_count
comma
id|sg_len
suffix:semicolon
id|dma_addr_t
id|sg_addr
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Set-up our command ORB..&n;&t; *&n;&t; * NOTE: We&squot;re doing unrestricted page tables (s/g), as this is&n;&t; * best performance (at least with the devices I have). This means&n;&t; * that data_size becomes the number of s/g elements, and&n;&t; * page_size should be zero (for unrestricted).&n;&t; */
id|command_orb-&gt;next_ORB_hi
op_assign
l_int|0xffffffff
suffix:semicolon
id|command_orb-&gt;next_ORB_lo
op_assign
l_int|0xffffffff
suffix:semicolon
id|command_orb-&gt;misc
op_assign
id|ORB_SET_MAX_PAYLOAD
c_func
(paren
id|scsi_id-&gt;max_payload_size
)paren
suffix:semicolon
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_SPEED
c_func
(paren
id|scsi_id-&gt;speed_code
)paren
suffix:semicolon
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_NOTIFY
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Notify us when complete */
multiline_comment|/*&n;&t; * Set-up our pagetable stuff... unfortunately, this has become&n;&t; * messier than I&squot;d like. Need to clean this up a bit.   ;-)&n;&t; */
r_if
c_cond
(paren
id|sbp2scsi_direction_table
(braket
op_star
id|scsi_cmd
)braket
op_eq
id|ORB_DIRECTION_NO_DATA_TRANSFER
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;No data transfer&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Handle no data transfer&n;&t;&t; */
id|command_orb-&gt;data_descriptor_hi
op_assign
l_int|0xffffffff
suffix:semicolon
id|command_orb-&gt;data_descriptor_lo
op_assign
l_int|0xffffffff
suffix:semicolon
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_DIRECTION
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scsi_use_sg
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;Use scatter/gather&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Special case if only one element (and less than 64KB in size)&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|scsi_use_sg
op_eq
l_int|1
)paren
op_logical_and
(paren
id|sgpnt
(braket
l_int|0
)braket
dot
id|length
op_le
id|SBP2_MAX_SG_ELEMENT_LENGTH
)paren
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;Only one s/g element&quot;
)paren
suffix:semicolon
id|command-&gt;dma_dir
op_assign
id|dma_dir
suffix:semicolon
id|command-&gt;dma_size
op_assign
id|sgpnt
(braket
l_int|0
)braket
dot
id|length
suffix:semicolon
id|command-&gt;cmd_dma
op_assign
id|pci_map_single
(paren
id|hi-&gt;host-&gt;pdev
comma
id|sgpnt
(braket
l_int|0
)braket
dot
id|address
comma
id|command-&gt;dma_size
comma
id|command-&gt;dma_dir
)paren
suffix:semicolon
id|SBP2_DMA_ALLOC
c_func
(paren
l_string|&quot;single scatter element&quot;
)paren
suffix:semicolon
id|command_orb-&gt;data_descriptor_hi
op_assign
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
suffix:semicolon
id|command_orb-&gt;data_descriptor_lo
op_assign
id|command-&gt;cmd_dma
suffix:semicolon
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_DATA_SIZE
c_func
(paren
id|command-&gt;dma_size
)paren
suffix:semicolon
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_DIRECTION
c_func
(paren
id|sbp2scsi_direction_table
(braket
op_star
id|scsi_cmd
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|count
op_assign
id|pci_map_sg
c_func
(paren
id|hi-&gt;host-&gt;pdev
comma
id|sgpnt
comma
id|scsi_use_sg
comma
id|dma_dir
)paren
suffix:semicolon
id|SBP2_DMA_ALLOC
c_func
(paren
l_string|&quot;scatter list&quot;
)paren
suffix:semicolon
id|command-&gt;dma_size
op_assign
id|scsi_use_sg
suffix:semicolon
id|command-&gt;dma_dir
op_assign
id|dma_dir
suffix:semicolon
id|command-&gt;sge_buffer
op_assign
id|sgpnt
suffix:semicolon
multiline_comment|/* use page tables (s/g) */
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_PAGE_TABLE_PRESENT
c_func
(paren
l_int|0x1
)paren
suffix:semicolon
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_DIRECTION
c_func
(paren
id|sbp2scsi_direction_table
(braket
op_star
id|scsi_cmd
)braket
)paren
suffix:semicolon
id|command_orb-&gt;data_descriptor_hi
op_assign
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
suffix:semicolon
id|command_orb-&gt;data_descriptor_lo
op_assign
id|command-&gt;sge_dma
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Loop through and fill out our sbp-2 page tables&n;&t;&t;&t; * (and split up anything too large)&n;&t;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|sg_count
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|sgpnt
op_increment
)paren
(brace
id|sg_len
op_assign
id|sg_dma_len
c_func
(paren
id|sgpnt
)paren
suffix:semicolon
id|sg_addr
op_assign
id|sg_dma_address
c_func
(paren
id|sgpnt
)paren
suffix:semicolon
r_while
c_loop
(paren
id|sg_len
)paren
(brace
id|scatter_gather_element
(braket
id|sg_count
)braket
dot
id|segment_base_lo
op_assign
id|sg_addr
suffix:semicolon
r_if
c_cond
(paren
id|sg_len
OG
id|SBP2_MAX_SG_ELEMENT_LENGTH
)paren
(brace
id|scatter_gather_element
(braket
id|sg_count
)braket
dot
id|length_segment_base_hi
op_assign
id|PAGE_TABLE_SET_SEGMENT_LENGTH
c_func
(paren
id|SBP2_MAX_SG_ELEMENT_LENGTH
)paren
suffix:semicolon
id|sg_addr
op_add_assign
id|SBP2_MAX_SG_ELEMENT_LENGTH
suffix:semicolon
id|sg_len
op_sub_assign
id|SBP2_MAX_SG_ELEMENT_LENGTH
suffix:semicolon
)brace
r_else
(brace
id|scatter_gather_element
(braket
id|sg_count
)braket
dot
id|length_segment_base_hi
op_assign
id|PAGE_TABLE_SET_SEGMENT_LENGTH
c_func
(paren
id|sg_len
)paren
suffix:semicolon
id|sg_len
op_assign
l_int|0
suffix:semicolon
)brace
id|sg_count
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Number of page table (s/g) elements */
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_DATA_SIZE
c_func
(paren
id|sg_count
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Byte swap page tables if necessary&n;&t;&t;&t; */
id|sbp2util_cpu_to_be32_buffer
c_func
(paren
id|scatter_gather_element
comma
(paren
r_sizeof
(paren
r_struct
id|sbp2_unrestricted_page_table
)paren
)paren
op_star
id|sg_count
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;No scatter/gather&quot;
)paren
suffix:semicolon
id|command-&gt;dma_dir
op_assign
id|dma_dir
suffix:semicolon
id|command-&gt;dma_size
op_assign
id|scsi_request_bufflen
suffix:semicolon
id|command-&gt;cmd_dma
op_assign
id|pci_map_single
(paren
id|hi-&gt;host-&gt;pdev
comma
id|scsi_request_buffer
comma
id|command-&gt;dma_size
comma
id|command-&gt;dma_dir
)paren
suffix:semicolon
id|SBP2_DMA_ALLOC
c_func
(paren
l_string|&quot;single bulk&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Handle case where we get a command w/o s/g enabled (but&n;&t;&t; * check for transfers larger than 64K)&n;&t;&t; */
r_if
c_cond
(paren
id|scsi_request_bufflen
op_le
id|SBP2_MAX_SG_ELEMENT_LENGTH
)paren
(brace
id|command_orb-&gt;data_descriptor_hi
op_assign
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
suffix:semicolon
id|command_orb-&gt;data_descriptor_lo
op_assign
id|command-&gt;cmd_dma
suffix:semicolon
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_DATA_SIZE
c_func
(paren
id|scsi_request_bufflen
)paren
suffix:semicolon
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_DIRECTION
c_func
(paren
id|sbp2scsi_direction_table
(braket
op_star
id|scsi_cmd
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Sanity, in case our direction table is not&n;&t;&t;&t; * up-to-date&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|scsi_request_bufflen
)paren
(brace
id|command_orb-&gt;data_descriptor_hi
op_assign
l_int|0xffffffff
suffix:semicolon
id|command_orb-&gt;data_descriptor_lo
op_assign
l_int|0xffffffff
suffix:semicolon
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_DIRECTION
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Need to turn this into page tables, since the&n;&t;&t;&t; * buffer is too large.&n;&t;&t;&t; */
id|command_orb-&gt;data_descriptor_hi
op_assign
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
suffix:semicolon
id|command_orb-&gt;data_descriptor_lo
op_assign
id|command-&gt;sge_dma
suffix:semicolon
multiline_comment|/* Use page tables (s/g) */
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_PAGE_TABLE_PRESENT
c_func
(paren
l_int|0x1
)paren
suffix:semicolon
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_DIRECTION
c_func
(paren
id|sbp2scsi_direction_table
(braket
op_star
id|scsi_cmd
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * fill out our sbp-2 page tables (and split up&n;&t;&t;&t; * the large buffer)&n;&t;&t;&t; */
id|sg_count
op_assign
l_int|0
suffix:semicolon
id|sg_len
op_assign
id|scsi_request_bufflen
suffix:semicolon
id|sg_addr
op_assign
id|command-&gt;cmd_dma
suffix:semicolon
r_while
c_loop
(paren
id|sg_len
)paren
(brace
id|scatter_gather_element
(braket
id|sg_count
)braket
dot
id|segment_base_lo
op_assign
id|sg_addr
suffix:semicolon
r_if
c_cond
(paren
id|sg_len
OG
id|SBP2_MAX_SG_ELEMENT_LENGTH
)paren
(brace
id|scatter_gather_element
(braket
id|sg_count
)braket
dot
id|length_segment_base_hi
op_assign
id|PAGE_TABLE_SET_SEGMENT_LENGTH
c_func
(paren
id|SBP2_MAX_SG_ELEMENT_LENGTH
)paren
suffix:semicolon
id|sg_addr
op_add_assign
id|SBP2_MAX_SG_ELEMENT_LENGTH
suffix:semicolon
id|sg_len
op_sub_assign
id|SBP2_MAX_SG_ELEMENT_LENGTH
suffix:semicolon
)brace
r_else
(brace
id|scatter_gather_element
(braket
id|sg_count
)braket
dot
id|length_segment_base_hi
op_assign
id|PAGE_TABLE_SET_SEGMENT_LENGTH
c_func
(paren
id|sg_len
)paren
suffix:semicolon
id|sg_len
op_assign
l_int|0
suffix:semicolon
)brace
id|sg_count
op_increment
suffix:semicolon
)brace
multiline_comment|/* Number of page table (s/g) elements */
id|command_orb-&gt;misc
op_or_assign
id|ORB_SET_DATA_SIZE
c_func
(paren
id|sg_count
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Byte swap page tables if necessary&n;&t;&t;&t; */
id|sbp2util_cpu_to_be32_buffer
c_func
(paren
id|scatter_gather_element
comma
(paren
r_sizeof
(paren
r_struct
id|sbp2_unrestricted_page_table
)paren
)paren
op_star
id|sg_count
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Byte swap command ORB if necessary&n;&t; */
id|sbp2util_cpu_to_be32_buffer
c_func
(paren
id|command_orb
comma
r_sizeof
(paren
r_struct
id|sbp2_command_orb
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Put our scsi command in the command ORB&n;&t; */
id|memset
c_func
(paren
id|command_orb-&gt;cdb
comma
l_int|0
comma
l_int|12
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|command_orb-&gt;cdb
comma
id|scsi_cmd
comma
id|COMMAND_SIZE
c_func
(paren
op_star
id|scsi_cmd
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called in order to begin a regular SBP-2 command. &n; */
DECL|function|sbp2_link_orb_command
r_static
r_int
id|sbp2_link_orb_command
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
r_struct
id|sbp2_command_info
op_star
id|command
)paren
(brace
r_struct
id|sbp2_request_packet
op_star
id|command_request_packet
suffix:semicolon
r_struct
id|sbp2_command_orb
op_star
id|command_orb
op_assign
op_amp
id|command-&gt;command_orb
suffix:semicolon
id|outstanding_orb_incr
suffix:semicolon
id|SBP2_ORB_DEBUG
c_func
(paren
l_string|&quot;sending command orb %p, linked = %x, total orbs = %x&quot;
comma
id|command_orb
comma
id|command-&gt;linked
comma
id|global_outstanding_command_orbs
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check to see if there are any previous orbs to use&n;&t; */
r_if
c_cond
(paren
id|scsi_id-&gt;last_orb
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * Ok, let&squot;s write to the target&squot;s management agent register&n;&t;&t; */
r_if
c_cond
(paren
id|hpsb_node_entry_valid
c_func
(paren
id|scsi_id-&gt;ne
)paren
)paren
(brace
id|command_request_packet
op_assign
id|sbp2util_allocate_write_request_packet
c_func
(paren
id|hi
comma
id|LOCAL_BUS
op_or
id|scsi_id-&gt;ne-&gt;nodeid
comma
id|scsi_id-&gt;sbp2_command_block_agent_addr
op_plus
id|SBP2_ORB_POINTER_OFFSET
comma
l_int|8
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|command_request_packet
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2util_allocate_write_request_packet failed&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|command_request_packet-&gt;packet-&gt;data
(braket
l_int|0
)braket
op_assign
id|ORB_SET_NODE_ID
c_func
(paren
id|hi-&gt;host-&gt;node_id
)paren
suffix:semicolon
id|command_request_packet-&gt;packet-&gt;data
(braket
l_int|1
)braket
op_assign
id|command-&gt;command_orb_dma
suffix:semicolon
id|sbp2util_cpu_to_be32_buffer
c_func
(paren
id|command_request_packet-&gt;packet-&gt;data
comma
l_int|8
)paren
suffix:semicolon
id|SBP2_ORB_DEBUG
c_func
(paren
l_string|&quot;write command agent, command orb %p&quot;
comma
id|command_orb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hpsb_send_packet
c_func
(paren
id|command_request_packet-&gt;packet
)paren
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;hpsb_send_packet failed&quot;
)paren
suffix:semicolon
id|sbp2util_free_request_packet
c_func
(paren
id|command_request_packet
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|SBP2_ORB_DEBUG
c_func
(paren
l_string|&quot;write command agent complete&quot;
)paren
suffix:semicolon
)brace
id|scsi_id-&gt;last_orb
op_assign
id|command_orb
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * We have an orb already sent (maybe or maybe not&n;&t;&t; * processed) that we can append this orb to. So do so,&n;&t;&t; * and ring the doorbell. Have to be very careful&n;&t;&t; * modifying these next orb pointers, as they are accessed&n;&t;&t; * both by the sbp2 device and us.&n;&t;&t; */
id|scsi_id-&gt;last_orb-&gt;next_ORB_lo
op_assign
id|cpu_to_be32
c_func
(paren
id|command-&gt;command_orb_dma
)paren
suffix:semicolon
multiline_comment|/* Tells hardware that this pointer is valid */
id|scsi_id-&gt;last_orb-&gt;next_ORB_hi
op_assign
l_int|0x0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Only ring the doorbell if we need to (first parts of&n;&t;&t; * linked orbs don&squot;t need this).&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|command-&gt;linked
op_logical_and
id|hpsb_node_entry_valid
c_func
(paren
id|scsi_id-&gt;ne
)paren
)paren
(brace
id|command_request_packet
op_assign
id|sbp2util_allocate_write_request_packet
c_func
(paren
id|hi
comma
id|LOCAL_BUS
op_or
id|scsi_id-&gt;ne-&gt;nodeid
comma
id|scsi_id-&gt;sbp2_command_block_agent_addr
op_plus
id|SBP2_DOORBELL_OFFSET
comma
l_int|0
comma
id|cpu_to_be32
c_func
(paren
id|command-&gt;command_orb_dma
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|command_request_packet
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2util_allocate_write_request_packet failed&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|SBP2_ORB_DEBUG
c_func
(paren
l_string|&quot;ring doorbell, command orb %p&quot;
comma
id|command_orb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hpsb_send_packet
c_func
(paren
id|command_request_packet-&gt;packet
)paren
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;hpsb_send_packet failed&quot;
)paren
suffix:semicolon
id|sbp2util_free_request_packet
c_func
(paren
id|command_request_packet
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
id|scsi_id-&gt;last_orb
op_assign
id|command_orb
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called in order to begin a regular SBP-2 command. &n; */
DECL|function|sbp2_send_command
r_static
r_int
id|sbp2_send_command
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
id|unchar
op_star
id|cmd
op_assign
(paren
id|unchar
op_star
)paren
id|SCpnt-&gt;cmnd
suffix:semicolon
id|u32
id|device_type
op_assign
(paren
id|scsi_id-&gt;sbp2_device_type_and_lun
op_amp
l_int|0x00ff0000
)paren
op_rshift
l_int|16
suffix:semicolon
r_struct
id|sbp2_command_info
op_star
id|command
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_send_command&quot;
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;SCSI command = %02x&quot;
comma
op_star
id|cmd
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;SCSI transfer size = %x&quot;
comma
id|SCpnt-&gt;request_bufflen
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;SCSI s/g elements = %x&quot;
comma
(paren
r_int
r_int
)paren
id|SCpnt-&gt;use_sg
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check for broken devices that can&squot;t handle greater than 128K&n;&t; * transfers, and deal with them in a hacked ugly way.&n;&t; */
r_if
c_cond
(paren
(paren
id|scsi_id-&gt;sbp2_firmware_revision
op_eq
id|SBP2_128KB_BROKEN_FIRMWARE
)paren
op_logical_and
(paren
id|SCpnt-&gt;request_bufflen
OG
id|SBP2_BROKEN_FIRMWARE_MAX_TRANSFER
)paren
op_logical_and
(paren
id|device_type
op_eq
id|TYPE_DISK
)paren
op_logical_and
(paren
id|SCpnt-&gt;use_sg
)paren
op_logical_and
(paren
op_star
id|cmd
op_eq
l_int|0x28
op_logical_or
op_star
id|cmd
op_eq
l_int|0x2a
op_logical_or
op_star
id|cmd
op_eq
l_int|0x0a
op_logical_or
op_star
id|cmd
op_eq
l_int|0x08
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Darn, a broken device. We&squot;ll need to split up the&n;&t;&t; * transfer ourselves.&n;&t;&t; */
id|sbp2_send_split_command
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|SCpnt
comma
id|done
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Allocate a command orb and s/g structure&n;&t; */
id|command
op_assign
id|sbp2util_allocate_command_orb
c_func
(paren
id|scsi_id
comma
id|SCpnt
comma
id|done
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|command
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now actually fill in the comamnd orb and sbp2 s/g list&n;&t; */
id|sbp2_create_command_orb
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|command
comma
id|cmd
comma
id|SCpnt-&gt;use_sg
comma
id|SCpnt-&gt;request_bufflen
comma
id|SCpnt-&gt;request_buffer
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|SCpnt-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Update our cdb if necessary (to handle sbp2 RBC command set&n;&t; * differences).  This is where the command set hacks go!   =)&n;&t; */
r_if
c_cond
(paren
(paren
id|device_type
op_eq
id|TYPE_DISK
)paren
op_logical_or
(paren
id|device_type
op_eq
id|TYPE_SDAD
)paren
op_logical_or
(paren
id|device_type
op_eq
id|TYPE_ROM
)paren
)paren
(brace
id|sbp2_check_sbp2_command
c_func
(paren
id|command-&gt;command_orb.cdb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Initialize status fifo&n;&t; */
id|memset
c_func
(paren
op_amp
id|scsi_id-&gt;status_block
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sbp2_status_block
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Link up the orb, and ring the doorbell if needed&n;&t; */
id|sbp2_link_orb_command
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|command
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called for broken sbp2 device, where we have to break&n; * up large transfers.&n; */
DECL|function|sbp2_send_split_command
r_static
r_int
id|sbp2_send_split_command
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
id|unchar
op_star
id|cmd
op_assign
(paren
id|unchar
op_star
)paren
id|SCpnt-&gt;cmnd
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sgpnt
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|SCpnt-&gt;request_buffer
suffix:semicolon
r_struct
id|sbp2_command_info
op_star
id|command
suffix:semicolon
r_int
r_int
id|i
comma
id|block_count
comma
id|block_address
comma
id|block_size
suffix:semicolon
r_int
r_int
id|current_sg
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|total_transfer
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|total_sg
op_assign
l_int|0
suffix:semicolon
id|unchar
id|new_cmd
(braket
l_int|12
)braket
suffix:semicolon
id|memset
c_func
(paren
id|new_cmd
comma
l_int|0
comma
l_int|12
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|new_cmd
comma
id|cmd
comma
id|COMMAND_SIZE
c_func
(paren
op_star
id|cmd
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Turns command into 10 byte version&n;&t; */
id|sbp2_check_sbp2_command
c_func
(paren
id|new_cmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Pull block size, block address, block count from command sent down&n;&t; */
id|block_count
op_assign
(paren
id|cmd
(braket
l_int|7
)braket
op_lshift
l_int|8
)paren
op_or
id|cmd
(braket
l_int|8
)braket
suffix:semicolon
id|block_address
op_assign
(paren
id|cmd
(braket
l_int|2
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|cmd
(braket
l_int|3
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|cmd
(braket
l_int|4
)braket
op_lshift
l_int|8
)paren
op_or
id|cmd
(braket
l_int|5
)braket
suffix:semicolon
id|block_size
op_assign
id|SCpnt-&gt;request_bufflen
op_div
id|block_count
suffix:semicolon
multiline_comment|/*&n;&t; * Walk the scsi s/g list to determine how much we can transfer in one pop&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCpnt-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
id|total_transfer
op_add_assign
id|sgpnt
(braket
id|i
)braket
dot
id|length
suffix:semicolon
id|total_sg
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|total_transfer
OG
id|SBP2_BROKEN_FIRMWARE_MAX_TRANSFER
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Back everything up one, so that we&squot;re less than 128KB&n;&t;&t;&t; */
id|total_transfer
op_sub_assign
id|sgpnt
(braket
id|i
)braket
dot
id|length
suffix:semicolon
id|total_sg
op_decrement
suffix:semicolon
id|i
op_decrement
suffix:semicolon
id|command
op_assign
id|sbp2util_allocate_command_orb
c_func
(paren
id|scsi_id
comma
id|SCpnt
comma
id|done
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|command
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * This is not the final piece, so mark it as linked&n;&t;&t;&t; */
id|command-&gt;linked
op_assign
l_int|1
suffix:semicolon
id|block_count
op_assign
id|total_transfer
op_div
id|block_size
suffix:semicolon
id|new_cmd
(braket
l_int|2
)braket
op_assign
(paren
id|unchar
)paren
(paren
id|block_address
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
suffix:semicolon
id|new_cmd
(braket
l_int|3
)braket
op_assign
(paren
id|unchar
)paren
(paren
id|block_address
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|new_cmd
(braket
l_int|4
)braket
op_assign
(paren
id|unchar
)paren
(paren
id|block_address
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|new_cmd
(braket
l_int|5
)braket
op_assign
(paren
id|unchar
)paren
id|block_address
op_amp
l_int|0xff
suffix:semicolon
id|new_cmd
(braket
l_int|7
)braket
op_assign
(paren
id|unchar
)paren
(paren
id|block_count
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|new_cmd
(braket
l_int|8
)braket
op_assign
(paren
id|unchar
)paren
id|block_count
op_amp
l_int|0xff
suffix:semicolon
id|block_address
op_add_assign
id|block_count
suffix:semicolon
id|sbp2_create_command_orb
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|command
comma
id|new_cmd
comma
id|total_sg
comma
id|total_transfer
comma
op_amp
id|sgpnt
(braket
id|current_sg
)braket
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|SCpnt-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Link up the orb, and ring the doorbell if needed&n;&t;&t;&t; */
id|memset
c_func
(paren
op_amp
id|scsi_id-&gt;status_block
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sbp2_status_block
)paren
)paren
suffix:semicolon
id|sbp2_link_orb_command
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|command
)paren
suffix:semicolon
id|current_sg
op_add_assign
id|total_sg
suffix:semicolon
id|total_sg
op_assign
l_int|0
suffix:semicolon
id|total_transfer
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Get the last piece...&n;&t; */
id|command
op_assign
id|sbp2util_allocate_command_orb
c_func
(paren
id|scsi_id
comma
id|SCpnt
comma
id|done
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|command
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|block_count
op_assign
id|total_transfer
op_div
id|block_size
suffix:semicolon
id|new_cmd
(braket
l_int|2
)braket
op_assign
(paren
id|unchar
)paren
(paren
id|block_address
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
suffix:semicolon
id|new_cmd
(braket
l_int|3
)braket
op_assign
(paren
id|unchar
)paren
(paren
id|block_address
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|new_cmd
(braket
l_int|4
)braket
op_assign
(paren
id|unchar
)paren
(paren
id|block_address
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|new_cmd
(braket
l_int|5
)braket
op_assign
(paren
id|unchar
)paren
id|block_address
op_amp
l_int|0xff
suffix:semicolon
id|new_cmd
(braket
l_int|7
)braket
op_assign
(paren
id|unchar
)paren
(paren
id|block_count
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|new_cmd
(braket
l_int|8
)braket
op_assign
(paren
id|unchar
)paren
id|block_count
op_amp
l_int|0xff
suffix:semicolon
id|sbp2_create_command_orb
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|command
comma
id|new_cmd
comma
id|total_sg
comma
id|total_transfer
comma
op_amp
id|sgpnt
(braket
id|current_sg
)braket
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|SCpnt-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Link up the orb, and ring the doorbell if needed&n;&t; */
id|memset
c_func
(paren
op_amp
id|scsi_id-&gt;status_block
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sbp2_status_block
)paren
)paren
suffix:semicolon
id|sbp2_link_orb_command
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|command
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function deals with command set differences between Linux scsi&n; * command set and sbp2 RBC command set.&n; */
DECL|function|sbp2_check_sbp2_command
r_static
r_void
id|sbp2_check_sbp2_command
c_func
(paren
id|unchar
op_star
id|cmd
)paren
(brace
id|unchar
id|new_cmd
(braket
l_int|16
)braket
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_check_sbp2_command&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
op_star
id|cmd
)paren
(brace
r_case
id|READ_6
suffix:colon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;Convert READ_6 to READ_10&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Need to turn read_6 into read_10&n;&t;&t;&t; */
id|new_cmd
(braket
l_int|0
)braket
op_assign
l_int|0x28
suffix:semicolon
id|new_cmd
(braket
l_int|1
)braket
op_assign
(paren
id|cmd
(braket
l_int|1
)braket
op_amp
l_int|0xe0
)paren
suffix:semicolon
id|new_cmd
(braket
l_int|2
)braket
op_assign
l_int|0x0
suffix:semicolon
id|new_cmd
(braket
l_int|3
)braket
op_assign
(paren
id|cmd
(braket
l_int|1
)braket
op_amp
l_int|0x1f
)paren
suffix:semicolon
id|new_cmd
(braket
l_int|4
)braket
op_assign
id|cmd
(braket
l_int|2
)braket
suffix:semicolon
id|new_cmd
(braket
l_int|5
)braket
op_assign
id|cmd
(braket
l_int|3
)braket
suffix:semicolon
id|new_cmd
(braket
l_int|6
)braket
op_assign
l_int|0x0
suffix:semicolon
id|new_cmd
(braket
l_int|7
)braket
op_assign
l_int|0x0
suffix:semicolon
id|new_cmd
(braket
l_int|8
)braket
op_assign
id|cmd
(braket
l_int|4
)braket
suffix:semicolon
id|new_cmd
(braket
l_int|9
)braket
op_assign
id|cmd
(braket
l_int|5
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|cmd
comma
id|new_cmd
comma
l_int|10
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WRITE_6
suffix:colon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;Convert WRITE_6 to WRITE_10&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Need to turn write_6 into write_10&n;&t;&t;&t; */
id|new_cmd
(braket
l_int|0
)braket
op_assign
l_int|0x2a
suffix:semicolon
id|new_cmd
(braket
l_int|1
)braket
op_assign
(paren
id|cmd
(braket
l_int|1
)braket
op_amp
l_int|0xe0
)paren
suffix:semicolon
id|new_cmd
(braket
l_int|2
)braket
op_assign
l_int|0x0
suffix:semicolon
id|new_cmd
(braket
l_int|3
)braket
op_assign
(paren
id|cmd
(braket
l_int|1
)braket
op_amp
l_int|0x1f
)paren
suffix:semicolon
id|new_cmd
(braket
l_int|4
)braket
op_assign
id|cmd
(braket
l_int|2
)braket
suffix:semicolon
id|new_cmd
(braket
l_int|5
)braket
op_assign
id|cmd
(braket
l_int|3
)braket
suffix:semicolon
id|new_cmd
(braket
l_int|6
)braket
op_assign
l_int|0x0
suffix:semicolon
id|new_cmd
(braket
l_int|7
)braket
op_assign
l_int|0x0
suffix:semicolon
id|new_cmd
(braket
l_int|8
)braket
op_assign
id|cmd
(braket
l_int|4
)braket
suffix:semicolon
id|new_cmd
(braket
l_int|9
)braket
op_assign
id|cmd
(braket
l_int|5
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|cmd
comma
id|new_cmd
comma
l_int|10
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MODE_SENSE
suffix:colon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;Convert MODE_SENSE_6 to MOSE_SENSE_10&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Need to turn mode_sense_6 into mode_sense_10&n;&t;&t;&t; */
id|new_cmd
(braket
l_int|0
)braket
op_assign
l_int|0x5a
suffix:semicolon
id|new_cmd
(braket
l_int|1
)braket
op_assign
id|cmd
(braket
l_int|1
)braket
suffix:semicolon
id|new_cmd
(braket
l_int|2
)braket
op_assign
id|cmd
(braket
l_int|2
)braket
suffix:semicolon
id|new_cmd
(braket
l_int|3
)braket
op_assign
l_int|0x0
suffix:semicolon
id|new_cmd
(braket
l_int|4
)braket
op_assign
l_int|0x0
suffix:semicolon
id|new_cmd
(braket
l_int|5
)braket
op_assign
l_int|0x0
suffix:semicolon
id|new_cmd
(braket
l_int|6
)braket
op_assign
l_int|0x0
suffix:semicolon
id|new_cmd
(braket
l_int|7
)braket
op_assign
l_int|0x0
suffix:semicolon
id|new_cmd
(braket
l_int|8
)braket
op_assign
id|cmd
(braket
l_int|4
)braket
suffix:semicolon
id|new_cmd
(braket
l_int|9
)braket
op_assign
id|cmd
(braket
l_int|5
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|cmd
comma
id|new_cmd
comma
l_int|10
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MODE_SELECT
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * TODO. Probably need to change mode select to 10 byte version&n;&t;&t;&t; */
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Translates SBP-2 status into SCSI sense data for check conditions&n; */
DECL|function|sbp2_status_to_sense_data
r_static
r_int
r_int
id|sbp2_status_to_sense_data
c_func
(paren
id|unchar
op_star
id|sbp2_status
comma
id|unchar
op_star
id|sense_data
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_status_to_sense_data&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, it&squot;s pretty ugly...   ;-)&n;&t; */
id|sense_data
(braket
l_int|0
)braket
op_assign
l_int|0x70
suffix:semicolon
id|sense_data
(braket
l_int|1
)braket
op_assign
l_int|0x0
suffix:semicolon
id|sense_data
(braket
l_int|2
)braket
op_assign
id|sbp2_status
(braket
l_int|9
)braket
suffix:semicolon
id|sense_data
(braket
l_int|3
)braket
op_assign
id|sbp2_status
(braket
l_int|12
)braket
suffix:semicolon
id|sense_data
(braket
l_int|4
)braket
op_assign
id|sbp2_status
(braket
l_int|13
)braket
suffix:semicolon
id|sense_data
(braket
l_int|5
)braket
op_assign
id|sbp2_status
(braket
l_int|14
)braket
suffix:semicolon
id|sense_data
(braket
l_int|6
)braket
op_assign
id|sbp2_status
(braket
l_int|15
)braket
suffix:semicolon
id|sense_data
(braket
l_int|7
)braket
op_assign
l_int|10
suffix:semicolon
id|sense_data
(braket
l_int|8
)braket
op_assign
id|sbp2_status
(braket
l_int|16
)braket
suffix:semicolon
id|sense_data
(braket
l_int|9
)braket
op_assign
id|sbp2_status
(braket
l_int|17
)braket
suffix:semicolon
id|sense_data
(braket
l_int|10
)braket
op_assign
id|sbp2_status
(braket
l_int|18
)braket
suffix:semicolon
id|sense_data
(braket
l_int|11
)braket
op_assign
id|sbp2_status
(braket
l_int|19
)braket
suffix:semicolon
id|sense_data
(braket
l_int|12
)braket
op_assign
id|sbp2_status
(braket
l_int|10
)braket
suffix:semicolon
id|sense_data
(braket
l_int|13
)braket
op_assign
id|sbp2_status
(braket
l_int|11
)braket
suffix:semicolon
id|sense_data
(braket
l_int|14
)braket
op_assign
id|sbp2_status
(braket
l_int|20
)braket
suffix:semicolon
id|sense_data
(braket
l_int|15
)braket
op_assign
id|sbp2_status
(braket
l_int|21
)braket
suffix:semicolon
r_return
id|sbp2_status
(braket
l_int|8
)braket
op_amp
l_int|0x3f
suffix:semicolon
multiline_comment|/* return scsi status */
)brace
multiline_comment|/*&n; * This function is called after a command is completed, in order to do any necessary SBP-2&n; * response data translations for the SCSI stack&n; */
DECL|function|sbp2_check_sbp2_response
r_static
r_void
id|sbp2_check_sbp2_response
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|u8
op_star
id|scsi_buf
op_assign
id|SCpnt-&gt;request_buffer
suffix:semicolon
id|u32
id|device_type
op_assign
(paren
id|scsi_id-&gt;sbp2_device_type_and_lun
op_amp
l_int|0x00ff0000
)paren
op_rshift
l_int|16
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_check_sbp2_response&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|INQUIRY
suffix:colon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;Check Inquiry data&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Check for Simple Direct Access Device and change it to TYPE_DISK&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|scsi_buf
(braket
l_int|0
)braket
op_amp
l_int|0x1f
)paren
op_eq
id|TYPE_SDAD
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;Changing TYPE_SDAD to TYPE_DISK&quot;
)paren
suffix:semicolon
id|scsi_buf
(braket
l_int|0
)braket
op_and_assign
l_int|0xe0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Fix ansi revision and response data format&n;&t;&t;&t; */
id|scsi_buf
(braket
l_int|2
)braket
op_or_assign
l_int|2
suffix:semicolon
id|scsi_buf
(braket
l_int|3
)braket
op_assign
(paren
id|scsi_buf
(braket
l_int|3
)braket
op_amp
l_int|0xf0
)paren
op_or
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MODE_SENSE
suffix:colon
r_if
c_cond
(paren
(paren
id|device_type
op_eq
id|TYPE_DISK
)paren
op_logical_or
(paren
id|device_type
op_eq
id|TYPE_SDAD
)paren
op_logical_or
(paren
id|device_type
op_eq
id|TYPE_ROM
)paren
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;Modify mode sense response (10 byte version)&quot;
)paren
suffix:semicolon
id|scsi_buf
(braket
l_int|0
)braket
op_assign
id|scsi_buf
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Mode data length */
id|scsi_buf
(braket
l_int|1
)braket
op_assign
id|scsi_buf
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Medium type */
id|scsi_buf
(braket
l_int|2
)braket
op_assign
id|scsi_buf
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Device specific parameter */
id|scsi_buf
(braket
l_int|3
)braket
op_assign
id|scsi_buf
(braket
l_int|7
)braket
suffix:semicolon
multiline_comment|/* Block descriptor length */
id|memcpy
c_func
(paren
id|scsi_buf
op_plus
l_int|4
comma
id|scsi_buf
op_plus
l_int|8
comma
id|scsi_buf
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|MODE_SELECT
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * TODO. Probably need to change mode select to 10 byte version&n;&t;&t;&t; */
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This function deals with status writes from the SBP-2 device&n; */
DECL|function|sbp2_handle_status_write
r_static
r_int
id|sbp2_handle_status_write
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
comma
r_int
id|nodeid
comma
r_int
id|destid
comma
id|quadlet_t
op_star
id|data
comma
id|u64
id|addr
comma
r_int
r_int
id|length
)paren
(brace
r_struct
id|sbp2scsi_host_info
op_star
id|hi
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
id|u32
id|scsi_status
op_assign
id|SBP2_SCSI_STATUS_GOOD
suffix:semicolon
r_struct
id|sbp2_command_info
op_star
id|command
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_handle_status_write&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|host
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;host is NULL - this is bad!&quot;
)paren
suffix:semicolon
r_return
id|RCODE_ADDRESS_ERROR
suffix:semicolon
)brace
id|sbp2_spin_lock
c_func
(paren
op_amp
id|sbp2_host_info_lock
comma
id|flags
)paren
suffix:semicolon
id|hi
op_assign
id|sbp2_find_host_info
c_func
(paren
id|host
)paren
suffix:semicolon
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|sbp2_host_info_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hi
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;host info is NULL - this is bad!&quot;
)paren
suffix:semicolon
r_return
id|RCODE_ADDRESS_ERROR
suffix:semicolon
)brace
id|sbp2_spin_lock
c_func
(paren
op_amp
id|hi-&gt;sbp2_command_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Find our scsi_id structure&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SBP2SCSI_MAX_SCSI_IDS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hi-&gt;scsi_id
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
(paren
id|hi-&gt;scsi_id
(braket
id|i
)braket
op_member_access_from_pointer
id|ne-&gt;nodeid
op_amp
id|NODE_MASK
)paren
op_eq
(paren
id|nodeid
op_amp
id|NODE_MASK
)paren
)paren
(brace
id|scsi_id
op_assign
id|hi-&gt;scsi_id
(braket
id|i
)braket
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;SBP-2 status write from node %x&quot;
comma
id|scsi_id-&gt;ne-&gt;nodeid
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|scsi_id
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;scsi_id is NULL - device is gone?&quot;
)paren
suffix:semicolon
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|hi-&gt;sbp2_command_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|RCODE_ADDRESS_ERROR
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Put response into scsi_id status fifo... &n;&t; */
id|memcpy
c_func
(paren
op_amp
id|scsi_id-&gt;status_block
comma
id|data
comma
id|length
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Byte swap first two quadlets (8 bytes) of status for processing&n;&t; */
id|sbp2util_be32_to_cpu_buffer
c_func
(paren
op_amp
id|scsi_id-&gt;status_block
comma
l_int|8
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Handle command ORB status here if necessary. First, need to match status with command.&n;&t; */
id|command
op_assign
id|sbp2util_find_command_for_orb
c_func
(paren
id|scsi_id
comma
id|scsi_id-&gt;status_block.ORB_offset_lo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|command
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;Found status for command ORB&quot;
)paren
suffix:semicolon
id|SBP2_ORB_DEBUG
c_func
(paren
l_string|&quot;matched command orb %p&quot;
comma
op_amp
id|command-&gt;command_orb
)paren
suffix:semicolon
id|outstanding_orb_decr
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Matched status with command, now grab scsi command pointers and check status&n;&t;&t; */
id|SCpnt
op_assign
id|command-&gt;Current_SCpnt
suffix:semicolon
id|sbp2util_mark_command_completed
c_func
(paren
id|scsi_id
comma
id|command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt
op_logical_and
op_logical_neg
id|command-&gt;linked
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Handle check conditions&n;&t;&t;&t; */
r_if
c_cond
(paren
id|STATUS_GET_SBP_STATUS
c_func
(paren
id|scsi_id-&gt;status_block.ORB_offset_hi_misc
)paren
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;CHECK CONDITION&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Translate SBP-2 status to SCSI sense data&n;&t;&t;&t;&t; */
id|scsi_status
op_assign
id|sbp2_status_to_sense_data
c_func
(paren
(paren
id|unchar
op_star
)paren
op_amp
id|scsi_id-&gt;status_block
comma
id|SCpnt-&gt;sense_buffer
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Initiate a fetch agent reset. &n;&t;&t;&t;&t; */
id|sbp2_agent_reset
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|SBP2_SEND_NO_WAIT
)paren
suffix:semicolon
)brace
id|SBP2_ORB_DEBUG
c_func
(paren
l_string|&quot;completing command orb %p&quot;
comma
op_amp
id|command-&gt;command_orb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Complete the SCSI command&n;&t;&t;&t; */
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;Completing SCSI command&quot;
)paren
suffix:semicolon
id|sbp2scsi_complete_command
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|scsi_status
comma
id|SCpnt
comma
id|command-&gt;Current_done
)paren
suffix:semicolon
id|SBP2_ORB_DEBUG
c_func
(paren
l_string|&quot;command orb completed&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Check here to see if there are no commands in-use. If there are none, we can&n;&t;&t; * null out last orb so that next time around we write directly to the orb pointer... &n;&t;&t; * Quick start saves one 1394 bus transaction.&n;&t;&t; */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_inuse
)paren
)paren
(brace
id|scsi_id-&gt;last_orb
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|hi-&gt;sbp2_command_lock
comma
id|flags
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_login_wait
)paren
suffix:semicolon
r_return
id|RCODE_COMPLETE
suffix:semicolon
)brace
"&f;"
multiline_comment|/**************************************&n; * SCSI interface related section&n; **************************************/
multiline_comment|/*&n; * This routine is the main request entry routine for doing I/O. It is &n; * called from the scsi stack directly.&n; */
DECL|function|sbp2scsi_queuecommand
r_static
r_int
id|sbp2scsi_queuecommand
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_struct
id|sbp2scsi_host_info
op_star
id|hi
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2scsi_queuecommand&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Pull our host info and scsi id instance data from the scsi command&n;&t; */
id|hi
op_assign
(paren
r_struct
id|sbp2scsi_host_info
op_star
)paren
id|SCpnt-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hi
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;sbp2scsi_host_info is NULL - this is bad!&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
id|done
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|scsi_id
op_assign
id|hi-&gt;scsi_id
(braket
id|SCpnt-&gt;target
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * If scsi_id is null, it means there is no device in this slot,&n;&t; * so we should return selection timeout.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|scsi_id
)paren
(brace
id|SCpnt-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
id|done
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Until we handle multiple luns, just return selection time-out&n;&t; * to any IO directed at non-zero LUNs&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;lun
)paren
(brace
id|SCpnt-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
id|done
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check for request sense command, and handle it here&n;&t; * (autorequest sense)&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;REQUEST_SENSE&quot;
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|SCpnt-&gt;request_buffer
comma
id|SCpnt-&gt;sense_buffer
comma
id|SCpnt-&gt;request_bufflen
)paren
suffix:semicolon
id|memset
c_func
(paren
id|SCpnt-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
(paren
id|SCpnt-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|sbp2scsi_complete_command
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|SBP2_SCSI_STATUS_GOOD
comma
id|SCpnt
comma
id|done
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check to see if there is a command in progress and just return&n;&t; * busy (to be queued later)&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|hpsb_node_entry_valid
c_func
(paren
id|scsi_id-&gt;ne
)paren
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;Bus reset in progress - rejecting command&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
id|done
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Try and send our SCSI command&n;&t; */
id|sbp2_spin_lock
c_func
(paren
op_amp
id|hi-&gt;sbp2_command_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbp2_send_command
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|SCpnt
comma
id|done
)paren
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;Error sending SCSI command&quot;
)paren
suffix:semicolon
id|sbp2scsi_complete_command
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|SBP2_SCSI_STATUS_SELECTION_TIMEOUT
comma
id|SCpnt
comma
id|done
)paren
suffix:semicolon
)brace
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|hi-&gt;sbp2_command_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called in order to complete all outstanding SBP-2&n; * commands (in case of resets, etc.).&n; */
DECL|function|sbp2scsi_complete_all_commands
r_static
r_void
id|sbp2scsi_complete_all_commands
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
id|u32
id|status
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|sbp2_command_info
op_star
id|command
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2_complete_all_commands&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|scsi_id-&gt;sbp2_command_orb_inuse
)paren
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;Found pending command to complete&quot;
)paren
suffix:semicolon
id|lh
op_assign
id|scsi_id-&gt;sbp2_command_orb_inuse.next
suffix:semicolon
id|command
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|sbp2_command_info
comma
id|list
)paren
suffix:semicolon
id|sbp2util_mark_command_completed
c_func
(paren
id|scsi_id
comma
id|command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|command-&gt;Current_SCpnt
op_logical_and
op_logical_neg
id|command-&gt;linked
)paren
(brace
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
op_assign
id|command-&gt;Current_done
suffix:semicolon
id|command-&gt;Current_SCpnt-&gt;result
op_assign
id|status
op_lshift
l_int|16
suffix:semicolon
id|done
(paren
id|command-&gt;Current_SCpnt
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called in order to complete a regular SBP-2 command.&n; */
DECL|function|sbp2scsi_complete_command
r_static
r_void
id|sbp2scsi_complete_command
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
comma
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
comma
id|u32
id|scsi_status
comma
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2scsi_complete_command&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Sanity&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|SCpnt
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;SCpnt is NULL&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If a bus reset is in progress and there was an error, don&squot;t&n;&t; * complete the command, just let it get retried at the end of the&n;&t; * bus reset.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|hpsb_node_entry_valid
c_func
(paren
id|scsi_id-&gt;ne
)paren
op_logical_and
(paren
id|scsi_status
op_ne
id|SBP2_SCSI_STATUS_GOOD
)paren
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;Bus reset in progress - retry command later&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Switch on scsi status&n;&t; */
r_switch
c_cond
(paren
id|scsi_status
)paren
(brace
r_case
id|SBP2_SCSI_STATUS_GOOD
suffix:colon
id|SCpnt-&gt;result
op_assign
id|DID_OK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBP2_SCSI_STATUS_BUSY
suffix:colon
id|SBP2_ERR
c_func
(paren
l_string|&quot;SBP2_SCSI_STATUS_BUSY&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBP2_SCSI_STATUS_CHECK_CONDITION
suffix:colon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;SBP2_SCSI_STATUS_CHECK_CONDITION&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|CHECK_CONDITION
op_lshift
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Debug stuff&n;&t;&t;&t; */
id|print_sense
c_func
(paren
l_string|&quot;bh&quot;
comma
id|SCpnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBP2_SCSI_STATUS_SELECTION_TIMEOUT
suffix:colon
id|SBP2_ERR
c_func
(paren
l_string|&quot;SBP2_SCSI_STATUS_SELECTION_TIMEOUT&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SBP2_SCSI_STATUS_CONDITION_MET
suffix:colon
r_case
id|SBP2_SCSI_STATUS_RESERVATION_CONFLICT
suffix:colon
r_case
id|SBP2_SCSI_STATUS_COMMAND_TERMINATED
suffix:colon
id|SBP2_ERR
c_func
(paren
l_string|&quot;Bad SCSI status = %x&quot;
comma
id|scsi_status
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|SBP2_ERR
c_func
(paren
l_string|&quot;Unsupported SCSI status = %x&quot;
comma
id|scsi_status
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Take care of any sbp2 response data mucking here (RBC stuff, etc.)&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;result
op_eq
id|DID_OK
)paren
(brace
id|sbp2_check_sbp2_response
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|SCpnt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * One more quick hack (not enabled by default). Some sbp2 devices&n;&t; * do not support mode sense. Turn-on this hack to allow the&n;&t; * device to pass the sd driver&squot;s write-protect test (so that you&n;&t; * can mount the device rw).&n;&t; */
r_if
c_cond
(paren
id|mode_sense_hack
op_logical_and
id|SCpnt-&gt;result
op_ne
id|DID_OK
op_logical_and
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SENSE
)paren
(brace
id|SBP2_INFO
c_func
(paren
l_string|&quot;Returning success to mode sense command&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_OK
suffix:semicolon
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|memset
(paren
id|SCpnt-&gt;request_buffer
comma
l_int|0
comma
l_int|8
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If a bus reset is in progress and there was an error, complete&n;&t; * the command as busy so that it will get retried.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|hpsb_node_entry_valid
c_func
(paren
id|scsi_id-&gt;ne
)paren
op_logical_and
(paren
id|scsi_status
op_ne
id|SBP2_SCSI_STATUS_GOOD
)paren
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;Completing command with busy (bus reset)&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If a unit attention occurs, return busy status so it gets&n;&t; * retried... it could have happened because of a 1394 bus reset&n;&t; * or hot-plug...&n;&t; */
r_if
c_cond
(paren
(paren
id|scsi_status
op_eq
id|SBP2_SCSI_STATUS_CHECK_CONDITION
)paren
op_logical_and
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_eq
id|UNIT_ATTENTION
)paren
)paren
(brace
id|SBP2_INFO
c_func
(paren
l_string|&quot;UNIT ATTENTION - return busy&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Tell scsi stack that we&squot;re done with this command&n;&t; */
id|done
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by scsi stack when something has really gone wrong.  Usually&n; * called when a command has timed-out for some reason.&n; */
DECL|function|sbp2scsi_abort
r_static
r_int
id|sbp2scsi_abort
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_struct
id|sbp2scsi_host_info
op_star
id|hi
op_assign
(paren
r_struct
id|sbp2scsi_host_info
op_star
)paren
id|SCpnt-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
r_struct
id|scsi_id_instance_data
op_star
id|scsi_id
op_assign
id|hi-&gt;scsi_id
(braket
id|SCpnt-&gt;target
)braket
suffix:semicolon
r_struct
id|sbp2_command_info
op_star
id|command
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|SBP2_ERR
c_func
(paren
l_string|&quot;aborting sbp2 command&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_id
)paren
(brace
multiline_comment|/*&n;&t;&t; * Right now, just return any matching command structures&n;&t;&t; * to the free pool (there may be more than one because of&n;&t;&t; * broken up/linked commands).&n;&t;&t; */
id|sbp2_spin_lock
c_func
(paren
op_amp
id|hi-&gt;sbp2_command_lock
comma
id|flags
)paren
suffix:semicolon
r_do
(brace
id|command
op_assign
id|sbp2util_find_command_for_SCpnt
c_func
(paren
id|scsi_id
comma
id|SCpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|command
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;Found command to abort&quot;
)paren
suffix:semicolon
id|sbp2util_mark_command_completed
c_func
(paren
id|scsi_id
comma
id|command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|command-&gt;Current_SCpnt
op_logical_and
op_logical_neg
id|command-&gt;linked
)paren
(brace
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
op_assign
id|command-&gt;Current_done
suffix:semicolon
id|command-&gt;Current_SCpnt-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|done
(paren
id|command-&gt;Current_SCpnt
)paren
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|command
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Initiate a fetch agent reset. &n;&t;&t; */
id|sbp2_agent_reset
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|SBP2_SEND_NO_WAIT
)paren
suffix:semicolon
id|sbp2scsi_complete_all_commands
c_func
(paren
id|hi
comma
id|scsi_id
comma
id|DID_BUS_BUSY
)paren
suffix:semicolon
id|sbp2_spin_unlock
c_func
(paren
op_amp
id|hi-&gt;sbp2_command_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|SCSI_ABORT_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by scsi stack when something has really gone wrong.&n; */
DECL|function|sbp2scsi_reset
r_static
r_int
id|sbp2scsi_reset
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
r_int
id|reset_flags
)paren
(brace
r_struct
id|sbp2scsi_host_info
op_star
id|hi
op_assign
(paren
r_struct
id|sbp2scsi_host_info
op_star
)paren
id|SCpnt-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
id|SBP2_ERR
c_func
(paren
l_string|&quot;reset requested&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hi
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;Generating IEEE-1394 bus reset&quot;
)paren
suffix:semicolon
id|hpsb_reset_bus
c_func
(paren
id|hi-&gt;host
comma
id|LONG_RESET
)paren
suffix:semicolon
)brace
r_return
id|SCSI_RESET_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by scsi stack to get bios parameters (used by fdisk, and at boot).&n; */
DECL|function|sbp2scsi_biosparam
r_static
r_int
id|sbp2scsi_biosparam
(paren
id|Scsi_Disk
op_star
id|disk
comma
id|kdev_t
id|dev
comma
r_int
id|geom
(braket
)braket
)paren
(brace
r_int
id|heads
comma
id|sectors
comma
id|cylinders
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;Request for bios parameters&quot;
)paren
suffix:semicolon
id|heads
op_assign
l_int|64
suffix:semicolon
id|sectors
op_assign
l_int|32
suffix:semicolon
id|cylinders
op_assign
id|disk-&gt;capacity
op_div
(paren
id|heads
op_star
id|sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cylinders
OG
l_int|1024
)paren
(brace
id|heads
op_assign
l_int|255
suffix:semicolon
id|sectors
op_assign
l_int|63
suffix:semicolon
id|cylinders
op_assign
id|disk-&gt;capacity
op_div
(paren
id|heads
op_star
id|sectors
)paren
suffix:semicolon
)brace
id|geom
(braket
l_int|0
)braket
op_assign
id|heads
suffix:semicolon
id|geom
(braket
l_int|1
)braket
op_assign
id|sectors
suffix:semicolon
id|geom
(braket
l_int|2
)braket
op_assign
id|cylinders
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called at setup (init) and does nothing. Not used here.   =)&n; */
DECL|function|sbp2scsi_setup
r_void
id|sbp2scsi_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2scsi_setup&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This is our detection routine, and is where we init everything.&n; */
DECL|function|sbp2scsi_detect
r_static
r_int
id|sbp2scsi_detect
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2scsi_detect&quot;
)paren
suffix:semicolon
id|global_scsi_tpnt
op_assign
id|tpnt
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,3,26)
id|global_scsi_tpnt-&gt;proc_name
op_assign
id|SBP2_DEVICE_NAME
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Module load option for force one command at a time&n;&t; */
r_if
c_cond
(paren
id|serialize_io
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;Driver forced to serialize I/O (serialize_io = 1)&quot;
)paren
suffix:semicolon
id|global_scsi_tpnt-&gt;can_queue
op_assign
l_int|1
suffix:semicolon
id|global_scsi_tpnt-&gt;cmd_per_lun
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Module load option to limit max size of requests from the scsi drivers&n;&t; */
r_if
c_cond
(paren
id|no_large_packets
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;Driver forced to limit max transfer size (no_large_packets = 1)&quot;
)paren
suffix:semicolon
id|global_scsi_tpnt-&gt;sg_tablesize
op_assign
l_int|0x1f
suffix:semicolon
id|global_scsi_tpnt-&gt;use_clustering
op_assign
id|DISABLE_CLUSTERING
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mode_sense_hack
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;Mode sense emulation enabled (mode_sense_hack = 1)&quot;
)paren
suffix:semicolon
)brace
id|sbp2_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sbp2_host_count
)paren
(brace
id|SBP2_ERR
c_func
(paren
l_string|&quot;Please load the lower level IEEE-1394 driver (e.g. ohci1394) before sbp2...&quot;
)paren
suffix:semicolon
id|sbp2_cleanup
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Since we are returning this count, it means that sbp2 must be&n;&t; * loaded &quot;after&quot; the host adapter module...&n;&t; */
r_return
id|sbp2_host_count
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called from sbp2_add_host, and is where we register&n; * our scsi host&n; */
DECL|function|sbp2scsi_register_scsi_host
r_static
r_void
id|sbp2scsi_register_scsi_host
c_func
(paren
r_struct
id|sbp2scsi_host_info
op_star
id|hi
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shpnt
op_assign
l_int|NULL
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2scsi_register_scsi_host&quot;
)paren
suffix:semicolon
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2scsi_host_info = %p&quot;
comma
id|hi
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Let&squot;s register with the scsi stack&n;&t; */
r_if
c_cond
(paren
id|global_scsi_tpnt
)paren
(brace
id|shpnt
op_assign
id|scsi_register
(paren
id|global_scsi_tpnt
comma
r_sizeof
(paren
r_void
op_star
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If successful, save off a context (to be used when SCSI&n;&t;&t; * commands are received)&n;&t;&t; */
r_if
c_cond
(paren
id|shpnt
)paren
(brace
id|shpnt-&gt;hostdata
(braket
l_int|0
)braket
op_assign
(paren
r_int
r_int
)paren
id|hi
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Called when our module is released */
DECL|function|sbp2scsi_release
r_static
r_int
id|sbp2scsi_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
id|SBP2_DEBUG
c_func
(paren
l_string|&quot;sbp2scsi_release&quot;
)paren
suffix:semicolon
id|sbp2_cleanup
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Called for contents of procfs */
DECL|function|sbp2scsi_info
r_static
r_const
r_char
op_star
id|sbp2scsi_info
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_return
l_string|&quot;IEEE-1394 SBP-2 protocol driver&quot;
suffix:semicolon
)brace
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;James Goodwin &lt;jamesg@filanet.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;IEEE-1394 SBP-2 protocol driver&quot;
)paren
suffix:semicolon
DECL|variable|SBP2_DEVICE_NAME
id|MODULE_SUPPORTED_DEVICE
c_func
(paren
id|SBP2_DEVICE_NAME
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
multiline_comment|/* SCSI host template */
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
(brace
id|name
suffix:colon
l_string|&quot;IEEE1394 SBP-2&quot;
comma
id|detect
suffix:colon
id|sbp2scsi_detect
comma
id|release
suffix:colon
id|sbp2scsi_release
comma
id|info
suffix:colon
id|sbp2scsi_info
comma
id|queuecommand
suffix:colon
id|sbp2scsi_queuecommand
comma
m_abort
suffix:colon
id|sbp2scsi_abort
comma
id|reset
suffix:colon
id|sbp2scsi_reset
comma
id|bios_param
suffix:colon
id|sbp2scsi_biosparam
comma
id|can_queue
suffix:colon
id|SBP2SCSI_MAX_OUTSTANDING_CMDS
comma
id|this_id
suffix:colon
op_minus
l_int|1
comma
id|sg_tablesize
suffix:colon
id|SBP2_MAX_SG_ELEMENTS
comma
id|cmd_per_lun
suffix:colon
id|SBP2SCSI_MAX_CMDS_PER_LUN
comma
id|use_clustering
suffix:colon
id|SBP2_CLUSTERING
comma
id|emulated
suffix:colon
l_int|1
)brace
suffix:semicolon
macro_line|#include &quot;../scsi/scsi_module.c&quot;
eof
