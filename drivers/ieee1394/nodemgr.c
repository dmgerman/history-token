multiline_comment|/*&n; * Node information (ConfigROM) collection and management.&n; *&n; * Copyright (C) 2000 Andreas E. Bombe&n; *               2001 Ben Collins &lt;bcollins@debian.net&gt;&n; *&n; * This code is licensed under the GPL.  See the file COPYING in the root&n; * directory of the kernel sources for details.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#ifdef CONFIG_PROC_FS
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#endif
macro_line|#include &quot;ieee1394_types.h&quot;
macro_line|#include &quot;ieee1394.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;ieee1394_transactions.h&quot;
macro_line|#include &quot;ieee1394_hotplug.h&quot;
macro_line|#include &quot;highlevel.h&quot;
macro_line|#include &quot;csr.h&quot;
macro_line|#include &quot;nodemgr.h&quot;
multiline_comment|/* &n; * Basically what we do here is start off retrieving the bus_info block.&n; * From there will fill in some info about the node, verify it is of IEEE&n; * 1394 type, and that the crc checks out ok. After that we start off with&n; * the root directory, and subdirectories. To do this, we retrieve the&n; * quadlet header for a directory, find out the length, and retrieve the&n; * complete directory entry (be it a leaf or a directory). We then process&n; * it and add the info to our structure for that particular node.&n; *&n; * We verify CRC&squot;s along the way for each directory/block/leaf. The&n; * entire node structure is generic, and simply stores the information in&n; * a way that&squot;s easy to parse by the protocol interface.&n; */
multiline_comment|/* The nodemgr maintains a number of data structures: the node list,&n; * the driver list, unit directory list and the host info list.  The&n; * first three lists are accessed from process context only: /proc&n; * readers, insmod and rmmod, and the nodemgr thread.  Access to these&n; * lists are serialized by means of the nodemgr_serialize mutex, which&n; * must be taken before accessing the structures and released&n; * afterwards.  The host info list is only accessed during insmod,&n; * rmmod and from interrupt and allways only for a short period of&n; * time, so a spinlock is used to protect this list.&n; */
r_static
id|DECLARE_MUTEX
c_func
(paren
id|nodemgr_serialize
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|node_list
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|driver_list
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|unit_directory_list
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|host_info_list
)paren
suffix:semicolon
DECL|variable|host_info_lock
r_static
id|spinlock_t
id|host_info_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* Disables use of the hotplug calls.  */
DECL|variable|nodemgr_disable_hotplug
r_static
r_int
id|nodemgr_disable_hotplug
op_assign
l_int|0
suffix:semicolon
DECL|struct|host_info
r_struct
id|host_info
(brace
DECL|member|host
r_struct
id|hpsb_host
op_star
id|host
suffix:semicolon
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|exited
r_struct
id|completion
id|exited
suffix:semicolon
DECL|member|reset_sem
r_struct
id|semaphore
id|reset_sem
suffix:semicolon
DECL|member|pid
r_int
id|pid
suffix:semicolon
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
DECL|macro|PUTF
mdefine_line|#define PUTF(fmt, args...) out += sprintf(out, fmt, ## args)
DECL|function|raw1394_read_proc
r_static
r_int
id|raw1394_read_proc
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|node_entry
op_star
id|ne
suffix:semicolon
r_int
id|len
suffix:semicolon
r_char
op_star
id|out
op_assign
id|page
suffix:semicolon
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|nodemgr_serialize
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
id|list_for_each
c_func
(paren
id|lh
comma
op_amp
id|node_list
)paren
(brace
r_struct
id|list_head
op_star
id|l
suffix:semicolon
r_int
id|ud_count
op_assign
l_int|0
suffix:semicolon
id|ne
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|node_entry
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ne
)paren
r_continue
suffix:semicolon
id|PUTF
c_func
(paren
l_string|&quot;Node[&quot;
id|NODE_BUS_FMT
l_string|&quot;]  GUID[%016Lx]:&bslash;n&quot;
comma
id|NODE_BUS_ARGS
c_func
(paren
id|ne-&gt;nodeid
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|ne-&gt;guid
)paren
suffix:semicolon
multiline_comment|/* Generic Node information */
id|PUTF
c_func
(paren
l_string|&quot;  Vendor ID: `%s&squot; [0x%06x]&bslash;n&quot;
comma
id|ne-&gt;vendor_name
ques
c_cond
suffix:colon
l_string|&quot;Unknown&quot;
comma
id|ne-&gt;vendor_id
)paren
suffix:semicolon
id|PUTF
c_func
(paren
l_string|&quot;  Capabilities: 0x%06x&bslash;n&quot;
comma
id|ne-&gt;capabilities
)paren
suffix:semicolon
id|PUTF
c_func
(paren
l_string|&quot;  Bus Options:&bslash;n&quot;
)paren
suffix:semicolon
id|PUTF
c_func
(paren
l_string|&quot;    IRMC(%d) CMC(%d) ISC(%d) BMC(%d) PMC(%d) GEN(%d)&bslash;n&quot;
l_string|&quot;    LSPD(%d) MAX_REC(%d) CYC_CLK_ACC(%d)&bslash;n&quot;
comma
id|ne-&gt;busopt.irmc
comma
id|ne-&gt;busopt.cmc
comma
id|ne-&gt;busopt.isc
comma
id|ne-&gt;busopt.bmc
comma
id|ne-&gt;busopt.pmc
comma
id|ne-&gt;busopt.generation
comma
id|ne-&gt;busopt.lnkspd
comma
id|ne-&gt;busopt.max_rec
comma
id|ne-&gt;busopt.cyc_clk_acc
)paren
suffix:semicolon
multiline_comment|/* If this is the host entry, output some info about it aswell */
r_if
c_cond
(paren
id|ne-&gt;host
op_ne
l_int|NULL
op_logical_and
id|ne-&gt;host-&gt;node_id
op_eq
id|ne-&gt;nodeid
)paren
(brace
id|PUTF
c_func
(paren
l_string|&quot;  Host Node Status:&bslash;n&quot;
)paren
suffix:semicolon
id|PUTF
c_func
(paren
l_string|&quot;    Host Driver     : %s&bslash;n&quot;
comma
id|ne-&gt;host-&gt;driver-&gt;name
)paren
suffix:semicolon
id|PUTF
c_func
(paren
l_string|&quot;    Nodes connected : %d&bslash;n&quot;
comma
id|ne-&gt;host-&gt;node_count
)paren
suffix:semicolon
id|PUTF
c_func
(paren
l_string|&quot;    Nodes active    : %d&bslash;n&quot;
comma
id|ne-&gt;host-&gt;nodes_active
)paren
suffix:semicolon
id|PUTF
c_func
(paren
l_string|&quot;    SelfIDs received: %d&bslash;n&quot;
comma
id|ne-&gt;host-&gt;selfid_count
)paren
suffix:semicolon
id|PUTF
c_func
(paren
l_string|&quot;    Irm ID          : [&quot;
id|NODE_BUS_FMT
l_string|&quot;]&bslash;n&quot;
comma
id|NODE_BUS_ARGS
c_func
(paren
id|ne-&gt;host-&gt;irm_id
)paren
)paren
suffix:semicolon
id|PUTF
c_func
(paren
l_string|&quot;    BusMgr ID       : [&quot;
id|NODE_BUS_FMT
l_string|&quot;]&bslash;n&quot;
comma
id|NODE_BUS_ARGS
c_func
(paren
id|ne-&gt;host-&gt;busmgr_id
)paren
)paren
suffix:semicolon
id|PUTF
c_func
(paren
l_string|&quot;    In Bus Reset    : %s&bslash;n&quot;
comma
id|ne-&gt;host-&gt;in_bus_reset
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
id|PUTF
c_func
(paren
l_string|&quot;    Root            : %s&bslash;n&quot;
comma
id|ne-&gt;host-&gt;is_root
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
id|PUTF
c_func
(paren
l_string|&quot;    Cycle Master    : %s&bslash;n&quot;
comma
id|ne-&gt;host-&gt;is_cycmst
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
id|PUTF
c_func
(paren
l_string|&quot;    IRM             : %s&bslash;n&quot;
comma
id|ne-&gt;host-&gt;is_irm
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
id|PUTF
c_func
(paren
l_string|&quot;    Bus Manager     : %s&bslash;n&quot;
comma
id|ne-&gt;host-&gt;is_busmgr
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Now the unit directories */
id|list_for_each
(paren
id|l
comma
op_amp
id|ne-&gt;unit_directories
)paren
(brace
r_struct
id|unit_directory
op_star
id|ud
op_assign
id|list_entry
(paren
id|l
comma
r_struct
id|unit_directory
comma
id|node_list
)paren
suffix:semicolon
r_int
id|printed
op_assign
l_int|0
suffix:semicolon
singleline_comment|// small hack
id|PUTF
c_func
(paren
l_string|&quot;  Unit Directory %d:&bslash;n&quot;
comma
id|ud_count
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;flags
op_amp
id|UNIT_DIRECTORY_VENDOR_ID
)paren
(brace
id|PUTF
c_func
(paren
l_string|&quot;    Vendor/Model ID: %s [%06x]&quot;
comma
id|ud-&gt;vendor_name
ques
c_cond
suffix:colon
l_string|&quot;Unknown&quot;
comma
id|ud-&gt;vendor_id
)paren
suffix:semicolon
id|printed
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ud-&gt;flags
op_amp
id|UNIT_DIRECTORY_MODEL_ID
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|printed
)paren
id|PUTF
c_func
(paren
l_string|&quot;    Vendor/Model ID: %s [%06x]&quot;
comma
id|ne-&gt;vendor_name
ques
c_cond
suffix:colon
l_string|&quot;Unknown&quot;
comma
id|ne-&gt;vendor_id
)paren
suffix:semicolon
id|PUTF
c_func
(paren
l_string|&quot; / %s [%06x]&quot;
comma
id|ud-&gt;model_name
ques
c_cond
suffix:colon
l_string|&quot;Unknown&quot;
comma
id|ud-&gt;model_id
)paren
suffix:semicolon
id|printed
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|printed
)paren
id|PUTF
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;flags
op_amp
id|UNIT_DIRECTORY_SPECIFIER_ID
)paren
id|PUTF
c_func
(paren
l_string|&quot;    Software Specifier ID: %06x&bslash;n&quot;
comma
id|ud-&gt;specifier_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;flags
op_amp
id|UNIT_DIRECTORY_VERSION
)paren
id|PUTF
c_func
(paren
l_string|&quot;    Software Version: %06x&bslash;n&quot;
comma
id|ud-&gt;version
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;driver
)paren
id|PUTF
c_func
(paren
l_string|&quot;    Driver: %s&bslash;n&quot;
comma
id|ud-&gt;driver-&gt;name
)paren
suffix:semicolon
id|PUTF
c_func
(paren
l_string|&quot;    Length (in quads): %d&bslash;n&quot;
comma
id|ud-&gt;count
)paren
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
op_amp
id|nodemgr_serialize
)paren
suffix:semicolon
id|len
op_assign
id|out
op_minus
id|page
suffix:semicolon
id|len
op_sub_assign
id|off
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|count
)paren
(brace
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
id|len
op_assign
id|count
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
id|off
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|macro|PUTF
macro_line|#undef PUTF
macro_line|#endif /* CONFIG_PROC_FS */
r_static
r_void
id|nodemgr_process_config_rom
c_func
(paren
r_struct
id|node_entry
op_star
id|ne
comma
id|quadlet_t
id|busoptions
)paren
suffix:semicolon
DECL|function|nodemgr_read_quadlet
r_static
r_int
id|nodemgr_read_quadlet
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
comma
id|nodeid_t
id|nodeid
comma
r_int
r_int
id|generation
comma
id|octlet_t
id|address
comma
id|quadlet_t
op_star
id|quad
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ret
op_assign
id|hpsb_read
c_func
(paren
id|host
comma
id|nodeid
comma
id|generation
comma
id|address
comma
id|quad
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
r_break
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|schedule_timeout
(paren
id|HZ
op_div
l_int|3
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
op_star
id|quad
op_assign
id|be32_to_cpu
c_func
(paren
op_star
id|quad
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|nodemgr_size_text_leaf
r_static
r_int
id|nodemgr_size_text_leaf
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
comma
id|nodeid_t
id|nodeid
comma
r_int
r_int
id|generation
comma
id|octlet_t
id|address
)paren
(brace
id|quadlet_t
id|quad
suffix:semicolon
r_int
id|size
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nodemgr_read_quadlet
c_func
(paren
id|host
comma
id|nodeid
comma
id|generation
comma
id|address
comma
op_amp
id|quad
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|CONFIG_ROM_KEY
c_func
(paren
id|quad
)paren
op_eq
id|CONFIG_ROM_DESCRIPTOR_LEAF
)paren
(brace
multiline_comment|/* This is the offset.  */
id|address
op_add_assign
l_int|4
op_star
id|CONFIG_ROM_VALUE
c_func
(paren
id|quad
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nodemgr_read_quadlet
c_func
(paren
id|host
comma
id|nodeid
comma
id|generation
comma
id|address
comma
op_amp
id|quad
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Now we got the size of the text descriptor leaf. */
id|size
op_assign
id|CONFIG_ROM_LEAF_LENGTH
c_func
(paren
id|quad
)paren
suffix:semicolon
)brace
r_return
id|size
suffix:semicolon
)brace
DECL|function|nodemgr_read_text_leaf
r_static
r_int
id|nodemgr_read_text_leaf
c_func
(paren
r_struct
id|node_entry
op_star
id|ne
comma
id|octlet_t
id|address
comma
id|quadlet_t
op_star
id|quadp
)paren
(brace
id|quadlet_t
id|quad
suffix:semicolon
r_int
id|i
comma
id|size
comma
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|nodemgr_read_quadlet
c_func
(paren
id|ne-&gt;host
comma
id|ne-&gt;nodeid
comma
id|ne-&gt;generation
comma
id|address
comma
op_amp
id|quad
)paren
op_logical_or
id|CONFIG_ROM_KEY
c_func
(paren
id|quad
)paren
op_ne
id|CONFIG_ROM_DESCRIPTOR_LEAF
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* This is the offset.  */
id|address
op_add_assign
l_int|4
op_star
id|CONFIG_ROM_VALUE
c_func
(paren
id|quad
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nodemgr_read_quadlet
c_func
(paren
id|ne-&gt;host
comma
id|ne-&gt;nodeid
comma
id|ne-&gt;generation
comma
id|address
comma
op_amp
id|quad
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Now we got the size of the text descriptor leaf. */
id|size
op_assign
id|CONFIG_ROM_LEAF_LENGTH
c_func
(paren
id|quad
)paren
op_minus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|size
op_le
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|address
op_add_assign
l_int|4
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
comma
id|address
op_add_assign
l_int|4
comma
id|quadp
op_increment
)paren
(brace
r_if
c_cond
(paren
id|nodemgr_read_quadlet
c_func
(paren
id|ne-&gt;host
comma
id|ne-&gt;nodeid
comma
id|ne-&gt;generation
comma
id|address
comma
id|quadp
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Now read the text string.  */
id|ret
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|size
OG
l_int|0
suffix:semicolon
id|size
op_decrement
comma
id|address
op_add_assign
l_int|4
comma
id|quadp
op_increment
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ret
op_assign
id|hpsb_read
c_func
(paren
id|ne-&gt;host
comma
id|ne-&gt;nodeid
comma
id|ne-&gt;generation
comma
id|address
comma
id|quadp
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
op_minus
id|EAGAIN
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
)paren
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|nodemgr_scan_root_directory
r_static
r_struct
id|node_entry
op_star
id|nodemgr_scan_root_directory
(paren
r_struct
id|hpsb_host
op_star
id|host
comma
id|nodeid_t
id|nodeid
comma
r_int
r_int
id|generation
)paren
(brace
id|octlet_t
id|address
suffix:semicolon
id|quadlet_t
id|quad
suffix:semicolon
r_int
id|length
suffix:semicolon
r_int
id|code
comma
id|size
comma
id|total_size
suffix:semicolon
r_struct
id|node_entry
op_star
id|ne
suffix:semicolon
id|address
op_assign
id|CSR_REGISTER_BASE
op_plus
id|CSR_CONFIG_ROM
suffix:semicolon
r_if
c_cond
(paren
id|nodemgr_read_quadlet
c_func
(paren
id|host
comma
id|nodeid
comma
id|generation
comma
id|address
comma
op_amp
id|quad
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|address
op_add_assign
l_int|4
op_plus
id|CONFIG_ROM_BUS_INFO_LENGTH
c_func
(paren
id|quad
)paren
op_star
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|nodemgr_read_quadlet
c_func
(paren
id|host
comma
id|nodeid
comma
id|generation
comma
id|address
comma
op_amp
id|quad
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|length
op_assign
id|CONFIG_ROM_ROOT_LENGTH
c_func
(paren
id|quad
)paren
suffix:semicolon
id|address
op_add_assign
l_int|4
suffix:semicolon
id|size
op_assign
l_int|0
suffix:semicolon
id|total_size
op_assign
r_sizeof
(paren
r_struct
id|node_entry
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|length
OG
l_int|0
suffix:semicolon
id|length
op_decrement
comma
id|address
op_add_assign
l_int|4
)paren
(brace
r_if
c_cond
(paren
id|nodemgr_read_quadlet
c_func
(paren
id|host
comma
id|nodeid
comma
id|generation
comma
id|address
comma
op_amp
id|quad
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|code
op_assign
id|CONFIG_ROM_KEY
c_func
(paren
id|quad
)paren
suffix:semicolon
r_if
c_cond
(paren
id|code
op_eq
id|CONFIG_ROM_VENDOR_ID
op_logical_and
id|length
OG
l_int|0
)paren
(brace
multiline_comment|/* Check if there is a text descriptor leaf&n;&t;&t;&t;   immediately after this.  */
id|size
op_assign
id|nodemgr_size_text_leaf
c_func
(paren
id|host
comma
id|nodeid
comma
id|generation
comma
id|address
op_plus
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
l_int|0
)paren
(brace
id|address
op_add_assign
l_int|4
suffix:semicolon
id|length
op_decrement
suffix:semicolon
id|total_size
op_add_assign
(paren
id|size
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
id|quadlet_t
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|size
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
id|ne
op_assign
id|kmalloc
c_func
(paren
id|total_size
comma
id|SLAB_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ne
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|size
op_ne
l_int|0
)paren
(brace
id|ne-&gt;vendor_name
op_assign
(paren
r_const
r_char
op_star
)paren
op_amp
(paren
id|ne-&gt;quadlets
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|ne-&gt;quadlets
(braket
id|size
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ne-&gt;vendor_name
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|ne
suffix:semicolon
)brace
DECL|function|nodemgr_create_node
r_static
r_struct
id|node_entry
op_star
id|nodemgr_create_node
c_func
(paren
id|octlet_t
id|guid
comma
id|quadlet_t
id|busoptions
comma
r_struct
id|hpsb_host
op_star
id|host
comma
id|nodeid_t
id|nodeid
comma
r_int
r_int
id|generation
)paren
(brace
r_struct
id|node_entry
op_star
id|ne
suffix:semicolon
id|ne
op_assign
id|nodemgr_scan_root_directory
(paren
id|host
comma
id|nodeid
comma
id|generation
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ne
)paren
r_return
l_int|NULL
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ne-&gt;list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ne-&gt;unit_directories
)paren
suffix:semicolon
id|ne-&gt;host
op_assign
id|host
suffix:semicolon
id|ne-&gt;nodeid
op_assign
id|nodeid
suffix:semicolon
id|ne-&gt;guid
op_assign
id|guid
suffix:semicolon
id|ne-&gt;generation
op_assign
id|generation
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|ne-&gt;list
comma
op_amp
id|node_list
)paren
suffix:semicolon
id|nodemgr_process_config_rom
(paren
id|ne
comma
id|busoptions
)paren
suffix:semicolon
id|HPSB_DEBUG
c_func
(paren
l_string|&quot;%s added: Node[&quot;
id|NODE_BUS_FMT
l_string|&quot;]  GUID[%016Lx]  [%s]&quot;
comma
(paren
id|host-&gt;node_id
op_eq
id|nodeid
)paren
ques
c_cond
l_string|&quot;Host&quot;
suffix:colon
l_string|&quot;Device&quot;
comma
id|NODE_BUS_ARGS
c_func
(paren
id|nodeid
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|guid
comma
id|ne-&gt;vendor_name
ques
c_cond
suffix:colon
l_string|&quot;Unknown&quot;
)paren
suffix:semicolon
r_return
id|ne
suffix:semicolon
)brace
DECL|function|find_entry_by_guid
r_static
r_struct
id|node_entry
op_star
id|find_entry_by_guid
c_func
(paren
id|u64
id|guid
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|node_entry
op_star
id|ne
suffix:semicolon
id|list_for_each
c_func
(paren
id|lh
comma
op_amp
id|node_list
)paren
(brace
id|ne
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|node_entry
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ne-&gt;guid
op_eq
id|guid
)paren
r_return
id|ne
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|find_entry_by_nodeid
r_static
r_struct
id|node_entry
op_star
id|find_entry_by_nodeid
c_func
(paren
id|nodeid_t
id|nodeid
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|node_entry
op_star
id|ne
suffix:semicolon
id|list_for_each
c_func
(paren
id|lh
comma
op_amp
id|node_list
)paren
(brace
id|ne
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|node_entry
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ne-&gt;nodeid
op_eq
id|nodeid
)paren
r_return
id|ne
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|nodemgr_scan_unit_directory
r_static
r_struct
id|unit_directory
op_star
id|nodemgr_scan_unit_directory
(paren
r_struct
id|node_entry
op_star
id|ne
comma
id|octlet_t
id|address
)paren
(brace
r_struct
id|unit_directory
op_star
id|ud
suffix:semicolon
id|quadlet_t
id|quad
suffix:semicolon
id|u8
id|flags
comma
id|todo
suffix:semicolon
r_int
id|length
comma
id|size
comma
id|total_size
comma
id|count
suffix:semicolon
r_int
id|vendor_name_size
comma
id|model_name_size
suffix:semicolon
r_if
c_cond
(paren
id|nodemgr_read_quadlet
c_func
(paren
id|ne-&gt;host
comma
id|ne-&gt;nodeid
comma
id|ne-&gt;generation
comma
id|address
comma
op_amp
id|quad
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|length
op_assign
id|CONFIG_ROM_DIRECTORY_LENGTH
c_func
(paren
id|quad
)paren
suffix:semicolon
id|address
op_add_assign
l_int|4
suffix:semicolon
id|size
op_assign
l_int|0
suffix:semicolon
id|total_size
op_assign
r_sizeof
(paren
r_struct
id|unit_directory
)paren
suffix:semicolon
id|flags
op_assign
l_int|0
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
id|vendor_name_size
op_assign
l_int|0
suffix:semicolon
id|model_name_size
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|length
OG
l_int|0
suffix:semicolon
id|length
op_decrement
comma
id|address
op_add_assign
l_int|4
)paren
(brace
r_int
id|code
suffix:semicolon
id|quadlet_t
id|value
suffix:semicolon
r_if
c_cond
(paren
id|nodemgr_read_quadlet
c_func
(paren
id|ne-&gt;host
comma
id|ne-&gt;nodeid
comma
id|ne-&gt;generation
comma
id|address
comma
op_amp
id|quad
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|code
op_assign
id|CONFIG_ROM_KEY
c_func
(paren
id|quad
)paren
suffix:semicolon
id|value
op_assign
id|CONFIG_ROM_VALUE
c_func
(paren
id|quad
)paren
suffix:semicolon
id|todo
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|code
)paren
(brace
r_case
id|CONFIG_ROM_VENDOR_ID
suffix:colon
id|todo
op_assign
id|UNIT_DIRECTORY_VENDOR_TEXT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CONFIG_ROM_MODEL_ID
suffix:colon
id|todo
op_assign
id|UNIT_DIRECTORY_MODEL_TEXT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CONFIG_ROM_SPECIFIER_ID
suffix:colon
r_case
id|CONFIG_ROM_UNIT_SW_VERSION
suffix:colon
r_break
suffix:semicolon
r_case
id|CONFIG_ROM_DESCRIPTOR_LEAF
suffix:colon
r_case
id|CONFIG_ROM_DESCRIPTOR_DIRECTORY
suffix:colon
multiline_comment|/* TODO: read strings... icons? */
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Which types of quadlets do we want to&n;&t;&t;&t;   store?  Only count immediate values and&n;&t;&t;&t;   CSR offsets for now.  */
id|code
op_and_assign
id|CONFIG_ROM_KEY_TYPE_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|code
op_amp
l_int|0x80
)paren
op_eq
l_int|0
)paren
id|count
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|todo
op_logical_and
id|length
OG
l_int|0
)paren
(brace
multiline_comment|/* Check if there is a text descriptor leaf&n;&t;&t;&t;   immediately after this.  */
id|size
op_assign
id|nodemgr_size_text_leaf
c_func
(paren
id|ne-&gt;host
comma
id|ne-&gt;nodeid
comma
id|ne-&gt;generation
comma
id|address
op_plus
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|todo
op_eq
id|UNIT_DIRECTORY_VENDOR_TEXT
)paren
id|vendor_name_size
op_assign
id|size
suffix:semicolon
r_else
id|model_name_size
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
l_int|0
)paren
(brace
id|address
op_add_assign
l_int|4
suffix:semicolon
id|length
op_decrement
suffix:semicolon
id|flags
op_or_assign
id|todo
suffix:semicolon
id|total_size
op_add_assign
(paren
id|size
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
id|quadlet_t
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|size
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
id|total_size
op_add_assign
id|count
op_star
r_sizeof
(paren
id|quadlet_t
)paren
suffix:semicolon
id|ud
op_assign
id|kmalloc
(paren
id|total_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ud
op_ne
l_int|NULL
)paren
(brace
id|memset
(paren
id|ud
comma
l_int|0
comma
r_sizeof
op_star
id|ud
)paren
suffix:semicolon
id|ud-&gt;flags
op_assign
id|flags
suffix:semicolon
id|ud-&gt;count
op_assign
id|count
suffix:semicolon
id|ud-&gt;vendor_name_size
op_assign
id|vendor_name_size
suffix:semicolon
id|ud-&gt;model_name_size
op_assign
id|model_name_size
suffix:semicolon
multiline_comment|/* If there is no vendor name in the unit directory,&n;&t;&t;   use the one in the root directory.  */
id|ud-&gt;vendor_name
op_assign
id|ne-&gt;vendor_name
suffix:semicolon
)brace
r_return
id|ud
suffix:semicolon
)brace
multiline_comment|/* This implementation currently only scans the config rom and its&n; * immediate unit directories looking for software_id and&n; * software_version entries, in order to get driver autoloading working.&n; */
DECL|function|nodemgr_process_unit_directory
r_static
r_void
id|nodemgr_process_unit_directory
c_func
(paren
r_struct
id|node_entry
op_star
id|ne
comma
id|octlet_t
id|address
)paren
(brace
r_struct
id|unit_directory
op_star
id|ud
suffix:semicolon
id|quadlet_t
id|quad
suffix:semicolon
id|quadlet_t
op_star
id|infop
suffix:semicolon
r_int
id|length
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ud
op_assign
id|nodemgr_scan_unit_directory
c_func
(paren
id|ne
comma
id|address
)paren
)paren
)paren
r_goto
id|unit_directory_error
suffix:semicolon
id|ud-&gt;ne
op_assign
id|ne
suffix:semicolon
id|ud-&gt;address
op_assign
id|address
suffix:semicolon
r_if
c_cond
(paren
id|nodemgr_read_quadlet
c_func
(paren
id|ne-&gt;host
comma
id|ne-&gt;nodeid
comma
id|ne-&gt;generation
comma
id|address
comma
op_amp
id|quad
)paren
)paren
r_goto
id|unit_directory_error
suffix:semicolon
id|length
op_assign
id|CONFIG_ROM_DIRECTORY_LENGTH
c_func
(paren
id|quad
)paren
suffix:semicolon
id|address
op_add_assign
l_int|4
suffix:semicolon
id|infop
op_assign
(paren
id|quadlet_t
op_star
)paren
id|ud-&gt;quadlets
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|length
OG
l_int|0
suffix:semicolon
id|length
op_decrement
comma
id|address
op_add_assign
l_int|4
comma
id|infop
op_increment
)paren
(brace
r_int
id|code
suffix:semicolon
id|quadlet_t
id|value
suffix:semicolon
id|quadlet_t
op_star
id|quadp
suffix:semicolon
r_if
c_cond
(paren
id|nodemgr_read_quadlet
c_func
(paren
id|ne-&gt;host
comma
id|ne-&gt;nodeid
comma
id|ne-&gt;generation
comma
id|address
comma
op_amp
id|quad
)paren
)paren
r_goto
id|unit_directory_error
suffix:semicolon
id|code
op_assign
id|CONFIG_ROM_KEY
c_func
(paren
id|quad
)paren
suffix:semicolon
id|value
op_assign
id|CONFIG_ROM_VALUE
c_func
(paren
id|quad
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|code
)paren
(brace
r_case
id|CONFIG_ROM_VENDOR_ID
suffix:colon
id|ud-&gt;vendor_id
op_assign
id|value
suffix:semicolon
id|ud-&gt;flags
op_or_assign
id|UNIT_DIRECTORY_VENDOR_ID
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ud-&gt;flags
op_amp
id|UNIT_DIRECTORY_VENDOR_TEXT
)paren
op_ne
l_int|0
)paren
(brace
id|length
op_decrement
suffix:semicolon
id|address
op_add_assign
l_int|4
suffix:semicolon
id|quadp
op_assign
op_amp
(paren
id|ud-&gt;quadlets
(braket
id|ud-&gt;count
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nodemgr_read_text_leaf
c_func
(paren
id|ne
comma
id|address
comma
id|quadp
)paren
op_eq
l_int|0
op_logical_and
id|quadp
(braket
l_int|0
)braket
op_eq
l_int|0
op_logical_and
id|quadp
(braket
l_int|1
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/* We only support minimal&n;&t;&t;&t;&t;&t;   ASCII and English. */
id|quadp
(braket
id|ud-&gt;vendor_name_size
)braket
op_assign
l_int|0
suffix:semicolon
id|ud-&gt;vendor_name
op_assign
(paren
r_const
r_char
op_star
)paren
op_amp
(paren
id|quadp
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|CONFIG_ROM_MODEL_ID
suffix:colon
id|ud-&gt;model_id
op_assign
id|value
suffix:semicolon
id|ud-&gt;flags
op_or_assign
id|UNIT_DIRECTORY_MODEL_ID
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ud-&gt;flags
op_amp
id|UNIT_DIRECTORY_MODEL_TEXT
)paren
op_ne
l_int|0
)paren
(brace
id|length
op_decrement
suffix:semicolon
id|address
op_add_assign
l_int|4
suffix:semicolon
id|quadp
op_assign
op_amp
(paren
id|ud-&gt;quadlets
(braket
id|ud-&gt;count
op_plus
id|ud-&gt;vendor_name_size
op_plus
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nodemgr_read_text_leaf
c_func
(paren
id|ne
comma
id|address
comma
id|quadp
)paren
op_eq
l_int|0
op_logical_and
id|quadp
(braket
l_int|0
)braket
op_eq
l_int|0
op_logical_and
id|quadp
(braket
l_int|1
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/* We only support minimal&n;&t;&t;&t;&t;&t;   ASCII and English. */
id|quadp
(braket
id|ud-&gt;model_name_size
)braket
op_assign
l_int|0
suffix:semicolon
id|ud-&gt;model_name
op_assign
(paren
r_const
r_char
op_star
)paren
op_amp
(paren
id|quadp
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|CONFIG_ROM_SPECIFIER_ID
suffix:colon
id|ud-&gt;specifier_id
op_assign
id|value
suffix:semicolon
id|ud-&gt;flags
op_or_assign
id|UNIT_DIRECTORY_SPECIFIER_ID
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CONFIG_ROM_UNIT_SW_VERSION
suffix:colon
id|ud-&gt;version
op_assign
id|value
suffix:semicolon
id|ud-&gt;flags
op_or_assign
id|UNIT_DIRECTORY_VERSION
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CONFIG_ROM_DESCRIPTOR_LEAF
suffix:colon
r_case
id|CONFIG_ROM_DESCRIPTOR_DIRECTORY
suffix:colon
multiline_comment|/* TODO: read strings... icons? */
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Which types of quadlets do we want to&n;&t;&t;&t;   store?  Only count immediate values and&n;&t;&t;&t;   CSR offsets for now.  */
id|code
op_and_assign
id|CONFIG_ROM_KEY_TYPE_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|code
op_amp
l_int|0x80
)paren
op_eq
l_int|0
)paren
op_star
id|infop
op_assign
id|quad
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|list_add_tail
c_func
(paren
op_amp
id|ud-&gt;node_list
comma
op_amp
id|ne-&gt;unit_directories
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|ud-&gt;driver_list
comma
op_amp
id|unit_directory_list
)paren
suffix:semicolon
r_return
suffix:semicolon
id|unit_directory_error
suffix:colon
r_if
c_cond
(paren
id|ud
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|ud
)paren
suffix:semicolon
)brace
DECL|function|dump_directories
r_static
r_void
id|dump_directories
(paren
r_struct
id|node_entry
op_star
id|ne
)paren
(brace
macro_line|#ifdef CONFIG_IEEE1394_VERBOSEDEBUG
r_struct
id|list_head
op_star
id|l
suffix:semicolon
id|HPSB_DEBUG
c_func
(paren
l_string|&quot;vendor_id=0x%06x [%s], capabilities=0x%06x&quot;
comma
id|ne-&gt;vendor_id
comma
id|ne-&gt;vendor_name
ques
c_cond
suffix:colon
l_string|&quot;Unknown&quot;
comma
id|ne-&gt;capabilities
)paren
suffix:semicolon
id|list_for_each
(paren
id|l
comma
op_amp
id|ne-&gt;unit_directories
)paren
(brace
r_struct
id|unit_directory
op_star
id|ud
op_assign
id|list_entry
(paren
id|l
comma
r_struct
id|unit_directory
comma
id|node_list
)paren
suffix:semicolon
id|HPSB_DEBUG
c_func
(paren
l_string|&quot;unit directory:&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;flags
op_amp
id|UNIT_DIRECTORY_VENDOR_ID
)paren
id|HPSB_DEBUG
c_func
(paren
l_string|&quot;  vendor_id=0x%06x [%s]&quot;
comma
id|ud-&gt;vendor_id
comma
id|ud-&gt;vendor_name
ques
c_cond
suffix:colon
l_string|&quot;Unknown&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;flags
op_amp
id|UNIT_DIRECTORY_MODEL_ID
)paren
id|HPSB_DEBUG
c_func
(paren
l_string|&quot;  model_id=0x%06x [%s]&quot;
comma
id|ud-&gt;model_id
comma
id|ud-&gt;model_name
ques
c_cond
suffix:colon
l_string|&quot;Unknown&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;flags
op_amp
id|UNIT_DIRECTORY_SPECIFIER_ID
)paren
id|HPSB_DEBUG
c_func
(paren
l_string|&quot;  sw_specifier_id=0x%06x &quot;
comma
id|ud-&gt;specifier_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;flags
op_amp
id|UNIT_DIRECTORY_VERSION
)paren
id|HPSB_DEBUG
c_func
(paren
l_string|&quot;  sw_version=0x%06x &quot;
comma
id|ud-&gt;version
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
suffix:semicolon
)brace
DECL|function|nodemgr_process_root_directory
r_static
r_void
id|nodemgr_process_root_directory
c_func
(paren
r_struct
id|node_entry
op_star
id|ne
)paren
(brace
id|octlet_t
id|address
suffix:semicolon
id|quadlet_t
id|quad
suffix:semicolon
r_int
id|length
suffix:semicolon
id|address
op_assign
id|CSR_REGISTER_BASE
op_plus
id|CSR_CONFIG_ROM
suffix:semicolon
r_if
c_cond
(paren
id|nodemgr_read_quadlet
c_func
(paren
id|ne-&gt;host
comma
id|ne-&gt;nodeid
comma
id|ne-&gt;generation
comma
id|address
comma
op_amp
id|quad
)paren
)paren
r_return
suffix:semicolon
id|address
op_add_assign
l_int|4
op_plus
id|CONFIG_ROM_BUS_INFO_LENGTH
c_func
(paren
id|quad
)paren
op_star
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|nodemgr_read_quadlet
c_func
(paren
id|ne-&gt;host
comma
id|ne-&gt;nodeid
comma
id|ne-&gt;generation
comma
id|address
comma
op_amp
id|quad
)paren
)paren
r_return
suffix:semicolon
id|length
op_assign
id|CONFIG_ROM_ROOT_LENGTH
c_func
(paren
id|quad
)paren
suffix:semicolon
id|address
op_add_assign
l_int|4
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|length
OG
l_int|0
suffix:semicolon
id|length
op_decrement
comma
id|address
op_add_assign
l_int|4
)paren
(brace
r_int
id|code
comma
id|value
suffix:semicolon
r_if
c_cond
(paren
id|nodemgr_read_quadlet
c_func
(paren
id|ne-&gt;host
comma
id|ne-&gt;nodeid
comma
id|ne-&gt;generation
comma
id|address
comma
op_amp
id|quad
)paren
)paren
r_return
suffix:semicolon
id|code
op_assign
id|CONFIG_ROM_KEY
c_func
(paren
id|quad
)paren
suffix:semicolon
id|value
op_assign
id|CONFIG_ROM_VALUE
c_func
(paren
id|quad
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|code
)paren
(brace
r_case
id|CONFIG_ROM_VENDOR_ID
suffix:colon
id|ne-&gt;vendor_id
op_assign
id|value
suffix:semicolon
multiline_comment|/* Now check if there is a vendor name text&n;&t;&t;&t;   string.  */
r_if
c_cond
(paren
id|ne-&gt;vendor_name
op_ne
l_int|NULL
)paren
(brace
id|length
op_decrement
suffix:semicolon
id|address
op_add_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|nodemgr_read_text_leaf
c_func
(paren
id|ne
comma
id|address
comma
id|ne-&gt;quadlets
)paren
op_ne
l_int|0
op_logical_or
id|ne-&gt;quadlets
(braket
l_int|0
)braket
op_ne
l_int|0
op_logical_or
id|ne-&gt;quadlets
(braket
l_int|1
)braket
op_ne
l_int|0
)paren
multiline_comment|/* We only support minimal&n;&t;&t;&t;&t;&t;   ASCII and English. */
id|ne-&gt;vendor_name
op_assign
l_int|NULL
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CONFIG_ROM_NODE_CAPABILITES
suffix:colon
id|ne-&gt;capabilities
op_assign
id|value
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CONFIG_ROM_UNIT_DIRECTORY
suffix:colon
id|nodemgr_process_unit_directory
c_func
(paren
id|ne
comma
id|address
op_plus
id|value
op_star
l_int|4
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CONFIG_ROM_DESCRIPTOR_LEAF
suffix:colon
r_case
id|CONFIG_ROM_DESCRIPTOR_DIRECTORY
suffix:colon
multiline_comment|/* TODO: read strings... icons? */
r_break
suffix:semicolon
)brace
)brace
id|dump_directories
c_func
(paren
id|ne
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_HOTPLUG
DECL|function|nodemgr_call_policy
r_static
r_void
id|nodemgr_call_policy
c_func
(paren
r_char
op_star
id|verb
comma
r_struct
id|unit_directory
op_star
id|ud
)paren
(brace
r_char
op_star
id|argv
(braket
l_int|3
)braket
comma
op_star
op_star
id|envp
comma
op_star
id|buf
comma
op_star
id|scratch
suffix:semicolon
r_int
id|i
op_assign
l_int|0
comma
id|value
suffix:semicolon
multiline_comment|/* User requested to disable hotplug when module was loaded. */
r_if
c_cond
(paren
id|nodemgr_disable_hotplug
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hotplug_path
(braket
l_int|0
)braket
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|current-&gt;fs-&gt;root
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|envp
op_assign
(paren
r_char
op_star
op_star
)paren
id|kmalloc
c_func
(paren
l_int|20
op_star
r_sizeof
(paren
r_char
op_star
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|HPSB_DEBUG
(paren
l_string|&quot;ENOMEM&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|buf
op_assign
id|kmalloc
c_func
(paren
l_int|256
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|kfree
c_func
(paren
id|envp
)paren
suffix:semicolon
id|HPSB_DEBUG
c_func
(paren
l_string|&quot;ENOMEM2&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* only one standardized param to hotplug command: type */
id|argv
(braket
l_int|0
)braket
op_assign
id|hotplug_path
suffix:semicolon
id|argv
(braket
l_int|1
)braket
op_assign
l_string|&quot;ieee1394&quot;
suffix:semicolon
id|argv
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* minimal command environment */
id|envp
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;HOME=/&quot;
suffix:semicolon
id|envp
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;PATH=/sbin:/bin:/usr/sbin:/usr/bin&quot;
suffix:semicolon
macro_line|#ifdef CONFIG_IEEE1394_VERBOSEDEBUG
multiline_comment|/* hint that policy agent should enter no-stdout debug mode */
id|envp
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;DEBUG=kernel&quot;
suffix:semicolon
macro_line|#endif
multiline_comment|/* extensible set of named bus-specific parameters,&n;&t; * supporting multiple driver selection algorithms.&n;&t; */
id|scratch
op_assign
id|buf
suffix:semicolon
id|envp
(braket
id|i
op_increment
)braket
op_assign
id|scratch
suffix:semicolon
id|scratch
op_add_assign
id|sprintf
c_func
(paren
id|scratch
comma
l_string|&quot;ACTION=%s&quot;
comma
id|verb
)paren
op_plus
l_int|1
suffix:semicolon
id|envp
(braket
id|i
op_increment
)braket
op_assign
id|scratch
suffix:semicolon
id|scratch
op_add_assign
id|sprintf
c_func
(paren
id|scratch
comma
l_string|&quot;VENDOR_ID=%06x&quot;
comma
id|ud-&gt;ne-&gt;vendor_id
)paren
op_plus
l_int|1
suffix:semicolon
id|envp
(braket
id|i
op_increment
)braket
op_assign
id|scratch
suffix:semicolon
id|scratch
op_add_assign
id|sprintf
c_func
(paren
id|scratch
comma
l_string|&quot;GUID=%016Lx&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ud-&gt;ne-&gt;guid
)paren
op_plus
l_int|1
suffix:semicolon
id|envp
(braket
id|i
op_increment
)braket
op_assign
id|scratch
suffix:semicolon
id|scratch
op_add_assign
id|sprintf
c_func
(paren
id|scratch
comma
l_string|&quot;SPECIFIER_ID=%06x&quot;
comma
id|ud-&gt;specifier_id
)paren
op_plus
l_int|1
suffix:semicolon
id|envp
(braket
id|i
op_increment
)braket
op_assign
id|scratch
suffix:semicolon
id|scratch
op_add_assign
id|sprintf
c_func
(paren
id|scratch
comma
l_string|&quot;VERSION=%06x&quot;
comma
id|ud-&gt;version
)paren
op_plus
l_int|1
suffix:semicolon
id|envp
(braket
id|i
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* NOTE: user mode daemons can call the agents too */
macro_line|#ifdef CONFIG_IEEE1394_VERBOSEDEBUG
id|HPSB_DEBUG
c_func
(paren
l_string|&quot;NodeMgr: %s %s %016Lx&quot;
comma
id|argv
(braket
l_int|0
)braket
comma
id|verb
comma
(paren
r_int
r_int
r_int
)paren
id|ud-&gt;ne-&gt;guid
)paren
suffix:semicolon
macro_line|#endif
id|value
op_assign
id|call_usermodehelper
c_func
(paren
id|argv
(braket
l_int|0
)braket
comma
id|argv
comma
id|envp
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|envp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ne
l_int|0
)paren
id|HPSB_DEBUG
c_func
(paren
l_string|&quot;NodeMgr: hotplug policy returned %d&quot;
comma
id|value
)paren
suffix:semicolon
)brace
macro_line|#else
r_static
r_inline
r_void
DECL|function|nodemgr_call_policy
id|nodemgr_call_policy
c_func
(paren
r_char
op_star
id|verb
comma
r_struct
id|unit_directory
op_star
id|ud
)paren
(brace
macro_line|#ifdef CONFIG_IEEE1394_VERBOSEDEBUG
id|HPSB_DEBUG
c_func
(paren
l_string|&quot;NodeMgr: nodemgr_call_policy(): hotplug not enabled&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_HOTPLUG */
DECL|function|nodemgr_claim_unit_directory
r_static
r_void
id|nodemgr_claim_unit_directory
c_func
(paren
r_struct
id|unit_directory
op_star
id|ud
comma
r_struct
id|hpsb_protocol_driver
op_star
id|driver
)paren
(brace
id|ud-&gt;driver
op_assign
id|driver
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|ud-&gt;driver_list
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|ud-&gt;driver_list
comma
op_amp
id|driver-&gt;unit_directories
)paren
suffix:semicolon
)brace
DECL|function|nodemgr_release_unit_directory
r_static
r_void
id|nodemgr_release_unit_directory
c_func
(paren
r_struct
id|unit_directory
op_star
id|ud
)paren
(brace
id|ud-&gt;driver
op_assign
l_int|NULL
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|ud-&gt;driver_list
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|ud-&gt;driver_list
comma
op_amp
id|unit_directory_list
)paren
suffix:semicolon
)brace
DECL|function|hpsb_release_unit_directory
r_void
id|hpsb_release_unit_directory
c_func
(paren
r_struct
id|unit_directory
op_star
id|ud
)paren
(brace
id|down
c_func
(paren
op_amp
id|nodemgr_serialize
)paren
suffix:semicolon
id|nodemgr_release_unit_directory
c_func
(paren
id|ud
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|nodemgr_serialize
)paren
suffix:semicolon
)brace
DECL|function|nodemgr_free_unit_directories
r_static
r_void
id|nodemgr_free_unit_directories
c_func
(paren
r_struct
id|node_entry
op_star
id|ne
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|unit_directory
op_star
id|ud
suffix:semicolon
id|lh
op_assign
id|ne-&gt;unit_directories.next
suffix:semicolon
r_while
c_loop
(paren
id|lh
op_ne
op_amp
id|ne-&gt;unit_directories
)paren
(brace
id|ud
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|unit_directory
comma
id|node_list
)paren
suffix:semicolon
id|lh
op_assign
id|lh-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;driver
op_logical_and
id|ud-&gt;driver-&gt;disconnect
)paren
id|ud-&gt;driver
op_member_access_from_pointer
id|disconnect
c_func
(paren
id|ud
)paren
suffix:semicolon
id|nodemgr_release_unit_directory
c_func
(paren
id|ud
)paren
suffix:semicolon
id|nodemgr_call_policy
c_func
(paren
l_string|&quot;remove&quot;
comma
id|ud
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|ud-&gt;driver_list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ud
)paren
suffix:semicolon
)brace
)brace
r_static
r_struct
id|ieee1394_device_id
op_star
DECL|function|nodemgr_match_driver
id|nodemgr_match_driver
c_func
(paren
r_struct
id|hpsb_protocol_driver
op_star
id|driver
comma
r_struct
id|unit_directory
op_star
id|ud
)paren
(brace
r_struct
id|ieee1394_device_id
op_star
id|id
suffix:semicolon
r_for
c_loop
(paren
id|id
op_assign
id|driver-&gt;id_table
suffix:semicolon
id|id-&gt;match_flags
op_ne
l_int|0
suffix:semicolon
id|id
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|IEEE1394_MATCH_VENDOR_ID
)paren
op_logical_and
id|id-&gt;vendor_id
op_ne
id|ud-&gt;vendor_id
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|IEEE1394_MATCH_MODEL_ID
)paren
op_logical_and
id|id-&gt;model_id
op_ne
id|ud-&gt;model_id
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|IEEE1394_MATCH_SPECIFIER_ID
)paren
op_logical_and
id|id-&gt;specifier_id
op_ne
id|ud-&gt;specifier_id
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|IEEE1394_MATCH_VERSION
)paren
op_logical_and
id|id-&gt;version
op_ne
id|ud-&gt;version
)paren
r_continue
suffix:semicolon
r_return
id|id
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_struct
id|hpsb_protocol_driver
op_star
DECL|function|nodemgr_find_driver
id|nodemgr_find_driver
c_func
(paren
r_struct
id|unit_directory
op_star
id|ud
)paren
(brace
r_struct
id|list_head
op_star
id|l
suffix:semicolon
r_struct
id|hpsb_protocol_driver
op_star
id|match
comma
op_star
id|driver
suffix:semicolon
r_struct
id|ieee1394_device_id
op_star
id|device_id
suffix:semicolon
id|match
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|driver_list
)paren
(brace
id|driver
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|hpsb_protocol_driver
comma
id|list
)paren
suffix:semicolon
id|device_id
op_assign
id|nodemgr_match_driver
c_func
(paren
id|driver
comma
id|ud
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device_id
op_ne
l_int|NULL
)paren
(brace
id|match
op_assign
id|driver
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|match
suffix:semicolon
)brace
DECL|function|nodemgr_bind_drivers
r_static
r_void
id|nodemgr_bind_drivers
(paren
r_struct
id|node_entry
op_star
id|ne
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|hpsb_protocol_driver
op_star
id|driver
suffix:semicolon
r_struct
id|unit_directory
op_star
id|ud
suffix:semicolon
id|list_for_each
c_func
(paren
id|lh
comma
op_amp
id|ne-&gt;unit_directories
)paren
(brace
id|ud
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|unit_directory
comma
id|node_list
)paren
suffix:semicolon
id|driver
op_assign
id|nodemgr_find_driver
c_func
(paren
id|ud
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver
op_ne
l_int|NULL
op_logical_and
id|driver
op_member_access_from_pointer
id|probe
c_func
(paren
id|ud
)paren
op_eq
l_int|0
)paren
id|nodemgr_claim_unit_directory
c_func
(paren
id|ud
comma
id|driver
)paren
suffix:semicolon
id|nodemgr_call_policy
c_func
(paren
l_string|&quot;add&quot;
comma
id|ud
)paren
suffix:semicolon
)brace
)brace
DECL|function|hpsb_register_protocol
r_int
id|hpsb_register_protocol
c_func
(paren
r_struct
id|hpsb_protocol_driver
op_star
id|driver
)paren
(brace
r_struct
id|unit_directory
op_star
id|ud
suffix:semicolon
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|nodemgr_serialize
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|driver-&gt;list
comma
op_amp
id|driver_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|driver-&gt;unit_directories
)paren
suffix:semicolon
id|lh
op_assign
id|unit_directory_list.next
suffix:semicolon
r_while
c_loop
(paren
id|lh
op_ne
op_amp
id|unit_directory_list
)paren
(brace
id|ud
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|unit_directory
comma
id|driver_list
)paren
suffix:semicolon
id|lh
op_assign
id|lh-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|nodemgr_match_driver
c_func
(paren
id|driver
comma
id|ud
)paren
op_logical_and
id|driver
op_member_access_from_pointer
id|probe
c_func
(paren
id|ud
)paren
op_eq
l_int|0
)paren
id|nodemgr_claim_unit_directory
c_func
(paren
id|ud
comma
id|driver
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|nodemgr_serialize
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Right now registration always succeeds, but maybe we should&n;&t; * detect clashes in protocols handled by other drivers.&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hpsb_unregister_protocol
r_void
id|hpsb_unregister_protocol
c_func
(paren
r_struct
id|hpsb_protocol_driver
op_star
id|driver
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|unit_directory
op_star
id|ud
suffix:semicolon
id|down
c_func
(paren
op_amp
id|nodemgr_serialize
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|driver-&gt;list
)paren
suffix:semicolon
id|lh
op_assign
id|driver-&gt;unit_directories.next
suffix:semicolon
r_while
c_loop
(paren
id|lh
op_ne
op_amp
id|driver-&gt;unit_directories
)paren
(brace
id|ud
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|unit_directory
comma
id|driver_list
)paren
suffix:semicolon
id|lh
op_assign
id|lh-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;driver
op_logical_and
id|ud-&gt;driver-&gt;disconnect
)paren
id|ud-&gt;driver
op_member_access_from_pointer
id|disconnect
c_func
(paren
id|ud
)paren
suffix:semicolon
id|nodemgr_release_unit_directory
c_func
(paren
id|ud
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|nodemgr_serialize
)paren
suffix:semicolon
)brace
DECL|function|nodemgr_process_config_rom
r_static
r_void
id|nodemgr_process_config_rom
c_func
(paren
r_struct
id|node_entry
op_star
id|ne
comma
id|quadlet_t
id|busoptions
)paren
(brace
id|ne-&gt;busopt.irmc
op_assign
(paren
id|busoptions
op_rshift
l_int|31
)paren
op_amp
l_int|1
suffix:semicolon
id|ne-&gt;busopt.cmc
op_assign
(paren
id|busoptions
op_rshift
l_int|30
)paren
op_amp
l_int|1
suffix:semicolon
id|ne-&gt;busopt.isc
op_assign
(paren
id|busoptions
op_rshift
l_int|29
)paren
op_amp
l_int|1
suffix:semicolon
id|ne-&gt;busopt.bmc
op_assign
(paren
id|busoptions
op_rshift
l_int|28
)paren
op_amp
l_int|1
suffix:semicolon
id|ne-&gt;busopt.pmc
op_assign
(paren
id|busoptions
op_rshift
l_int|27
)paren
op_amp
l_int|1
suffix:semicolon
id|ne-&gt;busopt.cyc_clk_acc
op_assign
(paren
id|busoptions
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|ne-&gt;busopt.max_rec
op_assign
l_int|1
op_lshift
(paren
(paren
(paren
id|busoptions
op_rshift
l_int|12
)paren
op_amp
l_int|0xf
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|ne-&gt;busopt.generation
op_assign
(paren
id|busoptions
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
suffix:semicolon
id|ne-&gt;busopt.lnkspd
op_assign
id|busoptions
op_amp
l_int|0x7
suffix:semicolon
macro_line|#ifdef CONFIG_IEEE1394_VERBOSEDEBUG
id|HPSB_DEBUG
c_func
(paren
l_string|&quot;NodeMgr: raw=0x%08x irmc=%d cmc=%d isc=%d bmc=%d pmc=%d &quot;
l_string|&quot;cyc_clk_acc=%d max_rec=%d gen=%d lspd=%d&quot;
comma
id|busoptions
comma
id|ne-&gt;busopt.irmc
comma
id|ne-&gt;busopt.cmc
comma
id|ne-&gt;busopt.isc
comma
id|ne-&gt;busopt.bmc
comma
id|ne-&gt;busopt.pmc
comma
id|ne-&gt;busopt.cyc_clk_acc
comma
id|ne-&gt;busopt.max_rec
comma
id|ne-&gt;busopt.generation
comma
id|ne-&gt;busopt.lnkspd
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * When the config rom changes we disconnect all drivers and&n;&t; * free the cached unit directories and reread the whole&n;&t; * thing.  If this was a new device, the call to&n;&t; * nodemgr_disconnect_drivers is a no-op and all is well.&n;&t; */
id|nodemgr_free_unit_directories
c_func
(paren
id|ne
)paren
suffix:semicolon
id|nodemgr_process_root_directory
c_func
(paren
id|ne
)paren
suffix:semicolon
id|nodemgr_bind_drivers
c_func
(paren
id|ne
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function updates nodes that were present on the bus before the&n; * reset and still are after the reset.  The nodeid and the config rom&n; * may have changed, and the drivers managing this device must be&n; * informed that this device just went through a bus reset, to allow&n; * the to take whatever actions required.&n; */
DECL|function|nodemgr_update_node
r_static
r_void
id|nodemgr_update_node
c_func
(paren
r_struct
id|node_entry
op_star
id|ne
comma
id|quadlet_t
id|busoptions
comma
r_struct
id|hpsb_host
op_star
id|host
comma
id|nodeid_t
id|nodeid
comma
r_int
r_int
id|generation
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|unit_directory
op_star
id|ud
suffix:semicolon
r_if
c_cond
(paren
id|ne-&gt;nodeid
op_ne
id|nodeid
)paren
(brace
id|HPSB_DEBUG
c_func
(paren
l_string|&quot;Node &quot;
id|NODE_BUS_FMT
l_string|&quot; changed to &quot;
id|NODE_BUS_FMT
comma
id|NODE_BUS_ARGS
c_func
(paren
id|ne-&gt;nodeid
)paren
comma
id|NODE_BUS_ARGS
c_func
(paren
id|nodeid
)paren
)paren
suffix:semicolon
id|ne-&gt;nodeid
op_assign
id|nodeid
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ne-&gt;busopt.generation
op_ne
(paren
(paren
id|busoptions
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
)paren
)paren
id|nodemgr_process_config_rom
(paren
id|ne
comma
id|busoptions
)paren
suffix:semicolon
multiline_comment|/* Since that&squot;s done, we can declare this record current */
id|ne-&gt;generation
op_assign
id|generation
suffix:semicolon
id|list_for_each
(paren
id|lh
comma
op_amp
id|ne-&gt;unit_directories
)paren
(brace
id|ud
op_assign
id|list_entry
(paren
id|lh
comma
r_struct
id|unit_directory
comma
id|node_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;driver
op_ne
l_int|NULL
op_logical_and
id|ud-&gt;driver-&gt;update
op_ne
l_int|NULL
)paren
id|ud-&gt;driver
op_member_access_from_pointer
id|update
c_func
(paren
id|ud
)paren
suffix:semicolon
)brace
)brace
DECL|function|read_businfo_block
r_static
r_int
id|read_businfo_block
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
comma
id|nodeid_t
id|nodeid
comma
r_int
r_int
id|generation
comma
id|quadlet_t
op_star
id|buffer
comma
r_int
id|buffer_length
)paren
(brace
id|octlet_t
id|addr
op_assign
id|CSR_REGISTER_BASE
op_plus
id|CSR_CONFIG_ROM
suffix:semicolon
r_int
id|header_size
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* IEEE P1212 says that devices should support 64byte block&n;&t; * reads, aligned on 64byte boundaries. That doesn&squot;t seem to&n;&t; * work though, and we are forced to doing quadlet sized&n;&t; * reads.  */
macro_line|#ifdef CONFIG_IEEE1394_VERBOSEDEBUG
id|HPSB_INFO
c_func
(paren
l_string|&quot;Initiating ConfigROM request for node &quot;
id|NODE_BUS_FMT
comma
id|NODE_BUS_ARGS
c_func
(paren
id|nodeid
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t; * Must retry a few times if config rom read returns zero (how long?). Will&n;&t; * not normally occur, but we should do the right thing. For example, with&n;&t; * some sbp2 devices, the bridge chipset cannot return valid config rom reads&n;&t; * immediately after power-on, since they need to detect the type of &n;&t; * device attached (disk or CD-ROM).&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|nodemgr_read_quadlet
c_func
(paren
id|host
comma
id|nodeid
comma
id|generation
comma
id|addr
comma
op_amp
id|buffer
(braket
l_int|0
)braket
)paren
OL
l_int|0
)paren
(brace
id|HPSB_ERR
c_func
(paren
l_string|&quot;ConfigROM quadlet transaction error for node &quot;
id|NODE_BUS_FMT
comma
id|NODE_BUS_ARGS
c_func
(paren
id|nodeid
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer
(braket
l_int|0
)braket
)paren
r_break
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|schedule_timeout
(paren
id|HZ
op_div
l_int|4
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|header_size
op_assign
id|buffer
(braket
l_int|0
)braket
op_rshift
l_int|24
suffix:semicolon
id|addr
op_add_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|header_size
OL
l_int|4
)paren
(brace
id|HPSB_INFO
c_func
(paren
l_string|&quot;Node &quot;
id|NODE_BUS_FMT
l_string|&quot; has non-standard ROM &quot;
l_string|&quot;format (%d quads), cannot parse&quot;
comma
id|NODE_BUS_ARGS
c_func
(paren
id|nodeid
)paren
comma
id|header_size
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|buffer_length
suffix:semicolon
id|i
op_increment
comma
id|addr
op_add_assign
l_int|4
)paren
(brace
r_if
c_cond
(paren
id|nodemgr_read_quadlet
c_func
(paren
id|host
comma
id|nodeid
comma
id|generation
comma
id|addr
comma
op_amp
id|buffer
(braket
id|i
)braket
)paren
OL
l_int|0
)paren
(brace
id|HPSB_ERR
c_func
(paren
l_string|&quot;ConfigROM quadlet transaction &quot;
l_string|&quot;error for node &quot;
id|NODE_BUS_FMT
comma
id|NODE_BUS_ARGS
c_func
(paren
id|nodeid
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|nodemgr_remove_node
r_static
r_void
id|nodemgr_remove_node
c_func
(paren
r_struct
id|node_entry
op_star
id|ne
)paren
(brace
id|HPSB_DEBUG
c_func
(paren
l_string|&quot;%s removed: Node[&quot;
id|NODE_BUS_FMT
l_string|&quot;]  GUID[%016Lx]  [%s]&quot;
comma
(paren
id|ne-&gt;host-&gt;node_id
op_eq
id|ne-&gt;nodeid
)paren
ques
c_cond
l_string|&quot;Host&quot;
suffix:colon
l_string|&quot;Device&quot;
comma
id|NODE_BUS_ARGS
c_func
(paren
id|ne-&gt;nodeid
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|ne-&gt;guid
comma
id|ne-&gt;vendor_name
ques
c_cond
suffix:colon
l_string|&quot;Unknown&quot;
)paren
suffix:semicolon
id|nodemgr_free_unit_directories
c_func
(paren
id|ne
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|ne-&gt;list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ne
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* This is where we probe the nodes for their information and provided&n; * features.  */
DECL|function|nodemgr_node_probe_one
r_static
r_void
id|nodemgr_node_probe_one
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
comma
id|nodeid_t
id|nodeid
comma
r_int
id|generation
)paren
(brace
r_struct
id|node_entry
op_star
id|ne
suffix:semicolon
id|quadlet_t
id|buffer
(braket
l_int|5
)braket
suffix:semicolon
id|octlet_t
id|guid
suffix:semicolon
multiline_comment|/* We need to detect when the ConfigROM&squot;s generation has changed,&n;&t; * so we only update the node&squot;s info when it needs to be.  */
r_if
c_cond
(paren
id|read_businfo_block
(paren
id|host
comma
id|nodeid
comma
id|generation
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
op_rshift
l_int|2
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|buffer
(braket
l_int|1
)braket
op_ne
id|IEEE1394_BUSID_MAGIC
)paren
(brace
multiline_comment|/* This isn&squot;t a 1394 device, but we let it slide. There&n;&t;&t; * was a report of a device with broken firmware which&n;&t;&t; * reported &squot;2394&squot; instead of &squot;1394&squot;, which is obviously a&n;&t;&t; * mistake. One would hope that a non-1394 device never&n;&t;&t; * gets connected to Firewire bus. If someone does, we&n;&t;&t; * shouldn&squot;t be held responsible, so we&squot;ll allow it with a&n;&t;&t; * warning.  */
id|HPSB_WARN
c_func
(paren
l_string|&quot;Node &quot;
id|NODE_BUS_FMT
l_string|&quot; has invalid busID magic [0x%08x]&quot;
comma
id|NODE_BUS_ARGS
c_func
(paren
id|nodeid
)paren
comma
id|buffer
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|guid
op_assign
(paren
(paren
id|u64
)paren
id|buffer
(braket
l_int|3
)braket
op_lshift
l_int|32
)paren
op_or
id|buffer
(braket
l_int|4
)braket
suffix:semicolon
id|ne
op_assign
id|find_entry_by_guid
c_func
(paren
id|guid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ne
)paren
id|nodemgr_create_node
c_func
(paren
id|guid
comma
id|buffer
(braket
l_int|2
)braket
comma
id|host
comma
id|nodeid
comma
id|generation
)paren
suffix:semicolon
r_else
id|nodemgr_update_node
c_func
(paren
id|ne
comma
id|buffer
(braket
l_int|2
)braket
comma
id|host
comma
id|nodeid
comma
id|generation
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|nodemgr_node_probe_cleanup
r_static
r_void
id|nodemgr_node_probe_cleanup
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
comma
r_int
r_int
id|generation
)paren
(brace
r_struct
id|list_head
op_star
id|lh
comma
op_star
id|next
suffix:semicolon
r_struct
id|node_entry
op_star
id|ne
suffix:semicolon
multiline_comment|/* Now check to see if we have any nodes that aren&squot;t referenced&n;&t; * any longer.  */
id|list_for_each_safe
c_func
(paren
id|lh
comma
id|next
comma
op_amp
id|node_list
)paren
(brace
id|ne
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|node_entry
comma
id|list
)paren
suffix:semicolon
multiline_comment|/* Only checking this host */
r_if
c_cond
(paren
id|ne-&gt;host
op_ne
id|host
)paren
r_continue
suffix:semicolon
multiline_comment|/* If the generation didn&squot;t get updated, then either the&n;&t;&t; * node was removed, or it failed the above probe. Either&n;&t;&t; * way, we remove references to it, since they are&n;&t;&t; * invalid.  */
r_if
c_cond
(paren
id|ne-&gt;generation
op_ne
id|generation
)paren
id|nodemgr_remove_node
c_func
(paren
id|ne
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|nodemgr_node_probe
r_static
r_void
id|nodemgr_node_probe
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
(brace
r_int
id|count
suffix:semicolon
r_struct
id|selfid
op_star
id|sid
op_assign
(paren
r_struct
id|selfid
op_star
)paren
id|host-&gt;topology_map
suffix:semicolon
id|nodeid_t
id|nodeid
op_assign
id|LOCAL_BUS
suffix:semicolon
r_int
r_int
id|generation
suffix:semicolon
multiline_comment|/* Pause for 1/4 second, to make sure things settle down. If&n;&t; * schedule_timeout returns non-zero, it means we caught a signal&n;&t; * and need to return. */
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|schedule_timeout
(paren
id|HZ
op_div
l_int|4
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Now get the generation in which the node ID&squot;s we collect&n;&t; * are valid.  During the bus scan we will use this generation&n;&t; * for the read transactions, so that if another reset occurs&n;&t; * during the scan the transactions will fail instead of&n;&t; * returning bogus data. */
id|generation
op_assign
id|get_hpsb_generation
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/* Scan each node on the bus */
r_for
c_loop
(paren
id|count
op_assign
id|host-&gt;selfid_count
suffix:semicolon
id|count
suffix:semicolon
id|count
op_decrement
comma
id|sid
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sid-&gt;extended
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sid-&gt;link_active
)paren
(brace
id|nodeid
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|nodemgr_node_probe_one
c_func
(paren
id|host
comma
id|nodeid
op_increment
comma
id|generation
)paren
suffix:semicolon
)brace
multiline_comment|/* If we had a bus reset while we were scanning the bus, it is&n;&t; * possible that we did not probe all nodes.  In that case, we&n;&t; * skip the clean up for now, since we could remove nodes that&n;&t; * were still on the bus.  The bus reset increased&n;&t; * hi-&gt;reset_sem, so there&squot;s a bus scan pending which will do&n;&t; * the clean up eventually. */
r_if
c_cond
(paren
id|generation
op_eq
id|get_hpsb_generation
c_func
(paren
id|host
)paren
)paren
id|nodemgr_node_probe_cleanup
c_func
(paren
id|host
comma
id|generation
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|nodemgr_host_thread
r_static
r_int
id|nodemgr_host_thread
c_func
(paren
r_void
op_star
id|__hi
)paren
(brace
r_struct
id|host_info
op_star
id|hi
op_assign
(paren
r_struct
id|host_info
op_star
)paren
id|__hi
suffix:semicolon
multiline_comment|/* No userlevel access needed */
id|daemonize
c_func
(paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;knodemgrd&quot;
)paren
suffix:semicolon
multiline_comment|/* Sit and wait for a signal to probe the nodes on the bus. This&n;&t; * happens when we get a bus reset. */
r_while
c_loop
(paren
op_logical_neg
id|down_interruptible
c_func
(paren
op_amp
id|hi-&gt;reset_sem
)paren
op_logical_and
op_logical_neg
id|down_interruptible
c_func
(paren
op_amp
id|nodemgr_serialize
)paren
)paren
(brace
id|nodemgr_node_probe
c_func
(paren
id|hi-&gt;host
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|nodemgr_serialize
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_IEEE1394_VERBOSEDEBUG
id|HPSB_DEBUG
(paren
l_string|&quot;NodeMgr: Exiting thread for %s&quot;
comma
id|hi-&gt;host-&gt;driver-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|complete_and_exit
c_func
(paren
op_amp
id|hi-&gt;exited
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|hpsb_guid_get_entry
r_struct
id|node_entry
op_star
id|hpsb_guid_get_entry
c_func
(paren
id|u64
id|guid
)paren
(brace
r_struct
id|node_entry
op_star
id|ne
suffix:semicolon
id|down
c_func
(paren
op_amp
id|nodemgr_serialize
)paren
suffix:semicolon
id|ne
op_assign
id|find_entry_by_guid
c_func
(paren
id|guid
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|nodemgr_serialize
)paren
suffix:semicolon
r_return
id|ne
suffix:semicolon
)brace
DECL|function|hpsb_nodeid_get_entry
r_struct
id|node_entry
op_star
id|hpsb_nodeid_get_entry
c_func
(paren
id|nodeid_t
id|nodeid
)paren
(brace
r_struct
id|node_entry
op_star
id|ne
suffix:semicolon
id|down
c_func
(paren
op_amp
id|nodemgr_serialize
)paren
suffix:semicolon
id|ne
op_assign
id|find_entry_by_nodeid
c_func
(paren
id|nodeid
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|nodemgr_serialize
)paren
suffix:semicolon
r_return
id|ne
suffix:semicolon
)brace
multiline_comment|/* The following four convenience functions use a struct node_entry&n; * for addressing a node on the bus.  They are intended for use by any&n; * process context, not just the nodemgr thread, so we need to be a&n; * little careful when reading out the node ID and generation.  The&n; * thing that can go wrong is that we get the node ID, then a bus&n; * reset occurs, and then we read the generation.  The node ID is&n; * possibly invalid, but the generation is current, and we end up&n; * sending a packet to a the wrong node.&n; *&n; * The solution is to make sure we read the generation first, so that&n; * if a reset occurs in the process, we end up with a stale generation&n; * and the transactions will fail instead of silently using wrong node&n; * ID&squot;s.&n; */
DECL|function|hpsb_node_fill_packet
r_void
id|hpsb_node_fill_packet
c_func
(paren
r_struct
id|node_entry
op_star
id|ne
comma
r_struct
id|hpsb_packet
op_star
id|pkt
)paren
(brace
id|pkt-&gt;host
op_assign
id|ne-&gt;host
suffix:semicolon
id|pkt-&gt;generation
op_assign
id|ne-&gt;generation
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|pkt-&gt;node_id
op_assign
id|ne-&gt;nodeid
suffix:semicolon
)brace
DECL|function|hpsb_node_read
r_int
id|hpsb_node_read
c_func
(paren
r_struct
id|node_entry
op_star
id|ne
comma
id|u64
id|addr
comma
id|quadlet_t
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
r_int
r_int
id|generation
op_assign
id|ne-&gt;generation
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
r_return
id|hpsb_read
c_func
(paren
id|ne-&gt;host
comma
id|ne-&gt;nodeid
comma
id|generation
comma
id|addr
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
)brace
DECL|function|hpsb_node_write
r_int
id|hpsb_node_write
c_func
(paren
r_struct
id|node_entry
op_star
id|ne
comma
id|u64
id|addr
comma
id|quadlet_t
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
r_int
r_int
id|generation
op_assign
id|ne-&gt;generation
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
r_return
id|hpsb_write
c_func
(paren
id|ne-&gt;host
comma
id|ne-&gt;nodeid
comma
id|generation
comma
id|addr
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
)brace
DECL|function|hpsb_node_lock
r_int
id|hpsb_node_lock
c_func
(paren
r_struct
id|node_entry
op_star
id|ne
comma
id|u64
id|addr
comma
r_int
id|extcode
comma
id|quadlet_t
op_star
id|data
comma
id|quadlet_t
id|arg
)paren
(brace
r_int
r_int
id|generation
op_assign
id|ne-&gt;generation
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
r_return
id|hpsb_lock
c_func
(paren
id|ne-&gt;host
comma
id|ne-&gt;nodeid
comma
id|generation
comma
id|addr
comma
id|extcode
comma
id|data
comma
id|arg
)paren
suffix:semicolon
)brace
DECL|function|nodemgr_add_host
r_static
r_void
id|nodemgr_add_host
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
(brace
r_struct
id|host_info
op_star
id|hi
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|host_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hi
)paren
(brace
id|HPSB_ERR
(paren
l_string|&quot;NodeMgr: out of memory in add host&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Initialize the hostinfo here and start the thread.  The&n;&t; * thread blocks on the reset semaphore until a bus reset&n;&t; * happens. */
id|hi-&gt;host
op_assign
id|host
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|hi-&gt;list
)paren
suffix:semicolon
id|init_completion
c_func
(paren
op_amp
id|hi-&gt;exited
)paren
suffix:semicolon
id|sema_init
c_func
(paren
op_amp
id|hi-&gt;reset_sem
comma
l_int|0
)paren
suffix:semicolon
id|hi-&gt;pid
op_assign
id|kernel_thread
c_func
(paren
id|nodemgr_host_thread
comma
id|hi
comma
id|CLONE_FS
op_or
id|CLONE_FILES
op_or
id|CLONE_SIGHAND
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hi-&gt;pid
OL
l_int|0
)paren
(brace
id|HPSB_ERR
(paren
l_string|&quot;NodeMgr: failed to start NodeMgr thread for %s&quot;
comma
id|host-&gt;driver-&gt;name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hi
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock_irqsave
(paren
op_amp
id|host_info_lock
comma
id|flags
)paren
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|hi-&gt;list
comma
op_amp
id|host_info_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|host_info_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|nodemgr_host_reset
r_static
r_void
id|nodemgr_host_reset
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|host_info
op_star
id|hi
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|host_info_lock
comma
id|flags
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|lh
comma
op_amp
id|host_info_list
)paren
(brace
r_struct
id|host_info
op_star
id|myhi
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|host_info
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|myhi-&gt;host
op_eq
id|host
)paren
(brace
id|hi
op_assign
id|myhi
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|hi
op_ne
l_int|NULL
)paren
(brace
macro_line|#ifdef CONFIG_IEEE1394_VERBOSEDEBUG
id|HPSB_DEBUG
(paren
l_string|&quot;NodeMgr: Processing host reset for %s&quot;
comma
id|host-&gt;driver-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|up
c_func
(paren
op_amp
id|hi-&gt;reset_sem
)paren
suffix:semicolon
)brace
r_else
id|HPSB_ERR
(paren
l_string|&quot;NodeMgr: could not process reset of non-existent host&quot;
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|host_info_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|nodemgr_remove_host
r_static
r_void
id|nodemgr_remove_host
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
(brace
r_struct
id|list_head
op_star
id|lh
comma
op_star
id|next
suffix:semicolon
r_struct
id|node_entry
op_star
id|ne
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|host_info
op_star
id|hi
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|host_info_lock
comma
id|flags
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|lh
comma
id|next
comma
op_amp
id|host_info_list
)paren
(brace
r_struct
id|host_info
op_star
id|myhi
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|host_info
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|myhi-&gt;host
op_eq
id|host
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|myhi-&gt;list
)paren
suffix:semicolon
id|hi
op_assign
id|myhi
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|host_info_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hi
)paren
(brace
r_if
c_cond
(paren
id|hi-&gt;pid
op_ge
l_int|0
)paren
(brace
id|kill_proc
c_func
(paren
id|hi-&gt;pid
comma
id|SIGTERM
comma
l_int|1
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|hi-&gt;exited
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|hi
)paren
suffix:semicolon
)brace
r_else
id|HPSB_ERR
c_func
(paren
l_string|&quot;NodeMgr: host %s does not exist, cannot remove&quot;
comma
id|host-&gt;driver-&gt;name
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|nodemgr_serialize
)paren
suffix:semicolon
multiline_comment|/* Even if we fail the host_info part, remove all the node&n;&t; * entries.  */
id|list_for_each_safe
c_func
(paren
id|lh
comma
id|next
comma
op_amp
id|node_list
)paren
(brace
id|ne
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|node_entry
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ne-&gt;host
op_eq
id|host
)paren
id|nodemgr_remove_node
c_func
(paren
id|ne
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|nodemgr_serialize
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|variable|nodemgr_ops
r_static
r_struct
id|hpsb_highlevel_ops
id|nodemgr_ops
op_assign
(brace
dot
id|add_host
op_assign
id|nodemgr_add_host
comma
dot
id|host_reset
op_assign
id|nodemgr_host_reset
comma
dot
id|remove_host
op_assign
id|nodemgr_remove_host
comma
)brace
suffix:semicolon
DECL|variable|hl
r_static
r_struct
id|hpsb_highlevel
op_star
id|hl
suffix:semicolon
DECL|macro|PROC_ENTRY
mdefine_line|#define PROC_ENTRY &quot;devices&quot;
DECL|function|init_ieee1394_nodemgr
r_void
id|init_ieee1394_nodemgr
c_func
(paren
r_int
id|disable_hotplug
)paren
(brace
id|nodemgr_disable_hotplug
op_assign
id|disable_hotplug
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
r_if
c_cond
(paren
op_logical_neg
id|create_proc_read_entry
c_func
(paren
id|PROC_ENTRY
comma
l_int|0444
comma
id|ieee1394_procfs_entry
comma
id|raw1394_read_proc
comma
l_int|NULL
)paren
)paren
id|HPSB_ERR
c_func
(paren
l_string|&quot;Can&squot;t create devices procfs entry&quot;
)paren
suffix:semicolon
macro_line|#endif
id|hl
op_assign
id|hpsb_register_highlevel
c_func
(paren
l_string|&quot;Node manager&quot;
comma
op_amp
id|nodemgr_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hl
)paren
(brace
id|HPSB_ERR
c_func
(paren
l_string|&quot;NodeMgr: out of memory during ieee1394 initialization&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|cleanup_ieee1394_nodemgr
r_void
id|cleanup_ieee1394_nodemgr
c_func
(paren
r_void
)paren
(brace
id|hpsb_unregister_highlevel
c_func
(paren
id|hl
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|remove_proc_entry
c_func
(paren
id|PROC_ENTRY
comma
id|ieee1394_procfs_entry
)paren
suffix:semicolon
macro_line|#endif
)brace
eof
