multiline_comment|/*&n; * Node information (ConfigROM) collection and management.&n; *&n; * Copyright (C) 2000&t;&t;Andreas E. Bombe&n; *               2001-2003&t;Ben Collins &lt;bcollins@debian.net&gt;&n; *&n; * This code is licensed under the GPL.  See the file COPYING in the root&n; * directory of the kernel sources for details.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &quot;ieee1394_types.h&quot;
macro_line|#include &quot;ieee1394.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;ieee1394_transactions.h&quot;
macro_line|#include &quot;highlevel.h&quot;
macro_line|#include &quot;csr.h&quot;
macro_line|#include &quot;nodemgr.h&quot;
DECL|variable|ignore_drivers
r_static
r_int
id|ignore_drivers
op_assign
l_int|0
suffix:semicolon
id|module_param
c_func
(paren
id|ignore_drivers
comma
r_int
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|ignore_drivers
comma
l_string|&quot;Disable automatic probing for drivers.&quot;
)paren
suffix:semicolon
DECL|struct|nodemgr_csr_info
r_struct
id|nodemgr_csr_info
(brace
DECL|member|host
r_struct
id|hpsb_host
op_star
id|host
suffix:semicolon
DECL|member|nodeid
id|nodeid_t
id|nodeid
suffix:semicolon
DECL|member|generation
r_int
r_int
id|generation
suffix:semicolon
)brace
suffix:semicolon
DECL|function|nodemgr_find_oui_name
r_static
r_char
op_star
id|nodemgr_find_oui_name
c_func
(paren
r_int
id|oui
)paren
(brace
macro_line|#ifdef CONFIG_IEEE1394_OUI_DB
r_extern
r_struct
id|oui_list_struct
(brace
r_int
id|oui
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
)brace
id|oui_list
(braket
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|oui_list
(braket
id|i
)braket
dot
id|name
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|oui_list
(braket
id|i
)braket
dot
id|oui
op_eq
id|oui
)paren
r_return
id|oui_list
(braket
id|i
)braket
dot
id|name
suffix:semicolon
macro_line|#endif
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|nodemgr_bus_read
r_static
r_int
id|nodemgr_bus_read
c_func
(paren
r_struct
id|csr1212_csr
op_star
id|csr
comma
id|u64
id|addr
comma
id|u16
id|length
comma
r_void
op_star
id|buffer
comma
r_void
op_star
id|__ci
)paren
(brace
r_struct
id|nodemgr_csr_info
op_star
id|ci
op_assign
(paren
r_struct
id|nodemgr_csr_info
op_star
)paren
id|__ci
suffix:semicolon
r_int
id|i
comma
id|ret
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ret
op_assign
id|hpsb_read
c_func
(paren
id|ci-&gt;host
comma
id|ci-&gt;nodeid
comma
id|ci-&gt;generation
comma
id|addr
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|msleep_interruptible
c_func
(paren
l_int|334
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|nodemgr_get_max_rom
r_static
r_int
id|nodemgr_get_max_rom
c_func
(paren
id|quadlet_t
op_star
id|bus_info_data
comma
r_void
op_star
id|__ci
)paren
(brace
r_return
(paren
id|CSR1212_BE32_TO_CPU
c_func
(paren
id|bus_info_data
(braket
l_int|2
)braket
)paren
op_rshift
l_int|8
)paren
op_amp
l_int|0x3
suffix:semicolon
)brace
DECL|variable|nodemgr_csr_ops
r_static
r_struct
id|csr1212_bus_ops
id|nodemgr_csr_ops
op_assign
(brace
dot
id|bus_read
op_assign
id|nodemgr_bus_read
comma
dot
id|get_max_rom
op_assign
id|nodemgr_get_max_rom
)brace
suffix:semicolon
multiline_comment|/*&n; * Basically what we do here is start off retrieving the bus_info block.&n; * From there will fill in some info about the node, verify it is of IEEE&n; * 1394 type, and that the crc checks out ok. After that we start off with&n; * the root directory, and subdirectories. To do this, we retrieve the&n; * quadlet header for a directory, find out the length, and retrieve the&n; * complete directory entry (be it a leaf or a directory). We then process&n; * it and add the info to our structure for that particular node.&n; *&n; * We verify CRC&squot;s along the way for each directory/block/leaf. The entire&n; * node structure is generic, and simply stores the information in a way&n; * that&squot;s easy to parse by the protocol interface.&n; */
multiline_comment|/*&n; * The nodemgr relies heavily on the Driver Model for device callbacks and&n; * driver/device mappings. The old nodemgr used to handle all this itself,&n; * but now we are much simpler because of the LDM.&n; */
r_static
id|DECLARE_MUTEX
c_func
(paren
id|nodemgr_serialize
)paren
suffix:semicolon
DECL|struct|host_info
r_struct
id|host_info
(brace
DECL|member|host
r_struct
id|hpsb_host
op_star
id|host
suffix:semicolon
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|exited
r_struct
id|completion
id|exited
suffix:semicolon
DECL|member|reset_sem
r_struct
id|semaphore
id|reset_sem
suffix:semicolon
DECL|member|pid
r_int
id|pid
suffix:semicolon
DECL|member|daemon_name
r_char
id|daemon_name
(braket
l_int|15
)braket
suffix:semicolon
DECL|member|kill_me
r_int
id|kill_me
suffix:semicolon
)brace
suffix:semicolon
r_static
r_int
id|nodemgr_bus_match
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|device_driver
op_star
id|drv
)paren
suffix:semicolon
r_static
r_int
id|nodemgr_hotplug
c_func
(paren
r_struct
id|class_device
op_star
id|cdev
comma
r_char
op_star
op_star
id|envp
comma
r_int
id|num_envp
comma
r_char
op_star
id|buffer
comma
r_int
id|buffer_size
)paren
suffix:semicolon
r_static
r_void
id|nodemgr_resume_ne
c_func
(paren
r_struct
id|node_entry
op_star
id|ne
)paren
suffix:semicolon
r_static
r_void
id|nodemgr_remove_ne
c_func
(paren
r_struct
id|node_entry
op_star
id|ne
)paren
suffix:semicolon
r_static
r_struct
id|node_entry
op_star
id|find_entry_by_guid
c_func
(paren
id|u64
id|guid
)paren
suffix:semicolon
DECL|variable|ieee1394_bus_type
r_struct
id|bus_type
id|ieee1394_bus_type
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ieee1394&quot;
comma
dot
id|match
op_assign
id|nodemgr_bus_match
comma
)brace
suffix:semicolon
DECL|function|host_cls_release
r_static
r_void
id|host_cls_release
c_func
(paren
r_struct
id|class_device
op_star
id|class_dev
)paren
(brace
id|put_device
c_func
(paren
op_amp
id|container_of
c_func
(paren
(paren
id|class_dev
)paren
comma
r_struct
id|hpsb_host
comma
id|class_dev
)paren
op_member_access_from_pointer
id|device
)paren
suffix:semicolon
)brace
DECL|variable|hpsb_host_class
r_struct
r_class
id|hpsb_host_class
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ieee1394_host&quot;
comma
dot
id|release
op_assign
id|host_cls_release
comma
)brace
suffix:semicolon
DECL|function|ne_cls_release
r_static
r_void
id|ne_cls_release
c_func
(paren
r_struct
id|class_device
op_star
id|class_dev
)paren
(brace
id|put_device
c_func
(paren
op_amp
id|container_of
c_func
(paren
(paren
id|class_dev
)paren
comma
r_struct
id|node_entry
comma
id|class_dev
)paren
op_member_access_from_pointer
id|device
)paren
suffix:semicolon
)brace
DECL|variable|nodemgr_ne_class
r_static
r_struct
r_class
id|nodemgr_ne_class
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ieee1394_node&quot;
comma
dot
id|release
op_assign
id|ne_cls_release
comma
)brace
suffix:semicolon
DECL|function|ud_cls_release
r_static
r_void
id|ud_cls_release
c_func
(paren
r_struct
id|class_device
op_star
id|class_dev
)paren
(brace
id|put_device
c_func
(paren
op_amp
id|container_of
c_func
(paren
(paren
id|class_dev
)paren
comma
r_struct
id|unit_directory
comma
id|class_dev
)paren
op_member_access_from_pointer
id|device
)paren
suffix:semicolon
)brace
multiline_comment|/* The name here is only so that unit directory hotplug works with old&n; * style hotplug, which only ever did unit directories anyway. */
DECL|variable|nodemgr_ud_class
r_static
r_struct
r_class
id|nodemgr_ud_class
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ieee1394&quot;
comma
dot
id|release
op_assign
id|ud_cls_release
comma
dot
id|hotplug
op_assign
id|nodemgr_hotplug
comma
)brace
suffix:semicolon
DECL|variable|nodemgr_highlevel
r_static
r_struct
id|hpsb_highlevel
id|nodemgr_highlevel
suffix:semicolon
DECL|function|nodemgr_release_ud
r_static
r_void
id|nodemgr_release_ud
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|unit_directory
op_star
id|ud
op_assign
id|container_of
c_func
(paren
id|dev
comma
r_struct
id|unit_directory
comma
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;vendor_name_kv
)paren
id|csr1212_release_keyval
c_func
(paren
id|ud-&gt;vendor_name_kv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;model_name_kv
)paren
id|csr1212_release_keyval
c_func
(paren
id|ud-&gt;model_name_kv
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ud
)paren
suffix:semicolon
)brace
DECL|function|nodemgr_release_ne
r_static
r_void
id|nodemgr_release_ne
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|node_entry
op_star
id|ne
op_assign
id|container_of
c_func
(paren
id|dev
comma
r_struct
id|node_entry
comma
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ne-&gt;vendor_name_kv
)paren
id|csr1212_release_keyval
c_func
(paren
id|ne-&gt;vendor_name_kv
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ne
)paren
suffix:semicolon
)brace
DECL|function|nodemgr_release_host
r_static
r_void
id|nodemgr_release_host
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|hpsb_host
op_star
id|host
op_assign
id|container_of
c_func
(paren
id|dev
comma
r_struct
id|hpsb_host
comma
id|device
)paren
suffix:semicolon
id|csr1212_destroy_csr
c_func
(paren
id|host-&gt;csr.rom
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|host
)paren
suffix:semicolon
)brace
DECL|variable|nodemgr_ud_platform_data
r_static
r_int
id|nodemgr_ud_platform_data
suffix:semicolon
DECL|variable|nodemgr_dev_template_ud
r_static
r_struct
id|device
id|nodemgr_dev_template_ud
op_assign
(brace
dot
id|bus
op_assign
op_amp
id|ieee1394_bus_type
comma
dot
id|release
op_assign
id|nodemgr_release_ud
comma
dot
id|platform_data
op_assign
op_amp
id|nodemgr_ud_platform_data
comma
)brace
suffix:semicolon
DECL|variable|nodemgr_dev_template_ne
r_static
r_struct
id|device
id|nodemgr_dev_template_ne
op_assign
(brace
dot
id|bus
op_assign
op_amp
id|ieee1394_bus_type
comma
dot
id|release
op_assign
id|nodemgr_release_ne
comma
)brace
suffix:semicolon
DECL|variable|nodemgr_dev_template_host
r_struct
id|device
id|nodemgr_dev_template_host
op_assign
(brace
dot
id|bus
op_assign
op_amp
id|ieee1394_bus_type
comma
dot
id|release
op_assign
id|nodemgr_release_host
comma
)brace
suffix:semicolon
DECL|macro|fw_attr
mdefine_line|#define fw_attr(class, class_type, field, type, format_string)&t;&t;&bslash;&n;static ssize_t fw_show_##class##_##field (struct device *dev, char *buf)&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;class_type *class;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;class = container_of(dev, class_type, device);&t;&t;&t;&bslash;&n;&t;return sprintf(buf, format_string, (type)class-&gt;field);&t;&t;&bslash;&n;}&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;static struct device_attribute dev_attr_##class##_##field = {&t;&t;&bslash;&n;&t;.attr = {.name = __stringify(field), .mode = S_IRUGO },&t;&t;&bslash;&n;&t;.show   = fw_show_##class##_##field,&t;&t;&t;&t;&bslash;&n;};
DECL|macro|fw_attr_td
mdefine_line|#define fw_attr_td(class, class_type, td_kv)&t;&t;&t;&t;&bslash;&n;static ssize_t fw_show_##class##_##td_kv (struct device *dev, char *buf)&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;int len;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;class_type *class = container_of(dev, class_type, device);&t;&bslash;&n;&t;len = (class-&gt;td_kv-&gt;value.leaf.len - 2) * sizeof(quadlet_t);&t;&bslash;&n;&t;memcpy(buf,&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;       CSR1212_TEXTUAL_DESCRIPTOR_LEAF_DATA(class-&gt;td_kv),&t;&bslash;&n;&t;       len);&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;while ((buf + len - 1) == &squot;&bslash;0&squot;)&t;&t;&t;&t;&t;&bslash;&n;&t;&t;len--;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;buf[len++] = &squot;&bslash;n&squot;;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;buf[len] = &squot;&bslash;0&squot;;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;return len;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;}&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;static struct device_attribute dev_attr_##class##_##td_kv = {&t;&t;&bslash;&n;&t;.attr = {.name = __stringify(td_kv), .mode = S_IRUGO },&t;&t;&bslash;&n;&t;.show   = fw_show_##class##_##td_kv,&t;&t;&t;&t;&bslash;&n;};
DECL|macro|fw_drv_attr
mdefine_line|#define fw_drv_attr(field, type, format_string)&t;&t;&t;&bslash;&n;static ssize_t fw_drv_show_##field (struct device_driver *drv, char *buf) &bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;struct hpsb_protocol_driver *driver;&t;&t;&t;&bslash;&n;&t;driver = container_of(drv, struct hpsb_protocol_driver, driver); &bslash;&n;&t;return sprintf(buf, format_string, (type)driver-&gt;field);&bslash;&n;}&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;static struct driver_attribute driver_attr_drv_##field = {&t;&bslash;&n;        .attr = {.name = __stringify(field), .mode = S_IRUGO },&t;&bslash;&n;        .show   = fw_drv_show_##field,&t;&t;&t;&t;&bslash;&n;};
DECL|function|fw_show_ne_bus_options
r_static
id|ssize_t
id|fw_show_ne_bus_options
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|node_entry
op_star
id|ne
op_assign
id|container_of
c_func
(paren
id|dev
comma
r_struct
id|node_entry
comma
id|device
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;IRMC(%d) CMC(%d) ISC(%d) BMC(%d) PMC(%d) GEN(%d) &quot;
l_string|&quot;LSPD(%d) MAX_REC(%d) MAX_ROM(%d) CYC_CLK_ACC(%d)&bslash;n&quot;
comma
id|ne-&gt;busopt.irmc
comma
id|ne-&gt;busopt.cmc
comma
id|ne-&gt;busopt.isc
comma
id|ne-&gt;busopt.bmc
comma
id|ne-&gt;busopt.pmc
comma
id|ne-&gt;busopt.generation
comma
id|ne-&gt;busopt.lnkspd
comma
id|ne-&gt;busopt.max_rec
comma
id|ne-&gt;busopt.max_rom
comma
id|ne-&gt;busopt.cyc_clk_acc
)paren
suffix:semicolon
)brace
r_static
id|DEVICE_ATTR
c_func
(paren
id|bus_options
comma
id|S_IRUGO
comma
id|fw_show_ne_bus_options
comma
l_int|NULL
)paren
suffix:semicolon
DECL|function|fw_show_ne_tlabels_free
r_static
id|ssize_t
id|fw_show_ne_tlabels_free
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|node_entry
op_star
id|ne
op_assign
id|container_of
c_func
(paren
id|dev
comma
r_struct
id|node_entry
comma
id|device
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|ne-&gt;tpool-&gt;count.count
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_static
id|DEVICE_ATTR
c_func
(paren
id|tlabels_free
comma
id|S_IRUGO
comma
id|fw_show_ne_tlabels_free
comma
l_int|NULL
)paren
suffix:semicolon
DECL|function|fw_show_ne_tlabels_allocations
r_static
id|ssize_t
id|fw_show_ne_tlabels_allocations
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|node_entry
op_star
id|ne
op_assign
id|container_of
c_func
(paren
id|dev
comma
r_struct
id|node_entry
comma
id|device
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%u&bslash;n&quot;
comma
id|ne-&gt;tpool-&gt;allocations
)paren
suffix:semicolon
)brace
r_static
id|DEVICE_ATTR
c_func
(paren
id|tlabels_allocations
comma
id|S_IRUGO
comma
id|fw_show_ne_tlabels_allocations
comma
l_int|NULL
)paren
suffix:semicolon
DECL|function|fw_show_ne_tlabels_mask
r_static
id|ssize_t
id|fw_show_ne_tlabels_mask
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|node_entry
op_star
id|ne
op_assign
id|container_of
c_func
(paren
id|dev
comma
r_struct
id|node_entry
comma
id|device
)paren
suffix:semicolon
macro_line|#if (BITS_PER_LONG &lt;= 32)
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;0x%08lx%08lx&bslash;n&quot;
comma
id|ne-&gt;tpool-&gt;pool
(braket
l_int|0
)braket
comma
id|ne-&gt;tpool-&gt;pool
(braket
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#else
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;0x%016lx&bslash;n&quot;
comma
id|ne-&gt;tpool-&gt;pool
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
r_static
id|DEVICE_ATTR
c_func
(paren
id|tlabels_mask
comma
id|S_IRUGO
comma
id|fw_show_ne_tlabels_mask
comma
l_int|NULL
)paren
suffix:semicolon
DECL|function|fw_set_ignore_driver
r_static
id|ssize_t
id|fw_set_ignore_driver
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|unit_directory
op_star
id|ud
op_assign
id|container_of
c_func
(paren
id|dev
comma
r_struct
id|unit_directory
comma
id|device
)paren
suffix:semicolon
r_int
id|state
op_assign
id|simple_strtoul
c_func
(paren
id|buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
l_int|1
)paren
(brace
id|down_write
c_func
(paren
op_amp
id|dev-&gt;bus-&gt;subsys.rwsem
)paren
suffix:semicolon
id|device_release_driver
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ud-&gt;ignore_driver
op_assign
l_int|1
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|dev-&gt;bus-&gt;subsys.rwsem
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|state
)paren
id|ud-&gt;ignore_driver
op_assign
l_int|0
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|function|fw_get_ignore_driver
r_static
id|ssize_t
id|fw_get_ignore_driver
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|unit_directory
op_star
id|ud
op_assign
id|container_of
c_func
(paren
id|dev
comma
r_struct
id|unit_directory
comma
id|device
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|ud-&gt;ignore_driver
)paren
suffix:semicolon
)brace
r_static
id|DEVICE_ATTR
c_func
(paren
id|ignore_driver
comma
id|S_IWUSR
op_or
id|S_IRUGO
comma
id|fw_get_ignore_driver
comma
id|fw_set_ignore_driver
)paren
suffix:semicolon
DECL|function|fw_set_destroy_node
r_static
id|ssize_t
id|fw_set_destroy_node
c_func
(paren
r_struct
id|bus_type
op_star
id|bus
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|node_entry
op_star
id|ne
suffix:semicolon
id|u64
id|guid
op_assign
(paren
id|u64
)paren
id|simple_strtoull
c_func
(paren
id|buf
comma
l_int|NULL
comma
l_int|16
)paren
suffix:semicolon
id|ne
op_assign
id|find_entry_by_guid
c_func
(paren
id|guid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ne
op_eq
l_int|NULL
op_logical_or
op_logical_neg
id|ne-&gt;in_limbo
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|nodemgr_remove_ne
c_func
(paren
id|ne
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|function|fw_get_destroy_node
r_static
id|ssize_t
id|fw_get_destroy_node
c_func
(paren
r_struct
id|bus_type
op_star
id|bus
comma
r_char
op_star
id|buf
)paren
(brace
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;You can destroy in_limbo nodes by writing their GUID to this file&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_static
id|BUS_ATTR
c_func
(paren
id|destroy_node
comma
id|S_IWUSR
op_or
id|S_IRUGO
comma
id|fw_get_destroy_node
comma
id|fw_set_destroy_node
)paren
suffix:semicolon
DECL|function|nodemgr_rescan_bus_thread
r_static
r_int
id|nodemgr_rescan_bus_thread
c_func
(paren
r_void
op_star
id|__unused
)paren
(brace
multiline_comment|/* No userlevel access needed */
id|daemonize
c_func
(paren
l_string|&quot;kfwrescan&quot;
)paren
suffix:semicolon
id|bus_rescan_devices
c_func
(paren
op_amp
id|ieee1394_bus_type
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fw_set_rescan
r_static
id|ssize_t
id|fw_set_rescan
c_func
(paren
r_struct
id|bus_type
op_star
id|bus
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|state
op_assign
id|simple_strtoul
c_func
(paren
id|buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t wait for this, or care about errors. Root could do&n;&t; * something stupid and spawn this a lot of times, but that&squot;s&n;&t; * root&squot;s fault. */
r_if
c_cond
(paren
id|state
op_eq
l_int|1
)paren
id|kernel_thread
c_func
(paren
id|nodemgr_rescan_bus_thread
comma
l_int|NULL
comma
id|CLONE_KERNEL
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|function|fw_get_rescan
r_static
id|ssize_t
id|fw_get_rescan
c_func
(paren
r_struct
id|bus_type
op_star
id|bus
comma
r_char
op_star
id|buf
)paren
(brace
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;You can force a rescan of the bus for &quot;
l_string|&quot;drivers by writing a 1 to this file&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_static
id|BUS_ATTR
c_func
(paren
id|rescan
comma
id|S_IWUSR
op_or
id|S_IRUGO
comma
id|fw_get_rescan
comma
id|fw_set_rescan
)paren
suffix:semicolon
DECL|function|fw_set_ignore_drivers
r_static
id|ssize_t
id|fw_set_ignore_drivers
c_func
(paren
r_struct
id|bus_type
op_star
id|bus
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|state
op_assign
id|simple_strtoul
c_func
(paren
id|buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
l_int|1
)paren
id|ignore_drivers
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|state
)paren
id|ignore_drivers
op_assign
l_int|0
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|function|fw_get_ignore_drivers
r_static
id|ssize_t
id|fw_get_ignore_drivers
c_func
(paren
r_struct
id|bus_type
op_star
id|bus
comma
r_char
op_star
id|buf
)paren
(brace
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|ignore_drivers
)paren
suffix:semicolon
)brace
r_static
id|BUS_ATTR
c_func
(paren
id|ignore_drivers
comma
id|S_IWUSR
op_or
id|S_IRUGO
comma
id|fw_get_ignore_drivers
comma
id|fw_set_ignore_drivers
)paren
suffix:semicolon
DECL|variable|fw_bus_attrs
r_struct
id|bus_attribute
op_star
r_const
id|fw_bus_attrs
(braket
)braket
op_assign
(brace
op_amp
id|bus_attr_destroy_node
comma
op_amp
id|bus_attr_rescan
comma
op_amp
id|bus_attr_ignore_drivers
comma
l_int|NULL
)brace
suffix:semicolon
id|fw_attr
c_func
(paren
id|ne
comma
r_struct
id|node_entry
comma
id|capabilities
comma
r_int
r_int
comma
l_string|&quot;0x%06x&bslash;n&quot;
)paren
id|fw_attr
c_func
(paren
id|ne
comma
r_struct
id|node_entry
comma
id|nodeid
comma
r_int
r_int
comma
l_string|&quot;0x%04x&bslash;n&quot;
)paren
id|fw_attr
c_func
(paren
id|ne
comma
r_struct
id|node_entry
comma
id|vendor_id
comma
r_int
r_int
comma
l_string|&quot;0x%06x&bslash;n&quot;
)paren
id|fw_attr_td
c_func
(paren
id|ne
comma
r_struct
id|node_entry
comma
id|vendor_name_kv
)paren
id|fw_attr
c_func
(paren
id|ne
comma
r_struct
id|node_entry
comma
id|vendor_oui
comma
r_const
r_char
op_star
comma
l_string|&quot;%s&bslash;n&quot;
)paren
id|fw_attr
c_func
(paren
id|ne
comma
r_struct
id|node_entry
comma
id|guid
comma
r_int
r_int
r_int
comma
l_string|&quot;0x%016Lx&bslash;n&quot;
)paren
id|fw_attr
c_func
(paren
id|ne
comma
r_struct
id|node_entry
comma
id|guid_vendor_id
comma
r_int
r_int
comma
l_string|&quot;0x%06x&bslash;n&quot;
)paren
id|fw_attr
c_func
(paren
id|ne
comma
r_struct
id|node_entry
comma
id|guid_vendor_oui
comma
r_const
r_char
op_star
comma
l_string|&quot;%s&bslash;n&quot;
)paren
id|fw_attr
c_func
(paren
id|ne
comma
r_struct
id|node_entry
comma
id|in_limbo
comma
r_int
comma
l_string|&quot;%d&bslash;n&quot;
)paren
suffix:semicolon
DECL|variable|fw_ne_attrs
r_static
r_struct
id|device_attribute
op_star
r_const
id|fw_ne_attrs
(braket
)braket
op_assign
(brace
op_amp
id|dev_attr_ne_guid
comma
op_amp
id|dev_attr_ne_guid_vendor_id
comma
op_amp
id|dev_attr_ne_capabilities
comma
op_amp
id|dev_attr_ne_vendor_id
comma
op_amp
id|dev_attr_ne_nodeid
comma
op_amp
id|dev_attr_bus_options
comma
op_amp
id|dev_attr_tlabels_free
comma
op_amp
id|dev_attr_tlabels_allocations
comma
op_amp
id|dev_attr_tlabels_mask
comma
)brace
suffix:semicolon
id|fw_attr
c_func
(paren
id|ud
comma
r_struct
id|unit_directory
comma
id|address
comma
r_int
r_int
r_int
comma
l_string|&quot;0x%016Lx&bslash;n&quot;
)paren
id|fw_attr
c_func
(paren
id|ud
comma
r_struct
id|unit_directory
comma
id|length
comma
r_int
comma
l_string|&quot;%d&bslash;n&quot;
)paren
multiline_comment|/* These are all dependent on the value being provided */
id|fw_attr
c_func
(paren
id|ud
comma
r_struct
id|unit_directory
comma
id|vendor_id
comma
r_int
r_int
comma
l_string|&quot;0x%06x&bslash;n&quot;
)paren
id|fw_attr
c_func
(paren
id|ud
comma
r_struct
id|unit_directory
comma
id|model_id
comma
r_int
r_int
comma
l_string|&quot;0x%06x&bslash;n&quot;
)paren
id|fw_attr
c_func
(paren
id|ud
comma
r_struct
id|unit_directory
comma
id|specifier_id
comma
r_int
r_int
comma
l_string|&quot;0x%06x&bslash;n&quot;
)paren
id|fw_attr
c_func
(paren
id|ud
comma
r_struct
id|unit_directory
comma
id|version
comma
r_int
r_int
comma
l_string|&quot;0x%06x&bslash;n&quot;
)paren
id|fw_attr_td
c_func
(paren
id|ud
comma
r_struct
id|unit_directory
comma
id|vendor_name_kv
)paren
id|fw_attr
c_func
(paren
id|ud
comma
r_struct
id|unit_directory
comma
id|vendor_oui
comma
r_const
r_char
op_star
comma
l_string|&quot;%s&bslash;n&quot;
)paren
id|fw_attr_td
c_func
(paren
id|ud
comma
r_struct
id|unit_directory
comma
id|model_name_kv
)paren
DECL|variable|fw_ud_attrs
r_static
r_struct
id|device_attribute
op_star
r_const
id|fw_ud_attrs
(braket
)braket
op_assign
(brace
op_amp
id|dev_attr_ud_address
comma
op_amp
id|dev_attr_ud_length
comma
op_amp
id|dev_attr_ignore_driver
comma
)brace
suffix:semicolon
id|fw_attr
c_func
(paren
id|host
comma
r_struct
id|hpsb_host
comma
id|node_count
comma
r_int
comma
l_string|&quot;%d&bslash;n&quot;
)paren
id|fw_attr
c_func
(paren
id|host
comma
r_struct
id|hpsb_host
comma
id|selfid_count
comma
r_int
comma
l_string|&quot;%d&bslash;n&quot;
)paren
id|fw_attr
c_func
(paren
id|host
comma
r_struct
id|hpsb_host
comma
id|nodes_active
comma
r_int
comma
l_string|&quot;%d&bslash;n&quot;
)paren
id|fw_attr
c_func
(paren
id|host
comma
r_struct
id|hpsb_host
comma
id|in_bus_reset
comma
r_int
comma
l_string|&quot;%d&bslash;n&quot;
)paren
id|fw_attr
c_func
(paren
id|host
comma
r_struct
id|hpsb_host
comma
id|is_root
comma
r_int
comma
l_string|&quot;%d&bslash;n&quot;
)paren
id|fw_attr
c_func
(paren
id|host
comma
r_struct
id|hpsb_host
comma
id|is_cycmst
comma
r_int
comma
l_string|&quot;%d&bslash;n&quot;
)paren
id|fw_attr
c_func
(paren
id|host
comma
r_struct
id|hpsb_host
comma
id|is_irm
comma
r_int
comma
l_string|&quot;%d&bslash;n&quot;
)paren
id|fw_attr
c_func
(paren
id|host
comma
r_struct
id|hpsb_host
comma
id|is_busmgr
comma
r_int
comma
l_string|&quot;%d&bslash;n&quot;
)paren
DECL|variable|fw_host_attrs
r_static
r_struct
id|device_attribute
op_star
r_const
id|fw_host_attrs
(braket
)braket
op_assign
(brace
op_amp
id|dev_attr_host_node_count
comma
op_amp
id|dev_attr_host_selfid_count
comma
op_amp
id|dev_attr_host_nodes_active
comma
op_amp
id|dev_attr_host_in_bus_reset
comma
op_amp
id|dev_attr_host_is_root
comma
op_amp
id|dev_attr_host_is_cycmst
comma
op_amp
id|dev_attr_host_is_irm
comma
op_amp
id|dev_attr_host_is_busmgr
comma
)brace
suffix:semicolon
DECL|function|fw_show_drv_device_ids
r_static
id|ssize_t
id|fw_show_drv_device_ids
c_func
(paren
r_struct
id|device_driver
op_star
id|drv
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|hpsb_protocol_driver
op_star
id|driver
suffix:semicolon
r_struct
id|ieee1394_device_id
op_star
id|id
suffix:semicolon
r_int
id|length
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|scratch
op_assign
id|buf
suffix:semicolon
id|driver
op_assign
id|container_of
c_func
(paren
id|drv
comma
r_struct
id|hpsb_protocol_driver
comma
id|driver
)paren
suffix:semicolon
r_for
c_loop
(paren
id|id
op_assign
id|driver-&gt;id_table
suffix:semicolon
id|id-&gt;match_flags
op_ne
l_int|0
suffix:semicolon
id|id
op_increment
)paren
(brace
r_int
id|need_coma
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;match_flags
op_amp
id|IEEE1394_MATCH_VENDOR_ID
)paren
(brace
id|length
op_add_assign
id|sprintf
c_func
(paren
id|scratch
comma
l_string|&quot;vendor_id=0x%06x&quot;
comma
id|id-&gt;vendor_id
)paren
suffix:semicolon
id|scratch
op_assign
id|buf
op_plus
id|length
suffix:semicolon
id|need_coma
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|id-&gt;match_flags
op_amp
id|IEEE1394_MATCH_MODEL_ID
)paren
(brace
id|length
op_add_assign
id|sprintf
c_func
(paren
id|scratch
comma
l_string|&quot;%smodel_id=0x%06x&quot;
comma
id|need_coma
op_increment
ques
c_cond
l_string|&quot;,&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|id-&gt;model_id
)paren
suffix:semicolon
id|scratch
op_assign
id|buf
op_plus
id|length
suffix:semicolon
)brace
r_if
c_cond
(paren
id|id-&gt;match_flags
op_amp
id|IEEE1394_MATCH_SPECIFIER_ID
)paren
(brace
id|length
op_add_assign
id|sprintf
c_func
(paren
id|scratch
comma
l_string|&quot;%sspecifier_id=0x%06x&quot;
comma
id|need_coma
op_increment
ques
c_cond
l_string|&quot;,&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|id-&gt;specifier_id
)paren
suffix:semicolon
id|scratch
op_assign
id|buf
op_plus
id|length
suffix:semicolon
)brace
r_if
c_cond
(paren
id|id-&gt;match_flags
op_amp
id|IEEE1394_MATCH_VERSION
)paren
(brace
id|length
op_add_assign
id|sprintf
c_func
(paren
id|scratch
comma
l_string|&quot;%sversion=0x%06x&quot;
comma
id|need_coma
op_increment
ques
c_cond
l_string|&quot;,&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|id-&gt;version
)paren
suffix:semicolon
id|scratch
op_assign
id|buf
op_plus
id|length
suffix:semicolon
)brace
r_if
c_cond
(paren
id|need_coma
)paren
(brace
op_star
id|scratch
op_increment
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|length
op_increment
suffix:semicolon
)brace
)brace
r_return
id|length
suffix:semicolon
)brace
r_static
id|DRIVER_ATTR
c_func
(paren
id|device_ids
comma
id|S_IRUGO
comma
id|fw_show_drv_device_ids
comma
l_int|NULL
)paren
suffix:semicolon
id|fw_drv_attr
c_func
(paren
id|name
comma
r_const
r_char
op_star
comma
l_string|&quot;%s&bslash;n&quot;
)paren
DECL|variable|fw_drv_attrs
r_static
r_struct
id|driver_attribute
op_star
r_const
id|fw_drv_attrs
(braket
)braket
op_assign
(brace
op_amp
id|driver_attr_drv_name
comma
op_amp
id|driver_attr_device_ids
comma
)brace
suffix:semicolon
DECL|function|nodemgr_create_drv_files
r_static
r_void
id|nodemgr_create_drv_files
c_func
(paren
r_struct
id|hpsb_protocol_driver
op_star
id|driver
)paren
(brace
r_struct
id|device_driver
op_star
id|drv
op_assign
op_amp
id|driver-&gt;driver
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|fw_drv_attrs
)paren
suffix:semicolon
id|i
op_increment
)paren
id|driver_create_file
c_func
(paren
id|drv
comma
id|fw_drv_attrs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
DECL|function|nodemgr_remove_drv_files
r_static
r_void
id|nodemgr_remove_drv_files
c_func
(paren
r_struct
id|hpsb_protocol_driver
op_star
id|driver
)paren
(brace
r_struct
id|device_driver
op_star
id|drv
op_assign
op_amp
id|driver-&gt;driver
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|fw_drv_attrs
)paren
suffix:semicolon
id|i
op_increment
)paren
id|driver_remove_file
c_func
(paren
id|drv
comma
id|fw_drv_attrs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
DECL|function|nodemgr_create_ne_dev_files
r_static
r_void
id|nodemgr_create_ne_dev_files
c_func
(paren
r_struct
id|node_entry
op_star
id|ne
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
op_amp
id|ne-&gt;device
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|fw_ne_attrs
)paren
suffix:semicolon
id|i
op_increment
)paren
id|device_create_file
c_func
(paren
id|dev
comma
id|fw_ne_attrs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
DECL|function|nodemgr_create_host_dev_files
r_static
r_void
id|nodemgr_create_host_dev_files
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
op_amp
id|host-&gt;device
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|fw_host_attrs
)paren
suffix:semicolon
id|i
op_increment
)paren
id|device_create_file
c_func
(paren
id|dev
comma
id|fw_host_attrs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_static
r_struct
id|node_entry
op_star
id|find_entry_by_nodeid
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
comma
id|nodeid_t
id|nodeid
)paren
suffix:semicolon
DECL|function|nodemgr_update_host_dev_links
r_static
r_void
id|nodemgr_update_host_dev_links
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
op_amp
id|host-&gt;device
suffix:semicolon
r_struct
id|node_entry
op_star
id|ne
suffix:semicolon
id|sysfs_remove_link
c_func
(paren
op_amp
id|dev-&gt;kobj
comma
l_string|&quot;irm_id&quot;
)paren
suffix:semicolon
id|sysfs_remove_link
c_func
(paren
op_amp
id|dev-&gt;kobj
comma
l_string|&quot;busmgr_id&quot;
)paren
suffix:semicolon
id|sysfs_remove_link
c_func
(paren
op_amp
id|dev-&gt;kobj
comma
l_string|&quot;host_id&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ne
op_assign
id|find_entry_by_nodeid
c_func
(paren
id|host
comma
id|host-&gt;irm_id
)paren
)paren
)paren
id|sysfs_create_link
c_func
(paren
op_amp
id|dev-&gt;kobj
comma
op_amp
id|ne-&gt;device.kobj
comma
l_string|&quot;irm_id&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ne
op_assign
id|find_entry_by_nodeid
c_func
(paren
id|host
comma
id|host-&gt;busmgr_id
)paren
)paren
)paren
id|sysfs_create_link
c_func
(paren
op_amp
id|dev-&gt;kobj
comma
op_amp
id|ne-&gt;device.kobj
comma
l_string|&quot;busmgr_id&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ne
op_assign
id|find_entry_by_nodeid
c_func
(paren
id|host
comma
id|host-&gt;node_id
)paren
)paren
)paren
id|sysfs_create_link
c_func
(paren
op_amp
id|dev-&gt;kobj
comma
op_amp
id|ne-&gt;device.kobj
comma
l_string|&quot;host_id&quot;
)paren
suffix:semicolon
)brace
DECL|function|nodemgr_create_ud_dev_files
r_static
r_void
id|nodemgr_create_ud_dev_files
c_func
(paren
r_struct
id|unit_directory
op_star
id|ud
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
op_amp
id|ud-&gt;device
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|fw_ud_attrs
)paren
suffix:semicolon
id|i
op_increment
)paren
id|device_create_file
c_func
(paren
id|dev
comma
id|fw_ud_attrs
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;flags
op_amp
id|UNIT_DIRECTORY_SPECIFIER_ID
)paren
id|device_create_file
c_func
(paren
id|dev
comma
op_amp
id|dev_attr_ud_specifier_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;flags
op_amp
id|UNIT_DIRECTORY_VERSION
)paren
id|device_create_file
c_func
(paren
id|dev
comma
op_amp
id|dev_attr_ud_version
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;flags
op_amp
id|UNIT_DIRECTORY_VENDOR_ID
)paren
(brace
id|device_create_file
c_func
(paren
id|dev
comma
op_amp
id|dev_attr_ud_vendor_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;vendor_name_kv
)paren
id|device_create_file
c_func
(paren
id|dev
comma
op_amp
id|dev_attr_ud_vendor_name_kv
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ud-&gt;flags
op_amp
id|UNIT_DIRECTORY_MODEL_ID
)paren
(brace
id|device_create_file
c_func
(paren
id|dev
comma
op_amp
id|dev_attr_ud_model_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;model_name_kv
)paren
id|device_create_file
c_func
(paren
id|dev
comma
op_amp
id|dev_attr_ud_model_name_kv
)paren
suffix:semicolon
)brace
)brace
DECL|function|nodemgr_bus_match
r_static
r_int
id|nodemgr_bus_match
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|device_driver
op_star
id|drv
)paren
(brace
r_struct
id|hpsb_protocol_driver
op_star
id|driver
suffix:semicolon
r_struct
id|unit_directory
op_star
id|ud
suffix:semicolon
r_struct
id|ieee1394_device_id
op_star
id|id
suffix:semicolon
multiline_comment|/* We only match unit directories */
r_if
c_cond
(paren
id|dev-&gt;platform_data
op_ne
op_amp
id|nodemgr_ud_platform_data
)paren
r_return
l_int|0
suffix:semicolon
id|ud
op_assign
id|container_of
c_func
(paren
id|dev
comma
r_struct
id|unit_directory
comma
id|device
)paren
suffix:semicolon
id|driver
op_assign
id|container_of
c_func
(paren
id|drv
comma
r_struct
id|hpsb_protocol_driver
comma
id|driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;ne-&gt;in_limbo
op_logical_or
id|ud-&gt;ignore_driver
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|id
op_assign
id|driver-&gt;id_table
suffix:semicolon
id|id-&gt;match_flags
op_ne
l_int|0
suffix:semicolon
id|id
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|IEEE1394_MATCH_VENDOR_ID
)paren
op_logical_and
id|id-&gt;vendor_id
op_ne
id|ud-&gt;vendor_id
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|IEEE1394_MATCH_MODEL_ID
)paren
op_logical_and
id|id-&gt;model_id
op_ne
id|ud-&gt;model_id
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|IEEE1394_MATCH_SPECIFIER_ID
)paren
op_logical_and
id|id-&gt;specifier_id
op_ne
id|ud-&gt;specifier_id
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|IEEE1394_MATCH_VERSION
)paren
op_logical_and
id|id-&gt;version
op_ne
id|ud-&gt;version
)paren
r_continue
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|nodemgr_remove_uds
r_static
r_void
id|nodemgr_remove_uds
c_func
(paren
r_struct
id|node_entry
op_star
id|ne
)paren
(brace
r_struct
id|class_device
op_star
id|cdev
comma
op_star
id|next
suffix:semicolon
r_struct
id|unit_directory
op_star
id|ud
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|cdev
comma
id|next
comma
op_amp
id|nodemgr_ud_class.children
comma
id|node
)paren
(brace
id|ud
op_assign
id|container_of
c_func
(paren
id|cdev
comma
r_struct
id|unit_directory
comma
id|class_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;ne
op_ne
id|ne
)paren
r_continue
suffix:semicolon
id|class_device_unregister
c_func
(paren
op_amp
id|ud-&gt;class_dev
)paren
suffix:semicolon
id|device_unregister
c_func
(paren
op_amp
id|ud-&gt;device
)paren
suffix:semicolon
)brace
)brace
DECL|function|nodemgr_remove_ne
r_static
r_void
id|nodemgr_remove_ne
c_func
(paren
r_struct
id|node_entry
op_star
id|ne
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
op_amp
id|ne-&gt;device
suffix:semicolon
id|dev
op_assign
id|get_device
c_func
(paren
op_amp
id|ne-&gt;device
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
suffix:semicolon
id|HPSB_DEBUG
c_func
(paren
l_string|&quot;Node removed: ID:BUS[&quot;
id|NODE_BUS_FMT
l_string|&quot;]  GUID[%016Lx]&quot;
comma
id|NODE_BUS_ARGS
c_func
(paren
id|ne-&gt;host
comma
id|ne-&gt;nodeid
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|ne-&gt;guid
)paren
suffix:semicolon
id|nodemgr_remove_uds
c_func
(paren
id|ne
)paren
suffix:semicolon
id|class_device_unregister
c_func
(paren
op_amp
id|ne-&gt;class_dev
)paren
suffix:semicolon
id|device_unregister
c_func
(paren
id|dev
)paren
suffix:semicolon
id|put_device
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|function|nodemgr_remove_host_dev
r_static
r_void
id|nodemgr_remove_host_dev
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|device
op_star
id|ne_dev
comma
op_star
id|next
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|ne_dev
comma
id|next
comma
op_amp
id|dev-&gt;children
comma
id|node
)paren
id|nodemgr_remove_ne
c_func
(paren
id|container_of
c_func
(paren
id|ne_dev
comma
r_struct
id|node_entry
comma
id|device
)paren
)paren
suffix:semicolon
id|sysfs_remove_link
c_func
(paren
op_amp
id|dev-&gt;kobj
comma
l_string|&quot;irm_id&quot;
)paren
suffix:semicolon
id|sysfs_remove_link
c_func
(paren
op_amp
id|dev-&gt;kobj
comma
l_string|&quot;busmgr_id&quot;
)paren
suffix:semicolon
id|sysfs_remove_link
c_func
(paren
op_amp
id|dev-&gt;kobj
comma
l_string|&quot;host_id&quot;
)paren
suffix:semicolon
)brace
DECL|function|nodemgr_update_bus_options
r_static
r_void
id|nodemgr_update_bus_options
c_func
(paren
r_struct
id|node_entry
op_star
id|ne
)paren
(brace
macro_line|#ifdef CONFIG_IEEE1394_VERBOSEDEBUG
r_static
r_const
id|u16
id|mr
(braket
)braket
op_assign
(brace
l_int|4
comma
l_int|64
comma
l_int|1024
comma
l_int|0
)brace
suffix:semicolon
macro_line|#endif
id|quadlet_t
id|busoptions
op_assign
id|be32_to_cpu
c_func
(paren
id|ne-&gt;csr-&gt;bus_info_data
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|ne-&gt;busopt.irmc
op_assign
(paren
id|busoptions
op_rshift
l_int|31
)paren
op_amp
l_int|1
suffix:semicolon
id|ne-&gt;busopt.cmc
op_assign
(paren
id|busoptions
op_rshift
l_int|30
)paren
op_amp
l_int|1
suffix:semicolon
id|ne-&gt;busopt.isc
op_assign
(paren
id|busoptions
op_rshift
l_int|29
)paren
op_amp
l_int|1
suffix:semicolon
id|ne-&gt;busopt.bmc
op_assign
(paren
id|busoptions
op_rshift
l_int|28
)paren
op_amp
l_int|1
suffix:semicolon
id|ne-&gt;busopt.pmc
op_assign
(paren
id|busoptions
op_rshift
l_int|27
)paren
op_amp
l_int|1
suffix:semicolon
id|ne-&gt;busopt.cyc_clk_acc
op_assign
(paren
id|busoptions
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|ne-&gt;busopt.max_rec
op_assign
l_int|1
op_lshift
(paren
(paren
(paren
id|busoptions
op_rshift
l_int|12
)paren
op_amp
l_int|0xf
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|ne-&gt;busopt.max_rom
op_assign
(paren
id|busoptions
op_rshift
l_int|8
)paren
op_amp
l_int|0x3
suffix:semicolon
id|ne-&gt;busopt.generation
op_assign
(paren
id|busoptions
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
suffix:semicolon
id|ne-&gt;busopt.lnkspd
op_assign
id|busoptions
op_amp
l_int|0x7
suffix:semicolon
id|HPSB_VERBOSE
c_func
(paren
l_string|&quot;NodeMgr: raw=0x%08x irmc=%d cmc=%d isc=%d bmc=%d pmc=%d &quot;
l_string|&quot;cyc_clk_acc=%d max_rec=%d max_rom=%d gen=%d lspd=%d&quot;
comma
id|busoptions
comma
id|ne-&gt;busopt.irmc
comma
id|ne-&gt;busopt.cmc
comma
id|ne-&gt;busopt.isc
comma
id|ne-&gt;busopt.bmc
comma
id|ne-&gt;busopt.pmc
comma
id|ne-&gt;busopt.cyc_clk_acc
comma
id|ne-&gt;busopt.max_rec
comma
id|mr
(braket
id|ne-&gt;busopt.max_rom
)braket
comma
id|ne-&gt;busopt.generation
comma
id|ne-&gt;busopt.lnkspd
)paren
suffix:semicolon
)brace
DECL|function|nodemgr_create_node
r_static
r_struct
id|node_entry
op_star
id|nodemgr_create_node
c_func
(paren
id|octlet_t
id|guid
comma
r_struct
id|csr1212_csr
op_star
id|csr
comma
r_struct
id|host_info
op_star
id|hi
comma
id|nodeid_t
id|nodeid
comma
r_int
r_int
id|generation
)paren
(brace
r_struct
id|hpsb_host
op_star
id|host
op_assign
id|hi-&gt;host
suffix:semicolon
r_struct
id|node_entry
op_star
id|ne
suffix:semicolon
id|ne
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|node_entry
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ne
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|ne
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|node_entry
)paren
)paren
suffix:semicolon
id|ne-&gt;tpool
op_assign
op_amp
id|host-&gt;tpool
(braket
id|nodeid
op_amp
id|NODE_MASK
)braket
suffix:semicolon
id|ne-&gt;host
op_assign
id|host
suffix:semicolon
id|ne-&gt;nodeid
op_assign
id|nodeid
suffix:semicolon
id|ne-&gt;generation
op_assign
id|generation
suffix:semicolon
id|ne-&gt;needs_probe
op_assign
l_int|1
suffix:semicolon
id|ne-&gt;guid
op_assign
id|guid
suffix:semicolon
id|ne-&gt;guid_vendor_id
op_assign
(paren
id|guid
op_rshift
l_int|40
)paren
op_amp
l_int|0xffffff
suffix:semicolon
id|ne-&gt;guid_vendor_oui
op_assign
id|nodemgr_find_oui_name
c_func
(paren
id|ne-&gt;guid_vendor_id
)paren
suffix:semicolon
id|ne-&gt;csr
op_assign
id|csr
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|ne-&gt;device
comma
op_amp
id|nodemgr_dev_template_ne
comma
r_sizeof
(paren
id|ne-&gt;device
)paren
)paren
suffix:semicolon
id|ne-&gt;device.parent
op_assign
op_amp
id|host-&gt;device
suffix:semicolon
id|snprintf
c_func
(paren
id|ne-&gt;device.bus_id
comma
id|BUS_ID_SIZE
comma
l_string|&quot;%016Lx&quot;
comma
(paren
r_int
r_int
r_int
)paren
(paren
id|ne-&gt;guid
)paren
)paren
suffix:semicolon
id|ne-&gt;class_dev.dev
op_assign
op_amp
id|ne-&gt;device
suffix:semicolon
id|ne-&gt;class_dev
dot
r_class
op_assign
op_amp
id|nodemgr_ne_class
suffix:semicolon
id|snprintf
c_func
(paren
id|ne-&gt;class_dev.class_id
comma
id|BUS_ID_SIZE
comma
l_string|&quot;%016Lx&quot;
comma
(paren
r_int
r_int
r_int
)paren
(paren
id|ne-&gt;guid
)paren
)paren
suffix:semicolon
id|device_register
c_func
(paren
op_amp
id|ne-&gt;device
)paren
suffix:semicolon
id|class_device_register
c_func
(paren
op_amp
id|ne-&gt;class_dev
)paren
suffix:semicolon
id|get_device
c_func
(paren
op_amp
id|ne-&gt;device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ne-&gt;guid_vendor_oui
)paren
id|device_create_file
c_func
(paren
op_amp
id|ne-&gt;device
comma
op_amp
id|dev_attr_ne_guid_vendor_oui
)paren
suffix:semicolon
id|nodemgr_create_ne_dev_files
c_func
(paren
id|ne
)paren
suffix:semicolon
id|nodemgr_update_bus_options
c_func
(paren
id|ne
)paren
suffix:semicolon
id|HPSB_DEBUG
c_func
(paren
l_string|&quot;%s added: ID:BUS[&quot;
id|NODE_BUS_FMT
l_string|&quot;]  GUID[%016Lx]&quot;
comma
(paren
id|host-&gt;node_id
op_eq
id|nodeid
)paren
ques
c_cond
l_string|&quot;Host&quot;
suffix:colon
l_string|&quot;Node&quot;
comma
id|NODE_BUS_ARGS
c_func
(paren
id|host
comma
id|nodeid
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|guid
)paren
suffix:semicolon
r_return
id|ne
suffix:semicolon
)brace
DECL|function|find_entry_by_guid
r_static
r_struct
id|node_entry
op_star
id|find_entry_by_guid
c_func
(paren
id|u64
id|guid
)paren
(brace
r_struct
r_class
op_star
r_class
op_assign
op_amp
id|nodemgr_ne_class
suffix:semicolon
r_struct
id|class_device
op_star
id|cdev
suffix:semicolon
r_struct
id|node_entry
op_star
id|ne
comma
op_star
id|ret_ne
op_assign
l_int|NULL
suffix:semicolon
id|down_read
c_func
(paren
op_amp
r_class
op_member_access_from_pointer
id|subsys.rwsem
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|cdev
comma
op_amp
r_class
op_member_access_from_pointer
id|children
comma
id|node
)paren
(brace
id|ne
op_assign
id|container_of
c_func
(paren
id|cdev
comma
r_struct
id|node_entry
comma
id|class_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ne-&gt;guid
op_eq
id|guid
)paren
(brace
id|ret_ne
op_assign
id|ne
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|up_read
c_func
(paren
op_amp
r_class
op_member_access_from_pointer
id|subsys.rwsem
)paren
suffix:semicolon
r_return
id|ret_ne
suffix:semicolon
)brace
DECL|function|find_entry_by_nodeid
r_static
r_struct
id|node_entry
op_star
id|find_entry_by_nodeid
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
comma
id|nodeid_t
id|nodeid
)paren
(brace
r_struct
r_class
op_star
r_class
op_assign
op_amp
id|nodemgr_ne_class
suffix:semicolon
r_struct
id|class_device
op_star
id|cdev
suffix:semicolon
r_struct
id|node_entry
op_star
id|ne
comma
op_star
id|ret_ne
op_assign
l_int|NULL
suffix:semicolon
id|down_read
c_func
(paren
op_amp
r_class
op_member_access_from_pointer
id|subsys.rwsem
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|cdev
comma
op_amp
r_class
op_member_access_from_pointer
id|children
comma
id|node
)paren
(brace
id|ne
op_assign
id|container_of
c_func
(paren
id|cdev
comma
r_struct
id|node_entry
comma
id|class_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ne-&gt;host
op_eq
id|host
op_logical_and
id|ne-&gt;nodeid
op_eq
id|nodeid
)paren
(brace
id|ret_ne
op_assign
id|ne
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|up_read
c_func
(paren
op_amp
r_class
op_member_access_from_pointer
id|subsys.rwsem
)paren
suffix:semicolon
r_return
id|ret_ne
suffix:semicolon
)brace
DECL|function|nodemgr_register_device
r_static
r_void
id|nodemgr_register_device
c_func
(paren
r_struct
id|node_entry
op_star
id|ne
comma
r_struct
id|unit_directory
op_star
id|ud
comma
r_struct
id|device
op_star
id|parent
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|ud-&gt;device
comma
op_amp
id|nodemgr_dev_template_ud
comma
r_sizeof
(paren
id|ud-&gt;device
)paren
)paren
suffix:semicolon
id|ud-&gt;device.parent
op_assign
id|parent
suffix:semicolon
id|snprintf
c_func
(paren
id|ud-&gt;device.bus_id
comma
id|BUS_ID_SIZE
comma
l_string|&quot;%s-%u&quot;
comma
id|ne-&gt;device.bus_id
comma
id|ud-&gt;id
)paren
suffix:semicolon
id|ud-&gt;class_dev.dev
op_assign
op_amp
id|ud-&gt;device
suffix:semicolon
id|ud-&gt;class_dev
dot
r_class
op_assign
op_amp
id|nodemgr_ud_class
suffix:semicolon
id|snprintf
c_func
(paren
id|ud-&gt;class_dev.class_id
comma
id|BUS_ID_SIZE
comma
l_string|&quot;%s-%u&quot;
comma
id|ne-&gt;device.bus_id
comma
id|ud-&gt;id
)paren
suffix:semicolon
id|device_register
c_func
(paren
op_amp
id|ud-&gt;device
)paren
suffix:semicolon
id|class_device_register
c_func
(paren
op_amp
id|ud-&gt;class_dev
)paren
suffix:semicolon
id|get_device
c_func
(paren
op_amp
id|ud-&gt;device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;vendor_oui
)paren
id|device_create_file
c_func
(paren
op_amp
id|ud-&gt;device
comma
op_amp
id|dev_attr_ud_vendor_oui
)paren
suffix:semicolon
id|nodemgr_create_ud_dev_files
c_func
(paren
id|ud
)paren
suffix:semicolon
)brace
multiline_comment|/* This implementation currently only scans the config rom and its&n; * immediate unit directories looking for software_id and&n; * software_version entries, in order to get driver autoloading working. */
DECL|function|nodemgr_process_unit_directory
r_static
r_struct
id|unit_directory
op_star
id|nodemgr_process_unit_directory
(paren
r_struct
id|host_info
op_star
id|hi
comma
r_struct
id|node_entry
op_star
id|ne
comma
r_struct
id|csr1212_keyval
op_star
id|ud_kv
comma
r_int
r_int
op_star
id|id
comma
r_struct
id|unit_directory
op_star
id|parent
)paren
(brace
r_struct
id|unit_directory
op_star
id|ud
suffix:semicolon
r_struct
id|unit_directory
op_star
id|ud_child
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|csr1212_dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|csr1212_keyval
op_star
id|kv
suffix:semicolon
id|u8
id|last_key_id
op_assign
l_int|0
suffix:semicolon
id|ud
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|unit_directory
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ud
)paren
r_goto
id|unit_directory_error
suffix:semicolon
id|memset
(paren
id|ud
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|unit_directory
)paren
)paren
suffix:semicolon
id|ud-&gt;ne
op_assign
id|ne
suffix:semicolon
id|ud-&gt;ignore_driver
op_assign
id|ignore_drivers
suffix:semicolon
id|ud-&gt;address
op_assign
id|ud_kv-&gt;offset
op_plus
id|CSR1212_CONFIG_ROM_SPACE_BASE
suffix:semicolon
id|ud-&gt;ud_kv
op_assign
id|ud_kv
suffix:semicolon
id|ud-&gt;id
op_assign
(paren
op_star
id|id
)paren
op_increment
suffix:semicolon
id|csr1212_for_each_dir_entry
c_func
(paren
id|ne-&gt;csr
comma
id|kv
comma
id|ud_kv
comma
id|dentry
)paren
(brace
r_switch
c_cond
(paren
id|kv-&gt;key.id
)paren
(brace
r_case
id|CSR1212_KV_ID_VENDOR
suffix:colon
r_if
c_cond
(paren
id|kv-&gt;key.type
op_eq
id|CSR1212_KV_TYPE_IMMEDIATE
)paren
(brace
id|ud-&gt;vendor_id
op_assign
id|kv-&gt;value.immediate
suffix:semicolon
id|ud-&gt;flags
op_or_assign
id|UNIT_DIRECTORY_VENDOR_ID
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;vendor_id
)paren
id|ud-&gt;vendor_oui
op_assign
id|nodemgr_find_oui_name
c_func
(paren
id|ud-&gt;vendor_id
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CSR1212_KV_ID_MODEL
suffix:colon
id|ud-&gt;model_id
op_assign
id|kv-&gt;value.immediate
suffix:semicolon
id|ud-&gt;flags
op_or_assign
id|UNIT_DIRECTORY_MODEL_ID
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR1212_KV_ID_SPECIFIER_ID
suffix:colon
id|ud-&gt;specifier_id
op_assign
id|kv-&gt;value.immediate
suffix:semicolon
id|ud-&gt;flags
op_or_assign
id|UNIT_DIRECTORY_SPECIFIER_ID
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR1212_KV_ID_VERSION
suffix:colon
id|ud-&gt;version
op_assign
id|kv-&gt;value.immediate
suffix:semicolon
id|ud-&gt;flags
op_or_assign
id|UNIT_DIRECTORY_VERSION
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR1212_KV_ID_DESCRIPTOR
suffix:colon
r_if
c_cond
(paren
id|kv-&gt;key.type
op_eq
id|CSR1212_KV_TYPE_LEAF
op_logical_and
id|CSR1212_DESCRIPTOR_LEAF_TYPE
c_func
(paren
id|kv
)paren
op_eq
l_int|0
op_logical_and
id|CSR1212_DESCRIPTOR_LEAF_SPECIFIER_ID
c_func
(paren
id|kv
)paren
op_eq
l_int|0
op_logical_and
id|CSR1212_TEXTUAL_DESCRIPTOR_LEAF_WIDTH
c_func
(paren
id|kv
)paren
op_eq
l_int|0
op_logical_and
id|CSR1212_TEXTUAL_DESCRIPTOR_LEAF_CHAR_SET
c_func
(paren
id|kv
)paren
op_eq
l_int|0
op_logical_and
id|CSR1212_TEXTUAL_DESCRIPTOR_LEAF_LANGUAGE
c_func
(paren
id|kv
)paren
op_eq
l_int|0
)paren
(brace
r_switch
c_cond
(paren
id|last_key_id
)paren
(brace
r_case
id|CSR1212_KV_ID_VENDOR
suffix:colon
id|ud-&gt;vendor_name_kv
op_assign
id|kv
suffix:semicolon
id|csr1212_keep_keyval
c_func
(paren
id|kv
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR1212_KV_ID_MODEL
suffix:colon
id|ud-&gt;model_name_kv
op_assign
id|kv
suffix:semicolon
id|csr1212_keep_keyval
c_func
(paren
id|kv
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* else if (kv-&gt;key.type == CSR1212_KV_TYPE_DIRECTORY) ... */
r_break
suffix:semicolon
r_case
id|CSR1212_KV_ID_DEPENDENT_INFO
suffix:colon
r_if
c_cond
(paren
id|kv-&gt;key.type
op_eq
id|CSR1212_KV_TYPE_DIRECTORY
)paren
(brace
multiline_comment|/* This should really be done in SBP2 as this is&n;&t;&t;&t;&t; * doing SBP2 specific parsing.&n;&t;&t;&t;&t; * DRD&gt; Hmm.. that would add a lot of udev bits to sbp2.c, and&n;&t;&t;&t;&t; * really it is just subdirectory handling, not necessarily&n;&t;&t;&t;&t; * specific to SBP2 although that is only known application at&n;&t;&t;&t;&t; * this time.&n;&t;&t;&t;&t; */
multiline_comment|/* first register the parent unit */
id|ud-&gt;flags
op_or_assign
id|UNIT_DIRECTORY_HAS_LUN_DIRECTORY
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;device.bus
op_ne
op_amp
id|ieee1394_bus_type
)paren
id|nodemgr_register_device
c_func
(paren
id|ne
comma
id|ud
comma
op_amp
id|ne-&gt;device
)paren
suffix:semicolon
multiline_comment|/* process the child unit */
id|ud_child
op_assign
id|nodemgr_process_unit_directory
c_func
(paren
id|hi
comma
id|ne
comma
id|kv
comma
id|id
comma
id|ud
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ud_child
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
multiline_comment|/* inherit unspecified values so hotplug picks it up */
r_if
c_cond
(paren
(paren
id|ud-&gt;flags
op_amp
id|UNIT_DIRECTORY_MODEL_ID
)paren
op_logical_and
op_logical_neg
(paren
id|ud_child-&gt;flags
op_amp
id|UNIT_DIRECTORY_MODEL_ID
)paren
)paren
(brace
id|ud_child-&gt;flags
op_or_assign
id|UNIT_DIRECTORY_MODEL_ID
suffix:semicolon
id|ud_child-&gt;model_id
op_assign
id|ud-&gt;model_id
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ud-&gt;flags
op_amp
id|UNIT_DIRECTORY_SPECIFIER_ID
)paren
op_logical_and
op_logical_neg
(paren
id|ud_child-&gt;flags
op_amp
id|UNIT_DIRECTORY_SPECIFIER_ID
)paren
)paren
(brace
id|ud_child-&gt;flags
op_or_assign
id|UNIT_DIRECTORY_SPECIFIER_ID
suffix:semicolon
id|ud_child-&gt;specifier_id
op_assign
id|ud-&gt;specifier_id
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ud-&gt;flags
op_amp
id|UNIT_DIRECTORY_VERSION
)paren
op_logical_and
op_logical_neg
(paren
id|ud_child-&gt;flags
op_amp
id|UNIT_DIRECTORY_VERSION
)paren
)paren
(brace
id|ud_child-&gt;flags
op_or_assign
id|UNIT_DIRECTORY_VERSION
suffix:semicolon
id|ud_child-&gt;version
op_assign
id|ud-&gt;version
suffix:semicolon
)brace
multiline_comment|/* register the child unit */
id|ud_child-&gt;flags
op_or_assign
id|UNIT_DIRECTORY_LUN_DIRECTORY
suffix:semicolon
id|nodemgr_register_device
c_func
(paren
id|ne
comma
id|ud_child
comma
op_amp
id|ud-&gt;device
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|last_key_id
op_assign
id|kv-&gt;key.id
suffix:semicolon
)brace
multiline_comment|/* do not process child units here and only if not already registered */
r_if
c_cond
(paren
op_logical_neg
id|parent
op_logical_and
id|ud-&gt;device.bus
op_ne
op_amp
id|ieee1394_bus_type
)paren
id|nodemgr_register_device
c_func
(paren
id|ne
comma
id|ud
comma
op_amp
id|ne-&gt;device
)paren
suffix:semicolon
r_return
id|ud
suffix:semicolon
id|unit_directory_error
suffix:colon
r_if
c_cond
(paren
id|ud
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|ud
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|nodemgr_process_root_directory
r_static
r_void
id|nodemgr_process_root_directory
c_func
(paren
r_struct
id|host_info
op_star
id|hi
comma
r_struct
id|node_entry
op_star
id|ne
)paren
(brace
r_int
r_int
id|ud_id
op_assign
l_int|0
suffix:semicolon
r_struct
id|csr1212_dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|csr1212_keyval
op_star
id|kv
suffix:semicolon
id|u8
id|last_key_id
op_assign
l_int|0
suffix:semicolon
id|ne-&gt;needs_probe
op_assign
l_int|0
suffix:semicolon
id|csr1212_for_each_dir_entry
c_func
(paren
id|ne-&gt;csr
comma
id|kv
comma
id|ne-&gt;csr-&gt;root_kv
comma
id|dentry
)paren
(brace
r_switch
c_cond
(paren
id|kv-&gt;key.id
)paren
(brace
r_case
id|CSR1212_KV_ID_VENDOR
suffix:colon
id|ne-&gt;vendor_id
op_assign
id|kv-&gt;value.immediate
suffix:semicolon
r_if
c_cond
(paren
id|ne-&gt;vendor_id
)paren
id|ne-&gt;vendor_oui
op_assign
id|nodemgr_find_oui_name
c_func
(paren
id|ne-&gt;vendor_id
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR1212_KV_ID_NODE_CAPABILITIES
suffix:colon
id|ne-&gt;capabilities
op_assign
id|kv-&gt;value.immediate
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR1212_KV_ID_UNIT
suffix:colon
id|nodemgr_process_unit_directory
c_func
(paren
id|hi
comma
id|ne
comma
id|kv
comma
op_amp
id|ud_id
comma
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR1212_KV_ID_DESCRIPTOR
suffix:colon
r_if
c_cond
(paren
id|last_key_id
op_eq
id|CSR1212_KV_ID_VENDOR
)paren
(brace
r_if
c_cond
(paren
id|kv-&gt;key.type
op_eq
id|CSR1212_KV_TYPE_LEAF
op_logical_and
id|CSR1212_DESCRIPTOR_LEAF_TYPE
c_func
(paren
id|kv
)paren
op_eq
l_int|0
op_logical_and
id|CSR1212_DESCRIPTOR_LEAF_SPECIFIER_ID
c_func
(paren
id|kv
)paren
op_eq
l_int|0
op_logical_and
id|CSR1212_TEXTUAL_DESCRIPTOR_LEAF_WIDTH
c_func
(paren
id|kv
)paren
op_eq
l_int|0
op_logical_and
id|CSR1212_TEXTUAL_DESCRIPTOR_LEAF_CHAR_SET
c_func
(paren
id|kv
)paren
op_eq
l_int|0
op_logical_and
id|CSR1212_TEXTUAL_DESCRIPTOR_LEAF_LANGUAGE
c_func
(paren
id|kv
)paren
op_eq
l_int|0
)paren
(brace
id|ne-&gt;vendor_name_kv
op_assign
id|kv
suffix:semicolon
id|csr1212_keep_keyval
c_func
(paren
id|kv
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
id|last_key_id
op_assign
id|kv-&gt;key.id
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ne-&gt;vendor_oui
)paren
id|device_create_file
c_func
(paren
op_amp
id|ne-&gt;device
comma
op_amp
id|dev_attr_ne_vendor_oui
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ne-&gt;vendor_name_kv
)paren
id|device_create_file
c_func
(paren
op_amp
id|ne-&gt;device
comma
op_amp
id|dev_attr_ne_vendor_name_kv
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_HOTPLUG
DECL|function|nodemgr_hotplug
r_static
r_int
id|nodemgr_hotplug
c_func
(paren
r_struct
id|class_device
op_star
id|cdev
comma
r_char
op_star
op_star
id|envp
comma
r_int
id|num_envp
comma
r_char
op_star
id|buffer
comma
r_int
id|buffer_size
)paren
(brace
r_struct
id|unit_directory
op_star
id|ud
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|length
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cdev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|ud
op_assign
id|container_of
c_func
(paren
id|cdev
comma
r_struct
id|unit_directory
comma
id|class_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;ne-&gt;in_limbo
op_logical_or
id|ud-&gt;ignore_driver
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
DECL|macro|PUT_ENVP
mdefine_line|#define PUT_ENVP(fmt,val) &t;&t;&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;int printed;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;envp[i++] = buffer;&t;&t;&t;&t;&t;&bslash;&n;&t;printed = snprintf(buffer, buffer_size - length,&t;&bslash;&n;&t;&t;&t;   fmt, val);&t;&t;&t;&t;&bslash;&n;&t;if ((buffer_size - (length+printed) &lt;= 0) || (i &gt;= num_envp))&t;&bslash;&n;&t;&t;return -ENOMEM;&t;&t;&t;&t;&t;&bslash;&n;&t;length += printed+1;&t;&t;&t;&t;&t;&bslash;&n;&t;buffer += printed+1;&t;&t;&t;&t;&t;&bslash;&n;} while (0)
id|PUT_ENVP
c_func
(paren
l_string|&quot;VENDOR_ID=%06x&quot;
comma
id|ud-&gt;vendor_id
)paren
suffix:semicolon
id|PUT_ENVP
c_func
(paren
l_string|&quot;MODEL_ID=%06x&quot;
comma
id|ud-&gt;model_id
)paren
suffix:semicolon
id|PUT_ENVP
c_func
(paren
l_string|&quot;GUID=%016Lx&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ud-&gt;ne-&gt;guid
)paren
suffix:semicolon
id|PUT_ENVP
c_func
(paren
l_string|&quot;SPECIFIER_ID=%06x&quot;
comma
id|ud-&gt;specifier_id
)paren
suffix:semicolon
id|PUT_ENVP
c_func
(paren
l_string|&quot;VERSION=%06x&quot;
comma
id|ud-&gt;version
)paren
suffix:semicolon
DECL|macro|PUT_ENVP
macro_line|#undef PUT_ENVP
id|envp
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#else
DECL|function|nodemgr_hotplug
r_static
r_int
id|nodemgr_hotplug
c_func
(paren
r_struct
id|class_device
op_star
id|cdev
comma
r_char
op_star
op_star
id|envp
comma
r_int
id|num_envp
comma
r_char
op_star
id|buffer
comma
r_int
id|buffer_size
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_HOTPLUG */
DECL|function|hpsb_register_protocol
r_int
id|hpsb_register_protocol
c_func
(paren
r_struct
id|hpsb_protocol_driver
op_star
id|driver
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/* This will cause a probe for devices */
id|ret
op_assign
id|driver_register
c_func
(paren
op_amp
id|driver-&gt;driver
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|nodemgr_create_drv_files
c_func
(paren
id|driver
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|hpsb_unregister_protocol
r_void
id|hpsb_unregister_protocol
c_func
(paren
r_struct
id|hpsb_protocol_driver
op_star
id|driver
)paren
(brace
id|nodemgr_remove_drv_files
c_func
(paren
id|driver
)paren
suffix:semicolon
multiline_comment|/* This will subsequently disconnect all devices that our driver&n;&t; * is attached to. */
id|driver_unregister
c_func
(paren
op_amp
id|driver-&gt;driver
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function updates nodes that were present on the bus before the&n; * reset and still are after the reset.  The nodeid and the config rom&n; * may have changed, and the drivers managing this device must be&n; * informed that this device just went through a bus reset, to allow&n; * the to take whatever actions required.&n; */
DECL|function|nodemgr_update_node
r_static
r_void
id|nodemgr_update_node
c_func
(paren
r_struct
id|node_entry
op_star
id|ne
comma
r_struct
id|csr1212_csr
op_star
id|csr
comma
r_struct
id|host_info
op_star
id|hi
comma
id|nodeid_t
id|nodeid
comma
r_int
r_int
id|generation
)paren
(brace
r_if
c_cond
(paren
id|ne-&gt;nodeid
op_ne
id|nodeid
)paren
(brace
id|HPSB_DEBUG
c_func
(paren
l_string|&quot;Node changed: &quot;
id|NODE_BUS_FMT
l_string|&quot; -&gt; &quot;
id|NODE_BUS_FMT
comma
id|NODE_BUS_ARGS
c_func
(paren
id|ne-&gt;host
comma
id|ne-&gt;nodeid
)paren
comma
id|NODE_BUS_ARGS
c_func
(paren
id|ne-&gt;host
comma
id|nodeid
)paren
)paren
suffix:semicolon
id|ne-&gt;nodeid
op_assign
id|nodeid
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ne-&gt;busopt.generation
op_ne
(paren
(paren
id|be32_to_cpu
c_func
(paren
id|csr-&gt;bus_info_data
(braket
l_int|2
)braket
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
)paren
)paren
(brace
id|kfree
c_func
(paren
id|ne-&gt;csr
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
id|csr1212_destroy_csr
c_func
(paren
id|ne-&gt;csr
)paren
suffix:semicolon
id|ne-&gt;csr
op_assign
id|csr
suffix:semicolon
multiline_comment|/* If the node&squot;s configrom generation has changed, we&n;&t;&t; * unregister all the unit directories. */
id|nodemgr_remove_uds
c_func
(paren
id|ne
)paren
suffix:semicolon
id|nodemgr_update_bus_options
c_func
(paren
id|ne
)paren
suffix:semicolon
multiline_comment|/* Mark the node as new, so it gets re-probed */
id|ne-&gt;needs_probe
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ne-&gt;in_limbo
)paren
id|nodemgr_resume_ne
c_func
(paren
id|ne
)paren
suffix:semicolon
multiline_comment|/* Mark the node current */
id|ne-&gt;generation
op_assign
id|generation
suffix:semicolon
)brace
DECL|function|nodemgr_node_scan_one
r_static
r_void
id|nodemgr_node_scan_one
c_func
(paren
r_struct
id|host_info
op_star
id|hi
comma
id|nodeid_t
id|nodeid
comma
r_int
id|generation
)paren
(brace
r_struct
id|hpsb_host
op_star
id|host
op_assign
id|hi-&gt;host
suffix:semicolon
r_struct
id|node_entry
op_star
id|ne
suffix:semicolon
id|octlet_t
id|guid
suffix:semicolon
r_struct
id|csr1212_csr
op_star
id|csr
suffix:semicolon
r_struct
id|nodemgr_csr_info
op_star
id|ci
suffix:semicolon
id|ci
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|nodemgr_csr_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ci
)paren
r_return
suffix:semicolon
id|ci-&gt;host
op_assign
id|host
suffix:semicolon
id|ci-&gt;nodeid
op_assign
id|nodeid
suffix:semicolon
id|ci-&gt;generation
op_assign
id|generation
suffix:semicolon
multiline_comment|/* We need to detect when the ConfigROM&squot;s generation has changed,&n;&t; * so we only update the node&squot;s info when it needs to be.  */
id|csr
op_assign
id|csr1212_create_csr
c_func
(paren
op_amp
id|nodemgr_csr_ops
comma
l_int|5
op_star
r_sizeof
(paren
id|quadlet_t
)paren
comma
id|ci
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|csr
op_logical_or
id|csr1212_parse_csr
c_func
(paren
id|csr
)paren
op_ne
id|CSR1212_SUCCESS
)paren
(brace
id|HPSB_ERR
c_func
(paren
l_string|&quot;Error parsing configrom for node &quot;
id|NODE_BUS_FMT
comma
id|NODE_BUS_ARGS
c_func
(paren
id|host
comma
id|nodeid
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|csr
)paren
id|csr1212_destroy_csr
c_func
(paren
id|csr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ci
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|csr-&gt;bus_info_data
(braket
l_int|1
)braket
op_ne
id|IEEE1394_BUSID_MAGIC
)paren
(brace
multiline_comment|/* This isn&squot;t a 1394 device, but we let it slide. There&n;&t;&t; * was a report of a device with broken firmware which&n;&t;&t; * reported &squot;2394&squot; instead of &squot;1394&squot;, which is obviously a&n;&t;&t; * mistake. One would hope that a non-1394 device never&n;&t;&t; * gets connected to Firewire bus. If someone does, we&n;&t;&t; * shouldn&squot;t be held responsible, so we&squot;ll allow it with a&n;&t;&t; * warning.  */
id|HPSB_WARN
c_func
(paren
l_string|&quot;Node &quot;
id|NODE_BUS_FMT
l_string|&quot; has invalid busID magic [0x%08x]&quot;
comma
id|NODE_BUS_ARGS
c_func
(paren
id|host
comma
id|nodeid
)paren
comma
id|csr-&gt;bus_info_data
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|guid
op_assign
(paren
(paren
id|u64
)paren
id|be32_to_cpu
c_func
(paren
id|csr-&gt;bus_info_data
(braket
l_int|3
)braket
)paren
op_lshift
l_int|32
)paren
op_or
id|be32_to_cpu
c_func
(paren
id|csr-&gt;bus_info_data
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|ne
op_assign
id|find_entry_by_guid
c_func
(paren
id|guid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ne
op_logical_and
id|ne-&gt;host
op_ne
id|host
op_logical_and
id|ne-&gt;in_limbo
)paren
(brace
multiline_comment|/* Must have moved this device from one host to another */
id|nodemgr_remove_ne
c_func
(paren
id|ne
)paren
suffix:semicolon
id|ne
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ne
)paren
id|nodemgr_create_node
c_func
(paren
id|guid
comma
id|csr
comma
id|hi
comma
id|nodeid
comma
id|generation
)paren
suffix:semicolon
r_else
id|nodemgr_update_node
c_func
(paren
id|ne
comma
id|csr
comma
id|hi
comma
id|nodeid
comma
id|generation
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|nodemgr_node_scan
r_static
r_void
id|nodemgr_node_scan
c_func
(paren
r_struct
id|host_info
op_star
id|hi
comma
r_int
id|generation
)paren
(brace
r_int
id|count
suffix:semicolon
r_struct
id|hpsb_host
op_star
id|host
op_assign
id|hi-&gt;host
suffix:semicolon
r_struct
id|selfid
op_star
id|sid
op_assign
(paren
r_struct
id|selfid
op_star
)paren
id|host-&gt;topology_map
suffix:semicolon
id|nodeid_t
id|nodeid
op_assign
id|LOCAL_BUS
suffix:semicolon
multiline_comment|/* Scan each node on the bus */
r_for
c_loop
(paren
id|count
op_assign
id|host-&gt;selfid_count
suffix:semicolon
id|count
suffix:semicolon
id|count
op_decrement
comma
id|sid
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sid-&gt;extended
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sid-&gt;link_active
)paren
(brace
id|nodeid
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|nodemgr_node_scan_one
c_func
(paren
id|hi
comma
id|nodeid
op_increment
comma
id|generation
)paren
suffix:semicolon
)brace
)brace
DECL|function|nodemgr_suspend_ne
r_static
r_void
id|nodemgr_suspend_ne
c_func
(paren
r_struct
id|node_entry
op_star
id|ne
)paren
(brace
r_struct
id|class_device
op_star
id|cdev
suffix:semicolon
r_struct
id|unit_directory
op_star
id|ud
suffix:semicolon
id|HPSB_DEBUG
c_func
(paren
l_string|&quot;Node suspended: ID:BUS[&quot;
id|NODE_BUS_FMT
l_string|&quot;]  GUID[%016Lx]&quot;
comma
id|NODE_BUS_ARGS
c_func
(paren
id|ne-&gt;host
comma
id|ne-&gt;nodeid
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|ne-&gt;guid
)paren
suffix:semicolon
id|ne-&gt;in_limbo
op_assign
l_int|1
suffix:semicolon
id|device_create_file
c_func
(paren
op_amp
id|ne-&gt;device
comma
op_amp
id|dev_attr_ne_in_limbo
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|ne-&gt;device.bus-&gt;subsys.rwsem
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|cdev
comma
op_amp
id|nodemgr_ud_class.children
comma
id|node
)paren
(brace
id|ud
op_assign
id|container_of
c_func
(paren
id|cdev
comma
r_struct
id|unit_directory
comma
id|class_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;ne
op_ne
id|ne
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;device.driver
op_logical_and
(paren
op_logical_neg
id|ud-&gt;device.driver-&gt;suspend
op_logical_or
id|ud-&gt;device.driver
op_member_access_from_pointer
id|suspend
c_func
(paren
op_amp
id|ud-&gt;device
comma
l_int|0
comma
l_int|0
)paren
)paren
)paren
id|device_release_driver
c_func
(paren
op_amp
id|ud-&gt;device
)paren
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|ne-&gt;device.bus-&gt;subsys.rwsem
)paren
suffix:semicolon
)brace
DECL|function|nodemgr_resume_ne
r_static
r_void
id|nodemgr_resume_ne
c_func
(paren
r_struct
id|node_entry
op_star
id|ne
)paren
(brace
r_struct
id|class_device
op_star
id|cdev
suffix:semicolon
r_struct
id|unit_directory
op_star
id|ud
suffix:semicolon
id|ne-&gt;in_limbo
op_assign
l_int|0
suffix:semicolon
id|device_remove_file
c_func
(paren
op_amp
id|ne-&gt;device
comma
op_amp
id|dev_attr_ne_in_limbo
)paren
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|ne-&gt;device.bus-&gt;subsys.rwsem
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|cdev
comma
op_amp
id|nodemgr_ud_class.children
comma
id|node
)paren
(brace
id|ud
op_assign
id|container_of
c_func
(paren
id|cdev
comma
r_struct
id|unit_directory
comma
id|class_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;ne
op_ne
id|ne
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;device.driver
op_logical_and
id|ud-&gt;device.driver-&gt;resume
)paren
id|ud-&gt;device.driver
op_member_access_from_pointer
id|resume
c_func
(paren
op_amp
id|ud-&gt;device
comma
l_int|0
)paren
suffix:semicolon
)brace
id|up_read
c_func
(paren
op_amp
id|ne-&gt;device.bus-&gt;subsys.rwsem
)paren
suffix:semicolon
id|HPSB_DEBUG
c_func
(paren
l_string|&quot;Node resumed: ID:BUS[&quot;
id|NODE_BUS_FMT
l_string|&quot;]  GUID[%016Lx]&quot;
comma
id|NODE_BUS_ARGS
c_func
(paren
id|ne-&gt;host
comma
id|ne-&gt;nodeid
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|ne-&gt;guid
)paren
suffix:semicolon
)brace
DECL|function|nodemgr_update_pdrv
r_static
r_void
id|nodemgr_update_pdrv
c_func
(paren
r_struct
id|node_entry
op_star
id|ne
)paren
(brace
r_struct
id|unit_directory
op_star
id|ud
suffix:semicolon
r_struct
id|hpsb_protocol_driver
op_star
id|pdrv
suffix:semicolon
r_struct
r_class
op_star
r_class
op_assign
op_amp
id|nodemgr_ud_class
suffix:semicolon
r_struct
id|class_device
op_star
id|cdev
suffix:semicolon
id|down_read
c_func
(paren
op_amp
r_class
op_member_access_from_pointer
id|subsys.rwsem
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|cdev
comma
op_amp
r_class
op_member_access_from_pointer
id|children
comma
id|node
)paren
(brace
id|ud
op_assign
id|container_of
c_func
(paren
id|cdev
comma
r_struct
id|unit_directory
comma
id|class_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ud-&gt;ne
op_ne
id|ne
op_logical_or
op_logical_neg
id|ud-&gt;device.driver
)paren
r_continue
suffix:semicolon
id|pdrv
op_assign
id|container_of
c_func
(paren
id|ud-&gt;device.driver
comma
r_struct
id|hpsb_protocol_driver
comma
id|driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pdrv-&gt;update
op_logical_and
id|pdrv
op_member_access_from_pointer
id|update
c_func
(paren
id|ud
)paren
)paren
(brace
id|down_write
c_func
(paren
op_amp
id|ud-&gt;device.bus-&gt;subsys.rwsem
)paren
suffix:semicolon
id|device_release_driver
c_func
(paren
op_amp
id|ud-&gt;device
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|ud-&gt;device.bus-&gt;subsys.rwsem
)paren
suffix:semicolon
)brace
)brace
id|up_read
c_func
(paren
op_amp
r_class
op_member_access_from_pointer
id|subsys.rwsem
)paren
suffix:semicolon
)brace
DECL|function|nodemgr_probe_ne
r_static
r_void
id|nodemgr_probe_ne
c_func
(paren
r_struct
id|host_info
op_star
id|hi
comma
r_struct
id|node_entry
op_star
id|ne
comma
r_int
id|generation
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|ne-&gt;host
op_ne
id|hi-&gt;host
op_logical_or
id|ne-&gt;in_limbo
)paren
r_return
suffix:semicolon
id|dev
op_assign
id|get_device
c_func
(paren
op_amp
id|ne-&gt;device
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
suffix:semicolon
multiline_comment|/* If &quot;needs_probe&quot;, then this is either a new or changed node we&n;&t; * rescan totally. If the generation matches for an existing node&n;&t; * (one that existed prior to the bus reset) we send update calls&n;&t; * down to the drivers. Otherwise, this is a dead node and we&n;&t; * suspend it. */
r_if
c_cond
(paren
id|ne-&gt;needs_probe
)paren
id|nodemgr_process_root_directory
c_func
(paren
id|hi
comma
id|ne
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ne-&gt;generation
op_eq
id|generation
)paren
id|nodemgr_update_pdrv
c_func
(paren
id|ne
)paren
suffix:semicolon
r_else
id|nodemgr_suspend_ne
c_func
(paren
id|ne
)paren
suffix:semicolon
id|put_device
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|function|nodemgr_node_probe
r_static
r_void
id|nodemgr_node_probe
c_func
(paren
r_struct
id|host_info
op_star
id|hi
comma
r_int
id|generation
)paren
(brace
r_struct
id|hpsb_host
op_star
id|host
op_assign
id|hi-&gt;host
suffix:semicolon
r_struct
r_class
op_star
r_class
op_assign
op_amp
id|nodemgr_ne_class
suffix:semicolon
r_struct
id|class_device
op_star
id|cdev
suffix:semicolon
multiline_comment|/* Do some processing of the nodes we&squot;ve probed. This pulls them&n;&t; * into the sysfs layer if needed, and can result in processing of&n;&t; * unit-directories, or just updating the node and it&squot;s&n;&t; * unit-directories. */
id|down_read
c_func
(paren
op_amp
r_class
op_member_access_from_pointer
id|subsys.rwsem
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|cdev
comma
op_amp
r_class
op_member_access_from_pointer
id|children
comma
id|node
)paren
id|nodemgr_probe_ne
c_func
(paren
id|hi
comma
id|container_of
c_func
(paren
id|cdev
comma
r_struct
id|node_entry
comma
id|class_dev
)paren
comma
id|generation
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
r_class
op_member_access_from_pointer
id|subsys.rwsem
)paren
suffix:semicolon
multiline_comment|/* If we had a bus reset while we were scanning the bus, it is&n;&t; * possible that we did not probe all nodes.  In that case, we&n;&t; * skip the clean up for now, since we could remove nodes that&n;&t; * were still on the bus.  The bus reset increased hi-&gt;reset_sem,&n;&t; * so there&squot;s a bus scan pending which will do the clean up&n;&t; * eventually.&n;&t; *&n;&t; * Now let&squot;s tell the bus to rescan our devices. This may seem&n;&t; * like overhead, but the driver-model core will only scan a&n;&t; * device for a driver when either the device is added, or when a&n;&t; * new driver is added. A bus reset is a good reason to rescan&n;&t; * devices that were there before.  For example, an sbp2 device&n;&t; * may become available for login, if the host that held it was&n;&t; * just removed.  */
r_if
c_cond
(paren
id|generation
op_eq
id|get_hpsb_generation
c_func
(paren
id|host
)paren
)paren
id|bus_rescan_devices
c_func
(paren
op_amp
id|ieee1394_bus_type
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Because we are a 1394a-2000 compliant IRM, we need to inform all the other&n; * nodes of the broadcast channel.  (Really we&squot;re only setting the validity&n; * bit). Other IRM responsibilities go in here as well. */
DECL|function|nodemgr_do_irm_duties
r_static
r_int
id|nodemgr_do_irm_duties
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
comma
r_int
id|cycles
)paren
(brace
id|quadlet_t
id|bc
suffix:semicolon
multiline_comment|/* if irm_id == -1 then there is no IRM on this bus */
r_if
c_cond
(paren
op_logical_neg
id|host-&gt;is_irm
op_logical_or
id|host-&gt;irm_id
op_eq
(paren
id|nodeid_t
)paren
op_minus
l_int|1
)paren
r_return
l_int|1
suffix:semicolon
id|host-&gt;csr.broadcast_channel
op_or_assign
l_int|0x40000000
suffix:semicolon
multiline_comment|/* set validity bit */
id|bc
op_assign
id|cpu_to_be32
c_func
(paren
id|host-&gt;csr.broadcast_channel
)paren
suffix:semicolon
id|hpsb_write
c_func
(paren
id|host
comma
id|LOCAL_BUS
op_or
id|ALL_NODES
comma
id|get_hpsb_generation
c_func
(paren
id|host
)paren
comma
(paren
id|CSR_REGISTER_BASE
op_or
id|CSR_BROADCAST_CHANNEL
)paren
comma
op_amp
id|bc
comma
r_sizeof
(paren
id|quadlet_t
)paren
)paren
suffix:semicolon
multiline_comment|/* If there is no bus manager then we should set the root node&squot;s&n;&t; * force_root bit to promote bus stability per the 1394&n;&t; * spec. (8.4.2.6) */
r_if
c_cond
(paren
id|host-&gt;busmgr_id
op_eq
l_int|0xffff
op_logical_and
id|host-&gt;node_count
OG
l_int|1
)paren
(brace
id|u16
id|root_node
op_assign
id|host-&gt;node_count
op_minus
l_int|1
suffix:semicolon
r_struct
id|node_entry
op_star
id|ne
op_assign
id|find_entry_by_nodeid
c_func
(paren
id|host
comma
id|root_node
op_or
id|LOCAL_BUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ne
op_logical_and
id|ne-&gt;busopt.cmc
)paren
id|hpsb_send_phy_config
c_func
(paren
id|host
comma
id|root_node
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_else
(brace
id|HPSB_DEBUG
c_func
(paren
l_string|&quot;The root node is not cycle master capable; &quot;
l_string|&quot;selecting a new root node and resetting...&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cycles
op_ge
l_int|5
)paren
(brace
multiline_comment|/* Oh screw it! Just leave the bus as it is */
id|HPSB_DEBUG
c_func
(paren
l_string|&quot;Stopping reset loop for IRM sanity&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|hpsb_send_phy_config
c_func
(paren
id|host
comma
id|NODEID_TO_NODE
c_func
(paren
id|host-&gt;node_id
)paren
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|hpsb_reset_bus
c_func
(paren
id|host
comma
id|LONG_RESET_FORCE_ROOT
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* We need to ensure that if we are not the IRM, that the IRM node is capable of&n; * everything we can do, otherwise issue a bus reset and try to become the IRM&n; * ourselves. */
DECL|function|nodemgr_check_irm_capability
r_static
r_int
id|nodemgr_check_irm_capability
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
comma
r_int
id|cycles
)paren
(brace
id|quadlet_t
id|bc
suffix:semicolon
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;is_irm
)paren
r_return
l_int|1
suffix:semicolon
id|status
op_assign
id|hpsb_read
c_func
(paren
id|host
comma
id|LOCAL_BUS
op_or
(paren
id|host-&gt;irm_id
)paren
comma
id|get_hpsb_generation
c_func
(paren
id|host
)paren
comma
(paren
id|CSR_REGISTER_BASE
op_or
id|CSR_BROADCAST_CHANNEL
)paren
comma
op_amp
id|bc
comma
r_sizeof
(paren
id|quadlet_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
op_logical_or
op_logical_neg
(paren
id|be32_to_cpu
c_func
(paren
id|bc
)paren
op_amp
l_int|0x80000000
)paren
)paren
(brace
multiline_comment|/* The current irm node does not have a valid BROADCAST_CHANNEL&n;&t;&t; * register and we do, so reset the bus with force_root set */
id|HPSB_DEBUG
c_func
(paren
l_string|&quot;Current remote IRM is not 1394a-2000 compliant, resetting...&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cycles
op_ge
l_int|5
)paren
(brace
multiline_comment|/* Oh screw it! Just leave the bus as it is */
id|HPSB_DEBUG
c_func
(paren
l_string|&quot;Stopping reset loop for IRM sanity&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|hpsb_send_phy_config
c_func
(paren
id|host
comma
id|NODEID_TO_NODE
c_func
(paren
id|host-&gt;node_id
)paren
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|hpsb_reset_bus
c_func
(paren
id|host
comma
id|LONG_RESET_FORCE_ROOT
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|nodemgr_host_thread
r_static
r_int
id|nodemgr_host_thread
c_func
(paren
r_void
op_star
id|__hi
)paren
(brace
r_struct
id|host_info
op_star
id|hi
op_assign
(paren
r_struct
id|host_info
op_star
)paren
id|__hi
suffix:semicolon
r_struct
id|hpsb_host
op_star
id|host
op_assign
id|hi-&gt;host
suffix:semicolon
r_int
id|reset_cycles
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No userlevel access needed */
id|daemonize
c_func
(paren
id|hi-&gt;daemon_name
)paren
suffix:semicolon
multiline_comment|/* Setup our device-model entries */
id|nodemgr_create_host_dev_files
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/* Sit and wait for a signal to probe the nodes on the bus. This&n;&t; * happens when we get a bus reset. */
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
r_int
id|generation
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|hi-&gt;reset_sem
)paren
op_logical_or
id|down_interruptible
c_func
(paren
op_amp
id|nodemgr_serialize
)paren
)paren
(brace
r_if
c_cond
(paren
id|try_to_freeze
c_func
(paren
id|PF_FREEZE
)paren
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NodeMgr: received unexpected signal?!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hi-&gt;kill_me
)paren
(brace
id|up
c_func
(paren
op_amp
id|nodemgr_serialize
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Pause for 1/4 second in 1/16 second intervals,&n;&t;&t; * to make sure things settle down. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msleep_interruptible
c_func
(paren
l_int|63
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|nodemgr_serialize
)paren
suffix:semicolon
r_goto
id|caught_signal
suffix:semicolon
)brace
multiline_comment|/* Now get the generation in which the node ID&squot;s we collect&n;&t;&t;&t; * are valid.  During the bus scan we will use this generation&n;&t;&t;&t; * for the read transactions, so that if another reset occurs&n;&t;&t;&t; * during the scan the transactions will fail instead of&n;&t;&t;&t; * returning bogus data. */
id|generation
op_assign
id|get_hpsb_generation
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/* If we get a reset before we are done waiting, then&n;&t;&t;&t; * start the the waiting over again */
r_while
c_loop
(paren
op_logical_neg
id|down_trylock
c_func
(paren
op_amp
id|hi-&gt;reset_sem
)paren
)paren
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Check the kill_me again */
r_if
c_cond
(paren
id|hi-&gt;kill_me
)paren
(brace
id|up
c_func
(paren
op_amp
id|nodemgr_serialize
)paren
suffix:semicolon
r_goto
id|caught_signal
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|nodemgr_check_irm_capability
c_func
(paren
id|host
comma
id|reset_cycles
)paren
)paren
(brace
id|reset_cycles
op_increment
suffix:semicolon
id|up
c_func
(paren
op_amp
id|nodemgr_serialize
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Scan our nodes to get the bus options and create node&n;&t;&t; * entries. This does not do the sysfs stuff, since that&n;&t;&t; * would trigger hotplug callbacks and such, which is a&n;&t;&t; * bad idea at this point. */
id|nodemgr_node_scan
c_func
(paren
id|hi
comma
id|generation
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nodemgr_do_irm_duties
c_func
(paren
id|host
comma
id|reset_cycles
)paren
)paren
(brace
id|reset_cycles
op_increment
suffix:semicolon
id|up
c_func
(paren
op_amp
id|nodemgr_serialize
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|reset_cycles
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This actually does the full probe, with sysfs&n;&t;&t; * registration. */
id|nodemgr_node_probe
c_func
(paren
id|hi
comma
id|generation
)paren
suffix:semicolon
multiline_comment|/* Update some of our sysfs symlinks */
id|nodemgr_update_host_dev_links
c_func
(paren
id|host
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|nodemgr_serialize
)paren
suffix:semicolon
)brace
id|caught_signal
suffix:colon
id|HPSB_VERBOSE
c_func
(paren
l_string|&quot;NodeMgr: Exiting thread&quot;
)paren
suffix:semicolon
id|complete_and_exit
c_func
(paren
op_amp
id|hi-&gt;exited
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|nodemgr_for_each_host
r_int
id|nodemgr_for_each_host
c_func
(paren
r_void
op_star
id|__data
comma
r_int
(paren
op_star
id|cb
)paren
(paren
r_struct
id|hpsb_host
op_star
comma
r_void
op_star
)paren
)paren
(brace
r_struct
r_class
op_star
r_class
op_assign
op_amp
id|hpsb_host_class
suffix:semicolon
r_struct
id|class_device
op_star
id|cdev
suffix:semicolon
r_struct
id|hpsb_host
op_star
id|host
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|down_read
c_func
(paren
op_amp
r_class
op_member_access_from_pointer
id|subsys.rwsem
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|cdev
comma
op_amp
r_class
op_member_access_from_pointer
id|children
comma
id|node
)paren
(brace
id|host
op_assign
id|container_of
c_func
(paren
id|cdev
comma
r_struct
id|hpsb_host
comma
id|class_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|cb
c_func
(paren
id|host
comma
id|__data
)paren
)paren
)paren
r_break
suffix:semicolon
)brace
id|up_read
c_func
(paren
op_amp
r_class
op_member_access_from_pointer
id|subsys.rwsem
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* The following four convenience functions use a struct node_entry&n; * for addressing a node on the bus.  They are intended for use by any&n; * process context, not just the nodemgr thread, so we need to be a&n; * little careful when reading out the node ID and generation.  The&n; * thing that can go wrong is that we get the node ID, then a bus&n; * reset occurs, and then we read the generation.  The node ID is&n; * possibly invalid, but the generation is current, and we end up&n; * sending a packet to a the wrong node.&n; *&n; * The solution is to make sure we read the generation first, so that&n; * if a reset occurs in the process, we end up with a stale generation&n; * and the transactions will fail instead of silently using wrong node&n; * ID&squot;s.&n; */
DECL|function|hpsb_node_fill_packet
r_void
id|hpsb_node_fill_packet
c_func
(paren
r_struct
id|node_entry
op_star
id|ne
comma
r_struct
id|hpsb_packet
op_star
id|pkt
)paren
(brace
id|pkt-&gt;host
op_assign
id|ne-&gt;host
suffix:semicolon
id|pkt-&gt;generation
op_assign
id|ne-&gt;generation
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|pkt-&gt;node_id
op_assign
id|ne-&gt;nodeid
suffix:semicolon
)brace
DECL|function|hpsb_node_write
r_int
id|hpsb_node_write
c_func
(paren
r_struct
id|node_entry
op_star
id|ne
comma
id|u64
id|addr
comma
id|quadlet_t
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
r_int
r_int
id|generation
op_assign
id|ne-&gt;generation
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
r_return
id|hpsb_write
c_func
(paren
id|ne-&gt;host
comma
id|ne-&gt;nodeid
comma
id|generation
comma
id|addr
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
)brace
DECL|function|nodemgr_add_host
r_static
r_void
id|nodemgr_add_host
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
(brace
r_struct
id|host_info
op_star
id|hi
suffix:semicolon
id|hi
op_assign
id|hpsb_create_hostinfo
c_func
(paren
op_amp
id|nodemgr_highlevel
comma
id|host
comma
r_sizeof
(paren
op_star
id|hi
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hi
)paren
(brace
id|HPSB_ERR
(paren
l_string|&quot;NodeMgr: out of memory in add host&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|hi-&gt;host
op_assign
id|host
suffix:semicolon
id|init_completion
c_func
(paren
op_amp
id|hi-&gt;exited
)paren
suffix:semicolon
id|sema_init
c_func
(paren
op_amp
id|hi-&gt;reset_sem
comma
l_int|0
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|hi-&gt;daemon_name
comma
l_string|&quot;knodemgrd_%d&quot;
comma
id|host-&gt;id
)paren
suffix:semicolon
id|hi-&gt;pid
op_assign
id|kernel_thread
c_func
(paren
id|nodemgr_host_thread
comma
id|hi
comma
id|CLONE_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hi-&gt;pid
OL
l_int|0
)paren
(brace
id|HPSB_ERR
(paren
l_string|&quot;NodeMgr: failed to start %s thread for %s&quot;
comma
id|hi-&gt;daemon_name
comma
id|host-&gt;driver-&gt;name
)paren
suffix:semicolon
id|hpsb_destroy_hostinfo
c_func
(paren
op_amp
id|nodemgr_highlevel
comma
id|host
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|nodemgr_host_reset
r_static
r_void
id|nodemgr_host_reset
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
(brace
r_struct
id|host_info
op_star
id|hi
op_assign
id|hpsb_get_hostinfo
c_func
(paren
op_amp
id|nodemgr_highlevel
comma
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hi
op_ne
l_int|NULL
)paren
(brace
id|HPSB_VERBOSE
c_func
(paren
l_string|&quot;NodeMgr: Processing host reset for %s&quot;
comma
id|hi-&gt;daemon_name
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|hi-&gt;reset_sem
)paren
suffix:semicolon
)brace
r_else
id|HPSB_ERR
(paren
l_string|&quot;NodeMgr: could not process reset of unused host&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|nodemgr_remove_host
r_static
r_void
id|nodemgr_remove_host
c_func
(paren
r_struct
id|hpsb_host
op_star
id|host
)paren
(brace
r_struct
id|host_info
op_star
id|hi
op_assign
id|hpsb_get_hostinfo
c_func
(paren
op_amp
id|nodemgr_highlevel
comma
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hi
)paren
(brace
r_if
c_cond
(paren
id|hi-&gt;pid
op_ge
l_int|0
)paren
(brace
id|hi-&gt;kill_me
op_assign
l_int|1
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|hi-&gt;reset_sem
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|hi-&gt;exited
)paren
suffix:semicolon
id|nodemgr_remove_host_dev
c_func
(paren
op_amp
id|host-&gt;device
)paren
suffix:semicolon
)brace
)brace
r_else
id|HPSB_ERR
c_func
(paren
l_string|&quot;NodeMgr: host %s does not exist, cannot remove&quot;
comma
id|host-&gt;driver-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|variable|nodemgr_highlevel
r_static
r_struct
id|hpsb_highlevel
id|nodemgr_highlevel
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;Node manager&quot;
comma
dot
id|add_host
op_assign
id|nodemgr_add_host
comma
dot
id|host_reset
op_assign
id|nodemgr_host_reset
comma
dot
id|remove_host
op_assign
id|nodemgr_remove_host
comma
)brace
suffix:semicolon
DECL|function|init_ieee1394_nodemgr
r_int
id|init_ieee1394_nodemgr
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|class_register
c_func
(paren
op_amp
id|nodemgr_ne_class
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
id|ret
op_assign
id|class_register
c_func
(paren
op_amp
id|nodemgr_ud_class
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|class_unregister
c_func
(paren
op_amp
id|nodemgr_ne_class
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|hpsb_register_highlevel
c_func
(paren
op_amp
id|nodemgr_highlevel
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_ieee1394_nodemgr
r_void
id|cleanup_ieee1394_nodemgr
c_func
(paren
r_void
)paren
(brace
id|hpsb_unregister_highlevel
c_func
(paren
op_amp
id|nodemgr_highlevel
)paren
suffix:semicolon
id|class_unregister
c_func
(paren
op_amp
id|nodemgr_ud_class
)paren
suffix:semicolon
id|class_unregister
c_func
(paren
op_amp
id|nodemgr_ne_class
)paren
suffix:semicolon
)brace
eof
