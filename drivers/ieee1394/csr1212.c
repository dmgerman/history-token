multiline_comment|/*&n; * csr1212.c -- IEEE 1212 Control and Status Register support for Linux&n; *&n; * Copyright (C) 2003 Francois Retief &lt;fgretief@sun.ac.za&gt;&n; *                    Steve Kinneberg &lt;kinnebergsteve@acmsystems.com&gt;&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions are met:&n; *&n; *    1. Redistributions of source code must retain the above copyright notice,&n; *       this list of conditions and the following disclaimer.&n; *    2. Redistributions in binary form must reproduce the above copyright&n; *       notice, this list of conditions and the following disclaimer in the&n; *       documentation and/or other materials provided with the distribution.&n; *    3. The name of the author may not be used to endorse or promote products&n; *       derived from this software without specific prior written permission.&n; *&n; * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS&squot;&squot; AND ANY EXPRESS OR IMPLIED&n; * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&n; * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO&n; * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,&n; * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,&n; * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;&n; * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,&n; * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR&n; * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF&n; * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; */
multiline_comment|/* TODO List:&n; * - Verify interface consistency: i.e., public functions that take a size&n; *   parameter expect size to be in bytes.&n; * - Convenience functions for reading a block of data from a given offset.&n; */
macro_line|#ifndef __KERNEL__
macro_line|#include &lt;string.h&gt;
macro_line|#endif
macro_line|#include &quot;csr1212.h&quot;
multiline_comment|/* Permitted key type for each key id */
DECL|macro|__I
mdefine_line|#define __I (1 &lt;&lt; CSR1212_KV_TYPE_IMMEDIATE)
DECL|macro|__C
mdefine_line|#define __C (1 &lt;&lt; CSR1212_KV_TYPE_CSR_OFFSET)
DECL|macro|__D
mdefine_line|#define __D (1 &lt;&lt; CSR1212_KV_TYPE_DIRECTORY)
DECL|macro|__L
mdefine_line|#define __L (1 &lt;&lt; CSR1212_KV_TYPE_LEAF)
DECL|variable|csr1212_key_id_type_map
r_static
r_const
id|u_int8_t
id|csr1212_key_id_type_map
(braket
l_int|0x30
)braket
op_assign
(brace
l_int|0
comma
multiline_comment|/* Reserved */
id|__D
op_or
id|__L
comma
multiline_comment|/* Descriptor */
id|__I
op_or
id|__D
op_or
id|__L
comma
multiline_comment|/* Bus_Dependent_Info */
id|__I
op_or
id|__D
op_or
id|__L
comma
multiline_comment|/* Vendor */
id|__I
comma
multiline_comment|/* Hardware_Version */
l_int|0
comma
l_int|0
comma
multiline_comment|/* Reserved */
id|__D
op_or
id|__L
comma
multiline_comment|/* Module */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* Reserved */
id|__I
comma
multiline_comment|/* Node_Capabilities */
id|__L
comma
multiline_comment|/* EUI_64 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* Reserved */
id|__D
comma
multiline_comment|/* Unit */
id|__I
comma
multiline_comment|/* Specifier_ID */
id|__I
comma
multiline_comment|/* Version */
id|__I
op_or
id|__C
op_or
id|__D
op_or
id|__L
comma
multiline_comment|/* Dependent_Info */
id|__L
comma
multiline_comment|/* Unit_Location */
l_int|0
comma
multiline_comment|/* Reserved */
id|__I
comma
multiline_comment|/* Model */
id|__D
comma
multiline_comment|/* Instance */
id|__L
comma
multiline_comment|/* Keyword */
id|__D
comma
multiline_comment|/* Feature */
id|__L
comma
multiline_comment|/* Extended_ROM */
id|__I
comma
multiline_comment|/* Extended_Key_Specifier_ID */
id|__I
comma
multiline_comment|/* Extended_Key */
id|__I
op_or
id|__C
op_or
id|__D
op_or
id|__L
comma
multiline_comment|/* Extended_Data */
id|__L
comma
multiline_comment|/* Modifiable_Descriptor */
id|__I
comma
multiline_comment|/* Directory_ID */
id|__I
comma
multiline_comment|/* Revision */
)brace
suffix:semicolon
DECL|macro|__I
macro_line|#undef __I
DECL|macro|__C
macro_line|#undef __C
DECL|macro|__D
macro_line|#undef __D
DECL|macro|__L
macro_line|#undef __L
DECL|macro|quads_to_bytes
mdefine_line|#define quads_to_bytes(_q) ((_q) * sizeof(u_int32_t))
DECL|macro|bytes_to_quads
mdefine_line|#define bytes_to_quads(_b) (((_b) + sizeof(u_int32_t) - 1) / sizeof(u_int32_t))
DECL|function|free_keyval
r_static
r_inline
r_void
id|free_keyval
c_func
(paren
r_struct
id|csr1212_keyval
op_star
id|kv
)paren
(brace
r_if
c_cond
(paren
id|kv-&gt;key.type
op_eq
id|CSR1212_KV_TYPE_LEAF
)paren
id|CSR1212_FREE
c_func
(paren
id|kv-&gt;value.leaf.data
)paren
suffix:semicolon
id|CSR1212_FREE
c_func
(paren
id|kv
)paren
suffix:semicolon
)brace
DECL|function|csr1212_crc16
r_static
id|u_int16_t
id|csr1212_crc16
c_func
(paren
r_const
id|u_int32_t
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
r_int
id|shift
suffix:semicolon
id|u_int32_t
id|data
suffix:semicolon
id|u_int16_t
id|sum
comma
id|crc
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|length
suffix:semicolon
id|length
op_decrement
)paren
(brace
id|data
op_assign
id|CSR1212_BE32_TO_CPU
c_func
(paren
op_star
id|buffer
)paren
suffix:semicolon
id|buffer
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|shift
op_assign
l_int|28
suffix:semicolon
id|shift
op_ge
l_int|0
suffix:semicolon
id|shift
op_sub_assign
l_int|4
)paren
(brace
id|sum
op_assign
(paren
(paren
id|crc
op_rshift
l_int|12
)paren
op_xor
(paren
id|data
op_rshift
id|shift
)paren
)paren
op_amp
l_int|0xf
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_lshift
l_int|4
)paren
op_xor
(paren
id|sum
op_lshift
l_int|12
)paren
op_xor
(paren
id|sum
op_lshift
l_int|5
)paren
op_xor
(paren
id|sum
)paren
suffix:semicolon
)brace
id|crc
op_and_assign
l_int|0xffff
suffix:semicolon
)brace
r_return
id|CSR1212_CPU_TO_BE16
c_func
(paren
id|crc
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* Microsoft computes the CRC with the bytes in reverse order.  Therefore we&n; * have a special version of the CRC algorithm to account for their buggy&n; * software. */
r_static
id|u_int16_t
id|csr1212_msft_crc16
c_func
(paren
r_const
id|u_int32_t
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
r_int
id|shift
suffix:semicolon
id|u_int32_t
id|data
suffix:semicolon
id|u_int16_t
id|sum
comma
id|crc
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|length
suffix:semicolon
id|length
op_decrement
)paren
(brace
id|data
op_assign
id|CSR1212_LE32_TO_CPU
c_func
(paren
op_star
id|buffer
)paren
suffix:semicolon
id|buffer
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|shift
op_assign
l_int|28
suffix:semicolon
id|shift
op_ge
l_int|0
suffix:semicolon
id|shift
op_sub_assign
l_int|4
)paren
(brace
id|sum
op_assign
(paren
(paren
id|crc
op_rshift
l_int|12
)paren
op_xor
(paren
id|data
op_rshift
id|shift
)paren
)paren
op_amp
l_int|0xf
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_lshift
l_int|4
)paren
op_xor
(paren
id|sum
op_lshift
l_int|12
)paren
op_xor
(paren
id|sum
op_lshift
l_int|5
)paren
op_xor
(paren
id|sum
)paren
suffix:semicolon
)brace
id|crc
op_and_assign
l_int|0xffff
suffix:semicolon
)brace
r_return
id|CSR1212_CPU_TO_BE16
c_func
(paren
id|crc
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|csr1212_find_keyval
r_static
r_inline
r_struct
id|csr1212_dentry
op_star
id|csr1212_find_keyval
c_func
(paren
r_struct
id|csr1212_keyval
op_star
id|dir
comma
r_struct
id|csr1212_keyval
op_star
id|kv
)paren
(brace
r_struct
id|csr1212_dentry
op_star
id|pos
suffix:semicolon
r_for
c_loop
(paren
id|pos
op_assign
id|dir-&gt;value.directory.dentries_head
suffix:semicolon
id|pos
op_ne
l_int|NULL
suffix:semicolon
id|pos
op_assign
id|pos-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|pos-&gt;kv
op_eq
id|kv
)paren
r_return
id|pos
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|csr1212_find_keyval_offset
r_static
r_inline
r_struct
id|csr1212_keyval
op_star
id|csr1212_find_keyval_offset
c_func
(paren
r_struct
id|csr1212_keyval
op_star
id|kv_list
comma
id|u_int32_t
id|offset
)paren
(brace
r_struct
id|csr1212_keyval
op_star
id|kv
suffix:semicolon
r_for
c_loop
(paren
id|kv
op_assign
id|kv_list
suffix:semicolon
id|kv
op_ne
l_int|NULL
suffix:semicolon
id|kv
op_assign
id|kv-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|kv-&gt;offset
op_eq
id|offset
)paren
r_return
id|kv
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Creation Routines */
DECL|function|csr1212_create_csr
r_struct
id|csr1212_csr
op_star
id|csr1212_create_csr
c_func
(paren
r_struct
id|csr1212_bus_ops
op_star
id|ops
comma
r_int
id|bus_info_size
comma
r_void
op_star
r_private
)paren
(brace
r_struct
id|csr1212_csr
op_star
id|csr
suffix:semicolon
id|csr
op_assign
id|CSR1212_MALLOC
c_func
(paren
r_sizeof
(paren
op_star
id|csr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|csr
)paren
r_return
l_int|NULL
suffix:semicolon
id|csr-&gt;cache_head
op_assign
id|csr1212_rom_cache_malloc
c_func
(paren
id|CSR1212_CONFIG_ROM_SPACE_OFFSET
comma
id|CSR1212_CONFIG_ROM_SPACE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|csr-&gt;cache_head
)paren
(brace
id|CSR1212_FREE
c_func
(paren
id|csr
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* The keyval key id is not used for the root node, but a valid key id&n;         * that can be used for a directory needs to be passed to&n;         * csr1212_new_directory(). */
id|csr-&gt;root_kv
op_assign
id|csr1212_new_directory
c_func
(paren
id|CSR1212_KV_ID_VENDOR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|csr-&gt;root_kv
)paren
(brace
id|CSR1212_FREE
c_func
(paren
id|csr-&gt;cache_head
)paren
suffix:semicolon
id|CSR1212_FREE
c_func
(paren
id|csr
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|csr-&gt;bus_info_data
op_assign
id|csr-&gt;cache_head-&gt;data
suffix:semicolon
id|csr-&gt;bus_info_len
op_assign
id|bus_info_size
suffix:semicolon
id|csr-&gt;crc_len
op_assign
id|bus_info_size
suffix:semicolon
id|csr-&gt;ops
op_assign
id|ops
suffix:semicolon
id|csr
op_member_access_from_pointer
r_private
op_assign
r_private
suffix:semicolon
id|csr-&gt;cache_tail
op_assign
id|csr-&gt;cache_head
suffix:semicolon
r_return
id|csr
suffix:semicolon
)brace
DECL|function|csr1212_init_local_csr
r_void
id|csr1212_init_local_csr
c_func
(paren
r_struct
id|csr1212_csr
op_star
id|csr
comma
r_const
id|u_int32_t
op_star
id|bus_info_data
comma
r_int
id|max_rom
)paren
(brace
r_static
r_const
r_int
id|mr_map
(braket
)braket
op_assign
(brace
l_int|4
comma
l_int|64
comma
l_int|1024
comma
l_int|0
)brace
suffix:semicolon
id|csr-&gt;max_rom
op_assign
id|mr_map
(braket
id|max_rom
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|csr-&gt;bus_info_data
comma
id|bus_info_data
comma
id|csr-&gt;bus_info_len
)paren
suffix:semicolon
)brace
DECL|function|csr1212_new_keyval
r_static
r_struct
id|csr1212_keyval
op_star
id|csr1212_new_keyval
c_func
(paren
id|u_int8_t
id|type
comma
id|u_int8_t
id|key
)paren
(brace
r_struct
id|csr1212_keyval
op_star
id|kv
suffix:semicolon
r_if
c_cond
(paren
id|key
OL
l_int|0x30
op_logical_and
(paren
(paren
id|csr1212_key_id_type_map
(braket
id|key
)braket
op_amp
(paren
l_int|1
op_lshift
id|type
)paren
)paren
op_eq
l_int|0
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|kv
op_assign
id|CSR1212_MALLOC
c_func
(paren
r_sizeof
(paren
op_star
id|kv
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kv
)paren
r_return
l_int|NULL
suffix:semicolon
id|kv-&gt;key.type
op_assign
id|type
suffix:semicolon
id|kv-&gt;key.id
op_assign
id|key
suffix:semicolon
id|kv-&gt;associate
op_assign
l_int|NULL
suffix:semicolon
id|kv-&gt;refcnt
op_assign
l_int|1
suffix:semicolon
id|kv-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|kv-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|kv-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|kv-&gt;valid
op_assign
l_int|0
suffix:semicolon
r_return
id|kv
suffix:semicolon
)brace
DECL|function|csr1212_new_immediate
r_struct
id|csr1212_keyval
op_star
id|csr1212_new_immediate
c_func
(paren
id|u_int8_t
id|key
comma
id|u_int32_t
id|value
)paren
(brace
r_struct
id|csr1212_keyval
op_star
id|kv
op_assign
id|csr1212_new_keyval
c_func
(paren
id|CSR1212_KV_TYPE_IMMEDIATE
comma
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kv
)paren
r_return
l_int|NULL
suffix:semicolon
id|kv-&gt;value.immediate
op_assign
id|value
suffix:semicolon
id|kv-&gt;valid
op_assign
l_int|1
suffix:semicolon
r_return
id|kv
suffix:semicolon
)brace
DECL|function|csr1212_new_leaf
r_struct
id|csr1212_keyval
op_star
id|csr1212_new_leaf
c_func
(paren
id|u_int8_t
id|key
comma
r_const
r_void
op_star
id|data
comma
r_int
id|data_len
)paren
(brace
r_struct
id|csr1212_keyval
op_star
id|kv
op_assign
id|csr1212_new_keyval
c_func
(paren
id|CSR1212_KV_TYPE_LEAF
comma
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kv
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|data_len
OG
l_int|0
)paren
(brace
id|kv-&gt;value.leaf.data
op_assign
id|CSR1212_MALLOC
c_func
(paren
id|data_len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kv-&gt;value.leaf.data
)paren
(brace
id|CSR1212_FREE
c_func
(paren
id|kv
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|data
)paren
id|memcpy
c_func
(paren
id|kv-&gt;value.leaf.data
comma
id|data
comma
id|data_len
)paren
suffix:semicolon
)brace
r_else
(brace
id|kv-&gt;value.leaf.data
op_assign
l_int|NULL
suffix:semicolon
)brace
id|kv-&gt;value.leaf.len
op_assign
id|bytes_to_quads
c_func
(paren
id|data_len
)paren
suffix:semicolon
id|kv-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|kv-&gt;valid
op_assign
l_int|1
suffix:semicolon
r_return
id|kv
suffix:semicolon
)brace
DECL|function|csr1212_new_csr_offset
r_struct
id|csr1212_keyval
op_star
id|csr1212_new_csr_offset
c_func
(paren
id|u_int8_t
id|key
comma
id|u_int32_t
id|csr_offset
)paren
(brace
r_struct
id|csr1212_keyval
op_star
id|kv
op_assign
id|csr1212_new_keyval
c_func
(paren
id|CSR1212_KV_TYPE_CSR_OFFSET
comma
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kv
)paren
r_return
l_int|NULL
suffix:semicolon
id|kv-&gt;value.csr_offset
op_assign
id|csr_offset
suffix:semicolon
id|kv-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|kv-&gt;valid
op_assign
l_int|1
suffix:semicolon
r_return
id|kv
suffix:semicolon
)brace
DECL|function|csr1212_new_directory
r_struct
id|csr1212_keyval
op_star
id|csr1212_new_directory
c_func
(paren
id|u_int8_t
id|key
)paren
(brace
r_struct
id|csr1212_keyval
op_star
id|kv
op_assign
id|csr1212_new_keyval
c_func
(paren
id|CSR1212_KV_TYPE_DIRECTORY
comma
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kv
)paren
r_return
l_int|NULL
suffix:semicolon
id|kv-&gt;value.directory.len
op_assign
l_int|0
suffix:semicolon
id|kv-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|kv-&gt;value.directory.dentries_head
op_assign
l_int|NULL
suffix:semicolon
id|kv-&gt;value.directory.dentries_tail
op_assign
l_int|NULL
suffix:semicolon
id|kv-&gt;valid
op_assign
l_int|1
suffix:semicolon
r_return
id|kv
suffix:semicolon
)brace
DECL|function|csr1212_associate_keyval
r_int
id|csr1212_associate_keyval
c_func
(paren
r_struct
id|csr1212_keyval
op_star
id|kv
comma
r_struct
id|csr1212_keyval
op_star
id|associate
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|kv
op_logical_or
op_logical_neg
id|associate
)paren
r_return
id|CSR1212_EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|kv-&gt;key.id
op_eq
id|CSR1212_KV_ID_DESCRIPTOR
op_logical_or
(paren
id|associate-&gt;key.id
op_ne
id|CSR1212_KV_ID_DESCRIPTOR
op_logical_and
id|associate-&gt;key.id
op_ne
id|CSR1212_KV_ID_DEPENDENT_INFO
op_logical_and
id|associate-&gt;key.id
op_ne
id|CSR1212_KV_ID_EXTENDED_KEY
op_logical_and
id|associate-&gt;key.id
op_ne
id|CSR1212_KV_ID_EXTENDED_DATA
op_logical_and
id|associate-&gt;key.id
OL
l_int|0x30
)paren
)paren
r_return
id|CSR1212_EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|kv-&gt;key.id
op_eq
id|CSR1212_KV_ID_EXTENDED_KEY_SPECIFIER_ID
op_logical_and
id|associate-&gt;key.id
op_ne
id|CSR1212_KV_ID_EXTENDED_KEY
)paren
r_return
id|CSR1212_EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|kv-&gt;key.id
op_eq
id|CSR1212_KV_ID_EXTENDED_KEY
op_logical_and
id|associate-&gt;key.id
op_ne
id|CSR1212_KV_ID_EXTENDED_DATA
)paren
r_return
id|CSR1212_EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|associate-&gt;key.id
op_eq
id|CSR1212_KV_ID_EXTENDED_KEY
op_logical_and
id|kv-&gt;key.id
op_ne
id|CSR1212_KV_ID_EXTENDED_KEY_SPECIFIER_ID
)paren
r_return
id|CSR1212_EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|associate-&gt;key.id
op_eq
id|CSR1212_KV_ID_EXTENDED_DATA
op_logical_and
id|kv-&gt;key.id
op_ne
id|CSR1212_KV_ID_EXTENDED_KEY
)paren
r_return
id|CSR1212_EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|kv-&gt;associate
)paren
id|csr1212_release_keyval
c_func
(paren
id|kv-&gt;associate
)paren
suffix:semicolon
id|associate-&gt;refcnt
op_increment
suffix:semicolon
id|kv-&gt;associate
op_assign
id|associate
suffix:semicolon
r_return
id|CSR1212_SUCCESS
suffix:semicolon
)brace
DECL|function|csr1212_attach_keyval_to_directory
r_int
id|csr1212_attach_keyval_to_directory
c_func
(paren
r_struct
id|csr1212_keyval
op_star
id|dir
comma
r_struct
id|csr1212_keyval
op_star
id|kv
)paren
(brace
r_struct
id|csr1212_dentry
op_star
id|dentry
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kv
op_logical_or
op_logical_neg
id|dir
op_logical_or
id|dir-&gt;key.type
op_ne
id|CSR1212_KV_TYPE_DIRECTORY
)paren
r_return
id|CSR1212_EINVAL
suffix:semicolon
id|dentry
op_assign
id|CSR1212_MALLOC
c_func
(paren
r_sizeof
(paren
op_star
id|dentry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
r_return
id|CSR1212_ENOMEM
suffix:semicolon
id|dentry-&gt;kv
op_assign
id|kv
suffix:semicolon
id|kv-&gt;refcnt
op_increment
suffix:semicolon
id|dentry-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|dentry-&gt;prev
op_assign
id|dir-&gt;value.directory.dentries_tail
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;value.directory.dentries_head
)paren
id|dir-&gt;value.directory.dentries_head
op_assign
id|dentry
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;value.directory.dentries_tail
)paren
id|dir-&gt;value.directory.dentries_tail-&gt;next
op_assign
id|dentry
suffix:semicolon
id|dir-&gt;value.directory.dentries_tail
op_assign
id|dentry
suffix:semicolon
r_return
id|CSR1212_SUCCESS
suffix:semicolon
)brace
DECL|function|csr1212_new_extended_immediate
r_struct
id|csr1212_keyval
op_star
id|csr1212_new_extended_immediate
c_func
(paren
id|u_int32_t
id|spec
comma
id|u_int32_t
id|key
comma
id|u_int32_t
id|value
)paren
(brace
r_struct
id|csr1212_keyval
op_star
id|kvs
comma
op_star
id|kvk
comma
op_star
id|kvv
suffix:semicolon
id|kvs
op_assign
id|csr1212_new_immediate
c_func
(paren
id|CSR1212_KV_ID_EXTENDED_KEY_SPECIFIER_ID
comma
id|spec
)paren
suffix:semicolon
id|kvk
op_assign
id|csr1212_new_immediate
c_func
(paren
id|CSR1212_KV_ID_EXTENDED_KEY
comma
id|key
)paren
suffix:semicolon
id|kvv
op_assign
id|csr1212_new_immediate
c_func
(paren
id|CSR1212_KV_ID_EXTENDED_DATA
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kvs
op_logical_or
op_logical_neg
id|kvk
op_logical_or
op_logical_neg
id|kvv
)paren
(brace
r_if
c_cond
(paren
id|kvs
)paren
id|free_keyval
c_func
(paren
id|kvs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kvk
)paren
id|free_keyval
c_func
(paren
id|kvk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kvv
)paren
id|free_keyval
c_func
(paren
id|kvv
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t keep a local reference to the extended key or value. */
id|kvk-&gt;refcnt
op_assign
l_int|0
suffix:semicolon
id|kvv-&gt;refcnt
op_assign
l_int|0
suffix:semicolon
id|csr1212_associate_keyval
c_func
(paren
id|kvk
comma
id|kvv
)paren
suffix:semicolon
id|csr1212_associate_keyval
c_func
(paren
id|kvs
comma
id|kvk
)paren
suffix:semicolon
r_return
id|kvs
suffix:semicolon
)brace
DECL|function|csr1212_new_extended_leaf
r_struct
id|csr1212_keyval
op_star
id|csr1212_new_extended_leaf
c_func
(paren
id|u_int32_t
id|spec
comma
id|u_int32_t
id|key
comma
r_const
r_void
op_star
id|data
comma
r_int
id|data_len
)paren
(brace
r_struct
id|csr1212_keyval
op_star
id|kvs
comma
op_star
id|kvk
comma
op_star
id|kvv
suffix:semicolon
id|kvs
op_assign
id|csr1212_new_immediate
c_func
(paren
id|CSR1212_KV_ID_EXTENDED_KEY_SPECIFIER_ID
comma
id|spec
)paren
suffix:semicolon
id|kvk
op_assign
id|csr1212_new_immediate
c_func
(paren
id|CSR1212_KV_ID_EXTENDED_KEY
comma
id|key
)paren
suffix:semicolon
id|kvv
op_assign
id|csr1212_new_leaf
c_func
(paren
id|CSR1212_KV_ID_EXTENDED_DATA
comma
id|data
comma
id|data_len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kvs
op_logical_or
op_logical_neg
id|kvk
op_logical_or
op_logical_neg
id|kvv
)paren
(brace
r_if
c_cond
(paren
id|kvs
)paren
id|free_keyval
c_func
(paren
id|kvs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kvk
)paren
id|free_keyval
c_func
(paren
id|kvk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kvv
)paren
id|free_keyval
c_func
(paren
id|kvv
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t keep a local reference to the extended key or value. */
id|kvk-&gt;refcnt
op_assign
l_int|0
suffix:semicolon
id|kvv-&gt;refcnt
op_assign
l_int|0
suffix:semicolon
id|csr1212_associate_keyval
c_func
(paren
id|kvk
comma
id|kvv
)paren
suffix:semicolon
id|csr1212_associate_keyval
c_func
(paren
id|kvs
comma
id|kvk
)paren
suffix:semicolon
r_return
id|kvs
suffix:semicolon
)brace
DECL|function|csr1212_new_descriptor_leaf
r_struct
id|csr1212_keyval
op_star
id|csr1212_new_descriptor_leaf
c_func
(paren
id|u_int8_t
id|dtype
comma
id|u_int32_t
id|specifier_id
comma
r_const
r_void
op_star
id|data
comma
r_int
id|data_len
)paren
(brace
r_struct
id|csr1212_keyval
op_star
id|kv
suffix:semicolon
id|kv
op_assign
id|csr1212_new_leaf
c_func
(paren
id|CSR1212_KV_ID_DESCRIPTOR
comma
l_int|NULL
comma
id|data_len
op_plus
id|CSR1212_DESCRIPTOR_LEAF_OVERHEAD
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kv
)paren
r_return
l_int|NULL
suffix:semicolon
id|CSR1212_DESCRIPTOR_LEAF_SET_TYPE
c_func
(paren
id|kv
comma
id|dtype
)paren
suffix:semicolon
id|CSR1212_DESCRIPTOR_LEAF_SET_SPECIFIER_ID
c_func
(paren
id|kv
comma
id|specifier_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
)paren
(brace
id|memcpy
c_func
(paren
id|CSR1212_DESCRIPTOR_LEAF_DATA
c_func
(paren
id|kv
)paren
comma
id|data
comma
id|data_len
)paren
suffix:semicolon
)brace
r_return
id|kv
suffix:semicolon
)brace
DECL|function|csr1212_new_textual_descriptor_leaf
r_struct
id|csr1212_keyval
op_star
id|csr1212_new_textual_descriptor_leaf
c_func
(paren
id|u_int8_t
id|cwidth
comma
id|u_int16_t
id|cset
comma
id|u_int16_t
id|language
comma
r_const
r_void
op_star
id|data
comma
r_int
id|data_len
)paren
(brace
r_struct
id|csr1212_keyval
op_star
id|kv
suffix:semicolon
r_char
op_star
id|lstr
suffix:semicolon
id|kv
op_assign
id|csr1212_new_descriptor_leaf
c_func
(paren
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
id|data_len
op_plus
id|CSR1212_TEXTUAL_DESCRIPTOR_LEAF_OVERHEAD
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kv
)paren
r_return
l_int|NULL
suffix:semicolon
id|CSR1212_TEXTUAL_DESCRIPTOR_LEAF_SET_WIDTH
c_func
(paren
id|kv
comma
id|cwidth
)paren
suffix:semicolon
id|CSR1212_TEXTUAL_DESCRIPTOR_LEAF_SET_CHAR_SET
c_func
(paren
id|kv
comma
id|cset
)paren
suffix:semicolon
id|CSR1212_TEXTUAL_DESCRIPTOR_LEAF_SET_LANGUAGE
c_func
(paren
id|kv
comma
id|language
)paren
suffix:semicolon
id|lstr
op_assign
(paren
r_char
op_star
)paren
id|CSR1212_TEXTUAL_DESCRIPTOR_LEAF_DATA
c_func
(paren
id|kv
)paren
suffix:semicolon
multiline_comment|/* make sure last quadlet is zeroed out */
op_star
(paren
(paren
id|u_int32_t
op_star
)paren
op_amp
(paren
id|lstr
(braket
(paren
id|data_len
op_minus
l_int|1
)paren
op_amp
op_complement
l_int|0x3
)braket
)paren
)paren
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* don&squot;t copy the NUL terminator */
id|memcpy
c_func
(paren
id|lstr
comma
id|data
comma
id|data_len
)paren
suffix:semicolon
r_return
id|kv
suffix:semicolon
)brace
DECL|function|csr1212_check_minimal_ascii
r_static
r_int
id|csr1212_check_minimal_ascii
c_func
(paren
r_const
r_char
op_star
id|s
)paren
(brace
r_static
r_const
r_char
id|minimal_ascii_table
(braket
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x07
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x0a
comma
l_int|0x00
comma
l_int|0x0C
comma
l_int|0x0D
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x20
comma
l_int|0x21
comma
l_int|0x22
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x25
comma
l_int|0x26
comma
l_int|0x27
comma
l_int|0x28
comma
l_int|0x29
comma
l_int|0x2a
comma
l_int|0x2b
comma
l_int|0x2c
comma
l_int|0x2d
comma
l_int|0x2e
comma
l_int|0x2f
comma
l_int|0x30
comma
l_int|0x31
comma
l_int|0x32
comma
l_int|0x33
comma
l_int|0x34
comma
l_int|0x35
comma
l_int|0x36
comma
l_int|0x37
comma
l_int|0x38
comma
l_int|0x39
comma
l_int|0x3a
comma
l_int|0x3b
comma
l_int|0x3c
comma
l_int|0x3d
comma
l_int|0x3e
comma
l_int|0x3f
comma
l_int|0x40
comma
l_int|0x41
comma
l_int|0x42
comma
l_int|0x43
comma
l_int|0x44
comma
l_int|0x45
comma
l_int|0x46
comma
l_int|0x47
comma
l_int|0x48
comma
l_int|0x49
comma
l_int|0x4a
comma
l_int|0x4b
comma
l_int|0x4c
comma
l_int|0x4d
comma
l_int|0x4e
comma
l_int|0x4f
comma
l_int|0x50
comma
l_int|0x51
comma
l_int|0x52
comma
l_int|0x53
comma
l_int|0x54
comma
l_int|0x55
comma
l_int|0x56
comma
l_int|0x57
comma
l_int|0x58
comma
l_int|0x59
comma
l_int|0x5a
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x5f
comma
l_int|0x00
comma
l_int|0x61
comma
l_int|0x62
comma
l_int|0x63
comma
l_int|0x64
comma
l_int|0x65
comma
l_int|0x66
comma
l_int|0x67
comma
l_int|0x68
comma
l_int|0x69
comma
l_int|0x6a
comma
l_int|0x6b
comma
l_int|0x6c
comma
l_int|0x6d
comma
l_int|0x6e
comma
l_int|0x6f
comma
l_int|0x70
comma
l_int|0x71
comma
l_int|0x72
comma
l_int|0x73
comma
l_int|0x74
comma
l_int|0x75
comma
l_int|0x76
comma
l_int|0x77
comma
l_int|0x78
comma
l_int|0x79
comma
l_int|0x7a
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
)brace
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
op_star
id|s
suffix:semicolon
id|s
op_increment
)paren
(brace
r_if
c_cond
(paren
id|minimal_ascii_table
(braket
op_star
id|s
op_amp
l_int|0x7F
)braket
op_ne
op_star
id|s
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* failed */
)brace
multiline_comment|/* String conforms to minimal-ascii, as specified by IEEE 1212,&n;&t; * par. 7.4 */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|csr1212_new_string_descriptor_leaf
r_struct
id|csr1212_keyval
op_star
id|csr1212_new_string_descriptor_leaf
c_func
(paren
r_const
r_char
op_star
id|s
)paren
(brace
multiline_comment|/* Check if string conform to minimal_ascii format */
r_if
c_cond
(paren
id|csr1212_check_minimal_ascii
c_func
(paren
id|s
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* IEEE 1212, par. 7.5.4.1  Textual descriptors (minimal ASCII) */
r_return
id|csr1212_new_textual_descriptor_leaf
c_func
(paren
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|s
comma
id|strlen
c_func
(paren
id|s
)paren
)paren
suffix:semicolon
)brace
DECL|function|csr1212_new_icon_descriptor_leaf
r_struct
id|csr1212_keyval
op_star
id|csr1212_new_icon_descriptor_leaf
c_func
(paren
id|u_int32_t
id|version
comma
id|u_int8_t
id|palette_depth
comma
id|u_int8_t
id|color_space
comma
id|u_int16_t
id|language
comma
id|u_int16_t
id|hscan
comma
id|u_int16_t
id|vscan
comma
id|u_int32_t
op_star
id|palette
comma
id|u_int32_t
op_star
id|pixels
)paren
(brace
r_static
r_const
r_int
id|pd
(braket
l_int|4
)braket
op_assign
(brace
l_int|0
comma
l_int|4
comma
l_int|16
comma
l_int|256
)brace
suffix:semicolon
r_static
r_const
r_int
id|cs
(braket
l_int|16
)braket
op_assign
(brace
l_int|4
comma
l_int|2
)brace
suffix:semicolon
r_struct
id|csr1212_keyval
op_star
id|kv
suffix:semicolon
r_int
id|palette_size
op_assign
id|pd
(braket
id|palette_depth
)braket
op_star
id|cs
(braket
id|color_space
)braket
suffix:semicolon
r_int
id|pixel_size
op_assign
(paren
id|hscan
op_star
id|vscan
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|0x3
suffix:semicolon
r_if
c_cond
(paren
(paren
id|palette_depth
op_logical_and
op_logical_neg
id|palette
)paren
op_logical_or
op_logical_neg
id|pixels
)paren
r_return
l_int|NULL
suffix:semicolon
id|kv
op_assign
id|csr1212_new_descriptor_leaf
c_func
(paren
l_int|1
comma
l_int|0
comma
l_int|NULL
comma
id|palette_size
op_plus
id|pixel_size
op_plus
id|CSR1212_ICON_DESCRIPTOR_LEAF_OVERHEAD
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kv
)paren
r_return
l_int|NULL
suffix:semicolon
id|CSR1212_ICON_DESCRIPTOR_LEAF_SET_VERSION
c_func
(paren
id|kv
comma
id|version
)paren
suffix:semicolon
id|CSR1212_ICON_DESCRIPTOR_LEAF_SET_PALETTE_DEPTH
c_func
(paren
id|kv
comma
id|palette_depth
)paren
suffix:semicolon
id|CSR1212_ICON_DESCRIPTOR_LEAF_SET_COLOR_SPACE
c_func
(paren
id|kv
comma
id|color_space
)paren
suffix:semicolon
id|CSR1212_ICON_DESCRIPTOR_LEAF_SET_LANGUAGE
c_func
(paren
id|kv
comma
id|language
)paren
suffix:semicolon
id|CSR1212_ICON_DESCRIPTOR_LEAF_SET_HSCAN
c_func
(paren
id|kv
comma
id|hscan
)paren
suffix:semicolon
id|CSR1212_ICON_DESCRIPTOR_LEAF_SET_VSCAN
c_func
(paren
id|kv
comma
id|vscan
)paren
suffix:semicolon
r_if
c_cond
(paren
id|palette_size
)paren
id|memcpy
c_func
(paren
id|CSR1212_ICON_DESCRIPTOR_LEAF_PALETTE
c_func
(paren
id|kv
)paren
comma
id|palette
comma
id|palette_size
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|CSR1212_ICON_DESCRIPTOR_LEAF_PIXELS
c_func
(paren
id|kv
)paren
comma
id|pixels
comma
id|pixel_size
)paren
suffix:semicolon
r_return
id|kv
suffix:semicolon
)brace
DECL|function|csr1212_new_modifiable_descriptor_leaf
r_struct
id|csr1212_keyval
op_star
id|csr1212_new_modifiable_descriptor_leaf
c_func
(paren
id|u_int16_t
id|max_size
comma
id|u_int64_t
id|address
)paren
(brace
r_struct
id|csr1212_keyval
op_star
id|kv
suffix:semicolon
multiline_comment|/* IEEE 1212, par. 7.5.4.3  Modifiable descriptors */
id|kv
op_assign
id|csr1212_new_leaf
c_func
(paren
id|CSR1212_KV_ID_MODIFIABLE_DESCRIPTOR
comma
l_int|NULL
comma
r_sizeof
(paren
id|u_int64_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kv
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|CSR1212_MODIFIABLE_DESCRIPTOR_SET_MAX_SIZE
c_func
(paren
id|kv
comma
id|max_size
)paren
suffix:semicolon
id|CSR1212_MODIFIABLE_DESCRIPTOR_SET_ADDRESS_HI
c_func
(paren
id|kv
comma
id|address
)paren
suffix:semicolon
id|CSR1212_MODIFIABLE_DESCRIPTOR_SET_ADDRESS_LO
c_func
(paren
id|kv
comma
id|address
)paren
suffix:semicolon
r_return
id|kv
suffix:semicolon
)brace
DECL|function|csr1212_check_keyword
r_static
r_int
id|csr1212_check_keyword
c_func
(paren
r_const
r_char
op_star
id|s
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
op_star
id|s
suffix:semicolon
id|s
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
l_char|&squot;A&squot;
op_le
op_star
id|s
)paren
op_logical_and
(paren
op_star
id|s
op_le
l_char|&squot;Z&squot;
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
l_char|&squot;0&squot;
op_le
op_star
id|s
)paren
op_logical_and
(paren
op_star
id|s
op_le
l_char|&squot;9&squot;
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
op_eq
l_char|&squot;-&squot;
)paren
r_continue
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* failed */
)brace
multiline_comment|/* String conforms to keyword, as specified by IEEE 1212,&n;&t; * par. 7.6.5 */
r_return
id|CSR1212_SUCCESS
suffix:semicolon
)brace
DECL|function|csr1212_new_keyword_leaf
r_struct
id|csr1212_keyval
op_star
id|csr1212_new_keyword_leaf
c_func
(paren
r_int
id|strc
comma
r_const
r_char
op_star
id|strv
(braket
)braket
)paren
(brace
r_struct
id|csr1212_keyval
op_star
id|kv
suffix:semicolon
r_char
op_star
id|buffer
suffix:semicolon
r_int
id|i
comma
id|data_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Check all keywords to see if they conform to restrictions:&n;&t; * Only the following characters is allowed [&squot;A&squot;..&squot;Z&squot;,&squot;0&squot;..&squot;9&squot;,&squot;-&squot;]&n;&t; * Each word is zero-terminated.&n;&t; * Also calculate the total length of the keywords.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|strc
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strv
(braket
id|i
)braket
op_logical_or
id|csr1212_check_keyword
c_func
(paren
id|strv
(braket
id|i
)braket
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|data_len
op_add_assign
id|strlen
c_func
(paren
id|strv
(braket
id|i
)braket
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Add zero-termination char. */
)brace
multiline_comment|/* IEEE 1212, par. 7.6.5 Keyword leaves */
id|kv
op_assign
id|csr1212_new_leaf
c_func
(paren
id|CSR1212_KV_ID_KEYWORD
comma
l_int|NULL
comma
id|data_len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kv
)paren
r_return
l_int|NULL
suffix:semicolon
id|buffer
op_assign
(paren
r_char
op_star
)paren
id|kv-&gt;value.leaf.data
suffix:semicolon
multiline_comment|/* make sure last quadlet is zeroed out */
op_star
(paren
(paren
id|u_int32_t
op_star
)paren
op_amp
(paren
id|buffer
(braket
(paren
id|data_len
op_minus
l_int|1
)paren
op_amp
op_complement
l_int|0x3
)braket
)paren
)paren
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Copy keyword(s) into leaf data buffer */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|strc
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|strv
(braket
id|i
)braket
)paren
op_plus
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
id|buffer
comma
id|strv
(braket
id|i
)braket
comma
id|len
)paren
suffix:semicolon
id|buffer
op_add_assign
id|len
suffix:semicolon
)brace
r_return
id|kv
suffix:semicolon
)brace
multiline_comment|/* Destruction Routines */
DECL|function|csr1212_detach_keyval_from_directory
r_void
id|csr1212_detach_keyval_from_directory
c_func
(paren
r_struct
id|csr1212_keyval
op_star
id|dir
comma
r_struct
id|csr1212_keyval
op_star
id|kv
)paren
(brace
r_struct
id|csr1212_dentry
op_star
id|dentry
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kv
op_logical_or
op_logical_neg
id|dir
op_logical_or
id|dir-&gt;key.type
op_ne
id|CSR1212_KV_TYPE_DIRECTORY
)paren
r_return
suffix:semicolon
id|dentry
op_assign
id|csr1212_find_keyval
c_func
(paren
id|dir
comma
id|kv
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;prev
)paren
id|dentry-&gt;prev-&gt;next
op_assign
id|dentry-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;next
)paren
id|dentry-&gt;next-&gt;prev
op_assign
id|dentry-&gt;prev
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;value.directory.dentries_head
op_eq
id|dentry
)paren
id|dir-&gt;value.directory.dentries_head
op_assign
id|dentry-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;value.directory.dentries_tail
op_eq
id|dentry
)paren
id|dir-&gt;value.directory.dentries_tail
op_assign
id|dentry-&gt;prev
suffix:semicolon
id|CSR1212_FREE
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|csr1212_release_keyval
c_func
(paren
id|kv
)paren
suffix:semicolon
)brace
DECL|function|csr1212_disassociate_keyval
r_void
id|csr1212_disassociate_keyval
c_func
(paren
r_struct
id|csr1212_keyval
op_star
id|kv
)paren
(brace
r_if
c_cond
(paren
id|kv-&gt;associate
)paren
(brace
id|csr1212_release_keyval
c_func
(paren
id|kv-&gt;associate
)paren
suffix:semicolon
)brace
id|kv-&gt;associate
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* This function is used to free the memory taken by a keyval.  If the given&n; * keyval is a directory type, then any keyvals contained in that directory&n; * will be destroyed as well if their respective refcnts are 0.  By means of&n; * list manipulation, this routine will descend a directory structure in a&n; * non-recursive manner. */
DECL|function|_csr1212_destroy_keyval
r_void
id|_csr1212_destroy_keyval
c_func
(paren
r_struct
id|csr1212_keyval
op_star
id|kv
)paren
(brace
r_struct
id|csr1212_keyval
op_star
id|k
comma
op_star
id|a
suffix:semicolon
r_struct
id|csr1212_dentry
id|dentry
suffix:semicolon
r_struct
id|csr1212_dentry
op_star
id|head
comma
op_star
id|tail
suffix:semicolon
id|dentry.kv
op_assign
id|kv
suffix:semicolon
id|dentry.next
op_assign
l_int|NULL
suffix:semicolon
id|dentry.prev
op_assign
l_int|NULL
suffix:semicolon
id|head
op_assign
op_amp
id|dentry
suffix:semicolon
id|tail
op_assign
id|head
suffix:semicolon
r_while
c_loop
(paren
id|head
)paren
(brace
id|k
op_assign
id|head-&gt;kv
suffix:semicolon
r_while
c_loop
(paren
id|k
)paren
(brace
id|k-&gt;refcnt
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|k-&gt;refcnt
OG
l_int|0
)paren
r_break
suffix:semicolon
id|a
op_assign
id|k-&gt;associate
suffix:semicolon
r_if
c_cond
(paren
id|k-&gt;key.type
op_eq
id|CSR1212_KV_TYPE_DIRECTORY
)paren
(brace
multiline_comment|/* If the current entry is a directory, then move all&n;&t;&t;&t;&t; * the entries to the destruction list. */
r_if
c_cond
(paren
id|k-&gt;value.directory.dentries_head
)paren
(brace
id|tail-&gt;next
op_assign
id|k-&gt;value.directory.dentries_head
suffix:semicolon
id|k-&gt;value.directory.dentries_head-&gt;prev
op_assign
id|tail
suffix:semicolon
id|tail
op_assign
id|k-&gt;value.directory.dentries_tail
suffix:semicolon
)brace
)brace
id|free_keyval
c_func
(paren
id|k
)paren
suffix:semicolon
id|k
op_assign
id|a
suffix:semicolon
)brace
id|head
op_assign
id|head-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|head
)paren
(brace
r_if
c_cond
(paren
id|head-&gt;prev
op_logical_and
id|head-&gt;prev
op_ne
op_amp
id|dentry
)paren
(brace
id|CSR1212_FREE
c_func
(paren
id|head-&gt;prev
)paren
suffix:semicolon
)brace
id|head-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tail
op_ne
op_amp
id|dentry
)paren
id|CSR1212_FREE
c_func
(paren
id|tail
)paren
suffix:semicolon
)brace
)brace
DECL|function|csr1212_destroy_csr
r_void
id|csr1212_destroy_csr
c_func
(paren
r_struct
id|csr1212_csr
op_star
id|csr
)paren
(brace
r_struct
id|csr1212_csr_rom_cache
op_star
id|c
comma
op_star
id|oc
suffix:semicolon
r_struct
id|csr1212_cache_region
op_star
id|cr
comma
op_star
id|ocr
suffix:semicolon
id|csr1212_release_keyval
c_func
(paren
id|csr-&gt;root_kv
)paren
suffix:semicolon
id|c
op_assign
id|csr-&gt;cache_head
suffix:semicolon
r_while
c_loop
(paren
id|c
)paren
(brace
id|oc
op_assign
id|c
suffix:semicolon
id|cr
op_assign
id|c-&gt;filled_head
suffix:semicolon
r_while
c_loop
(paren
id|cr
)paren
(brace
id|ocr
op_assign
id|cr
suffix:semicolon
id|cr
op_assign
id|cr-&gt;next
suffix:semicolon
id|CSR1212_FREE
c_func
(paren
id|ocr
)paren
suffix:semicolon
)brace
id|c
op_assign
id|c-&gt;next
suffix:semicolon
id|CSR1212_FREE
c_func
(paren
id|oc
)paren
suffix:semicolon
)brace
id|CSR1212_FREE
c_func
(paren
id|csr
)paren
suffix:semicolon
)brace
multiline_comment|/* CSR Image Creation */
DECL|function|csr1212_append_new_cache
r_static
r_int
id|csr1212_append_new_cache
c_func
(paren
r_struct
id|csr1212_csr
op_star
id|csr
comma
r_int
id|romsize
)paren
(brace
r_struct
id|csr1212_csr_rom_cache
op_star
id|cache
suffix:semicolon
id|u_int64_t
id|csr_addr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|csr
op_logical_or
op_logical_neg
id|csr-&gt;ops-&gt;allocate_addr_range
op_logical_or
op_logical_neg
id|csr-&gt;ops-&gt;release_addr
)paren
r_return
id|CSR1212_ENOMEM
suffix:semicolon
multiline_comment|/* ROM size must be a multiple of csr-&gt;max_rom */
id|romsize
op_assign
(paren
id|romsize
op_plus
(paren
id|csr-&gt;max_rom
op_minus
l_int|1
)paren
)paren
op_amp
op_complement
(paren
id|csr-&gt;max_rom
op_minus
l_int|1
)paren
suffix:semicolon
id|csr_addr
op_assign
id|csr-&gt;ops
op_member_access_from_pointer
id|allocate_addr_range
c_func
(paren
id|romsize
comma
id|csr-&gt;max_rom
comma
id|csr
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
r_if
c_cond
(paren
id|csr_addr
op_eq
op_complement
l_int|0ULL
)paren
(brace
r_return
id|CSR1212_ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|csr_addr
OL
id|CSR1212_REGISTER_SPACE_BASE
)paren
(brace
multiline_comment|/* Invalid address returned from allocate_addr_range(). */
id|csr-&gt;ops
op_member_access_from_pointer
id|release_addr
c_func
(paren
id|csr_addr
comma
id|csr
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
r_return
id|CSR1212_ENOMEM
suffix:semicolon
)brace
id|cache
op_assign
id|csr1212_rom_cache_malloc
c_func
(paren
id|csr_addr
op_minus
id|CSR1212_REGISTER_SPACE_BASE
comma
id|romsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cache
)paren
(brace
id|csr-&gt;ops
op_member_access_from_pointer
id|release_addr
c_func
(paren
id|csr_addr
comma
id|csr
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
r_return
id|CSR1212_ENOMEM
suffix:semicolon
)brace
id|cache-&gt;ext_rom
op_assign
id|csr1212_new_keyval
c_func
(paren
id|CSR1212_KV_TYPE_LEAF
comma
id|CSR1212_KV_ID_EXTENDED_ROM
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cache-&gt;ext_rom
)paren
(brace
id|csr-&gt;ops
op_member_access_from_pointer
id|release_addr
c_func
(paren
id|csr_addr
comma
id|csr
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
id|CSR1212_FREE
c_func
(paren
id|cache
)paren
suffix:semicolon
r_return
id|CSR1212_ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|csr1212_attach_keyval_to_directory
c_func
(paren
id|csr-&gt;root_kv
comma
id|cache-&gt;ext_rom
)paren
op_ne
id|CSR1212_SUCCESS
)paren
(brace
id|csr1212_release_keyval
c_func
(paren
id|cache-&gt;ext_rom
)paren
suffix:semicolon
id|csr-&gt;ops
op_member_access_from_pointer
id|release_addr
c_func
(paren
id|csr_addr
comma
id|csr
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
id|CSR1212_FREE
c_func
(paren
id|cache
)paren
suffix:semicolon
r_return
id|CSR1212_ENOMEM
suffix:semicolon
)brace
id|cache-&gt;ext_rom-&gt;offset
op_assign
id|csr_addr
op_minus
id|CSR1212_REGISTER_SPACE_BASE
suffix:semicolon
id|cache-&gt;ext_rom-&gt;value.leaf.len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Add cache to tail of cache list */
id|cache-&gt;prev
op_assign
id|csr-&gt;cache_tail
suffix:semicolon
id|csr-&gt;cache_tail-&gt;next
op_assign
id|cache
suffix:semicolon
id|csr-&gt;cache_tail
op_assign
id|cache
suffix:semicolon
r_return
id|CSR1212_SUCCESS
suffix:semicolon
)brace
DECL|function|csr1212_remove_cache
r_static
r_inline
r_void
id|csr1212_remove_cache
c_func
(paren
r_struct
id|csr1212_csr
op_star
id|csr
comma
r_struct
id|csr1212_csr_rom_cache
op_star
id|cache
)paren
(brace
r_if
c_cond
(paren
id|csr-&gt;cache_head
op_eq
id|cache
)paren
id|csr-&gt;cache_head
op_assign
id|cache-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|csr-&gt;cache_tail
op_eq
id|cache
)paren
id|csr-&gt;cache_tail
op_assign
id|cache-&gt;prev
suffix:semicolon
r_if
c_cond
(paren
id|cache-&gt;prev
)paren
id|cache-&gt;prev-&gt;next
op_assign
id|cache-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|cache-&gt;next
)paren
id|cache-&gt;next-&gt;prev
op_assign
id|cache-&gt;prev
suffix:semicolon
r_if
c_cond
(paren
id|cache-&gt;ext_rom
)paren
(brace
id|csr1212_detach_keyval_from_directory
c_func
(paren
id|csr-&gt;root_kv
comma
id|cache-&gt;ext_rom
)paren
suffix:semicolon
id|csr1212_release_keyval
c_func
(paren
id|cache-&gt;ext_rom
)paren
suffix:semicolon
)brace
id|CSR1212_FREE
c_func
(paren
id|cache
)paren
suffix:semicolon
)brace
DECL|function|csr1212_generate_layout_subdir
r_static
r_int
id|csr1212_generate_layout_subdir
c_func
(paren
r_struct
id|csr1212_keyval
op_star
id|dir
comma
r_struct
id|csr1212_keyval
op_star
op_star
id|layout_tail
)paren
(brace
r_struct
id|csr1212_dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|csr1212_keyval
op_star
id|dkv
suffix:semicolon
r_struct
id|csr1212_keyval
op_star
id|last_extkey_spec
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|csr1212_keyval
op_star
id|last_extkey
op_assign
l_int|NULL
suffix:semicolon
r_int
id|num_entries
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|dentry
op_assign
id|dir-&gt;value.directory.dentries_head
suffix:semicolon
id|dentry
suffix:semicolon
id|dentry
op_assign
id|dentry-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|dkv
op_assign
id|dentry-&gt;kv
suffix:semicolon
id|dkv
suffix:semicolon
id|dkv
op_assign
id|dkv-&gt;associate
)paren
(brace
multiline_comment|/* Special Case: Extended Key Specifier_ID */
r_if
c_cond
(paren
id|dkv-&gt;key.id
op_eq
id|CSR1212_KV_ID_EXTENDED_KEY_SPECIFIER_ID
)paren
(brace
r_if
c_cond
(paren
id|last_extkey_spec
op_eq
l_int|NULL
)paren
(brace
id|last_extkey_spec
op_assign
id|dkv
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dkv-&gt;value.immediate
op_ne
id|last_extkey_spec-&gt;value.immediate
)paren
(brace
id|last_extkey_spec
op_assign
id|dkv
suffix:semicolon
)brace
r_else
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* Special Case: Extended Key */
)brace
r_else
r_if
c_cond
(paren
id|dkv-&gt;key.id
op_eq
id|CSR1212_KV_ID_EXTENDED_KEY
)paren
(brace
r_if
c_cond
(paren
id|last_extkey
op_eq
l_int|NULL
)paren
(brace
id|last_extkey
op_assign
id|dkv
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dkv-&gt;value.immediate
op_ne
id|last_extkey-&gt;value.immediate
)paren
(brace
id|last_extkey
op_assign
id|dkv
suffix:semicolon
)brace
r_else
(brace
r_continue
suffix:semicolon
)brace
)brace
id|num_entries
op_add_assign
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|dkv-&gt;key.type
)paren
(brace
r_default
suffix:colon
r_case
id|CSR1212_KV_TYPE_IMMEDIATE
suffix:colon
r_case
id|CSR1212_KV_TYPE_CSR_OFFSET
suffix:colon
r_continue
suffix:semicolon
r_case
id|CSR1212_KV_TYPE_LEAF
suffix:colon
r_case
id|CSR1212_KV_TYPE_DIRECTORY
suffix:colon
multiline_comment|/* Remove from list */
r_if
c_cond
(paren
id|dkv-&gt;prev
)paren
id|dkv-&gt;prev-&gt;next
op_assign
id|dkv-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|dkv-&gt;next
)paren
id|dkv-&gt;next-&gt;prev
op_assign
id|dkv-&gt;prev
suffix:semicolon
r_if
c_cond
(paren
id|dkv
op_eq
op_star
id|layout_tail
)paren
op_star
id|layout_tail
op_assign
id|dkv-&gt;prev
suffix:semicolon
multiline_comment|/* Special case: Extended ROM leafs */
r_if
c_cond
(paren
id|dkv-&gt;key.id
op_eq
id|CSR1212_KV_ID_EXTENDED_ROM
)paren
(brace
id|dkv-&gt;value.leaf.len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* initialize to zero */
multiline_comment|/* Don&squot;t add Extended ROM leafs in the layout list,&n;&t;&t;&t;&t;&t; * they are handled differently. */
r_break
suffix:semicolon
)brace
multiline_comment|/* Add to tail of list */
id|dkv-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|dkv-&gt;prev
op_assign
op_star
id|layout_tail
suffix:semicolon
(paren
op_star
id|layout_tail
)paren
op_member_access_from_pointer
id|next
op_assign
id|dkv
suffix:semicolon
op_star
id|layout_tail
op_assign
id|dkv
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_return
id|num_entries
suffix:semicolon
)brace
DECL|function|csr1212_generate_layout_order
r_int
id|csr1212_generate_layout_order
c_func
(paren
r_struct
id|csr1212_keyval
op_star
id|kv
)paren
(brace
r_struct
id|csr1212_keyval
op_star
id|ltail
op_assign
id|kv
suffix:semicolon
r_int
id|agg_size
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|kv
)paren
(brace
r_switch
c_cond
(paren
id|kv-&gt;key.type
)paren
(brace
r_case
id|CSR1212_KV_TYPE_LEAF
suffix:colon
multiline_comment|/* Add 1 quadlet for crc/len field */
id|agg_size
op_add_assign
id|kv-&gt;value.leaf.len
op_plus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR1212_KV_TYPE_DIRECTORY
suffix:colon
id|kv-&gt;value.directory.len
op_assign
id|csr1212_generate_layout_subdir
c_func
(paren
id|kv
comma
op_amp
id|ltail
)paren
suffix:semicolon
multiline_comment|/* Add 1 quadlet for crc/len field */
id|agg_size
op_add_assign
id|kv-&gt;value.directory.len
op_plus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|kv
op_assign
id|kv-&gt;next
suffix:semicolon
)brace
r_return
id|quads_to_bytes
c_func
(paren
id|agg_size
)paren
suffix:semicolon
)brace
DECL|function|csr1212_generate_positions
r_struct
id|csr1212_keyval
op_star
id|csr1212_generate_positions
c_func
(paren
r_struct
id|csr1212_csr_rom_cache
op_star
id|cache
comma
r_struct
id|csr1212_keyval
op_star
id|start_kv
comma
r_int
id|start_pos
)paren
(brace
r_struct
id|csr1212_keyval
op_star
id|kv
op_assign
id|start_kv
suffix:semicolon
r_struct
id|csr1212_keyval
op_star
id|okv
op_assign
id|start_kv
suffix:semicolon
r_int
id|pos
op_assign
id|start_pos
suffix:semicolon
r_int
id|kv_len
op_assign
l_int|0
comma
id|okv_len
op_assign
l_int|0
suffix:semicolon
id|cache-&gt;layout_head
op_assign
id|kv
suffix:semicolon
r_while
c_loop
(paren
id|kv
op_logical_and
id|pos
OL
id|cache-&gt;size
)paren
(brace
id|kv-&gt;offset
op_assign
id|cache-&gt;offset
op_plus
id|pos
suffix:semicolon
r_switch
c_cond
(paren
id|kv-&gt;key.type
)paren
(brace
r_case
id|CSR1212_KV_TYPE_LEAF
suffix:colon
id|kv_len
op_assign
id|kv-&gt;value.leaf.len
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR1212_KV_TYPE_DIRECTORY
suffix:colon
id|kv_len
op_assign
id|kv-&gt;value.directory.len
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Should never get here */
r_break
suffix:semicolon
)brace
id|pos
op_add_assign
id|quads_to_bytes
c_func
(paren
id|kv_len
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_le
id|cache-&gt;size
)paren
(brace
id|okv
op_assign
id|kv
suffix:semicolon
id|okv_len
op_assign
id|kv_len
suffix:semicolon
id|kv
op_assign
id|kv-&gt;next
suffix:semicolon
)brace
)brace
id|cache-&gt;layout_tail
op_assign
id|okv
suffix:semicolon
id|cache-&gt;len
op_assign
(paren
id|okv-&gt;offset
op_minus
id|cache-&gt;offset
)paren
op_plus
id|quads_to_bytes
c_func
(paren
id|okv_len
op_plus
l_int|1
)paren
suffix:semicolon
r_return
id|kv
suffix:semicolon
)brace
DECL|function|csr1212_generate_tree_subdir
r_static
r_void
id|csr1212_generate_tree_subdir
c_func
(paren
r_struct
id|csr1212_keyval
op_star
id|dir
comma
id|u_int32_t
op_star
id|data_buffer
)paren
(brace
r_struct
id|csr1212_dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|csr1212_keyval
op_star
id|last_extkey_spec
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|csr1212_keyval
op_star
id|last_extkey
op_assign
l_int|NULL
suffix:semicolon
r_int
id|index
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|dentry
op_assign
id|dir-&gt;value.directory.dentries_head
suffix:semicolon
id|dentry
suffix:semicolon
id|dentry
op_assign
id|dentry-&gt;next
)paren
(brace
r_struct
id|csr1212_keyval
op_star
id|a
suffix:semicolon
r_for
c_loop
(paren
id|a
op_assign
id|dentry-&gt;kv
suffix:semicolon
id|a
suffix:semicolon
id|a
op_assign
id|a-&gt;associate
)paren
(brace
id|u_int32_t
id|value
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Special Case: Extended Key Specifier_ID */
r_if
c_cond
(paren
id|a-&gt;key.id
op_eq
id|CSR1212_KV_ID_EXTENDED_KEY_SPECIFIER_ID
)paren
(brace
r_if
c_cond
(paren
id|last_extkey_spec
op_eq
l_int|NULL
)paren
(brace
id|last_extkey_spec
op_assign
id|a
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|a-&gt;value.immediate
op_ne
id|last_extkey_spec-&gt;value.immediate
)paren
(brace
id|last_extkey_spec
op_assign
id|a
suffix:semicolon
)brace
r_else
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* Special Case: Extended Key */
)brace
r_else
r_if
c_cond
(paren
id|a-&gt;key.id
op_eq
id|CSR1212_KV_ID_EXTENDED_KEY
)paren
(brace
r_if
c_cond
(paren
id|last_extkey
op_eq
l_int|NULL
)paren
(brace
id|last_extkey
op_assign
id|a
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|a-&gt;value.immediate
op_ne
id|last_extkey-&gt;value.immediate
)paren
(brace
id|last_extkey
op_assign
id|a
suffix:semicolon
)brace
r_else
(brace
r_continue
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|a-&gt;key.type
)paren
(brace
r_case
id|CSR1212_KV_TYPE_IMMEDIATE
suffix:colon
id|value
op_assign
id|a-&gt;value.immediate
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR1212_KV_TYPE_CSR_OFFSET
suffix:colon
id|value
op_assign
id|a-&gt;value.csr_offset
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR1212_KV_TYPE_LEAF
suffix:colon
id|value
op_assign
id|a-&gt;offset
suffix:semicolon
id|value
op_sub_assign
id|dir-&gt;offset
op_plus
id|quads_to_bytes
c_func
(paren
l_int|1
op_plus
id|index
)paren
suffix:semicolon
id|value
op_assign
id|bytes_to_quads
c_func
(paren
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR1212_KV_TYPE_DIRECTORY
suffix:colon
id|value
op_assign
id|a-&gt;offset
suffix:semicolon
id|value
op_sub_assign
id|dir-&gt;offset
op_plus
id|quads_to_bytes
c_func
(paren
l_int|1
op_plus
id|index
)paren
suffix:semicolon
id|value
op_assign
id|bytes_to_quads
c_func
(paren
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Should never get here */
r_break
suffix:semicolon
multiline_comment|/* GDB breakpoint */
)brace
id|value
op_or_assign
(paren
id|a-&gt;key.id
op_amp
id|CSR1212_KV_KEY_ID_MASK
)paren
op_lshift
id|CSR1212_KV_KEY_SHIFT
suffix:semicolon
id|value
op_or_assign
(paren
id|a-&gt;key.type
op_amp
id|CSR1212_KV_KEY_TYPE_MASK
)paren
op_lshift
(paren
id|CSR1212_KV_KEY_SHIFT
op_plus
id|CSR1212_KV_KEY_TYPE_SHIFT
)paren
suffix:semicolon
id|data_buffer
(braket
id|index
)braket
op_assign
id|CSR1212_CPU_TO_BE32
c_func
(paren
id|value
)paren
suffix:semicolon
id|index
op_increment
suffix:semicolon
)brace
)brace
)brace
DECL|function|csr1212_fill_cache
r_void
id|csr1212_fill_cache
c_func
(paren
r_struct
id|csr1212_csr_rom_cache
op_star
id|cache
)paren
(brace
r_struct
id|csr1212_keyval
op_star
id|kv
comma
op_star
id|nkv
suffix:semicolon
r_struct
id|csr1212_keyval_img
op_star
id|kvi
suffix:semicolon
r_for
c_loop
(paren
id|kv
op_assign
id|cache-&gt;layout_head
suffix:semicolon
id|kv
op_ne
id|cache-&gt;layout_tail-&gt;next
suffix:semicolon
id|kv
op_assign
id|nkv
)paren
(brace
id|kvi
op_assign
(paren
r_struct
id|csr1212_keyval_img
op_star
)paren
(paren
id|cache-&gt;data
op_plus
id|bytes_to_quads
c_func
(paren
id|kv-&gt;offset
op_minus
id|cache-&gt;offset
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|kv-&gt;key.type
)paren
(brace
r_default
suffix:colon
r_case
id|CSR1212_KV_TYPE_IMMEDIATE
suffix:colon
r_case
id|CSR1212_KV_TYPE_CSR_OFFSET
suffix:colon
multiline_comment|/* Should never get here */
r_break
suffix:semicolon
multiline_comment|/* GDB breakpoint */
r_case
id|CSR1212_KV_TYPE_LEAF
suffix:colon
multiline_comment|/* Don&squot;t copy over Extended ROM areas, they are&n;&t;&t;&t; * already filled out! */
r_if
c_cond
(paren
id|kv-&gt;key.id
op_ne
id|CSR1212_KV_ID_EXTENDED_ROM
)paren
id|memcpy
c_func
(paren
id|kvi-&gt;data
comma
id|kv-&gt;value.leaf.data
comma
id|quads_to_bytes
c_func
(paren
id|kv-&gt;value.leaf.len
)paren
)paren
suffix:semicolon
id|kvi-&gt;length
op_assign
id|CSR1212_CPU_TO_BE16
c_func
(paren
id|kv-&gt;value.leaf.len
)paren
suffix:semicolon
id|kvi-&gt;crc
op_assign
id|csr1212_crc16
c_func
(paren
id|kvi-&gt;data
comma
id|kv-&gt;value.leaf.len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR1212_KV_TYPE_DIRECTORY
suffix:colon
id|csr1212_generate_tree_subdir
c_func
(paren
id|kv
comma
id|kvi-&gt;data
)paren
suffix:semicolon
id|kvi-&gt;length
op_assign
id|CSR1212_CPU_TO_BE16
c_func
(paren
id|kv-&gt;value.directory.len
)paren
suffix:semicolon
id|kvi-&gt;crc
op_assign
id|csr1212_crc16
c_func
(paren
id|kvi-&gt;data
comma
id|kv-&gt;value.directory.len
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|nkv
op_assign
id|kv-&gt;next
suffix:semicolon
id|kv-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|kv-&gt;next
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|csr1212_generate_csr_image
r_int
id|csr1212_generate_csr_image
c_func
(paren
r_struct
id|csr1212_csr
op_star
id|csr
)paren
(brace
r_struct
id|csr1212_bus_info_block_img
op_star
id|bi
suffix:semicolon
r_struct
id|csr1212_csr_rom_cache
op_star
id|cache
suffix:semicolon
r_struct
id|csr1212_keyval
op_star
id|kv
suffix:semicolon
r_int
id|agg_size
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|init_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|csr
)paren
r_return
id|CSR1212_EINVAL
suffix:semicolon
id|cache
op_assign
id|csr-&gt;cache_head
suffix:semicolon
id|bi
op_assign
(paren
r_struct
id|csr1212_bus_info_block_img
op_star
)paren
id|cache-&gt;data
suffix:semicolon
id|bi-&gt;length
op_assign
id|bytes_to_quads
c_func
(paren
id|csr-&gt;bus_info_len
)paren
op_minus
l_int|1
suffix:semicolon
id|bi-&gt;crc_length
op_assign
id|bi-&gt;length
suffix:semicolon
id|bi-&gt;crc
op_assign
id|csr1212_crc16
c_func
(paren
id|bi-&gt;data
comma
id|bi-&gt;crc_length
)paren
suffix:semicolon
id|agg_size
op_assign
id|csr1212_generate_layout_order
c_func
(paren
id|csr-&gt;root_kv
)paren
suffix:semicolon
id|init_offset
op_assign
id|csr-&gt;bus_info_len
suffix:semicolon
r_for
c_loop
(paren
id|kv
op_assign
id|csr-&gt;root_kv
comma
id|cache
op_assign
id|csr-&gt;cache_head
suffix:semicolon
id|kv
suffix:semicolon
id|cache
op_assign
id|cache-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cache
)paren
(brace
multiline_comment|/* Estimate approximate number of additional cache&n;&t;&t;&t; * regions needed (it assumes that the cache holding&n;&t;&t;&t; * the first 1K Config ROM space always exists). */
r_int
id|est_c
op_assign
id|agg_size
op_div
(paren
id|CSR1212_EXTENDED_ROM_SIZE
op_minus
(paren
l_int|2
op_star
r_sizeof
(paren
id|u_int32_t
)paren
)paren
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Add additional cache regions, extras will be&n;&t;&t;&t; * removed later */
r_for
c_loop
(paren
suffix:semicolon
id|est_c
suffix:semicolon
id|est_c
op_decrement
)paren
(brace
id|ret
op_assign
id|csr1212_append_new_cache
c_func
(paren
id|csr
comma
id|CSR1212_EXTENDED_ROM_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
id|CSR1212_SUCCESS
)paren
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Need to re-layout for additional cache regions */
id|agg_size
op_assign
id|csr1212_generate_layout_order
c_func
(paren
id|csr-&gt;root_kv
)paren
suffix:semicolon
id|kv
op_assign
id|csr-&gt;root_kv
suffix:semicolon
id|cache
op_assign
id|csr-&gt;cache_head
suffix:semicolon
id|init_offset
op_assign
id|csr-&gt;bus_info_len
suffix:semicolon
)brace
id|kv
op_assign
id|csr1212_generate_positions
c_func
(paren
id|cache
comma
id|kv
comma
id|init_offset
)paren
suffix:semicolon
id|agg_size
op_sub_assign
id|cache-&gt;len
suffix:semicolon
id|init_offset
op_assign
r_sizeof
(paren
id|u_int32_t
)paren
suffix:semicolon
)brace
multiline_comment|/* Remove unused, excess cache regions */
r_while
c_loop
(paren
id|cache
)paren
(brace
r_struct
id|csr1212_csr_rom_cache
op_star
id|oc
op_assign
id|cache
suffix:semicolon
id|cache
op_assign
id|cache-&gt;next
suffix:semicolon
id|csr1212_remove_cache
c_func
(paren
id|csr
comma
id|oc
)paren
suffix:semicolon
)brace
multiline_comment|/* Go through the list backward so that when done, the correct CRC&n;&t; * will be calculated for the Extended ROM areas. */
r_for
c_loop
(paren
id|cache
op_assign
id|csr-&gt;cache_tail
suffix:semicolon
id|cache
suffix:semicolon
id|cache
op_assign
id|cache-&gt;prev
)paren
(brace
multiline_comment|/* Only Extended ROM caches should have this set. */
r_if
c_cond
(paren
id|cache-&gt;ext_rom
)paren
(brace
r_int
id|leaf_size
suffix:semicolon
multiline_comment|/* Make sure the Extended ROM leaf is a multiple of&n;&t;&t;&t; * max_rom in size. */
id|leaf_size
op_assign
(paren
id|cache-&gt;len
op_plus
(paren
id|csr-&gt;max_rom
op_minus
l_int|1
)paren
)paren
op_amp
(paren
id|csr-&gt;max_rom
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Zero out the unused ROM region */
id|memset
c_func
(paren
id|cache-&gt;data
op_plus
id|bytes_to_quads
c_func
(paren
id|cache-&gt;len
)paren
comma
l_int|0x00
comma
id|leaf_size
op_minus
id|cache-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Subtract leaf header */
id|leaf_size
op_sub_assign
r_sizeof
(paren
id|u_int32_t
)paren
suffix:semicolon
multiline_comment|/* Update the Extended ROM leaf length */
id|cache-&gt;ext_rom-&gt;value.leaf.len
op_assign
id|bytes_to_quads
c_func
(paren
id|leaf_size
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Zero out the unused ROM region */
id|memset
c_func
(paren
id|cache-&gt;data
op_plus
id|bytes_to_quads
c_func
(paren
id|cache-&gt;len
)paren
comma
l_int|0x00
comma
id|cache-&gt;size
op_minus
id|cache-&gt;len
)paren
suffix:semicolon
)brace
multiline_comment|/* Copy the data into the cache buffer */
id|csr1212_fill_cache
c_func
(paren
id|cache
)paren
suffix:semicolon
)brace
r_return
id|CSR1212_SUCCESS
suffix:semicolon
)brace
DECL|function|csr1212_read
r_int
id|csr1212_read
c_func
(paren
r_struct
id|csr1212_csr
op_star
id|csr
comma
id|u_int32_t
id|offset
comma
r_void
op_star
id|buffer
comma
id|u_int32_t
id|len
)paren
(brace
r_struct
id|csr1212_csr_rom_cache
op_star
id|cache
suffix:semicolon
r_for
c_loop
(paren
id|cache
op_assign
id|csr-&gt;cache_head
suffix:semicolon
id|cache
suffix:semicolon
id|cache
op_assign
id|cache-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|offset
op_ge
id|cache-&gt;offset
op_logical_and
(paren
id|offset
op_plus
id|len
)paren
op_le
(paren
id|cache-&gt;offset
op_plus
id|cache-&gt;size
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|buffer
comma
op_amp
id|cache-&gt;data
(braket
id|bytes_to_quads
c_func
(paren
id|offset
op_minus
id|cache-&gt;offset
)paren
)braket
comma
id|len
)paren
suffix:semicolon
r_return
id|CSR1212_SUCCESS
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|offset
OL
id|cache-&gt;offset
)paren
op_logical_and
(paren
(paren
id|offset
op_plus
id|len
)paren
op_ge
id|cache-&gt;offset
)paren
)paren
op_logical_or
(paren
(paren
id|offset
op_ge
id|cache-&gt;offset
)paren
op_logical_and
(paren
(paren
id|offset
op_plus
id|len
)paren
OG
(paren
id|cache-&gt;offset
op_plus
id|cache-&gt;size
)paren
)paren
)paren
)paren
(brace
r_return
id|CSR1212_EINVAL
suffix:semicolon
)brace
)brace
r_return
id|CSR1212_ENOENT
suffix:semicolon
)brace
multiline_comment|/* Parse a chunk of data as a Config ROM */
DECL|function|csr1212_parse_bus_info_block
r_static
r_int
id|csr1212_parse_bus_info_block
c_func
(paren
r_struct
id|csr1212_csr
op_star
id|csr
)paren
(brace
r_struct
id|csr1212_bus_info_block_img
op_star
id|bi
suffix:semicolon
r_struct
id|csr1212_cache_region
op_star
id|cr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* IEEE 1212 says that the entire bus info block should be readable in&n;&t; * a single transaction regardless of the max_rom value.&n;&t; * Unfortunately, many IEEE 1394 devices do not abide by that, so the&n;&t; * bus info block will be read 1 quadlet at a time.  The rest of the&n;&t; * ConfigROM will be read according to the max_rom field. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|csr-&gt;bus_info_len
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|csr1212_quad_t
)paren
)paren
(brace
id|ret
op_assign
id|csr-&gt;ops
op_member_access_from_pointer
id|bus_read
c_func
(paren
id|csr
comma
id|CSR1212_CONFIG_ROM_SPACE_BASE
op_plus
id|i
comma
r_sizeof
(paren
id|csr1212_quad_t
)paren
comma
op_amp
id|csr-&gt;cache_head-&gt;data
(braket
id|bytes_to_quads
c_func
(paren
id|i
)paren
)braket
comma
id|csr
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
id|CSR1212_SUCCESS
)paren
r_return
id|ret
suffix:semicolon
)brace
id|bi
op_assign
(paren
r_struct
id|csr1212_bus_info_block_img
op_star
)paren
id|csr-&gt;cache_head-&gt;data
suffix:semicolon
id|csr-&gt;crc_len
op_assign
id|quads_to_bytes
c_func
(paren
id|bi-&gt;crc_length
)paren
suffix:semicolon
multiline_comment|/* IEEE 1212 recommends that crc_len be equal to bus_info_len, but that is not&n;&t; * always the case, so read the rest of the crc area 1 quadlet at a time. */
r_for
c_loop
(paren
id|i
op_assign
id|csr-&gt;bus_info_len
suffix:semicolon
id|i
op_le
id|csr-&gt;crc_len
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|csr1212_quad_t
)paren
)paren
(brace
id|ret
op_assign
id|csr-&gt;ops
op_member_access_from_pointer
id|bus_read
c_func
(paren
id|csr
comma
id|CSR1212_CONFIG_ROM_SPACE_BASE
op_plus
id|i
comma
r_sizeof
(paren
id|csr1212_quad_t
)paren
comma
op_amp
id|csr-&gt;cache_head-&gt;data
(braket
id|bytes_to_quads
c_func
(paren
id|i
)paren
)braket
comma
id|csr
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
id|CSR1212_SUCCESS
)paren
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bytes_to_quads
c_func
(paren
id|csr-&gt;bus_info_len
op_minus
r_sizeof
(paren
id|csr1212_quad_t
)paren
)paren
op_ne
id|bi-&gt;length
)paren
r_return
id|CSR1212_EINVAL
suffix:semicolon
macro_line|#if 0
multiline_comment|/* Apparently there are too many differnt wrong implementations of the&n;         * CRC algorithm that verifying them is moot. */
r_if
c_cond
(paren
(paren
id|csr1212_crc16
c_func
(paren
id|bi-&gt;data
comma
id|bi-&gt;crc_length
)paren
op_ne
id|bi-&gt;crc
)paren
op_logical_and
(paren
id|csr1212_msft_crc16
c_func
(paren
id|bi-&gt;data
comma
id|bi-&gt;crc_length
)paren
op_ne
id|bi-&gt;crc
)paren
)paren
r_return
id|CSR1212_EINVAL
suffix:semicolon
macro_line|#endif
id|cr
op_assign
id|CSR1212_MALLOC
c_func
(paren
r_sizeof
(paren
r_struct
id|csr1212_cache_region
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cr
)paren
r_return
id|CSR1212_ENOMEM
suffix:semicolon
id|cr-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|cr-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|cr-&gt;offset_start
op_assign
l_int|0
suffix:semicolon
id|cr-&gt;offset_end
op_assign
id|csr-&gt;crc_len
op_plus
l_int|4
suffix:semicolon
id|csr-&gt;cache_head-&gt;filled_head
op_assign
id|cr
suffix:semicolon
id|csr-&gt;cache_head-&gt;filled_tail
op_assign
id|cr
suffix:semicolon
r_return
id|CSR1212_SUCCESS
suffix:semicolon
)brace
DECL|function|csr1212_parse_dir_entry
r_static
r_inline
r_int
id|csr1212_parse_dir_entry
c_func
(paren
r_struct
id|csr1212_keyval
op_star
id|dir
comma
id|csr1212_quad_t
id|ki
comma
id|u_int32_t
id|kv_pos
comma
r_struct
id|csr1212_csr_rom_cache
op_star
id|cache
)paren
(brace
r_int
id|ret
op_assign
id|CSR1212_SUCCESS
suffix:semicolon
r_struct
id|csr1212_keyval
op_star
id|k
op_assign
l_int|NULL
suffix:semicolon
id|u_int32_t
id|offset
suffix:semicolon
r_switch
c_cond
(paren
id|CSR1212_KV_KEY_TYPE
c_func
(paren
id|ki
)paren
)paren
(brace
r_case
id|CSR1212_KV_TYPE_IMMEDIATE
suffix:colon
id|k
op_assign
id|csr1212_new_immediate
c_func
(paren
id|CSR1212_KV_KEY_ID
c_func
(paren
id|ki
)paren
comma
id|CSR1212_KV_VAL
c_func
(paren
id|ki
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|k
)paren
(brace
id|ret
op_assign
id|CSR1212_ENOMEM
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|k-&gt;refcnt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Don&squot;t keep local reference when parsing. */
r_break
suffix:semicolon
r_case
id|CSR1212_KV_TYPE_CSR_OFFSET
suffix:colon
id|k
op_assign
id|csr1212_new_csr_offset
c_func
(paren
id|CSR1212_KV_KEY_ID
c_func
(paren
id|ki
)paren
comma
id|CSR1212_KV_VAL
c_func
(paren
id|ki
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|k
)paren
(brace
id|ret
op_assign
id|CSR1212_ENOMEM
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|k-&gt;refcnt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Don&squot;t keep local reference when parsing. */
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Compute the offset from 0xffff f000 0000. */
id|offset
op_assign
id|quads_to_bytes
c_func
(paren
id|CSR1212_KV_VAL
c_func
(paren
id|ki
)paren
)paren
op_plus
id|kv_pos
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_eq
id|kv_pos
)paren
(brace
multiline_comment|/* Uh-oh.  Can&squot;t have a relative offset of 0 for Leaves&n;&t;&t;&t; * or Directories.  The Config ROM image is most likely&n;&t;&t;&t; * messed up, so we&squot;ll just abort here. */
id|ret
op_assign
id|CSR1212_EIO
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|k
op_assign
id|csr1212_find_keyval_offset
c_func
(paren
id|cache-&gt;layout_head
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|k
)paren
r_break
suffix:semicolon
multiline_comment|/* Found it. */
r_if
c_cond
(paren
id|CSR1212_KV_KEY_TYPE
c_func
(paren
id|ki
)paren
op_eq
id|CSR1212_KV_TYPE_DIRECTORY
)paren
(brace
id|k
op_assign
id|csr1212_new_directory
c_func
(paren
id|CSR1212_KV_KEY_ID
c_func
(paren
id|ki
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|k
op_assign
id|csr1212_new_leaf
c_func
(paren
id|CSR1212_KV_KEY_ID
c_func
(paren
id|ki
)paren
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|k
)paren
(brace
id|ret
op_assign
id|CSR1212_ENOMEM
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|k-&gt;refcnt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Don&squot;t keep local reference when parsing. */
id|k-&gt;valid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Contents not read yet so it&squot;s not valid. */
id|k-&gt;offset
op_assign
id|offset
suffix:semicolon
id|k-&gt;prev
op_assign
id|cache-&gt;layout_tail
suffix:semicolon
id|k-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cache-&gt;layout_tail
)paren
id|cache-&gt;layout_tail-&gt;next
op_assign
id|k
suffix:semicolon
id|cache-&gt;layout_tail
op_assign
id|k
suffix:semicolon
)brace
id|ret
op_assign
id|csr1212_attach_keyval_to_directory
c_func
(paren
id|dir
comma
id|k
)paren
suffix:semicolon
id|fail
suffix:colon
r_if
c_cond
(paren
id|ret
op_ne
id|CSR1212_SUCCESS
)paren
(brace
r_if
c_cond
(paren
id|k
)paren
id|free_keyval
c_func
(paren
id|k
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|csr1212_parse_keyval
r_int
id|csr1212_parse_keyval
c_func
(paren
r_struct
id|csr1212_keyval
op_star
id|kv
comma
r_struct
id|csr1212_csr_rom_cache
op_star
id|cache
)paren
(brace
r_struct
id|csr1212_keyval_img
op_star
id|kvi
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|ret
op_assign
id|CSR1212_SUCCESS
suffix:semicolon
r_int
id|kvi_len
suffix:semicolon
id|kvi
op_assign
(paren
r_struct
id|csr1212_keyval_img
op_star
)paren
op_amp
id|cache-&gt;data
(braket
id|bytes_to_quads
c_func
(paren
id|kv-&gt;offset
op_minus
id|cache-&gt;offset
)paren
)braket
suffix:semicolon
id|kvi_len
op_assign
id|CSR1212_BE16_TO_CPU
c_func
(paren
id|kvi-&gt;length
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* Apparently there are too many differnt wrong implementations of the&n;         * CRC algorithm that verifying them is moot. */
r_if
c_cond
(paren
(paren
id|csr1212_crc16
c_func
(paren
id|kvi-&gt;data
comma
id|kvi_len
)paren
op_ne
id|kvi-&gt;crc
)paren
op_logical_and
(paren
id|csr1212_msft_crc16
c_func
(paren
id|kvi-&gt;data
comma
id|kvi_len
)paren
op_ne
id|kvi-&gt;crc
)paren
)paren
(brace
id|ret
op_assign
id|CSR1212_EINVAL
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
macro_line|#endif
r_switch
c_cond
(paren
id|kv-&gt;key.type
)paren
(brace
r_case
id|CSR1212_KV_TYPE_DIRECTORY
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|kvi_len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|csr1212_quad_t
id|ki
op_assign
id|kvi-&gt;data
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Some devices put null entries in their unit&n;&t;&t;&t; * directories.  If we come across such and entry,&n;&t;&t;&t; * then skip it. */
r_if
c_cond
(paren
id|ki
op_eq
l_int|0x0
)paren
r_continue
suffix:semicolon
id|ret
op_assign
id|csr1212_parse_dir_entry
c_func
(paren
id|kv
comma
id|ki
comma
(paren
id|kv-&gt;offset
op_plus
id|quads_to_bytes
c_func
(paren
id|i
op_plus
l_int|1
)paren
)paren
comma
id|cache
)paren
suffix:semicolon
)brace
id|kv-&gt;value.directory.len
op_assign
id|kvi_len
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CSR1212_KV_TYPE_LEAF
suffix:colon
r_if
c_cond
(paren
id|kv-&gt;key.id
op_eq
id|CSR1212_KV_ID_EXTENDED_ROM
)paren
(brace
id|kv-&gt;value.leaf.data
op_assign
id|cache-&gt;data
suffix:semicolon
)brace
r_else
(brace
id|kv-&gt;value.leaf.data
op_assign
id|CSR1212_MALLOC
c_func
(paren
id|quads_to_bytes
c_func
(paren
id|kvi_len
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kv-&gt;value.leaf.data
)paren
(brace
id|ret
op_assign
id|CSR1212_ENOMEM
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|kv-&gt;value.leaf.len
op_assign
id|kvi_len
suffix:semicolon
id|memcpy
c_func
(paren
id|kv-&gt;value.leaf.data
comma
id|kvi-&gt;data
comma
id|quads_to_bytes
c_func
(paren
id|kvi_len
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|kv-&gt;valid
op_assign
l_int|1
suffix:semicolon
id|fail
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|_csr1212_read_keyval
r_int
id|_csr1212_read_keyval
c_func
(paren
r_struct
id|csr1212_csr
op_star
id|csr
comma
r_struct
id|csr1212_keyval
op_star
id|kv
)paren
(brace
r_struct
id|csr1212_cache_region
op_star
id|cr
comma
op_star
id|ncr
comma
op_star
id|newcr
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|csr1212_keyval_img
op_star
id|kvi
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|csr1212_csr_rom_cache
op_star
id|cache
suffix:semicolon
r_int
id|cache_index
suffix:semicolon
id|u_int64_t
id|addr
suffix:semicolon
id|u_int32_t
op_star
id|cache_ptr
suffix:semicolon
id|u_int16_t
id|kv_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|csr
op_logical_or
op_logical_neg
id|kv
)paren
r_return
id|CSR1212_EINVAL
suffix:semicolon
multiline_comment|/* First find which cache the data should be in (or go in if not read&n;&t; * yet). */
r_for
c_loop
(paren
id|cache
op_assign
id|csr-&gt;cache_head
suffix:semicolon
id|cache
suffix:semicolon
id|cache
op_assign
id|cache-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|kv-&gt;offset
op_ge
id|cache-&gt;offset
op_logical_and
id|kv-&gt;offset
OL
(paren
id|cache-&gt;offset
op_plus
id|cache-&gt;size
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cache
)paren
(brace
id|csr1212_quad_t
id|q
suffix:semicolon
r_struct
id|csr1212_csr_rom_cache
op_star
id|nc
suffix:semicolon
multiline_comment|/* Only create a new cache for Extended ROM leaves. */
r_if
c_cond
(paren
id|kv-&gt;key.id
op_ne
id|CSR1212_KV_ID_EXTENDED_ROM
)paren
r_return
id|CSR1212_EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|csr-&gt;ops
op_member_access_from_pointer
id|bus_read
c_func
(paren
id|csr
comma
id|CSR1212_REGISTER_SPACE_BASE
op_plus
id|kv-&gt;offset
comma
r_sizeof
(paren
id|csr1212_quad_t
)paren
comma
op_amp
id|q
comma
id|csr
op_member_access_from_pointer
r_private
)paren
)paren
(brace
r_return
id|CSR1212_EIO
suffix:semicolon
)brace
id|kv-&gt;value.leaf.len
op_assign
id|quads_to_bytes
c_func
(paren
id|CSR1212_BE32_TO_CPU
c_func
(paren
id|q
)paren
op_rshift
l_int|16
)paren
suffix:semicolon
id|nc
op_assign
id|csr1212_rom_cache_malloc
c_func
(paren
id|kv-&gt;offset
comma
id|kv-&gt;value.leaf.len
)paren
suffix:semicolon
id|cache-&gt;next
op_assign
id|nc
suffix:semicolon
id|nc-&gt;prev
op_assign
id|cache
suffix:semicolon
id|csr-&gt;cache_tail
op_assign
id|nc
suffix:semicolon
id|cache-&gt;filled_head
op_assign
id|CSR1212_MALLOC
c_func
(paren
r_sizeof
(paren
r_struct
id|csr1212_cache_region
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cache-&gt;filled_head
)paren
(brace
r_return
id|CSR1212_ENOMEM
suffix:semicolon
)brace
id|cache-&gt;filled_head-&gt;offset_start
op_assign
l_int|0
suffix:semicolon
id|cache-&gt;filled_head-&gt;offset_end
op_assign
r_sizeof
(paren
id|csr1212_quad_t
)paren
suffix:semicolon
id|cache-&gt;filled_tail
op_assign
id|cache-&gt;filled_head
suffix:semicolon
id|cache-&gt;filled_head-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|cache-&gt;filled_head-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|cache-&gt;data
(braket
l_int|0
)braket
op_assign
id|q
suffix:semicolon
)brace
id|cache_index
op_assign
id|kv-&gt;offset
op_minus
id|cache-&gt;offset
suffix:semicolon
multiline_comment|/* Now seach read portions of the cache to see if it is there. */
r_for
c_loop
(paren
id|cr
op_assign
id|cache-&gt;filled_head
suffix:semicolon
id|cr
suffix:semicolon
id|cr
op_assign
id|cr-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cache_index
OL
id|cr-&gt;offset_start
)paren
(brace
id|newcr
op_assign
id|CSR1212_MALLOC
c_func
(paren
r_sizeof
(paren
r_struct
id|csr1212_cache_region
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newcr
)paren
r_return
id|CSR1212_ENOMEM
suffix:semicolon
id|newcr-&gt;offset_start
op_assign
id|cache_index
op_amp
op_complement
(paren
id|csr-&gt;max_rom
op_minus
l_int|1
)paren
suffix:semicolon
id|newcr-&gt;offset_end
op_assign
id|newcr-&gt;offset_start
suffix:semicolon
id|newcr-&gt;next
op_assign
id|cr
suffix:semicolon
id|newcr-&gt;prev
op_assign
id|cr-&gt;prev
suffix:semicolon
id|cr-&gt;prev
op_assign
id|newcr
suffix:semicolon
id|cr
op_assign
id|newcr
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|cache_index
op_ge
id|cr-&gt;offset_start
)paren
op_logical_and
(paren
id|cache_index
OL
id|cr-&gt;offset_end
)paren
)paren
(brace
id|kvi
op_assign
(paren
r_struct
id|csr1212_keyval_img
op_star
)paren
(paren
op_amp
id|cache-&gt;data
(braket
id|bytes_to_quads
c_func
(paren
id|cache_index
)paren
)braket
)paren
suffix:semicolon
id|kv_len
op_assign
id|quads_to_bytes
c_func
(paren
id|CSR1212_BE16_TO_CPU
c_func
(paren
id|kvi-&gt;length
)paren
op_plus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cache_index
op_eq
id|cr-&gt;offset_end
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cr
)paren
(brace
id|cr
op_assign
id|cache-&gt;filled_tail
suffix:semicolon
id|newcr
op_assign
id|CSR1212_MALLOC
c_func
(paren
r_sizeof
(paren
r_struct
id|csr1212_cache_region
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newcr
)paren
r_return
id|CSR1212_ENOMEM
suffix:semicolon
id|newcr-&gt;offset_start
op_assign
id|cache_index
op_amp
op_complement
(paren
id|csr-&gt;max_rom
op_minus
l_int|1
)paren
suffix:semicolon
id|newcr-&gt;offset_end
op_assign
id|newcr-&gt;offset_start
suffix:semicolon
id|newcr-&gt;prev
op_assign
id|cr
suffix:semicolon
id|newcr-&gt;next
op_assign
id|cr-&gt;next
suffix:semicolon
id|cr-&gt;next
op_assign
id|newcr
suffix:semicolon
id|cr
op_assign
id|newcr
suffix:semicolon
id|cache-&gt;filled_tail
op_assign
id|newcr
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|kvi
op_logical_or
id|cr-&gt;offset_end
OL
id|cache_index
op_plus
id|kv_len
)paren
(brace
id|cache_ptr
op_assign
op_amp
id|cache-&gt;data
(braket
id|bytes_to_quads
c_func
(paren
id|cr-&gt;offset_end
op_amp
op_complement
(paren
id|csr-&gt;max_rom
op_minus
l_int|1
)paren
)paren
)braket
suffix:semicolon
id|addr
op_assign
(paren
id|CSR1212_CSR_ARCH_REG_SPACE_BASE
op_plus
id|cache-&gt;offset
op_plus
id|cr-&gt;offset_end
)paren
op_amp
op_complement
(paren
id|csr-&gt;max_rom
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|csr-&gt;ops
op_member_access_from_pointer
id|bus_read
c_func
(paren
id|csr
comma
id|addr
comma
id|csr-&gt;max_rom
comma
id|cache_ptr
comma
id|csr
op_member_access_from_pointer
r_private
)paren
)paren
(brace
r_if
c_cond
(paren
id|csr-&gt;max_rom
op_eq
l_int|4
)paren
multiline_comment|/* We&squot;ve got problems! */
r_return
id|CSR1212_EIO
suffix:semicolon
multiline_comment|/* Apperently the max_rom value was a lie, set it to&n;&t;&t;&t; * do quadlet reads and try again. */
id|csr-&gt;max_rom
op_assign
l_int|4
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|cr-&gt;offset_end
op_add_assign
id|csr-&gt;max_rom
op_minus
(paren
id|cr-&gt;offset_end
op_amp
(paren
id|csr-&gt;max_rom
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kvi
op_logical_and
(paren
id|cr-&gt;offset_end
OG
id|cache_index
)paren
)paren
(brace
id|kvi
op_assign
(paren
r_struct
id|csr1212_keyval_img
op_star
)paren
(paren
op_amp
id|cache-&gt;data
(braket
id|bytes_to_quads
c_func
(paren
id|cache_index
)paren
)braket
)paren
suffix:semicolon
id|kv_len
op_assign
id|quads_to_bytes
c_func
(paren
id|CSR1212_BE16_TO_CPU
c_func
(paren
id|kvi-&gt;length
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|kv_len
op_plus
(paren
id|kv-&gt;offset
op_minus
id|cache-&gt;offset
)paren
)paren
OG
id|cache-&gt;size
)paren
(brace
multiline_comment|/* The Leaf or Directory claims its length extends&n;&t;&t;&t; * beyond the ConfigROM image region and thus beyond the&n;&t;&t;&t; * end of our cache region.  Therefore, we abort now&n;&t;&t;&t; * rather than seg faulting later. */
r_return
id|CSR1212_EIO
suffix:semicolon
)brace
id|ncr
op_assign
id|cr-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|ncr
op_logical_and
(paren
id|cr-&gt;offset_end
op_ge
id|ncr-&gt;offset_start
)paren
)paren
(brace
multiline_comment|/* consolidate region entries */
id|ncr-&gt;offset_start
op_assign
id|cr-&gt;offset_start
suffix:semicolon
r_if
c_cond
(paren
id|cr-&gt;prev
)paren
id|cr-&gt;prev-&gt;next
op_assign
id|cr-&gt;next
suffix:semicolon
id|ncr-&gt;prev
op_assign
id|cr-&gt;prev
suffix:semicolon
r_if
c_cond
(paren
id|cache-&gt;filled_head
op_eq
id|cr
)paren
id|cache-&gt;filled_head
op_assign
id|ncr
suffix:semicolon
id|CSR1212_FREE
c_func
(paren
id|cr
)paren
suffix:semicolon
id|cr
op_assign
id|ncr
suffix:semicolon
)brace
)brace
r_return
id|csr1212_parse_keyval
c_func
(paren
id|kv
comma
id|cache
)paren
suffix:semicolon
)brace
DECL|function|csr1212_parse_csr
r_int
id|csr1212_parse_csr
c_func
(paren
r_struct
id|csr1212_csr
op_star
id|csr
)paren
(brace
r_static
r_const
r_int
id|mr_map
(braket
)braket
op_assign
(brace
l_int|4
comma
l_int|64
comma
l_int|1024
comma
l_int|0
)brace
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|csr
op_logical_or
op_logical_neg
id|csr-&gt;ops-&gt;bus_read
)paren
r_return
id|CSR1212_EINVAL
suffix:semicolon
id|ret
op_assign
id|csr1212_parse_bus_info_block
c_func
(paren
id|csr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
id|CSR1212_SUCCESS
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|csr-&gt;ops-&gt;get_max_rom
)paren
id|csr-&gt;max_rom
op_assign
id|mr_map
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* default value */
r_else
id|csr-&gt;max_rom
op_assign
id|mr_map
(braket
id|csr-&gt;ops
op_member_access_from_pointer
id|get_max_rom
c_func
(paren
id|csr-&gt;bus_info_data
comma
id|csr
op_member_access_from_pointer
r_private
)paren
)braket
suffix:semicolon
id|csr-&gt;cache_head-&gt;layout_head
op_assign
id|csr-&gt;root_kv
suffix:semicolon
id|csr-&gt;cache_head-&gt;layout_tail
op_assign
id|csr-&gt;root_kv
suffix:semicolon
id|csr-&gt;root_kv-&gt;offset
op_assign
(paren
id|CSR1212_CONFIG_ROM_SPACE_BASE
op_amp
l_int|0xffff
)paren
op_plus
id|csr-&gt;bus_info_len
suffix:semicolon
id|csr-&gt;root_kv-&gt;valid
op_assign
l_int|0
suffix:semicolon
id|csr1212_get_keyval
c_func
(paren
id|csr
comma
id|csr-&gt;root_kv
)paren
suffix:semicolon
r_return
id|CSR1212_SUCCESS
suffix:semicolon
)brace
eof
