multiline_comment|/*&n; * dv1394-private.h - DV input/output over IEEE 1394 on OHCI chips&n; *   Copyright (C)2001 Daniel Maas &lt;dmaas@dcine.com&gt;&n; *     receive, proc_fs by Dan Dennedy &lt;dan@dennedy.org&gt;&n; *&n; * based on:&n; *   video1394.h - driver for OHCI 1394 boards&n; *   Copyright (C)1999,2000 Sebastien Rougeaux &lt;sebastien.rougeaux@anu.edu.au&gt;&n; *                          Peter Schlaile &lt;udbz@rz.uni-karlsruhe.de&gt;&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software Foundation,&n; * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.&n; */
macro_line|#ifndef _DV_1394_PRIVATE_H
DECL|macro|_DV_1394_PRIVATE_H
mdefine_line|#define _DV_1394_PRIVATE_H
macro_line|#include &quot;ieee1394.h&quot;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/scatterlist.h&gt;
multiline_comment|/* data structures private to the dv1394 driver */
multiline_comment|/* none of this is exposed to user-space */
multiline_comment|/* &n;   the 8-byte CIP (Common Isochronous Packet) header that precedes&n;   each packet of DV data.&n;&n;   See the IEC 61883 standard. &n;*/
DECL|struct|CIP_header
DECL|member|b
r_struct
id|CIP_header
(brace
r_int
r_char
id|b
(braket
l_int|8
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|function|fill_cip_header
r_static
r_inline
r_void
id|fill_cip_header
c_func
(paren
r_struct
id|CIP_header
op_star
id|cip
comma
r_int
r_char
id|source_node_id
comma
r_int
r_int
id|counter
comma
r_enum
id|pal_or_ntsc
id|format
comma
r_int
r_int
id|timestamp
)paren
(brace
id|cip-&gt;b
(braket
l_int|0
)braket
op_assign
id|source_node_id
suffix:semicolon
id|cip-&gt;b
(braket
l_int|1
)braket
op_assign
l_int|0x78
suffix:semicolon
multiline_comment|/* packet size in quadlets (480/4) - even for empty packets! */
id|cip-&gt;b
(braket
l_int|2
)braket
op_assign
l_int|0x00
suffix:semicolon
id|cip-&gt;b
(braket
l_int|3
)braket
op_assign
id|counter
suffix:semicolon
id|cip-&gt;b
(braket
l_int|4
)braket
op_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* const */
r_switch
c_cond
(paren
id|format
)paren
(brace
r_case
id|DV1394_PAL
suffix:colon
id|cip-&gt;b
(braket
l_int|5
)braket
op_assign
l_int|0x80
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DV1394_NTSC
suffix:colon
id|cip-&gt;b
(braket
l_int|5
)braket
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cip-&gt;b
(braket
l_int|6
)braket
op_assign
id|timestamp
op_rshift
l_int|8
suffix:semicolon
id|cip-&gt;b
(braket
l_int|7
)braket
op_assign
id|timestamp
op_amp
l_int|0xFF
suffix:semicolon
)brace
multiline_comment|/* &n;   DMA commands used to program the OHCI&squot;s DMA engine&n;&n;   See the Texas Instruments OHCI 1394 chipset documentation. &n;*/
DECL|struct|output_more_immediate
DECL|member|q
r_struct
id|output_more_immediate
(brace
id|u32
id|q
(braket
l_int|8
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|output_more
DECL|member|q
r_struct
id|output_more
(brace
id|u32
id|q
(braket
l_int|4
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|output_last
DECL|member|q
r_struct
id|output_last
(brace
id|u32
id|q
(braket
l_int|4
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|input_more
DECL|member|q
r_struct
id|input_more
(brace
id|u32
id|q
(braket
l_int|4
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|input_last
DECL|member|q
r_struct
id|input_last
(brace
id|u32
id|q
(braket
l_int|4
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* outputs */
DECL|function|fill_output_more_immediate
r_static
r_inline
r_void
id|fill_output_more_immediate
c_func
(paren
r_struct
id|output_more_immediate
op_star
id|omi
comma
r_int
r_char
id|tag
comma
r_int
r_char
id|channel
comma
r_int
r_char
id|sync_tag
comma
r_int
r_int
id|payload_size
)paren
(brace
id|omi-&gt;q
(braket
l_int|0
)braket
op_assign
l_int|0x02000000
op_or
l_int|8
suffix:semicolon
multiline_comment|/* OUTPUT_MORE_IMMEDIATE; 8 is the size of the IT header */
id|omi-&gt;q
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|omi-&gt;q
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|omi-&gt;q
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* IT packet header */
id|omi-&gt;q
(braket
l_int|4
)braket
op_assign
(paren
l_int|0x0
op_lshift
l_int|16
)paren
multiline_comment|/* DMA_SPEED_100 */
op_or
(paren
id|tag
op_lshift
l_int|14
)paren
op_or
(paren
id|channel
op_lshift
l_int|8
)paren
op_or
(paren
id|TCODE_ISO_DATA
op_lshift
l_int|4
)paren
op_or
(paren
id|sync_tag
)paren
suffix:semicolon
id|omi-&gt;q
(braket
l_int|5
)braket
op_assign
id|payload_size
op_lshift
l_int|16
suffix:semicolon
id|omi-&gt;q
(braket
l_int|5
)braket
op_or_assign
(paren
l_int|0x7F
op_lshift
l_int|8
)paren
op_or
l_int|0xA0
suffix:semicolon
multiline_comment|/* reserved field; mimic behavior of my Sony DSR-40 */
id|omi-&gt;q
(braket
l_int|6
)braket
op_assign
l_int|0
suffix:semicolon
id|omi-&gt;q
(braket
l_int|7
)braket
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|fill_output_more
r_static
r_inline
r_void
id|fill_output_more
c_func
(paren
r_struct
id|output_more
op_star
id|om
comma
r_int
r_int
id|data_size
comma
r_int
r_int
id|data_phys_addr
)paren
(brace
id|om-&gt;q
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* OUTPUT_MORE */
id|om-&gt;q
(braket
l_int|0
)braket
op_or_assign
id|data_size
suffix:semicolon
id|om-&gt;q
(braket
l_int|1
)braket
op_assign
id|data_phys_addr
suffix:semicolon
id|om-&gt;q
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|om-&gt;q
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|fill_output_last
r_static
r_inline
r_void
id|fill_output_last
c_func
(paren
r_struct
id|output_last
op_star
id|ol
comma
r_int
id|want_timestamp
comma
r_int
id|want_interrupt
comma
r_int
r_int
id|data_size
comma
r_int
r_int
id|data_phys_addr
)paren
(brace
id|ol-&gt;q
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|ol-&gt;q
(braket
l_int|0
)braket
op_or_assign
l_int|1
op_lshift
l_int|28
suffix:semicolon
multiline_comment|/* OUTPUT_LAST */
r_if
c_cond
(paren
id|want_timestamp
)paren
(brace
multiline_comment|/* controller will update timestamp at DMA time */
id|ol-&gt;q
(braket
l_int|0
)braket
op_or_assign
l_int|1
op_lshift
l_int|27
suffix:semicolon
)brace
r_if
c_cond
(paren
id|want_interrupt
)paren
(brace
id|ol-&gt;q
(braket
l_int|0
)braket
op_or_assign
l_int|3
op_lshift
l_int|20
suffix:semicolon
)brace
id|ol-&gt;q
(braket
l_int|0
)braket
op_or_assign
l_int|3
op_lshift
l_int|18
suffix:semicolon
multiline_comment|/* must take branch */
id|ol-&gt;q
(braket
l_int|0
)braket
op_or_assign
id|data_size
suffix:semicolon
id|ol-&gt;q
(braket
l_int|1
)braket
op_assign
id|data_phys_addr
suffix:semicolon
id|ol-&gt;q
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|ol-&gt;q
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* inputs */
DECL|function|fill_input_more
r_static
r_inline
r_void
id|fill_input_more
c_func
(paren
r_struct
id|input_more
op_star
id|im
comma
r_int
id|want_interrupt
comma
r_int
r_int
id|data_size
comma
r_int
r_int
id|data_phys_addr
)paren
(brace
id|im-&gt;q
(braket
l_int|0
)braket
op_assign
l_int|2
op_lshift
l_int|28
suffix:semicolon
multiline_comment|/* INPUT_MORE */
id|im-&gt;q
(braket
l_int|0
)braket
op_or_assign
l_int|8
op_lshift
l_int|24
suffix:semicolon
multiline_comment|/* s = 1, update xferStatus and resCount */
r_if
c_cond
(paren
id|want_interrupt
)paren
id|im-&gt;q
(braket
l_int|0
)braket
op_or_assign
l_int|0
op_lshift
l_int|20
suffix:semicolon
multiline_comment|/* interrupts, i=0 in packet-per-buffer mode */
id|im-&gt;q
(braket
l_int|0
)braket
op_or_assign
l_int|0x0
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* disable branch to address for packet-per-buffer mode */
multiline_comment|/* disable wait on sync field, not used in DV :-( */
id|im-&gt;q
(braket
l_int|0
)braket
op_or_assign
id|data_size
suffix:semicolon
id|im-&gt;q
(braket
l_int|1
)braket
op_assign
id|data_phys_addr
suffix:semicolon
id|im-&gt;q
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* branchAddress and Z not use in packet-per-buffer mode */
id|im-&gt;q
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* xferStatus &amp; resCount, resCount must be initialize to data_size */
)brace
DECL|function|fill_input_last
r_static
r_inline
r_void
id|fill_input_last
c_func
(paren
r_struct
id|input_last
op_star
id|il
comma
r_int
r_int
id|data_size
comma
r_int
r_int
id|data_phys_addr
)paren
(brace
id|il-&gt;q
(braket
l_int|0
)braket
op_assign
l_int|3
op_lshift
l_int|28
suffix:semicolon
multiline_comment|/* INPUT_LAST */
id|il-&gt;q
(braket
l_int|0
)braket
op_or_assign
l_int|8
op_lshift
l_int|24
suffix:semicolon
multiline_comment|/* s = 1, update xferStatus and resCount */
id|il-&gt;q
(braket
l_int|0
)braket
op_or_assign
l_int|3
op_lshift
l_int|20
suffix:semicolon
multiline_comment|/* enable interrupts */
id|il-&gt;q
(braket
l_int|0
)braket
op_or_assign
l_int|0xC
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* enable branch to address */
multiline_comment|/* disable wait on sync field, not used in DV :-( */
id|il-&gt;q
(braket
l_int|0
)braket
op_or_assign
id|data_size
suffix:semicolon
id|il-&gt;q
(braket
l_int|1
)braket
op_assign
id|data_phys_addr
suffix:semicolon
id|il-&gt;q
(braket
l_int|2
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* branchAddress (filled in later) and Z = 1 descriptor in next block */
id|il-&gt;q
(braket
l_int|3
)braket
op_assign
id|data_size
suffix:semicolon
multiline_comment|/* xferStatus &amp; resCount, resCount must be initialize to data_size */
)brace
multiline_comment|/* &n;   A &quot;DMA descriptor block&quot; consists of several contiguous DMA commands.&n;   struct DMA_descriptor_block encapsulates all of the commands necessary &n;   to send one packet of DV data. &n;   &n;   There are three different types of these blocks:&n;&n;        1) command to send an empty packet (CIP header only, no DV data):&n;&n;&t;    OUTPUT_MORE-Immediate &lt;-- contains the iso header in-line&n;&t;    OUTPUT_LAST           &lt;-- points to the CIP header&n;&n;&t;2) command to send a full packet when the DV data payload does NOT&n;&t;   cross a page boundary:&n;&n;&t;    OUTPUT_MORE-Immediate &lt;-- contains the iso header in-line&n;&t;    OUTPUT_MORE           &lt;-- points to the CIP header&n;&t;    OUTPUT_LAST           &lt;-- points to entire DV data payload&n;&n;&t;3) command to send a full packet when the DV payload DOES cross&n;&t;   a page boundary:&n;&n;&t;    OUTPUT_MORE-Immediate &lt;-- contains the iso header in-line&n;&t;    OUTPUT_MORE           &lt;-- points to the CIP header&n;&t;    OUTPUT_MORE           &lt;-- points to first part of DV data payload&n;&t;    OUTPUT_LAST           &lt;-- points to second part of DV data payload&n;&n;   This struct describes all three block types using unions.&n;&n;   !!! It is vital that an even number of these descriptor blocks fit on one&n;   page of memory, since a block cannot cross a page boundary !!!&n;&n; */
DECL|struct|DMA_descriptor_block
r_struct
id|DMA_descriptor_block
(brace
r_union
(brace
r_struct
(brace
multiline_comment|/*  iso header, common to all output block types */
DECL|member|omi
r_struct
id|output_more_immediate
id|omi
suffix:semicolon
r_union
(brace
multiline_comment|/* empty packet */
r_struct
(brace
DECL|member|ol
r_struct
id|output_last
id|ol
suffix:semicolon
multiline_comment|/* CIP header */
DECL|member|empty
)brace
id|empty
suffix:semicolon
multiline_comment|/* full packet */
r_struct
(brace
DECL|member|om
r_struct
id|output_more
id|om
suffix:semicolon
multiline_comment|/* CIP header */
r_union
(brace
multiline_comment|/* payload does not cross page boundary */
r_struct
(brace
DECL|member|ol
r_struct
id|output_last
id|ol
suffix:semicolon
multiline_comment|/* data payload */
DECL|member|nocross
)brace
id|nocross
suffix:semicolon
multiline_comment|/* payload crosses page boundary */
r_struct
(brace
DECL|member|om
r_struct
id|output_more
id|om
suffix:semicolon
multiline_comment|/* data payload */
DECL|member|ol
r_struct
id|output_last
id|ol
suffix:semicolon
multiline_comment|/* data payload */
DECL|member|cross
)brace
id|cross
suffix:semicolon
DECL|member|u
)brace
id|u
suffix:semicolon
DECL|member|full
)brace
id|full
suffix:semicolon
DECL|member|u
)brace
id|u
suffix:semicolon
DECL|member|out
)brace
id|out
suffix:semicolon
r_struct
(brace
DECL|member|il
r_struct
id|input_last
id|il
suffix:semicolon
DECL|member|in
)brace
id|in
suffix:semicolon
DECL|member|u
)brace
id|u
suffix:semicolon
multiline_comment|/* ensure that PAGE_SIZE % sizeof(struct DMA_descriptor_block) == 0 &n;&t;   by padding out to 128 bytes */
DECL|member|__pad__
id|u32
id|__pad__
(braket
l_int|12
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* struct frame contains all data associated with one frame in the&n;   ringbuffer these are allocated when the DMA context is initialized&n;   do_dv1394_init().  They are re-used after the card finishes&n;   transmitting the frame. */
r_struct
id|video_card
suffix:semicolon
multiline_comment|/* forward declaration */
DECL|struct|frame
r_struct
id|frame
(brace
multiline_comment|/* points to the struct video_card that owns this frame */
DECL|member|video
r_struct
id|video_card
op_star
id|video
suffix:semicolon
multiline_comment|/* index of this frame in video_card-&gt;frames[] */
DECL|member|frame_num
r_int
r_int
id|frame_num
suffix:semicolon
multiline_comment|/* FRAME_CLEAR - DMA program not set up, waiting for data &n;&t;   FRAME_READY - DMA program written, ready to transmit&n;&n;&t;   Changes to these should be locked against the interrupt&n;&t;*/
r_enum
(brace
DECL|enumerator|FRAME_CLEAR
id|FRAME_CLEAR
op_assign
l_int|0
comma
DECL|enumerator|FRAME_READY
id|FRAME_READY
DECL|member|state
)brace
id|state
suffix:semicolon
multiline_comment|/* whether this frame has been DMA&squot;ed already; used only from&n;&t;   the IRQ handler to determine whether the frame can be reset */
DECL|member|done
r_int
id|done
suffix:semicolon
multiline_comment|/* kernel virtual pointer to the start of this frame&squot;s data in&n;&t;   the user ringbuffer. Use only for CPU access; to get the DMA&n;&t;   bus address you must go through the video-&gt;user_dma mapping */
DECL|member|data
r_int
r_int
id|data
suffix:semicolon
multiline_comment|/* Max # of packets per frame */
DECL|macro|MAX_PACKETS
mdefine_line|#define MAX_PACKETS 320
multiline_comment|/* a PAGE_SIZE memory pool for allocating CIP headers&n;&t;   !header_pool must be aligned to PAGE_SIZE! */
DECL|member|header_pool
r_struct
id|CIP_header
op_star
id|header_pool
suffix:semicolon
DECL|member|header_pool_dma
id|dma_addr_t
id|header_pool_dma
suffix:semicolon
multiline_comment|/* a physically contiguous memory pool for allocating DMA&n;&t;   descriptor blocks; usually around 64KB in size&n;&t;   !descriptor_pool must be aligned to PAGE_SIZE! */
DECL|member|descriptor_pool
r_struct
id|DMA_descriptor_block
op_star
id|descriptor_pool
suffix:semicolon
DECL|member|descriptor_pool_dma
id|dma_addr_t
id|descriptor_pool_dma
suffix:semicolon
DECL|member|descriptor_pool_size
r_int
r_int
id|descriptor_pool_size
suffix:semicolon
multiline_comment|/* # of packets allocated for this frame */
DECL|member|n_packets
r_int
r_int
id|n_packets
suffix:semicolon
multiline_comment|/* below are several pointers (kernel virtual addresses, not&n;&t;   DMA bus addresses) to parts of the DMA program.  These are&n;&t;   set each time the DMA program is written in&n;&t;   frame_prepare(). They are used later on, e.g. from the&n;&t;   interrupt handler, to check the status of the frame */
multiline_comment|/* points to status/timestamp field of first DMA packet */
multiline_comment|/* (we&squot;ll check it later to monitor timestamp accuracy) */
DECL|member|frame_begin_timestamp
id|u32
op_star
id|frame_begin_timestamp
suffix:semicolon
multiline_comment|/* the timestamp we assigned to the first packet in the frame */
DECL|member|assigned_timestamp
id|u32
id|assigned_timestamp
suffix:semicolon
multiline_comment|/* pointer to the first packet&squot;s CIP header (where the timestamp goes) */
DECL|member|cip_syt1
r_struct
id|CIP_header
op_star
id|cip_syt1
suffix:semicolon
multiline_comment|/* pointer to the second packet&squot;s CIP header&n;&t;   (only set if the first packet was empty) */
DECL|member|cip_syt2
r_struct
id|CIP_header
op_star
id|cip_syt2
suffix:semicolon
multiline_comment|/* in order to figure out what caused an interrupt,&n;&t;   store pointers to the status fields of the two packets&n;&t;   that can cause interrupts. We&squot;ll check these from the&n;&t;   interrupt handler.&n;&t;*/
DECL|member|mid_frame_timestamp
id|u32
op_star
id|mid_frame_timestamp
suffix:semicolon
DECL|member|frame_end_timestamp
id|u32
op_star
id|frame_end_timestamp
suffix:semicolon
multiline_comment|/* branch address field of final packet. This is effectively&n;&t;   the &quot;tail&quot; in the chain of DMA descriptor blocks.&n;&t;   We will fill it with the address of the first DMA descriptor&n;&t;   block in the subsequent frame, once it is ready.&n;&t;*/
DECL|member|frame_end_branch
id|u32
op_star
id|frame_end_branch
suffix:semicolon
multiline_comment|/* the number of descriptors in the first descriptor block&n;&t;   of the frame. Needed to start DMA */
DECL|member|first_n_descriptors
r_int
id|first_n_descriptors
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|packet
r_struct
id|packet
(brace
DECL|member|timestamp
id|u16
id|timestamp
suffix:semicolon
DECL|member|invalid
id|u16
id|invalid
suffix:semicolon
DECL|member|iso_header
id|u16
id|iso_header
suffix:semicolon
DECL|member|data_length
id|u16
id|data_length
suffix:semicolon
DECL|member|cip_h1
id|u32
id|cip_h1
suffix:semicolon
DECL|member|cip_h2
id|u32
id|cip_h2
suffix:semicolon
DECL|member|data
r_int
r_char
id|data
(braket
l_int|480
)braket
suffix:semicolon
DECL|member|padding
r_int
r_char
id|padding
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* force struct size =512 for page alignment */
)brace
suffix:semicolon
multiline_comment|/* allocate/free a frame */
r_static
r_struct
id|frame
op_star
id|frame_new
c_func
(paren
r_int
r_int
id|frame_num
comma
r_struct
id|video_card
op_star
id|video
)paren
suffix:semicolon
r_static
r_void
id|frame_delete
c_func
(paren
r_struct
id|frame
op_star
id|f
)paren
suffix:semicolon
multiline_comment|/* reset f so that it can be used again */
r_static
r_void
id|frame_reset
c_func
(paren
r_struct
id|frame
op_star
id|f
)paren
suffix:semicolon
multiline_comment|/* structure for bookkeeping of a large non-physically-contiguous DMA buffer */
DECL|struct|dma_region
r_struct
id|dma_region
(brace
DECL|member|n_pages
r_int
r_int
id|n_pages
suffix:semicolon
DECL|member|n_dma_pages
r_int
r_int
id|n_dma_pages
suffix:semicolon
DECL|member|sglist
r_struct
id|scatterlist
op_star
id|sglist
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* return the DMA bus address of the byte with the given offset&n;   relative to the beginning of the dma_region */
DECL|function|dma_offset_to_bus
r_static
r_inline
id|dma_addr_t
id|dma_offset_to_bus
c_func
(paren
r_struct
id|dma_region
op_star
id|dma
comma
r_int
r_int
id|offset
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|sg
op_assign
op_amp
id|dma-&gt;sglist
(braket
l_int|0
)braket
suffix:semicolon
id|i
OL
id|dma-&gt;n_dma_pages
suffix:semicolon
id|i
op_increment
comma
id|sg
op_increment
)paren
(brace
r_if
c_cond
(paren
id|offset
OL
id|sg_dma_len
c_func
(paren
id|sg
)paren
)paren
(brace
r_return
id|sg_dma_address
c_func
(paren
id|sg
)paren
op_plus
id|offset
suffix:semicolon
)brace
id|offset
op_sub_assign
id|sg_dma_len
c_func
(paren
id|sg
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;dv1394: dma_offset_to_bus failed for offset %lu!&bslash;n&quot;
comma
id|offset
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* struct video_card contains all data associated with one instance&n;   of the dv1394 driver &n;*/
DECL|enum|modes
r_enum
id|modes
(brace
DECL|enumerator|MODE_RECEIVE
id|MODE_RECEIVE
comma
DECL|enumerator|MODE_TRANSMIT
id|MODE_TRANSMIT
)brace
suffix:semicolon
DECL|struct|video_card
r_struct
id|video_card
(brace
multiline_comment|/* ohci card to which this instance corresponds */
DECL|member|ohci
r_struct
id|ti_ohci
op_star
id|ohci
suffix:semicolon
multiline_comment|/* OHCI card id; the link between the VFS inode and a specific video_card&n;&t;   (essentially the device minor number) */
DECL|member|id
r_int
id|id
suffix:semicolon
multiline_comment|/* entry in dv1394_cards */
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
multiline_comment|/* handle to /dev/ieee1394/dv/N, NULL if devfs not in use */
DECL|member|devfs_handle
id|devfs_handle_t
id|devfs_handle
suffix:semicolon
multiline_comment|/* OHCI card IT DMA context number, -1 if not in use */
DECL|member|ohci_it_ctx
r_int
id|ohci_it_ctx
suffix:semicolon
multiline_comment|/* register offsets for current IT DMA context, 0 if not in use */
DECL|member|ohci_IsoXmitContextControlSet
id|u32
id|ohci_IsoXmitContextControlSet
suffix:semicolon
DECL|member|ohci_IsoXmitContextControlClear
id|u32
id|ohci_IsoXmitContextControlClear
suffix:semicolon
DECL|member|ohci_IsoXmitCommandPtr
id|u32
id|ohci_IsoXmitCommandPtr
suffix:semicolon
multiline_comment|/* OHCI card IR DMA context number, -1 if not in use */
DECL|member|ohci_ir_ctx
r_int
id|ohci_ir_ctx
suffix:semicolon
multiline_comment|/* register offsets for current IR DMA context, 0 if not in use */
DECL|member|ohci_IsoRcvContextControlSet
id|u32
id|ohci_IsoRcvContextControlSet
suffix:semicolon
DECL|member|ohci_IsoRcvContextControlClear
id|u32
id|ohci_IsoRcvContextControlClear
suffix:semicolon
DECL|member|ohci_IsoRcvCommandPtr
id|u32
id|ohci_IsoRcvCommandPtr
suffix:semicolon
DECL|member|ohci_IsoRcvContextMatch
id|u32
id|ohci_IsoRcvContextMatch
suffix:semicolon
multiline_comment|/* CONCURRENCY CONTROL */
multiline_comment|/* there are THREE levels of locking associated with video_card. */
multiline_comment|/*&n;&t;   1) the &squot;open&squot; flag - this prevents more than one process from&n;&t;   opening the device. (the driver currently assumes only one opener).&n;&t;   This is a regular int, but use test_and_set_bit() (on bit zero) &n;&t;   for atomicity.&n;&t; */
DECL|member|open
r_int
id|open
suffix:semicolon
multiline_comment|/* &n;&t;   2) the spinlock - this provides mutual exclusion between the interrupt&n;&t;   handler and process-context operations. Generally you must take the&n;&t;   spinlock under the following conditions:&n;&t;     1) DMA (and hence the interrupt handler) may be running&n;&t;     AND&n;&t;     2) you need to operate on the video_card, especially active_frame&n;&n;&t;     It is OK to play with video_card without taking the spinlock if&n;&t;     you are certain that DMA is not running. Even if DMA is running,&n;&t;     it is OK to *read* active_frame with the lock, then drop it&n;&t;     immediately. This is safe because the interrupt handler will never&n;&t;     advance active_frame onto a frame that is not READY (and the spinlock&n;&t;     must be held while marking a frame READY).&n;&t; */
DECL|member|spinlock
id|spinlock_t
id|spinlock
suffix:semicolon
multiline_comment|/*&n;&t;  3) the sleeping semaphore &squot;sem&squot; - this is used from process context only,&n;&t;  to serialize various operations on the video_card. Even though only one&n;&t;  open() is allowed, we still need to prevent multiple threads of execution&n;&t;  from entering calls like read, write, ioctl, etc.&n;&n;&t;  I honestly can&squot;t think of a good reason to use dv1394 from several threads&n;&t;  at once, but we need to serialize anyway to prevent oopses =).&n;&n;&t;  NOTE: if you need both spinlock and sem, take sem first to avoid deadlock!&n;&t; */
DECL|member|sem
r_struct
id|semaphore
id|sem
suffix:semicolon
multiline_comment|/* people waiting for buffer space, please form a line here... */
DECL|member|waitq
id|wait_queue_head_t
id|waitq
suffix:semicolon
multiline_comment|/* support asynchronous I/O signals (SIGIO) */
DECL|member|fasync
r_struct
id|fasync_struct
op_star
id|fasync
suffix:semicolon
multiline_comment|/* the large, non-contiguous (rvmalloc()) ringbuffer for DV&n;           data, exposed to user-space via mmap() */
DECL|member|user_buf
r_int
r_char
op_star
id|user_buf
suffix:semicolon
DECL|member|user_buf_size
r_int
r_int
id|user_buf_size
suffix:semicolon
DECL|member|user_dma
r_struct
id|dma_region
id|user_dma
suffix:semicolon
multiline_comment|/* next byte in the ringbuffer that a write() call will fill */
DECL|member|write_off
r_int
id|write_off
suffix:semicolon
DECL|member|frames
r_struct
id|frame
op_star
id|frames
(braket
id|DV1394_MAX_FRAMES
)braket
suffix:semicolon
multiline_comment|/* n_frames also serves as an indicator that this struct video_card is&n;&t;   intialized and ready to run DMA buffers */
DECL|member|n_frames
r_int
id|n_frames
suffix:semicolon
multiline_comment|/* this is the frame that is currently &quot;owned&quot; by the OHCI DMA controller&n;&t;   (set to -1 iff DMA is not running) &n;&n;&t;   ! must lock against the interrupt handler when accessing it !&n;&n;&t;   RULES:&n;&n;&t;       Only the interrupt handler may change active_frame if DMA&n;&t;          is running; if not, process may change it&n;&n;&t;       If the next frame is READY, the interrupt handler will advance&n;&t;       active_frame when the current frame is finished.&n;&n;&t;       If the next frame is CLEAR, the interrupt handler will re-transmit&n;&t;       the current frame, and the dropped_frames counter will be  incremented.&n;&n;&t;       The interrupt handler will NEVER advance active_frame to a&n;&t;       frame that is not READY.&n;&t;       &n;&t;*/
DECL|member|active_frame
r_int
id|active_frame
suffix:semicolon
DECL|member|first_run
r_int
id|first_run
suffix:semicolon
multiline_comment|/* the same locking rules apply to these three fields also: */
multiline_comment|/* altered ONLY from process context. Must check first_clear_frame-&gt;state;&n;&t;   if it&squot;s READY, that means the ringbuffer is full with READY frames;&n;&t;   if it&squot;s CLEAR, that means one or more ringbuffer frames are CLEAR */
DECL|member|first_clear_frame
r_int
r_int
id|first_clear_frame
suffix:semicolon
multiline_comment|/* altered both by process and interrupt */
DECL|member|n_clear_frames
r_int
r_int
id|n_clear_frames
suffix:semicolon
multiline_comment|/* only altered by the interrupt */
DECL|member|dropped_frames
r_int
r_int
id|dropped_frames
suffix:semicolon
multiline_comment|/* the CIP accumulator and continuity counter are properties&n;&t;   of the DMA stream as a whole (not a single frame), so they&n;&t;   are stored here in the video_card */
DECL|member|cip_accum
r_int
r_int
id|cip_accum
suffix:semicolon
DECL|member|cip_n
DECL|member|cip_d
r_int
r_int
id|cip_n
comma
id|cip_d
suffix:semicolon
DECL|member|syt_offset
r_int
r_int
id|syt_offset
suffix:semicolon
DECL|member|continuity_counter
r_int
r_int
id|continuity_counter
suffix:semicolon
DECL|member|pal_or_ntsc
r_enum
id|pal_or_ntsc
id|pal_or_ntsc
suffix:semicolon
multiline_comment|/* redundant, but simplifies the code somewhat */
DECL|member|frame_size
r_int
r_int
id|frame_size
suffix:semicolon
multiline_comment|/* in bytes */
multiline_comment|/* the isochronous channel to use, -1 if video card is inactive */
DECL|member|channel
r_int
id|channel
suffix:semicolon
multiline_comment|/* physically contiguous packet ringbuffer for receive */
DECL|macro|MAX_PACKET_BUFFER
mdefine_line|#define MAX_PACKET_BUFFER 30
DECL|member|packet_buffer
r_struct
id|packet
op_star
id|packet_buffer
suffix:semicolon
DECL|member|packet_buffer_dma
id|dma_addr_t
id|packet_buffer_dma
suffix:semicolon
DECL|member|packet_buffer_size
r_int
r_int
id|packet_buffer_size
suffix:semicolon
DECL|member|current_packet
r_int
r_int
id|current_packet
suffix:semicolon
DECL|member|first_frame
r_int
id|first_frame
suffix:semicolon
multiline_comment|/* received first start frame marker? */
DECL|member|mode
r_enum
id|modes
id|mode
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* &n;   if the video_card is not initialized, then the ONLY fields that are valid are:&n;   ohci&n;   open&n;   n_frames&n;*/
DECL|function|video_card_initialized
r_static
r_inline
r_int
id|video_card_initialized
c_func
(paren
r_struct
id|video_card
op_star
id|v
)paren
(brace
r_return
id|v-&gt;n_frames
OG
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|do_dv1394_init
c_func
(paren
r_struct
id|video_card
op_star
id|video
comma
r_struct
id|dv1394_init
op_star
id|init
)paren
suffix:semicolon
r_static
r_int
id|do_dv1394_init_default
c_func
(paren
r_struct
id|video_card
op_star
id|video
)paren
suffix:semicolon
r_static
r_int
id|do_dv1394_shutdown
c_func
(paren
r_struct
id|video_card
op_star
id|video
comma
r_int
id|free_user_buf
)paren
suffix:semicolon
multiline_comment|/* NTSC empty packet rate accurate to within 0.01%, &n;   calibrated against a Sony DSR-40 DVCAM deck */
DECL|macro|CIP_N_NTSC
mdefine_line|#define CIP_N_NTSC   68000000
DECL|macro|CIP_D_NTSC
mdefine_line|#define CIP_D_NTSC 1000000000
DECL|macro|CIP_N_PAL
mdefine_line|#define CIP_N_PAL  1
DECL|macro|CIP_D_PAL
mdefine_line|#define CIP_D_PAL 16
macro_line|#endif /* _DV_1394_PRIVATE_H */
eof
