multiline_comment|/* Linux driver for NAND Flash Translation Layer      */
multiline_comment|/* (c) 1999 Machine Vision Holdings, Inc.             */
multiline_comment|/* Author: David Woodhouse &lt;dwmw2@infradead.org&gt;      */
multiline_comment|/* $Id: nftlcore.c,v 1.97 2004/11/16 18:28:59 dwmw2 Exp $ */
multiline_comment|/*&n;  The contents of this file are distributed under the GNU General&n;  Public License version 2. The author places no additional&n;  restrictions of any kind on it.&n; */
DECL|macro|PRERELEASE
mdefine_line|#define PRERELEASE
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/errno.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/mtd/nand.h&gt;
macro_line|#include &lt;linux/mtd/nftl.h&gt;
macro_line|#include &lt;linux/mtd/blktrans.h&gt;
multiline_comment|/* maximum number of loops while examining next block, to have a&n;   chance to detect consistency problems (they should never happen&n;   because of the checks done in the mounting */
DECL|macro|MAX_LOOPS
mdefine_line|#define MAX_LOOPS 10000
DECL|function|nftl_add_mtd
r_static
r_void
id|nftl_add_mtd
c_func
(paren
r_struct
id|mtd_blktrans_ops
op_star
id|tr
comma
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|NFTLrecord
op_star
id|nftl
suffix:semicolon
r_int
r_int
id|temp
suffix:semicolon
r_if
c_cond
(paren
id|mtd-&gt;type
op_ne
id|MTD_NANDFLASH
)paren
r_return
suffix:semicolon
multiline_comment|/* OK, this is moderately ugly.  But probably safe.  Alternatives? */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|mtd-&gt;name
comma
l_string|&quot;DiskOnChip&quot;
comma
l_int|10
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mtd-&gt;block_isbad
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NFTL no longer supports the old DiskOnChip drivers loaded via docprobe.&bslash;n&quot;
l_string|&quot;Please use the new diskonchip driver under the NAND subsystem.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;NFTL: add_mtd for %s&bslash;n&quot;
comma
id|mtd-&gt;name
)paren
suffix:semicolon
id|nftl
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|NFTLrecord
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nftl
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;NFTL: out of memory for data structures&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|nftl
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|nftl
)paren
)paren
suffix:semicolon
id|nftl-&gt;mbd.mtd
op_assign
id|mtd
suffix:semicolon
id|nftl-&gt;mbd.devnum
op_assign
op_minus
l_int|1
suffix:semicolon
id|nftl-&gt;mbd.blksize
op_assign
l_int|512
suffix:semicolon
id|nftl-&gt;mbd.tr
op_assign
id|tr
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|nftl-&gt;oobinfo
comma
op_amp
id|mtd-&gt;oobinfo
comma
r_sizeof
(paren
r_struct
id|nand_oobinfo
)paren
)paren
suffix:semicolon
id|nftl-&gt;oobinfo.useecc
op_assign
id|MTD_NANDECC_PLACEONLY
suffix:semicolon
r_if
c_cond
(paren
id|NFTL_mount
c_func
(paren
id|nftl
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;NFTL: could not mount device&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|nftl
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* OK, it&squot;s a new one. Set up all the data structures. */
multiline_comment|/* Calculate geometry */
id|nftl-&gt;cylinders
op_assign
l_int|1024
suffix:semicolon
id|nftl-&gt;heads
op_assign
l_int|16
suffix:semicolon
id|temp
op_assign
id|nftl-&gt;cylinders
op_star
id|nftl-&gt;heads
suffix:semicolon
id|nftl-&gt;sectors
op_assign
id|nftl-&gt;mbd.size
op_div
id|temp
suffix:semicolon
r_if
c_cond
(paren
id|nftl-&gt;mbd.size
op_mod
id|temp
)paren
(brace
id|nftl-&gt;sectors
op_increment
suffix:semicolon
id|temp
op_assign
id|nftl-&gt;cylinders
op_star
id|nftl-&gt;sectors
suffix:semicolon
id|nftl-&gt;heads
op_assign
id|nftl-&gt;mbd.size
op_div
id|temp
suffix:semicolon
r_if
c_cond
(paren
id|nftl-&gt;mbd.size
op_mod
id|temp
)paren
(brace
id|nftl-&gt;heads
op_increment
suffix:semicolon
id|temp
op_assign
id|nftl-&gt;heads
op_star
id|nftl-&gt;sectors
suffix:semicolon
id|nftl-&gt;cylinders
op_assign
id|nftl-&gt;mbd.size
op_div
id|temp
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|nftl-&gt;mbd.size
op_ne
id|nftl-&gt;heads
op_star
id|nftl-&gt;cylinders
op_star
id|nftl-&gt;sectors
)paren
(brace
multiline_comment|/*&n;&t;&t;  Oh no we don&squot;t have &n;&t;&t;   mbd.size == heads * cylinders * sectors&n;&t;&t;*/
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;NFTL: cannot calculate a geometry to &quot;
l_string|&quot;match size of 0x%lx.&bslash;n&quot;
comma
id|nftl-&gt;mbd.size
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;NFTL: using C:%d H:%d S:%d &quot;
l_string|&quot;(== 0x%lx sects)&bslash;n&quot;
comma
id|nftl-&gt;cylinders
comma
id|nftl-&gt;heads
comma
id|nftl-&gt;sectors
comma
(paren
r_int
)paren
id|nftl-&gt;cylinders
op_star
(paren
r_int
)paren
id|nftl-&gt;heads
op_star
(paren
r_int
)paren
id|nftl-&gt;sectors
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|add_mtd_blktrans_dev
c_func
(paren
op_amp
id|nftl-&gt;mbd
)paren
)paren
(brace
r_if
c_cond
(paren
id|nftl-&gt;ReplUnitTable
)paren
id|kfree
c_func
(paren
id|nftl-&gt;ReplUnitTable
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nftl-&gt;EUNtable
)paren
id|kfree
c_func
(paren
id|nftl-&gt;EUNtable
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|nftl
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef PSYCHO_DEBUG
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;NFTL: Found new nftl%c&bslash;n&quot;
comma
id|nftl-&gt;mbd.devnum
op_plus
l_char|&squot;a&squot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|nftl_remove_dev
r_static
r_void
id|nftl_remove_dev
c_func
(paren
r_struct
id|mtd_blktrans_dev
op_star
id|dev
)paren
(brace
r_struct
id|NFTLrecord
op_star
id|nftl
op_assign
(paren
r_void
op_star
)paren
id|dev
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;NFTL: remove_dev (i=%d)&bslash;n&quot;
comma
id|dev-&gt;devnum
)paren
suffix:semicolon
id|del_mtd_blktrans_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nftl-&gt;ReplUnitTable
)paren
id|kfree
c_func
(paren
id|nftl-&gt;ReplUnitTable
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nftl-&gt;EUNtable
)paren
id|kfree
c_func
(paren
id|nftl-&gt;EUNtable
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|nftl
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NFTL_RW
multiline_comment|/* Actual NFTL access routines */
multiline_comment|/* NFTL_findfreeblock: Find a free Erase Unit on the NFTL partition. This function is used&n; *&t;when the give Virtual Unit Chain&n; */
DECL|function|NFTL_findfreeblock
r_static
id|u16
id|NFTL_findfreeblock
c_func
(paren
r_struct
id|NFTLrecord
op_star
id|nftl
comma
r_int
id|desperate
)paren
(brace
multiline_comment|/* For a given Virtual Unit Chain: find or create a free block and&n;&t;   add it to the chain */
multiline_comment|/* We&squot;re passed the number of the last EUN in the chain, to save us from&n;&t;   having to look it up again */
id|u16
id|pot
op_assign
id|nftl-&gt;LastFreeEUN
suffix:semicolon
r_int
id|silly
op_assign
id|nftl-&gt;nb_blocks
suffix:semicolon
multiline_comment|/* Normally, we force a fold to happen before we run out of free blocks completely */
r_if
c_cond
(paren
op_logical_neg
id|desperate
op_logical_and
id|nftl-&gt;numfreeEUNs
OL
l_int|2
)paren
(brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;NFTL_findfreeblock: there are too few free EUNs&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
multiline_comment|/* Scan for a free block */
r_do
(brace
r_if
c_cond
(paren
id|nftl-&gt;ReplUnitTable
(braket
id|pot
)braket
op_eq
id|BLOCK_FREE
)paren
(brace
id|nftl-&gt;LastFreeEUN
op_assign
id|pot
suffix:semicolon
id|nftl-&gt;numfreeEUNs
op_decrement
suffix:semicolon
r_return
id|pot
suffix:semicolon
)brace
multiline_comment|/* This will probably point to the MediaHdr unit itself,&n;&t;&t;   right at the beginning of the partition. But that unit&n;&t;&t;   (and the backup unit too) should have the UCI set&n;&t;&t;   up so that it&squot;s not selected for overwriting */
r_if
c_cond
(paren
op_increment
id|pot
OG
id|nftl-&gt;lastEUN
)paren
id|pot
op_assign
id|le16_to_cpu
c_func
(paren
id|nftl-&gt;MediaHdr.FirstPhysicalEUN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|silly
op_decrement
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Argh! No free blocks found! LastFreeEUN = %d, &quot;
l_string|&quot;FirstEUN = %d&bslash;n&quot;
comma
id|nftl-&gt;LastFreeEUN
comma
id|le16_to_cpu
c_func
(paren
id|nftl-&gt;MediaHdr.FirstPhysicalEUN
)paren
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|pot
op_ne
id|nftl-&gt;LastFreeEUN
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
DECL|function|NFTL_foldchain
r_static
id|u16
id|NFTL_foldchain
(paren
r_struct
id|NFTLrecord
op_star
id|nftl
comma
r_int
id|thisVUC
comma
r_int
id|pendingblock
)paren
(brace
id|u16
id|BlockMap
(braket
id|MAX_SECTORS_PER_UNIT
)braket
suffix:semicolon
r_int
r_char
id|BlockLastState
(braket
id|MAX_SECTORS_PER_UNIT
)braket
suffix:semicolon
r_int
r_char
id|BlockFreeFound
(braket
id|MAX_SECTORS_PER_UNIT
)braket
suffix:semicolon
r_int
r_int
id|thisEUN
suffix:semicolon
r_int
id|block
suffix:semicolon
r_int
id|silly
suffix:semicolon
r_int
r_int
id|targetEUN
suffix:semicolon
r_struct
id|nftl_oob
id|oob
suffix:semicolon
r_int
id|inplace
op_assign
l_int|1
suffix:semicolon
r_int
id|retlen
suffix:semicolon
id|memset
c_func
(paren
id|BlockMap
comma
l_int|0xff
comma
r_sizeof
(paren
id|BlockMap
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|BlockFreeFound
comma
l_int|0
comma
r_sizeof
(paren
id|BlockFreeFound
)paren
)paren
suffix:semicolon
id|thisEUN
op_assign
id|nftl-&gt;EUNtable
(braket
id|thisVUC
)braket
suffix:semicolon
r_if
c_cond
(paren
id|thisEUN
op_eq
id|BLOCK_NIL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Trying to fold non-existent &quot;
l_string|&quot;Virtual Unit Chain %d!&bslash;n&quot;
comma
id|thisVUC
)paren
suffix:semicolon
r_return
id|BLOCK_NIL
suffix:semicolon
)brace
multiline_comment|/* Scan to find the Erase Unit which holds the actual data for each&n;&t;   512-byte block within the Chain.&n;&t;*/
id|silly
op_assign
id|MAX_LOOPS
suffix:semicolon
id|targetEUN
op_assign
id|BLOCK_NIL
suffix:semicolon
r_while
c_loop
(paren
id|thisEUN
op_le
id|nftl-&gt;lastEUN
)paren
(brace
r_int
r_int
id|status
comma
id|foldmark
suffix:semicolon
id|targetEUN
op_assign
id|thisEUN
suffix:semicolon
r_for
c_loop
(paren
id|block
op_assign
l_int|0
suffix:semicolon
id|block
OL
id|nftl-&gt;EraseSize
op_div
l_int|512
suffix:semicolon
id|block
op_increment
)paren
(brace
id|MTD_READOOB
c_func
(paren
id|nftl-&gt;mbd.mtd
comma
(paren
id|thisEUN
op_star
id|nftl-&gt;EraseSize
)paren
op_plus
(paren
id|block
op_star
l_int|512
)paren
comma
l_int|16
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block
op_eq
l_int|2
)paren
(brace
id|foldmark
op_assign
id|oob.u.c.FoldMark
op_or
id|oob.u.c.FoldMark1
suffix:semicolon
r_if
c_cond
(paren
id|foldmark
op_eq
id|FOLD_MARK_IN_PROGRESS
)paren
(brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;Write Inhibited on EUN %d&bslash;n&quot;
comma
id|thisEUN
)paren
suffix:semicolon
id|inplace
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* There&squot;s no other reason not to do inplace,&n;&t;&t;&t;&t;&t;   except ones that come later. So we don&squot;t need&n;&t;&t;&t;&t;&t;   to preserve inplace */
id|inplace
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|status
op_assign
id|oob.b.Status
op_or
id|oob.b.Status1
suffix:semicolon
id|BlockLastState
(braket
id|block
)braket
op_assign
id|status
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|SECTOR_FREE
suffix:colon
id|BlockFreeFound
(braket
id|block
)braket
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SECTOR_USED
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|BlockFreeFound
(braket
id|block
)braket
)paren
id|BlockMap
(braket
id|block
)braket
op_assign
id|thisEUN
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;SECTOR_USED found after SECTOR_FREE &quot;
l_string|&quot;in Virtual Unit Chain %d for block %d&bslash;n&quot;
comma
id|thisVUC
comma
id|block
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SECTOR_DELETED
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|BlockFreeFound
(braket
id|block
)braket
)paren
id|BlockMap
(braket
id|block
)braket
op_assign
id|BLOCK_NIL
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;SECTOR_DELETED found after SECTOR_FREE &quot;
l_string|&quot;in Virtual Unit Chain %d for block %d&bslash;n&quot;
comma
id|thisVUC
comma
id|block
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SECTOR_IGNORE
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Unknown status for block %d in EUN %d: %x&bslash;n&quot;
comma
id|block
comma
id|thisEUN
comma
id|status
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|silly
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Infinite loop in Virtual Unit Chain 0x%x&bslash;n&quot;
comma
id|thisVUC
)paren
suffix:semicolon
r_return
id|BLOCK_NIL
suffix:semicolon
)brace
id|thisEUN
op_assign
id|nftl-&gt;ReplUnitTable
(braket
id|thisEUN
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inplace
)paren
(brace
multiline_comment|/* We&squot;re being asked to be a fold-in-place. Check&n;&t;&t;   that all blocks which actually have data associated&n;&t;&t;   with them (i.e. BlockMap[block] != BLOCK_NIL) are &n;&t;&t;   either already present or SECTOR_FREE in the target&n;&t;&t;   block. If not, we&squot;re going to have to fold out-of-place&n;&t;&t;   anyway.&n;&t;&t;*/
r_for
c_loop
(paren
id|block
op_assign
l_int|0
suffix:semicolon
id|block
OL
id|nftl-&gt;EraseSize
op_div
l_int|512
suffix:semicolon
id|block
op_increment
)paren
(brace
r_if
c_cond
(paren
id|BlockLastState
(braket
id|block
)braket
op_ne
id|SECTOR_FREE
op_logical_and
id|BlockMap
(braket
id|block
)braket
op_ne
id|BLOCK_NIL
op_logical_and
id|BlockMap
(braket
id|block
)braket
op_ne
id|targetEUN
)paren
(brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;Setting inplace to 0. VUC %d, &quot;
l_string|&quot;block %d was %x lastEUN, &quot;
l_string|&quot;and is in EUN %d (%s) %d&bslash;n&quot;
comma
id|thisVUC
comma
id|block
comma
id|BlockLastState
(braket
id|block
)braket
comma
id|BlockMap
(braket
id|block
)braket
comma
id|BlockMap
(braket
id|block
)braket
op_eq
id|targetEUN
ques
c_cond
l_string|&quot;==&quot;
suffix:colon
l_string|&quot;!=&quot;
comma
id|targetEUN
)paren
suffix:semicolon
id|inplace
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pendingblock
op_ge
(paren
id|thisVUC
op_star
(paren
id|nftl-&gt;EraseSize
op_div
l_int|512
)paren
)paren
op_logical_and
id|pendingblock
OL
(paren
(paren
id|thisVUC
op_plus
l_int|1
)paren
op_star
(paren
id|nftl-&gt;EraseSize
op_div
l_int|512
)paren
)paren
op_logical_and
id|BlockLastState
(braket
id|pendingblock
op_minus
(paren
id|thisVUC
op_star
(paren
id|nftl-&gt;EraseSize
op_div
l_int|512
)paren
)paren
)braket
op_ne
id|SECTOR_FREE
)paren
(brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;Pending write not free in EUN %d. &quot;
l_string|&quot;Folding out of place.&bslash;n&quot;
comma
id|targetEUN
)paren
suffix:semicolon
id|inplace
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|inplace
)paren
(brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;Cannot fold Virtual Unit Chain %d in place. &quot;
l_string|&quot;Trying out-of-place&bslash;n&quot;
comma
id|thisVUC
)paren
suffix:semicolon
multiline_comment|/* We need to find a targetEUN to fold into. */
id|targetEUN
op_assign
id|NFTL_findfreeblock
c_func
(paren
id|nftl
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|targetEUN
op_eq
id|BLOCK_NIL
)paren
(brace
multiline_comment|/* Ouch. Now we&squot;re screwed. We need to do a &n;&t;&t;&t;   fold-in-place of another chain to make room&n;&t;&t;&t;   for this one. We need a better way of selecting&n;&t;&t;&t;   which chain to fold, because makefreeblock will &n;&t;&t;&t;   only ask us to fold the same one again.&n;&t;&t;&t;*/
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;NFTL_findfreeblock(desperate) returns 0xffff.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|BLOCK_NIL
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* We put a fold mark in the chain we are folding only if&n;               we fold in place to help the mount check code. If we do&n;               not fold in place, it is possible to find the valid&n;               chain by selecting the longer one */
id|oob.u.c.FoldMark
op_assign
id|oob.u.c.FoldMark1
op_assign
id|cpu_to_le16
c_func
(paren
id|FOLD_MARK_IN_PROGRESS
)paren
suffix:semicolon
id|oob.u.c.unused
op_assign
l_int|0xffffffff
suffix:semicolon
id|MTD_WRITEOOB
c_func
(paren
id|nftl-&gt;mbd.mtd
comma
(paren
id|nftl-&gt;EraseSize
op_star
id|targetEUN
)paren
op_plus
l_int|2
op_star
l_int|512
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob.u
)paren
suffix:semicolon
)brace
multiline_comment|/* OK. We now know the location of every block in the Virtual Unit Chain,&n;&t;   and the Erase Unit into which we are supposed to be copying.&n;&t;   Go for it.&n;&t;*/
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;Folding chain %d into unit %d&bslash;n&quot;
comma
id|thisVUC
comma
id|targetEUN
)paren
suffix:semicolon
r_for
c_loop
(paren
id|block
op_assign
l_int|0
suffix:semicolon
id|block
OL
id|nftl-&gt;EraseSize
op_div
l_int|512
suffix:semicolon
id|block
op_increment
)paren
(brace
r_int
r_char
id|movebuf
(braket
l_int|512
)braket
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* If it&squot;s in the target EUN already, or if it&squot;s pending write, do nothing */
r_if
c_cond
(paren
id|BlockMap
(braket
id|block
)braket
op_eq
id|targetEUN
op_logical_or
(paren
id|pendingblock
op_eq
(paren
id|thisVUC
op_star
(paren
id|nftl-&gt;EraseSize
op_div
l_int|512
)paren
op_plus
id|block
)paren
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* copy only in non free block (free blocks can only&n;                   happen in case of media errors or deleted blocks) */
r_if
c_cond
(paren
id|BlockMap
(braket
id|block
)braket
op_eq
id|BLOCK_NIL
)paren
r_continue
suffix:semicolon
id|ret
op_assign
id|MTD_READ
c_func
(paren
id|nftl-&gt;mbd.mtd
comma
(paren
id|nftl-&gt;EraseSize
op_star
id|BlockMap
(braket
id|block
)braket
)paren
op_plus
(paren
id|block
op_star
l_int|512
)paren
comma
l_int|512
comma
op_amp
id|retlen
comma
id|movebuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|ret
op_assign
id|MTD_READ
c_func
(paren
id|nftl-&gt;mbd.mtd
comma
(paren
id|nftl-&gt;EraseSize
op_star
id|BlockMap
(braket
id|block
)braket
)paren
op_plus
(paren
id|block
op_star
l_int|512
)paren
comma
l_int|512
comma
op_amp
id|retlen
comma
id|movebuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
op_minus
id|EIO
)paren
id|printk
c_func
(paren
l_string|&quot;Error went away on retry.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|oob
comma
l_int|0xff
comma
r_sizeof
(paren
r_struct
id|nftl_oob
)paren
)paren
suffix:semicolon
id|oob.b.Status
op_assign
id|oob.b.Status1
op_assign
id|SECTOR_USED
suffix:semicolon
id|MTD_WRITEECC
c_func
(paren
id|nftl-&gt;mbd.mtd
comma
(paren
id|nftl-&gt;EraseSize
op_star
id|targetEUN
)paren
op_plus
(paren
id|block
op_star
l_int|512
)paren
comma
l_int|512
comma
op_amp
id|retlen
comma
id|movebuf
comma
(paren
r_char
op_star
)paren
op_amp
id|oob
comma
op_amp
id|nftl-&gt;oobinfo
)paren
suffix:semicolon
)brace
multiline_comment|/* add the header so that it is now a valid chain */
id|oob.u.a.VirtUnitNum
op_assign
id|oob.u.a.SpareVirtUnitNum
op_assign
id|cpu_to_le16
c_func
(paren
id|thisVUC
)paren
suffix:semicolon
id|oob.u.a.ReplUnitNum
op_assign
id|oob.u.a.SpareReplUnitNum
op_assign
l_int|0xffff
suffix:semicolon
id|MTD_WRITEOOB
c_func
(paren
id|nftl-&gt;mbd.mtd
comma
(paren
id|nftl-&gt;EraseSize
op_star
id|targetEUN
)paren
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob.u
)paren
suffix:semicolon
multiline_comment|/* OK. We&squot;ve moved the whole lot into the new block. Now we have to free the original blocks. */
multiline_comment|/* At this point, we have two different chains for this Virtual Unit, and no way to tell &n;&t;   them apart. If we crash now, we get confused. However, both contain the same data, so we&n;&t;   shouldn&squot;t actually lose data in this case. It&squot;s just that when we load up on a medium which&n;&t;   has duplicate chains, we need to free one of the chains because it&squot;s not necessary any more.&n;&t;*/
id|thisEUN
op_assign
id|nftl-&gt;EUNtable
(braket
id|thisVUC
)braket
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;Want to erase&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* For each block in the old chain (except the targetEUN of course), &n;&t;   free it and make it available for future use */
r_while
c_loop
(paren
id|thisEUN
op_le
id|nftl-&gt;lastEUN
op_logical_and
id|thisEUN
op_ne
id|targetEUN
)paren
(brace
r_int
r_int
id|EUNtmp
suffix:semicolon
id|EUNtmp
op_assign
id|nftl-&gt;ReplUnitTable
(braket
id|thisEUN
)braket
suffix:semicolon
r_if
c_cond
(paren
id|NFTL_formatblock
c_func
(paren
id|nftl
comma
id|thisEUN
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* could not erase : mark block as reserved&n;&t;&t;&t; */
id|nftl-&gt;ReplUnitTable
(braket
id|thisEUN
)braket
op_assign
id|BLOCK_RESERVED
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* correctly erased : mark it as free */
id|nftl-&gt;ReplUnitTable
(braket
id|thisEUN
)braket
op_assign
id|BLOCK_FREE
suffix:semicolon
id|nftl-&gt;numfreeEUNs
op_increment
suffix:semicolon
)brace
id|thisEUN
op_assign
id|EUNtmp
suffix:semicolon
)brace
multiline_comment|/* Make this the new start of chain for thisVUC */
id|nftl-&gt;ReplUnitTable
(braket
id|targetEUN
)braket
op_assign
id|BLOCK_NIL
suffix:semicolon
id|nftl-&gt;EUNtable
(braket
id|thisVUC
)braket
op_assign
id|targetEUN
suffix:semicolon
r_return
id|targetEUN
suffix:semicolon
)brace
DECL|function|NFTL_makefreeblock
r_static
id|u16
id|NFTL_makefreeblock
c_func
(paren
r_struct
id|NFTLrecord
op_star
id|nftl
comma
r_int
id|pendingblock
)paren
(brace
multiline_comment|/* This is the part that needs some cleverness applied. &n;&t;   For now, I&squot;m doing the minimum applicable to actually&n;&t;   get the thing to work.&n;&t;   Wear-levelling and other clever stuff needs to be implemented&n;&t;   and we also need to do some assessment of the results when&n;&t;   the system loses power half-way through the routine.&n;&t;*/
id|u16
id|LongestChain
op_assign
l_int|0
suffix:semicolon
id|u16
id|ChainLength
op_assign
l_int|0
comma
id|thislen
suffix:semicolon
id|u16
id|chain
comma
id|EUN
suffix:semicolon
r_for
c_loop
(paren
id|chain
op_assign
l_int|0
suffix:semicolon
id|chain
OL
id|le32_to_cpu
c_func
(paren
id|nftl-&gt;MediaHdr.FormattedSize
)paren
op_div
id|nftl-&gt;EraseSize
suffix:semicolon
id|chain
op_increment
)paren
(brace
id|EUN
op_assign
id|nftl-&gt;EUNtable
(braket
id|chain
)braket
suffix:semicolon
id|thislen
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|EUN
op_le
id|nftl-&gt;lastEUN
)paren
(brace
id|thislen
op_increment
suffix:semicolon
singleline_comment|//printk(&quot;VUC %d reaches len %d with EUN %d&bslash;n&quot;, chain, thislen, EUN);
id|EUN
op_assign
id|nftl-&gt;ReplUnitTable
(braket
id|EUN
)braket
op_amp
l_int|0x7fff
suffix:semicolon
r_if
c_cond
(paren
id|thislen
OG
l_int|0xff00
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Endless loop in Virtual Chain %d: Unit %x&bslash;n&quot;
comma
id|chain
comma
id|EUN
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|thislen
OG
l_int|0xff10
)paren
(brace
multiline_comment|/* Actually, don&squot;t return failure. Just ignore this chain and&n;&t;&t;&t;&t;   get on with it. */
id|thislen
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|thislen
OG
id|ChainLength
)paren
(brace
singleline_comment|//printk(&quot;New longest chain is %d with length %d&bslash;n&quot;, chain, thislen);
id|ChainLength
op_assign
id|thislen
suffix:semicolon
id|LongestChain
op_assign
id|chain
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ChainLength
OL
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;No Virtual Unit Chains available for folding. &quot;
l_string|&quot;Failing request&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
r_return
id|NFTL_foldchain
(paren
id|nftl
comma
id|LongestChain
comma
id|pendingblock
)paren
suffix:semicolon
)brace
multiline_comment|/* NFTL_findwriteunit: Return the unit number into which we can write &n;                       for this block. Make it available if it isn&squot;t already&n;*/
DECL|function|NFTL_findwriteunit
r_static
r_inline
id|u16
id|NFTL_findwriteunit
c_func
(paren
r_struct
id|NFTLrecord
op_star
id|nftl
comma
r_int
id|block
)paren
(brace
id|u16
id|lastEUN
suffix:semicolon
id|u16
id|thisVUC
op_assign
id|block
op_div
(paren
id|nftl-&gt;EraseSize
op_div
l_int|512
)paren
suffix:semicolon
r_int
r_int
id|writeEUN
suffix:semicolon
r_int
r_int
id|blockofs
op_assign
(paren
id|block
op_star
l_int|512
)paren
op_amp
(paren
id|nftl-&gt;EraseSize
op_minus
l_int|1
)paren
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_int
id|silly
comma
id|silly2
op_assign
l_int|3
suffix:semicolon
r_struct
id|nftl_oob
id|oob
suffix:semicolon
r_do
(brace
multiline_comment|/* Scan the media to find a unit in the VUC which has&n;&t;&t;   a free space for the block in question.&n;&t;&t;*/
multiline_comment|/* This condition catches the 0x[7f]fff cases, as well as &n;&t;&t;   being a sanity check for past-end-of-media access&n;&t;&t;*/
id|lastEUN
op_assign
id|BLOCK_NIL
suffix:semicolon
id|writeEUN
op_assign
id|nftl-&gt;EUNtable
(braket
id|thisVUC
)braket
suffix:semicolon
id|silly
op_assign
id|MAX_LOOPS
suffix:semicolon
r_while
c_loop
(paren
id|writeEUN
op_le
id|nftl-&gt;lastEUN
)paren
(brace
r_struct
id|nftl_bci
id|bci
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_int
r_int
id|status
suffix:semicolon
id|lastEUN
op_assign
id|writeEUN
suffix:semicolon
id|MTD_READOOB
c_func
(paren
id|nftl-&gt;mbd.mtd
comma
(paren
id|writeEUN
op_star
id|nftl-&gt;EraseSize
)paren
op_plus
id|blockofs
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|bci
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL2
comma
l_string|&quot;Status of block %d in EUN %d is %x&bslash;n&quot;
comma
id|block
comma
id|writeEUN
comma
id|le16_to_cpu
c_func
(paren
id|bci.Status
)paren
)paren
suffix:semicolon
id|status
op_assign
id|bci.Status
op_or
id|bci.Status1
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|SECTOR_FREE
suffix:colon
r_return
id|writeEUN
suffix:semicolon
r_case
id|SECTOR_DELETED
suffix:colon
r_case
id|SECTOR_USED
suffix:colon
r_case
id|SECTOR_IGNORE
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
singleline_comment|// Invalid block. Don&squot;t use it any more. Must implement.
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|silly
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Infinite loop in Virtual Unit Chain 0x%x&bslash;n&quot;
comma
id|thisVUC
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
multiline_comment|/* Skip to next block in chain */
id|writeEUN
op_assign
id|nftl-&gt;ReplUnitTable
(braket
id|writeEUN
)braket
suffix:semicolon
)brace
multiline_comment|/* OK. We didn&squot;t find one in the existing chain, or there &n;&t;&t;   is no existing chain. */
multiline_comment|/* Try to find an already-free block */
id|writeEUN
op_assign
id|NFTL_findfreeblock
c_func
(paren
id|nftl
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|writeEUN
op_eq
id|BLOCK_NIL
)paren
(brace
multiline_comment|/* That didn&squot;t work - there were no free blocks just&n;&t;&t;&t;   waiting to be picked up. We&squot;re going to have to fold&n;&t;&t;&t;   a chain to make room.&n;&t;&t;&t;*/
multiline_comment|/* First remember the start of this chain */
singleline_comment|//u16 startEUN = nftl-&gt;EUNtable[thisVUC];
singleline_comment|//printk(&quot;Write to VirtualUnitChain %d, calling makefreeblock()&bslash;n&quot;, thisVUC);
id|writeEUN
op_assign
id|NFTL_makefreeblock
c_func
(paren
id|nftl
comma
l_int|0xffff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|writeEUN
op_eq
id|BLOCK_NIL
)paren
(brace
multiline_comment|/* OK, we accept that the above comment is &n;&t;&t;&t;&t;   lying - there may have been free blocks&n;&t;&t;&t;&t;   last time we called NFTL_findfreeblock(),&n;&t;&t;&t;&t;   but they are reserved for when we&squot;re&n;&t;&t;&t;&t;   desperate. Well, now we&squot;re desperate.&n;&t;&t;&t;&t;*/
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;Using desperate==1 to find free EUN to accommodate write to VUC %d&bslash;n&quot;
comma
id|thisVUC
)paren
suffix:semicolon
id|writeEUN
op_assign
id|NFTL_findfreeblock
c_func
(paren
id|nftl
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|writeEUN
op_eq
id|BLOCK_NIL
)paren
(brace
multiline_comment|/* Ouch. This should never happen - we should&n;&t;&t;&t;&t;   always be able to make some room somehow. &n;&t;&t;&t;&t;   If we get here, we&squot;ve allocated more storage &n;&t;&t;&t;&t;   space than actual media, or our makefreeblock&n;&t;&t;&t;&t;   routine is missing something.&n;&t;&t;&t;&t;*/
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Cannot make free space.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|BLOCK_NIL
suffix:semicolon
)brace
singleline_comment|//printk(&quot;Restarting scan&bslash;n&quot;);
id|lastEUN
op_assign
id|BLOCK_NIL
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* We&squot;ve found a free block. Insert it into the chain. */
r_if
c_cond
(paren
id|lastEUN
op_ne
id|BLOCK_NIL
)paren
(brace
id|thisVUC
op_or_assign
l_int|0x8000
suffix:semicolon
multiline_comment|/* It&squot;s a replacement block */
)brace
r_else
(brace
multiline_comment|/* The first block in a new chain */
id|nftl-&gt;EUNtable
(braket
id|thisVUC
)braket
op_assign
id|writeEUN
suffix:semicolon
)brace
multiline_comment|/* set up the actual EUN we&squot;re writing into */
multiline_comment|/* Both in our cache... */
id|nftl-&gt;ReplUnitTable
(braket
id|writeEUN
)braket
op_assign
id|BLOCK_NIL
suffix:semicolon
multiline_comment|/* ... and on the flash itself */
id|MTD_READOOB
c_func
(paren
id|nftl-&gt;mbd.mtd
comma
id|writeEUN
op_star
id|nftl-&gt;EraseSize
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob.u
)paren
suffix:semicolon
id|oob.u.a.VirtUnitNum
op_assign
id|oob.u.a.SpareVirtUnitNum
op_assign
id|cpu_to_le16
c_func
(paren
id|thisVUC
)paren
suffix:semicolon
id|MTD_WRITEOOB
c_func
(paren
id|nftl-&gt;mbd.mtd
comma
id|writeEUN
op_star
id|nftl-&gt;EraseSize
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob.u
)paren
suffix:semicolon
multiline_comment|/* we link the new block to the chain only after the&n;                   block is ready. It avoids the case where the chain&n;                   could point to a free block */
r_if
c_cond
(paren
id|lastEUN
op_ne
id|BLOCK_NIL
)paren
(brace
multiline_comment|/* Both in our cache... */
id|nftl-&gt;ReplUnitTable
(braket
id|lastEUN
)braket
op_assign
id|writeEUN
suffix:semicolon
multiline_comment|/* ... and on the flash itself */
id|MTD_READOOB
c_func
(paren
id|nftl-&gt;mbd.mtd
comma
(paren
id|lastEUN
op_star
id|nftl-&gt;EraseSize
)paren
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob.u
)paren
suffix:semicolon
id|oob.u.a.ReplUnitNum
op_assign
id|oob.u.a.SpareReplUnitNum
op_assign
id|cpu_to_le16
c_func
(paren
id|writeEUN
)paren
suffix:semicolon
id|MTD_WRITEOOB
c_func
(paren
id|nftl-&gt;mbd.mtd
comma
(paren
id|lastEUN
op_star
id|nftl-&gt;EraseSize
)paren
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob.u
)paren
suffix:semicolon
)brace
r_return
id|writeEUN
suffix:semicolon
)brace
r_while
c_loop
(paren
id|silly2
op_decrement
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Error folding to make room for Virtual Unit Chain 0x%x&bslash;n&quot;
comma
id|thisVUC
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
DECL|function|nftl_writeblock
r_static
r_int
id|nftl_writeblock
c_func
(paren
r_struct
id|mtd_blktrans_dev
op_star
id|mbd
comma
r_int
r_int
id|block
comma
r_char
op_star
id|buffer
)paren
(brace
r_struct
id|NFTLrecord
op_star
id|nftl
op_assign
(paren
r_void
op_star
)paren
id|mbd
suffix:semicolon
id|u16
id|writeEUN
suffix:semicolon
r_int
r_int
id|blockofs
op_assign
(paren
id|block
op_star
l_int|512
)paren
op_amp
(paren
id|nftl-&gt;EraseSize
op_minus
l_int|1
)paren
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_struct
id|nftl_oob
id|oob
suffix:semicolon
id|writeEUN
op_assign
id|NFTL_findwriteunit
c_func
(paren
id|nftl
comma
id|block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|writeEUN
op_eq
id|BLOCK_NIL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;NFTL_writeblock(): Cannot find block to write to&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* If we _still_ haven&squot;t got a block to use, we&squot;re screwed */
r_return
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|oob
comma
l_int|0xff
comma
r_sizeof
(paren
r_struct
id|nftl_oob
)paren
)paren
suffix:semicolon
id|oob.b.Status
op_assign
id|oob.b.Status1
op_assign
id|SECTOR_USED
suffix:semicolon
id|MTD_WRITEECC
c_func
(paren
id|nftl-&gt;mbd.mtd
comma
(paren
id|writeEUN
op_star
id|nftl-&gt;EraseSize
)paren
op_plus
id|blockofs
comma
l_int|512
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
id|buffer
comma
(paren
r_char
op_star
)paren
op_amp
id|oob
comma
op_amp
id|nftl-&gt;oobinfo
)paren
suffix:semicolon
multiline_comment|/* need to write SECTOR_USED flags since they are not written in mtd_writeecc */
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_NFTL_RW */
DECL|function|nftl_readblock
r_static
r_int
id|nftl_readblock
c_func
(paren
r_struct
id|mtd_blktrans_dev
op_star
id|mbd
comma
r_int
r_int
id|block
comma
r_char
op_star
id|buffer
)paren
(brace
r_struct
id|NFTLrecord
op_star
id|nftl
op_assign
(paren
r_void
op_star
)paren
id|mbd
suffix:semicolon
id|u16
id|lastgoodEUN
suffix:semicolon
id|u16
id|thisEUN
op_assign
id|nftl-&gt;EUNtable
(braket
id|block
op_div
(paren
id|nftl-&gt;EraseSize
op_div
l_int|512
)paren
)braket
suffix:semicolon
r_int
r_int
id|blockofs
op_assign
(paren
id|block
op_star
l_int|512
)paren
op_amp
(paren
id|nftl-&gt;EraseSize
op_minus
l_int|1
)paren
suffix:semicolon
r_int
r_int
id|status
suffix:semicolon
r_int
id|silly
op_assign
id|MAX_LOOPS
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_struct
id|nftl_bci
id|bci
suffix:semicolon
id|lastgoodEUN
op_assign
id|BLOCK_NIL
suffix:semicolon
r_if
c_cond
(paren
id|thisEUN
op_ne
id|BLOCK_NIL
)paren
(brace
r_while
c_loop
(paren
id|thisEUN
OL
id|nftl-&gt;nb_blocks
)paren
(brace
r_if
c_cond
(paren
id|MTD_READOOB
c_func
(paren
id|nftl-&gt;mbd.mtd
comma
(paren
id|thisEUN
op_star
id|nftl-&gt;EraseSize
)paren
op_plus
id|blockofs
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|bci
)paren
OL
l_int|0
)paren
id|status
op_assign
id|SECTOR_IGNORE
suffix:semicolon
r_else
id|status
op_assign
id|bci.Status
op_or
id|bci.Status1
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|SECTOR_FREE
suffix:colon
multiline_comment|/* no modification of a sector should follow a free sector */
r_goto
id|the_end
suffix:semicolon
r_case
id|SECTOR_DELETED
suffix:colon
id|lastgoodEUN
op_assign
id|BLOCK_NIL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SECTOR_USED
suffix:colon
id|lastgoodEUN
op_assign
id|thisEUN
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SECTOR_IGNORE
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Unknown status for block %ld in EUN %d: %x&bslash;n&quot;
comma
id|block
comma
id|thisEUN
comma
id|status
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|silly
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Infinite loop in Virtual Unit Chain 0x%lx&bslash;n&quot;
comma
id|block
op_div
(paren
id|nftl-&gt;EraseSize
op_div
l_int|512
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|thisEUN
op_assign
id|nftl-&gt;ReplUnitTable
(braket
id|thisEUN
)braket
suffix:semicolon
)brace
)brace
id|the_end
suffix:colon
r_if
c_cond
(paren
id|lastgoodEUN
op_eq
id|BLOCK_NIL
)paren
(brace
multiline_comment|/* the requested block is not on the media, return all 0x00 */
id|memset
c_func
(paren
id|buffer
comma
l_int|0
comma
l_int|512
)paren
suffix:semicolon
)brace
r_else
(brace
id|loff_t
id|ptr
op_assign
(paren
id|lastgoodEUN
op_star
id|nftl-&gt;EraseSize
)paren
op_plus
id|blockofs
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_if
c_cond
(paren
id|MTD_READ
c_func
(paren
id|nftl-&gt;mbd.mtd
comma
id|ptr
comma
l_int|512
comma
op_amp
id|retlen
comma
id|buffer
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|nftl_getgeo
r_static
r_int
id|nftl_getgeo
c_func
(paren
r_struct
id|mtd_blktrans_dev
op_star
id|dev
comma
r_struct
id|hd_geometry
op_star
id|geo
)paren
(brace
r_struct
id|NFTLrecord
op_star
id|nftl
op_assign
(paren
r_void
op_star
)paren
id|dev
suffix:semicolon
id|geo-&gt;heads
op_assign
id|nftl-&gt;heads
suffix:semicolon
id|geo-&gt;sectors
op_assign
id|nftl-&gt;sectors
suffix:semicolon
id|geo-&gt;cylinders
op_assign
id|nftl-&gt;cylinders
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * Module stuff&n; *&n; ****************************************************************************/
DECL|variable|nftl_tr
r_static
r_struct
id|mtd_blktrans_ops
id|nftl_tr
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;nftl&quot;
comma
dot
id|major
op_assign
id|NFTL_MAJOR
comma
dot
id|part_bits
op_assign
id|NFTL_PARTN_BITS
comma
dot
id|getgeo
op_assign
id|nftl_getgeo
comma
dot
id|readsect
op_assign
id|nftl_readblock
comma
macro_line|#ifdef CONFIG_NFTL_RW
dot
id|writesect
op_assign
id|nftl_writeblock
comma
macro_line|#endif
dot
id|add_mtd
op_assign
id|nftl_add_mtd
comma
dot
id|remove_dev
op_assign
id|nftl_remove_dev
comma
dot
id|owner
op_assign
id|THIS_MODULE
comma
)brace
suffix:semicolon
r_extern
r_char
id|nftlmountrev
(braket
)braket
suffix:semicolon
DECL|function|init_nftl
r_static
r_int
id|__init
id|init_nftl
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;NFTL driver: nftlcore.c $Revision: 1.97 $, nftlmount.c %s&bslash;n&quot;
comma
id|nftlmountrev
)paren
suffix:semicolon
r_return
id|register_mtd_blktrans
c_func
(paren
op_amp
id|nftl_tr
)paren
suffix:semicolon
)brace
DECL|function|cleanup_nftl
r_static
r_void
id|__exit
id|cleanup_nftl
c_func
(paren
r_void
)paren
(brace
id|deregister_mtd_blktrans
c_func
(paren
op_amp
id|nftl_tr
)paren
suffix:semicolon
)brace
DECL|variable|init_nftl
id|module_init
c_func
(paren
id|init_nftl
)paren
suffix:semicolon
DECL|variable|cleanup_nftl
id|module_exit
c_func
(paren
id|cleanup_nftl
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;David Woodhouse &lt;dwmw2@infradead.org&gt;, Fabrice Bellard &lt;fabrice.bellard@netgem.com&gt; et al.&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Support code for NAND Flash Translation Layer, used on M-Systems DiskOnChip 2000 and Millennium&quot;
)paren
suffix:semicolon
eof
