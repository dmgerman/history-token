multiline_comment|/*&n; *  drivers/mtd/nand.c&n; *&n; *  Overview:&n; *   This is the generic MTD driver for NAND flash devices. It should be&n; *   capable of working with almost all NAND chips currently available.&n; *   &n; *&t;Additional technical information is available on&n; *&t;http://www.linux-mtd.infradead.org/tech/nand.html&n; *&t;&n; *  Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)&n; * &t;&t;  2002 Thomas Gleixner (tglx@linutronix.de)&n; *&n; *  10-29-2001  Thomas Gleixner (tglx@linutronix.de)&n; * &t;&t;- Changed nand_chip structure for controlline function to&n; *&t;&t;support different hardware structures (Access to&n; *&t;&t;controllines ALE,CLE,NCE via hardware specific function. &n; *&t;&t;- exit out of &quot;failed erase block&quot; changed, to avoid&n; *&t;&t;driver hangup&n; *&t;&t;- init_waitqueue_head added in function nand_scan !!&n; *&n; *  01-30-2002  Thomas Gleixner (tglx@linutronix.de)&n; *&t;&t;change in nand_writev to block invalid vecs entries&n; *&n; *  02-11-2002  Thomas Gleixner (tglx@linutronix.de)&n; *&t;&t;- major rewrite to avoid duplicated code&n; *&t;&t;  common nand_write_page function  &n; *&t;&t;  common get_chip function &n; *&t;&t;- added oob_config structure for out of band layouts&n; *&t;&t;- write_oob changed for partial programming&n; *&t;&t;- read cache for faster access for subsequent reads&n; *&t;&t;from the same page.&n; *&t;&t;- support for different read/write address&n; *&t;&t;- support for device ready/busy line&n; *&t;&t;- read oob for more than one page enabled&n; *&n; *  02-27-2002&t;Thomas Gleixner (tglx@linutronix.de)&n; *&t;&t;- command-delay can be programmed&n; *&t;&t;- fixed exit from erase with callback-function enabled&n; *&n; *  03-21-2002  Thomas Gleixner (tglx@linutronix.de)&n; *&t;&t;- DEBUG improvements provided by Elizabeth Clarke &n; *&t;&t;(eclarke@aminocom.com)&n; *&t;&t;- added zero check for this-&gt;chip_delay&n; *&n; *  04-03-2002  Thomas Gleixner (tglx@linutronix.de)&n; *&t;&t;- added added hw-driver supplied command and wait functions&n; *&t;&t;- changed blocking for erase (erase suspend enabled)&n; *&t;&t;- check pointers before accessing flash provided by&n; *&t;&t;John Hall (john.hall@optionexist.co.uk)&n; *&n; *  04-09-2002  Thomas Gleixner (tglx@linutronix.de)&n; *&t;&t;- nand_wait repaired&n; *&n; *  04-28-2002  Thomas Gleixner (tglx@linutronix.de)&t;&n; *&t;&t;- OOB config defines moved to nand.h &n; *&n; *  08-01-2002  Thomas Gleixner (tglx@linutronix.de)&t;&n; *&t;&t;- changed my mailaddress, added pointer to tech/nand.html&n; *&n; *  08-07-2002 &t;Thomas Gleixner (tglx@linutronix.de)&n; *&t;&t;forced bad block location to byte 5 of OOB, even if&n; *&t;&t;CONFIG_MTD_NAND_ECC_JFFS2 is not set, to prevent&n; *&t;&t;erase /dev/mtdX from erasing bad blocks and destroying&n; *&t;&t;bad block info&n; *&n; *  08-10-2002 &t;Thomas Gleixner (tglx@linutronix.de)&n; *&t;&t;Fixed writing tail of data. Thanks to Alice Hennessy&n; *&t;&t;&lt;ahennessy@mvista.com&gt;.&n; *&n; *  08-10-2002 &t;Thomas Gleixner (tglx@linutronix.de)&n; *&t;&t;nand_read_ecc and nand_write_page restructured to support&n; *&t;&t;hardware ECC. Thanks to Steven Hein (ssh@sgi.com)&n; *&t;&t;for basic implementation and suggestions.&n; *&t;&t;3 new pointers in nand_chip structure:&n; *&t;&t;calculate_ecc, correct_data, enabled_hwecc &t;&t;&t;&t;&t; &n; *&t;&t;forcing all hw-drivers to support page cache&n; *&t;&t;eccvalid_pos is now mandatory&n; *&n; *  08-17-2002&t;tglx: fixed signed/unsigned missmatch in write.c&n; *&t;&t;Thanks to Ken Offer &lt;koffer@arlut.utexas.edu&gt; &t;&n; *&n; *  08-29-2002  tglx: use buffered read/write only for non pagealigned &n; *&t;&t;access, speed up the aligned path by using the fs-buffer&n; *&t;&t;reset chip removed from nand_select(), implicit done&n; *&t;&t;only, when erase is interrupted&n; *&t;&t;waitfuntion use yield, instead of schedule_timeout&n; *&t;&t;support for 6byte/512byte hardware ECC&n; *&t;&t;read_ecc, write_ecc extended for different oob-layout&n; *&t;&t;selections: Implemented NAND_NONE_OOB, NAND_JFFS2_OOB,&n; *&t;&t;NAND_YAFFS_OOB. fs-driver gives one of these constants&n; *&t;&t;to select the oob-layout fitting the filesystem.&n; *&t;&t;oobdata can be read together with the raw data, when&n; *&t;&t;the fs-driver supplies a big enough buffer.&n; *&t;&t;size = 12 * number of pages to read (256B pagesize)&n; *&t;&t;       24 * number of pages to read (512B pagesize)&n; *&t;&t;the buffer contains 8/16 byte oobdata and 4/8 byte&n; *&t;&t;returncode from calculate_ecc&n; *&t;&t;oobdata can be given from filesystem to program them&n; *&t;&t;in one go together with the raw data. ECC codes are&n; *&t;&t;filled in at the place selected by oobsel.&n; *&n; *  09-04-2002  tglx: fixed write_verify (John Hall (john.hall@optionexist.co.uk))&n; *&n; *  11-11-2002  tglx: fixed debug output in nand_write_page &n; *&t;&t;(John Hall (john.hall@optionexist.co.uk))&n; *&n; *  11-25-2002  tglx: Moved device ID/ manufacturer ID from nand_ids.h&n; *&t;&t;Splitted device ID and manufacturer ID table. &n; *&t;&t;Removed CONFIG_MTD_NAND_ECC, as it defaults to ECC_NONE for&n; *&t;&t;mtd-&gt;read / mtd-&gt;write and is controllable by the fs driver&n; *&t;&t;for mtd-&gt;read_ecc / mtd-&gt;write_ecc&n; *&t;&t;some minor cleanups&n; *&n; *  12-05-2002  tglx: Dave Ellis (DGE@sixnetio) provided the fix for&n; *&t;&t;WRITE_VERIFY long time ago. Thanks for remembering me.&t;&n; *&n; *  02-14-2003  tglx: Reject non page aligned writes &t;&n; *&t;&t;Fixed ecc select in nand_write_page to match semantics. &n; *&n; *  02-18-2003&t;tglx: Changed oobsel to pointer. Added a default oob-selector&n; *&t;&t;&t;&n; *  02-18-2003&t;tglx: Implemented oobsel again. Now it uses a pointer to&n; +&t;&t;a structure, which will be supplied by a filesystem driver&n; *&t;&t;If NULL is given, then the defaults (none or defaults&n; *&t;&t;supplied by ioctl (MEMSETOOBSEL) are used.&n; *&t;&t;For partitions the partition defaults are used (mtdpart.c)&n; *&n; *  06-04-2003  tglx: fix compile errors and fix write verify problem for&n; *&t;&t;some chips, which need either a delay between the readback&n; *&t;&t;and the next write command or have the CE removed. The&n; *&t;&t;CE disable/enable is much faster than a 20us delay and&n; *&t;&t;it should work on all available chips.&n; *&t;&n; * $Id: nand.c,v 1.46 2003/06/04 17:10:36 gleixner Exp $&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License version 2 as&n; * published by the Free Software Foundation.&n; *&n; */
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/mtd/nand.h&gt;
macro_line|#include &lt;linux/mtd/nand_ecc.h&gt;
macro_line|#include &lt;linux/mtd/compatmac.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/io.h&gt;
multiline_comment|/*&n; * Macros for low-level register control&n; */
DECL|macro|nand_select
mdefine_line|#define nand_select()&t;this-&gt;hwcontrol(NAND_CTL_SETNCE);
DECL|macro|nand_deselect
mdefine_line|#define nand_deselect() this-&gt;hwcontrol(NAND_CTL_CLRNCE);
multiline_comment|/*&n; * NAND low-level MTD interface functions&n; */
r_static
r_int
id|nand_read
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|nand_read_ecc
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
comma
id|u_char
op_star
id|eccbuf
comma
r_struct
id|nand_oobinfo
op_star
id|oobsel
)paren
suffix:semicolon
r_static
r_int
id|nand_read_oob
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|nand_write
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|nand_write_ecc
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
comma
id|u_char
op_star
id|eccbuf
comma
r_struct
id|nand_oobinfo
op_star
id|oobsel
)paren
suffix:semicolon
r_static
r_int
id|nand_write_oob
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|nand_writev
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
r_struct
id|iovec
op_star
id|vecs
comma
r_int
r_int
id|count
comma
id|loff_t
id|to
comma
r_int
op_star
id|retlen
)paren
suffix:semicolon
r_static
r_int
id|nand_writev_ecc
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
r_struct
id|iovec
op_star
id|vecs
comma
r_int
r_int
id|count
comma
id|loff_t
id|to
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|eccbuf
comma
r_struct
id|nand_oobinfo
op_star
id|oobsel
)paren
suffix:semicolon
r_static
r_int
id|nand_erase
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|erase_info
op_star
id|instr
)paren
suffix:semicolon
r_static
r_void
id|nand_sync
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
suffix:semicolon
r_static
r_int
id|nand_write_page
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|nand_chip
op_star
id|this
comma
r_int
id|page
comma
id|u_char
op_star
id|oob_buf
comma
r_struct
id|nand_oobinfo
op_star
id|oobsel
)paren
suffix:semicolon
multiline_comment|/*&n; * Send command to NAND device&n; */
DECL|function|nand_command
r_static
r_void
id|nand_command
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|command
comma
r_int
id|column
comma
r_int
id|page_addr
)paren
(brace
r_register
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_register
r_int
r_int
id|NAND_IO_ADDR
op_assign
id|this-&gt;IO_ADDR_W
suffix:semicolon
multiline_comment|/* Begin command latch cycle */
id|this-&gt;hwcontrol
(paren
id|NAND_CTL_SETCLE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Write out the command to the device.&n;&t; */
r_if
c_cond
(paren
id|command
op_ne
id|NAND_CMD_SEQIN
)paren
id|writeb
(paren
id|command
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|mtd-&gt;oobblock
op_eq
l_int|256
op_logical_and
id|column
op_ge
l_int|256
)paren
(brace
id|column
op_sub_assign
l_int|256
suffix:semicolon
id|writeb
(paren
id|NAND_CMD_READOOB
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
id|writeb
(paren
id|NAND_CMD_SEQIN
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mtd-&gt;oobblock
op_eq
l_int|512
op_logical_and
id|column
op_ge
l_int|256
)paren
(brace
r_if
c_cond
(paren
id|column
OL
l_int|512
)paren
(brace
id|column
op_sub_assign
l_int|256
suffix:semicolon
id|writeb
(paren
id|NAND_CMD_READ1
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
id|writeb
(paren
id|NAND_CMD_SEQIN
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
)brace
r_else
(brace
id|column
op_sub_assign
l_int|512
suffix:semicolon
id|writeb
(paren
id|NAND_CMD_READOOB
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
id|writeb
(paren
id|NAND_CMD_SEQIN
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|writeb
(paren
id|NAND_CMD_READ0
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
id|writeb
(paren
id|NAND_CMD_SEQIN
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Set ALE and clear CLE to start address cycle */
id|this-&gt;hwcontrol
(paren
id|NAND_CTL_CLRCLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|column
op_ne
op_minus
l_int|1
op_logical_or
id|page_addr
op_ne
op_minus
l_int|1
)paren
(brace
id|this-&gt;hwcontrol
(paren
id|NAND_CTL_SETALE
)paren
suffix:semicolon
multiline_comment|/* Serially input address */
r_if
c_cond
(paren
id|column
op_ne
op_minus
l_int|1
)paren
id|writeb
(paren
id|column
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page_addr
op_ne
op_minus
l_int|1
)paren
(brace
id|writeb
(paren
(paren
r_int
r_char
)paren
(paren
id|page_addr
op_amp
l_int|0xff
)paren
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
id|writeb
(paren
(paren
r_int
r_char
)paren
(paren
(paren
id|page_addr
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
multiline_comment|/* One more address cycle for higher density devices */
r_if
c_cond
(paren
id|mtd-&gt;size
op_amp
l_int|0x0c000000
)paren
id|writeb
(paren
(paren
r_int
r_char
)paren
(paren
(paren
id|page_addr
op_rshift
l_int|16
)paren
op_amp
l_int|0x0f
)paren
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
)brace
multiline_comment|/* Latch in address */
id|this-&gt;hwcontrol
(paren
id|NAND_CTL_CLRALE
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * program and erase have their own busy handlers &n;&t; * status and sequential in needs no delay&n;&t;*/
r_switch
c_cond
(paren
id|command
)paren
(brace
r_case
id|NAND_CMD_PAGEPROG
suffix:colon
r_case
id|NAND_CMD_ERASE1
suffix:colon
r_case
id|NAND_CMD_ERASE2
suffix:colon
r_case
id|NAND_CMD_SEQIN
suffix:colon
r_case
id|NAND_CMD_STATUS
suffix:colon
r_return
suffix:semicolon
r_case
id|NAND_CMD_RESET
suffix:colon
r_if
c_cond
(paren
id|this-&gt;dev_ready
)paren
r_break
suffix:semicolon
id|this-&gt;hwcontrol
(paren
id|NAND_CTL_SETCLE
)paren
suffix:semicolon
id|writeb
(paren
id|NAND_CMD_STATUS
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
id|this-&gt;hwcontrol
(paren
id|NAND_CTL_CLRCLE
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|readb
(paren
id|this-&gt;IO_ADDR_R
)paren
op_amp
l_int|0x40
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* This applies to read commands */
r_default
suffix:colon
(brace
)brace
multiline_comment|/* &n;&t;&t; * If we don&squot;t have access to the busy pin, we apply the given&n;&t;&t; * command delay&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;dev_ready
)paren
(brace
id|udelay
(paren
id|this-&gt;chip_delay
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* wait until command is processed */
r_while
c_loop
(paren
op_logical_neg
id|this
op_member_access_from_pointer
id|dev_ready
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get chip for selected access&n; */
DECL|function|nand_get_chip
r_static
r_inline
r_void
id|nand_get_chip
(paren
r_struct
id|nand_chip
op_star
id|this
comma
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|new_state
comma
r_int
op_star
id|erase_state
)paren
(brace
id|DECLARE_WAITQUEUE
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Grab the lock and see if the device is available &n;&t; * For erasing, we keep the spinlock until the&n;&t; * erase command is written. &n;&t;*/
id|retry
suffix:colon
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;state
op_eq
id|FL_READY
)paren
(brace
id|this-&gt;state
op_assign
id|new_state
suffix:semicolon
r_if
c_cond
(paren
id|new_state
op_ne
id|FL_ERASING
)paren
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|this-&gt;state
op_eq
id|FL_ERASING
)paren
(brace
r_if
c_cond
(paren
id|new_state
op_ne
id|FL_ERASING
)paren
(brace
id|this-&gt;state
op_assign
id|new_state
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|nand_select
(paren
)paren
suffix:semicolon
multiline_comment|/* select in any case */
id|this
op_member_access_from_pointer
id|cmdfunc
c_func
(paren
id|mtd
comma
id|NAND_CMD_RESET
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|set_current_state
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
(paren
op_amp
id|this-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|schedule
(paren
)paren
suffix:semicolon
id|remove_wait_queue
(paren
op_amp
id|this-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for command done. This applies to erase and program only&n; * Erase can take up to 400ms and program up to 20ms according to &n; * general NAND and SmartMedia specs&n; *&n;*/
DECL|function|nand_wait
r_static
r_int
id|nand_wait
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|nand_chip
op_star
id|this
comma
r_int
id|state
)paren
(brace
r_int
r_int
id|timeo
op_assign
id|jiffies
suffix:semicolon
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
id|FL_ERASING
)paren
id|timeo
op_add_assign
(paren
id|HZ
op_star
l_int|400
)paren
op_div
l_int|1000
suffix:semicolon
r_else
id|timeo
op_add_assign
(paren
id|HZ
op_star
l_int|20
)paren
op_div
l_int|1000
suffix:semicolon
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_STATUS
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|timeo
)paren
)paren
(brace
multiline_comment|/* Check, if we were interrupted */
r_if
c_cond
(paren
id|this-&gt;state
op_ne
id|state
)paren
(brace
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|this-&gt;dev_ready
)paren
(brace
r_if
c_cond
(paren
id|this-&gt;dev_ready
(paren
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|readb
(paren
id|this-&gt;IO_ADDR_R
)paren
op_amp
l_int|0x40
)paren
r_break
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|yield
(paren
)paren
suffix:semicolon
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
)brace
id|status
op_assign
(paren
r_int
)paren
id|readb
(paren
id|this-&gt;IO_ADDR_R
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Nand_page_program function is used for write and writev !&n; *&t;This function will always program a full page of data&n; *&t;If you call it with a non page aligned buffer, you&squot;re lost :)&n; */
DECL|function|nand_write_page
r_static
r_int
id|nand_write_page
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|nand_chip
op_star
id|this
comma
r_int
id|page
comma
id|u_char
op_star
id|oob_buf
comma
r_struct
id|nand_oobinfo
op_star
id|oobsel
)paren
(brace
r_int
id|i
comma
id|status
suffix:semicolon
id|u_char
id|ecc_code
(braket
l_int|6
)braket
comma
op_star
id|oob_data
suffix:semicolon
r_int
id|eccmode
op_assign
id|oobsel-&gt;useecc
ques
c_cond
id|this-&gt;eccmode
suffix:colon
id|NAND_ECC_NONE
suffix:semicolon
r_int
op_star
id|oob_config
op_assign
id|oobsel-&gt;eccpos
suffix:semicolon
multiline_comment|/* pad oob area, if we have no oob buffer from fs-driver */
r_if
c_cond
(paren
op_logical_neg
id|oob_buf
)paren
(brace
id|oob_data
op_assign
op_amp
id|this-&gt;data_buf
(braket
id|mtd-&gt;oobblock
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mtd-&gt;oobsize
suffix:semicolon
id|i
op_increment
)paren
id|oob_data
(braket
id|i
)braket
op_assign
l_int|0xff
suffix:semicolon
)brace
r_else
id|oob_data
op_assign
id|oob_buf
suffix:semicolon
multiline_comment|/* Send command to begin auto page programming */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_SEQIN
comma
l_int|0x00
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* Write out complete page of data, take care of eccmode */
r_switch
c_cond
(paren
id|eccmode
)paren
(brace
multiline_comment|/* No ecc and software ecc 3/256, write all */
r_case
id|NAND_ECC_NONE
suffix:colon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;Writing data without ECC to NAND-FLASH is not recommended&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mtd-&gt;oobblock
suffix:semicolon
id|i
op_increment
)paren
id|writeb
(paren
id|this-&gt;data_poi
(braket
id|i
)braket
comma
id|this-&gt;IO_ADDR_W
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_ECC_SOFT
suffix:colon
id|this-&gt;calculate_ecc
(paren
op_amp
id|this-&gt;data_poi
(braket
l_int|0
)braket
comma
op_amp
(paren
id|ecc_code
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
id|oob_data
(braket
id|oob_config
(braket
id|i
)braket
)braket
op_assign
id|ecc_code
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Calculate and write the second ECC for 512 Byte page size */
r_if
c_cond
(paren
id|mtd-&gt;oobblock
op_eq
l_int|512
)paren
(brace
id|this-&gt;calculate_ecc
(paren
op_amp
id|this-&gt;data_poi
(braket
l_int|256
)braket
comma
op_amp
(paren
id|ecc_code
(braket
l_int|3
)braket
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|3
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|oob_data
(braket
id|oob_config
(braket
id|i
)braket
)braket
op_assign
id|ecc_code
(braket
id|i
)braket
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mtd-&gt;oobblock
suffix:semicolon
id|i
op_increment
)paren
id|writeb
(paren
id|this-&gt;data_poi
(braket
id|i
)braket
comma
id|this-&gt;IO_ADDR_W
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Hardware ecc 3 byte / 256 data, write first half, get ecc, then second, if 512 byte pagesize */
r_case
id|NAND_ECC_HW3_256
suffix:colon
id|this-&gt;enable_hwecc
(paren
id|NAND_ECC_WRITE
)paren
suffix:semicolon
multiline_comment|/* enable hardware ecc logic for write */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mtd-&gt;eccsize
suffix:semicolon
id|i
op_increment
)paren
id|writeb
(paren
id|this-&gt;data_poi
(braket
id|i
)braket
comma
id|this-&gt;IO_ADDR_W
)paren
suffix:semicolon
id|this-&gt;calculate_ecc
(paren
l_int|NULL
comma
op_amp
(paren
id|ecc_code
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
id|oob_data
(braket
id|oob_config
(braket
id|i
)braket
)braket
op_assign
id|ecc_code
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|mtd-&gt;oobblock
op_eq
l_int|512
)paren
(brace
id|this-&gt;enable_hwecc
(paren
id|NAND_ECC_WRITE
)paren
suffix:semicolon
multiline_comment|/* enable hardware ecc logic for write*/
r_for
c_loop
(paren
id|i
op_assign
id|mtd-&gt;eccsize
suffix:semicolon
id|i
OL
id|mtd-&gt;oobblock
suffix:semicolon
id|i
op_increment
)paren
id|writeb
(paren
id|this-&gt;data_poi
(braket
id|i
)braket
comma
id|this-&gt;IO_ADDR_W
)paren
suffix:semicolon
id|this-&gt;calculate_ecc
(paren
l_int|NULL
comma
op_amp
(paren
id|ecc_code
(braket
l_int|3
)braket
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|3
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|oob_data
(braket
id|oob_config
(braket
id|i
)braket
)braket
op_assign
id|ecc_code
(braket
id|i
)braket
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* Hardware ecc 3 byte / 512 byte data, write full page */
r_case
id|NAND_ECC_HW3_512
suffix:colon
id|this-&gt;enable_hwecc
(paren
id|NAND_ECC_WRITE
)paren
suffix:semicolon
multiline_comment|/* enable hardware ecc logic */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mtd-&gt;oobblock
suffix:semicolon
id|i
op_increment
)paren
id|writeb
(paren
id|this-&gt;data_poi
(braket
id|i
)braket
comma
id|this-&gt;IO_ADDR_W
)paren
suffix:semicolon
id|this-&gt;calculate_ecc
(paren
l_int|NULL
comma
op_amp
(paren
id|ecc_code
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
id|oob_data
(braket
id|oob_config
(braket
id|i
)braket
)braket
op_assign
id|ecc_code
(braket
id|i
)braket
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Hardware ecc 6 byte / 512 byte data, write full page */
r_case
id|NAND_ECC_HW6_512
suffix:colon
id|this-&gt;enable_hwecc
(paren
id|NAND_ECC_WRITE
)paren
suffix:semicolon
multiline_comment|/* enable hardware ecc logic */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mtd-&gt;oobblock
suffix:semicolon
id|i
op_increment
)paren
id|writeb
(paren
id|this-&gt;data_poi
(braket
id|i
)braket
comma
id|this-&gt;IO_ADDR_W
)paren
suffix:semicolon
id|this-&gt;calculate_ecc
(paren
l_int|NULL
comma
op_amp
(paren
id|ecc_code
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|oob_data
(braket
id|oob_config
(braket
id|i
)braket
)braket
op_assign
id|ecc_code
(braket
id|i
)braket
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;Invalid NAND_ECC_MODE %d&bslash;n&quot;
comma
id|this-&gt;eccmode
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Write out OOB data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mtd-&gt;oobsize
suffix:semicolon
id|i
op_increment
)paren
id|writeb
(paren
id|oob_data
(braket
id|i
)braket
comma
id|this-&gt;IO_ADDR_W
)paren
suffix:semicolon
multiline_comment|/* Send command to actually program the data */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_PAGEPROG
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* call wait ready function */
id|status
op_assign
id|this-&gt;waitfunc
(paren
id|mtd
comma
id|this
comma
id|FL_WRITING
)paren
suffix:semicolon
multiline_comment|/* See if device thinks it succeeded */
r_if
c_cond
(paren
id|status
op_amp
l_int|0x01
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;%s: &quot;
l_string|&quot;Failed write, page 0x%08x, &quot;
comma
id|__FUNCTION__
comma
id|page
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
multiline_comment|/*&n;&t; * The NAND device assumes that it is always writing to&n;&t; * a cleanly erased page. Hence, it performs its internal&n;&t; * write verification only on bits that transitioned from&n;&t; * 1 to 0. The device does NOT verify the whole page on a&n;&t; * byte by byte basis. It is possible that the page was&n;&t; * not completely erased or the page is becoming unusable&n;&t; * due to wear. The read with ECC would catch the error&n;&t; * later when the ECC page check fails, but we would rather&n;&t; * catch it early in the page write stage. Better to write&n;&t; * no data than invalid data.&n;&t; */
multiline_comment|/* Send command to read back the page */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_READ0
comma
l_int|0
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* Loop through and verify the data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mtd-&gt;oobblock
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|this-&gt;data_poi
(braket
id|i
)braket
op_ne
id|readb
(paren
id|this-&gt;IO_ADDR_R
)paren
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;%s: &quot;
l_string|&quot;Failed write verify, page 0x%08x &quot;
comma
id|__FUNCTION__
comma
id|page
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
multiline_comment|/* check, if we have a fs-supplied oob-buffer */
r_if
c_cond
(paren
id|oob_buf
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mtd-&gt;oobsize
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|oob_data
(braket
id|i
)braket
op_ne
id|readb
(paren
id|this-&gt;IO_ADDR_R
)paren
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;%s: &quot;
l_string|&quot;Failed write verify, page 0x%08x &quot;
comma
id|__FUNCTION__
comma
id|page
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|eccmode
op_ne
id|NAND_ECC_NONE
)paren
(brace
r_int
id|ecc_bytes
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|this-&gt;eccmode
)paren
(brace
r_case
id|NAND_ECC_SOFT
suffix:colon
r_case
id|NAND_ECC_HW3_256
suffix:colon
id|ecc_bytes
op_assign
(paren
id|mtd-&gt;oobblock
op_eq
l_int|512
)paren
ques
c_cond
l_int|6
suffix:colon
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_ECC_HW3_512
suffix:colon
id|ecc_bytes
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_ECC_HW6_512
suffix:colon
id|ecc_bytes
op_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mtd-&gt;oobsize
suffix:semicolon
id|i
op_increment
)paren
id|oob_data
(braket
id|i
)braket
op_assign
id|readb
(paren
id|this-&gt;IO_ADDR_R
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ecc_bytes
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|oob_data
(braket
id|oob_config
(braket
id|i
)braket
)braket
op_ne
id|ecc_code
(braket
id|i
)braket
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;%s: Failed ECC write &quot;
l_string|&quot;verify, page 0x%08x, &quot;
l_string|&quot;%6i bytes were succesful&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|page
comma
id|i
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* &n;&t; * Terminate the read command. This is faster than sending a reset command or &n;&t; * applying a 20us delay before issuing the next programm sequence.&n;&t; * This is not a problem for all chips, but I have found a bunch of them.&n;&t; */
id|nand_deselect
c_func
(paren
)paren
suffix:semicolon
id|nand_select
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;*&t;Use NAND read ECC&n;*/
DECL|function|nand_read
r_static
r_int
id|nand_read
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
(brace
r_return
(paren
id|nand_read_ecc
(paren
id|mtd
comma
id|from
comma
id|len
comma
id|retlen
comma
id|buf
comma
l_int|NULL
comma
l_int|NULL
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAND read with ECC&n; */
DECL|function|nand_read_ecc
r_static
r_int
id|nand_read_ecc
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
comma
id|u_char
op_star
id|oob_buf
comma
r_struct
id|nand_oobinfo
op_star
id|oobsel
)paren
(brace
r_int
id|j
comma
id|col
comma
id|page
comma
id|end
comma
id|ecc
suffix:semicolon
r_int
id|erase_state
op_assign
l_int|0
suffix:semicolon
r_int
id|read
op_assign
l_int|0
comma
id|oob
op_assign
l_int|0
comma
id|ecc_status
op_assign
l_int|0
comma
id|ecc_failed
op_assign
l_int|0
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|u_char
op_star
id|data_poi
comma
op_star
id|oob_data
op_assign
id|oob_buf
suffix:semicolon
id|u_char
id|ecc_calc
(braket
l_int|6
)braket
suffix:semicolon
id|u_char
id|ecc_code
(braket
l_int|6
)braket
suffix:semicolon
r_int
id|eccmode
suffix:semicolon
r_int
op_star
id|oob_config
suffix:semicolon
singleline_comment|// use chip default if zero
r_if
c_cond
(paren
id|oobsel
op_eq
l_int|NULL
)paren
id|oobsel
op_assign
op_amp
id|mtd-&gt;oobinfo
suffix:semicolon
id|eccmode
op_assign
id|oobsel-&gt;useecc
ques
c_cond
id|this-&gt;eccmode
suffix:colon
id|NAND_ECC_NONE
suffix:semicolon
id|oob_config
op_assign
id|oobsel-&gt;eccpos
suffix:semicolon
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;nand_read_ecc: from = 0x%08x, len = %i&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|from
comma
(paren
r_int
)paren
id|len
)paren
suffix:semicolon
multiline_comment|/* Do not allow reads past end of device */
r_if
c_cond
(paren
(paren
id|from
op_plus
id|len
)paren
OG
id|mtd-&gt;size
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_read_ecc: Attempt read beyond end of device&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Grab the lock and see if the device is available */
id|nand_get_chip
(paren
id|this
comma
id|mtd
comma
id|FL_READING
comma
op_amp
id|erase_state
)paren
suffix:semicolon
multiline_comment|/* Select the NAND device */
id|nand_select
(paren
)paren
suffix:semicolon
multiline_comment|/* First we calculate the starting page */
id|page
op_assign
id|from
op_rshift
id|this-&gt;page_shift
suffix:semicolon
multiline_comment|/* Get raw starting column */
id|col
op_assign
id|from
op_amp
(paren
id|mtd-&gt;oobblock
op_minus
l_int|1
)paren
suffix:semicolon
id|end
op_assign
id|mtd-&gt;oobblock
suffix:semicolon
id|ecc
op_assign
id|mtd-&gt;eccsize
suffix:semicolon
multiline_comment|/* Send the read command */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_READ0
comma
l_int|0x00
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* Loop until all data read */
r_while
c_loop
(paren
id|read
OL
id|len
)paren
(brace
multiline_comment|/* If we have consequent page reads, apply delay or wait for ready/busy pin */
r_if
c_cond
(paren
id|read
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;dev_ready
)paren
id|udelay
(paren
id|this-&gt;chip_delay
)paren
suffix:semicolon
r_else
r_while
c_loop
(paren
op_logical_neg
id|this
op_member_access_from_pointer
id|dev_ready
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * If the read is not page aligned, we have to read into data buffer&n;&t;&t; * due to ecc, else we read into return buffer direct&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|col
op_logical_and
(paren
id|len
op_minus
id|read
)paren
op_ge
id|end
)paren
id|data_poi
op_assign
op_amp
id|buf
(braket
id|read
)braket
suffix:semicolon
r_else
id|data_poi
op_assign
id|this-&gt;data_buf
suffix:semicolon
multiline_comment|/* get oob area, if we have no oob buffer from fs-driver */
r_if
c_cond
(paren
op_logical_neg
id|oob_buf
)paren
(brace
id|oob_data
op_assign
op_amp
id|this-&gt;data_buf
(braket
id|end
)braket
suffix:semicolon
id|oob
op_assign
l_int|0
suffix:semicolon
)brace
id|j
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|eccmode
)paren
(brace
r_case
id|NAND_ECC_NONE
suffix:colon
multiline_comment|/* No ECC, Read in a page */
id|printk
(paren
id|KERN_WARNING
l_string|&quot;Reading data from NAND FLASH without ECC is not recommended&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|j
OL
id|end
)paren
id|data_poi
(braket
id|j
op_increment
)braket
op_assign
id|readb
(paren
id|this-&gt;IO_ADDR_R
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_ECC_SOFT
suffix:colon
multiline_comment|/* Software ECC 3/256: Read in a page + oob data */
r_while
c_loop
(paren
id|j
OL
id|end
)paren
id|data_poi
(braket
id|j
op_increment
)braket
op_assign
id|readb
(paren
id|this-&gt;IO_ADDR_R
)paren
suffix:semicolon
id|this-&gt;calculate_ecc
(paren
op_amp
id|data_poi
(braket
l_int|0
)braket
comma
op_amp
id|ecc_calc
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mtd-&gt;oobblock
op_eq
l_int|512
)paren
id|this-&gt;calculate_ecc
(paren
op_amp
id|data_poi
(braket
l_int|256
)braket
comma
op_amp
id|ecc_calc
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_ECC_HW3_256
suffix:colon
multiline_comment|/* Hardware ECC 3 byte /256 byte data: Read in first 256 byte, get ecc, */
id|this-&gt;enable_hwecc
(paren
id|NAND_ECC_READ
)paren
suffix:semicolon
r_while
c_loop
(paren
id|j
OL
id|ecc
)paren
id|data_poi
(braket
id|j
op_increment
)braket
op_assign
id|readb
(paren
id|this-&gt;IO_ADDR_R
)paren
suffix:semicolon
id|this-&gt;calculate_ecc
(paren
op_amp
id|data_poi
(braket
l_int|0
)braket
comma
op_amp
id|ecc_calc
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* read from hardware */
r_if
c_cond
(paren
id|mtd-&gt;oobblock
op_eq
l_int|512
)paren
(brace
multiline_comment|/* read second, if pagesize = 512 */
id|this-&gt;enable_hwecc
(paren
id|NAND_ECC_READ
)paren
suffix:semicolon
r_while
c_loop
(paren
id|j
OL
id|end
)paren
id|data_poi
(braket
id|j
op_increment
)braket
op_assign
id|readb
(paren
id|this-&gt;IO_ADDR_R
)paren
suffix:semicolon
id|this-&gt;calculate_ecc
(paren
op_amp
id|data_poi
(braket
l_int|256
)braket
comma
op_amp
id|ecc_calc
(braket
l_int|3
)braket
)paren
suffix:semicolon
multiline_comment|/* read from hardware */
)brace
r_break
suffix:semicolon
r_case
id|NAND_ECC_HW3_512
suffix:colon
r_case
id|NAND_ECC_HW6_512
suffix:colon
multiline_comment|/* Hardware ECC 3/6 byte / 512 byte data : Read in a page  */
id|this-&gt;enable_hwecc
(paren
id|NAND_ECC_READ
)paren
suffix:semicolon
r_while
c_loop
(paren
id|j
OL
id|end
)paren
id|data_poi
(braket
id|j
op_increment
)braket
op_assign
id|readb
(paren
id|this-&gt;IO_ADDR_R
)paren
suffix:semicolon
id|this-&gt;calculate_ecc
(paren
op_amp
id|data_poi
(braket
l_int|0
)braket
comma
op_amp
id|ecc_calc
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* read from hardware */
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;Invalid NAND_ECC_MODE %d&bslash;n&quot;
comma
id|this-&gt;eccmode
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* read oobdata */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|mtd-&gt;oobsize
suffix:semicolon
id|j
op_increment
)paren
id|oob_data
(braket
id|oob
op_plus
id|j
)braket
op_assign
id|readb
(paren
id|this-&gt;IO_ADDR_R
)paren
suffix:semicolon
multiline_comment|/* Skip ECC, if not active */
r_if
c_cond
(paren
id|eccmode
op_eq
id|NAND_ECC_NONE
)paren
r_goto
id|readdata
suffix:semicolon
multiline_comment|/* Pick the ECC bytes out of the oob data */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|6
suffix:semicolon
id|j
op_increment
)paren
id|ecc_code
(braket
id|j
)braket
op_assign
id|oob_data
(braket
id|oob
op_plus
id|oob_config
(braket
id|j
)braket
)braket
suffix:semicolon
multiline_comment|/* correct data, if neccecary */
id|ecc_status
op_assign
id|this-&gt;correct_data
(paren
op_amp
id|data_poi
(braket
l_int|0
)braket
comma
op_amp
id|ecc_code
(braket
l_int|0
)braket
comma
op_amp
id|ecc_calc
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* check, if we have a fs supplied oob-buffer */
r_if
c_cond
(paren
id|oob_buf
)paren
(brace
id|oob
op_add_assign
id|mtd-&gt;oobsize
suffix:semicolon
op_star
(paren
(paren
r_int
op_star
)paren
op_amp
id|oob_data
(braket
id|oob
)braket
)paren
op_assign
id|ecc_status
suffix:semicolon
id|oob
op_add_assign
r_sizeof
(paren
r_int
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ecc_status
op_eq
op_minus
l_int|1
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_read_ecc: &quot;
l_string|&quot;Failed ECC read, page 0x%08x&bslash;n&quot;
comma
id|page
)paren
suffix:semicolon
id|ecc_failed
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mtd-&gt;oobblock
op_eq
l_int|512
op_logical_and
id|eccmode
op_ne
id|NAND_ECC_HW3_512
)paren
(brace
id|ecc_status
op_assign
id|this-&gt;correct_data
(paren
op_amp
id|data_poi
(braket
l_int|256
)braket
comma
op_amp
id|ecc_code
(braket
l_int|3
)braket
comma
op_amp
id|ecc_calc
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oob_buf
)paren
(brace
op_star
(paren
(paren
r_int
op_star
)paren
op_amp
id|oob_data
(braket
id|oob
)braket
)paren
op_assign
id|ecc_status
suffix:semicolon
id|oob
op_add_assign
r_sizeof
(paren
r_int
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ecc_status
op_eq
op_minus
l_int|1
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_read_ecc: &quot;
l_string|&quot;Failed ECC read, page 0x%08x&bslash;n&quot;
comma
id|page
)paren
suffix:semicolon
id|ecc_failed
op_increment
suffix:semicolon
)brace
)brace
id|readdata
suffix:colon
r_if
c_cond
(paren
id|col
op_logical_or
(paren
id|len
op_minus
id|read
)paren
OL
id|end
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
id|col
suffix:semicolon
id|j
OL
id|end
op_logical_and
id|read
OL
id|len
suffix:semicolon
id|j
op_increment
)paren
id|buf
(braket
id|read
op_increment
)braket
op_assign
id|data_poi
(braket
id|j
)braket
suffix:semicolon
)brace
r_else
id|read
op_add_assign
id|mtd-&gt;oobblock
suffix:semicolon
multiline_comment|/* For subsequent reads align to page boundary. */
id|col
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Increment page address */
id|page
op_increment
suffix:semicolon
)brace
multiline_comment|/* De-select the NAND device */
id|nand_deselect
(paren
)paren
suffix:semicolon
multiline_comment|/* Wake up anyone waiting on the device */
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|wake_up
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Return success, if no ECC failures, else -EIO&n;&t; * fs driver will take care of that, because&n;&t; * retlen == desired len and result == -EIO&n;&t; */
op_star
id|retlen
op_assign
id|read
suffix:semicolon
r_return
id|ecc_failed
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * NAND read out-of-band&n; */
DECL|function|nand_read_oob
r_static
r_int
id|nand_read_oob
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
(brace
r_int
id|i
comma
id|col
comma
id|page
suffix:semicolon
r_int
id|erase_state
op_assign
l_int|0
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;nand_read_oob: from = 0x%08x, len = %i&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|from
comma
(paren
r_int
)paren
id|len
)paren
suffix:semicolon
multiline_comment|/* Shift to get page */
id|page
op_assign
(paren
(paren
r_int
)paren
id|from
)paren
op_rshift
id|this-&gt;page_shift
suffix:semicolon
multiline_comment|/* Mask to get column */
id|col
op_assign
id|from
op_amp
l_int|0x0f
suffix:semicolon
multiline_comment|/* Initialize return length value */
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Do not allow reads past end of device */
r_if
c_cond
(paren
(paren
id|from
op_plus
id|len
)paren
OG
id|mtd-&gt;size
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_read_oob: Attempt read beyond end of device&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Grab the lock and see if the device is available */
id|nand_get_chip
(paren
id|this
comma
id|mtd
comma
id|FL_READING
comma
op_amp
id|erase_state
)paren
suffix:semicolon
multiline_comment|/* Select the NAND device */
id|nand_select
(paren
)paren
suffix:semicolon
multiline_comment|/* Send the read command */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_READOOB
comma
id|col
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Read the data, if we read more than one page&n;&t; * oob data, let the device transfer the data !&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|buf
(braket
id|i
)braket
op_assign
id|readb
(paren
id|this-&gt;IO_ADDR_R
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|col
op_increment
op_amp
(paren
id|mtd-&gt;oobsize
op_minus
l_int|1
)paren
)paren
op_eq
(paren
id|mtd-&gt;oobsize
op_minus
l_int|1
)paren
)paren
id|udelay
(paren
id|this-&gt;chip_delay
)paren
suffix:semicolon
)brace
multiline_comment|/* De-select the NAND device */
id|nand_deselect
(paren
)paren
suffix:semicolon
multiline_comment|/* Wake up anyone waiting on the device */
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|wake_up
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
multiline_comment|/* Return happy */
op_star
id|retlen
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|NOTALIGNED
mdefine_line|#define NOTALIGNED(x) (x &amp; (mtd-&gt;oobblock-1)) != 0
multiline_comment|/*&n;*&t;Use NAND write ECC&n;*/
DECL|function|nand_write
r_static
r_int
id|nand_write
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
(brace
r_return
(paren
id|nand_write_ecc
(paren
id|mtd
comma
id|to
comma
id|len
comma
id|retlen
comma
id|buf
comma
l_int|NULL
comma
l_int|NULL
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAND write with ECC&n; */
DECL|function|nand_write_ecc
r_static
r_int
id|nand_write_ecc
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
comma
id|u_char
op_star
id|eccbuf
comma
r_struct
id|nand_oobinfo
op_star
id|oobsel
)paren
(brace
r_int
id|page
comma
id|ret
op_assign
l_int|0
comma
id|oob
op_assign
l_int|0
comma
id|written
op_assign
l_int|0
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;nand_write_ecc: to = 0x%08x, len = %i&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|to
comma
(paren
r_int
)paren
id|len
)paren
suffix:semicolon
multiline_comment|/* Do not allow write past end of device */
r_if
c_cond
(paren
(paren
id|to
op_plus
id|len
)paren
OG
id|mtd-&gt;size
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_write_ecc: Attempt to write past end of page&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* reject writes, which are not page aligned */
r_if
c_cond
(paren
id|NOTALIGNED
(paren
id|to
)paren
op_logical_or
id|NOTALIGNED
c_func
(paren
id|len
)paren
)paren
(brace
id|printk
(paren
id|KERN_NOTICE
l_string|&quot;nand_write_ecc: Attempt to write not page aligned data&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
singleline_comment|// if oobsel is NULL, use chip defaults
r_if
c_cond
(paren
id|oobsel
op_eq
l_int|NULL
)paren
id|oobsel
op_assign
op_amp
id|mtd-&gt;oobinfo
suffix:semicolon
multiline_comment|/* Shift to get page */
id|page
op_assign
(paren
(paren
r_int
)paren
id|to
)paren
op_rshift
id|this-&gt;page_shift
suffix:semicolon
multiline_comment|/* Grab the lock and see if the device is available */
id|nand_get_chip
(paren
id|this
comma
id|mtd
comma
id|FL_WRITING
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Select the NAND device */
id|nand_select
(paren
)paren
suffix:semicolon
multiline_comment|/* Check the WP bit */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_STATUS
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|readb
(paren
id|this-&gt;IO_ADDR_R
)paren
op_amp
l_int|0x80
)paren
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_write_ecc: Device is write protected!!!&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Loop until all data is written */
r_while
c_loop
(paren
id|written
OL
id|len
)paren
(brace
r_int
id|cnt
op_assign
id|mtd-&gt;oobblock
suffix:semicolon
id|this-&gt;data_poi
op_assign
(paren
id|u_char
op_star
)paren
op_amp
id|buf
(braket
id|written
)braket
suffix:semicolon
multiline_comment|/* We use the same function for write and writev */
r_if
c_cond
(paren
id|eccbuf
)paren
(brace
id|ret
op_assign
id|nand_write_page
(paren
id|mtd
comma
id|this
comma
id|page
comma
op_amp
id|eccbuf
(braket
id|oob
)braket
comma
id|oobsel
)paren
suffix:semicolon
id|oob
op_add_assign
id|mtd-&gt;oobsize
suffix:semicolon
)brace
r_else
id|ret
op_assign
id|nand_write_page
(paren
id|mtd
comma
id|this
comma
id|page
comma
l_int|NULL
comma
id|oobsel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Update written bytes count */
id|written
op_add_assign
id|cnt
suffix:semicolon
multiline_comment|/* Increment page address */
id|page
op_increment
suffix:semicolon
)brace
id|out
suffix:colon
multiline_comment|/* De-select the NAND device */
id|nand_deselect
(paren
)paren
suffix:semicolon
multiline_comment|/* Wake up anyone waiting on the device */
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|wake_up
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
op_star
id|retlen
op_assign
id|written
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * NAND write out-of-band&n; */
DECL|function|nand_write_oob
r_static
r_int
id|nand_write_oob
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
(brace
r_int
id|i
comma
id|column
comma
id|page
comma
id|status
comma
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;nand_write_oob: to = 0x%08x, len = %i&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|to
comma
(paren
r_int
)paren
id|len
)paren
suffix:semicolon
multiline_comment|/* Shift to get page */
id|page
op_assign
(paren
(paren
r_int
)paren
id|to
)paren
op_rshift
id|this-&gt;page_shift
suffix:semicolon
multiline_comment|/* Mask to get column */
id|column
op_assign
id|to
op_amp
l_int|0x1f
suffix:semicolon
multiline_comment|/* Initialize return length value */
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Do not allow write past end of page */
r_if
c_cond
(paren
(paren
id|column
op_plus
id|len
)paren
OG
id|mtd-&gt;oobsize
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_write_oob: Attempt to write past end of page&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Grab the lock and see if the device is available */
id|nand_get_chip
(paren
id|this
comma
id|mtd
comma
id|FL_WRITING
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Select the NAND device */
id|nand_select
(paren
)paren
suffix:semicolon
multiline_comment|/* Check the WP bit */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_STATUS
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|readb
(paren
id|this-&gt;IO_ADDR_R
)paren
op_amp
l_int|0x80
)paren
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_write_oob: Device is write protected!!!&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Write out desired data */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_SEQIN
comma
id|mtd-&gt;oobblock
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* prepad 0xff for partial programming */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|column
suffix:semicolon
id|i
op_increment
)paren
id|writeb
(paren
l_int|0xff
comma
id|this-&gt;IO_ADDR_W
)paren
suffix:semicolon
multiline_comment|/* write data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
id|writeb
(paren
id|buf
(braket
id|i
)braket
comma
id|this-&gt;IO_ADDR_W
)paren
suffix:semicolon
multiline_comment|/* postpad 0xff for partial programming */
r_for
c_loop
(paren
id|i
op_assign
id|len
op_plus
id|column
suffix:semicolon
id|i
OL
id|mtd-&gt;oobsize
suffix:semicolon
id|i
op_increment
)paren
id|writeb
(paren
l_int|0xff
comma
id|this-&gt;IO_ADDR_W
)paren
suffix:semicolon
multiline_comment|/* Send command to program the OOB data */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_PAGEPROG
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|status
op_assign
id|this-&gt;waitfunc
(paren
id|mtd
comma
id|this
comma
id|FL_WRITING
)paren
suffix:semicolon
multiline_comment|/* See if device thinks it succeeded */
r_if
c_cond
(paren
id|status
op_amp
l_int|0x01
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_write_oob: &quot;
l_string|&quot;Failed write, page 0x%08x&bslash;n&quot;
comma
id|page
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Return happy */
op_star
id|retlen
op_assign
id|len
suffix:semicolon
macro_line|#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
multiline_comment|/* Send command to read back the data */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_READOOB
comma
id|column
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* Loop through and verify the data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_ne
id|readb
(paren
id|this-&gt;IO_ADDR_R
)paren
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_write_oob: &quot;
l_string|&quot;Failed write verify, page 0x%08x&bslash;n&quot;
comma
id|page
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
macro_line|#endif
id|out
suffix:colon
multiline_comment|/* De-select the NAND device */
id|nand_deselect
(paren
)paren
suffix:semicolon
multiline_comment|/* Wake up anyone waiting on the device */
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|wake_up
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * NAND write with iovec&n; */
DECL|function|nand_writev
r_static
r_int
id|nand_writev
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
r_struct
id|iovec
op_star
id|vecs
comma
r_int
r_int
id|count
comma
id|loff_t
id|to
comma
r_int
op_star
id|retlen
)paren
(brace
r_return
(paren
id|nand_writev_ecc
(paren
id|mtd
comma
id|vecs
comma
id|count
comma
id|to
comma
id|retlen
comma
l_int|NULL
comma
l_int|0
)paren
)paren
suffix:semicolon
)brace
DECL|function|nand_writev_ecc
r_static
r_int
id|nand_writev_ecc
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
r_struct
id|iovec
op_star
id|vecs
comma
r_int
r_int
id|count
comma
id|loff_t
id|to
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|eccbuf
comma
r_struct
id|nand_oobinfo
op_star
id|oobsel
)paren
(brace
r_int
id|i
comma
id|page
comma
id|len
comma
id|total_len
comma
id|ret
op_assign
l_int|0
comma
id|written
op_assign
l_int|0
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
multiline_comment|/* Calculate total length of data */
id|total_len
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
id|total_len
op_add_assign
(paren
r_int
)paren
id|vecs
(braket
id|i
)braket
dot
id|iov_len
suffix:semicolon
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;nand_writev: to = 0x%08x, len = %i, count = %ld&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|to
comma
(paren
r_int
r_int
)paren
id|total_len
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* Do not allow write past end of page */
r_if
c_cond
(paren
(paren
id|to
op_plus
id|total_len
)paren
OG
id|mtd-&gt;size
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_writev: Attempted write past end of device&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* reject writes, which are not page aligned */
r_if
c_cond
(paren
id|NOTALIGNED
(paren
id|to
)paren
op_logical_or
id|NOTALIGNED
c_func
(paren
id|total_len
)paren
)paren
(brace
id|printk
(paren
id|KERN_NOTICE
l_string|&quot;nand_write_ecc: Attempt to write not page aligned data&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
singleline_comment|// if oobsel is NULL, use chip defaults
r_if
c_cond
(paren
id|oobsel
op_eq
l_int|NULL
)paren
id|oobsel
op_assign
op_amp
id|mtd-&gt;oobinfo
suffix:semicolon
multiline_comment|/* Shift to get page */
id|page
op_assign
(paren
(paren
r_int
)paren
id|to
)paren
op_rshift
id|this-&gt;page_shift
suffix:semicolon
multiline_comment|/* Grab the lock and see if the device is available */
id|nand_get_chip
(paren
id|this
comma
id|mtd
comma
id|FL_WRITING
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Select the NAND device */
id|nand_select
(paren
)paren
suffix:semicolon
multiline_comment|/* Check the WP bit */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_STATUS
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|readb
(paren
id|this-&gt;IO_ADDR_R
)paren
op_amp
l_int|0x80
)paren
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_writev: Device is write protected!!!&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Loop until all iovecs&squot; data has been written */
id|len
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
multiline_comment|/* &n;&t;&t; *  Check, if the tuple gives us not enough data for a &n;&t;&t; *  full page write. Then we can use the iov direct, &n;&t;&t; *  else we have to copy into data_buf.&t;&t;&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|vecs-&gt;iov_len
op_minus
id|len
)paren
op_ge
id|mtd-&gt;oobblock
)paren
(brace
id|this-&gt;data_poi
op_assign
(paren
id|u_char
op_star
)paren
id|vecs-&gt;iov_base
suffix:semicolon
id|this-&gt;data_poi
op_add_assign
id|len
suffix:semicolon
id|len
op_add_assign
id|mtd-&gt;oobblock
suffix:semicolon
multiline_comment|/* Check, if we have to switch to the next tuple */
r_if
c_cond
(paren
id|len
op_ge
(paren
r_int
)paren
id|vecs-&gt;iov_len
)paren
(brace
id|vecs
op_increment
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
id|count
op_decrement
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Read data out of each tuple until we have a full page&n;&t;&t;&t; * to write or we&squot;ve read all the tuples.&n;&t;&t; &t;*/
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|cnt
OL
id|mtd-&gt;oobblock
)paren
op_logical_and
id|count
)paren
(brace
r_if
c_cond
(paren
id|vecs-&gt;iov_base
op_ne
l_int|NULL
op_logical_and
id|vecs-&gt;iov_len
)paren
(brace
id|this-&gt;data_buf
(braket
id|cnt
op_increment
)braket
op_assign
(paren
(paren
id|u_char
op_star
)paren
id|vecs-&gt;iov_base
)paren
(braket
id|len
op_increment
)braket
suffix:semicolon
)brace
multiline_comment|/* Check, if we have to switch to the next tuple */
r_if
c_cond
(paren
id|len
op_ge
(paren
r_int
)paren
id|vecs-&gt;iov_len
)paren
(brace
id|vecs
op_increment
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
id|count
op_decrement
suffix:semicolon
)brace
)brace
id|this-&gt;data_poi
op_assign
id|this-&gt;data_buf
suffix:semicolon
)brace
multiline_comment|/* We use the same function for write and writev !) */
id|ret
op_assign
id|nand_write_page
(paren
id|mtd
comma
id|this
comma
id|page
comma
l_int|NULL
comma
id|oobsel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Update written bytes count */
id|written
op_add_assign
id|mtd-&gt;oobblock
suffix:semicolon
suffix:semicolon
multiline_comment|/* Increment page address */
id|page
op_increment
suffix:semicolon
)brace
id|out
suffix:colon
multiline_comment|/* De-select the NAND device */
id|nand_deselect
(paren
)paren
suffix:semicolon
multiline_comment|/* Wake up anyone waiting on the device */
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|wake_up
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
op_star
id|retlen
op_assign
id|written
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * NAND erase a block&n; */
DECL|function|nand_erase
r_static
r_int
id|nand_erase
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|erase_info
op_star
id|instr
)paren
(brace
r_int
id|page
comma
id|len
comma
id|status
comma
id|pages_per_block
comma
id|ret
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|DECLARE_WAITQUEUE
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;nand_erase: start = 0x%08x, len = %i&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|instr-&gt;addr
comma
(paren
r_int
r_int
)paren
id|instr-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Start address must align on block boundary */
r_if
c_cond
(paren
id|instr-&gt;addr
op_amp
(paren
id|mtd-&gt;erasesize
op_minus
l_int|1
)paren
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_erase: Unaligned address&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Length must align on block boundary */
r_if
c_cond
(paren
id|instr-&gt;len
op_amp
(paren
id|mtd-&gt;erasesize
op_minus
l_int|1
)paren
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_erase: Length not block aligned&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Do not allow erase past end of device */
r_if
c_cond
(paren
(paren
id|instr-&gt;len
op_plus
id|instr-&gt;addr
)paren
OG
id|mtd-&gt;size
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_erase: Erase past end of device&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Grab the lock and see if the device is available */
id|nand_get_chip
(paren
id|this
comma
id|mtd
comma
id|FL_ERASING
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Shift to get first page */
id|page
op_assign
(paren
r_int
)paren
(paren
id|instr-&gt;addr
op_rshift
id|this-&gt;page_shift
)paren
suffix:semicolon
multiline_comment|/* Calculate pages in each block */
id|pages_per_block
op_assign
id|mtd-&gt;erasesize
op_div
id|mtd-&gt;oobblock
suffix:semicolon
multiline_comment|/* Select the NAND device */
id|nand_select
(paren
)paren
suffix:semicolon
multiline_comment|/* Check the WP bit */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_STATUS
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|readb
(paren
id|this-&gt;IO_ADDR_R
)paren
op_amp
l_int|0x80
)paren
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_erase: Device is write protected!!!&bslash;n&quot;
)paren
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASE_FAILED
suffix:semicolon
r_goto
id|erase_exit
suffix:semicolon
)brace
multiline_comment|/* Loop through the pages */
id|len
op_assign
id|instr-&gt;len
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASING
suffix:semicolon
r_while
c_loop
(paren
id|len
)paren
(brace
multiline_comment|/* Check if we have a bad block, we do not erase bad blocks ! */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_READOOB
comma
id|NAND_BADBLOCK_POS
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|readb
(paren
id|this-&gt;IO_ADDR_R
)paren
op_ne
l_int|0xff
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;nand_erase: attempt to erase a bad block at page 0x%08x&bslash;n&quot;
comma
id|page
)paren
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASE_FAILED
suffix:semicolon
r_goto
id|erase_exit
suffix:semicolon
)brace
multiline_comment|/* Send commands to erase a page */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_ERASE1
comma
op_minus
l_int|1
comma
id|page
)paren
suffix:semicolon
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_ERASE2
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|status
op_assign
id|this-&gt;waitfunc
(paren
id|mtd
comma
id|this
comma
id|FL_ERASING
)paren
suffix:semicolon
multiline_comment|/* Get spinlock, in case we exit */
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
multiline_comment|/* See if block erase succeeded */
r_if
c_cond
(paren
id|status
op_amp
l_int|0x01
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_erase: &quot;
l_string|&quot;Failed erase, page 0x%08x&bslash;n&quot;
comma
id|page
)paren
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASE_FAILED
suffix:semicolon
r_goto
id|erase_exit
suffix:semicolon
)brace
multiline_comment|/* Check, if we were interupted */
r_if
c_cond
(paren
id|this-&gt;state
op_eq
id|FL_ERASING
)paren
(brace
multiline_comment|/* Increment page address and decrement length */
id|len
op_sub_assign
id|mtd-&gt;erasesize
suffix:semicolon
id|page
op_add_assign
id|pages_per_block
suffix:semicolon
)brace
multiline_comment|/* Release the spin lock */
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|erase_retry
suffix:colon
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
multiline_comment|/* Check the state and sleep if it changed */
r_if
c_cond
(paren
id|this-&gt;state
op_eq
id|FL_ERASING
op_logical_or
id|this-&gt;state
op_eq
id|FL_READY
)paren
(brace
multiline_comment|/* Select the NAND device again, if we were interrupted */
id|this-&gt;state
op_assign
id|FL_ERASING
suffix:semicolon
id|nand_select
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
(brace
id|set_current_state
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
(paren
op_amp
id|this-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|schedule
(paren
)paren
suffix:semicolon
id|remove_wait_queue
(paren
op_amp
id|this-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
r_goto
id|erase_retry
suffix:semicolon
)brace
)brace
id|instr-&gt;state
op_assign
id|MTD_ERASE_DONE
suffix:semicolon
id|erase_exit
suffix:colon
multiline_comment|/* De-select the NAND device */
id|nand_deselect
(paren
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|ret
op_assign
id|instr-&gt;state
op_eq
id|MTD_ERASE_DONE
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
suffix:semicolon
suffix:semicolon
multiline_comment|/* Do call back function */
r_if
c_cond
(paren
op_logical_neg
id|ret
op_logical_and
id|instr-&gt;callback
)paren
id|instr-&gt;callback
(paren
id|instr
)paren
suffix:semicolon
multiline_comment|/* The device is ready */
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
multiline_comment|/* Return more or less happy */
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * NAND sync&n; */
DECL|function|nand_sync
r_static
r_void
id|nand_sync
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|DECLARE_WAITQUEUE
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;nand_sync: called&bslash;n&quot;
)paren
suffix:semicolon
id|retry
suffix:colon
multiline_comment|/* Grab the spinlock */
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
multiline_comment|/* See what&squot;s going on */
r_switch
c_cond
(paren
id|this-&gt;state
)paren
(brace
r_case
id|FL_READY
suffix:colon
r_case
id|FL_SYNCING
suffix:colon
id|this-&gt;state
op_assign
id|FL_SYNCING
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Not an idle state */
id|add_wait_queue
(paren
op_amp
id|this-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|schedule
(paren
)paren
suffix:semicolon
id|remove_wait_queue
(paren
op_amp
id|this-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
multiline_comment|/* Lock the device */
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
multiline_comment|/* Set the device to be ready again */
r_if
c_cond
(paren
id|this-&gt;state
op_eq
id|FL_SYNCING
)paren
(brace
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|wake_up
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
)brace
multiline_comment|/* Unlock the device */
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Scan for the NAND device&n; */
DECL|function|nand_scan
r_int
id|nand_scan
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_int
id|i
comma
id|nand_maf_id
comma
id|nand_dev_id
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
multiline_comment|/* check for proper chip_delay setup, set 20us if not */
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;chip_delay
)paren
id|this-&gt;chip_delay
op_assign
l_int|20
suffix:semicolon
multiline_comment|/* check, if a user supplied command function given */
r_if
c_cond
(paren
id|this-&gt;cmdfunc
op_eq
l_int|NULL
)paren
id|this-&gt;cmdfunc
op_assign
id|nand_command
suffix:semicolon
multiline_comment|/* check, if a user supplied wait function given */
r_if
c_cond
(paren
id|this-&gt;waitfunc
op_eq
l_int|NULL
)paren
id|this-&gt;waitfunc
op_assign
id|nand_wait
suffix:semicolon
multiline_comment|/* Select the device */
id|nand_select
(paren
)paren
suffix:semicolon
multiline_comment|/* Send the command for reading device ID */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_READID
comma
l_int|0x00
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Read manufacturer and device IDs */
id|nand_maf_id
op_assign
id|readb
(paren
id|this-&gt;IO_ADDR_R
)paren
suffix:semicolon
id|nand_dev_id
op_assign
id|readb
(paren
id|this-&gt;IO_ADDR_R
)paren
suffix:semicolon
multiline_comment|/* Print and store flash device information */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|nand_flash_ids
(braket
id|i
)braket
dot
id|name
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|nand_dev_id
op_eq
id|nand_flash_ids
(braket
id|i
)braket
dot
id|id
op_logical_and
op_logical_neg
id|mtd-&gt;size
)paren
(brace
id|mtd-&gt;name
op_assign
id|nand_flash_ids
(braket
id|i
)braket
dot
id|name
suffix:semicolon
id|mtd-&gt;erasesize
op_assign
id|nand_flash_ids
(braket
id|i
)braket
dot
id|erasesize
suffix:semicolon
id|mtd-&gt;size
op_assign
(paren
l_int|1
op_lshift
id|nand_flash_ids
(braket
id|i
)braket
dot
id|chipshift
)paren
suffix:semicolon
id|mtd-&gt;eccsize
op_assign
l_int|256
suffix:semicolon
r_if
c_cond
(paren
id|nand_flash_ids
(braket
id|i
)braket
dot
id|page256
)paren
(brace
id|mtd-&gt;oobblock
op_assign
l_int|256
suffix:semicolon
id|mtd-&gt;oobsize
op_assign
l_int|8
suffix:semicolon
id|this-&gt;page_shift
op_assign
l_int|8
suffix:semicolon
)brace
r_else
(brace
id|mtd-&gt;oobblock
op_assign
l_int|512
suffix:semicolon
id|mtd-&gt;oobsize
op_assign
l_int|16
suffix:semicolon
id|this-&gt;page_shift
op_assign
l_int|9
suffix:semicolon
)brace
multiline_comment|/* Try to identify manufacturer */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|nand_manuf_ids
(braket
id|i
)braket
dot
id|id
op_ne
l_int|0x0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|nand_manuf_ids
(braket
id|i
)braket
dot
id|id
op_eq
id|nand_maf_id
)paren
r_break
suffix:semicolon
)brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;NAND device: Manufacture ID:&quot;
l_string|&quot; 0x%02x, Chip ID: 0x%02x (%s %s)&bslash;n&quot;
comma
id|nand_maf_id
comma
id|nand_dev_id
comma
id|nand_manuf_ids
(braket
id|i
)braket
dot
id|name
comma
id|mtd-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* &n;&t; * check ECC mode, default to software&n;&t; * if 3byte/512byte hardware ECC is selected and we have 256 byte pagesize&n;&t; * fallback to software ECC &n;&t;*/
id|this-&gt;eccsize
op_assign
l_int|256
suffix:semicolon
multiline_comment|/* set default eccsize */
r_switch
c_cond
(paren
id|this-&gt;eccmode
)paren
(brace
r_case
id|NAND_ECC_HW3_512
suffix:colon
r_if
c_cond
(paren
id|mtd-&gt;oobblock
op_eq
l_int|256
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;512 byte HW ECC not possible on 256 Byte pagesize, fallback to SW ECC &bslash;n&quot;
)paren
suffix:semicolon
id|this-&gt;eccmode
op_assign
id|NAND_ECC_SOFT
suffix:semicolon
id|this-&gt;calculate_ecc
op_assign
id|nand_calculate_ecc
suffix:semicolon
id|this-&gt;correct_data
op_assign
id|nand_correct_data
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
id|this-&gt;eccsize
op_assign
l_int|512
suffix:semicolon
multiline_comment|/* set eccsize to 512 and fall through for function check */
r_case
id|NAND_ECC_HW3_256
suffix:colon
r_if
c_cond
(paren
id|this-&gt;calculate_ecc
op_logical_and
id|this-&gt;correct_data
op_logical_and
id|this-&gt;enable_hwecc
)paren
r_break
suffix:semicolon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;No ECC functions supplied, Hardware ECC not possible&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_case
id|NAND_ECC_NONE
suffix:colon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;NAND_ECC_NONE selected by board driver. This is not recommended !!&bslash;n&quot;
)paren
suffix:semicolon
id|this-&gt;eccmode
op_assign
id|NAND_ECC_NONE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_ECC_SOFT
suffix:colon
id|this-&gt;calculate_ecc
op_assign
id|nand_calculate_ecc
suffix:semicolon
id|this-&gt;correct_data
op_assign
id|nand_correct_data
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;Invalid NAND_ECC_MODE %d&bslash;n&quot;
comma
id|this-&gt;eccmode
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize state, waitqueue and spinlock */
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|init_waitqueue_head
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
id|spin_lock_init
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
multiline_comment|/* De-select the device */
id|nand_deselect
(paren
)paren
suffix:semicolon
multiline_comment|/* Print warning message for no device */
r_if
c_cond
(paren
op_logical_neg
id|mtd-&gt;size
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;No NAND device found!!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Fill in remaining MTD driver data */
id|mtd-&gt;type
op_assign
id|MTD_NANDFLASH
suffix:semicolon
id|mtd-&gt;flags
op_assign
id|MTD_CAP_NANDFLASH
op_or
id|MTD_ECC
suffix:semicolon
id|mtd-&gt;ecctype
op_assign
id|MTD_ECC_SW
suffix:semicolon
id|mtd-&gt;erase
op_assign
id|nand_erase
suffix:semicolon
id|mtd-&gt;point
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;unpoint
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;read
op_assign
id|nand_read
suffix:semicolon
id|mtd-&gt;write
op_assign
id|nand_write
suffix:semicolon
id|mtd-&gt;read_ecc
op_assign
id|nand_read_ecc
suffix:semicolon
id|mtd-&gt;write_ecc
op_assign
id|nand_write_ecc
suffix:semicolon
id|mtd-&gt;read_oob
op_assign
id|nand_read_oob
suffix:semicolon
id|mtd-&gt;write_oob
op_assign
id|nand_write_oob
suffix:semicolon
id|mtd-&gt;readv
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;writev
op_assign
id|nand_writev
suffix:semicolon
id|mtd-&gt;writev_ecc
op_assign
id|nand_writev_ecc
suffix:semicolon
id|mtd-&gt;sync
op_assign
id|nand_sync
suffix:semicolon
id|mtd-&gt;lock
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;unlock
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;suspend
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;resume
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
multiline_comment|/* Return happy */
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|nand_scan
id|EXPORT_SYMBOL
(paren
id|nand_scan
)paren
suffix:semicolon
id|MODULE_LICENSE
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
(paren
l_string|&quot;Steven J. Hill &lt;sjhill@realitydiluted.com&gt;, Thomas Gleixner &lt;tglx@linutronix.de&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
(paren
l_string|&quot;Generic NAND flash driver code&quot;
)paren
suffix:semicolon
eof
