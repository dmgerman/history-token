multiline_comment|/*&n; *  drivers/mtd/nand.c&n; *&n; *  Copyright (C) 2000 Steven J. Hill (sjhill@cotw.com)&n; *&n; * $Id: nand.c,v 1.10 2001/03/20 07:26:01 dwmw2 Exp $&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License version 2 as&n; * published by the Free Software Foundation.&n; *&n; *  Overview:&n; *   This is the generic MTD driver for NAND flash devices. It should be&n; *   capable of working with almost all NAND chips currently available.&n; */
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/mtd/nand.h&gt;
macro_line|#include &lt;linux/mtd/nand_ids.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#ifdef CONFIG_MTD_NAND_ECC
macro_line|#include &lt;linux/mtd/nand_ecc.h&gt;
macro_line|#endif
multiline_comment|/*&n; * Macros for low-level register control&n; */
DECL|macro|NAND_CTRL
mdefine_line|#define NAND_CTRL (*(volatile unsigned char *) &bslash;&n;&t;&t;&t;((struct nand_chip *) mtd-&gt;priv)-&gt;CTRL_ADDR)
DECL|macro|nand_select
mdefine_line|#define nand_select()&t;NAND_CTRL &amp;= ~this-&gt;NCE; &bslash;&n;&t;&t;&t;nand_command(mtd, NAND_CMD_RESET, -1, -1); &bslash;&n;&t;&t;&t;udelay (10);
DECL|macro|nand_deselect
mdefine_line|#define nand_deselect() NAND_CTRL |= ~this-&gt;NCE;
multiline_comment|/*&n; * NAND low-level MTD interface functions&n; */
r_static
r_int
id|nand_read
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|nand_read_ecc
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
comma
id|u_char
op_star
id|ecc_code
)paren
suffix:semicolon
r_static
r_int
id|nand_read_oob
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|nand_write
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|nand_write_ecc
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
comma
id|u_char
op_star
id|ecc_code
)paren
suffix:semicolon
r_static
r_int
id|nand_write_oob
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|nand_writev
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
r_struct
id|iovec
op_star
id|vecs
comma
r_int
r_int
id|count
comma
id|loff_t
id|to
comma
r_int
op_star
id|retlen
)paren
suffix:semicolon
r_static
r_int
id|nand_erase
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|erase_info
op_star
id|instr
)paren
suffix:semicolon
r_static
r_void
id|nand_sync
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
suffix:semicolon
multiline_comment|/*&n; * Send command to NAND device&n; */
DECL|function|nand_command
r_static
r_void
id|nand_command
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|command
comma
r_int
id|column
comma
r_int
id|page_addr
)paren
(brace
r_register
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_register
r_int
r_int
id|NAND_IO_ADDR
op_assign
id|this-&gt;IO_ADDR
suffix:semicolon
multiline_comment|/* Begin command latch cycle */
id|NAND_CTRL
op_or_assign
id|this-&gt;CLE
suffix:semicolon
multiline_comment|/*&n;&t; * Write out the command to the device.&n;&t; */
r_if
c_cond
(paren
id|command
op_ne
id|NAND_CMD_SEQIN
)paren
id|writeb
(paren
id|command
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|mtd-&gt;oobblock
op_eq
l_int|256
op_logical_and
id|column
op_ge
l_int|256
)paren
(brace
id|column
op_sub_assign
l_int|256
suffix:semicolon
id|writeb
c_func
(paren
id|NAND_CMD_RESET
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|NAND_CMD_READOOB
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|NAND_CMD_SEQIN
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mtd-&gt;oobblock
op_eq
l_int|512
op_logical_and
id|column
op_ge
l_int|256
)paren
(brace
r_if
c_cond
(paren
id|column
OL
l_int|512
)paren
(brace
id|column
op_sub_assign
l_int|256
suffix:semicolon
id|writeb
c_func
(paren
id|NAND_CMD_READ1
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|NAND_CMD_SEQIN
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
)brace
r_else
(brace
id|column
op_sub_assign
l_int|512
suffix:semicolon
id|writeb
c_func
(paren
id|NAND_CMD_READOOB
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|NAND_CMD_SEQIN
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|writeb
c_func
(paren
id|NAND_CMD_READ0
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|NAND_CMD_SEQIN
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Set ALE and clear CLE to start address cycle */
id|NAND_CTRL
op_and_assign
op_complement
id|this-&gt;CLE
suffix:semicolon
id|NAND_CTRL
op_or_assign
id|this-&gt;ALE
suffix:semicolon
multiline_comment|/* Serially input address */
r_if
c_cond
(paren
id|column
op_ne
op_minus
l_int|1
)paren
id|writeb
(paren
id|column
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page_addr
op_ne
op_minus
l_int|1
)paren
(brace
id|writeb
(paren
(paren
r_int
r_char
)paren
(paren
id|page_addr
op_amp
l_int|0xff
)paren
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
id|writeb
(paren
(paren
r_int
r_char
)paren
(paren
(paren
id|page_addr
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
multiline_comment|/* One more address cycle for higher density devices */
r_if
c_cond
(paren
id|mtd-&gt;size
op_amp
l_int|0x0c000000
)paren
(brace
id|writeb
(paren
(paren
r_int
r_char
)paren
(paren
(paren
id|page_addr
op_rshift
l_int|16
)paren
op_amp
l_int|0x0f
)paren
comma
id|NAND_IO_ADDR
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Latch in address */
id|NAND_CTRL
op_and_assign
op_complement
id|this-&gt;ALE
suffix:semicolon
multiline_comment|/* Pause for 15us */
id|udelay
(paren
l_int|15
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAND read&n; */
DECL|function|nand_read
r_static
r_int
id|nand_read
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
(brace
macro_line|#ifdef CONFIG_MTD_NAND_ECC
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_return
id|nand_read_ecc
(paren
id|mtd
comma
id|from
comma
id|len
comma
id|retlen
comma
id|buf
comma
id|this-&gt;ecc_code_buf
)paren
suffix:semicolon
macro_line|#else
r_return
id|nand_read_ecc
(paren
id|mtd
comma
id|from
comma
id|len
comma
id|retlen
comma
id|buf
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * NAND read with ECC&n; */
DECL|function|nand_read_ecc
r_static
r_int
id|nand_read_ecc
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
comma
id|u_char
op_star
id|ecc_code
)paren
(brace
r_int
id|j
comma
id|col
comma
id|page
comma
id|state
suffix:semicolon
r_int
id|erase_state
op_assign
l_int|0
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MTD_NAND_ECC
r_int
id|ecc_result
suffix:semicolon
id|u_char
id|ecc_calc
(braket
l_int|6
)braket
suffix:semicolon
macro_line|#endif
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;nand_read_ecc: from = 0x%08x, len = %i&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|from
comma
(paren
r_int
)paren
id|len
)paren
suffix:semicolon
multiline_comment|/* Do not allow reads past end of device */
r_if
c_cond
(paren
(paren
id|from
op_plus
id|len
)paren
OG
id|mtd-&gt;size
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_read_ecc: Attempt read beyond end of device&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Grab the lock and see if the device is available */
id|retry
suffix:colon
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|this-&gt;state
)paren
(brace
r_case
id|FL_READY
suffix:colon
id|this-&gt;state
op_assign
id|FL_READING
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FL_ERASING
suffix:colon
id|this-&gt;state
op_assign
id|FL_READING
suffix:semicolon
id|erase_state
op_assign
l_int|1
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|set_current_state
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
(paren
op_amp
id|this-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|remove_wait_queue
(paren
op_amp
id|this-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* First we calculate the starting page */
id|page
op_assign
id|from
op_rshift
id|this-&gt;page_shift
suffix:semicolon
multiline_comment|/* Get raw starting column */
id|col
op_assign
id|from
op_amp
(paren
id|mtd-&gt;oobblock
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* State machine for devices having pages larger than 256 bytes */
id|state
op_assign
(paren
id|col
OL
id|mtd-&gt;eccsize
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Calculate column address within ECC block context */
id|col
op_assign
(paren
id|col
op_ge
id|mtd-&gt;eccsize
)paren
ques
c_cond
(paren
id|col
op_minus
id|mtd-&gt;eccsize
)paren
suffix:colon
id|col
suffix:semicolon
multiline_comment|/* Initialize return value */
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Select the NAND device */
id|nand_select
(paren
)paren
suffix:semicolon
multiline_comment|/* Loop until all data read */
r_while
c_loop
(paren
op_star
id|retlen
OL
id|len
)paren
(brace
macro_line|#ifdef CONFIG_MTD_NAND_ECC
multiline_comment|/* Send the read command */
r_if
c_cond
(paren
op_logical_neg
id|state
)paren
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_READ0
comma
l_int|0x00
comma
id|page
)paren
suffix:semicolon
r_else
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_READ1
comma
l_int|0x00
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* Read in a block big enough for ECC */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|mtd-&gt;eccsize
suffix:semicolon
id|j
op_increment
)paren
id|this-&gt;data_buf
(braket
id|j
)braket
op_assign
id|readb
(paren
id|this-&gt;IO_ADDR
)paren
suffix:semicolon
multiline_comment|/* Read in the out-of-band data */
r_if
c_cond
(paren
op_logical_neg
id|state
)paren
(brace
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_READOOB
comma
l_int|0x00
comma
id|page
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|3
suffix:semicolon
id|j
op_increment
)paren
id|ecc_code
(braket
id|j
)braket
op_assign
id|readb
c_func
(paren
id|this-&gt;IO_ADDR
)paren
suffix:semicolon
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_READ0
comma
l_int|0x00
comma
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_READOOB
comma
l_int|0x03
comma
id|page
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|3
suffix:semicolon
id|j
OL
l_int|6
suffix:semicolon
id|j
op_increment
)paren
id|ecc_code
(braket
id|j
)braket
op_assign
id|readb
c_func
(paren
id|this-&gt;IO_ADDR
)paren
suffix:semicolon
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_READ0
comma
l_int|0x00
comma
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/* Calculate the ECC and verify it */
r_if
c_cond
(paren
op_logical_neg
id|state
)paren
(brace
id|nand_calculate_ecc
(paren
op_amp
id|this-&gt;data_buf
(braket
l_int|0
)braket
comma
op_amp
id|ecc_calc
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|ecc_result
op_assign
id|nand_correct_data
(paren
op_amp
id|this-&gt;data_buf
(braket
l_int|0
)braket
comma
op_amp
id|ecc_code
(braket
l_int|0
)braket
comma
op_amp
id|ecc_calc
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|nand_calculate_ecc
(paren
op_amp
id|this-&gt;data_buf
(braket
l_int|0
)braket
comma
op_amp
id|ecc_calc
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|ecc_result
op_assign
id|nand_correct_data
(paren
op_amp
id|this-&gt;data_buf
(braket
l_int|0
)braket
comma
op_amp
id|ecc_code
(braket
l_int|3
)braket
comma
op_amp
id|ecc_calc
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ecc_result
op_eq
op_minus
l_int|1
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_read_ecc: &quot;
"&bslash;"
l_string|&quot;Failed ECC read, page 0x%08x&bslash;n&quot;
comma
id|page
)paren
suffix:semicolon
id|nand_deselect
(paren
)paren
suffix:semicolon
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|erase_state
)paren
id|this-&gt;state
op_assign
id|FL_ERASING
suffix:semicolon
r_else
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|wake_up
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Read the data from ECC data buffer into return buffer */
r_if
c_cond
(paren
(paren
op_star
id|retlen
op_plus
(paren
id|mtd-&gt;eccsize
op_minus
id|col
)paren
)paren
op_ge
id|len
)paren
(brace
r_while
c_loop
(paren
op_star
id|retlen
OL
id|len
)paren
id|buf
(braket
(paren
op_star
id|retlen
)paren
op_increment
)braket
op_assign
id|this-&gt;data_buf
(braket
id|col
op_increment
)braket
suffix:semicolon
multiline_comment|/* We&squot;re done */
r_continue
suffix:semicolon
)brace
r_else
r_for
c_loop
(paren
id|j
op_assign
id|col
suffix:semicolon
id|j
OL
id|mtd-&gt;eccsize
suffix:semicolon
id|j
op_increment
)paren
id|buf
(braket
(paren
op_star
id|retlen
)paren
op_increment
)braket
op_assign
id|this-&gt;data_buf
(braket
id|j
)braket
suffix:semicolon
macro_line|#else
multiline_comment|/* Send the read command */
r_if
c_cond
(paren
op_logical_neg
id|state
)paren
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_READ0
comma
id|col
comma
id|page
)paren
suffix:semicolon
r_else
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_READ1
comma
id|col
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* Read the data directly into the return buffer */
r_if
c_cond
(paren
(paren
op_star
id|retlen
op_plus
(paren
id|mtd-&gt;eccsize
op_minus
id|col
)paren
)paren
op_ge
id|len
)paren
(brace
r_while
c_loop
(paren
op_star
id|retlen
OL
id|len
)paren
id|buf
(braket
(paren
op_star
id|retlen
)paren
op_increment
)braket
op_assign
id|readb
(paren
id|this-&gt;IO_ADDR
)paren
suffix:semicolon
multiline_comment|/* We&squot;re done */
r_continue
suffix:semicolon
)brace
r_else
r_for
c_loop
(paren
id|j
op_assign
id|col
suffix:semicolon
id|j
OL
id|mtd-&gt;eccsize
suffix:semicolon
id|j
op_increment
)paren
id|buf
(braket
(paren
op_star
id|retlen
)paren
op_increment
)braket
op_assign
id|readb
(paren
id|this-&gt;IO_ADDR
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * If the amount of data to be read is greater than&n;&t;&t; * (256 - col), then all subsequent reads will take&n;&t;&t; * place on page or half-page (in the case of 512 byte&n;&t;&t; * page devices) aligned boundaries and the column&n;&t;&t; * address will be zero. Setting the column address to&n;&t;&t; * to zero after the first read allows us to simplify&n;&t;&t; * the reading of data and the if/else statements above.&n;&t;&t; */
r_if
c_cond
(paren
id|col
)paren
id|col
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* Increment page address */
r_if
c_cond
(paren
(paren
id|mtd-&gt;oobblock
op_eq
l_int|256
)paren
op_logical_or
id|state
)paren
id|page
op_increment
suffix:semicolon
multiline_comment|/* Toggle state machine */
r_if
c_cond
(paren
id|mtd-&gt;oobblock
op_eq
l_int|512
)paren
id|state
op_assign
id|state
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
multiline_comment|/* De-select the NAND device */
id|nand_deselect
(paren
)paren
suffix:semicolon
multiline_comment|/* Wake up anyone waiting on the device */
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|erase_state
)paren
id|this-&gt;state
op_assign
id|FL_ERASING
suffix:semicolon
r_else
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|wake_up
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
multiline_comment|/* Return happy */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * NAND read out-of-band&n; */
DECL|function|nand_read_oob
r_static
r_int
id|nand_read_oob
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
(brace
r_int
id|i
comma
id|col
comma
id|page
suffix:semicolon
r_int
id|erase_state
op_assign
l_int|0
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;nand_read_oob: from = 0x%08x, len = %i&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|from
comma
(paren
r_int
)paren
id|len
)paren
suffix:semicolon
multiline_comment|/* Shift to get page */
id|page
op_assign
(paren
(paren
r_int
)paren
id|from
)paren
op_rshift
id|this-&gt;page_shift
suffix:semicolon
multiline_comment|/* Mask to get column */
id|col
op_assign
id|from
op_amp
l_int|0x0f
suffix:semicolon
multiline_comment|/* Initialize return length value */
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Do not allow read past end of page */
r_if
c_cond
(paren
(paren
id|col
op_plus
id|len
)paren
OG
id|mtd-&gt;oobsize
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_read_oob: Attempt read past end of page &quot;
"&bslash;"
l_string|&quot;0x%08x, column %i, length %i&bslash;n&quot;
comma
id|page
comma
id|col
comma
id|len
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|retry
suffix:colon
multiline_comment|/* Grab the lock and see if the device is available */
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|this-&gt;state
)paren
(brace
r_case
id|FL_READY
suffix:colon
id|this-&gt;state
op_assign
id|FL_READING
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FL_ERASING
suffix:colon
id|this-&gt;state
op_assign
id|FL_READING
suffix:semicolon
id|erase_state
op_assign
l_int|1
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|set_current_state
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
(paren
op_amp
id|this-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|remove_wait_queue
(paren
op_amp
id|this-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Select the NAND device */
id|nand_select
(paren
)paren
suffix:semicolon
multiline_comment|/* Send the read command */
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_READOOB
comma
id|col
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* Read the data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
id|buf
(braket
id|i
)braket
op_assign
id|readb
(paren
id|this-&gt;IO_ADDR
)paren
suffix:semicolon
multiline_comment|/* De-select the NAND device */
id|nand_deselect
(paren
)paren
suffix:semicolon
multiline_comment|/* Wake up anyone waiting on the device */
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|erase_state
)paren
id|this-&gt;state
op_assign
id|FL_ERASING
suffix:semicolon
r_else
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|wake_up
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
multiline_comment|/* Return happy */
op_star
id|retlen
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * NAND write&n; */
DECL|function|nand_write
r_static
r_int
id|nand_write
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
(brace
macro_line|#ifdef CONFIG_MTD_NAND_ECC
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_return
id|nand_write_ecc
(paren
id|mtd
comma
id|to
comma
id|len
comma
id|retlen
comma
id|buf
comma
id|this-&gt;ecc_code_buf
)paren
suffix:semicolon
macro_line|#else
r_return
id|nand_write_ecc
(paren
id|mtd
comma
id|to
comma
id|len
comma
id|retlen
comma
id|buf
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * NAND write with ECC&n; */
DECL|function|nand_write_ecc
r_static
r_int
id|nand_write_ecc
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
comma
id|u_char
op_star
id|ecc_code
)paren
(brace
r_int
id|i
comma
id|page
comma
id|col
comma
id|cnt
comma
id|status
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MTD_NAND_ECC
r_int
id|ecc_bytes
op_assign
(paren
id|mtd-&gt;oobblock
op_eq
l_int|512
)paren
ques
c_cond
l_int|6
suffix:colon
l_int|3
suffix:semicolon
macro_line|#endif
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;nand_write_ecc: to = 0x%08x, len = %i&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|to
comma
(paren
r_int
)paren
id|len
)paren
suffix:semicolon
multiline_comment|/* Do not allow write past end of page */
r_if
c_cond
(paren
(paren
id|to
op_plus
id|len
)paren
OG
id|mtd-&gt;size
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_write_ecc: Attempted write past end of device&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|retry
suffix:colon
multiline_comment|/* Grab the lock and see if the device is available */
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|this-&gt;state
)paren
(brace
r_case
id|FL_READY
suffix:colon
id|this-&gt;state
op_assign
id|FL_WRITING
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|set_current_state
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
(paren
op_amp
id|this-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|remove_wait_queue
(paren
op_amp
id|this-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Shift to get page */
id|page
op_assign
(paren
(paren
r_int
)paren
id|to
)paren
op_rshift
id|this-&gt;page_shift
suffix:semicolon
multiline_comment|/* Get the starting column */
id|col
op_assign
id|to
op_amp
(paren
id|mtd-&gt;oobblock
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Initialize return length value */
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Select the NAND device */
id|nand_select
(paren
)paren
suffix:semicolon
multiline_comment|/* Check the WP bit */
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_STATUS
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|readb
(paren
id|this-&gt;IO_ADDR
)paren
op_amp
l_int|0x80
)paren
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_write_ecc: Device is write protected!!!&bslash;n&quot;
)paren
suffix:semicolon
id|nand_deselect
(paren
)paren
suffix:semicolon
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|wake_up
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Loop until all data is written */
r_while
c_loop
(paren
op_star
id|retlen
OL
id|len
)paren
(brace
multiline_comment|/* Write data into buffer */
r_if
c_cond
(paren
(paren
id|col
op_plus
id|len
)paren
op_ge
id|mtd-&gt;oobblock
)paren
r_for
c_loop
(paren
id|i
op_assign
id|col
comma
id|cnt
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mtd-&gt;oobblock
suffix:semicolon
id|i
op_increment
comma
id|cnt
op_increment
)paren
(brace
id|this-&gt;data_buf
(braket
id|i
)braket
op_assign
id|buf
(braket
(paren
op_star
id|retlen
op_plus
id|cnt
)paren
)braket
suffix:semicolon
)brace
r_else
r_for
c_loop
(paren
id|i
op_assign
id|col
comma
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
(paren
id|len
op_minus
op_star
id|retlen
)paren
suffix:semicolon
id|i
op_increment
comma
id|cnt
op_increment
)paren
(brace
id|this-&gt;data_buf
(braket
id|i
)braket
op_assign
id|buf
(braket
(paren
op_star
id|retlen
op_plus
id|cnt
)paren
)braket
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MTD_NAND_ECC
multiline_comment|/* Zero out the ECC array */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|ecc_code
(braket
id|i
)braket
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* Calculate and write the ECC if we have enough data */
r_if
c_cond
(paren
(paren
id|col
OL
id|mtd-&gt;eccsize
)paren
op_logical_and
(paren
(paren
id|col
op_plus
(paren
id|len
op_minus
op_star
id|retlen
)paren
)paren
op_ge
id|mtd-&gt;eccsize
)paren
)paren
(brace
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_READ0
comma
id|col
comma
id|page
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|col
suffix:semicolon
id|i
op_increment
)paren
id|this-&gt;data_buf
(braket
id|i
)braket
op_assign
id|readb
(paren
id|this-&gt;IO_ADDR
)paren
suffix:semicolon
id|nand_calculate_ecc
(paren
op_amp
id|this-&gt;data_buf
(braket
l_int|0
)braket
comma
op_amp
id|ecc_code
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
id|this-&gt;data_buf
(braket
(paren
id|mtd-&gt;oobblock
op_plus
id|i
)paren
)braket
op_assign
id|ecc_code
(braket
id|i
)braket
suffix:semicolon
)brace
multiline_comment|/* Calculate and write the second ECC if we have enough data */
r_if
c_cond
(paren
(paren
id|mtd-&gt;oobblock
op_eq
l_int|512
)paren
op_logical_and
(paren
(paren
id|col
op_plus
(paren
id|len
op_minus
op_star
id|retlen
)paren
)paren
op_ge
id|mtd-&gt;oobblock
)paren
)paren
(brace
id|nand_calculate_ecc
(paren
op_amp
id|this-&gt;data_buf
(braket
l_int|256
)braket
comma
op_amp
id|ecc_code
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|3
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|this-&gt;data_buf
(braket
(paren
id|mtd-&gt;oobblock
op_plus
id|i
)paren
)braket
op_assign
id|ecc_code
(braket
id|i
)braket
suffix:semicolon
)brace
multiline_comment|/* Write ones for partial page programming */
r_for
c_loop
(paren
id|i
op_assign
id|ecc_bytes
suffix:semicolon
id|i
OL
id|mtd-&gt;oobsize
suffix:semicolon
id|i
op_increment
)paren
id|this-&gt;data_buf
(braket
(paren
id|mtd-&gt;oobblock
op_plus
id|i
)paren
)braket
op_assign
l_int|0xff
suffix:semicolon
macro_line|#else
multiline_comment|/* Write ones for partial page programming */
r_for
c_loop
(paren
id|i
op_assign
id|mtd-&gt;oobblock
suffix:semicolon
id|i
OL
(paren
id|mtd-&gt;oobblock
op_plus
id|mtd-&gt;oobsize
)paren
suffix:semicolon
id|i
op_increment
)paren
id|this-&gt;data_buf
(braket
id|i
)braket
op_assign
l_int|0xff
suffix:semicolon
macro_line|#endif
multiline_comment|/* Write pre-padding bytes into buffer */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|col
suffix:semicolon
id|i
op_increment
)paren
id|this-&gt;data_buf
(braket
id|i
)braket
op_assign
l_int|0xff
suffix:semicolon
multiline_comment|/* Write post-padding bytes into buffer */
r_if
c_cond
(paren
(paren
id|col
op_plus
(paren
id|len
op_minus
op_star
id|retlen
)paren
)paren
OL
id|mtd-&gt;oobblock
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
(paren
id|col
op_plus
id|cnt
)paren
suffix:semicolon
id|i
OL
id|mtd-&gt;oobblock
suffix:semicolon
id|i
op_increment
)paren
(brace
id|this-&gt;data_buf
(braket
id|i
)braket
op_assign
l_int|0xff
suffix:semicolon
)brace
)brace
multiline_comment|/* Send command to begin auto page programming */
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_SEQIN
comma
l_int|0x00
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* Write out complete page of data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|mtd-&gt;oobblock
op_plus
id|mtd-&gt;oobsize
)paren
suffix:semicolon
id|i
op_increment
)paren
id|writeb
(paren
id|this-&gt;data_buf
(braket
id|i
)braket
comma
id|this-&gt;IO_ADDR
)paren
suffix:semicolon
multiline_comment|/* Send command to actually program the data */
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_PAGEPROG
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Wait for program operation to complete. This could&n;&t;&t; * take up to 3000us (3ms) on some devices, so we try&n;&t;&t; * and exit as quickly as possible.&n;&t;&t; */
id|status
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|24
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Delay for 125us */
id|udelay
(paren
l_int|125
)paren
suffix:semicolon
multiline_comment|/* Check the status */
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_STATUS
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|status
op_assign
(paren
r_int
)paren
id|readb
(paren
id|this-&gt;IO_ADDR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x40
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* See if device thinks it succeeded */
r_if
c_cond
(paren
id|status
op_amp
l_int|0x01
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_write_ecc: &quot;
"&bslash;"
l_string|&quot;Failed write, page 0x%08x, &quot;
"&bslash;"
l_string|&quot;%6i bytes were succesful&bslash;n&quot;
comma
id|page
comma
op_star
id|retlen
)paren
suffix:semicolon
id|nand_deselect
(paren
)paren
suffix:semicolon
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|wake_up
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
multiline_comment|/*&n;&t;&t; * The NAND device assumes that it is always writing to&n;&t;&t; * a cleanly erased page. Hence, it performs its internal&n;&t;&t; * write verification only on bits that transitioned from&n;&t;&t; * 1 to 0. The device does NOT verify the whole page on a&n;&t;&t; * byte by byte basis. It is possible that the page was&n;&t;&t; * not completely erased or the page is becoming unusable&n;&t;&t; * due to wear. The read with ECC would catch the error&n;&t;&t; * later when the ECC page check fails, but we would rather&n;&t;&t; * catch it early in the page write stage. Better to write&n;&t;&t; * no data than invalid data.&n;&t;&t; */
multiline_comment|/* Send command to read back the page */
r_if
c_cond
(paren
id|col
OL
id|mtd-&gt;eccsize
)paren
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_READ0
comma
id|col
comma
id|page
)paren
suffix:semicolon
r_else
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_READ1
comma
id|col
op_minus
l_int|256
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* Loop through and verify the data */
r_for
c_loop
(paren
id|i
op_assign
id|col
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|this-&gt;data_buf
(braket
id|i
)braket
op_ne
id|readb
(paren
id|this-&gt;IO_ADDR
)paren
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_write_ecc: &quot;
"&bslash;"
l_string|&quot;Failed write verify, page 0x%08x, &quot;
"&bslash;"
l_string|&quot;%6i bytes were succesful&bslash;n&quot;
comma
id|page
comma
op_star
id|retlen
)paren
suffix:semicolon
id|nand_deselect
(paren
)paren
suffix:semicolon
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|wake_up
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_MTD_NAND_ECC
multiline_comment|/*&n;&t;&t; * We also want to check that the ECC bytes wrote&n;&t;&t; * correctly for the same reasons stated above.&n;&t;&t; */
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_READOOB
comma
l_int|0x00
comma
id|page
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ecc_bytes
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|readb
(paren
id|this-&gt;IO_ADDR
)paren
op_ne
id|ecc_code
(braket
id|i
)braket
)paren
op_logical_and
id|ecc_code
(braket
id|i
)braket
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_write_ecc: Failed ECC write &quot;
"&bslash;"
l_string|&quot;verify, page 0x%08x, &quot;
"&bslash;"
l_string|&quot;%6i bytes were succesful&bslash;n&quot;
comma
id|page
comma
id|i
)paren
suffix:semicolon
id|nand_deselect
(paren
)paren
suffix:semicolon
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|wake_up
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#endif
multiline_comment|/*&n;&t;&t; * If we are writing a large amount of data and/or it&n;&t;&t; * crosses page or half-page boundaries, we set the&n;&t;&t; * the column to zero. It simplifies the program logic.&n;&t;&t; */
r_if
c_cond
(paren
id|col
)paren
id|col
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* Update written bytes count */
op_star
id|retlen
op_add_assign
id|cnt
suffix:semicolon
multiline_comment|/* Increment page address */
id|page
op_increment
suffix:semicolon
)brace
multiline_comment|/* De-select the NAND device */
id|nand_deselect
(paren
)paren
suffix:semicolon
multiline_comment|/* Wake up anyone waiting on the device */
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|wake_up
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
multiline_comment|/* Return happy */
op_star
id|retlen
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * NAND write out-of-band&n; */
DECL|function|nand_write_oob
r_static
r_int
id|nand_write_oob
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
(brace
r_int
id|i
comma
id|column
comma
id|page
comma
id|status
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;nand_write_oob: to = 0x%08x, len = %i&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|to
comma
(paren
r_int
)paren
id|len
)paren
suffix:semicolon
multiline_comment|/* Shift to get page */
id|page
op_assign
(paren
(paren
r_int
)paren
id|to
)paren
op_rshift
id|this-&gt;page_shift
suffix:semicolon
multiline_comment|/* Mask to get column */
id|column
op_assign
id|to
op_amp
l_int|0x1f
suffix:semicolon
multiline_comment|/* Initialize return length value */
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Do not allow write past end of page */
r_if
c_cond
(paren
(paren
id|column
op_plus
id|len
)paren
OG
id|mtd-&gt;oobsize
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_write_oob: Attempt to write past end of page&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|retry
suffix:colon
multiline_comment|/* Grab the lock and see if the device is available */
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|this-&gt;state
)paren
(brace
r_case
id|FL_READY
suffix:colon
id|this-&gt;state
op_assign
id|FL_WRITING
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|set_current_state
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
(paren
op_amp
id|this-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|remove_wait_queue
(paren
op_amp
id|this-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Select the NAND device */
id|nand_select
(paren
)paren
suffix:semicolon
multiline_comment|/* Check the WP bit */
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_STATUS
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|readb
(paren
id|this-&gt;IO_ADDR
)paren
op_amp
l_int|0x80
)paren
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_write_oob: Device is write protected!!!&bslash;n&quot;
)paren
suffix:semicolon
id|nand_deselect
(paren
)paren
suffix:semicolon
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|wake_up
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Write out desired data */
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_SEQIN
comma
id|column
op_plus
l_int|512
comma
id|page
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
id|writeb
(paren
id|buf
(braket
id|i
)braket
comma
id|this-&gt;IO_ADDR
)paren
suffix:semicolon
multiline_comment|/* Send command to program the OOB data */
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_PAGEPROG
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wait for program operation to complete. This could&n;&t; * take up to 3000us (3ms) on some devices, so we try&n;&t; * and exit as quickly as possible.&n;&t; */
id|status
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|24
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Delay for 125us */
id|udelay
(paren
l_int|125
)paren
suffix:semicolon
multiline_comment|/* Check the status */
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_STATUS
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|status
op_assign
(paren
r_int
)paren
id|readb
(paren
id|this-&gt;IO_ADDR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x40
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* See if device thinks it succeeded */
r_if
c_cond
(paren
id|status
op_amp
l_int|0x01
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_write_oob: &quot;
"&bslash;"
l_string|&quot;Failed write, page 0x%08x&bslash;n&quot;
comma
id|page
)paren
suffix:semicolon
id|nand_deselect
(paren
)paren
suffix:semicolon
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|wake_up
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
multiline_comment|/* Send command to read back the data */
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_READOOB
comma
id|column
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* Loop through and verify the data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_ne
id|readb
(paren
id|this-&gt;IO_ADDR
)paren
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_write_oob: &quot;
"&bslash;"
l_string|&quot;Failed write verify, page 0x%08x&bslash;n&quot;
comma
id|page
)paren
suffix:semicolon
id|nand_deselect
(paren
)paren
suffix:semicolon
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|wake_up
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* De-select the NAND device */
id|nand_deselect
(paren
)paren
suffix:semicolon
multiline_comment|/* Wake up anyone waiting on the device */
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|wake_up
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
multiline_comment|/* Return happy */
op_star
id|retlen
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * NAND write with iovec&n; */
DECL|function|nand_writev
r_static
r_int
id|nand_writev
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
r_struct
id|iovec
op_star
id|vecs
comma
r_int
r_int
id|count
comma
id|loff_t
id|to
comma
r_int
op_star
id|retlen
)paren
(brace
r_int
id|i
comma
id|page
comma
id|col
comma
id|cnt
comma
id|len
comma
id|total_len
comma
id|status
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MTD_NAND_ECC
r_int
id|ecc_bytes
op_assign
(paren
id|mtd-&gt;oobblock
op_eq
l_int|512
)paren
ques
c_cond
l_int|6
suffix:colon
l_int|3
suffix:semicolon
macro_line|#endif
multiline_comment|/* Calculate total length of data */
id|total_len
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
id|total_len
op_add_assign
(paren
r_int
)paren
id|vecs
(braket
id|i
)braket
dot
id|iov_len
suffix:semicolon
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;nand_writev: to = 0x%08x, len = %i&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|to
comma
(paren
r_int
r_int
)paren
id|total_len
)paren
suffix:semicolon
multiline_comment|/* Do not allow write past end of page */
r_if
c_cond
(paren
(paren
id|to
op_plus
id|total_len
)paren
OG
id|mtd-&gt;size
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_writev: Attempted write past end of device&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|retry
suffix:colon
multiline_comment|/* Grab the lock and see if the device is available */
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|this-&gt;state
)paren
(brace
r_case
id|FL_READY
suffix:colon
id|this-&gt;state
op_assign
id|FL_WRITING
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|set_current_state
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
(paren
op_amp
id|this-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|remove_wait_queue
(paren
op_amp
id|this-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Shift to get page */
id|page
op_assign
(paren
(paren
r_int
)paren
id|to
)paren
op_rshift
id|this-&gt;page_shift
suffix:semicolon
multiline_comment|/* Get the starting column */
id|col
op_assign
id|to
op_amp
(paren
id|mtd-&gt;oobblock
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Initialize return length value */
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Select the NAND device */
id|nand_select
(paren
)paren
suffix:semicolon
multiline_comment|/* Check the WP bit */
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_STATUS
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|readb
(paren
id|this-&gt;IO_ADDR
)paren
op_amp
l_int|0x80
)paren
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_writev: Device is write protected!!!&bslash;n&quot;
)paren
suffix:semicolon
id|nand_deselect
(paren
)paren
suffix:semicolon
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|wake_up
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Loop until all iovecs&squot; data has been written */
id|cnt
op_assign
id|col
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
multiline_comment|/* Do any need pre-fill for partial page programming */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
)paren
id|this-&gt;data_buf
(braket
id|i
)braket
op_assign
l_int|0xff
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Read data out of each tuple until we have a full page&n;&t;&t; * to write or we&squot;ve read all the tuples.&n;&t;&t; */
r_while
c_loop
(paren
(paren
id|cnt
OL
id|mtd-&gt;oobblock
)paren
op_logical_and
id|count
)paren
(brace
id|this-&gt;data_buf
(braket
id|cnt
op_increment
)braket
op_assign
(paren
(paren
id|u_char
op_star
)paren
id|vecs-&gt;iov_base
)paren
(braket
id|len
op_increment
)braket
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
(paren
r_int
)paren
id|vecs-&gt;iov_len
)paren
(brace
id|vecs
op_increment
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
id|count
op_decrement
suffix:semicolon
)brace
)brace
multiline_comment|/* Do any need post-fill for partial page programming */
r_for
c_loop
(paren
id|i
op_assign
id|cnt
suffix:semicolon
id|i
OL
id|mtd-&gt;oobblock
suffix:semicolon
id|i
op_increment
)paren
id|this-&gt;data_buf
(braket
id|i
)braket
op_assign
l_int|0xff
suffix:semicolon
macro_line|#ifdef CONFIG_MTD_NAND_ECC
multiline_comment|/* Zero out the ECC array */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|this-&gt;ecc_code_buf
(braket
id|i
)braket
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* Calculate and write the first ECC */
r_if
c_cond
(paren
id|col
op_ge
id|mtd-&gt;eccsize
)paren
(brace
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_READ0
comma
id|col
comma
id|page
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|col
suffix:semicolon
id|i
op_increment
)paren
id|this-&gt;data_buf
(braket
id|i
)braket
op_assign
id|readb
(paren
id|this-&gt;IO_ADDR
)paren
suffix:semicolon
id|nand_calculate_ecc
(paren
op_amp
id|this-&gt;data_buf
(braket
l_int|0
)braket
comma
op_amp
(paren
id|this-&gt;ecc_code_buf
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
id|this-&gt;data_buf
(braket
(paren
id|mtd-&gt;oobblock
op_plus
id|i
)paren
)braket
op_assign
id|this-&gt;ecc_code_buf
(braket
id|i
)braket
suffix:semicolon
)brace
multiline_comment|/* Calculate and write the second ECC */
r_if
c_cond
(paren
(paren
id|mtd-&gt;oobblock
op_eq
l_int|512
)paren
op_logical_and
(paren
id|cnt
op_eq
id|mtd-&gt;oobblock
)paren
)paren
(brace
id|nand_calculate_ecc
(paren
op_amp
id|this-&gt;data_buf
(braket
l_int|256
)braket
comma
op_amp
(paren
id|this-&gt;ecc_code_buf
(braket
l_int|3
)braket
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|3
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|this-&gt;data_buf
(braket
(paren
id|mtd-&gt;oobblock
op_plus
id|i
)paren
)braket
op_assign
id|this-&gt;ecc_code_buf
(braket
id|i
)braket
suffix:semicolon
)brace
multiline_comment|/* Write ones for partial page programming */
r_for
c_loop
(paren
id|i
op_assign
id|ecc_bytes
suffix:semicolon
id|i
OL
id|mtd-&gt;oobsize
suffix:semicolon
id|i
op_increment
)paren
id|this-&gt;data_buf
(braket
(paren
id|mtd-&gt;oobblock
op_plus
id|i
)paren
)braket
op_assign
l_int|0xff
suffix:semicolon
macro_line|#else
multiline_comment|/* Write ones for partial page programming */
r_for
c_loop
(paren
id|i
op_assign
id|mtd-&gt;oobblock
suffix:semicolon
id|i
OL
(paren
id|mtd-&gt;oobblock
op_plus
id|mtd-&gt;oobsize
)paren
suffix:semicolon
id|i
op_increment
)paren
id|this-&gt;data_buf
(braket
id|i
)braket
op_assign
l_int|0xff
suffix:semicolon
macro_line|#endif
multiline_comment|/* Send command to begin auto page programming */
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_SEQIN
comma
l_int|0x00
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* Write out complete page of data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|mtd-&gt;oobblock
op_plus
id|mtd-&gt;oobsize
)paren
suffix:semicolon
id|i
op_increment
)paren
id|writeb
(paren
id|this-&gt;data_buf
(braket
id|i
)braket
comma
id|this-&gt;IO_ADDR
)paren
suffix:semicolon
multiline_comment|/* Send command to actually program the data */
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_PAGEPROG
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Wait for program operation to complete. This could&n;&t;&t; * take up to 3000us (3ms) on some devices, so we try&n;&t;&t; * and exit as quickly as possible.&n;&t;&t; */
id|status
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|24
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Delay for 125us */
id|udelay
(paren
l_int|125
)paren
suffix:semicolon
multiline_comment|/* Check the status */
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_STATUS
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|status
op_assign
(paren
r_int
)paren
id|readb
(paren
id|this-&gt;IO_ADDR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x40
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* See if device thinks it succeeded */
r_if
c_cond
(paren
id|status
op_amp
l_int|0x01
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_writev: &quot;
"&bslash;"
l_string|&quot;Failed write, page 0x%08x, &quot;
"&bslash;"
l_string|&quot;%6i bytes were succesful&bslash;n&quot;
comma
id|page
comma
op_star
id|retlen
)paren
suffix:semicolon
id|nand_deselect
(paren
)paren
suffix:semicolon
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|wake_up
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
multiline_comment|/*&n;&t;&t; * The NAND device assumes that it is always writing to&n;&t;&t; * a cleanly erased page. Hence, it performs its internal&n;&t;&t; * write verification only on bits that transitioned from&n;&t;&t; * 1 to 0. The device does NOT verify the whole page on a&n;&t;&t; * byte by byte basis. It is possible that the page was&n;&t;&t; * not completely erased or the page is becoming unusable&n;&t;&t; * due to wear. The read with ECC would catch the error&n;&t;&t; * later when the ECC page check fails, but we would rather&n;&t;&t; * catch it early in the page write stage. Better to write&n;&t;&t; * no data than invalid data.&n;&t;&t; */
multiline_comment|/* Send command to read back the page */
r_if
c_cond
(paren
id|col
OL
id|mtd-&gt;eccsize
)paren
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_READ0
comma
id|col
comma
id|page
)paren
suffix:semicolon
r_else
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_READ1
comma
id|col
op_minus
l_int|256
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* Loop through and verify the data */
r_for
c_loop
(paren
id|i
op_assign
id|col
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|this-&gt;data_buf
(braket
id|i
)braket
op_ne
id|readb
(paren
id|this-&gt;IO_ADDR
)paren
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_writev: &quot;
"&bslash;"
l_string|&quot;Failed write verify, page 0x%08x, &quot;
"&bslash;"
l_string|&quot;%6i bytes were succesful&bslash;n&quot;
comma
id|page
comma
op_star
id|retlen
)paren
suffix:semicolon
id|nand_deselect
(paren
)paren
suffix:semicolon
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|wake_up
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_MTD_NAND_ECC
multiline_comment|/*&n;&t;&t; * We also want to check that the ECC bytes wrote&n;&t;&t; * correctly for the same reasons stated above.&n;&t;&t; */
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_READOOB
comma
l_int|0x00
comma
id|page
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ecc_bytes
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|readb
(paren
id|this-&gt;IO_ADDR
)paren
op_ne
id|this-&gt;ecc_code_buf
(braket
id|i
)braket
)paren
op_logical_and
id|this-&gt;ecc_code_buf
(braket
id|i
)braket
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_writev: Failed ECC write &quot;
"&bslash;"
l_string|&quot;verify, page 0x%08x, &quot;
"&bslash;"
l_string|&quot;%6i bytes were succesful&bslash;n&quot;
comma
id|page
comma
id|i
)paren
suffix:semicolon
id|nand_deselect
(paren
)paren
suffix:semicolon
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|wake_up
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#endif
multiline_comment|/* Update written bytes count */
op_star
id|retlen
op_add_assign
(paren
id|cnt
op_minus
id|col
)paren
suffix:semicolon
multiline_comment|/* Reset written byte counter and column */
id|col
op_assign
id|cnt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Increment page address */
id|page
op_increment
suffix:semicolon
)brace
multiline_comment|/* De-select the NAND device */
id|nand_deselect
(paren
)paren
suffix:semicolon
multiline_comment|/* Wake up anyone waiting on the device */
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|wake_up
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
multiline_comment|/* Return happy */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * NAND erase a block&n; */
DECL|function|nand_erase
r_static
r_int
id|nand_erase
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|erase_info
op_star
id|instr
)paren
(brace
r_int
id|i
comma
id|page
comma
id|len
comma
id|status
comma
id|pages_per_block
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;nand_erase: start = 0x%08x, len = %i&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|instr-&gt;addr
comma
(paren
r_int
r_int
)paren
id|instr-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Start address must align on block boundary */
r_if
c_cond
(paren
id|instr-&gt;addr
op_amp
(paren
id|mtd-&gt;erasesize
op_minus
l_int|1
)paren
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_erase: Unaligned address&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Length must align on block boundary */
r_if
c_cond
(paren
id|instr-&gt;len
op_amp
(paren
id|mtd-&gt;erasesize
op_minus
l_int|1
)paren
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_erase: Length not block aligned&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Do not allow erase past end of device */
r_if
c_cond
(paren
(paren
id|instr-&gt;len
op_plus
id|instr-&gt;addr
)paren
OG
id|mtd-&gt;size
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_erase: Erase past end of device&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|retry
suffix:colon
multiline_comment|/* Grab the lock and see if the device is available */
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|this-&gt;state
)paren
(brace
r_case
id|FL_READY
suffix:colon
id|this-&gt;state
op_assign
id|FL_ERASING
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|set_current_state
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
(paren
op_amp
id|this-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|remove_wait_queue
(paren
op_amp
id|this-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Shift to get first page */
id|page
op_assign
(paren
r_int
)paren
(paren
id|instr-&gt;addr
op_rshift
id|this-&gt;page_shift
)paren
suffix:semicolon
multiline_comment|/* Calculate pages in each block */
id|pages_per_block
op_assign
id|mtd-&gt;erasesize
op_div
id|mtd-&gt;oobblock
suffix:semicolon
multiline_comment|/* Select the NAND device */
id|nand_select
(paren
)paren
suffix:semicolon
multiline_comment|/* Check the WP bit */
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_STATUS
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|readb
(paren
id|this-&gt;IO_ADDR
)paren
op_amp
l_int|0x80
)paren
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_erase: Device is write protected!!!&bslash;n&quot;
)paren
suffix:semicolon
id|nand_deselect
(paren
)paren
suffix:semicolon
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Loop through the pages */
id|len
op_assign
id|instr-&gt;len
suffix:semicolon
r_while
c_loop
(paren
id|len
)paren
(brace
multiline_comment|/* Send commands to erase a page */
id|nand_command
c_func
(paren
id|mtd
comma
id|NAND_CMD_ERASE1
comma
op_minus
l_int|1
comma
id|page
)paren
suffix:semicolon
id|nand_command
c_func
(paren
id|mtd
comma
id|NAND_CMD_ERASE2
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Wait for program operation to complete. This could&n;&t;&t; * take up to 4000us (4ms) on some devices, so we try&n;&t;&t; * and exit as quickly as possible.&n;&t;&t; */
id|status
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Delay for 125us */
id|udelay
(paren
l_int|125
)paren
suffix:semicolon
multiline_comment|/* Check the status */
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_STATUS
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|status
op_assign
(paren
r_int
)paren
id|readb
(paren
id|this-&gt;IO_ADDR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x40
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* See if block erase succeeded */
r_if
c_cond
(paren
id|status
op_amp
l_int|0x01
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_erase: &quot;
"&bslash;"
l_string|&quot;Failed erase, page 0x%08x&bslash;n&quot;
comma
id|page
)paren
suffix:semicolon
id|nand_deselect
(paren
)paren
suffix:semicolon
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Increment page address and decrement length */
id|len
op_sub_assign
id|mtd-&gt;erasesize
suffix:semicolon
id|page
op_add_assign
id|pages_per_block
suffix:semicolon
multiline_comment|/* Release the spin lock */
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|erase_retry
suffix:colon
multiline_comment|/* Check the state and sleep if it changed */
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;state
op_eq
id|FL_ERASING
)paren
(brace
r_continue
suffix:semicolon
)brace
r_else
(brace
id|set_current_state
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
(paren
op_amp
id|this-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|remove_wait_queue
(paren
op_amp
id|this-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
r_goto
id|erase_retry
suffix:semicolon
)brace
)brace
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
multiline_comment|/* De-select the NAND device */
id|nand_deselect
(paren
)paren
suffix:semicolon
multiline_comment|/* Do call back function */
r_if
c_cond
(paren
id|instr-&gt;callback
)paren
id|instr-&gt;callback
(paren
id|instr
)paren
suffix:semicolon
multiline_comment|/* The device is ready */
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
multiline_comment|/* Return happy */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * NAND sync&n; */
DECL|function|nand_sync
r_static
r_void
id|nand_sync
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;nand_sync: called&bslash;n&quot;
)paren
suffix:semicolon
id|retry
suffix:colon
multiline_comment|/* Grab the spinlock */
id|spin_lock_bh
c_func
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
multiline_comment|/* See what&squot;s going on */
r_switch
c_cond
(paren
id|this-&gt;state
)paren
(brace
r_case
id|FL_READY
suffix:colon
r_case
id|FL_SYNCING
suffix:colon
id|this-&gt;state
op_assign
id|FL_SYNCING
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Not an idle state */
id|add_wait_queue
(paren
op_amp
id|this-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|schedule
(paren
)paren
suffix:semicolon
id|remove_wait_queue
(paren
op_amp
id|this-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
multiline_comment|/* Lock the device */
id|spin_lock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
multiline_comment|/* Set the device to be ready again */
r_if
c_cond
(paren
id|this-&gt;state
op_eq
id|FL_SYNCING
)paren
(brace
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|wake_up
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
)brace
multiline_comment|/* Unlock the device */
id|spin_unlock_bh
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Scan for the NAND device&n; */
DECL|function|nand_scan
r_int
id|nand_scan
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_int
id|i
comma
id|nand_maf_id
comma
id|nand_dev_id
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
multiline_comment|/* Select the device */
id|nand_select
(paren
)paren
suffix:semicolon
multiline_comment|/* Send the command for reading device ID */
id|nand_command
(paren
id|mtd
comma
id|NAND_CMD_READID
comma
l_int|0x00
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Read manufacturer and device IDs */
id|nand_maf_id
op_assign
id|readb
(paren
id|this-&gt;IO_ADDR
)paren
suffix:semicolon
id|nand_dev_id
op_assign
id|readb
(paren
id|this-&gt;IO_ADDR
)paren
suffix:semicolon
multiline_comment|/* Print and store flash device information */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|nand_flash_ids
(braket
id|i
)braket
dot
id|name
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|nand_maf_id
op_eq
id|nand_flash_ids
(braket
id|i
)braket
dot
id|manufacture_id
op_logical_and
id|nand_dev_id
op_eq
id|nand_flash_ids
(braket
id|i
)braket
dot
id|model_id
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mtd-&gt;size
)paren
(brace
id|mtd-&gt;name
op_assign
id|nand_flash_ids
(braket
id|i
)braket
dot
id|name
suffix:semicolon
id|mtd-&gt;erasesize
op_assign
id|nand_flash_ids
(braket
id|i
)braket
dot
id|erasesize
suffix:semicolon
id|mtd-&gt;size
op_assign
(paren
l_int|1
op_lshift
id|nand_flash_ids
(braket
id|i
)braket
dot
id|chipshift
)paren
suffix:semicolon
id|mtd-&gt;eccsize
op_assign
l_int|256
suffix:semicolon
r_if
c_cond
(paren
id|nand_flash_ids
(braket
id|i
)braket
dot
id|page256
)paren
(brace
id|mtd-&gt;oobblock
op_assign
l_int|256
suffix:semicolon
id|mtd-&gt;oobsize
op_assign
l_int|8
suffix:semicolon
id|this-&gt;page_shift
op_assign
l_int|8
suffix:semicolon
)brace
r_else
(brace
id|mtd-&gt;oobblock
op_assign
l_int|512
suffix:semicolon
id|mtd-&gt;oobsize
op_assign
l_int|16
suffix:semicolon
id|this-&gt;page_shift
op_assign
l_int|9
suffix:semicolon
)brace
)brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;NAND device: Manufacture ID:&quot;
"&bslash;"
l_string|&quot; 0x%02x, Chip ID: 0x%02x (%s)&bslash;n&quot;
comma
id|nand_maf_id
comma
id|nand_dev_id
comma
id|mtd-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Initialize state and spinlock */
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
multiline_comment|/* De-select the device */
id|nand_deselect
(paren
)paren
suffix:semicolon
multiline_comment|/* Print warning message for no device */
r_if
c_cond
(paren
op_logical_neg
id|mtd-&gt;size
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;No NAND device found!!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Fill in remaining MTD driver data */
id|mtd-&gt;type
op_assign
id|MTD_NANDFLASH
suffix:semicolon
id|mtd-&gt;flags
op_assign
id|MTD_CAP_NANDFLASH
op_or
id|MTD_ECC
suffix:semicolon
id|mtd-&gt;module
op_assign
id|THIS_MODULE
suffix:semicolon
id|mtd-&gt;ecctype
op_assign
id|MTD_ECC_SW
suffix:semicolon
id|mtd-&gt;erase
op_assign
id|nand_erase
suffix:semicolon
id|mtd-&gt;point
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;unpoint
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;read
op_assign
id|nand_read
suffix:semicolon
id|mtd-&gt;write
op_assign
id|nand_write
suffix:semicolon
id|mtd-&gt;read_ecc
op_assign
id|nand_read_ecc
suffix:semicolon
id|mtd-&gt;write_ecc
op_assign
id|nand_write_ecc
suffix:semicolon
id|mtd-&gt;read_oob
op_assign
id|nand_read_oob
suffix:semicolon
id|mtd-&gt;write_oob
op_assign
id|nand_write_oob
suffix:semicolon
id|mtd-&gt;readv
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;writev
op_assign
id|nand_writev
suffix:semicolon
id|mtd-&gt;sync
op_assign
id|nand_sync
suffix:semicolon
id|mtd-&gt;lock
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;unlock
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;suspend
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;resume
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Return happy */
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|nand_scan
id|EXPORT_SYMBOL
c_func
(paren
id|nand_scan
)paren
suffix:semicolon
eof
