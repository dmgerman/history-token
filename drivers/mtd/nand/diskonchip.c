multiline_comment|/* &n; * drivers/mtd/nand/diskonchip.c&n; *&n; * (C) 2003 Red Hat, Inc.&n; *&n; * Author: David Woodhouse &lt;dwmw2@infradead.org&gt;&n; *&n; * Interface to generic NAND code for M-Systems DiskOnChip devices&n; *&n; * $Id: diskonchip.c,v 1.25 2004/07/16 13:54:27 dbrown Exp $&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/mtd/nand.h&gt;
macro_line|#include &lt;linux/mtd/doc2000.h&gt;
macro_line|#include &lt;linux/mtd/compatmac.h&gt;
macro_line|#include &lt;linux/mtd/partitions.h&gt;
macro_line|#include &lt;linux/mtd/inftl.h&gt;
multiline_comment|/* Where to look for the devices? */
macro_line|#ifndef CONFIG_MTD_DOCPROBE_ADDRESS
DECL|macro|CONFIG_MTD_DOCPROBE_ADDRESS
mdefine_line|#define CONFIG_MTD_DOCPROBE_ADDRESS 0
macro_line|#endif
DECL|variable|doc_locations
r_static
r_int
r_int
id|__initdata
id|doc_locations
(braket
)braket
op_assign
(brace
macro_line|#if defined (__alpha__) || defined(__i386__) || defined(__x86_64__)
macro_line|#ifdef CONFIG_MTD_DOCPROBE_HIGH
l_int|0xfffc8000
comma
l_int|0xfffca000
comma
l_int|0xfffcc000
comma
l_int|0xfffce000
comma
l_int|0xfffd0000
comma
l_int|0xfffd2000
comma
l_int|0xfffd4000
comma
l_int|0xfffd6000
comma
l_int|0xfffd8000
comma
l_int|0xfffda000
comma
l_int|0xfffdc000
comma
l_int|0xfffde000
comma
l_int|0xfffe0000
comma
l_int|0xfffe2000
comma
l_int|0xfffe4000
comma
l_int|0xfffe6000
comma
l_int|0xfffe8000
comma
l_int|0xfffea000
comma
l_int|0xfffec000
comma
l_int|0xfffee000
comma
macro_line|#else /*  CONFIG_MTD_DOCPROBE_HIGH */
l_int|0xc8000
comma
l_int|0xca000
comma
l_int|0xcc000
comma
l_int|0xce000
comma
l_int|0xd0000
comma
l_int|0xd2000
comma
l_int|0xd4000
comma
l_int|0xd6000
comma
l_int|0xd8000
comma
l_int|0xda000
comma
l_int|0xdc000
comma
l_int|0xde000
comma
l_int|0xe0000
comma
l_int|0xe2000
comma
l_int|0xe4000
comma
l_int|0xe6000
comma
l_int|0xe8000
comma
l_int|0xea000
comma
l_int|0xec000
comma
l_int|0xee000
comma
macro_line|#endif /*  CONFIG_MTD_DOCPROBE_HIGH */
macro_line|#elif defined(__PPC__)
l_int|0xe4000000
comma
macro_line|#elif defined(CONFIG_MOMENCO_OCELOT)
l_int|0x2f000000
comma
l_int|0xff000000
comma
macro_line|#elif defined(CONFIG_MOMENCO_OCELOT_G) || defined (CONFIG_MOMENCO_OCELOT_C)
l_int|0xff000000
comma
macro_line|##else
macro_line|#warning Unknown architecture for DiskOnChip. No default probe locations defined
macro_line|#endif
l_int|0xffffffff
)brace
suffix:semicolon
DECL|variable|doclist
r_static
r_struct
id|mtd_info
op_star
id|doclist
op_assign
l_int|NULL
suffix:semicolon
DECL|struct|doc_priv
r_struct
id|doc_priv
(brace
DECL|member|virtadr
r_int
r_int
id|virtadr
suffix:semicolon
DECL|member|physadr
r_int
r_int
id|physadr
suffix:semicolon
DECL|member|ChipID
id|u_char
id|ChipID
suffix:semicolon
DECL|member|CDSNControl
id|u_char
id|CDSNControl
suffix:semicolon
DECL|member|chips_per_floor
r_int
id|chips_per_floor
suffix:semicolon
multiline_comment|/* The number of chips detected on each floor */
DECL|member|curfloor
r_int
id|curfloor
suffix:semicolon
DECL|member|curchip
r_int
id|curchip
suffix:semicolon
DECL|member|mh0_page
r_int
id|mh0_page
suffix:semicolon
DECL|member|mh1_page
r_int
id|mh1_page
suffix:semicolon
DECL|member|nextdoc
r_struct
id|mtd_info
op_star
id|nextdoc
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Max number of eraseblocks to scan (from start of device) for the (I)NFTL&n;   MediaHeader.  The spec says to just keep going, I think, but that&squot;s just&n;   silly. */
DECL|macro|MAX_MEDIAHEADER_SCAN
mdefine_line|#define MAX_MEDIAHEADER_SCAN 8
multiline_comment|/* This is the syndrome computed by the HW ecc generator upon reading an empty&n;   page, one with all 0xff for data and stored ecc code. */
DECL|variable|empty_read_syndrome
r_static
id|u_char
id|empty_read_syndrome
(braket
l_int|6
)braket
op_assign
(brace
l_int|0x26
comma
l_int|0xff
comma
l_int|0x6d
comma
l_int|0x47
comma
l_int|0x73
comma
l_int|0x7a
)brace
suffix:semicolon
multiline_comment|/* This is the ecc value computed by the HW ecc generator upon writing an empty&n;   page, one with all 0xff for data. */
DECL|variable|empty_write_ecc
r_static
id|u_char
id|empty_write_ecc
(braket
l_int|6
)braket
op_assign
(brace
l_int|0x4b
comma
l_int|0x00
comma
l_int|0xe2
comma
l_int|0x0e
comma
l_int|0x93
comma
l_int|0xf7
)brace
suffix:semicolon
DECL|macro|INFTL_BBT_RESERVED_BLOCKS
mdefine_line|#define INFTL_BBT_RESERVED_BLOCKS 4
DECL|macro|DoC_is_Millennium
mdefine_line|#define DoC_is_Millennium(doc) ((doc)-&gt;ChipID == DOC_ChipID_DocMil)
DECL|macro|DoC_is_2000
mdefine_line|#define DoC_is_2000(doc) ((doc)-&gt;ChipID == DOC_ChipID_Doc2k)
r_static
r_void
id|doc200x_hwcontrol
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|doc200x_select_chip
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|chip
)paren
suffix:semicolon
DECL|variable|debug
r_static
r_int
id|debug
op_assign
l_int|0
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|variable|try_dword
r_static
r_int
id|try_dword
op_assign
l_int|1
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|try_dword
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|variable|no_ecc_failures
r_static
r_int
id|no_ecc_failures
op_assign
l_int|0
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|no_ecc_failures
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|variable|no_autopart
r_static
r_int
id|no_autopart
op_assign
l_int|0
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|no_autopart
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#ifdef MTD_NAND_DISKONCHIP_BBTWRITE
DECL|variable|inftl_bbt_write
r_static
r_int
id|inftl_bbt_write
op_assign
l_int|1
suffix:semicolon
macro_line|#else
DECL|variable|inftl_bbt_write
r_static
r_int
id|inftl_bbt_write
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|MODULE_PARM
c_func
(paren
id|inftl_bbt_write
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|variable|doc_config_location
r_static
r_int
r_int
id|doc_config_location
op_assign
id|CONFIG_MTD_DOCPROBE_ADDRESS
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|doc_config_location
comma
l_string|&quot;l&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|doc_config_location
comma
l_string|&quot;Physical memory address at which to probe for DiskOnChip&quot;
)paren
suffix:semicolon
DECL|function|DoC_Delay
r_static
r_void
id|DoC_Delay
c_func
(paren
r_struct
id|doc_priv
op_star
id|doc
comma
r_int
r_int
id|cycles
)paren
(brace
r_volatile
r_char
id|dummy
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cycles
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|DoC_is_Millennium
c_func
(paren
id|doc
)paren
)paren
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|NOP
)paren
suffix:semicolon
r_else
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|DOCStatus
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* DOC_WaitReady: Wait for RDY line to be asserted by the flash chip */
DECL|function|_DoC_WaitReady
r_static
r_int
id|_DoC_WaitReady
c_func
(paren
r_struct
id|doc_priv
op_star
id|doc
)paren
(brace
r_int
r_int
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
r_int
id|timeo
op_assign
id|jiffies
op_plus
(paren
id|HZ
op_star
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;_DoC_WaitReady...&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Out-of-line routine to wait for chip response */
r_while
c_loop
(paren
op_logical_neg
(paren
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNControl
)paren
op_amp
id|CDSN_CTRL_FR_B
)paren
)paren
(brace
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|timeo
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;_DoC_WaitReady timed out.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|DoC_WaitReady
r_static
r_inline
r_int
id|DoC_WaitReady
c_func
(paren
r_struct
id|doc_priv
op_star
id|doc
)paren
(brace
r_int
r_int
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNControl
)paren
op_amp
id|CDSN_CTRL_FR_B
)paren
)paren
multiline_comment|/* Call the out-of-line routine to wait */
id|ret
op_assign
id|_DoC_WaitReady
c_func
(paren
id|doc
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DoC_WaitReady OK&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|doc2000_write_byte
r_static
r_void
id|doc2000_write_byte
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u_char
id|datum
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_int
r_int
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;write_byte %02x&bslash;n&quot;
comma
id|datum
)paren
suffix:semicolon
)brace
id|WriteDOC
c_func
(paren
id|datum
comma
id|docptr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|datum
comma
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
suffix:semicolon
)brace
DECL|function|doc2000_read_byte
r_static
id|u_char
id|doc2000_read_byte
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_int
r_int
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
id|u_char
id|ret
suffix:semicolon
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|2
)paren
suffix:semicolon
id|ret
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|printk
c_func
(paren
l_string|&quot;read_byte returns %02x&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|doc2000_writebuf
r_static
r_void
id|doc2000_writebuf
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_int
r_int
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|printk
c_func
(paren
l_string|&quot;writebuf of %d bytes: &quot;
comma
id|len
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|WriteDOC_
c_func
(paren
id|buf
(braket
id|i
)braket
comma
id|docptr
comma
id|DoC_2k_CDSN_IO
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_logical_and
id|i
OL
l_int|16
)paren
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|buf
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|doc2000_readbuf
r_static
r_void
id|doc2000_readbuf
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_int
r_int
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|printk
c_func
(paren
l_string|&quot;readbuf of %d bytes: &quot;
comma
id|len
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|buf
(braket
id|i
)braket
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_CDSN_IO
op_plus
id|i
)paren
suffix:semicolon
)brace
)brace
DECL|function|doc2000_readbuf_dword
r_static
r_void
id|doc2000_readbuf_dword
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_int
r_int
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|printk
c_func
(paren
l_string|&quot;readbuf_dword of %d bytes: &quot;
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
(paren
(paren
r_int
r_int
)paren
id|buf
)paren
op_or
id|len
)paren
op_amp
l_int|3
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
(paren
r_uint8
op_star
)paren
(paren
op_amp
id|buf
(braket
id|i
)braket
)paren
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_CDSN_IO
op_plus
id|i
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_add_assign
l_int|4
)paren
(brace
op_star
(paren
r_uint32
op_star
)paren
(paren
op_amp
id|buf
(braket
id|i
)braket
)paren
op_assign
id|readl
c_func
(paren
id|docptr
op_plus
id|DoC_2k_CDSN_IO
op_plus
id|i
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|doc2000_verifybuf
r_static
r_int
id|doc2000_verifybuf
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_int
r_int
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_ne
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|doc200x_ident_chip
r_static
r_uint16
id|__init
id|doc200x_ident_chip
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|nr
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_uint16
id|ret
suffix:semicolon
id|doc200x_select_chip
c_func
(paren
id|mtd
comma
id|nr
)paren
suffix:semicolon
id|doc200x_hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_SETCLE
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|write_byte
c_func
(paren
id|mtd
comma
id|NAND_CMD_READID
)paren
suffix:semicolon
id|doc200x_hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_CLRCLE
)paren
suffix:semicolon
id|doc200x_hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_SETALE
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|write_byte
c_func
(paren
id|mtd
comma
l_int|0
)paren
suffix:semicolon
id|doc200x_hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_CLRALE
)paren
suffix:semicolon
id|ret
op_assign
id|this
op_member_access_from_pointer
id|read_byte
c_func
(paren
id|mtd
)paren
op_lshift
l_int|8
suffix:semicolon
id|ret
op_or_assign
id|this
op_member_access_from_pointer
id|read_byte
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|doc-&gt;ChipID
op_eq
id|DOC_ChipID_Doc2k
op_logical_and
id|try_dword
op_logical_and
op_logical_neg
id|nr
)paren
(brace
multiline_comment|/* First chip probe. See if we get same results by 32-bit access */
r_union
(brace
r_uint32
id|dword
suffix:semicolon
r_uint8
id|byte
(braket
l_int|4
)braket
suffix:semicolon
)brace
id|ident
suffix:semicolon
r_int
r_int
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
id|doc200x_hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_SETCLE
)paren
suffix:semicolon
id|doc2000_write_byte
c_func
(paren
id|mtd
comma
id|NAND_CMD_READID
)paren
suffix:semicolon
id|doc200x_hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_CLRCLE
)paren
suffix:semicolon
id|doc200x_hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_SETALE
)paren
suffix:semicolon
id|doc2000_write_byte
c_func
(paren
id|mtd
comma
l_int|0
)paren
suffix:semicolon
id|doc200x_hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_CLRALE
)paren
suffix:semicolon
id|ident.dword
op_assign
id|readl
c_func
(paren
id|docptr
op_plus
id|DoC_2k_CDSN_IO
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|ident.byte
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
op_or
id|ident.byte
(braket
l_int|1
)braket
)paren
op_eq
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;DiskOnChip 2000 responds to DWORD access&bslash;n&quot;
)paren
suffix:semicolon
id|this-&gt;read_buf
op_assign
op_amp
id|doc2000_readbuf_dword
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|doc2000_count_chips
r_static
r_void
id|__init
id|doc2000_count_chips
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_uint16
id|mfrid
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Max 4 chips per floor on DiskOnChip 2000 */
id|doc-&gt;chips_per_floor
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* Find out what the first chip is */
id|mfrid
op_assign
id|doc200x_ident_chip
c_func
(paren
id|mtd
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Find how many chips in each floor. */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|doc200x_ident_chip
c_func
(paren
id|mtd
comma
id|i
)paren
op_ne
id|mfrid
)paren
r_break
suffix:semicolon
)brace
id|doc-&gt;chips_per_floor
op_assign
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Detected %d chips per floor.&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
DECL|function|doc200x_wait
r_static
r_int
id|doc200x_wait
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|nand_chip
op_star
id|this
comma
r_int
id|state
)paren
(brace
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_int
id|status
suffix:semicolon
id|DoC_WaitReady
c_func
(paren
id|doc
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|cmdfunc
c_func
(paren
id|mtd
comma
id|NAND_CMD_STATUS
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|DoC_WaitReady
c_func
(paren
id|doc
)paren
suffix:semicolon
id|status
op_assign
(paren
r_int
)paren
id|this
op_member_access_from_pointer
id|read_byte
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
DECL|function|doc2001_write_byte
r_static
r_void
id|doc2001_write_byte
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u_char
id|datum
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_int
r_int
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
id|WriteDOC
c_func
(paren
id|datum
comma
id|docptr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|datum
comma
id|docptr
comma
id|Mil_CDSN_IO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|datum
comma
id|docptr
comma
id|WritePipeTerm
)paren
suffix:semicolon
)brace
DECL|function|doc2001_read_byte
r_static
id|u_char
id|doc2001_read_byte
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_int
r_int
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
singleline_comment|//ReadDOC(docptr, CDSNSlowIO);
multiline_comment|/* 11.4.5 -- delay twice to allow extended length cycle */
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|2
)paren
suffix:semicolon
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ReadPipeInit
)paren
suffix:semicolon
singleline_comment|//return ReadDOC(docptr, Mil_CDSN_IO);
r_return
id|ReadDOC
c_func
(paren
id|docptr
comma
id|LastDataRead
)paren
suffix:semicolon
)brace
DECL|function|doc2001_writebuf
r_static
r_void
id|doc2001_writebuf
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_int
r_int
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
id|WriteDOC_
c_func
(paren
id|buf
(braket
id|i
)braket
comma
id|docptr
comma
id|DoC_Mil_CDSN_IO
op_plus
id|i
)paren
suffix:semicolon
multiline_comment|/* Terminate write pipeline */
id|WriteDOC
c_func
(paren
l_int|0x00
comma
id|docptr
comma
id|WritePipeTerm
)paren
suffix:semicolon
)brace
DECL|function|doc2001_readbuf
r_static
r_void
id|doc2001_readbuf
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_int
r_int
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Start read pipeline */
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ReadPipeInit
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
id|buf
(braket
id|i
)braket
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mil_CDSN_IO
op_plus
(paren
id|i
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
multiline_comment|/* Terminate read pipeline */
id|buf
(braket
id|i
)braket
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|LastDataRead
)paren
suffix:semicolon
)brace
DECL|function|doc2001_verifybuf
r_static
r_int
id|doc2001_verifybuf
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_int
r_int
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Start read pipeline */
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ReadPipeInit
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_ne
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mil_CDSN_IO
)paren
)paren
(brace
id|ReadDOC
c_func
(paren
id|docptr
comma
id|LastDataRead
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_ne
id|ReadDOC
c_func
(paren
id|docptr
comma
id|LastDataRead
)paren
)paren
r_return
id|i
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|doc200x_select_chip
r_static
r_void
id|doc200x_select_chip
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|chip
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_int
r_int
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
id|floor
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 11.4.4 -- deassert CE before changing chip */
id|doc200x_hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_CLRNCE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;select chip (%d)&bslash;n&quot;
comma
id|chip
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chip
op_eq
op_minus
l_int|1
)paren
r_return
suffix:semicolon
id|floor
op_assign
id|chip
op_div
id|doc-&gt;chips_per_floor
suffix:semicolon
id|chip
op_sub_assign
(paren
id|floor
op_star
id|doc-&gt;chips_per_floor
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|floor
comma
id|docptr
comma
id|FloorSelect
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|chip
comma
id|docptr
comma
id|CDSNDeviceSelect
)paren
suffix:semicolon
id|doc200x_hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_SETNCE
)paren
suffix:semicolon
id|doc-&gt;curchip
op_assign
id|chip
suffix:semicolon
id|doc-&gt;curfloor
op_assign
id|floor
suffix:semicolon
)brace
DECL|function|doc200x_hwcontrol
r_static
r_void
id|doc200x_hwcontrol
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|cmd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_int
r_int
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|NAND_CTL_SETNCE
suffix:colon
id|doc-&gt;CDSNControl
op_or_assign
id|CDSN_CTRL_CE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_CTL_CLRNCE
suffix:colon
id|doc-&gt;CDSNControl
op_and_assign
op_complement
id|CDSN_CTRL_CE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_CTL_SETCLE
suffix:colon
id|doc-&gt;CDSNControl
op_or_assign
id|CDSN_CTRL_CLE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_CTL_CLRCLE
suffix:colon
id|doc-&gt;CDSNControl
op_and_assign
op_complement
id|CDSN_CTRL_CLE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_CTL_SETALE
suffix:colon
id|doc-&gt;CDSNControl
op_or_assign
id|CDSN_CTRL_ALE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_CTL_CLRALE
suffix:colon
id|doc-&gt;CDSNControl
op_and_assign
op_complement
id|CDSN_CTRL_ALE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_CTL_SETWP
suffix:colon
id|doc-&gt;CDSNControl
op_or_assign
id|CDSN_CTRL_WP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_CTL_CLRWP
suffix:colon
id|doc-&gt;CDSNControl
op_and_assign
op_complement
id|CDSN_CTRL_WP
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug
)paren
id|printk
c_func
(paren
l_string|&quot;hwcontrol(%d): %02x&bslash;n&quot;
comma
id|cmd
comma
id|doc-&gt;CDSNControl
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|doc-&gt;CDSNControl
comma
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
multiline_comment|/* 11.4.3 -- 4 NOPs after CSDNControl write */
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|4
)paren
suffix:semicolon
)brace
DECL|function|doc200x_dev_ready
r_static
r_int
id|doc200x_dev_ready
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_int
r_int
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
multiline_comment|/* 11.4.2 -- must NOP four times before checking FR/B# */
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNControl
)paren
op_amp
id|CDSN_CTRL_FR_B
)paren
)paren
(brace
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;not ready&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* 11.4.2 -- Must NOP twice if it&squot;s ready */
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|printk
c_func
(paren
l_string|&quot;was ready&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|doc200x_block_bad
r_static
r_int
id|doc200x_block_bad
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|ofs
comma
r_int
id|getchip
)paren
(brace
multiline_comment|/* This is our last resort if we couldn&squot;t find or create a BBT.  Just&n;&t;   pretend all blocks are good. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|doc200x_enable_hwecc
r_static
r_void
id|doc200x_enable_hwecc
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|mode
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_int
r_int
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
multiline_comment|/* Prime the ECC engine */
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|NAND_ECC_READ
suffix:colon
id|WriteDOC
c_func
(paren
id|DOC_ECC_RESET
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|DOC_ECC_EN
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_ECC_WRITE
suffix:colon
id|WriteDOC
c_func
(paren
id|DOC_ECC_RESET
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|DOC_ECC_EN
op_or
id|DOC_ECC_RW
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* This code is only called on write */
DECL|function|doc200x_calculate_ecc
r_static
r_int
id|doc200x_calculate_ecc
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
id|u_char
op_star
id|dat
comma
r_int
r_char
op_star
id|ecc_code
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_int
r_int
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|emptymatch
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* flush the pipeline */
r_if
c_cond
(paren
id|DoC_is_2000
c_func
(paren
id|doc
)paren
)paren
(brace
id|WriteDOC
c_func
(paren
id|doc-&gt;CDSNControl
op_amp
op_complement
id|CDSN_CTRL_FLASH_IO
comma
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|doc-&gt;CDSNControl
comma
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
)brace
r_else
(brace
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
id|NOP
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
id|NOP
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
id|NOP
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ecc_code
(braket
id|i
)braket
op_assign
id|ReadDOC_
c_func
(paren
id|docptr
comma
id|DoC_ECCSyndrome0
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ecc_code
(braket
id|i
)braket
op_ne
id|empty_write_ecc
(braket
id|i
)braket
)paren
id|emptymatch
op_assign
l_int|0
suffix:semicolon
)brace
id|WriteDOC
c_func
(paren
id|DOC_ECC_DIS
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* If emptymatch=1, we might have an all-0xff data buffer.  Check. */
r_if
c_cond
(paren
id|emptymatch
)paren
(brace
multiline_comment|/* Note: this somewhat expensive test should not be triggered&n;&t;&t;   often.  It could be optimized away by examining the data in&n;&t;&t;   the writebuf routine, and remembering the result. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|512
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dat
(braket
id|i
)braket
op_eq
l_int|0xff
)paren
r_continue
suffix:semicolon
id|emptymatch
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* If emptymatch still =1, we do have an all-0xff data buffer.&n;&t;   Return all-0xff ecc value instead of the computed one, so&n;&t;   it&squot;ll look just like a freshly-erased page. */
r_if
c_cond
(paren
id|emptymatch
)paren
id|memset
c_func
(paren
id|ecc_code
comma
l_int|0xff
comma
l_int|6
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|doc200x_correct_data
r_static
r_int
id|doc200x_correct_data
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u_char
op_star
id|dat
comma
id|u_char
op_star
id|read_ecc
comma
id|u_char
op_star
id|calc_ecc
)paren
(brace
r_int
id|i
comma
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_int
r_int
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_volatile
id|u_char
id|dummy
suffix:semicolon
r_int
id|emptymatch
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* flush the pipeline */
r_if
c_cond
(paren
id|DoC_is_2000
c_func
(paren
id|doc
)paren
)paren
(brace
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_ECCStatus
)paren
suffix:semicolon
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_ECCStatus
)paren
suffix:semicolon
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_ECCStatus
)paren
suffix:semicolon
)brace
r_else
(brace
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
)brace
multiline_comment|/* Error occured ? */
r_if
c_cond
(paren
id|dummy
op_amp
l_int|0x80
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|calc_ecc
(braket
id|i
)braket
op_assign
id|ReadDOC_
c_func
(paren
id|docptr
comma
id|DoC_ECCSyndrome0
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|calc_ecc
(braket
id|i
)braket
op_ne
id|empty_read_syndrome
(braket
id|i
)braket
)paren
id|emptymatch
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If emptymatch=1, the read syndrome is consistent with an&n;&t;&t;   all-0xff data and stored ecc block.  Check the stored ecc. */
r_if
c_cond
(paren
id|emptymatch
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|read_ecc
(braket
id|i
)braket
op_eq
l_int|0xff
)paren
r_continue
suffix:semicolon
id|emptymatch
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* If emptymatch still =1, check the data block. */
r_if
c_cond
(paren
id|emptymatch
)paren
(brace
multiline_comment|/* Note: this somewhat expensive test should not be triggered&n;&t;&t;   often.  It could be optimized away by examining the data in&n;&t;&t;   the readbuf routine, and remembering the result. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|512
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dat
(braket
id|i
)braket
op_eq
l_int|0xff
)paren
r_continue
suffix:semicolon
id|emptymatch
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* If emptymatch still =1, this is almost certainly a freshly-&n;&t;&t;   erased block, in which case the ECC will not come out right.&n;&t;&t;   We&squot;ll suppress the error and tell the caller everything&squot;s&n;&t;&t;   OK.  Because it is. */
r_if
c_cond
(paren
op_logical_neg
id|emptymatch
)paren
id|ret
op_assign
id|doc_decode_ecc
(paren
id|dat
comma
id|calc_ecc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OG
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;doc200x_correct_data corrected %d errors&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
)brace
id|WriteDOC
c_func
(paren
id|DOC_ECC_DIS
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|no_ecc_failures
op_logical_and
(paren
id|ret
op_eq
op_minus
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;suppressing ECC failure&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
singleline_comment|//u_char mydatabuf[528];
DECL|variable|doc200x_oobinfo
r_static
r_struct
id|nand_oobinfo
id|doc200x_oobinfo
op_assign
(brace
dot
id|useecc
op_assign
id|MTD_NANDECC_AUTOPLACE
comma
dot
id|eccbytes
op_assign
l_int|6
comma
dot
id|eccpos
op_assign
(brace
l_int|0
comma
l_int|1
comma
l_int|2
comma
l_int|3
comma
l_int|4
comma
l_int|5
)brace
comma
dot
id|oobfree
op_assign
(brace
(brace
l_int|8
comma
l_int|8
)brace
)brace
)brace
suffix:semicolon
multiline_comment|/* Find the (I)NFTL Media Header, and optionally also the mirror media header.&n;   On sucessful return, buf will contain a copy of the media header for&n;   further processing.  id is the string to scan for, and will presumably be&n;   either &quot;ANAND&quot; or &quot;BNAND&quot;.  If findmirror=1, also look for the mirror media&n;   header.  The page #s of the found media headers are placed in mh0_page and&n;   mh1_page in the DOC private structure. */
DECL|function|find_media_headers
r_static
r_int
id|__init
id|find_media_headers
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u_char
op_star
id|buf
comma
r_const
r_char
op_star
id|id
comma
r_int
id|findmirror
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_int
id|offs
comma
id|end
op_assign
(paren
id|MAX_MEDIAHEADER_SCAN
op_lshift
id|this-&gt;phys_erase_shift
)paren
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|retlen
suffix:semicolon
id|end
op_assign
id|min
c_func
(paren
id|end
comma
(paren
r_int
)paren
id|mtd-&gt;size
)paren
suffix:semicolon
singleline_comment|// paranoia
r_for
c_loop
(paren
id|offs
op_assign
l_int|0
suffix:semicolon
id|offs
OL
id|end
suffix:semicolon
id|offs
op_add_assign
id|mtd-&gt;erasesize
)paren
(brace
id|ret
op_assign
id|mtd
op_member_access_from_pointer
id|read
c_func
(paren
id|mtd
comma
id|offs
comma
id|mtd-&gt;oobblock
comma
op_amp
id|retlen
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retlen
op_ne
id|mtd-&gt;oobblock
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ECC error scanning DOC at 0x%x&bslash;n&quot;
comma
id|offs
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|buf
comma
id|id
comma
l_int|6
)paren
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Found DiskOnChip %s Media Header at 0x%x&bslash;n&quot;
comma
id|id
comma
id|offs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|doc-&gt;mh0_page
op_eq
op_minus
l_int|1
)paren
(brace
id|doc-&gt;mh0_page
op_assign
id|offs
op_rshift
id|this-&gt;page_shift
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|findmirror
)paren
r_return
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|doc-&gt;mh1_page
op_assign
id|offs
op_rshift
id|this-&gt;page_shift
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|doc-&gt;mh0_page
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;DiskOnChip %s Media Header not found.&bslash;n&quot;
comma
id|id
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Only one mediaheader was found.  We want buf to contain a&n;&t;   mediaheader on return, so we&squot;ll have to re-read the one we found. */
id|offs
op_assign
id|doc-&gt;mh0_page
op_lshift
id|this-&gt;page_shift
suffix:semicolon
id|ret
op_assign
id|mtd
op_member_access_from_pointer
id|read
c_func
(paren
id|mtd
comma
id|offs
comma
id|mtd-&gt;oobblock
comma
op_amp
id|retlen
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retlen
op_ne
id|mtd-&gt;oobblock
)paren
(brace
multiline_comment|/* Insanity.  Give up. */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Read DiskOnChip Media Header once, but can&squot;t reread it???&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|nftl_partscan
r_static
r_inline
r_int
id|__init
id|nftl_partscan
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|mtd_partition
op_star
id|parts
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
id|u_char
op_star
id|buf
op_assign
id|this-&gt;data_buf
suffix:semicolon
r_struct
id|NFTLMediaHeader
op_star
id|mh
op_assign
(paren
r_struct
id|NFTLMediaHeader
op_star
)paren
id|buf
suffix:semicolon
r_const
r_int
id|psize
op_assign
l_int|1
op_lshift
id|this-&gt;page_shift
suffix:semicolon
r_int
id|blocks
comma
id|maxblocks
suffix:semicolon
r_int
id|offs
comma
id|numheaders
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|numheaders
op_assign
id|find_media_headers
c_func
(paren
id|mtd
comma
id|buf
comma
l_string|&quot;ANAND&quot;
comma
l_int|1
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
singleline_comment|//#ifdef CONFIG_MTD_DEBUG_VERBOSE
singleline_comment|//&t;if (CONFIG_MTD_DEBUG_VERBOSE &gt;= 2)
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    DataOrgID        = %s&bslash;n&quot;
l_string|&quot;    NumEraseUnits    = %d&bslash;n&quot;
l_string|&quot;    FirstPhysicalEUN = %d&bslash;n&quot;
l_string|&quot;    FormattedSize    = %d&bslash;n&quot;
l_string|&quot;    UnitSizeFactor   = %d&bslash;n&quot;
comma
id|mh-&gt;DataOrgID
comma
id|mh-&gt;NumEraseUnits
comma
id|mh-&gt;FirstPhysicalEUN
comma
id|mh-&gt;FormattedSize
comma
id|mh-&gt;UnitSizeFactor
)paren
suffix:semicolon
singleline_comment|//#endif
id|blocks
op_assign
id|mtd-&gt;size
op_rshift
id|this-&gt;phys_erase_shift
suffix:semicolon
id|maxblocks
op_assign
id|min
c_func
(paren
l_int|32768
comma
(paren
r_int
)paren
id|mtd-&gt;erasesize
op_minus
id|psize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mh-&gt;UnitSizeFactor
op_eq
l_int|0x00
)paren
(brace
multiline_comment|/* Auto-determine UnitSizeFactor.  The constraints are:&n;&t;&t;   - There can be at most 32768 virtual blocks.&n;&t;&t;   - There can be at most (virtual block size - page size)&n;&t;&t;     virtual blocks (because MediaHeader+BBT must fit in 1).&n;&t;&t;*/
id|mh-&gt;UnitSizeFactor
op_assign
l_int|0xff
suffix:semicolon
r_while
c_loop
(paren
id|blocks
OG
id|maxblocks
)paren
(brace
id|blocks
op_rshift_assign
l_int|1
suffix:semicolon
id|maxblocks
op_assign
id|min
c_func
(paren
l_int|32768
comma
(paren
id|maxblocks
op_lshift
l_int|1
)paren
op_plus
id|psize
)paren
suffix:semicolon
id|mh-&gt;UnitSizeFactor
op_decrement
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;UnitSizeFactor=0x00 detected.  Correct value is assumed to be 0x%02x.&bslash;n&quot;
comma
id|mh-&gt;UnitSizeFactor
)paren
suffix:semicolon
)brace
multiline_comment|/* NOTE: The lines below modify internal variables of the NAND and MTD&n;&t;   layers; variables with have already been configured by nand_scan.&n;&t;   Unfortunately, we didn&squot;t know before this point what these values&n;&t;   should be.  Thus, this code is somewhat dependant on the exact&n;&t;   implementation of the NAND layer.  */
r_if
c_cond
(paren
id|mh-&gt;UnitSizeFactor
op_ne
l_int|0xff
)paren
(brace
id|this-&gt;bbt_erase_shift
op_add_assign
(paren
l_int|0xff
op_minus
id|mh-&gt;UnitSizeFactor
)paren
suffix:semicolon
id|mtd-&gt;erasesize
op_lshift_assign
(paren
l_int|0xff
op_minus
id|mh-&gt;UnitSizeFactor
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Setting virtual erase size to %d&bslash;n&quot;
comma
id|mtd-&gt;erasesize
)paren
suffix:semicolon
id|blocks
op_assign
id|mtd-&gt;size
op_rshift
id|this-&gt;bbt_erase_shift
suffix:semicolon
id|maxblocks
op_assign
id|min
c_func
(paren
l_int|32768
comma
(paren
r_int
)paren
id|mtd-&gt;erasesize
op_minus
id|psize
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|blocks
OG
id|maxblocks
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;UnitSizeFactor of 0x%02x is inconsistent with device size.  Aborting.&bslash;n&quot;
comma
id|mh-&gt;UnitSizeFactor
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Skip past the media headers. */
id|offs
op_assign
id|max
c_func
(paren
id|doc-&gt;mh0_page
comma
id|doc-&gt;mh1_page
)paren
suffix:semicolon
id|offs
op_lshift_assign
id|this-&gt;page_shift
suffix:semicolon
id|offs
op_add_assign
id|mtd-&gt;erasesize
suffix:semicolon
singleline_comment|//parts[0].name = &quot; DiskOnChip Boot / Media Header partition&quot;;
singleline_comment|//parts[0].offset = 0;
singleline_comment|//parts[0].size = offs;
id|parts
(braket
l_int|0
)braket
dot
id|name
op_assign
l_string|&quot; DiskOnChip BDTL partition&quot;
suffix:semicolon
id|parts
(braket
l_int|0
)braket
dot
id|offset
op_assign
id|offs
suffix:semicolon
id|parts
(braket
l_int|0
)braket
dot
id|size
op_assign
(paren
id|mh-&gt;NumEraseUnits
op_minus
id|numheaders
)paren
op_lshift
id|this-&gt;bbt_erase_shift
suffix:semicolon
id|offs
op_add_assign
id|parts
(braket
l_int|0
)braket
dot
id|size
suffix:semicolon
r_if
c_cond
(paren
id|offs
OL
id|mtd-&gt;size
)paren
(brace
id|parts
(braket
l_int|1
)braket
dot
id|name
op_assign
l_string|&quot; DiskOnChip Remainder partition&quot;
suffix:semicolon
id|parts
(braket
l_int|1
)braket
dot
id|offset
op_assign
id|offs
suffix:semicolon
id|parts
(braket
l_int|1
)braket
dot
id|size
op_assign
id|mtd-&gt;size
op_minus
id|offs
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* This is a stripped-down copy of the code in inftlmount.c */
DECL|function|inftl_partscan
r_static
r_inline
r_int
id|__init
id|inftl_partscan
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|mtd_partition
op_star
id|parts
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
id|u_char
op_star
id|buf
op_assign
id|this-&gt;data_buf
suffix:semicolon
r_struct
id|INFTLMediaHeader
op_star
id|mh
op_assign
(paren
r_struct
id|INFTLMediaHeader
op_star
)paren
id|buf
suffix:semicolon
r_struct
id|INFTLPartition
op_star
id|ip
suffix:semicolon
r_int
id|numparts
op_assign
l_int|0
suffix:semicolon
r_int
id|blocks
suffix:semicolon
r_int
id|vshift
comma
id|lastvunit
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|end
op_assign
id|mtd-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|inftl_bbt_write
)paren
id|end
op_sub_assign
(paren
id|INFTL_BBT_RESERVED_BLOCKS
op_lshift
id|this-&gt;phys_erase_shift
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|find_media_headers
c_func
(paren
id|mtd
comma
id|buf
comma
l_string|&quot;BNAND&quot;
comma
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|doc-&gt;mh1_page
op_assign
id|doc-&gt;mh0_page
op_plus
(paren
l_int|4096
op_rshift
id|this-&gt;page_shift
)paren
suffix:semicolon
id|mh-&gt;NoOfBootImageBlocks
op_assign
id|le32_to_cpu
c_func
(paren
id|mh-&gt;NoOfBootImageBlocks
)paren
suffix:semicolon
id|mh-&gt;NoOfBinaryPartitions
op_assign
id|le32_to_cpu
c_func
(paren
id|mh-&gt;NoOfBinaryPartitions
)paren
suffix:semicolon
id|mh-&gt;NoOfBDTLPartitions
op_assign
id|le32_to_cpu
c_func
(paren
id|mh-&gt;NoOfBDTLPartitions
)paren
suffix:semicolon
id|mh-&gt;BlockMultiplierBits
op_assign
id|le32_to_cpu
c_func
(paren
id|mh-&gt;BlockMultiplierBits
)paren
suffix:semicolon
id|mh-&gt;FormatFlags
op_assign
id|le32_to_cpu
c_func
(paren
id|mh-&gt;FormatFlags
)paren
suffix:semicolon
id|mh-&gt;PercentUsed
op_assign
id|le32_to_cpu
c_func
(paren
id|mh-&gt;PercentUsed
)paren
suffix:semicolon
singleline_comment|//#ifdef CONFIG_MTD_DEBUG_VERBOSE
singleline_comment|//&t;if (CONFIG_MTD_DEBUG_VERBOSE &gt;= 2)
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    bootRecordID          = %s&bslash;n&quot;
l_string|&quot;    NoOfBootImageBlocks   = %d&bslash;n&quot;
l_string|&quot;    NoOfBinaryPartitions  = %d&bslash;n&quot;
l_string|&quot;    NoOfBDTLPartitions    = %d&bslash;n&quot;
l_string|&quot;    BlockMultiplerBits    = %d&bslash;n&quot;
l_string|&quot;    FormatFlgs            = %d&bslash;n&quot;
l_string|&quot;    OsakVersion           = 0x%x&bslash;n&quot;
l_string|&quot;    PercentUsed           = %d&bslash;n&quot;
comma
id|mh-&gt;bootRecordID
comma
id|mh-&gt;NoOfBootImageBlocks
comma
id|mh-&gt;NoOfBinaryPartitions
comma
id|mh-&gt;NoOfBDTLPartitions
comma
id|mh-&gt;BlockMultiplierBits
comma
id|mh-&gt;FormatFlags
comma
id|mh-&gt;OsakVersion
comma
id|mh-&gt;PercentUsed
)paren
suffix:semicolon
singleline_comment|//#endif
id|vshift
op_assign
id|this-&gt;phys_erase_shift
op_plus
id|mh-&gt;BlockMultiplierBits
suffix:semicolon
id|blocks
op_assign
id|mtd-&gt;size
op_rshift
id|vshift
suffix:semicolon
r_if
c_cond
(paren
id|blocks
OG
l_int|32768
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;BlockMultiplierBits=%d is inconsistent with device size.  Aborting.&bslash;n&quot;
comma
id|mh-&gt;BlockMultiplierBits
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|blocks
op_assign
id|doc-&gt;chips_per_floor
op_lshift
(paren
id|this-&gt;chip_shift
op_minus
id|this-&gt;phys_erase_shift
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inftl_bbt_write
op_logical_and
(paren
id|blocks
OG
id|mtd-&gt;erasesize
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Writeable BBTs spanning more than one erase block are not yet supported.  FIX ME!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Scan the partitions */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
l_int|4
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ip
op_assign
op_amp
(paren
id|mh-&gt;Partitions
(braket
id|i
)braket
)paren
suffix:semicolon
id|ip-&gt;virtualUnits
op_assign
id|le32_to_cpu
c_func
(paren
id|ip-&gt;virtualUnits
)paren
suffix:semicolon
id|ip-&gt;firstUnit
op_assign
id|le32_to_cpu
c_func
(paren
id|ip-&gt;firstUnit
)paren
suffix:semicolon
id|ip-&gt;lastUnit
op_assign
id|le32_to_cpu
c_func
(paren
id|ip-&gt;lastUnit
)paren
suffix:semicolon
id|ip-&gt;flags
op_assign
id|le32_to_cpu
c_func
(paren
id|ip-&gt;flags
)paren
suffix:semicolon
id|ip-&gt;spareUnits
op_assign
id|le32_to_cpu
c_func
(paren
id|ip-&gt;spareUnits
)paren
suffix:semicolon
id|ip-&gt;Reserved0
op_assign
id|le32_to_cpu
c_func
(paren
id|ip-&gt;Reserved0
)paren
suffix:semicolon
singleline_comment|//#ifdef CONFIG_MTD_DEBUG_VERBOSE
singleline_comment|//&t;&t;if (CONFIG_MTD_DEBUG_VERBOSE &gt;= 2)
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    PARTITION[%d] -&gt;&bslash;n&quot;
l_string|&quot;        virtualUnits    = %d&bslash;n&quot;
l_string|&quot;        firstUnit       = %d&bslash;n&quot;
l_string|&quot;        lastUnit        = %d&bslash;n&quot;
l_string|&quot;        flags           = 0x%x&bslash;n&quot;
l_string|&quot;        spareUnits      = %d&bslash;n&quot;
comma
id|i
comma
id|ip-&gt;virtualUnits
comma
id|ip-&gt;firstUnit
comma
id|ip-&gt;lastUnit
comma
id|ip-&gt;flags
comma
id|ip-&gt;spareUnits
)paren
suffix:semicolon
singleline_comment|//#endif
multiline_comment|/*&n;&t;&t;if ((i == 0) &amp;&amp; (ip-&gt;firstUnit &gt; 0)) {&n;&t;&t;&t;parts[0].name = &quot; DiskOnChip IPL / Media Header partition&quot;;&n;&t;&t;&t;parts[0].offset = 0;&n;&t;&t;&t;parts[0].size = mtd-&gt;erasesize * ip-&gt;firstUnit;&n;&t;&t;&t;numparts = 1;&n;&t;&t;}&n;*/
r_if
c_cond
(paren
id|ip-&gt;flags
op_amp
id|INFTL_BINARY
)paren
id|parts
(braket
id|numparts
)braket
dot
id|name
op_assign
l_string|&quot; DiskOnChip BDK partition&quot;
suffix:semicolon
r_else
id|parts
(braket
id|numparts
)braket
dot
id|name
op_assign
l_string|&quot; DiskOnChip BDTL partition&quot;
suffix:semicolon
id|parts
(braket
id|numparts
)braket
dot
id|offset
op_assign
id|ip-&gt;firstUnit
op_lshift
id|vshift
suffix:semicolon
id|parts
(braket
id|numparts
)braket
dot
id|size
op_assign
(paren
l_int|1
op_plus
id|ip-&gt;lastUnit
op_minus
id|ip-&gt;firstUnit
)paren
op_lshift
id|vshift
suffix:semicolon
id|numparts
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;lastUnit
OG
id|lastvunit
)paren
id|lastvunit
op_assign
id|ip-&gt;lastUnit
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;flags
op_amp
id|INFTL_LAST
)paren
r_break
suffix:semicolon
)brace
id|lastvunit
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lastvunit
op_lshift
id|vshift
)paren
OL
id|end
)paren
(brace
id|parts
(braket
id|numparts
)braket
dot
id|name
op_assign
l_string|&quot; DiskOnChip Remainder partition&quot;
suffix:semicolon
id|parts
(braket
id|numparts
)braket
dot
id|offset
op_assign
id|lastvunit
op_lshift
id|vshift
suffix:semicolon
id|parts
(braket
id|numparts
)braket
dot
id|size
op_assign
id|end
op_minus
id|parts
(braket
id|numparts
)braket
dot
id|offset
suffix:semicolon
id|numparts
op_increment
suffix:semicolon
)brace
r_return
id|numparts
suffix:semicolon
)brace
DECL|function|nftl_scan_bbt
r_static
r_int
id|__init
id|nftl_scan_bbt
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_int
id|ret
comma
id|numparts
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_struct
id|mtd_partition
id|parts
(braket
l_int|2
)braket
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|parts
comma
l_int|0
comma
r_sizeof
(paren
id|parts
)paren
)paren
suffix:semicolon
multiline_comment|/* On NFTL, we have to find the media headers before we can read the&n;&t;   BBTs, since they&squot;re stored in the media header eraseblocks. */
id|numparts
op_assign
id|nftl_partscan
c_func
(paren
id|mtd
comma
id|parts
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|numparts
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|this-&gt;bbt_td-&gt;options
op_assign
id|NAND_BBT_ABSPAGE
op_or
id|NAND_BBT_8BIT
op_or
id|NAND_BBT_SAVECONTENT
op_or
id|NAND_BBT_WRITE
op_or
id|NAND_BBT_VERSION
suffix:semicolon
id|this-&gt;bbt_td-&gt;veroffs
op_assign
l_int|7
suffix:semicolon
id|this-&gt;bbt_td-&gt;pages
(braket
l_int|0
)braket
op_assign
id|doc-&gt;mh0_page
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|doc-&gt;mh1_page
op_ne
op_minus
l_int|1
)paren
(brace
id|this-&gt;bbt_md-&gt;options
op_assign
id|NAND_BBT_ABSPAGE
op_or
id|NAND_BBT_8BIT
op_or
id|NAND_BBT_SAVECONTENT
op_or
id|NAND_BBT_WRITE
op_or
id|NAND_BBT_VERSION
suffix:semicolon
id|this-&gt;bbt_md-&gt;veroffs
op_assign
l_int|7
suffix:semicolon
id|this-&gt;bbt_md-&gt;pages
(braket
l_int|0
)braket
op_assign
id|doc-&gt;mh1_page
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|this-&gt;bbt_md
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* It&squot;s safe to set bd=NULL below because NAND_BBT_CREATE is not set.&n;&t;   At least as nand_bbt.c is currently written. */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|nand_scan_bbt
c_func
(paren
id|mtd
comma
l_int|NULL
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|add_mtd_device
c_func
(paren
id|mtd
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_MTD_PARTITIONS) || defined(CONFIG_MTD_PARTITIONS_MODULE)
r_if
c_cond
(paren
op_logical_neg
id|no_autopart
)paren
id|add_mtd_partitions
c_func
(paren
id|mtd
comma
id|parts
comma
id|numparts
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|inftl_scan_bbt
r_static
r_int
id|__init
id|inftl_scan_bbt
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_int
id|ret
comma
id|numparts
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_struct
id|mtd_partition
id|parts
(braket
l_int|5
)braket
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;numchips
OG
id|doc-&gt;chips_per_floor
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Multi-floor INFTL devices not yet supported.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|this-&gt;bbt_td-&gt;options
op_assign
id|NAND_BBT_LASTBLOCK
op_or
id|NAND_BBT_8BIT
op_or
id|NAND_BBT_VERSION
suffix:semicolon
r_if
c_cond
(paren
id|inftl_bbt_write
)paren
id|this-&gt;bbt_td-&gt;options
op_or_assign
id|NAND_BBT_WRITE
suffix:semicolon
id|this-&gt;bbt_td-&gt;offs
op_assign
l_int|8
suffix:semicolon
id|this-&gt;bbt_td-&gt;len
op_assign
l_int|8
suffix:semicolon
id|this-&gt;bbt_td-&gt;veroffs
op_assign
l_int|7
suffix:semicolon
id|this-&gt;bbt_td-&gt;maxblocks
op_assign
id|INFTL_BBT_RESERVED_BLOCKS
suffix:semicolon
id|this-&gt;bbt_td-&gt;reserved_block_code
op_assign
l_int|0x01
suffix:semicolon
id|this-&gt;bbt_td-&gt;pattern
op_assign
l_string|&quot;MSYS_BBT&quot;
suffix:semicolon
id|this-&gt;bbt_md-&gt;options
op_assign
id|NAND_BBT_LASTBLOCK
op_or
id|NAND_BBT_8BIT
op_or
id|NAND_BBT_VERSION
suffix:semicolon
r_if
c_cond
(paren
id|inftl_bbt_write
)paren
id|this-&gt;bbt_md-&gt;options
op_or_assign
id|NAND_BBT_WRITE
suffix:semicolon
id|this-&gt;bbt_md-&gt;offs
op_assign
l_int|8
suffix:semicolon
id|this-&gt;bbt_md-&gt;len
op_assign
l_int|8
suffix:semicolon
id|this-&gt;bbt_md-&gt;veroffs
op_assign
l_int|7
suffix:semicolon
id|this-&gt;bbt_md-&gt;maxblocks
op_assign
id|INFTL_BBT_RESERVED_BLOCKS
suffix:semicolon
id|this-&gt;bbt_md-&gt;reserved_block_code
op_assign
l_int|0x01
suffix:semicolon
id|this-&gt;bbt_md-&gt;pattern
op_assign
l_string|&quot;TBB_SYSM&quot;
suffix:semicolon
multiline_comment|/* It&squot;s safe to set bd=NULL below because NAND_BBT_CREATE is not set.&n;&t;   At least as nand_bbt.c is currently written. */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|nand_scan_bbt
c_func
(paren
id|mtd
comma
l_int|NULL
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|parts
comma
l_int|0
comma
r_sizeof
(paren
id|parts
)paren
)paren
suffix:semicolon
id|numparts
op_assign
id|inftl_partscan
c_func
(paren
id|mtd
comma
id|parts
)paren
suffix:semicolon
multiline_comment|/* At least for now, require the INFTL Media Header.  We could probably&n;&t;   do without it for non-INFTL use, since all it gives us is&n;&t;   autopartitioning, but I want to give it more thought. */
r_if
c_cond
(paren
op_logical_neg
id|numparts
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|add_mtd_device
c_func
(paren
id|mtd
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_MTD_PARTITIONS) || defined(CONFIG_MTD_PARTITIONS_MODULE)
r_if
c_cond
(paren
op_logical_neg
id|no_autopart
)paren
id|add_mtd_partitions
c_func
(paren
id|mtd
comma
id|parts
comma
id|numparts
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|doc2000_init
r_static
r_inline
r_int
id|__init
id|doc2000_init
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
id|this-&gt;write_byte
op_assign
id|doc2000_write_byte
suffix:semicolon
id|this-&gt;read_byte
op_assign
id|doc2000_read_byte
suffix:semicolon
id|this-&gt;write_buf
op_assign
id|doc2000_writebuf
suffix:semicolon
id|this-&gt;read_buf
op_assign
id|doc2000_readbuf
suffix:semicolon
id|this-&gt;verify_buf
op_assign
id|doc2000_verifybuf
suffix:semicolon
id|this-&gt;scan_bbt
op_assign
id|nftl_scan_bbt
suffix:semicolon
id|doc-&gt;CDSNControl
op_assign
id|CDSN_CTRL_FLASH_IO
op_or
id|CDSN_CTRL_ECC_IO
suffix:semicolon
id|doc2000_count_chips
c_func
(paren
id|mtd
)paren
suffix:semicolon
id|mtd-&gt;name
op_assign
l_string|&quot;DiskOnChip 2000 (NFTL Model)&quot;
suffix:semicolon
r_return
(paren
l_int|4
op_star
id|doc-&gt;chips_per_floor
)paren
suffix:semicolon
)brace
DECL|function|doc2001_init
r_static
r_inline
r_int
id|__init
id|doc2001_init
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
id|this-&gt;write_byte
op_assign
id|doc2001_write_byte
suffix:semicolon
id|this-&gt;read_byte
op_assign
id|doc2001_read_byte
suffix:semicolon
id|this-&gt;write_buf
op_assign
id|doc2001_writebuf
suffix:semicolon
id|this-&gt;read_buf
op_assign
id|doc2001_readbuf
suffix:semicolon
id|this-&gt;verify_buf
op_assign
id|doc2001_verifybuf
suffix:semicolon
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|ChipID
)paren
suffix:semicolon
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|ChipID
)paren
suffix:semicolon
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|ChipID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|ChipID
)paren
op_ne
id|DOC_ChipID_DocMil
)paren
(brace
multiline_comment|/* It&squot;s not a Millennium; it&squot;s one of the newer&n;&t;&t;   DiskOnChip 2000 units with a similar ASIC. &n;&t;&t;   Treat it like a Millennium, except that it&n;&t;&t;   can have multiple chips. */
id|doc2000_count_chips
c_func
(paren
id|mtd
)paren
suffix:semicolon
id|mtd-&gt;name
op_assign
l_string|&quot;DiskOnChip 2000 (INFTL Model)&quot;
suffix:semicolon
id|this-&gt;scan_bbt
op_assign
id|inftl_scan_bbt
suffix:semicolon
r_return
(paren
l_int|4
op_star
id|doc-&gt;chips_per_floor
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Bog-standard Millennium */
id|doc-&gt;chips_per_floor
op_assign
l_int|1
suffix:semicolon
id|mtd-&gt;name
op_assign
l_string|&quot;DiskOnChip Millennium&quot;
suffix:semicolon
id|this-&gt;scan_bbt
op_assign
id|nftl_scan_bbt
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|doc_probe
r_static
r_inline
r_int
id|__init
id|doc_probe
c_func
(paren
r_int
r_int
id|physadr
)paren
(brace
r_int
r_char
id|ChipID
suffix:semicolon
r_struct
id|mtd_info
op_star
id|mtd
suffix:semicolon
r_struct
id|nand_chip
op_star
id|nand
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
suffix:semicolon
r_int
r_int
id|virtadr
suffix:semicolon
r_int
r_char
id|save_control
suffix:semicolon
r_int
r_char
id|tmp
comma
id|tmpb
comma
id|tmpc
suffix:semicolon
r_int
id|reg
comma
id|len
comma
id|numchips
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|virtadr
op_assign
(paren
r_int
r_int
)paren
id|ioremap
c_func
(paren
id|physadr
comma
id|DOC_IOREMAP_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|virtadr
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Diskonchip ioremap failed: 0x%x bytes at 0x%lx&bslash;n&quot;
comma
id|DOC_IOREMAP_LEN
comma
id|physadr
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* It&squot;s not possible to cleanly detect the DiskOnChip - the&n;&t; * bootup procedure will put the device into reset mode, and&n;&t; * it&squot;s not possible to talk to it without actually writing&n;&t; * to the DOCControl register. So we store the current contents&n;&t; * of the DOCControl register&squot;s location, in case we later decide&n;&t; * that it&squot;s not a DiskOnChip, and want to put it back how we&n;&t; * found it. &n;&t; */
id|save_control
op_assign
id|ReadDOC
c_func
(paren
id|virtadr
comma
id|DOCControl
)paren
suffix:semicolon
multiline_comment|/* Reset the DiskOnChip ASIC */
id|WriteDOC
c_func
(paren
id|DOC_MODE_CLR_ERR
op_or
id|DOC_MODE_MDWREN
op_or
id|DOC_MODE_RESET
comma
id|virtadr
comma
id|DOCControl
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|DOC_MODE_CLR_ERR
op_or
id|DOC_MODE_MDWREN
op_or
id|DOC_MODE_RESET
comma
id|virtadr
comma
id|DOCControl
)paren
suffix:semicolon
multiline_comment|/* Enable the DiskOnChip ASIC */
id|WriteDOC
c_func
(paren
id|DOC_MODE_CLR_ERR
op_or
id|DOC_MODE_MDWREN
op_or
id|DOC_MODE_NORMAL
comma
id|virtadr
comma
id|DOCControl
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|DOC_MODE_CLR_ERR
op_or
id|DOC_MODE_MDWREN
op_or
id|DOC_MODE_NORMAL
comma
id|virtadr
comma
id|DOCControl
)paren
suffix:semicolon
id|ChipID
op_assign
id|ReadDOC
c_func
(paren
id|virtadr
comma
id|ChipID
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ChipID
)paren
(brace
r_case
id|DOC_ChipID_Doc2k
suffix:colon
id|reg
op_assign
id|DoC_2k_ECCStatus
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DOC_ChipID_DocMil
suffix:colon
id|reg
op_assign
id|DoC_ECCConf
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|notfound
suffix:semicolon
)brace
multiline_comment|/* Check the TOGGLE bit in the ECC register */
id|tmp
op_assign
id|ReadDOC_
c_func
(paren
id|virtadr
comma
id|reg
)paren
op_amp
id|DOC_TOGGLE_BIT
suffix:semicolon
id|tmpb
op_assign
id|ReadDOC_
c_func
(paren
id|virtadr
comma
id|reg
)paren
op_amp
id|DOC_TOGGLE_BIT
suffix:semicolon
id|tmpc
op_assign
id|ReadDOC_
c_func
(paren
id|virtadr
comma
id|reg
)paren
op_amp
id|DOC_TOGGLE_BIT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_eq
id|tmpb
)paren
op_logical_or
(paren
id|tmp
op_ne
id|tmpc
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Possible DiskOnChip at 0x%lx failed TOGGLE test, dropping.&bslash;n&quot;
comma
id|physadr
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|notfound
suffix:semicolon
)brace
r_for
c_loop
(paren
id|mtd
op_assign
id|doclist
suffix:semicolon
id|mtd
suffix:semicolon
id|mtd
op_assign
id|doc-&gt;nextdoc
)paren
(brace
r_int
r_char
id|oldval
suffix:semicolon
r_int
r_char
id|newval
suffix:semicolon
id|nand
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|doc
op_assign
(paren
r_void
op_star
)paren
id|nand-&gt;priv
suffix:semicolon
multiline_comment|/* Use the alias resolution register to determine if this is&n;&t;&t;   in fact the same DOC aliased to a new address.  If writes&n;&t;&t;   to one chip&squot;s alias resolution register change the value on&n;&t;&t;   the other chip, they&squot;re the same chip. */
id|oldval
op_assign
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|AliasResolution
)paren
suffix:semicolon
id|newval
op_assign
id|ReadDOC
c_func
(paren
id|virtadr
comma
id|AliasResolution
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldval
op_ne
id|newval
)paren
r_continue
suffix:semicolon
id|WriteDOC
c_func
(paren
op_complement
id|newval
comma
id|virtadr
comma
id|AliasResolution
)paren
suffix:semicolon
id|oldval
op_assign
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|AliasResolution
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|newval
comma
id|virtadr
comma
id|AliasResolution
)paren
suffix:semicolon
singleline_comment|// restore it
id|newval
op_assign
op_complement
id|newval
suffix:semicolon
r_if
c_cond
(paren
id|oldval
op_eq
id|newval
)paren
(brace
singleline_comment|//printk(KERN_DEBUG &quot;Found alias of DOC at 0x%lx to 0x%lx&bslash;n&quot;, doc-&gt;physadr, physadr);
r_goto
id|notfound
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;DiskOnChip found at 0x%lx&bslash;n&quot;
comma
id|physadr
)paren
suffix:semicolon
id|len
op_assign
r_sizeof
(paren
r_struct
id|mtd_info
)paren
op_plus
r_sizeof
(paren
r_struct
id|nand_chip
)paren
op_plus
r_sizeof
(paren
r_struct
id|doc_priv
)paren
op_plus
(paren
l_int|2
op_star
r_sizeof
(paren
r_struct
id|nand_bbt_descr
)paren
)paren
suffix:semicolon
id|mtd
op_assign
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mtd
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;DiskOnChip kmalloc (%d bytes) failed!&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|memset
c_func
(paren
id|mtd
comma
l_int|0
comma
id|len
)paren
suffix:semicolon
id|nand
op_assign
(paren
r_struct
id|nand_chip
op_star
)paren
(paren
id|mtd
op_plus
l_int|1
)paren
suffix:semicolon
id|doc
op_assign
(paren
r_struct
id|doc_priv
op_star
)paren
(paren
id|nand
op_plus
l_int|1
)paren
suffix:semicolon
id|nand-&gt;bbt_td
op_assign
(paren
r_struct
id|nand_bbt_descr
op_star
)paren
(paren
id|doc
op_plus
l_int|1
)paren
suffix:semicolon
id|nand-&gt;bbt_md
op_assign
id|nand-&gt;bbt_td
op_plus
l_int|1
suffix:semicolon
id|mtd-&gt;priv
op_assign
(paren
r_void
op_star
)paren
id|nand
suffix:semicolon
id|mtd-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|nand-&gt;priv
op_assign
(paren
r_void
op_star
)paren
id|doc
suffix:semicolon
id|nand-&gt;select_chip
op_assign
id|doc200x_select_chip
suffix:semicolon
id|nand-&gt;hwcontrol
op_assign
id|doc200x_hwcontrol
suffix:semicolon
id|nand-&gt;dev_ready
op_assign
id|doc200x_dev_ready
suffix:semicolon
id|nand-&gt;waitfunc
op_assign
id|doc200x_wait
suffix:semicolon
id|nand-&gt;block_bad
op_assign
id|doc200x_block_bad
suffix:semicolon
id|nand-&gt;enable_hwecc
op_assign
id|doc200x_enable_hwecc
suffix:semicolon
id|nand-&gt;calculate_ecc
op_assign
id|doc200x_calculate_ecc
suffix:semicolon
id|nand-&gt;correct_data
op_assign
id|doc200x_correct_data
suffix:semicolon
singleline_comment|//nand-&gt;data_buf
id|nand-&gt;autooob
op_assign
op_amp
id|doc200x_oobinfo
suffix:semicolon
id|nand-&gt;eccmode
op_assign
id|NAND_ECC_HW6_512
suffix:semicolon
id|nand-&gt;options
op_assign
id|NAND_USE_FLASH_BBT
op_or
id|NAND_HWECC_SYNDROME
suffix:semicolon
id|doc-&gt;physadr
op_assign
id|physadr
suffix:semicolon
id|doc-&gt;virtadr
op_assign
id|virtadr
suffix:semicolon
id|doc-&gt;ChipID
op_assign
id|ChipID
suffix:semicolon
id|doc-&gt;curfloor
op_assign
op_minus
l_int|1
suffix:semicolon
id|doc-&gt;curchip
op_assign
op_minus
l_int|1
suffix:semicolon
id|doc-&gt;mh0_page
op_assign
op_minus
l_int|1
suffix:semicolon
id|doc-&gt;mh1_page
op_assign
op_minus
l_int|1
suffix:semicolon
id|doc-&gt;nextdoc
op_assign
id|doclist
suffix:semicolon
r_if
c_cond
(paren
id|ChipID
op_eq
id|DOC_ChipID_Doc2k
)paren
id|numchips
op_assign
id|doc2000_init
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_else
id|numchips
op_assign
id|doc2001_init
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|nand_scan
c_func
(paren
id|mtd
comma
id|numchips
)paren
)paren
)paren
(brace
multiline_comment|/* DBB note: i believe nand_release is necessary here, as&n;&t;&t;   buffers may have been allocated in nand_base.  Check with&n;&t;&t;   Thomas. FIX ME! */
multiline_comment|/* nand_release will call del_mtd_device, but we haven&squot;t yet&n;&t;&t;   added it.  This is handled without incident by&n;&t;&t;   del_mtd_device, as far as I can tell. */
id|nand_release
c_func
(paren
id|mtd
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
multiline_comment|/* Success! */
id|doclist
op_assign
id|mtd
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|notfound
suffix:colon
multiline_comment|/* Put back the contents of the DOCControl register, in case it&squot;s not&n;&t;   actually a DiskOnChip.  */
id|WriteDOC
c_func
(paren
id|save_control
comma
id|virtadr
comma
id|DOCControl
)paren
suffix:semicolon
id|fail
suffix:colon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|virtadr
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|init_nanddoc
r_int
id|__init
id|init_nanddoc
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|doc_config_location
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Using configured DiskOnChip probe address 0x%lx&bslash;n&quot;
comma
id|doc_config_location
)paren
suffix:semicolon
r_return
id|doc_probe
c_func
(paren
id|doc_config_location
)paren
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|doc_locations
(braket
id|i
)braket
op_ne
l_int|0xffffffff
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|doc_probe
c_func
(paren
id|doc_locations
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* No banner message any more. Print a message if no DiskOnChip&n;&t;   found, so the user knows we at least tried. */
r_if
c_cond
(paren
op_logical_neg
id|doclist
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;No valid DiskOnChip devices found&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_nanddoc
r_void
id|__exit
id|cleanup_nanddoc
c_func
(paren
r_void
)paren
(brace
r_struct
id|mtd_info
op_star
id|mtd
comma
op_star
id|nextmtd
suffix:semicolon
r_struct
id|nand_chip
op_star
id|nand
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
suffix:semicolon
r_for
c_loop
(paren
id|mtd
op_assign
id|doclist
suffix:semicolon
id|mtd
suffix:semicolon
id|mtd
op_assign
id|nextmtd
)paren
(brace
id|nand
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|doc
op_assign
(paren
r_void
op_star
)paren
id|nand-&gt;priv
suffix:semicolon
id|nextmtd
op_assign
id|doc-&gt;nextdoc
suffix:semicolon
id|nand_release
c_func
(paren
id|mtd
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|doc-&gt;virtadr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mtd
)paren
suffix:semicolon
)brace
)brace
DECL|variable|init_nanddoc
id|module_init
c_func
(paren
id|init_nanddoc
)paren
suffix:semicolon
DECL|variable|cleanup_nanddoc
id|module_exit
c_func
(paren
id|cleanup_nanddoc
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;David Woodhouse &lt;dwmw2@infradead.org&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;M-Systems DiskOnChip 2000 and Millennium device driver&bslash;n&quot;
)paren
suffix:semicolon
eof
