multiline_comment|/* &n; * drivers/mtd/nand/diskonchip.c&n; *&n; * (C) 2003 Red Hat, Inc.&n; * (C) 2004 Dan Brown &lt;dan_brown@ieee.org&gt;&n; * (C) 2004 Kalev Lember &lt;kalev@smartlink.ee&gt;&n; *&n; * Author: David Woodhouse &lt;dwmw2@infradead.org&gt;&n; * Additional Diskonchip 2000 and Millennium support by Dan Brown &lt;dan_brown@ieee.org&gt;&n; * Diskonchip Millennium Plus support by Kalev Lember &lt;kalev@smartlink.ee&gt;&n; * &n; * Error correction code lifted from the old docecc code&n; * Author: Fabrice Bellard (fabrice.bellard@netgem.com) &n; * Copyright (C) 2000 Netgem S.A.&n; * converted to the generic Reed-Solomon library by Thomas Gleixner &lt;tglx@linutronix.de&gt;&n; *  &n; * Interface to generic NAND code for M-Systems DiskOnChip devices&n; *&n; * $Id: diskonchip.c,v 1.42 2004/11/16 18:29:03 dwmw2 Exp $&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/rslib.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/mtd/nand.h&gt;
macro_line|#include &lt;linux/mtd/doc2000.h&gt;
macro_line|#include &lt;linux/mtd/compatmac.h&gt;
macro_line|#include &lt;linux/mtd/partitions.h&gt;
macro_line|#include &lt;linux/mtd/inftl.h&gt;
multiline_comment|/* Where to look for the devices? */
macro_line|#ifndef CONFIG_MTD_DISKONCHIP_PROBE_ADDRESS
DECL|macro|CONFIG_MTD_DISKONCHIP_PROBE_ADDRESS
mdefine_line|#define CONFIG_MTD_DISKONCHIP_PROBE_ADDRESS 0
macro_line|#endif
DECL|variable|doc_locations
r_static
r_int
r_int
id|__initdata
id|doc_locations
(braket
)braket
op_assign
(brace
macro_line|#if defined (__alpha__) || defined(__i386__) || defined(__x86_64__)
macro_line|#ifdef CONFIG_MTD_DISKONCHIP_PROBE_HIGH
l_int|0xfffc8000
comma
l_int|0xfffca000
comma
l_int|0xfffcc000
comma
l_int|0xfffce000
comma
l_int|0xfffd0000
comma
l_int|0xfffd2000
comma
l_int|0xfffd4000
comma
l_int|0xfffd6000
comma
l_int|0xfffd8000
comma
l_int|0xfffda000
comma
l_int|0xfffdc000
comma
l_int|0xfffde000
comma
l_int|0xfffe0000
comma
l_int|0xfffe2000
comma
l_int|0xfffe4000
comma
l_int|0xfffe6000
comma
l_int|0xfffe8000
comma
l_int|0xfffea000
comma
l_int|0xfffec000
comma
l_int|0xfffee000
comma
macro_line|#else /*  CONFIG_MTD_DOCPROBE_HIGH */
l_int|0xc8000
comma
l_int|0xca000
comma
l_int|0xcc000
comma
l_int|0xce000
comma
l_int|0xd0000
comma
l_int|0xd2000
comma
l_int|0xd4000
comma
l_int|0xd6000
comma
l_int|0xd8000
comma
l_int|0xda000
comma
l_int|0xdc000
comma
l_int|0xde000
comma
l_int|0xe0000
comma
l_int|0xe2000
comma
l_int|0xe4000
comma
l_int|0xe6000
comma
l_int|0xe8000
comma
l_int|0xea000
comma
l_int|0xec000
comma
l_int|0xee000
comma
macro_line|#endif /*  CONFIG_MTD_DOCPROBE_HIGH */
macro_line|#elif defined(__PPC__)
l_int|0xe4000000
comma
macro_line|#elif defined(CONFIG_MOMENCO_OCELOT)
l_int|0x2f000000
comma
l_int|0xff000000
comma
macro_line|#elif defined(CONFIG_MOMENCO_OCELOT_G) || defined (CONFIG_MOMENCO_OCELOT_C)
l_int|0xff000000
comma
macro_line|##else
macro_line|#warning Unknown architecture for DiskOnChip. No default probe locations defined
macro_line|#endif
l_int|0xffffffff
)brace
suffix:semicolon
DECL|variable|doclist
r_static
r_struct
id|mtd_info
op_star
id|doclist
op_assign
l_int|NULL
suffix:semicolon
DECL|struct|doc_priv
r_struct
id|doc_priv
(brace
DECL|member|virtadr
r_void
id|__iomem
op_star
id|virtadr
suffix:semicolon
DECL|member|physadr
r_int
r_int
id|physadr
suffix:semicolon
DECL|member|ChipID
id|u_char
id|ChipID
suffix:semicolon
DECL|member|CDSNControl
id|u_char
id|CDSNControl
suffix:semicolon
DECL|member|chips_per_floor
r_int
id|chips_per_floor
suffix:semicolon
multiline_comment|/* The number of chips detected on each floor */
DECL|member|curfloor
r_int
id|curfloor
suffix:semicolon
DECL|member|curchip
r_int
id|curchip
suffix:semicolon
DECL|member|mh0_page
r_int
id|mh0_page
suffix:semicolon
DECL|member|mh1_page
r_int
id|mh1_page
suffix:semicolon
DECL|member|nextdoc
r_struct
id|mtd_info
op_star
id|nextdoc
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Max number of eraseblocks to scan (from start of device) for the (I)NFTL&n;   MediaHeader.  The spec says to just keep going, I think, but that&squot;s just&n;   silly. */
DECL|macro|MAX_MEDIAHEADER_SCAN
mdefine_line|#define MAX_MEDIAHEADER_SCAN 8
multiline_comment|/* This is the syndrome computed by the HW ecc generator upon reading an empty&n;   page, one with all 0xff for data and stored ecc code. */
DECL|variable|empty_read_syndrome
r_static
id|u_char
id|empty_read_syndrome
(braket
l_int|6
)braket
op_assign
(brace
l_int|0x26
comma
l_int|0xff
comma
l_int|0x6d
comma
l_int|0x47
comma
l_int|0x73
comma
l_int|0x7a
)brace
suffix:semicolon
multiline_comment|/* This is the ecc value computed by the HW ecc generator upon writing an empty&n;   page, one with all 0xff for data. */
DECL|variable|empty_write_ecc
r_static
id|u_char
id|empty_write_ecc
(braket
l_int|6
)braket
op_assign
(brace
l_int|0x4b
comma
l_int|0x00
comma
l_int|0xe2
comma
l_int|0x0e
comma
l_int|0x93
comma
l_int|0xf7
)brace
suffix:semicolon
DECL|macro|INFTL_BBT_RESERVED_BLOCKS
mdefine_line|#define INFTL_BBT_RESERVED_BLOCKS 4
DECL|macro|DoC_is_MillenniumPlus
mdefine_line|#define DoC_is_MillenniumPlus(doc) ((doc)-&gt;ChipID == DOC_ChipID_DocMilPlus16 || (doc)-&gt;ChipID == DOC_ChipID_DocMilPlus32)
DECL|macro|DoC_is_Millennium
mdefine_line|#define DoC_is_Millennium(doc) ((doc)-&gt;ChipID == DOC_ChipID_DocMil)
DECL|macro|DoC_is_2000
mdefine_line|#define DoC_is_2000(doc) ((doc)-&gt;ChipID == DOC_ChipID_Doc2k)
r_static
r_void
id|doc200x_hwcontrol
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|doc200x_select_chip
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|chip
)paren
suffix:semicolon
DECL|variable|debug
r_static
r_int
id|debug
op_assign
l_int|0
suffix:semicolon
id|module_param
c_func
(paren
id|debug
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
DECL|variable|try_dword
r_static
r_int
id|try_dword
op_assign
l_int|1
suffix:semicolon
id|module_param
c_func
(paren
id|try_dword
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
DECL|variable|no_ecc_failures
r_static
r_int
id|no_ecc_failures
op_assign
l_int|0
suffix:semicolon
id|module_param
c_func
(paren
id|no_ecc_failures
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MTD_PARTITIONS
DECL|variable|no_autopart
r_static
r_int
id|no_autopart
op_assign
l_int|0
suffix:semicolon
id|module_param
c_func
(paren
id|no_autopart
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MTD_NAND_DISKONCHIP_BBTWRITE
DECL|variable|inftl_bbt_write
r_static
r_int
id|inftl_bbt_write
op_assign
l_int|1
suffix:semicolon
macro_line|#else
DECL|variable|inftl_bbt_write
r_static
r_int
id|inftl_bbt_write
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|module_param
c_func
(paren
id|inftl_bbt_write
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
DECL|variable|doc_config_location
r_static
r_int
r_int
id|doc_config_location
op_assign
id|CONFIG_MTD_DISKONCHIP_PROBE_ADDRESS
suffix:semicolon
id|module_param
c_func
(paren
id|doc_config_location
comma
id|ulong
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|doc_config_location
comma
l_string|&quot;Physical memory address at which to probe for DiskOnChip&quot;
)paren
suffix:semicolon
multiline_comment|/* Sector size for HW ECC */
DECL|macro|SECTOR_SIZE
mdefine_line|#define SECTOR_SIZE 512
multiline_comment|/* The sector bytes are packed into NB_DATA 10 bit words */
DECL|macro|NB_DATA
mdefine_line|#define NB_DATA (((SECTOR_SIZE + 1) * 8 + 6) / 10)
multiline_comment|/* Number of roots */
DECL|macro|NROOTS
mdefine_line|#define NROOTS 4
multiline_comment|/* First consective root */
DECL|macro|FCR
mdefine_line|#define FCR 510
multiline_comment|/* Number of symbols */
DECL|macro|NN
mdefine_line|#define NN 1023
multiline_comment|/* the Reed Solomon control structure */
DECL|variable|rs_decoder
r_static
r_struct
id|rs_control
op_star
id|rs_decoder
suffix:semicolon
multiline_comment|/* &n; * The HW decoder in the DoC ASIC&squot;s provides us a error syndrome,&n; * which we must convert to a standard syndrom usable by the generic&n; * Reed-Solomon library code.&n; *&n; * Fabrice Bellard figured this out in the old docecc code. I added&n; * some comments, improved a minor bit and converted it to make use&n; * of the generic Reed-Solomon libary. tglx&n; */
DECL|function|doc_ecc_decode
r_static
r_int
id|doc_ecc_decode
(paren
r_struct
id|rs_control
op_star
id|rs
comma
r_uint8
op_star
id|data
comma
r_uint8
op_star
id|ecc
)paren
(brace
r_int
id|i
comma
id|j
comma
id|nerr
comma
id|errpos
(braket
l_int|8
)braket
suffix:semicolon
r_uint8
id|parity
suffix:semicolon
r_uint16
id|ds
(braket
l_int|4
)braket
comma
id|s
(braket
l_int|5
)braket
comma
id|tmp
comma
id|errval
(braket
l_int|8
)braket
comma
id|syn
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Convert the ecc bytes into words */
id|ds
(braket
l_int|0
)braket
op_assign
(paren
(paren
id|ecc
(braket
l_int|4
)braket
op_amp
l_int|0xff
)paren
op_rshift
l_int|0
)paren
op_or
(paren
(paren
id|ecc
(braket
l_int|5
)braket
op_amp
l_int|0x03
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|ds
(braket
l_int|1
)braket
op_assign
(paren
(paren
id|ecc
(braket
l_int|5
)braket
op_amp
l_int|0xfc
)paren
op_rshift
l_int|2
)paren
op_or
(paren
(paren
id|ecc
(braket
l_int|2
)braket
op_amp
l_int|0x0f
)paren
op_lshift
l_int|6
)paren
suffix:semicolon
id|ds
(braket
l_int|2
)braket
op_assign
(paren
(paren
id|ecc
(braket
l_int|2
)braket
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
)paren
op_or
(paren
(paren
id|ecc
(braket
l_int|3
)braket
op_amp
l_int|0x3f
)paren
op_lshift
l_int|4
)paren
suffix:semicolon
id|ds
(braket
l_int|3
)braket
op_assign
(paren
(paren
id|ecc
(braket
l_int|3
)braket
op_amp
l_int|0xc0
)paren
op_rshift
l_int|6
)paren
op_or
(paren
(paren
id|ecc
(braket
l_int|0
)braket
op_amp
l_int|0xff
)paren
op_lshift
l_int|2
)paren
suffix:semicolon
id|parity
op_assign
id|ecc
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Initialize the syndrom buffer */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NROOTS
suffix:semicolon
id|i
op_increment
)paren
id|s
(braket
id|i
)braket
op_assign
id|ds
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* &n;&t; *  Evaluate &n;&t; *  s[i] = ds[3]x^3 + ds[2]x^2 + ds[1]x^1 + ds[0]&n;&t; *  where x = alpha^(FCR + i)&n;&t; */
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
OL
id|NROOTS
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ds
(braket
id|j
)braket
op_eq
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
id|tmp
op_assign
id|rs-&gt;index_of
(braket
id|ds
(braket
id|j
)braket
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NROOTS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|s
(braket
id|i
)braket
op_xor_assign
id|rs-&gt;alpha_to
(braket
id|rs_modnn
c_func
(paren
id|rs
comma
id|tmp
op_plus
(paren
id|FCR
op_plus
id|i
)paren
op_star
id|j
)paren
)braket
suffix:semicolon
)brace
)brace
multiline_comment|/* Calc s[i] = s[i] / alpha^(v + i) */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NROOTS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|syn
(braket
id|i
)braket
)paren
id|syn
(braket
id|i
)braket
op_assign
id|rs_modnn
c_func
(paren
id|rs
comma
id|rs-&gt;index_of
(braket
id|s
(braket
id|i
)braket
)braket
op_plus
(paren
id|NN
op_minus
id|FCR
op_minus
id|i
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Call the decoder library */
id|nerr
op_assign
id|decode_rs16
c_func
(paren
id|rs
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|1019
comma
id|syn
comma
l_int|0
comma
id|errpos
comma
l_int|0
comma
id|errval
)paren
suffix:semicolon
multiline_comment|/* Incorrectable errors ? */
r_if
c_cond
(paren
id|nerr
OL
l_int|0
)paren
r_return
id|nerr
suffix:semicolon
multiline_comment|/* &n;&t; * Correct the errors. The bitpositions are a bit of magic,&n;&t; * but they are given by the design of the de/encoder circuit&n;&t; * in the DoC ASIC&squot;s.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nerr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|index
comma
id|bitpos
comma
id|pos
op_assign
l_int|1015
op_minus
id|errpos
(braket
id|i
)braket
suffix:semicolon
r_uint8
id|val
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
id|NB_DATA
op_logical_and
id|pos
OL
l_int|1019
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|NB_DATA
)paren
(brace
multiline_comment|/* extract bit position (MSB first) */
id|pos
op_assign
l_int|10
op_star
(paren
id|NB_DATA
op_minus
l_int|1
op_minus
id|pos
)paren
op_minus
l_int|6
suffix:semicolon
multiline_comment|/* now correct the following 10 bits. At most two bytes&n;&t;&t;&t;   can be modified since pos is even */
id|index
op_assign
(paren
id|pos
op_rshift
l_int|3
)paren
op_xor
l_int|1
suffix:semicolon
id|bitpos
op_assign
id|pos
op_amp
l_int|7
suffix:semicolon
r_if
c_cond
(paren
(paren
id|index
op_ge
l_int|0
op_logical_and
id|index
OL
id|SECTOR_SIZE
)paren
op_logical_or
id|index
op_eq
(paren
id|SECTOR_SIZE
op_plus
l_int|1
)paren
)paren
(brace
id|val
op_assign
(paren
r_uint8
)paren
(paren
id|errval
(braket
id|i
)braket
op_rshift
(paren
l_int|2
op_plus
id|bitpos
)paren
)paren
suffix:semicolon
id|parity
op_xor_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
id|index
OL
id|SECTOR_SIZE
)paren
id|data
(braket
id|index
)braket
op_xor_assign
id|val
suffix:semicolon
)brace
id|index
op_assign
(paren
(paren
id|pos
op_rshift
l_int|3
)paren
op_plus
l_int|1
)paren
op_xor
l_int|1
suffix:semicolon
id|bitpos
op_assign
(paren
id|bitpos
op_plus
l_int|10
)paren
op_amp
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|bitpos
op_eq
l_int|0
)paren
id|bitpos
op_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
(paren
id|index
op_ge
l_int|0
op_logical_and
id|index
OL
id|SECTOR_SIZE
)paren
op_logical_or
id|index
op_eq
(paren
id|SECTOR_SIZE
op_plus
l_int|1
)paren
)paren
(brace
id|val
op_assign
(paren
r_uint8
)paren
(paren
id|errval
(braket
id|i
)braket
op_lshift
(paren
l_int|8
op_minus
id|bitpos
)paren
)paren
suffix:semicolon
id|parity
op_xor_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
id|index
OL
id|SECTOR_SIZE
)paren
id|data
(braket
id|index
)braket
op_xor_assign
id|val
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* If the parity is wrong, no rescue possible */
r_return
id|parity
ques
c_cond
op_minus
l_int|1
suffix:colon
id|nerr
suffix:semicolon
)brace
DECL|function|DoC_Delay
r_static
r_void
id|DoC_Delay
c_func
(paren
r_struct
id|doc_priv
op_star
id|doc
comma
r_int
r_int
id|cycles
)paren
(brace
r_volatile
r_char
id|dummy
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cycles
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|DoC_is_Millennium
c_func
(paren
id|doc
)paren
)paren
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|NOP
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|DoC_is_MillenniumPlus
c_func
(paren
id|doc
)paren
)paren
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|Mplus_NOP
)paren
suffix:semicolon
r_else
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|DOCStatus
)paren
suffix:semicolon
)brace
)brace
DECL|macro|CDSN_CTRL_FR_B_MASK
mdefine_line|#define CDSN_CTRL_FR_B_MASK&t;(CDSN_CTRL_FR_B0 | CDSN_CTRL_FR_B1)
multiline_comment|/* DOC_WaitReady: Wait for RDY line to be asserted by the flash chip */
DECL|function|_DoC_WaitReady
r_static
r_int
id|_DoC_WaitReady
c_func
(paren
r_struct
id|doc_priv
op_star
id|doc
)paren
(brace
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
r_int
id|timeo
op_assign
id|jiffies
op_plus
(paren
id|HZ
op_star
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;_DoC_WaitReady...&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Out-of-line routine to wait for chip response */
r_if
c_cond
(paren
id|DoC_is_MillenniumPlus
c_func
(paren
id|doc
)paren
)paren
(brace
r_while
c_loop
(paren
(paren
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mplus_FlashControl
)paren
op_amp
id|CDSN_CTRL_FR_B_MASK
)paren
op_ne
id|CDSN_CTRL_FR_B_MASK
)paren
(brace
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|timeo
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;_DoC_WaitReady timed out.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNControl
)paren
op_amp
id|CDSN_CTRL_FR_B
)paren
)paren
(brace
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|timeo
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;_DoC_WaitReady timed out.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|DoC_WaitReady
r_static
r_inline
r_int
id|DoC_WaitReady
c_func
(paren
r_struct
id|doc_priv
op_star
id|doc
)paren
(brace
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|DoC_is_MillenniumPlus
c_func
(paren
id|doc
)paren
)paren
(brace
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mplus_FlashControl
)paren
op_amp
id|CDSN_CTRL_FR_B_MASK
)paren
op_ne
id|CDSN_CTRL_FR_B_MASK
)paren
multiline_comment|/* Call the out-of-line routine to wait */
id|ret
op_assign
id|_DoC_WaitReady
c_func
(paren
id|doc
)paren
suffix:semicolon
)brace
r_else
(brace
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNControl
)paren
op_amp
id|CDSN_CTRL_FR_B
)paren
)paren
multiline_comment|/* Call the out-of-line routine to wait */
id|ret
op_assign
id|_DoC_WaitReady
c_func
(paren
id|doc
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DoC_WaitReady OK&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|doc2000_write_byte
r_static
r_void
id|doc2000_write_byte
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u_char
id|datum
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;write_byte %02x&bslash;n&quot;
comma
id|datum
)paren
suffix:semicolon
)brace
id|WriteDOC
c_func
(paren
id|datum
comma
id|docptr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|datum
comma
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
suffix:semicolon
)brace
DECL|function|doc2000_read_byte
r_static
id|u_char
id|doc2000_read_byte
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
id|u_char
id|ret
suffix:semicolon
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|2
)paren
suffix:semicolon
id|ret
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|printk
c_func
(paren
l_string|&quot;read_byte returns %02x&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|doc2000_writebuf
r_static
r_void
id|doc2000_writebuf
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|printk
c_func
(paren
l_string|&quot;writebuf of %d bytes: &quot;
comma
id|len
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|WriteDOC_
c_func
(paren
id|buf
(braket
id|i
)braket
comma
id|docptr
comma
id|DoC_2k_CDSN_IO
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_logical_and
id|i
OL
l_int|16
)paren
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|buf
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|doc2000_readbuf
r_static
r_void
id|doc2000_readbuf
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|printk
c_func
(paren
l_string|&quot;readbuf of %d bytes: &quot;
comma
id|len
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|buf
(braket
id|i
)braket
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_CDSN_IO
op_plus
id|i
)paren
suffix:semicolon
)brace
)brace
DECL|function|doc2000_readbuf_dword
r_static
r_void
id|doc2000_readbuf_dword
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|printk
c_func
(paren
l_string|&quot;readbuf_dword of %d bytes: &quot;
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
(paren
(paren
r_int
r_int
)paren
id|buf
)paren
op_or
id|len
)paren
op_amp
l_int|3
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
(paren
r_uint8
op_star
)paren
(paren
op_amp
id|buf
(braket
id|i
)braket
)paren
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_CDSN_IO
op_plus
id|i
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_add_assign
l_int|4
)paren
(brace
op_star
(paren
r_uint32
op_star
)paren
(paren
op_amp
id|buf
(braket
id|i
)braket
)paren
op_assign
id|readl
c_func
(paren
id|docptr
op_plus
id|DoC_2k_CDSN_IO
op_plus
id|i
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|doc2000_verifybuf
r_static
r_int
id|doc2000_verifybuf
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_ne
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|doc200x_ident_chip
r_static
r_uint16
id|__init
id|doc200x_ident_chip
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|nr
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_uint16
id|ret
suffix:semicolon
id|doc200x_select_chip
c_func
(paren
id|mtd
comma
id|nr
)paren
suffix:semicolon
id|doc200x_hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_SETCLE
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|write_byte
c_func
(paren
id|mtd
comma
id|NAND_CMD_READID
)paren
suffix:semicolon
id|doc200x_hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_CLRCLE
)paren
suffix:semicolon
id|doc200x_hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_SETALE
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|write_byte
c_func
(paren
id|mtd
comma
l_int|0
)paren
suffix:semicolon
id|doc200x_hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_CLRALE
)paren
suffix:semicolon
id|ret
op_assign
id|this
op_member_access_from_pointer
id|read_byte
c_func
(paren
id|mtd
)paren
op_lshift
l_int|8
suffix:semicolon
id|ret
op_or_assign
id|this
op_member_access_from_pointer
id|read_byte
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|doc-&gt;ChipID
op_eq
id|DOC_ChipID_Doc2k
op_logical_and
id|try_dword
op_logical_and
op_logical_neg
id|nr
)paren
(brace
multiline_comment|/* First chip probe. See if we get same results by 32-bit access */
r_union
(brace
r_uint32
id|dword
suffix:semicolon
r_uint8
id|byte
(braket
l_int|4
)braket
suffix:semicolon
)brace
id|ident
suffix:semicolon
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
id|doc200x_hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_SETCLE
)paren
suffix:semicolon
id|doc2000_write_byte
c_func
(paren
id|mtd
comma
id|NAND_CMD_READID
)paren
suffix:semicolon
id|doc200x_hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_CLRCLE
)paren
suffix:semicolon
id|doc200x_hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_SETALE
)paren
suffix:semicolon
id|doc2000_write_byte
c_func
(paren
id|mtd
comma
l_int|0
)paren
suffix:semicolon
id|doc200x_hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_CLRALE
)paren
suffix:semicolon
id|ident.dword
op_assign
id|readl
c_func
(paren
id|docptr
op_plus
id|DoC_2k_CDSN_IO
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|ident.byte
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
op_or
id|ident.byte
(braket
l_int|1
)braket
)paren
op_eq
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;DiskOnChip 2000 responds to DWORD access&bslash;n&quot;
)paren
suffix:semicolon
id|this-&gt;read_buf
op_assign
op_amp
id|doc2000_readbuf_dword
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|doc2000_count_chips
r_static
r_void
id|__init
id|doc2000_count_chips
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_uint16
id|mfrid
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Max 4 chips per floor on DiskOnChip 2000 */
id|doc-&gt;chips_per_floor
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* Find out what the first chip is */
id|mfrid
op_assign
id|doc200x_ident_chip
c_func
(paren
id|mtd
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Find how many chips in each floor. */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|doc200x_ident_chip
c_func
(paren
id|mtd
comma
id|i
)paren
op_ne
id|mfrid
)paren
r_break
suffix:semicolon
)brace
id|doc-&gt;chips_per_floor
op_assign
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Detected %d chips per floor.&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
DECL|function|doc200x_wait
r_static
r_int
id|doc200x_wait
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|nand_chip
op_star
id|this
comma
r_int
id|state
)paren
(brace
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_int
id|status
suffix:semicolon
id|DoC_WaitReady
c_func
(paren
id|doc
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|cmdfunc
c_func
(paren
id|mtd
comma
id|NAND_CMD_STATUS
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|DoC_WaitReady
c_func
(paren
id|doc
)paren
suffix:semicolon
id|status
op_assign
(paren
r_int
)paren
id|this
op_member_access_from_pointer
id|read_byte
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
DECL|function|doc2001_write_byte
r_static
r_void
id|doc2001_write_byte
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u_char
id|datum
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
id|WriteDOC
c_func
(paren
id|datum
comma
id|docptr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|datum
comma
id|docptr
comma
id|Mil_CDSN_IO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|datum
comma
id|docptr
comma
id|WritePipeTerm
)paren
suffix:semicolon
)brace
DECL|function|doc2001_read_byte
r_static
id|u_char
id|doc2001_read_byte
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
singleline_comment|//ReadDOC(docptr, CDSNSlowIO);
multiline_comment|/* 11.4.5 -- delay twice to allow extended length cycle */
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|2
)paren
suffix:semicolon
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ReadPipeInit
)paren
suffix:semicolon
singleline_comment|//return ReadDOC(docptr, Mil_CDSN_IO);
r_return
id|ReadDOC
c_func
(paren
id|docptr
comma
id|LastDataRead
)paren
suffix:semicolon
)brace
DECL|function|doc2001_writebuf
r_static
r_void
id|doc2001_writebuf
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
id|WriteDOC_
c_func
(paren
id|buf
(braket
id|i
)braket
comma
id|docptr
comma
id|DoC_Mil_CDSN_IO
op_plus
id|i
)paren
suffix:semicolon
multiline_comment|/* Terminate write pipeline */
id|WriteDOC
c_func
(paren
l_int|0x00
comma
id|docptr
comma
id|WritePipeTerm
)paren
suffix:semicolon
)brace
DECL|function|doc2001_readbuf
r_static
r_void
id|doc2001_readbuf
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Start read pipeline */
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ReadPipeInit
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
id|buf
(braket
id|i
)braket
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mil_CDSN_IO
op_plus
(paren
id|i
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
multiline_comment|/* Terminate read pipeline */
id|buf
(braket
id|i
)braket
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|LastDataRead
)paren
suffix:semicolon
)brace
DECL|function|doc2001_verifybuf
r_static
r_int
id|doc2001_verifybuf
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Start read pipeline */
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ReadPipeInit
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_ne
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mil_CDSN_IO
)paren
)paren
(brace
id|ReadDOC
c_func
(paren
id|docptr
comma
id|LastDataRead
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_ne
id|ReadDOC
c_func
(paren
id|docptr
comma
id|LastDataRead
)paren
)paren
r_return
id|i
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|doc2001plus_read_byte
r_static
id|u_char
id|doc2001plus_read_byte
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
id|u_char
id|ret
suffix:semicolon
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mplus_ReadPipeInit
)paren
suffix:semicolon
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mplus_ReadPipeInit
)paren
suffix:semicolon
id|ret
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mplus_LastDataRead
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|printk
c_func
(paren
l_string|&quot;read_byte returns %02x&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|doc2001plus_writebuf
r_static
r_void
id|doc2001plus_writebuf
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|printk
c_func
(paren
l_string|&quot;writebuf of %d bytes: &quot;
comma
id|len
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|WriteDOC_
c_func
(paren
id|buf
(braket
id|i
)braket
comma
id|docptr
comma
id|DoC_Mil_CDSN_IO
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_logical_and
id|i
OL
l_int|16
)paren
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|buf
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|doc2001plus_readbuf
r_static
r_void
id|doc2001plus_readbuf
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|printk
c_func
(paren
l_string|&quot;readbuf of %d bytes: &quot;
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Start read pipeline */
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mplus_ReadPipeInit
)paren
suffix:semicolon
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mplus_ReadPipeInit
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
op_minus
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|buf
(braket
id|i
)braket
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mil_CDSN_IO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_logical_and
id|i
OL
l_int|16
)paren
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|buf
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Terminate read pipeline */
id|buf
(braket
id|len
op_minus
l_int|2
)braket
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mplus_LastDataRead
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_logical_and
id|i
OL
l_int|16
)paren
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|buf
(braket
id|len
op_minus
l_int|2
)braket
)paren
suffix:semicolon
id|buf
(braket
id|len
op_minus
l_int|1
)braket
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mplus_LastDataRead
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_logical_and
id|i
OL
l_int|16
)paren
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|buf
(braket
id|len
op_minus
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|doc2001plus_verifybuf
r_static
r_int
id|doc2001plus_verifybuf
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|printk
c_func
(paren
l_string|&quot;verifybuf of %d bytes: &quot;
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Start read pipeline */
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mplus_ReadPipeInit
)paren
suffix:semicolon
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mplus_ReadPipeInit
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
op_minus
l_int|2
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_ne
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mil_CDSN_IO
)paren
)paren
(brace
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mplus_LastDataRead
)paren
suffix:semicolon
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mplus_LastDataRead
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf
(braket
id|len
op_minus
l_int|2
)braket
op_ne
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mplus_LastDataRead
)paren
)paren
r_return
id|len
op_minus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|buf
(braket
id|len
op_minus
l_int|1
)braket
op_ne
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mplus_LastDataRead
)paren
)paren
r_return
id|len
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|doc2001plus_select_chip
r_static
r_void
id|doc2001plus_select_chip
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|chip
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
id|floor
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;select chip (%d)&bslash;n&quot;
comma
id|chip
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chip
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Disable flash internally */
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
id|Mplus_FlashSelect
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|floor
op_assign
id|chip
op_div
id|doc-&gt;chips_per_floor
suffix:semicolon
id|chip
op_sub_assign
(paren
id|floor
op_star
id|doc-&gt;chips_per_floor
)paren
suffix:semicolon
multiline_comment|/* Assert ChipEnable and deassert WriteProtect */
id|WriteDOC
c_func
(paren
(paren
id|DOC_FLASH_CE
)paren
comma
id|docptr
comma
id|Mplus_FlashSelect
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|cmdfunc
c_func
(paren
id|mtd
comma
id|NAND_CMD_RESET
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|doc-&gt;curchip
op_assign
id|chip
suffix:semicolon
id|doc-&gt;curfloor
op_assign
id|floor
suffix:semicolon
)brace
DECL|function|doc200x_select_chip
r_static
r_void
id|doc200x_select_chip
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|chip
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
id|floor
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;select chip (%d)&bslash;n&quot;
comma
id|chip
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chip
op_eq
op_minus
l_int|1
)paren
r_return
suffix:semicolon
id|floor
op_assign
id|chip
op_div
id|doc-&gt;chips_per_floor
suffix:semicolon
id|chip
op_sub_assign
(paren
id|floor
op_star
id|doc-&gt;chips_per_floor
)paren
suffix:semicolon
multiline_comment|/* 11.4.4 -- deassert CE before changing chip */
id|doc200x_hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_CLRNCE
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|floor
comma
id|docptr
comma
id|FloorSelect
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|chip
comma
id|docptr
comma
id|CDSNDeviceSelect
)paren
suffix:semicolon
id|doc200x_hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_SETNCE
)paren
suffix:semicolon
id|doc-&gt;curchip
op_assign
id|chip
suffix:semicolon
id|doc-&gt;curfloor
op_assign
id|floor
suffix:semicolon
)brace
DECL|function|doc200x_hwcontrol
r_static
r_void
id|doc200x_hwcontrol
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|cmd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|NAND_CTL_SETNCE
suffix:colon
id|doc-&gt;CDSNControl
op_or_assign
id|CDSN_CTRL_CE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_CTL_CLRNCE
suffix:colon
id|doc-&gt;CDSNControl
op_and_assign
op_complement
id|CDSN_CTRL_CE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_CTL_SETCLE
suffix:colon
id|doc-&gt;CDSNControl
op_or_assign
id|CDSN_CTRL_CLE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_CTL_CLRCLE
suffix:colon
id|doc-&gt;CDSNControl
op_and_assign
op_complement
id|CDSN_CTRL_CLE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_CTL_SETALE
suffix:colon
id|doc-&gt;CDSNControl
op_or_assign
id|CDSN_CTRL_ALE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_CTL_CLRALE
suffix:colon
id|doc-&gt;CDSNControl
op_and_assign
op_complement
id|CDSN_CTRL_ALE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_CTL_SETWP
suffix:colon
id|doc-&gt;CDSNControl
op_or_assign
id|CDSN_CTRL_WP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_CTL_CLRWP
suffix:colon
id|doc-&gt;CDSNControl
op_and_assign
op_complement
id|CDSN_CTRL_WP
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug
)paren
id|printk
c_func
(paren
l_string|&quot;hwcontrol(%d): %02x&bslash;n&quot;
comma
id|cmd
comma
id|doc-&gt;CDSNControl
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|doc-&gt;CDSNControl
comma
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
multiline_comment|/* 11.4.3 -- 4 NOPs after CSDNControl write */
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|4
)paren
suffix:semicolon
)brace
DECL|function|doc2001plus_command
r_static
r_void
id|doc2001plus_command
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|command
comma
r_int
id|column
comma
r_int
id|page_addr
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
multiline_comment|/*&n;&t; * Must terminate write pipeline before sending any commands&n;&t; * to the device.&n;&t; */
r_if
c_cond
(paren
id|command
op_eq
id|NAND_CMD_PAGEPROG
)paren
(brace
id|WriteDOC
c_func
(paren
l_int|0x00
comma
id|docptr
comma
id|Mplus_WritePipeTerm
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0x00
comma
id|docptr
comma
id|Mplus_WritePipeTerm
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Write out the command to the device.&n;&t; */
r_if
c_cond
(paren
id|command
op_eq
id|NAND_CMD_SEQIN
)paren
(brace
r_int
id|readcmd
suffix:semicolon
r_if
c_cond
(paren
id|column
op_ge
id|mtd-&gt;oobblock
)paren
(brace
multiline_comment|/* OOB area */
id|column
op_sub_assign
id|mtd-&gt;oobblock
suffix:semicolon
id|readcmd
op_assign
id|NAND_CMD_READOOB
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|column
OL
l_int|256
)paren
(brace
multiline_comment|/* First 256 bytes --&gt; READ0 */
id|readcmd
op_assign
id|NAND_CMD_READ0
suffix:semicolon
)brace
r_else
(brace
id|column
op_sub_assign
l_int|256
suffix:semicolon
id|readcmd
op_assign
id|NAND_CMD_READ1
suffix:semicolon
)brace
id|WriteDOC
c_func
(paren
id|readcmd
comma
id|docptr
comma
id|Mplus_FlashCmd
)paren
suffix:semicolon
)brace
id|WriteDOC
c_func
(paren
id|command
comma
id|docptr
comma
id|Mplus_FlashCmd
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
id|Mplus_WritePipeTerm
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
id|Mplus_WritePipeTerm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|column
op_ne
op_minus
l_int|1
op_logical_or
id|page_addr
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Serially input address */
r_if
c_cond
(paren
id|column
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Adjust columns for 16 bit buswidth */
r_if
c_cond
(paren
id|this-&gt;options
op_amp
id|NAND_BUSWIDTH_16
)paren
id|column
op_rshift_assign
l_int|1
suffix:semicolon
id|WriteDOC
c_func
(paren
id|column
comma
id|docptr
comma
id|Mplus_FlashAddress
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page_addr
op_ne
op_minus
l_int|1
)paren
(brace
id|WriteDOC
c_func
(paren
(paren
r_int
r_char
)paren
(paren
id|page_addr
op_amp
l_int|0xff
)paren
comma
id|docptr
comma
id|Mplus_FlashAddress
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
(paren
r_int
r_char
)paren
(paren
(paren
id|page_addr
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
comma
id|docptr
comma
id|Mplus_FlashAddress
)paren
suffix:semicolon
multiline_comment|/* One more address cycle for higher density devices */
r_if
c_cond
(paren
id|this-&gt;chipsize
op_amp
l_int|0x0c000000
)paren
(brace
id|WriteDOC
c_func
(paren
(paren
r_int
r_char
)paren
(paren
(paren
id|page_addr
op_rshift
l_int|16
)paren
op_amp
l_int|0x0f
)paren
comma
id|docptr
comma
id|Mplus_FlashAddress
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;high density&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
id|Mplus_WritePipeTerm
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
id|Mplus_WritePipeTerm
)paren
suffix:semicolon
multiline_comment|/* deassert ALE */
r_if
c_cond
(paren
id|command
op_eq
id|NAND_CMD_READ0
op_logical_or
id|command
op_eq
id|NAND_CMD_READ1
op_logical_or
id|command
op_eq
id|NAND_CMD_READOOB
op_logical_or
id|command
op_eq
id|NAND_CMD_READID
)paren
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
id|Mplus_FlashControl
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * program and erase have their own busy handlers&n;&t; * status and sequential in needs no delay&n;&t;*/
r_switch
c_cond
(paren
id|command
)paren
(brace
r_case
id|NAND_CMD_PAGEPROG
suffix:colon
r_case
id|NAND_CMD_ERASE1
suffix:colon
r_case
id|NAND_CMD_ERASE2
suffix:colon
r_case
id|NAND_CMD_SEQIN
suffix:colon
r_case
id|NAND_CMD_STATUS
suffix:colon
r_return
suffix:semicolon
r_case
id|NAND_CMD_RESET
suffix:colon
r_if
c_cond
(paren
id|this-&gt;dev_ready
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
id|this-&gt;chip_delay
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|NAND_CMD_STATUS
comma
id|docptr
comma
id|Mplus_FlashCmd
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
id|Mplus_WritePipeTerm
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
id|Mplus_WritePipeTerm
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|this
op_member_access_from_pointer
id|read_byte
c_func
(paren
id|mtd
)paren
op_amp
l_int|0x40
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* This applies to read commands */
r_default
suffix:colon
(brace
)brace
multiline_comment|/* &n;&t;&t; * If we don&squot;t have access to the busy pin, we apply the given&n;&t;&t; * command delay&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;dev_ready
)paren
(brace
id|udelay
(paren
id|this-&gt;chip_delay
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Apply this short delay always to ensure that we do wait tWB in&n;&t; * any case on any machine. */
id|ndelay
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* wait until command is processed */
r_while
c_loop
(paren
op_logical_neg
id|this
op_member_access_from_pointer
id|dev_ready
c_func
(paren
id|mtd
)paren
)paren
suffix:semicolon
)brace
DECL|function|doc200x_dev_ready
r_static
r_int
id|doc200x_dev_ready
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_if
c_cond
(paren
id|DoC_is_MillenniumPlus
c_func
(paren
id|doc
)paren
)paren
(brace
multiline_comment|/* 11.4.2 -- must NOP four times before checking FR/B# */
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mplus_FlashControl
)paren
op_amp
id|CDSN_CTRL_FR_B_MASK
)paren
op_ne
id|CDSN_CTRL_FR_B_MASK
)paren
(brace
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;not ready&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug
)paren
id|printk
c_func
(paren
l_string|&quot;was ready&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* 11.4.2 -- must NOP four times before checking FR/B# */
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNControl
)paren
op_amp
id|CDSN_CTRL_FR_B
)paren
)paren
(brace
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;not ready&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* 11.4.2 -- Must NOP twice if it&squot;s ready */
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|printk
c_func
(paren
l_string|&quot;was ready&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|doc200x_block_bad
r_static
r_int
id|doc200x_block_bad
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|ofs
comma
r_int
id|getchip
)paren
(brace
multiline_comment|/* This is our last resort if we couldn&squot;t find or create a BBT.  Just&n;&t;   pretend all blocks are good. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|doc200x_enable_hwecc
r_static
r_void
id|doc200x_enable_hwecc
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|mode
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
multiline_comment|/* Prime the ECC engine */
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|NAND_ECC_READ
suffix:colon
id|WriteDOC
c_func
(paren
id|DOC_ECC_RESET
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|DOC_ECC_EN
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_ECC_WRITE
suffix:colon
id|WriteDOC
c_func
(paren
id|DOC_ECC_RESET
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|DOC_ECC_EN
op_or
id|DOC_ECC_RW
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|doc2001plus_enable_hwecc
r_static
r_void
id|doc2001plus_enable_hwecc
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|mode
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
multiline_comment|/* Prime the ECC engine */
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|NAND_ECC_READ
suffix:colon
id|WriteDOC
c_func
(paren
id|DOC_ECC_RESET
comma
id|docptr
comma
id|Mplus_ECCConf
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|DOC_ECC_EN
comma
id|docptr
comma
id|Mplus_ECCConf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_ECC_WRITE
suffix:colon
id|WriteDOC
c_func
(paren
id|DOC_ECC_RESET
comma
id|docptr
comma
id|Mplus_ECCConf
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|DOC_ECC_EN
op_or
id|DOC_ECC_RW
comma
id|docptr
comma
id|Mplus_ECCConf
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* This code is only called on write */
DECL|function|doc200x_calculate_ecc
r_static
r_int
id|doc200x_calculate_ecc
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
id|u_char
op_star
id|dat
comma
r_int
r_char
op_star
id|ecc_code
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|emptymatch
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* flush the pipeline */
r_if
c_cond
(paren
id|DoC_is_2000
c_func
(paren
id|doc
)paren
)paren
(brace
id|WriteDOC
c_func
(paren
id|doc-&gt;CDSNControl
op_amp
op_complement
id|CDSN_CTRL_FLASH_IO
comma
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|doc-&gt;CDSNControl
comma
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|DoC_is_MillenniumPlus
c_func
(paren
id|doc
)paren
)paren
(brace
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
id|Mplus_NOP
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
id|Mplus_NOP
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
id|Mplus_NOP
)paren
suffix:semicolon
)brace
r_else
(brace
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
id|NOP
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
id|NOP
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
id|NOP
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|DoC_is_MillenniumPlus
c_func
(paren
id|doc
)paren
)paren
id|ecc_code
(braket
id|i
)braket
op_assign
id|ReadDOC_
c_func
(paren
id|docptr
comma
id|DoC_Mplus_ECCSyndrome0
op_plus
id|i
)paren
suffix:semicolon
r_else
id|ecc_code
(braket
id|i
)braket
op_assign
id|ReadDOC_
c_func
(paren
id|docptr
comma
id|DoC_ECCSyndrome0
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ecc_code
(braket
id|i
)braket
op_ne
id|empty_write_ecc
(braket
id|i
)braket
)paren
id|emptymatch
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DoC_is_MillenniumPlus
c_func
(paren
id|doc
)paren
)paren
id|WriteDOC
c_func
(paren
id|DOC_ECC_DIS
comma
id|docptr
comma
id|Mplus_ECCConf
)paren
suffix:semicolon
r_else
id|WriteDOC
c_func
(paren
id|DOC_ECC_DIS
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* If emptymatch=1, we might have an all-0xff data buffer.  Check. */
r_if
c_cond
(paren
id|emptymatch
)paren
(brace
multiline_comment|/* Note: this somewhat expensive test should not be triggered&n;&t;&t;   often.  It could be optimized away by examining the data in&n;&t;&t;   the writebuf routine, and remembering the result. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|512
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dat
(braket
id|i
)braket
op_eq
l_int|0xff
)paren
r_continue
suffix:semicolon
id|emptymatch
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* If emptymatch still =1, we do have an all-0xff data buffer.&n;&t;   Return all-0xff ecc value instead of the computed one, so&n;&t;   it&squot;ll look just like a freshly-erased page. */
r_if
c_cond
(paren
id|emptymatch
)paren
id|memset
c_func
(paren
id|ecc_code
comma
l_int|0xff
comma
l_int|6
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|doc200x_correct_data
r_static
r_int
id|doc200x_correct_data
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u_char
op_star
id|dat
comma
id|u_char
op_star
id|read_ecc
comma
id|u_char
op_star
id|calc_ecc
)paren
(brace
r_int
id|i
comma
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_void
id|__iomem
op_star
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_volatile
id|u_char
id|dummy
suffix:semicolon
r_int
id|emptymatch
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* flush the pipeline */
r_if
c_cond
(paren
id|DoC_is_2000
c_func
(paren
id|doc
)paren
)paren
(brace
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_ECCStatus
)paren
suffix:semicolon
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_ECCStatus
)paren
suffix:semicolon
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_ECCStatus
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|DoC_is_MillenniumPlus
c_func
(paren
id|doc
)paren
)paren
(brace
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mplus_ECCConf
)paren
suffix:semicolon
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mplus_ECCConf
)paren
suffix:semicolon
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mplus_ECCConf
)paren
suffix:semicolon
)brace
r_else
(brace
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
)brace
multiline_comment|/* Error occured ? */
r_if
c_cond
(paren
id|dummy
op_amp
l_int|0x80
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|DoC_is_MillenniumPlus
c_func
(paren
id|doc
)paren
)paren
id|calc_ecc
(braket
id|i
)braket
op_assign
id|ReadDOC_
c_func
(paren
id|docptr
comma
id|DoC_Mplus_ECCSyndrome0
op_plus
id|i
)paren
suffix:semicolon
r_else
id|calc_ecc
(braket
id|i
)braket
op_assign
id|ReadDOC_
c_func
(paren
id|docptr
comma
id|DoC_ECCSyndrome0
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|calc_ecc
(braket
id|i
)braket
op_ne
id|empty_read_syndrome
(braket
id|i
)braket
)paren
id|emptymatch
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If emptymatch=1, the read syndrome is consistent with an&n;&t;&t;   all-0xff data and stored ecc block.  Check the stored ecc. */
r_if
c_cond
(paren
id|emptymatch
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|read_ecc
(braket
id|i
)braket
op_eq
l_int|0xff
)paren
r_continue
suffix:semicolon
id|emptymatch
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* If emptymatch still =1, check the data block. */
r_if
c_cond
(paren
id|emptymatch
)paren
(brace
multiline_comment|/* Note: this somewhat expensive test should not be triggered&n;&t;&t;   often.  It could be optimized away by examining the data in&n;&t;&t;   the readbuf routine, and remembering the result. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|512
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dat
(braket
id|i
)braket
op_eq
l_int|0xff
)paren
r_continue
suffix:semicolon
id|emptymatch
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* If emptymatch still =1, this is almost certainly a freshly-&n;&t;&t;   erased block, in which case the ECC will not come out right.&n;&t;&t;   We&squot;ll suppress the error and tell the caller everything&squot;s&n;&t;&t;   OK.  Because it is. */
r_if
c_cond
(paren
op_logical_neg
id|emptymatch
)paren
id|ret
op_assign
id|doc_ecc_decode
(paren
id|rs_decoder
comma
id|dat
comma
id|calc_ecc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OG
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;doc200x_correct_data corrected %d errors&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DoC_is_MillenniumPlus
c_func
(paren
id|doc
)paren
)paren
id|WriteDOC
c_func
(paren
id|DOC_ECC_DIS
comma
id|docptr
comma
id|Mplus_ECCConf
)paren
suffix:semicolon
r_else
id|WriteDOC
c_func
(paren
id|DOC_ECC_DIS
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|no_ecc_failures
op_logical_and
(paren
id|ret
op_eq
op_minus
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;suppressing ECC failure&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
singleline_comment|//u_char mydatabuf[528];
DECL|variable|doc200x_oobinfo
r_static
r_struct
id|nand_oobinfo
id|doc200x_oobinfo
op_assign
(brace
dot
id|useecc
op_assign
id|MTD_NANDECC_AUTOPLACE
comma
dot
id|eccbytes
op_assign
l_int|6
comma
dot
id|eccpos
op_assign
(brace
l_int|0
comma
l_int|1
comma
l_int|2
comma
l_int|3
comma
l_int|4
comma
l_int|5
)brace
comma
dot
id|oobfree
op_assign
(brace
(brace
l_int|8
comma
l_int|8
)brace
)brace
)brace
suffix:semicolon
multiline_comment|/* Find the (I)NFTL Media Header, and optionally also the mirror media header.&n;   On sucessful return, buf will contain a copy of the media header for&n;   further processing.  id is the string to scan for, and will presumably be&n;   either &quot;ANAND&quot; or &quot;BNAND&quot;.  If findmirror=1, also look for the mirror media&n;   header.  The page #s of the found media headers are placed in mh0_page and&n;   mh1_page in the DOC private structure. */
DECL|function|find_media_headers
r_static
r_int
id|__init
id|find_media_headers
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u_char
op_star
id|buf
comma
r_const
r_char
op_star
id|id
comma
r_int
id|findmirror
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_int
id|offs
comma
id|end
op_assign
(paren
id|MAX_MEDIAHEADER_SCAN
op_lshift
id|this-&gt;phys_erase_shift
)paren
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|retlen
suffix:semicolon
id|end
op_assign
id|min
c_func
(paren
id|end
comma
id|mtd-&gt;size
)paren
suffix:semicolon
singleline_comment|// paranoia
r_for
c_loop
(paren
id|offs
op_assign
l_int|0
suffix:semicolon
id|offs
OL
id|end
suffix:semicolon
id|offs
op_add_assign
id|mtd-&gt;erasesize
)paren
(brace
id|ret
op_assign
id|mtd
op_member_access_from_pointer
id|read
c_func
(paren
id|mtd
comma
id|offs
comma
id|mtd-&gt;oobblock
comma
op_amp
id|retlen
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retlen
op_ne
id|mtd-&gt;oobblock
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ECC error scanning DOC at 0x%x&bslash;n&quot;
comma
id|offs
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|buf
comma
id|id
comma
l_int|6
)paren
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Found DiskOnChip %s Media Header at 0x%x&bslash;n&quot;
comma
id|id
comma
id|offs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|doc-&gt;mh0_page
op_eq
op_minus
l_int|1
)paren
(brace
id|doc-&gt;mh0_page
op_assign
id|offs
op_rshift
id|this-&gt;page_shift
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|findmirror
)paren
r_return
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|doc-&gt;mh1_page
op_assign
id|offs
op_rshift
id|this-&gt;page_shift
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|doc-&gt;mh0_page
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;DiskOnChip %s Media Header not found.&bslash;n&quot;
comma
id|id
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Only one mediaheader was found.  We want buf to contain a&n;&t;   mediaheader on return, so we&squot;ll have to re-read the one we found. */
id|offs
op_assign
id|doc-&gt;mh0_page
op_lshift
id|this-&gt;page_shift
suffix:semicolon
id|ret
op_assign
id|mtd
op_member_access_from_pointer
id|read
c_func
(paren
id|mtd
comma
id|offs
comma
id|mtd-&gt;oobblock
comma
op_amp
id|retlen
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retlen
op_ne
id|mtd-&gt;oobblock
)paren
(brace
multiline_comment|/* Insanity.  Give up. */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Read DiskOnChip Media Header once, but can&squot;t reread it???&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|nftl_partscan
r_static
r_inline
r_int
id|__init
id|nftl_partscan
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|mtd_partition
op_star
id|parts
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|u_char
op_star
id|buf
suffix:semicolon
r_struct
id|NFTLMediaHeader
op_star
id|mh
suffix:semicolon
r_const
r_int
id|psize
op_assign
l_int|1
op_lshift
id|this-&gt;page_shift
suffix:semicolon
r_int
id|blocks
comma
id|maxblocks
suffix:semicolon
r_int
id|offs
comma
id|numheaders
suffix:semicolon
id|buf
op_assign
id|kmalloc
c_func
(paren
id|mtd-&gt;oobblock
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;DiskOnChip mediaheader kmalloc failed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|numheaders
op_assign
id|find_media_headers
c_func
(paren
id|mtd
comma
id|buf
comma
l_string|&quot;ANAND&quot;
comma
l_int|1
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|mh
op_assign
(paren
r_struct
id|NFTLMediaHeader
op_star
)paren
id|buf
suffix:semicolon
singleline_comment|//#ifdef CONFIG_MTD_DEBUG_VERBOSE
singleline_comment|//&t;if (CONFIG_MTD_DEBUG_VERBOSE &gt;= 2)
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    DataOrgID        = %s&bslash;n&quot;
l_string|&quot;    NumEraseUnits    = %d&bslash;n&quot;
l_string|&quot;    FirstPhysicalEUN = %d&bslash;n&quot;
l_string|&quot;    FormattedSize    = %d&bslash;n&quot;
l_string|&quot;    UnitSizeFactor   = %d&bslash;n&quot;
comma
id|mh-&gt;DataOrgID
comma
id|mh-&gt;NumEraseUnits
comma
id|mh-&gt;FirstPhysicalEUN
comma
id|mh-&gt;FormattedSize
comma
id|mh-&gt;UnitSizeFactor
)paren
suffix:semicolon
singleline_comment|//#endif
id|blocks
op_assign
id|mtd-&gt;size
op_rshift
id|this-&gt;phys_erase_shift
suffix:semicolon
id|maxblocks
op_assign
id|min
c_func
(paren
l_int|32768U
comma
id|mtd-&gt;erasesize
op_minus
id|psize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mh-&gt;UnitSizeFactor
op_eq
l_int|0x00
)paren
(brace
multiline_comment|/* Auto-determine UnitSizeFactor.  The constraints are:&n;&t;&t;   - There can be at most 32768 virtual blocks.&n;&t;&t;   - There can be at most (virtual block size - page size)&n;&t;&t;     virtual blocks (because MediaHeader+BBT must fit in 1).&n;&t;&t;*/
id|mh-&gt;UnitSizeFactor
op_assign
l_int|0xff
suffix:semicolon
r_while
c_loop
(paren
id|blocks
OG
id|maxblocks
)paren
(brace
id|blocks
op_rshift_assign
l_int|1
suffix:semicolon
id|maxblocks
op_assign
id|min
c_func
(paren
l_int|32768U
comma
(paren
id|maxblocks
op_lshift
l_int|1
)paren
op_plus
id|psize
)paren
suffix:semicolon
id|mh-&gt;UnitSizeFactor
op_decrement
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;UnitSizeFactor=0x00 detected.  Correct value is assumed to be 0x%02x.&bslash;n&quot;
comma
id|mh-&gt;UnitSizeFactor
)paren
suffix:semicolon
)brace
multiline_comment|/* NOTE: The lines below modify internal variables of the NAND and MTD&n;&t;   layers; variables with have already been configured by nand_scan.&n;&t;   Unfortunately, we didn&squot;t know before this point what these values&n;&t;   should be.  Thus, this code is somewhat dependant on the exact&n;&t;   implementation of the NAND layer.  */
r_if
c_cond
(paren
id|mh-&gt;UnitSizeFactor
op_ne
l_int|0xff
)paren
(brace
id|this-&gt;bbt_erase_shift
op_add_assign
(paren
l_int|0xff
op_minus
id|mh-&gt;UnitSizeFactor
)paren
suffix:semicolon
id|mtd-&gt;erasesize
op_lshift_assign
(paren
l_int|0xff
op_minus
id|mh-&gt;UnitSizeFactor
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Setting virtual erase size to %d&bslash;n&quot;
comma
id|mtd-&gt;erasesize
)paren
suffix:semicolon
id|blocks
op_assign
id|mtd-&gt;size
op_rshift
id|this-&gt;bbt_erase_shift
suffix:semicolon
id|maxblocks
op_assign
id|min
c_func
(paren
l_int|32768U
comma
id|mtd-&gt;erasesize
op_minus
id|psize
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|blocks
OG
id|maxblocks
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;UnitSizeFactor of 0x%02x is inconsistent with device size.  Aborting.&bslash;n&quot;
comma
id|mh-&gt;UnitSizeFactor
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Skip past the media headers. */
id|offs
op_assign
id|max
c_func
(paren
id|doc-&gt;mh0_page
comma
id|doc-&gt;mh1_page
)paren
suffix:semicolon
id|offs
op_lshift_assign
id|this-&gt;page_shift
suffix:semicolon
id|offs
op_add_assign
id|mtd-&gt;erasesize
suffix:semicolon
singleline_comment|//parts[0].name = &quot; DiskOnChip Boot / Media Header partition&quot;;
singleline_comment|//parts[0].offset = 0;
singleline_comment|//parts[0].size = offs;
id|parts
(braket
l_int|0
)braket
dot
id|name
op_assign
l_string|&quot; DiskOnChip BDTL partition&quot;
suffix:semicolon
id|parts
(braket
l_int|0
)braket
dot
id|offset
op_assign
id|offs
suffix:semicolon
id|parts
(braket
l_int|0
)braket
dot
id|size
op_assign
(paren
id|mh-&gt;NumEraseUnits
op_minus
id|numheaders
)paren
op_lshift
id|this-&gt;bbt_erase_shift
suffix:semicolon
id|offs
op_add_assign
id|parts
(braket
l_int|0
)braket
dot
id|size
suffix:semicolon
r_if
c_cond
(paren
id|offs
OL
id|mtd-&gt;size
)paren
(brace
id|parts
(braket
l_int|1
)braket
dot
id|name
op_assign
l_string|&quot; DiskOnChip Remainder partition&quot;
suffix:semicolon
id|parts
(braket
l_int|1
)braket
dot
id|offset
op_assign
id|offs
suffix:semicolon
id|parts
(braket
l_int|1
)braket
dot
id|size
op_assign
id|mtd-&gt;size
op_minus
id|offs
suffix:semicolon
id|ret
op_assign
l_int|2
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|ret
op_assign
l_int|1
suffix:semicolon
id|out
suffix:colon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* This is a stripped-down copy of the code in inftlmount.c */
DECL|function|inftl_partscan
r_static
r_inline
r_int
id|__init
id|inftl_partscan
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|mtd_partition
op_star
id|parts
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|u_char
op_star
id|buf
suffix:semicolon
r_struct
id|INFTLMediaHeader
op_star
id|mh
suffix:semicolon
r_struct
id|INFTLPartition
op_star
id|ip
suffix:semicolon
r_int
id|numparts
op_assign
l_int|0
suffix:semicolon
r_int
id|blocks
suffix:semicolon
r_int
id|vshift
comma
id|lastvunit
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|end
op_assign
id|mtd-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|inftl_bbt_write
)paren
id|end
op_sub_assign
(paren
id|INFTL_BBT_RESERVED_BLOCKS
op_lshift
id|this-&gt;phys_erase_shift
)paren
suffix:semicolon
id|buf
op_assign
id|kmalloc
c_func
(paren
id|mtd-&gt;oobblock
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;DiskOnChip mediaheader kmalloc failed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|find_media_headers
c_func
(paren
id|mtd
comma
id|buf
comma
l_string|&quot;BNAND&quot;
comma
l_int|0
)paren
)paren
r_goto
id|out
suffix:semicolon
id|doc-&gt;mh1_page
op_assign
id|doc-&gt;mh0_page
op_plus
(paren
l_int|4096
op_rshift
id|this-&gt;page_shift
)paren
suffix:semicolon
id|mh
op_assign
(paren
r_struct
id|INFTLMediaHeader
op_star
)paren
id|buf
suffix:semicolon
id|mh-&gt;NoOfBootImageBlocks
op_assign
id|le32_to_cpu
c_func
(paren
id|mh-&gt;NoOfBootImageBlocks
)paren
suffix:semicolon
id|mh-&gt;NoOfBinaryPartitions
op_assign
id|le32_to_cpu
c_func
(paren
id|mh-&gt;NoOfBinaryPartitions
)paren
suffix:semicolon
id|mh-&gt;NoOfBDTLPartitions
op_assign
id|le32_to_cpu
c_func
(paren
id|mh-&gt;NoOfBDTLPartitions
)paren
suffix:semicolon
id|mh-&gt;BlockMultiplierBits
op_assign
id|le32_to_cpu
c_func
(paren
id|mh-&gt;BlockMultiplierBits
)paren
suffix:semicolon
id|mh-&gt;FormatFlags
op_assign
id|le32_to_cpu
c_func
(paren
id|mh-&gt;FormatFlags
)paren
suffix:semicolon
id|mh-&gt;PercentUsed
op_assign
id|le32_to_cpu
c_func
(paren
id|mh-&gt;PercentUsed
)paren
suffix:semicolon
singleline_comment|//#ifdef CONFIG_MTD_DEBUG_VERBOSE
singleline_comment|//&t;if (CONFIG_MTD_DEBUG_VERBOSE &gt;= 2)
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    bootRecordID          = %s&bslash;n&quot;
l_string|&quot;    NoOfBootImageBlocks   = %d&bslash;n&quot;
l_string|&quot;    NoOfBinaryPartitions  = %d&bslash;n&quot;
l_string|&quot;    NoOfBDTLPartitions    = %d&bslash;n&quot;
l_string|&quot;    BlockMultiplerBits    = %d&bslash;n&quot;
l_string|&quot;    FormatFlgs            = %d&bslash;n&quot;
l_string|&quot;    OsakVersion           = %d.%d.%d.%d&bslash;n&quot;
l_string|&quot;    PercentUsed           = %d&bslash;n&quot;
comma
id|mh-&gt;bootRecordID
comma
id|mh-&gt;NoOfBootImageBlocks
comma
id|mh-&gt;NoOfBinaryPartitions
comma
id|mh-&gt;NoOfBDTLPartitions
comma
id|mh-&gt;BlockMultiplierBits
comma
id|mh-&gt;FormatFlags
comma
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|mh-&gt;OsakVersion
)paren
(braket
l_int|0
)braket
op_amp
l_int|0xf
comma
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|mh-&gt;OsakVersion
)paren
(braket
l_int|1
)braket
op_amp
l_int|0xf
comma
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|mh-&gt;OsakVersion
)paren
(braket
l_int|2
)braket
op_amp
l_int|0xf
comma
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|mh-&gt;OsakVersion
)paren
(braket
l_int|3
)braket
op_amp
l_int|0xf
comma
id|mh-&gt;PercentUsed
)paren
suffix:semicolon
singleline_comment|//#endif
id|vshift
op_assign
id|this-&gt;phys_erase_shift
op_plus
id|mh-&gt;BlockMultiplierBits
suffix:semicolon
id|blocks
op_assign
id|mtd-&gt;size
op_rshift
id|vshift
suffix:semicolon
r_if
c_cond
(paren
id|blocks
OG
l_int|32768
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;BlockMultiplierBits=%d is inconsistent with device size.  Aborting.&bslash;n&quot;
comma
id|mh-&gt;BlockMultiplierBits
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|blocks
op_assign
id|doc-&gt;chips_per_floor
op_lshift
(paren
id|this-&gt;chip_shift
op_minus
id|this-&gt;phys_erase_shift
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inftl_bbt_write
op_logical_and
(paren
id|blocks
OG
id|mtd-&gt;erasesize
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Writeable BBTs spanning more than one erase block are not yet supported.  FIX ME!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Scan the partitions */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
l_int|4
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ip
op_assign
op_amp
(paren
id|mh-&gt;Partitions
(braket
id|i
)braket
)paren
suffix:semicolon
id|ip-&gt;virtualUnits
op_assign
id|le32_to_cpu
c_func
(paren
id|ip-&gt;virtualUnits
)paren
suffix:semicolon
id|ip-&gt;firstUnit
op_assign
id|le32_to_cpu
c_func
(paren
id|ip-&gt;firstUnit
)paren
suffix:semicolon
id|ip-&gt;lastUnit
op_assign
id|le32_to_cpu
c_func
(paren
id|ip-&gt;lastUnit
)paren
suffix:semicolon
id|ip-&gt;flags
op_assign
id|le32_to_cpu
c_func
(paren
id|ip-&gt;flags
)paren
suffix:semicolon
id|ip-&gt;spareUnits
op_assign
id|le32_to_cpu
c_func
(paren
id|ip-&gt;spareUnits
)paren
suffix:semicolon
id|ip-&gt;Reserved0
op_assign
id|le32_to_cpu
c_func
(paren
id|ip-&gt;Reserved0
)paren
suffix:semicolon
singleline_comment|//#ifdef CONFIG_MTD_DEBUG_VERBOSE
singleline_comment|//&t;&t;if (CONFIG_MTD_DEBUG_VERBOSE &gt;= 2)
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    PARTITION[%d] -&gt;&bslash;n&quot;
l_string|&quot;        virtualUnits    = %d&bslash;n&quot;
l_string|&quot;        firstUnit       = %d&bslash;n&quot;
l_string|&quot;        lastUnit        = %d&bslash;n&quot;
l_string|&quot;        flags           = 0x%x&bslash;n&quot;
l_string|&quot;        spareUnits      = %d&bslash;n&quot;
comma
id|i
comma
id|ip-&gt;virtualUnits
comma
id|ip-&gt;firstUnit
comma
id|ip-&gt;lastUnit
comma
id|ip-&gt;flags
comma
id|ip-&gt;spareUnits
)paren
suffix:semicolon
singleline_comment|//#endif
multiline_comment|/*&n;&t;&t;if ((i == 0) &amp;&amp; (ip-&gt;firstUnit &gt; 0)) {&n;&t;&t;&t;parts[0].name = &quot; DiskOnChip IPL / Media Header partition&quot;;&n;&t;&t;&t;parts[0].offset = 0;&n;&t;&t;&t;parts[0].size = mtd-&gt;erasesize * ip-&gt;firstUnit;&n;&t;&t;&t;numparts = 1;&n;&t;&t;}&n;*/
r_if
c_cond
(paren
id|ip-&gt;flags
op_amp
id|INFTL_BINARY
)paren
id|parts
(braket
id|numparts
)braket
dot
id|name
op_assign
l_string|&quot; DiskOnChip BDK partition&quot;
suffix:semicolon
r_else
id|parts
(braket
id|numparts
)braket
dot
id|name
op_assign
l_string|&quot; DiskOnChip BDTL partition&quot;
suffix:semicolon
id|parts
(braket
id|numparts
)braket
dot
id|offset
op_assign
id|ip-&gt;firstUnit
op_lshift
id|vshift
suffix:semicolon
id|parts
(braket
id|numparts
)braket
dot
id|size
op_assign
(paren
l_int|1
op_plus
id|ip-&gt;lastUnit
op_minus
id|ip-&gt;firstUnit
)paren
op_lshift
id|vshift
suffix:semicolon
id|numparts
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;lastUnit
OG
id|lastvunit
)paren
id|lastvunit
op_assign
id|ip-&gt;lastUnit
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;flags
op_amp
id|INFTL_LAST
)paren
r_break
suffix:semicolon
)brace
id|lastvunit
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lastvunit
op_lshift
id|vshift
)paren
OL
id|end
)paren
(brace
id|parts
(braket
id|numparts
)braket
dot
id|name
op_assign
l_string|&quot; DiskOnChip Remainder partition&quot;
suffix:semicolon
id|parts
(braket
id|numparts
)braket
dot
id|offset
op_assign
id|lastvunit
op_lshift
id|vshift
suffix:semicolon
id|parts
(braket
id|numparts
)braket
dot
id|size
op_assign
id|end
op_minus
id|parts
(braket
id|numparts
)braket
dot
id|offset
suffix:semicolon
id|numparts
op_increment
suffix:semicolon
)brace
id|ret
op_assign
id|numparts
suffix:semicolon
id|out
suffix:colon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|nftl_scan_bbt
r_static
r_int
id|__init
id|nftl_scan_bbt
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_int
id|ret
comma
id|numparts
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_struct
id|mtd_partition
id|parts
(braket
l_int|2
)braket
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|parts
comma
l_int|0
comma
r_sizeof
(paren
id|parts
)paren
)paren
suffix:semicolon
multiline_comment|/* On NFTL, we have to find the media headers before we can read the&n;&t;   BBTs, since they&squot;re stored in the media header eraseblocks. */
id|numparts
op_assign
id|nftl_partscan
c_func
(paren
id|mtd
comma
id|parts
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|numparts
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|this-&gt;bbt_td-&gt;options
op_assign
id|NAND_BBT_ABSPAGE
op_or
id|NAND_BBT_8BIT
op_or
id|NAND_BBT_SAVECONTENT
op_or
id|NAND_BBT_WRITE
op_or
id|NAND_BBT_VERSION
suffix:semicolon
id|this-&gt;bbt_td-&gt;veroffs
op_assign
l_int|7
suffix:semicolon
id|this-&gt;bbt_td-&gt;pages
(braket
l_int|0
)braket
op_assign
id|doc-&gt;mh0_page
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|doc-&gt;mh1_page
op_ne
op_minus
l_int|1
)paren
(brace
id|this-&gt;bbt_md-&gt;options
op_assign
id|NAND_BBT_ABSPAGE
op_or
id|NAND_BBT_8BIT
op_or
id|NAND_BBT_SAVECONTENT
op_or
id|NAND_BBT_WRITE
op_or
id|NAND_BBT_VERSION
suffix:semicolon
id|this-&gt;bbt_md-&gt;veroffs
op_assign
l_int|7
suffix:semicolon
id|this-&gt;bbt_md-&gt;pages
(braket
l_int|0
)braket
op_assign
id|doc-&gt;mh1_page
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|this-&gt;bbt_md
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* It&squot;s safe to set bd=NULL below because NAND_BBT_CREATE is not set.&n;&t;   At least as nand_bbt.c is currently written. */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|nand_scan_bbt
c_func
(paren
id|mtd
comma
l_int|NULL
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|add_mtd_device
c_func
(paren
id|mtd
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MTD_PARTITIONS
r_if
c_cond
(paren
op_logical_neg
id|no_autopart
)paren
id|add_mtd_partitions
c_func
(paren
id|mtd
comma
id|parts
comma
id|numparts
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|inftl_scan_bbt
r_static
r_int
id|__init
id|inftl_scan_bbt
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_int
id|ret
comma
id|numparts
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
r_struct
id|mtd_partition
id|parts
(braket
l_int|5
)braket
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;numchips
OG
id|doc-&gt;chips_per_floor
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Multi-floor INFTL devices not yet supported.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DoC_is_MillenniumPlus
c_func
(paren
id|doc
)paren
)paren
(brace
id|this-&gt;bbt_td-&gt;options
op_assign
id|NAND_BBT_2BIT
op_or
id|NAND_BBT_ABSPAGE
suffix:semicolon
r_if
c_cond
(paren
id|inftl_bbt_write
)paren
id|this-&gt;bbt_td-&gt;options
op_or_assign
id|NAND_BBT_WRITE
suffix:semicolon
id|this-&gt;bbt_td-&gt;pages
(braket
l_int|0
)braket
op_assign
l_int|2
suffix:semicolon
id|this-&gt;bbt_md
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|this-&gt;bbt_td-&gt;options
op_assign
id|NAND_BBT_LASTBLOCK
op_or
id|NAND_BBT_8BIT
op_or
id|NAND_BBT_VERSION
suffix:semicolon
r_if
c_cond
(paren
id|inftl_bbt_write
)paren
id|this-&gt;bbt_td-&gt;options
op_or_assign
id|NAND_BBT_WRITE
suffix:semicolon
id|this-&gt;bbt_td-&gt;offs
op_assign
l_int|8
suffix:semicolon
id|this-&gt;bbt_td-&gt;len
op_assign
l_int|8
suffix:semicolon
id|this-&gt;bbt_td-&gt;veroffs
op_assign
l_int|7
suffix:semicolon
id|this-&gt;bbt_td-&gt;maxblocks
op_assign
id|INFTL_BBT_RESERVED_BLOCKS
suffix:semicolon
id|this-&gt;bbt_td-&gt;reserved_block_code
op_assign
l_int|0x01
suffix:semicolon
id|this-&gt;bbt_td-&gt;pattern
op_assign
l_string|&quot;MSYS_BBT&quot;
suffix:semicolon
id|this-&gt;bbt_md-&gt;options
op_assign
id|NAND_BBT_LASTBLOCK
op_or
id|NAND_BBT_8BIT
op_or
id|NAND_BBT_VERSION
suffix:semicolon
r_if
c_cond
(paren
id|inftl_bbt_write
)paren
id|this-&gt;bbt_md-&gt;options
op_or_assign
id|NAND_BBT_WRITE
suffix:semicolon
id|this-&gt;bbt_md-&gt;offs
op_assign
l_int|8
suffix:semicolon
id|this-&gt;bbt_md-&gt;len
op_assign
l_int|8
suffix:semicolon
id|this-&gt;bbt_md-&gt;veroffs
op_assign
l_int|7
suffix:semicolon
id|this-&gt;bbt_md-&gt;maxblocks
op_assign
id|INFTL_BBT_RESERVED_BLOCKS
suffix:semicolon
id|this-&gt;bbt_md-&gt;reserved_block_code
op_assign
l_int|0x01
suffix:semicolon
id|this-&gt;bbt_md-&gt;pattern
op_assign
l_string|&quot;TBB_SYSM&quot;
suffix:semicolon
)brace
multiline_comment|/* It&squot;s safe to set bd=NULL below because NAND_BBT_CREATE is not set.&n;&t;   At least as nand_bbt.c is currently written. */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|nand_scan_bbt
c_func
(paren
id|mtd
comma
l_int|NULL
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|parts
comma
l_int|0
comma
r_sizeof
(paren
id|parts
)paren
)paren
suffix:semicolon
id|numparts
op_assign
id|inftl_partscan
c_func
(paren
id|mtd
comma
id|parts
)paren
suffix:semicolon
multiline_comment|/* At least for now, require the INFTL Media Header.  We could probably&n;&t;   do without it for non-INFTL use, since all it gives us is&n;&t;   autopartitioning, but I want to give it more thought. */
r_if
c_cond
(paren
op_logical_neg
id|numparts
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|add_mtd_device
c_func
(paren
id|mtd
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MTD_PARTITIONS
r_if
c_cond
(paren
op_logical_neg
id|no_autopart
)paren
id|add_mtd_partitions
c_func
(paren
id|mtd
comma
id|parts
comma
id|numparts
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|doc2000_init
r_static
r_inline
r_int
id|__init
id|doc2000_init
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
id|this-&gt;write_byte
op_assign
id|doc2000_write_byte
suffix:semicolon
id|this-&gt;read_byte
op_assign
id|doc2000_read_byte
suffix:semicolon
id|this-&gt;write_buf
op_assign
id|doc2000_writebuf
suffix:semicolon
id|this-&gt;read_buf
op_assign
id|doc2000_readbuf
suffix:semicolon
id|this-&gt;verify_buf
op_assign
id|doc2000_verifybuf
suffix:semicolon
id|this-&gt;scan_bbt
op_assign
id|nftl_scan_bbt
suffix:semicolon
id|doc-&gt;CDSNControl
op_assign
id|CDSN_CTRL_FLASH_IO
op_or
id|CDSN_CTRL_ECC_IO
suffix:semicolon
id|doc2000_count_chips
c_func
(paren
id|mtd
)paren
suffix:semicolon
id|mtd-&gt;name
op_assign
l_string|&quot;DiskOnChip 2000 (NFTL Model)&quot;
suffix:semicolon
r_return
(paren
l_int|4
op_star
id|doc-&gt;chips_per_floor
)paren
suffix:semicolon
)brace
DECL|function|doc2001_init
r_static
r_inline
r_int
id|__init
id|doc2001_init
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
id|this-&gt;write_byte
op_assign
id|doc2001_write_byte
suffix:semicolon
id|this-&gt;read_byte
op_assign
id|doc2001_read_byte
suffix:semicolon
id|this-&gt;write_buf
op_assign
id|doc2001_writebuf
suffix:semicolon
id|this-&gt;read_buf
op_assign
id|doc2001_readbuf
suffix:semicolon
id|this-&gt;verify_buf
op_assign
id|doc2001_verifybuf
suffix:semicolon
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|ChipID
)paren
suffix:semicolon
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|ChipID
)paren
suffix:semicolon
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|ChipID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|ChipID
)paren
op_ne
id|DOC_ChipID_DocMil
)paren
(brace
multiline_comment|/* It&squot;s not a Millennium; it&squot;s one of the newer&n;&t;&t;   DiskOnChip 2000 units with a similar ASIC. &n;&t;&t;   Treat it like a Millennium, except that it&n;&t;&t;   can have multiple chips. */
id|doc2000_count_chips
c_func
(paren
id|mtd
)paren
suffix:semicolon
id|mtd-&gt;name
op_assign
l_string|&quot;DiskOnChip 2000 (INFTL Model)&quot;
suffix:semicolon
id|this-&gt;scan_bbt
op_assign
id|inftl_scan_bbt
suffix:semicolon
r_return
(paren
l_int|4
op_star
id|doc-&gt;chips_per_floor
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Bog-standard Millennium */
id|doc-&gt;chips_per_floor
op_assign
l_int|1
suffix:semicolon
id|mtd-&gt;name
op_assign
l_string|&quot;DiskOnChip Millennium&quot;
suffix:semicolon
id|this-&gt;scan_bbt
op_assign
id|nftl_scan_bbt
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|doc2001plus_init
r_static
r_inline
r_int
id|__init
id|doc2001plus_init
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
op_assign
(paren
r_void
op_star
)paren
id|this-&gt;priv
suffix:semicolon
id|this-&gt;write_byte
op_assign
l_int|NULL
suffix:semicolon
id|this-&gt;read_byte
op_assign
id|doc2001plus_read_byte
suffix:semicolon
id|this-&gt;write_buf
op_assign
id|doc2001plus_writebuf
suffix:semicolon
id|this-&gt;read_buf
op_assign
id|doc2001plus_readbuf
suffix:semicolon
id|this-&gt;verify_buf
op_assign
id|doc2001plus_verifybuf
suffix:semicolon
id|this-&gt;scan_bbt
op_assign
id|inftl_scan_bbt
suffix:semicolon
id|this-&gt;hwcontrol
op_assign
l_int|NULL
suffix:semicolon
id|this-&gt;select_chip
op_assign
id|doc2001plus_select_chip
suffix:semicolon
id|this-&gt;cmdfunc
op_assign
id|doc2001plus_command
suffix:semicolon
id|this-&gt;enable_hwecc
op_assign
id|doc2001plus_enable_hwecc
suffix:semicolon
id|doc-&gt;chips_per_floor
op_assign
l_int|1
suffix:semicolon
id|mtd-&gt;name
op_assign
l_string|&quot;DiskOnChip Millennium Plus&quot;
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|doc_probe
r_static
r_inline
r_int
id|__init
id|doc_probe
c_func
(paren
r_int
r_int
id|physadr
)paren
(brace
r_int
r_char
id|ChipID
suffix:semicolon
r_struct
id|mtd_info
op_star
id|mtd
suffix:semicolon
r_struct
id|nand_chip
op_star
id|nand
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
suffix:semicolon
r_void
id|__iomem
op_star
id|virtadr
suffix:semicolon
r_int
r_char
id|save_control
suffix:semicolon
r_int
r_char
id|tmp
comma
id|tmpb
comma
id|tmpc
suffix:semicolon
r_int
id|reg
comma
id|len
comma
id|numchips
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|virtadr
op_assign
id|ioremap
c_func
(paren
id|physadr
comma
id|DOC_IOREMAP_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|virtadr
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Diskonchip ioremap failed: 0x%x bytes at 0x%lx&bslash;n&quot;
comma
id|DOC_IOREMAP_LEN
comma
id|physadr
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* It&squot;s not possible to cleanly detect the DiskOnChip - the&n;&t; * bootup procedure will put the device into reset mode, and&n;&t; * it&squot;s not possible to talk to it without actually writing&n;&t; * to the DOCControl register. So we store the current contents&n;&t; * of the DOCControl register&squot;s location, in case we later decide&n;&t; * that it&squot;s not a DiskOnChip, and want to put it back how we&n;&t; * found it. &n;&t; */
id|save_control
op_assign
id|ReadDOC
c_func
(paren
id|virtadr
comma
id|DOCControl
)paren
suffix:semicolon
multiline_comment|/* Reset the DiskOnChip ASIC */
id|WriteDOC
c_func
(paren
id|DOC_MODE_CLR_ERR
op_or
id|DOC_MODE_MDWREN
op_or
id|DOC_MODE_RESET
comma
id|virtadr
comma
id|DOCControl
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|DOC_MODE_CLR_ERR
op_or
id|DOC_MODE_MDWREN
op_or
id|DOC_MODE_RESET
comma
id|virtadr
comma
id|DOCControl
)paren
suffix:semicolon
multiline_comment|/* Enable the DiskOnChip ASIC */
id|WriteDOC
c_func
(paren
id|DOC_MODE_CLR_ERR
op_or
id|DOC_MODE_MDWREN
op_or
id|DOC_MODE_NORMAL
comma
id|virtadr
comma
id|DOCControl
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|DOC_MODE_CLR_ERR
op_or
id|DOC_MODE_MDWREN
op_or
id|DOC_MODE_NORMAL
comma
id|virtadr
comma
id|DOCControl
)paren
suffix:semicolon
id|ChipID
op_assign
id|ReadDOC
c_func
(paren
id|virtadr
comma
id|ChipID
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ChipID
)paren
(brace
r_case
id|DOC_ChipID_Doc2k
suffix:colon
id|reg
op_assign
id|DoC_2k_ECCStatus
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DOC_ChipID_DocMil
suffix:colon
id|reg
op_assign
id|DoC_ECCConf
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DOC_ChipID_DocMilPlus16
suffix:colon
r_case
id|DOC_ChipID_DocMilPlus32
suffix:colon
r_case
l_int|0
suffix:colon
multiline_comment|/* Possible Millennium Plus, need to do more checks */
multiline_comment|/* Possibly release from power down mode */
r_for
c_loop
(paren
id|tmp
op_assign
l_int|0
suffix:semicolon
(paren
id|tmp
OL
l_int|4
)paren
suffix:semicolon
id|tmp
op_increment
)paren
id|ReadDOC
c_func
(paren
id|virtadr
comma
id|Mplus_Power
)paren
suffix:semicolon
multiline_comment|/* Reset the Millennium Plus ASIC */
id|tmp
op_assign
id|DOC_MODE_RESET
op_or
id|DOC_MODE_MDWREN
op_or
id|DOC_MODE_RST_LAT
op_or
id|DOC_MODE_BDECT
suffix:semicolon
id|WriteDOC
c_func
(paren
id|tmp
comma
id|virtadr
comma
id|Mplus_DOCControl
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
op_complement
id|tmp
comma
id|virtadr
comma
id|Mplus_CtrlConfirm
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Enable the Millennium Plus ASIC */
id|tmp
op_assign
id|DOC_MODE_NORMAL
op_or
id|DOC_MODE_MDWREN
op_or
id|DOC_MODE_RST_LAT
op_or
id|DOC_MODE_BDECT
suffix:semicolon
id|WriteDOC
c_func
(paren
id|tmp
comma
id|virtadr
comma
id|Mplus_DOCControl
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
op_complement
id|tmp
comma
id|virtadr
comma
id|Mplus_CtrlConfirm
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|ChipID
op_assign
id|ReadDOC
c_func
(paren
id|virtadr
comma
id|ChipID
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ChipID
)paren
(brace
r_case
id|DOC_ChipID_DocMilPlus16
suffix:colon
id|reg
op_assign
id|DoC_Mplus_Toggle
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DOC_ChipID_DocMilPlus32
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;DiskOnChip Millennium Plus 32MB is not supported, ignoring.&bslash;n&quot;
)paren
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|notfound
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|notfound
suffix:semicolon
)brace
multiline_comment|/* Check the TOGGLE bit in the ECC register */
id|tmp
op_assign
id|ReadDOC_
c_func
(paren
id|virtadr
comma
id|reg
)paren
op_amp
id|DOC_TOGGLE_BIT
suffix:semicolon
id|tmpb
op_assign
id|ReadDOC_
c_func
(paren
id|virtadr
comma
id|reg
)paren
op_amp
id|DOC_TOGGLE_BIT
suffix:semicolon
id|tmpc
op_assign
id|ReadDOC_
c_func
(paren
id|virtadr
comma
id|reg
)paren
op_amp
id|DOC_TOGGLE_BIT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_eq
id|tmpb
)paren
op_logical_or
(paren
id|tmp
op_ne
id|tmpc
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Possible DiskOnChip at 0x%lx failed TOGGLE test, dropping.&bslash;n&quot;
comma
id|physadr
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|notfound
suffix:semicolon
)brace
r_for
c_loop
(paren
id|mtd
op_assign
id|doclist
suffix:semicolon
id|mtd
suffix:semicolon
id|mtd
op_assign
id|doc-&gt;nextdoc
)paren
(brace
r_int
r_char
id|oldval
suffix:semicolon
r_int
r_char
id|newval
suffix:semicolon
id|nand
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|doc
op_assign
(paren
r_void
op_star
)paren
id|nand-&gt;priv
suffix:semicolon
multiline_comment|/* Use the alias resolution register to determine if this is&n;&t;&t;   in fact the same DOC aliased to a new address.  If writes&n;&t;&t;   to one chip&squot;s alias resolution register change the value on&n;&t;&t;   the other chip, they&squot;re the same chip. */
r_if
c_cond
(paren
id|ChipID
op_eq
id|DOC_ChipID_DocMilPlus16
)paren
(brace
id|oldval
op_assign
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|Mplus_AliasResolution
)paren
suffix:semicolon
id|newval
op_assign
id|ReadDOC
c_func
(paren
id|virtadr
comma
id|Mplus_AliasResolution
)paren
suffix:semicolon
)brace
r_else
(brace
id|oldval
op_assign
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|AliasResolution
)paren
suffix:semicolon
id|newval
op_assign
id|ReadDOC
c_func
(paren
id|virtadr
comma
id|AliasResolution
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|oldval
op_ne
id|newval
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ChipID
op_eq
id|DOC_ChipID_DocMilPlus16
)paren
(brace
id|WriteDOC
c_func
(paren
op_complement
id|newval
comma
id|virtadr
comma
id|Mplus_AliasResolution
)paren
suffix:semicolon
id|oldval
op_assign
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|Mplus_AliasResolution
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|newval
comma
id|virtadr
comma
id|Mplus_AliasResolution
)paren
suffix:semicolon
singleline_comment|// restore it
)brace
r_else
(brace
id|WriteDOC
c_func
(paren
op_complement
id|newval
comma
id|virtadr
comma
id|AliasResolution
)paren
suffix:semicolon
id|oldval
op_assign
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|AliasResolution
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|newval
comma
id|virtadr
comma
id|AliasResolution
)paren
suffix:semicolon
singleline_comment|// restore it
)brace
id|newval
op_assign
op_complement
id|newval
suffix:semicolon
r_if
c_cond
(paren
id|oldval
op_eq
id|newval
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Found alias of DOC at 0x%lx to 0x%lx&bslash;n&quot;
comma
id|doc-&gt;physadr
comma
id|physadr
)paren
suffix:semicolon
r_goto
id|notfound
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;DiskOnChip found at 0x%lx&bslash;n&quot;
comma
id|physadr
)paren
suffix:semicolon
id|len
op_assign
r_sizeof
(paren
r_struct
id|mtd_info
)paren
op_plus
r_sizeof
(paren
r_struct
id|nand_chip
)paren
op_plus
r_sizeof
(paren
r_struct
id|doc_priv
)paren
op_plus
(paren
l_int|2
op_star
r_sizeof
(paren
r_struct
id|nand_bbt_descr
)paren
)paren
suffix:semicolon
id|mtd
op_assign
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mtd
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;DiskOnChip kmalloc (%d bytes) failed!&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|memset
c_func
(paren
id|mtd
comma
l_int|0
comma
id|len
)paren
suffix:semicolon
id|nand
op_assign
(paren
r_struct
id|nand_chip
op_star
)paren
(paren
id|mtd
op_plus
l_int|1
)paren
suffix:semicolon
id|doc
op_assign
(paren
r_struct
id|doc_priv
op_star
)paren
(paren
id|nand
op_plus
l_int|1
)paren
suffix:semicolon
id|nand-&gt;bbt_td
op_assign
(paren
r_struct
id|nand_bbt_descr
op_star
)paren
(paren
id|doc
op_plus
l_int|1
)paren
suffix:semicolon
id|nand-&gt;bbt_md
op_assign
id|nand-&gt;bbt_td
op_plus
l_int|1
suffix:semicolon
id|mtd-&gt;priv
op_assign
(paren
r_void
op_star
)paren
id|nand
suffix:semicolon
id|mtd-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|nand-&gt;priv
op_assign
(paren
r_void
op_star
)paren
id|doc
suffix:semicolon
id|nand-&gt;select_chip
op_assign
id|doc200x_select_chip
suffix:semicolon
id|nand-&gt;hwcontrol
op_assign
id|doc200x_hwcontrol
suffix:semicolon
id|nand-&gt;dev_ready
op_assign
id|doc200x_dev_ready
suffix:semicolon
id|nand-&gt;waitfunc
op_assign
id|doc200x_wait
suffix:semicolon
id|nand-&gt;block_bad
op_assign
id|doc200x_block_bad
suffix:semicolon
id|nand-&gt;enable_hwecc
op_assign
id|doc200x_enable_hwecc
suffix:semicolon
id|nand-&gt;calculate_ecc
op_assign
id|doc200x_calculate_ecc
suffix:semicolon
id|nand-&gt;correct_data
op_assign
id|doc200x_correct_data
suffix:semicolon
id|nand-&gt;autooob
op_assign
op_amp
id|doc200x_oobinfo
suffix:semicolon
id|nand-&gt;eccmode
op_assign
id|NAND_ECC_HW6_512
suffix:semicolon
id|nand-&gt;options
op_assign
id|NAND_USE_FLASH_BBT
op_or
id|NAND_HWECC_SYNDROME
suffix:semicolon
id|doc-&gt;physadr
op_assign
id|physadr
suffix:semicolon
id|doc-&gt;virtadr
op_assign
id|virtadr
suffix:semicolon
id|doc-&gt;ChipID
op_assign
id|ChipID
suffix:semicolon
id|doc-&gt;curfloor
op_assign
op_minus
l_int|1
suffix:semicolon
id|doc-&gt;curchip
op_assign
op_minus
l_int|1
suffix:semicolon
id|doc-&gt;mh0_page
op_assign
op_minus
l_int|1
suffix:semicolon
id|doc-&gt;mh1_page
op_assign
op_minus
l_int|1
suffix:semicolon
id|doc-&gt;nextdoc
op_assign
id|doclist
suffix:semicolon
r_if
c_cond
(paren
id|ChipID
op_eq
id|DOC_ChipID_Doc2k
)paren
id|numchips
op_assign
id|doc2000_init
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ChipID
op_eq
id|DOC_ChipID_DocMilPlus16
)paren
id|numchips
op_assign
id|doc2001plus_init
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_else
id|numchips
op_assign
id|doc2001_init
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|nand_scan
c_func
(paren
id|mtd
comma
id|numchips
)paren
)paren
)paren
(brace
multiline_comment|/* DBB note: i believe nand_release is necessary here, as&n;&t;&t;   buffers may have been allocated in nand_base.  Check with&n;&t;&t;   Thomas. FIX ME! */
multiline_comment|/* nand_release will call del_mtd_device, but we haven&squot;t yet&n;&t;&t;   added it.  This is handled without incident by&n;&t;&t;   del_mtd_device, as far as I can tell. */
id|nand_release
c_func
(paren
id|mtd
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
multiline_comment|/* Success! */
id|doclist
op_assign
id|mtd
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|notfound
suffix:colon
multiline_comment|/* Put back the contents of the DOCControl register, in case it&squot;s not&n;&t;   actually a DiskOnChip.  */
id|WriteDOC
c_func
(paren
id|save_control
comma
id|virtadr
comma
id|DOCControl
)paren
suffix:semicolon
id|fail
suffix:colon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|virtadr
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|release_nanddoc
r_static
r_void
id|release_nanddoc
c_func
(paren
r_void
)paren
(brace
r_struct
id|mtd_info
op_star
id|mtd
comma
op_star
id|nextmtd
suffix:semicolon
r_struct
id|nand_chip
op_star
id|nand
suffix:semicolon
r_struct
id|doc_priv
op_star
id|doc
suffix:semicolon
r_for
c_loop
(paren
id|mtd
op_assign
id|doclist
suffix:semicolon
id|mtd
suffix:semicolon
id|mtd
op_assign
id|nextmtd
)paren
(brace
id|nand
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|doc
op_assign
(paren
r_void
op_star
)paren
id|nand-&gt;priv
suffix:semicolon
id|nextmtd
op_assign
id|doc-&gt;nextdoc
suffix:semicolon
id|nand_release
c_func
(paren
id|mtd
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|doc-&gt;virtadr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mtd
)paren
suffix:semicolon
)brace
)brace
DECL|function|init_nanddoc
r_static
r_int
id|__init
id|init_nanddoc
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We could create the decoder on demand, if memory is a concern.&n;&t; * This way we have it handy, if an error happens &n;&t; *&n;&t; * Symbolsize is 10 (bits)&n;&t; * Primitve polynomial is x^10+x^3+1&n;&t; * first consecutive root is 510&n;&t; * primitve element to generate roots = 1&n;&t; * generator polinomial degree = 4&n;&t; */
id|rs_decoder
op_assign
id|init_rs
c_func
(paren
l_int|10
comma
l_int|0x409
comma
id|FCR
comma
l_int|1
comma
id|NROOTS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rs_decoder
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;DiskOnChip: Could not create a RS decoder&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|doc_config_location
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Using configured DiskOnChip probe address 0x%lx&bslash;n&quot;
comma
id|doc_config_location
)paren
suffix:semicolon
id|ret
op_assign
id|doc_probe
c_func
(paren
id|doc_config_location
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|outerr
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|doc_locations
(braket
id|i
)braket
op_ne
l_int|0xffffffff
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|doc_probe
c_func
(paren
id|doc_locations
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* No banner message any more. Print a message if no DiskOnChip&n;&t;   found, so the user knows we at least tried. */
r_if
c_cond
(paren
op_logical_neg
id|doclist
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;No valid DiskOnChip devices found&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|outerr
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|outerr
suffix:colon
id|free_rs
c_func
(paren
id|rs_decoder
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|cleanup_nanddoc
r_static
r_void
id|__exit
id|cleanup_nanddoc
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Cleanup the nand/DoC resources */
id|release_nanddoc
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Free the reed solomon resources */
r_if
c_cond
(paren
id|rs_decoder
)paren
(brace
id|free_rs
c_func
(paren
id|rs_decoder
)paren
suffix:semicolon
)brace
)brace
DECL|variable|init_nanddoc
id|module_init
c_func
(paren
id|init_nanddoc
)paren
suffix:semicolon
DECL|variable|cleanup_nanddoc
id|module_exit
c_func
(paren
id|cleanup_nanddoc
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;David Woodhouse &lt;dwmw2@infradead.org&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;M-Systems DiskOnChip 2000, Millennium and Millennium Plus device driver&bslash;n&quot;
)paren
suffix:semicolon
eof
