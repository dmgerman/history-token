multiline_comment|/*&n; * NAND flash simulator.&n; *&n; * Author: Artem B. Bityuckiy &lt;dedekind@oktetlabs.ru&gt;, &lt;dedekind@infradead.org&gt;&n; *&n; * Copyright (C) 2004 Nokia Corporation &n; *&n; * Note: NS means &quot;NAND Simulator&quot;.&n; * Note: Input means input TO flash chip, output means output FROM chip.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any later&n; * version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General&n; * Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA&n; *&n; * $Id: nandsim.c,v 1.3 2004/11/26 13:00:24 dedekind Exp $&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/mtd/nand.h&gt;
macro_line|#include &lt;linux/mtd/partitions.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#ifdef CONFIG_NS_ABS_POS
macro_line|#include &lt;asm/io.h&gt;
macro_line|#endif
multiline_comment|/* Default simulator parameters values */
macro_line|#if !defined(CONFIG_NANDSIM_FIRST_ID_BYTE)  || &bslash;&n;    !defined(CONFIG_NANDSIM_SECOND_ID_BYTE) || &bslash;&n;    !defined(CONFIG_NANDSIM_THIRD_ID_BYTE)  || &bslash;&n;    !defined(CONFIG_NANDSIM_FOURTH_ID_BYTE)
DECL|macro|CONFIG_NANDSIM_FIRST_ID_BYTE
mdefine_line|#define CONFIG_NANDSIM_FIRST_ID_BYTE  0x98
DECL|macro|CONFIG_NANDSIM_SECOND_ID_BYTE
mdefine_line|#define CONFIG_NANDSIM_SECOND_ID_BYTE 0x36
DECL|macro|CONFIG_NANDSIM_THIRD_ID_BYTE
mdefine_line|#define CONFIG_NANDSIM_THIRD_ID_BYTE  0xFF /* No byte */
DECL|macro|CONFIG_NANDSIM_FOURTH_ID_BYTE
mdefine_line|#define CONFIG_NANDSIM_FOURTH_ID_BYTE 0xFF /* No byte */
macro_line|#endif
macro_line|#ifndef CONFIG_NANDSIM_ACCESS_DELAY
DECL|macro|CONFIG_NANDSIM_ACCESS_DELAY
mdefine_line|#define CONFIG_NANDSIM_ACCESS_DELAY 25
macro_line|#endif
macro_line|#ifndef CONFIG_NANDSIM_PROGRAMM_DELAY
DECL|macro|CONFIG_NANDSIM_PROGRAMM_DELAY
mdefine_line|#define CONFIG_NANDSIM_PROGRAMM_DELAY 200
macro_line|#endif
macro_line|#ifndef CONFIG_NANDSIM_ERASE_DELAY
DECL|macro|CONFIG_NANDSIM_ERASE_DELAY
mdefine_line|#define CONFIG_NANDSIM_ERASE_DELAY 2
macro_line|#endif
macro_line|#ifndef CONFIG_NANDSIM_OUTPUT_CYCLE
DECL|macro|CONFIG_NANDSIM_OUTPUT_CYCLE
mdefine_line|#define CONFIG_NANDSIM_OUTPUT_CYCLE 40
macro_line|#endif
macro_line|#ifndef CONFIG_NANDSIM_INPUT_CYCLE
DECL|macro|CONFIG_NANDSIM_INPUT_CYCLE
mdefine_line|#define CONFIG_NANDSIM_INPUT_CYCLE  50
macro_line|#endif
macro_line|#ifndef CONFIG_NANDSIM_BUS_WIDTH
DECL|macro|CONFIG_NANDSIM_BUS_WIDTH
mdefine_line|#define CONFIG_NANDSIM_BUS_WIDTH  8
macro_line|#endif
macro_line|#ifndef CONFIG_NANDSIM_DO_DELAYS
DECL|macro|CONFIG_NANDSIM_DO_DELAYS
mdefine_line|#define CONFIG_NANDSIM_DO_DELAYS  0
macro_line|#endif
macro_line|#ifndef CONFIG_NANDSIM_LOG
DECL|macro|CONFIG_NANDSIM_LOG
mdefine_line|#define CONFIG_NANDSIM_LOG        0
macro_line|#endif
macro_line|#ifndef CONFIG_NANDSIM_DBG
DECL|macro|CONFIG_NANDSIM_DBG
mdefine_line|#define CONFIG_NANDSIM_DBG        0
macro_line|#endif
DECL|variable|first_id_byte
r_static
id|uint
id|first_id_byte
op_assign
id|CONFIG_NANDSIM_FIRST_ID_BYTE
suffix:semicolon
DECL|variable|second_id_byte
r_static
id|uint
id|second_id_byte
op_assign
id|CONFIG_NANDSIM_SECOND_ID_BYTE
suffix:semicolon
DECL|variable|third_id_byte
r_static
id|uint
id|third_id_byte
op_assign
id|CONFIG_NANDSIM_THIRD_ID_BYTE
suffix:semicolon
DECL|variable|fourth_id_byte
r_static
id|uint
id|fourth_id_byte
op_assign
id|CONFIG_NANDSIM_FOURTH_ID_BYTE
suffix:semicolon
DECL|variable|access_delay
r_static
id|uint
id|access_delay
op_assign
id|CONFIG_NANDSIM_ACCESS_DELAY
suffix:semicolon
DECL|variable|programm_delay
r_static
id|uint
id|programm_delay
op_assign
id|CONFIG_NANDSIM_PROGRAMM_DELAY
suffix:semicolon
DECL|variable|erase_delay
r_static
id|uint
id|erase_delay
op_assign
id|CONFIG_NANDSIM_ERASE_DELAY
suffix:semicolon
DECL|variable|output_cycle
r_static
id|uint
id|output_cycle
op_assign
id|CONFIG_NANDSIM_OUTPUT_CYCLE
suffix:semicolon
DECL|variable|input_cycle
r_static
id|uint
id|input_cycle
op_assign
id|CONFIG_NANDSIM_INPUT_CYCLE
suffix:semicolon
DECL|variable|bus_width
r_static
id|uint
id|bus_width
op_assign
id|CONFIG_NANDSIM_BUS_WIDTH
suffix:semicolon
DECL|variable|do_delays
r_static
id|uint
id|do_delays
op_assign
id|CONFIG_NANDSIM_DO_DELAYS
suffix:semicolon
DECL|variable|log
r_static
id|uint
id|log
op_assign
id|CONFIG_NANDSIM_LOG
suffix:semicolon
DECL|variable|dbg
r_static
id|uint
id|dbg
op_assign
id|CONFIG_NANDSIM_DBG
suffix:semicolon
id|module_param
c_func
(paren
id|first_id_byte
comma
id|uint
comma
l_int|0400
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|second_id_byte
comma
id|uint
comma
l_int|0400
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|third_id_byte
comma
id|uint
comma
l_int|0400
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|fourth_id_byte
comma
id|uint
comma
l_int|0400
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|access_delay
comma
id|uint
comma
l_int|0400
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|programm_delay
comma
id|uint
comma
l_int|0400
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|erase_delay
comma
id|uint
comma
l_int|0400
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|output_cycle
comma
id|uint
comma
l_int|0400
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|input_cycle
comma
id|uint
comma
l_int|0400
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|bus_width
comma
id|uint
comma
l_int|0400
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|do_delays
comma
id|uint
comma
l_int|0400
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|log
comma
id|uint
comma
l_int|0400
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|dbg
comma
id|uint
comma
l_int|0400
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|first_id_byte
comma
l_string|&quot;The fist byte returned by NAND Flash &squot;read ID&squot; command (manufaturer ID)&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|second_id_byte
comma
l_string|&quot;The second byte returned by NAND Flash &squot;read ID&squot; command (chip ID)&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|third_id_byte
comma
l_string|&quot;The third byte returned by NAND Flash &squot;read ID&squot; command&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|fourth_id_byte
comma
l_string|&quot;The fourth byte returned by NAND Flash &squot;read ID&squot; command&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|access_delay
comma
l_string|&quot;Initial page access delay (microiseconds)&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|programm_delay
comma
l_string|&quot;Page programm delay (microseconds&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|erase_delay
comma
l_string|&quot;Sector erase delay (milliseconds)&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|output_cycle
comma
l_string|&quot;Word output (from flash) time (nanodeconds)&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|input_cycle
comma
l_string|&quot;Word input (to flash) time (nanodeconds)&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|bus_width
comma
l_string|&quot;Chip&squot;s bus width (8- or 16-bit)&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|do_delays
comma
l_string|&quot;Simulate NAND delays using busy-waits if not zero&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|log
comma
l_string|&quot;Perform logging if not zero&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|dbg
comma
l_string|&quot;Output debug information if not zero&quot;
)paren
suffix:semicolon
multiline_comment|/* &n; * There is no macro for 0x30 command which is used in &quot;large page&quot;&n; * devices in standard mtd header, define it here. &n; */
DECL|macro|NAND_CMD_READ2LP
mdefine_line|#define NAND_CMD_READ2LP 0x30
multiline_comment|/* The largest possible page size */
DECL|macro|NS_LARGEST_PAGE_SIZE
mdefine_line|#define NS_LARGEST_PAGE_SIZE&t;2048
multiline_comment|/* The prefix for simulator output */
DECL|macro|NS_OUTPUT_PREFIX
mdefine_line|#define NS_OUTPUT_PREFIX &quot;[nandsim]&quot;
multiline_comment|/* Simulator&squot;s output macros (logging, debugging, warning, error) */
DECL|macro|NS_LOG
mdefine_line|#define NS_LOG(args...) &bslash;&n;&t;do { if (log) printk(KERN_INFO NS_OUTPUT_PREFIX &quot; log: &quot; args); } while(0)
DECL|macro|NS_DBG
mdefine_line|#define NS_DBG(args...) &bslash;&n;&t;do { if (dbg) printk(KERN_INFO NS_OUTPUT_PREFIX &quot; debug: &quot; args); } while(0)
DECL|macro|NS_WARN
mdefine_line|#define NS_WARN(args...) &bslash;&n;&t;do { printk(KERN_INFO NS_OUTPUT_PREFIX &quot; warnig: &quot; args); } while(0)
DECL|macro|NS_ERR
mdefine_line|#define NS_ERR(args...) &bslash;&n;&t;do { printk(KERN_INFO NS_OUTPUT_PREFIX &quot; errorr: &quot; args); } while(0)
multiline_comment|/* Busy-wait delay macros (microseconds, milliseconds) */
DECL|macro|NS_UDELAY
mdefine_line|#define NS_UDELAY(us) &bslash;&n;        do { if (do_delays) udelay(us); } while(0)
DECL|macro|NS_MDELAY
mdefine_line|#define NS_MDELAY(us) &bslash;&n;        do { if (do_delays) mdelay(us); } while(0)
multiline_comment|/* Is the nandsim structure initialized ? */
DECL|macro|NS_IS_INITIALIZED
mdefine_line|#define NS_IS_INITIALIZED(ns) ((ns)-&gt;geom.totsz != 0)
multiline_comment|/* Good operation completion status */
DECL|macro|NS_STATUS_OK
mdefine_line|#define NS_STATUS_OK(ns) (NAND_STATUS_READY | (NAND_STATUS_WP * ((ns)-&gt;lines.wp == 0)))
multiline_comment|/* Operation failed completion status */
DECL|macro|NS_STATUS_FAILED
mdefine_line|#define NS_STATUS_FAILED(ns) (NAND_STATUS_FAIL | NS_STATUS_OK(ns)) 
multiline_comment|/* Calculate the page offset in flash RAM image by (row, column) address */
DECL|macro|NS_RAW_OFFSET
mdefine_line|#define NS_RAW_OFFSET(ns) &bslash;&n;&t;(((ns)-&gt;regs.row &lt;&lt; (ns)-&gt;geom.pgshift) + ((ns)-&gt;regs.row * (ns)-&gt;geom.oobsz) + (ns)-&gt;regs.column)
multiline_comment|/* Calculate the OOB offset in flash RAM image by (row, column) address */
DECL|macro|NS_RAW_OFFSET_OOB
mdefine_line|#define NS_RAW_OFFSET_OOB(ns) (NS_RAW_OFFSET(ns) + ns-&gt;geom.pgsz)
multiline_comment|/* After a command is input, the simulator goes to one of the following states */
DECL|macro|STATE_CMD_READ0
mdefine_line|#define STATE_CMD_READ0        0x00000001 /* read data from the beginning of page */
DECL|macro|STATE_CMD_READ1
mdefine_line|#define STATE_CMD_READ1        0x00000002 /* read data from the second half of page */
DECL|macro|STATE_CMD_READ2LP
mdefine_line|#define STATE_CMD_READ2LP      0x00000003 /* read data second command (large page devices) */
DECL|macro|STATE_CMD_PAGEPROG
mdefine_line|#define STATE_CMD_PAGEPROG     0x00000004 /* start page programm */
DECL|macro|STATE_CMD_READOOB
mdefine_line|#define STATE_CMD_READOOB      0x00000005 /* read OOB area */
DECL|macro|STATE_CMD_ERASE1
mdefine_line|#define STATE_CMD_ERASE1       0x00000006 /* sector erase first command */
DECL|macro|STATE_CMD_STATUS
mdefine_line|#define STATE_CMD_STATUS       0x00000007 /* read status */
DECL|macro|STATE_CMD_STATUS_M
mdefine_line|#define STATE_CMD_STATUS_M     0x00000008 /* read multi-plane status (isn&squot;t implemented) */
DECL|macro|STATE_CMD_SEQIN
mdefine_line|#define STATE_CMD_SEQIN        0x00000009 /* sequential data imput */
DECL|macro|STATE_CMD_READID
mdefine_line|#define STATE_CMD_READID       0x0000000A /* read ID */
DECL|macro|STATE_CMD_ERASE2
mdefine_line|#define STATE_CMD_ERASE2       0x0000000B /* sector erase second command */
DECL|macro|STATE_CMD_RESET
mdefine_line|#define STATE_CMD_RESET        0x0000000C /* reset */
DECL|macro|STATE_CMD_MASK
mdefine_line|#define STATE_CMD_MASK         0x0000000F /* command states mask */
multiline_comment|/* After an addres is input, the simulator goes to one of these states */
DECL|macro|STATE_ADDR_PAGE
mdefine_line|#define STATE_ADDR_PAGE        0x00000010 /* full (row, column) address is accepted */
DECL|macro|STATE_ADDR_SEC
mdefine_line|#define STATE_ADDR_SEC         0x00000020 /* sector address was accepted */
DECL|macro|STATE_ADDR_ZERO
mdefine_line|#define STATE_ADDR_ZERO        0x00000030 /* one byte zero address was accepted */
DECL|macro|STATE_ADDR_MASK
mdefine_line|#define STATE_ADDR_MASK        0x00000030 /* address states mask */
multiline_comment|/* Durind data input/output the simulator is in these states */
DECL|macro|STATE_DATAIN
mdefine_line|#define STATE_DATAIN           0x00000100 /* waiting for data input */
DECL|macro|STATE_DATAIN_MASK
mdefine_line|#define STATE_DATAIN_MASK      0x00000100 /* data input states mask */
DECL|macro|STATE_DATAOUT
mdefine_line|#define STATE_DATAOUT          0x00001000 /* waiting for page data output */
DECL|macro|STATE_DATAOUT_ID
mdefine_line|#define STATE_DATAOUT_ID       0x00002000 /* waiting for ID bytes output */
DECL|macro|STATE_DATAOUT_STATUS
mdefine_line|#define STATE_DATAOUT_STATUS   0x00003000 /* waiting for status output */
DECL|macro|STATE_DATAOUT_STATUS_M
mdefine_line|#define STATE_DATAOUT_STATUS_M 0x00004000 /* waiting for multi-plane status output */
DECL|macro|STATE_DATAOUT_MASK
mdefine_line|#define STATE_DATAOUT_MASK     0x00007000 /* data output states mask */
multiline_comment|/* Previous operation is done, ready to accept new requests */
DECL|macro|STATE_READY
mdefine_line|#define STATE_READY            0x00000000
multiline_comment|/* This state is used to mark that the next state isn&squot;t known yet */
DECL|macro|STATE_UNKNOWN
mdefine_line|#define STATE_UNKNOWN          0x10000000
multiline_comment|/* Simulator&squot;s actions bit masks */
DECL|macro|ACTION_CPY
mdefine_line|#define ACTION_CPY       0x00100000 /* copy page/OOB to the internal buffer */
DECL|macro|ACTION_PRGPAGE
mdefine_line|#define ACTION_PRGPAGE   0x00200000 /* programm the internal buffer to flash */
DECL|macro|ACTION_SECERASE
mdefine_line|#define ACTION_SECERASE  0x00300000 /* erase sector */
DECL|macro|ACTION_ZEROOFF
mdefine_line|#define ACTION_ZEROOFF   0x00400000 /* don&squot;t add any offset to address */
DECL|macro|ACTION_HALFOFF
mdefine_line|#define ACTION_HALFOFF   0x00500000 /* add to address half of page */
DECL|macro|ACTION_OOBOFF
mdefine_line|#define ACTION_OOBOFF    0x00600000 /* add to address OOB offset */
DECL|macro|ACTION_MASK
mdefine_line|#define ACTION_MASK      0x00700000 /* action mask */
DECL|macro|NS_OPER_NUM
mdefine_line|#define NS_OPER_NUM      12 /* Number of operations supported by the simulator */
DECL|macro|NS_OPER_STATES
mdefine_line|#define NS_OPER_STATES   6  /* Maximum number of states in operation */
DECL|macro|OPT_ANY
mdefine_line|#define OPT_ANY          0xFFFFFFFF /* any chip supports this operation */
DECL|macro|OPT_PAGE256
mdefine_line|#define OPT_PAGE256      0x00000001 /* 256-byte  page chips */
DECL|macro|OPT_PAGE512
mdefine_line|#define OPT_PAGE512      0x00000002 /* 512-byte  page chips */
DECL|macro|OPT_PAGE2048
mdefine_line|#define OPT_PAGE2048     0x00000008 /* 2048-byte page chips */
DECL|macro|OPT_SMARTMEDIA
mdefine_line|#define OPT_SMARTMEDIA   0x00000010 /* SmartMedia technology chips */
DECL|macro|OPT_AUTOINCR
mdefine_line|#define OPT_AUTOINCR     0x00000020 /* page number auto inctimentation is possible */
DECL|macro|OPT_PAGE512_8BIT
mdefine_line|#define OPT_PAGE512_8BIT 0x00000040 /* 512-byte page chips with 8-bit bus width */
DECL|macro|OPT_LARGEPAGE
mdefine_line|#define OPT_LARGEPAGE    (OPT_PAGE2048) /* 2048-byte page chips */
DECL|macro|OPT_SMALLPAGE
mdefine_line|#define OPT_SMALLPAGE    (OPT_PAGE256  | OPT_PAGE512)  /* 256 and 512-byte page chips */
multiline_comment|/* Remove action bits ftom state */
DECL|macro|NS_STATE
mdefine_line|#define NS_STATE(x) ((x) &amp; ~ACTION_MASK)
multiline_comment|/* &n; * Maximum previous states which need to be saved. Currently saving is&n; * only needed for page programm operation with preceeded read command&n; * (which is only valid for 512-byte pages).&n; */
DECL|macro|NS_MAX_PREVSTATES
mdefine_line|#define NS_MAX_PREVSTATES 1
multiline_comment|/* &n; * The structure which describes all the internal simulator data.&n; */
DECL|struct|nandsim
r_struct
id|nandsim
(brace
DECL|member|part
r_struct
id|mtd_partition
id|part
suffix:semicolon
DECL|member|busw
id|uint
id|busw
suffix:semicolon
multiline_comment|/* flash chip bus width (8 or 16) */
DECL|member|ids
id|u_char
id|ids
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* chip&squot;s ID bytes */
DECL|member|options
r_uint32
id|options
suffix:semicolon
multiline_comment|/* chip&squot;s characteristic bits */
DECL|member|state
r_uint32
id|state
suffix:semicolon
multiline_comment|/* current chip state */
DECL|member|nxstate
r_uint32
id|nxstate
suffix:semicolon
multiline_comment|/* next expected state */
DECL|member|op
r_uint32
op_star
id|op
suffix:semicolon
multiline_comment|/* current operation, NULL operations isn&squot;t known yet  */
DECL|member|pstates
r_uint32
id|pstates
(braket
id|NS_MAX_PREVSTATES
)braket
suffix:semicolon
multiline_comment|/* previous states */
DECL|member|npstates
r_uint16
id|npstates
suffix:semicolon
multiline_comment|/* number of previous states saved */
DECL|member|stateidx
r_uint16
id|stateidx
suffix:semicolon
multiline_comment|/* current state index */
multiline_comment|/* The simulated NAND flash image */
DECL|union|flash_media
r_union
id|flash_media
(brace
DECL|member|byte
id|u_char
op_star
id|byte
suffix:semicolon
DECL|member|word
r_uint16
op_star
id|word
suffix:semicolon
DECL|member|mem
)brace
id|mem
suffix:semicolon
multiline_comment|/* Internal buffer of page + OOB size bytes */
DECL|union|internal_buffer
r_union
id|internal_buffer
(brace
DECL|member|byte
id|u_char
op_star
id|byte
suffix:semicolon
multiline_comment|/* for byte access */
DECL|member|word
r_uint16
op_star
id|word
suffix:semicolon
multiline_comment|/* for 16-bit word access */
DECL|member|buf
)brace
id|buf
suffix:semicolon
multiline_comment|/* NAND flash &quot;geometry&quot; */
DECL|struct|nandsin_geometry
r_struct
id|nandsin_geometry
(brace
DECL|member|totsz
r_uint32
id|totsz
suffix:semicolon
multiline_comment|/* total flash size, bytes */
DECL|member|secsz
r_uint32
id|secsz
suffix:semicolon
multiline_comment|/* flash sector (erase block) size, bytes */
DECL|member|pgsz
id|uint
id|pgsz
suffix:semicolon
multiline_comment|/* NAND flash page size, bytes */
DECL|member|oobsz
id|uint
id|oobsz
suffix:semicolon
multiline_comment|/* page OOB area size, bytes */
DECL|member|totszoob
r_uint32
id|totszoob
suffix:semicolon
multiline_comment|/* total flash size including OOB, bytes */
DECL|member|pgszoob
id|uint
id|pgszoob
suffix:semicolon
multiline_comment|/* page size including OOB , bytes*/
DECL|member|secszoob
id|uint
id|secszoob
suffix:semicolon
multiline_comment|/* sector size including OOB, bytes */
DECL|member|pgnum
id|uint
id|pgnum
suffix:semicolon
multiline_comment|/* total number of pages */
DECL|member|pgsec
id|uint
id|pgsec
suffix:semicolon
multiline_comment|/* number of pages per sector */
DECL|member|secshift
id|uint
id|secshift
suffix:semicolon
multiline_comment|/* bits number in sector size */
DECL|member|pgshift
id|uint
id|pgshift
suffix:semicolon
multiline_comment|/* bits number in page size */
DECL|member|oobshift
id|uint
id|oobshift
suffix:semicolon
multiline_comment|/* bits number in OOB size */
DECL|member|pgaddrbytes
id|uint
id|pgaddrbytes
suffix:semicolon
multiline_comment|/* bytes per page address */
DECL|member|secaddrbytes
id|uint
id|secaddrbytes
suffix:semicolon
multiline_comment|/* bytes per sector address */
DECL|member|idbytes
id|uint
id|idbytes
suffix:semicolon
multiline_comment|/* the number ID bytes that this chip outputs */
DECL|member|geom
)brace
id|geom
suffix:semicolon
multiline_comment|/* NAND flash internal registers */
DECL|struct|nandsim_regs
r_struct
id|nandsim_regs
(brace
DECL|member|command
r_int
id|command
suffix:semicolon
multiline_comment|/* the command register */
DECL|member|status
id|u_char
id|status
suffix:semicolon
multiline_comment|/* the status register */
DECL|member|row
id|uint
id|row
suffix:semicolon
multiline_comment|/* the page number */
DECL|member|column
id|uint
id|column
suffix:semicolon
multiline_comment|/* the offset within page */
DECL|member|count
id|uint
id|count
suffix:semicolon
multiline_comment|/* internal counter */
DECL|member|num
id|uint
id|num
suffix:semicolon
multiline_comment|/* number of bytes which must be processed */
DECL|member|off
id|uint
id|off
suffix:semicolon
multiline_comment|/* fixed page offset */
DECL|member|regs
)brace
id|regs
suffix:semicolon
multiline_comment|/* NAND flash lines state */
DECL|struct|ns_lines_status
r_struct
id|ns_lines_status
(brace
DECL|member|ce
r_int
id|ce
suffix:semicolon
multiline_comment|/* chip Enable */
DECL|member|cle
r_int
id|cle
suffix:semicolon
multiline_comment|/* command Latch Enable */
DECL|member|ale
r_int
id|ale
suffix:semicolon
multiline_comment|/* address Latch Enable */
DECL|member|wp
r_int
id|wp
suffix:semicolon
multiline_comment|/* write Protect */
DECL|member|lines
)brace
id|lines
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Operations array. To perform any operation the simulator must pass&n; * through the correspondent states chain.&n; */
DECL|struct|nandsim_operations
r_static
r_struct
id|nandsim_operations
(brace
DECL|member|reqopts
r_uint32
id|reqopts
suffix:semicolon
multiline_comment|/* options which are required to perform the operation */
DECL|member|states
r_uint32
id|states
(braket
id|NS_OPER_STATES
)braket
suffix:semicolon
multiline_comment|/* operation&squot;s states */
DECL|variable|ops
)brace
id|ops
(braket
id|NS_OPER_NUM
)braket
op_assign
(brace
multiline_comment|/* Read page + OOB from the beginning */
(brace
id|OPT_SMALLPAGE
comma
(brace
id|STATE_CMD_READ0
op_or
id|ACTION_ZEROOFF
comma
id|STATE_ADDR_PAGE
op_or
id|ACTION_CPY
comma
id|STATE_DATAOUT
comma
id|STATE_READY
)brace
)brace
comma
multiline_comment|/* Read page + OOB from the second half */
(brace
id|OPT_PAGE512_8BIT
comma
(brace
id|STATE_CMD_READ1
op_or
id|ACTION_HALFOFF
comma
id|STATE_ADDR_PAGE
op_or
id|ACTION_CPY
comma
id|STATE_DATAOUT
comma
id|STATE_READY
)brace
)brace
comma
multiline_comment|/* Read OOB */
(brace
id|OPT_SMALLPAGE
comma
(brace
id|STATE_CMD_READOOB
op_or
id|ACTION_OOBOFF
comma
id|STATE_ADDR_PAGE
op_or
id|ACTION_CPY
comma
id|STATE_DATAOUT
comma
id|STATE_READY
)brace
)brace
comma
multiline_comment|/* Programm page starting from the beginning */
(brace
id|OPT_ANY
comma
(brace
id|STATE_CMD_SEQIN
comma
id|STATE_ADDR_PAGE
comma
id|STATE_DATAIN
comma
id|STATE_CMD_PAGEPROG
op_or
id|ACTION_PRGPAGE
comma
id|STATE_READY
)brace
)brace
comma
multiline_comment|/* Programm page starting from the beginning */
(brace
id|OPT_SMALLPAGE
comma
(brace
id|STATE_CMD_READ0
comma
id|STATE_CMD_SEQIN
op_or
id|ACTION_ZEROOFF
comma
id|STATE_ADDR_PAGE
comma
id|STATE_DATAIN
comma
id|STATE_CMD_PAGEPROG
op_or
id|ACTION_PRGPAGE
comma
id|STATE_READY
)brace
)brace
comma
multiline_comment|/* Programm page starting from the second half */
(brace
id|OPT_PAGE512
comma
(brace
id|STATE_CMD_READ1
comma
id|STATE_CMD_SEQIN
op_or
id|ACTION_HALFOFF
comma
id|STATE_ADDR_PAGE
comma
id|STATE_DATAIN
comma
id|STATE_CMD_PAGEPROG
op_or
id|ACTION_PRGPAGE
comma
id|STATE_READY
)brace
)brace
comma
multiline_comment|/* Programm OOB */
(brace
id|OPT_SMALLPAGE
comma
(brace
id|STATE_CMD_READOOB
comma
id|STATE_CMD_SEQIN
op_or
id|ACTION_OOBOFF
comma
id|STATE_ADDR_PAGE
comma
id|STATE_DATAIN
comma
id|STATE_CMD_PAGEPROG
op_or
id|ACTION_PRGPAGE
comma
id|STATE_READY
)brace
)brace
comma
multiline_comment|/* Erase sector */
(brace
id|OPT_ANY
comma
(brace
id|STATE_CMD_ERASE1
comma
id|STATE_ADDR_SEC
comma
id|STATE_CMD_ERASE2
op_or
id|ACTION_SECERASE
comma
id|STATE_READY
)brace
)brace
comma
multiline_comment|/* Read status */
(brace
id|OPT_ANY
comma
(brace
id|STATE_CMD_STATUS
comma
id|STATE_DATAOUT_STATUS
comma
id|STATE_READY
)brace
)brace
comma
multiline_comment|/* Read multi-plane status */
(brace
id|OPT_SMARTMEDIA
comma
(brace
id|STATE_CMD_STATUS_M
comma
id|STATE_DATAOUT_STATUS_M
comma
id|STATE_READY
)brace
)brace
comma
multiline_comment|/* Read ID */
(brace
id|OPT_ANY
comma
(brace
id|STATE_CMD_READID
comma
id|STATE_ADDR_ZERO
comma
id|STATE_DATAOUT_ID
comma
id|STATE_READY
)brace
)brace
comma
multiline_comment|/* Large page devices read page */
(brace
id|OPT_LARGEPAGE
comma
(brace
id|STATE_CMD_READ0
comma
id|STATE_ADDR_PAGE
comma
id|STATE_CMD_READ2LP
op_or
id|ACTION_CPY
comma
id|STATE_DATAOUT
comma
id|STATE_READY
)brace
)brace
)brace
suffix:semicolon
multiline_comment|/* MTD structure for NAND controller */
DECL|variable|nsmtd
r_static
r_struct
id|mtd_info
op_star
id|nsmtd
suffix:semicolon
DECL|variable|ns_verify_buf
r_static
id|u_char
id|ns_verify_buf
(braket
id|NS_LARGEST_PAGE_SIZE
)braket
suffix:semicolon
multiline_comment|/*&n; * Initialize the nandsim structure.&n; *&n; * RETURNS: 0 if success, -ERRNO if failure.&n; */
r_static
r_int
DECL|function|init_nandsim
id|init_nandsim
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|chip
op_assign
(paren
r_struct
id|nand_chip
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|nandsim
op_star
id|ns
op_assign
(paren
r_struct
id|nandsim
op_star
)paren
(paren
id|chip-&gt;priv
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|NS_IS_INITIALIZED
c_func
(paren
id|ns
)paren
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;init_nandsim: nandsim is already initialized&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Force mtd to not do delays */
id|chip-&gt;chip_delay
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialize the NAND flash parameters */
id|ns-&gt;busw
op_assign
id|chip-&gt;options
op_amp
id|NAND_BUSWIDTH_16
ques
c_cond
l_int|16
suffix:colon
l_int|8
suffix:semicolon
id|ns-&gt;geom.totsz
op_assign
id|mtd-&gt;size
suffix:semicolon
id|ns-&gt;geom.pgsz
op_assign
id|mtd-&gt;oobblock
suffix:semicolon
id|ns-&gt;geom.oobsz
op_assign
id|mtd-&gt;oobsize
suffix:semicolon
id|ns-&gt;geom.secsz
op_assign
id|mtd-&gt;erasesize
suffix:semicolon
id|ns-&gt;geom.pgszoob
op_assign
id|ns-&gt;geom.pgsz
op_plus
id|ns-&gt;geom.oobsz
suffix:semicolon
id|ns-&gt;geom.pgnum
op_assign
id|ns-&gt;geom.totsz
op_div
id|ns-&gt;geom.pgsz
suffix:semicolon
id|ns-&gt;geom.totszoob
op_assign
id|ns-&gt;geom.totsz
op_plus
id|ns-&gt;geom.pgnum
op_star
id|ns-&gt;geom.oobsz
suffix:semicolon
id|ns-&gt;geom.secshift
op_assign
id|ffs
c_func
(paren
id|ns-&gt;geom.secsz
)paren
op_minus
l_int|1
suffix:semicolon
id|ns-&gt;geom.pgshift
op_assign
id|chip-&gt;page_shift
suffix:semicolon
id|ns-&gt;geom.oobshift
op_assign
id|ffs
c_func
(paren
id|ns-&gt;geom.oobsz
)paren
op_minus
l_int|1
suffix:semicolon
id|ns-&gt;geom.pgsec
op_assign
id|ns-&gt;geom.secsz
op_div
id|ns-&gt;geom.pgsz
suffix:semicolon
id|ns-&gt;geom.secszoob
op_assign
id|ns-&gt;geom.secsz
op_plus
id|ns-&gt;geom.oobsz
op_star
id|ns-&gt;geom.pgsec
suffix:semicolon
id|ns-&gt;options
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ns-&gt;geom.pgsz
op_eq
l_int|256
)paren
(brace
id|ns-&gt;options
op_or_assign
id|OPT_PAGE256
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ns-&gt;geom.pgsz
op_eq
l_int|512
)paren
(brace
id|ns-&gt;options
op_or_assign
(paren
id|OPT_PAGE512
op_or
id|OPT_AUTOINCR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ns-&gt;busw
op_eq
l_int|8
)paren
id|ns-&gt;options
op_or_assign
id|OPT_PAGE512_8BIT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ns-&gt;geom.pgsz
op_eq
l_int|2048
)paren
(brace
id|ns-&gt;options
op_or_assign
id|OPT_PAGE2048
suffix:semicolon
)brace
r_else
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;init_nandsim: unknown page size %u&bslash;n&quot;
comma
id|ns-&gt;geom.pgsz
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ns-&gt;options
op_amp
id|OPT_SMALLPAGE
)paren
(brace
r_if
c_cond
(paren
id|ns-&gt;geom.totsz
OL
(paren
l_int|64
op_lshift
l_int|20
)paren
)paren
(brace
id|ns-&gt;geom.pgaddrbytes
op_assign
l_int|3
suffix:semicolon
id|ns-&gt;geom.secaddrbytes
op_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|ns-&gt;geom.pgaddrbytes
op_assign
l_int|4
suffix:semicolon
id|ns-&gt;geom.secaddrbytes
op_assign
l_int|3
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|ns-&gt;geom.totsz
op_le
(paren
l_int|128
op_lshift
l_int|20
)paren
)paren
(brace
id|ns-&gt;geom.pgaddrbytes
op_assign
l_int|5
suffix:semicolon
id|ns-&gt;geom.secaddrbytes
op_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|ns-&gt;geom.pgaddrbytes
op_assign
l_int|5
suffix:semicolon
id|ns-&gt;geom.secaddrbytes
op_assign
l_int|3
suffix:semicolon
)brace
)brace
multiline_comment|/* Detect how many ID bytes the NAND chip outputs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|nand_flash_ids
(braket
id|i
)braket
dot
id|name
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|second_id_byte
op_ne
id|nand_flash_ids
(braket
id|i
)braket
dot
id|id
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|nand_flash_ids
(braket
id|i
)braket
dot
id|options
op_amp
id|NAND_NO_AUTOINCR
)paren
)paren
id|ns-&gt;options
op_or_assign
id|OPT_AUTOINCR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ns-&gt;busw
op_eq
l_int|16
)paren
id|NS_WARN
c_func
(paren
l_string|&quot;16-bit flashes support wasn&squot;t tested&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;flash size: %u MiB&bslash;n&quot;
comma
id|ns-&gt;geom.totsz
op_rshift
l_int|20
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;page size: %u bytes&bslash;n&quot;
comma
id|ns-&gt;geom.pgsz
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;OOB area size: %u bytes&bslash;n&quot;
comma
id|ns-&gt;geom.oobsz
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sector size: %u KiB&bslash;n&quot;
comma
id|ns-&gt;geom.secsz
op_rshift
l_int|10
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pages number: %u&bslash;n&quot;
comma
id|ns-&gt;geom.pgnum
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pages per sector: %u&bslash;n&quot;
comma
id|ns-&gt;geom.pgsec
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bus width: %u&bslash;n&quot;
comma
id|ns-&gt;busw
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bits in sector size: %u&bslash;n&quot;
comma
id|ns-&gt;geom.secshift
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bits in page size: %u&bslash;n&quot;
comma
id|ns-&gt;geom.pgshift
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bits in OOB size: %u&bslash;n&quot;
comma
id|ns-&gt;geom.oobshift
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;flash size with OOB: %u KiB&bslash;n&quot;
comma
id|ns-&gt;geom.totszoob
op_rshift
l_int|10
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;page address bytes: %u&bslash;n&quot;
comma
id|ns-&gt;geom.pgaddrbytes
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sector address bytes: %u&bslash;n&quot;
comma
id|ns-&gt;geom.secaddrbytes
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;options: %#x&bslash;n&quot;
comma
id|ns-&gt;options
)paren
suffix:semicolon
multiline_comment|/* Map / allocate and initialize the flash image */
macro_line|#ifdef CONFIG_NS_ABS_POS
id|ns-&gt;mem.byte
op_assign
id|ioremap
c_func
(paren
id|CONFIG_NS_ABS_POS
comma
id|ns-&gt;geom.totszoob
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ns-&gt;mem.byte
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;init_nandsim: failed to map the NAND flash image at address %p&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|CONFIG_NS_ABS_POS
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
macro_line|#else
id|ns-&gt;mem.byte
op_assign
id|vmalloc
c_func
(paren
id|ns-&gt;geom.totszoob
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ns-&gt;mem.byte
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;init_nandsim: unable to allocate %u bytes for flash image&bslash;n&quot;
comma
id|ns-&gt;geom.totszoob
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ns-&gt;mem.byte
comma
l_int|0xFF
comma
id|ns-&gt;geom.totszoob
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Allocate / initialize the internal buffer */
id|ns-&gt;buf.byte
op_assign
id|kmalloc
c_func
(paren
id|ns-&gt;geom.pgszoob
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ns-&gt;buf.byte
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;init_nandsim: unable to allocate %u bytes for the internal buffer&bslash;n&quot;
comma
id|ns-&gt;geom.pgszoob
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ns-&gt;buf.byte
comma
l_int|0xFF
comma
id|ns-&gt;geom.pgszoob
)paren
suffix:semicolon
multiline_comment|/* Fill the partition_info structure */
id|ns-&gt;part.name
op_assign
l_string|&quot;NAND simulator partition&quot;
suffix:semicolon
id|ns-&gt;part.offset
op_assign
l_int|0
suffix:semicolon
id|ns-&gt;part.size
op_assign
id|ns-&gt;geom.totsz
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error
suffix:colon
macro_line|#ifdef CONFIG_NS_ABS_POS
id|iounmap
c_func
(paren
id|ns-&gt;mem.byte
)paren
suffix:semicolon
macro_line|#else
id|vfree
c_func
(paren
id|ns-&gt;mem.byte
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * Free the nandsim structure.&n; */
r_static
r_void
DECL|function|free_nandsim
id|free_nandsim
c_func
(paren
r_struct
id|nandsim
op_star
id|ns
)paren
(brace
id|kfree
c_func
(paren
id|ns-&gt;buf.byte
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NS_ABS_POS
id|iounmap
c_func
(paren
id|ns-&gt;mem.byte
)paren
suffix:semicolon
macro_line|#else
id|vfree
c_func
(paren
id|ns-&gt;mem.byte
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns the string representation of &squot;state&squot; state.&n; */
r_static
r_char
op_star
DECL|function|get_state_name
id|get_state_name
c_func
(paren
r_uint32
id|state
)paren
(brace
r_switch
c_cond
(paren
id|NS_STATE
c_func
(paren
id|state
)paren
)paren
(brace
r_case
id|STATE_CMD_READ0
suffix:colon
r_return
l_string|&quot;STATE_CMD_READ0&quot;
suffix:semicolon
r_case
id|STATE_CMD_READ1
suffix:colon
r_return
l_string|&quot;STATE_CMD_READ1&quot;
suffix:semicolon
r_case
id|STATE_CMD_PAGEPROG
suffix:colon
r_return
l_string|&quot;STATE_CMD_PAGEPROG&quot;
suffix:semicolon
r_case
id|STATE_CMD_READOOB
suffix:colon
r_return
l_string|&quot;STATE_CMD_READOOB&quot;
suffix:semicolon
r_case
id|STATE_CMD_READ2LP
suffix:colon
r_return
l_string|&quot;STATE_CMD_READ2LP&quot;
suffix:semicolon
r_case
id|STATE_CMD_ERASE1
suffix:colon
r_return
l_string|&quot;STATE_CMD_ERASE1&quot;
suffix:semicolon
r_case
id|STATE_CMD_STATUS
suffix:colon
r_return
l_string|&quot;STATE_CMD_STATUS&quot;
suffix:semicolon
r_case
id|STATE_CMD_STATUS_M
suffix:colon
r_return
l_string|&quot;STATE_CMD_STATUS_M&quot;
suffix:semicolon
r_case
id|STATE_CMD_SEQIN
suffix:colon
r_return
l_string|&quot;STATE_CMD_SEQIN&quot;
suffix:semicolon
r_case
id|STATE_CMD_READID
suffix:colon
r_return
l_string|&quot;STATE_CMD_READID&quot;
suffix:semicolon
r_case
id|STATE_CMD_ERASE2
suffix:colon
r_return
l_string|&quot;STATE_CMD_ERASE2&quot;
suffix:semicolon
r_case
id|STATE_CMD_RESET
suffix:colon
r_return
l_string|&quot;STATE_CMD_RESET&quot;
suffix:semicolon
r_case
id|STATE_ADDR_PAGE
suffix:colon
r_return
l_string|&quot;STATE_ADDR_PAGE&quot;
suffix:semicolon
r_case
id|STATE_ADDR_SEC
suffix:colon
r_return
l_string|&quot;STATE_ADDR_SEC&quot;
suffix:semicolon
r_case
id|STATE_ADDR_ZERO
suffix:colon
r_return
l_string|&quot;STATE_ADDR_ZERO&quot;
suffix:semicolon
r_case
id|STATE_DATAIN
suffix:colon
r_return
l_string|&quot;STATE_DATAIN&quot;
suffix:semicolon
r_case
id|STATE_DATAOUT
suffix:colon
r_return
l_string|&quot;STATE_DATAOUT&quot;
suffix:semicolon
r_case
id|STATE_DATAOUT_ID
suffix:colon
r_return
l_string|&quot;STATE_DATAOUT_ID&quot;
suffix:semicolon
r_case
id|STATE_DATAOUT_STATUS
suffix:colon
r_return
l_string|&quot;STATE_DATAOUT_STATUS&quot;
suffix:semicolon
r_case
id|STATE_DATAOUT_STATUS_M
suffix:colon
r_return
l_string|&quot;STATE_DATAOUT_STATUS_M&quot;
suffix:semicolon
r_case
id|STATE_READY
suffix:colon
r_return
l_string|&quot;STATE_READY&quot;
suffix:semicolon
r_case
id|STATE_UNKNOWN
suffix:colon
r_return
l_string|&quot;STATE_UNKNOWN&quot;
suffix:semicolon
)brace
id|NS_ERR
c_func
(paren
l_string|&quot;get_state_name: unknown state, BUG&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Check if command is valid.&n; *&n; * RETURNS: 1 if wrong command, 0 if right.&n; */
r_static
r_int
DECL|function|check_command
id|check_command
c_func
(paren
r_int
id|cmd
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|NAND_CMD_READ0
suffix:colon
r_case
id|NAND_CMD_READ2LP
suffix:colon
r_case
id|NAND_CMD_PAGEPROG
suffix:colon
r_case
id|NAND_CMD_READOOB
suffix:colon
r_case
id|NAND_CMD_ERASE1
suffix:colon
r_case
id|NAND_CMD_STATUS
suffix:colon
r_case
id|NAND_CMD_SEQIN
suffix:colon
r_case
id|NAND_CMD_READID
suffix:colon
r_case
id|NAND_CMD_ERASE2
suffix:colon
r_case
id|NAND_CMD_RESET
suffix:colon
r_case
id|NAND_CMD_READ1
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|NAND_CMD_STATUS_MULTI
suffix:colon
r_default
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Returns state after command is accepted by command number.&n; */
r_static
r_uint32
DECL|function|get_state_by_command
id|get_state_by_command
c_func
(paren
r_int
id|command
)paren
(brace
r_switch
c_cond
(paren
id|command
)paren
(brace
r_case
id|NAND_CMD_READ0
suffix:colon
r_return
id|STATE_CMD_READ0
suffix:semicolon
r_case
id|NAND_CMD_READ1
suffix:colon
r_return
id|STATE_CMD_READ1
suffix:semicolon
r_case
id|NAND_CMD_PAGEPROG
suffix:colon
r_return
id|STATE_CMD_PAGEPROG
suffix:semicolon
r_case
id|NAND_CMD_READ2LP
suffix:colon
r_return
id|STATE_CMD_READ2LP
suffix:semicolon
r_case
id|NAND_CMD_READOOB
suffix:colon
r_return
id|STATE_CMD_READOOB
suffix:semicolon
r_case
id|NAND_CMD_ERASE1
suffix:colon
r_return
id|STATE_CMD_ERASE1
suffix:semicolon
r_case
id|NAND_CMD_STATUS
suffix:colon
r_return
id|STATE_CMD_STATUS
suffix:semicolon
r_case
id|NAND_CMD_STATUS_MULTI
suffix:colon
r_return
id|STATE_CMD_STATUS_M
suffix:semicolon
r_case
id|NAND_CMD_SEQIN
suffix:colon
r_return
id|STATE_CMD_SEQIN
suffix:semicolon
r_case
id|NAND_CMD_READID
suffix:colon
r_return
id|STATE_CMD_READID
suffix:semicolon
r_case
id|NAND_CMD_ERASE2
suffix:colon
r_return
id|STATE_CMD_ERASE2
suffix:semicolon
r_case
id|NAND_CMD_RESET
suffix:colon
r_return
id|STATE_CMD_RESET
suffix:semicolon
)brace
id|NS_ERR
c_func
(paren
l_string|&quot;get_state_by_command: unknown command, BUG&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Move an address byte to the correspondent internal register.&n; */
r_static
r_inline
r_void
DECL|function|accept_addr_byte
id|accept_addr_byte
c_func
(paren
r_struct
id|nandsim
op_star
id|ns
comma
id|u_char
id|bt
)paren
(brace
id|uint
id|byte
op_assign
(paren
id|uint
)paren
id|bt
suffix:semicolon
r_if
c_cond
(paren
id|ns-&gt;regs.count
OL
(paren
id|ns-&gt;geom.pgaddrbytes
op_minus
id|ns-&gt;geom.secaddrbytes
)paren
)paren
id|ns-&gt;regs.column
op_or_assign
(paren
id|byte
op_lshift
l_int|8
op_star
id|ns-&gt;regs.count
)paren
suffix:semicolon
r_else
(brace
id|ns-&gt;regs.row
op_or_assign
(paren
id|byte
op_lshift
l_int|8
op_star
(paren
id|ns-&gt;regs.count
op_minus
id|ns-&gt;geom.pgaddrbytes
op_plus
id|ns-&gt;geom.secaddrbytes
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Switch to STATE_READY state.&n; */
r_static
r_inline
r_void
DECL|function|switch_to_ready_state
id|switch_to_ready_state
c_func
(paren
r_struct
id|nandsim
op_star
id|ns
comma
id|u_char
id|status
)paren
(brace
id|NS_DBG
c_func
(paren
l_string|&quot;switch_to_ready_state: switch to %s state&bslash;n&quot;
comma
id|get_state_name
c_func
(paren
id|STATE_READY
)paren
)paren
suffix:semicolon
id|ns-&gt;state
op_assign
id|STATE_READY
suffix:semicolon
id|ns-&gt;nxstate
op_assign
id|STATE_UNKNOWN
suffix:semicolon
id|ns-&gt;op
op_assign
l_int|NULL
suffix:semicolon
id|ns-&gt;npstates
op_assign
l_int|0
suffix:semicolon
id|ns-&gt;stateidx
op_assign
l_int|0
suffix:semicolon
id|ns-&gt;regs.num
op_assign
l_int|0
suffix:semicolon
id|ns-&gt;regs.count
op_assign
l_int|0
suffix:semicolon
id|ns-&gt;regs.off
op_assign
l_int|0
suffix:semicolon
id|ns-&gt;regs.row
op_assign
l_int|0
suffix:semicolon
id|ns-&gt;regs.column
op_assign
l_int|0
suffix:semicolon
id|ns-&gt;regs.status
op_assign
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * If the operation isn&squot;t known yet, try to find it in the global array&n; * of supported operations.&n; *&n; * Operation can be unknown because of the following.&n; *   1. New command was accepted and this is the firs call to find the&n; *      correspondent states chain. In this case ns-&gt;npstates = 0;&n; *   2. There is several operations which begin with the same command(s)&n; *      (for example program from the second half and read from the&n; *      second half operations both begin with the READ1 command). In this&n; *      case the ns-&gt;pstates[] array contains previous states.&n; * &n; * Thus, the function tries to find operation containing the following&n; * states (if the &squot;flag&squot; parameter is 0):&n; *    ns-&gt;pstates[0], ... ns-&gt;pstates[ns-&gt;npstates], ns-&gt;state&n; *&n; * If (one and only one) matching operation is found, it is accepted (&n; * ns-&gt;ops, ns-&gt;state, ns-&gt;nxstate are initialized, ns-&gt;npstate is&n; * zeroed).&n; * &n; * If there are several maches, the current state is pushed to the&n; * ns-&gt;pstates.&n; *&n; * The operation can be unknown only while commands are input to the chip.&n; * As soon as address command is accepted, the operation must be known.&n; * In such situation the function is called with &squot;flag&squot; != 0, and the&n; * operation is searched using the following pattern:&n; *     ns-&gt;pstates[0], ... ns-&gt;pstates[ns-&gt;npstates], &lt;address input&gt;&n; * &n; * It is supposed that this pattern must either match one operation on&n; * none. There can&squot;t be ambiguity in that case.&n; *&n; * If no matches found, the functions does the following:&n; *   1. if there are saved states present, try to ignore them and search&n; *      again only using the last command. If nothing was found, switch&n; *      to the STATE_READY state.&n; *   2. if there are no saved states, switch to the STATE_READY state.&n; *&n; * RETURNS: -2 - no matched operations found.&n; *          -1 - several matches.&n; *           0 - operation is found.&n; */
r_static
r_int
DECL|function|find_operation
id|find_operation
c_func
(paren
r_struct
id|nandsim
op_star
id|ns
comma
r_uint32
id|flag
)paren
(brace
r_int
id|opsfound
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|idx
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NS_OPER_NUM
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|found
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ns-&gt;options
op_amp
id|ops
(braket
id|i
)braket
dot
id|reqopts
)paren
)paren
multiline_comment|/* Ignore operations we can&squot;t perform */
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|flag
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ops
(braket
id|i
)braket
dot
id|states
(braket
id|ns-&gt;npstates
)braket
op_amp
id|STATE_ADDR_MASK
)paren
)paren
r_continue
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|NS_STATE
c_func
(paren
id|ns-&gt;state
)paren
op_ne
id|NS_STATE
c_func
(paren
id|ops
(braket
id|i
)braket
dot
id|states
(braket
id|ns-&gt;npstates
)braket
)paren
)paren
r_continue
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ns-&gt;npstates
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|NS_STATE
c_func
(paren
id|ops
(braket
id|i
)braket
dot
id|states
(braket
id|j
)braket
)paren
op_ne
id|NS_STATE
c_func
(paren
id|ns-&gt;pstates
(braket
id|j
)braket
)paren
op_logical_and
(paren
id|ns-&gt;options
op_amp
id|ops
(braket
id|idx
)braket
dot
id|reqopts
)paren
)paren
(brace
id|found
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|found
)paren
(brace
id|idx
op_assign
id|i
suffix:semicolon
id|opsfound
op_add_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|opsfound
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Exact match */
id|ns-&gt;op
op_assign
op_amp
id|ops
(braket
id|idx
)braket
dot
id|states
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|flag
)paren
(brace
multiline_comment|/* &n;&t;&t;&t; * In this case the find_operation function was&n;&t;&t;&t; * called when address has just began input. But it isn&squot;t&n;&t;&t;&t; * yet fully input and the current state must&n;&t;&t;&t; * not be one of STATE_ADDR_*, but the STATE_ADDR_*&n;&t;&t;&t; * state must be the next state (ns-&gt;nxstate).&n;&t;&t;&t; */
id|ns-&gt;stateidx
op_assign
id|ns-&gt;npstates
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|ns-&gt;stateidx
op_assign
id|ns-&gt;npstates
suffix:semicolon
)brace
id|ns-&gt;npstates
op_assign
l_int|0
suffix:semicolon
id|ns-&gt;state
op_assign
id|ns-&gt;op
(braket
id|ns-&gt;stateidx
)braket
suffix:semicolon
id|ns-&gt;nxstate
op_assign
id|ns-&gt;op
(braket
id|ns-&gt;stateidx
op_plus
l_int|1
)braket
suffix:semicolon
id|NS_DBG
c_func
(paren
l_string|&quot;find_operation: operation found, index: %d, state: %s, nxstate %s&bslash;n&quot;
comma
id|idx
comma
id|get_state_name
c_func
(paren
id|ns-&gt;state
)paren
comma
id|get_state_name
c_func
(paren
id|ns-&gt;nxstate
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opsfound
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Nothing was found. Try to ignore previous commands (if any) and search again */
r_if
c_cond
(paren
id|ns-&gt;npstates
op_ne
l_int|0
)paren
(brace
id|NS_DBG
c_func
(paren
l_string|&quot;find_operation: no operation found, try again with state %s&bslash;n&quot;
comma
id|get_state_name
c_func
(paren
id|ns-&gt;state
)paren
)paren
suffix:semicolon
id|ns-&gt;npstates
op_assign
l_int|0
suffix:semicolon
r_return
id|find_operation
c_func
(paren
id|ns
comma
l_int|0
)paren
suffix:semicolon
)brace
id|NS_DBG
c_func
(paren
l_string|&quot;find_operation: no operations found&bslash;n&quot;
)paren
suffix:semicolon
id|switch_to_ready_state
c_func
(paren
id|ns
comma
id|NS_STATUS_FAILED
c_func
(paren
id|ns
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flag
)paren
(brace
multiline_comment|/* This shouldn&squot;t happen */
id|NS_DBG
c_func
(paren
l_string|&quot;find_operation: BUG, operation must be known if address is input&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|2
suffix:semicolon
)brace
id|NS_DBG
c_func
(paren
l_string|&quot;find_operation: there is still ambiguity&bslash;n&quot;
)paren
suffix:semicolon
id|ns-&gt;pstates
(braket
id|ns-&gt;npstates
op_increment
)braket
op_assign
id|ns-&gt;state
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * If state has any action bit, perform this action.&n; *&n; * RETURNS: 0 if success, -1 if error.&n; */
r_static
r_int
DECL|function|do_state_action
id|do_state_action
c_func
(paren
r_struct
id|nandsim
op_star
id|ns
comma
r_uint32
id|action
)paren
(brace
r_int
id|i
comma
id|num
suffix:semicolon
r_int
id|busdiv
op_assign
id|ns-&gt;busw
op_eq
l_int|8
ques
c_cond
l_int|1
suffix:colon
l_int|2
suffix:semicolon
id|action
op_and_assign
id|ACTION_MASK
suffix:semicolon
multiline_comment|/* Check that page address input is correct */
r_if
c_cond
(paren
id|action
op_ne
id|ACTION_SECERASE
op_logical_and
id|ns-&gt;regs.row
op_ge
id|ns-&gt;geom.pgnum
)paren
(brace
id|NS_WARN
c_func
(paren
l_string|&quot;do_state_action: wrong page number (%#x)&bslash;n&quot;
comma
id|ns-&gt;regs.row
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|action
)paren
(brace
r_case
id|ACTION_CPY
suffix:colon
multiline_comment|/*&n;&t;&t; * Copy page data to the internal buffer.&n;&t;&t; */
multiline_comment|/* Column shouldn&squot;t be very large */
r_if
c_cond
(paren
id|ns-&gt;regs.column
op_ge
(paren
id|ns-&gt;geom.pgszoob
op_minus
id|ns-&gt;regs.off
)paren
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;do_state_action: column number is too large&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|num
op_assign
id|ns-&gt;geom.pgszoob
op_minus
id|ns-&gt;regs.off
op_minus
id|ns-&gt;regs.column
suffix:semicolon
id|memcpy
c_func
(paren
id|ns-&gt;buf.byte
comma
id|ns-&gt;mem.byte
op_plus
id|NS_RAW_OFFSET
c_func
(paren
id|ns
)paren
op_plus
id|ns-&gt;regs.off
comma
id|num
)paren
suffix:semicolon
id|NS_DBG
c_func
(paren
l_string|&quot;do_state_action: (ACTION_CPY:) copy %d bytes to int buf, raw offset %d&bslash;n&quot;
comma
id|num
comma
id|NS_RAW_OFFSET
c_func
(paren
id|ns
)paren
op_plus
id|ns-&gt;regs.off
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ns-&gt;regs.off
op_eq
l_int|0
)paren
id|NS_LOG
c_func
(paren
l_string|&quot;read page %d&bslash;n&quot;
comma
id|ns-&gt;regs.row
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ns-&gt;regs.off
OL
id|ns-&gt;geom.pgsz
)paren
id|NS_LOG
c_func
(paren
l_string|&quot;read page %d (second half)&bslash;n&quot;
comma
id|ns-&gt;regs.row
)paren
suffix:semicolon
r_else
id|NS_LOG
c_func
(paren
l_string|&quot;read OOB of page %d&bslash;n&quot;
comma
id|ns-&gt;regs.row
)paren
suffix:semicolon
id|NS_UDELAY
c_func
(paren
id|access_delay
)paren
suffix:semicolon
id|NS_UDELAY
c_func
(paren
id|input_cycle
op_star
id|ns-&gt;geom.pgsz
op_div
l_int|1000
op_div
id|busdiv
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACTION_SECERASE
suffix:colon
multiline_comment|/*&n;&t;&t; * Erase sector.&n;&t;&t; */
r_if
c_cond
(paren
id|ns-&gt;lines.wp
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;do_state_action: device is write-protected, ignore sector erase&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ns-&gt;regs.row
op_ge
id|ns-&gt;geom.pgnum
op_minus
id|ns-&gt;geom.pgsec
op_logical_or
(paren
id|ns-&gt;regs.row
op_amp
op_complement
(paren
id|ns-&gt;geom.secsz
op_minus
l_int|1
)paren
)paren
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;do_state_action: wrong sector address (%#x)&bslash;n&quot;
comma
id|ns-&gt;regs.row
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|ns-&gt;regs.row
op_assign
(paren
id|ns-&gt;regs.row
op_lshift
l_int|8
op_star
(paren
id|ns-&gt;geom.pgaddrbytes
op_minus
id|ns-&gt;geom.secaddrbytes
)paren
)paren
op_or
id|ns-&gt;regs.column
suffix:semicolon
id|ns-&gt;regs.column
op_assign
l_int|0
suffix:semicolon
id|NS_DBG
c_func
(paren
l_string|&quot;do_state_action: erase sector at address %#x, off = %d&bslash;n&quot;
comma
id|ns-&gt;regs.row
comma
id|NS_RAW_OFFSET
c_func
(paren
id|ns
)paren
)paren
suffix:semicolon
id|NS_LOG
c_func
(paren
l_string|&quot;erase sector %d&bslash;n&quot;
comma
id|ns-&gt;regs.row
op_rshift
(paren
id|ns-&gt;geom.secshift
op_minus
id|ns-&gt;geom.pgshift
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ns-&gt;mem.byte
op_plus
id|NS_RAW_OFFSET
c_func
(paren
id|ns
)paren
comma
l_int|0xFF
comma
id|ns-&gt;geom.secszoob
)paren
suffix:semicolon
id|NS_MDELAY
c_func
(paren
id|erase_delay
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACTION_PRGPAGE
suffix:colon
multiline_comment|/*&n;&t;&t; * Programm page - move internal buffer data to the page.&n;&t;&t; */
r_if
c_cond
(paren
id|ns-&gt;lines.wp
)paren
(brace
id|NS_WARN
c_func
(paren
l_string|&quot;do_state_action: device is write-protected, programm&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|num
op_assign
id|ns-&gt;geom.pgszoob
op_minus
id|ns-&gt;regs.off
op_minus
id|ns-&gt;regs.column
suffix:semicolon
r_if
c_cond
(paren
id|num
op_ne
id|ns-&gt;regs.count
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;do_state_action: too few bytes were input (%d instead of %d)&bslash;n&quot;
comma
id|ns-&gt;regs.count
comma
id|num
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
id|ns-&gt;mem.byte
(braket
id|NS_RAW_OFFSET
c_func
(paren
id|ns
)paren
op_plus
id|ns-&gt;regs.off
op_plus
id|i
)braket
op_and_assign
id|ns-&gt;buf.byte
(braket
id|i
)braket
suffix:semicolon
id|NS_DBG
c_func
(paren
l_string|&quot;do_state_action: copy %d bytes from int buf to (%#x, %#x), raw off = %d&bslash;n&quot;
comma
id|num
comma
id|ns-&gt;regs.row
comma
id|ns-&gt;regs.column
comma
id|NS_RAW_OFFSET
c_func
(paren
id|ns
)paren
op_plus
id|ns-&gt;regs.off
)paren
suffix:semicolon
id|NS_LOG
c_func
(paren
l_string|&quot;programm page %d&bslash;n&quot;
comma
id|ns-&gt;regs.row
)paren
suffix:semicolon
id|NS_UDELAY
c_func
(paren
id|programm_delay
)paren
suffix:semicolon
id|NS_UDELAY
c_func
(paren
id|output_cycle
op_star
id|ns-&gt;geom.pgsz
op_div
l_int|1000
op_div
id|busdiv
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACTION_ZEROOFF
suffix:colon
id|NS_DBG
c_func
(paren
l_string|&quot;do_state_action: set internal offset to 0&bslash;n&quot;
)paren
suffix:semicolon
id|ns-&gt;regs.off
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACTION_HALFOFF
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ns-&gt;options
op_amp
id|OPT_PAGE512_8BIT
)paren
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;do_state_action: BUG! can&squot;t skip half of page for non-512&quot;
l_string|&quot;byte page size 8x chips&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|NS_DBG
c_func
(paren
l_string|&quot;do_state_action: set internal offset to %d&bslash;n&quot;
comma
id|ns-&gt;geom.pgsz
op_div
l_int|2
)paren
suffix:semicolon
id|ns-&gt;regs.off
op_assign
id|ns-&gt;geom.pgsz
op_div
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACTION_OOBOFF
suffix:colon
id|NS_DBG
c_func
(paren
l_string|&quot;do_state_action: set internal offset to %d&bslash;n&quot;
comma
id|ns-&gt;geom.pgsz
)paren
suffix:semicolon
id|ns-&gt;regs.off
op_assign
id|ns-&gt;geom.pgsz
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|NS_DBG
c_func
(paren
l_string|&quot;do_state_action: BUG! unknown action&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Switch simulator&squot;s state.&n; */
r_static
r_void
DECL|function|switch_state
id|switch_state
c_func
(paren
r_struct
id|nandsim
op_star
id|ns
)paren
(brace
r_if
c_cond
(paren
id|ns-&gt;op
)paren
(brace
multiline_comment|/*&n;&t;&t; * The current operation have already been identified.&n;&t;&t; * Just follow the states chain.&n;&t;&t; */
id|ns-&gt;stateidx
op_add_assign
l_int|1
suffix:semicolon
id|ns-&gt;state
op_assign
id|ns-&gt;nxstate
suffix:semicolon
id|ns-&gt;nxstate
op_assign
id|ns-&gt;op
(braket
id|ns-&gt;stateidx
op_plus
l_int|1
)braket
suffix:semicolon
id|NS_DBG
c_func
(paren
l_string|&quot;switch_state: operation is known, switch to the next state, &quot;
l_string|&quot;state: %s, nxstate: %s&bslash;n&quot;
comma
id|get_state_name
c_func
(paren
id|ns-&gt;state
)paren
comma
id|get_state_name
c_func
(paren
id|ns-&gt;nxstate
)paren
)paren
suffix:semicolon
multiline_comment|/* See, whether we need to do some action */
r_if
c_cond
(paren
(paren
id|ns-&gt;state
op_amp
id|ACTION_MASK
)paren
op_logical_and
id|do_state_action
c_func
(paren
id|ns
comma
id|ns-&gt;state
)paren
OL
l_int|0
)paren
(brace
id|switch_to_ready_state
c_func
(paren
id|ns
comma
id|NS_STATUS_FAILED
c_func
(paren
id|ns
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * We don&squot;t yet know which operation we perform.&n;&t;&t; * Try to identify it.&n;&t;&t; */
multiline_comment|/*  &n;&t;&t; *  The only event causing the switch_state function to&n;&t;&t; *  be called with yet unknown operation is new command.&n;&t;&t; */
id|ns-&gt;state
op_assign
id|get_state_by_command
c_func
(paren
id|ns-&gt;regs.command
)paren
suffix:semicolon
id|NS_DBG
c_func
(paren
l_string|&quot;switch_state: operation is unknown, try to find it&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|find_operation
c_func
(paren
id|ns
comma
l_int|0
)paren
op_ne
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ns-&gt;state
op_amp
id|ACTION_MASK
)paren
op_logical_and
id|do_state_action
c_func
(paren
id|ns
comma
id|ns-&gt;state
)paren
OL
l_int|0
)paren
(brace
id|switch_to_ready_state
c_func
(paren
id|ns
comma
id|NS_STATUS_FAILED
c_func
(paren
id|ns
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* For 16x devices column means the page offset in words */
r_if
c_cond
(paren
(paren
id|ns-&gt;nxstate
op_amp
id|STATE_ADDR_MASK
)paren
op_logical_and
id|ns-&gt;busw
op_eq
l_int|16
)paren
(brace
id|NS_DBG
c_func
(paren
l_string|&quot;switch_state: double the column number for 16x device&bslash;n&quot;
)paren
suffix:semicolon
id|ns-&gt;regs.column
op_lshift_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|NS_STATE
c_func
(paren
id|ns-&gt;nxstate
)paren
op_eq
id|STATE_READY
)paren
(brace
multiline_comment|/*&n;&t;&t; * The current state is the last. Return to STATE_READY&n;&t;&t; */
id|u_char
id|status
op_assign
id|NS_STATUS_OK
c_func
(paren
id|ns
)paren
suffix:semicolon
multiline_comment|/* In case of data states, see if all bytes were input/output */
r_if
c_cond
(paren
(paren
id|ns-&gt;state
op_amp
(paren
id|STATE_DATAIN_MASK
op_or
id|STATE_DATAOUT_MASK
)paren
)paren
op_logical_and
id|ns-&gt;regs.count
op_ne
id|ns-&gt;regs.num
)paren
(brace
id|NS_WARN
c_func
(paren
l_string|&quot;switch_state: not all bytes were processed, %d left&bslash;n&quot;
comma
id|ns-&gt;regs.num
op_minus
id|ns-&gt;regs.count
)paren
suffix:semicolon
id|status
op_assign
id|NS_STATUS_FAILED
c_func
(paren
id|ns
)paren
suffix:semicolon
)brace
id|NS_DBG
c_func
(paren
l_string|&quot;switch_state: operation complete, switch to STATE_READY state&bslash;n&quot;
)paren
suffix:semicolon
id|switch_to_ready_state
c_func
(paren
id|ns
comma
id|status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ns-&gt;nxstate
op_amp
(paren
id|STATE_DATAIN_MASK
op_or
id|STATE_DATAOUT_MASK
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t; * If the next state is data input/output, switch to it now&n;&t;&t; */
id|ns-&gt;state
op_assign
id|ns-&gt;nxstate
suffix:semicolon
id|ns-&gt;nxstate
op_assign
id|ns-&gt;op
(braket
op_increment
id|ns-&gt;stateidx
op_plus
l_int|1
)braket
suffix:semicolon
id|ns-&gt;regs.num
op_assign
id|ns-&gt;regs.count
op_assign
l_int|0
suffix:semicolon
id|NS_DBG
c_func
(paren
l_string|&quot;switch_state: the next state is data I/O, switch, &quot;
l_string|&quot;state: %s, nxstate: %s&bslash;n&quot;
comma
id|get_state_name
c_func
(paren
id|ns-&gt;state
)paren
comma
id|get_state_name
c_func
(paren
id|ns-&gt;nxstate
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set the internal register to the count of bytes which&n;&t;&t; * are expected to be input or output&n;&t;&t; */
r_switch
c_cond
(paren
id|NS_STATE
c_func
(paren
id|ns-&gt;state
)paren
)paren
(brace
r_case
id|STATE_DATAIN
suffix:colon
r_case
id|STATE_DATAOUT
suffix:colon
id|ns-&gt;regs.num
op_assign
id|ns-&gt;geom.pgszoob
op_minus
id|ns-&gt;regs.off
op_minus
id|ns-&gt;regs.column
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STATE_DATAOUT_ID
suffix:colon
id|ns-&gt;regs.num
op_assign
id|ns-&gt;geom.idbytes
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STATE_DATAOUT_STATUS
suffix:colon
r_case
id|STATE_DATAOUT_STATUS_M
suffix:colon
id|ns-&gt;regs.count
op_assign
id|ns-&gt;regs.num
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|NS_ERR
c_func
(paren
l_string|&quot;switch_state: BUG! unknown data state&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|ns-&gt;nxstate
op_amp
id|STATE_ADDR_MASK
)paren
(brace
multiline_comment|/*&n;&t;&t; * If the next state is address input, set the internal&n;&t;&t; * register to the number of expected address bytes&n;&t;&t; */
id|ns-&gt;regs.count
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|NS_STATE
c_func
(paren
id|ns-&gt;nxstate
)paren
)paren
(brace
r_case
id|STATE_ADDR_PAGE
suffix:colon
id|ns-&gt;regs.num
op_assign
id|ns-&gt;geom.pgaddrbytes
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STATE_ADDR_SEC
suffix:colon
id|ns-&gt;regs.num
op_assign
id|ns-&gt;geom.secaddrbytes
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STATE_ADDR_ZERO
suffix:colon
id|ns-&gt;regs.num
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|NS_ERR
c_func
(paren
l_string|&quot;switch_state: BUG! unknown address state&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* &n;&t;&t; * Just reset internal counters.&n;&t;&t; */
id|ns-&gt;regs.num
op_assign
l_int|0
suffix:semicolon
id|ns-&gt;regs.count
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|ns_hwcontrol
id|ns_hwcontrol
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|cmd
)paren
(brace
r_struct
id|nandsim
op_star
id|ns
op_assign
(paren
r_struct
id|nandsim
op_star
)paren
(paren
(paren
r_struct
id|nand_chip
op_star
)paren
id|mtd-&gt;priv
)paren
op_member_access_from_pointer
id|priv
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
multiline_comment|/* set CLE line high */
r_case
id|NAND_CTL_SETCLE
suffix:colon
id|NS_DBG
c_func
(paren
l_string|&quot;ns_hwcontrol: start command latch cycles&bslash;n&quot;
)paren
suffix:semicolon
id|ns-&gt;lines.cle
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* set CLE line low */
r_case
id|NAND_CTL_CLRCLE
suffix:colon
id|NS_DBG
c_func
(paren
l_string|&quot;ns_hwcontrol: stop command latch cycles&bslash;n&quot;
)paren
suffix:semicolon
id|ns-&gt;lines.cle
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* set ALE line high */
r_case
id|NAND_CTL_SETALE
suffix:colon
id|NS_DBG
c_func
(paren
l_string|&quot;ns_hwcontrol: start address latch cycles&bslash;n&quot;
)paren
suffix:semicolon
id|ns-&gt;lines.ale
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* set ALE line low */
r_case
id|NAND_CTL_CLRALE
suffix:colon
id|NS_DBG
c_func
(paren
l_string|&quot;ns_hwcontrol: stop address latch cycles&bslash;n&quot;
)paren
suffix:semicolon
id|ns-&gt;lines.ale
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* set WP line high */
r_case
id|NAND_CTL_SETWP
suffix:colon
id|NS_DBG
c_func
(paren
l_string|&quot;ns_hwcontrol: enable write protection&bslash;n&quot;
)paren
suffix:semicolon
id|ns-&gt;lines.wp
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* set WP line low */
r_case
id|NAND_CTL_CLRWP
suffix:colon
id|NS_DBG
c_func
(paren
l_string|&quot;ns_hwcontrol: disable write protection&bslash;n&quot;
)paren
suffix:semicolon
id|ns-&gt;lines.wp
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* set CE line low */
r_case
id|NAND_CTL_SETNCE
suffix:colon
id|NS_DBG
c_func
(paren
l_string|&quot;ns_hwcontrol: enable chip&bslash;n&quot;
)paren
suffix:semicolon
id|ns-&gt;lines.ce
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* set CE line high */
r_case
id|NAND_CTL_CLRNCE
suffix:colon
id|NS_DBG
c_func
(paren
l_string|&quot;ns_hwcontrol: disable chip&bslash;n&quot;
)paren
suffix:semicolon
id|ns-&gt;lines.ce
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|NS_ERR
c_func
(paren
l_string|&quot;hwcontrol: unknown command&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_static
id|u_char
DECL|function|ns_nand_read_byte
id|ns_nand_read_byte
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nandsim
op_star
id|ns
op_assign
(paren
r_struct
id|nandsim
op_star
)paren
(paren
(paren
r_struct
id|nand_chip
op_star
)paren
id|mtd-&gt;priv
)paren
op_member_access_from_pointer
id|priv
suffix:semicolon
id|u_char
id|outb
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* Sanity and correctness checks */
r_if
c_cond
(paren
op_logical_neg
id|ns-&gt;lines.ce
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;read_byte: chip is disabled, return %#x&bslash;n&quot;
comma
(paren
id|uint
)paren
id|outb
)paren
suffix:semicolon
r_return
id|outb
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ns-&gt;lines.ale
op_logical_or
id|ns-&gt;lines.cle
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;read_byte: ALE or CLE pin is high, return %#x&bslash;n&quot;
comma
(paren
id|uint
)paren
id|outb
)paren
suffix:semicolon
r_return
id|outb
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ns-&gt;state
op_amp
id|STATE_DATAOUT_MASK
)paren
)paren
(brace
id|NS_WARN
c_func
(paren
l_string|&quot;read_byte: unexpected data output cycle, state is %s &quot;
l_string|&quot;return %#x&bslash;n&quot;
comma
id|get_state_name
c_func
(paren
id|ns-&gt;state
)paren
comma
(paren
id|uint
)paren
id|outb
)paren
suffix:semicolon
r_return
id|outb
suffix:semicolon
)brace
multiline_comment|/* Status register may be read as many times as it is wanted */
r_if
c_cond
(paren
id|NS_STATE
c_func
(paren
id|ns-&gt;state
)paren
op_eq
id|STATE_DATAOUT_STATUS
)paren
(brace
id|NS_DBG
c_func
(paren
l_string|&quot;read_byte: return %#x status&bslash;n&quot;
comma
id|ns-&gt;regs.status
)paren
suffix:semicolon
r_return
id|ns-&gt;regs.status
suffix:semicolon
)brace
multiline_comment|/* Check if there is any data in the internal buffer which may be read */
r_if
c_cond
(paren
id|ns-&gt;regs.count
op_eq
id|ns-&gt;regs.num
)paren
(brace
id|NS_WARN
c_func
(paren
l_string|&quot;read_byte: no more data to output, return %#x&bslash;n&quot;
comma
(paren
id|uint
)paren
id|outb
)paren
suffix:semicolon
r_return
id|outb
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|NS_STATE
c_func
(paren
id|ns-&gt;state
)paren
)paren
(brace
r_case
id|STATE_DATAOUT
suffix:colon
r_if
c_cond
(paren
id|ns-&gt;busw
op_eq
l_int|8
)paren
(brace
id|outb
op_assign
id|ns-&gt;buf.byte
(braket
id|ns-&gt;regs.count
)braket
suffix:semicolon
id|ns-&gt;regs.count
op_add_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|outb
op_assign
(paren
id|u_char
)paren
id|cpu_to_le16
c_func
(paren
id|ns-&gt;buf.word
(braket
id|ns-&gt;regs.count
op_rshift
l_int|1
)braket
)paren
suffix:semicolon
id|ns-&gt;regs.count
op_add_assign
l_int|2
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|STATE_DATAOUT_ID
suffix:colon
id|NS_DBG
c_func
(paren
l_string|&quot;read_byte: read ID byte %d, total = %d&bslash;n&quot;
comma
id|ns-&gt;regs.count
comma
id|ns-&gt;regs.num
)paren
suffix:semicolon
id|outb
op_assign
id|ns-&gt;ids
(braket
id|ns-&gt;regs.count
)braket
suffix:semicolon
id|ns-&gt;regs.count
op_add_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ns-&gt;regs.count
op_eq
id|ns-&gt;regs.num
)paren
(brace
id|NS_DBG
c_func
(paren
l_string|&quot;read_byte: all bytes were read&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The OPT_AUTOINCR allows to read next conseqitive pages without&n;&t;&t; * new read operation cycle.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ns-&gt;options
op_amp
id|OPT_AUTOINCR
)paren
op_logical_and
id|NS_STATE
c_func
(paren
id|ns-&gt;state
)paren
op_eq
id|STATE_DATAOUT
)paren
(brace
id|ns-&gt;regs.count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ns-&gt;regs.row
op_plus
l_int|1
OL
id|ns-&gt;geom.pgnum
)paren
id|ns-&gt;regs.row
op_add_assign
l_int|1
suffix:semicolon
id|NS_DBG
c_func
(paren
l_string|&quot;read_byte: switch to the next page (%#x)&bslash;n&quot;
comma
id|ns-&gt;regs.row
)paren
suffix:semicolon
id|do_state_action
c_func
(paren
id|ns
comma
id|ACTION_CPY
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|NS_STATE
c_func
(paren
id|ns-&gt;nxstate
)paren
op_eq
id|STATE_READY
)paren
id|switch_state
c_func
(paren
id|ns
)paren
suffix:semicolon
)brace
r_return
id|outb
suffix:semicolon
)brace
r_static
r_void
DECL|function|ns_nand_write_byte
id|ns_nand_write_byte
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u_char
id|byte
)paren
(brace
r_struct
id|nandsim
op_star
id|ns
op_assign
(paren
r_struct
id|nandsim
op_star
)paren
(paren
(paren
r_struct
id|nand_chip
op_star
)paren
id|mtd-&gt;priv
)paren
op_member_access_from_pointer
id|priv
suffix:semicolon
multiline_comment|/* Sanity and correctness checks */
r_if
c_cond
(paren
op_logical_neg
id|ns-&gt;lines.ce
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;write_byte: chip is disabled, ignore write&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ns-&gt;lines.ale
op_logical_and
id|ns-&gt;lines.cle
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;write_byte: ALE and CLE pins are high simultaneously, ignore write&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ns-&gt;lines.cle
op_eq
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * The byte written is a command.&n;&t;&t; */
r_if
c_cond
(paren
id|byte
op_eq
id|NAND_CMD_RESET
)paren
(brace
id|NS_LOG
c_func
(paren
l_string|&quot;reset chip&bslash;n&quot;
)paren
suffix:semicolon
id|switch_to_ready_state
c_func
(paren
id|ns
comma
id|NS_STATUS_OK
c_func
(paren
id|ns
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * Chip might still be in STATE_DATAOUT&n;&t;&t; * (if OPT_AUTOINCR feature is supported), STATE_DATAOUT_STATUS or&n;&t;&t; * STATE_DATAOUT_STATUS_M state. If so, switch state.&n;&t;&t; */
r_if
c_cond
(paren
id|NS_STATE
c_func
(paren
id|ns-&gt;state
)paren
op_eq
id|STATE_DATAOUT_STATUS
op_logical_or
id|NS_STATE
c_func
(paren
id|ns-&gt;state
)paren
op_eq
id|STATE_DATAOUT_STATUS_M
op_logical_or
(paren
(paren
id|ns-&gt;options
op_amp
id|OPT_AUTOINCR
)paren
op_logical_and
id|NS_STATE
c_func
(paren
id|ns-&gt;state
)paren
op_eq
id|STATE_DATAOUT
)paren
)paren
id|switch_state
c_func
(paren
id|ns
)paren
suffix:semicolon
multiline_comment|/* Check if chip is expecting command */
r_if
c_cond
(paren
id|NS_STATE
c_func
(paren
id|ns-&gt;nxstate
)paren
op_ne
id|STATE_UNKNOWN
op_logical_and
op_logical_neg
(paren
id|ns-&gt;nxstate
op_amp
id|STATE_CMD_MASK
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We are in situation when something else (not command)&n;&t;&t;&t; * was expected but command was input. In this case ignore&n;&t;&t;&t; * previous command(s)/state(s) and accept the last one.&n;&t;&t;&t; */
id|NS_WARN
c_func
(paren
l_string|&quot;write_byte: command (%#x) wasn&squot;t expected, expected state is %s, &quot;
l_string|&quot;ignore previous states&bslash;n&quot;
comma
(paren
id|uint
)paren
id|byte
comma
id|get_state_name
c_func
(paren
id|ns-&gt;nxstate
)paren
)paren
suffix:semicolon
id|switch_to_ready_state
c_func
(paren
id|ns
comma
id|NS_STATUS_FAILED
c_func
(paren
id|ns
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Check that the command byte is correct */
r_if
c_cond
(paren
id|check_command
c_func
(paren
id|byte
)paren
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;write_byte: unknown command %#x&bslash;n&quot;
comma
(paren
id|uint
)paren
id|byte
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|NS_DBG
c_func
(paren
l_string|&quot;command byte corresponding to %s state accepted&bslash;n&quot;
comma
id|get_state_name
c_func
(paren
id|get_state_by_command
c_func
(paren
id|byte
)paren
)paren
)paren
suffix:semicolon
id|ns-&gt;regs.command
op_assign
id|byte
suffix:semicolon
id|switch_state
c_func
(paren
id|ns
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ns-&gt;lines.ale
op_eq
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * The byte written is an address.&n;&t;&t; */
r_if
c_cond
(paren
id|NS_STATE
c_func
(paren
id|ns-&gt;nxstate
)paren
op_eq
id|STATE_UNKNOWN
)paren
(brace
id|NS_DBG
c_func
(paren
l_string|&quot;write_byte: operation isn&squot;t known yet, identify it&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|find_operation
c_func
(paren
id|ns
comma
l_int|1
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ns-&gt;state
op_amp
id|ACTION_MASK
)paren
op_logical_and
id|do_state_action
c_func
(paren
id|ns
comma
id|ns-&gt;state
)paren
OL
l_int|0
)paren
(brace
id|switch_to_ready_state
c_func
(paren
id|ns
comma
id|NS_STATUS_FAILED
c_func
(paren
id|ns
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ns-&gt;regs.count
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|NS_STATE
c_func
(paren
id|ns-&gt;nxstate
)paren
)paren
(brace
r_case
id|STATE_ADDR_PAGE
suffix:colon
id|ns-&gt;regs.num
op_assign
id|ns-&gt;geom.pgaddrbytes
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STATE_ADDR_SEC
suffix:colon
id|ns-&gt;regs.num
op_assign
id|ns-&gt;geom.secaddrbytes
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STATE_ADDR_ZERO
suffix:colon
id|ns-&gt;regs.num
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Check that chip is expecting address */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ns-&gt;nxstate
op_amp
id|STATE_ADDR_MASK
)paren
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;write_byte: address (%#x) isn&squot;t expected, expected state is %s, &quot;
l_string|&quot;switch to STATE_READY&bslash;n&quot;
comma
(paren
id|uint
)paren
id|byte
comma
id|get_state_name
c_func
(paren
id|ns-&gt;nxstate
)paren
)paren
suffix:semicolon
id|switch_to_ready_state
c_func
(paren
id|ns
comma
id|NS_STATUS_FAILED
c_func
(paren
id|ns
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Check if this is expected byte */
r_if
c_cond
(paren
id|ns-&gt;regs.count
op_eq
id|ns-&gt;regs.num
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;write_byte: no more address bytes expected&bslash;n&quot;
)paren
suffix:semicolon
id|switch_to_ready_state
c_func
(paren
id|ns
comma
id|NS_STATUS_FAILED
c_func
(paren
id|ns
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|accept_addr_byte
c_func
(paren
id|ns
comma
id|byte
)paren
suffix:semicolon
id|ns-&gt;regs.count
op_add_assign
l_int|1
suffix:semicolon
id|NS_DBG
c_func
(paren
l_string|&quot;write_byte: address byte %#x was accepted (%d bytes input, %d expected)&bslash;n&quot;
comma
(paren
id|uint
)paren
id|byte
comma
id|ns-&gt;regs.count
comma
id|ns-&gt;regs.num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ns-&gt;regs.count
op_eq
id|ns-&gt;regs.num
)paren
(brace
id|NS_DBG
c_func
(paren
l_string|&quot;address (%#x, %#x) is accepted&bslash;n&quot;
comma
id|ns-&gt;regs.row
comma
id|ns-&gt;regs.column
)paren
suffix:semicolon
id|switch_state
c_func
(paren
id|ns
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * The byte written is an input data.&n;&t;&t; */
multiline_comment|/* Check that chip is expecting data input */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ns-&gt;state
op_amp
id|STATE_DATAIN_MASK
)paren
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;write_byte: data input (%#x) isn&squot;t expected, state is %s, &quot;
l_string|&quot;switch to %s&bslash;n&quot;
comma
(paren
id|uint
)paren
id|byte
comma
id|get_state_name
c_func
(paren
id|ns-&gt;state
)paren
comma
id|get_state_name
c_func
(paren
id|STATE_READY
)paren
)paren
suffix:semicolon
id|switch_to_ready_state
c_func
(paren
id|ns
comma
id|NS_STATUS_FAILED
c_func
(paren
id|ns
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Check if this is expected byte */
r_if
c_cond
(paren
id|ns-&gt;regs.count
op_eq
id|ns-&gt;regs.num
)paren
(brace
id|NS_WARN
c_func
(paren
l_string|&quot;write_byte: %u input bytes has already been accepted, ignore write&bslash;n&quot;
comma
id|ns-&gt;regs.num
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ns-&gt;busw
op_eq
l_int|8
)paren
(brace
id|ns-&gt;buf.byte
(braket
id|ns-&gt;regs.count
)braket
op_assign
id|byte
suffix:semicolon
id|ns-&gt;regs.count
op_add_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|ns-&gt;buf.word
(braket
id|ns-&gt;regs.count
op_rshift
l_int|1
)braket
op_assign
id|cpu_to_le16
c_func
(paren
(paren
r_uint16
)paren
id|byte
)paren
suffix:semicolon
id|ns-&gt;regs.count
op_add_assign
l_int|2
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|ns_device_ready
id|ns_device_ready
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
id|NS_DBG
c_func
(paren
l_string|&quot;device_ready&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_uint16
DECL|function|ns_nand_read_word
id|ns_nand_read_word
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|chip
op_assign
(paren
r_struct
id|nand_chip
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
id|NS_DBG
c_func
(paren
l_string|&quot;read_word&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|chip
op_member_access_from_pointer
id|read_byte
c_func
(paren
id|mtd
)paren
op_or
(paren
id|chip
op_member_access_from_pointer
id|read_byte
c_func
(paren
id|mtd
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ns_nand_write_word
id|ns_nand_write_word
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_uint16
id|word
)paren
(brace
r_struct
id|nand_chip
op_star
id|chip
op_assign
(paren
r_struct
id|nand_chip
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
id|NS_DBG
c_func
(paren
l_string|&quot;write_word&bslash;n&quot;
)paren
suffix:semicolon
id|chip
op_member_access_from_pointer
id|write_byte
c_func
(paren
id|mtd
comma
id|word
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|chip
op_member_access_from_pointer
id|write_byte
c_func
(paren
id|mtd
comma
id|word
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ns_nand_write_buf
id|ns_nand_write_buf
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|nandsim
op_star
id|ns
op_assign
(paren
r_struct
id|nandsim
op_star
)paren
(paren
(paren
r_struct
id|nand_chip
op_star
)paren
id|mtd-&gt;priv
)paren
op_member_access_from_pointer
id|priv
suffix:semicolon
multiline_comment|/* Check that chip is expecting data input */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ns-&gt;state
op_amp
id|STATE_DATAIN_MASK
)paren
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;write_buf: data input isn&squot;t expected, state is %s, &quot;
l_string|&quot;switch to STATE_READY&bslash;n&quot;
comma
id|get_state_name
c_func
(paren
id|ns-&gt;state
)paren
)paren
suffix:semicolon
id|switch_to_ready_state
c_func
(paren
id|ns
comma
id|NS_STATUS_FAILED
c_func
(paren
id|ns
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Check if these are expected bytes */
r_if
c_cond
(paren
id|ns-&gt;regs.count
op_plus
id|len
OG
id|ns-&gt;regs.num
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;write_buf: too many input bytes&bslash;n&quot;
)paren
suffix:semicolon
id|switch_to_ready_state
c_func
(paren
id|ns
comma
id|NS_STATUS_FAILED
c_func
(paren
id|ns
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|ns-&gt;buf.byte
op_plus
id|ns-&gt;regs.count
comma
id|buf
comma
id|len
)paren
suffix:semicolon
id|ns-&gt;regs.count
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|ns-&gt;regs.count
op_eq
id|ns-&gt;regs.num
)paren
(brace
id|NS_DBG
c_func
(paren
l_string|&quot;write_buf: %d bytes were written&bslash;n&quot;
comma
id|ns-&gt;regs.count
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|ns_nand_read_buf
id|ns_nand_read_buf
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|nandsim
op_star
id|ns
op_assign
(paren
r_struct
id|nandsim
op_star
)paren
(paren
(paren
r_struct
id|nand_chip
op_star
)paren
id|mtd-&gt;priv
)paren
op_member_access_from_pointer
id|priv
suffix:semicolon
multiline_comment|/* Sanity and correctness checks */
r_if
c_cond
(paren
op_logical_neg
id|ns-&gt;lines.ce
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;read_buf: chip is disabled&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ns-&gt;lines.ale
op_logical_or
id|ns-&gt;lines.cle
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;read_buf: ALE or CLE pin is high&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ns-&gt;state
op_amp
id|STATE_DATAOUT_MASK
)paren
)paren
(brace
id|NS_WARN
c_func
(paren
l_string|&quot;read_buf: unexpected data output cycle, current state is %s&bslash;n&quot;
comma
id|get_state_name
c_func
(paren
id|ns-&gt;state
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|NS_STATE
c_func
(paren
id|ns-&gt;state
)paren
op_ne
id|STATE_DATAOUT
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
id|buf
(braket
id|i
)braket
op_assign
(paren
(paren
r_struct
id|nand_chip
op_star
)paren
id|mtd-&gt;priv
)paren
op_member_access_from_pointer
id|read_byte
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Check if these are expected bytes */
r_if
c_cond
(paren
id|ns-&gt;regs.count
op_plus
id|len
OG
id|ns-&gt;regs.num
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;read_buf: too many bytes to read&bslash;n&quot;
)paren
suffix:semicolon
id|switch_to_ready_state
c_func
(paren
id|ns
comma
id|NS_STATUS_FAILED
c_func
(paren
id|ns
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|buf
comma
id|ns-&gt;buf.byte
op_plus
id|ns-&gt;regs.count
comma
id|len
)paren
suffix:semicolon
id|ns-&gt;regs.count
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|ns-&gt;regs.count
op_eq
id|ns-&gt;regs.num
)paren
(brace
r_if
c_cond
(paren
(paren
id|ns-&gt;options
op_amp
id|OPT_AUTOINCR
)paren
op_logical_and
id|NS_STATE
c_func
(paren
id|ns-&gt;state
)paren
op_eq
id|STATE_DATAOUT
)paren
(brace
id|ns-&gt;regs.count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ns-&gt;regs.row
op_plus
l_int|1
OL
id|ns-&gt;geom.pgnum
)paren
id|ns-&gt;regs.row
op_add_assign
l_int|1
suffix:semicolon
id|NS_DBG
c_func
(paren
l_string|&quot;read_buf: switch to the next page (%#x)&bslash;n&quot;
comma
id|ns-&gt;regs.row
)paren
suffix:semicolon
id|do_state_action
c_func
(paren
id|ns
comma
id|ACTION_CPY
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|NS_STATE
c_func
(paren
id|ns-&gt;nxstate
)paren
op_eq
id|STATE_READY
)paren
id|switch_state
c_func
(paren
id|ns
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|ns_nand_verify_buf
id|ns_nand_verify_buf
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
id|ns_nand_read_buf
c_func
(paren
id|mtd
comma
(paren
id|u_char
op_star
)paren
op_amp
id|ns_verify_buf
(braket
l_int|0
)braket
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|buf
comma
op_amp
id|ns_verify_buf
(braket
l_int|0
)braket
comma
id|len
)paren
)paren
(brace
id|NS_DBG
c_func
(paren
l_string|&quot;verify_buf: the buffer is OK&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|NS_DBG
c_func
(paren
l_string|&quot;verify_buf: the buffer is wrong&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Having only NAND chip IDs we call nand_scan which detects NAND flash&n; * parameters and then calls scan_bbt in order to scan/find/build the&n; * NAND flash bad block table. But since at that moment the NAND flash&n; * image isn&squot;t allocated in the simulator, errors arise. To avoid this&n; * we redefine the scan_bbt callback and initialize the nandsim structure&n; * before the flash media scanning.&n; */
DECL|function|ns_scan_bbt
r_int
id|ns_scan_bbt
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|chip
op_assign
(paren
r_struct
id|nand_chip
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|nandsim
op_star
id|ns
op_assign
(paren
r_struct
id|nandsim
op_star
)paren
(paren
id|chip-&gt;priv
)paren
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|NS_IS_INITIALIZED
c_func
(paren
id|ns
)paren
)paren
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|init_nandsim
c_func
(paren
id|mtd
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;scan_bbt: can&squot;t initialize the nandsim structure&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|nand_default_bbt
c_func
(paren
id|mtd
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|free_nandsim
c_func
(paren
id|ns
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Module initialization function&n; */
DECL|function|ns_init_module
r_int
id|__init
id|ns_init_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|nand_chip
op_star
id|chip
suffix:semicolon
r_struct
id|nandsim
op_star
id|nand
suffix:semicolon
r_int
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|bus_width
op_ne
l_int|8
op_logical_and
id|bus_width
op_ne
l_int|16
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;wrong bus width (%d), use only 8 or 16&bslash;n&quot;
comma
id|bus_width
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Allocate and initialize mtd_info, nand_chip and nandsim structures */
id|nsmtd
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|mtd_info
)paren
op_plus
r_sizeof
(paren
r_struct
id|nand_chip
)paren
op_plus
r_sizeof
(paren
r_struct
id|nandsim
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nsmtd
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;unable to allocate core structures.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|nsmtd
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|mtd_info
)paren
op_plus
r_sizeof
(paren
r_struct
id|nand_chip
)paren
op_plus
r_sizeof
(paren
r_struct
id|nandsim
)paren
)paren
suffix:semicolon
id|chip
op_assign
(paren
r_struct
id|nand_chip
op_star
)paren
(paren
id|nsmtd
op_plus
l_int|1
)paren
suffix:semicolon
id|nsmtd-&gt;priv
op_assign
(paren
r_void
op_star
)paren
id|chip
suffix:semicolon
id|nand
op_assign
(paren
r_struct
id|nandsim
op_star
)paren
(paren
id|chip
op_plus
l_int|1
)paren
suffix:semicolon
id|chip-&gt;priv
op_assign
(paren
r_void
op_star
)paren
id|nand
suffix:semicolon
multiline_comment|/*&n;&t; * Register simulator&squot;s callbacks.&n;&t; */
id|chip-&gt;hwcontrol
op_assign
id|ns_hwcontrol
suffix:semicolon
id|chip-&gt;read_byte
op_assign
id|ns_nand_read_byte
suffix:semicolon
id|chip-&gt;dev_ready
op_assign
id|ns_device_ready
suffix:semicolon
id|chip-&gt;scan_bbt
op_assign
id|ns_scan_bbt
suffix:semicolon
id|chip-&gt;write_byte
op_assign
id|ns_nand_write_byte
suffix:semicolon
id|chip-&gt;write_buf
op_assign
id|ns_nand_write_buf
suffix:semicolon
id|chip-&gt;read_buf
op_assign
id|ns_nand_read_buf
suffix:semicolon
id|chip-&gt;verify_buf
op_assign
id|ns_nand_verify_buf
suffix:semicolon
id|chip-&gt;write_word
op_assign
id|ns_nand_write_word
suffix:semicolon
id|chip-&gt;read_word
op_assign
id|ns_nand_read_word
suffix:semicolon
id|chip-&gt;eccmode
op_assign
id|NAND_ECC_SOFT
suffix:semicolon
multiline_comment|/* &n;&t; * Perform minimum nandsim structure initialization to handle&n;&t; * the initial ID read command correctly &n;&t; */
r_if
c_cond
(paren
id|third_id_byte
op_ne
l_int|0xFF
op_logical_or
id|fourth_id_byte
op_ne
l_int|0xFF
)paren
id|nand-&gt;geom.idbytes
op_assign
l_int|4
suffix:semicolon
r_else
id|nand-&gt;geom.idbytes
op_assign
l_int|2
suffix:semicolon
id|nand-&gt;regs.status
op_assign
id|NS_STATUS_OK
c_func
(paren
id|nand
)paren
suffix:semicolon
id|nand-&gt;nxstate
op_assign
id|STATE_UNKNOWN
suffix:semicolon
id|nand-&gt;options
op_or_assign
id|OPT_PAGE256
suffix:semicolon
multiline_comment|/* temporary value */
id|nand-&gt;ids
(braket
l_int|0
)braket
op_assign
id|first_id_byte
suffix:semicolon
id|nand-&gt;ids
(braket
l_int|1
)braket
op_assign
id|second_id_byte
suffix:semicolon
id|nand-&gt;ids
(braket
l_int|2
)braket
op_assign
id|third_id_byte
suffix:semicolon
id|nand-&gt;ids
(braket
l_int|3
)braket
op_assign
id|fourth_id_byte
suffix:semicolon
r_if
c_cond
(paren
id|bus_width
op_eq
l_int|16
)paren
(brace
id|nand-&gt;busw
op_assign
l_int|16
suffix:semicolon
id|chip-&gt;options
op_or_assign
id|NAND_BUSWIDTH_16
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|nand_scan
c_func
(paren
id|nsmtd
comma
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|NS_ERR
c_func
(paren
l_string|&quot;can&squot;t register NAND Simulator&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OG
l_int|0
)paren
id|retval
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* Register NAND as one big partition */
id|add_mtd_partitions
c_func
(paren
id|nsmtd
comma
op_amp
id|nand-&gt;part
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error
suffix:colon
id|kfree
c_func
(paren
id|nsmtd
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|ns_init_module
id|module_init
c_func
(paren
id|ns_init_module
)paren
suffix:semicolon
multiline_comment|/*&n; * Module clean-up function&n; */
DECL|function|ns_cleanup_module
r_static
r_void
id|__exit
id|ns_cleanup_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|nandsim
op_star
id|ns
op_assign
(paren
r_struct
id|nandsim
op_star
)paren
(paren
(paren
(paren
r_struct
id|nand_chip
op_star
)paren
id|nsmtd-&gt;priv
)paren
op_member_access_from_pointer
id|priv
)paren
suffix:semicolon
id|free_nandsim
c_func
(paren
id|ns
)paren
suffix:semicolon
multiline_comment|/* Free nandsim private resources */
id|nand_release
c_func
(paren
id|nsmtd
)paren
suffix:semicolon
multiline_comment|/* Unregisterd drived */
id|kfree
c_func
(paren
id|nsmtd
)paren
suffix:semicolon
multiline_comment|/* Free other structures */
)brace
DECL|variable|ns_cleanup_module
id|module_exit
c_func
(paren
id|ns_cleanup_module
)paren
suffix:semicolon
id|MODULE_LICENSE
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
(paren
l_string|&quot;Artem B. Bityuckiy&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
(paren
l_string|&quot;The NAND flash simulator&quot;
)paren
suffix:semicolon
eof
