multiline_comment|/*&n; *  drivers/mtd/nand_bbt.c&n; *&n; *  Overview:&n; *   Bad block table support for the NAND driver&n; *   &n; *  Copyright (C) 2004 Thomas Gleixner (tglx@linutronix.de)&n; *&n; * $Id: nand_bbt.c,v 1.28 2004/11/13 10:19:09 gleixner Exp $&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License version 2 as&n; * published by the Free Software Foundation.&n; *&n; * Description:&n; *&n; * When nand_scan_bbt is called, then it tries to find the bad block table &n; * depending on the options in the bbt descriptor(s). If a bbt is found &n; * then the contents are read and the memory based bbt is created. If a &n; * mirrored bbt is selected then the mirror is searched too and the&n; * versions are compared. If the mirror has a greater version number &n; * than the mirror bbt is used to build the memory based bbt.&n; * If the tables are not versioned, then we &quot;or&quot; the bad block information.&n; * If one of the bbt&squot;s is out of date or does not exist it is (re)created. &n; * If no bbt exists at all then the device is scanned for factory marked &n; * good / bad blocks and the bad block tables are created. &n; *&n; * For manufacturer created bbts like the one found on M-SYS DOC devices &n; * the bbt is searched and read but never created&n; *&n; * The autogenerated bad block table is located in the last good blocks &n; * of the device. The table is mirrored, so it can be updated eventually. &n; * The table is marked in the oob area with an ident pattern and a version &n; * number which indicates which of both tables is more up to date.&n; *&n; * The table uses 2 bits per block&n; * 11b: &t;block is good&n; * 00b: &t;block is factory marked bad&n; * 01b, 10b: &t;block is marked bad due to wear&n; *&n; * The memory bad block table uses the following scheme:&n; * 00b:&t;&t;block is good&n; * 01b:&t;&t;block is marked bad due to wear&n; * 10b:&t;&t;block is reserved (to protect the bbt area)&n; * 11b:&t;&t;block is factory marked bad&n; * &n; * Multichip devices like DOC store the bad block info per floor.&n; *&n; * Following assumptions are made:&n; * - bbts start at a page boundary, if autolocated on a block boundary&n; * - the space neccecary for a bbt in FLASH does not exceed a block boundary&n; * &n; */
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/mtd/nand.h&gt;
macro_line|#include &lt;linux/mtd/nand_ecc.h&gt;
macro_line|#include &lt;linux/mtd/compatmac.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
multiline_comment|/** &n; * check_pattern - [GENERIC] check if a pattern is in the buffer&n; * @buf:&t;the buffer to search&n; * @len:&t;the length of buffer to search&n; * @paglen:&t;the pagelength&n; * @td:&t;&t;search pattern descriptor&n; *&n; * Check for a pattern at the given place. Used to search bad block&n; * tables and good / bad block identifiers.&n; * If the SCAN_EMPTY option is set then check, if all bytes except the&n; * pattern area contain 0xff&n; *&n;*/
DECL|function|check_pattern
r_static
r_int
id|check_pattern
(paren
r_uint8
op_star
id|buf
comma
r_int
id|len
comma
r_int
id|paglen
comma
r_struct
id|nand_bbt_descr
op_star
id|td
)paren
(brace
r_int
id|i
comma
id|end
suffix:semicolon
r_uint8
op_star
id|p
op_assign
id|buf
suffix:semicolon
id|end
op_assign
id|paglen
op_plus
id|td-&gt;offs
suffix:semicolon
r_if
c_cond
(paren
id|td-&gt;options
op_amp
id|NAND_BBT_SCANEMPTY
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|end
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|p
(braket
id|i
)braket
op_ne
l_int|0xff
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|p
op_add_assign
id|end
suffix:semicolon
multiline_comment|/* Compare the pattern */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|td-&gt;len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|p
(braket
id|i
)braket
op_ne
id|td-&gt;pattern
(braket
id|i
)braket
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|p
op_add_assign
id|td-&gt;len
suffix:semicolon
id|end
op_add_assign
id|td-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|td-&gt;options
op_amp
id|NAND_BBT_SCANEMPTY
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|end
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_star
id|p
op_increment
op_ne
l_int|0xff
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * read_bbt - [GENERIC] Read the bad block table starting from page&n; * @mtd:&t;MTD device structure&n; * @buf:&t;temporary buffer&n; * @page:&t;the starting page&n; * @num:&t;the number of bbt descriptors to read&n; * @bits:&t;number of bits per block&n; * @offs:&t;offset in the memory table&n; * @reserved_block_code:&t;Pattern to identify reserved blocks&n; *&n; * Read the bad block table starting from page.&n; *&n; */
DECL|function|read_bbt
r_static
r_int
id|read_bbt
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_uint8
op_star
id|buf
comma
r_int
id|page
comma
r_int
id|num
comma
r_int
id|bits
comma
r_int
id|offs
comma
r_int
id|reserved_block_code
)paren
(brace
r_int
id|res
comma
id|i
comma
id|j
comma
id|act
op_assign
l_int|0
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_int
id|retlen
comma
id|len
comma
id|totlen
suffix:semicolon
id|loff_t
id|from
suffix:semicolon
r_uint8
id|msk
op_assign
(paren
r_uint8
)paren
(paren
(paren
l_int|1
op_lshift
id|bits
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|totlen
op_assign
(paren
id|num
op_star
id|bits
)paren
op_rshift
l_int|3
suffix:semicolon
id|from
op_assign
(paren
(paren
id|loff_t
)paren
id|page
)paren
op_lshift
id|this-&gt;page_shift
suffix:semicolon
r_while
c_loop
(paren
id|totlen
)paren
(brace
id|len
op_assign
id|min
(paren
id|totlen
comma
(paren
r_int
)paren
(paren
l_int|1
op_lshift
id|this-&gt;bbt_erase_shift
)paren
)paren
suffix:semicolon
id|res
op_assign
id|mtd-&gt;read_ecc
(paren
id|mtd
comma
id|from
comma
id|len
comma
op_amp
id|retlen
comma
id|buf
comma
l_int|NULL
comma
id|this-&gt;autooob
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|retlen
op_ne
id|len
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;nand_bbt: Error reading bad block table&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;nand_bbt: ECC error while reading bad block table&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Analyse data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_uint8
id|dat
op_assign
id|buf
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_add_assign
id|bits
comma
id|act
op_add_assign
l_int|2
)paren
(brace
r_uint8
id|tmp
op_assign
(paren
id|dat
op_rshift
id|j
)paren
op_amp
id|msk
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_eq
id|msk
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|reserved_block_code
op_logical_and
(paren
id|tmp
op_eq
id|reserved_block_code
)paren
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;nand_read_bbt: Reserved block at 0x%08x&bslash;n&quot;
comma
(paren
(paren
id|offs
op_lshift
l_int|2
)paren
op_plus
(paren
id|act
op_rshift
l_int|1
)paren
)paren
op_lshift
id|this-&gt;bbt_erase_shift
)paren
suffix:semicolon
id|this-&gt;bbt
(braket
id|offs
op_plus
(paren
id|act
op_rshift
l_int|3
)paren
)braket
op_or_assign
l_int|0x2
op_lshift
(paren
id|act
op_amp
l_int|0x06
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Leave it for now, if its matured we can move this&n;&t;&t;&t;&t; * message to MTD_DEBUG_LEVEL0 */
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;nand_read_bbt: Bad block at 0x%08x&bslash;n&quot;
comma
(paren
(paren
id|offs
op_lshift
l_int|2
)paren
op_plus
(paren
id|act
op_rshift
l_int|1
)paren
)paren
op_lshift
id|this-&gt;bbt_erase_shift
)paren
suffix:semicolon
multiline_comment|/* Factory marked bad or worn out ? */
r_if
c_cond
(paren
id|tmp
op_eq
l_int|0
)paren
id|this-&gt;bbt
(braket
id|offs
op_plus
(paren
id|act
op_rshift
l_int|3
)paren
)braket
op_or_assign
l_int|0x3
op_lshift
(paren
id|act
op_amp
l_int|0x06
)paren
suffix:semicolon
r_else
id|this-&gt;bbt
(braket
id|offs
op_plus
(paren
id|act
op_rshift
l_int|3
)paren
)braket
op_or_assign
l_int|0x1
op_lshift
(paren
id|act
op_amp
l_int|0x06
)paren
suffix:semicolon
)brace
)brace
id|totlen
op_sub_assign
id|len
suffix:semicolon
id|from
op_add_assign
id|len
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * read_abs_bbt - [GENERIC] Read the bad block table starting at a given page&n; * @mtd:&t;MTD device structure&n; * @buf:&t;temporary buffer&n; * @td:&t;&t;descriptor for the bad block table &n; * @chip:&t;read the table for a specific chip, -1 read all chips.&n; *&t;&t;Applies only if NAND_BBT_PERCHIP option is set&n; *&n; * Read the bad block table for all chips starting at a given page&n; * We assume that the bbt bits are in consecutive order.&n;*/
DECL|function|read_abs_bbt
r_static
r_int
id|read_abs_bbt
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_uint8
op_star
id|buf
comma
r_struct
id|nand_bbt_descr
op_star
id|td
comma
r_int
id|chip
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_int
id|res
op_assign
l_int|0
comma
id|i
suffix:semicolon
r_int
id|bits
suffix:semicolon
id|bits
op_assign
id|td-&gt;options
op_amp
id|NAND_BBT_NRBITS_MSK
suffix:semicolon
r_if
c_cond
(paren
id|td-&gt;options
op_amp
id|NAND_BBT_PERCHIP
)paren
(brace
r_int
id|offs
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|this-&gt;numchips
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|chip
op_eq
op_minus
l_int|1
op_logical_or
id|chip
op_eq
id|i
)paren
id|res
op_assign
id|read_bbt
(paren
id|mtd
comma
id|buf
comma
id|td-&gt;pages
(braket
id|i
)braket
comma
id|this-&gt;chipsize
op_rshift
id|this-&gt;bbt_erase_shift
comma
id|bits
comma
id|offs
comma
id|td-&gt;reserved_block_code
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
r_return
id|res
suffix:semicolon
id|offs
op_add_assign
id|this-&gt;chipsize
op_rshift
(paren
id|this-&gt;bbt_erase_shift
op_plus
l_int|2
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|res
op_assign
id|read_bbt
(paren
id|mtd
comma
id|buf
comma
id|td-&gt;pages
(braket
l_int|0
)braket
comma
id|mtd-&gt;size
op_rshift
id|this-&gt;bbt_erase_shift
comma
id|bits
comma
l_int|0
comma
id|td-&gt;reserved_block_code
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
r_return
id|res
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * read_abs_bbts - [GENERIC] Read the bad block table(s) for all chips starting at a given page&n; * @mtd:&t;MTD device structure&n; * @buf:&t;temporary buffer&n; * @td:&t;&t;descriptor for the bad block table &n; * @md:&t;&t;descriptor for the bad block table mirror&n; *&n; * Read the bad block table(s) for all chips starting at a given page&n; * We assume that the bbt bits are in consecutive order.&n; *&n;*/
DECL|function|read_abs_bbts
r_static
r_int
id|read_abs_bbts
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_uint8
op_star
id|buf
comma
r_struct
id|nand_bbt_descr
op_star
id|td
comma
r_struct
id|nand_bbt_descr
op_star
id|md
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
multiline_comment|/* Read the primary version, if available */
r_if
c_cond
(paren
id|td-&gt;options
op_amp
id|NAND_BBT_VERSION
)paren
(brace
id|nand_read_raw
(paren
id|mtd
comma
id|buf
comma
id|td-&gt;pages
(braket
l_int|0
)braket
op_lshift
id|this-&gt;page_shift
comma
id|mtd-&gt;oobblock
comma
id|mtd-&gt;oobsize
)paren
suffix:semicolon
id|td-&gt;version
(braket
l_int|0
)braket
op_assign
id|buf
(braket
id|mtd-&gt;oobblock
op_plus
id|td-&gt;veroffs
)braket
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;Bad block table at page %d, version 0x%02X&bslash;n&quot;
comma
id|td-&gt;pages
(braket
l_int|0
)braket
comma
id|td-&gt;version
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Read the mirror version, if available */
r_if
c_cond
(paren
id|md
op_logical_and
(paren
id|md-&gt;options
op_amp
id|NAND_BBT_VERSION
)paren
)paren
(brace
id|nand_read_raw
(paren
id|mtd
comma
id|buf
comma
id|md-&gt;pages
(braket
l_int|0
)braket
op_lshift
id|this-&gt;page_shift
comma
id|mtd-&gt;oobblock
comma
id|mtd-&gt;oobsize
)paren
suffix:semicolon
id|md-&gt;version
(braket
l_int|0
)braket
op_assign
id|buf
(braket
id|mtd-&gt;oobblock
op_plus
id|md-&gt;veroffs
)braket
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;Bad block table at page %d, version 0x%02X&bslash;n&quot;
comma
id|md-&gt;pages
(braket
l_int|0
)braket
comma
id|md-&gt;version
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * create_bbt - [GENERIC] Create a bad block table by scanning the device&n; * @mtd:&t;MTD device structure&n; * @buf:&t;temporary buffer&n; * @bd:&t;&t;descriptor for the good/bad block search pattern&n; * @chip:&t;create the table for a specific chip, -1 read all chips.&n; *&t;&t;Applies only if NAND_BBT_PERCHIP option is set&n; *&n; * Create a bad block table by scanning the device&n; * for the given good/bad block identify pattern&n; */
DECL|function|create_bbt
r_static
r_void
id|create_bbt
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_uint8
op_star
id|buf
comma
r_struct
id|nand_bbt_descr
op_star
id|bd
comma
r_int
id|chip
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|numblocks
comma
id|len
comma
id|scanlen
suffix:semicolon
r_int
id|startblock
suffix:semicolon
id|loff_t
id|from
suffix:semicolon
r_int
id|readlen
comma
id|ooblen
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;Scanning device for bad blocks&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bd-&gt;options
op_amp
id|NAND_BBT_SCANALLPAGES
)paren
id|len
op_assign
l_int|1
op_lshift
(paren
id|this-&gt;bbt_erase_shift
op_minus
id|this-&gt;page_shift
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|bd-&gt;options
op_amp
id|NAND_BBT_SCAN2NDPAGE
)paren
id|len
op_assign
l_int|2
suffix:semicolon
r_else
id|len
op_assign
l_int|1
suffix:semicolon
)brace
id|scanlen
op_assign
id|mtd-&gt;oobblock
op_plus
id|mtd-&gt;oobsize
suffix:semicolon
id|readlen
op_assign
id|len
op_star
id|mtd-&gt;oobblock
suffix:semicolon
id|ooblen
op_assign
id|len
op_star
id|mtd-&gt;oobsize
suffix:semicolon
r_if
c_cond
(paren
id|chip
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Note that numblocks is 2 * (real numblocks) here, see i+=2 below as it&n;&t;&t; * makes shifting and masking less painful */
id|numblocks
op_assign
id|mtd-&gt;size
op_rshift
(paren
id|this-&gt;bbt_erase_shift
op_minus
l_int|1
)paren
suffix:semicolon
id|startblock
op_assign
l_int|0
suffix:semicolon
id|from
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|chip
op_ge
id|this-&gt;numchips
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;create_bbt(): chipnr (%d) &gt; available chips (%d)&bslash;n&quot;
comma
id|chip
op_plus
l_int|1
comma
id|this-&gt;numchips
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|numblocks
op_assign
id|this-&gt;chipsize
op_rshift
(paren
id|this-&gt;bbt_erase_shift
op_minus
l_int|1
)paren
suffix:semicolon
id|startblock
op_assign
id|chip
op_star
id|numblocks
suffix:semicolon
id|numblocks
op_add_assign
id|startblock
suffix:semicolon
id|from
op_assign
id|startblock
op_lshift
(paren
id|this-&gt;bbt_erase_shift
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|startblock
suffix:semicolon
id|i
OL
id|numblocks
suffix:semicolon
)paren
(brace
id|nand_read_raw
(paren
id|mtd
comma
id|buf
comma
id|from
comma
id|readlen
comma
id|ooblen
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|len
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|check_pattern
(paren
op_amp
id|buf
(braket
id|j
op_star
id|scanlen
)braket
comma
id|scanlen
comma
id|mtd-&gt;oobblock
comma
id|bd
)paren
)paren
(brace
id|this-&gt;bbt
(braket
id|i
op_rshift
l_int|3
)braket
op_or_assign
l_int|0x03
op_lshift
(paren
id|i
op_amp
l_int|0x6
)paren
suffix:semicolon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;Bad eraseblock %d at 0x%08x&bslash;n&quot;
comma
id|i
op_rshift
l_int|1
comma
(paren
r_int
r_int
)paren
id|from
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|i
op_add_assign
l_int|2
suffix:semicolon
id|from
op_add_assign
(paren
l_int|1
op_lshift
id|this-&gt;bbt_erase_shift
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * search_bbt - [GENERIC] scan the device for a specific bad block table&n; * @mtd:&t;MTD device structure&n; * @buf:&t;temporary buffer&n; * @td:&t;&t;descriptor for the bad block table&n; *&n; * Read the bad block table by searching for a given ident pattern.&n; * Search is preformed either from the beginning up or from the end of &n; * the device downwards. The search starts always at the start of a&n; * block.&n; * If the option NAND_BBT_PERCHIP is given, each chip is searched &n; * for a bbt, which contains the bad block information of this chip.&n; * This is neccecary to provide support for certain DOC devices.&n; *&n; * The bbt ident pattern resides in the oob area of the first page &n; * in a block. &n; */
DECL|function|search_bbt
r_static
r_int
id|search_bbt
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_uint8
op_star
id|buf
comma
r_struct
id|nand_bbt_descr
op_star
id|td
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_int
id|i
comma
id|chips
suffix:semicolon
r_int
id|bits
comma
id|startblock
comma
id|block
comma
id|dir
suffix:semicolon
r_int
id|scanlen
op_assign
id|mtd-&gt;oobblock
op_plus
id|mtd-&gt;oobsize
suffix:semicolon
r_int
id|bbtblocks
suffix:semicolon
multiline_comment|/* Search direction top -&gt; down ? */
r_if
c_cond
(paren
id|td-&gt;options
op_amp
id|NAND_BBT_LASTBLOCK
)paren
(brace
id|startblock
op_assign
(paren
id|mtd-&gt;size
op_rshift
id|this-&gt;bbt_erase_shift
)paren
op_minus
l_int|1
suffix:semicolon
id|dir
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|startblock
op_assign
l_int|0
suffix:semicolon
id|dir
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Do we have a bbt per chip ? */
r_if
c_cond
(paren
id|td-&gt;options
op_amp
id|NAND_BBT_PERCHIP
)paren
(brace
id|chips
op_assign
id|this-&gt;numchips
suffix:semicolon
id|bbtblocks
op_assign
id|this-&gt;chipsize
op_rshift
id|this-&gt;bbt_erase_shift
suffix:semicolon
id|startblock
op_and_assign
id|bbtblocks
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|chips
op_assign
l_int|1
suffix:semicolon
id|bbtblocks
op_assign
id|mtd-&gt;size
op_rshift
id|this-&gt;bbt_erase_shift
suffix:semicolon
)brace
multiline_comment|/* Number of bits for each erase block in the bbt */
id|bits
op_assign
id|td-&gt;options
op_amp
id|NAND_BBT_NRBITS_MSK
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|chips
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Reset version information */
id|td-&gt;version
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|td-&gt;pages
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Scan the maximum number of blocks */
r_for
c_loop
(paren
id|block
op_assign
l_int|0
suffix:semicolon
id|block
OL
id|td-&gt;maxblocks
suffix:semicolon
id|block
op_increment
)paren
(brace
r_int
id|actblock
op_assign
id|startblock
op_plus
id|dir
op_star
id|block
suffix:semicolon
multiline_comment|/* Read first page */
id|nand_read_raw
(paren
id|mtd
comma
id|buf
comma
id|actblock
op_lshift
id|this-&gt;bbt_erase_shift
comma
id|mtd-&gt;oobblock
comma
id|mtd-&gt;oobsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|check_pattern
c_func
(paren
id|buf
comma
id|scanlen
comma
id|mtd-&gt;oobblock
comma
id|td
)paren
)paren
(brace
id|td-&gt;pages
(braket
id|i
)braket
op_assign
id|actblock
op_lshift
(paren
id|this-&gt;bbt_erase_shift
op_minus
id|this-&gt;page_shift
)paren
suffix:semicolon
r_if
c_cond
(paren
id|td-&gt;options
op_amp
id|NAND_BBT_VERSION
)paren
(brace
id|td-&gt;version
(braket
id|i
)braket
op_assign
id|buf
(braket
id|mtd-&gt;oobblock
op_plus
id|td-&gt;veroffs
)braket
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
id|startblock
op_add_assign
id|this-&gt;chipsize
op_rshift
id|this-&gt;bbt_erase_shift
suffix:semicolon
)brace
multiline_comment|/* Check, if we found a bbt for each requested chip */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|chips
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|td-&gt;pages
(braket
id|i
)braket
op_eq
op_minus
l_int|1
)paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;Bad block table not found for chip %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_else
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;Bad block table found at page %d, version 0x%02X&bslash;n&quot;
comma
id|td-&gt;pages
(braket
id|i
)braket
comma
id|td-&gt;version
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * search_read_bbts - [GENERIC] scan the device for bad block table(s)&n; * @mtd:&t;MTD device structure&n; * @buf:&t;temporary buffer&n; * @td:&t;&t;descriptor for the bad block table &n; * @md:&t;&t;descriptor for the bad block table mirror&n; *&n; * Search and read the bad block table(s)&n;*/
DECL|function|search_read_bbts
r_static
r_int
id|search_read_bbts
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_uint8
op_star
id|buf
comma
r_struct
id|nand_bbt_descr
op_star
id|td
comma
r_struct
id|nand_bbt_descr
op_star
id|md
)paren
(brace
multiline_comment|/* Search the primary table */
id|search_bbt
(paren
id|mtd
comma
id|buf
comma
id|td
)paren
suffix:semicolon
multiline_comment|/* Search the mirror table */
r_if
c_cond
(paren
id|md
)paren
id|search_bbt
(paren
id|mtd
comma
id|buf
comma
id|md
)paren
suffix:semicolon
multiline_comment|/* Force result check */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/** &n; * write_bbt - [GENERIC] (Re)write the bad block table&n; *&n; * @mtd:&t;MTD device structure&n; * @buf:&t;temporary buffer&n; * @td:&t;&t;descriptor for the bad block table &n; * @md:&t;&t;descriptor for the bad block table mirror&n; * @chipsel:&t;selector for a specific chip, -1 for all&n; *&n; * (Re)write the bad block table&n; *&n;*/
DECL|function|write_bbt
r_static
r_int
id|write_bbt
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_uint8
op_star
id|buf
comma
r_struct
id|nand_bbt_descr
op_star
id|td
comma
r_struct
id|nand_bbt_descr
op_star
id|md
comma
r_int
id|chipsel
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|nand_oobinfo
id|oobinfo
suffix:semicolon
r_struct
id|erase_info
id|einfo
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|res
comma
id|chip
op_assign
l_int|0
suffix:semicolon
r_int
id|bits
comma
id|startblock
comma
id|dir
comma
id|page
comma
id|offs
comma
id|numblocks
comma
id|sft
comma
id|sftmsk
suffix:semicolon
r_int
id|nrchips
comma
id|bbtoffs
comma
id|pageoffs
suffix:semicolon
r_uint8
id|msk
(braket
l_int|4
)braket
suffix:semicolon
r_uint8
id|rcode
op_assign
id|td-&gt;reserved_block_code
suffix:semicolon
r_int
id|retlen
comma
id|len
op_assign
l_int|0
suffix:semicolon
id|loff_t
id|to
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rcode
)paren
id|rcode
op_assign
l_int|0xff
suffix:semicolon
multiline_comment|/* Write bad block table per chip rather than per device ? */
r_if
c_cond
(paren
id|td-&gt;options
op_amp
id|NAND_BBT_PERCHIP
)paren
(brace
id|numblocks
op_assign
(paren
r_int
)paren
(paren
id|this-&gt;chipsize
op_rshift
id|this-&gt;bbt_erase_shift
)paren
suffix:semicolon
multiline_comment|/* Full device write or specific chip ? */
r_if
c_cond
(paren
id|chipsel
op_eq
op_minus
l_int|1
)paren
(brace
id|nrchips
op_assign
id|this-&gt;numchips
suffix:semicolon
)brace
r_else
(brace
id|nrchips
op_assign
id|chipsel
op_plus
l_int|1
suffix:semicolon
id|chip
op_assign
id|chipsel
suffix:semicolon
)brace
)brace
r_else
(brace
id|numblocks
op_assign
(paren
r_int
)paren
(paren
id|mtd-&gt;size
op_rshift
id|this-&gt;bbt_erase_shift
)paren
suffix:semicolon
id|nrchips
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Loop through the chips */
r_for
c_loop
(paren
suffix:semicolon
id|chip
OL
id|nrchips
suffix:semicolon
id|chip
op_increment
)paren
(brace
multiline_comment|/* There was already a version of the table, reuse the page &n;&t;&t; * This applies for absolute placement too, as we have the &n;&t;&t; * page nr. in td-&gt;pages.&n;&t;&t; */
r_if
c_cond
(paren
id|td-&gt;pages
(braket
id|chip
)braket
op_ne
op_minus
l_int|1
)paren
(brace
id|page
op_assign
id|td-&gt;pages
(braket
id|chip
)braket
suffix:semicolon
r_goto
id|write
suffix:semicolon
)brace
multiline_comment|/* Automatic placement of the bad block table */
multiline_comment|/* Search direction top -&gt; down ? */
r_if
c_cond
(paren
id|td-&gt;options
op_amp
id|NAND_BBT_LASTBLOCK
)paren
(brace
id|startblock
op_assign
id|numblocks
op_star
(paren
id|chip
op_plus
l_int|1
)paren
op_minus
l_int|1
suffix:semicolon
id|dir
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|startblock
op_assign
id|chip
op_star
id|numblocks
suffix:semicolon
id|dir
op_assign
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|td-&gt;maxblocks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|block
op_assign
id|startblock
op_plus
id|dir
op_star
id|i
suffix:semicolon
multiline_comment|/* Check, if the block is bad */
r_switch
c_cond
(paren
(paren
id|this-&gt;bbt
(braket
id|block
op_rshift
l_int|2
)braket
op_rshift
(paren
l_int|2
op_star
(paren
id|block
op_amp
l_int|0x03
)paren
)paren
)paren
op_amp
l_int|0x03
)paren
(brace
r_case
l_int|0x01
suffix:colon
r_case
l_int|0x03
suffix:colon
r_continue
suffix:semicolon
)brace
id|page
op_assign
id|block
op_lshift
(paren
id|this-&gt;bbt_erase_shift
op_minus
id|this-&gt;page_shift
)paren
suffix:semicolon
multiline_comment|/* Check, if the block is used by the mirror table */
r_if
c_cond
(paren
op_logical_neg
id|md
op_logical_or
id|md-&gt;pages
(braket
id|chip
)braket
op_ne
id|page
)paren
r_goto
id|write
suffix:semicolon
)brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;No space left to write bad block table&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
id|write
suffix:colon
multiline_comment|/* Set up shift count and masks for the flash table */
id|bits
op_assign
id|td-&gt;options
op_amp
id|NAND_BBT_NRBITS_MSK
suffix:semicolon
r_switch
c_cond
(paren
id|bits
)paren
(brace
r_case
l_int|1
suffix:colon
id|sft
op_assign
l_int|3
suffix:semicolon
id|sftmsk
op_assign
l_int|0x07
suffix:semicolon
id|msk
(braket
l_int|0
)braket
op_assign
l_int|0x00
suffix:semicolon
id|msk
(braket
l_int|1
)braket
op_assign
l_int|0x01
suffix:semicolon
id|msk
(braket
l_int|2
)braket
op_assign
op_complement
id|rcode
suffix:semicolon
id|msk
(braket
l_int|3
)braket
op_assign
l_int|0x01
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|sft
op_assign
l_int|2
suffix:semicolon
id|sftmsk
op_assign
l_int|0x06
suffix:semicolon
id|msk
(braket
l_int|0
)braket
op_assign
l_int|0x00
suffix:semicolon
id|msk
(braket
l_int|1
)braket
op_assign
l_int|0x01
suffix:semicolon
id|msk
(braket
l_int|2
)braket
op_assign
op_complement
id|rcode
suffix:semicolon
id|msk
(braket
l_int|3
)braket
op_assign
l_int|0x03
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|sft
op_assign
l_int|1
suffix:semicolon
id|sftmsk
op_assign
l_int|0x04
suffix:semicolon
id|msk
(braket
l_int|0
)braket
op_assign
l_int|0x00
suffix:semicolon
id|msk
(braket
l_int|1
)braket
op_assign
l_int|0x0C
suffix:semicolon
id|msk
(braket
l_int|2
)braket
op_assign
op_complement
id|rcode
suffix:semicolon
id|msk
(braket
l_int|3
)braket
op_assign
l_int|0x0f
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
id|sft
op_assign
l_int|0
suffix:semicolon
id|sftmsk
op_assign
l_int|0x00
suffix:semicolon
id|msk
(braket
l_int|0
)braket
op_assign
l_int|0x00
suffix:semicolon
id|msk
(braket
l_int|1
)braket
op_assign
l_int|0x0F
suffix:semicolon
id|msk
(braket
l_int|2
)braket
op_assign
op_complement
id|rcode
suffix:semicolon
id|msk
(braket
l_int|3
)braket
op_assign
l_int|0xff
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|bbtoffs
op_assign
id|chip
op_star
(paren
id|numblocks
op_rshift
l_int|2
)paren
suffix:semicolon
id|to
op_assign
(paren
(paren
id|loff_t
)paren
id|page
)paren
op_lshift
id|this-&gt;page_shift
suffix:semicolon
id|memcpy
(paren
op_amp
id|oobinfo
comma
id|this-&gt;autooob
comma
r_sizeof
(paren
id|oobinfo
)paren
)paren
suffix:semicolon
id|oobinfo.useecc
op_assign
id|MTD_NANDECC_PLACEONLY
suffix:semicolon
multiline_comment|/* Must we save the block contents ? */
r_if
c_cond
(paren
id|td-&gt;options
op_amp
id|NAND_BBT_SAVECONTENT
)paren
(brace
multiline_comment|/* Make it block aligned */
id|to
op_and_assign
op_complement
(paren
(paren
id|loff_t
)paren
(paren
(paren
l_int|1
op_lshift
id|this-&gt;bbt_erase_shift
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|len
op_assign
l_int|1
op_lshift
id|this-&gt;bbt_erase_shift
suffix:semicolon
id|res
op_assign
id|mtd-&gt;read_ecc
(paren
id|mtd
comma
id|to
comma
id|len
comma
op_amp
id|retlen
comma
id|buf
comma
op_amp
id|buf
(braket
id|len
)braket
comma
op_amp
id|oobinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|retlen
op_ne
id|len
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;nand_bbt: Error reading block for writing the bad block table&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;nand_bbt: ECC error while reading block for writing bad block table&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Calc the byte offset in the buffer */
id|pageoffs
op_assign
id|page
op_minus
(paren
r_int
)paren
(paren
id|to
op_rshift
id|this-&gt;page_shift
)paren
suffix:semicolon
id|offs
op_assign
id|pageoffs
op_lshift
id|this-&gt;page_shift
suffix:semicolon
multiline_comment|/* Preset the bbt area with 0xff */
id|memset
(paren
op_amp
id|buf
(braket
id|offs
)braket
comma
l_int|0xff
comma
(paren
r_int
)paren
(paren
id|numblocks
op_rshift
id|sft
)paren
)paren
suffix:semicolon
multiline_comment|/* Preset the bbt&squot;s oob area with 0xff */
id|memset
(paren
op_amp
id|buf
(braket
id|len
op_plus
id|pageoffs
op_star
id|mtd-&gt;oobsize
)braket
comma
l_int|0xff
comma
(paren
(paren
id|len
op_rshift
id|this-&gt;page_shift
)paren
op_minus
id|pageoffs
)paren
op_star
id|mtd-&gt;oobsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|td-&gt;options
op_amp
id|NAND_BBT_VERSION
)paren
(brace
id|buf
(braket
id|len
op_plus
(paren
id|pageoffs
op_star
id|mtd-&gt;oobsize
)paren
op_plus
id|td-&gt;veroffs
)braket
op_assign
id|td-&gt;version
(braket
id|chip
)braket
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Calc length */
id|len
op_assign
(paren
r_int
)paren
(paren
id|numblocks
op_rshift
id|sft
)paren
suffix:semicolon
multiline_comment|/* Make it page aligned ! */
id|len
op_assign
(paren
id|len
op_plus
(paren
id|mtd-&gt;oobblock
op_minus
l_int|1
)paren
)paren
op_amp
op_complement
(paren
id|mtd-&gt;oobblock
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Preset the buffer with 0xff */
id|memset
(paren
id|buf
comma
l_int|0xff
comma
id|len
op_plus
(paren
id|len
op_rshift
id|this-&gt;page_shift
)paren
op_star
id|mtd-&gt;oobsize
)paren
suffix:semicolon
id|offs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Pattern is located in oob area of first page */
id|memcpy
(paren
op_amp
id|buf
(braket
id|len
op_plus
id|td-&gt;offs
)braket
comma
id|td-&gt;pattern
comma
id|td-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|td-&gt;options
op_amp
id|NAND_BBT_VERSION
)paren
(brace
id|buf
(braket
id|len
op_plus
id|td-&gt;veroffs
)braket
op_assign
id|td-&gt;version
(braket
id|chip
)braket
suffix:semicolon
)brace
)brace
multiline_comment|/* walk through the memory table */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numblocks
suffix:semicolon
)paren
(brace
r_uint8
id|dat
suffix:semicolon
id|dat
op_assign
id|this-&gt;bbt
(braket
id|bbtoffs
op_plus
(paren
id|i
op_rshift
l_int|2
)paren
)braket
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|4
suffix:semicolon
id|j
op_increment
comma
id|i
op_increment
)paren
(brace
r_int
id|sftcnt
op_assign
(paren
id|i
op_lshift
(paren
l_int|3
op_minus
id|sft
)paren
)paren
op_amp
id|sftmsk
suffix:semicolon
multiline_comment|/* Do not store the reserved bbt blocks ! */
id|buf
(braket
id|offs
op_plus
(paren
id|i
op_rshift
id|sft
)paren
)braket
op_and_assign
op_complement
(paren
id|msk
(braket
id|dat
op_amp
l_int|0x03
)braket
op_lshift
id|sftcnt
)paren
suffix:semicolon
id|dat
op_rshift_assign
l_int|2
suffix:semicolon
)brace
)brace
id|memset
(paren
op_amp
id|einfo
comma
l_int|0
comma
r_sizeof
(paren
id|einfo
)paren
)paren
suffix:semicolon
id|einfo.mtd
op_assign
id|mtd
suffix:semicolon
id|einfo.addr
op_assign
(paren
r_int
r_int
)paren
id|to
suffix:semicolon
id|einfo.len
op_assign
l_int|1
op_lshift
id|this-&gt;bbt_erase_shift
suffix:semicolon
id|res
op_assign
id|nand_erase_nand
(paren
id|mtd
comma
op_amp
id|einfo
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
OL
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;nand_bbt: Error during block erase: %d&bslash;n&quot;
comma
id|res
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
id|res
op_assign
id|mtd-&gt;write_ecc
(paren
id|mtd
comma
id|to
comma
id|len
comma
op_amp
id|retlen
comma
id|buf
comma
op_amp
id|buf
(braket
id|len
)braket
comma
op_amp
id|oobinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
OL
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;nand_bbt: Error while writing bad block table %d&bslash;n&quot;
comma
id|res
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;Bad block table written to 0x%08x, version 0x%02X&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|to
comma
id|td-&gt;version
(braket
id|chip
)braket
)paren
suffix:semicolon
multiline_comment|/* Mark it as used */
id|td-&gt;pages
(braket
id|chip
)braket
op_assign
id|page
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_memory_bbt - [GENERIC] create a memory based bad block table&n; * @mtd:&t;MTD device structure&n; * @bd:&t;&t;descriptor for the good/bad block search pattern&n; *&n; * The function creates a memory based bbt by scanning the device &n; * for manufacturer / software marked good / bad blocks&n;*/
DECL|function|nand_memory_bbt
r_static
r_int
id|nand_memory_bbt
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|nand_bbt_descr
op_star
id|bd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
multiline_comment|/* Ensure that we only scan for the pattern and nothing else */
id|bd-&gt;options
op_assign
l_int|0
suffix:semicolon
id|create_bbt
(paren
id|mtd
comma
id|this-&gt;data_buf
comma
id|bd
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * check_create - [GENERIC] create and write bbt(s) if neccecary&n; * @mtd:&t;MTD device structure&n; * @buf:&t;temporary buffer&n; * @bd:&t;&t;descriptor for the good/bad block search pattern&n; *&n; * The function checks the results of the previous call to read_bbt&n; * and creates / updates the bbt(s) if neccecary&n; * Creation is neccecary if no bbt was found for the chip/device&n; * Update is neccecary if one of the tables is missing or the&n; * version nr. of one table is less than the other&n;*/
DECL|function|check_create
r_static
r_int
id|check_create
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_uint8
op_star
id|buf
comma
r_struct
id|nand_bbt_descr
op_star
id|bd
)paren
(brace
r_int
id|i
comma
id|chips
comma
id|writeops
comma
id|chipsel
comma
id|res
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|nand_bbt_descr
op_star
id|td
op_assign
id|this-&gt;bbt_td
suffix:semicolon
r_struct
id|nand_bbt_descr
op_star
id|md
op_assign
id|this-&gt;bbt_md
suffix:semicolon
r_struct
id|nand_bbt_descr
op_star
id|rd
comma
op_star
id|rd2
suffix:semicolon
multiline_comment|/* Do we have a bbt per chip ? */
r_if
c_cond
(paren
id|td-&gt;options
op_amp
id|NAND_BBT_PERCHIP
)paren
id|chips
op_assign
id|this-&gt;numchips
suffix:semicolon
r_else
id|chips
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|chips
suffix:semicolon
id|i
op_increment
)paren
(brace
id|writeops
op_assign
l_int|0
suffix:semicolon
id|rd
op_assign
l_int|NULL
suffix:semicolon
id|rd2
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Per chip or per device ? */
id|chipsel
op_assign
(paren
id|td-&gt;options
op_amp
id|NAND_BBT_PERCHIP
)paren
ques
c_cond
id|i
suffix:colon
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Mirrored table avilable ? */
r_if
c_cond
(paren
id|md
)paren
(brace
r_if
c_cond
(paren
id|td-&gt;pages
(braket
id|i
)braket
op_eq
op_minus
l_int|1
op_logical_and
id|md-&gt;pages
(braket
id|i
)braket
op_eq
op_minus
l_int|1
)paren
(brace
id|writeops
op_assign
l_int|0x03
suffix:semicolon
r_goto
id|create
suffix:semicolon
)brace
r_if
c_cond
(paren
id|td-&gt;pages
(braket
id|i
)braket
op_eq
op_minus
l_int|1
)paren
(brace
id|rd
op_assign
id|md
suffix:semicolon
id|td-&gt;version
(braket
id|i
)braket
op_assign
id|md-&gt;version
(braket
id|i
)braket
suffix:semicolon
id|writeops
op_assign
l_int|1
suffix:semicolon
r_goto
id|writecheck
suffix:semicolon
)brace
r_if
c_cond
(paren
id|md-&gt;pages
(braket
id|i
)braket
op_eq
op_minus
l_int|1
)paren
(brace
id|rd
op_assign
id|td
suffix:semicolon
id|md-&gt;version
(braket
id|i
)braket
op_assign
id|td-&gt;version
(braket
id|i
)braket
suffix:semicolon
id|writeops
op_assign
l_int|2
suffix:semicolon
r_goto
id|writecheck
suffix:semicolon
)brace
r_if
c_cond
(paren
id|td-&gt;version
(braket
id|i
)braket
op_eq
id|md-&gt;version
(braket
id|i
)braket
)paren
(brace
id|rd
op_assign
id|td
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|td-&gt;options
op_amp
id|NAND_BBT_VERSION
)paren
)paren
id|rd2
op_assign
id|md
suffix:semicolon
r_goto
id|writecheck
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
r_int8
)paren
(paren
id|td-&gt;version
(braket
id|i
)braket
op_minus
id|md-&gt;version
(braket
id|i
)braket
)paren
)paren
OG
l_int|0
)paren
(brace
id|rd
op_assign
id|td
suffix:semicolon
id|md-&gt;version
(braket
id|i
)braket
op_assign
id|td-&gt;version
(braket
id|i
)braket
suffix:semicolon
id|writeops
op_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|rd
op_assign
id|md
suffix:semicolon
id|td-&gt;version
(braket
id|i
)braket
op_assign
id|md-&gt;version
(braket
id|i
)braket
suffix:semicolon
id|writeops
op_assign
l_int|1
suffix:semicolon
)brace
r_goto
id|writecheck
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|td-&gt;pages
(braket
id|i
)braket
op_eq
op_minus
l_int|1
)paren
(brace
id|writeops
op_assign
l_int|0x01
suffix:semicolon
r_goto
id|create
suffix:semicolon
)brace
id|rd
op_assign
id|td
suffix:semicolon
r_goto
id|writecheck
suffix:semicolon
)brace
id|create
suffix:colon
multiline_comment|/* Create the bad block table by scanning the device ? */
r_if
c_cond
(paren
op_logical_neg
(paren
id|td-&gt;options
op_amp
id|NAND_BBT_CREATE
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Create the table in memory by scanning the chip(s) */
id|create_bbt
(paren
id|mtd
comma
id|buf
comma
id|bd
comma
id|chipsel
)paren
suffix:semicolon
id|td-&gt;version
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|md
)paren
id|md-&gt;version
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
id|writecheck
suffix:colon
multiline_comment|/* read back first ? */
r_if
c_cond
(paren
id|rd
)paren
id|read_abs_bbt
(paren
id|mtd
comma
id|buf
comma
id|rd
comma
id|chipsel
)paren
suffix:semicolon
multiline_comment|/* If they weren&squot;t versioned, read both. */
r_if
c_cond
(paren
id|rd2
)paren
id|read_abs_bbt
(paren
id|mtd
comma
id|buf
comma
id|rd2
comma
id|chipsel
)paren
suffix:semicolon
multiline_comment|/* Write the bad block table to the device ? */
r_if
c_cond
(paren
(paren
id|writeops
op_amp
l_int|0x01
)paren
op_logical_and
(paren
id|td-&gt;options
op_amp
id|NAND_BBT_WRITE
)paren
)paren
(brace
id|res
op_assign
id|write_bbt
(paren
id|mtd
comma
id|buf
comma
id|td
comma
id|md
comma
id|chipsel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
OL
l_int|0
)paren
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/* Write the mirror bad block table to the device ? */
r_if
c_cond
(paren
(paren
id|writeops
op_amp
l_int|0x02
)paren
op_logical_and
id|md
op_logical_and
(paren
id|md-&gt;options
op_amp
id|NAND_BBT_WRITE
)paren
)paren
(brace
id|res
op_assign
id|write_bbt
(paren
id|mtd
comma
id|buf
comma
id|md
comma
id|td
comma
id|chipsel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
OL
l_int|0
)paren
r_return
id|res
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * mark_bbt_regions - [GENERIC] mark the bad block table regions &n; * @mtd:&t;MTD device structure&n; * @td:&t;&t;bad block table descriptor&n; *&n; * The bad block table regions are marked as &quot;bad&quot; to prevent&n; * accidental erasures / writes. The regions are identified by&n; * the mark 0x02.&n;*/
DECL|function|mark_bbt_region
r_static
r_void
id|mark_bbt_region
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|nand_bbt_descr
op_star
id|td
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|chips
comma
id|block
comma
id|nrblocks
comma
id|update
suffix:semicolon
r_uint8
id|oldval
comma
id|newval
suffix:semicolon
multiline_comment|/* Do we have a bbt per chip ? */
r_if
c_cond
(paren
id|td-&gt;options
op_amp
id|NAND_BBT_PERCHIP
)paren
(brace
id|chips
op_assign
id|this-&gt;numchips
suffix:semicolon
id|nrblocks
op_assign
(paren
r_int
)paren
(paren
id|this-&gt;chipsize
op_rshift
id|this-&gt;bbt_erase_shift
)paren
suffix:semicolon
)brace
r_else
(brace
id|chips
op_assign
l_int|1
suffix:semicolon
id|nrblocks
op_assign
(paren
r_int
)paren
(paren
id|mtd-&gt;size
op_rshift
id|this-&gt;bbt_erase_shift
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|chips
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|td-&gt;options
op_amp
id|NAND_BBT_ABSPAGE
)paren
op_logical_or
op_logical_neg
(paren
id|td-&gt;options
op_amp
id|NAND_BBT_WRITE
)paren
)paren
(brace
r_if
c_cond
(paren
id|td-&gt;pages
(braket
id|i
)braket
op_eq
op_minus
l_int|1
)paren
r_continue
suffix:semicolon
id|block
op_assign
id|td-&gt;pages
(braket
id|i
)braket
op_rshift
(paren
id|this-&gt;bbt_erase_shift
op_minus
id|this-&gt;page_shift
)paren
suffix:semicolon
id|block
op_lshift_assign
l_int|1
suffix:semicolon
id|oldval
op_assign
id|this-&gt;bbt
(braket
(paren
id|block
op_rshift
l_int|3
)paren
)braket
suffix:semicolon
id|newval
op_assign
id|oldval
op_or
(paren
l_int|0x2
op_lshift
(paren
id|block
op_amp
l_int|0x06
)paren
)paren
suffix:semicolon
id|this-&gt;bbt
(braket
(paren
id|block
op_rshift
l_int|3
)paren
)braket
op_assign
id|newval
suffix:semicolon
r_if
c_cond
(paren
(paren
id|oldval
op_ne
id|newval
)paren
op_logical_and
id|td-&gt;reserved_block_code
)paren
id|nand_update_bbt
c_func
(paren
id|mtd
comma
id|block
op_lshift
(paren
id|this-&gt;bbt_erase_shift
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|update
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|td-&gt;options
op_amp
id|NAND_BBT_LASTBLOCK
)paren
id|block
op_assign
(paren
(paren
id|i
op_plus
l_int|1
)paren
op_star
id|nrblocks
)paren
op_minus
id|td-&gt;maxblocks
suffix:semicolon
r_else
id|block
op_assign
id|i
op_star
id|nrblocks
suffix:semicolon
id|block
op_lshift_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|td-&gt;maxblocks
suffix:semicolon
id|j
op_increment
)paren
(brace
id|oldval
op_assign
id|this-&gt;bbt
(braket
(paren
id|block
op_rshift
l_int|3
)paren
)braket
suffix:semicolon
id|newval
op_assign
id|oldval
op_or
(paren
l_int|0x2
op_lshift
(paren
id|block
op_amp
l_int|0x06
)paren
)paren
suffix:semicolon
id|this-&gt;bbt
(braket
(paren
id|block
op_rshift
l_int|3
)paren
)braket
op_assign
id|newval
suffix:semicolon
r_if
c_cond
(paren
id|oldval
op_ne
id|newval
)paren
id|update
op_assign
l_int|1
suffix:semicolon
id|block
op_add_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/* If we want reserved blocks to be recorded to flash, and some&n;&t;&t;   new ones have been marked, then we need to update the stored&n;&t;&t;   bbts.  This should only happen once. */
r_if
c_cond
(paren
id|update
op_logical_and
id|td-&gt;reserved_block_code
)paren
id|nand_update_bbt
c_func
(paren
id|mtd
comma
(paren
id|block
op_minus
l_int|2
)paren
op_lshift
(paren
id|this-&gt;bbt_erase_shift
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * nand_scan_bbt - [NAND Interface] scan, find, read and maybe create bad block table(s)&n; * @mtd:&t;MTD device structure&n; * @bd:&t;&t;descriptor for the good/bad block search pattern&n; *&n; * The function checks, if a bad block table(s) is/are already &n; * available. If not it scans the device for manufacturer&n; * marked good / bad blocks and writes the bad block table(s) to&n; * the selected place.&n; *&n; * The bad block table memory is allocated here. It must be freed&n; * by calling the nand_free_bbt function.&n; *&n;*/
DECL|function|nand_scan_bbt
r_int
id|nand_scan_bbt
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|nand_bbt_descr
op_star
id|bd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_int
id|len
comma
id|res
op_assign
l_int|0
suffix:semicolon
r_uint8
op_star
id|buf
suffix:semicolon
r_struct
id|nand_bbt_descr
op_star
id|td
op_assign
id|this-&gt;bbt_td
suffix:semicolon
r_struct
id|nand_bbt_descr
op_star
id|md
op_assign
id|this-&gt;bbt_md
suffix:semicolon
id|len
op_assign
id|mtd-&gt;size
op_rshift
(paren
id|this-&gt;bbt_erase_shift
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Allocate memory (2bit per block) */
id|this-&gt;bbt
op_assign
id|kmalloc
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;bbt
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;nand_scan_bbt: Out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Clear the memory bad block table */
id|memset
(paren
id|this-&gt;bbt
comma
l_int|0x00
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* If no primary table decriptor is given, scan the device&n;&t; * to build a memory based bad block table&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|td
)paren
r_return
id|nand_memory_bbt
c_func
(paren
id|mtd
comma
id|bd
)paren
suffix:semicolon
multiline_comment|/* Allocate a temporary buffer for one eraseblock incl. oob */
id|len
op_assign
(paren
l_int|1
op_lshift
id|this-&gt;bbt_erase_shift
)paren
suffix:semicolon
id|len
op_add_assign
(paren
id|len
op_rshift
id|this-&gt;page_shift
)paren
op_star
id|mtd-&gt;oobsize
suffix:semicolon
id|buf
op_assign
id|kmalloc
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;nand_bbt: Out of memory&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
(paren
id|this-&gt;bbt
)paren
suffix:semicolon
id|this-&gt;bbt
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Is the bbt at a given page ? */
r_if
c_cond
(paren
id|td-&gt;options
op_amp
id|NAND_BBT_ABSPAGE
)paren
(brace
id|res
op_assign
id|read_abs_bbts
(paren
id|mtd
comma
id|buf
comma
id|td
comma
id|md
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Search the bad block table using a pattern in oob */
id|res
op_assign
id|search_read_bbts
(paren
id|mtd
comma
id|buf
comma
id|td
comma
id|md
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|res
)paren
id|res
op_assign
id|check_create
(paren
id|mtd
comma
id|buf
comma
id|bd
)paren
suffix:semicolon
multiline_comment|/* Prevent the bbt regions from erasing / writing */
id|mark_bbt_region
(paren
id|mtd
comma
id|td
)paren
suffix:semicolon
r_if
c_cond
(paren
id|md
)paren
id|mark_bbt_region
(paren
id|mtd
comma
id|md
)paren
suffix:semicolon
id|kfree
(paren
id|buf
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_update_bbt - [NAND Interface] update bad block table(s) &n; * @mtd:&t;MTD device structure&n; * @offs:&t;the offset of the newly marked block&n; *&n; * The function updates the bad block table(s)&n;*/
DECL|function|nand_update_bbt
r_int
id|nand_update_bbt
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|offs
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_int
id|len
comma
id|res
op_assign
l_int|0
comma
id|writeops
op_assign
l_int|0
suffix:semicolon
r_int
id|chip
comma
id|chipsel
suffix:semicolon
r_uint8
op_star
id|buf
suffix:semicolon
r_struct
id|nand_bbt_descr
op_star
id|td
op_assign
id|this-&gt;bbt_td
suffix:semicolon
r_struct
id|nand_bbt_descr
op_star
id|md
op_assign
id|this-&gt;bbt_md
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;bbt
op_logical_or
op_logical_neg
id|td
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|len
op_assign
id|mtd-&gt;size
op_rshift
(paren
id|this-&gt;bbt_erase_shift
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Allocate a temporary buffer for one eraseblock incl. oob */
id|len
op_assign
(paren
l_int|1
op_lshift
id|this-&gt;bbt_erase_shift
)paren
suffix:semicolon
id|len
op_add_assign
(paren
id|len
op_rshift
id|this-&gt;page_shift
)paren
op_star
id|mtd-&gt;oobsize
suffix:semicolon
id|buf
op_assign
id|kmalloc
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;nand_update_bbt: Out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|writeops
op_assign
id|md
op_ne
l_int|NULL
ques
c_cond
l_int|0x03
suffix:colon
l_int|0x01
suffix:semicolon
multiline_comment|/* Do we have a bbt per chip ? */
r_if
c_cond
(paren
id|td-&gt;options
op_amp
id|NAND_BBT_PERCHIP
)paren
(brace
id|chip
op_assign
(paren
r_int
)paren
(paren
id|offs
op_rshift
id|this-&gt;chip_shift
)paren
suffix:semicolon
id|chipsel
op_assign
id|chip
suffix:semicolon
)brace
r_else
(brace
id|chip
op_assign
l_int|0
suffix:semicolon
id|chipsel
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|td-&gt;version
(braket
id|chip
)braket
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|md
)paren
id|md-&gt;version
(braket
id|chip
)braket
op_increment
suffix:semicolon
multiline_comment|/* Write the bad block table to the device ? */
r_if
c_cond
(paren
(paren
id|writeops
op_amp
l_int|0x01
)paren
op_logical_and
(paren
id|td-&gt;options
op_amp
id|NAND_BBT_WRITE
)paren
)paren
(brace
id|res
op_assign
id|write_bbt
(paren
id|mtd
comma
id|buf
comma
id|td
comma
id|md
comma
id|chipsel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Write the mirror bad block table to the device ? */
r_if
c_cond
(paren
(paren
id|writeops
op_amp
l_int|0x02
)paren
op_logical_and
id|md
op_logical_and
(paren
id|md-&gt;options
op_amp
id|NAND_BBT_WRITE
)paren
)paren
(brace
id|res
op_assign
id|write_bbt
(paren
id|mtd
comma
id|buf
comma
id|md
comma
id|td
comma
id|chipsel
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|kfree
(paren
id|buf
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/* Define some generic bad / good block scan pattern which are used &n; * while scanning a device for factory marked good / bad blocks&n; * &n; * The memory based patterns just &n; */
DECL|variable|scan_ff_pattern
r_static
r_uint8
id|scan_ff_pattern
(braket
)braket
op_assign
(brace
l_int|0xff
comma
l_int|0xff
)brace
suffix:semicolon
DECL|variable|smallpage_memorybased
r_static
r_struct
id|nand_bbt_descr
id|smallpage_memorybased
op_assign
(brace
dot
id|options
op_assign
l_int|0
comma
dot
id|offs
op_assign
l_int|5
comma
dot
id|len
op_assign
l_int|1
comma
dot
id|pattern
op_assign
id|scan_ff_pattern
)brace
suffix:semicolon
DECL|variable|largepage_memorybased
r_static
r_struct
id|nand_bbt_descr
id|largepage_memorybased
op_assign
(brace
dot
id|options
op_assign
l_int|0
comma
dot
id|offs
op_assign
l_int|0
comma
dot
id|len
op_assign
l_int|2
comma
dot
id|pattern
op_assign
id|scan_ff_pattern
)brace
suffix:semicolon
DECL|variable|smallpage_flashbased
r_static
r_struct
id|nand_bbt_descr
id|smallpage_flashbased
op_assign
(brace
dot
id|options
op_assign
id|NAND_BBT_SCANEMPTY
op_or
id|NAND_BBT_SCANALLPAGES
comma
dot
id|offs
op_assign
l_int|5
comma
dot
id|len
op_assign
l_int|1
comma
dot
id|pattern
op_assign
id|scan_ff_pattern
)brace
suffix:semicolon
DECL|variable|largepage_flashbased
r_static
r_struct
id|nand_bbt_descr
id|largepage_flashbased
op_assign
(brace
dot
id|options
op_assign
id|NAND_BBT_SCANEMPTY
op_or
id|NAND_BBT_SCANALLPAGES
comma
dot
id|offs
op_assign
l_int|0
comma
dot
id|len
op_assign
l_int|2
comma
dot
id|pattern
op_assign
id|scan_ff_pattern
)brace
suffix:semicolon
DECL|variable|scan_agand_pattern
r_static
r_uint8
id|scan_agand_pattern
(braket
)braket
op_assign
(brace
l_int|0x1C
comma
l_int|0x71
comma
l_int|0xC7
comma
l_int|0x1C
comma
l_int|0x71
comma
l_int|0xC7
)brace
suffix:semicolon
DECL|variable|agand_flashbased
r_static
r_struct
id|nand_bbt_descr
id|agand_flashbased
op_assign
(brace
dot
id|options
op_assign
id|NAND_BBT_SCANEMPTY
op_or
id|NAND_BBT_SCANALLPAGES
comma
dot
id|offs
op_assign
l_int|0x20
comma
dot
id|len
op_assign
l_int|6
comma
dot
id|pattern
op_assign
id|scan_agand_pattern
)brace
suffix:semicolon
multiline_comment|/* Generic flash bbt decriptors&n;*/
DECL|variable|bbt_pattern
r_static
r_uint8
id|bbt_pattern
(braket
)braket
op_assign
(brace
l_char|&squot;B&squot;
comma
l_char|&squot;b&squot;
comma
l_char|&squot;t&squot;
comma
l_char|&squot;0&squot;
)brace
suffix:semicolon
DECL|variable|mirror_pattern
r_static
r_uint8
id|mirror_pattern
(braket
)braket
op_assign
(brace
l_char|&squot;1&squot;
comma
l_char|&squot;t&squot;
comma
l_char|&squot;b&squot;
comma
l_char|&squot;B&squot;
)brace
suffix:semicolon
DECL|variable|bbt_main_descr
r_static
r_struct
id|nand_bbt_descr
id|bbt_main_descr
op_assign
(brace
dot
id|options
op_assign
id|NAND_BBT_LASTBLOCK
op_or
id|NAND_BBT_CREATE
op_or
id|NAND_BBT_WRITE
op_or
id|NAND_BBT_2BIT
op_or
id|NAND_BBT_VERSION
op_or
id|NAND_BBT_PERCHIP
comma
dot
id|offs
op_assign
l_int|8
comma
dot
id|len
op_assign
l_int|4
comma
dot
id|veroffs
op_assign
l_int|12
comma
dot
id|maxblocks
op_assign
l_int|4
comma
dot
id|pattern
op_assign
id|bbt_pattern
)brace
suffix:semicolon
DECL|variable|bbt_mirror_descr
r_static
r_struct
id|nand_bbt_descr
id|bbt_mirror_descr
op_assign
(brace
dot
id|options
op_assign
id|NAND_BBT_LASTBLOCK
op_or
id|NAND_BBT_CREATE
op_or
id|NAND_BBT_WRITE
op_or
id|NAND_BBT_2BIT
op_or
id|NAND_BBT_VERSION
op_or
id|NAND_BBT_PERCHIP
comma
dot
id|offs
op_assign
l_int|8
comma
dot
id|len
op_assign
l_int|4
comma
dot
id|veroffs
op_assign
l_int|12
comma
dot
id|maxblocks
op_assign
l_int|4
comma
dot
id|pattern
op_assign
id|mirror_pattern
)brace
suffix:semicolon
multiline_comment|/**&n; * nand_default_bbt - [NAND Interface] Select a default bad block table for the device &n; * @mtd:&t;MTD device structure&n; *&n; * This function selects the default bad block table&n; * support for the device and calls the nand_scan_bbt function&n; *&n;*/
DECL|function|nand_default_bbt
r_int
id|nand_default_bbt
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
multiline_comment|/* Default for AG-AND. We must use a flash based &n;&t; * bad block table as the devices have factory marked&n;&t; * _good_ blocks. Erasing those blocks leads to loss&n;&t; * of the good / bad information, so we _must_ store&n;&t; * this information in a good / bad table during &n;&t; * startup&n;&t;*/
r_if
c_cond
(paren
id|this-&gt;options
op_amp
id|NAND_IS_AND
)paren
(brace
multiline_comment|/* Use the default pattern descriptors */
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;bbt_td
)paren
(brace
id|this-&gt;bbt_td
op_assign
op_amp
id|bbt_main_descr
suffix:semicolon
id|this-&gt;bbt_md
op_assign
op_amp
id|bbt_mirror_descr
suffix:semicolon
)brace
id|this-&gt;options
op_or_assign
id|NAND_USE_FLASH_BBT
suffix:semicolon
r_return
id|nand_scan_bbt
(paren
id|mtd
comma
op_amp
id|agand_flashbased
)paren
suffix:semicolon
)brace
multiline_comment|/* Is a flash based bad block table requested ? */
r_if
c_cond
(paren
id|this-&gt;options
op_amp
id|NAND_USE_FLASH_BBT
)paren
(brace
multiline_comment|/* Use the default pattern descriptors */
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;bbt_td
)paren
(brace
id|this-&gt;bbt_td
op_assign
op_amp
id|bbt_main_descr
suffix:semicolon
id|this-&gt;bbt_md
op_assign
op_amp
id|bbt_mirror_descr
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;badblock_pattern
)paren
(brace
id|this-&gt;badblock_pattern
op_assign
(paren
id|mtd-&gt;oobblock
OG
l_int|512
)paren
ques
c_cond
op_amp
id|largepage_flashbased
suffix:colon
op_amp
id|smallpage_flashbased
suffix:semicolon
)brace
)brace
r_else
(brace
id|this-&gt;bbt_td
op_assign
l_int|NULL
suffix:semicolon
id|this-&gt;bbt_md
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;badblock_pattern
)paren
(brace
id|this-&gt;badblock_pattern
op_assign
(paren
id|mtd-&gt;oobblock
OG
l_int|512
)paren
ques
c_cond
op_amp
id|largepage_memorybased
suffix:colon
op_amp
id|smallpage_memorybased
suffix:semicolon
)brace
)brace
r_return
id|nand_scan_bbt
(paren
id|mtd
comma
id|this-&gt;badblock_pattern
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_isbad_bbt - [NAND Interface] Check if a block is bad &n; * @mtd:&t;MTD device structure&n; * @offs:&t;offset in the device&n; * @allowbbt:&t;allow access to bad block table region&n; *&n;*/
DECL|function|nand_isbad_bbt
r_int
id|nand_isbad_bbt
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|offs
comma
r_int
id|allowbbt
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_int
id|block
suffix:semicolon
r_uint8
id|res
suffix:semicolon
multiline_comment|/* Get block number * 2 */
id|block
op_assign
(paren
r_int
)paren
(paren
id|offs
op_rshift
(paren
id|this-&gt;bbt_erase_shift
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|res
op_assign
(paren
id|this-&gt;bbt
(braket
id|block
op_rshift
l_int|3
)braket
op_rshift
(paren
id|block
op_amp
l_int|0x06
)paren
)paren
op_amp
l_int|0x03
suffix:semicolon
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL2
comma
l_string|&quot;nand_isbad_bbt(): bbt info for offs 0x%08x: (block %d) 0x%02x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|offs
comma
id|res
comma
id|block
op_rshift
l_int|1
)paren
suffix:semicolon
r_switch
c_cond
(paren
(paren
r_int
)paren
id|res
)paren
(brace
r_case
l_int|0x00
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
l_int|0x01
suffix:colon
r_return
l_int|1
suffix:semicolon
r_case
l_int|0x02
suffix:colon
r_return
id|allowbbt
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|nand_scan_bbt
id|EXPORT_SYMBOL
(paren
id|nand_scan_bbt
)paren
suffix:semicolon
DECL|variable|nand_default_bbt
id|EXPORT_SYMBOL
(paren
id|nand_default_bbt
)paren
suffix:semicolon
eof
