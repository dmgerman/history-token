multiline_comment|/*&n; *  drivers/mtd/nand.c&n; *&n; *  Overview:&n; *   This is the generic MTD driver for NAND flash devices. It should be&n; *   capable of working with almost all NAND chips currently available.&n; *   Basic support for AG-AND chips is provided.&n; *   &n; *&t;Additional technical information is available on&n; *&t;http://www.linux-mtd.infradead.org/tech/nand.html&n; *&t;&n; *  Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)&n; * &t;&t;  2002 Thomas Gleixner (tglx@linutronix.de)&n; *&n; *  02-08-2004  tglx: support for strange chips, which cannot auto increment &n; *&t;&t;pages on read / read_oob&n; *&n; *  03-17-2004  tglx: Check ready before auto increment check. Simon Bayes&n; *&t;&t;pointed this out, as he marked an auto increment capable chip&n; *&t;&t;as NOAUTOINCR in the board driver.&n; *&t;&t;Make reads over block boundaries work too&n; *&n; *  04-14-2004&t;tglx: first working version for 2k page size chips&n; *  &n; *  05-19-2004  tglx: Basic support for Renesas AG-AND chips&n; *&n; *  09-24-2004  tglx: add support for hardware controllers (e.g. ECC) shared&n; *&t;&t;among multiple independend devices. Suggestions and initial patch&n; *&t;&t;from Ben Dooks &lt;ben-mtd@fluff.org&gt;&n; *&n; * Credits:&n; *&t;David Woodhouse for adding multichip support  &n; *&t;&n; *&t;Aleph One Ltd. and Toby Churchill Ltd. for supporting the&n; *&t;rework for 2K page size chips&n; *&n; * TODO:&n; *&t;Enable cached programming for 2k page size chips&n; *&t;Check, if mtd-&gt;ecctype should be set to MTD_ECC_HW&n; *&t;if we have HW ecc support.&n; *&t;The AG-AND chips have nice features for speed improvement,&n; *&t;which are not supported yet. Read / program 4 pages in one go.&n; *&n; * $Id: nand_base.c,v 1.123 2004/11/02 22:36:59 gleixner Exp $&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License version 2 as&n; * published by the Free Software Foundation.&n; *&n; */
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/mtd/nand.h&gt;
macro_line|#include &lt;linux/mtd/nand_ecc.h&gt;
macro_line|#include &lt;linux/mtd/compatmac.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#ifdef CONFIG_MTD_PARTITIONS
macro_line|#include &lt;linux/mtd/partitions.h&gt;
macro_line|#endif
multiline_comment|/* Define default oob placement schemes for large and small page devices */
DECL|variable|nand_oob_8
r_static
r_struct
id|nand_oobinfo
id|nand_oob_8
op_assign
(brace
dot
id|useecc
op_assign
id|MTD_NANDECC_AUTOPLACE
comma
dot
id|eccbytes
op_assign
l_int|3
comma
dot
id|eccpos
op_assign
(brace
l_int|0
comma
l_int|1
comma
l_int|2
)brace
comma
dot
id|oobfree
op_assign
(brace
(brace
l_int|3
comma
l_int|2
)brace
comma
(brace
l_int|6
comma
l_int|2
)brace
)brace
)brace
suffix:semicolon
DECL|variable|nand_oob_16
r_static
r_struct
id|nand_oobinfo
id|nand_oob_16
op_assign
(brace
dot
id|useecc
op_assign
id|MTD_NANDECC_AUTOPLACE
comma
dot
id|eccbytes
op_assign
l_int|6
comma
dot
id|eccpos
op_assign
(brace
l_int|0
comma
l_int|1
comma
l_int|2
comma
l_int|3
comma
l_int|6
comma
l_int|7
)brace
comma
dot
id|oobfree
op_assign
(brace
(brace
l_int|8
comma
l_int|8
)brace
)brace
)brace
suffix:semicolon
DECL|variable|nand_oob_64
r_static
r_struct
id|nand_oobinfo
id|nand_oob_64
op_assign
(brace
dot
id|useecc
op_assign
id|MTD_NANDECC_AUTOPLACE
comma
dot
id|eccbytes
op_assign
l_int|24
comma
dot
id|eccpos
op_assign
(brace
l_int|40
comma
l_int|41
comma
l_int|42
comma
l_int|43
comma
l_int|44
comma
l_int|45
comma
l_int|46
comma
l_int|47
comma
l_int|48
comma
l_int|49
comma
l_int|50
comma
l_int|51
comma
l_int|52
comma
l_int|53
comma
l_int|54
comma
l_int|55
comma
l_int|56
comma
l_int|57
comma
l_int|58
comma
l_int|59
comma
l_int|60
comma
l_int|61
comma
l_int|62
comma
l_int|63
)brace
comma
dot
id|oobfree
op_assign
(brace
(brace
l_int|2
comma
l_int|38
)brace
)brace
)brace
suffix:semicolon
multiline_comment|/* This is used for padding purposes in nand_write_oob */
DECL|variable|ffchars
r_static
id|u_char
id|ffchars
(braket
)braket
op_assign
(brace
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * NAND low-level MTD interface functions&n; */
r_static
r_void
id|nand_write_buf
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_void
id|nand_read_buf
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_int
id|nand_verify_buf
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_int
id|nand_read
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|nand_read_ecc
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
comma
id|u_char
op_star
id|eccbuf
comma
r_struct
id|nand_oobinfo
op_star
id|oobsel
)paren
suffix:semicolon
r_static
r_int
id|nand_read_oob
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|nand_write
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|nand_write_ecc
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
comma
id|u_char
op_star
id|eccbuf
comma
r_struct
id|nand_oobinfo
op_star
id|oobsel
)paren
suffix:semicolon
r_static
r_int
id|nand_write_oob
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|nand_writev
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
r_struct
id|kvec
op_star
id|vecs
comma
r_int
r_int
id|count
comma
id|loff_t
id|to
comma
r_int
op_star
id|retlen
)paren
suffix:semicolon
r_static
r_int
id|nand_writev_ecc
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
r_struct
id|kvec
op_star
id|vecs
comma
r_int
r_int
id|count
comma
id|loff_t
id|to
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|eccbuf
comma
r_struct
id|nand_oobinfo
op_star
id|oobsel
)paren
suffix:semicolon
r_static
r_int
id|nand_erase
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|erase_info
op_star
id|instr
)paren
suffix:semicolon
r_static
r_void
id|nand_sync
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
suffix:semicolon
multiline_comment|/* Some internal functions */
r_static
r_int
id|nand_write_page
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|nand_chip
op_star
id|this
comma
r_int
id|page
comma
id|u_char
op_star
id|oob_buf
comma
r_struct
id|nand_oobinfo
op_star
id|oobsel
comma
r_int
id|mode
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
r_static
r_int
id|nand_verify_pages
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|nand_chip
op_star
id|this
comma
r_int
id|page
comma
r_int
id|numpages
comma
id|u_char
op_star
id|oob_buf
comma
r_struct
id|nand_oobinfo
op_star
id|oobsel
comma
r_int
id|chipnr
comma
r_int
id|oobmode
)paren
suffix:semicolon
macro_line|#else
DECL|macro|nand_verify_pages
mdefine_line|#define nand_verify_pages(...) (0)
macro_line|#endif
r_static
r_void
id|nand_get_device
(paren
r_struct
id|nand_chip
op_star
id|this
comma
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|new_state
)paren
suffix:semicolon
multiline_comment|/**&n; * nand_release_device - [GENERIC] release chip&n; * @mtd:&t;MTD device structure&n; * &n; * Deselect, release chip lock and wake up anyone waiting on the device &n; */
DECL|function|nand_release_device
r_static
r_void
id|nand_release_device
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
multiline_comment|/* De-select the NAND device */
id|this
op_member_access_from_pointer
id|select_chip
c_func
(paren
id|mtd
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Do we have a hardware controller ? */
r_if
c_cond
(paren
id|this-&gt;controller
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|this-&gt;controller-&gt;lock
)paren
suffix:semicolon
id|this-&gt;controller-&gt;active
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|this-&gt;controller-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/* Release the chip */
id|spin_lock
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|wake_up
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_read_byte - [DEFAULT] read one byte from the chip&n; * @mtd:&t;MTD device structure&n; *&n; * Default read function for 8bit buswith&n; */
DECL|function|nand_read_byte
r_static
id|u_char
id|nand_read_byte
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_return
id|readb
c_func
(paren
id|this-&gt;IO_ADDR_R
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_write_byte - [DEFAULT] write one byte to the chip&n; * @mtd:&t;MTD device structure&n; * @byte:&t;pointer to data byte to write&n; *&n; * Default write function for 8it buswith&n; */
DECL|function|nand_write_byte
r_static
r_void
id|nand_write_byte
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u_char
id|byte
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|writeb
c_func
(paren
id|byte
comma
id|this-&gt;IO_ADDR_W
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_read_byte16 - [DEFAULT] read one byte endianess aware from the chip&n; * @mtd:&t;MTD device structure&n; *&n; * Default read function for 16bit buswith with &n; * endianess conversion&n; */
DECL|function|nand_read_byte16
r_static
id|u_char
id|nand_read_byte16
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_return
(paren
id|u_char
)paren
id|cpu_to_le16
c_func
(paren
id|readw
c_func
(paren
id|this-&gt;IO_ADDR_R
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_write_byte16 - [DEFAULT] write one byte endianess aware to the chip&n; * @mtd:&t;MTD device structure&n; * @byte:&t;pointer to data byte to write&n; *&n; * Default write function for 16bit buswith with&n; * endianess conversion&n; */
DECL|function|nand_write_byte16
r_static
r_void
id|nand_write_byte16
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u_char
id|byte
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|writew
c_func
(paren
id|le16_to_cpu
c_func
(paren
(paren
id|u16
)paren
id|byte
)paren
comma
id|this-&gt;IO_ADDR_W
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_read_word - [DEFAULT] read one word from the chip&n; * @mtd:&t;MTD device structure&n; *&n; * Default read function for 16bit buswith without &n; * endianess conversion&n; */
DECL|function|nand_read_word
r_static
id|u16
id|nand_read_word
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_return
id|readw
c_func
(paren
id|this-&gt;IO_ADDR_R
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_write_word - [DEFAULT] write one word to the chip&n; * @mtd:&t;MTD device structure&n; * @word:&t;data word to write&n; *&n; * Default write function for 16bit buswith without &n; * endianess conversion&n; */
DECL|function|nand_write_word
r_static
r_void
id|nand_write_word
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u16
id|word
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|writew
c_func
(paren
id|word
comma
id|this-&gt;IO_ADDR_W
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_select_chip - [DEFAULT] control CE line&n; * @mtd:&t;MTD device structure&n; * @chip:&t;chipnumber to select, -1 for deselect&n; *&n; * Default select function for 1 chip devices.&n; */
DECL|function|nand_select_chip
r_static
r_void
id|nand_select_chip
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|chip
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_switch
c_cond
(paren
id|chip
)paren
(brace
r_case
op_minus
l_int|1
suffix:colon
id|this
op_member_access_from_pointer
id|hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_CLRNCE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
id|this
op_member_access_from_pointer
id|hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_SETNCE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * nand_write_buf - [DEFAULT] write buffer to chip&n; * @mtd:&t;MTD device structure&n; * @buf:&t;data buffer&n; * @len:&t;number of bytes to write&n; *&n; * Default write function for 8bit buswith&n; */
DECL|function|nand_write_buf
r_static
r_void
id|nand_write_buf
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
id|writeb
c_func
(paren
id|buf
(braket
id|i
)braket
comma
id|this-&gt;IO_ADDR_W
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_read_buf - [DEFAULT] read chip data into buffer &n; * @mtd:&t;MTD device structure&n; * @buf:&t;buffer to store date&n; * @len:&t;number of bytes to read&n; *&n; * Default read function for 8bit buswith&n; */
DECL|function|nand_read_buf
r_static
r_void
id|nand_read_buf
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
id|buf
(braket
id|i
)braket
op_assign
id|readb
c_func
(paren
id|this-&gt;IO_ADDR_R
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_verify_buf - [DEFAULT] Verify chip data against buffer &n; * @mtd:&t;MTD device structure&n; * @buf:&t;buffer containing the data to compare&n; * @len:&t;number of bytes to compare&n; *&n; * Default verify function for 8bit buswith&n; */
DECL|function|nand_verify_buf
r_static
r_int
id|nand_verify_buf
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_ne
id|readb
c_func
(paren
id|this-&gt;IO_ADDR_R
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_write_buf16 - [DEFAULT] write buffer to chip&n; * @mtd:&t;MTD device structure&n; * @buf:&t;data buffer&n; * @len:&t;number of bytes to write&n; *&n; * Default write function for 16bit buswith&n; */
DECL|function|nand_write_buf16
r_static
r_void
id|nand_write_buf16
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|u16
op_star
id|p
op_assign
(paren
id|u16
op_star
)paren
id|buf
suffix:semicolon
id|len
op_rshift_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
id|writew
c_func
(paren
id|p
(braket
id|i
)braket
comma
id|this-&gt;IO_ADDR_W
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_read_buf16 - [DEFAULT] read chip data into buffer &n; * @mtd:&t;MTD device structure&n; * @buf:&t;buffer to store date&n; * @len:&t;number of bytes to read&n; *&n; * Default read function for 16bit buswith&n; */
DECL|function|nand_read_buf16
r_static
r_void
id|nand_read_buf16
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|u16
op_star
id|p
op_assign
(paren
id|u16
op_star
)paren
id|buf
suffix:semicolon
id|len
op_rshift_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
id|p
(braket
id|i
)braket
op_assign
id|readw
c_func
(paren
id|this-&gt;IO_ADDR_R
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_verify_buf16 - [DEFAULT] Verify chip data against buffer &n; * @mtd:&t;MTD device structure&n; * @buf:&t;buffer containing the data to compare&n; * @len:&t;number of bytes to compare&n; *&n; * Default verify function for 16bit buswith&n; */
DECL|function|nand_verify_buf16
r_static
r_int
id|nand_verify_buf16
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|u16
op_star
id|p
op_assign
(paren
id|u16
op_star
)paren
id|buf
suffix:semicolon
id|len
op_rshift_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|p
(braket
id|i
)braket
op_ne
id|readw
c_func
(paren
id|this-&gt;IO_ADDR_R
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_block_bad - [DEFAULT] Read bad block marker from the chip&n; * @mtd:&t;MTD device structure&n; * @ofs:&t;offset from device start&n; * @getchip:&t;0, if the chip is already selected&n; *&n; * Check, if the block is bad. &n; */
DECL|function|nand_block_bad
r_static
r_int
id|nand_block_bad
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|ofs
comma
r_int
id|getchip
)paren
(brace
r_int
id|page
comma
id|chipnr
comma
id|res
op_assign
l_int|0
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|u16
id|bad
suffix:semicolon
r_if
c_cond
(paren
id|getchip
)paren
(brace
id|page
op_assign
(paren
r_int
)paren
(paren
id|ofs
op_rshift
id|this-&gt;page_shift
)paren
suffix:semicolon
id|chipnr
op_assign
(paren
r_int
)paren
(paren
id|ofs
op_rshift
id|this-&gt;chip_shift
)paren
suffix:semicolon
multiline_comment|/* Grab the lock and see if the device is available */
id|nand_get_device
(paren
id|this
comma
id|mtd
comma
id|FL_READING
)paren
suffix:semicolon
multiline_comment|/* Select the NAND device */
id|this
op_member_access_from_pointer
id|select_chip
c_func
(paren
id|mtd
comma
id|chipnr
)paren
suffix:semicolon
)brace
r_else
id|page
op_assign
(paren
r_int
)paren
id|ofs
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;options
op_amp
id|NAND_BUSWIDTH_16
)paren
(brace
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_READOOB
comma
id|this-&gt;badblockpos
op_amp
l_int|0xFE
comma
id|page
op_amp
id|this-&gt;pagemask
)paren
suffix:semicolon
id|bad
op_assign
id|cpu_to_le16
c_func
(paren
id|this
op_member_access_from_pointer
id|read_word
c_func
(paren
id|mtd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;badblockpos
op_amp
l_int|0x1
)paren
id|bad
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bad
op_amp
l_int|0xFF
)paren
op_ne
l_int|0xff
)paren
id|res
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_READOOB
comma
id|this-&gt;badblockpos
comma
id|page
op_amp
id|this-&gt;pagemask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|this
op_member_access_from_pointer
id|read_byte
c_func
(paren
id|mtd
)paren
op_ne
l_int|0xff
)paren
id|res
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|getchip
)paren
(brace
multiline_comment|/* Deselect and wake up anyone waiting on the device */
id|nand_release_device
c_func
(paren
id|mtd
)paren
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_default_block_markbad - [DEFAULT] mark a block bad&n; * @mtd:&t;MTD device structure&n; * @ofs:&t;offset from device start&n; *&n; * This is the default implementation, which can be overridden by&n; * a hardware specific driver.&n;*/
DECL|function|nand_default_block_markbad
r_static
r_int
id|nand_default_block_markbad
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|ofs
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|u_char
id|buf
(braket
l_int|2
)braket
op_assign
(brace
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_int
id|block
suffix:semicolon
multiline_comment|/* Get block number */
id|block
op_assign
(paren
(paren
r_int
)paren
id|ofs
)paren
op_rshift
id|this-&gt;bbt_erase_shift
suffix:semicolon
id|this-&gt;bbt
(braket
id|block
op_rshift
l_int|2
)braket
op_or_assign
l_int|0x01
op_lshift
(paren
(paren
id|block
op_amp
l_int|0x03
)paren
op_lshift
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Do we have a flash based bad block table ? */
r_if
c_cond
(paren
id|this-&gt;options
op_amp
id|NAND_USE_FLASH_BBT
)paren
r_return
id|nand_update_bbt
(paren
id|mtd
comma
id|ofs
)paren
suffix:semicolon
multiline_comment|/* We write two bytes, so we dont have to mess with 16 bit access */
id|ofs
op_add_assign
id|mtd-&gt;oobsize
op_plus
(paren
id|this-&gt;badblockpos
op_amp
op_complement
l_int|0x01
)paren
suffix:semicolon
r_return
id|nand_write_oob
(paren
id|mtd
comma
id|ofs
comma
l_int|2
comma
op_amp
id|retlen
comma
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/** &n; * nand_check_wp - [GENERIC] check if the chip is write protected&n; * @mtd:&t;MTD device structure&n; * Check, if the device is write protected &n; *&n; * The function expects, that the device is already selected &n; */
DECL|function|nand_check_wp
r_static
r_int
id|nand_check_wp
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
multiline_comment|/* Check the WP bit */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_STATUS
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
(paren
id|this
op_member_access_from_pointer
id|read_byte
c_func
(paren
id|mtd
)paren
op_amp
l_int|0x80
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_block_checkbad - [GENERIC] Check if a block is marked bad&n; * @mtd:&t;MTD device structure&n; * @ofs:&t;offset from device start&n; * @getchip:&t;0, if the chip is already selected&n; * @allowbbt:&t;1, if its allowed to access the bbt area&n; *&n; * Check, if the block is bad. Either by reading the bad block table or&n; * calling of the scan function.&n; */
DECL|function|nand_block_checkbad
r_static
r_int
id|nand_block_checkbad
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|ofs
comma
r_int
id|getchip
comma
r_int
id|allowbbt
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;bbt
)paren
r_return
id|this
op_member_access_from_pointer
id|block_bad
c_func
(paren
id|mtd
comma
id|ofs
comma
id|getchip
)paren
suffix:semicolon
multiline_comment|/* Return info from the table */
r_return
id|nand_isbad_bbt
(paren
id|mtd
comma
id|ofs
comma
id|allowbbt
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_command - [DEFAULT] Send command to NAND device&n; * @mtd:&t;MTD device structure&n; * @command:&t;the command to be sent&n; * @column:&t;the column address for this command, -1 if none&n; * @page_addr:&t;the page address for this command, -1 if none&n; *&n; * Send command to NAND device. This function is used for small page&n; * devices (256/512 Bytes per page)&n; */
DECL|function|nand_command
r_static
r_void
id|nand_command
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|command
comma
r_int
id|column
comma
r_int
id|page_addr
)paren
(brace
r_register
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
multiline_comment|/* Begin command latch cycle */
id|this
op_member_access_from_pointer
id|hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_SETCLE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Write out the command to the device.&n;&t; */
r_if
c_cond
(paren
id|command
op_eq
id|NAND_CMD_SEQIN
)paren
(brace
r_int
id|readcmd
suffix:semicolon
r_if
c_cond
(paren
id|column
op_ge
id|mtd-&gt;oobblock
)paren
(brace
multiline_comment|/* OOB area */
id|column
op_sub_assign
id|mtd-&gt;oobblock
suffix:semicolon
id|readcmd
op_assign
id|NAND_CMD_READOOB
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|column
OL
l_int|256
)paren
(brace
multiline_comment|/* First 256 bytes --&gt; READ0 */
id|readcmd
op_assign
id|NAND_CMD_READ0
suffix:semicolon
)brace
r_else
(brace
id|column
op_sub_assign
l_int|256
suffix:semicolon
id|readcmd
op_assign
id|NAND_CMD_READ1
suffix:semicolon
)brace
id|this
op_member_access_from_pointer
id|write_byte
c_func
(paren
id|mtd
comma
id|readcmd
)paren
suffix:semicolon
)brace
id|this
op_member_access_from_pointer
id|write_byte
c_func
(paren
id|mtd
comma
id|command
)paren
suffix:semicolon
multiline_comment|/* Set ALE and clear CLE to start address cycle */
id|this
op_member_access_from_pointer
id|hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_CLRCLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|column
op_ne
op_minus
l_int|1
op_logical_or
id|page_addr
op_ne
op_minus
l_int|1
)paren
(brace
id|this
op_member_access_from_pointer
id|hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_SETALE
)paren
suffix:semicolon
multiline_comment|/* Serially input address */
r_if
c_cond
(paren
id|column
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Adjust columns for 16 bit buswidth */
r_if
c_cond
(paren
id|this-&gt;options
op_amp
id|NAND_BUSWIDTH_16
)paren
id|column
op_rshift_assign
l_int|1
suffix:semicolon
id|this
op_member_access_from_pointer
id|write_byte
c_func
(paren
id|mtd
comma
id|column
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page_addr
op_ne
op_minus
l_int|1
)paren
(brace
id|this
op_member_access_from_pointer
id|write_byte
c_func
(paren
id|mtd
comma
(paren
r_int
r_char
)paren
(paren
id|page_addr
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|write_byte
c_func
(paren
id|mtd
comma
(paren
r_int
r_char
)paren
(paren
(paren
id|page_addr
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
multiline_comment|/* One more address cycle for devices &gt; 32MiB */
r_if
c_cond
(paren
id|this-&gt;chipsize
OG
(paren
l_int|32
op_lshift
l_int|20
)paren
)paren
id|this
op_member_access_from_pointer
id|write_byte
c_func
(paren
id|mtd
comma
(paren
r_int
r_char
)paren
(paren
(paren
id|page_addr
op_rshift
l_int|16
)paren
op_amp
l_int|0x0f
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Latch in address */
id|this
op_member_access_from_pointer
id|hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_CLRALE
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * program and erase have their own busy handlers &n;&t; * status and sequential in needs no delay&n;&t;*/
r_switch
c_cond
(paren
id|command
)paren
(brace
r_case
id|NAND_CMD_PAGEPROG
suffix:colon
r_case
id|NAND_CMD_ERASE1
suffix:colon
r_case
id|NAND_CMD_ERASE2
suffix:colon
r_case
id|NAND_CMD_SEQIN
suffix:colon
r_case
id|NAND_CMD_STATUS
suffix:colon
r_return
suffix:semicolon
r_case
id|NAND_CMD_RESET
suffix:colon
r_if
c_cond
(paren
id|this-&gt;dev_ready
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
id|this-&gt;chip_delay
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_SETCLE
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|write_byte
c_func
(paren
id|mtd
comma
id|NAND_CMD_STATUS
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_CLRCLE
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|this
op_member_access_from_pointer
id|read_byte
c_func
(paren
id|mtd
)paren
op_amp
l_int|0x40
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* This applies to read commands */
r_default
suffix:colon
(brace
)brace
multiline_comment|/* &n;&t;&t; * If we don&squot;t have access to the busy pin, we apply the given&n;&t;&t; * command delay&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;dev_ready
)paren
(brace
id|udelay
(paren
id|this-&gt;chip_delay
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Apply this short delay always to ensure that we do wait tWB in&n;&t; * any case on any machine. */
id|ndelay
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* wait until command is processed */
r_while
c_loop
(paren
op_logical_neg
id|this
op_member_access_from_pointer
id|dev_ready
c_func
(paren
id|mtd
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_command_lp - [DEFAULT] Send command to NAND large page device&n; * @mtd:&t;MTD device structure&n; * @command:&t;the command to be sent&n; * @column:&t;the column address for this command, -1 if none&n; * @page_addr:&t;the page address for this command, -1 if none&n; *&n; * Send command to NAND device. This is the version for the new large page devices&n; * We dont have the seperate regions as we have in the small page devices.&n; * We must emulate NAND_CMD_READOOB to keep the code compatible.&n; *&n; */
DECL|function|nand_command_lp
r_static
r_void
id|nand_command_lp
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|command
comma
r_int
id|column
comma
r_int
id|page_addr
)paren
(brace
r_register
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
multiline_comment|/* Emulate NAND_CMD_READOOB */
r_if
c_cond
(paren
id|command
op_eq
id|NAND_CMD_READOOB
)paren
(brace
id|column
op_add_assign
id|mtd-&gt;oobblock
suffix:semicolon
id|command
op_assign
id|NAND_CMD_READ0
suffix:semicolon
)brace
multiline_comment|/* Begin command latch cycle */
id|this
op_member_access_from_pointer
id|hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_SETCLE
)paren
suffix:semicolon
multiline_comment|/* Write out the command to the device. */
id|this
op_member_access_from_pointer
id|write_byte
c_func
(paren
id|mtd
comma
id|command
)paren
suffix:semicolon
multiline_comment|/* End command latch cycle */
id|this
op_member_access_from_pointer
id|hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_CLRCLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|column
op_ne
op_minus
l_int|1
op_logical_or
id|page_addr
op_ne
op_minus
l_int|1
)paren
(brace
id|this
op_member_access_from_pointer
id|hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_SETALE
)paren
suffix:semicolon
multiline_comment|/* Serially input address */
r_if
c_cond
(paren
id|column
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Adjust columns for 16 bit buswidth */
r_if
c_cond
(paren
id|this-&gt;options
op_amp
id|NAND_BUSWIDTH_16
)paren
id|column
op_rshift_assign
l_int|1
suffix:semicolon
id|this
op_member_access_from_pointer
id|write_byte
c_func
(paren
id|mtd
comma
id|column
op_amp
l_int|0xff
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|write_byte
c_func
(paren
id|mtd
comma
id|column
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page_addr
op_ne
op_minus
l_int|1
)paren
(brace
id|this
op_member_access_from_pointer
id|write_byte
c_func
(paren
id|mtd
comma
(paren
r_int
r_char
)paren
(paren
id|page_addr
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|write_byte
c_func
(paren
id|mtd
comma
(paren
r_int
r_char
)paren
(paren
(paren
id|page_addr
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
multiline_comment|/* One more address cycle for devices &gt; 128MiB */
r_if
c_cond
(paren
id|this-&gt;chipsize
OG
(paren
l_int|128
op_lshift
l_int|20
)paren
)paren
id|this
op_member_access_from_pointer
id|write_byte
c_func
(paren
id|mtd
comma
(paren
r_int
r_char
)paren
(paren
(paren
id|page_addr
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Latch in address */
id|this
op_member_access_from_pointer
id|hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_CLRALE
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * program and erase have their own busy handlers &n;&t; * status and sequential in needs no delay&n;&t;*/
r_switch
c_cond
(paren
id|command
)paren
(brace
r_case
id|NAND_CMD_CACHEDPROG
suffix:colon
r_case
id|NAND_CMD_PAGEPROG
suffix:colon
r_case
id|NAND_CMD_ERASE1
suffix:colon
r_case
id|NAND_CMD_ERASE2
suffix:colon
r_case
id|NAND_CMD_SEQIN
suffix:colon
r_case
id|NAND_CMD_STATUS
suffix:colon
r_return
suffix:semicolon
r_case
id|NAND_CMD_RESET
suffix:colon
r_if
c_cond
(paren
id|this-&gt;dev_ready
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
id|this-&gt;chip_delay
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_SETCLE
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|write_byte
c_func
(paren
id|mtd
comma
id|NAND_CMD_STATUS
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_CLRCLE
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|this
op_member_access_from_pointer
id|read_byte
c_func
(paren
id|mtd
)paren
op_amp
l_int|0x40
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|NAND_CMD_READ0
suffix:colon
multiline_comment|/* Begin command latch cycle */
id|this
op_member_access_from_pointer
id|hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_SETCLE
)paren
suffix:semicolon
multiline_comment|/* Write out the start read command */
id|this
op_member_access_from_pointer
id|write_byte
c_func
(paren
id|mtd
comma
id|NAND_CMD_READSTART
)paren
suffix:semicolon
multiline_comment|/* End command latch cycle */
id|this
op_member_access_from_pointer
id|hwcontrol
c_func
(paren
id|mtd
comma
id|NAND_CTL_CLRCLE
)paren
suffix:semicolon
multiline_comment|/* Fall through into ready check */
multiline_comment|/* This applies to read commands */
r_default
suffix:colon
(brace
)brace
multiline_comment|/* &n;&t;&t; * If we don&squot;t have access to the busy pin, we apply the given&n;&t;&t; * command delay&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;dev_ready
)paren
(brace
id|udelay
(paren
id|this-&gt;chip_delay
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Apply this short delay always to ensure that we do wait tWB in&n;&t; * any case on any machine. */
id|ndelay
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* wait until command is processed */
r_while
c_loop
(paren
op_logical_neg
id|this
op_member_access_from_pointer
id|dev_ready
c_func
(paren
id|mtd
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_get_device - [GENERIC] Get chip for selected access&n; * @this:&t;the nand chip descriptor&n; * @mtd:&t;MTD device structure&n; * @new_state:&t;the state which is requested &n; *&n; * Get the device and lock it for exclusive access&n; */
DECL|function|nand_get_device
r_static
r_void
id|nand_get_device
(paren
r_struct
id|nand_chip
op_star
id|this
comma
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|new_state
)paren
(brace
r_struct
id|nand_chip
op_star
id|active
op_assign
id|this
suffix:semicolon
id|DECLARE_WAITQUEUE
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Grab the lock and see if the device is available &n;&t;*/
id|retry
suffix:colon
multiline_comment|/* Hardware controller shared among independend devices */
r_if
c_cond
(paren
id|this-&gt;controller
)paren
(brace
id|spin_lock
(paren
op_amp
id|this-&gt;controller-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;controller-&gt;active
)paren
id|active
op_assign
id|this-&gt;controller-&gt;active
suffix:semicolon
r_else
id|this-&gt;controller-&gt;active
op_assign
id|this
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|this-&gt;controller-&gt;lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|active
op_eq
id|this
)paren
(brace
id|spin_lock
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;state
op_eq
id|FL_READY
)paren
(brace
id|this-&gt;state
op_assign
id|new_state
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|set_current_state
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
(paren
op_amp
id|active-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|active-&gt;chip_lock
)paren
suffix:semicolon
id|schedule
(paren
)paren
suffix:semicolon
id|remove_wait_queue
(paren
op_amp
id|active-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_wait - [DEFAULT]  wait until the command is done&n; * @mtd:&t;MTD device structure&n; * @this:&t;NAND chip structure&n; * @state:&t;state to select the max. timeout value&n; *&n; * Wait for command done. This applies to erase and program only&n; * Erase can take up to 400ms and program up to 20ms according to &n; * general NAND and SmartMedia specs&n; *&n;*/
DECL|function|nand_wait
r_static
r_int
id|nand_wait
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|nand_chip
op_star
id|this
comma
r_int
id|state
)paren
(brace
r_int
r_int
id|timeo
op_assign
id|jiffies
suffix:semicolon
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
id|FL_ERASING
)paren
id|timeo
op_add_assign
(paren
id|HZ
op_star
l_int|400
)paren
op_div
l_int|1000
suffix:semicolon
r_else
id|timeo
op_add_assign
(paren
id|HZ
op_star
l_int|20
)paren
op_div
l_int|1000
suffix:semicolon
multiline_comment|/* Apply this short delay always to ensure that we do wait tWB in&n;&t; * any case on any machine. */
id|ndelay
(paren
l_int|100
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|state
op_eq
id|FL_ERASING
)paren
op_logical_and
(paren
id|this-&gt;options
op_amp
id|NAND_IS_AND
)paren
)paren
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_STATUS_MULTI
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_else
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_STATUS
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|timeo
)paren
)paren
(brace
multiline_comment|/* Check, if we were interrupted */
r_if
c_cond
(paren
id|this-&gt;state
op_ne
id|state
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;dev_ready
)paren
(brace
r_if
c_cond
(paren
id|this
op_member_access_from_pointer
id|dev_ready
c_func
(paren
id|mtd
)paren
)paren
r_break
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|this
op_member_access_from_pointer
id|read_byte
c_func
(paren
id|mtd
)paren
op_amp
id|NAND_STATUS_READY
)paren
r_break
suffix:semicolon
)brace
id|yield
(paren
)paren
suffix:semicolon
)brace
id|status
op_assign
(paren
r_int
)paren
id|this
op_member_access_from_pointer
id|read_byte
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_write_page - [GENERIC] write one page&n; * @mtd:&t;MTD device structure&n; * @this:&t;NAND chip structure&n; * @page: &t;startpage inside the chip, must be called with (page &amp; this-&gt;pagemask)&n; * @oob_buf:&t;out of band data buffer&n; * @oobsel:&t;out of band selecttion structre&n; * @cached:&t;1 = enable cached programming if supported by chip&n; *&n; * Nand_page_program function is used for write and writev !&n; * This function will always program a full page of data&n; * If you call it with a non page aligned buffer, you&squot;re lost :)&n; *&n; * Cached programming is not supported yet.&n; */
DECL|function|nand_write_page
r_static
r_int
id|nand_write_page
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|nand_chip
op_star
id|this
comma
r_int
id|page
comma
id|u_char
op_star
id|oob_buf
comma
r_struct
id|nand_oobinfo
op_star
id|oobsel
comma
r_int
id|cached
)paren
(brace
r_int
id|i
comma
id|status
suffix:semicolon
id|u_char
id|ecc_code
(braket
l_int|8
)braket
suffix:semicolon
r_int
id|eccmode
op_assign
id|oobsel-&gt;useecc
ques
c_cond
id|this-&gt;eccmode
suffix:colon
id|NAND_ECC_NONE
suffix:semicolon
r_int
op_star
id|oob_config
op_assign
id|oobsel-&gt;eccpos
suffix:semicolon
r_int
id|datidx
op_assign
l_int|0
comma
id|eccidx
op_assign
l_int|0
comma
id|eccsteps
op_assign
id|this-&gt;eccsteps
suffix:semicolon
r_int
id|eccbytes
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FIXME: Enable cached programming */
id|cached
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Send command to begin auto page programming */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_SEQIN
comma
l_int|0x00
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* Write out complete page of data, take care of eccmode */
r_switch
c_cond
(paren
id|eccmode
)paren
(brace
multiline_comment|/* No ecc, write all */
r_case
id|NAND_ECC_NONE
suffix:colon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;Writing data without ECC to NAND-FLASH is not recommended&bslash;n&quot;
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|write_buf
c_func
(paren
id|mtd
comma
id|this-&gt;data_poi
comma
id|mtd-&gt;oobblock
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Software ecc 3/256, write all */
r_case
id|NAND_ECC_SOFT
suffix:colon
r_for
c_loop
(paren
suffix:semicolon
id|eccsteps
suffix:semicolon
id|eccsteps
op_decrement
)paren
(brace
id|this
op_member_access_from_pointer
id|calculate_ecc
c_func
(paren
id|mtd
comma
op_amp
id|this-&gt;data_poi
(braket
id|datidx
)braket
comma
id|ecc_code
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
comma
id|eccidx
op_increment
)paren
id|oob_buf
(braket
id|oob_config
(braket
id|eccidx
)braket
)braket
op_assign
id|ecc_code
(braket
id|i
)braket
suffix:semicolon
id|datidx
op_add_assign
id|this-&gt;eccsize
suffix:semicolon
)brace
id|this
op_member_access_from_pointer
id|write_buf
c_func
(paren
id|mtd
comma
id|this-&gt;data_poi
comma
id|mtd-&gt;oobblock
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|eccbytes
op_assign
id|this-&gt;eccbytes
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|eccsteps
suffix:semicolon
id|eccsteps
op_decrement
)paren
(brace
multiline_comment|/* enable hardware ecc logic for write */
id|this
op_member_access_from_pointer
id|enable_hwecc
c_func
(paren
id|mtd
comma
id|NAND_ECC_WRITE
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|write_buf
c_func
(paren
id|mtd
comma
op_amp
id|this-&gt;data_poi
(braket
id|datidx
)braket
comma
id|this-&gt;eccsize
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|calculate_ecc
c_func
(paren
id|mtd
comma
op_amp
id|this-&gt;data_poi
(braket
id|datidx
)braket
comma
id|ecc_code
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|eccbytes
suffix:semicolon
id|i
op_increment
comma
id|eccidx
op_increment
)paren
id|oob_buf
(braket
id|oob_config
(braket
id|eccidx
)braket
)braket
op_assign
id|ecc_code
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* If the hardware ecc provides syndromes then&n;&t;&t;&t; * the ecc code must be written immidiately after&n;&t;&t;&t; * the data bytes (words) */
r_if
c_cond
(paren
id|this-&gt;options
op_amp
id|NAND_HWECC_SYNDROME
)paren
id|this
op_member_access_from_pointer
id|write_buf
c_func
(paren
id|mtd
comma
id|ecc_code
comma
id|eccbytes
)paren
suffix:semicolon
id|datidx
op_add_assign
id|this-&gt;eccsize
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* Write out OOB data */
r_if
c_cond
(paren
id|this-&gt;options
op_amp
id|NAND_HWECC_SYNDROME
)paren
id|this
op_member_access_from_pointer
id|write_buf
c_func
(paren
id|mtd
comma
op_amp
id|oob_buf
(braket
id|oobsel-&gt;eccbytes
)braket
comma
id|mtd-&gt;oobsize
op_minus
id|oobsel-&gt;eccbytes
)paren
suffix:semicolon
r_else
id|this
op_member_access_from_pointer
id|write_buf
c_func
(paren
id|mtd
comma
id|oob_buf
comma
id|mtd-&gt;oobsize
)paren
suffix:semicolon
multiline_comment|/* Send command to actually program the data */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|cached
ques
c_cond
id|NAND_CMD_CACHEDPROG
suffix:colon
id|NAND_CMD_PAGEPROG
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cached
)paren
(brace
multiline_comment|/* call wait ready function */
id|status
op_assign
id|this-&gt;waitfunc
(paren
id|mtd
comma
id|this
comma
id|FL_WRITING
)paren
suffix:semicolon
multiline_comment|/* See if device thinks it succeeded */
r_if
c_cond
(paren
id|status
op_amp
l_int|0x01
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;%s: &quot;
l_string|&quot;Failed write, page 0x%08x, &quot;
comma
id|__FUNCTION__
comma
id|page
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* FIXME: Implement cached programming ! */
multiline_comment|/* wait until cache is ready*/
singleline_comment|// status = this-&gt;waitfunc (mtd, this, FL_CACHEDRPG);
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
multiline_comment|/**&n; * nand_verify_pages - [GENERIC] verify the chip contents after a write&n; * @mtd:&t;MTD device structure&n; * @this:&t;NAND chip structure&n; * @page: &t;startpage inside the chip, must be called with (page &amp; this-&gt;pagemask)&n; * @numpages:&t;number of pages to verify&n; * @oob_buf:&t;out of band data buffer&n; * @oobsel:&t;out of band selecttion structre&n; * @chipnr:&t;number of the current chip&n; * @oobmode:&t;1 = full buffer verify, 0 = ecc only&n; *&n; * The NAND device assumes that it is always writing to a cleanly erased page.&n; * Hence, it performs its internal write verification only on bits that &n; * transitioned from 1 to 0. The device does NOT verify the whole page on a&n; * byte by byte basis. It is possible that the page was not completely erased &n; * or the page is becoming unusable due to wear. The read with ECC would catch &n; * the error later when the ECC page check fails, but we would rather catch &n; * it early in the page write stage. Better to write no data than invalid data.&n; */
DECL|function|nand_verify_pages
r_static
r_int
id|nand_verify_pages
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|nand_chip
op_star
id|this
comma
r_int
id|page
comma
r_int
id|numpages
comma
id|u_char
op_star
id|oob_buf
comma
r_struct
id|nand_oobinfo
op_star
id|oobsel
comma
r_int
id|chipnr
comma
r_int
id|oobmode
)paren
(brace
r_int
id|i
comma
id|j
comma
id|datidx
op_assign
l_int|0
comma
id|oobofs
op_assign
l_int|0
comma
id|res
op_assign
op_minus
id|EIO
suffix:semicolon
r_int
id|eccsteps
op_assign
id|this-&gt;eccsteps
suffix:semicolon
r_int
id|hweccbytes
suffix:semicolon
id|u_char
id|oobdata
(braket
l_int|64
)braket
suffix:semicolon
id|hweccbytes
op_assign
(paren
id|this-&gt;options
op_amp
id|NAND_HWECC_SYNDROME
)paren
ques
c_cond
(paren
id|oobsel-&gt;eccbytes
op_div
id|eccsteps
)paren
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* Send command to read back the first page */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_READ0
comma
l_int|0
comma
id|page
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|eccsteps
suffix:semicolon
id|j
op_increment
)paren
(brace
multiline_comment|/* Loop through and verify the data */
r_if
c_cond
(paren
id|this
op_member_access_from_pointer
id|verify_buf
c_func
(paren
id|mtd
comma
op_amp
id|this-&gt;data_poi
(braket
id|datidx
)braket
comma
id|mtd-&gt;eccsize
)paren
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;%s: &quot;
l_string|&quot;Failed write verify, page 0x%08x &quot;
comma
id|__FUNCTION__
comma
id|page
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|datidx
op_add_assign
id|mtd-&gt;eccsize
suffix:semicolon
multiline_comment|/* Have we a hw generator layout ? */
r_if
c_cond
(paren
op_logical_neg
id|hweccbytes
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|this
op_member_access_from_pointer
id|verify_buf
c_func
(paren
id|mtd
comma
op_amp
id|this-&gt;oob_buf
(braket
id|oobofs
)braket
comma
id|hweccbytes
)paren
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;%s: &quot;
l_string|&quot;Failed write verify, page 0x%08x &quot;
comma
id|__FUNCTION__
comma
id|page
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|oobofs
op_add_assign
id|hweccbytes
suffix:semicolon
)brace
multiline_comment|/* check, if we must compare all data or if we just have to&n;&t;&t; * compare the ecc bytes&n;&t;&t; */
r_if
c_cond
(paren
id|oobmode
)paren
(brace
r_if
c_cond
(paren
id|this
op_member_access_from_pointer
id|verify_buf
c_func
(paren
id|mtd
comma
op_amp
id|oob_buf
(braket
id|oobofs
)braket
comma
id|mtd-&gt;oobsize
op_minus
id|hweccbytes
op_star
id|eccsteps
)paren
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;%s: &quot;
l_string|&quot;Failed write verify, page 0x%08x &quot;
comma
id|__FUNCTION__
comma
id|page
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Read always, else autoincrement fails */
id|this
op_member_access_from_pointer
id|read_buf
c_func
(paren
id|mtd
comma
id|oobdata
comma
id|mtd-&gt;oobsize
op_minus
id|hweccbytes
op_star
id|eccsteps
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oobsel-&gt;useecc
op_ne
id|MTD_NANDECC_OFF
op_logical_and
op_logical_neg
id|hweccbytes
)paren
(brace
r_int
id|ecccnt
op_assign
id|oobsel-&gt;eccbytes
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ecccnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|idx
op_assign
id|oobsel-&gt;eccpos
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|oobdata
(braket
id|idx
)braket
op_ne
id|oob_buf
(braket
id|oobofs
op_plus
id|idx
)braket
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;%s: Failed ECC write &quot;
l_string|&quot;verify, page 0x%08x, &quot;
l_string|&quot;%6i bytes were succesful&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|page
comma
id|i
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
)brace
)brace
id|oobofs
op_add_assign
id|mtd-&gt;oobsize
op_minus
id|hweccbytes
op_star
id|eccsteps
suffix:semicolon
id|page
op_increment
suffix:semicolon
id|numpages
op_decrement
suffix:semicolon
multiline_comment|/* Apply delay or wait for ready/busy pin &n;&t;&t; * Do this before the AUTOINCR check, so no problems&n;&t;&t; * arise if a chip which does auto increment&n;&t;&t; * is marked as NOAUTOINCR by the board driver.&n;&t;&t; * Do this also before returning, so the chip is&n;&t;&t; * ready for the next command.&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;dev_ready
)paren
id|udelay
(paren
id|this-&gt;chip_delay
)paren
suffix:semicolon
r_else
r_while
c_loop
(paren
op_logical_neg
id|this
op_member_access_from_pointer
id|dev_ready
c_func
(paren
id|mtd
)paren
)paren
suffix:semicolon
multiline_comment|/* All done, return happy */
r_if
c_cond
(paren
op_logical_neg
id|numpages
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Check, if the chip supports auto page increment */
r_if
c_cond
(paren
op_logical_neg
id|NAND_CANAUTOINCR
c_func
(paren
id|this
)paren
)paren
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_READ0
comma
l_int|0x00
comma
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * Terminate the read command. We come here in case of an error&n;&t; * So we must issue a reset command.&n;&t; */
id|out
suffix:colon
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_RESET
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**&n; * nand_read - [MTD Interface] MTD compability function for nand_read_ecc&n; * @mtd:&t;MTD device structure&n; * @from:&t;offset to read from&n; * @len:&t;number of bytes to read&n; * @retlen:&t;pointer to variable to store the number of read bytes&n; * @buf:&t;the databuffer to put data&n; *&n; * This function simply calls nand_read_ecc with oob buffer and oobsel = NULL&n;*/
DECL|function|nand_read
r_static
r_int
id|nand_read
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
(brace
r_return
id|nand_read_ecc
(paren
id|mtd
comma
id|from
comma
id|len
comma
id|retlen
comma
id|buf
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_read_ecc - [MTD Interface] Read data with ECC&n; * @mtd:&t;MTD device structure&n; * @from:&t;offset to read from&n; * @len:&t;number of bytes to read&n; * @retlen:&t;pointer to variable to store the number of read bytes&n; * @buf:&t;the databuffer to put data&n; * @oob_buf:&t;filesystem supplied oob data buffer&n; * @oobsel:&t;oob selection structure&n; *&n; * NAND read with ECC&n; */
DECL|function|nand_read_ecc
r_static
r_int
id|nand_read_ecc
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
comma
id|u_char
op_star
id|oob_buf
comma
r_struct
id|nand_oobinfo
op_star
id|oobsel
)paren
(brace
r_int
id|i
comma
id|j
comma
id|col
comma
id|realpage
comma
id|page
comma
id|end
comma
id|ecc
comma
id|chipnr
comma
id|sndcmd
op_assign
l_int|1
suffix:semicolon
r_int
id|read
op_assign
l_int|0
comma
id|oob
op_assign
l_int|0
comma
id|ecc_status
op_assign
l_int|0
comma
id|ecc_failed
op_assign
l_int|0
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|u_char
op_star
id|data_poi
comma
op_star
id|oob_data
op_assign
id|oob_buf
suffix:semicolon
id|u_char
id|ecc_calc
(braket
l_int|32
)braket
suffix:semicolon
id|u_char
id|ecc_code
(braket
l_int|32
)braket
suffix:semicolon
r_int
id|eccmode
comma
id|eccsteps
suffix:semicolon
r_int
op_star
id|oob_config
comma
id|datidx
suffix:semicolon
r_int
id|blockcheck
op_assign
(paren
l_int|1
op_lshift
(paren
id|this-&gt;phys_erase_shift
op_minus
id|this-&gt;page_shift
)paren
)paren
op_minus
l_int|1
suffix:semicolon
r_int
id|eccbytes
suffix:semicolon
r_int
id|compareecc
op_assign
l_int|1
suffix:semicolon
r_int
id|oobreadlen
suffix:semicolon
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;nand_read_ecc: from = 0x%08x, len = %i&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|from
comma
(paren
r_int
)paren
id|len
)paren
suffix:semicolon
multiline_comment|/* Do not allow reads past end of device */
r_if
c_cond
(paren
(paren
id|from
op_plus
id|len
)paren
OG
id|mtd-&gt;size
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_read_ecc: Attempt read beyond end of device&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Grab the lock and see if the device is available */
id|nand_get_device
(paren
id|this
comma
id|mtd
comma
id|FL_READING
)paren
suffix:semicolon
multiline_comment|/* use userspace supplied oobinfo, if zero */
r_if
c_cond
(paren
id|oobsel
op_eq
l_int|NULL
)paren
id|oobsel
op_assign
op_amp
id|mtd-&gt;oobinfo
suffix:semicolon
multiline_comment|/* Autoplace of oob data ? Use the default placement scheme */
r_if
c_cond
(paren
id|oobsel-&gt;useecc
op_eq
id|MTD_NANDECC_AUTOPLACE
)paren
id|oobsel
op_assign
id|this-&gt;autooob
suffix:semicolon
id|eccmode
op_assign
id|oobsel-&gt;useecc
ques
c_cond
id|this-&gt;eccmode
suffix:colon
id|NAND_ECC_NONE
suffix:semicolon
id|oob_config
op_assign
id|oobsel-&gt;eccpos
suffix:semicolon
multiline_comment|/* Select the NAND device */
id|chipnr
op_assign
(paren
r_int
)paren
(paren
id|from
op_rshift
id|this-&gt;chip_shift
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|select_chip
c_func
(paren
id|mtd
comma
id|chipnr
)paren
suffix:semicolon
multiline_comment|/* First we calculate the starting page */
id|realpage
op_assign
(paren
r_int
)paren
(paren
id|from
op_rshift
id|this-&gt;page_shift
)paren
suffix:semicolon
id|page
op_assign
id|realpage
op_amp
id|this-&gt;pagemask
suffix:semicolon
multiline_comment|/* Get raw starting column */
id|col
op_assign
id|from
op_amp
(paren
id|mtd-&gt;oobblock
op_minus
l_int|1
)paren
suffix:semicolon
id|end
op_assign
id|mtd-&gt;oobblock
suffix:semicolon
id|ecc
op_assign
id|this-&gt;eccsize
suffix:semicolon
id|eccbytes
op_assign
id|this-&gt;eccbytes
suffix:semicolon
r_if
c_cond
(paren
(paren
id|eccmode
op_eq
id|NAND_ECC_NONE
)paren
op_logical_or
(paren
id|this-&gt;options
op_amp
id|NAND_HWECC_SYNDROME
)paren
)paren
id|compareecc
op_assign
l_int|0
suffix:semicolon
id|oobreadlen
op_assign
id|mtd-&gt;oobsize
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;options
op_amp
id|NAND_HWECC_SYNDROME
)paren
id|oobreadlen
op_sub_assign
id|oobsel-&gt;eccbytes
suffix:semicolon
multiline_comment|/* Loop until all data read */
r_while
c_loop
(paren
id|read
OL
id|len
)paren
(brace
r_int
id|aligned
op_assign
(paren
op_logical_neg
id|col
op_logical_and
(paren
id|len
op_minus
id|read
)paren
op_ge
id|end
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * If the read is not page aligned, we have to read into data buffer&n;&t;&t; * due to ecc, else we read into return buffer direct&n;&t;&t; */
r_if
c_cond
(paren
id|aligned
)paren
id|data_poi
op_assign
op_amp
id|buf
(braket
id|read
)braket
suffix:semicolon
r_else
id|data_poi
op_assign
id|this-&gt;data_buf
suffix:semicolon
multiline_comment|/* Check, if we have this page in the buffer &n;&t;&t; *&n;&t;&t; * FIXME: Make it work when we must provide oob data too,&n;&t;&t; * check the usage of data_buf oob field&n;&t;&t; */
r_if
c_cond
(paren
id|realpage
op_eq
id|this-&gt;pagebuf
op_logical_and
op_logical_neg
id|oob_buf
)paren
(brace
multiline_comment|/* aligned read ? */
r_if
c_cond
(paren
id|aligned
)paren
id|memcpy
(paren
id|data_poi
comma
id|this-&gt;data_buf
comma
id|end
)paren
suffix:semicolon
r_goto
id|readdata
suffix:semicolon
)brace
multiline_comment|/* Check, if we must send the read command */
r_if
c_cond
(paren
id|sndcmd
)paren
(brace
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_READ0
comma
l_int|0x00
comma
id|page
)paren
suffix:semicolon
id|sndcmd
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* get oob area, if we have no oob buffer from fs-driver */
r_if
c_cond
(paren
op_logical_neg
id|oob_buf
op_logical_or
id|oobsel-&gt;useecc
op_eq
id|MTD_NANDECC_AUTOPLACE
)paren
id|oob_data
op_assign
op_amp
id|this-&gt;data_buf
(braket
id|end
)braket
suffix:semicolon
id|eccsteps
op_assign
id|this-&gt;eccsteps
suffix:semicolon
r_switch
c_cond
(paren
id|eccmode
)paren
(brace
r_case
id|NAND_ECC_NONE
suffix:colon
(brace
multiline_comment|/* No ECC, Read in a page */
r_static
r_int
r_int
id|lastwhinge
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lastwhinge
op_div
id|HZ
)paren
op_ne
(paren
id|jiffies
op_div
id|HZ
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;Reading data from NAND FLASH without ECC is not recommended&bslash;n&quot;
)paren
suffix:semicolon
id|lastwhinge
op_assign
id|jiffies
suffix:semicolon
)brace
id|this
op_member_access_from_pointer
id|read_buf
c_func
(paren
id|mtd
comma
id|data_poi
comma
id|end
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|NAND_ECC_SOFT
suffix:colon
multiline_comment|/* Software ECC 3/256: Read in a page + oob data */
id|this
op_member_access_from_pointer
id|read_buf
c_func
(paren
id|mtd
comma
id|data_poi
comma
id|end
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|datidx
op_assign
l_int|0
suffix:semicolon
id|eccsteps
suffix:semicolon
id|eccsteps
op_decrement
comma
id|i
op_add_assign
l_int|3
comma
id|datidx
op_add_assign
id|ecc
)paren
id|this
op_member_access_from_pointer
id|calculate_ecc
c_func
(paren
id|mtd
comma
op_amp
id|data_poi
(braket
id|datidx
)braket
comma
op_amp
id|ecc_calc
(braket
id|i
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|datidx
op_assign
l_int|0
suffix:semicolon
id|eccsteps
suffix:semicolon
id|eccsteps
op_decrement
comma
id|i
op_add_assign
id|eccbytes
comma
id|datidx
op_add_assign
id|ecc
)paren
(brace
id|this
op_member_access_from_pointer
id|enable_hwecc
c_func
(paren
id|mtd
comma
id|NAND_ECC_READ
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|read_buf
c_func
(paren
id|mtd
comma
op_amp
id|data_poi
(braket
id|datidx
)braket
comma
id|ecc
)paren
suffix:semicolon
multiline_comment|/* HW ecc with syndrome calculation must read the&n;&t;&t;&t;&t; * syndrome from flash immidiately after the data */
r_if
c_cond
(paren
op_logical_neg
id|compareecc
)paren
(brace
multiline_comment|/* Some hw ecc generators need to know when the&n;&t;&t;&t;&t;&t; * syndrome is read from flash */
id|this
op_member_access_from_pointer
id|enable_hwecc
c_func
(paren
id|mtd
comma
id|NAND_ECC_READSYN
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|read_buf
c_func
(paren
id|mtd
comma
op_amp
id|oob_data
(braket
id|i
)braket
comma
id|eccbytes
)paren
suffix:semicolon
multiline_comment|/* We calc error correction directly, it checks the hw&n;&t;&t;&t;&t;&t; * generator for an error, reads back the syndrome and&n;&t;&t;&t;&t;&t; * does the error correction on the fly */
r_if
c_cond
(paren
id|this
op_member_access_from_pointer
id|correct_data
c_func
(paren
id|mtd
comma
op_amp
id|data_poi
(braket
id|datidx
)braket
comma
op_amp
id|oob_data
(braket
id|i
)braket
comma
op_amp
id|ecc_code
(braket
id|i
)braket
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_read_ecc: &quot;
l_string|&quot;Failed ECC read, page 0x%08x on chip %d&bslash;n&quot;
comma
id|page
comma
id|chipnr
)paren
suffix:semicolon
id|ecc_failed
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
id|this
op_member_access_from_pointer
id|calculate_ecc
c_func
(paren
id|mtd
comma
op_amp
id|data_poi
(braket
id|datidx
)braket
comma
op_amp
id|ecc_calc
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* read oobdata */
id|this
op_member_access_from_pointer
id|read_buf
c_func
(paren
id|mtd
comma
op_amp
id|oob_data
(braket
id|mtd-&gt;oobsize
op_minus
id|oobreadlen
)braket
comma
id|oobreadlen
)paren
suffix:semicolon
multiline_comment|/* Skip ECC check, if not requested (ECC_NONE or HW_ECC with syndromes) */
r_if
c_cond
(paren
op_logical_neg
id|compareecc
)paren
r_goto
id|readoob
suffix:semicolon
multiline_comment|/* Pick the ECC bytes out of the oob data */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|oobsel-&gt;eccbytes
suffix:semicolon
id|j
op_increment
)paren
id|ecc_code
(braket
id|j
)braket
op_assign
id|oob_data
(braket
id|oob_config
(braket
id|j
)braket
)braket
suffix:semicolon
multiline_comment|/* correct data, if neccecary */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
comma
id|datidx
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|this-&gt;eccsteps
suffix:semicolon
id|i
op_increment
comma
id|datidx
op_add_assign
id|ecc
)paren
(brace
id|ecc_status
op_assign
id|this
op_member_access_from_pointer
id|correct_data
c_func
(paren
id|mtd
comma
op_amp
id|data_poi
(braket
id|datidx
)braket
comma
op_amp
id|ecc_code
(braket
id|j
)braket
comma
op_amp
id|ecc_calc
(braket
id|j
)braket
)paren
suffix:semicolon
multiline_comment|/* Get next chunk of ecc bytes */
id|j
op_add_assign
id|eccbytes
suffix:semicolon
multiline_comment|/* Check, if we have a fs supplied oob-buffer, &n;&t;&t;&t; * This is the legacy mode. Used by YAFFS1&n;&t;&t;&t; * Should go away some day&n;&t;&t;&t; */
r_if
c_cond
(paren
id|oob_buf
op_logical_and
id|oobsel-&gt;useecc
op_eq
id|MTD_NANDECC_PLACE
)paren
(brace
r_int
op_star
id|p
op_assign
(paren
r_int
op_star
)paren
(paren
op_amp
id|oob_data
(braket
id|mtd-&gt;oobsize
)braket
)paren
suffix:semicolon
id|p
(braket
id|i
)braket
op_assign
id|ecc_status
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ecc_status
op_eq
op_minus
l_int|1
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_read_ecc: &quot;
l_string|&quot;Failed ECC read, page 0x%08x&bslash;n&quot;
comma
id|page
)paren
suffix:semicolon
id|ecc_failed
op_increment
suffix:semicolon
)brace
)brace
id|readoob
suffix:colon
multiline_comment|/* check, if we have a fs supplied oob-buffer */
r_if
c_cond
(paren
id|oob_buf
)paren
(brace
multiline_comment|/* without autoplace. Legacy mode used by YAFFS1 */
r_switch
c_cond
(paren
id|oobsel-&gt;useecc
)paren
(brace
r_case
id|MTD_NANDECC_AUTOPLACE
suffix:colon
multiline_comment|/* Walk through the autoplace chunks */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|mtd-&gt;oobavail
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|from
op_assign
id|oobsel-&gt;oobfree
(braket
id|i
)braket
(braket
l_int|0
)braket
suffix:semicolon
r_int
id|num
op_assign
id|oobsel-&gt;oobfree
(braket
id|i
)braket
(braket
l_int|1
)braket
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|oob_buf
(braket
id|oob
)braket
comma
op_amp
id|oob_data
(braket
id|from
)braket
comma
id|num
)paren
suffix:semicolon
id|j
op_add_assign
id|num
suffix:semicolon
)brace
id|oob
op_add_assign
id|mtd-&gt;oobavail
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTD_NANDECC_PLACE
suffix:colon
multiline_comment|/* YAFFS1 legacy mode */
id|oob_data
op_add_assign
id|this-&gt;eccsteps
op_star
r_sizeof
(paren
r_int
)paren
suffix:semicolon
r_default
suffix:colon
id|oob_data
op_add_assign
id|mtd-&gt;oobsize
suffix:semicolon
)brace
)brace
id|readdata
suffix:colon
multiline_comment|/* Partial page read, transfer data into fs buffer */
r_if
c_cond
(paren
op_logical_neg
id|aligned
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
id|col
suffix:semicolon
id|j
OL
id|end
op_logical_and
id|read
OL
id|len
suffix:semicolon
id|j
op_increment
)paren
id|buf
(braket
id|read
op_increment
)braket
op_assign
id|data_poi
(braket
id|j
)braket
suffix:semicolon
id|this-&gt;pagebuf
op_assign
id|realpage
suffix:semicolon
)brace
r_else
id|read
op_add_assign
id|mtd-&gt;oobblock
suffix:semicolon
multiline_comment|/* Apply delay or wait for ready/busy pin &n;&t;&t; * Do this before the AUTOINCR check, so no problems&n;&t;&t; * arise if a chip which does auto increment&n;&t;&t; * is marked as NOAUTOINCR by the board driver.&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;dev_ready
)paren
id|udelay
(paren
id|this-&gt;chip_delay
)paren
suffix:semicolon
r_else
r_while
c_loop
(paren
op_logical_neg
id|this
op_member_access_from_pointer
id|dev_ready
c_func
(paren
id|mtd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read
op_eq
id|len
)paren
r_break
suffix:semicolon
multiline_comment|/* For subsequent reads align to page boundary. */
id|col
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Increment page address */
id|realpage
op_increment
suffix:semicolon
id|page
op_assign
id|realpage
op_amp
id|this-&gt;pagemask
suffix:semicolon
multiline_comment|/* Check, if we cross a chip boundary */
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
id|chipnr
op_increment
suffix:semicolon
id|this
op_member_access_from_pointer
id|select_chip
c_func
(paren
id|mtd
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|select_chip
c_func
(paren
id|mtd
comma
id|chipnr
)paren
suffix:semicolon
)brace
multiline_comment|/* Check, if the chip supports auto page increment &n;&t;&t; * or if we have hit a block boundary. &n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|NAND_CANAUTOINCR
c_func
(paren
id|this
)paren
op_logical_or
op_logical_neg
(paren
id|page
op_amp
id|blockcheck
)paren
)paren
id|sndcmd
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Deselect and wake up anyone waiting on the device */
id|nand_release_device
c_func
(paren
id|mtd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Return success, if no ECC failures, else -EBADMSG&n;&t; * fs driver will take care of that, because&n;&t; * retlen == desired len and result == -EBADMSG&n;&t; */
op_star
id|retlen
op_assign
id|read
suffix:semicolon
r_return
id|ecc_failed
ques
c_cond
op_minus
id|EBADMSG
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_read_oob - [MTD Interface] NAND read out-of-band&n; * @mtd:&t;MTD device structure&n; * @from:&t;offset to read from&n; * @len:&t;number of bytes to read&n; * @retlen:&t;pointer to variable to store the number of read bytes&n; * @buf:&t;the databuffer to put data&n; *&n; * NAND read out-of-band data from the spare area&n; */
DECL|function|nand_read_oob
r_static
r_int
id|nand_read_oob
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
(brace
r_int
id|i
comma
id|col
comma
id|page
comma
id|chipnr
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_int
id|blockcheck
op_assign
(paren
l_int|1
op_lshift
(paren
id|this-&gt;phys_erase_shift
op_minus
id|this-&gt;page_shift
)paren
)paren
op_minus
l_int|1
suffix:semicolon
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;nand_read_oob: from = 0x%08x, len = %i&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|from
comma
(paren
r_int
)paren
id|len
)paren
suffix:semicolon
multiline_comment|/* Shift to get page */
id|page
op_assign
(paren
r_int
)paren
(paren
id|from
op_rshift
id|this-&gt;page_shift
)paren
suffix:semicolon
id|chipnr
op_assign
(paren
r_int
)paren
(paren
id|from
op_rshift
id|this-&gt;chip_shift
)paren
suffix:semicolon
multiline_comment|/* Mask to get column */
id|col
op_assign
id|from
op_amp
(paren
id|mtd-&gt;oobsize
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Initialize return length value */
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Do not allow reads past end of device */
r_if
c_cond
(paren
(paren
id|from
op_plus
id|len
)paren
OG
id|mtd-&gt;size
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_read_oob: Attempt read beyond end of device&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Grab the lock and see if the device is available */
id|nand_get_device
(paren
id|this
comma
id|mtd
comma
id|FL_READING
)paren
suffix:semicolon
multiline_comment|/* Select the NAND device */
id|this
op_member_access_from_pointer
id|select_chip
c_func
(paren
id|mtd
comma
id|chipnr
)paren
suffix:semicolon
multiline_comment|/* Send the read command */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_READOOB
comma
id|col
comma
id|page
op_amp
id|this-&gt;pagemask
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Read the data, if we read more than one page&n;&t; * oob data, let the device transfer the data !&n;&t; */
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|len
)paren
(brace
r_int
id|thislen
op_assign
id|mtd-&gt;oobsize
op_minus
id|col
suffix:semicolon
id|thislen
op_assign
id|min_t
c_func
(paren
r_int
comma
id|thislen
comma
id|len
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|read_buf
c_func
(paren
id|mtd
comma
op_amp
id|buf
(braket
id|i
)braket
comma
id|thislen
)paren
suffix:semicolon
id|i
op_add_assign
id|thislen
suffix:semicolon
multiline_comment|/* Apply delay or wait for ready/busy pin &n;&t;&t; * Do this before the AUTOINCR check, so no problems&n;&t;&t; * arise if a chip which does auto increment&n;&t;&t; * is marked as NOAUTOINCR by the board driver.&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;dev_ready
)paren
id|udelay
(paren
id|this-&gt;chip_delay
)paren
suffix:semicolon
r_else
r_while
c_loop
(paren
op_logical_neg
id|this
op_member_access_from_pointer
id|dev_ready
c_func
(paren
id|mtd
)paren
)paren
suffix:semicolon
multiline_comment|/* Read more ? */
r_if
c_cond
(paren
id|i
OL
id|len
)paren
(brace
id|page
op_increment
suffix:semicolon
id|col
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Check, if we cross a chip boundary */
r_if
c_cond
(paren
op_logical_neg
(paren
id|page
op_amp
id|this-&gt;pagemask
)paren
)paren
(brace
id|chipnr
op_increment
suffix:semicolon
id|this
op_member_access_from_pointer
id|select_chip
c_func
(paren
id|mtd
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|select_chip
c_func
(paren
id|mtd
comma
id|chipnr
)paren
suffix:semicolon
)brace
multiline_comment|/* Check, if the chip supports auto page increment &n;&t;&t;&t; * or if we have hit a block boundary. &n;&t;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|NAND_CANAUTOINCR
c_func
(paren
id|this
)paren
op_logical_or
op_logical_neg
(paren
id|page
op_amp
id|blockcheck
)paren
)paren
(brace
multiline_comment|/* For subsequent page reads set offset to 0 */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_READOOB
comma
l_int|0x0
comma
id|page
op_amp
id|this-&gt;pagemask
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Deselect and wake up anyone waiting on the device */
id|nand_release_device
c_func
(paren
id|mtd
)paren
suffix:semicolon
multiline_comment|/* Return happy */
op_star
id|retlen
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_read_raw - [GENERIC] Read raw data including oob into buffer&n; * @mtd:&t;MTD device structure&n; * @buf:&t;temporary buffer&n; * @from:&t;offset to read from&n; * @len:&t;number of bytes to read&n; * @ooblen:&t;number of oob data bytes to read&n; *&n; * Read raw data including oob into buffer&n; */
DECL|function|nand_read_raw
r_int
id|nand_read_raw
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_uint8
op_star
id|buf
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
id|ooblen
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_int
id|page
op_assign
(paren
r_int
)paren
(paren
id|from
op_rshift
id|this-&gt;page_shift
)paren
suffix:semicolon
r_int
id|chip
op_assign
(paren
r_int
)paren
(paren
id|from
op_rshift
id|this-&gt;chip_shift
)paren
suffix:semicolon
r_int
id|sndcmd
op_assign
l_int|1
suffix:semicolon
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_int
id|pagesize
op_assign
id|mtd-&gt;oobblock
op_plus
id|mtd-&gt;oobsize
suffix:semicolon
r_int
id|blockcheck
op_assign
(paren
l_int|1
op_lshift
(paren
id|this-&gt;phys_erase_shift
op_minus
id|this-&gt;page_shift
)paren
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Do not allow reads past end of device */
r_if
c_cond
(paren
(paren
id|from
op_plus
id|len
)paren
OG
id|mtd-&gt;size
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_read_raw: Attempt read beyond end of device&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Grab the lock and see if the device is available */
id|nand_get_device
(paren
id|this
comma
id|mtd
comma
id|FL_READING
)paren
suffix:semicolon
id|this-&gt;select_chip
(paren
id|mtd
comma
id|chip
)paren
suffix:semicolon
multiline_comment|/* Add requested oob length */
id|len
op_add_assign
id|ooblen
suffix:semicolon
r_while
c_loop
(paren
id|len
)paren
(brace
r_if
c_cond
(paren
id|sndcmd
)paren
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_READ0
comma
l_int|0
comma
id|page
op_amp
id|this-&gt;pagemask
)paren
suffix:semicolon
id|sndcmd
op_assign
l_int|0
suffix:semicolon
id|this-&gt;read_buf
(paren
id|mtd
comma
op_amp
id|buf
(braket
id|cnt
)braket
comma
id|pagesize
)paren
suffix:semicolon
id|len
op_sub_assign
id|pagesize
suffix:semicolon
id|cnt
op_add_assign
id|pagesize
suffix:semicolon
id|page
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;dev_ready
)paren
id|udelay
(paren
id|this-&gt;chip_delay
)paren
suffix:semicolon
r_else
r_while
c_loop
(paren
op_logical_neg
id|this
op_member_access_from_pointer
id|dev_ready
c_func
(paren
id|mtd
)paren
)paren
suffix:semicolon
multiline_comment|/* Check, if the chip supports auto page increment */
r_if
c_cond
(paren
op_logical_neg
id|NAND_CANAUTOINCR
c_func
(paren
id|this
)paren
op_logical_or
op_logical_neg
(paren
id|page
op_amp
id|blockcheck
)paren
)paren
id|sndcmd
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Deselect and wake up anyone waiting on the device */
id|nand_release_device
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/** &n; * nand_prepare_oobbuf - [GENERIC] Prepare the out of band buffer &n; * @mtd:&t;MTD device structure&n; * @fsbuf:&t;buffer given by fs driver&n; * @oobsel:&t;out of band selection structre&n; * @autoplace:&t;1 = place given buffer into the oob bytes&n; * @numpages:&t;number of pages to prepare&n; *&n; * Return:&n; * 1. Filesystem buffer available and autoplacement is off,&n; *    return filesystem buffer&n; * 2. No filesystem buffer or autoplace is off, return internal&n; *    buffer&n; * 3. Filesystem buffer is given and autoplace selected&n; *    put data from fs buffer into internal buffer and&n; *    retrun internal buffer&n; *&n; * Note: The internal buffer is filled with 0xff. This must&n; * be done only once, when no autoplacement happens&n; * Autoplacement sets the buffer dirty flag, which&n; * forces the 0xff fill before using the buffer again.&n; *&n;*/
DECL|function|nand_prepare_oobbuf
r_static
id|u_char
op_star
id|nand_prepare_oobbuf
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u_char
op_star
id|fsbuf
comma
r_struct
id|nand_oobinfo
op_star
id|oobsel
comma
r_int
id|autoplace
comma
r_int
id|numpages
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_int
id|i
comma
id|len
comma
id|ofs
suffix:semicolon
multiline_comment|/* Zero copy fs supplied buffer */
r_if
c_cond
(paren
id|fsbuf
op_logical_and
op_logical_neg
id|autoplace
)paren
r_return
id|fsbuf
suffix:semicolon
multiline_comment|/* Check, if the buffer must be filled with ff again */
r_if
c_cond
(paren
id|this-&gt;oobdirty
)paren
(brace
id|memset
(paren
id|this-&gt;oob_buf
comma
l_int|0xff
comma
id|mtd-&gt;oobsize
op_lshift
(paren
id|this-&gt;phys_erase_shift
op_minus
id|this-&gt;page_shift
)paren
)paren
suffix:semicolon
id|this-&gt;oobdirty
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If we have no autoplacement or no fs buffer use the internal one */
r_if
c_cond
(paren
op_logical_neg
id|autoplace
op_logical_or
op_logical_neg
id|fsbuf
)paren
r_return
id|this-&gt;oob_buf
suffix:semicolon
multiline_comment|/* Walk through the pages and place the data */
id|this-&gt;oobdirty
op_assign
l_int|1
suffix:semicolon
id|ofs
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|numpages
op_decrement
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|len
op_assign
l_int|0
suffix:semicolon
id|len
OL
id|mtd-&gt;oobavail
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|to
op_assign
id|ofs
op_plus
id|oobsel-&gt;oobfree
(braket
id|i
)braket
(braket
l_int|0
)braket
suffix:semicolon
r_int
id|num
op_assign
id|oobsel-&gt;oobfree
(braket
id|i
)braket
(braket
l_int|1
)braket
suffix:semicolon
id|memcpy
(paren
op_amp
id|this-&gt;oob_buf
(braket
id|to
)braket
comma
id|fsbuf
comma
id|num
)paren
suffix:semicolon
id|len
op_add_assign
id|num
suffix:semicolon
id|fsbuf
op_add_assign
id|num
suffix:semicolon
)brace
id|ofs
op_add_assign
id|mtd-&gt;oobavail
suffix:semicolon
)brace
r_return
id|this-&gt;oob_buf
suffix:semicolon
)brace
DECL|macro|NOTALIGNED
mdefine_line|#define NOTALIGNED(x) (x &amp; (mtd-&gt;oobblock-1)) != 0
multiline_comment|/**&n; * nand_write - [MTD Interface] compability function for nand_write_ecc&n; * @mtd:&t;MTD device structure&n; * @to:&t;&t;offset to write to&n; * @len:&t;number of bytes to write&n; * @retlen:&t;pointer to variable to store the number of written bytes&n; * @buf:&t;the data to write&n; *&n; * This function simply calls nand_write_ecc with oob buffer and oobsel = NULL&n; *&n;*/
DECL|function|nand_write
r_static
r_int
id|nand_write
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
(brace
r_return
(paren
id|nand_write_ecc
(paren
id|mtd
comma
id|to
comma
id|len
comma
id|retlen
comma
id|buf
comma
l_int|NULL
comma
l_int|NULL
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_write_ecc - [MTD Interface] NAND write with ECC&n; * @mtd:&t;MTD device structure&n; * @to:&t;&t;offset to write to&n; * @len:&t;number of bytes to write&n; * @retlen:&t;pointer to variable to store the number of written bytes&n; * @buf:&t;the data to write&n; * @eccbuf:&t;filesystem supplied oob data buffer&n; * @oobsel:&t;oob selection structure&n; *&n; * NAND write with ECC&n; */
DECL|function|nand_write_ecc
r_static
r_int
id|nand_write_ecc
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
comma
id|u_char
op_star
id|eccbuf
comma
r_struct
id|nand_oobinfo
op_star
id|oobsel
)paren
(brace
r_int
id|startpage
comma
id|page
comma
id|ret
op_assign
op_minus
id|EIO
comma
id|oob
op_assign
l_int|0
comma
id|written
op_assign
l_int|0
comma
id|chipnr
suffix:semicolon
r_int
id|autoplace
op_assign
l_int|0
comma
id|numpages
comma
id|totalpages
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|u_char
op_star
id|oobbuf
comma
op_star
id|bufstart
suffix:semicolon
r_int
id|ppblock
op_assign
(paren
l_int|1
op_lshift
(paren
id|this-&gt;phys_erase_shift
op_minus
id|this-&gt;page_shift
)paren
)paren
suffix:semicolon
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;nand_write_ecc: to = 0x%08x, len = %i&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|to
comma
(paren
r_int
)paren
id|len
)paren
suffix:semicolon
multiline_comment|/* Initialize retlen, in case of early exit */
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Do not allow write past end of device */
r_if
c_cond
(paren
(paren
id|to
op_plus
id|len
)paren
OG
id|mtd-&gt;size
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_write_ecc: Attempt to write past end of page&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* reject writes, which are not page aligned */
r_if
c_cond
(paren
id|NOTALIGNED
(paren
id|to
)paren
op_logical_or
id|NOTALIGNED
c_func
(paren
id|len
)paren
)paren
(brace
id|printk
(paren
id|KERN_NOTICE
l_string|&quot;nand_write_ecc: Attempt to write not page aligned data&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Grab the lock and see if the device is available */
id|nand_get_device
(paren
id|this
comma
id|mtd
comma
id|FL_WRITING
)paren
suffix:semicolon
multiline_comment|/* Calculate chipnr */
id|chipnr
op_assign
(paren
r_int
)paren
(paren
id|to
op_rshift
id|this-&gt;chip_shift
)paren
suffix:semicolon
multiline_comment|/* Select the NAND device */
id|this
op_member_access_from_pointer
id|select_chip
c_func
(paren
id|mtd
comma
id|chipnr
)paren
suffix:semicolon
multiline_comment|/* Check, if it is write protected */
r_if
c_cond
(paren
id|nand_check_wp
c_func
(paren
id|mtd
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* if oobsel is NULL, use chip defaults */
r_if
c_cond
(paren
id|oobsel
op_eq
l_int|NULL
)paren
id|oobsel
op_assign
op_amp
id|mtd-&gt;oobinfo
suffix:semicolon
multiline_comment|/* Autoplace of oob data ? Use the default placement scheme */
r_if
c_cond
(paren
id|oobsel-&gt;useecc
op_eq
id|MTD_NANDECC_AUTOPLACE
)paren
(brace
id|oobsel
op_assign
id|this-&gt;autooob
suffix:semicolon
id|autoplace
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Setup variables and oob buffer */
id|totalpages
op_assign
id|len
op_rshift
id|this-&gt;page_shift
suffix:semicolon
id|page
op_assign
(paren
r_int
)paren
(paren
id|to
op_rshift
id|this-&gt;page_shift
)paren
suffix:semicolon
multiline_comment|/* Invalidate the page cache, if we write to the cached page */
r_if
c_cond
(paren
id|page
op_le
id|this-&gt;pagebuf
op_logical_and
id|this-&gt;pagebuf
OL
(paren
id|page
op_plus
id|totalpages
)paren
)paren
id|this-&gt;pagebuf
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Set it relative to chip */
id|page
op_and_assign
id|this-&gt;pagemask
suffix:semicolon
id|startpage
op_assign
id|page
suffix:semicolon
multiline_comment|/* Calc number of pages we can write in one go */
id|numpages
op_assign
id|min
(paren
id|ppblock
op_minus
(paren
id|startpage
op_amp
(paren
id|ppblock
op_minus
l_int|1
)paren
)paren
comma
id|totalpages
)paren
suffix:semicolon
id|oobbuf
op_assign
id|nand_prepare_oobbuf
(paren
id|mtd
comma
id|eccbuf
comma
id|oobsel
comma
id|autoplace
comma
id|numpages
)paren
suffix:semicolon
id|bufstart
op_assign
(paren
id|u_char
op_star
)paren
id|buf
suffix:semicolon
multiline_comment|/* Loop until all data is written */
r_while
c_loop
(paren
id|written
OL
id|len
)paren
(brace
id|this-&gt;data_poi
op_assign
(paren
id|u_char
op_star
)paren
op_amp
id|buf
(braket
id|written
)braket
suffix:semicolon
multiline_comment|/* Write one page. If this is the last page to write&n;&t;&t; * or the last page in this block, then use the&n;&t;&t; * real pageprogram command, else select cached programming&n;&t;&t; * if supported by the chip.&n;&t;&t; */
id|ret
op_assign
id|nand_write_page
(paren
id|mtd
comma
id|this
comma
id|page
comma
op_amp
id|oobbuf
(braket
id|oob
)braket
comma
id|oobsel
comma
(paren
op_decrement
id|numpages
OG
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_write_ecc: write_page failed %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Next oob page */
id|oob
op_add_assign
id|mtd-&gt;oobsize
suffix:semicolon
multiline_comment|/* Update written bytes count */
id|written
op_add_assign
id|mtd-&gt;oobblock
suffix:semicolon
r_if
c_cond
(paren
id|written
op_eq
id|len
)paren
r_goto
id|cmp
suffix:semicolon
multiline_comment|/* Increment page address */
id|page
op_increment
suffix:semicolon
multiline_comment|/* Have we hit a block boundary ? Then we have to verify and&n;&t;&t; * if verify is ok, we have to setup the oob buffer for&n;&t;&t; * the next pages.&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|page
op_amp
(paren
id|ppblock
op_minus
l_int|1
)paren
)paren
)paren
(brace
r_int
id|ofs
suffix:semicolon
id|this-&gt;data_poi
op_assign
id|bufstart
suffix:semicolon
id|ret
op_assign
id|nand_verify_pages
(paren
id|mtd
comma
id|this
comma
id|startpage
comma
id|page
op_minus
id|startpage
comma
id|oobbuf
comma
id|oobsel
comma
id|chipnr
comma
(paren
id|eccbuf
op_ne
l_int|NULL
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_write_ecc: verify_pages failed %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
op_star
id|retlen
op_assign
id|written
suffix:semicolon
id|ofs
op_assign
id|autoplace
ques
c_cond
id|mtd-&gt;oobavail
suffix:colon
id|mtd-&gt;oobsize
suffix:semicolon
r_if
c_cond
(paren
id|eccbuf
)paren
id|eccbuf
op_add_assign
(paren
id|page
op_minus
id|startpage
)paren
op_star
id|ofs
suffix:semicolon
id|totalpages
op_sub_assign
id|page
op_minus
id|startpage
suffix:semicolon
id|numpages
op_assign
id|min
(paren
id|totalpages
comma
id|ppblock
)paren
suffix:semicolon
id|page
op_and_assign
id|this-&gt;pagemask
suffix:semicolon
id|startpage
op_assign
id|page
suffix:semicolon
id|oobbuf
op_assign
id|nand_prepare_oobbuf
(paren
id|mtd
comma
id|eccbuf
comma
id|oobsel
comma
id|autoplace
comma
id|numpages
)paren
suffix:semicolon
multiline_comment|/* Check, if we cross a chip boundary */
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
id|chipnr
op_increment
suffix:semicolon
id|this
op_member_access_from_pointer
id|select_chip
c_func
(paren
id|mtd
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|select_chip
c_func
(paren
id|mtd
comma
id|chipnr
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Verify the remaining pages */
id|cmp
suffix:colon
id|this-&gt;data_poi
op_assign
id|bufstart
suffix:semicolon
id|ret
op_assign
id|nand_verify_pages
(paren
id|mtd
comma
id|this
comma
id|startpage
comma
id|totalpages
comma
id|oobbuf
comma
id|oobsel
comma
id|chipnr
comma
(paren
id|eccbuf
op_ne
l_int|NULL
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
op_star
id|retlen
op_assign
id|written
suffix:semicolon
r_else
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_write_ecc: verify_pages failed %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
id|out
suffix:colon
multiline_comment|/* Deselect and wake up anyone waiting on the device */
id|nand_release_device
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_write_oob - [MTD Interface] NAND write out-of-band&n; * @mtd:&t;MTD device structure&n; * @to:&t;&t;offset to write to&n; * @len:&t;number of bytes to write&n; * @retlen:&t;pointer to variable to store the number of written bytes&n; * @buf:&t;the data to write&n; *&n; * NAND write out-of-band&n; */
DECL|function|nand_write_oob
r_static
r_int
id|nand_write_oob
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
(brace
r_int
id|column
comma
id|page
comma
id|status
comma
id|ret
op_assign
op_minus
id|EIO
comma
id|chipnr
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;nand_write_oob: to = 0x%08x, len = %i&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|to
comma
(paren
r_int
)paren
id|len
)paren
suffix:semicolon
multiline_comment|/* Shift to get page */
id|page
op_assign
(paren
r_int
)paren
(paren
id|to
op_rshift
id|this-&gt;page_shift
)paren
suffix:semicolon
id|chipnr
op_assign
(paren
r_int
)paren
(paren
id|to
op_rshift
id|this-&gt;chip_shift
)paren
suffix:semicolon
multiline_comment|/* Mask to get column */
id|column
op_assign
id|to
op_amp
(paren
id|mtd-&gt;oobsize
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Initialize return length value */
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Do not allow write past end of page */
r_if
c_cond
(paren
(paren
id|column
op_plus
id|len
)paren
OG
id|mtd-&gt;oobsize
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_write_oob: Attempt to write past end of page&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Grab the lock and see if the device is available */
id|nand_get_device
(paren
id|this
comma
id|mtd
comma
id|FL_WRITING
)paren
suffix:semicolon
multiline_comment|/* Select the NAND device */
id|this
op_member_access_from_pointer
id|select_chip
c_func
(paren
id|mtd
comma
id|chipnr
)paren
suffix:semicolon
multiline_comment|/* Reset the chip. Some chips (like the Toshiba TC5832DC found&n;&t;   in one of my DiskOnChip 2000 test units) will clear the whole&n;&t;   data page too if we don&squot;t do this. I have no clue why, but&n;&t;   I seem to have &squot;fixed&squot; it in the doc2000 driver in&n;&t;   August 1999.  dwmw2. */
id|this
op_member_access_from_pointer
id|cmdfunc
c_func
(paren
id|mtd
comma
id|NAND_CMD_RESET
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Check, if it is write protected */
r_if
c_cond
(paren
id|nand_check_wp
c_func
(paren
id|mtd
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Invalidate the page cache, if we write to the cached page */
r_if
c_cond
(paren
id|page
op_eq
id|this-&gt;pagebuf
)paren
id|this-&gt;pagebuf
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|NAND_MUST_PAD
c_func
(paren
id|this
)paren
)paren
(brace
multiline_comment|/* Write out desired data */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_SEQIN
comma
id|mtd-&gt;oobblock
comma
id|page
op_amp
id|this-&gt;pagemask
)paren
suffix:semicolon
multiline_comment|/* prepad 0xff for partial programming */
id|this
op_member_access_from_pointer
id|write_buf
c_func
(paren
id|mtd
comma
id|ffchars
comma
id|column
)paren
suffix:semicolon
multiline_comment|/* write data */
id|this
op_member_access_from_pointer
id|write_buf
c_func
(paren
id|mtd
comma
id|buf
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* postpad 0xff for partial programming */
id|this
op_member_access_from_pointer
id|write_buf
c_func
(paren
id|mtd
comma
id|ffchars
comma
id|mtd-&gt;oobsize
op_minus
(paren
id|len
op_plus
id|column
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Write out desired data */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_SEQIN
comma
id|mtd-&gt;oobblock
op_plus
id|column
comma
id|page
op_amp
id|this-&gt;pagemask
)paren
suffix:semicolon
multiline_comment|/* write data */
id|this
op_member_access_from_pointer
id|write_buf
c_func
(paren
id|mtd
comma
id|buf
comma
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/* Send command to program the OOB data */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_PAGEPROG
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|status
op_assign
id|this-&gt;waitfunc
(paren
id|mtd
comma
id|this
comma
id|FL_WRITING
)paren
suffix:semicolon
multiline_comment|/* See if device thinks it succeeded */
r_if
c_cond
(paren
id|status
op_amp
l_int|0x01
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_write_oob: &quot;
l_string|&quot;Failed write, page 0x%08x&bslash;n&quot;
comma
id|page
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Return happy */
op_star
id|retlen
op_assign
id|len
suffix:semicolon
macro_line|#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
multiline_comment|/* Send command to read back the data */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_READOOB
comma
id|column
comma
id|page
op_amp
id|this-&gt;pagemask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|this
op_member_access_from_pointer
id|verify_buf
c_func
(paren
id|mtd
comma
id|buf
comma
id|len
)paren
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_write_oob: &quot;
l_string|&quot;Failed write verify, page 0x%08x&bslash;n&quot;
comma
id|page
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
macro_line|#endif
id|ret
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
multiline_comment|/* Deselect and wake up anyone waiting on the device */
id|nand_release_device
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_writev - [MTD Interface] compabilty function for nand_writev_ecc&n; * @mtd:&t;MTD device structure&n; * @vecs:&t;the iovectors to write&n; * @count:&t;number of vectors&n; * @to:&t;&t;offset to write to&n; * @retlen:&t;pointer to variable to store the number of written bytes&n; *&n; * NAND write with kvec. This just calls the ecc function&n; */
DECL|function|nand_writev
r_static
r_int
id|nand_writev
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
r_struct
id|kvec
op_star
id|vecs
comma
r_int
r_int
id|count
comma
id|loff_t
id|to
comma
r_int
op_star
id|retlen
)paren
(brace
r_return
(paren
id|nand_writev_ecc
(paren
id|mtd
comma
id|vecs
comma
id|count
comma
id|to
comma
id|retlen
comma
l_int|NULL
comma
l_int|NULL
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_writev_ecc - [MTD Interface] write with iovec with ecc&n; * @mtd:&t;MTD device structure&n; * @vecs:&t;the iovectors to write&n; * @count:&t;number of vectors&n; * @to:&t;&t;offset to write to&n; * @retlen:&t;pointer to variable to store the number of written bytes&n; * @eccbuf:&t;filesystem supplied oob data buffer&n; * @oobsel:&t;oob selection structure&n; *&n; * NAND write with iovec with ecc&n; */
DECL|function|nand_writev_ecc
r_static
r_int
id|nand_writev_ecc
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_const
r_struct
id|kvec
op_star
id|vecs
comma
r_int
r_int
id|count
comma
id|loff_t
id|to
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|eccbuf
comma
r_struct
id|nand_oobinfo
op_star
id|oobsel
)paren
(brace
r_int
id|i
comma
id|page
comma
id|len
comma
id|total_len
comma
id|ret
op_assign
op_minus
id|EIO
comma
id|written
op_assign
l_int|0
comma
id|chipnr
suffix:semicolon
r_int
id|oob
comma
id|numpages
comma
id|autoplace
op_assign
l_int|0
comma
id|startpage
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_int
id|ppblock
op_assign
(paren
l_int|1
op_lshift
(paren
id|this-&gt;phys_erase_shift
op_minus
id|this-&gt;page_shift
)paren
)paren
suffix:semicolon
id|u_char
op_star
id|oobbuf
comma
op_star
id|bufstart
suffix:semicolon
multiline_comment|/* Preset written len for early exit */
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Calculate total length of data */
id|total_len
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
id|total_len
op_add_assign
(paren
r_int
)paren
id|vecs
(braket
id|i
)braket
dot
id|iov_len
suffix:semicolon
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;nand_writev: to = 0x%08x, len = %i, count = %ld&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|to
comma
(paren
r_int
r_int
)paren
id|total_len
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* Do not allow write past end of page */
r_if
c_cond
(paren
(paren
id|to
op_plus
id|total_len
)paren
OG
id|mtd-&gt;size
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_writev: Attempted write past end of device&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* reject writes, which are not page aligned */
r_if
c_cond
(paren
id|NOTALIGNED
(paren
id|to
)paren
op_logical_or
id|NOTALIGNED
c_func
(paren
id|total_len
)paren
)paren
(brace
id|printk
(paren
id|KERN_NOTICE
l_string|&quot;nand_write_ecc: Attempt to write not page aligned data&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Grab the lock and see if the device is available */
id|nand_get_device
(paren
id|this
comma
id|mtd
comma
id|FL_WRITING
)paren
suffix:semicolon
multiline_comment|/* Get the current chip-nr */
id|chipnr
op_assign
(paren
r_int
)paren
(paren
id|to
op_rshift
id|this-&gt;chip_shift
)paren
suffix:semicolon
multiline_comment|/* Select the NAND device */
id|this
op_member_access_from_pointer
id|select_chip
c_func
(paren
id|mtd
comma
id|chipnr
)paren
suffix:semicolon
multiline_comment|/* Check, if it is write protected */
r_if
c_cond
(paren
id|nand_check_wp
c_func
(paren
id|mtd
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* if oobsel is NULL, use chip defaults */
r_if
c_cond
(paren
id|oobsel
op_eq
l_int|NULL
)paren
id|oobsel
op_assign
op_amp
id|mtd-&gt;oobinfo
suffix:semicolon
multiline_comment|/* Autoplace of oob data ? Use the default placement scheme */
r_if
c_cond
(paren
id|oobsel-&gt;useecc
op_eq
id|MTD_NANDECC_AUTOPLACE
)paren
(brace
id|oobsel
op_assign
id|this-&gt;autooob
suffix:semicolon
id|autoplace
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Setup start page */
id|page
op_assign
(paren
r_int
)paren
(paren
id|to
op_rshift
id|this-&gt;page_shift
)paren
suffix:semicolon
multiline_comment|/* Invalidate the page cache, if we write to the cached page */
r_if
c_cond
(paren
id|page
op_le
id|this-&gt;pagebuf
op_logical_and
id|this-&gt;pagebuf
OL
(paren
(paren
id|to
op_plus
id|total_len
)paren
op_rshift
id|this-&gt;page_shift
)paren
)paren
id|this-&gt;pagebuf
op_assign
op_minus
l_int|1
suffix:semicolon
id|startpage
op_assign
id|page
op_amp
id|this-&gt;pagemask
suffix:semicolon
multiline_comment|/* Loop until all kvec&squot; data has been written */
id|len
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
multiline_comment|/* If the given tuple is &gt;= pagesize then&n;&t;&t; * write it out from the iov&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|vecs-&gt;iov_len
op_minus
id|len
)paren
op_ge
id|mtd-&gt;oobblock
)paren
(brace
multiline_comment|/* Calc number of pages we can write&n;&t;&t;&t; * out of this iov in one go */
id|numpages
op_assign
(paren
id|vecs-&gt;iov_len
op_minus
id|len
)paren
op_rshift
id|this-&gt;page_shift
suffix:semicolon
multiline_comment|/* Do not cross block boundaries */
id|numpages
op_assign
id|min
(paren
id|ppblock
op_minus
(paren
id|startpage
op_amp
(paren
id|ppblock
op_minus
l_int|1
)paren
)paren
comma
id|numpages
)paren
suffix:semicolon
id|oobbuf
op_assign
id|nand_prepare_oobbuf
(paren
id|mtd
comma
l_int|NULL
comma
id|oobsel
comma
id|autoplace
comma
id|numpages
)paren
suffix:semicolon
id|bufstart
op_assign
(paren
id|u_char
op_star
)paren
id|vecs-&gt;iov_base
suffix:semicolon
id|bufstart
op_add_assign
id|len
suffix:semicolon
id|this-&gt;data_poi
op_assign
id|bufstart
suffix:semicolon
id|oob
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|numpages
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Write one page. If this is the last page to write&n;&t;&t;&t;&t; * then use the real pageprogram command, else select &n;&t;&t;&t;&t; * cached programming if supported by the chip.&n;&t;&t;&t;&t; */
id|ret
op_assign
id|nand_write_page
(paren
id|mtd
comma
id|this
comma
id|page
op_amp
id|this-&gt;pagemask
comma
op_amp
id|oobbuf
(braket
id|oob
)braket
comma
id|oobsel
comma
id|i
op_ne
id|numpages
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
id|this-&gt;data_poi
op_add_assign
id|mtd-&gt;oobblock
suffix:semicolon
id|len
op_add_assign
id|mtd-&gt;oobblock
suffix:semicolon
id|oob
op_add_assign
id|mtd-&gt;oobsize
suffix:semicolon
id|page
op_increment
suffix:semicolon
)brace
multiline_comment|/* Check, if we have to switch to the next tuple */
r_if
c_cond
(paren
id|len
op_ge
(paren
r_int
)paren
id|vecs-&gt;iov_len
)paren
(brace
id|vecs
op_increment
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
id|count
op_decrement
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* We must use the internal buffer, read data out of each &n;&t;&t;&t; * tuple until we have a full page to write&n;&t;&t;&t; */
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cnt
OL
id|mtd-&gt;oobblock
)paren
(brace
r_if
c_cond
(paren
id|vecs-&gt;iov_base
op_ne
l_int|NULL
op_logical_and
id|vecs-&gt;iov_len
)paren
id|this-&gt;data_buf
(braket
id|cnt
op_increment
)braket
op_assign
(paren
(paren
id|u_char
op_star
)paren
id|vecs-&gt;iov_base
)paren
(braket
id|len
op_increment
)braket
suffix:semicolon
multiline_comment|/* Check, if we have to switch to the next tuple */
r_if
c_cond
(paren
id|len
op_ge
(paren
r_int
)paren
id|vecs-&gt;iov_len
)paren
(brace
id|vecs
op_increment
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
id|count
op_decrement
suffix:semicolon
)brace
)brace
id|this-&gt;pagebuf
op_assign
id|page
suffix:semicolon
id|this-&gt;data_poi
op_assign
id|this-&gt;data_buf
suffix:semicolon
id|bufstart
op_assign
id|this-&gt;data_poi
suffix:semicolon
id|numpages
op_assign
l_int|1
suffix:semicolon
id|oobbuf
op_assign
id|nand_prepare_oobbuf
(paren
id|mtd
comma
l_int|NULL
comma
id|oobsel
comma
id|autoplace
comma
id|numpages
)paren
suffix:semicolon
id|ret
op_assign
id|nand_write_page
(paren
id|mtd
comma
id|this
comma
id|page
op_amp
id|this-&gt;pagemask
comma
id|oobbuf
comma
id|oobsel
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
id|page
op_increment
suffix:semicolon
)brace
id|this-&gt;data_poi
op_assign
id|bufstart
suffix:semicolon
id|ret
op_assign
id|nand_verify_pages
(paren
id|mtd
comma
id|this
comma
id|startpage
comma
id|numpages
comma
id|oobbuf
comma
id|oobsel
comma
id|chipnr
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
id|written
op_add_assign
id|mtd-&gt;oobblock
op_star
id|numpages
suffix:semicolon
multiline_comment|/* All done ? */
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
r_break
suffix:semicolon
id|startpage
op_assign
id|page
op_amp
id|this-&gt;pagemask
suffix:semicolon
multiline_comment|/* Check, if we cross a chip boundary */
r_if
c_cond
(paren
op_logical_neg
id|startpage
)paren
(brace
id|chipnr
op_increment
suffix:semicolon
id|this
op_member_access_from_pointer
id|select_chip
c_func
(paren
id|mtd
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|select_chip
c_func
(paren
id|mtd
comma
id|chipnr
)paren
suffix:semicolon
)brace
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
multiline_comment|/* Deselect and wake up anyone waiting on the device */
id|nand_release_device
c_func
(paren
id|mtd
)paren
suffix:semicolon
op_star
id|retlen
op_assign
id|written
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * single_erease_cmd - [GENERIC] NAND standard block erase command function&n; * @mtd:&t;MTD device structure&n; * @page:&t;the page address of the block which will be erased&n; *&n; * Standard erase command for NAND chips&n; */
DECL|function|single_erase_cmd
r_static
r_void
id|single_erase_cmd
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|page
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
multiline_comment|/* Send commands to erase a block */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_ERASE1
comma
op_minus
l_int|1
comma
id|page
)paren
suffix:semicolon
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_ERASE2
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * multi_erease_cmd - [GENERIC] AND specific block erase command function&n; * @mtd:&t;MTD device structure&n; * @page:&t;the page address of the block which will be erased&n; *&n; * AND multi block erase command function&n; * Erase 4 consecutive blocks&n; */
DECL|function|multi_erase_cmd
r_static
r_void
id|multi_erase_cmd
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|page
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
multiline_comment|/* Send commands to erase a block */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_ERASE1
comma
op_minus
l_int|1
comma
id|page
op_increment
)paren
suffix:semicolon
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_ERASE1
comma
op_minus
l_int|1
comma
id|page
op_increment
)paren
suffix:semicolon
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_ERASE1
comma
op_minus
l_int|1
comma
id|page
op_increment
)paren
suffix:semicolon
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_ERASE1
comma
op_minus
l_int|1
comma
id|page
)paren
suffix:semicolon
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_ERASE2
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_erase - [MTD Interface] erase block(s)&n; * @mtd:&t;MTD device structure&n; * @instr:&t;erase instruction&n; *&n; * Erase one ore more blocks&n; */
DECL|function|nand_erase
r_static
r_int
id|nand_erase
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|erase_info
op_star
id|instr
)paren
(brace
r_return
id|nand_erase_nand
(paren
id|mtd
comma
id|instr
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_erase_intern - [NAND Interface] erase block(s)&n; * @mtd:&t;MTD device structure&n; * @instr:&t;erase instruction&n; * @allowbbt:&t;allow erasing the bbt area&n; *&n; * Erase one ore more blocks&n; */
DECL|function|nand_erase_nand
r_int
id|nand_erase_nand
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|erase_info
op_star
id|instr
comma
r_int
id|allowbbt
)paren
(brace
r_int
id|page
comma
id|len
comma
id|status
comma
id|pages_per_block
comma
id|ret
comma
id|chipnr
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;nand_erase: start = 0x%08x, len = %i&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|instr-&gt;addr
comma
(paren
r_int
r_int
)paren
id|instr-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Start address must align on block boundary */
r_if
c_cond
(paren
id|instr-&gt;addr
op_amp
(paren
(paren
l_int|1
op_lshift
id|this-&gt;phys_erase_shift
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_erase: Unaligned address&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Length must align on block boundary */
r_if
c_cond
(paren
id|instr-&gt;len
op_amp
(paren
(paren
l_int|1
op_lshift
id|this-&gt;phys_erase_shift
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_erase: Length not block aligned&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Do not allow erase past end of device */
r_if
c_cond
(paren
(paren
id|instr-&gt;len
op_plus
id|instr-&gt;addr
)paren
OG
id|mtd-&gt;size
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_erase: Erase past end of device&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|instr-&gt;fail_addr
op_assign
l_int|0xffffffff
suffix:semicolon
multiline_comment|/* Grab the lock and see if the device is available */
id|nand_get_device
(paren
id|this
comma
id|mtd
comma
id|FL_ERASING
)paren
suffix:semicolon
multiline_comment|/* Shift to get first page */
id|page
op_assign
(paren
r_int
)paren
(paren
id|instr-&gt;addr
op_rshift
id|this-&gt;page_shift
)paren
suffix:semicolon
id|chipnr
op_assign
(paren
r_int
)paren
(paren
id|instr-&gt;addr
op_rshift
id|this-&gt;chip_shift
)paren
suffix:semicolon
multiline_comment|/* Calculate pages in each block */
id|pages_per_block
op_assign
l_int|1
op_lshift
(paren
id|this-&gt;phys_erase_shift
op_minus
id|this-&gt;page_shift
)paren
suffix:semicolon
multiline_comment|/* Select the NAND device */
id|this
op_member_access_from_pointer
id|select_chip
c_func
(paren
id|mtd
comma
id|chipnr
)paren
suffix:semicolon
multiline_comment|/* Check the WP bit */
multiline_comment|/* Check, if it is write protected */
r_if
c_cond
(paren
id|nand_check_wp
c_func
(paren
id|mtd
)paren
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_erase: Device is write protected!!!&bslash;n&quot;
)paren
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASE_FAILED
suffix:semicolon
r_goto
id|erase_exit
suffix:semicolon
)brace
multiline_comment|/* Loop through the pages */
id|len
op_assign
id|instr-&gt;len
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASING
suffix:semicolon
r_while
c_loop
(paren
id|len
)paren
(brace
multiline_comment|/* Check if we have a bad block, we do not erase bad blocks ! */
r_if
c_cond
(paren
id|nand_block_checkbad
c_func
(paren
id|mtd
comma
(paren
(paren
id|loff_t
)paren
id|page
)paren
op_lshift
id|this-&gt;page_shift
comma
l_int|0
comma
id|allowbbt
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;nand_erase: attempt to erase a bad block at page 0x%08x&bslash;n&quot;
comma
id|page
)paren
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASE_FAILED
suffix:semicolon
r_goto
id|erase_exit
suffix:semicolon
)brace
multiline_comment|/* Invalidate the page cache, if we erase the block which contains &n;&t;&t;   the current cached page */
r_if
c_cond
(paren
id|page
op_le
id|this-&gt;pagebuf
op_logical_and
id|this-&gt;pagebuf
OL
(paren
id|page
op_plus
id|pages_per_block
)paren
)paren
id|this-&gt;pagebuf
op_assign
op_minus
l_int|1
suffix:semicolon
id|this-&gt;erase_cmd
(paren
id|mtd
comma
id|page
op_amp
id|this-&gt;pagemask
)paren
suffix:semicolon
id|status
op_assign
id|this-&gt;waitfunc
(paren
id|mtd
comma
id|this
comma
id|FL_ERASING
)paren
suffix:semicolon
multiline_comment|/* See if block erase succeeded */
r_if
c_cond
(paren
id|status
op_amp
l_int|0x01
)paren
(brace
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;nand_erase: &quot;
l_string|&quot;Failed erase, page 0x%08x&bslash;n&quot;
comma
id|page
)paren
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASE_FAILED
suffix:semicolon
id|instr-&gt;fail_addr
op_assign
(paren
id|page
op_lshift
id|this-&gt;page_shift
)paren
suffix:semicolon
r_goto
id|erase_exit
suffix:semicolon
)brace
multiline_comment|/* Increment page address and decrement length */
id|len
op_sub_assign
(paren
l_int|1
op_lshift
id|this-&gt;phys_erase_shift
)paren
suffix:semicolon
id|page
op_add_assign
id|pages_per_block
suffix:semicolon
multiline_comment|/* Check, if we cross a chip boundary */
r_if
c_cond
(paren
id|len
op_logical_and
op_logical_neg
(paren
id|page
op_amp
id|this-&gt;pagemask
)paren
)paren
(brace
id|chipnr
op_increment
suffix:semicolon
id|this
op_member_access_from_pointer
id|select_chip
c_func
(paren
id|mtd
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|select_chip
c_func
(paren
id|mtd
comma
id|chipnr
)paren
suffix:semicolon
)brace
)brace
id|instr-&gt;state
op_assign
id|MTD_ERASE_DONE
suffix:semicolon
id|erase_exit
suffix:colon
id|ret
op_assign
id|instr-&gt;state
op_eq
id|MTD_ERASE_DONE
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* Do call back function */
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|mtd_erase_callback
c_func
(paren
id|instr
)paren
suffix:semicolon
multiline_comment|/* Deselect and wake up anyone waiting on the device */
id|nand_release_device
c_func
(paren
id|mtd
)paren
suffix:semicolon
multiline_comment|/* Return more or less happy */
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_sync - [MTD Interface] sync&n; * @mtd:&t;MTD device structure&n; *&n; * Sync is actually a wait for chip ready function&n; */
DECL|function|nand_sync
r_static
r_void
id|nand_sync
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|DEBUG
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;nand_sync: called&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Grab the lock and see if the device is available */
id|nand_get_device
(paren
id|this
comma
id|mtd
comma
id|FL_SYNCING
)paren
suffix:semicolon
multiline_comment|/* Release it and go back */
id|nand_release_device
(paren
id|mtd
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_block_isbad - [MTD Interface] Check whether the block at the given offset is bad&n; * @mtd:&t;MTD device structure&n; * @ofs:&t;offset relative to mtd start&n; */
DECL|function|nand_block_isbad
r_static
r_int
id|nand_block_isbad
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|ofs
)paren
(brace
multiline_comment|/* Check for invalid offset */
r_if
c_cond
(paren
id|ofs
OG
id|mtd-&gt;size
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|nand_block_checkbad
(paren
id|mtd
comma
id|ofs
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_block_markbad - [MTD Interface] Mark the block at the given offset as bad&n; * @mtd:&t;MTD device structure&n; * @ofs:&t;offset relative to mtd start&n; */
DECL|function|nand_block_markbad
r_static
r_int
id|nand_block_markbad
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|ofs
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|nand_block_isbad
c_func
(paren
id|mtd
comma
id|ofs
)paren
)paren
)paren
(brace
multiline_comment|/* If it was bad already, return success and do nothing. */
r_if
c_cond
(paren
id|ret
OG
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_return
id|this
op_member_access_from_pointer
id|block_markbad
c_func
(paren
id|mtd
comma
id|ofs
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_scan - [NAND Interface] Scan for the NAND device&n; * @mtd:&t;MTD device structure&n; * @maxchips:&t;Number of chips to scan for&n; *&n; * This fills out all the not initialized function pointers&n; * with the defaults.&n; * The flash ID is read and the mtd/chip structures are&n; * filled with the appropriate values. Buffers are allocated if&n; * they are not provided by the board driver&n; *&n; */
DECL|function|nand_scan
r_int
id|nand_scan
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
id|maxchips
)paren
(brace
r_int
id|i
comma
id|j
comma
id|nand_maf_id
comma
id|nand_dev_id
comma
id|busw
suffix:semicolon
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
multiline_comment|/* Get buswidth to select the correct functions*/
id|busw
op_assign
id|this-&gt;options
op_amp
id|NAND_BUSWIDTH_16
suffix:semicolon
multiline_comment|/* check for proper chip_delay setup, set 20us if not */
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;chip_delay
)paren
id|this-&gt;chip_delay
op_assign
l_int|20
suffix:semicolon
multiline_comment|/* check, if a user supplied command function given */
r_if
c_cond
(paren
id|this-&gt;cmdfunc
op_eq
l_int|NULL
)paren
id|this-&gt;cmdfunc
op_assign
id|nand_command
suffix:semicolon
multiline_comment|/* check, if a user supplied wait function given */
r_if
c_cond
(paren
id|this-&gt;waitfunc
op_eq
l_int|NULL
)paren
id|this-&gt;waitfunc
op_assign
id|nand_wait
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;select_chip
)paren
id|this-&gt;select_chip
op_assign
id|nand_select_chip
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;write_byte
)paren
id|this-&gt;write_byte
op_assign
id|busw
ques
c_cond
id|nand_write_byte16
suffix:colon
id|nand_write_byte
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;read_byte
)paren
id|this-&gt;read_byte
op_assign
id|busw
ques
c_cond
id|nand_read_byte16
suffix:colon
id|nand_read_byte
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;write_word
)paren
id|this-&gt;write_word
op_assign
id|nand_write_word
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;read_word
)paren
id|this-&gt;read_word
op_assign
id|nand_read_word
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;block_bad
)paren
id|this-&gt;block_bad
op_assign
id|nand_block_bad
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;block_markbad
)paren
id|this-&gt;block_markbad
op_assign
id|nand_default_block_markbad
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;write_buf
)paren
id|this-&gt;write_buf
op_assign
id|busw
ques
c_cond
id|nand_write_buf16
suffix:colon
id|nand_write_buf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;read_buf
)paren
id|this-&gt;read_buf
op_assign
id|busw
ques
c_cond
id|nand_read_buf16
suffix:colon
id|nand_read_buf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;verify_buf
)paren
id|this-&gt;verify_buf
op_assign
id|busw
ques
c_cond
id|nand_verify_buf16
suffix:colon
id|nand_verify_buf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;scan_bbt
)paren
id|this-&gt;scan_bbt
op_assign
id|nand_default_bbt
suffix:semicolon
multiline_comment|/* Select the device */
id|this
op_member_access_from_pointer
id|select_chip
c_func
(paren
id|mtd
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Send the command for reading device ID */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_READID
comma
l_int|0x00
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Read manufacturer and device IDs */
id|nand_maf_id
op_assign
id|this
op_member_access_from_pointer
id|read_byte
c_func
(paren
id|mtd
)paren
suffix:semicolon
id|nand_dev_id
op_assign
id|this
op_member_access_from_pointer
id|read_byte
c_func
(paren
id|mtd
)paren
suffix:semicolon
multiline_comment|/* Print and store flash device information */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|nand_flash_ids
(braket
id|i
)braket
dot
id|name
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|nand_dev_id
op_ne
id|nand_flash_ids
(braket
id|i
)braket
dot
id|id
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mtd-&gt;name
)paren
id|mtd-&gt;name
op_assign
id|nand_flash_ids
(braket
id|i
)braket
dot
id|name
suffix:semicolon
id|this-&gt;chipsize
op_assign
id|nand_flash_ids
(braket
id|i
)braket
dot
id|chipsize
op_lshift
l_int|20
suffix:semicolon
multiline_comment|/* New devices have all the information in additional id bytes */
r_if
c_cond
(paren
op_logical_neg
id|nand_flash_ids
(braket
id|i
)braket
dot
id|pagesize
)paren
(brace
r_int
id|extid
suffix:semicolon
multiline_comment|/* The 3rd id byte contains non relevant data ATM */
id|extid
op_assign
id|this
op_member_access_from_pointer
id|read_byte
c_func
(paren
id|mtd
)paren
suffix:semicolon
multiline_comment|/* The 4th id byte is the important one */
id|extid
op_assign
id|this
op_member_access_from_pointer
id|read_byte
c_func
(paren
id|mtd
)paren
suffix:semicolon
multiline_comment|/* Calc pagesize */
id|mtd-&gt;oobblock
op_assign
l_int|1024
op_lshift
(paren
id|extid
op_amp
l_int|0x3
)paren
suffix:semicolon
id|extid
op_rshift_assign
l_int|2
suffix:semicolon
multiline_comment|/* Calc oobsize */
id|mtd-&gt;oobsize
op_assign
(paren
l_int|8
op_lshift
(paren
id|extid
op_amp
l_int|0x03
)paren
)paren
op_star
(paren
id|mtd-&gt;oobblock
op_div
l_int|512
)paren
suffix:semicolon
id|extid
op_rshift_assign
l_int|2
suffix:semicolon
multiline_comment|/* Calc blocksize. Blocksize is multiples of 64KiB */
id|mtd-&gt;erasesize
op_assign
(paren
l_int|64
op_star
l_int|1024
)paren
op_lshift
(paren
id|extid
op_amp
l_int|0x03
)paren
suffix:semicolon
id|extid
op_rshift_assign
l_int|2
suffix:semicolon
multiline_comment|/* Get buswidth information */
id|busw
op_assign
(paren
id|extid
op_amp
l_int|0x01
)paren
ques
c_cond
id|NAND_BUSWIDTH_16
suffix:colon
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Old devices have this data hardcoded in the&n;&t;&t;&t; * device id table */
id|mtd-&gt;erasesize
op_assign
id|nand_flash_ids
(braket
id|i
)braket
dot
id|erasesize
suffix:semicolon
id|mtd-&gt;oobblock
op_assign
id|nand_flash_ids
(braket
id|i
)braket
dot
id|pagesize
suffix:semicolon
id|mtd-&gt;oobsize
op_assign
id|mtd-&gt;oobblock
op_div
l_int|32
suffix:semicolon
id|busw
op_assign
id|nand_flash_ids
(braket
id|i
)braket
dot
id|options
op_amp
id|NAND_BUSWIDTH_16
suffix:semicolon
)brace
multiline_comment|/* Check, if buswidth is correct. Hardware drivers should set&n;&t;&t; * this correct ! */
r_if
c_cond
(paren
id|busw
op_ne
(paren
id|this-&gt;options
op_amp
id|NAND_BUSWIDTH_16
)paren
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;NAND device: Manufacturer ID:&quot;
l_string|&quot; 0x%02x, Chip ID: 0x%02x (%s %s)&bslash;n&quot;
comma
id|nand_maf_id
comma
id|nand_dev_id
comma
id|nand_manuf_ids
(braket
id|i
)braket
dot
id|name
comma
id|mtd-&gt;name
)paren
suffix:semicolon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;NAND bus width %d instead %d bit&bslash;n&quot;
comma
(paren
id|this-&gt;options
op_amp
id|NAND_BUSWIDTH_16
)paren
ques
c_cond
l_int|16
suffix:colon
l_int|8
comma
id|busw
ques
c_cond
l_int|16
suffix:colon
l_int|8
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|select_chip
c_func
(paren
id|mtd
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Calculate the address shift from the page size */
id|this-&gt;page_shift
op_assign
id|ffs
c_func
(paren
id|mtd-&gt;oobblock
)paren
op_minus
l_int|1
suffix:semicolon
id|this-&gt;bbt_erase_shift
op_assign
id|this-&gt;phys_erase_shift
op_assign
id|ffs
c_func
(paren
id|mtd-&gt;erasesize
)paren
op_minus
l_int|1
suffix:semicolon
id|this-&gt;chip_shift
op_assign
id|ffs
c_func
(paren
id|this-&gt;chipsize
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Set the bad block position */
id|this-&gt;badblockpos
op_assign
id|mtd-&gt;oobblock
OG
l_int|512
ques
c_cond
id|NAND_LARGE_BADBLOCK_POS
suffix:colon
id|NAND_SMALL_BADBLOCK_POS
suffix:semicolon
multiline_comment|/* Get chip options, preserve non chip based options */
id|this-&gt;options
op_and_assign
op_complement
id|NAND_CHIPOPTIONS_MSK
suffix:semicolon
id|this-&gt;options
op_or_assign
id|nand_flash_ids
(braket
id|i
)braket
dot
id|options
op_amp
id|NAND_CHIPOPTIONS_MSK
suffix:semicolon
multiline_comment|/* Set this as a default. Board drivers can override it, if neccecary */
id|this-&gt;options
op_or_assign
id|NAND_NO_AUTOINCR
suffix:semicolon
multiline_comment|/* Check if this is a not a samsung device. Do not clear the options&n;&t;&t; * for chips which are not having an extended id.&n;&t;&t; */
r_if
c_cond
(paren
id|nand_maf_id
op_ne
id|NAND_MFR_SAMSUNG
op_logical_and
op_logical_neg
id|nand_flash_ids
(braket
id|i
)braket
dot
id|pagesize
)paren
id|this-&gt;options
op_and_assign
op_complement
id|NAND_SAMSUNG_LP_OPTIONS
suffix:semicolon
multiline_comment|/* Check for AND chips with 4 page planes */
r_if
c_cond
(paren
id|this-&gt;options
op_amp
id|NAND_4PAGE_ARRAY
)paren
id|this-&gt;erase_cmd
op_assign
id|multi_erase_cmd
suffix:semicolon
r_else
id|this-&gt;erase_cmd
op_assign
id|single_erase_cmd
suffix:semicolon
multiline_comment|/* Do not replace user supplied command function ! */
r_if
c_cond
(paren
id|mtd-&gt;oobblock
OG
l_int|512
op_logical_and
id|this-&gt;cmdfunc
op_eq
id|nand_command
)paren
id|this-&gt;cmdfunc
op_assign
id|nand_command_lp
suffix:semicolon
multiline_comment|/* Try to identify manufacturer */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|nand_manuf_ids
(braket
id|j
)braket
dot
id|id
op_ne
l_int|0x0
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|nand_manuf_ids
(braket
id|j
)braket
dot
id|id
op_eq
id|nand_maf_id
)paren
r_break
suffix:semicolon
)brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;NAND device: Manufacturer ID:&quot;
l_string|&quot; 0x%02x, Chip ID: 0x%02x (%s %s)&bslash;n&quot;
comma
id|nand_maf_id
comma
id|nand_dev_id
comma
id|nand_manuf_ids
(braket
id|j
)braket
dot
id|name
comma
id|nand_flash_ids
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|nand_flash_ids
(braket
id|i
)braket
dot
id|name
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;No NAND device found!!!&bslash;n&quot;
)paren
suffix:semicolon
id|this
op_member_access_from_pointer
id|select_chip
c_func
(paren
id|mtd
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|maxchips
suffix:semicolon
id|i
op_increment
)paren
(brace
id|this
op_member_access_from_pointer
id|select_chip
c_func
(paren
id|mtd
comma
id|i
)paren
suffix:semicolon
multiline_comment|/* Send the command for reading device ID */
id|this-&gt;cmdfunc
(paren
id|mtd
comma
id|NAND_CMD_READID
comma
l_int|0x00
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Read manufacturer and device IDs */
r_if
c_cond
(paren
id|nand_maf_id
op_ne
id|this
op_member_access_from_pointer
id|read_byte
c_func
(paren
id|mtd
)paren
op_logical_or
id|nand_dev_id
op_ne
id|this
op_member_access_from_pointer
id|read_byte
c_func
(paren
id|mtd
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OG
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%d NAND chips detected&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
multiline_comment|/* Allocate buffers, if neccecary */
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;oob_buf
)paren
(brace
r_int
id|len
suffix:semicolon
id|len
op_assign
id|mtd-&gt;oobsize
op_lshift
(paren
id|this-&gt;phys_erase_shift
op_minus
id|this-&gt;page_shift
)paren
suffix:semicolon
id|this-&gt;oob_buf
op_assign
id|kmalloc
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;oob_buf
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;nand_scan(): Cannot allocate oob_buf&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|this-&gt;options
op_or_assign
id|NAND_OOBBUF_ALLOC
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;data_buf
)paren
(brace
r_int
id|len
suffix:semicolon
id|len
op_assign
id|mtd-&gt;oobblock
op_plus
id|mtd-&gt;oobsize
suffix:semicolon
id|this-&gt;data_buf
op_assign
id|kmalloc
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;data_buf
)paren
(brace
r_if
c_cond
(paren
id|this-&gt;options
op_amp
id|NAND_OOBBUF_ALLOC
)paren
id|kfree
(paren
id|this-&gt;oob_buf
)paren
suffix:semicolon
id|printk
(paren
id|KERN_ERR
l_string|&quot;nand_scan(): Cannot allocate data_buf&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|this-&gt;options
op_or_assign
id|NAND_DATABUF_ALLOC
suffix:semicolon
)brace
multiline_comment|/* Store the number of chips and calc total size for mtd */
id|this-&gt;numchips
op_assign
id|i
suffix:semicolon
id|mtd-&gt;size
op_assign
id|i
op_star
id|this-&gt;chipsize
suffix:semicolon
multiline_comment|/* Convert chipsize to number of pages per chip -1. */
id|this-&gt;pagemask
op_assign
(paren
id|this-&gt;chipsize
op_rshift
id|this-&gt;page_shift
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Preset the internal oob buffer */
id|memset
c_func
(paren
id|this-&gt;oob_buf
comma
l_int|0xff
comma
id|mtd-&gt;oobsize
op_lshift
(paren
id|this-&gt;phys_erase_shift
op_minus
id|this-&gt;page_shift
)paren
)paren
suffix:semicolon
multiline_comment|/* If no default placement scheme is given, select an&n;&t; * appropriate one */
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;autooob
)paren
(brace
multiline_comment|/* Select the appropriate default oob placement scheme for&n;&t;&t; * placement agnostic filesystems */
r_switch
c_cond
(paren
id|mtd-&gt;oobsize
)paren
(brace
r_case
l_int|8
suffix:colon
id|this-&gt;autooob
op_assign
op_amp
id|nand_oob_8
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|16
suffix:colon
id|this-&gt;autooob
op_assign
op_amp
id|nand_oob_16
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|64
suffix:colon
id|this-&gt;autooob
op_assign
op_amp
id|nand_oob_64
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;No oob scheme defined for oobsize %d&bslash;n&quot;
comma
id|mtd-&gt;oobsize
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* The number of bytes available for the filesystem to place fs dependend&n;&t; * oob data */
r_if
c_cond
(paren
id|this-&gt;options
op_amp
id|NAND_BUSWIDTH_16
)paren
(brace
id|mtd-&gt;oobavail
op_assign
id|mtd-&gt;oobsize
op_minus
(paren
id|this-&gt;autooob-&gt;eccbytes
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;autooob-&gt;eccbytes
op_amp
l_int|0x01
)paren
id|mtd-&gt;oobavail
op_decrement
suffix:semicolon
)brace
r_else
id|mtd-&gt;oobavail
op_assign
id|mtd-&gt;oobsize
op_minus
(paren
id|this-&gt;autooob-&gt;eccbytes
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * check ECC mode, default to software&n;&t; * if 3byte/512byte hardware ECC is selected and we have 256 byte pagesize&n;&t; * fallback to software ECC &n;&t;*/
id|this-&gt;eccsize
op_assign
l_int|256
suffix:semicolon
multiline_comment|/* set default eccsize */
id|this-&gt;eccbytes
op_assign
l_int|3
suffix:semicolon
r_switch
c_cond
(paren
id|this-&gt;eccmode
)paren
(brace
r_case
id|NAND_ECC_HW12_2048
suffix:colon
r_if
c_cond
(paren
id|mtd-&gt;oobblock
OL
l_int|2048
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;2048 byte HW ECC not possible on %d byte page size, fallback to SW ECC&bslash;n&quot;
comma
id|mtd-&gt;oobblock
)paren
suffix:semicolon
id|this-&gt;eccmode
op_assign
id|NAND_ECC_SOFT
suffix:semicolon
id|this-&gt;calculate_ecc
op_assign
id|nand_calculate_ecc
suffix:semicolon
id|this-&gt;correct_data
op_assign
id|nand_correct_data
suffix:semicolon
)brace
r_else
id|this-&gt;eccsize
op_assign
l_int|2048
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_ECC_HW3_512
suffix:colon
r_case
id|NAND_ECC_HW6_512
suffix:colon
r_case
id|NAND_ECC_HW8_512
suffix:colon
r_if
c_cond
(paren
id|mtd-&gt;oobblock
op_eq
l_int|256
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;512 byte HW ECC not possible on 256 Byte pagesize, fallback to SW ECC &bslash;n&quot;
)paren
suffix:semicolon
id|this-&gt;eccmode
op_assign
id|NAND_ECC_SOFT
suffix:semicolon
id|this-&gt;calculate_ecc
op_assign
id|nand_calculate_ecc
suffix:semicolon
id|this-&gt;correct_data
op_assign
id|nand_correct_data
suffix:semicolon
)brace
r_else
id|this-&gt;eccsize
op_assign
l_int|512
suffix:semicolon
multiline_comment|/* set eccsize to 512 */
r_break
suffix:semicolon
r_case
id|NAND_ECC_HW3_256
suffix:colon
r_break
suffix:semicolon
r_case
id|NAND_ECC_NONE
suffix:colon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;NAND_ECC_NONE selected by board driver. This is not recommended !!&bslash;n&quot;
)paren
suffix:semicolon
id|this-&gt;eccmode
op_assign
id|NAND_ECC_NONE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_ECC_SOFT
suffix:colon
id|this-&gt;calculate_ecc
op_assign
id|nand_calculate_ecc
suffix:semicolon
id|this-&gt;correct_data
op_assign
id|nand_correct_data
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;Invalid NAND_ECC_MODE %d&bslash;n&quot;
comma
id|this-&gt;eccmode
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Check hardware ecc function availability and adjust number of ecc bytes per &n;&t; * calculation step&n;&t;*/
r_switch
c_cond
(paren
id|this-&gt;eccmode
)paren
(brace
r_case
id|NAND_ECC_HW12_2048
suffix:colon
id|this-&gt;eccbytes
op_add_assign
l_int|4
suffix:semicolon
r_case
id|NAND_ECC_HW8_512
suffix:colon
id|this-&gt;eccbytes
op_add_assign
l_int|2
suffix:semicolon
r_case
id|NAND_ECC_HW6_512
suffix:colon
id|this-&gt;eccbytes
op_add_assign
l_int|3
suffix:semicolon
r_case
id|NAND_ECC_HW3_512
suffix:colon
r_case
id|NAND_ECC_HW3_256
suffix:colon
r_if
c_cond
(paren
id|this-&gt;calculate_ecc
op_logical_and
id|this-&gt;correct_data
op_logical_and
id|this-&gt;enable_hwecc
)paren
r_break
suffix:semicolon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;No ECC functions supplied, Hardware ECC not possible&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|mtd-&gt;eccsize
op_assign
id|this-&gt;eccsize
suffix:semicolon
multiline_comment|/* Set the number of read / write steps for one page to ensure ECC generation */
r_switch
c_cond
(paren
id|this-&gt;eccmode
)paren
(brace
r_case
id|NAND_ECC_HW12_2048
suffix:colon
id|this-&gt;eccsteps
op_assign
id|mtd-&gt;oobblock
op_div
l_int|2048
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_ECC_HW3_512
suffix:colon
r_case
id|NAND_ECC_HW6_512
suffix:colon
r_case
id|NAND_ECC_HW8_512
suffix:colon
id|this-&gt;eccsteps
op_assign
id|mtd-&gt;oobblock
op_div
l_int|512
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_ECC_HW3_256
suffix:colon
r_case
id|NAND_ECC_SOFT
suffix:colon
id|this-&gt;eccsteps
op_assign
id|mtd-&gt;oobblock
op_div
l_int|256
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NAND_ECC_NONE
suffix:colon
id|this-&gt;eccsteps
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Initialize state, waitqueue and spinlock */
id|this-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|init_waitqueue_head
(paren
op_amp
id|this-&gt;wq
)paren
suffix:semicolon
id|spin_lock_init
(paren
op_amp
id|this-&gt;chip_lock
)paren
suffix:semicolon
multiline_comment|/* De-select the device */
id|this
op_member_access_from_pointer
id|select_chip
c_func
(paren
id|mtd
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Invalidate the pagebuffer reference */
id|this-&gt;pagebuf
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Fill in remaining MTD driver data */
id|mtd-&gt;type
op_assign
id|MTD_NANDFLASH
suffix:semicolon
id|mtd-&gt;flags
op_assign
id|MTD_CAP_NANDFLASH
op_or
id|MTD_ECC
suffix:semicolon
id|mtd-&gt;ecctype
op_assign
id|MTD_ECC_SW
suffix:semicolon
id|mtd-&gt;erase
op_assign
id|nand_erase
suffix:semicolon
id|mtd-&gt;point
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;unpoint
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;read
op_assign
id|nand_read
suffix:semicolon
id|mtd-&gt;write
op_assign
id|nand_write
suffix:semicolon
id|mtd-&gt;read_ecc
op_assign
id|nand_read_ecc
suffix:semicolon
id|mtd-&gt;write_ecc
op_assign
id|nand_write_ecc
suffix:semicolon
id|mtd-&gt;read_oob
op_assign
id|nand_read_oob
suffix:semicolon
id|mtd-&gt;write_oob
op_assign
id|nand_write_oob
suffix:semicolon
id|mtd-&gt;readv
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;writev
op_assign
id|nand_writev
suffix:semicolon
id|mtd-&gt;writev_ecc
op_assign
id|nand_writev_ecc
suffix:semicolon
id|mtd-&gt;sync
op_assign
id|nand_sync
suffix:semicolon
id|mtd-&gt;lock
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;unlock
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;suspend
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;resume
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;block_isbad
op_assign
id|nand_block_isbad
suffix:semicolon
id|mtd-&gt;block_markbad
op_assign
id|nand_block_markbad
suffix:semicolon
multiline_comment|/* and make the autooob the default one */
id|memcpy
c_func
(paren
op_amp
id|mtd-&gt;oobinfo
comma
id|this-&gt;autooob
comma
r_sizeof
(paren
id|mtd-&gt;oobinfo
)paren
)paren
suffix:semicolon
id|mtd-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
multiline_comment|/* Build bad block table */
r_return
id|this-&gt;scan_bbt
(paren
id|mtd
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * nand_release - [NAND Interface] Free resources held by the NAND device &n; * @mtd:&t;MTD device structure&n;*/
DECL|function|nand_release
r_void
id|nand_release
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|nand_chip
op_star
id|this
op_assign
id|mtd-&gt;priv
suffix:semicolon
macro_line|#ifdef CONFIG_MTD_PARTITIONS
multiline_comment|/* Deregister partitions */
id|del_mtd_partitions
(paren
id|mtd
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Deregister the device */
id|del_mtd_device
(paren
id|mtd
)paren
suffix:semicolon
multiline_comment|/* Free bad block table memory, if allocated */
r_if
c_cond
(paren
id|this-&gt;bbt
)paren
id|kfree
(paren
id|this-&gt;bbt
)paren
suffix:semicolon
multiline_comment|/* Buffer allocated by nand_scan ? */
r_if
c_cond
(paren
id|this-&gt;options
op_amp
id|NAND_OOBBUF_ALLOC
)paren
id|kfree
(paren
id|this-&gt;oob_buf
)paren
suffix:semicolon
multiline_comment|/* Buffer allocated by nand_scan ? */
r_if
c_cond
(paren
id|this-&gt;options
op_amp
id|NAND_DATABUF_ALLOC
)paren
id|kfree
(paren
id|this-&gt;data_buf
)paren
suffix:semicolon
)brace
DECL|variable|nand_scan
id|EXPORT_SYMBOL
(paren
id|nand_scan
)paren
suffix:semicolon
DECL|variable|nand_release
id|EXPORT_SYMBOL
(paren
id|nand_release
)paren
suffix:semicolon
id|MODULE_LICENSE
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
(paren
l_string|&quot;Steven J. Hill &lt;sjhill@realitydiluted.com&gt;, Thomas Gleixner &lt;tglx@linutronix.de&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
(paren
l_string|&quot;Generic NAND flash driver code&quot;
)paren
suffix:semicolon
eof
