multiline_comment|/* &n; * inftlmount.c -- INFTL mount code with extensive checks.&n; *&n; * Author: Greg Ungerer (gerg@snapgear.com)&n; * (C) Copyright 2002-2003, Greg Ungerer (gerg@snapgear.com)&n; *&n; * Based heavily on the nftlmount.c code which is:&n; * Author: Fabrice Bellard (fabrice.bellard@netgem.com) &n; * Copyright (C) 2000 Netgem S.A.&n; *&n; * $Id: inftlmount.c,v 1.15 2004/11/05 21:55:55 kalev Exp $&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/errno.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/mtd/nftl.h&gt;
macro_line|#include &lt;linux/mtd/inftl.h&gt;
macro_line|#include &lt;linux/mtd/compatmac.h&gt;
DECL|variable|inftlmountrev
r_char
id|inftlmountrev
(braket
)braket
op_assign
l_string|&quot;$Revision: 1.15 $&quot;
suffix:semicolon
multiline_comment|/*&n; * find_boot_record: Find the INFTL Media Header and its Spare copy which&n; *&t;contains the various device information of the INFTL partition and&n; *&t;Bad Unit Table. Update the PUtable[] table according to the Bad&n; *&t;Unit Table. PUtable[] is used for management of Erase Unit in&n; *&t;other routines in inftlcore.c and inftlmount.c.&n; */
DECL|function|find_boot_record
r_static
r_int
id|find_boot_record
c_func
(paren
r_struct
id|INFTLrecord
op_star
id|inftl
)paren
(brace
r_struct
id|inftl_unittail
id|h1
suffix:semicolon
singleline_comment|//struct inftl_oob oob;
r_int
r_int
id|i
comma
id|block
suffix:semicolon
id|u8
id|buf
(braket
id|SECTORSIZE
)braket
suffix:semicolon
r_struct
id|INFTLMediaHeader
op_star
id|mh
op_assign
op_amp
id|inftl-&gt;MediaHdr
suffix:semicolon
r_struct
id|INFTLPartition
op_star
id|ip
suffix:semicolon
r_int
id|retlen
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;INFTL: find_boot_record(inftl=%p)&bslash;n&quot;
comma
id|inftl
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Assume logical EraseSize == physical erasesize for starting the&n;&t; * scan. We&squot;ll sort it out later if we find a MediaHeader which says&n;&t; * otherwise.&n;&t; */
id|inftl-&gt;EraseSize
op_assign
id|inftl-&gt;mbd.mtd-&gt;erasesize
suffix:semicolon
id|inftl-&gt;nb_blocks
op_assign
id|inftl-&gt;mbd.mtd-&gt;size
op_div
id|inftl-&gt;EraseSize
suffix:semicolon
id|inftl-&gt;MediaUnit
op_assign
id|BLOCK_NIL
suffix:semicolon
multiline_comment|/* Search for a valid boot record */
r_for
c_loop
(paren
id|block
op_assign
l_int|0
suffix:semicolon
id|block
OL
id|inftl-&gt;nb_blocks
suffix:semicolon
id|block
op_increment
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check for BNAND header first. Then whinge if it&squot;s found&n;&t;&t; * but later checks fail.&n;&t;&t; */
id|ret
op_assign
id|MTD_READ
c_func
(paren
id|inftl-&gt;mbd.mtd
comma
id|block
op_star
id|inftl-&gt;EraseSize
comma
id|SECTORSIZE
comma
op_amp
id|retlen
comma
id|buf
)paren
suffix:semicolon
multiline_comment|/* We ignore ret in case the ECC of the MediaHeader is invalid&n;&t;&t;   (which is apparently acceptable) */
r_if
c_cond
(paren
id|retlen
op_ne
id|SECTORSIZE
)paren
(brace
r_static
r_int
id|warncount
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|warncount
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: block read at 0x%x &quot;
l_string|&quot;of mtd%d failed: %d&bslash;n&quot;
comma
id|block
op_star
id|inftl-&gt;EraseSize
comma
id|inftl-&gt;mbd.mtd-&gt;index
comma
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|warncount
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: further &quot;
l_string|&quot;failures for this block will &quot;
l_string|&quot;not be printed&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retlen
OL
l_int|6
op_logical_or
id|memcmp
c_func
(paren
id|buf
comma
l_string|&quot;BNAND&quot;
comma
l_int|6
)paren
)paren
(brace
multiline_comment|/* BNAND&bslash;0 not found. Continue */
r_continue
suffix:semicolon
)brace
multiline_comment|/* To be safer with BIOS, also use erase mark as discriminant */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|MTD_READOOB
c_func
(paren
id|inftl-&gt;mbd.mtd
comma
id|block
op_star
id|inftl-&gt;EraseSize
op_plus
id|SECTORSIZE
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|h1
)paren
OL
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: ANAND header found at &quot;
l_string|&quot;0x%x in mtd%d, but OOB data read failed &quot;
l_string|&quot;(err %d)&bslash;n&quot;
comma
id|block
op_star
id|inftl-&gt;EraseSize
comma
id|inftl-&gt;mbd.mtd-&gt;index
comma
id|ret
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * This is the first we&squot;ve seen.&n;&t;&t; * Copy the media header structure into place.&n;&t;&t; */
id|memcpy
c_func
(paren
id|mh
comma
id|buf
comma
r_sizeof
(paren
r_struct
id|INFTLMediaHeader
)paren
)paren
suffix:semicolon
multiline_comment|/* Read the spare media header at offset 4096 */
id|MTD_READ
c_func
(paren
id|inftl-&gt;mbd.mtd
comma
id|block
op_star
id|inftl-&gt;EraseSize
op_plus
l_int|4096
comma
id|SECTORSIZE
comma
op_amp
id|retlen
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retlen
op_ne
id|SECTORSIZE
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: Unable to read spare &quot;
l_string|&quot;Media Header&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Check if this one is the same as the first one we found. */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|mh
comma
id|buf
comma
r_sizeof
(paren
r_struct
id|INFTLMediaHeader
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: Primary and spare Media &quot;
l_string|&quot;Headers disagree.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|mh-&gt;NoOfBootImageBlocks
op_assign
id|le32_to_cpu
c_func
(paren
id|mh-&gt;NoOfBootImageBlocks
)paren
suffix:semicolon
id|mh-&gt;NoOfBinaryPartitions
op_assign
id|le32_to_cpu
c_func
(paren
id|mh-&gt;NoOfBinaryPartitions
)paren
suffix:semicolon
id|mh-&gt;NoOfBDTLPartitions
op_assign
id|le32_to_cpu
c_func
(paren
id|mh-&gt;NoOfBDTLPartitions
)paren
suffix:semicolon
id|mh-&gt;BlockMultiplierBits
op_assign
id|le32_to_cpu
c_func
(paren
id|mh-&gt;BlockMultiplierBits
)paren
suffix:semicolon
id|mh-&gt;FormatFlags
op_assign
id|le32_to_cpu
c_func
(paren
id|mh-&gt;FormatFlags
)paren
suffix:semicolon
id|mh-&gt;PercentUsed
op_assign
id|le32_to_cpu
c_func
(paren
id|mh-&gt;PercentUsed
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MTD_DEBUG_VERBOSE
r_if
c_cond
(paren
id|CONFIG_MTD_DEBUG_VERBOSE
op_ge
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;INFTL: Media Header -&gt;&bslash;n&quot;
l_string|&quot;    bootRecordID          = %s&bslash;n&quot;
l_string|&quot;    NoOfBootImageBlocks   = %d&bslash;n&quot;
l_string|&quot;    NoOfBinaryPartitions  = %d&bslash;n&quot;
l_string|&quot;    NoOfBDTLPartitions    = %d&bslash;n&quot;
l_string|&quot;    BlockMultiplerBits    = %d&bslash;n&quot;
l_string|&quot;    FormatFlgs            = %d&bslash;n&quot;
l_string|&quot;    OsakVersion           = 0x%x&bslash;n&quot;
l_string|&quot;    PercentUsed           = %d&bslash;n&quot;
comma
id|mh-&gt;bootRecordID
comma
id|mh-&gt;NoOfBootImageBlocks
comma
id|mh-&gt;NoOfBinaryPartitions
comma
id|mh-&gt;NoOfBDTLPartitions
comma
id|mh-&gt;BlockMultiplierBits
comma
id|mh-&gt;FormatFlags
comma
id|mh-&gt;OsakVersion
comma
id|mh-&gt;PercentUsed
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|mh-&gt;NoOfBDTLPartitions
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: Media Header sanity check &quot;
l_string|&quot;failed: NoOfBDTLPartitions (%d) == 0, &quot;
l_string|&quot;must be at least 1&bslash;n&quot;
comma
id|mh-&gt;NoOfBDTLPartitions
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|mh-&gt;NoOfBDTLPartitions
op_plus
id|mh-&gt;NoOfBinaryPartitions
)paren
OG
l_int|4
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: Media Header sanity check &quot;
l_string|&quot;failed: Total Partitions (%d) &gt; 4, &quot;
l_string|&quot;BDTL=%d Binary=%d&bslash;n&quot;
comma
id|mh-&gt;NoOfBDTLPartitions
op_plus
id|mh-&gt;NoOfBinaryPartitions
comma
id|mh-&gt;NoOfBDTLPartitions
comma
id|mh-&gt;NoOfBinaryPartitions
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mh-&gt;BlockMultiplierBits
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: sorry, we don&squot;t support &quot;
l_string|&quot;UnitSizeFactor 0x%02x&bslash;n&quot;
comma
id|mh-&gt;BlockMultiplierBits
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mh-&gt;BlockMultiplierBits
op_eq
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: support for INFTL with &quot;
l_string|&quot;UnitSizeFactor 0x%02x is experimental&bslash;n&quot;
comma
id|mh-&gt;BlockMultiplierBits
)paren
suffix:semicolon
id|inftl-&gt;EraseSize
op_assign
id|inftl-&gt;mbd.mtd-&gt;erasesize
op_lshift
id|mh-&gt;BlockMultiplierBits
suffix:semicolon
id|inftl-&gt;nb_blocks
op_assign
id|inftl-&gt;mbd.mtd-&gt;size
op_div
id|inftl-&gt;EraseSize
suffix:semicolon
id|block
op_rshift_assign
id|mh-&gt;BlockMultiplierBits
suffix:semicolon
)brace
multiline_comment|/* Scan the partitions */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
l_int|4
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ip
op_assign
op_amp
id|mh-&gt;Partitions
(braket
id|i
)braket
suffix:semicolon
id|ip-&gt;virtualUnits
op_assign
id|le32_to_cpu
c_func
(paren
id|ip-&gt;virtualUnits
)paren
suffix:semicolon
id|ip-&gt;firstUnit
op_assign
id|le32_to_cpu
c_func
(paren
id|ip-&gt;firstUnit
)paren
suffix:semicolon
id|ip-&gt;lastUnit
op_assign
id|le32_to_cpu
c_func
(paren
id|ip-&gt;lastUnit
)paren
suffix:semicolon
id|ip-&gt;flags
op_assign
id|le32_to_cpu
c_func
(paren
id|ip-&gt;flags
)paren
suffix:semicolon
id|ip-&gt;spareUnits
op_assign
id|le32_to_cpu
c_func
(paren
id|ip-&gt;spareUnits
)paren
suffix:semicolon
id|ip-&gt;Reserved0
op_assign
id|le32_to_cpu
c_func
(paren
id|ip-&gt;Reserved0
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MTD_DEBUG_VERBOSE
r_if
c_cond
(paren
id|CONFIG_MTD_DEBUG_VERBOSE
op_ge
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;    PARTITION[%d] -&gt;&bslash;n&quot;
l_string|&quot;        virtualUnits    = %d&bslash;n&quot;
l_string|&quot;        firstUnit       = %d&bslash;n&quot;
l_string|&quot;        lastUnit        = %d&bslash;n&quot;
l_string|&quot;        flags           = 0x%x&bslash;n&quot;
l_string|&quot;        spareUnits      = %d&bslash;n&quot;
comma
id|i
comma
id|ip-&gt;virtualUnits
comma
id|ip-&gt;firstUnit
comma
id|ip-&gt;lastUnit
comma
id|ip-&gt;flags
comma
id|ip-&gt;spareUnits
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|ip-&gt;Reserved0
op_ne
id|ip-&gt;firstUnit
)paren
(brace
r_struct
id|erase_info
op_star
id|instr
op_assign
op_amp
id|inftl-&gt;instr
suffix:semicolon
id|instr-&gt;mtd
op_assign
id|inftl-&gt;mbd.mtd
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * &t;Most likely this is using the&n;&t;&t;&t;&t; * &t;undocumented qiuck mount feature.&n;&t;&t;&t;&t; * &t;We don&squot;t support that, we will need&n;&t;&t;&t;&t; * &t;to erase the hidden block for full&n;&t;&t;&t;&t; * &t;compatibility.&n;&t;&t;&t;&t; */
id|instr-&gt;addr
op_assign
id|ip-&gt;Reserved0
op_star
id|inftl-&gt;EraseSize
suffix:semicolon
id|instr-&gt;len
op_assign
id|inftl-&gt;EraseSize
suffix:semicolon
id|MTD_ERASE
c_func
(paren
id|inftl-&gt;mbd.mtd
comma
id|instr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ip-&gt;lastUnit
op_minus
id|ip-&gt;firstUnit
op_plus
l_int|1
)paren
OL
id|ip-&gt;virtualUnits
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: Media Header &quot;
l_string|&quot;Partition %d sanity check failed&bslash;n&quot;
l_string|&quot;    firstUnit %d : lastUnit %d  &gt;  &quot;
l_string|&quot;virtualUnits %d&bslash;n&quot;
comma
id|i
comma
id|ip-&gt;lastUnit
comma
id|ip-&gt;firstUnit
comma
id|ip-&gt;Reserved0
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip-&gt;Reserved1
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: Media Header &quot;
l_string|&quot;Partition %d sanity check failed: &quot;
l_string|&quot;Reserved1 %d != 0&bslash;n&quot;
comma
id|i
comma
id|ip-&gt;Reserved1
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip-&gt;flags
op_amp
id|INFTL_BDTL
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ge
l_int|4
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: Media Header Partition &quot;
l_string|&quot;sanity check failed:&bslash;n       No partition &quot;
l_string|&quot;marked as Disk Partition&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|inftl-&gt;nb_boot_blocks
op_assign
id|ip-&gt;firstUnit
suffix:semicolon
id|inftl-&gt;numvunits
op_assign
id|ip-&gt;virtualUnits
suffix:semicolon
r_if
c_cond
(paren
id|inftl-&gt;numvunits
OG
(paren
id|inftl-&gt;nb_blocks
op_minus
id|inftl-&gt;nb_boot_blocks
op_minus
l_int|2
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: Media Header sanity check &quot;
l_string|&quot;failed:&bslash;n        numvunits (%d) &gt; nb_blocks &quot;
l_string|&quot;(%d) - nb_boot_blocks(%d) - 2&bslash;n&quot;
comma
id|inftl-&gt;numvunits
comma
id|inftl-&gt;nb_blocks
comma
id|inftl-&gt;nb_boot_blocks
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|inftl-&gt;mbd.size
op_assign
id|inftl-&gt;numvunits
op_star
(paren
id|inftl-&gt;EraseSize
op_div
id|SECTORSIZE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Block count is set to last used EUN (we won&squot;t need to keep&n;&t;&t; * any meta-data past that point).&n;&t;&t; */
id|inftl-&gt;firstEUN
op_assign
id|ip-&gt;firstUnit
suffix:semicolon
id|inftl-&gt;lastEUN
op_assign
id|ip-&gt;lastUnit
suffix:semicolon
id|inftl-&gt;nb_blocks
op_assign
id|ip-&gt;lastUnit
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Memory alloc */
id|inftl-&gt;PUtable
op_assign
id|kmalloc
c_func
(paren
id|inftl-&gt;nb_blocks
op_star
r_sizeof
(paren
id|u16
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inftl-&gt;PUtable
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: allocation of PUtable &quot;
l_string|&quot;failed (%zd bytes)&bslash;n&quot;
comma
id|inftl-&gt;nb_blocks
op_star
r_sizeof
(paren
id|u16
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|inftl-&gt;VUtable
op_assign
id|kmalloc
c_func
(paren
id|inftl-&gt;nb_blocks
op_star
r_sizeof
(paren
id|u16
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inftl-&gt;VUtable
)paren
(brace
id|kfree
c_func
(paren
id|inftl-&gt;PUtable
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: allocation of VUtable &quot;
l_string|&quot;failed (%zd bytes)&bslash;n&quot;
comma
id|inftl-&gt;nb_blocks
op_star
r_sizeof
(paren
id|u16
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Mark the blocks before INFTL MediaHeader as reserved */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|inftl-&gt;nb_boot_blocks
suffix:semicolon
id|i
op_increment
)paren
id|inftl-&gt;PUtable
(braket
id|i
)braket
op_assign
id|BLOCK_RESERVED
suffix:semicolon
multiline_comment|/* Mark all remaining blocks as potentially containing data */
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|inftl-&gt;nb_blocks
suffix:semicolon
id|i
op_increment
)paren
id|inftl-&gt;PUtable
(braket
id|i
)braket
op_assign
id|BLOCK_NOTEXPLORED
suffix:semicolon
multiline_comment|/* Mark this boot record (NFTL MediaHeader) block as reserved */
id|inftl-&gt;PUtable
(braket
id|block
)braket
op_assign
id|BLOCK_RESERVED
suffix:semicolon
multiline_comment|/* Read Bad Erase Unit Table and modify PUtable[] accordingly */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|inftl-&gt;nb_blocks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|physblock
suffix:semicolon
multiline_comment|/* If any of the physical eraseblocks are bad, don&squot;t&n;&t;&t;&t;   use the unit. */
r_for
c_loop
(paren
id|physblock
op_assign
l_int|0
suffix:semicolon
id|physblock
OL
id|inftl-&gt;EraseSize
suffix:semicolon
id|physblock
op_add_assign
id|inftl-&gt;mbd.mtd-&gt;erasesize
)paren
(brace
r_if
c_cond
(paren
id|inftl-&gt;mbd.mtd
op_member_access_from_pointer
id|block_isbad
c_func
(paren
id|inftl-&gt;mbd.mtd
comma
id|i
op_star
id|inftl-&gt;EraseSize
op_plus
id|physblock
)paren
)paren
id|inftl-&gt;PUtable
(braket
id|i
)braket
op_assign
id|BLOCK_RESERVED
suffix:semicolon
)brace
)brace
id|inftl-&gt;MediaUnit
op_assign
id|block
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Not found. */
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|memcmpb
r_static
r_int
id|memcmpb
c_func
(paren
r_void
op_star
id|a
comma
r_int
id|c
comma
r_int
id|n
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|c
op_ne
(paren
(paren
r_int
r_char
op_star
)paren
id|a
)paren
(braket
id|i
)braket
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * check_free_sector: check if a free sector is actually FREE,&n; *&t;i.e. All 0xff in data and oob area.&n; */
DECL|function|check_free_sectors
r_static
r_int
id|check_free_sectors
c_func
(paren
r_struct
id|INFTLrecord
op_star
id|inftl
comma
r_int
r_int
id|address
comma
r_int
id|len
comma
r_int
id|check_oob
)paren
(brace
id|u8
id|buf
(braket
id|SECTORSIZE
op_plus
id|inftl-&gt;mbd.mtd-&gt;oobsize
)braket
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;INFTL: check_free_sectors(inftl=%p,&quot;
l_string|&quot;address=0x%x,len=%d,check_oob=%d)&bslash;n&quot;
comma
id|inftl
comma
id|address
comma
id|len
comma
id|check_oob
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_add_assign
id|SECTORSIZE
)paren
(brace
r_if
c_cond
(paren
id|MTD_READECC
c_func
(paren
id|inftl-&gt;mbd.mtd
comma
id|address
comma
id|SECTORSIZE
comma
op_amp
id|retlen
comma
id|buf
comma
op_amp
id|buf
(braket
id|SECTORSIZE
)braket
comma
op_amp
id|inftl-&gt;oobinfo
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|memcmpb
c_func
(paren
id|buf
comma
l_int|0xff
comma
id|SECTORSIZE
)paren
op_ne
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|check_oob
)paren
(brace
r_if
c_cond
(paren
id|memcmpb
c_func
(paren
id|buf
op_plus
id|SECTORSIZE
comma
l_int|0xff
comma
id|inftl-&gt;mbd.mtd-&gt;oobsize
)paren
op_ne
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|address
op_add_assign
id|SECTORSIZE
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * INFTL_format: format a Erase Unit by erasing ALL Erase Zones in the Erase&n; *&t;&t; Unit and Update INFTL metadata. Each erase operation is&n; *&t;&t; checked with check_free_sectors.&n; *&n; * Return: 0 when succeed, -1 on error.&n; *&n; * ToDo: 1. Is it neceressary to check_free_sector after erasing ?? &n; */
DECL|function|INFTL_formatblock
r_int
id|INFTL_formatblock
c_func
(paren
r_struct
id|INFTLrecord
op_star
id|inftl
comma
r_int
id|block
)paren
(brace
r_int
id|retlen
suffix:semicolon
r_struct
id|inftl_unittail
id|uci
suffix:semicolon
r_struct
id|erase_info
op_star
id|instr
op_assign
op_amp
id|inftl-&gt;instr
suffix:semicolon
r_int
id|physblock
suffix:semicolon
id|instr-&gt;mtd
op_assign
id|inftl-&gt;mbd.mtd
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;INFTL: INFTL_formatblock(inftl=%p,&quot;
l_string|&quot;block=%d)&bslash;n&quot;
comma
id|inftl
comma
id|block
)paren
suffix:semicolon
id|memset
c_func
(paren
id|instr
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|erase_info
)paren
)paren
suffix:semicolon
multiline_comment|/* FIXME: Shouldn&squot;t we be setting the &squot;discarded&squot; flag to zero&n;&t;   _first_? */
multiline_comment|/* Use async erase interface, test return code */
id|instr-&gt;addr
op_assign
id|block
op_star
id|inftl-&gt;EraseSize
suffix:semicolon
id|instr-&gt;len
op_assign
id|inftl-&gt;mbd.mtd-&gt;erasesize
suffix:semicolon
multiline_comment|/* Erase one physical eraseblock at a time, even though the NAND api&n;&t;   allows us to group them.  This way we if we have a failure, we can&n;&t;   mark only the failed block in the bbt. */
r_for
c_loop
(paren
id|physblock
op_assign
l_int|0
suffix:semicolon
id|physblock
OL
id|inftl-&gt;EraseSize
suffix:semicolon
id|physblock
op_add_assign
id|instr-&gt;len
comma
id|instr-&gt;addr
op_add_assign
id|instr-&gt;len
)paren
(brace
id|MTD_ERASE
c_func
(paren
id|inftl-&gt;mbd.mtd
comma
id|instr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|instr-&gt;state
op_eq
id|MTD_ERASE_FAILED
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: error while formatting block %d&bslash;n&quot;
comma
id|block
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
multiline_comment|/*&n;&t; &t;* Check the &quot;freeness&quot; of Erase Unit before updating metadata.&n;&t; &t;* FixMe: is this check really necessary? Since we have check the&n;&t; &t;*        return code after the erase operation.&n;&t; &t;*/
r_if
c_cond
(paren
id|check_free_sectors
c_func
(paren
id|inftl
comma
id|instr-&gt;addr
comma
id|instr-&gt;len
comma
l_int|1
)paren
op_ne
l_int|0
)paren
r_goto
id|fail
suffix:semicolon
)brace
id|uci.EraseMark
op_assign
id|cpu_to_le16
c_func
(paren
id|ERASE_MARK
)paren
suffix:semicolon
id|uci.EraseMark1
op_assign
id|cpu_to_le16
c_func
(paren
id|ERASE_MARK
)paren
suffix:semicolon
id|uci.Reserved
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|uci.Reserved
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|uci.Reserved
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|uci.Reserved
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|instr-&gt;addr
op_assign
id|block
op_star
id|inftl-&gt;EraseSize
op_plus
id|SECTORSIZE
op_star
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|MTD_WRITEOOB
c_func
(paren
id|inftl-&gt;mbd.mtd
comma
id|instr-&gt;addr
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|uci
)paren
OL
l_int|0
)paren
r_goto
id|fail
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail
suffix:colon
multiline_comment|/* could not format, update the bad block table (caller is responsible&n;&t;   for setting the PUtable to BLOCK_RESERVED on failure) */
id|inftl-&gt;mbd.mtd
op_member_access_from_pointer
id|block_markbad
c_func
(paren
id|inftl-&gt;mbd.mtd
comma
id|instr-&gt;addr
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * format_chain: Format an invalid Virtual Unit chain. It frees all the Erase&n; *&t;Units in a Virtual Unit Chain, i.e. all the units are disconnected.&n; *&n; *&t;Since the chain is invalid then we will have to erase it from its&n; *&t;head (normally for INFTL we go from the oldest). But if it has a&n; *&t;loop then there is no oldest...&n; */
DECL|function|format_chain
r_static
r_void
id|format_chain
c_func
(paren
r_struct
id|INFTLrecord
op_star
id|inftl
comma
r_int
r_int
id|first_block
)paren
(brace
r_int
r_int
id|block
op_assign
id|first_block
comma
id|block1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: formatting chain at block %d&bslash;n&quot;
comma
id|first_block
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|block1
op_assign
id|inftl-&gt;PUtable
(braket
id|block
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: formatting block %d&bslash;n&quot;
comma
id|block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INFTL_formatblock
c_func
(paren
id|inftl
comma
id|block
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Cannot format !!!! Mark it as Bad Unit,&n;&t;&t;&t; */
id|inftl-&gt;PUtable
(braket
id|block
)braket
op_assign
id|BLOCK_RESERVED
suffix:semicolon
)brace
r_else
(brace
id|inftl-&gt;PUtable
(braket
id|block
)braket
op_assign
id|BLOCK_FREE
suffix:semicolon
)brace
multiline_comment|/* Goto next block on the chain */
id|block
op_assign
id|block1
suffix:semicolon
r_if
c_cond
(paren
id|block
op_eq
id|BLOCK_NIL
op_logical_or
id|block
op_ge
id|inftl-&gt;lastEUN
)paren
r_break
suffix:semicolon
)brace
)brace
DECL|function|INFTL_dumptables
r_void
id|INFTL_dumptables
c_func
(paren
r_struct
id|INFTLrecord
op_star
id|s
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;-------------------------------------------&quot;
l_string|&quot;----------------------------------&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;VUtable[%d] -&gt;&quot;
comma
id|s-&gt;nb_blocks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|s-&gt;nb_blocks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|8
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n%04x: &quot;
comma
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%04x &quot;
comma
id|s-&gt;VUtable
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n-------------------------------------------&quot;
l_string|&quot;----------------------------------&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PUtable[%d-%d=%d] -&gt;&quot;
comma
id|s-&gt;firstEUN
comma
id|s-&gt;lastEUN
comma
id|s-&gt;nb_blocks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|s-&gt;lastEUN
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|8
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n%04x: &quot;
comma
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%04x &quot;
comma
id|s-&gt;PUtable
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n-------------------------------------------&quot;
l_string|&quot;----------------------------------&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;INFTL -&gt;&bslash;n&quot;
l_string|&quot;  EraseSize       = %d&bslash;n&quot;
l_string|&quot;  h/s/c           = %d/%d/%d&bslash;n&quot;
l_string|&quot;  numvunits       = %d&bslash;n&quot;
l_string|&quot;  firstEUN        = %d&bslash;n&quot;
l_string|&quot;  lastEUN         = %d&bslash;n&quot;
l_string|&quot;  numfreeEUNs     = %d&bslash;n&quot;
l_string|&quot;  LastFreeEUN     = %d&bslash;n&quot;
l_string|&quot;  nb_blocks       = %d&bslash;n&quot;
l_string|&quot;  nb_boot_blocks  = %d&quot;
comma
id|s-&gt;EraseSize
comma
id|s-&gt;heads
comma
id|s-&gt;sectors
comma
id|s-&gt;cylinders
comma
id|s-&gt;numvunits
comma
id|s-&gt;firstEUN
comma
id|s-&gt;lastEUN
comma
id|s-&gt;numfreeEUNs
comma
id|s-&gt;LastFreeEUN
comma
id|s-&gt;nb_blocks
comma
id|s-&gt;nb_boot_blocks
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n-------------------------------------------&quot;
l_string|&quot;----------------------------------&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|INFTL_dumpVUchains
r_void
id|INFTL_dumpVUchains
c_func
(paren
r_struct
id|INFTLrecord
op_star
id|s
)paren
(brace
r_int
id|logical
comma
id|block
comma
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;-------------------------------------------&quot;
l_string|&quot;----------------------------------&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;INFTL Virtual Unit Chains:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|logical
op_assign
l_int|0
suffix:semicolon
id|logical
OL
id|s-&gt;nb_blocks
suffix:semicolon
id|logical
op_increment
)paren
(brace
id|block
op_assign
id|s-&gt;VUtable
(braket
id|logical
)braket
suffix:semicolon
r_if
c_cond
(paren
id|block
OG
id|s-&gt;nb_blocks
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  LOGICAL %d --&gt; %d &quot;
comma
id|logical
comma
id|block
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|s-&gt;nb_blocks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;PUtable
(braket
id|block
)braket
op_eq
id|BLOCK_NIL
)paren
r_break
suffix:semicolon
id|block
op_assign
id|s-&gt;PUtable
(braket
id|block
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d &quot;
comma
id|block
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;-------------------------------------------&quot;
l_string|&quot;----------------------------------&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|INFTL_mount
r_int
id|INFTL_mount
c_func
(paren
r_struct
id|INFTLrecord
op_star
id|s
)paren
(brace
r_int
r_int
id|block
comma
id|first_block
comma
id|prev_block
comma
id|last_block
suffix:semicolon
r_int
r_int
id|first_logical_block
comma
id|logical_block
comma
id|erase_mark
suffix:semicolon
r_int
id|chain_length
comma
id|do_format_chain
suffix:semicolon
r_struct
id|inftl_unithead1
id|h0
suffix:semicolon
r_struct
id|inftl_unittail
id|h1
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u8
op_star
id|ANACtable
comma
id|ANAC
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;INFTL: INFTL_mount(inftl=%p)&bslash;n&quot;
comma
id|s
)paren
suffix:semicolon
multiline_comment|/* Search for INFTL MediaHeader and Spare INFTL Media Header */
r_if
c_cond
(paren
id|find_boot_record
c_func
(paren
id|s
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: could not find valid boot record?&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Init the logical to physical table */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|s-&gt;nb_blocks
suffix:semicolon
id|i
op_increment
)paren
id|s-&gt;VUtable
(braket
id|i
)braket
op_assign
id|BLOCK_NIL
suffix:semicolon
id|logical_block
op_assign
id|block
op_assign
id|BLOCK_NIL
suffix:semicolon
multiline_comment|/* Temporary buffer to store ANAC numbers. */
id|ANACtable
op_assign
id|kmalloc
c_func
(paren
id|s-&gt;nb_blocks
op_star
r_sizeof
(paren
id|u8
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ANACtable
comma
l_int|0
comma
id|s-&gt;nb_blocks
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * First pass is to explore each physical unit, and construct the&n;&t; * virtual chains that exist (newest physical unit goes into VUtable).&n;&t; * Any block that is in any way invalid will be left in the&n;&t; * NOTEXPLORED state. Then at the end we will try to format it and&n;&t; * mark it as free.&n;&t; */
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;INFTL: pass 1, explore each unit&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|first_block
op_assign
id|s-&gt;firstEUN
suffix:semicolon
id|first_block
op_le
id|s-&gt;lastEUN
suffix:semicolon
id|first_block
op_increment
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;PUtable
(braket
id|first_block
)braket
op_ne
id|BLOCK_NOTEXPLORED
)paren
r_continue
suffix:semicolon
id|do_format_chain
op_assign
l_int|0
suffix:semicolon
id|first_logical_block
op_assign
id|BLOCK_NIL
suffix:semicolon
id|last_block
op_assign
id|BLOCK_NIL
suffix:semicolon
id|block
op_assign
id|first_block
suffix:semicolon
r_for
c_loop
(paren
id|chain_length
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
id|chain_length
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|chain_length
op_eq
l_int|0
)paren
op_logical_and
(paren
id|s-&gt;PUtable
(braket
id|block
)braket
op_ne
id|BLOCK_NOTEXPLORED
)paren
)paren
(brace
multiline_comment|/* Nothing to do here, onto next block */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|MTD_READOOB
c_func
(paren
id|s-&gt;mbd.mtd
comma
id|block
op_star
id|s-&gt;EraseSize
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|h0
)paren
OL
l_int|0
op_logical_or
id|MTD_READOOB
c_func
(paren
id|s-&gt;mbd.mtd
comma
id|block
op_star
id|s-&gt;EraseSize
op_plus
l_int|2
op_star
id|SECTORSIZE
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|h1
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* Should never happen? */
id|do_format_chain
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
id|logical_block
op_assign
id|le16_to_cpu
c_func
(paren
id|h0.virtualUnitNo
)paren
suffix:semicolon
id|prev_block
op_assign
id|le16_to_cpu
c_func
(paren
id|h0.prevUnitNo
)paren
suffix:semicolon
id|erase_mark
op_assign
id|le16_to_cpu
c_func
(paren
(paren
id|h1.EraseMark
op_or
id|h1.EraseMark1
)paren
)paren
suffix:semicolon
id|ANACtable
(braket
id|block
)braket
op_assign
id|h0.ANAC
suffix:semicolon
multiline_comment|/* Previous block is relative to start of Partition */
r_if
c_cond
(paren
id|prev_block
OL
id|s-&gt;nb_blocks
)paren
id|prev_block
op_add_assign
id|s-&gt;firstEUN
suffix:semicolon
multiline_comment|/* Already explored partial chain? */
r_if
c_cond
(paren
id|s-&gt;PUtable
(braket
id|block
)braket
op_ne
id|BLOCK_NOTEXPLORED
)paren
(brace
multiline_comment|/* Check if chain for this logical */
r_if
c_cond
(paren
id|logical_block
op_eq
id|first_logical_block
)paren
(brace
r_if
c_cond
(paren
id|last_block
op_ne
id|BLOCK_NIL
)paren
id|s-&gt;PUtable
(braket
id|last_block
)braket
op_assign
id|block
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* Check for invalid block */
r_if
c_cond
(paren
id|erase_mark
op_ne
id|ERASE_MARK
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: corrupt block %d &quot;
l_string|&quot;in chain %d, chain length %d, erase &quot;
l_string|&quot;mark 0x%x?&bslash;n&quot;
comma
id|block
comma
id|first_block
comma
id|chain_length
comma
id|erase_mark
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Assume end of chain, probably incomplete&n;&t;&t;&t;&t; * fold/erase...&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|chain_length
op_eq
l_int|0
)paren
id|do_format_chain
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Check for it being free already then... */
r_if
c_cond
(paren
(paren
id|logical_block
op_eq
id|BLOCK_FREE
)paren
op_logical_or
(paren
id|logical_block
op_eq
id|BLOCK_NIL
)paren
)paren
(brace
id|s-&gt;PUtable
(braket
id|block
)braket
op_assign
id|BLOCK_FREE
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Sanity checks on block numbers */
r_if
c_cond
(paren
(paren
id|logical_block
op_ge
id|s-&gt;nb_blocks
)paren
op_logical_or
(paren
(paren
id|prev_block
op_ge
id|s-&gt;nb_blocks
)paren
op_logical_and
(paren
id|prev_block
op_ne
id|BLOCK_NIL
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|chain_length
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: corrupt &quot;
l_string|&quot;block %d in chain %d?&bslash;n&quot;
comma
id|block
comma
id|first_block
)paren
suffix:semicolon
id|do_format_chain
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|first_logical_block
op_eq
id|BLOCK_NIL
)paren
(brace
id|first_logical_block
op_assign
id|logical_block
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|first_logical_block
op_ne
id|logical_block
)paren
(brace
multiline_comment|/* Normal for folded chain... */
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * Current block is valid, so if we followed a virtual&n;&t;&t;&t; * chain to get here then we can set the previous&n;&t;&t;&t; * block pointer in our PUtable now. Then move onto&n;&t;&t;&t; * the previous block in the chain.&n;&t;&t;&t; */
id|s-&gt;PUtable
(braket
id|block
)braket
op_assign
id|BLOCK_NIL
suffix:semicolon
r_if
c_cond
(paren
id|last_block
op_ne
id|BLOCK_NIL
)paren
id|s-&gt;PUtable
(braket
id|last_block
)braket
op_assign
id|block
suffix:semicolon
id|last_block
op_assign
id|block
suffix:semicolon
id|block
op_assign
id|prev_block
suffix:semicolon
multiline_comment|/* Check for end of chain */
r_if
c_cond
(paren
id|block
op_eq
id|BLOCK_NIL
)paren
r_break
suffix:semicolon
multiline_comment|/* Validate next block before following it... */
r_if
c_cond
(paren
id|block
OG
id|s-&gt;lastEUN
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: invalid previous &quot;
l_string|&quot;block %d in chain %d?&bslash;n&quot;
comma
id|block
comma
id|first_block
)paren
suffix:semicolon
id|do_format_chain
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|do_format_chain
)paren
(brace
id|format_chain
c_func
(paren
id|s
comma
id|first_block
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Looks like a valid chain then. It may not really be the&n;&t;&t; * newest block in the chain, but it is the newest we have&n;&t;&t; * found so far. We might update it in later iterations of&n;&t;&t; * this loop if we find something newer.&n;&t;&t; */
id|s-&gt;VUtable
(braket
id|first_logical_block
)braket
op_assign
id|first_block
suffix:semicolon
id|logical_block
op_assign
id|BLOCK_NIL
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MTD_DEBUG_VERBOSE
r_if
c_cond
(paren
id|CONFIG_MTD_DEBUG_VERBOSE
op_ge
l_int|2
)paren
id|INFTL_dumptables
c_func
(paren
id|s
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Second pass, check for infinite loops in chains. These are&n;&t; * possible because we don&squot;t update the previous pointers when&n;&t; * we fold chains. No big deal, just fix them up in PUtable.&n;&t; */
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;INFTL: pass 2, validate virtual chains&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|logical_block
op_assign
l_int|0
suffix:semicolon
id|logical_block
OL
id|s-&gt;numvunits
suffix:semicolon
id|logical_block
op_increment
)paren
(brace
id|block
op_assign
id|s-&gt;VUtable
(braket
id|logical_block
)braket
suffix:semicolon
id|last_block
op_assign
id|BLOCK_NIL
suffix:semicolon
multiline_comment|/* Check for free/reserved/nil */
r_if
c_cond
(paren
id|block
op_ge
id|BLOCK_RESERVED
)paren
r_continue
suffix:semicolon
id|ANAC
op_assign
id|ANACtable
(braket
id|block
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|s-&gt;numvunits
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;PUtable
(braket
id|block
)braket
op_eq
id|BLOCK_NIL
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;PUtable
(braket
id|block
)braket
OG
id|s-&gt;lastEUN
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: invalid prev %d, &quot;
l_string|&quot;in virtual chain %d&bslash;n&quot;
comma
id|s-&gt;PUtable
(braket
id|block
)braket
comma
id|logical_block
)paren
suffix:semicolon
id|s-&gt;PUtable
(braket
id|block
)braket
op_assign
id|BLOCK_NIL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ANACtable
(braket
id|block
)braket
op_ne
id|ANAC
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Chain must point back to itself. This is ok,&n;&t;&t;&t;&t; * but we will need adjust the tables with this&n;&t;&t;&t;&t; * newest block and oldest block.&n;&t;&t;&t;&t; */
id|s-&gt;VUtable
(braket
id|logical_block
)braket
op_assign
id|block
suffix:semicolon
id|s-&gt;PUtable
(braket
id|last_block
)braket
op_assign
id|BLOCK_NIL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ANAC
op_decrement
suffix:semicolon
id|last_block
op_assign
id|block
suffix:semicolon
id|block
op_assign
id|s-&gt;PUtable
(braket
id|block
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ge
id|s-&gt;nb_blocks
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Uhoo, infinite chain with valid ANACS!&n;&t;&t;&t; * Format whole chain...&n;&t;&t;&t; */
id|format_chain
c_func
(paren
id|s
comma
id|first_block
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_MTD_DEBUG_VERBOSE
r_if
c_cond
(paren
id|CONFIG_MTD_DEBUG_VERBOSE
op_ge
l_int|2
)paren
id|INFTL_dumptables
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CONFIG_MTD_DEBUG_VERBOSE
op_ge
l_int|2
)paren
id|INFTL_dumpVUchains
c_func
(paren
id|s
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Third pass, format unreferenced blocks and init free block count.&n;&t; */
id|s-&gt;numfreeEUNs
op_assign
l_int|0
suffix:semicolon
id|s-&gt;LastFreeEUN
op_assign
id|BLOCK_NIL
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;INFTL: pass 3, format unused blocks&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|block
op_assign
id|s-&gt;firstEUN
suffix:semicolon
id|block
op_le
id|s-&gt;lastEUN
suffix:semicolon
id|block
op_increment
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;PUtable
(braket
id|block
)braket
op_eq
id|BLOCK_NOTEXPLORED
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;INFTL: unreferenced block %d, formatting it&bslash;n&quot;
comma
id|block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INFTL_formatblock
c_func
(paren
id|s
comma
id|block
)paren
OL
l_int|0
)paren
id|s-&gt;PUtable
(braket
id|block
)braket
op_assign
id|BLOCK_RESERVED
suffix:semicolon
r_else
id|s-&gt;PUtable
(braket
id|block
)braket
op_assign
id|BLOCK_FREE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;PUtable
(braket
id|block
)braket
op_eq
id|BLOCK_FREE
)paren
(brace
id|s-&gt;numfreeEUNs
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;LastFreeEUN
op_eq
id|BLOCK_NIL
)paren
id|s-&gt;LastFreeEUN
op_assign
id|block
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|ANACtable
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
