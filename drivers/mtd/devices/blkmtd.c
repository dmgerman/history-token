multiline_comment|/* &n; * $Id: blkmtd.c,v 1.7 2001/11/10 17:06:30 spse Exp $&n; *&n; * blkmtd.c - use a block device as a fake MTD&n; *&n; * Author: Simon Evans &lt;spse@secret.org.uk&gt;&n; *&n; * Copyright (C) 2001 Simon Evans&n; * &n; * Licence: GPL&n; *&n; * How it works:&n; *       The driver uses raw/io to read/write the device and the page&n; *       cache to cache access. Writes update the page cache with the&n; *       new data but make a copy of the new page(s) and then a kernel&n; *       thread writes pages out to the device in the background. This&n; *       ensures that writes are order even if a page is updated twice.&n; *       Also, since pages in the page cache are never marked as dirty,&n; *       we dont have to worry about writepage() being called on some &n; *       random page which may not be in the write order.&n; * &n; *       Erases are handled like writes, so the callback is called after&n; *       the page cache has been updated. Sync()ing will wait until it is &n; *       all done.&n; *&n; *       It can be loaded Read-Only to prevent erases and writes to the &n; *       medium.&n; *&n; * Todo:&n; *       Make the write queue size dynamic so this it is not too big on&n; *       small memory systems and too small on large memory systems.&n; * &n; *       Page cache usage may still be a bit wrong. Check we are doing&n; *       everything properly.&n; * &n; *       Somehow allow writes to dirty the page cache so we dont use too&n; *       much memory making copies of outgoing pages. Need to handle case&n; *       where page x is written to, then page y, then page x again before&n; *       any of them have been committed to disk.&n; * &n; *       Reading should read multiple pages at once rather than using &n; *       readpage() for each one. This is easy and will be fixed asap.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/iobuf.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/mtd/compatmac.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#ifdef CONFIG_MTD_DEBUG
macro_line|#ifdef CONFIG_PROC_FS
macro_line|#  include &lt;linux/proc_fs.h&gt;
DECL|macro|BLKMTD_PROC_DEBUG
macro_line|#  define BLKMTD_PROC_DEBUG
DECL|variable|blkmtd_proc
r_static
r_struct
id|proc_dir_entry
op_star
id|blkmtd_proc
suffix:semicolon
macro_line|#endif
macro_line|#endif
multiline_comment|/* Default erase size in K, always make it a multiple of PAGE_SIZE */
DECL|macro|CONFIG_MTD_BLKDEV_ERASESIZE
mdefine_line|#define CONFIG_MTD_BLKDEV_ERASESIZE 128
DECL|macro|VERSION
mdefine_line|#define VERSION &quot;1.7&quot;
multiline_comment|/* Info for the block device */
DECL|struct|mtd_raw_dev_data_s
r_typedef
r_struct
id|mtd_raw_dev_data_s
(brace
DECL|member|binding
r_struct
id|block_device
op_star
id|binding
suffix:semicolon
DECL|member|sector_size
DECL|member|sector_bits
r_int
id|sector_size
comma
id|sector_bits
suffix:semicolon
DECL|member|partial_last_page
r_int
id|partial_last_page
suffix:semicolon
singleline_comment|// 0 if device ends on page boundary, else page no of last page
DECL|member|last_page_sectors
r_int
id|last_page_sectors
suffix:semicolon
singleline_comment|// Number of sectors in last page if partial_last_page != 0
DECL|member|totalsize
r_int
id|totalsize
suffix:semicolon
DECL|member|readonly
r_int
id|readonly
suffix:semicolon
DECL|member|as
r_struct
id|address_space
id|as
suffix:semicolon
DECL|member|mtd_info
r_struct
id|mtd_info
id|mtd_info
suffix:semicolon
DECL|typedef|mtd_raw_dev_data_t
)brace
id|mtd_raw_dev_data_t
suffix:semicolon
multiline_comment|/* Info for each queue item in the write queue */
DECL|struct|mtdblkdev_write_queue_s
r_typedef
r_struct
id|mtdblkdev_write_queue_s
(brace
DECL|member|rawdevice
id|mtd_raw_dev_data_t
op_star
id|rawdevice
suffix:semicolon
DECL|member|pages
r_struct
id|page
op_star
op_star
id|pages
suffix:semicolon
DECL|member|pagenr
r_int
id|pagenr
suffix:semicolon
DECL|member|pagecnt
r_int
id|pagecnt
suffix:semicolon
DECL|member|iserase
r_int
id|iserase
suffix:semicolon
DECL|typedef|mtdblkdev_write_queue_t
)brace
id|mtdblkdev_write_queue_t
suffix:semicolon
multiline_comment|/* Our erase page - always remains locked. */
DECL|variable|erase_page
r_static
r_struct
id|page
op_star
id|erase_page
suffix:semicolon
multiline_comment|/* Static info about the MTD, used in cleanup_module */
DECL|variable|mtd_rawdevice
r_static
id|mtd_raw_dev_data_t
op_star
id|mtd_rawdevice
suffix:semicolon
multiline_comment|/* Write queue fixed size */
DECL|macro|WRITE_QUEUE_SZ
mdefine_line|#define WRITE_QUEUE_SZ 512
multiline_comment|/* Storage for the write queue */
DECL|variable|write_queue
r_static
id|mtdblkdev_write_queue_t
op_star
id|write_queue
suffix:semicolon
DECL|variable|write_queue_sz
r_static
r_int
id|write_queue_sz
op_assign
id|WRITE_QUEUE_SZ
suffix:semicolon
DECL|variable|write_queue_head
r_static
r_int
r_volatile
id|write_queue_head
suffix:semicolon
DECL|variable|write_queue_tail
r_static
r_int
r_volatile
id|write_queue_tail
suffix:semicolon
DECL|variable|write_queue_cnt
r_static
r_int
r_volatile
id|write_queue_cnt
suffix:semicolon
DECL|variable|mbd_writeq_lock
r_static
id|spinlock_t
id|mbd_writeq_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* Tell the write thread to finish */
DECL|variable|write_task_finish
r_static
r_volatile
r_int
id|write_task_finish
suffix:semicolon
multiline_comment|/* ipc with the write thread */
macro_line|#if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,3,0)
r_static
id|DECLARE_MUTEX_LOCKED
c_func
(paren
id|thread_sem
)paren
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|thr_wq
)paren
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|mtbd_sync_wq
)paren
suffix:semicolon
macro_line|#else
DECL|variable|thread_sem
r_static
r_struct
id|semaphore
id|thread_sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
DECL|variable|thr_wq
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|thr_wq
)paren
suffix:semicolon
DECL|variable|mtbd_sync_wq
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|mtbd_sync_wq
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Module parameters passed by insmod/modprobe */
DECL|variable|device
r_char
op_star
id|device
suffix:semicolon
multiline_comment|/* the block device to use */
DECL|variable|erasesz
r_int
id|erasesz
suffix:semicolon
multiline_comment|/* optional default erase size */
DECL|variable|ro
r_int
id|ro
suffix:semicolon
multiline_comment|/* optional read only flag */
DECL|variable|bs
r_int
id|bs
suffix:semicolon
multiline_comment|/* optionally force the block size (avoid using) */
DECL|variable|count
r_int
id|count
suffix:semicolon
multiline_comment|/* optionally force the block count (avoid using) */
DECL|variable|wqs
r_int
id|wqs
suffix:semicolon
multiline_comment|/* optionally set the write queue size */
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,2,0)
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Simon Evans &lt;spse@secret.org.uk&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Emulate an MTD using a block device&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|device
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|device
comma
l_string|&quot;block device to use&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|erasesz
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|erasesz
comma
l_string|&quot;optional erase size to use in KB. eg 4=4K.&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|ro
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|ro
comma
l_string|&quot;1=Read only, writes and erases cause errors&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|bs
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|bs
comma
l_string|&quot;force the block size in bytes&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|count
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|count
comma
l_string|&quot;force the block count&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|wqs
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Page cache stuff */
multiline_comment|/* writepage() - should never be called - catch it anyway */
DECL|function|blkmtd_writepage
r_static
r_int
id|blkmtd_writepage
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|writeback_control
op_star
id|wbc
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: writepage called!!!&bslash;n&quot;
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* readpage() - reads one page from the block device */
DECL|function|blkmtd_readpage
r_static
r_int
id|blkmtd_readpage
c_func
(paren
id|mtd_raw_dev_data_t
op_star
id|rawdevice
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_int
id|err
suffix:semicolon
r_int
id|sectornr
comma
id|sectors
comma
id|i
suffix:semicolon
r_struct
id|kiobuf
op_star
id|iobuf
suffix:semicolon
id|sector_t
op_star
id|blocks
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rawdevice
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: readpage: PANIC file-&gt;private_data == NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: readpage called, dev = `%s&squot; page = %p index = %ld&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rawdevice-&gt;binding
)paren
comma
id|page
comma
id|page-&gt;index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: readpage page %ld is already upto date&bslash;n&quot;
comma
id|page-&gt;index
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|ClearPageError
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* see if page is in the outgoing write queue */
id|spin_lock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_queue_cnt
)paren
(brace
r_int
id|i
op_assign
id|write_queue_tail
suffix:semicolon
r_while
c_loop
(paren
id|i
op_ne
id|write_queue_head
)paren
(brace
id|mtdblkdev_write_queue_t
op_star
id|item
op_assign
op_amp
id|write_queue
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;index
op_ge
id|item-&gt;pagenr
op_logical_and
id|page-&gt;index
OL
id|item-&gt;pagenr
op_plus
id|item-&gt;pagecnt
)paren
(brace
multiline_comment|/* yes it is */
r_int
id|index
op_assign
id|page-&gt;index
op_minus
id|item-&gt;pagenr
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: readpage: found page %ld in outgoing write queue&bslash;n&quot;
comma
id|page-&gt;index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|item-&gt;iserase
)paren
(brace
id|memset
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
comma
l_int|0xff
comma
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
comma
id|page_address
c_func
(paren
id|item-&gt;pages
(braket
id|index
)braket
)paren
comma
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|i
op_increment
suffix:semicolon
id|i
op_mod_assign
id|write_queue_sz
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: readpage: getting kiovec&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
id|alloc_kiovec
c_func
(paren
l_int|1
comma
op_amp
id|iobuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: cant allocate kiobuf&bslash;n&quot;
)paren
suffix:semicolon
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Pre 2.4.4 doesn&squot;t have space for the block list in the kiobuf */
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,4,4)
id|blocks
op_assign
id|kmalloc
c_func
(paren
id|KIO_MAX_SECTORS
op_star
r_sizeof
(paren
op_star
id|blocks
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blocks
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: cant allocate iobuf blocks&bslash;n&quot;
)paren
suffix:semicolon
id|free_kiovec
c_func
(paren
l_int|1
comma
op_amp
id|iobuf
)paren
suffix:semicolon
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
macro_line|#else 
id|blocks
op_assign
id|iobuf-&gt;blocks
suffix:semicolon
macro_line|#endif
id|iobuf-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|iobuf-&gt;nr_pages
op_assign
l_int|1
suffix:semicolon
id|iobuf-&gt;length
op_assign
id|PAGE_SIZE
suffix:semicolon
id|iobuf-&gt;locked
op_assign
l_int|1
suffix:semicolon
id|iobuf-&gt;maplist
(braket
l_int|0
)braket
op_assign
id|page
suffix:semicolon
id|sectornr
op_assign
id|page-&gt;index
op_lshift
(paren
id|PAGE_SHIFT
op_minus
id|rawdevice-&gt;sector_bits
)paren
suffix:semicolon
id|sectors
op_assign
l_int|1
op_lshift
(paren
id|PAGE_SHIFT
op_minus
id|rawdevice-&gt;sector_bits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rawdevice-&gt;partial_last_page
op_logical_and
id|page-&gt;index
op_eq
id|rawdevice-&gt;partial_last_page
)paren
(brace
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: handling partial last page&bslash;n&quot;
)paren
suffix:semicolon
id|sectors
op_assign
id|rawdevice-&gt;last_page_sectors
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: readpage: sectornr = %d sectors = %d&bslash;n&quot;
comma
id|sectornr
comma
id|sectors
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sectors
suffix:semicolon
id|i
op_increment
)paren
(brace
id|blocks
(braket
id|i
)braket
op_assign
id|sectornr
op_increment
suffix:semicolon
)brace
multiline_comment|/* If only a partial page read in, clear the rest of the page */
r_if
c_cond
(paren
id|rawdevice-&gt;partial_last_page
op_logical_and
id|page-&gt;index
op_eq
id|rawdevice-&gt;partial_last_page
)paren
(brace
r_int
id|offset
op_assign
id|rawdevice-&gt;last_page_sectors
op_lshift
id|rawdevice-&gt;sector_bits
suffix:semicolon
r_int
id|count
op_assign
id|PAGE_SIZE
op_minus
id|offset
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: clear last partial page: offset = %d count = %d&bslash;n&quot;
comma
id|offset
comma
id|count
)paren
suffix:semicolon
id|memset
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|offset
comma
l_int|0
comma
id|count
)paren
suffix:semicolon
id|sectors
op_assign
id|rawdevice-&gt;last_page_sectors
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;bklmtd: readpage: starting brw_kiovec&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
id|brw_kiovec
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
id|iobuf
comma
id|rawdevice-&gt;binding
comma
id|blocks
comma
id|rawdevice-&gt;sector_size
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: readpage: finished, err = %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
id|iobuf-&gt;locked
op_assign
l_int|0
suffix:semicolon
id|free_kiovec
c_func
(paren
l_int|1
comma
op_amp
id|iobuf
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,4,4)
id|kfree
c_func
(paren
id|blocks
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|err
op_ne
id|PAGE_SIZE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: readpage: error reading page %ld&bslash;n&quot;
comma
id|page-&gt;index
)paren
suffix:semicolon
id|memset
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: readpage: setting page upto date&bslash;n&quot;
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: readpage: finished, err = %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|blkmtd_aops
r_static
r_struct
id|address_space_operations
id|blkmtd_aops
op_assign
(brace
id|writepage
suffix:colon
id|blkmtd_writepage
comma
id|readpage
suffix:colon
l_int|NULL
comma
)brace
suffix:semicolon
multiline_comment|/* This is the kernel thread that empties the write queue to disk */
DECL|function|write_queue_task
r_static
r_int
id|write_queue_task
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
r_struct
id|kiobuf
op_star
id|iobuf
suffix:semicolon
id|sector_t
op_star
id|blocks
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;blkmtd: writetask: starting (pid = %d)&bslash;n&quot;
comma
id|tsk-&gt;pid
)paren
suffix:semicolon
id|daemonize
c_func
(paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|tsk-&gt;comm
comma
l_string|&quot;blkmtdd&quot;
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|tsk-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
id|sigfillset
c_func
(paren
op_amp
id|tsk-&gt;blocked
)paren
suffix:semicolon
id|recalc_sigpending
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|tsk-&gt;sighand-&gt;siglock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|alloc_kiovec
c_func
(paren
l_int|1
comma
op_amp
id|iobuf
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: write_queue_task cant allocate kiobuf&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Pre 2.4.4 doesn&squot;t have space for the block list in the kiobuf */
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,4,4)
id|blocks
op_assign
id|kmalloc
c_func
(paren
id|KIO_MAX_SECTORS
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blocks
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: write_queue_task cant allocate iobuf blocks&bslash;n&quot;
)paren
suffix:semicolon
id|free_kiovec
c_func
(paren
l_int|1
comma
op_amp
id|iobuf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#else 
id|blocks
op_assign
id|iobuf-&gt;blocks
suffix:semicolon
macro_line|#endif
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: writetask: entering main loop&bslash;n&quot;
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|thr_wq
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|write_queue_cnt
)paren
(brace
multiline_comment|/* If nothing in the queue, wake up anyone wanting to know when there&n;&t; is space in the queue then sleep for 2*HZ */
id|spin_unlock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;blkmtd: writetask: queue empty&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|mtbd_sync_wq
)paren
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|mtbd_sync_wq
)paren
suffix:semicolon
)brace
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|thr_wq
comma
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;blkmtd: writetask: woken up&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_task_finish
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* we have stuff to write */
id|mtdblkdev_write_queue_t
op_star
id|item
op_assign
op_amp
id|write_queue
(braket
id|write_queue_tail
)braket
suffix:semicolon
r_struct
id|page
op_star
op_star
id|pages
op_assign
id|item-&gt;pages
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|sectornr
op_assign
id|item-&gt;pagenr
op_lshift
(paren
id|PAGE_SHIFT
op_minus
id|item-&gt;rawdevice-&gt;sector_bits
)paren
suffix:semicolon
r_int
id|sectorcnt
op_assign
id|item-&gt;pagecnt
op_lshift
(paren
id|PAGE_SHIFT
op_minus
id|item-&gt;rawdevice-&gt;sector_bits
)paren
suffix:semicolon
r_int
id|max_sectors
op_assign
id|KIO_MAX_SECTORS
op_rshift
(paren
id|item-&gt;rawdevice-&gt;sector_bits
op_minus
l_int|9
)paren
suffix:semicolon
multiline_comment|/* If we are writing to the last page on the device and it doesn&squot;t end&n;       * on a page boundary, subtract the number of sectors that dont exist.&n;       */
r_if
c_cond
(paren
id|item-&gt;rawdevice-&gt;partial_last_page
op_logical_and
(paren
id|item-&gt;pagenr
op_plus
id|item-&gt;pagecnt
op_minus
l_int|1
)paren
op_eq
id|item-&gt;rawdevice-&gt;partial_last_page
)paren
(brace
id|sectorcnt
op_sub_assign
(paren
l_int|1
op_lshift
(paren
id|PAGE_SHIFT
op_minus
id|item-&gt;rawdevice-&gt;sector_bits
)paren
)paren
suffix:semicolon
id|sectorcnt
op_add_assign
id|item-&gt;rawdevice-&gt;last_page_sectors
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: writetask: got %d queue items&bslash;n&quot;
comma
id|write_queue_cnt
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: writetask: writing pagenr = %d pagecnt = %d sectornr = %d sectorcnt = %d&bslash;n&quot;
comma
id|item-&gt;pagenr
comma
id|item-&gt;pagecnt
comma
id|sectornr
comma
id|sectorcnt
)paren
suffix:semicolon
id|iobuf-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|iobuf-&gt;locked
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Loop through all the pages to be written in the queue item, remembering&n;&t; we can only write KIO_MAX_SECTORS at a time */
r_while
c_loop
(paren
id|sectorcnt
)paren
(brace
r_int
id|cursectors
op_assign
(paren
id|sectorcnt
OL
id|max_sectors
)paren
ques
c_cond
id|sectorcnt
suffix:colon
id|max_sectors
suffix:semicolon
r_int
id|cpagecnt
op_assign
(paren
id|cursectors
op_lshift
id|item-&gt;rawdevice-&gt;sector_bits
)paren
op_plus
id|PAGE_SIZE
op_minus
l_int|1
suffix:semicolon
id|cpagecnt
op_rshift_assign
id|PAGE_SHIFT
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cpagecnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|item-&gt;iserase
)paren
(brace
id|iobuf-&gt;maplist
(braket
id|i
)braket
op_assign
id|erase_page
suffix:semicolon
)brace
r_else
(brace
id|iobuf-&gt;maplist
(braket
id|i
)braket
op_assign
op_star
(paren
id|pages
op_increment
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cursectors
suffix:semicolon
id|i
op_increment
)paren
(brace
id|blocks
(braket
id|i
)braket
op_assign
id|sectornr
op_increment
suffix:semicolon
)brace
id|iobuf-&gt;nr_pages
op_assign
id|cpagecnt
suffix:semicolon
id|iobuf-&gt;length
op_assign
id|cursectors
op_lshift
id|item-&gt;rawdevice-&gt;sector_bits
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: write_task: about to kiovec&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
id|brw_kiovec
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|iobuf
comma
id|item-&gt;rawdevice-&gt;binding
comma
id|blocks
comma
id|item-&gt;rawdevice-&gt;sector_size
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;bklmtd: write_task: done, err = %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
(paren
id|cursectors
op_lshift
id|item-&gt;rawdevice-&gt;sector_bits
)paren
)paren
(brace
multiline_comment|/* if an error occured - set this to exit the loop */
id|sectorcnt
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|sectorcnt
op_sub_assign
id|cursectors
suffix:semicolon
)brace
)brace
multiline_comment|/* free up the pages used in the write and list of pages used in the write&n;&t; queue item */
id|iobuf-&gt;locked
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
id|write_queue_cnt
op_decrement
suffix:semicolon
id|write_queue_tail
op_increment
suffix:semicolon
id|write_queue_tail
op_mod_assign
id|write_queue_sz
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|item-&gt;iserase
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|item-&gt;pagecnt
suffix:semicolon
id|i
op_increment
)paren
(brace
id|unlock_page
c_func
(paren
id|item-&gt;pages
(braket
id|i
)braket
)paren
suffix:semicolon
id|__free_pages
c_func
(paren
id|item-&gt;pages
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|item-&gt;pages
)paren
suffix:semicolon
)brace
id|item-&gt;pages
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
multiline_comment|/* Tell others there is some space in the write queue */
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|mtbd_sync_wq
)paren
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|mtbd_sync_wq
)paren
suffix:semicolon
)brace
)brace
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|thr_wq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;blkmtd: writetask: exiting&bslash;n&quot;
)paren
suffix:semicolon
id|free_kiovec
c_func
(paren
l_int|1
comma
op_amp
id|iobuf
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,4,4)
id|kfree
c_func
(paren
id|blocks
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Tell people we have exitd */
id|up
c_func
(paren
op_amp
id|thread_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Add a range of pages into the outgoing write queue, making copies of them */
DECL|function|queue_page_write
r_static
r_int
id|queue_page_write
c_func
(paren
id|mtd_raw_dev_data_t
op_star
id|rawdevice
comma
r_struct
id|page
op_star
op_star
id|pages
comma
r_int
id|pagenr
comma
r_int
id|pagecnt
comma
r_int
id|iserase
)paren
(brace
r_struct
id|page
op_star
id|outpage
suffix:semicolon
r_struct
id|page
op_star
op_star
id|new_pages
op_assign
l_int|NULL
suffix:semicolon
id|mtdblkdev_write_queue_t
op_star
id|item
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: queue_page_write: adding pagenr = %d pagecnt = %d&bslash;n&quot;
comma
id|pagenr
comma
id|pagecnt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pagecnt
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pages
op_eq
l_int|NULL
op_logical_and
op_logical_neg
id|iserase
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* create a array for the list of pages */
r_if
c_cond
(paren
op_logical_neg
id|iserase
)paren
(brace
id|new_pages
op_assign
id|kmalloc
c_func
(paren
id|pagecnt
op_star
r_sizeof
(paren
r_struct
id|page
op_star
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_pages
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* make copies of the pages in the page cache */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pagecnt
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outpage
op_assign
id|alloc_pages
c_func
(paren
id|GFP_KERNEL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|outpage
)paren
(brace
r_while
c_loop
(paren
id|i
op_decrement
)paren
(brace
id|unlock_page
c_func
(paren
id|new_pages
(braket
id|i
)braket
)paren
suffix:semicolon
id|__free_pages
c_func
(paren
id|new_pages
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|new_pages
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|lock_page
c_func
(paren
id|outpage
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|page_address
c_func
(paren
id|outpage
)paren
comma
id|page_address
c_func
(paren
id|pages
(braket
id|i
)braket
)paren
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|new_pages
(braket
id|i
)braket
op_assign
id|outpage
suffix:semicolon
)brace
)brace
multiline_comment|/* wait until there is some space in the write queue */
id|test_lock
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_queue_cnt
op_eq
id|write_queue_sz
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: queue_page: Queue full&bslash;n&quot;
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|mtbd_sync_wq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|thr_wq
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|mtbd_sync_wq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: queue_page_write: Queue has %d items in it&bslash;n&quot;
comma
id|write_queue_cnt
)paren
suffix:semicolon
r_goto
id|test_lock
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: queue_page_write: qhead: %d qtail: %d qcnt: %d&bslash;n&quot;
comma
id|write_queue_head
comma
id|write_queue_tail
comma
id|write_queue_cnt
)paren
suffix:semicolon
multiline_comment|/* fix up the queue item */
id|item
op_assign
op_amp
id|write_queue
(braket
id|write_queue_head
)braket
suffix:semicolon
id|item-&gt;pages
op_assign
id|new_pages
suffix:semicolon
id|item-&gt;pagenr
op_assign
id|pagenr
suffix:semicolon
id|item-&gt;pagecnt
op_assign
id|pagecnt
suffix:semicolon
id|item-&gt;rawdevice
op_assign
id|rawdevice
suffix:semicolon
id|item-&gt;iserase
op_assign
id|iserase
suffix:semicolon
id|write_queue_head
op_increment
suffix:semicolon
id|write_queue_head
op_mod_assign
id|write_queue_sz
suffix:semicolon
id|write_queue_cnt
op_increment
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: queue_page_write: qhead: %d qtail: %d qcnt: %d&bslash;n&quot;
comma
id|write_queue_head
comma
id|write_queue_tail
comma
id|write_queue_cnt
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: queue_page_write: finished&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* erase a specified part of the device */
DECL|function|blkmtd_erase
r_static
r_int
id|blkmtd_erase
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|erase_info
op_star
id|instr
)paren
(brace
id|mtd_raw_dev_data_t
op_star
id|rawdevice
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|mtd_erase_region_info
op_star
id|einfo
op_assign
id|mtd-&gt;eraseregions
suffix:semicolon
r_int
id|numregions
op_assign
id|mtd-&gt;numeraseregions
suffix:semicolon
r_int
id|from
suffix:semicolon
id|u_long
id|len
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* check readonly */
r_if
c_cond
(paren
id|rawdevice-&gt;readonly
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: error: trying to erase readonly device %s&bslash;n&quot;
comma
id|device
)paren
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASE_FAILED
suffix:semicolon
r_goto
id|erase_callback
suffix:semicolon
)brace
id|instr-&gt;state
op_assign
id|MTD_ERASING
suffix:semicolon
id|from
op_assign
id|instr-&gt;addr
suffix:semicolon
id|len
op_assign
id|instr-&gt;len
suffix:semicolon
multiline_comment|/* check erase region has valid start and length */
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: erase: dev = `%s&squot; from = 0x%x len = 0x%lx&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rawdevice-&gt;binding
)paren
comma
id|from
comma
id|len
)paren
suffix:semicolon
r_while
c_loop
(paren
id|numregions
)paren
(brace
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: checking erase region = 0x%08X size = 0x%X num = 0x%x&bslash;n&quot;
comma
id|einfo-&gt;offset
comma
id|einfo-&gt;erasesize
comma
id|einfo-&gt;numblocks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|from
op_ge
id|einfo-&gt;offset
op_logical_and
id|from
OL
id|einfo-&gt;offset
op_plus
(paren
id|einfo-&gt;erasesize
op_star
id|einfo-&gt;numblocks
)paren
)paren
(brace
r_if
c_cond
(paren
id|len
op_eq
id|einfo-&gt;erasesize
op_logical_and
(paren
(paren
id|from
op_minus
id|einfo-&gt;offset
)paren
op_mod
id|einfo-&gt;erasesize
op_eq
l_int|0
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|numregions
op_decrement
suffix:semicolon
id|einfo
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|numregions
)paren
(brace
multiline_comment|/* Not a valid erase block */
id|printk
c_func
(paren
l_string|&quot;blkmtd: erase: invalid erase request 0x%lX @ 0x%08X&bslash;n&quot;
comma
id|len
comma
id|from
)paren
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASE_FAILED
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|instr-&gt;state
op_ne
id|MTD_ERASE_FAILED
)paren
(brace
multiline_comment|/* start the erase */
r_int
id|pagenr
comma
id|pagecnt
suffix:semicolon
r_struct
id|page
op_star
id|page
comma
op_star
op_star
id|pages
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Handle the last page of the device not being whole */
r_if
c_cond
(paren
id|len
OL
id|PAGE_SIZE
)paren
(brace
id|len
op_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|pagenr
op_assign
id|from
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|pagecnt
op_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: erase: pagenr = %d pagecnt = %d&bslash;n&quot;
comma
id|pagenr
comma
id|pagecnt
)paren
suffix:semicolon
id|pages
op_assign
id|kmalloc
c_func
(paren
id|pagecnt
op_star
r_sizeof
(paren
r_struct
id|page
op_star
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pages
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASE_FAILED
suffix:semicolon
r_goto
id|erase_out
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pagecnt
)paren
(brace
multiline_comment|/* get the page via the page cache */
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: erase: doing grab_cache_page() for page %d&bslash;n&quot;
comma
id|pagenr
)paren
suffix:semicolon
id|page
op_assign
id|grab_cache_page
c_func
(paren
op_amp
id|rawdevice-&gt;as
comma
id|pagenr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: erase: grab_cache_page() failed for page %d&bslash;n&quot;
comma
id|pagenr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pages
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASE_FAILED
suffix:semicolon
r_goto
id|erase_out
suffix:semicolon
)brace
id|memset
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
comma
l_int|0xff
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|pages
(braket
id|i
)braket
op_assign
id|page
suffix:semicolon
id|pagecnt
op_decrement
suffix:semicolon
id|pagenr
op_increment
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: erase: queuing page write&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
id|queue_page_write
c_func
(paren
id|rawdevice
comma
l_int|NULL
comma
id|from
op_rshift
id|PAGE_SHIFT
comma
id|len
op_rshift
id|PAGE_SHIFT
comma
l_int|1
)paren
suffix:semicolon
id|pagecnt
op_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
r_while
c_loop
(paren
id|pagecnt
op_decrement
)paren
(brace
id|SetPageUptodate
c_func
(paren
id|pages
(braket
id|pagecnt
)braket
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|pages
(braket
id|pagecnt
)braket
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|pages
(braket
id|pagecnt
)braket
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|pages
(braket
id|pagecnt
)braket
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|pages
)paren
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASE_DONE
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
id|pagecnt
op_decrement
)paren
(brace
id|SetPageError
c_func
(paren
id|pages
(braket
id|pagecnt
)braket
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|pages
(braket
id|pagecnt
)braket
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|pages
)paren
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASE_FAILED
suffix:semicolon
)brace
)brace
id|erase_out
suffix:colon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: erase: checking callback&bslash;n&quot;
)paren
suffix:semicolon
id|erase_callback
suffix:colon
r_if
c_cond
(paren
id|instr-&gt;callback
)paren
(brace
(paren
op_star
(paren
id|instr-&gt;callback
)paren
)paren
(paren
id|instr
)paren
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: erase: finished (err = %d)&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* read a range of the data via the page cache */
DECL|function|blkmtd_read
r_static
r_int
id|blkmtd_read
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
(brace
id|mtd_raw_dev_data_t
op_star
id|rawdevice
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_int
id|pagenr
comma
id|pages
suffix:semicolon
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: read: dev = `%s&squot; from = %ld len = %d buf = %p&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rawdevice-&gt;binding
)paren
comma
(paren
r_int
r_int
)paren
id|from
comma
id|len
comma
id|buf
)paren
suffix:semicolon
id|pagenr
op_assign
id|from
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|offset
op_assign
id|from
op_minus
(paren
id|pagenr
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|pages
op_assign
(paren
id|offset
op_plus
id|len
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: read: pagenr = %d offset = %d, pages = %d&bslash;n&quot;
comma
id|pagenr
comma
id|offset
comma
id|pages
)paren
suffix:semicolon
multiline_comment|/* just loop through each page, getting it via readpage() - slow but easy */
r_while
c_loop
(paren
id|pages
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|cpylen
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: read: looking for page: %d&bslash;n&quot;
comma
id|pagenr
)paren
suffix:semicolon
id|page
op_assign
id|read_cache_page
c_func
(paren
op_amp
id|rawdevice-&gt;as
comma
id|pagenr
comma
(paren
id|filler_t
op_star
)paren
id|blkmtd_readpage
comma
id|rawdevice
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
r_return
id|PTR_ERR
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|wait_on_page_locked
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
multiline_comment|/* error reading page */
id|printk
c_func
(paren
l_string|&quot;blkmtd: read: page not uptodate&bslash;n&quot;
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|cpylen
op_assign
(paren
id|PAGE_SIZE
OG
id|len
)paren
ques
c_cond
id|len
suffix:colon
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_plus
id|cpylen
OG
id|PAGE_SIZE
)paren
(brace
id|cpylen
op_assign
id|PAGE_SIZE
op_minus
id|offset
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|buf
op_plus
op_star
id|retlen
comma
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|offset
comma
id|cpylen
)paren
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
id|len
op_sub_assign
id|cpylen
suffix:semicolon
op_star
id|retlen
op_add_assign
id|cpylen
suffix:semicolon
id|pagenr
op_increment
suffix:semicolon
id|pages
op_decrement
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: end read: retlen = %d, err = %d&bslash;n&quot;
comma
op_star
id|retlen
comma
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* write a range of the data via the page cache.&n; *&n; * Basic operation. break the write into three parts. &n; *&n; * 1. From a page unaligned start up until the next page boundary&n; * 2. Page sized, page aligned blocks&n; * 3. From end of last aligned block to end of range&n; *&n; * 1,3 are read via the page cache and readpage() since these are partial&n; * pages, 2 we just grab pages from the page cache, not caring if they are&n; * already in memory or not since they will be completly overwritten.&n; *&n; */
DECL|function|blkmtd_write
r_static
r_int
id|blkmtd_write
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
(brace
id|mtd_raw_dev_data_t
op_star
id|rawdevice
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_int
id|pagenr
suffix:semicolon
r_int
id|len1
op_assign
l_int|0
comma
id|len2
op_assign
l_int|0
comma
id|len3
op_assign
l_int|0
suffix:semicolon
r_struct
id|page
op_star
op_star
id|pages
suffix:semicolon
r_int
id|pagecnt
op_assign
l_int|0
suffix:semicolon
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: write: dev = `%s&squot; to = %ld len = %d buf = %p&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rawdevice-&gt;binding
)paren
comma
(paren
r_int
r_int
)paren
id|to
comma
id|len
comma
id|buf
)paren
suffix:semicolon
multiline_comment|/* handle readonly and out of range numbers */
r_if
c_cond
(paren
id|rawdevice-&gt;readonly
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: error: trying to write to a readonly device %s&bslash;n&quot;
comma
id|device
)paren
suffix:semicolon
r_return
op_minus
id|EROFS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|to
op_ge
id|rawdevice-&gt;totalsize
)paren
(brace
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_if
c_cond
(paren
id|to
op_plus
id|len
OG
id|rawdevice-&gt;totalsize
)paren
(brace
id|len
op_assign
(paren
id|rawdevice-&gt;totalsize
op_minus
id|to
)paren
suffix:semicolon
)brace
id|pagenr
op_assign
id|to
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|offset
op_assign
id|to
op_minus
(paren
id|pagenr
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
multiline_comment|/* see if we have to do a partial write at the start */
r_if
c_cond
(paren
id|offset
)paren
(brace
r_if
c_cond
(paren
(paren
id|offset
op_plus
id|len
)paren
OG
id|PAGE_SIZE
)paren
(brace
id|len1
op_assign
id|PAGE_SIZE
op_minus
id|offset
suffix:semicolon
id|len
op_sub_assign
id|len1
suffix:semicolon
)brace
r_else
(brace
id|len1
op_assign
id|len
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* calculate the length of the other two regions */
id|len3
op_assign
id|len
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
id|len
op_sub_assign
id|len3
suffix:semicolon
id|len2
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|len1
)paren
(brace
id|pagecnt
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len2
)paren
(brace
id|pagecnt
op_add_assign
id|len2
op_rshift
id|PAGE_SHIFT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len3
)paren
(brace
id|pagecnt
op_increment
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: write: len1 = %d len2 = %d len3 = %d pagecnt = %d&bslash;n&quot;
comma
id|len1
comma
id|len2
comma
id|len3
comma
id|pagecnt
)paren
suffix:semicolon
multiline_comment|/* get space for list of pages */
id|pages
op_assign
id|kmalloc
c_func
(paren
id|pagecnt
op_star
r_sizeof
(paren
r_struct
id|page
op_star
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pages
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|pagecnt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|len1
)paren
(brace
multiline_comment|/* do partial start region */
r_struct
id|page
op_star
id|page
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: write: doing partial start, page = %d len = %d offset = %d&bslash;n&quot;
comma
id|pagenr
comma
id|len1
comma
id|offset
)paren
suffix:semicolon
id|page
op_assign
id|read_cache_page
c_func
(paren
op_amp
id|rawdevice-&gt;as
comma
id|pagenr
comma
(paren
id|filler_t
op_star
)paren
id|blkmtd_readpage
comma
id|rawdevice
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
id|kfree
c_func
(paren
id|pages
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|offset
comma
id|buf
comma
id|len1
)paren
suffix:semicolon
id|pages
(braket
id|pagecnt
op_increment
)braket
op_assign
id|page
suffix:semicolon
id|buf
op_add_assign
id|len1
suffix:semicolon
op_star
id|retlen
op_assign
id|len1
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|pagenr
op_increment
suffix:semicolon
)brace
multiline_comment|/* Now do the main loop to a page aligned, n page sized output */
r_if
c_cond
(paren
id|len2
)paren
(brace
r_int
id|pagesc
op_assign
id|len2
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: write: whole pages start = %d, count = %d&bslash;n&quot;
comma
id|pagenr
comma
id|pagesc
)paren
suffix:semicolon
r_while
c_loop
(paren
id|pagesc
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
multiline_comment|/* see if page is in the page cache */
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: write: grabbing page %d from page cache&bslash;n&quot;
comma
id|pagenr
)paren
suffix:semicolon
id|page
op_assign
id|grab_cache_page
c_func
(paren
op_amp
id|rawdevice-&gt;as
comma
id|pagenr
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: write: got page %d from page cache&bslash;n&quot;
comma
id|pagenr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: write: cant grab cache page %d&bslash;n&quot;
comma
id|pagenr
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|write_err
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
comma
id|buf
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|pages
(braket
id|pagecnt
op_increment
)braket
op_assign
id|page
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|pagenr
op_increment
suffix:semicolon
id|pagesc
op_decrement
suffix:semicolon
id|buf
op_add_assign
id|PAGE_SIZE
suffix:semicolon
op_star
id|retlen
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|len3
)paren
(brace
multiline_comment|/* do the third region */
r_struct
id|page
op_star
id|page
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: write: doing partial end, page = %d len = %d&bslash;n&quot;
comma
id|pagenr
comma
id|len3
)paren
suffix:semicolon
id|page
op_assign
id|read_cache_page
c_func
(paren
op_amp
id|rawdevice-&gt;as
comma
id|pagenr
comma
(paren
id|filler_t
op_star
)paren
id|blkmtd_readpage
comma
id|rawdevice
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|write_err
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
comma
id|buf
comma
id|len3
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: write: writing out partial end&bslash;n&quot;
)paren
suffix:semicolon
id|pages
(braket
id|pagecnt
op_increment
)braket
op_assign
id|page
suffix:semicolon
op_star
id|retlen
op_add_assign
id|len3
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: write: end, retlen = %d, err = %d&bslash;n&quot;
comma
op_star
id|retlen
comma
id|err
)paren
suffix:semicolon
multiline_comment|/* submit it to the write task */
id|err
op_assign
id|queue_page_write
c_func
(paren
id|rawdevice
comma
id|pages
comma
id|to
op_rshift
id|PAGE_SHIFT
comma
id|pagecnt
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
r_while
c_loop
(paren
id|pagecnt
op_decrement
)paren
(brace
id|SetPageUptodate
c_func
(paren
id|pages
(braket
id|pagecnt
)braket
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|pages
(braket
id|pagecnt
)braket
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|pages
(braket
id|pagecnt
)braket
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|pages
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|write_err
suffix:colon
r_while
c_loop
(paren
op_decrement
id|pagecnt
)paren
(brace
id|SetPageError
c_func
(paren
id|pages
(braket
id|pagecnt
)braket
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|pages
(braket
id|pagecnt
)braket
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|pages
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* sync the device - wait until the write queue is empty */
DECL|function|blkmtd_sync
r_static
r_void
id|blkmtd_sync
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|mtd_raw_dev_data_t
op_star
id|rawdevice
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|rawdevice-&gt;readonly
)paren
(brace
r_return
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: sync: called&bslash;n&quot;
)paren
suffix:semicolon
id|stuff_inq
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_queue_cnt
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|mtbd_sync_wq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: sync: waking up task&bslash;n&quot;
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|thr_wq
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|mtbd_sync_wq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: sync: waking up after write task&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|stuff_inq
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: sync: finished&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef BLKMTD_PROC_DEBUG
multiline_comment|/* procfs stuff */
DECL|function|blkmtd_proc_read
r_static
r_int
id|blkmtd_proc_read
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|clean
op_assign
l_int|0
comma
id|dirty
op_assign
l_int|0
comma
id|locked
op_assign
l_int|0
suffix:semicolon
r_struct
id|list_head
op_star
id|temp
suffix:semicolon
r_int
id|i
comma
id|len
comma
id|pages
op_assign
l_int|0
comma
id|cnt
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
id|cnt
op_assign
id|write_queue_cnt
suffix:semicolon
id|i
op_assign
id|write_queue_tail
suffix:semicolon
r_while
c_loop
(paren
id|cnt
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|write_queue
(braket
id|i
)braket
dot
id|iserase
)paren
(brace
id|pages
op_add_assign
id|write_queue
(braket
id|i
)braket
dot
id|pagecnt
suffix:semicolon
)brace
id|i
op_increment
suffix:semicolon
id|i
op_mod_assign
id|write_queue_sz
suffix:semicolon
id|cnt
op_decrement
suffix:semicolon
)brace
multiline_comment|/* Count the size of the page lists */
id|list_for_each
c_func
(paren
id|temp
comma
op_amp
id|mtd_rawdevice-&gt;as.clean_pages
)paren
(brace
id|clean
op_increment
suffix:semicolon
)brace
id|list_for_each
c_func
(paren
id|temp
comma
op_amp
id|mtd_rawdevice-&gt;as.dirty_pages
)paren
(brace
id|dirty
op_increment
suffix:semicolon
)brace
id|list_for_each
c_func
(paren
id|temp
comma
op_amp
id|mtd_rawdevice-&gt;as.locked_pages
)paren
(brace
id|locked
op_increment
suffix:semicolon
)brace
id|len
op_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;Write queue head: %d&bslash;nWrite queue tail: %d&bslash;n&quot;
l_string|&quot;Write queue count: %d&bslash;nPages in queue: %d (%dK)&bslash;n&quot;
l_string|&quot;Clean Pages: %d&bslash;nDirty Pages: %d&bslash;nLocked Pages: %d&bslash;n&quot;
l_string|&quot;nrpages: %ld&bslash;n&quot;
comma
id|write_queue_head
comma
id|write_queue_tail
comma
id|write_queue_cnt
comma
id|pages
comma
id|pages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
comma
id|clean
comma
id|dirty
comma
id|locked
comma
id|mtd_rawdevice-&gt;as.nrpages
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
id|count
)paren
(brace
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Cleanup and exit - sync the device and kill of the kernel thread */
DECL|function|cleanup_blkmtd
r_static
r_void
id|__exit
id|cleanup_blkmtd
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef BLKMTD_PROC_DEBUG
r_if
c_cond
(paren
id|blkmtd_proc
)paren
(brace
id|remove_proc_entry
c_func
(paren
l_string|&quot;blkmtd_debug&quot;
comma
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|mtd_rawdevice
)paren
(brace
multiline_comment|/* sync the device */
r_if
c_cond
(paren
op_logical_neg
id|mtd_rawdevice-&gt;readonly
)paren
(brace
id|blkmtd_sync
c_func
(paren
op_amp
id|mtd_rawdevice-&gt;mtd_info
)paren
suffix:semicolon
id|write_task_finish
op_assign
l_int|1
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|thr_wq
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|thread_sem
)paren
suffix:semicolon
)brace
id|del_mtd_device
c_func
(paren
op_amp
id|mtd_rawdevice-&gt;mtd_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mtd_rawdevice-&gt;binding
op_ne
l_int|NULL
)paren
(brace
id|blkdev_put
c_func
(paren
id|mtd_rawdevice-&gt;binding
comma
id|BDEV_RAW
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mtd_rawdevice-&gt;mtd_info.eraseregions
)paren
(brace
id|kfree
c_func
(paren
id|mtd_rawdevice-&gt;mtd_info.eraseregions
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mtd_rawdevice-&gt;mtd_info.name
)paren
(brace
id|kfree
c_func
(paren
id|mtd_rawdevice-&gt;mtd_info.name
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|mtd_rawdevice
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|write_queue
)paren
(brace
id|kfree
c_func
(paren
id|write_queue
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|erase_page
)paren
(brace
id|unlock_page
c_func
(paren
id|erase_page
)paren
suffix:semicolon
id|__free_pages
c_func
(paren
id|erase_page
comma
l_int|0
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: unloaded for %s&bslash;n&quot;
comma
id|device
)paren
suffix:semicolon
)brace
r_extern
r_struct
id|module
id|__this_module
suffix:semicolon
macro_line|#ifndef MODULE
multiline_comment|/* Handle kernel boot params */
DECL|function|param_blkmtd_device
r_static
r_int
id|__init
id|param_blkmtd_device
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|device
op_assign
id|str
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|param_blkmtd_erasesz
r_static
r_int
id|__init
id|param_blkmtd_erasesz
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|erasesz
op_assign
id|simple_strtol
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|param_blkmtd_ro
r_static
r_int
id|__init
id|param_blkmtd_ro
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|ro
op_assign
id|simple_strtol
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|param_blkmtd_bs
r_static
r_int
id|__init
id|param_blkmtd_bs
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|bs
op_assign
id|simple_strtol
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|param_blkmtd_count
r_static
r_int
id|__init
id|param_blkmtd_count
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|count
op_assign
id|simple_strtol
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;blkmtd_device=&quot;
comma
id|param_blkmtd_device
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;blkmtd_erasesz=&quot;
comma
id|param_blkmtd_erasesz
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;blkmtd_ro=&quot;
comma
id|param_blkmtd_ro
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;blkmtd_bs=&quot;
comma
id|param_blkmtd_bs
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;blkmtd_count=&quot;
comma
id|param_blkmtd_count
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* for a given size and initial erase size, calculate the number and size of each&n;   erase region */
DECL|function|calc_erase_regions
r_static
r_int
id|__init
id|calc_erase_regions
c_func
(paren
r_struct
id|mtd_erase_region_info
op_star
id|info
comma
r_int
id|erase_size
comma
r_int
id|total_size
)paren
(brace
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
id|offset
op_assign
l_int|0
suffix:semicolon
r_int
id|regions
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|total_size
)paren
(brace
id|count
op_assign
id|total_size
op_div
id|erase_size
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
id|total_size
op_assign
id|total_size
op_mod
id|erase_size
suffix:semicolon
r_if
c_cond
(paren
id|info
)paren
(brace
id|info-&gt;offset
op_assign
id|offset
suffix:semicolon
id|info-&gt;erasesize
op_assign
id|erase_size
suffix:semicolon
id|info-&gt;numblocks
op_assign
id|count
suffix:semicolon
id|info
op_increment
suffix:semicolon
)brace
id|offset
op_add_assign
(paren
id|count
op_star
id|erase_size
)paren
suffix:semicolon
id|regions
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|erase_size
OG
id|total_size
)paren
(brace
id|erase_size
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|regions
suffix:semicolon
)brace
r_extern
id|dev_t
id|name_to_dev_t
c_func
(paren
r_char
op_star
id|line
)paren
id|__init
suffix:semicolon
multiline_comment|/* Startup */
DECL|function|init_blkmtd
r_static
r_int
id|__init
id|init_blkmtd
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef MODULE
r_struct
id|file
op_star
id|file
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
macro_line|#endif
r_int
id|maj
comma
id|min
suffix:semicolon
r_int
id|i
comma
id|blocksize
comma
id|blocksize_bits
suffix:semicolon
id|loff_t
id|size
suffix:semicolon
r_int
id|readonly
op_assign
l_int|0
suffix:semicolon
r_int
id|erase_size
op_assign
id|CONFIG_MTD_BLKDEV_ERASESIZE
suffix:semicolon
id|dev_t
id|rdev
suffix:semicolon
r_struct
id|block_device
op_star
id|bdev
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
id|mode
suffix:semicolon
r_int
id|regions
suffix:semicolon
multiline_comment|/* Check args */
r_if
c_cond
(paren
id|device
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: error, missing `device&squot; name&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ro
)paren
(brace
id|readonly
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|erasesz
)paren
(brace
id|erase_size
op_assign
id|erasesz
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wqs
)paren
(brace
r_if
c_cond
(paren
id|wqs
OL
l_int|16
)paren
(brace
id|wqs
op_assign
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wqs
OG
l_int|4
op_star
id|WRITE_QUEUE_SZ
)paren
(brace
id|wqs
op_assign
l_int|4
op_star
id|WRITE_QUEUE_SZ
suffix:semicolon
)brace
id|write_queue_sz
op_assign
id|wqs
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;blkmtd: device = `%s&squot; erase size = %dK readonly = %s queue size = %d&bslash;n&quot;
comma
id|device
comma
id|erase_size
comma
id|readonly
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
comma
id|write_queue_sz
)paren
suffix:semicolon
multiline_comment|/* Get a handle on the device */
id|mode
op_assign
(paren
id|readonly
)paren
ques
c_cond
id|O_RDONLY
suffix:colon
id|O_RDWR
suffix:semicolon
macro_line|#ifdef MODULE
id|file
op_assign
id|filp_open
c_func
(paren
id|device
comma
id|mode
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|file
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: error, cant open device %s&bslash;n&quot;
comma
id|device
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: filp_open returned %ld&bslash;n&quot;
comma
id|PTR_ERR
c_func
(paren
id|file
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* determine is this is a block device and if so get its major and minor&n;     numbers */
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: %s not a block device&bslash;n&quot;
comma
id|device
)paren
suffix:semicolon
id|filp_close
c_func
(paren
id|file
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|rdev
op_assign
id|inode-&gt;i_bdev-&gt;bd_dev
suffix:semicolon
id|filp_close
c_func
(paren
id|file
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#else
id|rdev
op_assign
id|name_to_dev_t
c_func
(paren
id|device
)paren
suffix:semicolon
macro_line|#endif
id|maj
op_assign
id|MAJOR
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|min
op_assign
id|MINOR
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;blkmtd: found a block device major = %d, minor = %d&bslash;n&quot;
comma
id|maj
comma
id|min
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: bad block device: `%s&squot;&bslash;n&quot;
comma
id|device
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|maj
op_eq
id|MTD_BLOCK_MAJOR
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: attempting to use an MTD device as a block device&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* get the block device */
id|bdev
op_assign
id|bdget
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|err
op_assign
id|blkdev_get
c_func
(paren
id|bdev
comma
id|mode
comma
l_int|0
comma
id|BDEV_RAW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
l_int|1
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;blkmtd: devname = %s&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|bdev
)paren
)paren
suffix:semicolon
id|blocksize
op_assign
id|BLOCK_SIZE
suffix:semicolon
id|blocksize
op_assign
id|bs
ques
c_cond
id|bs
suffix:colon
id|block_size
c_func
(paren
id|bdev
)paren
suffix:semicolon
id|i
op_assign
id|blocksize
suffix:semicolon
id|blocksize_bits
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|i
op_ne
l_int|1
)paren
(brace
id|blocksize_bits
op_increment
suffix:semicolon
id|i
op_rshift_assign
l_int|1
suffix:semicolon
)brace
id|size
op_assign
id|count
ques
c_cond
id|count
op_star
id|blocksize
suffix:colon
id|bdev-&gt;bd_inode-&gt;i_size
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;blkmtd: size = %ld&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: cant determine size&bslash;n&quot;
)paren
suffix:semicolon
id|blkdev_put
c_func
(paren
id|bdev
comma
id|BDEV_RAW
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|mtd_rawdevice
op_assign
(paren
id|mtd_raw_dev_data_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|mtd_raw_dev_data_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mtd_rawdevice
op_eq
l_int|NULL
)paren
(brace
id|blkdev_put
c_func
(paren
id|bdev
comma
id|BDEV_RAW
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|init_err
suffix:semicolon
)brace
id|memset
c_func
(paren
id|mtd_rawdevice
comma
l_int|0
comma
r_sizeof
(paren
id|mtd_raw_dev_data_t
)paren
)paren
suffix:semicolon
id|mtd_rawdevice-&gt;binding
op_assign
id|bdev
suffix:semicolon
id|mtd_rawdevice-&gt;totalsize
op_assign
id|size
suffix:semicolon
id|mtd_rawdevice-&gt;sector_size
op_assign
id|blocksize
suffix:semicolon
id|mtd_rawdevice-&gt;sector_bits
op_assign
id|blocksize_bits
suffix:semicolon
id|mtd_rawdevice-&gt;readonly
op_assign
id|readonly
suffix:semicolon
multiline_comment|/* See if device ends on page boundary */
r_if
c_cond
(paren
id|size
op_mod
id|PAGE_SIZE
)paren
(brace
id|mtd_rawdevice-&gt;partial_last_page
op_assign
id|size
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|mtd_rawdevice-&gt;last_page_sectors
op_assign
(paren
id|size
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;sector_size = %d, sector_bits = %d, partial_last_page = %d last_page_sectors = %d&bslash;n&quot;
comma
id|mtd_rawdevice-&gt;sector_size
comma
id|mtd_rawdevice-&gt;sector_bits
comma
id|mtd_rawdevice-&gt;partial_last_page
comma
id|mtd_rawdevice-&gt;last_page_sectors
)paren
suffix:semicolon
multiline_comment|/* Setup the MTD structure */
multiline_comment|/* make the name contain the block device in */
id|mtd_rawdevice-&gt;mtd_info.name
op_assign
id|kmalloc
c_func
(paren
l_int|9
op_plus
id|strlen
c_func
(paren
id|device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mtd_rawdevice-&gt;mtd_info.name
op_eq
l_int|NULL
)paren
(brace
r_goto
id|init_err
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|mtd_rawdevice-&gt;mtd_info.name
comma
l_string|&quot;blkmtd: %s&quot;
comma
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|readonly
)paren
(brace
id|mtd_rawdevice-&gt;mtd_info.type
op_assign
id|MTD_ROM
suffix:semicolon
id|mtd_rawdevice-&gt;mtd_info.flags
op_assign
id|MTD_CAP_ROM
suffix:semicolon
id|mtd_rawdevice-&gt;mtd_info.erasesize
op_assign
id|erase_size
op_lshift
l_int|10
suffix:semicolon
)brace
r_else
(brace
id|mtd_rawdevice-&gt;mtd_info.type
op_assign
id|MTD_RAM
suffix:semicolon
id|mtd_rawdevice-&gt;mtd_info.flags
op_assign
id|MTD_CAP_RAM
suffix:semicolon
id|mtd_rawdevice-&gt;mtd_info.erasesize
op_assign
id|erase_size
op_lshift
l_int|10
suffix:semicolon
)brace
id|mtd_rawdevice-&gt;mtd_info.size
op_assign
id|size
suffix:semicolon
id|mtd_rawdevice-&gt;mtd_info.erase
op_assign
id|blkmtd_erase
suffix:semicolon
id|mtd_rawdevice-&gt;mtd_info.read
op_assign
id|blkmtd_read
suffix:semicolon
id|mtd_rawdevice-&gt;mtd_info.write
op_assign
id|blkmtd_write
suffix:semicolon
id|mtd_rawdevice-&gt;mtd_info.sync
op_assign
id|blkmtd_sync
suffix:semicolon
id|mtd_rawdevice-&gt;mtd_info.point
op_assign
l_int|0
suffix:semicolon
id|mtd_rawdevice-&gt;mtd_info.unpoint
op_assign
l_int|0
suffix:semicolon
id|mtd_rawdevice-&gt;mtd_info.priv
op_assign
id|mtd_rawdevice
suffix:semicolon
id|regions
op_assign
id|calc_erase_regions
c_func
(paren
l_int|NULL
comma
id|erase_size
op_lshift
l_int|10
comma
id|size
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;blkmtd: init: found %d erase regions&bslash;n&quot;
comma
id|regions
)paren
suffix:semicolon
id|mtd_rawdevice-&gt;mtd_info.eraseregions
op_assign
id|kmalloc
c_func
(paren
id|regions
op_star
r_sizeof
(paren
r_struct
id|mtd_erase_region_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mtd_rawdevice-&gt;mtd_info.eraseregions
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|init_err
suffix:semicolon
)brace
id|mtd_rawdevice-&gt;mtd_info.numeraseregions
op_assign
id|regions
suffix:semicolon
id|calc_erase_regions
c_func
(paren
id|mtd_rawdevice-&gt;mtd_info.eraseregions
comma
id|erase_size
op_lshift
l_int|10
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* setup the page cache info */
id|mtd_rawdevice-&gt;as.nrpages
op_assign
l_int|0
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|mtd_rawdevice-&gt;as.clean_pages
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|mtd_rawdevice-&gt;as.dirty_pages
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|mtd_rawdevice-&gt;as.locked_pages
)paren
suffix:semicolon
id|mtd_rawdevice-&gt;as.host
op_assign
l_int|NULL
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
(paren
id|mtd_rawdevice-&gt;as.i_shared_sem
)paren
)paren
suffix:semicolon
id|mtd_rawdevice-&gt;as.a_ops
op_assign
op_amp
id|blkmtd_aops
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|mtd_rawdevice-&gt;as.i_mmap
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|mtd_rawdevice-&gt;as.i_mmap_shared
)paren
suffix:semicolon
id|mtd_rawdevice-&gt;as.gfp_mask
op_assign
id|GFP_KERNEL
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,2,0)
id|mtd_rawdevice-&gt;mtd_info.module
op_assign
id|THIS_MODULE
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|add_mtd_device
c_func
(paren
op_amp
id|mtd_rawdevice-&gt;mtd_info
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|init_err
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mtd_rawdevice-&gt;readonly
)paren
(brace
multiline_comment|/* Allocate the write queue */
id|write_queue
op_assign
id|kmalloc
c_func
(paren
id|write_queue_sz
op_star
r_sizeof
(paren
id|mtdblkdev_write_queue_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|write_queue
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|init_err
suffix:semicolon
)brace
multiline_comment|/* Set up the erase page */
id|erase_page
op_assign
id|alloc_pages
c_func
(paren
id|GFP_KERNEL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|erase_page
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|init_err
suffix:semicolon
)brace
id|memset
c_func
(paren
id|page_address
c_func
(paren
id|erase_page
)paren
comma
l_int|0xff
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|lock_page
c_func
(paren
id|erase_page
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|thr_wq
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|mtbd_sync_wq
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: init: kernel task @ %p&bslash;n&quot;
comma
id|write_queue_task
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: init: starting kernel task&bslash;n&quot;
)paren
suffix:semicolon
id|kernel_thread
c_func
(paren
id|write_queue_task
comma
l_int|NULL
comma
id|CLONE_FS
op_or
id|CLONE_FILES
op_or
id|CLONE_SIGHAND
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: init: started&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;blkmtd loaded: version = %s using %s erase_size = %dK %s&bslash;n&quot;
comma
id|VERSION
comma
id|device
comma
id|erase_size
comma
(paren
id|readonly
)paren
ques
c_cond
l_string|&quot;(read-only)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef BLKMTD_PROC_DEBUG
multiline_comment|/* create proc entry */
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;Creating /proc/blkmtd_debug&bslash;n&quot;
)paren
suffix:semicolon
id|blkmtd_proc
op_assign
id|create_proc_read_entry
c_func
(paren
l_string|&quot;blkmtd_debug&quot;
comma
l_int|0444
comma
l_int|NULL
comma
id|blkmtd_proc_read
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blkmtd_proc
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Cant create /proc/blkmtd_debug&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|blkmtd_proc-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Everything is ok if we got here */
r_return
l_int|0
suffix:semicolon
id|init_err
suffix:colon
r_if
c_cond
(paren
id|mtd_rawdevice
)paren
(brace
r_if
c_cond
(paren
id|mtd_rawdevice-&gt;mtd_info.eraseregions
)paren
(brace
id|kfree
c_func
(paren
id|mtd_rawdevice-&gt;mtd_info.eraseregions
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mtd_rawdevice-&gt;mtd_info.name
)paren
(brace
id|kfree
c_func
(paren
id|mtd_rawdevice-&gt;mtd_info.name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mtd_rawdevice-&gt;binding
)paren
(brace
id|blkdev_put
c_func
(paren
id|mtd_rawdevice-&gt;binding
comma
id|BDEV_RAW
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|mtd_rawdevice
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|write_queue
)paren
(brace
id|kfree
c_func
(paren
id|write_queue
)paren
suffix:semicolon
id|write_queue
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|erase_page
)paren
(brace
id|__free_pages
c_func
(paren
id|erase_page
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|variable|init_blkmtd
id|module_init
c_func
(paren
id|init_blkmtd
)paren
suffix:semicolon
DECL|variable|cleanup_blkmtd
id|module_exit
c_func
(paren
id|cleanup_blkmtd
)paren
suffix:semicolon
eof
