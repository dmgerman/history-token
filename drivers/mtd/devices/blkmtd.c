multiline_comment|/* &n; * $Id: blkmtd.c,v 1.3 2001/10/02 15:33:20 dwmw2 Exp $&n; * blkmtd.c - use a block device as a fake MTD&n; *&n; * Author: Simon Evans &lt;spse@secret.org.uk&gt;&n; *&n; * Copyright (C) 2001 Simon Evans &lt;spse@secret.org.uk&gt;&n; * &n; * Licence: GPL&n; *&n; * How it works:&n; *       The driver uses raw/io to read/write the device and the page&n; *       cache to cache access. Writes update the page cache with the&n; *       new data but make a copy of the new page(s) and then a kernel&n; *       thread writes pages out to the device in the background. This&n; *       ensures tht writes are order even if a page is updated twice.&n; *       Also, since pages in the page cache are never marked as dirty,&n; *       we dont have to worry about writepage() being called on some &n; *       random page which may not be in the write order.&n; * &n; *       Erases are handled like writes, so the callback is called after&n; *       the page cache has been updated. Sync()ing will wait until it is &n; *       all done.&n; *&n; *       It can be loaded Read-Only to prevent erases and writes to the &n; *       medium.&n; *&n; * Todo:&n; *       Make the write queue size dynamic so this it is not too big on&n; *       small memory systems and too small on large memory systems.&n; * &n; *       Page cache usage may still be a bit wrong. Check we are doing&n; *       everything proberly.&n; * &n; *       Somehow allow writes to dirty the page cache so we dont use too&n; *       much memory making copies of outgoing pages. Need to handle case&n; *       where page x is written to, then page y, then page x again before&n; *       any of them have been committed to disk.&n; * &n; *       Reading should read multiple pages at once rather than using &n; *       readpage() for each one. This is easy and will be fixed asap.&n; *&n; *       Dont run the write_thread if readonly. This is also easy and will&n; *       be fixed asap.&n; * &n; *       Even though the multiple erase regions are used if the default erase&n; *       block size doesnt match the device properly, erases currently wont&n; *       work on the last page if it is not a full page.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/iobuf.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/mtd/compatmac.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
multiline_comment|/* Default erase size in K, always make it a multiple of PAGE_SIZE */
DECL|macro|CONFIG_MTD_BLKDEV_ERASESIZE
mdefine_line|#define CONFIG_MTD_BLKDEV_ERASESIZE 128
DECL|macro|VERSION
mdefine_line|#define VERSION &quot;1.1&quot;
r_extern
r_int
op_star
id|blk_size
(braket
)braket
suffix:semicolon
multiline_comment|/* Info for the block device */
DECL|struct|mtd_raw_dev_data_s
r_typedef
r_struct
id|mtd_raw_dev_data_s
(brace
DECL|member|binding
r_struct
id|block_device
op_star
id|binding
suffix:semicolon
DECL|member|sector_size
DECL|member|sector_bits
DECL|member|total_sectors
r_int
id|sector_size
comma
id|sector_bits
comma
id|total_sectors
suffix:semicolon
DECL|member|totalsize
r_int
id|totalsize
suffix:semicolon
DECL|member|readonly
r_int
id|readonly
suffix:semicolon
DECL|member|as
r_struct
id|address_space
id|as
suffix:semicolon
DECL|member|file
r_struct
id|file
op_star
id|file
suffix:semicolon
DECL|typedef|mtd_raw_dev_data_t
)brace
id|mtd_raw_dev_data_t
suffix:semicolon
multiline_comment|/* Info for each queue item in the write queue */
DECL|struct|mtdblkdev_write_queue_s
r_typedef
r_struct
id|mtdblkdev_write_queue_s
(brace
DECL|member|rawdevice
id|mtd_raw_dev_data_t
op_star
id|rawdevice
suffix:semicolon
DECL|member|pages
r_struct
id|page
op_star
op_star
id|pages
suffix:semicolon
DECL|member|pagenr
r_int
id|pagenr
suffix:semicolon
DECL|member|pagecnt
r_int
id|pagecnt
suffix:semicolon
DECL|member|iserase
r_int
id|iserase
suffix:semicolon
DECL|typedef|mtdblkdev_write_queue_t
)brace
id|mtdblkdev_write_queue_t
suffix:semicolon
multiline_comment|/* Static info about the MTD, used in cleanup_module */
DECL|variable|mtd_info
r_static
r_struct
id|mtd_info
op_star
id|mtd_info
suffix:semicolon
multiline_comment|/* Write queue fixed size */
DECL|macro|WRITE_QUEUE_SZ
mdefine_line|#define WRITE_QUEUE_SZ 512
multiline_comment|/* Storage for the write queue */
DECL|variable|write_queue
r_static
id|mtdblkdev_write_queue_t
id|write_queue
(braket
id|WRITE_QUEUE_SZ
)braket
suffix:semicolon
DECL|variable|write_queue_head
r_static
r_int
r_volatile
id|write_queue_head
suffix:semicolon
DECL|variable|write_queue_tail
r_static
r_int
r_volatile
id|write_queue_tail
suffix:semicolon
DECL|variable|write_queue_cnt
r_static
r_int
r_volatile
id|write_queue_cnt
suffix:semicolon
DECL|variable|mbd_writeq_lock
r_static
id|spinlock_t
id|mbd_writeq_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* Tell the write thread to finish */
DECL|variable|write_task_finish
r_static
r_volatile
r_int
id|write_task_finish
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ipc with the write thread */
macro_line|#if LINUX_VERSION_CODE &gt; 0x020300
r_static
id|DECLARE_MUTEX_LOCKED
c_func
(paren
id|thread_sem
)paren
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|thr_wq
)paren
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|mtbd_sync_wq
)paren
suffix:semicolon
macro_line|#else
DECL|variable|thread_sem
r_static
r_struct
id|semaphore
id|thread_sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
DECL|variable|thr_wq
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|thr_wq
)paren
suffix:semicolon
DECL|variable|mtbd_sync_wq
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|mtbd_sync_wq
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Module parameters passed by insmod/modprobe */
DECL|variable|device
r_char
op_star
id|device
suffix:semicolon
multiline_comment|/* the block device to use */
DECL|variable|erasesz
r_int
id|erasesz
suffix:semicolon
multiline_comment|/* optional default erase size */
DECL|variable|ro
r_int
id|ro
suffix:semicolon
multiline_comment|/* optional read only flag */
DECL|variable|bs
r_int
id|bs
suffix:semicolon
multiline_comment|/* optionally force the block size (avoid using) */
DECL|variable|count
r_int
id|count
suffix:semicolon
multiline_comment|/* optionally force the block count (avoid using) */
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,2,0)
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Simon Evans &lt;spse@secret.org.uk&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Emulate an MTD using a block device&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|device
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|device
comma
l_string|&quot;block device to use&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|erasesz
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|erasesz
comma
l_string|&quot;optional erase size to use in KB. eg 4=4K.&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|ro
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|ro
comma
l_string|&quot;1=Read only, writes and erases cause errors&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|bs
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|bs
comma
l_string|&quot;force the block size in bytes&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|count
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|count
comma
l_string|&quot;force the block count&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Page cache stuff */
multiline_comment|/* writepage() - should never be called - catch it anyway */
DECL|function|blkmtd_writepage
r_static
r_int
id|blkmtd_writepage
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: writepage called!!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* readpage() - reads one page from the block device */
DECL|function|blkmtd_readpage
r_static
r_int
id|blkmtd_readpage
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_int
id|err
suffix:semicolon
r_int
id|sectornr
comma
id|sectors
comma
id|i
suffix:semicolon
r_struct
id|kiobuf
op_star
id|iobuf
suffix:semicolon
id|mtd_raw_dev_data_t
op_star
id|rawdevice
op_assign
(paren
id|mtd_raw_dev_data_t
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rawdevice
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: readpage: PANIC file-&gt;private_data == NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|dev
op_assign
id|to_kdev_t
c_func
(paren
id|rawdevice-&gt;binding-&gt;bd_dev
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: readpage called, dev = `%s&squot; page = %p index = %ld&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|dev
)paren
comma
id|page
comma
id|page-&gt;index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Page_Uptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;blkmtd: readpage page %ld is already upto date&bslash;n&quot;
comma
id|page-&gt;index
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|ClearPageError
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* see if page is in the outgoing write queue */
id|spin_lock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_queue_cnt
)paren
(brace
r_int
id|i
op_assign
id|write_queue_tail
suffix:semicolon
r_while
c_loop
(paren
id|i
op_ne
id|write_queue_head
)paren
(brace
id|mtdblkdev_write_queue_t
op_star
id|item
op_assign
op_amp
id|write_queue
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;index
op_ge
id|item-&gt;pagenr
op_logical_and
id|page-&gt;index
OL
id|item-&gt;pagenr
op_plus
id|item-&gt;pagecnt
)paren
(brace
multiline_comment|/* yes it is */
r_int
id|index
op_assign
id|item-&gt;pagenr
op_minus
id|page-&gt;index
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;blkmtd: readpage: found page %ld in outgoing write queue&bslash;n&quot;
comma
id|page-&gt;index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|item-&gt;iserase
)paren
(brace
id|memset
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
comma
l_int|0xff
comma
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
comma
id|page_address
c_func
(paren
id|item-&gt;pages
(braket
id|index
)braket
)paren
comma
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|i
op_increment
suffix:semicolon
id|i
op_mod_assign
id|WRITE_QUEUE_SZ
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: readpage: getting kiovec&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
id|alloc_kiovec
c_func
(paren
l_int|1
comma
op_amp
id|iobuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
id|iobuf-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|iobuf-&gt;nr_pages
op_assign
l_int|1
suffix:semicolon
id|iobuf-&gt;length
op_assign
id|PAGE_SIZE
suffix:semicolon
id|iobuf-&gt;locked
op_assign
l_int|1
suffix:semicolon
id|iobuf-&gt;maplist
(braket
l_int|0
)braket
op_assign
id|page
suffix:semicolon
id|sectornr
op_assign
id|page-&gt;index
op_lshift
(paren
id|PAGE_SHIFT
op_minus
id|rawdevice-&gt;sector_bits
)paren
suffix:semicolon
id|sectors
op_assign
l_int|1
op_lshift
(paren
id|PAGE_SHIFT
op_minus
id|rawdevice-&gt;sector_bits
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: readpage: sectornr = %d sectors = %d&bslash;n&quot;
comma
id|sectornr
comma
id|sectors
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sectors
suffix:semicolon
id|i
op_increment
)paren
(brace
id|iobuf-&gt;blocks
(braket
id|i
)braket
op_assign
id|sectornr
op_increment
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;bklmtd: readpage: starting brw_kiovec&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
id|brw_kiovec
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
id|iobuf
comma
id|dev
comma
id|iobuf-&gt;blocks
comma
id|rawdevice-&gt;sector_size
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: readpage: finished, err = %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
id|iobuf-&gt;locked
op_assign
l_int|0
suffix:semicolon
id|free_kiovec
c_func
(paren
l_int|1
comma
op_amp
id|iobuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
id|PAGE_SIZE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: readpage: error reading page %ld&bslash;n&quot;
comma
id|page-&gt;index
)paren
suffix:semicolon
id|memset
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: readpage: setting page upto date&bslash;n&quot;
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: readpage: finished, err = %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|blkmtd_aops
r_static
r_struct
id|address_space_operations
id|blkmtd_aops
op_assign
(brace
id|writepage
suffix:colon
id|blkmtd_writepage
comma
id|readpage
suffix:colon
id|blkmtd_readpage
comma
)brace
suffix:semicolon
multiline_comment|/* This is the kernel thread that empties the write queue to disk */
DECL|function|write_queue_task
r_static
r_int
id|write_queue_task
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
r_struct
id|kiobuf
op_star
id|iobuf
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;blkmtd: writetask: starting (pid = %d)&bslash;n&quot;
comma
id|tsk-&gt;pid
)paren
suffix:semicolon
id|daemonize
c_func
(paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|tsk-&gt;comm
comma
l_string|&quot;blkmtdd&quot;
)paren
suffix:semicolon
id|tsk-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|tsk-&gt;sigmask_lock
)paren
suffix:semicolon
id|sigfillset
c_func
(paren
op_amp
id|tsk-&gt;blocked
)paren
suffix:semicolon
id|recalc_sigpending
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|tsk-&gt;sigmask_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|alloc_kiovec
c_func
(paren
l_int|1
comma
op_amp
id|iobuf
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: writetask: entering main loop&bslash;n&quot;
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|thr_wq
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|write_queue_cnt
)paren
(brace
multiline_comment|/* If nothing in the queue, wake up anyone wanting to know when there&n;&t; is space in the queue then sleep for 2*HZ */
id|spin_unlock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: writetask: queue empty&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|mtbd_sync_wq
)paren
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|mtbd_sync_wq
)paren
suffix:semicolon
)brace
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|thr_wq
comma
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: writetask: woken up&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_task_finish
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* we have stuff to write */
id|mtdblkdev_write_queue_t
op_star
id|item
op_assign
op_amp
id|write_queue
(braket
id|write_queue_tail
)braket
suffix:semicolon
r_struct
id|page
op_star
op_star
id|pages
op_assign
id|item-&gt;pages
suffix:semicolon
r_int
id|pagecnt
op_assign
id|item-&gt;pagecnt
suffix:semicolon
r_int
id|pagenr
op_assign
id|item-&gt;pagenr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|max_sectors
op_assign
id|KIO_MAX_SECTORS
op_rshift
(paren
id|item-&gt;rawdevice-&gt;sector_bits
op_minus
l_int|9
)paren
suffix:semicolon
id|kdev_t
id|dev
op_assign
id|to_kdev_t
c_func
(paren
id|item-&gt;rawdevice-&gt;binding-&gt;bd_dev
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: writetask: got %d queue items&bslash;n&quot;
comma
id|write_queue_cnt
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: write_task: writing pagenr = %d pagecnt = %d&quot;
comma
id|item-&gt;pagenr
comma
id|item-&gt;pagecnt
)paren
suffix:semicolon
id|iobuf-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|iobuf-&gt;locked
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Loop through all the pages to be written in the queue item, remembering&n;&t; we can only write KIO_MAX_SECTORS at a time */
r_while
c_loop
(paren
id|pagecnt
)paren
(brace
r_int
id|sectornr
op_assign
id|pagenr
op_lshift
(paren
id|PAGE_SHIFT
op_minus
id|item-&gt;rawdevice-&gt;sector_bits
)paren
suffix:semicolon
r_int
id|sectorcnt
op_assign
id|pagecnt
op_lshift
(paren
id|PAGE_SHIFT
op_minus
id|item-&gt;rawdevice-&gt;sector_bits
)paren
suffix:semicolon
r_int
id|cursectors
op_assign
(paren
id|sectorcnt
OL
id|max_sectors
)paren
ques
c_cond
id|sectorcnt
suffix:colon
id|max_sectors
suffix:semicolon
r_int
id|cpagecnt
op_assign
(paren
id|cursectors
op_lshift
id|item-&gt;rawdevice-&gt;sector_bits
)paren
op_plus
id|PAGE_SIZE
op_minus
l_int|1
suffix:semicolon
id|cpagecnt
op_rshift_assign
id|PAGE_SHIFT
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cpagecnt
suffix:semicolon
id|i
op_increment
)paren
(brace
id|iobuf-&gt;maplist
(braket
id|i
)braket
op_assign
op_star
(paren
id|pages
op_increment
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cursectors
suffix:semicolon
id|i
op_increment
)paren
(brace
id|iobuf-&gt;blocks
(braket
id|i
)braket
op_assign
id|sectornr
op_increment
suffix:semicolon
)brace
id|iobuf-&gt;nr_pages
op_assign
id|cpagecnt
suffix:semicolon
id|iobuf-&gt;length
op_assign
id|cursectors
op_lshift
id|item-&gt;rawdevice-&gt;sector_bits
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: write_task: about to kiovec&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
id|brw_kiovec
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|iobuf
comma
id|dev
comma
id|iobuf-&gt;blocks
comma
id|item-&gt;rawdevice-&gt;sector_size
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;bklmtd: write_task: done, err = %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
(paren
id|cursectors
op_lshift
id|item-&gt;rawdevice-&gt;sector_bits
)paren
)paren
(brace
multiline_comment|/* if an error occured - set this to exit the loop */
id|pagecnt
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|pagenr
op_add_assign
id|cpagecnt
suffix:semicolon
id|pagecnt
op_sub_assign
id|cpagecnt
suffix:semicolon
)brace
)brace
multiline_comment|/* free up the pages used in the write and list of pages used in the write&n;&t; queue item */
id|iobuf-&gt;locked
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
id|write_queue_cnt
op_decrement
suffix:semicolon
id|write_queue_tail
op_increment
suffix:semicolon
id|write_queue_tail
op_mod_assign
id|WRITE_QUEUE_SZ
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|item-&gt;pagecnt
suffix:semicolon
id|i
op_increment
)paren
(brace
id|UnlockPage
c_func
(paren
id|item-&gt;pages
(braket
id|i
)braket
)paren
suffix:semicolon
id|__free_pages
c_func
(paren
id|item-&gt;pages
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|item-&gt;pages
)paren
suffix:semicolon
id|item-&gt;pages
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
multiline_comment|/* Tell others there is some space in the write queue */
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|mtbd_sync_wq
)paren
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|mtbd_sync_wq
)paren
suffix:semicolon
)brace
)brace
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|thr_wq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;blkmtd: writetask: exiting&bslash;n&quot;
)paren
suffix:semicolon
id|free_kiovec
c_func
(paren
l_int|1
comma
op_amp
id|iobuf
)paren
suffix:semicolon
multiline_comment|/* Tell people we have exitd */
id|up
c_func
(paren
op_amp
id|thread_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Add a range of pages into the outgoing write queue, making copies of them */
DECL|function|queue_page_write
r_static
r_int
id|queue_page_write
c_func
(paren
id|mtd_raw_dev_data_t
op_star
id|rawdevice
comma
r_struct
id|page
op_star
op_star
id|pages
comma
r_int
id|pagenr
comma
r_int
id|pagecnt
comma
r_int
id|iserase
)paren
(brace
r_struct
id|page
op_star
id|outpage
suffix:semicolon
r_struct
id|page
op_star
op_star
id|new_pages
suffix:semicolon
id|mtdblkdev_write_queue_t
op_star
id|item
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;mtdblkdev: queue_page_write: adding pagenr = %d pagecnt = %d&bslash;n&quot;
comma
id|pagenr
comma
id|pagecnt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pagecnt
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pages
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* create a array for the list of pages */
id|new_pages
op_assign
id|kmalloc
c_func
(paren
id|pagecnt
op_star
r_sizeof
(paren
r_struct
id|page
op_star
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_pages
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* make copies of the pages in the page cache */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pagecnt
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outpage
op_assign
id|alloc_pages
c_func
(paren
id|GFP_KERNEL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|outpage
)paren
(brace
r_while
c_loop
(paren
id|i
op_decrement
)paren
(brace
id|UnlockPage
c_func
(paren
id|new_pages
(braket
id|i
)braket
)paren
suffix:semicolon
id|__free_pages
c_func
(paren
id|new_pages
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|new_pages
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|lock_page
c_func
(paren
id|outpage
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|page_address
c_func
(paren
id|outpage
)paren
comma
id|page_address
c_func
(paren
id|pages
(braket
id|i
)braket
)paren
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|new_pages
(braket
id|i
)braket
op_assign
id|outpage
suffix:semicolon
)brace
multiline_comment|/* wait until there is some space in the write queue */
id|test_lock
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_queue_cnt
op_eq
id|WRITE_QUEUE_SZ
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: queue_page: Queue full&bslash;n&quot;
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|mtbd_sync_wq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|thr_wq
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|mtbd_sync_wq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: queue_page: Queue has %d items in it&bslash;n&quot;
comma
id|write_queue_cnt
)paren
suffix:semicolon
r_goto
id|test_lock
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: queue_write_page: qhead: %d qtail: %d qcnt: %d&bslash;n&quot;
comma
id|write_queue_head
comma
id|write_queue_tail
comma
id|write_queue_cnt
)paren
suffix:semicolon
multiline_comment|/* fix up the queue item */
id|item
op_assign
op_amp
id|write_queue
(braket
id|write_queue_head
)braket
suffix:semicolon
id|item-&gt;pages
op_assign
id|new_pages
suffix:semicolon
id|item-&gt;pagenr
op_assign
id|pagenr
suffix:semicolon
id|item-&gt;pagecnt
op_assign
id|pagecnt
suffix:semicolon
id|item-&gt;rawdevice
op_assign
id|rawdevice
suffix:semicolon
id|item-&gt;iserase
op_assign
id|iserase
suffix:semicolon
id|write_queue_head
op_increment
suffix:semicolon
id|write_queue_head
op_mod_assign
id|WRITE_QUEUE_SZ
suffix:semicolon
id|write_queue_cnt
op_increment
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: queue_write_page: qhead: %d qtail: %d qcnt: %d&bslash;n&quot;
comma
id|write_queue_head
comma
id|write_queue_tail
comma
id|write_queue_cnt
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: queue_page_write: finished&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* erase a specified part of the device */
DECL|function|blkmtd_erase
r_static
r_int
id|blkmtd_erase
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|erase_info
op_star
id|instr
)paren
(brace
id|mtd_raw_dev_data_t
op_star
id|rawdevice
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_int
id|from
suffix:semicolon
id|u_long
id|len
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* check readonly */
r_if
c_cond
(paren
id|rawdevice-&gt;readonly
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: error: trying to erase readonly device %s&bslash;n&quot;
comma
id|device
)paren
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASE_FAILED
suffix:semicolon
r_goto
id|erase_callback
suffix:semicolon
)brace
id|instr-&gt;state
op_assign
id|MTD_ERASING
suffix:semicolon
id|from
op_assign
id|instr-&gt;addr
suffix:semicolon
id|len
op_assign
id|instr-&gt;len
suffix:semicolon
multiline_comment|/* check page alignment of start and length */
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: erase: dev = `%s&squot; from = %d len = %ld&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rawdevice-&gt;binding-&gt;bd_dev
)paren
comma
id|from
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|from
op_mod
id|PAGE_SIZE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: erase: addr not page aligned (addr = %d)&bslash;n&quot;
comma
id|from
)paren
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASE_FAILED
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
op_mod
id|PAGE_SIZE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: erase: len not a whole number of pages (len = %ld)&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASE_FAILED
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|instr-&gt;state
op_ne
id|MTD_ERASE_FAILED
)paren
(brace
multiline_comment|/* start the erase */
r_int
id|pagenr
comma
id|pagecnt
suffix:semicolon
r_struct
id|page
op_star
id|page
comma
op_star
op_star
id|pages
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|pagenr
op_assign
id|from
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|pagecnt
op_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: erase: pagenr = %d pagecnt = %d&bslash;n&quot;
comma
id|pagenr
comma
id|pagecnt
)paren
suffix:semicolon
id|pages
op_assign
id|kmalloc
c_func
(paren
id|pagecnt
op_star
r_sizeof
(paren
r_struct
id|page
op_star
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pages
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASE_FAILED
suffix:semicolon
r_goto
id|erase_out
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pagecnt
)paren
(brace
multiline_comment|/* get the page via the page cache */
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: erase: doing grap_cache_page() for page %d&bslash;n&quot;
comma
id|pagenr
)paren
suffix:semicolon
id|page
op_assign
id|grab_cache_page
c_func
(paren
op_amp
id|rawdevice-&gt;as
comma
id|pagenr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: erase: grab_cache_page() failed for page %d&bslash;n&quot;
comma
id|pagenr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pages
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASE_FAILED
suffix:semicolon
r_goto
id|erase_out
suffix:semicolon
)brace
id|memset
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
comma
l_int|0xff
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|pages
(braket
id|i
)braket
op_assign
id|page
suffix:semicolon
id|pagecnt
op_decrement
suffix:semicolon
id|pagenr
op_increment
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: erase: queuing page write&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
id|queue_page_write
c_func
(paren
id|rawdevice
comma
id|pages
comma
id|from
op_rshift
id|PAGE_SHIFT
comma
id|len
op_rshift
id|PAGE_SHIFT
comma
l_int|1
)paren
suffix:semicolon
id|pagecnt
op_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
r_while
c_loop
(paren
id|pagecnt
op_decrement
)paren
(brace
id|SetPageUptodate
c_func
(paren
id|pages
(braket
id|pagecnt
)braket
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|pages
(braket
id|pagecnt
)braket
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|pages
(braket
id|pagecnt
)braket
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|pages
(braket
id|pagecnt
)braket
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|pages
)paren
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASE_DONE
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
id|pagecnt
op_decrement
)paren
(brace
id|SetPageError
c_func
(paren
id|pages
(braket
id|pagecnt
)braket
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|pages
(braket
id|pagecnt
)braket
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|pages
)paren
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASE_FAILED
suffix:semicolon
)brace
)brace
id|erase_out
suffix:colon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: erase: checking callback&bslash;n&quot;
)paren
suffix:semicolon
id|erase_callback
suffix:colon
r_if
c_cond
(paren
id|instr-&gt;callback
)paren
(brace
(paren
op_star
(paren
id|instr-&gt;callback
)paren
)paren
(paren
id|instr
)paren
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: erase: finished (err = %d)&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* read a range of the data via the page cache */
DECL|function|blkmtd_read
r_static
r_int
id|blkmtd_read
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
(brace
id|mtd_raw_dev_data_t
op_star
id|rawdevice
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_int
id|pagenr
comma
id|pages
suffix:semicolon
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: read: dev = `%s&squot; from = %ld len = %d buf = %p&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rawdevice-&gt;binding-&gt;bd_dev
)paren
comma
(paren
r_int
r_int
)paren
id|from
comma
id|len
comma
id|buf
)paren
suffix:semicolon
id|pagenr
op_assign
id|from
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|offset
op_assign
id|from
op_minus
(paren
id|pagenr
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|pages
op_assign
(paren
id|offset
op_plus
id|len
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: read: pagenr = %d offset = %d, pages = %d&bslash;n&quot;
comma
id|pagenr
comma
id|offset
comma
id|pages
)paren
suffix:semicolon
multiline_comment|/* just loop through each page, getting it via readpage() - slow but easy */
r_while
c_loop
(paren
id|pages
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|cpylen
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: read: looking for page: %d&bslash;n&quot;
comma
id|pagenr
)paren
suffix:semicolon
id|page
op_assign
id|read_cache_page
c_func
(paren
op_amp
id|rawdevice-&gt;as
comma
id|pagenr
comma
(paren
id|filler_t
op_star
)paren
id|blkmtd_readpage
comma
id|rawdevice-&gt;file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
r_return
id|PTR_ERR
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|wait_on_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|Page_Uptodate
c_func
(paren
id|page
)paren
)paren
(brace
multiline_comment|/* error reading page */
id|printk
c_func
(paren
l_string|&quot;blkmtd: read: page not uptodate&bslash;n&quot;
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|cpylen
op_assign
(paren
id|PAGE_SIZE
OG
id|len
)paren
ques
c_cond
id|len
suffix:colon
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_plus
id|cpylen
OG
id|PAGE_SIZE
)paren
(brace
id|cpylen
op_assign
id|PAGE_SIZE
op_minus
id|offset
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|buf
op_plus
op_star
id|retlen
comma
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|offset
comma
id|cpylen
)paren
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
id|len
op_sub_assign
id|cpylen
suffix:semicolon
op_star
id|retlen
op_add_assign
id|cpylen
suffix:semicolon
id|pagenr
op_increment
suffix:semicolon
id|pages
op_decrement
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: end read: retlen = %d, err = %d&bslash;n&quot;
comma
op_star
id|retlen
comma
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* write a range of the data via the page cache.&n; *&n; * Basic operation. break the write into three parts. &n; *&n; * 1. From a page unaligned start up until the next page boundary&n; * 2. Page sized, page aligned blocks&n; * 3. From end of last aligned block to end of range&n; *&n; * 1,3 are read via the page cache and readpage() since these are partial&n; * pages, 2 we just grab pages from the page cache, not caring if they are&n; * already in memory or not since they will be completly overwritten.&n; *&n; */
DECL|function|blkmtd_write
r_static
r_int
id|blkmtd_write
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
(brace
id|mtd_raw_dev_data_t
op_star
id|rawdevice
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_int
id|pagenr
suffix:semicolon
r_int
id|len1
op_assign
l_int|0
comma
id|len2
op_assign
l_int|0
comma
id|len3
op_assign
l_int|0
suffix:semicolon
r_struct
id|page
op_star
op_star
id|pages
suffix:semicolon
r_int
id|pagecnt
op_assign
l_int|0
suffix:semicolon
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: write: dev = `%s&squot; to = %ld len = %d buf = %p&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rawdevice-&gt;binding-&gt;bd_dev
)paren
comma
(paren
r_int
r_int
)paren
id|to
comma
id|len
comma
id|buf
)paren
suffix:semicolon
multiline_comment|/* handle readonly and out of range numbers */
r_if
c_cond
(paren
id|rawdevice-&gt;readonly
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: error: trying to write to a readonly device %s&bslash;n&quot;
comma
id|device
)paren
suffix:semicolon
r_return
op_minus
id|EROFS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|to
op_ge
id|rawdevice-&gt;totalsize
)paren
(brace
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_if
c_cond
(paren
id|to
op_plus
id|len
OG
id|rawdevice-&gt;totalsize
)paren
(brace
id|len
op_assign
(paren
id|rawdevice-&gt;totalsize
op_minus
id|to
)paren
suffix:semicolon
)brace
id|pagenr
op_assign
id|to
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|offset
op_assign
id|to
op_minus
(paren
id|pagenr
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
multiline_comment|/* see if we have to do a partial write at the start */
r_if
c_cond
(paren
id|offset
)paren
(brace
r_if
c_cond
(paren
(paren
id|offset
op_plus
id|len
)paren
OG
id|PAGE_SIZE
)paren
(brace
id|len1
op_assign
id|PAGE_SIZE
op_minus
id|offset
suffix:semicolon
id|len
op_sub_assign
id|len1
suffix:semicolon
)brace
r_else
(brace
id|len1
op_assign
id|len
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* calculate the length of the other two regions */
id|len3
op_assign
id|len
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
id|len
op_sub_assign
id|len3
suffix:semicolon
id|len2
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|len1
)paren
(brace
id|pagecnt
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len2
)paren
(brace
id|pagecnt
op_add_assign
id|len2
op_rshift
id|PAGE_SHIFT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len3
)paren
(brace
id|pagecnt
op_increment
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: write: len1 = %d len2 = %d len3 = %d pagecnt = %d&bslash;n&quot;
comma
id|len1
comma
id|len2
comma
id|len3
comma
id|pagecnt
)paren
suffix:semicolon
multiline_comment|/* get space for list of pages */
id|pages
op_assign
id|kmalloc
c_func
(paren
id|pagecnt
op_star
r_sizeof
(paren
r_struct
id|page
op_star
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pages
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|pagecnt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|len1
)paren
(brace
multiline_comment|/* do partial start region */
r_struct
id|page
op_star
id|page
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: write: doing partial start, page = %d len = %d offset = %d&bslash;n&quot;
comma
id|pagenr
comma
id|len1
comma
id|offset
)paren
suffix:semicolon
id|page
op_assign
id|read_cache_page
c_func
(paren
op_amp
id|rawdevice-&gt;as
comma
id|pagenr
comma
(paren
id|filler_t
op_star
)paren
id|blkmtd_readpage
comma
id|rawdevice-&gt;file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
id|kfree
c_func
(paren
id|pages
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|offset
comma
id|buf
comma
id|len1
)paren
suffix:semicolon
id|pages
(braket
id|pagecnt
op_increment
)braket
op_assign
id|page
suffix:semicolon
id|buf
op_add_assign
id|len1
suffix:semicolon
op_star
id|retlen
op_assign
id|len1
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|pagenr
op_increment
suffix:semicolon
)brace
multiline_comment|/* Now do the main loop to a page aligned, n page sized output */
r_if
c_cond
(paren
id|len2
)paren
(brace
r_int
id|pagesc
op_assign
id|len2
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: write: whole pages start = %d, count = %d&bslash;n&quot;
comma
id|pagenr
comma
id|pagesc
)paren
suffix:semicolon
r_while
c_loop
(paren
id|pagesc
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
multiline_comment|/* see if page is in the page cache */
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: write: grabbing page %d from page cache&bslash;n&quot;
comma
id|pagenr
)paren
suffix:semicolon
id|page
op_assign
id|grab_cache_page
c_func
(paren
op_amp
id|rawdevice-&gt;as
comma
id|pagenr
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: write: got page %d from page cache&bslash;n&quot;
comma
id|pagenr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: write: cant grab cache page %d&bslash;n&quot;
comma
id|pagenr
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|write_err
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
comma
id|buf
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|pages
(braket
id|pagecnt
op_increment
)braket
op_assign
id|page
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|pagenr
op_increment
suffix:semicolon
id|pagesc
op_decrement
suffix:semicolon
id|buf
op_add_assign
id|PAGE_SIZE
suffix:semicolon
op_star
id|retlen
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|len3
)paren
(brace
multiline_comment|/* do the third region */
r_struct
id|page
op_star
id|page
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: write: doing partial end, page = %d len = %d&bslash;n&quot;
comma
id|pagenr
comma
id|len3
)paren
suffix:semicolon
id|page
op_assign
id|read_cache_page
c_func
(paren
op_amp
id|rawdevice-&gt;as
comma
id|pagenr
comma
(paren
id|filler_t
op_star
)paren
id|blkmtd_readpage
comma
id|rawdevice-&gt;file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|write_err
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
comma
id|buf
comma
id|len3
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: write: writing out partial end&bslash;n&quot;
)paren
suffix:semicolon
id|pages
(braket
id|pagecnt
op_increment
)braket
op_assign
id|page
suffix:semicolon
op_star
id|retlen
op_add_assign
id|len3
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: write: end, retlen = %d, err = %d&bslash;n&quot;
comma
op_star
id|retlen
comma
id|err
)paren
suffix:semicolon
multiline_comment|/* submit it to the write task */
id|err
op_assign
id|queue_page_write
c_func
(paren
id|rawdevice
comma
id|pages
comma
id|to
op_rshift
id|PAGE_SHIFT
comma
id|pagecnt
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
r_while
c_loop
(paren
id|pagecnt
op_decrement
)paren
(brace
id|SetPageUptodate
c_func
(paren
id|pages
(braket
id|pagecnt
)braket
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|pages
(braket
id|pagecnt
)braket
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|pages
(braket
id|pagecnt
)braket
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|pages
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|write_err
suffix:colon
r_while
c_loop
(paren
op_decrement
id|pagecnt
)paren
(brace
id|SetPageError
c_func
(paren
id|pages
(braket
id|pagecnt
)braket
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|pages
(braket
id|pagecnt
)braket
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|pages
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* sync the device - wait until the write queue is empty */
DECL|function|blkmtd_sync
r_static
r_void
id|blkmtd_sync
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: sync: called&bslash;n&quot;
)paren
suffix:semicolon
id|stuff_inq
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_queue_cnt
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|mtbd_sync_wq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: sync: waking up task&bslash;n&quot;
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|thr_wq
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|mtbd_sync_wq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: sync: waking up after write task&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|stuff_inq
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|mbd_writeq_lock
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtdL sync: finished&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Cleanup and exit - sync the device and kill of the kernel thread */
DECL|function|cleanup_blkmtd
r_static
r_void
id|__exit
id|cleanup_blkmtd
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|mtd_info
)paren
(brace
id|mtd_raw_dev_data_t
op_star
id|rawdevice
op_assign
id|mtd_info-&gt;priv
suffix:semicolon
singleline_comment|// sync the device
r_if
c_cond
(paren
id|rawdevice
)paren
(brace
id|blkmtd_sync
c_func
(paren
id|mtd_info
)paren
suffix:semicolon
id|write_task_finish
op_assign
l_int|1
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|thr_wq
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|thread_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rawdevice-&gt;binding
op_ne
l_int|NULL
)paren
(brace
id|blkdev_put
c_func
(paren
id|rawdevice-&gt;binding
comma
id|BDEV_RAW
)paren
suffix:semicolon
)brace
id|filp_close
c_func
(paren
id|rawdevice-&gt;file
comma
l_int|NULL
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mtd_info-&gt;priv
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mtd_info-&gt;eraseregions
)paren
(brace
id|kfree
c_func
(paren
id|mtd_info-&gt;eraseregions
)paren
suffix:semicolon
)brace
id|del_mtd_device
c_func
(paren
id|mtd_info
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mtd_info
)paren
suffix:semicolon
id|mtd_info
op_assign
l_int|NULL
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: unloaded for %s&bslash;n&quot;
comma
id|device
)paren
suffix:semicolon
)brace
r_extern
r_struct
id|module
id|__this_module
suffix:semicolon
multiline_comment|/* for a given size and initial erase size, calculate the number and size of each&n;   erase region */
DECL|function|calc_erase_regions
r_static
r_int
id|__init
id|calc_erase_regions
c_func
(paren
r_struct
id|mtd_erase_region_info
op_star
id|info
comma
r_int
id|erase_size
comma
r_int
id|total_size
)paren
(brace
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
id|offset
op_assign
l_int|0
suffix:semicolon
r_int
id|regions
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|total_size
)paren
(brace
id|count
op_assign
id|total_size
op_div
id|erase_size
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
id|total_size
op_assign
id|total_size
op_mod
id|erase_size
suffix:semicolon
r_if
c_cond
(paren
id|info
)paren
(brace
id|info-&gt;offset
op_assign
id|offset
suffix:semicolon
id|info-&gt;erasesize
op_assign
id|erase_size
suffix:semicolon
id|info-&gt;numblocks
op_assign
id|count
suffix:semicolon
id|info
op_increment
suffix:semicolon
)brace
id|offset
op_add_assign
(paren
id|count
op_star
id|erase_size
)paren
suffix:semicolon
id|regions
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|erase_size
OG
id|total_size
)paren
(brace
id|erase_size
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|regions
suffix:semicolon
)brace
multiline_comment|/* Startup */
DECL|function|init_blkmtd
r_static
r_int
id|__init
id|init_blkmtd
c_func
(paren
r_void
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|mtd_raw_dev_data_t
op_star
id|rawdevice
op_assign
l_int|NULL
suffix:semicolon
r_int
id|maj
comma
id|min
suffix:semicolon
r_int
id|i
comma
id|blocksize
comma
id|blocksize_bits
suffix:semicolon
id|loff_t
id|size
op_assign
l_int|0
suffix:semicolon
r_int
id|readonly
op_assign
l_int|0
suffix:semicolon
r_int
id|erase_size
op_assign
id|CONFIG_MTD_BLKDEV_ERASESIZE
suffix:semicolon
id|kdev_t
id|rdev
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
id|mode
suffix:semicolon
r_int
id|totalsize
op_assign
l_int|0
comma
id|total_sectors
op_assign
l_int|0
suffix:semicolon
r_int
id|regions
suffix:semicolon
id|mtd_info
op_assign
l_int|NULL
suffix:semicolon
singleline_comment|// Check args
r_if
c_cond
(paren
id|device
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: error, missing `device&squot; name&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ro
)paren
(brace
id|readonly
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|erasesz
)paren
(brace
id|erase_size
op_assign
id|erasesz
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;blkmtd: got device = `%s&squot; erase size = %dK readonly = %s&bslash;n&quot;
comma
id|device
comma
id|erase_size
comma
id|readonly
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
singleline_comment|// Get a handle on the device
id|mode
op_assign
(paren
id|readonly
)paren
ques
c_cond
id|O_RDONLY
suffix:colon
id|O_RDWR
suffix:semicolon
id|file
op_assign
id|filp_open
c_func
(paren
id|device
comma
id|mode
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|file
)paren
)paren
(brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: open_namei returned %ld&bslash;n&quot;
comma
id|PTR_ERR
c_func
(paren
id|file
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* determine is this is a block device and if so get its major and minor&n;     numbers */
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: %s not a block device&bslash;n&quot;
comma
id|device
)paren
suffix:semicolon
id|filp_close
c_func
(paren
id|file
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|rdev
op_assign
id|inode-&gt;i_rdev
suffix:semicolon
singleline_comment|//filp_close(file, NULL);
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;blkmtd: found a block device major = %d, minor = %d&bslash;n&quot;
comma
id|MAJOR
c_func
(paren
id|rdev
)paren
comma
id|MINOR
c_func
(paren
id|rdev
)paren
)paren
suffix:semicolon
id|maj
op_assign
id|MAJOR
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|min
op_assign
id|MINOR
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maj
op_eq
id|MTD_BLOCK_MAJOR
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: attempting to use an MTD device as a block device&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;blkmtd: devname = %s&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|rdev
)paren
)paren
suffix:semicolon
id|blocksize
op_assign
id|BLOCK_SIZE
suffix:semicolon
id|blocksize
op_assign
id|bs
ques
c_cond
id|bs
suffix:colon
id|block_size
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|i
op_assign
id|blocksize
suffix:semicolon
id|blocksize_bits
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|i
op_ne
l_int|1
)paren
(brace
id|blocksize_bits
op_increment
suffix:semicolon
id|i
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
)paren
(brace
id|size
op_assign
id|count
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|blk_size
(braket
id|maj
)braket
)paren
(brace
id|size
op_assign
(paren
(paren
id|loff_t
)paren
id|blk_size
(braket
id|maj
)braket
(braket
id|min
)braket
op_lshift
id|BLOCK_SIZE_BITS
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
)brace
)brace
id|total_sectors
op_assign
id|size
suffix:semicolon
id|size
op_mul_assign
id|blocksize
suffix:semicolon
id|totalsize
op_assign
id|size
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;blkmtd: size = %ld&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;blkmtd: cant determine size&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|rawdevice
op_assign
(paren
id|mtd_raw_dev_data_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|mtd_raw_dev_data_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rawdevice
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|init_err
suffix:semicolon
)brace
id|memset
c_func
(paren
id|rawdevice
comma
l_int|0
comma
r_sizeof
(paren
id|mtd_raw_dev_data_t
)paren
)paren
suffix:semicolon
singleline_comment|// get the block device
id|rawdevice-&gt;binding
op_assign
id|bdget
c_func
(paren
id|kdev_t_to_nr
c_func
(paren
id|MKDEV
c_func
(paren
id|maj
comma
id|min
)paren
)paren
)paren
suffix:semicolon
id|err
op_assign
id|blkdev_get
c_func
(paren
id|rawdevice-&gt;binding
comma
id|mode
comma
l_int|0
comma
id|BDEV_RAW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_goto
id|init_err
suffix:semicolon
)brace
id|rawdevice-&gt;totalsize
op_assign
id|totalsize
suffix:semicolon
id|rawdevice-&gt;total_sectors
op_assign
id|total_sectors
suffix:semicolon
id|rawdevice-&gt;sector_size
op_assign
id|blocksize
suffix:semicolon
id|rawdevice-&gt;sector_bits
op_assign
id|blocksize_bits
suffix:semicolon
id|rawdevice-&gt;readonly
op_assign
id|readonly
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;sector_size = %d, sector_bits = %d&bslash;n&quot;
comma
id|rawdevice-&gt;sector_size
comma
id|rawdevice-&gt;sector_bits
)paren
suffix:semicolon
id|mtd_info
op_assign
(paren
r_struct
id|mtd_info
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|mtd_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mtd_info
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|init_err
suffix:semicolon
)brace
id|memset
c_func
(paren
id|mtd_info
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|mtd_info
)paren
)paren
suffix:semicolon
singleline_comment|// Setup the MTD structure
id|mtd_info-&gt;name
op_assign
l_string|&quot;blkmtd block device&quot;
suffix:semicolon
r_if
c_cond
(paren
id|readonly
)paren
(brace
id|mtd_info-&gt;type
op_assign
id|MTD_ROM
suffix:semicolon
id|mtd_info-&gt;flags
op_assign
id|MTD_CAP_ROM
suffix:semicolon
id|mtd_info-&gt;erasesize
op_assign
id|erase_size
op_lshift
l_int|10
suffix:semicolon
)brace
r_else
(brace
id|mtd_info-&gt;type
op_assign
id|MTD_RAM
suffix:semicolon
id|mtd_info-&gt;flags
op_assign
id|MTD_CAP_RAM
suffix:semicolon
id|mtd_info-&gt;erasesize
op_assign
id|erase_size
op_lshift
l_int|10
suffix:semicolon
)brace
id|mtd_info-&gt;size
op_assign
id|size
suffix:semicolon
id|mtd_info-&gt;erase
op_assign
id|blkmtd_erase
suffix:semicolon
id|mtd_info-&gt;read
op_assign
id|blkmtd_read
suffix:semicolon
id|mtd_info-&gt;write
op_assign
id|blkmtd_write
suffix:semicolon
id|mtd_info-&gt;sync
op_assign
id|blkmtd_sync
suffix:semicolon
id|mtd_info-&gt;point
op_assign
l_int|0
suffix:semicolon
id|mtd_info-&gt;unpoint
op_assign
l_int|0
suffix:semicolon
id|mtd_info-&gt;priv
op_assign
id|rawdevice
suffix:semicolon
id|regions
op_assign
id|calc_erase_regions
c_func
(paren
l_int|NULL
comma
id|erase_size
op_lshift
l_int|10
comma
id|size
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;blkmtd: init: found %d erase regions&bslash;n&quot;
comma
id|regions
)paren
suffix:semicolon
id|mtd_info-&gt;eraseregions
op_assign
id|kmalloc
c_func
(paren
id|regions
op_star
r_sizeof
(paren
r_struct
id|mtd_erase_region_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mtd_info-&gt;eraseregions
op_eq
l_int|NULL
)paren
(brace
)brace
id|mtd_info-&gt;numeraseregions
op_assign
id|regions
suffix:semicolon
id|calc_erase_regions
c_func
(paren
id|mtd_info-&gt;eraseregions
comma
id|erase_size
op_lshift
l_int|10
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* setup the page cache info */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|rawdevice-&gt;as.clean_pages
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|rawdevice-&gt;as.dirty_pages
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|rawdevice-&gt;as.locked_pages
)paren
suffix:semicolon
id|rawdevice-&gt;as.nrpages
op_assign
l_int|0
suffix:semicolon
id|rawdevice-&gt;as.a_ops
op_assign
op_amp
id|blkmtd_aops
suffix:semicolon
id|rawdevice-&gt;as.host
op_assign
id|inode
suffix:semicolon
id|rawdevice-&gt;as.i_mmap
op_assign
l_int|NULL
suffix:semicolon
id|rawdevice-&gt;as.i_mmap_shared
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|rawdevice-&gt;as.i_shared_lock
)paren
suffix:semicolon
id|rawdevice-&gt;as.gfp_mask
op_assign
id|GFP_KERNEL
suffix:semicolon
id|rawdevice-&gt;file
op_assign
id|file
suffix:semicolon
id|file-&gt;private_data
op_assign
id|rawdevice
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,2,0)
id|mtd_info-&gt;module
op_assign
id|THIS_MODULE
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|add_mtd_device
c_func
(paren
id|mtd_info
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|init_err
suffix:semicolon
)brace
id|init_waitqueue_head
c_func
(paren
op_amp
id|thr_wq
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|mtbd_sync_wq
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: init: kernel task @ %p&bslash;n&quot;
comma
id|write_queue_task
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: init: starting kernel task&bslash;n&quot;
)paren
suffix:semicolon
id|kernel_thread
c_func
(paren
id|write_queue_task
comma
l_int|NULL
comma
id|CLONE_FS
op_or
id|CLONE_FILES
op_or
id|CLONE_SIGHAND
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: init: started&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;blkmtd loaded: version = %s using %s erase_size = %dK %s&bslash;n&quot;
comma
id|VERSION
comma
id|device
comma
id|erase_size
comma
(paren
id|readonly
)paren
ques
c_cond
l_string|&quot;(read-only)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|init_err
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|rawdevice
)paren
(brace
r_if
c_cond
(paren
id|rawdevice-&gt;binding
)paren
(brace
id|blkdev_put
c_func
(paren
id|rawdevice-&gt;binding
comma
id|BDEV_RAW
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|rawdevice
)paren
suffix:semicolon
id|rawdevice
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mtd_info
)paren
(brace
r_if
c_cond
(paren
id|mtd_info-&gt;eraseregions
)paren
(brace
id|kfree
c_func
(paren
id|mtd_info-&gt;eraseregions
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|mtd_info
)paren
suffix:semicolon
id|mtd_info
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|variable|init_blkmtd
id|module_init
c_func
(paren
id|init_blkmtd
)paren
suffix:semicolon
DECL|variable|cleanup_blkmtd
id|module_exit
c_func
(paren
id|cleanup_blkmtd
)paren
suffix:semicolon
eof
