multiline_comment|/*&n; * $Id: blkmtd.c,v 1.24 2004/11/16 18:29:01 dwmw2 Exp $&n; *&n; * blkmtd.c - use a block device as a fake MTD&n; *&n; * Author: Simon Evans &lt;spse@secret.org.uk&gt;&n; *&n; * Copyright (C) 2001,2002 Simon Evans&n; *&n; * Licence: GPL&n; *&n; * How it works:&n; *&t;The driver uses raw/io to read/write the device and the page&n; *&t;cache to cache access. Writes update the page cache with the&n; *&t;new data and mark it dirty and add the page into a BIO which&n; *&t;is then written out.&n; *&n; *&t;It can be loaded Read-Only to prevent erases and writes to the&n; *&t;medium.&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
DECL|macro|err
mdefine_line|#define err(format, arg...) printk(KERN_ERR &quot;blkmtd: &quot; format &quot;&bslash;n&quot; , ## arg)
DECL|macro|info
mdefine_line|#define info(format, arg...) printk(KERN_INFO &quot;blkmtd: &quot; format &quot;&bslash;n&quot; , ## arg)
DECL|macro|warn
mdefine_line|#define warn(format, arg...) printk(KERN_WARNING &quot;blkmtd: &quot; format &quot;&bslash;n&quot; , ## arg)
DECL|macro|crit
mdefine_line|#define crit(format, arg...) printk(KERN_CRIT &quot;blkmtd: &quot; format &quot;&bslash;n&quot; , ## arg)
multiline_comment|/* Default erase size in K, always make it a multiple of PAGE_SIZE */
DECL|macro|CONFIG_MTD_BLKDEV_ERASESIZE
mdefine_line|#define CONFIG_MTD_BLKDEV_ERASESIZE (128 &lt;&lt; 10)&t;/* 128KiB */
DECL|macro|VERSION
mdefine_line|#define VERSION &quot;$Revision: 1.24 $&quot;
multiline_comment|/* Info for the block device */
DECL|struct|blkmtd_dev
r_struct
id|blkmtd_dev
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|blkdev
r_struct
id|block_device
op_star
id|blkdev
suffix:semicolon
DECL|member|mtd_info
r_struct
id|mtd_info
id|mtd_info
suffix:semicolon
DECL|member|wrbuf_mutex
r_struct
id|semaphore
id|wrbuf_mutex
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Static info about the MTD, used in cleanup_module */
r_static
id|LIST_HEAD
c_func
(paren
id|blkmtd_device_list
)paren
suffix:semicolon
r_static
r_void
id|blkmtd_sync
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
suffix:semicolon
DECL|macro|MAX_DEVICES
mdefine_line|#define MAX_DEVICES 4
multiline_comment|/* Module parameters passed by insmod/modprobe */
DECL|variable|device
r_static
r_char
op_star
id|device
(braket
id|MAX_DEVICES
)braket
suffix:semicolon
multiline_comment|/* the block device to use */
DECL|variable|erasesz
r_static
r_int
id|erasesz
(braket
id|MAX_DEVICES
)braket
suffix:semicolon
multiline_comment|/* optional default erase size */
DECL|variable|ro
r_static
r_int
id|ro
(braket
id|MAX_DEVICES
)braket
suffix:semicolon
multiline_comment|/* optional read only flag */
DECL|variable|sync
r_static
r_int
id|sync
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Simon Evans &lt;spse@secret.org.uk&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Emulate an MTD using a block device&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|device
comma
l_string|&quot;1-4s&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|device
comma
l_string|&quot;block device to use&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|erasesz
comma
l_string|&quot;1-4i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|erasesz
comma
l_string|&quot;optional erase size to use in KiB. eg 4=4KiB.&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|ro
comma
l_string|&quot;1-4i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|ro
comma
l_string|&quot;1=Read only, writes and erases cause errors&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|sync
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|sync
comma
l_string|&quot;1=Synchronous writes&quot;
)paren
suffix:semicolon
multiline_comment|/* completion handler for BIO reads */
DECL|function|bi_read_complete
r_static
r_int
id|bi_read_complete
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|bytes_done
comma
r_int
id|error
)paren
(brace
r_if
c_cond
(paren
id|bio-&gt;bi_size
)paren
r_return
l_int|1
suffix:semicolon
id|complete
c_func
(paren
(paren
r_struct
id|completion
op_star
)paren
id|bio-&gt;bi_private
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* completion handler for BIO writes */
DECL|function|bi_write_complete
r_static
r_int
id|bi_write_complete
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|bytes_done
comma
r_int
id|error
)paren
(brace
r_const
r_int
id|uptodate
op_assign
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
suffix:semicolon
r_struct
id|bio_vec
op_star
id|bvec
op_assign
id|bio-&gt;bi_io_vec
op_plus
id|bio-&gt;bi_vcnt
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_size
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
(brace
id|err
c_func
(paren
l_string|&quot;bi_write_complete: not uptodate&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_do
(brace
r_struct
id|page
op_star
id|page
op_assign
id|bvec-&gt;bv_page
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;Cleaning up page %ld&bslash;n&quot;
comma
id|page-&gt;index
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|bvec
op_ge
id|bio-&gt;bi_io_vec
)paren
id|prefetchw
c_func
(paren
op_amp
id|bvec-&gt;bv_page-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uptodate
)paren
(brace
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|ClearPageDirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bvec
op_ge
id|bio-&gt;bi_io_vec
)paren
suffix:semicolon
id|complete
c_func
(paren
(paren
r_struct
id|completion
op_star
)paren
id|bio-&gt;bi_private
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* read one page from the block device */
DECL|function|blkmtd_readpage
r_static
r_int
id|blkmtd_readpage
c_func
(paren
r_struct
id|blkmtd_dev
op_star
id|dev
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_struct
id|completion
id|event
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: readpage page %ld is already upto date&bslash;n&quot;
comma
id|page-&gt;index
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|ClearPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|GFP_KERNEL
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bio
)paren
(brace
id|init_completion
c_func
(paren
op_amp
id|event
)paren
suffix:semicolon
id|bio-&gt;bi_bdev
op_assign
id|dev-&gt;blkdev
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|page-&gt;index
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|9
)paren
suffix:semicolon
id|bio-&gt;bi_private
op_assign
op_amp
id|event
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
id|bi_read_complete
suffix:semicolon
r_if
c_cond
(paren
id|bio_add_page
c_func
(paren
id|bio
comma
id|page
comma
id|PAGE_SIZE
comma
l_int|0
)paren
op_eq
id|PAGE_SIZE
)paren
(brace
id|submit_bio
c_func
(paren
id|READ_SYNC
comma
id|bio
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|event
)paren
suffix:semicolon
id|err
op_assign
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
suffix:semicolon
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|err
)paren
(brace
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* write out the current BIO and wait for it to finish */
DECL|function|blkmtd_write_out
r_static
r_int
id|blkmtd_write_out
c_func
(paren
r_struct
id|bio
op_star
id|bio
)paren
(brace
r_struct
id|completion
id|event
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bio-&gt;bi_vcnt
)paren
(brace
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|init_completion
c_func
(paren
op_amp
id|event
)paren
suffix:semicolon
id|bio-&gt;bi_private
op_assign
op_amp
id|event
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
id|bi_write_complete
suffix:semicolon
id|submit_bio
c_func
(paren
id|WRITE_SYNC
comma
id|bio
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|event
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;submit_bio completed, bi_vcnt = %d&bslash;n&quot;
comma
id|bio-&gt;bi_vcnt
)paren
suffix:semicolon
id|err
op_assign
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
suffix:semicolon
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * blkmtd_add_page - add a page to the current BIO&n; * @bio: bio to add to (NULL to alloc initial bio)&n; * @blkdev: block device&n; * @page: page to add&n; * @pagecnt: pages left to add&n; *&n; * Adds a page to the current bio, allocating it if necessary. If it cannot be&n; * added, the current bio is written out and a new one is allocated. Returns&n; * the new bio to add or NULL on error&n; */
DECL|function|blkmtd_add_page
r_static
r_struct
id|bio
op_star
id|blkmtd_add_page
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_struct
id|block_device
op_star
id|blkdev
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|pagecnt
)paren
(brace
id|retry
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|bio
)paren
(brace
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|GFP_KERNEL
comma
id|pagecnt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bio
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|bio-&gt;bi_sector
op_assign
id|page-&gt;index
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|9
)paren
suffix:semicolon
id|bio-&gt;bi_bdev
op_assign
id|blkdev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bio_add_page
c_func
(paren
id|bio
comma
id|page
comma
id|PAGE_SIZE
comma
l_int|0
)paren
op_ne
id|PAGE_SIZE
)paren
(brace
id|blkmtd_write_out
c_func
(paren
id|bio
)paren
suffix:semicolon
id|bio
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
r_return
id|bio
suffix:semicolon
)brace
multiline_comment|/**&n; * write_pages - write block of data to device via the page cache&n; * @dev: device to write to&n; * @buf: data source or NULL if erase (output is set to 0xff)&n; * @to: offset into output device&n; * @len: amount to data to write&n; * @retlen: amount of data written&n; *&n; * Grab pages from the page cache and fill them with the source data.&n; * Non page aligned start and end result in a readin of the page and&n; * part of the page being modified. Pages are added to the bio and then written&n; * out.&n; */
DECL|function|write_pages
r_static
r_int
id|write_pages
c_func
(paren
r_struct
id|blkmtd_dev
op_star
id|dev
comma
r_const
id|u_char
op_star
id|buf
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
)paren
(brace
r_int
id|pagenr
comma
id|offset
suffix:semicolon
r_int
id|start_len
op_assign
l_int|0
comma
id|end_len
suffix:semicolon
r_int
id|pagecnt
op_assign
l_int|0
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|bio
op_star
id|bio
op_assign
l_int|NULL
suffix:semicolon
r_int
id|thislen
op_assign
l_int|0
suffix:semicolon
id|pagenr
op_assign
id|to
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|offset
op_assign
id|to
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: write_pages: buf = %p to = %ld len = %zd pagenr = %d offset = %d&bslash;n&quot;
comma
id|buf
comma
(paren
r_int
)paren
id|to
comma
id|len
comma
id|pagenr
comma
id|offset
)paren
suffix:semicolon
multiline_comment|/* see if we have to do a partial write at the start */
r_if
c_cond
(paren
id|offset
)paren
(brace
id|start_len
op_assign
(paren
(paren
id|offset
op_plus
id|len
)paren
OG
id|PAGE_SIZE
)paren
ques
c_cond
id|PAGE_SIZE
op_minus
id|offset
suffix:colon
id|len
suffix:semicolon
id|len
op_sub_assign
id|start_len
suffix:semicolon
)brace
multiline_comment|/* calculate the length of the other two regions */
id|end_len
op_assign
id|len
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
id|len
op_sub_assign
id|end_len
suffix:semicolon
r_if
c_cond
(paren
id|start_len
)paren
(brace
id|pagecnt
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
)paren
(brace
id|pagecnt
op_add_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|end_len
)paren
(brace
id|pagecnt
op_increment
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|dev-&gt;wrbuf_mutex
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: write: start_len = %zd len = %zd end_len = %zd pagecnt = %d&bslash;n&quot;
comma
id|start_len
comma
id|len
comma
id|end_len
comma
id|pagecnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start_len
)paren
(brace
multiline_comment|/* do partial start region */
r_struct
id|page
op_star
id|page
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: write: doing partial start, page = %d len = %zd offset = %d&bslash;n&quot;
comma
id|pagenr
comma
id|start_len
comma
id|offset
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|buf
)paren
suffix:semicolon
id|page
op_assign
id|read_cache_page
c_func
(paren
id|dev-&gt;blkdev-&gt;bd_inode-&gt;i_mapping
comma
id|pagenr
comma
(paren
id|filler_t
op_star
)paren
id|blkmtd_readpage
comma
id|dev
)paren
suffix:semicolon
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageDirty
c_func
(paren
id|page
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;to = %lld start_len = %zd len = %zd end_len = %zd pagenr = %d&bslash;n&quot;
comma
id|to
comma
id|start_len
comma
id|len
comma
id|end_len
comma
id|pagenr
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|offset
comma
id|buf
comma
id|start_len
)paren
suffix:semicolon
id|SetPageDirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|buf
op_add_assign
id|start_len
suffix:semicolon
id|thislen
op_assign
id|start_len
suffix:semicolon
id|bio
op_assign
id|blkmtd_add_page
c_func
(paren
id|bio
comma
id|dev-&gt;blkdev
comma
id|page
comma
id|pagecnt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bio
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|err
c_func
(paren
l_string|&quot;bio_add_page failed&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|write_err
suffix:semicolon
)brace
id|pagecnt
op_decrement
suffix:semicolon
id|pagenr
op_increment
suffix:semicolon
)brace
multiline_comment|/* Now do the main loop to a page aligned, n page sized output */
r_if
c_cond
(paren
id|len
)paren
(brace
r_int
id|pagesc
op_assign
id|len
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: write: whole pages start = %d, count = %d&bslash;n&quot;
comma
id|pagenr
comma
id|pagesc
)paren
suffix:semicolon
r_while
c_loop
(paren
id|pagesc
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
multiline_comment|/* see if page is in the page cache */
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: write: grabbing page %d from page cache&bslash;n&quot;
comma
id|pagenr
)paren
suffix:semicolon
id|page
op_assign
id|grab_cache_page
c_func
(paren
id|dev-&gt;blkdev-&gt;bd_inode-&gt;i_mapping
comma
id|pagenr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageDirty
c_func
(paren
id|page
)paren
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
id|warn
c_func
(paren
l_string|&quot;write: cannot grab cache page %d&quot;
comma
id|pagenr
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|write_err
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
id|memset
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
comma
l_int|0xff
comma
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
comma
id|buf
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|buf
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|bio
op_assign
id|blkmtd_add_page
c_func
(paren
id|bio
comma
id|dev-&gt;blkdev
comma
id|page
comma
id|pagecnt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bio
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|err
c_func
(paren
l_string|&quot;bio_add_page failed&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|write_err
suffix:semicolon
)brace
id|pagenr
op_increment
suffix:semicolon
id|pagecnt
op_decrement
suffix:semicolon
id|SetPageDirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|pagesc
op_decrement
suffix:semicolon
id|thislen
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|end_len
)paren
(brace
multiline_comment|/* do the third region */
r_struct
id|page
op_star
id|page
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: write: doing partial end, page = %d len = %zd&bslash;n&quot;
comma
id|pagenr
comma
id|end_len
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|buf
)paren
suffix:semicolon
id|page
op_assign
id|read_cache_page
c_func
(paren
id|dev-&gt;blkdev-&gt;bd_inode-&gt;i_mapping
comma
id|pagenr
comma
(paren
id|filler_t
op_star
)paren
id|blkmtd_readpage
comma
id|dev
)paren
suffix:semicolon
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageDirty
c_func
(paren
id|page
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;to = %lld start_len = %zd len = %zd end_len = %zd pagenr = %d&bslash;n&quot;
comma
id|to
comma
id|start_len
comma
id|len
comma
id|end_len
comma
id|pagenr
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
comma
id|buf
comma
id|end_len
)paren
suffix:semicolon
id|SetPageDirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: write: writing out partial end&bslash;n&quot;
)paren
suffix:semicolon
id|thislen
op_add_assign
id|end_len
suffix:semicolon
id|bio
op_assign
id|blkmtd_add_page
c_func
(paren
id|bio
comma
id|dev-&gt;blkdev
comma
id|page
comma
id|pagecnt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bio
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|err
c_func
(paren
l_string|&quot;bio_add_page failed&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|write_err
suffix:semicolon
)brace
id|pagenr
op_increment
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: write: got %d vectors to write&bslash;n&quot;
comma
id|bio-&gt;bi_vcnt
)paren
suffix:semicolon
id|write_err
suffix:colon
r_if
c_cond
(paren
id|bio
)paren
(brace
id|blkmtd_write_out
c_func
(paren
id|bio
)paren
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: write: end, retlen = %zd, err = %d&bslash;n&quot;
comma
op_star
id|retlen
comma
id|err
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|dev-&gt;wrbuf_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retlen
)paren
(brace
op_star
id|retlen
op_assign
id|thislen
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* erase a specified part of the device */
DECL|function|blkmtd_erase
r_static
r_int
id|blkmtd_erase
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|erase_info
op_star
id|instr
)paren
(brace
r_struct
id|blkmtd_dev
op_star
id|dev
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|mtd_erase_region_info
op_star
id|einfo
op_assign
id|mtd-&gt;eraseregions
suffix:semicolon
r_int
id|numregions
op_assign
id|mtd-&gt;numeraseregions
suffix:semicolon
r_int
id|from
suffix:semicolon
id|u_long
id|len
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_int
id|retlen
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASING
suffix:semicolon
id|from
op_assign
id|instr-&gt;addr
suffix:semicolon
id|len
op_assign
id|instr-&gt;len
suffix:semicolon
multiline_comment|/* check erase region has valid start and length */
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: erase: dev = `%s&squot; from = 0x%zx len = 0x%lx&bslash;n&quot;
comma
id|mtd-&gt;name
op_plus
l_int|9
comma
id|from
comma
id|len
)paren
suffix:semicolon
r_while
c_loop
(paren
id|numregions
)paren
(brace
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: checking erase region = 0x%08X size = 0x%X num = 0x%x&bslash;n&quot;
comma
id|einfo-&gt;offset
comma
id|einfo-&gt;erasesize
comma
id|einfo-&gt;numblocks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|from
op_ge
id|einfo-&gt;offset
op_logical_and
id|from
OL
id|einfo-&gt;offset
op_plus
(paren
id|einfo-&gt;erasesize
op_star
id|einfo-&gt;numblocks
)paren
)paren
(brace
r_if
c_cond
(paren
id|len
op_eq
id|einfo-&gt;erasesize
op_logical_and
(paren
(paren
id|from
op_minus
id|einfo-&gt;offset
)paren
op_mod
id|einfo-&gt;erasesize
op_eq
l_int|0
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|numregions
op_decrement
suffix:semicolon
id|einfo
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|numregions
)paren
(brace
multiline_comment|/* Not a valid erase block */
id|err
c_func
(paren
l_string|&quot;erase: invalid erase request 0x%lX @ 0x%08zX&quot;
comma
id|len
comma
id|from
)paren
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASE_FAILED
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|instr-&gt;state
op_ne
id|MTD_ERASE_FAILED
)paren
(brace
multiline_comment|/* do the erase */
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;Doing erase from = %zd len = %ld&bslash;n&quot;
comma
id|from
comma
id|len
)paren
suffix:semicolon
id|err
op_assign
id|write_pages
c_func
(paren
id|dev
comma
l_int|NULL
comma
id|from
comma
id|len
comma
op_amp
id|retlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_logical_or
id|retlen
op_ne
id|len
)paren
(brace
id|err
c_func
(paren
l_string|&quot;erase failed err = %d&quot;
comma
id|err
)paren
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASE_FAILED
suffix:semicolon
)brace
r_else
(brace
id|instr-&gt;state
op_assign
id|MTD_ERASE_DONE
suffix:semicolon
)brace
)brace
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: erase: checking callback&bslash;n&quot;
)paren
suffix:semicolon
id|mtd_erase_callback
c_func
(paren
id|instr
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: erase: finished (err = %d)&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* read a range of the data via the page cache */
DECL|function|blkmtd_read
r_static
r_int
id|blkmtd_read
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
(brace
r_struct
id|blkmtd_dev
op_star
id|dev
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_int
id|pagenr
comma
id|pages
suffix:semicolon
r_int
id|thislen
op_assign
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: read: dev = `%s&squot; from = %lld len = %zd buf = %p&bslash;n&quot;
comma
id|mtd-&gt;name
op_plus
l_int|9
comma
id|from
comma
id|len
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|from
OG
id|mtd-&gt;size
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|from
op_plus
id|len
OG
id|mtd-&gt;size
)paren
(brace
id|len
op_assign
id|mtd-&gt;size
op_minus
id|from
suffix:semicolon
)brace
id|pagenr
op_assign
id|from
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|offset
op_assign
id|from
op_minus
(paren
id|pagenr
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|pages
op_assign
(paren
id|offset
op_plus
id|len
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: read: pagenr = %d offset = %d, pages = %d&bslash;n&quot;
comma
id|pagenr
comma
id|offset
comma
id|pages
)paren
suffix:semicolon
r_while
c_loop
(paren
id|pages
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|cpylen
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;blkmtd: read: looking for page: %d&bslash;n&quot;
comma
id|pagenr
)paren
suffix:semicolon
id|page
op_assign
id|read_cache_page
c_func
(paren
id|dev-&gt;blkdev-&gt;bd_inode-&gt;i_mapping
comma
id|pagenr
comma
(paren
id|filler_t
op_star
)paren
id|blkmtd_readpage
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|readerr
suffix:semicolon
)brace
id|cpylen
op_assign
(paren
id|PAGE_SIZE
OG
id|len
)paren
ques
c_cond
id|len
suffix:colon
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_plus
id|cpylen
OG
id|PAGE_SIZE
)paren
(brace
id|cpylen
op_assign
id|PAGE_SIZE
op_minus
id|offset
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|buf
op_plus
id|thislen
comma
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|offset
comma
id|cpylen
)paren
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
id|len
op_sub_assign
id|cpylen
suffix:semicolon
id|thislen
op_add_assign
id|cpylen
suffix:semicolon
id|pagenr
op_increment
suffix:semicolon
id|pages
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageDirty
c_func
(paren
id|page
)paren
)paren
(brace
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
id|readerr
suffix:colon
r_if
c_cond
(paren
id|retlen
)paren
(brace
op_star
id|retlen
op_assign
id|thislen
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: end read: retlen = %zd, err = %d&bslash;n&quot;
comma
id|thislen
comma
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* write data to the underlying device */
DECL|function|blkmtd_write
r_static
r_int
id|blkmtd_write
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
(brace
r_struct
id|blkmtd_dev
op_star
id|dev
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: write: dev = `%s&squot; to = %lld len = %zd buf = %p&bslash;n&quot;
comma
id|mtd-&gt;name
op_plus
l_int|9
comma
id|to
comma
id|len
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|to
op_ge
id|mtd-&gt;size
)paren
(brace
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_if
c_cond
(paren
id|to
op_plus
id|len
OG
id|mtd-&gt;size
)paren
(brace
id|len
op_assign
id|mtd-&gt;size
op_minus
id|to
suffix:semicolon
)brace
id|err
op_assign
id|write_pages
c_func
(paren
id|dev
comma
id|buf
comma
id|to
comma
id|len
comma
id|retlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OG
l_int|0
)paren
(brace
id|err
op_assign
l_int|0
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: write: end, err = %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* sync the device - wait until the write queue is empty */
DECL|function|blkmtd_sync
r_static
r_void
id|blkmtd_sync
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
multiline_comment|/* Currently all writes are synchronous */
)brace
DECL|function|free_device
r_static
r_void
id|free_device
c_func
(paren
r_struct
id|blkmtd_dev
op_star
id|dev
)paren
(brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: free_device() dev = %p&bslash;n&quot;
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;mtd_info.eraseregions
)paren
(brace
id|kfree
c_func
(paren
id|dev-&gt;mtd_info.eraseregions
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;mtd_info.name
)paren
(brace
id|kfree
c_func
(paren
id|dev-&gt;mtd_info.name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;blkdev
)paren
(brace
id|invalidate_inode_pages
c_func
(paren
id|dev-&gt;blkdev-&gt;bd_inode-&gt;i_mapping
)paren
suffix:semicolon
id|close_bdev_excl
c_func
(paren
id|dev-&gt;blkdev
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* For a given size and initial erase size, calculate the number&n; * and size of each erase region. Goes round the loop twice,&n; * once to find out how many regions, then allocates space,&n; * then round the loop again to fill it in.&n; */
DECL|function|calc_erase_regions
r_static
r_struct
id|mtd_erase_region_info
op_star
id|calc_erase_regions
c_func
(paren
r_int
id|erase_size
comma
r_int
id|total_size
comma
r_int
op_star
id|regions
)paren
(brace
r_struct
id|mtd_erase_region_info
op_star
id|info
op_assign
l_int|NULL
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;calc_erase_regions, es = %zd size = %zd regions = %d&bslash;n&quot;
comma
id|erase_size
comma
id|total_size
comma
op_star
id|regions
)paren
suffix:semicolon
multiline_comment|/* Make any user specified erasesize be a power of 2&n;&t;   and at least PAGE_SIZE */
r_if
c_cond
(paren
id|erase_size
)paren
(brace
r_int
id|es
op_assign
id|erase_size
suffix:semicolon
id|erase_size
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|es
op_ne
l_int|1
)paren
(brace
id|es
op_rshift_assign
l_int|1
suffix:semicolon
id|erase_size
op_lshift_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|erase_size
OL
id|PAGE_SIZE
)paren
(brace
id|erase_size
op_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
r_else
(brace
id|erase_size
op_assign
id|CONFIG_MTD_BLKDEV_ERASESIZE
suffix:semicolon
)brace
op_star
id|regions
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_int
id|tot_size
op_assign
id|total_size
suffix:semicolon
r_int
id|er_size
op_assign
id|erase_size
suffix:semicolon
r_int
id|count
op_assign
l_int|0
comma
id|offset
op_assign
l_int|0
comma
id|regcnt
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|tot_size
)paren
(brace
id|count
op_assign
id|tot_size
op_div
id|er_size
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
id|tot_size
op_assign
id|tot_size
op_mod
id|er_size
suffix:semicolon
r_if
c_cond
(paren
id|info
)paren
(brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;adding to erase info off=%d er=%d cnt=%d&bslash;n&quot;
comma
id|offset
comma
id|er_size
comma
id|count
)paren
suffix:semicolon
(paren
id|info
op_plus
id|regcnt
)paren
op_member_access_from_pointer
id|offset
op_assign
id|offset
suffix:semicolon
(paren
id|info
op_plus
id|regcnt
)paren
op_member_access_from_pointer
id|erasesize
op_assign
id|er_size
suffix:semicolon
(paren
id|info
op_plus
id|regcnt
)paren
op_member_access_from_pointer
id|numblocks
op_assign
id|count
suffix:semicolon
(paren
op_star
id|regions
)paren
op_increment
suffix:semicolon
)brace
id|regcnt
op_increment
suffix:semicolon
id|offset
op_add_assign
(paren
id|count
op_star
id|er_size
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|er_size
OG
id|tot_size
)paren
(brace
id|er_size
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|info
op_eq
l_int|NULL
)paren
(brace
id|info
op_assign
id|kmalloc
c_func
(paren
id|regcnt
op_star
r_sizeof
(paren
r_struct
id|mtd_erase_region_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
op_star
id|regions
)paren
)paren
(brace
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;calc_erase_regions done, es = %zd size = %zd regions = %d&bslash;n&quot;
comma
id|erase_size
comma
id|total_size
comma
op_star
id|regions
)paren
suffix:semicolon
r_return
id|info
suffix:semicolon
)brace
r_extern
id|dev_t
id|__init
id|name_to_dev_t
c_func
(paren
r_const
r_char
op_star
id|line
)paren
suffix:semicolon
DECL|function|add_device
r_static
r_struct
id|blkmtd_dev
op_star
id|add_device
c_func
(paren
r_char
op_star
id|devname
comma
r_int
id|readonly
comma
r_int
id|erase_size
)paren
(brace
r_struct
id|block_device
op_star
id|bdev
suffix:semicolon
r_int
id|mode
suffix:semicolon
r_struct
id|blkmtd_dev
op_star
id|dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devname
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Get a handle on the device */
macro_line|#ifdef MODULE
id|mode
op_assign
(paren
id|readonly
)paren
ques
c_cond
id|O_RDONLY
suffix:colon
id|O_RDWR
suffix:semicolon
id|bdev
op_assign
id|open_bdev_excl
c_func
(paren
id|devname
comma
id|mode
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#else
id|mode
op_assign
(paren
id|readonly
)paren
ques
c_cond
id|FMODE_READ
suffix:colon
id|FMODE_WRITE
suffix:semicolon
id|bdev
op_assign
id|open_by_devnum
c_func
(paren
id|name_to_dev_t
c_func
(paren
id|devname
)paren
comma
id|mode
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|bdev
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;error: cannot open device %s&quot;
comma
id|devname
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: opening bdev returned %ld&bslash;n&quot;
comma
id|PTR_ERR
c_func
(paren
id|bdev
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;blkmtd: found a block device major = %d, minor = %d&bslash;n&quot;
comma
id|MAJOR
c_func
(paren
id|bdev-&gt;bd_dev
)paren
comma
id|MINOR
c_func
(paren
id|bdev-&gt;bd_dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|bdev-&gt;bd_dev
)paren
op_eq
id|MTD_BLOCK_MAJOR
)paren
(brace
id|err
c_func
(paren
l_string|&quot;attempting to use an MTD device as a block device&quot;
)paren
suffix:semicolon
id|blkdev_put
c_func
(paren
id|bdev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|blkmtd_dev
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|blkdev_put
c_func
(paren
id|bdev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|blkmtd_dev
)paren
)paren
suffix:semicolon
id|dev-&gt;blkdev
op_assign
id|bdev
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|dev-&gt;blkdev-&gt;bd_inode-&gt;i_mapping-&gt;truncate_count
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|readonly
)paren
(brace
id|init_MUTEX
c_func
(paren
op_amp
id|dev-&gt;wrbuf_mutex
)paren
suffix:semicolon
)brace
id|dev-&gt;mtd_info.size
op_assign
id|dev-&gt;blkdev-&gt;bd_inode-&gt;i_size
op_amp
id|PAGE_MASK
suffix:semicolon
multiline_comment|/* Setup the MTD structure */
multiline_comment|/* make the name contain the block device in */
id|dev-&gt;mtd_info.name
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
l_string|&quot;blkmtd: &quot;
)paren
op_plus
id|strlen
c_func
(paren
id|devname
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;mtd_info.name
op_eq
l_int|NULL
)paren
(brace
r_goto
id|devinit_err
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|dev-&gt;mtd_info.name
comma
l_string|&quot;blkmtd: %s&quot;
comma
id|devname
)paren
suffix:semicolon
id|dev-&gt;mtd_info.eraseregions
op_assign
id|calc_erase_regions
c_func
(paren
id|erase_size
comma
id|dev-&gt;mtd_info.size
comma
op_amp
id|dev-&gt;mtd_info.numeraseregions
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;mtd_info.eraseregions
op_eq
l_int|NULL
)paren
(brace
r_goto
id|devinit_err
suffix:semicolon
)brace
id|dev-&gt;mtd_info.erasesize
op_assign
id|dev-&gt;mtd_info.eraseregions-&gt;erasesize
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;blkmtd: init: found %d erase regions&bslash;n&quot;
comma
id|dev-&gt;mtd_info.numeraseregions
)paren
suffix:semicolon
r_if
c_cond
(paren
id|readonly
)paren
(brace
id|dev-&gt;mtd_info.type
op_assign
id|MTD_ROM
suffix:semicolon
id|dev-&gt;mtd_info.flags
op_assign
id|MTD_CAP_ROM
suffix:semicolon
)brace
r_else
(brace
id|dev-&gt;mtd_info.type
op_assign
id|MTD_RAM
suffix:semicolon
id|dev-&gt;mtd_info.flags
op_assign
id|MTD_CAP_RAM
suffix:semicolon
id|dev-&gt;mtd_info.erase
op_assign
id|blkmtd_erase
suffix:semicolon
id|dev-&gt;mtd_info.write
op_assign
id|blkmtd_write
suffix:semicolon
id|dev-&gt;mtd_info.writev
op_assign
id|default_mtd_writev
suffix:semicolon
id|dev-&gt;mtd_info.sync
op_assign
id|blkmtd_sync
suffix:semicolon
)brace
id|dev-&gt;mtd_info.read
op_assign
id|blkmtd_read
suffix:semicolon
id|dev-&gt;mtd_info.readv
op_assign
id|default_mtd_readv
suffix:semicolon
id|dev-&gt;mtd_info.priv
op_assign
id|dev
suffix:semicolon
id|dev-&gt;mtd_info.owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|dev-&gt;list
comma
op_amp
id|blkmtd_device_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|add_mtd_device
c_func
(paren
op_amp
id|dev-&gt;mtd_info
)paren
)paren
(brace
multiline_comment|/* Device didnt get added, so free the entry */
id|list_del
c_func
(paren
op_amp
id|dev-&gt;list
)paren
suffix:semicolon
r_goto
id|devinit_err
suffix:semicolon
)brace
r_else
(brace
id|info
c_func
(paren
l_string|&quot;mtd%d: [%s] erase_size = %dKiB %s&quot;
comma
id|dev-&gt;mtd_info.index
comma
id|dev-&gt;mtd_info.name
op_plus
id|strlen
c_func
(paren
l_string|&quot;blkmtd: &quot;
)paren
comma
id|dev-&gt;mtd_info.erasesize
op_rshift
l_int|10
comma
id|readonly
ques
c_cond
l_string|&quot;(read-only)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
r_return
id|dev
suffix:semicolon
id|devinit_err
suffix:colon
id|free_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Cleanup and exit - sync the device and kill of the kernel thread */
DECL|function|cleanup_blkmtd
r_static
r_void
id|__devexit
id|cleanup_blkmtd
c_func
(paren
r_void
)paren
(brace
r_struct
id|list_head
op_star
id|temp1
comma
op_star
id|temp2
suffix:semicolon
multiline_comment|/* Remove the MTD devices */
id|list_for_each_safe
c_func
(paren
id|temp1
comma
id|temp2
comma
op_amp
id|blkmtd_device_list
)paren
(brace
r_struct
id|blkmtd_dev
op_star
id|dev
op_assign
id|list_entry
c_func
(paren
id|temp1
comma
r_struct
id|blkmtd_dev
comma
id|list
)paren
suffix:semicolon
id|blkmtd_sync
c_func
(paren
op_amp
id|dev-&gt;mtd_info
)paren
suffix:semicolon
id|del_mtd_device
c_func
(paren
op_amp
id|dev-&gt;mtd_info
)paren
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;mtd%d: [%s] removed&quot;
comma
id|dev-&gt;mtd_info.index
comma
id|dev-&gt;mtd_info.name
op_plus
id|strlen
c_func
(paren
l_string|&quot;blkmtd: &quot;
)paren
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|dev-&gt;list
)paren
suffix:semicolon
id|free_device
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifndef MODULE
multiline_comment|/* Handle kernel boot params */
DECL|function|param_blkmtd_device
r_static
r_int
id|__init
id|param_blkmtd_device
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_DEVICES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|device
(braket
id|i
)braket
op_assign
id|str
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: device setup: %d = %s&bslash;n&quot;
comma
id|i
comma
id|device
(braket
id|i
)braket
)paren
suffix:semicolon
id|strsep
c_func
(paren
op_amp
id|str
comma
l_string|&quot;,&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|param_blkmtd_erasesz
r_static
r_int
id|__init
id|param_blkmtd_erasesz
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_DEVICES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
op_star
id|val
op_assign
id|strsep
c_func
(paren
op_amp
id|str
comma
l_string|&quot;,&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
)paren
(brace
id|erasesz
(braket
id|i
)braket
op_assign
id|simple_strtoul
c_func
(paren
id|val
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: erasesz setup: %d = %d&bslash;n&quot;
comma
id|i
comma
id|erasesz
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|param_blkmtd_ro
r_static
r_int
id|__init
id|param_blkmtd_ro
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_DEVICES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
op_star
id|val
op_assign
id|strsep
c_func
(paren
op_amp
id|str
comma
l_string|&quot;,&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
)paren
(brace
id|ro
(braket
id|i
)braket
op_assign
id|simple_strtoul
c_func
(paren
id|val
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;blkmtd: ro setup: %d = %d&bslash;n&quot;
comma
id|i
comma
id|ro
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|param_blkmtd_sync
r_static
r_int
id|__init
id|param_blkmtd_sync
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_if
c_cond
(paren
id|str
(braket
l_int|0
)braket
op_eq
l_char|&squot;1&squot;
)paren
(brace
id|sync
op_assign
l_int|1
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;blkmtd_device=&quot;
comma
id|param_blkmtd_device
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;blkmtd_erasesz=&quot;
comma
id|param_blkmtd_erasesz
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;blkmtd_ro=&quot;
comma
id|param_blkmtd_ro
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;blkmtd_sync=&quot;
comma
id|param_blkmtd_sync
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Startup */
DECL|function|init_blkmtd
r_static
r_int
id|__init
id|init_blkmtd
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;version &quot;
id|VERSION
)paren
suffix:semicolon
multiline_comment|/* Check args - device[0] is the bare minimum*/
r_if
c_cond
(paren
op_logical_neg
id|device
(braket
l_int|0
)braket
)paren
(brace
id|err
c_func
(paren
l_string|&quot;error: missing `device&squot; name&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_DEVICES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|add_device
c_func
(paren
id|device
(braket
id|i
)braket
comma
id|ro
(braket
id|i
)braket
comma
id|erasesz
(braket
id|i
)braket
op_lshift
l_int|10
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|blkmtd_device_list
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|init_blkmtd
id|module_init
c_func
(paren
id|init_blkmtd
)paren
suffix:semicolon
DECL|variable|cleanup_blkmtd
id|module_exit
c_func
(paren
id|cleanup_blkmtd
)paren
suffix:semicolon
eof
