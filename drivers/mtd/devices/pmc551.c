multiline_comment|/*&n; * $Id: pmc551.c,v 1.19 2001/10/02 15:05:13 dwmw2 Exp $&n; *&n; * PMC551 PCI Mezzanine Ram Device&n; *&n; * Author:&n; *       Mark Ferrell &lt;mferrell@mvista.com&gt;&n; *       Copyright 1999,2000 Nortel Networks&n; *&n; * License:&n; *&t; As part of this driver was derived from the slram.c driver it&n; *&t; falls under the same license, which is GNU General Public&n; *&t; License v2&n; *&n; * Description:&n; *&t; This driver is intended to support the PMC551 PCI Ram device&n; *&t; from Ramix Inc.  The PMC551 is a PMC Mezzanine module for&n; *&t; cPCI embedded systems.  The device contains a single SROM&n; *&t; that initially programs the V370PDC chipset onboard the&n; *&t; device, and various banks of DRAM/SDRAM onboard.  This driver&n; *&t; implements this PCI Ram device as an MTD (Memory Technology&n; *&t; Device) so that it can be used to hold a file system, or for&n; *&t; added swap space in embedded systems.  Since the memory on&n; *&t; this board isn&squot;t as fast as main memory we do not try to hook&n; *&t; it into main memory as that would simply reduce performance&n; *&t; on the system.  Using it as a block device allows us to use&n; *&t; it as high speed swap or for a high speed disk device of some&n; *&t; sort.  Which becomes very useful on diskless systems in the&n; *&t; embedded market I might add.&n; *&t; &n; * Notes:&n; *&t; Due to what I assume is more buggy SROM, the 64M PMC551 I&n; *&t; have available claims that all 4 of its DRAM banks have 64M&n; *&t; of ram configured (making a grand total of 256M onboard).&n; *&t; This is slightly annoying since the BAR0 size reflects the&n; *&t; aperture size, not the dram size, and the V370PDC supplies no&n; *&t; other method for memory size discovery.  This problem is&n; *&t; mostly only relevant when compiled as a module, as the&n; *&t; unloading of the module with an aperture size smaller then&n; *&t; the ram will cause the driver to detect the onboard memory&n; *&t; size to be equal to the aperture size when the module is&n; *&t; reloaded.  Soooo, to help, the module supports an msize&n; *&t; option to allow the specification of the onboard memory, and&n; *&t; an asize option, to allow the specification of the aperture&n; *&t; size.  The aperture must be equal to or less then the memory&n; *&t; size, the driver will correct this if you screw it up.  This&n; *&t; problem is not relevant for compiled in drivers as compiled&n; *&t; in drivers only init once.&n; *&n; * Credits:&n; *       Saeed Karamooz &lt;saeed@ramix.com&gt; of Ramix INC. for the&n; *       initial example code of how to initialize this device and for&n; *       help with questions I had concerning operation of the device.&n; *&n; *       Most of the MTD code for this driver was originally written&n; *       for the slram.o module in the MTD drivers package which&n; *       allows the mapping of system memory into an MTD device.&n; *       Since the PMC551 memory module is accessed in the same&n; *       fashion as system memory, the slram.c code became a very nice&n; *       fit to the needs of this driver.  All we added was PCI&n; *       detection/initialization to the driver and automatically figure&n; *       out the size via the PCI detection.o, later changes by Corey&n; *       Minyard set up the card to utilize a 1M sliding apature.&n; *&n; *&t; Corey Minyard &lt;minyard@nortelnetworks.com&gt;&n; *       * Modified driver to utilize a sliding aperture instead of &n; *         mapping all memory into kernel space which turned out to&n; *         be very wasteful.&n; *       * Located a bug in the SROM&squot;s initialization sequence that &n; *         made the memory unusable, added a fix to code to touch up&n; *         the DRAM some.&n; *&n; * Bugs/FIXME&squot;s:&n; *       * MUST fix the init function to not spin on a register&n; *       waiting for it to set .. this does not safely handle busted&n; *       devices that never reset the register correctly which will&n; *       cause the system to hang w/ a reboot being the only chance at&n; *       recover. [sort of fixed, could be better]&n; *       * Add I2C handling of the SROM so we can read the SROM&squot;s information&n; *       about the aperture size.  This should always accurately reflect the&n; *       onboard memory size.&n; *       * Comb the init routine.  It&squot;s still a bit cludgy on a few things.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/ioctl.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#ifndef CONFIG_PCI
macro_line|#error Enable PCI in your kernel config
macro_line|#endif
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/mtd/pmc551.h&gt;
macro_line|#include &lt;linux/mtd/compatmac.h&gt;
macro_line|#if LINUX_VERSION_CODE &gt; 0x20300
DECL|macro|PCI_BASE_ADDRESS
mdefine_line|#define PCI_BASE_ADDRESS(dev) (dev-&gt;resource[0].start)
macro_line|#else
DECL|macro|PCI_BASE_ADDRESS
mdefine_line|#define PCI_BASE_ADDRESS(dev) (dev-&gt;base_address[0])
macro_line|#endif
DECL|variable|pmc551list
r_static
r_struct
id|mtd_info
op_star
id|pmc551list
suffix:semicolon
DECL|function|pmc551_erase
r_static
r_int
id|pmc551_erase
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|erase_info
op_star
id|instr
)paren
(brace
r_struct
id|mypriv
op_star
id|priv
op_assign
(paren
r_struct
id|mypriv
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
id|u32
id|soff_hi
comma
id|soff_lo
suffix:semicolon
multiline_comment|/* start address offset hi/lo */
id|u32
id|eoff_hi
comma
id|eoff_lo
suffix:semicolon
multiline_comment|/* end address offset hi/lo */
r_int
r_int
id|end
suffix:semicolon
id|u_char
op_star
id|ptr
suffix:semicolon
r_int
id|retlen
suffix:semicolon
macro_line|#ifdef CONFIG_MTD_PMC551_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551_erase(pos:%ld, len:%ld)&bslash;n&quot;
comma
(paren
r_int
)paren
id|instr-&gt;addr
comma
(paren
r_int
)paren
id|instr-&gt;len
)paren
suffix:semicolon
macro_line|#endif
id|end
op_assign
id|instr-&gt;addr
op_plus
id|instr-&gt;len
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Is it past the end? */
r_if
c_cond
(paren
id|end
OG
id|mtd-&gt;size
)paren
(brace
macro_line|#ifdef CONFIG_MTD_PMC551_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551_erase() out of bounds (%ld &gt; %ld)&bslash;n&quot;
comma
(paren
r_int
)paren
id|end
comma
(paren
r_int
)paren
id|mtd-&gt;size
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|eoff_hi
op_assign
id|end
op_amp
op_complement
(paren
id|priv-&gt;asize
op_minus
l_int|1
)paren
suffix:semicolon
id|soff_hi
op_assign
id|instr-&gt;addr
op_amp
op_complement
(paren
id|priv-&gt;asize
op_minus
l_int|1
)paren
suffix:semicolon
id|eoff_lo
op_assign
id|end
op_amp
(paren
id|priv-&gt;asize
op_minus
l_int|1
)paren
suffix:semicolon
id|soff_lo
op_assign
id|instr-&gt;addr
op_amp
(paren
id|priv-&gt;asize
op_minus
l_int|1
)paren
suffix:semicolon
id|pmc551_point
(paren
id|mtd
comma
id|instr-&gt;addr
comma
id|instr-&gt;len
comma
op_amp
id|retlen
comma
op_amp
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|soff_hi
op_eq
id|eoff_hi
op_logical_or
id|mtd-&gt;size
op_eq
id|priv-&gt;asize
)paren
(brace
multiline_comment|/* The whole thing fits within one access, so just one shot&n;                   will do it. */
id|memset
c_func
(paren
id|ptr
comma
l_int|0xff
comma
id|instr-&gt;len
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We have to do multiple writes to get all the data&n;                   written. */
r_while
c_loop
(paren
id|soff_hi
op_ne
id|eoff_hi
)paren
(brace
macro_line|#ifdef CONFIG_MTD_PMC551_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551_erase() soff_hi: %ld, eoff_hi: %ld&bslash;n&quot;
comma
(paren
r_int
)paren
id|soff_hi
comma
(paren
r_int
)paren
id|eoff_hi
)paren
suffix:semicolon
macro_line|#endif
id|memset
c_func
(paren
id|ptr
comma
l_int|0xff
comma
id|priv-&gt;asize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|soff_hi
op_plus
id|priv-&gt;asize
op_ge
id|mtd-&gt;size
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|soff_hi
op_add_assign
id|priv-&gt;asize
suffix:semicolon
id|pmc551_point
(paren
id|mtd
comma
(paren
id|priv-&gt;base_map0
op_or
id|soff_hi
)paren
comma
id|priv-&gt;asize
comma
op_amp
id|retlen
comma
op_amp
id|ptr
)paren
suffix:semicolon
)brace
id|memset
(paren
id|ptr
comma
l_int|0xff
comma
id|eoff_lo
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|instr-&gt;state
op_assign
id|MTD_ERASE_DONE
suffix:semicolon
macro_line|#ifdef CONFIG_MTD_PMC551_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551_erase() done&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|instr-&gt;callback
)paren
(brace
(paren
op_star
(paren
id|instr-&gt;callback
)paren
)paren
(paren
id|instr
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pmc551_point
r_static
r_int
id|pmc551_point
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
op_star
id|mtdbuf
)paren
(brace
r_struct
id|mypriv
op_star
id|priv
op_assign
(paren
r_struct
id|mypriv
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
id|u32
id|soff_hi
suffix:semicolon
id|u32
id|soff_lo
suffix:semicolon
macro_line|#ifdef CONFIG_MTD_PMC551_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551_point(%ld, %ld)&bslash;n&quot;
comma
(paren
r_int
)paren
id|from
comma
(paren
r_int
)paren
id|len
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|from
op_plus
id|len
OG
id|mtd-&gt;size
)paren
(brace
macro_line|#ifdef CONFIG_MTD_PMC551_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551_point() out of bounds (%ld &gt; %ld)&bslash;n&quot;
comma
(paren
r_int
)paren
id|from
op_plus
id|len
comma
(paren
r_int
)paren
id|mtd-&gt;size
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|soff_hi
op_assign
id|from
op_amp
op_complement
(paren
id|priv-&gt;asize
op_minus
l_int|1
)paren
suffix:semicolon
id|soff_lo
op_assign
id|from
op_amp
(paren
id|priv-&gt;asize
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Cheap hack optimization */
r_if
c_cond
(paren
id|priv-&gt;curr_map0
op_ne
id|from
)paren
(brace
id|pci_write_config_dword
(paren
id|priv-&gt;dev
comma
id|PMC551_PCI_MEM_MAP0
comma
(paren
id|priv-&gt;base_map0
op_or
id|soff_hi
)paren
)paren
suffix:semicolon
id|priv-&gt;curr_map0
op_assign
id|soff_hi
suffix:semicolon
)brace
op_star
id|mtdbuf
op_assign
id|priv-&gt;start
op_plus
id|soff_lo
suffix:semicolon
op_star
id|retlen
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pmc551_unpoint
r_static
r_void
id|pmc551_unpoint
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u_char
op_star
id|addr
)paren
(brace
macro_line|#ifdef CONFIG_MTD_PMC551_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551_unpoint()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|pmc551_read
r_static
r_int
id|pmc551_read
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
(brace
r_struct
id|mypriv
op_star
id|priv
op_assign
(paren
r_struct
id|mypriv
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
id|u32
id|soff_hi
comma
id|soff_lo
suffix:semicolon
multiline_comment|/* start address offset hi/lo */
id|u32
id|eoff_hi
comma
id|eoff_lo
suffix:semicolon
multiline_comment|/* end address offset hi/lo */
r_int
r_int
id|end
suffix:semicolon
id|u_char
op_star
id|ptr
suffix:semicolon
id|u_char
op_star
id|copyto
op_assign
id|buf
suffix:semicolon
macro_line|#ifdef CONFIG_MTD_PMC551_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551_read(pos:%ld, len:%ld) asize: %ld&bslash;n&quot;
comma
(paren
r_int
)paren
id|from
comma
(paren
r_int
)paren
id|len
comma
(paren
r_int
)paren
id|priv-&gt;asize
)paren
suffix:semicolon
macro_line|#endif
id|end
op_assign
id|from
op_plus
id|len
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Is it past the end? */
r_if
c_cond
(paren
id|end
OG
id|mtd-&gt;size
)paren
(brace
macro_line|#ifdef CONFIG_MTD_PMC551_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551_read() out of bounds (%ld &gt; %ld)&bslash;n&quot;
comma
(paren
r_int
)paren
id|end
comma
(paren
r_int
)paren
id|mtd-&gt;size
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|soff_hi
op_assign
id|from
op_amp
op_complement
(paren
id|priv-&gt;asize
op_minus
l_int|1
)paren
suffix:semicolon
id|eoff_hi
op_assign
id|end
op_amp
op_complement
(paren
id|priv-&gt;asize
op_minus
l_int|1
)paren
suffix:semicolon
id|soff_lo
op_assign
id|from
op_amp
(paren
id|priv-&gt;asize
op_minus
l_int|1
)paren
suffix:semicolon
id|eoff_lo
op_assign
id|end
op_amp
(paren
id|priv-&gt;asize
op_minus
l_int|1
)paren
suffix:semicolon
id|pmc551_point
(paren
id|mtd
comma
id|from
comma
id|len
comma
id|retlen
comma
op_amp
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|soff_hi
op_eq
id|eoff_hi
)paren
(brace
multiline_comment|/* The whole thing fits within one access, so just one shot&n;                   will do it. */
id|memcpy
c_func
(paren
id|copyto
comma
id|ptr
comma
id|len
)paren
suffix:semicolon
id|copyto
op_add_assign
id|len
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We have to do multiple writes to get all the data&n;                   written. */
r_while
c_loop
(paren
id|soff_hi
op_ne
id|eoff_hi
)paren
(brace
macro_line|#ifdef CONFIG_MTD_PMC551_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551_read() soff_hi: %ld, eoff_hi: %ld&bslash;n&quot;
comma
(paren
r_int
)paren
id|soff_hi
comma
(paren
r_int
)paren
id|eoff_hi
)paren
suffix:semicolon
macro_line|#endif
id|memcpy
c_func
(paren
id|copyto
comma
id|ptr
comma
id|priv-&gt;asize
)paren
suffix:semicolon
id|copyto
op_add_assign
id|priv-&gt;asize
suffix:semicolon
r_if
c_cond
(paren
id|soff_hi
op_plus
id|priv-&gt;asize
op_ge
id|mtd-&gt;size
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|soff_hi
op_add_assign
id|priv-&gt;asize
suffix:semicolon
id|pmc551_point
(paren
id|mtd
comma
id|soff_hi
comma
id|priv-&gt;asize
comma
id|retlen
comma
op_amp
id|ptr
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|copyto
comma
id|ptr
comma
id|eoff_lo
)paren
suffix:semicolon
id|copyto
op_add_assign
id|eoff_lo
suffix:semicolon
)brace
id|out
suffix:colon
macro_line|#ifdef CONFIG_MTD_PMC551_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551_read() done&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
op_star
id|retlen
op_assign
id|copyto
op_minus
id|buf
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pmc551_write
r_static
r_int
id|pmc551_write
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
(brace
r_struct
id|mypriv
op_star
id|priv
op_assign
(paren
r_struct
id|mypriv
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
id|u32
id|soff_hi
comma
id|soff_lo
suffix:semicolon
multiline_comment|/* start address offset hi/lo */
id|u32
id|eoff_hi
comma
id|eoff_lo
suffix:semicolon
multiline_comment|/* end address offset hi/lo */
r_int
r_int
id|end
suffix:semicolon
id|u_char
op_star
id|ptr
suffix:semicolon
r_const
id|u_char
op_star
id|copyfrom
op_assign
id|buf
suffix:semicolon
macro_line|#ifdef CONFIG_MTD_PMC551_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551_write(pos:%ld, len:%ld) asize:%ld&bslash;n&quot;
comma
(paren
r_int
)paren
id|to
comma
(paren
r_int
)paren
id|len
comma
(paren
r_int
)paren
id|priv-&gt;asize
)paren
suffix:semicolon
macro_line|#endif
id|end
op_assign
id|to
op_plus
id|len
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Is it past the end?  or did the u32 wrap? */
r_if
c_cond
(paren
id|end
OG
id|mtd-&gt;size
)paren
(brace
macro_line|#ifdef CONFIG_MTD_PMC551_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551_write() out of bounds (end: %ld, size: %ld, to: %ld)&bslash;n&quot;
comma
(paren
r_int
)paren
id|end
comma
(paren
r_int
)paren
id|mtd-&gt;size
comma
(paren
r_int
)paren
id|to
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|soff_hi
op_assign
id|to
op_amp
op_complement
(paren
id|priv-&gt;asize
op_minus
l_int|1
)paren
suffix:semicolon
id|eoff_hi
op_assign
id|end
op_amp
op_complement
(paren
id|priv-&gt;asize
op_minus
l_int|1
)paren
suffix:semicolon
id|soff_lo
op_assign
id|to
op_amp
(paren
id|priv-&gt;asize
op_minus
l_int|1
)paren
suffix:semicolon
id|eoff_lo
op_assign
id|end
op_amp
(paren
id|priv-&gt;asize
op_minus
l_int|1
)paren
suffix:semicolon
id|pmc551_point
(paren
id|mtd
comma
id|to
comma
id|len
comma
id|retlen
comma
op_amp
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|soff_hi
op_eq
id|eoff_hi
)paren
(brace
multiline_comment|/* The whole thing fits within one access, so just one shot&n;                   will do it. */
id|memcpy
c_func
(paren
id|ptr
comma
id|copyfrom
comma
id|len
)paren
suffix:semicolon
id|copyfrom
op_add_assign
id|len
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We have to do multiple writes to get all the data&n;                   written. */
r_while
c_loop
(paren
id|soff_hi
op_ne
id|eoff_hi
)paren
(brace
macro_line|#ifdef CONFIG_MTD_PMC551_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551_write() soff_hi: %ld, eoff_hi: %ld&bslash;n&quot;
comma
(paren
r_int
)paren
id|soff_hi
comma
(paren
r_int
)paren
id|eoff_hi
)paren
suffix:semicolon
macro_line|#endif
id|memcpy
c_func
(paren
id|ptr
comma
id|copyfrom
comma
id|priv-&gt;asize
)paren
suffix:semicolon
id|copyfrom
op_add_assign
id|priv-&gt;asize
suffix:semicolon
r_if
c_cond
(paren
id|soff_hi
op_ge
id|mtd-&gt;size
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|soff_hi
op_add_assign
id|priv-&gt;asize
suffix:semicolon
id|pmc551_point
(paren
id|mtd
comma
id|soff_hi
comma
id|priv-&gt;asize
comma
id|retlen
comma
op_amp
id|ptr
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|ptr
comma
id|copyfrom
comma
id|eoff_lo
)paren
suffix:semicolon
id|copyfrom
op_add_assign
id|eoff_lo
suffix:semicolon
)brace
id|out
suffix:colon
macro_line|#ifdef CONFIG_MTD_PMC551_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551_write() done&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
op_star
id|retlen
op_assign
id|copyfrom
op_minus
id|buf
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Fixup routines for the V370PDC&n; * PCI device ID 0x020011b0&n; *&n; * This function basicly kick starts the DRAM oboard the card and gets it&n; * ready to be used.  Before this is done the device reads VERY erratic, so&n; * much that it can crash the Linux 2.2.x series kernels when a user cat&squot;s&n; * /proc/pci .. though that is mainly a kernel bug in handling the PCI DEVSEL&n; * register.  FIXME: stop spinning on registers .. must implement a timeout&n; * mechanism&n; * returns the size of the memory region found.&n; */
DECL|function|fixup_pmc551
r_static
id|u32
id|fixup_pmc551
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
macro_line|#ifdef CONFIG_MTD_PMC551_BUGFIX
id|u32
id|dram_data
suffix:semicolon
macro_line|#endif
id|u32
id|size
comma
id|dcmd
comma
id|cfg
comma
id|dtmp
suffix:semicolon
id|u16
id|cmd
comma
id|tmp
comma
id|i
suffix:semicolon
id|u8
id|bcmd
comma
id|counter
suffix:semicolon
multiline_comment|/* Sanity Check */
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Attempt to reset the card&n;&t; * FIXME: Stop Spinning registers&n;&t; */
id|counter
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* unlock registers */
id|pci_write_config_byte
c_func
(paren
id|dev
comma
id|PMC551_SYS_CTRL_REG
comma
l_int|0xA5
)paren
suffix:semicolon
multiline_comment|/* read in old data */
id|pci_read_config_byte
c_func
(paren
id|dev
comma
id|PMC551_SYS_CTRL_REG
comma
op_amp
id|bcmd
)paren
suffix:semicolon
multiline_comment|/* bang the reset line up and down for a few */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
id|counter
op_assign
l_int|0
suffix:semicolon
id|bcmd
op_and_assign
op_complement
l_int|0x80
suffix:semicolon
r_while
c_loop
(paren
id|counter
op_increment
OL
l_int|100
)paren
(brace
id|pci_write_config_byte
c_func
(paren
id|dev
comma
id|PMC551_SYS_CTRL_REG
comma
id|bcmd
)paren
suffix:semicolon
)brace
id|counter
op_assign
l_int|0
suffix:semicolon
id|bcmd
op_or_assign
l_int|0x80
suffix:semicolon
r_while
c_loop
(paren
id|counter
op_increment
OL
l_int|100
)paren
(brace
id|pci_write_config_byte
c_func
(paren
id|dev
comma
id|PMC551_SYS_CTRL_REG
comma
id|bcmd
)paren
suffix:semicolon
)brace
)brace
id|bcmd
op_or_assign
(paren
l_int|0x40
op_or
l_int|0x20
)paren
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|dev
comma
id|PMC551_SYS_CTRL_REG
comma
id|bcmd
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Take care and turn off the memory on the device while we&n;&t; * tweak the configurations&n;&t; */
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|tmp
op_assign
id|cmd
op_amp
op_complement
(paren
id|PCI_COMMAND_IO
op_or
id|PCI_COMMAND_MEMORY
)paren
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Disable existing aperture before probing memory size&n;&t; */
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PMC551_PCI_MEM_MAP0
comma
op_amp
id|dcmd
)paren
suffix:semicolon
id|dtmp
op_assign
(paren
id|dcmd
op_or
id|PMC551_PCI_MEM_MAP_ENABLE
op_or
id|PMC551_PCI_MEM_MAP_REG_EN
)paren
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|dev
comma
id|PMC551_PCI_MEM_MAP0
comma
id|dtmp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Grab old BAR0 config so that we can figure out memory size&n;&t; * This is another bit of kludge going on.  The reason for the&n;&t; * redundancy is I am hoping to retain the original configuration&n;&t; * previously assigned to the card by the BIOS or some previous &n;&t; * fixup routine in the kernel.  So we read the old config into cfg,&n;&t; * then write all 1&squot;s to the memory space, read back the result into&n;&t; * &quot;size&quot;, and then write back all the old config.&n;&t; */
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PCI_BASE_ADDRESS_0
comma
op_amp
id|cfg
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_MTD_PMC551_BUGFIX
id|pci_write_config_dword
c_func
(paren
id|dev
comma
id|PCI_BASE_ADDRESS_0
comma
op_complement
l_int|0
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PCI_BASE_ADDRESS_0
comma
op_amp
id|size
)paren
suffix:semicolon
id|size
op_assign
(paren
id|size
op_amp
id|PCI_BASE_ADDRESS_MEM_MASK
)paren
suffix:semicolon
id|size
op_and_assign
op_complement
(paren
id|size
op_minus
l_int|1
)paren
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|dev
comma
id|PCI_BASE_ADDRESS_0
comma
id|cfg
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/*&n;         * Get the size of the memory by reading all the DRAM size values&n;         * and adding them up.&n;         *&n;         * KLUDGE ALERT: the boards we are using have invalid column and&n;         * row mux values.  We fix them here, but this will break other&n;         * memory configurations.&n;         */
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PMC551_DRAM_BLK0
comma
op_amp
id|dram_data
)paren
suffix:semicolon
id|size
op_assign
id|PMC551_DRAM_BLK_GET_SIZE
c_func
(paren
id|dram_data
)paren
suffix:semicolon
id|dram_data
op_assign
id|PMC551_DRAM_BLK_SET_COL_MUX
c_func
(paren
id|dram_data
comma
l_int|0x5
)paren
suffix:semicolon
id|dram_data
op_assign
id|PMC551_DRAM_BLK_SET_ROW_MUX
c_func
(paren
id|dram_data
comma
l_int|0x9
)paren
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|dev
comma
id|PMC551_DRAM_BLK0
comma
id|dram_data
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PMC551_DRAM_BLK1
comma
op_amp
id|dram_data
)paren
suffix:semicolon
id|size
op_add_assign
id|PMC551_DRAM_BLK_GET_SIZE
c_func
(paren
id|dram_data
)paren
suffix:semicolon
id|dram_data
op_assign
id|PMC551_DRAM_BLK_SET_COL_MUX
c_func
(paren
id|dram_data
comma
l_int|0x5
)paren
suffix:semicolon
id|dram_data
op_assign
id|PMC551_DRAM_BLK_SET_ROW_MUX
c_func
(paren
id|dram_data
comma
l_int|0x9
)paren
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|dev
comma
id|PMC551_DRAM_BLK1
comma
id|dram_data
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PMC551_DRAM_BLK2
comma
op_amp
id|dram_data
)paren
suffix:semicolon
id|size
op_add_assign
id|PMC551_DRAM_BLK_GET_SIZE
c_func
(paren
id|dram_data
)paren
suffix:semicolon
id|dram_data
op_assign
id|PMC551_DRAM_BLK_SET_COL_MUX
c_func
(paren
id|dram_data
comma
l_int|0x5
)paren
suffix:semicolon
id|dram_data
op_assign
id|PMC551_DRAM_BLK_SET_ROW_MUX
c_func
(paren
id|dram_data
comma
l_int|0x9
)paren
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|dev
comma
id|PMC551_DRAM_BLK2
comma
id|dram_data
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PMC551_DRAM_BLK3
comma
op_amp
id|dram_data
)paren
suffix:semicolon
id|size
op_add_assign
id|PMC551_DRAM_BLK_GET_SIZE
c_func
(paren
id|dram_data
)paren
suffix:semicolon
id|dram_data
op_assign
id|PMC551_DRAM_BLK_SET_COL_MUX
c_func
(paren
id|dram_data
comma
l_int|0x5
)paren
suffix:semicolon
id|dram_data
op_assign
id|PMC551_DRAM_BLK_SET_ROW_MUX
c_func
(paren
id|dram_data
comma
l_int|0x9
)paren
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|dev
comma
id|PMC551_DRAM_BLK3
comma
id|dram_data
)paren
suffix:semicolon
multiline_comment|/*&n;         * Oops .. something went wrong&n;         */
r_if
c_cond
(paren
(paren
id|size
op_and_assign
id|PCI_BASE_ADDRESS_MEM_MASK
)paren
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_MTD_PMC551_BUGFIX */
r_if
c_cond
(paren
(paren
id|cfg
op_amp
id|PCI_BASE_ADDRESS_SPACE
)paren
op_ne
id|PCI_BASE_ADDRESS_SPACE_MEMORY
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;         * Precharge Dram&n;         */
id|pci_write_config_word
c_func
(paren
id|dev
comma
id|PMC551_SDRAM_MA
comma
l_int|0x0400
)paren
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|dev
comma
id|PMC551_SDRAM_CMD
comma
l_int|0x00bf
)paren
suffix:semicolon
multiline_comment|/*&n;         * Wait until command has gone through&n;         * FIXME: register spinning issue&n;         */
r_do
(brace
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PMC551_SDRAM_CMD
comma
op_amp
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|counter
op_increment
OG
l_int|100
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|PCI_COMMAND_IO
)paren
op_amp
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Turn on auto refresh &n;&t; * The loop is taken directly from Ramix&squot;s example code.  I assume that&n;&t; * this must be held high for some duration of time, but I can find no&n;&t; * documentation refrencing the reasons why.&n;         */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pci_write_config_word
(paren
id|dev
comma
id|PMC551_SDRAM_CMD
comma
l_int|0x0df
)paren
suffix:semicolon
multiline_comment|/*&n;                 * Make certain command has gone through&n;                 * FIXME: register spinning issue&n;                 */
id|counter
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PMC551_SDRAM_CMD
comma
op_amp
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|counter
op_increment
OG
l_int|100
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|PCI_COMMAND_IO
)paren
op_amp
id|cmd
)paren
suffix:semicolon
)brace
id|pci_write_config_word
(paren
id|dev
comma
id|PMC551_SDRAM_MA
comma
l_int|0x0020
)paren
suffix:semicolon
id|pci_write_config_word
(paren
id|dev
comma
id|PMC551_SDRAM_CMD
comma
l_int|0x0ff
)paren
suffix:semicolon
multiline_comment|/*&n;         * Wait until command completes&n;         * FIXME: register spinning issue&n;         */
id|counter
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|pci_read_config_word
(paren
id|dev
comma
id|PMC551_SDRAM_CMD
comma
op_amp
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|counter
op_increment
OG
l_int|100
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|PCI_COMMAND_IO
)paren
op_amp
id|cmd
)paren
suffix:semicolon
id|pci_read_config_dword
(paren
id|dev
comma
id|PMC551_DRAM_CFG
comma
op_amp
id|dcmd
)paren
suffix:semicolon
id|dcmd
op_or_assign
l_int|0x02000000
suffix:semicolon
id|pci_write_config_dword
(paren
id|dev
comma
id|PMC551_DRAM_CFG
comma
id|dcmd
)paren
suffix:semicolon
multiline_comment|/*&n;         * Check to make certain fast back-to-back, if not&n;         * then set it so&n;         */
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PCI_STATUS
comma
op_amp
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd
op_amp
id|PCI_COMMAND_FAST_BACK
)paren
op_eq
l_int|0
)paren
(brace
id|cmd
op_or_assign
id|PCI_COMMAND_FAST_BACK
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|dev
comma
id|PCI_STATUS
comma
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;         * Check to make certain the DEVSEL is set correctly, this device&n;         * has a tendancy to assert DEVSEL and TRDY when a write is performed&n;         * to the memory when memory is read-only&n;         */
r_if
c_cond
(paren
(paren
id|cmd
op_amp
id|PCI_STATUS_DEVSEL_MASK
)paren
op_ne
l_int|0x0
)paren
(brace
id|cmd
op_and_assign
op_complement
id|PCI_STATUS_DEVSEL_MASK
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|dev
comma
id|PCI_STATUS
comma
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;         * Set to be prefetchable and put everything back based on old cfg.&n;&t; * it&squot;s possible that the reset of the V370PDC nuked the original&n;&t; * setup&n;         */
multiline_comment|/*&n;        cfg |= PCI_BASE_ADDRESS_MEM_PREFETCH;&n;&t;pci_write_config_dword( dev, PCI_BASE_ADDRESS_0, cfg );&n;&t;*/
multiline_comment|/*&n;         * Turn PCI memory and I/O bus access back on&n;         */
id|pci_write_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
id|PCI_COMMAND_MEMORY
op_or
id|PCI_COMMAND_IO
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MTD_PMC551_DEBUG
multiline_comment|/*&n;         * Some screen fun&n;         */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551: %d%c (0x%x) of %sprefetchable memory at 0x%lx&bslash;n&quot;
comma
(paren
id|size
OL
l_int|1024
)paren
ques
c_cond
id|size
suffix:colon
(paren
id|size
OL
l_int|1048576
)paren
ques
c_cond
id|size
op_rshift
l_int|10
suffix:colon
id|size
op_rshift
l_int|20
comma
(paren
id|size
OL
l_int|1024
)paren
ques
c_cond
l_char|&squot;B&squot;
suffix:colon
(paren
id|size
OL
l_int|1048576
)paren
ques
c_cond
l_char|&squot;K&squot;
suffix:colon
l_char|&squot;M&squot;
comma
id|size
comma
(paren
(paren
id|dcmd
op_amp
(paren
l_int|0x1
op_lshift
l_int|3
)paren
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;non-&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|PCI_BASE_ADDRESS
c_func
(paren
id|dev
)paren
op_amp
id|PCI_BASE_ADDRESS_MEM_MASK
)paren
suffix:semicolon
multiline_comment|/*&n;         * Check to see the state of the memory&n;         */
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PMC551_DRAM_BLK0
comma
op_amp
id|dcmd
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551: DRAM_BLK0 Flags: %s,%s&bslash;n&quot;
l_string|&quot;pmc551: DRAM_BLK0 Size: %d at %d&bslash;n&quot;
l_string|&quot;pmc551: DRAM_BLK0 Row MUX: %d, Col MUX: %d&bslash;n&quot;
comma
(paren
(paren
(paren
l_int|0x1
op_lshift
l_int|1
)paren
op_amp
id|dcmd
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;RW&quot;
suffix:colon
l_string|&quot;RO&quot;
comma
(paren
(paren
(paren
l_int|0x1
op_lshift
l_int|0
)paren
op_amp
id|dcmd
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;Off&quot;
suffix:colon
l_string|&quot;On&quot;
comma
id|PMC551_DRAM_BLK_GET_SIZE
c_func
(paren
id|dcmd
)paren
comma
(paren
(paren
id|dcmd
op_rshift
l_int|20
)paren
op_amp
l_int|0x7FF
)paren
comma
(paren
(paren
id|dcmd
op_rshift
l_int|13
)paren
op_amp
l_int|0x7
)paren
comma
(paren
(paren
id|dcmd
op_rshift
l_int|9
)paren
op_amp
l_int|0xF
)paren
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PMC551_DRAM_BLK1
comma
op_amp
id|dcmd
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551: DRAM_BLK1 Flags: %s,%s&bslash;n&quot;
l_string|&quot;pmc551: DRAM_BLK1 Size: %d at %d&bslash;n&quot;
l_string|&quot;pmc551: DRAM_BLK1 Row MUX: %d, Col MUX: %d&bslash;n&quot;
comma
(paren
(paren
(paren
l_int|0x1
op_lshift
l_int|1
)paren
op_amp
id|dcmd
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;RW&quot;
suffix:colon
l_string|&quot;RO&quot;
comma
(paren
(paren
(paren
l_int|0x1
op_lshift
l_int|0
)paren
op_amp
id|dcmd
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;Off&quot;
suffix:colon
l_string|&quot;On&quot;
comma
id|PMC551_DRAM_BLK_GET_SIZE
c_func
(paren
id|dcmd
)paren
comma
(paren
(paren
id|dcmd
op_rshift
l_int|20
)paren
op_amp
l_int|0x7FF
)paren
comma
(paren
(paren
id|dcmd
op_rshift
l_int|13
)paren
op_amp
l_int|0x7
)paren
comma
(paren
(paren
id|dcmd
op_rshift
l_int|9
)paren
op_amp
l_int|0xF
)paren
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PMC551_DRAM_BLK2
comma
op_amp
id|dcmd
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551: DRAM_BLK2 Flags: %s,%s&bslash;n&quot;
l_string|&quot;pmc551: DRAM_BLK2 Size: %d at %d&bslash;n&quot;
l_string|&quot;pmc551: DRAM_BLK2 Row MUX: %d, Col MUX: %d&bslash;n&quot;
comma
(paren
(paren
(paren
l_int|0x1
op_lshift
l_int|1
)paren
op_amp
id|dcmd
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;RW&quot;
suffix:colon
l_string|&quot;RO&quot;
comma
(paren
(paren
(paren
l_int|0x1
op_lshift
l_int|0
)paren
op_amp
id|dcmd
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;Off&quot;
suffix:colon
l_string|&quot;On&quot;
comma
id|PMC551_DRAM_BLK_GET_SIZE
c_func
(paren
id|dcmd
)paren
comma
(paren
(paren
id|dcmd
op_rshift
l_int|20
)paren
op_amp
l_int|0x7FF
)paren
comma
(paren
(paren
id|dcmd
op_rshift
l_int|13
)paren
op_amp
l_int|0x7
)paren
comma
(paren
(paren
id|dcmd
op_rshift
l_int|9
)paren
op_amp
l_int|0xF
)paren
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PMC551_DRAM_BLK3
comma
op_amp
id|dcmd
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551: DRAM_BLK3 Flags: %s,%s&bslash;n&quot;
l_string|&quot;pmc551: DRAM_BLK3 Size: %d at %d&bslash;n&quot;
l_string|&quot;pmc551: DRAM_BLK3 Row MUX: %d, Col MUX: %d&bslash;n&quot;
comma
(paren
(paren
(paren
l_int|0x1
op_lshift
l_int|1
)paren
op_amp
id|dcmd
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;RW&quot;
suffix:colon
l_string|&quot;RO&quot;
comma
(paren
(paren
(paren
l_int|0x1
op_lshift
l_int|0
)paren
op_amp
id|dcmd
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;Off&quot;
suffix:colon
l_string|&quot;On&quot;
comma
id|PMC551_DRAM_BLK_GET_SIZE
c_func
(paren
id|dcmd
)paren
comma
(paren
(paren
id|dcmd
op_rshift
l_int|20
)paren
op_amp
l_int|0x7FF
)paren
comma
(paren
(paren
id|dcmd
op_rshift
l_int|13
)paren
op_amp
l_int|0x7
)paren
comma
(paren
(paren
id|dcmd
op_rshift
l_int|9
)paren
op_amp
l_int|0xF
)paren
)paren
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551: Memory Access %s&bslash;n&quot;
comma
(paren
(paren
(paren
l_int|0x1
op_lshift
l_int|1
)paren
op_amp
id|cmd
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;off&quot;
suffix:colon
l_string|&quot;on&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551: I/O Access %s&bslash;n&quot;
comma
(paren
(paren
(paren
l_int|0x1
op_lshift
l_int|0
)paren
op_amp
id|cmd
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;off&quot;
suffix:colon
l_string|&quot;on&quot;
)paren
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PCI_STATUS
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551: Devsel %s&bslash;n&quot;
comma
(paren
(paren
id|PCI_STATUS_DEVSEL_MASK
op_amp
id|cmd
)paren
op_eq
l_int|0x000
)paren
ques
c_cond
l_string|&quot;Fast&quot;
suffix:colon
(paren
(paren
id|PCI_STATUS_DEVSEL_MASK
op_amp
id|cmd
)paren
op_eq
l_int|0x200
)paren
ques
c_cond
l_string|&quot;Medium&quot;
suffix:colon
(paren
(paren
id|PCI_STATUS_DEVSEL_MASK
op_amp
id|cmd
)paren
op_eq
l_int|0x400
)paren
ques
c_cond
l_string|&quot;Slow&quot;
suffix:colon
l_string|&quot;Invalid&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551: %sFast Back-to-Back&bslash;n&quot;
comma
(paren
(paren
id|PCI_COMMAND_FAST_BACK
op_amp
id|cmd
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;Not &quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|dev
comma
id|PMC551_SYS_CTRL_REG
comma
op_amp
id|bcmd
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551: EEPROM is under %s control&bslash;n&quot;
l_string|&quot;pmc551: System Control Register is %slocked to PCI access&bslash;n&quot;
l_string|&quot;pmc551: System Control Register is %slocked to EEPROM access&bslash;n&quot;
comma
(paren
id|bcmd
op_amp
l_int|0x1
)paren
ques
c_cond
l_string|&quot;software&quot;
suffix:colon
l_string|&quot;hardware&quot;
comma
(paren
id|bcmd
op_amp
l_int|0x20
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;un&quot;
comma
(paren
id|bcmd
op_amp
l_int|0x40
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;un&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; * Kernel version specific module stuffages&n; */
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Mark Ferrell &lt;mferrell@mvista.com&gt;&quot;
)paren
suffix:semicolon
DECL|variable|PMC551_VERSION
id|MODULE_DESCRIPTION
c_func
(paren
id|PMC551_VERSION
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|msize
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|msize
comma
l_string|&quot;memory size in Megabytes [1 - 1024]&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|asize
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|asize
comma
l_string|&quot;aperture size, must be &lt;= memsize [1-1024]&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * Stuff these outside the ifdef so as to not bust compiled in driver support&n; */
DECL|variable|msize
r_static
r_int
id|msize
op_assign
l_int|0
suffix:semicolon
macro_line|#if defined(CONFIG_MTD_PMC551_APERTURE_SIZE)
DECL|variable|asize
r_static
r_int
id|asize
op_assign
id|CONFIG_MTD_PMC551_APERTURE_SIZE
macro_line|#else
r_static
r_int
id|asize
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * PMC551 Card Initialization&n; */
r_int
id|__init
id|init_pmc551
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_dev
op_star
id|PCI_Device
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|mypriv
op_star
id|priv
suffix:semicolon
r_int
id|count
comma
id|found
op_assign
l_int|0
suffix:semicolon
r_struct
id|mtd_info
op_star
id|mtd
suffix:semicolon
id|u32
id|length
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|msize
)paren
(brace
id|msize
op_assign
(paren
l_int|1
op_lshift
(paren
id|ffs
c_func
(paren
id|msize
)paren
op_minus
l_int|1
)paren
)paren
op_lshift
l_int|20
suffix:semicolon
r_if
c_cond
(paren
id|msize
OG
(paren
l_int|1
op_lshift
l_int|30
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: Invalid memory size [%d]&bslash;n&quot;
comma
id|msize
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|asize
)paren
(brace
id|asize
op_assign
(paren
l_int|1
op_lshift
(paren
id|ffs
c_func
(paren
id|asize
)paren
op_minus
l_int|1
)paren
)paren
op_lshift
l_int|20
suffix:semicolon
r_if
c_cond
(paren
id|asize
OG
(paren
l_int|1
op_lshift
l_int|30
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: Invalid aperture size [%d]&bslash;n&quot;
comma
id|asize
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_INFO
id|PMC551_VERSION
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_present
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: PCI not enabled.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;         * PCU-bus chipset probe.&n;         */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|MAX_MTD_DEVICES
suffix:semicolon
id|count
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|PCI_Device
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_V3_SEMI
comma
id|PCI_DEVICE_ID_V3_SEMI_V370PDC
comma
id|PCI_Device
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: Found PCI V370PDC at 0x%lX&bslash;n&quot;
comma
id|PCI_BASE_ADDRESS
c_func
(paren
id|PCI_Device
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;                 * The PMC551 device acts VERY weird if you don&squot;t init it&n;                 * first.  i.e. it will not correctly report devsel.  If for&n;                 * some reason the sdram is in a wrote-protected state the&n;                 * device will DEVSEL when it is written to causing problems&n;                 * with the oldproc.c driver in&n;                 * some kernels (2.2.*)&n;                 */
r_if
c_cond
(paren
(paren
id|length
op_assign
id|fixup_pmc551
c_func
(paren
id|PCI_Device
)paren
)paren
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: Cannot init SDRAM&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * This is needed until the driver is capable of reading the&n;&t;&t; * onboard I2C SROM to discover the &quot;real&quot; memory size.&n;&t;&t; */
r_if
c_cond
(paren
id|msize
)paren
(brace
id|length
op_assign
id|msize
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: Using specified memory size 0x%x&bslash;n&quot;
comma
id|length
)paren
suffix:semicolon
)brace
r_else
(brace
id|msize
op_assign
id|length
suffix:semicolon
)brace
id|mtd
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|mtd_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mtd
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: Cannot allocate new MTD device.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memset
c_func
(paren
id|mtd
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|mtd_info
)paren
)paren
suffix:semicolon
id|priv
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|mypriv
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: Cannot allocate new MTD device.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memset
c_func
(paren
id|priv
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|priv
)paren
)paren
suffix:semicolon
id|mtd-&gt;priv
op_assign
id|priv
suffix:semicolon
id|priv-&gt;dev
op_assign
id|PCI_Device
suffix:semicolon
r_if
c_cond
(paren
id|asize
OG
id|length
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: reducing aperture size to fit %dM&bslash;n&quot;
comma
id|length
op_rshift
l_int|20
)paren
suffix:semicolon
id|priv-&gt;asize
op_assign
id|asize
op_assign
id|length
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|asize
op_eq
l_int|0
op_logical_or
id|asize
op_eq
id|length
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: Using existing aperture size %dM&bslash;n&quot;
comma
id|length
op_rshift
l_int|20
)paren
suffix:semicolon
id|priv-&gt;asize
op_assign
id|asize
op_assign
id|length
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: Using specified aperture size %dM&bslash;n&quot;
comma
id|asize
op_rshift
l_int|20
)paren
suffix:semicolon
id|priv-&gt;asize
op_assign
id|asize
suffix:semicolon
)brace
id|priv-&gt;start
op_assign
id|ioremap
c_func
(paren
(paren
id|PCI_BASE_ADDRESS
c_func
(paren
id|PCI_Device
)paren
op_amp
id|PCI_BASE_ADDRESS_MEM_MASK
)paren
comma
id|priv-&gt;asize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;start
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: Unable to map IO space&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mtd-&gt;priv
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MTD_PMC551_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551: setting aperture to %d&bslash;n&quot;
comma
id|ffs
c_func
(paren
id|priv-&gt;asize
op_rshift
l_int|20
)paren
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|priv-&gt;base_map0
op_assign
(paren
id|PMC551_PCI_MEM_MAP_REG_EN
op_or
id|PMC551_PCI_MEM_MAP_ENABLE
op_or
(paren
id|ffs
c_func
(paren
id|priv-&gt;asize
op_rshift
l_int|20
)paren
op_minus
l_int|1
)paren
op_lshift
l_int|4
)paren
suffix:semicolon
id|priv-&gt;curr_map0
op_assign
id|priv-&gt;base_map0
suffix:semicolon
id|pci_write_config_dword
(paren
id|priv-&gt;dev
comma
id|PMC551_PCI_MEM_MAP0
comma
id|priv-&gt;curr_map0
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MTD_PMC551_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551: aperture set to %d&bslash;n&quot;
comma
(paren
id|priv-&gt;base_map0
op_amp
l_int|0xF0
)paren
op_rshift
l_int|4
)paren
suffix:semicolon
macro_line|#endif
id|mtd-&gt;size
op_assign
id|msize
suffix:semicolon
id|mtd-&gt;flags
op_assign
id|MTD_CAP_RAM
suffix:semicolon
id|mtd-&gt;erase
op_assign
id|pmc551_erase
suffix:semicolon
id|mtd-&gt;read
op_assign
id|pmc551_read
suffix:semicolon
id|mtd-&gt;write
op_assign
id|pmc551_write
suffix:semicolon
id|mtd-&gt;point
op_assign
id|pmc551_point
suffix:semicolon
id|mtd-&gt;unpoint
op_assign
id|pmc551_unpoint
suffix:semicolon
id|mtd-&gt;module
op_assign
id|THIS_MODULE
suffix:semicolon
id|mtd-&gt;type
op_assign
id|MTD_RAM
suffix:semicolon
id|mtd-&gt;name
op_assign
l_string|&quot;PMC551 RAM board&quot;
suffix:semicolon
id|mtd-&gt;erasesize
op_assign
l_int|0x10000
suffix:semicolon
r_if
c_cond
(paren
id|add_mtd_device
c_func
(paren
id|mtd
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: Failed to register new device&bslash;n&quot;
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|priv-&gt;start
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mtd-&gt;priv
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Registered pmc551 memory device.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Mapped %dM of memory from 0x%p to 0x%p&bslash;n&quot;
comma
id|priv-&gt;asize
op_rshift
l_int|20
comma
id|priv-&gt;start
comma
id|priv-&gt;start
op_plus
id|priv-&gt;asize
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Total memory is %d%c&bslash;n&quot;
comma
(paren
id|length
OL
l_int|1024
)paren
ques
c_cond
id|length
suffix:colon
(paren
id|length
OL
l_int|1048576
)paren
ques
c_cond
id|length
op_rshift
l_int|10
suffix:colon
id|length
op_rshift
l_int|20
comma
(paren
id|length
OL
l_int|1024
)paren
ques
c_cond
l_char|&squot;B&squot;
suffix:colon
(paren
id|length
OL
l_int|1048576
)paren
ques
c_cond
l_char|&squot;K&squot;
suffix:colon
l_char|&squot;M&squot;
)paren
suffix:semicolon
id|priv-&gt;nextpmc551
op_assign
id|pmc551list
suffix:semicolon
id|pmc551list
op_assign
id|mtd
suffix:semicolon
id|found
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pmc551list
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: not detected&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: %d pmc551 devices loaded&bslash;n&quot;
comma
id|found
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * PMC551 Card Cleanup&n; */
r_static
r_void
id|__exit
id|cleanup_pmc551
c_func
(paren
r_void
)paren
(brace
r_int
id|found
op_assign
l_int|0
suffix:semicolon
r_struct
id|mtd_info
op_star
id|mtd
suffix:semicolon
r_struct
id|mypriv
op_star
id|priv
suffix:semicolon
r_while
c_loop
(paren
(paren
id|mtd
op_assign
id|pmc551list
)paren
)paren
(brace
id|priv
op_assign
(paren
r_struct
id|mypriv
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
id|pmc551list
op_assign
id|priv-&gt;nextpmc551
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;start
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;pmc551: unmapping %dM starting at 0x%p&bslash;n&quot;
comma
id|priv-&gt;asize
op_rshift
l_int|20
comma
id|priv-&gt;start
)paren
suffix:semicolon
id|iounmap
(paren
id|priv-&gt;start
)paren
suffix:semicolon
)brace
id|kfree
(paren
id|mtd-&gt;priv
)paren
suffix:semicolon
id|del_mtd_device
(paren
id|mtd
)paren
suffix:semicolon
id|kfree
(paren
id|mtd
)paren
suffix:semicolon
id|found
op_increment
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: %d pmc551 devices unloaded&bslash;n&quot;
comma
id|found
)paren
suffix:semicolon
)brace
id|module_init
c_func
(paren
id|init_pmc551
)paren
suffix:semicolon
DECL|variable|cleanup_pmc551
id|module_exit
c_func
(paren
id|cleanup_pmc551
)paren
suffix:semicolon
eof
