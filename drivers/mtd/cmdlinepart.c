multiline_comment|/*&n; * $Id: cmdlinepart.c,v 1.17 2004/11/26 11:18:47 lavinen Exp $&n; *&n; * Read flash partition table from command line&n; *&n; * Copyright 2002 SYSGO Real-Time Solutions GmbH&n; *&n; * The format for the command line is as follows:&n; * &n; * mtdparts=&lt;mtddef&gt;[;&lt;mtddef]&n; * &lt;mtddef&gt;  := &lt;mtd-id&gt;:&lt;partdef&gt;[,&lt;partdef&gt;]&n; * &lt;partdef&gt; := &lt;size&gt;[@offset][&lt;name&gt;][ro]&n; * &lt;mtd-id&gt;  := unique name used in mapping driver/device (mtd-&gt;name)&n; * &lt;size&gt;    := standard linux memsize OR &quot;-&quot; to denote all remaining space&n; * &lt;name&gt;    := &squot;(&squot; NAME &squot;)&squot;&n; * &n; * Examples:&n; * &n; * 1 NOR Flash, with 1 single writable partition:&n; * edb7312-nor:-&n; * &n; * 1 NOR Flash with 2 partitions, 1 NAND with one&n; * edb7312-nor:256k(ARMboot)ro,-(root);edb7312-nand:-(home)&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/mtd/partitions.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
multiline_comment|/* error message prefix */
DECL|macro|ERRP
mdefine_line|#define ERRP &quot;mtd: &quot;
multiline_comment|/* debug macro */
macro_line|#if 0
mdefine_line|#define dbg(x) do { printk(&quot;DEBUG-CMDLINE-PART: &quot;); printk x; } while(0)
macro_line|#else
DECL|macro|dbg
mdefine_line|#define dbg(x)
macro_line|#endif
multiline_comment|/* special size referring to all the remaining space in a partition */
DECL|macro|SIZE_REMAINING
mdefine_line|#define SIZE_REMAINING 0xffffffff
DECL|struct|cmdline_mtd_partition
r_struct
id|cmdline_mtd_partition
(brace
DECL|member|next
r_struct
id|cmdline_mtd_partition
op_star
id|next
suffix:semicolon
DECL|member|mtd_id
r_char
op_star
id|mtd_id
suffix:semicolon
DECL|member|num_parts
r_int
id|num_parts
suffix:semicolon
DECL|member|parts
r_struct
id|mtd_partition
op_star
id|parts
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* mtdpart_setup() parses into here */
DECL|variable|partitions
r_static
r_struct
id|cmdline_mtd_partition
op_star
id|partitions
suffix:semicolon
multiline_comment|/* the command line passed to mtdpart_setupd() */
DECL|variable|cmdline
r_static
r_char
op_star
id|cmdline
suffix:semicolon
DECL|variable|cmdline_parsed
r_static
r_int
id|cmdline_parsed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Parse one partition definition for an MTD. Since there can be many&n; * comma separated partition definitions, this function calls itself &n; * recursively until no more partition definitions are found. Nice side&n; * effect: the memory to keep the mtd_partition structs and the names&n; * is allocated upon the last definition being found. At that point the&n; * syntax has been verified ok.&n; */
DECL|function|newpart
r_static
r_struct
id|mtd_partition
op_star
id|newpart
c_func
(paren
r_char
op_star
id|s
comma
r_char
op_star
op_star
id|retptr
comma
r_int
op_star
id|num_parts
comma
r_int
id|this_part
comma
r_int
r_char
op_star
op_star
id|extra_mem_ptr
comma
r_int
id|extra_mem_size
)paren
(brace
r_struct
id|mtd_partition
op_star
id|parts
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_int
r_int
id|offset
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
r_int
id|name_len
suffix:semicolon
r_int
r_char
op_star
id|extra_mem
suffix:semicolon
r_char
id|delim
suffix:semicolon
r_int
r_int
id|mask_flags
suffix:semicolon
multiline_comment|/* fetch the partition size */
r_if
c_cond
(paren
op_star
id|s
op_eq
l_char|&squot;-&squot;
)paren
(brace
multiline_comment|/* assign all remaining space to this partition */
id|size
op_assign
id|SIZE_REMAINING
suffix:semicolon
id|s
op_increment
suffix:semicolon
)brace
r_else
(brace
id|size
op_assign
id|memparse
c_func
(paren
id|s
comma
op_amp
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
id|PAGE_SIZE
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|ERRP
l_string|&quot;partition size too small (%lx)&bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* fetch partition name and flags */
id|mask_flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* this is going to be a regular partition */
id|delim
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* check for offset */
r_if
c_cond
(paren
op_star
id|s
op_eq
l_char|&squot;@&squot;
)paren
(brace
id|s
op_increment
suffix:semicolon
id|offset
op_assign
id|memparse
c_func
(paren
id|s
comma
op_amp
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/* now look for name */
r_if
c_cond
(paren
op_star
id|s
op_eq
l_char|&squot;(&squot;
)paren
(brace
id|delim
op_assign
l_char|&squot;)&squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|delim
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
id|name
op_assign
op_increment
id|s
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p
op_assign
id|strchr
c_func
(paren
id|name
comma
id|delim
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|ERRP
l_string|&quot;no closing %c found in partition name&bslash;n&quot;
comma
id|delim
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|name_len
op_assign
id|p
op_minus
id|name
suffix:semicolon
id|s
op_assign
id|p
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|name
op_assign
l_int|NULL
suffix:semicolon
id|name_len
op_assign
l_int|13
suffix:semicolon
multiline_comment|/* Partition_000 */
)brace
multiline_comment|/* record name length for memory allocation later */
id|extra_mem_size
op_add_assign
id|name_len
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* test for options */
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|s
comma
l_string|&quot;ro&quot;
comma
l_int|2
)paren
op_eq
l_int|0
)paren
(brace
id|mask_flags
op_or_assign
id|MTD_WRITEABLE
suffix:semicolon
id|s
op_add_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/* test if more partitions are following */
r_if
c_cond
(paren
op_star
id|s
op_eq
l_char|&squot;,&squot;
)paren
(brace
r_if
c_cond
(paren
id|size
op_eq
id|SIZE_REMAINING
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|ERRP
l_string|&quot;no partitions allowed after a fill-up partition&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* more partitions follow, parse them */
r_if
c_cond
(paren
(paren
id|parts
op_assign
id|newpart
c_func
(paren
id|s
op_plus
l_int|1
comma
op_amp
id|s
comma
id|num_parts
comma
id|this_part
op_plus
l_int|1
comma
op_amp
id|extra_mem
comma
id|extra_mem_size
)paren
)paren
op_eq
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* this is the last partition: allocate space for all */
r_int
id|alloc_size
suffix:semicolon
op_star
id|num_parts
op_assign
id|this_part
op_plus
l_int|1
suffix:semicolon
id|alloc_size
op_assign
op_star
id|num_parts
op_star
r_sizeof
(paren
r_struct
id|mtd_partition
)paren
op_plus
id|extra_mem_size
suffix:semicolon
id|parts
op_assign
id|kmalloc
c_func
(paren
id|alloc_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parts
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|ERRP
l_string|&quot;out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|parts
comma
l_int|0
comma
id|alloc_size
)paren
suffix:semicolon
id|extra_mem
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|parts
op_plus
op_star
id|num_parts
)paren
suffix:semicolon
)brace
multiline_comment|/* enter this partition (offset will be calculated later if it is zero at this point) */
id|parts
(braket
id|this_part
)braket
dot
id|size
op_assign
id|size
suffix:semicolon
id|parts
(braket
id|this_part
)braket
dot
id|offset
op_assign
id|offset
suffix:semicolon
id|parts
(braket
id|this_part
)braket
dot
id|mask_flags
op_assign
id|mask_flags
suffix:semicolon
r_if
c_cond
(paren
id|name
)paren
(brace
id|strlcpy
c_func
(paren
id|extra_mem
comma
id|name
comma
id|name_len
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|sprintf
c_func
(paren
id|extra_mem
comma
l_string|&quot;Partition_%03d&quot;
comma
id|this_part
)paren
suffix:semicolon
)brace
id|parts
(braket
id|this_part
)braket
dot
id|name
op_assign
id|extra_mem
suffix:semicolon
id|extra_mem
op_add_assign
id|name_len
op_plus
l_int|1
suffix:semicolon
id|dbg
c_func
(paren
(paren
l_string|&quot;partition %d: name &lt;%s&gt;, offset %x, size %x, mask flags %x&bslash;n&quot;
comma
id|this_part
comma
id|parts
(braket
id|this_part
)braket
dot
id|name
comma
id|parts
(braket
id|this_part
)braket
dot
id|offset
comma
id|parts
(braket
id|this_part
)braket
dot
id|size
comma
id|parts
(braket
id|this_part
)braket
dot
id|mask_flags
)paren
)paren
suffix:semicolon
multiline_comment|/* return (updated) pointer to extra_mem memory */
r_if
c_cond
(paren
id|extra_mem_ptr
)paren
op_star
id|extra_mem_ptr
op_assign
id|extra_mem
suffix:semicolon
multiline_comment|/* return (updated) pointer command line string */
op_star
id|retptr
op_assign
id|s
suffix:semicolon
multiline_comment|/* return partition table */
r_return
id|parts
suffix:semicolon
)brace
multiline_comment|/* &n; * Parse the command line. &n; */
DECL|function|mtdpart_setup_real
r_static
r_int
id|mtdpart_setup_real
c_func
(paren
r_char
op_star
id|s
)paren
(brace
id|cmdline_parsed
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|s
op_ne
l_int|NULL
suffix:semicolon
)paren
(brace
r_struct
id|cmdline_mtd_partition
op_star
id|this_mtd
suffix:semicolon
r_struct
id|mtd_partition
op_star
id|parts
suffix:semicolon
r_int
id|mtd_id_len
suffix:semicolon
r_int
id|num_parts
suffix:semicolon
r_char
op_star
id|p
comma
op_star
id|mtd_id
suffix:semicolon
id|mtd_id
op_assign
id|s
suffix:semicolon
multiline_comment|/* fetch &lt;mtd-id&gt; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|p
op_assign
id|strchr
c_func
(paren
id|s
comma
l_char|&squot;:&squot;
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|ERRP
l_string|&quot;no mtd-id&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|mtd_id_len
op_assign
id|p
op_minus
id|mtd_id
suffix:semicolon
id|dbg
c_func
(paren
(paren
l_string|&quot;parsing &lt;%s&gt;&bslash;n&quot;
comma
id|p
op_plus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * parse one mtd. have it reserve memory for the&n;&t;&t; * struct cmdline_mtd_partition and the mtd-id string.&n;&t;&t; */
id|parts
op_assign
id|newpart
c_func
(paren
id|p
op_plus
l_int|1
comma
multiline_comment|/* cmdline */
op_amp
id|s
comma
multiline_comment|/* out: updated cmdline ptr */
op_amp
id|num_parts
comma
multiline_comment|/* out: number of parts */
l_int|0
comma
multiline_comment|/* first partition */
(paren
r_int
r_char
op_star
op_star
)paren
op_amp
id|this_mtd
comma
multiline_comment|/* out: extra mem */
id|mtd_id_len
op_plus
l_int|1
op_plus
r_sizeof
(paren
op_star
id|this_mtd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parts
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * An error occurred. We&squot;re either:&n;&t;&t;&t; * a) out of memory, or&n;&t;&t;&t; * b) in the middle of the partition spec&n;&t;&t;&t; * Either way, this mtd is hosed and we&squot;re&n;&t;&t;&t; * unlikely to succeed in parsing any more&n;&t;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* enter results */
id|this_mtd-&gt;parts
op_assign
id|parts
suffix:semicolon
id|this_mtd-&gt;num_parts
op_assign
id|num_parts
suffix:semicolon
id|this_mtd-&gt;mtd_id
op_assign
(paren
r_char
op_star
)paren
(paren
id|this_mtd
op_plus
l_int|1
)paren
suffix:semicolon
id|strlcpy
c_func
(paren
id|this_mtd-&gt;mtd_id
comma
id|mtd_id
comma
id|mtd_id_len
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* link into chain */
id|this_mtd-&gt;next
op_assign
id|partitions
suffix:semicolon
id|partitions
op_assign
id|this_mtd
suffix:semicolon
id|dbg
c_func
(paren
(paren
l_string|&quot;mtdid=&lt;%s&gt; num_parts=&lt;%d&gt;&bslash;n&quot;
comma
id|this_mtd-&gt;mtd_id
comma
id|this_mtd-&gt;num_parts
)paren
)paren
suffix:semicolon
multiline_comment|/* EOS - we&squot;re done */
r_if
c_cond
(paren
op_star
id|s
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* does another spec follow? */
r_if
c_cond
(paren
op_star
id|s
op_ne
l_char|&squot;;&squot;
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|ERRP
l_string|&quot;bad character after partition (%c)&bslash;n&quot;
comma
op_star
id|s
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|s
op_increment
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Main function to be called from the MTD mapping driver/device to&n; * obtain the partitioning information. At this point the command line&n; * arguments will actually be parsed and turned to struct mtd_partition&n; * information. It returns partitions for the requested mtd device, or&n; * the first one in the chain if a NULL mtd_id is passed in.&n; */
DECL|function|parse_cmdline_partitions
r_static
r_int
id|parse_cmdline_partitions
c_func
(paren
r_struct
id|mtd_info
op_star
id|master
comma
r_struct
id|mtd_partition
op_star
op_star
id|pparts
comma
r_int
r_int
id|origin
)paren
(brace
r_int
r_int
id|offset
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|cmdline_mtd_partition
op_star
id|part
suffix:semicolon
r_char
op_star
id|mtd_id
op_assign
id|master-&gt;name
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmdline
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* parse command line */
r_if
c_cond
(paren
op_logical_neg
id|cmdline_parsed
)paren
id|mtdpart_setup_real
c_func
(paren
id|cmdline
)paren
suffix:semicolon
r_for
c_loop
(paren
id|part
op_assign
id|partitions
suffix:semicolon
id|part
suffix:semicolon
id|part
op_assign
id|part-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|mtd_id
)paren
op_logical_or
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|part-&gt;mtd_id
comma
id|mtd_id
)paren
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|offset
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|part-&gt;num_parts
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|part-&gt;parts
(braket
id|i
)braket
dot
id|offset
)paren
id|part-&gt;parts
(braket
id|i
)braket
dot
id|offset
op_assign
id|offset
suffix:semicolon
r_else
id|offset
op_assign
id|part-&gt;parts
(braket
id|i
)braket
dot
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|part-&gt;parts
(braket
id|i
)braket
dot
id|size
op_eq
id|SIZE_REMAINING
)paren
id|part-&gt;parts
(braket
id|i
)braket
dot
id|size
op_assign
id|master-&gt;size
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_plus
id|part-&gt;parts
(braket
id|i
)braket
dot
id|size
OG
id|master-&gt;size
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|ERRP
l_string|&quot;%s: partitioning exceeds flash size, truncating&bslash;n&quot;
comma
id|part-&gt;mtd_id
)paren
suffix:semicolon
id|part-&gt;parts
(braket
id|i
)braket
dot
id|size
op_assign
id|master-&gt;size
op_minus
id|offset
suffix:semicolon
id|part-&gt;num_parts
op_assign
id|i
suffix:semicolon
)brace
id|offset
op_add_assign
id|part-&gt;parts
(braket
id|i
)braket
dot
id|size
suffix:semicolon
)brace
op_star
id|pparts
op_assign
id|part-&gt;parts
suffix:semicolon
r_return
id|part-&gt;num_parts
suffix:semicolon
)brace
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* &n; * This is the handler for our kernel parameter, called from &n; * main.c::checksetup(). Note that we can not yet kmalloc() anything,&n; * so we only save the commandline for later processing.&n; *&n; * This function needs to be visible for bootloaders.&n; */
DECL|function|mtdpart_setup
r_int
id|mtdpart_setup
c_func
(paren
r_char
op_star
id|s
)paren
(brace
id|cmdline
op_assign
id|s
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;mtdparts=&quot;
comma
id|mtdpart_setup
)paren
suffix:semicolon
DECL|variable|cmdline_parser
r_static
r_struct
id|mtd_part_parser
id|cmdline_parser
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|parse_fn
op_assign
id|parse_cmdline_partitions
comma
dot
id|name
op_assign
l_string|&quot;cmdlinepart&quot;
comma
)brace
suffix:semicolon
DECL|function|cmdline_parser_init
r_static
r_int
id|__init
id|cmdline_parser_init
c_func
(paren
r_void
)paren
(brace
r_return
id|register_mtd_parser
c_func
(paren
op_amp
id|cmdline_parser
)paren
suffix:semicolon
)brace
DECL|variable|cmdline_parser_init
id|module_init
c_func
(paren
id|cmdline_parser_init
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Marius Groeger &lt;mag@sysgo.de&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Command line configuration of MTD partitions&quot;
)paren
suffix:semicolon
eof
