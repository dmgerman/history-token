macro_line|#ifndef FWH_LOCK_H
DECL|macro|FWH_LOCK_H
mdefine_line|#define FWH_LOCK_H
DECL|enum|fwh_lock_state
r_enum
id|fwh_lock_state
(brace
DECL|enumerator|FWH_UNLOCKED
id|FWH_UNLOCKED
op_assign
l_int|0
comma
DECL|enumerator|FWH_DENY_WRITE
id|FWH_DENY_WRITE
op_assign
l_int|1
comma
DECL|enumerator|FWH_IMMUTABLE
id|FWH_IMMUTABLE
op_assign
l_int|2
comma
DECL|enumerator|FWH_DENY_READ
id|FWH_DENY_READ
op_assign
l_int|4
comma
)brace
suffix:semicolon
DECL|struct|fwh_xxlock_thunk
r_struct
id|fwh_xxlock_thunk
(brace
DECL|member|val
r_enum
id|fwh_lock_state
id|val
suffix:semicolon
DECL|member|state
id|flstate_t
id|state
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|FWH_XXLOCK_ONEBLOCK_LOCK
mdefine_line|#define FWH_XXLOCK_ONEBLOCK_LOCK   ((struct fwh_xxlock_thunk){ FWH_DENY_WRITE, FL_LOCKING})
DECL|macro|FWH_XXLOCK_ONEBLOCK_UNLOCK
mdefine_line|#define FWH_XXLOCK_ONEBLOCK_UNLOCK ((struct fwh_xxlock_thunk){ FWH_UNLOCKED,   FL_UNLOCKING})
multiline_comment|/*&n; * This locking/unlock is specific to firmware hub parts.  Only one&n; * is known that supports the Intel command set.    Firmware&n; * hub parts cannot be interleaved as they are on the LPC bus&n; * so this code has not been tested with interleaved chips,&n; * and will likely fail in that context.&n; */
DECL|function|fwh_xxlock_oneblock
r_static
r_int
id|fwh_xxlock_oneblock
c_func
(paren
r_struct
id|map_info
op_star
id|map
comma
r_struct
id|flchip
op_star
id|chip
comma
r_int
r_int
id|adr
comma
r_int
id|len
comma
r_void
op_star
id|thunk
)paren
(brace
r_struct
id|cfi_private
op_star
id|cfi
op_assign
id|map-&gt;fldrv_priv
suffix:semicolon
r_struct
id|fwh_xxlock_thunk
op_star
id|xxlt
op_assign
(paren
r_struct
id|fwh_xxlock_thunk
op_star
)paren
id|thunk
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* Refuse the operation if the we cannot look behind the chip */
r_if
c_cond
(paren
id|chip-&gt;start
OL
l_int|0x400000
)paren
(brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;MTD %s(): chip-&gt;start: %lx wanted &gt;= 0x400000&bslash;n&quot;
comma
id|__func__
comma
id|chip-&gt;start
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * lock block registers:&n;&t; * - on 64k boundariesand&n;&t; * - bit 1 set high&n;&t; * - block lock registers are 4MiB lower - overflow subtract (danger)&n;&t; * &n;&t; * The address manipulation is first done on the logical address&n;&t; * which is 0 at the start of the chip, and then the offset of&n;&t; * the individual chip is addted to it.  Any other order a weird&n;&t; * map offset could cause problems.&n;&t; */
id|adr
op_assign
(paren
id|adr
op_amp
op_complement
l_int|0xffffUL
)paren
op_or
l_int|0x2
suffix:semicolon
id|adr
op_add_assign
id|chip-&gt;start
op_minus
l_int|0x400000
suffix:semicolon
multiline_comment|/*&n;&t; * This is easy because these are writes to registers and not writes&n;&t; * to flash memory - that means that we don&squot;t have to check status&n;&t; * and timeout.&n;&t; */
id|cfi_spin_lock
c_func
(paren
id|chip-&gt;mutex
)paren
suffix:semicolon
id|ret
op_assign
id|get_chip
c_func
(paren
id|map
comma
id|chip
comma
id|adr
comma
id|FL_LOCKING
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|cfi_spin_unlock
c_func
(paren
id|chip-&gt;mutex
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|chip-&gt;state
op_assign
id|xxlt-&gt;state
suffix:semicolon
id|map_write
c_func
(paren
id|map
comma
id|CMD
c_func
(paren
id|xxlt-&gt;val
)paren
comma
id|adr
)paren
suffix:semicolon
multiline_comment|/* Done and happy. */
id|chip-&gt;state
op_assign
id|FL_READY
suffix:semicolon
id|put_chip
c_func
(paren
id|map
comma
id|chip
comma
id|adr
)paren
suffix:semicolon
id|cfi_spin_unlock
c_func
(paren
id|chip-&gt;mutex
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fwh_lock_varsize
r_static
r_int
id|fwh_lock_varsize
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|ofs
comma
r_int
id|len
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|cfi_varsize_frob
c_func
(paren
id|mtd
comma
id|fwh_xxlock_oneblock
comma
id|ofs
comma
id|len
comma
(paren
r_void
op_star
)paren
op_amp
id|FWH_XXLOCK_ONEBLOCK_LOCK
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|fwh_unlock_varsize
r_static
r_int
id|fwh_unlock_varsize
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|ofs
comma
r_int
id|len
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|cfi_varsize_frob
c_func
(paren
id|mtd
comma
id|fwh_xxlock_oneblock
comma
id|ofs
comma
id|len
comma
(paren
r_void
op_star
)paren
op_amp
id|FWH_XXLOCK_ONEBLOCK_UNLOCK
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|fixup_use_fwh_lock
r_static
r_void
id|fixup_use_fwh_lock
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_void
op_star
id|param
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;using fwh lock/unlock method&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Setup for the chips with the fwh lock method */
id|mtd-&gt;lock
op_assign
id|fwh_lock_varsize
suffix:semicolon
id|mtd-&gt;unlock
op_assign
id|fwh_unlock_varsize
suffix:semicolon
)brace
macro_line|#endif /* FWH_LOCK_H */
eof
