multiline_comment|/* &n;   Common Flash Interface probe code.&n;   (C) 2000 Red Hat. GPL&squot;d.&n;   $Id: cfi_probe.c,v 1.60 2001/06/03 01:32:57 nico Exp $&n;*/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/mtd/map.h&gt;
macro_line|#include &lt;linux/mtd/cfi.h&gt;
multiline_comment|/* #define DEBUG_CFI */
macro_line|#ifdef DEBUG_CFI
r_static
r_void
id|print_cfi_ident
c_func
(paren
r_struct
id|cfi_ident
op_star
)paren
suffix:semicolon
macro_line|#endif
r_int
id|cfi_jedec_setup
c_func
(paren
r_struct
id|cfi_private
op_star
id|p_cfi
comma
r_int
id|index
)paren
suffix:semicolon
r_int
id|cfi_jedec_lookup
c_func
(paren
r_int
id|index
comma
r_int
id|mfr_id
comma
r_int
id|dev_id
)paren
suffix:semicolon
r_static
r_void
id|check_cmd_set
c_func
(paren
r_struct
id|map_info
op_star
comma
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_struct
id|cfi_private
op_star
id|cfi_cfi_probe
c_func
(paren
r_struct
id|map_info
op_star
)paren
suffix:semicolon
r_struct
id|mtd_info
op_star
id|cfi_probe
c_func
(paren
r_struct
id|map_info
op_star
id|map
)paren
suffix:semicolon
DECL|variable|cfi_chipdrv
r_static
r_struct
id|mtd_chip_driver
id|cfi_chipdrv
op_assign
(brace
id|probe
suffix:colon
id|cfi_probe
comma
id|name
suffix:colon
l_string|&quot;cfi&quot;
comma
id|module
suffix:colon
id|THIS_MODULE
)brace
suffix:semicolon
DECL|function|cfi_probe
r_struct
id|mtd_info
op_star
id|cfi_probe
c_func
(paren
r_struct
id|map_info
op_star
id|map
)paren
(brace
r_struct
id|mtd_info
op_star
id|mtd
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|cfi_private
op_star
id|cfi
suffix:semicolon
multiline_comment|/* First probe the map to see if we have CFI stuff there. */
id|cfi
op_assign
id|cfi_cfi_probe
c_func
(paren
id|map
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfi
)paren
r_return
l_int|NULL
suffix:semicolon
id|map-&gt;fldrv_priv
op_assign
id|cfi
suffix:semicolon
multiline_comment|/* OK we liked it. Now find a driver for the command set it talks */
id|check_cmd_set
c_func
(paren
id|map
comma
l_int|1
comma
id|cfi-&gt;chips
(braket
l_int|0
)braket
dot
id|start
)paren
suffix:semicolon
multiline_comment|/* First the primary cmdset */
r_if
c_cond
(paren
op_logical_neg
id|map-&gt;fldrv
)paren
id|check_cmd_set
c_func
(paren
id|map
comma
l_int|0
comma
id|cfi-&gt;chips
(braket
l_int|0
)braket
dot
id|start
)paren
suffix:semicolon
multiline_comment|/* Then the secondary */
multiline_comment|/* check_cmd_set() will have used inter_module_get to increase&n;&t;   the use count of the module which provides the command set &n;&t;   driver. If we&squot;re quitting, we have to decrease it again.&n;&t;*/
r_if
c_cond
(paren
id|map-&gt;fldrv
)paren
(brace
id|mtd
op_assign
id|map-&gt;fldrv
op_member_access_from_pointer
id|probe
c_func
(paren
id|map
)paren
suffix:semicolon
multiline_comment|/* Undo the use count we held onto from inter_module_get */
macro_line|#ifdef MODULE
r_if
c_cond
(paren
id|map-&gt;fldrv-&gt;module
)paren
(brace
id|__MOD_DEC_USE_COUNT
c_func
(paren
id|map-&gt;fldrv-&gt;module
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|mtd
)paren
r_return
id|mtd
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cfi_probe: No supported Vendor Command Set found&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|cfi-&gt;cfiq
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|cfi
)paren
suffix:semicolon
id|map-&gt;fldrv_priv
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|cfi_send_cmd
r_static
id|__u32
id|cfi_send_cmd
c_func
(paren
id|u_char
id|cmd
comma
id|__u32
id|base
comma
r_struct
id|map_info
op_star
id|map
comma
r_struct
id|cfi_private
op_star
id|cfi
)paren
(brace
r_return
id|cfi_send_gen_cmd
c_func
(paren
id|cmd
comma
l_int|0x55
comma
id|base
comma
id|map
comma
id|cfi
comma
id|cfi-&gt;device_type
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* check for QRY, or search for jedec id.&n;   in: interleave,type,mode&n;   ret: table index, &lt;0 for error&n; */
DECL|function|cfi_check_qry_or_id
r_static
r_int
id|cfi_check_qry_or_id
c_func
(paren
r_struct
id|map_info
op_star
id|map
comma
id|__u32
id|base
comma
r_int
id|index
comma
r_struct
id|cfi_private
op_star
id|cfi
)paren
(brace
id|__u32
id|manufacturer_id
comma
id|device_id
suffix:semicolon
r_int
id|osf
op_assign
id|cfi-&gt;interleave
op_star
id|cfi-&gt;device_type
suffix:semicolon
singleline_comment|// scale factor
singleline_comment|//printk(&quot;cfi_check_qry_or_id: base=0x%08lx interl=%d type=%d index=%d&bslash;n&quot;,base,cfi-&gt;interleave,cfi-&gt;device_type,index);
r_switch
c_cond
(paren
id|cfi-&gt;cfi_mode
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|cfi_read
c_func
(paren
id|map
comma
id|base
op_plus
id|osf
op_star
l_int|0x10
)paren
op_eq
id|cfi_build_cmd
c_func
(paren
l_char|&squot;Q&squot;
comma
id|map
comma
id|cfi
)paren
op_logical_and
id|cfi_read
c_func
(paren
id|map
comma
id|base
op_plus
id|osf
op_star
l_int|0x11
)paren
op_eq
id|cfi_build_cmd
c_func
(paren
l_char|&squot;R&squot;
comma
id|map
comma
id|cfi
)paren
op_logical_and
id|cfi_read
c_func
(paren
id|map
comma
id|base
op_plus
id|osf
op_star
l_int|0x12
)paren
op_eq
id|cfi_build_cmd
c_func
(paren
l_char|&squot;Y&squot;
comma
id|map
comma
id|cfi
)paren
)paren
r_return
l_int|0
suffix:semicolon
singleline_comment|// ok !
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|manufacturer_id
op_assign
id|cfi_read
c_func
(paren
id|map
comma
id|base
op_plus
l_int|0
op_star
id|osf
)paren
suffix:semicolon
id|device_id
op_assign
id|cfi_read
c_func
(paren
id|map
comma
id|base
op_plus
l_int|1
op_star
id|osf
)paren
suffix:semicolon
singleline_comment|//printk(&quot;cfi_check_qry_or_id: man=0x%lx,id=0x%lx&bslash;n&quot;,manufacturer_id, device_id);
r_return
id|cfi_jedec_lookup
c_func
(paren
id|index
comma
id|manufacturer_id
comma
id|device_id
)paren
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
singleline_comment|// nothing found
)brace
DECL|function|cfi_qry_mode
r_static
r_void
id|cfi_qry_mode
c_func
(paren
r_struct
id|map_info
op_star
id|map
comma
id|__u32
id|base
comma
r_struct
id|cfi_private
op_star
id|cfi
)paren
(brace
r_switch
c_cond
(paren
id|cfi-&gt;cfi_mode
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* Query */
id|cfi_send_cmd
c_func
(paren
l_int|0x98
comma
id|base
comma
id|map
comma
id|cfi
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* Autoselect */
id|cfi_send_gen_cmd
c_func
(paren
l_int|0xaa
comma
id|cfi-&gt;addr_unlock1
comma
id|base
comma
id|map
comma
id|cfi
comma
id|CFI_DEVICETYPE_X8
comma
l_int|NULL
)paren
suffix:semicolon
id|cfi_send_gen_cmd
c_func
(paren
l_int|0x55
comma
id|cfi-&gt;addr_unlock2
comma
id|base
comma
id|map
comma
id|cfi
comma
id|CFI_DEVICETYPE_X8
comma
l_int|NULL
)paren
suffix:semicolon
id|cfi_send_gen_cmd
c_func
(paren
l_int|0x90
comma
id|cfi-&gt;addr_unlock1
comma
id|base
comma
id|map
comma
id|cfi
comma
id|CFI_DEVICETYPE_X8
comma
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|cfi_probe_chip_1
r_static
r_int
id|cfi_probe_chip_1
c_func
(paren
r_struct
id|map_info
op_star
id|map
comma
id|__u32
id|base
comma
r_struct
id|flchip
op_star
id|chips
comma
r_struct
id|cfi_private
op_star
id|cfi
)paren
(brace
r_int
id|index
suffix:semicolon
id|__u32
id|tmp
comma
id|ofs
suffix:semicolon
id|ofs
op_assign
id|cfi_send_gen_cmd
c_func
(paren
l_int|0xF0
comma
l_int|0
comma
id|base
comma
id|map
comma
id|cfi
comma
id|cfi-&gt;device_type
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|cfi_qry_mode
c_func
(paren
id|map
comma
id|base
comma
id|cfi
)paren
suffix:semicolon
id|index
op_assign
id|cfi_check_qry_or_id
c_func
(paren
id|map
comma
id|base
comma
op_minus
l_int|1
comma
id|cfi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|chips
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cfi-&gt;numchips
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* This chip should be in read mode if it&squot;s one&n;&t;&t;&t;   we&squot;ve already touched. */
r_if
c_cond
(paren
id|cfi_check_qry_or_id
c_func
(paren
id|map
comma
id|chips
(braket
id|i
)braket
dot
id|start
comma
id|index
comma
id|cfi
)paren
op_ge
l_int|0
)paren
(brace
id|cfi_send_gen_cmd
c_func
(paren
l_int|0xF0
comma
l_int|0
comma
id|chips
(braket
id|i
)braket
dot
id|start
comma
id|map
comma
id|cfi
comma
id|cfi-&gt;device_type
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfi_check_qry_or_id
c_func
(paren
id|map
comma
id|chips
(braket
id|i
)braket
dot
id|start
comma
id|index
comma
id|cfi
)paren
op_ge
l_int|0
)paren
(brace
multiline_comment|/* Yes it&squot;s got QRY for data. Most unfortunate.&n;&t;&t;&t;&t;&t;   Stick the old one in read mode too. */
id|cfi_send_gen_cmd
c_func
(paren
l_int|0xF0
comma
l_int|0
comma
id|base
comma
id|map
comma
id|cfi
comma
id|cfi-&gt;device_type
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfi_check_qry_or_id
c_func
(paren
id|map
comma
id|base
comma
id|index
comma
id|cfi
)paren
op_ge
l_int|0
)paren
(brace
multiline_comment|/* OK, so has the new one. Assume it&squot;s an alias */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Found an alias at 0x%x for the chip at 0x%lx&bslash;n&quot;
comma
id|map-&gt;name
comma
id|base
comma
id|chips
(braket
id|i
)braket
dot
id|start
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* &n;&t;&t;&t;&t;&t; * FIXME: Is this supposed to work?&n;&t;&t;&t;&t;&t; * The third argument is already&n;&t;&t;&t;&t;&t; * multiplied as this within the&n;&t;&t;&t;&t;&t; * function definition. (Nicolas Pitre)&n;&t;&t;&t;&t;&t; */
id|cfi_send_gen_cmd
c_func
(paren
l_int|0xF0
comma
l_int|0
comma
id|base
op_plus
l_int|0xaa
op_star
id|cfi-&gt;interleave
op_star
id|cfi-&gt;device_type
comma
id|map
comma
id|cfi
comma
id|cfi-&gt;device_type
comma
l_int|NULL
)paren
suffix:semicolon
id|cfi_send_gen_cmd
c_func
(paren
l_int|0xF0
comma
l_int|0
comma
id|chips
(braket
id|i
)braket
dot
id|start
op_plus
l_int|0xaa
op_star
id|cfi-&gt;interleave
op_star
id|cfi-&gt;device_type
comma
id|map
comma
id|cfi
comma
id|cfi-&gt;device_type
comma
l_int|NULL
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* for i */
multiline_comment|/* OK, if we got to here, then none of the previous chips appear to&n;&t;&t;   be aliases for the current one. */
r_if
c_cond
(paren
id|cfi-&gt;numchips
op_eq
id|MAX_CFI_CHIPS
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Too many flash chips detected. Increase MAX_CFI_CHIPS from %d.&bslash;n&quot;
comma
id|map-&gt;name
comma
id|MAX_CFI_CHIPS
)paren
suffix:semicolon
multiline_comment|/* Doesn&squot;t matter about resetting it to Read Mode - we&squot;re not going to talk to it anyway */
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|chips
(braket
id|cfi-&gt;numchips
)braket
dot
id|start
op_assign
id|base
suffix:semicolon
id|chips
(braket
id|cfi-&gt;numchips
)braket
dot
id|state
op_assign
id|FL_READY
suffix:semicolon
id|chips
(braket
id|cfi-&gt;numchips
)braket
dot
id|mutex
op_assign
op_amp
id|chips
(braket
id|cfi-&gt;numchips
)braket
dot
id|_spinlock
suffix:semicolon
id|cfi-&gt;numchips
op_increment
suffix:semicolon
multiline_comment|/* Put it back into Read Mode */
id|cfi_send_gen_cmd
c_func
(paren
l_int|0xF0
comma
l_int|0
comma
id|base
comma
id|map
comma
id|cfi
comma
id|cfi-&gt;device_type
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Found %d x%d devices at 0x%x in %d-bit mode&bslash;n&quot;
comma
id|map-&gt;name
comma
id|cfi-&gt;interleave
comma
id|cfi-&gt;device_type
op_star
l_int|8
comma
id|base
comma
id|map-&gt;buswidth
op_star
l_int|8
)paren
suffix:semicolon
r_return
id|index
suffix:semicolon
)brace
multiline_comment|/*  put dev into qry mode, and try cfi and jedec modes for the given type/interleave&n; */
DECL|function|cfi_probe_chip
r_static
r_int
id|cfi_probe_chip
c_func
(paren
r_struct
id|map_info
op_star
id|map
comma
id|__u32
id|base
comma
r_struct
id|flchip
op_star
id|chips
comma
r_struct
id|cfi_private
op_star
id|cfi
)paren
(brace
r_int
id|index
suffix:semicolon
id|cfi-&gt;cfi_mode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* cfi mode */
r_switch
c_cond
(paren
id|cfi-&gt;device_type
)paren
(brace
r_case
id|CFI_DEVICETYPE_X8
suffix:colon
id|cfi-&gt;addr_unlock1
op_assign
l_int|0x555
suffix:semicolon
id|cfi-&gt;addr_unlock2
op_assign
l_int|0x2aa
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CFI_DEVICETYPE_X16
suffix:colon
id|cfi-&gt;addr_unlock1
op_assign
l_int|0xaaa
suffix:semicolon
r_if
c_cond
(paren
id|map-&gt;buswidth
op_eq
id|cfi-&gt;interleave
)paren
(brace
multiline_comment|/* X16 chip(s) in X8 mode */
id|cfi-&gt;addr_unlock2
op_assign
l_int|0x555
suffix:semicolon
)brace
r_else
(brace
id|cfi-&gt;addr_unlock2
op_assign
l_int|0x554
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CFI_DEVICETYPE_X32
suffix:colon
id|cfi-&gt;addr_unlock1
op_assign
l_int|0x1555
suffix:semicolon
id|cfi-&gt;addr_unlock2
op_assign
l_int|0xaaa
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
id|index
op_assign
id|cfi_probe_chip_1
c_func
(paren
id|map
comma
id|base
comma
id|chips
comma
id|cfi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
l_int|0
)paren
r_return
id|index
suffix:semicolon
id|cfi-&gt;cfi_mode
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* jedec mode */
id|index
op_assign
id|cfi_probe_chip_1
c_func
(paren
id|map
comma
id|base
comma
id|chips
comma
id|cfi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
l_int|0
)paren
r_return
id|index
suffix:semicolon
id|cfi-&gt;addr_unlock1
op_assign
l_int|0x5555
suffix:semicolon
id|cfi-&gt;addr_unlock2
op_assign
l_int|0x2aaa
suffix:semicolon
id|index
op_assign
id|cfi_probe_chip_1
c_func
(paren
id|map
comma
id|base
comma
id|chips
comma
id|cfi
)paren
suffix:semicolon
r_return
id|index
suffix:semicolon
)brace
multiline_comment|/*&n; * Since probeing for CFI chips requires writing to the device problems may&n; * occur if the flash is not present and RAM is accessed instead.  For now we&n; * assume that the flash is present so we don&squot;t check for RAM or replace&n; * possibly overwritten data.&n; */
DECL|function|cfi_probe_new_chip
r_static
r_int
id|cfi_probe_new_chip
c_func
(paren
r_struct
id|map_info
op_star
id|map
comma
r_int
r_int
id|base
comma
r_struct
id|flchip
op_star
id|chips
comma
r_struct
id|cfi_private
op_star
id|cfi
)paren
(brace
r_int
id|index
suffix:semicolon
r_switch
c_cond
(paren
id|map-&gt;buswidth
)paren
(brace
macro_line|#ifdef CFIDEV_BUSWIDTH_1&t;&t;
r_case
id|CFIDEV_BUSWIDTH_1
suffix:colon
id|cfi-&gt;interleave
op_assign
id|CFIDEV_INTERLEAVE_1
suffix:semicolon
id|cfi-&gt;device_type
op_assign
id|CFI_DEVICETYPE_X8
suffix:semicolon
id|index
op_assign
id|cfi_probe_chip
c_func
(paren
id|map
comma
id|base
comma
id|chips
comma
id|cfi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
l_int|0
)paren
r_return
id|index
suffix:semicolon
id|cfi-&gt;device_type
op_assign
id|CFI_DEVICETYPE_X16
suffix:semicolon
id|index
op_assign
id|cfi_probe_chip
c_func
(paren
id|map
comma
id|base
comma
id|chips
comma
id|cfi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
l_int|0
)paren
r_return
id|index
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CFIDEV_BUSWIDTH_2&t;&t;
r_case
id|CFIDEV_BUSWIDTH_2
suffix:colon
macro_line|#ifdef CFIDEV_INTERLEAVE_1
id|cfi-&gt;interleave
op_assign
id|CFIDEV_INTERLEAVE_1
suffix:semicolon
id|cfi-&gt;device_type
op_assign
id|CFI_DEVICETYPE_X16
suffix:semicolon
id|index
op_assign
id|cfi_probe_chip
c_func
(paren
id|map
comma
id|base
comma
id|chips
comma
id|cfi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
l_int|0
)paren
r_return
id|index
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CFIDEV_INTERLEAVE_2
id|cfi-&gt;interleave
op_assign
id|CFIDEV_INTERLEAVE_2
suffix:semicolon
id|cfi-&gt;device_type
op_assign
id|CFI_DEVICETYPE_X8
suffix:semicolon
id|index
op_assign
id|cfi_probe_chip
c_func
(paren
id|map
comma
id|base
comma
id|chips
comma
id|cfi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
l_int|0
)paren
r_return
id|index
suffix:semicolon
id|cfi-&gt;device_type
op_assign
id|CFI_DEVICETYPE_X16
suffix:semicolon
id|index
op_assign
id|cfi_probe_chip
c_func
(paren
id|map
comma
id|base
comma
id|chips
comma
id|cfi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
l_int|0
)paren
r_return
id|index
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CFIDEV_BUSWIDTH_4
r_case
id|CFIDEV_BUSWIDTH_4
suffix:colon
macro_line|#ifdef CFIDEV_INTERLEAVE_4
id|cfi-&gt;interleave
op_assign
id|CFIDEV_INTERLEAVE_4
suffix:semicolon
id|cfi-&gt;device_type
op_assign
id|CFI_DEVICETYPE_X16
suffix:semicolon
id|index
op_assign
id|cfi_probe_chip
c_func
(paren
id|map
comma
id|base
comma
id|chips
comma
id|cfi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
l_int|0
)paren
r_return
id|index
suffix:semicolon
id|cfi-&gt;device_type
op_assign
id|CFI_DEVICETYPE_X32
suffix:semicolon
id|index
op_assign
id|cfi_probe_chip
c_func
(paren
id|map
comma
id|base
comma
id|chips
comma
id|cfi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
l_int|0
)paren
r_return
id|index
suffix:semicolon
id|cfi-&gt;device_type
op_assign
id|CFI_DEVICETYPE_X8
suffix:semicolon
id|index
op_assign
id|cfi_probe_chip
c_func
(paren
id|map
comma
id|base
comma
id|chips
comma
id|cfi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
l_int|0
)paren
r_return
id|index
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CFIDEV_INTERLEAVE_2
id|cfi-&gt;interleave
op_assign
id|CFIDEV_INTERLEAVE_2
suffix:semicolon
id|cfi-&gt;device_type
op_assign
id|CFI_DEVICETYPE_X16
suffix:semicolon
id|index
op_assign
id|cfi_probe_chip
c_func
(paren
id|map
comma
id|base
comma
id|chips
comma
id|cfi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
l_int|0
)paren
r_return
id|index
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CFIDEV_INTERLEAVE_1
id|cfi-&gt;interleave
op_assign
id|CFIDEV_INTERLEAVE_1
suffix:semicolon
id|cfi-&gt;device_type
op_assign
id|CFI_DEVICETYPE_X32
suffix:semicolon
id|index
op_assign
id|cfi_probe_chip
c_func
(paren
id|map
comma
id|base
comma
id|chips
comma
id|cfi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
l_int|0
)paren
r_return
id|index
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cfi_probe called with unsupported buswidth %d&bslash;n&quot;
comma
id|map-&gt;buswidth
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
singleline_comment|// switch
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|cfi_cfi_probe
r_static
r_struct
id|cfi_private
op_star
id|cfi_cfi_probe
c_func
(paren
r_struct
id|map_info
op_star
id|map
)paren
(brace
r_int
r_int
id|base
op_assign
l_int|0
suffix:semicolon
r_struct
id|cfi_private
id|cfi
suffix:semicolon
r_struct
id|cfi_private
op_star
id|retcfi
suffix:semicolon
r_struct
id|flchip
id|chip
(braket
id|MAX_CFI_CHIPS
)braket
suffix:semicolon
r_int
id|i
comma
id|index
suffix:semicolon
r_char
id|num_erase_regions
suffix:semicolon
r_int
id|ofs_factor
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|cfi
comma
l_int|0
comma
r_sizeof
(paren
id|cfi
)paren
)paren
suffix:semicolon
multiline_comment|/* The first invocation (with chips == NULL) leaves the device in Query Mode */
id|index
op_assign
id|cfi_probe_new_chip
c_func
(paren
id|map
comma
l_int|0
comma
l_int|NULL
comma
op_amp
id|cfi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Found no CFI device at location zero&bslash;n&quot;
comma
id|map-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Doesn&squot;t appear to be CFI-compliant at all */
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Read the Basic Query Structure from the device */
id|ofs_factor
op_assign
id|cfi.interleave
op_star
id|cfi.device_type
suffix:semicolon
multiline_comment|/* First, work out the amount of space to allocate */
r_if
c_cond
(paren
id|cfi.cfi_mode
op_eq
l_int|0
)paren
(brace
id|num_erase_regions
op_assign
id|cfi_read_query
c_func
(paren
id|map
comma
id|base
op_plus
(paren
l_int|0x10
op_plus
l_int|28
)paren
op_star
id|ofs_factor
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_CFI
id|printk
c_func
(paren
l_string|&quot;Number of erase regions: %d&bslash;n&quot;
comma
id|num_erase_regions
)paren
suffix:semicolon
macro_line|#endif
id|cfi.cfiq
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|cfi_ident
)paren
op_plus
id|num_erase_regions
op_star
l_int|4
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfi.cfiq
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: kmalloc failed for CFI ident structure&bslash;n&quot;
comma
id|map-&gt;name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|cfi.cfiq
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|cfi_ident
)paren
)paren
suffix:semicolon
id|cfi.fast_prog
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* CFI supports fast programming */
multiline_comment|/* CFI flash */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_sizeof
(paren
r_struct
id|cfi_ident
)paren
op_plus
id|num_erase_regions
op_star
l_int|4
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
(paren
(paren
r_int
r_char
op_star
)paren
id|cfi.cfiq
)paren
(braket
id|i
)braket
op_assign
id|cfi_read_query
c_func
(paren
id|map
comma
id|base
op_plus
(paren
l_int|0x10
op_plus
id|i
)paren
op_star
id|ofs_factor
)paren
suffix:semicolon
)brace
multiline_comment|/* Do any necessary byteswapping */
id|cfi.cfiq-&gt;P_ID
op_assign
id|le16_to_cpu
c_func
(paren
id|cfi.cfiq-&gt;P_ID
)paren
suffix:semicolon
id|cfi.cfiq-&gt;P_ADR
op_assign
id|le16_to_cpu
c_func
(paren
id|cfi.cfiq-&gt;P_ADR
)paren
suffix:semicolon
id|cfi.cfiq-&gt;A_ID
op_assign
id|le16_to_cpu
c_func
(paren
id|cfi.cfiq-&gt;A_ID
)paren
suffix:semicolon
id|cfi.cfiq-&gt;A_ADR
op_assign
id|le16_to_cpu
c_func
(paren
id|cfi.cfiq-&gt;A_ADR
)paren
suffix:semicolon
id|cfi.cfiq-&gt;InterfaceDesc
op_assign
id|le16_to_cpu
c_func
(paren
id|cfi.cfiq-&gt;InterfaceDesc
)paren
suffix:semicolon
id|cfi.cfiq-&gt;MaxBufWriteSize
op_assign
id|le16_to_cpu
c_func
(paren
id|cfi.cfiq-&gt;MaxBufWriteSize
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cfi.cfiq-&gt;NumEraseRegions
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cfi.cfiq-&gt;EraseRegionInfo
(braket
id|i
)braket
op_assign
id|le32_to_cpu
c_func
(paren
id|cfi.cfiq-&gt;EraseRegionInfo
(braket
id|i
)braket
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_CFI&t;&t;
id|printk
c_func
(paren
l_string|&quot;  Erase Region #%d: BlockSize 0x%4.4X bytes, %d blocks&bslash;n&quot;
comma
id|i
comma
(paren
id|cfi.cfiq-&gt;EraseRegionInfo
(braket
id|i
)braket
op_rshift
l_int|8
)paren
op_amp
op_complement
l_int|0xff
comma
(paren
id|cfi.cfiq-&gt;EraseRegionInfo
(braket
id|i
)braket
op_amp
l_int|0xffff
)paren
op_plus
l_int|1
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_else
(brace
multiline_comment|/* JEDEC flash */
r_if
c_cond
(paren
id|cfi_jedec_setup
c_func
(paren
op_amp
id|cfi
comma
id|index
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cfi_jedec_setup failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cfi.cfiq-&gt;NumEraseRegions
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Number of erase regions is zero&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|cfi.cfiq
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_CFI
multiline_comment|/* Dump the information therein */
id|print_cfi_ident
c_func
(paren
id|cfi.cfiq
)paren
suffix:semicolon
macro_line|#endif
id|cfi_send_cmd
c_func
(paren
l_int|0xFF
comma
id|base
comma
id|map
comma
op_amp
id|cfi
)paren
suffix:semicolon
multiline_comment|/* OK. We&squot;ve worked out what it is and we&squot;re happy with it. Now see if there are others */
id|chip
(braket
l_int|0
)braket
dot
id|start
op_assign
l_int|0
suffix:semicolon
id|chip
(braket
l_int|0
)braket
dot
id|state
op_assign
id|FL_READY
suffix:semicolon
id|chip
(braket
l_int|0
)braket
dot
id|mutex
op_assign
op_amp
id|chip
(braket
l_int|0
)braket
dot
id|_spinlock
suffix:semicolon
id|cfi.chipshift
op_assign
id|cfi.cfiq-&gt;DevSize
suffix:semicolon
id|cfi.numchips
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfi.chipshift
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cfi.chipsize is zero. This is bad. cfi.cfiq-&gt;DevSize is %d&bslash;n&quot;
comma
id|cfi.cfiq-&gt;DevSize
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|cfi.cfiq
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cfi.interleave
)paren
(brace
r_case
l_int|2
suffix:colon
id|cfi.chipshift
op_add_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|cfi.chipshift
op_add_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
id|base
op_assign
(paren
l_int|1
op_lshift
id|cfi.chipshift
)paren
suffix:semicolon
id|base
OL
id|map-&gt;size
suffix:semicolon
id|base
op_add_assign
(paren
l_int|1
op_lshift
id|cfi.chipshift
)paren
)paren
id|cfi_probe_chip_1
c_func
(paren
id|map
comma
id|base
comma
op_amp
id|chip
(braket
l_int|0
)braket
comma
op_amp
id|cfi
)paren
suffix:semicolon
id|retcfi
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|cfi_private
)paren
op_plus
id|cfi.numchips
op_star
r_sizeof
(paren
r_struct
id|flchip
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retcfi
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: kmalloc failed for CFI private structure&bslash;n&quot;
comma
id|map-&gt;name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|cfi.cfiq
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|retcfi
comma
op_amp
id|cfi
comma
r_sizeof
(paren
id|cfi
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|retcfi-&gt;chips
(braket
l_int|0
)braket
comma
id|chip
comma
r_sizeof
(paren
r_struct
id|flchip
)paren
op_star
id|cfi.numchips
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|retcfi-&gt;numchips
suffix:semicolon
id|i
op_increment
)paren
(brace
id|init_waitqueue_head
c_func
(paren
op_amp
id|retcfi-&gt;chips
(braket
id|i
)braket
dot
id|wq
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|retcfi-&gt;chips
(braket
id|i
)braket
dot
id|_spinlock
)paren
suffix:semicolon
id|retcfi-&gt;chips
(braket
id|i
)braket
dot
id|mutex
op_assign
op_amp
id|retcfi-&gt;chips
(braket
id|i
)braket
dot
id|_spinlock
suffix:semicolon
)brace
r_return
id|retcfi
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_CFI
DECL|function|vendorname
r_static
r_char
op_star
id|vendorname
c_func
(paren
id|__u16
id|vendor
)paren
(brace
r_switch
c_cond
(paren
id|vendor
)paren
(brace
r_case
id|P_ID_NONE
suffix:colon
r_return
l_string|&quot;None&quot;
suffix:semicolon
r_case
id|P_ID_INTEL_EXT
suffix:colon
r_return
l_string|&quot;Intel/Sharp Extended&quot;
suffix:semicolon
r_case
id|P_ID_AMD_STD
suffix:colon
r_return
l_string|&quot;AMD/Fujitsu Standard&quot;
suffix:semicolon
r_case
id|P_ID_INTEL_STD
suffix:colon
r_return
l_string|&quot;Intel/Sharp Standard&quot;
suffix:semicolon
r_case
id|P_ID_AMD_EXT
suffix:colon
r_return
l_string|&quot;AMD/Fujitsu Extended&quot;
suffix:semicolon
r_case
id|P_ID_MITSUBISHI_STD
suffix:colon
r_return
l_string|&quot;Mitsubishi Standard&quot;
suffix:semicolon
r_case
id|P_ID_MITSUBISHI_EXT
suffix:colon
r_return
l_string|&quot;Mitsubishi Extended&quot;
suffix:semicolon
r_case
id|P_ID_RESERVED
suffix:colon
r_return
l_string|&quot;Not Allowed / Reserved for Future Use&quot;
suffix:semicolon
r_default
suffix:colon
r_return
l_string|&quot;Unknown&quot;
suffix:semicolon
)brace
)brace
DECL|function|print_cfi_ident
r_static
r_void
id|print_cfi_ident
c_func
(paren
r_struct
id|cfi_ident
op_star
id|cfip
)paren
(brace
macro_line|#if 0
r_if
c_cond
(paren
id|cfip-&gt;qry
(braket
l_int|0
)braket
op_ne
l_char|&squot;Q&squot;
op_logical_or
id|cfip-&gt;qry
(braket
l_int|1
)braket
op_ne
l_char|&squot;R&squot;
op_logical_or
id|cfip-&gt;qry
(braket
l_int|2
)braket
op_ne
l_char|&squot;Y&squot;
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Invalid CFI ident structure.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif&t;&t;
id|printk
c_func
(paren
l_string|&quot;Primary Vendor Command Set: %4.4X (%s)&bslash;n&quot;
comma
id|cfip-&gt;P_ID
comma
id|vendorname
c_func
(paren
id|cfip-&gt;P_ID
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfip-&gt;P_ADR
)paren
id|printk
c_func
(paren
l_string|&quot;Primary Algorithm Table at %4.4X&bslash;n&quot;
comma
id|cfip-&gt;P_ADR
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;No Primary Algorithm Table&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Alternative Vendor Command Set: %4.4X (%s)&bslash;n&quot;
comma
id|cfip-&gt;A_ID
comma
id|vendorname
c_func
(paren
id|cfip-&gt;A_ID
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfip-&gt;A_ADR
)paren
id|printk
c_func
(paren
l_string|&quot;Alternate Algorithm Table at %4.4X&bslash;n&quot;
comma
id|cfip-&gt;A_ADR
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;No Alternate Algorithm Table&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Vcc Minimum: %x.%x V&bslash;n&quot;
comma
id|cfip-&gt;VccMin
op_rshift
l_int|4
comma
id|cfip-&gt;VccMin
op_amp
l_int|0xf
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Vcc Maximum: %x.%x V&bslash;n&quot;
comma
id|cfip-&gt;VccMax
op_rshift
l_int|4
comma
id|cfip-&gt;VccMax
op_amp
l_int|0xf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfip-&gt;VppMin
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Vpp Minimum: %x.%x V&bslash;n&quot;
comma
id|cfip-&gt;VppMin
op_rshift
l_int|4
comma
id|cfip-&gt;VppMin
op_amp
l_int|0xf
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Vpp Maximum: %x.%x V&bslash;n&quot;
comma
id|cfip-&gt;VppMax
op_rshift
l_int|4
comma
id|cfip-&gt;VppMax
op_amp
l_int|0xf
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;No Vpp line&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Typical byte/word write timeout: %d &#xfffd;s&bslash;n&quot;
comma
l_int|1
op_lshift
id|cfip-&gt;WordWriteTimeoutTyp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Maximum byte/word write timeout: %d &#xfffd;s&bslash;n&quot;
comma
(paren
l_int|1
op_lshift
id|cfip-&gt;WordWriteTimeoutMax
)paren
op_star
(paren
l_int|1
op_lshift
id|cfip-&gt;WordWriteTimeoutTyp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfip-&gt;BufWriteTimeoutTyp
op_logical_or
id|cfip-&gt;BufWriteTimeoutMax
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Typical full buffer write timeout: %d &#xfffd;s&bslash;n&quot;
comma
l_int|1
op_lshift
id|cfip-&gt;BufWriteTimeoutTyp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Maximum full buffer write timeout: %d &#xfffd;s&bslash;n&quot;
comma
(paren
l_int|1
op_lshift
id|cfip-&gt;BufWriteTimeoutMax
)paren
op_star
(paren
l_int|1
op_lshift
id|cfip-&gt;BufWriteTimeoutTyp
)paren
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;Full buffer write not supported&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Typical block erase timeout: %d &#xfffd;s&bslash;n&quot;
comma
l_int|1
op_lshift
id|cfip-&gt;BlockEraseTimeoutTyp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Maximum block erase timeout: %d &#xfffd;s&bslash;n&quot;
comma
(paren
l_int|1
op_lshift
id|cfip-&gt;BlockEraseTimeoutMax
)paren
op_star
(paren
l_int|1
op_lshift
id|cfip-&gt;BlockEraseTimeoutTyp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfip-&gt;ChipEraseTimeoutTyp
op_logical_or
id|cfip-&gt;ChipEraseTimeoutMax
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Typical chip erase timeout: %d &#xfffd;s&bslash;n&quot;
comma
l_int|1
op_lshift
id|cfip-&gt;ChipEraseTimeoutTyp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Maximum chip erase timeout: %d &#xfffd;s&bslash;n&quot;
comma
(paren
l_int|1
op_lshift
id|cfip-&gt;ChipEraseTimeoutMax
)paren
op_star
(paren
l_int|1
op_lshift
id|cfip-&gt;ChipEraseTimeoutTyp
)paren
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;Chip erase not supported&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Device size: 0x%X bytes (%d MiB)&bslash;n&quot;
comma
l_int|1
op_lshift
id|cfip-&gt;DevSize
comma
l_int|1
op_lshift
(paren
id|cfip-&gt;DevSize
op_minus
l_int|20
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Flash Device Interface description: 0x%4.4X&bslash;n&quot;
comma
id|cfip-&gt;InterfaceDesc
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cfip-&gt;InterfaceDesc
)paren
(brace
r_case
l_int|0
suffix:colon
id|printk
c_func
(paren
l_string|&quot;  - x8-only asynchronous interface&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|printk
c_func
(paren
l_string|&quot;  - x16-only asynchronous interface&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|printk
c_func
(paren
l_string|&quot;  - supports x8 and x16 via BYTE# with asynchronous interface&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|printk
c_func
(paren
l_string|&quot;  - x32-only asynchronous interface&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|65535
suffix:colon
id|printk
c_func
(paren
l_string|&quot;  - Not Allowed / Reserved&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;  - Unknown&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Max. bytes in buffer write: 0x%x&bslash;n&quot;
comma
l_int|1
op_lshift
id|cfip-&gt;MaxBufWriteSize
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Number of Erase Block Regions: %d&bslash;n&quot;
comma
id|cfip-&gt;NumEraseRegions
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG_CFI */
DECL|typedef|cfi_cmdset_fn_t
r_typedef
r_void
id|cfi_cmdset_fn_t
c_func
(paren
r_struct
id|map_info
op_star
comma
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
id|cfi_cmdset_fn_t
id|cfi_cmdset_0001
suffix:semicolon
r_extern
id|cfi_cmdset_fn_t
id|cfi_cmdset_0002
suffix:semicolon
DECL|function|cfi_cmdset_unknown
r_static
r_void
id|cfi_cmdset_unknown
c_func
(paren
r_struct
id|map_info
op_star
id|map
comma
r_int
id|primary
comma
r_int
r_int
id|base
)paren
(brace
id|__u16
id|adr
suffix:semicolon
r_struct
id|cfi_private
op_star
id|cfi
op_assign
id|map-&gt;fldrv_priv
suffix:semicolon
id|__u16
id|type
op_assign
id|primary
ques
c_cond
id|cfi-&gt;cfiq-&gt;P_ID
suffix:colon
id|cfi-&gt;cfiq-&gt;A_ID
suffix:semicolon
macro_line|#ifdef HAVE_INTER_MODULE
r_char
id|probename
(braket
l_int|32
)braket
suffix:semicolon
id|cfi_cmdset_fn_t
op_star
id|probe_function
suffix:semicolon
id|sprintf
c_func
(paren
id|probename
comma
l_string|&quot;cfi_cmdset_%4.4X&quot;
comma
id|type
)paren
suffix:semicolon
id|probe_function
op_assign
id|inter_module_get_request
c_func
(paren
id|probename
comma
id|probename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|probe_function
)paren
(brace
(paren
op_star
id|probe_function
)paren
(paren
id|map
comma
id|primary
comma
id|base
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Support for command set %04X not present&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
multiline_comment|/* This was a command set we don&squot;t know about. Print only the basic info */
id|adr
op_assign
id|primary
ques
c_cond
id|cfi-&gt;cfiq-&gt;P_ADR
suffix:colon
id|cfi-&gt;cfiq-&gt;A_ADR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|adr
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; No Extended Query Table&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|ofs_factor
op_assign
id|cfi-&gt;interleave
op_star
id|cfi-&gt;device_type
suffix:semicolon
r_if
c_cond
(paren
id|cfi_read_query
c_func
(paren
id|map
comma
id|base
op_plus
id|adr
op_star
id|ofs_factor
)paren
op_ne
(paren
id|primary
ques
c_cond
l_char|&squot;P&squot;
suffix:colon
l_char|&squot;A&squot;
)paren
op_logical_or
id|cfi_read_query
c_func
(paren
id|map
comma
id|base
op_plus
(paren
id|adr
op_plus
l_int|1
)paren
op_star
id|ofs_factor
)paren
op_ne
(paren
id|primary
ques
c_cond
l_char|&squot;R&squot;
suffix:colon
l_char|&squot;L&squot;
)paren
op_logical_or
id|cfi_read_query
c_func
(paren
id|map
comma
id|base
op_plus
(paren
id|adr
op_plus
l_int|2
)paren
op_star
id|ofs_factor
)paren
op_ne
(paren
id|primary
ques
c_cond
l_char|&squot;I&squot;
suffix:colon
l_char|&squot;T&squot;
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;Invalid Extended Query Table at %4.4X: %2.2X %2.2X %2.2X&bslash;n&quot;
comma
id|adr
comma
id|cfi_read_query
c_func
(paren
id|map
comma
id|base
op_plus
id|adr
op_star
id|ofs_factor
)paren
comma
id|cfi_read_query
c_func
(paren
id|map
comma
id|base
op_plus
(paren
id|adr
op_plus
l_int|1
)paren
op_star
id|ofs_factor
)paren
comma
id|cfi_read_query
c_func
(paren
id|map
comma
id|base
op_plus
(paren
id|adr
op_plus
l_int|2
)paren
op_star
id|ofs_factor
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot; Extended Query Table version %c.%c&bslash;n&quot;
comma
id|cfi_read_query
c_func
(paren
id|map
comma
id|base
op_plus
(paren
id|adr
op_plus
l_int|3
)paren
op_star
id|ofs_factor
)paren
comma
id|cfi_read_query
c_func
(paren
id|map
comma
id|base
op_plus
(paren
id|adr
op_plus
l_int|4
)paren
op_star
id|ofs_factor
)paren
)paren
suffix:semicolon
)brace
)brace
id|cfi_send_cmd
c_func
(paren
l_int|0xff
comma
id|base
comma
id|map
comma
id|cfi
)paren
suffix:semicolon
)brace
DECL|function|check_cmd_set
r_static
r_void
id|check_cmd_set
c_func
(paren
r_struct
id|map_info
op_star
id|map
comma
r_int
id|primary
comma
r_int
r_int
id|base
)paren
(brace
r_struct
id|cfi_private
op_star
id|cfi
op_assign
id|map-&gt;fldrv_priv
suffix:semicolon
id|__u16
id|type
op_assign
id|primary
ques
c_cond
id|cfi-&gt;cfiq-&gt;P_ID
suffix:colon
id|cfi-&gt;cfiq-&gt;A_ID
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|P_ID_NONE
op_logical_or
id|type
op_eq
id|P_ID_RESERVED
)paren
r_return
suffix:semicolon
multiline_comment|/* Put it in query mode */
id|cfi_qry_mode
c_func
(paren
id|map
comma
id|base
comma
id|cfi
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
multiline_comment|/* Urgh. Ifdefs. The version with weak symbols was&n;&t;&t; * _much_ nicer. Shame it didn&squot;t seem to work on&n;&t;&t; * anything but x86, really.&n;&t;&t; * But we can&squot;t rely in inter_module_get() because&n;&t;&t; * that&squot;d mean we depend on link order.&n;&t;&t; */
macro_line|#ifdef CONFIG_MTD_CFI_INTELEXT
r_case
l_int|0x0001
suffix:colon
r_case
l_int|0x0003
suffix:colon
r_return
id|cfi_cmdset_0001
c_func
(paren
id|map
comma
id|primary
comma
id|base
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_MTD_CFI_AMDSTD
r_case
l_int|0x0002
suffix:colon
r_return
id|cfi_cmdset_0002
c_func
(paren
id|map
comma
id|primary
comma
id|base
)paren
suffix:semicolon
macro_line|#endif
)brace
r_return
id|cfi_cmdset_unknown
c_func
(paren
id|map
comma
id|primary
comma
id|base
)paren
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &lt; 0x20212 &amp;&amp; defined(MODULE)
DECL|macro|cfi_probe_init
mdefine_line|#define cfi_probe_init init_module
DECL|macro|cfi_probe_exit
mdefine_line|#define cfi_probe_exit cleanup_module
macro_line|#endif
DECL|function|cfi_probe_init
id|mod_init_t
id|cfi_probe_init
c_func
(paren
r_void
)paren
(brace
id|register_mtd_chip_driver
c_func
(paren
op_amp
id|cfi_chipdrv
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cfi_probe_exit
id|mod_exit_t
id|cfi_probe_exit
c_func
(paren
r_void
)paren
(brace
id|unregister_mtd_chip_driver
c_func
(paren
op_amp
id|cfi_chipdrv
)paren
suffix:semicolon
)brace
DECL|variable|cfi_probe_init
id|module_init
c_func
(paren
id|cfi_probe_init
)paren
suffix:semicolon
DECL|variable|cfi_probe_exit
id|module_exit
c_func
(paren
id|cfi_probe_exit
)paren
suffix:semicolon
eof
