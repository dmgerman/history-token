multiline_comment|/* sc520cdp.c -- MTD map driver for AMD SC520 Customer Development Platform&n; *&n; * Copyright (C) 2001 Sysgo Real-Time Solutions GmbH&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA&n; *&n; * $Id: sc520cdp.c,v 1.18 2004/11/04 13:24:15 gleixner Exp $&n; *&n; *&n; * The SC520CDP is an evaluation board for the Elan SC520 processor available&n; * from AMD. It has two banks of 32-bit Flash ROM, each 8 Megabytes in size,&n; * and up to 512 KiB of 8-bit DIL Flash ROM.&n; * For details see http://www.amd.com/products/epd/desiging/evalboards/18.elansc520/520_cdp_brief/index.html&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/mtd/map.h&gt;
macro_line|#include &lt;linux/mtd/concat.h&gt;
multiline_comment|/*&n;** The Embedded Systems BIOS decodes the first FLASH starting at&n;** 0x8400000. This is a *terrible* place for it because accessing&n;** the flash at this location causes the A22 address line to be high&n;** (that&squot;s what 0x8400000 binary&squot;s ought to be). But this is the highest&n;** order address line on the raw flash devices themselves!!&n;** This causes the top HALF of the flash to be accessed first. Beyond&n;** the physical limits of the flash, the flash chip aliases over (to&n;** 0x880000 which causes the bottom half to be accessed. This splits the&n;** flash into two and inverts it! If you then try to access this from another&n;** program that does NOT do this insanity, then you *will* access the&n;** first half of the flash, but not find what you expect there. That&n;** stuff is in the *second* half! Similarly, the address used by the&n;** BIOS for the second FLASH bank is also quite a bad choice.&n;** If REPROGRAM_PAR is defined below (the default), then this driver will&n;** choose more useful addresses for the FLASH banks by reprogramming the&n;** responsible PARxx registers in the SC520&squot;s MMCR region. This will&n;** cause the settings to be incompatible with the BIOS&squot;s settings, which&n;** shouldn&squot;t be a problem since you are running Linux, (i.e. the BIOS is&n;** not much use anyway). However, if you need to be compatible with&n;** the BIOS for some reason, just undefine REPROGRAM_PAR.&n;*/
DECL|macro|REPROGRAM_PAR
mdefine_line|#define REPROGRAM_PAR
macro_line|#ifdef REPROGRAM_PAR
multiline_comment|/* These are the addresses we want.. */
DECL|macro|WINDOW_ADDR_0
mdefine_line|#define WINDOW_ADDR_0&t;0x08800000
DECL|macro|WINDOW_ADDR_1
mdefine_line|#define WINDOW_ADDR_1&t;0x09000000
DECL|macro|WINDOW_ADDR_2
mdefine_line|#define WINDOW_ADDR_2&t;0x09800000
multiline_comment|/* .. and these are the addresses the BIOS gives us */
DECL|macro|WINDOW_ADDR_0_BIOS
mdefine_line|#define WINDOW_ADDR_0_BIOS&t;0x08400000
DECL|macro|WINDOW_ADDR_1_BIOS
mdefine_line|#define WINDOW_ADDR_1_BIOS&t;0x08c00000
DECL|macro|WINDOW_ADDR_2_BIOS
mdefine_line|#define WINDOW_ADDR_2_BIOS&t;0x09400000
macro_line|#else
DECL|macro|WINDOW_ADDR_0
mdefine_line|#define WINDOW_ADDR_0&t;0x08400000
DECL|macro|WINDOW_ADDR_1
mdefine_line|#define WINDOW_ADDR_1&t;0x08C00000
DECL|macro|WINDOW_ADDR_2
mdefine_line|#define WINDOW_ADDR_2&t;0x09400000
macro_line|#endif
DECL|macro|WINDOW_SIZE_0
mdefine_line|#define WINDOW_SIZE_0&t;0x00800000
DECL|macro|WINDOW_SIZE_1
mdefine_line|#define WINDOW_SIZE_1&t;0x00800000
DECL|macro|WINDOW_SIZE_2
mdefine_line|#define WINDOW_SIZE_2&t;0x00080000
DECL|variable|sc520cdp_map
r_static
r_struct
id|map_info
id|sc520cdp_map
(braket
)braket
op_assign
(brace
(brace
dot
id|name
op_assign
l_string|&quot;SC520CDP Flash Bank #0&quot;
comma
dot
id|size
op_assign
id|WINDOW_SIZE_0
comma
dot
id|bankwidth
op_assign
l_int|4
comma
dot
id|phys
op_assign
id|WINDOW_ADDR_0
)brace
comma
(brace
dot
id|name
op_assign
l_string|&quot;SC520CDP Flash Bank #1&quot;
comma
dot
id|size
op_assign
id|WINDOW_SIZE_1
comma
dot
id|bankwidth
op_assign
l_int|4
comma
dot
id|phys
op_assign
id|WINDOW_ADDR_1
)brace
comma
(brace
dot
id|name
op_assign
l_string|&quot;SC520CDP DIL Flash&quot;
comma
dot
id|size
op_assign
id|WINDOW_SIZE_2
comma
dot
id|bankwidth
op_assign
l_int|1
comma
dot
id|phys
op_assign
id|WINDOW_ADDR_2
)brace
comma
)brace
suffix:semicolon
DECL|macro|NUM_FLASH_BANKS
mdefine_line|#define NUM_FLASH_BANKS&t;(sizeof(sc520cdp_map)/sizeof(struct map_info))
DECL|variable|mymtd
r_static
r_struct
id|mtd_info
op_star
id|mymtd
(braket
id|NUM_FLASH_BANKS
)braket
suffix:semicolon
DECL|variable|merged_mtd
r_static
r_struct
id|mtd_info
op_star
id|merged_mtd
suffix:semicolon
macro_line|#ifdef REPROGRAM_PAR
multiline_comment|/*&n;** The SC520 MMCR (memory mapped control register) region resides&n;** at 0xFFFEF000. The 16 Programmable Address Region (PAR) registers&n;** are at offset 0x88 in the MMCR:&n;*/
DECL|macro|SC520_MMCR_BASE
mdefine_line|#define SC520_MMCR_BASE&t;&t;0xFFFEF000
DECL|macro|SC520_MMCR_EXTENT
mdefine_line|#define SC520_MMCR_EXTENT&t;0x1000
DECL|macro|SC520_PAR
mdefine_line|#define SC520_PAR(x)&t;&t;((0x88/sizeof(unsigned long)) + (x))
DECL|macro|NUM_SC520_PAR
mdefine_line|#define NUM_SC520_PAR&t;&t;16&t;/* total number of PAR registers */
multiline_comment|/*&n;** The highest three bits in a PAR register determine what target&n;** device is controlled by this PAR. Here, only ROMCS? and BOOTCS&n;** devices are of interest.&n;*/
DECL|macro|SC520_PAR_BOOTCS
mdefine_line|#define SC520_PAR_BOOTCS&t;(0x4&lt;&lt;29)
DECL|macro|SC520_PAR_ROMCS0
mdefine_line|#define SC520_PAR_ROMCS0&t;(0x5&lt;&lt;29)
DECL|macro|SC520_PAR_ROMCS1
mdefine_line|#define SC520_PAR_ROMCS1&t;(0x6&lt;&lt;29)
DECL|macro|SC520_PAR_TRGDEV
mdefine_line|#define SC520_PAR_TRGDEV&t;(0x7&lt;&lt;29)
multiline_comment|/*&n;** Bits 28 thru 26 determine some attributes for the&n;** region controlled by the PAR. (We only use non-cacheable)&n;*/
DECL|macro|SC520_PAR_WRPROT
mdefine_line|#define SC520_PAR_WRPROT&t;(1&lt;&lt;26)&t;/* write protected       */
DECL|macro|SC520_PAR_NOCACHE
mdefine_line|#define SC520_PAR_NOCACHE&t;(1&lt;&lt;27)&t;/* non-cacheable         */
DECL|macro|SC520_PAR_NOEXEC
mdefine_line|#define SC520_PAR_NOEXEC&t;(1&lt;&lt;28)&t;/* code execution denied */
multiline_comment|/*&n;** Bit 25 determines the granularity: 4K or 64K&n;*/
DECL|macro|SC520_PAR_PG_SIZ4
mdefine_line|#define SC520_PAR_PG_SIZ4&t;(0&lt;&lt;25)
DECL|macro|SC520_PAR_PG_SIZ64
mdefine_line|#define SC520_PAR_PG_SIZ64&t;(1&lt;&lt;25)
multiline_comment|/*&n;** Build a value to be written into a PAR register.&n;** We only need ROM entries, 64K page size:&n;*/
DECL|macro|SC520_PAR_ENTRY
mdefine_line|#define SC520_PAR_ENTRY(trgdev, address, size) &bslash;&n;&t;((trgdev) | SC520_PAR_NOCACHE | SC520_PAR_PG_SIZ64 | &bslash;&n;&t;(address) &gt;&gt; 16 | (((size) &gt;&gt; 16) - 1) &lt;&lt; 14)
DECL|struct|sc520_par_table
r_struct
id|sc520_par_table
(brace
DECL|member|trgdev
r_int
r_int
id|trgdev
suffix:semicolon
DECL|member|new_par
r_int
r_int
id|new_par
suffix:semicolon
DECL|member|default_address
r_int
r_int
id|default_address
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|par_table
r_static
r_struct
id|sc520_par_table
id|par_table
(braket
id|NUM_FLASH_BANKS
)braket
op_assign
(brace
(brace
multiline_comment|/* Flash Bank #0: selected by ROMCS0 */
id|SC520_PAR_ROMCS0
comma
id|SC520_PAR_ENTRY
c_func
(paren
id|SC520_PAR_ROMCS0
comma
id|WINDOW_ADDR_0
comma
id|WINDOW_SIZE_0
)paren
comma
id|WINDOW_ADDR_0_BIOS
)brace
comma
(brace
multiline_comment|/* Flash Bank #1: selected by ROMCS1 */
id|SC520_PAR_ROMCS1
comma
id|SC520_PAR_ENTRY
c_func
(paren
id|SC520_PAR_ROMCS1
comma
id|WINDOW_ADDR_1
comma
id|WINDOW_SIZE_1
)paren
comma
id|WINDOW_ADDR_1_BIOS
)brace
comma
(brace
multiline_comment|/* DIL (BIOS) Flash: selected by BOOTCS */
id|SC520_PAR_BOOTCS
comma
id|SC520_PAR_ENTRY
c_func
(paren
id|SC520_PAR_BOOTCS
comma
id|WINDOW_ADDR_2
comma
id|WINDOW_SIZE_2
)paren
comma
id|WINDOW_ADDR_2_BIOS
)brace
)brace
suffix:semicolon
DECL|function|sc520cdp_setup_par
r_static
r_void
id|sc520cdp_setup_par
c_func
(paren
r_void
)paren
(brace
r_volatile
r_int
r_int
id|__iomem
op_star
id|mmcr
suffix:semicolon
r_int
r_int
id|mmcr_val
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
multiline_comment|/* map in SC520&squot;s MMCR area */
id|mmcr
op_assign
id|ioremap_nocache
c_func
(paren
id|SC520_MMCR_BASE
comma
id|SC520_MMCR_EXTENT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mmcr
)paren
(brace
multiline_comment|/* ioremap_nocache failed: skip the PAR reprogramming */
multiline_comment|/* force physical address fields to BIOS defaults: */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_FLASH_BANKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sc520cdp_map
(braket
id|i
)braket
dot
id|phys
op_assign
id|par_table
(braket
id|i
)braket
dot
id|default_address
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** Find the PARxx registers that are reponsible for activating&n;&t;** ROMCS0, ROMCS1 and BOOTCS. Reprogram each of these with a&n;&t;** new value from the table.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_FLASH_BANKS
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* for each par_table entry  */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|NUM_SC520_PAR
suffix:semicolon
id|j
op_increment
)paren
(brace
multiline_comment|/* for each PAR register     */
id|mmcr_val
op_assign
id|mmcr
(braket
id|SC520_PAR
c_func
(paren
id|j
)paren
)braket
suffix:semicolon
multiline_comment|/* if target device field matches, reprogram the PAR */
r_if
c_cond
(paren
(paren
id|mmcr_val
op_amp
id|SC520_PAR_TRGDEV
)paren
op_eq
id|par_table
(braket
id|i
)braket
dot
id|trgdev
)paren
(brace
id|mmcr
(braket
id|SC520_PAR
c_func
(paren
id|j
)paren
)braket
op_assign
id|par_table
(braket
id|i
)braket
dot
id|new_par
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|j
op_eq
id|NUM_SC520_PAR
)paren
(brace
multiline_comment|/* no matching PAR found: try default BIOS address */
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Could not find PAR responsible for %s&bslash;n&quot;
comma
id|sc520cdp_map
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Trying default address 0x%lx&bslash;n&quot;
comma
id|par_table
(braket
id|i
)braket
dot
id|default_address
)paren
suffix:semicolon
id|sc520cdp_map
(braket
id|i
)braket
dot
id|phys
op_assign
id|par_table
(braket
id|i
)braket
dot
id|default_address
suffix:semicolon
)brace
)brace
id|iounmap
c_func
(paren
id|mmcr
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|init_sc520cdp
r_static
r_int
id|__init
id|init_sc520cdp
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|devices_found
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef REPROGRAM_PAR
multiline_comment|/* reprogram PAR registers so flash appears at the desired addresses */
id|sc520cdp_setup_par
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_FLASH_BANKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;SC520 CDP flash device: 0x%lx at 0x%lx&bslash;n&quot;
comma
id|sc520cdp_map
(braket
id|i
)braket
dot
id|size
comma
id|sc520cdp_map
(braket
id|i
)braket
dot
id|phys
)paren
suffix:semicolon
id|sc520cdp_map
(braket
id|i
)braket
dot
id|virt
op_assign
id|ioremap_nocache
c_func
(paren
id|sc520cdp_map
(braket
id|i
)braket
dot
id|phys
comma
id|sc520cdp_map
(braket
id|i
)braket
dot
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sc520cdp_map
(braket
id|i
)braket
dot
id|virt
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Failed to ioremap_nocache&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|simple_map_init
c_func
(paren
op_amp
id|sc520cdp_map
(braket
id|i
)braket
)paren
suffix:semicolon
id|mymtd
(braket
id|i
)braket
op_assign
id|do_map_probe
c_func
(paren
l_string|&quot;cfi_probe&quot;
comma
op_amp
id|sc520cdp_map
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mymtd
(braket
id|i
)braket
)paren
(brace
id|mymtd
(braket
id|i
)braket
op_assign
id|do_map_probe
c_func
(paren
l_string|&quot;jedec_probe&quot;
comma
op_amp
id|sc520cdp_map
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mymtd
(braket
id|i
)braket
)paren
(brace
id|mymtd
(braket
id|i
)braket
op_assign
id|do_map_probe
c_func
(paren
l_string|&quot;map_rom&quot;
comma
op_amp
id|sc520cdp_map
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mymtd
(braket
id|i
)braket
)paren
(brace
id|mymtd
(braket
id|i
)braket
op_member_access_from_pointer
id|owner
op_assign
id|THIS_MODULE
suffix:semicolon
op_increment
id|devices_found
suffix:semicolon
)brace
r_else
(brace
id|iounmap
c_func
(paren
id|sc520cdp_map
(braket
id|i
)braket
dot
id|virt
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|devices_found
op_ge
l_int|2
)paren
(brace
multiline_comment|/* Combine the two flash banks into a single MTD device &amp; register it: */
id|merged_mtd
op_assign
id|mtd_concat_create
c_func
(paren
id|mymtd
comma
l_int|2
comma
l_string|&quot;SC520CDP Flash Banks #0 and #1&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|merged_mtd
)paren
(brace
id|add_mtd_device
c_func
(paren
id|merged_mtd
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|devices_found
op_eq
l_int|3
)paren
(brace
multiline_comment|/* register the third (DIL-Flash) device */
id|add_mtd_device
c_func
(paren
id|mymtd
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
r_return
id|devices_found
ques
c_cond
l_int|0
suffix:colon
op_minus
id|ENXIO
suffix:semicolon
)brace
DECL|function|cleanup_sc520cdp
r_static
r_void
id|__exit
id|cleanup_sc520cdp
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|merged_mtd
)paren
(brace
id|del_mtd_device
c_func
(paren
id|merged_mtd
)paren
suffix:semicolon
id|mtd_concat_destroy
c_func
(paren
id|merged_mtd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mymtd
(braket
l_int|2
)braket
)paren
id|del_mtd_device
c_func
(paren
id|mymtd
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_FLASH_BANKS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mymtd
(braket
id|i
)braket
)paren
id|map_destroy
c_func
(paren
id|mymtd
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sc520cdp_map
(braket
id|i
)braket
dot
id|virt
)paren
(brace
id|iounmap
c_func
(paren
id|sc520cdp_map
(braket
id|i
)braket
dot
id|virt
)paren
suffix:semicolon
id|sc520cdp_map
(braket
id|i
)braket
dot
id|virt
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
DECL|variable|init_sc520cdp
id|module_init
c_func
(paren
id|init_sc520cdp
)paren
suffix:semicolon
DECL|variable|cleanup_sc520cdp
id|module_exit
c_func
(paren
id|cleanup_sc520cdp
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Sysgo Real-Time Solutions GmbH&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;MTD map driver for AMD SC520 Customer Development Platform&quot;
)paren
suffix:semicolon
eof
