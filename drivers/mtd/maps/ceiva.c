multiline_comment|/*&n; * Ceiva flash memory driver.&n; * Copyright (C) 2002 Rob Scott &lt;rscott@mtrob.fdns.net&gt;&n; *&n; * Note: this driver supports jedec compatible devices. Modification&n; * for CFI compatible devices should be straight forward: change&n; * jedec_probe to cfi_probe.&n; *&n; * Based on: sa1100-flash.c, which has the following copyright:&n; * Flash memory access on SA11x0 based devices&n; *&n; * (C) 2000 Nicolas Pitre &lt;nico@cam.org&gt;&n; *&n; * $Id: ceiva.c,v 1.8 2003/05/21 12:45:18 dwmw2 Exp $&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/mtd/map.h&gt;
macro_line|#include &lt;linux/mtd/partitions.h&gt;
macro_line|#include &lt;linux/mtd/concat.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;
macro_line|#include &lt;asm/mach-types.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/sizes.h&gt;
multiline_comment|/*&n; * This isn&squot;t complete yet, so...&n; */
DECL|macro|CONFIG_MTD_CEIVA_STATICMAP
mdefine_line|#define CONFIG_MTD_CEIVA_STATICMAP
macro_line|#ifdef CONFIG_MTD_CEIVA_STATICMAP
multiline_comment|/*&n; * See include/linux/mtd/partitions.h for definition of the mtd_partition&n; * structure.&n; *&n; * Please note:&n; *  1. The flash size given should be the largest flash size that can&n; *     be accomodated.&n; *&n; *  2. The bus width must defined in clps_setup_flash.&n; *&n; * The MTD layer will detect flash chip aliasing and reduce the size of&n; * the map accordingly.&n; *&n; */
macro_line|#ifdef CONFIG_ARCH_CEIVA
multiline_comment|/* Flash / Partition sizing */
multiline_comment|/* For the 28F8003, we use the block mapping to calcuate the sizes */
DECL|macro|MAX_SIZE_KiB
mdefine_line|#define MAX_SIZE_KiB                  (16 + 8 + 8 + 96 + (7*128))
DECL|macro|BOOT_PARTITION_SIZE_KiB
mdefine_line|#define BOOT_PARTITION_SIZE_KiB       (16)
DECL|macro|PARAMS_PARTITION_SIZE_KiB
mdefine_line|#define PARAMS_PARTITION_SIZE_KiB     (8)
DECL|macro|KERNEL_PARTITION_SIZE_KiB
mdefine_line|#define KERNEL_PARTITION_SIZE_KiB     (4*128)
multiline_comment|/* Use both remaing portion of first flash, and all of second flash */
DECL|macro|ROOT_PARTITION_SIZE_KiB
mdefine_line|#define ROOT_PARTITION_SIZE_KiB       (3*128) + (8*128)
DECL|variable|ceiva_partitions
r_static
r_struct
id|mtd_partition
id|ceiva_partitions
(braket
)braket
op_assign
(brace
(brace
dot
id|name
op_assign
l_string|&quot;Ceiva BOOT partition&quot;
comma
dot
id|size
op_assign
id|BOOT_PARTITION_SIZE_KiB
op_star
l_int|1024
comma
dot
id|offset
op_assign
l_int|0
comma
)brace
comma
(brace
dot
id|name
op_assign
l_string|&quot;Ceiva parameters partition&quot;
comma
dot
id|size
op_assign
id|PARAMS_PARTITION_SIZE_KiB
op_star
l_int|1024
comma
dot
id|offset
op_assign
(paren
l_int|16
op_plus
l_int|8
)paren
op_star
l_int|1024
comma
)brace
comma
(brace
dot
id|name
op_assign
l_string|&quot;Ceiva kernel partition&quot;
comma
dot
id|size
op_assign
(paren
id|KERNEL_PARTITION_SIZE_KiB
)paren
op_star
l_int|1024
comma
dot
id|offset
op_assign
l_int|0x20000
comma
)brace
comma
(brace
dot
id|name
op_assign
l_string|&quot;Ceiva root filesystem partition&quot;
comma
dot
id|offset
op_assign
id|MTDPART_OFS_APPEND
comma
dot
id|size
op_assign
(paren
id|ROOT_PARTITION_SIZE_KiB
)paren
op_star
l_int|1024
comma
)brace
)brace
suffix:semicolon
macro_line|#endif
DECL|function|clps_static_partitions
r_static
r_int
id|__init
id|clps_static_partitions
c_func
(paren
r_struct
id|mtd_partition
op_star
op_star
id|parts
)paren
(brace
r_int
id|nb_parts
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_ARCH_CEIVA
r_if
c_cond
(paren
id|machine_is_ceiva
c_func
(paren
)paren
)paren
(brace
op_star
id|parts
op_assign
id|ceiva_partitions
suffix:semicolon
id|nb_parts
op_assign
id|ARRAY_SIZE
c_func
(paren
id|ceiva_partitions
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|nb_parts
suffix:semicolon
)brace
macro_line|#endif
DECL|struct|clps_info
r_struct
id|clps_info
(brace
DECL|member|base
r_int
r_int
id|base
suffix:semicolon
DECL|member|size
r_int
r_int
id|size
suffix:semicolon
DECL|member|width
r_int
id|width
suffix:semicolon
DECL|member|vbase
r_void
op_star
id|vbase
suffix:semicolon
DECL|member|map
r_struct
id|map_info
op_star
id|map
suffix:semicolon
DECL|member|mtd
r_struct
id|mtd_info
op_star
id|mtd
suffix:semicolon
DECL|member|res
r_struct
id|resource
op_star
id|res
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|NR_SUBMTD
mdefine_line|#define NR_SUBMTD 4
DECL|variable|info
r_static
r_struct
id|clps_info
id|info
(braket
id|NR_SUBMTD
)braket
suffix:semicolon
DECL|function|clps_setup_mtd
r_static
r_int
id|__init
id|clps_setup_mtd
c_func
(paren
r_struct
id|clps_info
op_star
id|clps
comma
r_int
id|nr
comma
r_struct
id|mtd_info
op_star
op_star
id|rmtd
)paren
(brace
r_struct
id|mtd_info
op_star
id|subdev
(braket
id|nr
)braket
suffix:semicolon
r_struct
id|map_info
op_star
id|maps
suffix:semicolon
r_int
id|i
comma
id|found
op_assign
l_int|0
comma
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate the map_info structs in one go.&n;&t; */
id|maps
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|map_info
)paren
op_star
id|nr
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|maps
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|maps
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|map_info
)paren
op_star
id|nr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Claim and then map the memory regions.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|clps
(braket
id|i
)braket
dot
id|base
op_eq
(paren
r_int
r_int
)paren
op_minus
l_int|1
)paren
r_break
suffix:semicolon
id|clps
(braket
id|i
)braket
dot
id|res
op_assign
id|request_mem_region
c_func
(paren
id|clps
(braket
id|i
)braket
dot
id|base
comma
id|clps
(braket
id|i
)braket
dot
id|size
comma
l_string|&quot;clps flash&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|clps
(braket
id|i
)braket
dot
id|res
)paren
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
)brace
id|clps
(braket
id|i
)braket
dot
id|map
op_assign
id|maps
op_plus
id|i
suffix:semicolon
id|clps
(braket
id|i
)braket
dot
id|map-&gt;name
op_assign
l_string|&quot;clps flash&quot;
suffix:semicolon
id|clps
(braket
id|i
)braket
dot
id|map-&gt;phys
op_assign
id|clps
(braket
id|i
)braket
dot
id|base
suffix:semicolon
id|clps
(braket
id|i
)braket
dot
id|vbase
op_assign
id|ioremap
c_func
(paren
id|clps
(braket
id|i
)braket
dot
id|base
comma
id|clps
(braket
id|i
)braket
dot
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|clps
(braket
id|i
)braket
dot
id|vbase
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|clps
(braket
id|i
)braket
dot
id|map-&gt;virt
op_assign
(paren
r_int
r_int
)paren
id|clps
(braket
id|i
)braket
dot
id|vbase
suffix:semicolon
id|clps
(braket
id|i
)braket
dot
id|map-&gt;buswidth
op_assign
id|clps
(braket
id|i
)braket
dot
id|width
suffix:semicolon
id|clps
(braket
id|i
)braket
dot
id|map-&gt;size
op_assign
id|clps
(braket
id|i
)braket
dot
id|size
suffix:semicolon
id|simple_map_init
c_func
(paren
op_amp
id|clps
(braket
id|i
)braket
dot
id|map
)paren
suffix:semicolon
id|clps
(braket
id|i
)braket
dot
id|mtd
op_assign
id|do_map_probe
c_func
(paren
l_string|&quot;jedec_probe&quot;
comma
id|clps
(braket
id|i
)braket
dot
id|map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clps
(braket
id|i
)braket
dot
id|mtd
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_break
suffix:semicolon
)brace
id|clps
(braket
id|i
)braket
dot
id|mtd-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|subdev
(braket
id|i
)braket
op_assign
id|clps
(braket
id|i
)braket
dot
id|mtd
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;clps flash: JEDEC device at 0x%08lx, %dMiB, &quot;
l_string|&quot;%d-bit&bslash;n&quot;
comma
id|clps
(braket
id|i
)braket
dot
id|base
comma
id|clps
(braket
id|i
)braket
dot
id|mtd-&gt;size
op_rshift
l_int|20
comma
id|clps
(braket
id|i
)braket
dot
id|width
op_star
l_int|8
)paren
suffix:semicolon
id|found
op_add_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * ENXIO is special.  It means we didn&squot;t find a chip when&n;&t; * we probed.  We need to tear down the mapping, free the&n;&t; * resource and mark it as such.&n;&t; */
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|ENXIO
)paren
(brace
id|iounmap
c_func
(paren
id|clps
(braket
id|i
)braket
dot
id|vbase
)paren
suffix:semicolon
id|clps
(braket
id|i
)braket
dot
id|vbase
op_assign
l_int|NULL
suffix:semicolon
id|release_resource
c_func
(paren
id|clps
(braket
id|i
)braket
dot
id|res
)paren
suffix:semicolon
id|clps
(braket
id|i
)braket
dot
id|res
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we found one device, don&squot;t bother with concat support.&n;&t; * If we found multiple devices, use concat if we have it&n;&t; * available, otherwise fail.&n;&t; */
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
op_logical_or
id|ret
op_eq
op_minus
id|ENXIO
)paren
(brace
r_if
c_cond
(paren
id|found
op_eq
l_int|1
)paren
(brace
op_star
id|rmtd
op_assign
id|subdev
(braket
l_int|0
)braket
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|found
OG
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We detected multiple devices.  Concatenate&n;&t;&t;&t; * them together.&n;&t;&t;&t; */
macro_line|#ifdef CONFIG_MTD_CONCAT
op_star
id|rmtd
op_assign
id|mtd_concat_create
c_func
(paren
id|subdev
comma
id|found
comma
l_string|&quot;clps flash&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|rmtd
op_eq
l_int|NULL
)paren
id|ret
op_assign
op_minus
id|ENXIO
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;clps flash: multiple devices &quot;
l_string|&quot;found but MTD concat support disabled.&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENXIO
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/*&n;&t; * If we failed, clean up.&n;&t; */
r_if
c_cond
(paren
id|ret
)paren
(brace
r_do
(brace
r_if
c_cond
(paren
id|clps
(braket
id|i
)braket
dot
id|mtd
)paren
id|map_destroy
c_func
(paren
id|clps
(braket
id|i
)braket
dot
id|mtd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clps
(braket
id|i
)braket
dot
id|vbase
)paren
id|iounmap
c_func
(paren
id|clps
(braket
id|i
)braket
dot
id|vbase
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clps
(braket
id|i
)braket
dot
id|res
)paren
id|release_resource
c_func
(paren
id|clps
(braket
id|i
)braket
dot
id|res
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
op_decrement
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|maps
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|clps_destroy_mtd
r_static
r_void
id|__exit
id|clps_destroy_mtd
c_func
(paren
r_struct
id|clps_info
op_star
id|clps
comma
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_int
id|i
suffix:semicolon
id|del_mtd_partitions
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mtd
op_ne
id|clps
(braket
l_int|0
)braket
dot
id|mtd
)paren
id|mtd_concat_destroy
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|NR_SUBMTD
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|clps
(braket
id|i
)braket
dot
id|mtd
)paren
id|map_destroy
c_func
(paren
id|clps
(braket
id|i
)braket
dot
id|mtd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clps
(braket
id|i
)braket
dot
id|vbase
)paren
id|iounmap
c_func
(paren
id|clps
(braket
id|i
)braket
dot
id|vbase
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clps
(braket
id|i
)braket
dot
id|res
)paren
id|release_resource
c_func
(paren
id|clps
(braket
id|i
)braket
dot
id|res
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|clps
(braket
l_int|0
)braket
dot
id|map
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We define the memory space, size, and width for the flash memory&n; * space here.&n; */
DECL|function|clps_setup_flash
r_static
r_int
id|__init
id|clps_setup_flash
c_func
(paren
r_void
)paren
(brace
r_int
id|nr
suffix:semicolon
macro_line|#ifdef CONFIG_ARCH_CEIVA
r_if
c_cond
(paren
id|machine_is_ceiva
c_func
(paren
)paren
)paren
(brace
id|info
(braket
l_int|0
)braket
dot
id|base
op_assign
id|CS0_PHYS_BASE
suffix:semicolon
id|info
(braket
l_int|0
)braket
dot
id|size
op_assign
id|SZ_32M
suffix:semicolon
id|info
(braket
l_int|0
)braket
dot
id|width
op_assign
id|CEIVA_FLASH_WIDTH
suffix:semicolon
id|info
(braket
l_int|1
)braket
dot
id|base
op_assign
id|CS1_PHYS_BASE
suffix:semicolon
id|info
(braket
l_int|1
)braket
dot
id|size
op_assign
id|SZ_32M
suffix:semicolon
id|info
(braket
l_int|1
)braket
dot
id|width
op_assign
id|CEIVA_FLASH_WIDTH
suffix:semicolon
id|nr
op_assign
l_int|2
suffix:semicolon
)brace
macro_line|#endif
r_return
id|nr
suffix:semicolon
)brace
DECL|variable|parsed_parts
r_static
r_struct
id|mtd_partition
op_star
id|parsed_parts
suffix:semicolon
DECL|variable|probes
r_static
r_const
r_char
op_star
id|probes
(braket
)braket
op_assign
(brace
l_string|&quot;cmdlinepart&quot;
comma
l_string|&quot;RedBoot&quot;
comma
l_int|NULL
)brace
suffix:semicolon
DECL|function|clps_locate_partitions
r_static
r_void
id|__init
id|clps_locate_partitions
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_const
r_char
op_star
id|part_type
op_assign
l_int|NULL
suffix:semicolon
r_int
id|nr_parts
op_assign
l_int|0
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; * Partition selection stuff.&n;&t;&t; */
id|nr_parts
op_assign
id|parse_mtd_partitions
c_func
(paren
id|mtd
comma
id|probes
comma
op_amp
id|parsed_parts
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_parts
OG
l_int|0
)paren
(brace
id|part_type
op_assign
l_string|&quot;command line&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MTD_CEIVA_STATICMAP
id|nr_parts
op_assign
id|clps_static_partitions
c_func
(paren
op_amp
id|parsed_parts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_parts
OG
l_int|0
)paren
(brace
id|part_type
op_assign
l_string|&quot;static&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;found: %d partitions&bslash;n&quot;
comma
id|nr_parts
)paren
suffix:semicolon
macro_line|#endif
)brace
r_while
c_loop
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_parts
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;clps flash: no partition info &quot;
l_string|&quot;available, registering whole flash&bslash;n&quot;
)paren
suffix:semicolon
id|add_mtd_device
c_func
(paren
id|mtd
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;clps flash: using %s partition &quot;
l_string|&quot;definition&bslash;n&quot;
comma
id|part_type
)paren
suffix:semicolon
id|add_mtd_partitions
c_func
(paren
id|mtd
comma
id|parsed_parts
comma
id|nr_parts
)paren
suffix:semicolon
)brace
multiline_comment|/* Always succeeds. */
)brace
DECL|function|clps_destroy_partitions
r_static
r_void
id|__exit
id|clps_destroy_partitions
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|parsed_parts
)paren
id|kfree
c_func
(paren
id|parsed_parts
)paren
suffix:semicolon
)brace
DECL|variable|mymtd
r_static
r_struct
id|mtd_info
op_star
id|mymtd
suffix:semicolon
DECL|function|clps_mtd_init
r_static
r_int
id|__init
id|clps_mtd_init
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|nr
suffix:semicolon
id|nr
op_assign
id|clps_setup_flash
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
OL
l_int|0
)paren
r_return
id|nr
suffix:semicolon
id|ret
op_assign
id|clps_setup_mtd
c_func
(paren
id|info
comma
id|nr
comma
op_amp
id|mymtd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
id|clps_locate_partitions
c_func
(paren
id|mymtd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|clps_mtd_cleanup
r_static
r_void
id|__exit
id|clps_mtd_cleanup
c_func
(paren
r_void
)paren
(brace
id|clps_destroy_mtd
c_func
(paren
id|info
comma
id|mymtd
)paren
suffix:semicolon
id|clps_destroy_partitions
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|clps_mtd_init
id|module_init
c_func
(paren
id|clps_mtd_init
)paren
suffix:semicolon
DECL|variable|clps_mtd_cleanup
id|module_exit
c_func
(paren
id|clps_mtd_cleanup
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Rob Scott&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Cirrus Logic JEDEC map driver&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
