multiline_comment|/* &n; * inftlcore.c -- Linux driver for Inverse Flash Translation Layer (INFTL)&n; *&n; * (C) Copyright 2002, Greg Ungerer (gerg@snapgear.com)&n; *&n; * Based heavily on the nftlcore.c code which is:&n; * (c) 1999 Machine Vision Holdings, Inc.&n; * Author: David Woodhouse &lt;dwmw2@infradead.org&gt;&n; *&n; * $Id: inftlcore.c,v 1.18 2004/11/16 18:28:59 dwmw2 Exp $&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/mtd/nftl.h&gt;
macro_line|#include &lt;linux/mtd/inftl.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/errno.h&gt;
macro_line|#include &lt;asm/io.h&gt;
multiline_comment|/*&n; * Maximum number of loops while examining next block, to have a&n; * chance to detect consistency problems (they should never happen&n; * because of the checks done in the mounting.&n; */
DECL|macro|MAX_LOOPS
mdefine_line|#define MAX_LOOPS 10000
r_extern
r_void
id|INFTL_dumptables
c_func
(paren
r_struct
id|INFTLrecord
op_star
id|inftl
)paren
suffix:semicolon
r_extern
r_void
id|INFTL_dumpVUchains
c_func
(paren
r_struct
id|INFTLrecord
op_star
id|inftl
)paren
suffix:semicolon
DECL|function|inftl_add_mtd
r_static
r_void
id|inftl_add_mtd
c_func
(paren
r_struct
id|mtd_blktrans_ops
op_star
id|tr
comma
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|INFTLrecord
op_star
id|inftl
suffix:semicolon
r_int
r_int
id|temp
suffix:semicolon
r_if
c_cond
(paren
id|mtd-&gt;type
op_ne
id|MTD_NANDFLASH
)paren
r_return
suffix:semicolon
multiline_comment|/* OK, this is moderately ugly.  But probably safe.  Alternatives? */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|mtd-&gt;name
comma
l_string|&quot;DiskOnChip&quot;
comma
l_int|10
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mtd-&gt;block_isbad
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;INFTL no longer supports the old DiskOnChip drivers loaded via docprobe.&bslash;n&quot;
l_string|&quot;Please use the new diskonchip driver under the NAND subsystem.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;INFTL: add_mtd for %s&bslash;n&quot;
comma
id|mtd-&gt;name
)paren
suffix:semicolon
id|inftl
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|inftl
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inftl
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: Out of memory for data structures&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|inftl
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|inftl
)paren
)paren
suffix:semicolon
id|inftl-&gt;mbd.mtd
op_assign
id|mtd
suffix:semicolon
id|inftl-&gt;mbd.devnum
op_assign
op_minus
l_int|1
suffix:semicolon
id|inftl-&gt;mbd.blksize
op_assign
l_int|512
suffix:semicolon
id|inftl-&gt;mbd.tr
op_assign
id|tr
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|inftl-&gt;oobinfo
comma
op_amp
id|mtd-&gt;oobinfo
comma
r_sizeof
(paren
r_struct
id|nand_oobinfo
)paren
)paren
suffix:semicolon
id|inftl-&gt;oobinfo.useecc
op_assign
id|MTD_NANDECC_PLACEONLY
suffix:semicolon
r_if
c_cond
(paren
id|INFTL_mount
c_func
(paren
id|inftl
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: could not mount device&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|inftl
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* OK, it&squot;s a new one. Set up all the data structures. */
multiline_comment|/* Calculate geometry */
id|inftl-&gt;cylinders
op_assign
l_int|1024
suffix:semicolon
id|inftl-&gt;heads
op_assign
l_int|16
suffix:semicolon
id|temp
op_assign
id|inftl-&gt;cylinders
op_star
id|inftl-&gt;heads
suffix:semicolon
id|inftl-&gt;sectors
op_assign
id|inftl-&gt;mbd.size
op_div
id|temp
suffix:semicolon
r_if
c_cond
(paren
id|inftl-&gt;mbd.size
op_mod
id|temp
)paren
(brace
id|inftl-&gt;sectors
op_increment
suffix:semicolon
id|temp
op_assign
id|inftl-&gt;cylinders
op_star
id|inftl-&gt;sectors
suffix:semicolon
id|inftl-&gt;heads
op_assign
id|inftl-&gt;mbd.size
op_div
id|temp
suffix:semicolon
r_if
c_cond
(paren
id|inftl-&gt;mbd.size
op_mod
id|temp
)paren
(brace
id|inftl-&gt;heads
op_increment
suffix:semicolon
id|temp
op_assign
id|inftl-&gt;heads
op_star
id|inftl-&gt;sectors
suffix:semicolon
id|inftl-&gt;cylinders
op_assign
id|inftl-&gt;mbd.size
op_div
id|temp
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|inftl-&gt;mbd.size
op_ne
id|inftl-&gt;heads
op_star
id|inftl-&gt;cylinders
op_star
id|inftl-&gt;sectors
)paren
(brace
multiline_comment|/*&n;&t;&t;  Oh no we don&squot;t have &n;&t;&t;   mbd.size == heads * cylinders * sectors&n;&t;&t;*/
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: cannot calculate a geometry to &quot;
l_string|&quot;match size of 0x%lx.&bslash;n&quot;
comma
id|inftl-&gt;mbd.size
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: using C:%d H:%d S:%d &quot;
l_string|&quot;(== 0x%lx sects)&bslash;n&quot;
comma
id|inftl-&gt;cylinders
comma
id|inftl-&gt;heads
comma
id|inftl-&gt;sectors
comma
(paren
r_int
)paren
id|inftl-&gt;cylinders
op_star
(paren
r_int
)paren
id|inftl-&gt;heads
op_star
(paren
r_int
)paren
id|inftl-&gt;sectors
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|add_mtd_blktrans_dev
c_func
(paren
op_amp
id|inftl-&gt;mbd
)paren
)paren
(brace
r_if
c_cond
(paren
id|inftl-&gt;PUtable
)paren
id|kfree
c_func
(paren
id|inftl-&gt;PUtable
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inftl-&gt;VUtable
)paren
id|kfree
c_func
(paren
id|inftl-&gt;VUtable
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|inftl
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef PSYCHO_DEBUG
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;INFTL: Found new nftl%c&bslash;n&quot;
comma
id|nftl-&gt;mbd.devnum
op_plus
l_char|&squot;a&squot;
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
DECL|function|inftl_remove_dev
r_static
r_void
id|inftl_remove_dev
c_func
(paren
r_struct
id|mtd_blktrans_dev
op_star
id|dev
)paren
(brace
r_struct
id|INFTLrecord
op_star
id|inftl
op_assign
(paren
r_void
op_star
)paren
id|dev
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;INFTL: remove_dev (i=%d)&bslash;n&quot;
comma
id|dev-&gt;devnum
)paren
suffix:semicolon
id|del_mtd_blktrans_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inftl-&gt;PUtable
)paren
id|kfree
c_func
(paren
id|inftl-&gt;PUtable
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inftl-&gt;VUtable
)paren
id|kfree
c_func
(paren
id|inftl-&gt;VUtable
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|inftl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Actual INFTL access routines.&n; */
multiline_comment|/*&n; * INFTL_findfreeblock: Find a free Erase Unit on the INFTL partition.&n; *&t;This function is used when the give Virtual Unit Chain.&n; */
DECL|function|INFTL_findfreeblock
r_static
id|u16
id|INFTL_findfreeblock
c_func
(paren
r_struct
id|INFTLrecord
op_star
id|inftl
comma
r_int
id|desperate
)paren
(brace
id|u16
id|pot
op_assign
id|inftl-&gt;LastFreeEUN
suffix:semicolon
r_int
id|silly
op_assign
id|inftl-&gt;nb_blocks
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;INFTL: INFTL_findfreeblock(inftl=%p,&quot;
l_string|&quot;desperate=%d)&bslash;n&quot;
comma
id|inftl
comma
id|desperate
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Normally, we force a fold to happen before we run out of free&n;&t; * blocks completely.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|desperate
op_logical_and
id|inftl-&gt;numfreeEUNs
OL
l_int|2
)paren
(brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;INFTL: there are too few free &quot;
l_string|&quot;EUNs (%d)&bslash;n&quot;
comma
id|inftl-&gt;numfreeEUNs
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
multiline_comment|/* Scan for a free block */
r_do
(brace
r_if
c_cond
(paren
id|inftl-&gt;PUtable
(braket
id|pot
)braket
op_eq
id|BLOCK_FREE
)paren
(brace
id|inftl-&gt;LastFreeEUN
op_assign
id|pot
suffix:semicolon
r_return
id|pot
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|pot
OG
id|inftl-&gt;lastEUN
)paren
id|pot
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|silly
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: no free blocks found!  &quot;
l_string|&quot;EUN range = %d - %d&bslash;n&quot;
comma
l_int|0
comma
id|inftl-&gt;LastFreeEUN
)paren
suffix:semicolon
r_return
id|BLOCK_NIL
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|pot
op_ne
id|inftl-&gt;LastFreeEUN
)paren
suffix:semicolon
r_return
id|BLOCK_NIL
suffix:semicolon
)brace
DECL|function|INFTL_foldchain
r_static
id|u16
id|INFTL_foldchain
c_func
(paren
r_struct
id|INFTLrecord
op_star
id|inftl
comma
r_int
id|thisVUC
comma
r_int
id|pendingblock
)paren
(brace
id|u16
id|BlockMap
(braket
id|MAX_SECTORS_PER_UNIT
)braket
suffix:semicolon
r_int
r_char
id|BlockDeleted
(braket
id|MAX_SECTORS_PER_UNIT
)braket
suffix:semicolon
r_int
r_int
id|thisEUN
comma
id|prevEUN
comma
id|status
suffix:semicolon
r_int
id|block
comma
id|silly
suffix:semicolon
r_int
r_int
id|targetEUN
suffix:semicolon
r_struct
id|inftl_oob
id|oob
suffix:semicolon
r_int
id|retlen
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;INFTL: INFTL_foldchain(inftl=%p,thisVUC=%d,&quot;
l_string|&quot;pending=%d)&bslash;n&quot;
comma
id|inftl
comma
id|thisVUC
comma
id|pendingblock
)paren
suffix:semicolon
id|memset
c_func
(paren
id|BlockMap
comma
l_int|0xff
comma
r_sizeof
(paren
id|BlockMap
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|BlockDeleted
comma
l_int|0
comma
r_sizeof
(paren
id|BlockDeleted
)paren
)paren
suffix:semicolon
id|thisEUN
op_assign
id|targetEUN
op_assign
id|inftl-&gt;VUtable
(braket
id|thisVUC
)braket
suffix:semicolon
r_if
c_cond
(paren
id|thisEUN
op_eq
id|BLOCK_NIL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: trying to fold non-existent &quot;
l_string|&quot;Virtual Unit Chain %d!&bslash;n&quot;
comma
id|thisVUC
)paren
suffix:semicolon
r_return
id|BLOCK_NIL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Scan to find the Erase Unit which holds the actual data for each&n;&t; * 512-byte block within the Chain.&n;&t; */
id|silly
op_assign
id|MAX_LOOPS
suffix:semicolon
r_while
c_loop
(paren
id|thisEUN
OL
id|inftl-&gt;nb_blocks
)paren
(brace
r_for
c_loop
(paren
id|block
op_assign
l_int|0
suffix:semicolon
id|block
OL
id|inftl-&gt;EraseSize
op_div
id|SECTORSIZE
suffix:semicolon
id|block
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|BlockMap
(braket
id|block
)braket
op_ne
l_int|0xffff
)paren
op_logical_or
id|BlockDeleted
(braket
id|block
)braket
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|MTD_READOOB
c_func
(paren
id|inftl-&gt;mbd.mtd
comma
(paren
id|thisEUN
op_star
id|inftl-&gt;EraseSize
)paren
op_plus
(paren
id|block
op_star
id|SECTORSIZE
)paren
comma
l_int|16
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob
)paren
OL
l_int|0
)paren
id|status
op_assign
id|SECTOR_IGNORE
suffix:semicolon
r_else
id|status
op_assign
id|oob.b.Status
op_or
id|oob.b.Status1
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|SECTOR_FREE
suffix:colon
r_case
id|SECTOR_IGNORE
suffix:colon
r_break
suffix:semicolon
r_case
id|SECTOR_USED
suffix:colon
id|BlockMap
(braket
id|block
)braket
op_assign
id|thisEUN
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|SECTOR_DELETED
suffix:colon
id|BlockDeleted
(braket
id|block
)braket
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: unknown status &quot;
l_string|&quot;for block %d in EUN %d: %x&bslash;n&quot;
comma
id|block
comma
id|thisEUN
comma
id|status
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|silly
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: infinite loop in Virtual &quot;
l_string|&quot;Unit Chain 0x%x&bslash;n&quot;
comma
id|thisVUC
)paren
suffix:semicolon
r_return
id|BLOCK_NIL
suffix:semicolon
)brace
id|thisEUN
op_assign
id|inftl-&gt;PUtable
(braket
id|thisEUN
)braket
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * OK. We now know the location of every block in the Virtual Unit&n;&t; * Chain, and the Erase Unit into which we are supposed to be copying.&n;&t; * Go for it.&n;&t; */
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;INFTL: folding chain %d into unit %d&bslash;n&quot;
comma
id|thisVUC
comma
id|targetEUN
)paren
suffix:semicolon
r_for
c_loop
(paren
id|block
op_assign
l_int|0
suffix:semicolon
id|block
OL
id|inftl-&gt;EraseSize
op_div
id|SECTORSIZE
suffix:semicolon
id|block
op_increment
)paren
(brace
r_int
r_char
id|movebuf
(braket
id|SECTORSIZE
)braket
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If it&squot;s in the target EUN already, or if it&squot;s pending write,&n;&t;&t; * do nothing.&n;&t;&t; */
r_if
c_cond
(paren
id|BlockMap
(braket
id|block
)braket
op_eq
id|targetEUN
op_logical_or
(paren
id|pendingblock
op_eq
(paren
id|thisVUC
op_star
(paren
id|inftl-&gt;EraseSize
op_div
id|SECTORSIZE
)paren
op_plus
id|block
)paren
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Copy only in non free block (free blocks can only&n;                 * happen in case of media errors or deleted blocks).&n;&t;&t; */
r_if
c_cond
(paren
id|BlockMap
(braket
id|block
)braket
op_eq
id|BLOCK_NIL
)paren
r_continue
suffix:semicolon
id|ret
op_assign
id|MTD_READ
c_func
(paren
id|inftl-&gt;mbd.mtd
comma
(paren
id|inftl-&gt;EraseSize
op_star
id|BlockMap
(braket
id|block
)braket
)paren
op_plus
(paren
id|block
op_star
id|SECTORSIZE
)paren
comma
id|SECTORSIZE
comma
op_amp
id|retlen
comma
id|movebuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|ret
op_assign
id|MTD_READ
c_func
(paren
id|inftl-&gt;mbd.mtd
comma
(paren
id|inftl-&gt;EraseSize
op_star
id|BlockMap
(braket
id|block
)braket
)paren
op_plus
(paren
id|block
op_star
id|SECTORSIZE
)paren
comma
id|SECTORSIZE
comma
op_amp
id|retlen
comma
id|movebuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
op_minus
id|EIO
)paren
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;INFTL: error went &quot;
l_string|&quot;away on retry?&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|oob
comma
l_int|0xff
comma
r_sizeof
(paren
r_struct
id|inftl_oob
)paren
)paren
suffix:semicolon
id|oob.b.Status
op_assign
id|oob.b.Status1
op_assign
id|SECTOR_USED
suffix:semicolon
id|MTD_WRITEECC
c_func
(paren
id|inftl-&gt;mbd.mtd
comma
(paren
id|inftl-&gt;EraseSize
op_star
id|targetEUN
)paren
op_plus
(paren
id|block
op_star
id|SECTORSIZE
)paren
comma
id|SECTORSIZE
comma
op_amp
id|retlen
comma
id|movebuf
comma
(paren
r_char
op_star
)paren
op_amp
id|oob
comma
op_amp
id|inftl-&gt;oobinfo
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Newest unit in chain now contains data from _all_ older units.&n;&t; * So go through and erase each unit in chain, oldest first. (This&n;&t; * is important, by doing oldest first if we crash/reboot then it&n;&t; * it is relatively simple to clean up the mess).&n;&t; */
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;INFTL: want to erase virtual chain %d&bslash;n&quot;
comma
id|thisVUC
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* Find oldest unit in chain. */
id|thisEUN
op_assign
id|inftl-&gt;VUtable
(braket
id|thisVUC
)braket
suffix:semicolon
id|prevEUN
op_assign
id|BLOCK_NIL
suffix:semicolon
r_while
c_loop
(paren
id|inftl-&gt;PUtable
(braket
id|thisEUN
)braket
op_ne
id|BLOCK_NIL
)paren
(brace
id|prevEUN
op_assign
id|thisEUN
suffix:semicolon
id|thisEUN
op_assign
id|inftl-&gt;PUtable
(braket
id|thisEUN
)braket
suffix:semicolon
)brace
multiline_comment|/* Check if we are all done */
r_if
c_cond
(paren
id|thisEUN
op_eq
id|targetEUN
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|INFTL_formatblock
c_func
(paren
id|inftl
comma
id|thisEUN
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Could not erase : mark block as reserved.&n;&t;&t;&t; */
id|inftl-&gt;PUtable
(braket
id|thisEUN
)braket
op_assign
id|BLOCK_RESERVED
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Correctly erased : mark it as free */
id|inftl-&gt;PUtable
(braket
id|thisEUN
)braket
op_assign
id|BLOCK_FREE
suffix:semicolon
id|inftl-&gt;PUtable
(braket
id|prevEUN
)braket
op_assign
id|BLOCK_NIL
suffix:semicolon
id|inftl-&gt;numfreeEUNs
op_increment
suffix:semicolon
)brace
)brace
r_return
id|targetEUN
suffix:semicolon
)brace
DECL|function|INFTL_makefreeblock
r_static
id|u16
id|INFTL_makefreeblock
c_func
(paren
r_struct
id|INFTLrecord
op_star
id|inftl
comma
r_int
id|pendingblock
)paren
(brace
multiline_comment|/*&n;&t; * This is the part that needs some cleverness applied. &n;&t; * For now, I&squot;m doing the minimum applicable to actually&n;&t; * get the thing to work.&n;&t; * Wear-levelling and other clever stuff needs to be implemented&n;&t; * and we also need to do some assessment of the results when&n;&t; * the system loses power half-way through the routine.&n;&t; */
id|u16
id|LongestChain
op_assign
l_int|0
suffix:semicolon
id|u16
id|ChainLength
op_assign
l_int|0
comma
id|thislen
suffix:semicolon
id|u16
id|chain
comma
id|EUN
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;INFTL: INFTL_makefreeblock(inftl=%p,&quot;
l_string|&quot;pending=%d)&bslash;n&quot;
comma
id|inftl
comma
id|pendingblock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|chain
op_assign
l_int|0
suffix:semicolon
id|chain
OL
id|inftl-&gt;nb_blocks
suffix:semicolon
id|chain
op_increment
)paren
(brace
id|EUN
op_assign
id|inftl-&gt;VUtable
(braket
id|chain
)braket
suffix:semicolon
id|thislen
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|EUN
op_le
id|inftl-&gt;lastEUN
)paren
(brace
id|thislen
op_increment
suffix:semicolon
id|EUN
op_assign
id|inftl-&gt;PUtable
(braket
id|EUN
)braket
suffix:semicolon
r_if
c_cond
(paren
id|thislen
OG
l_int|0xff00
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: endless loop in &quot;
l_string|&quot;Virtual Chain %d: Unit %x&bslash;n&quot;
comma
id|chain
comma
id|EUN
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Actually, don&squot;t return failure.&n;&t;&t;&t;&t; * Just ignore this chain and get on with it.&n;&t;&t;&t;&t; */
id|thislen
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|thislen
OG
id|ChainLength
)paren
(brace
id|ChainLength
op_assign
id|thislen
suffix:semicolon
id|LongestChain
op_assign
id|chain
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ChainLength
OL
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: no Virtual Unit Chains available &quot;
l_string|&quot;for folding. Failing request&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|BLOCK_NIL
suffix:semicolon
)brace
r_return
id|INFTL_foldchain
c_func
(paren
id|inftl
comma
id|LongestChain
comma
id|pendingblock
)paren
suffix:semicolon
)brace
DECL|function|nrbits
r_static
r_int
id|nrbits
c_func
(paren
r_int
r_int
id|val
comma
r_int
id|bitcount
)paren
(brace
r_int
id|i
comma
id|total
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|bitcount
)paren
suffix:semicolon
id|i
op_increment
)paren
id|total
op_add_assign
(paren
(paren
(paren
l_int|0x1
op_lshift
id|i
)paren
op_amp
id|val
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
r_return
id|total
suffix:semicolon
)brace
multiline_comment|/*&n; * INFTL_findwriteunit: Return the unit number into which we can write &n; *                      for this block. Make it available if it isn&squot;t already.&n; */
DECL|function|INFTL_findwriteunit
r_static
r_inline
id|u16
id|INFTL_findwriteunit
c_func
(paren
r_struct
id|INFTLrecord
op_star
id|inftl
comma
r_int
id|block
)paren
(brace
r_int
r_int
id|thisVUC
op_assign
id|block
op_div
(paren
id|inftl-&gt;EraseSize
op_div
id|SECTORSIZE
)paren
suffix:semicolon
r_int
r_int
id|thisEUN
comma
id|writeEUN
comma
id|prev_block
comma
id|status
suffix:semicolon
r_int
r_int
id|blockofs
op_assign
(paren
id|block
op_star
id|SECTORSIZE
)paren
op_amp
(paren
id|inftl-&gt;EraseSize
op_minus
l_int|1
)paren
suffix:semicolon
r_struct
id|inftl_oob
id|oob
suffix:semicolon
r_struct
id|inftl_bci
id|bci
suffix:semicolon
r_int
r_char
id|anac
comma
id|nacs
comma
id|parity
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_int
id|silly
comma
id|silly2
op_assign
l_int|3
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;INFTL: INFTL_findwriteunit(inftl=%p,&quot;
l_string|&quot;block=%d)&bslash;n&quot;
comma
id|inftl
comma
id|block
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; * Scan the media to find a unit in the VUC which has&n;&t;&t; * a free space for the block in question.&n;&t;&t; */
id|writeEUN
op_assign
id|BLOCK_NIL
suffix:semicolon
id|thisEUN
op_assign
id|inftl-&gt;VUtable
(braket
id|thisVUC
)braket
suffix:semicolon
id|silly
op_assign
id|MAX_LOOPS
suffix:semicolon
r_while
c_loop
(paren
id|thisEUN
op_le
id|inftl-&gt;lastEUN
)paren
(brace
id|MTD_READOOB
c_func
(paren
id|inftl-&gt;mbd.mtd
comma
(paren
id|thisEUN
op_star
id|inftl-&gt;EraseSize
)paren
op_plus
id|blockofs
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|bci
)paren
suffix:semicolon
id|status
op_assign
id|bci.Status
op_or
id|bci.Status1
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;INFTL: status of block %d in &quot;
l_string|&quot;EUN %d is %x&bslash;n&quot;
comma
id|block
comma
id|writeEUN
comma
id|status
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|SECTOR_FREE
suffix:colon
id|writeEUN
op_assign
id|thisEUN
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SECTOR_DELETED
suffix:colon
r_case
id|SECTOR_USED
suffix:colon
multiline_comment|/* Can&squot;t go any further */
r_goto
id|hitused
suffix:semicolon
r_case
id|SECTOR_IGNORE
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Invalid block. Don&squot;t use it any more.&n;&t;&t;&t;&t; * Must implement.&n;&t;&t;&t;&t; */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|silly
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: infinite loop in &quot;
l_string|&quot;Virtual Unit Chain 0x%x&bslash;n&quot;
comma
id|thisVUC
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
multiline_comment|/* Skip to next block in chain */
id|thisEUN
op_assign
id|inftl-&gt;PUtable
(braket
id|thisEUN
)braket
suffix:semicolon
)brace
id|hitused
suffix:colon
r_if
c_cond
(paren
id|writeEUN
op_ne
id|BLOCK_NIL
)paren
r_return
id|writeEUN
suffix:semicolon
multiline_comment|/*&n;&t;&t; * OK. We didn&squot;t find one in the existing chain, or there &n;&t;&t; * is no existing chain. Allocate a new one.&n;&t;&t; */
id|writeEUN
op_assign
id|INFTL_findfreeblock
c_func
(paren
id|inftl
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|writeEUN
op_eq
id|BLOCK_NIL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * That didn&squot;t work - there were no free blocks just&n;&t;&t;&t; * waiting to be picked up. We&squot;re going to have to fold&n;&t;&t;&t; * a chain to make room.&n;&t;&t;&t; */
id|thisEUN
op_assign
id|INFTL_makefreeblock
c_func
(paren
id|inftl
comma
l_int|0xffff
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Hopefully we free something, lets try again.&n;&t;&t;&t; * This time we are desperate...&n;&t;&t;&t; */
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;INFTL: using desperate==1 &quot;
l_string|&quot;to find free EUN to accommodate write to &quot;
l_string|&quot;VUC %d&bslash;n&quot;
comma
id|thisVUC
)paren
suffix:semicolon
id|writeEUN
op_assign
id|INFTL_findfreeblock
c_func
(paren
id|inftl
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|writeEUN
op_eq
id|BLOCK_NIL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Ouch. This should never happen - we should&n;&t;&t;&t;&t; * always be able to make some room somehow. &n;&t;&t;&t;&t; * If we get here, we&squot;ve allocated more storage &n;&t;&t;&t;&t; * space than actual media, or our makefreeblock&n;&t;&t;&t;&t; * routine is missing something.&n;&t;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: cannot make free &quot;
l_string|&quot;space.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|INFTL_dumptables
c_func
(paren
id|inftl
)paren
suffix:semicolon
id|INFTL_dumpVUchains
c_func
(paren
id|inftl
)paren
suffix:semicolon
macro_line|#endif
r_return
id|BLOCK_NIL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Insert new block into virtual chain. Firstly update the&n;&t;&t; * block headers in flash...&n;&t;&t; */
id|anac
op_assign
l_int|0
suffix:semicolon
id|nacs
op_assign
l_int|0
suffix:semicolon
id|thisEUN
op_assign
id|inftl-&gt;VUtable
(braket
id|thisVUC
)braket
suffix:semicolon
r_if
c_cond
(paren
id|thisEUN
op_ne
id|BLOCK_NIL
)paren
(brace
id|MTD_READOOB
c_func
(paren
id|inftl-&gt;mbd.mtd
comma
id|thisEUN
op_star
id|inftl-&gt;EraseSize
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob.u
)paren
suffix:semicolon
id|anac
op_assign
id|oob.u.a.ANAC
op_plus
l_int|1
suffix:semicolon
id|nacs
op_assign
id|oob.u.a.NACs
op_plus
l_int|1
suffix:semicolon
)brace
id|prev_block
op_assign
id|inftl-&gt;VUtable
(braket
id|thisVUC
)braket
suffix:semicolon
r_if
c_cond
(paren
id|prev_block
OL
id|inftl-&gt;nb_blocks
)paren
id|prev_block
op_sub_assign
id|inftl-&gt;firstEUN
suffix:semicolon
id|parity
op_assign
(paren
id|nrbits
c_func
(paren
id|thisVUC
comma
l_int|16
)paren
op_amp
l_int|0x1
)paren
ques
c_cond
l_int|0x1
suffix:colon
l_int|0
suffix:semicolon
id|parity
op_or_assign
(paren
id|nrbits
c_func
(paren
id|prev_block
comma
l_int|16
)paren
op_amp
l_int|0x1
)paren
ques
c_cond
l_int|0x2
suffix:colon
l_int|0
suffix:semicolon
id|parity
op_or_assign
(paren
id|nrbits
c_func
(paren
id|anac
comma
l_int|8
)paren
op_amp
l_int|0x1
)paren
ques
c_cond
l_int|0x4
suffix:colon
l_int|0
suffix:semicolon
id|parity
op_or_assign
(paren
id|nrbits
c_func
(paren
id|nacs
comma
l_int|8
)paren
op_amp
l_int|0x1
)paren
ques
c_cond
l_int|0x8
suffix:colon
l_int|0
suffix:semicolon
id|oob.u.a.virtualUnitNo
op_assign
id|cpu_to_le16
c_func
(paren
id|thisVUC
)paren
suffix:semicolon
id|oob.u.a.prevUnitNo
op_assign
id|cpu_to_le16
c_func
(paren
id|prev_block
)paren
suffix:semicolon
id|oob.u.a.ANAC
op_assign
id|anac
suffix:semicolon
id|oob.u.a.NACs
op_assign
id|nacs
suffix:semicolon
id|oob.u.a.parityPerField
op_assign
id|parity
suffix:semicolon
id|oob.u.a.discarded
op_assign
l_int|0xaa
suffix:semicolon
id|MTD_WRITEOOB
c_func
(paren
id|inftl-&gt;mbd.mtd
comma
id|writeEUN
op_star
id|inftl-&gt;EraseSize
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob.u
)paren
suffix:semicolon
multiline_comment|/* Also back up header... */
id|oob.u.b.virtualUnitNo
op_assign
id|cpu_to_le16
c_func
(paren
id|thisVUC
)paren
suffix:semicolon
id|oob.u.b.prevUnitNo
op_assign
id|cpu_to_le16
c_func
(paren
id|prev_block
)paren
suffix:semicolon
id|oob.u.b.ANAC
op_assign
id|anac
suffix:semicolon
id|oob.u.b.NACs
op_assign
id|nacs
suffix:semicolon
id|oob.u.b.parityPerField
op_assign
id|parity
suffix:semicolon
id|oob.u.b.discarded
op_assign
l_int|0xaa
suffix:semicolon
id|MTD_WRITEOOB
c_func
(paren
id|inftl-&gt;mbd.mtd
comma
id|writeEUN
op_star
id|inftl-&gt;EraseSize
op_plus
id|SECTORSIZE
op_star
l_int|4
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob.u
)paren
suffix:semicolon
id|inftl-&gt;PUtable
(braket
id|writeEUN
)braket
op_assign
id|inftl-&gt;VUtable
(braket
id|thisVUC
)braket
suffix:semicolon
id|inftl-&gt;VUtable
(braket
id|thisVUC
)braket
op_assign
id|writeEUN
suffix:semicolon
id|inftl-&gt;numfreeEUNs
op_decrement
suffix:semicolon
r_return
id|writeEUN
suffix:semicolon
)brace
r_while
c_loop
(paren
id|silly2
op_decrement
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: error folding to make room for Virtual &quot;
l_string|&quot;Unit Chain 0x%x&bslash;n&quot;
comma
id|thisVUC
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
multiline_comment|/*&n; * Given a Virtual Unit Chain, see if it can be deleted, and if so do it.&n; */
DECL|function|INFTL_trydeletechain
r_static
r_void
id|INFTL_trydeletechain
c_func
(paren
r_struct
id|INFTLrecord
op_star
id|inftl
comma
r_int
id|thisVUC
)paren
(brace
r_int
r_char
id|BlockUsed
(braket
id|MAX_SECTORS_PER_UNIT
)braket
suffix:semicolon
r_int
r_char
id|BlockDeleted
(braket
id|MAX_SECTORS_PER_UNIT
)braket
suffix:semicolon
r_int
r_int
id|thisEUN
comma
id|status
suffix:semicolon
r_int
id|block
comma
id|silly
suffix:semicolon
r_struct
id|inftl_bci
id|bci
suffix:semicolon
r_int
id|retlen
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;INFTL: INFTL_trydeletechain(inftl=%p,&quot;
l_string|&quot;thisVUC=%d)&bslash;n&quot;
comma
id|inftl
comma
id|thisVUC
)paren
suffix:semicolon
id|memset
c_func
(paren
id|BlockUsed
comma
l_int|0
comma
r_sizeof
(paren
id|BlockUsed
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|BlockDeleted
comma
l_int|0
comma
r_sizeof
(paren
id|BlockDeleted
)paren
)paren
suffix:semicolon
id|thisEUN
op_assign
id|inftl-&gt;VUtable
(braket
id|thisVUC
)braket
suffix:semicolon
r_if
c_cond
(paren
id|thisEUN
op_eq
id|BLOCK_NIL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: trying to delete non-existent &quot;
l_string|&quot;Virtual Unit Chain %d!&bslash;n&quot;
comma
id|thisVUC
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Scan through the Erase Units to determine whether any data is in&n;&t; * each of the 512-byte blocks within the Chain.&n;&t; */
id|silly
op_assign
id|MAX_LOOPS
suffix:semicolon
r_while
c_loop
(paren
id|thisEUN
OL
id|inftl-&gt;nb_blocks
)paren
(brace
r_for
c_loop
(paren
id|block
op_assign
l_int|0
suffix:semicolon
id|block
OL
id|inftl-&gt;EraseSize
op_div
id|SECTORSIZE
suffix:semicolon
id|block
op_increment
)paren
(brace
r_if
c_cond
(paren
id|BlockUsed
(braket
id|block
)braket
op_logical_or
id|BlockDeleted
(braket
id|block
)braket
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|MTD_READOOB
c_func
(paren
id|inftl-&gt;mbd.mtd
comma
(paren
id|thisEUN
op_star
id|inftl-&gt;EraseSize
)paren
op_plus
(paren
id|block
op_star
id|SECTORSIZE
)paren
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|bci
)paren
OL
l_int|0
)paren
id|status
op_assign
id|SECTOR_IGNORE
suffix:semicolon
r_else
id|status
op_assign
id|bci.Status
op_or
id|bci.Status1
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|SECTOR_FREE
suffix:colon
r_case
id|SECTOR_IGNORE
suffix:colon
r_break
suffix:semicolon
r_case
id|SECTOR_USED
suffix:colon
id|BlockUsed
(braket
id|block
)braket
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|SECTOR_DELETED
suffix:colon
id|BlockDeleted
(braket
id|block
)braket
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: unknown status &quot;
l_string|&quot;for block %d in EUN %d: 0x%x&bslash;n&quot;
comma
id|block
comma
id|thisEUN
comma
id|status
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|silly
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: infinite loop in Virtual &quot;
l_string|&quot;Unit Chain 0x%x&bslash;n&quot;
comma
id|thisVUC
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|thisEUN
op_assign
id|inftl-&gt;PUtable
(braket
id|thisEUN
)braket
suffix:semicolon
)brace
r_for
c_loop
(paren
id|block
op_assign
l_int|0
suffix:semicolon
id|block
OL
id|inftl-&gt;EraseSize
op_div
id|SECTORSIZE
suffix:semicolon
id|block
op_increment
)paren
r_if
c_cond
(paren
id|BlockUsed
(braket
id|block
)braket
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * For each block in the chain free it and make it available&n;&t; * for future use. Erase from the oldest unit first.&n;&t; */
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;INFTL: deleting empty VUC %d&bslash;n&quot;
comma
id|thisVUC
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|u16
op_star
id|prevEUN
op_assign
op_amp
id|inftl-&gt;VUtable
(braket
id|thisVUC
)braket
suffix:semicolon
id|thisEUN
op_assign
op_star
id|prevEUN
suffix:semicolon
multiline_comment|/* If the chain is all gone already, we&squot;re done */
r_if
c_cond
(paren
id|thisEUN
op_eq
id|BLOCK_NIL
)paren
(brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL2
comma
l_string|&quot;INFTL: Empty VUC %d for deletion was already absent&bslash;n&quot;
comma
id|thisEUN
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Find oldest unit in chain. */
r_while
c_loop
(paren
id|inftl-&gt;PUtable
(braket
id|thisEUN
)braket
op_ne
id|BLOCK_NIL
)paren
(brace
id|BUG_ON
c_func
(paren
id|thisEUN
op_ge
id|inftl-&gt;nb_blocks
)paren
suffix:semicolon
id|prevEUN
op_assign
op_amp
id|inftl-&gt;PUtable
(braket
id|thisEUN
)braket
suffix:semicolon
id|thisEUN
op_assign
op_star
id|prevEUN
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;Deleting EUN %d from VUC %d&bslash;n&quot;
comma
id|thisEUN
comma
id|thisVUC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INFTL_formatblock
c_func
(paren
id|inftl
comma
id|thisEUN
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Could not erase : mark block as reserved.&n;&t;&t;&t; */
id|inftl-&gt;PUtable
(braket
id|thisEUN
)braket
op_assign
id|BLOCK_RESERVED
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Correctly erased : mark it as free */
id|inftl-&gt;PUtable
(braket
id|thisEUN
)braket
op_assign
id|BLOCK_FREE
suffix:semicolon
id|inftl-&gt;numfreeEUNs
op_increment
suffix:semicolon
)brace
multiline_comment|/* Now sort out whatever was pointing to it... */
op_star
id|prevEUN
op_assign
id|BLOCK_NIL
suffix:semicolon
multiline_comment|/* Ideally we&squot;d actually be responsive to new&n;&t;&t;   requests while we&squot;re doing this -- if there&squot;s&n;&t;&t;   free space why should others be made to wait? */
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
)brace
id|inftl-&gt;VUtable
(braket
id|thisVUC
)braket
op_assign
id|BLOCK_NIL
suffix:semicolon
)brace
DECL|function|INFTL_deleteblock
r_static
r_int
id|INFTL_deleteblock
c_func
(paren
r_struct
id|INFTLrecord
op_star
id|inftl
comma
r_int
id|block
)paren
(brace
r_int
r_int
id|thisEUN
op_assign
id|inftl-&gt;VUtable
(braket
id|block
op_div
(paren
id|inftl-&gt;EraseSize
op_div
id|SECTORSIZE
)paren
)braket
suffix:semicolon
r_int
r_int
id|blockofs
op_assign
(paren
id|block
op_star
id|SECTORSIZE
)paren
op_amp
(paren
id|inftl-&gt;EraseSize
op_minus
l_int|1
)paren
suffix:semicolon
r_int
r_int
id|status
suffix:semicolon
r_int
id|silly
op_assign
id|MAX_LOOPS
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_struct
id|inftl_bci
id|bci
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;INFTL: INFTL_deleteblock(inftl=%p,&quot;
l_string|&quot;block=%d)&bslash;n&quot;
comma
id|inftl
comma
id|block
)paren
suffix:semicolon
r_while
c_loop
(paren
id|thisEUN
OL
id|inftl-&gt;nb_blocks
)paren
(brace
r_if
c_cond
(paren
id|MTD_READOOB
c_func
(paren
id|inftl-&gt;mbd.mtd
comma
(paren
id|thisEUN
op_star
id|inftl-&gt;EraseSize
)paren
op_plus
id|blockofs
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|bci
)paren
OL
l_int|0
)paren
id|status
op_assign
id|SECTOR_IGNORE
suffix:semicolon
r_else
id|status
op_assign
id|bci.Status
op_or
id|bci.Status1
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|SECTOR_FREE
suffix:colon
r_case
id|SECTOR_IGNORE
suffix:colon
r_break
suffix:semicolon
r_case
id|SECTOR_DELETED
suffix:colon
id|thisEUN
op_assign
id|BLOCK_NIL
suffix:semicolon
r_goto
id|foundit
suffix:semicolon
r_case
id|SECTOR_USED
suffix:colon
r_goto
id|foundit
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: unknown status for &quot;
l_string|&quot;block %d in EUN %d: 0x%x&bslash;n&quot;
comma
id|block
comma
id|thisEUN
comma
id|status
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|silly
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: infinite loop in Virtual &quot;
l_string|&quot;Unit Chain 0x%x&bslash;n&quot;
comma
id|block
op_div
(paren
id|inftl-&gt;EraseSize
op_div
id|SECTORSIZE
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|thisEUN
op_assign
id|inftl-&gt;PUtable
(braket
id|thisEUN
)braket
suffix:semicolon
)brace
id|foundit
suffix:colon
r_if
c_cond
(paren
id|thisEUN
op_ne
id|BLOCK_NIL
)paren
(brace
id|loff_t
id|ptr
op_assign
(paren
id|thisEUN
op_star
id|inftl-&gt;EraseSize
)paren
op_plus
id|blockofs
suffix:semicolon
r_if
c_cond
(paren
id|MTD_READOOB
c_func
(paren
id|inftl-&gt;mbd.mtd
comma
id|ptr
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|bci
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|bci.Status
op_assign
id|bci.Status1
op_assign
id|SECTOR_DELETED
suffix:semicolon
r_if
c_cond
(paren
id|MTD_WRITEOOB
c_func
(paren
id|inftl-&gt;mbd.mtd
comma
id|ptr
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|bci
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|INFTL_trydeletechain
c_func
(paren
id|inftl
comma
id|block
op_div
(paren
id|inftl-&gt;EraseSize
op_div
id|SECTORSIZE
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|inftl_writeblock
r_static
r_int
id|inftl_writeblock
c_func
(paren
r_struct
id|mtd_blktrans_dev
op_star
id|mbd
comma
r_int
r_int
id|block
comma
r_char
op_star
id|buffer
)paren
(brace
r_struct
id|INFTLrecord
op_star
id|inftl
op_assign
(paren
r_void
op_star
)paren
id|mbd
suffix:semicolon
r_int
r_int
id|writeEUN
suffix:semicolon
r_int
r_int
id|blockofs
op_assign
(paren
id|block
op_star
id|SECTORSIZE
)paren
op_amp
(paren
id|inftl-&gt;EraseSize
op_minus
l_int|1
)paren
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_struct
id|inftl_oob
id|oob
suffix:semicolon
r_char
op_star
id|p
comma
op_star
id|pend
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;INFTL: inftl_writeblock(inftl=%p,block=%ld,&quot;
l_string|&quot;buffer=%p)&bslash;n&quot;
comma
id|inftl
comma
id|block
comma
id|buffer
)paren
suffix:semicolon
multiline_comment|/* Is block all zero? */
id|pend
op_assign
id|buffer
op_plus
id|SECTORSIZE
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|buffer
suffix:semicolon
id|p
OL
id|pend
op_logical_and
op_logical_neg
op_star
id|p
suffix:semicolon
id|p
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
OL
id|pend
)paren
(brace
id|writeEUN
op_assign
id|INFTL_findwriteunit
c_func
(paren
id|inftl
comma
id|block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|writeEUN
op_eq
id|BLOCK_NIL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;inftl_writeblock(): cannot find &quot;
l_string|&quot;block to write to&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If we _still_ haven&squot;t got a block to use,&n;&t;&t;&t; * we&squot;re screwed.&n;&t;&t;&t; */
r_return
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|oob
comma
l_int|0xff
comma
r_sizeof
(paren
r_struct
id|inftl_oob
)paren
)paren
suffix:semicolon
id|oob.b.Status
op_assign
id|oob.b.Status1
op_assign
id|SECTOR_USED
suffix:semicolon
id|MTD_WRITEECC
c_func
(paren
id|inftl-&gt;mbd.mtd
comma
(paren
id|writeEUN
op_star
id|inftl-&gt;EraseSize
)paren
op_plus
id|blockofs
comma
id|SECTORSIZE
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
id|buffer
comma
(paren
r_char
op_star
)paren
op_amp
id|oob
comma
op_amp
id|inftl-&gt;oobinfo
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * need to write SECTOR_USED flags since they are not written&n;&t;&t; * in mtd_writeecc&n;&t;&t; */
)brace
r_else
(brace
id|INFTL_deleteblock
c_func
(paren
id|inftl
comma
id|block
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|inftl_readblock
r_static
r_int
id|inftl_readblock
c_func
(paren
r_struct
id|mtd_blktrans_dev
op_star
id|mbd
comma
r_int
r_int
id|block
comma
r_char
op_star
id|buffer
)paren
(brace
r_struct
id|INFTLrecord
op_star
id|inftl
op_assign
(paren
r_void
op_star
)paren
id|mbd
suffix:semicolon
r_int
r_int
id|thisEUN
op_assign
id|inftl-&gt;VUtable
(braket
id|block
op_div
(paren
id|inftl-&gt;EraseSize
op_div
id|SECTORSIZE
)paren
)braket
suffix:semicolon
r_int
r_int
id|blockofs
op_assign
(paren
id|block
op_star
id|SECTORSIZE
)paren
op_amp
(paren
id|inftl-&gt;EraseSize
op_minus
l_int|1
)paren
suffix:semicolon
r_int
r_int
id|status
suffix:semicolon
r_int
id|silly
op_assign
id|MAX_LOOPS
suffix:semicolon
r_struct
id|inftl_bci
id|bci
suffix:semicolon
r_int
id|retlen
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;INFTL: inftl_readblock(inftl=%p,block=%ld,&quot;
l_string|&quot;buffer=%p)&bslash;n&quot;
comma
id|inftl
comma
id|block
comma
id|buffer
)paren
suffix:semicolon
r_while
c_loop
(paren
id|thisEUN
OL
id|inftl-&gt;nb_blocks
)paren
(brace
r_if
c_cond
(paren
id|MTD_READOOB
c_func
(paren
id|inftl-&gt;mbd.mtd
comma
(paren
id|thisEUN
op_star
id|inftl-&gt;EraseSize
)paren
op_plus
id|blockofs
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|bci
)paren
OL
l_int|0
)paren
id|status
op_assign
id|SECTOR_IGNORE
suffix:semicolon
r_else
id|status
op_assign
id|bci.Status
op_or
id|bci.Status1
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|SECTOR_DELETED
suffix:colon
id|thisEUN
op_assign
id|BLOCK_NIL
suffix:semicolon
r_goto
id|foundit
suffix:semicolon
r_case
id|SECTOR_USED
suffix:colon
r_goto
id|foundit
suffix:semicolon
r_case
id|SECTOR_FREE
suffix:colon
r_case
id|SECTOR_IGNORE
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: unknown status for &quot;
l_string|&quot;block %ld in EUN %d: 0x%04x&bslash;n&quot;
comma
id|block
comma
id|thisEUN
comma
id|status
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|silly
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;INFTL: infinite loop in &quot;
l_string|&quot;Virtual Unit Chain 0x%lx&bslash;n&quot;
comma
id|block
op_div
(paren
id|inftl-&gt;EraseSize
op_div
id|SECTORSIZE
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|thisEUN
op_assign
id|inftl-&gt;PUtable
(braket
id|thisEUN
)braket
suffix:semicolon
)brace
id|foundit
suffix:colon
r_if
c_cond
(paren
id|thisEUN
op_eq
id|BLOCK_NIL
)paren
(brace
multiline_comment|/* The requested block is not on the media, return all 0x00 */
id|memset
c_func
(paren
id|buffer
comma
l_int|0
comma
id|SECTORSIZE
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|retlen
suffix:semicolon
id|loff_t
id|ptr
op_assign
(paren
id|thisEUN
op_star
id|inftl-&gt;EraseSize
)paren
op_plus
id|blockofs
suffix:semicolon
r_if
c_cond
(paren
id|MTD_READ
c_func
(paren
id|inftl-&gt;mbd.mtd
comma
id|ptr
comma
id|SECTORSIZE
comma
op_amp
id|retlen
comma
id|buffer
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|inftl_getgeo
r_static
r_int
id|inftl_getgeo
c_func
(paren
r_struct
id|mtd_blktrans_dev
op_star
id|dev
comma
r_struct
id|hd_geometry
op_star
id|geo
)paren
(brace
r_struct
id|INFTLrecord
op_star
id|inftl
op_assign
(paren
r_void
op_star
)paren
id|dev
suffix:semicolon
id|geo-&gt;heads
op_assign
id|inftl-&gt;heads
suffix:semicolon
id|geo-&gt;sectors
op_assign
id|inftl-&gt;sectors
suffix:semicolon
id|geo-&gt;cylinders
op_assign
id|inftl-&gt;cylinders
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|inftl_tr
r_static
r_struct
id|mtd_blktrans_ops
id|inftl_tr
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;inftl&quot;
comma
dot
id|major
op_assign
id|INFTL_MAJOR
comma
dot
id|part_bits
op_assign
id|INFTL_PARTN_BITS
comma
dot
id|getgeo
op_assign
id|inftl_getgeo
comma
dot
id|readsect
op_assign
id|inftl_readblock
comma
dot
id|writesect
op_assign
id|inftl_writeblock
comma
dot
id|add_mtd
op_assign
id|inftl_add_mtd
comma
dot
id|remove_dev
op_assign
id|inftl_remove_dev
comma
dot
id|owner
op_assign
id|THIS_MODULE
comma
)brace
suffix:semicolon
r_extern
r_char
id|inftlmountrev
(braket
)braket
suffix:semicolon
DECL|function|init_inftl
r_static
r_int
id|__init
id|init_inftl
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;INFTL: inftlcore.c $Revision: 1.18 $, &quot;
l_string|&quot;inftlmount.c %s&bslash;n&quot;
comma
id|inftlmountrev
)paren
suffix:semicolon
r_return
id|register_mtd_blktrans
c_func
(paren
op_amp
id|inftl_tr
)paren
suffix:semicolon
)brace
DECL|function|cleanup_inftl
r_static
r_void
id|__exit
id|cleanup_inftl
c_func
(paren
r_void
)paren
(brace
id|deregister_mtd_blktrans
c_func
(paren
op_amp
id|inftl_tr
)paren
suffix:semicolon
)brace
DECL|variable|init_inftl
id|module_init
c_func
(paren
id|init_inftl
)paren
suffix:semicolon
DECL|variable|cleanup_inftl
id|module_exit
c_func
(paren
id|cleanup_inftl
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Greg Ungerer &lt;gerg@snapgear.com&gt;, David Woodhouse &lt;dwmw2@infradead.org&gt;, Fabrice Bellard &lt;fabrice.bellard@netgem.com&gt; et al.&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Support code for Inverse Flash Translation Layer, used on M-Systems DiskOnChip 2000, Millennium and Millennium Plus&quot;
)paren
suffix:semicolon
eof
