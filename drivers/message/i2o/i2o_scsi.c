multiline_comment|/*&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * For the avoidance of doubt the &quot;preferred form&quot; of this code is one which&n; * is in an open non patent encumbered format. Where cryptographic key signing&n; * forms part of the process of creating an executable the information&n; * including keys needed to generate an equivalently functional executable&n; * are deemed to be part of the source code.&n; *&n; *  Complications for I2O scsi&n; *&n; *&t;o&t;Each (bus,lun) is a logical device in I2O. We keep a map&n; *&t;&t;table. We spoof failed selection for unmapped units&n; *&t;o&t;Request sense buffers can come back for free.&n; *&t;o&t;Scatter gather is a bit dynamic. We have to investigate at&n; *&t;&t;setup time.&n; *&t;o&t;Some of our resources are dynamically shared. The i2o core&n; *&t;&t;needs a message reservation protocol to avoid swap v net&n; *&t;&t;deadlocking. We need to back off queue requests.&n; *&n; *&t;In general the firmware wants to help. Where its help isn&squot;t performance&n; *&t;useful we just ignore the aid. Its not worth the code in truth.&n; *&n; * Fixes/additions:&n; *&t;Steve Ralston:&n; *&t;&t;Scatter gather now works&n; *&t;Markus Lidel &lt;Markus.Lidel@shadowconnect.com&gt;:&n; *&t;&t;Minor fixes for 2.6.&n; *&n; * To Do:&n; *&t;64bit cleanups&n; *&t;Fix the resource management problems.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/jiffies.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/prefetch.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/i2o.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;scsi/scsi.h&gt;
macro_line|#include &lt;scsi/scsi_host.h&gt;
macro_line|#include &lt;scsi/scsi_device.h&gt;
macro_line|#include &lt;scsi/scsi_cmnd.h&gt;
DECL|macro|VERSION_STRING
mdefine_line|#define VERSION_STRING        &quot;Version 0.1.2&quot;
DECL|variable|i2o_scsi_driver
r_static
r_struct
id|i2o_driver
id|i2o_scsi_driver
suffix:semicolon
DECL|variable|i2o_scsi_max_id
r_static
r_int
id|i2o_scsi_max_id
op_assign
l_int|16
suffix:semicolon
DECL|variable|i2o_scsi_max_lun
r_static
r_int
id|i2o_scsi_max_lun
op_assign
l_int|8
suffix:semicolon
DECL|struct|i2o_scsi_host
r_struct
id|i2o_scsi_host
(brace
DECL|member|scsi_host
r_struct
id|Scsi_Host
op_star
id|scsi_host
suffix:semicolon
multiline_comment|/* pointer to the SCSI host */
DECL|member|iop
r_struct
id|i2o_controller
op_star
id|iop
suffix:semicolon
multiline_comment|/* pointer to the I2O controller */
DECL|member|channel
r_struct
id|i2o_device
op_star
id|channel
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* channel-&gt;i2o_dev mapping table */
)brace
suffix:semicolon
DECL|variable|i2o_scsi_host_template
r_static
r_struct
id|scsi_host_template
id|i2o_scsi_host_template
suffix:semicolon
DECL|macro|I2O_SCSI_CAN_QUEUE
mdefine_line|#define I2O_SCSI_CAN_QUEUE&t;4
multiline_comment|/* SCSI OSM class handling definition */
DECL|variable|i2o_scsi_class_id
r_static
r_struct
id|i2o_class_id
id|i2o_scsi_class_id
(braket
)braket
op_assign
(brace
(brace
id|I2O_CLASS_SCSI_PERIPHERAL
)brace
comma
(brace
id|I2O_CLASS_END
)brace
)brace
suffix:semicolon
DECL|function|i2o_scsi_host_alloc
r_static
r_struct
id|i2o_scsi_host
op_star
id|i2o_scsi_host_alloc
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
)paren
(brace
r_struct
id|i2o_scsi_host
op_star
id|i2o_shost
suffix:semicolon
r_struct
id|i2o_device
op_star
id|i2o_dev
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|scsi_host
suffix:semicolon
r_int
id|max_channel
op_assign
l_int|0
suffix:semicolon
id|u8
id|type
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|size
suffix:semicolon
id|i2o_status_block
op_star
id|sb
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|i2o_dev
comma
op_amp
id|c-&gt;devices
comma
id|list
)paren
r_if
c_cond
(paren
id|i2o_dev-&gt;lct_data.class_id
op_eq
id|I2O_CLASS_BUS_ADAPTER_PORT
)paren
(brace
r_if
c_cond
(paren
id|i2o_parm_field_get
c_func
(paren
id|i2o_dev
comma
l_int|0x0000
comma
l_int|0
comma
op_amp
id|type
comma
l_int|1
)paren
op_logical_or
(paren
id|type
op_eq
l_int|1
)paren
)paren
multiline_comment|/* SCSI bus */
id|max_channel
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|max_channel
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi-osm: no channels found on %s&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
id|size
op_assign
id|max_channel
op_star
r_sizeof
(paren
r_struct
id|i2o_device
op_star
)paren
op_plus
r_sizeof
(paren
r_struct
id|i2o_scsi_host
)paren
suffix:semicolon
id|scsi_host
op_assign
id|scsi_host_alloc
c_func
(paren
op_amp
id|i2o_scsi_host_template
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_host
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi-osm: Could not allocate SCSI host&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|scsi_host-&gt;max_channel
op_assign
id|max_channel
op_minus
l_int|1
suffix:semicolon
id|scsi_host-&gt;max_id
op_assign
id|i2o_scsi_max_id
suffix:semicolon
id|scsi_host-&gt;max_lun
op_assign
id|i2o_scsi_max_lun
suffix:semicolon
id|scsi_host-&gt;this_id
op_assign
id|c-&gt;unit
suffix:semicolon
id|sb
op_assign
id|c-&gt;status_block.virt
suffix:semicolon
id|scsi_host-&gt;sg_tablesize
op_assign
(paren
id|sb-&gt;inbound_frame_size
op_minus
r_sizeof
(paren
r_struct
id|i2o_message
)paren
op_div
l_int|4
op_minus
l_int|6
)paren
op_div
l_int|2
suffix:semicolon
id|i2o_shost
op_assign
(paren
r_struct
id|i2o_scsi_host
op_star
)paren
id|scsi_host-&gt;hostdata
suffix:semicolon
id|i2o_shost-&gt;scsi_host
op_assign
id|scsi_host
suffix:semicolon
id|i2o_shost-&gt;iop
op_assign
id|c
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|i2o_dev
comma
op_amp
id|c-&gt;devices
comma
id|list
)paren
r_if
c_cond
(paren
id|i2o_dev-&gt;lct_data.class_id
op_eq
id|I2O_CLASS_BUS_ADAPTER_PORT
)paren
(brace
r_if
c_cond
(paren
id|i2o_parm_field_get
c_func
(paren
id|i2o_dev
comma
l_int|0x0000
comma
l_int|0
comma
op_amp
id|type
comma
l_int|1
)paren
op_logical_or
(paren
id|type
op_eq
l_int|1
)paren
)paren
multiline_comment|/* only SCSI bus */
id|i2o_shost-&gt;channel
(braket
id|i
op_increment
)braket
op_assign
id|i2o_dev
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|max_channel
)paren
r_break
suffix:semicolon
)brace
r_return
id|i2o_shost
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/**&n; *&t;i2o_scsi_get_host - Get an I2O SCSI host&n; *&t;@c: I2O controller to for which to get the SCSI host&n; *&n; *&t;If the I2O controller already exists as SCSI host, the SCSI host&n; *&t;is returned, otherwise the I2O controller is added to the SCSI&n; *&t;core.&n; *&n; *&t;Returns pointer to the I2O SCSI host on success or NULL on failure.&n; */
DECL|function|i2o_scsi_get_host
r_static
r_struct
id|i2o_scsi_host
op_star
id|i2o_scsi_get_host
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
)paren
(brace
r_return
id|c-&gt;driver_data
(braket
id|i2o_scsi_driver.context
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/**&n; *&t;i2o_scsi_remove - Remove I2O device from SCSI core&n; *&t;@dev: device which should be removed&n; *&n; *&t;Removes the I2O device from the SCSI core again.&n; *&n; *&t;Returns 0 on success.&n; */
DECL|function|i2o_scsi_remove
r_static
r_int
id|i2o_scsi_remove
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|i2o_device
op_star
id|i2o_dev
op_assign
id|to_i2o_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|i2o_controller
op_star
id|c
op_assign
id|i2o_dev-&gt;iop
suffix:semicolon
r_struct
id|i2o_scsi_host
op_star
id|i2o_shost
suffix:semicolon
r_struct
id|scsi_device
op_star
id|scsi_dev
suffix:semicolon
id|i2o_shost
op_assign
id|i2o_scsi_get_host
c_func
(paren
id|c
)paren
suffix:semicolon
id|shost_for_each_device
c_func
(paren
id|scsi_dev
comma
id|i2o_shost-&gt;scsi_host
)paren
r_if
c_cond
(paren
id|scsi_dev-&gt;hostdata
op_eq
id|i2o_dev
)paren
(brace
id|scsi_remove_device
c_func
(paren
id|scsi_dev
)paren
suffix:semicolon
id|scsi_device_put
c_func
(paren
id|scsi_dev
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/**&n; *&t;i2o_scsi_probe - verify if dev is a I2O SCSI device and install it&n; *&t;@dev: device to verify if it is a I2O SCSI device&n; *&n; *&t;Retrieve channel, id and lun for I2O device. If everthing goes well&n; *&t;register the I2O device as SCSI device on the I2O SCSI controller.&n; *&n; *&t;Returns 0 on success or negative error code on failure.&n; */
DECL|function|i2o_scsi_probe
r_static
r_int
id|i2o_scsi_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|i2o_device
op_star
id|i2o_dev
op_assign
id|to_i2o_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|i2o_controller
op_star
id|c
op_assign
id|i2o_dev-&gt;iop
suffix:semicolon
r_struct
id|i2o_scsi_host
op_star
id|i2o_shost
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|scsi_host
suffix:semicolon
r_struct
id|i2o_device
op_star
id|parent
suffix:semicolon
r_struct
id|scsi_device
op_star
id|scsi_dev
suffix:semicolon
id|u32
id|id
suffix:semicolon
id|u64
id|lun
suffix:semicolon
r_int
id|channel
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|i
suffix:semicolon
id|i2o_shost
op_assign
id|i2o_scsi_get_host
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i2o_shost
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|scsi_host
op_assign
id|i2o_shost-&gt;scsi_host
suffix:semicolon
r_if
c_cond
(paren
id|i2o_parm_field_get
c_func
(paren
id|i2o_dev
comma
l_int|0
comma
l_int|3
comma
op_amp
id|id
comma
l_int|4
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|id
op_ge
id|scsi_host-&gt;max_id
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi-osm: SCSI device id (%d) &gt;= max_id &quot;
l_string|&quot;of I2O host (%d)&quot;
comma
id|id
comma
id|scsi_host-&gt;max_id
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i2o_parm_field_get
c_func
(paren
id|i2o_dev
comma
l_int|0
comma
l_int|4
comma
op_amp
id|lun
comma
l_int|8
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|lun
op_ge
id|scsi_host-&gt;max_lun
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi-osm: SCSI device id (%d) &gt;= max_lun &quot;
l_string|&quot;of I2O host (%d)&quot;
comma
(paren
r_int
r_int
)paren
id|lun
comma
id|scsi_host-&gt;max_lun
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|parent
op_assign
id|i2o_iop_find_device
c_func
(paren
id|c
comma
id|i2o_dev-&gt;lct_data.parent_tid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi-osm: can not find parent of device &quot;
l_string|&quot;%03x&bslash;n&quot;
comma
id|i2o_dev-&gt;lct_data.tid
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|i2o_shost-&gt;scsi_host-&gt;max_channel
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|i2o_shost-&gt;channel
(braket
id|i
)braket
op_eq
id|parent
)paren
id|channel
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi-osm: can not find channel of device &quot;
l_string|&quot;%03x&bslash;n&quot;
comma
id|i2o_dev-&gt;lct_data.tid
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|scsi_dev
op_assign
id|__scsi_add_device
c_func
(paren
id|i2o_shost-&gt;scsi_host
comma
id|channel
comma
id|id
comma
id|lun
comma
id|i2o_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_dev
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi-osm: can not add SCSI device &quot;
l_string|&quot;%03x&bslash;n&quot;
comma
id|i2o_dev-&gt;lct_data.tid
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|pr_debug
c_func
(paren
l_string|&quot;Added new SCSI device %03x (cannel: %d, id: %d, lun: %d)&bslash;n&quot;
comma
id|i2o_dev-&gt;lct_data.tid
comma
id|channel
comma
id|id
comma
(paren
r_int
r_int
)paren
id|lun
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
suffix:semicolon
DECL|function|i2o_scsi_info
r_static
r_const
r_char
op_star
id|i2o_scsi_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|SChost
)paren
(brace
r_struct
id|i2o_scsi_host
op_star
id|hostdata
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|i2o_scsi_host
op_star
)paren
id|SChost-&gt;hostdata
suffix:semicolon
r_return
id|hostdata-&gt;iop-&gt;name
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_scsi_reply - SCSI OSM message reply handler&n; *&t;@c: controller issuing the reply&n; *&t;@m: message id for flushing&n; *&t;@msg: the message from the controller&n; *&n; *&t;Process reply messages (interrupts in normal scsi controller think).&n; *&t;We can get a variety of messages to process. The normal path is&n; *&t;scsi command completions. We must also deal with IOP failures,&n; *&t;the reply to a bus reset and the reply to a LUN query.&n; *&n; *&t;Returns 0 on success and if the reply should not be flushed or &gt; 0&n; *&t;on success and if the reply should be flushed. Returns negative error&n; *&t;code on failure and if the reply should be flushed.&n; */
DECL|function|i2o_scsi_reply
r_static
r_int
id|i2o_scsi_reply
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
comma
id|u32
id|m
comma
r_struct
id|i2o_message
op_star
id|msg
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|cmd
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
id|u8
id|as
comma
id|ds
comma
id|st
suffix:semicolon
id|cmd
op_assign
id|i2o_cntxt_list_get
c_func
(paren
id|c
comma
id|readl
c_func
(paren
op_amp
id|msg-&gt;u.s.tcntxt
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;u.head
(braket
l_int|0
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|13
)paren
)paren
(brace
r_struct
id|i2o_message
op_star
id|pmsg
suffix:semicolon
multiline_comment|/* preserved message */
id|u32
id|pm
suffix:semicolon
id|pm
op_assign
id|readl
c_func
(paren
op_amp
id|msg-&gt;body
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|pmsg
op_assign
id|c-&gt;in_queue.virt
op_plus
id|pm
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;IOP fail.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;From %d To %d Cmd %d.&bslash;n&quot;
comma
(paren
id|msg-&gt;u.head
(braket
l_int|1
)braket
op_rshift
l_int|12
)paren
op_amp
l_int|0xFFF
comma
id|msg-&gt;u.head
(braket
l_int|1
)braket
op_amp
l_int|0xFFF
comma
id|msg-&gt;u.head
(braket
l_int|1
)braket
op_rshift
l_int|24
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Failure Code %d.&bslash;n&quot;
comma
id|msg-&gt;body
(braket
l_int|0
)braket
op_rshift
l_int|24
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;body
(braket
l_int|0
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|16
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Format error.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;body
(braket
l_int|0
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|17
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Path error.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;body
(braket
l_int|0
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|18
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Path State.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;body
(braket
l_int|0
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|18
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Congestion.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Failing message is %p.&bslash;n&quot;
comma
id|pmsg
)paren
suffix:semicolon
id|cmd
op_assign
id|i2o_cntxt_list_get
c_func
(paren
id|c
comma
id|readl
c_func
(paren
op_amp
id|pmsg-&gt;u.s.tcntxt
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
r_return
l_int|1
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/* Now flush the message by making it a NOP */
id|i2o_msg_nop
c_func
(paren
id|c
comma
id|pm
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      Low byte is device status, next is adapter status,&n;&t; *      (then one byte reserved), then request status.&n;&t; */
id|ds
op_assign
(paren
id|u8
)paren
id|readl
c_func
(paren
op_amp
id|msg-&gt;body
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|as
op_assign
(paren
id|u8
)paren
(paren
id|readl
c_func
(paren
op_amp
id|msg-&gt;body
(braket
l_int|0
)braket
)paren
op_rshift
l_int|8
)paren
suffix:semicolon
id|st
op_assign
(paren
id|u8
)paren
(paren
id|readl
c_func
(paren
op_amp
id|msg-&gt;body
(braket
l_int|0
)braket
)paren
op_rshift
l_int|24
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      Is this a control request coming back - eg an abort ?&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|st
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;SCSI abort: %08X&quot;
comma
id|readl
c_func
(paren
op_amp
id|msg-&gt;body
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;SCSI abort completed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|pr_debug
c_func
(paren
l_string|&quot;Completed %ld&bslash;n&quot;
comma
id|cmd-&gt;serial_number
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
(brace
id|u32
id|count
comma
id|error
suffix:semicolon
multiline_comment|/* An error has occurred */
r_switch
c_cond
(paren
id|st
)paren
(brace
r_case
l_int|0x06
suffix:colon
id|count
op_assign
id|readl
c_func
(paren
op_amp
id|msg-&gt;body
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
id|cmd-&gt;underflow
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;SCSI: underflow 0x%08X 0x%08X&quot;
l_string|&quot;&bslash;n&quot;
comma
id|count
comma
id|cmd-&gt;underflow
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Cmd: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|15
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%02X &quot;
comma
id|cmd-&gt;cmnd
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
id|readl
c_func
(paren
op_amp
id|msg-&gt;body
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;scsi-osm: SCSI error %08x&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_amp
l_int|0xff
)paren
op_eq
l_int|0x02
multiline_comment|/*CHECK_CONDITION */
)paren
(brace
r_int
id|i
suffix:semicolon
id|u32
id|len
op_assign
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
suffix:semicolon
id|len
op_assign
(paren
id|len
OG
l_int|40
)paren
ques
c_cond
l_int|40
suffix:colon
id|len
suffix:semicolon
singleline_comment|// Copy over the sense data
id|memcpy
c_func
(paren
id|cmd-&gt;sense_buffer
comma
(paren
r_void
op_star
)paren
op_amp
id|msg-&gt;body
(braket
l_int|3
)braket
comma
id|len
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|len
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%02x&bslash;n&quot;
comma
id|cmd-&gt;sense_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;sense_buffer
(braket
l_int|0
)braket
op_eq
l_int|0x70
op_logical_and
id|cmd-&gt;sense_buffer
(braket
l_int|2
)braket
op_eq
id|DATA_PROTECT
)paren
(brace
multiline_comment|/* This is to handle an array failed */
id|cmd-&gt;result
op_assign
(paren
id|DID_TIME_OUT
op_lshift
l_int|16
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: SCSI Data &quot;
l_string|&quot;Protect-Device (%d,%d,%d) &quot;
l_string|&quot;hba_status=0x%x, dev_status=&quot;
l_string|&quot;0x%x, cmd=0x%x&bslash;n&quot;
comma
id|c-&gt;name
comma
(paren
id|u32
)paren
id|cmd-&gt;device-&gt;channel
comma
(paren
id|u32
)paren
id|cmd-&gt;device-&gt;id
comma
(paren
id|u32
)paren
id|cmd-&gt;device-&gt;lun
comma
(paren
id|error
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
id|error
op_amp
l_int|0xff
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_else
id|cmd-&gt;result
op_assign
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|as
)paren
(brace
r_case
l_int|0x0E
suffix:colon
multiline_comment|/* SCSI Reset */
id|cmd-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0F
suffix:colon
id|cmd-&gt;result
op_assign
id|DID_PARITY
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|cmd-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|cmd-&gt;result
op_assign
id|DID_OK
op_lshift
l_int|16
op_or
id|ds
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|dev
op_assign
op_amp
id|c-&gt;pdev-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
id|dma_unmap_sg
c_func
(paren
id|dev
comma
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;buffer
comma
id|cmd-&gt;use_sg
comma
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
)paren
id|dma_unmap_single
c_func
(paren
id|dev
comma
(paren
id|dma_addr_t
)paren
(paren
(paren
r_int
)paren
id|cmd-&gt;SCp.ptr
)paren
comma
id|cmd-&gt;request_bufflen
comma
id|cmd-&gt;sc_data_direction
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/**&n; *&t;i2o_scsi_notify_controller_add - Retrieve notifications of added&n; *&t;&t;&t;&t;&t; controllers&n; *&t;@c: the controller which was added&n; *&n; *&t;If a I2O controller is added, we catch the notification to add a&n; *&t;corresponding Scsi_Host.&n; */
DECL|function|i2o_scsi_notify_controller_add
r_void
id|i2o_scsi_notify_controller_add
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
)paren
(brace
r_struct
id|i2o_scsi_host
op_star
id|i2o_shost
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|i2o_shost
op_assign
id|i2o_scsi_host_alloc
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|i2o_shost
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;scsi-osm: Could not initialize&quot;
l_string|&quot; SCSI host&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rc
op_assign
id|scsi_add_host
c_func
(paren
id|i2o_shost-&gt;scsi_host
comma
op_amp
id|c-&gt;device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;scsi-osm: Could not add SCSI &quot;
l_string|&quot;host&bslash;n&quot;
)paren
suffix:semicolon
id|scsi_host_put
c_func
(paren
id|i2o_shost-&gt;scsi_host
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|c-&gt;driver_data
(braket
id|i2o_scsi_driver.context
)braket
op_assign
id|i2o_shost
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;new I2O SCSI host added&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/**&n; *&t;i2o_scsi_notify_controller_remove - Retrieve notifications of removed&n; *&t;&t;&t;&t;&t;    controllers&n; *&t;@c: the controller which was removed&n; *&n; *&t;If a I2O controller is removed, we catch the notification to remove the&n; *&t;corresponding Scsi_Host.&n; */
DECL|function|i2o_scsi_notify_controller_remove
r_void
id|i2o_scsi_notify_controller_remove
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
)paren
(brace
r_struct
id|i2o_scsi_host
op_star
id|i2o_shost
suffix:semicolon
id|i2o_shost
op_assign
id|i2o_scsi_get_host
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i2o_shost
)paren
r_return
suffix:semicolon
id|c-&gt;driver_data
(braket
id|i2o_scsi_driver.context
)braket
op_assign
l_int|NULL
suffix:semicolon
id|scsi_remove_host
c_func
(paren
id|i2o_shost-&gt;scsi_host
)paren
suffix:semicolon
id|scsi_host_put
c_func
(paren
id|i2o_shost-&gt;scsi_host
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;I2O SCSI host removed&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* SCSI OSM driver struct */
DECL|variable|i2o_scsi_driver
r_static
r_struct
id|i2o_driver
id|i2o_scsi_driver
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;scsi-osm&quot;
comma
dot
id|reply
op_assign
id|i2o_scsi_reply
comma
dot
id|classes
op_assign
id|i2o_scsi_class_id
comma
dot
id|notify_controller_add
op_assign
id|i2o_scsi_notify_controller_add
comma
dot
id|notify_controller_remove
op_assign
id|i2o_scsi_notify_controller_remove
comma
dot
id|driver
op_assign
(brace
dot
id|probe
op_assign
id|i2o_scsi_probe
comma
dot
id|remove
op_assign
id|i2o_scsi_remove
comma
)brace
comma
)brace
suffix:semicolon
multiline_comment|/**&n; *&t;i2o_scsi_queuecommand - queue a SCSI command&n; *&t;@SCpnt: scsi command pointer&n; *&t;@done: callback for completion&n; *&n; *&t;Issue a scsi command asynchronously. Return 0 on success or 1 if&n; *&t;we hit an error (normally message queue congestion). The only&n; *&t;minor complication here is that I2O deals with the device addressing&n; *&t;so we have to map the bus/dev/lun back to an I2O handle as well&n; *&t;as faking absent devices ourself.&n; *&n; *&t;Locks: takes the controller lock on error path only&n; */
DECL|function|i2o_scsi_queuecommand
r_static
r_int
id|i2o_scsi_queuecommand
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
r_struct
id|scsi_cmnd
op_star
)paren
)paren
(brace
r_struct
id|i2o_controller
op_star
id|c
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
r_struct
id|i2o_device
op_star
id|i2o_dev
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_int
id|tid
suffix:semicolon
r_struct
id|i2o_message
op_star
id|msg
suffix:semicolon
id|u32
id|m
suffix:semicolon
id|u32
id|scsi_flags
comma
id|sg_flags
suffix:semicolon
id|u32
op_star
id|mptr
comma
op_star
id|lenptr
suffix:semicolon
id|u32
id|len
comma
id|reqlen
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; *      Do the incoming paperwork&n;&t; */
id|i2o_dev
op_assign
id|SCpnt-&gt;device-&gt;hostdata
suffix:semicolon
id|host
op_assign
id|SCpnt-&gt;device-&gt;host
suffix:semicolon
id|c
op_assign
id|i2o_dev-&gt;iop
suffix:semicolon
id|dev
op_assign
op_amp
id|c-&gt;pdev-&gt;dev
suffix:semicolon
id|SCpnt-&gt;scsi_done
op_assign
id|done
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|i2o_dev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi-osm: no I2O device in request&bslash;n&quot;
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
id|done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|tid
op_assign
id|i2o_dev-&gt;lct_data.tid
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;qcmd: Tid = %03x&bslash;n&quot;
comma
id|tid
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;Real scsi messages.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      Obtain an I2O message. If there are none free then&n;&t; *      throw it back to the scsi layer&n;&t; */
id|m
op_assign
id|i2o_msg_get_wait
c_func
(paren
id|c
comma
op_amp
id|msg
comma
id|I2O_TIMEOUT_MESSAGE_GET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
op_eq
id|I2O_QUEUE_EMPTY
)paren
r_return
id|SCSI_MLQUEUE_HOST_BUSY
suffix:semicolon
multiline_comment|/*&n;&t; *      Put together a scsi execscb message&n;&t; */
id|len
op_assign
id|SCpnt-&gt;request_bufflen
suffix:semicolon
r_switch
c_cond
(paren
id|SCpnt-&gt;sc_data_direction
)paren
(brace
r_case
id|PCI_DMA_NONE
suffix:colon
id|scsi_flags
op_assign
l_int|0x00000000
suffix:semicolon
singleline_comment|// DATA NO XFER
id|sg_flags
op_assign
l_int|0x00000000
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCI_DMA_TODEVICE
suffix:colon
id|scsi_flags
op_assign
l_int|0x80000000
suffix:semicolon
singleline_comment|// DATA OUT (iop--&gt;dev)
id|sg_flags
op_assign
l_int|0x14000000
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCI_DMA_FROMDEVICE
suffix:colon
id|scsi_flags
op_assign
l_int|0x40000000
suffix:semicolon
singleline_comment|// DATA IN  (iop&lt;--dev)
id|sg_flags
op_assign
l_int|0x10000000
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Unknown - kill the command */
id|SCpnt-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
id|done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|writel
c_func
(paren
id|I2O_CMD_SCSI_EXEC
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|tid
comma
op_amp
id|msg-&gt;u.head
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|writel
c_func
(paren
id|i2o_scsi_driver.context
comma
op_amp
id|msg-&gt;u.s.icntxt
)paren
suffix:semicolon
multiline_comment|/* We want the SCSI control block back */
id|writel
c_func
(paren
id|i2o_cntxt_list_add
c_func
(paren
id|c
comma
id|SCpnt
)paren
comma
op_amp
id|msg-&gt;u.s.tcntxt
)paren
suffix:semicolon
multiline_comment|/* LSI_920_PCI_QUIRK&n;&t; *&n;&t; *      Intermittant observations of msg frame word data corruption&n;&t; *      observed on msg[4] after:&n;&t; *        WRITE, READ-MODIFY-WRITE&n;&t; *      operations.  19990606 -sralston&n;&t; *&n;&t; *      (Hence we build this word via tag. Its good practice anyway&n;&t; *       we don&squot;t want fetches over PCI needlessly)&n;&t; */
multiline_comment|/* Attach tags to the devices */
multiline_comment|/*&n;&t;   if(SCpnt-&gt;device-&gt;tagged_supported) {&n;&t;   if(SCpnt-&gt;tag == HEAD_OF_QUEUE_TAG)&n;&t;   scsi_flags |= 0x01000000;&n;&t;   else if(SCpnt-&gt;tag == ORDERED_QUEUE_TAG)&n;&t;   scsi_flags |= 0x01800000;&n;&t;   }&n;&t; */
multiline_comment|/* Direction, disconnect ok, tag, CDBLen */
id|writel
c_func
(paren
id|scsi_flags
op_or
l_int|0x20200000
op_or
id|SCpnt-&gt;cmd_len
comma
op_amp
id|msg-&gt;body
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|mptr
op_assign
op_amp
id|msg-&gt;body
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Write SCSI command into the message - always 16 byte block */
id|memcpy_toio
c_func
(paren
id|mptr
comma
id|SCpnt-&gt;cmnd
comma
l_int|16
)paren
suffix:semicolon
id|mptr
op_add_assign
l_int|4
suffix:semicolon
id|lenptr
op_assign
id|mptr
op_increment
suffix:semicolon
multiline_comment|/* Remember me - fill in when we know */
id|reqlen
op_assign
l_int|12
suffix:semicolon
singleline_comment|// SINGLE SGE
multiline_comment|/* Now fill in the SGList and command */
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
)paren
(brace
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
r_int
id|sg_count
suffix:semicolon
id|sg
op_assign
id|SCpnt-&gt;request_buffer
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
id|sg_count
op_assign
id|dma_map_sg
c_func
(paren
id|dev
comma
id|sg
comma
id|SCpnt-&gt;use_sg
comma
id|SCpnt-&gt;sc_data_direction
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|sg_count
op_le
l_int|0
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|SCpnt-&gt;use_sg
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
l_int|1
)paren
id|sg_flags
op_or_assign
l_int|0xC0000000
suffix:semicolon
id|writel
c_func
(paren
id|sg_flags
op_or
id|sg_dma_len
c_func
(paren
id|sg
)paren
comma
id|mptr
op_increment
)paren
suffix:semicolon
id|writel
c_func
(paren
id|sg_dma_address
c_func
(paren
id|sg
)paren
comma
id|mptr
op_increment
)paren
suffix:semicolon
id|len
op_add_assign
id|sg_dma_len
c_func
(paren
id|sg
)paren
suffix:semicolon
id|sg
op_increment
suffix:semicolon
)brace
id|reqlen
op_assign
id|mptr
op_minus
op_amp
id|msg-&gt;u.head
(braket
l_int|0
)braket
suffix:semicolon
id|writel
c_func
(paren
id|len
comma
id|lenptr
)paren
suffix:semicolon
)brace
r_else
(brace
id|len
op_assign
id|SCpnt-&gt;request_bufflen
suffix:semicolon
id|writel
c_func
(paren
id|len
comma
id|lenptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|dma_addr_t
id|dma_addr
suffix:semicolon
id|dma_addr
op_assign
id|dma_map_single
c_func
(paren
id|dev
comma
id|SCpnt-&gt;request_buffer
comma
id|SCpnt-&gt;request_bufflen
comma
id|SCpnt-&gt;sc_data_direction
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dma_addr
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|SCpnt-&gt;SCp.ptr
op_assign
(paren
r_void
op_star
)paren
(paren
r_int
r_int
)paren
id|dma_addr
suffix:semicolon
id|sg_flags
op_or_assign
l_int|0xC0000000
suffix:semicolon
id|writel
c_func
(paren
id|sg_flags
op_or
id|SCpnt-&gt;request_bufflen
comma
id|mptr
op_increment
)paren
suffix:semicolon
id|writel
c_func
(paren
id|dma_addr
comma
id|mptr
op_increment
)paren
suffix:semicolon
)brace
r_else
id|reqlen
op_assign
l_int|9
suffix:semicolon
)brace
multiline_comment|/* Stick the headers on */
id|writel
c_func
(paren
id|reqlen
op_lshift
l_int|16
op_or
id|SGL_OFFSET_10
comma
op_amp
id|msg-&gt;u.head
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* Queue the message */
id|i2o_msg_post
c_func
(paren
id|c
comma
id|m
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;Issued %ld&bslash;n&quot;
comma
id|SCpnt-&gt;serial_number
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/**&n; *&t;i2o_scsi_abort - abort a running command&n; *&t;@SCpnt: command to abort&n; *&n; *&t;Ask the I2O controller to abort a command. This is an asynchrnous&n; *&t;process and our callback handler will see the command complete with an&n; *&t;aborted message if it succeeds.&n; *&n; *&t;Returns 0 if the command is successfully aborted or negative error code&n; *&t;on failure.&n; */
DECL|function|i2o_scsi_abort
r_int
id|i2o_scsi_abort
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|SCpnt
)paren
(brace
r_struct
id|i2o_device
op_star
id|i2o_dev
suffix:semicolon
r_struct
id|i2o_controller
op_star
id|c
suffix:semicolon
r_struct
id|i2o_message
op_star
id|msg
suffix:semicolon
id|u32
id|m
suffix:semicolon
r_int
id|tid
suffix:semicolon
r_int
id|status
op_assign
id|FAILED
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i2o_scsi: Aborting command block.&bslash;n&quot;
)paren
suffix:semicolon
id|i2o_dev
op_assign
id|SCpnt-&gt;device-&gt;hostdata
suffix:semicolon
id|c
op_assign
id|i2o_dev-&gt;iop
suffix:semicolon
id|tid
op_assign
id|i2o_dev-&gt;lct_data.tid
suffix:semicolon
id|m
op_assign
id|i2o_msg_get_wait
c_func
(paren
id|c
comma
op_amp
id|msg
comma
id|I2O_TIMEOUT_MESSAGE_GET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
op_eq
id|I2O_QUEUE_EMPTY
)paren
r_return
id|SCSI_MLQUEUE_HOST_BUSY
suffix:semicolon
id|writel
c_func
(paren
id|FIVE_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
comma
op_amp
id|msg-&gt;u.head
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|writel
c_func
(paren
id|I2O_CMD_SCSI_ABORT
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|tid
comma
op_amp
id|msg-&gt;u.head
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|writel
c_func
(paren
id|i2o_cntxt_list_get_ptr
c_func
(paren
id|c
comma
id|SCpnt
)paren
comma
op_amp
id|msg-&gt;body
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i2o_msg_post_wait
c_func
(paren
id|c
comma
id|m
comma
id|I2O_TIMEOUT_SCSI_SCB_ABORT
)paren
)paren
id|status
op_assign
id|SUCCESS
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_scsi_bios_param&t;-&t;Invent disk geometry&n; *&t;@sdev: scsi device&n; *&t;@dev: block layer device&n; *&t;@capacity: size in sectors&n; *&t;@ip: geometry array&n; *&n; *&t;This is anyones guess quite frankly. We use the same rules everyone&n; *&t;else appears to and hope. It seems to work.&n; */
DECL|function|i2o_scsi_bios_param
r_static
r_int
id|i2o_scsi_bios_param
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
comma
r_struct
id|block_device
op_star
id|dev
comma
id|sector_t
id|capacity
comma
r_int
op_star
id|ip
)paren
(brace
r_int
id|size
suffix:semicolon
id|size
op_assign
id|capacity
suffix:semicolon
id|ip
(braket
l_int|0
)braket
op_assign
l_int|64
suffix:semicolon
multiline_comment|/* heads                        */
id|ip
(braket
l_int|1
)braket
op_assign
l_int|32
suffix:semicolon
multiline_comment|/* sectors                      */
r_if
c_cond
(paren
(paren
id|ip
(braket
l_int|2
)braket
op_assign
id|size
op_rshift
l_int|11
)paren
OG
l_int|1024
)paren
(brace
multiline_comment|/* cylinders, test for big disk */
id|ip
(braket
l_int|0
)braket
op_assign
l_int|255
suffix:semicolon
multiline_comment|/* heads                        */
id|ip
(braket
l_int|1
)braket
op_assign
l_int|63
suffix:semicolon
multiline_comment|/* sectors                      */
id|ip
(braket
l_int|2
)braket
op_assign
id|size
op_div
(paren
l_int|255
op_star
l_int|63
)paren
suffix:semicolon
multiline_comment|/* cylinders                    */
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|i2o_scsi_host_template
r_static
r_struct
id|scsi_host_template
id|i2o_scsi_host_template
op_assign
(brace
dot
id|proc_name
op_assign
l_string|&quot;SCSI-OSM&quot;
comma
dot
id|name
op_assign
l_string|&quot;I2O SCSI Peripheral OSM&quot;
comma
dot
id|info
op_assign
id|i2o_scsi_info
comma
dot
id|queuecommand
op_assign
id|i2o_scsi_queuecommand
comma
dot
id|eh_abort_handler
op_assign
id|i2o_scsi_abort
comma
dot
id|bios_param
op_assign
id|i2o_scsi_bios_param
comma
dot
id|can_queue
op_assign
id|I2O_SCSI_CAN_QUEUE
comma
dot
id|sg_tablesize
op_assign
l_int|8
comma
dot
id|cmd_per_lun
op_assign
l_int|6
comma
dot
id|use_clustering
op_assign
id|ENABLE_CLUSTERING
comma
)brace
suffix:semicolon
multiline_comment|/*&n;int&n;i2o_scsi_queuecommand(struct scsi_cmnd * cmd, void (*done) (struct scsi_cmnd *))&n;{&n;&t;printk(KERN_INFO &quot;queuecommand&bslash;n&quot;);&n;&t;return SCSI_MLQUEUE_HOST_BUSY;&n;};&n;*/
multiline_comment|/**&n; *&t;i2o_scsi_init - SCSI OSM initialization function&n; *&n; *&t;Register SCSI OSM into I2O core.&n; *&n; *&t;Returns 0 on success or negative error code on failure.&n; */
DECL|function|i2o_scsi_init
r_static
r_int
id|__init
id|i2o_scsi_init
c_func
(paren
r_void
)paren
(brace
r_int
id|rc
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;I2O SCSI Peripheral OSM&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Register SCSI OSM into I2O core */
id|rc
op_assign
id|i2o_driver_register
c_func
(paren
op_amp
id|i2o_scsi_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;scsi-osm: Could not register SCSI driver&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/**&n; *&t;i2o_scsi_exit - SCSI OSM exit function&n; *&n; *&t;Unregisters SCSI OSM from I2O core.&n; */
DECL|function|i2o_scsi_exit
r_static
r_void
id|__exit
id|i2o_scsi_exit
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Unregister I2O SCSI OSM from I2O core */
id|i2o_driver_unregister
c_func
(paren
op_amp
id|i2o_scsi_driver
)paren
suffix:semicolon
)brace
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Red Hat Software&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|i2o_scsi_init
id|module_init
c_func
(paren
id|i2o_scsi_init
)paren
suffix:semicolon
DECL|variable|i2o_scsi_exit
id|module_exit
c_func
(paren
id|i2o_scsi_exit
)paren
suffix:semicolon
eof
