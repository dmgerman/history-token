multiline_comment|/* &n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * For the avoidance of doubt the &quot;preferred form&quot; of this code is one which&n; * is in an open non patent encumbered format. Where cryptographic key signing&n; * forms part of the process of creating an executable the information&n; * including keys needed to generate an equivalently functional executable&n; * are deemed to be part of the source code.&n; *&n; *  Complications for I2O scsi&n; *&n; *&t;o&t;Each (bus,lun) is a logical device in I2O. We keep a map&n; *&t;&t;table. We spoof failed selection for unmapped units&n; *&t;o&t;Request sense buffers can come back for free. &n; *&t;o&t;Scatter gather is a bit dynamic. We have to investigate at&n; *&t;&t;setup time.&n; *&t;o&t;Some of our resources are dynamically shared. The i2o core&n; *&t;&t;needs a message reservation protocol to avoid swap v net&n; *&t;&t;deadlocking. We need to back off queue requests.&n; *&t;&n; *&t;In general the firmware wants to help. Where its help isn&squot;t performance&n; *&t;useful we just ignore the aid. Its not worth the code in truth.&n; *&n; *&t;Fixes:&n; *&t;&t;Steve Ralston&t;:&t;Scatter gather now works&n; *&n; *&t;To Do&n; *&t;&t;64bit cleanups&n; *&t;&t;Fix the resource management problems.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/jiffies.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/prefetch.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/i2o.h&gt;
macro_line|#include &quot;../../scsi/scsi.h&quot;
macro_line|#include &quot;../../scsi/hosts.h&quot;
macro_line|#if BITS_PER_LONG == 64
macro_line|#error FIXME: driver does not support 64-bit platforms
macro_line|#endif
DECL|macro|VERSION_STRING
mdefine_line|#define VERSION_STRING        &quot;Version 0.1.2&quot;
DECL|macro|dprintk
mdefine_line|#define dprintk(x)
DECL|macro|I2O_SCSI_CAN_QUEUE
mdefine_line|#define I2O_SCSI_CAN_QUEUE&t;4
DECL|macro|MAXHOSTS
mdefine_line|#define MAXHOSTS&t;&t;32
DECL|struct|i2o_scsi_host
r_struct
id|i2o_scsi_host
(brace
DECL|member|controller
r_struct
id|i2o_controller
op_star
id|controller
suffix:semicolon
DECL|member|task
id|s16
id|task
(braket
l_int|16
)braket
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* Allow 16 devices for now */
DECL|member|tagclock
r_int
r_int
id|tagclock
(braket
l_int|16
)braket
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* Tag clock for queueing */
DECL|member|bus_task
id|s16
id|bus_task
suffix:semicolon
multiline_comment|/* The adapter TID */
)brace
suffix:semicolon
DECL|variable|scsi_context
r_static
r_int
id|scsi_context
suffix:semicolon
DECL|variable|lun_done
r_static
r_int
id|lun_done
suffix:semicolon
DECL|variable|i2o_scsi_hosts
r_static
r_int
id|i2o_scsi_hosts
suffix:semicolon
DECL|variable|retry
r_static
id|u32
op_star
id|retry
(braket
l_int|32
)braket
suffix:semicolon
DECL|variable|retry_ctrl
r_static
r_struct
id|i2o_controller
op_star
id|retry_ctrl
(braket
l_int|32
)braket
suffix:semicolon
DECL|variable|retry_timer
r_static
r_struct
id|timer_list
id|retry_timer
suffix:semicolon
DECL|variable|retry_lock
r_static
id|spinlock_t
id|retry_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|retry_ct
r_static
r_int
id|retry_ct
op_assign
l_int|0
suffix:semicolon
DECL|variable|queue_depth
r_static
id|atomic_t
id|queue_depth
suffix:semicolon
multiline_comment|/*&n; *&t;SG Chain buffer support...&n; */
DECL|macro|SG_MAX_FRAGS
mdefine_line|#define SG_MAX_FRAGS&t;&t;64
multiline_comment|/*&n; *&t;FIXME: we should allocate one of these per bus we find as we&n; *&t;locate them not in a lump at boot.&n; */
DECL|struct|_chain_buf
r_typedef
r_struct
id|_chain_buf
(brace
DECL|member|sg_flags_cnt
id|u32
id|sg_flags_cnt
(braket
id|SG_MAX_FRAGS
)braket
suffix:semicolon
DECL|member|sg_buf
id|u32
id|sg_buf
(braket
id|SG_MAX_FRAGS
)braket
suffix:semicolon
DECL|typedef|chain_buf
)brace
id|chain_buf
suffix:semicolon
DECL|macro|SG_CHAIN_BUF_SZ
mdefine_line|#define SG_CHAIN_BUF_SZ sizeof(chain_buf)
DECL|macro|SG_MAX_BUFS
mdefine_line|#define SG_MAX_BUFS&t;&t;(i2o_num_controllers * I2O_SCSI_CAN_QUEUE)
DECL|macro|SG_CHAIN_POOL_SZ
mdefine_line|#define SG_CHAIN_POOL_SZ&t;(SG_MAX_BUFS * SG_CHAIN_BUF_SZ)
DECL|variable|max_sg_len
r_static
r_int
id|max_sg_len
op_assign
l_int|0
suffix:semicolon
DECL|variable|sg_chain_pool
r_static
id|chain_buf
op_star
id|sg_chain_pool
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|sg_chain_tag
r_static
r_int
id|sg_chain_tag
op_assign
l_int|0
suffix:semicolon
DECL|variable|sg_max_frags
r_static
r_int
id|sg_max_frags
op_assign
id|SG_MAX_FRAGS
suffix:semicolon
multiline_comment|/**&n; *&t;i2o_retry_run&t;&t;-&t;retry on timeout&n; *&t;@f: unused&n; *&n; *&t;Retry congested frames. This actually needs pushing down into&n; *&t;i2o core. We should only bother the OSM with this when we can&squot;t&n; *&t;queue and retry the frame. Or perhaps we should call the OSM&n; *&t;and its default handler should be this in the core, and this&n; *&t;call a 2nd &quot;I give up&quot; handler in the OSM ?&n; */
DECL|function|i2o_retry_run
r_static
r_void
id|i2o_retry_run
c_func
(paren
r_int
r_int
id|f
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|retry_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|retry_ct
suffix:semicolon
id|i
op_increment
)paren
(brace
id|i2o_post_message
c_func
(paren
id|retry_ctrl
(braket
id|i
)braket
comma
id|virt_to_bus
c_func
(paren
id|retry
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
id|retry_ct
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|retry_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;flush_pending&t;&t;-&t;empty the retry queue&n; *&n; *&t;Turn each of the pending commands into a NOP and post it back&n; *&t;to the controller to clear it.&n; */
DECL|function|flush_pending
r_static
r_void
id|flush_pending
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|retry_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|retry_ct
suffix:semicolon
id|i
op_increment
)paren
(brace
id|retry
(braket
id|i
)braket
(braket
l_int|0
)braket
op_and_assign
op_complement
l_int|0xFFFFFF
suffix:semicolon
id|retry
(braket
id|i
)braket
(braket
l_int|0
)braket
op_or_assign
id|I2O_CMD_UTIL_NOP
op_lshift
l_int|24
suffix:semicolon
id|i2o_post_message
c_func
(paren
id|retry_ctrl
(braket
id|i
)braket
comma
id|virt_to_bus
c_func
(paren
id|retry
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
id|retry_ct
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|retry_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_scsi_reply&t;&t;-&t;scsi message reply processor&n; *&t;@h: our i2o handler&n; *&t;@c: controller issuing the reply&n; *&t;@msg: the message from the controller (mapped)&n; *&n; *&t;Process reply messages (interrupts in normal scsi controller think).&n; *&t;We can get a variety of messages to process. The normal path is&n; *&t;scsi command completions. We must also deal with IOP failures,&n; *&t;the reply to a bus reset and the reply to a LUN query.&n; *&n; *&t;Locks: the queue lock is taken to call the completion handler&n; */
DECL|function|i2o_scsi_reply
r_static
r_void
id|i2o_scsi_reply
c_func
(paren
r_struct
id|i2o_handler
op_star
id|h
comma
r_struct
id|i2o_controller
op_star
id|c
comma
r_struct
id|i2o_message
op_star
id|msg
)paren
(brace
id|Scsi_Cmnd
op_star
id|current_command
suffix:semicolon
id|spinlock_t
op_star
id|lock
suffix:semicolon
id|u32
op_star
id|m
op_assign
(paren
id|u32
op_star
)paren
id|msg
suffix:semicolon
id|u8
id|as
comma
id|ds
comma
id|st
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|m
(braket
l_int|0
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|13
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IOP fail.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;From %d To %d Cmd %d.&bslash;n&quot;
comma
(paren
id|m
(braket
l_int|1
)braket
op_rshift
l_int|12
)paren
op_amp
l_int|0xFFF
comma
id|m
(braket
l_int|1
)braket
op_amp
l_int|0xFFF
comma
id|m
(braket
l_int|1
)braket
op_rshift
l_int|24
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Failure Code %d.&bslash;n&quot;
comma
id|m
(braket
l_int|4
)braket
op_rshift
l_int|24
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
(braket
l_int|4
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|16
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Format error.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|m
(braket
l_int|4
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|17
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Path error.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|m
(braket
l_int|4
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|18
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Path State.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|m
(braket
l_int|4
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|18
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Congestion.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|m
op_assign
(paren
id|u32
op_star
)paren
id|bus_to_virt
c_func
(paren
id|m
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Failing message is %p.&bslash;n&quot;
comma
id|m
)paren
suffix:semicolon
multiline_comment|/* This isnt a fast path .. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|retry_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|m
(braket
l_int|4
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|18
)paren
)paren
op_logical_and
id|retry_ct
OL
l_int|32
)paren
(brace
id|retry_ctrl
(braket
id|retry_ct
)braket
op_assign
id|c
suffix:semicolon
id|retry
(braket
id|retry_ct
)braket
op_assign
id|m
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retry_ct
op_increment
)paren
(brace
id|retry_timer.expires
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|retry_timer
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|retry_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|retry_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Create a scsi error for this */
id|current_command
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|m
(braket
l_int|3
)braket
suffix:semicolon
id|lock
op_assign
id|current_command-&gt;device-&gt;host-&gt;host_lock
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Aborted %ld&bslash;n&quot;
comma
id|current_command-&gt;serial_number
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|lock
comma
id|flags
)paren
suffix:semicolon
id|current_command-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|current_command
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|current_command
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Now flush the message by making it a NOP */
id|m
(braket
l_int|0
)braket
op_and_assign
l_int|0x00FFFFFF
suffix:semicolon
id|m
(braket
l_int|0
)braket
op_or_assign
(paren
id|I2O_CMD_UTIL_NOP
)paren
op_lshift
l_int|24
suffix:semicolon
id|i2o_post_message
c_func
(paren
id|c
comma
id|virt_to_bus
c_func
(paren
id|m
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|prefetchw
c_func
(paren
op_amp
id|queue_depth
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Low byte is device status, next is adapter status,&n;&t; *&t;(then one byte reserved), then request status.&n;&t; */
id|ds
op_assign
(paren
id|u8
)paren
id|le32_to_cpu
c_func
(paren
id|m
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|as
op_assign
(paren
id|u8
)paren
id|le32_to_cpu
c_func
(paren
id|m
(braket
l_int|4
)braket
op_rshift
l_int|8
)paren
suffix:semicolon
id|st
op_assign
(paren
id|u8
)paren
id|le32_to_cpu
c_func
(paren
id|m
(braket
l_int|4
)braket
op_rshift
l_int|24
)paren
suffix:semicolon
id|dprintk
c_func
(paren
(paren
l_string|&quot;i2o got a scsi reply %08X: &quot;
comma
id|m
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|dprintk
c_func
(paren
(paren
l_string|&quot;m[2]=%08X: &quot;
comma
id|m
(braket
l_int|2
)braket
)paren
)paren
suffix:semicolon
id|dprintk
c_func
(paren
(paren
l_string|&quot;m[4]=%08X&bslash;n&quot;
comma
id|m
(braket
l_int|4
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
(braket
l_int|2
)braket
op_amp
l_int|0x80000000
)paren
(brace
r_if
c_cond
(paren
id|m
(braket
l_int|2
)braket
op_amp
l_int|0x40000000
)paren
(brace
id|dprintk
c_func
(paren
(paren
l_string|&quot;Event.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|lun_done
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;i2o_scsi: bus reset completed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; &t; *&t;FIXME: 64bit breakage&n;&t; */
id|current_command
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|m
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Is this a control request coming back - eg an abort ?&n;&t; */
r_if
c_cond
(paren
id|current_command
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|st
)paren
(brace
id|dprintk
c_func
(paren
(paren
l_string|&quot;SCSI abort: %08X&quot;
comma
id|m
(braket
l_int|4
)braket
)paren
)paren
suffix:semicolon
)brace
id|dprintk
c_func
(paren
(paren
l_string|&quot;SCSI abort completed.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dprintk
c_func
(paren
(paren
l_string|&quot;Completed %ld&bslash;n&quot;
comma
id|current_command-&gt;serial_number
)paren
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|queue_depth
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
op_eq
l_int|0x06
)paren
(brace
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|m
(braket
l_int|5
)braket
)paren
OL
id|current_command-&gt;underflow
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;SCSI: underflow 0x%08X 0x%08X&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|m
(braket
l_int|5
)braket
)paren
comma
id|current_command-&gt;underflow
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Cmd: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02X &quot;
comma
id|current_command-&gt;cmnd
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|st
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st
)paren
(brace
multiline_comment|/* An error has occurred */
id|dprintk
c_func
(paren
(paren
id|KERN_DEBUG
l_string|&quot;SCSI error %08X&quot;
comma
id|m
(braket
l_int|4
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|as
op_eq
l_int|0x0E
)paren
multiline_comment|/* SCSI Reset */
id|current_command-&gt;result
op_assign
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
r_else
r_if
c_cond
(paren
id|as
op_eq
l_int|0x0F
)paren
id|current_command-&gt;result
op_assign
id|DID_PARITY
op_lshift
l_int|16
suffix:semicolon
r_else
id|current_command-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
)brace
r_else
multiline_comment|/*&n;&t;&t; *&t;It worked maybe ?&n;&t;&t; */
id|current_command-&gt;result
op_assign
id|DID_OK
op_lshift
l_int|16
op_or
id|ds
suffix:semicolon
r_if
c_cond
(paren
id|current_command-&gt;use_sg
)paren
id|pci_unmap_sg
c_func
(paren
id|c-&gt;pdev
comma
(paren
r_struct
id|scatterlist
op_star
)paren
id|current_command-&gt;buffer
comma
id|current_command-&gt;use_sg
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|current_command-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|current_command-&gt;request_bufflen
)paren
id|pci_unmap_single
c_func
(paren
id|c-&gt;pdev
comma
(paren
id|dma_addr_t
)paren
(paren
(paren
r_int
)paren
id|current_command-&gt;SCp.ptr
)paren
comma
id|current_command-&gt;request_bufflen
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|current_command-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
id|lock
op_assign
id|current_command-&gt;device-&gt;host-&gt;host_lock
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|lock
comma
id|flags
)paren
suffix:semicolon
id|current_command
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|current_command
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|variable|i2o_scsi_handler
r_struct
id|i2o_handler
id|i2o_scsi_handler
op_assign
(brace
dot
id|reply
op_assign
id|i2o_scsi_reply
comma
dot
id|name
op_assign
l_string|&quot;I2O SCSI OSM&quot;
comma
dot
r_class
op_assign
id|I2O_CLASS_SCSI_PERIPHERAL
comma
)brace
suffix:semicolon
multiline_comment|/**&n; *&t;i2o_find_lun&t;&t;-&t;report the lun of an i2o device&n; *&t;@c: i2o controller owning the device&n; *&t;@d: i2o disk device&n; *&t;@target: filled in with target id&n; *&t;@lun: filled in with target lun&n; *&n; *&t;Query an I2O device to find out its SCSI lun and target numbering. We&n; *&t;don&squot;t currently handle some of the fancy SCSI-3 stuff although our&n; *&t;querying is sufficient to do so.&n; */
DECL|function|i2o_find_lun
r_static
r_int
id|i2o_find_lun
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
comma
r_struct
id|i2o_device
op_star
id|d
comma
r_int
op_star
id|target
comma
r_int
op_star
id|lun
)paren
(brace
id|u8
id|reply
(braket
l_int|8
)braket
suffix:semicolon
r_if
c_cond
(paren
id|i2o_query_scalar
c_func
(paren
id|c
comma
id|d-&gt;lct_data.tid
comma
l_int|0
comma
l_int|3
comma
id|reply
comma
l_int|4
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
op_star
id|target
op_assign
id|reply
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|i2o_query_scalar
c_func
(paren
id|c
comma
id|d-&gt;lct_data.tid
comma
l_int|0
comma
l_int|4
comma
id|reply
comma
l_int|8
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
op_star
id|lun
op_assign
id|reply
(braket
l_int|1
)braket
suffix:semicolon
id|dprintk
c_func
(paren
(paren
l_string|&quot;SCSI (%d,%d)&bslash;n&quot;
comma
op_star
id|target
comma
op_star
id|lun
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_scsi_init&t;&t;-&t;initialize an i2o device for scsi&n; *&t;@c: i2o controller owning the device&n; *&t;@d: scsi controller&n; *&t;@shpnt: scsi device we wish it to become&n; *&n; *&t;Enumerate the scsi peripheral/fibre channel peripheral class&n; *&t;devices that are children of the controller. From that we build&n; *&t;a translation map for the command queue code. Since I2O works on&n; *&t;its own tid&squot;s we effectively have to think backwards to get what&n; *&t;the midlayer wants&n; */
DECL|function|i2o_scsi_init
r_static
r_void
id|i2o_scsi_init
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
comma
r_struct
id|i2o_device
op_star
id|d
comma
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
(brace
r_struct
id|i2o_device
op_star
id|unit
suffix:semicolon
r_struct
id|i2o_scsi_host
op_star
id|h
op_assign
(paren
r_struct
id|i2o_scsi_host
op_star
)paren
id|shpnt-&gt;hostdata
suffix:semicolon
r_int
id|lun
suffix:semicolon
r_int
id|target
suffix:semicolon
id|h-&gt;controller
op_assign
id|c
suffix:semicolon
id|h-&gt;bus_task
op_assign
id|d-&gt;lct_data.tid
suffix:semicolon
r_for
c_loop
(paren
id|target
op_assign
l_int|0
suffix:semicolon
id|target
OL
l_int|16
suffix:semicolon
id|target
op_increment
)paren
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
l_int|8
suffix:semicolon
id|lun
op_increment
)paren
(brace
id|h-&gt;task
(braket
id|target
)braket
(braket
id|lun
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|unit
op_assign
id|c-&gt;devices
suffix:semicolon
id|unit
op_ne
l_int|NULL
suffix:semicolon
id|unit
op_assign
id|unit-&gt;next
)paren
(brace
id|dprintk
c_func
(paren
(paren
l_string|&quot;Class %03X, parent %d, want %d.&bslash;n&quot;
comma
id|unit-&gt;lct_data.class_id
comma
id|unit-&gt;lct_data.parent_tid
comma
id|d-&gt;lct_data.tid
)paren
)paren
suffix:semicolon
multiline_comment|/* Only look at scsi and fc devices */
r_if
c_cond
(paren
(paren
id|unit-&gt;lct_data.class_id
op_ne
id|I2O_CLASS_SCSI_PERIPHERAL
)paren
op_logical_and
(paren
id|unit-&gt;lct_data.class_id
op_ne
id|I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* On our bus ? */
id|dprintk
c_func
(paren
(paren
l_string|&quot;Found a disk (%d).&bslash;n&quot;
comma
id|unit-&gt;lct_data.tid
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|unit-&gt;lct_data.parent_tid
op_eq
id|d-&gt;lct_data.tid
)paren
op_logical_or
(paren
id|unit-&gt;lct_data.parent_tid
op_eq
id|d-&gt;lct_data.parent_tid
)paren
)paren
(brace
id|u16
id|limit
suffix:semicolon
id|dprintk
c_func
(paren
(paren
l_string|&quot;Its ours.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i2o_find_lun
c_func
(paren
id|c
comma
id|unit
comma
op_amp
id|target
comma
op_amp
id|lun
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2o_scsi: Unable to get lun for tid %d.&bslash;n&quot;
comma
id|unit-&gt;lct_data.tid
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|dprintk
c_func
(paren
(paren
l_string|&quot;Found disk %d %d.&bslash;n&quot;
comma
id|target
comma
id|lun
)paren
)paren
suffix:semicolon
id|h-&gt;task
(braket
id|target
)braket
(braket
id|lun
)braket
op_assign
id|unit-&gt;lct_data.tid
suffix:semicolon
id|h-&gt;tagclock
(braket
id|target
)braket
(braket
id|lun
)braket
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Get the max fragments/request */
id|i2o_query_scalar
c_func
(paren
id|c
comma
id|d-&gt;lct_data.tid
comma
l_int|0xF103
comma
l_int|3
comma
op_amp
id|limit
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* sanity */
r_if
c_cond
(paren
id|limit
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i2o_scsi: Ignoring unreasonable SG limit of 0 from IOP!&bslash;n&quot;
)paren
suffix:semicolon
id|limit
op_assign
l_int|1
suffix:semicolon
)brace
id|shpnt-&gt;sg_tablesize
op_assign
id|limit
suffix:semicolon
id|dprintk
c_func
(paren
(paren
l_string|&quot;i2o_scsi: set scatter-gather to %d.&bslash;n&quot;
comma
id|shpnt-&gt;sg_tablesize
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/**&n; *&t;i2o_scsi_detect&t;&t;-&t;probe for I2O scsi devices&n; *&t;@tpnt: scsi layer template&n; *&n; *&t;I2O is a little odd here. The I2O core already knows what the&n; *&t;devices are. It also knows them by disk and tape as well as&n; *&t;by controller. We register each I2O scsi class object as a&n; *&t;scsi controller and then let the enumeration fake up the rest&n; */
DECL|function|i2o_scsi_detect
r_static
r_int
id|i2o_scsi_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|tpnt
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shpnt
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|count
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;i2o_scsi.c: %s&bslash;n&quot;
comma
id|VERSION_STRING
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i2o_install_handler
c_func
(paren
op_amp
id|i2o_scsi_handler
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2o_scsi: Unable to install OSM handler.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|scsi_context
op_assign
id|i2o_scsi_handler.context
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sg_chain_pool
op_assign
id|kmalloc
c_func
(paren
id|SG_CHAIN_POOL_SZ
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;i2o_scsi: Unable to alloc %d byte SG chain buffer pool.&bslash;n&quot;
comma
id|SG_CHAIN_POOL_SZ
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;i2o_scsi: SG chaining DISABLED!&bslash;n&quot;
)paren
suffix:semicolon
id|sg_max_frags
op_assign
l_int|11
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  chain_pool: %d bytes @ %p&bslash;n&quot;
comma
id|SG_CHAIN_POOL_SZ
comma
id|sg_chain_pool
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  (%d byte buffers X %d can_queue X %d i2o controllers)&bslash;n&quot;
comma
id|SG_CHAIN_BUF_SZ
comma
id|I2O_SCSI_CAN_QUEUE
comma
id|i2o_num_controllers
)paren
suffix:semicolon
id|sg_max_frags
op_assign
id|SG_MAX_FRAGS
suffix:semicolon
singleline_comment|// 64
)brace
id|init_timer
c_func
(paren
op_amp
id|retry_timer
)paren
suffix:semicolon
id|retry_timer.data
op_assign
l_int|0UL
suffix:semicolon
id|retry_timer.function
op_assign
id|i2o_retry_run
suffix:semicolon
singleline_comment|//&t;printk(&quot;SCSI OSM at %d.&bslash;n&quot;, scsi_context);
r_for
c_loop
(paren
id|count
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2O_CONTROLLERS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|i2o_controller
op_star
id|c
op_assign
id|i2o_find_controller
c_func
(paren
id|i
)paren
suffix:semicolon
r_struct
id|i2o_device
op_star
id|d
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;This controller doesn&squot;t exist.&n;&t;&t; */
r_if
c_cond
(paren
id|c
op_eq
l_int|NULL
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Fixme - we need some altered device locking. This&n;&t;&t; *&t;is racing with device addition in theory. Easy to fix.&n;&t;&t; */
r_for
c_loop
(paren
id|d
op_assign
id|c-&gt;devices
suffix:semicolon
id|d
op_ne
l_int|NULL
suffix:semicolon
id|d
op_assign
id|d-&gt;next
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;bus_adapter, SCSI (obsolete), or FibreChannel busses only&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|d-&gt;lct_data.class_id
op_ne
id|I2O_CLASS_BUS_ADAPTER_PORT
)paren
singleline_comment|// bus_adapter
singleline_comment|//&t;&t;&t;    &amp;&amp; (d-&gt;lct_data.class_id!=I2O_CLASS_FIBRE_CHANNEL_PORT)&t;// FC_PORT
)paren
(brace
r_continue
suffix:semicolon
)brace
id|shpnt
op_assign
id|scsi_register
c_func
(paren
id|tpnt
comma
r_sizeof
(paren
r_struct
id|i2o_scsi_host
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shpnt
op_eq
l_int|NULL
)paren
(brace
r_continue
suffix:semicolon
)brace
id|shpnt-&gt;unique_id
op_assign
(paren
id|u32
)paren
id|d
suffix:semicolon
id|shpnt-&gt;io_port
op_assign
l_int|0
suffix:semicolon
id|shpnt-&gt;n_io_port
op_assign
l_int|0
suffix:semicolon
id|shpnt-&gt;irq
op_assign
l_int|0
suffix:semicolon
id|shpnt-&gt;this_id
op_assign
multiline_comment|/* Good question */
l_int|15
suffix:semicolon
id|i2o_scsi_init
c_func
(paren
id|c
comma
id|d
comma
id|shpnt
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
)brace
id|i2o_scsi_hosts
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|sg_chain_pool
op_ne
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|sg_chain_pool
)paren
suffix:semicolon
id|sg_chain_pool
op_assign
l_int|NULL
suffix:semicolon
)brace
id|flush_pending
c_func
(paren
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|retry_timer
)paren
suffix:semicolon
id|i2o_remove_handler
c_func
(paren
op_amp
id|i2o_scsi_handler
)paren
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
DECL|function|i2o_scsi_release
r_static
r_int
id|i2o_scsi_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|i2o_scsi_hosts
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|sg_chain_pool
op_ne
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|sg_chain_pool
)paren
suffix:semicolon
id|sg_chain_pool
op_assign
l_int|NULL
suffix:semicolon
)brace
id|flush_pending
c_func
(paren
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|retry_timer
)paren
suffix:semicolon
id|i2o_remove_handler
c_func
(paren
op_amp
id|i2o_scsi_handler
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|i2o_scsi_info
r_static
r_const
r_char
op_star
id|i2o_scsi_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|SChost
)paren
(brace
r_struct
id|i2o_scsi_host
op_star
id|hostdata
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|i2o_scsi_host
op_star
)paren
id|SChost-&gt;hostdata
suffix:semicolon
r_return
op_amp
id|hostdata-&gt;controller-&gt;name
(braket
l_int|0
)braket
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_scsi_queuecommand&t;-&t;queue a SCSI command&n; *&t;@SCpnt: scsi command pointer&n; *&t;@done: callback for completion&n; *&n; *&t;Issue a scsi comamnd asynchronously. Return 0 on success or 1 if&n; *&t;we hit an error (normally message queue congestion). The only &n; *&t;minor complication here is that I2O deals with the device addressing&n; *&t;so we have to map the bus/dev/lun back to an I2O handle as well&n; *&t;as faking absent devices ourself. &n; *&n; *&t;Locks: takes the controller lock on error path only&n; */
DECL|function|i2o_scsi_queuecommand
r_static
r_int
id|i2o_scsi_queuecommand
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|tid
suffix:semicolon
r_struct
id|i2o_controller
op_star
id|c
suffix:semicolon
id|Scsi_Cmnd
op_star
id|current_command
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
r_struct
id|i2o_scsi_host
op_star
id|hostdata
suffix:semicolon
id|u32
op_star
id|msg
comma
op_star
id|mptr
suffix:semicolon
id|u32
id|m
suffix:semicolon
id|u32
op_star
id|lenptr
suffix:semicolon
r_int
id|direction
suffix:semicolon
r_int
id|scsidir
suffix:semicolon
id|u32
id|len
suffix:semicolon
id|u32
id|reqlen
suffix:semicolon
id|u32
id|tag
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_static
r_int
id|max_qd
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Do the incoming paperwork&n;&t; */
id|host
op_assign
id|SCpnt-&gt;device-&gt;host
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|i2o_scsi_host
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|c
op_assign
id|hostdata-&gt;controller
suffix:semicolon
id|prefetch
c_func
(paren
id|c
)paren
suffix:semicolon
id|prefetchw
c_func
(paren
op_amp
id|queue_depth
)paren
suffix:semicolon
id|SCpnt-&gt;scsi_done
op_assign
id|done
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;device-&gt;id
OG
l_int|15
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2o_scsi: Wild target %d.&bslash;n&quot;
comma
id|SCpnt-&gt;device-&gt;id
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|tid
op_assign
id|hostdata-&gt;task
(braket
id|SCpnt-&gt;device-&gt;id
)braket
(braket
id|SCpnt-&gt;device-&gt;lun
)braket
suffix:semicolon
id|dprintk
c_func
(paren
(paren
l_string|&quot;qcmd: Tid = %d&bslash;n&quot;
comma
id|tid
)paren
)paren
suffix:semicolon
id|current_command
op_assign
id|SCpnt
suffix:semicolon
multiline_comment|/* set current command                */
id|current_command-&gt;scsi_done
op_assign
id|done
suffix:semicolon
multiline_comment|/* set ptr to done function           */
multiline_comment|/* We don&squot;t have such a device. Pretend we did the command &n;&t;   and that selection timed out */
r_if
c_cond
(paren
id|tid
op_eq
op_minus
l_int|1
)paren
(brace
id|SCpnt-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|dprintk
c_func
(paren
(paren
l_string|&quot;Real scsi messages.&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Obtain an I2O message. If there are none free then &n;&t; *&t;throw it back to the scsi layer&n;&t; */
id|m
op_assign
id|le32_to_cpu
c_func
(paren
id|I2O_POST_READ32
c_func
(paren
id|c
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
op_eq
l_int|0xFFFFFFFF
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
id|msg
op_assign
(paren
id|u32
op_star
)paren
(paren
id|c-&gt;mem_offset
op_plus
id|m
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Put together a scsi execscb message&n;&t; */
id|len
op_assign
id|SCpnt-&gt;request_bufflen
suffix:semicolon
id|direction
op_assign
l_int|0x00000000
suffix:semicolon
singleline_comment|// SGL IN  (osm&lt;--iop)
r_if
c_cond
(paren
id|SCpnt-&gt;sc_data_direction
op_eq
id|SCSI_DATA_NONE
)paren
(brace
id|scsidir
op_assign
l_int|0x00000000
suffix:semicolon
)brace
singleline_comment|// DATA NO XFER
r_else
r_if
c_cond
(paren
id|SCpnt-&gt;sc_data_direction
op_eq
id|SCSI_DATA_WRITE
)paren
(brace
id|direction
op_assign
l_int|0x04000000
suffix:semicolon
singleline_comment|// SGL OUT  (osm--&gt;iop)
id|scsidir
op_assign
l_int|0x80000000
suffix:semicolon
singleline_comment|// DATA OUT (iop--&gt;dev)
)brace
r_else
r_if
c_cond
(paren
id|SCpnt-&gt;sc_data_direction
op_eq
id|SCSI_DATA_READ
)paren
(brace
id|scsidir
op_assign
l_int|0x40000000
suffix:semicolon
singleline_comment|// DATA IN  (iop&lt;--dev)
)brace
r_else
(brace
multiline_comment|/* Unknown - kill the command */
id|SCpnt-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* We must lock the request queue while completing */
id|spin_lock_irqsave
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|i2o_raw_writel
c_func
(paren
id|I2O_CMD_SCSI_EXEC
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|tid
comma
op_amp
id|msg
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|i2o_raw_writel
c_func
(paren
id|scsi_context
comma
op_amp
id|msg
(braket
l_int|2
)braket
)paren
suffix:semicolon
multiline_comment|/* So the I2O layer passes to us */
multiline_comment|/* Sorry 64bit folks. FIXME */
id|i2o_raw_writel
c_func
(paren
(paren
id|u32
)paren
id|SCpnt
comma
op_amp
id|msg
(braket
l_int|3
)braket
)paren
suffix:semicolon
multiline_comment|/* We want the SCSI control block back */
multiline_comment|/* LSI_920_PCI_QUIRK&n;&t; *&n;&t; *&t;Intermittant observations of msg frame word data corruption&n;&t; *&t;observed on msg[4] after:&n;&t; *&t;  WRITE, READ-MODIFY-WRITE&n;&t; *&t;operations.  19990606 -sralston&n;&t; *&n;&t; *&t;(Hence we build this word via tag. Its good practice anyway&n;&t; *&t; we don&squot;t want fetches over PCI needlessly)&n;&t; */
id|tag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Attach tags to the devices&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;device-&gt;tagged_supported
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Some drives are too stupid to handle fairness issues&n;&t;&t; *&t;with tagged queueing. We throw in the odd ordered&n;&t;&t; *&t;tag to stop them starving themselves.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|hostdata-&gt;tagclock
(braket
id|SCpnt-&gt;device-&gt;id
)braket
(braket
id|SCpnt-&gt;device-&gt;lun
)braket
)paren
OG
(paren
l_int|5
op_star
id|HZ
)paren
)paren
(brace
id|tag
op_assign
l_int|0x01800000
suffix:semicolon
multiline_comment|/* ORDERED! */
id|hostdata-&gt;tagclock
(braket
id|SCpnt-&gt;device-&gt;id
)braket
(braket
id|SCpnt-&gt;device-&gt;lun
)braket
op_assign
id|jiffies
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Hmmm...  I always see value of 0 here,&n;&t;&t;&t; *  of which {HEAD_OF, ORDERED, SIMPLE} are NOT!  -sralston&n;&t;&t;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;tag
op_eq
id|HEAD_OF_QUEUE_TAG
)paren
(brace
id|tag
op_assign
l_int|0x01000000
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SCpnt-&gt;tag
op_eq
id|ORDERED_QUEUE_TAG
)paren
(brace
id|tag
op_assign
l_int|0x01800000
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Direction, disconnect ok, tag, CDBLen */
id|i2o_raw_writel
c_func
(paren
id|scsidir
op_or
l_int|0x20000000
op_or
id|SCpnt-&gt;cmd_len
op_or
id|tag
comma
op_amp
id|msg
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|mptr
op_assign
id|msg
op_plus
l_int|5
suffix:semicolon
multiline_comment|/* &n;&t; *&t;Write SCSI command into the message - always 16 byte block &n;&t; */
id|memcpy_toio
c_func
(paren
id|mptr
comma
id|SCpnt-&gt;cmnd
comma
l_int|16
)paren
suffix:semicolon
id|mptr
op_add_assign
l_int|4
suffix:semicolon
id|lenptr
op_assign
id|mptr
op_increment
suffix:semicolon
multiline_comment|/* Remember me - fill in when we know */
id|reqlen
op_assign
l_int|12
suffix:semicolon
singleline_comment|// SINGLE SGE
multiline_comment|/*&n;&t; *&t;Now fill in the SGList and command &n;&t; *&n;&t; *&t;FIXME: we need to set the sglist limits according to the &n;&t; *&t;message size of the I2O controller. We might only have room&n;&t; *&t;for 6 or so worst case&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
)paren
(brace
r_struct
id|scatterlist
op_star
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|SCpnt-&gt;request_buffer
suffix:semicolon
r_int
id|sg_count
suffix:semicolon
r_int
id|chain
op_assign
l_int|0
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
id|sg_count
op_assign
id|pci_map_sg
c_func
(paren
id|c-&gt;pdev
comma
id|sg
comma
id|SCpnt-&gt;use_sg
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|SCpnt-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
multiline_comment|/* FIXME: handle fail */
r_if
c_cond
(paren
op_logical_neg
id|sg_count
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|sg_max_frags
OG
l_int|11
)paren
op_logical_and
(paren
id|SCpnt-&gt;use_sg
OG
l_int|11
)paren
)paren
(brace
id|chain
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Need to chain!&n;&t;&t;&t; */
id|i2o_raw_writel
c_func
(paren
id|direction
op_or
l_int|0xB0000000
op_or
(paren
id|SCpnt-&gt;use_sg
op_star
l_int|2
op_star
l_int|4
)paren
comma
id|mptr
op_increment
)paren
suffix:semicolon
id|i2o_raw_writel
c_func
(paren
id|virt_to_bus
c_func
(paren
id|sg_chain_pool
op_plus
id|sg_chain_tag
)paren
comma
id|mptr
)paren
suffix:semicolon
id|mptr
op_assign
(paren
id|u32
op_star
)paren
(paren
id|sg_chain_pool
op_plus
id|sg_chain_tag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
OG
id|max_sg_len
)paren
(brace
id|max_sg_len
op_assign
id|SCpnt-&gt;use_sg
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;i2o_scsi: Chain SG! SCpnt=%p, SG_FragCnt=%d, SG_idx=%d&bslash;n&quot;
comma
id|SCpnt
comma
id|SCpnt-&gt;use_sg
comma
id|sg_chain_tag
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|sg_chain_tag
op_eq
id|SG_MAX_BUFS
)paren
id|sg_chain_tag
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCpnt-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|mptr
op_increment
op_assign
id|cpu_to_le32
c_func
(paren
id|direction
op_or
l_int|0x10000000
op_or
id|sg_dma_len
c_func
(paren
id|sg
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sg_dma_len
c_func
(paren
id|sg
)paren
suffix:semicolon
op_star
id|mptr
op_increment
op_assign
id|cpu_to_le32
c_func
(paren
id|sg_dma_address
c_func
(paren
id|sg
)paren
)paren
suffix:semicolon
id|sg
op_increment
suffix:semicolon
)brace
id|mptr
(braket
op_minus
l_int|2
)braket
op_assign
id|cpu_to_le32
c_func
(paren
id|direction
op_or
l_int|0xD0000000
op_or
id|sg_dma_len
c_func
(paren
id|sg
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCpnt-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
id|i2o_raw_writel
c_func
(paren
id|direction
op_or
l_int|0x10000000
op_or
id|sg_dma_len
c_func
(paren
id|sg
)paren
comma
id|mptr
op_increment
)paren
suffix:semicolon
id|len
op_add_assign
id|sg-&gt;length
suffix:semicolon
id|i2o_raw_writel
c_func
(paren
id|sg_dma_address
c_func
(paren
id|sg
)paren
comma
id|mptr
op_increment
)paren
suffix:semicolon
id|sg
op_increment
suffix:semicolon
)brace
multiline_comment|/* Make this an end of list. Again evade the 920 bug and&n;&t;&t;&t;   unwanted PCI read traffic */
id|i2o_raw_writel
c_func
(paren
id|direction
op_or
l_int|0xD0000000
op_or
id|sg_dma_len
c_func
(paren
id|sg
op_minus
l_int|1
)paren
comma
op_amp
id|mptr
(braket
op_minus
l_int|2
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|chain
)paren
(brace
id|reqlen
op_assign
id|mptr
op_minus
id|msg
suffix:semicolon
)brace
id|i2o_raw_writel
c_func
(paren
id|len
comma
id|lenptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
id|SCpnt-&gt;underflow
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Cmd len %08X Cmd underflow %08X&bslash;n&quot;
comma
id|len
comma
id|SCpnt-&gt;underflow
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|dprintk
c_func
(paren
(paren
l_string|&quot;non sg for %p, %d&bslash;n&quot;
comma
id|SCpnt-&gt;request_buffer
comma
id|SCpnt-&gt;request_bufflen
)paren
)paren
suffix:semicolon
id|i2o_raw_writel
c_func
(paren
id|len
op_assign
id|SCpnt-&gt;request_bufflen
comma
id|lenptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
(brace
id|reqlen
op_assign
l_int|9
suffix:semicolon
)brace
r_else
(brace
id|dma_addr_t
id|dma_addr
suffix:semicolon
id|dma_addr
op_assign
id|pci_map_single
c_func
(paren
id|c-&gt;pdev
comma
id|SCpnt-&gt;request_buffer
comma
id|SCpnt-&gt;request_bufflen
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|SCpnt-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_addr
op_eq
l_int|0
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* How to handle ?? */
id|SCpnt-&gt;SCp.ptr
op_assign
(paren
r_char
op_star
)paren
(paren
r_int
r_int
)paren
id|dma_addr
suffix:semicolon
id|i2o_raw_writel
c_func
(paren
l_int|0xD0000000
op_or
id|direction
op_or
id|SCpnt-&gt;request_bufflen
comma
id|mptr
op_increment
)paren
suffix:semicolon
id|i2o_raw_writel
c_func
(paren
id|dma_addr
comma
id|mptr
op_increment
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Stick the headers on &n;&t; */
id|i2o_raw_writel
c_func
(paren
id|reqlen
op_lshift
l_int|16
op_or
id|SGL_OFFSET_10
comma
id|msg
)paren
suffix:semicolon
multiline_comment|/* Queue the message */
id|i2o_post_message
c_func
(paren
id|c
comma
id|m
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|queue_depth
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|queue_depth
)paren
OG
id|max_qd
)paren
(brace
id|max_qd
op_assign
id|atomic_read
c_func
(paren
op_amp
id|queue_depth
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Queue depth now %d.&bslash;n&quot;
comma
id|max_qd
)paren
suffix:semicolon
)brace
id|mb
c_func
(paren
)paren
suffix:semicolon
id|dprintk
c_func
(paren
(paren
l_string|&quot;Issued %ld&bslash;n&quot;
comma
id|current_command-&gt;serial_number
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;internal_done&t;-&t;legacy scsi glue&n; *&t;@SCPnt: command&n; *&n; *&t;Completion function for a synchronous command&n; */
DECL|function|internal_done
r_static
r_void
id|internal_done
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|SCpnt-&gt;SCp.Status
op_increment
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_scsi_command&t;-&t;issue a scsi command and wait&n; *&t;@SCPnt: command&n; *&n; *&t;Issue a SCSI command and wait for it to complete.&n; */
DECL|function|i2o_scsi_command
r_static
r_int
id|i2o_scsi_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|i2o_scsi_queuecommand
c_func
(paren
id|SCpnt
comma
id|internal_done
)paren
suffix:semicolon
id|SCpnt-&gt;SCp.Status
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|SCpnt-&gt;SCp.Status
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
r_return
id|SCpnt-&gt;result
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_scsi_abort&t;-&t;abort a running command&n; *&t;@SCpnt: command to abort&n; *&n; *&t;Ask the I2O controller to abort a command. This is an asynchrnous&n; *&t;process and oru callback handler will see the command complete&n; *&t;with an aborted message if it succeeds. &n; *&n; *&t;Locks: no locks are held or needed&n; */
DECL|function|i2o_scsi_abort
r_int
id|i2o_scsi_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_struct
id|i2o_controller
op_star
id|c
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
r_struct
id|i2o_scsi_host
op_star
id|hostdata
suffix:semicolon
r_int
r_int
id|msg
suffix:semicolon
id|u32
id|m
suffix:semicolon
r_int
id|tid
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i2o_scsi: Aborting command block.&bslash;n&quot;
)paren
suffix:semicolon
id|host
op_assign
id|SCpnt-&gt;device-&gt;host
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|i2o_scsi_host
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|tid
op_assign
id|hostdata-&gt;task
(braket
id|SCpnt-&gt;device-&gt;id
)braket
(braket
id|SCpnt-&gt;device-&gt;lun
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tid
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2o_scsi: Impossible command to abort!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
id|c
op_assign
id|hostdata-&gt;controller
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|host-&gt;host_lock
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
l_int|2
op_star
id|HZ
suffix:semicolon
r_do
(brace
id|m
op_assign
id|le32_to_cpu
c_func
(paren
id|I2O_POST_READ32
c_func
(paren
id|c
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
op_ne
l_int|0xFFFFFFFF
)paren
(brace
r_break
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
suffix:semicolon
)brace
id|msg
op_assign
id|c-&gt;mem_offset
op_plus
id|m
suffix:semicolon
id|i2o_raw_writel
c_func
(paren
id|FIVE_WORD_MSG_SIZE
comma
id|msg
)paren
suffix:semicolon
id|i2o_raw_writel
c_func
(paren
id|I2O_CMD_SCSI_ABORT
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|tid
comma
id|msg
op_plus
l_int|4
)paren
suffix:semicolon
id|i2o_raw_writel
c_func
(paren
id|scsi_context
comma
id|msg
op_plus
l_int|8
)paren
suffix:semicolon
id|i2o_raw_writel
c_func
(paren
l_int|0
comma
id|msg
op_plus
l_int|12
)paren
suffix:semicolon
multiline_comment|/* Not needed for an abort */
id|i2o_raw_writel
c_func
(paren
(paren
id|u32
)paren
id|SCpnt
comma
id|msg
op_plus
l_int|16
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|i2o_post_message
c_func
(paren
id|c
comma
id|m
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|host-&gt;host_lock
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_scsi_bus_reset&t;&t;-&t;Issue a SCSI reset&n; *&t;@SCpnt: the command that caused the reset&n; *&n; *&t;Perform a SCSI bus reset operation. In I2O this is just a message&n; *&t;we pass. I2O can do clever multi-initiator and shared reset stuff&n; *&t;but we don&squot;t support this.&n; *&n; *&t;Locks: called with no lock held, requires no locks.&n; */
DECL|function|i2o_scsi_bus_reset
r_static
r_int
id|i2o_scsi_bus_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|tid
suffix:semicolon
r_struct
id|i2o_controller
op_star
id|c
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
r_struct
id|i2o_scsi_host
op_star
id|hostdata
suffix:semicolon
id|u32
id|m
suffix:semicolon
r_int
r_int
id|msg
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Find the TID for the bus&n;&t; */
id|host
op_assign
id|SCpnt-&gt;device-&gt;host
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|host-&gt;host_lock
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i2o_scsi: Attempting to reset the bus.&bslash;n&quot;
)paren
suffix:semicolon
id|hostdata
op_assign
(paren
r_struct
id|i2o_scsi_host
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|tid
op_assign
id|hostdata-&gt;bus_task
suffix:semicolon
id|c
op_assign
id|hostdata-&gt;controller
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now send a SCSI reset request. Any remaining commands&n;&t; *&t;will be aborted by the IOP. We need to catch the reply&n;&t; *&t;possibly ?&n;&t; */
id|timeout
op_assign
id|jiffies
op_plus
l_int|2
op_star
id|HZ
suffix:semicolon
r_do
(brace
id|m
op_assign
id|le32_to_cpu
c_func
(paren
id|I2O_POST_READ32
c_func
(paren
id|c
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
op_ne
l_int|0xFFFFFFFF
)paren
(brace
r_break
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
suffix:semicolon
)brace
id|msg
op_assign
id|c-&gt;mem_offset
op_plus
id|m
suffix:semicolon
id|i2o_raw_writel
c_func
(paren
id|FOUR_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
comma
id|msg
)paren
suffix:semicolon
id|i2o_raw_writel
c_func
(paren
id|I2O_CMD_SCSI_BUSRESET
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|tid
comma
id|msg
op_plus
l_int|4
)paren
suffix:semicolon
id|i2o_raw_writel
c_func
(paren
id|scsi_context
op_or
l_int|0x80000000
comma
id|msg
op_plus
l_int|8
)paren
suffix:semicolon
multiline_comment|/* We use the top bit to split controller and unit transactions */
multiline_comment|/* Now store unit,tid so we can tie the completion back to a specific device */
id|__raw_writel
c_func
(paren
id|c-&gt;unit
op_lshift
l_int|16
op_or
id|tid
comma
id|msg
op_plus
l_int|12
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* We want the command to complete after we return */
id|spin_lock_irq
c_func
(paren
id|host-&gt;host_lock
)paren
suffix:semicolon
id|i2o_post_message
c_func
(paren
id|c
comma
id|m
)paren
suffix:semicolon
multiline_comment|/* Should we wait for the reset to complete ? */
r_return
id|SUCCESS
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_scsi_host_reset&t;-&t;host reset callback&n; *&t;@SCpnt: command causing the reset&n; *&n; *&t;An I2O controller can be many things at once. While we can&n; *&t;reset a controller the potential mess from doing so is vast, and&n; *&t;it&squot;s better to simply hold on and pray&n; */
DECL|function|i2o_scsi_host_reset
r_static
r_int
id|i2o_scsi_host_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_scsi_device_reset&t;-&t;device reset callback&n; *&t;@SCpnt: command causing the reset&n; *&n; *&t;I2O does not (AFAIK) support doing a device reset&n; */
DECL|function|i2o_scsi_device_reset
r_static
r_int
id|i2o_scsi_device_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_scsi_bios_param&t;-&t;Invent disk geometry&n; *&t;@sdev: scsi device &n; *&t;@dev: block layer device&n; *&t;@capacity: size in sectors&n; *&t;@ip: geometry array&n; *&n; *&t;This is anyones guess quite frankly. We use the same rules everyone &n; *&t;else appears to and hope. It seems to work.&n; */
DECL|function|i2o_scsi_bios_param
r_static
r_int
id|i2o_scsi_bios_param
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
comma
r_struct
id|block_device
op_star
id|dev
comma
id|sector_t
id|capacity
comma
r_int
op_star
id|ip
)paren
(brace
r_int
id|size
suffix:semicolon
id|size
op_assign
id|capacity
suffix:semicolon
id|ip
(braket
l_int|0
)braket
op_assign
l_int|64
suffix:semicolon
multiline_comment|/* heads                        */
id|ip
(braket
l_int|1
)braket
op_assign
l_int|32
suffix:semicolon
multiline_comment|/* sectors                      */
r_if
c_cond
(paren
(paren
id|ip
(braket
l_int|2
)braket
op_assign
id|size
op_rshift
l_int|11
)paren
OG
l_int|1024
)paren
(brace
multiline_comment|/* cylinders, test for big disk */
id|ip
(braket
l_int|0
)braket
op_assign
l_int|255
suffix:semicolon
multiline_comment|/* heads                        */
id|ip
(braket
l_int|1
)braket
op_assign
l_int|63
suffix:semicolon
multiline_comment|/* sectors                      */
id|ip
(braket
l_int|2
)braket
op_assign
id|size
op_div
(paren
l_int|255
op_star
l_int|63
)paren
suffix:semicolon
multiline_comment|/* cylinders                    */
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Red Hat Software&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
(brace
dot
id|proc_name
op_assign
l_string|&quot;i2o_scsi&quot;
comma
dot
id|name
op_assign
l_string|&quot;I2O SCSI Layer&quot;
comma
dot
id|detect
op_assign
id|i2o_scsi_detect
comma
dot
id|release
op_assign
id|i2o_scsi_release
comma
dot
id|info
op_assign
id|i2o_scsi_info
comma
dot
id|command
op_assign
id|i2o_scsi_command
comma
dot
id|queuecommand
op_assign
id|i2o_scsi_queuecommand
comma
dot
id|eh_abort_handler
op_assign
id|i2o_scsi_abort
comma
dot
id|eh_bus_reset_handler
op_assign
id|i2o_scsi_bus_reset
comma
dot
id|eh_device_reset_handler
op_assign
id|i2o_scsi_device_reset
comma
dot
id|eh_host_reset_handler
op_assign
id|i2o_scsi_host_reset
comma
dot
id|bios_param
op_assign
id|i2o_scsi_bios_param
comma
dot
id|can_queue
op_assign
id|I2O_SCSI_CAN_QUEUE
comma
dot
id|this_id
op_assign
l_int|15
comma
dot
id|sg_tablesize
op_assign
l_int|8
comma
dot
id|cmd_per_lun
op_assign
l_int|6
comma
dot
id|use_clustering
op_assign
id|ENABLE_CLUSTERING
comma
)brace
suffix:semicolon
macro_line|#include &quot;../../scsi/scsi_module.c&quot;
eof
