multiline_comment|/*&n; * I2O Random Block Storage Class OSM&n; *&n; * (C) Copyright 1999-2002 Red Hat&n; *&t;&n; * Written by Alan Cox, Building Number Three Ltd&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * For the purpose of avoiding doubt the preferred form of the work&n; * for making modifications shall be a standards compliant form such&n; * gzipped tar and not one requiring a proprietary or patent encumbered&n; * tool to unpack.&n; *&n; * This is a beta test release. Most of the good code was taken&n; * from the nbd driver by Pavel Machek, who in turn took some of it&n; * from loop.c. Isn&squot;t free software great for reusability 8)&n; *&n; * Fixes/additions:&n; *&t;Steve Ralston:&t;&n; *&t;&t;Multiple device handling error fixes,&n; *&t;&t;Added a queue depth.&n; *&t;Alan Cox:&t;&n; *&t;&t;FC920 has an rmw bug. Dont or in the end marker.&n; *&t;&t;Removed queue walk, fixed for 64bitness.&n; *&t;&t;Rewrote much of the code over time&n; *&t;&t;Added indirect block lists&n; *&t;&t;Handle 64K limits on many controllers&n; *&t;&t;Don&squot;t use indirects on the Promise (breaks)&n; *&t;&t;Heavily chop down the queue depths&n; *&t;Deepak Saxena:&n; *&t;&t;Independent queues per IOP&n; *&t;&t;Support for dynamic device creation/deletion&n; *&t;&t;Code cleanup&t;&n; *    &t;&t;Support for larger I/Os through merge* functions &n; *       &t;(taken from DAC960 driver)&n; *&t;Boji T Kannanthanam:&n; *&t;&t;Set the I2O Block devices to be detected in increasing &n; *&t;&t;order of TIDs during boot.&n; *&t;&t;Search and set the I2O block device that we boot off from  as&n; *&t;&t;the first device to be claimed (as /dev/i2o/hda)&n; *&t;&t;Properly attach/detach I2O gendisk structure from the system&n; *&t;&t;gendisk list. The I2O block devices now appear in &n; * &t;&t;/proc/partitions.&n; *&n; *&t;To do:&n; *&t;&t;Serial number scanning to find duplicates for FC multipathing&n; */
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/ioctl.h&gt;
macro_line|#include &lt;linux/i2o.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR I2O_MAJOR
DECL|macro|MAX_I2OB
mdefine_line|#define MAX_I2OB&t;16
DECL|macro|MAX_I2OB_DEPTH
mdefine_line|#define MAX_I2OB_DEPTH&t;8
DECL|macro|MAX_I2OB_RETRIES
mdefine_line|#define MAX_I2OB_RETRIES 4
singleline_comment|//#define DRIVERDEBUG
macro_line|#ifdef DRIVERDEBUG
DECL|macro|DEBUG
mdefine_line|#define DEBUG( s ) printk( s )
macro_line|#else
DECL|macro|DEBUG
mdefine_line|#define DEBUG( s )
macro_line|#endif
multiline_comment|/*&n; * Events that this OSM is interested in&n; */
DECL|macro|I2OB_EVENT_MASK
mdefine_line|#define I2OB_EVENT_MASK&t;&t;(I2O_EVT_IND_BSA_VOLUME_LOAD |&t;&bslash;&n;&t;&t;&t;&t; I2O_EVT_IND_BSA_VOLUME_UNLOAD | &bslash;&n;&t;&t;&t;&t; I2O_EVT_IND_BSA_VOLUME_UNLOAD_REQ | &bslash;&n;&t;&t;&t;&t; I2O_EVT_IND_BSA_CAPACITY_CHANGE | &bslash;&n;&t;&t;&t;&t; I2O_EVT_IND_BSA_SCSI_SMART )
multiline_comment|/*&n; * I2O Block Error Codes - should be in a header file really...&n; */
DECL|macro|I2O_BSA_DSC_SUCCESS
mdefine_line|#define I2O_BSA_DSC_SUCCESS             0x0000
DECL|macro|I2O_BSA_DSC_MEDIA_ERROR
mdefine_line|#define I2O_BSA_DSC_MEDIA_ERROR         0x0001
DECL|macro|I2O_BSA_DSC_ACCESS_ERROR
mdefine_line|#define I2O_BSA_DSC_ACCESS_ERROR        0x0002
DECL|macro|I2O_BSA_DSC_DEVICE_FAILURE
mdefine_line|#define I2O_BSA_DSC_DEVICE_FAILURE      0x0003
DECL|macro|I2O_BSA_DSC_DEVICE_NOT_READY
mdefine_line|#define I2O_BSA_DSC_DEVICE_NOT_READY    0x0004
DECL|macro|I2O_BSA_DSC_MEDIA_NOT_PRESENT
mdefine_line|#define I2O_BSA_DSC_MEDIA_NOT_PRESENT   0x0005
DECL|macro|I2O_BSA_DSC_MEDIA_LOCKED
mdefine_line|#define I2O_BSA_DSC_MEDIA_LOCKED        0x0006
DECL|macro|I2O_BSA_DSC_MEDIA_FAILURE
mdefine_line|#define I2O_BSA_DSC_MEDIA_FAILURE       0x0007
DECL|macro|I2O_BSA_DSC_PROTOCOL_FAILURE
mdefine_line|#define I2O_BSA_DSC_PROTOCOL_FAILURE    0x0008
DECL|macro|I2O_BSA_DSC_BUS_FAILURE
mdefine_line|#define I2O_BSA_DSC_BUS_FAILURE         0x0009
DECL|macro|I2O_BSA_DSC_ACCESS_VIOLATION
mdefine_line|#define I2O_BSA_DSC_ACCESS_VIOLATION    0x000A
DECL|macro|I2O_BSA_DSC_WRITE_PROTECTED
mdefine_line|#define I2O_BSA_DSC_WRITE_PROTECTED     0x000B
DECL|macro|I2O_BSA_DSC_DEVICE_RESET
mdefine_line|#define I2O_BSA_DSC_DEVICE_RESET        0x000C
DECL|macro|I2O_BSA_DSC_VOLUME_CHANGED
mdefine_line|#define I2O_BSA_DSC_VOLUME_CHANGED      0x000D
DECL|macro|I2O_BSA_DSC_TIMEOUT
mdefine_line|#define I2O_BSA_DSC_TIMEOUT             0x000E
DECL|macro|I2O_LOCK
mdefine_line|#define I2O_LOCK(unit)&t;(i2ob_dev[(unit)].req_queue-&gt;queue_lock)
multiline_comment|/*&n; *&t;Some of these can be made smaller later&n; */
DECL|variable|i2ob_media_change_flag
r_static
r_int
id|i2ob_media_change_flag
(braket
id|MAX_I2OB
)braket
suffix:semicolon
DECL|variable|i2ob_max_sectors
r_static
id|u32
id|i2ob_max_sectors
(braket
id|MAX_I2OB
op_lshift
l_int|4
)braket
suffix:semicolon
DECL|variable|i2ob_context
r_static
r_int
id|i2ob_context
suffix:semicolon
multiline_comment|/*&n; * I2O Block device descriptor &n; */
DECL|struct|i2ob_device
r_struct
id|i2ob_device
(brace
DECL|member|controller
r_struct
id|i2o_controller
op_star
id|controller
suffix:semicolon
DECL|member|i2odev
r_struct
id|i2o_device
op_star
id|i2odev
suffix:semicolon
DECL|member|unit
r_int
id|unit
suffix:semicolon
DECL|member|tid
r_int
id|tid
suffix:semicolon
DECL|member|flags
r_int
id|flags
suffix:semicolon
DECL|member|refcnt
r_int
id|refcnt
suffix:semicolon
DECL|member|head
DECL|member|tail
r_struct
id|request
op_star
id|head
comma
op_star
id|tail
suffix:semicolon
DECL|member|req_queue
id|request_queue_t
op_star
id|req_queue
suffix:semicolon
DECL|member|max_segments
r_int
id|max_segments
suffix:semicolon
DECL|member|max_direct
r_int
id|max_direct
suffix:semicolon
multiline_comment|/* Not yet used properly */
DECL|member|done_flag
r_int
id|done_flag
suffix:semicolon
DECL|member|depth
r_int
id|depth
suffix:semicolon
DECL|member|rcache
r_int
id|rcache
suffix:semicolon
DECL|member|wcache
r_int
id|wcache
suffix:semicolon
DECL|member|power
r_int
id|power
suffix:semicolon
DECL|member|index
r_int
id|index
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;FIXME:&n; *&t;We should cache align these to avoid ping-ponging lines on SMP&n; *&t;boxes under heavy I/O load...&n; */
DECL|struct|i2ob_request
r_struct
id|i2ob_request
(brace
DECL|member|next
r_struct
id|i2ob_request
op_star
id|next
suffix:semicolon
DECL|member|req
r_struct
id|request
op_star
id|req
suffix:semicolon
DECL|member|num
r_int
id|num
suffix:semicolon
DECL|member|sg_dma_direction
r_int
id|sg_dma_direction
suffix:semicolon
DECL|member|sg_nents
r_int
id|sg_nents
suffix:semicolon
DECL|member|sg_table
r_struct
id|scatterlist
id|sg_table
(braket
l_int|16
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Per IOP requst queue information&n; *&n; * We have a separate requeust_queue_t per IOP so that a heavilly&n; * loaded I2O block device on an IOP does not starve block devices&n; * across all I2O controllers.&n; * &n; */
DECL|struct|i2ob_iop_queue
r_struct
id|i2ob_iop_queue
(brace
DECL|member|queue_depth
id|atomic_t
id|queue_depth
suffix:semicolon
DECL|member|request_queue
r_struct
id|i2ob_request
id|request_queue
(braket
id|MAX_I2OB_DEPTH
)braket
suffix:semicolon
DECL|member|i2ob_qhead
r_struct
id|i2ob_request
op_star
id|i2ob_qhead
suffix:semicolon
DECL|member|req_queue
id|request_queue_t
op_star
id|req_queue
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|i2ob_queues
r_static
r_struct
id|i2ob_iop_queue
op_star
id|i2ob_queues
(braket
id|MAX_I2O_CONTROLLERS
)braket
suffix:semicolon
multiline_comment|/*&n; *&t;Each I2O disk is one of these.&n; */
DECL|variable|i2ob_dev
r_static
r_struct
id|i2ob_device
id|i2ob_dev
(braket
id|MAX_I2OB
op_lshift
l_int|4
)braket
suffix:semicolon
DECL|variable|i2ob_dev_count
r_static
r_int
id|i2ob_dev_count
op_assign
l_int|0
suffix:semicolon
DECL|variable|i2ob_disk
r_static
r_struct
id|gendisk
op_star
id|i2ob_disk
(braket
id|MAX_I2OB
)braket
suffix:semicolon
multiline_comment|/*&n; * Mutex and spin lock for event handling synchronization&n; * evt_msg contains the last event.&n; */
r_static
id|DECLARE_MUTEX_LOCKED
c_func
(paren
id|i2ob_evt_sem
)paren
suffix:semicolon
r_static
id|DECLARE_COMPLETION
c_func
(paren
id|i2ob_thread_dead
)paren
suffix:semicolon
DECL|variable|i2ob_evt_lock
r_static
id|spinlock_t
id|i2ob_evt_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|evt_msg
r_static
id|u32
id|evt_msg
(braket
id|MSG_FRAME_SIZE
)braket
suffix:semicolon
r_static
r_void
id|i2o_block_reply
c_func
(paren
r_struct
id|i2o_handler
op_star
comma
r_struct
id|i2o_controller
op_star
comma
r_struct
id|i2o_message
op_star
)paren
suffix:semicolon
r_static
r_void
id|i2ob_new_device
c_func
(paren
r_struct
id|i2o_controller
op_star
comma
r_struct
id|i2o_device
op_star
)paren
suffix:semicolon
r_static
r_void
id|i2ob_del_device
c_func
(paren
r_struct
id|i2o_controller
op_star
comma
r_struct
id|i2o_device
op_star
)paren
suffix:semicolon
r_static
r_void
id|i2ob_reboot_event
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|i2ob_install_device
c_func
(paren
r_struct
id|i2o_controller
op_star
comma
r_struct
id|i2o_device
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|i2ob_end_request
c_func
(paren
r_struct
id|request
op_star
)paren
suffix:semicolon
r_static
r_void
id|i2ob_request
c_func
(paren
id|request_queue_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|i2ob_init_iop
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_int
id|i2ob_query_device
c_func
(paren
r_struct
id|i2ob_device
op_star
comma
r_int
comma
r_int
comma
r_void
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|i2ob_evt
c_func
(paren
r_void
op_star
)paren
suffix:semicolon
DECL|variable|evt_pid
r_static
r_int
id|evt_pid
op_assign
l_int|0
suffix:semicolon
DECL|variable|evt_running
r_static
r_int
id|evt_running
op_assign
l_int|0
suffix:semicolon
DECL|variable|scan_unit
r_static
r_int
id|scan_unit
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * I2O OSM registration structure...keeps getting bigger and bigger :)&n; */
DECL|variable|i2o_block_handler
r_static
r_struct
id|i2o_handler
id|i2o_block_handler
op_assign
(brace
id|i2o_block_reply
comma
id|i2ob_new_device
comma
id|i2ob_del_device
comma
id|i2ob_reboot_event
comma
l_string|&quot;I2O Block OSM&quot;
comma
l_int|0
comma
id|I2O_CLASS_RANDOM_BLOCK_STORAGE
)brace
suffix:semicolon
multiline_comment|/**&n; *&t;i2ob_get&t;-&t;Get an I2O message&n; *&t;@dev:  I2O block device&n; *&n; *&t;Get a message from the FIFO used for this block device. The message is returned&n; *&t;or the I2O &squot;no message&squot; value of 0xFFFFFFFF if nothing is available.&n; */
DECL|function|i2ob_get
r_static
id|u32
id|i2ob_get
c_func
(paren
r_struct
id|i2ob_device
op_star
id|dev
)paren
(brace
r_struct
id|i2o_controller
op_star
id|c
op_assign
id|dev-&gt;controller
suffix:semicolon
r_return
id|I2O_POST_READ32
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
DECL|function|i2ob_build_sglist
r_static
r_int
id|i2ob_build_sglist
c_func
(paren
r_struct
id|i2ob_device
op_star
id|dev
comma
r_struct
id|i2ob_request
op_star
id|ireq
)paren
(brace
r_struct
id|scatterlist
op_star
id|sg
op_assign
id|ireq-&gt;sg_table
suffix:semicolon
r_int
id|nents
suffix:semicolon
id|nents
op_assign
id|blk_rq_map_sg
c_func
(paren
id|dev-&gt;req_queue
comma
id|ireq-&gt;req
comma
id|ireq-&gt;sg_table
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|ireq-&gt;req
)paren
op_eq
id|READ
)paren
id|ireq-&gt;sg_dma_direction
op_assign
id|PCI_DMA_FROMDEVICE
suffix:semicolon
r_else
id|ireq-&gt;sg_dma_direction
op_assign
id|PCI_DMA_TODEVICE
suffix:semicolon
id|ireq-&gt;sg_nents
op_assign
id|pci_map_sg
c_func
(paren
id|dev-&gt;controller-&gt;pdev
comma
id|sg
comma
id|nents
comma
id|ireq-&gt;sg_dma_direction
)paren
suffix:semicolon
r_return
id|ireq-&gt;sg_nents
suffix:semicolon
)brace
DECL|function|i2ob_free_sglist
r_void
id|i2ob_free_sglist
c_func
(paren
r_struct
id|i2ob_device
op_star
id|dev
comma
r_struct
id|i2ob_request
op_star
id|ireq
)paren
(brace
r_struct
id|pci_dev
op_star
id|pdev
op_assign
id|dev-&gt;controller-&gt;pdev
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
id|ireq-&gt;sg_table
suffix:semicolon
r_int
id|nents
op_assign
id|ireq-&gt;sg_nents
suffix:semicolon
id|pci_unmap_sg
c_func
(paren
id|pdev
comma
id|sg
comma
id|nents
comma
id|ireq-&gt;sg_dma_direction
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2ob_send&t;&t;-&t;Turn a request into a message and send it&n; *&t;@m: Message offset&n; *&t;@dev: I2O device&n; *&t;@ireq: Request structure&n; *&t;@unit: Device identity&n; *&n; *&t;Generate an I2O BSAREAD request. This interface function is called for devices that&n; *&t;appear to explode when they are fed indirect chain pointers (notably right now this&n; *&t;appears to afflict Promise hardwre, so be careful what you feed the hardware&n; *&n; *&t;No cleanup is done by this interface. It is done on the interrupt side when the&n; *&t;reply arrives&n; */
DECL|function|i2ob_send
r_static
r_int
id|i2ob_send
c_func
(paren
id|u32
id|m
comma
r_struct
id|i2ob_device
op_star
id|dev
comma
r_struct
id|i2ob_request
op_star
id|ireq
comma
r_int
id|unit
)paren
(brace
r_struct
id|i2o_controller
op_star
id|c
op_assign
id|dev-&gt;controller
suffix:semicolon
r_int
id|tid
op_assign
id|dev-&gt;tid
suffix:semicolon
r_int
r_int
id|msg
suffix:semicolon
r_int
r_int
id|mptr
suffix:semicolon
id|u64
id|offset
suffix:semicolon
r_struct
id|request
op_star
id|req
op_assign
id|ireq-&gt;req
suffix:semicolon
r_int
id|count
op_assign
id|req-&gt;nr_sectors
op_lshift
l_int|9
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
r_int
id|sgnum
suffix:semicolon
r_int
id|i
suffix:semicolon
singleline_comment|// printk(KERN_INFO &quot;i2ob_send called&bslash;n&quot;);
multiline_comment|/* Map the message to a virtual address */
id|msg
op_assign
id|c-&gt;mem_offset
op_plus
id|m
suffix:semicolon
id|sgnum
op_assign
id|i2ob_build_sglist
c_func
(paren
id|dev
comma
id|ireq
)paren
suffix:semicolon
multiline_comment|/* FIXME: if we have no resources how should we get out of this */
r_if
c_cond
(paren
id|sgnum
op_eq
l_int|0
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Build the message based on the request.&n;&t; */
id|i2o_raw_writel
c_func
(paren
id|i2ob_context
op_or
(paren
id|unit
op_lshift
l_int|8
)paren
comma
id|msg
op_plus
l_int|8
)paren
suffix:semicolon
id|i2o_raw_writel
c_func
(paren
id|ireq-&gt;num
comma
id|msg
op_plus
l_int|12
)paren
suffix:semicolon
id|i2o_raw_writel
c_func
(paren
id|req-&gt;nr_sectors
op_lshift
l_int|9
comma
id|msg
op_plus
l_int|20
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Mask out partitions from now on&n;&t; */
id|unit
op_and_assign
l_int|0xF0
suffix:semicolon
multiline_comment|/* This can be optimised later - just want to be sure its right for&n;&t;   starters */
id|offset
op_assign
(paren
(paren
id|u64
)paren
id|req-&gt;sector
)paren
op_lshift
l_int|9
suffix:semicolon
id|i2o_raw_writel
c_func
(paren
id|offset
op_amp
l_int|0xFFFFFFFF
comma
id|msg
op_plus
l_int|24
)paren
suffix:semicolon
id|i2o_raw_writel
c_func
(paren
id|offset
op_rshift
l_int|32
comma
id|msg
op_plus
l_int|28
)paren
suffix:semicolon
id|mptr
op_assign
id|msg
op_plus
l_int|32
suffix:semicolon
id|sg
op_assign
id|ireq-&gt;sg_table
suffix:semicolon
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|req
)paren
op_eq
id|READ
)paren
(brace
id|DEBUG
c_func
(paren
l_string|&quot;READ&bslash;n&quot;
)paren
suffix:semicolon
id|i2o_raw_writel
c_func
(paren
id|I2O_CMD_BLOCK_READ
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|tid
comma
id|msg
op_plus
l_int|4
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|sgnum
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|i
op_ne
l_int|1
)paren
(brace
id|i2o_raw_writel
c_func
(paren
l_int|0x10000000
op_or
id|sg_dma_len
c_func
(paren
id|sg
)paren
comma
id|mptr
)paren
suffix:semicolon
)brace
r_else
id|i2o_raw_writel
c_func
(paren
l_int|0xD0000000
op_or
id|sg_dma_len
c_func
(paren
id|sg
)paren
comma
id|mptr
)paren
suffix:semicolon
id|i2o_raw_writel
c_func
(paren
id|sg_dma_address
c_func
(paren
id|sg
)paren
comma
id|mptr
op_plus
l_int|4
)paren
suffix:semicolon
id|mptr
op_add_assign
l_int|8
suffix:semicolon
id|count
op_sub_assign
id|sg_dma_len
c_func
(paren
id|sg
)paren
suffix:semicolon
id|sg
op_increment
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|dev-&gt;rcache
)paren
(brace
r_case
id|CACHE_NULL
suffix:colon
id|i2o_raw_writel
c_func
(paren
l_int|0
comma
id|msg
op_plus
l_int|16
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CACHE_PREFETCH
suffix:colon
id|i2o_raw_writel
c_func
(paren
l_int|0x201F0008
comma
id|msg
op_plus
l_int|16
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CACHE_SMARTFETCH
suffix:colon
r_if
c_cond
(paren
id|req-&gt;nr_sectors
OG
l_int|16
)paren
(brace
id|i2o_raw_writel
c_func
(paren
l_int|0x201F0008
comma
id|msg
op_plus
l_int|16
)paren
suffix:semicolon
)brace
r_else
id|i2o_raw_writel
c_func
(paren
l_int|0x001F0000
comma
id|msg
op_plus
l_int|16
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|//&t;&t;printk(&quot;Reading %d entries %d bytes.&bslash;n&quot;,
singleline_comment|//&t;&t;&t;mptr-msg-8, req-&gt;nr_sectors&lt;&lt;9);
)brace
r_else
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|req
)paren
op_eq
id|WRITE
)paren
(brace
id|DEBUG
c_func
(paren
l_string|&quot;WRITE&bslash;n&quot;
)paren
suffix:semicolon
id|i2o_raw_writel
c_func
(paren
id|I2O_CMD_BLOCK_WRITE
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|tid
comma
id|msg
op_plus
l_int|4
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|sgnum
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|i
op_ne
l_int|1
)paren
(brace
id|i2o_raw_writel
c_func
(paren
l_int|0x14000000
op_or
id|sg_dma_len
c_func
(paren
id|sg
)paren
comma
id|mptr
)paren
suffix:semicolon
)brace
r_else
id|i2o_raw_writel
c_func
(paren
l_int|0xD4000000
op_or
id|sg_dma_len
c_func
(paren
id|sg
)paren
comma
id|mptr
)paren
suffix:semicolon
id|i2o_raw_writel
c_func
(paren
id|sg_dma_address
c_func
(paren
id|sg
)paren
comma
id|mptr
op_plus
l_int|4
)paren
suffix:semicolon
id|mptr
op_add_assign
l_int|8
suffix:semicolon
id|count
op_sub_assign
id|sg_dma_len
c_func
(paren
id|sg
)paren
suffix:semicolon
id|sg
op_increment
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|dev-&gt;wcache
)paren
(brace
r_case
id|CACHE_NULL
suffix:colon
id|i2o_raw_writel
c_func
(paren
l_int|0
comma
id|msg
op_plus
l_int|16
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CACHE_WRITETHROUGH
suffix:colon
id|i2o_raw_writel
c_func
(paren
l_int|0x001F0008
comma
id|msg
op_plus
l_int|16
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CACHE_WRITEBACK
suffix:colon
id|i2o_raw_writel
c_func
(paren
l_int|0x001F0010
comma
id|msg
op_plus
l_int|16
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CACHE_SMARTBACK
suffix:colon
r_if
c_cond
(paren
id|req-&gt;nr_sectors
OG
l_int|16
)paren
(brace
id|i2o_raw_writel
c_func
(paren
l_int|0x001F0004
comma
id|msg
op_plus
l_int|16
)paren
suffix:semicolon
)brace
r_else
id|i2o_raw_writel
c_func
(paren
l_int|0x001F0010
comma
id|msg
op_plus
l_int|16
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CACHE_SMARTTHROUGH
suffix:colon
r_if
c_cond
(paren
id|req-&gt;nr_sectors
OG
l_int|16
)paren
(brace
id|i2o_raw_writel
c_func
(paren
l_int|0x001F0004
comma
id|msg
op_plus
l_int|16
)paren
suffix:semicolon
)brace
r_else
id|i2o_raw_writel
c_func
(paren
l_int|0x001F0010
comma
id|msg
op_plus
l_int|16
)paren
suffix:semicolon
)brace
singleline_comment|//&t;&t;printk(&quot;Writing %d entries %d bytes.&bslash;n&quot;,
singleline_comment|//&t;&t;&t;mptr-msg-8, req-&gt;nr_sectors&lt;&lt;9);
)brace
id|i2o_raw_writel
c_func
(paren
id|I2O_MESSAGE_SIZE
c_func
(paren
id|mptr
op_minus
id|msg
)paren
op_rshift
l_int|2
op_or
id|SGL_OFFSET_8
comma
id|msg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Request count botched by %d.&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
)brace
id|i2o_post_message
c_func
(paren
id|c
comma
id|m
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|i2ob_queues
(braket
id|c-&gt;unit
)braket
op_member_access_from_pointer
id|queue_depth
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Remove a request from the _locked_ request list. We update both the&n; *&t;list chain and if this is the last item the tail pointer. Caller&n; *&t;must hold the lock.&n; */
DECL|function|i2ob_unhook_request
r_static
r_inline
r_void
id|i2ob_unhook_request
c_func
(paren
r_struct
id|i2ob_request
op_star
id|ireq
comma
r_int
r_int
id|iop
)paren
(brace
id|ireq-&gt;next
op_assign
id|i2ob_queues
(braket
id|iop
)braket
op_member_access_from_pointer
id|i2ob_qhead
suffix:semicolon
id|i2ob_queues
(braket
id|iop
)braket
op_member_access_from_pointer
id|i2ob_qhead
op_assign
id|ireq
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Request completion handler&n; */
DECL|function|i2ob_end_request
r_static
r_inline
r_void
id|i2ob_end_request
c_func
(paren
r_struct
id|request
op_star
id|req
)paren
(brace
multiline_comment|/* FIXME  - pci unmap the request */
multiline_comment|/*&n;&t; * Loop until all of the buffers that are linked&n;&t; * to this request have been marked updated and&n;&t; * unlocked.&n;&t; */
r_while
c_loop
(paren
id|end_that_request_first
c_func
(paren
id|req
comma
op_logical_neg
id|req-&gt;errors
comma
id|req-&gt;hard_cur_sectors
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * It is now ok to complete the request.&n;&t; */
id|end_that_request_last
c_func
(paren
id|req
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_string|&quot;IO COMPLETED&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;OSM reply handler. This gets all the message replies&n; */
DECL|function|i2o_block_reply
r_static
r_void
id|i2o_block_reply
c_func
(paren
r_struct
id|i2o_handler
op_star
id|h
comma
r_struct
id|i2o_controller
op_star
id|c
comma
r_struct
id|i2o_message
op_star
id|msg
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|i2ob_request
op_star
id|ireq
op_assign
l_int|NULL
suffix:semicolon
id|u8
id|st
suffix:semicolon
id|u32
op_star
id|m
op_assign
(paren
id|u32
op_star
)paren
id|msg
suffix:semicolon
id|u8
id|unit
op_assign
(paren
id|m
(braket
l_int|2
)braket
op_rshift
l_int|8
)paren
op_amp
l_int|0xF0
suffix:semicolon
multiline_comment|/* low 4 bits are partition */
r_struct
id|i2ob_device
op_star
id|dev
op_assign
op_amp
id|i2ob_dev
(braket
(paren
id|unit
op_amp
l_int|0xF0
)paren
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * FAILed message&n;&t; */
r_if
c_cond
(paren
id|m
(braket
l_int|0
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|13
)paren
)paren
(brace
id|DEBUG
c_func
(paren
l_string|&quot;FAIL&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * FAILed message from controller&n;&t;&t; * We increment the error count and abort it&n;&t;&t; *&n;&t;&t; * In theory this will never happen.  The I2O block class&n;&t;&t; * specification states that block devices never return&n;&t;&t; * FAILs but instead use the REQ status field...but&n;&t;&t; * better be on the safe side since no one really follows&n;&t;&t; * the spec to the book :)&n;&t;&t; */
id|ireq
op_assign
op_amp
id|i2ob_queues
(braket
id|c-&gt;unit
)braket
op_member_access_from_pointer
id|request_queue
(braket
id|m
(braket
l_int|3
)braket
)braket
suffix:semicolon
id|ireq-&gt;req-&gt;errors
op_increment
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|I2O_LOCK
c_func
(paren
id|c-&gt;unit
)paren
comma
id|flags
)paren
suffix:semicolon
id|i2ob_unhook_request
c_func
(paren
id|ireq
comma
id|c-&gt;unit
)paren
suffix:semicolon
id|i2ob_end_request
c_func
(paren
id|ireq-&gt;req
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|I2O_LOCK
c_func
(paren
id|c-&gt;unit
)paren
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Now flush the message by making it a NOP */
id|m
(braket
l_int|0
)braket
op_and_assign
l_int|0x00FFFFFF
suffix:semicolon
id|m
(braket
l_int|0
)braket
op_or_assign
(paren
id|I2O_CMD_UTIL_NOP
)paren
op_lshift
l_int|24
suffix:semicolon
id|i2o_post_message
c_func
(paren
id|c
comma
(paren
(paren
r_int
r_int
)paren
id|m
)paren
op_minus
id|c-&gt;mem_offset
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|msg-&gt;function
op_eq
id|I2O_CMD_UTIL_EVT_REGISTER
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|i2ob_evt_lock
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|evt_msg
comma
id|msg
comma
(paren
id|m
(braket
l_int|0
)braket
op_rshift
l_int|16
)paren
op_lshift
l_int|2
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|i2ob_evt_lock
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|i2ob_evt_sem
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;i2odev
)paren
(brace
multiline_comment|/*&n;&t;&t; * This is HACK, but Intel Integrated RAID allows user&n;&t;&t; * to delete a volume that is claimed, locked, and in use &n;&t;&t; * by the OS. We have to check for a reply from a&n;&t;&t; * non-existent device and flag it as an error or the system &n;&t;&t; * goes kaput...&n;&t;&t; */
id|ireq
op_assign
op_amp
id|i2ob_queues
(braket
id|c-&gt;unit
)braket
op_member_access_from_pointer
id|request_queue
(braket
id|m
(braket
l_int|3
)braket
)braket
suffix:semicolon
id|ireq-&gt;req-&gt;errors
op_increment
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;I2O Block: Data transfer to deleted device!&bslash;n&quot;
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|I2O_LOCK
c_func
(paren
id|c-&gt;unit
)paren
comma
id|flags
)paren
suffix:semicolon
id|i2ob_unhook_request
c_func
(paren
id|ireq
comma
id|c-&gt;unit
)paren
suffix:semicolon
id|i2ob_end_request
c_func
(paren
id|ireq-&gt;req
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|I2O_LOCK
c_func
(paren
id|c-&gt;unit
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Lets see what is cooking. We stuffed the&n;&t; *&t;request in the context.&n;&t; */
id|ireq
op_assign
op_amp
id|i2ob_queues
(braket
id|c-&gt;unit
)braket
op_member_access_from_pointer
id|request_queue
(braket
id|m
(braket
l_int|3
)braket
)braket
suffix:semicolon
id|st
op_assign
id|m
(braket
l_int|4
)braket
op_rshift
l_int|24
suffix:semicolon
r_if
c_cond
(paren
id|st
op_ne
l_int|0
)paren
(brace
r_int
id|err
suffix:semicolon
r_char
op_star
id|bsa_errors
(braket
)braket
op_assign
(brace
l_string|&quot;Success&quot;
comma
l_string|&quot;Media Error&quot;
comma
l_string|&quot;Failure communicating to device&quot;
comma
l_string|&quot;Device Failure&quot;
comma
l_string|&quot;Device is not ready&quot;
comma
l_string|&quot;Media not present&quot;
comma
l_string|&quot;Media is locked by another user&quot;
comma
l_string|&quot;Media has failed&quot;
comma
l_string|&quot;Failure communicating to device&quot;
comma
l_string|&quot;Device bus failure&quot;
comma
l_string|&quot;Device is locked by another user&quot;
comma
l_string|&quot;Device is write protected&quot;
comma
l_string|&quot;Device has reset&quot;
comma
l_string|&quot;Volume has changed, waiting for acknowledgement&quot;
)brace
suffix:semicolon
id|err
op_assign
id|m
(braket
l_int|4
)braket
op_amp
l_int|0xFFFF
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Device not ready means two things. One is that the&n;&t;&t; *&t;the thing went offline (but not a removal media)&n;&t;&t; *&n;&t;&t; *&t;The second is that you have a SuperTrak 100 and the&n;&t;&t; *&t;firmware got constipated. Unlike standard i2o card&n;&t;&t; *&t;setups the supertrak returns an error rather than&n;&t;&t; *&t;blocking for the timeout in these cases. &n;&t;&t; *&n;&t;&t; *&t;Don&squot;t stick a supertrak100 into cache aggressive modes&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&bslash;n/dev/%s error: %s&quot;
comma
id|dev-&gt;i2odev-&gt;dev_name
comma
id|bsa_errors
(braket
id|m
(braket
l_int|4
)braket
op_amp
l_int|0XFFFF
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
(braket
l_int|4
)braket
op_amp
l_int|0x00FF0000
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; - DDM attempted %d retries&quot;
comma
(paren
id|m
(braket
l_int|4
)braket
op_rshift
l_int|16
)paren
op_amp
l_int|0x00FF
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
id|ireq-&gt;req-&gt;errors
op_increment
suffix:semicolon
)brace
r_else
id|ireq-&gt;req-&gt;errors
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Dequeue the request. We use irqsave locks as one day we&n;&t; *&t;may be running polled controllers from a BH...&n;&t; */
id|i2ob_free_sglist
c_func
(paren
id|dev
comma
id|ireq
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|I2O_LOCK
c_func
(paren
id|c-&gt;unit
)paren
comma
id|flags
)paren
suffix:semicolon
id|i2ob_unhook_request
c_func
(paren
id|ireq
comma
id|c-&gt;unit
)paren
suffix:semicolon
id|i2ob_end_request
c_func
(paren
id|ireq-&gt;req
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|i2ob_queues
(braket
id|c-&gt;unit
)braket
op_member_access_from_pointer
id|queue_depth
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We may be able to do more I/O&n;&t; */
id|i2ob_request
c_func
(paren
id|dev-&gt;req_queue
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|I2O_LOCK
c_func
(paren
id|c-&gt;unit
)paren
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Event handler.  Needs to be a separate thread b/c we may have&n; * to do things like scan a partition table, or query parameters&n; * which cannot be done from an interrupt or from a bottom half.&n; */
DECL|function|i2ob_evt
r_static
r_int
id|i2ob_evt
c_func
(paren
r_void
op_star
id|dummy
)paren
(brace
r_int
r_int
id|evt
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|unit
suffix:semicolon
r_int
id|i
suffix:semicolon
singleline_comment|//The only event that has data is the SCSI_SMART event.
r_struct
id|i2o_reply
(brace
id|u32
id|header
(braket
l_int|4
)braket
suffix:semicolon
id|u32
id|evt_indicator
suffix:semicolon
id|u8
id|ASC
suffix:semicolon
id|u8
id|ASCQ
suffix:semicolon
id|u16
id|pad
suffix:semicolon
id|u8
id|data
(braket
l_int|16
)braket
suffix:semicolon
)brace
op_star
id|evt_local
suffix:semicolon
id|daemonize
c_func
(paren
l_string|&quot;i2oblock&quot;
)paren
suffix:semicolon
id|allow_signal
c_func
(paren
id|SIGKILL
)paren
suffix:semicolon
id|evt_running
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|i2ob_evt_sem
)paren
)paren
(brace
id|evt_running
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;exiting...&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Keep another CPU/interrupt from overwriting the &n;&t;&t; * message while we&squot;re reading it&n;&t;&t; *&n;&t;&t; * We stuffed the unit in the TxContext and grab the event mask&n;&t;&t; * None of the BSA we care about events have EventData&n;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|i2ob_evt_lock
comma
id|flags
)paren
suffix:semicolon
id|evt_local
op_assign
(paren
r_struct
id|i2o_reply
op_star
)paren
id|evt_msg
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|i2ob_evt_lock
comma
id|flags
)paren
suffix:semicolon
id|unit
op_assign
id|le32_to_cpu
c_func
(paren
id|evt_local-&gt;header
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|evt
op_assign
id|le32_to_cpu
c_func
(paren
id|evt_local-&gt;evt_indicator
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|evt
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * New volume loaded on same TID, so we just re-install.&n;&t;&t;&t; * The TID/controller don&squot;t change as it is the same&n;&t;&t;&t; * I2O device.  It&squot;s just new media that we have to&n;&t;&t;&t; * rescan.&n;&t;&t;&t; */
r_case
id|I2O_EVT_IND_BSA_VOLUME_LOAD
suffix:colon
(brace
r_struct
id|gendisk
op_star
id|p
op_assign
id|i2ob_disk
(braket
id|unit
op_rshift
l_int|4
)braket
suffix:semicolon
id|i2ob_install_device
c_func
(paren
id|i2ob_dev
(braket
id|unit
)braket
dot
id|i2odev-&gt;controller
comma
id|i2ob_dev
(braket
id|unit
)braket
dot
id|i2odev
comma
id|unit
)paren
suffix:semicolon
id|add_disk
c_func
(paren
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * No media, so set all parameters to 0 and set the media&n;&t;&t;&t; * change flag. The I2O device is still valid, just doesn&squot;t&n;&t;&t;&t; * have media, so we don&squot;t want to clear the controller or&n;&t;&t;&t; * device pointer.&n;&t;&t;&t; */
r_case
id|I2O_EVT_IND_BSA_VOLUME_UNLOAD
suffix:colon
(brace
r_struct
id|gendisk
op_star
id|p
op_assign
id|i2ob_disk
(braket
id|unit
op_rshift
l_int|4
)braket
suffix:semicolon
id|del_gendisk
c_func
(paren
id|p
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|unit
suffix:semicolon
id|i
op_le
id|unit
op_plus
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
id|blk_queue_max_sectors
c_func
(paren
id|i2ob_dev
(braket
id|i
)braket
dot
id|req_queue
comma
l_int|0
)paren
suffix:semicolon
)brace
id|i2ob_media_change_flag
(braket
id|unit
)braket
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|I2O_EVT_IND_BSA_VOLUME_UNLOAD_REQ
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Attempt to eject locked media&bslash;n&quot;
comma
id|i2ob_dev
(braket
id|unit
)braket
dot
id|i2odev-&gt;dev_name
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * The capacity has changed and we are going to be&n;&t;&t;&t; * updating the max_sectors and other information &n;&t;&t;&t; * about this disk.  We try a revalidate first. If&n;&t;&t;&t; * the block device is in use, we don&squot;t want to&n;&t;&t;&t; * do that as there may be I/Os bound for the disk&n;&t;&t;&t; * at the moment.  In that case we read the size &n;&t;&t;&t; * from the device and update the information ourselves&n;&t;&t;&t; * and the user can later force a partition table&n;&t;&t;&t; * update through an ioctl.&n;&t;&t;&t; */
r_case
id|I2O_EVT_IND_BSA_CAPACITY_CHANGE
suffix:colon
(brace
id|u64
id|size
suffix:semicolon
r_if
c_cond
(paren
id|i2ob_query_device
c_func
(paren
op_amp
id|i2ob_dev
(braket
id|unit
)braket
comma
l_int|0x0004
comma
l_int|0
comma
op_amp
id|size
comma
l_int|8
)paren
op_ne
l_int|0
)paren
(brace
id|i2ob_query_device
c_func
(paren
op_amp
id|i2ob_dev
(braket
id|unit
)braket
comma
l_int|0x0000
comma
l_int|4
comma
op_amp
id|size
comma
l_int|8
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
id|I2O_LOCK
c_func
(paren
id|unit
)paren
comma
id|flags
)paren
suffix:semicolon
id|set_capacity
c_func
(paren
id|i2ob_disk
(braket
id|unit
op_rshift
l_int|4
)braket
comma
id|size
op_rshift
l_int|9
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|I2O_LOCK
c_func
(paren
id|unit
)paren
comma
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t;&t; * We got a SCSI SMART event, we just log the relevant&n;&t;&t;&t; * information and let the user decide what they want&n;&t;&t;&t; * to do with the information.&n;&t;&t;&t; */
r_case
id|I2O_EVT_IND_BSA_SCSI_SMART
suffix:colon
(brace
r_char
id|buf
(braket
l_int|16
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;I2O Block: %s received a SCSI SMART Event&bslash;n&quot;
comma
id|i2ob_dev
(braket
id|unit
)braket
dot
id|i2odev-&gt;dev_name
)paren
suffix:semicolon
id|evt_local-&gt;data
(braket
l_int|16
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%s&quot;
comma
op_amp
id|evt_local-&gt;data
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;      Disk Serial#:%s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;      ASC 0x%02x &bslash;n&quot;
comma
id|evt_local-&gt;ASC
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;      ASCQ 0x%02x &bslash;n&quot;
comma
id|evt_local-&gt;ASCQ
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *&t;Non event&n;&t;&t;&t; */
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * An event we didn&squot;t ask for.  Call the card manufacturer&n;&t;&t;&t; * and tell them to fix their firmware :)&n;&t;&t;&t; */
r_case
l_int|0x20
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * If a promise card reports 0x20 event then the brown stuff&n;&t;&t;&t;&t; * hit the fan big time. The card seems to recover but loses&n;&t;&t;&t;&t; * the pending writes. Deeply ungood except for testing fsck&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|i2ob_dev
(braket
id|unit
)braket
dot
id|i2odev-&gt;controller-&gt;promise
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;I2O controller firmware failed. Reboot and force a filesystem check.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Received event 0x%X we didn&squot;t register for&bslash;n&quot;
id|KERN_INFO
l_string|&quot;   Blame the I2O card manufacturer 8)&bslash;n&quot;
comma
id|i2ob_dev
(braket
id|unit
)braket
dot
id|i2odev-&gt;dev_name
comma
id|evt
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
suffix:semicolon
id|complete_and_exit
c_func
(paren
op_amp
id|i2ob_thread_dead
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;The I2O block driver is listed as one of those that pulls the&n; *&t;front entry off the queue before processing it. This is important&n; *&t;to remember here. If we drop the io lock then CURRENT will change&n; *&t;on us. We must unlink CURRENT in this routine before we return, if&n; *&t;we use it.&n; */
DECL|function|i2ob_request
r_static
r_void
id|i2ob_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_struct
id|request
op_star
id|req
suffix:semicolon
r_struct
id|i2ob_request
op_star
id|ireq
suffix:semicolon
r_struct
id|i2ob_device
op_star
id|dev
suffix:semicolon
id|u32
id|m
suffix:semicolon
r_while
c_loop
(paren
(paren
id|req
op_assign
id|elv_next_request
c_func
(paren
id|q
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;On an IRQ completion if there is an inactive&n;&t;&t; *&t;request on the queue head it means it isnt yet&n;&t;&t; *&t;ready to dispatch.&n;&t;&t; */
r_if
c_cond
(paren
id|req-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
r_return
suffix:semicolon
)brace
id|dev
op_assign
id|req-&gt;rq_disk-&gt;private_data
suffix:semicolon
multiline_comment|/* &n;&t;&t; *&t;Queue depths probably belong with some kind of &n;&t;&t; *&t;generic IOP commit control. Certainly it&squot;s not right &n;&t;&t; *&t;its global!  &n;&t;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|i2ob_queues
(braket
id|dev-&gt;unit
)braket
op_member_access_from_pointer
id|queue_depth
)paren
op_ge
id|dev-&gt;depth
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* Get a message */
id|m
op_assign
id|i2ob_get
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
op_eq
l_int|0xFFFFFFFF
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|i2ob_queues
(braket
id|dev-&gt;unit
)braket
op_member_access_from_pointer
id|queue_depth
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2o_block: message queue and request queue empty!!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Everything ok, so pull from kernel queue onto our queue&n;&t;&t; */
id|req-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|blkdev_dequeue_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|req-&gt;waiting
op_assign
l_int|NULL
suffix:semicolon
id|ireq
op_assign
id|i2ob_queues
(braket
id|dev-&gt;unit
)braket
op_member_access_from_pointer
id|i2ob_qhead
suffix:semicolon
id|i2ob_queues
(braket
id|dev-&gt;unit
)braket
op_member_access_from_pointer
id|i2ob_qhead
op_assign
id|ireq-&gt;next
suffix:semicolon
id|ireq-&gt;req
op_assign
id|req
suffix:semicolon
id|i2ob_send
c_func
(paren
id|m
comma
id|dev
comma
id|ireq
comma
(paren
id|dev-&gt;unit
op_amp
l_int|0xF0
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;SCSI-CAM for ioctl geometry mapping&n; *&t;Duplicated with SCSI - this should be moved into somewhere common&n; *&t;perhaps genhd ?&n; *&n; * LBA -&gt; CHS mapping table taken from:&n; *&n; * &quot;Incorporating the I2O Architecture into BIOS for Intel Architecture &n; *  Platforms&quot; &n; *&n; * This is an I2O document that is only available to I2O members,&n; * not developers.&n; *&n; * From my understanding, this is how all the I2O cards do this&n; *&n; * Disk Size      | Sectors | Heads | Cylinders&n; * ---------------+---------+-------+-------------------&n; * 1 &lt; X &lt;= 528M  | 63      | 16    | X/(63 * 16 * 512)&n; * 528M &lt; X &lt;= 1G | 63      | 32    | X/(63 * 32 * 512)&n; * 1 &lt; X &lt;528M    | 63      | 16    | X/(63 * 16 * 512)&n; * 1 &lt; X &lt;528M    | 63      | 16    | X/(63 * 16 * 512)&n; *&n; */
DECL|macro|BLOCK_SIZE_528M
mdefine_line|#define&t;BLOCK_SIZE_528M&t;&t;1081344
DECL|macro|BLOCK_SIZE_1G
mdefine_line|#define&t;BLOCK_SIZE_1G&t;&t;2097152
DECL|macro|BLOCK_SIZE_21G
mdefine_line|#define&t;BLOCK_SIZE_21G&t;&t;4403200
DECL|macro|BLOCK_SIZE_42G
mdefine_line|#define&t;BLOCK_SIZE_42G&t;&t;8806400
DECL|macro|BLOCK_SIZE_84G
mdefine_line|#define&t;BLOCK_SIZE_84G&t;&t;17612800
DECL|function|i2o_block_biosparam
r_static
r_void
id|i2o_block_biosparam
c_func
(paren
r_int
r_int
id|capacity
comma
r_int
r_int
op_star
id|cyls
comma
r_int
r_char
op_star
id|hds
comma
r_int
r_char
op_star
id|secs
)paren
(brace
r_int
r_int
id|heads
comma
id|sectors
comma
id|cylinders
suffix:semicolon
id|sectors
op_assign
l_int|63L
suffix:semicolon
multiline_comment|/* Maximize sectors per track */
r_if
c_cond
(paren
id|capacity
op_le
id|BLOCK_SIZE_528M
)paren
(brace
id|heads
op_assign
l_int|16
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|capacity
op_le
id|BLOCK_SIZE_1G
)paren
(brace
id|heads
op_assign
l_int|32
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|capacity
op_le
id|BLOCK_SIZE_21G
)paren
(brace
id|heads
op_assign
l_int|64
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|capacity
op_le
id|BLOCK_SIZE_42G
)paren
(brace
id|heads
op_assign
l_int|128
suffix:semicolon
)brace
r_else
id|heads
op_assign
l_int|255
suffix:semicolon
id|cylinders
op_assign
(paren
r_int
r_int
)paren
id|capacity
op_div
(paren
id|heads
op_star
id|sectors
)paren
suffix:semicolon
op_star
id|cyls
op_assign
(paren
r_int
r_int
)paren
id|cylinders
suffix:semicolon
multiline_comment|/* Stuff return values */
op_star
id|secs
op_assign
(paren
r_int
r_char
)paren
id|sectors
suffix:semicolon
op_star
id|hds
op_assign
(paren
r_int
r_char
)paren
id|heads
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Issue device specific ioctl calls.&n; */
DECL|function|i2ob_ioctl
r_static
r_int
id|i2ob_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|inode-&gt;i_bdev-&gt;bd_disk
suffix:semicolon
r_struct
id|i2ob_device
op_star
id|dev
op_assign
id|disk-&gt;private_data
suffix:semicolon
multiline_comment|/* Anyone capable of this syscall can do *real bad* things */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|HDIO_GETGEO
suffix:colon
(brace
r_struct
id|hd_geometry
id|g
suffix:semicolon
id|i2o_block_biosparam
c_func
(paren
id|get_capacity
c_func
(paren
id|disk
)paren
comma
op_amp
id|g.cylinders
comma
op_amp
id|g.heads
comma
op_amp
id|g.sectors
)paren
suffix:semicolon
id|g.start
op_assign
id|get_start_sect
c_func
(paren
id|inode-&gt;i_bdev
)paren
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|g
comma
r_sizeof
(paren
id|g
)paren
)paren
ques
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
r_case
id|BLKI2OGRSTRAT
suffix:colon
r_return
id|put_user
c_func
(paren
id|dev-&gt;rcache
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|BLKI2OGWSTRAT
suffix:colon
r_return
id|put_user
c_func
(paren
id|dev-&gt;wcache
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|BLKI2OSRSTRAT
suffix:colon
r_if
c_cond
(paren
id|arg
id|CACHE_SMARTFETCH
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|dev-&gt;rcache
op_assign
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BLKI2OSWSTRAT
suffix:colon
r_if
c_cond
(paren
id|arg
op_ne
l_int|0
op_logical_and
(paren
id|arg
id|CACHE_SMARTBACK
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|dev-&gt;wcache
op_assign
id|arg
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
op_minus
id|ENOTTY
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Close the block device down&n; */
DECL|function|i2ob_release
r_static
r_int
id|i2ob_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|inode-&gt;i_bdev-&gt;bd_disk
suffix:semicolon
r_struct
id|i2ob_device
op_star
id|dev
op_assign
id|disk-&gt;private_data
suffix:semicolon
multiline_comment|/*&n;&t; * This is to deail with the case of an application&n;&t; * opening a device and then the device dissapears while&n;&t; * it&squot;s in use, and then the application tries to release&n;&t; * it.  ex: Unmounting a deleted RAID volume at reboot. &n;&t; * If we send messages, it will just cause FAILs since&n;&t; * the TID no longer exists.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;i2odev
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;refcnt
op_le
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;i2ob_release: refcount(%d) &lt;= 0&bslash;n&quot;
comma
id|dev-&gt;refcnt
)paren
suffix:semicolon
id|dev-&gt;refcnt
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;refcnt
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Flush the onboard cache on unmount&n;&t;&t; */
id|u32
id|msg
(braket
l_int|5
)braket
suffix:semicolon
r_int
op_star
id|query_done
op_assign
op_amp
id|dev-&gt;done_flag
suffix:semicolon
id|msg
(braket
l_int|0
)braket
op_assign
(paren
id|FIVE_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
)paren
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_BLOCK_CFLUSH
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|dev-&gt;tid
suffix:semicolon
id|msg
(braket
l_int|2
)braket
op_assign
id|i2ob_context
op_or
l_int|0x40000000
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
(paren
id|u32
)paren
id|query_done
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
l_int|60
op_lshift
l_int|16
suffix:semicolon
id|DEBUG
c_func
(paren
l_string|&quot;Flushing...&quot;
)paren
suffix:semicolon
id|i2o_post_wait
c_func
(paren
id|dev-&gt;controller
comma
id|msg
comma
l_int|20
comma
l_int|60
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Unlock the media&n;&t;&t; */
id|msg
(braket
l_int|0
)braket
op_assign
id|FIVE_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_BLOCK_MUNLOCK
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|dev-&gt;tid
suffix:semicolon
id|msg
(braket
l_int|2
)braket
op_assign
id|i2ob_context
op_or
l_int|0x40000000
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
(paren
id|u32
)paren
id|query_done
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|DEBUG
c_func
(paren
l_string|&quot;Unlocking...&quot;
)paren
suffix:semicolon
id|i2o_post_wait
c_func
(paren
id|dev-&gt;controller
comma
id|msg
comma
l_int|20
comma
l_int|2
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_string|&quot;Unlocked.&bslash;n&quot;
)paren
suffix:semicolon
id|msg
(braket
l_int|0
)braket
op_assign
id|FOUR_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_BLOCK_POWER
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|dev-&gt;tid
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
(paren
l_int|1
op_lshift
l_int|3
op_or
l_int|1
op_lshift
l_int|4
)paren
)paren
(brace
multiline_comment|/* Removable */
id|msg
(braket
l_int|4
)braket
op_assign
l_int|0x21
op_lshift
l_int|24
suffix:semicolon
)brace
r_else
id|msg
(braket
l_int|4
)braket
op_assign
l_int|0x24
op_lshift
l_int|24
suffix:semicolon
r_if
c_cond
(paren
id|i2o_post_wait
c_func
(paren
id|dev-&gt;controller
comma
id|msg
comma
l_int|20
comma
l_int|60
)paren
op_eq
l_int|0
)paren
(brace
id|dev-&gt;power
op_assign
l_int|0x24
suffix:semicolon
)brace
multiline_comment|/*&n; &t;&t; * Now unclaim the device.&n;&t;&t; */
r_if
c_cond
(paren
id|i2o_release_device
c_func
(paren
id|dev-&gt;i2odev
comma
op_amp
id|i2o_block_handler
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2ob_release: controller rejected unclaim.&bslash;n&quot;
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_string|&quot;Unclaim&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Open the block device.&n; */
DECL|function|i2ob_open
r_static
r_int
id|i2ob_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|inode-&gt;i_bdev-&gt;bd_disk
suffix:semicolon
r_struct
id|i2ob_device
op_star
id|dev
op_assign
id|disk-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;i2odev
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;refcnt
op_increment
op_eq
l_int|0
)paren
(brace
id|u32
id|msg
(braket
l_int|6
)braket
suffix:semicolon
id|DEBUG
c_func
(paren
l_string|&quot;Claim &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i2o_claim_device
c_func
(paren
id|dev-&gt;i2odev
comma
op_amp
id|i2o_block_handler
)paren
)paren
(brace
id|dev-&gt;refcnt
op_decrement
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;I2O Block: Could not open device&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_string|&quot;Claimed &quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; &t; *&t;Power up if needed&n;&t; &t; */
r_if
c_cond
(paren
id|dev-&gt;power
OG
l_int|0x1f
)paren
(brace
id|msg
(braket
l_int|0
)braket
op_assign
id|FOUR_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_BLOCK_POWER
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|dev-&gt;tid
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
l_int|0x02
op_lshift
l_int|24
suffix:semicolon
r_if
c_cond
(paren
id|i2o_post_wait
c_func
(paren
id|dev-&gt;controller
comma
id|msg
comma
l_int|20
comma
l_int|60
)paren
op_eq
l_int|0
)paren
(brace
id|dev-&gt;power
op_assign
l_int|0x02
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; *&t;Mount the media if needed. Note that we don&squot;t use&n;&t;&t; *&t;the lock bit. Since we have to issue a lock if it&n;&t;&t; *&t;refuses a mount (quite possible) then we might as&n;&t;&t; *&t;well just send two messages out.&n;&t;&t; */
id|msg
(braket
l_int|0
)braket
op_assign
id|FIVE_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_BLOCK_MMOUNT
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|dev-&gt;tid
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|msg
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
l_string|&quot;Mount &quot;
)paren
suffix:semicolon
id|i2o_post_wait
c_func
(paren
id|dev-&gt;controller
comma
id|msg
comma
l_int|24
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Lock the media&n;&t;&t; */
id|msg
(braket
l_int|0
)braket
op_assign
id|FIVE_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_BLOCK_MLOCK
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|dev-&gt;tid
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|DEBUG
c_func
(paren
l_string|&quot;Lock &quot;
)paren
suffix:semicolon
id|i2o_post_wait
c_func
(paren
id|dev-&gt;controller
comma
id|msg
comma
l_int|20
comma
l_int|2
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_string|&quot;Ready.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Issue a device query&n; */
DECL|function|i2ob_query_device
r_static
r_int
id|i2ob_query_device
c_func
(paren
r_struct
id|i2ob_device
op_star
id|dev
comma
r_int
id|table
comma
r_int
id|field
comma
r_void
op_star
id|buf
comma
r_int
id|buflen
)paren
(brace
r_return
id|i2o_query_scalar
c_func
(paren
id|dev-&gt;controller
comma
id|dev-&gt;tid
comma
id|table
comma
id|field
comma
id|buf
comma
id|buflen
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Install the I2O block device we found.&n; */
DECL|function|i2ob_install_device
r_static
r_int
id|i2ob_install_device
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
comma
r_struct
id|i2o_device
op_star
id|d
comma
r_int
id|unit
)paren
(brace
id|u64
id|size
suffix:semicolon
id|u32
id|blocksize
suffix:semicolon
id|u8
id|type
suffix:semicolon
id|u16
id|power
suffix:semicolon
id|u32
id|flags
comma
id|status
suffix:semicolon
r_struct
id|i2ob_device
op_star
id|dev
op_assign
op_amp
id|i2ob_dev
(braket
id|unit
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * For logging purposes...&n;&t; */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;i2ob: Installing tid %d device at unit %d&bslash;n&quot;
comma
id|d-&gt;lct_data.tid
comma
id|unit
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Ask for the current media data. If that isn&squot;t supported&n;&t; *&t;then we ask for the device capacity data&n;&t; */
r_if
c_cond
(paren
id|i2ob_query_device
c_func
(paren
id|dev
comma
l_int|0x0004
comma
l_int|1
comma
op_amp
id|blocksize
comma
l_int|4
)paren
op_ne
l_int|0
op_logical_or
id|i2ob_query_device
c_func
(paren
id|dev
comma
l_int|0x0004
comma
l_int|0
comma
op_amp
id|size
comma
l_int|8
)paren
op_ne
l_int|0
)paren
(brace
id|i2ob_query_device
c_func
(paren
id|dev
comma
l_int|0x0000
comma
l_int|3
comma
op_amp
id|blocksize
comma
l_int|4
)paren
suffix:semicolon
id|i2ob_query_device
c_func
(paren
id|dev
comma
l_int|0x0000
comma
l_int|4
comma
op_amp
id|size
comma
l_int|8
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i2ob_query_device
c_func
(paren
id|dev
comma
l_int|0x0000
comma
l_int|2
comma
op_amp
id|power
comma
l_int|2
)paren
op_ne
l_int|0
)paren
(brace
id|power
op_assign
l_int|0
suffix:semicolon
)brace
id|i2ob_query_device
c_func
(paren
id|dev
comma
l_int|0x0000
comma
l_int|5
comma
op_amp
id|flags
comma
l_int|4
)paren
suffix:semicolon
id|i2ob_query_device
c_func
(paren
id|dev
comma
l_int|0x0000
comma
l_int|6
comma
op_amp
id|status
comma
l_int|4
)paren
suffix:semicolon
id|set_capacity
c_func
(paren
id|i2ob_disk
(braket
id|unit
op_rshift
l_int|4
)braket
comma
id|size
op_rshift
l_int|9
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Max number of Scatter-Gather Elements&n;&t; */
id|i2ob_dev
(braket
id|unit
)braket
dot
id|power
op_assign
id|power
suffix:semicolon
multiline_comment|/* Save power state in device proper */
id|i2ob_dev
(braket
id|unit
)braket
dot
id|flags
op_assign
id|flags
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|unit
suffix:semicolon
id|i
op_le
id|unit
op_plus
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
id|request_queue_t
op_star
id|q
op_assign
id|i2ob_dev
(braket
id|unit
)braket
dot
id|req_queue
suffix:semicolon
r_int
id|segments
op_assign
(paren
id|d-&gt;controller-&gt;status_block-&gt;inbound_frame_size
op_minus
l_int|7
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|segments
OG
l_int|16
)paren
(brace
id|segments
op_assign
l_int|16
suffix:semicolon
)brace
id|i2ob_dev
(braket
id|i
)braket
dot
id|power
op_assign
id|power
suffix:semicolon
multiline_comment|/* Save power state */
id|i2ob_dev
(braket
id|unit
)braket
dot
id|flags
op_assign
id|flags
suffix:semicolon
multiline_comment|/* Keep the type info */
id|blk_queue_max_sectors
c_func
(paren
id|q
comma
l_int|96
)paren
suffix:semicolon
multiline_comment|/* 256 might be nicer but many controllers &n;&t;&t;&t;&t;&t;&t;   explode on 65536 or higher */
id|blk_queue_max_phys_segments
c_func
(paren
id|q
comma
id|segments
)paren
suffix:semicolon
id|blk_queue_max_hw_segments
c_func
(paren
id|q
comma
id|segments
)paren
suffix:semicolon
id|i2ob_dev
(braket
id|i
)braket
dot
id|rcache
op_assign
id|CACHE_SMARTFETCH
suffix:semicolon
id|i2ob_dev
(braket
id|i
)braket
dot
id|wcache
op_assign
id|CACHE_WRITETHROUGH
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;controller-&gt;battery
op_eq
l_int|0
)paren
(brace
id|i2ob_dev
(braket
id|i
)braket
dot
id|wcache
op_assign
id|CACHE_WRITETHROUGH
suffix:semicolon
)brace
r_if
c_cond
(paren
id|d-&gt;controller-&gt;promise
)paren
(brace
id|i2ob_dev
(braket
id|i
)braket
dot
id|wcache
op_assign
id|CACHE_WRITETHROUGH
suffix:semicolon
)brace
r_if
c_cond
(paren
id|d-&gt;controller-&gt;short_req
)paren
(brace
id|blk_queue_max_sectors
c_func
(paren
id|q
comma
l_int|8
)paren
suffix:semicolon
id|blk_queue_max_phys_segments
c_func
(paren
id|q
comma
l_int|8
)paren
suffix:semicolon
id|blk_queue_max_hw_segments
c_func
(paren
id|q
comma
l_int|8
)paren
suffix:semicolon
)brace
)brace
id|strcpy
c_func
(paren
id|d-&gt;dev_name
comma
id|i2ob_disk
(braket
id|unit
op_rshift
l_int|4
)braket
op_member_access_from_pointer
id|disk_name
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Max segments %d, queue depth %d, byte limit %d.&bslash;n&quot;
comma
id|d-&gt;dev_name
comma
id|i2ob_dev
(braket
id|unit
)braket
dot
id|max_segments
comma
id|i2ob_dev
(braket
id|unit
)braket
dot
id|depth
comma
id|i2ob_max_sectors
(braket
id|unit
)braket
op_lshift
l_int|9
)paren
suffix:semicolon
id|i2ob_query_device
c_func
(paren
id|dev
comma
l_int|0x0000
comma
l_int|0
comma
op_amp
id|type
comma
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: &quot;
comma
id|d-&gt;dev_name
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
l_int|0
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Disk Storage&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|printk
c_func
(paren
l_string|&quot;WORM&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|printk
c_func
(paren
l_string|&quot;CD-ROM&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Optical device&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Type %d&quot;
comma
id|type
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
l_int|10
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;(RAID)&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|flags
op_xor
id|status
)paren
op_amp
(paren
l_int|1
op_lshift
l_int|4
op_or
l_int|1
op_lshift
l_int|3
)paren
)paren
multiline_comment|/* Missing media or device */
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot; Not loaded.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Device missing ? */
r_if
c_cond
(paren
(paren
id|flags
op_xor
id|status
)paren
op_amp
(paren
l_int|1
op_lshift
l_int|4
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;: %dMB, %d byte sectors&quot;
comma
(paren
r_int
)paren
(paren
id|size
op_rshift
l_int|20
)paren
comma
id|blocksize
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
l_int|0
)paren
)paren
(brace
id|u32
id|cachesize
suffix:semicolon
id|i2ob_query_device
c_func
(paren
id|dev
comma
l_int|0x0003
comma
l_int|0
comma
op_amp
id|cachesize
comma
l_int|4
)paren
suffix:semicolon
id|cachesize
op_rshift_assign
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|cachesize
OG
l_int|4095
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, %dMb cache&quot;
comma
id|cachesize
op_rshift
l_int|10
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;, %dKb cache&quot;
comma
id|cachesize
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Maximum sectors/read set to %d.&bslash;n&quot;
comma
id|d-&gt;dev_name
comma
id|i2ob_max_sectors
(braket
id|unit
)braket
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * If this is the first I2O block device found on this IOP,&n;&t; * we need to initialize all the queue data structures&n;&t; * before any I/O can be performed. If it fails, this&n;&t; * device is useless.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|i2ob_queues
(braket
id|c-&gt;unit
)braket
)paren
(brace
r_if
c_cond
(paren
id|i2ob_init_iop
c_func
(paren
id|c-&gt;unit
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* &n;&t; * This will save one level of lookup/indirection in critical &n;&t; * code so that we can directly get the queue ptr from the&n;&t; * device instead of having to go the IOP data structure.&n;&t; */
id|dev-&gt;req_queue
op_assign
id|i2ob_queues
(braket
id|c-&gt;unit
)braket
op_member_access_from_pointer
id|req_queue
suffix:semicolon
multiline_comment|/* Register a size before we register for events - otherwise we&n;&t;   might miss and overwrite an event */
id|set_capacity
c_func
(paren
id|i2ob_disk
(braket
id|unit
op_rshift
l_int|4
)braket
comma
id|size
op_rshift
l_int|9
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Register for the events we&squot;re interested in and that the&n;&t; * device actually supports.&n;&t; */
id|i2o_event_register
c_func
(paren
id|c
comma
id|d-&gt;lct_data.tid
comma
id|i2ob_context
comma
id|unit
comma
(paren
id|I2OB_EVENT_MASK
op_amp
id|d-&gt;lct_data.event_capabilities
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize IOP specific queue structures.  This is called&n; * once for each IOP that has a block device sitting behind it.&n; */
DECL|function|i2ob_init_iop
r_static
r_int
id|i2ob_init_iop
c_func
(paren
r_int
r_int
id|unit
)paren
(brace
r_int
id|i
suffix:semicolon
id|i2ob_queues
(braket
id|unit
)braket
op_assign
(paren
r_struct
id|i2ob_iop_queue
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|i2ob_iop_queue
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i2ob_queues
(braket
id|unit
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Could not allocate request queue for I2O block device!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2OB_DEPTH
suffix:semicolon
id|i
op_increment
)paren
(brace
id|i2ob_queues
(braket
id|unit
)braket
op_member_access_from_pointer
id|request_queue
(braket
id|i
)braket
dot
id|next
op_assign
op_amp
id|i2ob_queues
(braket
id|unit
)braket
op_member_access_from_pointer
id|request_queue
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
id|i2ob_queues
(braket
id|unit
)braket
op_member_access_from_pointer
id|request_queue
(braket
id|i
)braket
dot
id|num
op_assign
id|i
suffix:semicolon
)brace
multiline_comment|/* Queue is MAX_I2OB + 1... */
id|i2ob_queues
(braket
id|unit
)braket
op_member_access_from_pointer
id|request_queue
(braket
id|i
)braket
dot
id|next
op_assign
l_int|NULL
suffix:semicolon
id|i2ob_queues
(braket
id|unit
)braket
op_member_access_from_pointer
id|i2ob_qhead
op_assign
op_amp
id|i2ob_queues
(braket
id|unit
)braket
op_member_access_from_pointer
id|request_queue
(braket
l_int|0
)braket
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|i2ob_queues
(braket
id|unit
)braket
op_member_access_from_pointer
id|queue_depth
comma
l_int|0
)paren
suffix:semicolon
id|i2ob_queues
(braket
id|unit
)braket
op_member_access_from_pointer
id|req_queue
op_assign
id|blk_init_queue
c_func
(paren
id|i2ob_request
comma
op_amp
id|i2ob_queues
(braket
id|unit
)braket
op_member_access_from_pointer
id|lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i2ob_queues
(braket
id|unit
)braket
op_member_access_from_pointer
id|req_queue
)paren
(brace
id|kfree
c_func
(paren
id|i2ob_queues
(braket
id|unit
)braket
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|i2ob_queues
(braket
id|unit
)braket
op_member_access_from_pointer
id|req_queue-&gt;queuedata
op_assign
op_amp
id|i2ob_queues
(braket
id|unit
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Probe the I2O subsytem for block class devices&n; */
DECL|function|i2ob_scan
r_static
r_void
id|i2ob_scan
c_func
(paren
r_int
id|bios
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|warned
op_assign
l_int|0
suffix:semicolon
r_struct
id|i2o_device
op_star
id|d
comma
op_star
id|b
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|i2o_controller
op_star
id|c
suffix:semicolon
r_struct
id|i2ob_device
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2O_CONTROLLERS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|c
op_assign
id|i2o_find_controller
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_int|NULL
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *    The device list connected to the I2O Controller is doubly linked&n;&t;&t; * Here we traverse the end of the list , and start claiming devices&n;&t;&t; * from that end. This assures that within an I2O controller atleast&n;&t;&t; * the newly created volumes get claimed after the older ones, thus&n;&t;&t; * mapping to same major/minor (and hence device file name) after &n;&t;&t; * every reboot.&n;&t;&t; * The exception being: &n;&t;&t; * 1. If there was a TID reuse.&n;&t;&t; * 2. There was more than one I2O controller. &n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|bios
)paren
(brace
r_for
c_loop
(paren
id|d
op_assign
id|c-&gt;devices
suffix:semicolon
id|d
op_ne
l_int|NULL
suffix:semicolon
id|d
op_assign
id|d-&gt;next
)paren
r_if
c_cond
(paren
id|d-&gt;next
op_eq
l_int|NULL
)paren
(brace
id|b
op_assign
id|d
suffix:semicolon
)brace
)brace
r_else
id|b
op_assign
id|c-&gt;devices
suffix:semicolon
r_while
c_loop
(paren
id|b
op_ne
l_int|NULL
)paren
(brace
id|d
op_assign
id|b
suffix:semicolon
r_if
c_cond
(paren
id|bios
)paren
(brace
id|b
op_assign
id|b-&gt;next
suffix:semicolon
)brace
r_else
id|b
op_assign
id|b-&gt;prev
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;lct_data.class_id
op_ne
id|I2O_CLASS_RANDOM_BLOCK_STORAGE
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|d-&gt;lct_data.user_tid
op_ne
l_int|0xFFF
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bios
)paren
(brace
r_if
c_cond
(paren
id|d-&gt;lct_data.bios_info
op_ne
l_int|0x80
)paren
(brace
r_continue
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Claiming as Boot device: Controller %d, TID %d&bslash;n&quot;
comma
id|c-&gt;unit
comma
id|d-&gt;lct_data.tid
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|d-&gt;lct_data.bios_info
op_eq
l_int|0x80
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*Already claimed on pass 1 */
)brace
r_if
c_cond
(paren
id|i2o_claim_device
c_func
(paren
id|d
comma
op_amp
id|i2o_block_handler
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i2o_block: Controller %d, TID %d&bslash;n&quot;
comma
id|c-&gt;unit
comma
id|d-&gt;lct_data.tid
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;&bslash;t%sevice refused claim! Skipping installation&bslash;n&quot;
comma
id|bios
ques
c_cond
l_string|&quot;Boot d&quot;
suffix:colon
l_string|&quot;D&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scan_unit
OL
id|MAX_I2OB
op_lshift
l_int|4
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Get the device and fill in the&n;&t;&t;&t;&t; * Tid and controller.&n;&t;&t;&t;&t; */
id|dev
op_assign
op_amp
id|i2ob_dev
(braket
id|scan_unit
)braket
suffix:semicolon
id|dev-&gt;i2odev
op_assign
id|d
suffix:semicolon
id|dev-&gt;controller
op_assign
id|c
suffix:semicolon
id|dev-&gt;unit
op_assign
id|c-&gt;unit
suffix:semicolon
id|dev-&gt;tid
op_assign
id|d-&gt;lct_data.tid
suffix:semicolon
r_if
c_cond
(paren
id|i2ob_install_device
c_func
(paren
id|c
comma
id|d
comma
id|scan_unit
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Could not install I2O block device&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|add_disk
c_func
(paren
id|i2ob_disk
(braket
id|scan_unit
op_rshift
l_int|4
)braket
)paren
suffix:semicolon
id|scan_unit
op_add_assign
l_int|16
suffix:semicolon
id|i2ob_dev_count
op_increment
suffix:semicolon
multiline_comment|/* We want to know when device goes away */
id|i2o_device_notify_on
c_func
(paren
id|d
comma
op_amp
id|i2o_block_handler
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|warned
op_increment
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i2o_block: too many device, registering only %d.&bslash;n&quot;
comma
id|scan_unit
op_rshift
l_int|4
)paren
suffix:semicolon
)brace
)brace
id|i2o_release_device
c_func
(paren
id|d
comma
op_amp
id|i2o_block_handler
)paren
suffix:semicolon
)brace
id|i2o_unlock_controller
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
)brace
DECL|function|i2ob_probe
r_static
r_void
id|i2ob_probe
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; *      Some overhead/redundancy involved here, while trying to&n;&t; *      claim the first boot volume encountered as /dev/i2o/hda&n;&t; *      everytime. All the i2o_controllers are searched and the&n;&t; *      first i2o block device marked as bootable is claimed&n;&t; *      If an I2O block device was booted off , the bios sets&n;&t; *      its bios_info field to 0x80, this what we search for.&n;&t; *      Assuming that the bootable volume is /dev/i2o/hda&n;&t; *      everytime will prevent any kernel panic while mounting&n;&t; *      root partition&n;&t; */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;i2o_block: Checking for Boot device...&bslash;n&quot;
)paren
suffix:semicolon
id|i2ob_scan
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      Now the remainder.&n;&t; */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;i2o_block: Checking for I2O Block devices...&bslash;n&quot;
)paren
suffix:semicolon
id|i2ob_scan
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * New device notification handler.  Called whenever a new&n; * I2O block storage device is added to the system.&n; * &n; * Should we spin lock around this to keep multiple devs from &n; * getting updated at the same time? &n; * &n; */
DECL|function|i2ob_new_device
r_void
id|i2ob_new_device
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
comma
r_struct
id|i2o_device
op_star
id|d
)paren
(brace
r_struct
id|i2ob_device
op_star
id|dev
suffix:semicolon
r_int
id|unit
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;i2o_block: New device detected&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;   Controller %d Tid %d&bslash;n&quot;
comma
id|c-&gt;unit
comma
id|d-&gt;lct_data.tid
)paren
suffix:semicolon
multiline_comment|/* Check for available space */
r_if
c_cond
(paren
id|i2ob_dev_count
op_ge
id|MAX_I2OB
op_lshift
l_int|4
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2o_block: No more devices allowed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
(paren
id|MAX_I2OB
op_lshift
l_int|4
)paren
suffix:semicolon
id|unit
op_add_assign
l_int|16
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|i2ob_dev
(braket
id|unit
)braket
dot
id|i2odev
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i2o_claim_device
c_func
(paren
id|d
comma
op_amp
id|i2o_block_handler
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;i2o_block: Unable to claim device. Installation aborted&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dev
op_assign
op_amp
id|i2ob_dev
(braket
id|unit
)braket
suffix:semicolon
id|dev-&gt;i2odev
op_assign
id|d
suffix:semicolon
id|dev-&gt;controller
op_assign
id|c
suffix:semicolon
id|dev-&gt;tid
op_assign
id|d-&gt;lct_data.tid
suffix:semicolon
r_if
c_cond
(paren
id|i2ob_install_device
c_func
(paren
id|c
comma
id|d
comma
id|unit
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2o_block: Could not install new device&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|add_disk
c_func
(paren
id|i2ob_disk
(braket
id|unit
op_rshift
l_int|4
)braket
)paren
suffix:semicolon
id|i2ob_dev_count
op_increment
suffix:semicolon
id|i2o_device_notify_on
c_func
(paren
id|d
comma
op_amp
id|i2o_block_handler
)paren
suffix:semicolon
)brace
id|i2o_release_device
c_func
(paren
id|d
comma
op_amp
id|i2o_block_handler
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Deleted device notification handler.  Called when a device we&n; * are talking to has been deleted by the user or some other&n; * mysterious fource outside the kernel.&n; */
DECL|function|i2ob_del_device
r_void
id|i2ob_del_device
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
comma
r_struct
id|i2o_device
op_star
id|d
)paren
(brace
r_int
id|unit
op_assign
l_int|0
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|I2O_LOCK
c_func
(paren
id|c-&gt;unit
)paren
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Need to do this...we somtimes get two events from the IRTOS&n;&t; * in a row and that causes lots of problems.&n;&t; */
id|i2o_device_notify_off
c_func
(paren
id|d
comma
op_amp
id|i2o_block_handler
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;I2O Block Device Deleted&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_I2OB
op_lshift
l_int|4
suffix:semicolon
id|unit
op_add_assign
l_int|16
)paren
(brace
r_if
c_cond
(paren
id|i2ob_dev
(braket
id|unit
)braket
dot
id|i2odev
op_eq
id|d
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  /dev/%s: Controller %d Tid %d&bslash;n&quot;
comma
id|d-&gt;dev_name
comma
id|c-&gt;unit
comma
id|d-&gt;lct_data.tid
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|unit
op_ge
id|MAX_I2OB
op_lshift
l_int|4
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2ob_del_device called, but not in dev table!&bslash;n&quot;
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|I2O_LOCK
c_func
(paren
id|c-&gt;unit
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * This will force errors when i2ob_get_queue() is called&n;&t; * by the kenrel.&n;&t; */
id|del_gendisk
c_func
(paren
id|i2ob_disk
(braket
id|unit
op_rshift
l_int|4
)braket
)paren
suffix:semicolon
id|i2ob_dev
(braket
id|unit
)braket
dot
id|req_queue
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|unit
suffix:semicolon
id|i
op_le
id|unit
op_plus
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
id|i2ob_dev
(braket
id|i
)braket
dot
id|i2odev
op_assign
l_int|NULL
suffix:semicolon
id|blk_queue_max_sectors
c_func
(paren
id|i2ob_dev
(braket
id|i
)braket
dot
id|req_queue
comma
l_int|0
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
id|I2O_LOCK
c_func
(paren
id|c-&gt;unit
)paren
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Decrease usage count for module&n;&t; */
r_while
c_loop
(paren
id|i2ob_dev
(braket
id|unit
)braket
dot
id|refcnt
op_decrement
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
id|i2ob_dev
(braket
id|unit
)braket
dot
id|refcnt
op_assign
l_int|0
suffix:semicolon
id|i2ob_dev
(braket
id|i
)braket
dot
id|tid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t; * Do we need this?&n;&t; * The media didn&squot;t really change...the device is just gone&n;&t; */
id|i2ob_media_change_flag
(braket
id|unit
)braket
op_assign
l_int|1
suffix:semicolon
id|i2ob_dev_count
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Have we seen a media change ?&n; */
DECL|function|i2ob_media_change
r_static
r_int
id|i2ob_media_change
c_func
(paren
r_struct
id|gendisk
op_star
id|disk
)paren
(brace
r_struct
id|i2ob_device
op_star
id|p
op_assign
id|disk-&gt;private_data
suffix:semicolon
r_int
id|i
op_assign
id|p-&gt;index
suffix:semicolon
r_if
c_cond
(paren
id|i2ob_media_change_flag
(braket
id|i
)braket
)paren
(brace
id|i2ob_media_change_flag
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|i2ob_revalidate
r_static
r_int
id|i2ob_revalidate
c_func
(paren
r_struct
id|gendisk
op_star
id|disk
)paren
(brace
r_struct
id|i2ob_device
op_star
id|p
op_assign
id|disk-&gt;private_data
suffix:semicolon
r_return
id|i2ob_install_device
c_func
(paren
id|p-&gt;controller
comma
id|p-&gt;i2odev
comma
id|p-&gt;index
op_lshift
l_int|4
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Reboot notifier.  This is called by i2o_core when the system&n; * shuts down.&n; */
DECL|function|i2ob_reboot_event
r_static
r_void
id|i2ob_reboot_event
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2OB
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|i2ob_device
op_star
id|dev
op_assign
op_amp
id|i2ob_dev
(braket
(paren
id|i
op_lshift
l_int|4
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;refcnt
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Flush the onboard cache&n;&t;&t;&t; */
id|u32
id|msg
(braket
l_int|5
)braket
suffix:semicolon
r_int
op_star
id|query_done
op_assign
op_amp
id|dev-&gt;done_flag
suffix:semicolon
id|msg
(braket
l_int|0
)braket
op_assign
id|FIVE_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_BLOCK_CFLUSH
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|dev-&gt;tid
suffix:semicolon
id|msg
(braket
l_int|2
)braket
op_assign
id|i2ob_context
op_or
l_int|0x40000000
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
(paren
id|u32
)paren
id|query_done
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
l_int|60
op_lshift
l_int|16
suffix:semicolon
id|DEBUG
c_func
(paren
l_string|&quot;Flushing...&quot;
)paren
suffix:semicolon
id|i2o_post_wait
c_func
(paren
id|dev-&gt;controller
comma
id|msg
comma
l_int|20
comma
l_int|60
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_string|&quot;Unlocking...&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Unlock the media&n;&t;&t;&t; */
id|msg
(braket
l_int|0
)braket
op_assign
id|FIVE_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_BLOCK_MUNLOCK
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|dev-&gt;tid
suffix:semicolon
id|msg
(braket
l_int|2
)braket
op_assign
id|i2ob_context
op_or
l_int|0x40000000
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
(paren
id|u32
)paren
id|query_done
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|i2o_post_wait
c_func
(paren
id|dev-&gt;controller
comma
id|msg
comma
l_int|20
comma
l_int|2
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_string|&quot;Unlocked.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|variable|i2ob_fops
r_static
r_struct
id|block_device_operations
id|i2ob_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|open
op_assign
id|i2ob_open
comma
dot
id|release
op_assign
id|i2ob_release
comma
dot
id|ioctl
op_assign
id|i2ob_ioctl
comma
dot
id|media_changed
op_assign
id|i2ob_media_change
comma
dot
id|revalidate_disk
op_assign
id|i2ob_revalidate
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * And here should be modules and kernel interface &n; *  (Just smiley confuses emacs :-)&n; */
DECL|function|i2o_block_init
r_static
r_int
id|i2o_block_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;I2O Block Storage OSM v0.9&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;   (c) Copyright 1999-2001 Red Hat Software.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Register the block device interfaces&n;&t; */
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;i2o_block&quot;
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2OB
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|alloc_disk
c_func
(paren
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|disk
)paren
r_goto
id|oom
suffix:semicolon
id|i2ob_dev
(braket
id|i
op_lshift
l_int|4
)braket
dot
id|index
op_assign
id|i
suffix:semicolon
id|disk-&gt;queue
op_assign
id|i2ob_dev
(braket
id|i
op_lshift
l_int|4
)braket
dot
id|req_queue
suffix:semicolon
id|i2ob_disk
(braket
id|i
)braket
op_assign
id|disk
suffix:semicolon
)brace
macro_line|#ifdef MODULE
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;i2o_block: registered device at major %d&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *&t;Now fill in the boiler plate&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2OB
op_lshift
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|i2ob_dev
(braket
id|i
)braket
dot
id|refcnt
op_assign
l_int|0
suffix:semicolon
id|i2ob_dev
(braket
id|i
)braket
dot
id|flags
op_assign
l_int|0
suffix:semicolon
id|i2ob_dev
(braket
id|i
)braket
dot
id|controller
op_assign
l_int|NULL
suffix:semicolon
id|i2ob_dev
(braket
id|i
)braket
dot
id|i2odev
op_assign
l_int|NULL
suffix:semicolon
id|i2ob_dev
(braket
id|i
)braket
dot
id|tid
op_assign
l_int|0
suffix:semicolon
id|i2ob_dev
(braket
id|i
)braket
dot
id|head
op_assign
l_int|NULL
suffix:semicolon
id|i2ob_dev
(braket
id|i
)braket
dot
id|tail
op_assign
l_int|NULL
suffix:semicolon
id|i2ob_dev
(braket
id|i
)braket
dot
id|depth
op_assign
id|MAX_I2OB_DEPTH
suffix:semicolon
id|i2ob_max_sectors
(braket
id|i
)braket
op_assign
l_int|2
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2OB
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|i2ob_disk
(braket
id|i
)braket
suffix:semicolon
id|disk-&gt;major
op_assign
id|MAJOR_NR
suffix:semicolon
id|disk-&gt;first_minor
op_assign
id|i
op_lshift
l_int|4
suffix:semicolon
id|disk-&gt;fops
op_assign
op_amp
id|i2ob_fops
suffix:semicolon
id|sprintf
c_func
(paren
id|disk-&gt;disk_name
comma
l_string|&quot;i2o/hd%c&quot;
comma
l_char|&squot;a&squot;
op_plus
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Set up the queue&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2O_CONTROLLERS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|i2ob_queues
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Register the OSM handler as we will need this to probe for&n;&t; *&t;drives, geometry and other goodies.&n;&t; */
r_if
c_cond
(paren
id|i2o_install_handler
c_func
(paren
op_amp
id|i2o_block_handler
)paren
OL
l_int|0
)paren
(brace
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;i2o_block&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2o_block: unable to register OSM.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|i2ob_context
op_assign
id|i2o_block_handler.context
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize event handling thread&n;&t; */
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
id|i2ob_evt_sem
)paren
suffix:semicolon
id|evt_pid
op_assign
id|kernel_thread
c_func
(paren
id|i2ob_evt
comma
l_int|NULL
comma
id|CLONE_SIGHAND
)paren
suffix:semicolon
r_if
c_cond
(paren
id|evt_pid
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2o_block: Could not initialize event thread.  Aborting&bslash;n&quot;
)paren
suffix:semicolon
id|i2o_remove_handler
c_func
(paren
op_amp
id|i2o_block_handler
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|i2ob_probe
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|oom
suffix:colon
r_while
c_loop
(paren
id|i
op_decrement
)paren
id|put_disk
c_func
(paren
id|i2ob_disk
(braket
id|i
)braket
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;i2o_block&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
DECL|function|i2o_block_exit
r_static
r_void
id|i2o_block_exit
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|evt_running
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Killing I2O block threads...&quot;
)paren
suffix:semicolon
id|i
op_assign
id|kill_proc
c_func
(paren
id|evt_pid
comma
id|SIGTERM
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;waiting...&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Be sure it died */
id|wait_for_completion
c_func
(paren
op_amp
id|i2ob_thread_dead
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;done.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Unregister for updates from any devices..otherwise we still&n;&t; * get them and the core jumps to random memory :O&n;&t; */
r_if
c_cond
(paren
id|i2ob_dev_count
)paren
(brace
r_struct
id|i2o_device
op_star
id|d
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2OB
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|d
op_assign
id|i2ob_dev
(braket
id|i
op_lshift
l_int|4
)braket
dot
id|i2odev
)paren
)paren
(brace
id|i2o_device_notify_off
c_func
(paren
id|d
comma
op_amp
id|i2o_block_handler
)paren
suffix:semicolon
id|i2o_event_register
c_func
(paren
id|d-&gt;controller
comma
id|d-&gt;lct_data.tid
comma
id|i2ob_context
comma
id|i
op_lshift
l_int|4
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;We may get further callbacks for ourself. The i2o_core&n;&t; *&t;code handles this case reasonably sanely. The problem here&n;&t; *&t;is we shouldn&squot;t get them .. but a couple of cards feel &n;&t; *&t;obliged to tell us stuff we don&squot;t care about.&n;&t; *&n;&t; *&t;This isnt ideal at all but will do for now.&n;&t; */
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Flush the OSM&n;&t; */
id|i2o_remove_handler
c_func
(paren
op_amp
id|i2o_block_handler
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2OB
suffix:semicolon
id|i
op_increment
)paren
id|put_disk
c_func
(paren
id|i2ob_disk
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Return the block device&n;&t; */
r_if
c_cond
(paren
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;i2o_block&quot;
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;i2o_block: cleanup_module failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Red Hat&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;I2O Block Device OSM&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|i2o_block_init
id|module_init
c_func
(paren
id|i2o_block_init
)paren
suffix:semicolon
DECL|variable|i2o_block_exit
id|module_exit
c_func
(paren
id|i2o_block_exit
)paren
suffix:semicolon
eof
