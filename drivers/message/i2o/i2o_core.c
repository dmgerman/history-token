multiline_comment|/*&n; * Core I2O structure management &n; * &n; * (C) Copyright 1999-2002   Red Hat Software &n; *&n; * Written by Alan Cox, Building Number Three Ltd &n; * &n; * This program is free software; you can redistribute it and/or &n; * modify it under the terms of the GNU General Public License &n; * as published by the Free Software Foundation; either version &n; * 2 of the License, or (at your option) any later version.  &n; * &n; * A lot of the I2O message side code from this is taken from the &n; * Red Creek RCPCI45 adapter driver by Red Creek Communications &n; * &n; * Fixes by: &n; *&t;&t;Philipp Rumpf &n; *&t;&t;Juha Siev&#xfffd;nen &lt;Juha.Sievanen@cs.Helsinki.FI&gt; &n; *&t;&t;Auvo H&#xfffd;kkinen &lt;Auvo.Hakkinen@cs.Helsinki.FI&gt; &n; *&t;&t;Deepak Saxena &lt;deepak@plexity.net&gt; &n; *&t;&t;Boji T Kannanthanam &lt;boji.t.kannanthanam@intel.com&gt;&n; *&n; * Ported to Linux 2.5 by&n; *&t;&t;Alan Cox&t;&lt;alan@redhat.com&gt;&n; * &n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/i2o.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#ifdef CONFIG_MTRR
macro_line|#include &lt;asm/mtrr.h&gt;
macro_line|#endif 
singleline_comment|// CONFIG_MTRR
macro_line|#include &quot;i2o_lan.h&quot;
singleline_comment|//#define DRIVERDEBUG
macro_line|#ifdef DRIVERDEBUG
DECL|macro|dprintk
mdefine_line|#define dprintk(s, args...) printk(s, ## args)
macro_line|#else
DECL|macro|dprintk
mdefine_line|#define dprintk(s, args...)
macro_line|#endif
multiline_comment|/* OSM table */
DECL|variable|i2o_handlers
r_static
r_struct
id|i2o_handler
op_star
id|i2o_handlers
(braket
id|MAX_I2O_MODULES
)braket
suffix:semicolon
multiline_comment|/* Controller list */
DECL|variable|i2o_controllers
r_static
r_struct
id|i2o_controller
op_star
id|i2o_controllers
(braket
id|MAX_I2O_CONTROLLERS
)braket
suffix:semicolon
DECL|variable|i2o_controller_chain
r_struct
id|i2o_controller
op_star
id|i2o_controller_chain
suffix:semicolon
DECL|variable|i2o_num_controllers
r_int
id|i2o_num_controllers
suffix:semicolon
multiline_comment|/* Initiator Context for Core message */
DECL|variable|core_context
r_static
r_int
id|core_context
suffix:semicolon
multiline_comment|/* Initialization &amp;&amp; shutdown functions */
r_void
id|i2o_sys_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|i2o_sys_shutdown
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|i2o_reset_controller
c_func
(paren
r_struct
id|i2o_controller
op_star
)paren
suffix:semicolon
r_static
r_int
id|i2o_reboot_event
c_func
(paren
r_struct
id|notifier_block
op_star
comma
r_int
r_int
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_int
id|i2o_online_controller
c_func
(paren
r_struct
id|i2o_controller
op_star
)paren
suffix:semicolon
r_static
r_int
id|i2o_init_outbound_q
c_func
(paren
r_struct
id|i2o_controller
op_star
)paren
suffix:semicolon
r_static
r_int
id|i2o_post_outbound_messages
c_func
(paren
r_struct
id|i2o_controller
op_star
)paren
suffix:semicolon
multiline_comment|/* Reply handler */
r_static
r_void
id|i2o_core_reply
c_func
(paren
r_struct
id|i2o_handler
op_star
comma
r_struct
id|i2o_controller
op_star
comma
r_struct
id|i2o_message
op_star
)paren
suffix:semicolon
multiline_comment|/* Various helper functions */
r_static
r_int
id|i2o_lct_get
c_func
(paren
r_struct
id|i2o_controller
op_star
)paren
suffix:semicolon
r_static
r_int
id|i2o_lct_notify
c_func
(paren
r_struct
id|i2o_controller
op_star
)paren
suffix:semicolon
r_static
r_int
id|i2o_hrt_get
c_func
(paren
r_struct
id|i2o_controller
op_star
)paren
suffix:semicolon
r_static
r_int
id|i2o_build_sys_table
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|i2o_systab_send
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
)paren
suffix:semicolon
multiline_comment|/* I2O core event handler */
r_static
r_int
id|i2o_core_evt
c_func
(paren
r_void
op_star
)paren
suffix:semicolon
DECL|variable|evt_pid
r_static
r_int
id|evt_pid
suffix:semicolon
DECL|variable|evt_running
r_static
r_int
id|evt_running
suffix:semicolon
multiline_comment|/* Dynamic LCT update handler */
r_static
r_int
id|i2o_dyn_lct
c_func
(paren
r_void
op_star
)paren
suffix:semicolon
r_void
id|i2o_report_controller_unit
c_func
(paren
r_struct
id|i2o_controller
op_star
comma
r_struct
id|i2o_device
op_star
)paren
suffix:semicolon
r_static
r_void
id|i2o_pci_dispose
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
)paren
suffix:semicolon
multiline_comment|/*&n; * I2O System Table.  Contains information about&n; * all the IOPs in the system.  Used to inform IOPs&n; * about each other&squot;s existence.&n; *&n; * sys_tbl_ver is the CurrentChangeIndicator that is&n; * used by IOPs to track changes.&n; */
DECL|variable|sys_tbl
r_static
r_struct
id|i2o_sys_tbl
op_star
id|sys_tbl
suffix:semicolon
DECL|variable|sys_tbl_ind
r_static
r_int
id|sys_tbl_ind
suffix:semicolon
DECL|variable|sys_tbl_len
r_static
r_int
id|sys_tbl_len
suffix:semicolon
multiline_comment|/*&n; * This spin lock is used to keep a device from being&n; * added and deleted concurrently across CPUs or interrupts.&n; * This can occur when a user creates a device and immediatelly&n; * deletes it before the new_dev_notify() handler is called.&n; */
DECL|variable|i2o_dev_lock
r_static
id|spinlock_t
id|i2o_dev_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * Structures and definitions for synchronous message posting.&n; * See i2o_post_wait() for description.&n; */
DECL|struct|i2o_post_wait_data
r_struct
id|i2o_post_wait_data
(brace
DECL|member|status
r_int
op_star
id|status
suffix:semicolon
multiline_comment|/* Pointer to status block on caller stack */
DECL|member|complete
r_int
op_star
id|complete
suffix:semicolon
multiline_comment|/* Pointer to completion flag on caller stack */
DECL|member|id
id|u32
id|id
suffix:semicolon
multiline_comment|/* Unique identifier */
DECL|member|wq
id|wait_queue_head_t
op_star
id|wq
suffix:semicolon
multiline_comment|/* Wake up for caller (NULL for dead) */
DECL|member|next
r_struct
id|i2o_post_wait_data
op_star
id|next
suffix:semicolon
multiline_comment|/* Chain */
DECL|member|mem
r_void
op_star
id|mem
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Memory blocks to recover on failure path */
DECL|member|phys
id|dma_addr_t
id|phys
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Physical address of blocks to recover */
DECL|member|size
id|u32
id|size
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Size of blocks to recover */
)brace
suffix:semicolon
DECL|variable|post_wait_queue
r_static
r_struct
id|i2o_post_wait_data
op_star
id|post_wait_queue
suffix:semicolon
DECL|variable|post_wait_id
r_static
id|u32
id|post_wait_id
suffix:semicolon
singleline_comment|// Unique ID for each post_wait
DECL|variable|post_wait_lock
r_static
id|spinlock_t
id|post_wait_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_static
r_void
id|i2o_post_wait_complete
c_func
(paren
r_struct
id|i2o_controller
op_star
comma
id|u32
comma
r_int
)paren
suffix:semicolon
multiline_comment|/* OSM descriptor handler */
DECL|variable|i2o_core_handler
r_static
r_struct
id|i2o_handler
id|i2o_core_handler
op_assign
(brace
(paren
r_void
op_star
)paren
id|i2o_core_reply
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;I2O core layer&quot;
comma
l_int|0
comma
id|I2O_CLASS_EXECUTIVE
)brace
suffix:semicolon
multiline_comment|/*&n; * Used when queueing a reply to be handled later&n; */
DECL|struct|reply_info
r_struct
id|reply_info
(brace
DECL|member|iop
r_struct
id|i2o_controller
op_star
id|iop
suffix:semicolon
DECL|member|msg
id|u32
id|msg
(braket
id|MSG_FRAME_SIZE
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|evt_reply
r_static
r_struct
id|reply_info
id|evt_reply
suffix:semicolon
DECL|variable|events
r_static
r_struct
id|reply_info
id|events
(braket
id|I2O_EVT_Q_LEN
)braket
suffix:semicolon
DECL|variable|evt_in
r_static
r_int
id|evt_in
suffix:semicolon
DECL|variable|evt_out
r_static
r_int
id|evt_out
suffix:semicolon
DECL|variable|evt_q_len
r_static
r_int
id|evt_q_len
suffix:semicolon
DECL|macro|MODINC
mdefine_line|#define MODINC(x,y) ((x) = ((x) + 1) % (y))
multiline_comment|/*&n; * I2O configuration spinlock. This isnt a big deal for contention&n; * so we have one only&n; */
r_static
id|DECLARE_MUTEX
c_func
(paren
id|i2o_configuration_lock
)paren
suffix:semicolon
multiline_comment|/* &n; * Event spinlock.  Used to keep event queue sane and from&n; * handling multiple events simultaneously.&n; */
DECL|variable|i2o_evt_lock
r_static
id|spinlock_t
id|i2o_evt_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * Semaphore used to synchronize event handling thread with &n; * interrupt handler.&n; */
r_static
id|DECLARE_MUTEX
c_func
(paren
id|evt_sem
)paren
suffix:semicolon
r_static
id|DECLARE_COMPLETION
c_func
(paren
id|evt_dead
)paren
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|evt_wait
)paren
suffix:semicolon
DECL|variable|i2o_reboot_notifier
r_static
r_struct
id|notifier_block
id|i2o_reboot_notifier
op_assign
(brace
id|i2o_reboot_event
comma
l_int|NULL
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;Config options&n; */
DECL|variable|verbose
r_static
r_int
id|verbose
suffix:semicolon
multiline_comment|/*&n; * I2O Core reply handler&n; */
DECL|function|i2o_core_reply
r_static
r_void
id|i2o_core_reply
c_func
(paren
r_struct
id|i2o_handler
op_star
id|h
comma
r_struct
id|i2o_controller
op_star
id|c
comma
r_struct
id|i2o_message
op_star
id|m
)paren
(brace
id|u32
op_star
id|msg
op_assign
(paren
id|u32
op_star
)paren
id|m
suffix:semicolon
id|u32
id|status
suffix:semicolon
id|u32
id|context
op_assign
id|msg
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|msg
(braket
l_int|0
)braket
op_amp
id|MSG_FAIL
)paren
singleline_comment|// Fail bit is set
(brace
id|u32
op_star
id|preserved_msg
op_assign
(paren
id|u32
op_star
)paren
(paren
id|c-&gt;mem_offset
op_plus
id|msg
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|i2o_report_status
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;i2o_core&quot;
comma
id|msg
)paren
suffix:semicolon
id|i2o_dump_message
c_func
(paren
id|preserved_msg
)paren
suffix:semicolon
multiline_comment|/* If the failed request needs special treatment,&n;&t;&t; * it should be done here. */
multiline_comment|/* Release the preserved msg by resubmitting it as a NOP */
id|preserved_msg
(braket
l_int|0
)braket
op_assign
id|cpu_to_le32
c_func
(paren
id|THREE_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
)paren
suffix:semicolon
id|preserved_msg
(braket
l_int|1
)braket
op_assign
id|cpu_to_le32
c_func
(paren
id|I2O_CMD_UTIL_NOP
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
l_int|0
)paren
suffix:semicolon
id|preserved_msg
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|i2o_post_message
c_func
(paren
id|c
comma
id|msg
(braket
l_int|7
)braket
)paren
suffix:semicolon
multiline_comment|/* If reply to i2o_post_wait failed, return causes a timeout */
r_return
suffix:semicolon
)brace
macro_line|#ifdef DRIVERDEBUG
id|i2o_report_status
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;i2o_core&quot;
comma
id|msg
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|msg
(braket
l_int|2
)braket
op_amp
l_int|0x80000000
)paren
singleline_comment|// Post wait message
(brace
r_if
c_cond
(paren
id|msg
(braket
l_int|4
)braket
op_rshift
l_int|24
)paren
id|status
op_assign
(paren
id|msg
(braket
l_int|4
)braket
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
r_else
id|status
op_assign
id|I2O_POST_WAIT_OK
suffix:semicolon
id|i2o_post_wait_complete
c_func
(paren
id|c
comma
id|context
comma
id|status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|m-&gt;function
op_eq
id|I2O_CMD_UTIL_EVT_REGISTER
)paren
(brace
id|memcpy
c_func
(paren
id|events
(braket
id|evt_in
)braket
dot
id|msg
comma
id|msg
comma
(paren
id|msg
(braket
l_int|0
)braket
op_rshift
l_int|16
)paren
op_lshift
l_int|2
)paren
suffix:semicolon
id|events
(braket
id|evt_in
)braket
dot
id|iop
op_assign
id|c
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|i2o_evt_lock
)paren
suffix:semicolon
id|MODINC
c_func
(paren
id|evt_in
comma
id|I2O_EVT_Q_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|evt_q_len
op_eq
id|I2O_EVT_Q_LEN
)paren
(brace
id|MODINC
c_func
(paren
id|evt_out
comma
id|I2O_EVT_Q_LEN
)paren
suffix:semicolon
)brace
r_else
id|evt_q_len
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|i2o_evt_lock
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|evt_sem
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|evt_wait
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|m-&gt;function
op_eq
id|I2O_CMD_LCT_NOTIFY
)paren
(brace
id|up
c_func
(paren
op_amp
id|c-&gt;lct_sem
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If this happens, we want to dump the message to the syslog so&n;&t; * it can be sent back to the card manufacturer by the end user&n;&t; * to aid in debugging.&n;&t; * &n;&t; */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Unsolicited message reply sent to core!&quot;
l_string|&quot;Message dumped to syslog&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
id|i2o_dump_message
c_func
(paren
id|msg
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_install_handler - install a message handler&n; *&t;@h: Handler structure&n; *&n; *&t;Install an I2O handler - these handle the asynchronous messaging&n; *&t;from the card once it has initialised. If the table of handlers is&n; *&t;full then -ENOSPC is returned. On a success 0 is returned and the&n; *&t;context field is set by the function. The structure is part of the&n; *&t;system from this time onwards. It must not be freed until it has&n; *&t;been uninstalled&n; */
DECL|function|i2o_install_handler
r_int
id|i2o_install_handler
c_func
(paren
r_struct
id|i2o_handler
op_star
id|h
)paren
(brace
r_int
id|i
suffix:semicolon
id|down
c_func
(paren
op_amp
id|i2o_configuration_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2O_MODULES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i2o_handlers
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
(brace
id|h-&gt;context
op_assign
id|i
suffix:semicolon
id|i2o_handlers
(braket
id|i
)braket
op_assign
id|h
suffix:semicolon
id|up
c_func
(paren
op_amp
id|i2o_configuration_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
op_amp
id|i2o_configuration_lock
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_remove_handler - remove an i2o message handler&n; *&t;@h: handler&n; *&n; *&t;Remove a message handler previously installed with i2o_install_handler.&n; *&t;After this function returns the handler object can be freed or re-used&n; */
DECL|function|i2o_remove_handler
r_int
id|i2o_remove_handler
c_func
(paren
r_struct
id|i2o_handler
op_star
id|h
)paren
(brace
id|i2o_handlers
(braket
id|h-&gt;context
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Each I2O controller has a chain of devices on it.&n; * Each device has a pointer to its LCT entry to be used&n; * for fun purposes.&n; */
multiline_comment|/**&n; *&t;i2o_install_device&t;-&t;attach a device to a controller&n; *&t;@c: controller&n; *&t;@d: device&n; * &t;&n; *&t;Add a new device to an i2o controller. This can be called from&n; *&t;non interrupt contexts only. It adds the device and marks it as&n; *&t;unclaimed. The device memory becomes part of the kernel and must&n; *&t;be uninstalled before being freed or reused. Zero is returned&n; *&t;on success.&n; */
DECL|function|i2o_install_device
r_int
id|i2o_install_device
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
comma
r_struct
id|i2o_device
op_star
id|d
)paren
(brace
r_int
id|i
suffix:semicolon
id|down
c_func
(paren
op_amp
id|i2o_configuration_lock
)paren
suffix:semicolon
id|d-&gt;controller
op_assign
id|c
suffix:semicolon
id|d-&gt;owner
op_assign
l_int|NULL
suffix:semicolon
id|d-&gt;next
op_assign
id|c-&gt;devices
suffix:semicolon
id|d-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;devices
op_ne
l_int|NULL
)paren
id|c-&gt;devices-&gt;prev
op_assign
id|d
suffix:semicolon
id|c-&gt;devices
op_assign
id|d
suffix:semicolon
op_star
id|d-&gt;dev_name
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|I2O_MAX_MANAGERS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|d-&gt;managers
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|i2o_configuration_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* we need this version to call out of i2o_delete_controller */
DECL|function|__i2o_delete_device
r_int
id|__i2o_delete_device
c_func
(paren
r_struct
id|i2o_device
op_star
id|d
)paren
(brace
r_struct
id|i2o_device
op_star
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
id|p
op_assign
op_amp
(paren
id|d-&gt;controller-&gt;devices
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Hey we have a driver!&n;&t; * Check to see if the driver wants us to notify it of &n;&t; * device deletion. If it doesn&squot;t we assume that it&n;&t; * is unsafe to delete a device with an owner and &n;&t; * fail.&n;&t; */
r_if
c_cond
(paren
id|d-&gt;owner
)paren
(brace
r_if
c_cond
(paren
id|d-&gt;owner-&gt;dev_del_notify
)paren
(brace
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;Device has owner, notifying&bslash;n&quot;
)paren
suffix:semicolon
id|d-&gt;owner
op_member_access_from_pointer
id|dev_del_notify
c_func
(paren
id|d-&gt;controller
comma
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;owner
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Driver &bslash;&quot;%s&bslash;&quot; did not release device!&bslash;n&quot;
comma
id|d-&gt;owner-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
r_else
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Tell any other users who are talking to this device&n;&t; * that it&squot;s going away.  We assume that everything works.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|I2O_MAX_MANAGERS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|d-&gt;managers
(braket
id|i
)braket
op_logical_and
id|d-&gt;managers
(braket
id|i
)braket
op_member_access_from_pointer
id|dev_del_notify
)paren
(brace
id|d-&gt;managers
(braket
id|i
)braket
op_member_access_from_pointer
id|dev_del_notify
c_func
(paren
id|d-&gt;controller
comma
id|d
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_star
id|p
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_star
id|p
op_eq
id|d
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Destroy&n;&t;&t;&t; */
op_star
id|p
op_assign
id|d-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|d
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|p
op_assign
op_amp
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2o_delete_device: passed invalid device.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_delete_device&t;-&t;remove an i2o device&n; *&t;@d: device to remove&n; *&n; *&t;This function unhooks a device from a controller. The device&n; *&t;will not be unhooked if it has an owner who does not wish to free&n; *&t;it, or if the owner lacks a dev_del_notify function. In that case&n; *&t;-EBUSY is returned. On success 0 is returned. Other errors cause&n; *&t;negative errno values to be returned&n; */
DECL|function|i2o_delete_device
r_int
id|i2o_delete_device
c_func
(paren
r_struct
id|i2o_device
op_star
id|d
)paren
(brace
r_int
id|ret
suffix:semicolon
id|down
c_func
(paren
op_amp
id|i2o_configuration_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Seek, locate&n;&t; */
id|ret
op_assign
id|__i2o_delete_device
c_func
(paren
id|d
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|i2o_configuration_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_install_controller&t;-&t;attach a controller&n; *&t;@c: controller&n; * &t;&n; *&t;Add a new controller to the i2o layer. This can be called from&n; *&t;non interrupt contexts only. It adds the controller and marks it as&n; *&t;unused with no devices. If the tables are full or memory allocations&n; *&t;fail then a negative errno code is returned. On success zero is&n; *&t;returned and the controller is bound to the system. The structure&n; *&t;must not be freed or reused until being uninstalled.&n; */
DECL|function|i2o_install_controller
r_int
id|i2o_install_controller
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
)paren
(brace
r_int
id|i
suffix:semicolon
id|down
c_func
(paren
op_amp
id|i2o_configuration_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2O_CONTROLLERS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i2o_controllers
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
(brace
id|c-&gt;dlct
op_assign
(paren
id|i2o_lct
op_star
)paren
id|pci_alloc_consistent
c_func
(paren
id|c-&gt;pdev
comma
l_int|8192
comma
op_amp
id|c-&gt;dlct_phys
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;dlct
op_eq
l_int|NULL
)paren
(brace
id|up
c_func
(paren
op_amp
id|i2o_configuration_lock
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|i2o_controllers
(braket
id|i
)braket
op_assign
id|c
suffix:semicolon
id|c-&gt;devices
op_assign
l_int|NULL
suffix:semicolon
id|c-&gt;next
op_assign
id|i2o_controller_chain
suffix:semicolon
id|i2o_controller_chain
op_assign
id|c
suffix:semicolon
id|c-&gt;unit
op_assign
id|i
suffix:semicolon
id|c-&gt;page_frame
op_assign
l_int|NULL
suffix:semicolon
id|c-&gt;hrt
op_assign
l_int|NULL
suffix:semicolon
id|c-&gt;lct
op_assign
l_int|NULL
suffix:semicolon
id|c-&gt;status_block
op_assign
l_int|NULL
suffix:semicolon
id|sprintf
c_func
(paren
id|c-&gt;name
comma
l_string|&quot;i2o/iop%d&quot;
comma
id|i
)paren
suffix:semicolon
id|i2o_num_controllers
op_increment
suffix:semicolon
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
id|c-&gt;lct_sem
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|i2o_configuration_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;No free i2o controller slots.&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|i2o_configuration_lock
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_delete_controller&t;- delete a controller&n; *&t;@c: controller&n; *&t;&n; *&t;Remove an i2o controller from the system. If the controller or its&n; *&t;devices are busy then -EBUSY is returned. On a failure a negative&n; *&t;errno code is returned. On success zero is returned.&n; */
DECL|function|i2o_delete_controller
r_int
id|i2o_delete_controller
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
)paren
(brace
r_struct
id|i2o_controller
op_star
op_star
id|p
suffix:semicolon
r_int
id|users
suffix:semicolon
r_char
id|name
(braket
l_int|16
)braket
suffix:semicolon
r_int
id|stat
suffix:semicolon
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;Deleting controller %s&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clear event registration as this can cause weird behavior&n;&t; */
r_if
c_cond
(paren
id|c-&gt;status_block-&gt;iop_state
op_eq
id|ADAPTER_STATE_OPERATIONAL
)paren
(brace
id|i2o_event_register
c_func
(paren
id|c
comma
id|core_context
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|i2o_configuration_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|users
op_assign
id|atomic_read
c_func
(paren
op_amp
id|c-&gt;users
)paren
)paren
)paren
(brace
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;I2O: %d users for controller %s&bslash;n&quot;
comma
id|users
comma
id|c-&gt;name
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|i2o_configuration_lock
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_while
c_loop
(paren
id|c-&gt;devices
)paren
(brace
r_if
c_cond
(paren
id|__i2o_delete_device
c_func
(paren
id|c-&gt;devices
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* Shouldnt happen */
id|I2O_IRQ_WRITE32
c_func
(paren
id|c
comma
l_int|0xFFFFFFFF
)paren
suffix:semicolon
id|c-&gt;enabled
op_assign
l_int|0
suffix:semicolon
id|up
c_func
(paren
op_amp
id|i2o_configuration_lock
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If this is shutdown time, the thread&squot;s already been killed&n;&t; */
r_if
c_cond
(paren
id|c-&gt;lct_running
)paren
(brace
id|stat
op_assign
id|kill_proc
c_func
(paren
id|c-&gt;lct_pid
comma
id|SIGTERM
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stat
)paren
(brace
r_int
id|count
op_assign
l_int|10
op_star
l_int|100
suffix:semicolon
r_while
c_loop
(paren
id|c-&gt;lct_running
op_logical_and
op_decrement
id|count
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: LCT thread still running!&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
)brace
)brace
)brace
id|p
op_assign
op_amp
id|i2o_controller_chain
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
op_star
id|p
op_eq
id|c
)paren
(brace
multiline_comment|/* Ask the IOP to switch to RESET state */
id|i2o_reset_controller
c_func
(paren
id|c
)paren
suffix:semicolon
multiline_comment|/* Release IRQ */
id|i2o_pci_dispose
c_func
(paren
id|c
)paren
suffix:semicolon
op_star
id|p
op_assign
id|c-&gt;next
suffix:semicolon
id|up
c_func
(paren
op_amp
id|i2o_configuration_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;page_frame
)paren
(brace
id|pci_unmap_single
c_func
(paren
id|c-&gt;pdev
comma
id|c-&gt;page_frame_map
comma
id|MSG_POOL_SIZE
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|c-&gt;page_frame
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c-&gt;hrt
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|c-&gt;pdev
comma
id|c-&gt;hrt_len
comma
id|c-&gt;hrt
comma
id|c-&gt;hrt_phys
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c-&gt;lct
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|c-&gt;pdev
comma
id|c-&gt;lct-&gt;table_size
op_lshift
l_int|2
comma
id|c-&gt;lct
comma
id|c-&gt;lct_phys
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c-&gt;status_block
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|c-&gt;pdev
comma
r_sizeof
(paren
id|i2o_status_block
)paren
comma
id|c-&gt;status_block
comma
id|c-&gt;status_block_phys
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c-&gt;dlct
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|c-&gt;pdev
comma
l_int|8192
comma
id|c-&gt;dlct
comma
id|c-&gt;dlct_phys
)paren
suffix:semicolon
)brace
id|i2o_controllers
(braket
id|c-&gt;unit
)braket
op_assign
l_int|NULL
suffix:semicolon
id|memcpy
c_func
(paren
id|name
comma
id|c-&gt;name
comma
id|strlen
c_func
(paren
id|c-&gt;name
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|c
)paren
suffix:semicolon
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Deleted from controller chain.&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|i2o_num_controllers
op_decrement
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|p
op_assign
op_amp
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|i2o_configuration_lock
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2o_delete_controller: bad pointer!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_unlock_controller&t;-&t;unlock a controller&n; *&t;@c: controller to unlock&n; *&n; *&t;Take a lock on an i2o controller. This prevents it being deleted.&n; *&t;i2o controllers are not refcounted so a deletion of an in use device&n; *&t;will fail, not take affect on the last dereference.&n; */
DECL|function|i2o_unlock_controller
r_void
id|i2o_unlock_controller
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|c-&gt;users
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_find_controller - return a locked controller&n; *&t;@n: controller number&n; *&n; *&t;Returns a pointer to the controller object. The controller is locked&n; *&t;on return. NULL is returned if the controller is not found.&n; */
DECL|function|i2o_find_controller
r_struct
id|i2o_controller
op_star
id|i2o_find_controller
c_func
(paren
r_int
id|n
)paren
(brace
r_struct
id|i2o_controller
op_star
id|c
suffix:semicolon
r_if
c_cond
(paren
id|n
OL
l_int|0
op_logical_or
id|n
op_ge
id|MAX_I2O_CONTROLLERS
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|i2o_configuration_lock
)paren
suffix:semicolon
id|c
op_assign
id|i2o_controllers
(braket
id|n
)braket
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ne
l_int|NULL
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|c-&gt;users
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|i2o_configuration_lock
)paren
suffix:semicolon
r_return
id|c
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_issue_claim&t;- claim or release a device&n; *&t;@cmd: command&n; *&t;@c: controller to claim for&n; *&t;@tid: i2o task id&n; *&t;@type: type of claim&n; *&n; *&t;Issue I2O UTIL_CLAIM and UTIL_RELEASE messages. The message to be sent&n; *&t;is set by cmd. The tid is the task id of the object to claim and the&n; *&t;type is the claim type (see the i2o standard)&n; *&n; *&t;Zero is returned on success.&n; */
DECL|function|i2o_issue_claim
r_static
r_int
id|i2o_issue_claim
c_func
(paren
id|u32
id|cmd
comma
r_struct
id|i2o_controller
op_star
id|c
comma
r_int
id|tid
comma
id|u32
id|type
)paren
(brace
id|u32
id|msg
(braket
l_int|5
)braket
suffix:semicolon
id|msg
(braket
l_int|0
)braket
op_assign
id|FIVE_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|cmd
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|tid
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
id|type
suffix:semicolon
r_return
id|i2o_post_wait
c_func
(paren
id|c
comma
id|msg
comma
r_sizeof
(paren
id|msg
)paren
comma
l_int|60
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;i2o_claim_device - claim a device for use by an OSM&n; *&t;@d: device to claim&n; *&t;@h: handler for this device&n; *&n; *&t;Do the leg work to assign a device to a given OSM on Linux. The&n; *&t;kernel updates the internal handler data for the device and then&n; *&t;performs an I2O claim for the device, attempting to claim the&n; *&t;device as primary. If the attempt fails a negative errno code&n; *&t;is returned. On success zero is returned.&n; */
DECL|function|i2o_claim_device
r_int
id|i2o_claim_device
c_func
(paren
r_struct
id|i2o_device
op_star
id|d
comma
r_struct
id|i2o_handler
op_star
id|h
)paren
(brace
id|down
c_func
(paren
op_amp
id|i2o_configuration_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;owner
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Device claim called, but dev already owned by %s!&quot;
comma
id|h-&gt;name
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|i2o_configuration_lock
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|d-&gt;owner
op_assign
id|h
suffix:semicolon
r_if
c_cond
(paren
id|i2o_issue_claim
c_func
(paren
id|I2O_CMD_UTIL_CLAIM
comma
id|d-&gt;controller
comma
id|d-&gt;lct_data.tid
comma
id|I2O_CLAIM_PRIMARY
)paren
)paren
(brace
id|d-&gt;owner
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|i2o_configuration_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_release_device - release a device that the OSM is using&n; *&t;@d: device to claim&n; *&t;@h: handler for this device&n; *&n; *&t;Drop a claim by an OSM on a given I2O device. The handler is cleared&n; *&t;and 0 is returned on success.&n; *&n; *&t;AC - some devices seem to want to refuse an unclaim until they have&n; *&t;finished internal processing. It makes sense since you don&squot;t want a&n; *&t;new device to go reconfiguring the entire system until you are done.&n; *&t;Thus we are prepared to wait briefly.&n; */
DECL|function|i2o_release_device
r_int
id|i2o_release_device
c_func
(paren
r_struct
id|i2o_device
op_star
id|d
comma
r_struct
id|i2o_handler
op_star
id|h
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|tries
suffix:semicolon
id|down
c_func
(paren
op_amp
id|i2o_configuration_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;owner
op_ne
id|h
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Claim release called, but not owned by %s!&bslash;n&quot;
comma
id|h-&gt;name
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|i2o_configuration_lock
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
r_for
c_loop
(paren
id|tries
op_assign
l_int|0
suffix:semicolon
id|tries
OL
l_int|10
suffix:semicolon
id|tries
op_increment
)paren
(brace
id|d-&gt;owner
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;If the controller takes a nonblocking approach to&n;&t;&t; *&t;releases we have to sleep/poll for a few times.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|i2o_issue_claim
c_func
(paren
id|I2O_CMD_UTIL_RELEASE
comma
id|d-&gt;controller
comma
id|d-&gt;lct_data.tid
comma
id|I2O_CLAIM_PRIMARY
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENXIO
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
)paren
suffix:semicolon
)brace
r_else
(brace
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
op_amp
id|i2o_configuration_lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * &t;i2o_device_notify_on&t;-&t;Enable deletion notifiers&n; *&t;@d: device for notification&n; *&t;@h: handler to install&n; *&n; *&t;Called by OSMs to let the core know that they want to be&n; *&t;notified if the given device is deleted from the system.&n; */
DECL|function|i2o_device_notify_on
r_int
id|i2o_device_notify_on
c_func
(paren
r_struct
id|i2o_device
op_star
id|d
comma
r_struct
id|i2o_handler
op_star
id|h
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;num_managers
op_eq
id|I2O_MAX_MANAGERS
)paren
(brace
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|I2O_MAX_MANAGERS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|d-&gt;managers
(braket
id|i
)braket
)paren
(brace
id|d-&gt;managers
(braket
id|i
)braket
op_assign
id|h
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|d-&gt;num_managers
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * &t;i2o_device_notify_off&t;-&t;Remove deletion notifiers&n; *&t;@d: device for notification&n; *&t;@h: handler to remove&n; *&n; * Called by OSMs to let the core know that they no longer&n; * are interested in the fate of the given device.&n; */
DECL|function|i2o_device_notify_off
r_int
id|i2o_device_notify_off
c_func
(paren
r_struct
id|i2o_device
op_star
id|d
comma
r_struct
id|i2o_handler
op_star
id|h
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|I2O_MAX_MANAGERS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|d-&gt;managers
(braket
id|i
)braket
op_eq
id|h
)paren
(brace
id|d-&gt;managers
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|d-&gt;num_managers
op_decrement
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_event_register&t;-&t;register interest in an event&n; * &t;@c: Controller to register interest with&n; *&t;@tid: I2O task id&n; *&t;@init_context: initiator context to use with this notifier&n; *&t;@tr_context: transaction context to use with this notifier&n; *&t;@evt_mask: mask of events&n; *&n; *&t;Create and posts an event registration message to the task. No reply&n; *&t;is waited for, or expected. Errors in posting will be reported.&n; */
DECL|function|i2o_event_register
r_int
id|i2o_event_register
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
comma
id|u32
id|tid
comma
id|u32
id|init_context
comma
id|u32
id|tr_context
comma
id|u32
id|evt_mask
)paren
(brace
id|u32
id|msg
(braket
l_int|5
)braket
suffix:semicolon
singleline_comment|// Not performance critical, so we just 
singleline_comment|// i2o_post_this it instead of building it
singleline_comment|// in IOP memory
id|msg
(braket
l_int|0
)braket
op_assign
id|FIVE_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_UTIL_EVT_REGISTER
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|tid
suffix:semicolon
id|msg
(braket
l_int|2
)braket
op_assign
id|init_context
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
id|tr_context
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
id|evt_mask
suffix:semicolon
r_return
id|i2o_post_this
c_func
(paren
id|c
comma
id|msg
comma
r_sizeof
(paren
id|msg
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;i2o_event_ack&t;-&t;acknowledge an event&n; *&t;@c: controller &n; *&t;@msg: pointer to the UTIL_EVENT_REGISTER reply we received&n; *&n; *&t;We just take a pointer to the original UTIL_EVENT_REGISTER reply&n; *&t;message and change the function code since that&squot;s what spec&n; *&t;describes an EventAck message looking like.&n; */
DECL|function|i2o_event_ack
r_int
id|i2o_event_ack
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
comma
id|u32
op_star
id|msg
)paren
(brace
r_struct
id|i2o_message
op_star
id|m
op_assign
(paren
r_struct
id|i2o_message
op_star
)paren
id|msg
suffix:semicolon
id|m-&gt;function
op_assign
id|I2O_CMD_UTIL_EVT_ACK
suffix:semicolon
r_return
id|i2o_post_wait
c_func
(paren
id|c
comma
id|msg
comma
id|m-&gt;size
op_star
l_int|4
comma
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Core event handler.  Runs as a separate thread and is woken&n; * up whenever there is an Executive class event.&n; */
DECL|function|i2o_core_evt
r_static
r_int
id|i2o_core_evt
c_func
(paren
r_void
op_star
id|reply_data
)paren
(brace
r_struct
id|reply_info
op_star
id|reply
op_assign
(paren
r_struct
id|reply_info
op_star
)paren
id|reply_data
suffix:semicolon
id|u32
op_star
id|msg
op_assign
id|reply-&gt;msg
suffix:semicolon
r_struct
id|i2o_controller
op_star
id|c
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|daemonize
c_func
(paren
l_string|&quot;i2oevtd&quot;
)paren
suffix:semicolon
id|allow_signal
c_func
(paren
id|SIGKILL
)paren
suffix:semicolon
id|evt_running
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|evt_sem
)paren
)paren
(brace
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;I2O event thread dead&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;exiting...&quot;
)paren
suffix:semicolon
id|evt_running
op_assign
l_int|0
suffix:semicolon
id|complete_and_exit
c_func
(paren
op_amp
id|evt_dead
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * Copy the data out of the queue so that we don&squot;t have to lock&n;&t;&t; * around the whole function and just around the qlen update&n;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|i2o_evt_lock
comma
id|flags
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|reply
comma
op_amp
id|events
(braket
id|evt_out
)braket
comma
r_sizeof
(paren
r_struct
id|reply_info
)paren
)paren
suffix:semicolon
id|MODINC
c_func
(paren
id|evt_out
comma
id|I2O_EVT_Q_LEN
)paren
suffix:semicolon
id|evt_q_len
op_decrement
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|i2o_evt_lock
comma
id|flags
)paren
suffix:semicolon
id|c
op_assign
id|reply-&gt;iop
suffix:semicolon
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;I2O IRTOS EVENT: iop%d, event %#10x&bslash;n&quot;
comma
id|c-&gt;unit
comma
id|msg
(braket
l_int|4
)braket
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * We do not attempt to delete/quiesce/etc. the controller if&n;&t;&t; * some sort of error indidication occurs.  We may want to do&n;&t;&t; * so in the future, but for now we just let the user deal with &n;&t;&t; * it.  One reason for this is that what to do with an error&n;&t;&t; * or when to send what &#xfffd;rror is not really agreed on, so&n;&t;&t; * we get errors that may not be fatal but just look like they&n;&t;&t; * are...so let the user deal with it.&n;&t;&t; */
r_switch
c_cond
(paren
id|msg
(braket
l_int|4
)braket
)paren
(brace
r_case
id|I2O_EVT_IND_EXEC_RESOURCE_LIMITS
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Out of resources&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_EVT_IND_EXEC_POWER_FAIL
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Power failure&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_EVT_IND_EXEC_HW_FAIL
suffix:colon
(brace
r_char
op_star
id|fail
(braket
)braket
op_assign
(brace
l_string|&quot;Unknown Error&quot;
comma
l_string|&quot;Power Lost&quot;
comma
l_string|&quot;Code Violation&quot;
comma
l_string|&quot;Parity Error&quot;
comma
l_string|&quot;Code Execution Exception&quot;
comma
l_string|&quot;Watchdog Timer Expired&quot;
)brace
suffix:semicolon
r_if
c_cond
(paren
id|msg
(braket
l_int|5
)braket
op_le
l_int|6
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Hardware Failure: %s&bslash;n&quot;
comma
id|c-&gt;name
comma
id|fail
(braket
id|msg
(braket
l_int|5
)braket
)braket
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Unknown Hardware Failure&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; &t; * New device created&n;&t;&t; &t; * - Create a new i2o_device entry&n;&t;&t; &t; * - Inform all interested drivers about this device&squot;s existence&n;&t;&t; &t; */
r_case
id|I2O_EVT_IND_EXEC_NEW_LCT_ENTRY
suffix:colon
(brace
r_struct
id|i2o_device
op_star
id|d
op_assign
(paren
r_struct
id|i2o_device
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|i2o_device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|d
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;i2oevtd: out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|d-&gt;lct_data
comma
op_amp
id|msg
(braket
l_int|5
)braket
comma
r_sizeof
(paren
id|i2o_lct_entry
)paren
)paren
suffix:semicolon
id|d-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|d-&gt;controller
op_assign
id|c
suffix:semicolon
id|d-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|i2o_report_controller_unit
c_func
(paren
id|c
comma
id|d
)paren
suffix:semicolon
id|i2o_install_device
c_func
(paren
id|c
comma
id|d
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2O_MODULES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i2o_handlers
(braket
id|i
)braket
op_logical_and
id|i2o_handlers
(braket
id|i
)braket
op_member_access_from_pointer
id|new_dev_notify
op_logical_and
(paren
id|i2o_handlers
(braket
id|i
)braket
op_member_access_from_pointer
r_class
op_amp
id|d-&gt;lct_data.class_id
)paren
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|i2o_dev_lock
)paren
suffix:semicolon
id|i2o_handlers
(braket
id|i
)braket
op_member_access_from_pointer
id|new_dev_notify
c_func
(paren
id|c
comma
id|d
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|i2o_dev_lock
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n; &t;&t; &t; * LCT entry for a device has been modified, so update it&n;&t;&t; &t; * internally.&n;&t;&t; &t; */
r_case
id|I2O_EVT_IND_EXEC_MODIFIED_LCT
suffix:colon
(brace
r_struct
id|i2o_device
op_star
id|d
suffix:semicolon
id|i2o_lct_entry
op_star
id|new_lct
op_assign
(paren
id|i2o_lct_entry
op_star
)paren
op_amp
id|msg
(braket
l_int|5
)braket
suffix:semicolon
r_for
c_loop
(paren
id|d
op_assign
id|c-&gt;devices
suffix:semicolon
id|d
suffix:semicolon
id|d
op_assign
id|d-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|d-&gt;lct_data.tid
op_eq
id|new_lct-&gt;tid
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|d-&gt;lct_data
comma
id|new_lct
comma
r_sizeof
(paren
id|i2o_lct_entry
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
r_case
id|I2O_EVT_IND_CONFIGURATION_FLAG
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s requires user configuration&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_EVT_IND_GENERAL_WARNING
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Warning notification received!&quot;
l_string|&quot;Check configuration for errors!&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_EVT_IND_EVT_MASK_MODIFIED
suffix:colon
multiline_comment|/* Well I guess that was us hey .. */
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: No handler for event (0x%08x)&bslash;n&quot;
comma
id|c-&gt;name
comma
id|msg
(braket
l_int|4
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Dynamic LCT update.  This compares the LCT with the currently&n; * installed devices to check for device deletions..this needed b/c there&n; * is no DELETED_LCT_ENTRY EventIndicator for the Executive class so&n; * we can&squot;t just have the event handler do this...annoying&n; *&n; * This is a hole in the spec that will hopefully be fixed someday.&n; */
DECL|function|i2o_dyn_lct
r_static
r_int
id|i2o_dyn_lct
c_func
(paren
r_void
op_star
id|foo
)paren
(brace
r_struct
id|i2o_controller
op_star
id|c
op_assign
(paren
r_struct
id|i2o_controller
op_star
)paren
id|foo
suffix:semicolon
r_struct
id|i2o_device
op_star
id|d
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|i2o_device
op_star
id|d1
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
r_int
id|entries
suffix:semicolon
r_void
op_star
id|tmp
suffix:semicolon
id|daemonize
c_func
(paren
l_string|&quot;iop%d_lctd&quot;
comma
id|c-&gt;unit
)paren
suffix:semicolon
id|allow_signal
c_func
(paren
id|SIGKILL
)paren
suffix:semicolon
id|c-&gt;lct_running
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|down_interruptible
c_func
(paren
op_amp
id|c-&gt;lct_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|dprintk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: LCT thread dead&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
id|c-&gt;lct_running
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|entries
op_assign
id|c-&gt;dlct-&gt;table_size
suffix:semicolon
id|entries
op_sub_assign
l_int|3
suffix:semicolon
id|entries
op_div_assign
l_int|9
suffix:semicolon
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Dynamic LCT Update&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Dynamic LCT contains %d entries&bslash;n&quot;
comma
id|c-&gt;name
comma
id|entries
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entries
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Empty LCT???&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Loop through all the devices on the IOP looking for their&n;&t;&t; * LCT data in the LCT.  We assume that TIDs are not repeated.&n;&t;&t; * as that is the only way to really tell.  It&squot;s been confirmed&n;&t;&t; * by the IRTOS vendor(s?) that TIDs are not reused until they &n;&t;&t; * wrap arround(4096), and I doubt a system will up long enough&n;&t;&t; * to create/delete that many devices.&n;&t;&t; */
r_for
c_loop
(paren
id|d
op_assign
id|c-&gt;devices
suffix:semicolon
id|d
suffix:semicolon
)paren
(brace
id|found
op_assign
l_int|0
suffix:semicolon
id|d1
op_assign
id|d-&gt;next
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|entries
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|d-&gt;lct_data.tid
op_eq
id|c-&gt;dlct-&gt;lct_entry
(braket
id|i
)braket
dot
id|tid
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;i2o_core: Deleted device!&bslash;n&quot;
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|i2o_dev_lock
)paren
suffix:semicolon
id|i2o_delete_device
c_func
(paren
id|d
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|i2o_dev_lock
)paren
suffix:semicolon
)brace
id|d
op_assign
id|d1
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * Tell LCT to renotify us next time there is a change&n;&t; &t; */
id|i2o_lct_notify
c_func
(paren
id|c
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Copy new LCT into public LCT&n;&t;&t; *&n;&t;&t; * Possible race if someone is reading LCT while  we are copying &n;&t;&t; * over it. If this happens, we&squot;ll fix it then. but I doubt that&n;&t;&t; * the LCT will get updated often enough or will get read by&n;&t;&t; * a user often enough to worry.&n;&t;&t; */
r_if
c_cond
(paren
id|c-&gt;lct-&gt;table_size
OL
id|c-&gt;dlct-&gt;table_size
)paren
(brace
id|dma_addr_t
id|phys
suffix:semicolon
id|tmp
op_assign
id|c-&gt;lct
suffix:semicolon
id|c-&gt;lct
op_assign
id|pci_alloc_consistent
c_func
(paren
id|c-&gt;pdev
comma
id|c-&gt;dlct-&gt;table_size
op_lshift
l_int|2
comma
op_amp
id|phys
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;lct
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: No memory for LCT!&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
id|c-&gt;lct
op_assign
id|tmp
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|pci_free_consistent
c_func
(paren
id|tmp
comma
id|c-&gt;lct-&gt;table_size
op_lshift
l_int|2
comma
id|c-&gt;lct
comma
id|c-&gt;lct_phys
)paren
suffix:semicolon
id|c-&gt;lct_phys
op_assign
id|phys
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|c-&gt;lct
comma
id|c-&gt;dlct
comma
id|c-&gt;dlct-&gt;table_size
op_lshift
l_int|2
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_run_queue&t;-&t;process pending events on a controller&n; *&t;@c: controller to process&n; *&n; *&t;This is called by the bus specific driver layer when an interrupt&n; *&t;or poll of this card interface is desired.&n; */
DECL|function|i2o_run_queue
r_void
id|i2o_run_queue
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
)paren
(brace
r_struct
id|i2o_message
op_star
id|m
suffix:semicolon
id|u32
id|mv
suffix:semicolon
id|u32
op_star
id|msg
suffix:semicolon
multiline_comment|/*&n;&t; * Old 960 steppings had a bug in the I2O unit that caused&n;&t; * the queue to appear empty when it wasn&squot;t.&n;&t; */
r_if
c_cond
(paren
(paren
id|mv
op_assign
id|I2O_REPLY_READ32
c_func
(paren
id|c
)paren
)paren
op_eq
l_int|0xFFFFFFFF
)paren
(brace
id|mv
op_assign
id|I2O_REPLY_READ32
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|mv
op_ne
l_int|0xFFFFFFFF
)paren
(brace
r_struct
id|i2o_handler
op_star
id|i
suffix:semicolon
multiline_comment|/* Map the message from the page frame map to kernel virtual */
multiline_comment|/* m=(struct i2o_message *)(mv - (unsigned long)c-&gt;page_frame_map + (unsigned long)c-&gt;page_frame); */
id|m
op_assign
(paren
r_struct
id|i2o_message
op_star
)paren
id|bus_to_virt
c_func
(paren
id|mv
)paren
suffix:semicolon
id|msg
op_assign
(paren
id|u32
op_star
)paren
id|m
suffix:semicolon
multiline_comment|/*&n;&t; &t; *&t;Ensure this message is seen coherently but cachably by&n;&t;&t; *&t;the processor &n;&t; &t; */
id|pci_dma_sync_single
c_func
(paren
id|c-&gt;pdev
comma
id|c-&gt;page_frame_map
comma
id|MSG_FRAME_SIZE
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Despatch it&n;&t; &t; */
id|i
op_assign
id|i2o_handlers
(braket
id|m-&gt;initiator_context
op_amp
(paren
id|MAX_I2O_MODULES
op_minus
l_int|1
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|i
op_logical_and
id|i-&gt;reply
)paren
(brace
id|i
op_member_access_from_pointer
id|reply
c_func
(paren
id|i
comma
id|c
comma
id|m
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;I2O: Spurious reply to handler %d&bslash;n&quot;
comma
id|m-&gt;initiator_context
op_amp
(paren
id|MAX_I2O_MODULES
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
id|i2o_flush_reply
c_func
(paren
id|c
comma
id|mv
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* That 960 bug again... */
r_if
c_cond
(paren
(paren
id|mv
op_assign
id|I2O_REPLY_READ32
c_func
(paren
id|c
)paren
)paren
op_eq
l_int|0xFFFFFFFF
)paren
(brace
id|mv
op_assign
id|I2O_REPLY_READ32
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/**&n; *&t;i2o_get_class_name - &t;do i2o class name lookup&n; *&t;@class: class number&n; *&n; *&t;Return a descriptive string for an i2o class&n; */
DECL|function|i2o_get_class_name
r_const
r_char
op_star
id|i2o_get_class_name
c_func
(paren
r_int
r_class
)paren
(brace
r_int
id|idx
op_assign
l_int|16
suffix:semicolon
r_static
r_char
op_star
id|i2o_class_name
(braket
)braket
op_assign
(brace
l_string|&quot;Executive&quot;
comma
l_string|&quot;Device Driver Module&quot;
comma
l_string|&quot;Block Device&quot;
comma
l_string|&quot;Tape Device&quot;
comma
l_string|&quot;LAN Interface&quot;
comma
l_string|&quot;WAN Interface&quot;
comma
l_string|&quot;Fibre Channel Port&quot;
comma
l_string|&quot;Fibre Channel Device&quot;
comma
l_string|&quot;SCSI Device&quot;
comma
l_string|&quot;ATE Port&quot;
comma
l_string|&quot;ATE Device&quot;
comma
l_string|&quot;Floppy Controller&quot;
comma
l_string|&quot;Floppy Device&quot;
comma
l_string|&quot;Secondary Bus Port&quot;
comma
l_string|&quot;Peer Transport Agent&quot;
comma
l_string|&quot;Peer Transport&quot;
comma
l_string|&quot;Unknown&quot;
)brace
suffix:semicolon
r_switch
c_cond
(paren
r_class
op_amp
l_int|0xFFF
)paren
(brace
r_case
id|I2O_CLASS_EXECUTIVE
suffix:colon
id|idx
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CLASS_DDM
suffix:colon
id|idx
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CLASS_RANDOM_BLOCK_STORAGE
suffix:colon
id|idx
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CLASS_SEQUENTIAL_STORAGE
suffix:colon
id|idx
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CLASS_LAN
suffix:colon
id|idx
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CLASS_WAN
suffix:colon
id|idx
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CLASS_FIBRE_CHANNEL_PORT
suffix:colon
id|idx
op_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL
suffix:colon
id|idx
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CLASS_SCSI_PERIPHERAL
suffix:colon
id|idx
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CLASS_ATE_PORT
suffix:colon
id|idx
op_assign
l_int|9
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CLASS_ATE_PERIPHERAL
suffix:colon
id|idx
op_assign
l_int|10
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CLASS_FLOPPY_CONTROLLER
suffix:colon
id|idx
op_assign
l_int|11
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CLASS_FLOPPY_DEVICE
suffix:colon
id|idx
op_assign
l_int|12
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CLASS_BUS_ADAPTER_PORT
suffix:colon
id|idx
op_assign
l_int|13
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CLASS_PEER_TRANSPORT_AGENT
suffix:colon
id|idx
op_assign
l_int|14
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CLASS_PEER_TRANSPORT
suffix:colon
id|idx
op_assign
l_int|15
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|i2o_class_name
(braket
id|idx
)braket
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_wait_message&t;-&t;obtain an i2o message from the IOP&n; *&t;@c: controller&n; *&t;@why: explanation &n; *&n; *&t;This function waits up to 5 seconds for a message slot to be&n; *&t;available. If no message is available it prints an error message&n; *&t;that is expected to be what the message will be used for (eg&n; *&t;&quot;get_status&quot;). 0xFFFFFFFF is returned on a failure.&n; *&n; *&t;On a success the message is returned. This is the physical page&n; *&t;frame offset address from the read port. (See the i2o spec)&n; */
DECL|function|i2o_wait_message
id|u32
id|i2o_wait_message
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
comma
r_char
op_star
id|why
)paren
(brace
r_int
id|time
op_assign
id|jiffies
suffix:semicolon
id|u32
id|m
suffix:semicolon
r_while
c_loop
(paren
(paren
id|m
op_assign
id|I2O_POST_READ32
c_func
(paren
id|c
)paren
)paren
op_eq
l_int|0xFFFFFFFF
)paren
(brace
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|time
)paren
op_ge
l_int|5
op_star
id|HZ
)paren
(brace
id|dprintk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Timeout waiting for message frame to send %s.&bslash;n&quot;
comma
id|c-&gt;name
comma
id|why
)paren
suffix:semicolon
r_return
l_int|0xFFFFFFFF
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|m
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_report_controller_unit - print information about a tid&n; *&t;@c: controller&n; *&t;@d: device&n; *&t;&n; *&t;Dump an information block associated with a given unit (TID). The&n; *&t;tables are read and a block of text is output to printk that is&n; *&t;formatted intended for the user.&n; */
DECL|function|i2o_report_controller_unit
r_void
id|i2o_report_controller_unit
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
comma
r_struct
id|i2o_device
op_star
id|d
)paren
(brace
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
r_char
id|str
(braket
l_int|22
)braket
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|unit
op_assign
id|d-&gt;lct_data.tid
suffix:semicolon
r_if
c_cond
(paren
id|verbose
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Target ID %d.&bslash;n&quot;
comma
id|unit
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|i2o_query_scalar
c_func
(paren
id|c
comma
id|unit
comma
l_int|0xF100
comma
l_int|3
comma
id|buf
comma
l_int|16
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|buf
(braket
l_int|16
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;     Vendor: %s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|i2o_query_scalar
c_func
(paren
id|c
comma
id|unit
comma
l_int|0xF100
comma
l_int|4
comma
id|buf
comma
l_int|16
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|buf
(braket
l_int|16
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;     Device: %s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i2o_query_scalar
c_func
(paren
id|c
comma
id|unit
comma
l_int|0xF100
comma
l_int|5
comma
id|buf
comma
l_int|16
)paren
op_ge
l_int|0
)paren
(brace
id|buf
(braket
l_int|16
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;     Description: %s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|i2o_query_scalar
c_func
(paren
id|c
comma
id|unit
comma
l_int|0xF100
comma
l_int|6
comma
id|buf
comma
l_int|8
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|buf
(braket
l_int|8
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;        Rev: %s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    Class: &quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|str
comma
l_string|&quot;%-21s&quot;
comma
id|i2o_get_class_name
c_func
(paren
id|d-&gt;lct_data.class_id
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  Subclass: 0x%04X&bslash;n&quot;
comma
id|d-&gt;lct_data.sub_class
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;     Flags: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;lct_data.device_flags
op_amp
(paren
l_int|1
op_lshift
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;C&quot;
)paren
suffix:semicolon
)brace
singleline_comment|// ConfigDialog requested
r_if
c_cond
(paren
id|d-&gt;lct_data.device_flags
op_amp
(paren
l_int|1
op_lshift
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;U&quot;
)paren
suffix:semicolon
)brace
singleline_comment|// Multi-user capable
r_if
c_cond
(paren
op_logical_neg
(paren
id|d-&gt;lct_data.device_flags
op_amp
(paren
l_int|1
op_lshift
l_int|4
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;P&quot;
)paren
suffix:semicolon
)brace
singleline_comment|// Peer service enabled!
r_if
c_cond
(paren
op_logical_neg
(paren
id|d-&gt;lct_data.device_flags
op_amp
(paren
l_int|1
op_lshift
l_int|5
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;M&quot;
)paren
suffix:semicolon
)brace
singleline_comment|// Mgmt service enabled!
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Parse the hardware resource table. Right now we print it out&n; *&t;and don&squot;t do a lot with it. We should collate these and then&n; *&t;interact with the Linux resource allocation block.&n; *&n; *&t;Lets prove we can read it first eh ?&n; *&n; *&t;This is full of endianisms!&n; */
DECL|function|i2o_parse_hrt
r_static
r_int
id|i2o_parse_hrt
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
)paren
(brace
macro_line|#ifdef DRIVERDEBUG
id|u32
op_star
id|rows
op_assign
(paren
id|u32
op_star
)paren
id|c-&gt;hrt
suffix:semicolon
id|u8
op_star
id|p
op_assign
(paren
id|u8
op_star
)paren
id|c-&gt;hrt
suffix:semicolon
id|u8
op_star
id|d
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
id|length
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|state
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|3
)braket
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: HRT table for controller is too new a version.&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|count
op_assign
id|p
(braket
l_int|0
)braket
op_or
(paren
id|p
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
id|length
op_assign
id|p
(braket
l_int|2
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: HRT has %d entries of %d bytes each.&bslash;n&quot;
comma
id|c-&gt;name
comma
id|count
comma
id|length
op_lshift
l_int|2
)paren
suffix:semicolon
id|rows
op_add_assign
l_int|2
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Adapter %08X: &quot;
comma
id|rows
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|p
op_assign
(paren
id|u8
op_star
)paren
(paren
id|rows
op_plus
l_int|1
)paren
suffix:semicolon
id|d
op_assign
(paren
id|u8
op_star
)paren
(paren
id|rows
op_plus
l_int|2
)paren
suffix:semicolon
id|state
op_assign
id|p
(braket
l_int|1
)braket
op_lshift
l_int|8
op_or
id|p
(braket
l_int|0
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TID %04X:[&quot;
comma
id|state
op_amp
l_int|0xFFF
)paren
suffix:semicolon
id|state
op_rshift_assign
l_int|12
suffix:semicolon
r_if
c_cond
(paren
id|state
op_amp
(paren
l_int|1
op_lshift
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;H&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Hidden */
r_if
c_cond
(paren
id|state
op_amp
(paren
l_int|1
op_lshift
l_int|2
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;P&quot;
)paren
suffix:semicolon
multiline_comment|/* Present */
r_if
c_cond
(paren
id|state
op_amp
(paren
l_int|1
op_lshift
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;C&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Controlled */
)brace
r_if
c_cond
(paren
id|state
OG
l_int|9
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;*&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Hard */
id|printk
c_func
(paren
l_string|&quot;]:&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|p
(braket
l_int|3
)braket
op_amp
l_int|0xFFFF
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* Adapter private bus - easy */
id|printk
c_func
(paren
l_string|&quot;Local bus %d: I/O at 0x%04X Mem 0x%08X&quot;
comma
id|p
(braket
l_int|2
)braket
comma
id|d
(braket
l_int|1
)braket
op_lshift
l_int|8
op_or
id|d
(braket
l_int|0
)braket
comma
op_star
(paren
id|u32
op_star
)paren
(paren
id|d
op_plus
l_int|4
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* ISA bus */
id|printk
c_func
(paren
l_string|&quot;ISA %d: CSN %d I/O at 0x%04X Mem 0x%08X&quot;
comma
id|p
(braket
l_int|2
)braket
comma
id|d
(braket
l_int|2
)braket
comma
id|d
(braket
l_int|1
)braket
op_lshift
l_int|8
op_or
id|d
(braket
l_int|0
)braket
comma
op_star
(paren
id|u32
op_star
)paren
(paren
id|d
op_plus
l_int|4
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* EISA bus */
id|printk
c_func
(paren
l_string|&quot;EISA %d: Slot %d I/O at 0x%04X Mem 0x%08X&quot;
comma
id|p
(braket
l_int|2
)braket
comma
id|d
(braket
l_int|3
)braket
comma
id|d
(braket
l_int|1
)braket
op_lshift
l_int|8
op_or
id|d
(braket
l_int|0
)braket
comma
op_star
(paren
id|u32
op_star
)paren
(paren
id|d
op_plus
l_int|4
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* MCA bus */
id|printk
c_func
(paren
l_string|&quot;MCA %d: Slot %d I/O at 0x%04X Mem 0x%08X&quot;
comma
id|p
(braket
l_int|2
)braket
comma
id|d
(braket
l_int|3
)braket
comma
id|d
(braket
l_int|1
)braket
op_lshift
l_int|8
op_or
id|d
(braket
l_int|0
)braket
comma
op_star
(paren
id|u32
op_star
)paren
(paren
id|d
op_plus
l_int|4
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
multiline_comment|/* PCI bus */
id|printk
c_func
(paren
l_string|&quot;PCI %d: Bus %d Device %d Function %d&quot;
comma
id|p
(braket
l_int|2
)braket
comma
id|d
(braket
l_int|2
)braket
comma
id|d
(braket
l_int|1
)braket
comma
id|d
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x80
suffix:colon
multiline_comment|/* Other */
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Unsupported bus type.&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|rows
op_add_assign
id|length
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;The logical configuration table tells us what we can talk to&n; *&t;on the board. Most of the stuff isn&squot;t interesting to us. &n; */
DECL|function|i2o_parse_lct
r_static
r_int
id|i2o_parse_lct
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|max
suffix:semicolon
r_int
id|tid
suffix:semicolon
r_struct
id|i2o_device
op_star
id|d
suffix:semicolon
id|i2o_lct
op_star
id|lct
op_assign
id|c-&gt;lct
suffix:semicolon
r_if
c_cond
(paren
id|lct
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: LCT is empty???&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|max
op_assign
id|lct-&gt;table_size
suffix:semicolon
id|max
op_sub_assign
l_int|3
suffix:semicolon
id|max
op_div_assign
l_int|9
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: LCT has %d entries.&bslash;n&quot;
comma
id|c-&gt;name
comma
id|max
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lct-&gt;iop_flags
op_amp
(paren
l_int|1
op_lshift
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Configuration dialog desired.&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
id|i
op_increment
)paren
(brace
id|d
op_assign
(paren
r_struct
id|i2o_device
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|i2o_device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;i2o_core: Out of memory for I2O device data.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|d-&gt;controller
op_assign
id|c
suffix:semicolon
id|d-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|d-&gt;lct_data
comma
op_amp
id|lct-&gt;lct_entry
(braket
id|i
)braket
comma
r_sizeof
(paren
id|i2o_lct_entry
)paren
)paren
suffix:semicolon
id|d-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|tid
op_assign
id|d-&gt;lct_data.tid
suffix:semicolon
id|i2o_report_controller_unit
c_func
(paren
id|c
comma
id|d
)paren
suffix:semicolon
id|i2o_install_device
c_func
(paren
id|c
comma
id|d
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_quiesce_controller - quiesce controller&n; *&t;@c: controller &n; *&n; *&t;Quiesce an IOP. Causes IOP to make external operation quiescent&n; *&t;(i2o &squot;READY&squot; state). Internal operation of the IOP continues normally.&n; */
DECL|function|i2o_quiesce_controller
r_int
id|i2o_quiesce_controller
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
)paren
(brace
id|u32
id|msg
(braket
l_int|4
)braket
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|i2o_status_get
c_func
(paren
id|c
)paren
suffix:semicolon
multiline_comment|/* SysQuiesce discarded if IOP not in READY or OPERATIONAL state */
r_if
c_cond
(paren
(paren
id|c-&gt;status_block-&gt;iop_state
op_ne
id|ADAPTER_STATE_READY
)paren
op_logical_and
(paren
id|c-&gt;status_block-&gt;iop_state
op_ne
id|ADAPTER_STATE_OPERATIONAL
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|msg
(braket
l_int|0
)braket
op_assign
id|FOUR_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_SYS_QUIESCE
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|ADAPTER_TID
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Long timeout needed for quiesce if lots of devices */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|i2o_post_wait
c_func
(paren
id|c
comma
id|msg
comma
r_sizeof
(paren
id|msg
)paren
comma
l_int|240
)paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Unable to quiesce (status=%#x).&bslash;n&quot;
comma
id|c-&gt;name
comma
op_minus
id|ret
)paren
suffix:semicolon
r_else
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Quiesced.&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
id|i2o_status_get
c_func
(paren
id|c
)paren
suffix:semicolon
singleline_comment|// Entered READY state
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_enable_controller - move controller from ready to operational&n; *&t;@c: controller&n; *&n; *&t;Enable IOP. This allows the IOP to resume external operations and&n; *&t;reverses the effect of a quiesce. In the event of an error a negative&n; *&t;errno code is returned.&n; */
DECL|function|i2o_enable_controller
r_int
id|i2o_enable_controller
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
)paren
(brace
id|u32
id|msg
(braket
l_int|4
)braket
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|i2o_status_get
c_func
(paren
id|c
)paren
suffix:semicolon
multiline_comment|/* Enable only allowed on READY state */
r_if
c_cond
(paren
id|c-&gt;status_block-&gt;iop_state
op_ne
id|ADAPTER_STATE_READY
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|msg
(braket
l_int|0
)braket
op_assign
id|FOUR_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_SYS_ENABLE
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|ADAPTER_TID
suffix:semicolon
multiline_comment|/* How long of a timeout do we need? */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|i2o_post_wait
c_func
(paren
id|c
comma
id|msg
comma
r_sizeof
(paren
id|msg
)paren
comma
l_int|240
)paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Could not enable (status=%#x).&bslash;n&quot;
comma
id|c-&gt;name
comma
op_minus
id|ret
)paren
suffix:semicolon
r_else
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Enabled.&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
id|i2o_status_get
c_func
(paren
id|c
)paren
suffix:semicolon
singleline_comment|// entered OPERATIONAL state
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_clear_controller&t;-&t;clear a controller&n; *&t;@c: controller&n; *&n; *&t;Clear an IOP to HOLD state, ie. terminate external operations, clear all&n; *&t;input queues and prepare for a system restart. IOP&squot;s internal operation&n; *&t;continues normally and the outbound queue is alive.&n; *&t;The IOP is not expected to rebuild its LCT.&n; */
DECL|function|i2o_clear_controller
r_int
id|i2o_clear_controller
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
)paren
(brace
r_struct
id|i2o_controller
op_star
id|iop
suffix:semicolon
id|u32
id|msg
(braket
l_int|4
)braket
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* Quiesce all IOPs first */
r_for
c_loop
(paren
id|iop
op_assign
id|i2o_controller_chain
suffix:semicolon
id|iop
suffix:semicolon
id|iop
op_assign
id|iop-&gt;next
)paren
id|i2o_quiesce_controller
c_func
(paren
id|iop
)paren
suffix:semicolon
id|msg
(braket
l_int|0
)braket
op_assign
id|FOUR_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_ADAPTER_CLEAR
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|ADAPTER_TID
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|i2o_post_wait
c_func
(paren
id|c
comma
id|msg
comma
r_sizeof
(paren
id|msg
)paren
comma
l_int|30
)paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Unable to clear (status=%#x).&bslash;n&quot;
comma
id|c-&gt;name
comma
op_minus
id|ret
)paren
suffix:semicolon
r_else
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Cleared.&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
id|i2o_status_get
c_func
(paren
id|c
)paren
suffix:semicolon
multiline_comment|/* Enable other IOPs */
r_for
c_loop
(paren
id|iop
op_assign
id|i2o_controller_chain
suffix:semicolon
id|iop
suffix:semicolon
id|iop
op_assign
id|iop-&gt;next
)paren
r_if
c_cond
(paren
id|iop
op_ne
id|c
)paren
id|i2o_enable_controller
c_func
(paren
id|iop
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_reset_controller&t;-&t;reset an IOP&n; *&t;@c: controller to reset&n; *&n; *&t;Reset the IOP into INIT state and wait until IOP gets into RESET state.&n; *&t;Terminate all external operations, clear IOP&squot;s inbound and outbound&n; *&t;queues, terminate all DDMs, and reload the IOP&squot;s operating environment&n; *&t;and all local DDMs. The IOP rebuilds its LCT.&n; */
DECL|function|i2o_reset_controller
r_static
r_int
id|i2o_reset_controller
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
)paren
(brace
r_struct
id|i2o_controller
op_star
id|iop
suffix:semicolon
id|u32
id|m
suffix:semicolon
id|u8
op_star
id|status
suffix:semicolon
id|dma_addr_t
id|status_phys
suffix:semicolon
id|u32
op_star
id|msg
suffix:semicolon
r_int
id|time
suffix:semicolon
multiline_comment|/* Quiesce all IOPs first */
r_for
c_loop
(paren
id|iop
op_assign
id|i2o_controller_chain
suffix:semicolon
id|iop
suffix:semicolon
id|iop
op_assign
id|iop-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|iop-&gt;dpt
)paren
(brace
id|i2o_quiesce_controller
c_func
(paren
id|iop
)paren
suffix:semicolon
)brace
)brace
id|m
op_assign
id|i2o_wait_message
c_func
(paren
id|c
comma
l_string|&quot;AdapterReset&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
op_eq
l_int|0xFFFFFFFF
)paren
(brace
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
id|msg
op_assign
(paren
id|u32
op_star
)paren
(paren
id|c-&gt;mem_offset
op_plus
id|m
)paren
suffix:semicolon
id|status
op_assign
id|pci_alloc_consistent
c_func
(paren
id|c-&gt;pdev
comma
l_int|4
comma
op_amp
id|status_phys
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;IOP reset failed - no free memory.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|status
comma
l_int|0
comma
l_int|4
)paren
suffix:semicolon
id|msg
(braket
l_int|0
)braket
op_assign
id|EIGHT_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_ADAPTER_RESET
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|ADAPTER_TID
suffix:semicolon
id|msg
(braket
l_int|2
)braket
op_assign
id|core_context
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|msg
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|msg
(braket
l_int|6
)braket
op_assign
id|status_phys
suffix:semicolon
id|msg
(braket
l_int|7
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 64bit host FIXME */
id|i2o_post_message
c_func
(paren
id|c
comma
id|m
)paren
suffix:semicolon
multiline_comment|/* Wait for a reply */
id|time
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
op_star
id|status
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|time
)paren
op_ge
l_int|20
op_star
id|HZ
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;IOP reset timeout.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* The controller still may respond and overwrite&n;&t;&t;&t; * status_phys, LEAK it to prevent memory corruption.&n;&t;&t;&t; */
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|status
op_eq
id|I2O_CMD_IN_PROGRESS
)paren
(brace
multiline_comment|/* &n;&t;&t; * Once the reset is sent, the IOP goes into the INIT state &n;&t;&t; * which is indeterminate.  We need to wait until the IOP &n;&t;&t; * has rebooted before we can let the system talk to &n;&t;&t; * it. We read the inbound Free_List until a message is &n;&t;&t; * available.  If we can&squot;t read one in the given ammount of &n;&t;&t; * time, we assume the IOP could not reboot properly.  &n;&t;&t; */
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Reset in progress, waiting for reboot...&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
id|time
op_assign
id|jiffies
suffix:semicolon
id|m
op_assign
id|I2O_POST_READ32
c_func
(paren
id|c
)paren
suffix:semicolon
r_while
c_loop
(paren
id|m
op_eq
l_int|0XFFFFFFFF
)paren
(brace
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|time
)paren
op_ge
l_int|30
op_star
id|HZ
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Timeout waiting for IOP reset.&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
multiline_comment|/* The controller still may respond and&n;&t;&t;&t;&t; * overwrite status_phys, LEAK it to prevent&n;&t;&t;&t;&t; * memory corruption.&n;&t;&t;&t;&t; */
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|m
op_assign
id|I2O_POST_READ32
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
id|i2o_flush_reply
c_func
(paren
id|c
comma
id|m
)paren
suffix:semicolon
)brace
multiline_comment|/* If IopReset was rejected or didn&squot;t perform reset, try IopClear */
id|i2o_status_get
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
(braket
l_int|0
)braket
op_eq
id|I2O_CMD_REJECTED
op_logical_or
id|c-&gt;status_block-&gt;iop_state
op_ne
id|ADAPTER_STATE_RESET
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Reset rejected, trying to clear&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
id|i2o_clear_controller
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_else
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Reset completed.&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Enable other IOPs */
r_for
c_loop
(paren
id|iop
op_assign
id|i2o_controller_chain
suffix:semicolon
id|iop
suffix:semicolon
id|iop
op_assign
id|iop-&gt;next
)paren
r_if
c_cond
(paren
id|iop
op_ne
id|c
)paren
id|i2o_enable_controller
c_func
(paren
id|iop
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|c-&gt;pdev
comma
l_int|4
comma
id|status
comma
id|status_phys
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * &t;i2o_status_get&t;-&t;get the status block for the IOP&n; *&t;@c: controller&n; *&n; *&t;Issue a status query on the controller. This updates the&n; *&t;attached status_block. If the controller fails to reply or an&n; *&t;error occurs then a negative errno code is returned. On success&n; *&t;zero is returned and the status_blok is updated.&n; */
DECL|function|i2o_status_get
r_int
id|i2o_status_get
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
)paren
(brace
r_int
id|time
suffix:semicolon
id|u32
id|m
suffix:semicolon
id|u32
op_star
id|msg
suffix:semicolon
id|u8
op_star
id|status_block
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;status_block
op_eq
l_int|NULL
)paren
(brace
id|c-&gt;status_block
op_assign
(paren
id|i2o_status_block
op_star
)paren
id|pci_alloc_consistent
c_func
(paren
id|c-&gt;pdev
comma
r_sizeof
(paren
id|i2o_status_block
)paren
comma
op_amp
id|c-&gt;status_block_phys
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;status_block
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s: Get Status Block failed; Out of memory.&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
id|status_block
op_assign
(paren
id|u8
op_star
)paren
id|c-&gt;status_block
suffix:semicolon
id|memset
c_func
(paren
id|c-&gt;status_block
comma
l_int|0
comma
r_sizeof
(paren
id|i2o_status_block
)paren
)paren
suffix:semicolon
id|m
op_assign
id|i2o_wait_message
c_func
(paren
id|c
comma
l_string|&quot;StatusGet&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
op_eq
l_int|0xFFFFFFFF
)paren
(brace
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
id|msg
op_assign
(paren
id|u32
op_star
)paren
(paren
id|c-&gt;mem_offset
op_plus
id|m
)paren
suffix:semicolon
id|msg
(braket
l_int|0
)braket
op_assign
id|NINE_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_0
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_STATUS_GET
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|ADAPTER_TID
suffix:semicolon
id|msg
(braket
l_int|2
)braket
op_assign
id|core_context
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|msg
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|msg
(braket
l_int|6
)braket
op_assign
id|c-&gt;status_block_phys
suffix:semicolon
id|msg
(braket
l_int|7
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 64bit host FIXME */
id|msg
(braket
l_int|8
)braket
op_assign
r_sizeof
(paren
id|i2o_status_block
)paren
suffix:semicolon
multiline_comment|/* always 88 bytes */
id|i2o_post_message
c_func
(paren
id|c
comma
id|m
)paren
suffix:semicolon
multiline_comment|/* Wait for a reply */
id|time
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
id|status_block
(braket
l_int|87
)braket
op_ne
l_int|0xFF
)paren
(brace
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|time
)paren
op_ge
l_int|5
op_star
id|HZ
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Get status timeout.&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
id|yield
c_func
(paren
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef DRIVERDEBUG
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: State = &quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|c-&gt;status_block-&gt;iop_state
)paren
(brace
r_case
l_int|0x01
suffix:colon
id|printk
c_func
(paren
l_string|&quot;INIT&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x02
suffix:colon
id|printk
c_func
(paren
l_string|&quot;RESET&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x04
suffix:colon
id|printk
c_func
(paren
l_string|&quot;HOLD&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x05
suffix:colon
id|printk
c_func
(paren
l_string|&quot;READY&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x08
suffix:colon
id|printk
c_func
(paren
l_string|&quot;OPERATIONAL&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x10
suffix:colon
id|printk
c_func
(paren
l_string|&quot;FAILED&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x11
suffix:colon
id|printk
c_func
(paren
l_string|&quot;FAULTED&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%x (unknown !!)&bslash;n&quot;
comma
id|c-&gt;status_block-&gt;iop_state
)paren
suffix:semicolon
)brace
macro_line|#endif   
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the Hardware Resource Table for the device.&n; * The HRT contains information about possible hidden devices&n; * but is mostly useless to us &n; */
DECL|function|i2o_hrt_get
r_int
id|i2o_hrt_get
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
)paren
(brace
id|u32
id|msg
(braket
l_int|6
)braket
suffix:semicolon
r_int
id|ret
comma
id|size
op_assign
r_sizeof
(paren
id|i2o_hrt
)paren
suffix:semicolon
multiline_comment|/* First read just the header to figure out the real size */
r_do
(brace
r_if
c_cond
(paren
id|c-&gt;hrt
op_eq
l_int|NULL
)paren
(brace
id|c-&gt;hrt
op_assign
id|pci_alloc_consistent
c_func
(paren
id|c-&gt;pdev
comma
id|size
comma
op_amp
id|c-&gt;hrt_phys
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;hrt
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s: Hrt Get failed; Out of memory.&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
id|msg
(braket
l_int|0
)braket
op_assign
id|SIX_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_4
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_HRT_GET
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|ADAPTER_TID
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
(paren
l_int|0xD0000000
op_or
id|size
)paren
suffix:semicolon
multiline_comment|/* Simple transaction */
id|msg
(braket
l_int|5
)braket
op_assign
id|c-&gt;hrt_phys
suffix:semicolon
multiline_comment|/* Dump it here */
id|ret
op_assign
id|i2o_post_wait_mem
c_func
(paren
id|c
comma
id|msg
comma
r_sizeof
(paren
id|msg
)paren
comma
l_int|20
comma
id|c-&gt;hrt
comma
l_int|NULL
comma
id|c-&gt;hrt_phys
comma
l_int|0
comma
id|size
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|ETIMEDOUT
)paren
(brace
multiline_comment|/* The HRT block we used is in limbo somewhere. When the iop wakes up&n;&t;&t;&t;   we will recover it */
id|c-&gt;hrt
op_assign
l_int|NULL
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Unable to get HRT (status=%#x)&bslash;n&quot;
comma
id|c-&gt;name
comma
op_minus
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c-&gt;hrt-&gt;num_entries
op_star
id|c-&gt;hrt-&gt;entry_len
op_lshift
l_int|2
OG
id|size
)paren
(brace
r_int
id|new_size
op_assign
id|c-&gt;hrt-&gt;num_entries
op_star
id|c-&gt;hrt-&gt;entry_len
op_lshift
l_int|2
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|c-&gt;pdev
comma
id|size
comma
id|c-&gt;hrt
comma
id|c-&gt;hrt_phys
)paren
suffix:semicolon
id|size
op_assign
id|new_size
suffix:semicolon
id|c-&gt;hrt
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|c-&gt;hrt
op_eq
l_int|NULL
)paren
suffix:semicolon
id|i2o_parse_hrt
c_func
(paren
id|c
)paren
suffix:semicolon
singleline_comment|// just for debugging
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Send the I2O System Table to the specified IOP&n; *&n; * The system table contains information about all the IOPs in the&n; * system.  It is build and then sent to each IOP so that IOPs can&n; * establish connections between each other.&n; *&n; */
DECL|function|i2o_systab_send
r_static
r_int
id|i2o_systab_send
c_func
(paren
r_struct
id|i2o_controller
op_star
id|iop
)paren
(brace
id|u32
id|msg
(braket
l_int|12
)braket
suffix:semicolon
id|dma_addr_t
id|sys_tbl_phys
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_struct
id|resource
op_star
id|root
suffix:semicolon
id|u32
op_star
id|privbuf
op_assign
id|kmalloc
c_func
(paren
l_int|16
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|privbuf
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|iop-&gt;status_block-&gt;current_mem_size
OL
id|iop-&gt;status_block-&gt;desired_mem_size
)paren
(brace
r_struct
id|resource
op_star
id|res
op_assign
op_amp
id|iop-&gt;mem_resource
suffix:semicolon
id|res-&gt;name
op_assign
id|iop-&gt;pdev-&gt;bus-&gt;name
suffix:semicolon
id|res-&gt;flags
op_assign
id|IORESOURCE_MEM
suffix:semicolon
id|res-&gt;start
op_assign
l_int|0
suffix:semicolon
id|res-&gt;end
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: requires private memory resources.&bslash;n&quot;
comma
id|iop-&gt;name
)paren
suffix:semicolon
id|root
op_assign
id|pci_find_parent_resource
c_func
(paren
id|iop-&gt;pdev
comma
id|res
)paren
suffix:semicolon
r_if
c_cond
(paren
id|root
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Can&squot;t find parent resource!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|root
op_logical_and
id|allocate_resource
c_func
(paren
id|root
comma
id|res
comma
id|iop-&gt;status_block-&gt;desired_mem_size
comma
id|iop-&gt;status_block-&gt;desired_mem_size
comma
id|iop-&gt;status_block-&gt;desired_mem_size
comma
l_int|1
op_lshift
l_int|20
comma
multiline_comment|/* Unspecified, so use 1Mb and play safe */
l_int|NULL
comma
l_int|NULL
)paren
op_ge
l_int|0
)paren
(brace
id|iop-&gt;mem_alloc
op_assign
l_int|1
suffix:semicolon
id|iop-&gt;status_block-&gt;current_mem_size
op_assign
l_int|1
op_plus
id|res-&gt;end
op_minus
id|res-&gt;start
suffix:semicolon
id|iop-&gt;status_block-&gt;current_mem_base
op_assign
id|res-&gt;start
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: allocated %ld bytes of PCI memory at 0x%08lX.&bslash;n&quot;
comma
id|iop-&gt;name
comma
l_int|1
op_plus
id|res-&gt;end
op_minus
id|res-&gt;start
comma
id|res-&gt;start
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|iop-&gt;status_block-&gt;current_io_size
OL
id|iop-&gt;status_block-&gt;desired_io_size
)paren
(brace
r_struct
id|resource
op_star
id|res
op_assign
op_amp
id|iop-&gt;io_resource
suffix:semicolon
id|res-&gt;name
op_assign
id|iop-&gt;pdev-&gt;bus-&gt;name
suffix:semicolon
id|res-&gt;flags
op_assign
id|IORESOURCE_IO
suffix:semicolon
id|res-&gt;start
op_assign
l_int|0
suffix:semicolon
id|res-&gt;end
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: requires private memory resources.&bslash;n&quot;
comma
id|iop-&gt;name
)paren
suffix:semicolon
id|root
op_assign
id|pci_find_parent_resource
c_func
(paren
id|iop-&gt;pdev
comma
id|res
)paren
suffix:semicolon
r_if
c_cond
(paren
id|root
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Can&squot;t find parent resource!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|root
op_logical_and
id|allocate_resource
c_func
(paren
id|root
comma
id|res
comma
id|iop-&gt;status_block-&gt;desired_io_size
comma
id|iop-&gt;status_block-&gt;desired_io_size
comma
id|iop-&gt;status_block-&gt;desired_io_size
comma
l_int|1
op_lshift
l_int|20
comma
multiline_comment|/* Unspecified, so use 1Mb and play safe */
l_int|NULL
comma
l_int|NULL
)paren
op_ge
l_int|0
)paren
(brace
id|iop-&gt;io_alloc
op_assign
l_int|1
suffix:semicolon
id|iop-&gt;status_block-&gt;current_io_size
op_assign
l_int|1
op_plus
id|res-&gt;end
op_minus
id|res-&gt;start
suffix:semicolon
id|iop-&gt;status_block-&gt;current_mem_base
op_assign
id|res-&gt;start
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: allocated %ld bytes of PCI I/O at 0x%08lX.&bslash;n&quot;
comma
id|iop-&gt;name
comma
l_int|1
op_plus
id|res-&gt;end
op_minus
id|res-&gt;start
comma
id|res-&gt;start
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|privbuf
(braket
l_int|0
)braket
op_assign
id|iop-&gt;status_block-&gt;current_mem_base
suffix:semicolon
id|privbuf
(braket
l_int|1
)braket
op_assign
id|iop-&gt;status_block-&gt;current_mem_size
suffix:semicolon
id|privbuf
(braket
l_int|2
)braket
op_assign
id|iop-&gt;status_block-&gt;current_io_base
suffix:semicolon
id|privbuf
(braket
l_int|3
)braket
op_assign
id|iop-&gt;status_block-&gt;current_io_size
suffix:semicolon
)brace
id|msg
(braket
l_int|0
)braket
op_assign
id|I2O_MESSAGE_SIZE
c_func
(paren
l_int|12
)paren
op_or
id|SGL_OFFSET_6
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_SYS_TAB_SET
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|ADAPTER_TID
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
(paren
l_int|0
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|iop-&gt;unit
op_plus
l_int|2
)paren
)paren
suffix:semicolon
multiline_comment|/* Host 0 IOP ID (unit + 2) */
id|msg
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Segment 0 */
multiline_comment|/* &n; &t; * Provide three SGL-elements:&n; &t; * System table (SysTab), Private memory space declaration and &n; &t; * Private i/o space declaration  &n; &t; * &n; &t; * Nasty one here. We can&squot;t use pci_alloc_consistent to send the&n; &t; * same table to everyone. We have to go remap it for them all&n; &t; */
id|sys_tbl_phys
op_assign
id|pci_map_single
c_func
(paren
id|iop-&gt;pdev
comma
id|sys_tbl
comma
id|sys_tbl_len
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
id|msg
(braket
l_int|6
)braket
op_assign
l_int|0x54000000
op_or
id|sys_tbl_phys
suffix:semicolon
id|msg
(braket
l_int|7
)braket
op_assign
id|sys_tbl_phys
suffix:semicolon
id|msg
(braket
l_int|8
)braket
op_assign
l_int|0x54000000
op_or
id|privbuf
(braket
l_int|1
)braket
suffix:semicolon
id|msg
(braket
l_int|9
)braket
op_assign
id|privbuf
(braket
l_int|0
)braket
suffix:semicolon
id|msg
(braket
l_int|10
)braket
op_assign
l_int|0xD4000000
op_or
id|privbuf
(braket
l_int|3
)braket
suffix:semicolon
id|msg
(braket
l_int|11
)braket
op_assign
id|privbuf
(braket
l_int|2
)braket
suffix:semicolon
id|ret
op_assign
id|i2o_post_wait
c_func
(paren
id|iop
comma
id|msg
comma
r_sizeof
(paren
id|msg
)paren
comma
l_int|120
)paren
suffix:semicolon
id|pci_unmap_single
c_func
(paren
id|iop-&gt;pdev
comma
id|sys_tbl_phys
comma
id|sys_tbl_len
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|ETIMEDOUT
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: SysTab setup timed out.&bslash;n&quot;
comma
id|iop-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Unable to set SysTab (status=%#x).&bslash;n&quot;
comma
id|iop-&gt;name
comma
op_minus
id|ret
)paren
suffix:semicolon
)brace
r_else
(brace
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: SysTab set.&bslash;n&quot;
comma
id|iop-&gt;name
)paren
suffix:semicolon
)brace
id|i2o_status_get
c_func
(paren
id|iop
)paren
suffix:semicolon
singleline_comment|// Entered READY state
id|kfree
c_func
(paren
id|privbuf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize I2O subsystem.&n; */
DECL|function|i2o_sys_init
r_void
id|__init
id|i2o_sys_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|i2o_controller
op_star
id|iop
comma
op_star
id|niop
op_assign
l_int|NULL
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Activating I2O controllers...&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;This may take a few minutes if there are many devices&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* In INIT state, Activate IOPs */
r_for
c_loop
(paren
id|iop
op_assign
id|i2o_controller_chain
suffix:semicolon
id|iop
suffix:semicolon
id|iop
op_assign
id|niop
)paren
(brace
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;Calling i2o_activate_controller for %s...&bslash;n&quot;
comma
id|iop-&gt;name
)paren
suffix:semicolon
id|niop
op_assign
id|iop-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|i2o_activate_controller
c_func
(paren
id|iop
)paren
OL
l_int|0
)paren
id|i2o_delete_controller
c_func
(paren
id|iop
)paren
suffix:semicolon
)brace
multiline_comment|/* Active IOPs in HOLD state */
id|rebuild_sys_tab
suffix:colon
r_if
c_cond
(paren
id|i2o_controller_chain
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If build_sys_table fails, we kill everything and bail&n;&t; * as we can&squot;t init the IOPs w/o a system table&n;&t; */
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;i2o_core: Calling i2o_build_sys_table...&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i2o_build_sys_table
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
id|i2o_sys_shutdown
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* If IOP don&squot;t get online, we need to rebuild the System table */
r_for
c_loop
(paren
id|iop
op_assign
id|i2o_controller_chain
suffix:semicolon
id|iop
suffix:semicolon
id|iop
op_assign
id|niop
)paren
(brace
id|niop
op_assign
id|iop-&gt;next
suffix:semicolon
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;Calling i2o_online_controller for %s...&bslash;n&quot;
comma
id|iop-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i2o_online_controller
c_func
(paren
id|iop
)paren
OL
l_int|0
)paren
(brace
id|i2o_delete_controller
c_func
(paren
id|iop
)paren
suffix:semicolon
r_goto
id|rebuild_sys_tab
suffix:semicolon
)brace
)brace
multiline_comment|/* Active IOPs now in OPERATIONAL state */
multiline_comment|/*&n;&t; * Register for status updates from all IOPs&n;&t; */
r_for
c_loop
(paren
id|iop
op_assign
id|i2o_controller_chain
suffix:semicolon
id|iop
suffix:semicolon
id|iop
op_assign
id|iop-&gt;next
)paren
(brace
multiline_comment|/* Create a kernel thread to deal with dynamic LCT updates */
id|iop-&gt;lct_pid
op_assign
id|kernel_thread
c_func
(paren
id|i2o_dyn_lct
comma
id|iop
comma
id|CLONE_SIGHAND
)paren
suffix:semicolon
multiline_comment|/* Update change ind on DLCT */
id|iop-&gt;dlct-&gt;change_ind
op_assign
id|iop-&gt;lct-&gt;change_ind
suffix:semicolon
multiline_comment|/* Start dynamic LCT updates */
id|i2o_lct_notify
c_func
(paren
id|iop
)paren
suffix:semicolon
multiline_comment|/* Register for all events from IRTOS */
id|i2o_event_register
c_func
(paren
id|iop
comma
id|core_context
comma
l_int|0
comma
l_int|0
comma
l_int|0xFFFFFFFF
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;i2o_sys_shutdown - shutdown I2O system&n; *&n; *&t;Bring down each i2o controller and then return. Each controller&n; *&t;is taken through an orderly shutdown&n; */
DECL|function|i2o_sys_shutdown
r_static
r_void
id|i2o_sys_shutdown
c_func
(paren
r_void
)paren
(brace
r_struct
id|i2o_controller
op_star
id|iop
comma
op_star
id|niop
suffix:semicolon
multiline_comment|/* Delete all IOPs from the controller chain */
multiline_comment|/* that will reset all IOPs too */
r_for
c_loop
(paren
id|iop
op_assign
id|i2o_controller_chain
suffix:semicolon
id|iop
suffix:semicolon
id|iop
op_assign
id|niop
)paren
(brace
id|niop
op_assign
id|iop-&gt;next
suffix:semicolon
id|i2o_delete_controller
c_func
(paren
id|iop
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;i2o_activate_controller&t;-&t;bring controller up to HOLD&n; *&t;@iop: controller&n; *&n; *&t;This function brings an I2O controller into HOLD state. The adapter&n; *&t;is reset if necessary and then the queues and resource table&n; *&t;are read. -1 is returned on a failure, 0 on success.&n; *&t;&n; */
DECL|function|i2o_activate_controller
r_int
id|i2o_activate_controller
c_func
(paren
r_struct
id|i2o_controller
op_star
id|iop
)paren
(brace
multiline_comment|/* In INIT state, Wait Inbound Q to initialize (in i2o_status_get) */
multiline_comment|/* In READY state, Get status */
r_if
c_cond
(paren
id|i2o_status_get
c_func
(paren
id|iop
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Unable to obtain status of %s, &quot;
l_string|&quot;attempting a reset.&bslash;n&quot;
comma
id|iop-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i2o_reset_controller
c_func
(paren
id|iop
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|iop-&gt;status_block-&gt;iop_state
op_eq
id|ADAPTER_STATE_FAULTED
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s: hardware fault&bslash;n&quot;
comma
id|iop-&gt;name
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|iop-&gt;status_block-&gt;i2o_version
OG
id|I2OVER15
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Not running vrs. 1.5. of the I2O Specification.&bslash;n&quot;
comma
id|iop-&gt;name
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|iop-&gt;status_block-&gt;iop_state
op_eq
id|ADAPTER_STATE_READY
op_logical_or
id|iop-&gt;status_block-&gt;iop_state
op_eq
id|ADAPTER_STATE_OPERATIONAL
op_logical_or
id|iop-&gt;status_block-&gt;iop_state
op_eq
id|ADAPTER_STATE_HOLD
op_logical_or
id|iop-&gt;status_block-&gt;iop_state
op_eq
id|ADAPTER_STATE_FAILED
)paren
(brace
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Already running, trying to reset...&bslash;n&quot;
comma
id|iop-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i2o_reset_controller
c_func
(paren
id|iop
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i2o_init_outbound_q
c_func
(paren
id|iop
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|i2o_post_outbound_messages
c_func
(paren
id|iop
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* In HOLD state */
r_if
c_cond
(paren
id|i2o_hrt_get
c_func
(paren
id|iop
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_init_outbound_queue&t;- setup the outbound queue&n; *&t;@c: controller&n; *&n; *&t;Clear and (re)initialize IOP&squot;s outbound queue. Returns 0 on&n; *&t;success or a negative errno code on a failure.&n; */
DECL|function|i2o_init_outbound_q
r_int
id|i2o_init_outbound_q
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
)paren
(brace
id|u8
op_star
id|status
suffix:semicolon
id|dma_addr_t
id|status_phys
suffix:semicolon
id|u32
id|m
suffix:semicolon
id|u32
op_star
id|msg
suffix:semicolon
id|u32
id|time
suffix:semicolon
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Initializing Outbound Queue...&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
id|m
op_assign
id|i2o_wait_message
c_func
(paren
id|c
comma
l_string|&quot;OutboundInit&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
op_eq
l_int|0xFFFFFFFF
)paren
(brace
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
id|msg
op_assign
(paren
id|u32
op_star
)paren
(paren
id|c-&gt;mem_offset
op_plus
id|m
)paren
suffix:semicolon
id|status
op_assign
id|pci_alloc_consistent
c_func
(paren
id|c-&gt;pdev
comma
l_int|4
comma
op_amp
id|status_phys
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Outbound Queue initialization failed - no free memory.&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|status
comma
l_int|0
comma
l_int|4
)paren
suffix:semicolon
id|msg
(braket
l_int|0
)braket
op_assign
id|EIGHT_WORD_MSG_SIZE
op_or
id|TRL_OFFSET_6
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_OUTBOUND_INIT
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|ADAPTER_TID
suffix:semicolon
id|msg
(braket
l_int|2
)braket
op_assign
id|core_context
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
l_int|0x0106
suffix:semicolon
multiline_comment|/* Transaction context */
id|msg
(braket
l_int|4
)braket
op_assign
l_int|4096
suffix:semicolon
multiline_comment|/* Host page frame size */
multiline_comment|/* Frame size is in words. 256 bytes a frame for now */
id|msg
(braket
l_int|5
)braket
op_assign
id|MSG_FRAME_SIZE
op_lshift
l_int|16
op_or
l_int|0x80
suffix:semicolon
multiline_comment|/* Outbound msg frame size in words and Initcode */
id|msg
(braket
l_int|6
)braket
op_assign
l_int|0xD0000004
suffix:semicolon
multiline_comment|/* Simple SG LE, EOB */
id|msg
(braket
l_int|7
)braket
op_assign
id|status_phys
suffix:semicolon
id|i2o_post_message
c_func
(paren
id|c
comma
id|m
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|time
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
id|status
(braket
l_int|0
)braket
OL
id|I2O_CMD_REJECTED
)paren
(brace
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|time
)paren
op_ge
l_int|30
op_star
id|HZ
)paren
(brace
r_if
c_cond
(paren
id|status
(braket
l_int|0
)braket
op_eq
l_int|0x00
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Ignored queue initialize request.&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Outbound queue initialize timeout.&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|c-&gt;pdev
comma
l_int|4
comma
id|status
comma
id|status_phys
)paren
suffix:semicolon
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
id|yield
c_func
(paren
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
(braket
l_int|0
)braket
op_ne
id|I2O_CMD_COMPLETED
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: IOP outbound initialise failed.&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|c-&gt;pdev
comma
l_int|4
comma
id|status
comma
id|status_phys
)paren
suffix:semicolon
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
id|pci_free_consistent
c_func
(paren
id|c-&gt;pdev
comma
l_int|4
comma
id|status
comma
id|status_phys
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_post_outbound_messages&t;-&t;fill message queue&n; *&t;@c: controller&n; *&n; *&t;Allocate a message frame and load the messages into the IOP. The&n; *&t;function returns zero on success or a negative errno code on&n; *&t;failure.&n; */
DECL|function|i2o_post_outbound_messages
r_int
id|i2o_post_outbound_messages
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
)paren
(brace
r_int
id|i
suffix:semicolon
id|u32
id|m
suffix:semicolon
multiline_comment|/* Alloc space for IOP&squot;s outbound queue message frames */
id|c-&gt;page_frame
op_assign
id|kmalloc
c_func
(paren
id|MSG_POOL_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;page_frame
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Outbound Q initialize failed; out of memory.&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|c-&gt;page_frame_map
op_assign
id|pci_map_single
c_func
(paren
id|c-&gt;pdev
comma
id|c-&gt;page_frame
comma
id|MSG_POOL_SIZE
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;page_frame_map
op_eq
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|c-&gt;page_frame
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Unable to map outbound queue.&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|m
op_assign
id|c-&gt;page_frame_map
suffix:semicolon
multiline_comment|/* Post frames */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NMBR_MSG_FRAMES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|I2O_REPLY_WRITE32
c_func
(paren
id|c
comma
id|m
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|m
op_add_assign
(paren
id|MSG_FRAME_SIZE
op_lshift
l_int|2
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the IOP&squot;s Logical Configuration Table&n; */
DECL|function|i2o_lct_get
r_int
id|i2o_lct_get
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
)paren
(brace
id|u32
id|msg
(braket
l_int|8
)braket
suffix:semicolon
r_int
id|ret
comma
id|size
op_assign
id|c-&gt;status_block-&gt;expected_lct_size
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|c-&gt;lct
op_eq
l_int|NULL
)paren
(brace
id|c-&gt;lct
op_assign
id|pci_alloc_consistent
c_func
(paren
id|c-&gt;pdev
comma
id|size
comma
op_amp
id|c-&gt;lct_phys
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;lct
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s: Lct Get failed. Out of memory.&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
id|memset
c_func
(paren
id|c-&gt;lct
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|msg
(braket
l_int|0
)braket
op_assign
id|EIGHT_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_6
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_LCT_NOTIFY
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|ADAPTER_TID
suffix:semicolon
multiline_comment|/* msg[2] filled in i2o_post_wait */
id|msg
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
multiline_comment|/* All devices */
id|msg
(braket
l_int|5
)braket
op_assign
l_int|0x00000000
suffix:semicolon
multiline_comment|/* Report now */
id|msg
(braket
l_int|6
)braket
op_assign
l_int|0xD0000000
op_or
id|size
suffix:semicolon
id|msg
(braket
l_int|7
)braket
op_assign
id|c-&gt;lct_phys
suffix:semicolon
id|ret
op_assign
id|i2o_post_wait_mem
c_func
(paren
id|c
comma
id|msg
comma
r_sizeof
(paren
id|msg
)paren
comma
l_int|120
comma
id|c-&gt;lct
comma
l_int|NULL
comma
id|c-&gt;lct_phys
comma
l_int|0
comma
id|size
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|ETIMEDOUT
)paren
(brace
id|c-&gt;lct
op_assign
l_int|NULL
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: LCT Get failed (status=%#x.&bslash;n&quot;
comma
id|c-&gt;name
comma
op_minus
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c-&gt;lct-&gt;table_size
op_lshift
l_int|2
OG
id|size
)paren
(brace
r_int
id|new_size
op_assign
id|c-&gt;lct-&gt;table_size
op_lshift
l_int|2
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|c-&gt;pdev
comma
id|size
comma
id|c-&gt;lct
comma
id|c-&gt;lct_phys
)paren
suffix:semicolon
id|size
op_assign
id|new_size
suffix:semicolon
id|c-&gt;lct
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|c-&gt;lct
op_eq
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|i2o_parse_lct
c_func
(paren
id|c
)paren
)paren
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Like above, but used for async notification.  The main&n; * difference is that we keep track of the CurrentChangeIndiicator&n; * so that we only get updates when it actually changes.&n; *&n; */
DECL|function|i2o_lct_notify
r_int
id|i2o_lct_notify
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
)paren
(brace
id|u32
id|msg
(braket
l_int|8
)braket
suffix:semicolon
id|msg
(braket
l_int|0
)braket
op_assign
id|EIGHT_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_6
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|I2O_CMD_LCT_NOTIFY
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|ADAPTER_TID
suffix:semicolon
id|msg
(braket
l_int|2
)braket
op_assign
id|core_context
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
l_int|0xDEADBEEF
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
multiline_comment|/* All devices */
id|msg
(braket
l_int|5
)braket
op_assign
id|c-&gt;dlct-&gt;change_ind
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Next change */
id|msg
(braket
l_int|6
)braket
op_assign
l_int|0xD0000000
op_or
l_int|8192
suffix:semicolon
id|msg
(braket
l_int|7
)braket
op_assign
id|c-&gt;dlct_phys
suffix:semicolon
r_return
id|i2o_post_this
c_func
(paren
id|c
comma
id|msg
comma
r_sizeof
(paren
id|msg
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Bring a controller online into OPERATIONAL state. &n; */
DECL|function|i2o_online_controller
r_int
id|i2o_online_controller
c_func
(paren
r_struct
id|i2o_controller
op_star
id|iop
)paren
(brace
id|u32
id|v
suffix:semicolon
r_if
c_cond
(paren
id|i2o_systab_send
c_func
(paren
id|iop
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* In READY state */
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Attempting to enable...&bslash;n&quot;
comma
id|iop-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i2o_enable_controller
c_func
(paren
id|iop
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* In OPERATIONAL state  */
id|dprintk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Attempting to get/parse lct...&bslash;n&quot;
comma
id|iop-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i2o_lct_get
c_func
(paren
id|iop
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Check battery status */
id|iop-&gt;battery
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|i2o_query_scalar
c_func
(paren
id|iop
comma
id|ADAPTER_TID
comma
l_int|0x0000
comma
l_int|4
comma
op_amp
id|v
comma
l_int|4
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|v
op_amp
l_int|16
)paren
(brace
id|iop-&gt;battery
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Build system table&n; *&n; * The system table contains information about all the IOPs in the&n; * system (duh) and is used by the Executives on the IOPs to establish&n; * peer2peer connections.  We&squot;re not supporting peer2peer at the moment,&n; * but this will be needed down the road for things like lan2lan forwarding.&n; */
DECL|function|i2o_build_sys_table
r_static
r_int
id|i2o_build_sys_table
c_func
(paren
r_void
)paren
(brace
r_struct
id|i2o_controller
op_star
id|iop
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|i2o_controller
op_star
id|niop
op_assign
l_int|NULL
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|sys_tbl_len
op_assign
r_sizeof
(paren
r_struct
id|i2o_sys_tbl
)paren
op_plus
singleline_comment|// Header + IOPs
(paren
id|i2o_num_controllers
)paren
op_star
r_sizeof
(paren
r_struct
id|i2o_sys_tbl_entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sys_tbl
)paren
(brace
id|kfree
c_func
(paren
id|sys_tbl
)paren
suffix:semicolon
)brace
id|sys_tbl
op_assign
id|kmalloc
c_func
(paren
id|sys_tbl_len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sys_tbl
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;SysTab Set failed. Out of memory.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|sys_tbl
comma
l_int|0
comma
id|sys_tbl_len
)paren
suffix:semicolon
id|sys_tbl-&gt;num_entries
op_assign
id|i2o_num_controllers
suffix:semicolon
id|sys_tbl-&gt;version
op_assign
id|I2OVERSION
suffix:semicolon
multiline_comment|/* TODO: Version 2.0 */
id|sys_tbl-&gt;change_ind
op_assign
id|sys_tbl_ind
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|iop
op_assign
id|i2o_controller_chain
suffix:semicolon
id|iop
suffix:semicolon
id|iop
op_assign
id|niop
)paren
(brace
id|niop
op_assign
id|iop-&gt;next
suffix:semicolon
multiline_comment|/* &n;&t;&t; * Get updated IOP state so we have the latest information&n;&t;&t; *&n;&t;&t; * We should delete the controller at this point if it&n;&t;&t; * doesn&squot;t respond since  if it&squot;s not on the system table &n;&t;&t; * it is techninically not part of the I2O subsy&#xfffd;tem...&n;&t;&t; */
r_if
c_cond
(paren
id|i2o_status_get
c_func
(paren
id|iop
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Deleting b/c could not get status while&quot;
l_string|&quot;attempting to build system table&bslash;n&quot;
comma
id|iop-&gt;name
)paren
suffix:semicolon
id|i2o_delete_controller
c_func
(paren
id|iop
)paren
suffix:semicolon
id|sys_tbl-&gt;num_entries
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
singleline_comment|// try the next one
)brace
id|sys_tbl-&gt;iops
(braket
id|count
)braket
dot
id|org_id
op_assign
id|iop-&gt;status_block-&gt;org_id
suffix:semicolon
id|sys_tbl-&gt;iops
(braket
id|count
)braket
dot
id|iop_id
op_assign
id|iop-&gt;unit
op_plus
l_int|2
suffix:semicolon
id|sys_tbl-&gt;iops
(braket
id|count
)braket
dot
id|seg_num
op_assign
l_int|0
suffix:semicolon
id|sys_tbl-&gt;iops
(braket
id|count
)braket
dot
id|i2o_version
op_assign
id|iop-&gt;status_block-&gt;i2o_version
suffix:semicolon
id|sys_tbl-&gt;iops
(braket
id|count
)braket
dot
id|iop_state
op_assign
id|iop-&gt;status_block-&gt;iop_state
suffix:semicolon
id|sys_tbl-&gt;iops
(braket
id|count
)braket
dot
id|msg_type
op_assign
id|iop-&gt;status_block-&gt;msg_type
suffix:semicolon
id|sys_tbl-&gt;iops
(braket
id|count
)braket
dot
id|frame_size
op_assign
id|iop-&gt;status_block-&gt;inbound_frame_size
suffix:semicolon
id|sys_tbl-&gt;iops
(braket
id|count
)braket
dot
id|last_changed
op_assign
id|sys_tbl_ind
op_minus
l_int|1
suffix:semicolon
singleline_comment|// ??
id|sys_tbl-&gt;iops
(braket
id|count
)braket
dot
id|iop_capabilities
op_assign
id|iop-&gt;status_block-&gt;iop_capabilities
suffix:semicolon
id|sys_tbl-&gt;iops
(braket
id|count
)braket
dot
id|inbound_low
op_assign
id|iop-&gt;post_port
suffix:semicolon
id|sys_tbl-&gt;iops
(braket
id|count
)braket
dot
id|inbound_high
op_assign
l_int|0
suffix:semicolon
singleline_comment|// FIXME: 64-bit support
id|count
op_increment
suffix:semicolon
)brace
macro_line|#ifdef DRIVERDEBUG
(brace
id|u32
op_star
id|table
suffix:semicolon
id|table
op_assign
(paren
id|u32
op_star
)paren
id|sys_tbl
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
(paren
id|sys_tbl_len
op_rshift
l_int|2
)paren
suffix:semicolon
id|count
op_increment
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;sys_tbl[%d] = %0#10x&bslash;n&quot;
comma
id|count
comma
id|table
(braket
id|count
)braket
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Run time support routines&n; */
multiline_comment|/*&n; *&t;Generic &quot;post and forget&quot; helpers. This is less efficient - we do&n; *&t;a memcpy for example that isnt strictly needed, but for most uses&n; *&t;this is simply not worth optimising&n; */
DECL|function|i2o_post_this
r_int
id|i2o_post_this
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
comma
id|u32
op_star
id|data
comma
r_int
id|len
)paren
(brace
id|u32
id|m
suffix:semicolon
id|u32
op_star
id|msg
suffix:semicolon
r_int
r_int
id|t
op_assign
id|jiffies
suffix:semicolon
r_do
(brace
id|mb
c_func
(paren
)paren
suffix:semicolon
id|m
op_assign
id|I2O_POST_READ32
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|m
op_eq
l_int|0xFFFFFFFF
op_logical_and
(paren
id|jiffies
op_minus
id|t
)paren
OL
id|HZ
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|m
op_eq
l_int|0xFFFFFFFF
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Timeout waiting for message frame!&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
id|msg
op_assign
(paren
id|u32
op_star
)paren
(paren
id|c-&gt;mem_offset
op_plus
id|m
)paren
suffix:semicolon
id|memcpy_toio
c_func
(paren
id|msg
comma
id|data
comma
id|len
)paren
suffix:semicolon
id|i2o_post_message
c_func
(paren
id|c
comma
id|m
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * &t;i2o_post_wait_mem&t;-&t;I2O query/reply with DMA buffers&n; *&t;@c: controller&n; *&t;@msg: message to send&n; *&t;@len: length of message&n; *&t;@timeout: time in seconds to wait&n; *&t;@mem1: attached memory buffer 1&n; *&t;@mem2: attached memory buffer 2&n; *&t;@phys1: physical address of buffer 1&n; *&t;@phys2: physical address of buffer 2&n; *&t;@size1: size of buffer 1&n; *&t;@size2: size of buffer 2&n; *&n; * &t;This core API allows an OSM to post a message and then be told whether&n; *&t;or not the system received a successful reply. &n; *&n; *&t;If the message times out then the value &squot;-ETIMEDOUT&squot; is returned. This&n; *&t;is a special case. In this situation the message may (should) complete&n; *&t;at an indefinite time in the future. When it completes it will use the&n; *&t;memory buffers attached to the request. If -ETIMEDOUT is returned then&n; *&t;the memory buffers must not be freed. Instead the event completion will&n; *&t;free them for you. In all other cases the buffers are your problem.&n; *&n; *&t;Pass NULL for unneeded buffers.&n; */
DECL|function|i2o_post_wait_mem
r_int
id|i2o_post_wait_mem
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
comma
id|u32
op_star
id|msg
comma
r_int
id|len
comma
r_int
id|timeout
comma
r_void
op_star
id|mem1
comma
r_void
op_star
id|mem2
comma
id|dma_addr_t
id|phys1
comma
id|dma_addr_t
id|phys2
comma
r_int
id|size1
comma
r_int
id|size2
)paren
(brace
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|wq_i2o_post
)paren
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
id|complete
op_assign
l_int|0
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
r_struct
id|i2o_post_wait_data
op_star
id|wait_data
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|i2o_post_wait_data
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wait_data
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Create a new notification object&n;&t; */
id|wait_data-&gt;status
op_assign
op_amp
id|status
suffix:semicolon
id|wait_data-&gt;complete
op_assign
op_amp
id|complete
suffix:semicolon
id|wait_data-&gt;mem
(braket
l_int|0
)braket
op_assign
id|mem1
suffix:semicolon
id|wait_data-&gt;mem
(braket
l_int|1
)braket
op_assign
id|mem2
suffix:semicolon
id|wait_data-&gt;phys
(braket
l_int|0
)braket
op_assign
id|phys1
suffix:semicolon
id|wait_data-&gt;phys
(braket
l_int|1
)braket
op_assign
id|phys2
suffix:semicolon
id|wait_data-&gt;size
(braket
l_int|0
)braket
op_assign
id|size1
suffix:semicolon
id|wait_data-&gt;size
(braket
l_int|1
)braket
op_assign
id|size2
suffix:semicolon
multiline_comment|/* &n;&t; *&t;Queue the event with its unique id&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|post_wait_lock
comma
id|flags
)paren
suffix:semicolon
id|wait_data-&gt;next
op_assign
id|post_wait_queue
suffix:semicolon
id|post_wait_queue
op_assign
id|wait_data
suffix:semicolon
id|wait_data-&gt;id
op_assign
(paren
op_increment
id|post_wait_id
)paren
op_amp
l_int|0x7fff
suffix:semicolon
id|wait_data-&gt;wq
op_assign
op_amp
id|wq_i2o_post
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|post_wait_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Fill in the message id&n;&t; */
id|msg
(braket
l_int|2
)braket
op_assign
l_int|0x80000000
op_or
(paren
id|u32
)paren
id|core_context
op_or
(paren
(paren
id|u32
)paren
id|wait_data-&gt;id
op_lshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Post the message to the controller. At some point later it &n;&t; *&t;will return. If we time out before it returns then&n;&t; *&t;complete will be zero.  From the point post_this returns&n;&t; *&t;the wait_data may have been deleted.&n;&t; */
id|add_wait_queue
c_func
(paren
op_amp
id|wq_i2o_post
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|i2o_post_this
c_func
(paren
id|c
comma
id|msg
comma
id|len
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|schedule_timeout
c_func
(paren
id|HZ
op_star
id|timeout
)paren
suffix:semicolon
)brace
r_else
(brace
id|remove_wait_queue
c_func
(paren
op_amp
id|wq_i2o_post
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|wq_i2o_post
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|status
op_assign
op_minus
id|EINTR
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|post_wait_lock
comma
id|flags
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Be sure we see complete as it is locked */
r_if
c_cond
(paren
op_logical_neg
id|complete
)paren
(brace
multiline_comment|/* &n;&t;&t; *&t;Mark the entry dead. We cannot remove it. This is important.&n;&t;&t; *&t;When it does terminate (which it must do if the controller hasnt&n;&t;&t; *&t;died..) then it will otherwise scribble on stuff.&n;&t;&t; *&t;!complete lets us safely check if the entry is still&n;&t;&t; *&t;allocated and thus we can write into it&n;&t;&t; */
id|wait_data-&gt;wq
op_assign
l_int|NULL
suffix:semicolon
id|status
op_assign
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Debugging check - remove me soon */
r_if
c_cond
(paren
id|status
op_eq
op_minus
id|ETIMEDOUT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TIMEDOUT BUG!&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
)brace
multiline_comment|/* And the wait_data is not leaked either! */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|post_wait_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/**&n; * &t;i2o_post_wait&t;&t;-&t;I2O query/reply&n; *&t;@c: controller&n; *&t;@msg: message to send&n; *&t;@len: length of message&n; *&t;@timeout: time in seconds to wait&n; *&n; * &t;This core API allows an OSM to post a message and then be told whether&n; *&t;or not the system received a successful reply. &n; */
DECL|function|i2o_post_wait
r_int
id|i2o_post_wait
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
comma
id|u32
op_star
id|msg
comma
r_int
id|len
comma
r_int
id|timeout
)paren
(brace
r_return
id|i2o_post_wait_mem
c_func
(paren
id|c
comma
id|msg
comma
id|len
comma
id|timeout
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * i2o_post_wait is completed and we want to wake up the &n; * sleeping proccess. Called by core&squot;s reply handler.&n; */
DECL|function|i2o_post_wait_complete
r_static
r_void
id|i2o_post_wait_complete
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
comma
id|u32
id|context
comma
r_int
id|status
)paren
(brace
r_struct
id|i2o_post_wait_data
op_star
op_star
id|p1
comma
op_star
id|q
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* &n;&t; * We need to search through the post_wait &n;&t; * queue to see if the given message is still&n;&t; * outstanding.  If not, it means that the IOP &n;&t; * took longer to respond to the message than we &n;&t; * had allowed and timer has already expired.  &n;&t; * Not much we can do about that except log&n;&t; * it for debug purposes, increase timeout, and recompile&n;&t; *&n;&t; * Lock needed to keep anyone from moving queue pointers &n;&t; * around while we&squot;re looking through them.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|post_wait_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p1
op_assign
op_amp
id|post_wait_queue
suffix:semicolon
op_star
id|p1
op_ne
l_int|NULL
suffix:semicolon
id|p1
op_assign
op_amp
(paren
(paren
op_star
id|p1
)paren
op_member_access_from_pointer
id|next
)paren
)paren
(brace
id|q
op_assign
(paren
op_star
id|p1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;id
op_eq
(paren
(paren
id|context
op_rshift
l_int|16
)paren
op_amp
l_int|0x7fff
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Delete it &n;&t;&t;&t; */
op_star
id|p1
op_assign
id|q-&gt;next
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Live or dead ?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|q-&gt;wq
)paren
(brace
multiline_comment|/* Live entry - wakeup and set status */
op_star
id|q-&gt;status
op_assign
id|status
suffix:semicolon
op_star
id|q-&gt;complete
op_assign
l_int|1
suffix:semicolon
id|wake_up
c_func
(paren
id|q-&gt;wq
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Free resources. Caller is dead&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|q-&gt;mem
(braket
l_int|0
)braket
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|c-&gt;pdev
comma
id|q-&gt;size
(braket
l_int|0
)braket
comma
id|q-&gt;mem
(braket
l_int|0
)braket
comma
id|q-&gt;phys
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|q-&gt;mem
(braket
l_int|1
)braket
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|c-&gt;pdev
comma
id|q-&gt;size
(braket
l_int|1
)braket
comma
id|q-&gt;mem
(braket
l_int|1
)braket
comma
id|q-&gt;phys
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i2o_post_wait event completed after timeout.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|q
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|post_wait_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|post_wait_lock
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;i2o_post_wait: Bogus reply!&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&t;Issue UTIL_PARAMS_GET or UTIL_PARAMS_SET&n; *&n; *&t;This function can be used for all UtilParamsGet/Set operations.&n; *&t;The OperationList is given in oplist-buffer, &n; *&t;and results are returned in reslist-buffer.&n; *&t;Note that the minimum sized reslist is 8 bytes and contains&n; *&t;ResultCount, ErrorInfoSize, BlockStatus and BlockSize.&n; */
DECL|function|i2o_issue_params
r_int
id|i2o_issue_params
c_func
(paren
r_int
id|cmd
comma
r_struct
id|i2o_controller
op_star
id|iop
comma
r_int
id|tid
comma
r_void
op_star
id|oplist
comma
r_int
id|oplen
comma
r_void
op_star
id|reslist
comma
r_int
id|reslen
)paren
(brace
id|u32
id|msg
(braket
l_int|9
)braket
suffix:semicolon
id|u32
op_star
id|res32
op_assign
(paren
id|u32
op_star
)paren
id|reslist
suffix:semicolon
id|u32
op_star
id|restmp
op_assign
(paren
id|u32
op_star
)paren
id|reslist
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|wait_status
suffix:semicolon
id|u32
op_star
id|opmem
comma
op_star
id|resmem
suffix:semicolon
id|dma_addr_t
id|opmem_phys
comma
id|resmem_phys
suffix:semicolon
multiline_comment|/* Get DMAable memory */
id|opmem
op_assign
id|pci_alloc_consistent
c_func
(paren
id|iop-&gt;pdev
comma
id|oplen
comma
op_amp
id|opmem_phys
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opmem
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|opmem
comma
id|oplist
comma
id|oplen
)paren
suffix:semicolon
id|resmem
op_assign
id|pci_alloc_consistent
c_func
(paren
id|iop-&gt;pdev
comma
id|reslen
comma
op_amp
id|resmem_phys
)paren
suffix:semicolon
r_if
c_cond
(paren
id|resmem
op_eq
l_int|NULL
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|iop-&gt;pdev
comma
id|oplen
comma
id|opmem
comma
id|opmem_phys
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|msg
(braket
l_int|0
)braket
op_assign
id|NINE_WORD_MSG_SIZE
op_or
id|SGL_OFFSET_5
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|cmd
op_lshift
l_int|24
op_or
id|HOST_TID
op_lshift
l_int|12
op_or
id|tid
suffix:semicolon
id|msg
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|msg
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|msg
(braket
l_int|5
)braket
op_assign
l_int|0x54000000
op_or
id|oplen
suffix:semicolon
multiline_comment|/* OperationList */
id|msg
(braket
l_int|6
)braket
op_assign
id|opmem_phys
suffix:semicolon
id|msg
(braket
l_int|7
)braket
op_assign
l_int|0xD0000000
op_or
id|reslen
suffix:semicolon
multiline_comment|/* ResultList */
id|msg
(braket
l_int|8
)braket
op_assign
id|resmem_phys
suffix:semicolon
id|wait_status
op_assign
id|i2o_post_wait_mem
c_func
(paren
id|iop
comma
id|msg
comma
r_sizeof
(paren
id|msg
)paren
comma
l_int|10
comma
id|opmem
comma
id|resmem
comma
id|opmem_phys
comma
id|resmem_phys
comma
id|oplen
comma
id|reslen
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;This only looks like a memory leak - don&squot;t &quot;fix&quot; it.&t;&n;&t; */
r_if
c_cond
(paren
id|wait_status
op_eq
op_minus
id|ETIMEDOUT
)paren
(brace
r_return
id|wait_status
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|reslist
comma
id|resmem
comma
id|reslen
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|iop-&gt;pdev
comma
id|reslen
comma
id|resmem
comma
id|resmem_phys
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|iop-&gt;pdev
comma
id|oplen
comma
id|opmem
comma
id|opmem_phys
)paren
suffix:semicolon
multiline_comment|/* Query failed */
r_if
c_cond
(paren
id|wait_status
op_ne
l_int|0
)paren
(brace
r_return
id|wait_status
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Calculate number of bytes of Result LIST&n;&t; * We need to loop through each Result BLOCK and grab the length&n;&t; */
id|restmp
op_assign
id|res32
op_plus
l_int|1
suffix:semicolon
id|len
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|res32
(braket
l_int|0
)braket
op_amp
l_int|0X0000FFFF
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|restmp
(braket
l_int|0
)braket
op_amp
l_int|0x00FF0000
)paren
multiline_comment|/* BlockStatus != SUCCESS */
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s - Error:&bslash;n  ErrorInfoSize = 0x%02x, &quot;
l_string|&quot;BlockStatus = 0x%02x, BlockSize = 0x%04x&bslash;n&quot;
comma
(paren
id|cmd
op_eq
id|I2O_CMD_UTIL_PARAMS_SET
)paren
ques
c_cond
l_string|&quot;PARAMS_SET&quot;
suffix:colon
l_string|&quot;PARAMS_GET&quot;
comma
id|res32
(braket
l_int|1
)braket
op_rshift
l_int|24
comma
(paren
id|res32
(braket
l_int|1
)braket
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
comma
id|res32
(braket
l_int|1
)braket
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;If this is the only request,than we return an error&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|res32
(braket
l_int|0
)braket
op_amp
l_int|0x0000FFFF
)paren
op_eq
l_int|1
)paren
(brace
r_return
op_minus
(paren
(paren
id|res32
(braket
l_int|1
)braket
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
multiline_comment|/* -BlockStatus */
)brace
)brace
id|len
op_add_assign
id|restmp
(braket
l_int|0
)braket
op_amp
l_int|0x0000FFFF
suffix:semicolon
multiline_comment|/* Length of res BLOCK */
id|restmp
op_add_assign
id|restmp
(braket
l_int|0
)braket
op_amp
l_int|0x0000FFFF
suffix:semicolon
multiline_comment|/* Skip to next BLOCK */
)brace
r_return
(paren
id|len
op_lshift
l_int|2
)paren
suffix:semicolon
multiline_comment|/* bytes used by result list */
)brace
multiline_comment|/*&n; *&t; Query one scalar group value or a whole scalar group.&n; */
DECL|function|i2o_query_scalar
r_int
id|i2o_query_scalar
c_func
(paren
r_struct
id|i2o_controller
op_star
id|iop
comma
r_int
id|tid
comma
r_int
id|group
comma
r_int
id|field
comma
r_void
op_star
id|buf
comma
r_int
id|buflen
)paren
(brace
id|u16
id|opblk
(braket
)braket
op_assign
(brace
l_int|1
comma
l_int|0
comma
id|I2O_PARAMS_FIELD_GET
comma
id|group
comma
l_int|1
comma
id|field
)brace
suffix:semicolon
id|u8
id|resblk
(braket
l_int|8
op_plus
id|buflen
)braket
suffix:semicolon
multiline_comment|/* 8 bytes for header */
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
id|field
op_eq
op_minus
l_int|1
)paren
multiline_comment|/* whole group */
id|opblk
(braket
l_int|4
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|size
op_assign
id|i2o_issue_params
c_func
(paren
id|I2O_CMD_UTIL_PARAMS_GET
comma
id|iop
comma
id|tid
comma
id|opblk
comma
r_sizeof
(paren
id|opblk
)paren
comma
id|resblk
comma
r_sizeof
(paren
id|resblk
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
comma
id|resblk
op_plus
l_int|8
comma
id|buflen
)paren
suffix:semicolon
multiline_comment|/* cut off header */
r_if
c_cond
(paren
id|size
OG
id|buflen
)paren
(brace
r_return
id|buflen
suffix:semicolon
)brace
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Set a scalar group value or a whole group.&n; */
DECL|function|i2o_set_scalar
r_int
id|i2o_set_scalar
c_func
(paren
r_struct
id|i2o_controller
op_star
id|iop
comma
r_int
id|tid
comma
r_int
id|group
comma
r_int
id|field
comma
r_void
op_star
id|buf
comma
r_int
id|buflen
)paren
(brace
id|u16
op_star
id|opblk
suffix:semicolon
id|u8
id|resblk
(braket
l_int|8
op_plus
id|buflen
)braket
suffix:semicolon
multiline_comment|/* 8 bytes for header */
r_int
id|size
suffix:semicolon
id|opblk
op_assign
id|kmalloc
c_func
(paren
id|buflen
op_plus
l_int|64
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opblk
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2o: no memory for operation buffer.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|opblk
(braket
l_int|0
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* operation count */
id|opblk
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* pad */
id|opblk
(braket
l_int|2
)braket
op_assign
id|I2O_PARAMS_FIELD_SET
suffix:semicolon
id|opblk
(braket
l_int|3
)braket
op_assign
id|group
suffix:semicolon
r_if
c_cond
(paren
id|field
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* whole group */
id|opblk
(braket
l_int|4
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
id|opblk
op_plus
l_int|5
comma
id|buf
comma
id|buflen
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* single field */
(brace
id|opblk
(braket
l_int|4
)braket
op_assign
l_int|1
suffix:semicolon
id|opblk
(braket
l_int|5
)braket
op_assign
id|field
suffix:semicolon
id|memcpy
c_func
(paren
id|opblk
op_plus
l_int|6
comma
id|buf
comma
id|buflen
)paren
suffix:semicolon
)brace
id|size
op_assign
id|i2o_issue_params
c_func
(paren
id|I2O_CMD_UTIL_PARAMS_SET
comma
id|iop
comma
id|tid
comma
id|opblk
comma
l_int|12
op_plus
id|buflen
comma
id|resblk
comma
r_sizeof
(paren
id|resblk
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|opblk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|buflen
)paren
(brace
r_return
id|buflen
suffix:semicolon
)brace
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/* &n; * &t;if oper == I2O_PARAMS_TABLE_GET, get from all rows &n; * &t;&t;if fieldcount == -1 return all fields&n; *&t;&t;&t;ibuf and ibuflen are unused (use NULL, 0)&n; * &t;&t;else return specific fields&n; *  &t;&t;&t;ibuf contains fieldindexes&n; *&n; * &t;if oper == I2O_PARAMS_LIST_GET, get from specific rows&n; * &t;&t;if fieldcount == -1 return all fields&n; *&t;&t;&t;ibuf contains rowcount, keyvalues&n; * &t;&t;else return specific fields&n; *&t;&t;&t;fieldcount is # of fieldindexes&n; *  &t;&t;&t;ibuf contains fieldindexes, rowcount, keyvalues&n; *&n; *&t;You could also use directly function i2o_issue_params().&n; */
DECL|function|i2o_query_table
r_int
id|i2o_query_table
c_func
(paren
r_int
id|oper
comma
r_struct
id|i2o_controller
op_star
id|iop
comma
r_int
id|tid
comma
r_int
id|group
comma
r_int
id|fieldcount
comma
r_void
op_star
id|ibuf
comma
r_int
id|ibuflen
comma
r_void
op_star
id|resblk
comma
r_int
id|reslen
)paren
(brace
id|u16
op_star
id|opblk
suffix:semicolon
r_int
id|size
suffix:semicolon
id|opblk
op_assign
id|kmalloc
c_func
(paren
l_int|10
op_plus
id|ibuflen
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opblk
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2o: no memory for query buffer.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|opblk
(braket
l_int|0
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* operation count */
id|opblk
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* pad */
id|opblk
(braket
l_int|2
)braket
op_assign
id|oper
suffix:semicolon
id|opblk
(braket
l_int|3
)braket
op_assign
id|group
suffix:semicolon
id|opblk
(braket
l_int|4
)braket
op_assign
id|fieldcount
suffix:semicolon
id|memcpy
c_func
(paren
id|opblk
op_plus
l_int|5
comma
id|ibuf
comma
id|ibuflen
)paren
suffix:semicolon
multiline_comment|/* other params */
id|size
op_assign
id|i2o_issue_params
c_func
(paren
id|I2O_CMD_UTIL_PARAMS_GET
comma
id|iop
comma
id|tid
comma
id|opblk
comma
l_int|10
op_plus
id|ibuflen
comma
id|resblk
comma
id|reslen
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|opblk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|reslen
)paren
(brace
r_return
id|reslen
suffix:semicolon
)brace
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Clear table group, i.e. delete all rows.&n; */
DECL|function|i2o_clear_table
r_int
id|i2o_clear_table
c_func
(paren
r_struct
id|i2o_controller
op_star
id|iop
comma
r_int
id|tid
comma
r_int
id|group
)paren
(brace
id|u16
id|opblk
(braket
)braket
op_assign
(brace
l_int|1
comma
l_int|0
comma
id|I2O_PARAMS_TABLE_CLEAR
comma
id|group
)brace
suffix:semicolon
id|u8
id|resblk
(braket
l_int|32
)braket
suffix:semicolon
multiline_comment|/* min 8 bytes for result header */
r_return
id|i2o_issue_params
c_func
(paren
id|I2O_CMD_UTIL_PARAMS_SET
comma
id|iop
comma
id|tid
comma
id|opblk
comma
r_sizeof
(paren
id|opblk
)paren
comma
id|resblk
comma
r_sizeof
(paren
id|resblk
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Add a new row into a table group.&n; *&n; * &t;if fieldcount==-1 then we add whole rows&n; *&t;&t;buf contains rowcount, keyvalues&n; * &t;else just specific fields are given, rest use defaults&n; *  &t;&t;buf contains fieldindexes, rowcount, keyvalues&n; */
DECL|function|i2o_row_add_table
r_int
id|i2o_row_add_table
c_func
(paren
r_struct
id|i2o_controller
op_star
id|iop
comma
r_int
id|tid
comma
r_int
id|group
comma
r_int
id|fieldcount
comma
r_void
op_star
id|buf
comma
r_int
id|buflen
)paren
(brace
id|u16
op_star
id|opblk
suffix:semicolon
id|u8
id|resblk
(braket
l_int|32
)braket
suffix:semicolon
multiline_comment|/* min 8 bytes for header */
r_int
id|size
suffix:semicolon
id|opblk
op_assign
id|kmalloc
c_func
(paren
id|buflen
op_plus
l_int|64
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opblk
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2o: no memory for operation buffer.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|opblk
(braket
l_int|0
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* operation count */
id|opblk
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* pad */
id|opblk
(braket
l_int|2
)braket
op_assign
id|I2O_PARAMS_ROW_ADD
suffix:semicolon
id|opblk
(braket
l_int|3
)braket
op_assign
id|group
suffix:semicolon
id|opblk
(braket
l_int|4
)braket
op_assign
id|fieldcount
suffix:semicolon
id|memcpy
c_func
(paren
id|opblk
op_plus
l_int|5
comma
id|buf
comma
id|buflen
)paren
suffix:semicolon
id|size
op_assign
id|i2o_issue_params
c_func
(paren
id|I2O_CMD_UTIL_PARAMS_SET
comma
id|iop
comma
id|tid
comma
id|opblk
comma
l_int|10
op_plus
id|buflen
comma
id|resblk
comma
r_sizeof
(paren
id|resblk
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|opblk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|buflen
)paren
(brace
r_return
id|buflen
suffix:semicolon
)brace
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; * Used for error reporting/debugging purposes.&n; * Following fail status are common to all classes.&n; * The preserved message must be handled in the reply handler. &n; */
DECL|function|i2o_report_fail_status
r_void
id|i2o_report_fail_status
c_func
(paren
id|u8
id|req_status
comma
id|u32
op_star
id|msg
)paren
(brace
r_static
r_char
op_star
id|FAIL_STATUS
(braket
)braket
op_assign
(brace
l_string|&quot;0x80&quot;
comma
multiline_comment|/* not used */
l_string|&quot;SERVICE_SUSPENDED&quot;
comma
multiline_comment|/* 0x81 */
l_string|&quot;SERVICE_TERMINATED&quot;
comma
multiline_comment|/* 0x82 */
l_string|&quot;CONGESTION&quot;
comma
l_string|&quot;FAILURE&quot;
comma
l_string|&quot;STATE_ERROR&quot;
comma
l_string|&quot;TIME_OUT&quot;
comma
l_string|&quot;ROUTING_FAILURE&quot;
comma
l_string|&quot;INVALID_VERSION&quot;
comma
l_string|&quot;INVALID_OFFSET&quot;
comma
l_string|&quot;INVALID_MSG_FLAGS&quot;
comma
l_string|&quot;FRAME_TOO_SMALL&quot;
comma
l_string|&quot;FRAME_TOO_LARGE&quot;
comma
l_string|&quot;INVALID_TARGET_ID&quot;
comma
l_string|&quot;INVALID_INITIATOR_ID&quot;
comma
l_string|&quot;INVALID_INITIATOR_CONTEX&quot;
comma
multiline_comment|/* 0x8F */
l_string|&quot;UNKNOWN_FAILURE&quot;
multiline_comment|/* 0xFF */
)brace
suffix:semicolon
r_if
c_cond
(paren
id|req_status
op_eq
id|I2O_FSC_TRANSPORT_UNKNOWN_FAILURE
)paren
id|printk
c_func
(paren
l_string|&quot;TRANSPORT_UNKNOWN_FAILURE (%0#2x)&bslash;n.&quot;
comma
id|req_status
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;TRANSPORT_%s.&bslash;n&quot;
comma
id|FAIL_STATUS
(braket
id|req_status
op_amp
l_int|0x0F
)braket
)paren
suffix:semicolon
multiline_comment|/* Dump some details */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;  InitiatorId = %d, TargetId = %d&bslash;n&quot;
comma
(paren
id|msg
(braket
l_int|1
)braket
op_rshift
l_int|12
)paren
op_amp
l_int|0xFFF
comma
id|msg
(braket
l_int|1
)braket
op_amp
l_int|0xFFF
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;  LowestVersion = 0x%02X, HighestVersion = 0x%02X&bslash;n&quot;
comma
(paren
id|msg
(braket
l_int|4
)braket
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
comma
id|msg
(braket
l_int|4
)braket
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;  FailingHostUnit = 0x%04X,  FailingIOP = 0x%03X&bslash;n&quot;
comma
id|msg
(braket
l_int|5
)braket
op_rshift
l_int|16
comma
id|msg
(braket
l_int|5
)braket
op_amp
l_int|0xFFF
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;  Severity:  0x%02X &quot;
comma
(paren
id|msg
(braket
l_int|4
)braket
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
(braket
l_int|4
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|16
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;(FormatError), &quot;
l_string|&quot;this msg can never be delivered/processed.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
(braket
l_int|4
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|17
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;(PathError), &quot;
l_string|&quot;this msg can no longer be delivered/processed.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
(braket
l_int|4
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|18
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;(PathState), &quot;
l_string|&quot;the system state does not allow delivery.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
(braket
l_int|4
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|19
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;(Congestion), resources temporarily not available;&quot;
l_string|&quot;do not retry immediately.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Used for error reporting/debugging purposes.&n; * Following reply status are common to all classes.&n; */
DECL|function|i2o_report_common_status
r_void
id|i2o_report_common_status
c_func
(paren
id|u8
id|req_status
)paren
(brace
r_static
r_char
op_star
id|REPLY_STATUS
(braket
)braket
op_assign
(brace
l_string|&quot;SUCCESS&quot;
comma
l_string|&quot;ABORT_DIRTY&quot;
comma
l_string|&quot;ABORT_NO_DATA_TRANSFER&quot;
comma
l_string|&quot;ABORT_PARTIAL_TRANSFER&quot;
comma
l_string|&quot;ERROR_DIRTY&quot;
comma
l_string|&quot;ERROR_NO_DATA_TRANSFER&quot;
comma
l_string|&quot;ERROR_PARTIAL_TRANSFER&quot;
comma
l_string|&quot;PROCESS_ABORT_DIRTY&quot;
comma
l_string|&quot;PROCESS_ABORT_NO_DATA_TRANSFER&quot;
comma
l_string|&quot;PROCESS_ABORT_PARTIAL_TRANSFER&quot;
comma
l_string|&quot;TRANSACTION_ERROR&quot;
comma
l_string|&quot;PROGRESS_REPORT&quot;
)brace
suffix:semicolon
r_if
c_cond
(paren
id|req_status
op_ge
id|ARRAY_SIZE
c_func
(paren
id|REPLY_STATUS
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;RequestStatus = %0#2x&quot;
comma
id|req_status
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|REPLY_STATUS
(braket
id|req_status
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Used for error reporting/debugging purposes.&n; * Following detailed status are valid  for executive class, &n; * utility class, DDM class and for transaction error replies.&n; */
DECL|function|i2o_report_common_dsc
r_static
r_void
id|i2o_report_common_dsc
c_func
(paren
id|u16
id|detailed_status
)paren
(brace
r_static
r_char
op_star
id|COMMON_DSC
(braket
)braket
op_assign
(brace
l_string|&quot;SUCCESS&quot;
comma
l_string|&quot;0x01&quot;
comma
singleline_comment|// not used
l_string|&quot;BAD_KEY&quot;
comma
l_string|&quot;TCL_ERROR&quot;
comma
l_string|&quot;REPLY_BUFFER_FULL&quot;
comma
l_string|&quot;NO_SUCH_PAGE&quot;
comma
l_string|&quot;INSUFFICIENT_RESOURCE_SOFT&quot;
comma
l_string|&quot;INSUFFICIENT_RESOURCE_HARD&quot;
comma
l_string|&quot;0x08&quot;
comma
singleline_comment|// not used
l_string|&quot;CHAIN_BUFFER_TOO_LARGE&quot;
comma
l_string|&quot;UNSUPPORTED_FUNCTION&quot;
comma
l_string|&quot;DEVICE_LOCKED&quot;
comma
l_string|&quot;DEVICE_RESET&quot;
comma
l_string|&quot;INAPPROPRIATE_FUNCTION&quot;
comma
l_string|&quot;INVALID_INITIATOR_ADDRESS&quot;
comma
l_string|&quot;INVALID_MESSAGE_FLAGS&quot;
comma
l_string|&quot;INVALID_OFFSET&quot;
comma
l_string|&quot;INVALID_PARAMETER&quot;
comma
l_string|&quot;INVALID_REQUEST&quot;
comma
l_string|&quot;INVALID_TARGET_ADDRESS&quot;
comma
l_string|&quot;MESSAGE_TOO_LARGE&quot;
comma
l_string|&quot;MESSAGE_TOO_SMALL&quot;
comma
l_string|&quot;MISSING_PARAMETER&quot;
comma
l_string|&quot;TIMEOUT&quot;
comma
l_string|&quot;UNKNOWN_ERROR&quot;
comma
l_string|&quot;UNKNOWN_FUNCTION&quot;
comma
l_string|&quot;UNSUPPORTED_VERSION&quot;
comma
l_string|&quot;DEVICE_BUSY&quot;
comma
l_string|&quot;DEVICE_NOT_AVAILABLE&quot;
)brace
suffix:semicolon
r_if
c_cond
(paren
id|detailed_status
OG
id|I2O_DSC_DEVICE_NOT_AVAILABLE
)paren
id|printk
c_func
(paren
l_string|&quot; / DetailedStatus = %0#4x.&bslash;n&quot;
comma
id|detailed_status
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; / %s.&bslash;n&quot;
comma
id|COMMON_DSC
(braket
id|detailed_status
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Used for error reporting/debugging purposes&n; */
DECL|function|i2o_report_lan_dsc
r_static
r_void
id|i2o_report_lan_dsc
c_func
(paren
id|u16
id|detailed_status
)paren
(brace
r_static
r_char
op_star
id|LAN_DSC
(braket
)braket
op_assign
(brace
singleline_comment|// Lan detailed status code strings
l_string|&quot;SUCCESS&quot;
comma
l_string|&quot;DEVICE_FAILURE&quot;
comma
l_string|&quot;DESTINATION_NOT_FOUND&quot;
comma
l_string|&quot;TRANSMIT_ERROR&quot;
comma
l_string|&quot;TRANSMIT_ABORTED&quot;
comma
l_string|&quot;RECEIVE_ERROR&quot;
comma
l_string|&quot;RECEIVE_ABORTED&quot;
comma
l_string|&quot;DMA_ERROR&quot;
comma
l_string|&quot;BAD_PACKET_DETECTED&quot;
comma
l_string|&quot;OUT_OF_MEMORY&quot;
comma
l_string|&quot;BUCKET_OVERRUN&quot;
comma
l_string|&quot;IOP_INTERNAL_ERROR&quot;
comma
l_string|&quot;CANCELED&quot;
comma
l_string|&quot;INVALID_TRANSACTION_CONTEXT&quot;
comma
l_string|&quot;DEST_ADDRESS_DETECTED&quot;
comma
l_string|&quot;DEST_ADDRESS_OMITTED&quot;
comma
l_string|&quot;PARTIAL_PACKET_RETURNED&quot;
comma
l_string|&quot;TEMP_SUSPENDED_STATE&quot;
comma
singleline_comment|// last Lan detailed status code
l_string|&quot;INVALID_REQUEST&quot;
singleline_comment|// general detailed status code
)brace
suffix:semicolon
r_if
c_cond
(paren
id|detailed_status
OG
id|I2O_DSC_INVALID_REQUEST
)paren
id|printk
c_func
(paren
l_string|&quot; / %0#4x.&bslash;n&quot;
comma
id|detailed_status
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; / %s.&bslash;n&quot;
comma
id|LAN_DSC
(braket
id|detailed_status
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Used for error reporting/debugging purposes&n; */
DECL|function|i2o_report_util_cmd
r_static
r_void
id|i2o_report_util_cmd
c_func
(paren
id|u8
id|cmd
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|I2O_CMD_UTIL_NOP
suffix:colon
id|printk
c_func
(paren
l_string|&quot;UTIL_NOP, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_UTIL_ABORT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;UTIL_ABORT, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_UTIL_CLAIM
suffix:colon
id|printk
c_func
(paren
l_string|&quot;UTIL_CLAIM, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_UTIL_RELEASE
suffix:colon
id|printk
c_func
(paren
l_string|&quot;UTIL_CLAIM_RELEASE, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_UTIL_CONFIG_DIALOG
suffix:colon
id|printk
c_func
(paren
l_string|&quot;UTIL_CONFIG_DIALOG, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_UTIL_DEVICE_RESERVE
suffix:colon
id|printk
c_func
(paren
l_string|&quot;UTIL_DEVICE_RESERVE, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_UTIL_DEVICE_RELEASE
suffix:colon
id|printk
c_func
(paren
l_string|&quot;UTIL_DEVICE_RELEASE, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_UTIL_EVT_ACK
suffix:colon
id|printk
c_func
(paren
l_string|&quot;UTIL_EVENT_ACKNOWLEDGE, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_UTIL_EVT_REGISTER
suffix:colon
id|printk
c_func
(paren
l_string|&quot;UTIL_EVENT_REGISTER, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_UTIL_LOCK
suffix:colon
id|printk
c_func
(paren
l_string|&quot;UTIL_LOCK, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_UTIL_LOCK_RELEASE
suffix:colon
id|printk
c_func
(paren
l_string|&quot;UTIL_LOCK_RELEASE, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_UTIL_PARAMS_GET
suffix:colon
id|printk
c_func
(paren
l_string|&quot;UTIL_PARAMS_GET, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_UTIL_PARAMS_SET
suffix:colon
id|printk
c_func
(paren
l_string|&quot;UTIL_PARAMS_SET, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_UTIL_REPLY_FAULT_NOTIFY
suffix:colon
id|printk
c_func
(paren
l_string|&quot;UTIL_REPLY_FAULT_NOTIFY, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Cmd = %0#2x, &quot;
comma
id|cmd
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Used for error reporting/debugging purposes&n; */
DECL|function|i2o_report_exec_cmd
r_static
r_void
id|i2o_report_exec_cmd
c_func
(paren
id|u8
id|cmd
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|I2O_CMD_ADAPTER_ASSIGN
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_ADAPTER_ASSIGN, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_ADAPTER_READ
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_ADAPTER_READ, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_ADAPTER_RELEASE
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_ADAPTER_RELEASE, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_BIOS_INFO_SET
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_BIOS_INFO_SET, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_BOOT_DEVICE_SET
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_BOOT_DEVICE_SET, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_CONFIG_VALIDATE
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_CONFIG_VALIDATE, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_CONN_SETUP
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_CONN_SETUP, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_DDM_DESTROY
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_DDM_DESTROY, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_DDM_ENABLE
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_DDM_ENABLE, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_DDM_QUIESCE
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_DDM_QUIESCE, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_DDM_RESET
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_DDM_RESET, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_DDM_SUSPEND
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_DDM_SUSPEND, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_DEVICE_ASSIGN
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_DEVICE_ASSIGN, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_DEVICE_RELEASE
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_DEVICE_RELEASE, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_HRT_GET
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_HRT_GET, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_ADAPTER_CLEAR
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_IOP_CLEAR, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_ADAPTER_CONNECT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_IOP_CONNECT, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_ADAPTER_RESET
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_IOP_RESET, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_LCT_NOTIFY
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_LCT_NOTIFY, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_OUTBOUND_INIT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_OUTBOUND_INIT, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_PATH_ENABLE
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_PATH_ENABLE, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_PATH_QUIESCE
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_PATH_QUIESCE, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_PATH_RESET
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_PATH_RESET, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_STATIC_MF_CREATE
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_STATIC_MF_CREATE, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_STATIC_MF_RELEASE
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_STATIC_MF_RELEASE, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_STATUS_GET
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_STATUS_GET, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_SW_DOWNLOAD
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_SW_DOWNLOAD, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_SW_UPLOAD
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_SW_UPLOAD, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_SW_REMOVE
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_SW_REMOVE, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_SYS_ENABLE
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_SYS_ENABLE, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_SYS_MODIFY
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_SYS_MODIFY, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_SYS_QUIESCE
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_SYS_QUIESCE, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I2O_CMD_SYS_TAB_SET
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EXEC_SYS_TAB_SET, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Cmd = %#02x, &quot;
comma
id|cmd
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Used for error reporting/debugging purposes&n; */
DECL|function|i2o_report_lan_cmd
r_static
r_void
id|i2o_report_lan_cmd
c_func
(paren
id|u8
id|cmd
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|LAN_PACKET_SEND
suffix:colon
id|printk
c_func
(paren
l_string|&quot;LAN_PACKET_SEND, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LAN_SDU_SEND
suffix:colon
id|printk
c_func
(paren
l_string|&quot;LAN_SDU_SEND, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LAN_RECEIVE_POST
suffix:colon
id|printk
c_func
(paren
l_string|&quot;LAN_RECEIVE_POST, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LAN_RESET
suffix:colon
id|printk
c_func
(paren
l_string|&quot;LAN_RESET, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LAN_SUSPEND
suffix:colon
id|printk
c_func
(paren
l_string|&quot;LAN_SUSPEND, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Cmd = %0#2x, &quot;
comma
id|cmd
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Used for error reporting/debugging purposes.&n; * Report Cmd name, Request status, Detailed Status.&n; */
DECL|function|i2o_report_status
r_void
id|i2o_report_status
c_func
(paren
r_const
r_char
op_star
id|severity
comma
r_const
r_char
op_star
id|str
comma
id|u32
op_star
id|msg
)paren
(brace
id|u8
id|cmd
op_assign
(paren
id|msg
(braket
l_int|1
)braket
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|u8
id|req_status
op_assign
(paren
id|msg
(braket
l_int|4
)braket
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|u16
id|detailed_status
op_assign
id|msg
(braket
l_int|4
)braket
op_amp
l_int|0xFFFF
suffix:semicolon
r_struct
id|i2o_handler
op_star
id|h
op_assign
id|i2o_handlers
(braket
id|msg
(braket
l_int|2
)braket
op_amp
(paren
id|MAX_I2O_MODULES
op_minus
l_int|1
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|I2O_CMD_UTIL_EVT_REGISTER
)paren
r_return
suffix:semicolon
singleline_comment|// No status in this reply
id|printk
c_func
(paren
l_string|&quot;%s%s: &quot;
comma
id|severity
comma
id|str
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
OL
l_int|0x1F
)paren
singleline_comment|// Utility cmd
id|i2o_report_util_cmd
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmd
op_ge
l_int|0xA0
op_logical_and
id|cmd
op_le
l_int|0xEF
)paren
singleline_comment|// Executive cmd
id|i2o_report_exec_cmd
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|h
op_member_access_from_pointer
r_class
op_eq
id|I2O_CLASS_LAN
op_logical_and
id|cmd
op_ge
l_int|0x30
op_logical_and
id|cmd
op_le
l_int|0x3F
)paren
id|i2o_report_lan_cmd
c_func
(paren
id|cmd
)paren
suffix:semicolon
singleline_comment|// LAN cmd
r_else
id|printk
c_func
(paren
l_string|&quot;Cmd = %0#2x, &quot;
comma
id|cmd
)paren
suffix:semicolon
singleline_comment|// Other cmds
r_if
c_cond
(paren
id|msg
(braket
l_int|0
)braket
op_amp
id|MSG_FAIL
)paren
(brace
id|i2o_report_fail_status
c_func
(paren
id|req_status
comma
id|msg
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|i2o_report_common_status
c_func
(paren
id|req_status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
OL
l_int|0x1F
op_logical_or
(paren
id|cmd
op_ge
l_int|0xA0
op_logical_and
id|cmd
op_le
l_int|0xEF
)paren
)paren
id|i2o_report_common_dsc
c_func
(paren
id|detailed_status
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|h
op_member_access_from_pointer
r_class
op_eq
id|I2O_CLASS_LAN
op_logical_and
id|cmd
op_ge
l_int|0x30
op_logical_and
id|cmd
op_le
l_int|0x3F
)paren
id|i2o_report_lan_dsc
c_func
(paren
id|detailed_status
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; / DetailedStatus = %0#4x.&bslash;n&quot;
comma
id|detailed_status
)paren
suffix:semicolon
)brace
multiline_comment|/* Used to dump a message to syslog during debugging */
DECL|function|i2o_dump_message
r_void
id|i2o_dump_message
c_func
(paren
id|u32
op_star
id|msg
)paren
(brace
macro_line|#ifdef DRIVERDEBUG
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Dumping I2O message size %d @ %p&bslash;n&quot;
comma
id|msg
(braket
l_int|0
)braket
op_rshift
l_int|16
op_amp
l_int|0xffff
comma
id|msg
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
(paren
id|msg
(braket
l_int|0
)braket
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  msg[%d] = %0#10x&bslash;n&quot;
comma
id|i
comma
id|msg
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; * I2O reboot/shutdown notification.&n; *&n; * - Call each OSM&squot;s reboot notifier (if one exists)&n; * - Quiesce each IOP in the system&n; *&n; * Each IOP has to be quiesced before we can ensure that the system&n; * can be properly shutdown as a transaction that has already been&n; * acknowledged still needs to be placed in permanent store on the IOP.&n; * The SysQuiesce causes the IOP to force all HDMs to complete their&n; * transactions before returning, so only at that point is it safe&n; * &n; */
DECL|function|i2o_reboot_event
r_static
r_int
id|i2o_reboot_event
c_func
(paren
r_struct
id|notifier_block
op_star
id|n
comma
r_int
r_int
id|code
comma
r_void
op_star
id|p
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_struct
id|i2o_controller
op_star
id|c
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|code
op_ne
id|SYS_RESTART
op_logical_and
id|code
op_ne
id|SYS_HALT
op_logical_and
id|code
op_ne
id|SYS_POWER_OFF
)paren
(brace
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Shutting down I2O system.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;   This could take a few minutes if there are many devices attached&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_I2O_MODULES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i2o_handlers
(braket
id|i
)braket
op_logical_and
id|i2o_handlers
(braket
id|i
)braket
op_member_access_from_pointer
id|reboot_notify
)paren
(brace
id|i2o_handlers
(braket
id|i
)braket
op_member_access_from_pointer
id|reboot_notify
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|c
op_assign
id|i2o_controller_chain
suffix:semicolon
id|c
suffix:semicolon
id|c
op_assign
id|c-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|i2o_quiesce_controller
c_func
(paren
id|c
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i2o: Could not quiesce %s.&bslash;n&quot;
l_string|&quot;Verify setup on next system power up.&bslash;n&quot;
comma
id|c-&gt;name
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;I2O system down.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_pci_dispose&t;&t;-&t;Free bus specific resources&n; *&t;@c: I2O controller&n; *&n; *&t;Disable interrupts and then free interrupt, I/O and mtrr resources &n; *&t;used by this controller. Called by the I2O core on unload.&n; */
DECL|function|i2o_pci_dispose
r_static
r_void
id|i2o_pci_dispose
c_func
(paren
r_struct
id|i2o_controller
op_star
id|c
)paren
(brace
id|I2O_IRQ_WRITE32
c_func
(paren
id|c
comma
l_int|0xFFFFFFFF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;irq
OG
l_int|0
)paren
(brace
id|free_irq
c_func
(paren
id|c-&gt;irq
comma
id|c
)paren
suffix:semicolon
)brace
id|iounmap
c_func
(paren
(paren
(paren
id|u8
op_star
)paren
id|c-&gt;post_port
)paren
op_minus
l_int|0x40
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MTRR
r_if
c_cond
(paren
id|c-&gt;mtrr_reg0
OG
l_int|0
)paren
(brace
id|mtrr_del
c_func
(paren
id|c-&gt;mtrr_reg0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c-&gt;mtrr_reg1
OG
l_int|0
)paren
(brace
id|mtrr_del
c_func
(paren
id|c-&gt;mtrr_reg1
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/**&n; *&t;i2o_pci_interrupt&t;-&t;Bus specific interrupt handler&n; *&t;@irq: interrupt line&n; *&t;@dev_id: cookie&n; *&n; *&t;Handle an interrupt from a PCI based I2O controller. This turns out&n; *&t;to be rather simple. We keep the controller pointer in the cookie.&n; */
DECL|function|i2o_pci_interrupt
r_static
id|irqreturn_t
id|i2o_pci_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|r
)paren
(brace
r_struct
id|i2o_controller
op_star
id|c
op_assign
id|dev_id
suffix:semicolon
id|i2o_run_queue
c_func
(paren
id|c
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;i2o_pci_install&t;&t;-&t;Install a PCI i2o controller&n; *&t;@dev: PCI device of the I2O controller&n; *&n; *&t;Install a PCI (or in theory AGP) i2o controller. Devices are&n; *&t;initialized, configured and registered with the i2o core subsystem. Be&n; *&t;very careful with ordering. There may be pending interrupts.&n; *&n; *&t;To Do: Add support for polled controllers&n; */
DECL|function|i2o_pci_install
r_int
id|__init
id|i2o_pci_install
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_struct
id|i2o_controller
op_star
id|c
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|i2o_controller
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_int
r_int
id|mem
suffix:semicolon
id|u32
id|memptr
op_assign
l_int|0
suffix:semicolon
id|u32
id|size
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2o: Insufficient memory to add controller.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|c
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|c
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Skip I/O spaces */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pci_resource_flags
c_func
(paren
id|dev
comma
id|i
)paren
op_amp
id|IORESOURCE_IO
)paren
)paren
(brace
id|memptr
op_assign
id|pci_resource_start
c_func
(paren
id|dev
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|6
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2o: I2O controller has no memory regions defined.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|c
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|size
op_assign
id|dev-&gt;resource
(braket
id|i
)braket
dot
id|end
op_minus
id|dev-&gt;resource
(braket
id|i
)braket
dot
id|start
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Map the I2O controller */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;i2o: PCI I2O controller at 0x%08X size=%d&bslash;n&quot;
comma
id|memptr
comma
id|size
)paren
suffix:semicolon
id|mem
op_assign
(paren
r_int
r_int
)paren
id|ioremap
c_func
(paren
id|memptr
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mem
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2o: Unable to map controller.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|c
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|c-&gt;irq
op_assign
op_minus
l_int|1
suffix:semicolon
id|c-&gt;dpt
op_assign
l_int|0
suffix:semicolon
id|c-&gt;short_req
op_assign
l_int|0
suffix:semicolon
id|c-&gt;pdev
op_assign
id|dev
suffix:semicolon
id|c-&gt;irq_mask
op_assign
id|mem
op_plus
l_int|0x34
suffix:semicolon
id|c-&gt;post_port
op_assign
id|mem
op_plus
l_int|0x40
suffix:semicolon
id|c-&gt;reply_port
op_assign
id|mem
op_plus
l_int|0x44
suffix:semicolon
id|c-&gt;mem_phys
op_assign
id|memptr
suffix:semicolon
id|c-&gt;mem_offset
op_assign
id|mem
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Cards that fall apart if you hit them with large I/O&n;&t; *&t;loads...&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_NCR
op_logical_and
id|dev-&gt;device
op_eq
l_int|0x0630
)paren
(brace
id|c-&gt;short_req
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;I2O: Symbios FC920 workarounds activated.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;subsystem_vendor
op_eq
id|PCI_VENDOR_ID_PROMISE
)paren
(brace
id|c-&gt;promise
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;I2O: Promise workarounds activated.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Cards that go bananas if you quiesce them before you reset&n;&t; *&t;them&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_DPT
)paren
(brace
id|c-&gt;dpt
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * Enable Write Combining MTRR for IOP&squot;s memory region&n;&t; */
macro_line|#ifdef CONFIG_MTRR
id|c-&gt;mtrr_reg0
op_assign
id|mtrr_add
c_func
(paren
id|c-&gt;mem_phys
comma
id|size
comma
id|MTRR_TYPE_WRCOMB
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If it is an INTEL i960 I/O processor then set the first 64K to&n;&t; * Uncacheable since the region contains the Messaging unit which&n;&t; * shouldn&squot;t be cached.&n;&t; */
id|c-&gt;mtrr_reg1
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_INTEL
op_logical_or
id|dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_DPT
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;I2O: MTRR workaround for Intel i960 processor&bslash;n&quot;
)paren
suffix:semicolon
id|c-&gt;mtrr_reg1
op_assign
id|mtrr_add
c_func
(paren
id|c-&gt;mem_phys
comma
l_int|65536
comma
id|MTRR_TYPE_UNCACHABLE
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;mtrr_reg1
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;i2o_pci: Error in setting MTRR_TYPE_UNCACHABLE&bslash;n&quot;
)paren
suffix:semicolon
id|mtrr_del
c_func
(paren
id|c-&gt;mtrr_reg0
comma
id|c-&gt;mem_phys
comma
id|size
)paren
suffix:semicolon
id|c-&gt;mtrr_reg0
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#endif
id|I2O_IRQ_WRITE32
c_func
(paren
id|c
comma
l_int|0xFFFFFFFF
)paren
suffix:semicolon
id|i
op_assign
id|i2o_install_controller
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2o: Unable to install controller.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|c
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|mem
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
id|c-&gt;irq
op_assign
id|dev-&gt;irq
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;irq
)paren
(brace
id|i
op_assign
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
id|i2o_pci_interrupt
comma
id|SA_SHIRQ
comma
id|c-&gt;name
comma
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: unable to allocate interrupt %d.&bslash;n&quot;
comma
id|c-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|c-&gt;irq
op_assign
op_minus
l_int|1
suffix:semicolon
id|i2o_delete_controller
c_func
(paren
id|c
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|mem
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: Installed at IRQ%d&bslash;n&quot;
comma
id|c-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|I2O_IRQ_WRITE32
c_func
(paren
id|c
comma
l_int|0x0
)paren
suffix:semicolon
id|c-&gt;enabled
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|dpt
r_static
r_int
id|dpt
suffix:semicolon
multiline_comment|/**&n; *&t;i2o_pci_scan&t;-&t;Scan the pci bus for controllers&n; *&t;&n; *&t;Scan the PCI devices on the system looking for any device which is a &n; *&t;memory of the Intelligent, I2O class. We attempt to set up each such device&n; *&t;and register it with the core.&n; *&n; *&t;Returns the number of controllers registered&n; *&n; *&t;Note; Do not change this to a hot plug interface. I2O 1.5 itself&n; *&t;does not support hot plugging.&n; */
DECL|function|i2o_pci_scan
r_int
id|__init
id|i2o_pci_scan
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;i2o: Checking for PCI I2O controllers...&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
id|dev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_rshift
l_int|8
)paren
op_ne
id|PCI_CLASS_INTELLIGENT_I2O
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_DPT
op_logical_and
op_logical_neg
id|dpt
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;device
op_eq
l_int|0xA501
op_logical_or
id|dev-&gt;device
op_eq
l_int|0xA511
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;i2o: Skipping Adaptec/DPT I2O raid with preferred native driver.&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|dev
op_member_access_from_pointer
r_class
op_amp
l_int|0xFF
)paren
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;i2o: I2O Controller found but does not support I2O 1.5 (skipping).&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|dev
)paren
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;i2o: I2O controller on bus %d at %d.&bslash;n&quot;
comma
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_set_dma_mask
c_func
(paren
id|dev
comma
l_int|0xffffffff
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;I2O controller on bus %d at %d : No suitable DMA available&bslash;n&quot;
comma
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|pci_set_master
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i2o_pci_install
c_func
(paren
id|dev
)paren
op_eq
l_int|0
)paren
(brace
id|count
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|count
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;i2o: %d I2O controller%s found and installed.&bslash;n&quot;
comma
id|count
comma
id|count
op_eq
l_int|1
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;s&quot;
)paren
suffix:semicolon
)brace
r_return
id|count
ques
c_cond
id|count
suffix:colon
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|i2o_core_init
r_static
r_int
id|i2o_core_init
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;I2O Core - (C) Copyright 1999 Red Hat Software&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i2o_install_handler
c_func
(paren
op_amp
id|i2o_core_handler
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2o_core: Unable to install core handler.&bslash;nI2O stack not loaded!&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|core_context
op_assign
id|i2o_core_handler.context
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize event handling thread&n;&t; */
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
id|evt_sem
)paren
suffix:semicolon
id|evt_pid
op_assign
id|kernel_thread
c_func
(paren
id|i2o_core_evt
comma
op_amp
id|evt_reply
comma
id|CLONE_SIGHAND
)paren
suffix:semicolon
r_if
c_cond
(paren
id|evt_pid
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;I2O: Could not create event handler kernel thread&bslash;n&quot;
)paren
suffix:semicolon
id|i2o_remove_handler
c_func
(paren
op_amp
id|i2o_core_handler
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;I2O: Event thread created as pid %d&bslash;n&quot;
comma
id|evt_pid
)paren
suffix:semicolon
id|i2o_pci_scan
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i2o_num_controllers
)paren
(brace
id|i2o_sys_init
c_func
(paren
)paren
suffix:semicolon
)brace
id|register_reboot_notifier
c_func
(paren
op_amp
id|i2o_reboot_notifier
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|i2o_core_exit
r_static
r_void
id|i2o_core_exit
c_func
(paren
r_void
)paren
(brace
r_int
id|stat
suffix:semicolon
id|unregister_reboot_notifier
c_func
(paren
op_amp
id|i2o_reboot_notifier
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i2o_num_controllers
)paren
(brace
id|i2o_sys_shutdown
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If this is shutdown time, the thread has already been killed&n;&t; */
r_if
c_cond
(paren
id|evt_running
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Terminating i2o threads...&quot;
)paren
suffix:semicolon
id|stat
op_assign
id|kill_proc
c_func
(paren
id|evt_pid
comma
id|SIGTERM
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stat
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;waiting...&quot;
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|evt_dead
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;done.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|i2o_remove_handler
c_func
(paren
op_amp
id|i2o_core_handler
)paren
suffix:semicolon
id|unregister_reboot_notifier
c_func
(paren
op_amp
id|i2o_reboot_notifier
)paren
suffix:semicolon
)brace
DECL|variable|i2o_core_init
id|module_init
c_func
(paren
id|i2o_core_init
)paren
suffix:semicolon
DECL|variable|i2o_core_exit
id|module_exit
c_func
(paren
id|i2o_core_exit
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|dpt
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|dpt
comma
l_string|&quot;Set this if you want to drive DPT cards normally handled by dpt_i2o&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|verbose
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|verbose
comma
l_string|&quot;Verbose diagnostics&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Red Hat Software&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;I2O Core&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|i2o_controller_chain
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_controller_chain
)paren
suffix:semicolon
DECL|variable|i2o_num_controllers
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_num_controllers
)paren
suffix:semicolon
DECL|variable|i2o_find_controller
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_find_controller
)paren
suffix:semicolon
DECL|variable|i2o_unlock_controller
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_unlock_controller
)paren
suffix:semicolon
DECL|variable|i2o_status_get
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_status_get
)paren
suffix:semicolon
DECL|variable|i2o_install_handler
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_install_handler
)paren
suffix:semicolon
DECL|variable|i2o_remove_handler
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_remove_handler
)paren
suffix:semicolon
DECL|variable|i2o_install_controller
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_install_controller
)paren
suffix:semicolon
DECL|variable|i2o_delete_controller
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_delete_controller
)paren
suffix:semicolon
DECL|variable|i2o_run_queue
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_run_queue
)paren
suffix:semicolon
DECL|variable|i2o_claim_device
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_claim_device
)paren
suffix:semicolon
DECL|variable|i2o_release_device
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_release_device
)paren
suffix:semicolon
DECL|variable|i2o_device_notify_on
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_device_notify_on
)paren
suffix:semicolon
DECL|variable|i2o_device_notify_off
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_device_notify_off
)paren
suffix:semicolon
DECL|variable|i2o_post_this
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_post_this
)paren
suffix:semicolon
DECL|variable|i2o_post_wait
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_post_wait
)paren
suffix:semicolon
DECL|variable|i2o_post_wait_mem
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_post_wait_mem
)paren
suffix:semicolon
DECL|variable|i2o_query_scalar
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_query_scalar
)paren
suffix:semicolon
DECL|variable|i2o_set_scalar
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_set_scalar
)paren
suffix:semicolon
DECL|variable|i2o_query_table
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_query_table
)paren
suffix:semicolon
DECL|variable|i2o_clear_table
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_clear_table
)paren
suffix:semicolon
DECL|variable|i2o_row_add_table
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_row_add_table
)paren
suffix:semicolon
DECL|variable|i2o_issue_params
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_issue_params
)paren
suffix:semicolon
DECL|variable|i2o_event_register
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_event_register
)paren
suffix:semicolon
DECL|variable|i2o_event_ack
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_event_ack
)paren
suffix:semicolon
DECL|variable|i2o_report_status
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_report_status
)paren
suffix:semicolon
DECL|variable|i2o_dump_message
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_dump_message
)paren
suffix:semicolon
DECL|variable|i2o_get_class_name
id|EXPORT_SYMBOL
c_func
(paren
id|i2o_get_class_name
)paren
suffix:semicolon
eof
