multiline_comment|/*&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1999-2002 Harald Koerfgen &lt;hkoerfg@web.de&gt;&n; * Copyright (C) 2001, 2002, 2003, 2004  Maciej W. Rozycki&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/kbd_ll.h&gt;
macro_line|#include &lt;linux/kbd_kern.h&gt;
macro_line|#include &lt;linux/vt_kern.h&gt;
macro_line|#include &lt;asm/keyboard.h&gt;
macro_line|#include &lt;asm/dec/tc.h&gt;
macro_line|#include &lt;asm/dec/machtype.h&gt;
macro_line|#include &lt;asm/dec/serial.h&gt;
macro_line|#include &quot;lk201.h&quot;
multiline_comment|/*&n; * Only handle DECstations that have an LK201 interface.&n; * Maxine uses LK501 at the Access.Bus and various DECsystems&n; * have no keyboard interface at all.&n; */
DECL|macro|LK_IFACE
mdefine_line|#define LK_IFACE&t;(mips_machtype == MACH_DS23100    || &bslash;&n;&t;&t;&t; mips_machtype == MACH_DS5000_200 || &bslash;&n;&t;&t;&t; mips_machtype == MACH_DS5000_1XX || &bslash;&n;&t;&t;&t; mips_machtype == MACH_DS5000_2X0)
multiline_comment|/*&n; * These use the Z8530 SCC.  Others use the DZ11.&n; */
DECL|macro|LK_IFACE_ZS
mdefine_line|#define LK_IFACE_ZS&t;(mips_machtype == MACH_DS5000_1XX || &bslash;&n;&t;&t;&t; mips_machtype == MACH_DS5000_2X0)
multiline_comment|/* Simple translation table for the SysRq keys */
macro_line|#ifdef CONFIG_MAGIC_SYSRQ
multiline_comment|/*&n; * Actually no translation at all, at least until we figure out&n; * how to define SysRq for LK201 and friends. --macro&n; */
DECL|variable|lk201_sysrq_xlate
r_int
r_char
id|lk201_sysrq_xlate
(braket
l_int|128
)braket
suffix:semicolon
DECL|variable|kbd_sysrq_xlate
r_int
r_char
op_star
id|kbd_sysrq_xlate
op_assign
id|lk201_sysrq_xlate
suffix:semicolon
DECL|variable|kbd_sysrq_key
r_int
r_char
id|kbd_sysrq_key
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
DECL|macro|KEYB_LINE
mdefine_line|#define KEYB_LINE&t;3
r_static
r_int
id|__init
id|lk201_init
c_func
(paren
r_void
op_star
)paren
suffix:semicolon
r_static
r_void
id|__init
id|lk201_info
c_func
(paren
r_void
op_star
)paren
suffix:semicolon
r_static
r_void
id|lk201_rx_char
c_func
(paren
r_int
r_char
comma
r_int
r_char
)paren
suffix:semicolon
DECL|variable|lk201_hook
r_static
r_struct
id|dec_serial_hook
id|lk201_hook
op_assign
(brace
dot
id|init_channel
op_assign
id|lk201_init
comma
dot
id|init_info
op_assign
id|lk201_info
comma
dot
id|rx_char
op_assign
l_int|NULL
comma
dot
id|poll_rx_char
op_assign
l_int|NULL
comma
dot
id|poll_tx_char
op_assign
l_int|NULL
comma
dot
id|cflags
op_assign
id|B4800
op_or
id|CS8
op_or
id|CSTOPB
op_or
id|CLOCAL
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * This is used during keyboard initialisation&n; */
DECL|variable|lk201_reset_string
r_static
r_int
r_char
id|lk201_reset_string
(braket
)braket
op_assign
(brace
id|LK_CMD_SET_DEFAULTS
comma
id|LK_CMD_MODE
c_func
(paren
id|LK_MODE_RPT_DOWN
comma
l_int|1
)paren
comma
id|LK_CMD_MODE
c_func
(paren
id|LK_MODE_RPT_DOWN
comma
l_int|2
)paren
comma
id|LK_CMD_MODE
c_func
(paren
id|LK_MODE_RPT_DOWN
comma
l_int|3
)paren
comma
id|LK_CMD_MODE
c_func
(paren
id|LK_MODE_RPT_DOWN
comma
l_int|4
)paren
comma
id|LK_CMD_MODE
c_func
(paren
id|LK_MODE_DOWN_UP
comma
l_int|5
)paren
comma
id|LK_CMD_MODE
c_func
(paren
id|LK_MODE_DOWN_UP
comma
l_int|6
)paren
comma
id|LK_CMD_MODE
c_func
(paren
id|LK_MODE_RPT_DOWN
comma
l_int|7
)paren
comma
id|LK_CMD_MODE
c_func
(paren
id|LK_MODE_RPT_DOWN
comma
l_int|8
)paren
comma
id|LK_CMD_MODE
c_func
(paren
id|LK_MODE_RPT_DOWN
comma
l_int|9
)paren
comma
id|LK_CMD_MODE
c_func
(paren
id|LK_MODE_RPT_DOWN
comma
l_int|10
)paren
comma
id|LK_CMD_MODE
c_func
(paren
id|LK_MODE_RPT_DOWN
comma
l_int|11
)paren
comma
id|LK_CMD_MODE
c_func
(paren
id|LK_MODE_RPT_DOWN
comma
l_int|12
)paren
comma
id|LK_CMD_MODE
c_func
(paren
id|LK_MODE_DOWN
comma
l_int|13
)paren
comma
id|LK_CMD_MODE
c_func
(paren
id|LK_MODE_RPT_DOWN
comma
l_int|14
)paren
comma
id|LK_CMD_DIS_KEYCLK
comma
id|LK_CMD_ENB_BELL
comma
id|LK_PARAM_VOLUME
c_func
(paren
l_int|4
)paren
comma
)brace
suffix:semicolon
DECL|variable|lk201_handle
r_static
r_void
op_star
id|lk201_handle
suffix:semicolon
DECL|function|lk201_send
r_static
r_int
id|lk201_send
c_func
(paren
r_int
r_char
id|ch
)paren
(brace
r_if
c_cond
(paren
id|lk201_hook
dot
id|poll_tx_char
c_func
(paren
id|lk201_handle
comma
id|ch
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;lk201: transmit timeout&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|lk201_get_id
r_static
r_inline
r_int
id|lk201_get_id
c_func
(paren
r_void
)paren
(brace
r_return
id|lk201_send
c_func
(paren
id|LK_CMD_REQ_ID
)paren
suffix:semicolon
)brace
DECL|function|lk201_reset
r_static
r_int
id|lk201_reset
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|r
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|lk201_reset_string
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|r
op_assign
id|lk201_send
c_func
(paren
id|lk201_reset_string
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
r_return
id|r
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|lk201_report
r_static
r_void
id|lk201_report
c_func
(paren
r_int
r_char
id|id
(braket
l_int|6
)braket
)paren
(brace
r_char
op_star
id|report
op_assign
l_string|&quot;lk201: keyboard attached, &quot;
suffix:semicolon
r_switch
c_cond
(paren
id|id
(braket
l_int|2
)braket
)paren
(brace
r_case
id|LK_STAT_PWRUP_OK
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%sself-test OK&bslash;n&quot;
comma
id|report
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LK_STAT_PWRUP_KDOWN
suffix:colon
multiline_comment|/* The keyboard will resend the power-up ID&n;&t;&t;   after all keys are released, so we don&squot;t&n;&t;&t;   bother handling the error specially.  Still&n;&t;&t;   there may be a short-circuit inside.&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%skey down (stuck?), code: 0x%02x&bslash;n&quot;
comma
id|report
comma
id|id
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LK_STAT_PWRUP_ERROR
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%sself-test failure&bslash;n&quot;
comma
id|report
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%sunknown error: 0x%02x&bslash;n&quot;
comma
id|report
comma
id|id
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
)brace
DECL|function|lk201_id
r_static
r_void
id|lk201_id
c_func
(paren
r_int
r_char
id|id
(braket
l_int|6
)braket
)paren
(brace
multiline_comment|/*&n;&t; * Report whether there is an LK201 or an LK401&n;&t; * The LK401 has ALT keys...&n;&t; */
r_switch
c_cond
(paren
id|id
(braket
l_int|4
)braket
)paren
(brace
r_case
l_int|1
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lk201: LK201 detected&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lk201: LK401 detected&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lk201: LK443 detected&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lk201: LK421 detected&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;lk201: unknown keyboard detected, ID %d&bslash;n&quot;
comma
id|id
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;lk201: ... please report to &quot;
l_string|&quot;&lt;linux-mips@linux-mips.org&gt;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|macro|DEFAULT_KEYB_REP_DELAY
mdefine_line|#define DEFAULT_KEYB_REP_DELAY&t;(250/5)&t;/* [5ms] */
DECL|macro|DEFAULT_KEYB_REP_RATE
mdefine_line|#define DEFAULT_KEYB_REP_RATE&t;30&t;/* [cps] */
DECL|variable|kbdrate
r_static
r_struct
id|kbd_repeat
id|kbdrate
op_assign
(brace
id|DEFAULT_KEYB_REP_DELAY
comma
id|DEFAULT_KEYB_REP_RATE
)brace
suffix:semicolon
DECL|function|parse_kbd_rate
r_static
r_void
id|parse_kbd_rate
c_func
(paren
r_struct
id|kbd_repeat
op_star
id|r
)paren
(brace
r_if
c_cond
(paren
id|r-&gt;delay
op_le
l_int|0
)paren
id|r-&gt;delay
op_assign
id|kbdrate.delay
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;rate
op_le
l_int|0
)paren
id|r-&gt;rate
op_assign
id|kbdrate.rate
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;delay
OL
l_int|5
)paren
id|r-&gt;delay
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;delay
OG
l_int|630
)paren
id|r-&gt;delay
op_assign
l_int|630
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;rate
OL
l_int|12
)paren
id|r-&gt;rate
op_assign
l_int|12
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;rate
OG
l_int|127
)paren
id|r-&gt;rate
op_assign
l_int|127
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;rate
op_eq
l_int|125
)paren
id|r-&gt;rate
op_assign
l_int|124
suffix:semicolon
)brace
DECL|function|write_kbd_rate
r_static
r_int
id|write_kbd_rate
c_func
(paren
r_struct
id|kbd_repeat
op_star
id|rep
)paren
(brace
r_int
id|delay
comma
id|rate
suffix:semicolon
r_int
id|i
suffix:semicolon
id|delay
op_assign
id|rep-&gt;delay
op_div
l_int|5
suffix:semicolon
id|rate
op_assign
id|rep-&gt;rate
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|lk201_hook
dot
id|poll_tx_char
c_func
(paren
id|lk201_handle
comma
id|LK_CMD_RPT_RATE
c_func
(paren
id|i
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|lk201_hook
dot
id|poll_tx_char
c_func
(paren
id|lk201_handle
comma
id|LK_PARAM_DELAY
c_func
(paren
id|delay
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|lk201_hook
dot
id|poll_tx_char
c_func
(paren
id|lk201_handle
comma
id|LK_PARAM_RATE
c_func
(paren
id|rate
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|lk201_kbd_rate
r_static
r_int
id|lk201_kbd_rate
c_func
(paren
r_struct
id|kbd_repeat
op_star
id|rep
)paren
(brace
r_if
c_cond
(paren
id|rep
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|parse_kbd_rate
c_func
(paren
id|rep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write_kbd_rate
c_func
(paren
id|rep
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|rep
comma
op_amp
id|kbdrate
comma
r_sizeof
(paren
r_struct
id|kbd_repeat
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|kbdrate
comma
id|rep
comma
r_sizeof
(paren
r_struct
id|kbd_repeat
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|lk201_kd_mksound
r_static
r_void
id|lk201_kd_mksound
c_func
(paren
r_int
r_int
id|hz
comma
r_int
r_int
id|ticks
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ticks
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Can&squot;t set frequency and we &quot;approximate&quot;&n;&t; * duration by volume. ;-)&n;&t; */
id|ticks
op_div_assign
id|HZ
op_div
l_int|32
suffix:semicolon
r_if
c_cond
(paren
id|ticks
OG
l_int|7
)paren
id|ticks
op_assign
l_int|7
suffix:semicolon
id|ticks
op_assign
l_int|7
op_minus
id|ticks
suffix:semicolon
r_if
c_cond
(paren
id|lk201_hook
dot
id|poll_tx_char
c_func
(paren
id|lk201_handle
comma
id|LK_CMD_ENB_BELL
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|lk201_hook
dot
id|poll_tx_char
c_func
(paren
id|lk201_handle
comma
id|LK_PARAM_VOLUME
c_func
(paren
id|ticks
)paren
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|lk201_hook
dot
id|poll_tx_char
c_func
(paren
id|lk201_handle
comma
id|LK_CMD_BELL
)paren
)paren
r_return
suffix:semicolon
)brace
DECL|function|kbd_leds
r_void
id|kbd_leds
c_func
(paren
r_int
r_char
id|leds
)paren
(brace
r_int
r_char
id|l
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lk201_handle
)paren
multiline_comment|/* FIXME */
r_return
suffix:semicolon
multiline_comment|/* FIXME -- Only Hold and Lock LEDs for now. --macro */
r_if
c_cond
(paren
id|leds
op_amp
id|LED_SCR
)paren
id|l
op_or_assign
id|LK_LED_HOLD
suffix:semicolon
r_if
c_cond
(paren
id|leds
op_amp
id|LED_CAP
)paren
id|l
op_or_assign
id|LK_LED_LOCK
suffix:semicolon
r_if
c_cond
(paren
id|lk201_hook
dot
id|poll_tx_char
c_func
(paren
id|lk201_handle
comma
id|LK_CMD_LEDS_ON
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|lk201_hook
dot
id|poll_tx_char
c_func
(paren
id|lk201_handle
comma
id|LK_PARAM_LED_MASK
c_func
(paren
id|l
)paren
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|lk201_hook
dot
id|poll_tx_char
c_func
(paren
id|lk201_handle
comma
id|LK_CMD_LEDS_OFF
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|lk201_hook
dot
id|poll_tx_char
c_func
(paren
id|lk201_handle
comma
id|LK_PARAM_LED_MASK
c_func
(paren
op_complement
id|l
)paren
)paren
)paren
r_return
suffix:semicolon
)brace
DECL|function|kbd_setkeycode
r_int
id|kbd_setkeycode
c_func
(paren
r_int
r_int
id|scancode
comma
r_int
r_int
id|keycode
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|kbd_getkeycode
r_int
id|kbd_getkeycode
c_func
(paren
r_int
r_int
id|scancode
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|kbd_translate
r_int
id|kbd_translate
c_func
(paren
r_int
r_char
id|scancode
comma
r_int
r_char
op_star
id|keycode
comma
r_char
id|raw_mode
)paren
(brace
op_star
id|keycode
op_assign
id|scancode
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|kbd_unexpected_up
r_char
id|kbd_unexpected_up
c_func
(paren
r_int
r_char
id|keycode
)paren
(brace
r_return
l_int|0x80
suffix:semicolon
)brace
DECL|function|lk201_rx_char
r_static
r_void
id|lk201_rx_char
c_func
(paren
r_int
r_char
id|ch
comma
r_int
r_char
id|fl
)paren
(brace
r_static
r_int
r_char
id|id
(braket
l_int|6
)braket
suffix:semicolon
r_static
r_int
id|id_i
suffix:semicolon
r_static
r_int
id|shift_state
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|prev_scancode
suffix:semicolon
r_int
r_char
id|c
op_assign
id|scancodeRemap
(braket
id|ch
)braket
suffix:semicolon
r_if
c_cond
(paren
id|fl
op_ne
id|TTY_NORMAL
op_logical_and
id|fl
op_ne
id|TTY_OVERRUN
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;lk201: keyboard receive error: 0x%02x&bslash;n&quot;
comma
id|fl
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Assume this is a power-up ID. */
r_if
c_cond
(paren
id|ch
op_eq
id|LK_STAT_PWRUP_ID
op_logical_and
op_logical_neg
id|id_i
)paren
(brace
id|id
(braket
id|id_i
op_increment
)braket
op_assign
id|ch
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Handle the power-up sequence. */
r_if
c_cond
(paren
id|id_i
)paren
(brace
id|id
(braket
id|id_i
op_increment
)braket
op_assign
id|ch
suffix:semicolon
r_if
c_cond
(paren
id|id_i
op_eq
l_int|4
)paren
(brace
multiline_comment|/* OK, the power-up concluded. */
id|lk201_report
c_func
(paren
id|id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
(braket
l_int|2
)braket
op_eq
id|LK_STAT_PWRUP_OK
)paren
id|lk201_get_id
c_func
(paren
)paren
suffix:semicolon
r_else
(brace
id|id_i
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;lk201: keyboard power-up &quot;
l_string|&quot;error, skipping initialization&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|id_i
op_eq
l_int|6
)paren
(brace
multiline_comment|/* We got the ID; report it and start operation. */
id|id_i
op_assign
l_int|0
suffix:semicolon
id|lk201_id
c_func
(paren
id|id
)paren
suffix:semicolon
id|lk201_reset
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Everything else is a scancode/status response. */
id|id_i
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|ch
)paren
(brace
r_case
id|LK_STAT_RESUME_ERR
suffix:colon
r_case
id|LK_STAT_ERROR
suffix:colon
r_case
id|LK_STAT_INHIBIT_ACK
suffix:colon
r_case
id|LK_STAT_TEST_ACK
suffix:colon
r_case
id|LK_STAT_MODE_KEYDOWN
suffix:colon
r_case
id|LK_STAT_MODE_ACK
suffix:colon
r_break
suffix:semicolon
r_case
id|LK_KEY_LOCK
suffix:colon
id|shift_state
op_xor_assign
id|LK_LOCK
suffix:semicolon
id|handle_scancode
c_func
(paren
id|c
comma
(paren
id|shift_state
op_amp
id|LK_LOCK
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LK_KEY_SHIFT
suffix:colon
id|shift_state
op_xor_assign
id|LK_SHIFT
suffix:semicolon
id|handle_scancode
c_func
(paren
id|c
comma
(paren
id|shift_state
op_amp
id|LK_SHIFT
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LK_KEY_CTRL
suffix:colon
id|shift_state
op_xor_assign
id|LK_CTRL
suffix:semicolon
id|handle_scancode
c_func
(paren
id|c
comma
(paren
id|shift_state
op_amp
id|LK_CTRL
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LK_KEY_COMP
suffix:colon
id|shift_state
op_xor_assign
id|LK_COMP
suffix:semicolon
id|handle_scancode
c_func
(paren
id|c
comma
(paren
id|shift_state
op_amp
id|LK_COMP
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LK_KEY_RELEASE
suffix:colon
r_if
c_cond
(paren
id|shift_state
op_amp
id|LK_SHIFT
)paren
id|handle_scancode
c_func
(paren
id|scancodeRemap
(braket
id|LK_KEY_SHIFT
)braket
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shift_state
op_amp
id|LK_CTRL
)paren
id|handle_scancode
c_func
(paren
id|scancodeRemap
(braket
id|LK_KEY_CTRL
)braket
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shift_state
op_amp
id|LK_COMP
)paren
id|handle_scancode
c_func
(paren
id|scancodeRemap
(braket
id|LK_KEY_COMP
)braket
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shift_state
op_amp
id|LK_LOCK
)paren
id|handle_scancode
c_func
(paren
id|scancodeRemap
(braket
id|LK_KEY_LOCK
)braket
comma
l_int|0
)paren
suffix:semicolon
id|shift_state
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LK_KEY_REPEAT
suffix:colon
id|handle_scancode
c_func
(paren
id|prev_scancode
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|prev_scancode
op_assign
id|c
suffix:semicolon
id|handle_scancode
c_func
(paren
id|c
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tasklet_schedule
c_func
(paren
op_amp
id|keyboard_tasklet
)paren
suffix:semicolon
)brace
DECL|function|lk201_info
r_static
r_void
id|__init
id|lk201_info
c_func
(paren
r_void
op_star
id|handle
)paren
(brace
)brace
DECL|function|lk201_init
r_static
r_int
id|__init
id|lk201_init
c_func
(paren
r_void
op_star
id|handle
)paren
(brace
multiline_comment|/* First install handlers. */
id|lk201_handle
op_assign
id|handle
suffix:semicolon
id|kbd_rate
op_assign
id|lk201_kbd_rate
suffix:semicolon
id|kd_mksound
op_assign
id|lk201_kd_mksound
suffix:semicolon
id|lk201_hook.rx_char
op_assign
id|lk201_rx_char
suffix:semicolon
multiline_comment|/* Then just issue a reset -- the handlers will do the rest. */
id|lk201_send
c_func
(paren
id|LK_CMD_POWER_UP
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|kbd_init_hw
r_void
id|__init
id|kbd_init_hw
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Maxine uses LK501 at the Access.Bus. */
r_if
c_cond
(paren
op_logical_neg
id|LK_IFACE
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lk201: DECstation LK keyboard driver v0.05.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|LK_IFACE_ZS
)paren
(brace
multiline_comment|/*&n;&t;&t; * kbd_init_hw() is being called before&n;&t;&t; * rs_init() so just register the kbd hook&n;&t;&t; * and let zs_init do the rest :-)&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|register_dec_serial_hook
c_func
(paren
id|KEYB_LINE
comma
op_amp
id|lk201_hook
)paren
)paren
id|unregister_dec_serial_hook
c_func
(paren
id|KEYB_LINE
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * TODO: modify dz.c to allow similar hooks&n;&t;&t; * for LK201 handling on DS2100, DS3100, and DS5000/200&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;lk201: support for DZ11 not yet ready.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
eof
