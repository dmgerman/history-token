multiline_comment|/*&n; *&t;Intel i810 and friends ICH driver for Linux&n; *&t;Alan Cox &lt;alan@redhat.com&gt;&n; *&n; *  Built from:&n; *&t;Low level code:  Zach Brown (original nonworking i810 OSS driver)&n; *&t;&t;&t; Jaroslav Kysela &lt;perex@suse.cz&gt; (working ALSA driver)&n; *&n; *&t;Framework: Thomas Sailer &lt;sailer@ife.ee.ethz.ch&gt;&n; *&t;Extended by: Zach Brown &lt;zab@redhat.com&gt;  &n; *&t;&t;&t;and others..&n; *&n; *  Hardware Provided By:&n; *&t;Analog Devices (A major AC97 codec maker)&n; *&t;Intel Corp  (you&squot;ve probably heard of them already)&n; *&n; * AC97 clues and assistance provided by&n; *&t;Analog Devices&n; *&t;Zach &squot;Fufu&squot; Brown&n; *&t;Jeff Garzik&n; *&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2 of the License, or&n; *&t;(at your option) any later version.&n; *&n; *&t;This program is distributed in the hope that it will be useful,&n; *&t;but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *&t;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *&t;GNU General Public License for more details.&n; *&n; *&t;You should have received a copy of the GNU General Public License&n; *&t;along with this program; if not, write to the Free Software&n; *&t;Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; *&n; *&t;Intel 810 theory of operation&n; *&n; *&t;The chipset provides three DMA channels that talk to an AC97&n; *&t;CODEC (AC97 is a digital/analog mixer standard). At its simplest&n; *&t;you get 48Khz audio with basic volume and mixer controls. At the&n; *&t;best you get rate adaption in the codec. We set the card up so&n; *&t;that we never take completion interrupts but instead keep the card&n; *&t;chasing its tail around a ring buffer. This is needed for mmap&n; *&t;mode audio and happens to work rather well for non-mmap modes too.&n; *&n; *&t;The board has one output channel for PCM audio (supported) and&n; *&t;a stereo line in and mono microphone input. Again these are normally&n; *&t;locked to 48Khz only. Right now recording is not finished.&n; *&n; *&t;There is no midi support, no synth support. Use timidity. To get&n; *&t;esd working you need to use esd -r 48000 as it won&squot;t probe 48KHz&n; *&t;by default. mpg123 can&squot;t handle 48Khz only audio so use xmms.&n; *&n; *&t;Fix The Sound On Dell&n; *&n; *&t;Not everyone uses 48KHz. We know of no way to detect this reliably&n; *&t;and certainly not to get the right data. If your i810 audio sounds&n; *&t;stupid you may need to investigate other speeds. According to Analog&n; *&t;they tend to use a 14.318MHz clock which gives you a base rate of&n; *&t;41194Hz.&n; *&n; *&t;This is available via the &squot;ftsodell=1&squot; option. &n; *&n; *&t;If you need to force a specific rate set the clocking= option&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/sound.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/soundcard.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/ac97_codec.h&gt;
macro_line|#include &lt;linux/wrapper.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/hardirq.h&gt;
macro_line|#ifndef PCI_DEVICE_ID_INTEL_82801
DECL|macro|PCI_DEVICE_ID_INTEL_82801
mdefine_line|#define PCI_DEVICE_ID_INTEL_82801&t;0x2415
macro_line|#endif
macro_line|#ifndef PCI_DEVICE_ID_INTEL_82901
DECL|macro|PCI_DEVICE_ID_INTEL_82901
mdefine_line|#define PCI_DEVICE_ID_INTEL_82901&t;0x2425
macro_line|#endif
macro_line|#ifndef PCI_DEVICE_ID_INTEL_ICH2
DECL|macro|PCI_DEVICE_ID_INTEL_ICH2
mdefine_line|#define PCI_DEVICE_ID_INTEL_ICH2&t;0x2445
macro_line|#endif
macro_line|#ifndef PCI_DEVICE_ID_INTEL_ICH3
DECL|macro|PCI_DEVICE_ID_INTEL_ICH3
mdefine_line|#define PCI_DEVICE_ID_INTEL_ICH3&t;0x2485
macro_line|#endif
macro_line|#ifndef PCI_DEVICE_ID_INTEL_440MX
DECL|macro|PCI_DEVICE_ID_INTEL_440MX
mdefine_line|#define PCI_DEVICE_ID_INTEL_440MX&t;0x7195
macro_line|#endif
DECL|variable|ftsodell
r_static
r_int
id|ftsodell
op_assign
l_int|0
suffix:semicolon
DECL|variable|strict_clocking
r_static
r_int
id|strict_clocking
op_assign
l_int|0
suffix:semicolon
DECL|variable|clocking
r_static
r_int
r_int
id|clocking
op_assign
l_int|48000
suffix:semicolon
DECL|variable|spdif_locked
r_static
r_int
id|spdif_locked
op_assign
l_int|0
suffix:semicolon
singleline_comment|//#define DEBUG
singleline_comment|//#define DEBUG2
singleline_comment|//#define DEBUG_INTERRUPTS
DECL|macro|ADC_RUNNING
mdefine_line|#define ADC_RUNNING&t;1
DECL|macro|DAC_RUNNING
mdefine_line|#define DAC_RUNNING&t;2
DECL|macro|I810_FMT_16BIT
mdefine_line|#define I810_FMT_16BIT&t;1
DECL|macro|I810_FMT_STEREO
mdefine_line|#define I810_FMT_STEREO&t;2
DECL|macro|I810_FMT_MASK
mdefine_line|#define I810_FMT_MASK&t;3
DECL|macro|SPDIF_ON
mdefine_line|#define SPDIF_ON&t;0x0004
DECL|macro|SURR_ON
mdefine_line|#define SURR_ON&t;&t;0x0010
DECL|macro|CENTER_LFE_ON
mdefine_line|#define CENTER_LFE_ON&t;0x0020
DECL|macro|VOL_MUTED
mdefine_line|#define VOL_MUTED&t;0x8000
multiline_comment|/* the 810&squot;s array of pointers to data buffers */
DECL|struct|sg_item
r_struct
id|sg_item
(brace
DECL|macro|BUSADDR_MASK
mdefine_line|#define BUSADDR_MASK&t;0xFFFFFFFE
DECL|member|busaddr
id|u32
id|busaddr
suffix:semicolon
DECL|macro|CON_IOC
mdefine_line|#define CON_IOC &t;0x80000000 /* interrupt on completion */
DECL|macro|CON_BUFPAD
mdefine_line|#define CON_BUFPAD&t;0x40000000 /* pad underrun with last sample, else 0 */
DECL|macro|CON_BUFLEN_MASK
mdefine_line|#define CON_BUFLEN_MASK&t;0x0000ffff /* buffer length in samples */
DECL|member|control
id|u32
id|control
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* an instance of the i810 channel */
DECL|macro|SG_LEN
mdefine_line|#define SG_LEN 32
DECL|struct|i810_channel
r_struct
id|i810_channel
(brace
multiline_comment|/* these sg guys should probably be allocated&n;&t;   seperately as nocache. Must be 8 byte aligned */
DECL|member|sg
r_struct
id|sg_item
id|sg
(braket
id|SG_LEN
)braket
suffix:semicolon
multiline_comment|/* 32*8 */
DECL|member|offset
id|u32
id|offset
suffix:semicolon
multiline_comment|/* 4 */
DECL|member|port
id|u32
id|port
suffix:semicolon
multiline_comment|/* 4 */
DECL|member|used
id|u32
id|used
suffix:semicolon
DECL|member|num
id|u32
id|num
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * we have 3 seperate dma engines.  pcm in, pcm out, and mic.&n; * each dma engine has controlling registers.  These goofy&n; * names are from the datasheet, but make it easy to write&n; * code while leafing through it.&n; */
DECL|macro|ENUM_ENGINE
mdefine_line|#define ENUM_ENGINE(PRE,DIG) &t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;enum {&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;PRE##_BDBAR =&t;0x##DIG##0,&t;&t;/* Buffer Descriptor list Base Address */&t;&bslash;&n;&t;PRE##_CIV =&t;0x##DIG##4,&t;&t;/* Current Index Value */&t;&t;&t;&bslash;&n;&t;PRE##_LVI =&t;0x##DIG##5,&t;&t;/* Last Valid Index */&t;&t;&t;&t;&bslash;&n;&t;PRE##_SR =&t;0x##DIG##6,&t;&t;/* Status Register */&t;&t;&t;&t;&bslash;&n;&t;PRE##_PICB =&t;0x##DIG##8,&t;&t;/* Position In Current Buffer */&t;&t;&bslash;&n;&t;PRE##_PIV =&t;0x##DIG##a,&t;&t;/* Prefetched Index Value */&t;&t;&t;&bslash;&n;&t;PRE##_CR =&t;0x##DIG##b&t;&t;/* Control Register */&t;&t;&t;&t;&bslash;&n;}
id|ENUM_ENGINE
c_func
(paren
id|OFF
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Offsets */
id|ENUM_ENGINE
c_func
(paren
id|PI
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* PCM In */
id|ENUM_ENGINE
c_func
(paren
id|PO
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* PCM Out */
id|ENUM_ENGINE
c_func
(paren
id|MC
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Mic In */
r_enum
(brace
DECL|enumerator|GLOB_CNT
id|GLOB_CNT
op_assign
l_int|0x2c
comma
multiline_comment|/* Global Control */
DECL|enumerator|GLOB_STA
id|GLOB_STA
op_assign
l_int|0x30
comma
multiline_comment|/* Global Status */
DECL|enumerator|CAS
id|CAS
op_assign
l_int|0x34
multiline_comment|/* Codec Write Semaphore Register */
)brace
suffix:semicolon
multiline_comment|/* interrupts for a dma engine */
DECL|macro|DMA_INT_FIFO
mdefine_line|#define DMA_INT_FIFO&t;&t;(1&lt;&lt;4)  /* fifo under/over flow */
DECL|macro|DMA_INT_COMPLETE
mdefine_line|#define DMA_INT_COMPLETE&t;(1&lt;&lt;3)  /* buffer read/write complete and ioc set */
DECL|macro|DMA_INT_LVI
mdefine_line|#define DMA_INT_LVI&t;&t;(1&lt;&lt;2)  /* last valid done */
DECL|macro|DMA_INT_CELV
mdefine_line|#define DMA_INT_CELV&t;&t;(1&lt;&lt;1)  /* last valid is current */
DECL|macro|DMA_INT_DCH
mdefine_line|#define DMA_INT_DCH&t;&t;(1)&t;/* DMA Controller Halted (happens on LVI interrupts) */
DECL|macro|DMA_INT_MASK
mdefine_line|#define DMA_INT_MASK (DMA_INT_FIFO|DMA_INT_COMPLETE|DMA_INT_LVI)
multiline_comment|/* interrupts for the whole chip */
DECL|macro|INT_SEC
mdefine_line|#define INT_SEC&t;&t;(1&lt;&lt;11)
DECL|macro|INT_PRI
mdefine_line|#define INT_PRI&t;&t;(1&lt;&lt;10)
DECL|macro|INT_MC
mdefine_line|#define INT_MC&t;&t;(1&lt;&lt;7)
DECL|macro|INT_PO
mdefine_line|#define INT_PO&t;&t;(1&lt;&lt;6)
DECL|macro|INT_PI
mdefine_line|#define INT_PI&t;&t;(1&lt;&lt;5)
DECL|macro|INT_MO
mdefine_line|#define INT_MO&t;&t;(1&lt;&lt;2)
DECL|macro|INT_NI
mdefine_line|#define INT_NI&t;&t;(1&lt;&lt;1)
DECL|macro|INT_GPI
mdefine_line|#define INT_GPI&t;&t;(1&lt;&lt;0)
DECL|macro|INT_MASK
mdefine_line|#define INT_MASK (INT_SEC|INT_PRI|INT_MC|INT_PO|INT_PI|INT_MO|INT_NI|INT_GPI)
DECL|macro|DRIVER_VERSION
mdefine_line|#define DRIVER_VERSION &quot;0.04&quot;
multiline_comment|/* magic numbers to protect our data structures */
DECL|macro|I810_CARD_MAGIC
mdefine_line|#define I810_CARD_MAGIC&t;&t;0x5072696E /* &quot;Prin&quot; */
DECL|macro|I810_STATE_MAGIC
mdefine_line|#define I810_STATE_MAGIC&t;0x63657373 /* &quot;cess&quot; */
DECL|macro|I810_DMA_MASK
mdefine_line|#define I810_DMA_MASK&t;&t;0xffffffff /* DMA buffer mask for pci_alloc_consist */
DECL|macro|NR_HW_CH
mdefine_line|#define NR_HW_CH&t;&t;3
multiline_comment|/* maxinum number of AC97 codecs connected, AC97 2.0 defined 4 */
DECL|macro|NR_AC97
mdefine_line|#define NR_AC97&t;&t;2
multiline_comment|/* Please note that an 8bit mono stream is not valid on this card, you must have a 16bit */
multiline_comment|/* stream at a minimum for this card to be happy */
DECL|variable|sample_size
r_static
r_const
r_int
id|sample_size
(braket
)braket
op_assign
(brace
l_int|1
comma
l_int|2
comma
l_int|2
comma
l_int|4
)brace
suffix:semicolon
multiline_comment|/* Samples are 16bit values, so we are shifting to a word, not to a byte, hence shift */
multiline_comment|/* values are one less than might be expected */
DECL|variable|sample_shift
r_static
r_const
r_int
id|sample_shift
(braket
)braket
op_assign
(brace
op_minus
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|1
)brace
suffix:semicolon
r_enum
(brace
DECL|enumerator|ICH82801AA
id|ICH82801AA
op_assign
l_int|0
comma
DECL|enumerator|ICH82901AB
id|ICH82901AB
comma
DECL|enumerator|INTEL440MX
id|INTEL440MX
comma
DECL|enumerator|INTELICH2
id|INTELICH2
comma
DECL|enumerator|INTELICH3
id|INTELICH3
)brace
suffix:semicolon
DECL|variable|card_names
r_static
r_char
op_star
id|card_names
(braket
)braket
op_assign
(brace
l_string|&quot;Intel ICH 82801AA&quot;
comma
l_string|&quot;Intel ICH 82901AB&quot;
comma
l_string|&quot;Intel 440MX&quot;
comma
l_string|&quot;Intel ICH2&quot;
comma
l_string|&quot;Intel ICH3&quot;
)brace
suffix:semicolon
DECL|variable|__initdata
r_static
r_struct
id|pci_device_id
id|i810_pci_tbl
(braket
)braket
id|__initdata
op_assign
(brace
(brace
id|PCI_VENDOR_ID_INTEL
comma
id|PCI_DEVICE_ID_INTEL_82801
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|ICH82801AA
)brace
comma
(brace
id|PCI_VENDOR_ID_INTEL
comma
id|PCI_DEVICE_ID_INTEL_82901
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|ICH82901AB
)brace
comma
(brace
id|PCI_VENDOR_ID_INTEL
comma
id|PCI_DEVICE_ID_INTEL_440MX
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|INTEL440MX
)brace
comma
(brace
id|PCI_VENDOR_ID_INTEL
comma
id|PCI_DEVICE_ID_INTEL_ICH2
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|INTELICH2
)brace
comma
(brace
id|PCI_VENDOR_ID_INTEL
comma
id|PCI_DEVICE_ID_INTEL_ICH3
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|INTELICH3
)brace
comma
(brace
l_int|0
comma
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
(paren
id|pci
comma
id|i810_pci_tbl
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PM
DECL|macro|PM_SUSPENDED
mdefine_line|#define PM_SUSPENDED(card) (card-&gt;pm_suspended)
macro_line|#else
DECL|macro|PM_SUSPENDED
mdefine_line|#define PM_SUSPENDED(card) (0)
macro_line|#endif
multiline_comment|/* &quot;software&quot; or virtual channel, an instance of opened /dev/dsp */
DECL|struct|i810_state
r_struct
id|i810_state
(brace
DECL|member|magic
r_int
r_int
id|magic
suffix:semicolon
DECL|member|card
r_struct
id|i810_card
op_star
id|card
suffix:semicolon
multiline_comment|/* Card info */
multiline_comment|/* single open lock mechanism, only used for recording */
DECL|member|open_sem
r_struct
id|semaphore
id|open_sem
suffix:semicolon
DECL|member|open_wait
id|wait_queue_head_t
id|open_wait
suffix:semicolon
multiline_comment|/* file mode */
DECL|member|open_mode
id|mode_t
id|open_mode
suffix:semicolon
multiline_comment|/* virtual channel number */
DECL|member|virt
r_int
id|virt
suffix:semicolon
macro_line|#ifdef CONFIG_PM
DECL|member|pm_saved_dac_rate
DECL|member|pm_saved_adc_rate
r_int
r_int
id|pm_saved_dac_rate
comma
id|pm_saved_adc_rate
suffix:semicolon
macro_line|#endif
DECL|struct|dmabuf
r_struct
id|dmabuf
(brace
multiline_comment|/* wave sample stuff */
DECL|member|rate
r_int
r_int
id|rate
suffix:semicolon
DECL|member|fmt
DECL|member|enable
DECL|member|trigger
r_int
r_char
id|fmt
comma
id|enable
comma
id|trigger
suffix:semicolon
multiline_comment|/* hardware channel */
DECL|member|read_channel
r_struct
id|i810_channel
op_star
id|read_channel
suffix:semicolon
DECL|member|write_channel
r_struct
id|i810_channel
op_star
id|write_channel
suffix:semicolon
multiline_comment|/* OSS buffer management stuff */
DECL|member|rawbuf
r_void
op_star
id|rawbuf
suffix:semicolon
DECL|member|dma_handle
id|dma_addr_t
id|dma_handle
suffix:semicolon
DECL|member|buforder
r_int
id|buforder
suffix:semicolon
DECL|member|numfrag
r_int
id|numfrag
suffix:semicolon
DECL|member|fragshift
r_int
id|fragshift
suffix:semicolon
multiline_comment|/* our buffer acts like a circular ring */
DECL|member|hwptr
r_int
id|hwptr
suffix:semicolon
multiline_comment|/* where dma last started, updated by update_ptr */
DECL|member|swptr
r_int
id|swptr
suffix:semicolon
multiline_comment|/* where driver last clear/filled, updated by read/write */
DECL|member|count
r_int
id|count
suffix:semicolon
multiline_comment|/* bytes to be consumed or been generated by dma machine */
DECL|member|total_bytes
r_int
id|total_bytes
suffix:semicolon
multiline_comment|/* total bytes dmaed by hardware */
DECL|member|error
r_int
id|error
suffix:semicolon
multiline_comment|/* number of over/underruns */
DECL|member|wait
id|wait_queue_head_t
id|wait
suffix:semicolon
multiline_comment|/* put process on wait queue when no more space in buffer */
multiline_comment|/* redundant, but makes calculations easier */
multiline_comment|/* what the hardware uses */
DECL|member|dmasize
r_int
id|dmasize
suffix:semicolon
DECL|member|fragsize
r_int
id|fragsize
suffix:semicolon
DECL|member|fragsamples
r_int
id|fragsamples
suffix:semicolon
multiline_comment|/* what we tell the user to expect */
DECL|member|userfrags
r_int
id|userfrags
suffix:semicolon
DECL|member|userfragsize
r_int
id|userfragsize
suffix:semicolon
multiline_comment|/* OSS stuff */
DECL|member|mapped
r_int
id|mapped
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ready
r_int
id|ready
suffix:colon
l_int|1
suffix:semicolon
DECL|member|update_flag
r_int
id|update_flag
suffix:semicolon
DECL|member|ossfragsize
r_int
id|ossfragsize
suffix:semicolon
DECL|member|ossmaxfrags
r_int
id|ossmaxfrags
suffix:semicolon
DECL|member|subdivision
r_int
id|subdivision
suffix:semicolon
DECL|member|dmabuf
)brace
id|dmabuf
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|i810_card
r_struct
id|i810_card
(brace
DECL|member|channel
r_struct
id|i810_channel
id|channel
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|magic
r_int
r_int
id|magic
suffix:semicolon
multiline_comment|/* We keep i810 cards in a linked list */
DECL|member|next
r_struct
id|i810_card
op_star
id|next
suffix:semicolon
multiline_comment|/* The i810 has a certain amount of cross channel interaction&n;&t;   so we use a single per card lock */
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
multiline_comment|/* PCI device stuff */
DECL|member|pci_dev
r_struct
id|pci_dev
op_star
id|pci_dev
suffix:semicolon
DECL|member|pci_id
id|u16
id|pci_id
suffix:semicolon
macro_line|#ifdef CONFIG_PM&t;
DECL|member|pm_suspended
id|u16
id|pm_suspended
suffix:semicolon
DECL|member|pm_save_state
id|u32
id|pm_save_state
(braket
l_int|64
op_div
r_sizeof
(paren
id|u32
)paren
)braket
suffix:semicolon
DECL|member|pm_saved_mixer_settings
r_int
id|pm_saved_mixer_settings
(braket
id|SOUND_MIXER_NRDEVICES
)braket
(braket
id|NR_AC97
)braket
suffix:semicolon
macro_line|#endif
multiline_comment|/* soundcore stuff */
DECL|member|dev_audio
r_int
id|dev_audio
suffix:semicolon
multiline_comment|/* structures for abstraction of hardware facilities, codecs, banks and channels*/
DECL|member|ac97_codec
r_struct
id|ac97_codec
op_star
id|ac97_codec
(braket
id|NR_AC97
)braket
suffix:semicolon
DECL|member|states
r_struct
id|i810_state
op_star
id|states
(braket
id|NR_HW_CH
)braket
suffix:semicolon
DECL|member|ac97_features
id|u16
id|ac97_features
suffix:semicolon
DECL|member|ac97_status
id|u16
id|ac97_status
suffix:semicolon
DECL|member|channels
id|u16
id|channels
suffix:semicolon
multiline_comment|/* hardware resources */
DECL|member|iobase
r_int
r_int
id|iobase
suffix:semicolon
DECL|member|ac97base
r_int
r_int
id|ac97base
suffix:semicolon
DECL|member|irq
id|u32
id|irq
suffix:semicolon
multiline_comment|/* Function support */
DECL|member|alloc_pcm_channel
r_struct
id|i810_channel
op_star
(paren
op_star
id|alloc_pcm_channel
)paren
(paren
r_struct
id|i810_card
op_star
)paren
suffix:semicolon
DECL|member|alloc_rec_pcm_channel
r_struct
id|i810_channel
op_star
(paren
op_star
id|alloc_rec_pcm_channel
)paren
(paren
r_struct
id|i810_card
op_star
)paren
suffix:semicolon
DECL|member|alloc_rec_mic_channel
r_struct
id|i810_channel
op_star
(paren
op_star
id|alloc_rec_mic_channel
)paren
(paren
r_struct
id|i810_card
op_star
)paren
suffix:semicolon
DECL|member|free_pcm_channel
r_void
(paren
op_star
id|free_pcm_channel
)paren
(paren
r_struct
id|i810_card
op_star
comma
r_int
id|chan
)paren
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|devs
r_static
r_struct
id|i810_card
op_star
id|devs
op_assign
l_int|NULL
suffix:semicolon
r_static
r_int
id|i810_open_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|i810_ioctl_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
DECL|function|ld2
r_static
r_inline
r_int
id|ld2
c_func
(paren
r_int
r_int
id|x
)paren
(brace
r_int
id|r
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|x
op_ge
l_int|0x10000
)paren
(brace
id|x
op_rshift_assign
l_int|16
suffix:semicolon
id|r
op_add_assign
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_ge
l_int|0x100
)paren
(brace
id|x
op_rshift_assign
l_int|8
suffix:semicolon
id|r
op_add_assign
l_int|8
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_ge
l_int|0x10
)paren
(brace
id|x
op_rshift_assign
l_int|4
suffix:semicolon
id|r
op_add_assign
l_int|4
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_ge
l_int|4
)paren
(brace
id|x
op_rshift_assign
l_int|2
suffix:semicolon
id|r
op_add_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_ge
l_int|2
)paren
id|r
op_increment
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
r_static
id|u16
id|i810_ac97_get
c_func
(paren
r_struct
id|ac97_codec
op_star
id|dev
comma
id|u8
id|reg
)paren
suffix:semicolon
r_static
r_void
id|i810_ac97_set
c_func
(paren
r_struct
id|ac97_codec
op_star
id|dev
comma
id|u8
id|reg
comma
id|u16
id|data
)paren
suffix:semicolon
DECL|function|i810_alloc_pcm_channel
r_static
r_struct
id|i810_channel
op_star
id|i810_alloc_pcm_channel
c_func
(paren
r_struct
id|i810_card
op_star
id|card
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;channel
(braket
l_int|1
)braket
dot
id|used
op_eq
l_int|1
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|card-&gt;channel
(braket
l_int|1
)braket
dot
id|used
op_assign
l_int|1
suffix:semicolon
r_return
op_amp
id|card-&gt;channel
(braket
l_int|1
)braket
suffix:semicolon
)brace
DECL|function|i810_alloc_rec_pcm_channel
r_static
r_struct
id|i810_channel
op_star
id|i810_alloc_rec_pcm_channel
c_func
(paren
r_struct
id|i810_card
op_star
id|card
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;channel
(braket
l_int|0
)braket
dot
id|used
op_eq
l_int|1
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|card-&gt;channel
(braket
l_int|0
)braket
dot
id|used
op_assign
l_int|1
suffix:semicolon
r_return
op_amp
id|card-&gt;channel
(braket
l_int|0
)braket
suffix:semicolon
)brace
DECL|function|i810_alloc_rec_mic_channel
r_static
r_struct
id|i810_channel
op_star
id|i810_alloc_rec_mic_channel
c_func
(paren
r_struct
id|i810_card
op_star
id|card
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;channel
(braket
l_int|2
)braket
dot
id|used
op_eq
l_int|1
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|card-&gt;channel
(braket
l_int|2
)braket
dot
id|used
op_assign
l_int|1
suffix:semicolon
r_return
op_amp
id|card-&gt;channel
(braket
l_int|2
)braket
suffix:semicolon
)brace
DECL|function|i810_free_pcm_channel
r_static
r_void
id|i810_free_pcm_channel
c_func
(paren
r_struct
id|i810_card
op_star
id|card
comma
r_int
id|channel
)paren
(brace
id|card-&gt;channel
(braket
id|channel
)braket
dot
id|used
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|i810_valid_spdif_rate
r_static
r_int
id|i810_valid_spdif_rate
(paren
r_struct
id|ac97_codec
op_star
id|codec
comma
r_int
id|rate
)paren
(brace
r_int
r_int
id|id
op_assign
l_int|0L
suffix:semicolon
id|id
op_assign
(paren
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_VENDOR_ID1
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
id|id
op_or_assign
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_VENDOR_ID2
)paren
op_amp
l_int|0xffff
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
(paren
l_string|&quot;i810_audio: codec = %s, codec_id = 0x%08lx&bslash;n&quot;
comma
id|codec-&gt;name
comma
id|id
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|id
)paren
(brace
r_case
l_int|0x41445361
suffix:colon
multiline_comment|/* AD1886 */
r_if
c_cond
(paren
id|rate
op_eq
l_int|48000
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* all other codecs, until we know otherwiae */
r_if
c_cond
(paren
id|rate
op_eq
l_int|48000
op_logical_or
id|rate
op_eq
l_int|44100
op_logical_or
id|rate
op_eq
l_int|32000
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* i810_set_spdif_output&n; * &n; *  Configure the S/PDIF output transmitter. When we turn on&n; *  S/PDIF, we turn off the analog output. This may not be&n; *  the right thing to do.&n; *&n; *  Assumptions:&n; *     The DSP sample rate must already be set to a supported&n; *     S/PDIF rate (32kHz, 44.1kHz, or 48kHz) or we abort.&n; */
DECL|function|i810_set_spdif_output
r_static
r_void
id|i810_set_spdif_output
c_func
(paren
r_struct
id|i810_state
op_star
id|state
comma
r_int
id|slots
comma
r_int
id|rate
)paren
(brace
r_int
id|vol
suffix:semicolon
r_int
id|aud_reg
suffix:semicolon
r_struct
id|ac97_codec
op_star
id|codec
op_assign
id|state-&gt;card-&gt;ac97_codec
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|state-&gt;card-&gt;ac97_features
op_amp
l_int|4
)paren
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i810_audio: S/PDIF transmitter not available.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|state-&gt;card-&gt;ac97_status
op_and_assign
op_complement
id|SPDIF_ON
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|slots
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Turn off S/PDIF */
id|aud_reg
op_assign
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
)paren
suffix:semicolon
id|i810_ac97_set
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
comma
(paren
id|aud_reg
op_amp
op_complement
id|AC97_EA_SPDIF
)paren
)paren
suffix:semicolon
multiline_comment|/* If the volume wasn&squot;t muted before we turned on S/PDIF, unmute it */
r_if
c_cond
(paren
op_logical_neg
(paren
id|state-&gt;card-&gt;ac97_status
op_amp
id|VOL_MUTED
)paren
)paren
(brace
id|aud_reg
op_assign
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_MASTER_VOL_STEREO
)paren
suffix:semicolon
id|i810_ac97_set
c_func
(paren
id|codec
comma
id|AC97_MASTER_VOL_STEREO
comma
(paren
id|aud_reg
op_amp
op_complement
id|VOL_MUTED
)paren
)paren
suffix:semicolon
)brace
id|state-&gt;card-&gt;ac97_status
op_and_assign
op_complement
(paren
id|VOL_MUTED
op_or
id|SPDIF_ON
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|vol
op_assign
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_MASTER_VOL_STEREO
)paren
suffix:semicolon
id|state-&gt;card-&gt;ac97_status
op_assign
id|vol
op_amp
id|VOL_MUTED
suffix:semicolon
multiline_comment|/* Set S/PDIF transmitter sample rate */
id|aud_reg
op_assign
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_SPDIF_CONTROL
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|rate
)paren
(brace
r_case
l_int|32000
suffix:colon
id|aud_reg
op_assign
(paren
id|aud_reg
op_amp
id|AC97_SC_SPSR_MASK
)paren
op_or
id|AC97_SC_SPSR_32K
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|44100
suffix:colon
id|aud_reg
op_assign
(paren
id|aud_reg
op_amp
id|AC97_SC_SPSR_MASK
)paren
op_or
id|AC97_SC_SPSR_44K
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|48000
suffix:colon
id|aud_reg
op_assign
(paren
id|aud_reg
op_amp
id|AC97_SC_SPSR_MASK
)paren
op_or
id|AC97_SC_SPSR_48K
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i810_audio: %d sample rate not supported by S/PDIF.&bslash;n&quot;
comma
id|rate
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* turn off S/PDIF */
id|aud_reg
op_assign
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
)paren
suffix:semicolon
id|i810_ac97_set
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
comma
(paren
id|aud_reg
op_amp
op_complement
id|AC97_EA_SPDIF
)paren
)paren
suffix:semicolon
id|state-&gt;card-&gt;ac97_status
op_and_assign
op_complement
id|SPDIF_ON
suffix:semicolon
r_return
suffix:semicolon
)brace
id|i810_ac97_set
c_func
(paren
id|codec
comma
id|AC97_SPDIF_CONTROL
comma
id|aud_reg
)paren
suffix:semicolon
id|aud_reg
op_assign
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
)paren
suffix:semicolon
id|aud_reg
op_assign
(paren
id|aud_reg
op_amp
id|AC97_EA_SLOT_MASK
)paren
op_or
id|slots
op_or
id|AC97_EA_VRA
op_or
id|AC97_EA_SPDIF
suffix:semicolon
id|i810_ac97_set
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
comma
id|aud_reg
)paren
suffix:semicolon
id|state-&gt;card-&gt;ac97_status
op_or_assign
id|SPDIF_ON
suffix:semicolon
multiline_comment|/* Check to make sure the configuration is valid */
id|aud_reg
op_assign
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|aud_reg
op_amp
l_int|0x0400
)paren
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i810_audio: S/PDIF transmitter configuration not valid (0x%04x).&bslash;n&quot;
comma
id|aud_reg
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* turn off S/PDIF */
id|i810_ac97_set
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
comma
(paren
id|aud_reg
op_amp
op_complement
id|AC97_EA_SPDIF
)paren
)paren
suffix:semicolon
id|state-&gt;card-&gt;ac97_status
op_and_assign
op_complement
id|SPDIF_ON
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Mute the analog output */
multiline_comment|/* Should this only mute the PCM volume??? */
id|i810_ac97_set
c_func
(paren
id|codec
comma
id|AC97_MASTER_VOL_STEREO
comma
(paren
id|vol
op_or
id|VOL_MUTED
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* i810_set_dac_channels&n; *&n; *  Configure the codec&squot;s multi-channel DACs&n; *&n; *  The logic is backwards. Setting the bit to 1 turns off the DAC. &n; *&n; *  What about the ICH? We currently configure it using the&n; *  SNDCTL_DSP_CHANNELS ioctl.  If we&squot;re turnning on the DAC, &n; *  does that imply that we want the ICH set to support&n; *  these channels?&n; *  &n; *  TODO:&n; *    vailidate that the codec really supports these DACs&n; *    before turning them on. &n; */
DECL|function|i810_set_dac_channels
r_static
r_void
id|i810_set_dac_channels
c_func
(paren
r_struct
id|i810_state
op_star
id|state
comma
r_int
id|channel
)paren
(brace
r_int
id|aud_reg
suffix:semicolon
r_struct
id|ac97_codec
op_star
id|codec
op_assign
id|state-&gt;card-&gt;ac97_codec
(braket
l_int|0
)braket
suffix:semicolon
id|aud_reg
op_assign
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
)paren
suffix:semicolon
id|aud_reg
op_or_assign
id|AC97_EA_PRI
op_or
id|AC97_EA_PRJ
op_or
id|AC97_EA_PRK
suffix:semicolon
id|state-&gt;card-&gt;ac97_status
op_and_assign
op_complement
(paren
id|SURR_ON
op_or
id|CENTER_LFE_ON
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|channel
)paren
(brace
r_case
l_int|2
suffix:colon
multiline_comment|/* always enabled */
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|aud_reg
op_and_assign
op_complement
id|AC97_EA_PRJ
suffix:semicolon
id|state-&gt;card-&gt;ac97_status
op_or_assign
id|SURR_ON
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|aud_reg
op_and_assign
op_complement
(paren
id|AC97_EA_PRJ
op_or
id|AC97_EA_PRI
op_or
id|AC97_EA_PRK
)paren
suffix:semicolon
id|state-&gt;card-&gt;ac97_status
op_or_assign
id|SURR_ON
op_or
id|CENTER_LFE_ON
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|i810_ac97_set
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
comma
id|aud_reg
)paren
suffix:semicolon
)brace
multiline_comment|/* set playback sample rate */
DECL|function|i810_set_dac_rate
r_static
r_int
r_int
id|i810_set_dac_rate
c_func
(paren
r_struct
id|i810_state
op_star
id|state
comma
r_int
r_int
id|rate
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|u32
id|new_rate
suffix:semicolon
r_struct
id|ac97_codec
op_star
id|codec
op_assign
id|state-&gt;card-&gt;ac97_codec
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|state-&gt;card-&gt;ac97_features
op_amp
l_int|0x0001
)paren
)paren
(brace
id|dmabuf-&gt;rate
op_assign
id|clocking
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Asked for %d Hz, but ac97_features says we only do %dHz.  Sorry!&bslash;n&quot;
comma
id|rate
comma
id|clocking
)paren
suffix:semicolon
macro_line|#endif&t;&t;       
r_return
id|clocking
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rate
OG
l_int|48000
)paren
id|rate
op_assign
l_int|48000
suffix:semicolon
r_if
c_cond
(paren
id|rate
OL
l_int|8000
)paren
id|rate
op_assign
l_int|8000
suffix:semicolon
id|dmabuf-&gt;rate
op_assign
id|rate
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Adjust for misclocked crap&n;&t; */
id|rate
op_assign
(paren
id|rate
op_star
id|clocking
)paren
op_div
l_int|48000
suffix:semicolon
r_if
c_cond
(paren
id|strict_clocking
op_logical_and
id|rate
OL
l_int|8000
)paren
(brace
id|rate
op_assign
l_int|8000
suffix:semicolon
id|dmabuf-&gt;rate
op_assign
(paren
id|rate
op_star
l_int|48000
)paren
op_div
id|clocking
suffix:semicolon
)brace
id|new_rate
op_assign
id|ac97_set_dac_rate
c_func
(paren
id|codec
comma
id|rate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_rate
op_ne
id|rate
)paren
(brace
id|dmabuf-&gt;rate
op_assign
(paren
id|new_rate
op_star
l_int|48000
)paren
op_div
id|clocking
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;i810_audio: called i810_set_dac_rate : asked for %d, got %d&bslash;n&quot;
comma
id|rate
comma
id|dmabuf-&gt;rate
)paren
suffix:semicolon
macro_line|#endif
id|rate
op_assign
id|new_rate
suffix:semicolon
r_return
id|dmabuf-&gt;rate
suffix:semicolon
)brace
multiline_comment|/* set recording sample rate */
DECL|function|i810_set_adc_rate
r_static
r_int
r_int
id|i810_set_adc_rate
c_func
(paren
r_struct
id|i810_state
op_star
id|state
comma
r_int
r_int
id|rate
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|u32
id|new_rate
suffix:semicolon
r_struct
id|ac97_codec
op_star
id|codec
op_assign
id|state-&gt;card-&gt;ac97_codec
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|state-&gt;card-&gt;ac97_features
op_amp
l_int|0x0001
)paren
)paren
(brace
id|dmabuf-&gt;rate
op_assign
id|clocking
suffix:semicolon
r_return
id|clocking
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rate
OG
l_int|48000
)paren
id|rate
op_assign
l_int|48000
suffix:semicolon
r_if
c_cond
(paren
id|rate
OL
l_int|8000
)paren
id|rate
op_assign
l_int|8000
suffix:semicolon
id|dmabuf-&gt;rate
op_assign
id|rate
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Adjust for misclocked crap&n;&t; */
id|rate
op_assign
(paren
id|rate
op_star
id|clocking
)paren
op_div
l_int|48000
suffix:semicolon
r_if
c_cond
(paren
id|strict_clocking
op_logical_and
id|rate
OL
l_int|8000
)paren
(brace
id|rate
op_assign
l_int|8000
suffix:semicolon
id|dmabuf-&gt;rate
op_assign
(paren
id|rate
op_star
l_int|48000
)paren
op_div
id|clocking
suffix:semicolon
)brace
id|new_rate
op_assign
id|ac97_set_adc_rate
c_func
(paren
id|codec
comma
id|rate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_rate
op_ne
id|rate
)paren
(brace
id|dmabuf-&gt;rate
op_assign
(paren
id|new_rate
op_star
l_int|48000
)paren
op_div
id|clocking
suffix:semicolon
id|rate
op_assign
id|new_rate
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;i810_audio: called i810_set_adc_rate : rate = %d/%d&bslash;n&quot;
comma
id|dmabuf-&gt;rate
comma
id|rate
)paren
suffix:semicolon
macro_line|#endif
r_return
id|dmabuf-&gt;rate
suffix:semicolon
)brace
multiline_comment|/* get current playback/recording dma buffer pointer (byte offset from LBA),&n;   called with spinlock held! */
DECL|function|i810_get_dma_addr
r_static
r_inline
r_int
id|i810_get_dma_addr
c_func
(paren
r_struct
id|i810_state
op_star
id|state
comma
r_int
id|rec
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|civ
comma
id|offset
suffix:semicolon
r_struct
id|i810_channel
op_star
id|c
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;enable
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rec
)paren
id|c
op_assign
id|dmabuf-&gt;read_channel
suffix:semicolon
r_else
id|c
op_assign
id|dmabuf-&gt;write_channel
suffix:semicolon
r_do
(brace
id|civ
op_assign
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|c-&gt;port
op_plus
id|OFF_CIV
)paren
suffix:semicolon
id|offset
op_assign
(paren
id|civ
op_plus
l_int|1
)paren
op_star
id|dmabuf-&gt;fragsize
op_minus
l_int|2
op_star
id|inw
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|c-&gt;port
op_plus
id|OFF_PICB
)paren
suffix:semicolon
multiline_comment|/* CIV changed before we read PICB (very seldom) ?&n;&t;&t; * then PICB was rubbish, so try again */
)brace
r_while
c_loop
(paren
id|civ
op_ne
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|c-&gt;port
op_plus
id|OFF_CIV
)paren
)paren
suffix:semicolon
r_return
id|offset
suffix:semicolon
)brace
singleline_comment|//static void resync_dma_ptrs(struct i810_state *state, int rec)
singleline_comment|//{
singleline_comment|//&t;struct dmabuf *dmabuf = &amp;state-&gt;dmabuf;
singleline_comment|//&t;struct i810_channel *c;
singleline_comment|//&t;int offset;
singleline_comment|//
singleline_comment|//&t;if(rec) {
singleline_comment|//&t;&t;c = dmabuf-&gt;read_channel;
singleline_comment|//&t;} else {
singleline_comment|//&t;&t;c = dmabuf-&gt;write_channel;
singleline_comment|//&t;}
singleline_comment|//&t;if(c==NULL)
singleline_comment|//&t;&t;return;
singleline_comment|//&t;offset = inb(state-&gt;card-&gt;iobase+c-&gt;port+OFF_CIV);
singleline_comment|//&t;if(offset == inb(state-&gt;card-&gt;iobase+c-&gt;port+OFF_LVI))
singleline_comment|//&t;&t;offset++;
singleline_comment|//&t;offset *= dmabuf-&gt;fragsize;
singleline_comment|//&t;
singleline_comment|//&t;dmabuf-&gt;hwptr=dmabuf-&gt;swptr = offset;
singleline_comment|//}
multiline_comment|/* Stop recording (lock held) */
DECL|function|__stop_adc
r_static
r_inline
r_void
id|__stop_adc
c_func
(paren
r_struct
id|i810_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|i810_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
id|dmabuf-&gt;enable
op_and_assign
op_complement
id|ADC_RUNNING
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|card-&gt;iobase
op_plus
id|PI_CR
)paren
suffix:semicolon
singleline_comment|// wait for the card to acknowledge shutdown
r_while
c_loop
(paren
id|inb
c_func
(paren
id|card-&gt;iobase
op_plus
id|PI_CR
)paren
op_ne
l_int|0
)paren
(brace
suffix:semicolon
)brace
singleline_comment|// now clear any latent interrupt bits (like the halt bit)
id|outb
c_func
(paren
id|inb
c_func
(paren
id|card-&gt;iobase
op_plus
id|PI_SR
)paren
comma
id|card-&gt;iobase
op_plus
id|PI_SR
)paren
suffix:semicolon
id|outl
c_func
(paren
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|GLOB_STA
)paren
op_amp
id|INT_PI
comma
id|card-&gt;iobase
op_plus
id|GLOB_STA
)paren
suffix:semicolon
)brace
DECL|function|stop_adc
r_static
r_void
id|stop_adc
c_func
(paren
r_struct
id|i810_state
op_star
id|state
)paren
(brace
r_struct
id|i810_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|start_adc
r_static
r_void
id|start_adc
c_func
(paren
r_struct
id|i810_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|i810_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
id|dmabuf-&gt;dmasize
op_logical_and
id|dmabuf-&gt;ready
op_logical_and
op_logical_neg
id|dmabuf-&gt;enable
op_logical_and
(paren
id|dmabuf-&gt;trigger
op_amp
id|PCM_ENABLE_INPUT
)paren
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|dmabuf-&gt;enable
op_or_assign
id|ADC_RUNNING
suffix:semicolon
id|outb
c_func
(paren
(paren
l_int|1
op_lshift
l_int|4
)paren
op_or
(paren
l_int|1
op_lshift
l_int|2
)paren
op_or
l_int|1
comma
id|card-&gt;iobase
op_plus
id|PI_CR
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* stop playback (lock held) */
DECL|function|__stop_dac
r_static
r_inline
r_void
id|__stop_dac
c_func
(paren
r_struct
id|i810_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|i810_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
id|dmabuf-&gt;enable
op_and_assign
op_complement
id|DAC_RUNNING
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|card-&gt;iobase
op_plus
id|PO_CR
)paren
suffix:semicolon
singleline_comment|// wait for the card to acknowledge shutdown
r_while
c_loop
(paren
id|inb
c_func
(paren
id|card-&gt;iobase
op_plus
id|PO_CR
)paren
op_ne
l_int|0
)paren
(brace
suffix:semicolon
)brace
singleline_comment|// now clear any latent interrupt bits (like the halt bit)
id|outb
c_func
(paren
id|inb
c_func
(paren
id|card-&gt;iobase
op_plus
id|PO_SR
)paren
comma
id|card-&gt;iobase
op_plus
id|PO_SR
)paren
suffix:semicolon
id|outl
c_func
(paren
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|GLOB_STA
)paren
op_amp
id|INT_PO
comma
id|card-&gt;iobase
op_plus
id|GLOB_STA
)paren
suffix:semicolon
)brace
DECL|function|stop_dac
r_static
r_void
id|stop_dac
c_func
(paren
r_struct
id|i810_state
op_star
id|state
)paren
(brace
r_struct
id|i810_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|start_dac
r_static
r_void
id|start_dac
c_func
(paren
r_struct
id|i810_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|i810_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OG
l_int|0
op_logical_and
id|dmabuf-&gt;ready
op_logical_and
op_logical_neg
id|dmabuf-&gt;enable
op_logical_and
(paren
id|dmabuf-&gt;trigger
op_amp
id|PCM_ENABLE_OUTPUT
)paren
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|dmabuf-&gt;enable
op_or_assign
id|DAC_RUNNING
suffix:semicolon
id|outb
c_func
(paren
(paren
l_int|1
op_lshift
l_int|4
)paren
op_or
(paren
l_int|1
op_lshift
l_int|2
)paren
op_or
l_int|1
comma
id|card-&gt;iobase
op_plus
id|PO_CR
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
DECL|macro|DMABUF_DEFAULTORDER
mdefine_line|#define DMABUF_DEFAULTORDER (16-PAGE_SHIFT)
DECL|macro|DMABUF_MINORDER
mdefine_line|#define DMABUF_MINORDER 1
multiline_comment|/* allocate DMA buffer, playback and recording buffer should be allocated seperately */
DECL|function|alloc_dmabuf
r_static
r_int
id|alloc_dmabuf
c_func
(paren
r_struct
id|i810_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_void
op_star
id|rawbuf
op_assign
l_int|NULL
suffix:semicolon
r_int
id|order
comma
id|size
suffix:semicolon
r_struct
id|page
op_star
id|page
comma
op_star
id|pend
suffix:semicolon
multiline_comment|/* If we don&squot;t have any oss frag params, then use our default ones */
r_if
c_cond
(paren
id|dmabuf-&gt;ossmaxfrags
op_eq
l_int|0
)paren
(brace
id|dmabuf-&gt;ossmaxfrags
op_assign
l_int|4
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;ossfragsize
op_eq
l_int|0
)paren
(brace
id|dmabuf-&gt;ossfragsize
op_assign
(paren
id|PAGE_SIZE
op_lshift
id|DMABUF_DEFAULTORDER
)paren
op_div
id|dmabuf-&gt;ossmaxfrags
suffix:semicolon
)brace
id|size
op_assign
id|dmabuf-&gt;ossfragsize
op_star
id|dmabuf-&gt;ossmaxfrags
suffix:semicolon
multiline_comment|/* alloc enough to satisfy the oss params */
r_for
c_loop
(paren
id|order
op_assign
id|DMABUF_DEFAULTORDER
suffix:semicolon
id|order
op_ge
id|DMABUF_MINORDER
suffix:semicolon
id|order
op_decrement
)paren
(brace
r_if
c_cond
(paren
(paren
id|PAGE_SIZE
op_lshift
id|order
)paren
OG
id|size
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rawbuf
op_assign
id|pci_alloc_consistent
c_func
(paren
id|state-&gt;card-&gt;pci_dev
comma
id|PAGE_SIZE
op_lshift
id|order
comma
op_amp
id|dmabuf-&gt;dma_handle
)paren
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rawbuf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;i810_audio: allocated %ld (order = %d) bytes at %p&bslash;n&quot;
comma
id|PAGE_SIZE
op_lshift
id|order
comma
id|order
comma
id|rawbuf
)paren
suffix:semicolon
macro_line|#endif
id|dmabuf-&gt;ready
op_assign
id|dmabuf-&gt;mapped
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;rawbuf
op_assign
id|rawbuf
suffix:semicolon
id|dmabuf-&gt;buforder
op_assign
id|order
suffix:semicolon
multiline_comment|/* now mark the pages as reserved; otherwise remap_page_range doesn&squot;t do what we want */
id|pend
op_assign
id|virt_to_page
c_func
(paren
id|rawbuf
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|order
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
id|virt_to_page
c_func
(paren
id|rawbuf
)paren
suffix:semicolon
id|page
op_le
id|pend
suffix:semicolon
id|page
op_increment
)paren
id|mem_map_reserve
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* free DMA buffer */
DECL|function|dealloc_dmabuf
r_static
r_void
id|dealloc_dmabuf
c_func
(paren
r_struct
id|i810_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|page
op_star
id|page
comma
op_star
id|pend
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;rawbuf
)paren
(brace
multiline_comment|/* undo marking the pages as reserved */
id|pend
op_assign
id|virt_to_page
c_func
(paren
id|dmabuf-&gt;rawbuf
op_plus
(paren
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
id|virt_to_page
c_func
(paren
id|dmabuf-&gt;rawbuf
)paren
suffix:semicolon
id|page
op_le
id|pend
suffix:semicolon
id|page
op_increment
)paren
id|mem_map_unreserve
c_func
(paren
id|page
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|state-&gt;card-&gt;pci_dev
comma
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder
comma
id|dmabuf-&gt;rawbuf
comma
id|dmabuf-&gt;dma_handle
)paren
suffix:semicolon
)brace
id|dmabuf-&gt;rawbuf
op_assign
l_int|NULL
suffix:semicolon
id|dmabuf-&gt;mapped
op_assign
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|prog_dmabuf
r_static
r_int
id|prog_dmabuf
c_func
(paren
r_struct
id|i810_state
op_star
id|state
comma
r_int
id|rec
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_struct
id|i810_channel
op_star
id|c
suffix:semicolon
r_struct
id|sg_item
op_star
id|sg
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|fragint
suffix:semicolon
r_int
id|i
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
(brace
id|__stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|ADC_RUNNING
)paren
(brace
id|__stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|dmabuf-&gt;total_bytes
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;error
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* allocate DMA buffer if not allocated yet */
r_if
c_cond
(paren
id|dmabuf-&gt;rawbuf
)paren
id|dealloc_dmabuf
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|alloc_dmabuf
c_func
(paren
id|state
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* FIXME: figure out all this OSS fragment stuff */
multiline_comment|/* I did, it now does what it should according to the OSS API.  DL */
id|dmabuf-&gt;dmasize
op_assign
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder
suffix:semicolon
id|dmabuf-&gt;numfrag
op_assign
id|SG_LEN
suffix:semicolon
id|dmabuf-&gt;fragsize
op_assign
id|dmabuf-&gt;dmasize
op_div
id|dmabuf-&gt;numfrag
suffix:semicolon
id|dmabuf-&gt;fragsamples
op_assign
id|dmabuf-&gt;fragsize
op_rshift
l_int|1
suffix:semicolon
id|dmabuf-&gt;userfragsize
op_assign
id|dmabuf-&gt;ossfragsize
suffix:semicolon
id|dmabuf-&gt;userfrags
op_assign
id|dmabuf-&gt;dmasize
op_div
id|dmabuf-&gt;ossfragsize
suffix:semicolon
id|memset
c_func
(paren
id|dmabuf-&gt;rawbuf
comma
l_int|0
comma
id|dmabuf-&gt;dmasize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;ossmaxfrags
op_eq
l_int|4
)paren
(brace
id|fragint
op_assign
l_int|8
suffix:semicolon
id|dmabuf-&gt;fragshift
op_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dmabuf-&gt;ossmaxfrags
op_eq
l_int|8
)paren
(brace
id|fragint
op_assign
l_int|4
suffix:semicolon
id|dmabuf-&gt;fragshift
op_assign
l_int|3
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dmabuf-&gt;ossmaxfrags
op_eq
l_int|16
)paren
(brace
id|fragint
op_assign
l_int|2
suffix:semicolon
id|dmabuf-&gt;fragshift
op_assign
l_int|4
suffix:semicolon
)brace
r_else
(brace
id|fragint
op_assign
l_int|1
suffix:semicolon
id|dmabuf-&gt;fragshift
op_assign
l_int|5
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Now set up the ring &n;&t; */
r_if
c_cond
(paren
id|dmabuf-&gt;read_channel
)paren
(brace
id|c
op_assign
id|dmabuf-&gt;read_channel
suffix:semicolon
)brace
r_else
id|c
op_assign
id|dmabuf-&gt;write_channel
suffix:semicolon
r_while
c_loop
(paren
id|c
op_ne
l_int|NULL
)paren
(brace
id|sg
op_assign
op_amp
id|c-&gt;sg
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Load up 32 sg entries and take an interrupt at half&n;&t;&t; *&t;way (we might want more interrupts later..) &n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dmabuf-&gt;numfrag
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sg-&gt;busaddr
op_assign
id|virt_to_bus
c_func
(paren
id|dmabuf-&gt;rawbuf
op_plus
id|dmabuf-&gt;fragsize
op_star
id|i
)paren
suffix:semicolon
singleline_comment|// the card will always be doing 16bit stereo
id|sg-&gt;control
op_assign
id|dmabuf-&gt;fragsamples
suffix:semicolon
id|sg-&gt;control
op_or_assign
id|CON_BUFPAD
suffix:semicolon
singleline_comment|// set us up to get IOC interrupts as often as needed to
singleline_comment|// satisfy numfrag requirements, no more
r_if
c_cond
(paren
(paren
(paren
id|i
op_plus
l_int|1
)paren
op_mod
id|fragint
)paren
op_eq
l_int|0
)paren
(brace
id|sg-&gt;control
op_or_assign
id|CON_IOC
suffix:semicolon
)brace
id|sg
op_increment
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|2
comma
id|state-&gt;card-&gt;iobase
op_plus
id|c-&gt;port
op_plus
id|OFF_CR
)paren
suffix:semicolon
multiline_comment|/* reset DMA machine */
id|outl
c_func
(paren
id|virt_to_bus
c_func
(paren
op_amp
id|c-&gt;sg
(braket
l_int|0
)braket
)paren
comma
id|state-&gt;card-&gt;iobase
op_plus
id|c-&gt;port
op_plus
id|OFF_BDBAR
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|state-&gt;card-&gt;iobase
op_plus
id|c-&gt;port
op_plus
id|OFF_CIV
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|state-&gt;card-&gt;iobase
op_plus
id|c-&gt;port
op_plus
id|OFF_LVI
)paren
suffix:semicolon
id|dmabuf-&gt;count
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ne
id|dmabuf-&gt;write_channel
)paren
(brace
id|c
op_assign
id|dmabuf-&gt;write_channel
suffix:semicolon
)brace
r_else
id|c
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* set the ready flag for the dma buffer */
id|dmabuf-&gt;ready
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;i810_audio: prog_dmabuf, sample rate = %d, format = %d,&bslash;n&bslash;tnumfrag = %d, &quot;
l_string|&quot;fragsize = %d dmasize = %d&bslash;n&quot;
comma
id|dmabuf-&gt;rate
comma
id|dmabuf-&gt;fmt
comma
id|dmabuf-&gt;numfrag
comma
id|dmabuf-&gt;fragsize
comma
id|dmabuf-&gt;dmasize
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__i810_update_lvi
r_static
r_void
id|__i810_update_lvi
c_func
(paren
r_struct
id|i810_state
op_star
id|state
comma
r_int
id|rec
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
id|x
comma
id|port
suffix:semicolon
id|port
op_assign
id|state-&gt;card-&gt;iobase
suffix:semicolon
r_if
c_cond
(paren
id|rec
)paren
(brace
id|port
op_add_assign
id|dmabuf-&gt;read_channel-&gt;port
suffix:semicolon
)brace
r_else
id|port
op_add_assign
id|dmabuf-&gt;write_channel-&gt;port
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
(brace
r_if
c_cond
(paren
id|rec
)paren
(brace
id|dmabuf-&gt;swptr
op_assign
(paren
id|dmabuf-&gt;hwptr
op_plus
id|dmabuf-&gt;dmasize
op_minus
id|dmabuf-&gt;count
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
)brace
r_else
id|dmabuf-&gt;swptr
op_assign
(paren
id|dmabuf-&gt;hwptr
op_plus
id|dmabuf-&gt;count
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * two special cases, count == 0 on write&n;&t; * means no data, and count == dmasize&n;&t; * means no data on read, handle appropriately&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rec
op_logical_and
id|dmabuf-&gt;count
op_eq
l_int|0
)paren
(brace
id|outb
c_func
(paren
id|inb
c_func
(paren
id|port
op_plus
id|OFF_CIV
)paren
comma
id|port
op_plus
id|OFF_LVI
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rec
op_logical_and
id|dmabuf-&gt;count
op_eq
id|dmabuf-&gt;dmasize
)paren
(brace
id|outb
c_func
(paren
id|inb
c_func
(paren
id|port
op_plus
id|OFF_CIV
)paren
comma
id|port
op_plus
id|OFF_LVI
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* swptr - 1 is the tail of our transfer */
id|x
op_assign
(paren
id|dmabuf-&gt;dmasize
op_plus
id|dmabuf-&gt;swptr
op_minus
l_int|1
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|x
op_div_assign
id|dmabuf-&gt;fragsize
suffix:semicolon
id|outb
c_func
(paren
id|x
op_amp
l_int|31
comma
id|port
op_plus
id|OFF_LVI
)paren
suffix:semicolon
)brace
DECL|function|i810_update_lvi
r_static
r_void
id|i810_update_lvi
c_func
(paren
r_struct
id|i810_state
op_star
id|state
comma
r_int
id|rec
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
)paren
(brace
r_return
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__i810_update_lvi
c_func
(paren
id|state
comma
id|rec
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* update buffer manangement pointers, especially, dmabuf-&gt;count and dmabuf-&gt;hwptr */
DECL|function|i810_update_ptr
r_static
r_void
id|i810_update_ptr
c_func
(paren
r_struct
id|i810_state
op_star
id|state
)paren
(brace
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
id|hwptr
suffix:semicolon
r_int
id|diff
suffix:semicolon
multiline_comment|/* error handling and process wake up for DAC */
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_eq
id|ADC_RUNNING
)paren
(brace
multiline_comment|/* update hardware pointer */
id|hwptr
op_assign
id|i810_get_dma_addr
c_func
(paren
id|state
comma
l_int|1
)paren
suffix:semicolon
id|diff
op_assign
(paren
id|dmabuf-&gt;dmasize
op_plus
id|hwptr
op_minus
id|dmabuf-&gt;hwptr
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
singleline_comment|//&t;&t;printk(&quot;HWP %d,%d,%d&bslash;n&quot;, hwptr, dmabuf-&gt;hwptr, diff);
id|dmabuf-&gt;hwptr
op_assign
id|hwptr
suffix:semicolon
id|dmabuf-&gt;total_bytes
op_add_assign
id|diff
suffix:semicolon
id|dmabuf-&gt;count
op_add_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OG
id|dmabuf-&gt;dmasize
)paren
(brace
multiline_comment|/* buffer underrun or buffer overrun */
multiline_comment|/* this is normal for the end of a read */
multiline_comment|/* only give an error if we went past the */
multiline_comment|/* last valid sg entry */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|PI_CIV
)paren
op_ne
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|PI_LVI
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i810_audio: DMA overrun on read&bslash;n&quot;
)paren
suffix:semicolon
id|dmabuf-&gt;error
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;count
OG
id|dmabuf-&gt;userfragsize
)paren
id|wake_up
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
)brace
multiline_comment|/* error handling and process wake up for DAC */
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_eq
id|DAC_RUNNING
)paren
(brace
multiline_comment|/* update hardware pointer */
id|hwptr
op_assign
id|i810_get_dma_addr
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
id|diff
op_assign
(paren
id|dmabuf-&gt;dmasize
op_plus
id|hwptr
op_minus
id|dmabuf-&gt;hwptr
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
singleline_comment|//&t;&t;printk(&quot;HWP %d,%d,%d&bslash;n&quot;, hwptr, dmabuf-&gt;hwptr, diff);
id|dmabuf-&gt;hwptr
op_assign
id|hwptr
suffix:semicolon
id|dmabuf-&gt;total_bytes
op_add_assign
id|diff
suffix:semicolon
id|dmabuf-&gt;count
op_sub_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
l_int|0
)paren
(brace
multiline_comment|/* buffer underrun or buffer overrun */
multiline_comment|/* this is normal for the end of a write */
multiline_comment|/* only give an error if we went past the */
multiline_comment|/* last valid sg entry */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|PO_CIV
)paren
op_ne
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|PO_LVI
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i810_audio: DMA overrun on write&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;i810_audio: CIV %d, LVI %d, hwptr %x, &quot;
l_string|&quot;count %d&bslash;n&quot;
comma
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|PO_CIV
)paren
comma
id|inb
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|PO_LVI
)paren
comma
id|dmabuf-&gt;hwptr
comma
id|dmabuf-&gt;count
)paren
suffix:semicolon
id|dmabuf-&gt;error
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
(paren
id|dmabuf-&gt;dmasize
op_minus
id|dmabuf-&gt;userfragsize
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
)brace
)brace
DECL|function|drain_dac
r_static
r_int
id|drain_dac
c_func
(paren
r_struct
id|i810_state
op_star
id|state
comma
r_int
id|nonblock
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|tmo
suffix:semicolon
r_int
id|count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
)paren
r_return
l_int|0
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* It seems that we have to set the current state to TASK_INTERRUPTIBLE&n;&t;&t;   every time to make the process really go to sleep */
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|i810_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|count
op_assign
id|dmabuf-&gt;count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_le
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
id|i810_update_lvi
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_ne
id|DAC_RUNNING
)paren
id|start_dac
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nonblock
)paren
(brace
id|remove_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|tmo
op_assign
(paren
id|dmabuf-&gt;dmasize
op_star
id|HZ
)paren
op_div
id|dmabuf-&gt;rate
suffix:semicolon
id|tmo
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|schedule_timeout
c_func
(paren
id|tmo
ques
c_cond
id|tmo
suffix:colon
l_int|1
)paren
op_logical_and
id|tmo
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i810_audio: drain_dac, dma timeout?&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|i810_channel_interrupt
r_static
r_void
id|i810_channel_interrupt
c_func
(paren
r_struct
id|i810_card
op_star
id|card
)paren
(brace
r_int
id|i
comma
id|count
suffix:semicolon
macro_line|#ifdef DEBUG_INTERRUPTS
id|printk
c_func
(paren
l_string|&quot;CHANNEL &quot;
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_HW_CH
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|i810_state
op_star
id|state
op_assign
id|card-&gt;states
(braket
id|i
)braket
suffix:semicolon
r_struct
id|i810_channel
op_star
id|c
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
suffix:semicolon
r_int
r_int
id|port
op_assign
id|card-&gt;iobase
suffix:semicolon
id|u16
id|status
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;dmabuf.ready
)paren
(brace
r_continue
suffix:semicolon
)brace
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
(brace
id|c
op_assign
id|dmabuf-&gt;write_channel
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|ADC_RUNNING
)paren
(brace
id|c
op_assign
id|dmabuf-&gt;read_channel
suffix:semicolon
)brace
r_else
multiline_comment|/* This can occur going from R/W to close */
r_continue
suffix:semicolon
id|port
op_add_assign
id|c-&gt;port
suffix:semicolon
id|status
op_assign
id|inw
c_func
(paren
id|port
op_plus
id|OFF_SR
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_INTERRUPTS
id|printk
c_func
(paren
l_string|&quot;NUM %d PORT %X IRQ ( ST%d &quot;
comma
id|c-&gt;num
comma
id|c-&gt;port
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|status
op_amp
id|DMA_INT_COMPLETE
)paren
(brace
id|i810_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_INTERRUPTS
id|printk
c_func
(paren
l_string|&quot;COMP %d &quot;
comma
id|dmabuf-&gt;hwptr
op_div
id|dmabuf-&gt;fragsize
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|status
op_amp
id|DMA_INT_LVI
)paren
(brace
id|i810_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_INTERRUPTS
id|printk
c_func
(paren
l_string|&quot;LVI &quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|status
op_amp
id|DMA_INT_DCH
)paren
(brace
id|i810_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
(brace
id|count
op_assign
id|dmabuf-&gt;count
suffix:semicolon
)brace
r_else
id|count
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|dmabuf-&gt;count
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|0
)paren
(brace
id|outb
c_func
(paren
id|inb
c_func
(paren
id|port
op_plus
id|OFF_CR
)paren
op_or
l_int|1
comma
id|port
op_plus
id|OFF_CR
)paren
suffix:semicolon
)brace
r_else
(brace
id|wake_up
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_INTERRUPTS
id|printk
c_func
(paren
l_string|&quot;DCH - STOP &quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
id|outw
c_func
(paren
id|status
op_amp
id|DMA_INT_MASK
comma
id|port
op_plus
id|OFF_SR
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_INTERRUPTS
id|printk
c_func
(paren
l_string|&quot;)&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|i810_interrupt
r_static
r_void
id|i810_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|i810_card
op_star
id|card
op_assign
(paren
r_struct
id|i810_card
op_star
)paren
id|dev_id
suffix:semicolon
id|u32
id|status
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
id|status
op_assign
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|GLOB_STA
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|INT_MASK
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* not for us */
)brace
r_if
c_cond
(paren
id|status
op_amp
(paren
id|INT_PO
op_or
id|INT_PI
op_or
id|INT_MC
)paren
)paren
(brace
id|i810_channel_interrupt
c_func
(paren
id|card
)paren
suffix:semicolon
)brace
multiline_comment|/* clear &squot;em */
id|outl
c_func
(paren
id|status
op_amp
id|INT_MASK
comma
id|card-&gt;iobase
op_plus
id|GLOB_STA
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/* in this loop, dmabuf.count signifies the amount of data that is&n;   waiting to be copied to the user&squot;s buffer.  It is filled by the dma&n;   machine and drained by this loop. */
DECL|function|i810_read
r_static
id|ssize_t
id|i810_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|i810_state
op_star
id|state
op_assign
(paren
r_struct
id|i810_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|i810_card
op_star
id|card
op_assign
id|state
ques
c_cond
id|state-&gt;card
suffix:colon
l_int|0
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|swptr
suffix:semicolon
r_int
id|cnt
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|waita
comma
id|current
)paren
suffix:semicolon
macro_line|#ifdef DEBUG2
id|printk
c_func
(paren
l_string|&quot;i810_audio: i810_read called, count = %d&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;read_channel
)paren
(brace
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;read_channel
op_assign
id|card
op_member_access_from_pointer
id|alloc_rec_pcm_channel
c_func
(paren
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;read_channel
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|dmabuf-&gt;trigger
op_and_assign
op_complement
id|PCM_ENABLE_OUTPUT
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|waita
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PM_SUSPENDED
c_func
(paren
id|card
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
id|swptr
op_assign
id|dmabuf-&gt;swptr
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OG
id|dmabuf-&gt;dmasize
)paren
(brace
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;dmasize
suffix:semicolon
)brace
id|cnt
op_assign
id|dmabuf-&gt;count
op_minus
id|dmabuf-&gt;fragsize
suffix:semicolon
singleline_comment|// this is to make the copy_to_user simpler below
r_if
c_cond
(paren
id|cnt
OG
(paren
id|dmabuf-&gt;dmasize
op_minus
id|swptr
)paren
)paren
(brace
id|cnt
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|swptr
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
id|count
)paren
id|cnt
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
(brace
r_int
r_int
id|tmo
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;enable
)paren
(brace
id|dmabuf-&gt;trigger
op_or_assign
id|PCM_ENABLE_INPUT
suffix:semicolon
id|start_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|i810_update_lvi
c_func
(paren
id|state
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* This isnt strictly right for the 810  but it&squot;ll do */
id|tmo
op_assign
(paren
id|dmabuf-&gt;dmasize
op_star
id|HZ
)paren
op_div
(paren
id|dmabuf-&gt;rate
op_star
l_int|2
)paren
suffix:semicolon
id|tmo
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* There are two situations when sleep_on_timeout returns, one is when&n;&t;&t;&t;   the interrupt is serviced correctly and the process is waked up by&n;&t;&t;&t;   ISR ON TIME. Another is when timeout is expired, which means that&n;&t;&t;&t;   either interrupt is NOT serviced correctly (pending interrupt) or it&n;&t;&t;&t;   is TOO LATE for the process to be scheduled to run (scheduler latency)&n;&t;&t;&t;   which results in a (potential) buffer overrun. And worse, there is&n;&t;&t;&t;   NOTHING we can do to prevent it. */
r_if
c_cond
(paren
op_logical_neg
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
id|tmo
)paren
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i810_audio: recording schedule timeout, &quot;
l_string|&quot;dmasz %u fragsz %u count %i hwptr %u swptr %u&bslash;n&quot;
comma
id|dmabuf-&gt;dmasize
comma
id|dmabuf-&gt;fragsize
comma
id|dmabuf-&gt;count
comma
id|dmabuf-&gt;hwptr
comma
id|dmabuf-&gt;swptr
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* a buffer overrun, we delay the recovery until next time the&n;&t;&t;&t;&t;   while loop begin and we REALLY have space to record */
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|ret
op_assign
id|ret
ques
c_cond
id|ret
suffix:colon
op_minus
id|ERESTARTSYS
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buffer
comma
id|dmabuf-&gt;rawbuf
op_plus
id|swptr
comma
id|cnt
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|swptr
op_assign
(paren
id|swptr
op_plus
id|cnt
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PM_SUSPENDED
c_func
(paren
id|card
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|dmabuf-&gt;swptr
op_assign
id|swptr
suffix:semicolon
id|dmabuf-&gt;count
op_sub_assign
id|cnt
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_sub_assign
id|cnt
suffix:semicolon
id|buffer
op_add_assign
id|cnt
suffix:semicolon
id|ret
op_add_assign
id|cnt
suffix:semicolon
)brace
id|i810_update_lvi
c_func
(paren
id|state
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dmabuf-&gt;enable
op_amp
id|ADC_RUNNING
)paren
)paren
(brace
id|start_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|done
suffix:colon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|waita
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* in this loop, dmabuf.count signifies the amount of data that is waiting to be dma to&n;   the soundcard.  it is drained by the dma machine and filled by this loop. */
DECL|function|i810_write
r_static
id|ssize_t
id|i810_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|i810_state
op_star
id|state
op_assign
(paren
r_struct
id|i810_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|i810_card
op_star
id|card
op_assign
id|state
ques
c_cond
id|state-&gt;card
suffix:colon
l_int|0
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|swptr
op_assign
l_int|0
suffix:semicolon
r_int
id|cnt
comma
id|x
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|waita
comma
id|current
)paren
suffix:semicolon
macro_line|#ifdef DEBUG2
id|printk
c_func
(paren
l_string|&quot;i810_audio: i810_write called, count = %d&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|ADC_RUNNING
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;write_channel
)paren
(brace
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;write_channel
op_assign
id|card
op_member_access_from_pointer
id|alloc_pcm_channel
c_func
(paren
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;write_channel
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|dmabuf-&gt;trigger
op_and_assign
op_complement
id|PCM_ENABLE_INPUT
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|waita
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PM_SUSPENDED
c_func
(paren
id|card
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
id|swptr
op_assign
id|dmabuf-&gt;swptr
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;count
OL
l_int|0
)paren
(brace
id|dmabuf-&gt;count
op_assign
l_int|0
suffix:semicolon
)brace
id|cnt
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|dmabuf-&gt;fragsize
op_minus
id|dmabuf-&gt;count
suffix:semicolon
singleline_comment|// this is to make the copy_from_user simpler below
r_if
c_cond
(paren
id|cnt
OG
(paren
id|dmabuf-&gt;dmasize
op_minus
id|swptr
)paren
)paren
(brace
id|cnt
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|swptr
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef DEBUG2
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;i810_audio: i810_write: %d bytes available space&bslash;n&quot;
comma
id|cnt
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cnt
OG
id|count
)paren
id|cnt
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
(brace
r_int
r_int
id|tmo
suffix:semicolon
singleline_comment|// There is data waiting to be played
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;enable
op_logical_and
id|dmabuf-&gt;count
)paren
(brace
multiline_comment|/* force the starting incase SETTRIGGER has been used */
multiline_comment|/* to stop it, otherwise this is a deadlock situation */
id|dmabuf-&gt;trigger
op_or_assign
id|PCM_ENABLE_OUTPUT
suffix:semicolon
id|start_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
singleline_comment|// Update the LVI pointer in case we have already
singleline_comment|// written data in this syscall and are just waiting
singleline_comment|// on the tail bit of data
id|i810_update_lvi
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|ret
suffix:semicolon
)brace
multiline_comment|/* Not strictly correct but works */
id|tmo
op_assign
(paren
id|dmabuf-&gt;dmasize
op_star
id|HZ
)paren
op_div
(paren
id|dmabuf-&gt;rate
op_star
l_int|4
)paren
suffix:semicolon
multiline_comment|/* There are two situations when sleep_on_timeout returns, one is when&n;&t;&t;&t;   the interrupt is serviced correctly and the process is waked up by&n;&t;&t;&t;   ISR ON TIME. Another is when timeout is expired, which means that&n;&t;&t;&t;   either interrupt is NOT serviced correctly (pending interrupt) or it&n;&t;&t;&t;   is TOO LATE for the process to be scheduled to run (scheduler latency)&n;&t;&t;&t;   which results in a (potential) buffer underrun. And worse, there is&n;&t;&t;&t;   NOTHING we can do to prevent it. */
r_if
c_cond
(paren
op_logical_neg
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
id|tmo
)paren
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i810_audio: playback schedule timeout, &quot;
l_string|&quot;dmasz %u fragsz %u count %i hwptr %u swptr %u&bslash;n&quot;
comma
id|dmabuf-&gt;dmasize
comma
id|dmabuf-&gt;fragsize
comma
id|dmabuf-&gt;count
comma
id|dmabuf-&gt;hwptr
comma
id|dmabuf-&gt;swptr
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* a buffer underrun, we delay the recovery until next time the&n;&t;&t;&t;&t;   while loop begin and we REALLY have data to play */
singleline_comment|//return ret;
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_goto
id|ret
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|dmabuf-&gt;rawbuf
op_plus
id|swptr
comma
id|buffer
comma
id|cnt
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|ret
suffix:semicolon
)brace
id|swptr
op_assign
(paren
id|swptr
op_plus
id|cnt
)paren
op_mod
id|dmabuf-&gt;dmasize
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PM_SUSPENDED
c_func
(paren
id|card
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|dmabuf-&gt;swptr
op_assign
id|swptr
suffix:semicolon
id|dmabuf-&gt;count
op_add_assign
id|cnt
suffix:semicolon
id|count
op_sub_assign
id|cnt
suffix:semicolon
id|buffer
op_add_assign
id|cnt
suffix:semicolon
id|ret
op_add_assign
id|cnt
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|swptr
op_mod
id|dmabuf-&gt;fragsize
)paren
(brace
id|x
op_assign
id|dmabuf-&gt;fragsize
op_minus
(paren
id|swptr
op_mod
id|dmabuf-&gt;fragsize
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dmabuf-&gt;rawbuf
op_plus
id|swptr
comma
l_char|&squot;&bslash;0&squot;
comma
id|x
)paren
suffix:semicolon
)brace
id|i810_update_lvi
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;enable
op_logical_and
id|dmabuf-&gt;count
op_ge
id|dmabuf-&gt;userfragsize
)paren
id|start_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|ret
suffix:colon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|dmabuf-&gt;wait
comma
op_amp
id|waita
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* No kernel lock - we have our own spinlock */
DECL|function|i810_poll
r_static
r_int
r_int
id|i810_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|poll_table_struct
op_star
id|wait
)paren
(brace
r_struct
id|i810_state
op_star
id|state
op_assign
(paren
r_struct
id|i810_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|dmabuf-&gt;wait
comma
id|wait
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|i810_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
op_logical_and
id|dmabuf-&gt;enable
op_amp
id|ADC_RUNNING
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_ge
(paren
r_int
)paren
id|dmabuf-&gt;fragsize
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
op_logical_and
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;count
op_ge
(paren
r_int
)paren
id|dmabuf-&gt;fragsize
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
id|dmabuf-&gt;dmasize
op_ge
id|dmabuf-&gt;count
op_plus
(paren
r_int
)paren
id|dmabuf-&gt;fragsize
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
DECL|function|i810_mmap
r_static
r_int
id|i810_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|i810_state
op_star
id|state
op_assign
(paren
r_struct
id|i810_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_WRITE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;write_channel
op_logical_and
(paren
id|dmabuf-&gt;write_channel
op_assign
id|state-&gt;card
op_member_access_from_pointer
id|alloc_pcm_channel
c_func
(paren
id|state-&gt;card
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_READ
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;read_channel
op_logical_and
(paren
id|dmabuf-&gt;read_channel
op_assign
id|state-&gt;card
op_member_access_from_pointer
id|alloc_rec_pcm_channel
c_func
(paren
id|state-&gt;card
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_pgoff
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|size
op_assign
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
(paren
id|PAGE_SIZE
op_lshift
id|dmabuf-&gt;buforder
)paren
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|remap_page_range
c_func
(paren
id|vma-&gt;vm_start
comma
id|virt_to_phys
c_func
(paren
id|dmabuf-&gt;rawbuf
)paren
comma
id|size
comma
id|vma-&gt;vm_page_prot
)paren
)paren
r_goto
id|out
suffix:semicolon
id|dmabuf-&gt;mapped
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_WRITE
)paren
(brace
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;dmasize
suffix:semicolon
)brace
r_else
id|dmabuf-&gt;count
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;i810_audio: mmap&squot;ed %ld bytes of data space&bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
macro_line|#endif
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|i810_ioctl
r_static
r_int
id|i810_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|i810_state
op_star
id|state
op_assign
(paren
r_struct
id|i810_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|audio_buf_info
id|abinfo
suffix:semicolon
id|count_info
id|cinfo
suffix:semicolon
r_int
r_int
id|i_glob_cnt
suffix:semicolon
r_int
id|val
op_assign
l_int|0
comma
id|mapped
comma
id|ret
suffix:semicolon
r_struct
id|ac97_codec
op_star
id|codec
op_assign
id|state-&gt;card-&gt;ac97_codec
(braket
l_int|0
)braket
suffix:semicolon
id|mapped
op_assign
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
op_logical_and
id|dmabuf-&gt;mapped
)paren
op_logical_or
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
op_logical_and
id|dmabuf-&gt;mapped
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;i810_audio: i810_ioctl, arg=0x%x, cmd=&quot;
comma
id|arg
ques
c_cond
op_star
(paren
r_int
op_star
)paren
id|arg
suffix:colon
l_int|0
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|OSS_GETVERSION
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;OSS_GETVERSION&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|SOUND_VERSION
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_RESET
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_RESET&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* FIXME: spin_lock ? */
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_eq
id|DAC_RUNNING
)paren
(brace
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_eq
id|ADC_RUNNING
)paren
(brace
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;total_bytes
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SYNC
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SYNC&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_ne
id|DAC_RUNNING
op_logical_or
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
l_int|0
suffix:semicolon
id|drain_dac
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;total_bytes
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SPEED
suffix:colon
multiline_comment|/* set smaple rate */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SPEED&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
(paren
id|state-&gt;card-&gt;ac97_status
op_amp
id|SPDIF_ON
)paren
)paren
(brace
multiline_comment|/* S/PDIF Enabled */
multiline_comment|/* AD1886 only supports 48000, need to check that */
r_if
c_cond
(paren
id|i810_valid_spdif_rate
(paren
id|codec
comma
id|val
)paren
)paren
(brace
multiline_comment|/* Set DAC rate */
id|i810_set_spdif_output
(paren
id|state
comma
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|i810_set_dac_rate
c_func
(paren
id|state
comma
id|val
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Set S/PDIF transmitter rate. */
id|i810_set_spdif_output
(paren
id|state
comma
id|AC97_EA_SPSA_3_4
comma
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|state-&gt;card-&gt;ac97_status
op_amp
id|SPDIF_ON
)paren
)paren
(brace
id|val
op_assign
id|dmabuf-&gt;rate
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Not a valid rate for S/PDIF, ignore it */
id|val
op_assign
id|dmabuf-&gt;rate
suffix:semicolon
)brace
)brace
r_else
(brace
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|i810_set_dac_rate
c_func
(paren
id|state
comma
id|val
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|i810_set_adc_rate
c_func
(paren
id|state
comma
id|val
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
r_return
id|put_user
c_func
(paren
id|dmabuf-&gt;rate
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_STEREO
suffix:colon
multiline_comment|/* set stereo or mono channel */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_STEREO&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
(brace
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|ADC_RUNNING
)paren
(brace
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_return
id|put_user
c_func
(paren
l_int|1
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETBLKSIZE
suffix:colon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
)paren
r_return
id|val
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETBLKSIZE %d&bslash;n&quot;
comma
id|dmabuf-&gt;userfragsize
)paren
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|dmabuf-&gt;userfragsize
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETFMTS
suffix:colon
multiline_comment|/* Returns a mask of supported sample format*/
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETFMTS&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|AFMT_S16_LE
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFMT
suffix:colon
multiline_comment|/* Select sample format */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETFMT&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|val
)paren
(brace
r_case
id|AFMT_S16_LE
suffix:colon
r_break
suffix:semicolon
r_case
id|AFMT_QUERY
suffix:colon
r_default
suffix:colon
id|val
op_assign
id|AFMT_S16_LE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_CHANNELS
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_CHANNELS&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
)paren
(brace
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|ADC_RUNNING
)paren
(brace
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_return
id|put_user
c_func
(paren
id|state-&gt;card-&gt;channels
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
multiline_comment|/* ICH and ICH0 only support 2 channels */
r_if
c_cond
(paren
id|state-&gt;card-&gt;pci_id
op_eq
l_int|0x2415
op_logical_or
id|state-&gt;card-&gt;pci_id
op_eq
l_int|0x2425
)paren
r_return
id|put_user
c_func
(paren
l_int|2
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
multiline_comment|/* Multi-channel support was added with ICH2. Bits in */
multiline_comment|/* Global Status and Global Control register are now  */
multiline_comment|/* used to indicate this.                             */
id|i_glob_cnt
op_assign
id|inl
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|GLOB_CNT
)paren
suffix:semicolon
multiline_comment|/* Current # of channels enabled */
r_if
c_cond
(paren
id|i_glob_cnt
op_amp
l_int|0x0100000
)paren
id|ret
op_assign
l_int|4
suffix:semicolon
r_else
r_if
c_cond
(paren
id|i_glob_cnt
op_amp
l_int|0x0200000
)paren
id|ret
op_assign
l_int|6
suffix:semicolon
r_else
id|ret
op_assign
l_int|2
suffix:semicolon
r_switch
c_cond
(paren
id|val
)paren
(brace
r_case
l_int|2
suffix:colon
multiline_comment|/* 2 channels is always supported */
id|outl
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|GLOB_CNT
comma
(paren
id|i_glob_cnt
op_amp
l_int|0xcfffff
)paren
)paren
suffix:semicolon
multiline_comment|/* Do we need to change mixer settings????  */
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
multiline_comment|/* Supported on some chipsets, better check first */
r_if
c_cond
(paren
id|state-&gt;card-&gt;channels
op_ge
l_int|4
)paren
(brace
id|outl
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|GLOB_CNT
comma
(paren
(paren
id|i_glob_cnt
op_amp
l_int|0xcfffff
)paren
op_or
l_int|0x0100000
)paren
)paren
suffix:semicolon
multiline_comment|/* Do we need to change mixer settings??? */
)brace
r_else
(brace
id|val
op_assign
id|ret
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
multiline_comment|/* Supported on some chipsets, better check first */
r_if
c_cond
(paren
id|state-&gt;card-&gt;channels
op_ge
l_int|6
)paren
(brace
id|outl
c_func
(paren
id|state-&gt;card-&gt;iobase
op_plus
id|GLOB_CNT
comma
(paren
(paren
id|i_glob_cnt
op_amp
l_int|0xcfffff
)paren
op_or
l_int|0x0200000
)paren
)paren
suffix:semicolon
multiline_comment|/* Do we need to change mixer settings??? */
)brace
r_else
(brace
id|val
op_assign
id|ret
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* nothing else is ever supported by the chipset */
id|val
op_assign
id|ret
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_POST
suffix:colon
multiline_comment|/* the user has sent all data and is notifying us */
multiline_comment|/* we update the swptr to the end of the last sg segment then return */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_POST&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_or
(paren
id|dmabuf-&gt;enable
op_ne
id|DAC_RUNNING
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|dmabuf-&gt;swptr
op_mod
id|dmabuf-&gt;fragsize
)paren
op_ne
l_int|0
)paren
(brace
id|val
op_assign
id|dmabuf-&gt;fragsize
op_minus
(paren
id|dmabuf-&gt;swptr
op_mod
id|dmabuf-&gt;fragsize
)paren
suffix:semicolon
id|dmabuf-&gt;swptr
op_add_assign
id|val
suffix:semicolon
id|dmabuf-&gt;count
op_add_assign
id|val
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SUBDIVIDE
suffix:colon
r_if
c_cond
(paren
id|dmabuf-&gt;subdivision
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
l_int|1
op_logical_and
id|val
op_ne
l_int|2
op_logical_and
id|val
op_ne
l_int|4
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SUBDIVIDE %d&bslash;n&quot;
comma
id|val
)paren
suffix:semicolon
macro_line|#endif
id|dmabuf-&gt;subdivision
op_assign
id|val
suffix:semicolon
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFRAGMENT
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|dmabuf-&gt;ossfragsize
op_assign
l_int|1
op_lshift
(paren
id|val
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|dmabuf-&gt;ossmaxfrags
op_assign
(paren
id|val
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;ossmaxfrags
op_le
l_int|4
)paren
id|dmabuf-&gt;ossmaxfrags
op_assign
l_int|4
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dmabuf-&gt;ossmaxfrags
op_le
l_int|8
)paren
id|dmabuf-&gt;ossmaxfrags
op_assign
l_int|8
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dmabuf-&gt;ossmaxfrags
op_le
l_int|16
)paren
id|dmabuf-&gt;ossmaxfrags
op_assign
l_int|16
suffix:semicolon
r_else
id|dmabuf-&gt;ossmaxfrags
op_assign
l_int|32
suffix:semicolon
id|val
op_assign
id|dmabuf-&gt;ossfragsize
op_star
id|dmabuf-&gt;ossmaxfrags
suffix:semicolon
r_if
c_cond
(paren
id|val
OL
l_int|16384
)paren
id|val
op_assign
l_int|16384
suffix:semicolon
r_if
c_cond
(paren
id|val
OG
l_int|65536
)paren
id|val
op_assign
l_int|65536
suffix:semicolon
id|dmabuf-&gt;ossmaxfrags
op_assign
id|val
op_div
id|dmabuf-&gt;ossfragsize
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;ossmaxfrags
OL
l_int|4
)paren
(brace
id|dmabuf-&gt;ossfragsize
op_assign
id|val
op_div
l_int|4
suffix:semicolon
)brace
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETFRAGMENT 0x%x, %d, %d&bslash;n&quot;
comma
id|val
comma
id|dmabuf-&gt;ossfragsize
comma
id|dmabuf-&gt;ossmaxfrags
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOSPACE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|val
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|i810_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|abinfo.fragsize
op_assign
id|dmabuf-&gt;userfragsize
suffix:semicolon
id|abinfo.fragstotal
op_assign
id|dmabuf-&gt;userfrags
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
(brace
id|abinfo.bytes
op_assign
id|dmabuf-&gt;count
suffix:semicolon
)brace
r_else
id|abinfo.bytes
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|dmabuf-&gt;count
suffix:semicolon
id|abinfo.fragments
op_assign
id|abinfo.bytes
op_div
id|dmabuf-&gt;userfragsize
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETOSPACE %d, %d, %d, %d&bslash;n&quot;
comma
id|abinfo.bytes
comma
id|abinfo.fragsize
comma
id|abinfo.fragments
comma
id|abinfo.fragstotal
)paren
suffix:semicolon
macro_line|#endif
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|abinfo
comma
r_sizeof
(paren
id|abinfo
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOPTR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|val
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|i810_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|cinfo.bytes
op_assign
id|dmabuf-&gt;total_bytes
suffix:semicolon
id|cinfo.ptr
op_assign
id|dmabuf-&gt;hwptr
suffix:semicolon
id|cinfo.blocks
op_assign
(paren
id|dmabuf-&gt;dmasize
op_minus
id|dmabuf-&gt;count
)paren
op_div
id|dmabuf-&gt;userfragsize
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
(brace
id|dmabuf-&gt;count
op_assign
(paren
id|dmabuf-&gt;dmasize
op_minus
(paren
id|dmabuf-&gt;count
op_amp
(paren
id|dmabuf-&gt;userfragsize
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
id|__i810_update_lvi
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETOPTR %d, %d, %d, %d&bslash;n&quot;
comma
id|cinfo.bytes
comma
id|cinfo.blocks
comma
id|cinfo.ptr
comma
id|dmabuf-&gt;count
)paren
suffix:semicolon
macro_line|#endif
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|cinfo
comma
r_sizeof
(paren
id|cinfo
)paren
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETISPACE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|val
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|i810_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|abinfo.fragsize
op_assign
id|dmabuf-&gt;userfragsize
suffix:semicolon
id|abinfo.fragstotal
op_assign
id|dmabuf-&gt;userfrags
suffix:semicolon
id|abinfo.bytes
op_assign
id|dmabuf-&gt;dmasize
op_minus
id|dmabuf-&gt;count
suffix:semicolon
id|abinfo.fragments
op_assign
id|abinfo.bytes
op_div
id|dmabuf-&gt;userfragsize
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETISPACE %d, %d, %d, %d&bslash;n&quot;
comma
id|abinfo.bytes
comma
id|abinfo.fragsize
comma
id|abinfo.fragments
comma
id|abinfo.fragstotal
)paren
suffix:semicolon
macro_line|#endif
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|abinfo
comma
r_sizeof
(paren
id|abinfo
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETIPTR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|val
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|val
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|i810_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|cinfo.bytes
op_assign
id|dmabuf-&gt;total_bytes
suffix:semicolon
id|cinfo.blocks
op_assign
id|dmabuf-&gt;count
op_div
id|dmabuf-&gt;userfragsize
suffix:semicolon
id|cinfo.ptr
op_assign
id|dmabuf-&gt;hwptr
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
(brace
id|dmabuf-&gt;count
op_and_assign
(paren
id|dmabuf-&gt;userfragsize
op_minus
l_int|1
)paren
suffix:semicolon
id|__i810_update_lvi
c_func
(paren
id|state
comma
l_int|1
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETIPTR %d, %d, %d, %d&bslash;n&quot;
comma
id|cinfo.bytes
comma
id|cinfo.blocks
comma
id|cinfo.ptr
comma
id|dmabuf-&gt;count
)paren
suffix:semicolon
macro_line|#endif
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|cinfo
comma
r_sizeof
(paren
id|cinfo
)paren
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_NONBLOCK
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_NONBLOCK&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|file-&gt;f_flags
op_or_assign
id|O_NONBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_GETCAPS
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETCAPS&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|DSP_CAP_REALTIME
op_or
id|DSP_CAP_TRIGGER
op_or
id|DSP_CAP_MMAP
op_or
id|DSP_CAP_BIND
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETTRIGGER
suffix:colon
id|val
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETTRIGGER 0x%x&bslash;n&quot;
comma
id|dmabuf-&gt;trigger
)paren
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|dmabuf-&gt;trigger
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETTRIGGER
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETTRIGGER 0x%x&bslash;n&quot;
comma
id|val
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|val
op_amp
id|PCM_ENABLE_INPUT
)paren
op_logical_and
id|dmabuf-&gt;enable
op_eq
id|ADC_RUNNING
)paren
(brace
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|val
op_amp
id|PCM_ENABLE_OUTPUT
)paren
op_logical_and
id|dmabuf-&gt;enable
op_eq
id|DAC_RUNNING
)paren
(brace
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|dmabuf-&gt;trigger
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
id|val
op_amp
id|PCM_ENABLE_OUTPUT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;write_channel
)paren
(brace
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;write_channel
op_assign
id|state-&gt;card
op_member_access_from_pointer
id|alloc_pcm_channel
c_func
(paren
id|state-&gt;card
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;write_channel
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
(brace
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;dmasize
suffix:semicolon
id|i810_update_lvi
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;enable
op_logical_and
id|dmabuf-&gt;count
OG
id|dmabuf-&gt;userfragsize
)paren
id|start_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|val
op_amp
id|PCM_ENABLE_INPUT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;read_channel
)paren
(brace
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;read_channel
op_assign
id|state-&gt;card
op_member_access_from_pointer
id|alloc_rec_pcm_channel
c_func
(paren
id|state-&gt;card
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;read_channel
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;ready
op_logical_and
(paren
id|ret
op_assign
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|1
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;mapped
)paren
(brace
id|dmabuf-&gt;count
op_assign
l_int|0
suffix:semicolon
id|i810_update_lvi
c_func
(paren
id|state
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dmabuf-&gt;enable
op_logical_and
id|dmabuf-&gt;count
OL
(paren
id|dmabuf-&gt;dmasize
op_minus
id|dmabuf-&gt;userfragsize
)paren
)paren
id|start_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|SNDCTL_DSP_SETDUPLEX
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETDUPLEX&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|SNDCTL_DSP_GETODELAY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|i810_update_ptr
c_func
(paren
id|state
)paren
suffix:semicolon
id|val
op_assign
id|dmabuf-&gt;count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|state-&gt;card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETODELAY %d&bslash;n&quot;
comma
id|dmabuf-&gt;count
)paren
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_RATE
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SOUND_PCM_READ_RATE %d&bslash;n&quot;
comma
id|dmabuf-&gt;rate
)paren
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|dmabuf-&gt;rate
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_CHANNELS
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SOUND_PCM_READ_CHANNELS&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
l_int|2
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SOUND_PCM_READ_BITS
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SOUND_PCM_READ_BITS&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|AFMT_S16_LE
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_SETSPDIF
suffix:colon
multiline_comment|/* Set S/PDIF Control register */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_SETSPDIF&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Check to make sure the codec supports S/PDIF transmitter */
r_if
c_cond
(paren
(paren
id|state-&gt;card-&gt;ac97_features
op_amp
l_int|4
)paren
)paren
(brace
multiline_comment|/* mask out the transmitter speed bits so the user can&squot;t set them */
id|val
op_and_assign
op_complement
l_int|0x3000
suffix:semicolon
multiline_comment|/* Add the current transmitter speed bits to the passed value */
id|ret
op_assign
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_SPDIF_CONTROL
)paren
suffix:semicolon
id|val
op_or_assign
(paren
id|ret
op_amp
l_int|0x3000
)paren
suffix:semicolon
id|i810_ac97_set
c_func
(paren
id|codec
comma
id|AC97_SPDIF_CONTROL
comma
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_SPDIF_CONTROL
)paren
op_ne
id|val
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i810_audio: Unable to set S/PDIF configuration to 0x%04x.&bslash;n&quot;
comma
id|val
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i810_audio: S/PDIF transmitter not avalible.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETSPDIF
suffix:colon
multiline_comment|/* Get S/PDIF Control register */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETSPDIF&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Check to make sure the codec supports S/PDIF transmitter */
r_if
c_cond
(paren
op_logical_neg
(paren
id|state-&gt;card-&gt;ac97_features
op_amp
l_int|4
)paren
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i810_audio: S/PDIF transmitter not avalible.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|val
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|val
op_assign
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_SPDIF_CONTROL
)paren
suffix:semicolon
)brace
singleline_comment|//return put_user((val &amp; 0xcfff), (int *)arg);
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_GETCHANNELMASK
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_GETCHANNELMASK&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Based on AC&squot;97 DAC support, not ICH hardware */
id|val
op_assign
id|DSP_BIND_FRONT
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;card-&gt;ac97_features
op_amp
l_int|0x0004
)paren
id|val
op_or_assign
id|DSP_BIND_SPDIF
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;card-&gt;ac97_features
op_amp
l_int|0x0080
)paren
id|val
op_or_assign
id|DSP_BIND_SURR
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;card-&gt;ac97_features
op_amp
l_int|0x0140
)paren
id|val
op_or_assign
id|DSP_BIND_CENTER_LFE
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_BIND_CHANNEL
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_DSP_BIND_CHANNEL&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|val
op_eq
id|DSP_BIND_QUERY
)paren
(brace
id|val
op_assign
id|DSP_BIND_FRONT
suffix:semicolon
multiline_comment|/* Always report this as being enabled */
r_if
c_cond
(paren
id|state-&gt;card-&gt;ac97_status
op_amp
id|SPDIF_ON
)paren
id|val
op_or_assign
id|DSP_BIND_SPDIF
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|state-&gt;card-&gt;ac97_status
op_amp
id|SURR_ON
)paren
id|val
op_or_assign
id|DSP_BIND_SURR
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;card-&gt;ac97_status
op_amp
id|CENTER_LFE_ON
)paren
id|val
op_or_assign
id|DSP_BIND_CENTER_LFE
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Not a query, set it */
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_eq
id|DAC_RUNNING
)paren
(brace
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|val
op_amp
id|DSP_BIND_SPDIF
)paren
(brace
multiline_comment|/* Turn on SPDIF */
multiline_comment|/*  Ok, this should probably define what slots&n;&t;&t;&t;&t; *  to use. For now, we&squot;ll only set it to the&n;&t;&t;&t;&t; *  defaults:&n;&t;&t;&t;&t; * &n;&t;&t;&t;&t; *   non multichannel codec maps to slots 3&amp;4&n;&t;&t;&t;&t; *   2 channel codec maps to slots 7&amp;8&n;&t;&t;&t;&t; *   4 channel codec maps to slots 6&amp;9&n;&t;&t;&t;&t; *   6 channel codec maps to slots 10&amp;11&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; *  there should be some way for the app to&n;&t;&t;&t;&t; *  select the slot assignment.&n;&t;&t;&t;&t; */
id|i810_set_spdif_output
(paren
id|state
comma
id|AC97_EA_SPSA_3_4
comma
id|dmabuf-&gt;rate
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|state-&gt;card-&gt;ac97_status
op_amp
id|SPDIF_ON
)paren
)paren
id|val
op_and_assign
op_complement
id|DSP_BIND_SPDIF
suffix:semicolon
)brace
r_else
(brace
r_int
id|mask
suffix:semicolon
r_int
id|channels
suffix:semicolon
multiline_comment|/* Turn off S/PDIF if it was on */
r_if
c_cond
(paren
id|state-&gt;card-&gt;ac97_status
op_amp
id|SPDIF_ON
)paren
id|i810_set_spdif_output
(paren
id|state
comma
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|mask
op_assign
id|val
op_amp
(paren
id|DSP_BIND_FRONT
op_or
id|DSP_BIND_SURR
op_or
id|DSP_BIND_CENTER_LFE
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|mask
)paren
(brace
r_case
id|DSP_BIND_FRONT
suffix:colon
id|channels
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DSP_BIND_FRONT
op_or
id|DSP_BIND_SURR
suffix:colon
id|channels
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DSP_BIND_FRONT
op_or
id|DSP_BIND_SURR
op_or
id|DSP_BIND_CENTER_LFE
suffix:colon
id|channels
op_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|val
op_assign
id|DSP_BIND_FRONT
suffix:semicolon
id|channels
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
)brace
id|i810_set_dac_channels
(paren
id|state
comma
id|channels
)paren
suffix:semicolon
multiline_comment|/* check that they really got turned on */
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;card-&gt;ac97_status
op_amp
id|SURR_ON
)paren
id|val
op_and_assign
op_complement
id|DSP_BIND_SURR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;card-&gt;ac97_status
op_amp
id|CENTER_LFE_ON
)paren
id|val
op_and_assign
op_complement
id|DSP_BIND_CENTER_LFE
suffix:semicolon
)brace
)brace
r_return
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SNDCTL_DSP_MAPINBUF
suffix:colon
r_case
id|SNDCTL_DSP_MAPOUTBUF
suffix:colon
r_case
id|SNDCTL_DSP_SETSYNCRO
suffix:colon
r_case
id|SOUND_PCM_WRITE_FILTER
suffix:colon
r_case
id|SOUND_PCM_READ_FILTER
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SNDCTL_* -EINVAL&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|i810_open
r_static
r_int
id|i810_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_struct
id|i810_card
op_star
id|card
op_assign
id|devs
suffix:semicolon
r_struct
id|i810_state
op_star
id|state
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* find an avaiable virtual channel (instance of /dev/dsp) */
r_while
c_loop
(paren
id|card
op_ne
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_HW_CH
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|card-&gt;states
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
(brace
id|state
op_assign
id|card-&gt;states
(braket
id|i
)braket
op_assign
(paren
r_struct
id|i810_state
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|i810_state
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|state
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|i810_state
)paren
)paren
suffix:semicolon
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_goto
id|found_virt
suffix:semicolon
)brace
)brace
id|card
op_assign
id|card-&gt;next
suffix:semicolon
)brace
multiline_comment|/* no more virtual channel avaiable */
r_if
c_cond
(paren
op_logical_neg
id|state
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|found_virt
suffix:colon
multiline_comment|/* initialize the virtual channel */
id|state-&gt;virt
op_assign
id|i
suffix:semicolon
id|state-&gt;card
op_assign
id|card
suffix:semicolon
id|state-&gt;magic
op_assign
id|I810_STATE_MAGIC
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|state-&gt;open_sem
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
id|state
suffix:semicolon
id|dmabuf-&gt;trigger
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* allocate hardware channels */
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
(paren
id|dmabuf-&gt;read_channel
op_assign
id|card
op_member_access_from_pointer
id|alloc_rec_pcm_channel
c_func
(paren
id|card
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|kfree
(paren
id|card-&gt;states
(braket
id|i
)braket
)paren
suffix:semicolon
id|card-&gt;states
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|i810_set_adc_rate
c_func
(paren
id|state
comma
l_int|8000
)paren
suffix:semicolon
id|dmabuf-&gt;trigger
op_or_assign
id|PCM_ENABLE_INPUT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
(paren
id|dmabuf-&gt;write_channel
op_assign
id|card
op_member_access_from_pointer
id|alloc_pcm_channel
c_func
(paren
id|card
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|kfree
(paren
id|card-&gt;states
(braket
id|i
)braket
)paren
suffix:semicolon
id|card-&gt;states
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* Initialize to 8kHz?  What if we don&squot;t support 8kHz? */
multiline_comment|/*  Let&squot;s change this to check for S/PDIF stuff */
r_if
c_cond
(paren
id|spdif_locked
)paren
(brace
id|i810_set_dac_rate
c_func
(paren
id|state
comma
id|spdif_locked
)paren
suffix:semicolon
id|i810_set_spdif_output
c_func
(paren
id|state
comma
id|AC97_EA_SPSA_3_4
comma
id|spdif_locked
)paren
suffix:semicolon
)brace
r_else
(brace
id|i810_set_dac_rate
c_func
(paren
id|state
comma
l_int|8000
)paren
suffix:semicolon
)brace
id|dmabuf-&gt;trigger
op_or_assign
id|PCM_ENABLE_OUTPUT
suffix:semicolon
)brace
multiline_comment|/* set default sample format. According to OSS Programmer&squot;s Guide  /dev/dsp&n;&t;   should be default to unsigned 8-bits, mono, with sample rate 8kHz and&n;&t;   /dev/dspW will accept 16-bits sample, but we don&squot;t support those so we&n;&t;   set it immediately to stereo and 16bit, which is all we do support */
id|dmabuf-&gt;fmt
op_or_assign
id|I810_FMT_16BIT
op_or
id|I810_FMT_STEREO
suffix:semicolon
id|dmabuf-&gt;ossfragsize
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;ossmaxfrags
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;subdivision
op_assign
l_int|0
suffix:semicolon
id|state-&gt;open_mode
op_or_assign
id|file-&gt;f_mode
op_amp
(paren
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|i810_release
r_static
r_int
id|i810_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|i810_state
op_star
id|state
op_assign
(paren
r_struct
id|i810_state
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|i810_card
op_star
id|card
op_assign
id|state-&gt;card
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* stop DMA state machine and free DMA buffers/channels */
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
op_logical_or
(paren
id|dmabuf-&gt;count
op_logical_and
(paren
id|dmabuf-&gt;trigger
op_amp
id|PCM_ENABLE_OUTPUT
)paren
)paren
)paren
(brace
id|drain_dac
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|ADC_RUNNING
)paren
(brace
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|dealloc_dmabuf
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|state-&gt;card
op_member_access_from_pointer
id|free_pcm_channel
c_func
(paren
id|state-&gt;card
comma
id|dmabuf-&gt;write_channel-&gt;num
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|state-&gt;card
op_member_access_from_pointer
id|free_pcm_channel
c_func
(paren
id|state-&gt;card
comma
id|dmabuf-&gt;read_channel-&gt;num
)paren
suffix:semicolon
)brace
id|state-&gt;card-&gt;states
(braket
id|state-&gt;virt
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|state
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|i810_audio_fops
r_static
multiline_comment|/*const*/
r_struct
id|file_operations
id|i810_audio_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|llseek
suffix:colon
id|no_llseek
comma
id|read
suffix:colon
id|i810_read
comma
id|write
suffix:colon
id|i810_write
comma
id|poll
suffix:colon
id|i810_poll
comma
id|ioctl
suffix:colon
id|i810_ioctl
comma
id|mmap
suffix:colon
id|i810_mmap
comma
id|open
suffix:colon
id|i810_open
comma
id|release
suffix:colon
id|i810_release
comma
)brace
suffix:semicolon
multiline_comment|/* Write AC97 codec registers */
DECL|function|i810_ac97_get
r_static
id|u16
id|i810_ac97_get
c_func
(paren
r_struct
id|ac97_codec
op_star
id|dev
comma
id|u8
id|reg
)paren
(brace
r_struct
id|i810_card
op_star
id|card
op_assign
id|dev-&gt;private_data
suffix:semicolon
r_int
id|count
op_assign
l_int|100
suffix:semicolon
id|u8
id|reg_set
op_assign
(paren
(paren
id|dev-&gt;id
)paren
ques
c_cond
(paren
(paren
id|reg
op_amp
l_int|0x7f
)paren
op_or
l_int|0x80
)paren
suffix:colon
(paren
id|reg
op_amp
l_int|0x7f
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
op_logical_and
(paren
id|inb
c_func
(paren
id|card-&gt;iobase
op_plus
id|CAS
)paren
op_amp
l_int|1
)paren
)paren
(brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|inw
c_func
(paren
id|card-&gt;ac97base
op_plus
id|reg_set
)paren
suffix:semicolon
)brace
DECL|function|i810_ac97_set
r_static
r_void
id|i810_ac97_set
c_func
(paren
r_struct
id|ac97_codec
op_star
id|dev
comma
id|u8
id|reg
comma
id|u16
id|data
)paren
(brace
r_struct
id|i810_card
op_star
id|card
op_assign
id|dev-&gt;private_data
suffix:semicolon
r_int
id|count
op_assign
l_int|100
suffix:semicolon
id|u8
id|reg_set
op_assign
(paren
(paren
id|dev-&gt;id
)paren
ques
c_cond
(paren
(paren
id|reg
op_amp
l_int|0x7f
)paren
op_or
l_int|0x80
)paren
suffix:colon
(paren
id|reg
op_amp
l_int|0x7f
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
op_logical_and
(paren
id|inb
c_func
(paren
id|card-&gt;iobase
op_plus
id|CAS
)paren
op_amp
l_int|1
)paren
)paren
(brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|outw
c_func
(paren
id|data
comma
id|card-&gt;ac97base
op_plus
id|reg_set
)paren
suffix:semicolon
)brace
multiline_comment|/* OSS /dev/mixer file operation methods */
DECL|function|i810_open_mixdev
r_static
r_int
id|i810_open_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|i810_card
op_star
id|card
op_assign
id|devs
suffix:semicolon
r_for
c_loop
(paren
id|card
op_assign
id|devs
suffix:semicolon
id|card
op_ne
l_int|NULL
suffix:semicolon
id|card
op_assign
id|card-&gt;next
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_AC97
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_ne
l_int|NULL
op_logical_and
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_member_access_from_pointer
id|dev_mixer
op_eq
id|minor
)paren
(brace
id|file-&gt;private_data
op_assign
id|card-&gt;ac97_codec
(braket
id|i
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|i810_ioctl_mixdev
r_static
r_int
id|i810_ioctl_mixdev
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|ac97_codec
op_star
id|codec
op_assign
(paren
r_struct
id|ac97_codec
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_return
id|codec
op_member_access_from_pointer
id|mixer_ioctl
c_func
(paren
id|codec
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
DECL|variable|i810_mixer_fops
r_static
multiline_comment|/*const*/
r_struct
id|file_operations
id|i810_mixer_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|llseek
suffix:colon
id|no_llseek
comma
id|ioctl
suffix:colon
id|i810_ioctl_mixdev
comma
id|open
suffix:colon
id|i810_open_mixdev
comma
)brace
suffix:semicolon
multiline_comment|/* AC97 codec initialisation.  These small functions exist so we don&squot;t&n;   duplicate code between module init and apm resume */
DECL|function|i810_ac97_exists
r_static
r_inline
r_int
id|i810_ac97_exists
c_func
(paren
r_struct
id|i810_card
op_star
id|card
comma
r_int
id|ac97_number
)paren
(brace
id|u32
id|reg
op_assign
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|GLOB_STA
)paren
suffix:semicolon
r_return
(paren
id|reg
op_amp
(paren
l_int|0x100
op_lshift
id|ac97_number
)paren
)paren
suffix:semicolon
)brace
DECL|function|i810_ac97_enable_variable_rate
r_static
r_inline
r_int
id|i810_ac97_enable_variable_rate
c_func
(paren
r_struct
id|ac97_codec
op_star
id|codec
)paren
(brace
id|i810_ac97_set
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
comma
l_int|9
)paren
suffix:semicolon
id|i810_ac97_set
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
comma
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
)paren
op_or
l_int|0xE800
)paren
suffix:semicolon
r_return
(paren
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_STATUS
)paren
op_amp
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|i810_ac97_probe_and_powerup
r_static
r_int
id|i810_ac97_probe_and_powerup
c_func
(paren
r_struct
id|i810_card
op_star
id|card
comma
r_struct
id|ac97_codec
op_star
id|codec
)paren
(brace
multiline_comment|/* Returns 0 on failure */
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|ac97_probe_codec
c_func
(paren
id|codec
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* power it all up */
id|i810_ac97_set
c_func
(paren
id|codec
comma
id|AC97_POWER_CONTROL
comma
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_POWER_CONTROL
)paren
op_amp
op_complement
l_int|0x7f00
)paren
suffix:semicolon
multiline_comment|/* wait for analog ready */
r_for
c_loop
(paren
id|i
op_assign
l_int|10
suffix:semicolon
id|i
op_logical_and
(paren
(paren
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_POWER_CONTROL
)paren
op_amp
l_int|0xf
)paren
op_ne
l_int|0xf
)paren
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|20
)paren
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/* if I knew what this did, I&squot;d give it a better name */
DECL|function|i810_ac97_random_init_stuff
r_static
r_int
id|i810_ac97_random_init_stuff
c_func
(paren
r_struct
id|i810_card
op_star
id|card
)paren
(brace
id|u32
id|reg
op_assign
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|GLOB_CNT
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reg
op_amp
l_int|2
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Cold required */
id|reg
op_or_assign
l_int|2
suffix:semicolon
)brace
r_else
id|reg
op_or_assign
l_int|4
suffix:semicolon
multiline_comment|/* Warm */
id|reg
op_and_assign
op_complement
l_int|8
suffix:semicolon
multiline_comment|/* ACLink on */
id|outl
c_func
(paren
id|reg
comma
id|card-&gt;iobase
op_plus
id|GLOB_CNT
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|GLOB_CNT
)paren
op_amp
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|20
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|10
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i810_audio: AC&squot;97 reset failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|2
)paren
suffix:semicolon
id|reg
op_assign
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|GLOB_STA
)paren
suffix:semicolon
id|inw
c_func
(paren
id|card-&gt;ac97base
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|i810_ac97_init
r_static
r_int
id|__init
id|i810_ac97_init
c_func
(paren
r_struct
id|i810_card
op_star
id|card
)paren
(brace
r_int
id|num_ac97
op_assign
l_int|0
suffix:semicolon
r_int
id|total_channels
op_assign
l_int|0
suffix:semicolon
r_struct
id|ac97_codec
op_star
id|codec
suffix:semicolon
id|u16
id|eid
suffix:semicolon
id|u32
id|reg
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i810_ac97_random_init_stuff
c_func
(paren
id|card
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Number of channels supported */
multiline_comment|/* What about the codec?  Just because the ICH supports */
multiline_comment|/* multiple channels doesn&squot;t mean the codec does.       */
multiline_comment|/* we&squot;ll have to modify this in the codec section below */
multiline_comment|/* to reflect what the codec has.                       */
multiline_comment|/* ICH and ICH0 only support 2 channels so don&squot;t bother */
multiline_comment|/* to check....                                         */
id|card-&gt;channels
op_assign
l_int|2
suffix:semicolon
id|reg
op_assign
id|inl
c_func
(paren
id|card-&gt;iobase
op_plus
id|GLOB_STA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_amp
l_int|0x0200000
)paren
id|card-&gt;channels
op_assign
l_int|6
suffix:semicolon
r_else
r_if
c_cond
(paren
id|reg
op_amp
l_int|0x0100000
)paren
id|card-&gt;channels
op_assign
l_int|4
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;i810_audio: Audio Controller supports %d channels.&bslash;n&quot;
comma
id|card-&gt;channels
)paren
suffix:semicolon
id|inw
c_func
(paren
id|card-&gt;ac97base
)paren
suffix:semicolon
r_for
c_loop
(paren
id|num_ac97
op_assign
l_int|0
suffix:semicolon
id|num_ac97
OL
id|NR_AC97
suffix:semicolon
id|num_ac97
op_increment
)paren
(brace
multiline_comment|/* Assume codec isn&squot;t available until we go through the&n;&t;&t; * gauntlet below */
id|card-&gt;ac97_codec
(braket
id|num_ac97
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* The ICH programmer&squot;s reference says you should   */
multiline_comment|/* check the ready status before probing. So we chk */
multiline_comment|/*   What do we do if it&squot;s not ready?  Wait and try */
multiline_comment|/*   again, or abort?                               */
r_if
c_cond
(paren
op_logical_neg
id|i810_ac97_exists
c_func
(paren
id|card
comma
id|num_ac97
)paren
)paren
(brace
r_if
c_cond
(paren
id|num_ac97
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i810_audio: Primary codec not ready.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* I think this works, if not ready stop */
)brace
r_if
c_cond
(paren
(paren
id|codec
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ac97_codec
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|codec
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ac97_codec
)paren
)paren
suffix:semicolon
multiline_comment|/* initialize some basic codec information, other fields will be filled&n;&t;&t;   in ac97_probe_codec */
id|codec-&gt;private_data
op_assign
id|card
suffix:semicolon
id|codec-&gt;id
op_assign
id|num_ac97
suffix:semicolon
id|codec-&gt;codec_read
op_assign
id|i810_ac97_get
suffix:semicolon
id|codec-&gt;codec_write
op_assign
id|i810_ac97_set
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i810_ac97_probe_and_powerup
c_func
(paren
id|card
comma
id|codec
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;i810_audio: timed out waiting for codec %d analog ready&quot;
comma
id|num_ac97
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|codec
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* it didn&squot;t work */
)brace
multiline_comment|/* Store state information about S/PDIF transmitter */
id|card-&gt;ac97_status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Don&squot;t attempt to get eid until powerup is complete */
id|eid
op_assign
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_ID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eid
op_eq
l_int|0xFFFFFF
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i810_audio: no codec attached ?&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|codec
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|card-&gt;ac97_features
op_assign
id|eid
suffix:semicolon
multiline_comment|/* Now check the codec for useful features to make up for&n;&t;&t;   the dumbness of the 810 hardware engine */
r_if
c_cond
(paren
op_logical_neg
(paren
id|eid
op_amp
l_int|0x0001
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i810_audio: only 48Khz playback available.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|i810_ac97_enable_variable_rate
c_func
(paren
id|codec
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i810_audio: Codec refused to allow VRA, using 48Khz only.&bslash;n&quot;
)paren
suffix:semicolon
id|card-&gt;ac97_features
op_and_assign
op_complement
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Determine how many channels the codec(s) support   */
multiline_comment|/*   - The primary codec always supports 2            */
multiline_comment|/*   - If the codec supports AMAP, surround DACs will */
multiline_comment|/*     automaticlly get assigned to slots.            */
multiline_comment|/*     * Check for surround DACs and increment if     */
multiline_comment|/*       found.                                       */
multiline_comment|/*   - Else check if the codec is revision 2.2        */
multiline_comment|/*     * If surround DACs exist, assign them to slots */
multiline_comment|/*       and increment channel count.                 */
multiline_comment|/* All of this only applies to ICH2 and above. ICH    */
multiline_comment|/* and ICH0 only support 2 channels.  ICH2 will only  */
multiline_comment|/* support multiple codecs in a &quot;split audio&quot; config. */
multiline_comment|/* as described above.                                */
multiline_comment|/* TODO: Remove all the debugging messages!           */
r_if
c_cond
(paren
(paren
id|eid
op_amp
l_int|0xc000
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* primary codec */
id|total_channels
op_add_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eid
op_amp
l_int|0x200
)paren
(brace
multiline_comment|/* GOOD, AMAP support */
r_if
c_cond
(paren
id|eid
op_amp
l_int|0x0080
)paren
multiline_comment|/* L/R Surround channels */
id|total_channels
op_add_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|eid
op_amp
l_int|0x0140
)paren
multiline_comment|/* LFE and Center channels */
id|total_channels
op_add_assign
l_int|2
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;i810_audio: AC&squot;97 codec %d supports AMAP, total channels = %d&bslash;n&quot;
comma
id|num_ac97
comma
id|total_channels
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|eid
op_amp
l_int|0x0400
)paren
(brace
multiline_comment|/* this only works on 2.2 compliant codecs */
id|eid
op_and_assign
l_int|0xffcf
suffix:semicolon
r_if
c_cond
(paren
(paren
id|eid
op_amp
l_int|0xc000
)paren
op_ne
l_int|0
)paren
(brace
r_switch
c_cond
(paren
id|total_channels
)paren
(brace
r_case
l_int|2
suffix:colon
multiline_comment|/* Set dsa1, dsa0 to 01 */
id|eid
op_or_assign
l_int|0x0010
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
multiline_comment|/* Set dsa1, dsa0 to 10 */
id|eid
op_or_assign
l_int|0x0020
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
multiline_comment|/* Set dsa1, dsa0 to 11 */
id|eid
op_or_assign
l_int|0x0030
suffix:semicolon
r_break
suffix:semicolon
)brace
id|total_channels
op_add_assign
l_int|2
suffix:semicolon
)brace
id|i810_ac97_set
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_ID
comma
id|eid
)paren
suffix:semicolon
id|eid
op_assign
id|i810_ac97_get
c_func
(paren
id|codec
comma
id|AC97_EXTENDED_ID
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;i810_audio: AC&squot;97 codec %d, new EID value = 0x%04x&bslash;n&quot;
comma
id|num_ac97
comma
id|eid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eid
op_amp
l_int|0x0080
)paren
multiline_comment|/* L/R Surround channels */
id|total_channels
op_add_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|eid
op_amp
l_int|0x0140
)paren
multiline_comment|/* LFE and Center channels */
id|total_channels
op_add_assign
l_int|2
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;i810_audio: AC&squot;97 codec %d, DAC map configured, total channels = %d&bslash;n&quot;
comma
id|num_ac97
comma
id|total_channels
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;i810_audio: AC&squot;97 codec %d Unable to map surround DAC&squot;s (or DAC&squot;s not present), total channels = %d&bslash;n&quot;
comma
id|num_ac97
comma
id|total_channels
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|codec-&gt;dev_mixer
op_assign
id|register_sound_mixer
c_func
(paren
op_amp
id|i810_mixer_fops
comma
op_minus
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i810_audio: couldn&squot;t register mixer!&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|codec
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|card-&gt;ac97_codec
(braket
id|num_ac97
)braket
op_assign
id|codec
suffix:semicolon
)brace
multiline_comment|/* pick the minimum of channels supported by ICHx or codec(s) */
id|card-&gt;channels
op_assign
(paren
id|card-&gt;channels
OG
id|total_channels
)paren
ques
c_cond
id|total_channels
suffix:colon
id|card-&gt;channels
suffix:semicolon
r_return
id|num_ac97
suffix:semicolon
)brace
DECL|function|i810_configure_clocking
r_static
r_void
id|__init
id|i810_configure_clocking
(paren
r_void
)paren
(brace
r_struct
id|i810_card
op_star
id|card
suffix:semicolon
r_struct
id|i810_state
op_star
id|state
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
suffix:semicolon
r_int
r_int
id|i
comma
id|offset
comma
id|new_offset
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|card
op_assign
id|devs
suffix:semicolon
multiline_comment|/* We could try to set the clocking for multiple cards, but can you even have&n;&t; * more than one i810 in a machine?  Besides, clocking is global, so unless&n;&t; * someone actually thinks more than one i810 in a machine is possible and&n;&t; * decides to rewrite that little bit, setting the rate for more than one card&n;&t; * is a waste of time.&n;&t; */
r_if
c_cond
(paren
id|card
op_ne
l_int|NULL
)paren
(brace
id|state
op_assign
id|card-&gt;states
(braket
l_int|0
)braket
op_assign
(paren
r_struct
id|i810_state
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|i810_state
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|memset
c_func
(paren
id|state
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|i810_state
)paren
)paren
suffix:semicolon
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
id|dmabuf-&gt;write_channel
op_assign
id|card
op_member_access_from_pointer
id|alloc_pcm_channel
c_func
(paren
id|card
)paren
suffix:semicolon
id|state-&gt;virt
op_assign
l_int|0
suffix:semicolon
id|state-&gt;card
op_assign
id|card
suffix:semicolon
id|state-&gt;magic
op_assign
id|I810_STATE_MAGIC
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|dmabuf-&gt;wait
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|state-&gt;open_sem
)paren
suffix:semicolon
id|dmabuf-&gt;fmt
op_assign
id|I810_FMT_STEREO
op_or
id|I810_FMT_16BIT
suffix:semicolon
id|dmabuf-&gt;trigger
op_assign
id|PCM_ENABLE_OUTPUT
suffix:semicolon
id|i810_set_dac_rate
c_func
(paren
id|state
comma
l_int|48000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prog_dmabuf
c_func
(paren
id|state
comma
l_int|0
)paren
op_ne
l_int|0
)paren
(brace
r_goto
id|config_out_nodmabuf
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;dmasize
OL
l_int|16384
)paren
(brace
r_goto
id|config_out
suffix:semicolon
)brace
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;dmasize
suffix:semicolon
id|outb
c_func
(paren
l_int|31
comma
id|card-&gt;iobase
op_plus
id|dmabuf-&gt;write_channel-&gt;port
op_plus
id|OFF_LVI
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|start_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|offset
op_assign
id|i810_get_dma_addr
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|new_offset
op_assign
id|i810_get_dma_addr
c_func
(paren
id|state
comma
l_int|0
)paren
suffix:semicolon
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|2
comma
id|card-&gt;iobase
op_plus
id|dmabuf-&gt;write_channel-&gt;port
op_plus
id|OFF_CR
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|i
op_assign
id|new_offset
op_minus
id|offset
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;i810_audio: %d bytes in 50 milliseconds&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
r_goto
id|config_out
suffix:semicolon
)brace
id|i
op_assign
id|i
op_div
l_int|4
op_star
l_int|20
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|48500
op_logical_or
id|i
OL
l_int|47500
)paren
(brace
id|clocking
op_assign
id|clocking
op_star
id|clocking
op_div
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;i810_audio: setting clocking to %d&bslash;n&quot;
comma
id|clocking
)paren
suffix:semicolon
)brace
id|config_out
suffix:colon
id|dealloc_dmabuf
c_func
(paren
id|state
)paren
suffix:semicolon
id|config_out_nodmabuf
suffix:colon
id|state-&gt;card
op_member_access_from_pointer
id|free_pcm_channel
c_func
(paren
id|state-&gt;card
comma
id|state-&gt;dmabuf.write_channel-&gt;num
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|state
)paren
suffix:semicolon
id|card-&gt;states
(braket
l_int|0
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* install the driver, we do not allocate hardware channel nor DMA buffer now, they are defered &n;   until &quot;ACCESS&quot; time (in prog_dmabuf called by open/read/write/ioctl/mmap) */
DECL|function|i810_probe
r_static
r_int
id|__init
id|i810_probe
c_func
(paren
r_struct
id|pci_dev
op_star
id|pci_dev
comma
r_const
r_struct
id|pci_device_id
op_star
id|pci_id
)paren
(brace
r_struct
id|i810_card
op_star
id|card
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|pci_dev
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|pci_set_dma_mask
c_func
(paren
id|pci_dev
comma
id|I810_DMA_MASK
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;intel810: architecture does not support&quot;
l_string|&quot; 32bit PCI busmaster DMA&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|card
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|i810_card
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i810_audio: out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|card
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|card
)paren
)paren
suffix:semicolon
id|card-&gt;iobase
op_assign
id|pci_resource_start
(paren
id|pci_dev
comma
l_int|1
)paren
suffix:semicolon
id|card-&gt;ac97base
op_assign
id|pci_resource_start
(paren
id|pci_dev
comma
l_int|0
)paren
suffix:semicolon
id|card-&gt;pci_dev
op_assign
id|pci_dev
suffix:semicolon
id|card-&gt;pci_id
op_assign
id|pci_id-&gt;device
suffix:semicolon
id|card-&gt;irq
op_assign
id|pci_dev-&gt;irq
suffix:semicolon
id|card-&gt;next
op_assign
id|devs
suffix:semicolon
id|card-&gt;magic
op_assign
id|I810_CARD_MAGIC
suffix:semicolon
macro_line|#ifdef CONFIG_PM
id|card-&gt;pm_suspended
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|spin_lock_init
c_func
(paren
op_amp
id|card-&gt;lock
)paren
suffix:semicolon
id|devs
op_assign
id|card
suffix:semicolon
id|pci_set_master
c_func
(paren
id|pci_dev
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;i810: %s found at IO 0x%04lx and 0x%04lx, IRQ %d&bslash;n&quot;
comma
id|card_names
(braket
id|pci_id-&gt;driver_data
)braket
comma
id|card-&gt;iobase
comma
id|card-&gt;ac97base
comma
id|card-&gt;irq
)paren
suffix:semicolon
id|card-&gt;alloc_pcm_channel
op_assign
id|i810_alloc_pcm_channel
suffix:semicolon
id|card-&gt;alloc_rec_pcm_channel
op_assign
id|i810_alloc_rec_pcm_channel
suffix:semicolon
id|card-&gt;alloc_rec_mic_channel
op_assign
id|i810_alloc_rec_mic_channel
suffix:semicolon
id|card-&gt;free_pcm_channel
op_assign
id|i810_free_pcm_channel
suffix:semicolon
id|card-&gt;channel
(braket
l_int|0
)braket
dot
id|offset
op_assign
l_int|0
suffix:semicolon
id|card-&gt;channel
(braket
l_int|0
)braket
dot
id|port
op_assign
l_int|0x00
suffix:semicolon
id|card-&gt;channel
(braket
l_int|0
)braket
dot
id|num
op_assign
l_int|0
suffix:semicolon
id|card-&gt;channel
(braket
l_int|1
)braket
dot
id|offset
op_assign
l_int|0
suffix:semicolon
id|card-&gt;channel
(braket
l_int|1
)braket
dot
id|port
op_assign
l_int|0x10
suffix:semicolon
id|card-&gt;channel
(braket
l_int|1
)braket
dot
id|num
op_assign
l_int|1
suffix:semicolon
id|card-&gt;channel
(braket
l_int|2
)braket
dot
id|offset
op_assign
l_int|0
suffix:semicolon
id|card-&gt;channel
(braket
l_int|2
)braket
dot
id|port
op_assign
l_int|0x20
suffix:semicolon
id|card-&gt;channel
(braket
l_int|2
)braket
dot
id|num
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* claim our iospace and irq */
id|request_region
c_func
(paren
id|card-&gt;iobase
comma
l_int|64
comma
id|card_names
(braket
id|pci_id-&gt;driver_data
)braket
)paren
suffix:semicolon
id|request_region
c_func
(paren
id|card-&gt;ac97base
comma
l_int|256
comma
id|card_names
(braket
id|pci_id-&gt;driver_data
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|card-&gt;irq
comma
op_amp
id|i810_interrupt
comma
id|SA_SHIRQ
comma
id|card_names
(braket
id|pci_id-&gt;driver_data
)braket
comma
id|card
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i810_audio: unable to allocate irq %d&bslash;n&quot;
comma
id|card-&gt;irq
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|card-&gt;iobase
comma
l_int|64
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|card-&gt;ac97base
comma
l_int|256
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* initialize AC97 codec and register /dev/mixer */
r_if
c_cond
(paren
id|i810_ac97_init
c_func
(paren
id|card
)paren
op_le
l_int|0
)paren
(brace
id|release_region
c_func
(paren
id|card-&gt;iobase
comma
l_int|64
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|card-&gt;ac97base
comma
l_int|256
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|card-&gt;irq
comma
id|card
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|pci_set_drvdata
c_func
(paren
id|pci_dev
comma
id|card
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clocking
op_eq
l_int|48000
)paren
(brace
id|i810_configure_clocking
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* register /dev/dsp */
r_if
c_cond
(paren
(paren
id|card-&gt;dev_audio
op_assign
id|register_sound_dsp
c_func
(paren
op_amp
id|i810_audio_fops
comma
op_minus
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i810_audio: couldn&squot;t register DSP device!&bslash;n&quot;
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|card-&gt;iobase
comma
l_int|64
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|card-&gt;ac97base
comma
l_int|256
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|card-&gt;irq
comma
id|card
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_AC97
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
id|unregister_sound_mixer
c_func
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_member_access_from_pointer
id|dev_mixer
)paren
suffix:semicolon
id|kfree
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|i810_remove
r_static
r_void
id|__exit
id|i810_remove
c_func
(paren
r_struct
id|pci_dev
op_star
id|pci_dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|i810_card
op_star
id|card
op_assign
id|pci_get_drvdata
c_func
(paren
id|pci_dev
)paren
suffix:semicolon
multiline_comment|/* free hardware resources */
id|free_irq
c_func
(paren
id|card-&gt;irq
comma
id|devs
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|card-&gt;iobase
comma
l_int|64
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|card-&gt;ac97base
comma
l_int|256
)paren
suffix:semicolon
multiline_comment|/* unregister audio devices */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_AC97
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
id|unregister_sound_mixer
c_func
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
op_member_access_from_pointer
id|dev_mixer
)paren
suffix:semicolon
id|kfree
(paren
id|card-&gt;ac97_codec
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|unregister_sound_dsp
c_func
(paren
id|card-&gt;dev_audio
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|card
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PM
DECL|function|i810_pm_suspend
r_static
r_int
id|i810_pm_suspend
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
id|u32
id|pm_state
)paren
(brace
r_struct
id|i810_card
op_star
id|card
op_assign
id|pci_get_drvdata
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|i810_state
op_star
id|state
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|dmabuf
op_star
id|dmabuf
suffix:semicolon
r_int
id|i
comma
id|num_ac97
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;i810_audio: i810_pm_suspend called&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|card
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|card-&gt;pm_suspended
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_HW_CH
suffix:semicolon
id|i
op_increment
)paren
(brace
id|state
op_assign
id|card-&gt;states
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* this happens only if there are open files */
id|dmabuf
op_assign
op_amp
id|state-&gt;dmabuf
suffix:semicolon
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|DAC_RUNNING
op_logical_or
(paren
id|dmabuf-&gt;count
op_logical_and
(paren
id|dmabuf-&gt;trigger
op_amp
id|PCM_ENABLE_OUTPUT
)paren
)paren
)paren
(brace
id|state-&gt;pm_saved_dac_rate
op_assign
id|dmabuf-&gt;rate
suffix:semicolon
id|stop_dac
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_else
(brace
id|state-&gt;pm_saved_dac_rate
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmabuf-&gt;enable
op_amp
id|ADC_RUNNING
)paren
(brace
id|state-&gt;pm_saved_adc_rate
op_assign
id|dmabuf-&gt;rate
suffix:semicolon
id|stop_adc
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
r_else
(brace
id|state-&gt;pm_saved_adc_rate
op_assign
l_int|0
suffix:semicolon
)brace
id|dmabuf-&gt;ready
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;swptr
op_assign
id|dmabuf-&gt;hwptr
op_assign
l_int|0
suffix:semicolon
id|dmabuf-&gt;count
op_assign
id|dmabuf-&gt;total_bytes
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|card-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* save mixer settings */
r_for
c_loop
(paren
id|num_ac97
op_assign
l_int|0
suffix:semicolon
id|num_ac97
OL
id|NR_AC97
suffix:semicolon
id|num_ac97
op_increment
)paren
(brace
r_struct
id|ac97_codec
op_star
id|codec
op_assign
id|card-&gt;ac97_codec
(braket
id|num_ac97
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|codec
)paren
(brace
r_continue
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SOUND_MIXER_NRDEVICES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|supported_mixer
c_func
(paren
id|codec
comma
id|i
)paren
)paren
op_logical_and
(paren
id|codec-&gt;read_mixer
)paren
)paren
(brace
id|card-&gt;pm_saved_mixer_settings
(braket
id|i
)braket
(braket
id|num_ac97
)braket
op_assign
id|codec
op_member_access_from_pointer
id|read_mixer
c_func
(paren
id|codec
comma
id|i
)paren
suffix:semicolon
)brace
)brace
)brace
id|pci_save_state
c_func
(paren
id|dev
comma
id|card-&gt;pm_save_state
)paren
suffix:semicolon
multiline_comment|/* XXX do we need this? */
id|pci_disable_device
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* disable busmastering */
id|pci_set_power_state
c_func
(paren
id|dev
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/* Zzz. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|i810_pm_resume
r_static
r_int
id|i810_pm_resume
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_int
id|num_ac97
comma
id|i
op_assign
l_int|0
suffix:semicolon
r_struct
id|i810_card
op_star
id|card
op_assign
id|pci_get_drvdata
c_func
(paren
id|dev
)paren
suffix:semicolon
id|pci_enable_device
c_func
(paren
id|dev
)paren
suffix:semicolon
id|pci_restore_state
(paren
id|dev
comma
id|card-&gt;pm_save_state
)paren
suffix:semicolon
multiline_comment|/* observation of a toshiba portege 3440ct suggests that the &n;&t;   hardware has to be more or less completely reinitialized from&n;&t;   scratch after an apm suspend.  Works For Me.   -dan */
id|i810_ac97_random_init_stuff
c_func
(paren
id|card
)paren
suffix:semicolon
r_for
c_loop
(paren
id|num_ac97
op_assign
l_int|0
suffix:semicolon
id|num_ac97
OL
id|NR_AC97
suffix:semicolon
id|num_ac97
op_increment
)paren
(brace
r_struct
id|ac97_codec
op_star
id|codec
op_assign
id|card-&gt;ac97_codec
(braket
id|num_ac97
)braket
suffix:semicolon
multiline_comment|/* check they haven&squot;t stolen the hardware while we were&n;&t;&t;   away */
r_if
c_cond
(paren
op_logical_neg
id|codec
op_logical_or
op_logical_neg
id|i810_ac97_exists
c_func
(paren
id|card
comma
id|num_ac97
)paren
)paren
(brace
r_if
c_cond
(paren
id|num_ac97
)paren
(brace
r_continue
suffix:semicolon
)brace
r_else
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|i810_ac97_probe_and_powerup
c_func
(paren
id|card
comma
id|codec
)paren
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|card-&gt;ac97_features
op_amp
l_int|0x0001
)paren
)paren
(brace
multiline_comment|/* at probe time we found we could do variable&n;&t;&t;&t;   rates, but APM suspend has made it forget&n;&t;&t;&t;   its magical powers */
r_if
c_cond
(paren
op_logical_neg
id|i810_ac97_enable_variable_rate
c_func
(paren
id|codec
)paren
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* we lost our mixer settings, so restore them */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SOUND_MIXER_NRDEVICES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|supported_mixer
c_func
(paren
id|codec
comma
id|i
)paren
)paren
(brace
r_int
id|val
op_assign
id|card
op_member_access_from_pointer
id|pm_saved_mixer_settings
(braket
id|i
)braket
(braket
id|num_ac97
)braket
suffix:semicolon
id|codec-&gt;mixer_state
(braket
id|i
)braket
op_assign
id|val
suffix:semicolon
id|codec
op_member_access_from_pointer
id|write_mixer
c_func
(paren
id|codec
comma
id|i
comma
(paren
id|val
op_amp
l_int|0xff
)paren
comma
(paren
(paren
id|val
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* we need to restore the sample rate from whatever it was */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_HW_CH
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|i810_state
op_star
id|state
op_assign
id|card-&gt;states
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
r_if
c_cond
(paren
id|state-&gt;pm_saved_adc_rate
)paren
(brace
id|i810_set_adc_rate
c_func
(paren
id|state
comma
id|state-&gt;pm_saved_adc_rate
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|state-&gt;pm_saved_dac_rate
)paren
(brace
id|i810_set_dac_rate
c_func
(paren
id|state
comma
id|state-&gt;pm_saved_dac_rate
)paren
suffix:semicolon
)brace
)brace
)brace
id|card-&gt;pm_suspended
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* any processes that were reading/writing during the suspend&n;&t;   probably ended up here */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_HW_CH
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|i810_state
op_star
id|state
op_assign
id|card-&gt;states
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|state-&gt;dmabuf.wait
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PM */
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Intel 810 audio support&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|ftsodell
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|clocking
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|strict_clocking
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|spdif_locked
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|macro|I810_MODULE_NAME
mdefine_line|#define I810_MODULE_NAME &quot;intel810_audio&quot;
DECL|variable|i810_pci_driver
r_static
r_struct
id|pci_driver
id|i810_pci_driver
op_assign
(brace
id|name
suffix:colon
id|I810_MODULE_NAME
comma
id|id_table
suffix:colon
id|i810_pci_tbl
comma
id|probe
suffix:colon
id|i810_probe
comma
id|remove
suffix:colon
id|i810_remove
comma
macro_line|#ifdef CONFIG_PM
id|suspend
suffix:colon
id|i810_pm_suspend
comma
id|resume
suffix:colon
id|i810_pm_resume
comma
macro_line|#endif /* CONFIG_PM */
)brace
suffix:semicolon
DECL|function|i810_init_module
r_static
r_int
id|__init
id|i810_init_module
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pci_present
c_func
(paren
)paren
)paren
multiline_comment|/* No PCI bus in this machine! */
r_return
op_minus
id|ENODEV
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Intel 810 + AC97 Audio, version &quot;
id|DRIVER_VERSION
l_string|&quot;, &quot;
id|__TIME__
l_string|&quot; &quot;
id|__DATE__
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_register_driver
c_func
(paren
op_amp
id|i810_pci_driver
)paren
)paren
(brace
id|pci_unregister_driver
c_func
(paren
op_amp
id|i810_pci_driver
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ftsodell
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;i810_audio: ftsodell is now a deprecated option.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|clocking
op_eq
l_int|48000
)paren
(brace
id|i810_configure_clocking
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|spdif_locked
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|spdif_locked
op_eq
l_int|32000
op_logical_or
id|spdif_locked
op_eq
l_int|44100
op_logical_or
id|spdif_locked
op_eq
l_int|48000
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;i810_audio: Enabling S/PDIF at sample rate %dHz.&bslash;n&quot;
comma
id|spdif_locked
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;i810_audio: S/PDIF can only be locked to 32000, 441000, or 48000Hz.&bslash;n&quot;
)paren
suffix:semicolon
id|spdif_locked
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|i810_cleanup_module
r_static
r_void
id|__exit
id|i810_cleanup_module
(paren
r_void
)paren
(brace
id|pci_unregister_driver
c_func
(paren
op_amp
id|i810_pci_driver
)paren
suffix:semicolon
)brace
DECL|variable|i810_init_module
id|module_init
c_func
(paren
id|i810_init_module
)paren
suffix:semicolon
DECL|variable|i810_cleanup_module
id|module_exit
c_func
(paren
id|i810_cleanup_module
)paren
suffix:semicolon
multiline_comment|/*&n;Local Variables:&n;c-basic-offset: 8&n;End:&n;*/
eof
