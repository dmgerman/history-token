multiline_comment|/*&n; * ACPI PCI HotPlug Utility functions&n; *&n; * Copyright (C) 1995,2001 Compaq Computer Corporation&n; * Copyright (C) 2001 Greg Kroah-Hartman (greg@kroah.com)&n; * Copyright (C) 2001 IBM Corp.&n; * Copyright (C) 2002 Hiroshi Aono (h-aono@ap.jp.nec.com)&n; * Copyright (C) 2002 Takayoshi Kochi (t-kochi@bq.jp.nec.com)&n; * Copyright (C) 2002 NEC Corporation&n; *&n; * All rights reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or (at&n; * your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or&n; * NON INFRINGEMENT.  See the GNU General Public License for more&n; * details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; * Send feedback to &lt;gregkh@us.ibm.com&gt;, &lt;t-kochi@bq.jp.nec.com&gt;&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/ioctl.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &quot;pci_hotplug.h&quot;
macro_line|#include &quot;acpiphp.h&quot;
DECL|macro|MY_NAME
mdefine_line|#define MY_NAME &quot;acpiphp_res&quot;
multiline_comment|/*&n; * sort_by_size - sort nodes by their length, smallest first&n; */
DECL|function|sort_by_size
r_static
r_int
id|sort_by_size
c_func
(paren
r_struct
id|pci_resource
op_star
op_star
id|head
)paren
(brace
r_struct
id|pci_resource
op_star
id|current_res
suffix:semicolon
r_struct
id|pci_resource
op_star
id|next_res
suffix:semicolon
r_int
id|out_of_order
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|head
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|out_of_order
)paren
(brace
id|out_of_order
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Special case for swapping list head */
r_if
c_cond
(paren
(paren
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
)paren
op_logical_and
(paren
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|length
OG
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next-&gt;length
)paren
)paren
(brace
id|out_of_order
op_increment
suffix:semicolon
id|current_res
op_assign
op_star
id|head
suffix:semicolon
op_star
id|head
op_assign
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|current_res-&gt;next
op_assign
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
op_assign
id|current_res
suffix:semicolon
)brace
id|current_res
op_assign
op_star
id|head
suffix:semicolon
r_while
c_loop
(paren
id|current_res-&gt;next
op_logical_and
id|current_res-&gt;next-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|current_res-&gt;next-&gt;length
OG
id|current_res-&gt;next-&gt;next-&gt;length
)paren
(brace
id|out_of_order
op_increment
suffix:semicolon
id|next_res
op_assign
id|current_res-&gt;next
suffix:semicolon
id|current_res-&gt;next
op_assign
id|current_res-&gt;next-&gt;next
suffix:semicolon
id|current_res
op_assign
id|current_res-&gt;next
suffix:semicolon
id|next_res-&gt;next
op_assign
id|current_res-&gt;next
suffix:semicolon
id|current_res-&gt;next
op_assign
id|next_res
suffix:semicolon
)brace
r_else
id|current_res
op_assign
id|current_res-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/* End of out_of_order loop */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * sort_by_max_size - sort nodes by their length, largest first&n; */
DECL|function|sort_by_max_size
r_static
r_int
id|sort_by_max_size
c_func
(paren
r_struct
id|pci_resource
op_star
op_star
id|head
)paren
(brace
r_struct
id|pci_resource
op_star
id|current_res
suffix:semicolon
r_struct
id|pci_resource
op_star
id|next_res
suffix:semicolon
r_int
id|out_of_order
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|head
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|out_of_order
)paren
(brace
id|out_of_order
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Special case for swapping list head */
r_if
c_cond
(paren
(paren
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
)paren
op_logical_and
(paren
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|length
OL
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next-&gt;length
)paren
)paren
(brace
id|out_of_order
op_increment
suffix:semicolon
id|current_res
op_assign
op_star
id|head
suffix:semicolon
op_star
id|head
op_assign
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|current_res-&gt;next
op_assign
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
op_assign
id|current_res
suffix:semicolon
)brace
id|current_res
op_assign
op_star
id|head
suffix:semicolon
r_while
c_loop
(paren
id|current_res-&gt;next
op_logical_and
id|current_res-&gt;next-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|current_res-&gt;next-&gt;length
OL
id|current_res-&gt;next-&gt;next-&gt;length
)paren
(brace
id|out_of_order
op_increment
suffix:semicolon
id|next_res
op_assign
id|current_res-&gt;next
suffix:semicolon
id|current_res-&gt;next
op_assign
id|current_res-&gt;next-&gt;next
suffix:semicolon
id|current_res
op_assign
id|current_res-&gt;next
suffix:semicolon
id|next_res-&gt;next
op_assign
id|current_res-&gt;next
suffix:semicolon
id|current_res-&gt;next
op_assign
id|next_res
suffix:semicolon
)brace
r_else
id|current_res
op_assign
id|current_res-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/* End of out_of_order loop */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * get_io_resource - get resource for I/O ports&n; *&n; * this function sorts the resource list by size and then&n; * returns the first node of &quot;size&quot; length that is not in the&n; * ISA aliasing window.  If it finds a node larger than &quot;size&quot;&n; * it will split it up.&n; *&n; * size must be a power of two.&n; *&n; * difference from get_resource is handling of ISA aliasing space.&n; *&n; */
DECL|function|acpiphp_get_io_resource
r_struct
id|pci_resource
op_star
id|acpiphp_get_io_resource
(paren
r_struct
id|pci_resource
op_star
op_star
id|head
comma
id|u32
id|size
)paren
(brace
r_struct
id|pci_resource
op_star
id|prevnode
suffix:semicolon
r_struct
id|pci_resource
op_star
id|node
suffix:semicolon
r_struct
id|pci_resource
op_star
id|split_node
suffix:semicolon
id|u64
id|temp_qword
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|head
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|acpiphp_resource_sort_and_combine
c_func
(paren
id|head
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sort_by_size
c_func
(paren
id|head
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
op_star
id|head
suffix:semicolon
id|node
suffix:semicolon
id|node
op_assign
id|node-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|node-&gt;length
OL
id|size
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;base
op_amp
(paren
id|size
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/* this one isn&squot;t base aligned properly&n;&t;&t;&t;   so we&squot;ll make a new entry and split it up */
id|temp_qword
op_assign
(paren
id|node-&gt;base
op_or
(paren
id|size
op_minus
l_int|1
)paren
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Short circuit if adjusted size is too small */
r_if
c_cond
(paren
(paren
id|node-&gt;length
op_minus
(paren
id|temp_qword
op_minus
id|node-&gt;base
)paren
)paren
OL
id|size
)paren
r_continue
suffix:semicolon
id|split_node
op_assign
id|acpiphp_make_resource
c_func
(paren
id|node-&gt;base
comma
id|temp_qword
op_minus
id|node-&gt;base
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|split_node
)paren
r_return
l_int|NULL
suffix:semicolon
id|node-&gt;base
op_assign
id|temp_qword
suffix:semicolon
id|node-&gt;length
op_sub_assign
id|split_node-&gt;length
suffix:semicolon
multiline_comment|/* Put it in the list */
id|split_node-&gt;next
op_assign
id|node-&gt;next
suffix:semicolon
id|node-&gt;next
op_assign
id|split_node
suffix:semicolon
)brace
multiline_comment|/* End of non-aligned base */
multiline_comment|/* Don&squot;t need to check if too small since we already did */
r_if
c_cond
(paren
id|node-&gt;length
OG
id|size
)paren
(brace
multiline_comment|/* this one is longer than we need&n;&t;&t;&t;   so we&squot;ll make a new entry and split it up */
id|split_node
op_assign
id|acpiphp_make_resource
c_func
(paren
id|node-&gt;base
op_plus
id|size
comma
id|node-&gt;length
op_minus
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|split_node
)paren
r_return
l_int|NULL
suffix:semicolon
id|node-&gt;length
op_assign
id|size
suffix:semicolon
multiline_comment|/* Put it in the list */
id|split_node-&gt;next
op_assign
id|node-&gt;next
suffix:semicolon
id|node-&gt;next
op_assign
id|split_node
suffix:semicolon
)brace
multiline_comment|/* End of too big on top end */
multiline_comment|/* For IO make sure it&squot;s not in the ISA aliasing space */
r_if
c_cond
(paren
id|node-&gt;base
op_amp
l_int|0x300L
)paren
r_continue
suffix:semicolon
multiline_comment|/* If we got here, then it is the right size&n;&t;&t;   Now take it out of the list */
r_if
c_cond
(paren
op_star
id|head
op_eq
id|node
)paren
(brace
op_star
id|head
op_assign
id|node-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|prevnode
op_assign
op_star
id|head
suffix:semicolon
r_while
c_loop
(paren
id|prevnode-&gt;next
op_ne
id|node
)paren
id|prevnode
op_assign
id|prevnode-&gt;next
suffix:semicolon
id|prevnode-&gt;next
op_assign
id|node-&gt;next
suffix:semicolon
)brace
id|node-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Stop looping */
r_break
suffix:semicolon
)brace
r_return
id|node
suffix:semicolon
)brace
multiline_comment|/**&n; * get_max_resource - get the largest resource&n; *&n; * Gets the largest node that is at least &quot;size&quot; big from the&n; * list pointed to by head.  It aligns the node on top and bottom&n; * to &quot;size&quot; alignment before returning it.&n; */
DECL|function|acpiphp_get_max_resource
r_struct
id|pci_resource
op_star
id|acpiphp_get_max_resource
(paren
r_struct
id|pci_resource
op_star
op_star
id|head
comma
id|u32
id|size
)paren
(brace
r_struct
id|pci_resource
op_star
id|max
suffix:semicolon
r_struct
id|pci_resource
op_star
id|temp
suffix:semicolon
r_struct
id|pci_resource
op_star
id|split_node
suffix:semicolon
id|u64
id|temp_qword
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|head
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|acpiphp_resource_sort_and_combine
c_func
(paren
id|head
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sort_by_max_size
c_func
(paren
id|head
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|max
op_assign
op_star
id|head
suffix:semicolon
id|max
suffix:semicolon
id|max
op_assign
id|max-&gt;next
)paren
(brace
multiline_comment|/* If not big enough we could probably just bail,&n;&t;&t;   instead we&squot;ll continue to the next. */
r_if
c_cond
(paren
id|max-&gt;length
OL
id|size
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|max-&gt;base
op_amp
(paren
id|size
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/* this one isn&squot;t base aligned properly&n;&t;&t;&t;   so we&squot;ll make a new entry and split it up */
id|temp_qword
op_assign
(paren
id|max-&gt;base
op_or
(paren
id|size
op_minus
l_int|1
)paren
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Short circuit if adjusted size is too small */
r_if
c_cond
(paren
(paren
id|max-&gt;length
op_minus
(paren
id|temp_qword
op_minus
id|max-&gt;base
)paren
)paren
OL
id|size
)paren
r_continue
suffix:semicolon
id|split_node
op_assign
id|acpiphp_make_resource
c_func
(paren
id|max-&gt;base
comma
id|temp_qword
op_minus
id|max-&gt;base
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|split_node
)paren
r_return
l_int|NULL
suffix:semicolon
id|max-&gt;base
op_assign
id|temp_qword
suffix:semicolon
id|max-&gt;length
op_sub_assign
id|split_node-&gt;length
suffix:semicolon
multiline_comment|/* Put it next in the list */
id|split_node-&gt;next
op_assign
id|max-&gt;next
suffix:semicolon
id|max-&gt;next
op_assign
id|split_node
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|max-&gt;base
op_plus
id|max-&gt;length
)paren
op_amp
(paren
id|size
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/* this one isn&squot;t end aligned properly at the top&n;&t;&t;&t;   so we&squot;ll make a new entry and split it up */
id|temp_qword
op_assign
(paren
(paren
id|max-&gt;base
op_plus
id|max-&gt;length
)paren
op_amp
op_complement
(paren
id|size
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|split_node
op_assign
id|acpiphp_make_resource
c_func
(paren
id|temp_qword
comma
id|max-&gt;length
op_plus
id|max-&gt;base
op_minus
id|temp_qword
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|split_node
)paren
r_return
l_int|NULL
suffix:semicolon
id|max-&gt;length
op_sub_assign
id|split_node-&gt;length
suffix:semicolon
multiline_comment|/* Put it in the list */
id|split_node-&gt;next
op_assign
id|max-&gt;next
suffix:semicolon
id|max-&gt;next
op_assign
id|split_node
suffix:semicolon
)brace
multiline_comment|/* Make sure it didn&squot;t shrink too much when we aligned it */
r_if
c_cond
(paren
id|max-&gt;length
OL
id|size
)paren
r_continue
suffix:semicolon
multiline_comment|/* Now take it out of the list */
id|temp
op_assign
(paren
r_struct
id|pci_resource
op_star
)paren
op_star
id|head
suffix:semicolon
r_if
c_cond
(paren
id|temp
op_eq
id|max
)paren
(brace
op_star
id|head
op_assign
id|max-&gt;next
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
id|temp
op_logical_and
id|temp-&gt;next
op_ne
id|max
)paren
(brace
id|temp
op_assign
id|temp-&gt;next
suffix:semicolon
)brace
id|temp-&gt;next
op_assign
id|max-&gt;next
suffix:semicolon
)brace
id|max-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_return
id|max
suffix:semicolon
)brace
multiline_comment|/* If we get here, we couldn&squot;t find one */
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * get_resource - get resource (mem, pfmem)&n; *&n; * this function sorts the resource list by size and then&n; * returns the first node of &quot;size&quot; length.  If it finds a node&n; * larger than &quot;size&quot; it will split it up.&n; *&n; * size must be a power of two.&n; *&n; */
DECL|function|acpiphp_get_resource
r_struct
id|pci_resource
op_star
id|acpiphp_get_resource
(paren
r_struct
id|pci_resource
op_star
op_star
id|head
comma
id|u32
id|size
)paren
(brace
r_struct
id|pci_resource
op_star
id|prevnode
suffix:semicolon
r_struct
id|pci_resource
op_star
id|node
suffix:semicolon
r_struct
id|pci_resource
op_star
id|split_node
suffix:semicolon
id|u64
id|temp_qword
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|head
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|acpiphp_resource_sort_and_combine
c_func
(paren
id|head
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sort_by_size
c_func
(paren
id|head
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
op_star
id|head
suffix:semicolon
id|node
suffix:semicolon
id|node
op_assign
id|node-&gt;next
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s: req_size =%x node=%p, base=%x, length=%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|size
comma
id|node
comma
(paren
id|u32
)paren
id|node-&gt;base
comma
id|node-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;length
OL
id|size
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;base
op_amp
(paren
id|size
op_minus
l_int|1
)paren
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s: not aligned&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* this one isn&squot;t base aligned properly&n;&t;&t;&t;   so we&squot;ll make a new entry and split it up */
id|temp_qword
op_assign
(paren
id|node-&gt;base
op_or
(paren
id|size
op_minus
l_int|1
)paren
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Short circuit if adjusted size is too small */
r_if
c_cond
(paren
(paren
id|node-&gt;length
op_minus
(paren
id|temp_qword
op_minus
id|node-&gt;base
)paren
)paren
OL
id|size
)paren
r_continue
suffix:semicolon
id|split_node
op_assign
id|acpiphp_make_resource
c_func
(paren
id|node-&gt;base
comma
id|temp_qword
op_minus
id|node-&gt;base
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|split_node
)paren
r_return
l_int|NULL
suffix:semicolon
id|node-&gt;base
op_assign
id|temp_qword
suffix:semicolon
id|node-&gt;length
op_sub_assign
id|split_node-&gt;length
suffix:semicolon
multiline_comment|/* Put it in the list */
id|split_node-&gt;next
op_assign
id|node-&gt;next
suffix:semicolon
id|node-&gt;next
op_assign
id|split_node
suffix:semicolon
)brace
multiline_comment|/* End of non-aligned base */
multiline_comment|/* Don&squot;t need to check if too small since we already did */
r_if
c_cond
(paren
id|node-&gt;length
OG
id|size
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s: too big&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* this one is longer than we need&n;&t;&t;&t;   so we&squot;ll make a new entry and split it up */
id|split_node
op_assign
id|acpiphp_make_resource
c_func
(paren
id|node-&gt;base
op_plus
id|size
comma
id|node-&gt;length
op_minus
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|split_node
)paren
r_return
l_int|NULL
suffix:semicolon
id|node-&gt;length
op_assign
id|size
suffix:semicolon
multiline_comment|/* Put it in the list */
id|split_node-&gt;next
op_assign
id|node-&gt;next
suffix:semicolon
id|node-&gt;next
op_assign
id|split_node
suffix:semicolon
)brace
multiline_comment|/* End of too big on top end */
id|dbg
c_func
(paren
l_string|&quot;%s: got one!!!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* If we got here, then it is the right size&n;&t;&t;   Now take it out of the list */
r_if
c_cond
(paren
op_star
id|head
op_eq
id|node
)paren
(brace
op_star
id|head
op_assign
id|node-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|prevnode
op_assign
op_star
id|head
suffix:semicolon
r_while
c_loop
(paren
id|prevnode-&gt;next
op_ne
id|node
)paren
id|prevnode
op_assign
id|prevnode-&gt;next
suffix:semicolon
id|prevnode-&gt;next
op_assign
id|node-&gt;next
suffix:semicolon
)brace
id|node-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Stop looping */
r_break
suffix:semicolon
)brace
r_return
id|node
suffix:semicolon
)brace
multiline_comment|/**&n; * get_resource_with_base - get resource with specific base address&n; *&n; * this function&n; * returns the first node of &quot;size&quot; length located at specified base address.&n; * If it finds a node larger than &quot;size&quot; it will split it up.&n; *&n; * size must be a power of two.&n; *&n; */
DECL|function|acpiphp_get_resource_with_base
r_struct
id|pci_resource
op_star
id|acpiphp_get_resource_with_base
(paren
r_struct
id|pci_resource
op_star
op_star
id|head
comma
id|u64
id|base
comma
id|u32
id|size
)paren
(brace
r_struct
id|pci_resource
op_star
id|prevnode
suffix:semicolon
r_struct
id|pci_resource
op_star
id|node
suffix:semicolon
r_struct
id|pci_resource
op_star
id|split_node
suffix:semicolon
id|u64
id|temp_qword
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|head
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|acpiphp_resource_sort_and_combine
c_func
(paren
id|head
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
op_star
id|head
suffix:semicolon
id|node
suffix:semicolon
id|node
op_assign
id|node-&gt;next
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;: 1st req_base=%x req_size =%x node=%p, base=%x, length=%x&bslash;n&quot;
comma
(paren
id|u32
)paren
id|base
comma
id|size
comma
id|node
comma
(paren
id|u32
)paren
id|node-&gt;base
comma
id|node-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;base
OG
id|base
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|node-&gt;base
op_plus
id|node-&gt;length
)paren
OL
(paren
id|base
op_plus
id|size
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;base
OL
id|base
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;: split 1&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* this one isn&squot;t base aligned properly&n;&t;&t;&t;   so we&squot;ll make a new entry and split it up */
id|temp_qword
op_assign
id|base
suffix:semicolon
multiline_comment|/* Short circuit if adjusted size is too small */
r_if
c_cond
(paren
(paren
id|node-&gt;length
op_minus
(paren
id|temp_qword
op_minus
id|node-&gt;base
)paren
)paren
OL
id|size
)paren
r_continue
suffix:semicolon
id|split_node
op_assign
id|acpiphp_make_resource
c_func
(paren
id|node-&gt;base
comma
id|temp_qword
op_minus
id|node-&gt;base
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|split_node
)paren
r_return
l_int|NULL
suffix:semicolon
id|node-&gt;base
op_assign
id|temp_qword
suffix:semicolon
id|node-&gt;length
op_sub_assign
id|split_node-&gt;length
suffix:semicolon
multiline_comment|/* Put it in the list */
id|split_node-&gt;next
op_assign
id|node-&gt;next
suffix:semicolon
id|node-&gt;next
op_assign
id|split_node
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;: 2nd req_base=%x req_size =%x node=%p, base=%x, length=%x&bslash;n&quot;
comma
(paren
id|u32
)paren
id|base
comma
id|size
comma
id|node
comma
(paren
id|u32
)paren
id|node-&gt;base
comma
id|node-&gt;length
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t need to check if too small since we already did */
r_if
c_cond
(paren
id|node-&gt;length
OG
id|size
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;: split 2&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* this one is longer than we need&n;&t;&t;&t;   so we&squot;ll make a new entry and split it up */
id|split_node
op_assign
id|acpiphp_make_resource
c_func
(paren
id|node-&gt;base
op_plus
id|size
comma
id|node-&gt;length
op_minus
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|split_node
)paren
r_return
l_int|NULL
suffix:semicolon
id|node-&gt;length
op_assign
id|size
suffix:semicolon
multiline_comment|/* Put it in the list */
id|split_node-&gt;next
op_assign
id|node-&gt;next
suffix:semicolon
id|node-&gt;next
op_assign
id|split_node
suffix:semicolon
)brace
multiline_comment|/* End of too big on top end */
id|dbg
c_func
(paren
l_string|&quot;: got one!!!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* If we got here, then it is the right size&n;&t;&t;   Now take it out of the list */
r_if
c_cond
(paren
op_star
id|head
op_eq
id|node
)paren
(brace
op_star
id|head
op_assign
id|node-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|prevnode
op_assign
op_star
id|head
suffix:semicolon
r_while
c_loop
(paren
id|prevnode-&gt;next
op_ne
id|node
)paren
id|prevnode
op_assign
id|prevnode-&gt;next
suffix:semicolon
id|prevnode-&gt;next
op_assign
id|node-&gt;next
suffix:semicolon
)brace
id|node-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Stop looping */
r_break
suffix:semicolon
)brace
r_return
id|node
suffix:semicolon
)brace
multiline_comment|/**&n; * acpiphp_resource_sort_and_combine&n; *&n; * Sorts all of the nodes in the list in ascending order by&n; * their base addresses.  Also does garbage collection by&n; * combining adjacent nodes.&n; *&n; * returns 0 if success&n; */
DECL|function|acpiphp_resource_sort_and_combine
r_int
id|acpiphp_resource_sort_and_combine
(paren
r_struct
id|pci_resource
op_star
op_star
id|head
)paren
(brace
r_struct
id|pci_resource
op_star
id|node1
suffix:semicolon
r_struct
id|pci_resource
op_star
id|node2
suffix:semicolon
r_int
id|out_of_order
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|head
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;*head-&gt;next = %p&bslash;n&quot;
comma
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* only one item on the list, already sorted! */
id|dbg
c_func
(paren
l_string|&quot;*head-&gt;base = 0x%x&bslash;n&quot;
comma
(paren
id|u32
)paren
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|base
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;*head-&gt;next-&gt;base = 0x%x&bslash;n&quot;
comma
(paren
id|u32
)paren
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next-&gt;base
)paren
suffix:semicolon
r_while
c_loop
(paren
id|out_of_order
)paren
(brace
id|out_of_order
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Special case for swapping list head */
r_if
c_cond
(paren
(paren
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
)paren
op_logical_and
(paren
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|base
OG
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next-&gt;base
)paren
)paren
(brace
id|node1
op_assign
op_star
id|head
suffix:semicolon
(paren
op_star
id|head
)paren
op_assign
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|node1-&gt;next
op_assign
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
op_assign
id|node1
suffix:semicolon
id|out_of_order
op_increment
suffix:semicolon
)brace
id|node1
op_assign
(paren
op_star
id|head
)paren
suffix:semicolon
r_while
c_loop
(paren
id|node1-&gt;next
op_logical_and
id|node1-&gt;next-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|node1-&gt;next-&gt;base
OG
id|node1-&gt;next-&gt;next-&gt;base
)paren
(brace
id|out_of_order
op_increment
suffix:semicolon
id|node2
op_assign
id|node1-&gt;next
suffix:semicolon
id|node1-&gt;next
op_assign
id|node1-&gt;next-&gt;next
suffix:semicolon
id|node1
op_assign
id|node1-&gt;next
suffix:semicolon
id|node2-&gt;next
op_assign
id|node1-&gt;next
suffix:semicolon
id|node1-&gt;next
op_assign
id|node2
suffix:semicolon
)brace
r_else
id|node1
op_assign
id|node1-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/* End of out_of_order loop */
id|node1
op_assign
op_star
id|head
suffix:semicolon
r_while
c_loop
(paren
id|node1
op_logical_and
id|node1-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|node1-&gt;base
op_plus
id|node1-&gt;length
)paren
op_eq
id|node1-&gt;next-&gt;base
)paren
(brace
multiline_comment|/* Combine */
id|dbg
c_func
(paren
l_string|&quot;8..&bslash;n&quot;
)paren
suffix:semicolon
id|node1-&gt;length
op_add_assign
id|node1-&gt;next-&gt;length
suffix:semicolon
id|node2
op_assign
id|node1-&gt;next
suffix:semicolon
id|node1-&gt;next
op_assign
id|node1-&gt;next-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|node2
)paren
suffix:semicolon
)brace
r_else
id|node1
op_assign
id|node1-&gt;next
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * acpiphp_make_resource - make resource structure&n; * @base: base address of a resource&n; * @length: length of a resource&n; */
DECL|function|acpiphp_make_resource
r_struct
id|pci_resource
op_star
id|acpiphp_make_resource
(paren
id|u64
id|base
comma
id|u32
id|length
)paren
(brace
r_struct
id|pci_resource
op_star
id|res
suffix:semicolon
id|res
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
id|memset
c_func
(paren
id|res
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|pci_resource
)paren
)paren
suffix:semicolon
id|res-&gt;base
op_assign
id|base
suffix:semicolon
id|res-&gt;length
op_assign
id|length
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/**&n; * acpiphp_move_resource - move linked resources from one to another&n; * @from: head of linked resource list&n; * @to: head of linked resource list&n; */
DECL|function|acpiphp_move_resource
r_void
id|acpiphp_move_resource
(paren
r_struct
id|pci_resource
op_star
op_star
id|from
comma
r_struct
id|pci_resource
op_star
op_star
id|to
)paren
(brace
r_struct
id|pci_resource
op_star
id|tmp
suffix:semicolon
r_while
c_loop
(paren
op_star
id|from
)paren
(brace
id|tmp
op_assign
(paren
op_star
id|from
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
(paren
op_star
id|from
)paren
op_member_access_from_pointer
id|next
op_assign
op_star
id|to
suffix:semicolon
op_star
id|to
op_assign
op_star
id|from
suffix:semicolon
op_star
id|from
op_assign
id|tmp
suffix:semicolon
)brace
multiline_comment|/* *from = NULL is guaranteed */
)brace
multiline_comment|/**&n; * acpiphp_free_resource - free all linked resources&n; * @res: head of linked resource list&n; */
DECL|function|acpiphp_free_resource
r_void
id|acpiphp_free_resource
(paren
r_struct
id|pci_resource
op_star
op_star
id|res
)paren
(brace
r_struct
id|pci_resource
op_star
id|tmp
suffix:semicolon
r_while
c_loop
(paren
op_star
id|res
)paren
(brace
id|tmp
op_assign
(paren
op_star
id|res
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|kfree
c_func
(paren
op_star
id|res
)paren
suffix:semicolon
op_star
id|res
op_assign
id|tmp
suffix:semicolon
)brace
multiline_comment|/* *res = NULL is guaranteed */
)brace
multiline_comment|/* debug support functions;  will go away sometime :) */
DECL|function|dump_resource
r_static
r_void
id|dump_resource
c_func
(paren
r_struct
id|pci_resource
op_star
id|head
)paren
(brace
r_struct
id|pci_resource
op_star
id|p
suffix:semicolon
r_int
id|cnt
suffix:semicolon
id|p
op_assign
id|head
suffix:semicolon
id|cnt
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|p
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;[%02d] %08x - %08x&bslash;n&quot;
comma
id|cnt
op_increment
comma
(paren
id|u32
)paren
id|p-&gt;base
comma
(paren
id|u32
)paren
id|p-&gt;base
op_plus
id|p-&gt;length
op_minus
l_int|1
)paren
suffix:semicolon
id|p
op_assign
id|p-&gt;next
suffix:semicolon
)brace
)brace
DECL|function|acpiphp_dump_resource
r_void
id|acpiphp_dump_resource
c_func
(paren
r_struct
id|acpiphp_bridge
op_star
id|bridge
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;I/O resource:&bslash;n&quot;
)paren
suffix:semicolon
id|dump_resource
c_func
(paren
id|bridge-&gt;io_head
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;MEM resource:&bslash;n&quot;
)paren
suffix:semicolon
id|dump_resource
c_func
(paren
id|bridge-&gt;mem_head
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;PMEM resource:&bslash;n&quot;
)paren
suffix:semicolon
id|dump_resource
c_func
(paren
id|bridge-&gt;p_mem_head
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;BUS resource:&bslash;n&quot;
)paren
suffix:semicolon
id|dump_resource
c_func
(paren
id|bridge-&gt;bus_head
)paren
suffix:semicolon
)brace
DECL|function|acpiphp_dump_func_resource
r_void
id|acpiphp_dump_func_resource
c_func
(paren
r_struct
id|acpiphp_func
op_star
id|func
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;I/O resource:&bslash;n&quot;
)paren
suffix:semicolon
id|dump_resource
c_func
(paren
id|func-&gt;io_head
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;MEM resource:&bslash;n&quot;
)paren
suffix:semicolon
id|dump_resource
c_func
(paren
id|func-&gt;mem_head
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;PMEM resource:&bslash;n&quot;
)paren
suffix:semicolon
id|dump_resource
c_func
(paren
id|func-&gt;p_mem_head
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;BUS resource:&bslash;n&quot;
)paren
suffix:semicolon
id|dump_resource
c_func
(paren
id|func-&gt;bus_head
)paren
suffix:semicolon
)brace
eof
