multiline_comment|/*&n; * Compaq Hot Plug Controller Driver&n; *&n; * Copyright (C) 1995,2001 Compaq Computer Corporation&n; * Copyright (C) 2001 Greg Kroah-Hartman (greg@kroah.com)&n; * Copyright (C) 2001 IBM Corp.&n; *&n; * All rights reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or (at&n; * your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or&n; * NON INFRINGEMENT.  See the GNU General Public License for more&n; * details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; * Send feedback to &lt;greg@kroah.com&gt;&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &quot;cpqphp.h&quot;
r_static
id|u32
id|configure_new_device
c_func
(paren
r_struct
id|controller
op_star
id|ctrl
comma
r_struct
id|pci_func
op_star
id|func
comma
id|u8
id|behind_bridge
comma
r_struct
id|resource_lists
op_star
id|resources
)paren
suffix:semicolon
r_static
r_int
id|configure_new_function
c_func
(paren
r_struct
id|controller
op_star
id|ctrl
comma
r_struct
id|pci_func
op_star
id|func
comma
id|u8
id|behind_bridge
comma
r_struct
id|resource_lists
op_star
id|resources
)paren
suffix:semicolon
r_static
r_void
id|interrupt_event_handler
c_func
(paren
r_struct
id|controller
op_star
id|ctrl
)paren
suffix:semicolon
DECL|variable|event_semaphore
r_static
r_struct
id|semaphore
id|event_semaphore
suffix:semicolon
multiline_comment|/* mutex for process loop (up if something to process) */
DECL|variable|event_exit
r_static
r_struct
id|semaphore
id|event_exit
suffix:semicolon
multiline_comment|/* guard ensure thread has exited before calling it quits */
DECL|variable|event_finished
r_static
r_int
id|event_finished
suffix:semicolon
DECL|variable|pushbutton_pending
r_static
r_int
r_int
id|pushbutton_pending
suffix:semicolon
multiline_comment|/* = 0 */
multiline_comment|/* things needed for the long_delay function */
DECL|variable|delay_sem
r_static
r_struct
id|semaphore
id|delay_sem
suffix:semicolon
DECL|variable|delay_wait
r_static
id|wait_queue_head_t
id|delay_wait
suffix:semicolon
multiline_comment|/* delay is in jiffies to wait for */
DECL|function|long_delay
r_static
r_void
id|long_delay
c_func
(paren
r_int
id|delay
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
multiline_comment|/* only allow 1 customer into the delay queue at once&n;&t; * yes this makes some people wait even longer, but who really cares?&n;&t; * this is for _huge_ delays to make the hardware happy as the &n;&t; * signals bounce around&n;&t; */
id|down
(paren
op_amp
id|delay_sem
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|delay_wait
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|delay_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|delay
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|delay_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|delay_sem
)paren
suffix:semicolon
)brace
multiline_comment|/* FIXME: The following line needs to be somewhere else... */
DECL|macro|WRONG_BUS_FREQUENCY
mdefine_line|#define WRONG_BUS_FREQUENCY 0x07
DECL|function|handle_switch_change
r_static
id|u8
id|handle_switch_change
c_func
(paren
id|u8
id|change
comma
r_struct
id|controller
op_star
id|ctrl
)paren
(brace
r_int
id|hp_slot
suffix:semicolon
id|u8
id|rc
op_assign
l_int|0
suffix:semicolon
id|u16
id|temp_word
suffix:semicolon
r_struct
id|pci_func
op_star
id|func
suffix:semicolon
r_struct
id|event_info
op_star
id|taskInfo
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|change
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Switch Change */
id|dbg
c_func
(paren
l_string|&quot;cpqsbd:  Switch interrupt received.&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|hp_slot
op_assign
l_int|0
suffix:semicolon
id|hp_slot
OL
l_int|6
suffix:semicolon
id|hp_slot
op_increment
)paren
(brace
r_if
c_cond
(paren
id|change
op_amp
(paren
l_int|0x1L
op_lshift
id|hp_slot
)paren
)paren
(brace
multiline_comment|/**********************************&n;&t;&t;&t; * this one changed.&n;&t;&t;&t; **********************************/
id|func
op_assign
id|cpqhp_slot_find
c_func
(paren
id|ctrl-&gt;bus
comma
(paren
id|hp_slot
op_plus
id|ctrl-&gt;slot_device_offset
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* this is the structure that tells the worker thread&n;&t;&t;&t; *what to do */
id|taskInfo
op_assign
op_amp
(paren
id|ctrl-&gt;event_queue
(braket
id|ctrl-&gt;next_event
)braket
)paren
suffix:semicolon
id|ctrl-&gt;next_event
op_assign
(paren
id|ctrl-&gt;next_event
op_plus
l_int|1
)paren
op_mod
l_int|10
suffix:semicolon
id|taskInfo-&gt;hp_slot
op_assign
id|hp_slot
suffix:semicolon
id|rc
op_increment
suffix:semicolon
id|temp_word
op_assign
id|ctrl-&gt;ctrl_int_comp
op_rshift
l_int|16
suffix:semicolon
id|func-&gt;presence_save
op_assign
(paren
id|temp_word
op_rshift
id|hp_slot
)paren
op_amp
l_int|0x01
suffix:semicolon
id|func-&gt;presence_save
op_or_assign
(paren
id|temp_word
op_rshift
(paren
id|hp_slot
op_plus
l_int|7
)paren
)paren
op_amp
l_int|0x02
suffix:semicolon
r_if
c_cond
(paren
id|ctrl-&gt;ctrl_int_comp
op_amp
(paren
l_int|0x1L
op_lshift
id|hp_slot
)paren
)paren
(brace
multiline_comment|/**********************************&n;&t;&t;&t;&t; * Switch opened&n;&t;&t;&t;&t; **********************************/
id|func-&gt;switch_save
op_assign
l_int|0
suffix:semicolon
id|taskInfo-&gt;event_type
op_assign
id|INT_SWITCH_OPEN
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/**********************************&n;&t;&t;&t;&t; * Switch closed&n;&t;&t;&t;&t; **********************************/
id|func-&gt;switch_save
op_assign
l_int|0x10
suffix:semicolon
id|taskInfo-&gt;event_type
op_assign
id|INT_SWITCH_CLOSE
suffix:semicolon
)brace
)brace
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; * cpqhp_find_slot: find the struct slot of given device&n; * @ctrl: scan lots of this controller&n; * @device: the device id to find&n; */
DECL|function|cpqhp_find_slot
r_struct
id|slot
op_star
id|cpqhp_find_slot
c_func
(paren
r_struct
id|controller
op_star
id|ctrl
comma
id|u8
id|device
)paren
(brace
r_struct
id|slot
op_star
id|slot
op_assign
id|ctrl-&gt;slot
suffix:semicolon
r_while
c_loop
(paren
id|slot
op_logical_and
(paren
id|slot-&gt;device
op_ne
id|device
)paren
)paren
(brace
id|slot
op_assign
id|slot-&gt;next
suffix:semicolon
)brace
r_return
id|slot
suffix:semicolon
)brace
DECL|function|handle_presence_change
r_static
id|u8
id|handle_presence_change
c_func
(paren
id|u16
id|change
comma
r_struct
id|controller
op_star
id|ctrl
)paren
(brace
r_int
id|hp_slot
suffix:semicolon
id|u8
id|rc
op_assign
l_int|0
suffix:semicolon
id|u8
id|temp_byte
suffix:semicolon
id|u16
id|temp_word
suffix:semicolon
r_struct
id|pci_func
op_star
id|func
suffix:semicolon
r_struct
id|event_info
op_star
id|taskInfo
suffix:semicolon
r_struct
id|slot
op_star
id|p_slot
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|change
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/**********************************&n;&t; * Presence Change&n;&t; **********************************/
id|dbg
c_func
(paren
l_string|&quot;cpqsbd:  Presence/Notify input change.&bslash;n&quot;
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;         Changed bits are 0x%4.4x&bslash;n&quot;
comma
id|change
)paren
suffix:semicolon
r_for
c_loop
(paren
id|hp_slot
op_assign
l_int|0
suffix:semicolon
id|hp_slot
OL
l_int|6
suffix:semicolon
id|hp_slot
op_increment
)paren
(brace
r_if
c_cond
(paren
id|change
op_amp
(paren
l_int|0x0101
op_lshift
id|hp_slot
)paren
)paren
(brace
multiline_comment|/**********************************&n;&t;&t;&t; * this one changed.&n;&t;&t;&t; **********************************/
id|func
op_assign
id|cpqhp_slot_find
c_func
(paren
id|ctrl-&gt;bus
comma
(paren
id|hp_slot
op_plus
id|ctrl-&gt;slot_device_offset
)paren
comma
l_int|0
)paren
suffix:semicolon
id|taskInfo
op_assign
op_amp
(paren
id|ctrl-&gt;event_queue
(braket
id|ctrl-&gt;next_event
)braket
)paren
suffix:semicolon
id|ctrl-&gt;next_event
op_assign
(paren
id|ctrl-&gt;next_event
op_plus
l_int|1
)paren
op_mod
l_int|10
suffix:semicolon
id|taskInfo-&gt;hp_slot
op_assign
id|hp_slot
suffix:semicolon
id|rc
op_increment
suffix:semicolon
id|p_slot
op_assign
id|cpqhp_find_slot
c_func
(paren
id|ctrl
comma
id|hp_slot
op_plus
(paren
id|readb
c_func
(paren
id|ctrl-&gt;hpc_reg
op_plus
id|SLOT_MASK
)paren
op_rshift
l_int|4
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p_slot
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* If the switch closed, must be a button&n;&t;&t;&t; * If not in button mode, nevermind */
r_if
c_cond
(paren
id|func-&gt;switch_save
op_logical_and
(paren
id|ctrl-&gt;push_button
op_eq
l_int|1
)paren
)paren
(brace
id|temp_word
op_assign
id|ctrl-&gt;ctrl_int_comp
op_rshift
l_int|16
suffix:semicolon
id|temp_byte
op_assign
(paren
id|temp_word
op_rshift
id|hp_slot
)paren
op_amp
l_int|0x01
suffix:semicolon
id|temp_byte
op_or_assign
(paren
id|temp_word
op_rshift
(paren
id|hp_slot
op_plus
l_int|7
)paren
)paren
op_amp
l_int|0x02
suffix:semicolon
r_if
c_cond
(paren
id|temp_byte
op_ne
id|func-&gt;presence_save
)paren
(brace
multiline_comment|/**************************************&n;&t;&t;&t;&t;&t; * button Pressed (doesn&squot;t do anything)&n;&t;&t;&t;&t;&t; **************************************/
id|dbg
c_func
(paren
l_string|&quot;hp_slot %d button pressed&bslash;n&quot;
comma
id|hp_slot
)paren
suffix:semicolon
id|taskInfo-&gt;event_type
op_assign
id|INT_BUTTON_PRESS
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/**********************************&n;&t;&t;&t;&t;&t; * button Released - TAKE ACTION!!!!&n;&t;&t;&t;&t;&t; **********************************/
id|dbg
c_func
(paren
l_string|&quot;hp_slot %d button released&bslash;n&quot;
comma
id|hp_slot
)paren
suffix:semicolon
id|taskInfo-&gt;event_type
op_assign
id|INT_BUTTON_RELEASE
suffix:semicolon
multiline_comment|/* Cancel if we are still blinking */
r_if
c_cond
(paren
(paren
id|p_slot-&gt;state
op_eq
id|BLINKINGON_STATE
)paren
op_logical_or
(paren
id|p_slot-&gt;state
op_eq
id|BLINKINGOFF_STATE
)paren
)paren
(brace
id|taskInfo-&gt;event_type
op_assign
id|INT_BUTTON_CANCEL
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;hp_slot %d button cancel&bslash;n&quot;
comma
id|hp_slot
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|p_slot-&gt;state
op_eq
id|POWERON_STATE
)paren
op_logical_or
(paren
id|p_slot-&gt;state
op_eq
id|POWEROFF_STATE
)paren
)paren
(brace
multiline_comment|/* info(msg_button_ignore, p_slot-&gt;number); */
id|taskInfo-&gt;event_type
op_assign
id|INT_BUTTON_IGNORE
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;hp_slot %d button ignore&bslash;n&quot;
comma
id|hp_slot
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* Switch is open, assume a presence change&n;&t;&t;&t;&t; * Save the presence state */
id|temp_word
op_assign
id|ctrl-&gt;ctrl_int_comp
op_rshift
l_int|16
suffix:semicolon
id|func-&gt;presence_save
op_assign
(paren
id|temp_word
op_rshift
id|hp_slot
)paren
op_amp
l_int|0x01
suffix:semicolon
id|func-&gt;presence_save
op_or_assign
(paren
id|temp_word
op_rshift
(paren
id|hp_slot
op_plus
l_int|7
)paren
)paren
op_amp
l_int|0x02
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|ctrl-&gt;ctrl_int_comp
op_amp
(paren
l_int|0x010000
op_lshift
id|hp_slot
)paren
)paren
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|ctrl-&gt;ctrl_int_comp
op_amp
(paren
l_int|0x01000000
op_lshift
id|hp_slot
)paren
)paren
)paren
)paren
(brace
multiline_comment|/* Present */
id|taskInfo-&gt;event_type
op_assign
id|INT_PRESENCE_ON
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Not Present */
id|taskInfo-&gt;event_type
op_assign
id|INT_PRESENCE_OFF
suffix:semicolon
)brace
)brace
)brace
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|handle_power_fault
r_static
id|u8
id|handle_power_fault
c_func
(paren
id|u8
id|change
comma
r_struct
id|controller
op_star
id|ctrl
)paren
(brace
r_int
id|hp_slot
suffix:semicolon
id|u8
id|rc
op_assign
l_int|0
suffix:semicolon
r_struct
id|pci_func
op_star
id|func
suffix:semicolon
r_struct
id|event_info
op_star
id|taskInfo
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|change
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/**********************************&n;&t; * power fault&n;&t; **********************************/
id|info
c_func
(paren
l_string|&quot;power fault interrupt&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|hp_slot
op_assign
l_int|0
suffix:semicolon
id|hp_slot
OL
l_int|6
suffix:semicolon
id|hp_slot
op_increment
)paren
(brace
r_if
c_cond
(paren
id|change
op_amp
(paren
l_int|0x01
op_lshift
id|hp_slot
)paren
)paren
(brace
multiline_comment|/**********************************&n;&t;&t;&t; * this one changed.&n;&t;&t;&t; **********************************/
id|func
op_assign
id|cpqhp_slot_find
c_func
(paren
id|ctrl-&gt;bus
comma
(paren
id|hp_slot
op_plus
id|ctrl-&gt;slot_device_offset
)paren
comma
l_int|0
)paren
suffix:semicolon
id|taskInfo
op_assign
op_amp
(paren
id|ctrl-&gt;event_queue
(braket
id|ctrl-&gt;next_event
)braket
)paren
suffix:semicolon
id|ctrl-&gt;next_event
op_assign
(paren
id|ctrl-&gt;next_event
op_plus
l_int|1
)paren
op_mod
l_int|10
suffix:semicolon
id|taskInfo-&gt;hp_slot
op_assign
id|hp_slot
suffix:semicolon
id|rc
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ctrl-&gt;ctrl_int_comp
op_amp
(paren
l_int|0x00000100
op_lshift
id|hp_slot
)paren
)paren
(brace
multiline_comment|/**********************************&n;&t;&t;&t;&t; * power fault Cleared&n;&t;&t;&t;&t; **********************************/
id|func-&gt;status
op_assign
l_int|0x00
suffix:semicolon
id|taskInfo-&gt;event_type
op_assign
id|INT_POWER_FAULT_CLEAR
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/**********************************&n;&t;&t;&t;&t; * power fault&n;&t;&t;&t;&t; **********************************/
id|taskInfo-&gt;event_type
op_assign
id|INT_POWER_FAULT
suffix:semicolon
r_if
c_cond
(paren
id|ctrl-&gt;rev
OL
l_int|4
)paren
(brace
id|amber_LED_on
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|green_LED_off
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|set_SOGO
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* this is a fatal condition, we want&n;&t;&t;&t;&t;&t; * to crash the machine to protect from&n;&t;&t;&t;&t;&t; * data corruption. simulated_NMI&n;&t;&t;&t;&t;&t; * shouldn&squot;t ever return */
multiline_comment|/* FIXME&n;&t;&t;&t;&t;&t;simulated_NMI(hp_slot, ctrl); */
multiline_comment|/* The following code causes a software&n;&t;&t;&t;&t;&t; * crash just in case simulated_NMI did&n;&t;&t;&t;&t;&t; * return */
multiline_comment|/*FIXME&n;&t;&t;&t;&t;&t;panic(msg_power_fault); */
)brace
r_else
(brace
multiline_comment|/* set power fault status for this board */
id|func-&gt;status
op_assign
l_int|0xFF
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;power fault bit %x set&bslash;n&quot;
comma
id|hp_slot
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; * sort_by_size: sort nodes on the list by their length, smallest first.&n; * @head: list to sort&n; *&n; */
DECL|function|sort_by_size
r_static
r_int
id|sort_by_size
c_func
(paren
r_struct
id|pci_resource
op_star
op_star
id|head
)paren
(brace
r_struct
id|pci_resource
op_star
id|current_res
suffix:semicolon
r_struct
id|pci_resource
op_star
id|next_res
suffix:semicolon
r_int
id|out_of_order
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|head
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|out_of_order
)paren
(brace
id|out_of_order
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Special case for swapping list head */
r_if
c_cond
(paren
(paren
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
)paren
op_logical_and
(paren
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|length
OG
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next-&gt;length
)paren
)paren
(brace
id|out_of_order
op_increment
suffix:semicolon
id|current_res
op_assign
op_star
id|head
suffix:semicolon
op_star
id|head
op_assign
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|current_res-&gt;next
op_assign
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
op_assign
id|current_res
suffix:semicolon
)brace
id|current_res
op_assign
op_star
id|head
suffix:semicolon
r_while
c_loop
(paren
id|current_res-&gt;next
op_logical_and
id|current_res-&gt;next-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|current_res-&gt;next-&gt;length
OG
id|current_res-&gt;next-&gt;next-&gt;length
)paren
(brace
id|out_of_order
op_increment
suffix:semicolon
id|next_res
op_assign
id|current_res-&gt;next
suffix:semicolon
id|current_res-&gt;next
op_assign
id|current_res-&gt;next-&gt;next
suffix:semicolon
id|current_res
op_assign
id|current_res-&gt;next
suffix:semicolon
id|next_res-&gt;next
op_assign
id|current_res-&gt;next
suffix:semicolon
id|current_res-&gt;next
op_assign
id|next_res
suffix:semicolon
)brace
r_else
id|current_res
op_assign
id|current_res-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/* End of out_of_order loop */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * sort_by_max_size: sort nodes on the list by their length, largest first.&n; * @head: list to sort&n; *&n; */
DECL|function|sort_by_max_size
r_static
r_int
id|sort_by_max_size
c_func
(paren
r_struct
id|pci_resource
op_star
op_star
id|head
)paren
(brace
r_struct
id|pci_resource
op_star
id|current_res
suffix:semicolon
r_struct
id|pci_resource
op_star
id|next_res
suffix:semicolon
r_int
id|out_of_order
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|head
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|out_of_order
)paren
(brace
id|out_of_order
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Special case for swapping list head */
r_if
c_cond
(paren
(paren
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
)paren
op_logical_and
(paren
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|length
OL
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next-&gt;length
)paren
)paren
(brace
id|out_of_order
op_increment
suffix:semicolon
id|current_res
op_assign
op_star
id|head
suffix:semicolon
op_star
id|head
op_assign
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|current_res-&gt;next
op_assign
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
op_assign
id|current_res
suffix:semicolon
)brace
id|current_res
op_assign
op_star
id|head
suffix:semicolon
r_while
c_loop
(paren
id|current_res-&gt;next
op_logical_and
id|current_res-&gt;next-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|current_res-&gt;next-&gt;length
OL
id|current_res-&gt;next-&gt;next-&gt;length
)paren
(brace
id|out_of_order
op_increment
suffix:semicolon
id|next_res
op_assign
id|current_res-&gt;next
suffix:semicolon
id|current_res-&gt;next
op_assign
id|current_res-&gt;next-&gt;next
suffix:semicolon
id|current_res
op_assign
id|current_res-&gt;next
suffix:semicolon
id|next_res-&gt;next
op_assign
id|current_res-&gt;next
suffix:semicolon
id|current_res-&gt;next
op_assign
id|next_res
suffix:semicolon
)brace
r_else
id|current_res
op_assign
id|current_res-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/* End of out_of_order loop */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * do_pre_bridge_resource_split: find node of resources that are unused&n; *&n; */
DECL|function|do_pre_bridge_resource_split
r_static
r_struct
id|pci_resource
op_star
id|do_pre_bridge_resource_split
c_func
(paren
r_struct
id|pci_resource
op_star
op_star
id|head
comma
r_struct
id|pci_resource
op_star
op_star
id|orig_head
comma
id|u32
id|alignment
)paren
(brace
r_struct
id|pci_resource
op_star
id|prevnode
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|pci_resource
op_star
id|node
suffix:semicolon
r_struct
id|pci_resource
op_star
id|split_node
suffix:semicolon
id|u32
id|rc
suffix:semicolon
id|u32
id|temp_dword
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;do_pre_bridge_resource_split&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|head
)paren
op_logical_or
op_logical_neg
(paren
op_star
id|orig_head
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|rc
op_assign
id|cpqhp_resource_sort_and_combine
c_func
(paren
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|base
op_ne
(paren
op_star
id|orig_head
)paren
op_member_access_from_pointer
id|base
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|length
op_eq
(paren
op_star
id|orig_head
)paren
op_member_access_from_pointer
id|length
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* If we got here, there the bridge requires some of the resource, but&n;&t; * we may be able to split some off of the front */
id|node
op_assign
op_star
id|head
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;length
op_amp
(paren
id|alignment
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/* this one isn&squot;t an aligned length, so we&squot;ll make a new entry&n;&t;&t; * and split it up. */
id|split_node
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|split_node
)paren
r_return
l_int|NULL
suffix:semicolon
id|temp_dword
op_assign
(paren
id|node-&gt;length
op_or
(paren
id|alignment
op_minus
l_int|1
)paren
)paren
op_plus
l_int|1
op_minus
id|alignment
suffix:semicolon
id|split_node-&gt;base
op_assign
id|node-&gt;base
suffix:semicolon
id|split_node-&gt;length
op_assign
id|temp_dword
suffix:semicolon
id|node-&gt;length
op_sub_assign
id|temp_dword
suffix:semicolon
id|node-&gt;base
op_add_assign
id|split_node-&gt;length
suffix:semicolon
multiline_comment|/* Put it in the list */
op_star
id|head
op_assign
id|split_node
suffix:semicolon
id|split_node-&gt;next
op_assign
id|node
suffix:semicolon
)brace
r_if
c_cond
(paren
id|node-&gt;length
OL
id|alignment
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Now unlink it */
r_if
c_cond
(paren
op_star
id|head
op_eq
id|node
)paren
(brace
op_star
id|head
op_assign
id|node-&gt;next
suffix:semicolon
id|node-&gt;next
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|prevnode
op_assign
op_star
id|head
suffix:semicolon
r_while
c_loop
(paren
id|prevnode-&gt;next
op_ne
id|node
)paren
id|prevnode
op_assign
id|prevnode-&gt;next
suffix:semicolon
id|prevnode-&gt;next
op_assign
id|node-&gt;next
suffix:semicolon
id|node-&gt;next
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|node
suffix:semicolon
)brace
multiline_comment|/**&n; * do_bridge_resource_split: find one node of resources that aren&squot;t in use&n; *&n; */
DECL|function|do_bridge_resource_split
r_static
r_struct
id|pci_resource
op_star
id|do_bridge_resource_split
c_func
(paren
r_struct
id|pci_resource
op_star
op_star
id|head
comma
id|u32
id|alignment
)paren
(brace
r_struct
id|pci_resource
op_star
id|prevnode
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|pci_resource
op_star
id|node
suffix:semicolon
id|u32
id|rc
suffix:semicolon
id|u32
id|temp_dword
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|head
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|rc
op_assign
id|cpqhp_resource_sort_and_combine
c_func
(paren
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
l_int|NULL
suffix:semicolon
id|node
op_assign
op_star
id|head
suffix:semicolon
r_while
c_loop
(paren
id|node-&gt;next
)paren
(brace
id|prevnode
op_assign
id|node
suffix:semicolon
id|node
op_assign
id|node-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|prevnode
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|node-&gt;length
OL
id|alignment
)paren
r_goto
id|error
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;base
op_amp
(paren
id|alignment
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/* Short circuit if adjusted size is too small */
id|temp_dword
op_assign
(paren
id|node-&gt;base
op_or
(paren
id|alignment
op_minus
l_int|1
)paren
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|node-&gt;length
op_minus
(paren
id|temp_dword
op_minus
id|node-&gt;base
)paren
)paren
OL
id|alignment
)paren
r_goto
id|error
suffix:semicolon
id|node-&gt;length
op_sub_assign
(paren
id|temp_dword
op_minus
id|node-&gt;base
)paren
suffix:semicolon
id|node-&gt;base
op_assign
id|temp_dword
suffix:semicolon
)brace
r_if
c_cond
(paren
id|node-&gt;length
op_amp
(paren
id|alignment
op_minus
l_int|1
)paren
)paren
multiline_comment|/* There&squot;s stuff in use after this node */
r_goto
id|error
suffix:semicolon
r_return
id|node
suffix:semicolon
id|error
suffix:colon
id|kfree
c_func
(paren
id|node
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * get_io_resource: find first node of given size not in ISA aliasing window.&n; * @head: list to search&n; * @size: size of node to find, must be a power of two.&n; *&n; * Description: this function sorts the resource list by size and then returns&n; * returns the first node of &quot;size&quot; length that is not in the ISA aliasing&n; * window.  If it finds a node larger than &quot;size&quot; it will split it up.&n; *&n; */
DECL|function|get_io_resource
r_static
r_struct
id|pci_resource
op_star
id|get_io_resource
c_func
(paren
r_struct
id|pci_resource
op_star
op_star
id|head
comma
id|u32
id|size
)paren
(brace
r_struct
id|pci_resource
op_star
id|prevnode
suffix:semicolon
r_struct
id|pci_resource
op_star
id|node
suffix:semicolon
r_struct
id|pci_resource
op_star
id|split_node
suffix:semicolon
id|u32
id|temp_dword
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|head
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cpqhp_resource_sort_and_combine
c_func
(paren
id|head
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sort_by_size
c_func
(paren
id|head
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
op_star
id|head
suffix:semicolon
id|node
suffix:semicolon
id|node
op_assign
id|node-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|node-&gt;length
OL
id|size
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;base
op_amp
(paren
id|size
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/* this one isn&squot;t base aligned properly&n;&t;&t;&t; * so we&squot;ll make a new entry and split it up */
id|temp_dword
op_assign
(paren
id|node-&gt;base
op_or
(paren
id|size
op_minus
l_int|1
)paren
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Short circuit if adjusted size is too small */
r_if
c_cond
(paren
(paren
id|node-&gt;length
op_minus
(paren
id|temp_dword
op_minus
id|node-&gt;base
)paren
)paren
OL
id|size
)paren
r_continue
suffix:semicolon
id|split_node
op_assign
(paren
r_struct
id|pci_resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|split_node
)paren
r_return
l_int|NULL
suffix:semicolon
id|split_node-&gt;base
op_assign
id|node-&gt;base
suffix:semicolon
id|split_node-&gt;length
op_assign
id|temp_dword
op_minus
id|node-&gt;base
suffix:semicolon
id|node-&gt;base
op_assign
id|temp_dword
suffix:semicolon
id|node-&gt;length
op_sub_assign
id|split_node-&gt;length
suffix:semicolon
multiline_comment|/* Put it in the list */
id|split_node-&gt;next
op_assign
id|node-&gt;next
suffix:semicolon
id|node-&gt;next
op_assign
id|split_node
suffix:semicolon
)brace
multiline_comment|/* End of non-aligned base */
multiline_comment|/* Don&squot;t need to check if too small since we already did */
r_if
c_cond
(paren
id|node-&gt;length
OG
id|size
)paren
(brace
multiline_comment|/* this one is longer than we need&n;&t;&t;&t; * so we&squot;ll make a new entry and split it up */
id|split_node
op_assign
(paren
r_struct
id|pci_resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|split_node
)paren
r_return
l_int|NULL
suffix:semicolon
id|split_node-&gt;base
op_assign
id|node-&gt;base
op_plus
id|size
suffix:semicolon
id|split_node-&gt;length
op_assign
id|node-&gt;length
op_minus
id|size
suffix:semicolon
id|node-&gt;length
op_assign
id|size
suffix:semicolon
multiline_comment|/* Put it in the list */
id|split_node-&gt;next
op_assign
id|node-&gt;next
suffix:semicolon
id|node-&gt;next
op_assign
id|split_node
suffix:semicolon
)brace
multiline_comment|/* End of too big on top end */
multiline_comment|/* For IO make sure it&squot;s not in the ISA aliasing space */
r_if
c_cond
(paren
id|node-&gt;base
op_amp
l_int|0x300L
)paren
r_continue
suffix:semicolon
multiline_comment|/* If we got here, then it is the right size&n;&t;&t; * Now take it out of the list and break */
r_if
c_cond
(paren
op_star
id|head
op_eq
id|node
)paren
(brace
op_star
id|head
op_assign
id|node-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|prevnode
op_assign
op_star
id|head
suffix:semicolon
r_while
c_loop
(paren
id|prevnode-&gt;next
op_ne
id|node
)paren
id|prevnode
op_assign
id|prevnode-&gt;next
suffix:semicolon
id|prevnode-&gt;next
op_assign
id|node-&gt;next
suffix:semicolon
)brace
id|node-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|node
suffix:semicolon
)brace
multiline_comment|/**&n; * get_max_resource: get largest node which has at least the given size.&n; * @head: the list to search the node in&n; * @size: the minimum size of the node to find&n; *&n; * Description: Gets the largest node that is at least &quot;size&quot; big from the&n; * list pointed to by head.  It aligns the node on top and bottom&n; * to &quot;size&quot; alignment before returning it.&n; */
DECL|function|get_max_resource
r_static
r_struct
id|pci_resource
op_star
id|get_max_resource
c_func
(paren
r_struct
id|pci_resource
op_star
op_star
id|head
comma
id|u32
id|size
)paren
(brace
r_struct
id|pci_resource
op_star
id|max
suffix:semicolon
r_struct
id|pci_resource
op_star
id|temp
suffix:semicolon
r_struct
id|pci_resource
op_star
id|split_node
suffix:semicolon
id|u32
id|temp_dword
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|head
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cpqhp_resource_sort_and_combine
c_func
(paren
id|head
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sort_by_max_size
c_func
(paren
id|head
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|max
op_assign
op_star
id|head
suffix:semicolon
id|max
suffix:semicolon
id|max
op_assign
id|max-&gt;next
)paren
(brace
multiline_comment|/* If not big enough we could probably just bail, &n;&t;&t; * instead we&squot;ll continue to the next. */
r_if
c_cond
(paren
id|max-&gt;length
OL
id|size
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|max-&gt;base
op_amp
(paren
id|size
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/* this one isn&squot;t base aligned properly&n;&t;&t;&t; * so we&squot;ll make a new entry and split it up */
id|temp_dword
op_assign
(paren
id|max-&gt;base
op_or
(paren
id|size
op_minus
l_int|1
)paren
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Short circuit if adjusted size is too small */
r_if
c_cond
(paren
(paren
id|max-&gt;length
op_minus
(paren
id|temp_dword
op_minus
id|max-&gt;base
)paren
)paren
OL
id|size
)paren
r_continue
suffix:semicolon
id|split_node
op_assign
(paren
r_struct
id|pci_resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|split_node
)paren
r_return
l_int|NULL
suffix:semicolon
id|split_node-&gt;base
op_assign
id|max-&gt;base
suffix:semicolon
id|split_node-&gt;length
op_assign
id|temp_dword
op_minus
id|max-&gt;base
suffix:semicolon
id|max-&gt;base
op_assign
id|temp_dword
suffix:semicolon
id|max-&gt;length
op_sub_assign
id|split_node-&gt;length
suffix:semicolon
id|split_node-&gt;next
op_assign
id|max-&gt;next
suffix:semicolon
id|max-&gt;next
op_assign
id|split_node
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|max-&gt;base
op_plus
id|max-&gt;length
)paren
op_amp
(paren
id|size
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/* this one isn&squot;t end aligned properly at the top&n;&t;&t;&t; * so we&squot;ll make a new entry and split it up */
id|split_node
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|split_node
)paren
r_return
l_int|NULL
suffix:semicolon
id|temp_dword
op_assign
(paren
(paren
id|max-&gt;base
op_plus
id|max-&gt;length
)paren
op_amp
op_complement
(paren
id|size
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|split_node-&gt;base
op_assign
id|temp_dword
suffix:semicolon
id|split_node-&gt;length
op_assign
id|max-&gt;length
op_plus
id|max-&gt;base
op_minus
id|split_node-&gt;base
suffix:semicolon
id|max-&gt;length
op_sub_assign
id|split_node-&gt;length
suffix:semicolon
id|split_node-&gt;next
op_assign
id|max-&gt;next
suffix:semicolon
id|max-&gt;next
op_assign
id|split_node
suffix:semicolon
)brace
multiline_comment|/* Make sure it didn&squot;t shrink too much when we aligned it */
r_if
c_cond
(paren
id|max-&gt;length
OL
id|size
)paren
r_continue
suffix:semicolon
multiline_comment|/* Now take it out of the list */
id|temp
op_assign
op_star
id|head
suffix:semicolon
r_if
c_cond
(paren
id|temp
op_eq
id|max
)paren
(brace
op_star
id|head
op_assign
id|max-&gt;next
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
id|temp
op_logical_and
id|temp-&gt;next
op_ne
id|max
)paren
(brace
id|temp
op_assign
id|temp-&gt;next
suffix:semicolon
)brace
id|temp-&gt;next
op_assign
id|max-&gt;next
suffix:semicolon
)brace
id|max-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|max
suffix:semicolon
)brace
multiline_comment|/**&n; * get_resource: find resource of given size and split up larger ones.&n; * @head: the list to search for resources&n; * @size: the size limit to use&n; *&n; * Description: This function sorts the resource list by size and then&n; * returns the first node of &quot;size&quot; length.  If it finds a node&n; * larger than &quot;size&quot; it will split it up.&n; *&n; * size must be a power of two.&n; */
DECL|function|get_resource
r_static
r_struct
id|pci_resource
op_star
id|get_resource
c_func
(paren
r_struct
id|pci_resource
op_star
op_star
id|head
comma
id|u32
id|size
)paren
(brace
r_struct
id|pci_resource
op_star
id|prevnode
suffix:semicolon
r_struct
id|pci_resource
op_star
id|node
suffix:semicolon
r_struct
id|pci_resource
op_star
id|split_node
suffix:semicolon
id|u32
id|temp_dword
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|head
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cpqhp_resource_sort_and_combine
c_func
(paren
id|head
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sort_by_size
c_func
(paren
id|head
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
op_star
id|head
suffix:semicolon
id|node
suffix:semicolon
id|node
op_assign
id|node-&gt;next
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s: req_size =%x node=%p, base=%x, length=%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|size
comma
id|node
comma
id|node-&gt;base
comma
id|node-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;length
OL
id|size
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;base
op_amp
(paren
id|size
op_minus
l_int|1
)paren
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s: not aligned&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* this one isn&squot;t base aligned properly&n;&t;&t;&t; * so we&squot;ll make a new entry and split it up */
id|temp_dword
op_assign
(paren
id|node-&gt;base
op_or
(paren
id|size
op_minus
l_int|1
)paren
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Short circuit if adjusted size is too small */
r_if
c_cond
(paren
(paren
id|node-&gt;length
op_minus
(paren
id|temp_dword
op_minus
id|node-&gt;base
)paren
)paren
OL
id|size
)paren
r_continue
suffix:semicolon
id|split_node
op_assign
(paren
r_struct
id|pci_resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|split_node
)paren
r_return
l_int|NULL
suffix:semicolon
id|split_node-&gt;base
op_assign
id|node-&gt;base
suffix:semicolon
id|split_node-&gt;length
op_assign
id|temp_dword
op_minus
id|node-&gt;base
suffix:semicolon
id|node-&gt;base
op_assign
id|temp_dword
suffix:semicolon
id|node-&gt;length
op_sub_assign
id|split_node-&gt;length
suffix:semicolon
id|split_node-&gt;next
op_assign
id|node-&gt;next
suffix:semicolon
id|node-&gt;next
op_assign
id|split_node
suffix:semicolon
)brace
multiline_comment|/* End of non-aligned base */
multiline_comment|/* Don&squot;t need to check if too small since we already did */
r_if
c_cond
(paren
id|node-&gt;length
OG
id|size
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s: too big&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* this one is longer than we need&n;&t;&t;&t; * so we&squot;ll make a new entry and split it up */
id|split_node
op_assign
(paren
r_struct
id|pci_resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|split_node
)paren
r_return
l_int|NULL
suffix:semicolon
id|split_node-&gt;base
op_assign
id|node-&gt;base
op_plus
id|size
suffix:semicolon
id|split_node-&gt;length
op_assign
id|node-&gt;length
op_minus
id|size
suffix:semicolon
id|node-&gt;length
op_assign
id|size
suffix:semicolon
multiline_comment|/* Put it in the list */
id|split_node-&gt;next
op_assign
id|node-&gt;next
suffix:semicolon
id|node-&gt;next
op_assign
id|split_node
suffix:semicolon
)brace
multiline_comment|/* End of too big on top end */
id|dbg
c_func
(paren
l_string|&quot;%s: got one!!!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* If we got here, then it is the right size&n;&t;&t; * Now take it out of the list */
r_if
c_cond
(paren
op_star
id|head
op_eq
id|node
)paren
(brace
op_star
id|head
op_assign
id|node-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|prevnode
op_assign
op_star
id|head
suffix:semicolon
r_while
c_loop
(paren
id|prevnode-&gt;next
op_ne
id|node
)paren
id|prevnode
op_assign
id|prevnode-&gt;next
suffix:semicolon
id|prevnode-&gt;next
op_assign
id|node-&gt;next
suffix:semicolon
)brace
id|node-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|node
suffix:semicolon
)brace
multiline_comment|/**&n; * cpqhp_resource_sort_and_combine: sort nodes by base addresses and clean up.&n; * @head: the list to sort and clean up&n; *&n; * Description: Sorts all of the nodes in the list in ascending order by&n; * their base addresses.  Also does garbage collection by&n; * combining adjacent nodes.&n; *&n; * returns 0 if success&n; */
DECL|function|cpqhp_resource_sort_and_combine
r_int
id|cpqhp_resource_sort_and_combine
c_func
(paren
r_struct
id|pci_resource
op_star
op_star
id|head
)paren
(brace
r_struct
id|pci_resource
op_star
id|node1
suffix:semicolon
r_struct
id|pci_resource
op_star
id|node2
suffix:semicolon
r_int
id|out_of_order
op_assign
l_int|1
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: head = %p, *head = %p&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|head
comma
op_star
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|head
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;*head-&gt;next = %p&bslash;n&quot;
comma
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* only one item on the list, already sorted! */
id|dbg
c_func
(paren
l_string|&quot;*head-&gt;base = 0x%x&bslash;n&quot;
comma
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|base
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;*head-&gt;next-&gt;base = 0x%x&bslash;n&quot;
comma
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next-&gt;base
)paren
suffix:semicolon
r_while
c_loop
(paren
id|out_of_order
)paren
(brace
id|out_of_order
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Special case for swapping list head */
r_if
c_cond
(paren
(paren
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
)paren
op_logical_and
(paren
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|base
OG
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next-&gt;base
)paren
)paren
(brace
id|node1
op_assign
op_star
id|head
suffix:semicolon
(paren
op_star
id|head
)paren
op_assign
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|node1-&gt;next
op_assign
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|next
op_assign
id|node1
suffix:semicolon
id|out_of_order
op_increment
suffix:semicolon
)brace
id|node1
op_assign
(paren
op_star
id|head
)paren
suffix:semicolon
r_while
c_loop
(paren
id|node1-&gt;next
op_logical_and
id|node1-&gt;next-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|node1-&gt;next-&gt;base
OG
id|node1-&gt;next-&gt;next-&gt;base
)paren
(brace
id|out_of_order
op_increment
suffix:semicolon
id|node2
op_assign
id|node1-&gt;next
suffix:semicolon
id|node1-&gt;next
op_assign
id|node1-&gt;next-&gt;next
suffix:semicolon
id|node1
op_assign
id|node1-&gt;next
suffix:semicolon
id|node2-&gt;next
op_assign
id|node1-&gt;next
suffix:semicolon
id|node1-&gt;next
op_assign
id|node2
suffix:semicolon
)brace
r_else
id|node1
op_assign
id|node1-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/* End of out_of_order loop */
id|node1
op_assign
op_star
id|head
suffix:semicolon
r_while
c_loop
(paren
id|node1
op_logical_and
id|node1-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|node1-&gt;base
op_plus
id|node1-&gt;length
)paren
op_eq
id|node1-&gt;next-&gt;base
)paren
(brace
multiline_comment|/* Combine */
id|dbg
c_func
(paren
l_string|&quot;8..&bslash;n&quot;
)paren
suffix:semicolon
id|node1-&gt;length
op_add_assign
id|node1-&gt;next-&gt;length
suffix:semicolon
id|node2
op_assign
id|node1-&gt;next
suffix:semicolon
id|node1-&gt;next
op_assign
id|node1-&gt;next-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|node2
)paren
suffix:semicolon
)brace
r_else
id|node1
op_assign
id|node1-&gt;next
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cpqhp_ctrl_intr
id|irqreturn_t
id|cpqhp_ctrl_intr
c_func
(paren
r_int
id|IRQ
comma
r_void
op_star
id|data
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|controller
op_star
id|ctrl
op_assign
id|data
suffix:semicolon
id|u8
id|schedule_flag
op_assign
l_int|0
suffix:semicolon
id|u8
id|reset
suffix:semicolon
id|u16
id|misc
suffix:semicolon
id|u32
id|Diff
suffix:semicolon
id|u32
id|temp_dword
suffix:semicolon
id|misc
op_assign
id|readw
c_func
(paren
id|ctrl-&gt;hpc_reg
op_plus
id|MISC
)paren
suffix:semicolon
multiline_comment|/***************************************&n;&t; * Check to see if it was our interrupt&n;&t; ***************************************/
r_if
c_cond
(paren
op_logical_neg
(paren
id|misc
op_amp
l_int|0x000C
)paren
)paren
(brace
r_return
id|IRQ_NONE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|misc
op_amp
l_int|0x0004
)paren
(brace
multiline_comment|/**********************************&n;&t;&t; * Serial Output interrupt Pending&n;&t;&t; **********************************/
multiline_comment|/* Clear the interrupt */
id|misc
op_or_assign
l_int|0x0004
suffix:semicolon
id|writew
c_func
(paren
id|misc
comma
id|ctrl-&gt;hpc_reg
op_plus
id|MISC
)paren
suffix:semicolon
multiline_comment|/* Read to clear posted writes */
id|misc
op_assign
id|readw
c_func
(paren
id|ctrl-&gt;hpc_reg
op_plus
id|MISC
)paren
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s - waking up&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|ctrl-&gt;queue
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|misc
op_amp
l_int|0x0008
)paren
(brace
multiline_comment|/* General-interrupt-input interrupt Pending */
id|Diff
op_assign
id|readl
c_func
(paren
id|ctrl-&gt;hpc_reg
op_plus
id|INT_INPUT_CLEAR
)paren
op_xor
id|ctrl-&gt;ctrl_int_comp
suffix:semicolon
id|ctrl-&gt;ctrl_int_comp
op_assign
id|readl
c_func
(paren
id|ctrl-&gt;hpc_reg
op_plus
id|INT_INPUT_CLEAR
)paren
suffix:semicolon
multiline_comment|/* Clear the interrupt */
id|writel
c_func
(paren
id|Diff
comma
id|ctrl-&gt;hpc_reg
op_plus
id|INT_INPUT_CLEAR
)paren
suffix:semicolon
multiline_comment|/* Read it back to clear any posted writes */
id|temp_dword
op_assign
id|readl
c_func
(paren
id|ctrl-&gt;hpc_reg
op_plus
id|INT_INPUT_CLEAR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|Diff
)paren
multiline_comment|/* Clear all interrupts */
id|writel
c_func
(paren
l_int|0xFFFFFFFF
comma
id|ctrl-&gt;hpc_reg
op_plus
id|INT_INPUT_CLEAR
)paren
suffix:semicolon
id|schedule_flag
op_add_assign
id|handle_switch_change
c_func
(paren
(paren
id|u8
)paren
(paren
id|Diff
op_amp
l_int|0xFFL
)paren
comma
id|ctrl
)paren
suffix:semicolon
id|schedule_flag
op_add_assign
id|handle_presence_change
c_func
(paren
(paren
id|u16
)paren
(paren
(paren
id|Diff
op_amp
l_int|0xFFFF0000L
)paren
op_rshift
l_int|16
)paren
comma
id|ctrl
)paren
suffix:semicolon
id|schedule_flag
op_add_assign
id|handle_power_fault
c_func
(paren
(paren
id|u8
)paren
(paren
(paren
id|Diff
op_amp
l_int|0xFF00L
)paren
op_rshift
l_int|8
)paren
comma
id|ctrl
)paren
suffix:semicolon
)brace
id|reset
op_assign
id|readb
c_func
(paren
id|ctrl-&gt;hpc_reg
op_plus
id|RESET_FREQ_MODE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reset
op_amp
l_int|0x40
)paren
(brace
multiline_comment|/* Bus reset has completed */
id|reset
op_and_assign
l_int|0xCF
suffix:semicolon
id|writeb
c_func
(paren
id|reset
comma
id|ctrl-&gt;hpc_reg
op_plus
id|RESET_FREQ_MODE
)paren
suffix:semicolon
id|reset
op_assign
id|readb
c_func
(paren
id|ctrl-&gt;hpc_reg
op_plus
id|RESET_FREQ_MODE
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|ctrl-&gt;queue
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|schedule_flag
)paren
(brace
id|up
c_func
(paren
op_amp
id|event_semaphore
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Signal event_semaphore&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/**&n; * cpqhp_slot_create - Creates a node and adds it to the proper bus.&n; * @busnumber - bus where new node is to be located&n; *&n; * Returns pointer to the new node or NULL if unsuccessful&n; */
DECL|function|cpqhp_slot_create
r_struct
id|pci_func
op_star
id|cpqhp_slot_create
c_func
(paren
id|u8
id|busnumber
)paren
(brace
r_struct
id|pci_func
op_star
id|new_slot
suffix:semicolon
r_struct
id|pci_func
op_star
id|next
suffix:semicolon
id|new_slot
op_assign
(paren
r_struct
id|pci_func
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_func
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_slot
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* I&squot;m not dead yet!&n;&t;&t; * You will be. */
r_return
id|new_slot
suffix:semicolon
)brace
id|memset
c_func
(paren
id|new_slot
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|pci_func
)paren
)paren
suffix:semicolon
id|new_slot-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|new_slot-&gt;configured
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cpqhp_slot_list
(braket
id|busnumber
)braket
op_eq
l_int|NULL
)paren
(brace
id|cpqhp_slot_list
(braket
id|busnumber
)braket
op_assign
id|new_slot
suffix:semicolon
)brace
r_else
(brace
id|next
op_assign
id|cpqhp_slot_list
(braket
id|busnumber
)braket
suffix:semicolon
r_while
c_loop
(paren
id|next-&gt;next
op_ne
l_int|NULL
)paren
id|next
op_assign
id|next-&gt;next
suffix:semicolon
id|next-&gt;next
op_assign
id|new_slot
suffix:semicolon
)brace
r_return
id|new_slot
suffix:semicolon
)brace
multiline_comment|/**&n; * slot_remove - Removes a node from the linked list of slots.&n; * @old_slot: slot to remove&n; *&n; * Returns 0 if successful, !0 otherwise.&n; */
DECL|function|slot_remove
r_static
r_int
id|slot_remove
c_func
(paren
r_struct
id|pci_func
op_star
id|old_slot
)paren
(brace
r_struct
id|pci_func
op_star
id|next
suffix:semicolon
r_if
c_cond
(paren
id|old_slot
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
id|next
op_assign
id|cpqhp_slot_list
(braket
id|old_slot-&gt;bus
)braket
suffix:semicolon
r_if
c_cond
(paren
id|next
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|next
op_eq
id|old_slot
)paren
(brace
id|cpqhp_slot_list
(braket
id|old_slot-&gt;bus
)braket
op_assign
id|old_slot-&gt;next
suffix:semicolon
id|cpqhp_destroy_board_resources
c_func
(paren
id|old_slot
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|old_slot
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|next-&gt;next
op_ne
id|old_slot
)paren
op_logical_and
(paren
id|next-&gt;next
op_ne
l_int|NULL
)paren
)paren
(brace
id|next
op_assign
id|next-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|next-&gt;next
op_eq
id|old_slot
)paren
(brace
id|next-&gt;next
op_assign
id|old_slot-&gt;next
suffix:semicolon
id|cpqhp_destroy_board_resources
c_func
(paren
id|old_slot
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|old_slot
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
l_int|2
suffix:semicolon
)brace
multiline_comment|/**&n; * bridge_slot_remove - Removes a node from the linked list of slots.&n; * @bridge: bridge to remove&n; *&n; * Returns 0 if successful, !0 otherwise.&n; */
DECL|function|bridge_slot_remove
r_static
r_int
id|bridge_slot_remove
c_func
(paren
r_struct
id|pci_func
op_star
id|bridge
)paren
(brace
id|u8
id|subordinateBus
comma
id|secondaryBus
suffix:semicolon
id|u8
id|tempBus
suffix:semicolon
r_struct
id|pci_func
op_star
id|next
suffix:semicolon
r_if
c_cond
(paren
id|bridge
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
id|secondaryBus
op_assign
(paren
id|bridge-&gt;config_space
(braket
l_int|0x06
)braket
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|subordinateBus
op_assign
(paren
id|bridge-&gt;config_space
(braket
l_int|0x06
)braket
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
suffix:semicolon
r_for
c_loop
(paren
id|tempBus
op_assign
id|secondaryBus
suffix:semicolon
id|tempBus
op_le
id|subordinateBus
suffix:semicolon
id|tempBus
op_increment
)paren
(brace
id|next
op_assign
id|cpqhp_slot_list
(braket
id|tempBus
)braket
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|slot_remove
c_func
(paren
id|next
)paren
)paren
(brace
id|next
op_assign
id|cpqhp_slot_list
(braket
id|tempBus
)braket
suffix:semicolon
)brace
)brace
id|next
op_assign
id|cpqhp_slot_list
(braket
id|bridge-&gt;bus
)braket
suffix:semicolon
r_if
c_cond
(paren
id|next
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|next
op_eq
id|bridge
)paren
(brace
id|cpqhp_slot_list
(braket
id|bridge-&gt;bus
)braket
op_assign
id|bridge-&gt;next
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|next-&gt;next
op_ne
id|bridge
)paren
op_logical_and
(paren
id|next-&gt;next
op_ne
l_int|NULL
)paren
)paren
id|next
op_assign
id|next-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|next-&gt;next
op_ne
id|bridge
)paren
r_return
l_int|2
suffix:semicolon
id|next-&gt;next
op_assign
id|bridge-&gt;next
suffix:semicolon
id|out
suffix:colon
id|kfree
c_func
(paren
id|bridge
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * cpqhp_slot_find - Looks for a node by bus, and device, multiple functions accessed&n; * @bus: bus to find&n; * @device: device to find&n; * @index: is 0 for first function found, 1 for the second...&n; *&n; * Returns pointer to the node if successful, %NULL otherwise.&n; */
DECL|function|cpqhp_slot_find
r_struct
id|pci_func
op_star
id|cpqhp_slot_find
c_func
(paren
id|u8
id|bus
comma
id|u8
id|device
comma
id|u8
id|index
)paren
(brace
r_int
id|found
op_assign
op_minus
l_int|1
suffix:semicolon
r_struct
id|pci_func
op_star
id|func
suffix:semicolon
id|func
op_assign
id|cpqhp_slot_list
(braket
id|bus
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|func
op_eq
l_int|NULL
)paren
op_logical_or
(paren
(paren
id|func-&gt;device
op_eq
id|device
)paren
op_logical_and
(paren
id|index
op_eq
l_int|0
)paren
)paren
)paren
r_return
id|func
suffix:semicolon
r_if
c_cond
(paren
id|func-&gt;device
op_eq
id|device
)paren
id|found
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|func-&gt;next
op_ne
l_int|NULL
)paren
(brace
id|func
op_assign
id|func-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|func-&gt;device
op_eq
id|device
)paren
id|found
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|found
op_eq
id|index
)paren
r_return
id|func
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* DJZ: I don&squot;t think is_bridge will work as is.&n; * FIXME */
DECL|function|is_bridge
r_static
r_int
id|is_bridge
c_func
(paren
r_struct
id|pci_func
op_star
id|func
)paren
(brace
multiline_comment|/* Check the header type */
r_if
c_cond
(paren
(paren
(paren
id|func-&gt;config_space
(braket
l_int|0x03
)braket
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
)paren
op_eq
l_int|0x01
)paren
r_return
l_int|1
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * set_controller_speed - set the frequency and/or mode of a specific&n; * controller segment.&n; *&n; * @ctrl: controller to change frequency/mode for.&n; * @adapter_speed: the speed of the adapter we want to match.&n; * @hp_slot: the slot number where the adapter is installed.&n; *&n; * Returns 0 if we successfully change frequency and/or mode to match the&n; * adapter speed.&n; * &n; */
DECL|function|set_controller_speed
r_static
id|u8
id|set_controller_speed
c_func
(paren
r_struct
id|controller
op_star
id|ctrl
comma
id|u8
id|adapter_speed
comma
id|u8
id|hp_slot
)paren
(brace
r_struct
id|slot
op_star
id|slot
suffix:semicolon
id|u8
id|reg
suffix:semicolon
id|u8
id|slot_power
op_assign
id|readb
c_func
(paren
id|ctrl-&gt;hpc_reg
op_plus
id|SLOT_POWER
)paren
suffix:semicolon
id|u16
id|reg16
suffix:semicolon
id|u32
id|leds
op_assign
id|readl
c_func
(paren
id|ctrl-&gt;hpc_reg
op_plus
id|LED_CONTROL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctrl-&gt;speed
op_eq
id|adapter_speed
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* We don&squot;t allow freq/mode changes if we find another adapter running&n;&t; * in another slot on this controller */
r_for
c_loop
(paren
id|slot
op_assign
id|ctrl-&gt;slot
suffix:semicolon
id|slot
suffix:semicolon
id|slot
op_assign
id|slot-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|slot-&gt;device
op_eq
(paren
id|hp_slot
op_plus
id|ctrl-&gt;slot_device_offset
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|slot-&gt;hotplug_slot
op_logical_and
op_logical_neg
id|slot-&gt;hotplug_slot-&gt;info
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|slot-&gt;hotplug_slot-&gt;info-&gt;adapter_status
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* If another adapter is running on the same segment but at a&n;&t;&t; * lower speed/mode, we allow the new adapter to function at&n;&t;&t; * this rate if supported */
r_if
c_cond
(paren
id|ctrl-&gt;speed
OL
id|adapter_speed
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* If the controller doesn&squot;t support freq/mode changes and the&n;&t; * controller is running at a higher mode, we bail */
r_if
c_cond
(paren
(paren
id|ctrl-&gt;speed
OG
id|adapter_speed
)paren
op_logical_and
(paren
op_logical_neg
id|ctrl-&gt;pcix_speed_capability
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* But we allow the adapter to run at a lower rate if possible */
r_if
c_cond
(paren
(paren
id|ctrl-&gt;speed
OL
id|adapter_speed
)paren
op_logical_and
(paren
op_logical_neg
id|ctrl-&gt;pcix_speed_capability
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* We try to set the max speed supported by both the adapter and&n;&t; * controller */
r_if
c_cond
(paren
id|ctrl-&gt;speed_capability
OL
id|adapter_speed
)paren
(brace
r_if
c_cond
(paren
id|ctrl-&gt;speed
op_eq
id|ctrl-&gt;speed_capability
)paren
r_return
l_int|0
suffix:semicolon
id|adapter_speed
op_assign
id|ctrl-&gt;speed_capability
suffix:semicolon
)brace
id|writel
c_func
(paren
l_int|0x0L
comma
id|ctrl-&gt;hpc_reg
op_plus
id|LED_CONTROL
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0x00
comma
id|ctrl-&gt;hpc_reg
op_plus
id|SLOT_ENABLE
)paren
suffix:semicolon
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
id|wait_for_ctrl_irq
c_func
(paren
id|ctrl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adapter_speed
op_ne
id|PCI_SPEED_133MHz_PCIX
)paren
id|reg
op_assign
l_int|0xF5
suffix:semicolon
r_else
id|reg
op_assign
l_int|0xF4
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|ctrl-&gt;pci_dev
comma
l_int|0x41
comma
id|reg
)paren
suffix:semicolon
id|reg16
op_assign
id|readw
c_func
(paren
id|ctrl-&gt;hpc_reg
op_plus
id|NEXT_CURR_FREQ
)paren
suffix:semicolon
id|reg16
op_and_assign
op_complement
l_int|0x000F
suffix:semicolon
r_switch
c_cond
(paren
id|adapter_speed
)paren
(brace
r_case
(paren
id|PCI_SPEED_133MHz_PCIX
)paren
suffix:colon
id|reg
op_assign
l_int|0x75
suffix:semicolon
id|reg16
op_or_assign
l_int|0xB
suffix:semicolon
r_break
suffix:semicolon
r_case
(paren
id|PCI_SPEED_100MHz_PCIX
)paren
suffix:colon
id|reg
op_assign
l_int|0x74
suffix:semicolon
id|reg16
op_or_assign
l_int|0xA
suffix:semicolon
r_break
suffix:semicolon
r_case
(paren
id|PCI_SPEED_66MHz_PCIX
)paren
suffix:colon
id|reg
op_assign
l_int|0x73
suffix:semicolon
id|reg16
op_or_assign
l_int|0x9
suffix:semicolon
r_break
suffix:semicolon
r_case
(paren
id|PCI_SPEED_66MHz
)paren
suffix:colon
id|reg
op_assign
l_int|0x73
suffix:semicolon
id|reg16
op_or_assign
l_int|0x1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* 33MHz PCI 2.2 */
id|reg
op_assign
l_int|0x71
suffix:semicolon
r_break
suffix:semicolon
)brace
id|reg16
op_or_assign
l_int|0xB
op_lshift
l_int|12
suffix:semicolon
id|writew
c_func
(paren
id|reg16
comma
id|ctrl-&gt;hpc_reg
op_plus
id|NEXT_CURR_FREQ
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
multiline_comment|/* Reenable interrupts */
id|writel
c_func
(paren
l_int|0
comma
id|ctrl-&gt;hpc_reg
op_plus
id|INT_MASK
)paren
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|ctrl-&gt;pci_dev
comma
l_int|0x41
comma
id|reg
)paren
suffix:semicolon
multiline_comment|/* Restart state machine */
id|reg
op_assign
op_complement
l_int|0xF
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|ctrl-&gt;pci_dev
comma
l_int|0x43
comma
op_amp
id|reg
)paren
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|ctrl-&gt;pci_dev
comma
l_int|0x43
comma
id|reg
)paren
suffix:semicolon
multiline_comment|/* Only if mode change...*/
r_if
c_cond
(paren
(paren
(paren
id|ctrl-&gt;speed
op_eq
id|PCI_SPEED_66MHz
)paren
op_logical_and
(paren
id|adapter_speed
op_eq
id|PCI_SPEED_66MHz_PCIX
)paren
)paren
op_logical_or
(paren
(paren
id|ctrl-&gt;speed
op_eq
id|PCI_SPEED_66MHz_PCIX
)paren
op_logical_and
(paren
id|adapter_speed
op_eq
id|PCI_SPEED_66MHz
)paren
)paren
)paren
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
id|wait_for_ctrl_irq
c_func
(paren
id|ctrl
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1100
)paren
suffix:semicolon
multiline_comment|/* Restore LED/Slot state */
id|writel
c_func
(paren
id|leds
comma
id|ctrl-&gt;hpc_reg
op_plus
id|LED_CONTROL
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|slot_power
comma
id|ctrl-&gt;hpc_reg
op_plus
id|SLOT_ENABLE
)paren
suffix:semicolon
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
id|wait_for_ctrl_irq
c_func
(paren
id|ctrl
)paren
suffix:semicolon
id|ctrl-&gt;speed
op_assign
id|adapter_speed
suffix:semicolon
id|slot
op_assign
id|cpqhp_find_slot
c_func
(paren
id|ctrl
comma
id|hp_slot
op_plus
id|ctrl-&gt;slot_device_offset
)paren
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;Successfully changed frequency/mode for adapter in slot %d&bslash;n&quot;
comma
id|slot-&gt;number
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* the following routines constitute the bulk of the &n;   hotplug controller logic&n; */
multiline_comment|/**&n; * board_replaced - Called after a board has been replaced in the system.&n; *&n; * This is only used if we don&squot;t have resources for hot add&n; * Turns power on for the board&n; * Checks to see if board is the same&n; * If board is same, reconfigures it&n; * If board isn&squot;t same, turns it back off.&n; *&n; */
DECL|function|board_replaced
r_static
id|u32
id|board_replaced
c_func
(paren
r_struct
id|pci_func
op_star
id|func
comma
r_struct
id|controller
op_star
id|ctrl
)paren
(brace
id|u8
id|hp_slot
suffix:semicolon
id|u8
id|temp_byte
suffix:semicolon
id|u8
id|adapter_speed
suffix:semicolon
id|u32
id|index
suffix:semicolon
id|u32
id|rc
op_assign
l_int|0
suffix:semicolon
id|u32
id|src
op_assign
l_int|8
suffix:semicolon
id|hp_slot
op_assign
id|func-&gt;device
op_minus
id|ctrl-&gt;slot_device_offset
suffix:semicolon
r_if
c_cond
(paren
id|readl
c_func
(paren
id|ctrl-&gt;hpc_reg
op_plus
id|INT_INPUT_CLEAR
)paren
op_amp
(paren
l_int|0x01L
op_lshift
id|hp_slot
)paren
)paren
(brace
multiline_comment|/**********************************&n;&t;&t; * The switch is open.&n;&t;&t; **********************************/
id|rc
op_assign
id|INTERLOCK_OPEN
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|is_slot_enabled
(paren
id|ctrl
comma
id|hp_slot
)paren
)paren
(brace
multiline_comment|/**********************************&n;&t;&t; * The board is already on&n;&t;&t; **********************************/
id|rc
op_assign
id|CARD_FUNCTIONING
suffix:semicolon
)brace
r_else
(brace
id|down
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
multiline_comment|/* turn on board without attaching to the bus */
id|enable_slot_power
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Wait for SOBS to be unset */
id|wait_for_ctrl_irq
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Change bits in slot power register to force another shift out&n;&t;&t; * NOTE: this is to work around the timer bug */
id|temp_byte
op_assign
id|readb
c_func
(paren
id|ctrl-&gt;hpc_reg
op_plus
id|SLOT_POWER
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0x00
comma
id|ctrl-&gt;hpc_reg
op_plus
id|SLOT_POWER
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|temp_byte
comma
id|ctrl-&gt;hpc_reg
op_plus
id|SLOT_POWER
)paren
suffix:semicolon
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Wait for SOBS to be unset */
id|wait_for_ctrl_irq
(paren
id|ctrl
)paren
suffix:semicolon
id|adapter_speed
op_assign
id|get_adapter_speed
c_func
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctrl-&gt;speed
op_ne
id|adapter_speed
)paren
r_if
c_cond
(paren
id|set_controller_speed
c_func
(paren
id|ctrl
comma
id|adapter_speed
comma
id|hp_slot
)paren
)paren
id|rc
op_assign
id|WRONG_BUS_FREQUENCY
suffix:semicolon
multiline_comment|/* turn off board without attaching to the bus */
id|disable_slot_power
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Wait for SOBS to be unset */
id|wait_for_ctrl_irq
(paren
id|ctrl
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
id|slot_enable
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|green_LED_blink
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|amber_LED_off
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Wait for SOBS to be unset */
id|wait_for_ctrl_irq
(paren
id|ctrl
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
multiline_comment|/* Wait for ~1 second because of hot plug spec */
id|long_delay
c_func
(paren
l_int|1
op_star
id|HZ
)paren
suffix:semicolon
multiline_comment|/* Check for a power fault */
r_if
c_cond
(paren
id|func-&gt;status
op_eq
l_int|0xFF
)paren
(brace
multiline_comment|/* power fault occurred, but it was benign */
id|rc
op_assign
id|POWER_FAILURE
suffix:semicolon
id|func-&gt;status
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|rc
op_assign
id|cpqhp_valid_replace
c_func
(paren
id|ctrl
comma
id|func
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
(brace
multiline_comment|/* It must be the same board */
id|rc
op_assign
id|cpqhp_configure_board
c_func
(paren
id|ctrl
comma
id|func
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_logical_or
id|src
)paren
(brace
multiline_comment|/* If configuration fails, turn it off&n;&t;&t;&t;&t; * Get slot won&squot;t work for devices behind&n;&t;&t;&t;&t; * bridges, but in this case it will always be&n;&t;&t;&t;&t; * called for the &quot;base&quot; bus/dev/func of an&n;&t;&t;&t;&t; * adapter. */
id|down
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
id|amber_LED_on
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|green_LED_off
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|slot_disable
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Wait for SOBS to be unset */
id|wait_for_ctrl_irq
(paren
id|ctrl
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
r_else
r_return
l_int|1
suffix:semicolon
)brace
id|func-&gt;status
op_assign
l_int|0
suffix:semicolon
id|func-&gt;switch_save
op_assign
l_int|0x10
suffix:semicolon
id|index
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|func
op_assign
id|cpqhp_slot_find
c_func
(paren
id|func-&gt;bus
comma
id|func-&gt;device
comma
id|index
)paren
)paren
op_ne
l_int|NULL
)paren
op_logical_and
op_logical_neg
id|rc
)paren
(brace
id|rc
op_or_assign
id|cpqhp_configure_board
c_func
(paren
id|ctrl
comma
id|func
)paren
suffix:semicolon
id|index
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
)paren
(brace
multiline_comment|/* If configuration fails, turn it off&n;&t;&t;&t;&t; * Get slot won&squot;t work for devices behind&n;&t;&t;&t;&t; * bridges, but in this case it will always be&n;&t;&t;&t;&t; * called for the &quot;base&quot; bus/dev/func of an&n;&t;&t;&t;&t; * adapter. */
id|down
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
id|amber_LED_on
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|green_LED_off
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|slot_disable
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Wait for SOBS to be unset */
id|wait_for_ctrl_irq
(paren
id|ctrl
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* Done configuring so turn LED on full time */
id|down
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
id|green_LED_on
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Wait for SOBS to be unset */
id|wait_for_ctrl_irq
(paren
id|ctrl
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Something is wrong&n;&n;&t;&t;&t; * Get slot won&squot;t work for devices behind bridges, but&n;&t;&t;&t; * in this case it will always be called for the &quot;base&quot;&n;&t;&t;&t; * bus/dev/func of an adapter. */
id|down
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
id|amber_LED_on
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|green_LED_off
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|slot_disable
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Wait for SOBS to be unset */
id|wait_for_ctrl_irq
(paren
id|ctrl
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
)brace
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; * board_added - Called after a board has been added to the system.&n; *&n; * Turns power on for the board&n; * Configures board&n; *&n; */
DECL|function|board_added
r_static
id|u32
id|board_added
c_func
(paren
r_struct
id|pci_func
op_star
id|func
comma
r_struct
id|controller
op_star
id|ctrl
)paren
(brace
id|u8
id|hp_slot
suffix:semicolon
id|u8
id|temp_byte
suffix:semicolon
id|u8
id|adapter_speed
suffix:semicolon
r_int
id|index
suffix:semicolon
id|u32
id|temp_register
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|u32
id|rc
op_assign
l_int|0
suffix:semicolon
r_struct
id|pci_func
op_star
id|new_slot
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|slot
op_star
id|p_slot
suffix:semicolon
r_struct
id|resource_lists
id|res_lists
suffix:semicolon
id|hp_slot
op_assign
id|func-&gt;device
op_minus
id|ctrl-&gt;slot_device_offset
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: func-&gt;device, slot_offset, hp_slot = %d, %d ,%d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|func-&gt;device
comma
id|ctrl-&gt;slot_device_offset
comma
id|hp_slot
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
multiline_comment|/* turn on board without attaching to the bus */
id|enable_slot_power
c_func
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Wait for SOBS to be unset */
id|wait_for_ctrl_irq
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Change bits in slot power register to force another shift out&n;&t; * NOTE: this is to work around the timer bug */
id|temp_byte
op_assign
id|readb
c_func
(paren
id|ctrl-&gt;hpc_reg
op_plus
id|SLOT_POWER
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0x00
comma
id|ctrl-&gt;hpc_reg
op_plus
id|SLOT_POWER
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|temp_byte
comma
id|ctrl-&gt;hpc_reg
op_plus
id|SLOT_POWER
)paren
suffix:semicolon
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Wait for SOBS to be unset */
id|wait_for_ctrl_irq
(paren
id|ctrl
)paren
suffix:semicolon
id|adapter_speed
op_assign
id|get_adapter_speed
c_func
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctrl-&gt;speed
op_ne
id|adapter_speed
)paren
r_if
c_cond
(paren
id|set_controller_speed
c_func
(paren
id|ctrl
comma
id|adapter_speed
comma
id|hp_slot
)paren
)paren
id|rc
op_assign
id|WRONG_BUS_FREQUENCY
suffix:semicolon
multiline_comment|/* turn off board without attaching to the bus */
id|disable_slot_power
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Wait for SOBS to be unset */
id|wait_for_ctrl_irq
c_func
(paren
id|ctrl
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|p_slot
op_assign
id|cpqhp_find_slot
c_func
(paren
id|ctrl
comma
id|hp_slot
op_plus
id|ctrl-&gt;slot_device_offset
)paren
suffix:semicolon
multiline_comment|/* turn on board and blink green LED */
id|dbg
c_func
(paren
l_string|&quot;%s: before down&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: after down&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: before slot_enable&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|slot_enable
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: before green_LED_blink&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|green_LED_blink
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: before amber_LED_blink&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|amber_LED_off
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: before set_SOGO&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Wait for SOBS to be unset */
id|dbg
c_func
(paren
l_string|&quot;%s: before wait_for_ctrl_irq&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|wait_for_ctrl_irq
(paren
id|ctrl
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: after wait_for_ctrl_irq&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: before up&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: after up&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* Wait for ~1 second because of hot plug spec */
id|dbg
c_func
(paren
l_string|&quot;%s: before long_delay&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|long_delay
c_func
(paren
l_int|1
op_star
id|HZ
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: after long_delay&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: func status = %x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|func-&gt;status
)paren
suffix:semicolon
multiline_comment|/* Check for a power fault */
r_if
c_cond
(paren
id|func-&gt;status
op_eq
l_int|0xFF
)paren
(brace
multiline_comment|/* power fault occurred, but it was benign */
id|temp_register
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: temp register set to %x by power fault&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|temp_register
)paren
suffix:semicolon
id|rc
op_assign
id|POWER_FAILURE
suffix:semicolon
id|func-&gt;status
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get vendor/device ID u32 */
id|ctrl-&gt;pci_bus-&gt;number
op_assign
id|func-&gt;bus
suffix:semicolon
id|rc
op_assign
id|pci_bus_read_config_dword
(paren
id|ctrl-&gt;pci_bus
comma
id|PCI_DEVFN
c_func
(paren
id|func-&gt;device
comma
id|func-&gt;function
)paren
comma
id|PCI_VENDOR_ID
comma
op_amp
id|temp_register
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: pci_read_config_dword returns %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|rc
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: temp_register is %x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|temp_register
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Something&squot;s wrong here */
id|temp_register
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: temp register set to %x by error&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|temp_register
)paren
suffix:semicolon
)brace
multiline_comment|/* Preset return code.  It will be changed later if things go okay. */
id|rc
op_assign
id|NO_ADAPTER_PRESENT
suffix:semicolon
)brace
multiline_comment|/* All F&squot;s is an empty slot or an invalid board */
r_if
c_cond
(paren
id|temp_register
op_ne
l_int|0xFFFFFFFF
)paren
(brace
multiline_comment|/* Check for a board in the slot */
id|res_lists.io_head
op_assign
id|ctrl-&gt;io_head
suffix:semicolon
id|res_lists.mem_head
op_assign
id|ctrl-&gt;mem_head
suffix:semicolon
id|res_lists.p_mem_head
op_assign
id|ctrl-&gt;p_mem_head
suffix:semicolon
id|res_lists.bus_head
op_assign
id|ctrl-&gt;bus_head
suffix:semicolon
id|res_lists.irqs
op_assign
l_int|NULL
suffix:semicolon
id|rc
op_assign
id|configure_new_device
c_func
(paren
id|ctrl
comma
id|func
comma
l_int|0
comma
op_amp
id|res_lists
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: back from configure_new_device&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|ctrl-&gt;io_head
op_assign
id|res_lists.io_head
suffix:semicolon
id|ctrl-&gt;mem_head
op_assign
id|res_lists.mem_head
suffix:semicolon
id|ctrl-&gt;p_mem_head
op_assign
id|res_lists.p_mem_head
suffix:semicolon
id|ctrl-&gt;bus_head
op_assign
id|res_lists.bus_head
suffix:semicolon
id|cpqhp_resource_sort_and_combine
c_func
(paren
op_amp
(paren
id|ctrl-&gt;mem_head
)paren
)paren
suffix:semicolon
id|cpqhp_resource_sort_and_combine
c_func
(paren
op_amp
(paren
id|ctrl-&gt;p_mem_head
)paren
)paren
suffix:semicolon
id|cpqhp_resource_sort_and_combine
c_func
(paren
op_amp
(paren
id|ctrl-&gt;io_head
)paren
)paren
suffix:semicolon
id|cpqhp_resource_sort_and_combine
c_func
(paren
op_amp
(paren
id|ctrl-&gt;bus_head
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|down
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
id|amber_LED_on
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|green_LED_off
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|slot_disable
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Wait for SOBS to be unset */
id|wait_for_ctrl_irq
(paren
id|ctrl
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_else
(brace
id|cpqhp_save_slot_config
c_func
(paren
id|ctrl
comma
id|func
)paren
suffix:semicolon
)brace
id|func-&gt;status
op_assign
l_int|0
suffix:semicolon
id|func-&gt;switch_save
op_assign
l_int|0x10
suffix:semicolon
id|func-&gt;is_a_board
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* next, we will instantiate the linux pci_dev structures (with&n;&t;&t; * appropriate driver notification, if already present) */
id|dbg
c_func
(paren
l_string|&quot;%s: configure linux pci_dev structure&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|index
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|new_slot
op_assign
id|cpqhp_slot_find
c_func
(paren
id|ctrl-&gt;bus
comma
id|func-&gt;device
comma
id|index
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_slot
op_logical_and
op_logical_neg
id|new_slot-&gt;pci_dev
)paren
(brace
id|cpqhp_configure_device
c_func
(paren
id|ctrl
comma
id|new_slot
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|new_slot
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
id|green_LED_on
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Wait for SOBS to be unset */
id|wait_for_ctrl_irq
(paren
id|ctrl
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
)brace
r_else
(brace
id|down
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
id|amber_LED_on
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|green_LED_off
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|slot_disable
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Wait for SOBS to be unset */
id|wait_for_ctrl_irq
(paren
id|ctrl
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * remove_board - Turns off slot and LED&squot;s&n; *&n; */
DECL|function|remove_board
r_static
id|u32
id|remove_board
c_func
(paren
r_struct
id|pci_func
op_star
id|func
comma
id|u32
id|replace_flag
comma
r_struct
id|controller
op_star
id|ctrl
)paren
(brace
r_int
id|index
suffix:semicolon
id|u8
id|skip
op_assign
l_int|0
suffix:semicolon
id|u8
id|device
suffix:semicolon
id|u8
id|hp_slot
suffix:semicolon
id|u8
id|temp_byte
suffix:semicolon
id|u32
id|rc
suffix:semicolon
r_struct
id|resource_lists
id|res_lists
suffix:semicolon
r_struct
id|pci_func
op_star
id|temp_func
suffix:semicolon
r_if
c_cond
(paren
id|func
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cpqhp_unconfigure_device
c_func
(paren
id|func
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|device
op_assign
id|func-&gt;device
suffix:semicolon
id|hp_slot
op_assign
id|func-&gt;device
op_minus
id|ctrl-&gt;slot_device_offset
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;In %s, hp_slot = %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|hp_slot
)paren
suffix:semicolon
multiline_comment|/* When we get here, it is safe to change base address registers.&n;&t; * We will attempt to save the base address register lengths */
r_if
c_cond
(paren
id|replace_flag
op_logical_or
op_logical_neg
id|ctrl-&gt;add_support
)paren
id|rc
op_assign
id|cpqhp_save_base_addr_length
c_func
(paren
id|ctrl
comma
id|func
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|func-&gt;bus_head
op_logical_and
op_logical_neg
id|func-&gt;mem_head
op_logical_and
op_logical_neg
id|func-&gt;p_mem_head
op_logical_and
op_logical_neg
id|func-&gt;io_head
)paren
(brace
multiline_comment|/* Here we check to see if we&squot;ve saved any of the board&squot;s&n;&t;&t; * resources already.  If so, we&squot;ll skip the attempt to&n;&t;&t; * determine what&squot;s being used. */
id|index
op_assign
l_int|0
suffix:semicolon
id|temp_func
op_assign
id|cpqhp_slot_find
c_func
(paren
id|func-&gt;bus
comma
id|func-&gt;device
comma
id|index
op_increment
)paren
suffix:semicolon
r_while
c_loop
(paren
id|temp_func
)paren
(brace
r_if
c_cond
(paren
id|temp_func-&gt;bus_head
op_logical_or
id|temp_func-&gt;mem_head
op_logical_or
id|temp_func-&gt;p_mem_head
op_logical_or
id|temp_func-&gt;io_head
)paren
(brace
id|skip
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|temp_func
op_assign
id|cpqhp_slot_find
c_func
(paren
id|temp_func-&gt;bus
comma
id|temp_func-&gt;device
comma
id|index
op_increment
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|skip
)paren
id|rc
op_assign
id|cpqhp_save_used_resources
c_func
(paren
id|ctrl
comma
id|func
)paren
suffix:semicolon
)brace
multiline_comment|/* Change status to shutdown */
r_if
c_cond
(paren
id|func-&gt;is_a_board
)paren
id|func-&gt;status
op_assign
l_int|0x01
suffix:semicolon
id|func-&gt;configured
op_assign
l_int|0
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
id|green_LED_off
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|slot_disable
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* turn off SERR for slot */
id|temp_byte
op_assign
id|readb
c_func
(paren
id|ctrl-&gt;hpc_reg
op_plus
id|SLOT_SERR
)paren
suffix:semicolon
id|temp_byte
op_and_assign
op_complement
(paren
l_int|0x01
op_lshift
id|hp_slot
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|temp_byte
comma
id|ctrl-&gt;hpc_reg
op_plus
id|SLOT_SERR
)paren
suffix:semicolon
multiline_comment|/* Wait for SOBS to be unset */
id|wait_for_ctrl_irq
(paren
id|ctrl
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|replace_flag
op_logical_and
id|ctrl-&gt;add_support
)paren
(brace
r_while
c_loop
(paren
id|func
)paren
(brace
id|res_lists.io_head
op_assign
id|ctrl-&gt;io_head
suffix:semicolon
id|res_lists.mem_head
op_assign
id|ctrl-&gt;mem_head
suffix:semicolon
id|res_lists.p_mem_head
op_assign
id|ctrl-&gt;p_mem_head
suffix:semicolon
id|res_lists.bus_head
op_assign
id|ctrl-&gt;bus_head
suffix:semicolon
id|cpqhp_return_board_resources
c_func
(paren
id|func
comma
op_amp
id|res_lists
)paren
suffix:semicolon
id|ctrl-&gt;io_head
op_assign
id|res_lists.io_head
suffix:semicolon
id|ctrl-&gt;mem_head
op_assign
id|res_lists.mem_head
suffix:semicolon
id|ctrl-&gt;p_mem_head
op_assign
id|res_lists.p_mem_head
suffix:semicolon
id|ctrl-&gt;bus_head
op_assign
id|res_lists.bus_head
suffix:semicolon
id|cpqhp_resource_sort_and_combine
c_func
(paren
op_amp
(paren
id|ctrl-&gt;mem_head
)paren
)paren
suffix:semicolon
id|cpqhp_resource_sort_and_combine
c_func
(paren
op_amp
(paren
id|ctrl-&gt;p_mem_head
)paren
)paren
suffix:semicolon
id|cpqhp_resource_sort_and_combine
c_func
(paren
op_amp
(paren
id|ctrl-&gt;io_head
)paren
)paren
suffix:semicolon
id|cpqhp_resource_sort_and_combine
c_func
(paren
op_amp
(paren
id|ctrl-&gt;bus_head
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_bridge
c_func
(paren
id|func
)paren
)paren
(brace
id|bridge_slot_remove
c_func
(paren
id|func
)paren
suffix:semicolon
)brace
r_else
id|slot_remove
c_func
(paren
id|func
)paren
suffix:semicolon
id|func
op_assign
id|cpqhp_slot_find
c_func
(paren
id|ctrl-&gt;bus
comma
id|device
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Setup slot structure with entry for empty slot */
id|func
op_assign
id|cpqhp_slot_create
c_func
(paren
id|ctrl-&gt;bus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|func
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
id|func-&gt;bus
op_assign
id|ctrl-&gt;bus
suffix:semicolon
id|func-&gt;device
op_assign
id|device
suffix:semicolon
id|func-&gt;function
op_assign
l_int|0
suffix:semicolon
id|func-&gt;configured
op_assign
l_int|0
suffix:semicolon
id|func-&gt;switch_save
op_assign
l_int|0x10
suffix:semicolon
id|func-&gt;is_a_board
op_assign
l_int|0
suffix:semicolon
id|func-&gt;p_task_event
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pushbutton_helper_thread
r_static
r_void
id|pushbutton_helper_thread
c_func
(paren
r_int
r_int
id|data
)paren
(brace
id|pushbutton_pending
op_assign
id|data
suffix:semicolon
id|up
c_func
(paren
op_amp
id|event_semaphore
)paren
suffix:semicolon
)brace
multiline_comment|/* this is the main worker thread */
DECL|function|event_thread
r_static
r_int
id|event_thread
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|controller
op_star
id|ctrl
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|daemonize
c_func
(paren
l_string|&quot;phpd_event&quot;
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;!!!!event_thread sleeping&bslash;n&quot;
)paren
suffix:semicolon
id|down_interruptible
(paren
op_amp
id|event_semaphore
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;event_thread woken finished = %d&bslash;n&quot;
comma
id|event_finished
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event_finished
)paren
r_break
suffix:semicolon
multiline_comment|/* Do stuff here */
r_if
c_cond
(paren
id|pushbutton_pending
)paren
id|cpqhp_pushbutton_thread
c_func
(paren
id|pushbutton_pending
)paren
suffix:semicolon
r_else
r_for
c_loop
(paren
id|ctrl
op_assign
id|cpqhp_ctrl_list
suffix:semicolon
id|ctrl
suffix:semicolon
id|ctrl
op_assign
id|ctrl-&gt;next
)paren
id|interrupt_event_handler
c_func
(paren
id|ctrl
)paren
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;event_thread signals exit&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|event_exit
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cpqhp_event_start_thread
r_int
id|cpqhp_event_start_thread
c_func
(paren
r_void
)paren
(brace
r_int
id|pid
suffix:semicolon
multiline_comment|/* initialize our semaphores */
id|init_MUTEX
c_func
(paren
op_amp
id|delay_sem
)paren
suffix:semicolon
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
id|event_semaphore
)paren
suffix:semicolon
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
id|event_exit
)paren
suffix:semicolon
id|event_finished
op_assign
l_int|0
suffix:semicolon
id|pid
op_assign
id|kernel_thread
c_func
(paren
id|event_thread
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pid
OL
l_int|0
)paren
(brace
id|err
(paren
l_string|&quot;Can&squot;t start up our event thread&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;Our event thread pid = %d&bslash;n&quot;
comma
id|pid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cpqhp_event_stop_thread
r_void
id|cpqhp_event_stop_thread
c_func
(paren
r_void
)paren
(brace
id|event_finished
op_assign
l_int|1
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;event_thread finish command given&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|event_semaphore
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;wait for event_thread to exit&bslash;n&quot;
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|event_exit
)paren
suffix:semicolon
)brace
DECL|function|update_slot_info
r_static
r_int
id|update_slot_info
c_func
(paren
r_struct
id|controller
op_star
id|ctrl
comma
r_struct
id|slot
op_star
id|slot
)paren
(brace
r_struct
id|hotplug_slot_info
op_star
id|info
suffix:semicolon
r_int
id|result
suffix:semicolon
id|info
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|hotplug_slot_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|info-&gt;power_status
op_assign
id|get_slot_enabled
c_func
(paren
id|ctrl
comma
id|slot
)paren
suffix:semicolon
id|info-&gt;attention_status
op_assign
id|cpq_get_attention_status
c_func
(paren
id|ctrl
comma
id|slot
)paren
suffix:semicolon
id|info-&gt;latch_status
op_assign
id|cpq_get_latch_status
c_func
(paren
id|ctrl
comma
id|slot
)paren
suffix:semicolon
id|info-&gt;adapter_status
op_assign
id|get_presence_status
c_func
(paren
id|ctrl
comma
id|slot
)paren
suffix:semicolon
id|result
op_assign
id|pci_hp_change_slot_info
c_func
(paren
id|slot-&gt;hotplug_slot
comma
id|info
)paren
suffix:semicolon
id|kfree
(paren
id|info
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|interrupt_event_handler
r_static
r_void
id|interrupt_event_handler
c_func
(paren
r_struct
id|controller
op_star
id|ctrl
)paren
(brace
r_int
id|loop
op_assign
l_int|0
suffix:semicolon
r_int
id|change
op_assign
l_int|1
suffix:semicolon
r_struct
id|pci_func
op_star
id|func
suffix:semicolon
id|u8
id|hp_slot
suffix:semicolon
r_struct
id|slot
op_star
id|p_slot
suffix:semicolon
r_while
c_loop
(paren
id|change
)paren
(brace
id|change
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
l_int|10
suffix:semicolon
id|loop
op_increment
)paren
(brace
multiline_comment|/* dbg(&quot;loop %d&bslash;n&quot;, loop); */
r_if
c_cond
(paren
id|ctrl-&gt;event_queue
(braket
id|loop
)braket
dot
id|event_type
op_ne
l_int|0
)paren
(brace
id|hp_slot
op_assign
id|ctrl-&gt;event_queue
(braket
id|loop
)braket
dot
id|hp_slot
suffix:semicolon
id|func
op_assign
id|cpqhp_slot_find
c_func
(paren
id|ctrl-&gt;bus
comma
(paren
id|hp_slot
op_plus
id|ctrl-&gt;slot_device_offset
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|func
)paren
r_return
suffix:semicolon
id|p_slot
op_assign
id|cpqhp_find_slot
c_func
(paren
id|ctrl
comma
id|hp_slot
op_plus
id|ctrl-&gt;slot_device_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p_slot
)paren
r_return
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;hp_slot %d, func %p, p_slot %p&bslash;n&quot;
comma
id|hp_slot
comma
id|func
comma
id|p_slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctrl-&gt;event_queue
(braket
id|loop
)braket
dot
id|event_type
op_eq
id|INT_BUTTON_PRESS
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;button pressed&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ctrl-&gt;event_queue
(braket
id|loop
)braket
dot
id|event_type
op_eq
id|INT_BUTTON_CANCEL
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;button cancel&bslash;n&quot;
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|p_slot-&gt;task_event
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p_slot-&gt;state
op_eq
id|BLINKINGOFF_STATE
)paren
(brace
multiline_comment|/* slot is on */
id|dbg
c_func
(paren
l_string|&quot;turn on green LED&bslash;n&quot;
)paren
suffix:semicolon
id|green_LED_on
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p_slot-&gt;state
op_eq
id|BLINKINGON_STATE
)paren
(brace
multiline_comment|/* slot is off */
id|dbg
c_func
(paren
l_string|&quot;turn off green LED&bslash;n&quot;
)paren
suffix:semicolon
id|green_LED_off
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
)brace
id|info
c_func
(paren
id|msg_button_cancel
comma
id|p_slot-&gt;number
)paren
suffix:semicolon
id|p_slot-&gt;state
op_assign
id|STATIC_STATE
suffix:semicolon
id|amber_LED_off
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Wait for SOBS to be unset */
id|wait_for_ctrl_irq
(paren
id|ctrl
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
)brace
multiline_comment|/*** button Released (No action on press...) */
r_else
r_if
c_cond
(paren
id|ctrl-&gt;event_queue
(braket
id|loop
)braket
dot
id|event_type
op_eq
id|INT_BUTTON_RELEASE
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;button release&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_slot_enabled
(paren
id|ctrl
comma
id|hp_slot
)paren
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;slot is on&bslash;n&quot;
)paren
suffix:semicolon
id|p_slot-&gt;state
op_assign
id|BLINKINGOFF_STATE
suffix:semicolon
id|info
c_func
(paren
id|msg_button_off
comma
id|p_slot-&gt;number
)paren
suffix:semicolon
)brace
r_else
(brace
id|dbg
c_func
(paren
l_string|&quot;slot is off&bslash;n&quot;
)paren
suffix:semicolon
id|p_slot-&gt;state
op_assign
id|BLINKINGON_STATE
suffix:semicolon
id|info
c_func
(paren
id|msg_button_on
comma
id|p_slot-&gt;number
)paren
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;blink green LED and turn off amber&bslash;n&quot;
)paren
suffix:semicolon
id|amber_LED_off
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|green_LED_blink
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Wait for SOBS to be unset */
id|wait_for_ctrl_irq
(paren
id|ctrl
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ctrl-&gt;crit_sect
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|p_slot-&gt;task_event
)paren
suffix:semicolon
id|p_slot-&gt;hp_slot
op_assign
id|hp_slot
suffix:semicolon
id|p_slot-&gt;ctrl
op_assign
id|ctrl
suffix:semicolon
multiline_comment|/*&t;&t;&t;&t;&t;p_slot-&gt;physical_slot = physical_slot; */
id|p_slot-&gt;task_event.expires
op_assign
id|jiffies
op_plus
l_int|5
op_star
id|HZ
suffix:semicolon
multiline_comment|/* 5 second delay */
id|p_slot-&gt;task_event.function
op_assign
id|pushbutton_helper_thread
suffix:semicolon
id|p_slot-&gt;task_event.data
op_assign
(paren
id|u32
)paren
id|p_slot
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;add_timer p_slot = %p&bslash;n&quot;
comma
id|p_slot
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|p_slot-&gt;task_event
)paren
suffix:semicolon
)brace
multiline_comment|/***********POWER FAULT */
r_else
r_if
c_cond
(paren
id|ctrl-&gt;event_queue
(braket
id|loop
)braket
dot
id|event_type
op_eq
id|INT_POWER_FAULT
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;power fault&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* refresh notification */
r_if
c_cond
(paren
id|p_slot
)paren
id|update_slot_info
c_func
(paren
id|ctrl
comma
id|p_slot
)paren
suffix:semicolon
)brace
id|ctrl-&gt;event_queue
(braket
id|loop
)braket
dot
id|event_type
op_assign
l_int|0
suffix:semicolon
id|change
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* End of FOR loop */
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * cpqhp_pushbutton_thread&n; *&n; * Scheduled procedure to handle blocking stuff for the pushbuttons&n; * Handles all pending events and exits.&n; *&n; */
DECL|function|cpqhp_pushbutton_thread
r_void
id|cpqhp_pushbutton_thread
c_func
(paren
r_int
r_int
id|slot
)paren
(brace
id|u8
id|hp_slot
suffix:semicolon
id|u8
id|device
suffix:semicolon
r_struct
id|pci_func
op_star
id|func
suffix:semicolon
r_struct
id|slot
op_star
id|p_slot
op_assign
(paren
r_struct
id|slot
op_star
)paren
id|slot
suffix:semicolon
r_struct
id|controller
op_star
id|ctrl
op_assign
(paren
r_struct
id|controller
op_star
)paren
id|p_slot-&gt;ctrl
suffix:semicolon
id|pushbutton_pending
op_assign
l_int|0
suffix:semicolon
id|hp_slot
op_assign
id|p_slot-&gt;hp_slot
suffix:semicolon
id|device
op_assign
id|p_slot-&gt;device
suffix:semicolon
r_if
c_cond
(paren
id|is_slot_enabled
c_func
(paren
id|ctrl
comma
id|hp_slot
)paren
)paren
(brace
id|p_slot-&gt;state
op_assign
id|POWEROFF_STATE
suffix:semicolon
multiline_comment|/* power Down board */
id|func
op_assign
id|cpqhp_slot_find
c_func
(paren
id|p_slot-&gt;bus
comma
id|p_slot-&gt;device
comma
l_int|0
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;In power_down_board, func = %p, ctrl = %p&bslash;n&quot;
comma
id|func
comma
id|ctrl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|func
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;Error! func NULL in %s&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|func
op_ne
l_int|NULL
op_logical_and
id|ctrl
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|cpqhp_process_SS
c_func
(paren
id|ctrl
comma
id|func
)paren
op_ne
l_int|0
)paren
(brace
id|amber_LED_on
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|green_LED_on
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Wait for SOBS to be unset */
id|wait_for_ctrl_irq
(paren
id|ctrl
)paren
suffix:semicolon
)brace
)brace
id|p_slot-&gt;state
op_assign
id|STATIC_STATE
suffix:semicolon
)brace
r_else
(brace
id|p_slot-&gt;state
op_assign
id|POWERON_STATE
suffix:semicolon
multiline_comment|/* slot is off */
id|func
op_assign
id|cpqhp_slot_find
c_func
(paren
id|p_slot-&gt;bus
comma
id|p_slot-&gt;device
comma
l_int|0
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;In add_board, func = %p, ctrl = %p&bslash;n&quot;
comma
id|func
comma
id|ctrl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|func
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;Error! func NULL in %s&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|func
op_ne
l_int|NULL
op_logical_and
id|ctrl
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|cpqhp_process_SI
c_func
(paren
id|ctrl
comma
id|func
)paren
op_ne
l_int|0
)paren
(brace
id|amber_LED_on
c_func
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|green_LED_off
c_func
(paren
id|ctrl
comma
id|hp_slot
)paren
suffix:semicolon
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Wait for SOBS to be unset */
id|wait_for_ctrl_irq
(paren
id|ctrl
)paren
suffix:semicolon
)brace
)brace
id|p_slot-&gt;state
op_assign
id|STATIC_STATE
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|cpqhp_process_SI
r_int
id|cpqhp_process_SI
c_func
(paren
r_struct
id|controller
op_star
id|ctrl
comma
r_struct
id|pci_func
op_star
id|func
)paren
(brace
id|u8
id|device
comma
id|hp_slot
suffix:semicolon
id|u16
id|temp_word
suffix:semicolon
id|u32
id|tempdword
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_struct
id|slot
op_star
id|p_slot
suffix:semicolon
r_int
id|physical_slot
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctrl
)paren
r_return
l_int|1
suffix:semicolon
id|tempdword
op_assign
l_int|0
suffix:semicolon
id|device
op_assign
id|func-&gt;device
suffix:semicolon
id|hp_slot
op_assign
id|device
op_minus
id|ctrl-&gt;slot_device_offset
suffix:semicolon
id|p_slot
op_assign
id|cpqhp_find_slot
c_func
(paren
id|ctrl
comma
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p_slot
)paren
id|physical_slot
op_assign
id|p_slot-&gt;number
suffix:semicolon
multiline_comment|/* Check to see if the interlock is closed */
id|tempdword
op_assign
id|readl
c_func
(paren
id|ctrl-&gt;hpc_reg
op_plus
id|INT_INPUT_CLEAR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tempdword
op_amp
(paren
l_int|0x01
op_lshift
id|hp_slot
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|func-&gt;is_a_board
)paren
(brace
id|rc
op_assign
id|board_replaced
c_func
(paren
id|func
comma
id|ctrl
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* add board */
id|slot_remove
c_func
(paren
id|func
)paren
suffix:semicolon
id|func
op_assign
id|cpqhp_slot_create
c_func
(paren
id|ctrl-&gt;bus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|func
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
id|func-&gt;bus
op_assign
id|ctrl-&gt;bus
suffix:semicolon
id|func-&gt;device
op_assign
id|device
suffix:semicolon
id|func-&gt;function
op_assign
l_int|0
suffix:semicolon
id|func-&gt;configured
op_assign
l_int|0
suffix:semicolon
id|func-&gt;is_a_board
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* We have to save the presence info for these slots */
id|temp_word
op_assign
id|ctrl-&gt;ctrl_int_comp
op_rshift
l_int|16
suffix:semicolon
id|func-&gt;presence_save
op_assign
(paren
id|temp_word
op_rshift
id|hp_slot
)paren
op_amp
l_int|0x01
suffix:semicolon
id|func-&gt;presence_save
op_or_assign
(paren
id|temp_word
op_rshift
(paren
id|hp_slot
op_plus
l_int|7
)paren
)paren
op_amp
l_int|0x02
suffix:semicolon
r_if
c_cond
(paren
id|ctrl-&gt;ctrl_int_comp
op_amp
(paren
l_int|0x1L
op_lshift
id|hp_slot
)paren
)paren
(brace
id|func-&gt;switch_save
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|func-&gt;switch_save
op_assign
l_int|0x10
suffix:semicolon
)brace
id|rc
op_assign
id|board_added
c_func
(paren
id|func
comma
id|ctrl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
r_if
c_cond
(paren
id|is_bridge
c_func
(paren
id|func
)paren
)paren
(brace
id|bridge_slot_remove
c_func
(paren
id|func
)paren
suffix:semicolon
)brace
r_else
id|slot_remove
c_func
(paren
id|func
)paren
suffix:semicolon
multiline_comment|/* Setup slot structure with entry for empty slot */
id|func
op_assign
id|cpqhp_slot_create
c_func
(paren
id|ctrl-&gt;bus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|func
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
id|func-&gt;bus
op_assign
id|ctrl-&gt;bus
suffix:semicolon
id|func-&gt;device
op_assign
id|device
suffix:semicolon
id|func-&gt;function
op_assign
l_int|0
suffix:semicolon
id|func-&gt;configured
op_assign
l_int|0
suffix:semicolon
id|func-&gt;is_a_board
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We have to save the presence info for these slots */
id|temp_word
op_assign
id|ctrl-&gt;ctrl_int_comp
op_rshift
l_int|16
suffix:semicolon
id|func-&gt;presence_save
op_assign
(paren
id|temp_word
op_rshift
id|hp_slot
)paren
op_amp
l_int|0x01
suffix:semicolon
id|func-&gt;presence_save
op_or_assign
(paren
id|temp_word
op_rshift
(paren
id|hp_slot
op_plus
l_int|7
)paren
)paren
op_amp
l_int|0x02
suffix:semicolon
r_if
c_cond
(paren
id|ctrl-&gt;ctrl_int_comp
op_amp
(paren
l_int|0x1L
op_lshift
id|hp_slot
)paren
)paren
(brace
id|func-&gt;switch_save
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|func-&gt;switch_save
op_assign
l_int|0x10
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|rc
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s: rc = %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|rc
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p_slot
)paren
id|update_slot_info
c_func
(paren
id|ctrl
comma
id|p_slot
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|cpqhp_process_SS
r_int
id|cpqhp_process_SS
c_func
(paren
r_struct
id|controller
op_star
id|ctrl
comma
r_struct
id|pci_func
op_star
id|func
)paren
(brace
id|u8
id|device
comma
id|class_code
comma
id|header_type
comma
id|BCR
suffix:semicolon
id|u8
id|index
op_assign
l_int|0
suffix:semicolon
id|u8
id|replace_flag
suffix:semicolon
id|u32
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|devfn
suffix:semicolon
r_struct
id|slot
op_star
id|p_slot
suffix:semicolon
r_struct
id|pci_bus
op_star
id|pci_bus
op_assign
id|ctrl-&gt;pci_bus
suffix:semicolon
r_int
id|physical_slot
op_assign
l_int|0
suffix:semicolon
id|device
op_assign
id|func-&gt;device
suffix:semicolon
id|func
op_assign
id|cpqhp_slot_find
c_func
(paren
id|ctrl-&gt;bus
comma
id|device
comma
id|index
op_increment
)paren
suffix:semicolon
id|p_slot
op_assign
id|cpqhp_find_slot
c_func
(paren
id|ctrl
comma
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p_slot
)paren
(brace
id|physical_slot
op_assign
id|p_slot-&gt;number
suffix:semicolon
)brace
multiline_comment|/* Make sure there are no video controllers here */
r_while
c_loop
(paren
id|func
op_logical_and
op_logical_neg
id|rc
)paren
(brace
id|pci_bus-&gt;number
op_assign
id|func-&gt;bus
suffix:semicolon
id|devfn
op_assign
id|PCI_DEVFN
c_func
(paren
id|func-&gt;device
comma
id|func-&gt;function
)paren
suffix:semicolon
multiline_comment|/* Check the Class Code */
id|rc
op_assign
id|pci_bus_read_config_byte
(paren
id|pci_bus
comma
id|devfn
comma
l_int|0x0B
comma
op_amp
id|class_code
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|class_code
op_eq
id|PCI_BASE_CLASS_DISPLAY
)paren
(brace
multiline_comment|/* Display/Video adapter (not supported) */
id|rc
op_assign
id|REMOVE_NOT_SUPPORTED
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* See if it&squot;s a bridge */
id|rc
op_assign
id|pci_bus_read_config_byte
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_HEADER_TYPE
comma
op_amp
id|header_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* If it&squot;s a bridge, check the VGA Enable bit */
r_if
c_cond
(paren
(paren
id|header_type
op_amp
l_int|0x7F
)paren
op_eq
id|PCI_HEADER_TYPE_BRIDGE
)paren
(brace
id|rc
op_assign
id|pci_bus_read_config_byte
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_BRIDGE_CONTROL
comma
op_amp
id|BCR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* If the VGA Enable bit is set, remove isn&squot;t&n;&t;&t;&t;&t; * supported */
r_if
c_cond
(paren
id|BCR
op_amp
id|PCI_BRIDGE_CTL_VGA
)paren
(brace
id|rc
op_assign
id|REMOVE_NOT_SUPPORTED
suffix:semicolon
)brace
)brace
)brace
id|func
op_assign
id|cpqhp_slot_find
c_func
(paren
id|ctrl-&gt;bus
comma
id|device
comma
id|index
op_increment
)paren
suffix:semicolon
)brace
id|func
op_assign
id|cpqhp_slot_find
c_func
(paren
id|ctrl-&gt;bus
comma
id|device
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|func
op_ne
l_int|NULL
)paren
op_logical_and
op_logical_neg
id|rc
)paren
(brace
multiline_comment|/* FIXME: Replace flag should be passed into process_SS */
id|replace_flag
op_assign
op_logical_neg
(paren
id|ctrl-&gt;add_support
)paren
suffix:semicolon
id|rc
op_assign
id|remove_board
c_func
(paren
id|func
comma
id|replace_flag
comma
id|ctrl
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
(brace
id|rc
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p_slot
)paren
id|update_slot_info
c_func
(paren
id|ctrl
comma
id|p_slot
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; * switch_leds: switch the leds, go from one site to the other.&n; * @ctrl: controller to use&n; * @num_of_slots: number of slots to use&n; * @direction: 1 to start from the left side, 0 to start right.&n; */
DECL|function|switch_leds
r_void
id|switch_leds
c_func
(paren
r_struct
id|controller
op_star
id|ctrl
comma
r_const
r_int
id|num_of_slots
comma
id|u32
op_star
id|work_LED
comma
r_const
r_int
id|direction
)paren
(brace
r_int
id|loop
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|num_of_slots
suffix:semicolon
id|loop
op_increment
)paren
(brace
r_if
c_cond
(paren
id|direction
)paren
op_star
id|work_LED
op_assign
op_star
id|work_LED
op_rshift
l_int|1
suffix:semicolon
r_else
op_star
id|work_LED
op_assign
op_star
id|work_LED
op_lshift
l_int|1
suffix:semicolon
id|writel
c_func
(paren
op_star
id|work_LED
comma
id|ctrl-&gt;hpc_reg
op_plus
id|LED_CONTROL
)paren
suffix:semicolon
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Wait for SOGO interrupt */
id|wait_for_ctrl_irq
c_func
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Get ready for next iteration */
id|long_delay
c_func
(paren
(paren
l_int|2
op_star
id|HZ
)paren
op_div
l_int|10
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * hardware_test - runs hardware tests&n; *&n; * For hot plug ctrl folks to play with.&n; * test_num is the number written to the &quot;test&quot; file in sysfs&n; *&n; */
DECL|function|cpqhp_hardware_test
r_int
id|cpqhp_hardware_test
c_func
(paren
r_struct
id|controller
op_star
id|ctrl
comma
r_int
id|test_num
)paren
(brace
id|u32
id|save_LED
suffix:semicolon
id|u32
id|work_LED
suffix:semicolon
r_int
id|loop
suffix:semicolon
r_int
id|num_of_slots
suffix:semicolon
id|num_of_slots
op_assign
id|readb
c_func
(paren
id|ctrl-&gt;hpc_reg
op_plus
id|SLOT_MASK
)paren
op_amp
l_int|0x0f
suffix:semicolon
r_switch
c_cond
(paren
id|test_num
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* Do stuff here! */
multiline_comment|/* Do that funky LED thing */
multiline_comment|/* so we can restore them later */
id|save_LED
op_assign
id|readl
c_func
(paren
id|ctrl-&gt;hpc_reg
op_plus
id|LED_CONTROL
)paren
suffix:semicolon
id|work_LED
op_assign
l_int|0x01010101
suffix:semicolon
id|switch_leds
c_func
(paren
id|ctrl
comma
id|num_of_slots
comma
op_amp
id|work_LED
comma
l_int|0
)paren
suffix:semicolon
id|switch_leds
c_func
(paren
id|ctrl
comma
id|num_of_slots
comma
op_amp
id|work_LED
comma
l_int|1
)paren
suffix:semicolon
id|switch_leds
c_func
(paren
id|ctrl
comma
id|num_of_slots
comma
op_amp
id|work_LED
comma
l_int|0
)paren
suffix:semicolon
id|switch_leds
c_func
(paren
id|ctrl
comma
id|num_of_slots
comma
op_amp
id|work_LED
comma
l_int|1
)paren
suffix:semicolon
id|work_LED
op_assign
l_int|0x01010000
suffix:semicolon
id|writel
c_func
(paren
id|work_LED
comma
id|ctrl-&gt;hpc_reg
op_plus
id|LED_CONTROL
)paren
suffix:semicolon
id|switch_leds
c_func
(paren
id|ctrl
comma
id|num_of_slots
comma
op_amp
id|work_LED
comma
l_int|0
)paren
suffix:semicolon
id|switch_leds
c_func
(paren
id|ctrl
comma
id|num_of_slots
comma
op_amp
id|work_LED
comma
l_int|1
)paren
suffix:semicolon
id|work_LED
op_assign
l_int|0x00000101
suffix:semicolon
id|writel
c_func
(paren
id|work_LED
comma
id|ctrl-&gt;hpc_reg
op_plus
id|LED_CONTROL
)paren
suffix:semicolon
id|switch_leds
c_func
(paren
id|ctrl
comma
id|num_of_slots
comma
op_amp
id|work_LED
comma
l_int|0
)paren
suffix:semicolon
id|switch_leds
c_func
(paren
id|ctrl
comma
id|num_of_slots
comma
op_amp
id|work_LED
comma
l_int|1
)paren
suffix:semicolon
id|work_LED
op_assign
l_int|0x01010000
suffix:semicolon
id|writel
c_func
(paren
id|work_LED
comma
id|ctrl-&gt;hpc_reg
op_plus
id|LED_CONTROL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|num_of_slots
suffix:semicolon
id|loop
op_increment
)paren
(brace
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Wait for SOGO interrupt */
id|wait_for_ctrl_irq
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Get ready for next iteration */
id|long_delay
c_func
(paren
(paren
l_int|3
op_star
id|HZ
)paren
op_div
l_int|10
)paren
suffix:semicolon
id|work_LED
op_assign
id|work_LED
op_rshift
l_int|16
suffix:semicolon
id|writel
c_func
(paren
id|work_LED
comma
id|ctrl-&gt;hpc_reg
op_plus
id|LED_CONTROL
)paren
suffix:semicolon
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Wait for SOGO interrupt */
id|wait_for_ctrl_irq
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Get ready for next iteration */
id|long_delay
c_func
(paren
(paren
l_int|3
op_star
id|HZ
)paren
op_div
l_int|10
)paren
suffix:semicolon
id|work_LED
op_assign
id|work_LED
op_lshift
l_int|16
suffix:semicolon
id|writel
c_func
(paren
id|work_LED
comma
id|ctrl-&gt;hpc_reg
op_plus
id|LED_CONTROL
)paren
suffix:semicolon
id|work_LED
op_assign
id|work_LED
op_lshift
l_int|1
suffix:semicolon
id|writel
c_func
(paren
id|work_LED
comma
id|ctrl-&gt;hpc_reg
op_plus
id|LED_CONTROL
)paren
suffix:semicolon
)brace
multiline_comment|/* put it back the way it was */
id|writel
c_func
(paren
id|save_LED
comma
id|ctrl-&gt;hpc_reg
op_plus
id|LED_CONTROL
)paren
suffix:semicolon
id|set_SOGO
c_func
(paren
id|ctrl
)paren
suffix:semicolon
multiline_comment|/* Wait for SOBS to be unset */
id|wait_for_ctrl_irq
(paren
id|ctrl
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* Do other stuff here! */
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* and more... */
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * configure_new_device - Configures the PCI header information of one board.&n; *&n; * @ctrl: pointer to controller structure&n; * @func: pointer to function structure&n; * @behind_bridge: 1 if this is a recursive call, 0 if not&n; * @resources: pointer to set of resource lists&n; *&n; * Returns 0 if success&n; *&n; */
DECL|function|configure_new_device
r_static
id|u32
id|configure_new_device
c_func
(paren
r_struct
id|controller
op_star
id|ctrl
comma
r_struct
id|pci_func
op_star
id|func
comma
id|u8
id|behind_bridge
comma
r_struct
id|resource_lists
op_star
id|resources
)paren
(brace
id|u8
id|temp_byte
comma
id|function
comma
id|max_functions
comma
id|stop_it
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|u32
id|ID
suffix:semicolon
r_struct
id|pci_func
op_star
id|new_slot
suffix:semicolon
r_int
id|index
suffix:semicolon
id|new_slot
op_assign
id|func
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* Check for Multi-function device */
id|ctrl-&gt;pci_bus-&gt;number
op_assign
id|func-&gt;bus
suffix:semicolon
id|rc
op_assign
id|pci_bus_read_config_byte
(paren
id|ctrl-&gt;pci_bus
comma
id|PCI_DEVFN
c_func
(paren
id|func-&gt;device
comma
id|func-&gt;function
)paren
comma
l_int|0x0E
comma
op_amp
id|temp_byte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s: rc = %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|rc
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_if
c_cond
(paren
id|temp_byte
op_amp
l_int|0x80
)paren
multiline_comment|/* Multi-function device */
id|max_functions
op_assign
l_int|8
suffix:semicolon
r_else
id|max_functions
op_assign
l_int|1
suffix:semicolon
id|function
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|rc
op_assign
id|configure_new_function
c_func
(paren
id|ctrl
comma
id|new_slot
comma
id|behind_bridge
comma
id|resources
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;configure_new_function failed %d&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
id|index
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|new_slot
)paren
(brace
id|new_slot
op_assign
id|cpqhp_slot_find
c_func
(paren
id|new_slot-&gt;bus
comma
id|new_slot-&gt;device
comma
id|index
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_slot
)paren
id|cpqhp_return_board_resources
c_func
(paren
id|new_slot
comma
id|resources
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
id|function
op_increment
suffix:semicolon
id|stop_it
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The following loop skips to the next present function&n;&t;&t; * and creates a board structure */
r_while
c_loop
(paren
(paren
id|function
OL
id|max_functions
)paren
op_logical_and
(paren
op_logical_neg
id|stop_it
)paren
)paren
(brace
id|pci_bus_read_config_dword
(paren
id|ctrl-&gt;pci_bus
comma
id|PCI_DEVFN
c_func
(paren
id|func-&gt;device
comma
id|function
)paren
comma
l_int|0x00
comma
op_amp
id|ID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ID
op_eq
l_int|0xFFFFFFFF
)paren
(brace
multiline_comment|/* There&squot;s nothing there. */
id|function
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* There&squot;s something there */
multiline_comment|/* Setup slot structure. */
id|new_slot
op_assign
id|cpqhp_slot_create
c_func
(paren
id|func-&gt;bus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_slot
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
id|new_slot-&gt;bus
op_assign
id|func-&gt;bus
suffix:semicolon
id|new_slot-&gt;device
op_assign
id|func-&gt;device
suffix:semicolon
id|new_slot-&gt;function
op_assign
id|function
suffix:semicolon
id|new_slot-&gt;is_a_board
op_assign
l_int|1
suffix:semicolon
id|new_slot-&gt;status
op_assign
l_int|0
suffix:semicolon
id|stop_it
op_increment
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|function
OL
id|max_functions
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;returning from configure_new_device&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;  Configuration logic that involves the hotplug data structures and &n;  their bookkeeping&n; */
multiline_comment|/**&n; * configure_new_function - Configures the PCI header information of one device&n; *&n; * @ctrl: pointer to controller structure&n; * @func: pointer to function structure&n; * @behind_bridge: 1 if this is a recursive call, 0 if not&n; * @resources: pointer to set of resource lists&n; *&n; * Calls itself recursively for bridged devices.&n; * Returns 0 if success&n; *&n; */
DECL|function|configure_new_function
r_static
r_int
id|configure_new_function
c_func
(paren
r_struct
id|controller
op_star
id|ctrl
comma
r_struct
id|pci_func
op_star
id|func
comma
id|u8
id|behind_bridge
comma
r_struct
id|resource_lists
op_star
id|resources
)paren
(brace
r_int
id|cloop
suffix:semicolon
id|u8
id|IRQ
op_assign
l_int|0
suffix:semicolon
id|u8
id|temp_byte
suffix:semicolon
id|u8
id|device
suffix:semicolon
id|u8
id|class_code
suffix:semicolon
id|u16
id|command
suffix:semicolon
id|u16
id|temp_word
suffix:semicolon
id|u32
id|temp_dword
suffix:semicolon
id|u32
id|rc
suffix:semicolon
id|u32
id|temp_register
suffix:semicolon
id|u32
id|base
suffix:semicolon
id|u32
id|ID
suffix:semicolon
r_int
r_int
id|devfn
suffix:semicolon
r_struct
id|pci_resource
op_star
id|mem_node
suffix:semicolon
r_struct
id|pci_resource
op_star
id|p_mem_node
suffix:semicolon
r_struct
id|pci_resource
op_star
id|io_node
suffix:semicolon
r_struct
id|pci_resource
op_star
id|bus_node
suffix:semicolon
r_struct
id|pci_resource
op_star
id|hold_mem_node
suffix:semicolon
r_struct
id|pci_resource
op_star
id|hold_p_mem_node
suffix:semicolon
r_struct
id|pci_resource
op_star
id|hold_IO_node
suffix:semicolon
r_struct
id|pci_resource
op_star
id|hold_bus_node
suffix:semicolon
r_struct
id|irq_mapping
id|irqs
suffix:semicolon
r_struct
id|pci_func
op_star
id|new_slot
suffix:semicolon
r_struct
id|pci_bus
op_star
id|pci_bus
suffix:semicolon
r_struct
id|resource_lists
id|temp_resources
suffix:semicolon
id|pci_bus
op_assign
id|ctrl-&gt;pci_bus
suffix:semicolon
id|pci_bus-&gt;number
op_assign
id|func-&gt;bus
suffix:semicolon
id|devfn
op_assign
id|PCI_DEVFN
c_func
(paren
id|func-&gt;device
comma
id|func-&gt;function
)paren
suffix:semicolon
multiline_comment|/* Check for Bridge */
id|rc
op_assign
id|pci_bus_read_config_byte
c_func
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_HEADER_TYPE
comma
op_amp
id|temp_byte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
r_if
c_cond
(paren
(paren
id|temp_byte
op_amp
l_int|0x7F
)paren
op_eq
id|PCI_HEADER_TYPE_BRIDGE
)paren
(brace
multiline_comment|/* PCI-PCI Bridge */
multiline_comment|/* set Primary bus */
id|dbg
c_func
(paren
l_string|&quot;set Primary bus = %d&bslash;n&quot;
comma
id|func-&gt;bus
)paren
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_byte
c_func
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_PRIMARY_BUS
comma
id|func-&gt;bus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* find range of busses to use */
id|dbg
c_func
(paren
l_string|&quot;find ranges of buses to use&bslash;n&quot;
)paren
suffix:semicolon
id|bus_node
op_assign
id|get_max_resource
c_func
(paren
op_amp
id|resources-&gt;bus_head
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* If we don&squot;t have any busses to allocate, we can&squot;t continue */
r_if
c_cond
(paren
op_logical_neg
id|bus_node
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* set Secondary bus */
id|temp_byte
op_assign
id|bus_node-&gt;base
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;set Secondary bus = %d&bslash;n&quot;
comma
id|bus_node-&gt;base
)paren
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_byte
c_func
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_SECONDARY_BUS
comma
id|temp_byte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* set subordinate bus */
id|temp_byte
op_assign
id|bus_node-&gt;base
op_plus
id|bus_node-&gt;length
op_minus
l_int|1
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;set subordinate bus = %d&bslash;n&quot;
comma
id|bus_node-&gt;base
op_plus
id|bus_node-&gt;length
op_minus
l_int|1
)paren
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_byte
c_func
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_SUBORDINATE_BUS
comma
id|temp_byte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* set subordinate Latency Timer and base Latency Timer */
id|temp_byte
op_assign
l_int|0x40
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_byte
c_func
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_SEC_LATENCY_TIMER
comma
id|temp_byte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_byte
c_func
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_LATENCY_TIMER
comma
id|temp_byte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* set Cache Line size */
id|temp_byte
op_assign
l_int|0x08
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_byte
c_func
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_CACHE_LINE_SIZE
comma
id|temp_byte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* Setup the IO, memory, and prefetchable windows */
id|io_node
op_assign
id|get_max_resource
c_func
(paren
op_amp
(paren
id|resources-&gt;io_head
)paren
comma
l_int|0x1000
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|io_node
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|mem_node
op_assign
id|get_max_resource
c_func
(paren
op_amp
(paren
id|resources-&gt;mem_head
)paren
comma
l_int|0x100000
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mem_node
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|p_mem_node
op_assign
id|get_max_resource
c_func
(paren
op_amp
(paren
id|resources-&gt;p_mem_head
)paren
comma
l_int|0x100000
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p_mem_node
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Setup the IO, memory, and prefetchable windows&bslash;n&quot;
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;io_node&bslash;n&quot;
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;(base, len, next) (%x, %x, %p)&bslash;n&quot;
comma
id|io_node-&gt;base
comma
id|io_node-&gt;length
comma
id|io_node-&gt;next
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;mem_node&bslash;n&quot;
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;(base, len, next) (%x, %x, %p)&bslash;n&quot;
comma
id|mem_node-&gt;base
comma
id|mem_node-&gt;length
comma
id|mem_node-&gt;next
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;p_mem_node&bslash;n&quot;
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;(base, len, next) (%x, %x, %p)&bslash;n&quot;
comma
id|p_mem_node-&gt;base
comma
id|p_mem_node-&gt;length
comma
id|p_mem_node-&gt;next
)paren
suffix:semicolon
multiline_comment|/* set up the IRQ info */
r_if
c_cond
(paren
op_logical_neg
id|resources-&gt;irqs
)paren
(brace
id|irqs.barber_pole
op_assign
l_int|0
suffix:semicolon
id|irqs.interrupt
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|irqs.interrupt
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|irqs.interrupt
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|irqs.interrupt
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|irqs.valid_INT
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|irqs.barber_pole
op_assign
id|resources-&gt;irqs-&gt;barber_pole
suffix:semicolon
id|irqs.interrupt
(braket
l_int|0
)braket
op_assign
id|resources-&gt;irqs-&gt;interrupt
(braket
l_int|0
)braket
suffix:semicolon
id|irqs.interrupt
(braket
l_int|1
)braket
op_assign
id|resources-&gt;irqs-&gt;interrupt
(braket
l_int|1
)braket
suffix:semicolon
id|irqs.interrupt
(braket
l_int|2
)braket
op_assign
id|resources-&gt;irqs-&gt;interrupt
(braket
l_int|2
)braket
suffix:semicolon
id|irqs.interrupt
(braket
l_int|3
)braket
op_assign
id|resources-&gt;irqs-&gt;interrupt
(braket
l_int|3
)braket
suffix:semicolon
id|irqs.valid_INT
op_assign
id|resources-&gt;irqs-&gt;valid_INT
suffix:semicolon
)brace
multiline_comment|/* set up resource lists that are now aligned on top and bottom&n;&t;&t; * for anything behind the bridge. */
id|temp_resources.bus_head
op_assign
id|bus_node
suffix:semicolon
id|temp_resources.io_head
op_assign
id|io_node
suffix:semicolon
id|temp_resources.mem_head
op_assign
id|mem_node
suffix:semicolon
id|temp_resources.p_mem_head
op_assign
id|p_mem_node
suffix:semicolon
id|temp_resources.irqs
op_assign
op_amp
id|irqs
suffix:semicolon
multiline_comment|/* Make copies of the nodes we are going to pass down so that&n;&t;&t; * if there is a problem,we can just use these to free resources */
id|hold_bus_node
op_assign
(paren
r_struct
id|pci_resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|hold_IO_node
op_assign
(paren
r_struct
id|pci_resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|hold_mem_node
op_assign
(paren
r_struct
id|pci_resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|hold_p_mem_node
op_assign
(paren
r_struct
id|pci_resource
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_resource
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hold_bus_node
op_logical_or
op_logical_neg
id|hold_IO_node
op_logical_or
op_logical_neg
id|hold_mem_node
op_logical_or
op_logical_neg
id|hold_p_mem_node
)paren
(brace
r_if
c_cond
(paren
id|hold_bus_node
)paren
id|kfree
c_func
(paren
id|hold_bus_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hold_IO_node
)paren
id|kfree
c_func
(paren
id|hold_IO_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hold_mem_node
)paren
id|kfree
c_func
(paren
id|hold_mem_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hold_p_mem_node
)paren
id|kfree
c_func
(paren
id|hold_p_mem_node
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|hold_bus_node
comma
id|bus_node
comma
r_sizeof
(paren
r_struct
id|pci_resource
)paren
)paren
suffix:semicolon
id|bus_node-&gt;base
op_add_assign
l_int|1
suffix:semicolon
id|bus_node-&gt;length
op_sub_assign
l_int|1
suffix:semicolon
id|bus_node-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* If we have IO resources copy them and fill in the bridge&squot;s&n;&t;&t; * IO range registers */
r_if
c_cond
(paren
id|io_node
)paren
(brace
id|memcpy
c_func
(paren
id|hold_IO_node
comma
id|io_node
comma
r_sizeof
(paren
r_struct
id|pci_resource
)paren
)paren
suffix:semicolon
id|io_node-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* set IO base and Limit registers */
id|temp_byte
op_assign
id|io_node-&gt;base
op_rshift
l_int|8
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_byte
c_func
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_IO_BASE
comma
id|temp_byte
)paren
suffix:semicolon
id|temp_byte
op_assign
(paren
id|io_node-&gt;base
op_plus
id|io_node-&gt;length
op_minus
l_int|1
)paren
op_rshift
l_int|8
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_byte
c_func
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_IO_LIMIT
comma
id|temp_byte
)paren
suffix:semicolon
)brace
r_else
(brace
id|kfree
c_func
(paren
id|hold_IO_node
)paren
suffix:semicolon
id|hold_IO_node
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* If we have memory resources copy them and fill in the&n;&t;&t; * bridge&squot;s memory range registers.  Otherwise, fill in the&n;&t;&t; * range registers with values that disable them. */
r_if
c_cond
(paren
id|mem_node
)paren
(brace
id|memcpy
c_func
(paren
id|hold_mem_node
comma
id|mem_node
comma
r_sizeof
(paren
r_struct
id|pci_resource
)paren
)paren
suffix:semicolon
id|mem_node-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* set Mem base and Limit registers */
id|temp_word
op_assign
id|mem_node-&gt;base
op_rshift
l_int|16
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_word
c_func
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_MEMORY_BASE
comma
id|temp_word
)paren
suffix:semicolon
id|temp_word
op_assign
(paren
id|mem_node-&gt;base
op_plus
id|mem_node-&gt;length
op_minus
l_int|1
)paren
op_rshift
l_int|16
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_word
c_func
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_MEMORY_LIMIT
comma
id|temp_word
)paren
suffix:semicolon
)brace
r_else
(brace
id|temp_word
op_assign
l_int|0xFFFF
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_word
c_func
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_MEMORY_BASE
comma
id|temp_word
)paren
suffix:semicolon
id|temp_word
op_assign
l_int|0x0000
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_word
c_func
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_MEMORY_LIMIT
comma
id|temp_word
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hold_mem_node
)paren
suffix:semicolon
id|hold_mem_node
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* If we have prefetchable memory resources copy them and &n;&t;&t; * fill in the bridge&squot;s memory range registers.  Otherwise,&n;&t;&t; * fill in the range registers with values that disable them. */
r_if
c_cond
(paren
id|p_mem_node
)paren
(brace
id|memcpy
c_func
(paren
id|hold_p_mem_node
comma
id|p_mem_node
comma
r_sizeof
(paren
r_struct
id|pci_resource
)paren
)paren
suffix:semicolon
id|p_mem_node-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* set Pre Mem base and Limit registers */
id|temp_word
op_assign
id|p_mem_node-&gt;base
op_rshift
l_int|16
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_word
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_PREF_MEMORY_BASE
comma
id|temp_word
)paren
suffix:semicolon
id|temp_word
op_assign
(paren
id|p_mem_node-&gt;base
op_plus
id|p_mem_node-&gt;length
op_minus
l_int|1
)paren
op_rshift
l_int|16
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_word
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_PREF_MEMORY_LIMIT
comma
id|temp_word
)paren
suffix:semicolon
)brace
r_else
(brace
id|temp_word
op_assign
l_int|0xFFFF
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_word
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_PREF_MEMORY_BASE
comma
id|temp_word
)paren
suffix:semicolon
id|temp_word
op_assign
l_int|0x0000
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_word
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_PREF_MEMORY_LIMIT
comma
id|temp_word
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hold_p_mem_node
)paren
suffix:semicolon
id|hold_p_mem_node
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Adjust this to compensate for extra adjustment in first loop */
id|irqs.barber_pole
op_decrement
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Here we actually find the devices and configure them */
r_for
c_loop
(paren
id|device
op_assign
l_int|0
suffix:semicolon
(paren
id|device
op_le
l_int|0x1F
)paren
op_logical_and
op_logical_neg
id|rc
suffix:semicolon
id|device
op_increment
)paren
(brace
id|irqs.barber_pole
op_assign
(paren
id|irqs.barber_pole
op_plus
l_int|1
)paren
op_amp
l_int|0x03
suffix:semicolon
id|ID
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|pci_bus-&gt;number
op_assign
id|hold_bus_node-&gt;base
suffix:semicolon
id|pci_bus_read_config_dword
(paren
id|pci_bus
comma
id|PCI_DEVFN
c_func
(paren
id|device
comma
l_int|0
)paren
comma
l_int|0x00
comma
op_amp
id|ID
)paren
suffix:semicolon
id|pci_bus-&gt;number
op_assign
id|func-&gt;bus
suffix:semicolon
r_if
c_cond
(paren
id|ID
op_ne
l_int|0xFFFFFFFF
)paren
(brace
multiline_comment|/*  device present */
multiline_comment|/* Setup slot structure. */
id|new_slot
op_assign
id|cpqhp_slot_create
c_func
(paren
id|hold_bus_node-&gt;base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_slot
op_eq
l_int|NULL
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|new_slot-&gt;bus
op_assign
id|hold_bus_node-&gt;base
suffix:semicolon
id|new_slot-&gt;device
op_assign
id|device
suffix:semicolon
id|new_slot-&gt;function
op_assign
l_int|0
suffix:semicolon
id|new_slot-&gt;is_a_board
op_assign
l_int|1
suffix:semicolon
id|new_slot-&gt;status
op_assign
l_int|0
suffix:semicolon
id|rc
op_assign
id|configure_new_device
c_func
(paren
id|ctrl
comma
id|new_slot
comma
l_int|1
comma
op_amp
id|temp_resources
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;configure_new_device rc=0x%x&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/* End of IF (device in slot?) */
)brace
multiline_comment|/* End of FOR loop */
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|free_and_out
suffix:semicolon
multiline_comment|/* save the interrupt routing information */
r_if
c_cond
(paren
id|resources-&gt;irqs
)paren
(brace
id|resources-&gt;irqs-&gt;interrupt
(braket
l_int|0
)braket
op_assign
id|irqs.interrupt
(braket
l_int|0
)braket
suffix:semicolon
id|resources-&gt;irqs-&gt;interrupt
(braket
l_int|1
)braket
op_assign
id|irqs.interrupt
(braket
l_int|1
)braket
suffix:semicolon
id|resources-&gt;irqs-&gt;interrupt
(braket
l_int|2
)braket
op_assign
id|irqs.interrupt
(braket
l_int|2
)braket
suffix:semicolon
id|resources-&gt;irqs-&gt;interrupt
(braket
l_int|3
)braket
op_assign
id|irqs.interrupt
(braket
l_int|3
)braket
suffix:semicolon
id|resources-&gt;irqs-&gt;valid_INT
op_assign
id|irqs.valid_INT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|behind_bridge
)paren
(brace
multiline_comment|/* We need to hook up the interrupts here */
r_for
c_loop
(paren
id|cloop
op_assign
l_int|0
suffix:semicolon
id|cloop
OL
l_int|4
suffix:semicolon
id|cloop
op_increment
)paren
(brace
r_if
c_cond
(paren
id|irqs.valid_INT
op_amp
(paren
l_int|0x01
op_lshift
id|cloop
)paren
)paren
(brace
id|rc
op_assign
id|cpqhp_set_irq
c_func
(paren
id|func-&gt;bus
comma
id|func-&gt;device
comma
l_int|0x0A
op_plus
id|cloop
comma
id|irqs.interrupt
(braket
id|cloop
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|free_and_out
suffix:semicolon
)brace
)brace
multiline_comment|/* end of for loop */
)brace
multiline_comment|/* Return unused bus resources&n;&t;&t; * First use the temporary node to store information for&n;&t;&t; * the board */
r_if
c_cond
(paren
id|hold_bus_node
op_logical_and
id|bus_node
op_logical_and
id|temp_resources.bus_head
)paren
(brace
id|hold_bus_node-&gt;length
op_assign
id|bus_node-&gt;base
op_minus
id|hold_bus_node-&gt;base
suffix:semicolon
id|hold_bus_node-&gt;next
op_assign
id|func-&gt;bus_head
suffix:semicolon
id|func-&gt;bus_head
op_assign
id|hold_bus_node
suffix:semicolon
id|temp_byte
op_assign
id|temp_resources.bus_head-&gt;base
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* set subordinate bus */
id|rc
op_assign
id|pci_bus_write_config_byte
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_SUBORDINATE_BUS
comma
id|temp_byte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|temp_resources.bus_head-&gt;length
op_eq
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|temp_resources.bus_head
)paren
suffix:semicolon
id|temp_resources.bus_head
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|return_resource
c_func
(paren
op_amp
(paren
id|resources-&gt;bus_head
)paren
comma
id|temp_resources.bus_head
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* If we have IO space available and there is some left,&n;&t;&t; * return the unused portion */
r_if
c_cond
(paren
id|hold_IO_node
op_logical_and
id|temp_resources.io_head
)paren
(brace
id|io_node
op_assign
id|do_pre_bridge_resource_split
c_func
(paren
op_amp
(paren
id|temp_resources.io_head
)paren
comma
op_amp
id|hold_IO_node
comma
l_int|0x1000
)paren
suffix:semicolon
multiline_comment|/* Check if we were able to split something off */
r_if
c_cond
(paren
id|io_node
)paren
(brace
id|hold_IO_node-&gt;base
op_assign
id|io_node-&gt;base
op_plus
id|io_node-&gt;length
suffix:semicolon
id|temp_byte
op_assign
(paren
id|hold_IO_node-&gt;base
)paren
op_rshift
l_int|8
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_word
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_IO_BASE
comma
id|temp_byte
)paren
suffix:semicolon
id|return_resource
c_func
(paren
op_amp
(paren
id|resources-&gt;io_head
)paren
comma
id|io_node
)paren
suffix:semicolon
)brace
id|io_node
op_assign
id|do_bridge_resource_split
c_func
(paren
op_amp
(paren
id|temp_resources.io_head
)paren
comma
l_int|0x1000
)paren
suffix:semicolon
multiline_comment|/* Check if we were able to split something off */
r_if
c_cond
(paren
id|io_node
)paren
(brace
multiline_comment|/* First use the temporary node to store&n;&t;&t;&t;&t; * information for the board */
id|hold_IO_node-&gt;length
op_assign
id|io_node-&gt;base
op_minus
id|hold_IO_node-&gt;base
suffix:semicolon
multiline_comment|/* If we used any, add it to the board&squot;s list */
r_if
c_cond
(paren
id|hold_IO_node-&gt;length
)paren
(brace
id|hold_IO_node-&gt;next
op_assign
id|func-&gt;io_head
suffix:semicolon
id|func-&gt;io_head
op_assign
id|hold_IO_node
suffix:semicolon
id|temp_byte
op_assign
(paren
id|io_node-&gt;base
op_minus
l_int|1
)paren
op_rshift
l_int|8
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_byte
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_IO_LIMIT
comma
id|temp_byte
)paren
suffix:semicolon
id|return_resource
c_func
(paren
op_amp
(paren
id|resources-&gt;io_head
)paren
comma
id|io_node
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* it doesn&squot;t need any IO */
id|temp_word
op_assign
l_int|0x0000
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_word
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_IO_LIMIT
comma
id|temp_word
)paren
suffix:semicolon
id|return_resource
c_func
(paren
op_amp
(paren
id|resources-&gt;io_head
)paren
comma
id|io_node
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hold_IO_node
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* it used most of the range */
id|hold_IO_node-&gt;next
op_assign
id|func-&gt;io_head
suffix:semicolon
id|func-&gt;io_head
op_assign
id|hold_IO_node
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|hold_IO_node
)paren
(brace
multiline_comment|/* it used the whole range */
id|hold_IO_node-&gt;next
op_assign
id|func-&gt;io_head
suffix:semicolon
id|func-&gt;io_head
op_assign
id|hold_IO_node
suffix:semicolon
)brace
multiline_comment|/* If we have memory space available and there is some left,&n;&t;&t; * return the unused portion */
r_if
c_cond
(paren
id|hold_mem_node
op_logical_and
id|temp_resources.mem_head
)paren
(brace
id|mem_node
op_assign
id|do_pre_bridge_resource_split
c_func
(paren
op_amp
(paren
id|temp_resources
dot
id|mem_head
)paren
comma
op_amp
id|hold_mem_node
comma
l_int|0x100000
)paren
suffix:semicolon
multiline_comment|/* Check if we were able to split something off */
r_if
c_cond
(paren
id|mem_node
)paren
(brace
id|hold_mem_node-&gt;base
op_assign
id|mem_node-&gt;base
op_plus
id|mem_node-&gt;length
suffix:semicolon
id|temp_word
op_assign
(paren
id|hold_mem_node-&gt;base
)paren
op_rshift
l_int|16
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_word
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_MEMORY_BASE
comma
id|temp_word
)paren
suffix:semicolon
id|return_resource
c_func
(paren
op_amp
(paren
id|resources-&gt;mem_head
)paren
comma
id|mem_node
)paren
suffix:semicolon
)brace
id|mem_node
op_assign
id|do_bridge_resource_split
c_func
(paren
op_amp
(paren
id|temp_resources.mem_head
)paren
comma
l_int|0x100000
)paren
suffix:semicolon
multiline_comment|/* Check if we were able to split something off */
r_if
c_cond
(paren
id|mem_node
)paren
(brace
multiline_comment|/* First use the temporary node to store&n;&t;&t;&t;&t; * information for the board */
id|hold_mem_node-&gt;length
op_assign
id|mem_node-&gt;base
op_minus
id|hold_mem_node-&gt;base
suffix:semicolon
r_if
c_cond
(paren
id|hold_mem_node-&gt;length
)paren
(brace
id|hold_mem_node-&gt;next
op_assign
id|func-&gt;mem_head
suffix:semicolon
id|func-&gt;mem_head
op_assign
id|hold_mem_node
suffix:semicolon
multiline_comment|/* configure end address */
id|temp_word
op_assign
(paren
id|mem_node-&gt;base
op_minus
l_int|1
)paren
op_rshift
l_int|16
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_word
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_MEMORY_LIMIT
comma
id|temp_word
)paren
suffix:semicolon
multiline_comment|/* Return unused resources to the pool */
id|return_resource
c_func
(paren
op_amp
(paren
id|resources-&gt;mem_head
)paren
comma
id|mem_node
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* it doesn&squot;t need any Mem */
id|temp_word
op_assign
l_int|0x0000
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_word
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_MEMORY_LIMIT
comma
id|temp_word
)paren
suffix:semicolon
id|return_resource
c_func
(paren
op_amp
(paren
id|resources-&gt;mem_head
)paren
comma
id|mem_node
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hold_mem_node
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* it used most of the range */
id|hold_mem_node-&gt;next
op_assign
id|func-&gt;mem_head
suffix:semicolon
id|func-&gt;mem_head
op_assign
id|hold_mem_node
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|hold_mem_node
)paren
(brace
multiline_comment|/* it used the whole range */
id|hold_mem_node-&gt;next
op_assign
id|func-&gt;mem_head
suffix:semicolon
id|func-&gt;mem_head
op_assign
id|hold_mem_node
suffix:semicolon
)brace
multiline_comment|/* If we have prefetchable memory space available and there&n;&t;&t; * is some left at the end, return the unused portion */
r_if
c_cond
(paren
id|hold_p_mem_node
op_logical_and
id|temp_resources.p_mem_head
)paren
(brace
id|p_mem_node
op_assign
id|do_pre_bridge_resource_split
c_func
(paren
op_amp
(paren
id|temp_resources.p_mem_head
)paren
comma
op_amp
id|hold_p_mem_node
comma
l_int|0x100000
)paren
suffix:semicolon
multiline_comment|/* Check if we were able to split something off */
r_if
c_cond
(paren
id|p_mem_node
)paren
(brace
id|hold_p_mem_node-&gt;base
op_assign
id|p_mem_node-&gt;base
op_plus
id|p_mem_node-&gt;length
suffix:semicolon
id|temp_word
op_assign
(paren
id|hold_p_mem_node-&gt;base
)paren
op_rshift
l_int|16
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_word
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_PREF_MEMORY_BASE
comma
id|temp_word
)paren
suffix:semicolon
id|return_resource
c_func
(paren
op_amp
(paren
id|resources-&gt;p_mem_head
)paren
comma
id|p_mem_node
)paren
suffix:semicolon
)brace
id|p_mem_node
op_assign
id|do_bridge_resource_split
c_func
(paren
op_amp
(paren
id|temp_resources.p_mem_head
)paren
comma
l_int|0x100000
)paren
suffix:semicolon
multiline_comment|/* Check if we were able to split something off */
r_if
c_cond
(paren
id|p_mem_node
)paren
(brace
multiline_comment|/* First use the temporary node to store&n;&t;&t;&t;&t; * information for the board */
id|hold_p_mem_node-&gt;length
op_assign
id|p_mem_node-&gt;base
op_minus
id|hold_p_mem_node-&gt;base
suffix:semicolon
multiline_comment|/* If we used any, add it to the board&squot;s list */
r_if
c_cond
(paren
id|hold_p_mem_node-&gt;length
)paren
(brace
id|hold_p_mem_node-&gt;next
op_assign
id|func-&gt;p_mem_head
suffix:semicolon
id|func-&gt;p_mem_head
op_assign
id|hold_p_mem_node
suffix:semicolon
id|temp_word
op_assign
(paren
id|p_mem_node-&gt;base
op_minus
l_int|1
)paren
op_rshift
l_int|16
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_word
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_PREF_MEMORY_LIMIT
comma
id|temp_word
)paren
suffix:semicolon
id|return_resource
c_func
(paren
op_amp
(paren
id|resources-&gt;p_mem_head
)paren
comma
id|p_mem_node
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* it doesn&squot;t need any PMem */
id|temp_word
op_assign
l_int|0x0000
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_word
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_PREF_MEMORY_LIMIT
comma
id|temp_word
)paren
suffix:semicolon
id|return_resource
c_func
(paren
op_amp
(paren
id|resources-&gt;p_mem_head
)paren
comma
id|p_mem_node
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hold_p_mem_node
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* it used the most of the range */
id|hold_p_mem_node-&gt;next
op_assign
id|func-&gt;p_mem_head
suffix:semicolon
id|func-&gt;p_mem_head
op_assign
id|hold_p_mem_node
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|hold_p_mem_node
)paren
(brace
multiline_comment|/* it used the whole range */
id|hold_p_mem_node-&gt;next
op_assign
id|func-&gt;p_mem_head
suffix:semicolon
id|func-&gt;p_mem_head
op_assign
id|hold_p_mem_node
suffix:semicolon
)brace
multiline_comment|/* We should be configuring an IRQ and the bridge&squot;s base address&n;&t;&t; * registers if it needs them.  Although we have never seen such&n;&t;&t; * a device */
multiline_comment|/* enable card */
id|command
op_assign
l_int|0x0157
suffix:semicolon
multiline_comment|/* = PCI_COMMAND_IO |&n;&t;&t;&t;&t;&t; *   PCI_COMMAND_MEMORY |&n;&t;&t;&t;&t;&t; *   PCI_COMMAND_MASTER |&n;&t;&t;&t;&t;&t; *   PCI_COMMAND_INVALIDATE |&n;&t;&t;&t;&t;&t; *   PCI_COMMAND_PARITY |&n;&t;&t;&t;&t;&t; *   PCI_COMMAND_SERR */
id|rc
op_assign
id|pci_bus_write_config_word
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_COMMAND
comma
id|command
)paren
suffix:semicolon
multiline_comment|/* set Bridge Control Register */
id|command
op_assign
l_int|0x07
suffix:semicolon
multiline_comment|/* = PCI_BRIDGE_CTL_PARITY |&n;&t;&t;&t;&t;&t; *   PCI_BRIDGE_CTL_SERR |&n;&t;&t;&t;&t;&t; *   PCI_BRIDGE_CTL_NO_ISA */
id|rc
op_assign
id|pci_bus_write_config_word
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_BRIDGE_CONTROL
comma
id|command
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|temp_byte
op_amp
l_int|0x7F
)paren
op_eq
id|PCI_HEADER_TYPE_NORMAL
)paren
(brace
multiline_comment|/* Standard device */
id|rc
op_assign
id|pci_bus_read_config_byte
(paren
id|pci_bus
comma
id|devfn
comma
l_int|0x0B
comma
op_amp
id|class_code
)paren
suffix:semicolon
r_if
c_cond
(paren
id|class_code
op_eq
id|PCI_BASE_CLASS_DISPLAY
)paren
(brace
multiline_comment|/* Display (video) adapter (not supported) */
r_return
id|DEVICE_TYPE_NOT_SUPPORTED
suffix:semicolon
)brace
multiline_comment|/* Figure out IO and memory needs */
r_for
c_loop
(paren
id|cloop
op_assign
l_int|0x10
suffix:semicolon
id|cloop
op_le
l_int|0x24
suffix:semicolon
id|cloop
op_add_assign
l_int|4
)paren
(brace
id|temp_register
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;CND: bus=%d, devfn=%d, offset=%d&bslash;n&quot;
comma
id|pci_bus-&gt;number
comma
id|devfn
comma
id|cloop
)paren
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_dword
(paren
id|pci_bus
comma
id|devfn
comma
id|cloop
comma
id|temp_register
)paren
suffix:semicolon
id|rc
op_assign
id|pci_bus_read_config_dword
(paren
id|pci_bus
comma
id|devfn
comma
id|cloop
comma
op_amp
id|temp_register
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;CND: base = 0x%x&bslash;n&quot;
comma
id|temp_register
)paren
suffix:semicolon
r_if
c_cond
(paren
id|temp_register
)paren
(brace
multiline_comment|/* If this register is implemented */
r_if
c_cond
(paren
(paren
id|temp_register
op_amp
l_int|0x03L
)paren
op_eq
l_int|0x01
)paren
(brace
multiline_comment|/* Map IO */
multiline_comment|/* set base = amount of IO space */
id|base
op_assign
id|temp_register
op_amp
l_int|0xFFFFFFFC
suffix:semicolon
id|base
op_assign
op_complement
id|base
op_plus
l_int|1
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;CND:      length = 0x%x&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
id|io_node
op_assign
id|get_io_resource
c_func
(paren
op_amp
(paren
id|resources-&gt;io_head
)paren
comma
id|base
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Got io_node start = %8.8x, length = %8.8x next (%p)&bslash;n&quot;
comma
id|io_node-&gt;base
comma
id|io_node-&gt;length
comma
id|io_node-&gt;next
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;func (%p) io_head (%p)&bslash;n&quot;
comma
id|func
comma
id|func-&gt;io_head
)paren
suffix:semicolon
multiline_comment|/* allocate the resource to the board */
r_if
c_cond
(paren
id|io_node
)paren
(brace
id|base
op_assign
id|io_node-&gt;base
suffix:semicolon
id|io_node-&gt;next
op_assign
id|func-&gt;io_head
suffix:semicolon
id|func-&gt;io_head
op_assign
id|io_node
suffix:semicolon
)brace
r_else
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|temp_register
op_amp
l_int|0x0BL
)paren
op_eq
l_int|0x08
)paren
(brace
multiline_comment|/* Map prefetchable memory */
id|base
op_assign
id|temp_register
op_amp
l_int|0xFFFFFFF0
suffix:semicolon
id|base
op_assign
op_complement
id|base
op_plus
l_int|1
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;CND:      length = 0x%x&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
id|p_mem_node
op_assign
id|get_resource
c_func
(paren
op_amp
(paren
id|resources-&gt;p_mem_head
)paren
comma
id|base
)paren
suffix:semicolon
multiline_comment|/* allocate the resource to the board */
r_if
c_cond
(paren
id|p_mem_node
)paren
(brace
id|base
op_assign
id|p_mem_node-&gt;base
suffix:semicolon
id|p_mem_node-&gt;next
op_assign
id|func-&gt;p_mem_head
suffix:semicolon
id|func-&gt;p_mem_head
op_assign
id|p_mem_node
suffix:semicolon
)brace
r_else
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|temp_register
op_amp
l_int|0x0BL
)paren
op_eq
l_int|0x00
)paren
(brace
multiline_comment|/* Map memory */
id|base
op_assign
id|temp_register
op_amp
l_int|0xFFFFFFF0
suffix:semicolon
id|base
op_assign
op_complement
id|base
op_plus
l_int|1
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;CND:      length = 0x%x&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
id|mem_node
op_assign
id|get_resource
c_func
(paren
op_amp
(paren
id|resources-&gt;mem_head
)paren
comma
id|base
)paren
suffix:semicolon
multiline_comment|/* allocate the resource to the board */
r_if
c_cond
(paren
id|mem_node
)paren
(brace
id|base
op_assign
id|mem_node-&gt;base
suffix:semicolon
id|mem_node-&gt;next
op_assign
id|func-&gt;mem_head
suffix:semicolon
id|func-&gt;mem_head
op_assign
id|mem_node
suffix:semicolon
)brace
r_else
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|temp_register
op_amp
l_int|0x0BL
)paren
op_eq
l_int|0x04
)paren
(brace
multiline_comment|/* Map memory */
id|base
op_assign
id|temp_register
op_amp
l_int|0xFFFFFFF0
suffix:semicolon
id|base
op_assign
op_complement
id|base
op_plus
l_int|1
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;CND:      length = 0x%x&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
id|mem_node
op_assign
id|get_resource
c_func
(paren
op_amp
(paren
id|resources-&gt;mem_head
)paren
comma
id|base
)paren
suffix:semicolon
multiline_comment|/* allocate the resource to the board */
r_if
c_cond
(paren
id|mem_node
)paren
(brace
id|base
op_assign
id|mem_node-&gt;base
suffix:semicolon
id|mem_node-&gt;next
op_assign
id|func-&gt;mem_head
suffix:semicolon
id|func-&gt;mem_head
op_assign
id|mem_node
suffix:semicolon
)brace
r_else
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|temp_register
op_amp
l_int|0x0BL
)paren
op_eq
l_int|0x06
)paren
(brace
multiline_comment|/* Those bits are reserved, we can&squot;t handle this */
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Requesting space below 1M */
r_return
id|NOT_ENOUGH_RESOURCES
suffix:semicolon
)brace
id|rc
op_assign
id|pci_bus_write_config_dword
c_func
(paren
id|pci_bus
comma
id|devfn
comma
id|cloop
comma
id|base
)paren
suffix:semicolon
multiline_comment|/* Check for 64-bit base */
r_if
c_cond
(paren
(paren
id|temp_register
op_amp
l_int|0x07L
)paren
op_eq
l_int|0x04
)paren
(brace
id|cloop
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/* Upper 32 bits of address always zero&n;&t;&t;&t;&t;&t; * on today&squot;s systems */
multiline_comment|/* FIXME this is probably not true on&n;&t;&t;&t;&t;&t; * Alpha and ia64??? */
id|base
op_assign
l_int|0
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_dword
c_func
(paren
id|pci_bus
comma
id|devfn
comma
id|cloop
comma
id|base
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* End of base register loop */
r_if
c_cond
(paren
id|cpqhp_legacy_mode
)paren
(brace
multiline_comment|/* Figure out which interrupt pin this function uses */
id|rc
op_assign
id|pci_bus_read_config_byte
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_INTERRUPT_PIN
comma
op_amp
id|temp_byte
)paren
suffix:semicolon
multiline_comment|/* If this function needs an interrupt and we are behind&n;&t;&t;&t; * a bridge and the pin is tied to something that&squot;s&n;&t;&t;&t; * alread mapped, set this one the same */
r_if
c_cond
(paren
id|temp_byte
op_logical_and
id|resources-&gt;irqs
op_logical_and
(paren
id|resources-&gt;irqs-&gt;valid_INT
op_amp
(paren
l_int|0x01
op_lshift
(paren
(paren
id|temp_byte
op_plus
id|resources-&gt;irqs-&gt;barber_pole
op_minus
l_int|1
)paren
op_amp
l_int|0x03
)paren
)paren
)paren
)paren
(brace
multiline_comment|/* We have to share with something already set up */
id|IRQ
op_assign
id|resources-&gt;irqs-&gt;interrupt
(braket
(paren
id|temp_byte
op_plus
id|resources-&gt;irqs-&gt;barber_pole
op_minus
l_int|1
)paren
op_amp
l_int|0x03
)braket
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Program IRQ based on card type */
id|rc
op_assign
id|pci_bus_read_config_byte
(paren
id|pci_bus
comma
id|devfn
comma
l_int|0x0B
comma
op_amp
id|class_code
)paren
suffix:semicolon
r_if
c_cond
(paren
id|class_code
op_eq
id|PCI_BASE_CLASS_STORAGE
)paren
(brace
id|IRQ
op_assign
id|cpqhp_disk_irq
suffix:semicolon
)brace
r_else
(brace
id|IRQ
op_assign
id|cpqhp_nic_irq
suffix:semicolon
)brace
)brace
multiline_comment|/* IRQ Line */
id|rc
op_assign
id|pci_bus_write_config_byte
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_INTERRUPT_LINE
comma
id|IRQ
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|behind_bridge
)paren
(brace
id|rc
op_assign
id|cpqhp_set_irq
c_func
(paren
id|func-&gt;bus
comma
id|func-&gt;device
comma
id|temp_byte
op_plus
l_int|0x09
comma
id|IRQ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* TBD - this code may also belong in the other clause&n;&t;&t;&t; * of this If statement */
id|resources-&gt;irqs-&gt;interrupt
(braket
(paren
id|temp_byte
op_plus
id|resources-&gt;irqs-&gt;barber_pole
op_minus
l_int|1
)paren
op_amp
l_int|0x03
)braket
op_assign
id|IRQ
suffix:semicolon
id|resources-&gt;irqs-&gt;valid_INT
op_or_assign
l_int|0x01
op_lshift
(paren
id|temp_byte
op_plus
id|resources-&gt;irqs-&gt;barber_pole
op_minus
l_int|1
)paren
op_amp
l_int|0x03
suffix:semicolon
)brace
multiline_comment|/* Latency Timer */
id|temp_byte
op_assign
l_int|0x40
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_byte
c_func
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_LATENCY_TIMER
comma
id|temp_byte
)paren
suffix:semicolon
multiline_comment|/* Cache Line size */
id|temp_byte
op_assign
l_int|0x08
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_byte
c_func
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_CACHE_LINE_SIZE
comma
id|temp_byte
)paren
suffix:semicolon
multiline_comment|/* disable ROM base Address */
id|temp_dword
op_assign
l_int|0x00L
suffix:semicolon
id|rc
op_assign
id|pci_bus_write_config_word
c_func
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_ROM_ADDRESS
comma
id|temp_dword
)paren
suffix:semicolon
multiline_comment|/* enable card */
id|temp_word
op_assign
l_int|0x0157
suffix:semicolon
multiline_comment|/* = PCI_COMMAND_IO |&n;&t;&t;&t;&t;&t; *   PCI_COMMAND_MEMORY |&n;&t;&t;&t;&t;&t; *   PCI_COMMAND_MASTER |&n;&t;&t;&t;&t;&t; *   PCI_COMMAND_INVALIDATE |&n;&t;&t;&t;&t;&t; *   PCI_COMMAND_PARITY |&n;&t;&t;&t;&t;&t; *   PCI_COMMAND_SERR */
id|rc
op_assign
id|pci_bus_write_config_word
(paren
id|pci_bus
comma
id|devfn
comma
id|PCI_COMMAND
comma
id|temp_word
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* End of Not-A-Bridge else */
multiline_comment|/* It&squot;s some strange type of PCI adapter (Cardbus?) */
r_return
id|DEVICE_TYPE_NOT_SUPPORTED
suffix:semicolon
)brace
id|func-&gt;configured
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|free_and_out
suffix:colon
id|cpqhp_destroy_resource_list
(paren
op_amp
id|temp_resources
)paren
suffix:semicolon
id|return_resource
c_func
(paren
op_amp
(paren
id|resources
op_member_access_from_pointer
id|bus_head
)paren
comma
id|hold_bus_node
)paren
suffix:semicolon
id|return_resource
c_func
(paren
op_amp
(paren
id|resources
op_member_access_from_pointer
id|io_head
)paren
comma
id|hold_IO_node
)paren
suffix:semicolon
id|return_resource
c_func
(paren
op_amp
(paren
id|resources
op_member_access_from_pointer
id|mem_head
)paren
comma
id|hold_mem_node
)paren
suffix:semicolon
id|return_resource
c_func
(paren
op_amp
(paren
id|resources
op_member_access_from_pointer
id|p_mem_head
)paren
comma
id|hold_p_mem_node
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
eof
