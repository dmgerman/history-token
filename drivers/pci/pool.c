macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/module.h&gt;
multiline_comment|/*&n; * Pool allocator ... wraps the pci_alloc_consistent page allocator, so&n; * small blocks are easily used by drivers for bus mastering controllers.&n; * This should probably be sharing the guts of the slab allocator.&n; */
DECL|struct|pci_pool
r_struct
id|pci_pool
(brace
multiline_comment|/* the pool */
DECL|member|page_list
r_struct
id|list_head
id|page_list
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|blocks_per_page
r_int
id|blocks_per_page
suffix:semicolon
DECL|member|size
r_int
id|size
suffix:semicolon
DECL|member|dev
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
DECL|member|allocation
r_int
id|allocation
suffix:semicolon
DECL|member|name
r_char
id|name
(braket
l_int|32
)braket
suffix:semicolon
DECL|member|waitq
id|wait_queue_head_t
id|waitq
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|pci_page
r_struct
id|pci_page
(brace
multiline_comment|/* cacheable header for &squot;allocation&squot; bytes */
DECL|member|page_list
r_struct
id|list_head
id|page_list
suffix:semicolon
DECL|member|vaddr
r_void
op_star
id|vaddr
suffix:semicolon
DECL|member|dma
id|dma_addr_t
id|dma
suffix:semicolon
DECL|member|bitmap
r_int
r_int
id|bitmap
(braket
l_int|0
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|POOL_TIMEOUT_JIFFIES
mdefine_line|#define&t;POOL_TIMEOUT_JIFFIES&t;((100 /* msec */ * HZ) / 1000)
DECL|macro|POOL_POISON_BYTE
mdefine_line|#define&t;POOL_POISON_BYTE&t;0xa7
multiline_comment|/**&n; * pci_pool_create - Creates a pool of pci consistent memory blocks, for dma.&n; * @name: name of pool, for diagnostics&n; * @pdev: pci device that will be doing the DMA&n; * @size: size of the blocks in this pool.&n; * @align: alignment requirement for blocks; must be a power of two&n; * @allocation: returned blocks won&squot;t cross this boundary (or zero)&n; * @mem_flags: SLAB_* flags.&n; *&n; * Returns a pci allocation pool with the requested characteristics, or&n; * null if one can&squot;t be created.  Given one of these pools, pci_pool_alloc()&n; * may be used to allocate memory.  Such memory will all have &quot;consistent&quot;&n; * DMA mappings, accessible by the device and its driver without using&n; * cache flushing primitives.  The actual size of blocks allocated may be&n; * larger than requested because of alignment.&n; *&n; * If allocation is nonzero, objects returned from pci_pool_alloc() won&squot;t&n; * cross that size boundary.  This is useful for devices which have&n; * addressing restrictions on individual DMA transfers, such as not crossing&n; * boundaries of 4KBytes.&n; */
r_struct
id|pci_pool
op_star
DECL|function|pci_pool_create
id|pci_pool_create
(paren
r_const
r_char
op_star
id|name
comma
r_struct
id|pci_dev
op_star
id|pdev
comma
r_int
id|size
comma
r_int
id|align
comma
r_int
id|allocation
comma
r_int
id|mem_flags
)paren
(brace
r_struct
id|pci_pool
op_star
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|align
op_eq
l_int|0
)paren
id|align
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|size
OL
id|align
)paren
id|size
op_assign
id|align
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|size
op_mod
id|align
)paren
op_ne
l_int|0
)paren
(brace
id|size
op_add_assign
id|align
op_plus
l_int|1
suffix:semicolon
id|size
op_and_assign
op_complement
(paren
id|align
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|allocation
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|PAGE_SIZE
OL
id|size
)paren
id|allocation
op_assign
id|size
suffix:semicolon
r_else
id|allocation
op_assign
id|PAGE_SIZE
suffix:semicolon
singleline_comment|// FIXME: round up for less fragmentation
)brace
r_else
r_if
c_cond
(paren
id|allocation
OL
id|size
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|retval
op_assign
id|kmalloc
(paren
r_sizeof
op_star
id|retval
comma
id|mem_flags
)paren
)paren
)paren
r_return
id|retval
suffix:semicolon
id|strncpy
(paren
id|retval-&gt;name
comma
id|name
comma
r_sizeof
id|retval-&gt;name
)paren
suffix:semicolon
id|retval-&gt;name
(braket
r_sizeof
id|retval-&gt;name
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|retval-&gt;dev
op_assign
id|pdev
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|retval-&gt;page_list
)paren
suffix:semicolon
id|spin_lock_init
(paren
op_amp
id|retval-&gt;lock
)paren
suffix:semicolon
id|retval-&gt;size
op_assign
id|size
suffix:semicolon
id|retval-&gt;allocation
op_assign
id|allocation
suffix:semicolon
id|retval-&gt;blocks_per_page
op_assign
id|allocation
op_div
id|size
suffix:semicolon
id|init_waitqueue_head
(paren
op_amp
id|retval-&gt;waitq
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
r_struct
id|pci_page
op_star
DECL|function|pool_alloc_page
id|pool_alloc_page
(paren
r_struct
id|pci_pool
op_star
id|pool
comma
r_int
id|mem_flags
)paren
(brace
r_struct
id|pci_page
op_star
id|page
suffix:semicolon
r_int
id|mapsize
suffix:semicolon
id|mapsize
op_assign
id|pool-&gt;blocks_per_page
suffix:semicolon
id|mapsize
op_assign
(paren
id|mapsize
op_plus
id|BITS_PER_LONG
op_minus
l_int|1
)paren
op_div
id|BITS_PER_LONG
suffix:semicolon
id|mapsize
op_mul_assign
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|page
op_assign
(paren
r_struct
id|pci_page
op_star
)paren
id|kmalloc
(paren
id|mapsize
op_plus
r_sizeof
op_star
id|page
comma
id|mem_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_return
l_int|0
suffix:semicolon
id|page-&gt;vaddr
op_assign
id|pci_alloc_consistent
(paren
id|pool-&gt;dev
comma
id|pool-&gt;allocation
comma
op_amp
id|page-&gt;dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;vaddr
)paren
(brace
id|memset
(paren
id|page-&gt;bitmap
comma
l_int|0xff
comma
id|mapsize
)paren
suffix:semicolon
singleline_comment|// bit set == free
macro_line|#ifdef&t;CONFIG_DEBUG_SLAB
id|memset
(paren
id|page-&gt;vaddr
comma
id|POOL_POISON_BYTE
comma
id|pool-&gt;allocation
)paren
suffix:semicolon
macro_line|#endif
id|list_add
(paren
op_amp
id|page-&gt;page_list
comma
op_amp
id|pool-&gt;page_list
)paren
suffix:semicolon
)brace
r_else
(brace
id|kfree
(paren
id|page
)paren
suffix:semicolon
id|page
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|page
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|is_page_busy
id|is_page_busy
(paren
r_int
id|blocks
comma
r_int
r_int
op_star
id|bitmap
)paren
(brace
r_while
c_loop
(paren
id|blocks
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_star
id|bitmap
op_increment
op_ne
op_complement
l_int|0UL
)paren
r_return
l_int|1
suffix:semicolon
id|blocks
op_sub_assign
id|BITS_PER_LONG
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|pool_free_page
id|pool_free_page
(paren
r_struct
id|pci_pool
op_star
id|pool
comma
r_struct
id|pci_page
op_star
id|page
)paren
(brace
id|dma_addr_t
id|dma
op_assign
id|page-&gt;dma
suffix:semicolon
macro_line|#ifdef&t;CONFIG_DEBUG_SLAB
id|memset
(paren
id|page-&gt;vaddr
comma
id|POOL_POISON_BYTE
comma
id|pool-&gt;allocation
)paren
suffix:semicolon
macro_line|#endif
id|pci_free_consistent
(paren
id|pool-&gt;dev
comma
id|pool-&gt;allocation
comma
id|page-&gt;vaddr
comma
id|dma
)paren
suffix:semicolon
id|list_del
(paren
op_amp
id|page-&gt;page_list
)paren
suffix:semicolon
id|kfree
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * pci_pool_destroy - destroys a pool of pci memory blocks.&n; * @pool: pci pool that will be destroyed&n; *&n; * Caller guarantees that no more memory from the pool is in use,&n; * and that nothing will try to use the pool after this call.&n; */
r_void
DECL|function|pci_pool_destroy
id|pci_pool_destroy
(paren
r_struct
id|pci_pool
op_star
id|pool
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|pool-&gt;page_list
)paren
)paren
(brace
r_struct
id|pci_page
op_star
id|page
suffix:semicolon
id|page
op_assign
id|list_entry
(paren
id|pool-&gt;page_list.next
comma
r_struct
id|pci_page
comma
id|page_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_page_busy
(paren
id|pool-&gt;blocks_per_page
comma
id|page-&gt;bitmap
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;pci_pool_destroy %s/%s, %p busy&bslash;n&quot;
comma
id|pool-&gt;dev
ques
c_cond
id|pool-&gt;dev-&gt;slot_name
suffix:colon
l_int|NULL
comma
id|pool-&gt;name
comma
id|page-&gt;vaddr
)paren
suffix:semicolon
multiline_comment|/* leak the still-in-use consistent memory */
id|list_del
(paren
op_amp
id|page-&gt;page_list
)paren
suffix:semicolon
id|kfree
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
id|pool_free_page
(paren
id|pool
comma
id|page
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|kfree
(paren
id|pool
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * pci_pool_alloc - get a block of consistent memory&n; * @pool: pci pool that will produce the block&n; * @mem_flags: SLAB_KERNEL or SLAB_ATOMIC&n; * @handle: pointer to dma address of block&n; *&n; * This returns the kernel virtual address of a currently unused block,&n; * and reports its dma address through the handle.&n; * If such a memory block can&squot;t be allocated, null is returned.&n; */
r_void
op_star
DECL|function|pci_pool_alloc
id|pci_pool_alloc
(paren
r_struct
id|pci_pool
op_star
id|pool
comma
r_int
id|mem_flags
comma
id|dma_addr_t
op_star
id|handle
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
r_struct
id|pci_page
op_star
id|page
suffix:semicolon
r_int
id|map
comma
id|block
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_void
op_star
id|retval
suffix:semicolon
id|restart
suffix:colon
id|spin_lock_irqsave
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|list_for_each
(paren
id|entry
comma
op_amp
id|pool-&gt;page_list
)paren
(brace
r_int
id|i
suffix:semicolon
id|page
op_assign
id|list_entry
(paren
id|entry
comma
r_struct
id|pci_page
comma
id|page_list
)paren
suffix:semicolon
multiline_comment|/* only cachable accesses here ... */
r_for
c_loop
(paren
id|map
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pool-&gt;blocks_per_page
suffix:semicolon
id|i
op_add_assign
id|BITS_PER_LONG
comma
id|map
op_increment
)paren
(brace
r_if
c_cond
(paren
id|page-&gt;bitmap
(braket
id|map
)braket
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|block
op_assign
id|ffz
(paren
op_complement
id|page-&gt;bitmap
(braket
id|map
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_plus
id|block
)paren
OL
id|pool-&gt;blocks_per_page
)paren
(brace
id|clear_bit
(paren
id|block
comma
op_amp
id|page-&gt;bitmap
(braket
id|map
)braket
)paren
suffix:semicolon
id|offset
op_assign
(paren
id|BITS_PER_LONG
op_star
id|map
)paren
op_plus
id|block
suffix:semicolon
id|offset
op_mul_assign
id|pool-&gt;size
suffix:semicolon
r_goto
id|ready
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|page
op_assign
id|pool_alloc_page
(paren
id|pool
comma
id|mem_flags
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|mem_flags
op_eq
id|SLAB_KERNEL
)paren
(brace
id|DECLARE_WAITQUEUE
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|add_wait_queue
(paren
op_amp
id|pool-&gt;waitq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|schedule_timeout
(paren
id|POOL_TIMEOUT_JIFFIES
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
(paren
op_amp
id|pool-&gt;waitq
comma
op_amp
id|wait
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
id|retval
op_assign
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|clear_bit
(paren
l_int|0
comma
op_amp
id|page-&gt;bitmap
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
id|ready
suffix:colon
id|retval
op_assign
id|offset
op_plus
id|page-&gt;vaddr
suffix:semicolon
op_star
id|handle
op_assign
id|offset
op_plus
id|page-&gt;dma
suffix:semicolon
id|done
suffix:colon
id|spin_unlock_irqrestore
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
r_struct
id|pci_page
op_star
DECL|function|pool_find_page
id|pool_find_page
(paren
r_struct
id|pci_pool
op_star
id|pool
comma
id|dma_addr_t
id|dma
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
r_struct
id|pci_page
op_star
id|page
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|list_for_each
(paren
id|entry
comma
op_amp
id|pool-&gt;page_list
)paren
(brace
id|page
op_assign
id|list_entry
(paren
id|entry
comma
r_struct
id|pci_page
comma
id|page_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma
OL
id|page-&gt;dma
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dma
OL
(paren
id|page-&gt;dma
op_plus
id|pool-&gt;allocation
)paren
)paren
r_goto
id|done
suffix:semicolon
)brace
id|page
op_assign
l_int|0
suffix:semicolon
id|done
suffix:colon
id|spin_unlock_irqrestore
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|page
suffix:semicolon
)brace
multiline_comment|/**&n; * pci_pool_free - put block back into pci pool&n; * @pool: the pci pool holding the block&n; * @vaddr: virtual address of block&n; * @dma: dma address of block&n; *&n; * Caller promises neither device nor driver will again touch this block&n; * unless it is first re-allocated.&n; */
r_void
DECL|function|pci_pool_free
id|pci_pool_free
(paren
r_struct
id|pci_pool
op_star
id|pool
comma
r_void
op_star
id|vaddr
comma
id|dma_addr_t
id|dma
)paren
(brace
r_struct
id|pci_page
op_star
id|page
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|map
comma
id|block
suffix:semicolon
r_if
c_cond
(paren
(paren
id|page
op_assign
id|pool_find_page
(paren
id|pool
comma
id|dma
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;pci_pool_free %s/%s, %p/%lx (bad dma)&bslash;n&quot;
comma
id|pool-&gt;dev
ques
c_cond
id|pool-&gt;dev-&gt;slot_name
suffix:colon
l_int|NULL
comma
id|pool-&gt;name
comma
id|vaddr
comma
(paren
r_int
r_int
)paren
id|dma
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|block
op_assign
id|dma
op_minus
id|page-&gt;dma
suffix:semicolon
id|block
op_div_assign
id|pool-&gt;size
suffix:semicolon
id|map
op_assign
id|block
op_div
id|BITS_PER_LONG
suffix:semicolon
id|block
op_mod_assign
id|BITS_PER_LONG
suffix:semicolon
macro_line|#ifdef&t;CONFIG_DEBUG_SLAB
r_if
c_cond
(paren
(paren
(paren
id|dma
op_minus
id|page-&gt;dma
)paren
op_plus
(paren
r_void
op_star
)paren
id|page-&gt;vaddr
)paren
op_ne
id|vaddr
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;pci_pool_free %s/%s, %p (bad vaddr)/%lx&bslash;n&quot;
comma
id|pool-&gt;dev
ques
c_cond
id|pool-&gt;dev-&gt;slot_name
suffix:colon
l_int|NULL
comma
id|pool-&gt;name
comma
id|vaddr
comma
(paren
r_int
r_int
)paren
id|dma
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page-&gt;bitmap
(braket
id|map
)braket
op_amp
(paren
l_int|1UL
op_lshift
id|block
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;pci_pool_free %s/%s, dma %x already free&bslash;n&quot;
comma
id|pool-&gt;dev
ques
c_cond
id|pool-&gt;dev-&gt;slot_name
suffix:colon
l_int|NULL
comma
id|pool-&gt;name
comma
id|dma
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memset
(paren
id|vaddr
comma
id|POOL_POISON_BYTE
comma
id|pool-&gt;size
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|set_bit
(paren
id|block
comma
op_amp
id|page-&gt;bitmap
(braket
id|map
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
(paren
op_amp
id|pool-&gt;waitq
)paren
)paren
id|wake_up
(paren
op_amp
id|pool-&gt;waitq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Resist a temptation to do&n;&t; *    if (!is_page_busy(bpp, page-&gt;bitmap)) pool_free_page(pool, page);&n;&t; * it is not interrupt safe. Better have empty pages hang around.&n;&t; */
id|spin_unlock_irqrestore
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|pci_pool_create
id|EXPORT_SYMBOL
(paren
id|pci_pool_create
)paren
suffix:semicolon
DECL|variable|pci_pool_destroy
id|EXPORT_SYMBOL
(paren
id|pci_pool_destroy
)paren
suffix:semicolon
DECL|variable|pci_pool_alloc
id|EXPORT_SYMBOL
(paren
id|pci_pool_alloc
)paren
suffix:semicolon
DECL|variable|pci_pool_free
id|EXPORT_SYMBOL
(paren
id|pci_pool_free
)paren
suffix:semicolon
eof
