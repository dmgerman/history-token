multiline_comment|/*&n; *  drivers/s390/s390io.c&n; *   S/390 common I/O routines&n; *&n; *  S390 version&n; *    Copyright (C) 1999, 2000 IBM Deutschland Entwicklung GmbH,&n; *                             IBM Corporation&n; *    Author(s): Ingo Adlung (adlung@de.ibm.com)&n; *    ChangeLog: 01/07/2001 Blacklist cleanup (djbarrow@de.ibm.com,barrow_dj@yahoo.com)&n; *               01/04/2001 Holger Smolinski (smolinsk@de.ibm.com)&n; *                          Fixed lost interrupts and do_adapter_IO&n; *               xx/xx/xxxx nnn          multiple changes not reflected&n; *               03/12/2001 Ingo Adlung  blacklist= - changed to cio_ignore=  &n; *               03/14/2001 Ingo Adlung  disable interrupts before start_IO&n; *                                        in Path Group processing &n; *                                       decrease retry2 on busy while &n; *                                        disabling sync_isc; reset isc_cnt&n; *                                        on io error during sync_isc enablement&n; *               05/09/2001 Cornelia Huck added exploitation of debug feature&n; *               05/16/2001 Cornelia Huck added /proc/deviceinfo/&lt;devno&gt;/&n; *               05/22/2001 Cornelia Huck added /proc/cio_ignore&n; *                                        un-ignore blacklisted devices by piping &n; *                                        to /proc/cio_ignore&n; *               xx/xx/xxxx some bugfixes &amp; cleanups&n; *               08/02/2001 Cornelia Huck not already known devices can be blacklisted&n; *                                        by piping to /proc/cio_ignore&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/threads.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#ifdef CONFIG_PROC_FS
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#endif 
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/lowcore.h&gt;
macro_line|#include &lt;asm/idals.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt; 
macro_line|#include &lt;asm/cpcmd.h&gt;
macro_line|#include &lt;asm/s390io.h&gt;
macro_line|#include &lt;asm/s390dyn.h&gt;
macro_line|#include &lt;asm/s390mach.h&gt;
macro_line|#include &lt;asm/debug.h&gt;
macro_line|#include &lt;asm/queue.h&gt;
macro_line|#ifndef TRUE
DECL|macro|TRUE
mdefine_line|#define TRUE  1
DECL|macro|FALSE
mdefine_line|#define FALSE 0
macro_line|#endif
DECL|macro|SANITY_CHECK
mdefine_line|#define SANITY_CHECK(irq) do { &bslash;&n;if (irq &gt; highest_subchannel || irq &lt; 0) &bslash;&n;&t;&t;return (-ENODEV); &bslash;&n;&t;if (ioinfo[irq] == INVALID_STORAGE_AREA) &bslash;&n;&t;&t;return (-ENODEV); &bslash;&n;&t;} while(0) 
DECL|macro|CONFIG_DEBUG_IO
macro_line|#undef  CONFIG_DEBUG_IO
DECL|macro|CONFIG_DEBUG_CRW
mdefine_line|#define CONFIG_DEBUG_CRW
DECL|variable|highest_subchannel
r_int
r_int
id|highest_subchannel
suffix:semicolon
DECL|variable|ioinfo_head
id|ioinfo_t
op_star
id|ioinfo_head
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|ioinfo_tail
id|ioinfo_t
op_star
id|ioinfo_tail
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|ioinfo
id|ioinfo_t
op_star
id|ioinfo
(braket
id|__MAX_SUBCHANNELS
)braket
op_assign
(brace
(braket
l_int|0
dot
dot
dot
(paren
id|__MAX_SUBCHANNELS
op_minus
l_int|1
)paren
)braket
op_assign
id|INVALID_STORAGE_AREA
)brace
suffix:semicolon
DECL|variable|sync_isc
r_static
id|atomic_t
id|sync_isc
op_assign
id|ATOMIC_INIT
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
DECL|variable|sync_isc_cnt
r_static
r_int
id|sync_isc_cnt
op_assign
l_int|0
suffix:semicolon
singleline_comment|// synchronous irq processing lock
DECL|variable|adapter_lock
r_static
id|spinlock_t
id|adapter_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
singleline_comment|// adapter interrupt lock
DECL|variable|io_sync_wait
r_static
id|psw_t
id|io_sync_wait
suffix:semicolon
singleline_comment|// wait PSW for sync IO, prot. by sync_isc
DECL|variable|cons_dev
r_static
r_int
id|cons_dev
op_assign
op_minus
l_int|1
suffix:semicolon
singleline_comment|// identify console device
DECL|variable|init_IRQ_complete
r_static
r_int
id|init_IRQ_complete
op_assign
l_int|0
suffix:semicolon
DECL|variable|cio_show_msg
r_static
r_int
id|cio_show_msg
op_assign
l_int|0
suffix:semicolon
DECL|variable|p_init_schib
r_static
id|schib_t
op_star
id|p_init_schib
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|p_init_irb
r_static
id|irb_t
op_star
id|p_init_irb
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|irq_IPL_TOD
r_static
id|__u64
id|irq_IPL_TOD
suffix:semicolon
DECL|variable|adapter_handler
r_static
id|adapter_int_handler_t
id|adapter_handler
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* for use of debug feature */
DECL|variable|cio_debug_msg_id
id|debug_info_t
op_star
id|cio_debug_msg_id
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|cio_debug_trace_id
id|debug_info_t
op_star
id|cio_debug_trace_id
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|cio_debug_crw_id
id|debug_info_t
op_star
id|cio_debug_crw_id
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|cio_debug_initialized
r_int
id|cio_debug_initialized
op_assign
l_int|0
suffix:semicolon
r_static
r_void
id|init_IRQ_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|s390_process_subchannels
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|s390_device_recognition_all
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|s390_device_recognition_irq
c_func
(paren
r_int
id|irq
)paren
suffix:semicolon
r_static
r_void
id|s390_redo_validation
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|s390_validate_subchannel
c_func
(paren
r_int
id|irq
comma
r_int
id|enable
)paren
suffix:semicolon
r_static
r_int
id|s390_SenseID
c_func
(paren
r_int
id|irq
comma
id|senseid_t
op_star
id|sid
comma
id|__u8
id|lpm
)paren
suffix:semicolon
r_static
r_int
id|s390_SetPGID
c_func
(paren
r_int
id|irq
comma
id|__u8
id|lpm
comma
id|pgid_t
op_star
id|pgid
)paren
suffix:semicolon
r_static
r_int
id|s390_SensePGID
c_func
(paren
r_int
id|irq
comma
id|__u8
id|lpm
comma
id|pgid_t
op_star
id|pgid
)paren
suffix:semicolon
r_static
r_int
id|s390_process_IRQ
c_func
(paren
r_int
r_int
id|irq
)paren
suffix:semicolon
r_static
r_int
id|enable_subchannel
c_func
(paren
r_int
r_int
id|irq
)paren
suffix:semicolon
r_static
r_int
id|disable_subchannel
c_func
(paren
r_int
r_int
id|irq
)paren
suffix:semicolon
r_static
r_int
id|chan_proc_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_inline
r_void
id|do_adapter_IO
c_func
(paren
id|__u32
id|intparm
)paren
suffix:semicolon
r_int
id|s390_DevicePathVerification
c_func
(paren
r_int
id|irq
comma
id|__u8
id|domask
)paren
suffix:semicolon
r_int
id|s390_register_adapter_interrupt
c_func
(paren
id|adapter_int_handler_t
id|handler
)paren
suffix:semicolon
r_int
id|s390_unregister_adapter_interrupt
c_func
(paren
id|adapter_int_handler_t
id|handler
)paren
suffix:semicolon
r_extern
r_int
id|do_none
c_func
(paren
r_int
r_int
id|irq
comma
r_int
id|cpu
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_extern
r_int
id|enable_none
c_func
(paren
r_int
r_int
id|irq
)paren
suffix:semicolon
r_extern
r_int
id|disable_none
c_func
(paren
r_int
r_int
id|irq
)paren
suffix:semicolon
id|asmlinkage
r_void
id|do_IRQ
c_func
(paren
r_struct
id|pt_regs
id|regs
)paren
suffix:semicolon
DECL|macro|MAX_CIO_PROCFS_ENTRIES
mdefine_line|#define MAX_CIO_PROCFS_ENTRIES 0x300
multiline_comment|/* magic number; we want to have some room to spare */
r_int
id|cio_procfs_device_create
c_func
(paren
r_int
id|devno
)paren
suffix:semicolon
r_int
id|cio_procfs_device_remove
c_func
(paren
r_int
id|devno
)paren
suffix:semicolon
r_int
id|cio_procfs_device_purge
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|cio_notoper_msg
r_int
id|cio_notoper_msg
op_assign
l_int|1
suffix:semicolon
DECL|variable|cio_proc_devinfo
r_int
id|cio_proc_devinfo
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* switch off the /proc/deviceinfo/ stuff by default&n;&t;&t;&t;     until problems are dealt with */
DECL|variable|s390_irq_count
r_int
r_int
id|s390_irq_count
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* trace how many irqs have occured per cpu... */
DECL|variable|cio_count_irqs
r_int
id|cio_count_irqs
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* toggle use here... */
multiline_comment|/* &n; * &quot;Blacklisting&quot; of certain devices:&n; * Device numbers given in the commandline as blacklist=... won&squot;t be known to Linux&n; * These can be single devices or ranges of devices&n; *&n; * Introduced by Cornelia Huck &lt;cohuck@de.ibm.com&gt;&n; * Most of it shamelessly taken from dasd.c &n; */
DECL|struct|dev_blacklist_range_t
r_typedef
r_struct
id|dev_blacklist_range_t
(brace
DECL|member|next
r_struct
id|dev_blacklist_range_t
op_star
id|next
suffix:semicolon
multiline_comment|/* next range in list */
DECL|member|from
r_int
r_int
id|from
suffix:semicolon
multiline_comment|/* beginning of range */
DECL|member|to
r_int
r_int
id|to
suffix:semicolon
multiline_comment|/* end of range */
DECL|member|kmalloced
r_int
id|kmalloced
suffix:semicolon
DECL|typedef|dev_blacklist_range_t
)brace
id|dev_blacklist_range_t
suffix:semicolon
DECL|variable|dev_blacklist_range_head
r_static
id|dev_blacklist_range_t
op_star
id|dev_blacklist_range_head
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Anchor for list of ranges */
DECL|variable|dev_blacklist_unused_head
r_static
id|dev_blacklist_range_t
op_star
id|dev_blacklist_unused_head
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|blacklist_lock
r_static
id|spinlock_t
id|blacklist_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|nr_blacklisted_ranges
r_static
r_int
id|nr_blacklisted_ranges
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Handling of the blacklist ranges */
DECL|function|blacklist_range_destroy
r_static
r_inline
r_void
id|blacklist_range_destroy
c_func
(paren
id|dev_blacklist_range_t
op_star
id|range
comma
r_int
id|locked
)paren
(brace
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|locked
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|blacklist_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|remove_from_list
c_func
(paren
(paren
id|list
op_star
op_star
)paren
op_amp
id|dev_blacklist_range_head
comma
(paren
id|list
op_star
)paren
id|range
)paren
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|nr_blacklisted_ranges
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|range-&gt;kmalloced
)paren
(brace
id|kfree
c_func
(paren
id|range
)paren
suffix:semicolon
)brace
r_else
id|add_to_list
c_func
(paren
(paren
id|list
op_star
op_star
)paren
op_amp
id|dev_blacklist_unused_head
comma
(paren
id|list
op_star
)paren
id|range
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|locked
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|blacklist_lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Function: blacklist_range_add&n; * Creates a range from the specified arguments and appends it to the list of&n; * blacklisted devices&n; */
DECL|function|blacklist_range_add
r_static
r_inline
id|dev_blacklist_range_t
op_star
id|blacklist_range_add
c_func
(paren
r_int
id|from
comma
r_int
id|to
comma
r_int
id|locked
)paren
(brace
id|dev_blacklist_range_t
op_star
id|range
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|to
op_logical_and
(paren
id|from
OG
id|to
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Invalid blacklist range %x to %x, skipping&bslash;n&quot;
comma
id|from
comma
id|to
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|locked
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|blacklist_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev_blacklist_unused_head
)paren
(brace
id|range
op_assign
(paren
id|dev_blacklist_range_t
op_star
)paren
id|remove_listhead
c_func
(paren
(paren
id|list
op_star
op_star
)paren
op_amp
id|dev_blacklist_unused_head
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
(brace
r_if
c_cond
(paren
(paren
id|range
op_assign
(paren
id|dev_blacklist_range_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|dev_blacklist_range_t
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|range-&gt;kmalloced
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|range
op_assign
(paren
id|dev_blacklist_range_t
op_star
)paren
id|alloc_bootmem
c_func
(paren
r_sizeof
(paren
id|dev_blacklist_range_t
)paren
)paren
)paren
)paren
(brace
id|range-&gt;kmalloced
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|range
)paren
(brace
id|add_to_list
c_func
(paren
(paren
id|list
op_star
op_star
)paren
op_amp
id|dev_blacklist_range_head
comma
(paren
id|list
op_star
)paren
id|range
)paren
suffix:semicolon
id|range-&gt;from
op_assign
id|from
suffix:semicolon
r_if
c_cond
(paren
id|to
op_eq
l_int|0
)paren
(brace
multiline_comment|/* only a single device is given */
id|range-&gt;to
op_assign
id|from
suffix:semicolon
)brace
r_else
(brace
id|range-&gt;to
op_assign
id|to
suffix:semicolon
)brace
id|nr_blacklisted_ranges
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|locked
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|blacklist_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|range
suffix:semicolon
)brace
multiline_comment|/* &n; * Function: blacklist_range_remove&n; * Removes a range from the blacklist chain&n; */
DECL|function|blacklist_range_remove
r_static
r_inline
r_void
id|blacklist_range_remove
c_func
(paren
r_int
id|from
comma
r_int
id|to
)paren
(brace
id|dev_blacklist_range_t
op_star
id|temp
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|blacklist_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|temp
op_assign
id|dev_blacklist_range_head
suffix:semicolon
(paren
id|temp-&gt;from
op_ne
id|from
)paren
op_logical_and
(paren
id|temp-&gt;to
op_ne
id|to
)paren
suffix:semicolon
id|temp
op_assign
id|temp-&gt;next
)paren
suffix:semicolon
id|blacklist_range_destroy
c_func
(paren
id|temp
comma
l_int|1
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|blacklist_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Parsing the commandline for blacklist parameters */
multiline_comment|/* &n; * Variable to hold the blacklisted devices given by the parameter line&n; * blacklist=...&n; */
DECL|variable|blacklist
r_char
op_star
id|blacklist
(braket
l_int|256
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Get the blacklist=... items from the parameter line&n; */
DECL|function|blacklist_split_parm_string
r_static
r_void
id|blacklist_split_parm_string
(paren
r_char
op_star
id|str
)paren
(brace
r_char
op_star
id|tmp
op_assign
id|str
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_char
op_star
id|end
suffix:semicolon
r_int
id|len
suffix:semicolon
id|end
op_assign
id|strchr
(paren
id|tmp
comma
l_char|&squot;,&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
op_eq
l_int|NULL
)paren
(brace
id|len
op_assign
id|strlen
(paren
id|tmp
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|len
op_assign
(paren
r_int
)paren
id|end
op_minus
(paren
r_int
)paren
id|tmp
op_plus
l_int|1
suffix:semicolon
op_star
id|end
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|end
op_increment
suffix:semicolon
)brace
id|blacklist
(braket
id|count
)braket
op_assign
id|alloc_bootmem
(paren
id|len
op_star
r_sizeof
(paren
r_char
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blacklist
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;can&squot;t store blacklist= parameter no %d&bslash;n&quot;
comma
id|count
op_plus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memset
(paren
id|blacklist
(braket
id|count
)braket
comma
l_int|0
comma
id|len
op_star
r_sizeof
(paren
r_char
)paren
)paren
suffix:semicolon
id|memcpy
(paren
id|blacklist
(braket
id|count
)braket
comma
id|tmp
comma
id|len
op_star
r_sizeof
(paren
r_char
)paren
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
id|tmp
op_assign
id|end
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
l_int|NULL
op_logical_and
op_star
id|tmp
op_ne
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The blacklist parameters as one concatenated string&n; */
DECL|variable|__initdata
r_static
r_char
id|blacklist_parm_string
(braket
l_int|1024
)braket
id|__initdata
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* &n; * function: blacklist_strtoul&n; * Strip leading &squot;0x&squot; and interpret the values as Hex&n; */
DECL|function|blacklist_strtoul
r_static
r_inline
r_int
id|blacklist_strtoul
(paren
r_char
op_star
id|str
comma
r_char
op_star
op_star
id|stra
)paren
(brace
r_char
op_star
id|temp
op_assign
id|str
suffix:semicolon
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
op_star
id|temp
op_eq
l_char|&squot;0&squot;
)paren
(brace
id|temp
op_increment
suffix:semicolon
multiline_comment|/* strip leading zero */
r_if
c_cond
(paren
op_star
id|temp
op_eq
l_char|&squot;x&squot;
)paren
id|temp
op_increment
suffix:semicolon
multiline_comment|/* strip leading x */
)brace
id|val
op_assign
id|simple_strtoul
(paren
id|temp
comma
op_amp
id|temp
comma
l_int|16
)paren
suffix:semicolon
multiline_comment|/* interpret anything as hex */
op_star
id|stra
op_assign
id|temp
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
multiline_comment|/*&n; * Function: blacklist_parse&n; * Parse the parameters given to blacklist=... &n; * Add the blacklisted devices to the blacklist chain&n; */
DECL|function|blacklist_parse
r_static
r_inline
r_void
id|blacklist_parse
c_func
(paren
r_char
op_star
op_star
id|str
)paren
(brace
r_char
op_star
id|temp
suffix:semicolon
r_int
id|from
comma
id|to
suffix:semicolon
r_while
c_loop
(paren
op_star
id|str
)paren
(brace
id|temp
op_assign
op_star
id|str
suffix:semicolon
id|from
op_assign
l_int|0
suffix:semicolon
id|to
op_assign
l_int|0
suffix:semicolon
id|from
op_assign
id|blacklist_strtoul
c_func
(paren
id|temp
comma
op_amp
id|temp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|temp
op_eq
l_char|&squot;-&squot;
)paren
(brace
id|temp
op_increment
suffix:semicolon
id|to
op_assign
id|blacklist_strtoul
c_func
(paren
id|temp
comma
op_amp
id|temp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|blacklist_range_add
c_func
(paren
id|from
comma
id|to
comma
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Blacklisting range from %X to %X failed!&bslash;n&quot;
comma
id|from
comma
id|to
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;Blacklisted range from %X to %X&bslash;n&quot;
comma
id|from
comma
id|to
)paren
suffix:semicolon
macro_line|#endif
id|str
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Initialisation of blacklist &n; */
DECL|function|blacklist_init
r_void
id|__init
id|blacklist_init
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_DEBUG_IO     
id|printk
c_func
(paren
l_string|&quot;Reading blacklist...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|6
comma
l_string|&quot;Reading blacklist&bslash;n&quot;
)paren
suffix:semicolon
id|blacklist_split_parm_string
c_func
(paren
id|blacklist_parm_string
)paren
suffix:semicolon
id|blacklist_parse
c_func
(paren
id|blacklist
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Get all the blacklist parameters from parameter line&n; */
DECL|function|blacklist_setup
r_void
id|__init
id|blacklist_setup
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_int
id|len
op_assign
id|strlen
(paren
id|blacklist_parm_string
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
l_int|0
)paren
(brace
id|strcat
(paren
id|blacklist_parm_string
comma
l_string|&quot;,&quot;
)paren
suffix:semicolon
)brace
id|strcat
(paren
id|blacklist_parm_string
comma
id|str
)paren
suffix:semicolon
)brace
DECL|function|blacklist_call_setup
r_int
id|__init
id|blacklist_call_setup
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|dummy
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;Reading blacklist parameters...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|6
comma
l_string|&quot;Reading blacklist parameters&bslash;n&quot;
)paren
suffix:semicolon
id|blacklist_setup
c_func
(paren
id|str
comma
op_amp
id|dummy
)paren
suffix:semicolon
id|blacklist_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Blacklist ranges must be ready when device recognition starts */
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
(paren
l_string|&quot;cio_ignore=&quot;
comma
id|blacklist_call_setup
)paren
suffix:semicolon
multiline_comment|/* Checking if devices are blacklisted */
multiline_comment|/*&n; * Function: is_blacklisted&n; * Returns 1 if the given devicenumber can be found in the blacklist, otherwise 0.&n; */
DECL|function|is_blacklisted
r_static
r_inline
r_int
id|is_blacklisted
c_func
(paren
r_int
id|devno
)paren
(brace
id|dev_blacklist_range_t
op_star
id|temp
suffix:semicolon
r_int
id|flags
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev_blacklist_range_head
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* no blacklist */
r_return
l_int|0
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|blacklist_lock
comma
id|flags
)paren
suffix:semicolon
id|temp
op_assign
id|dev_blacklist_range_head
suffix:semicolon
r_while
c_loop
(paren
id|temp
)paren
(brace
r_if
c_cond
(paren
(paren
id|temp-&gt;from
op_le
id|devno
)paren
op_logical_and
(paren
id|temp-&gt;to
op_ge
id|devno
)paren
)paren
(brace
id|retval
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Deviceno is blacklisted */
r_break
suffix:semicolon
)brace
id|temp
op_assign
id|temp-&gt;next
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|blacklist_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Function: blacklist_free_all_ranges&n; * set all blacklisted devices free...&n; */
DECL|function|blacklist_free_all_ranges
r_void
id|blacklist_free_all_ranges
c_func
(paren
r_void
)paren
(brace
id|dev_blacklist_range_t
op_star
id|tmp
op_assign
id|dev_blacklist_range_head
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|blacklist_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|tmp
)paren
(brace
id|blacklist_range_destroy
c_func
(paren
id|tmp
comma
l_int|1
)paren
suffix:semicolon
id|tmp
op_assign
id|dev_blacklist_range_head
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|blacklist_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function: blacklist_parse_proc_parameters&n; * parse the stuff which is piped to /proc/cio_ignore&n; */
DECL|function|blacklist_parse_proc_parameters
r_void
id|blacklist_parse_proc_parameters
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_char
op_star
id|tmp
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
op_star
id|end
suffix:semicolon
r_int
id|len
op_assign
op_minus
l_int|1
suffix:semicolon
r_char
op_star
id|param
suffix:semicolon
r_int
id|from
op_assign
l_int|0
suffix:semicolon
r_int
id|to
op_assign
l_int|0
suffix:semicolon
r_int
id|changed
op_assign
l_int|0
suffix:semicolon
id|dev_blacklist_range_t
op_star
id|range
comma
op_star
id|temp
suffix:semicolon
r_int
id|flags
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|tmp
op_assign
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|tmp
comma
l_string|&quot;free &quot;
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|tmp
comma
l_string|&quot;all&quot;
)paren
)paren
(brace
id|blacklist_free_all_ranges
c_func
(paren
)paren
suffix:semicolon
id|s390_redo_validation
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
id|tmp
op_ne
l_int|NULL
)paren
(brace
id|end
op_assign
id|strchr
c_func
(paren
id|tmp
comma
l_char|&squot;,&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
op_eq
l_int|NULL
)paren
(brace
id|len
op_assign
id|strlen
c_func
(paren
id|tmp
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|len
op_assign
(paren
r_int
)paren
id|end
op_minus
(paren
r_int
)paren
id|tmp
op_plus
l_int|1
suffix:semicolon
op_star
id|end
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|end
op_increment
suffix:semicolon
)brace
id|param
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|len
op_star
r_sizeof
(paren
r_char
)paren
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|param
comma
(paren
r_const
r_char
op_star
)paren
id|tmp
comma
id|len
)paren
suffix:semicolon
id|tmp
op_assign
id|end
suffix:semicolon
id|from
op_assign
id|blacklist_strtoul
c_func
(paren
id|param
comma
op_amp
id|param
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|param
op_eq
l_char|&squot;-&squot;
)paren
(brace
id|param
op_increment
suffix:semicolon
id|to
op_assign
id|blacklist_strtoul
c_func
(paren
id|param
comma
op_amp
id|param
)paren
suffix:semicolon
)brace
r_else
(brace
id|to
op_assign
id|from
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|blacklist_lock
comma
id|flags
)paren
suffix:semicolon
id|range
op_assign
id|dev_blacklist_range_head
suffix:semicolon
r_while
c_loop
(paren
id|range
op_ne
l_int|NULL
)paren
(brace
id|temp
op_assign
id|range-&gt;next
suffix:semicolon
r_if
c_cond
(paren
(paren
id|from
op_le
id|range-&gt;from
)paren
op_logical_and
(paren
id|to
op_ge
id|range-&gt;to
)paren
)paren
(brace
id|blacklist_range_destroy
c_func
(paren
id|range
comma
l_int|1
)paren
suffix:semicolon
id|changed
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|from
op_le
id|range-&gt;from
)paren
op_logical_and
(paren
id|to
op_ge
id|range-&gt;from
)paren
op_logical_and
(paren
id|to
OL
id|range-&gt;to
)paren
)paren
(brace
id|blacklist_range_add
c_func
(paren
id|to
op_plus
l_int|1
comma
id|range-&gt;to
comma
l_int|1
)paren
suffix:semicolon
id|blacklist_range_destroy
c_func
(paren
id|range
comma
l_int|1
)paren
suffix:semicolon
id|changed
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|from
OG
id|range-&gt;from
)paren
op_logical_and
(paren
id|from
op_le
id|range-&gt;to
)paren
op_logical_and
(paren
id|to
op_ge
id|range-&gt;to
)paren
)paren
(brace
id|blacklist_range_add
c_func
(paren
id|range-&gt;from
comma
id|from
op_minus
l_int|1
comma
l_int|1
)paren
suffix:semicolon
id|blacklist_range_destroy
c_func
(paren
id|range
comma
l_int|1
)paren
suffix:semicolon
id|changed
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|from
OG
id|range-&gt;from
)paren
op_logical_and
(paren
id|to
OL
id|range-&gt;to
)paren
)paren
(brace
id|blacklist_range_add
c_func
(paren
id|range-&gt;from
comma
id|from
op_minus
l_int|1
comma
l_int|1
)paren
suffix:semicolon
id|blacklist_range_add
c_func
(paren
id|to
op_plus
l_int|1
comma
id|range-&gt;to
comma
l_int|1
)paren
suffix:semicolon
id|blacklist_range_destroy
c_func
(paren
id|range
comma
l_int|1
)paren
suffix:semicolon
id|changed
op_assign
l_int|1
suffix:semicolon
)brace
id|range
op_assign
id|temp
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|blacklist_lock
comma
id|flags
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|param
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|changed
)paren
id|s390_redo_validation
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|tmp
comma
l_string|&quot;add &quot;
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
l_int|NULL
)paren
(brace
id|end
op_assign
id|strchr
c_func
(paren
id|tmp
comma
l_char|&squot;,&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
op_eq
l_int|NULL
)paren
(brace
id|len
op_assign
id|strlen
c_func
(paren
id|tmp
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|len
op_assign
(paren
r_int
)paren
id|end
op_minus
(paren
r_int
)paren
id|tmp
op_plus
l_int|1
suffix:semicolon
op_star
id|end
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|end
op_increment
suffix:semicolon
)brace
id|param
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|len
op_star
r_sizeof
(paren
r_char
)paren
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|param
comma
(paren
r_const
r_char
op_star
)paren
id|tmp
comma
id|len
)paren
suffix:semicolon
id|tmp
op_assign
id|end
suffix:semicolon
id|from
op_assign
id|blacklist_strtoul
c_func
(paren
id|param
comma
op_amp
id|param
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|param
op_eq
l_char|&squot;-&squot;
)paren
(brace
id|param
op_increment
suffix:semicolon
id|to
op_assign
id|blacklist_strtoul
c_func
(paren
id|param
comma
op_amp
id|param
)paren
suffix:semicolon
)brace
r_else
(brace
id|to
op_assign
id|from
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|blacklist_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Don&squot;t allow for already known devices to be&n;&t;&t;&t; * blacklisted&n;&t;&t;&t; * The criterion is a bit dumb, devices which once were&n;&t;&t;&t; * there but are already gone are also caught...&n;&t;&t;&t; */
id|err
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|highest_subchannel
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|i
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
(brace
r_if
c_cond
(paren
(paren
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
op_ge
id|from
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
op_le
id|to
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cio_ignore: Won&squot;t blacklist &quot;
l_string|&quot;already known devices, skipping range &quot;
l_string|&quot;%x to %x&bslash;n&quot;
comma
id|from
comma
id|to
)paren
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * Note: We allow for overlapping ranges here, &n;&t;&t;&t; * since the user might specify overlapping ranges&n;&t;&t;&t; * and we walk through all ranges when freeing anyway.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|blacklist_range_add
c_func
(paren
id|from
comma
id|to
comma
l_int|1
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|blacklist_lock
comma
id|flags
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|param
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;cio_ignore: Parse error; try using &squot;free all|&lt;devno-range&gt;,&lt;devno-range&gt;,...&squot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;or &squot;add &lt;devno-range&gt;,&lt;devno-range&gt;,...&squot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* End of blacklist handling */
r_void
id|s390_displayhex
c_func
(paren
r_char
op_star
id|str
comma
r_void
op_star
id|ptr
comma
id|s32
id|cnt
)paren
suffix:semicolon
r_void
id|s390_displayhex2
c_func
(paren
r_char
op_star
id|str
comma
r_void
op_star
id|ptr
comma
id|s32
id|cnt
comma
r_int
id|level
)paren
suffix:semicolon
DECL|function|s390_displayhex
r_void
id|s390_displayhex
c_func
(paren
r_char
op_star
id|str
comma
r_void
op_star
id|ptr
comma
id|s32
id|cnt
)paren
(brace
id|s32
id|cnt1
comma
id|cnt2
comma
id|maxcnt2
suffix:semicolon
id|u32
op_star
id|currptr
op_assign
(paren
id|__u32
op_star
)paren
id|ptr
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n%s&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt1
op_assign
l_int|0
suffix:semicolon
id|cnt1
OL
id|cnt
suffix:semicolon
id|cnt1
op_add_assign
l_int|16
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%08lX &quot;
comma
(paren
r_int
r_int
)paren
id|currptr
)paren
suffix:semicolon
id|maxcnt2
op_assign
id|cnt
op_minus
id|cnt1
suffix:semicolon
r_if
c_cond
(paren
id|maxcnt2
OG
l_int|16
)paren
(brace
id|maxcnt2
op_assign
l_int|16
suffix:semicolon
)brace
r_for
c_loop
(paren
id|cnt2
op_assign
l_int|0
suffix:semicolon
id|cnt2
OL
id|maxcnt2
suffix:semicolon
id|cnt2
op_add_assign
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%08X &quot;
comma
op_star
id|currptr
op_increment
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|s390_displayhex2
r_void
id|s390_displayhex2
c_func
(paren
r_char
op_star
id|str
comma
r_void
op_star
id|ptr
comma
id|s32
id|cnt
comma
r_int
id|level
)paren
(brace
id|s32
id|cnt1
comma
id|cnt2
comma
id|maxcnt2
suffix:semicolon
id|u32
op_star
id|currptr
op_assign
(paren
id|__u32
op_star
)paren
id|ptr
suffix:semicolon
r_char
id|buffer
(braket
id|cnt
op_star
l_int|12
)braket
suffix:semicolon
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
id|level
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt1
op_assign
l_int|0
suffix:semicolon
id|cnt1
OL
id|cnt
suffix:semicolon
id|cnt1
op_add_assign
l_int|16
)paren
(brace
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%08lX &quot;
comma
(paren
r_int
r_int
)paren
id|currptr
)paren
suffix:semicolon
id|maxcnt2
op_assign
id|cnt
op_minus
id|cnt1
suffix:semicolon
r_if
c_cond
(paren
id|maxcnt2
OG
l_int|16
)paren
id|maxcnt2
op_assign
l_int|16
suffix:semicolon
r_for
c_loop
(paren
id|cnt2
op_assign
l_int|0
suffix:semicolon
id|cnt2
OL
id|maxcnt2
suffix:semicolon
id|cnt2
op_add_assign
l_int|4
)paren
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%08X &quot;
comma
op_star
id|currptr
op_increment
)paren
suffix:semicolon
)brace
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
id|level
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|buffer
)paren
suffix:semicolon
)brace
DECL|function|cio_setup
r_static
r_int
id|__init
id|cio_setup
c_func
(paren
r_char
op_star
id|parm
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|parm
comma
l_string|&quot;yes&quot;
)paren
)paren
(brace
id|cio_show_msg
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|parm
comma
l_string|&quot;no&quot;
)paren
)paren
(brace
id|cio_show_msg
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;cio_setup : invalid cio_msg parameter &squot;%s&squot;&quot;
comma
id|parm
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;cio_msg=&quot;
comma
id|cio_setup
)paren
suffix:semicolon
DECL|function|cio_notoper_setup
r_static
r_int
id|__init
id|cio_notoper_setup
c_func
(paren
r_char
op_star
id|parm
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|parm
comma
l_string|&quot;yes&quot;
)paren
)paren
(brace
id|cio_notoper_msg
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|parm
comma
l_string|&quot;no&quot;
)paren
)paren
(brace
id|cio_notoper_msg
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;cio_notoper_setup: invalid cio_notoper_msg parameter &squot;%s&squot;&quot;
comma
id|parm
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;cio_notoper_msg=&quot;
comma
id|cio_notoper_setup
)paren
suffix:semicolon
DECL|function|cio_proc_devinfo_setup
r_static
r_int
id|__init
id|cio_proc_devinfo_setup
c_func
(paren
r_char
op_star
id|parm
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|parm
comma
l_string|&quot;yes&quot;
)paren
)paren
(brace
id|cio_proc_devinfo
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|parm
comma
l_string|&quot;no&quot;
)paren
)paren
(brace
id|cio_proc_devinfo
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;cio_proc_devinfo_setup: invalid parameter &squot;%s&squot;&bslash;n&quot;
comma
id|parm
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;cio_proc_devinfo=&quot;
comma
id|cio_proc_devinfo_setup
)paren
suffix:semicolon
multiline_comment|/*&n; * register for adapter interrupts&n; *&n; * With HiperSockets the zSeries architecture provides for&n; *  means of adapter interrups, pseudo I/O interrupts that are&n; *  not tied to an I/O subchannel, but to an adapter. However,&n; *  it doesn&squot;t disclose the info how to enable/disable them, but&n; *  to recognize them only. Perhaps we should consider them&n; *  being shared interrupts, and thus build a linked list&n; *  of adapter handlers ... to be evaluated ...&n; */
DECL|function|s390_register_adapter_interrupt
r_int
id|s390_register_adapter_interrupt
c_func
(paren
id|adapter_int_handler_t
id|handler
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
l_string|&quot;rgaint&quot;
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|adapter_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|handler
op_eq
l_int|NULL
)paren
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_else
r_if
c_cond
(paren
id|adapter_handler
)paren
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_else
id|adapter_handler
op_assign
id|handler
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|adapter_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|s390_unregister_adapter_interrupt
r_int
id|s390_unregister_adapter_interrupt
c_func
(paren
id|adapter_int_handler_t
id|handler
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
l_string|&quot;urgaint&quot;
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|adapter_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|handler
op_eq
l_int|NULL
)paren
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_else
r_if
c_cond
(paren
id|handler
op_ne
id|adapter_handler
)paren
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_else
id|adapter_handler
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|adapter_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|do_adapter_IO
r_static
r_inline
r_void
id|do_adapter_IO
c_func
(paren
id|__u32
id|intparm
)paren
(brace
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
l_string|&quot;doaio&quot;
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|adapter_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adapter_handler
)paren
(paren
op_star
id|adapter_handler
)paren
(paren
id|intparm
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|adapter_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Note : internal use of irqflags SA_PROBE for NOT path grouping &n; *&n; */
DECL|function|s390_request_irq_special
r_int
id|s390_request_irq_special
c_func
(paren
r_int
id|irq
comma
id|io_handler_func_t
id|io_handler
comma
id|not_oper_handler_func_t
id|not_oper_handler
comma
r_int
r_int
id|irqflags
comma
r_const
r_char
op_star
id|devname
comma
r_void
op_star
id|dev_id
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
r_int
id|retry
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ge
id|__MAX_SUBCHANNELS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|io_handler
op_logical_or
op_logical_neg
id|dev_id
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
l_string|&quot;reqsp&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dbf_txt
comma
l_string|&quot;%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The following block of code has to be executed atomically&n;&t; */
id|s390irq_spin_lock_irqsave
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
id|retry
op_assign
l_int|5
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.handler
op_assign
id|io_handler
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.name
op_assign
id|devname
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
op_assign
id|dev_id
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
op_assign
l_int|1
suffix:semicolon
r_do
(brace
id|retval
op_assign
id|enable_subchannel
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|stsch
c_func
(paren
id|irq
comma
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.ena
)paren
id|retry
op_assign
l_int|0
suffix:semicolon
r_else
id|retry
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|retry
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; *  interrupt already owned, and shared interrupts&n;&t;&t; *   aren&squot;t supported on S/390.&n;&t;&t; */
id|retval
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* endif */
id|s390irq_spin_unlock_irqrestore
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|irqflags
op_amp
id|SA_PROBE
)paren
)paren
id|s390_DevicePathVerification
c_func
(paren
id|irq
comma
l_int|0
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.newreq
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|nopfunc
op_assign
id|not_oper_handler
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|s390_request_irq
r_int
id|s390_request_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
id|irqflags
comma
r_const
r_char
op_star
id|devname
comma
r_void
op_star
id|dev_id
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|s390_request_irq_special
c_func
(paren
id|irq
comma
(paren
id|io_handler_func_t
)paren
id|handler
comma
l_int|NULL
comma
id|irqflags
comma
id|devname
comma
id|dev_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.newreq
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|ret
suffix:semicolon
)brace
DECL|function|s390_free_irq
r_void
id|s390_free_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
op_star
id|dev_id
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ge
id|__MAX_SUBCHANNELS
op_logical_or
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|2
comma
l_string|&quot;free&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dbf_txt
comma
l_string|&quot;%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|2
comma
id|dbf_txt
)paren
suffix:semicolon
)brace
id|s390irq_spin_lock_irqsave
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef  CONFIG_KERNEL_DEBUG
r_if
c_cond
(paren
id|irq
op_ne
id|cons_dev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying to free IRQ%d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|2
comma
l_string|&quot;Trying to free IRQ %d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * disable the device and reset all IRQ info if&n;&t; *  the IRQ is actually owned by the handler ...&n;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
r_if
c_cond
(paren
id|dev_id
op_eq
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
)paren
(brace
multiline_comment|/* start deregister */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.unready
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Try to stop IO first...&n;&t;&t;&t; * ... it seems disable_subchannel is sometimes&n;&t;&t;&t; * successfully called with IO still pending.&n;&t;&t;&t; */
id|halt_IO
c_func
(paren
id|irq
comma
l_int|0xC8C1D3E3
comma
id|DOIO_WAIT_FOR_INTERRUPT
)paren
suffix:semicolon
r_do
(brace
id|ret
op_assign
id|disable_subchannel
c_func
(paren
id|irq
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EBUSY
)paren
(brace
r_int
id|iret
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * kill it !&n;&t;&t;&t;&t;&t; * ... we first try sync and eventually&n;&t;&t;&t;&t;&t; *  try terminating the current I/O by&n;&t;&t;&t;&t;&t; *  an async request, twice halt, then&n;&t;&t;&t;&t;&t; *  clear.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|count
OL
l_int|2
)paren
(brace
id|iret
op_assign
id|halt_IO
c_func
(paren
id|irq
comma
l_int|0xC8C1D3E3
comma
id|DOIO_WAIT_FOR_INTERRUPT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iret
op_eq
op_minus
id|EBUSY
)paren
(brace
id|halt_IO
c_func
(paren
id|irq
comma
l_int|0xC8C1D3E3
comma
l_int|0
)paren
suffix:semicolon
id|s390irq_spin_unlock_irqrestore
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|200000
)paren
suffix:semicolon
multiline_comment|/* 200 ms */
id|s390irq_spin_lock_irqsave
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|iret
op_assign
id|clear_IO
c_func
(paren
id|irq
comma
l_int|0x40C3D3D9
comma
id|DOIO_WAIT_FOR_INTERRUPT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iret
op_eq
op_minus
id|EBUSY
)paren
(brace
id|clear_IO
c_func
(paren
id|irq
comma
l_int|0xC8C1D3E3
comma
l_int|0
)paren
suffix:semicolon
id|s390irq_spin_unlock_irqrestore
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000000
)paren
suffix:semicolon
multiline_comment|/* 1000 ms */
id|s390irq_spin_lock_irqsave
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|count
op_eq
l_int|2
)paren
(brace
multiline_comment|/* give it a very last try ... */
id|disable_subchannel
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;free_irq(%04X) &quot;
l_string|&quot;- device %04X busy, retry &quot;
l_string|&quot;count exceeded&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|0
comma
l_string|&quot;free_irq(%04X) - device %04X busy, retry count exceeded&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
r_break
suffix:semicolon
multiline_comment|/* sigh, let&squot;s give up ... */
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
)brace
r_while
c_loop
(paren
id|ret
op_eq
op_minus
id|EBUSY
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.unready
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* deregister ended */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|nopfunc
op_assign
l_int|NULL
suffix:semicolon
id|s390irq_spin_unlock_irqrestore
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|s390irq_spin_unlock_irqrestore
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;free_irq(%04X) : error, &quot;
l_string|&quot;dev_id does not match !&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|0
comma
l_string|&quot;free_irq(%04X) : error, dev_id does not match !&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|s390irq_spin_unlock_irqrestore
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;free_irq(%04X) : error, &quot;
l_string|&quot;no action block ... !&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|0
comma
l_string|&quot;free_irq(%04X) : error, no action block ... !&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/*&n; * Generic enable/disable code&n; */
DECL|function|disable_irq
r_int
id|disable_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|SANITY_CHECK
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
l_string|&quot;disirq&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dbf_txt
comma
l_string|&quot;%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
)brace
id|s390irq_spin_lock_irqsave
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|disable_subchannel
c_func
(paren
id|irq
)paren
suffix:semicolon
id|s390irq_spin_unlock_irqrestore
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|enable_irq
r_int
id|enable_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|SANITY_CHECK
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
l_string|&quot;enirq&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dbf_txt
comma
l_string|&quot;%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
)brace
id|s390irq_spin_lock_irqsave
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|enable_subchannel
c_func
(paren
id|irq
)paren
suffix:semicolon
id|s390irq_spin_unlock_irqrestore
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Enable IRQ by modifying the subchannel&n; */
DECL|function|enable_subchannel
r_static
r_int
id|enable_subchannel
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|ccode
suffix:semicolon
r_int
id|retry
op_assign
l_int|5
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|SANITY_CHECK
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|2
comma
l_string|&quot;ensch&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dbf_txt
comma
l_string|&quot;%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|2
comma
id|dbf_txt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If a previous disable request is pending we reset it. However, this&n;&t; *  status implies that the device may (still) be not-operational.&n;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.d_disable
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.d_disable
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ccode
op_assign
id|stsch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccode
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.ena
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_eq
id|cons_dev
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.isc
op_assign
l_int|7
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.isc
op_assign
l_int|3
suffix:semicolon
)brace
multiline_comment|/* endif */
r_do
(brace
id|ccode
op_assign
id|msch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* ok */
id|ret
op_assign
l_int|0
suffix:semicolon
id|retry
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* status pending */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|1
suffix:semicolon
id|s390_process_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* might be overwritten */
multiline_comment|/* ... on re-driving    */
multiline_comment|/* ... the msch()       */
id|retry
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* busy */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* allow for recovery */
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
id|retry
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* not oper */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|retry
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|retry
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Disable IRQ by modifying the subchannel&n; */
DECL|function|disable_subchannel
r_static
r_int
id|disable_subchannel
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|cc
suffix:semicolon
multiline_comment|/* condition code */
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* function return value */
r_int
id|retry
op_assign
l_int|5
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|SANITY_CHECK
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
)paren
(brace
multiline_comment|/*&n;&t;&t; * the disable function must not be called while there are&n;&t;&t; *  requests pending for completion !&n;&t;&t; */
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|2
comma
l_string|&quot;dissch&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dbf_txt
comma
l_string|&quot;%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|2
comma
id|dbf_txt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If device isn&squot;t operational we have to perform delayed&n;&t;&t; *  disabling when the next interrupt occurs - unless the&n;&t;&t; *  irq is re-requested prior to the interrupt to occur.&n;&t;&t; */
id|cc
op_assign
id|stsch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cc
op_eq
l_int|3
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.d_disable
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
singleline_comment|// cc == 0
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.ena
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|cc
op_assign
id|msch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cc
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* ok */
id|retry
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* status pending */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|1
suffix:semicolon
id|s390_process_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* might be overwritten  */
multiline_comment|/* ... on re-driving the */
multiline_comment|/* ... msch() call       */
id|retry
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* busy; this should not happen! */
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;disable_subchannel(%04X) &quot;
l_string|&quot;- unexpected busy condition for &quot;
l_string|&quot;device %04X received !&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|0
comma
l_string|&quot;disable_subchannel(%04X) - unexpected busy condition for device %04X received !&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
id|retry
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* not oper */
multiline_comment|/*&n;&t;&t;&t;&t;&t; * should hardly occur ?!&n;&t;&t;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.d_disable
op_assign
l_int|1
suffix:semicolon
id|retry
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* if the device has gone we */
multiline_comment|/* ... don&squot;t need to disable */
multiline_comment|/* ... it anymore !          */
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
)brace
r_while
c_loop
(paren
id|retry
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_return
id|ret
suffix:semicolon
)brace
DECL|function|s390_init_IRQ
r_void
id|s390_init_IRQ
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* PSW flags */
r_int
id|cr6
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|8
)paren
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;STCK %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|irq_IPL_TOD
)paren
)paren
suffix:semicolon
id|p_init_schib
op_assign
id|alloc_bootmem_low
c_func
(paren
r_sizeof
(paren
id|schib_t
)paren
)paren
suffix:semicolon
id|p_init_irb
op_assign
id|alloc_bootmem_low
c_func
(paren
r_sizeof
(paren
id|irb_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * As we don&squot;t know about the calling environment&n;&t; *  we assure running disabled. Before leaving the&n;&t; *  function we resestablish the old environment.&n;&t; *&n;&t; * Note : as we don&squot;t need a system wide lock, therefore&n;&t; *        we shouldn&squot;t use cli(), but __cli() as this&n;&t; *        affects the current CPU only.&n;&t; */
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * disable all interrupts&n;&t; */
id|cr6
op_assign
l_int|0
suffix:semicolon
id|__ctl_load
c_func
(paren
id|cr6
comma
l_int|6
comma
l_int|6
)paren
suffix:semicolon
id|s390_process_subchannels
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_count_irqs
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
id|s390_irq_count
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * enable default I/O-interrupt sublass 3&n;&t; */
id|cr6
op_assign
l_int|0x10000000
suffix:semicolon
id|__ctl_load
c_func
(paren
id|cr6
comma
l_int|6
comma
l_int|6
)paren
suffix:semicolon
id|s390_device_recognition_all
c_func
(paren
)paren
suffix:semicolon
id|init_IRQ_complete
op_assign
l_int|1
suffix:semicolon
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * dummy handler, used during init_IRQ() processing for compatibility only&n; */
DECL|function|init_IRQ_handler
r_void
id|init_IRQ_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* this is a dummy handler only ... */
)brace
DECL|function|s390_start_IO
r_int
id|s390_start_IO
c_func
(paren
r_int
id|irq
comma
multiline_comment|/* IRQ */
id|ccw1_t
op_star
id|cpa
comma
multiline_comment|/* logical channel prog addr */
r_int
r_int
id|user_intparm
comma
multiline_comment|/* interruption parameter */
id|__u8
id|lpm
comma
multiline_comment|/* logical path mask */
r_int
r_int
id|flag
)paren
multiline_comment|/* flags */
(brace
r_int
id|ccode
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_char
id|buffer
(braket
l_int|80
)braket
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|SANITY_CHECK
c_func
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The flag usage is mutal exclusive ...&n;&t; */
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|DOIO_EARLY_NOTIFICATION
)paren
op_logical_and
(paren
id|flag
op_amp
id|DOIO_REPORT_ALL
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
l_string|&quot;stIO&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dbf_txt
comma
l_string|&quot;%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * setup ORB&n;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.intparm
op_assign
(paren
id|__u32
)paren
(paren
r_int
)paren
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|u_intparm
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.fmt
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.pfch
op_assign
op_logical_neg
(paren
id|flag
op_amp
id|DOIO_DENY_PREFETCH
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.spnd
op_assign
(paren
id|flag
op_amp
id|DOIO_ALLOW_SUSPEND
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.ssic
op_assign
(paren
(paren
id|flag
op_amp
id|DOIO_ALLOW_SUSPEND
)paren
op_logical_and
(paren
id|flag
op_amp
id|DOIO_SUPPRESS_INTER
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_VALID_LPM
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.lpm
op_assign
id|lpm
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.lpm
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
suffix:semicolon
)brace
multiline_comment|/* endif */
macro_line|#ifdef CONFIG_ARCH_S390X
multiline_comment|/* &n;&t; * for 64 bit we always support 64 bit IDAWs with 4k page size only&n;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.c64
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.i2k
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.cpa
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
c_func
(paren
id|cpa
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If sync processing was requested we lock the sync ISC, modify the&n;&t; *  device to present interrupts for this ISC only and switch the&n;&t; *  CPU to handle this ISC + the console ISC exclusively.&n;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
(brace
id|ret
op_assign
id|enable_cpu_sync_isc
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_DONT_CALL_INTHDLR
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repnone
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t; * Issue &quot;Start subchannel&quot; and process condition code&n;&t; */
id|ccode
op_assign
id|ssch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4sense
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * init the device driver specific devstat irb area&n;&t;&t;&t; *&n;&t;&t;&t; * Note : don&#xfffd;t clear saved irb info in case of sense !&n;&t;&t;&t; */
id|memset
c_func
(paren
op_amp
(paren
(paren
id|devstat_t
op_star
)paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
)paren
op_member_access_from_pointer
id|ii.irb
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|irb_t
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
id|memset
c_func
(paren
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|irb_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * initialize device status information&n;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|u_intparm
op_assign
id|user_intparm
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.cstat
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.dstat
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.lpum
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_assign
id|DEVSTAT_START_FUNCTION
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.scnt
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check for either early (FAST) notification requests&n;&t;&t; *  or if we are to return all interrupt info.&n;&t;&t; * Default is to call IRQ handler at secondary status only&n;&t;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_EARLY_NOTIFICATION
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_REPORT_ALL
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ulpm
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.lpm
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If synchronous I/O processing is requested, we have&n;&t;&t; *  to wait for the corresponding interrupt to occur by&n;&t;&t; *  polling the interrupt condition. However, as multiple&n;&t;&t; *  interrupts may be outstanding, we must not just wait&n;&t;&t; *  for the first interrupt, but must poll until ours&n;&t;&t; *  pops up.&n;&t;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
(brace
id|psw_t
id|io_new_psw
suffix:semicolon
r_int
id|ccode
suffix:semicolon
r_uint64
id|time_start
suffix:semicolon
r_uint64
id|time_curr
suffix:semicolon
r_int
id|ready
op_assign
l_int|0
suffix:semicolon
r_int
id|io_sub
op_assign
op_minus
l_int|1
suffix:semicolon
r_struct
id|_lowcore
op_star
id|lc
op_assign
l_int|NULL
suffix:semicolon
r_int
id|do_retry
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We shouldn&squot;t perform a TPI loop, waiting for an&n;&t;&t;&t; *  interrupt to occur, but should load a WAIT PSW&n;&t;&t;&t; *  instead. Otherwise we may keep the channel subsystem&n;&t;&t;&t; *  busy, not able to present the interrupt. When our&n;&t;&t;&t; *  sync. interrupt arrived we reset the I/O old PSW to&n;&t;&t;&t; *  its original value.&n;&t;&t;&t; */
id|memcpy
c_func
(paren
op_amp
id|io_new_psw
comma
op_amp
id|lc-&gt;io_new_psw
comma
r_sizeof
(paren
id|psw_t
)paren
)paren
suffix:semicolon
id|ccode
op_assign
id|iac
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
singleline_comment|// primary-space
id|io_sync_wait.mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_PRIM_SPACE_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
singleline_comment|// secondary-space
id|io_sync_wait.mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_SEC_SPACE_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
singleline_comment|// access-register
id|io_sync_wait.mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_ACC_REG_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
singleline_comment|// home-space&t;
id|io_sync_wait.mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_HOME_SPACE_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;start_IO() : unexpected &quot;
l_string|&quot;address-space-control %d&bslash;n&quot;
comma
id|ccode
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
id|io_sync_wait.addr
op_assign
id|FIX_PSW
c_func
(paren
op_logical_and
id|io_wakeup
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Martin didn&squot;t like modifying the new PSW, now we take&n;&t;&t;&t; *  a fast exit in do_IRQ() instead&n;&t;&t;&t; */
op_star
(paren
id|__u32
op_star
)paren
id|__LC_SYNC_IO_WORD
op_assign
l_int|1
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;STCK %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|time_start
)paren
)paren
suffix:semicolon
id|time_start
op_assign
id|time_start
op_rshift
l_int|32
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_TIMEOUT
)paren
(brace
id|tpi_info_t
id|tpi_info
op_assign
initialization_block
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|tpi
c_func
(paren
op_amp
id|tpi_info
)paren
op_eq
l_int|1
)paren
(brace
id|io_sub
op_assign
id|tpi_info.irq
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* usecs */
id|asm
r_volatile
(paren
l_string|&quot;STCK %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|time_curr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|time_curr
op_rshift
l_int|32
)paren
op_minus
id|time_start
)paren
op_ge
l_int|3
)paren
id|do_retry
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_while
c_loop
(paren
id|do_retry
)paren
suffix:semicolon
)brace
r_else
(brace
id|__load_psw
c_func
(paren
id|io_sync_wait
)paren
suffix:semicolon
id|io_wakeup
suffix:colon
id|io_sub
op_assign
(paren
id|__u32
)paren
op_star
(paren
id|__u16
op_star
)paren
id|__LC_SUBCHANNEL_NR
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|do_retry
)paren
id|ready
op_assign
id|s390_process_IRQ
c_func
(paren
id|io_sub
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * surrender when retry count&squot;s exceeded ...&n;&t;&t;&t;&t; */
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|io_sub
op_eq
id|irq
)paren
op_logical_and
(paren
id|ready
op_eq
l_int|1
)paren
)paren
op_logical_and
id|do_retry
)paren
suffix:semicolon
op_star
(paren
id|__u32
op_star
)paren
id|__LC_SYNC_IO_WORD
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|do_retry
)paren
id|ret
op_assign
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
multiline_comment|/* endif */
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* status pending */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_assign
id|DEVSTAT_START_FUNCTION
op_or
id|DEVSTAT_STATUS_PENDING
suffix:semicolon
multiline_comment|/*&n;&t;&t; * initialize the device driver specific devstat irb area&n;&t;&t; */
id|memset
c_func
(paren
op_amp
(paren
(paren
id|devstat_t
op_star
)paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
)paren
op_member_access_from_pointer
id|ii.irb
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|irb_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Let the common interrupt handler process the pending status.&n;&t;&t; *  However, we must avoid calling the user action handler, as&n;&t;&t; *  it won&squot;t be prepared to handle a pending status during&n;&t;&t; *  do_IO() processing inline. This also implies that process_IRQ&n;&t;&t; *  must terminate synchronously - especially if device sensing&n;&t;&t; *  is required.&n;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
op_assign
l_int|1
suffix:semicolon
id|s390_process_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4final
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_FINAL_STATUS
suffix:semicolon
multiline_comment|/*&n;&t;&t; * In multipath mode a condition code 3 implies the last path&n;&t;&t; *  has gone, except we have previously restricted the I/O to&n;&t;&t; *  a particular path. A condition code 1 (0 won&squot;t occur)&n;&t;&t; *  results in return code EIO as well as 3 with another path&n;&t;&t; *  than the one used (i.e. path available mask is non-zero).&n;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.scsw.cc
op_eq
l_int|3
)paren
(brace
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_VALID_LPM
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_and_assign
op_complement
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.esw.esw1.lpum
)paren
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* endif */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_NOT_OPER
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_IO
(brace
id|stsch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;s390_start_IO(%04X) - irb for &quot;
l_string|&quot;device %04X, after status pending&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
id|s390_displayhex
c_func
(paren
id|buffer
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb
)paren
comma
r_sizeof
(paren
id|irb_t
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;s390_start_IO(%04X) - schib for &quot;
l_string|&quot;device %04X, after status pending&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
id|s390_displayhex
c_func
(paren
id|buffer
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
comma
r_sizeof
(paren
id|schib_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_amp
id|DEVSTAT_FLAG_SENSE_AVAIL
)paren
(brace
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;s390_start_IO(%04X) - sense &quot;
l_string|&quot;data for &quot;
l_string|&quot;device %04X, after status pending&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
id|s390_displayhex
c_func
(paren
id|buffer
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id-&gt;ii.sense.data
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id-&gt;rescnt
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|stsch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;s390_start_IO(%04X) - irb for &quot;
l_string|&quot;device %04X, after status pending&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
id|s390_displayhex2
c_func
(paren
id|buffer
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb
)paren
comma
r_sizeof
(paren
id|irb_t
)paren
comma
l_int|2
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;s390_start_IO(%04X) - schib for &quot;
l_string|&quot;device %04X, after status pending&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
id|s390_displayhex2
c_func
(paren
id|buffer
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
comma
r_sizeof
(paren
id|schib_t
)paren
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_amp
id|DEVSTAT_FLAG_SENSE_AVAIL
)paren
(brace
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;s390_start_IO(%04X) - sense &quot;
l_string|&quot;data for &quot;
l_string|&quot;device %04X, after status pending&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
id|s390_displayhex2
c_func
(paren
id|buffer
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id-&gt;ii.sense.data
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id-&gt;rescnt
comma
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_and_assign
op_complement
id|DEVSTAT_NOT_OPER
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* busy */
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* device/path not operational */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_VALID_LPM
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_and_assign
op_complement
id|lpm
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_eq
l_int|0
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_NOT_OPER
suffix:semicolon
)brace
multiline_comment|/* endif */
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|memcpy
c_func
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat
)paren
comma
r_sizeof
(paren
id|devstat_t
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_IO
id|stsch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;s390_start_IO(%04X) - schib for &quot;
l_string|&quot;device %04X, after &squot;not oper&squot; status&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
id|s390_displayhex
c_func
(paren
id|buffer
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
comma
r_sizeof
(paren
id|schib_t
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|stsch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;s390_start_IO(%04X) - schib for &quot;
l_string|&quot;device %04X, after &squot;not oper&squot; status&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
id|s390_displayhex2
c_func
(paren
id|buffer
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
comma
r_sizeof
(paren
id|schib_t
)paren
comma
l_int|2
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
(brace
id|disable_cpu_sync_isc
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_DONT_CALL_INTHDLR
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repnone
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|ret
suffix:semicolon
)brace
DECL|function|do_IO
r_int
id|do_IO
c_func
(paren
r_int
id|irq
comma
multiline_comment|/* IRQ */
id|ccw1_t
op_star
id|cpa
comma
multiline_comment|/* channel program address */
r_int
r_int
id|user_intparm
comma
multiline_comment|/* interruption parameter */
id|__u8
id|lpm
comma
multiline_comment|/* logical path mask */
r_int
r_int
id|flag
)paren
multiline_comment|/* flags : see above */
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|SANITY_CHECK
c_func
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/* handler registered ? or free_irq() in process already ? */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
op_logical_or
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.unready
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
l_string|&quot;doIO&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dbf_txt
comma
l_string|&quot;%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Note: We ignore the device operational status - if not operational,&n;&t; *        the SSCH will lead to an -ENODEV condition ...&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
)paren
multiline_comment|/* last I/O completed ? */
(brace
id|ret
op_assign
id|s390_start_IO
c_func
(paren
id|irq
comma
id|cpa
comma
id|user_intparm
comma
id|lpm
comma
id|flag
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
)paren
(brace
multiline_comment|/*&n;&t;&t; * If primary status was received and ending status is missing,&n;&t;&t; *  the device driver won&squot;t be notified on the ending status&n;&t;&t; *  if early (fast) interrupt notification was requested.&n;&t;&t; *  Therefore we have to queue the next incoming request. If&n;&t;&t; *  halt_IO() is issued while there is a request queued, a HSCH&n;&t;&t; *  needs to be issued and the queued request must be deleted&n;&t;&t; *  but its intparm must be returned (see halt_IO() processing)&n;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4final
op_logical_and
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio_q
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qflag
op_assign
id|flag
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qcpa
op_assign
id|cpa
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qintparm
op_assign
id|user_intparm
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qlpm
op_assign
id|lpm
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * resume suspended I/O operation&n; */
DECL|function|resume_IO
r_int
id|resume_IO
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|SANITY_CHECK
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
l_string|&quot;resIO&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dbf_txt
comma
l_string|&quot;%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We allow for &squot;resume&squot; requests only for active I/O operations&n;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
)paren
(brace
r_int
id|ccode
suffix:semicolon
id|ccode
op_assign
id|rsch
c_func
(paren
id|irq
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|s390_process_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * useless to wait for request completion&n;&t;&t;&t; *  as device is no longer operational !&n;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
)brace
multiline_comment|/* endif  */
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Note: The &quot;intparm&quot; parameter is not used by the halt_IO() function&n; *       itself, as no ORB is built for the HSCH instruction. However,&n; *       it allows the device interrupt handler to associate the upcoming&n; *       interrupt with the halt_IO() request.&n; */
DECL|function|halt_IO
r_int
id|halt_IO
c_func
(paren
r_int
id|irq
comma
r_int
r_int
id|user_intparm
comma
r_int
r_int
id|flag
)paren
multiline_comment|/* possible DOIO_WAIT_FOR_INTERRUPT */
(brace
r_int
id|ret
suffix:semicolon
r_int
id|ccode
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|SANITY_CHECK
c_func
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we only allow for halt_IO if the device has an I/O handler associated&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we ignore the halt_io() request if ending_status was received but&n;&t; *  a SENSE operation is waiting for completion.&n;&t; */
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4sense
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n;&t; * We don&squot;t allow for halt_io with a sync do_IO() requests pending.&n;&t; */
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.syncio
op_logical_and
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
macro_line|#endif
r_else
(brace
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|2
comma
l_string|&quot;haltIO&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dbf_txt
comma
l_string|&quot;%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|2
comma
id|dbf_txt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If sync processing was requested we lock the sync ISC,&n;&t;&t; *  modify the device to present interrupts for this ISC only&n;&t;&t; *  and switch the CPU to handle this ISC + the console ISC&n;&t;&t; *  exclusively.&n;&t;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
(brace
id|ret
op_assign
id|enable_cpu_sync_isc
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t; * Issue &quot;Halt subchannel&quot; and process condition code&n;&t;&t; */
id|ccode
op_assign
id|hsch
c_func
(paren
id|irq
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.haltio
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|u_intparm
op_assign
id|user_intparm
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.cstat
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.dstat
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.lpum
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_assign
id|DEVSTAT_HALT_FUNCTION
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.scnt
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_HALT_FUNCTION
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t;&t; * If synchronous I/O processing is requested, we have&n;&t;&t;&t; *  to wait for the corresponding interrupt to occur by&n;&t;&t;&t; *  polling the interrupt condition. However, as multiple&n;&t;&t;&t; *  interrupts may be outstanding, we must not just wait&n;&t;&t;&t; *  for the first interrupt, but must poll until ours&n;&t;&t;&t; *  pops up.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
(brace
r_int
id|io_sub
suffix:semicolon
id|__u32
id|io_parm
suffix:semicolon
id|psw_t
id|io_new_psw
suffix:semicolon
r_int
id|ccode
suffix:semicolon
r_int
id|ready
op_assign
l_int|0
suffix:semicolon
r_struct
id|_lowcore
op_star
id|lc
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * We shouldn&squot;t perform a TPI loop, waiting for&n;&t;&t;&t;&t; *  an interrupt to occur, but should load a&n;&t;&t;&t;&t; *  WAIT PSW instead. Otherwise we may keep the&n;&t;&t;&t;&t; *  channel subsystem busy, not able to present&n;&t;&t;&t;&t; *  the interrupt. When our sync. interrupt&n;&t;&t;&t;&t; *  arrived we reset the I/O old PSW to its&n;&t;&t;&t;&t; *  original value.&n;&t;&t;&t;&t; */
id|memcpy
c_func
(paren
op_amp
id|io_new_psw
comma
op_amp
id|lc-&gt;io_new_psw
comma
r_sizeof
(paren
id|psw_t
)paren
)paren
suffix:semicolon
id|ccode
op_assign
id|iac
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
singleline_comment|// primary-space
id|io_sync_wait.mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_PRIM_SPACE_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
singleline_comment|// secondary-space
id|io_sync_wait.mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_SEC_SPACE_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
singleline_comment|// access-register
id|io_sync_wait.mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_ACC_REG_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
singleline_comment|// home-space&t;
id|io_sync_wait.mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_HOME_SPACE_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;halt_IO() : unexpected &quot;
l_string|&quot;address-space-control %d&bslash;n&quot;
comma
id|ccode
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
id|io_sync_wait.addr
op_assign
id|FIX_PSW
c_func
(paren
op_logical_and
id|hio_wakeup
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Martin didn&squot;t like modifying the new PSW, now we take&n;&t;&t;&t;&t; *  a fast exit in do_IRQ() instead&n;&t;&t;&t;&t; */
op_star
(paren
id|__u32
op_star
)paren
id|__LC_SYNC_IO_WORD
op_assign
l_int|1
suffix:semicolon
r_do
(brace
id|__load_psw
c_func
(paren
id|io_sync_wait
)paren
suffix:semicolon
id|hio_wakeup
suffix:colon
id|io_parm
op_assign
op_star
(paren
id|__u32
op_star
)paren
id|__LC_IO_INT_PARM
suffix:semicolon
id|io_sub
op_assign
(paren
id|__u32
)paren
op_star
(paren
id|__u16
op_star
)paren
id|__LC_SUBCHANNEL_NR
suffix:semicolon
id|ready
op_assign
id|s390_process_IRQ
c_func
(paren
id|io_sub
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|io_sub
op_eq
id|irq
)paren
op_logical_and
(paren
id|ready
op_eq
l_int|1
)paren
)paren
)paren
suffix:semicolon
op_star
(paren
id|__u32
op_star
)paren
id|__LC_SYNC_IO_WORD
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* status pending */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_STATUS_PENDING
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * initialize the device driver specific devstat irb area&n;&t;&t;&t; */
id|memset
c_func
(paren
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id-&gt;ii.irb
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|irb_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Let the common interrupt handler process the pending&n;&t;&t;&t; *  status. However, we must avoid calling the user&n;&t;&t;&t; *  action handler, as it won&squot;t be prepared to handle&n;&t;&t;&t; *  a pending status during do_IO() processing inline.&n;&t;&t;&t; *  This also implies that s390_process_IRQ must&n;&t;&t;&t; *  terminate synchronously - especially if device&n;&t;&t;&t; *  sensing is required.&n;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
op_assign
l_int|1
suffix:semicolon
id|s390_process_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4final
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_FINAL_STATUS
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * In multipath mode a condition code 3 implies the last&n;&t;&t;&t; *  path has gone, except we have previously restricted&n;&t;&t;&t; *  the I/O to a particular path. A condition code 1&n;&t;&t;&t; *  (0 won&squot;t occur) results in return code EIO as well&n;&t;&t;&t; *  as 3 with another path than the one used (i.e. path available mask is non-zero).&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.scsw.cc
op_eq
l_int|3
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_NOT_OPER
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_and_assign
op_complement
id|DEVSTAT_NOT_OPER
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* busy */
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* device not operational */
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
(brace
id|disable_cpu_sync_isc
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Note: The &quot;intparm&quot; parameter is not used by the clear_IO() function&n; *       itself, as no ORB is built for the CSCH instruction. However,&n; *       it allows the device interrupt handler to associate the upcoming&n; *       interrupt with the clear_IO() request.&n; */
DECL|function|clear_IO
r_int
id|clear_IO
c_func
(paren
r_int
id|irq
comma
r_int
r_int
id|user_intparm
comma
r_int
r_int
id|flag
)paren
multiline_comment|/* possible DOIO_WAIT_FOR_INTERRUPT */
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|ccode
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|SANITY_CHECK
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we only allow for clear_IO if the device has an I/O handler associated&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we ignore the clear_io() request if ending_status was received but&n;&t; *  a SENSE operation is waiting for completion.&n;&t; */
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4sense
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n;&t; * We don&squot;t allow for clear_io with a sync do_IO() requests pending.&n;&t; *  Concurrent I/O is possible in SMP environments only, but the&n;&t; *  sync. I/O request can be gated to one CPU at a time only.&n;&t; */
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.syncio
)paren
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
macro_line|#endif
r_else
(brace
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|2
comma
l_string|&quot;clearIO&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dbf_txt
comma
l_string|&quot;%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|2
comma
id|dbf_txt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If sync processing was requested we lock the sync ISC,&n;&t;&t; *  modify the device to present interrupts for this ISC only&n;&t;&t; *  and switch the CPU to handle this ISC + the console ISC&n;&t;&t; *  exclusively.&n;&t;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
(brace
id|ret
op_assign
id|enable_cpu_sync_isc
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t; * Issue &quot;Clear subchannel&quot; and process condition code&n;&t;&t; */
id|ccode
op_assign
id|csch
c_func
(paren
id|irq
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.haltio
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|u_intparm
op_assign
id|user_intparm
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.cstat
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.dstat
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.lpum
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_assign
id|DEVSTAT_CLEAR_FUNCTION
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.scnt
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_CLEAR_FUNCTION
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t;&t; * If synchronous I/O processing is requested, we have&n;&t;&t;&t; *  to wait for the corresponding interrupt to occur by&n;&t;&t;&t; *  polling the interrupt condition. However, as multiple&n;&t;&t;&t; *  interrupts may be outstanding, we must not just wait&n;&t;&t;&t; *  for the first interrupt, but must poll until ours&n;&t;&t;&t; *  pops up.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
(brace
r_int
id|io_sub
suffix:semicolon
id|__u32
id|io_parm
suffix:semicolon
id|psw_t
id|io_new_psw
suffix:semicolon
r_int
id|ccode
suffix:semicolon
r_int
id|ready
op_assign
l_int|0
suffix:semicolon
r_struct
id|_lowcore
op_star
id|lc
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * We shouldn&squot;t perform a TPI loop, waiting for&n;&t;&t;&t;&t; *  an interrupt to occur, but should load a&n;&t;&t;&t;&t; *  WAIT PSW instead. Otherwise we may keep the&n;&t;&t;&t;&t; *  channel subsystem busy, not able to present&n;&t;&t;&t;&t; *  the interrupt. When our sync. interrupt&n;&t;&t;&t;&t; *  arrived we reset the I/O old PSW to its&n;&t;&t;&t;&t; *  original value.&n;&t;&t;&t;&t; */
id|memcpy
c_func
(paren
op_amp
id|io_new_psw
comma
op_amp
id|lc-&gt;io_new_psw
comma
r_sizeof
(paren
id|psw_t
)paren
)paren
suffix:semicolon
id|ccode
op_assign
id|iac
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
singleline_comment|// primary-space
id|io_sync_wait.mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_PRIM_SPACE_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
singleline_comment|// secondary-space
id|io_sync_wait.mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_SEC_SPACE_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
singleline_comment|// access-register
id|io_sync_wait.mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_ACC_REG_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
singleline_comment|// home-space&t;
id|io_sync_wait.mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_HOME_SPACE_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;clear_IO() : unexpected &quot;
l_string|&quot;address-space-control %d&bslash;n&quot;
comma
id|ccode
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
id|io_sync_wait.addr
op_assign
id|FIX_PSW
c_func
(paren
op_logical_and
id|cio_wakeup
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Martin didn&squot;t like modifying the new PSW, now we take&n;&t;&t;&t;&t; *  a fast exit in do_IRQ() instead&n;&t;&t;&t;&t; */
op_star
(paren
id|__u32
op_star
)paren
id|__LC_SYNC_IO_WORD
op_assign
l_int|1
suffix:semicolon
r_do
(brace
id|__load_psw
c_func
(paren
id|io_sync_wait
)paren
suffix:semicolon
id|cio_wakeup
suffix:colon
id|io_parm
op_assign
op_star
(paren
id|__u32
op_star
)paren
id|__LC_IO_INT_PARM
suffix:semicolon
id|io_sub
op_assign
(paren
id|__u32
)paren
op_star
(paren
id|__u16
op_star
)paren
id|__LC_SUBCHANNEL_NR
suffix:semicolon
id|ready
op_assign
id|s390_process_IRQ
c_func
(paren
id|io_sub
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|io_sub
op_eq
id|irq
)paren
op_logical_and
(paren
id|ready
op_eq
l_int|1
)paren
)paren
)paren
suffix:semicolon
op_star
(paren
id|__u32
op_star
)paren
id|__LC_SYNC_IO_WORD
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* no status pending for csh */
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* no busy for csh*/
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* device not operational */
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
(brace
id|disable_cpu_sync_isc
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * do_IRQ() handles all normal I/O device IRQ&squot;s (the special&n; *          SMP cross-CPU interrupts have their own specific&n; *          handlers).&n; *&n; */
DECL|function|do_IRQ
id|asmlinkage
r_void
id|do_IRQ
c_func
(paren
r_struct
id|pt_regs
id|regs
)paren
(brace
multiline_comment|/*&n;&t; * Get interrupt info from lowcore&n;&t; */
r_volatile
id|tpi_info_t
op_star
id|tpi_info
op_assign
(paren
id|tpi_info_t
op_star
)paren
(paren
id|__LC_SUBCHANNEL_ID
)paren
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * take fast exit if CPU is in sync. I/O state&n;&t; *&n;&t; * Note: we have to turn off the WAIT bit and re-disable&n;&t; *       interrupts prior to return as this was the initial&n;&t; *       entry condition to synchronous I/O.&n;&t; */
r_if
c_cond
(paren
op_star
(paren
id|__u32
op_star
)paren
id|__LC_SYNC_IO_WORD
)paren
(brace
id|regs.psw.mask
op_and_assign
op_complement
(paren
id|_PSW_WAIT_MASK_BIT
op_or
id|_PSW_IO_MASK_BIT
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* endif */
macro_line|#ifdef CONFIG_FAST_IRQ
r_do
(brace
macro_line|#endif /*  CONFIG_FAST_IRQ */
multiline_comment|/*&n;&t;&t; * Non I/O-subchannel thin interrupts are processed differently&n;&t;&t; */
r_if
c_cond
(paren
id|tpi_info-&gt;adapter_IO
op_eq
l_int|1
op_logical_and
id|tpi_info-&gt;int_type
op_eq
id|IO_INTERRUPT_TYPE
)paren
(brace
id|irq_enter
c_func
(paren
id|cpu
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|do_adapter_IO
c_func
(paren
id|tpi_info-&gt;intparm
)paren
suffix:semicolon
id|irq_exit
c_func
(paren
id|cpu
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|irq
op_assign
id|tpi_info-&gt;irq
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * fix me !!!&n;&t;&t;&t; *&n;&t;&t;&t; * instead of boxing the device, we need to schedule device&n;&t;&t;&t; * recognition, the interrupt stays pending. We need to&n;&t;&t;&t; * dynamically allocate an ioinfo structure, etc..&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
(brace
r_return
suffix:semicolon
multiline_comment|/* this keeps the device boxed ... */
)brace
id|irq_enter
c_func
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
id|s390irq_spin_lock
c_func
(paren
id|irq
)paren
suffix:semicolon
id|s390_process_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
id|s390irq_spin_unlock
c_func
(paren
id|irq
)paren
suffix:semicolon
id|irq_exit
c_func
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_FAST_IRQ
multiline_comment|/*&n;&t;&t; * Are more interrupts pending?&n;&t;&t; * If so, the tpi instruction will update the lowcore &n;&t;&t; * to hold the info for the next interrupt.&n;&t;&t; */
)brace
r_while
c_loop
(paren
id|tpi
c_func
(paren
l_int|NULL
)paren
op_ne
l_int|0
)paren
suffix:semicolon
macro_line|#endif /*  CONFIG_FAST_IRQ */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * s390_process_IRQ() handles status pending situations and interrupts&n; *&n; * Called by : do_IRQ()             - for &quot;real&quot; interrupts&n; *             s390_start_IO, halt_IO()&n; *                                  - status pending cond. after SSCH, or HSCH&n; *             disable_subchannel() - status pending conditions (after MSCH)&n; *&n; * Returns: 0 - no ending status received, no further action taken&n; *          1 - interrupt handler was called with ending status&n; */
DECL|function|s390_process_IRQ
r_int
id|s390_process_IRQ
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|ccode
suffix:semicolon
multiline_comment|/* cond code from tsch() operation */
r_int
id|irb_cc
suffix:semicolon
multiline_comment|/* cond code from irb */
r_int
id|sdevstat
suffix:semicolon
multiline_comment|/* struct devstat size to copy */
r_int
r_int
id|fctl
suffix:semicolon
multiline_comment|/* function control */
r_int
r_int
id|stctl
suffix:semicolon
multiline_comment|/* status   control */
r_int
r_int
id|actl
suffix:semicolon
multiline_comment|/* activity control */
r_int
id|issense
op_assign
l_int|0
suffix:semicolon
r_int
id|ending_status
op_assign
l_int|0
suffix:semicolon
r_int
id|allow4handler
op_assign
l_int|1
suffix:semicolon
r_int
id|chnchk
op_assign
l_int|0
suffix:semicolon
id|devstat_t
op_star
id|dp
suffix:semicolon
id|devstat_t
op_star
id|udp
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
r_char
id|buffer
(braket
l_int|80
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cio_count_irqs
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|s390_irq_count
(braket
id|cpu
)braket
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|3
comma
l_string|&quot;procIRQ&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dbf_txt
comma
l_string|&quot;%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|3
comma
id|dbf_txt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
(brace
multiline_comment|/* we can&squot;t properly process the interrupt ... */
id|tsch
c_func
(paren
id|irq
comma
id|p_init_irb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
id|dp
op_assign
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat
suffix:semicolon
id|udp
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
suffix:semicolon
multiline_comment|/*&n;&t; * It might be possible that a device was not-oper. at the time&n;&t; *  of free_irq() processing. This means the handler is no longer&n;&t; *  available when the device possibly becomes ready again. In&n;&t; *  this case we perform delayed disable_subchannel() processing.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.d_disable
)paren
(brace
macro_line|#ifdef CONFIG_DEBUG_IO
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;s390_process_IRQ(%04X) &quot;
l_string|&quot;- no interrupt handler registered &quot;
l_string|&quot;for device %04X !&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_DEBUG_IO */
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|0
comma
l_string|&quot;s390_process_IRQ(%04X) - no interrupt handler registered for device %04X !&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t; * retrieve the i/o interrupt information (irb),&n;&t; *  update the device specific status information&n;&t; *  and possibly call the interrupt handler.&n;&t; *&n;&t; * Note 1: At this time we don&squot;t process the resulting&n;&t; *         condition code (ccode) from tsch(), although&n;&t; *         we probably should.&n;&t; *&n;&t; * Note 2: Here we will have to check for channel&n;&t; *         check conditions and call a channel check&n;&t; *         handler.&n;&t; *&n;&t; * Note 3: If a start function was issued, the interruption&n;&t; *         parameter relates to it. If a halt function was&n;&t; *         issued for an idle device, the intparm must not&n;&t; *         be taken from lowcore, but from the devstat area.&n;&t; */
id|ccode
op_assign
id|tsch
c_func
(paren
id|irq
comma
op_amp
(paren
id|dp-&gt;ii.irb
)paren
)paren
suffix:semicolon
singleline_comment|//
singleline_comment|// We must only accumulate the status if the device is busy already
singleline_comment|//
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
)paren
(brace
id|dp-&gt;dstat
op_or_assign
id|dp-&gt;ii.irb.scsw.dstat
suffix:semicolon
id|dp-&gt;cstat
op_or_assign
id|dp-&gt;ii.irb.scsw.cstat
suffix:semicolon
id|dp-&gt;intparm
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|u_intparm
suffix:semicolon
)brace
r_else
(brace
id|dp-&gt;dstat
op_assign
id|dp-&gt;ii.irb.scsw.dstat
suffix:semicolon
id|dp-&gt;cstat
op_assign
id|dp-&gt;ii.irb.scsw.cstat
suffix:semicolon
id|dp-&gt;flag
op_assign
l_int|0
suffix:semicolon
singleline_comment|// reset status flags
id|dp-&gt;intparm
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
id|dp-&gt;lpum
op_assign
id|dp-&gt;ii.irb.esw.esw1.lpum
suffix:semicolon
multiline_comment|/*&n;&t; * reset device-busy bit if no longer set in irb&n;&t; */
r_if
c_cond
(paren
(paren
id|dp-&gt;dstat
op_amp
id|DEV_STAT_BUSY
)paren
op_logical_and
(paren
(paren
id|dp-&gt;ii.irb.scsw.dstat
op_amp
id|DEV_STAT_BUSY
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|dp-&gt;dstat
op_and_assign
op_complement
id|DEV_STAT_BUSY
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t; * Save residual count and CCW information in case primary and&n;&t; *  secondary status are presented with different interrupts.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;ii.irb.scsw.stctl
op_amp
(paren
id|SCSW_STCTL_PRIM_STATUS
op_or
id|SCSW_STCTL_INTER_STATUS
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * If the subchannel status shows status pending&n;&t;&t; * and we received a check condition, the count&n;&t;&t; * information is not meaningful.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|dp-&gt;ii.irb.scsw.stctl
op_amp
id|SCSW_STCTL_STATUS_PEND
)paren
op_logical_and
(paren
id|dp-&gt;ii.irb.scsw.cstat
op_amp
(paren
id|SCHN_STAT_CHN_DATA_CHK
op_or
id|SCHN_STAT_CHN_CTRL_CHK
op_or
id|SCHN_STAT_INTF_CTRL_CHK
op_or
id|SCHN_STAT_PROG_CHECK
op_or
id|SCHN_STAT_PROT_CHECK
op_or
id|SCHN_STAT_CHAIN_CHECK
)paren
)paren
)paren
)paren
(brace
id|dp-&gt;rescnt
op_assign
id|dp-&gt;ii.irb.scsw.count
suffix:semicolon
)brace
r_else
(brace
id|dp-&gt;rescnt
op_assign
id|SENSE_MAX_COUNT
suffix:semicolon
)brace
id|dp-&gt;cpa
op_assign
id|dp-&gt;ii.irb.scsw.cpa
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_IO
r_if
c_cond
(paren
id|irq
op_ne
id|cons_dev
)paren
id|printk
c_func
(paren
l_string|&quot;s390_process_IRQ( %04X ) : &quot;
l_string|&quot;residual count from irb after tsch() %d&bslash;n&quot;
comma
id|irq
comma
id|dp-&gt;rescnt
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|6
comma
l_string|&quot;s390_process_IRQ( %04X ) : residual count from irq after tsch() %d&bslash;n&quot;
comma
id|irq
comma
id|dp-&gt;rescnt
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
id|irb_cc
op_assign
id|dp-&gt;ii.irb.scsw.cc
suffix:semicolon
singleline_comment|//
singleline_comment|// check for any kind of channel or interface control check but don&squot;t
singleline_comment|//  issue the message for the console device
singleline_comment|//
r_if
c_cond
(paren
(paren
id|dp-&gt;ii.irb.scsw.cstat
op_amp
(paren
id|SCHN_STAT_CHN_DATA_CHK
op_or
id|SCHN_STAT_CHN_CTRL_CHK
op_or
id|SCHN_STAT_INTF_CTRL_CHK
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|irq
op_ne
id|cons_dev
)paren
id|printk
c_func
(paren
l_string|&quot;Channel-Check or Interface-Control-Check &quot;
l_string|&quot;received&bslash;n&quot;
l_string|&quot; ... device %04X on subchannel %04X, dev_stat &quot;
l_string|&quot;: %02X sch_stat : %02X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
comma
id|irq
comma
id|dp-&gt;dstat
comma
id|dp-&gt;cstat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|0
comma
l_string|&quot;Channel-Check or Interface-Control-Check received&bslash;n&quot;
)paren
suffix:semicolon
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|0
comma
l_string|&quot;... device %04X on subchannel %04X, dev_stat: %02X sch_stat: %02X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
comma
id|irq
comma
id|dp-&gt;dstat
comma
id|dp-&gt;cstat
)paren
suffix:semicolon
)brace
id|chnchk
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|dp-&gt;ii.irb.scsw.ectl
op_eq
l_int|0
)paren
(brace
id|issense
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|dp-&gt;ii.irb.scsw.stctl
op_eq
id|SCSW_STCTL_STATUS_PEND
)paren
op_logical_and
(paren
id|dp-&gt;ii.irb.scsw.eswf
op_eq
l_int|0
)paren
)paren
(brace
id|issense
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|dp-&gt;ii.irb.scsw.stctl
op_eq
(paren
id|SCSW_STCTL_STATUS_PEND
op_or
id|SCSW_STCTL_INTER_STATUS
)paren
)paren
op_logical_and
(paren
(paren
id|dp-&gt;ii.irb.scsw.actl
op_amp
id|SCSW_ACTL_SUSPENDED
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|issense
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|issense
op_assign
id|dp-&gt;ii.irb.esw.esw0.erw.cons
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|issense
)paren
(brace
id|dp-&gt;scnt
op_assign
id|dp-&gt;ii.irb.esw.esw0.erw.scnt
suffix:semicolon
id|dp-&gt;flag
op_or_assign
id|DEVSTAT_FLAG_SENSE_AVAIL
suffix:semicolon
id|sdevstat
op_assign
r_sizeof
(paren
id|devstat_t
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_IO
r_if
c_cond
(paren
id|irq
op_ne
id|cons_dev
)paren
id|printk
c_func
(paren
l_string|&quot;s390_process_IRQ( %04X ) : &quot;
l_string|&quot;concurrent sense bytes avail %d&bslash;n&quot;
comma
id|irq
comma
id|dp-&gt;scnt
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|4
comma
l_string|&quot;s390_process_IRQ( %04X ): concurrent sense bytes avail %d&bslash;n&quot;
comma
id|irq
comma
id|dp-&gt;scnt
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* don&squot;t copy the sense data area ! */
id|sdevstat
op_assign
r_sizeof
(paren
id|devstat_t
)paren
op_minus
id|SENSE_MAX_COUNT
suffix:semicolon
)brace
multiline_comment|/* endif */
r_switch
c_cond
(paren
id|irb_cc
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* status pending */
id|dp-&gt;flag
op_or_assign
id|DEVSTAT_STATUS_PENDING
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/* normal i/o interruption */
id|fctl
op_assign
id|dp-&gt;ii.irb.scsw.fctl
suffix:semicolon
id|stctl
op_assign
id|dp-&gt;ii.irb.scsw.stctl
suffix:semicolon
id|actl
op_assign
id|dp-&gt;ii.irb.scsw.actl
suffix:semicolon
r_if
c_cond
(paren
id|chnchk
)paren
(brace
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;s390_process_IRQ(%04X) - irb for &quot;
l_string|&quot;device %04X after channel check&bslash;n&quot;
comma
id|irq
comma
id|dp-&gt;devno
)paren
suffix:semicolon
id|s390_displayhex
c_func
(paren
id|buffer
comma
op_amp
(paren
id|dp-&gt;ii.irb
)paren
comma
r_sizeof
(paren
id|irb_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;s390_process_IRQ(%04X) - irb for &quot;
l_string|&quot;device %04X after channel check&bslash;n&quot;
comma
id|irq
comma
id|dp-&gt;devno
)paren
suffix:semicolon
id|s390_displayhex2
c_func
(paren
id|buffer
comma
op_amp
(paren
id|dp-&gt;ii.irb
)paren
comma
r_sizeof
(paren
id|irb_t
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* endif */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|stctl
op_or_assign
id|stctl
suffix:semicolon
id|ending_status
op_assign
(paren
id|stctl
op_amp
id|SCSW_STCTL_SEC_STATUS
)paren
op_logical_or
(paren
id|stctl
op_eq
(paren
id|SCSW_STCTL_ALERT_STATUS
op_or
id|SCSW_STCTL_STATUS_PEND
)paren
)paren
op_logical_or
(paren
(paren
id|fctl
op_eq
id|SCSW_FCTL_HALT_FUNC
)paren
op_logical_and
(paren
id|stctl
op_eq
id|SCSW_STCTL_STATUS_PEND
)paren
)paren
op_logical_or
(paren
(paren
id|fctl
op_eq
id|SCSW_FCTL_CLEAR_FUNC
)paren
op_logical_and
(paren
id|stctl
op_eq
id|SCSW_STCTL_STATUS_PEND
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check for unsolicited interrupts - for debug purposes only&n;&t;&t; *&n;&t;&t; * We only consider an interrupt as unsolicited, if the device was not&n;&t;&t; *  actively in use (busy) and an interrupt other than an ALERT status&n;&t;&t; *  was received.&n;&t;&t; *&n;&t;&t; * Note: We must not issue a message to the console, if the&n;&t;&t; *       unsolicited interrupt applies to the console device&n;&t;&t; *       itself !&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|stctl
op_amp
id|SCSW_STCTL_ALERT_STATUS
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_eq
l_int|0
)paren
)paren
(brace
macro_line|#ifdef CONFIG_DEBUG_IO
r_if
c_cond
(paren
id|irq
op_ne
id|cons_dev
)paren
id|printk
c_func
(paren
l_string|&quot;Unsolicited interrupt received for device %04X on subchannel %04X&bslash;n&quot;
l_string|&quot; ... device status : %02X subchannel status : %02X&bslash;n&quot;
comma
id|dp-&gt;devno
comma
id|irq
comma
id|dp-&gt;dstat
comma
id|dp-&gt;cstat
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;s390_process_IRQ(%04X) - irb for &quot;
l_string|&quot;device %04X, ending_status %d&bslash;n&quot;
comma
id|irq
comma
id|dp-&gt;devno
comma
id|ending_status
)paren
suffix:semicolon
id|s390_displayhex
c_func
(paren
id|buffer
comma
op_amp
(paren
id|dp-&gt;ii.irb
)paren
comma
r_sizeof
(paren
id|irb_t
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|2
comma
l_string|&quot;Unsolicited interrupt received for device %04X on subchannel %04X&bslash;n&quot;
l_string|&quot; ... device status : %02X subchannel status : %02X&bslash;n&quot;
comma
id|dp-&gt;devno
comma
id|irq
comma
id|dp-&gt;dstat
comma
id|dp-&gt;cstat
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;s390_process_IRQ(%04X) - irb for &quot;
l_string|&quot;device %04X, ending_status %d&bslash;n&quot;
comma
id|irq
comma
id|dp-&gt;devno
comma
id|ending_status
)paren
suffix:semicolon
id|s390_displayhex2
c_func
(paren
id|buffer
comma
op_amp
(paren
id|dp-&gt;ii.irb
)paren
comma
r_sizeof
(paren
id|irb_t
)paren
comma
l_int|2
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t; * take fast exit if no handler is available&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
r_return
id|ending_status
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check whether we must issue a SENSE CCW ourselves if there is no&n;&t;&t; *  concurrent sense facility installed for the subchannel.&n;&t;&t; *&n;&t;&t; * Note: We should check for ioinfo[irq]-&gt;ui.flags.consns but VM&n;&t;&t; *       violates the ESA/390 architecture and doesn&squot;t present an&n;&t;&t; *       operand exception for virtual devices without concurrent&n;&t;&t; *       sense facility available/supported when enabling the&n;&t;&t; *       concurrent sense facility.&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|dp-&gt;ii.irb.scsw.dstat
op_amp
id|DEV_STAT_UNIT_CHECK
)paren
op_logical_and
(paren
op_logical_neg
id|issense
)paren
)paren
op_logical_or
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.delsense
op_logical_and
id|ending_status
)paren
)paren
(brace
r_int
id|ret_io
suffix:semicolon
id|ccw1_t
op_star
id|s_ccw
op_assign
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseccw
suffix:semicolon
r_int
r_int
id|s_flag
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ending_status
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * We copy the current status information into the device driver&n;&t;&t;&t;&t; *  status area. Then we can use the local devstat area for device&n;&t;&t;&t;&t; *  sensing. When finally calling the IRQ handler we must not overlay&n;&t;&t;&t;&t; *  the original device status but copy the sense data only.&n;&t;&t;&t;&t; */
id|memcpy
c_func
(paren
id|udp
comma
id|dp
comma
r_sizeof
(paren
id|devstat_t
)paren
)paren
suffix:semicolon
id|s_ccw-&gt;cmd_code
op_assign
id|CCW_CMD_BASIC_SENSE
suffix:semicolon
id|s_ccw-&gt;cda
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
c_func
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|sense_data
)paren
suffix:semicolon
id|s_ccw-&gt;count
op_assign
id|SENSE_MAX_COUNT
suffix:semicolon
id|s_ccw-&gt;flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * If free_irq() or a sync do_IO/s390_start_IO() is in&n;&t;&t;&t;&t; *  process we have to sense synchronously&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.unready
op_logical_or
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.syncio
)paren
(brace
id|s_flag
op_assign
id|DOIO_WAIT_FOR_INTERRUPT
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t;&t;&t; * Reset status info&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * It does not matter whether this is a sync. or async.&n;&t;&t;&t;&t; *  SENSE request, but we have to assure we don&squot;t call&n;&t;&t;&t;&t; *  the irq handler now, but keep the irq in busy state.&n;&t;&t;&t;&t; *  In sync. mode s390_process_IRQ() is called recursively,&n;&t;&t;&t;&t; *  while in async. mode we re-enter do_IRQ() with the&n;&t;&t;&t;&t; *  next interrupt.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * Note : this may be a delayed sense request !&n;&t;&t;&t;&t; */
id|allow4handler
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4final
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.delsense
op_assign
l_int|0
suffix:semicolon
id|dp-&gt;cstat
op_assign
l_int|0
suffix:semicolon
id|dp-&gt;dstat
op_assign
l_int|0
suffix:semicolon
id|dp-&gt;rescnt
op_assign
id|SENSE_MAX_COUNT
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4sense
op_assign
l_int|1
suffix:semicolon
id|ret_io
op_assign
id|s390_start_IO
c_func
(paren
id|irq
comma
id|s_ccw
comma
l_int|0xE2C5D5E2
comma
singleline_comment|// = SENSe
l_int|0
comma
singleline_comment|// n/a
id|s_flag
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * we received an Unit Check but we have no final&n;&t;&t;&t;&t; *  status yet, therefore we must delay the SENSE&n;&t;&t;&t;&t; *  processing. However, we must not report this&n;&t;&t;&t;&t; *  intermediate status to the device interrupt&n;&t;&t;&t;&t; *  handler.&n;&t;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.delsense
op_assign
l_int|1
suffix:semicolon
id|allow4handler
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t; * we allow for the device action handler if .&n;&t;&t; *  - we received ending status&n;&t;&t; *  - the action handler requested to see all interrupts&n;&t;&t; *  - we received an intermediate status&n;&t;&t; *  - fast notification was requested (primary status)&n;&t;&t; *  - unsollicited interrupts&n;&t;&t; *&n;&t;&t; */
r_if
c_cond
(paren
id|allow4handler
)paren
(brace
id|allow4handler
op_assign
id|ending_status
op_logical_or
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
)paren
op_logical_or
(paren
id|stctl
op_amp
id|SCSW_STCTL_INTER_STATUS
)paren
op_logical_or
(paren
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
)paren
op_logical_and
(paren
id|stctl
op_amp
id|SCSW_STCTL_PRIM_STATUS
)paren
)paren
op_logical_or
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_eq
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t; * We used to copy the device status information right before&n;&t;&t; *  calling the device action handler. However, in status&n;&t;&t; *  pending situations during do_IO() or halt_IO(), as well as&n;&t;&t; *  enable_subchannel/disable_subchannel processing we must&n;&t;&t; *  synchronously return the status information and must not&n;&t;&t; *  call the device action handler.&n;&t;&t; *&n;&t;&t; */
r_if
c_cond
(paren
id|allow4handler
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * if we were waiting for sense data we copy the sense&n;&t;&t;&t; *  bytes only as the original status information was&n;&t;&t;&t; *  saved prior to sense already.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4sense
)paren
(brace
r_int
id|sense_count
op_assign
id|SENSE_MAX_COUNT
op_minus
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.rescnt
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_IO
r_if
c_cond
(paren
id|irq
op_ne
id|cons_dev
)paren
id|printk
c_func
(paren
l_string|&quot;s390_process_IRQ( %04X ) : &quot;
l_string|&quot;BASIC SENSE bytes avail %d&bslash;n&quot;
comma
id|irq
comma
id|sense_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|4
comma
l_string|&quot;s390_process_IRQ( %04X ): BASIC SENSE bytes avail %d&bslash;n&quot;
comma
id|irq
comma
id|sense_count
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4sense
op_assign
l_int|0
suffix:semicolon
id|udp-&gt;flag
op_or_assign
id|DEVSTAT_FLAG_SENSE_AVAIL
suffix:semicolon
id|udp-&gt;scnt
op_assign
id|sense_count
suffix:semicolon
r_if
c_cond
(paren
id|sense_count
op_ge
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|udp-&gt;ii.sense.data
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|sense_data
comma
id|sense_count
)paren
suffix:semicolon
)brace
r_else
(brace
id|panic
c_func
(paren
l_string|&quot;s390_process_IRQ(%04x) encountered &quot;
l_string|&quot;negative sense count&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|udp
comma
id|dp
comma
id|sdevstat
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t; * for status pending situations other than deferred interrupt&n;&t;&t; *  conditions detected by s390_process_IRQ() itself we must not&n;&t;&t; *  call the handler. This will synchronously be reported back&n;&t;&t; *  to the caller instead, e.g. when detected during do_IO().&n;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_logical_or
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.unready
op_logical_or
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repnone
)paren
(brace
r_if
c_cond
(paren
id|ending_status
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.haltio
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4final
op_assign
l_int|0
suffix:semicolon
id|dp-&gt;flag
op_or_assign
id|DEVSTAT_FINAL_STATUS
suffix:semicolon
id|udp-&gt;flag
op_or_assign
id|DEVSTAT_FINAL_STATUS
suffix:semicolon
)brace
multiline_comment|/* endif */
id|allow4handler
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t; * Call device action handler if applicable&n;&t;&t; */
r_if
c_cond
(paren
id|allow4handler
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *  We only reset the busy condition when we are sure that no further&n;&t;&t;&t; *   interrupt is pending for the current I/O request (ending_status).&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ending_status
op_logical_or
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* dev IS oper */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.haltio
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4final
op_assign
l_int|0
suffix:semicolon
id|dp-&gt;flag
op_or_assign
id|DEVSTAT_FINAL_STATUS
suffix:semicolon
id|udp-&gt;flag
op_or_assign
id|DEVSTAT_FINAL_STATUS
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc
dot
id|handler
c_func
(paren
id|irq
comma
id|udp
comma
l_int|NULL
)paren
suffix:semicolon
singleline_comment|//
singleline_comment|// reset intparm after final status or we will badly present unsolicited
singleline_comment|//  interrupts with a intparm value possibly no longer valid.
singleline_comment|//
id|dp-&gt;intparm
op_assign
l_int|0
suffix:semicolon
singleline_comment|//
singleline_comment|// Was there anything queued ? Start the pending channel program
singleline_comment|//  if there is one.
singleline_comment|//
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio_q
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|s390_start_IO
c_func
(paren
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qcpa
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qintparm
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qlpm
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qflag
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio_q
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * If s390_start_IO() failed call the device&squot;s interrupt&n;&t;&t;&t;&t;&t; *  handler, the IRQ related devstat area was setup by&n;&t;&t;&t;&t;&t; *  s390_start_IO() accordingly already (status pending&n;&t;&t;&t;&t;&t; *  condition).&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ret
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc
dot
id|handler
c_func
(paren
id|irq
comma
id|udp
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4final
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Eventually reset subchannel PCI status and&n;&t;&t;&t;&t; *  set the PCI or SUSPENDED flag in the user&n;&t;&t;&t;&t; *  device status block if appropriate.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|dp-&gt;cstat
op_amp
id|SCHN_STAT_PCI
)paren
(brace
id|udp-&gt;flag
op_or_assign
id|DEVSTAT_PCI
suffix:semicolon
id|dp-&gt;cstat
op_and_assign
op_complement
id|SCHN_STAT_PCI
suffix:semicolon
)brace
r_if
c_cond
(paren
id|actl
op_amp
id|SCSW_ACTL_SUSPENDED
)paren
(brace
id|udp-&gt;flag
op_or_assign
id|DEVSTAT_SUSPENDED
suffix:semicolon
)brace
multiline_comment|/* endif */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc
dot
id|handler
c_func
(paren
id|irq
comma
id|udp
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* device/path not operational */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.haltio
op_assign
l_int|0
suffix:semicolon
id|dp-&gt;cstat
op_assign
l_int|0
suffix:semicolon
id|dp-&gt;dstat
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ulpm
op_ne
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * either it was the only path or it was restricted ...&n;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_and_assign
op_complement
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.esw.esw1.lpum
)paren
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_eq
l_int|0
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_NOT_OPER
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_FINAL_STATUS
suffix:semicolon
multiline_comment|/*&n;&t;&t; * When we find a device &quot;not oper&quot; we save the status&n;&t;&t; *  information into the device status area and call the&n;&t;&t; *  device specific interrupt handler.&n;&t;&t; *&n;&t;&t; * Note: currently we don&squot;t have any way to reenable&n;&t;&t; *       the device unless an unsolicited interrupt&n;&t;&t; *       is presented. We don&squot;t check for spurious&n;&t;&t; *       interrupts on &quot;not oper&quot; conditions.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4final
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If a new request was queued already, we have&n;&t;&t;&t; *  to simulate the &quot;not oper&quot; status for the&n;&t;&t;&t; *  queued request by switching the &quot;intparm&quot; value&n;&t;&t;&t; *  and notify the interrupt handler.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio_q
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.intparm
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qintparm
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4final
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * take fast exit if no handler is available&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
r_return
id|ending_status
suffix:semicolon
id|memcpy
c_func
(paren
id|udp
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat
)paren
comma
id|sdevstat
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.intparm
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc
dot
id|handler
c_func
(paren
id|irq
comma
id|udp
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
id|ending_status
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
r_return
id|ending_status
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the special i/o-interruption sublass 7 for the&n; *  device specified by parameter irq. There can only&n; *  be a single device been operated on this special&n; *  isc. This function is aimed being able to check&n; *  on special device interrupts in disabled state,&n; *  without having to delay I/O processing (by queueing)&n; *  for non-console devices.&n; *&n; * Setting of this isc is done by set_cons_dev(), while&n; *  reset_cons_dev() resets this isc and re-enables the&n; *  default isc3 for this device. wait_cons_dev() allows&n; *  to actively wait on an interrupt for this device in&n; *  disabed state. When the interrupt condition is&n; *  encountered, wait_cons_dev(9 calls do_IRQ() to have&n; *  the console device driver processing the interrupt.&n; */
DECL|function|set_cons_dev
r_int
id|set_cons_dev
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
id|ccode
suffix:semicolon
r_int
r_int
id|cr6
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|8
)paren
)paren
)paren
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|SANITY_CHECK
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cons_dev
op_ne
op_minus
l_int|1
)paren
(brace
id|rc
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
l_string|&quot;scons&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dbf_txt
comma
l_string|&quot;%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * modify the indicated console device to operate&n;&t;&t; *  on special console interrupt sublass 7&n;&t;&t; */
id|ccode
op_assign
id|stsch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccode
)paren
(brace
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_NOT_OPER
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.isc
op_assign
l_int|7
suffix:semicolon
id|ccode
op_assign
id|msch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccode
)paren
(brace
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|cons_dev
op_assign
id|irq
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * enable console I/O-interrupt sublass 7&n;&t;&t;&t;&t; */
id|__ctl_store
c_func
(paren
id|cr6
comma
l_int|6
comma
l_int|6
)paren
suffix:semicolon
id|cr6
op_or_assign
l_int|0x01000000
suffix:semicolon
id|__ctl_load
c_func
(paren
id|cr6
comma
l_int|6
comma
l_int|6
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_return
id|rc
suffix:semicolon
)brace
DECL|function|reset_cons_dev
r_int
id|reset_cons_dev
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|ccode
suffix:semicolon
r_int
id|cr6
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|8
)paren
)paren
)paren
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|SANITY_CHECK
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cons_dev
op_ne
op_minus
l_int|1
)paren
(brace
id|rc
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
l_string|&quot;rcons&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dbf_txt
comma
l_string|&quot;%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * reset the indicated console device to operate&n;&t;&t; *  on default console interrupt sublass 3&n;&t;&t; */
id|ccode
op_assign
id|stsch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccode
)paren
(brace
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_NOT_OPER
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.isc
op_assign
l_int|3
suffix:semicolon
id|ccode
op_assign
id|msch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccode
)paren
(brace
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|cons_dev
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * disable special console I/O-interrupt sublass 7&n;&t;&t;&t;&t; */
id|__ctl_store
c_func
(paren
id|cr6
comma
l_int|6
comma
l_int|6
)paren
suffix:semicolon
id|cr6
op_and_assign
l_int|0xFEFFFFFF
suffix:semicolon
id|__ctl_load
c_func
(paren
id|cr6
comma
l_int|6
comma
l_int|6
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_return
id|rc
suffix:semicolon
)brace
DECL|function|wait_cons_dev
r_int
id|wait_cons_dev
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|save_cr6
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_eq
id|cons_dev
)paren
(brace
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
l_string|&quot;wcons&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dbf_txt
comma
l_string|&quot;%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * before entering the spinlock we may already have&n;&t;&t; *  processed the interrupt on a different CPU ...&n;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_eq
l_int|1
)paren
(brace
r_int
id|cr6
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|8
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * disable all, but isc 7 (console device)&n;&t;&t;&t; */
id|__ctl_store
c_func
(paren
id|cr6
comma
l_int|6
comma
l_int|6
)paren
suffix:semicolon
id|save_cr6
op_assign
id|cr6
suffix:semicolon
id|cr6
op_and_assign
l_int|0x01FFFFFF
suffix:semicolon
id|__ctl_load
c_func
(paren
id|cr6
comma
l_int|6
comma
l_int|6
)paren
suffix:semicolon
r_do
(brace
id|tpi_info_t
id|tpi_info
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
r_if
c_cond
(paren
id|tpi
c_func
(paren
op_amp
id|tpi_info
)paren
op_eq
l_int|1
)paren
(brace
id|s390_process_IRQ
c_func
(paren
id|tpi_info.irq
)paren
suffix:semicolon
)brace
r_else
(brace
id|s390irq_spin_unlock
c_func
(paren
id|irq
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|s390irq_spin_lock
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
id|eieio
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_eq
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * restore previous isc value&n;&t;&t;&t; */
id|cr6
op_assign
id|save_cr6
suffix:semicolon
id|__ctl_load
c_func
(paren
id|cr6
comma
l_int|6
comma
l_int|6
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|rc
op_assign
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|rc
suffix:semicolon
)brace
DECL|function|enable_cpu_sync_isc
r_int
id|enable_cpu_sync_isc
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
id|ccode
suffix:semicolon
r_int
id|cr6
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|8
)paren
)paren
)paren
suffix:semicolon
r_int
id|retry
op_assign
l_int|3
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
l_string|&quot;enisc&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dbf_txt
comma
l_string|&quot;%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
)brace
multiline_comment|/* This one spins until it can get the sync_isc lock for irq# irq */
r_if
c_cond
(paren
id|irq
op_le
id|highest_subchannel
op_logical_and
id|ioinfo
(braket
id|irq
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sync_isc
)paren
op_ne
id|irq
)paren
id|atomic_compare_and_swap_spin
c_func
(paren
op_minus
l_int|1
comma
id|irq
comma
op_amp
id|sync_isc
)paren
suffix:semicolon
id|sync_isc_cnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sync_isc_cnt
OG
l_int|255
)paren
multiline_comment|/* fixme : magic number */
(brace
id|panic
c_func
(paren
l_string|&quot;Too many recursive calls to enable_sync_isc&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * we only run the STSCH/MSCH path for the first enablement&n;&t;&t; */
r_else
r_if
c_cond
(paren
id|sync_isc_cnt
op_eq
l_int|1
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.syncio
op_assign
l_int|1
suffix:semicolon
id|ccode
op_assign
id|stsch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ccode
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.isc
op_assign
l_int|5
suffix:semicolon
r_do
(brace
id|ccode
op_assign
id|msch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * enable special isc&n;&t;&t;&t;&t;&t;&t; */
id|__ctl_store
c_func
(paren
id|cr6
comma
l_int|6
comma
l_int|6
)paren
suffix:semicolon
id|cr6
op_or_assign
l_int|0x04000000
suffix:semicolon
singleline_comment|// enable sync isc 5
id|cr6
op_and_assign
l_int|0xEFFFFFFF
suffix:semicolon
singleline_comment|// disable standard isc 3
id|__ctl_load
c_func
(paren
id|cr6
comma
l_int|6
comma
l_int|6
)paren
suffix:semicolon
id|retry
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
singleline_comment|//
singleline_comment|// process pending status
singleline_comment|//
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|1
suffix:semicolon
id|s390_process_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|0
suffix:semicolon
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* might be overwritten... */
id|retry
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* busy */
id|retry
op_assign
l_int|0
suffix:semicolon
id|rc
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* not oper*/
id|retry
op_assign
l_int|0
suffix:semicolon
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|retry
)paren
suffix:semicolon
)brace
r_else
(brace
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
singleline_comment|// device is not-operational
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|rc
)paren
multiline_comment|/* can only happen if stsch/msch fails */
(brace
id|sync_isc_cnt
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|sync_isc
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
macro_line|#ifdef CONFIG_SYNC_ISC_PARANOIA
id|panic
c_func
(paren
l_string|&quot;enable_sync_isc: called with invalid %x&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
macro_line|#endif
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|rc
suffix:semicolon
)brace
DECL|function|disable_cpu_sync_isc
r_int
id|disable_cpu_sync_isc
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|retry1
op_assign
l_int|5
suffix:semicolon
r_int
id|retry2
op_assign
l_int|5
suffix:semicolon
r_int
id|clear_pend
op_assign
l_int|0
suffix:semicolon
r_int
id|ccode
suffix:semicolon
r_int
id|cr6
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|8
)paren
)paren
)paren
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
l_string|&quot;disisc&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dbf_txt
comma
l_string|&quot;%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irq
op_le
id|highest_subchannel
op_logical_and
id|ioinfo
(braket
id|irq
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
(brace
multiline_comment|/*&n;&t;&t; * We disable if we&squot;re the top user only, as we may&n;&t;&t; *  run recursively ...&t;&n;&t;&t; * We must not decrease the count immediately; during&n;&t;&t; *  msch() processing we may face another pending&n;&t;&t; *  status we have to process recursively (sync).&n;&t;&t; */
macro_line|#ifdef CONFIG_SYNC_ISC_PARANOIA
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sync_isc
)paren
op_ne
id|irq
)paren
id|panic
c_func
(paren
l_string|&quot;disable_sync_isc: called for %x while %x locked&bslash;n&quot;
comma
id|irq
comma
id|atomic_read
c_func
(paren
op_amp
id|sync_isc
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|sync_isc_cnt
op_eq
l_int|1
)paren
(brace
id|ccode
op_assign
id|stsch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.isc
op_assign
l_int|3
suffix:semicolon
r_do
(brace
id|retry2
op_assign
l_int|5
suffix:semicolon
r_do
(brace
id|ccode
op_assign
id|msch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * disable special interrupt subclass in CPU&n;&t;&t;&t;&t;&t;&t; */
id|__ctl_store
c_func
(paren
id|cr6
comma
l_int|6
comma
l_int|6
)paren
suffix:semicolon
id|cr6
op_and_assign
l_int|0xFBFFFFFF
suffix:semicolon
singleline_comment|// disable sync isc 5
id|cr6
op_or_assign
l_int|0x10000000
suffix:semicolon
singleline_comment|// enable standard isc 3
id|__ctl_load
c_func
(paren
id|cr6
comma
l_int|6
comma
l_int|6
)paren
suffix:semicolon
id|retry2
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* status pending */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|1
suffix:semicolon
id|s390_process_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|0
suffix:semicolon
id|retry2
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* busy */
id|retry2
op_decrement
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
singleline_comment|// give it time
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* not oper */
id|retry2
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
)brace
r_while
c_loop
(paren
id|retry2
)paren
suffix:semicolon
id|retry1
op_decrement
suffix:semicolon
multiline_comment|/* try stopping it ... */
r_if
c_cond
(paren
(paren
id|ccode
)paren
op_logical_and
op_logical_neg
id|clear_pend
)paren
(brace
id|clear_IO
c_func
(paren
id|irq
comma
l_int|0x00004711
comma
l_int|0
)paren
suffix:semicolon
id|clear_pend
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|retry1
op_logical_and
id|ccode
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.syncio
op_assign
l_int|0
suffix:semicolon
id|sync_isc_cnt
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|sync_isc
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|sync_isc_cnt
op_decrement
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
macro_line|#ifdef CONFIG_SYNC_ISC_PARANOIA
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sync_isc
)paren
op_ne
op_minus
l_int|1
)paren
id|panic
c_func
(paren
l_string|&quot;disable_sync_isc: called with invalid %x while %x locked&bslash;n&quot;
comma
id|irq
comma
id|atomic_read
c_func
(paren
op_amp
id|sync_isc
)paren
)paren
suffix:semicolon
macro_line|#endif
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|rc
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// Input :
singleline_comment|//   devno - device number
singleline_comment|//   ps    - pointer to sense ID data area
singleline_comment|//
singleline_comment|// Output : none
singleline_comment|//
DECL|function|VM_virtual_device_info
r_void
id|VM_virtual_device_info
c_func
(paren
id|__u16
id|devno
comma
id|senseid_t
op_star
id|ps
)paren
(brace
id|diag210_t
op_star
id|p_diag_data
suffix:semicolon
r_int
id|ccode
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
l_string|&quot;VMvdinf&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
(brace
id|p_diag_data
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|diag210_t
)paren
comma
id|GFP_DMA
)paren
suffix:semicolon
)brace
r_else
(brace
id|p_diag_data
op_assign
id|alloc_bootmem_low
c_func
(paren
r_sizeof
(paren
id|diag210_t
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
id|p_diag_data-&gt;vrdcdvno
op_assign
id|devno
suffix:semicolon
id|p_diag_data-&gt;vrdclen
op_assign
r_sizeof
(paren
id|diag210_t
)paren
suffix:semicolon
id|ccode
op_assign
id|diag210
c_func
(paren
(paren
id|diag210_t
op_star
)paren
id|virt_to_phys
c_func
(paren
id|p_diag_data
)paren
)paren
suffix:semicolon
id|ps-&gt;reserved
op_assign
l_int|0xff
suffix:semicolon
r_switch
c_cond
(paren
id|p_diag_data-&gt;vrdcvcla
)paren
(brace
r_case
l_int|0x80
suffix:colon
r_switch
c_cond
(paren
id|p_diag_data-&gt;vrdcvtyp
)paren
(brace
r_case
l_int|00
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3215
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
r_break
suffix:semicolon
r_case
l_int|0x40
suffix:colon
r_switch
c_cond
(paren
id|p_diag_data-&gt;vrdcvtyp
)paren
(brace
r_case
l_int|0xC0
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x5080
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x80
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x2250
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x04
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3277
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x01
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3278
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
r_break
suffix:semicolon
r_case
l_int|0x20
suffix:colon
r_switch
c_cond
(paren
id|p_diag_data-&gt;vrdcvtyp
)paren
(brace
r_case
l_int|0x84
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3505
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x82
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x2540
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x81
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x2501
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
r_break
suffix:semicolon
r_case
l_int|0x10
suffix:colon
r_switch
c_cond
(paren
id|p_diag_data-&gt;vrdcvtyp
)paren
(brace
r_case
l_int|0x84
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3525
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x82
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x2540
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x4F
suffix:colon
r_case
l_int|0x4E
suffix:colon
r_case
l_int|0x48
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3820
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x4D
suffix:colon
r_case
l_int|0x49
suffix:colon
r_case
l_int|0x45
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3800
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x4B
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x4248
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x4A
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x4245
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x47
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3262
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x43
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3203
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x42
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3211
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x41
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x1403
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
r_break
suffix:semicolon
r_case
l_int|0x08
suffix:colon
r_switch
c_cond
(paren
id|p_diag_data-&gt;vrdcvtyp
)paren
(brace
r_case
l_int|0x82
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3422
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x81
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3490
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x10
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3420
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x02
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3430
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x01
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3480
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x42
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3424
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x44
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x9348
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
r_break
suffix:semicolon
r_case
l_int|02
suffix:colon
multiline_comment|/* special device class ... */
r_switch
c_cond
(paren
id|p_diag_data-&gt;vrdcvtyp
)paren
(brace
r_case
l_int|0x20
suffix:colon
multiline_comment|/* OSA */
id|ps-&gt;cu_type
op_assign
l_int|0x3088
suffix:semicolon
id|ps-&gt;cu_model
op_assign
l_int|0x60
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
(brace
id|kfree
c_func
(paren
id|p_diag_data
)paren
suffix:semicolon
)brace
r_else
(brace
id|free_bootmem
c_func
(paren
(paren
r_int
r_int
)paren
id|p_diag_data
comma
r_sizeof
(paren
id|diag210_t
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|error
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DIAG X&squot;210&squot; for &quot;
l_string|&quot;device %04X returned &quot;
l_string|&quot;(cc = %d): vdev class : %02X, &quot;
l_string|&quot;vdev type : %04X &bslash;n ...  rdev class : %02X, rdev type : %04X, rdev model: %02X&bslash;n&quot;
comma
id|devno
comma
id|ccode
comma
id|p_diag_data-&gt;vrdcvcla
comma
id|p_diag_data-&gt;vrdcvtyp
comma
id|p_diag_data-&gt;vrdcrccl
comma
id|p_diag_data-&gt;vrdccrty
comma
id|p_diag_data-&gt;vrdccrmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|0
comma
l_string|&quot;DIAG X&squot;210&squot; for &quot;
l_string|&quot;device %04X returned &quot;
l_string|&quot;(cc = %d): vdev class : %02X, &quot;
l_string|&quot;vdev type : %04X &bslash;n ...  rdev class : %02X, rdev type : %04X, rdev model: %02X&bslash;n&quot;
comma
id|devno
comma
id|ccode
comma
id|p_diag_data-&gt;vrdcvcla
comma
id|p_diag_data-&gt;vrdcvtyp
comma
id|p_diag_data-&gt;vrdcrccl
comma
id|p_diag_data-&gt;vrdccrty
comma
id|p_diag_data-&gt;vrdccrmd
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/*&n; * This routine returns the characteristics for the device&n; *  specified. Some old devices might not provide the necessary&n; *  command code information during SenseID processing. In this&n; *  case the function returns -EINVAL. Otherwise the function&n; *  allocates a decice specific data buffer and provides the&n; *  device characteristics together with the buffer size. Its&n; *  the callers responability to release the kernel memory if&n; *  not longer needed. In case of persistent I/O problems -EBUSY&n; *  is returned.&n; *&n; *  The function may be called enabled or disabled. However, the&n; *   caller must have locked the irq it is requesting data for.&n; *&n; * Note : It would have been nice to collect this information&n; *         during init_IRQ() processing but this is not possible&n; *&n; *         a) without statically pre-allocation fixed size buffers&n; *            as virtual memory management isn&squot;t available yet.&n; *&n; *         b) without unnecessarily increase system startup by&n; *            evaluating devices eventually not used at all.&n; */
DECL|function|read_dev_chars
r_int
id|read_dev_chars
c_func
(paren
r_int
id|irq
comma
r_void
op_star
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|ccw1_t
op_star
id|rdc_ccw
suffix:semicolon
id|devstat_t
id|devstat
suffix:semicolon
r_char
op_star
id|rdc_buf
suffix:semicolon
r_int
id|devflag
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|emulated
op_assign
l_int|0
suffix:semicolon
r_int
id|retry
op_assign
l_int|5
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
op_logical_or
op_logical_neg
id|length
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* endif */
id|SANITY_CHECK
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
l_string|&quot;rddevch&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dbf_txt
comma
l_string|&quot;%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Before playing around with irq locks we should assure&n;&t; *   running disabled on (just) our CPU. Sync. I/O requests&n;&t; *   also require to run disabled.&n;&t; *&n;&t; * Note : as no global lock is required, we must not use&n;&t; *        cli(), but __cli() instead.  &t;&n;&t; */
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
id|rdc_ccw
op_assign
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseccw
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
id|ret
op_assign
id|request_irq
c_func
(paren
id|irq
comma
id|init_IRQ_handler
comma
id|SA_PROBE
comma
l_string|&quot;RDC&quot;
comma
op_amp
id|devstat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|emulated
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|buffer
)paren
(brace
id|rdc_buf
op_assign
id|kmalloc
c_func
(paren
id|length
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
r_else
(brace
id|rdc_buf
op_assign
op_star
id|buffer
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
op_logical_neg
id|rdc_buf
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
r_do
(brace
id|rdc_ccw-&gt;cmd_code
op_assign
id|CCW_CMD_RDC
suffix:semicolon
id|rdc_ccw-&gt;count
op_assign
id|length
suffix:semicolon
id|rdc_ccw-&gt;flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
id|ret
op_assign
id|set_normalized_cda
c_func
(paren
id|rdc_ccw
comma
(paren
r_int
r_int
)paren
id|rdc_buf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|memset
c_func
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|devstat_t
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|s390_start_IO
c_func
(paren
id|irq
comma
id|rdc_ccw
comma
l_int|0x00524443
comma
singleline_comment|// RDC
l_int|0
comma
singleline_comment|// n/a
id|DOIO_WAIT_FOR_INTERRUPT
op_or
id|DOIO_DONT_CALL_INTHDLR
)paren
suffix:semicolon
id|retry
op_decrement
suffix:semicolon
id|devflag
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id-&gt;flag
suffix:semicolon
id|clear_normalized_cda
c_func
(paren
id|rdc_ccw
)paren
suffix:semicolon
)brace
r_else
(brace
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
singleline_comment|//wait for recovery
id|retry
op_decrement
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|retry
)paren
op_logical_and
(paren
id|ret
op_logical_or
(paren
id|devflag
op_amp
id|DEVSTAT_STATUS_PENDING
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
op_logical_neg
id|retry
)paren
(brace
id|ret
op_assign
(paren
id|ret
op_eq
op_minus
id|ENOMEM
)paren
ques
op_minus
id|ENOMEM
suffix:colon
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* endif */
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * on success we update the user input parms&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
op_star
id|buffer
op_assign
id|rdc_buf
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|emulated
)paren
(brace
id|free_irq
c_func
(paren
id|irq
comma
op_amp
id|devstat
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *  Read Configuration data&n; */
DECL|function|read_conf_data
r_int
id|read_conf_data
c_func
(paren
r_int
id|irq
comma
r_void
op_star
op_star
id|buffer
comma
r_int
op_star
id|length
comma
id|__u8
id|lpm
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ciw_cnt
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
singleline_comment|// RCD CIW found
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
singleline_comment|// return code
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|SANITY_CHECK
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
op_logical_or
op_logical_neg
id|length
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.esid
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
l_string|&quot;rdconf&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dbf_txt
comma
l_string|&quot;%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * scan for RCD command in extended SenseID data&n;&t; */
r_for
c_loop
(paren
id|ciw_cnt
op_assign
l_int|0
suffix:semicolon
(paren
id|found
op_eq
l_int|0
)paren
op_logical_and
(paren
id|ciw_cnt
OL
l_int|62
)paren
suffix:semicolon
id|ciw_cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.ciw
(braket
id|ciw_cnt
)braket
dot
id|ct
op_eq
id|CIW_TYPE_RCD
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * paranoia check ...&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.ciw
(braket
id|ciw_cnt
)braket
dot
id|cmd
op_ne
l_int|0
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
r_break
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endfor */
r_if
c_cond
(paren
id|found
)paren
(brace
id|devstat_t
id|devstat
suffix:semicolon
multiline_comment|/* inline device status area */
id|devstat_t
op_star
id|pdevstat
suffix:semicolon
r_int
id|ioflags
suffix:semicolon
id|ccw1_t
op_star
id|rcd_ccw
op_assign
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseccw
suffix:semicolon
r_char
op_star
id|rcd_buf
op_assign
l_int|NULL
suffix:semicolon
r_int
id|emulated
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no i/O handler installed */
r_int
id|retry
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* retry count */
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
id|pdevstat
op_assign
op_amp
id|devstat
suffix:semicolon
id|ret
op_assign
id|request_irq
c_func
(paren
id|irq
comma
id|init_IRQ_handler
comma
id|SA_PROBE
comma
l_string|&quot;RCD&quot;
comma
id|pdevstat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|emulated
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|pdevstat
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
(brace
id|rcd_buf
op_assign
id|kmalloc
c_func
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.ciw
(braket
id|ciw_cnt
)braket
dot
id|count
comma
id|GFP_DMA
)paren
suffix:semicolon
)brace
r_else
(brace
id|rcd_buf
op_assign
id|alloc_bootmem_low
c_func
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.ciw
(braket
id|ciw_cnt
)braket
dot
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|rcd_buf
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|memset
c_func
(paren
id|rcd_buf
comma
l_char|&squot;&bslash;0&squot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.ciw
(braket
id|ciw_cnt
)braket
dot
id|count
)paren
suffix:semicolon
r_do
(brace
id|rcd_ccw-&gt;cmd_code
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.ciw
(braket
id|ciw_cnt
)braket
dot
id|cmd
suffix:semicolon
id|rcd_ccw-&gt;cda
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
c_func
(paren
id|rcd_buf
)paren
suffix:semicolon
id|rcd_ccw-&gt;count
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.ciw
(braket
id|ciw_cnt
)braket
dot
id|count
suffix:semicolon
id|rcd_ccw-&gt;flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
id|memset
c_func
(paren
id|pdevstat
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|devstat_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lpm
)paren
(brace
id|ioflags
op_assign
id|DOIO_WAIT_FOR_INTERRUPT
op_or
id|DOIO_VALID_LPM
op_or
id|DOIO_DONT_CALL_INTHDLR
suffix:semicolon
)brace
r_else
(brace
id|ioflags
op_assign
id|DOIO_WAIT_FOR_INTERRUPT
op_or
id|DOIO_DONT_CALL_INTHDLR
suffix:semicolon
)brace
multiline_comment|/* endif */
id|ret
op_assign
id|s390_start_IO
c_func
(paren
id|irq
comma
id|rcd_ccw
comma
l_int|0x00524344
comma
singleline_comment|// == RCD
id|lpm
comma
id|ioflags
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ret
)paren
(brace
r_case
l_int|0
suffix:colon
r_case
op_minus
id|EIO
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pdevstat-&gt;flag
op_amp
(paren
id|DEVSTAT_STATUS_PENDING
op_or
id|DEVSTAT_NOT_OPER
op_or
id|DEVSTAT_FLAG_SENSE_AVAIL
)paren
)paren
)paren
(brace
id|retry
op_assign
l_int|0
suffix:semicolon
singleline_comment|// we got it ...
)brace
r_else
(brace
id|retry
op_decrement
suffix:semicolon
singleline_comment|// try again ...
)brace
multiline_comment|/* endif */
r_break
suffix:semicolon
r_default
suffix:colon
singleline_comment|// -EBUSY, -ENODEV, ???
id|retry
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endswitch */
)brace
r_while
c_loop
(paren
id|retry
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t; * on success we update the user input parms&n;&t;&t; */
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
op_star
id|length
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.ciw
(braket
id|ciw_cnt
)braket
dot
id|count
suffix:semicolon
op_star
id|buffer
op_assign
id|rcd_buf
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|rcd_buf
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
(brace
id|kfree
c_func
(paren
id|rcd_buf
)paren
suffix:semicolon
)brace
r_else
(brace
id|free_bootmem
c_func
(paren
(paren
r_int
r_int
)paren
id|rcd_buf
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.ciw
(braket
id|ciw_cnt
)braket
dot
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
op_star
id|buffer
op_assign
l_int|NULL
suffix:semicolon
op_star
id|length
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|emulated
)paren
id|free_irq
c_func
(paren
id|irq
comma
id|pdevstat
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|ret
suffix:semicolon
)brace
DECL|function|get_dev_info
r_int
id|get_dev_info
c_func
(paren
r_int
id|irq
comma
id|s390_dev_info_t
op_star
id|pdi
)paren
(brace
r_return
id|get_dev_info_by_irq
c_func
(paren
id|irq
comma
id|pdi
)paren
suffix:semicolon
)brace
DECL|function|get_next_available_irq
r_static
r_int
id|__inline__
id|get_next_available_irq
c_func
(paren
id|ioinfo_t
op_star
id|pi
)paren
(brace
r_int
id|ret_val
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_while
c_loop
(paren
id|pi
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|pi-&gt;ui.flags.oper
)paren
(brace
id|ret_val
op_assign
id|pi-&gt;irq
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|pi
op_assign
id|pi-&gt;next
suffix:semicolon
)brace
)brace
r_return
id|ret_val
suffix:semicolon
)brace
DECL|function|get_irq_first
r_int
id|get_irq_first
c_func
(paren
r_void
)paren
(brace
r_int
id|ret_irq
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo_head
)paren
(brace
r_if
c_cond
(paren
id|ioinfo_head-&gt;ui.flags.oper
)paren
(brace
id|ret_irq
op_assign
id|ioinfo_head-&gt;irq
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ioinfo_head-&gt;next
)paren
(brace
id|ret_irq
op_assign
id|get_next_available_irq
c_func
(paren
id|ioinfo_head-&gt;next
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret_irq
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|ret_irq
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|ret_irq
suffix:semicolon
)brace
DECL|function|get_irq_next
r_int
id|get_irq_next
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
id|ret_irq
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
(brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|next
)paren
(brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|next-&gt;ui.flags.oper
)paren
(brace
id|ret_irq
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|next-&gt;irq
suffix:semicolon
)brace
r_else
(brace
id|ret_irq
op_assign
id|get_next_available_irq
c_func
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|ret_irq
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|ret_irq
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|ret_irq
suffix:semicolon
)brace
DECL|function|get_dev_info_by_irq
r_int
id|get_dev_info_by_irq
c_func
(paren
r_int
id|irq
comma
id|s390_dev_info_t
op_star
id|pdi
)paren
(brace
id|SANITY_CHECK
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pdi
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|pdi-&gt;devno
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
suffix:semicolon
id|pdi-&gt;irq
op_assign
id|irq
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_logical_and
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.unknown
)paren
(brace
id|pdi-&gt;status
op_assign
l_int|0
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
(paren
id|pdi-&gt;sid_data
)paren
comma
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid
comma
r_sizeof
(paren
id|senseid_t
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.unknown
)paren
(brace
id|pdi-&gt;status
op_assign
id|DEVSTAT_UNKNOWN_DEV
suffix:semicolon
id|memset
c_func
(paren
op_amp
(paren
id|pdi-&gt;sid_data
)paren
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|senseid_t
)paren
)paren
suffix:semicolon
id|pdi-&gt;sid_data.cu_type
op_assign
l_int|0xFFFF
suffix:semicolon
)brace
r_else
(brace
id|pdi-&gt;status
op_assign
id|DEVSTAT_NOT_OPER
suffix:semicolon
id|memset
c_func
(paren
op_amp
(paren
id|pdi-&gt;sid_data
)paren
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|senseid_t
)paren
)paren
suffix:semicolon
id|pdi-&gt;sid_data.cu_type
op_assign
l_int|0xFFFF
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
id|pdi-&gt;status
op_or_assign
id|DEVSTAT_DEVICE_OWNED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_dev_info_by_devno
r_int
id|get_dev_info_by_devno
c_func
(paren
id|__u16
id|devno
comma
id|s390_dev_info_t
op_star
id|pdi
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|devno
OG
l_int|0x0000ffff
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|pdi
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|highest_subchannel
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|i
)braket
op_ne
id|INVALID_STORAGE_AREA
op_logical_and
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
op_eq
id|devno
)paren
(brace
id|pdi-&gt;irq
op_assign
id|i
suffix:semicolon
id|pdi-&gt;devno
op_assign
id|devno
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_logical_and
op_logical_neg
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|ui.flags.unknown
)paren
(brace
id|pdi-&gt;status
op_assign
l_int|0
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
(paren
id|pdi-&gt;sid_data
)paren
comma
op_amp
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|senseid
comma
r_sizeof
(paren
id|senseid_t
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|ui.flags.unknown
)paren
(brace
id|pdi-&gt;status
op_assign
id|DEVSTAT_UNKNOWN_DEV
suffix:semicolon
id|memset
c_func
(paren
op_amp
(paren
id|pdi-&gt;sid_data
)paren
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|senseid_t
)paren
)paren
suffix:semicolon
id|pdi-&gt;sid_data.cu_type
op_assign
l_int|0xFFFF
suffix:semicolon
)brace
r_else
(brace
id|pdi-&gt;status
op_assign
id|DEVSTAT_NOT_OPER
suffix:semicolon
id|memset
c_func
(paren
op_amp
(paren
id|pdi-&gt;sid_data
)paren
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|senseid_t
)paren
)paren
suffix:semicolon
id|pdi-&gt;sid_data.cu_type
op_assign
l_int|0xFFFF
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
id|pdi-&gt;status
op_or_assign
id|DEVSTAT_DEVICE_OWNED
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* found */
r_break
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endfor */
r_return
id|rc
suffix:semicolon
)brace
DECL|function|get_irq_by_devno
r_int
id|get_irq_by_devno
c_func
(paren
id|__u16
id|devno
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|rc
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|devno
op_le
l_int|0x0000ffff
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|highest_subchannel
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|ioinfo
(braket
id|i
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
op_eq
id|devno
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|schib.pmcw.dnv
op_eq
l_int|1
)paren
)paren
(brace
id|rc
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endfor */
)brace
multiline_comment|/* endif */
r_return
id|rc
suffix:semicolon
)brace
DECL|function|get_devno_by_irq
r_int
r_int
id|get_devno_by_irq
c_func
(paren
r_int
id|irq
)paren
(brace
r_if
c_cond
(paren
(paren
id|irq
OG
id|highest_subchannel
)paren
op_logical_or
(paren
id|irq
OL
l_int|0
)paren
op_logical_or
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t; * we don&squot;t need to check for the device be operational&n;&t; *  as the initial STSCH will always present the device&n;&t; *  number defined by the IOCDS regardless of the device&n;&t; *  existing or not. However, there could be subchannels&n;&t; *  defined who&squot;s device number isn&squot;t valid ...&n;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dnv
)paren
r_return
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
suffix:semicolon
r_else
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * s390_device_recognition_irq&n; *&n; * Used for individual device recognition. Issues the device&n; *  independant SenseID command to obtain info the device type.&n; *&n; */
DECL|function|s390_device_recognition_irq
r_void
id|s390_device_recognition_irq
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
id|ret
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
l_string|&quot;devrec&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dbf_txt
comma
l_string|&quot;%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We issue the SenseID command on I/O subchannels we think are&n;&t; *  operational only.&n;&t; */
r_if
c_cond
(paren
(paren
id|ioinfo
(braket
id|irq
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.st
op_eq
l_int|0
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_eq
l_int|1
)paren
)paren
(brace
r_int
id|irq_ret
suffix:semicolon
id|devstat_t
id|devstat
suffix:semicolon
id|irq_ret
op_assign
id|request_irq
c_func
(paren
id|irq
comma
id|init_IRQ_handler
comma
id|SA_PROBE
comma
l_string|&quot;INIT&quot;
comma
op_amp
id|devstat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|irq_ret
)paren
(brace
id|ret
op_assign
id|enable_cpu_sync_isc
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.unknown
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|senseid_t
)paren
)paren
suffix:semicolon
id|s390_SenseID
c_func
(paren
id|irq
comma
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid
comma
l_int|0xff
)paren
suffix:semicolon
macro_line|#if 0&t;/* FIXME */
multiline_comment|/*&n;&t;&t;&t;&t; * We initially check the configuration data for&n;&t;&t;&t;&t; *  those devices with more than a single path&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pim
op_ne
l_int|0x80
)paren
(brace
r_char
op_star
id|prcd
suffix:semicolon
r_int
id|lrcd
suffix:semicolon
id|ret
op_assign
id|read_conf_data
c_func
(paren
id|irq
comma
(paren
r_void
op_star
op_star
)paren
op_amp
id|prcd
comma
op_amp
id|lrcd
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
singleline_comment|// on success only ...
(brace
r_char
id|buffer
(braket
l_int|80
)braket
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_IO
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;RCD for device(%04X)/&quot;
l_string|&quot;subchannel(%04X) returns :&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
)paren
suffix:semicolon
id|s390_displayhex
c_func
(paren
id|buffer
comma
id|prcd
comma
id|lrcd
)paren
suffix:semicolon
macro_line|#endif      &t;&t;&t;&t;
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;RCD for device(%04X)/&quot;
l_string|&quot;subchannel(%04X) returns :&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
)paren
suffix:semicolon
id|s390_displayhex2
c_func
(paren
id|buffer
comma
id|prcd
comma
id|lrcd
comma
l_int|2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
(brace
id|kfree
c_func
(paren
id|prcd
)paren
suffix:semicolon
)brace
r_else
(brace
id|free_bootmem
c_func
(paren
(paren
r_int
r_int
)paren
id|prcd
comma
id|lrcd
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
macro_line|#endif
id|disable_cpu_sync_isc
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
id|free_irq
c_func
(paren
id|irq
comma
op_amp
id|devstat
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/*&n; * s390_device_recognition_all&n; *&n; * Used for system wide device recognition.&n; *&n; */
DECL|function|s390_device_recognition_all
r_void
id|s390_device_recognition_all
c_func
(paren
r_void
)paren
(brace
r_int
id|irq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* let&squot;s start with subchannel 0 ... */
r_do
(brace
id|s390_device_recognition_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|irq
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|irq
op_le
id|highest_subchannel
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function: s390_redo_validation&n; * Look for no longer blacklisted devices&n; * FIXME: there must be a better way to do this...&n; */
DECL|function|s390_redo_validation
r_void
id|s390_redo_validation
c_func
(paren
r_void
)paren
(brace
r_int
id|irq
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|0
comma
l_string|&quot;redoval&quot;
)paren
suffix:semicolon
)brace
r_do
(brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
(brace
id|ret
op_assign
id|s390_validate_subchannel
c_func
(paren
id|irq
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|s390_device_recognition_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
)paren
(brace
id|devreg_t
op_star
id|pdevreg
suffix:semicolon
id|pdevreg
op_assign
id|s390_search_devreg
c_func
(paren
id|ioinfo
(braket
id|irq
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pdevreg
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|pdevreg-&gt;oper_func
op_ne
l_int|NULL
)paren
id|pdevreg
op_member_access_from_pointer
id|oper_func
c_func
(paren
id|irq
comma
id|pdevreg
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cio_proc_devinfo
)paren
r_if
c_cond
(paren
id|irq
OL
id|MAX_CIO_PROCFS_ENTRIES
)paren
(brace
id|cio_procfs_device_create
c_func
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devno
)paren
suffix:semicolon
)brace
)brace
)brace
id|irq
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|irq
op_le
id|highest_subchannel
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * s390_search_devices&n; *&n; * Determines all subchannels available to the system.&n; *&n; */
DECL|function|s390_process_subchannels
r_void
id|s390_process_subchannels
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|irq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Evaluate all subchannels starting with 0 ... */
r_do
(brace
id|ret
op_assign
id|s390_validate_subchannel
c_func
(paren
id|irq
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
op_minus
id|ENXIO
)paren
id|irq
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|ret
op_ne
op_minus
id|ENXIO
)paren
op_logical_and
(paren
id|irq
OL
id|__MAX_SUBCHANNELS
)paren
)paren
suffix:semicolon
id|highest_subchannel
op_assign
(paren
op_decrement
id|irq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Highest subchannel number detected (hex) : %04X&bslash;n&quot;
comma
id|highest_subchannel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|0
comma
l_string|&quot;Highest subchannel number detected (hex) : %04X&bslash;n&quot;
comma
id|highest_subchannel
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * s390_validate_subchannel()&n; *&n; * Process the subchannel for the requested irq. Returns 1 for valid&n; *  subchannels, otherwise 0.&n; */
DECL|function|s390_validate_subchannel
r_int
id|s390_validate_subchannel
c_func
(paren
r_int
id|irq
comma
r_int
id|enable
)paren
(brace
r_int
id|retry
suffix:semicolon
multiline_comment|/* retry count for status pending conditions */
r_int
id|ccode
suffix:semicolon
multiline_comment|/* condition code for stsch() only */
r_int
id|ccode2
suffix:semicolon
multiline_comment|/* condition code for other I/O routines */
id|schib_t
op_star
id|p_schib
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
l_string|&quot;valsch&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dbf_txt
comma
l_string|&quot;%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The first subchannel that is not-operational (ccode==3)&n;&t; *  indicates that there aren&squot;t any more devices available.&n;&t; */
r_if
c_cond
(paren
(paren
id|init_IRQ_complete
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
)paren
(brace
id|p_schib
op_assign
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
suffix:semicolon
)brace
r_else
(brace
id|p_schib
op_assign
id|p_init_schib
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t; * If we knew the device before we assume the worst case ... &t;&n;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.dval
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
id|ccode
op_assign
id|stsch
c_func
(paren
id|irq
comma
id|p_schib
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ccode
)paren
(brace
multiline_comment|/*&n;&t;&t; * ... just being curious we check for non I/O subchannels&n;&t;&t; */
r_if
c_cond
(paren
id|p_schib-&gt;pmcw.st
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Subchannel %04X reports &quot;
l_string|&quot;non-I/O subchannel type %04X&bslash;n&quot;
comma
id|irq
comma
id|p_schib-&gt;pmcw.st
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|0
comma
l_string|&quot;Subchannel %04X reports non-I/O subchannel type %04X&bslash;n&quot;
comma
id|irq
comma
id|p_schib-&gt;pmcw.st
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|p_schib-&gt;pmcw.dnv
)paren
(brace
r_if
c_cond
(paren
id|is_blacklisted
c_func
(paren
id|p_schib-&gt;pmcw.dev
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;   * This device must not be known to Linux. So we simply say that &n;&t;&t;&t;   * there is no device and return ENODEV.&n;&t;&t;&t;   */
macro_line|#ifdef CONFIG_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;Blacklisted device detected at devno %04X&bslash;n&quot;
comma
id|p_schib-&gt;pmcw.dev
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|0
comma
l_string|&quot;Blacklisted device detected at devno %04X&bslash;n&quot;
comma
id|p_schib-&gt;pmcw.dev
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|init_IRQ_complete
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_assign
(paren
id|ioinfo_t
op_star
)paren
id|alloc_bootmem_low
c_func
(paren
r_sizeof
(paren
id|ioinfo_t
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_assign
(paren
id|ioinfo_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|ioinfo_t
)paren
comma
id|GFP_DMA
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
id|memset
c_func
(paren
id|ioinfo
(braket
id|irq
)braket
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|ioinfo_t
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
comma
id|p_init_schib
comma
r_sizeof
(paren
id|schib_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * We have to insert the new ioinfo element&n;&t;&t;&t;&t; *  into the linked list, either at its head,&n;&t;&t;&t;&t; *  its tail or insert it.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ioinfo_head
op_eq
l_int|NULL
)paren
multiline_comment|/* first element */
(brace
id|ioinfo_head
op_assign
id|ioinfo
(braket
id|irq
)braket
suffix:semicolon
id|ioinfo_tail
op_assign
id|ioinfo
(braket
id|irq
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|irq
OL
id|ioinfo_head-&gt;irq
)paren
multiline_comment|/* new head */
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|next
op_assign
id|ioinfo_head
suffix:semicolon
id|ioinfo_head-&gt;prev
op_assign
id|ioinfo
(braket
id|irq
)braket
suffix:semicolon
id|ioinfo_head
op_assign
id|ioinfo
(braket
id|irq
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|irq
OG
id|ioinfo_tail-&gt;irq
)paren
multiline_comment|/* new tail */
(brace
id|ioinfo_tail-&gt;next
op_assign
id|ioinfo
(braket
id|irq
)braket
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|prev
op_assign
id|ioinfo_tail
suffix:semicolon
id|ioinfo_tail
op_assign
id|ioinfo
(braket
id|irq
)braket
suffix:semicolon
)brace
r_else
multiline_comment|/* insert element */
(brace
id|ioinfo_t
op_star
id|pi
op_assign
id|ioinfo_head
suffix:semicolon
r_for
c_loop
(paren
id|pi
op_assign
id|ioinfo_head
suffix:semicolon
id|pi
op_ne
l_int|NULL
suffix:semicolon
id|pi
op_assign
id|pi-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|irq
OL
id|pi-&gt;next-&gt;irq
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|next
op_assign
id|pi-&gt;next
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|prev
op_assign
id|pi
suffix:semicolon
id|pi-&gt;next-&gt;prev
op_assign
id|ioinfo
(braket
id|irq
)braket
suffix:semicolon
id|pi-&gt;next
op_assign
id|ioinfo
(braket
id|irq
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
singleline_comment|// initialize some values ...&t;
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.pgid_supp
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pim
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pam
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pom
suffix:semicolon
r_if
c_cond
(paren
id|cio_show_msg
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Detected device %04X &quot;
l_string|&quot;on subchannel %04X&quot;
l_string|&quot; - PIM = %02X, PAM = %02X, POM = %02X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pim
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pam
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pom
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|0
comma
l_string|&quot;Detected device %04X &quot;
l_string|&quot;on subchannel %04X&quot;
l_string|&quot; - PIM = %02X, PAM = %02X, POM = %02X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pim
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pam
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pom
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * initialize ioinfo structure&n;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq
op_assign
id|irq
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|nopfunc
op_assign
l_int|NULL
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.dval
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.intparm
op_assign
l_int|0
suffix:semicolon
)brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devno
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We should have at least one CHPID ...&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * We now have to initially ...&n;&t;&t;&t;&t; *  ... set &quot;interruption sublass&quot;&n;&t;&t;&t;&t; *  ... enable &quot;concurrent sense&quot;&n;&t;&t;&t;&t; *  ... enable &quot;multipath mode&quot; if more than one&n;&t;&t;&t;&t; *        CHPID is available. This is done regardless&n;&t;&t;&t;&t; *        whether multiple paths are available for us.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * Note : we don&squot;t enable the device here, this is temporarily&n;&t;&t;&t;&t; *        done during device sensing below.&n;&t;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.isc
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* could be smth. else */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.csense
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* concurrent sense */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.ena
op_assign
id|enable
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.intparm
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_ne
l_int|0x80
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_ne
l_int|0x40
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_ne
l_int|0x20
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_ne
l_int|0x10
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_ne
l_int|0x08
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_ne
l_int|0x04
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_ne
l_int|0x02
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_ne
l_int|0x01
)paren
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.mp
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* multipath mode */
)brace
multiline_comment|/* endif */
id|retry
op_assign
l_int|5
suffix:semicolon
r_do
(brace
id|ccode2
op_assign
id|msch_err
c_func
(paren
id|irq
comma
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode2
)paren
(brace
r_case
l_int|0
suffix:colon
singleline_comment|// successful completion
singleline_comment|//
singleline_comment|// concurrent sense facility available ...
singleline_comment|//
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.consns
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
singleline_comment|// status pending
singleline_comment|//
singleline_comment|// How can we have a pending status as
singleline_comment|//  device is disabled for interrupts ?
singleline_comment|//  Anyway, process it ...
singleline_comment|//
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|1
suffix:semicolon
id|s390_process_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|0
suffix:semicolon
id|retry
op_decrement
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
singleline_comment|// busy
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * we mark it not-oper as we can&squot;t&n;&t;&t;&t;&t;&t;&t; *  properly operate it !&n;&t;&t;&t;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* allow for recovery */
id|retry
op_decrement
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
singleline_comment|// not operational
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|retry
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
DECL|macro|PGMCHK_OPERAND_EXC
mdefine_line|#define PGMCHK_OPERAND_EXC      0x15
r_if
c_cond
(paren
(paren
id|ccode2
op_amp
id|PGMCHK_OPERAND_EXC
)paren
op_eq
id|PGMCHK_OPERAND_EXC
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;&t; * re-issue the modify subchannel without trying to&n;&t;&t;&t;&t;&t;&t;&t; *  enable the concurrent sense facility&n;&t;&t;&t;&t;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.csense
op_assign
l_int|0
suffix:semicolon
id|ccode2
op_assign
id|msch_err
c_func
(paren
id|irq
comma
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccode2
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; ... msch() (2) failed with CC = %X&bslash;n&quot;
comma
id|ccode2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|0
comma
l_string|&quot;msch() (2) failed with CC=%X&bslash;n&quot;
comma
id|ccode2
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.consns
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot; ... msch() (1) failed with CC = %X&bslash;n&quot;
comma
id|ccode2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|0
comma
l_string|&quot;msch() (1) failed with CC = %X&bslash;n&quot;
comma
id|ccode2
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* endif */
id|retry
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
)brace
r_while
c_loop
(paren
id|ccode2
op_logical_and
id|retry
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ccode2
op_ne
l_int|0
)paren
op_logical_and
(paren
id|ccode2
op_ne
l_int|3
)paren
op_logical_and
(paren
op_logical_neg
id|retry
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; ... msch() retry count for &quot;
l_string|&quot;subchannel %04X exceeded, CC = %d&bslash;n&quot;
comma
id|irq
comma
id|ccode2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|0
comma
l_string|&quot; ... msch() retry count for &quot;
l_string|&quot;subchannel %04X exceeded, CC = %d&bslash;n&quot;
comma
id|irq
comma
id|ccode2
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
multiline_comment|/* no path available ... */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * s390_SenseID&n; *&n; * Try to obtain the &squot;control unit&squot;/&squot;device type&squot; information&n; *  associated with the subchannel.&n; *&n; * The function is primarily meant to be called without irq&n; *  action handler in place. However, it also allows for&n; *  use with an action handler in place. If there is already&n; *  an action handler registered assure it can handle the&n; *  s390_SenseID() related device interrupts - interruption&n; *  parameter used is 0x00E2C9C4 ( SID ).&n; */
DECL|function|s390_SenseID
r_int
id|s390_SenseID
c_func
(paren
r_int
id|irq
comma
id|senseid_t
op_star
id|sid
comma
id|__u8
id|lpm
)paren
(brace
id|ccw1_t
op_star
id|sense_ccw
suffix:semicolon
multiline_comment|/* ccw area for SenseID command */
id|senseid_t
id|isid
suffix:semicolon
multiline_comment|/* internal sid */
id|devstat_t
id|devstat
suffix:semicolon
multiline_comment|/* required by request_irq() */
id|__u8
id|pathmask
suffix:semicolon
multiline_comment|/* calulate path mask */
id|__u8
id|domask
suffix:semicolon
multiline_comment|/* path mask to use */
r_int
id|inlreq
suffix:semicolon
multiline_comment|/* inline request_irq() */
r_int
id|irq_ret
suffix:semicolon
multiline_comment|/* return code */
id|devstat_t
op_star
id|pdevstat
suffix:semicolon
multiline_comment|/* ptr to devstat in use */
r_int
id|retry
suffix:semicolon
multiline_comment|/* retry count */
r_int
id|io_retry
suffix:semicolon
multiline_comment|/* retry indicator */
id|senseid_t
op_star
id|psid
op_assign
id|sid
suffix:semicolon
multiline_comment|/* start with the external buffer */
r_int
id|sbuffer
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* switch SID data buffer */
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
r_int
id|failure
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* nothing went wrong yet */
id|SANITY_CHECK
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
l_string|&quot;snsID&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dbf_txt
comma
l_string|&quot;%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
)brace
id|inlreq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* to make the compiler quiet... */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
id|pdevstat
op_assign
op_amp
id|devstat
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Perform SENSE ID command processing. We have to request device&n;&t;&t; *  ownership and provide a dummy I/O handler. We issue sync. I/O&n;&t;&t; *  requests and evaluate the devstat area on return therefore&n;&t;&t; *  we don&squot;t need a real I/O handler in place.&n;&t;&t; */
id|irq_ret
op_assign
id|request_irq
c_func
(paren
id|irq
comma
id|init_IRQ_handler
comma
id|SA_PROBE
comma
l_string|&quot;SID&quot;
comma
op_amp
id|devstat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_ret
op_eq
l_int|0
)paren
id|inlreq
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|inlreq
op_assign
l_int|0
suffix:semicolon
id|irq_ret
op_assign
l_int|0
suffix:semicolon
id|pdevstat
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|irq_ret
op_eq
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
id|s390irq_spin_lock
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
(brace
id|sense_ccw
op_assign
id|kmalloc
c_func
(paren
l_int|2
op_star
r_sizeof
(paren
id|ccw1_t
)paren
comma
id|GFP_DMA
)paren
suffix:semicolon
)brace
r_else
(brace
id|sense_ccw
op_assign
id|alloc_bootmem_low
c_func
(paren
l_int|2
op_star
r_sizeof
(paren
id|ccw1_t
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
singleline_comment|// more than one path installed ?
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pim
op_ne
l_int|0x80
)paren
(brace
id|sense_ccw
(braket
l_int|0
)braket
dot
id|cmd_code
op_assign
id|CCW_CMD_SUSPEND_RECONN
suffix:semicolon
id|sense_ccw
(braket
l_int|0
)braket
dot
id|cda
op_assign
l_int|0
suffix:semicolon
id|sense_ccw
(braket
l_int|0
)braket
dot
id|count
op_assign
l_int|0
suffix:semicolon
id|sense_ccw
(braket
l_int|0
)braket
dot
id|flags
op_assign
id|CCW_FLAG_SLI
op_or
id|CCW_FLAG_CC
suffix:semicolon
id|sense_ccw
(braket
l_int|1
)braket
dot
id|cmd_code
op_assign
id|CCW_CMD_SENSE_ID
suffix:semicolon
id|sense_ccw
(braket
l_int|1
)braket
dot
id|cda
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
c_func
(paren
id|sid
)paren
suffix:semicolon
id|sense_ccw
(braket
l_int|1
)braket
dot
id|count
op_assign
r_sizeof
(paren
id|senseid_t
)paren
suffix:semicolon
id|sense_ccw
(braket
l_int|1
)braket
dot
id|flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
)brace
r_else
(brace
id|sense_ccw
(braket
l_int|0
)braket
dot
id|cmd_code
op_assign
id|CCW_CMD_SENSE_ID
suffix:semicolon
id|sense_ccw
(braket
l_int|0
)braket
dot
id|cda
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
c_func
(paren
id|sid
)paren
suffix:semicolon
id|sense_ccw
(braket
l_int|0
)braket
dot
id|count
op_assign
r_sizeof
(paren
id|senseid_t
)paren
suffix:semicolon
id|sense_ccw
(braket
l_int|0
)braket
dot
id|flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
)brace
multiline_comment|/* endif */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
l_int|8
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pathmask
op_assign
l_int|0x80
op_rshift
id|i
suffix:semicolon
id|domask
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_amp
id|pathmask
suffix:semicolon
r_if
c_cond
(paren
id|lpm
)paren
id|domask
op_and_assign
id|lpm
suffix:semicolon
r_if
c_cond
(paren
id|domask
)paren
(brace
id|failure
op_assign
l_int|0
suffix:semicolon
id|psid-&gt;reserved
op_assign
l_int|0
suffix:semicolon
id|psid-&gt;cu_type
op_assign
l_int|0xFFFF
suffix:semicolon
multiline_comment|/* initialize fields ... */
id|psid-&gt;cu_model
op_assign
l_int|0
suffix:semicolon
id|psid-&gt;dev_type
op_assign
l_int|0
suffix:semicolon
id|psid-&gt;dev_model
op_assign
l_int|0
suffix:semicolon
id|retry
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* retry count    */
id|io_retry
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* enable retries */
multiline_comment|/*&n;&t;&t;&t;&t; * We now issue a SenseID request. In case of BUSY,&n;&t;&t;&t;&t; *  STATUS PENDING or non-CMD_REJECT error conditions&n;&t;&t;&t;&t; *  we run simple retries.&n;&t;&t;&t;&t; */
r_do
(brace
id|memset
c_func
(paren
id|pdevstat
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|devstat_t
)paren
)paren
suffix:semicolon
id|irq_ret
op_assign
id|s390_start_IO
c_func
(paren
id|irq
comma
id|sense_ccw
comma
l_int|0x00E2C9C4
comma
singleline_comment|// == SID
id|domask
comma
id|DOIO_WAIT_FOR_INTERRUPT
op_or
id|DOIO_TIMEOUT
op_or
id|DOIO_VALID_LPM
op_or
id|DOIO_DONT_CALL_INTHDLR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|psid-&gt;cu_type
op_eq
l_int|0xFFFF
)paren
(brace
id|failure
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pdevstat-&gt;flag
op_amp
id|DEVSTAT_STATUS_PENDING
)paren
(brace
macro_line|#ifdef CONFIG_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;SenseID : device %04X on &quot;
l_string|&quot;Subchannel %04X &quot;
l_string|&quot;reports pending status, &quot;
l_string|&quot;retry : %d&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
comma
id|retry
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|2
comma
l_string|&quot;SenseID : device %04X on &quot;
l_string|&quot;Subchannel %04X &quot;
l_string|&quot;reports pending status, &quot;
l_string|&quot;retry : %d&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
comma
id|retry
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|pdevstat-&gt;flag
op_amp
id|DEVSTAT_FLAG_SENSE_AVAIL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;&t; * if the device doesn&squot;t support the SenseID&n;&t;&t;&t;&t;&t;&t;&t; *  command further retries wouldn&squot;t help ...&n;&t;&t;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|pdevstat-&gt;ii.sense.data
(braket
l_int|0
)braket
op_amp
(paren
id|SNS0_CMD_REJECT
op_or
id|SNS0_INTERVENTION_REQ
)paren
)paren
(brace
macro_line|#ifdef CONFIG_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;SenseID : device %04X on &quot;
l_string|&quot;Subchannel %04X &quot;
l_string|&quot;reports cmd reject or &quot;
l_string|&quot;intervention required&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|2
comma
l_string|&quot;SenseID : device %04X on &quot;
l_string|&quot;Subchannel %04X &quot;
l_string|&quot;reports cmd reject or &quot;
l_string|&quot;intervention required&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
)paren
suffix:semicolon
id|io_retry
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef CONFIG_DEBUG_IO&t;&t;&t;&t;&t;&t;&t;
id|printk
c_func
(paren
l_string|&quot;SenseID : UC on &quot;
l_string|&quot;dev %04X, &quot;
l_string|&quot;retry %d, &quot;
l_string|&quot;lpum %02X, &quot;
l_string|&quot;cnt %02d, &quot;
l_string|&quot;sns :&quot;
l_string|&quot; %02X%02X%02X%02X &quot;
l_string|&quot;%02X%02X%02X%02X ...&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|retry
comma
id|pdevstat-&gt;lpum
comma
id|pdevstat-&gt;scnt
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|0
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|1
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|2
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|3
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|4
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|5
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|6
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|7
)braket
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|2
comma
l_string|&quot;SenseID : UC on &quot;
l_string|&quot;dev %04X, &quot;
l_string|&quot;retry %d, &quot;
l_string|&quot;lpum %02X, &quot;
l_string|&quot;cnt %02d, &quot;
l_string|&quot;sns :&quot;
l_string|&quot; %02X%02X%02X%02X &quot;
l_string|&quot;%02X%02X%02X%02X ...&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|retry
comma
id|pdevstat-&gt;lpum
comma
id|pdevstat-&gt;scnt
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|0
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|1
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|2
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|3
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|4
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|5
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|6
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|7
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|psid-&gt;reserved
op_ne
l_int|0xFF
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|2
comma
l_string|&quot;SenseID was not properly &quot;
l_string|&quot;executed!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* endif */
)brace
r_else
r_if
c_cond
(paren
(paren
id|pdevstat-&gt;flag
op_amp
id|DEVSTAT_NOT_OPER
)paren
op_logical_or
(paren
id|irq_ret
op_eq
op_minus
id|ENODEV
)paren
)paren
(brace
macro_line|#ifdef CONFIG_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;SenseID : path %02X for &quot;
l_string|&quot;device %04X on &quot;
l_string|&quot;subchannel %04X &quot;
l_string|&quot;is &squot;not operational&squot;&bslash;n&quot;
comma
id|domask
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|2
comma
l_string|&quot;SenseID : path %02X for &quot;
l_string|&quot;device %04X on &quot;
l_string|&quot;subchannel %04X &quot;
l_string|&quot;is &squot;not operational&squot;&bslash;n&quot;
comma
id|domask
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
)paren
suffix:semicolon
id|io_retry
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_and_assign
op_complement
id|domask
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|pdevstat-&gt;flag
op_ne
(paren
id|DEVSTAT_START_FUNCTION
op_or
id|DEVSTAT_FINAL_STATUS
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|pdevstat-&gt;flag
op_amp
id|DEVSTAT_STATUS_PENDING
)paren
)paren
(brace
macro_line|#ifdef CONFIG_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;SenseID : start_IO() for &quot;
l_string|&quot;device %04X on &quot;
l_string|&quot;subchannel %04X &quot;
l_string|&quot;returns %d, retry %d, &quot;
l_string|&quot;status %04X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
comma
id|irq_ret
comma
id|retry
comma
id|pdevstat-&gt;flag
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|2
comma
l_string|&quot;SenseID : start_IO() for &quot;
l_string|&quot;device %04X on &quot;
l_string|&quot;subchannel %04X &quot;
l_string|&quot;returns %d, retry %d, &quot;
l_string|&quot;status %04X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
comma
id|irq_ret
comma
id|retry
comma
id|pdevstat-&gt;flag
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
singleline_comment|// we got it ...
(brace
r_if
c_cond
(paren
id|psid-&gt;reserved
op_ne
l_int|0xFF
)paren
(brace
multiline_comment|/* No, we failed after all... */
id|failure
op_assign
l_int|1
suffix:semicolon
id|retry
op_decrement
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|sbuffer
)paren
singleline_comment|// switch buffers
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;&t;&t; * we report back the&n;&t;&t;&t;&t;&t;&t;&t;&t; *  first hit only&n;&t;&t;&t;&t;&t;&t;&t;&t; */
id|psid
op_assign
op_amp
id|isid
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pim
op_ne
l_int|0x80
)paren
(brace
id|sense_ccw
(braket
l_int|1
)braket
dot
id|cda
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
c_func
(paren
id|psid
)paren
suffix:semicolon
)brace
r_else
(brace
id|sense_ccw
(braket
l_int|0
)braket
dot
id|cda
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
c_func
(paren
id|psid
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;&t;&t; * if just the very first&n;&t;&t;&t;&t;&t;&t;&t;&t; *  was requested to be&n;&t;&t;&t;&t;&t;&t;&t;&t; *  sensed disable further&n;&t;&t;&t;&t;&t;&t;&t;&t; *  scans.&n;&t;&t;&t;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|lpm
)paren
id|lpm
op_assign
id|domask
suffix:semicolon
id|sbuffer
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|pdevstat-&gt;rescnt
OL
(paren
r_sizeof
(paren
id|senseid_t
)paren
op_minus
l_int|8
)paren
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.esid
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
id|io_retry
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|io_retry
)paren
(brace
id|retry
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|retry
op_eq
l_int|0
)paren
(brace
id|io_retry
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
(paren
id|failure
)paren
op_logical_and
(paren
id|io_retry
)paren
)paren
(brace
multiline_comment|/* reset fields... */
id|failure
op_assign
l_int|0
suffix:semicolon
id|psid-&gt;reserved
op_assign
l_int|0
suffix:semicolon
id|psid-&gt;cu_type
op_assign
l_int|0xFFFF
suffix:semicolon
id|psid-&gt;cu_model
op_assign
l_int|0
suffix:semicolon
id|psid-&gt;dev_type
op_assign
l_int|0
suffix:semicolon
id|psid-&gt;dev_model
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|io_retry
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* endif - domask */
)brace
multiline_comment|/* endfor */
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
(brace
id|kfree
c_func
(paren
id|sense_ccw
)paren
suffix:semicolon
)brace
r_else
(brace
id|free_bootmem
c_func
(paren
(paren
r_int
r_int
)paren
id|sense_ccw
comma
l_int|2
op_star
r_sizeof
(paren
id|ccw1_t
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
id|s390irq_spin_unlock
c_func
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we installed the irq action handler we have to&n;&t;&t; *  release it too.&n;&t;&t; */
r_if
c_cond
(paren
id|inlreq
)paren
id|free_irq
c_func
(paren
id|irq
comma
id|pdevstat
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if running under VM check there ... perhaps we should do&n;&t;&t; *  only if we suffered a command reject, but it doesn&squot;t harm&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|sid-&gt;cu_type
op_eq
l_int|0xFFFF
)paren
op_logical_and
(paren
id|MACHINE_IS_VM
)paren
)paren
(brace
id|VM_virtual_device_info
c_func
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|sid
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|sid-&gt;cu_type
op_eq
l_int|0xFFFF
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * SenseID CU-type of 0xffff indicates that no device&n;&t;&t;&t; *  information could be retrieved (pre-init value).&n;&t;&t;&t; *&n;&t;&t;&t; * If we can&squot;t couldn&squot;t identify the device type we&n;&t;&t;&t; *  consider the device &quot;not operational&quot;.&n;&t;&t;&t; */
macro_line|#ifdef CONFIG_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;SenseID : unknown device %04X on subchannel %04X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|2
comma
l_string|&quot;SenseID : unknown device %04X on subchannel %04X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.unknown
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t; * Issue device info message if unit was operational .&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.unknown
)paren
(brace
r_if
c_cond
(paren
id|sid-&gt;dev_type
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|cio_show_msg
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;SenseID : device %04X reports: &quot;
l_string|&quot;CU  Type/Mod = %04X/%02X,&quot;
l_string|&quot; Dev Type/Mod = %04X/%02X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|sid-&gt;cu_type
comma
id|sid-&gt;cu_model
comma
id|sid-&gt;dev_type
comma
id|sid-&gt;dev_model
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|2
comma
l_string|&quot;SenseID : device %04X reports: &quot;
l_string|&quot;CU  Type/Mod = %04X/%02X,&quot;
l_string|&quot; Dev Type/Mod = %04X/%02X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|sid-&gt;cu_type
comma
id|sid-&gt;cu_model
comma
id|sid-&gt;dev_type
comma
id|sid-&gt;dev_model
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|cio_show_msg
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;SenseID : device %04X reports:&quot;
l_string|&quot; Dev Type/Mod = %04X/%02X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|sid-&gt;cu_type
comma
id|sid-&gt;cu_model
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|2
comma
l_string|&quot;SenseID : device %04X reports:&quot;
l_string|&quot; Dev Type/Mod = %04X/%02X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|sid-&gt;cu_type
comma
id|sid-&gt;cu_model
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.unknown
)paren
id|irq_ret
op_assign
l_int|0
suffix:semicolon
r_else
id|irq_ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|irq_ret
suffix:semicolon
)brace
DECL|function|s390_SetMultiPath
r_static
r_int
id|__inline__
id|s390_SetMultiPath
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
id|cc
suffix:semicolon
id|cc
op_assign
id|stsch
c_func
(paren
id|irq
comma
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cc
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.mp
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* multipath mode */
id|cc
op_assign
id|msch
c_func
(paren
id|irq
comma
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|cc
suffix:semicolon
)brace
multiline_comment|/*&n; * Device Path Verification&n; *&n; * Path verification is accomplished by checking which paths (CHPIDs) are&n; *  available. Further, a path group ID is set, if possible in multipath&n; *  mode, otherwise in single path mode.&n; *&n; * Note : This function must not be called during normal device recognition,&n; *         but during device driver initiated request_irq() processing only.&n; */
DECL|function|s390_DevicePathVerification
r_int
id|s390_DevicePathVerification
c_func
(paren
r_int
id|irq
comma
id|__u8
id|usermask
)paren
(brace
r_int
id|ccode
suffix:semicolon
id|__u8
id|pathmask
suffix:semicolon
id|__u8
id|domask
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
(brace
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
l_string|&quot;dpver&quot;
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dbf_txt
comma
l_string|&quot;%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|debug_text_event
c_func
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.pgid_supp
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
singleline_comment|// just exit ...
)brace
multiline_comment|/* endif */
id|ccode
op_assign
id|stsch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccode
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pim
op_eq
l_int|0x80
)paren
(brace
multiline_comment|/*&n;&t;&t; * no error, just not required for single path only devices&n;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.pgid_supp
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_int
id|i
suffix:semicolon
id|pgid_t
id|pgid
suffix:semicolon
id|__u8
id|dev_path
suffix:semicolon
r_int
id|first
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pim
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pam
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pom
suffix:semicolon
r_if
c_cond
(paren
id|usermask
)paren
(brace
id|dev_path
op_assign
id|usermask
suffix:semicolon
)brace
r_else
(brace
id|dev_path
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t; * let&squot;s build a path group ID if we don&squot;t have one yet&n;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.pgid
op_eq
l_int|0
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|pgid.cpu_addr
op_assign
op_star
(paren
id|__u16
op_star
)paren
id|__LC_CPUADDR
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|pgid.cpu_id
op_assign
(paren
(paren
id|cpuid_t
op_star
)paren
id|__LC_CPUID
)paren
op_member_access_from_pointer
id|ident
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|pgid.cpu_model
op_assign
(paren
(paren
id|cpuid_t
op_star
)paren
id|__LC_CPUID
)paren
op_member_access_from_pointer
id|machine
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|pgid.tod_high
op_assign
op_star
(paren
id|__u32
op_star
)paren
op_amp
id|irq_IPL_TOD
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.pgid
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
id|memcpy
c_func
(paren
op_amp
id|pgid
comma
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|pgid
comma
r_sizeof
(paren
id|pgid_t
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
op_logical_and
op_logical_neg
id|ret
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pathmask
op_assign
l_int|0x80
op_rshift
id|i
suffix:semicolon
id|domask
op_assign
id|dev_path
op_amp
id|pathmask
suffix:semicolon
r_if
c_cond
(paren
id|domask
)paren
(brace
id|ret
op_assign
id|s390_SetPGID
c_func
(paren
id|irq
comma
id|domask
comma
op_amp
id|pgid
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * For the *first* path we are prepared&n;&t;&t;&t;&t; *  for recovery&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; *  - If we fail setting the PGID we assume its&n;&t;&t;&t;&t; *     using  a different PGID already (VM) we&n;&t;&t;&t;&t; *     try to sense.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EOPNOTSUPP
op_logical_and
id|first
)paren
(brace
op_star
(paren
r_int
op_star
)paren
op_amp
id|pgid
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|s390_SensePGID
c_func
(paren
id|irq
comma
id|domask
comma
op_amp
id|pgid
)paren
suffix:semicolon
id|first
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Check whether we retrieved&n;&t;&t;&t;&t;&t;&t; *  a reasonable PGID ...&n;&t;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|pgid.inf.ps.state1
op_eq
id|SNID_STATE1_GROUPED
)paren
(brace
id|memcpy
c_func
(paren
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|pgid
)paren
comma
op_amp
id|pgid
comma
r_sizeof
(paren
id|pgid_t
)paren
)paren
suffix:semicolon
)brace
r_else
singleline_comment|// ungrouped or garbage ...
(brace
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.pgid_supp
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;PathVerification(%04X) &quot;
l_string|&quot;- Device %04X doesn&squot;t &quot;
l_string|&quot; support path grouping&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|2
comma
l_string|&quot;PathVerification(%04X) &quot;
l_string|&quot;- Device %04X doesn&squot;t &quot;
l_string|&quot; support path grouping&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EIO
)paren
(brace
macro_line|#ifdef CONFIG_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;PathVerification(%04X) - I/O error &quot;
l_string|&quot;on device %04X&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|2
comma
l_string|&quot;PathVerification(%04X) - I/O error &quot;
l_string|&quot;on device %04X&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.pgid_supp
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef CONFIG_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;PathVerification(%04X) &quot;
l_string|&quot;- Unexpected error on device %04X&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|2
comma
l_string|&quot;PathVerification(%04X) - &quot;
l_string|&quot;Unexpected error on device %04X&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.pgid_supp
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endfor */
)brace
multiline_comment|/* endif */
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * s390_SetPGID&n; *&n; * Set Path Group ID&n; *&n; */
DECL|function|s390_SetPGID
r_int
id|s390_SetPGID
c_func
(paren
r_int
id|irq
comma
id|__u8
id|lpm
comma
id|pgid_t
op_star
id|pgid
)paren
(brace
id|ccw1_t
op_star
id|spid_ccw
suffix:semicolon
multiline_comment|/* ccw area for SPID command */
id|devstat_t
id|devstat
suffix:semicolon
multiline_comment|/* required by request_irq() */
id|devstat_t
op_star
id|pdevstat
op_assign
op_amp
id|devstat
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|irq_ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* return code */
r_int
id|retry
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* retry count */
r_int
id|inlreq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* inline request_irq() */
r_int
id|mpath
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* try multi-path first */
id|SANITY_CHECK
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
multiline_comment|/*&n;&t;&t; * Perform SetPGID command processing. We have to request device&n;&t;&t; *  ownership and provide a dummy I/O handler. We issue sync. I/O&n;&t;&t; *  requests and evaluate the devstat area on return therefore&n;&t;&t; *  we don&squot;t need a real I/O handler in place.&n;&t;&t; */
id|irq_ret
op_assign
id|request_irq
c_func
(paren
id|irq
comma
id|init_IRQ_handler
comma
id|SA_PROBE
comma
l_string|&quot;SPID&quot;
comma
id|pdevstat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_ret
op_eq
l_int|0
)paren
id|inlreq
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|pdevstat
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|irq_ret
op_eq
l_int|0
)paren
(brace
id|s390irq_spin_lock_irqsave
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
(brace
id|spid_ccw
op_assign
id|kmalloc
c_func
(paren
l_int|2
op_star
r_sizeof
(paren
id|ccw1_t
)paren
comma
id|GFP_DMA
)paren
suffix:semicolon
)brace
r_else
(brace
id|spid_ccw
op_assign
id|alloc_bootmem_low
c_func
(paren
l_int|2
op_star
r_sizeof
(paren
id|ccw1_t
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
id|spid_ccw
(braket
l_int|0
)braket
dot
id|cmd_code
op_assign
l_int|0x5B
suffix:semicolon
multiline_comment|/* suspend multipath reconnect */
id|spid_ccw
(braket
l_int|0
)braket
dot
id|cda
op_assign
l_int|0
suffix:semicolon
id|spid_ccw
(braket
l_int|0
)braket
dot
id|count
op_assign
l_int|0
suffix:semicolon
id|spid_ccw
(braket
l_int|0
)braket
dot
id|flags
op_assign
id|CCW_FLAG_SLI
op_or
id|CCW_FLAG_CC
suffix:semicolon
id|spid_ccw
(braket
l_int|1
)braket
dot
id|cmd_code
op_assign
id|CCW_CMD_SET_PGID
suffix:semicolon
id|spid_ccw
(braket
l_int|1
)braket
dot
id|cda
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
c_func
(paren
id|pgid
)paren
suffix:semicolon
id|spid_ccw
(braket
l_int|1
)braket
dot
id|count
op_assign
r_sizeof
(paren
id|pgid_t
)paren
suffix:semicolon
id|spid_ccw
(braket
l_int|1
)braket
dot
id|flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
id|pgid-&gt;inf.fc
op_assign
id|SPID_FUNC_MULTI_PATH
op_or
id|SPID_FUNC_ESTABLISH
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We now issue a SetPGID request. In case of BUSY&n;&t;&t; *  or STATUS PENDING conditions we retry 5 times.&n;&t;&t; */
r_do
(brace
id|memset
c_func
(paren
id|pdevstat
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|devstat_t
)paren
)paren
suffix:semicolon
id|irq_ret
op_assign
id|s390_start_IO
c_func
(paren
id|irq
comma
id|spid_ccw
comma
l_int|0xE2D7C9C4
comma
singleline_comment|// == SPID
id|lpm
comma
singleline_comment|// n/a
id|DOIO_WAIT_FOR_INTERRUPT
op_or
id|DOIO_VALID_LPM
op_or
id|DOIO_DONT_CALL_INTHDLR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|irq_ret
)paren
(brace
r_if
c_cond
(paren
id|pdevstat-&gt;flag
op_amp
id|DEVSTAT_STATUS_PENDING
)paren
(brace
macro_line|#ifdef CONFIG_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;SPID - Device %04X &quot;
l_string|&quot;on Subchannel %04X &quot;
l_string|&quot;reports pending status, &quot;
l_string|&quot;retry : %d&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
comma
id|retry
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|2
comma
l_string|&quot;SPID - Device %04X &quot;
l_string|&quot;on Subchannel %04X &quot;
l_string|&quot;reports pending status, &quot;
l_string|&quot;retry : %d&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
comma
id|retry
)paren
suffix:semicolon
id|retry
op_decrement
suffix:semicolon
id|irq_ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|pdevstat-&gt;flag
op_eq
(paren
id|DEVSTAT_START_FUNCTION
op_or
id|DEVSTAT_FINAL_STATUS
)paren
)paren
(brace
id|retry
op_assign
l_int|0
suffix:semicolon
singleline_comment|// successfully set ...
id|irq_ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pdevstat-&gt;flag
op_amp
id|DEVSTAT_FLAG_SENSE_AVAIL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * If the device doesn&squot;t support the&n;&t;&t;&t;&t;&t; *  Sense Path Group ID command&n;&t;&t;&t;&t;&t; *  further retries wouldn&squot;t help ...&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|pdevstat-&gt;ii.sense.data
(braket
l_int|0
)braket
op_amp
id|SNS0_CMD_REJECT
)paren
(brace
r_if
c_cond
(paren
id|mpath
)paren
(brace
id|pgid-&gt;inf.fc
op_assign
id|SPID_FUNC_SINGLE_PATH
op_or
id|SPID_FUNC_ESTABLISH
suffix:semicolon
id|mpath
op_assign
l_int|0
suffix:semicolon
id|retry
op_decrement
suffix:semicolon
id|irq_ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|irq_ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
id|retry
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
macro_line|#ifdef CONFIG_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;SPID - device %04X,&quot;
l_string|&quot; unit check,&quot;
l_string|&quot; retry %d, cnt %02d,&quot;
l_string|&quot; sns :&quot;
l_string|&quot; %02X%02X%02X%02X %02X%02X%02X%02X ...&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|retry
comma
id|pdevstat-&gt;scnt
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|0
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|1
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|2
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|3
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|4
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|5
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|6
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|7
)braket
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|2
comma
l_string|&quot;SPID - device %04X,&quot;
l_string|&quot; unit check,&quot;
l_string|&quot; retry %d, cnt %02d,&quot;
l_string|&quot; sns :&quot;
l_string|&quot; %02X%02X%02X%02X %02X%02X%02X%02X ...&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|retry
comma
id|pdevstat-&gt;scnt
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|0
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|1
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|2
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|3
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|4
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|5
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|6
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|retry
op_decrement
suffix:semicolon
id|irq_ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
r_if
c_cond
(paren
id|pdevstat-&gt;flag
op_amp
id|DEVSTAT_NOT_OPER
)paren
(brace
multiline_comment|/* don&squot;t issue warnings during startup unless requested*/
r_if
c_cond
(paren
id|init_IRQ_complete
op_logical_or
id|cio_notoper_msg
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SPID - Device %04X &quot;
l_string|&quot;on Subchannel %04X &quot;
l_string|&quot;became &squot;not operational&squot;&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|2
comma
l_string|&quot;SPID - Device %04X &quot;
l_string|&quot;on Subchannel %04X &quot;
l_string|&quot;became &squot;not operational&squot;&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
)paren
suffix:semicolon
)brace
id|retry
op_assign
l_int|0
suffix:semicolon
id|irq_ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
r_if
c_cond
(paren
id|irq_ret
op_ne
op_minus
id|ENODEV
)paren
(brace
id|retry
op_decrement
suffix:semicolon
id|irq_ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|retry
op_assign
l_int|0
suffix:semicolon
id|irq_ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_while
c_loop
(paren
id|retry
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
(brace
id|kfree
c_func
(paren
id|spid_ccw
)paren
suffix:semicolon
)brace
r_else
(brace
id|free_bootmem
c_func
(paren
(paren
r_int
r_int
)paren
id|spid_ccw
comma
l_int|2
op_star
r_sizeof
(paren
id|ccw1_t
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
id|s390irq_spin_unlock_irqrestore
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we installed the irq action handler we have to&n;&t;&t; *  release it too.&n;&t;&t; */
r_if
c_cond
(paren
id|inlreq
)paren
id|free_irq
c_func
(paren
id|irq
comma
id|pdevstat
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|irq_ret
suffix:semicolon
)brace
multiline_comment|/*&n; * s390_SensePGID&n; *&n; * Sense Path Group ID&n; *&n; */
DECL|function|s390_SensePGID
r_int
id|s390_SensePGID
c_func
(paren
r_int
id|irq
comma
id|__u8
id|lpm
comma
id|pgid_t
op_star
id|pgid
)paren
(brace
id|ccw1_t
op_star
id|snid_ccw
suffix:semicolon
multiline_comment|/* ccw area for SNID command */
id|devstat_t
id|devstat
suffix:semicolon
multiline_comment|/* required by request_irq() */
id|devstat_t
op_star
id|pdevstat
op_assign
op_amp
id|devstat
suffix:semicolon
r_int
id|irq_ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* return code */
r_int
id|retry
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* retry count */
r_int
id|inlreq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* inline request_irq() */
r_int
r_int
id|flags
suffix:semicolon
id|SANITY_CHECK
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
multiline_comment|/*&n;&t;&t; * Perform SENSE PGID command processing. We have to request device&n;&t;&t; *  ownership and provide a dummy I/O handler. We issue sync. I/O&n;&t;&t; *  requests and evaluate the devstat area on return therefore&n;&t;&t; *  we don&squot;t need a real I/O handler in place.&n;&t;&t; */
id|irq_ret
op_assign
id|request_irq
c_func
(paren
id|irq
comma
id|init_IRQ_handler
comma
id|SA_PROBE
comma
l_string|&quot;SNID&quot;
comma
id|pdevstat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_ret
op_eq
l_int|0
)paren
id|inlreq
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|pdevstat
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|irq_ret
op_eq
l_int|0
)paren
(brace
id|s390irq_spin_lock_irqsave
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
(brace
id|snid_ccw
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|ccw1_t
)paren
comma
id|GFP_DMA
)paren
suffix:semicolon
)brace
r_else
(brace
id|snid_ccw
op_assign
id|alloc_bootmem_low
c_func
(paren
r_sizeof
(paren
id|ccw1_t
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
id|snid_ccw-&gt;cmd_code
op_assign
id|CCW_CMD_SENSE_PGID
suffix:semicolon
id|snid_ccw-&gt;cda
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
c_func
(paren
id|pgid
)paren
suffix:semicolon
id|snid_ccw-&gt;count
op_assign
r_sizeof
(paren
id|pgid_t
)paren
suffix:semicolon
id|snid_ccw-&gt;flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We now issue a SensePGID request. In case of BUSY&n;&t;&t; *  or STATUS PENDING conditions we retry 5 times.&n;&t;&t; */
r_do
(brace
id|memset
c_func
(paren
id|pdevstat
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|devstat_t
)paren
)paren
suffix:semicolon
id|irq_ret
op_assign
id|s390_start_IO
c_func
(paren
id|irq
comma
id|snid_ccw
comma
l_int|0xE2D5C9C4
comma
singleline_comment|// == SNID
id|lpm
comma
singleline_comment|// n/a
id|DOIO_WAIT_FOR_INTERRUPT
op_or
id|DOIO_VALID_LPM
op_or
id|DOIO_DONT_CALL_INTHDLR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|pdevstat-&gt;flag
op_amp
id|DEVSTAT_FLAG_SENSE_AVAIL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * If the device doesn&squot;t support the&n;&t;&t;&t;&t;&t; *  Sense Path Group ID command&n;&t;&t;&t;&t;&t; *  further retries wouldn&squot;t help ...&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|pdevstat-&gt;ii.sense.data
(braket
l_int|0
)braket
op_amp
id|SNS0_CMD_REJECT
)paren
(brace
id|retry
op_assign
l_int|0
suffix:semicolon
id|irq_ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef CONFIG_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;SNID - device %04X,&quot;
l_string|&quot; unit check,&quot;
l_string|&quot; flag %04X, &quot;
l_string|&quot; retry %d, cnt %02d,&quot;
l_string|&quot; sns :&quot;
l_string|&quot; %02X%02X%02X%02X %02X%02X%02X%02X ...&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|pdevstat-&gt;flag
comma
id|retry
comma
id|pdevstat-&gt;scnt
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|0
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|1
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|2
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|3
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|4
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|5
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|6
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|7
)braket
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|2
comma
l_string|&quot;SNID - device %04X,&quot;
l_string|&quot; unit check,&quot;
l_string|&quot; flag %04X, &quot;
l_string|&quot; retry %d, cnt %02d,&quot;
l_string|&quot; sns :&quot;
l_string|&quot; %02X%02X%02X%02X %02X%02X%02X%02X ...&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|pdevstat-&gt;flag
comma
id|retry
comma
id|pdevstat-&gt;scnt
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|0
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|1
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|2
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|3
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|4
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|5
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|6
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|retry
op_decrement
suffix:semicolon
id|irq_ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
r_if
c_cond
(paren
id|pdevstat-&gt;flag
op_amp
id|DEVSTAT_NOT_OPER
)paren
(brace
multiline_comment|/* don&squot;t issue warnings during startup unless requested*/
r_if
c_cond
(paren
id|init_IRQ_complete
op_logical_or
id|cio_notoper_msg
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SNID - Device %04X &quot;
l_string|&quot;on Subchannel %04X &quot;
l_string|&quot;became &squot;not operational&squot;&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|2
comma
l_string|&quot;SNID - Device %04X &quot;
l_string|&quot;on Subchannel %04X &quot;
l_string|&quot;became &squot;not operational&squot;&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
)paren
suffix:semicolon
)brace
id|retry
op_assign
l_int|0
suffix:semicolon
id|irq_ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|retry
op_assign
l_int|0
suffix:semicolon
singleline_comment|// success ...
id|irq_ret
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
r_if
c_cond
(paren
id|irq_ret
op_ne
op_minus
id|ENODEV
)paren
singleline_comment|// -EIO, or -EBUSY
(brace
r_if
c_cond
(paren
id|pdevstat-&gt;flag
op_amp
id|DEVSTAT_STATUS_PENDING
)paren
(brace
macro_line|#ifdef CONFIG_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;SNID - Device %04X &quot;
l_string|&quot;on Subchannel %04X &quot;
l_string|&quot;reports pending status, &quot;
l_string|&quot;retry : %d&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
comma
id|retry
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|2
comma
l_string|&quot;SNID - Device %04X &quot;
l_string|&quot;on Subchannel %04X &quot;
l_string|&quot;reports pending status, &quot;
l_string|&quot;retry : %d&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
comma
id|retry
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
id|printk
c_func
(paren
l_string|&quot;SNID - device %04X,&quot;
l_string|&quot; start_io() reports rc : %d, retrying ...&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq_ret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|2
comma
l_string|&quot;SNID - device %04X,&quot;
l_string|&quot; start_io() reports rc : %d, retrying ...&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq_ret
)paren
suffix:semicolon
id|retry
op_decrement
suffix:semicolon
id|irq_ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
singleline_comment|// -ENODEV ...
(brace
id|retry
op_assign
l_int|0
suffix:semicolon
id|irq_ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_while
c_loop
(paren
id|retry
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
(brace
id|kfree
c_func
(paren
id|snid_ccw
)paren
suffix:semicolon
)brace
r_else
(brace
id|free_bootmem
c_func
(paren
(paren
r_int
r_int
)paren
id|snid_ccw
comma
r_sizeof
(paren
id|ccw1_t
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
id|s390irq_spin_unlock_irqrestore
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we installed the irq action handler we have to&n;&t;&t; *  release it too.&n;&t;&t; */
r_if
c_cond
(paren
id|inlreq
)paren
id|free_irq
c_func
(paren
id|irq
comma
id|pdevstat
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|irq_ret
suffix:semicolon
)brace
multiline_comment|/*&n; * s390_do_crw_pending&n; *&n; * Called by the machine check handler to process CRW pending&n; *  conditions. It may be a single CRW, or CRWs may be chained.&n; *&n; * Note : we currently process CRWs for subchannel source only&n; */
DECL|function|s390_do_crw_pending
r_void
id|s390_do_crw_pending
c_func
(paren
id|crwe_t
op_star
id|pcrwe
)paren
(brace
r_int
id|irq
suffix:semicolon
r_int
id|chpid
suffix:semicolon
r_int
id|dev_oper
op_assign
l_int|0
suffix:semicolon
r_int
id|dev_no
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|lock
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_CRW
id|printk
c_func
(paren
l_string|&quot;do_crw_pending : starting ...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_crw_id
comma
l_int|2
comma
l_string|&quot;do_crw_pending: starting&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|pcrwe
op_ne
l_int|NULL
)paren
(brace
r_int
id|is_owned
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|pcrwe-&gt;crw.rsc
)paren
(brace
r_case
id|CRW_RSC_SCH
suffix:colon
id|irq
op_assign
id|pcrwe-&gt;crw.rsid
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_CRW
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;do_crw_pending : source is &quot;
l_string|&quot;subchannel %04X&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_crw_id
comma
l_int|2
comma
l_string|&quot;source is subchannel %04X&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If the device isn&squot;t known yet&n;&t;&t;&t; *   we can&squot;t lock it ...&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
(brace
id|s390irq_spin_lock
c_func
(paren
id|irq
)paren
suffix:semicolon
id|lock
op_assign
l_int|1
suffix:semicolon
id|dev_oper
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.dval
)paren
id|dev_no
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devno
suffix:semicolon
id|is_owned
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
suffix:semicolon
)brace
multiline_comment|/* endif */
macro_line|#ifdef CONFIG_DEBUG_CRW
id|printk
c_func
(paren
l_string|&quot;do_crw_pending : subchannel validation - start ...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_crw_id
comma
l_int|4
comma
l_string|&quot;subchannel validation - start&bslash;n&quot;
)paren
suffix:semicolon
id|s390_validate_subchannel
c_func
(paren
id|irq
comma
id|is_owned
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
OG
id|highest_subchannel
)paren
id|highest_subchannel
op_assign
id|irq
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_CRW
id|printk
c_func
(paren
l_string|&quot;do_crw_pending : subchannel validation - done&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_crw_id
comma
l_int|4
comma
l_string|&quot;subchannel validation - done&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * After the validate processing&n;&t;&t;&t; *   the ioinfo control block&n;&t;&t;&t; *   should be allocated ...&n;&t;&t;&t; */
r_if
c_cond
(paren
id|lock
)paren
(brace
id|s390irq_spin_unlock
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
(brace
macro_line|#ifdef CONFIG_DEBUG_CRW
id|printk
c_func
(paren
l_string|&quot;do_crw_pending : ioinfo at &quot;
macro_line|#ifdef CONFIG_ARCH_S390X
l_string|&quot;%08lX&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ioinfo
(braket
id|irq
)braket
)paren
suffix:semicolon
macro_line|#else /* CONFIG_ARCH_S390X */
l_string|&quot;%08X&bslash;n&quot;
comma
(paren
r_int
)paren
id|ioinfo
(braket
id|irq
)braket
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_ARCH_S390X */
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_crw_id
comma
l_int|4
comma
l_string|&quot;ioinfo at &quot;
macro_line|#ifdef CONFIG_ARCH_S390X
l_string|&quot;%08lX&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ioinfo
(braket
id|irq
)braket
)paren
suffix:semicolon
macro_line|#else /* CONFIG_ARCH_S390X */
l_string|&quot;%08X&bslash;n&quot;
comma
(paren
r_int
)paren
id|ioinfo
(braket
id|irq
)braket
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_ARCH_S390X */
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
(brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_eq
l_int|0
)paren
(brace
id|not_oper_handler_func_t
id|nopfunc
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|nopfunc
suffix:semicolon
multiline_comment|/* remove procfs entry */
r_if
c_cond
(paren
id|cio_proc_devinfo
)paren
id|cio_procfs_device_remove
c_func
(paren
id|dev_no
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * If the device has gone&n;&t;&t;&t;&t;&t; *  call not oper handler        &t;&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|dev_oper
op_eq
l_int|1
)paren
op_logical_and
(paren
id|nopfunc
op_ne
l_int|NULL
)paren
)paren
(brace
id|free_irq
c_func
(paren
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
)paren
suffix:semicolon
id|nopfunc
c_func
(paren
id|irq
comma
id|DEVSTAT_DEVICE_GONE
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
macro_line|#ifdef CONFIG_DEBUG_CRW
id|printk
c_func
(paren
l_string|&quot;do_crw_pending : device &quot;
l_string|&quot;recognition - start ...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_crw_id
comma
l_int|4
comma
l_string|&quot;device recognition - start&bslash;n&quot;
)paren
suffix:semicolon
id|s390_device_recognition_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_CRW
id|printk
c_func
(paren
l_string|&quot;do_crw_pending : device &quot;
l_string|&quot;recognition - done&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_crw_id
comma
l_int|4
comma
l_string|&quot;device recognition - done&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * the device became operational&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|dev_oper
op_eq
l_int|0
)paren
(brace
id|devreg_t
op_star
id|pdevreg
suffix:semicolon
id|pdevreg
op_assign
id|s390_search_devreg
c_func
(paren
id|ioinfo
(braket
id|irq
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pdevreg
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|pdevreg-&gt;oper_func
op_ne
l_int|NULL
)paren
id|pdevreg
op_member_access_from_pointer
id|oper_func
c_func
(paren
id|irq
comma
id|pdevreg
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/* add new procfs entry */
r_if
c_cond
(paren
id|cio_proc_devinfo
)paren
r_if
c_cond
(paren
id|highest_subchannel
OL
id|MAX_CIO_PROCFS_ENTRIES
)paren
(brace
id|cio_procfs_device_create
c_func
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devno
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * ... it is and was operational, but&n;&t;&t;&t;&t;&t; *      the devno may have changed&n;&t;&t;&t;&t;&t; */
r_else
r_if
c_cond
(paren
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devno
op_ne
id|dev_no
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|nopfunc
op_ne
l_int|NULL
)paren
)paren
(brace
r_int
id|devno_old
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devno
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|nopfunc
c_func
(paren
id|irq
comma
id|DEVSTAT_REVALIDATE
)paren
suffix:semicolon
multiline_comment|/* remove old entry, add new */
r_if
c_cond
(paren
id|cio_proc_devinfo
)paren
(brace
id|cio_procfs_device_remove
c_func
(paren
id|devno_old
)paren
suffix:semicolon
id|cio_procfs_device_create
c_func
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devno
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
multiline_comment|/* get rid of dead procfs entries */
r_if
c_cond
(paren
id|cio_proc_devinfo
)paren
id|cio_procfs_device_purge
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
r_break
suffix:semicolon
r_case
id|CRW_RSC_MONITOR
suffix:colon
macro_line|#ifdef CONFIG_DEBUG_CRW
id|printk
c_func
(paren
l_string|&quot;do_crw_pending : source is &quot;
l_string|&quot;monitoring facility&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_crw_id
comma
l_int|2
comma
l_string|&quot;source is monitoring facility&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CRW_RSC_CPATH
suffix:colon
id|chpid
op_assign
id|pcrwe-&gt;crw.rsid
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_CRW
id|printk
c_func
(paren
l_string|&quot;do_crw_pending : source is &quot;
l_string|&quot;channel path %02X&bslash;n&quot;
comma
id|chpid
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_crw_id
comma
l_int|2
comma
l_string|&quot;source is channel path %02X&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CRW_RSC_CONFIG
suffix:colon
macro_line|#ifdef CONFIG_DEBUG_CRW
id|printk
c_func
(paren
l_string|&quot;do_crw_pending : source is &quot;
l_string|&quot;configuration-alert facility&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_crw_id
comma
l_int|2
comma
l_string|&quot;source is configuration-alert facility&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CRW_RSC_CSS
suffix:colon
macro_line|#ifdef CONFIG_DEBUG_CRW
id|printk
c_func
(paren
l_string|&quot;do_crw_pending : source is &quot;
l_string|&quot;channel subsystem&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_crw_id
comma
l_int|2
comma
l_string|&quot;source is channel subsystem&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
macro_line|#ifdef CONFIG_DEBUG_CRW
id|printk
c_func
(paren
l_string|&quot;do_crw_pending : unknown source&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_crw_id
comma
l_int|2
comma
l_string|&quot;unknown source&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
id|pcrwe
op_assign
id|pcrwe-&gt;crwe_next
suffix:semicolon
)brace
multiline_comment|/* endwhile */
macro_line|#ifdef CONFIG_DEBUG_CRW
id|printk
c_func
(paren
l_string|&quot;do_crw_pending : done&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_crw_id
comma
l_int|2
comma
l_string|&quot;do_crw_pending: done&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* added by Holger Smolinski for reipl support in reipl.S */
r_extern
r_void
id|do_reipl
(paren
r_int
)paren
suffix:semicolon
r_void
DECL|function|reipl
id|reipl
(paren
r_int
id|sch
)paren
(brace
r_int
id|i
suffix:semicolon
id|s390_dev_info_t
id|dev_info
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|highest_subchannel
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|get_dev_info_by_irq
c_func
(paren
id|i
comma
op_amp
id|dev_info
)paren
op_eq
l_int|0
op_logical_and
(paren
id|dev_info.status
op_amp
id|DEVSTAT_DEVICE_OWNED
)paren
)paren
(brace
id|free_irq
(paren
id|i
comma
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|MACHINE_IS_VM
)paren
id|cpcmd
c_func
(paren
l_string|&quot;IPL&quot;
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_else
id|do_reipl
c_func
(paren
l_int|0x10000
op_or
id|sch
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function: cio_debug_init&n; * Initializes three debug logs (under /proc/s390dbf) for common I/O:&n; * - cio_msg logs the messages which are printk&squot;ed when CONFIG_DEBUG_IO is on&n; * - cio_trace logs the calling of different functions&n; * - cio_crw logs the messages which are printk&squot;ed when CONFIG_DEBUG_CRW is on&n; * debug levels depend on CONFIG_DEBUG_IO resp. CONFIG_DEBUG_CRW&n; */
DECL|function|cio_debug_init
r_int
id|cio_debug_init
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|cio_debug_msg_id
op_assign
id|debug_register
c_func
(paren
l_string|&quot;cio_msg&quot;
comma
l_int|2
comma
l_int|4
comma
l_int|16
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_msg_id
op_ne
l_int|NULL
)paren
(brace
id|debug_register_view
c_func
(paren
id|cio_debug_msg_id
comma
op_amp
id|debug_sprintf_view
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_IO
id|debug_set_level
c_func
(paren
id|cio_debug_msg_id
comma
l_int|6
)paren
suffix:semicolon
macro_line|#else /* CONFIG_DEBUG_IO */
id|debug_set_level
c_func
(paren
id|cio_debug_msg_id
comma
l_int|2
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_DEBUG_IO */
)brace
r_else
(brace
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|cio_debug_trace_id
op_assign
id|debug_register
c_func
(paren
l_string|&quot;cio_trace&quot;
comma
l_int|4
comma
l_int|4
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_trace_id
op_ne
l_int|NULL
)paren
(brace
id|debug_register_view
c_func
(paren
id|cio_debug_trace_id
comma
op_amp
id|debug_hex_ascii_view
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_IO
id|debug_set_level
c_func
(paren
id|cio_debug_trace_id
comma
l_int|6
)paren
suffix:semicolon
macro_line|#else /* CONFIG_DEBUG_IO */
id|debug_set_level
c_func
(paren
id|cio_debug_trace_id
comma
l_int|2
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_DEBUG_IO */
)brace
r_else
(brace
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|cio_debug_crw_id
op_assign
id|debug_register
c_func
(paren
l_string|&quot;cio_crw&quot;
comma
l_int|2
comma
l_int|4
comma
l_int|16
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_crw_id
op_ne
l_int|NULL
)paren
(brace
id|debug_register_view
c_func
(paren
id|cio_debug_crw_id
comma
op_amp
id|debug_sprintf_view
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_CRW
id|debug_set_level
c_func
(paren
id|cio_debug_crw_id
comma
l_int|6
)paren
suffix:semicolon
macro_line|#else /* CONFIG_DEBUG_CRW */
id|debug_set_level
c_func
(paren
id|cio_debug_crw_id
comma
l_int|2
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_DEBUG_CRW */
)brace
r_else
(brace
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
id|cio_debug_initialized
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|cio_debug_init
id|__initcall
c_func
(paren
id|cio_debug_init
)paren
suffix:semicolon
multiline_comment|/* &n; * Display info on subchannels in /proc/subchannels. &n; * Adapted from procfs stuff in dasd.c by Cornelia Huck, 02/28/01.      &n; */
r_typedef
r_struct
(brace
DECL|member|data
r_char
op_star
id|data
suffix:semicolon
DECL|member|len
r_int
id|len
suffix:semicolon
DECL|typedef|tempinfo_t
)brace
id|tempinfo_t
suffix:semicolon
DECL|macro|MIN
mdefine_line|#define MIN(a,b) ((a)&lt;(b)?(a):(b))
DECL|variable|chan_subch_entry
r_static
r_struct
id|proc_dir_entry
op_star
id|chan_subch_entry
suffix:semicolon
DECL|function|chan_subch_open
r_static
r_int
id|chan_subch_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|size
op_assign
l_int|1
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|j
op_assign
l_int|0
suffix:semicolon
id|tempinfo_t
op_star
id|info
suffix:semicolon
id|info
op_assign
(paren
id|tempinfo_t
op_star
)paren
id|vmalloc
c_func
(paren
r_sizeof
(paren
id|tempinfo_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;No memory available for data&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
id|file-&gt;private_data
op_assign
(paren
r_void
op_star
)paren
id|info
suffix:semicolon
)brace
id|size
op_add_assign
(paren
id|highest_subchannel
op_plus
l_int|1
)paren
op_star
l_int|128
suffix:semicolon
id|info-&gt;data
op_assign
(paren
r_char
op_star
)paren
id|vmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_logical_and
id|info-&gt;data
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;No memory available for data&bslash;n&quot;
)paren
suffix:semicolon
id|vfree
(paren
id|info
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;Device sch.  Dev Type/Model CU  in use  PIM PAM POM LPUM CHPIDs&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;--------------------------------------------------------------------------&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|highest_subchannel
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|ioinfo
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|ioinfo
(braket
id|i
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
op_logical_or
op_logical_neg
(paren
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|ui.flags.oper
)paren
)paren
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;%04X   %04X  &quot;
comma
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|senseid.dev_type
op_ne
l_int|0
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;%04X/%02X   %04X/%02X&quot;
comma
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|senseid.dev_type
comma
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|senseid.dev_model
comma
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|senseid.cu_type
comma
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|senseid.cu_model
)paren
suffix:semicolon
)brace
r_else
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;          %04X/%02X&quot;
comma
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|senseid.cu_type
comma
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|senseid.cu_model
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;  yes &quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;      &quot;
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;    %02X  %02X  %02X  %02X   &quot;
comma
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|schib.pmcw.pim
comma
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|schib.pmcw.pam
comma
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|schib.pmcw.pom
comma
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|schib.pmcw.lpum
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_increment
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;%02X&quot;
comma
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|schib.pmcw.chpid
(braket
id|j
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|j
op_eq
l_int|3
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|info-&gt;len
op_assign
id|len
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|chan_subch_close
r_static
r_int
id|chan_subch_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|tempinfo_t
op_star
id|p_info
op_assign
(paren
id|tempinfo_t
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|p_info
)paren
(brace
r_if
c_cond
(paren
id|p_info-&gt;data
)paren
id|vfree
c_func
(paren
id|p_info-&gt;data
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|p_info
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|chan_subch_read
r_static
id|ssize_t
id|chan_subch_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|user_buf
comma
r_int
id|user_len
comma
id|loff_t
op_star
id|offset
)paren
(brace
id|loff_t
id|len
suffix:semicolon
id|tempinfo_t
op_star
id|p_info
op_assign
(paren
id|tempinfo_t
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
op_star
id|offset
op_ge
id|p_info-&gt;len
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|len
op_assign
id|MIN
c_func
(paren
id|user_len
comma
(paren
id|p_info-&gt;len
op_minus
op_star
id|offset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|user_buf
comma
op_amp
(paren
id|p_info-&gt;data
(braket
op_star
id|offset
)braket
)paren
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
(paren
op_star
id|offset
)paren
op_add_assign
id|len
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
)brace
DECL|variable|chan_subch_file_ops
r_static
r_struct
id|file_operations
id|chan_subch_file_ops
op_assign
(brace
id|read
suffix:colon
id|chan_subch_read
comma
id|open
suffix:colon
id|chan_subch_open
comma
id|release
suffix:colon
id|chan_subch_close
comma
)brace
suffix:semicolon
DECL|function|chan_proc_init
r_static
r_int
id|chan_proc_init
c_func
(paren
r_void
)paren
(brace
id|chan_subch_entry
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;subchannels&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
comma
op_amp
id|proc_root
)paren
suffix:semicolon
id|chan_subch_entry-&gt;proc_fops
op_assign
op_amp
id|chan_subch_file_ops
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|chan_proc_init
id|__initcall
c_func
(paren
id|chan_proc_init
)paren
suffix:semicolon
DECL|function|chan_proc_cleanup
r_void
id|chan_proc_cleanup
c_func
(paren
r_void
)paren
(brace
id|remove_proc_entry
c_func
(paren
l_string|&quot;subchannels&quot;
comma
op_amp
id|proc_root
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Display device specific information under /proc/deviceinfo/&lt;devno&gt;&n; */
DECL|variable|cio_procfs_deviceinfo_root
r_static
r_struct
id|proc_dir_entry
op_star
id|cio_procfs_deviceinfo_root
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* &n; * cio_procfs_device_list holds all devno-specific procfs directories&n; */
r_typedef
r_struct
(brace
DECL|member|devno
r_int
id|devno
suffix:semicolon
DECL|member|cio_device_entry
r_struct
id|proc_dir_entry
op_star
id|cio_device_entry
suffix:semicolon
DECL|member|cio_sensedata_entry
r_struct
id|proc_dir_entry
op_star
id|cio_sensedata_entry
suffix:semicolon
DECL|member|cio_in_use_entry
r_struct
id|proc_dir_entry
op_star
id|cio_in_use_entry
suffix:semicolon
DECL|member|cio_chpid_entry
r_struct
id|proc_dir_entry
op_star
id|cio_chpid_entry
suffix:semicolon
DECL|typedef|cio_procfs_entry_t
)brace
id|cio_procfs_entry_t
suffix:semicolon
DECL|struct|_cio_procfs_device
r_typedef
r_struct
id|_cio_procfs_device
(brace
DECL|member|next
r_struct
id|_cio_procfs_device
op_star
id|next
suffix:semicolon
DECL|member|entry
id|cio_procfs_entry_t
op_star
id|entry
suffix:semicolon
DECL|typedef|cio_procfs_device_t
)brace
id|cio_procfs_device_t
suffix:semicolon
DECL|variable|cio_procfs_device_list
id|cio_procfs_device_t
op_star
id|cio_procfs_device_list
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; * File operations&n; */
DECL|function|cio_device_entry_close
r_static
r_int
id|cio_device_entry_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|tempinfo_t
op_star
id|p_info
op_assign
(paren
id|tempinfo_t
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|p_info
)paren
(brace
r_if
c_cond
(paren
id|p_info-&gt;data
)paren
id|vfree
c_func
(paren
id|p_info-&gt;data
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|p_info
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|cio_device_entry_read
r_static
id|ssize_t
id|cio_device_entry_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|user_buf
comma
r_int
id|user_len
comma
id|loff_t
op_star
id|offset
)paren
(brace
id|loff_t
id|len
suffix:semicolon
id|tempinfo_t
op_star
id|p_info
op_assign
(paren
id|tempinfo_t
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
op_star
id|offset
op_ge
id|p_info-&gt;len
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|len
op_assign
id|MIN
c_func
(paren
id|user_len
comma
(paren
id|p_info-&gt;len
op_minus
op_star
id|offset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|user_buf
comma
op_amp
(paren
id|p_info-&gt;data
(braket
op_star
id|offset
)braket
)paren
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
(paren
op_star
id|offset
)paren
op_add_assign
id|len
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
)brace
DECL|function|cio_sensedata_entry_open
r_static
r_int
id|cio_sensedata_entry_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|size
op_assign
l_int|1
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|tempinfo_t
op_star
id|info
suffix:semicolon
r_int
id|irq
suffix:semicolon
r_int
id|devno
suffix:semicolon
r_char
op_star
id|devno_str
suffix:semicolon
id|info
op_assign
(paren
id|tempinfo_t
op_star
)paren
id|vmalloc
c_func
(paren
r_sizeof
(paren
id|tempinfo_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;No memory available for data&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
id|file-&gt;private_data
op_assign
(paren
r_void
op_star
)paren
id|info
suffix:semicolon
id|size
op_add_assign
l_int|2
op_star
l_int|32
suffix:semicolon
id|info-&gt;data
op_assign
(paren
r_char
op_star
)paren
id|vmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_logical_and
id|info-&gt;data
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;No memory available for data&bslash;n&quot;
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|info
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
id|devno_str
op_assign
id|kmalloc
c_func
(paren
l_int|6
op_star
r_sizeof
(paren
r_char
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|devno_str
comma
l_int|0
comma
l_int|6
op_star
r_sizeof
(paren
r_char
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|devno_str
comma
id|file-&gt;f_dentry-&gt;d_parent-&gt;d_name.name
comma
id|strlen
c_func
(paren
id|file-&gt;f_dentry-&gt;d_parent-&gt;d_name.name
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|devno
op_assign
id|simple_strtoul
c_func
(paren
id|devno_str
comma
op_amp
id|devno_str
comma
l_int|16
)paren
suffix:semicolon
id|irq
op_assign
id|get_irq_by_devno
c_func
(paren
id|devno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ne
op_minus
l_int|1
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;Dev Type/Mod: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.dev_type
op_eq
l_int|0
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;%04X/%02X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.cu_type
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.cu_model
)paren
suffix:semicolon
)brace
r_else
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;%04X/%02X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.dev_type
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.dev_model
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;CU Type/Mod:  %04X/%02X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.cu_type
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.cu_model
)paren
suffix:semicolon
)brace
)brace
id|info-&gt;len
op_assign
id|len
suffix:semicolon
)brace
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|cio_in_use_entry_open
r_static
r_int
id|cio_in_use_entry_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|size
op_assign
l_int|1
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|tempinfo_t
op_star
id|info
suffix:semicolon
r_int
id|irq
suffix:semicolon
r_int
id|devno
suffix:semicolon
r_char
op_star
id|devno_str
suffix:semicolon
id|info
op_assign
(paren
id|tempinfo_t
op_star
)paren
id|vmalloc
c_func
(paren
r_sizeof
(paren
id|tempinfo_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;No memory available for data&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
id|file-&gt;private_data
op_assign
(paren
r_void
op_star
)paren
id|info
suffix:semicolon
id|size
op_add_assign
l_int|8
suffix:semicolon
id|info-&gt;data
op_assign
(paren
r_char
op_star
)paren
id|vmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_logical_and
id|info-&gt;data
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;No memory available for data&bslash;n&quot;
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|info
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
id|devno_str
op_assign
id|kmalloc
c_func
(paren
l_int|6
op_star
r_sizeof
(paren
r_char
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|devno_str
comma
l_int|0
comma
l_int|6
op_star
r_sizeof
(paren
r_char
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|devno_str
comma
id|file-&gt;f_dentry-&gt;d_parent-&gt;d_name.name
comma
id|strlen
c_func
(paren
id|file-&gt;f_dentry-&gt;d_parent-&gt;d_name.name
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|devno
op_assign
id|simple_strtoul
c_func
(paren
id|devno_str
comma
op_amp
id|devno_str
comma
l_int|16
)paren
suffix:semicolon
id|irq
op_assign
id|get_irq_by_devno
c_func
(paren
id|devno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ne
op_minus
l_int|1
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
)brace
id|info-&gt;len
op_assign
id|len
suffix:semicolon
)brace
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|cio_chpid_entry_open
r_static
r_int
id|cio_chpid_entry_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|size
op_assign
l_int|1
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|tempinfo_t
op_star
id|info
suffix:semicolon
r_int
id|irq
suffix:semicolon
r_int
id|devno
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
op_star
id|devno_str
suffix:semicolon
id|info
op_assign
(paren
id|tempinfo_t
op_star
)paren
id|vmalloc
c_func
(paren
r_sizeof
(paren
id|tempinfo_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;No memory available for data&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
id|file-&gt;private_data
op_assign
(paren
r_void
op_star
)paren
id|info
suffix:semicolon
id|size
op_add_assign
l_int|8
op_star
l_int|16
suffix:semicolon
id|info-&gt;data
op_assign
(paren
r_char
op_star
)paren
id|vmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_logical_and
id|info-&gt;data
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;No memory available for data&bslash;n&quot;
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|info
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
id|devno_str
op_assign
id|kmalloc
c_func
(paren
l_int|6
op_star
r_sizeof
(paren
r_char
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|devno_str
comma
l_int|0
comma
l_int|6
op_star
r_sizeof
(paren
r_char
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|devno_str
comma
id|file-&gt;f_dentry-&gt;d_parent-&gt;d_name.name
comma
id|strlen
c_func
(paren
id|file-&gt;f_dentry-&gt;d_parent-&gt;d_name.name
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|devno
op_assign
id|simple_strtoul
c_func
(paren
id|devno_str
comma
op_amp
id|devno_str
comma
l_int|16
)paren
suffix:semicolon
id|irq
op_assign
id|get_irq_by_devno
c_func
(paren
id|devno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ne
op_minus
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;CHPID[%d]: &quot;
comma
id|i
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;%02X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.chpid
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
id|info-&gt;len
op_assign
id|len
suffix:semicolon
)brace
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|variable|cio_sensedata_entry_file_ops
r_static
r_struct
id|file_operations
id|cio_sensedata_entry_file_ops
op_assign
(brace
id|read
suffix:colon
id|cio_device_entry_read
comma
id|open
suffix:colon
id|cio_sensedata_entry_open
comma
id|release
suffix:colon
id|cio_device_entry_close
comma
)brace
suffix:semicolon
DECL|variable|cio_in_use_entry_file_ops
r_static
r_struct
id|file_operations
id|cio_in_use_entry_file_ops
op_assign
(brace
id|read
suffix:colon
id|cio_device_entry_read
comma
id|open
suffix:colon
id|cio_in_use_entry_open
comma
id|release
suffix:colon
id|cio_device_entry_close
comma
)brace
suffix:semicolon
DECL|variable|cio_chpid_entry_file_ops
r_static
r_struct
id|file_operations
id|cio_chpid_entry_file_ops
op_assign
(brace
id|read
suffix:colon
id|cio_device_entry_read
comma
id|open
suffix:colon
id|cio_chpid_entry_open
comma
id|release
suffix:colon
id|cio_device_entry_close
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Function: cio_procfs_device_create&n; * create procfs entry for given device number&n; * and insert it into list&n; */
DECL|function|cio_procfs_device_create
r_int
id|cio_procfs_device_create
c_func
(paren
r_int
id|devno
)paren
(brace
id|cio_procfs_entry_t
op_star
id|entry
suffix:semicolon
id|cio_procfs_device_t
op_star
id|tmp
suffix:semicolon
id|cio_procfs_device_t
op_star
id|where
suffix:semicolon
r_char
id|buf
(braket
l_int|8
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* create the directory entry */
id|entry
op_assign
(paren
id|cio_procfs_entry_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|cio_procfs_entry_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
)paren
(brace
id|entry-&gt;devno
op_assign
id|devno
suffix:semicolon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%x&quot;
comma
id|devno
)paren
suffix:semicolon
id|entry-&gt;cio_device_entry
op_assign
id|proc_mkdir
c_func
(paren
id|buf
comma
id|cio_procfs_deviceinfo_root
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;cio_device_entry
)paren
(brace
id|tmp
op_assign
(paren
id|cio_procfs_device_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|cio_procfs_device_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
(brace
id|tmp-&gt;entry
op_assign
id|entry
suffix:semicolon
r_if
c_cond
(paren
id|cio_procfs_device_list
op_eq
l_int|NULL
)paren
(brace
id|cio_procfs_device_list
op_assign
id|tmp
suffix:semicolon
id|tmp-&gt;next
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|where
op_assign
id|cio_procfs_device_list
suffix:semicolon
id|i
op_assign
id|where-&gt;entry-&gt;devno
suffix:semicolon
r_while
c_loop
(paren
(paren
id|devno
OG
id|i
)paren
op_logical_and
(paren
id|where-&gt;next
op_ne
l_int|NULL
)paren
)paren
(brace
id|where
op_assign
id|where-&gt;next
suffix:semicolon
id|i
op_assign
id|where-&gt;entry-&gt;devno
suffix:semicolon
)brace
r_if
c_cond
(paren
id|where-&gt;next
op_eq
l_int|NULL
)paren
(brace
id|where-&gt;next
op_assign
id|tmp
suffix:semicolon
id|tmp-&gt;next
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|tmp-&gt;next
op_assign
id|where-&gt;next
suffix:semicolon
id|where-&gt;next
op_assign
id|tmp
suffix:semicolon
)brace
)brace
multiline_comment|/* create the different entries */
id|entry-&gt;cio_sensedata_entry
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;sensedata&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
comma
id|entry-&gt;cio_device_entry
)paren
suffix:semicolon
id|entry-&gt;cio_sensedata_entry-&gt;proc_fops
op_assign
op_amp
id|cio_sensedata_entry_file_ops
suffix:semicolon
id|entry-&gt;cio_in_use_entry
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;in_use&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
comma
id|entry-&gt;cio_device_entry
)paren
suffix:semicolon
id|entry-&gt;cio_in_use_entry-&gt;proc_fops
op_assign
op_amp
id|cio_in_use_entry_file_ops
suffix:semicolon
id|entry-&gt;cio_chpid_entry
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;chpids&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
comma
id|entry-&gt;cio_device_entry
)paren
suffix:semicolon
id|entry-&gt;cio_chpid_entry-&gt;proc_fops
op_assign
op_amp
id|cio_chpid_entry_file_ops
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Error, could not allocate procfs structure!&bslash;n&quot;
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|buf
comma
id|cio_procfs_deviceinfo_root
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|entry
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Error, could not allocate procfs structure!&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|entry
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Error, could not allocate procfs structure!&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Function: cio_procfs_device_remove&n; * remove procfs entry for given device number&n; */
DECL|function|cio_procfs_device_remove
r_int
id|cio_procfs_device_remove
c_func
(paren
r_int
id|devno
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|cio_procfs_device_t
op_star
id|tmp
suffix:semicolon
id|cio_procfs_device_t
op_star
id|prev
op_assign
l_int|NULL
suffix:semicolon
id|tmp
op_assign
id|cio_procfs_device_list
suffix:semicolon
r_while
c_loop
(paren
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|tmp-&gt;entry-&gt;devno
op_eq
id|devno
)paren
r_break
suffix:semicolon
id|prev
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmp
)paren
(brace
r_char
id|buf
(braket
l_int|8
)braket
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;sensedata&quot;
comma
id|tmp-&gt;entry-&gt;cio_device_entry
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;in_use&quot;
comma
id|tmp-&gt;entry-&gt;cio_device_entry
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;chpid&quot;
comma
id|tmp-&gt;entry-&gt;cio_device_entry
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%x&quot;
comma
id|devno
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|buf
comma
id|cio_procfs_deviceinfo_root
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_eq
id|cio_procfs_device_list
)paren
(brace
id|cio_procfs_device_list
op_assign
id|tmp-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|prev-&gt;next
op_assign
id|tmp-&gt;next
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|tmp-&gt;entry
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
r_else
(brace
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Function: cio_procfs_purge&n; * purge /proc/deviceinfo of entries for gone devices&n; */
DECL|function|cio_procfs_device_purge
r_int
id|cio_procfs_device_purge
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|highest_subchannel
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|i
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|ui.flags.oper
)paren
id|cio_procfs_device_remove
c_func
(paren
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|devno
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function: cio_procfs_create&n; * create /proc/deviceinfo/ and subdirs for the devices&n; */
DECL|function|cio_procfs_create
r_static
r_int
id|cio_procfs_create
c_func
(paren
r_void
)paren
(brace
r_int
id|irq
suffix:semicolon
r_if
c_cond
(paren
id|cio_proc_devinfo
)paren
(brace
id|cio_procfs_deviceinfo_root
op_assign
id|proc_mkdir
c_func
(paren
l_string|&quot;deviceinfo&quot;
comma
op_amp
id|proc_root
)paren
suffix:semicolon
r_if
c_cond
(paren
id|highest_subchannel
op_ge
id|MAX_CIO_PROCFS_ENTRIES
)paren
(brace
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;Warning: Not enough inodes for creating all entries under /proc/deviceinfo/. &quot;
l_string|&quot;Not every device will get an entry.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|irq
op_assign
l_int|0
suffix:semicolon
id|irq
op_le
id|highest_subchannel
suffix:semicolon
id|irq
op_increment
)paren
(brace
r_if
c_cond
(paren
id|irq
op_ge
id|MAX_CIO_PROCFS_ENTRIES
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
(brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
)paren
r_if
c_cond
(paren
id|cio_procfs_device_create
c_func
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devno
)paren
op_eq
op_minus
id|ENOMEM
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Out of memory while creating entries in /proc/deviceinfo/, &quot;
l_string|&quot;not all devices might show up&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|cio_procfs_create
id|__initcall
c_func
(paren
id|cio_procfs_create
)paren
suffix:semicolon
multiline_comment|/*&n; * Entry /proc/cio_ignore to display blacklisted ranges of devices.&n; * un-ignore devices by piping to /proc/cio_ignore:&n; * free all frees all blacklisted devices, free &lt;range&gt;,&lt;range&gt;,...&n; * frees specified ranges of devnos&n; * add &lt;range&gt;,&lt;range&gt;,... will add a range of devices to blacklist -&n; * but only for devices not already known&n; */
DECL|variable|cio_ignore_proc_entry
r_static
r_struct
id|proc_dir_entry
op_star
id|cio_ignore_proc_entry
suffix:semicolon
DECL|function|cio_ignore_proc_open
r_static
r_int
id|cio_ignore_proc_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|size
op_assign
l_int|1
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|tempinfo_t
op_star
id|info
suffix:semicolon
id|dev_blacklist_range_t
op_star
id|tmp
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|info
op_assign
(paren
id|tempinfo_t
op_star
)paren
id|vmalloc
c_func
(paren
r_sizeof
(paren
id|tempinfo_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;No memory available for data&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
id|file-&gt;private_data
op_assign
(paren
r_void
op_star
)paren
id|info
suffix:semicolon
id|size
op_add_assign
id|nr_blacklisted_ranges
op_star
l_int|32
suffix:semicolon
id|info-&gt;data
op_assign
(paren
r_char
op_star
)paren
id|vmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_logical_and
id|info-&gt;data
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;No memory available for data&bslash;n&quot;
)paren
suffix:semicolon
id|vfree
(paren
id|info
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|blacklist_lock
comma
id|flags
)paren
suffix:semicolon
id|tmp
op_assign
id|dev_blacklist_range_head
suffix:semicolon
r_while
c_loop
(paren
id|tmp
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;%04x &quot;
comma
id|tmp-&gt;from
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;to
op_ne
id|tmp-&gt;from
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;- %04x&quot;
comma
id|tmp-&gt;to
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|blacklist_lock
comma
id|flags
)paren
suffix:semicolon
id|info-&gt;len
op_assign
id|len
suffix:semicolon
)brace
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|cio_ignore_proc_close
r_static
r_int
id|cio_ignore_proc_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|tempinfo_t
op_star
id|p_info
op_assign
(paren
id|tempinfo_t
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|p_info
)paren
(brace
r_if
c_cond
(paren
id|p_info-&gt;data
)paren
id|vfree
c_func
(paren
id|p_info-&gt;data
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|p_info
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|cio_ignore_proc_read
r_static
id|ssize_t
id|cio_ignore_proc_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|user_buf
comma
r_int
id|user_len
comma
id|loff_t
op_star
id|offset
)paren
(brace
id|loff_t
id|len
suffix:semicolon
id|tempinfo_t
op_star
id|p_info
op_assign
(paren
id|tempinfo_t
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
op_star
id|offset
op_ge
id|p_info-&gt;len
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|len
op_assign
id|MIN
c_func
(paren
id|user_len
comma
(paren
id|p_info-&gt;len
op_minus
op_star
id|offset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|user_buf
comma
op_amp
(paren
id|p_info-&gt;data
(braket
op_star
id|offset
)braket
)paren
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
(paren
op_star
id|offset
)paren
op_add_assign
id|len
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
)brace
DECL|function|cio_ignore_proc_write
r_static
id|ssize_t
id|cio_ignore_proc_write
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|user_buf
comma
r_int
id|user_len
comma
id|loff_t
op_star
id|offset
)paren
(brace
r_char
op_star
id|buffer
op_assign
id|vmalloc
(paren
id|user_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
id|buffer
comma
id|user_buf
comma
id|user_len
)paren
)paren
(brace
id|vfree
(paren
id|buffer
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|buffer
(braket
id|user_len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
macro_line|#ifdef CIO_DEBUG_IO
id|printk
(paren
l_string|&quot;/proc/cio_ignore: &squot;%s&squot;&bslash;n&quot;
comma
id|buffer
)paren
suffix:semicolon
macro_line|#endif /* CIO_DEBUG_IO */
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_sprintf_event
c_func
(paren
id|cio_debug_msg_id
comma
l_int|2
comma
l_string|&quot;/proc/cio_ignore: &squot;%s&squot;&bslash;n&quot;
comma
id|buffer
)paren
suffix:semicolon
id|blacklist_parse_proc_parameters
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|user_len
suffix:semicolon
)brace
DECL|variable|cio_ignore_proc_file_ops
r_static
r_struct
id|file_operations
id|cio_ignore_proc_file_ops
op_assign
(brace
id|read
suffix:colon
id|cio_ignore_proc_read
comma
id|open
suffix:colon
id|cio_ignore_proc_open
comma
id|write
suffix:colon
id|cio_ignore_proc_write
comma
id|release
suffix:colon
id|cio_ignore_proc_close
comma
)brace
suffix:semicolon
DECL|function|cio_ignore_proc_init
r_static
r_int
id|cio_ignore_proc_init
c_func
(paren
r_void
)paren
(brace
id|cio_ignore_proc_entry
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;cio_ignore&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
comma
op_amp
id|proc_root
)paren
suffix:semicolon
id|cio_ignore_proc_entry-&gt;proc_fops
op_assign
op_amp
id|cio_ignore_proc_file_ops
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|cio_ignore_proc_init
id|__initcall
c_func
(paren
id|cio_ignore_proc_init
)paren
suffix:semicolon
multiline_comment|/*&n; * Entry /proc/irq_count&n; * display how many irqs have occured per cpu...&n; */
DECL|variable|cio_irq_proc_entry
r_static
r_struct
id|proc_dir_entry
op_star
id|cio_irq_proc_entry
suffix:semicolon
DECL|function|cio_irq_proc_open
r_static
r_int
id|cio_irq_proc_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|size
op_assign
l_int|1
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|tempinfo_t
op_star
id|info
suffix:semicolon
r_int
id|i
suffix:semicolon
id|info
op_assign
(paren
id|tempinfo_t
op_star
)paren
id|vmalloc
c_func
(paren
r_sizeof
(paren
id|tempinfo_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;No memory available for data&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
id|file-&gt;private_data
op_assign
(paren
r_void
op_star
)paren
id|info
suffix:semicolon
id|size
op_add_assign
id|NR_CPUS
op_star
l_int|16
suffix:semicolon
id|info-&gt;data
op_assign
(paren
r_char
op_star
)paren
id|vmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_logical_and
id|info-&gt;data
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;No memory available for data&bslash;n&quot;
)paren
suffix:semicolon
id|vfree
(paren
id|info
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|s390_irq_count
(braket
id|i
)braket
op_ne
l_int|0
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;%lx&bslash;n&quot;
comma
id|s390_irq_count
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|info-&gt;len
op_assign
id|len
suffix:semicolon
)brace
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|cio_irq_proc_close
r_static
r_int
id|cio_irq_proc_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|tempinfo_t
op_star
id|p_info
op_assign
(paren
id|tempinfo_t
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|p_info
)paren
(brace
r_if
c_cond
(paren
id|p_info-&gt;data
)paren
id|vfree
c_func
(paren
id|p_info-&gt;data
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|p_info
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|cio_irq_proc_read
r_static
id|ssize_t
id|cio_irq_proc_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|user_buf
comma
r_int
id|user_len
comma
id|loff_t
op_star
id|offset
)paren
(brace
id|loff_t
id|len
suffix:semicolon
id|tempinfo_t
op_star
id|p_info
op_assign
(paren
id|tempinfo_t
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
op_star
id|offset
op_ge
id|p_info-&gt;len
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|len
op_assign
id|MIN
c_func
(paren
id|user_len
comma
(paren
id|p_info-&gt;len
op_minus
op_star
id|offset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|user_buf
comma
op_amp
(paren
id|p_info-&gt;data
(braket
op_star
id|offset
)braket
)paren
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
(paren
op_star
id|offset
)paren
op_add_assign
id|len
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
)brace
DECL|variable|cio_irq_proc_file_ops
r_static
r_struct
id|file_operations
id|cio_irq_proc_file_ops
op_assign
(brace
id|read
suffix:colon
id|cio_irq_proc_read
comma
id|open
suffix:colon
id|cio_irq_proc_open
comma
id|release
suffix:colon
id|cio_irq_proc_close
comma
)brace
suffix:semicolon
DECL|function|cio_irq_proc_init
r_static
r_int
id|cio_irq_proc_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|cio_count_irqs
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
id|s390_irq_count
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|cio_irq_proc_entry
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;irq_count&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
comma
op_amp
id|proc_root
)paren
suffix:semicolon
id|cio_irq_proc_entry-&gt;proc_fops
op_assign
op_amp
id|cio_irq_proc_file_ops
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|cio_irq_proc_init
id|__initcall
c_func
(paren
id|cio_irq_proc_init
)paren
suffix:semicolon
multiline_comment|/* end of procfs stuff */
DECL|function|s390_get_schib
id|schib_t
op_star
id|s390_get_schib
c_func
(paren
r_int
id|irq
)paren
(brace
r_if
c_cond
(paren
(paren
id|irq
OG
id|highest_subchannel
)paren
op_logical_or
(paren
id|irq
OL
l_int|0
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
suffix:semicolon
)brace
DECL|variable|halt_IO
id|EXPORT_SYMBOL
c_func
(paren
id|halt_IO
)paren
suffix:semicolon
DECL|variable|clear_IO
id|EXPORT_SYMBOL
c_func
(paren
id|clear_IO
)paren
suffix:semicolon
DECL|variable|do_IO
id|EXPORT_SYMBOL
c_func
(paren
id|do_IO
)paren
suffix:semicolon
DECL|variable|resume_IO
id|EXPORT_SYMBOL
c_func
(paren
id|resume_IO
)paren
suffix:semicolon
DECL|variable|ioinfo
id|EXPORT_SYMBOL
c_func
(paren
id|ioinfo
)paren
suffix:semicolon
DECL|variable|get_dev_info_by_irq
id|EXPORT_SYMBOL
c_func
(paren
id|get_dev_info_by_irq
)paren
suffix:semicolon
DECL|variable|get_dev_info_by_devno
id|EXPORT_SYMBOL
c_func
(paren
id|get_dev_info_by_devno
)paren
suffix:semicolon
DECL|variable|get_irq_by_devno
id|EXPORT_SYMBOL
c_func
(paren
id|get_irq_by_devno
)paren
suffix:semicolon
DECL|variable|get_devno_by_irq
id|EXPORT_SYMBOL
c_func
(paren
id|get_devno_by_irq
)paren
suffix:semicolon
DECL|variable|get_irq_first
id|EXPORT_SYMBOL
c_func
(paren
id|get_irq_first
)paren
suffix:semicolon
DECL|variable|get_irq_next
id|EXPORT_SYMBOL
c_func
(paren
id|get_irq_next
)paren
suffix:semicolon
DECL|variable|read_conf_data
id|EXPORT_SYMBOL
c_func
(paren
id|read_conf_data
)paren
suffix:semicolon
DECL|variable|read_dev_chars
id|EXPORT_SYMBOL
c_func
(paren
id|read_dev_chars
)paren
suffix:semicolon
DECL|variable|s390_request_irq_special
id|EXPORT_SYMBOL
c_func
(paren
id|s390_request_irq_special
)paren
suffix:semicolon
DECL|variable|s390_get_schib
id|EXPORT_SYMBOL
c_func
(paren
id|s390_get_schib
)paren
suffix:semicolon
DECL|variable|s390_register_adapter_interrupt
id|EXPORT_SYMBOL
c_func
(paren
id|s390_register_adapter_interrupt
)paren
suffix:semicolon
DECL|variable|s390_unregister_adapter_interrupt
id|EXPORT_SYMBOL
c_func
(paren
id|s390_unregister_adapter_interrupt
)paren
suffix:semicolon
eof
