multiline_comment|/*&n; *  drivers/s390/cio/s390io.c&n; *   S/390 common I/O routines&n; *   $Revision: 1.11 $&n; *&n; *  S390 version&n; *    Copyright (C) 1999, 2000 IBM Deutschland Entwicklung GmbH,&n; *                             IBM Corporation&n; *    Author(s): Ingo Adlung (adlung@de.ibm.com)&n; *               Cornelia Huck (cohuck@de.ibm.com) &n; *               Arnd Bergmann (arndb@de.ibm.com)&n; *    ChangeLog: 01/07/2001 Blacklist cleanup (djbarrow@de.ibm.com,barrow_dj@yahoo.com)&n; *               01/04/2001 Holger Smolinski (smolinsk@de.ibm.com)&n; *                          Fixed lost interrupts and do_adapter_IO&n; *               xx/xx/xxxx nnn          multiple changes not reflected&n; *               03/12/2001 Ingo Adlung  blacklist= - changed to cio_ignore=  &n; *               03/14/2001 Ingo Adlung  disable interrupts before start_IO&n; *                                        in Path Group processing &n; *                                       decrease retry2 on busy while &n; *                                        disabling sync_isc; reset isc_cnt&n; *                                        on io error during sync_isc enablement&n; *               05/09/2001 Cornelia Huck added exploitation of debug feature&n; *               05/16/2001 Cornelia Huck added /proc/deviceinfo/&lt;devno&gt;/&n; *               05/22/2001 Cornelia Huck added /proc/cio_ignore&n; *                                        un-ignore blacklisted devices by piping &n; *                                        to /proc/cio_ignore&n; *               xx/xx/xxxx some bugfixes &amp; cleanups&n; *               08/02/2001 Cornelia Huck not already known devices can be blacklisted&n; *                                        by piping to /proc/cio_ignore&n; *               09/xx/2001 couple more fixes&n; *               10/15/2001 Cornelia Huck xsch - internal only for now&n; *               10/29/2001 Cornelia Huck Blacklisting reworked again&n; *               10/29/2001 Cornelia Huck improved utilization of debug feature&n; *               10/29/2001 Cornelia Huck more work on cancel_IO - use the flag&n; *                                        DOIO_CANCEL_ON_TIMEOUT in do_IO to get&n; *                                        io cancelled&n; *               11/15/2001 Cornelia Huck proper behaviour with procfs off&n; *               12/10/2001 Cornelia Huck added private_data + functions to &n; *                                        ioinfo_t&n; *               11-12/2001 Cornelia Huck various cleanups&n; *               01/09/2002 Cornelia Huck PGID fixes&n; *                                        process css machine checks &n; *               01/10/2002 Cornelia Huck added /proc/chpids&n; * &t;&t; 02/11/2002 Arnd Bergmann split this file into many smaller pieces &n; * &t;&t; &t;&t;&t;  in drivers/s39/cio/&n; *               05/03/2002 Cornelia Huck debug cleanup&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
macro_line|#include &lt;asm/idals.h&gt;
macro_line|#include &lt;asm/cpcmd.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/s390io.h&gt;
macro_line|#include &lt;asm/s390dyn.h&gt;
macro_line|#include &lt;asm/s390mach.h&gt;
macro_line|#include &lt;asm/debug.h&gt;
macro_line|#include &quot;s390io.h&quot;
macro_line|#include &quot;ioinfo.h&quot;
macro_line|#include &quot;cio.h&quot;
macro_line|#include &quot;cio_debug.h&quot;
macro_line|#include &quot;blacklist.h&quot;
macro_line|#include &quot;proc.h&quot;
macro_line|#include &quot;chsc.h&quot;
DECL|variable|init_IRQ_complete
r_static
r_int
id|init_IRQ_complete
suffix:semicolon
DECL|variable|global_pgid
r_static
id|pgid_t
id|global_pgid
suffix:semicolon
DECL|variable|p_init_schib
r_static
id|schib_t
id|p_init_schib
suffix:semicolon
DECL|variable|irq_IPL_TOD
r_static
id|__u64
id|irq_IPL_TOD
suffix:semicolon
singleline_comment|// FIXME: can be on stack
r_static
r_void
id|s390_process_subchannels
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|s390_device_recognition_all
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|s390_SenseID
(paren
r_int
id|irq
comma
id|senseid_t
op_star
id|sid
comma
id|__u8
id|lpm
)paren
suffix:semicolon
r_static
r_int
id|s390_SetPGID
(paren
r_int
id|irq
comma
id|__u8
id|lpm
comma
id|pgid_t
op_star
id|pgid
)paren
suffix:semicolon
r_static
r_int
id|s390_SensePGID
(paren
r_int
id|irq
comma
id|__u8
id|lpm
comma
id|pgid_t
op_star
id|pgid
)paren
suffix:semicolon
multiline_comment|/* FIXME: intermixed with proc.c */
DECL|variable|cio_count_irqs
r_int
id|cio_count_irqs
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* toggle use here... */
DECL|variable|s390_irq_count
r_int
r_int
id|s390_irq_count
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* trace how many irqs have occured per cpu... */
DECL|variable|cio_show_msg
r_int
id|cio_show_msg
suffix:semicolon
DECL|variable|cio_notoper_msg
r_static
r_int
id|cio_notoper_msg
op_assign
l_int|1
suffix:semicolon
DECL|variable|cio_sid_with_pgid
r_static
r_int
id|cio_sid_with_pgid
suffix:semicolon
multiline_comment|/* if we need a PGID for SenseID, switch this on */
r_static
r_int
id|__init
DECL|function|cio_setup
id|cio_setup
(paren
r_char
op_star
id|parm
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|parm
comma
l_string|&quot;yes&quot;
)paren
)paren
(brace
id|cio_show_msg
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|parm
comma
l_string|&quot;no&quot;
)paren
)paren
(brace
id|cio_show_msg
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;cio_setup : invalid cio_msg parameter &squot;%s&squot;&quot;
comma
id|parm
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
(paren
l_string|&quot;cio_msg=&quot;
comma
id|cio_setup
)paren
suffix:semicolon
r_static
r_int
id|__init
DECL|function|cio_notoper_setup
id|cio_notoper_setup
(paren
r_char
op_star
id|parm
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|parm
comma
l_string|&quot;yes&quot;
)paren
)paren
(brace
id|cio_notoper_msg
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|parm
comma
l_string|&quot;no&quot;
)paren
)paren
(brace
id|cio_notoper_msg
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;cio_notoper_setup: &quot;
l_string|&quot;invalid cio_notoper_msg parameter &squot;%s&squot;&quot;
comma
id|parm
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
(paren
l_string|&quot;cio_notoper_msg=&quot;
comma
id|cio_notoper_setup
)paren
suffix:semicolon
r_static
r_int
id|__init
DECL|function|cio_pgid_setup
id|cio_pgid_setup
(paren
r_char
op_star
id|parm
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|parm
comma
l_string|&quot;yes&quot;
)paren
)paren
(brace
id|cio_sid_with_pgid
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|parm
comma
l_string|&quot;no&quot;
)paren
)paren
(brace
id|cio_sid_with_pgid
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;cio_pgid_setup : invalid cio_msg parameter &squot;%s&squot;&quot;
comma
id|parm
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
(paren
l_string|&quot;cio_sid_with_pgid=&quot;
comma
id|cio_pgid_setup
)paren
suffix:semicolon
multiline_comment|/* This function is replacing the init_IRQ function in&n; * arch/s390(x)/kernel/irq.c and is called early during&n; * bootup. Anything called from here must be careful &n; * about memory allocations */
r_void
id|__init
DECL|function|s390_init_IRQ
id|s390_init_IRQ
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* PSW flags */
r_int
id|cr6
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|8
)paren
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;STCK %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|irq_IPL_TOD
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * As we don&squot;t know about the calling environment&n;&t; *  we assure running disabled. Before leaving the&n;&t; *  function we resestablish the old environment.&n;&t; *&n;&t; * Note : as we don&squot;t need a system wide lock, therefore&n;&t; *        we shouldn&squot;t use cli(), but local_irq_save() as this&n;&t; *        affects the current CPU only.&n;&t; */
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * disable all interrupts&n;&t; */
id|cr6
op_assign
l_int|0
suffix:semicolon
id|__ctl_load
(paren
id|cr6
comma
l_int|6
comma
l_int|6
)paren
suffix:semicolon
id|s390_process_subchannels
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_count_irqs
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
id|s390_irq_count
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Let&squot;s build our path group ID here.&n;&t; */
id|global_pgid.cpu_addr
op_assign
op_star
(paren
id|__u16
op_star
)paren
id|__LC_CPUADDR
suffix:semicolon
id|global_pgid.cpu_id
op_assign
(paren
(paren
id|cpuid_t
op_star
)paren
id|__LC_CPUID
)paren
op_member_access_from_pointer
id|ident
suffix:semicolon
id|global_pgid.cpu_model
op_assign
(paren
(paren
id|cpuid_t
op_star
)paren
id|__LC_CPUID
)paren
op_member_access_from_pointer
id|machine
suffix:semicolon
id|global_pgid.tod_high
op_assign
op_star
(paren
id|__u32
op_star
)paren
op_amp
id|irq_IPL_TOD
suffix:semicolon
multiline_comment|/*&n;&t; * enable default I/O-interrupt subclass 3&n;&t; */
id|cr6
op_assign
l_int|0x10000000
suffix:semicolon
id|__ctl_load
(paren
id|cr6
comma
l_int|6
comma
l_int|6
)paren
suffix:semicolon
id|s390_device_recognition_all
(paren
)paren
suffix:semicolon
id|init_IRQ_complete
op_assign
l_int|1
suffix:semicolon
id|local_irq_restore
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * init_IRQ wrapper&n; */
r_void
id|__init
DECL|function|init_IRQ
id|init_IRQ
c_func
(paren
r_void
)paren
(brace
id|s390_init_IRQ
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * dummy handler, used during init_IRQ() processing for compatibility only&n; */
r_static
r_void
DECL|function|init_IRQ_handler
id|init_IRQ_handler
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* this is a dummy handler only ... */
)brace
multiline_comment|/*&n; * Input :&n; *   devno - device number&n; *   ps    - pointer to sense ID data area&n; * Output : none&n; */
r_static
r_inline
r_void
DECL|function|_VM_virtual_device_info
id|_VM_virtual_device_info
(paren
id|__u16
id|devno
comma
id|senseid_t
op_star
id|ps
)paren
(brace
id|diag210_t
op_star
id|p_diag_data
suffix:semicolon
r_int
id|ccode
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|4
comma
l_string|&quot;VMvdinf&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
(brace
id|p_diag_data
op_assign
id|kmalloc
(paren
r_sizeof
(paren
id|diag210_t
)paren
comma
id|GFP_DMA
)paren
suffix:semicolon
)brace
r_else
(brace
id|p_diag_data
op_assign
id|alloc_bootmem_low
(paren
r_sizeof
(paren
id|diag210_t
)paren
)paren
suffix:semicolon
)brace
id|p_diag_data-&gt;vrdcdvno
op_assign
id|devno
suffix:semicolon
id|p_diag_data-&gt;vrdclen
op_assign
r_sizeof
(paren
id|diag210_t
)paren
suffix:semicolon
id|ccode
op_assign
id|diag210
(paren
(paren
id|diag210_t
op_star
)paren
id|virt_to_phys
(paren
id|p_diag_data
)paren
)paren
suffix:semicolon
id|ps-&gt;reserved
op_assign
l_int|0xff
suffix:semicolon
r_switch
c_cond
(paren
id|p_diag_data-&gt;vrdcvcla
)paren
(brace
r_case
l_int|0x80
suffix:colon
r_switch
c_cond
(paren
id|p_diag_data-&gt;vrdcvtyp
)paren
(brace
r_case
l_int|00
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3215
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x40
suffix:colon
r_switch
c_cond
(paren
id|p_diag_data-&gt;vrdcvtyp
)paren
(brace
r_case
l_int|0xC0
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x5080
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x80
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x2250
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x04
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3277
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x01
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3278
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x20
suffix:colon
r_switch
c_cond
(paren
id|p_diag_data-&gt;vrdcvtyp
)paren
(brace
r_case
l_int|0x84
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3505
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x82
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x2540
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x81
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x2501
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x10
suffix:colon
r_switch
c_cond
(paren
id|p_diag_data-&gt;vrdcvtyp
)paren
(brace
r_case
l_int|0x84
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3525
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x82
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x2540
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x4F
suffix:colon
r_case
l_int|0x4E
suffix:colon
r_case
l_int|0x48
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3820
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x4D
suffix:colon
r_case
l_int|0x49
suffix:colon
r_case
l_int|0x45
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3800
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x4B
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x4248
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x4A
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x4245
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x47
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3262
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x43
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3203
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x42
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3211
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x41
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x1403
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x08
suffix:colon
r_switch
c_cond
(paren
id|p_diag_data-&gt;vrdcvtyp
)paren
(brace
r_case
l_int|0x82
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3422
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x81
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3490
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x10
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3420
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x02
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3430
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x01
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3480
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x42
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3424
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x44
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x9348
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|02
suffix:colon
multiline_comment|/* special device class ... */
r_switch
c_cond
(paren
id|p_diag_data-&gt;vrdcvtyp
)paren
(brace
r_case
l_int|0x20
suffix:colon
multiline_comment|/* OSA */
id|ps-&gt;cu_type
op_assign
l_int|0x3088
suffix:semicolon
id|ps-&gt;cu_model
op_assign
l_int|0x60
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
(brace
id|kfree
(paren
id|p_diag_data
)paren
suffix:semicolon
)brace
r_else
(brace
id|free_bootmem
(paren
(paren
r_int
r_int
)paren
id|p_diag_data
comma
r_sizeof
(paren
id|diag210_t
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
id|CIO_DEBUG_ALWAYS
c_func
(paren
id|KERN_ERR
comma
l_int|0
comma
l_string|&quot;DIAG X&squot;210&squot; for &quot;
l_string|&quot;device %04X returned &quot;
l_string|&quot;(cc = %d): vdev class : %02X, &quot;
l_string|&quot;vdev type : %04X &bslash;n ...  &quot;
l_string|&quot;rdev class : %02X, rdev type : %04X, &quot;
l_string|&quot;rdev model: %02X&bslash;n&quot;
comma
id|devno
comma
id|ccode
comma
id|p_diag_data-&gt;vrdcvcla
comma
id|p_diag_data-&gt;vrdcvtyp
comma
id|p_diag_data-&gt;vrdcrccl
comma
id|p_diag_data-&gt;vrdccrty
comma
id|p_diag_data-&gt;vrdccrmd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine returns the characteristics for the device&n; *  specified. Some old devices might not provide the necessary&n; *  command code information during SenseID processing. In this&n; *  case the function returns -EINVAL. Otherwise the function&n; *  allocates a decice specific data buffer and provides the&n; *  device characteristics together with the buffer size. Its&n; *  the callers responability to release the kernel memory if&n; *  not longer needed. In case of persistent I/O problems -EBUSY&n; *  is returned.&n; *&n; *  The function may be called enabled or disabled. However, the&n; *   caller must have locked the irq it is requesting data for.&n; *&n; * Note : It would have been nice to collect this information&n; *         during init_IRQ() processing but this is not possible&n; *&n; *         a) without statically pre-allocation fixed size buffers&n; *            as virtual memory management isn&squot;t available yet.&n; *&n; *         b) without unnecessarily increase system startup by&n; *            evaluating devices eventually not used at all.&n; */
r_int
DECL|function|read_dev_chars
id|read_dev_chars
(paren
r_int
id|irq
comma
r_void
op_star
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|ccw1_t
op_star
id|rdc_ccw
suffix:semicolon
id|devstat_t
id|devstat
suffix:semicolon
r_char
op_star
id|rdc_buf
suffix:semicolon
r_int
id|devflag
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|emulated
op_assign
l_int|0
suffix:semicolon
r_int
id|retry
op_assign
l_int|5
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
op_logical_or
op_logical_neg
id|length
)paren
(brace
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
id|SANITY_CHECK
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_eq
l_int|0
)paren
(brace
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;rddevch%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Before playing around with irq locks we should assure&n;&t; *   running disabled on (just) our CPU. Sync. I/O requests&n;&t; *   also require to run disabled.&n;&t; *&n;&t; * Note : as no global lock is required, we must not use&n;&t; *        cli(), but local_irq_save() instead.   &n;&t; */
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|rdc_ccw
op_assign
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseccw
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
id|ret
op_assign
id|request_irq
(paren
id|irq
comma
id|init_IRQ_handler
comma
id|SA_PROBE
comma
l_string|&quot;RDC&quot;
comma
op_amp
id|devstat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|emulated
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|buffer
)paren
(brace
id|rdc_buf
op_assign
id|kmalloc
(paren
id|length
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
r_else
(brace
id|rdc_buf
op_assign
op_star
id|buffer
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rdc_buf
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
r_do
(brace
id|rdc_ccw-&gt;cmd_code
op_assign
id|CCW_CMD_RDC
suffix:semicolon
id|rdc_ccw-&gt;count
op_assign
id|length
suffix:semicolon
id|rdc_ccw-&gt;flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
id|ret
op_assign
id|set_normalized_cda
(paren
id|rdc_ccw
comma
id|rdc_buf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|memset
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|devstat_t
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|s390_start_IO
(paren
id|irq
comma
id|rdc_ccw
comma
l_int|0x00524443
comma
multiline_comment|/* RDC */
l_int|0
comma
multiline_comment|/* n/a */
id|DOIO_WAIT_FOR_INTERRUPT
op_or
id|DOIO_DONT_CALL_INTHDLR
)paren
suffix:semicolon
id|retry
op_decrement
suffix:semicolon
id|devflag
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id-&gt;flag
suffix:semicolon
id|clear_normalized_cda
(paren
id|rdc_ccw
)paren
suffix:semicolon
)brace
r_else
(brace
id|udelay
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* wait for recovery */
id|retry
op_decrement
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|retry
)paren
op_logical_and
(paren
id|ret
op_logical_or
(paren
id|devflag
op_amp
id|DEVSTAT_STATUS_PENDING
)paren
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|retry
)paren
(brace
id|ret
op_assign
(paren
id|ret
op_eq
op_minus
id|ENOMEM
)paren
ques
c_cond
op_minus
id|ENOMEM
suffix:colon
op_minus
id|EBUSY
suffix:semicolon
)brace
id|local_irq_restore
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * on success we update the user input parms&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
op_star
id|buffer
op_assign
id|rdc_buf
suffix:semicolon
)brace
r_if
c_cond
(paren
id|emulated
)paren
(brace
id|free_irq
(paren
id|irq
comma
op_amp
id|devstat
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Read Configuration data&n; */
r_int
DECL|function|read_conf_data
id|read_conf_data
(paren
r_int
id|irq
comma
r_void
op_star
op_star
id|buffer
comma
r_int
op_star
id|length
comma
id|__u8
id|lpm
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ciw_cnt
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* RCD CIW found */
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* return code */
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|SANITY_CHECK
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
op_logical_or
op_logical_neg
id|length
)paren
(brace
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_eq
l_int|0
)paren
(brace
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.esid
op_eq
l_int|0
)paren
(brace
r_return
(paren
op_minus
id|EOPNOTSUPP
)paren
suffix:semicolon
)brace
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;rdconf%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * scan for RCD command in extended SenseID data&n;&t; */
r_for
c_loop
(paren
id|ciw_cnt
op_assign
l_int|0
suffix:semicolon
(paren
id|found
op_eq
l_int|0
)paren
op_logical_and
(paren
id|ciw_cnt
OL
l_int|62
)paren
suffix:semicolon
id|ciw_cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.ciw
(braket
id|ciw_cnt
)braket
dot
id|ct
op_eq
id|CIW_TYPE_RCD
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * paranoia check ...&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.ciw
(braket
id|ciw_cnt
)braket
dot
id|cmd
op_ne
l_int|0
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|found
)paren
(brace
id|devstat_t
id|devstat
suffix:semicolon
multiline_comment|/* inline device status area */
id|devstat_t
op_star
id|pdevstat
suffix:semicolon
r_int
id|ioflags
suffix:semicolon
id|ccw1_t
op_star
id|rcd_ccw
op_assign
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseccw
suffix:semicolon
r_char
op_star
id|rcd_buf
op_assign
l_int|NULL
suffix:semicolon
r_int
id|emulated
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no i/O handler installed */
r_int
id|retry
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* retry count */
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
id|pdevstat
op_assign
op_amp
id|devstat
suffix:semicolon
id|ret
op_assign
id|request_irq
(paren
id|irq
comma
id|init_IRQ_handler
comma
id|SA_PROBE
comma
l_string|&quot;RCD&quot;
comma
id|pdevstat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|emulated
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|pdevstat
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
(brace
id|rcd_buf
op_assign
id|kmalloc
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.ciw
(braket
id|ciw_cnt
)braket
dot
id|count
comma
id|GFP_DMA
)paren
suffix:semicolon
)brace
r_else
(brace
id|rcd_buf
op_assign
id|alloc_bootmem_low
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid
dot
id|ciw
(braket
id|ciw_cnt
)braket
dot
id|count
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rcd_buf
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|memset
(paren
id|rcd_buf
comma
l_char|&squot;&bslash;0&squot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.ciw
(braket
id|ciw_cnt
)braket
dot
id|count
)paren
suffix:semicolon
r_do
(brace
id|rcd_ccw-&gt;cmd_code
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.ciw
(braket
id|ciw_cnt
)braket
dot
id|cmd
suffix:semicolon
id|rcd_ccw-&gt;cda
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
(paren
id|rcd_buf
)paren
suffix:semicolon
id|rcd_ccw-&gt;count
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.ciw
(braket
id|ciw_cnt
)braket
dot
id|count
suffix:semicolon
id|rcd_ccw-&gt;flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
id|memset
(paren
id|pdevstat
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|devstat_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lpm
)paren
(brace
id|ioflags
op_assign
id|DOIO_WAIT_FOR_INTERRUPT
op_or
id|DOIO_VALID_LPM
op_or
id|DOIO_DONT_CALL_INTHDLR
suffix:semicolon
)brace
r_else
(brace
id|ioflags
op_assign
id|DOIO_WAIT_FOR_INTERRUPT
op_or
id|DOIO_DONT_CALL_INTHDLR
suffix:semicolon
)brace
id|ret
op_assign
id|s390_start_IO
(paren
id|irq
comma
id|rcd_ccw
comma
l_int|0x00524344
comma
multiline_comment|/* == RCD */
id|lpm
comma
id|ioflags
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ret
)paren
(brace
r_case
l_int|0
suffix:colon
r_case
op_minus
id|EIO
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pdevstat
op_member_access_from_pointer
id|flag
op_amp
(paren
id|DEVSTAT_STATUS_PENDING
op_or
id|DEVSTAT_NOT_OPER
op_or
id|DEVSTAT_FLAG_SENSE_AVAIL
)paren
)paren
)paren
(brace
id|retry
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* we got it ... */
)brace
r_else
(brace
id|retry
op_decrement
suffix:semicolon
multiline_comment|/* try again ... */
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* -EBUSY, -ENODEV, ??? */
id|retry
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|retry
)paren
suffix:semicolon
)brace
id|local_irq_restore
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * on success we update the user input parms&n;&t;&t; */
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
op_star
id|length
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.ciw
(braket
id|ciw_cnt
)braket
dot
id|count
suffix:semicolon
op_star
id|buffer
op_assign
id|rcd_buf
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|rcd_buf
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
(brace
id|kfree
(paren
id|rcd_buf
)paren
suffix:semicolon
)brace
r_else
(brace
id|free_bootmem
(paren
(paren
r_int
r_int
)paren
id|rcd_buf
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid
dot
id|ciw
(braket
id|ciw_cnt
)braket
dot
id|count
)paren
suffix:semicolon
)brace
)brace
op_star
id|buffer
op_assign
l_int|NULL
suffix:semicolon
op_star
id|length
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|emulated
)paren
id|free_irq
(paren
id|irq
comma
id|pdevstat
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * s390_device_recognition_irq&n; *&n; * Used for individual device recognition. Issues the device&n; *  independant SenseID command to obtain info the device type.&n; *&n; */
r_void
DECL|function|s390_device_recognition_irq
id|s390_device_recognition_irq
(paren
r_int
id|irq
)paren
(brace
r_int
id|ret
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;devrec%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We issue the SenseID command on I/O subchannels we think are&n;&t; *  operational only.&n;&t; */
r_if
c_cond
(paren
(paren
id|ioinfo
(braket
id|irq
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
op_logical_and
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|st
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.st
op_eq
l_int|0
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_eq
l_int|1
)paren
)paren
(brace
r_int
id|irq_ret
suffix:semicolon
id|devstat_t
id|devstat
suffix:semicolon
id|irq_ret
op_assign
id|request_irq
(paren
id|irq
comma
id|init_IRQ_handler
comma
id|SA_PROBE
comma
l_string|&quot;INIT&quot;
comma
op_amp
id|devstat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|irq_ret
)paren
(brace
id|ret
op_assign
id|enable_cpu_sync_isc
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.unknown
op_assign
l_int|0
suffix:semicolon
id|memset
(paren
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|senseid_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_sid_with_pgid
)paren
(brace
id|ret
op_assign
id|s390_DevicePathVerification
c_func
(paren
id|irq
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EOPNOTSUPP
)paren
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t; * Doesn&squot;t prevent us from proceeding&n;&t;&t;&t;&t;&t;&t; */
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * we&squot;ll fallthrough here if we don&squot;t want&n;&t;&t;&t;&t; * to do SPID before SID&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|s390_SenseID
(paren
id|irq
comma
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid
comma
l_int|0xff
)paren
suffix:semicolon
)brace
id|disable_cpu_sync_isc
(paren
id|irq
)paren
suffix:semicolon
)brace
id|free_irq
(paren
id|irq
comma
op_amp
id|devstat
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * s390_device_recognition_all&n; *&n; * Used for system wide device recognition.&n; *&n; */
r_static
r_void
id|__init
DECL|function|s390_device_recognition_all
id|s390_device_recognition_all
(paren
r_void
)paren
(brace
r_int
id|irq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* let&squot;s start with subchannel 0 ... */
r_do
(brace
id|s390_device_recognition_irq
(paren
id|irq
)paren
suffix:semicolon
id|irq
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|irq
op_le
id|highest_subchannel
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * s390_process_subchannels&n; *&n; * Determines all subchannels available to the system.&n; * Only called early during startup by s390_init_IRQ&n; */
r_static
r_void
id|__init
DECL|function|s390_process_subchannels
id|s390_process_subchannels
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|irq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Evaluate all subchannels starting with 0 ... */
r_do
(brace
id|ret
op_assign
id|s390_validate_subchannel
(paren
id|irq
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
op_minus
id|ENXIO
)paren
id|irq
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|ret
op_ne
op_minus
id|ENXIO
)paren
op_logical_and
(paren
id|irq
OL
id|__MAX_SUBCHANNELS
)paren
)paren
suffix:semicolon
id|highest_subchannel
op_assign
(paren
op_decrement
id|irq
)paren
suffix:semicolon
id|CIO_DEBUG_ALWAYS
c_func
(paren
id|KERN_INFO
comma
l_int|0
comma
l_string|&quot;Highest subchannel number detected &quot;
l_string|&quot;(hex) : %04X&bslash;n&quot;
comma
id|highest_subchannel
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * s390_validate_subchannel()&n; *&n; * Process the subchannel for the requested irq. &n; * Return codes:&n; * * 0 for valid subchannels&n; * * -ENXIO for non-defined subchannels &n; *   (indicates highest available subchannel + 1)&n; * * -ENODEV for non-IO subchannels and not operational conditions&n; * * -EIO and -EBUSY for error conditions during msch&n; */
r_int
DECL|function|s390_validate_subchannel
id|s390_validate_subchannel
(paren
r_int
id|irq
comma
r_int
id|enable
)paren
(brace
r_int
id|retry
suffix:semicolon
multiline_comment|/* retry count for status pending conditions */
r_int
id|ccode
suffix:semicolon
multiline_comment|/* condition code for stsch() only */
r_int
id|ccode2
suffix:semicolon
multiline_comment|/* condition code for other I/O routines */
id|schib_t
op_star
id|p_schib
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|chp
op_assign
l_int|0
suffix:semicolon
r_int
id|mask
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;valsch%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The first subchannel that is not-operational (ccode==3)&n;&t; *  indicates that there aren&squot;t any more devices available.&n;&t; */
r_if
c_cond
(paren
(paren
id|init_IRQ_complete
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
)paren
(brace
id|p_schib
op_assign
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
suffix:semicolon
)brace
r_else
(brace
id|p_schib
op_assign
op_amp
id|p_init_schib
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we knew the device before we assume the worst case ...    &n;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.dval
op_assign
l_int|0
suffix:semicolon
)brace
id|ccode
op_assign
id|stsch
(paren
id|irq
comma
id|p_schib
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccode
)paren
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * ... just being curious we check for non I/O subchannels&n;&t; */
r_if
c_cond
(paren
id|p_schib-&gt;pmcw.st
)paren
(brace
id|CIO_DEBUG_IFMSG
c_func
(paren
id|KERN_INFO
comma
l_int|0
comma
l_string|&quot;Subchannel %04X reports &quot;
l_string|&quot;non-I/O subchannel type %04X&bslash;n&quot;
comma
id|irq
comma
id|p_schib-&gt;pmcw.st
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|p_schib-&gt;pmcw.dnv
)paren
op_logical_and
(paren
op_logical_neg
id|p_schib-&gt;pmcw.st
)paren
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|p_schib-&gt;pmcw.st
)paren
(brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
op_logical_and
id|is_blacklisted
(paren
id|p_schib-&gt;pmcw.dev
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t; * This device must not be known to Linux. So we simply say that &n;&t;&t;&t; * there is no device and return ENODEV.&n;&t;&t;&t; */
id|CIO_DEBUG
c_func
(paren
id|KERN_DEBUG
comma
l_int|0
comma
l_string|&quot;Blacklisted device detected at devno %04X&bslash;n&quot;
comma
id|p_schib-&gt;pmcw.dev
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|init_IRQ_complete
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_assign
(paren
id|ioinfo_t
op_star
)paren
id|alloc_bootmem_low
(paren
r_sizeof
(paren
id|ioinfo_t
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_assign
(paren
id|ioinfo_t
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
id|ioinfo_t
)paren
comma
id|GFP_DMA
)paren
suffix:semicolon
)brace
id|memset
(paren
id|ioinfo
(braket
id|irq
)braket
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|ioinfo_t
)paren
)paren
suffix:semicolon
id|memcpy
(paren
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
comma
op_amp
id|p_init_schib
comma
r_sizeof
(paren
id|schib_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We have to insert the new ioinfo element&n;&t;&t; *  into the linked list, either at its head,&n;&t;&t; *  its tail or insert it.&n;&t;&t; */
r_if
c_cond
(paren
id|ioinfo_head
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* first element */
id|ioinfo_head
op_assign
id|ioinfo
(braket
id|irq
)braket
suffix:semicolon
id|ioinfo_tail
op_assign
id|ioinfo
(braket
id|irq
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|irq
OL
id|ioinfo_head-&gt;irq
)paren
(brace
multiline_comment|/* new head */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|next
op_assign
id|ioinfo_head
suffix:semicolon
id|ioinfo_head-&gt;prev
op_assign
id|ioinfo
(braket
id|irq
)braket
suffix:semicolon
id|ioinfo_head
op_assign
id|ioinfo
(braket
id|irq
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|irq
OG
id|ioinfo_tail-&gt;irq
)paren
(brace
multiline_comment|/* new tail */
id|ioinfo_tail-&gt;next
op_assign
id|ioinfo
(braket
id|irq
)braket
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|prev
op_assign
id|ioinfo_tail
suffix:semicolon
id|ioinfo_tail
op_assign
id|ioinfo
(braket
id|irq
)braket
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* insert element */
id|ioinfo_t
op_star
id|pi
op_assign
id|ioinfo_head
suffix:semicolon
r_for
c_loop
(paren
id|pi
op_assign
id|ioinfo_head
suffix:semicolon
id|pi
op_ne
l_int|NULL
suffix:semicolon
id|pi
op_assign
id|pi-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|irq
OL
id|pi-&gt;next-&gt;irq
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|next
op_assign
id|pi-&gt;next
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|prev
op_assign
id|pi
suffix:semicolon
id|pi-&gt;next-&gt;prev
op_assign
id|ioinfo
(braket
id|irq
)braket
suffix:semicolon
id|pi-&gt;next
op_assign
id|ioinfo
(braket
id|irq
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* initialize some values ... */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq
op_assign
id|irq
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|st
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.st
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|st
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.pgid_supp
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pim
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pam
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pom
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
)paren
(brace
r_for
c_loop
(paren
id|chp
op_assign
l_int|0
suffix:semicolon
id|chp
op_le
l_int|7
suffix:semicolon
id|chp
op_increment
)paren
(brace
id|mask
op_assign
l_int|0x80
op_rshift
id|chp
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_amp
id|mask
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|chsc_chpid_logical
(paren
id|irq
comma
id|chp
)paren
)paren
(brace
multiline_comment|/* disable using this path */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_and_assign
op_complement
id|mask
suffix:semicolon
)brace
)brace
)brace
)brace
id|CIO_DEBUG_IFMSG
c_func
(paren
id|KERN_INFO
comma
l_int|0
comma
l_string|&quot;Detected device %04X &quot;
l_string|&quot;on subchannel %04X&quot;
l_string|&quot; - PIM = %02X, &quot;
l_string|&quot;PAM = %02X, POM = %02X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pim
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pam
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pom
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize ioinfo structure&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|nopfunc
op_assign
l_int|NULL
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.dval
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.intparm
op_assign
l_int|0
suffix:semicolon
)brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devno
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
suffix:semicolon
multiline_comment|/*&n;&t; * We should have at least one CHPID ...&n;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
)paren
(brace
multiline_comment|/*&n;&t;&t; * We now have to initially ...&n;&t;&t; *  ... set &quot;interruption subclass&quot;&n;&t;&t; *  ... enable &quot;concurrent sense&quot;&n;&t;&t; *  ... enable &quot;multipath mode&quot; if more than one&n;&t;&t; *        CHPID is available. This is done regardless&n;&t;&t; *        whether multiple paths are available for us.&n;&t;&t; *&n;&t;&t; * Note : we don&squot;t enable the device here, this is temporarily&n;&t;&t; *        done during device sensing below.&n;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.isc
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* could be smth. else */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.csense
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* concurrent sense */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.ena
op_assign
id|enable
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.intparm
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_ne
l_int|0x80
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_ne
l_int|0x40
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_ne
l_int|0x20
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_ne
l_int|0x10
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_ne
l_int|0x08
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_ne
l_int|0x04
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_ne
l_int|0x02
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_ne
l_int|0x01
)paren
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.mp
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* multipath mode */
)brace
id|retry
op_assign
l_int|5
suffix:semicolon
r_do
(brace
id|ccode2
op_assign
id|msch_err
(paren
id|irq
comma
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode2
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * successful completion&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * concurrent sense facility available&n;&t;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.consns
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * status pending&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * How can we have a pending status &n;&t;&t;&t;&t; * as the device is disabled for &n;&t;&t;&t;&t; * interrupts ?&n;&t;&t;&t;&t; * Anyway, process it ...&n;&t;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|1
suffix:semicolon
id|s390_process_IRQ
(paren
id|irq
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|0
suffix:semicolon
id|retry
op_decrement
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * busy&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * we mark it not-oper as we can&squot;t &n;&t;&t;&t;&t; * properly operate it !&n;&t;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|udelay
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* allow for recovery */
id|retry
op_decrement
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* not operational */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|retry
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
DECL|macro|PGMCHK_OPERAND_EXC
mdefine_line|#define PGMCHK_OPERAND_EXC      0x15
r_if
c_cond
(paren
(paren
id|ccode2
op_amp
id|PGMCHK_OPERAND_EXC
)paren
op_eq
id|PGMCHK_OPERAND_EXC
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * re-issue the modify subchannel without trying to&n;&t;&t;&t;&t;&t; *  enable the concurrent sense facility&n;&t;&t;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.csense
op_assign
l_int|0
suffix:semicolon
id|ccode2
op_assign
id|msch_err
(paren
id|irq
comma
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccode2
op_ne
l_int|0
)paren
(brace
id|CIO_DEBUG_ALWAYS
c_func
(paren
id|KERN_ERR
comma
l_int|0
comma
l_string|&quot;msch() (2) failed&quot;
l_string|&quot; with CC=%X&bslash;n&quot;
comma
id|ccode2
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui
dot
id|flags.consns
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|CIO_DEBUG_ALWAYS
c_func
(paren
id|KERN_ERR
comma
l_int|0
comma
l_string|&quot;msch() (1) failed with &quot;
l_string|&quot;CC = %X&bslash;n&quot;
comma
id|ccode2
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
id|retry
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|ccode2
op_logical_and
id|retry
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ccode2
op_ne
l_int|0
)paren
op_logical_and
(paren
id|ccode2
op_ne
l_int|3
)paren
op_logical_and
(paren
op_logical_neg
id|retry
)paren
)paren
(brace
id|CIO_DEBUG_ALWAYS
c_func
(paren
id|KERN_ERR
comma
l_int|0
comma
l_string|&quot; ... msch() retry count for &quot;
l_string|&quot;subchannel %04X exceeded, CC = %d&bslash;n&quot;
comma
id|irq
comma
id|ccode2
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* no path available ... */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * s390_SenseID&n; *&n; * Try to obtain the &squot;control unit&squot;/&squot;device type&squot; information&n; *  associated with the subchannel.&n; *&n; * The function is primarily meant to be called without irq&n; *  action handler in place. However, it also allows for&n; *  use with an action handler in place. If there is already&n; *  an action handler registered assure it can handle the&n; *  s390_SenseID() related device interrupts - interruption&n; *  parameter used is 0x00E2C9C4 ( SID ).&n; */
r_static
r_int
DECL|function|s390_SenseID
id|s390_SenseID
(paren
r_int
id|irq
comma
id|senseid_t
op_star
id|sid
comma
id|__u8
id|lpm
)paren
(brace
id|ccw1_t
op_star
id|sense_ccw
suffix:semicolon
multiline_comment|/* ccw area for SenseID command */
id|senseid_t
id|isid
suffix:semicolon
multiline_comment|/* internal sid */
id|devstat_t
id|devstat
suffix:semicolon
multiline_comment|/* required by request_irq() */
id|__u8
id|pathmask
suffix:semicolon
multiline_comment|/* calulate path mask */
id|__u8
id|domask
suffix:semicolon
multiline_comment|/* path mask to use */
r_int
id|inlreq
suffix:semicolon
multiline_comment|/* inline request_irq() */
r_int
id|irq_ret
suffix:semicolon
multiline_comment|/* return code */
id|devstat_t
op_star
id|pdevstat
suffix:semicolon
multiline_comment|/* ptr to devstat in use */
r_int
id|retry
suffix:semicolon
multiline_comment|/* retry count */
r_int
id|io_retry
suffix:semicolon
multiline_comment|/* retry indicator */
id|senseid_t
op_star
id|psid
op_assign
id|sid
suffix:semicolon
multiline_comment|/* start with the external buffer */
r_int
id|sbuffer
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* switch SID data buffer */
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|failure
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* nothing went wrong yet */
id|SANITY_CHECK
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_eq
l_int|0
)paren
(brace
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;snsID%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
id|inlreq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* to make the compiler quiet... */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
id|pdevstat
op_assign
op_amp
id|devstat
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Perform SENSE ID command processing. We have to request device&n;&t;&t; *  ownership and provide a dummy I/O handler. We issue sync. I/O&n;&t;&t; *  requests and evaluate the devstat area on return therefore&n;&t;&t; *  we don&squot;t need a real I/O handler in place.&n;&t;&t; */
id|irq_ret
op_assign
id|request_irq
(paren
id|irq
comma
id|init_IRQ_handler
comma
id|SA_PROBE
comma
l_string|&quot;SID&quot;
comma
op_amp
id|devstat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_ret
op_eq
l_int|0
)paren
id|inlreq
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|inlreq
op_assign
l_int|0
suffix:semicolon
id|irq_ret
op_assign
l_int|0
suffix:semicolon
id|pdevstat
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irq_ret
)paren
(brace
r_return
id|irq_ret
suffix:semicolon
)brace
id|s390irq_spin_lock
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
(brace
id|sense_ccw
op_assign
id|kmalloc
(paren
l_int|2
op_star
r_sizeof
(paren
id|ccw1_t
)paren
comma
id|GFP_DMA
)paren
suffix:semicolon
)brace
r_else
(brace
id|sense_ccw
op_assign
id|alloc_bootmem_low
(paren
l_int|2
op_star
r_sizeof
(paren
id|ccw1_t
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* more than one path installed ? */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pim
op_ne
l_int|0x80
)paren
(brace
id|sense_ccw
(braket
l_int|0
)braket
dot
id|cmd_code
op_assign
id|CCW_CMD_SUSPEND_RECONN
suffix:semicolon
id|sense_ccw
(braket
l_int|0
)braket
dot
id|cda
op_assign
l_int|0
suffix:semicolon
id|sense_ccw
(braket
l_int|0
)braket
dot
id|count
op_assign
l_int|0
suffix:semicolon
id|sense_ccw
(braket
l_int|0
)braket
dot
id|flags
op_assign
id|CCW_FLAG_SLI
op_or
id|CCW_FLAG_CC
suffix:semicolon
id|sense_ccw
(braket
l_int|1
)braket
dot
id|cmd_code
op_assign
id|CCW_CMD_SENSE_ID
suffix:semicolon
id|sense_ccw
(braket
l_int|1
)braket
dot
id|cda
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
(paren
id|sid
)paren
suffix:semicolon
id|sense_ccw
(braket
l_int|1
)braket
dot
id|count
op_assign
r_sizeof
(paren
id|senseid_t
)paren
suffix:semicolon
id|sense_ccw
(braket
l_int|1
)braket
dot
id|flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
)brace
r_else
(brace
id|sense_ccw
(braket
l_int|0
)braket
dot
id|cmd_code
op_assign
id|CCW_CMD_SENSE_ID
suffix:semicolon
id|sense_ccw
(braket
l_int|0
)braket
dot
id|cda
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
(paren
id|sid
)paren
suffix:semicolon
id|sense_ccw
(braket
l_int|0
)braket
dot
id|count
op_assign
r_sizeof
(paren
id|senseid_t
)paren
suffix:semicolon
id|sense_ccw
(braket
l_int|0
)braket
dot
id|flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
l_int|8
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pathmask
op_assign
l_int|0x80
op_rshift
id|i
suffix:semicolon
id|domask
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_amp
id|pathmask
suffix:semicolon
r_if
c_cond
(paren
id|lpm
)paren
id|domask
op_and_assign
id|lpm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|domask
)paren
r_continue
suffix:semicolon
id|failure
op_assign
l_int|0
suffix:semicolon
id|psid-&gt;reserved
op_assign
l_int|0
suffix:semicolon
id|psid-&gt;cu_type
op_assign
l_int|0xFFFF
suffix:semicolon
multiline_comment|/* initialize fields ... */
id|psid-&gt;cu_model
op_assign
l_int|0
suffix:semicolon
id|psid-&gt;dev_type
op_assign
l_int|0
suffix:semicolon
id|psid-&gt;dev_model
op_assign
l_int|0
suffix:semicolon
id|retry
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* retry count    */
id|io_retry
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* enable retries */
multiline_comment|/*&n;&t;&t; * We now issue a SenseID request. In case of BUSY,&n;&t;&t; *  STATUS PENDING or non-CMD_REJECT error conditions&n;&t;&t; *  we run simple retries.&n;&t;&t; */
r_do
(brace
id|memset
(paren
id|pdevstat
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|devstat_t
)paren
)paren
suffix:semicolon
id|irq_ret
op_assign
id|s390_start_IO
(paren
id|irq
comma
id|sense_ccw
comma
l_int|0x00E2C9C4
comma
multiline_comment|/* == SID */
id|domask
comma
id|DOIO_WAIT_FOR_INTERRUPT
op_or
id|DOIO_TIMEOUT
op_or
id|DOIO_VALID_LPM
op_or
id|DOIO_DONT_CALL_INTHDLR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|psid-&gt;cu_type
op_ne
l_int|0xFFFF
)paren
op_logical_and
(paren
id|psid-&gt;reserved
op_eq
l_int|0xFF
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sbuffer
)paren
(brace
multiline_comment|/* switch buffers */
multiline_comment|/*&n;&t;&t;&t;&t;&t; * we report back the&n;&t;&t;&t;&t;&t; *  first hit only&n;&t;&t;&t;&t;&t; */
id|psid
op_assign
op_amp
id|isid
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pim
op_ne
l_int|0x80
)paren
(brace
id|sense_ccw
(braket
l_int|1
)braket
dot
id|cda
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
(paren
id|psid
)paren
suffix:semicolon
)brace
r_else
(brace
id|sense_ccw
(braket
l_int|0
)braket
dot
id|cda
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
(paren
id|psid
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * if just the very first&n;&t;&t;&t;&t;&t; *  was requested to be&n;&t;&t;&t;&t;&t; *  sensed disable further&n;&t;&t;&t;&t;&t; *  scans.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|lpm
)paren
id|lpm
op_assign
id|domask
suffix:semicolon
id|sbuffer
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pdevstat-&gt;rescnt
OL
(paren
r_sizeof
(paren
id|senseid_t
)paren
op_minus
l_int|8
)paren
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.esid
op_assign
l_int|1
suffix:semicolon
)brace
id|io_retry
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|failure
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pdevstat-&gt;flag
op_amp
id|DEVSTAT_STATUS_PENDING
)paren
(brace
id|CIO_DEBUG
(paren
id|KERN_DEBUG
comma
l_int|2
comma
l_string|&quot;SenseID : device %04X on &quot;
l_string|&quot;Subchannel %04X &quot;
l_string|&quot;reports pending status, &quot;
l_string|&quot;retry : %d&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
comma
id|retry
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pdevstat-&gt;flag
op_amp
id|DEVSTAT_FLAG_SENSE_AVAIL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * if the device doesn&squot;t support the SenseID&n;&t;&t;&t;&t; *  command further retries wouldn&squot;t help ...&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|pdevstat-&gt;ii.sense.data
(braket
l_int|0
)braket
op_amp
(paren
id|SNS0_CMD_REJECT
op_or
id|SNS0_INTERVENTION_REQ
)paren
)paren
(brace
id|CIO_DEBUG
c_func
(paren
id|KERN_ERR
comma
l_int|2
comma
l_string|&quot;SenseID : device %04X on &quot;
l_string|&quot;Subchannel %04X &quot;
l_string|&quot;reports cmd reject or &quot;
l_string|&quot;intervention required&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
)paren
suffix:semicolon
id|io_retry
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|CIO_DEBUG
c_func
(paren
id|KERN_WARNING
comma
l_int|2
comma
l_string|&quot;SenseID : UC on &quot;
l_string|&quot;dev %04X, retry %d, &quot;
l_string|&quot;lpum %02X, &quot;
l_string|&quot;cnt %02d, sns :&quot;
l_string|&quot; %02X%02X%02X%02X &quot;
l_string|&quot;%02X%02X%02X%02X ...&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|retry
comma
id|pdevstat-&gt;lpum
comma
id|pdevstat-&gt;scnt
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|0
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|1
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|2
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|3
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|4
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|5
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|6
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|7
)braket
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|pdevstat-&gt;flag
op_amp
id|DEVSTAT_NOT_OPER
)paren
op_logical_or
(paren
id|irq_ret
op_eq
op_minus
id|ENODEV
)paren
)paren
(brace
id|CIO_DEBUG
c_func
(paren
id|KERN_ERR
comma
l_int|2
comma
l_string|&quot;SenseID : path %02X for &quot;
l_string|&quot;device %04X on &quot;
l_string|&quot;subchannel %04X &quot;
l_string|&quot;is &squot;not operational&squot;&bslash;n&quot;
comma
id|domask
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
)paren
suffix:semicolon
id|io_retry
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_and_assign
op_complement
id|domask
suffix:semicolon
)brace
r_else
(brace
id|CIO_DEBUG
c_func
(paren
id|KERN_INFO
comma
l_int|2
comma
l_string|&quot;SenseID : start_IO() for &quot;
l_string|&quot;device %04X on &quot;
l_string|&quot;subchannel %04X &quot;
l_string|&quot;returns %d, retry %d, &quot;
l_string|&quot;status %04X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
comma
id|irq_ret
comma
id|retry
comma
id|pdevstat-&gt;flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_ret
op_eq
op_minus
id|ETIMEDOUT
)paren
(brace
r_int
id|xret
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Seems we need to cancel the first ssch sometimes...&n;&t;&t;&t;&t;&t; * On the next try, the ssch will usually be fine.&n;&t;&t;&t;&t;&t; */
id|xret
op_assign
id|cancel_IO
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xret
)paren
id|CIO_MSG_EVENT
c_func
(paren
l_int|4
comma
l_string|&quot;SenseID: sch canceled &quot;
l_string|&quot;successfully for irq %x&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|io_retry
)paren
(brace
id|retry
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|retry
op_eq
l_int|0
)paren
(brace
id|io_retry
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|failure
)paren
op_logical_and
(paren
id|io_retry
)paren
)paren
(brace
multiline_comment|/* reset fields... */
id|failure
op_assign
l_int|0
suffix:semicolon
id|psid-&gt;reserved
op_assign
l_int|0
suffix:semicolon
id|psid-&gt;cu_type
op_assign
l_int|0xFFFF
suffix:semicolon
id|psid-&gt;cu_model
op_assign
l_int|0
suffix:semicolon
id|psid-&gt;dev_type
op_assign
l_int|0
suffix:semicolon
id|psid-&gt;dev_model
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|io_retry
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
(brace
id|kfree
(paren
id|sense_ccw
)paren
suffix:semicolon
)brace
r_else
(brace
id|free_bootmem
(paren
(paren
r_int
r_int
)paren
id|sense_ccw
comma
l_int|2
op_star
r_sizeof
(paren
id|ccw1_t
)paren
)paren
suffix:semicolon
)brace
id|s390irq_spin_unlock
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we installed the irq action handler we have to&n;&t; *  release it too.&n;&t; */
r_if
c_cond
(paren
id|inlreq
)paren
id|free_irq
(paren
id|irq
comma
id|pdevstat
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * if running under VM check there ... perhaps we should do&n;&t; *  only if we suffered a command reject, but it doesn&squot;t harm&n;&t; */
r_if
c_cond
(paren
(paren
id|sid-&gt;cu_type
op_eq
l_int|0xFFFF
)paren
op_logical_and
(paren
id|MACHINE_IS_VM
)paren
)paren
(brace
id|_VM_virtual_device_info
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|sid
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sid-&gt;cu_type
op_eq
l_int|0xFFFF
)paren
(brace
multiline_comment|/*&n;&t;&t; * SenseID CU-type of 0xffff indicates that no device&n;&t;&t; *  information could be retrieved (pre-init value).&n;&t;&t; *&n;&t;&t; * If we can&squot;t couldn&squot;t identify the device type we&n;&t;&t; *  consider the device &quot;not operational&quot;.&n;&t;&t; */
id|CIO_DEBUG
c_func
(paren
id|KERN_WARNING
comma
l_int|2
comma
l_string|&quot;SenseID : unknown device %04X on subchannel %04X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.unknown
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Issue device info message if unit was operational .&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.unknown
)paren
(brace
r_if
c_cond
(paren
id|sid-&gt;dev_type
op_ne
l_int|0
)paren
(brace
id|CIO_DEBUG_IFMSG
c_func
(paren
id|KERN_INFO
comma
l_int|2
comma
l_string|&quot;SenseID : device %04X reports: &quot;
l_string|&quot;CU  Type/Mod = %04X/%02X,&quot;
l_string|&quot; Dev Type/Mod = %04X/%02X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|sid-&gt;cu_type
comma
id|sid-&gt;cu_model
comma
id|sid-&gt;dev_type
comma
id|sid-&gt;dev_model
)paren
suffix:semicolon
)brace
r_else
(brace
id|CIO_DEBUG_IFMSG
c_func
(paren
id|KERN_INFO
comma
l_int|2
comma
l_string|&quot;SenseID : device %04X reports:&quot;
l_string|&quot; Dev Type/Mod = %04X/%02X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|sid-&gt;cu_type
comma
id|sid-&gt;cu_model
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.unknown
)paren
id|irq_ret
op_assign
l_int|0
suffix:semicolon
r_else
id|irq_ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_return
(paren
id|irq_ret
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Device Path Verification&n; *&n; * Path verification is accomplished by checking which paths (CHPIDs) are&n; *  available. Further, a path group ID is set, if possible in multipath&n; *  mode, otherwise in single path mode.&n; *&n; * Note : This function must not be called during normal device recognition,&n; *         but during device driver initiated request_irq() processing only.&n; */
r_int
DECL|function|s390_DevicePathVerification
id|s390_DevicePathVerification
(paren
r_int
id|irq
comma
id|__u8
id|usermask
)paren
(brace
r_int
id|ccode
suffix:semicolon
id|__u8
id|pathmask
suffix:semicolon
id|__u8
id|domask
suffix:semicolon
r_int
id|chp
suffix:semicolon
r_int
id|mask
suffix:semicolon
r_int
id|old_opm
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|pgid_t
id|pgid
suffix:semicolon
id|__u8
id|dev_path
suffix:semicolon
r_int
id|first
op_assign
l_int|1
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;dpver%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|st
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|old_opm
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
suffix:semicolon
id|ccode
op_assign
id|stsch
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccode
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pim
op_eq
l_int|0x80
)paren
(brace
multiline_comment|/*&n;&t;&t; * no error, just not required for single path only devices&n;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.pgid_supp
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * disable if chpid is logically offline&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|chsc_chpid_logical
c_func
(paren
id|irq
comma
l_int|0
)paren
)paren
(brace
id|not_oper_handler_func_t
id|nopfunc
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|nopfunc
suffix:semicolon
r_int
id|was_oper
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|CIO_DEBUG_ALWAYS
c_func
(paren
id|KERN_WARNING
comma
l_int|0
comma
l_string|&quot;No logical path for sch %d...&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_opm
op_logical_and
id|was_oper
op_logical_and
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
id|free_irq
c_func
(paren
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nopfunc
)paren
id|nopfunc
c_func
(paren
id|irq
comma
id|DEVSTAT_DEVICE_GONE
)paren
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|old_opm
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * check for opm...&n;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pim
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pam
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pom
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
)paren
(brace
id|devreg_t
op_star
id|pdevreg
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|1
suffix:semicolon
id|pdevreg
op_assign
id|s390_search_devreg
c_func
(paren
id|ioinfo
(braket
id|irq
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pdevreg
)paren
r_if
c_cond
(paren
id|pdevreg-&gt;oper_func
)paren
id|pdevreg-&gt;oper_func
(paren
id|irq
comma
id|pdevreg
)paren
suffix:semicolon
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pim
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pam
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pom
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
)paren
(brace
r_for
c_loop
(paren
id|chp
op_assign
l_int|0
suffix:semicolon
id|chp
op_le
l_int|7
suffix:semicolon
id|chp
op_increment
)paren
(brace
id|mask
op_assign
l_int|0x80
op_rshift
id|chp
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_amp
id|mask
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|chsc_chpid_logical
(paren
id|irq
comma
id|chp
)paren
)paren
(brace
multiline_comment|/* disable using this path */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_and_assign
op_complement
id|mask
suffix:semicolon
)brace
)brace
)brace
)brace
r_if
c_cond
(paren
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_eq
l_int|0
)paren
op_logical_and
(paren
id|old_opm
)paren
)paren
(brace
id|not_oper_handler_func_t
id|nopfunc
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|nopfunc
suffix:semicolon
r_int
id|was_oper
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|CIO_DEBUG_ALWAYS
c_func
(paren
id|KERN_WARNING
comma
l_int|0
comma
l_string|&quot;No logical path for sch %d...&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|was_oper
op_logical_and
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
)paren
(brace
id|free_irq
c_func
(paren
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nopfunc
)paren
id|nopfunc
c_func
(paren
id|irq
comma
id|DEVSTAT_DEVICE_GONE
)paren
suffix:semicolon
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|old_opm
)paren
(brace
multiline_comment|/* Hey, we have a new logical path... */
id|devreg_t
op_star
id|pdevreg
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|1
suffix:semicolon
id|pdevreg
op_assign
id|s390_search_devreg
c_func
(paren
id|ioinfo
(braket
id|irq
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pdevreg
)paren
r_if
c_cond
(paren
id|pdevreg-&gt;oper_func
)paren
id|pdevreg
op_member_access_from_pointer
id|oper_func
c_func
(paren
id|irq
comma
id|pdevreg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.pgid_supp
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* just exit ... */
r_if
c_cond
(paren
id|usermask
)paren
(brace
id|dev_path
op_assign
id|usermask
suffix:semicolon
)brace
r_else
(brace
id|dev_path
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.pgid
op_eq
l_int|0
)paren
(brace
id|memcpy
(paren
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|pgid
comma
op_amp
id|global_pgid
comma
r_sizeof
(paren
id|pgid_t
)paren
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.pgid
op_assign
l_int|1
suffix:semicolon
)brace
id|memcpy
(paren
op_amp
id|pgid
comma
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|pgid
comma
r_sizeof
(paren
id|pgid_t
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
op_logical_and
op_logical_neg
id|ret
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pathmask
op_assign
l_int|0x80
op_rshift
id|i
suffix:semicolon
id|domask
op_assign
id|dev_path
op_amp
id|pathmask
suffix:semicolon
r_if
c_cond
(paren
id|domask
)paren
(brace
id|ret
op_assign
id|s390_SetPGID
(paren
id|irq
comma
id|domask
comma
op_amp
id|pgid
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * For the *first* path we are prepared&n;&t;&t;&t; *  for recovery&n;&t;&t;&t; *&n;&t;&t;&t; *  - If we fail setting the PGID we assume its&n;&t;&t;&t; *     using  a different PGID already (VM) we&n;&t;&t;&t; *     try to sense.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EOPNOTSUPP
op_logical_and
id|first
)paren
(brace
op_star
(paren
r_int
op_star
)paren
op_amp
id|pgid
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|s390_SensePGID
(paren
id|irq
comma
id|domask
comma
op_amp
id|pgid
)paren
suffix:semicolon
id|first
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Check whether we retrieved&n;&t;&t;&t;&t;&t; *  a reasonable PGID ...&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|pgid.inf.ps.state1
op_eq
id|SNID_STATE1_GROUPED
)paren
(brace
id|memcpy
(paren
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|pgid
comma
op_amp
id|pgid
comma
r_sizeof
(paren
id|pgid_t
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* ungrouped or garbage ... */
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.pgid_supp
op_assign
l_int|0
suffix:semicolon
id|CIO_DEBUG
c_func
(paren
id|KERN_WARNING
comma
l_int|2
comma
l_string|&quot;PathVerification(%04X) &quot;
l_string|&quot;- Device %04X doesn&squot;t &quot;
l_string|&quot; support path grouping&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EIO
)paren
(brace
id|CIO_DEBUG
c_func
(paren
id|KERN_ERR
comma
l_int|2
comma
l_string|&quot;PathVerification(%04X) - I/O error &quot;
l_string|&quot;on device %04X&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.pgid_supp
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|ETIMEDOUT
)paren
(brace
id|CIO_DEBUG
c_func
(paren
id|KERN_ERR
comma
l_int|2
comma
l_string|&quot;PathVerification(%04X) - I/O timed &quot;
l_string|&quot;out on device %04X&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.pgid_supp
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EAGAIN
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|CIO_DEBUG
c_func
(paren
id|KERN_ERR
comma
l_int|2
comma
l_string|&quot;PathVerification(%04X) - &quot;
l_string|&quot;Unexpected error on device %04X&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.pgid_supp
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * s390_SetPGID&n; *&n; * Set Path Group ID&n; *&n; */
r_static
r_int
DECL|function|s390_SetPGID
id|s390_SetPGID
(paren
r_int
id|irq
comma
id|__u8
id|lpm
comma
id|pgid_t
op_star
id|pgid
)paren
(brace
id|ccw1_t
op_star
id|spid_ccw
suffix:semicolon
multiline_comment|/* ccw area for SPID command */
id|devstat_t
id|devstat
suffix:semicolon
multiline_comment|/* required by request_irq() */
id|devstat_t
op_star
id|pdevstat
op_assign
op_amp
id|devstat
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
r_int
id|irq_ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* return code */
r_int
id|retry
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* retry count */
r_int
id|inlreq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* inline request_irq() */
r_int
id|mpath
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* try multi-path first */
id|SANITY_CHECK
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_eq
l_int|0
)paren
(brace
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;SPID%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
multiline_comment|/*&n;&t;&t; * Perform SetPGID command processing. We have to request device&n;&t;&t; *  ownership and provide a dummy I/O handler. We issue sync. I/O&n;&t;&t; *  requests and evaluate the devstat area on return therefore&n;&t;&t; *  we don&squot;t need a real I/O handler in place.&n;&t;&t; */
id|irq_ret
op_assign
id|request_irq
(paren
id|irq
comma
id|init_IRQ_handler
comma
id|SA_PROBE
comma
l_string|&quot;SPID&quot;
comma
id|pdevstat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_ret
op_eq
l_int|0
)paren
id|inlreq
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|pdevstat
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irq_ret
)paren
(brace
r_return
id|irq_ret
suffix:semicolon
)brace
id|s390irq_spin_lock_irqsave
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
(brace
id|spid_ccw
op_assign
id|kmalloc
(paren
l_int|2
op_star
r_sizeof
(paren
id|ccw1_t
)paren
comma
id|GFP_DMA
)paren
suffix:semicolon
)brace
r_else
(brace
id|spid_ccw
op_assign
id|alloc_bootmem_low
(paren
l_int|2
op_star
r_sizeof
(paren
id|ccw1_t
)paren
)paren
suffix:semicolon
)brace
id|spid_ccw
(braket
l_int|0
)braket
dot
id|cmd_code
op_assign
id|CCW_CMD_SUSPEND_RECONN
suffix:semicolon
id|spid_ccw
(braket
l_int|0
)braket
dot
id|cda
op_assign
l_int|0
suffix:semicolon
id|spid_ccw
(braket
l_int|0
)braket
dot
id|count
op_assign
l_int|0
suffix:semicolon
id|spid_ccw
(braket
l_int|0
)braket
dot
id|flags
op_assign
id|CCW_FLAG_SLI
op_or
id|CCW_FLAG_CC
suffix:semicolon
id|spid_ccw
(braket
l_int|1
)braket
dot
id|cmd_code
op_assign
id|CCW_CMD_SET_PGID
suffix:semicolon
id|spid_ccw
(braket
l_int|1
)braket
dot
id|cda
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
(paren
id|pgid
)paren
suffix:semicolon
id|spid_ccw
(braket
l_int|1
)braket
dot
id|count
op_assign
r_sizeof
(paren
id|pgid_t
)paren
suffix:semicolon
id|spid_ccw
(braket
l_int|1
)braket
dot
id|flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
id|pgid-&gt;inf.fc
op_assign
id|SPID_FUNC_MULTI_PATH
op_or
id|SPID_FUNC_ESTABLISH
suffix:semicolon
multiline_comment|/*&n;&t; * We now issue a SetPGID request. In case of BUSY&n;&t; *  or STATUS PENDING conditions we retry 5 times.&n;&t; */
r_do
(brace
id|memset
(paren
id|pdevstat
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|devstat_t
)paren
)paren
suffix:semicolon
id|irq_ret
op_assign
id|s390_start_IO
(paren
id|irq
comma
id|spid_ccw
comma
l_int|0xE2D7C9C4
comma
multiline_comment|/* == SPID */
id|lpm
comma
multiline_comment|/* n/a */
id|DOIO_WAIT_FOR_INTERRUPT
op_or
id|DOIO_VALID_LPM
op_or
id|DOIO_DONT_CALL_INTHDLR
op_or
id|DOIO_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|irq_ret
)paren
(brace
r_if
c_cond
(paren
id|pdevstat-&gt;flag
op_amp
id|DEVSTAT_STATUS_PENDING
)paren
(brace
id|CIO_DEBUG
c_func
(paren
id|KERN_DEBUG
comma
l_int|2
comma
l_string|&quot;SPID - Device %04X &quot;
l_string|&quot;on Subchannel %04X &quot;
l_string|&quot;reports pending status, &quot;
l_string|&quot;retry : %d&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
comma
id|retry
)paren
suffix:semicolon
id|retry
op_decrement
suffix:semicolon
id|irq_ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pdevstat-&gt;flag
op_eq
(paren
id|DEVSTAT_START_FUNCTION
op_or
id|DEVSTAT_FINAL_STATUS
)paren
)paren
(brace
id|retry
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* successfully set ... */
id|irq_ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pdevstat-&gt;flag
op_amp
id|DEVSTAT_FLAG_SENSE_AVAIL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * If the device doesn&squot;t support the&n;&t;&t;&t;&t; *  Sense Path Group ID command&n;&t;&t;&t;&t; *  further retries wouldn&squot;t help ...&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|pdevstat-&gt;ii.sense
dot
id|data
(braket
l_int|0
)braket
op_amp
id|SNS0_CMD_REJECT
)paren
(brace
r_if
c_cond
(paren
id|mpath
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * We now try single path mode.&n;&t;&t;&t;&t;&t;&t; * Note we must not issue the suspend&n;&t;&t;&t;&t;&t;&t; * multipath reconnect, or we will get&n;&t;&t;&t;&t;&t;&t; * a command reject by tapes.&n;&t;&t;&t;&t;&t;&t; */
id|spid_ccw
(braket
l_int|0
)braket
dot
id|cmd_code
op_assign
id|CCW_CMD_SET_PGID
suffix:semicolon
id|spid_ccw
(braket
l_int|0
)braket
dot
id|cda
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
(paren
id|pgid
)paren
suffix:semicolon
id|spid_ccw
(braket
l_int|0
)braket
dot
id|count
op_assign
r_sizeof
(paren
id|pgid_t
)paren
suffix:semicolon
id|spid_ccw
(braket
l_int|0
)braket
dot
id|flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
id|pgid-&gt;inf.fc
op_assign
id|SPID_FUNC_SINGLE_PATH
op_or
id|SPID_FUNC_ESTABLISH
suffix:semicolon
id|mpath
op_assign
l_int|0
suffix:semicolon
id|retry
op_decrement
suffix:semicolon
id|irq_ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|irq_ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
id|retry
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|CIO_DEBUG
c_func
(paren
id|KERN_WARNING
comma
l_int|2
comma
l_string|&quot;SPID - device %04X,&quot;
l_string|&quot; unit check,&quot;
l_string|&quot; retry %d, cnt %02d,&quot;
l_string|&quot; sns :&quot;
l_string|&quot; %02X%02X%02X%02X &quot;
l_string|&quot;%02X%02X%02X%02X ...&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|retry
comma
id|pdevstat-&gt;scnt
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|0
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|1
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|2
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|3
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|4
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|5
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|6
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|retry
op_decrement
suffix:semicolon
id|irq_ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|pdevstat-&gt;flag
op_amp
id|DEVSTAT_NOT_OPER
)paren
(brace
multiline_comment|/* don&squot;t issue warnings during startup unless requested */
r_if
c_cond
(paren
id|init_IRQ_complete
op_logical_or
id|cio_notoper_msg
)paren
(brace
id|CIO_DEBUG_ALWAYS
c_func
(paren
id|KERN_WARNING
comma
l_int|2
comma
l_string|&quot;SPID - Device %04X &quot;
l_string|&quot;on Subchannel %04X, &quot;
l_string|&quot;lpm %02X, &quot;
l_string|&quot;became &squot;not &quot;
l_string|&quot;operational&squot;&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
dot
id|pmcw.dev
comma
id|irq
comma
id|lpm
)paren
suffix:semicolon
)brace
id|retry
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_and_assign
op_complement
id|lpm
suffix:semicolon
id|irq_ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|irq_ret
op_eq
op_minus
id|ETIMEDOUT
)paren
(brace
multiline_comment|/* &n;&t;&t;&t; * SetPGID timed out, so we cancel it before&n;&t;&t;&t; * we retry&n;&t;&t;&t; */
r_int
id|xret
suffix:semicolon
id|xret
op_assign
id|cancel_IO
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xret
)paren
id|CIO_MSG_EVENT
c_func
(paren
l_int|2
comma
l_string|&quot;SetPGID: sch canceled &quot;
l_string|&quot;successfully for irq %x&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
id|retry
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|irq_ret
op_ne
op_minus
id|ENODEV
)paren
(brace
id|retry
op_decrement
suffix:semicolon
id|irq_ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|retry
op_assign
l_int|0
suffix:semicolon
id|irq_ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|retry
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
(brace
id|kfree
(paren
id|spid_ccw
)paren
suffix:semicolon
)brace
r_else
(brace
id|free_bootmem
(paren
(paren
r_int
r_int
)paren
id|spid_ccw
comma
l_int|2
op_star
r_sizeof
(paren
id|ccw1_t
)paren
)paren
suffix:semicolon
)brace
id|s390irq_spin_unlock_irqrestore
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we installed the irq action handler we have to&n;&t; *  release it too.&n;&t; */
r_if
c_cond
(paren
id|inlreq
)paren
id|free_irq
(paren
id|irq
comma
id|pdevstat
)paren
suffix:semicolon
r_return
(paren
id|irq_ret
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * s390_SensePGID&n; *&n; * Sense Path Group ID&n; *&n; */
r_static
r_int
DECL|function|s390_SensePGID
id|s390_SensePGID
(paren
r_int
id|irq
comma
id|__u8
id|lpm
comma
id|pgid_t
op_star
id|pgid
)paren
(brace
id|ccw1_t
op_star
id|snid_ccw
suffix:semicolon
multiline_comment|/* ccw area for SNID command */
id|devstat_t
id|devstat
suffix:semicolon
multiline_comment|/* required by request_irq() */
id|devstat_t
op_star
id|pdevstat
op_assign
op_amp
id|devstat
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
r_int
id|irq_ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* return code */
r_int
id|retry
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* retry count */
r_int
id|inlreq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* inline request_irq() */
r_int
r_int
id|flags
suffix:semicolon
id|SANITY_CHECK
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_eq
l_int|0
)paren
(brace
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;SNID%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
multiline_comment|/*&n;&t;&t; * Perform SENSE PGID command processing. We have to request device&n;&t;&t; *  ownership and provide a dummy I/O handler. We issue sync. I/O&n;&t;&t; *  requests and evaluate the devstat area on return therefore&n;&t;&t; *  we don&squot;t need a real I/O handler in place.&n;&t;&t; */
id|irq_ret
op_assign
id|request_irq
(paren
id|irq
comma
id|init_IRQ_handler
comma
id|SA_PROBE
comma
l_string|&quot;SNID&quot;
comma
id|pdevstat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_ret
op_eq
l_int|0
)paren
id|inlreq
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|pdevstat
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irq_ret
)paren
(brace
r_return
id|irq_ret
suffix:semicolon
)brace
id|s390irq_spin_lock_irqsave
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
(brace
id|snid_ccw
op_assign
id|kmalloc
(paren
r_sizeof
(paren
id|ccw1_t
)paren
comma
id|GFP_DMA
)paren
suffix:semicolon
)brace
r_else
(brace
id|snid_ccw
op_assign
id|alloc_bootmem_low
(paren
r_sizeof
(paren
id|ccw1_t
)paren
)paren
suffix:semicolon
)brace
id|snid_ccw-&gt;cmd_code
op_assign
id|CCW_CMD_SENSE_PGID
suffix:semicolon
id|snid_ccw-&gt;cda
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
(paren
id|pgid
)paren
suffix:semicolon
id|snid_ccw-&gt;count
op_assign
r_sizeof
(paren
id|pgid_t
)paren
suffix:semicolon
id|snid_ccw-&gt;flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
multiline_comment|/*&n;&t; * We now issue a SensePGID request. In case of BUSY&n;&t; *  or STATUS PENDING conditions we retry 5 times.&n;&t; */
r_do
(brace
id|memset
(paren
id|pdevstat
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|devstat_t
)paren
)paren
suffix:semicolon
id|irq_ret
op_assign
id|s390_start_IO
(paren
id|irq
comma
id|snid_ccw
comma
l_int|0xE2D5C9C4
comma
multiline_comment|/* == SNID */
id|lpm
comma
multiline_comment|/* n/a */
id|DOIO_WAIT_FOR_INTERRUPT
op_or
id|DOIO_VALID_LPM
op_or
id|DOIO_DONT_CALL_INTHDLR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|pdevstat-&gt;flag
op_amp
id|DEVSTAT_FLAG_SENSE_AVAIL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * If the device doesn&squot;t support the&n;&t;&t;&t;&t; *  Sense Path Group ID command&n;&t;&t;&t;&t; *  further retries wouldn&squot;t help ...&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|pdevstat-&gt;ii.sense
dot
id|data
(braket
l_int|0
)braket
op_amp
id|SNS0_CMD_REJECT
)paren
(brace
id|retry
op_assign
l_int|0
suffix:semicolon
id|irq_ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_else
(brace
id|CIO_DEBUG
c_func
(paren
id|KERN_WARNING
comma
l_int|2
comma
l_string|&quot;SNID - device %04X,&quot;
l_string|&quot; unit check,&quot;
l_string|&quot; flag %04X, &quot;
l_string|&quot; retry %d, cnt %02d,&quot;
l_string|&quot; sns :&quot;
l_string|&quot; %02X%02X%02X%02X &quot;
l_string|&quot;%02X%02X%02X%02X ...&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|pdevstat-&gt;flag
comma
id|retry
comma
id|pdevstat-&gt;scnt
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|0
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|1
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|2
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|3
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|4
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|5
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|6
)braket
comma
id|pdevstat-&gt;ii.sense.data
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|retry
op_decrement
suffix:semicolon
id|irq_ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|pdevstat-&gt;flag
op_amp
id|DEVSTAT_NOT_OPER
)paren
(brace
multiline_comment|/* don&squot;t issue warnings during startup unless requested */
r_if
c_cond
(paren
id|init_IRQ_complete
op_logical_or
id|cio_notoper_msg
)paren
(brace
id|CIO_DEBUG_ALWAYS
c_func
(paren
id|KERN_WARNING
comma
l_int|2
comma
l_string|&quot;SNID - Device %04X &quot;
l_string|&quot;on Subchannel %04X, &quot;
l_string|&quot;lpm %02X, &quot;
l_string|&quot;became &squot;not &quot;
l_string|&quot;operational&squot;&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
dot
id|pmcw.dev
comma
id|irq
comma
id|lpm
)paren
suffix:semicolon
)brace
id|retry
op_assign
l_int|0
suffix:semicolon
id|irq_ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|retry
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* success ... */
id|irq_ret
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|irq_ret
op_ne
op_minus
id|ENODEV
)paren
(brace
multiline_comment|/* -EIO, or -EBUSY */
r_if
c_cond
(paren
id|pdevstat-&gt;flag
op_amp
id|DEVSTAT_STATUS_PENDING
)paren
(brace
id|CIO_DEBUG
c_func
(paren
id|KERN_INFO
comma
l_int|2
comma
l_string|&quot;SNID - Device %04X &quot;
l_string|&quot;on Subchannel %04X &quot;
l_string|&quot;reports pending status, &quot;
l_string|&quot;retry : %d&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
comma
id|retry
)paren
suffix:semicolon
)brace
id|CIO_DEBUG_ALWAYS
c_func
(paren
id|KERN_INFO
comma
l_int|2
comma
l_string|&quot;SNID - device %04X,&quot;
l_string|&quot; start_io() reports rc : %d,&quot;
l_string|&quot; retrying ...&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq_ret
)paren
suffix:semicolon
id|retry
op_decrement
suffix:semicolon
id|irq_ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* -ENODEV ... */
id|retry
op_assign
l_int|0
suffix:semicolon
id|irq_ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|retry
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
(brace
id|kfree
(paren
id|snid_ccw
)paren
suffix:semicolon
)brace
r_else
(brace
id|free_bootmem
(paren
(paren
r_int
r_int
)paren
id|snid_ccw
comma
r_sizeof
(paren
id|ccw1_t
)paren
)paren
suffix:semicolon
)brace
id|s390irq_spin_unlock_irqrestore
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we installed the irq action handler we have to&n;&t; *  release it too.&n;&t; */
r_if
c_cond
(paren
id|inlreq
)paren
id|free_irq
(paren
id|irq
comma
id|pdevstat
)paren
suffix:semicolon
r_return
(paren
id|irq_ret
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function: s390_send_nop&n; * &n; * sends a nop CCW to the specified subchannel down the given path(s)&n; * FIXME: why not put nop_ccw on the stack, it&squot;s only 64 bits?&n; */
r_int
DECL|function|s390_send_nop
id|s390_send_nop
c_func
(paren
r_int
id|irq
comma
id|__u8
id|lpm
)paren
(brace
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|ccw1_t
op_star
id|nop_ccw
suffix:semicolon
id|devstat_t
id|devstat
suffix:semicolon
id|devstat_t
op_star
id|pdevstat
op_assign
op_amp
id|devstat
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|irq_ret
op_assign
l_int|0
suffix:semicolon
r_int
id|inlreq
op_assign
l_int|0
suffix:semicolon
id|SANITY_CHECK
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
)paren
multiline_comment|/* no sense in trying */
r_return
op_minus
id|ENODEV
suffix:semicolon
id|sprintf
c_func
(paren
id|dbf_txt
comma
l_string|&quot;snop%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
c_func
(paren
l_int|5
comma
id|dbf_txt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
multiline_comment|/*&n; &t;&t; * If there&squot;s no handler, use our dummy handler.&n; &t;&t; */
id|irq_ret
op_assign
id|request_irq
(paren
id|irq
comma
id|init_IRQ_handler
comma
id|SA_PROBE
comma
l_string|&quot;SNOP&quot;
comma
id|pdevstat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|irq_ret
)paren
id|inlreq
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|pdevstat
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irq_ret
)paren
r_return
id|irq_ret
suffix:semicolon
id|s390irq_spin_lock_irqsave
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
id|nop_ccw
op_assign
id|kmalloc
(paren
r_sizeof
(paren
id|ccw1_t
)paren
comma
id|GFP_DMA
)paren
suffix:semicolon
r_else
id|nop_ccw
op_assign
id|alloc_bootmem_low
(paren
r_sizeof
(paren
id|ccw1_t
)paren
)paren
suffix:semicolon
id|nop_ccw-&gt;cmd_code
op_assign
id|CCW_CMD_NOOP
suffix:semicolon
id|nop_ccw-&gt;cda
op_assign
l_int|0
suffix:semicolon
id|nop_ccw-&gt;count
op_assign
l_int|0
suffix:semicolon
id|nop_ccw-&gt;flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
id|memset
(paren
id|pdevstat
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|devstat_t
)paren
)paren
suffix:semicolon
id|irq_ret
op_assign
id|s390_start_IO
(paren
id|irq
comma
id|nop_ccw
comma
l_int|0xE2D5D6D7
comma
id|lpm
comma
id|DOIO_WAIT_FOR_INTERRUPT
op_or
id|DOIO_TIMEOUT
op_or
id|DOIO_DONT_CALL_INTHDLR
op_or
id|DOIO_VALID_LPM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_ret
op_eq
op_minus
id|ETIMEDOUT
)paren
(brace
multiline_comment|/* better cancel... */
id|cancel_IO
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
id|kfree
(paren
id|nop_ccw
)paren
suffix:semicolon
r_else
id|free_bootmem
(paren
(paren
r_int
r_int
)paren
id|nop_ccw
comma
r_sizeof
(paren
id|ccw1_t
)paren
)paren
suffix:semicolon
id|s390irq_spin_unlock_irqrestore
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inlreq
)paren
id|free_irq
(paren
id|irq
comma
id|pdevstat
)paren
suffix:semicolon
r_return
id|irq_ret
suffix:semicolon
)brace
DECL|variable|read_conf_data
id|EXPORT_SYMBOL
(paren
id|read_conf_data
)paren
suffix:semicolon
DECL|variable|read_dev_chars
id|EXPORT_SYMBOL
(paren
id|read_dev_chars
)paren
suffix:semicolon
eof
