multiline_comment|/*&n; *  drivers/s390/cio/cio.c&n; *   S/390 common I/O routines -- low level i/o calls&n; *   $Revision: 1.15 $&n; *&n; *    Copyright (C) 1999-2002 IBM Deutschland Entwicklung GmbH,&n; *                            IBM Corporation&n; *    Author(s): Ingo Adlung (adlung@de.ibm.com)&n; *               Cornelia Huck (cohuck@de.ibm.com) &n; *&t;&t; Arnd Bergmann (arndb@de.ibm.com)&n; *    ChangeLog: 11/04/2002 Arnd Bergmann Split s390io.c into multiple files,&n; *&t;&t;&t;&t;&t;  see s390io.c for complete list of&n; * &t;&t;&t;&t;&t;  changes.&n; *               05/06/2002 Cornelia Huck  some cleanups&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
macro_line|#include &lt;asm/debug.h&gt;
macro_line|#include &quot;airq.h&quot;
macro_line|#include &quot;cio.h&quot;
macro_line|#include &quot;cio_debug.h&quot;
macro_line|#include &quot;ioinfo.h&quot;
macro_line|#include &quot;s390io.h&quot; /* FIXME: try to do without this */
DECL|variable|sync_isc
r_static
id|atomic_t
id|sync_isc
op_assign
id|ATOMIC_INIT
(paren
op_minus
l_int|1
)paren
suffix:semicolon
DECL|variable|sync_isc_cnt
r_static
r_int
id|sync_isc_cnt
suffix:semicolon
multiline_comment|/* synchronous irq processing lock */
DECL|variable|cons_dev
r_int
id|cons_dev
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* identify console device */
multiline_comment|/* FIXME: no signed counters here */
r_static
r_void
DECL|function|s390_displayhex
id|s390_displayhex
(paren
r_void
op_star
id|ptr
comma
id|s32
id|cnt
comma
r_int
id|level
)paren
(brace
id|s32
id|cnt1
comma
id|cnt2
comma
id|maxcnt2
suffix:semicolon
id|u32
op_star
id|currptr
op_assign
(paren
id|__u32
op_star
)paren
id|ptr
suffix:semicolon
r_char
id|buffer
(braket
id|cnt
op_star
l_int|12
)braket
suffix:semicolon
multiline_comment|/* FIXME: possible stack overflow? */
r_for
c_loop
(paren
id|cnt1
op_assign
l_int|0
suffix:semicolon
id|cnt1
OL
id|cnt
suffix:semicolon
id|cnt1
op_add_assign
l_int|16
)paren
(brace
id|sprintf
(paren
id|buffer
comma
l_string|&quot;%08lX &quot;
comma
(paren
r_int
r_int
)paren
id|currptr
)paren
suffix:semicolon
id|maxcnt2
op_assign
id|cnt
op_minus
id|cnt1
suffix:semicolon
r_if
c_cond
(paren
id|maxcnt2
OG
l_int|16
)paren
id|maxcnt2
op_assign
l_int|16
suffix:semicolon
r_for
c_loop
(paren
id|cnt2
op_assign
l_int|0
suffix:semicolon
id|cnt2
OL
id|maxcnt2
suffix:semicolon
id|cnt2
op_add_assign
l_int|4
)paren
id|sprintf
(paren
id|buffer
comma
l_string|&quot;%08X &quot;
comma
op_star
id|currptr
op_increment
)paren
suffix:semicolon
)brace
id|DBG
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_text_event
(paren
id|cio_debug_trace_id
comma
id|level
comma
id|buffer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * used by s390_start_IO&n; */
r_static
r_inline
r_void
DECL|function|s390_build_orb
id|s390_build_orb
c_func
(paren
r_int
id|irq
comma
id|ccw1_t
op_star
id|cpa
comma
r_int
r_int
id|flag
comma
id|__u8
id|lpm
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.intparm
op_assign
(paren
id|__u32
)paren
(paren
r_int
)paren
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|u_intparm
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.fmt
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.sync
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.pfch
op_assign
op_logical_neg
(paren
id|flag
op_amp
id|DOIO_DENY_PREFETCH
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.spnd
op_assign
(paren
id|flag
op_amp
id|DOIO_ALLOW_SUSPEND
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.ssic
op_assign
(paren
(paren
id|flag
op_amp
id|DOIO_ALLOW_SUSPEND
)paren
op_logical_and
(paren
id|flag
op_amp
id|DOIO_SUPPRESS_INTER
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_VALID_LPM
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.lpm
op_assign
id|lpm
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.lpm
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_ARCH_S390X
multiline_comment|/* &n;&t; * for 64 bit we always support 64 bit IDAWs with 4k page size only&n;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.c64
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.i2k
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.cpa
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
(paren
id|cpa
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * used by s390_start_IO to wait on sync. requests&n; */
r_static
r_inline
r_int
DECL|function|s390_do_sync_wait
id|s390_do_sync_wait
c_func
(paren
r_int
id|irq
comma
r_int
id|do_tpi
)paren
(brace
r_int
r_int
id|psw_mask
suffix:semicolon
r_int
id|ccode
suffix:semicolon
r_uint64
id|time_start
suffix:semicolon
r_uint64
id|time_curr
suffix:semicolon
r_int
id|ready
op_assign
l_int|0
suffix:semicolon
r_int
id|io_sub
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|do_retry
op_assign
l_int|1
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * We shouldn&squot;t perform a TPI loop, waiting for an&n;&t; *  interrupt to occur, but should load a WAIT PSW&n;&t; *  instead. Otherwise we may keep the channel subsystem&n;&t; *  busy, not able to present the interrupt. When our&n;&t; *  sync. interrupt arrived we reset the I/O old PSW to&n;&t; *  its original value.&n;&t; */
id|ccode
op_assign
id|iac
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* primary-space */
id|psw_mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_PRIM_SPACE_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* secondary-space */
id|psw_mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_SEC_SPACE_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* access-register */
id|psw_mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_ACC_REG_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* home-space */
id|psw_mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_HOME_SPACE_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
(paren
l_string|&quot;start_IO() : unexpected &quot;
l_string|&quot;address-space-control %d&bslash;n&quot;
comma
id|ccode
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Martin didn&squot;t like modifying the new PSW, now we take&n;&t; *  a fast exit in do_IRQ() instead&n;&t; */
op_star
(paren
id|__u32
op_star
)paren
id|__LC_SYNC_IO_WORD
op_assign
l_int|1
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;STCK %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|time_start
)paren
)paren
suffix:semicolon
id|time_start
op_assign
id|time_start
op_rshift
l_int|32
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|do_tpi
)paren
(brace
id|tpi_info_t
id|tpi_info
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|tpi
(paren
op_amp
id|tpi_info
)paren
op_eq
l_int|1
)paren
(brace
id|io_sub
op_assign
id|tpi_info.irq
suffix:semicolon
r_break
suffix:semicolon
)brace
id|udelay
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* usecs */
id|asm
r_volatile
(paren
l_string|&quot;STCK %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|time_curr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|time_curr
op_rshift
l_int|32
)paren
op_minus
id|time_start
)paren
op_ge
l_int|3
)paren
id|do_retry
op_assign
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|do_retry
)paren
suffix:semicolon
)brace
r_else
(brace
id|__load_psw_mask
(paren
id|psw_mask
)paren
suffix:semicolon
id|io_sub
op_assign
(paren
id|__u32
)paren
op_star
(paren
id|__u16
op_star
)paren
id|__LC_SUBCHANNEL_NR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|do_retry
)paren
id|ready
op_assign
id|s390_process_IRQ
(paren
id|io_sub
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * surrender when retry count&squot;s exceeded ...&n;&t;&t; */
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|io_sub
op_eq
id|irq
)paren
op_logical_and
(paren
id|ready
op_eq
l_int|1
)paren
)paren
op_logical_and
id|do_retry
)paren
suffix:semicolon
op_star
(paren
id|__u32
op_star
)paren
id|__LC_SYNC_IO_WORD
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|do_retry
)paren
id|ret
op_assign
op_minus
id|ETIMEDOUT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Used by halt_IO and clear_IO to wait on sync. requests&n; */
r_static
r_void
DECL|function|s390_do_sync_wait_haltclear
id|s390_do_sync_wait_haltclear
c_func
(paren
r_int
id|irq
comma
r_int
id|halt
)paren
(brace
r_int
id|io_sub
suffix:semicolon
id|__u32
id|io_parm
suffix:semicolon
r_int
r_int
id|psw_mask
suffix:semicolon
r_int
id|ccode
suffix:semicolon
r_int
id|ready
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * For hsch and csch, we don&squot;t do a tpi loop as for ssch,&n;&t; * but load a wait psw if sync processing is requested.&n;&t; *&n;&t; * FIXME: Are there case where we can&squot;t rely on an interrupt&n;&t; *        to occurr? Need to check...&n;&t; */
id|ccode
op_assign
id|iac
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* primary-space */
id|psw_mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_PRIM_SPACE_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* secondary-space */
id|psw_mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_SEC_SPACE_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* access-register */
id|psw_mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_ACC_REG_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* home-space */
id|psw_mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_HOME_SPACE_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* FIXME: isn&squot;t ccode only 2 bits anyway? */
id|panic
(paren
id|halt
ques
c_cond
l_string|&quot;halt&quot;
suffix:colon
l_string|&quot;clear&quot;
l_string|&quot;_IO() : unexpected address-space-control %d&bslash;n&quot;
comma
id|ccode
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Martin didn&squot;t like modifying the new PSW, now we take&n;&t; *  a fast exit in do_IRQ() instead&n;&t; */
op_star
(paren
id|__u32
op_star
)paren
id|__LC_SYNC_IO_WORD
op_assign
l_int|1
suffix:semicolon
r_do
(brace
id|__load_psw_mask
(paren
id|psw_mask
)paren
suffix:semicolon
id|io_parm
op_assign
op_star
(paren
id|__u32
op_star
)paren
id|__LC_IO_INT_PARM
suffix:semicolon
id|io_sub
op_assign
(paren
id|__u32
)paren
op_star
(paren
id|__u16
op_star
)paren
id|__LC_SUBCHANNEL_NR
suffix:semicolon
id|ready
op_assign
id|s390_process_IRQ
(paren
id|io_sub
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|io_sub
op_eq
id|irq
)paren
op_logical_and
(paren
id|ready
op_eq
l_int|1
)paren
)paren
)paren
suffix:semicolon
op_star
(paren
id|__u32
op_star
)paren
id|__LC_SYNC_IO_WORD
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * called from start_IO after deferred cc=3 conditions&n; * to print some debug data&n; */
r_static
r_inline
r_void
DECL|function|s390_cc3_print_data
id|s390_cc3_print_data
c_func
(paren
r_int
id|irq
)paren
(brace
id|stsch
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
id|CIO_DEBUG
c_func
(paren
id|KERN_INFO
comma
l_int|4
comma
l_string|&quot;s390_start_IO(%04X) - irb for &quot;
l_string|&quot;device %04X, after status pending:&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
id|s390_displayhex
(paren
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb
)paren
comma
r_sizeof
(paren
id|irb_t
)paren
comma
l_int|4
)paren
suffix:semicolon
id|CIO_DEBUG
c_func
(paren
id|KERN_INFO
comma
l_int|4
comma
l_string|&quot;s390_start_IO(%04X) - schib for &quot;
l_string|&quot;device %04X, after status pending:&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
id|s390_displayhex
(paren
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
comma
r_sizeof
(paren
id|schib_t
)paren
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_amp
id|DEVSTAT_FLAG_SENSE_AVAIL
)paren
(brace
id|CIO_DEBUG
c_func
(paren
id|KERN_INFO
comma
l_int|4
comma
l_string|&quot;s390_start_IO(%04X) &quot;
l_string|&quot;- sense data for device %04X,&quot;
l_string|&quot; after status pending:&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
id|s390_displayhex
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc
dot
id|dev_id-&gt;ii.sense.data
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc
dot
id|dev_id-&gt;rescnt
comma
l_int|4
)paren
suffix:semicolon
)brace
)brace
r_static
r_inline
r_int
DECL|function|s390_IO_handle_pending
id|s390_IO_handle_pending
c_func
(paren
r_int
id|irq
comma
r_int
id|valid_lpm
comma
r_int
id|halt
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|halt
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_STATUS_PENDING
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_assign
id|DEVSTAT_START_FUNCTION
op_or
id|DEVSTAT_STATUS_PENDING
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * initialize the device driver specific devstat irb area&n;&t; */
id|memset
(paren
op_amp
(paren
(paren
id|devstat_t
op_star
)paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
)paren
op_member_access_from_pointer
id|ii.irb
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|irb_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Let the common interrupt handler process the pending status.&n;&t; *  However, we must avoid calling the user action handler, as&n;&t; *  it won&squot;t be prepared to handle a pending status during&n;&t; *  do_IO() processing inline. This also implies that process_IRQ&n;&t; *  must terminate synchronously - especially if device sensing&n;&t; *  is required.&n;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
op_assign
l_int|1
suffix:semicolon
id|s390_process_IRQ
(paren
id|irq
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4final
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_FINAL_STATUS
suffix:semicolon
multiline_comment|/*&n;&t; * In multipath mode a condition code 3 implies the last path&n;&t; *  has gone, except we have previously restricted the I/O to&n;&t; *  a particular path. A condition code 1 (0 won&squot;t occur)&n;&t; *  results in return code EIO as well as 3 with another path&n;&t; *  than the one used (i.e. path available mask is non-zero).&n;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.scsw.cc
op_eq
l_int|3
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|halt
)paren
(brace
r_if
c_cond
(paren
id|valid_lpm
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_and_assign
op_complement
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.esw.esw1.lpum
)paren
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|halt
)paren
op_logical_or
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_eq
l_int|0
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_NOT_OPER
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|halt
)paren
id|s390_cc3_print_data
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_and_assign
op_complement
id|DEVSTAT_NOT_OPER
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|s390_start_IO_handle_notoper
id|s390_start_IO_handle_notoper
c_func
(paren
r_int
id|irq
comma
r_int
id|valid_lpm
comma
id|__u8
id|lpm
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|valid_lpm
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_and_assign
op_complement
id|lpm
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_eq
l_int|0
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_NOT_OPER
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|memcpy
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat
)paren
comma
r_sizeof
(paren
id|devstat_t
)paren
)paren
suffix:semicolon
id|stsch
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
id|CIO_DEBUG
c_func
(paren
id|KERN_WARNING
comma
l_int|0
comma
l_string|&quot;s390_start_IO(%04X) - schib for &quot;
l_string|&quot;device %04X, after &squot;not oper&squot; status:&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
id|s390_displayhex
(paren
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
comma
r_sizeof
(paren
id|schib_t
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_int
DECL|function|s390_start_IO
id|s390_start_IO
(paren
r_int
id|irq
comma
multiline_comment|/* IRQ */
id|ccw1_t
op_star
id|cpa
comma
multiline_comment|/* logical channel prog addr */
r_int
r_int
id|user_intparm
comma
multiline_comment|/* interruption parameter */
id|__u8
id|lpm
comma
multiline_comment|/* logical path mask */
r_int
r_int
id|flag
)paren
(brace
multiline_comment|/* flags */
r_int
id|ccode
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|SANITY_CHECK
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The flag usage is mutal exclusive ...&n;&t; */
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|DOIO_EARLY_NOTIFICATION
)paren
op_logical_and
(paren
id|flag
op_amp
id|DOIO_REPORT_ALL
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;stIO%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
id|s390_build_orb
c_func
(paren
id|irq
comma
id|cpa
comma
id|flag
comma
id|lpm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If sync processing was requested we lock the sync ISC, modify the&n;&t; *  device to present interrupts for this ISC only and switch the&n;&t; *  CPU to handle this ISC exclusively.&n;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
(brace
id|ret
op_assign
id|enable_cpu_sync_isc
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_DONT_CALL_INTHDLR
)paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repnone
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Issue &quot;Start subchannel&quot; and process condition code&n;&t; */
id|ccode
op_assign
id|ssch
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb
)paren
)paren
suffix:semicolon
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;ccode:%d&quot;
comma
id|ccode
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4sense
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * init the device driver specific devstat irb area&n;&t;&t;&t; *&n;&t;&t;&t; * Note : don&#xfffd;t clear saved irb info in case of sense !&n;&t;&t;&t; */
id|memset
(paren
op_amp
(paren
(paren
id|devstat_t
op_star
)paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
)paren
op_member_access_from_pointer
id|ii.irb
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|irb_t
)paren
)paren
suffix:semicolon
)brace
id|memset
(paren
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|irb_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * initialize device status information&n;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|u_intparm
op_assign
id|user_intparm
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.cstat
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.dstat
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.lpum
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_assign
id|DEVSTAT_START_FUNCTION
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.scnt
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check for either early (FAST) notification requests&n;&t;&t; *  or if we are to return all interrupt info.&n;&t;&t; * Default is to call IRQ handler at secondary status only&n;&t;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_EARLY_NOTIFICATION
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_REPORT_ALL
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
op_assign
l_int|1
suffix:semicolon
)brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ulpm
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.lpm
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If synchronous I/O processing is requested, we have&n;&t;&t; *  to wait for the corresponding interrupt to occur by&n;&t;&t; *  polling the interrupt condition. However, as multiple&n;&t;&t; *  interrupts may be outstanding, we must not just wait&n;&t;&t; *  for the first interrupt, but must poll until ours&n;&t;&t; *  pops up.&n;&t;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
id|ret
op_assign
id|s390_do_sync_wait
c_func
(paren
id|irq
comma
id|flag
op_amp
id|DOIO_TIMEOUT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* status pending */
id|ret
op_assign
id|s390_IO_handle_pending
c_func
(paren
id|irq
comma
id|flag
op_amp
id|DOIO_VALID_LPM
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* busy */
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* device/path not operational */
id|ret
op_assign
id|s390_start_IO_handle_notoper
c_func
(paren
id|irq
comma
id|flag
op_amp
id|DOIO_VALID_LPM
comma
id|lpm
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
id|disable_cpu_sync_isc
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_DONT_CALL_INTHDLR
)paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repnone
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
r_int
DECL|function|do_IO
id|do_IO
(paren
r_int
id|irq
comma
multiline_comment|/* IRQ */
id|ccw1_t
op_star
id|cpa
comma
multiline_comment|/* channel program address */
r_int
r_int
id|user_intparm
comma
multiline_comment|/* interruption parameter */
id|__u8
id|lpm
comma
multiline_comment|/* logical path mask */
r_int
r_int
id|flag
)paren
(brace
multiline_comment|/* flags : see above */
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|SANITY_CHECK
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/* handler registered ? or free_irq() in process already ? */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
op_logical_or
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.unready
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;doIO%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Note: We ignore the device operational status - if not operational,&n;&t; *        the SSCH will lead to an -ENODEV condition ...&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
)paren
(brace
multiline_comment|/* last I/O completed ? */
id|ret
op_assign
id|s390_start_IO
(paren
id|irq
comma
id|cpa
comma
id|user_intparm
comma
id|lpm
comma
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_eq
op_minus
id|ETIMEDOUT
)paren
op_logical_and
(paren
id|flag
op_amp
id|DOIO_CANCEL_ON_TIMEOUT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We should better cancel the io request here&n;&t;&t;&t; * or we might not be able to do io on this sch&n;&t;&t;&t; * again&n;&t;&t;&t; */
id|cancel_IO
(paren
id|irq
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
)paren
(brace
multiline_comment|/*&n;&t;&t; * If primary status was received and ending status is missing,&n;&t;&t; *  the device driver won&squot;t be notified on the ending status&n;&t;&t; *  if early (fast) interrupt notification was requested.&n;&t;&t; *  Therefore we have to queue the next incoming request. If&n;&t;&t; *  halt_IO() is issued while there is a request queued, a HSCH&n;&t;&t; *  needs to be issued and the queued request must be deleted&n;&t;&t; *  but its intparm must be returned (see halt_IO() processing)&n;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4final
op_logical_and
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio_q
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qflag
op_assign
id|flag
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qcpa
op_assign
id|cpa
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qintparm
op_assign
id|user_intparm
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qlpm
op_assign
id|lpm
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * resume suspended I/O operation&n; */
r_int
DECL|function|resume_IO
id|resume_IO
(paren
r_int
id|irq
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|SANITY_CHECK
(paren
id|irq
)paren
suffix:semicolon
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;resIO%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We allow for &squot;resume&squot; requests only for active I/O operations&n;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
)paren
(brace
r_int
id|ccode
suffix:semicolon
id|ccode
op_assign
id|rsch
(paren
id|irq
)paren
suffix:semicolon
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;ccode:%d&quot;
comma
id|ccode
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|s390_process_IRQ
(paren
id|irq
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * useless to wait for request completion&n;&t;&t;&t; *  as device is no longer operational !&n;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
)brace
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Note: The &quot;intparm&quot; parameter is not used by the halt_IO() function&n; *       itself, as no ORB is built for the HSCH instruction. However,&n; *       it allows the device interrupt handler to associate the upcoming&n; *       interrupt with the halt_IO() request.&n; */
r_int
DECL|function|halt_IO
id|halt_IO
(paren
r_int
id|irq
comma
r_int
r_int
id|user_intparm
comma
r_int
r_int
id|flag
)paren
(brace
multiline_comment|/* possible DOIO_WAIT_FOR_INTERRUPT */
r_int
id|ret
suffix:semicolon
r_int
id|ccode
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|SANITY_CHECK
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we only allow for halt_IO if the device has an I/O handler associated&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/*&n;&t; * we ignore the halt_io() request if ending_status was received but&n;&t; *  a SENSE operation is waiting for completion.&n;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4sense
)paren
r_return
l_int|0
suffix:semicolon
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;haltIO%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|2
comma
id|dbf_txt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If sync processing was requested we lock the sync ISC,&n;&t; *  modify the device to present interrupts for this ISC only&n;&t; *  and switch the CPU to handle this ISC exclusively.&n;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
(brace
id|ret
op_assign
id|enable_cpu_sync_isc
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Issue &quot;Halt subchannel&quot; and process condition code&n;&t; */
id|ccode
op_assign
id|hsch
(paren
id|irq
)paren
suffix:semicolon
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;ccode:%d&quot;
comma
id|ccode
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|2
comma
id|dbf_txt
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.haltio
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|u_intparm
op_assign
id|user_intparm
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.cstat
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.dstat
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.lpum
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_assign
id|DEVSTAT_HALT_FUNCTION
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.scnt
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_HALT_FUNCTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If synchronous I/O processing is requested, we have&n;&t;&t; *  to wait for the corresponding interrupt to occur by&n;&t;&t; *  polling the interrupt condition. However, as multiple&n;&t;&t; *  interrupts may be outstanding, we must not just wait&n;&t;&t; *  for the first interrupt, but must poll until ours&n;&t;&t; *  pops up.&n;&t;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
id|s390_do_sync_wait_haltclear
c_func
(paren
id|irq
comma
l_int|1
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* status pending */
id|ret
op_assign
id|s390_IO_handle_pending
c_func
(paren
id|irq
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* busy */
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* device not operational */
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
id|disable_cpu_sync_isc
(paren
id|irq
)paren
suffix:semicolon
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Note: The &quot;intparm&quot; parameter is not used by the clear_IO() function&n; *       itself, as no ORB is built for the CSCH instruction. However,&n; *       it allows the device interrupt handler to associate the upcoming&n; *       interrupt with the clear_IO() request.&n; */
r_int
DECL|function|clear_IO
id|clear_IO
(paren
r_int
id|irq
comma
r_int
r_int
id|user_intparm
comma
r_int
r_int
id|flag
)paren
(brace
multiline_comment|/* possible DOIO_WAIT_FOR_INTERRUPT */
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|ccode
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|SANITY_CHECK
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we only allow for clear_IO if the device has an I/O handler associated&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/*&n;&t; * we ignore the clear_io() request if ending_status was received but&n;&t; *  a SENSE operation is waiting for completion.&n;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4sense
)paren
r_return
l_int|0
suffix:semicolon
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;clearIO%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|2
comma
id|dbf_txt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If sync processing was requested we lock the sync ISC,&n;&t; *  modify the device to present interrupts for this ISC only&n;&t; *  and switch the CPU to handle this ISC exclusively.&n;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
(brace
id|ret
op_assign
id|enable_cpu_sync_isc
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Issue &quot;Clear subchannel&quot; and process condition code&n;&t; */
id|ccode
op_assign
id|csch
(paren
id|irq
)paren
suffix:semicolon
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;ccode:%d&quot;
comma
id|ccode
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|2
comma
id|dbf_txt
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.haltio
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|u_intparm
op_assign
id|user_intparm
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.cstat
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.dstat
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.lpum
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_assign
id|DEVSTAT_CLEAR_FUNCTION
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.scnt
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_CLEAR_FUNCTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If synchronous I/O processing is requested, we have&n;&t;&t; *  to wait for the corresponding interrupt to occur by&n;&t;&t; *  polling the interrupt condition. However, as multiple&n;&t;&t; *  interrupts may be outstanding, we must not just wait&n;&t;&t; *  for the first interrupt, but must poll until ours&n;&t;&t; *  pops up.&n;&t;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
id|s390_do_sync_wait_haltclear
c_func
(paren
id|irq
comma
l_int|0
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* no status pending for csh */
id|BUG
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* no busy for csh */
id|BUG
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* device not operational */
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
id|disable_cpu_sync_isc
(paren
id|irq
)paren
suffix:semicolon
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function: cancel_IO&n; * Issues a &quot;Cancel Subchannel&quot; on the specified subchannel&n; * Note: We don&squot;t need any fancy intparms and flags here&n; *       since xsch is executed synchronously.&n; * Only for common I/O internal use as for now.&n; */
r_int
DECL|function|cancel_IO
id|cancel_IO
(paren
r_int
id|irq
)paren
(brace
r_int
id|ccode
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|SANITY_CHECK
(paren
id|irq
)paren
suffix:semicolon
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;cancelIO%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|2
comma
id|dbf_txt
)paren
suffix:semicolon
id|ccode
op_assign
id|xsch
(paren
id|irq
)paren
suffix:semicolon
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;ccode:%d&quot;
comma
id|ccode
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|2
comma
id|dbf_txt
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* success */
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* status pending */
multiline_comment|/* process the pending irq... */
id|s390_process_IRQ
(paren
id|irq
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* not applicable */
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* not oper */
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * do_IRQ() handles all normal I/O device IRQ&squot;s (the special&n; *          SMP cross-CPU interrupts have their own specific&n; *          handlers).&n; *&n; */
id|asmlinkage
r_void
DECL|function|do_IRQ
id|do_IRQ
(paren
r_struct
id|pt_regs
id|regs
)paren
(brace
multiline_comment|/*&n;&t; * Get interrupt info from lowcore&n;&t; */
r_volatile
id|tpi_info_t
op_star
id|tpi_info
op_assign
(paren
id|tpi_info_t
op_star
)paren
(paren
id|__LC_SUBCHANNEL_ID
)paren
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * take fast exit if CPU is in sync. I/O state&n;&t; *&n;&t; * Note: we have to turn off the WAIT bit and re-disable&n;&t; *       interrupts prior to return as this was the initial&n;&t; *       entry condition to synchronous I/O.&n;&t; */
r_if
c_cond
(paren
op_star
(paren
id|__u32
op_star
)paren
id|__LC_SYNC_IO_WORD
)paren
(brace
id|regs.psw.mask
op_and_assign
op_complement
(paren
id|_PSW_WAIT_MASK_BIT
op_or
id|_PSW_IO_MASK_BIT
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* endif */
macro_line|#ifdef CONFIG_FAST_IRQ
r_do
(brace
macro_line|#endif&t;&t;&t;&t;/* CONFIG_FAST_IRQ */
multiline_comment|/*&n;&t;&t; * Non I/O-subchannel thin interrupts are processed differently&n;&t;&t; */
r_if
c_cond
(paren
id|tpi_info-&gt;adapter_IO
op_eq
l_int|1
op_logical_and
id|tpi_info-&gt;int_type
op_eq
id|IO_INTERRUPT_TYPE
)paren
(brace
id|irq_enter
(paren
id|cpu
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|do_adapter_IO
(paren
id|tpi_info-&gt;intparm
)paren
suffix:semicolon
id|irq_exit
(paren
id|cpu
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|irq
op_assign
id|tpi_info-&gt;irq
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * fix me !!!&n;&t;&t;&t; *&n;&t;&t;&t; * instead of boxing the device, we need to schedule device&n;&t;&t;&t; * recognition, the interrupt stays pending. We need to&n;&t;&t;&t; * dynamically allocate an ioinfo structure, etc..&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
r_return
suffix:semicolon
multiline_comment|/* this keeps the device boxed ... */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|st
)paren
(brace
multiline_comment|/* How can that be? */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Received interrupt on &quot;
l_string|&quot;non-IO subchannel %x!&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|irq_enter
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
id|s390irq_spin_lock
(paren
id|irq
)paren
suffix:semicolon
id|s390_process_IRQ
(paren
id|irq
)paren
suffix:semicolon
id|s390irq_spin_unlock
(paren
id|irq
)paren
suffix:semicolon
id|irq_exit
(paren
id|cpu
comma
id|irq
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_FAST_IRQ
multiline_comment|/*&n;&t;&t; * Are more interrupts pending?&n;&t;&t; * If so, the tpi instruction will update the lowcore &n;&t;&t; * to hold the info for the next interrupt.&n;&t;&t; */
)brace
r_while
c_loop
(paren
id|tpi
(paren
l_int|NULL
)paren
op_ne
l_int|0
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* CONFIG_FAST_IRQ */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * used by s390_process_irq to start queued channel programs&n; */
r_static
r_inline
r_void
DECL|function|s390_start_queued_io
id|s390_start_queued_io
c_func
(paren
r_int
id|irq
comma
id|devstat_t
op_star
id|udp
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|do_cancel
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qflag
op_amp
id|DOIO_CANCEL_ON_TIMEOUT
suffix:semicolon
id|ret
op_assign
id|s390_start_IO
(paren
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qcpa
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qintparm
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qlpm
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qflag
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio_q
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If s390_start_IO() failed call the device&squot;s interrupt&n;&t; *  handler, the IRQ related devstat area was setup by&n;&t; *  s390_start_IO() accordingly already (status pending&n;&t; *  condition).&n;&t; */
r_if
c_cond
(paren
id|ret
)paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.handler
(paren
id|irq
comma
id|udp
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * better cancel the io when we time out...&n;&t; */
r_if
c_cond
(paren
(paren
id|ret
op_eq
op_minus
id|ETIMEDOUT
)paren
op_logical_and
id|do_cancel
)paren
id|cancel_IO
(paren
id|irq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * used by s390_process_irq to issue a sense ccw&n; */
r_static
r_inline
r_void
DECL|function|s390_issue_sense
id|s390_issue_sense
c_func
(paren
r_int
r_int
id|irq
comma
id|devstat_t
op_star
id|dp
)paren
(brace
r_int
id|ret_io
suffix:semicolon
id|ccw1_t
op_star
id|s_ccw
op_assign
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseccw
suffix:semicolon
r_int
r_int
id|s_flag
op_assign
l_int|0
suffix:semicolon
id|s_ccw-&gt;cmd_code
op_assign
id|CCW_CMD_BASIC_SENSE
suffix:semicolon
id|s_ccw-&gt;cda
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|sense_data
)paren
suffix:semicolon
id|s_ccw-&gt;count
op_assign
id|SENSE_MAX_COUNT
suffix:semicolon
id|s_ccw-&gt;flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
multiline_comment|/*&n;&t; * If free_irq() or a sync do_IO/s390_start_IO() is in&n;&t; *  process we have to sense synchronously&n;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.unready
op_logical_or
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.syncio
)paren
id|s_flag
op_assign
id|DOIO_WAIT_FOR_INTERRUPT
suffix:semicolon
multiline_comment|/*&n;&t; * Reset status info&n;&t; *&n;&t; * It does not matter whether this is a sync. or async.&n;&t; *  SENSE request, but we have to assure we don&squot;t call&n;&t; *  the irq handler now, but keep the irq in busy state.&n;&t; *  In sync. mode s390_process_IRQ() is called recursively,&n;&t; *  while in async. mode we re-enter do_IRQ() with the&n;&t; *  next interrupt.&n;&t; *&n;&t; * Note : this may be a delayed sense request !&n;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4final
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.delsense
op_assign
l_int|0
suffix:semicolon
id|dp-&gt;cstat
op_assign
l_int|0
suffix:semicolon
id|dp-&gt;dstat
op_assign
l_int|0
suffix:semicolon
id|dp-&gt;rescnt
op_assign
id|SENSE_MAX_COUNT
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4sense
op_assign
l_int|1
suffix:semicolon
id|ret_io
op_assign
id|s390_start_IO
(paren
id|irq
comma
id|s_ccw
comma
l_int|0xE2C5D5E2
comma
multiline_comment|/* = SENSe */
l_int|0
comma
multiline_comment|/* n/a */
id|s_flag
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|s390_reset_flags_after_ending_status
id|s390_reset_flags_after_ending_status
c_func
(paren
r_int
id|irq
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.haltio
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4final
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_FINAL_STATUS
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id-&gt;flag
op_or_assign
id|DEVSTAT_FINAL_STATUS
suffix:semicolon
)brace
multiline_comment|/*&n; * for cc=0 and cc=1 after tsch&n; */
r_static
r_inline
r_int
DECL|function|s390_process_IRQ_normal
id|s390_process_IRQ_normal
c_func
(paren
r_int
r_int
id|irq
comma
r_int
id|ending_status
)paren
(brace
r_int
r_int
id|fctl
suffix:semicolon
multiline_comment|/* function control */
r_int
r_int
id|stctl
suffix:semicolon
multiline_comment|/* status   control */
r_int
r_int
id|actl
suffix:semicolon
multiline_comment|/* activity control */
id|scsw_t
op_star
id|scsw
suffix:semicolon
r_int
id|allow4handler
op_assign
l_int|1
suffix:semicolon
id|devstat_t
op_star
id|dp
suffix:semicolon
id|devstat_t
op_star
id|udp
suffix:semicolon
id|dp
op_assign
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat
suffix:semicolon
id|udp
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
suffix:semicolon
id|scsw
op_assign
op_amp
id|dp-&gt;ii.irb.scsw
suffix:semicolon
id|fctl
op_assign
id|scsw-&gt;fctl
suffix:semicolon
id|stctl
op_assign
id|scsw-&gt;stctl
suffix:semicolon
id|actl
op_assign
id|scsw-&gt;actl
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|stctl
op_or_assign
id|stctl
suffix:semicolon
id|ending_status
op_assign
(paren
id|stctl
op_amp
id|SCSW_STCTL_SEC_STATUS
)paren
op_logical_or
(paren
id|stctl
op_eq
(paren
id|SCSW_STCTL_ALERT_STATUS
op_or
id|SCSW_STCTL_STATUS_PEND
)paren
)paren
op_logical_or
(paren
id|stctl
op_eq
id|SCSW_STCTL_STATUS_PEND
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check for unsolicited interrupts - for debug purposes only&n;&t; *&n;&t; * We only consider an interrupt as unsolicited, if the device was not&n;&t; *  actively in use (busy) and an interrupt other than an ALERT status&n;&t; *  was received.&n;&t; *&n;&t; * Note: We must not issue a message to the console, if the&n;&t; *       unsolicited interrupt applies to the console device&n;&t; *       itself !&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|stctl
op_amp
id|SCSW_STCTL_ALERT_STATUS
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_eq
l_int|0
)paren
)paren
(brace
id|CIO_DEBUG_NOCONS
c_func
(paren
id|irq
comma
id|KERN_INFO
comma
id|DBG
comma
l_int|2
comma
l_string|&quot;Unsolicited interrupt &quot;
l_string|&quot;received for device %04X &quot;
l_string|&quot;on subchannel %04X&bslash;n&quot;
l_string|&quot; ... device status : %02X &quot;
l_string|&quot;subchannel status : %02X&bslash;n&quot;
comma
id|dp-&gt;devno
comma
id|irq
comma
id|dp-&gt;dstat
comma
id|dp-&gt;cstat
)paren
suffix:semicolon
id|CIO_DEBUG_NOCONS
c_func
(paren
id|irq
comma
id|KERN_INFO
comma
id|DBG
comma
l_int|2
comma
l_string|&quot;s390_process_IRQ(%04X) - irb for &quot;
l_string|&quot;device %04X, ending_status %d:&bslash;n&quot;
comma
id|irq
comma
id|dp-&gt;devno
comma
id|ending_status
)paren
suffix:semicolon
id|s390_displayhex
(paren
op_amp
(paren
id|dp-&gt;ii.irb
)paren
comma
r_sizeof
(paren
id|irb_t
)paren
comma
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * take fast exit if no handler is available&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
r_return
(paren
id|ending_status
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check whether we must issue a SENSE CCW ourselves if there is no&n;&t; *  concurrent sense facility installed for the subchannel.&n;&t; *&n;&t; * Note: We should check for ioinfo[irq]-&gt;ui.flags.consns but VM&n;&t; *       violates the ESA/390 architecture and doesn&squot;t present an&n;&t; *       operand exception for virtual devices without concurrent&n;&t; *       sense facility available/supported when enabling the&n;&t; *       concurrent sense facility.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|scsw-&gt;dstat
op_amp
id|DEV_STAT_UNIT_CHECK
)paren
op_logical_and
(paren
op_logical_neg
id|dp-&gt;flag
op_amp
id|DEVSTAT_FLAG_SENSE_AVAIL
)paren
)paren
op_logical_or
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.delsense
op_logical_and
id|ending_status
)paren
)paren
(brace
id|allow4handler
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ending_status
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We copy the current status information into the device driver&n;&t;&t;&t; *  status area. Then we can use the local devstat area for device&n;&t;&t;&t; *  sensing. When finally calling the IRQ handler we must not overlay&n;&t;&t;&t; *  the original device status but copy the sense data only.&n;&t;&t;&t; */
id|memcpy
(paren
id|udp
comma
id|dp
comma
r_sizeof
(paren
id|devstat_t
)paren
)paren
suffix:semicolon
id|s390_issue_sense
c_func
(paren
id|irq
comma
id|dp
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * we received an Unit Check but we have no final&n;&t;&t;&t; *  status yet, therefore we must delay the SENSE&n;&t;&t;&t; *  processing. However, we must not report this&n;&t;&t;&t; *  intermediate status to the device interrupt&n;&t;&t;&t; *  handler.&n;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.delsense
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * we allow for the device action handler if .&n;&t; *  - we received ending status&n;&t; *  - the action handler requested to see all interrupts&n;&t; *  - we received an intermediate status&n;&t; *  - fast notification was requested (primary status)&n;&t; *  - unsolicited interrupts&n;&t; *&n;&t; */
r_if
c_cond
(paren
id|allow4handler
)paren
(brace
id|allow4handler
op_assign
id|ending_status
op_logical_or
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
)paren
op_logical_or
(paren
id|stctl
op_amp
id|SCSW_STCTL_INTER_STATUS
)paren
op_logical_or
(paren
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
)paren
op_logical_and
(paren
id|stctl
op_amp
id|SCSW_STCTL_PRIM_STATUS
)paren
)paren
op_logical_or
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_eq
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We used to copy the device status information right before&n;&t; *  calling the device action handler. However, in status&n;&t; *  pending situations during do_IO() or halt_IO(), as well as&n;&t; *  enable_subchannel/disable_subchannel processing we must&n;&t; *  synchronously return the status information and must not&n;&t; *  call the device action handler.&n;&t; *&n;&t; */
r_if
c_cond
(paren
id|allow4handler
)paren
(brace
multiline_comment|/*&n;&t;&t; * if we were waiting for sense data we copy the sense&n;&t;&t; *  bytes only as the original status information was&n;&t;&t; *  saved prior to sense already.&n;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4sense
)paren
(brace
r_int
id|sense_count
op_assign
id|SENSE_MAX_COUNT
op_minus
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.rescnt
suffix:semicolon
id|CIO_DEBUG_NOCONS
c_func
(paren
id|irq
comma
id|KERN_DEBUG
comma
id|DBG
comma
l_int|4
comma
l_string|&quot;s390_process_IRQ( %04X ): &quot;
l_string|&quot;BASIC SENSE bytes avail %d&bslash;n&quot;
comma
id|irq
comma
id|sense_count
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4sense
op_assign
l_int|0
suffix:semicolon
id|udp-&gt;flag
op_or_assign
id|DEVSTAT_FLAG_SENSE_AVAIL
suffix:semicolon
id|udp-&gt;scnt
op_assign
id|sense_count
suffix:semicolon
r_if
c_cond
(paren
id|sense_count
op_ge
l_int|0
)paren
(brace
id|memcpy
(paren
id|udp-&gt;ii.sense.data
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|sense_data
comma
id|sense_count
)paren
suffix:semicolon
)brace
r_else
(brace
id|panic
(paren
l_string|&quot;s390_process_IRQ(%04x) encountered &quot;
l_string|&quot;negative sense count&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|memcpy
(paren
id|udp
comma
id|dp
comma
r_sizeof
(paren
id|devstat_t
)paren
op_minus
(paren
id|dp-&gt;flag
op_amp
id|DEVSTAT_FLAG_SENSE_AVAIL
ques
c_cond
l_int|0
suffix:colon
id|SENSE_MAX_COUNT
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * for status pending situations other than deferred interrupt&n;&t; *  conditions detected by s390_process_IRQ() itself we must not&n;&t; *  call the handler. This will synchronously be reported back&n;&t; *  to the caller instead, e.g. when detected during do_IO().&n;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_logical_or
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.unready
op_logical_or
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repnone
)paren
(brace
r_if
c_cond
(paren
id|ending_status
)paren
id|s390_reset_flags_after_ending_status
c_func
(paren
id|irq
)paren
suffix:semicolon
id|allow4handler
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Call device action handler if applicable&n;&t; */
r_if
c_cond
(paren
id|allow4handler
)paren
(brace
multiline_comment|/*&n;&t;&t; *  We only reset the busy condition when we are sure that no further&n;&t;&t; *   interrupt is pending for the current I/O request (ending_status).&n;&t;&t; */
r_if
c_cond
(paren
id|ending_status
op_logical_or
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* dev IS oper */
id|s390_reset_flags_after_ending_status
c_func
(paren
id|irq
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.handler
(paren
id|irq
comma
id|udp
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * reset intparm after final status or we will badly present unsolicited&n;&t;&t;&t; *  interrupts with a intparm value possibly no longer valid.&n;&t;&t;&t; */
id|dp-&gt;intparm
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Was there anything queued ? Start the pending channel program&n;&t;&t;&t; *  if there is one.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio_q
)paren
id|s390_start_queued_io
c_func
(paren
id|irq
comma
id|udp
)paren
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4final
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Eventually reset subchannel PCI status and&n;&t;&t;&t; *  set the PCI or SUSPENDED flag in the user&n;&t;&t;&t; *  device status block if appropriate.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|dp-&gt;cstat
op_amp
id|SCHN_STAT_PCI
)paren
(brace
id|udp-&gt;flag
op_or_assign
id|DEVSTAT_PCI
suffix:semicolon
id|dp-&gt;cstat
op_and_assign
op_complement
id|SCHN_STAT_PCI
suffix:semicolon
)brace
r_if
c_cond
(paren
id|actl
op_amp
id|SCSW_ACTL_SUSPENDED
)paren
id|udp-&gt;flag
op_or_assign
id|DEVSTAT_SUSPENDED
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.handler
(paren
id|irq
comma
id|udp
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
r_return
id|ending_status
suffix:semicolon
)brace
multiline_comment|/*&n; * for cc=3 after tsch&n; */
r_static
r_inline
r_int
DECL|function|s390_process_IRQ_notoper
id|s390_process_IRQ_notoper
c_func
(paren
r_int
r_int
id|irq
comma
r_int
id|ending_status
)paren
(brace
id|devstat_t
op_star
id|dp
suffix:semicolon
id|devstat_t
op_star
id|udp
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.haltio
op_assign
l_int|0
suffix:semicolon
id|dp
op_assign
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat
suffix:semicolon
id|udp
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
suffix:semicolon
id|dp-&gt;cstat
op_assign
l_int|0
suffix:semicolon
id|dp-&gt;dstat
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ulpm
op_ne
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
)paren
multiline_comment|/*&n;&t;&t; * either it was the only path or it was restricted ...&n;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_and_assign
op_complement
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.esw.esw1.lpum
)paren
suffix:semicolon
r_else
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_eq
l_int|0
)paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_NOT_OPER
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_FINAL_STATUS
suffix:semicolon
multiline_comment|/*&n;&t; * When we find a device &quot;not oper&quot; we save the status&n;&t; *  information into the device status area and call the&n;&t; *  device specific interrupt handler.&n;&t; *&n;&t; * Note: currently we don&squot;t have any way to reenable&n;&t; *       the device unless an unsolicited interrupt&n;&t; *       is presented. We don&squot;t check for spurious&n;&t; *       interrupts on &quot;not oper&quot; conditions.&n;&t; */
r_if
c_cond
(paren
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4final
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * If a new request was queued already, we have&n;&t;&t; *  to simulate the &quot;not oper&quot; status for the&n;&t;&t; *  queued request by switching the &quot;intparm&quot; value&n;&t;&t; *  and notify the interrupt handler.&n;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio_q
)paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.intparm
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qintparm
suffix:semicolon
)brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4final
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * take fast exit if no handler is available&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
r_return
(paren
id|ending_status
)paren
suffix:semicolon
id|memcpy
(paren
id|udp
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat
)paren
comma
r_sizeof
(paren
id|devstat_t
)paren
op_minus
(paren
id|dp-&gt;flag
op_amp
id|DEVSTAT_FLAG_SENSE_AVAIL
ques
c_cond
l_int|0
suffix:colon
id|SENSE_MAX_COUNT
)paren
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.intparm
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
)paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.handler
(paren
id|irq
comma
id|udp
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* FIXME:  help!!!! */
multiline_comment|/*&n; * s390_process_IRQ() handles status pending situations and interrupts&n; *&n; * Called by : do_IRQ()             - for &quot;real&quot; interrupts&n; *             s390_start_IO, halt_IO()&n; *                                  - status pending cond. after SSCH, or HSCH&n; *             cancel_IO(), clear_IO(), resume_IO()&n; *             s390_set_isc5()&n; *             s390_validate_subchannel(),&n; *             {en,dis}able_subchannel() - status pending conditions (after MSCH)&n; *&n; * Returns: 0 - no ending status received, no further action taken&n; *          1 - interrupt handler was called with ending status&n; */
r_int
DECL|function|s390_process_IRQ
id|s390_process_IRQ
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|ccode
suffix:semicolon
multiline_comment|/* cond code from tsch() operation */
r_int
id|irb_cc
suffix:semicolon
multiline_comment|/* cond code from irb */
r_int
id|issense
op_assign
l_int|0
suffix:semicolon
r_int
id|ending_status
op_assign
l_int|0
suffix:semicolon
id|devstat_t
op_star
id|dp
suffix:semicolon
id|devstat_t
op_star
id|udp
suffix:semicolon
id|scsw_t
op_star
id|scsw
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cio_count_irqs
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
(paren
)paren
suffix:semicolon
id|s390_irq_count
(braket
id|cpu
)braket
op_increment
suffix:semicolon
)brace
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;procIRQ%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|3
comma
id|dbf_txt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
(brace
r_static
id|irb_t
id|p_init_irb
suffix:semicolon
multiline_comment|/* FIXME: could this be on the stack? */
multiline_comment|/* we can&squot;t properly process the interrupt ... */
id|CIO_DEBUG
c_func
(paren
id|KERN_CRIT
comma
l_int|0
comma
l_string|&quot;s390_process_IRQ(%04X) - got interrupt &quot;
l_string|&quot;for non-initialized subchannel!&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
id|tsch
(paren
id|irq
comma
op_amp
id|p_init_irb
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|st
)paren
(brace
multiline_comment|/* can&squot;t be */
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|dp
op_assign
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat
suffix:semicolon
id|udp
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
suffix:semicolon
multiline_comment|/*&n;&t; * It might be possible that a device was not-oper. at the time&n;&t; *  of free_irq() processing. This means the handler is no longer&n;&t; *  available when the device possibly becomes ready again. In&n;&t; *  this case we perform delayed disable_subchannel() processing.&n;&t; */
r_if
c_cond
(paren
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
op_logical_and
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.d_disable
)paren
)paren
id|CIO_DEBUG
(paren
id|KERN_CRIT
comma
l_int|0
comma
l_string|&quot;s390_process_IRQ(%04X) &quot;
l_string|&quot;- no interrupt handler registered &quot;
l_string|&quot;for device %04X !&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * retrieve the i/o interrupt information (irb),&n;&t; *  update the device specific status information&n;&t; *  and possibly call the interrupt handler.&n;&t; *&n;&t; * Note 1: At this time we don&squot;t process the resulting&n;&t; *         condition code (ccode) from tsch(), although&n;&t; *         we probably should.&n;&t; *&n;&t; * Note 2: Here we will have to check for channel&n;&t; *         check conditions and call a channel check&n;&t; *         handler.&n;&t; *&n;&t; * Note 3: If a start function was issued, the interruption&n;&t; *         parameter relates to it. If a halt function was&n;&t; *         issued for an idle device, the intparm must not&n;&t; *         be taken from lowcore, but from the devstat area.&n;&t; */
id|ccode
op_assign
id|tsch
(paren
id|irq
comma
op_amp
(paren
id|dp-&gt;ii.irb
)paren
)paren
suffix:semicolon
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;ccode:%d&quot;
comma
id|ccode
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|3
comma
id|dbf_txt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccode
op_eq
l_int|3
)paren
id|CIO_DEBUG
(paren
id|KERN_WARNING
comma
l_int|0
comma
l_string|&quot;s390_process_IRQ(%04X) - subchannel &quot;
l_string|&quot;is not operational!&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We must only accumulate the status if the device is busy already&n;&t; */
id|scsw
op_assign
op_amp
id|dp-&gt;ii.irb.scsw
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
)paren
(brace
id|dp-&gt;dstat
op_or_assign
id|scsw-&gt;dstat
suffix:semicolon
id|dp-&gt;cstat
op_or_assign
id|scsw-&gt;cstat
suffix:semicolon
id|dp-&gt;intparm
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|u_intparm
suffix:semicolon
)brace
r_else
(brace
id|dp-&gt;dstat
op_assign
id|scsw-&gt;dstat
suffix:semicolon
id|dp-&gt;cstat
op_assign
id|scsw-&gt;cstat
suffix:semicolon
id|dp-&gt;flag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* reset status flags */
id|dp-&gt;intparm
op_assign
l_int|0
suffix:semicolon
)brace
id|dp-&gt;lpum
op_assign
id|dp-&gt;ii.irb.esw.esw1.lpum
suffix:semicolon
multiline_comment|/*&n;&t; * reset device-busy bit if no longer set in irb&n;&t; */
r_if
c_cond
(paren
(paren
id|dp-&gt;dstat
op_amp
id|DEV_STAT_BUSY
)paren
op_logical_and
(paren
(paren
id|scsw-&gt;dstat
op_amp
id|DEV_STAT_BUSY
)paren
op_eq
l_int|0
)paren
)paren
id|dp-&gt;dstat
op_and_assign
op_complement
id|DEV_STAT_BUSY
suffix:semicolon
multiline_comment|/*&n;&t; * Save residual count and CCW information in case primary and&n;&t; *  secondary status are presented with different interrupts.&n;&t; */
r_if
c_cond
(paren
id|scsw-&gt;stctl
op_amp
(paren
id|SCSW_STCTL_PRIM_STATUS
op_or
id|SCSW_STCTL_INTER_STATUS
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * If the subchannel status shows status pending&n;&t;&t; * and we received a check condition, the count&n;&t;&t; * information is not meaningful.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|scsw-&gt;stctl
op_amp
id|SCSW_STCTL_STATUS_PEND
)paren
op_logical_and
(paren
id|scsw-&gt;cstat
op_amp
(paren
id|SCHN_STAT_CHN_DATA_CHK
op_or
id|SCHN_STAT_CHN_CTRL_CHK
op_or
id|SCHN_STAT_INTF_CTRL_CHK
op_or
id|SCHN_STAT_PROG_CHECK
op_or
id|SCHN_STAT_PROT_CHECK
op_or
id|SCHN_STAT_CHAIN_CHECK
)paren
)paren
)paren
)paren
(brace
id|dp-&gt;rescnt
op_assign
id|scsw-&gt;count
suffix:semicolon
)brace
r_else
(brace
id|dp-&gt;rescnt
op_assign
id|SENSE_MAX_COUNT
suffix:semicolon
)brace
id|dp-&gt;cpa
op_assign
id|scsw-&gt;cpa
suffix:semicolon
)brace
id|irb_cc
op_assign
id|scsw-&gt;cc
suffix:semicolon
multiline_comment|/*&n;&t; * check for any kind of channel or interface control check but don&squot;t&n;&t; * issue the message for the console device&n;&t; */
r_if
c_cond
(paren
(paren
id|scsw-&gt;cstat
op_amp
(paren
id|SCHN_STAT_CHN_DATA_CHK
op_or
id|SCHN_STAT_CHN_CTRL_CHK
op_or
id|SCHN_STAT_INTF_CTRL_CHK
)paren
)paren
)paren
(brace
id|CIO_DEBUG_NOCONS
(paren
id|irq
comma
id|KERN_WARNING
comma
id|printk
comma
l_int|0
comma
l_string|&quot;Channel-Check or Interface-Control-Check &quot;
l_string|&quot;received&bslash;n&quot;
l_string|&quot; ... device %04X on subchannel %04X, dev_stat &quot;
l_string|&quot;: %02X sch_stat : %02X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
comma
id|irq
comma
id|dp-&gt;dstat
comma
id|dp-&gt;cstat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irb_cc
op_ne
l_int|3
)paren
(brace
id|CIO_DEBUG_NOCONS
c_func
(paren
id|irq
comma
id|KERN_WARNING
comma
id|printk
comma
l_int|0
comma
l_string|&quot;s390_process_IRQ(%04X) - irb for &quot;
l_string|&quot;device %04X after channel check &quot;
l_string|&quot;or interface control check:&bslash;n&quot;
comma
id|irq
comma
id|dp-&gt;devno
)paren
suffix:semicolon
id|s390_displayhex
(paren
op_amp
(paren
id|dp-&gt;ii.irb
)paren
comma
r_sizeof
(paren
id|irb_t
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|scsw-&gt;ectl
op_eq
l_int|0
)paren
(brace
id|issense
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|scsw-&gt;stctl
op_eq
id|SCSW_STCTL_STATUS_PEND
)paren
op_logical_and
(paren
id|scsw-&gt;eswf
op_eq
l_int|0
)paren
)paren
(brace
id|issense
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|scsw-&gt;stctl
op_eq
(paren
id|SCSW_STCTL_STATUS_PEND
op_or
id|SCSW_STCTL_INTER_STATUS
)paren
)paren
op_logical_and
(paren
(paren
id|scsw-&gt;actl
op_amp
id|SCSW_ACTL_SUSPENDED
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|issense
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|issense
op_assign
id|dp-&gt;ii.irb.esw.esw0.erw.cons
suffix:semicolon
)brace
r_if
c_cond
(paren
id|issense
)paren
(brace
id|dp-&gt;scnt
op_assign
id|dp-&gt;ii.irb.esw.esw0.erw.scnt
suffix:semicolon
id|dp-&gt;flag
op_or_assign
id|DEVSTAT_FLAG_SENSE_AVAIL
suffix:semicolon
id|CIO_DEBUG_NOCONS
(paren
id|irq
comma
id|KERN_DEBUG
comma
id|DBG
comma
l_int|4
comma
l_string|&quot;s390_process_IRQ( %04X ): &quot;
l_string|&quot;concurrent sense bytes avail %d&bslash;n&quot;
comma
id|irq
comma
id|dp-&gt;scnt
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|irb_cc
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* status pending */
id|dp-&gt;flag
op_or_assign
id|DEVSTAT_STATUS_PENDING
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/* normal i/o interruption */
id|ending_status
op_assign
id|s390_process_IRQ_normal
c_func
(paren
id|irq
comma
id|ending_status
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* device/path not operational */
id|ending_status
op_assign
id|s390_process_IRQ_notoper
c_func
(paren
id|irq
comma
id|ending_status
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
(paren
id|ending_status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the special i/o-interruption subclass 7 for the&n; *  device specified by parameter irq. There can only&n; *  be a single device been operated on this special&n; *  isc. This function is aimed being able to check&n; *  on special device interrupts in disabled state,&n; *  without having to delay I/O processing (by queueing)&n; *  for non-console devices.&n; *&n; * Setting of this isc is done by set_cons_dev(), while&n; *  wait_cons_dev() allows to actively wait on an interrupt&n; *  for this device in disabed state. When the interrupt &n; *  condition is encountered, wait_cons_dev() calls do_IRQ()&n; *  to have the console device driver processing the&n; *  interrupt.&n; */
r_int
DECL|function|set_cons_dev
id|set_cons_dev
(paren
r_int
id|irq
)paren
(brace
r_int
id|ccode
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|SANITY_CHECK
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cons_dev
op_ne
op_minus
l_int|1
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;scons%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * modify the indicated console device to operate&n;&t; *  on special console interrupt subclass 7&n;&t; */
id|ccode
op_assign
id|stsch
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccode
)paren
(brace
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_NOT_OPER
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.isc
op_assign
l_int|7
suffix:semicolon
id|ccode
op_assign
id|msch
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccode
)paren
(brace
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|cons_dev
op_assign
id|irq
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * enable console I/O-interrupt subclass 7&n;&t;&t;&t; */
id|ctl_set_bit
c_func
(paren
l_int|6
comma
l_int|24
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
r_int
DECL|function|wait_cons_dev
id|wait_cons_dev
(paren
r_int
id|irq
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|save_cr6
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ne
id|cons_dev
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;wcons%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * before entering the spinlock we may already have&n;&t; *  processed the interrupt on a different CPU ...&n;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_eq
l_int|1
)paren
(brace
r_int
id|cr6
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|8
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * disable all, but isc 7 (console device)&n;&t;&t; */
id|__ctl_store
(paren
id|cr6
comma
l_int|6
comma
l_int|6
)paren
suffix:semicolon
id|save_cr6
op_assign
id|cr6
suffix:semicolon
id|cr6
op_and_assign
l_int|0x01FFFFFF
suffix:semicolon
id|__ctl_load
(paren
id|cr6
comma
l_int|6
comma
l_int|6
)paren
suffix:semicolon
r_do
(brace
id|tpi_info_t
id|tpi_info
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
r_if
c_cond
(paren
id|tpi
(paren
op_amp
id|tpi_info
)paren
op_eq
l_int|1
)paren
(brace
id|s390_process_IRQ
(paren
id|tpi_info.irq
)paren
suffix:semicolon
)brace
r_else
(brace
id|s390irq_spin_unlock
(paren
id|irq
)paren
suffix:semicolon
id|udelay
(paren
l_int|100
)paren
suffix:semicolon
id|s390irq_spin_lock
(paren
id|irq
)paren
suffix:semicolon
)brace
id|eieio
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_eq
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * restore previous isc value&n;&t;&t; */
id|cr6
op_assign
id|save_cr6
suffix:semicolon
id|__ctl_load
(paren
id|cr6
comma
l_int|6
comma
l_int|6
)paren
suffix:semicolon
)brace
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * used by {en,dis}able_cpu_sync_isc&n; */
r_static
r_inline
r_int
DECL|function|s390_set_isc5
id|s390_set_isc5
c_func
(paren
r_int
id|irq
comma
r_int
id|reset
)paren
(brace
r_int
id|ccode
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|retry1
op_assign
l_int|5
suffix:semicolon
r_int
id|retry2
op_assign
l_int|5
suffix:semicolon
r_int
id|clear_pend
op_assign
l_int|0
suffix:semicolon
r_int
id|cr6
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|8
)paren
)paren
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|reset
)paren
id|retry2
op_assign
l_int|5
suffix:semicolon
r_else
id|retry2
op_assign
l_int|3
suffix:semicolon
r_do
(brace
id|ccode
op_assign
id|msch
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * disable special interrupt subclass in CPU&n;&t;&t;&t;&t; */
id|__ctl_store
(paren
id|cr6
comma
l_int|6
comma
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reset
)paren
(brace
multiline_comment|/* disable sync isc 5 */
id|cr6
op_and_assign
l_int|0xFBFFFFFF
suffix:semicolon
multiline_comment|/* enable standard isc 3 */
id|cr6
op_or_assign
l_int|0x10000000
suffix:semicolon
multiline_comment|/* enable console isc 7, if neccessary */
r_if
c_cond
(paren
id|cons_dev
op_ne
op_minus
l_int|1
)paren
id|cr6
op_or_assign
l_int|0x01000000
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* enable sync isc 5 */
id|cr6
op_or_assign
l_int|0x04000000
suffix:semicolon
multiline_comment|/* disable standard isc 3 */
id|cr6
op_and_assign
l_int|0xEFFFFFFF
suffix:semicolon
multiline_comment|/* disable console isc 7, if neccessary */
r_if
c_cond
(paren
id|cons_dev
op_ne
op_minus
l_int|1
)paren
id|cr6
op_and_assign
l_int|0xFEFFFFFF
suffix:semicolon
)brace
id|__ctl_load
(paren
id|cr6
comma
l_int|6
comma
l_int|6
)paren
suffix:semicolon
id|retry2
op_assign
l_int|0
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* status pending */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|1
suffix:semicolon
id|s390_process_IRQ
(paren
id|irq
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|0
suffix:semicolon
id|retry2
op_decrement
suffix:semicolon
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* busy */
r_if
c_cond
(paren
id|reset
)paren
(brace
id|retry2
op_decrement
suffix:semicolon
id|udelay
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* give it time */
)brace
r_else
(brace
id|retry2
op_assign
l_int|0
suffix:semicolon
)brace
id|rc
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* not oper */
id|retry2
op_assign
l_int|0
suffix:semicolon
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|retry2
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_eq
l_int|0
)paren
op_logical_or
(paren
id|rc
op_eq
op_minus
id|ENODEV
)paren
op_logical_or
(paren
op_logical_neg
id|reset
)paren
)paren
id|retry1
op_assign
l_int|0
suffix:semicolon
r_else
id|retry1
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|retry1
)paren
(brace
multiline_comment|/* try stopping it ... */
r_if
c_cond
(paren
op_logical_neg
id|clear_pend
)paren
(brace
id|clear_IO
(paren
id|irq
comma
l_int|0x00004711
comma
l_int|0
)paren
suffix:semicolon
id|clear_pend
op_assign
l_int|1
suffix:semicolon
)brace
id|udelay
(paren
l_int|100
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|retry1
op_logical_and
id|ccode
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_int
DECL|function|enable_cpu_sync_isc
id|enable_cpu_sync_isc
(paren
r_int
id|irq
)paren
(brace
r_int
id|ccode
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;enisc%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
multiline_comment|/* This one spins until it can get the sync_isc lock for irq# irq */
r_if
c_cond
(paren
(paren
id|irq
op_le
id|highest_subchannel
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
op_logical_and
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|st
)paren
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
(paren
op_amp
id|sync_isc
)paren
op_ne
id|irq
)paren
id|atomic_compare_and_swap_spin
(paren
op_minus
l_int|1
comma
id|irq
comma
op_amp
id|sync_isc
)paren
suffix:semicolon
id|sync_isc_cnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sync_isc_cnt
OG
l_int|255
)paren
(brace
multiline_comment|/* fixme : magic number */
id|panic
(paren
l_string|&quot;Too many recursive calls to enable_sync_isc&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * we only run the STSCH/MSCH path for the first enablement&n;&t;&t; */
r_else
r_if
c_cond
(paren
id|sync_isc_cnt
op_eq
l_int|1
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.syncio
op_assign
l_int|1
suffix:semicolon
id|ccode
op_assign
id|stsch
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ccode
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.isc
op_assign
l_int|5
suffix:semicolon
id|rc
op_assign
id|s390_set_isc5
c_func
(paren
id|irq
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* device is not-operational */
)brace
)brace
r_if
c_cond
(paren
id|rc
)paren
(brace
multiline_comment|/* can only happen if stsch/msch fails */
id|sync_isc_cnt
op_assign
l_int|0
suffix:semicolon
id|atomic_set
(paren
op_amp
id|sync_isc
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
r_int
DECL|function|disable_cpu_sync_isc
id|disable_cpu_sync_isc
(paren
r_int
id|irq
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|ccode
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;disisc%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|irq
op_le
id|highest_subchannel
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
op_logical_and
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|st
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * We disable if we&squot;re the top user only, as we may&n;&t;&t; *  run recursively ... &n;&t;&t; * We must not decrease the count immediately; during&n;&t;&t; *  msch() processing we may face another pending&n;&t;&t; *  status we have to process recursively (sync).&n;&t;&t; */
r_if
c_cond
(paren
id|sync_isc_cnt
op_eq
l_int|1
)paren
(brace
id|ccode
op_assign
id|stsch
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ccode
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.isc
op_assign
l_int|3
suffix:semicolon
id|rc
op_assign
id|s390_set_isc5
c_func
(paren
id|irq
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.syncio
op_assign
l_int|0
suffix:semicolon
id|sync_isc_cnt
op_assign
l_int|0
suffix:semicolon
id|atomic_set
(paren
op_amp
id|sync_isc
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|sync_isc_cnt
op_decrement
suffix:semicolon
)brace
)brace
r_else
(brace
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
DECL|variable|halt_IO
id|EXPORT_SYMBOL
(paren
id|halt_IO
)paren
suffix:semicolon
DECL|variable|clear_IO
id|EXPORT_SYMBOL
(paren
id|clear_IO
)paren
suffix:semicolon
DECL|variable|do_IO
id|EXPORT_SYMBOL
(paren
id|do_IO
)paren
suffix:semicolon
DECL|variable|resume_IO
id|EXPORT_SYMBOL
(paren
id|resume_IO
)paren
suffix:semicolon
eof
