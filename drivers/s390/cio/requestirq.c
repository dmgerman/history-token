multiline_comment|/*&n; *  drivers/s390/cio/requestirq.c&n; *   S/390 common I/O routines -- &n; *   $Revision: 1.7 $&n; *&n; *    Copyright (C) 1999-2002 IBM Deutschland Entwicklung GmbH,&n; *                            IBM Corporation&n; *    Author(s): Ingo Adlung (adlung@de.ibm.com)&n; *               Cornelia Huck (cohuck@de.ibm.com) &n; *&t;&t; Arnd Bergmann (arndb@de.ibm.com)&n; *    ChangeLog: 11/04/2002 Arnd Bergmann Split s390io.c into multiple files,&n; *&t;&t;&t;&t;&t;  see s390io.c for complete list of&n; * &t;&t;&t;&t;&t;  changes.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
macro_line|#include &lt;asm/debug.h&gt;
macro_line|#include &lt;asm/cpcmd.h&gt;
macro_line|#include &quot;cio.h&quot;
macro_line|#include &quot;cio_debug.h&quot;
macro_line|#include &quot;ioinfo.h&quot;
macro_line|#include &quot;s390io.h&quot;
r_static
r_int
id|enable_subchannel
(paren
r_int
r_int
id|irq
)paren
suffix:semicolon
r_static
r_int
id|disable_subchannel
(paren
r_int
r_int
id|irq
)paren
suffix:semicolon
multiline_comment|/*&n; * Note : internal use of irqflags SA_PROBE for NOT path grouping &n; *&n; */
r_int
DECL|function|s390_request_irq_special
id|s390_request_irq_special
(paren
r_int
id|irq
comma
id|io_handler_func_t
id|io_handler
comma
id|not_oper_handler_func_t
id|not_oper_handler
comma
r_int
r_int
id|irqflags
comma
r_const
r_char
op_star
id|devname
comma
r_void
op_star
id|dev_id
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
r_int
id|retry
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ge
id|__MAX_SUBCHANNELS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|io_handler
op_logical_or
op_logical_neg
id|dev_id
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|st
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;reqsp%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|4
comma
id|dbf_txt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The following block of code has to be executed atomically&n;&t; */
id|s390irq_spin_lock_irqsave
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
id|retry
op_assign
l_int|5
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.handler
op_assign
id|io_handler
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.name
op_assign
id|devname
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
op_assign
id|dev_id
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
op_assign
l_int|1
suffix:semicolon
r_do
(brace
id|retval
op_assign
id|enable_subchannel
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|stsch
(paren
id|irq
comma
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.ena
)paren
id|retry
op_assign
l_int|0
suffix:semicolon
r_else
id|retry
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|retry
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; *  interrupt already owned, and shared interrupts&n;&t;&t; *   aren&squot;t supported on S/390.&n;&t;&t; */
id|retval
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
id|s390irq_spin_unlock_irqrestore
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|irqflags
op_amp
id|SA_PROBE
)paren
)paren
id|s390_DevicePathVerification
(paren
id|irq
comma
l_int|0
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|nopfunc
op_assign
id|not_oper_handler
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cio_debug_initialized
)paren
id|debug_int_event
(paren
id|cio_debug_trace_id
comma
l_int|4
comma
id|retval
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_int
DECL|function|s390_request_irq
id|s390_request_irq
(paren
r_int
r_int
id|irq
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
id|irqflags
comma
r_const
r_char
op_star
id|devname
comma
r_void
op_star
id|dev_id
)paren
(brace
r_return
id|s390_request_irq_special
(paren
id|irq
comma
(paren
id|io_handler_func_t
)paren
id|handler
comma
l_int|NULL
comma
id|irqflags
comma
id|devname
comma
id|dev_id
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * request_irq wrapper&n; */
r_int
DECL|function|request_irq
id|request_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
id|irqflags
comma
r_const
r_char
op_star
id|devname
comma
r_void
op_star
id|dev_id
)paren
(brace
r_return
id|s390_request_irq
c_func
(paren
id|irq
comma
id|handler
comma
id|irqflags
comma
id|devname
comma
id|dev_id
)paren
suffix:semicolon
)brace
r_void
DECL|function|s390_free_irq
id|s390_free_irq
(paren
r_int
r_int
id|irq
comma
r_void
op_star
id|dev_id
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ge
id|__MAX_SUBCHANNELS
op_logical_or
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|st
)paren
r_return
suffix:semicolon
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;free%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|2
comma
id|dbf_txt
)paren
suffix:semicolon
id|s390irq_spin_lock_irqsave
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
id|CIO_DEBUG_NOCONS
c_func
(paren
id|irq
comma
id|KERN_DEBUG
comma
id|printk
comma
l_int|2
comma
l_string|&quot;Trying to free IRQ %d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * disable the device and reset all IRQ info if&n;&t; *  the IRQ is actually owned by the handler ...&n;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
r_if
c_cond
(paren
id|dev_id
op_eq
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
)paren
(brace
multiline_comment|/* start deregister */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.unready
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
id|disable_subchannel
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EBUSY
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * kill it !&n;&t;&t;&t;&t; * We try to terminate the I/O by halt_IO first,&n;&t;&t;&t;&t; * then clear_IO.&n;&t;&t;&t;&t; * Because the device may be gone (machine &n;&t;&t;&t;&t; * check handling), we can&squot;t use sync I/O.&n;&t;&t;&t;&t; */
id|halt_IO
(paren
id|irq
comma
l_int|0xC8C1D3E3
comma
l_int|0
)paren
suffix:semicolon
id|s390irq_spin_unlock_irqrestore
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
id|udelay
(paren
l_int|200000
)paren
suffix:semicolon
multiline_comment|/* 200 ms */
id|s390irq_spin_lock_irqsave
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|disable_subchannel
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EBUSY
)paren
(brace
id|clear_IO
(paren
id|irq
comma
l_int|0x40C3D3D9
comma
l_int|0
)paren
suffix:semicolon
id|s390irq_spin_unlock_irqrestore
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
id|udelay
(paren
l_int|1000000
)paren
suffix:semicolon
multiline_comment|/* 1000 ms */
id|s390irq_spin_lock_irqsave
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* give it a very last try ... */
id|disable_subchannel
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
)paren
(brace
id|CIO_DEBUG_ALWAYS
c_func
(paren
id|KERN_CRIT
comma
l_int|0
comma
l_string|&quot;free_irq(%04X) - &quot;
l_string|&quot;device %04X busy, &quot;
l_string|&quot;retry count exceeded&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
)brace
)brace
)brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.unready
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* deregister ended */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|nopfunc
op_assign
l_int|NULL
suffix:semicolon
id|s390irq_spin_unlock_irqrestore
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|s390irq_spin_unlock_irqrestore
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
id|CIO_DEBUG_ALWAYS
c_func
(paren
id|KERN_ERR
comma
l_int|0
comma
l_string|&quot;free_irq(%04X) : error, &quot;
l_string|&quot;dev_id does not match !&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|s390irq_spin_unlock_irqrestore
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
id|CIO_DEBUG_ALWAYS
c_func
(paren
id|KERN_ERR
comma
l_int|0
comma
l_string|&quot;free_irq(%04X) : error, &quot;
l_string|&quot;no action block ... !&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * free_irq wrapper.&n; */
r_void
DECL|function|free_irq
id|free_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
op_star
id|dev_id
)paren
(brace
id|s390_free_irq
c_func
(paren
id|irq
comma
id|dev_id
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Enable IRQ by modifying the subchannel&n; */
r_static
r_int
DECL|function|enable_subchannel
id|enable_subchannel
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|ccode
suffix:semicolon
r_int
id|retry
op_assign
l_int|5
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|SANITY_CHECK
(paren
id|irq
)paren
suffix:semicolon
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;ensch%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|2
comma
id|dbf_txt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If a previous disable request is pending we reset it. However, this&n;&t; *  status implies that the device may (still) be not-operational.&n;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.d_disable
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.d_disable
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ccode
op_assign
id|stsch
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccode
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.ena
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_eq
id|cons_dev
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.isc
op_assign
l_int|7
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.isc
op_assign
l_int|3
suffix:semicolon
)brace
r_do
(brace
id|ccode
op_assign
id|msch
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* ok */
id|ret
op_assign
l_int|0
suffix:semicolon
id|retry
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* status pending */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|1
suffix:semicolon
id|s390_process_IRQ
(paren
id|irq
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * might be overwritten on re-driving &n;&t;&t;&t;&t;&t; * the msch()       &n;&t;&t;&t;&t;&t; */
id|retry
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* busy */
id|udelay
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* allow for recovery */
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
id|retry
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* not oper */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|retry
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|retry
)paren
suffix:semicolon
)brace
)brace
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;ret:%d&quot;
comma
id|ret
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|2
comma
id|dbf_txt
)paren
suffix:semicolon
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Disable IRQ by modifying the subchannel&n; */
r_static
r_int
DECL|function|disable_subchannel
id|disable_subchannel
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|cc
suffix:semicolon
multiline_comment|/* condition code */
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* function return value */
r_int
id|retry
op_assign
l_int|5
suffix:semicolon
r_char
id|dbf_txt
(braket
l_int|15
)braket
suffix:semicolon
id|SANITY_CHECK
(paren
id|irq
)paren
suffix:semicolon
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;dissch%x&quot;
comma
id|irq
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|2
comma
id|dbf_txt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
)paren
(brace
multiline_comment|/*&n;&t;&t; * the disable function must not be called while there are&n;&t;&t; *  requests pending for completion !&n;&t;&t; */
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * If device isn&squot;t operational we have to perform delayed&n;&t;&t; *  disabling when the next interrupt occurs - unless the&n;&t;&t; *  irq is re-requested prior to the interrupt to occur.&n;&t;&t; */
id|cc
op_assign
id|stsch
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cc
op_eq
l_int|3
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.d_disable
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* cc == 0 */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.ena
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|cc
op_assign
id|msch
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cc
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* ok */
id|retry
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* status pending */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|1
suffix:semicolon
id|s390_process_IRQ
(paren
id|irq
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * might be overwritten on re-driving &n;&t;&t;&t;&t;&t; * the msch() call       &n;&t;&t;&t;&t;&t; */
id|retry
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* busy; this should not happen! */
id|CIO_DEBUG_ALWAYS
c_func
(paren
id|KERN_CRIT
comma
l_int|0
comma
l_string|&quot;disable_subchannel&quot;
l_string|&quot;(%04X) - unexpected &quot;
l_string|&quot;busy condition for &quot;
l_string|&quot;device %04X received!&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat
dot
id|devno
)paren
suffix:semicolon
id|retry
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* not oper */
multiline_comment|/*&n;&t;&t;&t;&t;&t; * should hardly occur ?!&n;&t;&t;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.d_disable
op_assign
l_int|1
suffix:semicolon
id|retry
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t; * if the device has gone, we don&squot;t need &n;&t;&t;&t;&t;&t; * to disable it anymore !          &n;&t;&t;&t;&t;&t; */
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|retry
)paren
suffix:semicolon
)brace
)brace
id|sprintf
(paren
id|dbf_txt
comma
l_string|&quot;ret:%d&quot;
comma
id|ret
)paren
suffix:semicolon
id|CIO_TRACE_EVENT
(paren
l_int|2
comma
id|dbf_txt
)paren
suffix:semicolon
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/* FIXME: there must be a cleaner way to express what happens */
r_extern
r_void
id|do_reipl
(paren
r_int
)paren
suffix:semicolon
r_void
DECL|function|reipl
id|reipl
(paren
r_int
id|sch
)paren
(brace
r_int
id|i
suffix:semicolon
id|s390_dev_info_t
id|dev_info
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|highest_subchannel
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|get_dev_info_by_irq
(paren
id|i
comma
op_amp
id|dev_info
)paren
op_eq
l_int|0
op_logical_and
(paren
id|dev_info.status
op_amp
id|DEVSTAT_DEVICE_OWNED
)paren
)paren
(brace
id|free_irq
(paren
id|i
comma
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|irq_desc.dev_id
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|MACHINE_IS_VM
)paren
id|cpcmd
(paren
l_string|&quot;IPL&quot;
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_else
id|do_reipl
(paren
l_int|0x10000
op_or
id|sch
)paren
suffix:semicolon
)brace
DECL|variable|s390_request_irq_special
id|EXPORT_SYMBOL
(paren
id|s390_request_irq_special
)paren
suffix:semicolon
eof
