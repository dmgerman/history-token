multiline_comment|/*&n; *  drivers/s390/net/netiucv.c&n; *    Network driver for VM using iucv&n; *&n; *  S/390 version&n; *    Copyright (C) 1999, 2000 IBM Deutschland Entwicklung GmbH, IBM Corporation&n; *    Author(s): Stefan Hegewald &lt;hegewald@de.ibm.com&gt;&n; *               Hartmut Penner &lt;hpenner@de.ibm.com&gt;&n; *&n; *&n; *    2.3 Updates Denis Joseph Barrow (djbarrow@de.ibm.com,barrow_dj@yahoo.com)&n; *                Martin Schwidefsky (schwidefsky@de.ibm.com)&n; *&n; *    Re-write:   Alan Altmark (Alan_Altmark@us.ibm.com)  Sept. 2000&n; *                Uses iucv.c kernel module for IUCV services. &n; *&n; *    2.4 Updates Alan Altmark (Alan_Altmark@us.ibm.com)  June 2001&n; *                Update to use changed IUCV (iucv.c) interface.&n; *&n; * -------------------------------------------------------------------------- &n; *  An IUCV frame consists of one or more packets preceded by a 16-bit&n; *  header.   The header contains the offset to the next packet header,&n; *  measured from the beginning of the _frame_.  If zero, there are no more&n; *  packets in the frame.  Consider a frame which contains a 10-byte packet&n; *  followed by a 20-byte packet:&n; *        +-----+----------------+--------------------------------+-----+&n; *        |h&squot;12&squot;| 10-byte packet |h&squot;34&squot;|  20-byte packet          |h&squot;00&squot;|&n; *        +-----+----------------+-----+--------------------------+-----+&n; * Offset: 0     2                12    14                         34  &n; *&n; *  This means that each header will always have a larger value than the&n; *  previous one (except for the final zero header, of course).&n; *  &n; *  For outbound packets, we send ONE frame per packet.  So, our frame is:&n; *       AL2(packet length+2), packet, AL2(0)&n; *  The maximum packet size is the MTU, so the maximum IUCV frame we send&n; *  is MTU+4 bytes.&n; *&n; *  For inbound frames, we don&squot;t care how long the frame is.  We tear apart&n; *  the frame, processing packets up to MTU size in length, until no more&n; *  packets remain in the frame.&n; *&n; * --------------------------------------------------------------------------&n; *  The code uses the 2.3.43 network driver interfaces.  If compiled on an&n; *  an older level of the kernel, the module provides its own macros.&n; *  Doc is in Linux Weekly News (lwn.net) memo from David Miller, 9 Feb 2000.&n; *  There are a few other places with 2.3-specific enhancements.&n; *&n; * --------------------------------------------------------------------------&n;*/
singleline_comment|//#define DEBUG 1
singleline_comment|//#define DEBUG2 1
singleline_comment|//#define IPDEBUG 1
DECL|macro|LEVEL
mdefine_line|#define LEVEL &quot;1.1&quot;
multiline_comment|/* If MAX_DEVICES increased, add initialization data to iucv_netdev[] array */
multiline_comment|/* (See bottom of program.)&t;&t;&t;&t;&t;&t;    */
DECL|macro|MAX_DEVICES
mdefine_line|#define MAX_DEVICES 20&t;&t;/* Allows &quot;iucv0&quot; to &quot;iucv19&quot;   */
DECL|macro|MAX_VM_MTU
mdefine_line|#define MAX_VM_MTU 32764&t;/* 32K IUCV buffer, minus 4     */
DECL|macro|MAX_TX_Q
mdefine_line|#define MAX_TX_Q 50&t;&t;/* Maximum pending TX           */
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
id|MODULE_AUTHOR
(paren
l_string|&quot;(C) 2000 IBM Corporation by Alan Altmark (Alan_Altmark@us.ibm.com)&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
(paren
l_string|&quot;Linux for S/390 IUCV network driver &quot;
id|LEVEL
)paren
suffix:semicolon
id|MODULE_PARM
(paren
id|iucv
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
(paren
id|MAX_DEVICES
)paren
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
(paren
id|iucv
comma
l_string|&quot;Specify the userids associated with iucv0-iucv9:&bslash;n&quot;
l_string|&quot;iucv=userid1,userid2,...,userid10&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef MODVERSIONS
macro_line|#include &lt;linux/modversions.h&gt;
macro_line|#endif
macro_line|#else
DECL|macro|MOD_INC_USE_COUNT
mdefine_line|#define MOD_INC_USE_COUNT
DECL|macro|MOD_DEC_USE_COUNT
mdefine_line|#define MOD_DEC_USE_COUNT
macro_line|#endif
macro_line|#include &lt;linux/sched.h&gt;&t;/* task queues                  */
macro_line|#include &lt;linux/malloc.h&gt;&t;/* kmalloc()                    */
macro_line|#include &lt;linux/errno.h&gt;&t;/* error codes                  */
macro_line|#include &lt;linux/types.h&gt;&t;/* size_t                       */
macro_line|#include &lt;linux/interrupt.h&gt;&t;/* mark_bh                      */
macro_line|#include &lt;linux/netdevice.h&gt;&t;/* struct net_device, etc.      */
macro_line|#include &lt;linux/if_arp.h&gt;&t;/* ARPHRD_SLIP                  */
macro_line|#include &lt;linux/ip.h&gt;&t;&t;/* IP header                    */
macro_line|#include &lt;linux/skbuff.h&gt;&t;/* skb                          */
macro_line|#include &lt;linux/init.h&gt;&t;&t;/* __setup()                    */
macro_line|#include &lt;asm/string.h&gt;&t;&t;/* memset, memcpy, etc.         */
macro_line|#include &quot;iucv.h&quot;
macro_line|#if defined( DEBUG )
DECL|macro|KERN_INFO
macro_line|#undef KERN_INFO
DECL|macro|KERN_DEBUG
macro_line|#undef KERN_DEBUG
DECL|macro|KERN_NOTICE
macro_line|#undef KERN_NOTICE
DECL|macro|KERN_ERR
macro_line|#undef KERN_ERR
DECL|macro|KERN_INFO
mdefine_line|#define KERN_INFO    KERN_EMERG
DECL|macro|KERN_DEBUG
mdefine_line|#define KERN_DEBUG   KERN_EMERG
DECL|macro|KERN_NOTICE
mdefine_line|#define KERN_NOTICE  KERN_EMERG
DECL|macro|KERN_ERR
mdefine_line|#define KERN_ERR     KERN_EMERG
macro_line|#endif
macro_line|#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,3,0))
DECL|typedef|net_device
r_typedef
r_struct
id|net_device
id|net_device
suffix:semicolon
macro_line|#else
DECL|typedef|net_device
r_typedef
r_struct
id|device
id|net_device
suffix:semicolon
macro_line|#endif
r_static
id|__inline__
r_int
DECL|function|netif_is_busy
id|netif_is_busy
(paren
id|net_device
op_star
id|dev
)paren
(brace
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,45))
r_return
(paren
id|dev-&gt;tbusy
)paren
suffix:semicolon
macro_line|#else
r_return
(paren
id|test_bit
(paren
id|__LINK_STATE_XOFF
comma
op_amp
id|dev-&gt;flags
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,45))
multiline_comment|/* Provide our own 2.3.45 interfaces */
DECL|macro|netif_enter_interrupt
mdefine_line|#define netif_enter_interrupt(dev) dev-&gt;interrupt=1
DECL|macro|netif_exit_interrupt
mdefine_line|#define netif_exit_interrupt(dev) dev-&gt;interrupt=0
DECL|macro|netif_start
mdefine_line|#define netif_start(dev) dev-&gt;start=1
DECL|macro|netif_stop
mdefine_line|#define netif_stop(dev) dev-&gt;start=0
r_static
id|__inline__
r_void
DECL|function|netif_stop_queue
id|netif_stop_queue
(paren
id|net_device
op_star
id|dev
)paren
(brace
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
)brace
r_static
id|__inline__
r_void
DECL|function|netif_start_queue
id|netif_start_queue
(paren
id|net_device
op_star
id|dev
)paren
(brace
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
)brace
r_static
id|__inline__
r_void
DECL|function|netif_wake_queue
id|netif_wake_queue
(paren
id|net_device
op_star
id|dev
)paren
(brace
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
(paren
id|NET_BH
)paren
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/* As of 2.3.45, we don&squot;t do these things anymore */
DECL|macro|netif_enter_interrupt
mdefine_line|#define netif_enter_interrupt(dev)
DECL|macro|netif_exit_interrupt
mdefine_line|#define netif_exit_interrupt(dev)
DECL|macro|netif_start
mdefine_line|#define netif_start(dev)
DECL|macro|netif_stop
mdefine_line|#define netif_stop(dev)
macro_line|#endif
r_static
r_int
id|iucv_start
(paren
id|net_device
op_star
)paren
suffix:semicolon
r_static
r_int
id|iucv_stop
(paren
id|net_device
op_star
)paren
suffix:semicolon
r_static
r_int
id|iucv_change_mtu
(paren
id|net_device
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|iucv_init
(paren
id|net_device
op_star
)paren
suffix:semicolon
r_static
r_void
id|iucv_rx
(paren
id|net_device
op_star
comma
id|u32
comma
id|uchar
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|iucv_tx
(paren
r_struct
id|sk_buff
op_star
comma
id|net_device
op_star
)paren
suffix:semicolon
r_static
r_void
id|connection_severed
(paren
id|iucv_ConnectionSevered
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_void
id|connection_pending
(paren
id|iucv_ConnectionPending
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_void
id|connection_complete
(paren
id|iucv_ConnectionComplete
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_void
id|message_pending
(paren
id|iucv_MessagePending
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_static
r_void
id|send_complete
(paren
id|iucv_MessageComplete
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_void
id|register_iucv_dev
(paren
r_int
comma
r_char
op_star
)paren
suffix:semicolon
DECL|variable|netiucv_ops
r_static
id|iucv_interrupt_ops_t
id|netiucv_ops
op_assign
(brace
op_amp
id|connection_pending
comma
op_amp
id|connection_complete
comma
op_amp
id|connection_severed
comma
l_int|NULL
comma
multiline_comment|/* Quiesced             */
l_int|NULL
comma
multiline_comment|/* Resumed              */
op_amp
id|message_pending
comma
multiline_comment|/* Message pending      */
op_amp
id|send_complete
multiline_comment|/* Message complete     */
)brace
suffix:semicolon
DECL|variable|iucv_userid
r_static
r_char
id|iucv_userid
(braket
id|MAX_DEVICES
)braket
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|iucv_netdev
id|net_device
id|iucv_netdev
(braket
id|MAX_DEVICES
)braket
suffix:semicolon
multiline_comment|/* This structure is private to each device. It contains the    */
multiline_comment|/* information necessary to do IUCV operations.                 */
DECL|struct|iucv_priv
r_struct
id|iucv_priv
(brace
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
DECL|member|dev
id|net_device
op_star
id|dev
suffix:semicolon
DECL|member|handle
id|iucv_handle_t
id|handle
suffix:semicolon
DECL|member|userid
id|uchar
id|userid
(braket
l_int|9
)braket
suffix:semicolon
multiline_comment|/* Printable userid */
DECL|member|userid2
id|uchar
id|userid2
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* Used for IUCV operations */
multiline_comment|/* Note: atomic_compare_and_swap() return value is backwards */
multiline_comment|/*       from what you might think: FALSE=0=OK, TRUE=1=FAIL  */
DECL|member|state
id|atomic_t
id|state
suffix:semicolon
DECL|macro|FREE
mdefine_line|#define FREE 0
DECL|macro|CONNECTING
mdefine_line|#define CONNECTING 1
DECL|macro|CONNECTED
mdefine_line|#define CONNECTED 2
DECL|member|pathid
id|u16
id|pathid
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|iucv_host
id|uchar
id|iucv_host
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
DECL|variable|iucvMagic
id|uchar
id|iucvMagic
(braket
l_int|16
)braket
op_assign
(brace
l_int|0xF0
comma
l_int|0x40
comma
l_int|0x40
comma
l_int|0x40
comma
l_int|0x40
comma
l_int|0x40
comma
l_int|0x40
comma
l_int|0x40
comma
l_int|0xF0
comma
l_int|0x40
comma
l_int|0x40
comma
l_int|0x40
comma
l_int|0x40
comma
l_int|0x40
comma
l_int|0x40
comma
l_int|0x40
)brace
suffix:semicolon
multiline_comment|/* This mask means the 16-byte IUCV &quot;magic&quot; and the origin userid must */
multiline_comment|/* match exactly as specified in order to give connection_pending()    */
multiline_comment|/* control. &t;&t;&t;&t;&t;&t;&t;       */
DECL|variable|mask
r_const
r_char
id|mask
(braket
)braket
op_assign
(brace
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
)brace
suffix:semicolon
macro_line|#if defined( DEBUG2 ) || defined( IPDEBUG )
multiline_comment|/*--------------------------*/
multiline_comment|/* Dump buffer formatted    */
multiline_comment|/*--------------------------*/
r_static
r_void
DECL|function|dumpit
id|dumpit
(paren
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|i
op_mod
l_int|32
)paren
op_logical_and
id|i
op_ne
l_int|0
)paren
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|i
op_mod
l_int|4
)paren
op_logical_and
id|i
op_ne
l_int|0
)paren
id|printk
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;%02X&quot;
comma
id|buf
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
op_mod
l_int|32
)paren
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*-----------------------------------------------------------------*/
multiline_comment|/* Open a connection to another Linux or VM TCP/IP stack.          */
multiline_comment|/* Called by kernel.&t;&t;&t;&t;&t;&t;   */
multiline_comment|/*                                                                 */
multiline_comment|/* 1. Register a handler. (Up to now, any attempt by another stack */
multiline_comment|/*    has been rejected by the IUCV handler.)  We give the handler */
multiline_comment|/*    the net_device* so that we can locate the dev associated     */
multiline_comment|/*    with the partner userid if he tries to connect to us or      */
multiline_comment|/*    if the connection is broken.                                 */
multiline_comment|/*                                                                 */
multiline_comment|/* 2. Connect to remote stack.  If we get a connection pending     */
multiline_comment|/*    interrupt while we&squot;re in the middle of connecting, don&squot;t     */
multiline_comment|/*    worry.  VM will sever its and use ours, because the DEVICE   */
multiline_comment|/*    is defined to be:                                            */
multiline_comment|/*           DEVICE devname IUCV 0 0 linuxvm A                     */
multiline_comment|/*        or DEVICE devname IUCV 0 0 linuxvm B                     */
multiline_comment|/*    In EBCDIC, &quot;0&quot; (0xF0) is greater than &quot;A&quot; (0xC1) or &quot;B&quot;, so  */
multiline_comment|/*    win all races.  We will sever any connects that occur while  */
multiline_comment|/*    we are connecting.  The &quot;0 0&quot; is where we get iucvMagic from.*/
multiline_comment|/*&t;&t;&t;&t;&t;&t;&t;&t;   */
multiline_comment|/*    FIXME: If two Linux machines get into this race condition,   */
multiline_comment|/*           both will sever.  Manual intervention required.       */
multiline_comment|/*           Need a better IUCV &quot;hello&quot;-like function that permits */
multiline_comment|/*           some negotiation.  But can&squot;t do that until VM TCP/IP  */
multiline_comment|/*           would support it.                                     */
multiline_comment|/*                                                                 */
multiline_comment|/* 3. Return 0 to indicate device ok.  Anything else is an error.  */
multiline_comment|/*-----------------------------------------------------------------*/
r_static
r_int
DECL|function|iucv_start
id|iucv_start
(paren
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|rc
comma
id|i
suffix:semicolon
r_struct
id|iucv_priv
op_star
id|p
op_assign
(paren
r_struct
id|iucv_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|pr_debug
(paren
l_string|&quot;iucv_start(%s)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Allocate priv data */
id|p
op_assign
(paren
r_struct
id|iucv_priv
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|iucv_priv
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_CRIT
l_string|&quot;%s: no memory for dev-&gt;priv.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
(paren
id|p
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|iucv_priv
)paren
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
id|p
suffix:semicolon
id|p-&gt;dev
op_assign
id|dev
suffix:semicolon
id|memcpy
(paren
id|p-&gt;userid
comma
id|iucv_userid
(braket
id|dev
op_minus
id|iucv_netdev
)braket
comma
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Save userid */
id|memcpy
(paren
id|p-&gt;userid2
comma
id|p-&gt;userid
comma
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Again, with feeling.  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Change userid to printable form */
r_if
c_cond
(paren
id|p-&gt;userid
(braket
id|i
)braket
op_eq
l_char|&squot; &squot;
)paren
(brace
id|p-&gt;userid
(braket
id|i
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|p-&gt;userid
(braket
l_int|8
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|atomic_set
(paren
op_amp
id|p-&gt;state
comma
id|FREE
)paren
suffix:semicolon
id|p-&gt;handle
op_assign
id|iucv_register_program
(paren
id|iucvMagic
comma
id|p-&gt;userid2
comma
(paren
r_char
op_star
)paren
id|mask
comma
op_amp
id|netiucv_ops
comma
(paren
r_void
op_star
)paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;handle
op_le
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;%s: iucv_register_program error, rc=%p&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|p-&gt;handle
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
l_int|NULL
suffix:semicolon
id|kfree
(paren
id|p
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|pr_debug
(paren
l_string|&quot;state@ = %p&bslash;n&quot;
comma
op_amp
id|p-&gt;state
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_compare_and_swap
(paren
id|FREE
comma
id|CONNECTING
comma
op_amp
id|p-&gt;state
)paren
op_ne
l_int|0
)paren
(brace
id|pr_debug
(paren
l_string|&quot;Other side connecting during start&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|rc
op_assign
id|iucv_connect
(paren
op_amp
(paren
id|p-&gt;pathid
)paren
comma
id|MAX_TX_Q
comma
id|iucvMagic
comma
id|p-&gt;userid2
comma
id|iucv_host
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
comma
id|p-&gt;handle
comma
id|p
)paren
suffix:semicolon
multiline_comment|/* Some errors are not fatal.  In these cases we will report &quot;OK&quot;. */
r_switch
c_cond
(paren
id|rc
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* Wait for connection to complete */
id|pr_debug
(paren
l_string|&quot;...waiting for connection to complete...&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
l_int|11
suffix:colon
multiline_comment|/* Wait for parter to connect */
id|printk
(paren
id|KERN_NOTICE
l_string|&quot;%s: &quot;
l_string|&quot;User %s is not available now.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|p-&gt;userid
)paren
suffix:semicolon
id|atomic_set
(paren
op_amp
id|p-&gt;state
comma
id|FREE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
l_int|12
suffix:colon
multiline_comment|/* Wait for partner to connect */
id|printk
(paren
id|KERN_NOTICE
l_string|&quot;%s: &quot;
l_string|&quot;User %s is not ready to talk now.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|p-&gt;userid
)paren
suffix:semicolon
id|atomic_set
(paren
op_amp
id|p-&gt;state
comma
id|FREE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
l_int|13
suffix:colon
multiline_comment|/* Fatal */
id|printk
(paren
id|KERN_ERR
l_string|&quot;%s: &quot;
l_string|&quot;You have too many IUCV connections.&quot;
l_string|&quot;Check MAXCONN in CP directory.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|14
suffix:colon
multiline_comment|/* Fatal */
id|printk
(paren
id|KERN_ERR
l_string|&quot;%s: &quot;
l_string|&quot;User %s has too many IUCV connections.&quot;
l_string|&quot;Check MAXCONN in CP directory.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|p-&gt;userid
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|15
suffix:colon
multiline_comment|/* Fatal */
id|printk
(paren
id|KERN_ERR
l_string|&quot;%s: &quot;
l_string|&quot;No IUCV authorization found in CP directory.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Really fatal! Should not occur!! */
id|printk
(paren
id|KERN_ERR
l_string|&quot;%s: &quot;
l_string|&quot;return code %i from iucv_connect()&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rc
)paren
suffix:semicolon
)brace
id|rc
op_assign
id|iucv_unregister_program
(paren
id|p-&gt;handle
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
l_int|NULL
suffix:semicolon
id|kfree
(paren
id|p
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* end iucv_start() */
multiline_comment|/*********************************************************************/
multiline_comment|/* Our connection TO another stack has been accepted.                */
multiline_comment|/*********************************************************************/
r_static
r_void
DECL|function|connection_complete
id|connection_complete
(paren
id|iucv_ConnectionComplete
op_star
id|cci
comma
r_void
op_star
id|pgm_data
)paren
(brace
r_struct
id|iucv_priv
op_star
id|p
op_assign
(paren
r_struct
id|iucv_priv
op_star
)paren
id|pgm_data
suffix:semicolon
id|pr_debug
(paren
l_string|&quot;...%s connection complete... txq=%u&bslash;n&quot;
comma
id|p-&gt;dev-&gt;name
comma
id|cci-&gt;ipmsglim
)paren
suffix:semicolon
id|atomic_set
(paren
op_amp
id|p-&gt;state
comma
id|CONNECTED
)paren
suffix:semicolon
id|p-&gt;pathid
op_assign
id|cci-&gt;ippathid
suffix:semicolon
id|p-&gt;dev-&gt;tx_queue_len
op_assign
id|cci-&gt;ipmsglim
suffix:semicolon
id|netif_start
(paren
id|p-&gt;dev
)paren
suffix:semicolon
id|netif_start_queue
(paren
id|p-&gt;dev
)paren
suffix:semicolon
id|printk
(paren
id|KERN_NOTICE
l_string|&quot;%s: Connection to user %s is up&bslash;n&quot;
comma
id|p-&gt;dev-&gt;name
comma
id|p-&gt;userid
)paren
suffix:semicolon
)brace
multiline_comment|/* end connection_complete() */
multiline_comment|/*********************************************************************/
multiline_comment|/* A connection FROM another stack is pending.  If we are in the     */
multiline_comment|/* middle of connecting, sever the new connection.                   */
multiline_comment|/*&t;&t;&t;&t;&t;&t;&t;&t;     */
multiline_comment|/* We only get here if we&squot;ve done an iucv_register(), so we know     */
multiline_comment|/* the remote user is the correct user.                              */
multiline_comment|/*********************************************************************/
r_static
r_void
DECL|function|connection_pending
id|connection_pending
(paren
id|iucv_ConnectionPending
op_star
id|cpi
comma
r_void
op_star
id|pgm_data
)paren
(brace
multiline_comment|/* Only get this far if handler is set up, so we know userid is ok. */
multiline_comment|/* and the device is started.                                       */
multiline_comment|/* pgm_data is different for this one.  We get dev*, not priv*.     */
id|net_device
op_star
id|dev
op_assign
(paren
id|net_device
op_star
)paren
id|pgm_data
suffix:semicolon
r_struct
id|iucv_priv
op_star
id|p
op_assign
(paren
r_struct
id|iucv_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|u16
id|msglimit
suffix:semicolon
id|uchar
id|udata
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* If we&squot;re not waiting on a connect, reject the connection */
r_if
c_cond
(paren
id|atomic_compare_and_swap
(paren
id|FREE
comma
id|CONNECTING
comma
op_amp
id|p-&gt;state
)paren
op_ne
l_int|0
)paren
(brace
id|iucv_sever
(paren
id|cpi-&gt;ippathid
comma
id|udata
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rc
op_assign
id|iucv_accept
(paren
id|cpi-&gt;ippathid
comma
multiline_comment|/* Path id                      */
id|MAX_TX_Q
comma
multiline_comment|/* desired IUCV msg limit       */
id|udata
comma
multiline_comment|/* user_Data                    */
l_int|0
comma
multiline_comment|/* No flags                     */
id|p-&gt;handle
comma
multiline_comment|/* registration handle          */
id|p
comma
multiline_comment|/* private data                 */
l_int|NULL
comma
multiline_comment|/* don&squot;t care about output flags */
op_amp
id|msglimit
)paren
suffix:semicolon
multiline_comment|/* Actual IUCV msg limit        */
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
id|atomic_set
(paren
op_amp
id|p-&gt;state
comma
id|FREE
)paren
suffix:semicolon
id|printk
(paren
id|KERN_ERR
l_string|&quot;%s: iucv accept failed rc=%i&bslash;n&quot;
comma
id|p-&gt;dev-&gt;name
comma
id|rc
)paren
suffix:semicolon
)brace
r_else
(brace
id|atomic_set
(paren
op_amp
id|p-&gt;state
comma
id|CONNECTED
)paren
suffix:semicolon
id|p-&gt;pathid
op_assign
id|cpi-&gt;ippathid
suffix:semicolon
id|p-&gt;dev-&gt;tx_queue_len
op_assign
(paren
id|u32
)paren
id|msglimit
suffix:semicolon
id|netif_start
(paren
id|p-&gt;dev
)paren
suffix:semicolon
id|netif_start_queue
(paren
id|p-&gt;dev
)paren
suffix:semicolon
id|printk
(paren
id|KERN_NOTICE
l_string|&quot;%s: Connection to user %s is up&bslash;n&quot;
comma
id|p-&gt;dev-&gt;name
comma
id|p-&gt;userid
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end connection_pending() */
multiline_comment|/*********************************************************************/
multiline_comment|/* Our connection to another stack has been severed.                 */
multiline_comment|/*********************************************************************/
r_static
r_void
DECL|function|connection_severed
id|connection_severed
(paren
id|iucv_ConnectionSevered
op_star
id|eib
comma
r_void
op_star
id|pgm_data
)paren
(brace
r_struct
id|iucv_priv
op_star
id|p
op_assign
(paren
r_struct
id|iucv_priv
op_star
)paren
id|pgm_data
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: Connection to user %s is down&bslash;n&quot;
comma
id|p-&gt;dev-&gt;name
comma
id|p-&gt;userid
)paren
suffix:semicolon
multiline_comment|/* FIXME: We can also get a severed interrupt while in&n;&t;          state CONNECTING!  Fix the state machine ... */
macro_line|#if 0
r_if
c_cond
(paren
id|atomic_compare_and_swap
(paren
id|CONNECTED
comma
id|FREE
comma
op_amp
id|p-&gt;state
)paren
op_ne
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* In case reconnect in progress already */
macro_line|#else
id|atomic_set
(paren
op_amp
id|p-&gt;state
comma
id|FREE
)paren
suffix:semicolon
macro_line|#endif
id|netif_stop_queue
(paren
id|p-&gt;dev
)paren
suffix:semicolon
id|netif_stop
(paren
id|p-&gt;dev
)paren
suffix:semicolon
)brace
multiline_comment|/* end connection_severed() */
multiline_comment|/*-----------------------------------------------------*/
multiline_comment|/* STOP device.                   Called by kernel.    */
multiline_comment|/*-----------------------------------------------------*/
r_static
r_int
DECL|function|iucv_stop
id|iucv_stop
(paren
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_struct
id|iucv_priv
op_star
id|p
suffix:semicolon
id|pr_debug
(paren
l_string|&quot;%s: iucv_stop&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|netif_stop_queue
(paren
id|dev
)paren
suffix:semicolon
id|netif_stop
(paren
id|dev
)paren
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|iucv_priv
op_star
)paren
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Unregister will sever associated connections */
id|rc
op_assign
id|iucv_unregister_program
(paren
id|p-&gt;handle
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
l_int|NULL
suffix:semicolon
id|kfree
(paren
id|p
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end  iucv_stop() */
multiline_comment|/*---------------------------------------------------------------------*/
multiline_comment|/* Inbound packets from other host are ready for receipt.  Receive     */
multiline_comment|/* them (they arrive as a single transmission), break them up into     */
multiline_comment|/* separate packets, and send them to the &quot;generic&quot; packet processor.  */
multiline_comment|/*---------------------------------------------------------------------*/
r_static
r_void
DECL|function|message_pending
id|message_pending
(paren
id|iucv_MessagePending
op_star
id|mpi
comma
r_void
op_star
id|pgm_data
)paren
(brace
r_struct
id|iucv_priv
op_star
id|p
op_assign
(paren
r_struct
id|iucv_priv
op_star
)paren
id|pgm_data
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|u32
id|buffer_length
suffix:semicolon
id|u16
id|packet_offset
comma
id|prev_offset
op_assign
l_int|0
suffix:semicolon
r_void
op_star
id|buffer
suffix:semicolon
id|buffer_length
op_assign
id|mpi-&gt;ln1msg2.ipbfln1f
suffix:semicolon
id|pr_debug
(paren
l_string|&quot;%s: MP id=%i Length=%u&bslash;n&quot;
comma
id|p-&gt;dev-&gt;name
comma
id|mpi-&gt;ipmsgid
comma
id|buffer_length
)paren
suffix:semicolon
id|buffer
op_assign
id|kmalloc
(paren
id|buffer_length
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
(brace
id|p-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rc
op_assign
id|iucv_receive
(paren
id|p-&gt;pathid
comma
id|mpi-&gt;ipmsgid
comma
id|mpi-&gt;iptrgcls
comma
id|buffer
comma
id|buffer_length
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
op_logical_or
id|buffer_length
OL
l_int|5
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: IUCV rcv error. rc=%X ID=%i length=%u&bslash;n&quot;
comma
id|p-&gt;dev-&gt;name
comma
id|rc
comma
id|mpi-&gt;ipmsgid
comma
id|buffer_length
)paren
suffix:semicolon
id|p-&gt;stats.rx_errors
op_increment
suffix:semicolon
id|kfree
(paren
id|buffer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|packet_offset
op_assign
op_star
(paren
(paren
id|u16
op_star
)paren
id|buffer
)paren
suffix:semicolon
r_while
c_loop
(paren
id|packet_offset
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|packet_offset
op_le
id|prev_offset
op_logical_or
id|packet_offset
OG
id|buffer_length
op_minus
l_int|2
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: bad inbound packet offset %u, &quot;
l_string|&quot;prev %u, total %u&bslash;n&quot;
comma
id|p-&gt;dev-&gt;name
comma
id|packet_offset
comma
id|prev_offset
comma
id|buffer_length
)paren
suffix:semicolon
id|p-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Kick the packet upstairs */
id|iucv_rx
(paren
id|p-&gt;dev
comma
id|mpi-&gt;ipmsgid
comma
id|buffer
op_plus
id|prev_offset
op_plus
l_int|2
comma
id|packet_offset
op_minus
id|prev_offset
op_minus
l_int|2
)paren
suffix:semicolon
id|prev_offset
op_assign
id|packet_offset
suffix:semicolon
id|packet_offset
op_assign
op_star
(paren
(paren
id|u16
op_star
)paren
(paren
id|buffer
op_plus
id|packet_offset
)paren
)paren
suffix:semicolon
)brace
)brace
id|kfree
(paren
id|buffer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* end message_pending() */
multiline_comment|/*-------------------------------------------------------------*/
multiline_comment|/* Add meta-data to packet and send upstairs.                  */
multiline_comment|/*-------------------------------------------------------------*/
r_static
r_void
DECL|function|iucv_rx
id|iucv_rx
(paren
id|net_device
op_star
id|dev
comma
id|u32
id|msgid
comma
id|uchar
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|iucv_priv
op_star
id|p
op_assign
(paren
r_struct
id|iucv_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
macro_line|#ifdef IPDEBUG
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;RX id=%i&bslash;n&quot;
comma
id|msgid
)paren
suffix:semicolon
id|dumpit
(paren
id|buf
comma
l_int|20
)paren
suffix:semicolon
id|dumpit
(paren
id|buf
op_plus
l_int|20
comma
l_int|20
)paren
suffix:semicolon
macro_line|#endif
id|pr_debug
(paren
l_string|&quot;%s: RX len=%u&bslash;n&quot;
comma
id|p-&gt;dev-&gt;name
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|p-&gt;dev-&gt;mtu
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: inbound packet id# %i length %u exceeds MTU %i&bslash;n&quot;
comma
id|p-&gt;dev-&gt;name
comma
id|msgid
comma
id|len
comma
id|p-&gt;dev-&gt;mtu
)paren
suffix:semicolon
id|p-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb
op_assign
id|dev_alloc_skb
(paren
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|p-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* If not enough room, skb_put will panic */
id|memcpy
(paren
id|skb_put
(paren
id|skb
comma
id|len
)paren
comma
id|buf
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Write metadata, and then pass to the receive level.  Since we */
multiline_comment|/* are not an Ethernet device, we have special fields to set.    */
multiline_comment|/* This is all boilerplace, not to be messed with.               */
id|skb-&gt;dev
op_assign
id|p-&gt;dev
suffix:semicolon
multiline_comment|/* Set device       */
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/* Point to packet  */
id|skb-&gt;pkt_type
op_assign
id|PACKET_HOST
suffix:semicolon
multiline_comment|/* ..for this host. */
id|skb-&gt;protocol
op_assign
id|htons
(paren
id|ETH_P_IP
)paren
suffix:semicolon
multiline_comment|/* IP packet        */
id|skb-&gt;ip_summed
op_assign
id|CHECKSUM_UNNECESSARY
suffix:semicolon
multiline_comment|/* No checksum      */
id|p-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|p-&gt;stats.rx_bytes
op_add_assign
id|len
suffix:semicolon
id|netif_rx
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* end  iucv_rx() */
multiline_comment|/*-------------------------------------------------------------*/
multiline_comment|/* TRANSMIT a packet.            &t;    Called by kernel.  */
multiline_comment|/* This function deals with hw details of packet transmission. */
multiline_comment|/*-------------------------------------------------------------*/
r_static
r_int
DECL|function|iucv_tx
id|iucv_tx
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|rc
comma
id|pktlen
suffix:semicolon
id|u32
id|framelen
comma
id|msgid
suffix:semicolon
r_void
op_star
id|frame
suffix:semicolon
r_struct
id|iucv_priv
op_star
id|p
op_assign
(paren
r_struct
id|iucv_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Nothing to do */
id|printk
(paren
id|KERN_WARNING
l_string|&quot;%s: TX Kernel passed null sk_buffer&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|p-&gt;stats.tx_dropped
op_increment
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|netif_is_busy
(paren
id|dev
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* save the timestamp */
multiline_comment|/* IUCV frame will be released when MessageComplete   */
multiline_comment|/* interrupt is received.                             */
id|pktlen
op_assign
id|skb-&gt;len
suffix:semicolon
id|framelen
op_assign
id|pktlen
op_plus
l_int|4
suffix:semicolon
id|frame
op_assign
id|kmalloc
(paren
id|framelen
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|frame
)paren
(brace
id|p-&gt;stats.tx_dropped
op_increment
suffix:semicolon
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|netif_stop_queue
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* transmission is busy */
op_star
(paren
id|u16
op_star
)paren
id|frame
op_assign
id|pktlen
op_plus
l_int|2
suffix:semicolon
multiline_comment|/* Set header   */
id|memcpy
(paren
id|frame
op_plus
l_int|2
comma
id|skb-&gt;data
comma
id|pktlen
)paren
suffix:semicolon
multiline_comment|/* Copy data    */
id|memset
(paren
id|frame
op_plus
id|pktlen
op_plus
l_int|2
comma
l_int|0
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Set trailer  */
multiline_comment|/* Ok, now the frame is ready for transmission: send it. */
id|rc
op_assign
id|iucv_send
(paren
id|p-&gt;pathid
comma
op_amp
id|msgid
comma
l_int|0
comma
l_int|0
comma
(paren
id|u32
)paren
id|frame
comma
multiline_comment|/* Msg tag      */
l_int|0
comma
multiline_comment|/* No flags     */
id|frame
comma
id|framelen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef IPDEBUG
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;TX id=%i&bslash;n&quot;
comma
id|msgid
)paren
suffix:semicolon
id|dumpit
(paren
id|skb-&gt;data
comma
l_int|20
)paren
suffix:semicolon
id|dumpit
(paren
id|skb-&gt;data
op_plus
l_int|20
comma
l_int|20
)paren
suffix:semicolon
macro_line|#endif
id|pr_debug
(paren
l_string|&quot;%s: tx START %i.%i @=%p len=%i&bslash;n&quot;
comma
id|p-&gt;dev-&gt;name
comma
id|p-&gt;pathid
comma
id|msgid
comma
id|frame
comma
id|framelen
)paren
suffix:semicolon
id|p-&gt;stats.tx_packets
op_increment
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|rc
op_eq
l_int|3
)paren
multiline_comment|/* Exceeded MSGLIMIT */
id|p-&gt;stats.tx_dropped
op_increment
suffix:semicolon
r_else
(brace
id|p-&gt;stats.tx_errors
op_increment
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: tx ERROR id=%i.%i rc=%i&bslash;n&quot;
comma
id|p-&gt;dev-&gt;name
comma
id|p-&gt;pathid
comma
id|msgid
comma
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/* We won&squot;t get interrupt.  Free frame now. */
id|kfree
(paren
id|frame
)paren
suffix:semicolon
)brace
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Finished with skb            */
id|netif_wake_queue
(paren
id|p-&gt;dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end iucv_tx() */
multiline_comment|/*-----------------------------------------------------------*/
multiline_comment|/* SEND COMPLETE                    Called by IUCV handler.  */
multiline_comment|/* Free the IUCV frame that was used for this transmission.  */
multiline_comment|/*-----------------------------------------------------------*/
r_static
r_void
DECL|function|send_complete
id|send_complete
(paren
id|iucv_MessageComplete
op_star
id|mci
comma
r_void
op_star
id|pgm_data
)paren
(brace
r_void
op_star
id|frame
suffix:semicolon
macro_line|#ifdef DEBUG
r_struct
id|iucv_priv
op_star
id|p
op_assign
(paren
r_struct
id|iucv_priv
op_star
)paren
id|pgm_data
suffix:semicolon
macro_line|#endif
id|frame
op_assign
(paren
r_void
op_star
)paren
(paren
id|ulong
)paren
id|mci-&gt;ipmsgtag
suffix:semicolon
id|kfree
(paren
id|frame
)paren
suffix:semicolon
id|pr_debug
(paren
l_string|&quot;%s: TX DONE %i.%i @=%p&bslash;n&quot;
comma
id|p-&gt;dev-&gt;name
comma
id|mci-&gt;ippathid
comma
id|mci-&gt;ipmsgid
comma
id|frame
)paren
suffix:semicolon
)brace
multiline_comment|/* end send_complete() */
multiline_comment|/*-----------------------------------------------------------*/
multiline_comment|/* STATISTICS reporting.                  Called by kernel.  */
multiline_comment|/*-----------------------------------------------------------*/
r_static
r_struct
id|net_device_stats
op_star
DECL|function|iucv_stats
id|iucv_stats
(paren
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|iucv_priv
op_star
id|p
op_assign
(paren
r_struct
id|iucv_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|p-&gt;stats
suffix:semicolon
)brace
multiline_comment|/* end iucv_stats() */
multiline_comment|/*-----------------------------------------------------------*/
multiline_comment|/* MTU change    .                        Called by kernel.  */
multiline_comment|/* IUCV can handle mtu sizes from 576 (the IP architectural  */
multiline_comment|/* minimum) up to maximum supported by VM.  I don&squot;t think IP */
multiline_comment|/* pays attention to new mtu until device is restarted.      */
multiline_comment|/*-----------------------------------------------------------*/
r_static
r_int
DECL|function|iucv_change_mtu
id|iucv_change_mtu
(paren
id|net_device
op_star
id|dev
comma
r_int
id|new_mtu
)paren
(brace
r_if
c_cond
(paren
(paren
id|new_mtu
OL
l_int|576
)paren
op_logical_or
(paren
id|new_mtu
OG
id|MAX_VM_MTU
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|dev-&gt;mtu
op_assign
id|new_mtu
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end iucv_change_mtu() */
multiline_comment|/*-----------------------------------------------------------*/
multiline_comment|/* INIT device.                           Called by kernel.  */
multiline_comment|/* Called by register_netdev() in kernel.                    */
multiline_comment|/*-----------------------------------------------------------*/
r_static
r_int
DECL|function|iucv_init
id|iucv_init
(paren
id|net_device
op_star
id|dev
)paren
(brace
id|dev-&gt;open
op_assign
id|iucv_start
suffix:semicolon
id|dev-&gt;stop
op_assign
id|iucv_stop
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|iucv_tx
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|iucv_stats
suffix:semicolon
id|dev-&gt;change_mtu
op_assign
id|iucv_change_mtu
suffix:semicolon
id|dev-&gt;hard_header_len
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;addr_len
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;type
op_assign
id|ARPHRD_SLIP
suffix:semicolon
id|dev-&gt;tx_queue_len
op_assign
id|MAX_TX_Q
suffix:semicolon
multiline_comment|/* Default - updated based on IUCV */
multiline_comment|/* keep the default flags, just add NOARP and POINTOPOINT */
id|dev-&gt;flags
op_or_assign
id|IFF_NOARP
op_or
id|IFF_POINTOPOINT
suffix:semicolon
id|dev-&gt;mtu
op_assign
l_int|9216
suffix:semicolon
id|dev_init_buffers
(paren
id|dev
)paren
suffix:semicolon
id|pr_debug
(paren
l_string|&quot;%s: iucv_init  dev@=%p&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifndef MODULE
multiline_comment|/*-----------------------------------------------------------------*/
multiline_comment|/* Process iucv=userid1,...,useridn kernel parameter.              */
multiline_comment|/*                                                                 */
multiline_comment|/* Each user id provided will be associated with device &squot;iucvnn&squot;.  */
multiline_comment|/* iucv_init will be called to initialize each device.             */
multiline_comment|/*-----------------------------------------------------------------*/
macro_line|#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,3,0))
DECL|macro|init_return
mdefine_line|#define init_return(a) return a
r_static
r_int
id|__init
DECL|function|iucv_setup
id|iucv_setup
(paren
r_char
op_star
id|iucv
)paren
macro_line|#else
mdefine_line|#define init_return(a) return
id|__initfunc
(paren
r_void
id|iucv_setup
(paren
r_char
op_star
id|iucv
comma
r_int
op_star
id|ints
)paren
)paren
macro_line|#endif
(brace
r_int
id|i
comma
id|devnumber
suffix:semicolon
r_char
op_star
id|s
suffix:semicolon
r_char
id|temp_userid
(braket
l_int|9
)braket
suffix:semicolon
id|i
op_assign
id|devnumber
op_assign
l_int|0
suffix:semicolon
id|memset
(paren
id|temp_userid
comma
l_char|&squot; &squot;
comma
l_int|8
)paren
suffix:semicolon
id|temp_userid
(braket
l_int|8
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|printk
(paren
id|KERN_NOTICE
l_string|&quot;netiucv: IUCV network driver &quot;
id|LEVEL
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iucv
)paren
id|init_return
(paren
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|s
op_assign
id|iucv
suffix:semicolon
op_star
id|s
op_ne
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|s
op_increment
)paren
(brace
r_if
c_cond
(paren
op_star
id|s
op_eq
l_char|&squot; &squot;
)paren
multiline_comment|/* Compress out blanks */
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|devnumber
op_ge
id|MAX_DEVICES
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;More than %i IUCV hosts specified&bslash;n&quot;
comma
id|MAX_DEVICES
)paren
suffix:semicolon
id|init_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|s
op_ne
l_char|&squot;,&squot;
)paren
(brace
id|temp_userid
(braket
id|i
op_increment
)braket
op_assign
op_star
id|s
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|8
op_logical_or
op_star
(paren
id|s
op_plus
l_int|1
)paren
op_eq
l_char|&squot;,&squot;
op_logical_or
op_star
(paren
id|s
op_plus
l_int|1
)paren
op_eq
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|register_iucv_dev
(paren
id|devnumber
comma
id|temp_userid
)paren
suffix:semicolon
id|devnumber
op_increment
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|memset
(paren
id|temp_userid
comma
l_char|&squot; &squot;
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
id|s
op_plus
l_int|1
)paren
op_ne
l_char|&squot;&bslash;0&squot;
)paren
op_star
(paren
id|s
op_plus
l_int|1
)paren
op_assign
l_char|&squot; &squot;
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* while */
id|init_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,3,0))
id|__setup
(paren
l_string|&quot;iucv=&quot;
comma
id|iucv_setup
)paren
suffix:semicolon
macro_line|#endif
macro_line|#else&t;&t;&t;&t;/* BUILT AS MODULE */
multiline_comment|/*-------------------------------------------------------------------*/
multiline_comment|/* Process iucv=userid1,...,useridn module paramter.                 */
multiline_comment|/*                                                                   */
multiline_comment|/* insmod passes the module an array of string pointers, each of     */
multiline_comment|/* which points to a userid.  The commas are stripped out by insmod. */
multiline_comment|/* MODULE_PARM defines the name of the array.  (See start of module.)*/
multiline_comment|/*                                                                   */
multiline_comment|/* Each user id provided will be associated with device &squot;iucvnn&squot;.    */
multiline_comment|/* iucv_init will be called to initialize each device.               */
multiline_comment|/*-------------------------------------------------------------------*/
DECL|variable|iucv
r_char
op_star
id|iucv
(braket
id|MAX_DEVICES
)braket
op_assign
(brace
l_int|NULL
)brace
suffix:semicolon
r_int
DECL|function|init_module
id|init_module
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
(paren
id|KERN_NOTICE
l_string|&quot;netiucv: IUCV network driver &quot;
id|LEVEL
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_DEVICES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|iucv
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|register_iucv_dev
(paren
id|i
comma
id|iucv
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|cleanup_module
id|cleanup_module
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_DEVICES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|iucv
(braket
id|i
)braket
)paren
id|unregister_netdev
(paren
op_amp
id|iucv_netdev
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* MODULE */
r_void
DECL|function|register_iucv_dev
id|register_iucv_dev
(paren
r_int
id|devnumber
comma
r_char
op_star
id|userid
)paren
(brace
r_int
id|rc
suffix:semicolon
id|net_device
op_star
id|dev
suffix:semicolon
id|memset
(paren
id|iucv_userid
(braket
id|devnumber
)braket
comma
l_char|&squot; &squot;
comma
l_int|8
)paren
suffix:semicolon
id|memcpy
(paren
id|iucv_userid
(braket
id|devnumber
)braket
comma
id|userid
comma
id|min_t
c_func
(paren
r_int
r_int
comma
id|strlen
c_func
(paren
id|userid
)paren
comma
l_int|8
)paren
)paren
suffix:semicolon
id|dev
op_assign
op_amp
id|iucv_netdev
(braket
id|devnumber
)braket
suffix:semicolon
id|sprintf
(paren
id|dev-&gt;name
comma
l_string|&quot;iucv%i&quot;
comma
id|devnumber
)paren
suffix:semicolon
id|pr_debug
(paren
l_string|&quot;netiucv: registering %s&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|register_netdev
(paren
id|dev
)paren
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;netiucv: register_netdev(%s) error %i&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rc
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* These structures are static because setup() can be called very */
multiline_comment|/* early in kernel init if this module is built into the kernel.  */
multiline_comment|/* Certainly no kmalloc() is available, probably no C runtime.    */
multiline_comment|/* If support changed to be module only, this can all be done     */
multiline_comment|/* dynamically.                                                   */
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0))
DECL|variable|iucv_names
r_static
r_char
id|iucv_names
(braket
id|MAX_DEVICES
)braket
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* Allows &quot;iucvXXX&quot; plus null */
macro_line|#endif
DECL|variable|iucv_netdev
id|net_device
id|iucv_netdev
(braket
id|MAX_DEVICES
)braket
op_assign
(brace
(brace
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0))
id|name
suffix:colon
op_amp
id|iucv_names
(braket
l_int|0
)braket
(braket
l_int|0
)braket
comma
multiline_comment|/* Name filled in at load time  */
macro_line|#endif
id|init
suffix:colon
id|iucv_init
multiline_comment|/* probe function               */
)brace
comma
(brace
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0))
id|name
suffix:colon
op_amp
id|iucv_names
(braket
l_int|1
)braket
(braket
l_int|0
)braket
comma
multiline_comment|/* Name filled in at load time  */
macro_line|#endif
id|init
suffix:colon
id|iucv_init
multiline_comment|/* probe function               */
)brace
comma
(brace
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0))
id|name
suffix:colon
op_amp
id|iucv_names
(braket
l_int|2
)braket
(braket
l_int|0
)braket
comma
multiline_comment|/* Name filled in at load time  */
macro_line|#endif
id|init
suffix:colon
id|iucv_init
multiline_comment|/* probe function               */
)brace
comma
(brace
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0))
id|name
suffix:colon
op_amp
id|iucv_names
(braket
l_int|3
)braket
(braket
l_int|0
)braket
comma
multiline_comment|/* Name filled in at load time  */
macro_line|#endif
id|init
suffix:colon
id|iucv_init
multiline_comment|/* probe function               */
)brace
comma
(brace
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0))
id|name
suffix:colon
op_amp
id|iucv_names
(braket
l_int|4
)braket
(braket
l_int|0
)braket
comma
multiline_comment|/* Name filled in at load time  */
macro_line|#endif
id|init
suffix:colon
id|iucv_init
multiline_comment|/* probe function               */
)brace
comma
(brace
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0))
id|name
suffix:colon
op_amp
id|iucv_names
(braket
l_int|5
)braket
(braket
l_int|0
)braket
comma
multiline_comment|/* Name filled in at load time  */
macro_line|#endif
id|init
suffix:colon
id|iucv_init
multiline_comment|/* probe function               */
)brace
comma
(brace
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0))
id|name
suffix:colon
op_amp
id|iucv_names
(braket
l_int|6
)braket
(braket
l_int|0
)braket
comma
multiline_comment|/* Name filled in at load time  */
macro_line|#endif
id|init
suffix:colon
id|iucv_init
multiline_comment|/* probe function               */
)brace
comma
(brace
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0))
id|name
suffix:colon
op_amp
id|iucv_names
(braket
l_int|7
)braket
(braket
l_int|0
)braket
comma
multiline_comment|/* Name filled in at load time  */
macro_line|#endif
id|init
suffix:colon
id|iucv_init
multiline_comment|/* probe function               */
)brace
comma
(brace
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0))
id|name
suffix:colon
op_amp
id|iucv_names
(braket
l_int|8
)braket
(braket
l_int|0
)braket
comma
multiline_comment|/* Name filled in at load time  */
macro_line|#endif
id|init
suffix:colon
id|iucv_init
multiline_comment|/* probe function               */
)brace
comma
(brace
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0))
id|name
suffix:colon
op_amp
id|iucv_names
(braket
l_int|9
)braket
(braket
l_int|0
)braket
comma
multiline_comment|/* Name filled in at load time  */
macro_line|#endif
id|init
suffix:colon
id|iucv_init
multiline_comment|/* probe function               */
)brace
comma
(brace
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0))
id|name
suffix:colon
op_amp
id|iucv_names
(braket
l_int|10
)braket
(braket
l_int|0
)braket
comma
multiline_comment|/* Name filled in at load time  */
macro_line|#endif
id|init
suffix:colon
id|iucv_init
multiline_comment|/* probe function               */
)brace
comma
(brace
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0))
id|name
suffix:colon
op_amp
id|iucv_names
(braket
l_int|11
)braket
(braket
l_int|0
)braket
comma
multiline_comment|/* Name filled in at load time  */
macro_line|#endif
id|init
suffix:colon
id|iucv_init
multiline_comment|/* probe function               */
)brace
comma
(brace
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0))
id|name
suffix:colon
op_amp
id|iucv_names
(braket
l_int|12
)braket
(braket
l_int|0
)braket
comma
multiline_comment|/* Name filled in at load time  */
macro_line|#endif
id|init
suffix:colon
id|iucv_init
multiline_comment|/* probe function               */
)brace
comma
(brace
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0))
id|name
suffix:colon
op_amp
id|iucv_names
(braket
l_int|13
)braket
(braket
l_int|0
)braket
comma
multiline_comment|/* Name filled in at load time  */
macro_line|#endif
id|init
suffix:colon
id|iucv_init
multiline_comment|/* probe function               */
)brace
comma
(brace
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0))
id|name
suffix:colon
op_amp
id|iucv_names
(braket
l_int|14
)braket
(braket
l_int|0
)braket
comma
multiline_comment|/* Name filled in at load time  */
macro_line|#endif
id|init
suffix:colon
id|iucv_init
multiline_comment|/* probe function               */
)brace
comma
(brace
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0))
id|name
suffix:colon
op_amp
id|iucv_names
(braket
l_int|15
)braket
(braket
l_int|0
)braket
comma
multiline_comment|/* Name filled in at load time  */
macro_line|#endif
id|init
suffix:colon
id|iucv_init
multiline_comment|/* probe function               */
)brace
comma
(brace
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0))
id|name
suffix:colon
op_amp
id|iucv_names
(braket
l_int|16
)braket
(braket
l_int|0
)braket
comma
multiline_comment|/* Name filled in at load time  */
macro_line|#endif
id|init
suffix:colon
id|iucv_init
multiline_comment|/* probe function               */
)brace
comma
(brace
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0))
id|name
suffix:colon
op_amp
id|iucv_names
(braket
l_int|17
)braket
(braket
l_int|0
)braket
comma
multiline_comment|/* Name filled in at load time  */
macro_line|#endif
id|init
suffix:colon
id|iucv_init
multiline_comment|/* probe function               */
)brace
comma
(brace
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0))
id|name
suffix:colon
op_amp
id|iucv_names
(braket
l_int|18
)braket
(braket
l_int|0
)braket
comma
multiline_comment|/* Name filled in at load time  */
macro_line|#endif
id|init
suffix:colon
id|iucv_init
multiline_comment|/* probe function               */
)brace
comma
(brace
macro_line|#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0))
id|name
suffix:colon
op_amp
id|iucv_names
(braket
l_int|19
)braket
(braket
l_int|0
)braket
comma
multiline_comment|/* Name filled in at load time  */
macro_line|#endif
id|init
suffix:colon
id|iucv_init
multiline_comment|/* probe function               */
)brace
comma
)brace
suffix:semicolon
eof
