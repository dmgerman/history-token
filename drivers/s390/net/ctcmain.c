multiline_comment|/*&n; * $Id: ctcmain.c,v 1.51 2001/09/24 10:38:02 mschwide Exp $&n; *&n; * CTC / ESCON network driver&n; *&n; * Copyright (C) 2001 IBM Deutschland Entwicklung GmbH, IBM Corporation&n; * Author(s): Fritz Elfert (elfert@de.ibm.com, felfert@millenux.com)&n; * Fixes by : Jochen R&#xfffd;hrig (roehrig@de.ibm.com)&n; *            Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt;&n; *&n; * Documentation used:&n; *  - Principles of Operation (IBM doc#: SA22-7201-06)&n; *  - Common IO/-Device Commands and Self Description (IBM doc#: SA22-7204-02)&n; *  - Common IO/-Device Commands and Self Description (IBM doc#: SN22-5535)&n; *  - ESCON Channel-to-Channel Adapter (IBM doc#: SA22-7203-00)&n; *  - ESCON I/O Interface (IBM doc#: SA22-7202-029&n; *&n; * and the source of the original CTC driver by:&n; *  Dieter Wellerdiek (wel@de.ibm.com)&n; *  Martin Schwidefsky (schwidefsky@de.ibm.com)&n; *  Denis Joseph Barrow (djbarrow@de.ibm.com,barrow_dj@yahoo.com)&n; *  Jochen R&#xfffd;hrig (roehrig@de.ibm.com)&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; * RELEASE-TAG: CTC/ESCON network driver $Revision: 1.51 $&n; *&n; */
"&f;"
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/tcp.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;net/dst.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#ifdef CONFIG_CHANDEV
DECL|macro|CTC_CHANDEV
mdefine_line|#define CTC_CHANDEV
macro_line|#endif
macro_line|#ifdef CTC_CHANDEV
macro_line|#include &lt;asm/chandev.h&gt;
DECL|macro|REQUEST_IRQ
mdefine_line|#define REQUEST_IRQ chandev_request_irq
DECL|macro|FREE_IRQ
mdefine_line|#define FREE_IRQ chandev_free_irq
macro_line|#else
DECL|macro|REQUEST_IRQ
mdefine_line|#define REQUEST_IRQ request_irq
DECL|macro|FREE_IRQ
mdefine_line|#define FREE_IRQ free_irq
macro_line|#endif
macro_line|#if LINUX_VERSION_CODE &gt;= 0x020213
macro_line|#  include &lt;asm/idals.h&gt;
macro_line|#else
DECL|macro|set_normalized_cda
macro_line|#  define set_normalized_cda(ccw, addr) ((ccw)-&gt;cda = (addr),0)
DECL|macro|clear_normalized_cda
macro_line|#  define clear_normalized_cda(ccw)
macro_line|#endif
macro_line|#if LINUX_VERSION_CODE &lt; 0x020400
DECL|macro|s390_dev_info_t
macro_line|#  define s390_dev_info_t dev_info_t
DECL|macro|dev_kfree_skb_irq
macro_line|#  define dev_kfree_skb_irq(a) dev_kfree_skb(a)
macro_line|#endif
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &quot;ctctty.h&quot;
macro_line|#include &quot;fsm.h&quot;
macro_line|#ifdef MODULE
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;(C) 2000 IBM Corp. by Fritz Elfert (felfert@millenux.com)&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Linux for S/390 CTC/Escon Driver&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
macro_line|#ifndef CTC_CHANDEV
id|MODULE_PARM
c_func
(paren
id|ctc
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|ctc
comma
l_string|&quot;One or more definitions in the same format like the kernel param for ctc.&bslash;n&quot;
l_string|&quot;E.g.: ctc0:0x700:0x701:0:ctc1:0x702:0x703:0&bslash;n&quot;
)paren
suffix:semicolon
DECL|variable|ctc
r_char
op_star
id|ctc
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
macro_line|#else
multiline_comment|/**&n; * Number of devices in monolithic (not module) driver version.&n; */
DECL|macro|MAX_STATIC_DEVICES
mdefine_line|#define MAX_STATIC_DEVICES 16
macro_line|#endif /* MODULE */
DECL|macro|DEBUG
macro_line|#undef DEBUG
multiline_comment|/**&n; * CCW commands, used in this driver.&n; */
DECL|macro|CCW_CMD_WRITE
mdefine_line|#define CCW_CMD_WRITE&t;&t;0x01
DECL|macro|CCW_CMD_READ
mdefine_line|#define CCW_CMD_READ&t;&t;0x02
DECL|macro|CCW_CMD_SET_EXTENDED
mdefine_line|#define CCW_CMD_SET_EXTENDED&t;0xc3
DECL|macro|CCW_CMD_PREPARE
mdefine_line|#define CCW_CMD_PREPARE&t;&t;0xe3
DECL|macro|CTC_PROTO_S390
mdefine_line|#define CTC_PROTO_S390          0
DECL|macro|CTC_PROTO_LINUX
mdefine_line|#define CTC_PROTO_LINUX         1
DECL|macro|CTC_PROTO_LINUX_TTY
mdefine_line|#define CTC_PROTO_LINUX_TTY     2
DECL|macro|CTC_PROTO_OS390
mdefine_line|#define CTC_PROTO_OS390         3
DECL|macro|CTC_PROTO_MAX
mdefine_line|#define CTC_PROTO_MAX           3
DECL|macro|CTC_BUFSIZE_LIMIT
mdefine_line|#define CTC_BUFSIZE_LIMIT       65535
DECL|macro|CTC_BUFSIZE_DEFAULT
mdefine_line|#define CTC_BUFSIZE_DEFAULT     32768
DECL|macro|CTC_TIMEOUT_5SEC
mdefine_line|#define CTC_TIMEOUT_5SEC        5000
DECL|macro|CTC_INITIAL_BLOCKLEN
mdefine_line|#define CTC_INITIAL_BLOCKLEN    2
DECL|macro|READ
mdefine_line|#define READ&t;&t;&t;0
DECL|macro|WRITE
mdefine_line|#define WRITE&t;&t;&t;1
"&f;"
multiline_comment|/**&n; * Enum for classifying detected devices.&n; */
DECL|enum|channel_types
r_enum
id|channel_types
(brace
multiline_comment|/**&n;&t; * Device is not a channel.&n;&t; */
DECL|enumerator|channel_type_none
id|channel_type_none
comma
multiline_comment|/**&n;&t; * Device is a channel, but we don&squot;t know&n;&t; * anything about it.&n;&t; */
DECL|enumerator|channel_type_unknown
id|channel_type_unknown
comma
multiline_comment|/**&n;&t; * Device is a CTC/A.&n;&t; */
DECL|enumerator|channel_type_ctca
id|channel_type_ctca
comma
multiline_comment|/**&n;&t; * Device is a ESCON channel.&n;&t; */
DECL|enumerator|channel_type_escon
id|channel_type_escon
comma
multiline_comment|/**&n;&t; * Device is an unsupported model.&n;&t; */
DECL|enumerator|channel_type_unsupported
id|channel_type_unsupported
)brace
suffix:semicolon
DECL|typedef|channel_type_t
r_typedef
r_enum
id|channel_types
id|channel_type_t
suffix:semicolon
macro_line|#ifndef CTC_CHANDEV
DECL|variable|ctc_no_auto
r_static
r_int
id|ctc_no_auto
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/**&n; * If running on 64 bit, this must be changed. XXX Why? (bird)&n; */
DECL|typedef|intparm_t
r_typedef
r_int
r_int
id|intparm_t
suffix:semicolon
macro_line|#ifndef CTC_CHANDEV
multiline_comment|/**&n; * Definition of a per device parameter block&n; */
DECL|macro|MAX_PARAM_NAME_LEN
mdefine_line|#define MAX_PARAM_NAME_LEN 11
DECL|struct|param_t
r_typedef
r_struct
id|param_t
(brace
DECL|member|next
r_struct
id|param_t
op_star
id|next
suffix:semicolon
DECL|member|read_dev
r_int
id|read_dev
suffix:semicolon
DECL|member|write_dev
r_int
id|write_dev
suffix:semicolon
DECL|member|proto
id|__u16
id|proto
suffix:semicolon
DECL|member|name
r_char
id|name
(braket
id|MAX_PARAM_NAME_LEN
)braket
suffix:semicolon
DECL|typedef|param
)brace
id|param
suffix:semicolon
DECL|variable|params
r_static
id|param
op_star
id|params
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
"&f;"
r_typedef
r_struct
(brace
DECL|member|maxmulti
r_int
r_int
id|maxmulti
suffix:semicolon
DECL|member|maxcqueue
r_int
r_int
id|maxcqueue
suffix:semicolon
DECL|member|doios_single
r_int
r_int
id|doios_single
suffix:semicolon
DECL|member|doios_multi
r_int
r_int
id|doios_multi
suffix:semicolon
DECL|member|txlen
r_int
r_int
id|txlen
suffix:semicolon
DECL|member|tx_time
r_int
r_int
id|tx_time
suffix:semicolon
DECL|member|send_stamp
r_struct
id|timeval
id|send_stamp
suffix:semicolon
DECL|typedef|ctc_profile
)brace
id|ctc_profile
suffix:semicolon
multiline_comment|/**&n; * Definition of one channel&n; */
DECL|struct|channel_t
r_typedef
r_struct
id|channel_t
(brace
multiline_comment|/**&n;&t; * Pointer to next channel in list.&n;&t; */
DECL|member|next
r_struct
id|channel_t
op_star
id|next
suffix:semicolon
DECL|member|devno
id|__u16
id|devno
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
multiline_comment|/**&n;&t; * Type of this channel.&n;&t; * CTC/A or Escon for valid channels.&n;&t; */
DECL|member|type
id|channel_type_t
id|type
suffix:semicolon
multiline_comment|/**&n;&t; * Misc. flags. See CHANNEL_FLAGS_... below&n;&t; */
DECL|member|flags
id|__u32
id|flags
suffix:semicolon
multiline_comment|/**&n;&t; * The protocol of this channel&n;&t; */
DECL|member|protocol
id|__u16
id|protocol
suffix:semicolon
multiline_comment|/**&n;&t; * I/O and irq related stuff&n;&t; */
DECL|member|ccw
id|ccw1_t
op_star
id|ccw
suffix:semicolon
DECL|member|devstat
id|devstat_t
op_star
id|devstat
suffix:semicolon
multiline_comment|/**&n;&t; * Bottom half task queue.&n;&t; */
DECL|member|tq
r_struct
id|tq_struct
id|tq
suffix:semicolon
multiline_comment|/**&n;&t; * RX/TX buffer size&n;&t; */
DECL|member|max_bufsize
r_int
id|max_bufsize
suffix:semicolon
multiline_comment|/**&n;&t; * Transmit/Receive buffer.&n;&t; */
DECL|member|trans_skb
r_struct
id|sk_buff
op_star
id|trans_skb
suffix:semicolon
multiline_comment|/**&n;&t; * Universal I/O queue.&n;&t; */
DECL|member|io_queue
r_struct
id|sk_buff_head
id|io_queue
suffix:semicolon
multiline_comment|/**&n;&t; * TX queue for collecting skb&squot;s during busy.&n;&t; */
DECL|member|collect_queue
r_struct
id|sk_buff_head
id|collect_queue
suffix:semicolon
multiline_comment|/**&n;&t; * Amount of data in collect_queue.&n;&t; */
DECL|member|collect_len
r_int
id|collect_len
suffix:semicolon
multiline_comment|/**&n;&t; * spinlock for collect_queue and collect_len&n;&t; */
DECL|member|collect_lock
id|spinlock_t
id|collect_lock
suffix:semicolon
multiline_comment|/**&n;&t; * Timer for detecting unresposive&n;&t; * I/O operations.&n;&t; */
DECL|member|timer
id|fsm_timer
id|timer
suffix:semicolon
multiline_comment|/**&n;&t; * Retry counter for misc. operations.&n;&t; */
DECL|member|retry
r_int
id|retry
suffix:semicolon
multiline_comment|/**&n;&t; * The finite state machine of this channel&n;&t; */
DECL|member|fsm
id|fsm_instance
op_star
id|fsm
suffix:semicolon
multiline_comment|/**&n;&t; * The corresponding net_device this channel&n;&t; * belongs to.&n;&t; */
DECL|member|netdev
id|net_device
op_star
id|netdev
suffix:semicolon
DECL|member|prof
id|ctc_profile
id|prof
suffix:semicolon
DECL|member|trans_skb_data
r_int
r_char
op_star
id|trans_skb_data
suffix:semicolon
DECL|typedef|channel
)brace
id|channel
suffix:semicolon
DECL|macro|CHANNEL_FLAGS_READ
mdefine_line|#define CHANNEL_FLAGS_READ            0
DECL|macro|CHANNEL_FLAGS_WRITE
mdefine_line|#define CHANNEL_FLAGS_WRITE           1
DECL|macro|CHANNEL_FLAGS_INUSE
mdefine_line|#define CHANNEL_FLAGS_INUSE           2
DECL|macro|CHANNEL_FLAGS_BUFSIZE_CHANGED
mdefine_line|#define CHANNEL_FLAGS_BUFSIZE_CHANGED 4
DECL|macro|CHANNEL_FLAGS_RWMASK
mdefine_line|#define CHANNEL_FLAGS_RWMASK 1
DECL|macro|CHANNEL_DIRECTION
mdefine_line|#define CHANNEL_DIRECTION(f) (f &amp; CHANNEL_FLAGS_RWMASK)
multiline_comment|/**&n; * Linked list of all detected channels.&n; */
DECL|variable|channels
r_static
id|channel
op_star
id|channels
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef CTC_CHANDEV
DECL|variable|activated
r_static
r_int
id|activated
suffix:semicolon
macro_line|#endif
DECL|struct|ctc_priv_t
r_typedef
r_struct
id|ctc_priv_t
(brace
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= 0x02032D
DECL|member|tbusy
r_int
r_int
id|tbusy
suffix:semicolon
macro_line|#endif
multiline_comment|/**&n;&t; * The finite state machine of this interface.&n;&t; */
DECL|member|fsm
id|fsm_instance
op_star
id|fsm
suffix:semicolon
multiline_comment|/**&n;&t; * The protocol of this device&n;&t; */
DECL|member|protocol
id|__u16
id|protocol
suffix:semicolon
DECL|member|channel
id|channel
op_star
id|channel
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|proc_dentry
r_struct
id|proc_dir_entry
op_star
id|proc_dentry
suffix:semicolon
DECL|member|proc_stat_entry
r_struct
id|proc_dir_entry
op_star
id|proc_stat_entry
suffix:semicolon
DECL|member|proc_ctrl_entry
r_struct
id|proc_dir_entry
op_star
id|proc_ctrl_entry
suffix:semicolon
DECL|member|proc_registered
r_int
id|proc_registered
suffix:semicolon
DECL|typedef|ctc_priv
)brace
id|ctc_priv
suffix:semicolon
multiline_comment|/**&n; * Definition of our link level header.&n; */
DECL|struct|ll_header_t
r_typedef
r_struct
id|ll_header_t
(brace
DECL|member|length
id|__u16
id|length
suffix:semicolon
DECL|member|type
id|__u16
id|type
suffix:semicolon
DECL|member|unused
id|__u16
id|unused
suffix:semicolon
DECL|typedef|ll_header
)brace
id|ll_header
suffix:semicolon
DECL|macro|LL_HEADER_LENGTH
mdefine_line|#define LL_HEADER_LENGTH (sizeof(ll_header))
multiline_comment|/**&n; * Compatibility macros for busy handling&n; * of network devices.&n; */
macro_line|#if LINUX_VERSION_CODE &lt; 0x02032D
DECL|function|ctc_clear_busy
r_static
id|__inline__
r_void
id|ctc_clear_busy
c_func
(paren
id|net_device
op_star
id|dev
)paren
(brace
id|clear_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|dev-&gt;tbusy
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
)brace
DECL|function|ctc_test_and_set_busy
r_static
id|__inline__
r_int
id|ctc_test_and_set_busy
c_func
(paren
id|net_device
op_star
id|dev
)paren
(brace
r_return
id|test_and_set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|dev-&gt;tbusy
)paren
suffix:semicolon
)brace
DECL|macro|SET_DEVICE_START
mdefine_line|#define SET_DEVICE_START(device, value) dev-&gt;start = value
macro_line|#else
DECL|function|ctc_clear_busy
r_static
id|__inline__
r_void
id|ctc_clear_busy
c_func
(paren
id|net_device
op_star
id|dev
)paren
(brace
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
(paren
(paren
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|tbusy
)paren
)paren
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|function|ctc_test_and_set_busy
r_static
id|__inline__
r_int
id|ctc_test_and_set_busy
c_func
(paren
id|net_device
op_star
id|dev
)paren
(brace
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
(paren
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|tbusy
)paren
suffix:semicolon
)brace
DECL|macro|SET_DEVICE_START
mdefine_line|#define SET_DEVICE_START(device, value)
macro_line|#endif
multiline_comment|/**&n; * Print Banner.&n; */
DECL|function|print_banner
r_static
r_void
id|print_banner
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|printed
op_assign
l_int|0
suffix:semicolon
r_char
id|vbuf
(braket
)braket
op_assign
l_string|&quot;$Revision: 1.51 $&quot;
suffix:semicolon
r_char
op_star
id|version
op_assign
id|vbuf
suffix:semicolon
r_if
c_cond
(paren
id|printed
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|version
op_assign
id|strchr
c_func
(paren
id|version
comma
l_char|&squot;:&squot;
)paren
)paren
)paren
(brace
r_char
op_star
id|p
op_assign
id|strchr
c_func
(paren
id|version
op_plus
l_int|1
comma
l_char|&squot;$&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
op_star
id|p
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_else
id|version
op_assign
l_string|&quot; ??? &quot;
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;CTC driver Version%s initialized&bslash;n&quot;
comma
id|version
)paren
suffix:semicolon
id|printed
op_assign
l_int|1
suffix:semicolon
)brace
"&f;"
macro_line|#ifndef CTC_CHANDEV
multiline_comment|/**&n; * Return type of a detected device.&n; */
DECL|function|channel_type
r_static
id|channel_type_t
id|channel_type
(paren
id|senseid_t
op_star
id|id
)paren
(brace
id|channel_type_t
id|type
op_assign
id|channel_type_none
suffix:semicolon
r_switch
c_cond
(paren
id|id-&gt;cu_type
)paren
(brace
r_case
l_int|0x3088
suffix:colon
r_switch
c_cond
(paren
id|id-&gt;cu_model
)paren
(brace
r_case
l_int|0x08
suffix:colon
multiline_comment|/**&n;&t;&t;&t;&t;&t; * 3088-08 = CTCA&n;&t;&t;&t;&t;&t; */
id|type
op_assign
id|channel_type_ctca
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x1F
suffix:colon
multiline_comment|/**&n;&t;&t;&t;&t;&t; * 3088-1F = ESCON channel&n;&t;&t;&t;&t;&t; */
id|type
op_assign
id|channel_type_escon
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/**&n;&t;&t;&t;&t;&t; * 3088-01 = P390 OSA emulation&n;&t;&t;&t;&t;&t; */
r_case
l_int|0x01
suffix:colon
multiline_comment|/* fall thru */
multiline_comment|/**&n;&t;&t;&t;&t;&t; * 3088-60 = OSA/2 adapter&n;&t;&t;&t;&t;&t; */
r_case
l_int|0x60
suffix:colon
multiline_comment|/* fall thru */
multiline_comment|/**&n;&t;&t;&t;&t;&t; * 3088-61 = CISCO 7206 CLAW proto&n;&t;&t;&t;&t;&t; * on ESCON&n;&t;&t;&t;&t;&t; */
r_case
l_int|0x61
suffix:colon
multiline_comment|/* fall thru */
multiline_comment|/**&n;&t;&t;&t;&t;&t; * 3088-62 = OSA/D device&n;&t;&t;&t;&t;&t; */
r_case
l_int|0x62
suffix:colon
id|type
op_assign
id|channel_type_unsupported
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|type
op_assign
id|channel_type_unknown
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;channel: Unknown model found &quot;
l_string|&quot;3088-%02x&bslash;n&quot;
comma
id|id-&gt;cu_model
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|type
op_assign
id|channel_type_none
suffix:semicolon
)brace
r_return
id|type
suffix:semicolon
)brace
macro_line|#endif
"&f;"
multiline_comment|/**&n; * States of the interface statemachine.&n; */
DECL|enum|dev_states
r_enum
id|dev_states
(brace
DECL|enumerator|DEV_STATE_STOPPED
id|DEV_STATE_STOPPED
comma
DECL|enumerator|DEV_STATE_STARTWAIT_RXTX
id|DEV_STATE_STARTWAIT_RXTX
comma
DECL|enumerator|DEV_STATE_STARTWAIT_RX
id|DEV_STATE_STARTWAIT_RX
comma
DECL|enumerator|DEV_STATE_STARTWAIT_TX
id|DEV_STATE_STARTWAIT_TX
comma
DECL|enumerator|DEV_STATE_STOPWAIT_RXTX
id|DEV_STATE_STOPWAIT_RXTX
comma
DECL|enumerator|DEV_STATE_STOPWAIT_RX
id|DEV_STATE_STOPWAIT_RX
comma
DECL|enumerator|DEV_STATE_STOPWAIT_TX
id|DEV_STATE_STOPWAIT_TX
comma
DECL|enumerator|DEV_STATE_RUNNING
id|DEV_STATE_RUNNING
comma
multiline_comment|/**&n;&t; * MUST be always the last element!!&n;&t; */
DECL|enumerator|NR_DEV_STATES
id|NR_DEV_STATES
)brace
suffix:semicolon
DECL|variable|dev_state_names
r_static
r_const
r_char
op_star
id|dev_state_names
(braket
)braket
op_assign
(brace
l_string|&quot;Stopped&quot;
comma
l_string|&quot;StartWait RXTX&quot;
comma
l_string|&quot;StartWait RX&quot;
comma
l_string|&quot;StartWait TX&quot;
comma
l_string|&quot;StopWait RXTX&quot;
comma
l_string|&quot;StopWait RX&quot;
comma
l_string|&quot;StopWait TX&quot;
comma
l_string|&quot;Running&quot;
comma
)brace
suffix:semicolon
multiline_comment|/**&n; * Events of the interface statemachine.&n; */
DECL|enum|dev_events
r_enum
id|dev_events
(brace
DECL|enumerator|DEV_EVENT_START
id|DEV_EVENT_START
comma
DECL|enumerator|DEV_EVENT_STOP
id|DEV_EVENT_STOP
comma
DECL|enumerator|DEV_EVENT_RXUP
id|DEV_EVENT_RXUP
comma
DECL|enumerator|DEV_EVENT_TXUP
id|DEV_EVENT_TXUP
comma
DECL|enumerator|DEV_EVENT_RXDOWN
id|DEV_EVENT_RXDOWN
comma
DECL|enumerator|DEV_EVENT_TXDOWN
id|DEV_EVENT_TXDOWN
comma
multiline_comment|/**&n;&t; * MUST be always the last element!!&n;&t; */
DECL|enumerator|NR_DEV_EVENTS
id|NR_DEV_EVENTS
)brace
suffix:semicolon
DECL|variable|dev_event_names
r_static
r_const
r_char
op_star
id|dev_event_names
(braket
)braket
op_assign
(brace
l_string|&quot;Start&quot;
comma
l_string|&quot;Stop&quot;
comma
l_string|&quot;RX up&quot;
comma
l_string|&quot;TX up&quot;
comma
l_string|&quot;RX down&quot;
comma
l_string|&quot;TX down&quot;
comma
)brace
suffix:semicolon
"&f;"
multiline_comment|/**&n; * Events of the channel statemachine&n; */
DECL|enum|ch_events
r_enum
id|ch_events
(brace
multiline_comment|/**&n;&t; * Events, representing return code of&n;&t; * I/O operations (do_IO, halt_IO et al.)&n;&t; */
DECL|enumerator|CH_EVENT_IO_SUCCESS
id|CH_EVENT_IO_SUCCESS
comma
DECL|enumerator|CH_EVENT_IO_EBUSY
id|CH_EVENT_IO_EBUSY
comma
DECL|enumerator|CH_EVENT_IO_ENODEV
id|CH_EVENT_IO_ENODEV
comma
DECL|enumerator|CH_EVENT_IO_EIO
id|CH_EVENT_IO_EIO
comma
DECL|enumerator|CH_EVENT_IO_UNKNOWN
id|CH_EVENT_IO_UNKNOWN
comma
DECL|enumerator|CH_EVENT_ATTNBUSY
id|CH_EVENT_ATTNBUSY
comma
DECL|enumerator|CH_EVENT_ATTN
id|CH_EVENT_ATTN
comma
DECL|enumerator|CH_EVENT_BUSY
id|CH_EVENT_BUSY
comma
multiline_comment|/**&n;&t; * Events, representing unit-check&n;&t; */
DECL|enumerator|CH_EVENT_UC_RCRESET
id|CH_EVENT_UC_RCRESET
comma
DECL|enumerator|CH_EVENT_UC_RSRESET
id|CH_EVENT_UC_RSRESET
comma
DECL|enumerator|CH_EVENT_UC_TXTIMEOUT
id|CH_EVENT_UC_TXTIMEOUT
comma
DECL|enumerator|CH_EVENT_UC_TXPARITY
id|CH_EVENT_UC_TXPARITY
comma
DECL|enumerator|CH_EVENT_UC_HWFAIL
id|CH_EVENT_UC_HWFAIL
comma
DECL|enumerator|CH_EVENT_UC_RXPARITY
id|CH_EVENT_UC_RXPARITY
comma
DECL|enumerator|CH_EVENT_UC_ZERO
id|CH_EVENT_UC_ZERO
comma
DECL|enumerator|CH_EVENT_UC_UNKNOWN
id|CH_EVENT_UC_UNKNOWN
comma
multiline_comment|/**&n;&t; * Events, representing subchannel-check&n;&t; */
DECL|enumerator|CH_EVENT_SC_UNKNOWN
id|CH_EVENT_SC_UNKNOWN
comma
multiline_comment|/**&n;&t; * Events, representing machine checks&n;&t; */
DECL|enumerator|CH_EVENT_MC_FAIL
id|CH_EVENT_MC_FAIL
comma
DECL|enumerator|CH_EVENT_MC_GOOD
id|CH_EVENT_MC_GOOD
comma
multiline_comment|/**&n;&t; * Event, representing normal IRQ&n;&t; */
DECL|enumerator|CH_EVENT_IRQ
id|CH_EVENT_IRQ
comma
DECL|enumerator|CH_EVENT_FINSTAT
id|CH_EVENT_FINSTAT
comma
multiline_comment|/**&n;&t; * Event, representing timer expiry.&n;&t; */
DECL|enumerator|CH_EVENT_TIMER
id|CH_EVENT_TIMER
comma
multiline_comment|/**&n;&t; * Events, representing commands from upper levels.&n;&t; */
DECL|enumerator|CH_EVENT_START
id|CH_EVENT_START
comma
DECL|enumerator|CH_EVENT_STOP
id|CH_EVENT_STOP
comma
multiline_comment|/**&n;&t; * MUST be always the last element!!&n;&t; */
DECL|enumerator|NR_CH_EVENTS
id|NR_CH_EVENTS
comma
)brace
suffix:semicolon
DECL|variable|ch_event_names
r_static
r_const
r_char
op_star
id|ch_event_names
(braket
)braket
op_assign
(brace
l_string|&quot;do_IO success&quot;
comma
l_string|&quot;do_IO busy&quot;
comma
l_string|&quot;do_IO enodev&quot;
comma
l_string|&quot;do_IO ioerr&quot;
comma
l_string|&quot;do_IO unknown&quot;
comma
l_string|&quot;Status ATTN &amp; BUSY&quot;
comma
l_string|&quot;Status ATTN&quot;
comma
l_string|&quot;Status BUSY&quot;
comma
l_string|&quot;Unit check remote reset&quot;
comma
l_string|&quot;Unit check remote system reset&quot;
comma
l_string|&quot;Unit check TX timeout&quot;
comma
l_string|&quot;Unit check TX parity&quot;
comma
l_string|&quot;Unit check Hardware failure&quot;
comma
l_string|&quot;Unit check RX parity&quot;
comma
l_string|&quot;Unit check ZERO&quot;
comma
l_string|&quot;Unit check Unknown&quot;
comma
l_string|&quot;SubChannel check Unknown&quot;
comma
l_string|&quot;Machine check failure&quot;
comma
l_string|&quot;Machine check operational&quot;
comma
l_string|&quot;IRQ normal&quot;
comma
l_string|&quot;IRQ final&quot;
comma
l_string|&quot;Timer&quot;
comma
l_string|&quot;Start&quot;
comma
l_string|&quot;Stop&quot;
comma
)brace
suffix:semicolon
multiline_comment|/**&n; * States of the channel statemachine.&n; */
DECL|enum|ch_states
r_enum
id|ch_states
(brace
multiline_comment|/**&n;&t; * Channel not assigned to any device,&n;&t; * initial state, direction invalid&n;&t; */
DECL|enumerator|CH_STATE_IDLE
id|CH_STATE_IDLE
comma
multiline_comment|/**&n;&t; * Channel assigned but not operating&n;&t; */
DECL|enumerator|CH_STATE_STOPPED
id|CH_STATE_STOPPED
comma
DECL|enumerator|CH_STATE_STARTWAIT
id|CH_STATE_STARTWAIT
comma
DECL|enumerator|CH_STATE_STARTRETRY
id|CH_STATE_STARTRETRY
comma
DECL|enumerator|CH_STATE_SETUPWAIT
id|CH_STATE_SETUPWAIT
comma
DECL|enumerator|CH_STATE_RXINIT
id|CH_STATE_RXINIT
comma
DECL|enumerator|CH_STATE_TXINIT
id|CH_STATE_TXINIT
comma
DECL|enumerator|CH_STATE_RX
id|CH_STATE_RX
comma
DECL|enumerator|CH_STATE_TX
id|CH_STATE_TX
comma
DECL|enumerator|CH_STATE_RXIDLE
id|CH_STATE_RXIDLE
comma
DECL|enumerator|CH_STATE_TXIDLE
id|CH_STATE_TXIDLE
comma
DECL|enumerator|CH_STATE_RXERR
id|CH_STATE_RXERR
comma
DECL|enumerator|CH_STATE_TXERR
id|CH_STATE_TXERR
comma
DECL|enumerator|CH_STATE_TERM
id|CH_STATE_TERM
comma
DECL|enumerator|CH_STATE_DTERM
id|CH_STATE_DTERM
comma
DECL|enumerator|CH_STATE_NOTOP
id|CH_STATE_NOTOP
comma
multiline_comment|/**&n;&t; * MUST be always the last element!!&n;&t; */
DECL|enumerator|NR_CH_STATES
id|NR_CH_STATES
comma
)brace
suffix:semicolon
DECL|variable|ch_state_names
r_static
r_const
r_char
op_star
id|ch_state_names
(braket
)braket
op_assign
(brace
l_string|&quot;Idle&quot;
comma
l_string|&quot;Stopped&quot;
comma
l_string|&quot;StartWait&quot;
comma
l_string|&quot;StartRetry&quot;
comma
l_string|&quot;SetupWait&quot;
comma
l_string|&quot;RX init&quot;
comma
l_string|&quot;TX init&quot;
comma
l_string|&quot;RX&quot;
comma
l_string|&quot;TX&quot;
comma
l_string|&quot;RX idle&quot;
comma
l_string|&quot;TX idle&quot;
comma
l_string|&quot;RX error&quot;
comma
l_string|&quot;TX error&quot;
comma
l_string|&quot;Terminating&quot;
comma
l_string|&quot;Restarting&quot;
comma
l_string|&quot;Not operational&quot;
comma
)brace
suffix:semicolon
"&f;"
macro_line|#ifdef DEBUG
multiline_comment|/**&n; * Dump header and first 16 bytes of an sk_buff for debugging purposes.&n; *&n; * @param skb    The sk_buff to dump.&n; * @param offset Offset relative to skb-data, where to start the dump.&n; */
DECL|function|ctc_dump_skb
r_static
r_void
id|ctc_dump_skb
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|offset
)paren
(brace
r_int
r_char
op_star
id|p
op_assign
id|skb-&gt;data
suffix:semicolon
id|__u16
id|bl
suffix:semicolon
id|ll_header
op_star
id|header
suffix:semicolon
r_int
id|i
suffix:semicolon
id|p
op_add_assign
id|offset
suffix:semicolon
id|bl
op_assign
op_star
(paren
(paren
id|__u16
op_star
)paren
id|p
)paren
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
id|header
op_assign
(paren
id|ll_header
op_star
)paren
id|p
suffix:semicolon
id|p
op_sub_assign
l_int|2
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;dump:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;blocklen=%d %04x&bslash;n&quot;
comma
id|bl
comma
id|bl
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;h-&gt;length=%d %04x&bslash;n&quot;
comma
id|header-&gt;length
comma
id|header-&gt;length
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;h-&gt;type=%04x&bslash;n&quot;
comma
id|header-&gt;type
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;h-&gt;unused=%04x&bslash;n&quot;
comma
id|header-&gt;unused
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bl
OG
l_int|16
)paren
id|bl
op_assign
l_int|16
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;data: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bl
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%02x%s&quot;
comma
op_star
id|p
op_increment
comma
(paren
id|i
op_mod
l_int|16
)paren
ques
c_cond
l_string|&quot; &quot;
suffix:colon
l_string|&quot;&bslash;n&lt;7&gt;&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**&n; * Unpack a just received skb and hand it over to&n; * upper layers.&n; *&n; * @param ch The channel where this skb has been received.&n; * @param pskb The received skb.&n; */
DECL|function|ctc_unpack_skb
r_static
id|__inline__
r_void
id|ctc_unpack_skb
c_func
(paren
id|channel
op_star
id|ch
comma
r_struct
id|sk_buff
op_star
id|pskb
)paren
(brace
id|net_device
op_star
id|dev
op_assign
id|ch-&gt;netdev
suffix:semicolon
id|ctc_priv
op_star
id|privptr
op_assign
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|__u16
id|len
op_assign
op_star
(paren
(paren
id|__u16
op_star
)paren
id|pskb-&gt;data
)paren
suffix:semicolon
id|skb_put
c_func
(paren
id|pskb
comma
l_int|2
op_plus
id|LL_HEADER_LENGTH
)paren
suffix:semicolon
id|skb_pull
c_func
(paren
id|pskb
comma
l_int|2
)paren
suffix:semicolon
id|pskb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|pskb-&gt;ip_summed
op_assign
id|CHECKSUM_UNNECESSARY
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|ll_header
op_star
id|header
op_assign
(paren
id|ll_header
op_star
)paren
id|pskb-&gt;data
suffix:semicolon
id|skb_pull
c_func
(paren
id|pskb
comma
id|LL_HEADER_LENGTH
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ch-&gt;protocol
op_eq
id|CTC_PROTO_S390
)paren
op_logical_and
(paren
id|header-&gt;type
op_ne
id|ETH_P_IP
)paren
)paren
(brace
multiline_comment|/**&n;&t;&t;&t; * Check packet type only if we stick strictly&n;&t;&t;&t; * to S/390&squot;s protocol of OS390. This only&n;&t;&t;&t; * supports IP. Otherwise allow any packet&n;&t;&t;&t; * type.&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s Illegal packet type 0x%04x &quot;
l_string|&quot;received, dropping&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|header-&gt;type
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|ctc_dump_skb
c_func
(paren
id|pskb
comma
op_minus
l_int|6
)paren
suffix:semicolon
macro_line|#endif
id|privptr-&gt;stats.rx_dropped
op_increment
suffix:semicolon
id|privptr-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pskb-&gt;protocol
op_assign
id|ntohs
c_func
(paren
id|header-&gt;type
)paren
suffix:semicolon
id|header-&gt;length
op_sub_assign
id|LL_HEADER_LENGTH
suffix:semicolon
r_if
c_cond
(paren
(paren
id|header-&gt;length
op_eq
l_int|0
)paren
op_logical_or
(paren
id|header-&gt;length
OG
id|skb_tailroom
c_func
(paren
id|pskb
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s Illegal packet size %d &quot;
l_string|&quot;received (MTU=%d), &quot;
l_string|&quot;dropping&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|header-&gt;length
comma
id|dev-&gt;mtu
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|ctc_dump_skb
c_func
(paren
id|pskb
comma
op_minus
l_int|6
)paren
suffix:semicolon
macro_line|#endif
id|privptr-&gt;stats.rx_dropped
op_increment
suffix:semicolon
id|privptr-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|header-&gt;length
OG
id|skb_tailroom
c_func
(paren
id|pskb
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s Illegal packet size %d &quot;
l_string|&quot;(beyond the end of received data), &quot;
l_string|&quot;dropping&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|header-&gt;length
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|ctc_dump_skb
c_func
(paren
id|pskb
comma
op_minus
l_int|6
)paren
suffix:semicolon
macro_line|#endif
id|privptr-&gt;stats.rx_dropped
op_increment
suffix:semicolon
id|privptr-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb_put
c_func
(paren
id|pskb
comma
id|header-&gt;length
)paren
suffix:semicolon
id|pskb-&gt;mac.raw
op_assign
id|pskb-&gt;data
suffix:semicolon
id|len
op_sub_assign
(paren
id|LL_HEADER_LENGTH
op_plus
id|header-&gt;length
)paren
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|pskb-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s Out of memory in ctc_unpack_skb&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|privptr-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|pskb-&gt;len
)paren
comma
id|pskb-&gt;data
comma
id|pskb-&gt;len
)paren
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
id|skb-&gt;dev
op_assign
id|pskb-&gt;dev
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|pskb-&gt;protocol
suffix:semicolon
id|pskb-&gt;ip_summed
op_assign
id|CHECKSUM_UNNECESSARY
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;protocol
op_eq
id|CTC_PROTO_LINUX_TTY
)paren
id|ctc_tty_netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
r_else
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|privptr-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|privptr-&gt;stats.rx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|skb_pull
c_func
(paren
id|pskb
comma
id|header-&gt;length
)paren
suffix:semicolon
id|skb_put
c_func
(paren
id|pskb
comma
id|LL_HEADER_LENGTH
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/**&n; * Bottom half routine.&n; *&n; * @param ch The channel to work on.&n; */
DECL|function|ctc_bh
r_static
r_void
id|ctc_bh
c_func
(paren
id|channel
op_star
id|ch
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|ch-&gt;io_queue
)paren
)paren
)paren
id|ctc_unpack_skb
c_func
(paren
id|ch
comma
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Check return code of a preceeding do_IO, halt_IO etc...&n; *&n; * @param ch          The channel, the error belongs to.&n; * @param return_code The error code to inspect.&n; */
DECL|function|ccw_check_return_code
r_static
r_void
r_inline
id|ccw_check_return_code
(paren
id|channel
op_star
id|ch
comma
r_int
id|return_code
)paren
(brace
r_switch
c_cond
(paren
id|return_code
)paren
(brace
r_case
l_int|0
suffix:colon
id|fsm_event
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_EVENT_IO_SUCCESS
comma
id|ch
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|EBUSY
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ch-%04x: Busy !&bslash;n&quot;
comma
id|ch-&gt;devno
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_EVENT_IO_EBUSY
comma
id|ch
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|ENODEV
suffix:colon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;ch-%04x: Invalid device called for IO&bslash;n&quot;
comma
id|ch-&gt;devno
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_EVENT_IO_ENODEV
comma
id|ch
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|EIO
suffix:colon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;ch-%04x: Status pending... &bslash;n&quot;
comma
id|ch-&gt;devno
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_EVENT_IO_EIO
comma
id|ch
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;ch-%04x: Unknown error in do_IO %04x&bslash;n&quot;
comma
id|ch-&gt;devno
comma
id|return_code
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_EVENT_IO_UNKNOWN
comma
id|ch
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * Check sense of a unit check.&n; *&n; * @param ch    The channel, the sense code belongs to.&n; * @param sense The sense code to inspect.&n; */
DECL|function|ccw_unit_check
r_static
r_void
r_inline
id|ccw_unit_check
(paren
id|channel
op_star
id|ch
comma
r_int
r_char
id|sense
)paren
(brace
r_if
c_cond
(paren
id|sense
op_amp
id|SNS0_INTERVENTION_REQ
)paren
(brace
r_if
c_cond
(paren
id|sense
op_amp
l_int|0x01
)paren
(brace
r_if
c_cond
(paren
id|ch-&gt;protocol
op_ne
id|CTC_PROTO_LINUX_TTY
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ch-%04x: Interface disc. or Sel. reset &quot;
l_string|&quot;(remote)&bslash;n&quot;
comma
id|ch-&gt;devno
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_EVENT_UC_RCRESET
comma
id|ch
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ch-%04x: System reset (remote)&bslash;n&quot;
comma
id|ch-&gt;devno
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_EVENT_UC_RSRESET
comma
id|ch
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|sense
op_amp
id|SNS0_EQUIPMENT_CHECK
)paren
(brace
r_if
c_cond
(paren
id|sense
op_amp
id|SNS0_BUS_OUT_CHECK
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ch-%04x: Hardware malfunction (remote)&bslash;n&quot;
comma
id|ch-&gt;devno
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_EVENT_UC_HWFAIL
comma
id|ch
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ch-%04x: Read-data parity error (remote)&bslash;n&quot;
comma
id|ch-&gt;devno
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_EVENT_UC_RXPARITY
comma
id|ch
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|sense
op_amp
id|SNS0_BUS_OUT_CHECK
)paren
(brace
r_if
c_cond
(paren
id|sense
op_amp
l_int|0x04
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ch-%04x: Data-streaming timeout)&bslash;n&quot;
comma
id|ch-&gt;devno
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_EVENT_UC_TXTIMEOUT
comma
id|ch
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ch-%04x: Data-transfer parity error&bslash;n&quot;
comma
id|ch-&gt;devno
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_EVENT_UC_TXPARITY
comma
id|ch
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|sense
op_amp
id|SNS0_CMD_REJECT
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ch-%04x: Command reject&bslash;n&quot;
comma
id|ch-&gt;devno
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sense
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ch-%04x: Unit check ZERO&bslash;n&quot;
comma
id|ch-&gt;devno
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_EVENT_UC_ZERO
comma
id|ch
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ch-%04x: Unit Check with sense code: %02x&bslash;n&quot;
comma
id|ch-&gt;devno
comma
id|sense
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_EVENT_UC_UNKNOWN
comma
id|ch
)paren
suffix:semicolon
)brace
)brace
DECL|function|ctc_purge_skb_queue
r_static
r_void
id|ctc_purge_skb_queue
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|q
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
id|q
)paren
)paren
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|skb-&gt;users
)paren
suffix:semicolon
id|dev_kfree_skb_irq
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
DECL|function|ctc_checkalloc_buffer
r_static
id|__inline__
r_int
id|ctc_checkalloc_buffer
c_func
(paren
id|channel
op_star
id|ch
comma
r_int
id|warn
)paren
(brace
r_if
c_cond
(paren
(paren
id|ch-&gt;trans_skb
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|ch-&gt;flags
op_amp
id|CHANNEL_FLAGS_BUFSIZE_CHANGED
)paren
)paren
(brace
r_if
c_cond
(paren
id|ch-&gt;trans_skb
op_ne
l_int|NULL
)paren
id|dev_kfree_skb
c_func
(paren
id|ch-&gt;trans_skb
)paren
suffix:semicolon
id|clear_normalized_cda
c_func
(paren
op_amp
id|ch-&gt;ccw
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|ch-&gt;trans_skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|ch-&gt;max_bufsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;trans_skb
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|warn
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ch-%04x: Couldn&squot;t alloc %s trans_skb&bslash;n&quot;
comma
id|ch-&gt;devno
comma
(paren
id|CHANNEL_DIRECTION
c_func
(paren
id|ch-&gt;flags
)paren
op_eq
id|READ
)paren
ques
c_cond
l_string|&quot;RX&quot;
suffix:colon
l_string|&quot;TX&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|ch-&gt;ccw
(braket
l_int|1
)braket
dot
id|count
op_assign
id|ch-&gt;max_bufsize
suffix:semicolon
r_if
c_cond
(paren
id|set_normalized_cda
c_func
(paren
op_amp
id|ch-&gt;ccw
(braket
l_int|1
)braket
comma
id|virt_to_phys
c_func
(paren
id|ch-&gt;trans_skb-&gt;data
)paren
)paren
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|ch-&gt;trans_skb
)paren
suffix:semicolon
id|ch-&gt;trans_skb
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|warn
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ch-%04x: set_normalized_cda for %s &quot;
l_string|&quot;trans_skb failed, dropping packets&bslash;n&quot;
comma
id|ch-&gt;devno
comma
(paren
id|CHANNEL_DIRECTION
c_func
(paren
id|ch-&gt;flags
)paren
op_eq
id|READ
)paren
ques
c_cond
l_string|&quot;RX&quot;
suffix:colon
l_string|&quot;TX&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|ch-&gt;ccw
(braket
l_int|1
)braket
dot
id|count
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;trans_skb_data
op_assign
id|ch-&gt;trans_skb-&gt;data
suffix:semicolon
id|ch-&gt;flags
op_and_assign
op_complement
id|CHANNEL_FLAGS_BUFSIZE_CHANGED
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Dummy NOP action for statemachines&n; */
DECL|function|fsm_action_nop
r_static
r_void
id|fsm_action_nop
c_func
(paren
id|fsm_instance
op_star
id|fi
comma
r_int
id|event
comma
r_void
op_star
id|arg
)paren
(brace
)brace
"&f;"
multiline_comment|/**&n; * Actions for channel - statemachines.&n; *****************************************************************************/
multiline_comment|/**&n; * Normal data has been send. Free the corresponding&n; * skb (it&squot;s in io_queue), reset dev-&gt;tbusy and&n; * revert to idle state.&n; *&n; * @param fi    An instance of a channel statemachine.&n; * @param event The event, just happened.&n; * @param arg   Generic pointer, casted from channel * upon call.&n; */
DECL|function|ch_action_txdone
r_static
r_void
id|ch_action_txdone
c_func
(paren
id|fsm_instance
op_star
id|fi
comma
r_int
id|event
comma
r_void
op_star
id|arg
)paren
(brace
id|channel
op_star
id|ch
op_assign
(paren
id|channel
op_star
)paren
id|arg
suffix:semicolon
id|net_device
op_star
id|dev
op_assign
id|ch-&gt;netdev
suffix:semicolon
id|ctc_priv
op_star
id|privptr
op_assign
id|dev-&gt;priv
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|first
op_assign
l_int|1
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|timeval
id|done_stamp
op_assign
id|xtime
suffix:semicolon
r_int
r_int
id|duration
op_assign
(paren
id|done_stamp.tv_sec
op_minus
id|ch-&gt;prof.send_stamp.tv_sec
)paren
op_star
l_int|1000000
op_plus
id|done_stamp.tv_usec
op_minus
id|ch-&gt;prof.send_stamp.tv_usec
suffix:semicolon
r_if
c_cond
(paren
id|duration
OG
id|ch-&gt;prof.tx_time
)paren
id|ch-&gt;prof.tx_time
op_assign
id|duration
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;devstat-&gt;rescnt
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: TX not complete, remaining %d bytes&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ch-&gt;devstat-&gt;rescnt
)paren
suffix:semicolon
id|fsm_deltimer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|ch-&gt;io_queue
)paren
)paren
)paren
(brace
id|privptr-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|privptr-&gt;stats.tx_bytes
op_add_assign
id|skb-&gt;len
op_minus
id|LL_HEADER_LENGTH
suffix:semicolon
r_if
c_cond
(paren
id|first
)paren
(brace
id|privptr-&gt;stats.tx_bytes
op_add_assign
l_int|2
suffix:semicolon
id|first
op_assign
l_int|0
suffix:semicolon
)brace
id|atomic_dec
c_func
(paren
op_amp
id|skb-&gt;users
)paren
suffix:semicolon
id|dev_kfree_skb_irq
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|ch-&gt;collect_lock
)paren
suffix:semicolon
id|clear_normalized_cda
c_func
(paren
op_amp
id|ch-&gt;ccw
(braket
l_int|4
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;collect_len
OG
l_int|0
)paren
(brace
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|ctc_checkalloc_buffer
c_func
(paren
id|ch
comma
l_int|1
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|ch-&gt;collect_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ch-&gt;trans_skb-&gt;tail
op_assign
id|ch-&gt;trans_skb-&gt;data
op_assign
id|ch-&gt;trans_skb_data
suffix:semicolon
id|ch-&gt;trans_skb-&gt;len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;prof.maxmulti
OL
(paren
id|ch-&gt;collect_len
op_plus
l_int|2
)paren
)paren
id|ch-&gt;prof.maxmulti
op_assign
id|ch-&gt;collect_len
op_plus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;prof.maxcqueue
OL
id|skb_queue_len
c_func
(paren
op_amp
id|ch-&gt;collect_queue
)paren
)paren
id|ch-&gt;prof.maxcqueue
op_assign
id|skb_queue_len
c_func
(paren
op_amp
id|ch-&gt;collect_queue
)paren
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|1
)braket
dot
id|count
op_assign
id|ch-&gt;collect_len
op_plus
l_int|2
suffix:semicolon
op_star
(paren
(paren
id|__u16
op_star
)paren
id|skb_put
c_func
(paren
id|ch-&gt;trans_skb
comma
l_int|2
)paren
)paren
op_assign
id|ch-&gt;collect_len
op_plus
l_int|2
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|ch-&gt;collect_queue
)paren
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|ch-&gt;trans_skb
comma
id|skb-&gt;len
)paren
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|privptr-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|privptr-&gt;stats.tx_bytes
op_add_assign
id|skb-&gt;len
op_minus
id|LL_HEADER_LENGTH
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|skb-&gt;users
)paren
suffix:semicolon
id|dev_kfree_skb_irq
c_func
(paren
id|skb
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
id|ch-&gt;collect_len
op_assign
l_int|0
suffix:semicolon
id|fsm_addtimer
c_func
(paren
op_amp
id|ch-&gt;timer
comma
id|CTC_TIMEOUT_5SEC
comma
id|CH_EVENT_TIMER
comma
id|ch
)paren
suffix:semicolon
id|ch-&gt;prof.send_stamp
op_assign
id|xtime
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ccw[1].cda = %08x&bslash;n&quot;
comma
id|ch-&gt;ccw
(braket
l_int|1
)braket
dot
id|cda
)paren
suffix:semicolon
macro_line|#endif
id|rc
op_assign
id|do_IO
c_func
(paren
id|ch-&gt;irq
comma
op_amp
id|ch-&gt;ccw
(braket
l_int|0
)braket
comma
(paren
id|intparm_t
)paren
id|ch
comma
l_int|0xff
comma
l_int|0
)paren
suffix:semicolon
id|ch-&gt;prof.doios_multi
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
id|privptr-&gt;stats.tx_dropped
op_add_assign
id|i
suffix:semicolon
id|privptr-&gt;stats.tx_errors
op_add_assign
id|i
suffix:semicolon
id|fsm_deltimer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|ccw_check_return_code
c_func
(paren
id|ch
comma
id|rc
)paren
suffix:semicolon
)brace
)brace
r_else
id|fsm_newstate
c_func
(paren
id|fi
comma
id|CH_STATE_TXIDLE
)paren
suffix:semicolon
id|ctc_clear_busy
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ch-&gt;collect_lock
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Initial data is sent.&n; * Notify device statemachine that we are up and&n; * running.&n; *&n; * @param fi    An instance of a channel statemachine.&n; * @param event The event, just happened.&n; * @param arg   Generic pointer, casted from channel * upon call.&n; */
DECL|function|ch_action_txidle
r_static
r_void
id|ch_action_txidle
c_func
(paren
id|fsm_instance
op_star
id|fi
comma
r_int
id|event
comma
r_void
op_star
id|arg
)paren
(brace
id|channel
op_star
id|ch
op_assign
(paren
id|channel
op_star
)paren
id|arg
suffix:semicolon
id|fsm_deltimer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|fsm_newstate
c_func
(paren
id|fi
comma
id|CH_STATE_TXIDLE
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
(paren
(paren
id|ctc_priv
op_star
)paren
id|ch-&gt;netdev-&gt;priv
)paren
op_member_access_from_pointer
id|fsm
comma
id|DEV_EVENT_TXUP
comma
id|ch-&gt;netdev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Got normal data, check for sanity, queue it up, allocate new buffer&n; * trigger bottom half, and initiate next read.&n; *&n; * @param fi    An instance of a channel statemachine.&n; * @param event The event, just happened.&n; * @param arg   Generic pointer, casted from channel * upon call.&n; */
DECL|function|ch_action_rx
r_static
r_void
id|ch_action_rx
c_func
(paren
id|fsm_instance
op_star
id|fi
comma
r_int
id|event
comma
r_void
op_star
id|arg
)paren
(brace
id|channel
op_star
id|ch
op_assign
(paren
id|channel
op_star
)paren
id|arg
suffix:semicolon
id|net_device
op_star
id|dev
op_assign
id|ch-&gt;netdev
suffix:semicolon
id|ctc_priv
op_star
id|privptr
op_assign
id|dev-&gt;priv
suffix:semicolon
r_int
id|len
op_assign
id|ch-&gt;max_bufsize
op_minus
id|ch-&gt;devstat-&gt;rescnt
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|ch-&gt;trans_skb
suffix:semicolon
id|__u16
id|block_len
op_assign
op_star
(paren
(paren
id|__u16
op_star
)paren
id|skb-&gt;data
)paren
suffix:semicolon
r_int
id|check_len
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|fsm_deltimer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|8
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: got packet with length %d &lt; 8&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|len
)paren
suffix:semicolon
id|privptr-&gt;stats.rx_dropped
op_increment
suffix:semicolon
id|privptr-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
id|ch-&gt;max_bufsize
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: got packet with length %d &gt; %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|len
comma
id|ch-&gt;max_bufsize
)paren
suffix:semicolon
id|privptr-&gt;stats.rx_dropped
op_increment
suffix:semicolon
id|privptr-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
multiline_comment|/**&n;&t; * VM TCP seems to have a bug sending 2 trailing bytes of garbage.&n;&t; */
r_switch
c_cond
(paren
id|ch-&gt;protocol
)paren
(brace
r_case
id|CTC_PROTO_S390
suffix:colon
r_case
id|CTC_PROTO_OS390
suffix:colon
id|check_len
op_assign
id|block_len
op_plus
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|check_len
op_assign
id|block_len
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|len
OL
id|block_len
)paren
op_logical_or
(paren
id|len
OG
id|check_len
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: got block length %d != rx length %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|block_len
comma
id|len
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|ctc_dump_skb
c_func
(paren
id|skb
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
op_star
(paren
(paren
id|__u16
op_star
)paren
id|skb-&gt;data
)paren
op_assign
id|len
suffix:semicolon
id|privptr-&gt;stats.rx_dropped
op_increment
suffix:semicolon
id|privptr-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
id|block_len
op_sub_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|block_len
OG
l_int|0
)paren
(brace
op_star
(paren
(paren
id|__u16
op_star
)paren
id|skb-&gt;data
)paren
op_assign
id|block_len
suffix:semicolon
id|ctc_unpack_skb
c_func
(paren
id|ch
comma
id|skb
)paren
suffix:semicolon
)brace
id|again
suffix:colon
id|skb-&gt;data
op_assign
id|skb-&gt;tail
op_assign
id|ch-&gt;trans_skb_data
suffix:semicolon
id|skb-&gt;len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ctc_checkalloc_buffer
c_func
(paren
id|ch
comma
l_int|1
)paren
)paren
r_return
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|1
)braket
dot
id|count
op_assign
id|ch-&gt;max_bufsize
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ccw[1].cda = %08x&bslash;n&quot;
comma
id|ch-&gt;ccw
(braket
l_int|1
)braket
dot
id|cda
)paren
suffix:semicolon
macro_line|#endif
id|rc
op_assign
id|do_IO
c_func
(paren
id|ch-&gt;irq
comma
op_amp
id|ch-&gt;ccw
(braket
l_int|0
)braket
comma
(paren
id|intparm_t
)paren
id|ch
comma
l_int|0xff
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
id|ccw_check_return_code
c_func
(paren
id|ch
comma
id|rc
)paren
suffix:semicolon
)brace
r_static
r_void
id|ch_action_rxidle
c_func
(paren
id|fsm_instance
op_star
id|fi
comma
r_int
id|event
comma
r_void
op_star
id|arg
)paren
suffix:semicolon
multiline_comment|/**&n; * Initialize connection by sending a __u16 of value 0.&n; *&n; * @param fi    An instance of a channel statemachine.&n; * @param event The event, just happened.&n; * @param arg   Generic pointer, casted from channel * upon call.&n; */
DECL|function|ch_action_firstio
r_static
r_void
id|ch_action_firstio
c_func
(paren
id|fsm_instance
op_star
id|fi
comma
r_int
id|event
comma
r_void
op_star
id|arg
)paren
(brace
id|channel
op_star
id|ch
op_assign
(paren
id|channel
op_star
)paren
id|arg
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|fsm_getstate
c_func
(paren
id|fi
)paren
op_eq
id|CH_STATE_TXIDLE
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ch-%04x: remote side issued READ?, &quot;
l_string|&quot;init ...&bslash;n&quot;
comma
id|ch-&gt;devno
)paren
suffix:semicolon
id|fsm_deltimer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctc_checkalloc_buffer
c_func
(paren
id|ch
comma
l_int|1
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fsm_getstate
c_func
(paren
id|fi
)paren
op_eq
id|CH_STATE_SETUPWAIT
)paren
op_logical_and
(paren
id|ch-&gt;protocol
op_eq
id|CTC_PROTO_OS390
)paren
)paren
(brace
multiline_comment|/* OS/390 resp. z/OS */
r_if
c_cond
(paren
id|CHANNEL_DIRECTION
c_func
(paren
id|ch-&gt;flags
)paren
op_eq
id|READ
)paren
(brace
op_star
(paren
(paren
id|__u16
op_star
)paren
id|ch-&gt;trans_skb-&gt;data
)paren
op_assign
id|CTC_INITIAL_BLOCKLEN
suffix:semicolon
id|fsm_addtimer
c_func
(paren
op_amp
id|ch-&gt;timer
comma
id|CTC_TIMEOUT_5SEC
comma
id|CH_EVENT_TIMER
comma
id|ch
)paren
suffix:semicolon
id|ch_action_rxidle
c_func
(paren
id|fi
comma
id|event
comma
id|arg
)paren
suffix:semicolon
)brace
r_else
(brace
id|net_device
op_star
id|dev
op_assign
id|ch-&gt;netdev
suffix:semicolon
id|fsm_newstate
c_func
(paren
id|fi
comma
id|CH_STATE_TXIDLE
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
(paren
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|fsm
comma
id|DEV_EVENT_TXUP
comma
id|dev
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/**&n;&t; * Don&#xfffd;t setup a timer for receiving the initial RX frame&n;&t; * if in compatibility mode, since VM TCP delays the initial&n;&t; * frame until it has some data to send.&n;&t; */
r_if
c_cond
(paren
(paren
id|CHANNEL_DIRECTION
c_func
(paren
id|ch-&gt;flags
)paren
op_eq
id|WRITE
)paren
op_logical_or
(paren
id|ch-&gt;protocol
op_ne
id|CTC_PROTO_S390
)paren
)paren
id|fsm_addtimer
c_func
(paren
op_amp
id|ch-&gt;timer
comma
id|CTC_TIMEOUT_5SEC
comma
id|CH_EVENT_TIMER
comma
id|ch
)paren
suffix:semicolon
op_star
(paren
(paren
id|__u16
op_star
)paren
id|ch-&gt;trans_skb-&gt;data
)paren
op_assign
id|CTC_INITIAL_BLOCKLEN
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|1
)braket
dot
id|count
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Transfer only length */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ccw[1].cda = %08x&bslash;n&quot;
comma
id|ch-&gt;ccw
(braket
l_int|1
)braket
dot
id|cda
)paren
suffix:semicolon
macro_line|#endif
id|fsm_newstate
c_func
(paren
id|fi
comma
(paren
id|CHANNEL_DIRECTION
c_func
(paren
id|ch-&gt;flags
)paren
op_eq
id|READ
)paren
ques
c_cond
id|CH_STATE_RXINIT
suffix:colon
id|CH_STATE_TXINIT
)paren
suffix:semicolon
id|rc
op_assign
id|do_IO
c_func
(paren
id|ch-&gt;irq
comma
op_amp
id|ch-&gt;ccw
(braket
l_int|0
)braket
comma
(paren
id|intparm_t
)paren
id|ch
comma
l_int|0xff
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
id|fsm_deltimer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|fsm_newstate
c_func
(paren
id|fi
comma
id|CH_STATE_SETUPWAIT
)paren
suffix:semicolon
id|ccw_check_return_code
c_func
(paren
id|ch
comma
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/**&n;&t; * If in compatibility mode since we don&#xfffd;t setup a timer, we&n;&t; * also signal RX channel up immediately. This enables us&n;&t; * to send packets early which in turn usually triggers some&n;&t; * reply from VM TCP which brings up the RX channel to it&#xfffd;s&n;&t; * final state.&n;&t; */
r_if
c_cond
(paren
(paren
id|CHANNEL_DIRECTION
c_func
(paren
id|ch-&gt;flags
)paren
op_eq
id|READ
)paren
op_logical_and
(paren
id|ch-&gt;protocol
op_eq
id|CTC_PROTO_S390
)paren
)paren
(brace
id|net_device
op_star
id|dev
op_assign
id|ch-&gt;netdev
suffix:semicolon
id|fsm_event
c_func
(paren
(paren
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|fsm
comma
id|DEV_EVENT_RXUP
comma
id|dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * Got initial data, check it. If OK,&n; * notify device statemachine that we are up and&n; * running.&n; *&n; * @param fi    An instance of a channel statemachine.&n; * @param event The event, just happened.&n; * @param arg   Generic pointer, casted from channel * upon call.&n; */
DECL|function|ch_action_rxidle
r_static
r_void
id|ch_action_rxidle
c_func
(paren
id|fsm_instance
op_star
id|fi
comma
r_int
id|event
comma
r_void
op_star
id|arg
)paren
(brace
id|channel
op_star
id|ch
op_assign
(paren
id|channel
op_star
)paren
id|arg
suffix:semicolon
id|net_device
op_star
id|dev
op_assign
id|ch-&gt;netdev
suffix:semicolon
id|__u16
id|buflen
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|fsm_deltimer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|buflen
op_assign
op_star
(paren
(paren
id|__u16
op_star
)paren
id|ch-&gt;trans_skb-&gt;data
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Initial RX count %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|buflen
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|buflen
op_ge
id|CTC_INITIAL_BLOCKLEN
)paren
(brace
r_if
c_cond
(paren
id|ctc_checkalloc_buffer
c_func
(paren
id|ch
comma
l_int|1
)paren
)paren
r_return
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|1
)braket
dot
id|count
op_assign
id|ch-&gt;max_bufsize
suffix:semicolon
id|fsm_newstate
c_func
(paren
id|fi
comma
id|CH_STATE_RXIDLE
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ccw[1].cda = %08x&bslash;n&quot;
comma
id|ch-&gt;ccw
(braket
l_int|1
)braket
dot
id|cda
)paren
suffix:semicolon
macro_line|#endif
id|rc
op_assign
id|do_IO
c_func
(paren
id|ch-&gt;irq
comma
op_amp
id|ch-&gt;ccw
(braket
l_int|0
)braket
comma
(paren
id|intparm_t
)paren
id|ch
comma
l_int|0xff
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
id|fsm_newstate
c_func
(paren
id|fi
comma
id|CH_STATE_RXINIT
)paren
suffix:semicolon
id|ccw_check_return_code
c_func
(paren
id|ch
comma
id|rc
)paren
suffix:semicolon
)brace
r_else
id|fsm_event
c_func
(paren
(paren
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|fsm
comma
id|DEV_EVENT_RXUP
comma
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Initial RX count %d not %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|buflen
comma
id|CTC_INITIAL_BLOCKLEN
)paren
suffix:semicolon
id|ch_action_firstio
c_func
(paren
id|fi
comma
id|event
comma
id|arg
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * Set channel into extended mode.&n; *&n; * @param fi    An instance of a channel statemachine.&n; * @param event The event, just happened.&n; * @param arg   Generic pointer, casted from channel * upon call.&n; */
DECL|function|ch_action_setmode
r_static
r_void
id|ch_action_setmode
c_func
(paren
id|fsm_instance
op_star
id|fi
comma
r_int
id|event
comma
r_void
op_star
id|arg
)paren
(brace
id|channel
op_star
id|ch
op_assign
(paren
id|channel
op_star
)paren
id|arg
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_int
r_int
id|saveflags
suffix:semicolon
id|fsm_deltimer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|fsm_addtimer
c_func
(paren
op_amp
id|ch-&gt;timer
comma
id|CTC_TIMEOUT_5SEC
comma
id|CH_EVENT_TIMER
comma
id|ch
)paren
suffix:semicolon
id|fsm_newstate
c_func
(paren
id|fi
comma
id|CH_STATE_SETUPWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event
op_eq
id|CH_EVENT_TIMER
)paren
id|s390irq_spin_lock_irqsave
c_func
(paren
id|ch-&gt;irq
comma
id|saveflags
)paren
suffix:semicolon
id|rc
op_assign
id|do_IO
c_func
(paren
id|ch-&gt;irq
comma
op_amp
id|ch-&gt;ccw
(braket
l_int|6
)braket
comma
(paren
id|intparm_t
)paren
id|ch
comma
l_int|0xff
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event
op_eq
id|CH_EVENT_TIMER
)paren
id|s390irq_spin_unlock_irqrestore
c_func
(paren
id|ch-&gt;irq
comma
id|saveflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
id|fsm_deltimer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|fsm_newstate
c_func
(paren
id|fi
comma
id|CH_STATE_STARTWAIT
)paren
suffix:semicolon
id|ccw_check_return_code
c_func
(paren
id|ch
comma
id|rc
)paren
suffix:semicolon
)brace
r_else
id|ch-&gt;retry
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Setup channel.&n; *&n; * @param fi    An instance of a channel statemachine.&n; * @param event The event, just happened.&n; * @param arg   Generic pointer, casted from channel * upon call.&n; */
DECL|function|ch_action_start
r_static
r_void
id|ch_action_start
c_func
(paren
id|fsm_instance
op_star
id|fi
comma
r_int
id|event
comma
r_void
op_star
id|arg
)paren
(brace
id|channel
op_star
id|ch
op_assign
(paren
id|channel
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|saveflags
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|net_device
op_star
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ch_action_start ch=NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ch-&gt;netdev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ch_action_start dev=NULL, irq=%d&bslash;n&quot;
comma
id|ch-&gt;irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dev
op_assign
id|ch-&gt;netdev
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: %s channel start&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
id|CHANNEL_DIRECTION
c_func
(paren
id|ch-&gt;flags
)paren
op_eq
id|READ
)paren
ques
c_cond
l_string|&quot;RX&quot;
suffix:colon
l_string|&quot;TX&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ch-&gt;trans_skb
op_ne
l_int|NULL
)paren
(brace
id|clear_normalized_cda
c_func
(paren
op_amp
id|ch-&gt;ccw
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|ch-&gt;trans_skb
)paren
suffix:semicolon
id|ch-&gt;trans_skb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CHANNEL_DIRECTION
c_func
(paren
id|ch-&gt;flags
)paren
op_eq
id|READ
)paren
(brace
id|ch-&gt;ccw
(braket
l_int|1
)braket
dot
id|cmd_code
op_assign
id|CCW_CMD_READ
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|1
)braket
dot
id|flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|1
)braket
dot
id|count
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ch-&gt;ccw
(braket
l_int|1
)braket
dot
id|cmd_code
op_assign
id|CCW_CMD_WRITE
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|1
)braket
dot
id|flags
op_assign
id|CCW_FLAG_SLI
op_or
id|CCW_FLAG_CC
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|1
)braket
dot
id|count
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctc_checkalloc_buffer
c_func
(paren
id|ch
comma
l_int|0
)paren
)paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: Could not allocate %s trans_skb, delaying &quot;
l_string|&quot;allocation until first transfer&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
id|CHANNEL_DIRECTION
c_func
(paren
id|ch-&gt;flags
)paren
op_eq
id|READ
)paren
ques
c_cond
l_string|&quot;RX&quot;
suffix:colon
l_string|&quot;TX&quot;
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= 0x020400
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ch-&gt;tq.list
)paren
suffix:semicolon
macro_line|#else
id|ch-&gt;tq.next
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
id|ch-&gt;tq.sync
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;tq.routine
op_assign
(paren
r_void
op_star
)paren
(paren
r_void
op_star
)paren
id|ctc_bh
suffix:semicolon
id|ch-&gt;tq.data
op_assign
id|ch
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|0
)braket
dot
id|cmd_code
op_assign
id|CCW_CMD_PREPARE
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|0
)braket
dot
id|flags
op_assign
id|CCW_FLAG_SLI
op_or
id|CCW_FLAG_CC
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|0
)braket
dot
id|count
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|0
)braket
dot
id|cda
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|2
)braket
dot
id|cmd_code
op_assign
id|CCW_CMD_NOOP
suffix:semicolon
multiline_comment|/* jointed CE + DE */
id|ch-&gt;ccw
(braket
l_int|2
)braket
dot
id|flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|2
)braket
dot
id|count
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|2
)braket
dot
id|cda
op_assign
l_int|0
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|ch-&gt;ccw
(braket
l_int|3
)braket
comma
op_amp
id|ch-&gt;ccw
(braket
l_int|0
)braket
comma
r_sizeof
(paren
id|ccw1_t
)paren
op_star
l_int|3
)paren
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|4
)braket
dot
id|cda
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|4
)braket
dot
id|flags
op_and_assign
op_complement
id|CCW_FLAG_IDA
suffix:semicolon
id|fsm_newstate
c_func
(paren
id|fi
comma
id|CH_STATE_STARTWAIT
)paren
suffix:semicolon
id|fsm_addtimer
c_func
(paren
op_amp
id|ch-&gt;timer
comma
l_int|1000
comma
id|CH_EVENT_TIMER
comma
id|ch
)paren
suffix:semicolon
id|s390irq_spin_lock_irqsave
c_func
(paren
id|ch-&gt;irq
comma
id|saveflags
)paren
suffix:semicolon
id|rc
op_assign
id|halt_IO
c_func
(paren
id|ch-&gt;irq
comma
(paren
id|intparm_t
)paren
id|ch
comma
l_int|0
)paren
suffix:semicolon
id|s390irq_spin_unlock_irqrestore
c_func
(paren
id|ch-&gt;irq
comma
id|saveflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
id|fsm_deltimer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|ccw_check_return_code
c_func
(paren
id|ch
comma
id|rc
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ctc: %s(): leaving&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/**&n; * Shutdown a channel.&n; *&n; * @param fi    An instance of a channel statemachine.&n; * @param event The event, just happened.&n; * @param arg   Generic pointer, casted from channel * upon call.&n; */
DECL|function|ch_action_haltio
r_static
r_void
id|ch_action_haltio
c_func
(paren
id|fsm_instance
op_star
id|fi
comma
r_int
id|event
comma
r_void
op_star
id|arg
)paren
(brace
id|channel
op_star
id|ch
op_assign
(paren
id|channel
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|saveflags
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_int
id|oldstate
suffix:semicolon
id|fsm_deltimer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|fsm_addtimer
c_func
(paren
op_amp
id|ch-&gt;timer
comma
id|CTC_TIMEOUT_5SEC
comma
id|CH_EVENT_TIMER
comma
id|ch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event
op_eq
id|CH_EVENT_STOP
)paren
id|s390irq_spin_lock_irqsave
c_func
(paren
id|ch-&gt;irq
comma
id|saveflags
)paren
suffix:semicolon
id|oldstate
op_assign
id|fsm_getstate
c_func
(paren
id|fi
)paren
suffix:semicolon
id|fsm_newstate
c_func
(paren
id|fi
comma
id|CH_STATE_TERM
)paren
suffix:semicolon
id|rc
op_assign
id|halt_IO
(paren
id|ch-&gt;irq
comma
(paren
id|intparm_t
)paren
id|ch
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event
op_eq
id|CH_EVENT_STOP
)paren
id|s390irq_spin_unlock_irqrestore
c_func
(paren
id|ch-&gt;irq
comma
id|saveflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
id|fsm_deltimer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|fsm_newstate
c_func
(paren
id|fi
comma
id|oldstate
)paren
suffix:semicolon
id|ccw_check_return_code
c_func
(paren
id|ch
comma
id|rc
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * A channel has successfully been halted.&n; * Cleanup it&squot;s queue and notify interface statemachine.&n; *&n; * @param fi    An instance of a channel statemachine.&n; * @param event The event, just happened.&n; * @param arg   Generic pointer, casted from channel * upon call.&n; */
DECL|function|ch_action_stopped
r_static
r_void
id|ch_action_stopped
c_func
(paren
id|fsm_instance
op_star
id|fi
comma
r_int
id|event
comma
r_void
op_star
id|arg
)paren
(brace
id|channel
op_star
id|ch
op_assign
(paren
id|channel
op_star
)paren
id|arg
suffix:semicolon
id|net_device
op_star
id|dev
op_assign
id|ch-&gt;netdev
suffix:semicolon
id|fsm_deltimer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|fsm_newstate
c_func
(paren
id|fi
comma
id|CH_STATE_STOPPED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;trans_skb
op_ne
l_int|NULL
)paren
(brace
id|clear_normalized_cda
c_func
(paren
op_amp
id|ch-&gt;ccw
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|ch-&gt;trans_skb
)paren
suffix:semicolon
id|ch-&gt;trans_skb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CHANNEL_DIRECTION
c_func
(paren
id|ch-&gt;flags
)paren
op_eq
id|READ
)paren
(brace
id|skb_queue_purge
c_func
(paren
op_amp
id|ch-&gt;io_queue
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
(paren
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|fsm
comma
id|DEV_EVENT_RXDOWN
comma
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|ctc_purge_skb_queue
c_func
(paren
op_amp
id|ch-&gt;io_queue
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|ch-&gt;collect_lock
)paren
suffix:semicolon
id|ctc_purge_skb_queue
c_func
(paren
op_amp
id|ch-&gt;collect_queue
)paren
suffix:semicolon
id|ch-&gt;collect_len
op_assign
l_int|0
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ch-&gt;collect_lock
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
(paren
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|fsm
comma
id|DEV_EVENT_TXDOWN
comma
id|dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * A stop command from device statemachine arrived and we are in&n; * not operational mode. Set state to stopped.&n; *&n; * @param fi    An instance of a channel statemachine.&n; * @param event The event, just happened.&n; * @param arg   Generic pointer, casted from channel * upon call.&n; */
DECL|function|ch_action_stop
r_static
r_void
id|ch_action_stop
c_func
(paren
id|fsm_instance
op_star
id|fi
comma
r_int
id|event
comma
r_void
op_star
id|arg
)paren
(brace
id|fsm_newstate
c_func
(paren
id|fi
comma
id|CH_STATE_STOPPED
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * A machine check for no path, not operational status or gone device has&n; * happened.&n; * Cleanup queue and notify interface statemachine.&n; *&n; * @param fi    An instance of a channel statemachine.&n; * @param event The event, just happened.&n; * @param arg   Generic pointer, casted from channel * upon call.&n; */
DECL|function|ch_action_fail
r_static
r_void
id|ch_action_fail
c_func
(paren
id|fsm_instance
op_star
id|fi
comma
r_int
id|event
comma
r_void
op_star
id|arg
)paren
(brace
id|channel
op_star
id|ch
op_assign
(paren
id|channel
op_star
)paren
id|arg
suffix:semicolon
id|net_device
op_star
id|dev
op_assign
id|ch-&gt;netdev
suffix:semicolon
id|fsm_deltimer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|fsm_newstate
c_func
(paren
id|fi
comma
id|CH_STATE_NOTOP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CHANNEL_DIRECTION
c_func
(paren
id|ch-&gt;flags
)paren
op_eq
id|READ
)paren
(brace
id|skb_queue_purge
c_func
(paren
op_amp
id|ch-&gt;io_queue
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
(paren
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|fsm
comma
id|DEV_EVENT_RXDOWN
comma
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|ctc_purge_skb_queue
c_func
(paren
op_amp
id|ch-&gt;io_queue
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|ch-&gt;collect_lock
)paren
suffix:semicolon
id|ctc_purge_skb_queue
c_func
(paren
op_amp
id|ch-&gt;collect_queue
)paren
suffix:semicolon
id|ch-&gt;collect_len
op_assign
l_int|0
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ch-&gt;collect_lock
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
(paren
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|fsm
comma
id|DEV_EVENT_TXDOWN
comma
id|dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * Handle error during setup of channel.&n; *&n; * @param fi    An instance of a channel statemachine.&n; * @param event The event, just happened.&n; * @param arg   Generic pointer, casted from channel * upon call.&n; */
DECL|function|ch_action_setuperr
r_static
r_void
id|ch_action_setuperr
c_func
(paren
id|fsm_instance
op_star
id|fi
comma
r_int
id|event
comma
r_void
op_star
id|arg
)paren
(brace
id|channel
op_star
id|ch
op_assign
(paren
id|channel
op_star
)paren
id|arg
suffix:semicolon
id|net_device
op_star
id|dev
op_assign
id|ch-&gt;netdev
suffix:semicolon
multiline_comment|/**&n;&t; * Special case: Got UC_RCRESET on setmode.&n;&t; * This means that remote side isn&squot;t setup. In this case&n;&t; * simply retry after some 10 secs...&n;&t; */
r_if
c_cond
(paren
(paren
id|fsm_getstate
c_func
(paren
id|fi
)paren
op_eq
id|CH_STATE_SETUPWAIT
)paren
op_logical_and
(paren
(paren
id|event
op_eq
id|CH_EVENT_UC_RCRESET
)paren
op_logical_or
(paren
id|event
op_eq
id|CH_EVENT_UC_RSRESET
)paren
)paren
)paren
(brace
id|fsm_newstate
c_func
(paren
id|fi
comma
id|CH_STATE_STARTRETRY
)paren
suffix:semicolon
id|fsm_deltimer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|fsm_addtimer
c_func
(paren
op_amp
id|ch-&gt;timer
comma
id|CTC_TIMEOUT_5SEC
comma
id|CH_EVENT_TIMER
comma
id|ch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CHANNEL_DIRECTION
c_func
(paren
id|ch-&gt;flags
)paren
op_eq
id|READ
)paren
(brace
r_int
id|rc
op_assign
id|halt_IO
(paren
id|ch-&gt;irq
comma
(paren
id|intparm_t
)paren
id|ch
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
id|ccw_check_return_code
c_func
(paren
id|ch
comma
id|rc
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Error %s during %s channel setup state=%s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ch_event_names
(braket
id|event
)braket
comma
(paren
id|CHANNEL_DIRECTION
c_func
(paren
id|ch-&gt;flags
)paren
op_eq
id|READ
)paren
ques
c_cond
l_string|&quot;RX&quot;
suffix:colon
l_string|&quot;TX&quot;
comma
id|fsm_getstate_str
c_func
(paren
id|fi
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CHANNEL_DIRECTION
c_func
(paren
id|ch-&gt;flags
)paren
op_eq
id|READ
)paren
(brace
id|fsm_newstate
c_func
(paren
id|fi
comma
id|CH_STATE_RXERR
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
(paren
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|fsm
comma
id|DEV_EVENT_RXDOWN
comma
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|fsm_newstate
c_func
(paren
id|fi
comma
id|CH_STATE_TXERR
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
(paren
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|fsm
comma
id|DEV_EVENT_TXDOWN
comma
id|dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * Restart a channel after an error.&n; *&n; * @param fi    An instance of a channel statemachine.&n; * @param event The event, just happened.&n; * @param arg   Generic pointer, casted from channel * upon call.&n; */
DECL|function|ch_action_restart
r_static
r_void
id|ch_action_restart
c_func
(paren
id|fsm_instance
op_star
id|fi
comma
r_int
id|event
comma
r_void
op_star
id|arg
)paren
(brace
r_int
r_int
id|saveflags
suffix:semicolon
r_int
id|oldstate
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|channel
op_star
id|ch
op_assign
(paren
id|channel
op_star
)paren
id|arg
suffix:semicolon
id|net_device
op_star
id|dev
op_assign
id|ch-&gt;netdev
suffix:semicolon
id|fsm_deltimer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: %s channel restart&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
id|CHANNEL_DIRECTION
c_func
(paren
id|ch-&gt;flags
)paren
op_eq
id|READ
)paren
ques
c_cond
l_string|&quot;RX&quot;
suffix:colon
l_string|&quot;TX&quot;
)paren
suffix:semicolon
id|fsm_addtimer
c_func
(paren
op_amp
id|ch-&gt;timer
comma
id|CTC_TIMEOUT_5SEC
comma
id|CH_EVENT_TIMER
comma
id|ch
)paren
suffix:semicolon
id|oldstate
op_assign
id|fsm_getstate
c_func
(paren
id|fi
)paren
suffix:semicolon
id|fsm_newstate
c_func
(paren
id|fi
comma
id|CH_STATE_STARTWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event
op_eq
id|CH_EVENT_TIMER
)paren
id|s390irq_spin_lock_irqsave
c_func
(paren
id|ch-&gt;irq
comma
id|saveflags
)paren
suffix:semicolon
id|rc
op_assign
id|halt_IO
(paren
id|ch-&gt;irq
comma
(paren
id|intparm_t
)paren
id|ch
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event
op_eq
id|CH_EVENT_TIMER
)paren
id|s390irq_spin_unlock_irqrestore
c_func
(paren
id|ch-&gt;irq
comma
id|saveflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
id|fsm_deltimer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|fsm_newstate
c_func
(paren
id|fi
comma
id|oldstate
)paren
suffix:semicolon
id|ccw_check_return_code
c_func
(paren
id|ch
comma
id|rc
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * Handle error during RX initial handshake (exchange of&n; * 0-length block header)&n; *&n; * @param fi    An instance of a channel statemachine.&n; * @param event The event, just happened.&n; * @param arg   Generic pointer, casted from channel * upon call.&n; */
DECL|function|ch_action_rxiniterr
r_static
r_void
id|ch_action_rxiniterr
c_func
(paren
id|fsm_instance
op_star
id|fi
comma
r_int
id|event
comma
r_void
op_star
id|arg
)paren
(brace
id|channel
op_star
id|ch
op_assign
(paren
id|channel
op_star
)paren
id|arg
suffix:semicolon
id|net_device
op_star
id|dev
op_assign
id|ch-&gt;netdev
suffix:semicolon
r_if
c_cond
(paren
id|event
op_eq
id|CH_EVENT_TIMER
)paren
(brace
id|fsm_deltimer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Timeout during RX init handshake&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;retry
op_increment
OL
l_int|3
)paren
id|ch_action_restart
c_func
(paren
id|fi
comma
id|event
comma
id|arg
)paren
suffix:semicolon
r_else
(brace
id|fsm_newstate
c_func
(paren
id|fi
comma
id|CH_STATE_RXERR
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
(paren
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|fsm
comma
id|DEV_EVENT_RXDOWN
comma
id|dev
)paren
suffix:semicolon
)brace
)brace
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Error during RX init handshake&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Notify device statemachine if we gave up initialization&n; * of RX channel.&n; *&n; * @param fi    An instance of a channel statemachine.&n; * @param event The event, just happened.&n; * @param arg   Generic pointer, casted from channel * upon call.&n; */
DECL|function|ch_action_rxinitfail
r_static
r_void
id|ch_action_rxinitfail
c_func
(paren
id|fsm_instance
op_star
id|fi
comma
r_int
id|event
comma
r_void
op_star
id|arg
)paren
(brace
id|channel
op_star
id|ch
op_assign
(paren
id|channel
op_star
)paren
id|arg
suffix:semicolon
id|net_device
op_star
id|dev
op_assign
id|ch-&gt;netdev
suffix:semicolon
id|fsm_newstate
c_func
(paren
id|fi
comma
id|CH_STATE_RXERR
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: RX initialization failed&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: RX &lt;-&gt; RX connection detected&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
(paren
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|fsm
comma
id|DEV_EVENT_RXDOWN
comma
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Handle RX Unit check remote reset (remote disconnected)&n; *&n; * @param fi    An instance of a channel statemachine.&n; * @param event The event, just happened.&n; * @param arg   Generic pointer, casted from channel * upon call.&n; */
DECL|function|ch_action_rxdisc
r_static
r_void
id|ch_action_rxdisc
c_func
(paren
id|fsm_instance
op_star
id|fi
comma
r_int
id|event
comma
r_void
op_star
id|arg
)paren
(brace
id|channel
op_star
id|ch
op_assign
(paren
id|channel
op_star
)paren
id|arg
suffix:semicolon
id|channel
op_star
id|ch2
suffix:semicolon
id|net_device
op_star
id|dev
op_assign
id|ch-&gt;netdev
suffix:semicolon
id|fsm_deltimer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Got remote disconnect, re-initializing ...&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/**&n;&t; * Notify device statemachine&n;&t; */
id|fsm_event
c_func
(paren
(paren
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|fsm
comma
id|DEV_EVENT_RXDOWN
comma
id|dev
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
(paren
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|fsm
comma
id|DEV_EVENT_TXDOWN
comma
id|dev
)paren
suffix:semicolon
id|fsm_newstate
c_func
(paren
id|fi
comma
id|CH_STATE_DTERM
)paren
suffix:semicolon
id|ch2
op_assign
(paren
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|channel
(braket
id|WRITE
)braket
suffix:semicolon
id|fsm_newstate
c_func
(paren
id|ch2-&gt;fsm
comma
id|CH_STATE_DTERM
)paren
suffix:semicolon
id|halt_IO
c_func
(paren
id|ch-&gt;irq
comma
(paren
id|intparm_t
)paren
id|ch
comma
l_int|0
)paren
suffix:semicolon
id|halt_IO
c_func
(paren
id|ch2-&gt;irq
comma
(paren
id|intparm_t
)paren
id|ch2
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Handle error during TX channel initialization.&n; *&n; * @param fi    An instance of a channel statemachine.&n; * @param event The event, just happened.&n; * @param arg   Generic pointer, casted from channel * upon call.&n; */
DECL|function|ch_action_txiniterr
r_static
r_void
id|ch_action_txiniterr
c_func
(paren
id|fsm_instance
op_star
id|fi
comma
r_int
id|event
comma
r_void
op_star
id|arg
)paren
(brace
id|channel
op_star
id|ch
op_assign
(paren
id|channel
op_star
)paren
id|arg
suffix:semicolon
id|net_device
op_star
id|dev
op_assign
id|ch-&gt;netdev
suffix:semicolon
r_if
c_cond
(paren
id|event
op_eq
id|CH_EVENT_TIMER
)paren
(brace
id|fsm_deltimer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Timeout during TX init handshake&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;retry
op_increment
OL
l_int|3
)paren
id|ch_action_restart
c_func
(paren
id|fi
comma
id|event
comma
id|arg
)paren
suffix:semicolon
r_else
(brace
id|fsm_newstate
c_func
(paren
id|fi
comma
id|CH_STATE_TXERR
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
(paren
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|fsm
comma
id|DEV_EVENT_TXDOWN
comma
id|dev
)paren
suffix:semicolon
)brace
)brace
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Error during TX init handshake&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Handle TX timeout by retrying operation.&n; *&n; * @param fi    An instance of a channel statemachine.&n; * @param event The event, just happened.&n; * @param arg   Generic pointer, casted from channel * upon call.&n; */
DECL|function|ch_action_txretry
r_static
r_void
id|ch_action_txretry
c_func
(paren
id|fsm_instance
op_star
id|fi
comma
r_int
id|event
comma
r_void
op_star
id|arg
)paren
(brace
id|channel
op_star
id|ch
op_assign
(paren
id|channel
op_star
)paren
id|arg
suffix:semicolon
id|net_device
op_star
id|dev
op_assign
id|ch-&gt;netdev
suffix:semicolon
r_int
r_int
id|saveflags
suffix:semicolon
id|fsm_deltimer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;retry
op_increment
OG
l_int|3
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: TX retry failed, restarting channel&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
(paren
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|fsm
comma
id|DEV_EVENT_TXDOWN
comma
id|dev
)paren
suffix:semicolon
id|ch_action_restart
c_func
(paren
id|fi
comma
id|event
comma
id|arg
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: TX retry %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ch-&gt;retry
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|skb_peek
c_func
(paren
op_amp
id|ch-&gt;io_queue
)paren
)paren
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|clear_normalized_cda
c_func
(paren
op_amp
id|ch-&gt;ccw
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|4
)braket
dot
id|count
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|set_normalized_cda
c_func
(paren
op_amp
id|ch-&gt;ccw
(braket
l_int|4
)braket
comma
id|virt_to_phys
c_func
(paren
id|skb-&gt;data
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: IDAL alloc failed, &quot;
l_string|&quot;restarting channel&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
(paren
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|fsm
comma
id|DEV_EVENT_TXDOWN
comma
id|dev
)paren
suffix:semicolon
id|ch_action_restart
c_func
(paren
id|fi
comma
id|event
comma
id|arg
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|fsm_addtimer
c_func
(paren
op_amp
id|ch-&gt;timer
comma
l_int|1000
comma
id|CH_EVENT_TIMER
comma
id|ch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event
op_eq
id|CH_EVENT_TIMER
)paren
id|s390irq_spin_lock_irqsave
c_func
(paren
id|ch-&gt;irq
comma
id|saveflags
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ccw[4].cda = %08x&bslash;n&quot;
comma
id|ch-&gt;ccw
(braket
l_int|4
)braket
dot
id|cda
)paren
suffix:semicolon
macro_line|#endif
id|rc
op_assign
id|do_IO
c_func
(paren
id|ch-&gt;irq
comma
op_amp
id|ch-&gt;ccw
(braket
l_int|3
)braket
comma
(paren
id|intparm_t
)paren
id|ch
comma
l_int|0xff
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event
op_eq
id|CH_EVENT_TIMER
)paren
id|s390irq_spin_unlock_irqrestore
c_func
(paren
id|ch-&gt;irq
comma
id|saveflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
id|fsm_deltimer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|ccw_check_return_code
c_func
(paren
id|ch
comma
id|rc
)paren
suffix:semicolon
id|ctc_purge_skb_queue
c_func
(paren
op_amp
id|ch-&gt;io_queue
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/**&n; * Handle fatal errors during an I/O command.&n; *&n; * @param fi    An instance of a channel statemachine.&n; * @param event The event, just happened.&n; * @param arg   Generic pointer, casted from channel * upon call.&n; */
DECL|function|ch_action_iofatal
r_static
r_void
id|ch_action_iofatal
c_func
(paren
id|fsm_instance
op_star
id|fi
comma
r_int
id|event
comma
r_void
op_star
id|arg
)paren
(brace
id|channel
op_star
id|ch
op_assign
(paren
id|channel
op_star
)paren
id|arg
suffix:semicolon
id|net_device
op_star
id|dev
op_assign
id|ch-&gt;netdev
suffix:semicolon
id|fsm_deltimer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CHANNEL_DIRECTION
c_func
(paren
id|ch-&gt;flags
)paren
op_eq
id|READ
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: RX I/O error&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|fsm_newstate
c_func
(paren
id|fi
comma
id|CH_STATE_RXERR
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
(paren
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|fsm
comma
id|DEV_EVENT_RXDOWN
comma
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: TX I/O error&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|fsm_newstate
c_func
(paren
id|fi
comma
id|CH_STATE_TXERR
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
(paren
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|fsm
comma
id|DEV_EVENT_TXDOWN
comma
id|dev
)paren
suffix:semicolon
)brace
)brace
"&f;"
multiline_comment|/**&n; * The statemachine for a channel.&n; */
DECL|variable|ch_fsm
r_static
r_const
id|fsm_node
id|ch_fsm
(braket
)braket
op_assign
(brace
(brace
id|CH_STATE_STOPPED
comma
id|CH_EVENT_STOP
comma
id|fsm_action_nop
)brace
comma
(brace
id|CH_STATE_STOPPED
comma
id|CH_EVENT_START
comma
id|ch_action_start
)brace
comma
(brace
id|CH_STATE_STOPPED
comma
id|CH_EVENT_FINSTAT
comma
id|fsm_action_nop
)brace
comma
(brace
id|CH_STATE_STOPPED
comma
id|CH_EVENT_MC_FAIL
comma
id|fsm_action_nop
)brace
comma
(brace
id|CH_STATE_NOTOP
comma
id|CH_EVENT_STOP
comma
id|ch_action_stop
)brace
comma
(brace
id|CH_STATE_NOTOP
comma
id|CH_EVENT_START
comma
id|fsm_action_nop
)brace
comma
(brace
id|CH_STATE_NOTOP
comma
id|CH_EVENT_FINSTAT
comma
id|fsm_action_nop
)brace
comma
(brace
id|CH_STATE_NOTOP
comma
id|CH_EVENT_MC_FAIL
comma
id|fsm_action_nop
)brace
comma
(brace
id|CH_STATE_NOTOP
comma
id|CH_EVENT_MC_GOOD
comma
id|ch_action_start
)brace
comma
(brace
id|CH_STATE_STARTWAIT
comma
id|CH_EVENT_STOP
comma
id|ch_action_haltio
)brace
comma
(brace
id|CH_STATE_STARTWAIT
comma
id|CH_EVENT_START
comma
id|fsm_action_nop
)brace
comma
(brace
id|CH_STATE_STARTWAIT
comma
id|CH_EVENT_FINSTAT
comma
id|ch_action_setmode
)brace
comma
(brace
id|CH_STATE_STARTWAIT
comma
id|CH_EVENT_TIMER
comma
id|ch_action_setuperr
)brace
comma
(brace
id|CH_STATE_STARTWAIT
comma
id|CH_EVENT_IO_ENODEV
comma
id|ch_action_iofatal
)brace
comma
(brace
id|CH_STATE_STARTWAIT
comma
id|CH_EVENT_IO_EIO
comma
id|ch_action_iofatal
)brace
comma
(brace
id|CH_STATE_STARTWAIT
comma
id|CH_EVENT_MC_FAIL
comma
id|ch_action_fail
)brace
comma
(brace
id|CH_STATE_STARTRETRY
comma
id|CH_EVENT_STOP
comma
id|ch_action_haltio
)brace
comma
(brace
id|CH_STATE_STARTRETRY
comma
id|CH_EVENT_TIMER
comma
id|ch_action_setmode
)brace
comma
(brace
id|CH_STATE_STARTRETRY
comma
id|CH_EVENT_FINSTAT
comma
id|fsm_action_nop
)brace
comma
(brace
id|CH_STATE_STARTRETRY
comma
id|CH_EVENT_MC_FAIL
comma
id|ch_action_fail
)brace
comma
(brace
id|CH_STATE_SETUPWAIT
comma
id|CH_EVENT_STOP
comma
id|ch_action_haltio
)brace
comma
(brace
id|CH_STATE_SETUPWAIT
comma
id|CH_EVENT_START
comma
id|fsm_action_nop
)brace
comma
(brace
id|CH_STATE_SETUPWAIT
comma
id|CH_EVENT_FINSTAT
comma
id|ch_action_firstio
)brace
comma
(brace
id|CH_STATE_SETUPWAIT
comma
id|CH_EVENT_UC_RCRESET
comma
id|ch_action_setuperr
)brace
comma
(brace
id|CH_STATE_SETUPWAIT
comma
id|CH_EVENT_UC_RSRESET
comma
id|ch_action_setuperr
)brace
comma
(brace
id|CH_STATE_SETUPWAIT
comma
id|CH_EVENT_TIMER
comma
id|ch_action_setmode
)brace
comma
(brace
id|CH_STATE_SETUPWAIT
comma
id|CH_EVENT_IO_ENODEV
comma
id|ch_action_iofatal
)brace
comma
(brace
id|CH_STATE_SETUPWAIT
comma
id|CH_EVENT_IO_EIO
comma
id|ch_action_iofatal
)brace
comma
(brace
id|CH_STATE_SETUPWAIT
comma
id|CH_EVENT_MC_FAIL
comma
id|ch_action_fail
)brace
comma
(brace
id|CH_STATE_RXINIT
comma
id|CH_EVENT_STOP
comma
id|ch_action_haltio
)brace
comma
(brace
id|CH_STATE_RXINIT
comma
id|CH_EVENT_START
comma
id|fsm_action_nop
)brace
comma
(brace
id|CH_STATE_RXINIT
comma
id|CH_EVENT_FINSTAT
comma
id|ch_action_rxidle
)brace
comma
(brace
id|CH_STATE_RXINIT
comma
id|CH_EVENT_UC_RCRESET
comma
id|ch_action_rxiniterr
)brace
comma
(brace
id|CH_STATE_RXINIT
comma
id|CH_EVENT_UC_RSRESET
comma
id|ch_action_rxiniterr
)brace
comma
(brace
id|CH_STATE_RXINIT
comma
id|CH_EVENT_TIMER
comma
id|ch_action_rxiniterr
)brace
comma
(brace
id|CH_STATE_RXINIT
comma
id|CH_EVENT_ATTNBUSY
comma
id|ch_action_rxinitfail
)brace
comma
(brace
id|CH_STATE_RXINIT
comma
id|CH_EVENT_IO_ENODEV
comma
id|ch_action_iofatal
)brace
comma
(brace
id|CH_STATE_RXINIT
comma
id|CH_EVENT_IO_EIO
comma
id|ch_action_iofatal
)brace
comma
(brace
id|CH_STATE_RXINIT
comma
id|CH_EVENT_UC_ZERO
comma
id|ch_action_firstio
)brace
comma
(brace
id|CH_STATE_RXINIT
comma
id|CH_EVENT_MC_FAIL
comma
id|ch_action_fail
)brace
comma
(brace
id|CH_STATE_RXIDLE
comma
id|CH_EVENT_STOP
comma
id|ch_action_haltio
)brace
comma
(brace
id|CH_STATE_RXIDLE
comma
id|CH_EVENT_START
comma
id|fsm_action_nop
)brace
comma
(brace
id|CH_STATE_RXIDLE
comma
id|CH_EVENT_FINSTAT
comma
id|ch_action_rx
)brace
comma
(brace
id|CH_STATE_RXIDLE
comma
id|CH_EVENT_UC_RCRESET
comma
id|ch_action_rxdisc
)brace
comma
singleline_comment|//&t;{ CH_STATE_RXIDLE,     CH_EVENT_UC_RSRESET, ch_action_rxretry    },
(brace
id|CH_STATE_RXIDLE
comma
id|CH_EVENT_IO_ENODEV
comma
id|ch_action_iofatal
)brace
comma
(brace
id|CH_STATE_RXIDLE
comma
id|CH_EVENT_IO_EIO
comma
id|ch_action_iofatal
)brace
comma
(brace
id|CH_STATE_RXIDLE
comma
id|CH_EVENT_MC_FAIL
comma
id|ch_action_fail
)brace
comma
(brace
id|CH_STATE_RXIDLE
comma
id|CH_EVENT_UC_ZERO
comma
id|ch_action_rx
)brace
comma
(brace
id|CH_STATE_TXINIT
comma
id|CH_EVENT_STOP
comma
id|ch_action_haltio
)brace
comma
(brace
id|CH_STATE_TXINIT
comma
id|CH_EVENT_START
comma
id|fsm_action_nop
)brace
comma
(brace
id|CH_STATE_TXINIT
comma
id|CH_EVENT_FINSTAT
comma
id|ch_action_txidle
)brace
comma
(brace
id|CH_STATE_TXINIT
comma
id|CH_EVENT_UC_RCRESET
comma
id|ch_action_txiniterr
)brace
comma
(brace
id|CH_STATE_TXINIT
comma
id|CH_EVENT_UC_RSRESET
comma
id|ch_action_txiniterr
)brace
comma
(brace
id|CH_STATE_TXINIT
comma
id|CH_EVENT_TIMER
comma
id|ch_action_txiniterr
)brace
comma
(brace
id|CH_STATE_TXINIT
comma
id|CH_EVENT_IO_ENODEV
comma
id|ch_action_iofatal
)brace
comma
(brace
id|CH_STATE_TXINIT
comma
id|CH_EVENT_IO_EIO
comma
id|ch_action_iofatal
)brace
comma
(brace
id|CH_STATE_TXINIT
comma
id|CH_EVENT_MC_FAIL
comma
id|ch_action_fail
)brace
comma
(brace
id|CH_STATE_TXIDLE
comma
id|CH_EVENT_STOP
comma
id|ch_action_haltio
)brace
comma
(brace
id|CH_STATE_TXIDLE
comma
id|CH_EVENT_START
comma
id|fsm_action_nop
)brace
comma
(brace
id|CH_STATE_TXIDLE
comma
id|CH_EVENT_FINSTAT
comma
id|ch_action_firstio
)brace
comma
(brace
id|CH_STATE_TXIDLE
comma
id|CH_EVENT_UC_RCRESET
comma
id|fsm_action_nop
)brace
comma
(brace
id|CH_STATE_TXIDLE
comma
id|CH_EVENT_UC_RSRESET
comma
id|fsm_action_nop
)brace
comma
(brace
id|CH_STATE_TXIDLE
comma
id|CH_EVENT_IO_ENODEV
comma
id|ch_action_iofatal
)brace
comma
(brace
id|CH_STATE_TXIDLE
comma
id|CH_EVENT_IO_EIO
comma
id|ch_action_iofatal
)brace
comma
(brace
id|CH_STATE_TXIDLE
comma
id|CH_EVENT_MC_FAIL
comma
id|ch_action_fail
)brace
comma
(brace
id|CH_STATE_TERM
comma
id|CH_EVENT_STOP
comma
id|fsm_action_nop
)brace
comma
(brace
id|CH_STATE_TERM
comma
id|CH_EVENT_START
comma
id|ch_action_restart
)brace
comma
(brace
id|CH_STATE_TERM
comma
id|CH_EVENT_FINSTAT
comma
id|ch_action_stopped
)brace
comma
(brace
id|CH_STATE_TERM
comma
id|CH_EVENT_UC_RCRESET
comma
id|fsm_action_nop
)brace
comma
(brace
id|CH_STATE_TERM
comma
id|CH_EVENT_UC_RSRESET
comma
id|fsm_action_nop
)brace
comma
(brace
id|CH_STATE_TERM
comma
id|CH_EVENT_MC_FAIL
comma
id|ch_action_fail
)brace
comma
(brace
id|CH_STATE_DTERM
comma
id|CH_EVENT_STOP
comma
id|ch_action_haltio
)brace
comma
(brace
id|CH_STATE_DTERM
comma
id|CH_EVENT_START
comma
id|ch_action_restart
)brace
comma
(brace
id|CH_STATE_DTERM
comma
id|CH_EVENT_FINSTAT
comma
id|ch_action_setmode
)brace
comma
(brace
id|CH_STATE_DTERM
comma
id|CH_EVENT_UC_RCRESET
comma
id|fsm_action_nop
)brace
comma
(brace
id|CH_STATE_DTERM
comma
id|CH_EVENT_UC_RSRESET
comma
id|fsm_action_nop
)brace
comma
(brace
id|CH_STATE_DTERM
comma
id|CH_EVENT_MC_FAIL
comma
id|ch_action_fail
)brace
comma
(brace
id|CH_STATE_TX
comma
id|CH_EVENT_STOP
comma
id|ch_action_haltio
)brace
comma
(brace
id|CH_STATE_TX
comma
id|CH_EVENT_START
comma
id|fsm_action_nop
)brace
comma
(brace
id|CH_STATE_TX
comma
id|CH_EVENT_FINSTAT
comma
id|ch_action_txdone
)brace
comma
(brace
id|CH_STATE_TX
comma
id|CH_EVENT_UC_RCRESET
comma
id|ch_action_txretry
)brace
comma
(brace
id|CH_STATE_TX
comma
id|CH_EVENT_UC_RSRESET
comma
id|ch_action_txretry
)brace
comma
(brace
id|CH_STATE_TX
comma
id|CH_EVENT_TIMER
comma
id|ch_action_txretry
)brace
comma
(brace
id|CH_STATE_TX
comma
id|CH_EVENT_IO_ENODEV
comma
id|ch_action_iofatal
)brace
comma
(brace
id|CH_STATE_TX
comma
id|CH_EVENT_IO_EIO
comma
id|ch_action_iofatal
)brace
comma
(brace
id|CH_STATE_TX
comma
id|CH_EVENT_MC_FAIL
comma
id|ch_action_fail
)brace
comma
(brace
id|CH_STATE_RXERR
comma
id|CH_EVENT_STOP
comma
id|ch_action_haltio
)brace
comma
(brace
id|CH_STATE_TXERR
comma
id|CH_EVENT_STOP
comma
id|ch_action_haltio
)brace
comma
(brace
id|CH_STATE_TXERR
comma
id|CH_EVENT_MC_FAIL
comma
id|ch_action_fail
)brace
comma
(brace
id|CH_STATE_RXERR
comma
id|CH_EVENT_MC_FAIL
comma
id|ch_action_fail
)brace
comma
)brace
suffix:semicolon
DECL|variable|CH_FSM_LEN
r_static
r_const
r_int
id|CH_FSM_LEN
op_assign
r_sizeof
(paren
id|ch_fsm
)paren
op_div
r_sizeof
(paren
id|fsm_node
)paren
suffix:semicolon
"&f;"
multiline_comment|/**&n; * Functions related to setup and device detection.&n; *****************************************************************************/
multiline_comment|/**&n; * Add a new channel to the list of channels.&n; * Keeps the channel list sorted.&n; *&n; * @param irq   The IRQ to be used by the new channel.&n; * @param devno The device number of the new channel.&n; * @param type  The type class of the new channel.&n; *&n; * @return 0 on success, !0 on error.&n; */
DECL|function|add_channel
r_static
r_int
id|add_channel
c_func
(paren
r_int
id|irq
comma
id|__u16
id|devno
comma
id|channel_type_t
id|type
)paren
(brace
id|channel
op_star
op_star
id|c
op_assign
op_amp
id|channels
suffix:semicolon
id|channel
op_star
id|ch
suffix:semicolon
r_char
id|name
(braket
l_int|10
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ch
op_assign
(paren
id|channel
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|channel
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc: Out of memory in add_channel&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ch
comma
l_int|0
comma
r_sizeof
(paren
id|channel
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ch-&gt;ccw
op_assign
(paren
id|ccw1_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|ccw1_t
)paren
op_star
l_int|8
comma
id|GFP_KERNEL
op_or
id|GFP_DMA
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|ch
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc: Out of memory in add_channel&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n;&t; * &quot;static&quot; ccws are used in the following way:&n;&t; *&n;&t; * ccw[0..2] (Channel program for generic I/O):&n;&t; *           0: prepare&n;&t; *           1: read or write (depending on direction) with fixed&n;&t; *              buffer (idal allocated once when buffer is allocated)&n;&t; *           2: nop&n;&t; * ccw[3..5] (Channel program for direct write of packets)&n;&t; *           3: prepare&n;&t; *           4: write (idal allocated on every write).&n;&t; *           5: nop&n;&t; * ccw[6..7] (Channel program for initial channel setup):&n;&t; *           3: set extended mode&n;&t; *           4: nop&n;&t; *&n;&t; * ch-&gt;ccw[0..5] are initialized in ch_action_start because&n;&t; * the channel&squot;s direction is yet unknown here.&n;&t; */
id|ch-&gt;ccw
(braket
l_int|6
)braket
dot
id|cmd_code
op_assign
id|CCW_CMD_SET_EXTENDED
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|6
)braket
dot
id|flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|6
)braket
dot
id|count
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|6
)braket
dot
id|cda
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|7
)braket
dot
id|cmd_code
op_assign
id|CCW_CMD_NOOP
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|7
)braket
dot
id|flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|7
)braket
dot
id|count
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|7
)braket
dot
id|cda
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;irq
op_assign
id|irq
suffix:semicolon
id|ch-&gt;devno
op_assign
id|devno
suffix:semicolon
id|ch-&gt;type
op_assign
id|type
suffix:semicolon
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;ch-%04x&quot;
comma
id|devno
)paren
suffix:semicolon
id|ch-&gt;fsm
op_assign
id|init_fsm
c_func
(paren
id|name
comma
id|ch_state_names
comma
id|ch_event_names
comma
id|NR_CH_STATES
comma
id|NR_CH_EVENTS
comma
id|ch_fsm
comma
id|CH_FSM_LEN
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;fsm
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc: Could not create FSM in add_channel&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ch
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|fsm_newstate
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_STATE_IDLE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ch-&gt;devstat
op_assign
(paren
id|devstat_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|devstat_t
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc: Out of memory in add_channel&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_fsm
c_func
(paren
id|ch-&gt;fsm
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ch
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ch-&gt;devstat
comma
l_int|0
comma
r_sizeof
(paren
id|devstat_t
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|c
op_logical_and
(paren
(paren
op_star
id|c
)paren
op_member_access_from_pointer
id|devno
OL
id|devno
)paren
)paren
id|c
op_assign
op_amp
(paren
op_star
id|c
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|c
)paren
op_member_access_from_pointer
id|devno
op_eq
id|devno
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ctc: add_channel: device %04x already in list, &quot;
l_string|&quot;using old entry&bslash;n&quot;
comma
(paren
op_star
id|c
)paren
op_member_access_from_pointer
id|devno
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ch-&gt;devstat
)paren
suffix:semicolon
id|kfree_fsm
c_func
(paren
id|ch-&gt;fsm
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ch
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|fsm_settimer
c_func
(paren
id|ch-&gt;fsm
comma
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|ch-&gt;io_queue
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|ch-&gt;collect_queue
)paren
suffix:semicolon
id|ch-&gt;next
op_assign
op_star
id|c
suffix:semicolon
op_star
id|c
op_assign
id|ch
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifndef CTC_CHANDEV
multiline_comment|/**&n; * scan for all channels and create an entry in the channels list&n; * for every supported channel.&n; */
DECL|function|channel_scan
r_static
r_void
id|channel_scan
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|print_result
op_assign
l_int|1
suffix:semicolon
r_int
id|irq
suffix:semicolon
r_int
id|nr_escon
op_assign
l_int|0
suffix:semicolon
r_int
id|nr_ctca
op_assign
l_int|0
suffix:semicolon
id|s390_dev_info_t
id|di
suffix:semicolon
r_for
c_loop
(paren
id|irq
op_assign
l_int|0
suffix:semicolon
id|irq
OL
id|NR_IRQS
suffix:semicolon
id|irq
op_increment
)paren
(brace
r_if
c_cond
(paren
id|get_dev_info_by_irq
c_func
(paren
id|irq
comma
op_amp
id|di
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|di.status
op_eq
id|DEVSTAT_NOT_OPER
)paren
op_logical_or
(paren
id|di.status
op_eq
id|DEVSTAT_DEVICE_OWNED
)paren
)paren
r_continue
suffix:semicolon
r_switch
c_cond
(paren
id|channel_type
c_func
(paren
op_amp
id|di.sid_data
)paren
)paren
(brace
r_case
id|channel_type_ctca
suffix:colon
multiline_comment|/* CTC/A */
r_if
c_cond
(paren
op_logical_neg
id|add_channel
c_func
(paren
id|irq
comma
id|di.devno
comma
id|channel_type_ctca
)paren
)paren
id|nr_ctca
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|channel_type_escon
suffix:colon
multiline_comment|/* ESCON */
r_if
c_cond
(paren
op_logical_neg
id|add_channel
c_func
(paren
id|irq
comma
id|di.devno
comma
id|channel_type_escon
)paren
)paren
id|nr_escon
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
)brace
)brace
)brace
r_if
c_cond
(paren
id|print_result
)paren
(brace
r_if
c_cond
(paren
id|nr_escon
op_plus
id|nr_ctca
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ctc: %d CTC/A channel%s and %d ESCON &quot;
l_string|&quot;channel%s found.&bslash;n&quot;
comma
id|nr_ctca
comma
(paren
id|nr_ctca
op_eq
l_int|1
)paren
ques
c_cond
l_string|&quot;s&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|nr_escon
comma
(paren
id|nr_escon
op_eq
l_int|1
)paren
ques
c_cond
l_string|&quot;s&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ctc: No channel devices found.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|print_result
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**&n; * Release a specific channel in the channel list.&n; *&n; * @param ch Pointer to channel struct to be released.&n; */
DECL|function|channel_free
r_static
r_void
id|channel_free
c_func
(paren
id|channel
op_star
id|ch
)paren
(brace
id|ch-&gt;flags
op_and_assign
op_complement
id|CHANNEL_FLAGS_INUSE
suffix:semicolon
id|fsm_newstate
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_STATE_IDLE
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Remove a specific channel in the channel list.&n; *&n; * @param ch Pointer to channel struct to be released.&n; */
DECL|function|channel_remove
r_static
r_void
id|channel_remove
c_func
(paren
id|channel
op_star
id|ch
)paren
(brace
id|channel
op_star
op_star
id|c
op_assign
op_amp
id|channels
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
macro_line|#ifndef CTC_CHANDEV
r_if
c_cond
(paren
id|ch-&gt;flags
op_amp
id|CHANNEL_FLAGS_INUSE
)paren
id|FREE_IRQ
c_func
(paren
id|ch-&gt;irq
comma
id|ch-&gt;devstat
)paren
suffix:semicolon
macro_line|#endif
id|channel_free
c_func
(paren
id|ch
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|c
)paren
(brace
r_if
c_cond
(paren
op_star
id|c
op_eq
id|ch
)paren
(brace
op_star
id|c
op_assign
id|ch-&gt;next
suffix:semicolon
id|fsm_deltimer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|kfree_fsm
c_func
(paren
id|ch-&gt;fsm
)paren
suffix:semicolon
id|clear_normalized_cda
c_func
(paren
op_amp
id|ch-&gt;ccw
(braket
l_int|4
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;trans_skb
op_ne
l_int|NULL
)paren
(brace
id|clear_normalized_cda
c_func
(paren
op_amp
id|ch-&gt;ccw
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|ch-&gt;trans_skb
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|ch-&gt;ccw
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|c
op_assign
op_amp
(paren
(paren
op_star
id|c
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * Get a specific channel from the channel list.&n; *&n; * @param type Type of channel we are interested in.&n; * @param devno Device number of channel we are interested in.&n; * @param direction Direction we want to use this channel for.&n; *&n; * @return Pointer to a channel or NULL if no matching channel available.&n; */
DECL|function|channel_get
r_static
id|channel
op_star
id|channel_get
c_func
(paren
id|channel_type_t
id|type
comma
r_int
id|devno
comma
r_int
id|direction
)paren
(brace
id|channel
op_star
id|ch
op_assign
id|channels
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ctc: %s(): searching for ch with devno %d and type %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|devno
comma
id|type
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|ch
op_logical_and
(paren
(paren
id|ch-&gt;devno
op_ne
id|devno
)paren
op_logical_or
(paren
id|ch-&gt;type
op_ne
id|type
)paren
)paren
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ctc: %s(): ch=0x%p (devno=%d, type=%d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|ch
comma
id|ch-&gt;devno
comma
id|ch-&gt;type
)paren
suffix:semicolon
macro_line|#endif
id|ch
op_assign
id|ch-&gt;next
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ctc: %s(): ch=0x%pq (devno=%d, type=%d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|ch
comma
id|ch-&gt;devno
comma
id|ch-&gt;type
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|ch
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc: %s(): channel with devno %d &quot;
l_string|&quot;and type %d not found in channel list&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|devno
comma
id|type
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ch-&gt;flags
op_amp
id|CHANNEL_FLAGS_INUSE
)paren
id|ch
op_assign
l_int|NULL
suffix:semicolon
r_else
(brace
id|ch-&gt;flags
op_or_assign
id|CHANNEL_FLAGS_INUSE
suffix:semicolon
id|ch-&gt;flags
op_and_assign
op_complement
id|CHANNEL_FLAGS_RWMASK
suffix:semicolon
id|ch-&gt;flags
op_or_assign
(paren
id|direction
op_eq
id|WRITE
)paren
ques
c_cond
id|CHANNEL_FLAGS_WRITE
suffix:colon
id|CHANNEL_FLAGS_READ
suffix:semicolon
id|fsm_newstate
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_STATE_STOPPED
)paren
suffix:semicolon
)brace
)brace
r_return
id|ch
suffix:semicolon
)brace
macro_line|#ifndef CTC_CHANDEV
multiline_comment|/**&n; * Get the next free channel from the channel list&n; *&n; * @param type Type of channel we are interested in.&n; * @param direction Direction we want to use this channel for.&n; *&n; * @return Pointer to a channel or NULL if no matching channel available.&n; */
DECL|function|channel_get_next
r_static
id|channel
op_star
id|channel_get_next
c_func
(paren
id|channel_type_t
id|type
comma
r_int
id|direction
)paren
(brace
id|channel
op_star
id|ch
op_assign
id|channels
suffix:semicolon
r_while
c_loop
(paren
id|ch
op_logical_and
(paren
id|ch-&gt;type
op_ne
id|type
op_logical_or
(paren
id|ch-&gt;flags
op_amp
id|CHANNEL_FLAGS_INUSE
)paren
)paren
)paren
id|ch
op_assign
id|ch-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|ch
)paren
(brace
id|ch-&gt;flags
op_or_assign
id|CHANNEL_FLAGS_INUSE
suffix:semicolon
id|ch-&gt;flags
op_and_assign
op_complement
id|CHANNEL_FLAGS_RWMASK
suffix:semicolon
id|ch-&gt;flags
op_or_assign
(paren
id|direction
op_eq
id|WRITE
)paren
ques
c_cond
id|CHANNEL_FLAGS_WRITE
suffix:colon
id|CHANNEL_FLAGS_READ
suffix:semicolon
id|fsm_newstate
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_STATE_STOPPED
)paren
suffix:semicolon
)brace
r_return
id|ch
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**&n; * Return the channel type by name.&n; *&n; * @param name Name of network interface.&n; *&n; * @return Type class of channel to be used for that interface.&n; */
DECL|function|extract_channel_media
r_static
id|channel_type_t
r_inline
id|extract_channel_media
c_func
(paren
r_char
op_star
id|name
)paren
(brace
id|channel_type_t
id|ret
op_assign
id|channel_type_unknown
suffix:semicolon
r_if
c_cond
(paren
id|name
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|name
comma
l_string|&quot;ctc&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
id|ret
op_assign
id|channel_type_ctca
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|name
comma
l_string|&quot;escon&quot;
comma
l_int|5
)paren
op_eq
l_int|0
)paren
id|ret
op_assign
id|channel_type_escon
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * Find a channel in the list by its IRQ.&n; *&n; * @param irq IRQ to search for.&n; *&n; * @return Pointer to channel or NULL if no matching channel found.&n; */
DECL|function|find_channel_by_irq
r_static
id|channel
op_star
id|find_channel_by_irq
c_func
(paren
r_int
id|irq
)paren
(brace
id|channel
op_star
id|ch
op_assign
id|channels
suffix:semicolon
r_while
c_loop
(paren
id|ch
op_logical_and
(paren
id|ch-&gt;irq
op_ne
id|irq
)paren
)paren
id|ch
op_assign
id|ch-&gt;next
suffix:semicolon
r_return
id|ch
suffix:semicolon
)brace
multiline_comment|/**&n; * Main IRQ handler.&n; *&n; * @param irq     The IRQ to handle.&n; * @param intparm IRQ params.&n; * @param regs    CPU registers.&n; */
DECL|function|ctc_irq_handler
r_static
r_void
id|ctc_irq_handler
(paren
r_int
id|irq
comma
r_void
op_star
id|intparm
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|devstat_t
op_star
id|devstat
op_assign
(paren
id|devstat_t
op_star
)paren
id|intparm
suffix:semicolon
id|channel
op_star
id|ch
op_assign
(paren
id|channel
op_star
)paren
id|devstat-&gt;intparm
suffix:semicolon
id|net_device
op_star
id|dev
suffix:semicolon
multiline_comment|/**&n;&t; * Check for unsolicited interrupts.&n;&t; * If intparm is NULL, then loop over all our known&n;&t; * channels and try matching the irq number.&n;&t; */
r_if
c_cond
(paren
id|ch
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|ch
op_assign
id|find_channel_by_irq
c_func
(paren
id|irq
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc: Got unsolicited irq: %04x c-%02x d-%02x&quot;
l_string|&quot;f-%02x&bslash;n&quot;
comma
id|devstat-&gt;devno
comma
id|devstat-&gt;cstat
comma
id|devstat-&gt;dstat
comma
id|devstat-&gt;flag
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
)brace
id|dev
op_assign
(paren
id|net_device
op_star
)paren
(paren
id|ch-&gt;netdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;ctc: ctc_irq_handler dev = NULL irq=%d, ch=0x%p&bslash;n&quot;
comma
id|irq
comma
id|ch
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intparm
op_eq
l_int|NULL
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Channel %04x found by IRQ %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ch-&gt;devno
comma
id|irq
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: interrupt for device: %04x received c-%02x d-%02x &quot;
l_string|&quot;f-%02x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|devstat-&gt;devno
comma
id|devstat-&gt;cstat
comma
id|devstat-&gt;dstat
comma
id|devstat-&gt;flag
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Check for good subchannel return code, otherwise error message */
r_if
c_cond
(paren
id|devstat-&gt;cstat
)paren
(brace
id|fsm_event
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_EVENT_SC_UNKNOWN
comma
id|ch
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: subchannel check for device: %04x - %02x %02x &quot;
l_string|&quot;%02x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ch-&gt;devno
comma
id|devstat-&gt;cstat
comma
id|devstat-&gt;dstat
comma
id|devstat-&gt;flag
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* Check the reason-code of a unit check */
r_if
c_cond
(paren
id|devstat-&gt;dstat
op_amp
id|DEV_STAT_UNIT_CHECK
)paren
(brace
id|ccw_unit_check
c_func
(paren
id|ch
comma
id|devstat-&gt;ii.sense.data
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|devstat-&gt;dstat
op_amp
id|DEV_STAT_BUSY
)paren
(brace
r_if
c_cond
(paren
id|devstat-&gt;dstat
op_amp
id|DEV_STAT_ATTENTION
)paren
id|fsm_event
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_EVENT_ATTNBUSY
comma
id|ch
)paren
suffix:semicolon
r_else
id|fsm_event
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_EVENT_BUSY
comma
id|ch
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|devstat-&gt;dstat
op_amp
id|DEV_STAT_ATTENTION
)paren
(brace
id|fsm_event
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_EVENT_ATTN
comma
id|ch
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|devstat-&gt;flag
op_amp
id|DEVSTAT_FINAL_STATUS
)paren
id|fsm_event
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_EVENT_FINSTAT
comma
id|ch
)paren
suffix:semicolon
r_else
id|fsm_event
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_EVENT_IRQ
comma
id|ch
)paren
suffix:semicolon
id|done
suffix:colon
)brace
"&f;"
multiline_comment|/**&n; * Actions for interface - statemachine.&n; *****************************************************************************/
multiline_comment|/**&n; * Startup channels by sending CH_EVENT_START to each channel.&n; *&n; * @param fi    An instance of an interface statemachine.&n; * @param event The event, just happened.&n; * @param arg   Generic pointer, casted from net_device * upon call.&n; */
DECL|function|dev_action_start
r_static
r_void
id|dev_action_start
c_func
(paren
id|fsm_instance
op_star
id|fi
comma
r_int
id|event
comma
r_void
op_star
id|arg
)paren
(brace
id|net_device
op_star
id|dev
op_assign
(paren
id|net_device
op_star
)paren
id|arg
suffix:semicolon
id|ctc_priv
op_star
id|privptr
op_assign
id|dev-&gt;priv
suffix:semicolon
r_int
id|direction
suffix:semicolon
id|fsm_newstate
c_func
(paren
id|fi
comma
id|DEV_STATE_STARTWAIT_RXTX
)paren
suffix:semicolon
r_for
c_loop
(paren
id|direction
op_assign
id|READ
suffix:semicolon
id|direction
op_le
id|WRITE
suffix:semicolon
id|direction
op_increment
)paren
(brace
id|channel
op_star
id|ch
op_assign
id|privptr-&gt;channel
(braket
id|direction
)braket
suffix:semicolon
id|fsm_event
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_EVENT_START
comma
id|ch
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * Shutdown channels by sending CH_EVENT_STOP to each channel.&n; *&n; * @param fi    An instance of an interface statemachine.&n; * @param event The event, just happened.&n; * @param arg   Generic pointer, casted from net_device * upon call.&n; */
DECL|function|dev_action_stop
r_static
r_void
id|dev_action_stop
c_func
(paren
id|fsm_instance
op_star
id|fi
comma
r_int
id|event
comma
r_void
op_star
id|arg
)paren
(brace
id|net_device
op_star
id|dev
op_assign
(paren
id|net_device
op_star
)paren
id|arg
suffix:semicolon
id|ctc_priv
op_star
id|privptr
op_assign
id|dev-&gt;priv
suffix:semicolon
r_int
id|direction
suffix:semicolon
id|fsm_newstate
c_func
(paren
id|fi
comma
id|DEV_STATE_STOPWAIT_RXTX
)paren
suffix:semicolon
r_for
c_loop
(paren
id|direction
op_assign
id|READ
suffix:semicolon
id|direction
op_le
id|WRITE
suffix:semicolon
id|direction
op_increment
)paren
(brace
id|channel
op_star
id|ch
op_assign
id|privptr-&gt;channel
(braket
id|direction
)braket
suffix:semicolon
id|fsm_event
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_EVENT_STOP
comma
id|ch
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * Called from channel statemachine&n; * when a channel is up and running.&n; *&n; * @param fi    An instance of an interface statemachine.&n; * @param event The event, just happened.&n; * @param arg   Generic pointer, casted from net_device * upon call.&n; */
DECL|function|dev_action_chup
r_static
r_void
id|dev_action_chup
c_func
(paren
id|fsm_instance
op_star
id|fi
comma
r_int
id|event
comma
r_void
op_star
id|arg
)paren
(brace
id|net_device
op_star
id|dev
op_assign
(paren
id|net_device
op_star
)paren
id|arg
suffix:semicolon
id|ctc_priv
op_star
id|privptr
op_assign
id|dev-&gt;priv
suffix:semicolon
r_switch
c_cond
(paren
id|fsm_getstate
c_func
(paren
id|fi
)paren
)paren
(brace
r_case
id|DEV_STATE_STARTWAIT_RXTX
suffix:colon
r_if
c_cond
(paren
id|event
op_eq
id|DEV_EVENT_RXUP
)paren
id|fsm_newstate
c_func
(paren
id|fi
comma
id|DEV_STATE_STARTWAIT_TX
)paren
suffix:semicolon
r_else
id|fsm_newstate
c_func
(paren
id|fi
comma
id|DEV_STATE_STARTWAIT_RX
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEV_STATE_STARTWAIT_RX
suffix:colon
r_if
c_cond
(paren
id|event
op_eq
id|DEV_EVENT_RXUP
)paren
(brace
id|fsm_newstate
c_func
(paren
id|fi
comma
id|DEV_STATE_RUNNING
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: connected with remote side&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|privptr-&gt;protocol
op_eq
id|CTC_PROTO_LINUX_TTY
)paren
id|ctc_tty_setcarrier
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|ctc_clear_busy
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DEV_STATE_STARTWAIT_TX
suffix:colon
r_if
c_cond
(paren
id|event
op_eq
id|DEV_EVENT_TXUP
)paren
(brace
id|fsm_newstate
c_func
(paren
id|fi
comma
id|DEV_STATE_RUNNING
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: connected with remote side&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|privptr-&gt;protocol
op_eq
id|CTC_PROTO_LINUX_TTY
)paren
id|ctc_tty_setcarrier
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|ctc_clear_busy
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DEV_STATE_STOPWAIT_TX
suffix:colon
r_if
c_cond
(paren
id|event
op_eq
id|DEV_EVENT_RXUP
)paren
id|fsm_newstate
c_func
(paren
id|fi
comma
id|DEV_STATE_STOPWAIT_RXTX
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEV_STATE_STOPWAIT_RX
suffix:colon
r_if
c_cond
(paren
id|event
op_eq
id|DEV_EVENT_TXUP
)paren
id|fsm_newstate
c_func
(paren
id|fi
comma
id|DEV_STATE_STOPWAIT_RXTX
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * Called from channel statemachine&n; * when a channel has been shutdown.&n; *&n; * @param fi    An instance of an interface statemachine.&n; * @param event The event, just happened.&n; * @param arg   Generic pointer, casted from net_device * upon call.&n; */
DECL|function|dev_action_chdown
r_static
r_void
id|dev_action_chdown
c_func
(paren
id|fsm_instance
op_star
id|fi
comma
r_int
id|event
comma
r_void
op_star
id|arg
)paren
(brace
id|net_device
op_star
id|dev
op_assign
(paren
id|net_device
op_star
)paren
id|arg
suffix:semicolon
id|ctc_priv
op_star
id|privptr
op_assign
id|dev-&gt;priv
suffix:semicolon
r_switch
c_cond
(paren
id|fsm_getstate
c_func
(paren
id|fi
)paren
)paren
(brace
r_case
id|DEV_STATE_RUNNING
suffix:colon
r_if
c_cond
(paren
id|privptr-&gt;protocol
op_eq
id|CTC_PROTO_LINUX_TTY
)paren
id|ctc_tty_setcarrier
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event
op_eq
id|DEV_EVENT_TXDOWN
)paren
id|fsm_newstate
c_func
(paren
id|fi
comma
id|DEV_STATE_STARTWAIT_TX
)paren
suffix:semicolon
r_else
id|fsm_newstate
c_func
(paren
id|fi
comma
id|DEV_STATE_STARTWAIT_RX
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEV_STATE_STARTWAIT_RX
suffix:colon
r_if
c_cond
(paren
id|event
op_eq
id|DEV_EVENT_TXDOWN
)paren
id|fsm_newstate
c_func
(paren
id|fi
comma
id|DEV_STATE_STARTWAIT_RXTX
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEV_STATE_STARTWAIT_TX
suffix:colon
r_if
c_cond
(paren
id|event
op_eq
id|DEV_EVENT_RXDOWN
)paren
id|fsm_newstate
c_func
(paren
id|fi
comma
id|DEV_STATE_STARTWAIT_RXTX
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEV_STATE_STOPWAIT_RXTX
suffix:colon
r_if
c_cond
(paren
id|event
op_eq
id|DEV_EVENT_TXDOWN
)paren
id|fsm_newstate
c_func
(paren
id|fi
comma
id|DEV_STATE_STOPWAIT_RX
)paren
suffix:semicolon
r_else
id|fsm_newstate
c_func
(paren
id|fi
comma
id|DEV_STATE_STOPWAIT_TX
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEV_STATE_STOPWAIT_RX
suffix:colon
r_if
c_cond
(paren
id|event
op_eq
id|DEV_EVENT_RXDOWN
)paren
id|fsm_newstate
c_func
(paren
id|fi
comma
id|DEV_STATE_STOPPED
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEV_STATE_STOPWAIT_TX
suffix:colon
r_if
c_cond
(paren
id|event
op_eq
id|DEV_EVENT_TXDOWN
)paren
id|fsm_newstate
c_func
(paren
id|fi
comma
id|DEV_STATE_STOPPED
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|variable|dev_fsm
r_static
r_const
id|fsm_node
id|dev_fsm
(braket
)braket
op_assign
(brace
(brace
id|DEV_STATE_STOPPED
comma
id|DEV_EVENT_START
comma
id|dev_action_start
)brace
comma
(brace
id|DEV_STATE_STOPWAIT_RXTX
comma
id|DEV_EVENT_START
comma
id|dev_action_start
)brace
comma
(brace
id|DEV_STATE_STOPWAIT_RXTX
comma
id|DEV_EVENT_RXDOWN
comma
id|dev_action_chdown
)brace
comma
(brace
id|DEV_STATE_STOPWAIT_RXTX
comma
id|DEV_EVENT_TXDOWN
comma
id|dev_action_chdown
)brace
comma
(brace
id|DEV_STATE_STOPWAIT_RX
comma
id|DEV_EVENT_START
comma
id|dev_action_start
)brace
comma
(brace
id|DEV_STATE_STOPWAIT_RX
comma
id|DEV_EVENT_RXUP
comma
id|dev_action_chup
)brace
comma
(brace
id|DEV_STATE_STOPWAIT_RX
comma
id|DEV_EVENT_TXUP
comma
id|dev_action_chup
)brace
comma
(brace
id|DEV_STATE_STOPWAIT_RX
comma
id|DEV_EVENT_RXDOWN
comma
id|dev_action_chdown
)brace
comma
(brace
id|DEV_STATE_STOPWAIT_TX
comma
id|DEV_EVENT_START
comma
id|dev_action_start
)brace
comma
(brace
id|DEV_STATE_STOPWAIT_TX
comma
id|DEV_EVENT_RXUP
comma
id|dev_action_chup
)brace
comma
(brace
id|DEV_STATE_STOPWAIT_TX
comma
id|DEV_EVENT_TXUP
comma
id|dev_action_chup
)brace
comma
(brace
id|DEV_STATE_STOPWAIT_TX
comma
id|DEV_EVENT_TXDOWN
comma
id|dev_action_chdown
)brace
comma
(brace
id|DEV_STATE_STARTWAIT_RXTX
comma
id|DEV_EVENT_STOP
comma
id|dev_action_stop
)brace
comma
(brace
id|DEV_STATE_STARTWAIT_RXTX
comma
id|DEV_EVENT_RXUP
comma
id|dev_action_chup
)brace
comma
(brace
id|DEV_STATE_STARTWAIT_RXTX
comma
id|DEV_EVENT_TXUP
comma
id|dev_action_chup
)brace
comma
(brace
id|DEV_STATE_STARTWAIT_RXTX
comma
id|DEV_EVENT_RXDOWN
comma
id|dev_action_chdown
)brace
comma
(brace
id|DEV_STATE_STARTWAIT_RXTX
comma
id|DEV_EVENT_TXDOWN
comma
id|dev_action_chdown
)brace
comma
(brace
id|DEV_STATE_STARTWAIT_TX
comma
id|DEV_EVENT_STOP
comma
id|dev_action_stop
)brace
comma
(brace
id|DEV_STATE_STARTWAIT_TX
comma
id|DEV_EVENT_RXUP
comma
id|dev_action_chup
)brace
comma
(brace
id|DEV_STATE_STARTWAIT_TX
comma
id|DEV_EVENT_TXUP
comma
id|dev_action_chup
)brace
comma
(brace
id|DEV_STATE_STARTWAIT_TX
comma
id|DEV_EVENT_RXDOWN
comma
id|dev_action_chdown
)brace
comma
(brace
id|DEV_STATE_STARTWAIT_RX
comma
id|DEV_EVENT_STOP
comma
id|dev_action_stop
)brace
comma
(brace
id|DEV_STATE_STARTWAIT_RX
comma
id|DEV_EVENT_RXUP
comma
id|dev_action_chup
)brace
comma
(brace
id|DEV_STATE_STARTWAIT_RX
comma
id|DEV_EVENT_TXUP
comma
id|dev_action_chup
)brace
comma
(brace
id|DEV_STATE_STARTWAIT_RX
comma
id|DEV_EVENT_TXDOWN
comma
id|dev_action_chdown
)brace
comma
(brace
id|DEV_STATE_RUNNING
comma
id|DEV_EVENT_STOP
comma
id|dev_action_stop
)brace
comma
(brace
id|DEV_STATE_RUNNING
comma
id|DEV_EVENT_RXDOWN
comma
id|dev_action_chdown
)brace
comma
(brace
id|DEV_STATE_RUNNING
comma
id|DEV_EVENT_TXDOWN
comma
id|dev_action_chdown
)brace
comma
(brace
id|DEV_STATE_RUNNING
comma
id|DEV_EVENT_TXUP
comma
id|fsm_action_nop
)brace
comma
(brace
id|DEV_STATE_RUNNING
comma
id|DEV_EVENT_RXUP
comma
id|fsm_action_nop
)brace
comma
)brace
suffix:semicolon
DECL|variable|DEV_FSM_LEN
r_static
r_const
r_int
id|DEV_FSM_LEN
op_assign
r_sizeof
(paren
id|dev_fsm
)paren
op_div
r_sizeof
(paren
id|fsm_node
)paren
suffix:semicolon
multiline_comment|/**&n; * Transmit a packet.&n; * This is a helper function for ctc_tx().&n; *&n; * @param ch Channel to be used for sending.&n; * @param skb Pointer to struct sk_buff of packet to send.&n; *            The linklevel header has already been set up&n; *            by ctc_tx().&n; *&n; * @return 0 on success, -ERRNO on failure. (Never fails.)&n; */
DECL|function|transmit_skb
r_static
r_int
id|transmit_skb
c_func
(paren
id|channel
op_star
id|ch
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
r_int
id|saveflags
suffix:semicolon
id|ll_header
id|header
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fsm_getstate
c_func
(paren
id|ch-&gt;fsm
)paren
op_ne
id|CH_STATE_TXIDLE
)paren
(brace
r_int
id|l
op_assign
id|skb-&gt;len
op_plus
id|LL_HEADER_LENGTH
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ch-&gt;collect_lock
comma
id|saveflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;collect_len
op_plus
id|l
OG
id|ch-&gt;max_bufsize
op_minus
l_int|2
)paren
id|rc
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_else
(brace
id|atomic_inc
c_func
(paren
op_amp
id|skb-&gt;users
)paren
suffix:semicolon
id|header.length
op_assign
id|l
suffix:semicolon
id|header.type
op_assign
id|skb-&gt;protocol
suffix:semicolon
id|header.unused
op_assign
l_int|0
suffix:semicolon
id|memcpy
c_func
(paren
id|skb_push
c_func
(paren
id|skb
comma
id|LL_HEADER_LENGTH
)paren
comma
op_amp
id|header
comma
id|LL_HEADER_LENGTH
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|ch-&gt;collect_queue
comma
id|skb
)paren
suffix:semicolon
id|ch-&gt;collect_len
op_add_assign
id|l
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ch-&gt;collect_lock
comma
id|saveflags
)paren
suffix:semicolon
)brace
r_else
(brace
id|__u16
id|block_len
suffix:semicolon
r_int
id|ccw_idx
suffix:semicolon
multiline_comment|/**&n;&t;&t; * Protect skb against beeing free&squot;d by upper&n;&t;&t; * layers.&n;&t;&t; */
id|atomic_inc
c_func
(paren
op_amp
id|skb-&gt;users
)paren
suffix:semicolon
id|ch-&gt;prof.txlen
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|header.length
op_assign
id|skb-&gt;len
op_plus
id|LL_HEADER_LENGTH
suffix:semicolon
id|header.type
op_assign
id|skb-&gt;protocol
suffix:semicolon
id|header.unused
op_assign
l_int|0
suffix:semicolon
id|memcpy
c_func
(paren
id|skb_push
c_func
(paren
id|skb
comma
id|LL_HEADER_LENGTH
)paren
comma
op_amp
id|header
comma
id|LL_HEADER_LENGTH
)paren
suffix:semicolon
id|block_len
op_assign
id|skb-&gt;len
op_plus
l_int|2
suffix:semicolon
op_star
(paren
(paren
id|__u16
op_star
)paren
id|skb_push
c_func
(paren
id|skb
comma
l_int|2
)paren
)paren
op_assign
id|block_len
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|4
)braket
dot
id|count
op_assign
id|block_len
suffix:semicolon
r_if
c_cond
(paren
id|set_normalized_cda
c_func
(paren
op_amp
id|ch-&gt;ccw
(braket
l_int|4
)braket
comma
id|virt_to_phys
c_func
(paren
id|skb-&gt;data
)paren
)paren
)paren
(brace
multiline_comment|/**&n;&t;&t;&t; * idal allocation failed, try via copying to&n;&t;&t;&t; * trans_skb. trans_skb usually has a pre-allocated&n;&t;&t;&t; * idal.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ctc_checkalloc_buffer
c_func
(paren
id|ch
comma
l_int|1
)paren
)paren
(brace
multiline_comment|/**&n;&t;&t;&t;&t; * Remove our header. It gets added&n;&t;&t;&t;&t; * again on retransmit.&n;&t;&t;&t;&t; */
id|skb_pull
c_func
(paren
id|skb
comma
id|LL_HEADER_LENGTH
op_plus
l_int|2
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|ch-&gt;trans_skb-&gt;tail
op_assign
id|ch-&gt;trans_skb-&gt;data
suffix:semicolon
id|ch-&gt;trans_skb-&gt;len
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;ccw
(braket
l_int|1
)braket
dot
id|count
op_assign
id|skb-&gt;len
suffix:semicolon
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|ch-&gt;trans_skb
comma
id|skb-&gt;len
)paren
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|skb-&gt;users
)paren
suffix:semicolon
id|dev_kfree_skb_irq
c_func
(paren
id|skb
)paren
suffix:semicolon
id|ccw_idx
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|skb_queue_tail
c_func
(paren
op_amp
id|ch-&gt;io_queue
comma
id|skb
)paren
suffix:semicolon
id|ccw_idx
op_assign
l_int|3
suffix:semicolon
)brace
id|ch-&gt;retry
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
id|ctc_dump_skb
c_func
(paren
id|skb
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|fsm_newstate
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_STATE_TX
)paren
suffix:semicolon
id|fsm_addtimer
c_func
(paren
op_amp
id|ch-&gt;timer
comma
id|CTC_TIMEOUT_5SEC
comma
id|CH_EVENT_TIMER
comma
id|ch
)paren
suffix:semicolon
id|s390irq_spin_lock_irqsave
c_func
(paren
id|ch-&gt;irq
comma
id|saveflags
)paren
suffix:semicolon
id|ch-&gt;prof.send_stamp
op_assign
id|xtime
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ccw[%d].cda = %08x&bslash;n&quot;
comma
id|ccw_idx
op_plus
l_int|1
comma
id|ch-&gt;ccw
(braket
id|ccw_idx
op_plus
l_int|1
)braket
dot
id|cda
)paren
suffix:semicolon
macro_line|#endif
id|rc
op_assign
id|do_IO
c_func
(paren
id|ch-&gt;irq
comma
op_amp
id|ch-&gt;ccw
(braket
id|ccw_idx
)braket
comma
(paren
id|intparm_t
)paren
id|ch
comma
l_int|0xff
comma
l_int|0
)paren
suffix:semicolon
id|s390irq_spin_unlock_irqrestore
c_func
(paren
id|ch-&gt;irq
comma
id|saveflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccw_idx
op_eq
l_int|3
)paren
id|ch-&gt;prof.doios_single
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
id|fsm_deltimer
c_func
(paren
op_amp
id|ch-&gt;timer
)paren
suffix:semicolon
id|ccw_check_return_code
c_func
(paren
id|ch
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccw_idx
op_eq
l_int|3
)paren
id|skb_dequeue_tail
c_func
(paren
op_amp
id|ch-&gt;io_queue
)paren
suffix:semicolon
multiline_comment|/**&n;&t;&t;&t; * Remove our header. It gets added&n;&t;&t;&t; * again on retransmit.&n;&t;&t;&t; */
id|skb_pull
c_func
(paren
id|skb
comma
id|LL_HEADER_LENGTH
op_plus
l_int|2
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ccw_idx
op_eq
l_int|0
)paren
(brace
id|net_device
op_star
id|dev
op_assign
id|ch-&gt;netdev
suffix:semicolon
id|ctc_priv
op_star
id|privptr
op_assign
id|dev-&gt;priv
suffix:semicolon
id|privptr-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|privptr-&gt;stats.tx_bytes
op_add_assign
id|skb-&gt;len
op_minus
id|LL_HEADER_LENGTH
suffix:semicolon
)brace
)brace
)brace
r_return
id|rc
suffix:semicolon
)brace
"&f;"
multiline_comment|/**&n; * Interface API for upper network layers&n; *****************************************************************************/
multiline_comment|/**&n; * Open an interface.&n; * Called from generic network layer when ifconfig up is run.&n; *&n; * @param dev Pointer to interface struct.&n; *&n; * @return 0 on success, -ERRNO on failure. (Never fails.)&n; */
DECL|function|ctc_open
r_static
r_int
id|ctc_open
c_func
(paren
id|net_device
op_star
id|dev
)paren
(brace
id|MOD_INC_USE_COUNT
suffix:semicolon
id|fsm_event
c_func
(paren
(paren
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|fsm
comma
id|DEV_EVENT_START
comma
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Close an interface.&n; * Called from generic network layer when ifconfig down is run.&n; *&n; * @param dev Pointer to interface struct.&n; *&n; * @return 0 on success, -ERRNO on failure. (Never fails.)&n; */
DECL|function|ctc_close
r_static
r_int
id|ctc_close
c_func
(paren
id|net_device
op_star
id|dev
)paren
(brace
id|SET_DEVICE_START
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
id|fsm_event
c_func
(paren
(paren
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|fsm
comma
id|DEV_EVENT_STOP
comma
id|dev
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Start transmission of a packet.&n; * Called from generic network device layer.&n; *&n; * @param skb Pointer to buffer containing the packet.&n; * @param dev Pointer to interface struct.&n; *&n; * @return 0 if packet consumed, !0 if packet rejected.&n; *         Note: If we return !0, then the packet is free&squot;d by&n; *               the generic network layer.&n; */
DECL|function|ctc_tx
r_static
r_int
id|ctc_tx
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|ctc_priv
op_star
id|privptr
op_assign
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/**&n;&t; * Some sanity checks ...&n;&t; */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: NULL sk_buff passed&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|privptr-&gt;stats.tx_dropped
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb_headroom
c_func
(paren
id|skb
)paren
OL
(paren
id|LL_HEADER_LENGTH
op_plus
l_int|2
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Got sk_buff with head room &lt; %ld bytes&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|LL_HEADER_LENGTH
op_plus
l_int|2
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|privptr-&gt;stats.tx_dropped
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n;&t; * If channels are not running, try to restart them&n;&t; * notify anybody about a link failure and throw&n;&t; * away packet. &n;&t; */
r_if
c_cond
(paren
id|fsm_getstate
c_func
(paren
id|privptr-&gt;fsm
)paren
op_ne
id|DEV_STATE_RUNNING
)paren
(brace
id|fsm_event
c_func
(paren
id|privptr-&gt;fsm
comma
id|DEV_EVENT_START
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|privptr-&gt;protocol
op_eq
id|CTC_PROTO_LINUX_TTY
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|dst_link_failure
c_func
(paren
id|skb
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|privptr-&gt;stats.tx_dropped
op_increment
suffix:semicolon
id|privptr-&gt;stats.tx_errors
op_increment
suffix:semicolon
id|privptr-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctc_test_and_set_busy
c_func
(paren
id|dev
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|transmit_skb
c_func
(paren
id|privptr-&gt;channel
(braket
id|WRITE
)braket
comma
id|skb
)paren
op_ne
l_int|0
)paren
id|rc
op_assign
l_int|1
suffix:semicolon
id|ctc_clear_busy
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; * Sets MTU of an interface.&n; *&n; * @param dev     Pointer to interface struct.&n; * @param new_mtu The new MTU to use for this interface.&n; *&n; * @return 0 on success, -EINVAL if MTU is out of valid range.&n; *         (valid range is 576 .. 65527). If VM is on the&n; *         remote side, maximum MTU is 32760, however this is&n; *         &lt;em&gt;not&lt;/em&gt; checked here.&n; */
DECL|function|ctc_change_mtu
r_static
r_int
id|ctc_change_mtu
c_func
(paren
id|net_device
op_star
id|dev
comma
r_int
id|new_mtu
)paren
(brace
id|ctc_priv
op_star
id|privptr
op_assign
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
(paren
id|new_mtu
OL
l_int|576
)paren
op_logical_or
(paren
id|new_mtu
OG
l_int|65527
)paren
op_logical_or
(paren
id|new_mtu
OG
(paren
id|privptr-&gt;channel
(braket
id|READ
)braket
op_member_access_from_pointer
id|max_bufsize
op_minus
id|LL_HEADER_LENGTH
op_minus
l_int|2
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|dev-&gt;mtu
op_assign
id|new_mtu
suffix:semicolon
id|dev-&gt;hard_header_len
op_assign
id|LL_HEADER_LENGTH
op_plus
l_int|2
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Returns interface statistics of a device.&n; *&n; * @param dev Pointer to interface struct.&n; *&n; * @return Pointer to stats struct of this interface.&n; */
DECL|function|ctc_stats
r_static
r_struct
id|net_device_stats
op_star
id|ctc_stats
c_func
(paren
id|net_device
op_star
id|dev
)paren
(brace
r_return
op_amp
(paren
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|stats
suffix:semicolon
)brace
"&f;"
multiline_comment|/**&n; * procfs related structures and routines&n; *****************************************************************************/
DECL|function|find_netdev_by_ino
r_static
id|net_device
op_star
id|find_netdev_by_ino
c_func
(paren
r_int
r_int
id|ino
)paren
(brace
id|channel
op_star
id|ch
op_assign
id|channels
suffix:semicolon
id|net_device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
id|ctc_priv
op_star
id|privptr
suffix:semicolon
r_while
c_loop
(paren
id|ch
)paren
(brace
r_if
c_cond
(paren
id|ch-&gt;netdev
op_ne
id|dev
)paren
(brace
id|dev
op_assign
id|ch-&gt;netdev
suffix:semicolon
id|privptr
op_assign
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
(paren
id|privptr-&gt;proc_ctrl_entry-&gt;low_ino
op_eq
id|ino
)paren
op_logical_or
(paren
id|privptr-&gt;proc_stat_entry-&gt;low_ino
op_eq
id|ino
)paren
)paren
r_return
id|dev
suffix:semicolon
)brace
id|ch
op_assign
id|ch-&gt;next
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &lt; 0x020363
multiline_comment|/**&n; * Lock the module, if someone changes into&n; * our proc directory.&n; */
DECL|function|ctc_fill_inode
r_static
r_void
id|ctc_fill_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|fill
)paren
(brace
r_if
c_cond
(paren
id|fill
)paren
(brace
id|MOD_INC_USE_COUNT
suffix:semicolon
)brace
r_else
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
macro_line|#endif
DECL|macro|CTRL_BUFSIZE
mdefine_line|#define CTRL_BUFSIZE 40
DECL|function|ctc_ctrl_open
r_static
r_int
id|ctc_ctrl_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|file-&gt;private_data
op_assign
id|kmalloc
c_func
(paren
id|CTRL_BUFSIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;private_data
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ctc_ctrl_close
r_static
r_int
id|ctc_ctrl_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|kfree
c_func
(paren
id|file-&gt;private_data
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ctc_ctrl_write
r_static
id|ssize_t
id|ctc_ctrl_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|off
)paren
(brace
r_int
r_int
id|ino
op_assign
(paren
(paren
r_struct
id|inode
op_star
)paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
op_member_access_from_pointer
id|i_ino
suffix:semicolon
id|net_device
op_star
id|dev
suffix:semicolon
id|ctc_priv
op_star
id|privptr
suffix:semicolon
r_char
op_star
id|e
suffix:semicolon
r_int
id|bs1
suffix:semicolon
r_char
id|tmp
(braket
l_int|40
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev
op_assign
id|find_netdev_by_ino
c_func
(paren
id|ino
)paren
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|off
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
id|privptr
op_assign
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ge
l_int|39
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|tmp
comma
id|buf
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|tmp
(braket
id|count
op_plus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|bs1
op_assign
id|simple_strtoul
c_func
(paren
id|tmp
comma
op_amp
id|e
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bs1
OG
id|CTC_BUFSIZE_LIMIT
)paren
op_logical_or
(paren
id|e
op_logical_and
(paren
op_logical_neg
id|isspace
c_func
(paren
op_star
id|e
)paren
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_RUNNING
)paren
op_logical_and
(paren
id|bs1
OL
(paren
id|dev-&gt;mtu
op_plus
id|LL_HEADER_LENGTH
op_plus
l_int|2
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|bs1
OL
(paren
l_int|576
op_plus
id|LL_HEADER_LENGTH
op_plus
l_int|2
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|privptr-&gt;channel
(braket
id|READ
)braket
op_member_access_from_pointer
id|max_bufsize
op_assign
id|privptr-&gt;channel
(braket
id|WRITE
)braket
op_member_access_from_pointer
id|max_bufsize
op_assign
id|bs1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_RUNNING
)paren
)paren
id|dev-&gt;mtu
op_assign
id|bs1
op_minus
id|LL_HEADER_LENGTH
op_minus
l_int|2
suffix:semicolon
id|privptr-&gt;channel
(braket
id|READ
)braket
op_member_access_from_pointer
id|flags
op_or_assign
id|CHANNEL_FLAGS_BUFSIZE_CHANGED
suffix:semicolon
id|privptr-&gt;channel
(braket
id|WRITE
)braket
op_member_access_from_pointer
id|flags
op_or_assign
id|CHANNEL_FLAGS_BUFSIZE_CHANGED
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|function|ctc_ctrl_read
r_static
id|ssize_t
id|ctc_ctrl_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|off
)paren
(brace
r_int
r_int
id|ino
op_assign
(paren
(paren
r_struct
id|inode
op_star
)paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
op_member_access_from_pointer
id|i_ino
suffix:semicolon
r_char
op_star
id|sbuf
op_assign
(paren
r_char
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|net_device
op_star
id|dev
suffix:semicolon
id|ctc_priv
op_star
id|privptr
suffix:semicolon
id|ssize_t
id|ret
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|p
op_assign
id|sbuf
suffix:semicolon
r_int
id|l
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev
op_assign
id|find_netdev_by_ino
c_func
(paren
id|ino
)paren
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|off
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
id|privptr
op_assign
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_pos
op_eq
l_int|0
)paren
id|sprintf
c_func
(paren
id|sbuf
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|privptr-&gt;channel
(braket
id|READ
)braket
op_member_access_from_pointer
id|max_bufsize
)paren
suffix:semicolon
id|l
op_assign
id|strlen
c_func
(paren
id|sbuf
)paren
suffix:semicolon
id|p
op_assign
id|sbuf
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_pos
OL
id|l
)paren
(brace
id|p
op_add_assign
id|file-&gt;f_pos
suffix:semicolon
id|l
op_assign
id|strlen
c_func
(paren
id|p
)paren
suffix:semicolon
id|ret
op_assign
(paren
id|count
OG
id|l
)paren
ques
c_cond
id|l
suffix:colon
id|count
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|p
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|file-&gt;f_pos
op_add_assign
id|ret
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|macro|STATS_BUFSIZE
mdefine_line|#define STATS_BUFSIZE 2048
DECL|function|ctc_stat_open
r_static
r_int
id|ctc_stat_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|file-&gt;private_data
op_assign
id|kmalloc
c_func
(paren
id|STATS_BUFSIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;private_data
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ctc_stat_close
r_static
r_int
id|ctc_stat_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|kfree
c_func
(paren
id|file-&gt;private_data
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ctc_stat_write
r_static
id|ssize_t
id|ctc_stat_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|off
)paren
(brace
r_int
r_int
id|ino
op_assign
(paren
(paren
r_struct
id|inode
op_star
)paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
op_member_access_from_pointer
id|i_ino
suffix:semicolon
id|net_device
op_star
id|dev
suffix:semicolon
id|ctc_priv
op_star
id|privptr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev
op_assign
id|find_netdev_by_ino
c_func
(paren
id|ino
)paren
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|privptr
op_assign
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|privptr-&gt;channel
(braket
id|WRITE
)braket
op_member_access_from_pointer
id|prof.maxmulti
op_assign
l_int|0
suffix:semicolon
id|privptr-&gt;channel
(braket
id|WRITE
)braket
op_member_access_from_pointer
id|prof.maxcqueue
op_assign
l_int|0
suffix:semicolon
id|privptr-&gt;channel
(braket
id|WRITE
)braket
op_member_access_from_pointer
id|prof.doios_single
op_assign
l_int|0
suffix:semicolon
id|privptr-&gt;channel
(braket
id|WRITE
)braket
op_member_access_from_pointer
id|prof.doios_multi
op_assign
l_int|0
suffix:semicolon
id|privptr-&gt;channel
(braket
id|WRITE
)braket
op_member_access_from_pointer
id|prof.txlen
op_assign
l_int|0
suffix:semicolon
id|privptr-&gt;channel
(braket
id|WRITE
)braket
op_member_access_from_pointer
id|prof.tx_time
op_assign
l_int|0
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|function|ctc_stat_read
r_static
id|ssize_t
id|ctc_stat_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|off
)paren
(brace
r_int
r_int
id|ino
op_assign
(paren
(paren
r_struct
id|inode
op_star
)paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
op_member_access_from_pointer
id|i_ino
suffix:semicolon
r_char
op_star
id|sbuf
op_assign
(paren
r_char
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|net_device
op_star
id|dev
suffix:semicolon
id|ctc_priv
op_star
id|privptr
suffix:semicolon
id|ssize_t
id|ret
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|p
op_assign
id|sbuf
suffix:semicolon
r_int
id|l
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev
op_assign
id|find_netdev_by_ino
c_func
(paren
id|ino
)paren
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|off
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
id|privptr
op_assign
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_pos
op_eq
l_int|0
)paren
(brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Device FSM state: %s&bslash;n&quot;
comma
id|fsm_getstate_str
c_func
(paren
id|privptr-&gt;fsm
)paren
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;RX channel FSM state: %s&bslash;n&quot;
comma
id|fsm_getstate_str
c_func
(paren
id|privptr-&gt;channel
(braket
id|READ
)braket
op_member_access_from_pointer
id|fsm
)paren
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;TX channel FSM state: %s&bslash;n&quot;
comma
id|fsm_getstate_str
c_func
(paren
id|privptr-&gt;channel
(braket
id|WRITE
)braket
op_member_access_from_pointer
id|fsm
)paren
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Max. TX buffer used: %ld&bslash;n&quot;
comma
id|privptr-&gt;channel
(braket
id|WRITE
)braket
op_member_access_from_pointer
id|prof.maxmulti
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Max. chained SKBs: %ld&bslash;n&quot;
comma
id|privptr-&gt;channel
(braket
id|WRITE
)braket
op_member_access_from_pointer
id|prof.maxcqueue
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;TX single write ops: %ld&bslash;n&quot;
comma
id|privptr-&gt;channel
(braket
id|WRITE
)braket
op_member_access_from_pointer
id|prof.doios_single
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;TX multi write ops: %ld&bslash;n&quot;
comma
id|privptr-&gt;channel
(braket
id|WRITE
)braket
op_member_access_from_pointer
id|prof.doios_multi
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Netto bytes written: %ld&bslash;n&quot;
comma
id|privptr-&gt;channel
(braket
id|WRITE
)braket
op_member_access_from_pointer
id|prof.txlen
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;Max. TX IO-time: %ld&bslash;n&quot;
comma
id|privptr-&gt;channel
(braket
id|WRITE
)braket
op_member_access_from_pointer
id|prof.tx_time
)paren
suffix:semicolon
)brace
id|l
op_assign
id|strlen
c_func
(paren
id|sbuf
)paren
suffix:semicolon
id|p
op_assign
id|sbuf
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_pos
OL
id|l
)paren
(brace
id|p
op_add_assign
id|file-&gt;f_pos
suffix:semicolon
id|l
op_assign
id|strlen
c_func
(paren
id|p
)paren
suffix:semicolon
id|ret
op_assign
(paren
id|count
OG
id|l
)paren
ques
c_cond
id|l
suffix:colon
id|count
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|p
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|file-&gt;f_pos
op_add_assign
id|ret
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|ctc_stat_fops
r_static
r_struct
id|file_operations
id|ctc_stat_fops
op_assign
(brace
id|read
suffix:colon
id|ctc_stat_read
comma
id|write
suffix:colon
id|ctc_stat_write
comma
id|open
suffix:colon
id|ctc_stat_open
comma
id|release
suffix:colon
id|ctc_stat_close
comma
)brace
suffix:semicolon
DECL|variable|ctc_ctrl_fops
r_static
r_struct
id|file_operations
id|ctc_ctrl_fops
op_assign
(brace
id|read
suffix:colon
id|ctc_ctrl_read
comma
id|write
suffix:colon
id|ctc_ctrl_write
comma
id|open
suffix:colon
id|ctc_ctrl_open
comma
id|release
suffix:colon
id|ctc_ctrl_close
comma
)brace
suffix:semicolon
DECL|variable|ctc_stat_iops
r_static
r_struct
id|inode_operations
id|ctc_stat_iops
op_assign
(brace
macro_line|#if LINUX_VERSION_CODE &lt; 0x020363
id|default_file_ops
suffix:colon
op_amp
id|ctc_stat_fops
macro_line|#endif
)brace
suffix:semicolon
DECL|variable|ctc_ctrl_iops
r_static
r_struct
id|inode_operations
id|ctc_ctrl_iops
op_assign
(brace
macro_line|#if LINUX_VERSION_CODE &lt; 0x020363
id|default_file_ops
suffix:colon
op_amp
id|ctc_ctrl_fops
macro_line|#endif
)brace
suffix:semicolon
DECL|variable|stat_entry
r_static
r_struct
id|proc_dir_entry
id|stat_entry
op_assign
(brace
l_int|0
comma
multiline_comment|/* low_ino */
l_int|10
comma
multiline_comment|/* namelen */
l_string|&quot;statistics&quot;
comma
multiline_comment|/* name    */
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
comma
multiline_comment|/* mode    */
l_int|1
comma
multiline_comment|/* nlink   */
l_int|0
comma
multiline_comment|/* uid     */
l_int|0
comma
multiline_comment|/* gid     */
l_int|0
comma
multiline_comment|/* size    */
op_amp
id|ctc_stat_iops
multiline_comment|/* ops     */
)brace
suffix:semicolon
DECL|variable|ctrl_entry
r_static
r_struct
id|proc_dir_entry
id|ctrl_entry
op_assign
(brace
l_int|0
comma
multiline_comment|/* low_ino */
l_int|10
comma
multiline_comment|/* namelen */
l_string|&quot;buffersize&quot;
comma
multiline_comment|/* name    */
id|S_IFREG
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
multiline_comment|/* mode    */
l_int|1
comma
multiline_comment|/* nlink   */
l_int|0
comma
multiline_comment|/* uid     */
l_int|0
comma
multiline_comment|/* gid     */
l_int|0
comma
multiline_comment|/* size    */
op_amp
id|ctc_ctrl_iops
multiline_comment|/* ops     */
)brace
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; 0x020363
DECL|variable|ctc_dir
r_static
r_struct
id|proc_dir_entry
id|ctc_dir
op_assign
(brace
l_int|0
comma
multiline_comment|/* low_ino  */
l_int|3
comma
multiline_comment|/* namelen  */
l_string|&quot;ctc&quot;
comma
multiline_comment|/* name     */
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
comma
multiline_comment|/* mode     */
l_int|2
comma
multiline_comment|/* nlink    */
l_int|0
comma
multiline_comment|/* uid      */
l_int|0
comma
multiline_comment|/* gid      */
l_int|0
comma
multiline_comment|/* size     */
l_int|0
comma
multiline_comment|/* ops      */
l_int|0
comma
multiline_comment|/* get_info */
id|ctc_fill_inode
multiline_comment|/* fill_ino (for locking) */
)brace
suffix:semicolon
DECL|variable|ctc_template
r_static
r_struct
id|proc_dir_entry
id|ctc_template
op_assign
(brace
l_int|0
comma
multiline_comment|/* low_ino  */
l_int|0
comma
multiline_comment|/* namelen  */
l_string|&quot;&quot;
comma
multiline_comment|/* name     */
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
comma
multiline_comment|/* mode     */
l_int|2
comma
multiline_comment|/* nlink    */
l_int|0
comma
multiline_comment|/* uid      */
l_int|0
comma
multiline_comment|/* gid      */
l_int|0
comma
multiline_comment|/* size     */
l_int|0
comma
multiline_comment|/* ops      */
l_int|0
comma
multiline_comment|/* get_info */
id|ctc_fill_inode
multiline_comment|/* fill_ino (for locking) */
)brace
suffix:semicolon
macro_line|#else
DECL|variable|ctc_dir
r_static
r_struct
id|proc_dir_entry
op_star
id|ctc_dir
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|ctc_template
r_static
r_struct
id|proc_dir_entry
op_star
id|ctc_template
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
multiline_comment|/**&n; * Create the driver&squot;s main directory /proc/net/ctc&n; */
DECL|function|ctc_proc_create_main
r_static
r_void
id|ctc_proc_create_main
c_func
(paren
r_void
)paren
(brace
multiline_comment|/**&n;&t; * If not registered, register main proc dir-entry now&n;&t; */
macro_line|#if LINUX_VERSION_CODE &gt; 0x020362
r_if
c_cond
(paren
op_logical_neg
id|ctc_dir
)paren
id|ctc_dir
op_assign
id|proc_mkdir
c_func
(paren
l_string|&quot;ctc&quot;
comma
id|proc_net
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|ctc_dir.low_ino
op_eq
l_int|0
)paren
id|proc_net_register
c_func
(paren
op_amp
id|ctc_dir
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef MODULE
multiline_comment|/**&n; * Destroy /proc/net/ctc&n; */
DECL|function|ctc_proc_destroy_main
r_static
r_void
id|ctc_proc_destroy_main
c_func
(paren
r_void
)paren
(brace
macro_line|#if LINUX_VERSION_CODE &gt; 0x020362
id|remove_proc_entry
c_func
(paren
l_string|&quot;ctc&quot;
comma
id|proc_net
)paren
suffix:semicolon
macro_line|#else
id|proc_net_unregister
c_func
(paren
id|ctc_dir.low_ino
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif MODULE
multiline_comment|/**&n; * Create a device specific subdirectory in /proc/net/ctc/ with the&n; * same name like the device. In that directory, create 2 entries&n; * &quot;statistics&quot; and &quot;buffersize&quot;.&n; *&n; * @param dev The device for which the subdirectory should be created.&n; *&n; */
DECL|function|ctc_proc_create_sub
r_static
r_void
id|ctc_proc_create_sub
c_func
(paren
id|net_device
op_star
id|dev
)paren
(brace
id|ctc_priv
op_star
id|privptr
op_assign
id|dev-&gt;priv
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt; 0x020362
id|privptr-&gt;proc_dentry
op_assign
id|proc_mkdir
c_func
(paren
id|dev-&gt;name
comma
id|ctc_dir
)paren
suffix:semicolon
id|privptr-&gt;proc_stat_entry
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;statistics&quot;
comma
id|S_IFREG
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
id|privptr-&gt;proc_dentry
)paren
suffix:semicolon
id|privptr-&gt;proc_stat_entry-&gt;proc_fops
op_assign
op_amp
id|ctc_stat_fops
suffix:semicolon
id|privptr-&gt;proc_stat_entry-&gt;proc_iops
op_assign
op_amp
id|ctc_stat_iops
suffix:semicolon
id|privptr-&gt;proc_ctrl_entry
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;buffersize&quot;
comma
id|S_IFREG
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
id|privptr-&gt;proc_dentry
)paren
suffix:semicolon
id|privptr-&gt;proc_ctrl_entry-&gt;proc_fops
op_assign
op_amp
id|ctc_ctrl_fops
suffix:semicolon
id|privptr-&gt;proc_ctrl_entry-&gt;proc_iops
op_assign
op_amp
id|ctc_ctrl_iops
suffix:semicolon
macro_line|#else
id|privptr-&gt;proc_dentry-&gt;name
op_assign
id|dev-&gt;name
suffix:semicolon
id|privptr-&gt;proc_dentry-&gt;namelen
op_assign
id|strlen
c_func
(paren
id|dev-&gt;name
)paren
suffix:semicolon
id|proc_register
c_func
(paren
op_amp
id|ctc_dir
comma
id|privptr-&gt;proc_dentry
)paren
suffix:semicolon
id|proc_register
c_func
(paren
id|privptr-&gt;proc_dentry
comma
id|privptr-&gt;proc_stat_entry
)paren
suffix:semicolon
id|proc_register
c_func
(paren
id|privptr-&gt;proc_dentry
comma
id|privptr-&gt;proc_ctrl_entry
)paren
suffix:semicolon
macro_line|#endif
id|privptr-&gt;proc_registered
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * Destroy a device specific subdirectory.&n; *&n; * @param privptr Pointer to device private data.&n; */
DECL|function|ctc_proc_destroy_sub
r_static
r_void
id|ctc_proc_destroy_sub
c_func
(paren
id|ctc_priv
op_star
id|privptr
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|privptr-&gt;proc_registered
)paren
r_return
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt; 0x020362
id|remove_proc_entry
c_func
(paren
l_string|&quot;statistics&quot;
comma
id|privptr-&gt;proc_dentry
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;buffersize&quot;
comma
id|privptr-&gt;proc_dentry
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|privptr-&gt;proc_dentry-&gt;name
comma
id|ctc_dir
)paren
suffix:semicolon
macro_line|#else
id|proc_unregister
c_func
(paren
id|privptr-&gt;proc_dentry
comma
id|privptr-&gt;proc_stat_entry-&gt;low_ino
)paren
suffix:semicolon
id|proc_unregister
c_func
(paren
id|privptr-&gt;proc_dentry
comma
id|privptr-&gt;proc_ctrl_entry-&gt;low_ino
)paren
suffix:semicolon
id|proc_unregister
c_func
(paren
op_amp
id|ctc_dir
comma
id|privptr-&gt;proc_dentry-&gt;low_ino
)paren
suffix:semicolon
macro_line|#endif
id|privptr-&gt;proc_registered
op_assign
l_int|0
suffix:semicolon
)brace
"&f;"
macro_line|#ifndef CTC_CHANDEV
multiline_comment|/**&n; * Setup related routines&n; *****************************************************************************/
multiline_comment|/**&n; * Parse a portion of the setup string describing a single device or option&n; * providing the following syntax:&n; *&n; * [Device/OptionName[:int1][:int2][:int3]]&n; *&n; *&n; * @param setup    Pointer to a pointer to the remainder of the parameter&n; *                 string to be parsed. On return, the content of this&n; *                 pointer is updated to point to the first character after&n; *                 the parsed portion (e.g. possible start of next portion)&n; *                 NOTE: The string pointed to must be writeable, since a&n; *                 &bslash;0 is written for termination of the device/option name.&n; *&n; * @param dev_name Pointer to a pointer to the name of the device whose&n; *                 parameters are parsed. On return, this is set to the&n; *                 name of the device/option.&n; *&n; * @param ints     Pointer to an array of integer parameters. On return,&n; *                 element 0 is set to the number of parameters found.&n; *&n; * @param maxip    Maximum number of ints to parse.&n; *                 (ints[] must have size maxip+1)&n; *&n; * @return     0 if string &quot;setup&quot; was empty, !=0 otherwise&n; */
DECL|function|parse_opts
r_static
r_int
id|parse_opts
c_func
(paren
r_char
op_star
op_star
id|setup
comma
r_char
op_star
op_star
id|dev_name
comma
r_int
op_star
id|ints
comma
r_int
id|maxip
)paren
(brace
r_char
op_star
id|cur
op_assign
op_star
id|setup
suffix:semicolon
r_int
id|i
op_assign
l_int|1
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|in_name
op_assign
l_int|1
suffix:semicolon
r_int
id|noauto
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ctc: parse_opts(): *setup=&squot;%s&squot;, maxip=%d&bslash;n&quot;
comma
op_star
id|setup
comma
id|maxip
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_star
id|setup
)paren
(brace
op_star
id|dev_name
op_assign
op_star
id|setup
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;ctc&quot;
comma
l_int|3
)paren
op_logical_and
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;escon&quot;
comma
l_int|5
)paren
op_logical_and
id|strncmp
c_func
(paren
id|cur
comma
l_string|&quot;noauto&quot;
comma
l_int|6
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|setup
op_assign
id|strchr
c_func
(paren
id|cur
comma
l_char|&squot;:&squot;
)paren
)paren
)paren
op_star
(paren
op_star
id|setup
)paren
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc: Invalid device name or option &squot;%s&squot;&bslash;n&quot;
comma
id|cur
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_switch
c_cond
(paren
op_star
id|cur
)paren
(brace
r_case
l_char|&squot;c&squot;
suffix:colon
id|cur
op_add_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;e&squot;
suffix:colon
id|cur
op_add_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
id|cur
op_add_assign
l_int|6
suffix:semicolon
op_star
id|cur
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|noauto
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|noauto
)paren
(brace
r_while
c_loop
(paren
id|cur
op_logical_and
(paren
op_star
id|cur
op_eq
l_char|&squot;-&squot;
op_logical_or
id|isdigit
c_func
(paren
op_star
id|cur
)paren
)paren
op_logical_and
id|i
op_le
id|maxip
)paren
(brace
r_if
c_cond
(paren
id|in_name
)paren
(brace
id|cur
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|cur
op_eq
l_char|&squot;:&squot;
)paren
(brace
op_star
id|cur
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|in_name
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|ints
(braket
id|i
op_increment
)braket
op_assign
id|simple_strtoul
c_func
(paren
id|cur
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ctc: %s: ints[%d]=%d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|i
op_minus
l_int|1
comma
id|ints
(braket
id|i
op_minus
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|cur
op_assign
id|strchr
c_func
(paren
id|cur
comma
l_char|&squot;:&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
id|cur
op_increment
suffix:semicolon
)brace
)brace
)brace
id|ints
(braket
l_int|0
)braket
op_assign
id|i
op_minus
l_int|1
suffix:semicolon
op_star
id|setup
op_assign
id|cur
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_logical_and
(paren
op_star
id|cur
op_eq
l_char|&squot;:&squot;
)paren
)paren
(paren
op_star
id|setup
)paren
op_increment
suffix:semicolon
id|rc
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; *&n; * Allocate one param struct&n; *&n; * If the driver is loaded as a module this functions is called during&n; *   module set up and we can allocate the struct by using kmalloc()&n; *&n; * If the driver is statically linked into the kernel this function is called&n; * when kmalloc() is not yet available so we must allocate from a static array&n; *&n; */
macro_line|#ifdef MODULE
DECL|macro|alloc_param
mdefine_line|#define alloc_param() ((param *)kmalloc(sizeof(param), GFP_KERNEL));
macro_line|#else
DECL|variable|parms_array
r_static
id|param
id|parms_array
(braket
id|MAX_STATIC_DEVICES
)braket
suffix:semicolon
DECL|variable|next_param
r_static
id|param
op_star
id|next_param
op_assign
id|parms_array
suffix:semicolon
DECL|macro|alloc_param
mdefine_line|#define alloc_param() &bslash;&n;        ((next_param&lt;parms_array+MAX_STATIC_DEVICES)?next_param++:NULL)
macro_line|#endif MODULE
multiline_comment|/**&n; * Returns commandline parameter using device name as key.&n; *&n; * @param name Name of interface to get parameters from.&n; *&n; * @return Pointer to corresponting param struct, NULL if not found.&n; */
DECL|function|find_param
r_static
id|param
op_star
id|find_param
c_func
(paren
r_char
op_star
id|name
)paren
(brace
id|param
op_star
id|p
op_assign
id|params
suffix:semicolon
r_while
c_loop
(paren
id|p
op_logical_and
id|strcmp
c_func
(paren
id|p-&gt;name
comma
id|name
)paren
)paren
id|p
op_assign
id|p-&gt;next
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
multiline_comment|/**&n; * maximum number of integer parametes that may be specified&n; * for one device in the setup string&n; */
DECL|macro|CTC_MAX_INTPARMS
mdefine_line|#define CTC_MAX_INTPARMS 3
multiline_comment|/**&n; * Parse configuration options for all interfaces.&n; *&n; * This function is called from two possible locations:&n; *  - If built as module, this function is called from init_module().&n; *  - If built in monolithic kernel, this function is called from within&n; *    init/main.c.&n; * Parsing is always done here.&n; *&n; * Valid parameters are:&n; *&n; *&n; *   [NAME[:0xRRRR[:0xWWWW[:P]]]]&n; *&n; *     where P       is the channel protocol (always 0)&n; *&t;      0xRRRR is the cu number for the read channel&n; *&t;      0xWWWW is the cu number for the write channel&n; *&t;      NAME   is either ctc0 ... ctcN for CTC/A&n; *                      or     escon0 ... esconN for Escon.&n; *                      or     noauto&n; *                             which switches off auto-detection of channels.&n; *&n; * @param setup    The parameter string to parse. MUST be writeable!&n; * @param ints     Pointer to an array of ints. Only for kernel 2.2,&n; *                 builtin (not module) version. With kernel 2.2,&n; *                 normally all integer-parameters, preceeding some&n; *                 configuration-string are pre-parsed in init/main.c&n; *                 and handed over here.&n; *                 To simplify 2.2/2.4 compatibility, by definition,&n; *                 our parameters always start with a string and ints&n; *                 is always unset and ignored.&n; */
macro_line|#ifdef MODULE
DECL|function|ctc_setup
r_static
r_void
id|ctc_setup
c_func
(paren
r_char
op_star
id|setup
)paren
DECL|macro|ctc_setup_return
macro_line|#  define ctc_setup_return return
macro_line|#else MODULE
macro_line|#  if LINUX_VERSION_CODE &lt; 0x020300
id|__initfunc
c_func
(paren
r_void
id|ctc_setup
c_func
(paren
r_char
op_star
id|setup
comma
r_int
op_star
id|ints
)paren
)paren
macro_line|#    define ctc_setup_return return
macro_line|#    define ints local_ints
macro_line|#  else
r_static
r_int
id|__init
id|ctc_setup
c_func
(paren
r_char
op_star
id|setup
)paren
macro_line|#    define ctc_setup_return return(1)
macro_line|#  endif
macro_line|#endif MODULE
(brace
r_int
id|write_dev
suffix:semicolon
r_int
id|read_dev
suffix:semicolon
r_int
id|proto
suffix:semicolon
id|param
op_star
id|par
suffix:semicolon
r_char
op_star
id|dev_name
suffix:semicolon
r_int
id|ints
(braket
id|CTC_MAX_INTPARMS
op_plus
l_int|1
)braket
suffix:semicolon
r_while
c_loop
(paren
id|parse_opts
c_func
(paren
op_amp
id|setup
comma
op_amp
id|dev_name
comma
id|ints
comma
id|CTC_MAX_INTPARMS
)paren
)paren
(brace
id|write_dev
op_assign
op_minus
l_int|1
suffix:semicolon
id|read_dev
op_assign
op_minus
l_int|1
suffix:semicolon
id|proto
op_assign
id|CTC_PROTO_S390
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ctc: ctc_setup(): setup=&squot;%s&squot; dev_name=&squot;%s&squot;,&quot;
l_string|&quot; ints[0]=%d)&bslash;n&quot;
comma
id|setup
comma
id|dev_name
comma
id|ints
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#endif DEBUG
r_if
c_cond
(paren
id|dev_name
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/**&n;&t;&t;&t; * happens if device name is not specified in&n;&t;&t;&t; * parameter line (cf. init/main.c:get_options()&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc: %s(): Device name not specified&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|ctc_setup_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;name=&#xfffd;%s&#xfffd; argc=%d&bslash;n&quot;
comma
id|dev_name
comma
id|ints
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|dev_name
comma
l_string|&quot;noauto&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ctc: autoprobing disabled&bslash;n&quot;
)paren
suffix:semicolon
id|ctc_no_auto
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|find_param
c_func
(paren
id|dev_name
)paren
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc: Definition for device %s already set. &quot;
l_string|&quot;Ignoring second definition&bslash;n&quot;
comma
id|dev_name
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|ints
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|3
suffix:colon
multiline_comment|/* protocol type passed */
id|proto
op_assign
id|ints
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
id|proto
OG
id|CTC_PROTO_MAX
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: wrong protocol type &quot;
l_string|&quot;passed&bslash;n&quot;
comma
id|dev_name
)paren
suffix:semicolon
id|ctc_setup_return
suffix:semicolon
)brace
r_case
l_int|2
suffix:colon
multiline_comment|/* write channel passed */
id|write_dev
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* read channel passed */
id|read_dev
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|write_dev
op_eq
op_minus
l_int|1
)paren
id|write_dev
op_assign
id|read_dev
op_plus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc: wrong number of parameter &quot;
l_string|&quot;passed (is: %d, expected: [1..3]&bslash;n&quot;
comma
id|ints
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|ctc_setup_return
suffix:semicolon
)brace
id|par
op_assign
id|alloc_param
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|par
)paren
(brace
macro_line|#ifdef MODULE
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc: Couldn&squot;t allocate setup param block&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc: Number of device definitions in &quot;
l_string|&quot; kernel commandline exceeds builtin limit &quot;
l_string|&quot; of %d devices.&bslash;n&quot;
comma
id|MAX_STATIC_DEVICES
)paren
suffix:semicolon
macro_line|#endif
id|ctc_setup_return
suffix:semicolon
)brace
id|par-&gt;read_dev
op_assign
id|read_dev
suffix:semicolon
id|par-&gt;write_dev
op_assign
id|write_dev
suffix:semicolon
id|par-&gt;proto
op_assign
id|proto
suffix:semicolon
id|strncpy
c_func
(paren
id|par-&gt;name
comma
id|dev_name
comma
id|MAX_PARAM_NAME_LEN
)paren
suffix:semicolon
id|par-&gt;next
op_assign
id|params
suffix:semicolon
id|params
op_assign
id|par
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: protocol=%x read=%04x write=%04x&bslash;n&quot;
comma
id|dev_name
comma
id|proto
comma
id|read_dev
comma
id|write_dev
)paren
suffix:semicolon
macro_line|#endif
)brace
id|ctc_setup_return
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &gt;= 0x020300
id|__setup
c_func
(paren
l_string|&quot;ctc=&quot;
comma
id|ctc_setup
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif /* !CTC_CHANDEV */
"&f;"
r_static
r_void
DECL|function|ctc_netdev_unregister
id|ctc_netdev_unregister
c_func
(paren
id|net_device
op_star
id|dev
)paren
(brace
id|ctc_priv
op_star
id|privptr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
suffix:semicolon
id|privptr
op_assign
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|privptr-&gt;protocol
op_ne
id|CTC_PROTO_LINUX_TTY
)paren
id|unregister_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_else
id|ctc_tty_unregister_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|ctc_netdev_register
id|ctc_netdev_register
c_func
(paren
id|net_device
op_star
id|dev
)paren
(brace
id|ctc_priv
op_star
id|privptr
op_assign
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|privptr-&gt;protocol
op_ne
id|CTC_PROTO_LINUX_TTY
)paren
r_return
id|register_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_else
r_return
id|ctc_tty_register_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ctc_free_netdevice
id|ctc_free_netdevice
c_func
(paren
id|net_device
op_star
id|dev
comma
r_int
id|free_dev
)paren
(brace
id|ctc_priv
op_star
id|privptr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
suffix:semicolon
id|privptr
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|privptr
)paren
(brace
r_if
c_cond
(paren
id|privptr-&gt;fsm
)paren
id|kfree_fsm
c_func
(paren
id|privptr-&gt;fsm
)paren
suffix:semicolon
id|ctc_proc_destroy_sub
c_func
(paren
id|privptr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|privptr
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
r_if
c_cond
(paren
id|free_dev
)paren
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef CTC_CHANDEV
r_static
r_int
DECL|function|ctc_shutdown
id|ctc_shutdown
c_func
(paren
id|net_device
op_star
id|dev
)paren
(brace
id|ctc_priv
op_star
id|privptr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
l_int|0
suffix:semicolon
id|privptr
op_assign
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|channel_remove
c_func
(paren
id|privptr-&gt;channel
(braket
id|READ
)braket
)paren
suffix:semicolon
id|channel_remove
c_func
(paren
id|privptr-&gt;channel
(braket
id|WRITE
)braket
)paren
suffix:semicolon
id|ctc_free_netdevice
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**&n; * Initialize everything of the net device except the name and the&n; * channel structs.&n; */
r_static
id|net_device
op_star
DECL|function|ctc_init_netdevice
id|ctc_init_netdevice
c_func
(paren
id|net_device
op_star
id|dev
comma
r_int
id|alloc_device
)paren
(brace
id|ctc_priv
op_star
id|privptr
suffix:semicolon
r_int
id|priv_size
suffix:semicolon
r_if
c_cond
(paren
id|alloc_device
)paren
(brace
id|dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|net_device
)paren
macro_line|#if LINUX_VERSION_CODE &lt; 0x020300
op_plus
l_int|11
multiline_comment|/* name + zero */
macro_line|#endif
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
id|net_device
)paren
)paren
suffix:semicolon
)brace
id|priv_size
op_assign
r_sizeof
(paren
id|ctc_priv
)paren
op_plus
r_sizeof
(paren
id|ctc_template
)paren
op_plus
r_sizeof
(paren
id|stat_entry
)paren
op_plus
r_sizeof
(paren
id|ctrl_entry
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
id|priv_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|alloc_device
)paren
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
id|priv_size
)paren
suffix:semicolon
id|privptr
op_assign
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|privptr-&gt;proc_dentry
op_assign
(paren
r_struct
id|proc_dir_entry
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|privptr
)paren
op_plus
r_sizeof
(paren
id|ctc_priv
)paren
)paren
suffix:semicolon
id|privptr-&gt;proc_stat_entry
op_assign
(paren
r_struct
id|proc_dir_entry
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|privptr
)paren
op_plus
r_sizeof
(paren
id|ctc_priv
)paren
op_plus
r_sizeof
(paren
id|ctc_template
)paren
)paren
suffix:semicolon
id|privptr-&gt;proc_ctrl_entry
op_assign
(paren
r_struct
id|proc_dir_entry
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|privptr
)paren
op_plus
r_sizeof
(paren
id|ctc_priv
)paren
op_plus
r_sizeof
(paren
id|ctc_template
)paren
op_plus
r_sizeof
(paren
id|stat_entry
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|privptr-&gt;proc_dentry
comma
op_amp
id|ctc_template
comma
r_sizeof
(paren
id|ctc_template
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|privptr-&gt;proc_stat_entry
comma
op_amp
id|stat_entry
comma
r_sizeof
(paren
id|stat_entry
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|privptr-&gt;proc_ctrl_entry
comma
op_amp
id|ctrl_entry
comma
r_sizeof
(paren
id|ctrl_entry
)paren
)paren
suffix:semicolon
id|privptr-&gt;fsm
op_assign
id|init_fsm
c_func
(paren
l_string|&quot;ctcdev&quot;
comma
id|dev_state_names
comma
id|dev_event_names
comma
id|NR_DEV_STATES
comma
id|NR_DEV_EVENTS
comma
id|dev_fsm
comma
id|DEV_FSM_LEN
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|privptr-&gt;fsm
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|privptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|alloc_device
)paren
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|fsm_newstate
c_func
(paren
id|privptr-&gt;fsm
comma
id|DEV_STATE_STOPPED
)paren
suffix:semicolon
id|dev-&gt;mtu
op_assign
id|CTC_BUFSIZE_DEFAULT
op_minus
id|LL_HEADER_LENGTH
op_minus
l_int|2
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|ctc_tx
suffix:semicolon
id|dev-&gt;open
op_assign
id|ctc_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|ctc_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|ctc_stats
suffix:semicolon
id|dev-&gt;change_mtu
op_assign
id|ctc_change_mtu
suffix:semicolon
id|dev-&gt;hard_header_len
op_assign
id|LL_HEADER_LENGTH
op_plus
l_int|2
suffix:semicolon
id|dev-&gt;addr_len
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;type
op_assign
id|ARPHRD_SLIP
suffix:semicolon
id|dev-&gt;tx_queue_len
op_assign
l_int|100
suffix:semicolon
id|SET_DEVICE_START
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|dev_init_buffers
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;flags
op_assign
id|IFF_POINTOPOINT
op_or
id|IFF_NOARP
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
macro_line|#ifdef CTC_CHANDEV
r_static
r_void
DECL|function|ctc_chandev_msck_notify
id|ctc_chandev_msck_notify
c_func
(paren
r_void
op_star
id|dev
comma
r_int
id|msck_irq
comma
id|chandev_msck_status
id|prevstatus
comma
id|chandev_msck_status
id|newstatus
)paren
(brace
id|net_device
op_star
id|device
op_assign
(paren
id|net_device
op_star
)paren
id|dev
suffix:semicolon
id|ctc_priv
op_star
id|privptr
suffix:semicolon
r_int
id|direction
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
suffix:semicolon
id|privptr
op_assign
id|device-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|prevstatus
op_eq
id|chandev_status_revalidate
)paren
r_for
c_loop
(paren
id|direction
op_assign
id|READ
suffix:semicolon
id|direction
op_le
id|WRITE
suffix:semicolon
id|direction
op_increment
)paren
(brace
id|channel
op_star
id|ch
op_assign
id|privptr-&gt;channel
(braket
id|direction
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;irq
op_eq
id|msck_irq
)paren
(brace
id|s390_dev_info_t
id|devinfo
suffix:semicolon
r_if
c_cond
(paren
id|get_dev_info_by_irq
c_func
(paren
id|ch-&gt;irq
comma
op_amp
id|devinfo
)paren
)paren
id|ch-&gt;devno
op_assign
id|devinfo.devno
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc_chandev_msck_notify: &quot;
l_string|&quot;get_dev_info_by_irq failed for &quot;
l_string|&quot;irq %d&bslash;n&quot;
comma
id|ch-&gt;irq
)paren
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|newstatus
)paren
(brace
r_case
id|chandev_status_not_oper
suffix:colon
r_case
id|chandev_status_no_path
suffix:colon
r_case
id|chandev_status_gone
suffix:colon
r_for
c_loop
(paren
id|direction
op_assign
id|READ
suffix:semicolon
id|direction
op_le
id|WRITE
suffix:semicolon
id|direction
op_increment
)paren
(brace
id|channel
op_star
id|ch
op_assign
id|privptr-&gt;channel
(braket
id|direction
)braket
suffix:semicolon
id|fsm_event
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_EVENT_MC_FAIL
comma
id|ch
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc: %s channel deactivated&bslash;n&quot;
comma
id|device-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|chandev_status_all_chans_good
suffix:colon
r_for
c_loop
(paren
id|direction
op_assign
id|READ
suffix:semicolon
id|direction
op_le
id|WRITE
suffix:semicolon
id|direction
op_increment
)paren
(brace
id|channel
op_star
id|ch
op_assign
id|privptr-&gt;channel
(braket
id|direction
)braket
suffix:semicolon
id|fsm_event
c_func
(paren
id|ch-&gt;fsm
comma
id|CH_EVENT_MC_GOOD
comma
id|ch
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc: %s channel activated&bslash;n&quot;
comma
id|device-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&n; * Setup an interface.&n; *&n; * Like ctc_setup(), ctc_probe() can be called from two different locations:&n; *  - If built as module, it is called from within init_module().&n; *  - If built in monolithic kernel, it is called from within generic network&n; *    layer during initialization for every corresponding device, declared in&n; *    drivers/net/Space.c&n; *&n; * @param dev Pointer to net_device to be initialized.&n; *&n; * @returns 0 on success, !0 on failure.&n; */
DECL|function|ctc_chandev_probe
r_static
r_int
id|ctc_chandev_probe
c_func
(paren
id|chandev_probeinfo
op_star
id|info
)paren
(brace
r_int
id|devno
(braket
l_int|2
)braket
suffix:semicolon
id|__u16
id|proto
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_int
id|direction
suffix:semicolon
id|channel_type_t
id|type
suffix:semicolon
id|ctc_priv
op_star
id|privptr
suffix:semicolon
id|net_device
op_star
id|dev
suffix:semicolon
id|ctc_proc_create_main
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|info-&gt;chan_type
)paren
(brace
r_case
id|chandev_type_ctc
suffix:colon
id|type
op_assign
id|channel_type_ctca
suffix:semicolon
r_break
suffix:semicolon
r_case
id|chandev_type_escon
suffix:colon
id|type
op_assign
id|channel_type_escon
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc_chandev_probe called with &quot;
l_string|&quot;unsupported channel type %d&bslash;n&quot;
comma
id|info-&gt;chan_type
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|devno
(braket
id|READ
)braket
op_assign
id|info-&gt;read.devno
suffix:semicolon
id|devno
(braket
id|WRITE
)braket
op_assign
id|info-&gt;write.devno
suffix:semicolon
id|proto
op_assign
id|info-&gt;port_protocol_no
suffix:semicolon
r_if
c_cond
(paren
id|add_channel
c_func
(paren
id|info-&gt;read.irq
comma
id|info-&gt;read.devno
comma
id|type
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|add_channel
c_func
(paren
id|info-&gt;write.irq
comma
id|info-&gt;write.devno
comma
id|type
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|dev
op_assign
id|ctc_init_netdevice
c_func
(paren
l_int|NULL
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc_init_netdevice failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|proto
op_eq
id|CTC_PROTO_LINUX_TTY
)paren
id|chandev_build_device_name
c_func
(paren
id|info
comma
id|dev-&gt;name
comma
l_string|&quot;ctctty&quot;
comma
l_int|1
)paren
suffix:semicolon
r_else
id|chandev_build_device_name
c_func
(paren
id|info
comma
id|dev-&gt;name
comma
l_string|&quot;ctc&quot;
comma
l_int|1
)paren
suffix:semicolon
id|privptr
op_assign
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|privptr-&gt;protocol
op_assign
id|proto
suffix:semicolon
r_for
c_loop
(paren
id|direction
op_assign
id|READ
suffix:semicolon
id|direction
op_le
id|WRITE
suffix:semicolon
id|direction
op_increment
)paren
(brace
id|privptr-&gt;channel
(braket
id|direction
)braket
op_assign
id|channel_get
c_func
(paren
id|type
comma
id|devno
(braket
id|direction
)braket
comma
id|direction
)paren
suffix:semicolon
r_if
c_cond
(paren
id|privptr-&gt;channel
(braket
id|direction
)braket
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|direction
op_eq
id|WRITE
)paren
(brace
id|FREE_IRQ
c_func
(paren
id|privptr-&gt;channel
(braket
id|READ
)braket
op_member_access_from_pointer
id|irq
comma
id|privptr-&gt;channel
(braket
id|READ
)braket
op_member_access_from_pointer
id|devstat
)paren
suffix:semicolon
id|channel_free
c_func
(paren
id|privptr-&gt;channel
(braket
id|READ
)braket
)paren
suffix:semicolon
)brace
id|ctc_free_netdevice
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|privptr-&gt;channel
(braket
id|direction
)braket
op_member_access_from_pointer
id|netdev
op_assign
id|dev
suffix:semicolon
id|privptr-&gt;channel
(braket
id|direction
)braket
op_member_access_from_pointer
id|protocol
op_assign
id|proto
suffix:semicolon
id|privptr-&gt;channel
(braket
id|direction
)braket
op_member_access_from_pointer
id|max_bufsize
op_assign
id|CTC_BUFSIZE_DEFAULT
suffix:semicolon
id|rc
op_assign
id|REQUEST_IRQ
c_func
(paren
id|privptr-&gt;channel
(braket
id|direction
)braket
op_member_access_from_pointer
id|irq
comma
(paren
r_void
op_star
)paren
id|ctc_irq_handler
comma
id|SA_INTERRUPT
comma
id|dev-&gt;name
comma
id|privptr-&gt;channel
(braket
id|direction
)braket
op_member_access_from_pointer
id|devstat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: requested irq %d is busy rc=%02x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|privptr-&gt;channel
(braket
id|direction
)braket
op_member_access_from_pointer
id|irq
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|WRITE
)paren
(brace
id|FREE_IRQ
c_func
(paren
id|privptr-&gt;channel
(braket
id|READ
)braket
op_member_access_from_pointer
id|irq
comma
id|privptr-&gt;channel
(braket
id|READ
)braket
op_member_access_from_pointer
id|devstat
)paren
suffix:semicolon
id|channel_free
c_func
(paren
id|privptr-&gt;channel
(braket
id|READ
)braket
)paren
suffix:semicolon
)brace
id|channel_free
c_func
(paren
id|privptr-&gt;channel
(braket
id|direction
)braket
)paren
suffix:semicolon
id|ctc_free_netdevice
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ctc_netdev_register
c_func
(paren
id|dev
)paren
op_ne
l_int|0
)paren
(brace
id|ctc_free_netdevice
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/**&n;&t; * register subdir in /proc/net/ctc&n;&t; */
id|ctc_proc_create_sub
c_func
(paren
id|dev
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|privptr-&gt;fsm-&gt;name
comma
id|dev-&gt;name
comma
r_sizeof
(paren
id|privptr-&gt;fsm-&gt;name
)paren
)paren
suffix:semicolon
id|activated
op_increment
suffix:semicolon
id|print_banner
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: read: ch %04x (irq %04x), &quot;
l_string|&quot;write: ch %04x (irq %04x) proto: %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|privptr-&gt;channel
(braket
id|READ
)braket
op_member_access_from_pointer
id|devno
comma
id|privptr-&gt;channel
(braket
id|READ
)braket
op_member_access_from_pointer
id|irq
comma
id|privptr-&gt;channel
(braket
id|WRITE
)braket
op_member_access_from_pointer
id|devno
comma
id|privptr-&gt;channel
(braket
id|WRITE
)braket
op_member_access_from_pointer
id|irq
comma
id|proto
)paren
suffix:semicolon
id|chandev_initdevice
c_func
(paren
id|info
comma
id|dev
comma
l_int|0
comma
id|dev-&gt;name
comma
(paren
id|proto
op_eq
id|CTC_PROTO_LINUX_TTY
)paren
ques
c_cond
id|chandev_category_serial_device
suffix:colon
id|chandev_category_network_device
comma
(paren
id|chandev_unregfunc
)paren
id|ctc_netdev_unregister
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#else /* ! CHANDEV */
multiline_comment|/**&n; *&n; * Setup an interface.&n; *&n; * Like ctc_setup(), ctc_probe() can be called from two different locations:&n; *  - If built as module, it is called from within init_module().&n; *  - If built in monolithic kernel, it is called from within generic network&n; *    layer during initialization for every corresponding device, declared in&n; *    drivers/net/Space.c&n; *&n; * @param dev Pointer to net_device to be initialized.&n; *&n; * @returns 0 on success, !0 on failure.&n; */
DECL|function|ctc_probe
r_int
id|ctc_probe
c_func
(paren
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|devno
(braket
l_int|2
)braket
suffix:semicolon
id|__u16
id|proto
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_int
id|direction
suffix:semicolon
id|channel_type_t
id|type
suffix:semicolon
id|ctc_priv
op_star
id|privptr
suffix:semicolon
id|param
op_star
id|par
suffix:semicolon
id|ctc_proc_create_main
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/**&n;&t; * Scan for available channels only the first time,&n;&t; * ctc_probe gets control.&n;&t; */
r_if
c_cond
(paren
id|channels
op_eq
l_int|NULL
)paren
id|channel_scan
c_func
(paren
)paren
suffix:semicolon
id|type
op_assign
id|extract_channel_media
c_func
(paren
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|channel_type_unknown
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|par
op_assign
id|find_param
c_func
(paren
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|par
)paren
(brace
id|devno
(braket
id|READ
)braket
op_assign
id|par-&gt;read_dev
suffix:semicolon
id|devno
(braket
id|WRITE
)braket
op_assign
id|par-&gt;write_dev
suffix:semicolon
id|proto
op_assign
id|par-&gt;proto
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ctc_no_auto
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_else
(brace
id|devno
(braket
id|READ
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|devno
(braket
id|WRITE
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|proto
op_assign
id|CTC_PROTO_S390
suffix:semicolon
)brace
)brace
macro_line|#ifndef MODULE
r_if
c_cond
(paren
id|ctc_init_netdevice
c_func
(paren
id|dev
comma
l_int|0
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
macro_line|#endif
id|privptr
op_assign
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|privptr-&gt;protocol
op_assign
id|proto
suffix:semicolon
r_for
c_loop
(paren
id|direction
op_assign
id|READ
suffix:semicolon
id|direction
op_le
id|WRITE
suffix:semicolon
id|direction
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|ctc_no_auto
op_eq
l_int|0
)paren
op_logical_or
(paren
id|devno
(braket
id|direction
)braket
op_eq
op_minus
l_int|1
)paren
)paren
id|privptr-&gt;channel
(braket
id|direction
)braket
op_assign
id|channel_get_next
c_func
(paren
id|type
comma
id|direction
)paren
suffix:semicolon
r_else
id|privptr-&gt;channel
(braket
id|direction
)braket
op_assign
id|channel_get
c_func
(paren
id|type
comma
id|devno
(braket
id|direction
)braket
comma
id|direction
)paren
suffix:semicolon
r_if
c_cond
(paren
id|privptr-&gt;channel
(braket
id|direction
)braket
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|direction
op_eq
id|WRITE
)paren
(brace
id|FREE_IRQ
c_func
(paren
id|privptr-&gt;channel
(braket
id|READ
)braket
op_member_access_from_pointer
id|irq
comma
id|privptr-&gt;channel
(braket
id|READ
)braket
op_member_access_from_pointer
id|devstat
)paren
suffix:semicolon
id|channel_free
c_func
(paren
id|privptr-&gt;channel
(braket
id|READ
)braket
)paren
suffix:semicolon
)brace
id|ctc_free_netdevice
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|privptr-&gt;channel
(braket
id|direction
)braket
op_member_access_from_pointer
id|netdev
op_assign
id|dev
suffix:semicolon
id|privptr-&gt;channel
(braket
id|direction
)braket
op_member_access_from_pointer
id|protocol
op_assign
id|proto
suffix:semicolon
id|privptr-&gt;channel
(braket
id|direction
)braket
op_member_access_from_pointer
id|max_bufsize
op_assign
id|CTC_BUFSIZE_DEFAULT
suffix:semicolon
id|rc
op_assign
id|REQUEST_IRQ
c_func
(paren
id|privptr-&gt;channel
(braket
id|direction
)braket
op_member_access_from_pointer
id|irq
comma
(paren
r_void
op_star
)paren
id|ctc_irq_handler
comma
id|SA_INTERRUPT
comma
id|dev-&gt;name
comma
id|privptr-&gt;channel
(braket
id|direction
)braket
op_member_access_from_pointer
id|devstat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: requested irq %d is busy rc=%02x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|privptr-&gt;channel
(braket
id|direction
)braket
op_member_access_from_pointer
id|irq
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|WRITE
)paren
(brace
id|FREE_IRQ
c_func
(paren
id|privptr-&gt;channel
(braket
id|READ
)braket
op_member_access_from_pointer
id|irq
comma
id|privptr-&gt;channel
(braket
id|READ
)braket
op_member_access_from_pointer
id|devstat
)paren
suffix:semicolon
id|channel_free
c_func
(paren
id|privptr-&gt;channel
(braket
id|READ
)braket
)paren
suffix:semicolon
)brace
id|channel_free
c_func
(paren
id|privptr-&gt;channel
(braket
id|direction
)braket
)paren
suffix:semicolon
id|ctc_free_netdevice
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
multiline_comment|/**&n;&t; * register subdir in /proc/net/ctc&n;&t; */
id|ctc_proc_create_sub
c_func
(paren
id|dev
)paren
suffix:semicolon
id|print_banner
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: read: ch %04x (irq %04x), &quot;
l_string|&quot;write: ch %04x (irq %04x) proto: %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|privptr-&gt;channel
(braket
id|READ
)braket
op_member_access_from_pointer
id|devno
comma
id|privptr-&gt;channel
(braket
id|READ
)braket
op_member_access_from_pointer
id|irq
comma
id|privptr-&gt;channel
(braket
id|WRITE
)braket
op_member_access_from_pointer
id|devno
comma
id|privptr-&gt;channel
(braket
id|WRITE
)braket
op_member_access_from_pointer
id|irq
comma
id|proto
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
"&f;"
multiline_comment|/**&n; * Module related routines&n; *****************************************************************************/
macro_line|#ifdef MODULE
multiline_comment|/**&n; * Prepare to be unloaded. Free IRQ&squot;s and release all resources.&n; * This is called just before this module is unloaded. It is&n; * &lt;em&gt;not&lt;/em&gt; called, if the usage count is !0, so we don&squot;t need to check&n; * for that.&n; */
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|ctc_tty_cleanup
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* we are called if all interfaces are down only, so no need&n;&t; * to bother around with locking stuff&n;&t; */
macro_line|#ifndef CTC_CHANDEV
r_while
c_loop
(paren
id|channels
)paren
(brace
r_if
c_cond
(paren
(paren
id|channels-&gt;flags
op_amp
id|CHANNEL_FLAGS_INUSE
)paren
op_logical_and
(paren
id|channels-&gt;netdev
op_ne
l_int|NULL
)paren
)paren
(brace
id|net_device
op_star
id|dev
op_assign
id|channels-&gt;netdev
suffix:semicolon
id|ctc_priv
op_star
id|privptr
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|privptr
)paren
(brace
id|privptr-&gt;channel
(braket
id|READ
)braket
op_member_access_from_pointer
id|netdev
op_assign
l_int|NULL
suffix:semicolon
id|privptr-&gt;channel
(braket
id|WRITE
)braket
op_member_access_from_pointer
id|netdev
op_assign
l_int|NULL
suffix:semicolon
)brace
id|channels-&gt;netdev
op_assign
l_int|NULL
suffix:semicolon
id|ctc_netdev_unregister
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ctc_free_netdevice
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
)brace
id|channel_remove
c_func
(paren
id|channels
)paren
suffix:semicolon
)brace
id|channels
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
id|ctc_tty_cleanup
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|ctc_proc_destroy_main
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CTC_CHANDEV
id|chandev_unregister
c_func
(paren
id|ctc_chandev_probe
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;CTC driver unloaded&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|macro|ctc_init
mdefine_line|#define ctc_init init_module
macro_line|#endif MODULE
multiline_comment|/**&n; * Initialize module.&n; * This is called just after the module is loaded.&n; *&n; * @return 0 on success, !0 on error.&n; */
DECL|function|ctc_init
r_int
id|ctc_init
c_func
(paren
r_void
)paren
(brace
macro_line|#ifndef CTC_CHANDEV
r_int
id|cnt
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|itype
suffix:semicolon
r_int
id|activated
suffix:semicolon
id|param
op_star
id|par
suffix:semicolon
macro_line|#endif
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|probed
op_assign
l_int|0
suffix:semicolon
id|print_banner
c_func
(paren
)paren
suffix:semicolon
macro_line|#if defined(DEBUG) &amp;&amp; !defined(CTC_CHANDEV)
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ctc: init_module(): got string &squot;%s&squot;&bslash;n&quot;
comma
id|ctc
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifndef CTC_CHANDEV
macro_line|#ifdef MODULE
id|ctc_setup
c_func
(paren
id|ctc
)paren
suffix:semicolon
macro_line|#endif
id|par
op_assign
id|params
suffix:semicolon
macro_line|#endif
id|activated
op_assign
l_int|0
suffix:semicolon
id|ctc_tty_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CTC_CHANDEV
id|chandev_register_and_probe
c_func
(paren
id|ctc_chandev_probe
comma
(paren
id|chandev_shutdownfunc
)paren
id|ctc_shutdown
comma
id|ctc_chandev_msck_notify
comma
id|chandev_type_ctc
op_or
id|chandev_type_escon
)paren
suffix:semicolon
macro_line|#else /* CTC_CHANDEV */
r_for
c_loop
(paren
id|itype
op_assign
l_int|0
suffix:semicolon
id|itype
OL
l_int|2
suffix:semicolon
id|itype
op_increment
)paren
(brace
id|net_device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|bname
op_assign
(paren
id|itype
)paren
ques
c_cond
l_string|&quot;escon&quot;
suffix:colon
l_string|&quot;ctc&quot;
suffix:semicolon
id|cnt
(braket
id|itype
)braket
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|dev
op_assign
id|ctc_init_netdevice
c_func
(paren
l_int|NULL
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &lt; 0x020300
id|dev-&gt;name
op_assign
(paren
r_int
r_char
op_star
)paren
id|dev
op_plus
r_sizeof
(paren
id|net_device
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|par
op_logical_and
id|par-&gt;name
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
r_int
id|n
suffix:semicolon
id|sprintf
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;%s&quot;
comma
id|par-&gt;name
)paren
suffix:semicolon
id|par
op_assign
id|par-&gt;next
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|dev-&gt;name
suffix:semicolon
id|p
op_logical_and
op_star
id|p
suffix:semicolon
id|p
op_increment
)paren
r_if
c_cond
(paren
id|isdigit
c_func
(paren
op_star
id|p
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|p
op_logical_and
op_star
id|p
)paren
(brace
r_int
id|it
op_assign
(paren
id|strncmp
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;escon&quot;
comma
l_int|5
)paren
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|n
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_ge
id|cnt
(braket
id|it
)braket
)paren
id|cnt
(braket
id|it
)braket
op_assign
id|n
op_plus
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|ctc_no_auto
)paren
(brace
id|itype
op_assign
l_int|3
suffix:semicolon
id|ctc_free_netdevice
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;%s%d&quot;
comma
id|bname
comma
(paren
id|cnt
(braket
id|itype
)braket
)paren
op_increment
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ctc: %s(): probing for device %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;
id|probed
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ctc_probe
c_func
(paren
id|dev
)paren
op_eq
l_int|0
)paren
(brace
id|ctc_priv
op_star
id|privptr
op_assign
(paren
id|ctc_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ctc: %s(): probing succeeded&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ctc: %s(): registering device %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ctc_netdev_register
c_func
(paren
id|dev
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc: Couldn&squot;t register %s&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|FREE_IRQ
c_func
(paren
id|privptr-&gt;channel
(braket
id|READ
)braket
op_member_access_from_pointer
id|irq
comma
id|privptr-&gt;channel
(braket
id|READ
)braket
op_member_access_from_pointer
id|devstat
)paren
suffix:semicolon
id|FREE_IRQ
c_func
(paren
id|privptr-&gt;channel
(braket
id|WRITE
)braket
op_member_access_from_pointer
id|irq
comma
id|privptr-&gt;channel
(braket
id|WRITE
)braket
op_member_access_from_pointer
id|devstat
)paren
suffix:semicolon
id|channel_free
c_func
(paren
id|privptr-&gt;channel
(braket
id|READ
)braket
)paren
suffix:semicolon
id|channel_free
c_func
(paren
id|privptr-&gt;channel
(braket
id|WRITE
)braket
)paren
suffix:semicolon
id|ctc_free_netdevice
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|dev
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ctc: %s(): register succeed&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;
id|activated
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ctc: %s(): probing failed&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;
id|dev
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|dev
op_logical_and
(paren
id|ret
op_eq
l_int|0
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CHANDEV */
macro_line|#if !defined(CTC_CHANDEV) &amp;&amp; defined(MODULE)
r_if
c_cond
(paren
op_logical_neg
id|activated
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc: No devices registered&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|ret
)paren
(brace
id|ctc_tty_cleanup
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|ctc_tty_cleanup
c_func
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#if defined(CTC_CHANDEV) &amp;&amp; defined(MODULE)
id|chandev_unregister
c_func
(paren
id|ctc_chandev_probe
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MODULE
r_if
c_cond
(paren
id|probed
)paren
id|ctc_proc_destroy_main
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifndef MODULE
macro_line|#if (LINUX_VERSION_CODE&gt;=KERNEL_VERSION(2,3,0))
DECL|variable|ctc_init
id|__initcall
c_func
(paren
id|ctc_init
)paren
suffix:semicolon
macro_line|#endif /* LINUX_VERSION_CODE */
macro_line|#endif /* MODULE */
multiline_comment|/* --- This is the END my friend --- */
eof
