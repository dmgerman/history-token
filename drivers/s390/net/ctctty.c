multiline_comment|/*&n; * $Id: ctctty.c,v 1.8 2001/05/16 16:28:31 felfert Exp $&n; *&n; * CTC / ESCON network driver, tty interface.&n; *&n; * Copyright (C) 2001 IBM Deutschland Entwicklung GmbH, IBM Corporation&n; * Author(s): Fritz Elfert (elfert@de.ibm.com, felfert@millenux.com)&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; */
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/serial_reg.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#ifdef CONFIG_DEVFS_FS
macro_line|#  include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#endif
macro_line|#include &quot;ctctty.h&quot;
macro_line|#if LINUX_VERSION_CODE &lt; 0x020212
DECL|typedef|wait_queue_t
r_typedef
r_struct
id|wait_queue
id|wait_queue_t
suffix:semicolon
DECL|typedef|wait_queue_head_t
r_typedef
r_struct
id|wait_queue
op_star
id|wait_queue_head_t
suffix:semicolon
DECL|macro|DECLARE_WAITQUEUE
mdefine_line|#define DECLARE_WAITQUEUE(wait, current) &bslash;&n;&t;struct wait_queue wait = { current, NULL }
DECL|macro|init_waitqueue_head
mdefine_line|#define init_waitqueue_head(x) *(x)=NULL
DECL|macro|__set_current_state
mdefine_line|#define __set_current_state(state_value) &bslash;&n;&t;do { current-&gt;state = state_value; } while (0)
macro_line|#ifdef __SMP__
DECL|macro|set_current_state
mdefine_line|#define set_current_state(state_value) &bslash;&n;&t;do { __set_current_state(state_value); mb(); } while (0)
macro_line|#else
DECL|macro|set_current_state
mdefine_line|#define set_current_state(state_value) __set_current_state(state_value)
macro_line|#endif
DECL|macro|init_MUTEX
mdefine_line|#define init_MUTEX(x) *(x)=MUTEX
macro_line|#endif
DECL|macro|CTC_TTY_MAJOR
mdefine_line|#define CTC_TTY_MAJOR       43
DECL|macro|CTC_TTY_MAX_DEVICES
mdefine_line|#define CTC_TTY_MAX_DEVICES 64
DECL|macro|CTC_ASYNC_MAGIC
mdefine_line|#define CTC_ASYNC_MAGIC          0x49344C01 /* for paranoia-checking        */
DECL|macro|CTC_ASYNC_INITIALIZED
mdefine_line|#define CTC_ASYNC_INITIALIZED    0x80000000 /* port was initialized         */
DECL|macro|CTC_ASYNC_NORMAL_ACTIVE
mdefine_line|#define CTC_ASYNC_NORMAL_ACTIVE  0x20000000 /* Normal device active         */
DECL|macro|CTC_ASYNC_CLOSING
mdefine_line|#define CTC_ASYNC_CLOSING        0x08000000 /* Serial port is closing       */
DECL|macro|CTC_ASYNC_CTS_FLOW
mdefine_line|#define CTC_ASYNC_CTS_FLOW       0x04000000 /* Do CTS flow control          */
DECL|macro|CTC_ASYNC_CHECK_CD
mdefine_line|#define CTC_ASYNC_CHECK_CD       0x02000000 /* i.e., CLOCAL                 */
DECL|macro|CTC_ASYNC_HUP_NOTIFY
mdefine_line|#define CTC_ASYNC_HUP_NOTIFY         0x0001 /* Notify tty on hangups/closes */
DECL|macro|CTC_ASYNC_NETDEV_OPEN
mdefine_line|#define CTC_ASYNC_NETDEV_OPEN        0x0002 /* Underlying netdev is open    */
DECL|macro|CTC_ASYNC_TX_LINESTAT
mdefine_line|#define CTC_ASYNC_TX_LINESTAT        0x0004 /* Must send line status        */
DECL|macro|CTC_ASYNC_SPLIT_TERMIOS
mdefine_line|#define CTC_ASYNC_SPLIT_TERMIOS      0x0008 /* Sep. termios for dialin/out  */
DECL|macro|CTC_TTY_XMIT_SIZE
mdefine_line|#define CTC_TTY_XMIT_SIZE              1024 /* Default bufsize for write    */
DECL|macro|CTC_SERIAL_XMIT_MAX
mdefine_line|#define CTC_SERIAL_XMIT_MAX            4000 /* Maximum bufsize for write    */
DECL|macro|CTC_SERIAL_TYPE_NORMAL
mdefine_line|#define CTC_SERIAL_TYPE_NORMAL            1
multiline_comment|/* Private data (similar to async_struct in &lt;linux/serial.h&gt;) */
r_typedef
r_struct
(brace
DECL|member|magic
r_int
id|magic
suffix:semicolon
DECL|member|flags
r_int
id|flags
suffix:semicolon
multiline_comment|/* defined in tty.h               */
DECL|member|mcr
r_int
id|mcr
suffix:semicolon
multiline_comment|/* Modem control register         */
DECL|member|msr
r_int
id|msr
suffix:semicolon
multiline_comment|/* Modem status register          */
DECL|member|lsr
r_int
id|lsr
suffix:semicolon
multiline_comment|/* Line status register           */
DECL|member|line
r_int
id|line
suffix:semicolon
DECL|member|count
r_int
id|count
suffix:semicolon
multiline_comment|/* # of fd on device              */
DECL|member|blocked_open
r_int
id|blocked_open
suffix:semicolon
multiline_comment|/* # of blocked opens             */
DECL|member|netdev
id|net_device
op_star
id|netdev
suffix:semicolon
DECL|member|tx_queue
r_struct
id|sk_buff_head
id|tx_queue
suffix:semicolon
multiline_comment|/* transmit queue                 */
DECL|member|rx_queue
r_struct
id|sk_buff_head
id|rx_queue
suffix:semicolon
multiline_comment|/* receive queue                  */
DECL|member|tty
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
multiline_comment|/* Pointer to corresponding tty   */
DECL|member|normal_termios
r_struct
id|termios
id|normal_termios
suffix:semicolon
multiline_comment|/* For saving termios structs     */
DECL|member|open_wait
id|wait_queue_head_t
id|open_wait
suffix:semicolon
DECL|member|close_wait
id|wait_queue_head_t
id|close_wait
suffix:semicolon
DECL|member|write_sem
r_struct
id|semaphore
id|write_sem
suffix:semicolon
DECL|member|tq
r_struct
id|tq_struct
id|tq
suffix:semicolon
DECL|member|stoptimer
r_struct
id|timer_list
id|stoptimer
suffix:semicolon
DECL|typedef|ctc_tty_info
)brace
id|ctc_tty_info
suffix:semicolon
multiline_comment|/* Description of one CTC-tty */
r_typedef
r_struct
(brace
DECL|member|refcount
r_int
id|refcount
suffix:semicolon
multiline_comment|/* Number of opens        */
DECL|member|ctc_tty_device
r_struct
id|tty_driver
id|ctc_tty_device
suffix:semicolon
multiline_comment|/* tty-device             */
DECL|member|modem_table
r_struct
id|tty_struct
op_star
id|modem_table
(braket
id|CTC_TTY_MAX_DEVICES
)braket
suffix:semicolon
DECL|member|modem_termios
r_struct
id|termios
op_star
id|modem_termios
(braket
id|CTC_TTY_MAX_DEVICES
)braket
suffix:semicolon
DECL|member|modem_termios_locked
r_struct
id|termios
op_star
id|modem_termios_locked
(braket
id|CTC_TTY_MAX_DEVICES
)braket
suffix:semicolon
DECL|member|info
id|ctc_tty_info
id|info
(braket
id|CTC_TTY_MAX_DEVICES
)braket
suffix:semicolon
multiline_comment|/* Private data           */
DECL|typedef|ctc_tty_driver
)brace
id|ctc_tty_driver
suffix:semicolon
DECL|variable|driver
r_static
id|ctc_tty_driver
op_star
id|driver
suffix:semicolon
multiline_comment|/* Leave this unchanged unless you know what you do! */
DECL|macro|MODEM_PARANOIA_CHECK
mdefine_line|#define MODEM_PARANOIA_CHECK
DECL|macro|MODEM_DO_RESTART
mdefine_line|#define MODEM_DO_RESTART
DECL|macro|CTC_TTY_NAME
mdefine_line|#define CTC_TTY_NAME &quot;ctctty&quot;
macro_line|#ifdef CONFIG_DEVFS_FS
DECL|variable|ctc_ttyname
r_static
r_char
op_star
id|ctc_ttyname
op_assign
l_string|&quot;ctc/&quot;
id|CTC_TTY_NAME
l_string|&quot;%d&quot;
suffix:semicolon
macro_line|#else
DECL|variable|ctc_ttyname
r_static
r_char
op_star
id|ctc_ttyname
op_assign
id|CTC_TTY_NAME
suffix:semicolon
macro_line|#endif
DECL|variable|ctc_tty_revision
r_char
op_star
id|ctc_tty_revision
op_assign
l_string|&quot;$Revision: 1.8 $&quot;
suffix:semicolon
DECL|variable|ctc_tty_magic
r_static
id|__u32
id|ctc_tty_magic
op_assign
id|CTC_ASYNC_MAGIC
suffix:semicolon
DECL|variable|ctc_tty_shuttingdown
r_static
r_int
id|ctc_tty_shuttingdown
op_assign
l_int|0
suffix:semicolon
DECL|variable|ctc_tty_lock
r_static
id|spinlock_t
id|ctc_tty_lock
suffix:semicolon
multiline_comment|/* ctc_tty_try_read() is called from within ctc_tty_rcv_skb()&n; * to stuff incoming data directly into a tty&squot;s flip-buffer. If the&n; * flip buffer is full, the packet gets queued up.&n; *&n; * Return:&n; *  1 = Success&n; *  0 = Failure, data has to be buffered and later processed by&n; *      ctc_tty_readmodem().&n; */
r_static
r_int
DECL|function|ctc_tty_try_read
id|ctc_tty_try_read
c_func
(paren
id|ctc_tty_info
op_star
id|info
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|c
suffix:semicolon
r_int
id|len
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty
op_assign
id|info-&gt;tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;mcr
op_amp
id|UART_MCR_RTS
)paren
(brace
id|c
op_assign
id|TTY_FLIPBUF_SIZE
op_minus
id|tty-&gt;flip.count
suffix:semicolon
id|len
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ge
id|len
)paren
(brace
id|memcpy
c_func
(paren
id|tty-&gt;flip.char_buf_ptr
comma
id|skb-&gt;data
comma
id|len
)paren
suffix:semicolon
id|memset
c_func
(paren
id|tty-&gt;flip.flag_buf_ptr
comma
l_int|0
comma
id|len
)paren
suffix:semicolon
id|tty-&gt;flip.count
op_add_assign
id|len
suffix:semicolon
id|tty-&gt;flip.char_buf_ptr
op_add_assign
id|len
suffix:semicolon
id|tty-&gt;flip.flag_buf_ptr
op_add_assign
id|len
suffix:semicolon
id|tty_flip_buffer_push
c_func
(paren
id|tty
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ctc_tty_readmodem() is called periodically from within timer-interrupt.&n; * It tries getting received data from the receive queue an stuff it into&n; * the tty&squot;s flip-buffer.&n; */
r_static
r_int
DECL|function|ctc_tty_readmodem
id|ctc_tty_readmodem
c_func
(paren
id|ctc_tty_info
op_star
id|info
)paren
(brace
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty
op_assign
id|info-&gt;tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;mcr
op_amp
id|UART_MCR_RTS
)paren
(brace
r_int
id|c
op_assign
id|TTY_FLIPBUF_SIZE
op_minus
id|tty-&gt;flip.count
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c
OG
l_int|0
)paren
op_logical_and
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|info-&gt;rx_queue
)paren
)paren
)paren
(brace
r_int
id|len
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|c
)paren
id|len
op_assign
id|c
suffix:semicolon
id|memcpy
c_func
(paren
id|tty-&gt;flip.char_buf_ptr
comma
id|skb-&gt;data
comma
id|len
)paren
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
id|memset
c_func
(paren
id|tty-&gt;flip.flag_buf_ptr
comma
l_int|0
comma
id|len
)paren
suffix:semicolon
id|tty-&gt;flip.count
op_add_assign
id|len
suffix:semicolon
id|tty-&gt;flip.char_buf_ptr
op_add_assign
id|len
suffix:semicolon
id|tty-&gt;flip.flag_buf_ptr
op_add_assign
id|len
suffix:semicolon
id|tty_flip_buffer_push
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
OG
l_int|0
)paren
id|skb_queue_head
c_func
(paren
op_amp
id|info-&gt;rx_queue
comma
id|skb
)paren
suffix:semicolon
r_else
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|ret
op_assign
id|skb_queue_len
c_func
(paren
op_amp
id|info-&gt;rx_queue
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
r_void
DECL|function|ctc_tty_setcarrier
id|ctc_tty_setcarrier
c_func
(paren
id|net_device
op_star
id|netdev
comma
r_int
id|on
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|driver
)paren
op_logical_or
id|ctc_tty_shuttingdown
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CTC_TTY_MAX_DEVICES
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|driver-&gt;info
(braket
id|i
)braket
dot
id|netdev
op_eq
id|netdev
)paren
(brace
id|ctc_tty_info
op_star
id|info
op_assign
op_amp
id|driver-&gt;info
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|on
)paren
id|info-&gt;msr
op_or_assign
id|UART_MSR_DCD
suffix:semicolon
r_else
id|info-&gt;msr
op_and_assign
op_complement
id|UART_MSR_DCD
suffix:semicolon
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|CTC_ASYNC_CHECK_CD
)paren
op_logical_and
(paren
op_logical_neg
id|on
)paren
)paren
id|tty_hangup
c_func
(paren
id|info-&gt;tty
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|ctc_tty_netif_rx
id|ctc_tty_netif_rx
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|i
suffix:semicolon
id|ctc_tty_info
op_star
id|info
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|skb-&gt;dev
)paren
op_logical_or
(paren
op_logical_neg
id|driver
)paren
op_logical_or
id|ctc_tty_shuttingdown
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CTC_TTY_MAX_DEVICES
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|driver-&gt;info
(braket
id|i
)braket
dot
id|netdev
op_eq
id|skb-&gt;dev
)paren
(brace
id|info
op_assign
op_amp
id|driver-&gt;info
(braket
id|i
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;len
OL
l_int|6
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|skb-&gt;data
comma
op_amp
id|ctc_tty_magic
comma
r_sizeof
(paren
id|__u32
)paren
)paren
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb_pull
c_func
(paren
id|skb
comma
r_sizeof
(paren
id|__u32
)paren
)paren
suffix:semicolon
id|i
op_assign
op_star
(paren
(paren
r_int
op_star
)paren
id|skb-&gt;data
)paren
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
r_sizeof
(paren
id|info-&gt;mcr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
id|UART_MCR_RTS
)paren
(brace
id|info-&gt;msr
op_or_assign
id|UART_MSR_CTS
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|CTC_ASYNC_CTS_FLOW
)paren
id|info-&gt;tty-&gt;hw_stopped
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|info-&gt;msr
op_and_assign
op_complement
id|UART_MSR_CTS
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|CTC_ASYNC_CTS_FLOW
)paren
id|info-&gt;tty-&gt;hw_stopped
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_amp
id|UART_MCR_DTR
)paren
id|info-&gt;msr
op_or_assign
id|UART_MSR_DSR
suffix:semicolon
r_else
id|info-&gt;msr
op_and_assign
op_complement
id|UART_MSR_DSR
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
op_le
l_int|0
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Try to deliver directly via tty-flip-buf if queue is empty */
r_if
c_cond
(paren
id|skb_queue_empty
c_func
(paren
op_amp
id|info-&gt;rx_queue
)paren
)paren
r_if
c_cond
(paren
id|ctc_tty_try_read
c_func
(paren
id|info
comma
id|skb
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Direct deliver failed or queue wasn&squot;t empty.&n;&t; * Queue up for later dequeueing via timer-irq.&n;&t; */
id|skb_queue_tail
c_func
(paren
op_amp
id|info-&gt;rx_queue
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* Schedule dequeuing */
id|queue_task
c_func
(paren
op_amp
id|info-&gt;tq
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|ctc_tty_tint
id|ctc_tty_tint
c_func
(paren
id|ctc_tty_info
op_star
id|info
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|info-&gt;tx_queue
)paren
suffix:semicolon
r_int
id|stopped
op_assign
(paren
id|info-&gt;tty-&gt;hw_stopped
op_logical_or
id|info-&gt;tty-&gt;stopped
)paren
suffix:semicolon
r_int
id|wake
op_assign
l_int|1
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;netdev
)paren
(brace
r_if
c_cond
(paren
id|skb
)paren
id|kfree
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|CTC_ASYNC_TX_LINESTAT
)paren
(brace
r_int
id|skb_res
op_assign
id|info-&gt;netdev-&gt;hard_header_len
op_plus
r_sizeof
(paren
id|info-&gt;mcr
)paren
op_plus
r_sizeof
(paren
id|__u32
)paren
suffix:semicolon
multiline_comment|/* If we must update line status,&n;&t;&t; * create an empty dummy skb and insert it.&n;&t;&t; */
r_if
c_cond
(paren
id|skb
)paren
id|skb_queue_head
c_func
(paren
op_amp
id|info-&gt;tx_queue
comma
id|skb
)paren
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|skb_res
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc_tty: Out of memory in %s%d tint&bslash;n&quot;
comma
id|CTC_TTY_NAME
comma
id|info-&gt;line
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|skb
comma
id|skb_res
)paren
suffix:semicolon
id|stopped
op_assign
l_int|0
suffix:semicolon
id|wake
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|stopped
)paren
(brace
id|skb_queue_head
c_func
(paren
op_amp
id|info-&gt;tx_queue
comma
id|skb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#if 0
r_if
c_cond
(paren
id|skb-&gt;len
OG
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;tint: %d %02x&bslash;n&quot;
comma
id|skb-&gt;len
comma
op_star
(paren
id|skb-&gt;data
)paren
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;tint: %d STAT&bslash;n&quot;
comma
id|skb-&gt;len
)paren
suffix:semicolon
macro_line|#endif
id|memcpy
c_func
(paren
id|skb_push
c_func
(paren
id|skb
comma
r_sizeof
(paren
id|info-&gt;mcr
)paren
)paren
comma
op_amp
id|info-&gt;mcr
comma
r_sizeof
(paren
id|info-&gt;mcr
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|skb_push
c_func
(paren
id|skb
comma
r_sizeof
(paren
id|__u32
)paren
)paren
comma
op_amp
id|ctc_tty_magic
comma
r_sizeof
(paren
id|__u32
)paren
)paren
suffix:semicolon
id|rc
op_assign
id|info-&gt;netdev
op_member_access_from_pointer
id|hard_start_xmit
c_func
(paren
id|skb
comma
id|info-&gt;netdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|skb_pull
c_func
(paren
id|skb
comma
r_sizeof
(paren
id|info-&gt;mcr
)paren
op_plus
r_sizeof
(paren
id|__u32
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
OG
l_int|0
)paren
id|skb_queue_head
c_func
(paren
op_amp
id|info-&gt;tx_queue
comma
id|skb
)paren
suffix:semicolon
r_else
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|info-&gt;tty
suffix:semicolon
id|info-&gt;flags
op_and_assign
op_complement
id|CTC_ASYNC_TX_LINESTAT
suffix:semicolon
r_if
c_cond
(paren
id|tty
)paren
(brace
r_if
c_cond
(paren
id|wake
op_logical_and
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
id|skb_queue_empty
c_func
(paren
op_amp
id|info-&gt;tx_queue
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/************************************************************&n; *&n; * Modem-functions&n; *&n; * mostly &quot;stolen&quot; from original Linux-serial.c and friends.&n; *&n; ************************************************************/
r_static
r_inline
r_int
DECL|function|ctc_tty_paranoia_check
id|ctc_tty_paranoia_check
c_func
(paren
id|ctc_tty_info
op_star
id|info
comma
id|kdev_t
id|device
comma
r_const
r_char
op_star
id|routine
)paren
(brace
macro_line|#ifdef MODEM_PARANOIA_CHECK
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc_tty: null info_struct for (%d, %d) in %s&bslash;n&quot;
comma
id|MAJOR
c_func
(paren
id|device
)paren
comma
id|MINOR
c_func
(paren
id|device
)paren
comma
id|routine
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;magic
op_ne
id|CTC_ASYNC_MAGIC
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc_tty: bad magic for info struct (%d, %d) in %s&bslash;n&quot;
comma
id|MAJOR
c_func
(paren
id|device
)paren
comma
id|MINOR
c_func
(paren
id|device
)paren
comma
id|routine
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|ctc_tty_inject
id|ctc_tty_inject
c_func
(paren
id|ctc_tty_info
op_star
id|info
comma
r_char
id|c
)paren
(brace
r_int
id|skb_res
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|ctc_tty_shuttingdown
)paren
r_return
suffix:semicolon
id|skb_res
op_assign
id|info-&gt;netdev-&gt;hard_header_len
op_plus
r_sizeof
(paren
id|info-&gt;mcr
)paren
op_plus
r_sizeof
(paren
id|__u32
)paren
op_plus
l_int|1
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|skb_res
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc_tty: Out of memory in %s%d tx_inject&bslash;n&quot;
comma
id|CTC_TTY_NAME
comma
id|info-&gt;line
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|skb
comma
id|skb_res
)paren
suffix:semicolon
op_star
(paren
id|skb_put
c_func
(paren
id|skb
comma
l_int|1
)paren
)paren
op_assign
id|c
suffix:semicolon
id|skb_queue_head
c_func
(paren
op_amp
id|info-&gt;tx_queue
comma
id|skb
)paren
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|info-&gt;tq
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ctc_tty_transmit_status
id|ctc_tty_transmit_status
c_func
(paren
id|ctc_tty_info
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
id|ctc_tty_shuttingdown
)paren
r_return
suffix:semicolon
id|info-&gt;flags
op_or_assign
id|CTC_ASYNC_TX_LINESTAT
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|info-&gt;tq
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ctc_tty_change_speed
id|ctc_tty_change_speed
c_func
(paren
id|ctc_tty_info
op_star
id|info
)paren
(brace
r_int
r_int
id|cflag
suffix:semicolon
r_int
r_int
id|quot
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;tty
op_logical_or
op_logical_neg
id|info-&gt;tty-&gt;termios
)paren
r_return
suffix:semicolon
id|cflag
op_assign
id|info-&gt;tty-&gt;termios-&gt;c_cflag
suffix:semicolon
id|quot
op_assign
id|i
op_assign
id|cflag
op_amp
id|CBAUD
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
id|CBAUDEX
)paren
(brace
id|i
op_and_assign
op_complement
id|CBAUDEX
suffix:semicolon
r_if
c_cond
(paren
id|i
template_param
l_int|2
)paren
id|info-&gt;tty-&gt;termios-&gt;c_cflag
op_and_assign
op_complement
id|CBAUDEX
suffix:semicolon
r_else
id|i
op_add_assign
l_int|15
suffix:semicolon
)brace
r_if
c_cond
(paren
id|quot
)paren
(brace
id|info-&gt;mcr
op_or_assign
id|UART_MCR_DTR
suffix:semicolon
id|info-&gt;mcr
op_or_assign
id|UART_MCR_RTS
suffix:semicolon
id|ctc_tty_transmit_status
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
r_else
(brace
id|info-&gt;mcr
op_and_assign
op_complement
id|UART_MCR_DTR
suffix:semicolon
id|info-&gt;mcr
op_and_assign
op_complement
id|UART_MCR_RTS
suffix:semicolon
id|ctc_tty_transmit_status
c_func
(paren
id|info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* CTS flow control flag and modem status interrupts */
r_if
c_cond
(paren
id|cflag
op_amp
id|CRTSCTS
)paren
(brace
id|info-&gt;flags
op_or_assign
id|CTC_ASYNC_CTS_FLOW
suffix:semicolon
)brace
r_else
id|info-&gt;flags
op_and_assign
op_complement
id|CTC_ASYNC_CTS_FLOW
suffix:semicolon
r_if
c_cond
(paren
id|cflag
op_amp
id|CLOCAL
)paren
id|info-&gt;flags
op_and_assign
op_complement
id|CTC_ASYNC_CHECK_CD
suffix:semicolon
r_else
(brace
id|info-&gt;flags
op_or_assign
id|CTC_ASYNC_CHECK_CD
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|ctc_tty_startup
id|ctc_tty_startup
c_func
(paren
id|ctc_tty_info
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|CTC_ASYNC_INITIALIZED
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#ifdef CTC_DEBUG_MODEM_OPEN
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;starting up %s%d ...&bslash;n&quot;
comma
id|CTC_TTY_NAME
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Now, initialize the UART&n;&t; */
id|info-&gt;mcr
op_assign
id|UART_MCR_DTR
op_or
id|UART_MCR_RTS
op_or
id|UART_MCR_OUT2
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;tty
)paren
id|clear_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|info-&gt;tty-&gt;flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * and set the speed of the serial port&n;&t; */
id|ctc_tty_change_speed
c_func
(paren
id|info
)paren
suffix:semicolon
id|info-&gt;flags
op_or_assign
id|CTC_ASYNC_INITIALIZED
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|CTC_ASYNC_NETDEV_OPEN
)paren
)paren
id|info-&gt;netdev
op_member_access_from_pointer
id|open
c_func
(paren
id|info-&gt;netdev
)paren
suffix:semicolon
id|info-&gt;flags
op_or_assign
id|CTC_ASYNC_NETDEV_OPEN
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|ctc_tty_stopdev
id|ctc_tty_stopdev
c_func
(paren
r_int
r_int
id|data
)paren
(brace
id|ctc_tty_info
op_star
id|info
op_assign
(paren
id|ctc_tty_info
op_star
)paren
id|data
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|info
)paren
op_logical_or
(paren
op_logical_neg
id|info-&gt;netdev
)paren
op_logical_or
(paren
id|info-&gt;flags
op_amp
id|CTC_ASYNC_INITIALIZED
)paren
)paren
r_return
suffix:semicolon
id|info-&gt;netdev
op_member_access_from_pointer
id|stop
c_func
(paren
id|info-&gt;netdev
)paren
suffix:semicolon
id|info-&gt;flags
op_and_assign
op_complement
id|CTC_ASYNC_NETDEV_OPEN
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine will shutdown a serial port; interrupts are disabled, and&n; * DTR is dropped if the hangup on close termio flag is on.&n; */
r_static
r_void
DECL|function|ctc_tty_shutdown
id|ctc_tty_shutdown
c_func
(paren
id|ctc_tty_info
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|CTC_ASYNC_INITIALIZED
)paren
)paren
r_return
suffix:semicolon
macro_line|#ifdef CTC_DEBUG_MODEM_OPEN
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Shutting down %s%d ....&bslash;n&quot;
comma
id|CTC_TTY_NAME
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
id|info-&gt;msr
op_and_assign
op_complement
id|UART_MSR_RI
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;tty
op_logical_or
(paren
id|info-&gt;tty-&gt;termios-&gt;c_cflag
op_amp
id|HUPCL
)paren
)paren
id|info-&gt;mcr
op_and_assign
op_complement
(paren
id|UART_MCR_DTR
op_or
id|UART_MCR_RTS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;tty
)paren
id|set_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|info-&gt;tty-&gt;flags
)paren
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|info-&gt;stoptimer
comma
id|jiffies
op_plus
(paren
l_int|10
op_star
id|HZ
)paren
)paren
suffix:semicolon
id|skb_queue_purge
c_func
(paren
op_amp
id|info-&gt;tx_queue
)paren
suffix:semicolon
id|skb_queue_purge
c_func
(paren
op_amp
id|info-&gt;rx_queue
)paren
suffix:semicolon
id|info-&gt;flags
op_and_assign
op_complement
id|CTC_ASYNC_INITIALIZED
suffix:semicolon
)brace
multiline_comment|/* ctc_tty_write() is the main send-routine. It is called from the upper&n; * levels within the kernel to perform sending data. Depending on the&n; * online-flag it either directs output to the at-command-interpreter or&n; * to the lower level. Additional tasks done here:&n; *  - If online, check for escape-sequence (+++)&n; *  - If sending audio-data, call ctc_tty_DLEdown() to parse DLE-codes.&n; *  - If receiving audio-data, call ctc_tty_end_vrx() to abort if needed.&n; *  - If dialing, abort dial.&n; */
r_static
r_int
DECL|function|ctc_tty_write
id|ctc_tty_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
id|u_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|c
suffix:semicolon
r_int
id|total
op_assign
l_int|0
suffix:semicolon
id|ctc_tty_info
op_star
id|info
op_assign
(paren
id|ctc_tty_info
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|ctc_tty_shuttingdown
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ctc_tty_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;ctc_tty_write&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;netdev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|from_user
)paren
id|down
c_func
(paren
op_amp
id|info-&gt;write_sem
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|skb_res
suffix:semicolon
id|c
op_assign
(paren
id|count
OL
id|CTC_TTY_XMIT_SIZE
)paren
ques
c_cond
id|count
suffix:colon
id|CTC_TTY_XMIT_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|c
op_le
l_int|0
)paren
r_break
suffix:semicolon
id|skb_res
op_assign
id|info-&gt;netdev-&gt;hard_header_len
op_plus
r_sizeof
(paren
id|info-&gt;mcr
)paren
op_plus
op_plus
r_sizeof
(paren
id|__u32
)paren
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|skb_res
op_plus
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc_tty: Out of memory in %s%d write&bslash;n&quot;
comma
id|CTC_TTY_NAME
comma
id|info-&gt;line
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|skb
comma
id|skb_res
)paren
suffix:semicolon
r_if
c_cond
(paren
id|from_user
)paren
id|copy_from_user
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|c
)paren
comma
id|buf
comma
id|c
)paren
suffix:semicolon
r_else
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|c
)paren
comma
id|buf
comma
id|c
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|info-&gt;tx_queue
comma
id|skb
)paren
suffix:semicolon
id|buf
op_add_assign
id|c
suffix:semicolon
id|total
op_add_assign
id|c
suffix:semicolon
id|count
op_sub_assign
id|c
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|info-&gt;tx_queue
)paren
)paren
(brace
id|info-&gt;lsr
op_and_assign
op_complement
id|UART_LSR_TEMT
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|info-&gt;tq
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|from_user
)paren
id|up
c_func
(paren
op_amp
id|info-&gt;write_sem
)paren
suffix:semicolon
r_return
id|total
suffix:semicolon
)brace
r_static
r_int
DECL|function|ctc_tty_write_room
id|ctc_tty_write_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|ctc_tty_info
op_star
id|info
op_assign
(paren
id|ctc_tty_info
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|ctc_tty_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;ctc_tty_write_room&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|CTC_TTY_XMIT_SIZE
suffix:semicolon
)brace
r_static
r_int
DECL|function|ctc_tty_chars_in_buffer
id|ctc_tty_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|ctc_tty_info
op_star
id|info
op_assign
(paren
id|ctc_tty_info
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|ctc_tty_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;ctc_tty_chars_in_buffer&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|ctc_tty_flush_buffer
id|ctc_tty_flush_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|ctc_tty_info
op_star
id|info
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|info
op_assign
(paren
id|ctc_tty_info
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|ctc_tty_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;ctc_tty_flush_buffer&quot;
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb_queue_purge
c_func
(paren
op_amp
id|info-&gt;tx_queue
)paren
suffix:semicolon
id|info-&gt;lsr
op_or_assign
id|UART_LSR_TEMT
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ctc_tty_flush_chars
id|ctc_tty_flush_chars
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|ctc_tty_info
op_star
id|info
op_assign
(paren
id|ctc_tty_info
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|ctc_tty_shuttingdown
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ctc_tty_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;ctc_tty_flush_chars&quot;
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;stopped
op_logical_or
id|tty-&gt;hw_stopped
op_logical_or
(paren
op_logical_neg
id|skb_queue_len
c_func
(paren
op_amp
id|info-&gt;tx_queue
)paren
)paren
)paren
r_return
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|info-&gt;tq
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ------------------------------------------------------------&n; * ctc_tty_throttle()&n; *&n; * This routine is called by the upper-layer tty layer to signal that&n; * incoming characters should be throttled.&n; * ------------------------------------------------------------&n; */
r_static
r_void
DECL|function|ctc_tty_throttle
id|ctc_tty_throttle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|ctc_tty_info
op_star
id|info
op_assign
(paren
id|ctc_tty_info
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|ctc_tty_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;ctc_tty_throttle&quot;
)paren
)paren
r_return
suffix:semicolon
id|info-&gt;mcr
op_and_assign
op_complement
id|UART_MCR_RTS
suffix:semicolon
r_if
c_cond
(paren
id|I_IXOFF
c_func
(paren
id|tty
)paren
)paren
id|ctc_tty_inject
c_func
(paren
id|info
comma
id|STOP_CHAR
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
id|ctc_tty_transmit_status
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ctc_tty_unthrottle
id|ctc_tty_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|ctc_tty_info
op_star
id|info
op_assign
(paren
id|ctc_tty_info
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|ctc_tty_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;ctc_tty_unthrottle&quot;
)paren
)paren
r_return
suffix:semicolon
id|info-&gt;mcr
op_or_assign
id|UART_MCR_RTS
suffix:semicolon
r_if
c_cond
(paren
id|I_IXOFF
c_func
(paren
id|tty
)paren
)paren
id|ctc_tty_inject
c_func
(paren
id|info
comma
id|START_CHAR
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
id|ctc_tty_transmit_status
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ------------------------------------------------------------&n; * ctc_tty_ioctl() and friends&n; * ------------------------------------------------------------&n; */
multiline_comment|/*&n; * ctc_tty_get_lsr_info - get line status register info&n; *&n; * Purpose: Let user call ioctl() to get info when the UART physically&n; *          is emptied.  On bus types like RS485, the transmitter must&n; *          release the bus after transmitting. This must be done when&n; *          the transmit shift register is empty, not be done when the&n; *          transmit holding register is empty.  This functionality&n; *          allows RS485 driver to be written in user space.&n; */
r_static
r_int
DECL|function|ctc_tty_get_lsr_info
id|ctc_tty_get_lsr_info
c_func
(paren
id|ctc_tty_info
op_star
id|info
comma
id|uint
op_star
id|value
)paren
(brace
id|u_char
id|status
suffix:semicolon
id|uint
id|result
suffix:semicolon
id|ulong
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|status
op_assign
id|info-&gt;lsr
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|result
op_assign
(paren
(paren
id|status
op_amp
id|UART_LSR_TEMT
)paren
ques
c_cond
id|TIOCSER_TEMT
suffix:colon
l_int|0
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|result
comma
(paren
id|uint
op_star
)paren
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|ctc_tty_get_ctc_tty_info
id|ctc_tty_get_ctc_tty_info
c_func
(paren
id|ctc_tty_info
op_star
id|info
comma
id|uint
op_star
id|value
)paren
(brace
id|u_char
id|control
comma
id|status
suffix:semicolon
id|uint
id|result
suffix:semicolon
id|ulong
id|flags
suffix:semicolon
id|control
op_assign
id|info-&gt;mcr
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|status
op_assign
id|info-&gt;msr
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|result
op_assign
(paren
(paren
id|control
op_amp
id|UART_MCR_RTS
)paren
ques
c_cond
id|TIOCM_RTS
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|control
op_amp
id|UART_MCR_DTR
)paren
ques
c_cond
id|TIOCM_DTR
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|status
op_amp
id|UART_MSR_DCD
)paren
ques
c_cond
id|TIOCM_CAR
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|status
op_amp
id|UART_MSR_RI
)paren
ques
c_cond
id|TIOCM_RNG
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|status
op_amp
id|UART_MSR_DSR
)paren
ques
c_cond
id|TIOCM_DSR
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|status
op_amp
id|UART_MSR_CTS
)paren
ques
c_cond
id|TIOCM_CTS
suffix:colon
l_int|0
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|result
comma
(paren
id|uint
op_star
)paren
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|ctc_tty_set_ctc_tty_info
id|ctc_tty_set_ctc_tty_info
c_func
(paren
id|ctc_tty_info
op_star
id|info
comma
id|uint
id|cmd
comma
id|uint
op_star
id|value
)paren
(brace
id|uint
id|arg
suffix:semicolon
r_int
id|old_mcr
op_assign
id|info-&gt;mcr
op_amp
(paren
id|UART_MCR_RTS
op_or
id|UART_MCR_DTR
)paren
suffix:semicolon
id|get_user
c_func
(paren
id|arg
comma
(paren
id|uint
op_star
)paren
id|value
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCMBIS
suffix:colon
macro_line|#ifdef CTC_DEBUG_MODEM_IOCTL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s%d ioctl TIOCMBIS&bslash;n&quot;
comma
id|CTC_TTY_NAME
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_RTS
)paren
id|info-&gt;mcr
op_or_assign
id|UART_MCR_RTS
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_DTR
)paren
id|info-&gt;mcr
op_or_assign
id|UART_MCR_DTR
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCMBIC
suffix:colon
macro_line|#ifdef CTC_DEBUG_MODEM_IOCTL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s%d ioctl TIOCMBIC&bslash;n&quot;
comma
id|CTC_TTY_NAME
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_RTS
)paren
id|info-&gt;mcr
op_and_assign
op_complement
id|UART_MCR_RTS
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_DTR
)paren
id|info-&gt;mcr
op_and_assign
op_complement
id|UART_MCR_DTR
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCMSET
suffix:colon
macro_line|#ifdef CTC_DEBUG_MODEM_IOCTL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s%d ioctl TIOCMSET&bslash;n&quot;
comma
id|CTC_TTY_NAME
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
id|info-&gt;mcr
op_assign
(paren
(paren
id|info-&gt;mcr
op_amp
op_complement
(paren
id|UART_MCR_RTS
op_or
id|UART_MCR_DTR
)paren
)paren
op_or
(paren
(paren
id|arg
op_amp
id|TIOCM_RTS
)paren
ques
c_cond
id|UART_MCR_RTS
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|arg
op_amp
id|TIOCM_DTR
)paren
ques
c_cond
id|UART_MCR_DTR
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|info-&gt;mcr
op_amp
(paren
id|UART_MCR_RTS
op_or
id|UART_MCR_DTR
)paren
)paren
op_ne
id|old_mcr
)paren
id|ctc_tty_transmit_status
c_func
(paren
id|info
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|ctc_tty_ioctl
id|ctc_tty_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
id|uint
id|cmd
comma
id|ulong
id|arg
)paren
(brace
id|ctc_tty_info
op_star
id|info
op_assign
(paren
id|ctc_tty_info
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|ctc_tty_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;ctc_tty_ioctl&quot;
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_IO_ERROR
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TCSBRK
suffix:colon
multiline_comment|/* SVID version: non-zero arg --&gt; no break */
macro_line|#ifdef CTC_DEBUG_MODEM_IOCTL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s%d ioctl TCSBRK&bslash;n&quot;
comma
id|CTC_TTY_NAME
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
id|retval
op_assign
id|tty_check_change
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TCSBRKP
suffix:colon
multiline_comment|/* support for POSIX tcsendbreak() */
macro_line|#ifdef CTC_DEBUG_MODEM_IOCTL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s%d ioctl TCSBRKP&bslash;n&quot;
comma
id|CTC_TTY_NAME
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
id|retval
op_assign
id|tty_check_change
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCGSOFTCAR
suffix:colon
macro_line|#ifdef CTC_DEBUG_MODEM_IOCTL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s%d ioctl TIOCGSOFTCAR&bslash;n&quot;
comma
id|CTC_TTY_NAME
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|put_user
c_func
(paren
id|C_CLOCAL
c_func
(paren
id|tty
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
(paren
id|ulong
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCSSOFTCAR
suffix:colon
macro_line|#ifdef CTC_DEBUG_MODEM_IOCTL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s%d ioctl TIOCSSOFTCAR&bslash;n&quot;
comma
id|CTC_TTY_NAME
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|get_user
c_func
(paren
id|arg
comma
(paren
id|ulong
op_star
)paren
id|arg
)paren
suffix:semicolon
id|tty-&gt;termios-&gt;c_cflag
op_assign
(paren
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
op_complement
id|CLOCAL
)paren
op_or
(paren
id|arg
ques
c_cond
id|CLOCAL
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCMGET
suffix:colon
macro_line|#ifdef CTC_DEBUG_MODEM_IOCTL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s%d ioctl TIOCMGET&bslash;n&quot;
comma
id|CTC_TTY_NAME
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|uint
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_return
id|ctc_tty_get_ctc_tty_info
c_func
(paren
id|info
comma
(paren
id|uint
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|TIOCMBIS
suffix:colon
r_case
id|TIOCMBIC
suffix:colon
r_case
id|TIOCMSET
suffix:colon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|uint
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_return
id|ctc_tty_set_ctc_tty_info
c_func
(paren
id|info
comma
id|cmd
comma
(paren
id|uint
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|TIOCSERGETLSR
suffix:colon
multiline_comment|/* Get line status register */
macro_line|#ifdef CTC_DEBUG_MODEM_IOCTL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s%d ioctl TIOCSERGETLSR&bslash;n&quot;
comma
id|CTC_TTY_NAME
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|uint
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_else
r_return
id|ctc_tty_get_lsr_info
c_func
(paren
id|info
comma
(paren
id|uint
op_star
)paren
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
macro_line|#ifdef CTC_DEBUG_MODEM_IOCTL
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;UNKNOWN ioctl 0x%08x on %s%d&bslash;n&quot;
comma
id|cmd
comma
id|CTC_TTY_NAME
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|ctc_tty_set_termios
id|ctc_tty_set_termios
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old_termios
)paren
(brace
id|ctc_tty_info
op_star
id|info
op_assign
(paren
id|ctc_tty_info
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|cflag
op_assign
id|tty-&gt;termios-&gt;c_cflag
suffix:semicolon
id|ctc_tty_change_speed
c_func
(paren
id|info
)paren
suffix:semicolon
multiline_comment|/* Handle transition to B0 */
r_if
c_cond
(paren
(paren
id|old_termios-&gt;c_cflag
op_amp
id|CBAUD
)paren
op_logical_and
op_logical_neg
(paren
id|cflag
op_amp
id|CBAUD
)paren
)paren
(brace
id|info-&gt;mcr
op_and_assign
op_complement
(paren
id|UART_MCR_DTR
op_or
id|UART_MCR_RTS
)paren
suffix:semicolon
id|ctc_tty_transmit_status
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
multiline_comment|/* Handle transition from B0 to other */
r_if
c_cond
(paren
op_logical_neg
(paren
id|old_termios-&gt;c_cflag
op_amp
id|CBAUD
)paren
op_logical_and
(paren
id|cflag
op_amp
id|CBAUD
)paren
)paren
(brace
id|info-&gt;mcr
op_or_assign
id|UART_MCR_DTR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
op_logical_or
op_logical_neg
id|test_bit
c_func
(paren
id|TTY_THROTTLED
comma
op_amp
id|tty-&gt;flags
)paren
)paren
(brace
id|info-&gt;mcr
op_or_assign
id|UART_MCR_RTS
suffix:semicolon
)brace
id|ctc_tty_transmit_status
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
multiline_comment|/* Handle turning off CRTSCTS */
r_if
c_cond
(paren
(paren
id|old_termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
op_logical_and
op_logical_neg
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
)paren
id|tty-&gt;hw_stopped
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * ------------------------------------------------------------&n; * ctc_tty_open() and friends&n; * ------------------------------------------------------------&n; */
r_static
r_int
DECL|function|ctc_tty_block_til_ready
id|ctc_tty_block_til_ready
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
comma
id|ctc_tty_info
op_star
id|info
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
l_int|NULL
)paren
suffix:semicolon
r_int
id|do_clocal
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|retval
suffix:semicolon
multiline_comment|/*&n;&t; * If the device is in the middle of being closed, then block&n;&t; * until it&squot;s done, and then try again.&n;&t; */
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
op_logical_or
(paren
id|info-&gt;flags
op_amp
id|CTC_ASYNC_CLOSING
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|CTC_ASYNC_CLOSING
)paren
id|interruptible_sleep_on
c_func
(paren
op_amp
id|info-&gt;close_wait
)paren
suffix:semicolon
macro_line|#ifdef MODEM_DO_RESTART
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|CTC_ASYNC_HUP_NOTIFY
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
r_else
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
macro_line|#else
r_return
op_minus
id|EAGAIN
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t; * If non-blocking mode is set, then make the check up front&n;&t; * and then exit.&n;&t; */
r_if
c_cond
(paren
(paren
id|filp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
op_logical_or
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_IO_ERROR
)paren
)paren
)paren
(brace
id|info-&gt;flags
op_or_assign
id|CTC_ASYNC_NORMAL_ACTIVE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CLOCAL
)paren
id|do_clocal
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Block waiting for the carrier detect and the line to become&n;&t; * free (i.e., not in use by the callout).  While we are in&n;&t; * this loop, info-&gt;count is dropped by one, so that&n;&t; * ctc_tty_close() knows when to free things.  We restore it upon&n;&t; * exit, either normal or abnormal.&n;&t; */
id|retval
op_assign
l_int|0
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|info-&gt;open_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
macro_line|#ifdef CTC_DEBUG_MODEM_OPEN
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ctc_tty_block_til_ready before block: %s%d, count = %d&bslash;n&quot;
comma
id|CTC_TTY_NAME
comma
id|info-&gt;line
comma
id|info-&gt;count
)paren
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
)paren
id|info-&gt;count
op_decrement
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|info-&gt;blocked_open
op_increment
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
op_logical_or
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|CTC_ASYNC_INITIALIZED
)paren
)paren
(brace
macro_line|#ifdef MODEM_DO_RESTART
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|CTC_ASYNC_HUP_NOTIFY
)paren
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_else
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
macro_line|#else
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|CTC_ASYNC_CLOSING
)paren
op_logical_and
(paren
id|do_clocal
op_logical_or
(paren
id|info-&gt;msr
op_amp
id|UART_MSR_DCD
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef CTC_DEBUG_MODEM_OPEN
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ctc_tty_block_til_ready blocking: %s%d, count = %d&bslash;n&quot;
comma
id|CTC_TTY_NAME
comma
id|info-&gt;line
comma
id|info-&gt;count
)paren
suffix:semicolon
macro_line|#endif
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|info-&gt;open_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
id|info-&gt;count
op_increment
suffix:semicolon
id|info-&gt;blocked_open
op_decrement
suffix:semicolon
macro_line|#ifdef CTC_DEBUG_MODEM_OPEN
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ctc_tty_block_til_ready after blocking: %s%d, count = %d&bslash;n&quot;
comma
id|CTC_TTY_NAME
comma
id|info-&gt;line
comma
id|info-&gt;count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|info-&gt;flags
op_or_assign
id|CTC_ASYNC_NORMAL_ACTIVE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called whenever a serial port is opened.  It&n; * enables interrupts for a serial port, linking in its async structure into&n; * the IRQ chain.   It also performs the serial-specific&n; * initialization for the tty structure.&n; */
r_static
r_int
DECL|function|ctc_tty_open
id|ctc_tty_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|ctc_tty_info
op_star
id|info
suffix:semicolon
r_int
r_int
id|saveflags
suffix:semicolon
r_int
id|retval
comma
id|line
suffix:semicolon
id|line
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|tty-&gt;driver.minor_start
suffix:semicolon
r_if
c_cond
(paren
id|line
template_param
id|CTC_TTY_MAX_DEVICES
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|info
op_assign
op_amp
id|driver-&gt;info
(braket
id|line
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ctc_tty_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;ctc_tty_open&quot;
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;netdev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
macro_line|#ifdef CTC_DEBUG_MODEM_OPEN
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ctc_tty_open %s%d, count = %d&bslash;n&quot;
comma
id|tty-&gt;driver.name
comma
id|info-&gt;line
comma
id|info-&gt;count
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ctc_tty_lock
comma
id|saveflags
)paren
suffix:semicolon
id|info-&gt;count
op_increment
suffix:semicolon
id|tty-&gt;driver_data
op_assign
id|info
suffix:semicolon
id|info-&gt;tty
op_assign
id|tty
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ctc_tty_lock
comma
id|saveflags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Start up serial port&n;&t; */
id|retval
op_assign
id|ctc_tty_startup
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
macro_line|#ifdef CTC_DEBUG_MODEM_OPEN
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ctc_tty_open return after startup&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|retval
suffix:semicolon
)brace
id|retval
op_assign
id|ctc_tty_block_til_ready
c_func
(paren
id|tty
comma
id|filp
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
macro_line|#ifdef CTC_DEBUG_MODEM_OPEN
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ctc_tty_open return after ctc_tty_block_til_ready &bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|retval
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|info-&gt;count
op_eq
l_int|1
)paren
op_logical_and
(paren
id|info-&gt;flags
op_amp
id|CTC_ASYNC_SPLIT_TERMIOS
)paren
)paren
(brace
op_star
id|tty-&gt;termios
op_assign
id|info-&gt;normal_termios
suffix:semicolon
id|ctc_tty_change_speed
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
macro_line|#ifdef CTC_DEBUG_MODEM_OPEN
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ctc_tty_open %s%d successful...&bslash;n&quot;
comma
id|CTC_TTY_NAME
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|ctc_tty_close
id|ctc_tty_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|ctc_tty_info
op_star
id|info
op_assign
(paren
id|ctc_tty_info
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|saveflags
suffix:semicolon
id|ulong
id|flags
suffix:semicolon
id|ulong
id|timeout
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
op_logical_or
id|ctc_tty_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;ctc_tty_close&quot;
)paren
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#ifdef CTC_DEBUG_MODEM_OPEN
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ctc_tty_close return after tty_hung_up_p&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|tty-&gt;count
op_eq
l_int|1
)paren
op_logical_and
(paren
id|info-&gt;count
op_ne
l_int|1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Uh, oh.  tty-&gt;count is 1, which means that the tty&n;&t;&t; * structure will be freed.  Info-&gt;count should always&n;&t;&t; * be one in these conditions.  If it&squot;s greater than&n;&t;&t; * one, we&squot;ve got real problems, since it means the&n;&t;&t; * serial port won&squot;t be shutdown.&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ctc_tty_close: bad port count; tty-&gt;count is 1, &quot;
l_string|&quot;info-&gt;count is %d&bslash;n&quot;
comma
id|info-&gt;count
)paren
suffix:semicolon
id|info-&gt;count
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|info-&gt;count
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ctc_tty_close: bad port count for %s%d: %d&bslash;n&quot;
comma
id|CTC_TTY_NAME
comma
id|info-&gt;line
comma
id|info-&gt;count
)paren
suffix:semicolon
id|info-&gt;count
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;count
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#ifdef CTC_DEBUG_MODEM_OPEN
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ctc_tty_close after info-&gt;count != 0&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
id|info-&gt;flags
op_or_assign
id|CTC_ASYNC_CLOSING
suffix:semicolon
multiline_comment|/*&n;&t; * Save the termios structure, since this port may have&n;&t; * separate termios for callout and dialin.&n;&t; */
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|CTC_ASYNC_NORMAL_ACTIVE
)paren
id|info-&gt;normal_termios
op_assign
op_star
id|tty-&gt;termios
suffix:semicolon
id|tty-&gt;closing
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * At this point we stop accepting input.  To do this, we&n;&t; * disable the receive line status interrupts, and tell the&n;&t; * interrupt driver to stop checking the data ready bit in the&n;&t; * line status register.&n;&t; */
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|CTC_ASYNC_INITIALIZED
)paren
(brace
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
l_int|3000
)paren
suffix:semicolon
multiline_comment|/* 30 seconds timeout */
multiline_comment|/*&n;&t;&t; * Before we drop DTR, make sure the UART transmitter&n;&t;&t; * has completely drained; this is especially&n;&t;&t; * important if there is a transmit FIFO!&n;&t;&t; */
id|timeout
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|info-&gt;lsr
op_amp
id|UART_LSR_TEMT
)paren
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
id|ctc_tty_shutdown
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.flush_buffer
)paren
id|tty-&gt;driver
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
id|tty-&gt;ldisc
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ctc_tty_lock
comma
id|saveflags
)paren
suffix:semicolon
id|info-&gt;tty
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ctc_tty_lock
comma
id|saveflags
)paren
suffix:semicolon
id|tty-&gt;closing
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;blocked_open
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;open_wait
)paren
suffix:semicolon
)brace
id|info-&gt;flags
op_and_assign
op_complement
(paren
id|CTC_ASYNC_NORMAL_ACTIVE
op_or
id|CTC_ASYNC_CLOSING
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;close_wait
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#ifdef CTC_DEBUG_MODEM_OPEN
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ctc_tty_close normal exit&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * ctc_tty_hangup() --- called by tty_hangup() when a hangup is signaled.&n; */
r_static
r_void
DECL|function|ctc_tty_hangup
id|ctc_tty_hangup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|ctc_tty_info
op_star
id|info
op_assign
(paren
id|ctc_tty_info
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|saveflags
suffix:semicolon
r_if
c_cond
(paren
id|ctc_tty_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;ctc_tty_hangup&quot;
)paren
)paren
r_return
suffix:semicolon
id|ctc_tty_shutdown
c_func
(paren
id|info
)paren
suffix:semicolon
id|info-&gt;count
op_assign
l_int|0
suffix:semicolon
id|info-&gt;flags
op_and_assign
op_complement
id|CTC_ASYNC_NORMAL_ACTIVE
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ctc_tty_lock
comma
id|saveflags
)paren
suffix:semicolon
id|info-&gt;tty
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ctc_tty_lock
comma
id|saveflags
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;open_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * For all online tty&squot;s, try sending data to&n; * the lower levels.&n; */
r_static
r_void
DECL|function|ctc_tty_task
id|ctc_tty_task
c_func
(paren
id|ctc_tty_info
op_star
id|info
)paren
(brace
r_int
r_int
id|saveflags
suffix:semicolon
r_int
id|again
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ctc_tty_lock
comma
id|saveflags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|ctc_tty_shuttingdown
)paren
op_logical_and
id|info
)paren
(brace
id|again
op_assign
id|ctc_tty_tint
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|again
)paren
id|info-&gt;lsr
op_or_assign
id|UART_LSR_TEMT
suffix:semicolon
id|again
op_or_assign
id|ctc_tty_readmodem
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|again
)paren
(brace
id|queue_task
c_func
(paren
op_amp
id|info-&gt;tq
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ctc_tty_lock
comma
id|saveflags
)paren
suffix:semicolon
)brace
r_int
DECL|function|ctc_tty_init
id|ctc_tty_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|ctc_tty_info
op_star
id|info
suffix:semicolon
r_struct
id|tty_driver
op_star
id|device
suffix:semicolon
id|driver
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|ctc_tty_driver
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Out of memory in ctc_tty_modem_init&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|driver
comma
l_int|0
comma
r_sizeof
(paren
id|ctc_tty_driver
)paren
)paren
suffix:semicolon
id|device
op_assign
op_amp
id|driver-&gt;ctc_tty_device
suffix:semicolon
id|device-&gt;magic
op_assign
id|TTY_DRIVER_MAGIC
suffix:semicolon
id|device-&gt;name
op_assign
id|ctc_ttyname
suffix:semicolon
id|device-&gt;major
op_assign
id|CTC_TTY_MAJOR
suffix:semicolon
id|device-&gt;minor_start
op_assign
l_int|0
suffix:semicolon
id|device-&gt;num
op_assign
id|CTC_TTY_MAX_DEVICES
suffix:semicolon
id|device-&gt;type
op_assign
id|TTY_DRIVER_TYPE_SERIAL
suffix:semicolon
id|device-&gt;subtype
op_assign
id|CTC_SERIAL_TYPE_NORMAL
suffix:semicolon
id|device-&gt;init_termios
op_assign
id|tty_std_termios
suffix:semicolon
id|device-&gt;init_termios.c_cflag
op_assign
id|B9600
op_or
id|CS8
op_or
id|CREAD
op_or
id|HUPCL
op_or
id|CLOCAL
suffix:semicolon
id|device-&gt;flags
op_assign
id|TTY_DRIVER_REAL_RAW
suffix:semicolon
id|device-&gt;refcount
op_assign
op_amp
id|driver-&gt;refcount
suffix:semicolon
id|device-&gt;table
op_assign
id|driver-&gt;modem_table
suffix:semicolon
id|device-&gt;termios
op_assign
id|driver-&gt;modem_termios
suffix:semicolon
id|device-&gt;termios_locked
op_assign
id|driver-&gt;modem_termios_locked
suffix:semicolon
id|device-&gt;open
op_assign
id|ctc_tty_open
suffix:semicolon
id|device-&gt;close
op_assign
id|ctc_tty_close
suffix:semicolon
id|device-&gt;write
op_assign
id|ctc_tty_write
suffix:semicolon
id|device-&gt;put_char
op_assign
l_int|NULL
suffix:semicolon
id|device-&gt;flush_chars
op_assign
id|ctc_tty_flush_chars
suffix:semicolon
id|device-&gt;write_room
op_assign
id|ctc_tty_write_room
suffix:semicolon
id|device-&gt;chars_in_buffer
op_assign
id|ctc_tty_chars_in_buffer
suffix:semicolon
id|device-&gt;flush_buffer
op_assign
id|ctc_tty_flush_buffer
suffix:semicolon
id|device-&gt;ioctl
op_assign
id|ctc_tty_ioctl
suffix:semicolon
id|device-&gt;throttle
op_assign
id|ctc_tty_throttle
suffix:semicolon
id|device-&gt;unthrottle
op_assign
id|ctc_tty_unthrottle
suffix:semicolon
id|device-&gt;set_termios
op_assign
id|ctc_tty_set_termios
suffix:semicolon
id|device-&gt;stop
op_assign
l_int|NULL
suffix:semicolon
id|device-&gt;start
op_assign
l_int|NULL
suffix:semicolon
id|device-&gt;hangup
op_assign
id|ctc_tty_hangup
suffix:semicolon
id|device-&gt;driver_name
op_assign
l_string|&quot;ctc_tty&quot;
suffix:semicolon
r_if
c_cond
(paren
id|tty_register_driver
c_func
(paren
id|device
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc_tty: Couldn&squot;t register serial-device&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|driver
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CTC_TTY_MAX_DEVICES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|info
op_assign
op_amp
id|driver-&gt;info
(braket
id|i
)braket
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|info-&gt;write_sem
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= 0x020400
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|info-&gt;tq.list
)paren
suffix:semicolon
macro_line|#else
id|info-&gt;tq.next
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
id|info-&gt;tq.sync
op_assign
l_int|0
suffix:semicolon
id|info-&gt;tq.routine
op_assign
(paren
r_void
op_star
)paren
(paren
r_void
op_star
)paren
id|ctc_tty_task
suffix:semicolon
id|info-&gt;tq.data
op_assign
id|info
suffix:semicolon
id|info-&gt;magic
op_assign
id|CTC_ASYNC_MAGIC
suffix:semicolon
id|info-&gt;line
op_assign
id|i
suffix:semicolon
id|info-&gt;tty
op_assign
l_int|0
suffix:semicolon
id|info-&gt;count
op_assign
l_int|0
suffix:semicolon
id|info-&gt;blocked_open
op_assign
l_int|0
suffix:semicolon
id|info-&gt;normal_termios
op_assign
id|device-&gt;init_termios
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|info-&gt;open_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|info-&gt;close_wait
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|info-&gt;tx_queue
)paren
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|info-&gt;rx_queue
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|info-&gt;stoptimer
)paren
suffix:semicolon
id|info-&gt;stoptimer.function
op_assign
id|ctc_tty_stopdev
suffix:semicolon
id|info-&gt;stoptimer.data
op_assign
(paren
r_int
r_int
)paren
id|info
suffix:semicolon
id|info-&gt;mcr
op_assign
id|UART_MCR_RTS
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|ctc_tty_register_netdev
id|ctc_tty_register_netdev
c_func
(paren
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ttynum
suffix:semicolon
r_char
op_star
id|err
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|dev
)paren
op_logical_or
(paren
op_logical_neg
id|dev-&gt;name
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc_tty_register_netdev called &quot;
l_string|&quot;with NULL dev or NULL dev-name&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|p
op_assign
id|dev-&gt;name
suffix:semicolon
id|p
op_logical_and
(paren
(paren
op_star
id|p
OL
l_char|&squot;0&squot;
)paren
op_logical_or
(paren
op_star
id|p
OG
l_char|&squot;9&squot;
)paren
)paren
suffix:semicolon
id|p
op_increment
)paren
suffix:semicolon
id|ttynum
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
op_amp
id|err
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ttynum
OL
l_int|0
)paren
op_logical_or
(paren
id|ttynum
op_ge
id|CTC_TTY_MAX_DEVICES
)paren
op_logical_or
(paren
id|err
op_logical_and
op_star
id|err
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc_tty_register_netdev called &quot;
l_string|&quot;with number in name &squot;%s&squot;&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|driver-&gt;info
(braket
id|ttynum
)braket
dot
id|netdev
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ctc_tty_register_netdev called &quot;
l_string|&quot;for already registered device &squot;%s&squot;&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|driver-&gt;info
(braket
id|ttynum
)braket
dot
id|netdev
op_assign
id|dev
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|ctc_tty_unregister_netdev
id|ctc_tty_unregister_netdev
c_func
(paren
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|saveflags
suffix:semicolon
id|ctc_tty_info
op_star
id|info
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ctc_tty_lock
comma
id|saveflags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CTC_TTY_MAX_DEVICES
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|driver-&gt;info
(braket
id|i
)braket
dot
id|netdev
op_eq
id|dev
)paren
(brace
id|info
op_assign
op_amp
id|driver-&gt;info
(braket
id|i
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info
)paren
(brace
id|info-&gt;netdev
op_assign
l_int|NULL
suffix:semicolon
id|skb_queue_purge
c_func
(paren
op_amp
id|info-&gt;tx_queue
)paren
suffix:semicolon
id|skb_queue_purge
c_func
(paren
op_amp
id|info-&gt;rx_queue
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ctc_tty_lock
comma
id|saveflags
)paren
suffix:semicolon
)brace
r_void
DECL|function|ctc_tty_cleanup
id|ctc_tty_cleanup
c_func
(paren
r_int
id|final
)paren
(brace
r_int
r_int
id|saveflags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ctc_tty_lock
comma
id|saveflags
)paren
suffix:semicolon
id|ctc_tty_shuttingdown
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|final
)paren
(brace
id|kfree
c_func
(paren
id|driver
)paren
suffix:semicolon
id|driver
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CTC_TTY_MAX_DEVICES
suffix:semicolon
id|i
op_increment
)paren
id|driver-&gt;info
(braket
id|i
)braket
dot
id|tq.routine
op_assign
l_int|NULL
suffix:semicolon
id|tty_unregister_driver
c_func
(paren
op_amp
id|driver-&gt;ctc_tty_device
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ctc_tty_lock
comma
id|saveflags
)paren
suffix:semicolon
)brace
eof
