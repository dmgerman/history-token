multiline_comment|/*&n; * drivers/s390/char/vmlogrdr.c&n; *&t;character device driver for reading z/VM system service records&n; *&n; *&n; *&t;Copyright (C) 2004 IBM Corporation&n; *&t;character device driver for reading z/VM system service records,&n; *&t;Version 1.0&n; *&t;Author(s): Xenia Tkatschow &lt;xenia@us.ibm.com&gt;&n; *&t;&t;   Stefan Weinhuber &lt;wein@de.ibm.com&gt;&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/cpcmd.h&gt;
macro_line|#include &lt;asm/debug.h&gt;
macro_line|#include &lt;asm/ebcdic.h&gt;
macro_line|#include &quot;../net/iucv.h&quot;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/cdev.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/string.h&gt;
id|MODULE_AUTHOR
(paren
l_string|&quot;(C) 2004 IBM Corporation by Xenia Tkatschow (xenia@us.ibm.com)&bslash;n&quot;
l_string|&quot;                            Stefan Weinhuber (wein@de.ibm.com)&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
(paren
l_string|&quot;Character device driver for reading z/VM &quot;
l_string|&quot;system service records.&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * The size of the buffer for iucv data transfer is one page,&n; * but in addition to the data we read from iucv we also&n; * place an integer and some characters into that buffer,&n; * so the maximum size for record data is a little less then&n; * one page.&n; */
DECL|macro|NET_BUFFER_SIZE
mdefine_line|#define NET_BUFFER_SIZE&t;(PAGE_SIZE - sizeof(int) - sizeof(FENCE))
multiline_comment|/*&n; * The elements that are concurrently accessed by bottom halves are&n; * connection_established, iucv_path_severed, local_interrupt_buffer&n; * and receive_ready. The first three can be protected by&n; * priv_lock.  receive_ready is atomic, so it can be incremented and&n; * decremented without holding a lock.&n; * The variable dev_in_use needs to be protected by the lock, since&n; * it&squot;s a flag used by open to make sure that the device is opened only&n; * by one user at the same time.&n; */
DECL|struct|vmlogrdr_priv_t
r_struct
id|vmlogrdr_priv_t
(brace
DECL|member|system_service
r_char
id|system_service
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|internal_name
r_char
id|internal_name
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|recording_name
r_char
id|recording_name
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|pathid
id|u16
id|pathid
suffix:semicolon
DECL|member|connection_established
r_int
id|connection_established
suffix:semicolon
DECL|member|iucv_path_severed
r_int
id|iucv_path_severed
suffix:semicolon
DECL|member|local_interrupt_buffer
id|iucv_MessagePending
id|local_interrupt_buffer
suffix:semicolon
DECL|member|receive_ready
id|atomic_t
id|receive_ready
suffix:semicolon
DECL|member|iucv_handle
id|iucv_handle_t
id|iucv_handle
suffix:semicolon
DECL|member|minor_num
r_int
id|minor_num
suffix:semicolon
DECL|member|buffer
r_char
op_star
id|buffer
suffix:semicolon
DECL|member|current_position
r_char
op_star
id|current_position
suffix:semicolon
DECL|member|remaining
r_int
id|remaining
suffix:semicolon
DECL|member|residual_length
id|ulong
id|residual_length
suffix:semicolon
DECL|member|buffer_free
r_int
id|buffer_free
suffix:semicolon
DECL|member|dev_in_use
r_int
id|dev_in_use
suffix:semicolon
multiline_comment|/* 1: already opened, 0: not opened*/
DECL|member|priv_lock
id|spinlock_t
id|priv_lock
suffix:semicolon
DECL|member|device
r_struct
id|device
op_star
id|device
suffix:semicolon
DECL|member|class_device
r_struct
id|class_device
op_star
id|class_device
suffix:semicolon
DECL|member|autorecording
r_int
id|autorecording
suffix:semicolon
DECL|member|autopurge
r_int
id|autopurge
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * File operation structure for vmlogrdr devices&n; */
r_static
r_int
id|vmlogrdr_open
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
r_int
id|vmlogrdr_release
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
id|ssize_t
id|vmlogrdr_read
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|data
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
suffix:semicolon
DECL|variable|vmlogrdr_fops
r_static
r_struct
id|file_operations
id|vmlogrdr_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|open
op_assign
id|vmlogrdr_open
comma
dot
id|release
op_assign
id|vmlogrdr_release
comma
dot
id|read
op_assign
id|vmlogrdr_read
comma
)brace
suffix:semicolon
DECL|variable|iucvMagic
r_static
id|u8
id|iucvMagic
(braket
l_int|16
)braket
op_assign
(brace
l_int|0xF0
comma
l_int|0x40
comma
l_int|0x40
comma
l_int|0x40
comma
l_int|0x40
comma
l_int|0x40
comma
l_int|0x40
comma
l_int|0x40
comma
l_int|0xF0
comma
l_int|0x40
comma
l_int|0x40
comma
l_int|0x40
comma
l_int|0x40
comma
l_int|0x40
comma
l_int|0x40
comma
l_int|0x40
)brace
suffix:semicolon
DECL|variable|mask
r_static
id|u8
id|mask
(braket
)braket
op_assign
(brace
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
)brace
suffix:semicolon
DECL|variable|iucv_host
r_static
id|u8
id|iucv_host
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
r_static
r_void
id|vmlogrdr_iucv_ConnectionComplete
c_func
(paren
id|iucv_ConnectionComplete
op_star
id|eib
comma
r_void
op_star
id|pgm_data
)paren
suffix:semicolon
r_static
r_void
id|vmlogrdr_iucv_ConnectionSevered
c_func
(paren
id|iucv_ConnectionSevered
op_star
id|eib
comma
r_void
op_star
id|pgm_data
)paren
suffix:semicolon
r_static
r_void
id|vmlogrdr_iucv_MessagePending
c_func
(paren
id|iucv_MessagePending
op_star
id|eib
comma
r_void
op_star
id|pgm_data
)paren
suffix:semicolon
DECL|variable|vmlogrdr_iucvops
r_static
id|iucv_interrupt_ops_t
id|vmlogrdr_iucvops
op_assign
(brace
dot
id|ConnectionComplete
op_assign
id|vmlogrdr_iucv_ConnectionComplete
comma
dot
id|ConnectionSevered
op_assign
id|vmlogrdr_iucv_ConnectionSevered
comma
dot
id|MessagePending
op_assign
id|vmlogrdr_iucv_MessagePending
comma
)brace
suffix:semicolon
DECL|variable|conn_wait_queue
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|conn_wait_queue
)paren
suffix:semicolon
DECL|variable|read_wait_queue
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|read_wait_queue
)paren
suffix:semicolon
multiline_comment|/*&n; * pointer to system service private structure&n; * minor number 0 --&gt; logrec&n; * minor number 1 --&gt; account&n; * minor number 2 --&gt; symptom&n; */
DECL|variable|sys_ser
r_static
r_struct
id|vmlogrdr_priv_t
id|sys_ser
(braket
)braket
op_assign
(brace
(brace
dot
id|system_service
op_assign
l_string|&quot;*LOGREC &quot;
comma
dot
id|internal_name
op_assign
l_string|&quot;logrec&quot;
comma
dot
id|recording_name
op_assign
l_string|&quot;EREP&quot;
comma
dot
id|minor_num
op_assign
l_int|0
comma
dot
id|buffer_free
op_assign
l_int|1
comma
dot
id|priv_lock
op_assign
id|SPIN_LOCK_UNLOCKED
comma
dot
id|autorecording
op_assign
l_int|1
comma
dot
id|autopurge
op_assign
l_int|1
comma
)brace
comma
(brace
dot
id|system_service
op_assign
l_string|&quot;*ACCOUNT&quot;
comma
dot
id|internal_name
op_assign
l_string|&quot;account&quot;
comma
dot
id|recording_name
op_assign
l_string|&quot;ACCOUNT&quot;
comma
dot
id|minor_num
op_assign
l_int|1
comma
dot
id|buffer_free
op_assign
l_int|1
comma
dot
id|priv_lock
op_assign
id|SPIN_LOCK_UNLOCKED
comma
dot
id|autorecording
op_assign
l_int|1
comma
dot
id|autopurge
op_assign
l_int|1
comma
)brace
comma
(brace
dot
id|system_service
op_assign
l_string|&quot;*SYMPTOM&quot;
comma
dot
id|internal_name
op_assign
l_string|&quot;symptom&quot;
comma
dot
id|recording_name
op_assign
l_string|&quot;SYMPTOM&quot;
comma
dot
id|minor_num
op_assign
l_int|2
comma
dot
id|buffer_free
op_assign
l_int|1
comma
dot
id|priv_lock
op_assign
id|SPIN_LOCK_UNLOCKED
comma
dot
id|autorecording
op_assign
l_int|1
comma
dot
id|autopurge
op_assign
l_int|1
comma
)brace
)brace
suffix:semicolon
DECL|macro|MAXMINOR
mdefine_line|#define MAXMINOR  (sizeof(sys_ser)/sizeof(struct vmlogrdr_priv_t))
DECL|variable|FENCE
r_static
r_char
id|FENCE
(braket
)braket
op_assign
(brace
l_string|&quot;EOR&quot;
)brace
suffix:semicolon
DECL|variable|vmlogrdr_major
r_static
r_int
id|vmlogrdr_major
op_assign
l_int|0
suffix:semicolon
DECL|variable|vmlogrdr_cdev
r_static
r_struct
id|cdev
op_star
id|vmlogrdr_cdev
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|recording_class_AB
r_static
r_int
id|recording_class_AB
suffix:semicolon
r_static
r_void
DECL|function|vmlogrdr_iucv_ConnectionComplete
id|vmlogrdr_iucv_ConnectionComplete
(paren
id|iucv_ConnectionComplete
op_star
id|eib
comma
r_void
op_star
id|pgm_data
)paren
(brace
r_struct
id|vmlogrdr_priv_t
op_star
id|logptr
op_assign
id|pgm_data
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|logptr-&gt;priv_lock
)paren
suffix:semicolon
id|logptr-&gt;connection_established
op_assign
l_int|1
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|logptr-&gt;priv_lock
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|conn_wait_queue
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|vmlogrdr_iucv_ConnectionSevered
id|vmlogrdr_iucv_ConnectionSevered
(paren
id|iucv_ConnectionSevered
op_star
id|eib
comma
r_void
op_star
id|pgm_data
)paren
(brace
id|u8
id|reason
op_assign
(paren
id|u8
)paren
id|eib-&gt;ipuser
(braket
l_int|8
)braket
suffix:semicolon
r_struct
id|vmlogrdr_priv_t
op_star
id|logptr
op_assign
id|pgm_data
suffix:semicolon
id|printk
(paren
id|KERN_ERR
l_string|&quot;vmlogrdr: connection severed with&quot;
l_string|&quot; reason %i&bslash;n&quot;
comma
id|reason
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|logptr-&gt;priv_lock
)paren
suffix:semicolon
id|logptr-&gt;connection_established
op_assign
l_int|0
suffix:semicolon
id|logptr-&gt;iucv_path_severed
op_assign
l_int|1
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|logptr-&gt;priv_lock
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|conn_wait_queue
)paren
suffix:semicolon
multiline_comment|/* just in case we&squot;re sleeping waiting for a record */
id|wake_up_interruptible
c_func
(paren
op_amp
id|read_wait_queue
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|vmlogrdr_iucv_MessagePending
id|vmlogrdr_iucv_MessagePending
(paren
id|iucv_MessagePending
op_star
id|eib
comma
r_void
op_star
id|pgm_data
)paren
(brace
r_struct
id|vmlogrdr_priv_t
op_star
id|logptr
op_assign
id|pgm_data
suffix:semicolon
multiline_comment|/*&n;&t; * This function is the bottom half so it should be quick.&n;&t; * Copy the external interrupt data into our local eib and increment&n;&t; * the usage count&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|logptr-&gt;priv_lock
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
(paren
id|logptr-&gt;local_interrupt_buffer
)paren
comma
id|eib
comma
r_sizeof
(paren
op_star
id|eib
)paren
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|logptr-&gt;receive_ready
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|logptr-&gt;priv_lock
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|read_wait_queue
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|vmlogrdr_get_recording_class_AB
id|vmlogrdr_get_recording_class_AB
c_func
(paren
r_void
)paren
(brace
r_char
id|cp_command
(braket
)braket
op_assign
l_string|&quot;QUERY COMMAND RECORDING &quot;
suffix:semicolon
r_char
id|cp_response
(braket
l_int|80
)braket
suffix:semicolon
r_char
op_star
id|tail
suffix:semicolon
r_int
id|len
comma
id|i
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;vmlogrdr: query command: %s&bslash;n&quot;
comma
id|cp_command
)paren
suffix:semicolon
id|cpcmd
c_func
(paren
id|cp_command
comma
id|cp_response
comma
r_sizeof
(paren
id|cp_response
)paren
)paren
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;vmlogrdr: response: %s&quot;
comma
id|cp_response
)paren
suffix:semicolon
id|len
op_assign
id|strnlen
c_func
(paren
id|cp_response
comma
r_sizeof
(paren
id|cp_response
)paren
)paren
suffix:semicolon
singleline_comment|// now the parsing
id|tail
op_assign
id|strnchr
c_func
(paren
id|cp_response
comma
id|len
comma
l_char|&squot;=&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tail
)paren
r_return
l_int|0
suffix:semicolon
id|tail
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
l_string|&quot;ANY&quot;
comma
id|tail
comma
l_int|3
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
l_string|&quot;NONE&quot;
comma
id|tail
comma
l_int|4
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * expect comma separated list of classes here, if one of them&n;&t; * is A or B return 1 otherwise 0&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|tail
op_minus
id|cp_response
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|cp_response
(braket
id|i
)braket
op_eq
l_char|&squot;A&squot;
op_logical_or
id|cp_response
(braket
id|i
)braket
op_eq
l_char|&squot;B&squot;
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|vmlogrdr_recording
id|vmlogrdr_recording
c_func
(paren
r_struct
id|vmlogrdr_priv_t
op_star
id|logptr
comma
r_int
id|action
comma
r_int
id|purge
)paren
(brace
r_char
id|cp_command
(braket
l_int|80
)braket
suffix:semicolon
r_char
id|cp_response
(braket
l_int|160
)braket
suffix:semicolon
r_char
op_star
id|onoff
comma
op_star
id|qid_string
suffix:semicolon
id|memset
c_func
(paren
id|cp_command
comma
l_int|0x00
comma
r_sizeof
(paren
id|cp_command
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cp_response
comma
l_int|0x00
comma
r_sizeof
(paren
id|cp_response
)paren
)paren
suffix:semicolon
id|onoff
op_assign
(paren
(paren
id|action
op_eq
l_int|1
)paren
ques
c_cond
l_string|&quot;ON&quot;
suffix:colon
l_string|&quot;OFF&quot;
)paren
suffix:semicolon
id|qid_string
op_assign
(paren
(paren
id|recording_class_AB
op_eq
l_int|1
)paren
ques
c_cond
l_string|&quot; QID * &quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The recording commands needs to be called with option QID&n;&t; * for guests that have previlege classes A or B.&n;&t; * Purging has to be done as separate step, because recording&n;&t; * can&squot;t be switched on as long as records are on the queue.&n;&t; * Doing both at the same time doesn&squot;t work.&n;&t; */
r_if
c_cond
(paren
id|purge
)paren
(brace
id|snprintf
c_func
(paren
id|cp_command
comma
r_sizeof
(paren
id|cp_command
)paren
comma
l_string|&quot;RECORDING %s PURGE %s&quot;
comma
id|logptr-&gt;recording_name
comma
id|qid_string
)paren
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;vmlogrdr: recording command: %s&bslash;n&quot;
comma
id|cp_command
)paren
suffix:semicolon
id|cpcmd
c_func
(paren
id|cp_command
comma
id|cp_response
comma
r_sizeof
(paren
id|cp_response
)paren
)paren
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;vmlogrdr: recording response: %s&quot;
comma
id|cp_response
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|cp_command
comma
l_int|0x00
comma
r_sizeof
(paren
id|cp_command
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cp_response
comma
l_int|0x00
comma
r_sizeof
(paren
id|cp_response
)paren
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|cp_command
comma
r_sizeof
(paren
id|cp_command
)paren
comma
l_string|&quot;RECORDING %s %s %s&quot;
comma
id|logptr-&gt;recording_name
comma
id|onoff
comma
id|qid_string
)paren
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;vmlogrdr: recording command: %s&bslash;n&quot;
comma
id|cp_command
)paren
suffix:semicolon
id|cpcmd
c_func
(paren
id|cp_command
comma
id|cp_response
comma
r_sizeof
(paren
id|cp_response
)paren
)paren
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;vmlogrdr: recording response: %s&quot;
comma
id|cp_response
)paren
suffix:semicolon
multiline_comment|/* The recording command will usually answer with &squot;Command complete&squot;&n;&t; * on success, but when the specific service was never connected&n;&t; * before then there might be an additional informational message&n;&t; * &squot;HCPCRC8072I Recording entry not found&squot; before the&n;         * &squot;Command complete&squot;. So I use strstr rather then the strncmp.&n;&t; */
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|cp_response
comma
l_string|&quot;Command complete&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_static
r_int
DECL|function|vmlogrdr_open
id|vmlogrdr_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|dev_num
op_assign
l_int|0
suffix:semicolon
r_struct
id|vmlogrdr_priv_t
op_star
id|logptr
op_assign
l_int|NULL
suffix:semicolon
r_int
id|connect_rc
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|dev_num
op_assign
id|iminor
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev_num
OG
id|MAXMINOR
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|logptr
op_assign
op_amp
id|sys_ser
(braket
id|dev_num
)braket
suffix:semicolon
r_if
c_cond
(paren
id|logptr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/*&n;&t; * only allow for blocking reads to be open&n;&t; */
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
multiline_comment|/* Besure this device hasn&squot;t already been opened */
id|spin_lock_bh
c_func
(paren
op_amp
id|logptr-&gt;priv_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|logptr-&gt;dev_in_use
)paren
(brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|logptr-&gt;priv_lock
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
(brace
id|logptr-&gt;dev_in_use
op_assign
l_int|1
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|logptr-&gt;priv_lock
)paren
suffix:semicolon
)brace
id|atomic_set
c_func
(paren
op_amp
id|logptr-&gt;receive_ready
comma
l_int|0
)paren
suffix:semicolon
id|logptr-&gt;buffer_free
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* set the file options */
id|filp-&gt;private_data
op_assign
id|logptr
suffix:semicolon
id|filp-&gt;f_op
op_assign
op_amp
id|vmlogrdr_fops
suffix:semicolon
multiline_comment|/* start recording for this service*/
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|logptr-&gt;autorecording
)paren
id|ret
op_assign
id|vmlogrdr_recording
c_func
(paren
id|logptr
comma
l_int|1
comma
id|logptr-&gt;autopurge
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;vmlogrdr: failed to start &quot;
l_string|&quot;recording automatically&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Register with iucv driver */
id|logptr-&gt;iucv_handle
op_assign
id|iucv_register_program
c_func
(paren
id|iucvMagic
comma
id|logptr-&gt;system_service
comma
id|mask
comma
op_amp
id|vmlogrdr_iucvops
comma
id|logptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|logptr-&gt;iucv_handle
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;vmlogrdr: failed to register with&quot;
l_string|&quot;iucv driver&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|not_registered
suffix:semicolon
)brace
multiline_comment|/* create connection to the system service */
id|spin_lock_bh
c_func
(paren
op_amp
id|logptr-&gt;priv_lock
)paren
suffix:semicolon
id|logptr-&gt;connection_established
op_assign
l_int|0
suffix:semicolon
id|logptr-&gt;iucv_path_severed
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|logptr-&gt;priv_lock
)paren
suffix:semicolon
id|connect_rc
op_assign
id|iucv_connect
(paren
op_amp
(paren
id|logptr-&gt;pathid
)paren
comma
l_int|10
comma
id|iucvMagic
comma
id|logptr-&gt;system_service
comma
id|iucv_host
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
comma
id|logptr-&gt;iucv_handle
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|connect_rc
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;vmlogrdr: iucv connection to %s &quot;
l_string|&quot;failed with rc %i &bslash;n&quot;
comma
id|logptr-&gt;system_service
comma
id|connect_rc
)paren
suffix:semicolon
r_goto
id|not_connected
suffix:semicolon
)brace
multiline_comment|/* We&squot;ve issued the connect and now we must wait for a&n;&t; * ConnectionComplete or ConnectinSevered Interrupt&n;&t; * before we can continue to process.&n;&t; */
id|wait_event
c_func
(paren
id|conn_wait_queue
comma
(paren
id|logptr-&gt;connection_established
)paren
op_logical_or
(paren
id|logptr-&gt;iucv_path_severed
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|logptr-&gt;iucv_path_severed
)paren
(brace
r_goto
id|not_connected
suffix:semicolon
)brace
r_return
id|nonseekable_open
c_func
(paren
id|inode
comma
id|filp
)paren
suffix:semicolon
id|not_connected
suffix:colon
id|iucv_unregister_program
c_func
(paren
id|logptr-&gt;iucv_handle
)paren
suffix:semicolon
id|logptr-&gt;iucv_handle
op_assign
l_int|NULL
suffix:semicolon
id|not_registered
suffix:colon
r_if
c_cond
(paren
id|logptr-&gt;autorecording
)paren
id|vmlogrdr_recording
c_func
(paren
id|logptr
comma
l_int|0
comma
id|logptr-&gt;autopurge
)paren
suffix:semicolon
id|logptr-&gt;dev_in_use
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_static
r_int
DECL|function|vmlogrdr_release
id|vmlogrdr_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|vmlogrdr_priv_t
op_star
id|logptr
op_assign
id|filp-&gt;private_data
suffix:semicolon
id|iucv_unregister_program
c_func
(paren
id|logptr-&gt;iucv_handle
)paren
suffix:semicolon
id|logptr-&gt;iucv_handle
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|logptr-&gt;autorecording
)paren
(brace
id|ret
op_assign
id|vmlogrdr_recording
c_func
(paren
id|logptr
comma
l_int|0
comma
id|logptr-&gt;autopurge
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;vmlogrdr: failed to stop &quot;
l_string|&quot;recording automatically&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|logptr-&gt;dev_in_use
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|vmlogrdr_receive_data
id|vmlogrdr_receive_data
c_func
(paren
r_struct
id|vmlogrdr_priv_t
op_star
id|priv
)paren
(brace
r_int
id|rc
comma
op_star
id|temp
suffix:semicolon
multiline_comment|/* we need to keep track of two data sizes here:&n;&t; * The number of bytes we need to receive from iucv and&n;&t; * the total number of bytes we actually write into the buffer.&n;&t; */
r_int
id|user_data_count
comma
id|iucv_data_count
suffix:semicolon
r_char
op_star
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|priv-&gt;receive_ready
)paren
)paren
(brace
id|spin_lock_bh
c_func
(paren
op_amp
id|priv-&gt;priv_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;residual_length
)paren
(brace
multiline_comment|/* receive second half of a record */
id|iucv_data_count
op_assign
id|priv-&gt;residual_length
suffix:semicolon
id|user_data_count
op_assign
l_int|0
suffix:semicolon
id|buffer
op_assign
id|priv-&gt;buffer
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* receive a new record:&n;&t;&t;&t; * We need to return the total length of the record&n;                         * + size of FENCE in the first 4 bytes of the buffer.&n;&t;&t;         */
id|iucv_data_count
op_assign
id|priv-&gt;local_interrupt_buffer.ln1msg2.ipbfln1f
suffix:semicolon
id|user_data_count
op_assign
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|temp
op_assign
(paren
r_int
op_star
)paren
id|priv-&gt;buffer
suffix:semicolon
op_star
id|temp
op_assign
id|iucv_data_count
op_plus
r_sizeof
(paren
id|FENCE
)paren
suffix:semicolon
id|buffer
op_assign
id|priv-&gt;buffer
op_plus
r_sizeof
(paren
r_int
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If the record is bigger then our buffer, we receive only&n;&t;&t; * a part of it. We can get the rest later.&n;&t;&t; */
r_if
c_cond
(paren
id|iucv_data_count
OG
id|NET_BUFFER_SIZE
)paren
id|iucv_data_count
op_assign
id|NET_BUFFER_SIZE
suffix:semicolon
id|rc
op_assign
id|iucv_receive
c_func
(paren
id|priv-&gt;pathid
comma
id|priv-&gt;local_interrupt_buffer.ipmsgid
comma
id|priv-&gt;local_interrupt_buffer.iptrgcls
comma
id|buffer
comma
id|iucv_data_count
comma
l_int|NULL
comma
l_int|NULL
comma
op_amp
id|priv-&gt;residual_length
)paren
suffix:semicolon
id|spin_unlock_bh
c_func
(paren
op_amp
id|priv-&gt;priv_lock
)paren
suffix:semicolon
multiline_comment|/* An rc of 5 indicates that the record was bigger then&n;&t;&t; * the buffer, which is OK for us. A 9 indicates that the&n;&t;&t; * record was purged befor we could receive it.&n;&t;&t; */
r_if
c_cond
(paren
id|rc
op_eq
l_int|5
)paren
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|9
)paren
id|atomic_set
c_func
(paren
op_amp
id|priv-&gt;receive_ready
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|rc
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
(brace
id|priv-&gt;buffer_free
op_assign
l_int|0
suffix:semicolon
id|user_data_count
op_add_assign
id|iucv_data_count
suffix:semicolon
id|priv-&gt;current_position
op_assign
id|priv-&gt;buffer
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;residual_length
op_eq
l_int|0
)paren
(brace
multiline_comment|/* the whole record has been captured,&n;&t;&t;&t; * now add the fence */
id|atomic_dec
c_func
(paren
op_amp
id|priv-&gt;receive_ready
)paren
suffix:semicolon
id|buffer
op_assign
id|priv-&gt;buffer
op_plus
id|user_data_count
suffix:semicolon
id|memcpy
c_func
(paren
id|buffer
comma
id|FENCE
comma
r_sizeof
(paren
id|FENCE
)paren
)paren
suffix:semicolon
id|user_data_count
op_add_assign
r_sizeof
(paren
id|FENCE
)paren
suffix:semicolon
)brace
id|priv-&gt;remaining
op_assign
id|user_data_count
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|vmlogrdr_read
id|vmlogrdr_read
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|data
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
id|rc
suffix:semicolon
r_struct
id|vmlogrdr_priv_t
op_star
id|priv
op_assign
id|filp-&gt;private_data
suffix:semicolon
r_while
c_loop
(paren
id|priv-&gt;buffer_free
)paren
(brace
id|rc
op_assign
id|vmlogrdr_receive_data
c_func
(paren
id|priv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|rc
op_assign
id|wait_event_interruptible
c_func
(paren
id|read_wait_queue
comma
id|atomic_read
c_func
(paren
op_amp
id|priv-&gt;receive_ready
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
)brace
)brace
multiline_comment|/* copy only up to end of record */
r_if
c_cond
(paren
id|count
OG
id|priv-&gt;remaining
)paren
id|count
op_assign
id|priv-&gt;remaining
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|data
comma
id|priv-&gt;current_position
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
op_star
id|ppos
op_add_assign
id|count
suffix:semicolon
id|priv-&gt;current_position
op_add_assign
id|count
suffix:semicolon
id|priv-&gt;remaining
op_sub_assign
id|count
suffix:semicolon
multiline_comment|/* if all data has been transferred, set buffer free */
r_if
c_cond
(paren
id|priv-&gt;remaining
op_eq
l_int|0
)paren
id|priv-&gt;buffer_free
op_assign
l_int|1
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|vmlogrdr_autopurge_store
id|vmlogrdr_autopurge_store
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|vmlogrdr_priv_t
op_star
id|priv
op_assign
id|dev-&gt;driver_data
suffix:semicolon
id|ssize_t
id|ret
op_assign
id|count
suffix:semicolon
r_switch
c_cond
(paren
id|buf
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;0&squot;
suffix:colon
id|priv-&gt;autopurge
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;1&squot;
suffix:colon
id|priv-&gt;autopurge
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|vmlogrdr_autopurge_show
id|vmlogrdr_autopurge_show
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|vmlogrdr_priv_t
op_star
id|priv
op_assign
id|dev-&gt;driver_data
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%u&bslash;n&quot;
comma
id|priv-&gt;autopurge
)paren
suffix:semicolon
)brace
r_static
id|DEVICE_ATTR
c_func
(paren
id|autopurge
comma
l_int|0644
comma
id|vmlogrdr_autopurge_show
comma
id|vmlogrdr_autopurge_store
)paren
suffix:semicolon
r_static
id|ssize_t
DECL|function|vmlogrdr_purge_store
id|vmlogrdr_purge_store
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_char
id|cp_command
(braket
l_int|80
)braket
suffix:semicolon
r_char
id|cp_response
(braket
l_int|80
)braket
suffix:semicolon
r_struct
id|vmlogrdr_priv_t
op_star
id|priv
op_assign
id|dev-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|buf
(braket
l_int|0
)braket
op_ne
l_char|&squot;1&squot;
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|memset
c_func
(paren
id|cp_command
comma
l_int|0x00
comma
r_sizeof
(paren
id|cp_command
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cp_response
comma
l_int|0x00
comma
r_sizeof
(paren
id|cp_response
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The recording command needs to be called with option QID&n;&t; * for guests that have previlege classes A or B.&n;&t; * Other guests will not recognize the command and we have to&n;&t; * issue the same command without the QID parameter.&n;&t; */
r_if
c_cond
(paren
id|recording_class_AB
)paren
id|snprintf
c_func
(paren
id|cp_command
comma
r_sizeof
(paren
id|cp_command
)paren
comma
l_string|&quot;RECORDING %s PURGE QID * &quot;
comma
id|priv-&gt;recording_name
)paren
suffix:semicolon
r_else
id|snprintf
c_func
(paren
id|cp_command
comma
r_sizeof
(paren
id|cp_command
)paren
comma
l_string|&quot;RECORDING %s PURGE &quot;
comma
id|priv-&gt;recording_name
)paren
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;vmlogrdr: recording command: %s&bslash;n&quot;
comma
id|cp_command
)paren
suffix:semicolon
id|cpcmd
c_func
(paren
id|cp_command
comma
id|cp_response
comma
r_sizeof
(paren
id|cp_response
)paren
)paren
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;vmlogrdr: recording response: %s&quot;
comma
id|cp_response
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_static
id|DEVICE_ATTR
c_func
(paren
id|purge
comma
l_int|0200
comma
l_int|NULL
comma
id|vmlogrdr_purge_store
)paren
suffix:semicolon
r_static
id|ssize_t
DECL|function|vmlogrdr_autorecording_store
id|vmlogrdr_autorecording_store
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|vmlogrdr_priv_t
op_star
id|priv
op_assign
id|dev-&gt;driver_data
suffix:semicolon
id|ssize_t
id|ret
op_assign
id|count
suffix:semicolon
r_switch
c_cond
(paren
id|buf
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;0&squot;
suffix:colon
id|priv-&gt;autorecording
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;1&squot;
suffix:colon
id|priv-&gt;autorecording
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|vmlogrdr_autorecording_show
id|vmlogrdr_autorecording_show
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|vmlogrdr_priv_t
op_star
id|priv
op_assign
id|dev-&gt;driver_data
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%u&bslash;n&quot;
comma
id|priv-&gt;autorecording
)paren
suffix:semicolon
)brace
r_static
id|DEVICE_ATTR
c_func
(paren
id|autorecording
comma
l_int|0644
comma
id|vmlogrdr_autorecording_show
comma
id|vmlogrdr_autorecording_store
)paren
suffix:semicolon
r_static
id|ssize_t
DECL|function|vmlogrdr_recording_store
id|vmlogrdr_recording_store
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|vmlogrdr_priv_t
op_star
id|priv
op_assign
id|dev-&gt;driver_data
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_switch
c_cond
(paren
id|buf
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;0&squot;
suffix:colon
id|ret
op_assign
id|vmlogrdr_recording
c_func
(paren
id|priv
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;1&squot;
suffix:colon
id|ret
op_assign
id|vmlogrdr_recording
c_func
(paren
id|priv
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
r_else
r_return
id|count
suffix:semicolon
)brace
r_static
id|DEVICE_ATTR
c_func
(paren
id|recording
comma
l_int|0200
comma
l_int|NULL
comma
id|vmlogrdr_recording_store
)paren
suffix:semicolon
r_static
id|ssize_t
DECL|function|vmlogrdr_recording_status_show
id|vmlogrdr_recording_status_show
c_func
(paren
r_struct
id|device_driver
op_star
id|driver
comma
r_char
op_star
id|buf
)paren
(brace
r_char
id|cp_command
(braket
)braket
op_assign
l_string|&quot;QUERY RECORDING &quot;
suffix:semicolon
r_int
id|len
suffix:semicolon
id|cpcmd
c_func
(paren
id|cp_command
comma
id|buf
comma
l_int|4096
)paren
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_static
id|DRIVER_ATTR
c_func
(paren
id|recording_status
comma
l_int|0444
comma
id|vmlogrdr_recording_status_show
comma
l_int|NULL
)paren
suffix:semicolon
DECL|variable|vmlogrdr_attrs
r_static
r_struct
id|attribute
op_star
id|vmlogrdr_attrs
(braket
)braket
op_assign
(brace
op_amp
id|dev_attr_autopurge.attr
comma
op_amp
id|dev_attr_purge.attr
comma
op_amp
id|dev_attr_autorecording.attr
comma
op_amp
id|dev_attr_recording.attr
comma
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|vmlogrdr_attr_group
r_static
r_struct
id|attribute_group
id|vmlogrdr_attr_group
op_assign
(brace
dot
id|attrs
op_assign
id|vmlogrdr_attrs
comma
)brace
suffix:semicolon
DECL|variable|vmlogrdr_class
r_static
r_struct
id|class_simple
op_star
id|vmlogrdr_class
suffix:semicolon
DECL|variable|vmlogrdr_driver
r_static
r_struct
id|device_driver
id|vmlogrdr_driver
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;vmlogrdr&quot;
comma
dot
id|bus
op_assign
op_amp
id|iucv_bus
comma
)brace
suffix:semicolon
r_static
r_int
DECL|function|vmlogrdr_register_driver
id|vmlogrdr_register_driver
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|driver_register
c_func
(paren
op_amp
id|vmlogrdr_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;vmlogrdr: failed to register driver.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|ret
op_assign
id|driver_create_file
c_func
(paren
op_amp
id|vmlogrdr_driver
comma
op_amp
id|driver_attr_recording_status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;vmlogrdr: failed to add driver attribute.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|unregdriver
suffix:semicolon
)brace
id|vmlogrdr_class
op_assign
id|class_simple_create
c_func
(paren
id|THIS_MODULE
comma
l_string|&quot;vmlogrdr&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|vmlogrdr_class
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;vmlogrdr: failed to create class.&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|vmlogrdr_class
)paren
suffix:semicolon
id|vmlogrdr_class
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|unregattr
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|unregattr
suffix:colon
id|driver_remove_file
c_func
(paren
op_amp
id|vmlogrdr_driver
comma
op_amp
id|driver_attr_recording_status
)paren
suffix:semicolon
id|unregdriver
suffix:colon
id|driver_unregister
c_func
(paren
op_amp
id|vmlogrdr_driver
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_void
DECL|function|vmlogrdr_unregister_driver
id|vmlogrdr_unregister_driver
c_func
(paren
r_void
)paren
(brace
id|class_simple_destroy
c_func
(paren
id|vmlogrdr_class
)paren
suffix:semicolon
id|vmlogrdr_class
op_assign
l_int|NULL
suffix:semicolon
id|driver_remove_file
c_func
(paren
op_amp
id|vmlogrdr_driver
comma
op_amp
id|driver_attr_recording_status
)paren
suffix:semicolon
id|driver_unregister
c_func
(paren
op_amp
id|vmlogrdr_driver
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|vmlogrdr_register_device
id|vmlogrdr_register_device
c_func
(paren
r_struct
id|vmlogrdr_priv_t
op_star
id|priv
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
(brace
id|memset
c_func
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|device
)paren
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|dev-&gt;bus_id
comma
id|BUS_ID_SIZE
comma
l_string|&quot;%s&quot;
comma
id|priv-&gt;internal_name
)paren
suffix:semicolon
id|dev-&gt;bus
op_assign
op_amp
id|iucv_bus
suffix:semicolon
id|dev-&gt;parent
op_assign
id|iucv_root
suffix:semicolon
id|dev-&gt;driver
op_assign
op_amp
id|vmlogrdr_driver
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The release function could be called after the&n;&t;&t; * module has been unloaded. It&squot;s _only_ task is to&n;&t;&t; * free the struct. Therefore, we specify kfree()&n;&t;&t; * directly here. (Probably a little bit obfuscating&n;&t;&t; * but legitime ...).&n;&t;&t; */
id|dev-&gt;release
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_struct
id|device
op_star
)paren
)paren
id|kfree
suffix:semicolon
)brace
r_else
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|ret
op_assign
id|device_register
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
id|ret
op_assign
id|sysfs_create_group
c_func
(paren
op_amp
id|dev-&gt;kobj
comma
op_amp
id|vmlogrdr_attr_group
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|device_unregister
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|priv-&gt;class_device
op_assign
id|class_simple_device_add
c_func
(paren
id|vmlogrdr_class
comma
id|MKDEV
c_func
(paren
id|vmlogrdr_major
comma
id|priv-&gt;minor_num
)paren
comma
id|dev
comma
l_string|&quot;%s&quot;
comma
id|dev-&gt;bus_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|priv-&gt;class_device
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|priv-&gt;class_device
)paren
suffix:semicolon
id|priv-&gt;class_device
op_assign
l_int|NULL
suffix:semicolon
id|sysfs_remove_group
c_func
(paren
op_amp
id|dev-&gt;kobj
comma
op_amp
id|vmlogrdr_attr_group
)paren
suffix:semicolon
id|device_unregister
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|dev-&gt;driver_data
op_assign
id|priv
suffix:semicolon
id|priv-&gt;device
op_assign
id|dev
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|vmlogrdr_unregister_device
id|vmlogrdr_unregister_device
c_func
(paren
r_struct
id|vmlogrdr_priv_t
op_star
id|priv
)paren
(brace
id|class_simple_device_remove
c_func
(paren
id|MKDEV
c_func
(paren
id|vmlogrdr_major
comma
id|priv-&gt;minor_num
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;device
op_ne
l_int|NULL
)paren
(brace
id|sysfs_remove_group
c_func
(paren
op_amp
id|priv-&gt;device-&gt;kobj
comma
op_amp
id|vmlogrdr_attr_group
)paren
suffix:semicolon
id|device_unregister
c_func
(paren
id|priv-&gt;device
)paren
suffix:semicolon
id|priv-&gt;device
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|vmlogrdr_register_cdev
id|vmlogrdr_register_cdev
c_func
(paren
id|dev_t
id|dev
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|vmlogrdr_cdev
op_assign
id|cdev_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vmlogrdr_cdev
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|vmlogrdr_cdev-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|vmlogrdr_cdev-&gt;ops
op_assign
op_amp
id|vmlogrdr_fops
suffix:semicolon
id|vmlogrdr_cdev-&gt;dev
op_assign
id|dev
suffix:semicolon
id|rc
op_assign
id|cdev_add
c_func
(paren
id|vmlogrdr_cdev
comma
id|vmlogrdr_cdev-&gt;dev
comma
id|MAXMINOR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
r_return
l_int|0
suffix:semicolon
singleline_comment|// cleanup: cdev is not fully registered, no cdev_del here!
id|kobject_put
c_func
(paren
op_amp
id|vmlogrdr_cdev-&gt;kobj
)paren
suffix:semicolon
id|vmlogrdr_cdev
op_assign
l_int|NULL
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_static
r_void
DECL|function|vmlogrdr_cleanup
id|vmlogrdr_cleanup
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|vmlogrdr_cdev
)paren
(brace
id|cdev_del
c_func
(paren
id|vmlogrdr_cdev
)paren
suffix:semicolon
id|vmlogrdr_cdev
op_assign
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAXMINOR
suffix:semicolon
op_increment
id|i
)paren
(brace
id|vmlogrdr_unregister_device
c_func
(paren
op_amp
id|sys_ser
(braket
id|i
)braket
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|sys_ser
(braket
id|i
)braket
dot
id|buffer
)paren
suffix:semicolon
)brace
id|vmlogrdr_unregister_driver
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vmlogrdr_major
)paren
(brace
id|unregister_chrdev_region
c_func
(paren
id|MKDEV
c_func
(paren
id|vmlogrdr_major
comma
l_int|0
)paren
comma
id|MAXMINOR
)paren
suffix:semicolon
id|vmlogrdr_major
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|vmlogrdr_init
id|vmlogrdr_init
c_func
(paren
r_void
)paren
(brace
r_int
id|rc
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dev_t
id|dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MACHINE_IS_VM
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;vmlogrdr: not running under VM, &quot;
l_string|&quot;driver not loaded.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|recording_class_AB
op_assign
id|vmlogrdr_get_recording_class_AB
c_func
(paren
)paren
suffix:semicolon
id|rc
op_assign
id|alloc_chrdev_region
c_func
(paren
op_amp
id|dev
comma
l_int|0
comma
id|MAXMINOR
comma
l_string|&quot;vmlogrdr&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|vmlogrdr_major
op_assign
id|MAJOR
c_func
(paren
id|dev
)paren
suffix:semicolon
id|rc
op_assign
id|vmlogrdr_register_driver
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|cleanup
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAXMINOR
suffix:semicolon
op_increment
id|i
)paren
(brace
id|sys_ser
(braket
id|i
)braket
dot
id|buffer
op_assign
(paren
r_char
op_star
)paren
id|get_zeroed_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sys_ser
(braket
id|i
)braket
dot
id|buffer
)paren
(brace
id|rc
op_assign
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
id|sys_ser
(braket
id|i
)braket
dot
id|current_position
op_assign
id|sys_ser
(braket
id|i
)braket
dot
id|buffer
suffix:semicolon
id|rc
op_assign
id|vmlogrdr_register_device
c_func
(paren
op_amp
id|sys_ser
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|cleanup
suffix:semicolon
id|rc
op_assign
id|vmlogrdr_register_cdev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|cleanup
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;vmlogrdr: driver loaded&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|cleanup
suffix:colon
id|vmlogrdr_cleanup
c_func
(paren
)paren
suffix:semicolon
id|printk
(paren
id|KERN_ERR
l_string|&quot;vmlogrdr: driver not loaded.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_static
r_void
DECL|function|vmlogrdr_exit
id|vmlogrdr_exit
c_func
(paren
r_void
)paren
(brace
id|vmlogrdr_cleanup
c_func
(paren
)paren
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;vmlogrdr: driver unloaded&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|variable|vmlogrdr_init
id|module_init
c_func
(paren
id|vmlogrdr_init
)paren
suffix:semicolon
DECL|variable|vmlogrdr_exit
id|module_exit
c_func
(paren
id|vmlogrdr_exit
)paren
suffix:semicolon
eof
