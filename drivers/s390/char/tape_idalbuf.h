multiline_comment|/***************************************************************************&n; *&n; *  drivers/s390/char/tape_idalbuf.h&n; *    functions for idal buffer handling&n; *&n; *  S390 and zSeries version&n; *    Copyright (C) 2001 IBM Corporation&n; *    Author(s): Michael Holzheu &lt;holzheu@de.ibm.com&gt;&n; *&n; ****************************************************************************&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;asm/hardirq.h&gt; 
singleline_comment|// in_interrupt
multiline_comment|/*&n; * Macros&n; */
macro_line|#ifdef CONFIG_ARCH_S390X
singleline_comment|// on ESAME each idal entry points to a 4K buffer
DECL|macro|IDALBUF_BLK_SIZE
mdefine_line|#define IDALBUF_BLK_SIZE    4096
macro_line|#else
singleline_comment|// on ESA each idal entry points to a 2K buffer
DECL|macro|IDALBUF_BLK_SIZE
mdefine_line|#define IDALBUF_BLK_SIZE    2048
macro_line|#endif
DECL|macro|IDALBUF_MAX_ENTRIES
mdefine_line|#define IDALBUF_MAX_ENTRIES 33 
singleline_comment|// an ida list can have up to 33 entries
DECL|macro|IDALBUF_PAGE_ORDER
mdefine_line|#define IDALBUF_PAGE_ORDER  1  
singleline_comment|// each chunk has 2exp(1) pages
DECL|macro|__IDALBUF_CHUNK_SIZE
mdefine_line|#define __IDALBUF_CHUNK_SIZE   ((1&lt;&lt;IDALBUF_PAGE_ORDER) * PAGE_SIZE)
DECL|macro|__IDALBUF_ENTRIES_PER_CHUNK
mdefine_line|#define __IDALBUF_ENTRIES_PER_CHUNK (__IDALBUF_CHUNK_SIZE/IDALBUF_BLK_SIZE)
singleline_comment|// Macro which finds out, if we need idal addressing
macro_line|#ifdef CONFIG_ARCH_S390X
DECL|macro|__IDALBUF_DIRECT_ADDR
mdefine_line|#define __IDALBUF_DIRECT_ADDR(idal) &bslash;&n;&t;( (idal-&gt;size &lt;= __IDALBUF_CHUNK_SIZE) &bslash;&n;&t;&amp;&amp; ( ( ((unsigned long)idal-&gt;data[0]) &gt;&gt; 31) == 0) )
macro_line|#else
DECL|macro|__IDALBUF_DIRECT_ADDR
mdefine_line|#define __IDALBUF_DIRECT_ADDR(idal) &bslash;&n;&t;(idal-&gt;size &lt;= __IDALBUF_CHUNK_SIZE)
macro_line|#endif
macro_line|#ifndef MIN
DECL|macro|MIN
mdefine_line|#define MIN(a,b) (((a)&lt;(b))?(a):(b))
macro_line|#endif
multiline_comment|/*&n; * The idalbuf data structure&n; */
DECL|struct|_idalbuf_t
r_typedef
r_struct
id|_idalbuf_t
(brace
DECL|member|data
r_void
op_star
id|data
(braket
id|IDALBUF_MAX_ENTRIES
)braket
suffix:semicolon
DECL|member|size
r_int
id|size
suffix:semicolon
DECL|typedef|idalbuf_t
)brace
id|idalbuf_t
suffix:semicolon
r_static
r_inline
r_int
r_int
DECL|function|__round_up_multiple
id|__round_up_multiple
(paren
r_int
r_int
id|no
comma
r_int
r_int
id|mult
)paren
(brace
r_int
id|rem
op_assign
id|no
op_mod
id|mult
suffix:semicolon
r_return
(paren
id|rem
ques
c_cond
id|no
op_minus
id|rem
op_plus
id|mult
suffix:colon
id|no
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Setup a ccw in a way that the data buf is an idalbuf_mem_t&n; */
r_static
r_inline
r_void
DECL|function|idalbuf_set_normalized_cda
id|idalbuf_set_normalized_cda
c_func
(paren
id|ccw1_t
op_star
id|ccw
comma
id|idalbuf_t
op_star
id|idal
)paren
(brace
r_if
c_cond
(paren
id|__IDALBUF_DIRECT_ADDR
c_func
(paren
id|idal
)paren
)paren
(brace
singleline_comment|// we do not need idals - use direct addressing
id|ccw-&gt;cda
op_assign
(paren
r_int
r_int
)paren
id|idal-&gt;data
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// setup idals
id|ccw-&gt;flags
op_or_assign
id|CCW_FLAG_IDA
suffix:semicolon
id|ccw-&gt;cda
op_assign
(paren
r_int
r_int
)paren
id|idal-&gt;data
suffix:semicolon
)brace
id|ccw-&gt;count
op_assign
id|idal-&gt;size
suffix:semicolon
)brace
multiline_comment|/*&n; * Alloc size bytes of memory&n; */
r_static
r_inline
id|idalbuf_t
op_star
DECL|function|idalbuf_alloc
id|idalbuf_alloc
c_func
(paren
r_int
id|size
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|count
op_assign
id|__round_up_multiple
c_func
(paren
id|size
comma
id|IDALBUF_BLK_SIZE
)paren
op_div
id|IDALBUF_BLK_SIZE
suffix:semicolon
id|idalbuf_t
op_star
id|rc
suffix:semicolon
r_char
op_star
id|addr
op_assign
l_int|NULL
suffix:semicolon
r_int
id|kmalloc_flags
suffix:semicolon
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
(brace
id|kmalloc_flags
op_assign
id|GFP_ATOMIC
suffix:semicolon
)brace
r_else
id|kmalloc_flags
op_assign
id|GFP_KERNEL
suffix:semicolon
r_if
c_cond
(paren
id|size
op_div
id|IDALBUF_BLK_SIZE
OG
id|IDALBUF_MAX_ENTRIES
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
singleline_comment|// the ida list must be below 2GB --&gt; GFP_DMA
id|rc
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|idalbuf_t
)paren
comma
id|kmalloc_flags
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
(brace
r_goto
id|error
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_mod
id|__IDALBUF_ENTRIES_PER_CHUNK
)paren
op_eq
l_int|0
)paren
(brace
singleline_comment|// data does not need to be below 2GB
id|rc-&gt;data
(braket
id|i
)braket
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|kmalloc_flags
comma
id|IDALBUF_PAGE_ORDER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rc-&gt;data
(braket
id|i
)braket
)paren
(brace
r_goto
id|error
suffix:semicolon
)brace
id|addr
op_assign
(paren
r_char
op_star
)paren
(paren
id|rc-&gt;data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|addr
op_add_assign
id|IDALBUF_BLK_SIZE
suffix:semicolon
id|rc-&gt;data
(braket
id|i
)braket
op_assign
id|addr
suffix:semicolon
)brace
)brace
id|rc-&gt;size
op_assign
id|size
suffix:semicolon
r_return
id|rc
suffix:semicolon
id|error
suffix:colon
r_if
c_cond
(paren
id|rc
)paren
(brace
r_int
id|end
op_assign
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|end
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_sub_assign
id|__IDALBUF_ENTRIES_PER_CHUNK
)paren
(brace
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|rc-&gt;data
(braket
id|i
)braket
comma
id|IDALBUF_PAGE_ORDER
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|rc
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Free an idal buffer&n; */
r_static
r_inline
r_void
DECL|function|idalbuf_free
id|idalbuf_free
c_func
(paren
id|idalbuf_t
op_star
id|idal
)paren
(brace
r_int
id|count
op_assign
id|__round_up_multiple
c_func
(paren
id|idal-&gt;size
comma
id|__IDALBUF_CHUNK_SIZE
)paren
op_div
id|__IDALBUF_CHUNK_SIZE
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|idal-&gt;data
(braket
id|i
op_star
id|__IDALBUF_ENTRIES_PER_CHUNK
)braket
comma
id|IDALBUF_PAGE_ORDER
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|idal
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy count bytes from an idal buffer to contiguous user memory&n; */
r_static
r_inline
r_int
DECL|function|idalbuf_copy_to_user
id|idalbuf_copy_to_user
c_func
(paren
r_void
op_star
id|to
comma
r_const
id|idalbuf_t
op_star
id|from
comma
r_int
id|count
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|from-&gt;size
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_add_assign
id|__IDALBUF_CHUNK_SIZE
)paren
(brace
id|rc
op_assign
id|copy_to_user
c_func
(paren
(paren
(paren
r_char
op_star
)paren
id|to
)paren
op_plus
id|i
comma
id|from-&gt;data
(braket
id|i
op_div
id|IDALBUF_BLK_SIZE
)braket
comma
id|MIN
c_func
(paren
id|__IDALBUF_CHUNK_SIZE
comma
(paren
id|count
op_minus
id|i
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy count bytes from contiguous user memory to an idal buffer&n; */
r_static
r_inline
r_int
DECL|function|idalbuf_copy_from_user
id|idalbuf_copy_from_user
c_func
(paren
id|idalbuf_t
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
id|count
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|to-&gt;size
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_add_assign
id|__IDALBUF_CHUNK_SIZE
)paren
(brace
id|rc
op_assign
id|copy_from_user
c_func
(paren
id|to-&gt;data
(braket
id|i
op_div
id|IDALBUF_BLK_SIZE
)braket
comma
(paren
(paren
r_char
op_star
)paren
id|from
)paren
op_plus
id|i
comma
id|MIN
c_func
(paren
id|__IDALBUF_CHUNK_SIZE
comma
(paren
id|count
op_minus
id|i
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy count bytes from an idal buffer to a contiguous kernel buffer&n; */
r_static
r_inline
r_void
DECL|function|idalbuf_copy_from_idal
id|idalbuf_copy_from_idal
c_func
(paren
r_void
op_star
id|to
comma
r_const
id|idalbuf_t
op_star
id|from
comma
r_int
id|count
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|from-&gt;size
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_add_assign
id|__IDALBUF_CHUNK_SIZE
)paren
(brace
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|to
op_plus
id|i
comma
(paren
id|from-&gt;data
(braket
id|i
op_div
id|IDALBUF_BLK_SIZE
)braket
)paren
comma
id|MIN
c_func
(paren
id|__IDALBUF_CHUNK_SIZE
comma
(paren
id|count
op_minus
id|i
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Copy count bytes from a contiguous kernel buffer to an idal buffer&n; */
r_static
r_inline
r_void
DECL|function|idalbuf_copy_to_idal
id|idalbuf_copy_to_idal
c_func
(paren
id|idalbuf_t
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
id|count
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|to-&gt;size
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_add_assign
id|__IDALBUF_CHUNK_SIZE
)paren
(brace
id|memcpy
c_func
(paren
id|to-&gt;data
(braket
id|i
op_div
id|IDALBUF_BLK_SIZE
)braket
comma
(paren
r_char
op_star
)paren
id|from
op_plus
id|i
comma
id|MIN
c_func
(paren
id|__IDALBUF_CHUNK_SIZE
comma
(paren
id|count
op_minus
id|i
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
eof
