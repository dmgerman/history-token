multiline_comment|/***********************************************************************&n; *  drivers/s390/char/tape.c&n; *    tape device driver for S/390 and zSeries tapes.&n; *&n; *  S390 and zSeries version&n; *    Copyright (C) 2001 IBM Corporation&n; *    Author(s): Carsten Otte &lt;cotte@de.ibm.com&gt;&n; *               Michael Holzheu &lt;holzheu@de.ibm.com&gt;&n; *               Tuan Ngo-Anh &lt;ngoanh@de.ibm.com&gt;&n; *&n; ***********************************************************************&n; */
macro_line|#include &quot;tapedefs.h&quot; 
singleline_comment|// kernel 2.2 compatibility defines
macro_line|#include &lt;linux/stddef.h&gt;    
singleline_comment|// defines NULL
macro_line|#include &lt;linux/proc_fs.h&gt;   
singleline_comment|// for /proc/tapedevices
macro_line|#include &lt;linux/init.h&gt;      
singleline_comment|// for kernel parameters
macro_line|#include &lt;linux/kmod.h&gt;      
singleline_comment|// for requesting modules
macro_line|#include &lt;linux/spinlock.h&gt;  
singleline_comment|// for locks
macro_line|#include &lt;asm/types.h&gt;       
singleline_comment|// for variable types
macro_line|#ifdef CONFIG_S390_TAPE_DYNAMIC
macro_line|#include &lt;asm/s390dyn.h&gt;
macro_line|#endif
macro_line|#include &quot;tape.h&quot;
macro_line|#ifdef CONFIG_S390_TAPE_3590
macro_line|#include &quot;tape3590.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_S390_TAPE_3490
macro_line|#include &quot;tape3490.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_S390_TAPE_3480
macro_line|#include &quot;tape3480.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_S390_TAPE_BLOCK
macro_line|#include &quot;tapeblock.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_S390_TAPE_CHAR
macro_line|#include &quot;tapechar.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_PROC_FS
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#endif
DECL|macro|PRINTK_HEADER
mdefine_line|#define PRINTK_HEADER &quot;T390:&quot;
DECL|macro|TAPE_MAX_DEVREGS
mdefine_line|#define TAPE_MAX_DEVREGS        (256 / TAPE_MINORS_PER_DEV)
DECL|macro|TAPE_NO_IO
mdefine_line|#define TAPE_NO_IO          0
DECL|macro|TAPE_DO_IO
mdefine_line|#define TAPE_DO_IO          1
DECL|macro|TAPE_CIO_PRIVATE_DATA
mdefine_line|#define TAPE_CIO_PRIVATE_DATA
macro_line|#ifdef CONFIG_KMOD
DECL|macro|tape_request_module
mdefine_line|#define tape_request_module(a) request_module(a)
macro_line|#else
DECL|macro|tape_request_module
mdefine_line|#define tape_request_module(a)
macro_line|#endif
multiline_comment|/*******************************************************************&n; * Internal Prototypes&n; *******************************************************************/
r_static
r_void
id|tape_do_irq
(paren
r_int
id|irq
comma
r_void
op_star
id|int_parm
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_inline
r_int
id|tape_halt_io
c_func
(paren
id|tape_dev_t
op_star
id|td
)paren
suffix:semicolon
r_static
r_void
id|tape_wait
c_func
(paren
id|tape_ccw_req_t
op_star
id|treq
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_S390_TAPE_DYNAMIC
multiline_comment|/* functions for dyn. dev. attach/detach */
r_static
r_int
id|tape_oper_handler
(paren
r_int
id|irq
comma
r_struct
id|_devreg
op_star
id|dreg
)paren
suffix:semicolon
r_static
r_void
id|tape_noper_handler
(paren
r_int
id|irq
comma
r_int
id|status
)paren
suffix:semicolon
macro_line|#endif
r_static
r_inline
r_void
id|tape_disable_device
c_func
(paren
id|tape_dev_t
op_star
id|td
)paren
suffix:semicolon
r_static
r_inline
r_int
id|tape_enable_device
c_func
(paren
id|tape_dev_t
op_star
id|td
)paren
suffix:semicolon
multiline_comment|/*******************************************************************&n; * GLOBALS&n; *******************************************************************/
DECL|variable|tape_devreg
r_static
id|devreg_t
op_star
id|tape_devreg
(braket
id|TAPE_MAX_DEVREGS
)braket
suffix:semicolon
DECL|variable|tape_devregct
r_static
r_int
id|tape_devregct
op_assign
l_int|0
suffix:semicolon
DECL|variable|tape_autoprobe
r_static
r_int
id|tape_autoprobe
op_assign
l_int|1
suffix:semicolon
DECL|variable|tape_first_disc
r_static
id|tape_discipline_t
op_star
id|tape_first_disc
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|tape_first_dev
id|tape_dev_t
op_star
id|tape_first_dev
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|tape_first_front
id|tape_frontend_t
op_star
id|tape_first_front
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|tape
r_char
op_star
id|tape
(braket
l_int|256
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Lock hirarchy:&n; * tape_discipline_lock &gt; tape_dev_lock &gt; td-&gt;lock&n; */
DECL|variable|tape_dev_lock
id|rwlock_t
id|tape_dev_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|tape_discipline_lock
r_static
id|rwlock_t
id|tape_discipline_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
macro_line|#ifdef TAPE_DEBUG
DECL|variable|tape_dbf_area
id|debug_info_t
op_star
id|tape_dbf_area
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
DECL|variable|tape_med_st_verbose
r_const
r_char
op_star
id|tape_med_st_verbose
(braket
id|MS_SIZE
)braket
op_assign
initialization_block
suffix:semicolon
DECL|variable|tape_state_verbose
r_const
r_char
op_star
id|tape_state_verbose
(braket
id|TS_SIZE
)braket
op_assign
initialization_block
suffix:semicolon
DECL|variable|tape_op_verbose
r_const
r_char
op_star
id|tape_op_verbose
(braket
id|TO_SIZE
)braket
op_assign
(brace
l_string|&quot;BLK&quot;
comma
l_string|&quot;BSB&quot;
comma
l_string|&quot;BSF&quot;
comma
l_string|&quot;DSE&quot;
comma
l_string|&quot;EGA&quot;
comma
l_string|&quot;FSB&quot;
comma
l_string|&quot;FSF&quot;
comma
l_string|&quot;LDI&quot;
comma
l_string|&quot;LBL&quot;
comma
l_string|&quot;MSE&quot;
comma
l_string|&quot;NOP&quot;
comma
l_string|&quot;RBA&quot;
comma
l_string|&quot;RBI&quot;
comma
l_string|&quot;RBU&quot;
comma
l_string|&quot;RBL&quot;
comma
l_string|&quot;RDC&quot;
comma
l_string|&quot;RFO&quot;
comma
l_string|&quot;RSD&quot;
comma
l_string|&quot;REW&quot;
comma
l_string|&quot;RUN&quot;
comma
l_string|&quot;SEN&quot;
comma
l_string|&quot;SID&quot;
comma
l_string|&quot;SNP&quot;
comma
l_string|&quot;SPG&quot;
comma
l_string|&quot;SWI&quot;
comma
l_string|&quot;SMR&quot;
comma
l_string|&quot;SYN&quot;
comma
l_string|&quot;TIO&quot;
comma
l_string|&quot;UNA&quot;
comma
l_string|&quot;WRI&quot;
comma
l_string|&quot;WTM&quot;
comma
l_string|&quot;MSN&quot;
comma
l_string|&quot;LOA&quot;
comma
l_string|&quot;RCF&quot;
comma
multiline_comment|/* 3590 */
l_string|&quot;RAT&quot;
comma
multiline_comment|/* 3590 */
l_string|&quot;NOT&quot;
)brace
suffix:semicolon
multiline_comment|/*******************************************************************&n; * DEVFS Functions&n; *******************************************************************/
macro_line|#ifdef CONFIG_DEVFS_FS
DECL|variable|tape_devfs_root_entry
id|devfs_handle_t
id|tape_devfs_root_entry
suffix:semicolon
multiline_comment|/*&n; * Create devfs root entry (devno in hex) for device td&n; */
r_static
r_inline
id|devfs_handle_t
DECL|function|tape_mkdevfsroot
id|tape_mkdevfsroot
(paren
id|tape_dev_t
op_star
id|td
)paren
(brace
r_char
id|devno
(braket
l_int|5
)braket
suffix:semicolon
id|sprintf
(paren
id|devno
comma
l_string|&quot;%04x&quot;
comma
id|td-&gt;devinfo.devno
)paren
suffix:semicolon
r_return
(paren
id|td-&gt;devfs_dir
op_assign
id|devfs_mk_dir
(paren
id|tape_devfs_root_entry
comma
id|devno
comma
id|td
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove devfs root entry for device td&n; */
r_static
r_inline
r_void
DECL|function|tape_rmdevfsroot
id|tape_rmdevfsroot
(paren
id|tape_dev_t
op_star
id|td
)paren
(brace
r_if
c_cond
(paren
id|td-&gt;devfs_dir
)paren
id|devfs_unregister
(paren
id|td-&gt;devfs_dir
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*******************************************************************&n; * PROCFS Functions&n; *******************************************************************/
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/* functions used in tape_proc_file_ops */
r_static
id|ssize_t
id|tape_proc_devices_read
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|user_buf
comma
r_int
id|user_len
comma
id|loff_t
op_star
id|offset
)paren
suffix:semicolon
r_static
r_int
id|tape_proc_devices_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|tape_proc_devices_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
multiline_comment|/* our proc tapedevices entry */
DECL|variable|tape_proc_devices
r_static
r_struct
id|proc_dir_entry
op_star
id|tape_proc_devices
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|data
r_char
op_star
id|data
suffix:semicolon
DECL|member|len
r_int
id|len
suffix:semicolon
DECL|typedef|tape_procinfo_t
)brace
id|tape_procinfo_t
suffix:semicolon
DECL|variable|tape_proc_devices_file_ops
r_static
r_struct
id|file_operations
id|tape_proc_devices_file_ops
op_assign
(brace
id|read
suffix:colon
id|tape_proc_devices_read
comma
multiline_comment|/* read */
id|open
suffix:colon
id|tape_proc_devices_open
comma
multiline_comment|/* open */
id|release
suffix:colon
id|tape_proc_devices_release
comma
multiline_comment|/* close */
)brace
suffix:semicolon
multiline_comment|/* &n; * Initialize procfs stuff on startup&n; */
r_static
r_inline
r_void
DECL|function|tape_proc_init
id|tape_proc_init
(paren
r_void
)paren
(brace
id|tape_proc_devices
op_assign
id|create_proc_entry
(paren
l_string|&quot;tapedevices&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
comma
op_amp
id|proc_root
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape_proc_devices
op_eq
l_int|NULL
)paren
r_goto
id|error
suffix:semicolon
id|tape_proc_devices-&gt;proc_fops
op_assign
op_amp
id|tape_proc_devices_file_ops
suffix:semicolon
id|tape_proc_devices-&gt;proc_iops
op_assign
op_amp
id|tape_proc_devices_inode_ops
suffix:semicolon
r_return
suffix:semicolon
id|error
suffix:colon
id|PRINT_WARN
(paren
l_string|&quot;tape: Cannot register procfs entry tapedevices&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Open function for /proc/tapedevices&n; */
r_static
r_int
DECL|function|tape_proc_devices_open
id|tape_proc_devices_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|tape_dev_t
op_star
id|td
suffix:semicolon
id|tape_procinfo_t
op_star
id|procinfo
suffix:semicolon
r_char
op_star
id|data
op_assign
l_int|NULL
suffix:semicolon
r_int
id|size
op_assign
l_int|0
comma
id|check_size
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|pos
op_assign
l_int|0
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|lockflags
comma
id|lockflags2
suffix:semicolon
id|tape_ccw_req_t
op_star
id|treq
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|procinfo
op_assign
id|kmalloc
(paren
r_sizeof
(paren
id|tape_procinfo_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|procinfo
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_goto
id|out_no_lock
suffix:semicolon
)brace
multiline_comment|/* Find out mem size for output, ensure that after releasing lock   */
multiline_comment|/* (vmalloc must not be called with interrupts disabled) no devices */
multiline_comment|/* have been added/removed                                          */
r_do
(brace
id|size
op_assign
l_int|100
suffix:semicolon
singleline_comment|// Headline
id|read_lock_irqsave
c_func
(paren
op_amp
id|tape_dev_lock
comma
id|lockflags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|td
op_assign
id|tape_first_dev
suffix:semicolon
id|td
op_ne
l_int|NULL
suffix:semicolon
id|td
op_assign
id|td-&gt;next
)paren
id|size
op_add_assign
l_int|100
suffix:semicolon
singleline_comment|// FIXME: Guess better!
r_if
c_cond
(paren
id|size
op_eq
id|check_size
)paren
(brace
r_break
suffix:semicolon
)brace
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|tape_dev_lock
comma
id|lockflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
)paren
(brace
id|vfree
c_func
(paren
id|data
)paren
suffix:semicolon
)brace
id|data
op_assign
id|vmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
(brace
id|kfree
(paren
id|procinfo
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out_no_lock
suffix:semicolon
)brace
id|check_size
op_assign
id|size
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
singleline_comment|// We have the tape_dev lock now
macro_line|#ifdef CONFIG_S390_TAPE_CHAR
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|data
op_plus
id|pos
comma
l_string|&quot;TapeNo&bslash;tDevNo&bslash;tCuType&bslash;tCuModel&bslash;tDevType&bslash;tDevMod&bslash;tBlkSize&bslash;tState&bslash;tOp&bslash;tMedState&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|data
op_plus
id|pos
comma
l_string|&quot;TapeNo&bslash;tDevNo&bslash;tCuType&bslash;tCuModel&bslash;tDevType&bslash;tDevMod&bslash;tState&bslash;tOp&bslash;tMedState&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|td
op_assign
id|tape_first_dev
suffix:semicolon
id|td
op_ne
l_int|NULL
suffix:semicolon
id|td
op_assign
id|td-&gt;next
)paren
(brace
id|s390irq_spin_lock_irqsave
(paren
id|td-&gt;devinfo.irq
comma
id|lockflags2
)paren
suffix:semicolon
id|treq
op_assign
id|tape_get_active_ccw_req
c_func
(paren
id|td
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|data
op_plus
id|pos
comma
l_string|&quot;%d&bslash;t&quot;
comma
id|td-&gt;first_minor
op_div
id|TAPE_MINORS_PER_DEV
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|data
op_plus
id|pos
comma
l_string|&quot;%04X&bslash;t&quot;
comma
id|td-&gt;devinfo.devno
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|data
op_plus
id|pos
comma
l_string|&quot;%04X&bslash;t&quot;
comma
id|td-&gt;devinfo.sid_data.cu_type
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|data
op_plus
id|pos
comma
l_string|&quot;%02X&bslash;t&quot;
comma
id|td-&gt;devinfo.sid_data.cu_model
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|data
op_plus
id|pos
comma
l_string|&quot;%04X&bslash;t&quot;
comma
id|td-&gt;devinfo.sid_data.dev_type
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|data
op_plus
id|pos
comma
l_string|&quot;%02X&bslash;t&quot;
comma
id|td-&gt;devinfo.sid_data.dev_model
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_S390_TAPE_CHAR
r_if
c_cond
(paren
id|td-&gt;char_data.block_size
op_eq
l_int|0
)paren
(brace
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|data
op_plus
id|pos
comma
l_string|&quot;auto&bslash;t&quot;
)paren
suffix:semicolon
)brace
r_else
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|data
op_plus
id|pos
comma
l_string|&quot;%i&bslash;t&quot;
comma
id|td-&gt;char_data.block_size
)paren
suffix:semicolon
macro_line|#endif
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|data
op_plus
id|pos
comma
l_string|&quot;%s&bslash;t&quot;
comma
(paren
(paren
id|tape_state_get
c_func
(paren
id|td
)paren
op_ge
l_int|0
)paren
op_logical_and
(paren
id|tape_state_get
c_func
(paren
id|td
)paren
OL
id|TS_SIZE
)paren
)paren
ques
c_cond
id|tape_state_verbose
(braket
id|tape_state_get
(paren
id|td
)paren
)braket
suffix:colon
l_string|&quot;UNKNOWN&quot;
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|data
op_plus
id|pos
comma
l_string|&quot;%s&bslash;t&quot;
comma
(paren
id|treq
op_ne
l_int|NULL
)paren
ques
c_cond
id|tape_op_verbose
(braket
id|treq-&gt;op
)braket
suffix:colon
l_string|&quot;---&quot;
)paren
suffix:semicolon
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|data
op_plus
id|pos
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|tape_med_st_verbose
(braket
id|td-&gt;medium_state
)braket
)paren
suffix:semicolon
id|s390irq_spin_unlock_irqrestore
(paren
id|td-&gt;devinfo.irq
comma
id|lockflags2
)paren
suffix:semicolon
)brace
id|procinfo-&gt;data
op_assign
id|data
suffix:semicolon
id|procinfo-&gt;len
op_assign
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|pos
OG
id|size
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// we&squot;ve overwritten some memory
id|file-&gt;private_data
op_assign
(paren
r_void
op_star
)paren
id|procinfo
suffix:semicolon
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|tape_dev_lock
comma
id|lockflags
)paren
suffix:semicolon
id|out_no_lock
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Read function for /proc/tapedevices&n; */
r_static
id|ssize_t
DECL|function|tape_proc_devices_read
id|tape_proc_devices_read
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|user_buf
comma
r_int
id|user_len
comma
id|loff_t
op_star
id|offset
)paren
(brace
id|loff_t
id|len
op_assign
l_int|0
suffix:semicolon
id|tape_procinfo_t
op_star
id|p_info
op_assign
(paren
id|tape_procinfo_t
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
op_star
id|offset
op_ge
id|p_info-&gt;len
)paren
(brace
r_goto
id|out
suffix:semicolon
multiline_comment|/* EOF */
)brace
r_else
(brace
id|len
op_assign
id|user_len
OL
(paren
id|p_info-&gt;len
op_minus
op_star
id|offset
)paren
ques
c_cond
id|user_len
suffix:colon
(paren
id|p_info-&gt;len
op_minus
op_star
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
(paren
id|user_buf
comma
op_amp
(paren
id|p_info-&gt;data
(braket
op_star
id|offset
)braket
)paren
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
(paren
op_star
id|offset
)paren
op_add_assign
id|len
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * Close function for /proc/tapedevices&n; */
r_static
r_int
DECL|function|tape_proc_devices_release
id|tape_proc_devices_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|tape_procinfo_t
op_star
id|p_info
op_assign
(paren
id|tape_procinfo_t
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|vfree
c_func
(paren
id|p_info-&gt;data
)paren
suffix:semicolon
id|kfree
(paren
id|p_info
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Cleanup all stuff registered to the procfs&n; */
r_static
r_inline
r_void
DECL|function|tape_proc_cleanup
id|tape_proc_cleanup
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|tape_proc_devices
op_ne
l_int|NULL
)paren
id|remove_proc_entry
(paren
l_string|&quot;tapedevices&quot;
comma
op_amp
id|proc_root
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PROC_FS */
multiline_comment|/*******************************************************************&n; * Wait/Wakeup Functions&n; *******************************************************************/
DECL|function|tape_wake_up_remove
r_static
r_void
(def_block
id|tape_wake_up_remove
c_func
(paren
id|tape_ccw_req_t
op_star
id|treq
)paren
(brace
id|tape_remove_ccw_req
c_func
(paren
id|treq-&gt;tape_dev
comma
id|treq
)paren
suffix:semicolon
id|tape_free_ccw_req
c_func
(paren
id|treq
)paren
suffix:semicolon
)brace
)def_block
DECL|function|tape_wake_up
r_static
r_void
(def_block
id|tape_wake_up
c_func
(paren
id|tape_ccw_req_t
op_star
id|treq
)paren
(brace
id|treq-&gt;wakeup
op_assign
l_int|NULL
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|treq-&gt;wq
)paren
suffix:semicolon
)brace
)def_block
DECL|function|tape_wake_up_interruptible
r_static
r_void
(def_block
id|tape_wake_up_interruptible
c_func
(paren
id|tape_ccw_req_t
op_star
id|treq
)paren
(brace
id|treq-&gt;wakeup
op_assign
l_int|NULL
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|treq-&gt;wq
)paren
suffix:semicolon
)brace
)def_block
macro_line|#ifdef CONFIG_S390_TAPE_BLOCK
DECL|function|tape_schedule_tapeblock
r_static
r_void
(def_block
id|tape_schedule_tapeblock
c_func
(paren
id|tape_ccw_req_t
op_star
id|treq
)paren
(brace
id|treq-&gt;wakeup
op_assign
l_int|NULL
suffix:semicolon
id|tapeblock_schedule_exec_io
c_func
(paren
(paren
id|tape_dev_t
op_star
)paren
(paren
id|treq-&gt;tape_dev
)paren
)paren
suffix:semicolon
suffix:semicolon
)brace
)def_block
macro_line|#endif
DECL|function|tape_wait_event
r_static
r_void
(def_block
id|tape_wait_event
c_func
(paren
id|tape_ccw_req_t
op_star
id|treq
)paren
(brace
id|wait_event
(paren
id|treq-&gt;wq
comma
(paren
id|treq-&gt;wakeup
op_eq
l_int|NULL
)paren
)paren
suffix:semicolon
)brace
)def_block
DECL|function|tape_wait_event_interruptible
r_static
r_void
(def_block
id|tape_wait_event_interruptible
c_func
(paren
id|tape_ccw_req_t
op_star
id|treq
)paren
(brace
id|wait_event_interruptible
c_func
(paren
id|treq-&gt;wq
comma
(paren
id|treq-&gt;wakeup
op_eq
l_int|NULL
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
(paren
id|current
)paren
)paren
(brace
id|treq-&gt;rc
op_assign
id|tape_halt_io
c_func
(paren
id|treq-&gt;tape_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|treq-&gt;rc
op_eq
op_minus
id|ERESTARTSYS
)paren
(brace
id|PRINT_INFO
c_func
(paren
l_string|&quot;IO stopped on irq %d&bslash;n&quot;
comma
id|treq-&gt;tape_dev-&gt;devinfo.irq
)paren
suffix:semicolon
)brace
multiline_comment|/* FIXME: only put into dbf */
r_else
r_if
c_cond
(paren
id|treq-&gt;rc
op_eq
l_int|0
)paren
(brace
id|PRINT_INFO
c_func
(paren
l_string|&quot;could not stop IO,irq was faster on irq %d&bslash;n&quot;
comma
id|treq-&gt;tape_dev-&gt;devinfo.irq
)paren
suffix:semicolon
)brace
multiline_comment|/* FIXME: only put into dbf */
r_else
id|PRINT_WARN
c_func
(paren
l_string|&quot;IO error while stopping IO on irq %d&bslash;n&quot;
comma
id|treq-&gt;tape_dev-&gt;devinfo.irq
)paren
suffix:semicolon
)brace
)brace
)def_block
DECL|function|tape_wait_event_interruptible_nohaltio
r_static
r_void
(def_block
id|tape_wait_event_interruptible_nohaltio
c_func
(paren
id|tape_ccw_req_t
op_star
id|treq
)paren
(brace
id|wait_event_interruptible
c_func
(paren
id|treq-&gt;wq
comma
(paren
id|treq-&gt;wakeup
op_eq
l_int|NULL
)paren
)paren
suffix:semicolon
)brace
)def_block
multiline_comment|/*******************************************************************&n; * DYNAMIC ATTACH/DETACH Functions&n; *******************************************************************/
r_static
r_inline
r_void
DECL|function|tape_init_devregs
id|tape_init_devregs
c_func
(paren
r_void
)paren
(brace
r_int
id|lockflags
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|tape_dev_lock
comma
id|lockflags
)paren
suffix:semicolon
id|memset
c_func
(paren
id|tape_devreg
comma
l_int|0
comma
r_sizeof
(paren
id|devreg_t
op_star
)paren
op_star
id|TAPE_MAX_DEVREGS
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|tape_dev_lock
comma
id|lockflags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Alloc a devreg for a devno&n; */
r_static
r_inline
id|devreg_t
op_star
DECL|function|tape_create_devno_devreg
id|tape_create_devno_devreg
(paren
r_int
id|devno
)paren
(brace
id|devreg_t
op_star
id|devreg
op_assign
id|kmalloc
(paren
r_sizeof
(paren
id|devreg_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devreg
op_ne
l_int|NULL
)paren
(brace
id|memset
(paren
id|devreg
comma
l_int|0
comma
r_sizeof
(paren
id|devreg_t
)paren
)paren
suffix:semicolon
id|devreg-&gt;ci.devno
op_assign
id|devno
suffix:semicolon
id|devreg-&gt;flag
op_assign
id|DEVREG_TYPE_DEVNO
suffix:semicolon
id|devreg-&gt;oper_func
op_assign
id|tape_oper_handler
suffix:semicolon
)brace
r_return
id|devreg
suffix:semicolon
)brace
multiline_comment|/*&n; * Alloc a devreg for a cu-type &n; */
r_static
r_inline
id|devreg_t
op_star
DECL|function|tape_create_cu_devreg
id|tape_create_cu_devreg
(paren
r_int
id|cu_type
)paren
(brace
id|devreg_t
op_star
id|devreg
op_assign
id|kmalloc
(paren
r_sizeof
(paren
id|devreg_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devreg
op_ne
l_int|NULL
)paren
(brace
id|memset
(paren
id|devreg
comma
l_int|0
comma
r_sizeof
(paren
id|devreg_t
)paren
)paren
suffix:semicolon
id|devreg-&gt;ci.hc.ctype
op_assign
id|cu_type
suffix:semicolon
id|devreg-&gt;flag
op_assign
id|DEVREG_MATCH_CU_TYPE
op_or
id|DEVREG_TYPE_DEVCHARS
suffix:semicolon
id|devreg-&gt;oper_func
op_assign
id|tape_oper_handler
suffix:semicolon
)brace
r_return
id|devreg
suffix:semicolon
)brace
multiline_comment|/*&n; * Create devregs for device numbers from &quot;from&quot; to &quot;to&quot;&n; */
r_static
r_inline
r_void
DECL|function|tape_create_devregs_range
id|tape_create_devregs_range
c_func
(paren
r_int
id|from
comma
r_int
id|to
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|lockflags
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|tape_dev_lock
comma
id|lockflags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|from
suffix:semicolon
id|i
op_le
id|to
suffix:semicolon
id|i
op_increment
)paren
(brace
singleline_comment|// register for attch/detach of a devno
r_if
c_cond
(paren
id|tape_devregct
op_ge
id|TAPE_MAX_DEVREGS
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot;Could not create devregs for devno range %04x - %04x.&bslash;n&quot;
comma
id|i
comma
id|to
)paren
suffix:semicolon
id|PRINT_WARN
(paren
l_string|&quot;These devices cannot be used. Use autoprobe&bslash;n&quot;
)paren
suffix:semicolon
id|PRINT_WARN
(paren
l_string|&quot;or specify device ranges more precisely!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tape_devreg
(braket
id|tape_devregct
)braket
op_assign
id|tape_create_devno_devreg
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape_devreg
(braket
id|tape_devregct
)braket
op_ne
l_int|NULL
)paren
(brace
id|s390_device_register
(paren
id|tape_devreg
(braket
id|tape_devregct
op_increment
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINT_WARN
(paren
l_string|&quot;Could not create devreg for devno %04x, dyn. attach for this devno deactivated.&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|tape_dev_lock
comma
id|lockflags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a devreg for a discipline&n; */
r_static
r_inline
r_void
DECL|function|tape_create_devreg_for_disc
id|tape_create_devreg_for_disc
c_func
(paren
id|tape_discipline_t
op_star
id|disc
)paren
(brace
r_int
id|devreg_nr
suffix:semicolon
r_int
id|lockflags
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|tape_dev_lock
comma
id|lockflags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|devreg_nr
op_assign
l_int|0
suffix:semicolon
id|devreg_nr
OL
id|TAPE_MAX_DEVREGS
suffix:semicolon
id|devreg_nr
op_increment
)paren
(brace
r_if
c_cond
(paren
id|tape_devreg
(braket
id|devreg_nr
)braket
op_eq
l_int|NULL
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|devreg_nr
op_eq
id|TAPE_MAX_DEVREGS
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot;Could not create devreg for discipline (%x), dyn. attach for this discipline deactivated.&bslash;n&quot;
comma
id|disc-&gt;cu_type
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|tape_devreg
(braket
id|devreg_nr
)braket
op_assign
id|tape_create_cu_devreg
c_func
(paren
id|disc-&gt;cu_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape_devreg
(braket
id|devreg_nr
)braket
op_ne
l_int|NULL
)paren
(brace
id|s390_device_register
c_func
(paren
id|tape_devreg
(braket
id|devreg_nr
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINT_WARN
c_func
(paren
l_string|&quot;Could not alloc devreg: Out of memory&bslash;n&quot;
)paren
suffix:semicolon
id|PRINT_WARN
c_func
(paren
l_string|&quot;Dynamic attach/detach will not work!&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|out_unlock
suffix:colon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|tape_dev_lock
comma
id|lockflags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Free all devregs&n; */
r_static
r_inline
r_void
DECL|function|tape_delete_all_devregs
id|tape_delete_all_devregs
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|lockflags
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|tape_dev_lock
comma
id|lockflags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TAPE_MAX_DEVREGS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|tape_devreg
(braket
id|i
)braket
)paren
(brace
id|s390_device_unregister
c_func
(paren
id|tape_devreg
(braket
id|i
)braket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|tape_devreg
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
id|memset
c_func
(paren
id|tape_devreg
comma
l_int|0
comma
r_sizeof
(paren
id|devreg_t
op_star
)paren
op_star
id|TAPE_MAX_DEVREGS
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|tape_dev_lock
comma
id|lockflags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Free Devregs for a discipline&n; */
r_static
r_inline
r_void
DECL|function|tape_delete_devreg_for_disc
id|tape_delete_devreg_for_disc
c_func
(paren
id|tape_discipline_t
op_star
id|disc
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|lockflags
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|tape_dev_lock
comma
id|lockflags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TAPE_MAX_DEVREGS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|tape_devreg
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
id|tape_devreg
(braket
id|i
)braket
op_member_access_from_pointer
id|ci.hc.ctype
op_eq
id|disc-&gt;cu_type
)paren
(brace
id|s390_device_unregister
c_func
(paren
id|tape_devreg
(braket
id|i
)braket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|tape_devreg
(braket
id|i
)braket
)paren
suffix:semicolon
id|tape_devreg
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|tape_dev_lock
comma
id|lockflags
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************&n; * Module/Kernel Parameter Handling&n; *******************************************************************/
macro_line|#ifndef MODULE
DECL|variable|__initdata
r_static
r_char
id|tape_parm_string
(braket
l_int|1024
)braket
id|__initdata
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Get Kernel parameters (str) seperated by &quot;,&quot;&n; * and store them into the tape[] array&n; */
r_static
r_void
DECL|function|tape_split_parm_string
id|tape_split_parm_string
(paren
r_char
op_star
id|str
)paren
(brace
r_char
op_star
id|tmp
op_assign
id|str
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
l_int|NULL
op_logical_and
op_star
id|tmp
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
r_char
op_star
id|end
suffix:semicolon
r_int
id|len
suffix:semicolon
id|end
op_assign
id|strchr
(paren
id|tmp
comma
l_char|&squot;,&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
op_eq
l_int|NULL
)paren
(brace
id|len
op_assign
id|strlen
(paren
id|tmp
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|len
op_assign
(paren
r_int
)paren
id|end
op_minus
(paren
r_int
)paren
id|tmp
op_plus
l_int|1
suffix:semicolon
op_star
id|end
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|end
op_increment
suffix:semicolon
)brace
id|tape
(braket
id|count
)braket
op_assign
id|kmalloc
(paren
id|len
op_star
r_sizeof
(paren
r_char
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape
(braket
id|count
)braket
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot;can&squot;t store tape= parameter no %d&bslash;n&quot;
comma
id|count
op_plus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memcpy
(paren
id|tape
(braket
id|count
)braket
comma
id|tmp
comma
id|len
op_star
r_sizeof
(paren
r_char
)paren
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
id|tmp
op_assign
id|end
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called for each &quot;tape=&quot; Kernel parameter&n; * at Kernel initialization. We need tape_parm_setup because of&n; * 2.2 compatibility (At least I assume this :-))&n; */
r_void
id|__init
DECL|function|tape_parm_setup
id|tape_parm_setup
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_int
id|len
op_assign
id|strlen
(paren
id|tape_parm_string
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
l_int|0
)paren
(brace
id|strcat
(paren
id|tape_parm_string
comma
l_string|&quot;,&quot;
)paren
suffix:semicolon
)brace
id|strcat
(paren
id|tape_parm_string
comma
id|str
)paren
suffix:semicolon
)brace
r_int
id|__init
DECL|function|tape_parm_call_setup
id|tape_parm_call_setup
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|dummy
suffix:semicolon
id|tape_parm_setup
(paren
id|str
comma
op_amp
id|dummy
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;tape=&quot;
comma
id|tape_parm_call_setup
)paren
suffix:semicolon
macro_line|#endif   /* not defined MODULE */
multiline_comment|/*&n; * Convert string to int&n; */
r_static
r_inline
r_int
DECL|function|tape_parm_strtoul
id|tape_parm_strtoul
(paren
r_char
op_star
id|str
comma
r_char
op_star
op_star
id|stra
)paren
(brace
r_char
op_star
id|temp
op_assign
id|str
suffix:semicolon
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
op_star
id|temp
op_eq
l_char|&squot;0&squot;
)paren
(brace
id|temp
op_increment
suffix:semicolon
multiline_comment|/* strip leading zero */
r_if
c_cond
(paren
op_star
id|temp
op_eq
l_char|&squot;x&squot;
)paren
id|temp
op_increment
suffix:semicolon
multiline_comment|/* strip leading x */
)brace
id|val
op_assign
id|simple_strtoul
(paren
id|temp
comma
op_amp
id|temp
comma
l_int|16
)paren
suffix:semicolon
multiline_comment|/* interpret anything as hex */
op_star
id|stra
op_assign
id|temp
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
multiline_comment|/*&n; * Parse Kernel/Module Parameters and create devregs for dynamic attach/detach&n; */
r_static
r_inline
r_void
DECL|function|tape_parm_parse
id|tape_parm_parse
(paren
r_char
op_star
op_star
id|str
)paren
(brace
r_char
op_star
id|temp
suffix:semicolon
r_int
id|from
comma
id|to
suffix:semicolon
r_if
c_cond
(paren
op_star
id|str
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* no params present -&gt; leave */
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
op_star
id|str
)paren
(brace
id|temp
op_assign
op_star
id|str
suffix:semicolon
id|from
op_assign
l_int|0
suffix:semicolon
id|to
op_assign
l_int|0
suffix:semicolon
id|from
op_assign
id|tape_parm_strtoul
(paren
id|temp
comma
op_amp
id|temp
)paren
suffix:semicolon
id|to
op_assign
id|from
suffix:semicolon
r_if
c_cond
(paren
op_star
id|temp
op_eq
l_char|&squot;-&squot;
)paren
(brace
id|temp
op_increment
suffix:semicolon
id|to
op_assign
id|tape_parm_strtoul
(paren
id|temp
comma
op_amp
id|temp
)paren
suffix:semicolon
)brace
id|tape_create_devregs_range
c_func
(paren
id|from
comma
id|to
)paren
suffix:semicolon
id|str
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*******************************************************************&n; * Tape device (td) functions for create, free, enq, deq, enable,&n; * disable, get and put&n; *******************************************************************/
multiline_comment|/*&n; * Enable Device&n; */
r_static
r_inline
r_int
DECL|function|tape_enable_device
id|tape_enable_device
c_func
(paren
id|tape_dev_t
op_star
id|td
)paren
(brace
macro_line|#ifdef CONFIG_DEVFS_FS
id|tape_frontend_t
op_star
id|frontend
suffix:semicolon
macro_line|#endif
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|td-&gt;discipline
op_member_access_from_pointer
id|setup_device
c_func
(paren
id|td
)paren
op_ne
l_int|0
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Register IRQ */
macro_line|#ifdef TAPE_CIO_PRIVATE_DATA
macro_line|#ifdef CONFIG_S390_TAPE_DYNAMIC
id|rc
op_assign
id|s390_request_irq_special
(paren
id|td-&gt;devinfo.irq
comma
id|tape_do_irq
comma
id|tape_noper_handler
comma
l_int|0
comma
id|TAPE_MAGIC
comma
op_amp
(paren
id|td-&gt;devstat
)paren
)paren
suffix:semicolon
macro_line|#else
id|rc
op_assign
id|s390_request_irq
(paren
id|td-&gt;devinfo.irq
comma
id|tape_do_irq
comma
l_int|0
comma
id|TAPE_MAGIC
comma
op_amp
(paren
id|td-&gt;devstat
)paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#else
macro_line|#ifdef CONFIG_S390_TAPE_DYNAMIC
id|rc
op_assign
id|s390_request_irq_special
(paren
id|td-&gt;devinfo.irq
comma
id|tape_do_irq
comma
id|tape_noper_handler
comma
l_int|0
comma
(paren
r_char
op_star
)paren
id|td
comma
op_amp
(paren
id|td-&gt;devstat
)paren
)paren
suffix:semicolon
macro_line|#else
id|rc
op_assign
id|s390_request_irq
(paren
id|td-&gt;devinfo.irq
comma
id|tape_do_irq
comma
l_int|0
comma
(paren
r_char
op_star
)paren
id|td
comma
op_amp
(paren
id|td-&gt;devstat
)paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif /* TAPE_CIO_PRIVATE_DATA */
r_if
c_cond
(paren
id|rc
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot;Cannot register irq %d, rc=%d&bslash;n&quot;
comma
id|td-&gt;devinfo.irq
comma
id|rc
)paren
suffix:semicolon
id|td-&gt;discipline
op_member_access_from_pointer
id|cleanup_device
c_func
(paren
id|td
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Create devfs entries */
macro_line|#ifdef CONFIG_DEVFS_FS
r_if
c_cond
(paren
id|tape_mkdevfsroot
c_func
(paren
id|td
)paren
op_eq
l_int|NULL
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot;Cannot create a devfs directory for device %04x&bslash;n&quot;
comma
id|td-&gt;devinfo.devno
)paren
suffix:semicolon
r_goto
id|out_undo
suffix:semicolon
)brace
r_for
c_loop
(paren
id|frontend
op_assign
id|tape_first_front
suffix:semicolon
id|frontend
op_ne
l_int|NULL
suffix:semicolon
id|frontend
op_assign
id|frontend-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|frontend
op_member_access_from_pointer
id|mkdevfstree
c_func
(paren
id|td
)paren
op_eq
l_int|NULL
)paren
(brace
r_goto
id|out_undo
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#ifdef TAPE_CIO_PRIVATE_DATA
id|s390_set_private_data
c_func
(paren
id|td-&gt;devinfo.irq
comma
id|td
)paren
suffix:semicolon
macro_line|#endif
id|out
suffix:colon
r_return
id|rc
suffix:semicolon
id|out_undo
suffix:colon
id|tape_disable_device
c_func
(paren
id|td
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * Disable Device&n; */
r_static
r_inline
r_void
DECL|function|tape_disable_device
id|tape_disable_device
c_func
(paren
id|tape_dev_t
op_star
id|td
)paren
(brace
macro_line|#ifdef CONFIG_DEVFS_FS
id|tape_frontend_t
op_star
id|frontend
suffix:semicolon
macro_line|#endif
id|td-&gt;discipline
op_member_access_from_pointer
id|cleanup_device
c_func
(paren
id|td
)paren
suffix:semicolon
macro_line|#ifdef TAPE_CIO_PRIVATE_DATA 
id|s390_set_private_data
c_func
(paren
id|td-&gt;devinfo.irq
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#else
id|ioinfo
(braket
id|td-&gt;devinfo.irq
)braket
op_member_access_from_pointer
id|irq_desc.name
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
id|free_irq
(paren
id|td-&gt;devinfo.irq
comma
op_amp
(paren
id|td-&gt;devstat
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_FS
r_for
c_loop
(paren
id|frontend
op_assign
id|tape_first_front
suffix:semicolon
id|frontend
op_ne
l_int|NULL
suffix:semicolon
id|frontend
op_assign
id|frontend-&gt;next
)paren
id|frontend
op_member_access_from_pointer
id|rmdevfstree
c_func
(paren
id|td
)paren
suffix:semicolon
id|tape_rmdevfsroot
c_func
(paren
id|td
)paren
suffix:semicolon
macro_line|#endif
id|tape_state_set
c_func
(paren
id|td
comma
id|TS_NOT_OPER
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Append Tape device (td) to our tape info list&n; * Must be called with hold tape_dev_lock&n; */
r_static
r_inline
r_void
DECL|function|tape_enq_device
id|tape_enq_device
c_func
(paren
id|tape_dev_t
op_star
id|td
)paren
(brace
id|tape_dev_t
op_star
id|temptd
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|tape_first_dev
op_eq
l_int|NULL
)paren
(brace
id|tape_first_dev
op_assign
id|td
suffix:semicolon
)brace
r_else
(brace
id|temptd
op_assign
id|tape_first_dev
suffix:semicolon
r_while
c_loop
(paren
id|temptd-&gt;next
op_ne
l_int|NULL
)paren
id|temptd
op_assign
id|temptd-&gt;next
suffix:semicolon
id|temptd-&gt;next
op_assign
id|td
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Remove Tape device (td) from our tape info list&n; * Must be called with hold tape_dev_lock&n; */
r_static
r_inline
r_void
DECL|function|tape_deq_device
id|tape_deq_device
c_func
(paren
id|tape_dev_t
op_star
id|td
)paren
(brace
id|tape_dev_t
op_star
id|lasttd
suffix:semicolon
r_if
c_cond
(paren
id|td
op_eq
id|tape_first_dev
)paren
(brace
id|tape_first_dev
op_assign
id|td-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|lasttd
op_assign
id|tape_first_dev
suffix:semicolon
r_while
c_loop
(paren
id|lasttd-&gt;next
op_ne
id|td
)paren
id|lasttd
op_assign
id|lasttd-&gt;next
suffix:semicolon
id|lasttd-&gt;next
op_assign
id|td-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Get Free minor number&n; * Must be called with held tape_dev_lock&n; */
r_static
r_inline
r_int
DECL|function|tape_get_new_minor
id|tape_get_new_minor
c_func
(paren
r_int
id|devno
)paren
(brace
r_int
id|i
comma
id|tape_num
op_assign
op_minus
l_int|1
suffix:semicolon
id|tape_dev_t
op_star
id|newtape
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tape_autoprobe
)paren
(brace
multiline_comment|/* we have static device ranges, so fingure out the */
multiline_comment|/* tape_num of the attached tape                    */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|tape_devregct
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|tape_devreg
(braket
id|i
)braket
op_member_access_from_pointer
id|ci.devno
op_eq
id|devno
)paren
(brace
id|tape_num
op_assign
id|TAPE_MINORS_PER_DEV
op_star
id|i
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* we are running in autoprobe mode, find a free */
multiline_comment|/* tape_num */
id|i
op_assign
l_int|0
suffix:semicolon
id|newtape
op_assign
id|tape_first_dev
suffix:semicolon
r_while
c_loop
(paren
id|newtape
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|newtape-&gt;first_minor
op_eq
id|i
)paren
(brace
multiline_comment|/* tape num in use. try next one */
id|i
op_add_assign
id|TAPE_MINORS_PER_DEV
suffix:semicolon
id|newtape
op_assign
id|tape_first_dev
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* tape num not used by newtape. look at next */
multiline_comment|/* tape info */
id|newtape
op_assign
id|newtape-&gt;next
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
OG
l_int|255
)paren
(brace
multiline_comment|/* No more minor available */
id|tape_num
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
id|tape_num
op_assign
id|i
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|tape_num
suffix:semicolon
)brace
multiline_comment|/*&n; * Create device: Alloc, enable and enq device&n; */
r_static
r_inline
id|tape_dev_t
op_star
DECL|function|tape_create_device
id|tape_create_device
c_func
(paren
r_int
id|irq
comma
r_int
id|devno
comma
id|tape_discipline_t
op_star
id|disc
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|tape_num
suffix:semicolon
id|tape_dev_t
op_star
id|td
suffix:semicolon
r_int
id|lockflags
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|tape_dev_lock
comma
id|lockflags
)paren
suffix:semicolon
id|td
op_assign
id|kmalloc
(paren
r_sizeof
(paren
id|tape_dev_t
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|td
op_eq
l_int|NULL
)paren
(brace
id|tape_sprintf_exception
(paren
id|tape_dbf_area
comma
l_int|2
comma
l_string|&quot;ti:no mem &bslash;n&quot;
)paren
suffix:semicolon
id|PRINT_INFO
(paren
l_string|&quot;tape: can&squot;t allocate memory for &quot;
l_string|&quot;tape info structure&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|memset
c_func
(paren
id|td
comma
l_int|0
comma
r_sizeof
(paren
id|tape_dev_t
)paren
)paren
suffix:semicolon
id|tape_num
op_assign
id|tape_get_new_minor
c_func
(paren
id|devno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape_num
op_eq
op_minus
l_int|1
)paren
(brace
id|PRINT_WARN
c_func
(paren
l_string|&quot;tape: could not get minor for tape %x&bslash;n&quot;
comma
id|devno
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|rc
op_assign
id|get_dev_info_by_irq
(paren
id|irq
comma
op_amp
(paren
id|td-&gt;devinfo
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
id|ENODEV
)paren
(brace
multiline_comment|/* end of device list */
r_goto
id|error
suffix:semicolon
)brace
id|td-&gt;discipline
op_assign
id|disc
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|td-&gt;use_count
)paren
comma
l_int|1
)paren
suffix:semicolon
id|td-&gt;first_minor
op_assign
id|tape_num
suffix:semicolon
id|td-&gt;medium_state
op_assign
id|MS_UNKNOWN
suffix:semicolon
id|td-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|td-&gt;discdata
op_assign
id|td-&gt;treq
op_assign
l_int|NULL
suffix:semicolon
id|tape_state_set
(paren
id|td
comma
id|TS_INIT
)paren
suffix:semicolon
id|td-&gt;discdata
op_assign
l_int|NULL
suffix:semicolon
id|td-&gt;last_op
op_assign
id|TO_NOTHING
suffix:semicolon
r_if
c_cond
(paren
id|td-&gt;discipline
op_member_access_from_pointer
id|setup_device
c_func
(paren
id|td
)paren
op_ne
l_int|0
)paren
(brace
r_goto
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tape_enable_device
c_func
(paren
id|td
)paren
op_ne
l_int|0
)paren
(brace
r_goto
id|error
suffix:semicolon
)brace
id|tape_enq_device
c_func
(paren
id|td
)paren
suffix:semicolon
id|PRINT_INFO
(paren
l_string|&quot;using devno %04x with discipline %04x on irq %d as tape device %d&bslash;n&quot;
comma
id|devno
comma
id|disc-&gt;cu_type
comma
id|irq
comma
id|tape_num
op_div
l_int|2
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|tape_dev_lock
comma
id|lockflags
)paren
suffix:semicolon
r_return
id|td
suffix:semicolon
id|error
suffix:colon
id|tape_sprintf_event
(paren
id|tape_dbf_area
comma
l_int|3
comma
l_string|&quot;tsetup err: %x&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|td
)paren
(brace
id|kfree
(paren
id|td
)paren
suffix:semicolon
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|tape_dev_lock
comma
id|lockflags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Free Device storage&n; */
r_static
r_void
DECL|function|tape_free_device
id|tape_free_device
c_func
(paren
id|tape_dev_t
op_star
id|td
)paren
(brace
r_if
c_cond
(paren
id|TAPE_BUSY
c_func
(paren
id|td
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* one should _not_ free the device when a request is pending */
id|tape_sprintf_event
(paren
id|tape_dbf_area
comma
l_int|6
comma
l_string|&quot;free irq: %x&bslash;n&quot;
comma
id|td-&gt;devinfo.irq
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|td
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Decrement use count of tape structure&n; * if use count == 0 tape structure is freed&n; */
r_inline
r_void
DECL|function|tape_put_device
id|tape_put_device
c_func
(paren
id|tape_dev_t
op_star
id|td
)paren
(brace
r_if
c_cond
(paren
id|td
op_eq
l_int|NULL
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
(paren
id|td-&gt;use_count
)paren
)paren
)paren
(brace
id|tape_free_device
c_func
(paren
id|td
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Find the tape_dev_t structure associated with member&n; * and increase use count:&n; *&n; * member:    TAPE_MEMB_IRQ, TAPE_MEMB_MINOR&n; */
id|tape_dev_t
op_star
DECL|function|__tape_get_device_by_member
id|__tape_get_device_by_member
c_func
(paren
r_int
r_int
id|value
comma
r_int
id|member
)paren
(brace
id|tape_dev_t
op_star
id|td
op_assign
l_int|NULL
suffix:semicolon
r_int
id|lockflags
suffix:semicolon
id|read_lock_irqsave
c_func
(paren
op_amp
id|tape_dev_lock
comma
id|lockflags
)paren
suffix:semicolon
id|td
op_assign
id|tape_first_dev
suffix:semicolon
r_while
c_loop
(paren
id|td
op_ne
l_int|NULL
)paren
(brace
r_switch
c_cond
(paren
id|member
)paren
(brace
r_case
id|TAPE_MEMB_IRQ
suffix:colon
r_if
c_cond
(paren
id|td-&gt;devinfo.irq
op_eq
id|value
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TAPE_MEMB_MINOR
suffix:colon
r_if
c_cond
(paren
(paren
id|value
op_ge
id|td-&gt;first_minor
)paren
op_logical_and
(paren
id|value
OL
(paren
id|td-&gt;first_minor
op_plus
id|TAPE_MINORS_PER_DEV
)paren
)paren
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TAPE_MEMB_QUEUE
suffix:colon
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
(paren
op_amp
id|td-&gt;blk_data.request_queue
)paren
)paren
op_eq
id|value
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|td
op_assign
id|td-&gt;next
suffix:semicolon
)brace
id|out
suffix:colon
r_if
c_cond
(paren
id|td
)paren
(brace
singleline_comment|// found!
id|atomic_inc
c_func
(paren
op_amp
(paren
id|td-&gt;use_count
)paren
)paren
suffix:semicolon
)brace
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|tape_dev_lock
comma
id|lockflags
)paren
suffix:semicolon
r_return
id|td
suffix:semicolon
)brace
multiline_comment|/*&n; * Scan all irqs an create tape devices for all matching cu types&n; */
r_static
r_inline
r_void
DECL|function|tape_create_devs_for_disc
id|tape_create_devs_for_disc
c_func
(paren
id|tape_discipline_t
op_star
id|disc
)paren
(brace
r_int
id|irq
comma
id|i
suffix:semicolon
id|tape_dev_t
op_star
id|td
op_assign
l_int|NULL
suffix:semicolon
id|s390_dev_info_t
id|dinfo
suffix:semicolon
r_for
c_loop
(paren
id|irq
op_assign
id|get_irq_first
c_func
(paren
)paren
suffix:semicolon
id|irq
op_ne
op_minus
id|ENODEV
suffix:semicolon
id|irq
op_assign
id|get_irq_next
c_func
(paren
id|irq
)paren
)paren
(brace
r_if
c_cond
(paren
id|get_dev_info_by_irq
(paren
id|irq
comma
op_amp
id|dinfo
)paren
op_eq
op_minus
id|ENODEV
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|disc-&gt;cu_type
op_ne
id|dinfo.sid_data.cu_type
)paren
(brace
multiline_comment|/* Wrong type - try next one */
r_continue
suffix:semicolon
)brace
id|tape_sprintf_event
(paren
id|tape_dbf_area
comma
l_int|3
comma
l_string|&quot;det irq:  %x&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
id|tape_sprintf_event
(paren
id|tape_dbf_area
comma
l_int|3
comma
l_string|&quot;cu     :  %x&bslash;n&quot;
comma
id|disc-&gt;cu_type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tape_autoprobe
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|tape_devregct
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|tape_devreg
(braket
id|i
)braket
op_member_access_from_pointer
id|ci.devno
op_eq
id|dinfo.devno
)paren
(brace
id|td
op_assign
id|tape_create_device
c_func
(paren
id|irq
comma
id|dinfo.devno
comma
id|disc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|td
)paren
(brace
id|PRINT_WARN
c_func
(paren
l_string|&quot;Could not initialize tape 0x%x&bslash;n&quot;
comma
id|dinfo.devno
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|disc-&gt;init_device
)paren
(brace
id|disc
op_member_access_from_pointer
id|init_device
c_func
(paren
id|td
)paren
suffix:semicolon
)brace
multiline_comment|/* XXX */
id|tape_state_set
(paren
id|td
comma
id|TS_UNUSED
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|td
op_assign
id|tape_create_device
c_func
(paren
id|irq
comma
id|dinfo.devno
comma
id|disc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|td
)paren
(brace
id|PRINT_WARN
c_func
(paren
l_string|&quot;Could not initialize tape 0x%x&bslash;n&quot;
comma
id|dinfo.devno
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|disc-&gt;init_device
)paren
(brace
id|disc
op_member_access_from_pointer
id|init_device
c_func
(paren
id|td
)paren
suffix:semicolon
)brace
multiline_comment|/* XXX */
id|tape_state_set
(paren
id|td
comma
id|TS_UNUSED
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Go through our tape info list and disable, deq and free all devices with &n; * matching cu type&n; */
r_static
r_inline
r_void
DECL|function|tape_delete_devs_for_disc
id|tape_delete_devs_for_disc
c_func
(paren
id|tape_discipline_t
op_star
id|disc
)paren
(brace
id|tape_dev_t
op_star
id|td
suffix:semicolon
r_int
id|lockflags
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|tape_dev_lock
comma
id|lockflags
)paren
suffix:semicolon
id|td
op_assign
id|tape_first_dev
suffix:semicolon
r_while
c_loop
(paren
id|td
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|td-&gt;discipline
op_eq
id|disc
)paren
(brace
id|tape_deq_device
c_func
(paren
id|td
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|tape_dev_lock
comma
id|lockflags
)paren
suffix:semicolon
id|tape_disable_device
c_func
(paren
id|td
)paren
suffix:semicolon
id|tape_put_device
c_func
(paren
id|td
)paren
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|tape_dev_lock
comma
id|lockflags
)paren
suffix:semicolon
id|td
op_assign
id|tape_first_dev
suffix:semicolon
)brace
r_else
(brace
id|td
op_assign
id|td-&gt;next
suffix:semicolon
)brace
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|tape_dev_lock
comma
id|lockflags
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************&n; * TAPE Request and IO Functions&n; *******************************************************************/
multiline_comment|/*&n; * Allocate a new tape ccw request&n; */
r_inline
id|tape_ccw_req_t
op_star
DECL|function|tape_alloc_ccw_req
id|tape_alloc_ccw_req
(paren
r_int
id|cplength
comma
r_int
id|datasize
comma
r_int
id|idal_buf_size
comma
id|tape_op_t
id|operation
)paren
(brace
id|tape_ccw_req_t
op_star
id|treq
suffix:semicolon
r_int
id|kmalloc_flags
suffix:semicolon
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
(brace
id|kmalloc_flags
op_assign
id|GFP_ATOMIC
suffix:semicolon
)brace
r_else
id|kmalloc_flags
op_assign
id|GFP_KERNEL
suffix:semicolon
id|treq
op_assign
(paren
id|tape_ccw_req_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|tape_ccw_req_t
)paren
comma
id|kmalloc_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|treq
)paren
(brace
r_goto
id|error
suffix:semicolon
)brace
id|memset
c_func
(paren
id|treq
comma
l_int|0
comma
r_sizeof
(paren
id|tape_ccw_req_t
)paren
)paren
suffix:semicolon
id|treq-&gt;kernbuf_size
op_assign
id|datasize
suffix:semicolon
id|treq-&gt;userbuf_size
op_assign
id|datasize
suffix:semicolon
id|treq-&gt;op
op_assign
id|operation
suffix:semicolon
id|treq-&gt;cplength
op_assign
id|cplength
suffix:semicolon
id|init_waitqueue_head
(paren
op_amp
id|treq-&gt;wq
)paren
suffix:semicolon
singleline_comment|// alloc small kernel buffer
r_if
c_cond
(paren
id|datasize
OG
id|PAGE_SIZE
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|datasize
OG
l_int|0
)paren
(brace
singleline_comment|// the kernbuf must be below 2GB --&gt; GFP_DMA
id|treq-&gt;kernbuf
op_assign
id|kmalloc
c_func
(paren
id|datasize
comma
id|kmalloc_flags
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|treq-&gt;kernbuf
)paren
(brace
r_goto
id|error
suffix:semicolon
)brace
id|memset
c_func
(paren
id|treq-&gt;kernbuf
comma
l_int|0
comma
id|datasize
)paren
suffix:semicolon
)brace
singleline_comment|// alloc idal kernel buffer
r_if
c_cond
(paren
id|idal_buf_size
OG
l_int|0
)paren
(brace
id|treq-&gt;idal_buf
op_assign
id|idalbuf_alloc
c_func
(paren
id|idal_buf_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|treq-&gt;idal_buf
)paren
(brace
r_goto
id|error
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cplength
OL
l_int|0
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
singleline_comment|// the channel program must be below 2GB --&gt; GFP_DMA
id|treq-&gt;cpaddr
op_assign
id|kmalloc
c_func
(paren
id|cplength
op_star
r_sizeof
(paren
id|ccw1_t
)paren
comma
id|kmalloc_flags
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|treq-&gt;cpaddr
)paren
(brace
r_goto
id|error
suffix:semicolon
)brace
id|memset
c_func
(paren
id|treq-&gt;cpaddr
comma
l_int|0
comma
id|cplength
op_star
r_sizeof
(paren
id|ccw1_t
)paren
)paren
suffix:semicolon
r_return
id|treq
suffix:semicolon
id|error
suffix:colon
id|tape_sprintf_exception
(paren
id|tape_dbf_area
comma
l_int|1
comma
l_string|&quot;cqra nomem&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|treq
)paren
(brace
id|tape_free_ccw_req
c_func
(paren
id|treq
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Free tape ccw request&n; */
r_void
DECL|function|tape_free_ccw_req
id|tape_free_ccw_req
(paren
id|tape_ccw_req_t
op_star
id|treq
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|treq
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|treq-&gt;cpaddr
)paren
(brace
id|kfree
c_func
(paren
id|treq-&gt;cpaddr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|treq-&gt;kernbuf
)paren
(brace
id|kfree
c_func
(paren
id|treq-&gt;kernbuf
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|treq-&gt;idal_buf
)paren
(brace
id|idalbuf_free
c_func
(paren
id|treq-&gt;idal_buf
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|treq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add request to request queue (At the moment queue length = 1)&n; */
r_static
r_inline
r_int
DECL|function|tape_add_ccw_req
id|tape_add_ccw_req
c_func
(paren
id|tape_dev_t
op_star
id|td
comma
id|tape_ccw_req_t
op_star
id|treq
)paren
(brace
r_if
c_cond
(paren
id|td-&gt;treq
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|td-&gt;treq
op_assign
id|treq
suffix:semicolon
id|treq-&gt;tape_dev
op_assign
id|td
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove request from request queue (At the moment queue length = 1)&n; */
r_int
DECL|function|tape_remove_ccw_req
id|tape_remove_ccw_req
c_func
(paren
id|tape_dev_t
op_star
id|td
comma
id|tape_ccw_req_t
op_star
id|treq
)paren
(brace
r_if
c_cond
(paren
id|treq
op_ne
id|td-&gt;treq
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|td-&gt;last_op
op_assign
id|treq-&gt;op
suffix:semicolon
id|td-&gt;treq
op_assign
l_int|NULL
suffix:semicolon
id|treq-&gt;tape_dev
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the active ccw request&n; */
id|tape_ccw_req_t
op_star
DECL|function|tape_get_active_ccw_req
id|tape_get_active_ccw_req
c_func
(paren
id|tape_dev_t
op_star
id|td
)paren
(brace
r_return
id|td-&gt;treq
suffix:semicolon
)brace
multiline_comment|/*&n; * Stop the active ccw request&n; */
r_static
r_inline
r_int
DECL|function|tape_halt_io
id|tape_halt_io
c_func
(paren
id|tape_dev_t
op_star
id|td
)paren
(brace
r_int
id|retries
op_assign
l_int|0
suffix:semicolon
r_int
id|irq
op_assign
id|td-&gt;devinfo.irq
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|lockflags
suffix:semicolon
id|tape_ccw_req_t
op_star
id|treq
suffix:semicolon
id|s390irq_spin_lock_irqsave
(paren
id|td-&gt;devinfo.irq
comma
id|lockflags
)paren
suffix:semicolon
id|treq
op_assign
id|tape_get_active_ccw_req
c_func
(paren
id|td
)paren
suffix:semicolon
multiline_comment|/* check if interrupt has already been processed */
r_if
c_cond
(paren
op_logical_neg
id|treq
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|treq-&gt;wakeup
op_eq
l_int|NULL
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
r_while
c_loop
(paren
id|retries
OL
l_int|5
)paren
(brace
r_if
c_cond
(paren
id|retries
OL
l_int|2
)paren
id|rc
op_assign
id|halt_IO
c_func
(paren
id|irq
comma
(paren
r_int
)paren
id|treq
comma
id|treq-&gt;options
)paren
suffix:semicolon
r_else
id|rc
op_assign
id|clear_IO
c_func
(paren
id|irq
comma
(paren
r_int
)paren
id|treq
comma
id|treq-&gt;options
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|rc
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* termination successful */
id|rc
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_case
op_minus
id|ENODEV
suffix:colon
id|PRINT_INFO
(paren
l_string|&quot;device gone, retry&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* FIXME: s390dbf only */
r_break
suffix:semicolon
r_case
op_minus
id|EIO
suffix:colon
id|PRINT_INFO
(paren
l_string|&quot;I/O error, retry&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* FIXME: s390dbf only */
r_break
suffix:semicolon
r_case
op_minus
id|EBUSY
suffix:colon
id|PRINT_INFO
(paren
l_string|&quot;device busy, retry later&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* FIXME: s390dbf only */
r_break
suffix:semicolon
r_default
suffix:colon
id|PRINT_ERR
(paren
l_string|&quot;line %d unknown RC=%d, please report&quot;
l_string|&quot; to linux390@de.ibm.com&bslash;n&quot;
comma
id|__LINE__
comma
id|rc
)paren
suffix:semicolon
id|BUG
(paren
)paren
suffix:semicolon
)brace
id|retries
op_increment
suffix:semicolon
)brace
id|out
suffix:colon
id|s390irq_spin_unlock_irqrestore
c_func
(paren
id|td-&gt;devinfo.irq
comma
id|lockflags
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * The tape IO function:&n; * tape_do_io MUST be called with locked td lock!&n; */
r_static
r_inline
r_int
DECL|function|__tape_do_io
id|__tape_do_io
c_func
(paren
id|tape_dev_t
op_star
id|td
comma
id|tape_ccw_req_t
op_star
id|treq
comma
id|tape_wait_t
id|type
comma
r_int
id|io
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|td
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|treq
op_eq
l_int|NULL
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape_state_get
c_func
(paren
id|td
)paren
op_eq
id|TS_NOT_OPER
)paren
(brace
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TAPE_BUSY
c_func
(paren
id|td
)paren
)paren
(brace
id|tape_sprintf_event
(paren
id|tape_dbf_area
comma
l_int|1
comma
l_string|&quot;tape: IRQ - Tape busy&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|tape_add_ccw_req
c_func
(paren
id|td
comma
id|treq
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|TAPE_REMOVE_REQ_ON_WAKEUP
suffix:colon
id|treq-&gt;wakeup
op_assign
id|tape_wake_up_remove
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TAPE_NO_WAIT
suffix:colon
singleline_comment|// needed for retry
r_break
suffix:semicolon
r_case
id|TAPE_WAIT
suffix:colon
id|treq-&gt;wakeup
op_assign
id|tape_wake_up
suffix:semicolon
id|treq-&gt;wait
op_assign
id|tape_wait_event
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TAPE_WAIT_INTERRUPTIBLE
suffix:colon
id|treq-&gt;wakeup
op_assign
id|tape_wake_up_interruptible
suffix:semicolon
id|treq-&gt;wait
op_assign
id|tape_wait_event_interruptible
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TAPE_WAIT_INTERRUPTIBLE_NOHALTIO
suffix:colon
singleline_comment|// neded for dummy load 
id|treq-&gt;wakeup
op_assign
id|tape_wake_up_interruptible
suffix:semicolon
id|treq-&gt;wait
op_assign
id|tape_wait_event_interruptible_nohaltio
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_S390_TAPE_BLOCK
r_case
id|TAPE_SCHED_BLOCK
suffix:colon
id|treq-&gt;wakeup
op_assign
id|tape_schedule_tapeblock
suffix:semicolon
id|treq-&gt;wait
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|io
)paren
(brace
id|rc
op_assign
id|do_IO
c_func
(paren
id|td-&gt;devinfo.irq
comma
id|treq-&gt;cpaddr
comma
(paren
r_int
r_int
)paren
id|treq
comma
l_int|0x00
comma
id|treq-&gt;options
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
)paren
(brace
id|tape_sprintf_event
(paren
id|tape_dbf_area
comma
l_int|1
comma
l_string|&quot;tape: DOIO failed with er = %i&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
id|treq-&gt;wakeup
op_assign
l_int|NULL
suffix:semicolon
id|treq-&gt;wait
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*XXX ??*/
id|tape_remove_ccw_req
c_func
(paren
id|td
comma
id|treq
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Do the io request and wait for it&n; */
r_int
DECL|function|tape_do_io_and_wait
id|tape_do_io_and_wait
c_func
(paren
id|tape_dev_t
op_star
id|td
comma
id|tape_ccw_req_t
op_star
id|treq
comma
id|tape_wait_t
id|type
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|lockflags
suffix:semicolon
r_if
c_cond
(paren
id|td
op_eq
l_int|NULL
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|s390irq_spin_lock_irqsave
(paren
id|td-&gt;devinfo.irq
comma
id|lockflags
)paren
suffix:semicolon
id|rc
op_assign
id|__tape_do_io
c_func
(paren
id|td
comma
id|treq
comma
id|type
comma
id|TAPE_DO_IO
)paren
suffix:semicolon
id|s390irq_spin_unlock_irqrestore
(paren
id|td-&gt;devinfo.irq
comma
id|lockflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|tape_wait
c_func
(paren
id|treq
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Needed for MTLOAD: Just create a wait request without doing io&n; */
r_int
DECL|function|tape_do_wait_req
id|tape_do_wait_req
c_func
(paren
id|tape_dev_t
op_star
id|td
comma
id|tape_ccw_req_t
op_star
id|treq
comma
id|tape_wait_t
id|type
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|lockflags
suffix:semicolon
r_if
c_cond
(paren
id|td
op_eq
l_int|NULL
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|s390irq_spin_lock_irqsave
(paren
id|td-&gt;devinfo.irq
comma
id|lockflags
)paren
suffix:semicolon
id|rc
op_assign
id|__tape_do_io
c_func
(paren
id|td
comma
id|treq
comma
id|type
comma
id|TAPE_NO_IO
)paren
suffix:semicolon
id|s390irq_spin_unlock_irqrestore
(paren
id|td-&gt;devinfo.irq
comma
id|lockflags
)paren
suffix:semicolon
id|tape_wait
c_func
(paren
id|treq
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Just do the io&n; */
r_int
DECL|function|tape_do_io
id|tape_do_io
c_func
(paren
id|tape_dev_t
op_star
id|td
comma
id|tape_ccw_req_t
op_star
id|treq
comma
id|tape_wait_t
id|type
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|lockflags
suffix:semicolon
id|s390irq_spin_lock_irqsave
(paren
id|td-&gt;devinfo.irq
comma
id|lockflags
)paren
suffix:semicolon
id|rc
op_assign
id|__tape_do_io
c_func
(paren
id|td
comma
id|treq
comma
id|type
comma
id|TAPE_DO_IO
)paren
suffix:semicolon
id|s390irq_spin_unlock_irqrestore
(paren
id|td-&gt;devinfo.irq
comma
id|lockflags
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Just do the io, but we are already locked here (in irq)&n; */
r_int
DECL|function|tape_do_io_irq
id|tape_do_io_irq
c_func
(paren
id|tape_dev_t
op_star
id|td
comma
id|tape_ccw_req_t
op_star
id|treq
comma
id|tape_wait_t
id|type
)paren
(brace
r_return
id|__tape_do_io
c_func
(paren
id|td
comma
id|treq
comma
id|type
comma
id|TAPE_DO_IO
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for an io request&n; */
r_static
r_void
DECL|function|tape_wait
id|tape_wait
c_func
(paren
id|tape_ccw_req_t
op_star
id|treq
)paren
(brace
id|tape_dev_t
op_star
id|td
suffix:semicolon
r_if
c_cond
(paren
id|treq
op_eq
l_int|NULL
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|td
op_assign
id|treq-&gt;tape_dev
suffix:semicolon
r_if
c_cond
(paren
id|td
op_eq
l_int|NULL
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|treq-&gt;wait
op_eq
l_int|NULL
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|treq
op_member_access_from_pointer
id|wait
c_func
(paren
id|treq
)paren
suffix:semicolon
id|tape_remove_ccw_req
c_func
(paren
id|td
comma
id|treq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Tape interrupt routine, called from Ingo&squot;s I/O layer&n; */
r_static
r_void
DECL|function|tape_do_irq
id|tape_do_irq
(paren
r_int
id|irq
comma
r_void
op_star
id|int_parm
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|tape_dev_t
op_star
id|td
suffix:semicolon
macro_line|#ifdef TAPE_CIO_PRIVATE_DATA
id|td
op_assign
(paren
id|tape_dev_t
op_star
)paren
id|s390_get_private_data
c_func
(paren
id|irq
)paren
suffix:semicolon
macro_line|#else
id|td
op_assign
(paren
id|tape_dev_t
op_star
)paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.name
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|td
)paren
(brace
id|PRINT_ERR
(paren
l_string|&quot;tape: could not get device structure for irq %d in interrupt&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|td-&gt;devstat.dstat
op_ne
l_int|0x0c
)paren
(brace
id|tape_sprintf_event
(paren
id|tape_dbf_area
comma
l_int|3
comma
l_string|&quot;-- Tape Interrupthandler --&bslash;n&quot;
)paren
suffix:semicolon
id|tape_dump_sense_dbf
c_func
(paren
id|td
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tape_state_get
c_func
(paren
id|td
)paren
op_eq
id|TS_NOT_OPER
)paren
(brace
id|tape_sprintf_event
(paren
id|tape_dbf_area
comma
l_int|6
comma
l_string|&quot;tape:device is not operational&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|td-&gt;discipline
op_member_access_from_pointer
id|irq
c_func
(paren
id|td
)paren
suffix:semicolon
id|out
suffix:colon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Oper Handler is called from Ingo&squot;s I/O layer when a new tape device is &n; * attached. We create a new devinfo for the new device, enable and enq it.&n; */
r_static
r_int
DECL|function|tape_oper_handler
id|tape_oper_handler
(paren
r_int
id|irq
comma
r_struct
id|_devreg
op_star
id|dreg
)paren
(brace
id|tape_dev_t
op_star
id|td
op_assign
id|tape_first_dev
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|s390_dev_info_t
id|dinfo
suffix:semicolon
id|tape_discipline_t
op_star
id|disc
suffix:semicolon
r_int
id|lockflags
suffix:semicolon
id|td
op_assign
id|tape_get_device_by_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|td
op_ne
l_int|NULL
)paren
(brace
singleline_comment|// irq is (still) used by tape. tell ingo to try again later
id|PRINT_ERR
(paren
l_string|&quot;tape:Oper handler for irq %d called, but irq is still (internally) used.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|rc
op_assign
id|get_dev_info_by_irq
(paren
id|irq
comma
op_amp
id|dinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
id|ENODEV
)paren
(brace
id|PRINT_ERR
(paren
l_string|&quot;tape: Cannot get dev info for irq %d in the oper handler.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|read_lock_irqsave
c_func
(paren
op_amp
id|tape_discipline_lock
comma
id|lockflags
)paren
suffix:semicolon
id|disc
op_assign
id|tape_first_disc
suffix:semicolon
r_while
c_loop
(paren
(paren
id|disc
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|disc-&gt;cu_type
op_ne
id|dinfo.sid_data.cu_type
)paren
)paren
id|disc
op_assign
(paren
id|tape_discipline_t
op_star
)paren
(paren
id|disc-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|disc
op_eq
l_int|NULL
)paren
(brace
id|PRINT_WARN
(paren
l_string|&quot;tape: No matching discipline for cu_type %x found in the oper handler, ignoring device %04x.&bslash;n&quot;
comma
id|dinfo.sid_data.cu_type
comma
id|dinfo.devno
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* Allocate tape structure  */
id|td
op_assign
id|tape_create_device
c_func
(paren
id|irq
comma
id|dinfo.devno
comma
id|disc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|td
op_eq
l_int|NULL
)paren
(brace
id|PRINT_WARN
c_func
(paren
l_string|&quot;Could not initialize tape 0x%x&bslash;n&quot;
comma
id|dinfo.devno
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|disc-&gt;init_device
)paren
(brace
id|disc
op_member_access_from_pointer
id|init_device
c_func
(paren
id|td
)paren
suffix:semicolon
)brace
)brace
id|tape_state_set
(paren
id|td
comma
id|TS_UNUSED
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|tape_discipline_lock
comma
id|lockflags
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Not Oper Handler is called from Ingo&squot;s IO layer, when a tape device&n; * is detached. We deq, disable and free the tape info for this device&n; */
r_static
r_void
DECL|function|tape_noper_handler
id|tape_noper_handler
(paren
r_int
id|irq
comma
r_int
id|status
)paren
(brace
id|tape_dev_t
op_star
id|td
suffix:semicolon
r_int
id|lockflags
suffix:semicolon
id|tape_ccw_req_t
op_star
id|treq
suffix:semicolon
id|td
op_assign
id|tape_get_device_by_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|td
op_eq
l_int|NULL
)paren
(brace
id|PRINT_ERR
c_func
(paren
l_string|&quot;tape: not operational handler called for irq %x, but tape does not hold this irq.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|write_lock_irqsave
c_func
(paren
op_amp
id|tape_dev_lock
comma
id|lockflags
)paren
suffix:semicolon
id|tape_deq_device
c_func
(paren
id|td
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|tape_dev_lock
comma
id|lockflags
)paren
suffix:semicolon
id|tape_disable_device
c_func
(paren
id|td
)paren
suffix:semicolon
id|s390irq_spin_lock_irqsave
(paren
id|td-&gt;devinfo.irq
comma
id|lockflags
)paren
suffix:semicolon
id|treq
op_assign
id|tape_get_active_ccw_req
c_func
(paren
id|td
)paren
suffix:semicolon
r_if
c_cond
(paren
id|treq
)paren
(brace
singleline_comment|// device is in use!
id|treq-&gt;rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|treq-&gt;wakeup
)paren
(brace
id|treq-&gt;wakeup
(paren
id|treq
)paren
suffix:semicolon
)brace
id|PRINT_WARN
(paren
l_string|&quot;Tape #%d is detached while it was busy.&bslash;n&quot;
comma
id|td-&gt;first_minor
op_div
id|TAPE_MINORS_PER_DEV
)paren
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// device is unused!
id|PRINT_WARN
(paren
l_string|&quot;Tape #%d is detached now.&bslash;n&quot;
comma
id|td-&gt;first_minor
op_div
id|TAPE_MINORS_PER_DEV
)paren
suffix:semicolon
)brace
id|s390irq_spin_unlock_irqrestore
(paren
id|td-&gt;devinfo.irq
comma
id|lockflags
)paren
suffix:semicolon
multiline_comment|/* decrement use count twice ! */
id|tape_put_device
c_func
(paren
id|td
)paren
suffix:semicolon
id|tape_put_device
c_func
(paren
id|td
)paren
suffix:semicolon
id|error
suffix:colon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Write sense data to dbf&n; */
DECL|function|tape_dump_sense_dbf
r_void
id|tape_dump_sense_dbf
c_func
(paren
id|tape_dev_t
op_star
id|td
)paren
(brace
id|devstat_t
op_star
id|stat
op_assign
op_amp
id|td-&gt;devstat
suffix:semicolon
r_const
r_char
op_star
id|op
suffix:semicolon
r_if
c_cond
(paren
id|TAPE_BUSY
c_func
(paren
id|td
)paren
)paren
(brace
id|op
op_assign
id|tape_op_verbose
(braket
id|tape_get_active_ccw_req
c_func
(paren
id|td
)paren
op_member_access_from_pointer
id|op
)braket
suffix:semicolon
)brace
r_else
id|op
op_assign
l_string|&quot;---&quot;
suffix:semicolon
id|tape_sprintf_event
(paren
id|tape_dbf_area
comma
l_int|3
comma
l_string|&quot;DSTAT : %02x   CSTAT: %02x&bslash;n&quot;
comma
id|stat-&gt;dstat
comma
id|stat-&gt;cstat
)paren
suffix:semicolon
id|tape_sprintf_event
(paren
id|tape_dbf_area
comma
l_int|3
comma
l_string|&quot;DEVICE: %04x OP   : %s&bslash;n&quot;
comma
id|td-&gt;devinfo.devno
comma
id|op
)paren
suffix:semicolon
id|tape_sprintf_event
(paren
id|tape_dbf_area
comma
l_int|3
comma
l_string|&quot;%08x %08x&bslash;n&quot;
comma
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|stat-&gt;ii.sense.data
(braket
l_int|0
)braket
)paren
comma
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|stat-&gt;ii.sense.data
(braket
l_int|4
)braket
)paren
)paren
suffix:semicolon
id|tape_sprintf_event
(paren
id|tape_dbf_area
comma
l_int|3
comma
l_string|&quot;%08x %08x&bslash;n&quot;
comma
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|stat-&gt;ii.sense.data
(braket
l_int|8
)braket
)paren
comma
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|stat-&gt;ii.sense.data
(braket
l_int|12
)braket
)paren
)paren
suffix:semicolon
id|tape_sprintf_event
(paren
id|tape_dbf_area
comma
l_int|3
comma
l_string|&quot;%08x %08x&bslash;n&quot;
comma
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|stat-&gt;ii.sense.data
(braket
l_int|16
)braket
)paren
comma
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|stat-&gt;ii.sense.data
(braket
l_int|20
)braket
)paren
)paren
suffix:semicolon
id|tape_sprintf_event
(paren
id|tape_dbf_area
comma
l_int|3
comma
l_string|&quot;%08x %08x&bslash;n&quot;
comma
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|stat-&gt;ii.sense.data
(braket
l_int|24
)braket
)paren
comma
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|stat-&gt;ii.sense.data
(braket
l_int|28
)braket
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Write sense data to console/dbf&n; */
r_void
DECL|function|tape_dump_sense
id|tape_dump_sense
(paren
id|tape_dev_t
op_star
id|td
)paren
(brace
id|devstat_t
op_star
id|stat
op_assign
op_amp
id|td-&gt;devstat
suffix:semicolon
macro_line|#if 1 /* XXX */
id|PRINT_INFO
(paren
l_string|&quot;-------------------------------------------------&bslash;n&quot;
)paren
suffix:semicolon
id|PRINT_INFO
(paren
l_string|&quot;DSTAT : %02x  CSTAT: %02x  CPA: %04x&bslash;n&quot;
comma
id|stat-&gt;dstat
comma
id|stat-&gt;cstat
comma
id|stat-&gt;cpa
)paren
suffix:semicolon
id|PRINT_INFO
(paren
l_string|&quot;DEVICE: %04x&bslash;n&quot;
comma
id|td-&gt;devinfo.devno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TAPE_BUSY
c_func
(paren
id|td
)paren
)paren
(brace
id|PRINT_INFO
c_func
(paren
l_string|&quot;OP    : %s&bslash;n&quot;
comma
id|tape_op_verbose
(braket
id|tape_get_active_ccw_req
c_func
(paren
id|td
)paren
op_member_access_from_pointer
id|op
)braket
)paren
suffix:semicolon
)brace
id|PRINT_INFO
(paren
l_string|&quot;Sense data: %02X%02X%02X%02X %02X%02X%02X%02X &quot;
l_string|&quot; %02X%02X%02X%02X %02X%02X%02X%02X &bslash;n&quot;
comma
id|stat-&gt;ii.sense.data
(braket
l_int|0
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|1
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|2
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|3
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|4
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|5
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|6
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|7
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|8
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|9
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|10
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|11
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|12
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|13
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|14
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|15
)braket
)paren
suffix:semicolon
id|PRINT_INFO
(paren
l_string|&quot;Sense data: %02X%02X%02X%02X %02X%02X%02X%02X &quot;
l_string|&quot; %02X%02X%02X%02X %02X%02X%02X%02X &bslash;n&quot;
comma
id|stat-&gt;ii.sense.data
(braket
l_int|16
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|17
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|18
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|19
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|20
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|21
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|22
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|23
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|24
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|25
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|26
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|27
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|28
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|29
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|30
)braket
comma
id|stat-&gt;ii.sense.data
(braket
l_int|31
)braket
)paren
suffix:semicolon
id|PRINT_INFO
(paren
l_string|&quot;--------------------------------------------------&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*******************************************************************&n; * TAPE Discipline functions&n; *******************************************************************/
multiline_comment|/*&n; * Register backend discipline&n; */
r_int
DECL|function|tape_register_discipline
id|tape_register_discipline
c_func
(paren
id|tape_discipline_t
op_star
id|disc
)paren
(brace
id|tape_discipline_t
op_star
id|disc_ptr
suffix:semicolon
r_int
id|lockflags
suffix:semicolon
id|disc-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|tape_discipline_lock
comma
id|lockflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape_first_disc
op_eq
l_int|NULL
)paren
(brace
id|tape_first_disc
op_assign
id|disc
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|disc_ptr
op_assign
id|tape_first_disc
suffix:semicolon
id|disc_ptr-&gt;next
op_ne
l_int|NULL
suffix:semicolon
id|disc_ptr
op_assign
(paren
id|tape_discipline_t
op_star
)paren
id|disc_ptr-&gt;next
)paren
(brace
suffix:semicolon
)brace
id|disc_ptr-&gt;next
op_assign
id|disc
suffix:semicolon
)brace
id|tape_create_devs_for_disc
c_func
(paren
id|disc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape_autoprobe
)paren
(brace
id|tape_create_devreg_for_disc
c_func
(paren
id|disc
)paren
suffix:semicolon
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|tape_discipline_lock
comma
id|lockflags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Unregister backend discipline&n; */
r_void
DECL|function|tape_unregister_discipline
id|tape_unregister_discipline
c_func
(paren
id|tape_discipline_t
op_star
id|disc
)paren
(brace
id|tape_discipline_t
op_star
id|lastdisc
suffix:semicolon
r_int
id|lockflags
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|tape_discipline_lock
comma
id|lockflags
)paren
suffix:semicolon
id|tape_delete_devs_for_disc
c_func
(paren
id|disc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape_autoprobe
)paren
(brace
id|tape_delete_devreg_for_disc
c_func
(paren
id|disc
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|disc
op_eq
id|tape_first_disc
)paren
(brace
id|tape_first_disc
op_assign
id|disc-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|lastdisc
op_assign
id|tape_first_disc
suffix:semicolon
r_while
c_loop
(paren
id|lastdisc-&gt;next
op_ne
id|disc
)paren
id|lastdisc
op_assign
id|lastdisc-&gt;next
suffix:semicolon
id|lastdisc-&gt;next
op_assign
id|disc-&gt;next
suffix:semicolon
)brace
id|disc
op_member_access_from_pointer
id|shutdown
c_func
(paren
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|tape_discipline_lock
comma
id|lockflags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Cleanup all registered disciplines&n; */
r_static
r_inline
r_void
DECL|function|tape_cleanup_disciplines
id|tape_cleanup_disciplines
(paren
r_void
)paren
(brace
r_int
id|lockflags
suffix:semicolon
id|tape_discipline_t
op_star
id|disc
suffix:semicolon
multiline_comment|/* Unregister all backend disciplines - this also deletes the devices */
id|write_lock_irqsave
c_func
(paren
op_amp
id|tape_discipline_lock
comma
id|lockflags
)paren
suffix:semicolon
id|disc
op_assign
id|tape_first_disc
suffix:semicolon
r_while
c_loop
(paren
id|disc
op_ne
l_int|NULL
)paren
(brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|tape_discipline_lock
comma
id|lockflags
)paren
suffix:semicolon
id|tape_unregister_discipline
c_func
(paren
id|disc
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|disc
)paren
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|tape_discipline_lock
comma
id|lockflags
)paren
suffix:semicolon
id|disc
op_assign
id|tape_first_disc
suffix:semicolon
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|tape_discipline_lock
comma
id|lockflags
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************&n; * TAPE Init Functions&n; *******************************************************************/
multiline_comment|/*&n; *      tape_print_banner will be called on initialisation and print a nice banner&n; */
r_static
r_inline
r_void
DECL|function|tape_print_banner
id|tape_print_banner
(paren
r_void
)paren
(brace
r_char
op_star
id|opt_char
comma
op_star
id|opt_block
suffix:semicolon
multiline_comment|/* print banner */
id|PRINT_WARN
(paren
l_string|&quot;IBM zSeries Tape Device Driver (v%d.%02d).&bslash;n&quot;
comma
id|TAPE_VERSION_MAJOR
comma
id|TAPE_VERSION_MINOR
)paren
suffix:semicolon
id|PRINT_WARN
(paren
l_string|&quot;(C) IBM Deutschland Entwicklung GmbH, 2000 - 2001&bslash;n&quot;
)paren
suffix:semicolon
id|opt_char
op_assign
id|opt_block
op_assign
l_string|&quot;not present&quot;
suffix:semicolon
macro_line|#ifdef CONFIG_S390_TAPE_CHAR
id|opt_char
op_assign
l_string|&quot;built in&quot;
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_S390_TAPE_BLOCK
id|opt_block
op_assign
l_string|&quot;built in&quot;
suffix:semicolon
macro_line|#endif
multiline_comment|/* print feature info */
id|PRINT_WARN
(paren
l_string|&quot;character device frontend   : %s&bslash;n&quot;
comma
id|opt_char
)paren
suffix:semicolon
id|PRINT_WARN
(paren
l_string|&quot;block device frontend       : %s&bslash;n&quot;
comma
id|opt_block
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *      tape_init will register the driver for each tape.&n; */
r_int
DECL|function|tape_init
id|tape_init
(paren
r_void
)paren
(brace
r_static
r_int
id|initialized
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|initialized
)paren
singleline_comment|// Only init the devices once
r_return
l_int|0
suffix:semicolon
id|initialized
op_assign
l_int|1
suffix:semicolon
id|tape_init_devregs
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef TAPE_DEBUG
id|tape_dbf_area
op_assign
id|debug_register
(paren
l_string|&quot;tape&quot;
comma
l_int|2
comma
l_int|2
comma
l_int|3
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|debug_register_view
c_func
(paren
id|tape_dbf_area
comma
op_amp
id|debug_sprintf_view
)paren
suffix:semicolon
id|tape_sprintf_event
(paren
id|tape_dbf_area
comma
l_int|3
comma
l_string|&quot;begin init&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* TAPE_DEBUG */
id|tape_print_banner
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifndef MODULE
id|tape_split_parm_string
c_func
(paren
id|tape_parm_string
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_DEVFS_FS
id|tape_devfs_root_entry
op_assign
id|devfs_mk_dir
(paren
l_int|NULL
comma
l_string|&quot;tape&quot;
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_DEVFS_FS */
id|tape_sprintf_event
(paren
id|tape_dbf_area
comma
l_int|3
comma
l_string|&quot;dev detect&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Allocate the tape structures */
r_if
c_cond
(paren
op_star
id|tape
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* if parameters are present */
id|PRINT_INFO
(paren
l_string|&quot;Using ranges supplied in parameters, disabling autoprobe mode.&bslash;n&quot;
)paren
suffix:semicolon
id|tape_parm_parse
(paren
id|tape
)paren
suffix:semicolon
id|tape_autoprobe
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|PRINT_INFO
(paren
l_string|&quot;No parameters supplied, enabling autoprobe mode for all supported devices.&bslash;n&quot;
)paren
suffix:semicolon
id|tape_autoprobe
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
id|tape_proc_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PROC_FS */
macro_line|#ifdef  CONFIG_S390_TAPE_3480 
id|tape_register_discipline
c_func
(paren
id|tape3480_init
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#else
macro_line|#ifndef CONFIG_S390_TAPE
id|tape_request_module
c_func
(paren
l_string|&quot;tape_3480_mod&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif /* CONFIG_S390_TAPE_3480 */
macro_line|#ifdef CONFIG_S390_TAPE_3490
id|tape_register_discipline
c_func
(paren
id|tape3490_init
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#else
macro_line|#ifndef CONFIG_S390_TAPE
id|tape_request_module
c_func
(paren
l_string|&quot;tape_3490_mod&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif /* CONFIG_S390_TAPE_3490 */
macro_line|#ifdef CONFIG_S390_TAPE_3590
id|tape_register_discipline
c_func
(paren
id|tape3590_init
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#else
macro_line|#ifndef CONFIG_S390_TAPE
id|tape_request_module
c_func
(paren
l_string|&quot;tape_3590_mod&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif /* CONFIG_S390_TAPE_3590 */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*******************************************************************&n; * TAPE Module functions&n; *******************************************************************/
macro_line|#ifdef MODULE
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;(C) 2001 IBM Deutschland Entwicklung GmbH by Carsten Otte and Michael Holzheu (cotte@de.ibm.com,holzheu@de.ibm.com)&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Linux on zSeries channel attached tape device driver&quot;
)paren
suffix:semicolon
id|MODULE_PARM
(paren
id|tape
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
(paren
l_int|256
)paren
l_string|&quot;s&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * The famous init_module&n; */
r_int
DECL|function|init_module
id|init_module
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_S390_TAPE_CHAR
id|tapechar_init
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_S390_TAPE_BLOCK
id|tapeblock_init
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Cleanup the frontends&n; */
r_static
r_inline
r_void
DECL|function|tape_cleanup_frontends
id|tape_cleanup_frontends
c_func
(paren
r_void
)paren
(brace
id|tape_frontend_t
op_star
id|frontend
comma
op_star
id|tempfe
suffix:semicolon
multiline_comment|/* Now get rid of the frontends */
macro_line|#ifdef CONFIG_S390_TAPE_CHAR
id|tapechar_uninit
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_S390_TAPE_BLOCK
id|tapeblock_uninit
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|frontend
op_assign
id|tape_first_front
suffix:semicolon
r_while
c_loop
(paren
id|frontend
op_ne
l_int|NULL
)paren
(brace
id|tempfe
op_assign
id|frontend
suffix:semicolon
id|frontend
op_assign
id|frontend-&gt;next
suffix:semicolon
id|kfree
(paren
id|tempfe
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Cleanup module&n; */
r_void
DECL|function|cleanup_module
id|cleanup_module
(paren
r_void
)paren
(brace
id|tape_sprintf_event
(paren
id|tape_dbf_area
comma
l_int|6
comma
l_string|&quot;cleaup mod&quot;
)paren
suffix:semicolon
id|tape_cleanup_disciplines
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_FS
id|devfs_unregister
(paren
id|tape_devfs_root_entry
)paren
suffix:semicolon
multiline_comment|/* devfs checks for NULL */
macro_line|#endif CONFIG_DEVFS_FS
macro_line|#ifdef CONFIG_PROC_FS
id|tape_proc_cleanup
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif 
id|tape_cleanup_frontends
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Deallocate devregs in case of not autoprobe */
r_if
c_cond
(paren
op_logical_neg
id|tape_autoprobe
)paren
(brace
id|tape_delete_all_devregs
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef TAPE_DEBUG
id|debug_unregister
(paren
id|tape_dbf_area
)paren
suffix:semicolon
macro_line|#endif /* TAPE_DEBUG */
)brace
macro_line|#endif&t;&t;&t;&t;/* MODULE */
multiline_comment|/*******************************************************************&n; * TAPE Tapestate functions&n; *******************************************************************/
r_inline
r_void
DECL|function|tape_state_set
id|tape_state_set
(paren
id|tape_dev_t
op_star
id|td
comma
id|tape_state_t
id|newstate
)paren
(brace
r_if
c_cond
(paren
id|td-&gt;tape_state
op_eq
id|TS_NOT_OPER
)paren
(brace
id|tape_sprintf_event
c_func
(paren
id|tape_dbf_area
comma
l_int|3
comma
l_string|&quot;ts_set err: not oper&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|tape_sprintf_event
c_func
(paren
id|tape_dbf_area
comma
l_int|4
comma
l_string|&quot;ts. dev:  %x&bslash;n&quot;
comma
id|td-&gt;first_minor
)paren
suffix:semicolon
id|tape_sprintf_event
c_func
(paren
id|tape_dbf_area
comma
l_int|4
comma
l_string|&quot;old ts:   %s&bslash;n&quot;
comma
(paren
(paren
(paren
id|tape_state_get
(paren
id|td
)paren
OL
id|TO_SIZE
)paren
op_logical_and
(paren
id|tape_state_get
(paren
id|td
)paren
op_ge
l_int|0
)paren
)paren
ques
c_cond
id|tape_state_verbose
(braket
id|tape_state_get
(paren
id|td
)paren
)braket
suffix:colon
l_string|&quot;UNKNOWN TS&quot;
)paren
)paren
suffix:semicolon
id|tape_sprintf_event
c_func
(paren
id|tape_dbf_area
comma
l_int|4
comma
l_string|&quot;%s&bslash;n&quot;
comma
(paren
(paren
(paren
id|tape_state_get
(paren
id|td
)paren
OL
id|TO_SIZE
)paren
op_logical_and
(paren
id|tape_state_get
(paren
id|td
)paren
op_ge
l_int|0
)paren
)paren
ques
c_cond
id|tape_state_verbose
(braket
id|tape_state_get
(paren
id|td
)paren
)braket
suffix:colon
l_string|&quot;UNKNOWN TS&quot;
)paren
)paren
suffix:semicolon
id|tape_sprintf_event
(paren
id|tape_dbf_area
comma
l_int|4
comma
l_string|&quot;new ts:   &bslash;n&quot;
)paren
suffix:semicolon
id|tape_sprintf_event
(paren
id|tape_dbf_area
comma
l_int|4
comma
l_string|&quot;%s&bslash;n&quot;
comma
(paren
(paren
(paren
id|newstate
OL
id|TO_SIZE
)paren
op_logical_and
(paren
id|newstate
op_ge
l_int|0
)paren
)paren
ques
c_cond
id|tape_state_verbose
(braket
id|newstate
)braket
suffix:colon
l_string|&quot;UNKNOWN TS&quot;
)paren
)paren
suffix:semicolon
id|td-&gt;tape_state
op_assign
id|newstate
suffix:semicolon
)brace
)brace
r_inline
id|tape_state_t
DECL|function|tape_state_get
id|tape_state_get
(paren
id|tape_dev_t
op_star
id|td
)paren
(brace
r_return
(paren
id|td-&gt;tape_state
)paren
suffix:semicolon
)brace
r_inline
r_void
DECL|function|tape_med_state_set
id|tape_med_state_set
c_func
(paren
id|tape_dev_t
op_star
id|td
comma
id|tape_medium_state_t
id|newstate
)paren
(brace
r_if
c_cond
(paren
id|td-&gt;medium_state
op_eq
id|newstate
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|newstate
)paren
(brace
r_case
id|MS_UNLOADED
suffix:colon
id|PRINT_INFO
c_func
(paren
l_string|&quot;(%x): Tape is unloaded&bslash;n&quot;
comma
id|td-&gt;devstat.devno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MS_LOADED
suffix:colon
id|PRINT_INFO
c_func
(paren
l_string|&quot;(%x): Tape has been mounted&bslash;n&quot;
comma
id|td-&gt;devstat.devno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
singleline_comment|// print nothing
r_break
suffix:semicolon
)brace
id|td-&gt;medium_state
op_assign
id|newstate
suffix:semicolon
id|out
suffix:colon
r_return
suffix:semicolon
)brace
multiline_comment|/*******************************************************************&n; * TAPE Exported Functions &n; *******************************************************************/
DECL|variable|tape_register_discipline
id|EXPORT_SYMBOL
c_func
(paren
id|tape_register_discipline
)paren
suffix:semicolon
DECL|variable|tape_unregister_discipline
id|EXPORT_SYMBOL
c_func
(paren
id|tape_unregister_discipline
)paren
suffix:semicolon
DECL|variable|tape_dbf_area
id|EXPORT_SYMBOL
c_func
(paren
id|tape_dbf_area
)paren
suffix:semicolon
DECL|variable|tape_alloc_ccw_req
id|EXPORT_SYMBOL
c_func
(paren
id|tape_alloc_ccw_req
)paren
suffix:semicolon
DECL|variable|tape_free_ccw_req
id|EXPORT_SYMBOL
c_func
(paren
id|tape_free_ccw_req
)paren
suffix:semicolon
DECL|variable|tape_state_set
id|EXPORT_SYMBOL
c_func
(paren
id|tape_state_set
)paren
suffix:semicolon
DECL|variable|tape_state_get
id|EXPORT_SYMBOL
c_func
(paren
id|tape_state_get
)paren
suffix:semicolon
DECL|variable|tape_med_state_set
id|EXPORT_SYMBOL
c_func
(paren
id|tape_med_state_set
)paren
suffix:semicolon
DECL|variable|tape_state_verbose
id|EXPORT_SYMBOL
c_func
(paren
id|tape_state_verbose
)paren
suffix:semicolon
DECL|variable|tape_op_verbose
id|EXPORT_SYMBOL
c_func
(paren
id|tape_op_verbose
)paren
suffix:semicolon
DECL|variable|tape_dump_sense
id|EXPORT_SYMBOL
c_func
(paren
id|tape_dump_sense
)paren
suffix:semicolon
DECL|variable|tape_dump_sense_dbf
id|EXPORT_SYMBOL
c_func
(paren
id|tape_dump_sense_dbf
)paren
suffix:semicolon
DECL|variable|tape_do_io
id|EXPORT_SYMBOL
c_func
(paren
id|tape_do_io
)paren
suffix:semicolon
DECL|variable|tape_do_io_irq
id|EXPORT_SYMBOL
c_func
(paren
id|tape_do_io_irq
)paren
suffix:semicolon
DECL|variable|tape_do_io_and_wait
id|EXPORT_SYMBOL
c_func
(paren
id|tape_do_io_and_wait
)paren
suffix:semicolon
DECL|variable|tape_remove_ccw_req
id|EXPORT_SYMBOL
c_func
(paren
id|tape_remove_ccw_req
)paren
suffix:semicolon
DECL|variable|tape_get_active_ccw_req
id|EXPORT_SYMBOL
c_func
(paren
id|tape_get_active_ccw_req
)paren
suffix:semicolon
eof
