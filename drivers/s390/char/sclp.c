multiline_comment|/*&n; *  drivers/s390/char/sclp.c&n; *     core function to access sclp interface&n; *&n; *  S390 version&n; *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation&n; *    Author(s): Martin Peschke &lt;mpeschke@de.ibm.com&gt;&n; *&t;&t; Martin Schwidefsky &lt;schwidefsky@de.ibm.com&gt;&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/err.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/jiffies.h&gt;
macro_line|#include &lt;asm/types.h&gt;
macro_line|#include &lt;asm/s390_ext.h&gt;
macro_line|#include &quot;sclp.h&quot;
DECL|macro|SCLP_HEADER
mdefine_line|#define SCLP_HEADER&t;&t;&quot;sclp: &quot;
multiline_comment|/* Structure for register_early_external_interrupt. */
DECL|variable|ext_int_info_hwc
r_static
id|ext_int_info_t
id|ext_int_info_hwc
suffix:semicolon
multiline_comment|/* Lock to protect internal data consistency. */
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|sclp_lock
)paren
suffix:semicolon
multiline_comment|/* Mask of events that we can receive from the sclp interface. */
DECL|variable|sclp_receive_mask
r_static
id|sccb_mask_t
id|sclp_receive_mask
suffix:semicolon
multiline_comment|/* Mask of events that we can send to the sclp interface. */
DECL|variable|sclp_send_mask
r_static
id|sccb_mask_t
id|sclp_send_mask
suffix:semicolon
multiline_comment|/* List of registered event listeners and senders. */
DECL|variable|sclp_reg_list
r_static
r_struct
id|list_head
id|sclp_reg_list
suffix:semicolon
multiline_comment|/* List of queued requests. */
DECL|variable|sclp_req_queue
r_static
r_struct
id|list_head
id|sclp_req_queue
suffix:semicolon
multiline_comment|/* Data for read and and init requests. */
DECL|variable|sclp_read_req
r_static
r_struct
id|sclp_req
id|sclp_read_req
suffix:semicolon
DECL|variable|sclp_init_req
r_static
r_struct
id|sclp_req
id|sclp_init_req
suffix:semicolon
DECL|variable|sclp_read_sccb
r_static
r_char
id|sclp_read_sccb
(braket
id|PAGE_SIZE
)braket
id|__attribute__
c_func
(paren
(paren
id|__aligned__
c_func
(paren
id|PAGE_SIZE
)paren
)paren
)paren
suffix:semicolon
DECL|variable|sclp_init_sccb
r_static
r_char
id|sclp_init_sccb
(braket
id|PAGE_SIZE
)braket
id|__attribute__
c_func
(paren
(paren
id|__aligned__
c_func
(paren
id|PAGE_SIZE
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Timer for request retries. */
DECL|variable|sclp_request_timer
r_static
r_struct
id|timer_list
id|sclp_request_timer
suffix:semicolon
multiline_comment|/* Internal state: is the driver initialized? */
DECL|enum|sclp_init_state_t
r_static
r_volatile
r_enum
id|sclp_init_state_t
(brace
DECL|enumerator|sclp_init_state_uninitialized
id|sclp_init_state_uninitialized
comma
DECL|enumerator|sclp_init_state_initializing
id|sclp_init_state_initializing
comma
DECL|enumerator|sclp_init_state_initialized
id|sclp_init_state_initialized
DECL|variable|sclp_init_state
)brace
id|sclp_init_state
op_assign
id|sclp_init_state_uninitialized
suffix:semicolon
multiline_comment|/* Internal state: is a request active at the sclp? */
DECL|enum|sclp_running_state_t
r_static
r_volatile
r_enum
id|sclp_running_state_t
(brace
DECL|enumerator|sclp_running_state_idle
id|sclp_running_state_idle
comma
DECL|enumerator|sclp_running_state_running
id|sclp_running_state_running
DECL|variable|sclp_running_state
)brace
id|sclp_running_state
op_assign
id|sclp_running_state_idle
suffix:semicolon
multiline_comment|/* Internal state: is a read request pending? */
DECL|enum|sclp_reading_state_t
r_static
r_volatile
r_enum
id|sclp_reading_state_t
(brace
DECL|enumerator|sclp_reading_state_idle
id|sclp_reading_state_idle
comma
DECL|enumerator|sclp_reading_state_reading
id|sclp_reading_state_reading
DECL|variable|sclp_reading_state
)brace
id|sclp_reading_state
op_assign
id|sclp_reading_state_idle
suffix:semicolon
multiline_comment|/* Internal state: is the driver currently serving requests? */
DECL|enum|sclp_activation_state_t
r_static
r_volatile
r_enum
id|sclp_activation_state_t
(brace
DECL|enumerator|sclp_activation_state_active
id|sclp_activation_state_active
comma
DECL|enumerator|sclp_activation_state_deactivating
id|sclp_activation_state_deactivating
comma
DECL|enumerator|sclp_activation_state_inactive
id|sclp_activation_state_inactive
comma
DECL|enumerator|sclp_activation_state_activating
id|sclp_activation_state_activating
DECL|variable|sclp_activation_state
)brace
id|sclp_activation_state
op_assign
id|sclp_activation_state_active
suffix:semicolon
multiline_comment|/* Internal state: is an init mask request pending? */
DECL|enum|sclp_mask_state_t
r_static
r_volatile
r_enum
id|sclp_mask_state_t
(brace
DECL|enumerator|sclp_mask_state_idle
id|sclp_mask_state_idle
comma
DECL|enumerator|sclp_mask_state_initializing
id|sclp_mask_state_initializing
DECL|variable|sclp_mask_state
)brace
id|sclp_mask_state
op_assign
id|sclp_mask_state_idle
suffix:semicolon
multiline_comment|/* Maximum retry counts */
DECL|macro|SCLP_INIT_RETRY
mdefine_line|#define SCLP_INIT_RETRY&t;&t;3
DECL|macro|SCLP_MASK_RETRY
mdefine_line|#define SCLP_MASK_RETRY&t;&t;3
DECL|macro|SCLP_REQUEST_RETRY
mdefine_line|#define SCLP_REQUEST_RETRY&t;3
multiline_comment|/* Timeout intervals in seconds.*/
DECL|macro|SCLP_BUSY_INTERVAL
mdefine_line|#define SCLP_BUSY_INTERVAL&t;2
DECL|macro|SCLP_RETRY_INTERVAL
mdefine_line|#define SCLP_RETRY_INTERVAL&t;5
r_static
r_void
id|sclp_process_queue
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|sclp_init_mask
c_func
(paren
r_int
id|calculate
)paren
suffix:semicolon
r_static
r_int
id|sclp_init
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* Perform service call. Return 0 on success, non-zero otherwise. */
r_static
r_int
DECL|function|service_call
id|service_call
c_func
(paren
id|sclp_cmdw_t
id|command
comma
r_void
op_star
id|sccb
)paren
(brace
r_int
id|cc
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;   .insn rre,0xb2200000,%1,%2&bslash;n&quot;
multiline_comment|/* servc %1,%2 */
l_string|&quot;   ipm&t;  %0&bslash;n&quot;
l_string|&quot;   srl&t;  %0,28&quot;
suffix:colon
l_string|&quot;=&amp;d&quot;
(paren
id|cc
)paren
suffix:colon
l_string|&quot;d&quot;
(paren
id|command
)paren
comma
l_string|&quot;a&quot;
(paren
id|__pa
c_func
(paren
id|sccb
)paren
)paren
suffix:colon
l_string|&quot;cc&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cc
op_eq
l_int|3
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|cc
op_eq
l_int|2
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Request timeout handler. Restart the request queue. If DATA is non-zero,&n; * force restart of running request. */
r_static
r_void
DECL|function|sclp_request_timeout
id|sclp_request_timeout
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|data
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
id|sclp_running_state
op_assign
id|sclp_running_state_idle
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|sclp_process_queue
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Set up request retry timer. Called while sclp_lock is locked. */
r_static
r_inline
r_void
DECL|function|__sclp_set_request_timer
id|__sclp_set_request_timer
c_func
(paren
r_int
r_int
id|time
comma
r_void
(paren
op_star
id|function
)paren
(paren
r_int
r_int
)paren
comma
r_int
r_int
id|data
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|sclp_request_timer
)paren
suffix:semicolon
id|sclp_request_timer.function
op_assign
id|function
suffix:semicolon
id|sclp_request_timer.data
op_assign
id|data
suffix:semicolon
id|sclp_request_timer.expires
op_assign
id|jiffies
op_plus
id|time
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sclp_request_timer
)paren
suffix:semicolon
)brace
multiline_comment|/* Try to start a request. Return zero if the request was successfully&n; * started or if it will be started at a later time. Return non-zero otherwise.&n; * Called while sclp_lock is locked. */
r_static
r_int
DECL|function|__sclp_start_request
id|__sclp_start_request
c_func
(paren
r_struct
id|sclp_req
op_star
id|req
)paren
(brace
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|sclp_running_state
op_ne
id|sclp_running_state_idle
)paren
r_return
l_int|0
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|sclp_request_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;start_count
op_le
id|SCLP_REQUEST_RETRY
)paren
(brace
id|rc
op_assign
id|service_call
c_func
(paren
id|req-&gt;command
comma
id|req-&gt;sccb
)paren
suffix:semicolon
id|req-&gt;start_count
op_increment
suffix:semicolon
)brace
r_else
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Sucessfully started request */
id|req-&gt;status
op_assign
id|SCLP_REQ_RUNNING
suffix:semicolon
id|sclp_running_state
op_assign
id|sclp_running_state_running
suffix:semicolon
id|__sclp_set_request_timer
c_func
(paren
id|SCLP_RETRY_INTERVAL
op_star
id|HZ
comma
id|sclp_request_timeout
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rc
op_eq
op_minus
id|EBUSY
)paren
(brace
multiline_comment|/* Try again later */
id|__sclp_set_request_timer
c_func
(paren
id|SCLP_BUSY_INTERVAL
op_star
id|HZ
comma
id|sclp_request_timeout
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Request failed */
id|req-&gt;status
op_assign
id|SCLP_REQ_FAILED
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* Try to start queued requests. */
r_static
r_void
DECL|function|sclp_process_queue
id|sclp_process_queue
c_func
(paren
r_void
)paren
(brace
r_struct
id|sclp_req
op_star
id|req
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sclp_running_state
op_ne
id|sclp_running_state_idle
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|del_timer
c_func
(paren
op_amp
id|sclp_request_timer
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|sclp_req_queue
)paren
)paren
(brace
id|req
op_assign
id|list_entry
c_func
(paren
id|sclp_req_queue.next
comma
r_struct
id|sclp_req
comma
id|list
)paren
suffix:semicolon
id|rc
op_assign
id|__sclp_start_request
c_func
(paren
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* Request failed. */
id|list_del
c_func
(paren
op_amp
id|req-&gt;list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;callback
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
id|req
op_member_access_from_pointer
id|callback
c_func
(paren
id|req
comma
id|req-&gt;callback_data
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Queue a new request. Return zero on success, non-zero otherwise. */
r_int
DECL|function|sclp_add_request
id|sclp_add_request
c_func
(paren
r_struct
id|sclp_req
op_star
id|req
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sclp_init_state
op_ne
id|sclp_init_state_initialized
op_logical_or
id|sclp_activation_state
op_ne
id|sclp_activation_state_active
)paren
op_logical_and
id|req
op_ne
op_amp
id|sclp_init_req
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|req-&gt;status
op_assign
id|SCLP_REQ_QUEUED
suffix:semicolon
id|req-&gt;start_count
op_assign
l_int|0
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|req-&gt;list
comma
op_amp
id|sclp_req_queue
)paren
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Start if request is first in list */
r_if
c_cond
(paren
id|req-&gt;list.prev
op_eq
op_amp
id|sclp_req_queue
)paren
(brace
id|rc
op_assign
id|__sclp_start_request
c_func
(paren
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
id|list_del
c_func
(paren
op_amp
id|req-&gt;list
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|variable|sclp_add_request
id|EXPORT_SYMBOL
c_func
(paren
id|sclp_add_request
)paren
suffix:semicolon
multiline_comment|/* Dispatch events found in request buffer to registered listeners. Return 0&n; * if all events were dispatched, non-zero otherwise. */
r_static
r_int
DECL|function|sclp_dispatch_evbufs
id|sclp_dispatch_evbufs
c_func
(paren
r_struct
id|sccb_header
op_star
id|sccb
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|evbuf_header
op_star
id|evbuf
suffix:semicolon
r_struct
id|list_head
op_star
id|l
suffix:semicolon
r_struct
id|sclp_register
op_star
id|reg
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
r_sizeof
(paren
r_struct
id|sccb_header
)paren
suffix:semicolon
id|offset
OL
id|sccb-&gt;length
suffix:semicolon
id|offset
op_add_assign
id|evbuf-&gt;length
)paren
(brace
multiline_comment|/* Search for event handler */
id|evbuf
op_assign
(paren
r_struct
id|evbuf_header
op_star
)paren
(paren
(paren
id|addr_t
)paren
id|sccb
op_plus
id|offset
)paren
suffix:semicolon
id|reg
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|sclp_reg_list
)paren
(brace
id|reg
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|sclp_register
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg-&gt;receive_mask
op_amp
(paren
l_int|1
op_lshift
(paren
l_int|32
op_minus
id|evbuf-&gt;type
)paren
)paren
)paren
r_break
suffix:semicolon
r_else
id|reg
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reg
op_logical_and
id|reg-&gt;receiver_fn
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
id|reg
op_member_access_from_pointer
id|receiver_fn
c_func
(paren
id|evbuf
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|reg
op_eq
l_int|NULL
)paren
id|rc
op_assign
op_minus
id|ENOSYS
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* Read event data request callback. */
r_static
r_void
DECL|function|sclp_read_cb
id|sclp_read_cb
c_func
(paren
r_struct
id|sclp_req
op_star
id|req
comma
r_void
op_star
id|data
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sccb_header
op_star
id|sccb
suffix:semicolon
id|sccb
op_assign
(paren
r_struct
id|sccb_header
op_star
)paren
id|req-&gt;sccb
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;status
op_eq
id|SCLP_REQ_DONE
op_logical_and
(paren
id|sccb-&gt;response_code
op_eq
l_int|0x20
op_logical_or
id|sccb-&gt;response_code
op_eq
l_int|0x220
)paren
)paren
id|sclp_dispatch_evbufs
c_func
(paren
id|sccb
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
id|sclp_reading_state
op_assign
id|sclp_reading_state_idle
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Prepare read event data request. Called while sclp_lock is locked. */
r_static
r_inline
r_void
DECL|function|__sclp_make_read_req
id|__sclp_make_read_req
c_func
(paren
r_void
)paren
(brace
r_struct
id|sccb_header
op_star
id|sccb
suffix:semicolon
id|sccb
op_assign
(paren
r_struct
id|sccb_header
op_star
)paren
id|sclp_read_sccb
suffix:semicolon
id|clear_page
c_func
(paren
id|sccb
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|sclp_read_req
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sclp_req
)paren
)paren
suffix:semicolon
id|sclp_read_req.command
op_assign
id|SCLP_CMDW_READDATA
suffix:semicolon
id|sclp_read_req.status
op_assign
id|SCLP_REQ_QUEUED
suffix:semicolon
id|sclp_read_req.start_count
op_assign
l_int|0
suffix:semicolon
id|sclp_read_req.callback
op_assign
id|sclp_read_cb
suffix:semicolon
id|sclp_read_req.sccb
op_assign
id|sccb
suffix:semicolon
id|sccb-&gt;length
op_assign
id|PAGE_SIZE
suffix:semicolon
id|sccb-&gt;function_code
op_assign
l_int|0
suffix:semicolon
id|sccb-&gt;control_mask
(braket
l_int|2
)braket
op_assign
l_int|0x80
suffix:semicolon
)brace
multiline_comment|/* Search request list for request with matching sccb. Return request if found,&n; * NULL otherwise. Called while sclp_lock is locked. */
r_static
r_inline
r_struct
id|sclp_req
op_star
DECL|function|__sclp_find_req
id|__sclp_find_req
c_func
(paren
id|u32
id|sccb
)paren
(brace
r_struct
id|list_head
op_star
id|l
suffix:semicolon
r_struct
id|sclp_req
op_star
id|req
suffix:semicolon
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|sclp_req_queue
)paren
(brace
id|req
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|sclp_req
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sccb
op_eq
(paren
id|u32
)paren
(paren
id|addr_t
)paren
id|req-&gt;sccb
)paren
r_return
id|req
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Handler for external interruption. Perform request post-processing.&n; * Prepare read event data request if necessary. Start processing of next&n; * request on queue. */
r_static
r_void
DECL|function|sclp_interrupt_handler
id|sclp_interrupt_handler
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
id|__u16
id|code
)paren
(brace
r_struct
id|sclp_req
op_star
id|req
suffix:semicolon
id|u32
id|finished_sccb
suffix:semicolon
id|u32
id|evbuf_pending
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sclp_lock
)paren
suffix:semicolon
id|finished_sccb
op_assign
id|S390_lowcore.ext_params
op_amp
l_int|0xfffffff8
suffix:semicolon
id|evbuf_pending
op_assign
id|S390_lowcore.ext_params
op_amp
l_int|0x3
suffix:semicolon
r_if
c_cond
(paren
id|finished_sccb
)paren
(brace
id|req
op_assign
id|__sclp_find_req
c_func
(paren
id|finished_sccb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
multiline_comment|/* Request post-processing */
id|list_del
c_func
(paren
op_amp
id|req-&gt;list
)paren
suffix:semicolon
id|req-&gt;status
op_assign
id|SCLP_REQ_DONE
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;callback
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|sclp_lock
)paren
suffix:semicolon
id|req
op_member_access_from_pointer
id|callback
c_func
(paren
id|req
comma
id|req-&gt;callback_data
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sclp_lock
)paren
suffix:semicolon
)brace
)brace
id|sclp_running_state
op_assign
id|sclp_running_state_idle
suffix:semicolon
)brace
r_if
c_cond
(paren
id|evbuf_pending
op_logical_and
id|sclp_receive_mask
op_ne
l_int|0
op_logical_and
id|sclp_reading_state
op_eq
id|sclp_reading_state_idle
op_logical_and
id|sclp_activation_state
op_eq
id|sclp_activation_state_active
)paren
(brace
id|sclp_reading_state
op_assign
id|sclp_reading_state_reading
suffix:semicolon
id|__sclp_make_read_req
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Add request to head of queue */
id|list_add
c_func
(paren
op_amp
id|sclp_read_req.list
comma
op_amp
id|sclp_req_queue
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|sclp_lock
)paren
suffix:semicolon
id|sclp_process_queue
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Return current Time-Of-Day clock. */
r_static
r_inline
id|u64
DECL|function|sclp_get_clock
id|sclp_get_clock
c_func
(paren
r_void
)paren
(brace
id|u64
id|result
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;STCK 0(%1)&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|result
)paren
suffix:colon
l_string|&quot;a&quot;
(paren
op_amp
(paren
id|result
)paren
)paren
suffix:colon
l_string|&quot;cc&quot;
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* Convert interval in jiffies to TOD ticks. */
r_static
r_inline
id|u64
DECL|function|sclp_tod_from_jiffies
id|sclp_tod_from_jiffies
c_func
(paren
r_int
r_int
id|jiffies
)paren
(brace
r_return
(paren
id|u64
)paren
(paren
id|jiffies
op_div
id|HZ
)paren
op_lshift
l_int|32
suffix:semicolon
)brace
multiline_comment|/* Wait until a currently running request finished. Note: while this function&n; * is running, no timers are served on the calling CPU. */
r_void
DECL|function|sclp_sync_wait
id|sclp_sync_wait
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|psw_mask
suffix:semicolon
r_int
r_int
id|cr0
comma
id|cr0_sync
suffix:semicolon
id|u64
id|timeout
suffix:semicolon
multiline_comment|/* We&squot;ll be disabling timer interrupts, so we need a custom timeout&n;&t; * mechanism */
id|timeout
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|sclp_request_timer
)paren
)paren
(brace
multiline_comment|/* Get timeout TOD value */
id|timeout
op_assign
id|sclp_get_clock
c_func
(paren
)paren
op_plus
id|sclp_tod_from_jiffies
c_func
(paren
id|sclp_request_timer.expires
op_minus
id|jiffies
)paren
suffix:semicolon
)brace
multiline_comment|/* Prevent bottom half from executing once we force interrupts open */
id|local_bh_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Enable service-signal interruption, disable timer interrupts */
id|__ctl_store
c_func
(paren
id|cr0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|cr0_sync
op_assign
id|cr0
suffix:semicolon
id|cr0_sync
op_or_assign
l_int|0x00000200
suffix:semicolon
id|cr0_sync
op_and_assign
l_int|0xFFFFF3AC
suffix:semicolon
id|__ctl_load
c_func
(paren
id|cr0_sync
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;STOSM 0(%1),0x01&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|psw_mask
)paren
suffix:colon
l_string|&quot;a&quot;
(paren
op_amp
id|psw_mask
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/* Loop until driver state indicates finished request */
r_while
c_loop
(paren
id|sclp_running_state
op_ne
id|sclp_running_state_idle
)paren
(brace
multiline_comment|/* Check for expired request timer */
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|sclp_request_timer
)paren
op_logical_and
id|sclp_get_clock
c_func
(paren
)paren
OG
id|timeout
op_logical_and
id|del_timer
c_func
(paren
op_amp
id|sclp_request_timer
)paren
)paren
id|sclp_request_timer
dot
id|function
c_func
(paren
id|sclp_request_timer.data
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Restore interrupt settings */
id|asm
r_volatile
(paren
l_string|&quot;SSM 0(%0)&quot;
suffix:colon
suffix:colon
l_string|&quot;a&quot;
(paren
op_amp
id|psw_mask
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
id|__ctl_load
c_func
(paren
id|cr0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|__local_bh_enable
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|sclp_sync_wait
id|EXPORT_SYMBOL
c_func
(paren
id|sclp_sync_wait
)paren
suffix:semicolon
multiline_comment|/* Dispatch changes in send and receive mask to registered listeners. */
r_static
r_inline
r_void
DECL|function|sclp_dispatch_state_change
id|sclp_dispatch_state_change
c_func
(paren
r_void
)paren
(brace
r_struct
id|list_head
op_star
id|l
suffix:semicolon
r_struct
id|sclp_register
op_star
id|reg
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|sccb_mask_t
id|receive_mask
suffix:semicolon
id|sccb_mask_t
id|send_mask
suffix:semicolon
r_do
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
id|reg
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|sclp_reg_list
)paren
(brace
id|reg
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|sclp_register
comma
id|list
)paren
suffix:semicolon
id|receive_mask
op_assign
id|reg-&gt;receive_mask
op_amp
id|sclp_receive_mask
suffix:semicolon
id|send_mask
op_assign
id|reg-&gt;send_mask
op_amp
id|sclp_send_mask
suffix:semicolon
r_if
c_cond
(paren
id|reg-&gt;sclp_receive_mask
op_ne
id|receive_mask
op_logical_or
id|reg-&gt;sclp_send_mask
op_ne
id|send_mask
)paren
(brace
id|reg-&gt;sclp_receive_mask
op_assign
id|receive_mask
suffix:semicolon
id|reg-&gt;sclp_send_mask
op_assign
id|send_mask
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
id|reg
op_assign
l_int|NULL
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_logical_and
id|reg-&gt;state_change_fn
)paren
id|reg
op_member_access_from_pointer
id|state_change_fn
c_func
(paren
id|reg
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|reg
)paren
suffix:semicolon
)brace
DECL|struct|sclp_statechangebuf
r_struct
id|sclp_statechangebuf
(brace
DECL|member|header
r_struct
id|evbuf_header
id|header
suffix:semicolon
DECL|member|validity_sclp_active_facility_mask
id|u8
id|validity_sclp_active_facility_mask
suffix:colon
l_int|1
suffix:semicolon
DECL|member|validity_sclp_receive_mask
id|u8
id|validity_sclp_receive_mask
suffix:colon
l_int|1
suffix:semicolon
DECL|member|validity_sclp_send_mask
id|u8
id|validity_sclp_send_mask
suffix:colon
l_int|1
suffix:semicolon
DECL|member|validity_read_data_function_mask
id|u8
id|validity_read_data_function_mask
suffix:colon
l_int|1
suffix:semicolon
DECL|member|_zeros
id|u16
id|_zeros
suffix:colon
l_int|12
suffix:semicolon
DECL|member|mask_length
id|u16
id|mask_length
suffix:semicolon
DECL|member|sclp_active_facility_mask
id|u64
id|sclp_active_facility_mask
suffix:semicolon
DECL|member|sclp_receive_mask
id|sccb_mask_t
id|sclp_receive_mask
suffix:semicolon
DECL|member|sclp_send_mask
id|sccb_mask_t
id|sclp_send_mask
suffix:semicolon
DECL|member|read_data_function_mask
id|u32
id|read_data_function_mask
suffix:semicolon
)brace
id|__attribute__
c_func
(paren
(paren
id|packed
)paren
)paren
suffix:semicolon
multiline_comment|/* State change event callback. Inform listeners of changes. */
r_static
r_void
DECL|function|sclp_state_change_cb
id|sclp_state_change_cb
c_func
(paren
r_struct
id|evbuf_header
op_star
id|evbuf
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sclp_statechangebuf
op_star
id|scbuf
suffix:semicolon
id|scbuf
op_assign
(paren
r_struct
id|sclp_statechangebuf
op_star
)paren
id|evbuf
suffix:semicolon
r_if
c_cond
(paren
id|scbuf-&gt;mask_length
op_ne
r_sizeof
(paren
id|sccb_mask_t
)paren
)paren
r_return
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scbuf-&gt;validity_sclp_receive_mask
)paren
id|sclp_receive_mask
op_assign
id|scbuf-&gt;sclp_receive_mask
suffix:semicolon
r_if
c_cond
(paren
id|scbuf-&gt;validity_sclp_send_mask
)paren
id|sclp_send_mask
op_assign
id|scbuf-&gt;sclp_send_mask
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
id|sclp_dispatch_state_change
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|sclp_state_change_event
r_static
r_struct
id|sclp_register
id|sclp_state_change_event
op_assign
(brace
dot
id|receive_mask
op_assign
id|EvTyp_StateChange_Mask
comma
dot
id|receiver_fn
op_assign
id|sclp_state_change_cb
)brace
suffix:semicolon
multiline_comment|/* Calculate receive and send mask of currently registered listeners.&n; * Called while sclp_lock is locked. */
r_static
r_inline
r_void
DECL|function|__sclp_get_mask
id|__sclp_get_mask
c_func
(paren
id|sccb_mask_t
op_star
id|receive_mask
comma
id|sccb_mask_t
op_star
id|send_mask
)paren
(brace
r_struct
id|list_head
op_star
id|l
suffix:semicolon
r_struct
id|sclp_register
op_star
id|t
suffix:semicolon
op_star
id|receive_mask
op_assign
l_int|0
suffix:semicolon
op_star
id|send_mask
op_assign
l_int|0
suffix:semicolon
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|sclp_reg_list
)paren
(brace
id|t
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|sclp_register
comma
id|list
)paren
suffix:semicolon
op_star
id|receive_mask
op_or_assign
id|t-&gt;receive_mask
suffix:semicolon
op_star
id|send_mask
op_or_assign
id|t-&gt;send_mask
suffix:semicolon
)brace
)brace
multiline_comment|/* Register event listener. Return 0 on success, non-zero otherwise. */
r_int
DECL|function|sclp_register
id|sclp_register
c_func
(paren
r_struct
id|sclp_register
op_star
id|reg
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|sccb_mask_t
id|receive_mask
suffix:semicolon
id|sccb_mask_t
id|send_mask
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|sclp_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Check event mask for collisions */
id|__sclp_get_mask
c_func
(paren
op_amp
id|receive_mask
comma
op_amp
id|send_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg-&gt;receive_mask
op_amp
id|receive_mask
op_logical_or
id|reg-&gt;send_mask
op_amp
id|send_mask
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* Trigger initial state change callback */
id|reg-&gt;sclp_receive_mask
op_assign
l_int|0
suffix:semicolon
id|reg-&gt;sclp_send_mask
op_assign
l_int|0
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|reg-&gt;list
comma
op_amp
id|sclp_reg_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
id|rc
op_assign
id|sclp_init_mask
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|reg-&gt;list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|variable|sclp_register
id|EXPORT_SYMBOL
c_func
(paren
id|sclp_register
)paren
suffix:semicolon
multiline_comment|/* Unregister event listener. */
r_void
DECL|function|sclp_unregister
id|sclp_unregister
c_func
(paren
r_struct
id|sclp_register
op_star
id|reg
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|reg-&gt;list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
id|sclp_init_mask
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|variable|sclp_unregister
id|EXPORT_SYMBOL
c_func
(paren
id|sclp_unregister
)paren
suffix:semicolon
multiline_comment|/* Remove event buffers which are marked processed. Return the number of&n; * remaining event buffers. */
r_int
DECL|function|sclp_remove_processed
id|sclp_remove_processed
c_func
(paren
r_struct
id|sccb_header
op_star
id|sccb
)paren
(brace
r_struct
id|evbuf_header
op_star
id|evbuf
suffix:semicolon
r_int
id|unprocessed
suffix:semicolon
id|u16
id|remaining
suffix:semicolon
id|evbuf
op_assign
(paren
r_struct
id|evbuf_header
op_star
)paren
(paren
id|sccb
op_plus
l_int|1
)paren
suffix:semicolon
id|unprocessed
op_assign
l_int|0
suffix:semicolon
id|remaining
op_assign
id|sccb-&gt;length
op_minus
r_sizeof
(paren
r_struct
id|sccb_header
)paren
suffix:semicolon
r_while
c_loop
(paren
id|remaining
OG
l_int|0
)paren
(brace
id|remaining
op_sub_assign
id|evbuf-&gt;length
suffix:semicolon
r_if
c_cond
(paren
id|evbuf-&gt;flags
op_amp
l_int|0x80
)paren
(brace
id|sccb-&gt;length
op_sub_assign
id|evbuf-&gt;length
suffix:semicolon
id|memcpy
c_func
(paren
id|evbuf
comma
(paren
r_void
op_star
)paren
(paren
(paren
id|addr_t
)paren
id|evbuf
op_plus
id|evbuf-&gt;length
)paren
comma
id|remaining
)paren
suffix:semicolon
)brace
r_else
(brace
id|unprocessed
op_increment
suffix:semicolon
id|evbuf
op_assign
(paren
r_struct
id|evbuf_header
op_star
)paren
(paren
(paren
id|addr_t
)paren
id|evbuf
op_plus
id|evbuf-&gt;length
)paren
suffix:semicolon
)brace
)brace
r_return
id|unprocessed
suffix:semicolon
)brace
DECL|variable|sclp_remove_processed
id|EXPORT_SYMBOL
c_func
(paren
id|sclp_remove_processed
)paren
suffix:semicolon
DECL|struct|init_sccb
r_struct
id|init_sccb
(brace
DECL|member|header
r_struct
id|sccb_header
id|header
suffix:semicolon
DECL|member|_reserved
id|u16
id|_reserved
suffix:semicolon
DECL|member|mask_length
id|u16
id|mask_length
suffix:semicolon
DECL|member|receive_mask
id|sccb_mask_t
id|receive_mask
suffix:semicolon
DECL|member|send_mask
id|sccb_mask_t
id|send_mask
suffix:semicolon
DECL|member|sclp_send_mask
id|sccb_mask_t
id|sclp_send_mask
suffix:semicolon
DECL|member|sclp_receive_mask
id|sccb_mask_t
id|sclp_receive_mask
suffix:semicolon
)brace
id|__attribute__
c_func
(paren
(paren
id|packed
)paren
)paren
suffix:semicolon
multiline_comment|/* Prepare init mask request. Called while sclp_lock is locked. */
r_static
r_inline
r_void
DECL|function|__sclp_make_init_req
id|__sclp_make_init_req
c_func
(paren
id|u32
id|receive_mask
comma
id|u32
id|send_mask
)paren
(brace
r_struct
id|init_sccb
op_star
id|sccb
suffix:semicolon
id|sccb
op_assign
(paren
r_struct
id|init_sccb
op_star
)paren
id|sclp_init_sccb
suffix:semicolon
id|clear_page
c_func
(paren
id|sccb
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|sclp_init_req
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sclp_req
)paren
)paren
suffix:semicolon
id|sclp_init_req.command
op_assign
id|SCLP_CMDW_WRITEMASK
suffix:semicolon
id|sclp_init_req.status
op_assign
id|SCLP_REQ_FILLED
suffix:semicolon
id|sclp_init_req.start_count
op_assign
l_int|0
suffix:semicolon
id|sclp_init_req.callback
op_assign
l_int|NULL
suffix:semicolon
id|sclp_init_req.callback_data
op_assign
l_int|NULL
suffix:semicolon
id|sclp_init_req.sccb
op_assign
id|sccb
suffix:semicolon
id|sccb-&gt;header.length
op_assign
r_sizeof
(paren
r_struct
id|init_sccb
)paren
suffix:semicolon
id|sccb-&gt;mask_length
op_assign
r_sizeof
(paren
id|sccb_mask_t
)paren
suffix:semicolon
id|sccb-&gt;receive_mask
op_assign
id|receive_mask
suffix:semicolon
id|sccb-&gt;send_mask
op_assign
id|send_mask
suffix:semicolon
id|sccb-&gt;sclp_receive_mask
op_assign
l_int|0
suffix:semicolon
id|sccb-&gt;sclp_send_mask
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Start init mask request. If calculate is non-zero, calculate the mask as&n; * requested by registered listeners. Use zero mask otherwise. Return 0 on&n; * success, non-zero otherwise. */
r_static
r_int
DECL|function|sclp_init_mask
id|sclp_init_mask
c_func
(paren
r_int
id|calculate
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|init_sccb
op_star
id|sccb
op_assign
(paren
r_struct
id|init_sccb
op_star
)paren
id|sclp_init_sccb
suffix:semicolon
id|sccb_mask_t
id|receive_mask
suffix:semicolon
id|sccb_mask_t
id|send_mask
suffix:semicolon
r_int
id|retry
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_int
r_int
id|wait
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Check if interface is in appropriate state */
r_if
c_cond
(paren
id|sclp_mask_state
op_ne
id|sclp_mask_state_idle
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sclp_activation_state
op_eq
id|sclp_activation_state_inactive
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|sclp_mask_state
op_assign
id|sclp_mask_state_initializing
suffix:semicolon
multiline_comment|/* Determine mask */
r_if
c_cond
(paren
id|calculate
)paren
id|__sclp_get_mask
c_func
(paren
op_amp
id|receive_mask
comma
op_amp
id|send_mask
)paren
suffix:semicolon
r_else
(brace
id|receive_mask
op_assign
l_int|0
suffix:semicolon
id|send_mask
op_assign
l_int|0
suffix:semicolon
)brace
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
r_for
c_loop
(paren
id|retry
op_assign
l_int|0
suffix:semicolon
id|retry
op_le
id|SCLP_MASK_RETRY
suffix:semicolon
id|retry
op_increment
)paren
(brace
multiline_comment|/* Prepare request */
id|__sclp_make_init_req
c_func
(paren
id|receive_mask
comma
id|send_mask
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sclp_add_request
c_func
(paren
op_amp
id|sclp_init_req
)paren
)paren
(brace
multiline_comment|/* Try again later */
id|wait
op_assign
id|jiffies
op_plus
id|SCLP_BUSY_INTERVAL
op_star
id|HZ
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|wait
)paren
)paren
id|sclp_sync_wait
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_while
c_loop
(paren
id|sclp_init_req.status
op_ne
id|SCLP_REQ_DONE
op_logical_and
id|sclp_init_req.status
op_ne
id|SCLP_REQ_FAILED
)paren
id|sclp_sync_wait
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sclp_init_req.status
op_eq
id|SCLP_REQ_DONE
op_logical_and
id|sccb-&gt;header.response_code
op_eq
l_int|0x20
)paren
(brace
multiline_comment|/* Successful request */
r_if
c_cond
(paren
id|calculate
)paren
(brace
id|sclp_receive_mask
op_assign
id|sccb-&gt;sclp_receive_mask
suffix:semicolon
id|sclp_send_mask
op_assign
id|sccb-&gt;sclp_send_mask
suffix:semicolon
)brace
r_else
(brace
id|sclp_receive_mask
op_assign
l_int|0
suffix:semicolon
id|sclp_send_mask
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
id|sclp_dispatch_state_change
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|sclp_mask_state
op_assign
id|sclp_mask_state_idle
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* Deactivate SCLP interface. On success, new requests will be rejected,&n; * events will no longer be dispatched. Return 0 on success, non-zero&n; * otherwise. */
r_int
DECL|function|sclp_deactivate
id|sclp_deactivate
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Deactivate can only be called when active */
r_if
c_cond
(paren
id|sclp_activation_state
op_ne
id|sclp_activation_state_active
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|sclp_activation_state
op_assign
id|sclp_activation_state_deactivating
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
id|rc
op_assign
id|sclp_init_mask
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
id|sclp_activation_state
op_assign
id|sclp_activation_state_inactive
suffix:semicolon
r_else
id|sclp_activation_state
op_assign
id|sclp_activation_state_active
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|variable|sclp_deactivate
id|EXPORT_SYMBOL
c_func
(paren
id|sclp_deactivate
)paren
suffix:semicolon
multiline_comment|/* Reactivate SCLP interface after sclp_deactivate. On success, new&n; * requests will be accepted, events will be dispatched again. Return 0 on&n; * success, non-zero otherwise. */
r_int
DECL|function|sclp_reactivate
id|sclp_reactivate
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Reactivate can only be called when inactive */
r_if
c_cond
(paren
id|sclp_activation_state
op_ne
id|sclp_activation_state_inactive
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|sclp_activation_state
op_assign
id|sclp_activation_state_activating
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
id|rc
op_assign
id|sclp_init_mask
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
id|sclp_activation_state
op_assign
id|sclp_activation_state_active
suffix:semicolon
r_else
id|sclp_activation_state
op_assign
id|sclp_activation_state_inactive
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|variable|sclp_reactivate
id|EXPORT_SYMBOL
c_func
(paren
id|sclp_reactivate
)paren
suffix:semicolon
multiline_comment|/* Handler for external interruption used during initialization. Modify&n; * request state to done. */
r_static
r_void
DECL|function|sclp_check_handler
id|sclp_check_handler
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
id|__u16
id|code
)paren
(brace
id|u32
id|finished_sccb
suffix:semicolon
id|finished_sccb
op_assign
id|S390_lowcore.ext_params
op_amp
l_int|0xfffffff8
suffix:semicolon
multiline_comment|/* Is this the interrupt we are waiting for? */
r_if
c_cond
(paren
id|finished_sccb
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|finished_sccb
op_ne
(paren
id|u32
)paren
(paren
id|addr_t
)paren
id|sclp_init_sccb
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|SCLP_HEADER
l_string|&quot;unsolicited interrupt &quot;
l_string|&quot;for buffer at 0x%x&bslash;n&quot;
comma
id|finished_sccb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|sclp_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sclp_running_state
op_eq
id|sclp_running_state_running
)paren
(brace
id|sclp_init_req.status
op_assign
id|SCLP_REQ_DONE
suffix:semicolon
id|sclp_running_state
op_assign
id|sclp_running_state_idle
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|sclp_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* Initial init mask request timed out. Modify request state to failed. */
r_static
r_void
DECL|function|sclp_check_timeout
id|sclp_check_timeout
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sclp_running_state
op_eq
id|sclp_running_state_running
)paren
(brace
id|sclp_init_req.status
op_assign
id|SCLP_REQ_FAILED
suffix:semicolon
id|sclp_running_state
op_assign
id|sclp_running_state_idle
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Perform a check of the SCLP interface. Return zero if the interface is&n; * available and there are no pending requests from a previous instance.&n; * Return non-zero otherwise. */
r_static
r_int
DECL|function|sclp_check_interface
id|sclp_check_interface
c_func
(paren
r_void
)paren
(brace
r_struct
id|init_sccb
op_star
id|sccb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|retry
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Prepare init mask command */
id|rc
op_assign
id|register_early_external_interrupt
c_func
(paren
l_int|0x2401
comma
id|sclp_check_handler
comma
op_amp
id|ext_int_info_hwc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_for
c_loop
(paren
id|retry
op_assign
l_int|0
suffix:semicolon
id|retry
op_le
id|SCLP_INIT_RETRY
suffix:semicolon
id|retry
op_increment
)paren
(brace
id|__sclp_make_init_req
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|sccb
op_assign
(paren
r_struct
id|init_sccb
op_star
)paren
id|sclp_init_req.sccb
suffix:semicolon
id|rc
op_assign
id|service_call
c_func
(paren
id|sclp_init_req.command
comma
id|sccb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
id|EIO
)paren
r_break
suffix:semicolon
id|sclp_init_req.status
op_assign
id|SCLP_REQ_RUNNING
suffix:semicolon
id|sclp_running_state
op_assign
id|sclp_running_state_running
suffix:semicolon
id|__sclp_set_request_timer
c_func
(paren
id|SCLP_RETRY_INTERVAL
op_star
id|HZ
comma
id|sclp_check_timeout
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Enable service-signal interruption - needs to happen&n;&t;&t; * with IRQs enabled. */
id|ctl_set_bit
c_func
(paren
l_int|0
comma
l_int|9
)paren
suffix:semicolon
multiline_comment|/* Wait for signal from interrupt or timeout */
id|sclp_sync_wait
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Disable service-signal interruption - needs to happen&n;&t;&t; * with IRQs enabled. */
id|ctl_clear_bit
c_func
(paren
l_int|0
comma
l_int|9
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|sclp_request_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sclp_init_req.status
op_eq
id|SCLP_REQ_DONE
op_logical_and
id|sccb-&gt;header.response_code
op_eq
l_int|0x20
)paren
(brace
id|rc
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
id|rc
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
id|unregister_early_external_interrupt
c_func
(paren
l_int|0x2401
comma
id|sclp_check_handler
comma
op_amp
id|ext_int_info_hwc
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* Reboot event handler. Reset send and receive mask to prevent pending SCLP&n; * events from interfering with rebooted system. */
r_static
r_int
DECL|function|sclp_reboot_event
id|sclp_reboot_event
c_func
(paren
r_struct
id|notifier_block
op_star
id|this
comma
r_int
r_int
id|event
comma
r_void
op_star
id|ptr
)paren
(brace
id|sclp_deactivate
c_func
(paren
)paren
suffix:semicolon
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
DECL|variable|sclp_reboot_notifier
r_static
r_struct
id|notifier_block
id|sclp_reboot_notifier
op_assign
(brace
dot
id|notifier_call
op_assign
id|sclp_reboot_event
)brace
suffix:semicolon
multiline_comment|/* Initialize SCLP driver. Return zero if driver is operational, non-zero&n; * otherwise. */
r_static
r_int
DECL|function|sclp_init
id|sclp_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MACHINE_HAS_SCLP
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Check for previous or running initialization */
r_if
c_cond
(paren
id|sclp_init_state
op_ne
id|sclp_init_state_uninitialized
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sclp_init_state
op_assign
id|sclp_init_state_initializing
suffix:semicolon
multiline_comment|/* Set up variables */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sclp_req_queue
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sclp_reg_list
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|sclp_state_change_event.list
comma
op_amp
id|sclp_reg_list
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|sclp_request_timer
)paren
suffix:semicolon
multiline_comment|/* Check interface */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
id|rc
op_assign
id|sclp_check_interface
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|sclp_init_state
op_assign
id|sclp_init_state_uninitialized
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* Register reboot handler */
id|rc
op_assign
id|register_reboot_notifier
c_func
(paren
op_amp
id|sclp_reboot_notifier
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|sclp_init_state
op_assign
id|sclp_init_state_uninitialized
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* Register interrupt handler */
id|rc
op_assign
id|register_early_external_interrupt
c_func
(paren
l_int|0x2401
comma
id|sclp_interrupt_handler
comma
op_amp
id|ext_int_info_hwc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|unregister_reboot_notifier
c_func
(paren
op_amp
id|sclp_reboot_notifier
)paren
suffix:semicolon
id|sclp_init_state
op_assign
id|sclp_init_state_uninitialized
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|sclp_init_state
op_assign
id|sclp_init_state_initialized
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Enable service-signal external interruption - needs to happen with&n;&t; * IRQs enabled. */
id|ctl_set_bit
c_func
(paren
l_int|0
comma
l_int|9
)paren
suffix:semicolon
id|sclp_init_mask
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
