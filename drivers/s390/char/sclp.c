multiline_comment|/*&n; *  drivers/s390/char/sclp.c&n; *     core function to access sclp interface&n; *&n; *  S390 version&n; *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation&n; *    Author(s): Martin Peschke &lt;mpeschke@de.ibm.com&gt;&n; *&t;&t; Martin Schwidefsky &lt;schwidefsky@de.ibm.com&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/err.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/s390_ext.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &quot;sclp.h&quot;
DECL|macro|SCLP_CORE_PRINT_HEADER
mdefine_line|#define SCLP_CORE_PRINT_HEADER &quot;sclp low level driver: &quot;
multiline_comment|/* Structure for register_early_external_interrupt. */
DECL|variable|ext_int_info_hwc
r_static
id|ext_int_info_t
id|ext_int_info_hwc
suffix:semicolon
multiline_comment|/* spinlock to protect global variables of sclp_core */
DECL|variable|sclp_lock
r_static
id|spinlock_t
id|sclp_lock
suffix:semicolon
multiline_comment|/* Mask of valid sclp events */
DECL|variable|sclp_receive_mask
r_static
id|sccb_mask_t
id|sclp_receive_mask
suffix:semicolon
DECL|variable|sclp_send_mask
r_static
id|sccb_mask_t
id|sclp_send_mask
suffix:semicolon
multiline_comment|/* List of registered event types */
DECL|variable|sclp_reg_list
r_static
r_struct
id|list_head
id|sclp_reg_list
suffix:semicolon
multiline_comment|/* sccb queue */
DECL|variable|sclp_req_queue
r_static
r_struct
id|list_head
id|sclp_req_queue
suffix:semicolon
multiline_comment|/* sccb for unconditional read */
DECL|variable|sclp_read_req
r_static
r_struct
id|sclp_req
id|sclp_read_req
suffix:semicolon
DECL|variable|sclp_read_sccb
r_static
r_char
id|sclp_read_sccb
(braket
id|PAGE_SIZE
)braket
id|__attribute__
c_func
(paren
(paren
id|__aligned__
c_func
(paren
id|PAGE_SIZE
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* sccb for write mask sccb */
DECL|variable|sclp_init_sccb
r_static
r_char
id|sclp_init_sccb
(braket
id|PAGE_SIZE
)braket
id|__attribute__
c_func
(paren
(paren
id|__aligned__
c_func
(paren
id|PAGE_SIZE
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Timer for init mask retries. */
DECL|variable|retry_timer
r_static
r_struct
id|timer_list
id|retry_timer
suffix:semicolon
DECL|variable|sclp_status
r_static
r_volatile
r_int
r_int
id|sclp_status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* some status flags */
DECL|macro|SCLP_INIT
mdefine_line|#define SCLP_INIT&t;&t;0
DECL|macro|SCLP_RUNNING
mdefine_line|#define SCLP_RUNNING&t;&t;1
DECL|macro|SCLP_READING
mdefine_line|#define SCLP_READING&t;&t;2
DECL|macro|SCLP_INIT_POLL_INTERVAL
mdefine_line|#define SCLP_INIT_POLL_INTERVAL&t;1
DECL|macro|SCLP_COMMAND_INITIATED
mdefine_line|#define SCLP_COMMAND_INITIATED&t;0
DECL|macro|SCLP_BUSY
mdefine_line|#define SCLP_BUSY&t;&t;2
DECL|macro|SCLP_NOT_OPERATIONAL
mdefine_line|#define SCLP_NOT_OPERATIONAL&t;3
multiline_comment|/*&n; * assembler instruction for Service Call&n; */
r_static
r_int
DECL|function|__service_call
id|__service_call
c_func
(paren
id|sclp_cmdw_t
id|command
comma
r_void
op_star
id|sccb
)paren
(brace
r_int
id|cc
suffix:semicolon
multiline_comment|/*&n;&t; *  Mnemonic:&t;SERVC&t;Rx, Ry&t;[RRE]&n;&t; *&n;&t; *  Rx: SCLP command word&n;&t; *  Ry: address of SCCB&n;&t; */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;   .insn rre,0xb2200000,%1,%2&bslash;n&quot;
multiline_comment|/* servc %1,%2 */
l_string|&quot;   ipm&t;  %0&bslash;n&quot;
l_string|&quot;   srl&t;  %0,28&quot;
suffix:colon
l_string|&quot;=&amp;d&quot;
(paren
id|cc
)paren
suffix:colon
l_string|&quot;d&quot;
(paren
id|command
)paren
comma
l_string|&quot;a&quot;
(paren
id|__pa
c_func
(paren
id|sccb
)paren
)paren
suffix:colon
l_string|&quot;cc&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * cc == 0:   Service Call succesful initiated&n;&t; * cc == 2:   SCLP busy, new Service Call not initiated,&n;&t; *&t;      new SCCB unchanged&n;&t; * cc == 3:   SCLP function not operational&n;&t; */
r_if
c_cond
(paren
id|cc
op_eq
id|SCLP_NOT_OPERATIONAL
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/*&n;&t; * We set the SCLP_RUNNING bit for cc 2 as well because if&n;&t; * service_call returns cc 2 some old request is running&n;&t; * that has to complete first&n;&t; */
id|set_bit
c_func
(paren
id|SCLP_RUNNING
comma
op_amp
id|sclp_status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cc
op_eq
id|SCLP_BUSY
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|sclp_start_request
id|sclp_start_request
c_func
(paren
r_void
)paren
(brace
r_struct
id|sclp_req
op_star
id|req
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* quick exit if sclp is already in use */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SCLP_RUNNING
comma
op_amp
id|sclp_status
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Get first request on queue if available */
id|req
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|sclp_req_queue
)paren
)paren
id|req
op_assign
id|list_entry
c_func
(paren
id|sclp_req_queue.next
comma
r_struct
id|sclp_req
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
id|rc
op_assign
id|__service_call
c_func
(paren
id|req-&gt;command
comma
id|req-&gt;sccb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|req-&gt;status
op_assign
id|SCLP_REQ_FAILED
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|req-&gt;list
)paren
suffix:semicolon
)brace
r_else
id|req-&gt;status
op_assign
id|SCLP_REQ_RUNNING
suffix:semicolon
)brace
r_else
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
id|EIO
op_logical_and
id|req-&gt;callback
op_ne
l_int|NULL
)paren
id|req
op_member_access_from_pointer
id|callback
c_func
(paren
id|req
comma
id|req-&gt;callback_data
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_static
r_int
DECL|function|sclp_process_evbufs
id|sclp_process_evbufs
c_func
(paren
r_struct
id|sccb_header
op_star
id|sccb
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|evbuf_header
op_star
id|evbuf
suffix:semicolon
r_struct
id|list_head
op_star
id|l
suffix:semicolon
r_struct
id|sclp_register
op_star
id|t
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
id|evbuf
op_assign
(paren
r_struct
id|evbuf_header
op_star
)paren
(paren
id|sccb
op_plus
l_int|1
)paren
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|addr_t
)paren
id|evbuf
OL
(paren
id|addr_t
)paren
id|sccb
op_plus
id|sccb-&gt;length
)paren
(brace
multiline_comment|/* check registered event */
id|t
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|sclp_reg_list
)paren
(brace
id|t
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|sclp_register
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;receive_mask
op_amp
(paren
l_int|1
op_lshift
(paren
l_int|32
op_minus
id|evbuf-&gt;type
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|t-&gt;receiver_fn
op_ne
l_int|NULL
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
id|t
op_member_access_from_pointer
id|receiver_fn
c_func
(paren
id|evbuf
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_else
id|t
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Check for unrequested event buffer */
r_if
c_cond
(paren
id|t
op_eq
l_int|NULL
)paren
id|result
op_assign
op_minus
id|ENOSYS
suffix:semicolon
id|evbuf
op_assign
(paren
r_struct
id|evbuf_header
op_star
)paren
(paren
(paren
id|addr_t
)paren
id|evbuf
op_plus
id|evbuf-&gt;length
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_char
op_star
DECL|function|sclp_error_message
id|sclp_error_message
c_func
(paren
id|u16
id|rc
)paren
(brace
r_static
r_struct
(brace
id|u16
id|code
suffix:semicolon
r_char
op_star
id|msg
suffix:semicolon
)brace
id|sclp_errors
(braket
)braket
op_assign
(brace
(brace
l_int|0x0000
comma
l_string|&quot;No response code stored (machine malfunction)&quot;
)brace
comma
(brace
l_int|0x0020
comma
l_string|&quot;Normal Completion&quot;
)brace
comma
(brace
l_int|0x0040
comma
l_string|&quot;SCLP equipment check&quot;
)brace
comma
(brace
l_int|0x0100
comma
l_string|&quot;SCCB boundary violation&quot;
)brace
comma
(brace
l_int|0x01f0
comma
l_string|&quot;Invalid command&quot;
)brace
comma
(brace
l_int|0x0220
comma
l_string|&quot;Normal Completion; suppressed buffers pending&quot;
)brace
comma
(brace
l_int|0x0300
comma
l_string|&quot;Insufficient SCCB length&quot;
)brace
comma
(brace
l_int|0x0340
comma
l_string|&quot;Contained SCLP equipment check&quot;
)brace
comma
(brace
l_int|0x05f0
comma
l_string|&quot;Target resource in improper state&quot;
)brace
comma
(brace
l_int|0x40f0
comma
l_string|&quot;Invalid function code/not installed&quot;
)brace
comma
(brace
l_int|0x60f0
comma
l_string|&quot;No buffers stored&quot;
)brace
comma
(brace
l_int|0x62f0
comma
l_string|&quot;No buffers stored; suppressed buffers pending&quot;
)brace
comma
(brace
l_int|0x70f0
comma
l_string|&quot;Invalid selection mask&quot;
)brace
comma
(brace
l_int|0x71f0
comma
l_string|&quot;Event buffer exceeds available space&quot;
)brace
comma
(brace
l_int|0x72f0
comma
l_string|&quot;Inconsistent lengths&quot;
)brace
comma
(brace
l_int|0x73f0
comma
l_string|&quot;Event buffer syntax error&quot;
)brace
)brace
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|sclp_errors
)paren
op_div
r_sizeof
(paren
id|sclp_errors
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|rc
op_eq
id|sclp_errors
(braket
id|i
)braket
dot
id|code
)paren
r_return
id|sclp_errors
(braket
id|i
)braket
dot
id|msg
suffix:semicolon
r_return
l_string|&quot;Invalid response code&quot;
suffix:semicolon
)brace
multiline_comment|/*&n; * postprocessing of unconditional read service call&n; */
r_static
r_void
DECL|function|sclp_unconditional_read_cb
id|sclp_unconditional_read_cb
c_func
(paren
r_struct
id|sclp_req
op_star
id|read_req
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|sccb_header
op_star
id|sccb
suffix:semicolon
id|sccb
op_assign
id|read_req-&gt;sccb
suffix:semicolon
r_if
c_cond
(paren
id|sccb-&gt;response_code
op_eq
l_int|0x0020
op_logical_or
id|sccb-&gt;response_code
op_eq
l_int|0x0220
)paren
(brace
r_if
c_cond
(paren
id|sclp_process_evbufs
c_func
(paren
id|sccb
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_WARNING
id|SCLP_CORE_PRINT_HEADER
l_string|&quot;unconditional read: &quot;
l_string|&quot;unrequested event buffer received.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sccb-&gt;response_code
op_ne
l_int|0x0020
)paren
id|printk
c_func
(paren
id|KERN_WARNING
id|SCLP_CORE_PRINT_HEADER
l_string|&quot;unconditional read: %s (response code=0x%x).&bslash;n&quot;
comma
id|sclp_error_message
c_func
(paren
id|sccb-&gt;response_code
)paren
comma
id|sccb-&gt;response_code
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|SCLP_READING
comma
op_amp
id|sclp_status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function to queue Read Event Data/Unconditional Read&n; */
r_static
r_void
DECL|function|__sclp_unconditional_read
id|__sclp_unconditional_read
c_func
(paren
r_void
)paren
(brace
r_struct
id|sccb_header
op_star
id|sccb
suffix:semicolon
r_struct
id|sclp_req
op_star
id|read_req
suffix:semicolon
multiline_comment|/*&n;&t; * Don&squot;t try to initiate Unconditional Read if we are not able to&n;&t; * receive anything&n;&t; */
r_if
c_cond
(paren
id|sclp_receive_mask
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* Don&squot;t try reading if a read is already outstanding */
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|SCLP_READING
comma
op_amp
id|sclp_status
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Initialize read sccb */
id|sccb
op_assign
(paren
r_struct
id|sccb_header
op_star
)paren
id|sclp_read_sccb
suffix:semicolon
id|clear_page
c_func
(paren
id|sccb
)paren
suffix:semicolon
id|sccb-&gt;length
op_assign
id|PAGE_SIZE
suffix:semicolon
id|sccb-&gt;function_code
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* unconditional read */
id|sccb-&gt;control_mask
(braket
l_int|2
)braket
op_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* variable length response */
multiline_comment|/* Initialize request structure */
id|read_req
op_assign
op_amp
id|sclp_read_req
suffix:semicolon
id|read_req-&gt;command
op_assign
id|SCLP_CMDW_READDATA
suffix:semicolon
id|read_req-&gt;status
op_assign
id|SCLP_REQ_QUEUED
suffix:semicolon
id|read_req-&gt;callback
op_assign
id|sclp_unconditional_read_cb
suffix:semicolon
id|read_req-&gt;sccb
op_assign
id|sccb
suffix:semicolon
multiline_comment|/* Add read request to the head of queue */
id|list_add
c_func
(paren
op_amp
id|read_req-&gt;list
comma
op_amp
id|sclp_req_queue
)paren
suffix:semicolon
)brace
multiline_comment|/* Bit masks to interpret external interruption parameter contents. */
DECL|macro|EXT_INT_SCCB_MASK
mdefine_line|#define EXT_INT_SCCB_MASK&t;&t;0xfffffff8
DECL|macro|EXT_INT_STATECHANGE_PENDING
mdefine_line|#define EXT_INT_STATECHANGE_PENDING&t;0x00000002
DECL|macro|EXT_INT_EVBUF_PENDING
mdefine_line|#define EXT_INT_EVBUF_PENDING&t;&t;0x00000001
multiline_comment|/*&n; * Handler for service-signal external interruptions&n; */
r_static
r_void
DECL|function|sclp_interrupt_handler
id|sclp_interrupt_handler
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
id|__u16
id|code
)paren
(brace
id|u32
id|ext_int_param
comma
id|finished_sccb
comma
id|evbuf_pending
suffix:semicolon
r_struct
id|list_head
op_star
id|l
suffix:semicolon
r_struct
id|sclp_req
op_star
id|req
comma
op_star
id|tmp
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sclp_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Only process interrupt if sclp is initialized.&n;&t; * This avoids strange effects for a pending request&n;&t; * from before the last re-ipl.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|SCLP_INIT
comma
op_amp
id|sclp_status
)paren
)paren
(brace
multiline_comment|/* Now clear the running bit */
id|clear_bit
c_func
(paren
id|SCLP_RUNNING
comma
op_amp
id|sclp_status
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|sclp_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ext_int_param
op_assign
id|S390_lowcore.ext_params
suffix:semicolon
id|finished_sccb
op_assign
id|ext_int_param
op_amp
id|EXT_INT_SCCB_MASK
suffix:semicolon
id|evbuf_pending
op_assign
id|ext_int_param
op_amp
(paren
id|EXT_INT_EVBUF_PENDING
op_or
id|EXT_INT_STATECHANGE_PENDING
)paren
suffix:semicolon
id|req
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|finished_sccb
op_ne
l_int|0U
)paren
(brace
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|sclp_req_queue
)paren
(brace
id|tmp
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|sclp_req
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|finished_sccb
op_eq
(paren
id|u32
)paren
(paren
id|addr_t
)paren
id|tmp-&gt;sccb
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|tmp-&gt;list
)paren
suffix:semicolon
id|req
op_assign
id|tmp
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|sclp_lock
)paren
suffix:semicolon
multiline_comment|/* Perform callback */
r_if
c_cond
(paren
id|req
op_ne
l_int|NULL
)paren
(brace
id|req-&gt;status
op_assign
id|SCLP_REQ_DONE
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;callback
op_ne
l_int|NULL
)paren
id|req
op_member_access_from_pointer
id|callback
c_func
(paren
id|req
comma
id|req-&gt;callback_data
)paren
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|sclp_lock
)paren
suffix:semicolon
multiline_comment|/* Head queue a read sccb if an event buffer is pending */
r_if
c_cond
(paren
id|evbuf_pending
)paren
id|__sclp_unconditional_read
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Now clear the running bit if SCLP indicated a finished SCCB */
r_if
c_cond
(paren
id|finished_sccb
op_ne
l_int|0U
)paren
id|clear_bit
c_func
(paren
id|SCLP_RUNNING
comma
op_amp
id|sclp_status
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|sclp_lock
)paren
suffix:semicolon
multiline_comment|/* and start next request on the queue */
id|sclp_start_request
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait synchronously for external interrupt of sclp. We may not receive&n; * any other external interrupt, so we disable all other external interrupts&n; * in control register 0.&n; */
r_void
DECL|function|sclp_sync_wait
id|sclp_sync_wait
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|psw_mask
suffix:semicolon
r_int
r_int
id|cr0
comma
id|cr0_sync
suffix:semicolon
multiline_comment|/*&n;&t; * save cr0&n;&t; * enable service signal external interruption (cr0.22)&n;&t; * disable cr0.20-21, cr0.25, cr0.27, cr0.30-31&n;&t; * don&squot;t touch any other bit in cr0&n;&t; */
id|__ctl_store
c_func
(paren
id|cr0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|cr0_sync
op_assign
id|cr0
suffix:semicolon
id|cr0_sync
op_or_assign
l_int|0x00000200
suffix:semicolon
id|cr0_sync
op_and_assign
l_int|0xFFFFF3AC
suffix:semicolon
id|__ctl_load
c_func
(paren
id|cr0_sync
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* enable external interruptions (PSW-mask.7) */
id|asm
r_volatile
(paren
l_string|&quot;STOSM 0(%1),0x01&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|psw_mask
)paren
suffix:colon
l_string|&quot;a&quot;
(paren
op_amp
id|psw_mask
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/* wait until ISR signals receipt of interrupt */
r_while
c_loop
(paren
id|test_bit
c_func
(paren
id|SCLP_RUNNING
comma
op_amp
id|sclp_status
)paren
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* disable external interruptions */
id|asm
r_volatile
(paren
l_string|&quot;SSM 0(%0)&quot;
suffix:colon
suffix:colon
l_string|&quot;a&quot;
(paren
op_amp
id|psw_mask
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/* restore cr0 */
id|__ctl_load
c_func
(paren
id|cr0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Queue an SCLP request. Request will immediately be processed if queue is&n; * empty.&n; */
r_void
DECL|function|sclp_add_request
id|sclp_add_request
c_func
(paren
r_struct
id|sclp_req
op_star
id|req
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|SCLP_INIT
comma
op_amp
id|sclp_status
)paren
)paren
(brace
id|req-&gt;status
op_assign
id|SCLP_REQ_FAILED
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;callback
op_ne
l_int|NULL
)paren
id|req
op_member_access_from_pointer
id|callback
c_func
(paren
id|req
comma
id|req-&gt;callback_data
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* queue the request */
id|req-&gt;status
op_assign
id|SCLP_REQ_QUEUED
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|req-&gt;list
comma
op_amp
id|sclp_req_queue
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* try to start the first request on the queue */
id|sclp_start_request
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* state change notification */
DECL|struct|sclp_statechangebuf
r_struct
id|sclp_statechangebuf
(brace
DECL|member|header
r_struct
id|evbuf_header
id|header
suffix:semicolon
DECL|member|validity_sclp_active_facility_mask
id|u8
id|validity_sclp_active_facility_mask
suffix:colon
l_int|1
suffix:semicolon
DECL|member|validity_sclp_receive_mask
id|u8
id|validity_sclp_receive_mask
suffix:colon
l_int|1
suffix:semicolon
DECL|member|validity_sclp_send_mask
id|u8
id|validity_sclp_send_mask
suffix:colon
l_int|1
suffix:semicolon
DECL|member|validity_read_data_function_mask
id|u8
id|validity_read_data_function_mask
suffix:colon
l_int|1
suffix:semicolon
DECL|member|_zeros
id|u16
id|_zeros
suffix:colon
l_int|12
suffix:semicolon
DECL|member|mask_length
id|u16
id|mask_length
suffix:semicolon
DECL|member|sclp_active_facility_mask
id|u64
id|sclp_active_facility_mask
suffix:semicolon
DECL|member|sclp_receive_mask
id|sccb_mask_t
id|sclp_receive_mask
suffix:semicolon
DECL|member|sclp_send_mask
id|sccb_mask_t
id|sclp_send_mask
suffix:semicolon
DECL|member|read_data_function_mask
id|u32
id|read_data_function_mask
suffix:semicolon
)brace
id|__attribute__
c_func
(paren
(paren
id|packed
)paren
)paren
suffix:semicolon
r_static
r_inline
r_void
DECL|function|__sclp_notify_state_change
id|__sclp_notify_state_change
c_func
(paren
r_void
)paren
(brace
r_struct
id|list_head
op_star
id|l
suffix:semicolon
r_struct
id|sclp_register
op_star
id|t
suffix:semicolon
id|sccb_mask_t
id|receive_mask
comma
id|send_mask
suffix:semicolon
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|sclp_reg_list
)paren
(brace
id|t
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|sclp_register
comma
id|list
)paren
suffix:semicolon
id|receive_mask
op_assign
id|t-&gt;receive_mask
op_amp
id|sclp_receive_mask
suffix:semicolon
id|send_mask
op_assign
id|t-&gt;send_mask
op_amp
id|sclp_send_mask
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;sclp_receive_mask
op_ne
id|receive_mask
op_logical_or
id|t-&gt;sclp_send_mask
op_ne
id|send_mask
)paren
(brace
id|t-&gt;sclp_receive_mask
op_assign
id|receive_mask
suffix:semicolon
id|t-&gt;sclp_send_mask
op_assign
id|send_mask
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;state_change_fn
op_ne
l_int|NULL
)paren
id|t
op_member_access_from_pointer
id|state_change_fn
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_void
DECL|function|sclp_state_change
id|sclp_state_change
c_func
(paren
r_struct
id|evbuf_header
op_star
id|evbuf
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sclp_statechangebuf
op_star
id|scbuf
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
id|scbuf
op_assign
(paren
r_struct
id|sclp_statechangebuf
op_star
)paren
id|evbuf
suffix:semicolon
r_if
c_cond
(paren
id|scbuf-&gt;validity_sclp_receive_mask
)paren
(brace
r_if
c_cond
(paren
id|scbuf-&gt;mask_length
op_ne
r_sizeof
(paren
id|sccb_mask_t
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
id|SCLP_CORE_PRINT_HEADER
l_string|&quot;state change event with mask length %i&bslash;n&quot;
comma
id|scbuf-&gt;mask_length
)paren
suffix:semicolon
r_else
multiline_comment|/* set new receive mask */
id|sclp_receive_mask
op_assign
id|scbuf-&gt;sclp_receive_mask
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scbuf-&gt;validity_sclp_send_mask
)paren
(brace
r_if
c_cond
(paren
id|scbuf-&gt;mask_length
op_ne
r_sizeof
(paren
id|sccb_mask_t
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
id|SCLP_CORE_PRINT_HEADER
l_string|&quot;state change event with mask length %i&bslash;n&quot;
comma
id|scbuf-&gt;mask_length
)paren
suffix:semicolon
r_else
multiline_comment|/* set new send mask */
id|sclp_send_mask
op_assign
id|scbuf-&gt;sclp_send_mask
suffix:semicolon
)brace
id|__sclp_notify_state_change
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|sclp_state_change_event
r_static
r_struct
id|sclp_register
id|sclp_state_change_event
op_assign
(brace
dot
id|receive_mask
op_assign
id|EvTyp_StateChange_Mask
comma
dot
id|receiver_fn
op_assign
id|sclp_state_change
)brace
suffix:semicolon
multiline_comment|/*&n; * SCLP quiesce event handler&n; */
macro_line|#ifdef CONFIG_SMP
DECL|variable|cpu_quiesce_map
r_static
id|cpumask_t
id|cpu_quiesce_map
suffix:semicolon
r_static
r_void
DECL|function|do_load_quiesce_psw
id|do_load_quiesce_psw
c_func
(paren
r_void
op_star
id|__unused
)paren
(brace
id|psw_t
id|quiesce_psw
suffix:semicolon
id|cpu_clear
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
comma
id|cpu_quiesce_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smp_processor_id
c_func
(paren
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Wait for all other cpus to enter do_load_quiesce_psw */
r_while
c_loop
(paren
op_logical_neg
id|cpus_empty
c_func
(paren
id|cpu_quiesce_map
)paren
)paren
suffix:semicolon
multiline_comment|/* Quiesce the last cpu with the special psw */
id|quiesce_psw.mask
op_assign
id|PSW_BASE_BITS
op_or
id|PSW_MASK_WAIT
suffix:semicolon
id|quiesce_psw.addr
op_assign
l_int|0xfff
suffix:semicolon
id|__load_psw
c_func
(paren
id|quiesce_psw
)paren
suffix:semicolon
)brace
id|signal_processor
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
comma
id|sigp_stop
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|do_machine_quiesce
id|do_machine_quiesce
c_func
(paren
r_void
)paren
(brace
id|cpu_quiesce_map
op_assign
id|cpu_online_map
suffix:semicolon
id|on_each_cpu
c_func
(paren
id|do_load_quiesce_psw
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#else
r_static
r_void
DECL|function|do_machine_quiesce
id|do_machine_quiesce
c_func
(paren
r_void
)paren
(brace
id|psw_t
id|quiesce_psw
suffix:semicolon
id|quiesce_psw.mask
op_assign
id|PSW_BASE_BITS
op_or
id|PSW_MASK_WAIT
suffix:semicolon
id|quiesce_psw.addr
op_assign
l_int|0xfff
suffix:semicolon
id|__load_psw
c_func
(paren
id|quiesce_psw
)paren
suffix:semicolon
)brace
macro_line|#endif
r_extern
r_void
id|ctrl_alt_del
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
DECL|function|sclp_quiesce
id|sclp_quiesce
c_func
(paren
r_struct
id|evbuf_header
op_star
id|evbuf
)paren
(brace
multiline_comment|/*&n;&t; * We got a &quot;shutdown&quot; request.&n;&t; * Add a call to an appropriate &quot;shutdown&quot; routine here. This&n;&t; * routine should set all PSWs to &squot;disabled-wait&squot;, &squot;stopped&squot;&n;&t; * or &squot;check-stopped&squot; - except 1 PSW which needs to carry a&n;&t; * special bit pattern called &squot;quiesce PSW&squot;.&n;&t; */
id|_machine_restart
op_assign
(paren
r_void
op_star
)paren
id|do_machine_quiesce
suffix:semicolon
id|_machine_halt
op_assign
id|do_machine_quiesce
suffix:semicolon
id|_machine_power_off
op_assign
id|do_machine_quiesce
suffix:semicolon
id|ctrl_alt_del
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|sclp_quiesce_event
r_static
r_struct
id|sclp_register
id|sclp_quiesce_event
op_assign
(brace
dot
id|receive_mask
op_assign
id|EvTyp_SigQuiesce_Mask
comma
dot
id|receiver_fn
op_assign
id|sclp_quiesce
)brace
suffix:semicolon
multiline_comment|/* initialisation of SCLP */
DECL|struct|init_sccb
r_struct
id|init_sccb
(brace
DECL|member|header
r_struct
id|sccb_header
id|header
suffix:semicolon
DECL|member|_reserved
id|u16
id|_reserved
suffix:semicolon
DECL|member|mask_length
id|u16
id|mask_length
suffix:semicolon
DECL|member|receive_mask
id|sccb_mask_t
id|receive_mask
suffix:semicolon
DECL|member|send_mask
id|sccb_mask_t
id|send_mask
suffix:semicolon
DECL|member|sclp_send_mask
id|sccb_mask_t
id|sclp_send_mask
suffix:semicolon
DECL|member|sclp_receive_mask
id|sccb_mask_t
id|sclp_receive_mask
suffix:semicolon
)brace
id|__attribute__
c_func
(paren
(paren
id|packed
)paren
)paren
suffix:semicolon
r_static
r_void
id|sclp_init_mask_retry
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_int
DECL|function|sclp_init_mask
id|sclp_init_mask
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|init_sccb
op_star
id|sccb
suffix:semicolon
r_struct
id|sclp_req
op_star
id|req
suffix:semicolon
r_struct
id|list_head
op_star
id|l
suffix:semicolon
r_struct
id|sclp_register
op_star
id|t
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|sccb
op_assign
(paren
r_struct
id|init_sccb
op_star
)paren
id|sclp_init_sccb
suffix:semicolon
multiline_comment|/* stick the request structure to the end of the init sccb page */
id|req
op_assign
(paren
r_struct
id|sclp_req
op_star
)paren
(paren
(paren
id|addr_t
)paren
id|sccb
op_plus
id|PAGE_SIZE
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* SCLP setup concerning receiving and sending Event Buffers */
id|req-&gt;command
op_assign
id|SCLP_CMDW_WRITEMASK
suffix:semicolon
id|req-&gt;status
op_assign
id|SCLP_REQ_QUEUED
suffix:semicolon
id|req-&gt;callback
op_assign
l_int|NULL
suffix:semicolon
id|req-&gt;sccb
op_assign
id|sccb
suffix:semicolon
multiline_comment|/* setup sccb for writemask command */
id|memset
c_func
(paren
id|sccb
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|init_sccb
)paren
)paren
suffix:semicolon
id|sccb-&gt;header.length
op_assign
r_sizeof
(paren
r_struct
id|init_sccb
)paren
suffix:semicolon
id|sccb-&gt;mask_length
op_assign
r_sizeof
(paren
id|sccb_mask_t
)paren
suffix:semicolon
multiline_comment|/* copy in the sccb mask of the registered event types */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|sclp_reg_list
)paren
(brace
id|t
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|sclp_register
comma
id|list
)paren
suffix:semicolon
id|sccb-&gt;receive_mask
op_or_assign
id|t-&gt;receive_mask
suffix:semicolon
id|sccb-&gt;send_mask
op_or_assign
id|t-&gt;send_mask
suffix:semicolon
)brace
id|sccb-&gt;sclp_receive_mask
op_assign
l_int|0
suffix:semicolon
id|sccb-&gt;sclp_send_mask
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SCLP_INIT
comma
op_amp
id|sclp_status
)paren
)paren
(brace
multiline_comment|/* add request to sclp queue */
id|list_add_tail
c_func
(paren
op_amp
id|req-&gt;list
comma
op_amp
id|sclp_req_queue
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* and start if SCLP is idle */
id|sclp_start_request
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* now wait for completion */
r_while
c_loop
(paren
id|req-&gt;status
op_ne
id|SCLP_REQ_DONE
op_logical_and
id|req-&gt;status
op_ne
id|SCLP_REQ_FAILED
)paren
id|sclp_sync_wait
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Special case for the very first write mask command.&n;&t;&t; * The interrupt handler is not removing request from&n;&t;&t; * the request queue and doesn&squot;t call callbacks yet&n;&t;&t; * because there might be an pending old interrupt&n;&t;&t; * after a Re-IPL. We have to receive and ignore it.&n;&t;&t; */
r_do
(brace
id|rc
op_assign
id|__service_call
c_func
(paren
id|req-&gt;command
comma
id|req-&gt;sccb
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
id|EIO
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
id|sclp_sync_wait
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|rc
op_eq
op_minus
id|EBUSY
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sccb-&gt;header.response_code
op_ne
l_int|0x0020
)paren
(brace
multiline_comment|/* WRITEMASK failed - we cannot rely on receiving a state&n;&t;&t;   change event, so initially, polling is the only alternative&n;&t;&t;   for us to ever become operational. */
r_if
c_cond
(paren
op_logical_neg
id|timer_pending
c_func
(paren
op_amp
id|retry_timer
)paren
op_logical_or
op_logical_neg
id|mod_timer
c_func
(paren
op_amp
id|retry_timer
comma
id|jiffies
op_plus
id|SCLP_INIT_POLL_INTERVAL
op_star
id|HZ
)paren
)paren
(brace
id|retry_timer.function
op_assign
id|sclp_init_mask_retry
suffix:semicolon
id|retry_timer.data
op_assign
l_int|0
suffix:semicolon
id|retry_timer.expires
op_assign
id|jiffies
op_plus
id|SCLP_INIT_POLL_INTERVAL
op_star
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|retry_timer
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|sclp_receive_mask
op_assign
id|sccb-&gt;sclp_receive_mask
suffix:semicolon
id|sclp_send_mask
op_assign
id|sccb-&gt;sclp_send_mask
suffix:semicolon
id|__sclp_notify_state_change
c_func
(paren
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|sclp_init_mask_retry
id|sclp_init_mask_retry
c_func
(paren
r_int
r_int
id|data
)paren
(brace
id|sclp_init_mask
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sclp setup function. Called early (no kmalloc!) from sclp_console_init().&n; */
r_static
r_int
DECL|function|sclp_init
id|sclp_init
c_func
(paren
r_void
)paren
(brace
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SCLP_INIT
comma
op_amp
id|sclp_status
)paren
)paren
multiline_comment|/* Already initialized. */
r_return
l_int|0
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|sclp_lock
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sclp_req_queue
)paren
suffix:semicolon
multiline_comment|/* init event list */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sclp_reg_list
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|sclp_state_change_event.list
comma
op_amp
id|sclp_reg_list
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|sclp_quiesce_event.list
comma
op_amp
id|sclp_reg_list
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * request the 0x2401 external interrupt&n;&t; * The sclp driver is initialized early (before kmalloc works). We&n;&t; * need to use register_early_external_interrupt.&n;&t; */
r_if
c_cond
(paren
id|register_early_external_interrupt
c_func
(paren
l_int|0x2401
comma
id|sclp_interrupt_handler
comma
op_amp
id|ext_int_info_hwc
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* enable service-signal external interruptions,&n;&t; * Control Register 0 bit 22 := 1&n;&t; * (besides PSW bit 7 must be set to 1 sometimes for external&n;&t; * interruptions)&n;&t; */
id|ctl_set_bit
c_func
(paren
l_int|0
comma
l_int|9
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|retry_timer
)paren
suffix:semicolon
multiline_comment|/* do the initial write event mask */
id|rc
op_assign
id|sclp_init_mask
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Ok, now everything is setup right. */
id|set_bit
c_func
(paren
id|SCLP_INIT
comma
op_amp
id|sclp_status
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* The sclp_init_mask failed. SCLP is broken, unregister and exit. */
id|ctl_clear_bit
c_func
(paren
l_int|0
comma
l_int|9
)paren
suffix:semicolon
id|unregister_early_external_interrupt
c_func
(paren
l_int|0x2401
comma
id|sclp_interrupt_handler
comma
op_amp
id|ext_int_info_hwc
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Register the SCLP event listener identified by REG. Return 0 on success.&n; * Some error codes and their meaning:&n; *&n; *  -ENODEV = SCLP interface is not supported on this machine&n; *   -EBUSY = there is already a listener registered for the requested&n; *            event type&n; *     -EIO = SCLP interface is currently not operational&n; */
r_int
DECL|function|sclp_register
id|sclp_register
c_func
(paren
r_struct
id|sclp_register
op_star
id|reg
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|list_head
op_star
id|l
suffix:semicolon
r_struct
id|sclp_register
op_star
id|t
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MACHINE_HAS_SCLP
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|SCLP_INIT
comma
op_amp
id|sclp_status
)paren
)paren
id|sclp_init
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* check already registered event masks for collisions */
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|sclp_reg_list
)paren
(brace
id|t
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|sclp_register
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t-&gt;receive_mask
op_amp
id|reg-&gt;receive_mask
op_logical_or
id|t-&gt;send_mask
op_amp
id|reg-&gt;send_mask
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * set present mask to 0 to trigger state change&n;&t; * callback in sclp_init_mask&n;&t; */
id|reg-&gt;sclp_receive_mask
op_assign
l_int|0
suffix:semicolon
id|reg-&gt;sclp_send_mask
op_assign
l_int|0
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|reg-&gt;list
comma
op_amp
id|sclp_reg_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
id|sclp_init_mask
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Unregister the SCLP event listener identified by REG.&n; */
r_void
DECL|function|sclp_unregister
id|sclp_unregister
c_func
(paren
r_struct
id|sclp_register
op_star
id|reg
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|reg-&gt;list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_lock
comma
id|flags
)paren
suffix:semicolon
id|sclp_init_mask
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|macro|SCLP_EVBUF_PROCESSED
mdefine_line|#define&t;SCLP_EVBUF_PROCESSED&t;0x80
multiline_comment|/*&n; * Traverse array of event buffers contained in SCCB and remove all buffers&n; * with a set &quot;processed&quot; flag. Return the number of unprocessed buffers.&n; */
r_int
DECL|function|sclp_remove_processed
id|sclp_remove_processed
c_func
(paren
r_struct
id|sccb_header
op_star
id|sccb
)paren
(brace
r_struct
id|evbuf_header
op_star
id|evbuf
suffix:semicolon
r_int
id|unprocessed
suffix:semicolon
id|u16
id|remaining
suffix:semicolon
id|evbuf
op_assign
(paren
r_struct
id|evbuf_header
op_star
)paren
(paren
id|sccb
op_plus
l_int|1
)paren
suffix:semicolon
id|unprocessed
op_assign
l_int|0
suffix:semicolon
id|remaining
op_assign
id|sccb-&gt;length
op_minus
r_sizeof
(paren
r_struct
id|sccb_header
)paren
suffix:semicolon
r_while
c_loop
(paren
id|remaining
OG
l_int|0
)paren
(brace
id|remaining
op_sub_assign
id|evbuf-&gt;length
suffix:semicolon
r_if
c_cond
(paren
id|evbuf-&gt;flags
op_amp
id|SCLP_EVBUF_PROCESSED
)paren
(brace
id|sccb-&gt;length
op_sub_assign
id|evbuf-&gt;length
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|evbuf
comma
(paren
r_void
op_star
)paren
(paren
(paren
id|addr_t
)paren
id|evbuf
op_plus
id|evbuf-&gt;length
)paren
comma
id|remaining
)paren
suffix:semicolon
)brace
r_else
(brace
id|unprocessed
op_increment
suffix:semicolon
id|evbuf
op_assign
(paren
r_struct
id|evbuf_header
op_star
)paren
(paren
(paren
id|addr_t
)paren
id|evbuf
op_plus
id|evbuf-&gt;length
)paren
suffix:semicolon
)brace
)brace
r_return
id|unprocessed
suffix:semicolon
)brace
DECL|variable|sclp_init
id|module_init
c_func
(paren
id|sclp_init
)paren
suffix:semicolon
DECL|variable|sclp_add_request
id|EXPORT_SYMBOL
c_func
(paren
id|sclp_add_request
)paren
suffix:semicolon
DECL|variable|sclp_sync_wait
id|EXPORT_SYMBOL
c_func
(paren
id|sclp_sync_wait
)paren
suffix:semicolon
DECL|variable|sclp_register
id|EXPORT_SYMBOL
c_func
(paren
id|sclp_register
)paren
suffix:semicolon
DECL|variable|sclp_unregister
id|EXPORT_SYMBOL
c_func
(paren
id|sclp_unregister
)paren
suffix:semicolon
DECL|variable|sclp_error_message
id|EXPORT_SYMBOL
c_func
(paren
id|sclp_error_message
)paren
suffix:semicolon
eof
