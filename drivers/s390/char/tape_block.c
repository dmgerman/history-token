multiline_comment|/*&n; *  drivers/s390/char/tape_block.c&n; *    block device frontend for tape device driver&n; *&n; *  S390 and zSeries version&n; *    Copyright (C) 2001,2002 IBM Deutschland Entwicklung GmbH, IBM Corporation&n; *    Author(s): Carsten Otte &lt;cotte@de.ibm.com&gt;&n; *&t;&t; Tuan Ngo-Anh &lt;ngoanh@de.ibm.com&gt;&n; *&t;&t; Martin Schwidefsky &lt;schwidefsky@de.ibm.com&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;asm/debug.h&gt;
macro_line|#include &quot;tape.h&quot;
DECL|macro|PRINTK_HEADER
mdefine_line|#define PRINTK_HEADER &quot;TBLOCK:&quot;
DECL|macro|TAPEBLOCK_MAX_SEC
mdefine_line|#define TAPEBLOCK_MAX_SEC&t;100
DECL|macro|TAPEBLOCK_MIN_REQUEUE
mdefine_line|#define TAPEBLOCK_MIN_REQUEUE&t;3
multiline_comment|/*&n; * file operation structure for tape block frontend&n; */
r_static
r_int
id|tapeblock_open
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
r_int
id|tapeblock_release
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
DECL|variable|tapeblock_fops
r_static
r_struct
id|block_device_operations
id|tapeblock_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|open
op_assign
id|tapeblock_open
comma
dot
id|release
op_assign
id|tapeblock_release
comma
)brace
suffix:semicolon
DECL|variable|tapeblock_major
r_static
r_int
id|tapeblock_major
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Post finished request.&n; */
r_static
r_inline
r_void
DECL|function|tapeblock_end_request
id|tapeblock_end_request
c_func
(paren
r_struct
id|request
op_star
id|req
comma
r_int
id|uptodate
)paren
(brace
r_if
c_cond
(paren
id|end_that_request_first
c_func
(paren
id|req
comma
id|uptodate
comma
id|req-&gt;hard_nr_sectors
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|end_that_request_last
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|__tapeblock_end_request
id|__tapeblock_end_request
c_func
(paren
r_struct
id|tape_request
op_star
id|ccw_req
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|tape_device
op_star
id|device
suffix:semicolon
r_struct
id|request
op_star
id|req
suffix:semicolon
id|device
op_assign
id|ccw_req-&gt;device
suffix:semicolon
id|req
op_assign
(paren
r_struct
id|request
op_star
)paren
id|data
suffix:semicolon
id|tapeblock_end_request
c_func
(paren
id|req
comma
id|ccw_req-&gt;rc
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccw_req-&gt;rc
op_eq
l_int|0
)paren
multiline_comment|/* Update position. */
id|device-&gt;blk_data.block_position
op_assign
(paren
id|req-&gt;sector
op_plus
id|req-&gt;nr_sectors
)paren
op_rshift
id|TAPEBLOCK_HSEC_S2B
suffix:semicolon
r_else
multiline_comment|/* We lost the position information due to an error. */
id|device-&gt;blk_data.block_position
op_assign
op_minus
l_int|1
suffix:semicolon
id|device-&gt;discipline
op_member_access_from_pointer
id|free_bread
c_func
(paren
id|ccw_req
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|device-&gt;req_queue
)paren
op_logical_or
id|elv_next_request
c_func
(paren
op_amp
id|device-&gt;blk_data.request_queue
)paren
)paren
id|tasklet_schedule
c_func
(paren
op_amp
id|device-&gt;blk_data.tasklet
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Fetch requests from block device queue.&n; */
r_static
r_inline
r_void
DECL|function|__tape_process_blk_queue
id|__tape_process_blk_queue
c_func
(paren
r_struct
id|tape_device
op_star
id|device
comma
r_struct
id|list_head
op_star
id|new_req
)paren
(brace
id|request_queue_t
op_star
id|queue
suffix:semicolon
r_struct
id|list_head
op_star
id|l
suffix:semicolon
r_struct
id|request
op_star
id|req
suffix:semicolon
r_struct
id|tape_request
op_star
id|ccw_req
suffix:semicolon
r_int
id|nr_queued
suffix:semicolon
multiline_comment|/* FIXME: we have to make sure that the tapeblock frontend&n;&t;   owns the device. tape_state != TS_IN_USE is NOT enough. */
r_if
c_cond
(paren
id|device-&gt;tape_state
op_ne
id|TS_IN_USE
)paren
r_return
suffix:semicolon
id|queue
op_assign
op_amp
id|device-&gt;blk_data.request_queue
suffix:semicolon
id|nr_queued
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Count number of requests on ccw queue. */
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|device-&gt;req_queue
)paren
id|nr_queued
op_increment
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|blk_queue_plugged
c_func
(paren
id|queue
)paren
op_logical_and
id|elv_next_request
c_func
(paren
id|queue
)paren
op_logical_and
id|nr_queued
OL
id|TAPEBLOCK_MIN_REQUEUE
)paren
(brace
id|req
op_assign
id|elv_next_request
c_func
(paren
id|queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|req
)paren
op_eq
id|WRITE
)paren
(brace
id|DBF_EVENT
c_func
(paren
l_int|1
comma
l_string|&quot;TBLOCK: Rejecting write request&bslash;n&quot;
)paren
suffix:semicolon
id|blkdev_dequeue_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|tapeblock_end_request
c_func
(paren
id|req
comma
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|ccw_req
op_assign
id|device-&gt;discipline
op_member_access_from_pointer
id|bread
c_func
(paren
id|device
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|ccw_req
)paren
)paren
(brace
r_if
c_cond
(paren
id|PTR_ERR
c_func
(paren
id|ccw_req
)paren
op_eq
op_minus
id|ENOMEM
)paren
r_break
suffix:semicolon
multiline_comment|/* don&squot;t try again */
id|DBF_EVENT
c_func
(paren
l_int|1
comma
l_string|&quot;TBLOCK: bread failed&bslash;n&quot;
)paren
suffix:semicolon
id|blkdev_dequeue_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|tapeblock_end_request
c_func
(paren
id|req
comma
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|ccw_req-&gt;callback
op_assign
id|__tapeblock_end_request
suffix:semicolon
id|ccw_req-&gt;callback_data
op_assign
(paren
r_void
op_star
)paren
id|req
suffix:semicolon
id|ccw_req-&gt;retries
op_assign
id|TAPEBLOCK_RETRIES
suffix:semicolon
id|blkdev_dequeue_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
id|new_req
comma
op_amp
id|ccw_req-&gt;list
)paren
suffix:semicolon
id|nr_queued
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Feed requests to the tape device.&n; */
r_static
r_inline
r_int
DECL|function|tape_queue_requests
id|tape_queue_requests
c_func
(paren
r_struct
id|tape_device
op_star
id|device
comma
r_struct
id|list_head
op_star
id|new_req
)paren
(brace
r_struct
id|list_head
op_star
id|l
comma
op_star
id|n
suffix:semicolon
r_struct
id|tape_request
op_star
id|ccw_req
suffix:semicolon
r_struct
id|request
op_star
id|req
suffix:semicolon
r_int
id|rc
comma
id|fail
suffix:semicolon
id|fail
op_assign
l_int|0
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|l
comma
id|n
comma
id|new_req
)paren
(brace
id|ccw_req
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|tape_request
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|ccw_req-&gt;list
)paren
suffix:semicolon
id|rc
op_assign
id|tape_do_io_async
c_func
(paren
id|device
comma
id|ccw_req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Start/enqueueing failed. No retries in&n;&t;&t;&t; * this case.&n;&t;&t;&t; */
id|req
op_assign
(paren
r_struct
id|request
op_star
)paren
id|ccw_req-&gt;callback_data
suffix:semicolon
id|tapeblock_end_request
c_func
(paren
id|req
comma
l_int|0
)paren
suffix:semicolon
id|device-&gt;discipline
op_member_access_from_pointer
id|free_bread
c_func
(paren
id|ccw_req
)paren
suffix:semicolon
id|fail
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|fail
suffix:semicolon
)brace
multiline_comment|/*&n; * Tape request queue function. Called from ll_rw_blk.c&n; */
r_static
r_void
DECL|function|tapeblock_request_fn
id|tapeblock_request_fn
c_func
(paren
id|request_queue_t
op_star
id|queue
)paren
(brace
r_struct
id|list_head
id|new_req
suffix:semicolon
r_struct
id|tape_device
op_star
id|device
suffix:semicolon
id|device
op_assign
(paren
r_struct
id|tape_device
op_star
)paren
id|queue-&gt;queuedata
suffix:semicolon
r_while
c_loop
(paren
id|elv_next_request
c_func
(paren
id|queue
)paren
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|new_req
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
)paren
suffix:semicolon
id|__tape_process_blk_queue
c_func
(paren
id|device
comma
op_amp
id|new_req
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Now queue the new request to the tape. This needs to be&n;&t;&t; * done without the device lock held.&n;&t;&t; */
r_if
c_cond
(paren
id|tape_queue_requests
c_func
(paren
id|device
comma
op_amp
id|new_req
)paren
op_eq
l_int|0
)paren
multiline_comment|/* All requests queued. Thats enough for now. */
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Acquire the device lock and process queues for the device.&n; */
r_static
r_void
DECL|function|tapeblock_tasklet
id|tapeblock_tasklet
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|list_head
id|new_req
suffix:semicolon
r_struct
id|tape_device
op_star
id|device
suffix:semicolon
id|device
op_assign
(paren
r_struct
id|tape_device
op_star
)paren
id|data
suffix:semicolon
r_while
c_loop
(paren
id|elv_next_request
c_func
(paren
op_amp
id|device-&gt;blk_data.request_queue
)paren
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|new_req
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
)paren
suffix:semicolon
id|__tape_process_blk_queue
c_func
(paren
id|device
comma
op_amp
id|new_req
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Now queue the new request to the tape. This needs to be&n;&t;&t; * done without the device lock held.&n;&t;&t; */
r_if
c_cond
(paren
id|tape_queue_requests
c_func
(paren
id|device
comma
op_amp
id|new_req
)paren
op_eq
l_int|0
)paren
multiline_comment|/* All requests queued. Thats enough for now. */
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This function is called for every new tapedevice&n; */
r_int
DECL|function|tapeblock_setup_device
id|tapeblock_setup_device
c_func
(paren
r_struct
id|tape_device
op_star
id|device
)paren
(brace
r_struct
id|tape_blk_data
op_star
id|d
op_assign
op_amp
id|device-&gt;blk_data
suffix:semicolon
id|request_queue_t
op_star
id|q
suffix:semicolon
r_struct
id|gendisk
op_star
id|disk
op_assign
id|alloc_disk
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|disk
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|tasklet_init
c_func
(paren
op_amp
id|d-&gt;tasklet
comma
id|tapeblock_tasklet
comma
(paren
r_int
r_int
)paren
id|device
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|d-&gt;request_queue_lock
)paren
suffix:semicolon
id|q
op_assign
id|blk_init_queue
c_func
(paren
id|tapeblock_request_fn
comma
op_amp
id|d-&gt;request_queue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q
)paren
r_goto
id|put_disk
suffix:semicolon
id|d-&gt;request_queue
op_assign
id|q
suffix:semicolon
id|elevator_exit
c_func
(paren
id|q
)paren
suffix:semicolon
id|rc
op_assign
id|elevator_init
c_func
(paren
id|q
comma
op_amp
id|elevator_noop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|cleanup_queue
suffix:semicolon
multiline_comment|/* FIXME: We should be able to sense the sectore size */
id|blk_queue_hardsect_size
c_func
(paren
id|q
comma
id|TAPEBLOCK_HSEC_SIZE
)paren
suffix:semicolon
id|blk_queue_max_sectors
c_func
(paren
id|q
comma
id|TAPEBLOCK_MAX_SEC
)paren
suffix:semicolon
id|blk_queue_max_phys_segments
c_func
(paren
id|q
comma
op_minus
l_int|1L
)paren
suffix:semicolon
id|blk_queue_max_hw_segments
c_func
(paren
id|q
comma
op_minus
l_int|1L
)paren
suffix:semicolon
id|blk_queue_max_segment_size
c_func
(paren
id|q
comma
op_minus
l_int|1L
)paren
suffix:semicolon
id|blk_queue_segment_boundary
c_func
(paren
id|q
comma
op_minus
l_int|1L
)paren
suffix:semicolon
id|disk-&gt;major
op_assign
id|tapeblock_major
suffix:semicolon
id|disk-&gt;first_minor
op_assign
id|device-&gt;first_minor
suffix:semicolon
id|disk-&gt;fops
op_assign
op_amp
id|tapeblock_fops
suffix:semicolon
id|disk-&gt;private_data
op_assign
id|device
suffix:semicolon
id|disk-&gt;queue
op_assign
id|q
suffix:semicolon
singleline_comment|//set_capacity(disk, size);
id|sprintf
c_func
(paren
id|disk-&gt;disk_name
comma
l_string|&quot;tBLK/%d&quot;
comma
id|device-&gt;first_minor
op_div
id|TAPE_MINORS_PER_DEV
)paren
suffix:semicolon
id|add_disk
c_func
(paren
id|disk
)paren
suffix:semicolon
id|d-&gt;disk
op_assign
id|disk
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|cleanup_queue
suffix:colon
id|blk_cleanup_queue
c_func
(paren
id|q
)paren
suffix:semicolon
id|put_disk
suffix:colon
id|put_disk
c_func
(paren
id|disk
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_void
DECL|function|tapeblock_cleanup_device
id|tapeblock_cleanup_device
c_func
(paren
r_struct
id|tape_device
op_star
id|device
)paren
(brace
r_struct
id|tape_blk_data
op_star
id|d
op_assign
op_amp
id|device-&gt;blk_data
suffix:semicolon
id|del_gendisk
c_func
(paren
id|d-&gt;disk
)paren
suffix:semicolon
id|put_disk
c_func
(paren
id|d-&gt;disk
)paren
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
id|d-&gt;request_queue
)paren
suffix:semicolon
id|tasklet_kill
c_func
(paren
op_amp
id|d-&gt;tasklet
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Detect number of blocks of the tape.&n; * FIXME: can we extent this to detect the blocks size as well ?&n; */
DECL|function|tapeblock_mediumdetect
r_static
r_int
id|tapeblock_mediumdetect
c_func
(paren
r_struct
id|tape_device
op_star
id|device
)paren
(brace
r_int
r_int
id|nr_of_blks
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|PRINT_INFO
c_func
(paren
l_string|&quot;Detecting media size...&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
id|tape_mtop
c_func
(paren
id|device
comma
id|MTREW
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|rc
op_assign
id|tape_mtop
c_func
(paren
id|device
comma
id|MTFSF
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|rc
op_assign
id|tape_mtop
c_func
(paren
id|device
comma
id|MTTELL
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|nr_of_blks
op_assign
id|rc
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* don&squot;t count FM */
id|rc
op_assign
id|tape_mtop
c_func
(paren
id|device
comma
id|MTREW
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|PRINT_INFO
c_func
(paren
l_string|&quot;Found %i blocks on media&bslash;n&quot;
comma
id|nr_of_blks
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Block frontend tape device open function.&n; */
r_static
r_int
DECL|function|tapeblock_open
id|tapeblock_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|inode-&gt;i_bdev-&gt;bd_disk
suffix:semicolon
r_struct
id|tape_device
op_star
id|device
op_assign
id|disk-&gt;private_data
suffix:semicolon
r_int
id|rc
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: this new tapeblock_open function is from 2.5.69.&n;&t; * It doesn&squot;t do tape_get_device anymore but picks the device&n;&t; * pointer from disk-&gt;private_data. It is stored in &n;&t; * tapeblock_setup_device but WITHOUT proper ref-counting.&n;&t; */
id|rc
op_assign
id|tape_open
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|put_device
suffix:semicolon
id|rc
op_assign
id|tape_assign
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|release
suffix:semicolon
id|device-&gt;blk_data.block_position
op_assign
op_minus
l_int|1
suffix:semicolon
id|rc
op_assign
id|tapeblock_mediumdetect
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|unassign
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|unassign
suffix:colon
id|tape_unassign
c_func
(paren
id|device
)paren
suffix:semicolon
id|release
suffix:colon
id|tape_release
c_func
(paren
id|device
)paren
suffix:semicolon
id|put_device
suffix:colon
id|tape_put_device
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Block frontend tape device release function.&n; */
r_static
r_int
DECL|function|tapeblock_release
id|tapeblock_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|inode-&gt;i_bdev-&gt;bd_disk
suffix:semicolon
r_struct
id|tape_device
op_star
id|device
op_assign
id|disk-&gt;private_data
suffix:semicolon
id|tape_release
c_func
(paren
id|device
)paren
suffix:semicolon
id|tape_unassign
c_func
(paren
id|device
)paren
suffix:semicolon
id|tape_put_device
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize block device frontend.&n; */
r_int
DECL|function|tapeblock_init
id|tapeblock_init
c_func
(paren
r_void
)paren
(brace
r_int
id|rc
suffix:semicolon
multiline_comment|/* Register the tape major number to the kernel */
id|rc
op_assign
id|register_blkdev
c_func
(paren
id|tapeblock_major
comma
l_string|&quot;tBLK&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
r_return
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|tapeblock_major
op_eq
l_int|0
)paren
id|tapeblock_major
op_assign
id|rc
suffix:semicolon
id|PRINT_INFO
c_func
(paren
l_string|&quot;tape gets major %d for block device&bslash;n&quot;
comma
id|tapeblock_major
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Deregister major for block device frontend&n; */
r_void
DECL|function|tapeblock_exit
id|tapeblock_exit
c_func
(paren
r_void
)paren
(brace
id|unregister_blkdev
c_func
(paren
id|tapeblock_major
comma
l_string|&quot;tBLK&quot;
)paren
suffix:semicolon
)brace
eof
