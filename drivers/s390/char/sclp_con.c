multiline_comment|/*&n; *  drivers/s390/char/sclp_con.c&n; *    SCLP line mode console driver&n; *&n; *  S390 version&n; *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation&n; *    Author(s): Martin Peschke &lt;mpeschke@de.ibm.com&gt;&n; *&t;&t; Martin Schwidefsky &lt;schwidefsky@de.ibm.com&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/jiffies.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &quot;sclp.h&quot;
macro_line|#include &quot;sclp_rw.h&quot;
DECL|macro|SCLP_CON_PRINT_HEADER
mdefine_line|#define SCLP_CON_PRINT_HEADER &quot;sclp console driver: &quot;
DECL|macro|sclp_console_major
mdefine_line|#define sclp_console_major 4&t;&t;/* TTYAUX_MAJOR */
DECL|macro|sclp_console_minor
mdefine_line|#define sclp_console_minor 64
DECL|macro|sclp_console_name
mdefine_line|#define sclp_console_name  &quot;ttyS&quot;
multiline_comment|/* Lock to guard over changes to global variables */
DECL|variable|sclp_con_lock
r_static
id|spinlock_t
id|sclp_con_lock
suffix:semicolon
multiline_comment|/* List of free pages that can be used for console output buffering */
DECL|variable|sclp_con_pages
r_static
r_struct
id|list_head
id|sclp_con_pages
suffix:semicolon
multiline_comment|/* List of full struct sclp_buffer structures ready for output */
DECL|variable|sclp_con_outqueue
r_static
r_struct
id|list_head
id|sclp_con_outqueue
suffix:semicolon
multiline_comment|/* Counter how many buffers are emitted (max 1) and how many */
multiline_comment|/* are on the output queue. */
DECL|variable|sclp_con_buffer_count
r_static
r_int
id|sclp_con_buffer_count
suffix:semicolon
multiline_comment|/* Pointer to current console buffer */
DECL|variable|sclp_conbuf
r_static
r_struct
id|sclp_buffer
op_star
id|sclp_conbuf
suffix:semicolon
multiline_comment|/* Timer for delayed output of console messages */
DECL|variable|sclp_con_timer
r_static
r_struct
id|timer_list
id|sclp_con_timer
suffix:semicolon
multiline_comment|/* Output format for console messages */
DECL|variable|sclp_con_columns
r_static
r_int
r_int
id|sclp_con_columns
suffix:semicolon
DECL|variable|sclp_con_width_htab
r_static
r_int
r_int
id|sclp_con_width_htab
suffix:semicolon
r_static
r_void
DECL|function|sclp_conbuf_callback
id|sclp_conbuf_callback
c_func
(paren
r_struct
id|sclp_buffer
op_star
id|buffer
comma
r_int
id|rc
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sclp_buffer
op_star
id|next
suffix:semicolon
r_void
op_star
id|page
suffix:semicolon
multiline_comment|/* Ignore return code - because console-writes aren&squot;t critical,&n;&t;   we do without a sophisticated error recovery mechanism.  */
id|page
op_assign
id|sclp_unmake_buffer
c_func
(paren
id|buffer
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_con_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Remove buffer from outqueue */
id|list_del
c_func
(paren
op_amp
id|buffer-&gt;list
)paren
suffix:semicolon
id|sclp_con_buffer_count
op_decrement
suffix:semicolon
id|list_add_tail
c_func
(paren
(paren
r_struct
id|list_head
op_star
)paren
id|page
comma
op_amp
id|sclp_con_pages
)paren
suffix:semicolon
multiline_comment|/* Check if there is a pending buffer on the out queue. */
id|next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|sclp_con_outqueue
)paren
)paren
id|next
op_assign
id|list_entry
c_func
(paren
id|sclp_con_outqueue.next
comma
r_struct
id|sclp_buffer
comma
id|list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_con_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next
op_ne
l_int|NULL
)paren
id|sclp_emit_buffer
c_func
(paren
id|next
comma
id|sclp_conbuf_callback
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|__sclp_conbuf_emit
id|__sclp_conbuf_emit
c_func
(paren
r_struct
id|sclp_buffer
op_star
id|buffer
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|buffer-&gt;list
comma
op_amp
id|sclp_con_outqueue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sclp_con_buffer_count
op_increment
op_eq
l_int|0
)paren
id|sclp_emit_buffer
c_func
(paren
id|buffer
comma
id|sclp_conbuf_callback
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * When this routine is called from the timer then we flush the&n; * temporary write buffer without further waiting on a final new line.&n; */
r_static
r_void
DECL|function|sclp_console_timeout
id|sclp_console_timeout
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_con_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sclp_conbuf
op_ne
l_int|NULL
)paren
(brace
id|__sclp_conbuf_emit
c_func
(paren
id|sclp_conbuf
)paren
suffix:semicolon
id|sclp_conbuf
op_assign
l_int|NULL
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_con_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Writes the given message to S390 system console&n; */
r_static
r_void
DECL|function|sclp_console_write
id|sclp_console_write
c_func
(paren
r_struct
id|console
op_star
id|console
comma
r_const
r_char
op_star
id|message
comma
r_int
r_int
id|count
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_void
op_star
id|page
suffix:semicolon
r_int
id|written
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_con_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * process escape characters, write message into buffer,&n;&t; * send buffer to SCLP&n;&t; */
r_do
(brace
multiline_comment|/* make sure we have a console output buffer */
r_if
c_cond
(paren
id|sclp_conbuf
op_eq
l_int|NULL
)paren
(brace
r_while
c_loop
(paren
id|list_empty
c_func
(paren
op_amp
id|sclp_con_pages
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_con_lock
comma
id|flags
)paren
suffix:semicolon
id|sclp_sync_wait
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_con_lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|page
op_assign
id|sclp_con_pages.next
suffix:semicolon
id|list_del
c_func
(paren
(paren
r_struct
id|list_head
op_star
)paren
id|page
)paren
suffix:semicolon
id|sclp_conbuf
op_assign
id|sclp_make_buffer
c_func
(paren
id|page
comma
id|sclp_con_columns
comma
id|sclp_con_width_htab
)paren
suffix:semicolon
)brace
multiline_comment|/* try to write the string to the current output buffer */
id|written
op_assign
id|sclp_write
c_func
(paren
id|sclp_conbuf
comma
(paren
r_const
r_int
r_char
op_star
)paren
id|message
comma
id|count
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|written
op_eq
op_minus
id|EFAULT
op_logical_or
id|written
op_eq
id|count
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Not all characters could be written to the current&n;&t;&t; * output buffer. Emit the buffer, create a new buffer&n;&t;&t; * and then output the rest of the string.&n;&t;&t; */
id|__sclp_conbuf_emit
c_func
(paren
id|sclp_conbuf
)paren
suffix:semicolon
id|sclp_conbuf
op_assign
l_int|NULL
suffix:semicolon
id|message
op_add_assign
id|written
suffix:semicolon
id|count
op_sub_assign
id|written
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Setup timer to output current console buffer after 1/10 second */
r_if
c_cond
(paren
id|sclp_conbuf
op_ne
l_int|NULL
op_logical_and
op_logical_neg
id|timer_pending
c_func
(paren
op_amp
id|sclp_con_timer
)paren
)paren
(brace
id|init_timer
c_func
(paren
op_amp
id|sclp_con_timer
)paren
suffix:semicolon
id|sclp_con_timer.function
op_assign
id|sclp_console_timeout
suffix:semicolon
id|sclp_con_timer.data
op_assign
l_int|0UL
suffix:semicolon
id|sclp_con_timer.expires
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|10
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sclp_con_timer
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_con_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* returns the device number of the SCLP console */
r_static
id|kdev_t
DECL|function|sclp_console_device
id|sclp_console_device
c_func
(paren
r_struct
id|console
op_star
id|c
)paren
(brace
r_return
id|mk_kdev
c_func
(paren
id|sclp_console_major
comma
id|sclp_console_minor
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called from panic when the kernel&n; * is going to give up. We have to make sure that all buffers&n; * will be flushed to the SCLP.&n; */
r_static
r_void
DECL|function|sclp_console_unblank
id|sclp_console_unblank
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_con_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|sclp_con_timer
)paren
)paren
id|del_timer
c_func
(paren
op_amp
id|sclp_con_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sclp_conbuf
op_ne
l_int|NULL
)paren
(brace
id|__sclp_conbuf_emit
c_func
(paren
id|sclp_conbuf
)paren
suffix:semicolon
id|sclp_conbuf
op_assign
l_int|NULL
suffix:semicolon
)brace
r_while
c_loop
(paren
id|sclp_con_buffer_count
OG
l_int|0
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_con_lock
comma
id|flags
)paren
suffix:semicolon
id|sclp_sync_wait
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_con_lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_con_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * used to register the SCLP console to the kernel and to&n; * give printk necessary information&n; */
DECL|variable|sclp_console
r_static
r_struct
id|console
id|sclp_console
op_assign
(brace
dot
id|name
op_assign
id|sclp_console_name
comma
dot
id|write
op_assign
id|sclp_console_write
comma
dot
id|device
op_assign
id|sclp_console_device
comma
dot
id|unblank
op_assign
id|sclp_console_unblank
comma
dot
id|flags
op_assign
id|CON_PRINTBUFFER
comma
dot
id|index
op_assign
l_int|0
multiline_comment|/* ttyS0 */
)brace
suffix:semicolon
multiline_comment|/*&n; * called by console_init() in drivers/char/tty_io.c at boot-time.&n; */
r_static
r_int
id|__init
DECL|function|sclp_console_init
id|sclp_console_init
c_func
(paren
r_void
)paren
(brace
r_void
op_star
id|page
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CONSOLE_IS_SCLP
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sclp_rw_init
c_func
(paren
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Allocate pages for output buffering */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sclp_con_pages
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_CONSOLE_PAGES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|page
op_assign
id|alloc_bootmem_low_pages
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|list_add_tail
c_func
(paren
(paren
r_struct
id|list_head
op_star
)paren
id|page
comma
op_amp
id|sclp_con_pages
)paren
suffix:semicolon
)brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sclp_con_outqueue
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|sclp_con_lock
)paren
suffix:semicolon
id|sclp_con_buffer_count
op_assign
l_int|0
suffix:semicolon
id|sclp_conbuf
op_assign
l_int|NULL
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|sclp_con_timer
)paren
suffix:semicolon
multiline_comment|/* Set output format */
r_if
c_cond
(paren
id|MACHINE_IS_VM
)paren
multiline_comment|/*&n;&t;&t; * save 4 characters for the CPU number&n;&t;&t; * written at start of each line by VM/CP&n;&t;&t; */
id|sclp_con_columns
op_assign
l_int|76
suffix:semicolon
r_else
id|sclp_con_columns
op_assign
l_int|80
suffix:semicolon
id|sclp_con_width_htab
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* enable printk-access to this driver */
id|register_console
c_func
(paren
op_amp
id|sclp_console
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|sclp_console_init
id|console_initcall
c_func
(paren
id|sclp_console_init
)paren
suffix:semicolon
eof
