multiline_comment|/*&n; *  drivers/s390/char/sclp_tty.c&n; *    SCLP line mode terminal driver.&n; *&n; *  S390 version&n; *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation&n; *    Author(s): Martin Peschke &lt;mpeschke@de.ibm.com&gt;&n; *&t;&t; Martin Schwidefsky &lt;schwidefsky@de.ibm.com&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/tty_driver.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/err.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;ctrlchar.h&quot;
macro_line|#include &quot;sclp.h&quot;
macro_line|#include &quot;sclp_rw.h&quot;
macro_line|#include &quot;sclp_tty.h&quot;
DECL|macro|SCLP_TTY_PRINT_HEADER
mdefine_line|#define SCLP_TTY_PRINT_HEADER &quot;sclp tty driver: &quot;
multiline_comment|/*&n; * size of a buffer that collects single characters coming in&n; * via sclp_tty_put_char()&n; */
DECL|macro|SCLP_TTY_BUF_SIZE
mdefine_line|#define SCLP_TTY_BUF_SIZE 512
multiline_comment|/*&n; * There is exactly one SCLP terminal, so we can keep things simple&n; * and allocate all variables statically.&n; */
multiline_comment|/* Lock to guard over changes to global variables. */
DECL|variable|sclp_tty_lock
r_static
id|spinlock_t
id|sclp_tty_lock
suffix:semicolon
multiline_comment|/* List of free pages that can be used for console output buffering. */
DECL|variable|sclp_tty_pages
r_static
r_struct
id|list_head
id|sclp_tty_pages
suffix:semicolon
multiline_comment|/* List of full struct sclp_buffer structures ready for output. */
DECL|variable|sclp_tty_outqueue
r_static
r_struct
id|list_head
id|sclp_tty_outqueue
suffix:semicolon
multiline_comment|/* Counter how many buffers are emitted. */
DECL|variable|sclp_tty_buffer_count
r_static
r_int
id|sclp_tty_buffer_count
suffix:semicolon
multiline_comment|/* Pointer to current console buffer. */
DECL|variable|sclp_ttybuf
r_static
r_struct
id|sclp_buffer
op_star
id|sclp_ttybuf
suffix:semicolon
multiline_comment|/* Timer for delayed output of console messages. */
DECL|variable|sclp_tty_timer
r_static
r_struct
id|timer_list
id|sclp_tty_timer
suffix:semicolon
multiline_comment|/* Waitqueue to wait for buffers to get empty. */
DECL|variable|sclp_tty_waitq
r_static
id|wait_queue_head_t
id|sclp_tty_waitq
suffix:semicolon
DECL|variable|sclp_tty
r_static
r_struct
id|tty_struct
op_star
id|sclp_tty
suffix:semicolon
DECL|variable|sclp_tty_chars
r_static
r_int
r_char
id|sclp_tty_chars
(braket
id|SCLP_TTY_BUF_SIZE
)braket
suffix:semicolon
DECL|variable|sclp_tty_chars_count
r_static
r_int
r_int
r_int
id|sclp_tty_chars_count
suffix:semicolon
DECL|variable|sclp_tty_driver
r_struct
id|tty_driver
op_star
id|sclp_tty_driver
suffix:semicolon
r_extern
r_struct
id|termios
id|tty_std_termios
suffix:semicolon
DECL|variable|sclp_ioctls
r_static
r_struct
id|sclp_ioctls
id|sclp_ioctls
suffix:semicolon
DECL|variable|sclp_ioctls_init
r_static
r_struct
id|sclp_ioctls
id|sclp_ioctls_init
op_assign
(brace
l_int|8
comma
multiline_comment|/* 1 hor. tab. = 8 spaces */
l_int|0
comma
multiline_comment|/* no echo of input by this driver */
l_int|80
comma
multiline_comment|/* 80 characters/line */
l_int|1
comma
multiline_comment|/* write after 1/10 s without final new line */
id|MAX_KMEM_PAGES
comma
multiline_comment|/* quick fix: avoid __alloc_pages */
id|MAX_KMEM_PAGES
comma
multiline_comment|/* take 32/64 pages from kernel memory, */
l_int|0
comma
multiline_comment|/* do not convert to lower case */
l_int|0x6c
multiline_comment|/* to seprate upper and lower case */
multiline_comment|/* (&squot;%&squot; in EBCDIC) */
)brace
suffix:semicolon
multiline_comment|/* This routine is called whenever we try to open a SCLP terminal. */
r_static
r_int
DECL|function|sclp_tty_open
id|sclp_tty_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|sclp_tty
op_assign
id|tty
suffix:semicolon
id|tty-&gt;driver_data
op_assign
l_int|NULL
suffix:semicolon
id|tty-&gt;low_latency
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This routine is called when the SCLP terminal is closed. */
r_static
r_void
DECL|function|sclp_tty_close
id|sclp_tty_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;count
OG
l_int|1
)paren
r_return
suffix:semicolon
id|sclp_tty
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* execute commands to control the i/o behaviour of the SCLP tty at runtime */
r_static
r_int
DECL|function|sclp_tty_ioctl
id|sclp_tty_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|obuf
suffix:semicolon
r_int
id|check
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_IO_ERROR
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
id|check
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCSCLPSHTAB
suffix:colon
multiline_comment|/* set width of horizontal tab&t;*/
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|sclp_ioctls.htab
comma
(paren
r_int
r_int
id|__user
op_star
)paren
id|arg
)paren
)paren
id|rc
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_else
id|check
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSCLPGHTAB
suffix:colon
multiline_comment|/* get width of horizontal tab&t;*/
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|sclp_ioctls.htab
comma
(paren
r_int
r_int
id|__user
op_star
)paren
id|arg
)paren
)paren
id|rc
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSCLPSECHO
suffix:colon
multiline_comment|/* enable/disable echo of input */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|sclp_ioctls.echo
comma
(paren
r_int
r_char
id|__user
op_star
)paren
id|arg
)paren
)paren
id|rc
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSCLPGECHO
suffix:colon
multiline_comment|/* Is echo of input enabled ?  */
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|sclp_ioctls.echo
comma
(paren
r_int
r_char
id|__user
op_star
)paren
id|arg
)paren
)paren
id|rc
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSCLPSCOLS
suffix:colon
multiline_comment|/* set number of columns for output  */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|sclp_ioctls.columns
comma
(paren
r_int
r_int
id|__user
op_star
)paren
id|arg
)paren
)paren
id|rc
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_else
id|check
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSCLPGCOLS
suffix:colon
multiline_comment|/* get number of columns for output  */
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|sclp_ioctls.columns
comma
(paren
r_int
r_int
id|__user
op_star
)paren
id|arg
)paren
)paren
id|rc
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSCLPSNL
suffix:colon
multiline_comment|/* enable/disable writing without final new line character  */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|sclp_ioctls.final_nl
comma
(paren
r_int
r_char
id|__user
op_star
)paren
id|arg
)paren
)paren
id|rc
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSCLPGNL
suffix:colon
multiline_comment|/* Is writing without final new line character enabled ?  */
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|sclp_ioctls.final_nl
comma
(paren
r_int
r_char
id|__user
op_star
)paren
id|arg
)paren
)paren
id|rc
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSCLPSOBUF
suffix:colon
multiline_comment|/*&n;&t;&t; * set the maximum buffers size for output, will be rounded&n;&t;&t; * up to next 4kB boundary and stored as number of SCCBs&n;&t;&t; * (4kB Buffers) limitation: 256 x 4kB&n;&t;&t; */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|obuf
comma
(paren
r_int
r_int
id|__user
op_star
)paren
id|arg
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|obuf
op_amp
l_int|0xFFF
)paren
id|sclp_ioctls.max_sccb
op_assign
(paren
id|obuf
op_rshift
l_int|12
)paren
op_plus
l_int|1
suffix:semicolon
r_else
id|sclp_ioctls.max_sccb
op_assign
(paren
id|obuf
op_rshift
l_int|12
)paren
suffix:semicolon
)brace
r_else
id|rc
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSCLPGOBUF
suffix:colon
multiline_comment|/* get the maximum buffers size for output  */
id|obuf
op_assign
id|sclp_ioctls.max_sccb
op_lshift
l_int|12
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|obuf
comma
(paren
r_int
r_int
id|__user
op_star
)paren
id|arg
)paren
)paren
id|rc
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSCLPGKBUF
suffix:colon
multiline_comment|/* get the number of buffers got from kernel at startup */
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|sclp_ioctls.kmem_sccb
comma
(paren
r_int
r_int
id|__user
op_star
)paren
id|arg
)paren
)paren
id|rc
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSCLPSCASE
suffix:colon
multiline_comment|/* enable/disable conversion from upper to lower case */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|sclp_ioctls.tolower
comma
(paren
r_int
r_char
id|__user
op_star
)paren
id|arg
)paren
)paren
id|rc
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSCLPGCASE
suffix:colon
multiline_comment|/* Is conversion from upper to lower case of input enabled? */
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|sclp_ioctls.tolower
comma
(paren
r_int
r_char
id|__user
op_star
)paren
id|arg
)paren
)paren
id|rc
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSCLPSDELIM
suffix:colon
multiline_comment|/*&n;&t;&t; * set special character used for separating upper and&n;&t;&t; * lower case, 0x00 disables this feature&n;&t;&t; */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|sclp_ioctls.delim
comma
(paren
r_int
r_char
id|__user
op_star
)paren
id|arg
)paren
)paren
id|rc
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSCLPGDELIM
suffix:colon
multiline_comment|/*&n;&t;&t; * get special character used for separating upper and&n;&t;&t; * lower case, 0x00 disables this feature&n;&t;&t; */
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|sclp_ioctls.delim
comma
(paren
r_int
r_char
id|__user
op_star
)paren
id|arg
)paren
)paren
id|rc
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSCLPSINIT
suffix:colon
multiline_comment|/* set initial (default) sclp ioctls  */
id|sclp_ioctls
op_assign
id|sclp_ioctls_init
suffix:semicolon
id|check
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|rc
op_assign
op_minus
id|ENOIOCTLCMD
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_tty_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sclp_ttybuf
op_ne
l_int|NULL
)paren
(brace
id|sclp_set_htab
c_func
(paren
id|sclp_ttybuf
comma
id|sclp_ioctls.htab
)paren
suffix:semicolon
id|sclp_set_columns
c_func
(paren
id|sclp_ttybuf
comma
id|sclp_ioctls.columns
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_tty_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine returns the numbers of characters the tty driver&n; * will accept for queuing to be written.  This number is subject&n; * to change as output buffers get emptied, or if the output flow&n; * control is acted. This is not an exact number because not every&n; * character needs the same space in the sccb. The worst case is&n; * a string of newlines. Every newlines creates a new mto which&n; * needs 8 bytes.&n; */
r_static
r_int
DECL|function|sclp_tty_write_room
id|sclp_tty_write_room
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|list_head
op_star
id|l
suffix:semicolon
r_int
id|count
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_tty_lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sclp_ttybuf
op_ne
l_int|NULL
)paren
id|count
op_assign
id|sclp_buffer_space
c_func
(paren
id|sclp_ttybuf
)paren
op_div
r_sizeof
(paren
r_struct
id|mto
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|sclp_tty_pages
)paren
id|count
op_add_assign
id|NR_EMPTY_MTO_PER_SCCB
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_tty_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_static
r_void
DECL|function|sclp_ttybuf_callback
id|sclp_ttybuf_callback
c_func
(paren
r_struct
id|sclp_buffer
op_star
id|buffer
comma
r_int
id|rc
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sclp_buffer
op_star
id|next
suffix:semicolon
r_void
op_star
id|page
suffix:semicolon
multiline_comment|/* Ignore return code - because tty-writes aren&squot;t critical,&n;&t;   we do without a sophisticated error recovery mechanism.  */
id|page
op_assign
id|sclp_unmake_buffer
c_func
(paren
id|buffer
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_tty_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Remove buffer from outqueue */
id|list_del
c_func
(paren
op_amp
id|buffer-&gt;list
)paren
suffix:semicolon
id|sclp_tty_buffer_count
op_decrement
suffix:semicolon
id|list_add_tail
c_func
(paren
(paren
r_struct
id|list_head
op_star
)paren
id|page
comma
op_amp
id|sclp_tty_pages
)paren
suffix:semicolon
multiline_comment|/* Check if there is a pending buffer on the out queue. */
id|next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|sclp_tty_outqueue
)paren
)paren
id|next
op_assign
id|list_entry
c_func
(paren
id|sclp_tty_outqueue.next
comma
r_struct
id|sclp_buffer
comma
id|list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_tty_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next
op_ne
l_int|NULL
)paren
id|sclp_emit_buffer
c_func
(paren
id|next
comma
id|sclp_ttybuf_callback
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|sclp_tty_waitq
)paren
suffix:semicolon
multiline_comment|/* check if the tty needs a wake up call */
r_if
c_cond
(paren
id|sclp_tty
op_ne
l_int|NULL
)paren
(brace
id|tty_wakeup
c_func
(paren
id|sclp_tty
)paren
suffix:semicolon
)brace
)brace
r_static
r_inline
r_void
DECL|function|__sclp_ttybuf_emit
id|__sclp_ttybuf_emit
c_func
(paren
r_struct
id|sclp_buffer
op_star
id|buffer
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|count
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_tty_lock
comma
id|flags
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|buffer-&gt;list
comma
op_amp
id|sclp_tty_outqueue
)paren
suffix:semicolon
id|count
op_assign
id|sclp_tty_buffer_count
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_tty_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
id|sclp_emit_buffer
c_func
(paren
id|buffer
comma
id|sclp_ttybuf_callback
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * When this routine is called from the timer then we flush the&n; * temporary write buffer.&n; */
r_static
r_void
DECL|function|sclp_tty_timeout
id|sclp_tty_timeout
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sclp_buffer
op_star
id|buf
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_tty_lock
comma
id|flags
)paren
suffix:semicolon
id|buf
op_assign
id|sclp_ttybuf
suffix:semicolon
id|sclp_ttybuf
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_tty_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_ne
l_int|NULL
)paren
(brace
id|__sclp_ttybuf_emit
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Write a string to the sclp tty.&n; */
r_static
r_void
DECL|function|sclp_tty_write_string
id|sclp_tty_write_string
c_func
(paren
r_const
r_int
r_char
op_star
id|str
comma
r_int
id|count
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_void
op_star
id|page
suffix:semicolon
r_int
id|written
suffix:semicolon
r_struct
id|sclp_buffer
op_star
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|count
op_le
l_int|0
)paren
r_return
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_tty_lock
comma
id|flags
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* Create a sclp output buffer if none exists yet */
r_if
c_cond
(paren
id|sclp_ttybuf
op_eq
l_int|NULL
)paren
(brace
r_while
c_loop
(paren
id|list_empty
c_func
(paren
op_amp
id|sclp_tty_pages
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_tty_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
id|sclp_sync_wait
c_func
(paren
)paren
suffix:semicolon
r_else
id|wait_event
c_func
(paren
id|sclp_tty_waitq
comma
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|sclp_tty_pages
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_tty_lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|page
op_assign
id|sclp_tty_pages.next
suffix:semicolon
id|list_del
c_func
(paren
(paren
r_struct
id|list_head
op_star
)paren
id|page
)paren
suffix:semicolon
id|sclp_ttybuf
op_assign
id|sclp_make_buffer
c_func
(paren
id|page
comma
id|sclp_ioctls.columns
comma
id|sclp_ioctls.htab
)paren
suffix:semicolon
)brace
multiline_comment|/* try to write the string to the current output buffer */
id|written
op_assign
id|sclp_write
c_func
(paren
id|sclp_ttybuf
comma
id|str
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|written
op_eq
id|count
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Not all characters could be written to the current&n;&t;&t; * output buffer. Emit the buffer, create a new buffer&n;&t;&t; * and then output the rest of the string.&n;&t;&t; */
id|buf
op_assign
id|sclp_ttybuf
suffix:semicolon
id|sclp_ttybuf
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_tty_lock
comma
id|flags
)paren
suffix:semicolon
id|__sclp_ttybuf_emit
c_func
(paren
id|buf
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_tty_lock
comma
id|flags
)paren
suffix:semicolon
id|str
op_add_assign
id|written
suffix:semicolon
id|count
op_sub_assign
id|written
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Setup timer to output current console buffer after 1/10 second */
r_if
c_cond
(paren
id|sclp_ioctls.final_nl
)paren
(brace
r_if
c_cond
(paren
id|sclp_ttybuf
op_ne
l_int|NULL
op_logical_and
id|sclp_chars_in_buffer
c_func
(paren
id|sclp_ttybuf
)paren
op_ne
l_int|0
op_logical_and
op_logical_neg
id|timer_pending
c_func
(paren
op_amp
id|sclp_tty_timer
)paren
)paren
(brace
id|init_timer
c_func
(paren
op_amp
id|sclp_tty_timer
)paren
suffix:semicolon
id|sclp_tty_timer.function
op_assign
id|sclp_tty_timeout
suffix:semicolon
id|sclp_tty_timer.data
op_assign
l_int|0UL
suffix:semicolon
id|sclp_tty_timer.expires
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|10
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sclp_tty_timer
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|sclp_ttybuf
op_ne
l_int|NULL
op_logical_and
id|sclp_chars_in_buffer
c_func
(paren
id|sclp_ttybuf
)paren
op_ne
l_int|0
)paren
(brace
id|buf
op_assign
id|sclp_ttybuf
suffix:semicolon
id|sclp_ttybuf
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_tty_lock
comma
id|flags
)paren
suffix:semicolon
id|__sclp_ttybuf_emit
c_func
(paren
id|buf
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_tty_lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_tty_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called by the kernel to write a series of characters to the&n; * tty device. The characters may come from user space or kernel space. This&n; * routine will return the number of characters actually accepted for writing.&n; */
r_static
r_int
DECL|function|sclp_tty_write
id|sclp_tty_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|length
comma
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|sclp_tty_chars_count
OG
l_int|0
)paren
(brace
id|sclp_tty_write_string
c_func
(paren
id|sclp_tty_chars
comma
id|sclp_tty_chars_count
)paren
suffix:semicolon
id|sclp_tty_chars_count
op_assign
l_int|0
suffix:semicolon
)brace
id|sclp_tty_write_string
c_func
(paren
id|buf
comma
id|count
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called by the kernel to write a single character to the tty&n; * device. If the kernel uses this routine, it must call the flush_chars()&n; * routine (if defined) when it is done stuffing characters into the driver.&n; *&n; * Characters provided to sclp_tty_put_char() are buffered by the SCLP driver.&n; * If the given character is a &squot;&bslash;n&squot; the contents of the SCLP write buffer&n; * - including previous characters from sclp_tty_put_char() and strings from&n; * sclp_write() without final &squot;&bslash;n&squot; - will be written.&n; */
r_static
r_void
DECL|function|sclp_tty_put_char
id|sclp_tty_put_char
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|ch
)paren
(brace
id|sclp_tty_chars
(braket
id|sclp_tty_chars_count
op_increment
)braket
op_assign
id|ch
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_or
id|sclp_tty_chars_count
op_ge
id|SCLP_TTY_BUF_SIZE
)paren
(brace
id|sclp_tty_write_string
c_func
(paren
id|sclp_tty_chars
comma
id|sclp_tty_chars_count
)paren
suffix:semicolon
id|sclp_tty_chars_count
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This routine is called by the kernel after it has written a series of&n; * characters to the tty device using put_char().&n; */
r_static
r_void
DECL|function|sclp_tty_flush_chars
id|sclp_tty_flush_chars
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|sclp_tty_chars_count
OG
l_int|0
)paren
(brace
id|sclp_tty_write_string
c_func
(paren
id|sclp_tty_chars
comma
id|sclp_tty_chars_count
)paren
suffix:semicolon
id|sclp_tty_chars_count
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This routine returns the number of characters in the write buffer of the&n; * SCLP driver. The provided number includes all characters that are stored&n; * in the SCCB (will be written next time the SCLP is not busy) as well as&n; * characters in the write buffer (will not be written as long as there is a&n; * final line feed missing).&n; */
r_static
r_int
DECL|function|sclp_tty_chars_in_buffer
id|sclp_tty_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|list_head
op_star
id|l
suffix:semicolon
r_struct
id|sclp_buffer
op_star
id|t
suffix:semicolon
r_int
id|count
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sclp_tty_lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sclp_ttybuf
op_ne
l_int|NULL
)paren
id|count
op_assign
id|sclp_chars_in_buffer
c_func
(paren
id|sclp_ttybuf
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|sclp_tty_outqueue
)paren
(brace
id|t
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|sclp_buffer
comma
id|list
)paren
suffix:semicolon
id|count
op_add_assign
id|sclp_chars_in_buffer
c_func
(paren
id|t
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sclp_tty_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*&n; * removes all content from buffers of low level driver&n; */
r_static
r_void
DECL|function|sclp_tty_flush_buffer
id|sclp_tty_flush_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|sclp_tty_chars_count
OG
l_int|0
)paren
(brace
id|sclp_tty_write_string
c_func
(paren
id|sclp_tty_chars
comma
id|sclp_tty_chars_count
)paren
suffix:semicolon
id|sclp_tty_chars_count
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * push input to tty&n; */
r_static
r_void
DECL|function|sclp_tty_input
id|sclp_tty_input
c_func
(paren
r_int
r_char
op_star
id|buf
comma
r_int
r_int
id|count
)paren
(brace
r_int
r_int
id|cchar
suffix:semicolon
multiline_comment|/*&n;&t; * If this tty driver is currently closed&n;&t; * then throw the received input away.&n;&t; */
r_if
c_cond
(paren
id|sclp_tty
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|cchar
op_assign
id|ctrlchar_handle
c_func
(paren
id|buf
comma
id|count
comma
id|sclp_tty
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cchar
op_amp
id|CTRLCHAR_MASK
)paren
(brace
r_case
id|CTRLCHAR_SYSRQ
suffix:colon
r_break
suffix:semicolon
r_case
id|CTRLCHAR_CTRL
suffix:colon
id|sclp_tty-&gt;flip.count
op_increment
suffix:semicolon
op_star
id|sclp_tty-&gt;flip.flag_buf_ptr
op_increment
op_assign
id|TTY_NORMAL
suffix:semicolon
op_star
id|sclp_tty-&gt;flip.char_buf_ptr
op_increment
op_assign
id|cchar
suffix:semicolon
id|tty_flip_buffer_push
c_func
(paren
id|sclp_tty
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CTRLCHAR_NONE
suffix:colon
multiline_comment|/* send (normal) input to line discipline */
id|memcpy
c_func
(paren
id|sclp_tty-&gt;flip.char_buf_ptr
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
l_int|2
op_logical_or
(paren
id|strncmp
(paren
(paren
r_const
r_char
op_star
)paren
id|buf
op_plus
id|count
op_minus
l_int|2
comma
l_string|&quot;^n&quot;
comma
l_int|2
)paren
op_logical_and
id|strncmp
(paren
(paren
r_const
r_char
op_star
)paren
id|buf
op_plus
id|count
op_minus
l_int|2
comma
l_string|&quot;&bslash;0252n&quot;
comma
l_int|2
)paren
)paren
)paren
(brace
id|sclp_tty-&gt;flip.char_buf_ptr
(braket
id|count
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
r_else
id|count
op_sub_assign
l_int|2
suffix:semicolon
id|memset
c_func
(paren
id|sclp_tty-&gt;flip.flag_buf_ptr
comma
id|TTY_NORMAL
comma
id|count
)paren
suffix:semicolon
id|sclp_tty-&gt;flip.char_buf_ptr
op_add_assign
id|count
suffix:semicolon
id|sclp_tty-&gt;flip.flag_buf_ptr
op_add_assign
id|count
suffix:semicolon
id|sclp_tty-&gt;flip.count
op_add_assign
id|count
suffix:semicolon
id|tty_flip_buffer_push
c_func
(paren
id|sclp_tty
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * get a EBCDIC string in upper/lower case,&n; * find out characters in lower/upper case separated by a special character,&n; * modifiy original string,&n; * returns length of resulting string&n; */
r_static
r_int
DECL|function|sclp_switch_cases
id|sclp_switch_cases
c_func
(paren
r_int
r_char
op_star
id|buf
comma
r_int
id|count
comma
r_int
r_char
id|delim
comma
r_int
id|tolower
)paren
(brace
r_int
r_char
op_star
id|ip
comma
op_star
id|op
suffix:semicolon
r_int
id|toggle
suffix:semicolon
multiline_comment|/* initially changing case is off */
id|toggle
op_assign
l_int|0
suffix:semicolon
id|ip
op_assign
id|op
op_assign
id|buf
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
(brace
multiline_comment|/* compare with special character */
r_if
c_cond
(paren
op_star
id|ip
op_eq
id|delim
)paren
(brace
multiline_comment|/* followed by another special character? */
r_if
c_cond
(paren
id|count
op_logical_and
id|ip
(braket
l_int|1
)braket
op_eq
id|delim
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * ... then put a single copy of the special&n;&t;&t;&t;&t; * character to the output string&n;&t;&t;&t;&t; */
op_star
id|op
op_increment
op_assign
op_star
id|ip
op_increment
suffix:semicolon
id|count
op_decrement
suffix:semicolon
)brace
r_else
multiline_comment|/*&n;&t;&t;&t;&t; * ... special character follower by a normal&n;&t;&t;&t;&t; * character toggles the case change behaviour&n;&t;&t;&t;&t; */
id|toggle
op_assign
op_complement
id|toggle
suffix:semicolon
multiline_comment|/* skip special character */
id|ip
op_increment
suffix:semicolon
)brace
r_else
multiline_comment|/* not the special character */
r_if
c_cond
(paren
id|toggle
)paren
multiline_comment|/* but case switching is on */
r_if
c_cond
(paren
id|tolower
)paren
multiline_comment|/* switch to uppercase */
op_star
id|op
op_increment
op_assign
id|_ebc_toupper
(braket
(paren
r_int
)paren
op_star
id|ip
op_increment
)braket
suffix:semicolon
r_else
multiline_comment|/* switch to lowercase */
op_star
id|op
op_increment
op_assign
id|_ebc_tolower
(braket
(paren
r_int
)paren
op_star
id|ip
op_increment
)braket
suffix:semicolon
r_else
multiline_comment|/* no case switching, copy the character */
op_star
id|op
op_increment
op_assign
op_star
id|ip
op_increment
suffix:semicolon
)brace
multiline_comment|/* return length of reformatted string. */
r_return
id|op
op_minus
id|buf
suffix:semicolon
)brace
r_static
r_void
DECL|function|sclp_get_input
id|sclp_get_input
c_func
(paren
r_int
r_char
op_star
id|start
comma
r_int
r_char
op_star
id|end
)paren
(brace
r_int
id|count
suffix:semicolon
id|count
op_assign
id|end
op_minus
id|start
suffix:semicolon
multiline_comment|/*&n;&t; * if set in ioctl convert EBCDIC to lower case&n;&t; * (modify original input in SCCB)&n;&t; */
r_if
c_cond
(paren
id|sclp_ioctls.tolower
)paren
id|EBC_TOLOWER
c_func
(paren
id|start
comma
id|count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * if set in ioctl find out characters in lower or upper case&n;&t; * (depends on current case) separated by a special character,&n;&t; * works on EBCDIC&n;&t; */
r_if
c_cond
(paren
id|sclp_ioctls.delim
)paren
id|count
op_assign
id|sclp_switch_cases
c_func
(paren
id|start
comma
id|count
comma
id|sclp_ioctls.delim
comma
id|sclp_ioctls.tolower
)paren
suffix:semicolon
multiline_comment|/* convert EBCDIC to ASCII (modify original input in SCCB) */
id|sclp_ebcasc_str
c_func
(paren
id|start
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* if set in ioctl write operators input to console  */
r_if
c_cond
(paren
id|sclp_ioctls.echo
)paren
id|sclp_tty_write
c_func
(paren
id|sclp_tty
comma
l_int|0
comma
id|start
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* transfer input to high level driver */
id|sclp_tty_input
c_func
(paren
id|start
comma
id|count
)paren
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|gds_vector
op_star
DECL|function|find_gds_vector
id|find_gds_vector
c_func
(paren
r_struct
id|gds_vector
op_star
id|start
comma
r_struct
id|gds_vector
op_star
id|end
comma
id|u16
id|id
)paren
(brace
r_struct
id|gds_vector
op_star
id|vec
suffix:semicolon
r_for
c_loop
(paren
id|vec
op_assign
id|start
suffix:semicolon
id|vec
OL
id|end
suffix:semicolon
id|vec
op_assign
(paren
r_void
op_star
)paren
id|vec
op_plus
id|vec-&gt;length
)paren
r_if
c_cond
(paren
id|vec-&gt;gds_id
op_eq
id|id
)paren
r_return
id|vec
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|gds_subvector
op_star
DECL|function|find_gds_subvector
id|find_gds_subvector
c_func
(paren
r_struct
id|gds_subvector
op_star
id|start
comma
r_struct
id|gds_subvector
op_star
id|end
comma
id|u8
id|key
)paren
(brace
r_struct
id|gds_subvector
op_star
id|subvec
suffix:semicolon
r_for
c_loop
(paren
id|subvec
op_assign
id|start
suffix:semicolon
id|subvec
OL
id|end
suffix:semicolon
id|subvec
op_assign
(paren
r_void
op_star
)paren
id|subvec
op_plus
id|subvec-&gt;length
)paren
r_if
c_cond
(paren
id|subvec-&gt;key
op_eq
id|key
)paren
r_return
id|subvec
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|sclp_eval_selfdeftextmsg
id|sclp_eval_selfdeftextmsg
c_func
(paren
r_struct
id|gds_subvector
op_star
id|start
comma
r_struct
id|gds_subvector
op_star
id|end
)paren
(brace
r_struct
id|gds_subvector
op_star
id|subvec
suffix:semicolon
id|subvec
op_assign
id|start
suffix:semicolon
r_while
c_loop
(paren
id|subvec
OL
id|end
)paren
(brace
id|subvec
op_assign
id|find_gds_subvector
c_func
(paren
id|subvec
comma
id|end
comma
l_int|0x30
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|subvec
)paren
r_break
suffix:semicolon
id|sclp_get_input
c_func
(paren
(paren
r_int
r_char
op_star
)paren
(paren
id|subvec
op_plus
l_int|1
)paren
comma
(paren
r_int
r_char
op_star
)paren
id|subvec
op_plus
id|subvec-&gt;length
)paren
suffix:semicolon
id|subvec
op_assign
(paren
r_void
op_star
)paren
id|subvec
op_plus
id|subvec-&gt;length
suffix:semicolon
)brace
)brace
r_static
r_inline
r_void
DECL|function|sclp_eval_textcmd
id|sclp_eval_textcmd
c_func
(paren
r_struct
id|gds_subvector
op_star
id|start
comma
r_struct
id|gds_subvector
op_star
id|end
)paren
(brace
r_struct
id|gds_subvector
op_star
id|subvec
suffix:semicolon
id|subvec
op_assign
id|start
suffix:semicolon
r_while
c_loop
(paren
id|subvec
OL
id|end
)paren
(brace
id|subvec
op_assign
id|find_gds_subvector
c_func
(paren
id|subvec
comma
id|end
comma
id|GDS_KEY_SelfDefTextMsg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|subvec
)paren
r_break
suffix:semicolon
id|sclp_eval_selfdeftextmsg
c_func
(paren
(paren
r_struct
id|gds_subvector
op_star
)paren
(paren
id|subvec
op_plus
l_int|1
)paren
comma
(paren
r_void
op_star
)paren
id|subvec
op_plus
id|subvec-&gt;length
)paren
suffix:semicolon
id|subvec
op_assign
(paren
r_void
op_star
)paren
id|subvec
op_plus
id|subvec-&gt;length
suffix:semicolon
)brace
)brace
r_static
r_inline
r_void
DECL|function|sclp_eval_cpmsu
id|sclp_eval_cpmsu
c_func
(paren
r_struct
id|gds_vector
op_star
id|start
comma
r_struct
id|gds_vector
op_star
id|end
)paren
(brace
r_struct
id|gds_vector
op_star
id|vec
suffix:semicolon
id|vec
op_assign
id|start
suffix:semicolon
r_while
c_loop
(paren
id|vec
OL
id|end
)paren
(brace
id|vec
op_assign
id|find_gds_vector
c_func
(paren
id|vec
comma
id|end
comma
id|GDS_ID_TextCmd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vec
)paren
r_break
suffix:semicolon
id|sclp_eval_textcmd
c_func
(paren
(paren
r_struct
id|gds_subvector
op_star
)paren
(paren
id|vec
op_plus
l_int|1
)paren
comma
(paren
r_void
op_star
)paren
id|vec
op_plus
id|vec-&gt;length
)paren
suffix:semicolon
id|vec
op_assign
(paren
r_void
op_star
)paren
id|vec
op_plus
id|vec-&gt;length
suffix:semicolon
)brace
)brace
r_static
r_inline
r_void
DECL|function|sclp_eval_mdsmu
id|sclp_eval_mdsmu
c_func
(paren
r_struct
id|gds_vector
op_star
id|start
comma
r_void
op_star
id|end
)paren
(brace
r_struct
id|gds_vector
op_star
id|vec
suffix:semicolon
id|vec
op_assign
id|find_gds_vector
c_func
(paren
id|start
comma
id|end
comma
id|GDS_ID_CPMSU
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vec
)paren
id|sclp_eval_cpmsu
c_func
(paren
id|vec
op_plus
l_int|1
comma
(paren
r_void
op_star
)paren
id|vec
op_plus
id|vec-&gt;length
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|sclp_tty_receiver
id|sclp_tty_receiver
c_func
(paren
r_struct
id|evbuf_header
op_star
id|evbuf
)paren
(brace
r_struct
id|gds_vector
op_star
id|start
comma
op_star
id|end
comma
op_star
id|vec
suffix:semicolon
id|start
op_assign
(paren
r_struct
id|gds_vector
op_star
)paren
(paren
id|evbuf
op_plus
l_int|1
)paren
suffix:semicolon
id|end
op_assign
(paren
r_void
op_star
)paren
id|evbuf
op_plus
id|evbuf-&gt;length
suffix:semicolon
id|vec
op_assign
id|find_gds_vector
c_func
(paren
id|start
comma
id|end
comma
id|GDS_ID_MDSMU
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vec
)paren
id|sclp_eval_mdsmu
c_func
(paren
id|vec
op_plus
l_int|1
comma
(paren
r_void
op_star
)paren
id|vec
op_plus
id|vec-&gt;length
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|sclp_tty_state_change
id|sclp_tty_state_change
c_func
(paren
r_struct
id|sclp_register
op_star
id|reg
)paren
(brace
)brace
DECL|variable|sclp_input_event
r_static
r_struct
id|sclp_register
id|sclp_input_event
op_assign
(brace
dot
id|receive_mask
op_assign
id|EvTyp_OpCmd_Mask
op_or
id|EvTyp_PMsgCmd_Mask
comma
dot
id|state_change_fn
op_assign
id|sclp_tty_state_change
comma
dot
id|receiver_fn
op_assign
id|sclp_tty_receiver
)brace
suffix:semicolon
DECL|variable|sclp_ops
r_static
r_struct
id|tty_operations
id|sclp_ops
op_assign
(brace
dot
id|open
op_assign
id|sclp_tty_open
comma
dot
id|close
op_assign
id|sclp_tty_close
comma
dot
id|write
op_assign
id|sclp_tty_write
comma
dot
id|put_char
op_assign
id|sclp_tty_put_char
comma
dot
id|flush_chars
op_assign
id|sclp_tty_flush_chars
comma
dot
id|write_room
op_assign
id|sclp_tty_write_room
comma
dot
id|chars_in_buffer
op_assign
id|sclp_tty_chars_in_buffer
comma
dot
id|flush_buffer
op_assign
id|sclp_tty_flush_buffer
comma
dot
id|ioctl
op_assign
id|sclp_tty_ioctl
comma
)brace
suffix:semicolon
r_int
id|__init
DECL|function|sclp_tty_init
id|sclp_tty_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|tty_driver
op_star
id|driver
suffix:semicolon
r_void
op_star
id|page
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CONSOLE_IS_SCLP
)paren
r_return
l_int|0
suffix:semicolon
id|driver
op_assign
id|alloc_tty_driver
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|driver
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|rc
op_assign
id|sclp_rw_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|SCLP_TTY_PRINT_HEADER
l_string|&quot;could not register tty - &quot;
l_string|&quot;sclp_rw_init returned %d&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
id|put_tty_driver
c_func
(paren
id|driver
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* Allocate pages for output buffering */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sclp_tty_pages
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_KMEM_PAGES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|page
op_assign
(paren
r_void
op_star
)paren
id|get_zeroed_page
c_func
(paren
id|GFP_KERNEL
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
op_eq
l_int|NULL
)paren
(brace
id|put_tty_driver
c_func
(paren
id|driver
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
(paren
r_struct
id|list_head
op_star
)paren
id|page
comma
op_amp
id|sclp_tty_pages
)paren
suffix:semicolon
)brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sclp_tty_outqueue
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|sclp_tty_lock
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|sclp_tty_waitq
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|sclp_tty_timer
)paren
suffix:semicolon
id|sclp_ttybuf
op_assign
l_int|NULL
suffix:semicolon
id|sclp_tty_buffer_count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|MACHINE_IS_VM
)paren
(brace
multiline_comment|/*&n;&t;&t; * save 4 characters for the CPU number&n;&t;&t; * written at start of each line by VM/CP&n;&t;&t; */
id|sclp_ioctls_init.columns
op_assign
l_int|76
suffix:semicolon
multiline_comment|/* case input lines to lowercase */
id|sclp_ioctls_init.tolower
op_assign
l_int|1
suffix:semicolon
)brace
id|sclp_ioctls
op_assign
id|sclp_ioctls_init
suffix:semicolon
id|sclp_tty_chars_count
op_assign
l_int|0
suffix:semicolon
id|sclp_tty
op_assign
l_int|NULL
suffix:semicolon
id|rc
op_assign
id|sclp_register
c_func
(paren
op_amp
id|sclp_input_event
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|put_tty_driver
c_func
(paren
id|driver
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|driver-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|driver-&gt;driver_name
op_assign
l_string|&quot;sclp_line&quot;
suffix:semicolon
id|driver-&gt;name
op_assign
l_string|&quot;sclp_line&quot;
suffix:semicolon
id|driver-&gt;major
op_assign
id|TTY_MAJOR
suffix:semicolon
id|driver-&gt;minor_start
op_assign
l_int|64
suffix:semicolon
id|driver-&gt;type
op_assign
id|TTY_DRIVER_TYPE_SYSTEM
suffix:semicolon
id|driver-&gt;subtype
op_assign
id|SYSTEM_TYPE_TTY
suffix:semicolon
id|driver-&gt;init_termios
op_assign
id|tty_std_termios
suffix:semicolon
id|driver-&gt;init_termios.c_iflag
op_assign
id|IGNBRK
op_or
id|IGNPAR
suffix:semicolon
id|driver-&gt;init_termios.c_oflag
op_assign
id|ONLCR
op_or
id|XTABS
suffix:semicolon
id|driver-&gt;init_termios.c_lflag
op_assign
id|ISIG
op_or
id|ECHO
suffix:semicolon
id|driver-&gt;flags
op_assign
id|TTY_DRIVER_REAL_RAW
suffix:semicolon
id|tty_set_operations
c_func
(paren
id|driver
comma
op_amp
id|sclp_ops
)paren
suffix:semicolon
id|rc
op_assign
id|tty_register_driver
c_func
(paren
id|driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|SCLP_TTY_PRINT_HEADER
l_string|&quot;could not register tty - &quot;
l_string|&quot;tty_register_driver returned %d&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
id|put_tty_driver
c_func
(paren
id|driver
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|sclp_tty_driver
op_assign
id|driver
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|sclp_tty_init
id|module_init
c_func
(paren
id|sclp_tty_init
)paren
suffix:semicolon
eof
