multiline_comment|/*&n; * linux/drivers/s390/scsi/zfcp_qdio.c&n; *&n; * FCP adapter driver for IBM eServer zSeries&n; *&n; * QDIO related routines&n; *&n; * (C) Copyright IBM Corp. 2002, 2004&n; *&n; * Authors:&n; *      Martin Peschke &lt;mpeschke@de.ibm.com&gt;&n; *      Raimund Schroeder &lt;raimund.schroeder@de.ibm.com&gt;&n; *      Wolfgang Taphorn&n; *      Heiko Carstens &lt;heiko.carstens@de.ibm.com&gt;&n; *      Andreas Herrmann &lt;aherrman@de.ibm.com&gt;&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
DECL|macro|ZFCP_QDIO_C_REVISION
mdefine_line|#define ZFCP_QDIO_C_REVISION &quot;$Revision: 1.20 $&quot;
macro_line|#include &quot;zfcp_ext.h&quot;
r_static
r_inline
r_void
id|zfcp_qdio_sbal_limit
c_func
(paren
r_struct
id|zfcp_fsf_req
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_inline
r_volatile
r_struct
id|qdio_buffer_element
op_star
id|zfcp_qdio_sbale_get
(paren
r_struct
id|zfcp_qdio_queue
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_static
r_inline
r_volatile
r_struct
id|qdio_buffer_element
op_star
id|zfcp_qdio_sbale_resp
(paren
r_struct
id|zfcp_fsf_req
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_static
r_inline
r_volatile
r_struct
id|qdio_buffer_element
op_star
id|zfcp_qdio_sbal_chain
(paren
r_struct
id|zfcp_fsf_req
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_inline
r_volatile
r_struct
id|qdio_buffer_element
op_star
id|zfcp_qdio_sbale_next
(paren
r_struct
id|zfcp_fsf_req
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_inline
r_int
id|zfcp_qdio_sbals_zero
c_func
(paren
r_struct
id|zfcp_qdio_queue
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_static
r_inline
r_int
id|zfcp_qdio_sbals_wipe
c_func
(paren
r_struct
id|zfcp_fsf_req
op_star
)paren
suffix:semicolon
r_static
r_inline
r_void
id|zfcp_qdio_sbale_fill
(paren
r_struct
id|zfcp_fsf_req
op_star
comma
r_int
r_int
comma
r_void
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_inline
r_int
id|zfcp_qdio_sbals_from_segment
(paren
r_struct
id|zfcp_fsf_req
op_star
comma
r_int
r_int
comma
r_void
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_inline
r_int
id|zfcp_qdio_sbals_from_buffer
(paren
r_struct
id|zfcp_fsf_req
op_star
comma
r_int
r_int
comma
r_void
op_star
comma
r_int
r_int
comma
r_int
)paren
suffix:semicolon
DECL|variable|zfcp_qdio_request_handler
r_static
id|qdio_handler_t
id|zfcp_qdio_request_handler
suffix:semicolon
DECL|variable|zfcp_qdio_response_handler
r_static
id|qdio_handler_t
id|zfcp_qdio_response_handler
suffix:semicolon
r_static
r_int
id|zfcp_qdio_handler_error_check
c_func
(paren
r_struct
id|zfcp_adapter
op_star
comma
r_int
r_int
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
DECL|macro|ZFCP_LOG_AREA
mdefine_line|#define ZFCP_LOG_AREA                   ZFCP_LOG_AREA_QDIO
multiline_comment|/*&n; * Allocates BUFFER memory to each of the pointers of the qdio_buffer_t &n; * array in the adapter struct.&n; * Cur_buf is the pointer array and count can be any number of required &n; * buffers, the page-fitting arithmetic is done entirely within this funciton.&n; *&n; * returns:&t;number of buffers allocated&n; * locks:       must only be called with zfcp_data.config_sema taken&n; */
r_static
r_int
DECL|function|zfcp_qdio_buffers_enqueue
id|zfcp_qdio_buffers_enqueue
c_func
(paren
r_struct
id|qdio_buffer
op_star
op_star
id|cur_buf
comma
r_int
id|count
)paren
(brace
r_int
id|buf_pos
suffix:semicolon
r_int
id|qdio_buffers_per_page
suffix:semicolon
r_int
id|page_pos
op_assign
l_int|0
suffix:semicolon
r_struct
id|qdio_buffer
op_star
id|first_in_page
op_assign
l_int|NULL
suffix:semicolon
id|qdio_buffers_per_page
op_assign
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_struct
id|qdio_buffer
)paren
suffix:semicolon
id|ZFCP_LOG_TRACE
c_func
(paren
l_string|&quot;buffers_per_page=%d&bslash;n&quot;
comma
id|qdio_buffers_per_page
)paren
suffix:semicolon
r_for
c_loop
(paren
id|buf_pos
op_assign
l_int|0
suffix:semicolon
id|buf_pos
OL
id|count
suffix:semicolon
id|buf_pos
op_increment
)paren
(brace
r_if
c_cond
(paren
id|page_pos
op_eq
l_int|0
)paren
(brace
id|cur_buf
(braket
id|buf_pos
)braket
op_assign
(paren
r_struct
id|qdio_buffer
op_star
)paren
id|get_zeroed_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_buf
(braket
id|buf_pos
)braket
op_eq
l_int|NULL
)paren
(brace
id|ZFCP_LOG_INFO
c_func
(paren
l_string|&quot;error: allocation of &quot;
l_string|&quot;QDIO buffer failed &bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|first_in_page
op_assign
id|cur_buf
(braket
id|buf_pos
)braket
suffix:semicolon
)brace
r_else
(brace
id|cur_buf
(braket
id|buf_pos
)braket
op_assign
id|first_in_page
op_plus
id|page_pos
suffix:semicolon
)brace
multiline_comment|/* was initialised to zero */
id|page_pos
op_increment
suffix:semicolon
id|page_pos
op_mod_assign
id|qdio_buffers_per_page
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|buf_pos
suffix:semicolon
)brace
multiline_comment|/*&n; * Frees BUFFER memory for each of the pointers of the struct qdio_buffer array&n; * in the adapter struct cur_buf is the pointer array and count can be any&n; * number of buffers in the array that should be freed starting from buffer 0&n; *&n; * locks:       must only be called with zfcp_data.config_sema taken&n; */
r_static
r_void
DECL|function|zfcp_qdio_buffers_dequeue
id|zfcp_qdio_buffers_dequeue
c_func
(paren
r_struct
id|qdio_buffer
op_star
op_star
id|cur_buf
comma
r_int
id|count
)paren
(brace
r_int
id|buf_pos
suffix:semicolon
r_int
id|qdio_buffers_per_page
suffix:semicolon
id|qdio_buffers_per_page
op_assign
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_struct
id|qdio_buffer
)paren
suffix:semicolon
id|ZFCP_LOG_TRACE
c_func
(paren
l_string|&quot;buffers_per_page=%d&bslash;n&quot;
comma
id|qdio_buffers_per_page
)paren
suffix:semicolon
r_for
c_loop
(paren
id|buf_pos
op_assign
l_int|0
suffix:semicolon
id|buf_pos
OL
id|count
suffix:semicolon
id|buf_pos
op_add_assign
id|qdio_buffers_per_page
)paren
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|cur_buf
(braket
id|buf_pos
)braket
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* locks:       must only be called with zfcp_data.config_sema taken */
r_int
DECL|function|zfcp_qdio_allocate_queues
id|zfcp_qdio_allocate_queues
c_func
(paren
r_struct
id|zfcp_adapter
op_star
id|adapter
)paren
(brace
r_int
id|buffer_count
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|buffer_count
op_assign
id|zfcp_qdio_buffers_enqueue
c_func
(paren
op_amp
(paren
id|adapter-&gt;request_queue.buffer
(braket
l_int|0
)braket
)paren
comma
id|QDIO_MAX_BUFFERS_PER_Q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_count
OL
id|QDIO_MAX_BUFFERS_PER_Q
)paren
(brace
id|ZFCP_LOG_DEBUG
c_func
(paren
l_string|&quot;only %d QDIO buffers allocated for request &quot;
l_string|&quot;queue&bslash;n&quot;
comma
id|buffer_count
)paren
suffix:semicolon
id|zfcp_qdio_buffers_dequeue
c_func
(paren
op_amp
(paren
id|adapter-&gt;request_queue.buffer
(braket
l_int|0
)braket
)paren
comma
id|buffer_count
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|buffer_count
op_assign
id|zfcp_qdio_buffers_enqueue
c_func
(paren
op_amp
(paren
id|adapter-&gt;response_queue.buffer
(braket
l_int|0
)braket
)paren
comma
id|QDIO_MAX_BUFFERS_PER_Q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_count
OL
id|QDIO_MAX_BUFFERS_PER_Q
)paren
(brace
id|ZFCP_LOG_DEBUG
c_func
(paren
l_string|&quot;only %d QDIO buffers allocated for response &quot;
l_string|&quot;queue&quot;
comma
id|buffer_count
)paren
suffix:semicolon
id|zfcp_qdio_buffers_dequeue
c_func
(paren
op_amp
(paren
id|adapter-&gt;response_queue.buffer
(braket
l_int|0
)braket
)paren
comma
id|buffer_count
)paren
suffix:semicolon
id|ZFCP_LOG_TRACE
c_func
(paren
l_string|&quot;freeing request_queue buffers&bslash;n&quot;
)paren
suffix:semicolon
id|zfcp_qdio_buffers_dequeue
c_func
(paren
op_amp
(paren
id|adapter-&gt;request_queue.buffer
(braket
l_int|0
)braket
)paren
comma
id|QDIO_MAX_BUFFERS_PER_Q
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* locks:       must only be called with zfcp_data.config_sema taken */
r_void
DECL|function|zfcp_qdio_free_queues
id|zfcp_qdio_free_queues
c_func
(paren
r_struct
id|zfcp_adapter
op_star
id|adapter
)paren
(brace
id|ZFCP_LOG_TRACE
c_func
(paren
l_string|&quot;freeing request_queue buffers&bslash;n&quot;
)paren
suffix:semicolon
id|zfcp_qdio_buffers_dequeue
c_func
(paren
op_amp
(paren
id|adapter-&gt;request_queue.buffer
(braket
l_int|0
)braket
)paren
comma
id|QDIO_MAX_BUFFERS_PER_Q
)paren
suffix:semicolon
id|ZFCP_LOG_TRACE
c_func
(paren
l_string|&quot;freeing response_queue buffers&bslash;n&quot;
)paren
suffix:semicolon
id|zfcp_qdio_buffers_dequeue
c_func
(paren
op_amp
(paren
id|adapter-&gt;response_queue.buffer
(braket
l_int|0
)braket
)paren
comma
id|QDIO_MAX_BUFFERS_PER_Q
)paren
suffix:semicolon
)brace
r_int
DECL|function|zfcp_qdio_allocate
id|zfcp_qdio_allocate
c_func
(paren
r_struct
id|zfcp_adapter
op_star
id|adapter
)paren
(brace
r_struct
id|qdio_initialize
op_star
id|init_data
suffix:semicolon
id|init_data
op_assign
op_amp
id|adapter-&gt;qdio_init_data
suffix:semicolon
id|init_data-&gt;cdev
op_assign
id|adapter-&gt;ccw_device
suffix:semicolon
id|init_data-&gt;q_format
op_assign
id|QDIO_SCSI_QFMT
suffix:semicolon
id|memcpy
c_func
(paren
id|init_data-&gt;adapter_name
comma
op_amp
id|adapter-&gt;name
comma
l_int|8
)paren
suffix:semicolon
id|init_data-&gt;qib_param_field_format
op_assign
l_int|0
suffix:semicolon
id|init_data-&gt;qib_param_field
op_assign
l_int|NULL
suffix:semicolon
id|init_data-&gt;input_slib_elements
op_assign
l_int|NULL
suffix:semicolon
id|init_data-&gt;output_slib_elements
op_assign
l_int|NULL
suffix:semicolon
id|init_data-&gt;min_input_threshold
op_assign
id|ZFCP_MIN_INPUT_THRESHOLD
suffix:semicolon
id|init_data-&gt;max_input_threshold
op_assign
id|ZFCP_MAX_INPUT_THRESHOLD
suffix:semicolon
id|init_data-&gt;min_output_threshold
op_assign
id|ZFCP_MIN_OUTPUT_THRESHOLD
suffix:semicolon
id|init_data-&gt;max_output_threshold
op_assign
id|ZFCP_MAX_OUTPUT_THRESHOLD
suffix:semicolon
id|init_data-&gt;no_input_qs
op_assign
l_int|1
suffix:semicolon
id|init_data-&gt;no_output_qs
op_assign
l_int|1
suffix:semicolon
id|init_data-&gt;input_handler
op_assign
id|zfcp_qdio_response_handler
suffix:semicolon
id|init_data-&gt;output_handler
op_assign
id|zfcp_qdio_request_handler
suffix:semicolon
id|init_data-&gt;int_parm
op_assign
(paren
r_int
r_int
)paren
id|adapter
suffix:semicolon
id|init_data-&gt;flags
op_assign
id|QDIO_INBOUND_0COPY_SBALS
op_or
id|QDIO_OUTBOUND_0COPY_SBALS
op_or
id|QDIO_USE_OUTBOUND_PCIS
suffix:semicolon
id|init_data-&gt;input_sbal_addr_array
op_assign
(paren
r_void
op_star
op_star
)paren
(paren
id|adapter-&gt;response_queue.buffer
)paren
suffix:semicolon
id|init_data-&gt;output_sbal_addr_array
op_assign
(paren
r_void
op_star
op_star
)paren
(paren
id|adapter-&gt;request_queue.buffer
)paren
suffix:semicolon
r_return
id|qdio_allocate
c_func
(paren
id|init_data
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * function:   &t;zfcp_qdio_handler_error_check&n; *&n; * purpose:     called by the response handler to determine error condition&n; *&n; * returns:&t;error flag&n; *&n; */
r_static
r_inline
r_int
DECL|function|zfcp_qdio_handler_error_check
id|zfcp_qdio_handler_error_check
c_func
(paren
r_struct
id|zfcp_adapter
op_star
id|adapter
comma
r_int
r_int
id|status
comma
r_int
r_int
id|qdio_error
comma
r_int
r_int
id|siga_error
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ZFCP_LOG_CHECK
c_func
(paren
id|ZFCP_LOG_LEVEL_TRACE
)paren
)paren
(brace
r_if
c_cond
(paren
id|status
op_amp
id|QDIO_STATUS_INBOUND_INT
)paren
(brace
id|ZFCP_LOG_TRACE
c_func
(paren
l_string|&quot;status is&quot;
l_string|&quot; QDIO_STATUS_INBOUND_INT &bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|QDIO_STATUS_OUTBOUND_INT
)paren
(brace
id|ZFCP_LOG_TRACE
c_func
(paren
l_string|&quot;status is&quot;
l_string|&quot; QDIO_STATUS_OUTBOUND_INT &bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// if (ZFCP_LOG_CHECK(ZFCP_LOG_LEVEL_TRACE))
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|status
op_amp
id|QDIO_STATUS_LOOK_FOR_ERROR
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
id|ZFCP_LOG_FLAGS
c_func
(paren
l_int|1
comma
l_string|&quot;QDIO_STATUS_LOOK_FOR_ERROR &bslash;n&quot;
)paren
suffix:semicolon
id|ZFCP_LOG_INFO
c_func
(paren
l_string|&quot;QDIO problem occurred (status=0x%x, &quot;
l_string|&quot;qdio_error=0x%x, siga_error=0x%x)&bslash;n&quot;
comma
id|status
comma
id|qdio_error
comma
id|siga_error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|QDIO_STATUS_ACTIVATE_CHECK_CONDITION
)paren
(brace
id|ZFCP_LOG_FLAGS
c_func
(paren
l_int|2
comma
l_string|&quot;QDIO_STATUS_ACTIVATE_CHECK_CONDITION&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|QDIO_STATUS_MORE_THAN_ONE_QDIO_ERROR
)paren
(brace
id|ZFCP_LOG_FLAGS
c_func
(paren
l_int|2
comma
l_string|&quot;QDIO_STATUS_MORE_THAN_ONE_QDIO_ERROR&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|QDIO_STATUS_MORE_THAN_ONE_SIGA_ERROR
)paren
(brace
id|ZFCP_LOG_FLAGS
c_func
(paren
l_int|2
comma
l_string|&quot;QDIO_STATUS_MORE_THAN_ONE_SIGA_ERROR&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|siga_error
op_amp
id|QDIO_SIGA_ERROR_ACCESS_EXCEPTION
)paren
(brace
id|ZFCP_LOG_FLAGS
c_func
(paren
l_int|2
comma
l_string|&quot;QDIO_SIGA_ERROR_ACCESS_EXCEPTION&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|siga_error
op_amp
id|QDIO_SIGA_ERROR_B_BIT_SET
)paren
(brace
id|ZFCP_LOG_FLAGS
c_func
(paren
l_int|2
comma
l_string|&quot;QDIO_SIGA_ERROR_B_BIT_SET&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|qdio_error
)paren
(brace
r_case
l_int|0
suffix:colon
id|ZFCP_LOG_FLAGS
c_func
(paren
l_int|3
comma
l_string|&quot;QDIO_OK&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SLSB_P_INPUT_ERROR
suffix:colon
id|ZFCP_LOG_FLAGS
c_func
(paren
l_int|1
comma
l_string|&quot;SLSB_P_INPUT_ERROR&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SLSB_P_OUTPUT_ERROR
suffix:colon
id|ZFCP_LOG_FLAGS
c_func
(paren
l_int|1
comma
l_string|&quot;SLSB_P_OUTPUT_ERROR&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ZFCP_LOG_NORMAL
c_func
(paren
l_string|&quot;bug: unknown QDIO error 0x%x&bslash;n&quot;
comma
id|qdio_error
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Restarting IO on the failed adapter from scratch */
id|debug_text_event
c_func
(paren
id|adapter-&gt;erp_dbf
comma
l_int|1
comma
l_string|&quot;qdio_err&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;                * Since we have been using this adapter, it is save to assume&n;                * that it is not failed but recoverable. The card seems to&n;                * report link-up events by self-initiated queue shutdown.&n;                * That is why we need to clear the the link-down flag&n;                * which is set again in case we have missed by a mile.&n;                */
id|zfcp_erp_adapter_reopen
c_func
(paren
id|adapter
comma
id|ZFCP_STATUS_ADAPTER_LINK_UNPLUGGED
op_or
id|ZFCP_STATUS_COMMON_ERP_FAILED
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * function:    zfcp_qdio_request_handler&n; *&n; * purpose:&t;is called by QDIO layer for completed SBALs in request queue&n; *&n; * returns:&t;(void)&n; */
r_static
r_void
DECL|function|zfcp_qdio_request_handler
id|zfcp_qdio_request_handler
c_func
(paren
r_struct
id|ccw_device
op_star
id|ccw_device
comma
r_int
r_int
id|status
comma
r_int
r_int
id|qdio_error
comma
r_int
r_int
id|siga_error
comma
r_int
r_int
id|queue_number
comma
r_int
id|first_element
comma
r_int
id|elements_processed
comma
r_int
r_int
id|int_parm
)paren
(brace
r_struct
id|zfcp_adapter
op_star
id|adapter
suffix:semicolon
r_struct
id|zfcp_qdio_queue
op_star
id|queue
suffix:semicolon
id|adapter
op_assign
(paren
r_struct
id|zfcp_adapter
op_star
)paren
id|int_parm
suffix:semicolon
id|queue
op_assign
op_amp
id|adapter-&gt;request_queue
suffix:semicolon
id|ZFCP_LOG_DEBUG
c_func
(paren
l_string|&quot;adapter %s, first=%d, elements_processed=%d&bslash;n&quot;
comma
id|zfcp_get_busid_by_adapter
c_func
(paren
id|adapter
)paren
comma
id|first_element
comma
id|elements_processed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|zfcp_qdio_handler_error_check
c_func
(paren
id|adapter
comma
id|status
comma
id|qdio_error
comma
id|siga_error
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * we stored address of struct zfcp_adapter  data structure&n;&t; * associated with irq in int_parm&n;&t; */
multiline_comment|/* cleanup all SBALs being program-owned now */
id|zfcp_qdio_zero_sbals
c_func
(paren
id|queue-&gt;buffer
comma
id|first_element
comma
id|elements_processed
)paren
suffix:semicolon
multiline_comment|/* increase free space in outbound queue */
id|atomic_add
c_func
(paren
id|elements_processed
comma
op_amp
id|queue-&gt;free_count
)paren
suffix:semicolon
id|ZFCP_LOG_DEBUG
c_func
(paren
l_string|&quot;free_count=%d&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|queue-&gt;free_count
)paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|adapter-&gt;request_wq
)paren
suffix:semicolon
id|ZFCP_LOG_DEBUG
c_func
(paren
l_string|&quot;elements_processed=%d, free count=%d&bslash;n&quot;
comma
id|elements_processed
comma
id|atomic_read
c_func
(paren
op_amp
id|queue-&gt;free_count
)paren
)paren
suffix:semicolon
id|out
suffix:colon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * function:   &t;zfcp_qdio_response_handler&n; *&n; * purpose:&t;is called by QDIO layer for completed SBALs in response queue&n; *&n; * returns:&t;(void)&n; */
r_static
r_void
DECL|function|zfcp_qdio_response_handler
id|zfcp_qdio_response_handler
c_func
(paren
r_struct
id|ccw_device
op_star
id|ccw_device
comma
r_int
r_int
id|status
comma
r_int
r_int
id|qdio_error
comma
r_int
r_int
id|siga_error
comma
r_int
r_int
id|queue_number
comma
r_int
id|first_element
comma
r_int
id|elements_processed
comma
r_int
r_int
id|int_parm
)paren
(brace
r_struct
id|zfcp_adapter
op_star
id|adapter
suffix:semicolon
r_struct
id|zfcp_qdio_queue
op_star
id|queue
suffix:semicolon
r_int
id|buffer_index
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|qdio_buffer
op_star
id|buffer
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|u8
id|count
suffix:semicolon
id|u8
id|start
suffix:semicolon
r_volatile
r_struct
id|qdio_buffer_element
op_star
id|buffere
op_assign
l_int|NULL
suffix:semicolon
r_int
id|buffere_index
suffix:semicolon
id|adapter
op_assign
(paren
r_struct
id|zfcp_adapter
op_star
)paren
id|int_parm
suffix:semicolon
id|queue
op_assign
op_amp
id|adapter-&gt;response_queue
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|zfcp_qdio_handler_error_check
c_func
(paren
id|adapter
comma
id|status
comma
id|qdio_error
comma
id|siga_error
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * we stored address of struct zfcp_adapter  data structure&n;&t; * associated with irq in int_parm&n;&t; */
id|buffere
op_assign
op_amp
(paren
id|queue-&gt;buffer
(braket
id|first_element
)braket
op_member_access_from_pointer
id|element
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|ZFCP_LOG_DEBUG
c_func
(paren
l_string|&quot;first BUFFERE flags=0x%x&bslash;n&quot;
comma
id|buffere-&gt;flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * go through all SBALs from input queue currently&n;&t; * returned by QDIO layer&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|elements_processed
suffix:semicolon
id|i
op_increment
)paren
(brace
id|buffer_index
op_assign
id|first_element
op_plus
id|i
suffix:semicolon
id|buffer_index
op_mod_assign
id|QDIO_MAX_BUFFERS_PER_Q
suffix:semicolon
id|buffer
op_assign
id|queue-&gt;buffer
(braket
id|buffer_index
)braket
suffix:semicolon
multiline_comment|/* go through all SBALEs of SBAL */
r_for
c_loop
(paren
id|buffere_index
op_assign
l_int|0
suffix:semicolon
id|buffere_index
OL
id|QDIO_MAX_ELEMENTS_PER_BUFFER
suffix:semicolon
id|buffere_index
op_increment
)paren
(brace
multiline_comment|/* look for QDIO request identifiers in SB */
id|buffere
op_assign
op_amp
id|buffer-&gt;element
(braket
id|buffere_index
)braket
suffix:semicolon
id|retval
op_assign
id|zfcp_qdio_reqid_check
c_func
(paren
id|adapter
comma
(paren
r_void
op_star
)paren
id|buffere-&gt;addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|ZFCP_LOG_NORMAL
c_func
(paren
l_string|&quot;bug: unexpected inbound &quot;
l_string|&quot;packet on adapter %s &quot;
l_string|&quot;(reqid=0x%lx, &quot;
l_string|&quot;first_element=%d, &quot;
l_string|&quot;elements_processed=%d)&bslash;n&quot;
comma
id|zfcp_get_busid_by_adapter
c_func
(paren
id|adapter
)paren
comma
(paren
r_int
r_int
)paren
id|buffere-&gt;addr
comma
id|first_element
comma
id|elements_processed
)paren
suffix:semicolon
id|ZFCP_LOG_NORMAL
c_func
(paren
l_string|&quot;hex dump of inbound buffer &quot;
l_string|&quot;at address %p &quot;
l_string|&quot;(buffer_index=%d, &quot;
l_string|&quot;buffere_index=%d)&bslash;n&quot;
comma
id|buffer
comma
id|buffer_index
comma
id|buffere_index
)paren
suffix:semicolon
id|ZFCP_HEX_DUMP
c_func
(paren
id|ZFCP_LOG_LEVEL_NORMAL
comma
(paren
r_char
op_star
)paren
id|buffer
comma
id|SBAL_SIZE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * A single used SBALE per inbound SBALE has been&n;&t;&t;&t; * implemented by QDIO so far. Hope they will&n;&t;&t;&t; * do some optimisation. Will need to change to&n;&t;&t;&t; * unlikely() then.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|buffere-&gt;flags
op_amp
id|SBAL_FLAGS_LAST_ENTRY
)paren
)paren
r_break
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
(paren
id|buffere-&gt;flags
op_amp
id|SBAL_FLAGS_LAST_ENTRY
)paren
)paren
)paren
(brace
id|ZFCP_LOG_NORMAL
c_func
(paren
l_string|&quot;bug: End of inbound data &quot;
l_string|&quot;not marked!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * put range of SBALs back to response queue&n;&t; * (including SBALs which have already been free before)&n;&t; */
id|count
op_assign
id|atomic_read
c_func
(paren
op_amp
id|queue-&gt;free_count
)paren
op_plus
id|elements_processed
suffix:semicolon
id|start
op_assign
id|queue-&gt;free_index
suffix:semicolon
id|ZFCP_LOG_TRACE
c_func
(paren
l_string|&quot;calling do_QDIO on adapter %s (flags=0x%x, &quot;
l_string|&quot;queue_no=%i, index_in_queue=%i, count=%i, &quot;
l_string|&quot;buffers=0x%lx&bslash;n&quot;
comma
id|zfcp_get_busid_by_adapter
c_func
(paren
id|adapter
)paren
comma
id|QDIO_FLAG_SYNC_INPUT
op_or
id|QDIO_FLAG_UNDER_INTERRUPT
comma
l_int|0
comma
id|start
comma
id|count
comma
(paren
r_int
r_int
)paren
op_amp
id|queue-&gt;buffer
(braket
id|start
)braket
)paren
suffix:semicolon
id|retval
op_assign
id|do_QDIO
c_func
(paren
id|ccw_device
comma
id|QDIO_FLAG_SYNC_INPUT
op_or
id|QDIO_FLAG_UNDER_INTERRUPT
comma
l_int|0
comma
id|start
comma
id|count
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|retval
)paren
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|queue-&gt;free_count
comma
id|count
)paren
suffix:semicolon
id|ZFCP_LOG_DEBUG
c_func
(paren
l_string|&quot;clearing of inbound data regions failed, &quot;
l_string|&quot;queues may be down &quot;
l_string|&quot;(count=%d, start=%d, retval=%d)&bslash;n&quot;
comma
id|count
comma
id|start
comma
id|retval
)paren
suffix:semicolon
)brace
r_else
(brace
id|queue-&gt;free_index
op_add_assign
id|count
suffix:semicolon
id|queue-&gt;free_index
op_mod_assign
id|QDIO_MAX_BUFFERS_PER_Q
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|queue-&gt;free_count
comma
l_int|0
)paren
suffix:semicolon
id|ZFCP_LOG_TRACE
c_func
(paren
l_string|&quot;%i buffers enqueued to response &quot;
l_string|&quot;queue at position %i&bslash;n&quot;
comma
id|count
comma
id|start
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * function:&t;zfcp_qdio_reqid_check&n; *&n; * purpose:&t;checks for valid reqids or unsolicited status&n; *&n; * returns:&t;0 - valid request id or unsolicited status&n; *&t;&t;!0 - otherwise&n; */
r_int
DECL|function|zfcp_qdio_reqid_check
id|zfcp_qdio_reqid_check
c_func
(paren
r_struct
id|zfcp_adapter
op_star
id|adapter
comma
r_void
op_star
id|sbale_addr
)paren
(brace
r_struct
id|zfcp_fsf_req
op_star
id|fsf_req
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* invalid (per convention used in this driver) */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|sbale_addr
)paren
)paren
(brace
id|ZFCP_LOG_NORMAL
c_func
(paren
l_string|&quot;bug: invalid reqid&bslash;n&quot;
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* valid request id and thus (hopefully :) valid fsf_req address */
id|fsf_req
op_assign
(paren
r_struct
id|zfcp_fsf_req
op_star
)paren
id|sbale_addr
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|adapter
op_ne
id|fsf_req-&gt;adapter
)paren
)paren
(brace
id|ZFCP_LOG_NORMAL
c_func
(paren
l_string|&quot;bug: invalid reqid (fsf_req=%p, &quot;
l_string|&quot;fsf_req-&gt;adapter=%p, adapter=%p)&bslash;n&quot;
comma
id|fsf_req
comma
id|fsf_req-&gt;adapter
comma
id|adapter
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|ZFCP_LOG_TRACE
c_func
(paren
l_string|&quot;fsf_req at %p, QTCB at %p&bslash;n&quot;
comma
id|fsf_req
comma
id|fsf_req-&gt;qtcb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|fsf_req-&gt;qtcb
)paren
)paren
(brace
id|ZFCP_LOG_TRACE
c_func
(paren
l_string|&quot;hex dump of QTCB:&bslash;n&quot;
)paren
suffix:semicolon
id|ZFCP_HEX_DUMP
c_func
(paren
id|ZFCP_LOG_LEVEL_TRACE
comma
(paren
r_char
op_star
)paren
id|fsf_req-&gt;qtcb
comma
r_sizeof
(paren
r_struct
id|fsf_qtcb
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* finish the FSF request */
id|zfcp_fsf_req_complete
c_func
(paren
id|fsf_req
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; * zfcp_qdio_sbale_get - return pointer to SBALE of qdio_queue&n; * @queue: queue from which SBALE should be returned&n; * @sbal: specifies number of SBAL in queue&n; * @sbale: specifes number of SBALE in SBAL&n; */
r_static
r_inline
r_volatile
r_struct
id|qdio_buffer_element
op_star
DECL|function|zfcp_qdio_sbale_get
id|zfcp_qdio_sbale_get
c_func
(paren
r_struct
id|zfcp_qdio_queue
op_star
id|queue
comma
r_int
id|sbal
comma
r_int
id|sbale
)paren
(brace
r_return
op_amp
id|queue-&gt;buffer
(braket
id|sbal
)braket
op_member_access_from_pointer
id|element
(braket
id|sbale
)braket
suffix:semicolon
)brace
multiline_comment|/**&n; * zfcp_qdio_sbale_req - return pointer to SBALE of request_queue for&n; *&t;a struct zfcp_fsf_req&n; */
r_inline
r_volatile
r_struct
id|qdio_buffer_element
op_star
DECL|function|zfcp_qdio_sbale_req
id|zfcp_qdio_sbale_req
c_func
(paren
r_struct
id|zfcp_fsf_req
op_star
id|fsf_req
comma
r_int
id|sbal
comma
r_int
id|sbale
)paren
(brace
r_return
id|zfcp_qdio_sbale_get
c_func
(paren
op_amp
id|fsf_req-&gt;adapter-&gt;request_queue
comma
id|sbal
comma
id|sbale
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * zfcp_qdio_sbale_resp - return pointer to SBALE of response_queue for&n; *&t;a struct zfcp_fsf_req&n; */
r_static
r_inline
r_volatile
r_struct
id|qdio_buffer_element
op_star
DECL|function|zfcp_qdio_sbale_resp
id|zfcp_qdio_sbale_resp
c_func
(paren
r_struct
id|zfcp_fsf_req
op_star
id|fsf_req
comma
r_int
id|sbal
comma
r_int
id|sbale
)paren
(brace
r_return
id|zfcp_qdio_sbale_get
c_func
(paren
op_amp
id|fsf_req-&gt;adapter-&gt;response_queue
comma
id|sbal
comma
id|sbale
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * zfcp_qdio_sbale_curr - return current SBALE on request_queue for&n; *&t;a struct zfcp_fsf_req&n; */
r_inline
r_volatile
r_struct
id|qdio_buffer_element
op_star
DECL|function|zfcp_qdio_sbale_curr
id|zfcp_qdio_sbale_curr
c_func
(paren
r_struct
id|zfcp_fsf_req
op_star
id|fsf_req
)paren
(brace
r_return
id|zfcp_qdio_sbale_req
c_func
(paren
id|fsf_req
comma
id|fsf_req-&gt;sbal_curr
comma
id|fsf_req-&gt;sbale_curr
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * zfcp_qdio_sbal_limit - determine maximum number of SBALs that can be used&n; *&t;on the request_queue for a struct zfcp_fsf_req&n; * @fsf_req: the number of the last SBAL that can be used is stored herein&n; * @max_sbals: used to pass an upper limit for the number of SBALs&n; *&n; * Note: We can assume at least one free SBAL in the request_queue when called.&n; */
r_static
r_inline
r_void
DECL|function|zfcp_qdio_sbal_limit
id|zfcp_qdio_sbal_limit
c_func
(paren
r_struct
id|zfcp_fsf_req
op_star
id|fsf_req
comma
r_int
id|max_sbals
)paren
(brace
r_int
id|count
op_assign
id|atomic_read
c_func
(paren
op_amp
id|fsf_req-&gt;adapter-&gt;request_queue.free_count
)paren
suffix:semicolon
id|count
op_assign
id|min
c_func
(paren
id|count
comma
id|max_sbals
)paren
suffix:semicolon
id|fsf_req-&gt;sbal_last
op_assign
id|fsf_req-&gt;sbal_first
suffix:semicolon
id|fsf_req-&gt;sbal_last
op_add_assign
(paren
id|count
op_minus
l_int|1
)paren
suffix:semicolon
id|fsf_req-&gt;sbal_last
op_mod_assign
id|QDIO_MAX_BUFFERS_PER_Q
suffix:semicolon
)brace
multiline_comment|/**&n; * zfcp_qdio_sbal_chain - chain SBALs if more than one SBAL is needed for a&n; *&t;request&n; * @fsf_req: zfcp_fsf_req to be processed&n; * @sbtype: SBAL flags which have to be set in first SBALE of new SBAL&n; *&n; * This function changes sbal_curr, sbale_curr, sbal_number of fsf_req.&n; */
r_static
r_inline
r_volatile
r_struct
id|qdio_buffer_element
op_star
DECL|function|zfcp_qdio_sbal_chain
id|zfcp_qdio_sbal_chain
c_func
(paren
r_struct
id|zfcp_fsf_req
op_star
id|fsf_req
comma
r_int
r_int
id|sbtype
)paren
(brace
r_volatile
r_struct
id|qdio_buffer_element
op_star
id|sbale
suffix:semicolon
multiline_comment|/* set last entry flag in current SBALE of current SBAL */
id|sbale
op_assign
id|zfcp_qdio_sbale_curr
c_func
(paren
id|fsf_req
)paren
suffix:semicolon
id|sbale-&gt;flags
op_or_assign
id|SBAL_FLAGS_LAST_ENTRY
suffix:semicolon
multiline_comment|/* don&squot;t exceed last allowed SBAL */
r_if
c_cond
(paren
id|fsf_req-&gt;sbal_curr
op_eq
id|fsf_req-&gt;sbal_last
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* set chaining flag in first SBALE of current SBAL */
id|sbale
op_assign
id|zfcp_qdio_sbale_req
c_func
(paren
id|fsf_req
comma
id|fsf_req-&gt;sbal_curr
comma
l_int|0
)paren
suffix:semicolon
id|sbale-&gt;flags
op_or_assign
id|SBAL_FLAGS0_MORE_SBALS
suffix:semicolon
multiline_comment|/* calculate index of next SBAL */
id|fsf_req-&gt;sbal_curr
op_increment
suffix:semicolon
id|fsf_req-&gt;sbal_curr
op_mod_assign
id|QDIO_MAX_BUFFERS_PER_Q
suffix:semicolon
multiline_comment|/* keep this requests number of SBALs up-to-date */
id|fsf_req-&gt;sbal_number
op_increment
suffix:semicolon
multiline_comment|/* start at first SBALE of new SBAL */
id|fsf_req-&gt;sbale_curr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set storage-block type for new SBAL */
id|sbale
op_assign
id|zfcp_qdio_sbale_curr
c_func
(paren
id|fsf_req
)paren
suffix:semicolon
id|sbale-&gt;flags
op_or_assign
id|sbtype
suffix:semicolon
r_return
id|sbale
suffix:semicolon
)brace
multiline_comment|/**&n; * zfcp_qdio_sbale_next - switch to next SBALE, chain SBALs if needed&n; */
r_static
r_inline
r_volatile
r_struct
id|qdio_buffer_element
op_star
DECL|function|zfcp_qdio_sbale_next
id|zfcp_qdio_sbale_next
c_func
(paren
r_struct
id|zfcp_fsf_req
op_star
id|fsf_req
comma
r_int
r_int
id|sbtype
)paren
(brace
r_if
c_cond
(paren
id|fsf_req-&gt;sbale_curr
op_eq
id|ZFCP_LAST_SBALE_PER_SBAL
)paren
r_return
id|zfcp_qdio_sbal_chain
c_func
(paren
id|fsf_req
comma
id|sbtype
)paren
suffix:semicolon
id|fsf_req-&gt;sbale_curr
op_increment
suffix:semicolon
r_return
id|zfcp_qdio_sbale_curr
c_func
(paren
id|fsf_req
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * zfcp_qdio_sbals_zero - initialize SBALs between first and last in queue&n; *&t;with zero from&n; */
r_static
r_inline
r_int
DECL|function|zfcp_qdio_sbals_zero
id|zfcp_qdio_sbals_zero
c_func
(paren
r_struct
id|zfcp_qdio_queue
op_star
id|queue
comma
r_int
id|first
comma
r_int
id|last
)paren
(brace
r_struct
id|qdio_buffer
op_star
op_star
id|buf
op_assign
id|queue-&gt;buffer
suffix:semicolon
r_int
id|curr
op_assign
id|first
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|curr
op_mod_assign
id|QDIO_MAX_BUFFERS_PER_Q
suffix:semicolon
id|count
op_increment
suffix:semicolon
id|memset
c_func
(paren
id|buf
(braket
id|curr
)braket
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|qdio_buffer
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|curr
op_eq
id|last
)paren
r_break
suffix:semicolon
id|curr
op_increment
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/**&n; * zfcp_qdio_sbals_wipe - reset all changes in SBALs for an fsf_req&n; */
r_static
r_inline
r_int
DECL|function|zfcp_qdio_sbals_wipe
id|zfcp_qdio_sbals_wipe
c_func
(paren
r_struct
id|zfcp_fsf_req
op_star
id|fsf_req
)paren
(brace
r_return
id|zfcp_qdio_sbals_zero
c_func
(paren
op_amp
id|fsf_req-&gt;adapter-&gt;request_queue
comma
id|fsf_req-&gt;sbal_first
comma
id|fsf_req-&gt;sbal_curr
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * zfcp_qdio_sbale_fill - set address and lenght in current SBALE&n; *&t;on request_queue&n; */
r_static
r_inline
r_void
DECL|function|zfcp_qdio_sbale_fill
id|zfcp_qdio_sbale_fill
c_func
(paren
r_struct
id|zfcp_fsf_req
op_star
id|fsf_req
comma
r_int
r_int
id|sbtype
comma
r_void
op_star
id|addr
comma
r_int
id|length
)paren
(brace
r_volatile
r_struct
id|qdio_buffer_element
op_star
id|sbale
suffix:semicolon
id|sbale
op_assign
id|zfcp_qdio_sbale_curr
c_func
(paren
id|fsf_req
)paren
suffix:semicolon
id|sbale-&gt;addr
op_assign
id|addr
suffix:semicolon
id|sbale-&gt;length
op_assign
id|length
suffix:semicolon
)brace
multiline_comment|/**&n; * zfcp_qdio_sbals_from_segment - map memory segment to SBALE(s)&n; * @fsf_req: request to be processed&n; * @sbtype: SBALE flags&n; * @start_addr: address of memory segment&n; * @total_length: length of memory segment&n; *&n; * Alignment and length of the segment determine how many SBALEs are needed&n; * for the memory segment.&n; */
r_static
r_inline
r_int
DECL|function|zfcp_qdio_sbals_from_segment
id|zfcp_qdio_sbals_from_segment
c_func
(paren
r_struct
id|zfcp_fsf_req
op_star
id|fsf_req
comma
r_int
r_int
id|sbtype
comma
r_void
op_star
id|start_addr
comma
r_int
r_int
id|total_length
)paren
(brace
r_int
r_int
id|remaining
comma
id|length
suffix:semicolon
r_void
op_star
id|addr
suffix:semicolon
multiline_comment|/* split segment up heeding page boundaries */
r_for
c_loop
(paren
id|addr
op_assign
id|start_addr
comma
id|remaining
op_assign
id|total_length
suffix:semicolon
id|remaining
OG
l_int|0
suffix:semicolon
id|addr
op_add_assign
id|length
comma
id|remaining
op_sub_assign
id|length
)paren
(brace
multiline_comment|/* get next free SBALE for new piece */
r_if
c_cond
(paren
l_int|NULL
op_eq
id|zfcp_qdio_sbale_next
c_func
(paren
id|fsf_req
comma
id|sbtype
)paren
)paren
(brace
multiline_comment|/* no SBALE left, clean up and leave */
id|zfcp_qdio_sbals_wipe
c_func
(paren
id|fsf_req
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* calculate length of new piece */
id|length
op_assign
id|min
c_func
(paren
id|remaining
comma
(paren
id|PAGE_SIZE
op_minus
(paren
(paren
r_int
r_int
)paren
id|addr
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* fill current SBALE with calculated piece */
id|zfcp_qdio_sbale_fill
c_func
(paren
id|fsf_req
comma
id|sbtype
comma
id|addr
comma
id|length
)paren
suffix:semicolon
)brace
r_return
id|total_length
suffix:semicolon
)brace
multiline_comment|/**&n; * zfcp_qdio_sbals_from_sg - fill SBALs from scatter-gather list&n; * @fsf_req: request to be processed&n; * @sbtype: SBALE flags&n; * @sg: scatter-gather list&n; * @sg_count: number of elements in scatter-gather list&n; * @max_sbals: upper bound for number of SBALs to be used&n; */
r_inline
r_int
DECL|function|zfcp_qdio_sbals_from_sg
id|zfcp_qdio_sbals_from_sg
c_func
(paren
r_struct
id|zfcp_fsf_req
op_star
id|fsf_req
comma
r_int
r_int
id|sbtype
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|sg_count
comma
r_int
id|max_sbals
)paren
(brace
r_int
id|sg_index
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg_segment
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_volatile
r_struct
id|qdio_buffer_element
op_star
id|sbale
suffix:semicolon
r_int
id|bytes
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* figure out last allowed SBAL */
id|zfcp_qdio_sbal_limit
c_func
(paren
id|fsf_req
comma
id|max_sbals
)paren
suffix:semicolon
multiline_comment|/* set storage-block type for current SBAL */
id|sbale
op_assign
id|zfcp_qdio_sbale_req
c_func
(paren
id|fsf_req
comma
id|fsf_req-&gt;sbal_curr
comma
l_int|0
)paren
suffix:semicolon
id|sbale-&gt;flags
op_or_assign
id|sbtype
suffix:semicolon
multiline_comment|/* process all segements of scatter-gather list */
r_for
c_loop
(paren
id|sg_index
op_assign
l_int|0
comma
id|sg_segment
op_assign
id|sg
comma
id|bytes
op_assign
l_int|0
suffix:semicolon
id|sg_index
OL
id|sg_count
suffix:semicolon
id|sg_index
op_increment
comma
id|sg_segment
op_increment
)paren
(brace
id|retval
op_assign
id|zfcp_qdio_sbals_from_segment
c_func
(paren
id|fsf_req
comma
id|sbtype
comma
id|zfcp_sg_to_address
c_func
(paren
id|sg_segment
)paren
comma
id|sg_segment-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
id|bytes
op_assign
id|retval
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_else
id|bytes
op_add_assign
id|retval
suffix:semicolon
)brace
multiline_comment|/* assume that no other SBALEs are to follow in the same SBAL */
id|sbale
op_assign
id|zfcp_qdio_sbale_curr
c_func
(paren
id|fsf_req
)paren
suffix:semicolon
id|sbale-&gt;flags
op_or_assign
id|SBAL_FLAGS_LAST_ENTRY
suffix:semicolon
id|out
suffix:colon
r_return
id|bytes
suffix:semicolon
)brace
multiline_comment|/**&n; * zfcp_qdio_sbals_from_buffer - fill SBALs from buffer&n; * @fsf_req: request to be processed&n; * @sbtype: SBALE flags&n; * @buffer: data buffer&n; * @length: length of buffer&n; * @max_sbals: upper bound for number of SBALs to be used&n; */
r_static
r_inline
r_int
DECL|function|zfcp_qdio_sbals_from_buffer
id|zfcp_qdio_sbals_from_buffer
c_func
(paren
r_struct
id|zfcp_fsf_req
op_star
id|fsf_req
comma
r_int
r_int
id|sbtype
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|length
comma
r_int
id|max_sbals
)paren
(brace
r_struct
id|scatterlist
id|sg_segment
suffix:semicolon
id|zfcp_address_to_sg
c_func
(paren
id|buffer
comma
op_amp
id|sg_segment
)paren
suffix:semicolon
id|sg_segment.length
op_assign
id|length
suffix:semicolon
r_return
id|zfcp_qdio_sbals_from_sg
c_func
(paren
id|fsf_req
comma
id|sbtype
comma
op_amp
id|sg_segment
comma
l_int|1
comma
id|max_sbals
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * zfcp_qdio_sbals_from_scsicmnd - fill SBALs from scsi command&n; * @fsf_req: request to be processed&n; * @sbtype: SBALE flags&n; * @scsi_cmnd: either scatter-gather list or buffer contained herein is used&n; *&t;to fill SBALs&n; */
r_inline
r_int
DECL|function|zfcp_qdio_sbals_from_scsicmnd
id|zfcp_qdio_sbals_from_scsicmnd
c_func
(paren
r_struct
id|zfcp_fsf_req
op_star
id|fsf_req
comma
r_int
r_int
id|sbtype
comma
r_struct
id|scsi_cmnd
op_star
id|scsi_cmnd
)paren
(brace
r_if
c_cond
(paren
id|scsi_cmnd-&gt;use_sg
)paren
(brace
r_return
id|zfcp_qdio_sbals_from_sg
c_func
(paren
id|fsf_req
comma
id|sbtype
comma
(paren
r_struct
id|scatterlist
op_star
)paren
id|scsi_cmnd-&gt;request_buffer
comma
id|scsi_cmnd-&gt;use_sg
comma
id|ZFCP_MAX_SBALS_PER_REQ
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|zfcp_qdio_sbals_from_buffer
c_func
(paren
id|fsf_req
comma
id|sbtype
comma
id|scsi_cmnd-&gt;request_buffer
comma
id|scsi_cmnd-&gt;request_bufflen
comma
id|ZFCP_MAX_SBALS_PER_REQ
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * zfcp_qdio_determine_pci - set PCI flag in first SBALE on qdio queue if needed&n; */
r_int
DECL|function|zfcp_qdio_determine_pci
id|zfcp_qdio_determine_pci
c_func
(paren
r_struct
id|zfcp_qdio_queue
op_star
id|req_queue
comma
r_struct
id|zfcp_fsf_req
op_star
id|fsf_req
)paren
(brace
r_int
id|new_distance_from_int
suffix:semicolon
r_int
id|pci_pos
suffix:semicolon
r_volatile
r_struct
id|qdio_buffer_element
op_star
id|sbale
suffix:semicolon
id|new_distance_from_int
op_assign
id|req_queue-&gt;distance_from_int
op_plus
id|fsf_req-&gt;sbal_number
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|new_distance_from_int
op_ge
id|ZFCP_QDIO_PCI_INTERVAL
)paren
)paren
(brace
id|new_distance_from_int
op_mod_assign
id|ZFCP_QDIO_PCI_INTERVAL
suffix:semicolon
id|pci_pos
op_assign
id|fsf_req-&gt;sbal_first
suffix:semicolon
id|pci_pos
op_add_assign
id|fsf_req-&gt;sbal_number
suffix:semicolon
id|pci_pos
op_sub_assign
id|new_distance_from_int
suffix:semicolon
id|pci_pos
op_sub_assign
l_int|1
suffix:semicolon
id|pci_pos
op_mod_assign
id|QDIO_MAX_BUFFERS_PER_Q
suffix:semicolon
id|sbale
op_assign
id|zfcp_qdio_sbale_req
c_func
(paren
id|fsf_req
comma
id|pci_pos
comma
l_int|0
)paren
suffix:semicolon
id|sbale-&gt;flags
op_or_assign
id|SBAL_FLAGS0_PCI
suffix:semicolon
)brace
r_return
id|new_distance_from_int
suffix:semicolon
)brace
multiline_comment|/*&n; * function:&t;zfcp_zero_sbals&n; *&n; * purpose:&t;zeros specified range of SBALs&n; *&n; * returns:&n; */
r_void
DECL|function|zfcp_qdio_zero_sbals
id|zfcp_qdio_zero_sbals
c_func
(paren
r_struct
id|qdio_buffer
op_star
id|buf
(braket
)braket
comma
r_int
id|first
comma
r_int
id|clean_count
)paren
(brace
r_int
id|cur_pos
suffix:semicolon
r_int
id|index
suffix:semicolon
r_for
c_loop
(paren
id|cur_pos
op_assign
id|first
suffix:semicolon
id|cur_pos
OL
(paren
id|first
op_plus
id|clean_count
)paren
suffix:semicolon
id|cur_pos
op_increment
)paren
(brace
id|index
op_assign
id|cur_pos
op_mod
id|QDIO_MAX_BUFFERS_PER_Q
suffix:semicolon
id|memset
c_func
(paren
id|buf
(braket
id|index
)braket
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|qdio_buffer
)paren
)paren
suffix:semicolon
id|ZFCP_LOG_TRACE
c_func
(paren
l_string|&quot;zeroing BUFFER %d at address %p&bslash;n&quot;
comma
id|index
comma
id|buf
(braket
id|index
)braket
)paren
suffix:semicolon
)brace
)brace
DECL|macro|ZFCP_LOG_AREA
macro_line|#undef ZFCP_LOG_AREA
eof
