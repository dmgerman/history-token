multiline_comment|/*&n; * File...........: linux/drivers/s390/block/dasd_devmap.c&n; * Author(s)......: Holger Smolinski &lt;Holger.Smolinski@de.ibm.com&gt;&n; *&t;&t;    Horst Hummel &lt;Horst.Hummel@de.ibm.com&gt;&n; *&t;&t;    Carsten Otte &lt;Cotte@de.ibm.com&gt;&n; *&t;&t;    Martin Schwidefsky &lt;schwidefsky@de.ibm.com&gt;&n; * Bugreports.to..: &lt;Linux390@de.ibm.com&gt;&n; * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999-2001&n; *&n; * Device mapping and dasd= parameter parsing functions. All devmap&n; * functions may not be called from interrupt context. In particular&n; * dasd_get_device is a no-no from interrupt context.&n; *&n; * 05/04/02 split from dasd.c, code restructuring.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/debug.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/* This is ugly... */
DECL|macro|PRINTK_HEADER
mdefine_line|#define PRINTK_HEADER &quot;dasd_devmap:&quot;
macro_line|#include &quot;dasd_int.h&quot;
multiline_comment|/*&n; * Parameter parsing functions for dasd= parameter. The syntax is:&n; *   &lt;devno&gt;&t;&t;: (0x)?[0-9a-fA-F]+&n; *   &lt;feature&gt;&t;&t;: ro&n; *   &lt;feature_list&gt;&t;: &bslash;(&lt;feature&gt;(:&lt;feature&gt;)*&bslash;)&n; *   &lt;range&gt;&t;&t;: &lt;devno&gt;(-&lt;devno&gt;)?&lt;feature_list&gt;?&n; *   &lt;dasd_module&gt;&t;: dasd_diag_mod|dasd_eckd_mod|dasd_fba_mod&n; *&n; *   &lt;dasd&gt;&t;&t;: autodetect|probeonly|&lt;range&gt;(,&lt;range&gt;)*&n; */
DECL|variable|dasd_probeonly
r_int
id|dasd_probeonly
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* is true, when probeonly mode is active */
DECL|variable|dasd_autodetect
r_int
id|dasd_autodetect
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* is true, when autodetection is active */
multiline_comment|/*&n; * char *dasd[] is intended to hold the ranges supplied by the dasd= statement&n; * it is named &squot;dasd&squot; to directly be filled by insmod with the comma separated&n; * strings when running as a module.&n; */
DECL|variable|dasd
r_static
r_char
op_star
id|dasd
(braket
l_int|256
)braket
suffix:semicolon
multiline_comment|/*&n; * Single spinlock to protect devmap structures and lists.&n; */
DECL|variable|dasd_devmap_lock
r_static
id|spinlock_t
id|dasd_devmap_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * Hash lists for devmap structures.&n; */
DECL|variable|dasd_devindex_hashlists
r_static
r_struct
id|list_head
id|dasd_devindex_hashlists
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|dasd_devno_hashlists
r_static
r_struct
id|list_head
id|dasd_devno_hashlists
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|dasd_max_devindex
r_int
id|dasd_max_devindex
suffix:semicolon
macro_line|#ifndef MODULE
multiline_comment|/*&n; * The parameter parsing functions for builtin-drivers are called&n; * before kmalloc works. Store the pointers to the parameters strings&n; * into dasd[] for later processing.&n; */
r_static
r_int
id|__init
DECL|function|dasd_call_setup
id|dasd_call_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_static
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
l_int|256
)paren
id|dasd
(braket
id|count
op_increment
)braket
op_assign
id|str
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
(paren
l_string|&quot;dasd=&quot;
comma
id|dasd_call_setup
)paren
suffix:semicolon
macro_line|#endif&t;/* #ifndef MODULE */
multiline_comment|/*&n; * Read a device number from a string. The number is always in hex,&n; * a leading 0x is accepted.&n; */
r_int
DECL|function|dasd_devno
id|dasd_devno
c_func
(paren
r_char
op_star
id|str
comma
r_char
op_star
op_star
id|endp
)paren
(brace
multiline_comment|/* remove leading &squot;0x&squot; */
r_if
c_cond
(paren
op_star
id|str
op_eq
l_char|&squot;0&squot;
)paren
(brace
id|str
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|str
op_eq
l_char|&squot;x&squot;
)paren
id|str
op_increment
suffix:semicolon
)brace
multiline_comment|/* We require at least one hex digit */
r_if
c_cond
(paren
op_logical_neg
id|isxdigit
c_func
(paren
op_star
id|str
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|simple_strtoul
c_func
(paren
id|str
comma
id|endp
comma
l_int|16
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read colon separated list of dasd features. Currently there is&n; * only one: &quot;ro&quot; for read-only devices. The default feature set&n; * is empty (value 0).&n; */
r_int
DECL|function|dasd_feature_list
id|dasd_feature_list
c_func
(paren
r_char
op_star
id|str
comma
r_char
op_star
op_star
id|endp
)paren
(brace
r_int
id|features
comma
id|len
comma
id|rc
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_star
id|str
op_ne
l_char|&squot;(&squot;
)paren
(brace
op_star
id|endp
op_assign
id|str
suffix:semicolon
r_return
id|DASD_FEATURE_DEFAULT
suffix:semicolon
)brace
id|features
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|len
op_assign
l_int|0
suffix:semicolon
id|str
(braket
id|len
)braket
op_logical_and
id|str
(braket
id|len
)braket
op_ne
l_char|&squot;:&squot;
op_logical_and
id|str
(braket
id|len
)braket
op_ne
l_char|&squot;)&squot;
suffix:semicolon
id|len
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|2
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|str
comma
l_string|&quot;ro&quot;
comma
l_int|2
)paren
)paren
id|features
op_or_assign
id|DASD_FEATURE_READONLY
suffix:semicolon
r_else
(brace
id|MESSAGE
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;unsupported feature: %*s, &quot;
l_string|&quot;ignoring setting&quot;
comma
id|len
comma
id|str
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|str
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
op_star
id|str
op_ne
l_char|&squot;:&squot;
)paren
r_break
suffix:semicolon
id|str
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|str
op_ne
l_char|&squot;)&squot;
)paren
(brace
id|MESSAGE
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;missing &squot;)&squot; in dasd parameter string&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
id|str
op_increment
suffix:semicolon
op_star
id|endp
op_assign
id|str
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
r_return
id|rc
suffix:semicolon
r_return
id|features
suffix:semicolon
)brace
multiline_comment|/*&n; * Read comma separated list of dasd ranges.&n; */
r_static
r_inline
r_int
DECL|function|dasd_ranges_list
id|dasd_ranges_list
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|from
comma
id|to
comma
id|features
comma
id|rc
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|to
op_assign
id|from
op_assign
id|dasd_devno
c_func
(paren
id|str
comma
op_amp
id|str
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|str
op_eq
l_char|&squot;-&squot;
)paren
(brace
id|str
op_increment
suffix:semicolon
id|to
op_assign
id|dasd_devno
c_func
(paren
id|str
comma
op_amp
id|str
)paren
suffix:semicolon
)brace
id|features
op_assign
id|dasd_feature_list
c_func
(paren
id|str
comma
op_amp
id|str
)paren
suffix:semicolon
multiline_comment|/* Negative numbers in from/to/features indicate errors */
r_if
c_cond
(paren
id|from
op_ge
l_int|0
op_logical_and
id|to
op_ge
l_int|0
op_logical_and
id|features
op_ge
l_int|0
)paren
(brace
id|rc
op_assign
id|dasd_add_range
c_func
(paren
id|from
comma
id|to
comma
id|features
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|str
op_ne
l_char|&squot;,&squot;
)paren
r_break
suffix:semicolon
id|str
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|str
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|MESSAGE
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;junk at end of dasd parameter string: %s&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Parse a single dasd= parameter.&n; */
r_static
r_int
DECL|function|dasd_parameter
id|dasd_parameter
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_if
c_cond
(paren
id|strcmp
(paren
l_string|&quot;autodetect&quot;
comma
id|str
)paren
op_eq
l_int|0
)paren
(brace
id|dasd_autodetect
op_assign
l_int|1
suffix:semicolon
id|MESSAGE
(paren
id|KERN_INFO
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;turning to autodetection mode&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strcmp
(paren
l_string|&quot;probeonly&quot;
comma
id|str
)paren
op_eq
l_int|0
)paren
(brace
id|dasd_probeonly
op_assign
l_int|1
suffix:semicolon
id|MESSAGE
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;turning to probeonly mode&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* turn off autodetect mode and scan for dasd ranges */
id|dasd_autodetect
op_assign
l_int|0
suffix:semicolon
r_return
id|dasd_ranges_list
c_func
(paren
id|str
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Parse parameters stored in dasd[] and dasd_disciplines[].&n; */
r_int
DECL|function|dasd_parse
id|dasd_parse
c_func
(paren
r_void
)paren
(brace
r_int
id|rc
comma
id|i
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dasd
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|rc
op_assign
id|dasd_parameter
c_func
(paren
id|dasd
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|DBF_EVENT
c_func
(paren
id|DBF_ALERT
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;invalid range found&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a range of devices and creates the corresponding devreg_t&n; * structures. The order of the ranges added through this function&n; * will define the kdevs for the individual devices. &n; */
r_int
DECL|function|dasd_add_range
id|dasd_add_range
c_func
(paren
r_int
id|from
comma
r_int
id|to
comma
r_int
id|features
)paren
(brace
r_int
id|devindex
suffix:semicolon
r_int
id|devno
suffix:semicolon
r_if
c_cond
(paren
id|from
OG
id|to
)paren
(brace
id|MESSAGE
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;Invalid device range %04x-%04x&quot;
comma
id|from
comma
id|to
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|devno
op_assign
id|from
suffix:semicolon
id|devno
op_le
id|to
suffix:semicolon
id|devno
op_increment
)paren
(brace
id|dasd_devmap_t
op_star
id|devmap
comma
op_star
id|tmp
suffix:semicolon
r_struct
id|list_head
op_star
id|l
suffix:semicolon
id|devmap
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Find previous devmap for device number i */
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|dasd_devno_hashlists
(braket
id|devno
op_amp
l_int|255
)braket
)paren
(brace
id|tmp
op_assign
id|list_entry
c_func
(paren
id|l
comma
id|dasd_devmap_t
comma
id|devno_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;devno
op_eq
id|devno
)paren
(brace
id|devmap
op_assign
id|tmp
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|devmap
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* This devno is new. */
id|devmap
op_assign
(paren
id|dasd_devmap_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|dasd_devmap_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devmap
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|devindex
op_assign
id|dasd_max_devindex
op_increment
suffix:semicolon
id|devmap-&gt;devindex
op_assign
id|devindex
suffix:semicolon
id|devmap-&gt;devno
op_assign
id|devno
suffix:semicolon
id|devmap-&gt;features
op_assign
id|features
suffix:semicolon
id|devmap-&gt;devreg
op_assign
l_int|NULL
suffix:semicolon
id|devmap-&gt;device
op_assign
l_int|NULL
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|devmap-&gt;devindex_list
comma
op_amp
id|dasd_devindex_hashlists
(braket
id|devindex
op_amp
l_int|255
)braket
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|devmap-&gt;devno_list
comma
op_amp
id|dasd_devno_hashlists
(braket
id|devno
op_amp
l_int|255
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|devmap-&gt;devreg
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* The devreg is missing. */
id|devmap-&gt;devreg
op_assign
(paren
id|devreg_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|devreg_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devmap-&gt;devreg
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|devmap-&gt;devreg
comma
r_sizeof
(paren
id|devreg_t
)paren
comma
l_int|0
)paren
suffix:semicolon
id|devmap-&gt;devreg-&gt;ci.devno
op_assign
id|devno
suffix:semicolon
id|devmap-&gt;devreg-&gt;flag
op_assign
id|DEVREG_TYPE_DEVNO
suffix:semicolon
id|devmap-&gt;devreg-&gt;oper_func
op_assign
id|dasd_oper_handler
suffix:semicolon
id|s390_device_register
c_func
(paren
id|devmap-&gt;devreg
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Removes the devreg_t structures for a range of devices. This does&n; * NOT remove the range itself. The mapping between devno and kdevs&n; * for the devices is remembered until dasd_forget_ranges() is called.&n; */
r_static
r_int
DECL|function|dasd_clear_range
id|dasd_clear_range
c_func
(paren
r_int
id|from
comma
r_int
id|to
)paren
(brace
r_int
id|devno
suffix:semicolon
r_if
c_cond
(paren
id|from
OG
id|to
)paren
(brace
id|MESSAGE
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;Invalid device range %04x-%04x&quot;
comma
id|from
comma
id|to
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|devno
op_assign
id|from
suffix:semicolon
id|devno
op_le
id|to
suffix:semicolon
id|devno
op_increment
)paren
(brace
r_struct
id|list_head
op_star
id|l
suffix:semicolon
id|dasd_devmap_t
op_star
id|devmap
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Find previous devmap for device number i */
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|dasd_devno_hashlists
(braket
id|devno
op_amp
l_int|255
)braket
)paren
(brace
id|devmap
op_assign
id|list_entry
c_func
(paren
id|l
comma
id|dasd_devmap_t
comma
id|devno_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devmap-&gt;devno
op_eq
id|devno
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|devmap
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|devmap-&gt;device
op_ne
l_int|NULL
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devmap-&gt;devreg
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|s390_device_unregister
c_func
(paren
id|devmap-&gt;devreg
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|devmap-&gt;devreg
)paren
suffix:semicolon
id|devmap-&gt;devreg
op_assign
l_int|NULL
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Forget all about the device numbers added so far.&n; * This may only be called at module unload or system shutdown.&n; */
r_static
r_void
DECL|function|dasd_forget_ranges
id|dasd_forget_ranges
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|list_head
op_star
id|l
comma
op_star
id|next
suffix:semicolon
id|dasd_devmap_t
op_star
id|devmap
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|l
comma
id|next
comma
op_amp
id|dasd_devno_hashlists
(braket
id|i
)braket
)paren
(brace
id|devmap
op_assign
id|list_entry
c_func
(paren
id|l
comma
id|dasd_devmap_t
comma
id|devno_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devmap-&gt;device
op_ne
l_int|NULL
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devmap-&gt;devreg
op_ne
l_int|NULL
)paren
(brace
id|s390_device_unregister
c_func
(paren
id|devmap-&gt;devreg
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|devmap-&gt;devreg
)paren
suffix:semicolon
id|devmap-&gt;devreg
op_assign
l_int|NULL
suffix:semicolon
)brace
id|list_del
c_func
(paren
op_amp
id|devmap-&gt;devindex_list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|devmap-&gt;devno_list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|devmap
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the devmap structure from a devno. Can be removed as soon&n; * as big minors are available.&n; */
id|dasd_devmap_t
op_star
DECL|function|dasd_devmap_from_devno
id|dasd_devmap_from_devno
c_func
(paren
r_int
id|devno
)paren
(brace
r_struct
id|list_head
op_star
id|l
suffix:semicolon
id|dasd_devmap_t
op_star
id|devmap
comma
op_star
id|tmp
suffix:semicolon
id|devmap
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
multiline_comment|/* Find devmap for device with device number devno */
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|dasd_devno_hashlists
(braket
id|devno
op_amp
l_int|255
)braket
)paren
(brace
id|tmp
op_assign
id|list_entry
c_func
(paren
id|l
comma
id|dasd_devmap_t
comma
id|devno_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;devno
op_eq
id|devno
)paren
(brace
multiline_comment|/* Found the device, return devmap */
id|devmap
op_assign
id|tmp
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
r_return
id|devmap
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the devmap for a device by its device index. Can be removed&n; * as soon as big minors are available.&n; */
id|dasd_devmap_t
op_star
DECL|function|dasd_devmap_from_devindex
id|dasd_devmap_from_devindex
c_func
(paren
r_int
id|devindex
)paren
(brace
r_struct
id|list_head
op_star
id|l
suffix:semicolon
id|dasd_devmap_t
op_star
id|devmap
comma
op_star
id|tmp
suffix:semicolon
id|devmap
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
multiline_comment|/* Find devmap for device with device index devindex */
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|dasd_devindex_hashlists
(braket
id|devindex
op_amp
l_int|255
)braket
)paren
(brace
id|tmp
op_assign
id|list_entry
c_func
(paren
id|l
comma
id|dasd_devmap_t
comma
id|devindex_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;devindex
op_eq
id|devindex
)paren
(brace
multiline_comment|/* Found the device, return devno */
id|devmap
op_assign
id|tmp
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
r_return
id|devmap
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the devmap for a device by its irq line.&n; */
id|dasd_devmap_t
op_star
DECL|function|dasd_devmap_from_irq
id|dasd_devmap_from_irq
c_func
(paren
r_int
id|irq
)paren
(brace
r_struct
id|list_head
op_star
id|l
suffix:semicolon
id|dasd_devmap_t
op_star
id|devmap
comma
op_star
id|tmp
suffix:semicolon
r_int
id|i
suffix:semicolon
id|devmap
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
l_int|256
)paren
op_logical_and
(paren
id|devmap
op_eq
l_int|NULL
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|dasd_devno_hashlists
(braket
id|i
op_amp
l_int|255
)braket
)paren
(brace
id|tmp
op_assign
id|list_entry
c_func
(paren
id|l
comma
id|dasd_devmap_t
comma
id|devno_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;device
op_ne
l_int|NULL
op_logical_and
id|tmp-&gt;device-&gt;devinfo.irq
op_eq
id|irq
)paren
(brace
id|devmap
op_assign
id|tmp
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
r_return
id|devmap
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the devmap for a device corresponding to a kdev.&n; */
id|dasd_devmap_t
op_star
DECL|function|dasd_devmap_from_kdev
id|dasd_devmap_from_kdev
c_func
(paren
id|kdev_t
id|kdev
)paren
(brace
r_int
id|devindex
suffix:semicolon
multiline_comment|/* Find the devindex for kdev. */
id|devindex
op_assign
id|dasd_gendisk_major_index
c_func
(paren
id|major
c_func
(paren
id|kdev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devindex
OL
l_int|0
)paren
multiline_comment|/* No such major -&gt; no devmap */
r_return
l_int|NULL
suffix:semicolon
id|devindex
op_add_assign
id|minor
c_func
(paren
id|kdev
)paren
op_rshift
id|DASD_PARTN_BITS
suffix:semicolon
multiline_comment|/* Now find the devmap by the devindex. */
r_return
id|dasd_devmap_from_devindex
c_func
(paren
id|devindex
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the device structure for device number devno. If it does not&n; * exists yet, allocate it. Increase the reference counter in the device&n; * structure and return a pointer to it.&n; */
id|dasd_device_t
op_star
DECL|function|dasd_get_device
id|dasd_get_device
c_func
(paren
id|dasd_devmap_t
op_star
id|devmap
)paren
(brace
id|dasd_device_t
op_star
id|device
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
id|device
op_assign
id|devmap-&gt;device
suffix:semicolon
r_if
c_cond
(paren
id|device
op_ne
l_int|NULL
)paren
id|atomic_inc
c_func
(paren
op_amp
id|device-&gt;ref_count
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device
op_ne
l_int|NULL
)paren
r_return
id|device
suffix:semicolon
id|device
op_assign
id|dasd_alloc_device
c_func
(paren
id|devmap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|device
)paren
)paren
r_return
id|device
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devmap-&gt;device
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Someone else was faster. */
id|dasd_free_device
c_func
(paren
id|device
)paren
suffix:semicolon
id|device
op_assign
id|devmap-&gt;device
suffix:semicolon
)brace
r_else
id|devmap-&gt;device
op_assign
id|device
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|device-&gt;ref_count
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
r_return
id|device
suffix:semicolon
)brace
multiline_comment|/*&n; * Decrease the reference counter of a devices structure. If the&n; * reference counter reaches zero and the device status is&n; * DASD_STATE_NEW the device structure is freed. &n; */
r_void
DECL|function|dasd_put_device
id|dasd_put_device
c_func
(paren
id|dasd_devmap_t
op_star
id|devmap
)paren
(brace
id|dasd_device_t
op_star
id|device
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
id|device
op_assign
id|devmap-&gt;device
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_return
c_func
(paren
op_amp
id|device-&gt;ref_count
)paren
op_eq
l_int|0
op_logical_and
id|device-&gt;state
op_eq
id|DASD_STATE_NEW
)paren
(brace
id|devmap-&gt;device
op_assign
l_int|NULL
suffix:semicolon
id|dasd_free_device
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
)brace
r_int
DECL|function|dasd_devmap_init
id|dasd_devmap_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Initialize devmap structures. */
id|dasd_max_devindex
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dasd_devindex_hashlists
(braket
id|i
)braket
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dasd_devno_hashlists
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|dasd_devmap_exit
id|dasd_devmap_exit
c_func
(paren
r_void
)paren
(brace
id|dasd_forget_ranges
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|dasd_devmap_from_devno
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_devmap_from_devno
)paren
suffix:semicolon
DECL|variable|dasd_devmap_from_devindex
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_devmap_from_devindex
)paren
suffix:semicolon
DECL|variable|dasd_devmap_from_irq
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_devmap_from_irq
)paren
suffix:semicolon
DECL|variable|dasd_devmap_from_kdev
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_devmap_from_kdev
)paren
suffix:semicolon
DECL|variable|dasd_get_device
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_get_device
)paren
suffix:semicolon
DECL|variable|dasd_put_device
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_put_device
)paren
suffix:semicolon
eof
