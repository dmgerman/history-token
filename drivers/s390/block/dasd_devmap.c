multiline_comment|/*&n; * File...........: linux/drivers/s390/block/dasd_devmap.c&n; * Author(s)......: Holger Smolinski &lt;Holger.Smolinski@de.ibm.com&gt;&n; *&t;&t;    Horst Hummel &lt;Horst.Hummel@de.ibm.com&gt;&n; *&t;&t;    Carsten Otte &lt;Cotte@de.ibm.com&gt;&n; *&t;&t;    Martin Schwidefsky &lt;schwidefsky@de.ibm.com&gt;&n; * Bugreports.to..: &lt;Linux390@de.ibm.com&gt;&n; * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999-2001&n; *&n; * Device mapping and dasd= parameter parsing functions. All devmap&n; * functions may not be called from interrupt context. In particular&n; * dasd_get_device is a no-no from interrupt context.&n; *&n; * $Revision: 1.15 $&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/debug.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/* This is ugly... */
DECL|macro|PRINTK_HEADER
mdefine_line|#define PRINTK_HEADER &quot;dasd_devmap:&quot;
macro_line|#include &quot;dasd_int.h&quot;
multiline_comment|/*&n; * dasd_devmap_t is used to store the features and the relation&n; * between device number and device index. To find a dasd_devmap_t&n; * that corresponds to a device number of a device index each&n; * dasd_devmap_t is added to two linked lists, one to search by&n; * the device number and one to search by the device index. As&n; * soon as big minor numbers are available the device index list&n; * can be removed since the device number will then be identical&n; * to the device index.&n; */
DECL|struct|dasd_devmap
r_struct
id|dasd_devmap
(brace
DECL|member|devindex_list
r_struct
id|list_head
id|devindex_list
suffix:semicolon
DECL|member|devno_list
r_struct
id|list_head
id|devno_list
suffix:semicolon
DECL|member|devindex
r_int
r_int
id|devindex
suffix:semicolon
DECL|member|devno
r_int
r_int
id|devno
suffix:semicolon
DECL|member|features
r_int
r_int
id|features
suffix:semicolon
DECL|member|device
r_struct
id|dasd_device
op_star
id|device
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Parameter parsing functions for dasd= parameter. The syntax is:&n; *   &lt;devno&gt;&t;&t;: (0x)?[0-9a-fA-F]+&n; *   &lt;feature&gt;&t;&t;: ro&n; *   &lt;feature_list&gt;&t;: &bslash;(&lt;feature&gt;(:&lt;feature&gt;)*&bslash;)&n; *   &lt;range&gt;&t;&t;: &lt;devno&gt;(-&lt;devno&gt;)?&lt;feature_list&gt;?&n; *   &lt;dasd_module&gt;&t;: dasd_diag_mod|dasd_eckd_mod|dasd_fba_mod&n; *&n; *   &lt;dasd&gt;&t;&t;: autodetect|probeonly|&lt;range&gt;(,&lt;range&gt;)*&n; */
DECL|variable|dasd_probeonly
r_int
id|dasd_probeonly
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* is true, when probeonly mode is active */
DECL|variable|dasd_autodetect
r_int
id|dasd_autodetect
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* is true, when autodetection is active */
multiline_comment|/*&n; * char *dasd[] is intended to hold the ranges supplied by the dasd= statement&n; * it is named &squot;dasd&squot; to directly be filled by insmod with the comma separated&n; * strings when running as a module.&n; */
DECL|variable|dasd
r_static
r_char
op_star
id|dasd
(braket
l_int|256
)braket
suffix:semicolon
multiline_comment|/*&n; * Single spinlock to protect devmap structures and lists.&n; */
DECL|variable|dasd_devmap_lock
r_static
id|spinlock_t
id|dasd_devmap_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * Hash lists for devmap structures.&n; */
DECL|variable|dasd_devindex_hashlists
r_static
r_struct
id|list_head
id|dasd_devindex_hashlists
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|dasd_devno_hashlists
r_static
r_struct
id|list_head
id|dasd_devno_hashlists
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|dasd_max_devindex
r_int
id|dasd_max_devindex
suffix:semicolon
macro_line|#ifndef MODULE
multiline_comment|/*&n; * The parameter parsing functions for builtin-drivers are called&n; * before kmalloc works. Store the pointers to the parameters strings&n; * into dasd[] for later processing.&n; */
r_static
r_int
id|__init
DECL|function|dasd_call_setup
id|dasd_call_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_static
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
l_int|256
)paren
id|dasd
(braket
id|count
op_increment
)braket
op_assign
id|str
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
(paren
l_string|&quot;dasd=&quot;
comma
id|dasd_call_setup
)paren
suffix:semicolon
macro_line|#endif&t;/* #ifndef MODULE */
multiline_comment|/*&n; * Read a device number from a string. The number is always in hex,&n; * a leading 0x is accepted.&n; */
r_static
r_inline
r_int
DECL|function|dasd_devno
id|dasd_devno
c_func
(paren
r_char
op_star
id|str
comma
r_char
op_star
op_star
id|endp
)paren
(brace
r_int
id|val
suffix:semicolon
multiline_comment|/* remove leading &squot;0x&squot; */
r_if
c_cond
(paren
op_star
id|str
op_eq
l_char|&squot;0&squot;
)paren
(brace
id|str
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|str
op_eq
l_char|&squot;x&squot;
)paren
id|str
op_increment
suffix:semicolon
)brace
multiline_comment|/* We require at least one hex digit */
r_if
c_cond
(paren
op_logical_neg
id|isxdigit
c_func
(paren
op_star
id|str
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|val
op_assign
id|simple_strtoul
c_func
(paren
id|str
comma
id|endp
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
OG
l_int|0xFFFF
)paren
op_logical_or
(paren
id|val
OL
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
multiline_comment|/*&n; * Read colon separated list of dasd features. Currently there is&n; * only one: &quot;ro&quot; for read-only devices. The default feature set&n; * is empty (value 0).&n; */
r_static
r_inline
r_int
DECL|function|dasd_feature_list
id|dasd_feature_list
c_func
(paren
r_char
op_star
id|str
comma
r_char
op_star
op_star
id|endp
)paren
(brace
r_int
id|features
comma
id|len
comma
id|rc
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_star
id|str
op_ne
l_char|&squot;(&squot;
)paren
(brace
op_star
id|endp
op_assign
id|str
suffix:semicolon
r_return
id|DASD_FEATURE_DEFAULT
suffix:semicolon
)brace
id|features
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|len
op_assign
l_int|0
suffix:semicolon
id|str
(braket
id|len
)braket
op_logical_and
id|str
(braket
id|len
)braket
op_ne
l_char|&squot;:&squot;
op_logical_and
id|str
(braket
id|len
)braket
op_ne
l_char|&squot;)&squot;
suffix:semicolon
id|len
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|2
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|str
comma
l_string|&quot;ro&quot;
comma
l_int|2
)paren
)paren
id|features
op_or_assign
id|DASD_FEATURE_READONLY
suffix:semicolon
r_else
(brace
id|MESSAGE
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;unsupported feature: %*s, &quot;
l_string|&quot;ignoring setting&quot;
comma
id|len
comma
id|str
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|str
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
op_star
id|str
op_ne
l_char|&squot;:&squot;
)paren
r_break
suffix:semicolon
id|str
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|str
op_ne
l_char|&squot;)&squot;
)paren
(brace
id|MESSAGE
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;missing &squot;)&squot; in dasd parameter string&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
id|str
op_increment
suffix:semicolon
op_star
id|endp
op_assign
id|str
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
r_return
id|rc
suffix:semicolon
r_return
id|features
suffix:semicolon
)brace
multiline_comment|/*&n; * Read comma separated list of dasd ranges.&n; */
r_static
r_inline
r_int
DECL|function|dasd_ranges_list
id|dasd_ranges_list
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|from
comma
id|to
comma
id|features
comma
id|rc
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|to
op_assign
id|from
op_assign
id|dasd_devno
c_func
(paren
id|str
comma
op_amp
id|str
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|str
op_eq
l_char|&squot;-&squot;
)paren
(brace
id|str
op_increment
suffix:semicolon
id|to
op_assign
id|dasd_devno
c_func
(paren
id|str
comma
op_amp
id|str
)paren
suffix:semicolon
)brace
id|features
op_assign
id|dasd_feature_list
c_func
(paren
id|str
comma
op_amp
id|str
)paren
suffix:semicolon
multiline_comment|/* Negative numbers in from/to/features indicate errors */
r_if
c_cond
(paren
id|from
op_ge
l_int|0
op_logical_and
id|to
op_ge
l_int|0
op_logical_and
id|features
op_ge
l_int|0
)paren
(brace
id|rc
op_assign
id|dasd_add_range
c_func
(paren
id|from
comma
id|to
comma
id|features
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|str
op_ne
l_char|&squot;,&squot;
)paren
r_break
suffix:semicolon
id|str
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|str
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|MESSAGE
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;junk at end of dasd parameter string: %s&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Parse a single dasd= parameter.&n; */
r_static
r_int
DECL|function|dasd_parameter
id|dasd_parameter
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_if
c_cond
(paren
id|strcmp
(paren
l_string|&quot;autodetect&quot;
comma
id|str
)paren
op_eq
l_int|0
)paren
(brace
id|dasd_autodetect
op_assign
l_int|1
suffix:semicolon
id|MESSAGE
(paren
id|KERN_INFO
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;turning to autodetection mode&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strcmp
(paren
l_string|&quot;probeonly&quot;
comma
id|str
)paren
op_eq
l_int|0
)paren
(brace
id|dasd_probeonly
op_assign
l_int|1
suffix:semicolon
id|MESSAGE
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;turning to probeonly mode&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* turn off autodetect mode and scan for dasd ranges */
id|dasd_autodetect
op_assign
l_int|0
suffix:semicolon
r_return
id|dasd_ranges_list
c_func
(paren
id|str
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Parse parameters stored in dasd[] and dasd_disciplines[].&n; */
r_int
DECL|function|dasd_parse
id|dasd_parse
c_func
(paren
r_void
)paren
(brace
r_int
id|rc
comma
id|i
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dasd
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|rc
op_assign
id|dasd_parameter
c_func
(paren
id|dasd
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|DBF_EVENT
c_func
(paren
id|DBF_ALERT
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;invalid range found&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a range of devices and creates the corresponding devreg_t&n; * structures. The order of the ranges added through this function&n; * will define the kdevs for the individual devices. &n; */
r_int
DECL|function|dasd_add_range
id|dasd_add_range
c_func
(paren
r_int
id|from
comma
r_int
id|to
comma
r_int
id|features
)paren
(brace
r_int
id|devindex
suffix:semicolon
r_int
id|devno
suffix:semicolon
r_if
c_cond
(paren
id|from
OG
id|to
)paren
(brace
id|MESSAGE
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;Invalid device range %04x-%04x&quot;
comma
id|from
comma
id|to
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|devno
op_assign
id|from
suffix:semicolon
id|devno
op_le
id|to
suffix:semicolon
id|devno
op_increment
)paren
(brace
r_struct
id|dasd_devmap
op_star
id|devmap
comma
op_star
id|tmp
suffix:semicolon
id|devmap
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Find previous devmap for device number i */
id|list_for_each_entry
c_func
(paren
id|tmp
comma
op_amp
id|dasd_devno_hashlists
(braket
id|devno
op_amp
l_int|255
)braket
comma
id|devno_list
)paren
(brace
r_if
c_cond
(paren
id|tmp-&gt;devno
op_eq
id|devno
)paren
(brace
id|devmap
op_assign
id|tmp
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|devmap
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* This devno is new. */
id|devmap
op_assign
(paren
r_struct
id|dasd_devmap
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|dasd_devmap
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devmap
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|devindex
op_assign
id|dasd_max_devindex
op_increment
suffix:semicolon
id|devmap-&gt;devindex
op_assign
id|devindex
suffix:semicolon
id|devmap-&gt;devno
op_assign
id|devno
suffix:semicolon
id|devmap-&gt;features
op_assign
id|features
suffix:semicolon
id|devmap-&gt;device
op_assign
l_int|NULL
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|devmap-&gt;devindex_list
comma
op_amp
id|dasd_devindex_hashlists
(braket
id|devindex
op_amp
l_int|255
)braket
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|devmap-&gt;devno_list
comma
op_amp
id|dasd_devno_hashlists
(braket
id|devno
op_amp
l_int|255
)braket
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Check if devno has been added to the list of dasd ranges.&n; */
r_int
DECL|function|dasd_devno_in_range
id|dasd_devno_in_range
c_func
(paren
r_int
id|devno
)paren
(brace
r_struct
id|dasd_devmap
op_star
id|devmap
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
multiline_comment|/* Find devmap for device with device number devno */
id|list_for_each_entry
c_func
(paren
id|devmap
comma
op_amp
id|dasd_devno_hashlists
(braket
id|devno
op_amp
l_int|255
)braket
comma
id|devno_list
)paren
(brace
r_if
c_cond
(paren
id|devmap-&gt;devno
op_eq
id|devno
)paren
(brace
multiline_comment|/* Found the device. */
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Forget all about the device numbers added so far.&n; * This may only be called at module unload or system shutdown.&n; */
r_static
r_void
DECL|function|dasd_forget_ranges
id|dasd_forget_ranges
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|list_head
op_star
id|l
comma
op_star
id|next
suffix:semicolon
r_struct
id|dasd_devmap
op_star
id|devmap
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|l
comma
id|next
comma
op_amp
id|dasd_devno_hashlists
(braket
id|i
)braket
)paren
(brace
id|devmap
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|dasd_devmap
comma
id|devno_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devmap-&gt;device
op_ne
l_int|NULL
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|devmap-&gt;devindex_list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|devmap-&gt;devno_list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|devmap
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the devmap structure from a devno. Can be removed as soon&n; * as big minors are available.&n; */
r_static
r_struct
id|dasd_devmap
op_star
DECL|function|dasd_devmap_from_devno
id|dasd_devmap_from_devno
c_func
(paren
r_int
id|devno
)paren
(brace
r_struct
id|dasd_devmap
op_star
id|devmap
comma
op_star
id|tmp
suffix:semicolon
id|devmap
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
multiline_comment|/* Find devmap for device with device number devno */
id|list_for_each_entry
c_func
(paren
id|tmp
comma
op_amp
id|dasd_devno_hashlists
(braket
id|devno
op_amp
l_int|255
)braket
comma
id|devno_list
)paren
(brace
r_if
c_cond
(paren
id|tmp-&gt;devno
op_eq
id|devno
)paren
(brace
multiline_comment|/* Found the device, return devmap */
id|devmap
op_assign
id|tmp
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
r_return
id|devmap
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the devmap for a device by its device index. Can be removed&n; * as soon as big minors are available.&n; */
r_static
r_struct
id|dasd_devmap
op_star
DECL|function|dasd_devmap_from_devindex
id|dasd_devmap_from_devindex
c_func
(paren
r_int
id|devindex
)paren
(brace
r_struct
id|dasd_devmap
op_star
id|devmap
comma
op_star
id|tmp
suffix:semicolon
id|devmap
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
multiline_comment|/* Find devmap for device with device index devindex */
id|list_for_each_entry
c_func
(paren
id|tmp
comma
op_amp
id|dasd_devindex_hashlists
(braket
id|devindex
op_amp
l_int|255
)braket
comma
id|devindex_list
)paren
(brace
r_if
c_cond
(paren
id|tmp-&gt;devindex
op_eq
id|devindex
)paren
(brace
multiline_comment|/* Found the device, return devno */
id|devmap
op_assign
id|tmp
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
r_return
id|devmap
suffix:semicolon
)brace
r_struct
id|dasd_device
op_star
DECL|function|dasd_device_from_devindex
id|dasd_device_from_devindex
c_func
(paren
r_int
id|devindex
)paren
(brace
r_struct
id|dasd_devmap
op_star
id|devmap
suffix:semicolon
r_struct
id|dasd_device
op_star
id|device
suffix:semicolon
id|devmap
op_assign
id|dasd_devmap_from_devindex
c_func
(paren
id|devindex
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
id|device
op_assign
id|devmap-&gt;device
suffix:semicolon
r_if
c_cond
(paren
id|device
)paren
id|dasd_get_device
c_func
(paren
id|device
)paren
suffix:semicolon
r_else
id|device
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
r_return
id|device
suffix:semicolon
)brace
multiline_comment|/*&n; * Return kdev for a dasd device.&n; */
id|kdev_t
DECL|function|dasd_get_kdev
id|dasd_get_kdev
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
r_struct
id|dasd_devmap
op_star
id|devmap
suffix:semicolon
r_int
id|major
comma
id|minor
suffix:semicolon
r_int
id|devno
suffix:semicolon
id|devno
op_assign
id|_ccw_device_get_device_number
c_func
(paren
id|device-&gt;cdev
)paren
suffix:semicolon
id|devmap
op_assign
id|dasd_devmap_from_devno
c_func
(paren
id|devno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devmap
op_eq
l_int|NULL
)paren
r_return
id|NODEV
suffix:semicolon
id|major
op_assign
id|dasd_gendisk_index_major
c_func
(paren
id|devmap-&gt;devindex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|major
OL
l_int|0
)paren
r_return
id|NODEV
suffix:semicolon
id|minor
op_assign
id|devmap-&gt;devindex
op_mod
id|DASD_PER_MAJOR
suffix:semicolon
r_return
id|mk_kdev
c_func
(paren
id|major
comma
id|minor
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a dasd device structure for cdev.&n; */
r_struct
id|dasd_device
op_star
DECL|function|dasd_create_device
id|dasd_create_device
c_func
(paren
r_struct
id|ccw_device
op_star
id|cdev
)paren
(brace
r_struct
id|dasd_devmap
op_star
id|devmap
suffix:semicolon
r_struct
id|dasd_device
op_star
id|device
suffix:semicolon
r_int
id|devno
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|devno
op_assign
id|_ccw_device_get_device_number
c_func
(paren
id|cdev
)paren
suffix:semicolon
id|rc
op_assign
id|dasd_add_range
c_func
(paren
id|devno
comma
id|devno
comma
id|DASD_FEATURE_DEFAULT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|ERR_PTR
c_func
(paren
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|devmap
op_assign
id|dasd_devmap_from_devno
(paren
id|devno
)paren
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
id|device
op_assign
id|dasd_alloc_device
c_func
(paren
id|devmap-&gt;devindex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|device
)paren
)paren
r_return
id|device
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|device-&gt;ref_count
comma
l_int|1
)paren
suffix:semicolon
id|device-&gt;ro_flag
op_assign
(paren
id|devmap-&gt;features
op_amp
id|DASD_FEATURE_READONLY
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|device-&gt;use_diag_flag
op_assign
l_int|1
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|cdev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cdev-&gt;dev.driver_data
op_eq
l_int|NULL
)paren
(brace
id|get_device
c_func
(paren
op_amp
id|cdev-&gt;dev
)paren
suffix:semicolon
id|cdev-&gt;dev.driver_data
op_assign
id|device
suffix:semicolon
id|device-&gt;gdp-&gt;driverfs_dev
op_assign
op_amp
id|cdev-&gt;dev
suffix:semicolon
id|device-&gt;cdev
op_assign
id|cdev
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
)brace
r_else
multiline_comment|/* Someone else was faster. */
id|rc
op_assign
op_minus
id|EBUSY
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|cdev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|dasd_free_device
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/* Device created successfully. Make it known via devmap. */
id|spin_lock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
id|devmap-&gt;device
op_assign
id|device
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
r_return
id|device
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait queue for dasd_delete_device waits.&n; */
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|dasd_delete_wq
)paren
suffix:semicolon
multiline_comment|/*&n; * Remove a dasd device structure.&n; */
r_void
DECL|function|dasd_delete_device
id|dasd_delete_device
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
r_struct
id|ccw_device
op_star
id|cdev
suffix:semicolon
r_struct
id|dasd_devmap
op_star
id|devmap
suffix:semicolon
r_int
id|devno
suffix:semicolon
multiline_comment|/* First remove device pointer from devmap. */
id|devno
op_assign
id|_ccw_device_get_device_number
c_func
(paren
id|device-&gt;cdev
)paren
suffix:semicolon
id|devmap
op_assign
id|dasd_devmap_from_devno
(paren
id|devno
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
id|devmap-&gt;device
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dasd_devmap_lock
)paren
suffix:semicolon
multiline_comment|/* Wait for reference counter to drop to zero. */
id|atomic_dec
c_func
(paren
op_amp
id|device-&gt;ref_count
)paren
suffix:semicolon
id|wait_event
c_func
(paren
id|dasd_delete_wq
comma
id|atomic_read
c_func
(paren
op_amp
id|device-&gt;ref_count
)paren
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Disconnect dasd_device structure from ccw_device structure. */
id|cdev
op_assign
id|device-&gt;cdev
suffix:semicolon
id|device-&gt;cdev
op_assign
l_int|NULL
suffix:semicolon
id|device-&gt;gdp-&gt;driverfs_dev
op_assign
l_int|NULL
suffix:semicolon
id|cdev-&gt;dev.driver_data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Put ccw_device structure. */
id|put_device
c_func
(paren
op_amp
id|cdev-&gt;dev
)paren
suffix:semicolon
multiline_comment|/* Now the device structure can be freed. */
id|dasd_free_device
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Reference counter dropped to zero. Wake up waiter&n; * in dasd_delete_device.&n; */
r_void
DECL|function|dasd_put_device_wake
id|dasd_put_device_wake
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|dasd_delete_wq
)paren
suffix:semicolon
)brace
r_int
DECL|function|dasd_devmap_init
id|dasd_devmap_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Initialize devmap structures. */
id|dasd_max_devindex
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dasd_devindex_hashlists
(braket
id|i
)braket
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dasd_devno_hashlists
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|dasd_devmap_exit
id|dasd_devmap_exit
c_func
(paren
r_void
)paren
(brace
id|dasd_forget_ranges
c_func
(paren
)paren
suffix:semicolon
)brace
eof
