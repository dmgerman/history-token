multiline_comment|/*&n; * File...........: linux/drivers/s390/block/dasd.c&n; * Author(s)......: Holger Smolinski &lt;Holger.Smolinski@de.ibm.com&gt;&n; *&t;&t;    Horst Hummel &lt;Horst.Hummel@de.ibm.com&gt;&n; *&t;&t;    Carsten Otte &lt;Cotte@de.ibm.com&gt;&n; *&t;&t;    Martin Schwidefsky &lt;schwidefsky@de.ibm.com&gt;&n; * Bugreports.to..: &lt;Linux390@de.ibm.com&gt;&n; * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999-2001&n; *&n; * $Revision: 1.154 $&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;asm/ccwdev.h&gt;
macro_line|#include &lt;asm/ebcdic.h&gt;
macro_line|#include &lt;asm/idals.h&gt;
macro_line|#include &lt;asm/todclk.h&gt;
multiline_comment|/* This is ugly... */
DECL|macro|PRINTK_HEADER
mdefine_line|#define PRINTK_HEADER &quot;dasd:&quot;
macro_line|#include &quot;dasd_int.h&quot;
multiline_comment|/*&n; * SECTION: Constant definitions to be used within this file&n; */
DECL|macro|DASD_CHANQ_MAX_SIZE
mdefine_line|#define DASD_CHANQ_MAX_SIZE 4
multiline_comment|/*&n; * SECTION: exported variables of dasd.c&n; */
DECL|variable|dasd_debug_area
id|debug_info_t
op_star
id|dasd_debug_area
suffix:semicolon
DECL|variable|dasd_diag_discipline_pointer
r_struct
id|dasd_discipline
op_star
id|dasd_diag_discipline_pointer
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Holger Smolinski &lt;Holger.Smolinski@de.ibm.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Linux on S/390 DASD device driver,&quot;
l_string|&quot; Copyright 2000 IBM Corporation&quot;
)paren
suffix:semicolon
id|MODULE_SUPPORTED_DEVICE
c_func
(paren
l_string|&quot;dasd&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|dasd
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
l_int|256
)paren
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * SECTION: prototypes for static functions of dasd.c&n; */
r_static
r_int
id|dasd_alloc_queue
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
suffix:semicolon
r_static
r_void
id|dasd_setup_queue
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
suffix:semicolon
r_static
r_void
id|dasd_free_queue
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
suffix:semicolon
r_static
r_void
id|dasd_flush_request_queue
c_func
(paren
r_struct
id|dasd_device
op_star
)paren
suffix:semicolon
r_static
r_void
id|dasd_int_handler
c_func
(paren
r_struct
id|ccw_device
op_star
comma
r_int
r_int
comma
r_struct
id|irb
op_star
)paren
suffix:semicolon
r_static
r_void
id|dasd_flush_ccw_queue
c_func
(paren
r_struct
id|dasd_device
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|dasd_tasklet
c_func
(paren
r_struct
id|dasd_device
op_star
)paren
suffix:semicolon
r_static
r_void
id|do_kick_device
c_func
(paren
r_void
op_star
id|data
)paren
suffix:semicolon
multiline_comment|/*&n; * SECTION: Operations on the device structure.&n; */
DECL|variable|dasd_init_waitq
r_static
id|wait_queue_head_t
id|dasd_init_waitq
suffix:semicolon
multiline_comment|/*&n; * Allocate memory for a new device structure.&n; */
r_struct
id|dasd_device
op_star
DECL|function|dasd_alloc_device
id|dasd_alloc_device
c_func
(paren
r_void
)paren
(brace
r_struct
id|dasd_device
op_star
id|device
suffix:semicolon
id|device
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|dasd_device
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device
op_eq
l_int|NULL
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|memset
c_func
(paren
id|device
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|dasd_device
)paren
)paren
suffix:semicolon
multiline_comment|/* open_count = 0 means device online but not in use */
id|atomic_set
c_func
(paren
op_amp
id|device-&gt;open_count
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Get two pages for normal block device operations. */
id|device-&gt;ccw_mem
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
op_or
id|GFP_DMA
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;ccw_mem
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
multiline_comment|/* Get one page for error recovery. */
id|device-&gt;erp_mem
op_assign
(paren
r_void
op_star
)paren
id|get_zeroed_page
c_func
(paren
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;erp_mem
op_eq
l_int|NULL
)paren
(brace
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|device-&gt;ccw_mem
comma
l_int|1
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|dasd_init_chunklist
c_func
(paren
op_amp
id|device-&gt;ccw_chunks
comma
id|device-&gt;ccw_mem
comma
id|PAGE_SIZE
op_star
l_int|2
)paren
suffix:semicolon
id|dasd_init_chunklist
c_func
(paren
op_amp
id|device-&gt;erp_chunks
comma
id|device-&gt;erp_mem
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|device-&gt;mem_lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|device-&gt;request_queue_lock
)paren
suffix:semicolon
id|atomic_set
(paren
op_amp
id|device-&gt;tasklet_scheduled
comma
l_int|0
)paren
suffix:semicolon
id|tasklet_init
c_func
(paren
op_amp
id|device-&gt;tasklet
comma
(paren
r_void
(paren
op_star
)paren
(paren
r_int
r_int
)paren
)paren
id|dasd_tasklet
comma
(paren
r_int
r_int
)paren
id|device
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|device-&gt;ccw_queue
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|device-&gt;timer
)paren
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|device-&gt;kick_work
comma
id|do_kick_device
comma
id|device
)paren
suffix:semicolon
id|device-&gt;state
op_assign
id|DASD_STATE_NEW
suffix:semicolon
id|device-&gt;target
op_assign
id|DASD_STATE_NEW
suffix:semicolon
r_return
id|device
suffix:semicolon
)brace
multiline_comment|/*&n; * Free memory of a device structure.&n; */
r_void
DECL|function|dasd_free_device
id|dasd_free_device
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
r_if
c_cond
(paren
id|device
op_member_access_from_pointer
r_private
)paren
id|kfree
c_func
(paren
id|device
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|device-&gt;erp_mem
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|device-&gt;ccw_mem
comma
l_int|1
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Make a new device known to the system.&n; */
r_static
r_inline
r_int
DECL|function|dasd_state_new_to_known
id|dasd_state_new_to_known
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
r_int
id|rc
suffix:semicolon
multiline_comment|/*&n;&t; * As long as the device is not in state DASD_STATE_NEW we want to &n;&t; * keep the reference count &gt; 0.&n;&t; */
id|dasd_get_device
c_func
(paren
id|device
)paren
suffix:semicolon
id|rc
op_assign
id|dasd_alloc_queue
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|dasd_put_device
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|device-&gt;state
op_assign
id|DASD_STATE_KNOWN
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Let the system forget about a device.&n; */
r_static
r_inline
r_void
DECL|function|dasd_state_known_to_new
id|dasd_state_known_to_new
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
multiline_comment|/* Forget the discipline information. */
id|device-&gt;discipline
op_assign
l_int|NULL
suffix:semicolon
id|device-&gt;state
op_assign
id|DASD_STATE_NEW
suffix:semicolon
id|dasd_free_queue
c_func
(paren
id|device
)paren
suffix:semicolon
multiline_comment|/* Give up reference we took in dasd_state_new_to_known. */
id|dasd_put_device
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Request the irq line for the device.&n; */
r_static
r_inline
r_int
DECL|function|dasd_state_known_to_basic
id|dasd_state_known_to_basic
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
r_int
id|rc
suffix:semicolon
multiline_comment|/* Allocate and register gendisk structure. */
id|rc
op_assign
id|dasd_gendisk_alloc
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* register &squot;device&squot; debug area, used for all DBF_DEV_XXX calls */
id|device-&gt;debug_area
op_assign
id|debug_register
c_func
(paren
id|device-&gt;cdev-&gt;dev.bus_id
comma
l_int|0
comma
l_int|2
comma
l_int|8
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|debug_register_view
c_func
(paren
id|device-&gt;debug_area
comma
op_amp
id|debug_sprintf_view
)paren
suffix:semicolon
id|debug_set_level
c_func
(paren
id|device-&gt;debug_area
comma
id|DBF_DEBUG
)paren
suffix:semicolon
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_EMERG
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;debug area created&quot;
)paren
suffix:semicolon
id|device-&gt;state
op_assign
id|DASD_STATE_BASIC
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Release the irq line for the device. Terminate any running i/o.&n; */
r_static
r_inline
r_void
DECL|function|dasd_state_basic_to_known
id|dasd_state_basic_to_known
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
id|dasd_gendisk_free
c_func
(paren
id|device
)paren
suffix:semicolon
id|dasd_flush_ccw_queue
c_func
(paren
id|device
comma
l_int|1
)paren
suffix:semicolon
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_EMERG
comma
id|device
comma
l_string|&quot;%p debug area deleted&quot;
comma
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;debug_area
op_ne
l_int|NULL
)paren
(brace
id|debug_unregister
c_func
(paren
id|device-&gt;debug_area
)paren
suffix:semicolon
id|device-&gt;debug_area
op_assign
l_int|NULL
suffix:semicolon
)brace
id|device-&gt;state
op_assign
id|DASD_STATE_KNOWN
suffix:semicolon
)brace
multiline_comment|/*&n; * Do the initial analysis. The do_analysis function may return&n; * -EAGAIN in which case the device keeps the state DASD_STATE_BASIC&n; * until the discipline decides to continue the startup sequence&n; * by calling the function dasd_change_state. The eckd disciplines&n; * uses this to start a ccw that detects the format. The completion&n; * interrupt for this detection ccw uses the kernel event daemon to&n; * trigger the call to dasd_change_state. All this is done in the&n; * discipline code, see dasd_eckd.c.&n; * After the analysis ccw is done (do_analysis returned 0 or error)&n; * the block device is setup. Either a fake disk is added to allow&n; * formatting or a proper device request queue is created.&n; */
r_static
r_inline
r_int
DECL|function|dasd_state_basic_to_ready
id|dasd_state_basic_to_ready
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
r_int
id|rc
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;discipline-&gt;do_analysis
op_ne
l_int|NULL
)paren
id|rc
op_assign
id|device-&gt;discipline
op_member_access_from_pointer
id|do_analysis
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|dasd_setup_queue
c_func
(paren
id|device
)paren
suffix:semicolon
id|device-&gt;state
op_assign
id|DASD_STATE_READY
suffix:semicolon
r_if
c_cond
(paren
id|dasd_scan_partitions
c_func
(paren
id|device
)paren
op_ne
l_int|0
)paren
id|device-&gt;state
op_assign
id|DASD_STATE_BASIC
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove device from block device layer. Destroy dirty buffers.&n; * Forget format information. Check if the target level is basic&n; * and if it is create fake disk for formatting.&n; */
r_static
r_inline
r_void
DECL|function|dasd_state_ready_to_basic
id|dasd_state_ready_to_basic
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
id|dasd_flush_ccw_queue
c_func
(paren
id|device
comma
l_int|0
)paren
suffix:semicolon
id|dasd_destroy_partitions
c_func
(paren
id|device
)paren
suffix:semicolon
id|dasd_flush_request_queue
c_func
(paren
id|device
)paren
suffix:semicolon
id|device-&gt;blocks
op_assign
l_int|0
suffix:semicolon
id|device-&gt;bp_block
op_assign
l_int|0
suffix:semicolon
id|device-&gt;s2b_shift
op_assign
l_int|0
suffix:semicolon
id|device-&gt;state
op_assign
id|DASD_STATE_BASIC
suffix:semicolon
)brace
multiline_comment|/*&n; * Make the device online and schedule the bottom half to start&n; * the requeueing of requests from the linux request queue to the&n; * ccw queue.&n; */
r_static
r_inline
r_int
DECL|function|dasd_state_ready_to_online
id|dasd_state_ready_to_online
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
id|device-&gt;state
op_assign
id|DASD_STATE_ONLINE
suffix:semicolon
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Stop the requeueing of requests again.&n; */
r_static
r_inline
r_void
DECL|function|dasd_state_online_to_ready
id|dasd_state_online_to_ready
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
id|device-&gt;state
op_assign
id|DASD_STATE_READY
suffix:semicolon
)brace
multiline_comment|/*&n; * Device startup state changes.&n; */
r_static
r_inline
r_int
DECL|function|dasd_increase_state
id|dasd_increase_state
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
r_int
id|rc
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;state
op_eq
id|DASD_STATE_NEW
op_logical_and
id|device-&gt;target
op_ge
id|DASD_STATE_KNOWN
)paren
id|rc
op_assign
id|dasd_state_new_to_known
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rc
op_logical_and
id|device-&gt;state
op_eq
id|DASD_STATE_KNOWN
op_logical_and
id|device-&gt;target
op_ge
id|DASD_STATE_BASIC
)paren
id|rc
op_assign
id|dasd_state_known_to_basic
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rc
op_logical_and
id|device-&gt;state
op_eq
id|DASD_STATE_BASIC
op_logical_and
id|device-&gt;target
op_ge
id|DASD_STATE_READY
)paren
id|rc
op_assign
id|dasd_state_basic_to_ready
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rc
op_logical_and
id|device-&gt;state
op_eq
id|DASD_STATE_READY
op_logical_and
id|device-&gt;target
op_ge
id|DASD_STATE_ONLINE
)paren
id|rc
op_assign
id|dasd_state_ready_to_online
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Device shutdown state changes.&n; */
r_static
r_inline
r_int
DECL|function|dasd_decrease_state
id|dasd_decrease_state
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
r_if
c_cond
(paren
id|device-&gt;state
op_eq
id|DASD_STATE_ONLINE
op_logical_and
id|device-&gt;target
op_le
id|DASD_STATE_READY
)paren
id|dasd_state_online_to_ready
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;state
op_eq
id|DASD_STATE_READY
op_logical_and
id|device-&gt;target
op_le
id|DASD_STATE_BASIC
)paren
id|dasd_state_ready_to_basic
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;state
op_eq
id|DASD_STATE_BASIC
op_logical_and
id|device-&gt;target
op_le
id|DASD_STATE_KNOWN
)paren
id|dasd_state_basic_to_known
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;state
op_eq
id|DASD_STATE_KNOWN
op_logical_and
id|device-&gt;target
op_le
id|DASD_STATE_NEW
)paren
id|dasd_state_known_to_new
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the main startup/shutdown routine.&n; */
r_static
r_void
DECL|function|dasd_change_state
id|dasd_change_state
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;state
op_eq
id|device-&gt;target
)paren
multiline_comment|/* Already where we want to go today... */
r_return
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;state
OL
id|device-&gt;target
)paren
id|rc
op_assign
id|dasd_increase_state
c_func
(paren
id|device
)paren
suffix:semicolon
r_else
id|rc
op_assign
id|dasd_decrease_state
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_logical_and
id|rc
op_ne
op_minus
id|EAGAIN
)paren
id|device-&gt;target
op_assign
id|device-&gt;state
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;state
op_eq
id|device-&gt;target
)paren
id|wake_up
c_func
(paren
op_amp
id|dasd_init_waitq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Kick starter for devices that did not complete the startup/shutdown&n; * procedure or were sleeping because of a pending state.&n; * dasd_kick_device will schedule a call do do_kick_device to the kernel&n; * event daemon.&n; */
r_static
r_void
DECL|function|do_kick_device
id|do_kick_device
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|dasd_device
op_star
id|device
suffix:semicolon
id|device
op_assign
(paren
r_struct
id|dasd_device
op_star
)paren
id|data
suffix:semicolon
id|dasd_change_state
c_func
(paren
id|device
)paren
suffix:semicolon
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
id|dasd_put_device
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
r_void
DECL|function|dasd_kick_device
id|dasd_kick_device
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
id|dasd_get_device
c_func
(paren
id|device
)paren
suffix:semicolon
multiline_comment|/* queue call to dasd_kick_device to the kernel event daemon. */
id|schedule_work
c_func
(paren
op_amp
id|device-&gt;kick_work
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the target state for a device and starts the state change.&n; */
r_void
DECL|function|dasd_set_target_state
id|dasd_set_target_state
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
comma
r_int
id|target
)paren
(brace
multiline_comment|/* If we are in probeonly mode stop at DASD_STATE_READY. */
r_if
c_cond
(paren
id|dasd_probeonly
op_logical_and
id|target
OG
id|DASD_STATE_READY
)paren
id|target
op_assign
id|DASD_STATE_READY
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;target
op_ne
id|target
)paren
(brace
r_if
c_cond
(paren
id|device-&gt;state
op_eq
id|target
)paren
id|wake_up
c_func
(paren
op_amp
id|dasd_init_waitq
)paren
suffix:semicolon
id|device-&gt;target
op_assign
id|target
suffix:semicolon
)brace
r_if
c_cond
(paren
id|device-&gt;state
op_ne
id|device-&gt;target
)paren
id|dasd_change_state
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Enable devices with device numbers in [from..to].&n; */
r_static
r_inline
r_int
DECL|function|_wait_for_device
id|_wait_for_device
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
r_return
(paren
id|device-&gt;state
op_eq
id|device-&gt;target
)paren
suffix:semicolon
)brace
r_void
DECL|function|dasd_enable_device
id|dasd_enable_device
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
id|dasd_set_target_state
c_func
(paren
id|device
comma
id|DASD_STATE_ONLINE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;state
op_le
id|DASD_STATE_KNOWN
)paren
multiline_comment|/* No discipline for device found. */
id|dasd_set_target_state
c_func
(paren
id|device
comma
id|DASD_STATE_NEW
)paren
suffix:semicolon
multiline_comment|/* Now wait for the devices to come up. */
id|wait_event
c_func
(paren
id|dasd_init_waitq
comma
id|_wait_for_device
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * SECTION: device operation (interrupt handler, start i/o, term i/o ...)&n; */
macro_line|#ifdef CONFIG_DASD_PROFILE
DECL|variable|dasd_global_profile
r_struct
id|dasd_profile_info_t
id|dasd_global_profile
suffix:semicolon
DECL|variable|dasd_profile_level
r_int
r_int
id|dasd_profile_level
op_assign
id|DASD_PROFILE_OFF
suffix:semicolon
multiline_comment|/*&n; * Increments counter in global and local profiling structures.&n; */
DECL|macro|dasd_profile_counter
mdefine_line|#define dasd_profile_counter(value, counter, device) &bslash;&n;{ &bslash;&n;&t;int index; &bslash;&n;&t;for (index = 0; index &lt; 31 &amp;&amp; value &gt;&gt; (2+index); index++); &bslash;&n;&t;dasd_global_profile.counter[index]++; &bslash;&n;&t;device-&gt;profile.counter[index]++; &bslash;&n;}
multiline_comment|/*&n; * Add profiling information for cqr before execution.&n; */
r_static
r_inline
r_void
DECL|function|dasd_profile_start
id|dasd_profile_start
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
comma
r_struct
id|dasd_ccw_req
op_star
id|cqr
comma
r_struct
id|request
op_star
id|req
)paren
(brace
r_struct
id|list_head
op_star
id|l
suffix:semicolon
r_int
r_int
id|counter
suffix:semicolon
r_if
c_cond
(paren
id|dasd_profile_level
op_ne
id|DASD_PROFILE_ON
)paren
r_return
suffix:semicolon
multiline_comment|/* count the length of the chanq for statistics */
id|counter
op_assign
l_int|0
suffix:semicolon
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|device-&gt;ccw_queue
)paren
r_if
c_cond
(paren
op_increment
id|counter
op_ge
l_int|31
)paren
r_break
suffix:semicolon
id|dasd_global_profile.dasd_io_nr_req
(braket
id|counter
)braket
op_increment
suffix:semicolon
id|device-&gt;profile.dasd_io_nr_req
(braket
id|counter
)braket
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * Add profiling information for cqr after execution.&n; */
r_static
r_inline
r_void
DECL|function|dasd_profile_end
id|dasd_profile_end
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
comma
r_struct
id|dasd_ccw_req
op_star
id|cqr
comma
r_struct
id|request
op_star
id|req
)paren
(brace
r_int
id|strtime
comma
id|irqtime
comma
id|endtime
comma
id|tottime
suffix:semicolon
multiline_comment|/* in microseconds */
r_int
id|tottimeps
comma
id|sectors
suffix:semicolon
r_if
c_cond
(paren
id|dasd_profile_level
op_ne
id|DASD_PROFILE_ON
)paren
r_return
suffix:semicolon
id|sectors
op_assign
id|req-&gt;nr_sectors
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cqr-&gt;buildclk
op_logical_or
op_logical_neg
id|cqr-&gt;startclk
op_logical_or
op_logical_neg
id|cqr-&gt;stopclk
op_logical_or
op_logical_neg
id|cqr-&gt;endclk
op_logical_or
op_logical_neg
id|sectors
)paren
r_return
suffix:semicolon
id|strtime
op_assign
(paren
(paren
id|cqr-&gt;startclk
op_minus
id|cqr-&gt;buildclk
)paren
op_rshift
l_int|12
)paren
suffix:semicolon
id|irqtime
op_assign
(paren
(paren
id|cqr-&gt;stopclk
op_minus
id|cqr-&gt;startclk
)paren
op_rshift
l_int|12
)paren
suffix:semicolon
id|endtime
op_assign
(paren
(paren
id|cqr-&gt;endclk
op_minus
id|cqr-&gt;stopclk
)paren
op_rshift
l_int|12
)paren
suffix:semicolon
id|tottime
op_assign
(paren
(paren
id|cqr-&gt;endclk
op_minus
id|cqr-&gt;buildclk
)paren
op_rshift
l_int|12
)paren
suffix:semicolon
id|tottimeps
op_assign
id|tottime
op_div
id|sectors
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dasd_global_profile.dasd_io_reqs
)paren
id|memset
c_func
(paren
op_amp
id|dasd_global_profile
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|dasd_profile_info_t
)paren
)paren
suffix:semicolon
id|dasd_global_profile.dasd_io_reqs
op_increment
suffix:semicolon
id|dasd_global_profile.dasd_io_sects
op_add_assign
id|sectors
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device-&gt;profile.dasd_io_reqs
)paren
id|memset
c_func
(paren
op_amp
id|device-&gt;profile
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|dasd_profile_info_t
)paren
)paren
suffix:semicolon
id|device-&gt;profile.dasd_io_reqs
op_increment
suffix:semicolon
id|device-&gt;profile.dasd_io_sects
op_add_assign
id|sectors
suffix:semicolon
id|dasd_profile_counter
c_func
(paren
id|sectors
comma
id|dasd_io_secs
comma
id|device
)paren
suffix:semicolon
id|dasd_profile_counter
c_func
(paren
id|tottime
comma
id|dasd_io_times
comma
id|device
)paren
suffix:semicolon
id|dasd_profile_counter
c_func
(paren
id|tottimeps
comma
id|dasd_io_timps
comma
id|device
)paren
suffix:semicolon
id|dasd_profile_counter
c_func
(paren
id|strtime
comma
id|dasd_io_time1
comma
id|device
)paren
suffix:semicolon
id|dasd_profile_counter
c_func
(paren
id|irqtime
comma
id|dasd_io_time2
comma
id|device
)paren
suffix:semicolon
id|dasd_profile_counter
c_func
(paren
id|irqtime
op_div
id|sectors
comma
id|dasd_io_time2ps
comma
id|device
)paren
suffix:semicolon
id|dasd_profile_counter
c_func
(paren
id|endtime
comma
id|dasd_io_time3
comma
id|device
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|dasd_profile_start
mdefine_line|#define dasd_profile_start(device, cqr, req) do {} while (0)
DECL|macro|dasd_profile_end
mdefine_line|#define dasd_profile_end(device, cqr, req) do {} while (0)
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_PROFILE */
multiline_comment|/*&n; * Allocate memory for a channel program with &squot;cplength&squot; channel&n; * command words and &squot;datasize&squot; additional space. There are two&n; * variantes: 1) dasd_kmalloc_request uses kmalloc to get the needed&n; * memory and 2) dasd_smalloc_request uses the static ccw memory&n; * that gets allocated for each device.&n; */
r_struct
id|dasd_ccw_req
op_star
DECL|function|dasd_kmalloc_request
id|dasd_kmalloc_request
c_func
(paren
r_char
op_star
id|magic
comma
r_int
id|cplength
comma
r_int
id|datasize
comma
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
r_struct
id|dasd_ccw_req
op_star
id|cqr
suffix:semicolon
multiline_comment|/* Sanity checks */
r_if
c_cond
(paren
id|magic
op_eq
l_int|NULL
op_logical_or
id|datasize
OG
id|PAGE_SIZE
op_logical_or
(paren
id|cplength
op_star
r_sizeof
(paren
r_struct
id|ccw1
)paren
)paren
OG
id|PAGE_SIZE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|cqr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|dasd_ccw_req
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr
op_eq
l_int|NULL
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cqr
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|dasd_ccw_req
)paren
)paren
suffix:semicolon
id|cqr-&gt;cpaddr
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cplength
OG
l_int|0
)paren
(brace
id|cqr-&gt;cpaddr
op_assign
id|kmalloc
c_func
(paren
id|cplength
op_star
r_sizeof
(paren
r_struct
id|ccw1
)paren
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;cpaddr
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|cqr
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|cqr-&gt;cpaddr
comma
l_int|0
comma
id|cplength
op_star
r_sizeof
(paren
r_struct
id|ccw1
)paren
)paren
suffix:semicolon
)brace
id|cqr-&gt;data
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|datasize
OG
l_int|0
)paren
(brace
id|cqr-&gt;data
op_assign
id|kmalloc
c_func
(paren
id|datasize
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;data
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|cqr-&gt;cpaddr
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|cqr-&gt;cpaddr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|cqr
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|cqr-&gt;data
comma
l_int|0
comma
id|datasize
)paren
suffix:semicolon
)brace
id|strncpy
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|cqr-&gt;magic
comma
id|magic
comma
l_int|4
)paren
suffix:semicolon
id|ASCEBC
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|cqr-&gt;magic
comma
l_int|4
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|DASD_CQR_FLAGS_USE_ERP
comma
op_amp
id|cqr-&gt;flags
)paren
suffix:semicolon
id|dasd_get_device
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
id|cqr
suffix:semicolon
)brace
r_struct
id|dasd_ccw_req
op_star
DECL|function|dasd_smalloc_request
id|dasd_smalloc_request
c_func
(paren
r_char
op_star
id|magic
comma
r_int
id|cplength
comma
r_int
id|datasize
comma
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|dasd_ccw_req
op_star
id|cqr
suffix:semicolon
r_char
op_star
id|data
suffix:semicolon
r_int
id|size
suffix:semicolon
multiline_comment|/* Sanity checks */
r_if
c_cond
(paren
id|magic
op_eq
l_int|NULL
op_logical_or
id|datasize
OG
id|PAGE_SIZE
op_logical_or
(paren
id|cplength
op_star
r_sizeof
(paren
r_struct
id|ccw1
)paren
)paren
OG
id|PAGE_SIZE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|size
op_assign
(paren
r_sizeof
(paren
r_struct
id|dasd_ccw_req
)paren
op_plus
l_int|7L
)paren
op_amp
op_minus
l_int|8L
suffix:semicolon
r_if
c_cond
(paren
id|cplength
OG
l_int|0
)paren
id|size
op_add_assign
id|cplength
op_star
r_sizeof
(paren
r_struct
id|ccw1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|datasize
OG
l_int|0
)paren
id|size
op_add_assign
id|datasize
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|device-&gt;mem_lock
comma
id|flags
)paren
suffix:semicolon
id|cqr
op_assign
(paren
r_struct
id|dasd_ccw_req
op_star
)paren
id|dasd_alloc_chunk
c_func
(paren
op_amp
id|device-&gt;ccw_chunks
comma
id|size
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device-&gt;mem_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr
op_eq
l_int|NULL
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cqr
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|dasd_ccw_req
)paren
)paren
suffix:semicolon
id|data
op_assign
(paren
r_char
op_star
)paren
id|cqr
op_plus
(paren
(paren
r_sizeof
(paren
r_struct
id|dasd_ccw_req
)paren
op_plus
l_int|7L
)paren
op_amp
op_minus
l_int|8L
)paren
suffix:semicolon
id|cqr-&gt;cpaddr
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cplength
OG
l_int|0
)paren
(brace
id|cqr-&gt;cpaddr
op_assign
(paren
r_struct
id|ccw1
op_star
)paren
id|data
suffix:semicolon
id|data
op_add_assign
id|cplength
op_star
r_sizeof
(paren
r_struct
id|ccw1
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cqr-&gt;cpaddr
comma
l_int|0
comma
id|cplength
op_star
r_sizeof
(paren
r_struct
id|ccw1
)paren
)paren
suffix:semicolon
)brace
id|cqr-&gt;data
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|datasize
OG
l_int|0
)paren
(brace
id|cqr-&gt;data
op_assign
id|data
suffix:semicolon
id|memset
c_func
(paren
id|cqr-&gt;data
comma
l_int|0
comma
id|datasize
)paren
suffix:semicolon
)brace
id|strncpy
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|cqr-&gt;magic
comma
id|magic
comma
l_int|4
)paren
suffix:semicolon
id|ASCEBC
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|cqr-&gt;magic
comma
l_int|4
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|DASD_CQR_FLAGS_USE_ERP
comma
op_amp
id|cqr-&gt;flags
)paren
suffix:semicolon
id|dasd_get_device
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
id|cqr
suffix:semicolon
)brace
multiline_comment|/*&n; * Free memory of a channel program. This function needs to free all the&n; * idal lists that might have been created by dasd_set_cda and the&n; * struct dasd_ccw_req itself.&n; */
r_void
DECL|function|dasd_kfree_request
id|dasd_kfree_request
c_func
(paren
r_struct
id|dasd_ccw_req
op_star
id|cqr
comma
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
macro_line|#ifdef CONFIG_ARCH_S390X
r_struct
id|ccw1
op_star
id|ccw
suffix:semicolon
multiline_comment|/* Clear any idals used for the request. */
id|ccw
op_assign
id|cqr-&gt;cpaddr
suffix:semicolon
r_do
(brace
id|clear_normalized_cda
c_func
(paren
id|ccw
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ccw
op_increment
op_member_access_from_pointer
id|flags
op_amp
(paren
id|CCW_FLAG_CC
op_or
id|CCW_FLAG_DC
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cqr-&gt;cpaddr
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|cqr-&gt;cpaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;data
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|cqr-&gt;data
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|cqr
)paren
suffix:semicolon
id|dasd_put_device
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
r_void
DECL|function|dasd_sfree_request
id|dasd_sfree_request
c_func
(paren
r_struct
id|dasd_ccw_req
op_star
id|cqr
comma
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|device-&gt;mem_lock
comma
id|flags
)paren
suffix:semicolon
id|dasd_free_chunk
c_func
(paren
op_amp
id|device-&gt;ccw_chunks
comma
id|cqr
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device-&gt;mem_lock
comma
id|flags
)paren
suffix:semicolon
id|dasd_put_device
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Check discipline magic in cqr.&n; */
r_static
r_inline
r_int
DECL|function|dasd_check_cqr
id|dasd_check_cqr
c_func
(paren
r_struct
id|dasd_ccw_req
op_star
id|cqr
)paren
(brace
r_struct
id|dasd_device
op_star
id|device
suffix:semicolon
r_if
c_cond
(paren
id|cqr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|device
op_assign
id|cqr-&gt;device
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|cqr-&gt;magic
comma
id|device-&gt;discipline-&gt;ebcname
comma
l_int|4
)paren
)paren
(brace
id|DEV_MESSAGE
c_func
(paren
id|KERN_WARNING
comma
id|device
comma
l_string|&quot; dasd_ccw_req 0x%08x magic doesn&squot;t match&quot;
l_string|&quot; discipline 0x%08x&quot;
comma
id|cqr-&gt;magic
comma
op_star
(paren
r_int
r_int
op_star
)paren
id|device-&gt;discipline-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Terminate the current i/o and set the request to clear_pending.&n; * Timer keeps device runnig.&n; * ccw_device_clear can fail if the i/o subsystem&n; * is in a bad mood.&n; */
r_int
DECL|function|dasd_term_IO
id|dasd_term_IO
c_func
(paren
r_struct
id|dasd_ccw_req
op_star
id|cqr
)paren
(brace
r_struct
id|dasd_device
op_star
id|device
suffix:semicolon
r_int
id|retries
comma
id|rc
suffix:semicolon
multiline_comment|/* Check the cqr */
id|rc
op_assign
id|dasd_check_cqr
c_func
(paren
id|cqr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|retries
op_assign
l_int|0
suffix:semicolon
id|device
op_assign
(paren
r_struct
id|dasd_device
op_star
)paren
id|cqr-&gt;device
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retries
OL
l_int|5
)paren
op_logical_and
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_IN_IO
)paren
)paren
(brace
id|rc
op_assign
id|ccw_device_clear
c_func
(paren
id|device-&gt;cdev
comma
(paren
r_int
)paren
id|cqr
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|rc
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* termination successful */
r_if
c_cond
(paren
id|cqr-&gt;retries
OG
l_int|0
)paren
(brace
id|cqr-&gt;retries
op_decrement
suffix:semicolon
id|cqr-&gt;status
op_assign
id|DASD_CQR_CLEAR
suffix:semicolon
)brace
r_else
id|cqr-&gt;status
op_assign
id|DASD_CQR_FAILED
suffix:semicolon
id|cqr-&gt;stopclk
op_assign
id|get_clock
c_func
(paren
)paren
suffix:semicolon
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_DEBUG
comma
id|device
comma
l_string|&quot;terminate cqr %p successful&quot;
comma
id|cqr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|ENODEV
suffix:colon
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_ERR
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;device gone, retry&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|EIO
suffix:colon
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_ERR
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;I/O error, retry&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|EINVAL
suffix:colon
r_case
op_minus
id|EBUSY
suffix:colon
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_ERR
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;device busy, retry later&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEV_MESSAGE
c_func
(paren
id|KERN_ERR
comma
id|device
comma
l_string|&quot;line %d unknown RC=%d, please &quot;
l_string|&quot;report to linux390@de.ibm.com&quot;
comma
id|__LINE__
comma
id|rc
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|retries
op_increment
suffix:semicolon
)brace
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Start the i/o. This start_IO can fail if the channel is really busy.&n; * In that case set up a timer to start the request later.&n; */
r_int
DECL|function|dasd_start_IO
id|dasd_start_IO
c_func
(paren
r_struct
id|dasd_ccw_req
op_star
id|cqr
)paren
(brace
r_struct
id|dasd_device
op_star
id|device
suffix:semicolon
r_int
id|rc
suffix:semicolon
multiline_comment|/* Check the cqr */
id|rc
op_assign
id|dasd_check_cqr
c_func
(paren
id|cqr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|device
op_assign
(paren
r_struct
id|dasd_device
op_star
)paren
id|cqr-&gt;device
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;retries
OL
l_int|0
)paren
(brace
id|DEV_MESSAGE
c_func
(paren
id|KERN_DEBUG
comma
id|device
comma
l_string|&quot;start_IO: request %p (%02x/%i) - no retry left.&quot;
comma
id|cqr
comma
id|cqr-&gt;status
comma
id|cqr-&gt;retries
)paren
suffix:semicolon
id|cqr-&gt;status
op_assign
id|DASD_CQR_FAILED
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|cqr-&gt;startclk
op_assign
id|get_clock
c_func
(paren
)paren
suffix:semicolon
id|cqr-&gt;starttime
op_assign
id|jiffies
suffix:semicolon
id|cqr-&gt;retries
op_decrement
suffix:semicolon
id|rc
op_assign
id|ccw_device_start
c_func
(paren
id|device-&gt;cdev
comma
id|cqr-&gt;cpaddr
comma
(paren
r_int
)paren
id|cqr
comma
id|cqr-&gt;lpm
comma
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|rc
)paren
(brace
r_case
l_int|0
suffix:colon
id|cqr-&gt;status
op_assign
id|DASD_CQR_IN_IO
suffix:semicolon
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_DEBUG
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;start_IO: request %p started successful&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|EBUSY
suffix:colon
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_ERR
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;start_IO: device busy, retry later&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|ETIMEDOUT
suffix:colon
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_ERR
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;start_IO: request timeout, retry later&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|ENODEV
suffix:colon
r_case
op_minus
id|EIO
suffix:colon
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_ERR
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;start_IO: device gone, retry&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEV_MESSAGE
c_func
(paren
id|KERN_ERR
comma
id|device
comma
l_string|&quot;line %d unknown RC=%d, please report&quot;
l_string|&quot; to linux390@de.ibm.com&quot;
comma
id|__LINE__
comma
id|rc
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Timeout function for dasd devices. This is used for different purposes&n; *  1) missing interrupt handler for normal operation&n; *  2) delayed start of request where start_IO failed with -EBUSY&n; *  3) timeout for missing state change interrupts&n; * The head of the ccw queue will have status DASD_CQR_IN_IO for 1),&n; * DASD_CQR_QUEUED for 2) and 3).&n; */
r_static
r_void
DECL|function|dasd_timeout_device
id|dasd_timeout_device
c_func
(paren
r_int
r_int
id|ptr
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|dasd_device
op_star
id|device
suffix:semicolon
id|device
op_assign
(paren
r_struct
id|dasd_device
op_star
)paren
id|ptr
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* re-activate request queue */
id|device-&gt;stopped
op_and_assign
op_complement
id|DASD_STOPPED_PENDING
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
comma
id|flags
)paren
suffix:semicolon
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Setup timeout for a device in jiffies.&n; */
r_void
DECL|function|dasd_set_timer
id|dasd_set_timer
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
comma
r_int
id|expires
)paren
(brace
r_if
c_cond
(paren
id|expires
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|device-&gt;timer
)paren
)paren
id|del_timer
c_func
(paren
op_amp
id|device-&gt;timer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|device-&gt;timer
)paren
)paren
(brace
r_if
c_cond
(paren
id|mod_timer
c_func
(paren
op_amp
id|device-&gt;timer
comma
id|jiffies
op_plus
id|expires
)paren
)paren
r_return
suffix:semicolon
)brace
id|device-&gt;timer.function
op_assign
id|dasd_timeout_device
suffix:semicolon
id|device-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|device
suffix:semicolon
id|device-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|expires
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|device-&gt;timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Clear timeout for a device.&n; */
r_void
DECL|function|dasd_clear_timer
id|dasd_clear_timer
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|device-&gt;timer
)paren
)paren
id|del_timer
c_func
(paren
op_amp
id|device-&gt;timer
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|dasd_handle_killed_request
id|dasd_handle_killed_request
c_func
(paren
r_struct
id|ccw_device
op_star
id|cdev
comma
r_int
r_int
id|intparm
)paren
(brace
r_struct
id|dasd_ccw_req
op_star
id|cqr
suffix:semicolon
r_struct
id|dasd_device
op_star
id|device
suffix:semicolon
id|cqr
op_assign
(paren
r_struct
id|dasd_ccw_req
op_star
)paren
id|intparm
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;status
op_ne
id|DASD_CQR_IN_IO
)paren
(brace
id|MESSAGE
c_func
(paren
id|KERN_DEBUG
comma
l_string|&quot;invalid status in handle_killed_request: &quot;
l_string|&quot;bus_id %s, status %02x&quot;
comma
id|cdev-&gt;dev.bus_id
comma
id|cqr-&gt;status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|device
op_assign
(paren
r_struct
id|dasd_device
op_star
)paren
id|cqr-&gt;device
suffix:semicolon
r_if
c_cond
(paren
id|device
op_eq
l_int|NULL
op_logical_or
id|device
op_ne
id|dasd_device_from_cdev
c_func
(paren
id|cdev
)paren
op_logical_or
id|strncmp
c_func
(paren
id|device-&gt;discipline-&gt;ebcname
comma
(paren
r_char
op_star
)paren
op_amp
id|cqr-&gt;magic
comma
l_int|4
)paren
)paren
(brace
id|MESSAGE
c_func
(paren
id|KERN_DEBUG
comma
l_string|&quot;invalid device in request: bus_id %s&quot;
comma
id|cdev-&gt;dev.bus_id
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Schedule request to be retried. */
id|cqr-&gt;status
op_assign
id|DASD_CQR_QUEUED
suffix:semicolon
id|dasd_clear_timer
c_func
(paren
id|device
)paren
suffix:semicolon
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
id|dasd_put_device
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|dasd_handle_state_change_pending
id|dasd_handle_state_change_pending
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
r_struct
id|dasd_ccw_req
op_star
id|cqr
suffix:semicolon
r_struct
id|list_head
op_star
id|l
comma
op_star
id|n
suffix:semicolon
id|device-&gt;stopped
op_and_assign
op_complement
id|DASD_STOPPED_PENDING
suffix:semicolon
multiline_comment|/* restart all &squot;running&squot; IO on queue */
id|list_for_each_safe
c_func
(paren
id|l
comma
id|n
comma
op_amp
id|device-&gt;ccw_queue
)paren
(brace
id|cqr
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|dasd_ccw_req
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_IN_IO
)paren
(brace
id|cqr-&gt;status
op_assign
id|DASD_CQR_QUEUED
suffix:semicolon
)brace
)brace
id|dasd_clear_timer
c_func
(paren
id|device
)paren
suffix:semicolon
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Interrupt handler for &quot;normal&quot; ssch-io based dasd devices.&n; */
r_void
DECL|function|dasd_int_handler
id|dasd_int_handler
c_func
(paren
r_struct
id|ccw_device
op_star
id|cdev
comma
r_int
r_int
id|intparm
comma
r_struct
id|irb
op_star
id|irb
)paren
(brace
r_struct
id|dasd_ccw_req
op_star
id|cqr
comma
op_star
id|next
suffix:semicolon
r_struct
id|dasd_device
op_star
id|device
suffix:semicolon
r_int
r_int
r_int
id|now
suffix:semicolon
r_int
id|expires
suffix:semicolon
id|dasd_era_t
id|era
suffix:semicolon
r_char
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|irb
)paren
)paren
(brace
r_switch
c_cond
(paren
id|PTR_ERR
c_func
(paren
id|irb
)paren
)paren
(brace
r_case
op_minus
id|EIO
suffix:colon
id|dasd_handle_killed_request
c_func
(paren
id|cdev
comma
id|intparm
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|ETIMEDOUT
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s(%s): request timed out&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|cdev-&gt;dev.bus_id
)paren
suffix:semicolon
singleline_comment|//FIXME - dasd uses own timeout interface...
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s(%s): unknown error %ld&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|cdev-&gt;dev.bus_id
comma
id|PTR_ERR
c_func
(paren
id|irb
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|now
op_assign
id|get_clock
c_func
(paren
)paren
suffix:semicolon
id|DBF_EVENT
c_func
(paren
id|DBF_ERR
comma
l_string|&quot;Interrupt: bus_id %s CS/DS %04x ip %08x&quot;
comma
id|cdev-&gt;dev.bus_id
comma
(paren
(paren
id|irb-&gt;scsw.cstat
op_lshift
l_int|8
)paren
op_or
id|irb-&gt;scsw.dstat
)paren
comma
(paren
r_int
r_int
)paren
id|intparm
)paren
suffix:semicolon
multiline_comment|/* first of all check for state change pending interrupt */
id|mask
op_assign
id|DEV_STAT_ATTENTION
op_or
id|DEV_STAT_DEV_END
op_or
id|DEV_STAT_UNIT_EXCEP
suffix:semicolon
r_if
c_cond
(paren
(paren
id|irb-&gt;scsw.dstat
op_amp
id|mask
)paren
op_eq
id|mask
)paren
(brace
id|device
op_assign
id|dasd_device_from_cdev
c_func
(paren
id|cdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|device
)paren
)paren
(brace
id|dasd_handle_state_change_pending
c_func
(paren
id|device
)paren
suffix:semicolon
id|dasd_put_device
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|cqr
op_assign
(paren
r_struct
id|dasd_ccw_req
op_star
)paren
id|intparm
suffix:semicolon
multiline_comment|/* check for unsolicited interrupts */
r_if
c_cond
(paren
id|cqr
op_eq
l_int|NULL
)paren
(brace
id|MESSAGE
c_func
(paren
id|KERN_DEBUG
comma
l_string|&quot;unsolicited interrupt received: bus_id %s&quot;
comma
id|cdev-&gt;dev.bus_id
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|device
op_assign
(paren
r_struct
id|dasd_device
op_star
)paren
id|cqr-&gt;device
suffix:semicolon
r_if
c_cond
(paren
id|device
op_eq
l_int|NULL
op_logical_or
id|strncmp
c_func
(paren
id|device-&gt;discipline-&gt;ebcname
comma
(paren
r_char
op_star
)paren
op_amp
id|cqr-&gt;magic
comma
l_int|4
)paren
)paren
(brace
id|MESSAGE
c_func
(paren
id|KERN_DEBUG
comma
l_string|&quot;invalid device in request: bus_id %s&quot;
comma
id|cdev-&gt;dev.bus_id
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Check for clear pending */
r_if
c_cond
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_CLEAR
op_logical_and
id|irb-&gt;scsw.fctl
op_amp
id|SCSW_FCTL_CLEAR_FUNC
)paren
(brace
id|cqr-&gt;status
op_assign
id|DASD_CQR_QUEUED
suffix:semicolon
id|dasd_clear_timer
c_func
(paren
id|device
)paren
suffix:semicolon
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* check status - the request might have been killed by dyn detach */
r_if
c_cond
(paren
id|cqr-&gt;status
op_ne
id|DASD_CQR_IN_IO
)paren
(brace
id|MESSAGE
c_func
(paren
id|KERN_DEBUG
comma
l_string|&quot;invalid status: bus_id %s, status %02x&quot;
comma
id|cdev-&gt;dev.bus_id
comma
id|cqr-&gt;status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_DEBUG
comma
id|device
comma
l_string|&quot;Int: CS/DS 0x%04x for cqr %p&quot;
comma
(paren
(paren
id|irb-&gt;scsw.cstat
op_lshift
l_int|8
)paren
op_or
id|irb-&gt;scsw.dstat
)paren
comma
id|cqr
)paren
suffix:semicolon
multiline_comment|/* Find out the appropriate era_action. */
r_if
c_cond
(paren
id|irb-&gt;scsw.fctl
op_amp
id|SCSW_FCTL_HALT_FUNC
)paren
id|era
op_assign
id|dasd_era_fatal
suffix:semicolon
r_else
r_if
c_cond
(paren
id|irb-&gt;scsw.dstat
op_eq
(paren
id|DEV_STAT_CHN_END
op_or
id|DEV_STAT_DEV_END
)paren
op_logical_and
id|irb-&gt;scsw.cstat
op_eq
l_int|0
op_logical_and
op_logical_neg
id|irb-&gt;esw.esw0.erw.cons
)paren
id|era
op_assign
id|dasd_era_none
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|DASD_CQR_FLAGS_USE_ERP
comma
op_amp
id|cqr-&gt;flags
)paren
)paren
id|era
op_assign
id|dasd_era_fatal
suffix:semicolon
multiline_comment|/* don&squot;t recover this request */
r_else
r_if
c_cond
(paren
id|irb-&gt;esw.esw0.erw.cons
)paren
id|era
op_assign
id|device-&gt;discipline
op_member_access_from_pointer
id|examine_error
c_func
(paren
id|cqr
comma
id|irb
)paren
suffix:semicolon
r_else
id|era
op_assign
id|dasd_era_recover
suffix:semicolon
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_DEBUG
comma
id|device
comma
l_string|&quot;era_code %d&quot;
comma
id|era
)paren
suffix:semicolon
id|expires
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|era
op_eq
id|dasd_era_none
)paren
(brace
id|cqr-&gt;status
op_assign
id|DASD_CQR_DONE
suffix:semicolon
id|cqr-&gt;stopclk
op_assign
id|now
suffix:semicolon
multiline_comment|/* Start first request on queue if possible -&gt; fast_io. */
r_if
c_cond
(paren
id|cqr-&gt;list.next
op_ne
op_amp
id|device-&gt;ccw_queue
)paren
(brace
id|next
op_assign
id|list_entry
c_func
(paren
id|cqr-&gt;list.next
comma
r_struct
id|dasd_ccw_req
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|next-&gt;status
op_eq
id|DASD_CQR_QUEUED
)paren
op_logical_and
(paren
op_logical_neg
id|device-&gt;stopped
)paren
)paren
(brace
r_if
c_cond
(paren
id|device-&gt;discipline
op_member_access_from_pointer
id|start_IO
c_func
(paren
id|next
)paren
op_eq
l_int|0
)paren
id|expires
op_assign
id|next-&gt;expires
suffix:semicolon
r_else
id|DEV_MESSAGE
c_func
(paren
id|KERN_DEBUG
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;Interrupt fastpath &quot;
l_string|&quot;failed!&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* error */
id|memcpy
c_func
(paren
op_amp
id|cqr-&gt;irb
comma
id|irb
comma
r_sizeof
(paren
r_struct
id|irb
)paren
)paren
suffix:semicolon
macro_line|#ifdef ERP_DEBUG
multiline_comment|/* dump sense data */
id|dasd_log_sense
c_func
(paren
id|cqr
comma
id|irb
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|era
)paren
(brace
r_case
id|dasd_era_fatal
suffix:colon
id|cqr-&gt;status
op_assign
id|DASD_CQR_FAILED
suffix:semicolon
id|cqr-&gt;stopclk
op_assign
id|now
suffix:semicolon
r_break
suffix:semicolon
r_case
id|dasd_era_recover
suffix:colon
id|cqr-&gt;status
op_assign
id|DASD_CQR_ERROR
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|expires
op_ne
l_int|0
)paren
id|dasd_set_timer
c_func
(paren
id|device
comma
id|expires
)paren
suffix:semicolon
r_else
id|dasd_clear_timer
c_func
(paren
id|device
)paren
suffix:semicolon
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * posts the buffer_cache about a finalized request&n; */
r_static
r_inline
r_void
DECL|function|dasd_end_request
id|dasd_end_request
c_func
(paren
r_struct
id|request
op_star
id|req
comma
r_int
id|uptodate
)paren
(brace
r_if
c_cond
(paren
id|end_that_request_first
c_func
(paren
id|req
comma
id|uptodate
comma
id|req-&gt;hard_nr_sectors
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|add_disk_randomness
c_func
(paren
id|req-&gt;rq_disk
)paren
suffix:semicolon
id|end_that_request_last
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Process finished error recovery ccw.&n; */
r_static
r_inline
r_void
DECL|function|__dasd_process_erp
id|__dasd_process_erp
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
comma
r_struct
id|dasd_ccw_req
op_star
id|cqr
)paren
(brace
id|dasd_erp_fn_t
id|erp_fn
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_DONE
)paren
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_NOTICE
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;ERP successful&quot;
)paren
suffix:semicolon
r_else
id|DEV_MESSAGE
c_func
(paren
id|KERN_ERR
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;ERP unsuccessful&quot;
)paren
suffix:semicolon
id|erp_fn
op_assign
id|device-&gt;discipline
op_member_access_from_pointer
id|erp_postaction
c_func
(paren
id|cqr
)paren
suffix:semicolon
id|erp_fn
c_func
(paren
id|cqr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Process ccw request queue.&n; */
r_static
r_inline
r_void
DECL|function|__dasd_process_ccw_queue
id|__dasd_process_ccw_queue
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
comma
r_struct
id|list_head
op_star
id|final_queue
)paren
(brace
r_struct
id|list_head
op_star
id|l
comma
op_star
id|n
suffix:semicolon
r_struct
id|dasd_ccw_req
op_star
id|cqr
suffix:semicolon
id|dasd_erp_fn_t
id|erp_fn
suffix:semicolon
id|restart
suffix:colon
multiline_comment|/* Process request with final status. */
id|list_for_each_safe
c_func
(paren
id|l
comma
id|n
comma
op_amp
id|device-&gt;ccw_queue
)paren
(brace
id|cqr
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|dasd_ccw_req
comma
id|list
)paren
suffix:semicolon
multiline_comment|/* Stop list processing at the first non-final request. */
r_if
c_cond
(paren
id|cqr-&gt;status
op_ne
id|DASD_CQR_DONE
op_logical_and
id|cqr-&gt;status
op_ne
id|DASD_CQR_FAILED
op_logical_and
id|cqr-&gt;status
op_ne
id|DASD_CQR_ERROR
)paren
r_break
suffix:semicolon
multiline_comment|/*  Process requests with DASD_CQR_ERROR */
r_if
c_cond
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_ERROR
)paren
(brace
r_if
c_cond
(paren
id|cqr-&gt;irb.scsw.fctl
op_amp
id|SCSW_FCTL_HALT_FUNC
)paren
(brace
id|cqr-&gt;status
op_assign
id|DASD_CQR_FAILED
suffix:semicolon
id|cqr-&gt;stopclk
op_assign
id|get_clock
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|cqr-&gt;irb.esw.esw0.erw.cons
)paren
(brace
id|erp_fn
op_assign
id|device-&gt;discipline
op_member_access_from_pointer
id|erp_action
c_func
(paren
id|cqr
)paren
suffix:semicolon
id|erp_fn
c_func
(paren
id|cqr
)paren
suffix:semicolon
)brace
r_else
id|dasd_default_erp_action
c_func
(paren
id|cqr
)paren
suffix:semicolon
)brace
r_goto
id|restart
suffix:semicolon
)brace
multiline_comment|/* Process finished ERP request. */
r_if
c_cond
(paren
id|cqr-&gt;refers
)paren
(brace
id|__dasd_process_erp
c_func
(paren
id|device
comma
id|cqr
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
multiline_comment|/* Rechain finished requests to final queue */
id|cqr-&gt;endclk
op_assign
id|get_clock
c_func
(paren
)paren
suffix:semicolon
id|list_move_tail
c_func
(paren
op_amp
id|cqr-&gt;list
comma
id|final_queue
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|dasd_end_request_cb
id|dasd_end_request_cb
c_func
(paren
r_struct
id|dasd_ccw_req
op_star
id|cqr
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|request
op_star
id|req
suffix:semicolon
r_struct
id|dasd_device
op_star
id|device
suffix:semicolon
r_int
id|status
suffix:semicolon
id|req
op_assign
(paren
r_struct
id|request
op_star
)paren
id|data
suffix:semicolon
id|device
op_assign
id|cqr-&gt;device
suffix:semicolon
id|dasd_profile_end
c_func
(paren
id|device
comma
id|cqr
comma
id|req
)paren
suffix:semicolon
id|status
op_assign
id|cqr-&gt;device-&gt;discipline
op_member_access_from_pointer
id|free_cp
c_func
(paren
id|cqr
comma
id|req
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|device-&gt;request_queue_lock
)paren
suffix:semicolon
id|dasd_end_request
c_func
(paren
id|req
comma
id|status
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|device-&gt;request_queue_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Fetch requests from the block device queue.&n; */
r_static
r_inline
r_void
DECL|function|__dasd_process_blk_queue
id|__dasd_process_blk_queue
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
id|request_queue_t
op_star
id|queue
suffix:semicolon
r_struct
id|request
op_star
id|req
suffix:semicolon
r_struct
id|dasd_ccw_req
op_star
id|cqr
suffix:semicolon
r_int
id|nr_queued
suffix:semicolon
id|queue
op_assign
id|device-&gt;request_queue
suffix:semicolon
multiline_comment|/* No queue ? Then there is nothing to do. */
r_if
c_cond
(paren
id|queue
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * We requeue request from the block device queue to the ccw&n;&t; * queue only in two states. In state DASD_STATE_READY the&n;&t; * partition detection is done and we need to requeue requests&n;&t; * for that. State DASD_STATE_ONLINE is normal block device&n;&t; * operation.&n;&t; */
r_if
c_cond
(paren
id|device-&gt;state
op_ne
id|DASD_STATE_READY
op_logical_and
id|device-&gt;state
op_ne
id|DASD_STATE_ONLINE
)paren
r_return
suffix:semicolon
id|nr_queued
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Now we try to fetch requests from the request queue */
id|list_for_each_entry
c_func
(paren
id|cqr
comma
op_amp
id|device-&gt;ccw_queue
comma
id|list
)paren
r_if
c_cond
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_QUEUED
)paren
id|nr_queued
op_increment
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|blk_queue_plugged
c_func
(paren
id|queue
)paren
op_logical_and
id|elv_next_request
c_func
(paren
id|queue
)paren
op_logical_and
id|nr_queued
OL
id|DASD_CHANQ_MAX_SIZE
)paren
(brace
id|req
op_assign
id|elv_next_request
c_func
(paren
id|queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|DASD_FLAG_RO
comma
op_amp
id|device-&gt;flags
)paren
op_logical_and
id|rq_data_dir
c_func
(paren
id|req
)paren
op_eq
id|WRITE
)paren
(brace
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_ERR
comma
id|device
comma
l_string|&quot;Rejecting write request %p&quot;
comma
id|req
)paren
suffix:semicolon
id|blkdev_dequeue_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|dasd_end_request
c_func
(paren
id|req
comma
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|device-&gt;stopped
op_amp
id|DASD_STOPPED_DC_EIO
)paren
(brace
id|blkdev_dequeue_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|dasd_end_request
c_func
(paren
id|req
comma
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|cqr
op_assign
id|device-&gt;discipline
op_member_access_from_pointer
id|build_cp
c_func
(paren
id|device
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|cqr
)paren
)paren
(brace
r_if
c_cond
(paren
id|PTR_ERR
c_func
(paren
id|cqr
)paren
op_eq
op_minus
id|ENOMEM
)paren
r_break
suffix:semicolon
multiline_comment|/* terminate request queue loop */
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_ERR
comma
id|device
comma
l_string|&quot;CCW creation failed (rc=%ld) &quot;
l_string|&quot;on request %p&quot;
comma
id|PTR_ERR
c_func
(paren
id|cqr
)paren
comma
id|req
)paren
suffix:semicolon
id|blkdev_dequeue_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|dasd_end_request
c_func
(paren
id|req
comma
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|cqr-&gt;callback
op_assign
id|dasd_end_request_cb
suffix:semicolon
id|cqr-&gt;callback_data
op_assign
(paren
r_void
op_star
)paren
id|req
suffix:semicolon
id|cqr-&gt;status
op_assign
id|DASD_CQR_QUEUED
suffix:semicolon
id|blkdev_dequeue_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|cqr-&gt;list
comma
op_amp
id|device-&gt;ccw_queue
)paren
suffix:semicolon
id|dasd_profile_start
c_func
(paren
id|device
comma
id|cqr
comma
id|req
)paren
suffix:semicolon
id|nr_queued
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Take a look at the first request on the ccw queue and check&n; * if it reached its expire time. If so, terminate the IO.&n; */
r_static
r_inline
r_void
DECL|function|__dasd_check_expire
id|__dasd_check_expire
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
r_struct
id|dasd_ccw_req
op_star
id|cqr
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|device-&gt;ccw_queue
)paren
)paren
r_return
suffix:semicolon
id|cqr
op_assign
id|list_entry
c_func
(paren
id|device-&gt;ccw_queue.next
comma
r_struct
id|dasd_ccw_req
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_IN_IO
op_logical_and
id|cqr-&gt;expires
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|cqr-&gt;expires
op_plus
id|cqr-&gt;starttime
)paren
)paren
(brace
r_if
c_cond
(paren
id|device-&gt;discipline
op_member_access_from_pointer
id|term_IO
c_func
(paren
id|cqr
)paren
op_ne
l_int|0
)paren
multiline_comment|/* Hmpf, try again in 1/10 sec */
id|dasd_set_timer
c_func
(paren
id|device
comma
l_int|10
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Take a look at the first request on the ccw queue and check&n; * if it needs to be started.&n; */
r_static
r_inline
r_void
DECL|function|__dasd_start_head
id|__dasd_start_head
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
r_struct
id|dasd_ccw_req
op_star
id|cqr
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|device-&gt;ccw_queue
)paren
)paren
r_return
suffix:semicolon
id|cqr
op_assign
id|list_entry
c_func
(paren
id|device-&gt;ccw_queue.next
comma
r_struct
id|dasd_ccw_req
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_QUEUED
)paren
op_logical_and
(paren
op_logical_neg
id|device-&gt;stopped
)paren
)paren
(brace
multiline_comment|/* try to start the first I/O that can be started */
id|rc
op_assign
id|device-&gt;discipline
op_member_access_from_pointer
id|start_IO
c_func
(paren
id|cqr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
id|dasd_set_timer
c_func
(paren
id|device
comma
id|cqr-&gt;expires
)paren
suffix:semicolon
r_else
multiline_comment|/* Hmpf, try again in 1/2 sec */
id|dasd_set_timer
c_func
(paren
id|device
comma
l_int|50
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Remove requests from the ccw queue. &n; */
r_static
r_void
DECL|function|dasd_flush_ccw_queue
id|dasd_flush_ccw_queue
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
comma
r_int
id|all
)paren
(brace
r_struct
id|list_head
id|flush_queue
suffix:semicolon
r_struct
id|list_head
op_star
id|l
comma
op_star
id|n
suffix:semicolon
r_struct
id|dasd_ccw_req
op_star
id|cqr
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|flush_queue
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|l
comma
id|n
comma
op_amp
id|device-&gt;ccw_queue
)paren
(brace
id|cqr
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|dasd_ccw_req
comma
id|list
)paren
suffix:semicolon
multiline_comment|/* Flush all request or only block device requests? */
r_if
c_cond
(paren
id|all
op_eq
l_int|0
op_logical_and
id|cqr-&gt;callback
op_eq
id|dasd_end_request_cb
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_IN_IO
)paren
id|device-&gt;discipline
op_member_access_from_pointer
id|term_IO
c_func
(paren
id|cqr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;status
op_ne
id|DASD_CQR_DONE
op_logical_or
id|cqr-&gt;status
op_ne
id|DASD_CQR_FAILED
)paren
(brace
id|cqr-&gt;status
op_assign
id|DASD_CQR_FAILED
suffix:semicolon
id|cqr-&gt;stopclk
op_assign
id|get_clock
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Process finished ERP request. */
r_if
c_cond
(paren
id|cqr-&gt;refers
)paren
(brace
id|__dasd_process_erp
c_func
(paren
id|device
comma
id|cqr
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Rechain request on device request queue */
id|cqr-&gt;endclk
op_assign
id|get_clock
c_func
(paren
)paren
suffix:semicolon
id|list_move_tail
c_func
(paren
op_amp
id|cqr-&gt;list
comma
op_amp
id|flush_queue
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
)paren
suffix:semicolon
multiline_comment|/* Now call the callback function of flushed requests */
id|list_for_each_safe
c_func
(paren
id|l
comma
id|n
comma
op_amp
id|flush_queue
)paren
(brace
id|cqr
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|dasd_ccw_req
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;callback
op_ne
l_int|NULL
)paren
(paren
id|cqr-&gt;callback
)paren
(paren
id|cqr
comma
id|cqr-&gt;callback_data
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Acquire the device lock and process queues for the device.&n; */
r_static
r_void
DECL|function|dasd_tasklet
id|dasd_tasklet
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
r_struct
id|list_head
id|final_queue
suffix:semicolon
r_struct
id|list_head
op_star
id|l
comma
op_star
id|n
suffix:semicolon
r_struct
id|dasd_ccw_req
op_star
id|cqr
suffix:semicolon
id|atomic_set
(paren
op_amp
id|device-&gt;tasklet_scheduled
comma
l_int|0
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|final_queue
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
)paren
suffix:semicolon
multiline_comment|/* Check expire time of first request on the ccw queue. */
id|__dasd_check_expire
c_func
(paren
id|device
)paren
suffix:semicolon
multiline_comment|/* Finish off requests on ccw queue */
id|__dasd_process_ccw_queue
c_func
(paren
id|device
comma
op_amp
id|final_queue
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
)paren
suffix:semicolon
multiline_comment|/* Now call the callback function of requests with final status */
id|list_for_each_safe
c_func
(paren
id|l
comma
id|n
comma
op_amp
id|final_queue
)paren
(brace
id|cqr
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|dasd_ccw_req
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|cqr-&gt;list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;callback
op_ne
l_int|NULL
)paren
(paren
id|cqr-&gt;callback
)paren
(paren
id|cqr
comma
id|cqr-&gt;callback_data
)paren
suffix:semicolon
)brace
id|spin_lock_irq
c_func
(paren
op_amp
id|device-&gt;request_queue_lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
)paren
suffix:semicolon
multiline_comment|/* Get new request from the block device request queue */
id|__dasd_process_blk_queue
c_func
(paren
id|device
)paren
suffix:semicolon
multiline_comment|/* Now check if the head of the ccw queue needs to be started. */
id|__dasd_start_head
c_func
(paren
id|device
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|device-&gt;request_queue_lock
)paren
suffix:semicolon
id|dasd_put_device
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Schedules a call to dasd_tasklet over the device tasklet.&n; */
r_void
DECL|function|dasd_schedule_bh
id|dasd_schedule_bh
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
multiline_comment|/* Protect against rescheduling. */
r_if
c_cond
(paren
id|atomic_compare_and_swap
(paren
l_int|0
comma
l_int|1
comma
op_amp
id|device-&gt;tasklet_scheduled
)paren
)paren
r_return
suffix:semicolon
id|dasd_get_device
c_func
(paren
id|device
)paren
suffix:semicolon
id|tasklet_hi_schedule
c_func
(paren
op_amp
id|device-&gt;tasklet
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Queue a request to the head of the ccw_queue. Start the I/O if&n; * possible.&n; */
r_void
DECL|function|dasd_add_request_head
id|dasd_add_request_head
c_func
(paren
r_struct
id|dasd_ccw_req
op_star
id|req
)paren
(brace
r_struct
id|dasd_device
op_star
id|device
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|device
op_assign
id|req-&gt;device
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
comma
id|flags
)paren
suffix:semicolon
id|req-&gt;status
op_assign
id|DASD_CQR_QUEUED
suffix:semicolon
id|req-&gt;device
op_assign
id|device
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|req-&gt;list
comma
op_amp
id|device-&gt;ccw_queue
)paren
suffix:semicolon
multiline_comment|/* let the bh start the request to keep them in order */
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Queue a request to the tail of the ccw_queue. Start the I/O if&n; * possible.&n; */
r_void
DECL|function|dasd_add_request_tail
id|dasd_add_request_tail
c_func
(paren
r_struct
id|dasd_ccw_req
op_star
id|req
)paren
(brace
r_struct
id|dasd_device
op_star
id|device
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|device
op_assign
id|req-&gt;device
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
comma
id|flags
)paren
suffix:semicolon
id|req-&gt;status
op_assign
id|DASD_CQR_QUEUED
suffix:semicolon
id|req-&gt;device
op_assign
id|device
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|req-&gt;list
comma
op_amp
id|device-&gt;ccw_queue
)paren
suffix:semicolon
multiline_comment|/* let the bh start the request to keep them in order */
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wakeup callback.&n; */
r_static
r_void
DECL|function|dasd_wakeup_cb
id|dasd_wakeup_cb
c_func
(paren
r_struct
id|dasd_ccw_req
op_star
id|cqr
comma
r_void
op_star
id|data
)paren
(brace
id|wake_up
c_func
(paren
(paren
id|wait_queue_head_t
op_star
)paren
id|data
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|_wait_for_wakeup
id|_wait_for_wakeup
c_func
(paren
r_struct
id|dasd_ccw_req
op_star
id|cqr
)paren
(brace
r_struct
id|dasd_device
op_star
id|device
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|device
op_assign
id|cqr-&gt;device
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
)paren
suffix:semicolon
id|rc
op_assign
id|cqr-&gt;status
op_eq
id|DASD_CQR_DONE
op_logical_or
id|cqr-&gt;status
op_eq
id|DASD_CQR_FAILED
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Attempts to start a special ccw queue and waits for its completion.&n; */
r_int
DECL|function|dasd_sleep_on
id|dasd_sleep_on
c_func
(paren
r_struct
id|dasd_ccw_req
op_star
id|cqr
)paren
(brace
id|wait_queue_head_t
id|wait_q
suffix:semicolon
r_struct
id|dasd_device
op_star
id|device
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|device
op_assign
id|cqr-&gt;device
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
)paren
suffix:semicolon
id|init_waitqueue_head
(paren
op_amp
id|wait_q
)paren
suffix:semicolon
id|cqr-&gt;callback
op_assign
id|dasd_wakeup_cb
suffix:semicolon
id|cqr-&gt;callback_data
op_assign
(paren
r_void
op_star
)paren
op_amp
id|wait_q
suffix:semicolon
id|cqr-&gt;status
op_assign
id|DASD_CQR_QUEUED
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|cqr-&gt;list
comma
op_amp
id|device-&gt;ccw_queue
)paren
suffix:semicolon
multiline_comment|/* let the bh start the request to keep them in order */
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
)paren
suffix:semicolon
id|wait_event
c_func
(paren
id|wait_q
comma
id|_wait_for_wakeup
c_func
(paren
id|cqr
)paren
)paren
suffix:semicolon
multiline_comment|/* Request status is either done or failed. */
id|rc
op_assign
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_FAILED
)paren
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Attempts to start a special ccw queue and wait interruptible&n; * for its completion.&n; */
r_int
DECL|function|dasd_sleep_on_interruptible
id|dasd_sleep_on_interruptible
c_func
(paren
r_struct
id|dasd_ccw_req
op_star
id|cqr
)paren
(brace
id|wait_queue_head_t
id|wait_q
suffix:semicolon
r_struct
id|dasd_device
op_star
id|device
suffix:semicolon
r_int
id|rc
comma
id|finished
suffix:semicolon
id|device
op_assign
id|cqr-&gt;device
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
)paren
suffix:semicolon
id|init_waitqueue_head
(paren
op_amp
id|wait_q
)paren
suffix:semicolon
id|cqr-&gt;callback
op_assign
id|dasd_wakeup_cb
suffix:semicolon
id|cqr-&gt;callback_data
op_assign
(paren
r_void
op_star
)paren
op_amp
id|wait_q
suffix:semicolon
id|cqr-&gt;status
op_assign
id|DASD_CQR_QUEUED
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|cqr-&gt;list
comma
op_amp
id|device-&gt;ccw_queue
)paren
suffix:semicolon
multiline_comment|/* let the bh start the request to keep them in order */
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
)paren
suffix:semicolon
id|finished
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|finished
)paren
(brace
id|rc
op_assign
id|wait_event_interruptible
c_func
(paren
id|wait_q
comma
id|_wait_for_wakeup
c_func
(paren
id|cqr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
op_minus
id|ERESTARTSYS
)paren
(brace
multiline_comment|/* Request status is either done or failed. */
id|rc
op_assign
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_FAILED
)paren
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_lock_irq
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_IN_IO
op_logical_and
id|device-&gt;discipline
op_member_access_from_pointer
id|term_IO
c_func
(paren
id|cqr
)paren
op_eq
l_int|0
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|cqr-&gt;list
)paren
suffix:semicolon
id|finished
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Whoa nelly now it gets really hairy. For some functions (e.g. steal lock&n; * for eckd devices) the currently running request has to be terminated&n; * and be put back to status queued, before the special request is added&n; * to the head of the queue. Then the special request is waited on normally.&n; */
r_static
r_inline
r_int
DECL|function|_dasd_term_running_cqr
id|_dasd_term_running_cqr
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
r_struct
id|dasd_ccw_req
op_star
id|cqr
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|device-&gt;ccw_queue
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|cqr
op_assign
id|list_entry
c_func
(paren
id|device-&gt;ccw_queue.next
comma
r_struct
id|dasd_ccw_req
comma
id|list
)paren
suffix:semicolon
id|rc
op_assign
id|device-&gt;discipline
op_member_access_from_pointer
id|term_IO
c_func
(paren
id|cqr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
multiline_comment|/* termination successful */
id|cqr-&gt;status
op_assign
id|DASD_CQR_QUEUED
suffix:semicolon
id|cqr-&gt;startclk
op_assign
id|cqr-&gt;stopclk
op_assign
l_int|0
suffix:semicolon
id|cqr-&gt;starttime
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
r_int
DECL|function|dasd_sleep_on_immediatly
id|dasd_sleep_on_immediatly
c_func
(paren
r_struct
id|dasd_ccw_req
op_star
id|cqr
)paren
(brace
id|wait_queue_head_t
id|wait_q
suffix:semicolon
r_struct
id|dasd_device
op_star
id|device
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|device
op_assign
id|cqr-&gt;device
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
)paren
suffix:semicolon
id|rc
op_assign
id|_dasd_term_running_cqr
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|spin_unlock_irq
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|init_waitqueue_head
(paren
op_amp
id|wait_q
)paren
suffix:semicolon
id|cqr-&gt;callback
op_assign
id|dasd_wakeup_cb
suffix:semicolon
id|cqr-&gt;callback_data
op_assign
(paren
r_void
op_star
)paren
op_amp
id|wait_q
suffix:semicolon
id|cqr-&gt;status
op_assign
id|DASD_CQR_QUEUED
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|cqr-&gt;list
comma
op_amp
id|device-&gt;ccw_queue
)paren
suffix:semicolon
multiline_comment|/* let the bh start the request to keep them in order */
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
)paren
suffix:semicolon
id|wait_event
c_func
(paren
id|wait_q
comma
id|_wait_for_wakeup
c_func
(paren
id|cqr
)paren
)paren
suffix:semicolon
multiline_comment|/* Request status is either done or failed. */
id|rc
op_assign
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_FAILED
)paren
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Cancels a request that was started with dasd_sleep_on_req.&n; * This is useful to timeout requests. The request will be&n; * terminated if it is currently in i/o.&n; * Returns 1 if the request has been terminated.&n; */
r_int
DECL|function|dasd_cancel_req
id|dasd_cancel_req
c_func
(paren
r_struct
id|dasd_ccw_req
op_star
id|cqr
)paren
(brace
r_struct
id|dasd_device
op_star
id|device
op_assign
id|cqr-&gt;device
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
comma
id|flags
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cqr-&gt;status
)paren
(brace
r_case
id|DASD_CQR_QUEUED
suffix:colon
multiline_comment|/* request was not started - just set to failed */
id|cqr-&gt;status
op_assign
id|DASD_CQR_FAILED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DASD_CQR_IN_IO
suffix:colon
multiline_comment|/* request in IO - terminate IO and release again */
r_if
c_cond
(paren
id|device-&gt;discipline
op_member_access_from_pointer
id|term_IO
c_func
(paren
id|cqr
)paren
op_ne
l_int|0
)paren
multiline_comment|/* what to do if unable to terminate ??????&n;&t;&t;&t;   e.g. not _IN_IO */
id|cqr-&gt;status
op_assign
id|DASD_CQR_FAILED
suffix:semicolon
id|cqr-&gt;stopclk
op_assign
id|get_clock
c_func
(paren
)paren
suffix:semicolon
id|rc
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DASD_CQR_DONE
suffix:colon
r_case
id|DASD_CQR_FAILED
suffix:colon
multiline_comment|/* already finished - do nothing */
r_break
suffix:semicolon
r_default
suffix:colon
id|DEV_MESSAGE
c_func
(paren
id|KERN_ALERT
comma
id|device
comma
l_string|&quot;invalid status %02x in request&quot;
comma
id|cqr-&gt;status
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
comma
id|flags
)paren
suffix:semicolon
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * SECTION: Block device operations (request queue, partitions, open, release).&n; */
multiline_comment|/*&n; * Dasd request queue function. Called from ll_rw_blk.c&n; */
r_static
r_void
DECL|function|do_dasd_request
id|do_dasd_request
c_func
(paren
id|request_queue_t
op_star
id|queue
)paren
(brace
r_struct
id|dasd_device
op_star
id|device
suffix:semicolon
id|device
op_assign
(paren
r_struct
id|dasd_device
op_star
)paren
id|queue-&gt;queuedata
suffix:semicolon
id|spin_lock
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
)paren
suffix:semicolon
multiline_comment|/* Get new request from the block device request queue */
id|__dasd_process_blk_queue
c_func
(paren
id|device
)paren
suffix:semicolon
multiline_comment|/* Now check if the head of the ccw queue needs to be started. */
id|__dasd_start_head
c_func
(paren
id|device
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|device-&gt;cdev
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate and initialize request queue.&n; */
r_static
r_int
DECL|function|dasd_alloc_queue
id|dasd_alloc_queue
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
id|device-&gt;request_queue
op_assign
id|blk_init_queue
c_func
(paren
id|do_dasd_request
comma
op_amp
id|device-&gt;request_queue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;request_queue
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|device-&gt;request_queue-&gt;queuedata
op_assign
id|device
suffix:semicolon
macro_line|#if 0
id|elevator_exit
c_func
(paren
id|device-&gt;request_queue-&gt;elevator
)paren
suffix:semicolon
id|rc
op_assign
id|elevator_init
c_func
(paren
id|device-&gt;request_queue
comma
l_string|&quot;noop&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|blk_cleanup_queue
c_func
(paren
id|device-&gt;request_queue
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate and initialize request queue.&n; */
r_static
r_void
DECL|function|dasd_setup_queue
id|dasd_setup_queue
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
r_int
id|max
suffix:semicolon
id|blk_queue_hardsect_size
c_func
(paren
id|device-&gt;request_queue
comma
id|device-&gt;bp_block
)paren
suffix:semicolon
id|max
op_assign
id|device-&gt;discipline-&gt;max_blocks
op_lshift
id|device-&gt;s2b_shift
suffix:semicolon
id|blk_queue_max_sectors
c_func
(paren
id|device-&gt;request_queue
comma
id|max
)paren
suffix:semicolon
id|blk_queue_max_phys_segments
c_func
(paren
id|device-&gt;request_queue
comma
op_minus
l_int|1L
)paren
suffix:semicolon
id|blk_queue_max_hw_segments
c_func
(paren
id|device-&gt;request_queue
comma
op_minus
l_int|1L
)paren
suffix:semicolon
id|blk_queue_max_segment_size
c_func
(paren
id|device-&gt;request_queue
comma
op_minus
l_int|1L
)paren
suffix:semicolon
id|blk_queue_segment_boundary
c_func
(paren
id|device-&gt;request_queue
comma
op_minus
l_int|1L
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Deactivate and free request queue.&n; */
r_static
r_void
DECL|function|dasd_free_queue
id|dasd_free_queue
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
r_if
c_cond
(paren
id|device-&gt;request_queue
)paren
(brace
id|blk_cleanup_queue
c_func
(paren
id|device-&gt;request_queue
)paren
suffix:semicolon
id|device-&gt;request_queue
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Flush request on the request queue.&n; */
r_static
r_void
DECL|function|dasd_flush_request_queue
id|dasd_flush_request_queue
c_func
(paren
r_struct
id|dasd_device
op_star
id|device
)paren
(brace
r_struct
id|request
op_star
id|req
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device-&gt;request_queue
)paren
r_return
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|device-&gt;request_queue_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|device-&gt;request_queue-&gt;queue_head
)paren
)paren
(brace
id|req
op_assign
id|elv_next_request
c_func
(paren
id|device-&gt;request_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|dasd_end_request
c_func
(paren
id|req
comma
l_int|0
)paren
suffix:semicolon
id|blkdev_dequeue_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|device-&gt;request_queue_lock
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|dasd_open
id|dasd_open
c_func
(paren
r_struct
id|inode
op_star
id|inp
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|inp-&gt;i_bdev-&gt;bd_disk
suffix:semicolon
r_struct
id|dasd_device
op_star
id|device
op_assign
id|disk-&gt;private_data
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|device-&gt;open_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|DASD_FLAG_OFFLINE
comma
op_amp
id|device-&gt;flags
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|try_module_get
c_func
(paren
id|device-&gt;discipline-&gt;owner
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dasd_probeonly
)paren
(brace
id|DEV_MESSAGE
c_func
(paren
id|KERN_INFO
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;No access to device due to probeonly mode&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|device-&gt;state
OL
id|DASD_STATE_BASIC
)paren
(brace
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_ERR
comma
id|device
comma
l_string|&quot; %s&quot;
comma
l_string|&quot; Cannot open unrecognized device&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|out
suffix:colon
id|module_put
c_func
(paren
id|device-&gt;discipline-&gt;owner
)paren
suffix:semicolon
id|unlock
suffix:colon
id|atomic_dec
c_func
(paren
op_amp
id|device-&gt;open_count
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_static
r_int
DECL|function|dasd_release
id|dasd_release
c_func
(paren
r_struct
id|inode
op_star
id|inp
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|gendisk
op_star
id|disk
op_assign
id|inp-&gt;i_bdev-&gt;bd_disk
suffix:semicolon
r_struct
id|dasd_device
op_star
id|device
op_assign
id|disk-&gt;private_data
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|device-&gt;open_count
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|device-&gt;discipline-&gt;owner
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_struct
id|block_device_operations
DECL|variable|dasd_device_operations
id|dasd_device_operations
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|open
op_assign
id|dasd_open
comma
dot
id|release
op_assign
id|dasd_release
comma
dot
id|ioctl
op_assign
id|dasd_ioctl
comma
)brace
suffix:semicolon
r_static
r_void
DECL|function|dasd_exit
id|dasd_exit
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_PROC_FS
id|dasd_proc_exit
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|dasd_ioctl_exit
c_func
(paren
)paren
suffix:semicolon
id|dasd_gendisk_exit
c_func
(paren
)paren
suffix:semicolon
id|dasd_devmap_exit
c_func
(paren
)paren
suffix:semicolon
id|devfs_remove
c_func
(paren
l_string|&quot;dasd&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dasd_debug_area
op_ne
l_int|NULL
)paren
(brace
id|debug_unregister
c_func
(paren
id|dasd_debug_area
)paren
suffix:semicolon
id|dasd_debug_area
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * SECTION: common functions for ccw_driver use&n; */
multiline_comment|/* initial attempt at a probe function. this can be simplified once&n; * the other detection code is gone */
r_int
DECL|function|dasd_generic_probe
id|dasd_generic_probe
(paren
r_struct
id|ccw_device
op_star
id|cdev
comma
r_struct
id|dasd_discipline
op_star
id|discipline
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|dasd_add_sysfs_files
c_func
(paren
id|cdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;dasd_generic_probe: could not add sysfs entries &quot;
l_string|&quot;for %s&bslash;n&quot;
comma
id|cdev-&gt;dev.bus_id
)paren
suffix:semicolon
)brace
id|cdev-&gt;handler
op_assign
op_amp
id|dasd_int_handler
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* this will one day be called from a global not_oper handler.&n; * It is also used by driver_unregister during module unload */
r_void
DECL|function|dasd_generic_remove
id|dasd_generic_remove
(paren
r_struct
id|ccw_device
op_star
id|cdev
)paren
(brace
r_struct
id|dasd_device
op_star
id|device
suffix:semicolon
id|dasd_remove_sysfs_files
c_func
(paren
id|cdev
)paren
suffix:semicolon
id|device
op_assign
id|dasd_device_from_cdev
c_func
(paren
id|cdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|device
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|DASD_FLAG_OFFLINE
comma
op_amp
id|device-&gt;flags
)paren
)paren
(brace
multiline_comment|/* Already doing offline processing */
id|dasd_put_device
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This device is removed unconditionally. Set offline&n;&t; * flag to prevent dasd_open from opening it while it is&n;&t; * no quite down yet.&n;&t; */
id|dasd_set_target_state
c_func
(paren
id|device
comma
id|DASD_STATE_NEW
)paren
suffix:semicolon
multiline_comment|/* dasd_delete_device destroys the device reference. */
id|dasd_delete_device
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
multiline_comment|/* activate a device. This is called from dasd_{eckd,fba}_probe() when either&n; * the device is detected for the first time and is supposed to be used&n; * or the user has started activation through sysfs */
r_int
DECL|function|dasd_generic_set_online
id|dasd_generic_set_online
(paren
r_struct
id|ccw_device
op_star
id|cdev
comma
r_struct
id|dasd_discipline
op_star
id|discipline
)paren
(brace
r_struct
id|dasd_device
op_star
id|device
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|device
op_assign
id|dasd_create_device
c_func
(paren
id|cdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|device
)paren
)paren
r_return
id|PTR_ERR
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|DASD_FLAG_USE_DIAG
comma
op_amp
id|device-&gt;flags
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dasd_diag_discipline_pointer
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;dasd_generic couldn&squot;t online device %s &quot;
l_string|&quot;- discipline DIAG not available&bslash;n&quot;
comma
id|cdev-&gt;dev.bus_id
)paren
suffix:semicolon
id|dasd_delete_device
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|discipline
op_assign
id|dasd_diag_discipline_pointer
suffix:semicolon
)brace
id|device-&gt;discipline
op_assign
id|discipline
suffix:semicolon
id|rc
op_assign
id|discipline
op_member_access_from_pointer
id|check_device
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;dasd_generic couldn&squot;t online device %s &quot;
l_string|&quot;with discipline %s&bslash;n&quot;
comma
id|cdev-&gt;dev.bus_id
comma
id|discipline-&gt;name
)paren
suffix:semicolon
id|dasd_delete_device
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|dasd_set_target_state
c_func
(paren
id|device
comma
id|DASD_STATE_ONLINE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;state
op_le
id|DASD_STATE_KNOWN
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;dasd_generic discipline not found for %s&bslash;n&quot;
comma
id|cdev-&gt;dev.bus_id
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|dasd_set_target_state
c_func
(paren
id|device
comma
id|DASD_STATE_NEW
)paren
suffix:semicolon
id|dasd_delete_device
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
r_else
id|pr_debug
c_func
(paren
l_string|&quot;dasd_generic device %s found&bslash;n&quot;
comma
id|cdev-&gt;dev.bus_id
)paren
suffix:semicolon
multiline_comment|/* FIXME: we have to wait for the root device but we don&squot;t want&n;&t; * to wait for each single device but for all at once. */
id|wait_event
c_func
(paren
id|dasd_init_waitq
comma
id|_wait_for_device
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
id|dasd_put_device
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_int
DECL|function|dasd_generic_set_offline
id|dasd_generic_set_offline
(paren
r_struct
id|ccw_device
op_star
id|cdev
)paren
(brace
r_struct
id|dasd_device
op_star
id|device
suffix:semicolon
r_int
id|max_count
suffix:semicolon
id|device
op_assign
id|dasd_device_from_cdev
c_func
(paren
id|cdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|device
)paren
)paren
r_return
id|PTR_ERR
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|DASD_FLAG_OFFLINE
comma
op_amp
id|device-&gt;flags
)paren
)paren
(brace
multiline_comment|/* Already doing offline processing */
id|dasd_put_device
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We must make sure that this device is currently not in use.&n;&t; * The open_count is increased for every opener, that includes&n;&t; * the blkdev_get in dasd_scan_partitions. We are only interested&n;&t; * in the other openers.&n;&t; */
id|max_count
op_assign
id|device-&gt;bdev
ques
c_cond
l_int|0
suffix:colon
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|device-&gt;open_count
)paren
OG
id|max_count
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;Can&squot;t offline dasd device with open&quot;
l_string|&quot; count = %i.&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|device-&gt;open_count
)paren
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|DASD_FLAG_OFFLINE
comma
op_amp
id|device-&gt;flags
)paren
suffix:semicolon
id|dasd_put_device
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|dasd_set_target_state
c_func
(paren
id|device
comma
id|DASD_STATE_NEW
)paren
suffix:semicolon
multiline_comment|/* dasd_delete_device destroys the device reference. */
id|dasd_delete_device
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|dasd_generic_notify
id|dasd_generic_notify
c_func
(paren
r_struct
id|ccw_device
op_star
id|cdev
comma
r_int
id|event
)paren
(brace
r_struct
id|dasd_device
op_star
id|device
suffix:semicolon
r_struct
id|dasd_ccw_req
op_star
id|cqr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|device
op_assign
id|dasd_device_from_cdev
c_func
(paren
id|cdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|device
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|cdev
)paren
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|CIO_GONE
suffix:colon
r_case
id|CIO_NO_PATH
suffix:colon
r_if
c_cond
(paren
id|device-&gt;state
OL
id|DASD_STATE_BASIC
)paren
r_break
suffix:semicolon
multiline_comment|/* Device is active. We want to keep it. */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|DASD_FLAG_DSC_ERROR
comma
op_amp
id|device-&gt;flags
)paren
)paren
(brace
id|list_for_each_entry
c_func
(paren
id|cqr
comma
op_amp
id|device-&gt;ccw_queue
comma
id|list
)paren
r_if
c_cond
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_IN_IO
)paren
id|cqr-&gt;status
op_assign
id|DASD_CQR_FAILED
suffix:semicolon
id|device-&gt;stopped
op_or_assign
id|DASD_STOPPED_DC_EIO
suffix:semicolon
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
r_else
(brace
id|list_for_each_entry
c_func
(paren
id|cqr
comma
op_amp
id|device-&gt;ccw_queue
comma
id|list
)paren
r_if
c_cond
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_IN_IO
)paren
(brace
id|cqr-&gt;status
op_assign
id|DASD_CQR_QUEUED
suffix:semicolon
id|cqr-&gt;retries
op_increment
suffix:semicolon
)brace
id|device-&gt;stopped
op_or_assign
id|DASD_STOPPED_DC_WAIT
suffix:semicolon
id|dasd_set_timer
c_func
(paren
id|device
comma
l_int|0
)paren
suffix:semicolon
)brace
id|ret
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CIO_OPER
suffix:colon
multiline_comment|/* FIXME: add a sanity check. */
id|device-&gt;stopped
op_and_assign
op_complement
(paren
id|DASD_STOPPED_DC_WAIT
op_or
id|DASD_STOPPED_DC_EIO
)paren
suffix:semicolon
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
id|get_ccwdev_lock
c_func
(paren
id|cdev
)paren
comma
id|flags
)paren
suffix:semicolon
id|dasd_put_device
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Automatically online either all dasd devices (dasd_autodetect) or&n; * all devices specified with dasd= parameters.&n; */
r_void
DECL|function|dasd_generic_auto_online
id|dasd_generic_auto_online
(paren
r_struct
id|ccw_driver
op_star
id|dasd_discipline_driver
)paren
(brace
r_struct
id|device_driver
op_star
id|drv
suffix:semicolon
r_struct
id|device
op_star
id|d
comma
op_star
id|dev
suffix:semicolon
r_struct
id|ccw_device
op_star
id|cdev
suffix:semicolon
id|drv
op_assign
id|get_driver
c_func
(paren
op_amp
id|dasd_discipline_driver-&gt;driver
)paren
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|drv-&gt;bus-&gt;subsys.rwsem
)paren
suffix:semicolon
id|dev
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|d
comma
op_amp
id|drv-&gt;devices
comma
id|driver_list
)paren
(brace
id|dev
op_assign
id|get_device
c_func
(paren
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_continue
suffix:semicolon
id|cdev
op_assign
id|to_ccwdev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dasd_autodetect
op_logical_or
id|dasd_busid_known
c_func
(paren
id|cdev-&gt;dev.bus_id
)paren
op_eq
l_int|0
)paren
id|ccw_device_set_online
c_func
(paren
id|cdev
)paren
suffix:semicolon
id|put_device
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|up_read
c_func
(paren
op_amp
id|drv-&gt;bus-&gt;subsys.rwsem
)paren
suffix:semicolon
id|put_driver
c_func
(paren
id|drv
)paren
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|dasd_init
id|dasd_init
c_func
(paren
r_void
)paren
(brace
r_int
id|rc
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|dasd_init_waitq
)paren
suffix:semicolon
multiline_comment|/* register &squot;common&squot; DASD debug area, used for all DBF_XXX calls */
id|dasd_debug_area
op_assign
id|debug_register
c_func
(paren
l_string|&quot;dasd&quot;
comma
l_int|0
comma
l_int|2
comma
l_int|8
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dasd_debug_area
op_eq
l_int|NULL
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
id|debug_register_view
c_func
(paren
id|dasd_debug_area
comma
op_amp
id|debug_sprintf_view
)paren
suffix:semicolon
id|debug_set_level
c_func
(paren
id|dasd_debug_area
comma
id|DBF_DEBUG
)paren
suffix:semicolon
id|DBF_EVENT
c_func
(paren
id|DBF_EMERG
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;debug area created&quot;
)paren
suffix:semicolon
id|dasd_diag_discipline_pointer
op_assign
l_int|NULL
suffix:semicolon
id|rc
op_assign
id|devfs_mk_dir
c_func
(paren
l_string|&quot;dasd&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|failed
suffix:semicolon
id|rc
op_assign
id|dasd_devmap_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|failed
suffix:semicolon
id|rc
op_assign
id|dasd_gendisk_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|failed
suffix:semicolon
id|rc
op_assign
id|dasd_parse
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|failed
suffix:semicolon
id|rc
op_assign
id|dasd_ioctl_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|failed
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|rc
op_assign
id|dasd_proc_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|failed
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
id|failed
suffix:colon
id|MESSAGE
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;initialization not performed due to errors&quot;
)paren
suffix:semicolon
id|dasd_exit
c_func
(paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|variable|dasd_init
id|module_init
c_func
(paren
id|dasd_init
)paren
suffix:semicolon
DECL|variable|dasd_exit
id|module_exit
c_func
(paren
id|dasd_exit
)paren
suffix:semicolon
DECL|variable|dasd_debug_area
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_debug_area
)paren
suffix:semicolon
DECL|variable|dasd_diag_discipline_pointer
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_diag_discipline_pointer
)paren
suffix:semicolon
DECL|variable|dasd_add_request_head
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_add_request_head
)paren
suffix:semicolon
DECL|variable|dasd_add_request_tail
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_add_request_tail
)paren
suffix:semicolon
DECL|variable|dasd_cancel_req
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_cancel_req
)paren
suffix:semicolon
DECL|variable|dasd_clear_timer
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_clear_timer
)paren
suffix:semicolon
DECL|variable|dasd_enable_device
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_enable_device
)paren
suffix:semicolon
DECL|variable|dasd_int_handler
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_int_handler
)paren
suffix:semicolon
DECL|variable|dasd_kfree_request
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_kfree_request
)paren
suffix:semicolon
DECL|variable|dasd_kick_device
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_kick_device
)paren
suffix:semicolon
DECL|variable|dasd_kmalloc_request
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_kmalloc_request
)paren
suffix:semicolon
DECL|variable|dasd_schedule_bh
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_schedule_bh
)paren
suffix:semicolon
DECL|variable|dasd_set_target_state
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_set_target_state
)paren
suffix:semicolon
DECL|variable|dasd_set_timer
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_set_timer
)paren
suffix:semicolon
DECL|variable|dasd_sfree_request
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_sfree_request
)paren
suffix:semicolon
DECL|variable|dasd_sleep_on
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_sleep_on
)paren
suffix:semicolon
DECL|variable|dasd_sleep_on_immediatly
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_sleep_on_immediatly
)paren
suffix:semicolon
DECL|variable|dasd_sleep_on_interruptible
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_sleep_on_interruptible
)paren
suffix:semicolon
DECL|variable|dasd_smalloc_request
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_smalloc_request
)paren
suffix:semicolon
DECL|variable|dasd_start_IO
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_start_IO
)paren
suffix:semicolon
DECL|variable|dasd_term_IO
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_term_IO
)paren
suffix:semicolon
DECL|variable|dasd_generic_probe
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|dasd_generic_probe
)paren
suffix:semicolon
DECL|variable|dasd_generic_remove
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|dasd_generic_remove
)paren
suffix:semicolon
DECL|variable|dasd_generic_notify
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|dasd_generic_notify
)paren
suffix:semicolon
DECL|variable|dasd_generic_set_online
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|dasd_generic_set_online
)paren
suffix:semicolon
DECL|variable|dasd_generic_set_offline
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|dasd_generic_set_offline
)paren
suffix:semicolon
DECL|variable|dasd_generic_auto_online
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|dasd_generic_auto_online
)paren
suffix:semicolon
multiline_comment|/*&n; * Overrides for Emacs so that we follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-indent-level: 4&n; * c-brace-imaginary-offset: 0&n; * c-brace-offset: -4&n; * c-argdecl-indent: 4&n; * c-label-offset: -4&n; * c-continued-statement-offset: 4&n; * c-continued-brace-offset: 0&n; * indent-tabs-mode: 1&n; * tab-width: 8&n; * End:&n; */
eof
