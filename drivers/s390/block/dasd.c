multiline_comment|/*&n; * File...........: linux/drivers/s390/block/dasd.c&n; * Author(s)......: Holger Smolinski &lt;Holger.Smolinski@de.ibm.com&gt;&n; *&t;&t;    Horst Hummel &lt;Horst.Hummel@de.ibm.com&gt;&n; *&t;&t;    Carsten Otte &lt;Cotte@de.ibm.com&gt;&n; *&t;&t;    Martin Schwidefsky &lt;schwidefsky@de.ibm.com&gt;&n; * Bugreports.to..: &lt;Linux390@de.ibm.com&gt;&n; * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999-2001&n; *&n; * History of changes (starts July 2000)&n; * 11/09/00 complete redesign after code review&n; * 02/01/01 added dynamic registration of ioctls&n; *&t;    fixed bug in registration of new majors&n; *&t;    fixed handling of request during dasd_end_request&n; *&t;    fixed handling of plugged queues&n; *&t;    fixed partition handling and HDIO_GETGEO&n; *&t;    fixed traditional naming scheme for devices beyond 702&n; *&t;    fixed some race conditions related to modules&n; *&t;    added devfs suupport&n; * 03/06/01 refined dynamic attach/detach for leaving devices which are online.&n; * 03/09/01 refined dynamic modifiaction of devices&n; * 03/12/01 moved policy in dasd_format to dasdfmt (renamed BIODASDFORMAT)&n; * 03/19/01 added BIODASDINFO-ioctl&n; *&t;    removed 2.2 compatibility&n; * 04/27/01 fixed PL030119COT (dasd_disciplines does not work)&n; * 04/30/01 fixed PL030146HSM (module locking with dynamic ioctls)&n; *&t;    fixed PL030130SBA (handling of invalid ranges)&n; * 05/02/01 fixed PL030145SBA (killing dasdmt)&n; *&t;    fixed PL030149SBA (status of &squot;accepted&squot; devices)&n; *&t;    fixed PL030146SBA (BUG in ibm.c after adding device)&n; *&t;    added BIODASDPRRD ioctl interface&n; * 05/11/01 fixed  PL030164MVE (trap in probeonly mode)&n; * 05/15/01 fixed devfs support for unformatted devices&n; * 06/26/01 hopefully fixed PL030172SBA,PL030234SBA&n; * 07/09/01 fixed PL030324MSH (wrong statistics output)&n; * 07/16/01 merged in new fixes for handling low-mem situations&n; * 01/22/01 fixed PL030579KBE (wrong statistics)&n; * 05/04/02 code restructuring.&n; */
DECL|macro|LOCAL_END_REQUEST
mdefine_line|#define LOCAL_END_REQUEST /* Don&squot;t generate end_request in blk.h */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;asm/div64.h&gt;
macro_line|#include &lt;asm/ebcdic.h&gt;
macro_line|#include &lt;asm/idals.h&gt;
macro_line|#include &lt;asm/todclk.h&gt;
multiline_comment|/* This is ugly... */
DECL|macro|PRINTK_HEADER
mdefine_line|#define PRINTK_HEADER &quot;dasd:&quot;
macro_line|#include &quot;dasd_int.h&quot;
macro_line|#include &quot;dasd_eckd.h&quot;
macro_line|#include &quot;dasd_fba.h&quot;
macro_line|#include &quot;dasd_diag.h&quot;
multiline_comment|/*&n; * SECTION: Constant definitions to be used within this file&n; */
DECL|macro|DASD_CHANQ_MAX_SIZE
mdefine_line|#define DASD_CHANQ_MAX_SIZE 5
multiline_comment|/*&n; * SECTION: exported variables of dasd.c&n; */
DECL|variable|dasd_debug_area
id|debug_info_t
op_star
id|dasd_debug_area
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Holger Smolinski &lt;Holger.Smolinski@de.ibm.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Linux on S/390 DASD device driver,&quot;
l_string|&quot; Copyright 2000 IBM Corporation&quot;
)paren
suffix:semicolon
id|MODULE_SUPPORTED_DEVICE
c_func
(paren
l_string|&quot;dasd&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|dasd
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
l_int|256
)paren
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|dasd_disciplines
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
l_int|8
)paren
l_string|&quot;s&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * SECTION: prototypes for static functions of dasd.c&n; */
r_static
r_void
id|dasd_enable_discipline
c_func
(paren
id|dasd_discipline_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|dasd_disable_discipline
c_func
(paren
id|dasd_discipline_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|dasd_not_oper_handler
c_func
(paren
r_int
id|irq
comma
r_int
id|status
)paren
suffix:semicolon
r_static
r_int
id|dasd_setup_blkdev
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
suffix:semicolon
r_static
r_void
id|dasd_disable_blkdev
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
suffix:semicolon
r_static
r_void
id|dasd_flush_request_queue
c_func
(paren
id|dasd_device_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|dasd_int_handler
c_func
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_void
id|dasd_flush_ccw_queue
c_func
(paren
id|dasd_device_t
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|dasd_tasklet
c_func
(paren
id|dasd_device_t
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * Parameter parsing functions. There are two for the dasd driver:&n; *   &lt;dasd_disciplines&gt; : &lt;dasd_module&gt;(,&lt;dasd_module&gt;)*&n; */
DECL|variable|dasd_disciplines
r_static
r_char
op_star
id|dasd_disciplines
(braket
l_int|8
)braket
suffix:semicolon
macro_line|#ifndef MODULE
multiline_comment|/*&n; * The parameter parsing functions for builtin-drivers are called&n; * before kmalloc works. Store the pointers to the parameters strings&n; * into dasd_disciplines[] for later processing.&n; */
r_static
r_int
id|__init
DECL|function|dasd_disciplines_setup
id|dasd_disciplines_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_static
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
l_int|8
)paren
id|dasd_disciplines
(braket
id|count
op_increment
)braket
op_assign
id|str
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
(paren
l_string|&quot;dasd_disciplines=&quot;
comma
id|dasd_disciplines_setup
)paren
suffix:semicolon
macro_line|#endif&t;/* #ifndef MODULE */
multiline_comment|/*&n; * SECTION: managing dasd disciplines&n; */
DECL|variable|dasd_disc_head
r_static
r_struct
id|list_head
id|dasd_disc_head
op_assign
id|LIST_HEAD_INIT
c_func
(paren
id|dasd_disc_head
)paren
suffix:semicolon
DECL|variable|discipline_lock
r_static
id|spinlock_t
id|discipline_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * Add a discipline to the head of the discipline chain. The last added&n; * discipline that matches a device is used. In particular disciplines&n; * added by a module will have precedence over statically linked &n; * disciplines.&n; */
r_void
DECL|function|dasd_discipline_add
id|dasd_discipline_add
c_func
(paren
id|dasd_discipline_t
op_star
id|discipline
)paren
(brace
id|MOD_INC_USE_COUNT
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|discipline_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|discipline-&gt;list
comma
op_amp
id|dasd_disc_head
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|discipline_lock
)paren
suffix:semicolon
multiline_comment|/* Setup devices for discipline. */
id|dasd_enable_discipline
c_func
(paren
id|discipline
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove a discipline from the discipline list and disable all devices&n; * that rely on that discipline.&n; */
r_void
DECL|function|dasd_discipline_del
id|dasd_discipline_del
c_func
(paren
id|dasd_discipline_t
op_star
id|discipline
)paren
(brace
r_struct
id|list_head
op_star
id|l
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|discipline_lock
)paren
suffix:semicolon
multiline_comment|/* Check if the discipline was added. */
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|dasd_disc_head
)paren
(brace
r_if
c_cond
(paren
id|list_entry
c_func
(paren
id|l
comma
id|dasd_discipline_t
comma
id|list
)paren
op_eq
id|discipline
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|discipline-&gt;list
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|discipline_lock
)paren
suffix:semicolon
multiline_comment|/* Disable devices for discipline. */
id|dasd_disable_discipline
c_func
(paren
id|discipline
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the discipline for a device.&n; */
r_static
r_inline
r_int
DECL|function|dasd_find_disc
id|dasd_find_disc
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
r_struct
id|list_head
op_star
id|l
suffix:semicolon
id|dasd_discipline_t
op_star
id|discipline
comma
op_star
id|tmp
suffix:semicolon
id|discipline
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|discipline_lock
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|dasd_disc_head
)paren
(brace
id|tmp
op_assign
id|list_entry
c_func
(paren
id|l
comma
id|dasd_discipline_t
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_member_access_from_pointer
id|check_device
c_func
(paren
id|device
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Found a matching discipline. */
id|discipline
op_assign
id|tmp
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|device-&gt;discipline
op_assign
id|discipline
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|discipline_lock
)paren
suffix:semicolon
r_return
(paren
id|discipline
op_ne
l_int|NULL
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n; * SECTION: Operations on the device structure.&n; */
DECL|variable|dasd_devfs_handle
r_static
id|devfs_handle_t
id|dasd_devfs_handle
suffix:semicolon
DECL|variable|dasd_init_waitq
r_static
id|wait_queue_head_t
id|dasd_init_waitq
suffix:semicolon
multiline_comment|/*&n; * Allocate memory for a new device structure.&n; */
id|dasd_device_t
op_star
DECL|function|dasd_alloc_device
id|dasd_alloc_device
c_func
(paren
id|dasd_devmap_t
op_star
id|devmap
)paren
(brace
id|dasd_device_t
op_star
id|device
suffix:semicolon
r_struct
id|gendisk
op_star
id|gdp
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|device
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|dasd_device_t
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device
op_eq
l_int|NULL
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|memset
c_func
(paren
id|device
comma
l_int|0
comma
r_sizeof
(paren
id|dasd_device_t
)paren
)paren
suffix:semicolon
multiline_comment|/* Get devinfo from the common io layer. */
id|rc
op_assign
id|get_dev_info_by_devno
c_func
(paren
id|devmap-&gt;devno
comma
op_amp
id|device-&gt;devinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|kfree
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
id|rc
)paren
suffix:semicolon
)brace
id|DBF_EVENT
c_func
(paren
id|DBF_NOTICE
comma
l_string|&quot;got devinfo CU-type %04x and dev-type %04x&quot;
comma
id|device-&gt;devinfo.sid_data.cu_type
comma
id|device-&gt;devinfo.sid_data.dev_type
)paren
suffix:semicolon
multiline_comment|/* Get two pages for normal block device operations. */
id|device-&gt;ccw_mem
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
op_or
id|GFP_DMA
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;ccw_mem
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
multiline_comment|/* Get one page for error recovery. */
id|device-&gt;erp_mem
op_assign
(paren
r_void
op_star
)paren
id|get_free_page
c_func
(paren
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;erp_mem
op_eq
l_int|NULL
)paren
(brace
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|device-&gt;ccw_mem
comma
l_int|1
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
multiline_comment|/* Allocate gendisk structure for device. */
id|gdp
op_assign
id|dasd_gendisk_alloc
c_func
(paren
id|devmap-&gt;devindex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|gdp
)paren
)paren
(brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|device-&gt;erp_mem
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|device-&gt;ccw_mem
comma
l_int|1
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
(paren
id|dasd_device_t
op_star
)paren
id|gdp
suffix:semicolon
)brace
id|device-&gt;gdp
op_assign
id|gdp
suffix:semicolon
id|dasd_init_chunklist
c_func
(paren
op_amp
id|device-&gt;ccw_chunks
comma
id|device-&gt;ccw_mem
comma
id|PAGE_SIZE
op_star
l_int|2
)paren
suffix:semicolon
id|dasd_init_chunklist
c_func
(paren
op_amp
id|device-&gt;erp_chunks
comma
id|device-&gt;erp_mem
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|device-&gt;request_queue_lock
)paren
suffix:semicolon
id|atomic_set
(paren
op_amp
id|device-&gt;tasklet_scheduled
comma
l_int|0
)paren
suffix:semicolon
id|tasklet_init
c_func
(paren
op_amp
id|device-&gt;tasklet
comma
(paren
r_void
(paren
op_star
)paren
(paren
r_int
r_int
)paren
)paren
id|dasd_tasklet
comma
(paren
r_int
r_int
)paren
id|device
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|device-&gt;ccw_queue
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|device-&gt;timer
)paren
suffix:semicolon
id|device-&gt;state
op_assign
id|DASD_STATE_NEW
suffix:semicolon
id|device-&gt;target
op_assign
id|DASD_STATE_NEW
suffix:semicolon
r_return
id|device
suffix:semicolon
)brace
multiline_comment|/*&n; * Free memory of a device structure.&n; */
r_void
DECL|function|dasd_free_device
id|dasd_free_device
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
r_if
c_cond
(paren
id|device
op_member_access_from_pointer
r_private
)paren
id|kfree
c_func
(paren
id|device
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|device-&gt;erp_mem
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|device-&gt;ccw_mem
comma
l_int|1
)paren
suffix:semicolon
id|put_disk
c_func
(paren
id|device-&gt;gdp
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Make a new device known to the system.&n; */
r_static
r_inline
r_int
DECL|function|dasd_state_new_to_known
id|dasd_state_new_to_known
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
r_char
id|buffer
(braket
l_int|5
)braket
suffix:semicolon
id|dasd_devmap_t
op_star
id|devmap
suffix:semicolon
id|umode_t
id|devfs_perm
suffix:semicolon
id|devfs_handle_t
id|dir
suffix:semicolon
r_int
id|major
comma
id|minor
comma
id|rc
suffix:semicolon
id|devmap
op_assign
id|dasd_devmap_from_devno
c_func
(paren
id|device-&gt;devinfo.devno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devmap
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|major
op_assign
id|dasd_gendisk_index_major
c_func
(paren
id|devmap-&gt;devindex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|major
OL
l_int|0
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|minor
op_assign
id|devmap-&gt;devindex
op_mod
id|DASD_PER_MAJOR
suffix:semicolon
multiline_comment|/* Find a discipline for the device. */
id|rc
op_assign
id|dasd_find_disc
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* Add a proc directory and the dasd device entry to devfs. */
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%04x&quot;
comma
id|device-&gt;devinfo.devno
)paren
suffix:semicolon
id|dir
op_assign
id|devfs_mk_dir
c_func
(paren
id|dasd_devfs_handle
comma
id|buffer
comma
id|device
)paren
suffix:semicolon
id|device-&gt;gdp-&gt;de
op_assign
id|dir
suffix:semicolon
r_if
c_cond
(paren
id|devmap-&gt;features
op_amp
id|DASD_FEATURE_READONLY
)paren
id|devfs_perm
op_assign
id|S_IFBLK
op_or
id|S_IRUSR
suffix:semicolon
r_else
id|devfs_perm
op_assign
id|S_IFBLK
op_or
id|S_IRUSR
op_or
id|S_IWUSR
suffix:semicolon
id|device-&gt;devfs_entry
op_assign
id|devfs_register
c_func
(paren
id|dir
comma
l_string|&quot;device&quot;
comma
id|DEVFS_FL_DEFAULT
comma
id|major
comma
id|minor
op_lshift
id|DASD_PARTN_BITS
comma
id|devfs_perm
comma
op_amp
id|dasd_device_operations
comma
l_int|NULL
)paren
suffix:semicolon
id|device-&gt;state
op_assign
id|DASD_STATE_KNOWN
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Let the system forget about a device.&n; */
r_static
r_inline
r_void
DECL|function|dasd_state_known_to_new
id|dasd_state_known_to_new
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
id|dasd_devmap_t
op_star
id|devmap
suffix:semicolon
r_struct
id|block_device
op_star
id|bdev
suffix:semicolon
r_int
id|minor
suffix:semicolon
id|devmap
op_assign
id|dasd_devmap_from_devno
c_func
(paren
id|device-&gt;devinfo.devno
)paren
suffix:semicolon
id|minor
op_assign
id|devmap-&gt;devindex
op_mod
id|DASD_PER_MAJOR
suffix:semicolon
multiline_comment|/* Remove device entry and devfs directory. */
id|devfs_unregister
c_func
(paren
id|device-&gt;devfs_entry
)paren
suffix:semicolon
id|devfs_unregister
c_func
(paren
id|device-&gt;gdp-&gt;de
)paren
suffix:semicolon
multiline_comment|/* Forget the discipline information. */
id|device-&gt;discipline
op_assign
l_int|NULL
suffix:semicolon
id|device-&gt;state
op_assign
id|DASD_STATE_NEW
suffix:semicolon
multiline_comment|/* Forget the block device */
id|bdev
op_assign
id|bdget
c_func
(paren
id|MKDEV
c_func
(paren
id|device-&gt;gdp-&gt;major
comma
id|device-&gt;gdp-&gt;first_minor
)paren
)paren
suffix:semicolon
id|bdput
c_func
(paren
id|bdev
)paren
suffix:semicolon
id|bdput
c_func
(paren
id|bdev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Request the irq line for the device.&n; */
r_static
r_inline
r_int
DECL|function|dasd_state_known_to_basic
id|dasd_state_known_to_basic
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
r_int
id|rc
suffix:semicolon
multiline_comment|/* register &squot;device&squot; debug area, used for all DBF_DEV_XXX calls */
id|device-&gt;debug_area
op_assign
id|debug_register
c_func
(paren
id|device-&gt;gdp-&gt;disk_name
comma
l_int|0
comma
l_int|2
comma
l_int|8
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|debug_register_view
c_func
(paren
id|device-&gt;debug_area
comma
op_amp
id|debug_sprintf_view
)paren
suffix:semicolon
id|debug_set_level
c_func
(paren
id|device-&gt;debug_area
comma
id|DBF_ERR
)paren
suffix:semicolon
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_EMERG
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;debug area created&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We request the &quot;official&quot; irq line even for dasd diag device.&n;&t; * The interrupts for dasd diag will arrive at dasd_ext_handler&n;&t; * instead of dasd_int_handler so this is just a placeholder.&n;&t; */
id|rc
op_assign
id|s390_request_irq_special
c_func
(paren
id|device-&gt;devinfo.irq
comma
id|dasd_int_handler
comma
id|dasd_not_oper_handler
comma
l_int|0
comma
l_string|&quot;dasd&quot;
comma
op_amp
id|device-&gt;dev_status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|MESSAGE
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;No request IRQ&quot;
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|device-&gt;state
op_assign
id|DASD_STATE_BASIC
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Release the irq line for the device. Terminate any running i/o.&n; */
r_static
r_inline
r_void
DECL|function|dasd_state_basic_to_known
id|dasd_state_basic_to_known
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
id|dasd_flush_ccw_queue
c_func
(paren
id|device
comma
l_int|1
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|device-&gt;devinfo.irq
comma
op_amp
id|device-&gt;dev_status
)paren
suffix:semicolon
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_EMERG
comma
id|device
comma
l_string|&quot;%p debug area deleted&quot;
comma
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;debug_area
op_ne
l_int|NULL
)paren
(brace
id|debug_unregister
c_func
(paren
id|device-&gt;debug_area
)paren
suffix:semicolon
id|device-&gt;debug_area
op_assign
l_int|NULL
suffix:semicolon
)brace
id|device-&gt;state
op_assign
id|DASD_STATE_KNOWN
suffix:semicolon
)brace
multiline_comment|/*&n; * Do the initial analysis. The do_analysis function may return&n; * -EAGAIN in which case the device keeps the state DASD_STATE_BASIC&n; * until the discipline decides to continue the startup sequence&n; * by calling the function dasd_change_state. The eckd disciplines&n; * uses this to start a ccw that detects the format. The completion&n; * interrupt for this detection ccw uses the kernel event daemon to&n; * trigger the call to dasd_change_state. All this is done in the&n; * discipline code, see dasd_eckd.c.&n; */
r_static
r_inline
r_int
DECL|function|dasd_state_basic_to_accept
id|dasd_state_basic_to_accept
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
r_int
id|rc
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;discipline-&gt;do_analysis
op_ne
l_int|NULL
)paren
id|rc
op_assign
id|device-&gt;discipline
op_member_access_from_pointer
id|do_analysis
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
id|device-&gt;state
op_assign
id|DASD_STATE_ACCEPT
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Forget everything the initial analysis found out.&n; */
r_static
r_inline
r_void
DECL|function|dasd_state_accept_to_basic
id|dasd_state_accept_to_basic
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
id|device-&gt;blocks
op_assign
l_int|0
suffix:semicolon
id|device-&gt;bp_block
op_assign
l_int|0
suffix:semicolon
id|device-&gt;s2b_shift
op_assign
l_int|0
suffix:semicolon
id|device-&gt;state
op_assign
id|DASD_STATE_BASIC
suffix:semicolon
)brace
multiline_comment|/*&n; * get the kdev_t of a device &n; * FIXME: remove this when no longer needed&n; */
r_static
r_inline
id|kdev_t
DECL|function|dasd_partition_to_kdev_t
id|dasd_partition_to_kdev_t
c_func
(paren
id|dasd_device_t
op_star
id|device
comma
r_int
r_int
id|partition
)paren
(brace
r_return
id|mk_kdev
c_func
(paren
id|device-&gt;gdp-&gt;major
comma
id|device-&gt;gdp-&gt;first_minor
op_plus
id|partition
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Setup block device.&n; */
r_static
r_inline
r_int
DECL|function|dasd_state_accept_to_ready
id|dasd_state_accept_to_ready
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
id|dasd_devmap_t
op_star
id|devmap
suffix:semicolon
r_int
id|rc
comma
id|i
suffix:semicolon
id|devmap
op_assign
id|dasd_devmap_from_devno
c_func
(paren
id|device-&gt;devinfo.devno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devmap-&gt;features
op_amp
id|DASD_FEATURE_READONLY
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
l_int|1
op_lshift
id|DASD_PARTN_BITS
)paren
suffix:semicolon
id|i
op_increment
)paren
id|set_device_ro
c_func
(paren
id|dasd_partition_to_kdev_t
c_func
(paren
id|device
comma
id|i
)paren
comma
l_int|1
)paren
suffix:semicolon
id|device-&gt;ro_flag
op_assign
l_int|1
suffix:semicolon
id|DEV_MESSAGE
(paren
id|KERN_WARNING
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;setting read-only mode &quot;
)paren
suffix:semicolon
)brace
id|rc
op_assign
id|dasd_setup_blkdev
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|dasd_setup_partitions
c_func
(paren
id|device
)paren
suffix:semicolon
id|device-&gt;state
op_assign
id|DASD_STATE_READY
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove device from block device layer. Destroy dirty buffers.&n; */
r_static
r_inline
r_void
DECL|function|dasd_state_ready_to_accept
id|dasd_state_ready_to_accept
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
id|dasd_flush_ccw_queue
c_func
(paren
id|device
comma
l_int|0
)paren
suffix:semicolon
id|dasd_destroy_partitions
c_func
(paren
id|device
)paren
suffix:semicolon
id|dasd_flush_request_queue
c_func
(paren
id|device
)paren
suffix:semicolon
id|dasd_disable_blkdev
c_func
(paren
id|device
)paren
suffix:semicolon
id|device-&gt;state
op_assign
id|DASD_STATE_ACCEPT
suffix:semicolon
)brace
multiline_comment|/*&n; * Make the device online and schedule the bottom half to start&n; * the requeueing of requests from the linux request queue to the&n; * ccw queue.&n; */
r_static
r_inline
r_int
DECL|function|dasd_state_ready_to_online
id|dasd_state_ready_to_online
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
id|device-&gt;state
op_assign
id|DASD_STATE_ONLINE
suffix:semicolon
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Stop the requeueing of requests again.&n; */
r_static
r_inline
r_void
DECL|function|dasd_state_online_to_ready
id|dasd_state_online_to_ready
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
id|device-&gt;state
op_assign
id|DASD_STATE_READY
suffix:semicolon
)brace
multiline_comment|/*&n; * Device startup state changes.&n; */
r_static
r_inline
r_int
DECL|function|dasd_increase_state
id|dasd_increase_state
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
r_int
id|rc
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;state
op_eq
id|DASD_STATE_NEW
op_logical_and
id|device-&gt;target
op_ge
id|DASD_STATE_KNOWN
)paren
id|rc
op_assign
id|dasd_state_new_to_known
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;state
op_eq
id|DASD_STATE_KNOWN
op_logical_and
id|device-&gt;target
op_ge
id|DASD_STATE_BASIC
)paren
id|rc
op_assign
id|dasd_state_known_to_basic
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;state
op_eq
id|DASD_STATE_BASIC
op_logical_and
id|device-&gt;target
op_ge
id|DASD_STATE_ACCEPT
)paren
id|rc
op_assign
id|dasd_state_basic_to_accept
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;state
op_eq
id|DASD_STATE_ACCEPT
op_logical_and
id|device-&gt;target
op_ge
id|DASD_STATE_READY
)paren
id|rc
op_assign
id|dasd_state_accept_to_ready
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;state
op_eq
id|DASD_STATE_READY
op_logical_and
id|device-&gt;target
op_ge
id|DASD_STATE_ONLINE
)paren
id|rc
op_assign
id|dasd_state_ready_to_online
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Device shutdown state changes.&n; */
r_static
r_inline
r_int
DECL|function|dasd_decrease_state
id|dasd_decrease_state
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
r_if
c_cond
(paren
id|device-&gt;state
op_eq
id|DASD_STATE_ONLINE
op_logical_and
id|device-&gt;target
op_le
id|DASD_STATE_READY
)paren
id|dasd_state_online_to_ready
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;state
op_eq
id|DASD_STATE_READY
op_logical_and
id|device-&gt;target
op_le
id|DASD_STATE_ACCEPT
)paren
id|dasd_state_ready_to_accept
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;state
op_eq
id|DASD_STATE_ACCEPT
op_logical_and
id|device-&gt;target
op_le
id|DASD_STATE_BASIC
)paren
id|dasd_state_accept_to_basic
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;state
op_eq
id|DASD_STATE_BASIC
op_logical_and
id|device-&gt;target
op_le
id|DASD_STATE_KNOWN
)paren
id|dasd_state_basic_to_known
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;state
op_eq
id|DASD_STATE_KNOWN
op_logical_and
id|device-&gt;target
op_le
id|DASD_STATE_NEW
)paren
id|dasd_state_known_to_new
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the main startup/shutdown routine.&n; */
r_static
r_void
DECL|function|dasd_change_state
id|dasd_change_state
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;state
op_eq
id|device-&gt;target
)paren
multiline_comment|/* Already where we want to go today... */
r_return
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;state
OL
id|device-&gt;target
)paren
id|rc
op_assign
id|dasd_increase_state
c_func
(paren
id|device
)paren
suffix:semicolon
r_else
id|rc
op_assign
id|dasd_decrease_state
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_logical_and
id|rc
op_ne
op_minus
id|EAGAIN
)paren
(brace
r_if
c_cond
(paren
id|rc
op_ne
op_minus
id|ENODEV
)paren
id|MESSAGE
(paren
id|KERN_INFO
comma
l_string|&quot;giving up on dasd device with &quot;
l_string|&quot;devno %04x&quot;
comma
id|device-&gt;devinfo.devno
)paren
suffix:semicolon
id|device-&gt;target
op_assign
id|device-&gt;state
suffix:semicolon
)brace
r_if
c_cond
(paren
id|device-&gt;state
op_eq
id|device-&gt;target
)paren
id|wake_up
c_func
(paren
op_amp
id|dasd_init_waitq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Kick starter for devices that did not complete the startup/shutdown&n; * procedure or were sleeping because of a pending state.&n; * dasd_kick_device will schedule a call do do_kick_device to the kernel&n; * event daemon.&n; */
r_static
r_void
DECL|function|do_kick_device
id|do_kick_device
c_func
(paren
r_int
id|devno
)paren
(brace
id|dasd_devmap_t
op_star
id|devmap
suffix:semicolon
id|dasd_device_t
op_star
id|device
suffix:semicolon
id|devmap
op_assign
id|dasd_devmap_from_devno
c_func
(paren
id|devno
)paren
suffix:semicolon
id|device
op_assign
(paren
id|devmap
op_ne
l_int|NULL
)paren
ques
c_cond
id|dasd_get_device
c_func
(paren
id|devmap
)paren
suffix:colon
id|ERR_PTR
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|device
)paren
)paren
r_return
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|device-&gt;ref_count
)paren
suffix:semicolon
id|dasd_change_state
c_func
(paren
id|device
)paren
suffix:semicolon
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
id|dasd_put_device
c_func
(paren
id|devmap
)paren
suffix:semicolon
)brace
r_void
DECL|function|dasd_kick_device
id|dasd_kick_device
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|device-&gt;ref_count
)paren
suffix:semicolon
id|device-&gt;kick_tq.routine
op_assign
(paren
r_void
op_star
)paren
id|do_kick_device
suffix:semicolon
id|device-&gt;kick_tq.data
op_assign
(paren
r_void
op_star
)paren
(paren
id|addr_t
)paren
id|device-&gt;devinfo.devno
suffix:semicolon
multiline_comment|/* queue call to dasd_kick_device to the kernel event daemon. */
id|schedule_task
c_func
(paren
op_amp
id|device-&gt;kick_tq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the target state for a device and starts the state change.&n; */
r_void
DECL|function|dasd_set_target_state
id|dasd_set_target_state
c_func
(paren
id|dasd_device_t
op_star
id|device
comma
r_int
id|target
)paren
(brace
multiline_comment|/* If we are in probeonly mode stop at DASD_STATE_ACCEPT. */
r_if
c_cond
(paren
id|dasd_probeonly
op_logical_and
id|target
OG
id|DASD_STATE_ACCEPT
)paren
id|target
op_assign
id|DASD_STATE_ACCEPT
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;target
op_ne
id|target
)paren
(brace
r_if
c_cond
(paren
id|device-&gt;state
op_eq
id|target
)paren
id|wake_up
c_func
(paren
op_amp
id|dasd_init_waitq
)paren
suffix:semicolon
id|device-&gt;target
op_assign
id|target
suffix:semicolon
)brace
r_if
c_cond
(paren
id|device-&gt;state
op_ne
id|device-&gt;target
)paren
id|dasd_change_state
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Enable devices with device numbers in [from..to].&n; */
r_static
r_inline
r_int
DECL|function|_wait_for_devices
id|_wait_for_devices
c_func
(paren
r_int
id|from
comma
r_int
id|to
)paren
(brace
id|dasd_devmap_t
op_star
id|devmap
suffix:semicolon
id|dasd_device_t
op_star
id|device
suffix:semicolon
r_int
id|devno
comma
id|rc
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|devno
op_assign
id|from
suffix:semicolon
id|devno
op_le
id|to
op_logical_and
id|rc
op_eq
l_int|0
suffix:semicolon
id|devno
op_increment
)paren
(brace
id|devmap
op_assign
id|dasd_devmap_from_devno
c_func
(paren
id|devno
)paren
suffix:semicolon
id|device
op_assign
(paren
id|devmap
op_ne
l_int|NULL
)paren
ques
c_cond
id|dasd_get_device
c_func
(paren
id|devmap
)paren
suffix:colon
id|ERR_PTR
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|device
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;state
op_ne
id|device-&gt;target
)paren
id|rc
op_assign
l_int|1
suffix:semicolon
id|dasd_put_device
c_func
(paren
id|devmap
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
r_void
DECL|function|dasd_enable_devices
id|dasd_enable_devices
c_func
(paren
r_int
id|from
comma
r_int
id|to
)paren
(brace
id|dasd_devmap_t
op_star
id|devmap
suffix:semicolon
id|dasd_device_t
op_star
id|device
suffix:semicolon
r_int
id|devno
suffix:semicolon
r_for
c_loop
(paren
id|devno
op_assign
id|from
suffix:semicolon
id|devno
op_le
id|to
suffix:semicolon
id|devno
op_increment
)paren
(brace
id|devmap
op_assign
id|dasd_devmap_from_devno
c_func
(paren
id|devno
)paren
suffix:semicolon
id|device
op_assign
(paren
id|devmap
op_ne
l_int|NULL
)paren
ques
c_cond
id|dasd_get_device
c_func
(paren
id|devmap
)paren
suffix:colon
id|ERR_PTR
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|device
)paren
)paren
r_continue
suffix:semicolon
id|dasd_set_target_state
c_func
(paren
id|device
comma
id|DASD_STATE_ONLINE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;state
op_le
id|DASD_STATE_KNOWN
)paren
multiline_comment|/* No discipline for device found. */
id|dasd_set_target_state
c_func
(paren
id|device
comma
id|DASD_STATE_NEW
)paren
suffix:semicolon
id|dasd_put_device
c_func
(paren
id|devmap
)paren
suffix:semicolon
)brace
multiline_comment|/* Now wait for the devices to come up. */
id|wait_event
c_func
(paren
id|dasd_init_waitq
comma
id|_wait_for_devices
c_func
(paren
id|from
comma
id|to
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Disable devices with device numbers in [from..to].&n; */
r_void
DECL|function|dasd_disable_devices
id|dasd_disable_devices
c_func
(paren
r_int
id|from
comma
r_int
id|to
)paren
(brace
id|dasd_devmap_t
op_star
id|devmap
suffix:semicolon
id|dasd_device_t
op_star
id|device
suffix:semicolon
r_int
id|devno
suffix:semicolon
r_for
c_loop
(paren
id|devno
op_assign
id|from
suffix:semicolon
id|devno
op_le
id|to
suffix:semicolon
id|devno
op_increment
)paren
(brace
id|devmap
op_assign
id|dasd_devmap_from_devno
c_func
(paren
id|devno
)paren
suffix:semicolon
id|device
op_assign
(paren
id|devmap
op_ne
l_int|NULL
)paren
ques
c_cond
id|dasd_get_device
c_func
(paren
id|devmap
)paren
suffix:colon
id|ERR_PTR
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|device
)paren
)paren
r_continue
suffix:semicolon
id|dasd_set_target_state
c_func
(paren
id|device
comma
id|DASD_STATE_NEW
)paren
suffix:semicolon
id|dasd_put_device
c_func
(paren
id|devmap
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Enable devices that use a specific discipline.&n; */
r_static
r_inline
r_int
DECL|function|_wait_for_disc_devices
id|_wait_for_disc_devices
c_func
(paren
id|dasd_discipline_t
op_star
id|discipline
)paren
(brace
id|dasd_devmap_t
op_star
id|devmap
suffix:semicolon
id|dasd_device_t
op_star
id|device
suffix:semicolon
r_int
id|devindex
comma
id|rc
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|devindex
op_assign
l_int|0
suffix:semicolon
id|devindex
OL
id|dasd_max_devindex
suffix:semicolon
id|devindex
op_increment
)paren
(brace
id|devmap
op_assign
id|dasd_devmap_from_devindex
c_func
(paren
id|devindex
)paren
suffix:semicolon
id|device
op_assign
(paren
id|devmap
op_ne
l_int|NULL
)paren
ques
c_cond
id|dasd_get_device
c_func
(paren
id|devmap
)paren
suffix:colon
id|ERR_PTR
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|device
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;discipline
op_eq
id|discipline
op_logical_and
id|device-&gt;state
op_ne
id|device-&gt;target
)paren
id|rc
op_assign
l_int|1
suffix:semicolon
id|dasd_put_device
c_func
(paren
id|devmap
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
r_static
r_void
DECL|function|dasd_enable_discipline
id|dasd_enable_discipline
c_func
(paren
id|dasd_discipline_t
op_star
id|discipline
)paren
(brace
id|dasd_devmap_t
op_star
id|devmap
suffix:semicolon
id|dasd_device_t
op_star
id|device
suffix:semicolon
r_int
id|devindex
suffix:semicolon
r_for
c_loop
(paren
id|devindex
op_assign
l_int|0
suffix:semicolon
id|devindex
OL
id|dasd_max_devindex
suffix:semicolon
id|devindex
op_increment
)paren
(brace
id|devmap
op_assign
id|dasd_devmap_from_devindex
c_func
(paren
id|devindex
)paren
suffix:semicolon
id|device
op_assign
(paren
id|devmap
op_ne
l_int|NULL
)paren
ques
c_cond
id|dasd_get_device
c_func
(paren
id|devmap
)paren
suffix:colon
id|ERR_PTR
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|device
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;discipline
op_ne
l_int|NULL
op_logical_and
id|device-&gt;discipline
op_ne
id|discipline
)paren
r_continue
suffix:semicolon
id|dasd_set_target_state
c_func
(paren
id|device
comma
id|DASD_STATE_ONLINE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;discipline
op_eq
l_int|NULL
)paren
multiline_comment|/* No discipline for device found. */
id|dasd_set_target_state
c_func
(paren
id|device
comma
id|DASD_STATE_NEW
)paren
suffix:semicolon
id|dasd_put_device
c_func
(paren
id|devmap
)paren
suffix:semicolon
)brace
multiline_comment|/* Now wait for the devices to come up. */
id|wait_event
c_func
(paren
id|dasd_init_waitq
comma
id|_wait_for_disc_devices
c_func
(paren
id|discipline
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Disable devices that use a specific discipline.&n; */
r_static
r_void
DECL|function|dasd_disable_discipline
id|dasd_disable_discipline
c_func
(paren
id|dasd_discipline_t
op_star
id|discipline
)paren
(brace
id|dasd_devmap_t
op_star
id|devmap
suffix:semicolon
id|dasd_device_t
op_star
id|device
suffix:semicolon
r_int
id|devindex
suffix:semicolon
multiline_comment|/* Shutdown device that use the discipline. */
r_for
c_loop
(paren
id|devindex
op_assign
l_int|0
suffix:semicolon
id|devindex
OL
id|dasd_max_devindex
suffix:semicolon
id|devindex
op_increment
)paren
(brace
id|devmap
op_assign
id|dasd_devmap_from_devindex
c_func
(paren
id|devindex
)paren
suffix:semicolon
id|device
op_assign
(paren
id|devmap
op_ne
l_int|NULL
)paren
ques
c_cond
id|dasd_get_device
c_func
(paren
id|devmap
)paren
suffix:colon
id|ERR_PTR
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|device
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;discipline
op_eq
id|discipline
)paren
id|dasd_set_target_state
c_func
(paren
id|device
comma
id|DASD_STATE_NEW
)paren
suffix:semicolon
id|dasd_put_device
c_func
(paren
id|devmap
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Deactivate a device that has vaninshed.&n; */
r_static
r_void
DECL|function|do_not_oper_handler
id|do_not_oper_handler
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
(brace
r_struct
id|tq_struct
id|tq
suffix:semicolon
r_int
id|irq
suffix:semicolon
)brace
op_star
id|p
suffix:semicolon
id|dasd_device_t
op_star
id|device
suffix:semicolon
id|dasd_devmap_t
op_star
id|devmap
suffix:semicolon
multiline_comment|/*&n;&t; * find out devno of leaving device: CIO has already deleted&n;&t; * this information so we need to find it by irq!&n;&t; */
id|p
op_assign
id|data
suffix:semicolon
id|devmap
op_assign
id|dasd_devmap_from_irq
c_func
(paren
id|p-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devmap
op_eq
l_int|NULL
)paren
(brace
id|MESSAGE
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;not_oper_handler called on irq 0x%04x no devno!&quot;
comma
id|p-&gt;irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
id|DBF_EVENT
c_func
(paren
id|DBF_NOTICE
comma
l_string|&quot;called for devno %04x&quot;
comma
id|devmap-&gt;devno
)paren
suffix:semicolon
id|device
op_assign
id|dasd_get_device
c_func
(paren
id|devmap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|device
)paren
)paren
r_return
suffix:semicolon
id|dasd_set_target_state
c_func
(paren
id|device
comma
id|DASD_STATE_NEW
)paren
suffix:semicolon
id|dasd_put_device
c_func
(paren
id|devmap
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_void
DECL|function|dasd_not_oper_handler
id|dasd_not_oper_handler
c_func
(paren
r_int
id|irq
comma
r_int
id|status
)paren
(brace
r_struct
(brace
r_struct
id|tq_struct
id|tq
suffix:semicolon
r_int
id|irq
suffix:semicolon
)brace
op_star
id|p
suffix:semicolon
id|p
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|p
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
multiline_comment|/* FIXME: No memory, we loose. */
r_return
suffix:semicolon
id|p-&gt;tq.routine
op_assign
(paren
r_void
op_star
)paren
id|do_not_oper_handler
suffix:semicolon
id|p-&gt;tq.data
op_assign
(paren
r_void
op_star
)paren
id|p
suffix:semicolon
id|p-&gt;irq
op_assign
id|irq
suffix:semicolon
multiline_comment|/* queue call to do_not_oper_handler to the kernel event daemon. */
id|schedule_task
c_func
(paren
op_amp
id|p-&gt;tq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Activate a device that appeared out of nowhere.&n; */
r_static
r_void
DECL|function|do_oper_handler
id|do_oper_handler
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
(brace
r_struct
id|tq_struct
id|tq
suffix:semicolon
r_int
id|devno
suffix:semicolon
)brace
op_star
id|p
suffix:semicolon
id|dasd_devmap_t
op_star
id|devmap
suffix:semicolon
id|dasd_device_t
op_star
id|device
suffix:semicolon
id|p
op_assign
id|data
suffix:semicolon
id|DBF_EVENT
c_func
(paren
id|DBF_NOTICE
comma
l_string|&quot;called for devno %04x&quot;
comma
id|p-&gt;devno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dasd_autodetect
op_logical_and
id|dasd_add_range
c_func
(paren
id|p-&gt;devno
comma
id|p-&gt;devno
comma
id|DASD_FEATURE_DEFAULT
)paren
op_ne
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* Get/create the device structure for devno. */
id|devmap
op_assign
id|dasd_devmap_from_devno
c_func
(paren
id|p-&gt;devno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devmap
op_eq
l_int|NULL
)paren
(brace
id|DBF_EXC
c_func
(paren
id|DBF_ALERT
comma
l_string|&quot;no dasd: devno %04x&quot;
comma
id|p-&gt;devno
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|device
op_assign
id|dasd_get_device
c_func
(paren
id|devmap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|device
)paren
)paren
r_return
suffix:semicolon
id|dasd_enable_devices
c_func
(paren
id|p-&gt;devno
comma
id|p-&gt;devno
)paren
suffix:semicolon
id|dasd_put_device
c_func
(paren
id|devmap
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_int
DECL|function|dasd_oper_handler
id|dasd_oper_handler
c_func
(paren
r_int
id|irq
comma
id|devreg_t
op_star
id|devreg
)paren
(brace
r_struct
(brace
r_struct
id|tq_struct
id|tq
suffix:semicolon
r_int
id|devno
suffix:semicolon
)brace
op_star
id|p
suffix:semicolon
id|p
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|p
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
multiline_comment|/* FIXME: No memory, we loose. */
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|p-&gt;devno
op_assign
id|get_devno_by_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;devno
op_eq
op_minus
id|ENODEV
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|p-&gt;tq.routine
op_assign
(paren
r_void
op_star
)paren
id|do_oper_handler
suffix:semicolon
id|p-&gt;tq.data
op_assign
(paren
r_void
op_star
)paren
id|p
suffix:semicolon
multiline_comment|/* queue call to do_oper_handler to the kernel event daemon. */
id|schedule_task
c_func
(paren
op_amp
id|p-&gt;tq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * SECTION: device operation (interrupt handler, start_IO, term_IO ...)&n; */
macro_line|#ifdef CONFIG_DASD_PROFILE
DECL|variable|dasd_global_profile
id|dasd_profile_info_t
id|dasd_global_profile
suffix:semicolon
DECL|variable|dasd_profile_level
r_int
r_int
id|dasd_profile_level
op_assign
id|DASD_PROFILE_OFF
suffix:semicolon
multiline_comment|/*&n; * Increments counter in global and local profiling structures.&n; */
DECL|macro|dasd_profile_counter
mdefine_line|#define dasd_profile_counter(value, counter, device) &bslash;&n;{ &bslash;&n;&t;int index; &bslash;&n;&t;for (index = 0; index &lt; 31 &amp;&amp; value &gt;&gt; (2+index); index++); &bslash;&n;&t;dasd_global_profile.counter[index]++; &bslash;&n;&t;device-&gt;profile.counter[index]++; &bslash;&n;}
multiline_comment|/*&n; * Add profiling information for cqr before execution.&n; */
r_static
r_inline
r_void
DECL|function|dasd_profile_start
id|dasd_profile_start
c_func
(paren
id|dasd_device_t
op_star
id|device
comma
id|dasd_ccw_req_t
op_star
id|cqr
comma
r_struct
id|request
op_star
id|req
)paren
(brace
r_struct
id|list_head
op_star
id|l
suffix:semicolon
r_int
r_int
id|counter
suffix:semicolon
r_if
c_cond
(paren
id|dasd_profile_level
op_ne
id|DASD_PROFILE_ON
)paren
r_return
suffix:semicolon
multiline_comment|/* count the length of the chanq for statistics */
id|counter
op_assign
l_int|0
suffix:semicolon
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|device-&gt;ccw_queue
)paren
r_if
c_cond
(paren
op_increment
id|counter
op_ge
l_int|31
)paren
r_break
suffix:semicolon
id|dasd_global_profile.dasd_io_nr_req
(braket
id|counter
)braket
op_increment
suffix:semicolon
id|device-&gt;profile.dasd_io_nr_req
(braket
id|counter
)braket
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * Add profiling information for cqr after execution.&n; */
r_static
r_inline
r_void
DECL|function|dasd_profile_end
id|dasd_profile_end
c_func
(paren
id|dasd_device_t
op_star
id|device
comma
id|dasd_ccw_req_t
op_star
id|cqr
comma
r_struct
id|request
op_star
id|req
)paren
(brace
r_int
id|strtime
comma
id|irqtime
comma
id|endtime
comma
id|tottime
suffix:semicolon
multiline_comment|/* in microsecnds */
r_int
id|tottimeps
comma
id|sectors
suffix:semicolon
r_if
c_cond
(paren
id|dasd_profile_level
op_ne
id|DASD_PROFILE_ON
)paren
r_return
suffix:semicolon
id|sectors
op_assign
id|req-&gt;nr_sectors
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cqr-&gt;buildclk
op_logical_or
op_logical_neg
id|cqr-&gt;startclk
op_logical_or
op_logical_neg
id|cqr-&gt;stopclk
op_logical_or
op_logical_neg
id|cqr-&gt;endclk
op_logical_or
op_logical_neg
id|sectors
)paren
r_return
suffix:semicolon
id|strtime
op_assign
(paren
(paren
id|cqr-&gt;startclk
op_minus
id|cqr-&gt;buildclk
)paren
op_rshift
l_int|12
)paren
suffix:semicolon
id|irqtime
op_assign
(paren
(paren
id|cqr-&gt;stopclk
op_minus
id|cqr-&gt;startclk
)paren
op_rshift
l_int|12
)paren
suffix:semicolon
id|endtime
op_assign
(paren
(paren
id|cqr-&gt;endclk
op_minus
id|cqr-&gt;stopclk
)paren
op_rshift
l_int|12
)paren
suffix:semicolon
id|tottime
op_assign
(paren
(paren
id|cqr-&gt;endclk
op_minus
id|cqr-&gt;buildclk
)paren
op_rshift
l_int|12
)paren
suffix:semicolon
id|tottimeps
op_assign
id|tottime
op_div
id|sectors
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dasd_global_profile.dasd_io_reqs
)paren
id|memset
c_func
(paren
op_amp
id|dasd_global_profile
comma
l_int|0
comma
r_sizeof
(paren
id|dasd_profile_info_t
)paren
)paren
suffix:semicolon
id|dasd_global_profile.dasd_io_reqs
op_increment
suffix:semicolon
id|dasd_global_profile.dasd_io_sects
op_add_assign
id|sectors
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device-&gt;profile.dasd_io_reqs
)paren
id|memset
c_func
(paren
op_amp
id|device-&gt;profile
comma
l_int|0
comma
r_sizeof
(paren
id|dasd_profile_info_t
)paren
)paren
suffix:semicolon
id|device-&gt;profile.dasd_io_reqs
op_increment
suffix:semicolon
id|device-&gt;profile.dasd_io_sects
op_add_assign
id|sectors
suffix:semicolon
id|dasd_profile_counter
c_func
(paren
id|sectors
comma
id|dasd_io_secs
comma
id|device
)paren
suffix:semicolon
id|dasd_profile_counter
c_func
(paren
id|tottime
comma
id|dasd_io_times
comma
id|device
)paren
suffix:semicolon
id|dasd_profile_counter
c_func
(paren
id|tottimeps
comma
id|dasd_io_timps
comma
id|device
)paren
suffix:semicolon
id|dasd_profile_counter
c_func
(paren
id|strtime
comma
id|dasd_io_time1
comma
id|device
)paren
suffix:semicolon
id|dasd_profile_counter
c_func
(paren
id|irqtime
comma
id|dasd_io_time2
comma
id|device
)paren
suffix:semicolon
id|dasd_profile_counter
c_func
(paren
id|irqtime
op_div
id|sectors
comma
id|dasd_io_time2ps
comma
id|device
)paren
suffix:semicolon
id|dasd_profile_counter
c_func
(paren
id|endtime
comma
id|dasd_io_time3
comma
id|device
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|dasd_profile_start
mdefine_line|#define dasd_profile_start(device, cqr, req) do {} while (0)
DECL|macro|dasd_profile_end
mdefine_line|#define dasd_profile_end(device, cqr, req) do {} while (0)
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_PROFILE */
multiline_comment|/*&n; * Allocate memory for a channel program with &squot;cplength&squot; channel&n; * command words and &squot;datasize&squot; additional space. There are two&n; * variantes: 1) dasd_kmalloc_request uses kmalloc to get the needed&n; * memory and 2) dasd_smalloc_request uses the static ccw memory&n; * that gets allocated for each device.&n; */
id|dasd_ccw_req_t
op_star
DECL|function|dasd_kmalloc_request
id|dasd_kmalloc_request
c_func
(paren
r_char
op_star
id|magic
comma
r_int
id|cplength
comma
r_int
id|datasize
comma
id|dasd_device_t
op_star
id|device
)paren
(brace
id|dasd_ccw_req_t
op_star
id|cqr
suffix:semicolon
multiline_comment|/* Sanity checks */
r_if
c_cond
(paren
id|magic
op_eq
l_int|NULL
op_logical_or
id|datasize
OG
id|PAGE_SIZE
op_logical_or
(paren
id|cplength
op_star
r_sizeof
(paren
id|ccw1_t
)paren
)paren
OG
id|PAGE_SIZE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|debug_text_event
(paren
id|dasd_debug_area
comma
l_int|1
comma
l_string|&quot;ALLC&quot;
)paren
suffix:semicolon
id|debug_text_event
(paren
id|dasd_debug_area
comma
l_int|1
comma
id|magic
)paren
suffix:semicolon
id|debug_int_event
(paren
id|dasd_debug_area
comma
l_int|1
comma
id|cplength
)paren
suffix:semicolon
id|debug_int_event
(paren
id|dasd_debug_area
comma
l_int|1
comma
id|datasize
)paren
suffix:semicolon
id|cqr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|dasd_ccw_req_t
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr
op_eq
l_int|NULL
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cqr
comma
l_int|0
comma
r_sizeof
(paren
id|dasd_ccw_req_t
)paren
)paren
suffix:semicolon
id|cqr-&gt;cpaddr
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cplength
OG
l_int|0
)paren
(brace
id|cqr-&gt;cpaddr
op_assign
id|kmalloc
c_func
(paren
id|cplength
op_star
r_sizeof
(paren
id|ccw1_t
)paren
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;cpaddr
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|cqr
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|cqr-&gt;cpaddr
comma
l_int|0
comma
id|cplength
op_star
r_sizeof
(paren
id|ccw1_t
)paren
)paren
suffix:semicolon
)brace
id|cqr-&gt;data
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|datasize
OG
l_int|0
)paren
(brace
id|cqr-&gt;data
op_assign
id|kmalloc
c_func
(paren
id|datasize
comma
id|GFP_ATOMIC
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;data
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|cqr-&gt;cpaddr
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|cqr-&gt;cpaddr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|cqr
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|cqr-&gt;data
comma
l_int|0
comma
id|datasize
)paren
suffix:semicolon
)brace
id|strncpy
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|cqr-&gt;magic
comma
id|magic
comma
l_int|4
)paren
suffix:semicolon
id|ASCEBC
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|cqr-&gt;magic
comma
l_int|4
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|device-&gt;ref_count
)paren
suffix:semicolon
r_return
id|cqr
suffix:semicolon
)brace
id|dasd_ccw_req_t
op_star
DECL|function|dasd_smalloc_request
id|dasd_smalloc_request
c_func
(paren
r_char
op_star
id|magic
comma
r_int
id|cplength
comma
r_int
id|datasize
comma
id|dasd_device_t
op_star
id|device
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|dasd_ccw_req_t
op_star
id|cqr
suffix:semicolon
r_char
op_star
id|data
suffix:semicolon
r_int
id|size
suffix:semicolon
multiline_comment|/* Sanity checks */
r_if
c_cond
(paren
id|magic
op_eq
l_int|NULL
op_logical_or
id|datasize
OG
id|PAGE_SIZE
op_logical_or
(paren
id|cplength
op_star
r_sizeof
(paren
id|ccw1_t
)paren
)paren
OG
id|PAGE_SIZE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|debug_text_event
(paren
id|dasd_debug_area
comma
l_int|1
comma
l_string|&quot;ALLC&quot;
)paren
suffix:semicolon
id|debug_text_event
(paren
id|dasd_debug_area
comma
l_int|1
comma
id|magic
)paren
suffix:semicolon
id|debug_int_event
(paren
id|dasd_debug_area
comma
l_int|1
comma
id|cplength
)paren
suffix:semicolon
id|debug_int_event
(paren
id|dasd_debug_area
comma
l_int|1
comma
id|datasize
)paren
suffix:semicolon
id|size
op_assign
(paren
r_sizeof
(paren
id|dasd_ccw_req_t
)paren
op_plus
l_int|7L
)paren
op_amp
op_minus
l_int|8L
suffix:semicolon
r_if
c_cond
(paren
id|cplength
OG
l_int|0
)paren
id|size
op_add_assign
id|cplength
op_star
r_sizeof
(paren
id|ccw1_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|datasize
OG
l_int|0
)paren
id|size
op_add_assign
id|datasize
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|device-&gt;mem_lock
comma
id|flags
)paren
suffix:semicolon
id|cqr
op_assign
(paren
id|dasd_ccw_req_t
op_star
)paren
id|dasd_alloc_chunk
c_func
(paren
op_amp
id|device-&gt;ccw_chunks
comma
id|size
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device-&gt;mem_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr
op_eq
l_int|NULL
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cqr
comma
l_int|0
comma
r_sizeof
(paren
id|dasd_ccw_req_t
)paren
)paren
suffix:semicolon
id|data
op_assign
(paren
r_char
op_star
)paren
id|cqr
op_plus
(paren
(paren
r_sizeof
(paren
id|dasd_ccw_req_t
)paren
op_plus
l_int|7L
)paren
op_amp
op_minus
l_int|8L
)paren
suffix:semicolon
id|cqr-&gt;cpaddr
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cplength
OG
l_int|0
)paren
(brace
id|cqr-&gt;cpaddr
op_assign
(paren
id|ccw1_t
op_star
)paren
id|data
suffix:semicolon
id|data
op_add_assign
id|cplength
op_star
r_sizeof
(paren
id|ccw1_t
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cqr-&gt;cpaddr
comma
l_int|0
comma
id|cplength
op_star
r_sizeof
(paren
id|ccw1_t
)paren
)paren
suffix:semicolon
)brace
id|cqr-&gt;data
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|datasize
OG
l_int|0
)paren
(brace
id|cqr-&gt;data
op_assign
id|data
suffix:semicolon
id|memset
c_func
(paren
id|cqr-&gt;data
comma
l_int|0
comma
id|datasize
)paren
suffix:semicolon
)brace
id|strncpy
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|cqr-&gt;magic
comma
id|magic
comma
l_int|4
)paren
suffix:semicolon
id|ASCEBC
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|cqr-&gt;magic
comma
l_int|4
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|device-&gt;ref_count
)paren
suffix:semicolon
r_return
id|cqr
suffix:semicolon
)brace
multiline_comment|/*&n; * Free memory of a channel program. This function needs to free all the&n; * idal lists that might have been created by dasd_set_cda and the&n; * dasd_ccw_req_t itself.&n; */
r_void
DECL|function|dasd_kfree_request
id|dasd_kfree_request
c_func
(paren
id|dasd_ccw_req_t
op_star
id|cqr
comma
id|dasd_device_t
op_star
id|device
)paren
(brace
macro_line|#ifdef CONFIG_ARCH_S390X
id|ccw1_t
op_star
id|ccw
suffix:semicolon
multiline_comment|/* Clear any idals used for the request. */
id|ccw
op_assign
id|cqr-&gt;cpaddr
suffix:semicolon
r_do
(brace
id|clear_normalized_cda
c_func
(paren
id|ccw
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ccw
op_increment
op_member_access_from_pointer
id|flags
op_amp
(paren
id|CCW_FLAG_CC
op_or
id|CCW_FLAG_DC
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cqr-&gt;dstat
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|cqr-&gt;dstat
)paren
suffix:semicolon
id|debug_text_event
(paren
id|dasd_debug_area
comma
l_int|1
comma
l_string|&quot;FREE&quot;
)paren
suffix:semicolon
id|debug_int_event
(paren
id|dasd_debug_area
comma
l_int|1
comma
(paren
r_int
)paren
id|cqr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;cpaddr
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|cqr-&gt;cpaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;data
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|cqr-&gt;data
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|cqr
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|device-&gt;ref_count
)paren
suffix:semicolon
)brace
r_void
DECL|function|dasd_sfree_request
id|dasd_sfree_request
c_func
(paren
id|dasd_ccw_req_t
op_star
id|cqr
comma
id|dasd_device_t
op_star
id|device
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;dstat
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|cqr-&gt;dstat
)paren
suffix:semicolon
id|debug_text_event
c_func
(paren
id|dasd_debug_area
comma
l_int|1
comma
l_string|&quot;FREE&quot;
)paren
suffix:semicolon
id|debug_int_event
c_func
(paren
id|dasd_debug_area
comma
l_int|1
comma
(paren
r_int
)paren
id|cqr
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|device-&gt;mem_lock
comma
id|flags
)paren
suffix:semicolon
id|dasd_free_chunk
c_func
(paren
op_amp
id|device-&gt;ccw_chunks
comma
id|cqr
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device-&gt;mem_lock
comma
id|flags
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|device-&gt;ref_count
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Check discipline magic in cqr.&n; */
r_static
r_inline
r_int
DECL|function|dasd_check_cqr
id|dasd_check_cqr
c_func
(paren
id|dasd_ccw_req_t
op_star
id|cqr
)paren
(brace
id|dasd_device_t
op_star
id|device
suffix:semicolon
r_if
c_cond
(paren
id|cqr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|device
op_assign
id|cqr-&gt;device
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|cqr-&gt;magic
comma
id|device-&gt;discipline-&gt;ebcname
comma
l_int|4
)paren
)paren
(brace
id|DEV_MESSAGE
c_func
(paren
id|KERN_WARNING
comma
id|device
comma
l_string|&quot; dasd_ccw_req_t 0x%08x magic doesn&squot;t match&quot;
l_string|&quot; discipline 0x%08x&quot;
comma
id|cqr-&gt;magic
comma
op_star
(paren
r_int
r_int
op_star
)paren
id|device-&gt;discipline-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Terminate the current i/o and set the request to failed.&n; * halt_IO/clear_IO can fail if the i/o subsystem is in a bad mood.&n; */
r_int
DECL|function|dasd_term_IO
id|dasd_term_IO
c_func
(paren
id|dasd_ccw_req_t
op_star
id|cqr
)paren
(brace
id|dasd_device_t
op_star
id|device
suffix:semicolon
r_int
id|retries
comma
id|rc
suffix:semicolon
multiline_comment|/* Check the cqr */
id|rc
op_assign
id|dasd_check_cqr
c_func
(paren
id|cqr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|retries
op_assign
l_int|0
suffix:semicolon
id|device
op_assign
(paren
id|dasd_device_t
op_star
)paren
id|cqr-&gt;device
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retries
OL
l_int|5
)paren
op_logical_and
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_IN_IO
)paren
)paren
(brace
r_if
c_cond
(paren
id|retries
OL
l_int|2
)paren
id|rc
op_assign
id|halt_IO
c_func
(paren
id|device-&gt;devinfo.irq
comma
(paren
r_int
)paren
id|cqr
comma
id|cqr-&gt;options
)paren
suffix:semicolon
r_else
id|rc
op_assign
id|clear_IO
c_func
(paren
id|device-&gt;devinfo.irq
comma
(paren
r_int
)paren
id|cqr
comma
id|cqr-&gt;options
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|rc
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* termination successful */
id|cqr-&gt;status
op_assign
id|DASD_CQR_FAILED
suffix:semicolon
id|cqr-&gt;stopclk
op_assign
id|get_clock
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|ENODEV
suffix:colon
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_ERR
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;device gone, retry&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|EIO
suffix:colon
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_ERR
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;I/O error, retry&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|EBUSY
suffix:colon
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_ERR
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;device busy, retry later&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEV_MESSAGE
c_func
(paren
id|KERN_ERR
comma
id|device
comma
l_string|&quot;line %d unknown RC=%d, please &quot;
l_string|&quot;report to linux390@de.ibm.com&quot;
comma
id|__LINE__
comma
id|rc
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Start the i/o. This start_IO can fail if the channel is really busy.&n; * In that case set up a timer to start the request later.&n; */
r_int
DECL|function|dasd_start_IO
id|dasd_start_IO
c_func
(paren
id|dasd_ccw_req_t
op_star
id|cqr
)paren
(brace
id|dasd_device_t
op_star
id|device
suffix:semicolon
r_int
id|rc
suffix:semicolon
multiline_comment|/* Check the cqr */
id|rc
op_assign
id|dasd_check_cqr
c_func
(paren
id|cqr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|device
op_assign
(paren
id|dasd_device_t
op_star
)paren
id|cqr-&gt;device
suffix:semicolon
id|cqr-&gt;startclk
op_assign
id|get_clock
c_func
(paren
)paren
suffix:semicolon
id|rc
op_assign
id|do_IO
c_func
(paren
id|device-&gt;devinfo.irq
comma
id|cqr-&gt;cpaddr
comma
(paren
r_int
)paren
id|cqr
comma
id|cqr-&gt;lpm
comma
id|cqr-&gt;options
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|rc
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|cqr-&gt;options
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
(brace
multiline_comment|/* request already finished (synchronous IO) */
id|cqr-&gt;status
op_assign
id|DASD_CQR_DONE
suffix:semicolon
id|cqr-&gt;stopclk
op_assign
id|cqr-&gt;startclk
suffix:semicolon
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
r_else
id|cqr-&gt;status
op_assign
id|DASD_CQR_IN_IO
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|EBUSY
suffix:colon
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_ERR
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;device busy, retry later&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|ETIMEDOUT
suffix:colon
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_ERR
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;request timeout - terminated&quot;
)paren
suffix:semicolon
r_case
op_minus
id|ENODEV
suffix:colon
r_case
op_minus
id|EIO
suffix:colon
id|cqr-&gt;status
op_assign
id|DASD_CQR_FAILED
suffix:semicolon
id|cqr-&gt;stopclk
op_assign
id|cqr-&gt;startclk
suffix:semicolon
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DEV_MESSAGE
c_func
(paren
id|KERN_ERR
comma
id|device
comma
l_string|&quot;line %d unknown RC=%d, please report&quot;
l_string|&quot; to linux390@de.ibm.com&quot;
comma
id|__LINE__
comma
id|rc
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Timeout function for dasd devices. This is used for different purposes&n; *  1) missing interrupt handler for normal operation&n; *  2) delayed start of request where start_IO failed with -EBUSY&n; *  3) timeout for missing state change interrupts&n; * The head of the ccw queue will have status DASD_CQR_IN_IO for 1),&n; * DASD_CQR_QUEUED for 2) and DASD_CQR_PENDING for 3).&n; */
r_static
r_void
DECL|function|dasd_timeout_device
id|dasd_timeout_device
c_func
(paren
r_int
r_int
id|ptr
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|dasd_device_t
op_star
id|device
suffix:semicolon
id|dasd_ccw_req_t
op_star
id|cqr
suffix:semicolon
id|device
op_assign
(paren
id|dasd_device_t
op_star
)paren
id|ptr
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* re-activate first request in queue */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|device-&gt;ccw_queue
)paren
)paren
(brace
id|cqr
op_assign
id|list_entry
c_func
(paren
id|device-&gt;ccw_queue.next
comma
id|dasd_ccw_req_t
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_PENDING
)paren
id|cqr-&gt;status
op_assign
id|DASD_CQR_QUEUED
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
comma
id|flags
)paren
suffix:semicolon
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Setup timeout for a device.&n; */
r_void
DECL|function|dasd_set_timer
id|dasd_set_timer
c_func
(paren
id|dasd_device_t
op_star
id|device
comma
r_int
id|expires
)paren
(brace
multiline_comment|/* FIXME: timeouts are based on jiffies but the timeout&n;&t; * comparision in __dasd_check_expire is based on the&n;&t; * TOD clock. */
r_if
c_cond
(paren
id|expires
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|timer_pending
c_func
(paren
op_amp
id|device-&gt;timer
)paren
)paren
(brace
id|device-&gt;timer.function
op_assign
id|dasd_timeout_device
suffix:semicolon
id|device-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|device
suffix:semicolon
id|device-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|expires
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|device-&gt;timer
)paren
suffix:semicolon
)brace
r_else
id|mod_timer
c_func
(paren
op_amp
id|device-&gt;timer
comma
id|jiffies
op_plus
id|expires
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|device-&gt;timer
)paren
)paren
id|del_timer
c_func
(paren
op_amp
id|device-&gt;timer
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Clear timeout for a device.&n; */
r_void
DECL|function|dasd_clear_timer
id|dasd_clear_timer
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|device-&gt;timer
)paren
)paren
id|del_timer
c_func
(paren
op_amp
id|device-&gt;timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *   Handles the state change pending interrupt.&n; *   Search for the device related request queue and check if the first&n; *   cqr in queue in in status &squot;DASD_CQR_PENDING&squot;.&n; *   If so the status is set to &squot;DASD_CQR_QUEUED&squot; to reactivate&n; *   the device.&n; */
r_static
r_void
DECL|function|do_state_change_pending
id|do_state_change_pending
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
(brace
r_struct
id|tq_struct
id|tq
suffix:semicolon
r_int
r_int
id|devno
suffix:semicolon
)brace
op_star
id|p
suffix:semicolon
id|dasd_devmap_t
op_star
id|devmap
suffix:semicolon
id|dasd_device_t
op_star
id|device
suffix:semicolon
id|dasd_ccw_req_t
op_star
id|cqr
suffix:semicolon
id|p
op_assign
id|data
suffix:semicolon
id|DBF_EVENT
c_func
(paren
id|DBF_NOTICE
comma
l_string|&quot;State change Interrupt: %04x&quot;
comma
id|p-&gt;devno
)paren
suffix:semicolon
id|devmap
op_assign
id|dasd_devmap_from_devno
c_func
(paren
id|p-&gt;devno
)paren
suffix:semicolon
id|device
op_assign
(paren
id|devmap
op_ne
l_int|NULL
)paren
ques
c_cond
id|dasd_get_device
c_func
(paren
id|devmap
)paren
suffix:colon
id|ERR_PTR
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|device
)paren
)paren
(brace
id|MESSAGE
c_func
(paren
id|KERN_DEBUG
comma
l_string|&quot;unable to find device for state change pending &quot;
l_string|&quot;interrupt: devno%04x&quot;
comma
id|p-&gt;devno
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock_irq
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
)paren
suffix:semicolon
multiline_comment|/* re-activate first request in queue */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|device-&gt;ccw_queue
)paren
)paren
(brace
id|cqr
op_assign
id|list_entry
c_func
(paren
id|device-&gt;ccw_queue.next
comma
id|dasd_ccw_req_t
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_PENDING
)paren
id|cqr-&gt;status
op_assign
id|DASD_CQR_QUEUED
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
)paren
suffix:semicolon
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
id|dasd_put_device
c_func
(paren
id|devmap
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|dasd_handle_state_change_pending
id|dasd_handle_state_change_pending
c_func
(paren
id|devstat_t
op_star
id|stat
)paren
(brace
r_struct
(brace
r_struct
id|tq_struct
id|tq
suffix:semicolon
r_int
r_int
id|devno
suffix:semicolon
)brace
op_star
id|p
suffix:semicolon
id|p
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|p
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
multiline_comment|/* No memory, let the timeout do the reactivation. */
r_return
suffix:semicolon
id|p-&gt;tq.routine
op_assign
(paren
r_void
op_star
)paren
id|do_state_change_pending
suffix:semicolon
id|p-&gt;tq.data
op_assign
(paren
r_void
op_star
)paren
id|p
suffix:semicolon
id|p-&gt;devno
op_assign
id|stat-&gt;devno
suffix:semicolon
multiline_comment|/* queue call to do_state_change_pending to the kernel event daemon. */
id|schedule_task
c_func
(paren
op_amp
id|p-&gt;tq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Interrupt handler for &quot;normal&quot; ssch-io based dasd devices.&n; */
r_void
DECL|function|dasd_int_handler
id|dasd_int_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|ds
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|dasd_ccw_req_t
op_star
id|cqr
comma
op_star
id|next
suffix:semicolon
id|dasd_device_t
op_star
id|device
suffix:semicolon
r_int
r_int
r_int
id|now
suffix:semicolon
r_int
id|expires
suffix:semicolon
id|dasd_era_t
id|era
suffix:semicolon
id|devstat_t
op_star
id|stat
suffix:semicolon
r_char
id|mask
suffix:semicolon
id|now
op_assign
id|get_clock
c_func
(paren
)paren
suffix:semicolon
id|stat
op_assign
(paren
id|devstat_t
op_star
)paren
id|ds
suffix:semicolon
id|DBF_EVENT
c_func
(paren
id|DBF_DEBUG
comma
l_string|&quot;Interrupt: IRQ %02x, stat %02x, devno %04x&quot;
comma
id|irq
comma
id|stat-&gt;dstat
comma
id|stat-&gt;devno
)paren
suffix:semicolon
multiline_comment|/* first of all check for state change pending interrupt */
id|mask
op_assign
id|DEV_STAT_ATTENTION
op_or
id|DEV_STAT_DEV_END
op_or
id|DEV_STAT_UNIT_EXCEP
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat-&gt;dstat
op_amp
id|mask
)paren
op_eq
id|mask
)paren
(brace
id|dasd_handle_state_change_pending
c_func
(paren
id|stat
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stat-&gt;intparm
op_eq
l_int|0
)paren
(brace
multiline_comment|/* no intparm: unsolicited interrupt */
id|MESSAGE
c_func
(paren
id|KERN_DEBUG
comma
l_string|&quot;unsolicited interrupt: irq 0x%x devno %04x&quot;
comma
id|irq
comma
id|stat-&gt;devno
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|cqr
op_assign
(paren
id|dasd_ccw_req_t
op_star
)paren
(paren
r_int
r_int
)paren
id|stat-&gt;intparm
suffix:semicolon
multiline_comment|/*&n;&t; * check status - the request might have been killed&n;&t; * because of dyn detach&n;&t; */
r_if
c_cond
(paren
id|cqr-&gt;status
op_ne
id|DASD_CQR_IN_IO
)paren
(brace
id|MESSAGE
c_func
(paren
id|KERN_DEBUG
comma
l_string|&quot;invalid status: irq 0x%x devno %04x, status %02x&quot;
comma
id|irq
comma
id|stat-&gt;devno
comma
id|cqr-&gt;status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|device
op_assign
(paren
id|dasd_device_t
op_star
)paren
id|cqr-&gt;device
suffix:semicolon
r_if
c_cond
(paren
id|device
op_eq
l_int|NULL
op_logical_or
id|device
op_ne
id|ds
op_minus
m_offsetof
(paren
id|dasd_device_t
comma
id|dev_status
)paren
op_logical_or
id|device-&gt;devinfo.irq
op_ne
id|irq
op_logical_or
id|strncmp
c_func
(paren
id|device-&gt;discipline-&gt;ebcname
comma
(paren
r_char
op_star
)paren
op_amp
id|cqr-&gt;magic
comma
l_int|4
)paren
)paren
(brace
id|MESSAGE
c_func
(paren
id|KERN_DEBUG
comma
l_string|&quot;invalid device in request: irq 0x%x devno %04x&quot;
comma
id|irq
comma
id|stat-&gt;devno
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_DEBUG
comma
id|device
comma
l_string|&quot;Int: CS/DS 0x%04x&quot;
comma
(paren
(paren
id|stat-&gt;cstat
op_lshift
l_int|8
)paren
op_or
id|stat-&gt;dstat
)paren
)paren
suffix:semicolon
multiline_comment|/* Find out the appropriate era_action. */
id|era
op_assign
id|dasd_era_none
suffix:semicolon
r_if
c_cond
(paren
id|stat-&gt;flag
op_amp
id|DEVSTAT_FLAG_SENSE_AVAIL
op_logical_or
id|stat-&gt;dstat
op_amp
op_complement
(paren
id|DEV_STAT_CHN_END
op_or
id|DEV_STAT_DEV_END
)paren
)paren
(brace
multiline_comment|/* The request did end abnormally. */
r_if
c_cond
(paren
id|stat-&gt;flag
op_amp
id|DEVSTAT_HALT_FUNCTION
)paren
id|era
op_assign
id|dasd_era_fatal
suffix:semicolon
r_else
id|era
op_assign
id|device-&gt;discipline
op_member_access_from_pointer
id|examine_error
c_func
(paren
id|cqr
comma
id|stat
)paren
suffix:semicolon
id|DBF_EVENT
c_func
(paren
id|DBF_NOTICE
comma
l_string|&quot;era_code %d&quot;
comma
id|era
)paren
suffix:semicolon
)brace
id|expires
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|era
op_eq
id|dasd_era_none
)paren
(brace
id|cqr-&gt;status
op_assign
id|DASD_CQR_DONE
suffix:semicolon
id|cqr-&gt;stopclk
op_assign
id|now
suffix:semicolon
multiline_comment|/* Start first request on queue if possible -&gt; fast_io. */
r_if
c_cond
(paren
id|cqr-&gt;list.next
op_ne
op_amp
id|device-&gt;ccw_queue
)paren
(brace
id|next
op_assign
id|list_entry
c_func
(paren
id|cqr-&gt;list.next
comma
id|dasd_ccw_req_t
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next-&gt;status
op_eq
id|DASD_CQR_QUEUED
)paren
(brace
r_if
c_cond
(paren
id|device-&gt;discipline
op_member_access_from_pointer
id|start_IO
c_func
(paren
id|next
)paren
op_eq
l_int|0
)paren
id|expires
op_assign
id|next-&gt;expires
suffix:semicolon
r_else
id|MESSAGE
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;Interrupt fastpath failed!&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* error */
r_if
c_cond
(paren
id|cqr-&gt;dstat
op_eq
l_int|NULL
)paren
id|cqr-&gt;dstat
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|devstat_t
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;dstat
)paren
id|memcpy
c_func
(paren
id|cqr-&gt;dstat
comma
id|stat
comma
r_sizeof
(paren
id|devstat_t
)paren
)paren
suffix:semicolon
r_else
id|MESSAGE
c_func
(paren
id|KERN_ERR
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;no memory for dstat...ignoring&quot;
)paren
suffix:semicolon
macro_line|#ifdef ERP_DEBUG
multiline_comment|/* dump sense data */
r_if
c_cond
(paren
id|device-&gt;discipline
op_logical_and
id|device-&gt;discipline-&gt;dump_sense
)paren
id|device-&gt;discipline
op_member_access_from_pointer
id|dump_sense
c_func
(paren
id|device
comma
id|cqr
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|era
)paren
(brace
r_case
id|dasd_era_fatal
suffix:colon
id|cqr-&gt;status
op_assign
id|DASD_CQR_FAILED
suffix:semicolon
id|cqr-&gt;stopclk
op_assign
id|now
suffix:semicolon
r_break
suffix:semicolon
r_case
id|dasd_era_recover
suffix:colon
id|cqr-&gt;status
op_assign
id|DASD_CQR_ERROR
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|expires
op_ne
l_int|0
)paren
id|dasd_set_timer
c_func
(paren
id|device
comma
id|expires
)paren
suffix:semicolon
r_else
id|dasd_clear_timer
c_func
(paren
id|device
)paren
suffix:semicolon
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * posts the buffer_cache about a finalized request&n; */
r_static
r_inline
r_void
DECL|function|dasd_end_request
id|dasd_end_request
c_func
(paren
r_struct
id|request
op_star
id|req
comma
r_int
id|uptodate
)paren
(brace
r_if
c_cond
(paren
id|end_that_request_first
c_func
(paren
id|req
comma
id|uptodate
comma
id|req-&gt;hard_nr_sectors
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|add_blkdev_randomness
c_func
(paren
id|major
c_func
(paren
id|req-&gt;rq_dev
)paren
)paren
suffix:semicolon
id|end_that_request_last
c_func
(paren
id|req
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Process finished error recovery ccw.&n; */
r_static
r_inline
r_void
DECL|function|__dasd_process_erp
id|__dasd_process_erp
c_func
(paren
id|dasd_device_t
op_star
id|device
comma
id|dasd_ccw_req_t
op_star
id|cqr
)paren
(brace
id|dasd_erp_fn_t
id|erp_fn
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_DONE
)paren
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_NOTICE
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;ERP successful&quot;
)paren
suffix:semicolon
r_else
id|DEV_MESSAGE
c_func
(paren
id|KERN_ERR
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;ERP unsuccessful&quot;
)paren
suffix:semicolon
id|erp_fn
op_assign
id|device-&gt;discipline
op_member_access_from_pointer
id|erp_postaction
c_func
(paren
id|cqr
)paren
suffix:semicolon
id|erp_fn
c_func
(paren
id|cqr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Process ccw request queue.&n; */
r_static
r_inline
r_void
DECL|function|__dasd_process_ccw_queue
id|__dasd_process_ccw_queue
c_func
(paren
id|dasd_device_t
op_star
id|device
comma
r_struct
id|list_head
op_star
id|final_queue
)paren
(brace
r_struct
id|list_head
op_star
id|l
comma
op_star
id|n
suffix:semicolon
id|dasd_ccw_req_t
op_star
id|cqr
suffix:semicolon
id|dasd_erp_fn_t
id|erp_fn
suffix:semicolon
id|restart
suffix:colon
multiline_comment|/* Process request with final status. */
id|list_for_each_safe
c_func
(paren
id|l
comma
id|n
comma
op_amp
id|device-&gt;ccw_queue
)paren
(brace
id|cqr
op_assign
id|list_entry
c_func
(paren
id|l
comma
id|dasd_ccw_req_t
comma
id|list
)paren
suffix:semicolon
multiline_comment|/* Stop list processing at the first non-final request. */
r_if
c_cond
(paren
id|cqr-&gt;status
op_ne
id|DASD_CQR_DONE
op_logical_and
id|cqr-&gt;status
op_ne
id|DASD_CQR_FAILED
op_logical_and
id|cqr-&gt;status
op_ne
id|DASD_CQR_ERROR
)paren
r_break
suffix:semicolon
multiline_comment|/*  Process requests with DASD_CQR_ERROR */
r_if
c_cond
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_ERROR
)paren
(brace
id|cqr-&gt;retries
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;dstat-&gt;flag
op_amp
id|DEVSTAT_HALT_FUNCTION
)paren
(brace
id|cqr-&gt;status
op_assign
id|DASD_CQR_FAILED
suffix:semicolon
id|cqr-&gt;stopclk
op_assign
id|get_clock
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|erp_fn
op_assign
id|device-&gt;discipline
op_member_access_from_pointer
id|erp_action
c_func
(paren
id|cqr
)paren
suffix:semicolon
id|erp_fn
c_func
(paren
id|cqr
)paren
suffix:semicolon
)brace
r_goto
id|restart
suffix:semicolon
)brace
multiline_comment|/* Process finished ERP request. */
r_if
c_cond
(paren
id|cqr-&gt;refers
)paren
(brace
id|__dasd_process_erp
c_func
(paren
id|device
comma
id|cqr
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
multiline_comment|/* Rechain request on device device request queue */
id|cqr-&gt;endclk
op_assign
id|get_clock
c_func
(paren
)paren
suffix:semicolon
id|list_move_tail
c_func
(paren
op_amp
id|cqr-&gt;list
comma
id|final_queue
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|dasd_end_request_cb
id|dasd_end_request_cb
c_func
(paren
id|dasd_ccw_req_t
op_star
id|cqr
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|request
op_star
id|req
suffix:semicolon
id|req
op_assign
(paren
r_struct
id|request
op_star
)paren
id|data
suffix:semicolon
id|dasd_profile_end
c_func
(paren
id|cqr-&gt;device
comma
id|cqr
comma
id|req
)paren
suffix:semicolon
id|dasd_end_request
c_func
(paren
id|req
comma
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_DONE
)paren
)paren
suffix:semicolon
id|dasd_sfree_request
c_func
(paren
id|cqr
comma
id|cqr-&gt;device
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Fetch requests from the block device queue.&n; */
r_static
r_inline
r_void
DECL|function|__dasd_process_blk_queue
id|__dasd_process_blk_queue
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
id|request_queue_t
op_star
id|queue
suffix:semicolon
r_struct
id|list_head
op_star
id|l
suffix:semicolon
r_struct
id|request
op_star
id|req
suffix:semicolon
id|dasd_ccw_req_t
op_star
id|cqr
suffix:semicolon
r_int
id|nr_queued
suffix:semicolon
id|queue
op_assign
id|device-&gt;request_queue
suffix:semicolon
multiline_comment|/* No queue ? Then there is nothing to do. */
r_if
c_cond
(paren
id|queue
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * We requeue request from the block device queue to the ccw&n;&t; * queue only in two states. In state DASD_STATE_ACCEPT the&n;&t; * partition detection is done and we need to requeue requests&n;&t; * for that. State DASD_STATE_ONLINE is normal block device&n;&t; * operation.&n;&t; */
r_if
c_cond
(paren
id|device-&gt;state
op_ne
id|DASD_STATE_ACCEPT
op_logical_and
id|device-&gt;state
op_ne
id|DASD_STATE_ONLINE
)paren
r_return
suffix:semicolon
id|nr_queued
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Now we try to fetch requests from the request queue */
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|device-&gt;ccw_queue
)paren
(brace
id|cqr
op_assign
id|list_entry
c_func
(paren
id|l
comma
id|dasd_ccw_req_t
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_QUEUED
)paren
id|nr_queued
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|blk_queue_plugged
c_func
(paren
id|queue
)paren
op_logical_and
op_logical_neg
id|blk_queue_empty
c_func
(paren
id|queue
)paren
op_logical_and
id|nr_queued
OL
id|DASD_CHANQ_MAX_SIZE
)paren
(brace
id|req
op_assign
id|elv_next_request
c_func
(paren
id|queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;ro_flag
op_logical_and
id|rq_data_dir
c_func
(paren
id|req
)paren
op_eq
id|WRITE
)paren
(brace
id|DBF_EVENT
c_func
(paren
id|DBF_ERR
comma
l_string|&quot;(%04x) Rejecting write request %p&quot;
comma
id|device-&gt;devinfo.devno
comma
id|req
)paren
suffix:semicolon
id|blkdev_dequeue_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|dasd_end_request
c_func
(paren
id|req
comma
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|cqr
op_assign
id|device-&gt;discipline
op_member_access_from_pointer
id|build_cp
c_func
(paren
id|device
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|cqr
)paren
)paren
(brace
r_if
c_cond
(paren
id|PTR_ERR
c_func
(paren
id|cqr
)paren
op_eq
op_minus
id|ENOMEM
)paren
r_break
suffix:semicolon
multiline_comment|/* terminate request queue loop */
id|DBF_EVENT
c_func
(paren
id|DBF_ERR
comma
l_string|&quot;(%04x) CCW creation failed on request %p&quot;
comma
id|device-&gt;devinfo.devno
comma
id|req
)paren
suffix:semicolon
id|blkdev_dequeue_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|dasd_end_request
c_func
(paren
id|req
comma
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|cqr-&gt;callback
op_assign
id|dasd_end_request_cb
suffix:semicolon
id|cqr-&gt;callback_data
op_assign
(paren
r_void
op_star
)paren
id|req
suffix:semicolon
id|cqr-&gt;status
op_assign
id|DASD_CQR_QUEUED
suffix:semicolon
id|blkdev_dequeue_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|cqr-&gt;list
comma
op_amp
id|device-&gt;ccw_queue
)paren
suffix:semicolon
id|dasd_profile_start
c_func
(paren
id|device
comma
id|cqr
comma
id|req
)paren
suffix:semicolon
id|nr_queued
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Take a look at the first request on the ccw queue and check&n; * if it reached its expire time.&n; */
r_static
r_inline
r_void
DECL|function|__dasd_check_expire
id|__dasd_check_expire
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
id|dasd_ccw_req_t
op_star
id|cqr
suffix:semicolon
r_int
r_int
r_int
id|now
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|device-&gt;ccw_queue
)paren
)paren
r_return
suffix:semicolon
id|cqr
op_assign
id|list_entry
c_func
(paren
id|device-&gt;ccw_queue.next
comma
id|dasd_ccw_req_t
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_IN_IO
op_logical_and
id|cqr-&gt;expires
op_ne
l_int|0
)paren
(brace
id|now
op_assign
id|get_clock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;expires
op_star
(paren
id|TOD_SEC
op_div
id|HZ
)paren
op_plus
id|cqr-&gt;startclk
OL
id|now
)paren
(brace
r_if
c_cond
(paren
id|device-&gt;discipline
op_member_access_from_pointer
id|term_IO
c_func
(paren
id|cqr
)paren
op_ne
l_int|0
)paren
multiline_comment|/* Hmpf, try again in 1/100 sec */
id|dasd_set_timer
c_func
(paren
id|device
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Take a look at the first request on the ccw queue and check&n; * if it needs to be started.&n; */
r_static
r_inline
r_void
DECL|function|__dasd_start_head
id|__dasd_start_head
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
id|dasd_ccw_req_t
op_star
id|cqr
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|device-&gt;ccw_queue
)paren
)paren
r_return
suffix:semicolon
id|cqr
op_assign
id|list_entry
c_func
(paren
id|device-&gt;ccw_queue.next
comma
id|dasd_ccw_req_t
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_QUEUED
)paren
(brace
multiline_comment|/* try to start the first I/O that can be started */
id|rc
op_assign
id|device-&gt;discipline
op_member_access_from_pointer
id|start_IO
c_func
(paren
id|cqr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
id|dasd_set_timer
c_func
(paren
id|device
comma
id|cqr-&gt;expires
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rc
op_eq
op_minus
id|EBUSY
)paren
multiline_comment|/* Hmpf, try again in 1/100 sec */
id|dasd_set_timer
c_func
(paren
id|device
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Remove requests from the ccw queue. &n; */
r_static
r_void
DECL|function|dasd_flush_ccw_queue
id|dasd_flush_ccw_queue
c_func
(paren
id|dasd_device_t
op_star
id|device
comma
r_int
id|all
)paren
(brace
r_struct
id|list_head
id|flush_queue
suffix:semicolon
r_struct
id|list_head
op_star
id|l
comma
op_star
id|n
suffix:semicolon
id|dasd_ccw_req_t
op_star
id|cqr
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|flush_queue
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|l
comma
id|n
comma
op_amp
id|device-&gt;ccw_queue
)paren
(brace
id|cqr
op_assign
id|list_entry
c_func
(paren
id|l
comma
id|dasd_ccw_req_t
comma
id|list
)paren
suffix:semicolon
multiline_comment|/* Flush all request or only block device requests? */
r_if
c_cond
(paren
id|all
op_eq
l_int|0
op_logical_and
id|cqr-&gt;callback
op_eq
id|dasd_end_request_cb
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_IN_IO
)paren
id|device-&gt;discipline
op_member_access_from_pointer
id|term_IO
c_func
(paren
id|cqr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;status
op_ne
id|DASD_CQR_DONE
op_logical_or
id|cqr-&gt;status
op_ne
id|DASD_CQR_FAILED
)paren
(brace
id|cqr-&gt;status
op_assign
id|DASD_CQR_FAILED
suffix:semicolon
id|cqr-&gt;stopclk
op_assign
id|get_clock
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Process finished ERP request. */
r_if
c_cond
(paren
id|cqr-&gt;refers
)paren
(brace
id|__dasd_process_erp
c_func
(paren
id|device
comma
id|cqr
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Rechain request on device request queue */
id|cqr-&gt;endclk
op_assign
id|get_clock
c_func
(paren
)paren
suffix:semicolon
id|list_move_tail
c_func
(paren
op_amp
id|cqr-&gt;list
comma
op_amp
id|flush_queue
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
)paren
suffix:semicolon
multiline_comment|/* Now call the callback function of flushed requests */
id|list_for_each_safe
c_func
(paren
id|l
comma
id|n
comma
op_amp
id|flush_queue
)paren
(brace
id|cqr
op_assign
id|list_entry
c_func
(paren
id|l
comma
id|dasd_ccw_req_t
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;callback
op_ne
l_int|NULL
)paren
(paren
id|cqr-&gt;callback
)paren
(paren
id|cqr
comma
id|cqr-&gt;callback_data
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Acquire the device lock and process queues for the device.&n; */
r_static
r_void
DECL|function|dasd_tasklet
id|dasd_tasklet
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
r_struct
id|list_head
id|final_queue
suffix:semicolon
r_struct
id|list_head
op_star
id|l
comma
op_star
id|n
suffix:semicolon
id|dasd_ccw_req_t
op_star
id|cqr
suffix:semicolon
id|atomic_set
(paren
op_amp
id|device-&gt;tasklet_scheduled
comma
l_int|0
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|final_queue
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
)paren
suffix:semicolon
multiline_comment|/* Check expire time of first request on the ccw queue. */
id|__dasd_check_expire
c_func
(paren
id|device
)paren
suffix:semicolon
multiline_comment|/* Finish off requests on ccw queue */
id|__dasd_process_ccw_queue
c_func
(paren
id|device
comma
op_amp
id|final_queue
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
)paren
suffix:semicolon
multiline_comment|/* Now call the callback function of requests with final status */
id|list_for_each_safe
c_func
(paren
id|l
comma
id|n
comma
op_amp
id|final_queue
)paren
(brace
id|cqr
op_assign
id|list_entry
c_func
(paren
id|l
comma
id|dasd_ccw_req_t
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|cqr-&gt;list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;callback
op_ne
l_int|NULL
)paren
(paren
id|cqr-&gt;callback
)paren
(paren
id|cqr
comma
id|cqr-&gt;callback_data
)paren
suffix:semicolon
)brace
id|spin_lock_irq
c_func
(paren
op_amp
id|device-&gt;request_queue_lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
)paren
suffix:semicolon
multiline_comment|/* Get new request from the block device request queue */
id|__dasd_process_blk_queue
c_func
(paren
id|device
)paren
suffix:semicolon
multiline_comment|/* Now check if the head of the ccw queue needs to be started. */
id|__dasd_start_head
c_func
(paren
id|device
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|device-&gt;request_queue_lock
)paren
suffix:semicolon
multiline_comment|/* FIXME: what if ref_count == 0 &amp;&amp; state == DASD_STATE_NEW ?? */
id|atomic_dec
c_func
(paren
op_amp
id|device-&gt;ref_count
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Schedules a call to dasd_process_queues over the device tasklet.&n; */
r_void
DECL|function|dasd_schedule_bh
id|dasd_schedule_bh
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
multiline_comment|/* Protect against rescheduling. */
r_if
c_cond
(paren
id|atomic_compare_and_swap
(paren
l_int|0
comma
l_int|1
comma
op_amp
id|device-&gt;tasklet_scheduled
)paren
)paren
r_return
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|device-&gt;ref_count
)paren
suffix:semicolon
id|tasklet_hi_schedule
c_func
(paren
op_amp
id|device-&gt;tasklet
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Queue a request to the head of the ccw_queue. Start the I/O if&n; * possible.&n; */
r_void
DECL|function|dasd_add_request_head
id|dasd_add_request_head
c_func
(paren
id|dasd_ccw_req_t
op_star
id|req
)paren
(brace
id|dasd_device_t
op_star
id|device
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|device
op_assign
id|req-&gt;device
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
comma
id|flags
)paren
suffix:semicolon
id|req-&gt;status
op_assign
id|DASD_CQR_QUEUED
suffix:semicolon
id|req-&gt;device
op_assign
id|device
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|req-&gt;list
comma
op_amp
id|device-&gt;ccw_queue
)paren
suffix:semicolon
multiline_comment|/* let the bh start the request to keep them in order */
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Queue a request to the tail of the ccw_queue. Start the I/O if&n; * possible.&n; */
r_void
DECL|function|dasd_add_request_tail
id|dasd_add_request_tail
c_func
(paren
id|dasd_ccw_req_t
op_star
id|req
)paren
(brace
id|dasd_device_t
op_star
id|device
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|device
op_assign
id|req-&gt;device
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
comma
id|flags
)paren
suffix:semicolon
id|req-&gt;status
op_assign
id|DASD_CQR_QUEUED
suffix:semicolon
id|req-&gt;device
op_assign
id|device
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|req-&gt;list
comma
op_amp
id|device-&gt;ccw_queue
)paren
suffix:semicolon
multiline_comment|/* let the bh start the request to keep them in order */
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wakeup callback.&n; */
r_static
r_void
DECL|function|dasd_wakeup_cb
id|dasd_wakeup_cb
c_func
(paren
id|dasd_ccw_req_t
op_star
id|cqr
comma
r_void
op_star
id|data
)paren
(brace
id|wake_up
c_func
(paren
(paren
id|wait_queue_head_t
op_star
)paren
id|data
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|_wait_for_wakeup
id|_wait_for_wakeup
c_func
(paren
id|dasd_ccw_req_t
op_star
id|cqr
)paren
(brace
id|dasd_device_t
op_star
id|device
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|device
op_assign
id|cqr-&gt;device
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
)paren
suffix:semicolon
id|rc
op_assign
id|cqr-&gt;status
op_eq
id|DASD_CQR_DONE
op_logical_or
id|cqr-&gt;status
op_eq
id|DASD_CQR_FAILED
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Attempts to start a special ccw queue and waits for its completion.&n; */
r_int
DECL|function|dasd_sleep_on
id|dasd_sleep_on
c_func
(paren
id|dasd_ccw_req_t
op_star
id|cqr
)paren
(brace
id|wait_queue_head_t
id|wait_q
suffix:semicolon
id|dasd_device_t
op_star
id|device
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|device
op_assign
id|cqr-&gt;device
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
)paren
suffix:semicolon
id|init_waitqueue_head
(paren
op_amp
id|wait_q
)paren
suffix:semicolon
id|cqr-&gt;callback
op_assign
id|dasd_wakeup_cb
suffix:semicolon
id|cqr-&gt;callback_data
op_assign
(paren
r_void
op_star
)paren
op_amp
id|wait_q
suffix:semicolon
id|cqr-&gt;status
op_assign
id|DASD_CQR_QUEUED
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|cqr-&gt;list
comma
op_amp
id|device-&gt;ccw_queue
)paren
suffix:semicolon
multiline_comment|/* let the bh start the request to keep them in order */
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
)paren
suffix:semicolon
id|wait_event
c_func
(paren
id|wait_q
comma
id|_wait_for_wakeup
c_func
(paren
id|cqr
)paren
)paren
suffix:semicolon
multiline_comment|/* Request status is either done or failed. */
id|rc
op_assign
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_FAILED
)paren
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Attempts to start a special ccw queue and wait interruptible&n; * for its completion.&n; */
r_int
DECL|function|dasd_sleep_on_interruptible
id|dasd_sleep_on_interruptible
c_func
(paren
id|dasd_ccw_req_t
op_star
id|cqr
)paren
(brace
id|wait_queue_head_t
id|wait_q
suffix:semicolon
id|dasd_device_t
op_star
id|device
suffix:semicolon
r_int
id|rc
comma
id|finished
suffix:semicolon
id|device
op_assign
id|cqr-&gt;device
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
)paren
suffix:semicolon
id|init_waitqueue_head
(paren
op_amp
id|wait_q
)paren
suffix:semicolon
id|cqr-&gt;callback
op_assign
id|dasd_wakeup_cb
suffix:semicolon
id|cqr-&gt;callback_data
op_assign
(paren
r_void
op_star
)paren
op_amp
id|wait_q
suffix:semicolon
id|cqr-&gt;status
op_assign
id|DASD_CQR_QUEUED
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|cqr-&gt;list
comma
op_amp
id|device-&gt;ccw_queue
)paren
suffix:semicolon
multiline_comment|/* let the bh start the request to keep them in order */
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
)paren
suffix:semicolon
id|finished
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|finished
)paren
(brace
id|rc
op_assign
id|wait_event_interruptible
c_func
(paren
id|wait_q
comma
id|_wait_for_wakeup
c_func
(paren
id|cqr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
op_minus
id|ERESTARTSYS
)paren
(brace
multiline_comment|/* Request status is either done or failed. */
id|rc
op_assign
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_FAILED
)paren
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_lock_irq
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_IN_IO
op_logical_and
id|device-&gt;discipline
op_member_access_from_pointer
id|term_IO
c_func
(paren
id|cqr
)paren
op_eq
l_int|0
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|cqr-&gt;list
)paren
suffix:semicolon
id|finished
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Whoa nelly now it gets really hairy. For some functions (e.g. steal lock&n; * for eckd devices) the currently running request has to be terminated&n; * and be put back to status queued, before the special request is added&n; * to the head of the queue. Then the special request is waited on normally.&n; */
r_static
r_inline
r_int
DECL|function|_dasd_term_running_cqr
id|_dasd_term_running_cqr
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
id|dasd_ccw_req_t
op_star
id|cqr
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|device-&gt;ccw_queue
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|cqr
op_assign
id|list_entry
c_func
(paren
id|device-&gt;ccw_queue.next
comma
id|dasd_ccw_req_t
comma
id|list
)paren
suffix:semicolon
id|rc
op_assign
id|device-&gt;discipline
op_member_access_from_pointer
id|term_IO
c_func
(paren
id|cqr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
multiline_comment|/* termination successful */
id|cqr-&gt;status
op_assign
id|DASD_CQR_QUEUED
suffix:semicolon
id|cqr-&gt;startclk
op_assign
id|cqr-&gt;stopclk
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
r_int
DECL|function|dasd_sleep_on_immediatly
id|dasd_sleep_on_immediatly
c_func
(paren
id|dasd_ccw_req_t
op_star
id|cqr
)paren
(brace
id|wait_queue_head_t
id|wait_q
suffix:semicolon
id|dasd_device_t
op_star
id|device
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|device
op_assign
id|cqr-&gt;device
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
)paren
suffix:semicolon
id|rc
op_assign
id|_dasd_term_running_cqr
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|spin_unlock_irq
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|init_waitqueue_head
(paren
op_amp
id|wait_q
)paren
suffix:semicolon
id|cqr-&gt;callback
op_assign
id|dasd_wakeup_cb
suffix:semicolon
id|cqr-&gt;callback_data
op_assign
(paren
r_void
op_star
)paren
op_amp
id|wait_q
suffix:semicolon
id|cqr-&gt;status
op_assign
id|DASD_CQR_QUEUED
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|cqr-&gt;list
comma
op_amp
id|device-&gt;ccw_queue
)paren
suffix:semicolon
multiline_comment|/* let the bh start the request to keep them in order */
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
)paren
suffix:semicolon
id|wait_event
c_func
(paren
id|wait_q
comma
id|_wait_for_wakeup
c_func
(paren
id|cqr
)paren
)paren
suffix:semicolon
multiline_comment|/* Request status is either done or failed. */
id|rc
op_assign
(paren
id|cqr-&gt;status
op_eq
id|DASD_CQR_FAILED
)paren
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Cancels a request that was started with dasd_sleep_on_req.&n; * This is usefull to timeout requests. The request will be&n; * terminated if it is currently in i/o.&n; * Returns 1 if the request has been terminated.&n; */
DECL|function|dasd_cancel_req
r_int
id|dasd_cancel_req
c_func
(paren
id|dasd_ccw_req_t
op_star
id|cqr
)paren
(brace
id|dasd_device_t
op_star
id|device
op_assign
id|cqr-&gt;device
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
comma
id|flags
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cqr-&gt;status
)paren
(brace
r_case
id|DASD_CQR_QUEUED
suffix:colon
multiline_comment|/* request was not started - just set to failed */
id|cqr-&gt;status
op_assign
id|DASD_CQR_FAILED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DASD_CQR_IN_IO
suffix:colon
multiline_comment|/* request in IO - terminate IO and release again */
r_if
c_cond
(paren
id|device-&gt;discipline
op_member_access_from_pointer
id|term_IO
c_func
(paren
id|cqr
)paren
op_ne
l_int|0
)paren
multiline_comment|/* what to do if unable to terminate ??????&n;&t;&t;&t;   e.g. not _IN_IO */
id|cqr-&gt;status
op_assign
id|DASD_CQR_FAILED
suffix:semicolon
id|cqr-&gt;stopclk
op_assign
id|get_clock
c_func
(paren
)paren
suffix:semicolon
id|rc
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DASD_CQR_DONE
suffix:colon
r_case
id|DASD_CQR_FAILED
suffix:colon
multiline_comment|/* already finished - do nothing */
r_break
suffix:semicolon
r_default
suffix:colon
id|DEV_MESSAGE
c_func
(paren
id|KERN_ALERT
comma
id|device
comma
l_string|&quot;invalid status %02x in request&quot;
comma
id|cqr-&gt;status
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
comma
id|flags
)paren
suffix:semicolon
id|dasd_schedule_bh
c_func
(paren
id|device
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * SECTION: Block device operations (request queue, partitions, open, release).&n; */
multiline_comment|/*&n; * Dasd request queue function. Called from ll_rw_blk.c&n; */
r_static
r_void
DECL|function|do_dasd_request
id|do_dasd_request
c_func
(paren
id|request_queue_t
op_star
id|queue
)paren
(brace
id|dasd_device_t
op_star
id|device
suffix:semicolon
id|device
op_assign
(paren
id|dasd_device_t
op_star
)paren
id|queue-&gt;queuedata
suffix:semicolon
id|spin_lock
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
)paren
suffix:semicolon
multiline_comment|/* Get new request from the block device request queue */
id|__dasd_process_blk_queue
c_func
(paren
id|device
)paren
suffix:semicolon
multiline_comment|/* Now check if the head of the ccw queue needs to be started. */
id|__dasd_start_head
c_func
(paren
id|device
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
id|get_irq_lock
c_func
(paren
id|device-&gt;devinfo.irq
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate request queue and initialize gendisk info for device.&n; */
r_static
r_int
DECL|function|dasd_setup_blkdev
id|dasd_setup_blkdev
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
r_int
id|max
comma
id|rc
suffix:semicolon
id|device-&gt;request_queue
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|request_queue_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;request_queue
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|device-&gt;request_queue-&gt;queuedata
op_assign
id|device
suffix:semicolon
id|rc
op_assign
id|blk_init_queue
c_func
(paren
id|device-&gt;request_queue
comma
id|do_dasd_request
comma
op_amp
id|device-&gt;request_queue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|elevator_exit
c_func
(paren
id|device-&gt;request_queue
)paren
suffix:semicolon
id|rc
op_assign
id|elevator_init
c_func
(paren
id|device-&gt;request_queue
comma
op_amp
id|elevator_noop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|blk_cleanup_queue
c_func
(paren
id|device-&gt;request_queue
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|blk_queue_hardsect_size
c_func
(paren
id|device-&gt;request_queue
comma
id|device-&gt;bp_block
)paren
suffix:semicolon
id|max
op_assign
id|device-&gt;discipline-&gt;max_blocks
op_lshift
id|device-&gt;s2b_shift
suffix:semicolon
id|blk_queue_max_sectors
c_func
(paren
id|device-&gt;request_queue
comma
id|max
)paren
suffix:semicolon
id|blk_queue_max_phys_segments
c_func
(paren
id|device-&gt;request_queue
comma
op_minus
l_int|1L
)paren
suffix:semicolon
id|blk_queue_max_hw_segments
c_func
(paren
id|device-&gt;request_queue
comma
op_minus
l_int|1L
)paren
suffix:semicolon
id|blk_queue_max_segment_size
c_func
(paren
id|device-&gt;request_queue
comma
op_minus
l_int|1L
)paren
suffix:semicolon
id|blk_queue_segment_boundary
c_func
(paren
id|device-&gt;request_queue
comma
op_minus
l_int|1L
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Deactivate and free request queue.&n; */
r_static
r_void
DECL|function|dasd_disable_blkdev
id|dasd_disable_blkdev
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
r_if
c_cond
(paren
id|device-&gt;request_queue
)paren
(brace
id|blk_cleanup_queue
c_func
(paren
id|device-&gt;request_queue
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|device-&gt;request_queue
)paren
suffix:semicolon
id|device-&gt;request_queue
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Flush request on the request queue.&n; */
r_static
r_void
DECL|function|dasd_flush_request_queue
id|dasd_flush_request_queue
c_func
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
r_struct
id|request
op_star
id|req
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device-&gt;request_queue
)paren
r_return
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|device-&gt;request_queue_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|device-&gt;request_queue-&gt;queue_head
)paren
)paren
(brace
id|req
op_assign
id|elv_next_request
c_func
(paren
id|device-&gt;request_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|dasd_end_request
c_func
(paren
id|req
comma
l_int|0
)paren
suffix:semicolon
id|blkdev_dequeue_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|device-&gt;request_queue_lock
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|dasd_open
id|dasd_open
c_func
(paren
r_struct
id|inode
op_star
id|inp
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|dasd_devmap_t
op_star
id|devmap
suffix:semicolon
id|dasd_device_t
op_star
id|device
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|inp
)paren
op_logical_or
id|kdev_none
c_func
(paren
id|inp-&gt;i_rdev
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|dasd_probeonly
)paren
(brace
id|MESSAGE
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;No access to device (%d:%d) due to probeonly mode&quot;
comma
id|major
c_func
(paren
id|inp-&gt;i_rdev
)paren
comma
id|minor
c_func
(paren
id|inp-&gt;i_rdev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|devmap
op_assign
id|dasd_devmap_from_kdev
c_func
(paren
id|inp-&gt;i_rdev
)paren
suffix:semicolon
id|device
op_assign
(paren
id|devmap
op_ne
l_int|NULL
)paren
ques
c_cond
id|dasd_get_device
c_func
(paren
id|devmap
)paren
suffix:colon
id|ERR_PTR
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|device
)paren
)paren
(brace
id|MESSAGE
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;No device registered as (%d:%d)&quot;
comma
id|major
c_func
(paren
id|inp-&gt;i_rdev
)paren
comma
id|minor
c_func
(paren
id|inp-&gt;i_rdev
)paren
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|device-&gt;state
OL
id|DASD_STATE_BASIC
)paren
(brace
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_ERR
comma
id|device
comma
l_string|&quot; %s&quot;
comma
l_string|&quot; Cannot open unrecognized device&quot;
)paren
suffix:semicolon
id|dasd_put_device
c_func
(paren
id|devmap
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|rc
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|discipline_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_inc_return
c_func
(paren
op_amp
id|device-&gt;open_count
)paren
op_eq
l_int|1
op_logical_and
id|device-&gt;discipline-&gt;owner
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|try_inc_mod_count
c_func
(paren
id|device-&gt;discipline-&gt;owner
)paren
)paren
(brace
multiline_comment|/* Discipline is currently unloaded! */
id|atomic_dec
c_func
(paren
op_amp
id|device-&gt;open_count
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|discipline_lock
)paren
suffix:semicolon
id|dasd_put_device
c_func
(paren
id|devmap
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_static
r_int
DECL|function|dasd_release
id|dasd_release
c_func
(paren
r_struct
id|inode
op_star
id|inp
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|dasd_devmap_t
op_star
id|devmap
suffix:semicolon
id|dasd_device_t
op_star
id|device
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|inp
)paren
op_logical_or
id|kdev_none
c_func
(paren
id|inp-&gt;i_rdev
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|devmap
op_assign
id|dasd_devmap_from_kdev
c_func
(paren
id|inp-&gt;i_rdev
)paren
suffix:semicolon
id|device
op_assign
(paren
id|devmap
op_ne
l_int|NULL
)paren
ques
c_cond
id|dasd_get_device
c_func
(paren
id|devmap
)paren
suffix:colon
id|ERR_PTR
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|device
)paren
)paren
(brace
id|MESSAGE
c_func
(paren
id|KERN_WARNING
comma
l_string|&quot;No device registered as %d:%d&quot;
comma
id|major
c_func
(paren
id|inp-&gt;i_rdev
)paren
comma
id|minor
c_func
(paren
id|inp-&gt;i_rdev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|device-&gt;state
OL
id|DASD_STATE_ACCEPT
)paren
(brace
id|DBF_DEV_EVENT
c_func
(paren
id|DBF_ERR
comma
id|device
comma
l_string|&quot; %s&quot;
comma
l_string|&quot; Cannot release unrecognized device&quot;
)paren
suffix:semicolon
id|dasd_put_device
c_func
(paren
id|devmap
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_dec_return
c_func
(paren
op_amp
id|device-&gt;open_count
)paren
op_eq
l_int|0
)paren
(brace
id|invalidate_buffers
c_func
(paren
id|inp-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;discipline-&gt;owner
)paren
id|__MOD_DEC_USE_COUNT
c_func
(paren
id|device-&gt;discipline-&gt;owner
)paren
suffix:semicolon
)brace
id|dasd_put_device
c_func
(paren
id|devmap
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_struct
DECL|variable|dasd_device_operations
id|block_device_operations
id|dasd_device_operations
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|open
suffix:colon
id|dasd_open
comma
id|release
suffix:colon
id|dasd_release
comma
id|ioctl
suffix:colon
id|dasd_ioctl
comma
)brace
suffix:semicolon
r_static
r_void
DECL|function|dasd_exit
id|dasd_exit
c_func
(paren
r_void
)paren
(brace
id|dasd_disable_devices
c_func
(paren
l_int|0
comma
id|dasd_max_devindex
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DASD_DIAG
r_if
c_cond
(paren
id|MACHINE_IS_VM
)paren
id|dasd_diag_cleanup
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_DASD_FBA
id|dasd_fba_cleanup
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_DASD_ECKD
id|dasd_eckd_cleanup
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_PROC_FS
id|dasd_proc_exit
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|dasd_ioctl_exit
c_func
(paren
)paren
suffix:semicolon
id|dasd_gendisk_exit
c_func
(paren
)paren
suffix:semicolon
id|dasd_devmap_exit
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dasd_devfs_handle
)paren
id|devfs_unregister
c_func
(paren
id|dasd_devfs_handle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dasd_debug_area
op_ne
l_int|NULL
)paren
(brace
id|debug_unregister
c_func
(paren
id|dasd_debug_area
)paren
suffix:semicolon
id|dasd_debug_area
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * SECTION: Initializing the driver&n; */
r_static
r_int
DECL|function|dasd_request_module
id|dasd_request_module
c_func
(paren
r_void
op_star
id|name
)paren
(brace
r_int
id|rc
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
id|strcpy
c_func
(paren
id|current-&gt;comm
comma
id|name
)paren
suffix:semicolon
id|daemonize
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|current-&gt;fs-&gt;root
op_eq
l_int|NULL
)paren
multiline_comment|/* wait for root-FS */
id|schedule_timeout
c_func
(paren
id|HZ
)paren
suffix:semicolon
multiline_comment|/* wait a second */
r_while
c_loop
(paren
(paren
id|rc
op_assign
id|request_module
c_func
(paren
id|name
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|MESSAGE
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;request_module returned %d for %s&quot;
comma
id|rc
comma
(paren
r_char
op_star
)paren
id|name
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
multiline_comment|/* wait 5 seconds */
)brace
r_return
id|rc
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|dasd_init
id|dasd_init
c_func
(paren
r_void
)paren
(brace
r_char
op_star
op_star
id|disc
suffix:semicolon
r_int
id|irq
comma
id|devno
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|dasd_init_waitq
)paren
suffix:semicolon
multiline_comment|/* register &squot;common&squot; DASD debug area, used faor all DBF_XXX calls */
id|dasd_debug_area
op_assign
id|debug_register
c_func
(paren
l_string|&quot;dasd&quot;
comma
l_int|0
comma
l_int|2
comma
l_int|8
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dasd_debug_area
op_eq
l_int|NULL
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
id|debug_register_view
c_func
(paren
id|dasd_debug_area
comma
op_amp
id|debug_sprintf_view
)paren
suffix:semicolon
id|debug_set_level
c_func
(paren
id|dasd_debug_area
comma
id|DBF_ERR
)paren
suffix:semicolon
id|DBF_EVENT
c_func
(paren
id|DBF_EMERG
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;debug area created&quot;
)paren
suffix:semicolon
id|dasd_devfs_handle
op_assign
id|devfs_mk_dir
c_func
(paren
l_int|NULL
comma
l_string|&quot;dasd&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dasd_devfs_handle
OL
l_int|0
)paren
(brace
id|DBF_EVENT
c_func
(paren
id|DBF_ALERT
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;no devfs&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOSYS
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
id|rc
op_assign
id|dasd_devmap_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|failed
suffix:semicolon
id|rc
op_assign
id|dasd_gendisk_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|failed
suffix:semicolon
id|rc
op_assign
id|dasd_parse
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|failed
suffix:semicolon
id|rc
op_assign
id|dasd_ioctl_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|failed
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|rc
op_assign
id|dasd_proc_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|failed
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|dasd_autodetect
)paren
(brace
multiline_comment|/* update device range to all devices */
id|irq
op_assign
id|get_irq_first
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|irq
op_ne
op_minus
id|ENODEV
)paren
(brace
id|devno
op_assign
id|get_devno_by_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dasd_devmap_from_devno
c_func
(paren
id|devno
)paren
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* devno not included yet */
id|DBF_EVENT
c_func
(paren
id|DBF_NOTICE
comma
l_string|&quot;add %04x to range&quot;
comma
id|devno
)paren
suffix:semicolon
id|dasd_add_range
c_func
(paren
id|devno
comma
id|devno
comma
id|DASD_FEATURE_DEFAULT
)paren
suffix:semicolon
)brace
id|irq
op_assign
id|get_irq_next
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|MACHINE_IS_VM
)paren
(brace
macro_line|#ifdef CONFIG_DASD_DIAG
id|rc
op_assign
id|dasd_diag_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
id|DBF_EVENT
c_func
(paren
id|DBF_ALERT
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;Register DIAG discipline failed&quot;
)paren
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_DIAG */
macro_line|#if defined(CONFIG_DASD_DIAG_MODULE) &amp;&amp; defined(CONFIG_DASD_AUTO_DIAG)
id|kernel_thread
c_func
(paren
id|dasd_request_module
comma
l_string|&quot;dasd_diag_mod&quot;
comma
id|SIGCHLD
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef CONFIG_DASD_ECKD
id|rc
op_assign
id|dasd_eckd_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
id|DBF_EVENT
c_func
(paren
id|DBF_ALERT
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;Register ECKD discipline failed&quot;
)paren
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_ECKD */
macro_line|#if defined(CONFIG_DASD_ECKD_MODULE) &amp;&amp; defined(CONFIG_DASD_AUTO_ECKD)
id|kernel_thread
c_func
(paren
id|dasd_request_module
comma
l_string|&quot;dasd_eckd_mod&quot;
comma
id|SIGCHLD
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_DASD_FBA
id|rc
op_assign
id|dasd_fba_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
(brace
id|DBF_EVENT
c_func
(paren
id|DBF_ALERT
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;Register FBA discipline failed&quot;
)paren
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if defined(CONFIG_DASD_FBA_MODULE) &amp;&amp; defined(CONFIG_DASD_AUTO_FBA)
id|kernel_thread
c_func
(paren
id|dasd_request_module
comma
l_string|&quot;dasd_fba_mod&quot;
comma
id|SIGCHLD
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_AUTO_FBA */
id|disc
op_assign
id|dasd_disciplines
suffix:semicolon
r_while
c_loop
(paren
op_star
id|disc
)paren
(brace
id|kernel_thread
c_func
(paren
id|dasd_request_module
comma
op_star
id|disc
comma
id|SIGCHLD
)paren
suffix:semicolon
id|disc
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|failed
suffix:colon
id|MESSAGE
c_func
(paren
id|KERN_INFO
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;initialization not performed due to errors&quot;
)paren
suffix:semicolon
id|dasd_exit
c_func
(paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|variable|dasd_init
id|module_init
c_func
(paren
id|dasd_init
)paren
suffix:semicolon
DECL|variable|dasd_exit
id|module_exit
c_func
(paren
id|dasd_exit
)paren
suffix:semicolon
DECL|variable|dasd_debug_area
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_debug_area
)paren
suffix:semicolon
DECL|variable|dasd_add_request_head
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_add_request_head
)paren
suffix:semicolon
DECL|variable|dasd_add_request_tail
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_add_request_tail
)paren
suffix:semicolon
DECL|variable|dasd_cancel_req
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_cancel_req
)paren
suffix:semicolon
DECL|variable|dasd_clear_timer
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_clear_timer
)paren
suffix:semicolon
DECL|variable|dasd_disable_devices
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_disable_devices
)paren
suffix:semicolon
DECL|variable|dasd_discipline_add
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_discipline_add
)paren
suffix:semicolon
DECL|variable|dasd_discipline_del
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_discipline_del
)paren
suffix:semicolon
DECL|variable|dasd_enable_devices
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_enable_devices
)paren
suffix:semicolon
DECL|variable|dasd_int_handler
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_int_handler
)paren
suffix:semicolon
DECL|variable|dasd_kfree_request
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_kfree_request
)paren
suffix:semicolon
DECL|variable|dasd_kick_device
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_kick_device
)paren
suffix:semicolon
DECL|variable|dasd_kmalloc_request
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_kmalloc_request
)paren
suffix:semicolon
DECL|variable|dasd_not_oper_handler
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_not_oper_handler
)paren
suffix:semicolon
DECL|variable|dasd_oper_handler
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_oper_handler
)paren
suffix:semicolon
DECL|variable|dasd_schedule_bh
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_schedule_bh
)paren
suffix:semicolon
DECL|variable|dasd_set_target_state
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_set_target_state
)paren
suffix:semicolon
DECL|variable|dasd_set_timer
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_set_timer
)paren
suffix:semicolon
DECL|variable|dasd_sfree_request
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_sfree_request
)paren
suffix:semicolon
DECL|variable|dasd_sleep_on
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_sleep_on
)paren
suffix:semicolon
DECL|variable|dasd_sleep_on_immediatly
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_sleep_on_immediatly
)paren
suffix:semicolon
DECL|variable|dasd_sleep_on_interruptible
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_sleep_on_interruptible
)paren
suffix:semicolon
DECL|variable|dasd_smalloc_request
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_smalloc_request
)paren
suffix:semicolon
DECL|variable|dasd_start_IO
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_start_IO
)paren
suffix:semicolon
DECL|variable|dasd_term_IO
id|EXPORT_SYMBOL
c_func
(paren
id|dasd_term_IO
)paren
suffix:semicolon
multiline_comment|/*&n; * Overrides for Emacs so that we follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-indent-level: 4&n; * c-brace-imaginary-offset: 0&n; * c-brace-offset: -4&n; * c-argdecl-indent: 4&n; * c-label-offset: -4&n; * c-continued-statement-offset: 4&n; * c-continued-brace-offset: 0&n; * indent-tabs-mode: 1&n; * tab-width: 8&n; * End:&n; */
eof
