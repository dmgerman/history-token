multiline_comment|/* &n; * File...........: linux/drivers/s390/block/dasd.c&n; * Author(s)......: Holger Smolinski &lt;Holger.Smolinski@de.ibm.com&gt;&n; *                  Horst Hummel &lt;Horst.Hummel@de.ibm.com&gt;  &n; * Bugreports.to..: &lt;Linux390@de.ibm.com&gt;&n; * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999,2000&n; *&n; * History of changes (starts July 2000)&n; * 11/09/00 complete redesign after code review&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/tqueue.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#ifdef CONFIG_PROC_FS
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#endif&t;&t;&t;&t;/* CONFIG_PROC_FS */
macro_line|#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,3,98))
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#else
macro_line|#include &lt;asm/spinlock.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/ccwcache.h&gt;
macro_line|#include &lt;asm/dasd.h&gt;
macro_line|#include &lt;asm/debug.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/ebcdic.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/s390_ext.h&gt;
macro_line|#include &lt;asm/s390dyn.h&gt;
macro_line|#include &lt;asm/idals.h&gt;
macro_line|#ifdef CONFIG_DASD_ECKD
macro_line|#include &quot;dasd_eckd.h&quot;
macro_line|#endif&t;&t;&t;&t;/*  CONFIG_DASD_ECKD */
macro_line|#ifdef CONFIG_DASD_FBA
macro_line|#include &quot;dasd_fba.h&quot;
macro_line|#endif&t;&t;&t;&t;/*  CONFIG_DASD_FBA */
macro_line|#ifdef CONFIG_DASD_MDSK
macro_line|#include &quot;dasd_diag.h&quot;
macro_line|#endif&t;&t;&t;&t;/*  CONFIG_DASD_MDSK */
DECL|variable|dasd_device_operations
r_static
r_struct
id|block_device_operations
id|dasd_device_operations
suffix:semicolon
macro_line|#ifdef MODULE
DECL|macro|EXPORT_SYMTAB
mdefine_line|#define EXPORT_SYMTAB
macro_line|#include &lt;linux/module.h&gt;
id|EXPORT_NO_SYMBOLS
suffix:semicolon
id|MODULE_AUTHOR
(paren
l_string|&quot;Holger Smolinski &lt;Holger.Smolinski@de.ibm.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
(paren
l_string|&quot;Linux on S/390 DASD device driver,&quot;
l_string|&quot; Copyright 2000 IBM Corporation&quot;
)paren
suffix:semicolon
id|MODULE_SUPPORTED_DEVICE
(paren
l_string|&quot;dasd&quot;
)paren
suffix:semicolon
id|MODULE_PARM
(paren
id|dasd
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
(paren
l_int|256
)paren
l_string|&quot;s&quot;
)paren
suffix:semicolon
DECL|variable|dasd_discipline_enq
id|EXPORT_SYMBOL
(paren
id|dasd_discipline_enq
)paren
suffix:semicolon
DECL|variable|dasd_discipline_deq
id|EXPORT_SYMBOL
(paren
id|dasd_discipline_deq
)paren
suffix:semicolon
DECL|variable|dasd_start_IO
id|EXPORT_SYMBOL
(paren
id|dasd_start_IO
)paren
suffix:semicolon
DECL|variable|dasd_int_handler
id|EXPORT_SYMBOL
(paren
id|dasd_int_handler
)paren
suffix:semicolon
DECL|variable|dasd_alloc_request
id|EXPORT_SYMBOL
(paren
id|dasd_alloc_request
)paren
suffix:semicolon
DECL|variable|dasd_free_request
id|EXPORT_SYMBOL
(paren
id|dasd_free_request
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* MODULE */
multiline_comment|/* SECTION: Constant definitions to be used within this file */
DECL|macro|ERP_DEBUG
macro_line|#undef ERP_DEBUG
DECL|macro|PRINTK_HEADER
mdefine_line|#define PRINTK_HEADER DASD_NAME&quot;: &quot;
DECL|macro|DASD_EMERGENCY_REQUESTS
mdefine_line|#define DASD_EMERGENCY_REQUESTS 16
DECL|macro|DASD_MIN_SIZE_FOR_QUEUE
mdefine_line|#define DASD_MIN_SIZE_FOR_QUEUE 32
DECL|macro|CONFIG_DYNAMIC_QUEUE_MIN_SIZE
macro_line|#undef CONFIG_DYNAMIC_QUEUE_MIN_SIZE
DECL|macro|DASD_CHANQ_MAX_SIZE
mdefine_line|#define DASD_CHANQ_MAX_SIZE 6
multiline_comment|/* SECTION: prototypes for static functions of dasd.c */
DECL|variable|do_dasd_request
r_static
id|request_fn_proc
id|do_dasd_request
suffix:semicolon
r_void
id|dasd_schedule_bh
(paren
id|dasd_device_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|dasd_set_device_level
(paren
r_int
r_int
comma
r_int
comma
id|dasd_discipline_t
op_star
comma
r_int
)paren
suffix:semicolon
r_static
id|request_queue_t
op_star
id|dasd_get_queue
(paren
id|kdev_t
id|kdev
)paren
suffix:semicolon
DECL|variable|dasd_device_operations
r_static
r_struct
id|block_device_operations
id|dasd_device_operations
suffix:semicolon
macro_line|#ifdef CONFIG_DASD_DYNAMIC
multiline_comment|/* SECTION: managing dynamic configuration of dasd_driver */
DECL|variable|dasd_devreg_head
r_static
id|dasd_devreg_t
op_star
id|dasd_devreg_head
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* &n; * function: dasd_create_devreg&n; * creates a dasd_devreg_t related to a devno&n; */
r_static
r_inline
id|dasd_devreg_t
op_star
DECL|function|dasd_create_devreg
id|dasd_create_devreg
(paren
r_int
id|devno
)paren
(brace
id|dasd_devreg_t
op_star
id|r
op_assign
id|kmalloc
(paren
r_sizeof
(paren
id|dasd_devreg_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_ne
l_int|NULL
)paren
(brace
id|memset
(paren
id|r
comma
l_int|0
comma
r_sizeof
(paren
id|dasd_devreg_t
)paren
)paren
suffix:semicolon
id|r-&gt;devreg.ci.devno
op_assign
id|devno
suffix:semicolon
id|r-&gt;devreg.flag
op_assign
id|DEVREG_TYPE_DEVNO
suffix:semicolon
id|r-&gt;devreg.oper_func
op_assign
id|dasd_oper_handler
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/* &n; * function: dasd_destroy_devreg&n; * destroys the dasd_devreg_t given as argument&n; */
r_static
r_inline
r_void
DECL|function|dasd_destroy_devreg
id|dasd_destroy_devreg
(paren
id|dasd_devreg_t
op_star
id|devreg
)paren
(brace
id|kfree
(paren
id|devreg
)paren
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_DYNAMIC */
multiline_comment|/* SECTION: managing setup of dasd_driver */
multiline_comment|/* default setting is probeonly, autodetect */
DECL|variable|dasd_probeonly
r_static
r_int
id|dasd_probeonly
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* is true, when probeonly mode is active */
DECL|variable|dasd_autodetect
r_static
r_int
id|dasd_autodetect
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* is true, when autodetection is active */
multiline_comment|/* dasd_range_t are used for ordering the DASD devices */
DECL|struct|dasd_range_t
r_typedef
r_struct
id|dasd_range_t
(brace
DECL|member|from
r_int
r_int
id|from
suffix:semicolon
multiline_comment|/* first DASD in range */
DECL|member|to
r_int
r_int
id|to
suffix:semicolon
multiline_comment|/* last DASD in range */
DECL|member|discipline
r_char
id|discipline
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* placeholder to force discipline */
DECL|member|next
r_struct
id|dasd_range_t
op_star
id|next
suffix:semicolon
multiline_comment|/* next one in linked list */
DECL|typedef|dasd_range_t
)brace
id|dasd_range_t
suffix:semicolon
DECL|variable|dasd_range_head
r_static
id|dasd_range_t
op_star
id|dasd_range_head
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* anchor for list of ranges */
DECL|variable|range_lock
r_static
id|spinlock_t
id|range_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* &n; * function: dasd_create_range&n; * creates a dasd_range_t according to the arguments &n; * FIXME: no check is performed for reoccurrence of a devno&n; */
r_static
r_inline
id|dasd_range_t
op_star
DECL|function|dasd_create_range
id|dasd_create_range
(paren
r_int
id|from
comma
r_int
id|to
)paren
(brace
id|dasd_range_t
op_star
id|range
op_assign
l_int|NULL
suffix:semicolon
id|range
op_assign
(paren
id|dasd_range_t
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
id|dasd_range_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|range
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
(paren
id|range
comma
l_int|0
comma
r_sizeof
(paren
id|dasd_range_t
)paren
)paren
suffix:semicolon
id|range-&gt;from
op_assign
id|from
suffix:semicolon
r_if
c_cond
(paren
id|to
op_eq
l_int|0
)paren
(brace
multiline_comment|/* single devno ? */
id|range-&gt;to
op_assign
id|from
suffix:semicolon
)brace
r_else
(brace
id|range-&gt;to
op_assign
id|to
suffix:semicolon
)brace
r_return
id|range
suffix:semicolon
)brace
multiline_comment|/* &n; * function dasd_destroy_range&n; * destroy a range allocated wit dasd_crate_range&n; * CAUTION: must not be callen in arunning sysztem, because it destroys &n; * the mapping of DASDs&n; */
r_static
r_inline
r_void
DECL|function|dasd_destroy_range
id|dasd_destroy_range
(paren
id|dasd_range_t
op_star
id|range
)paren
(brace
id|kfree
(paren
id|range
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * function: dasd_append_range&n; * appends the range given as argument to the list anchored at dasd_range_head. &n; */
r_static
r_inline
r_void
DECL|function|dasd_append_range
id|dasd_append_range
(paren
id|dasd_range_t
op_star
id|range
)paren
(brace
id|dasd_range_t
op_star
id|temp
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|range_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dasd_range_head
op_eq
l_int|NULL
)paren
(brace
id|dasd_range_head
op_assign
id|range
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|temp
op_assign
id|dasd_range_head
suffix:semicolon
id|temp
op_logical_and
id|temp-&gt;next
suffix:semicolon
id|temp
op_assign
id|temp-&gt;next
)paren
suffix:semicolon
id|temp-&gt;next
op_assign
id|range
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|range_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * function dasd_dechain_range&n; * removes a range from the chain of ranges&n; * CAUTION: must not be called in a running system because it destroys &n; * the mapping of devices&n; */
r_static
r_inline
r_void
DECL|function|dasd_dechain_range
id|dasd_dechain_range
(paren
id|dasd_range_t
op_star
id|range
)paren
(brace
id|dasd_range_t
op_star
id|temp
comma
op_star
id|prev
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|range_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|temp
op_assign
id|dasd_range_head
suffix:semicolon
id|temp
op_ne
l_int|NULL
suffix:semicolon
id|temp
op_assign
id|temp-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|temp
op_eq
id|range
)paren
r_break
suffix:semicolon
id|prev
op_assign
id|temp
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|temp
)paren
id|BUG
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
(brace
id|prev-&gt;next
op_assign
id|temp-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|dasd_range_head
op_assign
id|temp-&gt;next
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|range_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * function: dasd_add_range&n; * creates a dasd_range_t according to the arguments and&n; * appends it to the list of ranges&n; * additionally a devreg_t is created and added to the list of devregs &n; */
r_static
r_inline
r_void
DECL|function|dasd_add_range
id|dasd_add_range
(paren
r_int
id|from
comma
r_int
id|to
)paren
(brace
id|dasd_range_t
op_star
id|range
suffix:semicolon
id|range
op_assign
id|dasd_create_range
(paren
id|from
comma
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
id|range
)paren
id|dasd_append_range
(paren
id|range
)paren
suffix:semicolon
r_else
r_return
suffix:semicolon
macro_line|#ifdef CONFIG_DASD_DYNAMIC
multiline_comment|/* allocate and chain devreg infos for the devnos... */
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|range-&gt;from
suffix:semicolon
id|i
op_le
id|range-&gt;to
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dasd_devreg_t
op_star
id|reg
op_assign
id|dasd_create_devreg
(paren
id|i
)paren
suffix:semicolon
id|s390_device_register
(paren
op_amp
id|reg-&gt;devreg
)paren
suffix:semicolon
id|reg-&gt;next
op_assign
id|dasd_devreg_head
suffix:semicolon
id|dasd_devreg_head
op_assign
id|reg
suffix:semicolon
)brace
)brace
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_DYNAMIC */
)brace
multiline_comment|/* &n; * function: dasd_remove_range&n; * removes a range and the corresponding devregs from all of the chains&n; * CAUTION: must not be called in a running system because it destroys&n; * the mapping of devices!&n; */
r_static
r_inline
r_void
DECL|function|dasd_remove_range
id|dasd_remove_range
(paren
id|dasd_range_t
op_star
id|range
)paren
(brace
macro_line|#ifdef CONFIG_DASD_DYNAMIC
multiline_comment|/* deallocate and dechain devreg infos for the devnos... */
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|range-&gt;from
suffix:semicolon
id|i
op_le
id|range-&gt;to
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dasd_devreg_t
op_star
id|reg
comma
op_star
id|prev
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|reg
op_assign
id|dasd_devreg_head
suffix:semicolon
id|reg
suffix:semicolon
id|reg
op_assign
id|reg-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|reg-&gt;devreg.flag
op_eq
id|DEVREG_TYPE_DEVNO
op_logical_and
id|reg-&gt;devreg.devno
op_eq
id|i
op_logical_and
id|reg-&gt;devreg.oper_func
op_eq
id|dasd_oper_handler
)paren
r_break
suffix:semicolon
id|prev
op_assign
id|reg
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|reg
)paren
id|BUG
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
(brace
id|prev-&gt;next
op_assign
id|reg-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|dasd_devreg_head
op_assign
id|reg-&gt;next
suffix:semicolon
)brace
id|s390_device_unregister
(paren
op_amp
id|reg-&gt;devreg
)paren
suffix:semicolon
id|dasd_destroy_devreg
(paren
id|reg
)paren
suffix:semicolon
)brace
)brace
id|dasd_dechain_range
(paren
id|range
)paren
suffix:semicolon
id|dasd_destroy_range
(paren
id|range
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_DYNAMIC */
)brace
multiline_comment|/* &n; * function: dasd_devindex_from_devno&n; * finds the logical number of the devno supplied as argument in the list&n; * of dasd ranges and returns it or ENODEV when not found&n; */
r_static
r_int
DECL|function|dasd_devindex_from_devno
id|dasd_devindex_from_devno
(paren
r_int
id|devno
)paren
(brace
id|dasd_range_t
op_star
id|temp
suffix:semicolon
r_int
id|devindex
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|range_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|temp
op_assign
id|dasd_range_head
suffix:semicolon
id|temp
suffix:semicolon
id|temp
op_assign
id|temp-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|devno
op_ge
id|temp-&gt;from
op_logical_and
id|devno
op_le
id|temp-&gt;to
)paren
(brace
id|spin_unlock_irqrestore
(paren
op_amp
id|range_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|devindex
op_plus
id|devno
op_minus
id|temp-&gt;from
suffix:semicolon
)brace
id|devindex
op_add_assign
id|temp-&gt;to
op_minus
id|temp-&gt;from
op_plus
l_int|1
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|range_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* SECTION: parsing the dasd= parameter of the parmline/insmod cmdline */
multiline_comment|/* &n; * char *dasd[] is intended to hold the ranges supplied by the dasd= statement&n; * it is named &squot;dasd&squot; to directly be filled by insmod with the comma separated&n; * strings when running as a module.&n; * a maximum of 256 ranges can be supplied, as the parmline is limited to&n; * &lt;1024 Byte anyway.&n; */
DECL|variable|dasd
r_char
op_star
id|dasd
(braket
l_int|256
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
macro_line|#ifndef MODULE
multiline_comment|/* &n; * function: dasd_split_parm_string&n; * splits the parmline given to the kernel into comma separated strings&n; * which are filled into the &squot;dasd[]&squot; array, to be parsed later on&n; */
r_static
r_void
DECL|function|dasd_split_parm_string
id|dasd_split_parm_string
(paren
r_char
op_star
id|str
)paren
(brace
r_char
op_star
id|tmp
op_assign
id|str
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_char
op_star
id|end
suffix:semicolon
r_int
id|len
suffix:semicolon
id|end
op_assign
id|strchr
(paren
id|tmp
comma
l_char|&squot;,&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
op_eq
l_int|NULL
)paren
(brace
id|len
op_assign
id|strlen
(paren
id|tmp
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|len
op_assign
(paren
r_int
)paren
id|end
op_minus
(paren
r_int
)paren
id|tmp
op_plus
l_int|1
suffix:semicolon
op_star
id|end
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|end
op_increment
suffix:semicolon
)brace
id|dasd
(braket
id|count
)braket
op_assign
id|kmalloc
(paren
id|len
op_star
r_sizeof
(paren
r_char
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dasd
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot;can&squot;t store dasd= parameter no %d&bslash;n&quot;
comma
id|count
op_plus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memset
(paren
id|dasd
(braket
id|count
)braket
comma
l_int|0
comma
id|len
op_star
r_sizeof
(paren
r_char
)paren
)paren
suffix:semicolon
id|memcpy
(paren
id|dasd
(braket
id|count
)braket
comma
id|tmp
comma
id|len
op_star
r_sizeof
(paren
r_char
)paren
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
id|tmp
op_assign
id|end
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
l_int|NULL
op_logical_and
op_star
id|tmp
op_ne
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * dasd_parm_string holds a concatenated version of all &squot;dasd=&squot; parameters&n; * supplied in the parmline, which is later to be split by &n; * dasd_split_parm_string&n; * FIXME: why first concatenate then split ?&n; */
DECL|variable|__initdata
r_static
r_char
id|dasd_parm_string
(braket
l_int|1024
)braket
id|__initdata
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* &n; * function: dasd_setup&n; * is invoked for any single &squot;dasd=&squot; parameter supplied in the parmline&n; * it merges all the arguments into dasd_parm_string&n; */
r_void
id|__init
DECL|function|dasd_setup
id|dasd_setup
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_int
id|len
op_assign
id|strlen
(paren
id|dasd_parm_string
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
l_int|0
)paren
(brace
id|strcat
(paren
id|dasd_parm_string
comma
l_string|&quot;,&quot;
)paren
suffix:semicolon
)brace
id|strcat
(paren
id|dasd_parm_string
comma
id|str
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * function: dasd_call_setup &n; * is the 2.4 version of dasd_setup and&n; * is invoked for any single &squot;dasd=&squot; parameter supplied in the parmline&n; */
r_int
id|__init
DECL|function|dasd_call_setup
id|dasd_call_setup
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|dummy
suffix:semicolon
id|dasd_setup
c_func
(paren
id|str
comma
op_amp
id|dummy
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
(paren
l_string|&quot;dasd=&quot;
comma
id|dasd_call_setup
)paren
suffix:semicolon
macro_line|#endif /* MODULE */
multiline_comment|/* &n; * function: dasd_strtoul&n; * provides a wrapper to simple_strtoul to strip leading &squot;0x&squot; and&n; * interpret any argument to dasd=[range,...] as hexadecimal&n; */
r_static
r_inline
r_int
DECL|function|dasd_strtoul
id|dasd_strtoul
(paren
r_char
op_star
id|str
comma
r_char
op_star
op_star
id|stra
)paren
(brace
r_char
op_star
id|temp
op_assign
id|str
suffix:semicolon
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
op_star
id|temp
op_eq
l_char|&squot;0&squot;
)paren
(brace
id|temp
op_increment
suffix:semicolon
multiline_comment|/* strip leading zero */
r_if
c_cond
(paren
op_star
id|temp
op_eq
l_char|&squot;x&squot;
)paren
id|temp
op_increment
suffix:semicolon
multiline_comment|/* strip leading x */
)brace
id|val
op_assign
id|simple_strtoul
(paren
id|temp
comma
op_amp
id|temp
comma
l_int|16
)paren
suffix:semicolon
multiline_comment|/* interpret anything as hex */
op_star
id|stra
op_assign
id|temp
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
multiline_comment|/* &n; * function: dasd_parse&n; * examines the strings given in the string array str and&n; * creates and adds the ranges to the apropriate lists&n; */
r_static
r_inline
r_void
DECL|function|dasd_parse
id|dasd_parse
(paren
r_char
op_star
op_star
id|str
)paren
(brace
r_char
op_star
id|temp
suffix:semicolon
r_int
id|from
comma
id|to
suffix:semicolon
r_if
c_cond
(paren
op_star
id|str
)paren
(brace
multiline_comment|/* turn off probeonly mode, if any dasd parameter is present */
id|dasd_probeonly
op_assign
l_int|0
suffix:semicolon
id|dasd_autodetect
op_assign
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
op_star
id|str
)paren
(brace
id|temp
op_assign
op_star
id|str
suffix:semicolon
id|from
op_assign
l_int|0
suffix:semicolon
id|to
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
(paren
l_string|&quot;autodetect&quot;
comma
op_star
id|str
)paren
op_eq
l_int|0
)paren
(brace
id|dasd_autodetect
op_assign
l_int|1
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;turning to autodetection mode&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
(paren
l_string|&quot;probeonly&quot;
comma
op_star
id|str
)paren
op_eq
l_int|0
)paren
(brace
id|dasd_probeonly
op_assign
l_int|1
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;turning to probeonly mode&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* turn off autodetect mode, if any range is present */
id|dasd_autodetect
op_assign
l_int|0
suffix:semicolon
id|from
op_assign
id|dasd_strtoul
(paren
id|temp
comma
op_amp
id|temp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|temp
op_eq
l_char|&squot;-&squot;
)paren
(brace
id|temp
op_increment
suffix:semicolon
id|to
op_assign
id|dasd_strtoul
(paren
id|temp
comma
op_amp
id|temp
)paren
suffix:semicolon
)brace
id|dasd_add_range
(paren
id|from
comma
id|to
)paren
suffix:semicolon
)brace
id|str
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* SECTION: Dealing with devices registered to multiple major numbers */
DECL|variable|dasd_major_lock
r_static
id|spinlock_t
id|dasd_major_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|dasd_major_info
r_static
id|major_info_t
id|dasd_major_info
(braket
)braket
op_assign
(brace
(brace
id|next
suffix:colon
l_int|NULL
comma
id|gendisk
suffix:colon
(brace
id|INIT_GENDISK
c_func
(paren
l_int|94
comma
id|DASD_NAME
comma
id|DASD_PARTN_BITS
comma
id|DASD_PER_MAJOR
)paren
)brace
)brace
)brace
suffix:semicolon
r_static
id|major_info_t
op_star
DECL|function|get_new_major_info
id|get_new_major_info
(paren
r_void
)paren
(brace
id|major_info_t
op_star
id|major_info
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|major_info
op_assign
id|kmalloc
(paren
r_sizeof
(paren
id|major_info_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|major_info
)paren
(brace
id|major_info_t
op_star
id|temp
op_assign
id|dasd_major_info
suffix:semicolon
r_static
id|major_info_t
id|temp_major_info
(braket
)braket
op_assign
(brace
(brace
id|next
suffix:colon
l_int|NULL
comma
id|gendisk
suffix:colon
(brace
id|INIT_GENDISK
c_func
(paren
l_int|0
comma
id|DASD_NAME
comma
id|DASD_PARTN_BITS
comma
id|DASD_PER_MAJOR
)paren
)brace
)brace
)brace
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|dasd_major_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|temp-&gt;next
)paren
id|temp
op_assign
id|temp-&gt;next
suffix:semicolon
id|temp-&gt;next
op_assign
id|major_info
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|dasd_major_lock
comma
id|flags
)paren
suffix:semicolon
id|memcpy
(paren
id|major_info
comma
id|temp_major_info
comma
r_sizeof
(paren
id|major_info_t
)paren
)paren
suffix:semicolon
)brace
r_return
id|major_info
suffix:semicolon
)brace
r_static
r_int
DECL|function|dasd_register_major
id|dasd_register_major
(paren
id|major_info_t
op_star
id|major_info
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|major
suffix:semicolon
r_if
c_cond
(paren
id|major_info
op_eq
l_int|NULL
)paren
(brace
id|major_info
op_assign
id|get_new_major_info
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|major_info
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot;Cannot get memory to allocate another major number&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_INFO
id|PRINTK_HEADER
l_string|&quot;Created another major number&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|major
op_assign
id|major_info-&gt;gendisk.major
suffix:semicolon
id|rc
op_assign
id|devfs_register_blkdev
(paren
id|major
comma
id|DASD_NAME
comma
op_amp
id|dasd_device_operations
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot;Cannot register to major no %d, rc = %d&bslash;n&quot;
comma
id|major
comma
id|rc
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_if
c_cond
(paren
id|major
op_eq
l_int|0
)paren
(brace
id|major
op_assign
id|rc
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
)brace
id|major_info-&gt;dasd_device
op_assign
(paren
id|dasd_device_t
op_star
op_star
)paren
id|kmalloc
(paren
id|DASD_PER_MAJOR
op_star
r_sizeof
(paren
id|dasd_device_t
op_star
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|major_info-&gt;dasd_device
)paren
r_goto
id|out_devfs
suffix:semicolon
id|memset
(paren
id|major_info-&gt;dasd_device
comma
l_int|0
comma
id|DASD_PER_MAJOR
op_star
r_sizeof
(paren
id|dasd_device_t
op_star
)paren
)paren
suffix:semicolon
id|blk_size
(braket
id|major
)braket
op_assign
(paren
r_int
op_star
)paren
id|kmalloc
(paren
(paren
l_int|1
op_lshift
id|MINORBITS
)paren
op_star
r_sizeof
(paren
r_int
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|blk_size
(braket
id|major
)braket
)paren
r_goto
id|out_dasd_device
suffix:semicolon
id|memset
(paren
id|blk_size
(braket
id|major
)braket
comma
l_int|0
comma
(paren
l_int|1
op_lshift
id|MINORBITS
)paren
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|blksize_size
(braket
id|major
)braket
op_assign
(paren
r_int
op_star
)paren
id|kmalloc
(paren
(paren
l_int|1
op_lshift
id|MINORBITS
)paren
op_star
r_sizeof
(paren
r_int
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|blksize_size
(braket
id|major
)braket
)paren
r_goto
id|out_blk_size
suffix:semicolon
id|memset
(paren
id|blksize_size
(braket
id|major
)braket
comma
l_int|0
comma
(paren
l_int|1
op_lshift
id|MINORBITS
)paren
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|hardsect_size
(braket
id|major
)braket
op_assign
(paren
r_int
op_star
)paren
id|kmalloc
(paren
(paren
l_int|1
op_lshift
id|MINORBITS
)paren
op_star
r_sizeof
(paren
r_int
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hardsect_size
(braket
id|major
)braket
)paren
r_goto
id|out_blksize_size
suffix:semicolon
id|memset
(paren
id|hardsect_size
(braket
id|major
)braket
comma
l_int|0
comma
(paren
l_int|1
op_lshift
id|MINORBITS
)paren
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|max_sectors
(braket
id|major
)braket
op_assign
(paren
r_int
op_star
)paren
id|kmalloc
(paren
(paren
l_int|1
op_lshift
id|MINORBITS
)paren
op_star
r_sizeof
(paren
r_int
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|max_sectors
(braket
id|major
)braket
)paren
r_goto
id|out_hardsect_size
suffix:semicolon
id|memset
(paren
id|max_sectors
(braket
id|major
)braket
comma
l_int|0
comma
(paren
l_int|1
op_lshift
id|MINORBITS
)paren
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
multiline_comment|/* finally do the gendisk stuff */
id|major_info-&gt;gendisk.part
op_assign
id|kmalloc
(paren
(paren
l_int|1
op_lshift
id|MINORBITS
)paren
op_star
r_sizeof
(paren
r_struct
id|hd_struct
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|major_info-&gt;gendisk.part
)paren
r_goto
id|out_max_sectors
suffix:semicolon
id|memset
(paren
id|major_info-&gt;gendisk.part
comma
l_int|0
comma
(paren
l_int|1
op_lshift
id|MINORBITS
)paren
op_star
r_sizeof
(paren
r_struct
id|hd_struct
)paren
)paren
suffix:semicolon
id|INIT_BLK_DEV
c_func
(paren
id|major
comma
id|do_dasd_request
comma
id|dasd_get_queue
comma
l_int|NULL
)paren
suffix:semicolon
id|major_info-&gt;gendisk.major
op_assign
id|major
suffix:semicolon
id|major_info-&gt;gendisk.next
op_assign
id|gendisk_head
suffix:semicolon
id|major_info-&gt;gendisk.sizes
op_assign
id|blk_size
(braket
id|major
)braket
suffix:semicolon
id|gendisk_head
op_assign
op_amp
id|major_info-&gt;gendisk
suffix:semicolon
r_return
id|major
suffix:semicolon
id|out_max_sectors
suffix:colon
id|kfree
c_func
(paren
id|max_sectors
(braket
id|major
)braket
)paren
suffix:semicolon
id|out_hardsect_size
suffix:colon
id|kfree
c_func
(paren
id|hardsect_size
(braket
id|major
)braket
)paren
suffix:semicolon
id|out_blksize_size
suffix:colon
id|kfree
c_func
(paren
id|blksize_size
(braket
id|major
)braket
)paren
suffix:semicolon
id|out_blk_size
suffix:colon
id|kfree
c_func
(paren
id|blk_size
(braket
id|major
)braket
)paren
suffix:semicolon
id|out_dasd_device
suffix:colon
id|kfree
c_func
(paren
id|major_info-&gt;dasd_device
)paren
suffix:semicolon
id|out_devfs
suffix:colon
id|devfs_unregister_blkdev
c_func
(paren
id|major
comma
id|DASD_NAME
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_static
r_int
DECL|function|dasd_unregister_major
id|dasd_unregister_major
(paren
id|major_info_t
op_star
id|major_info
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|major
suffix:semicolon
r_struct
id|gendisk
op_star
id|dd
comma
op_star
id|prev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|major_info
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|major
op_assign
id|major_info-&gt;gendisk.major
suffix:semicolon
id|INIT_BLK_DEV
c_func
(paren
id|major
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|blk_size
(braket
id|major
)braket
op_assign
l_int|NULL
suffix:semicolon
id|blksize_size
(braket
id|major
)braket
op_assign
l_int|NULL
suffix:semicolon
id|hardsect_size
(braket
id|major
)braket
op_assign
l_int|NULL
suffix:semicolon
id|max_sectors
(braket
id|major
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* do the gendisk stuff */
r_for
c_loop
(paren
id|dd
op_assign
id|gendisk_head
suffix:semicolon
id|dd
suffix:semicolon
id|dd
op_assign
id|dd-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dd
op_eq
op_amp
id|major_info-&gt;gendisk
)paren
(brace
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;next
op_assign
id|dd-&gt;next
suffix:semicolon
r_else
id|gendisk_head
op_assign
id|dd-&gt;next
suffix:semicolon
r_break
suffix:semicolon
)brace
id|prev
op_assign
id|dd
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dd
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
id|kfree
(paren
id|major_info-&gt;dasd_device
)paren
suffix:semicolon
id|kfree
(paren
id|blk_size
(braket
id|major
)braket
)paren
suffix:semicolon
id|kfree
(paren
id|blksize_size
(braket
id|major
)braket
)paren
suffix:semicolon
id|kfree
(paren
id|hardsect_size
(braket
id|major
)braket
)paren
suffix:semicolon
id|kfree
(paren
id|max_sectors
(braket
id|major
)braket
)paren
suffix:semicolon
id|kfree
(paren
id|major_info-&gt;gendisk.part
)paren
suffix:semicolon
id|rc
op_assign
id|devfs_unregister_blkdev
(paren
id|major
comma
id|DASD_NAME
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot;Cannot unregister from major no %d, rc = %d&bslash;n&quot;
comma
id|major
comma
id|rc
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_if
c_cond
(paren
id|major_info-&gt;gendisk.major
OG
l_int|128
)paren
id|kfree
(paren
id|major_info
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* &n; * function: dasd_device_from_kdev&n; * finds the device structure corresponding to the kdev supplied as argument&n; * in the major_info structures and returns it or NULL when not found&n; */
r_static
r_inline
id|dasd_device_t
op_star
DECL|function|dasd_device_from_kdev
id|dasd_device_from_kdev
(paren
id|kdev_t
id|kdev
)paren
(brace
id|major_info_t
op_star
id|major_info
op_assign
id|dasd_major_info
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|dasd_major_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|major_info
op_logical_and
id|major_info-&gt;gendisk.major
op_ne
id|MAJOR
(paren
id|kdev
)paren
)paren
(brace
id|major_info
op_assign
id|major_info-&gt;next
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|dasd_major_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|major_info
)paren
r_return
id|major_info-&gt;dasd_device
(braket
id|MINOR
(paren
id|kdev
)paren
op_rshift
id|DASD_PARTN_BITS
)braket
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* &n; * function: dasd_device_from_devno&n; * finds the address of the device structure corresponding to the devno &n; * supplied as argument in the major_info structures and returns &n; * it or NULL when not found&n; */
r_static
r_inline
id|dasd_device_t
op_star
op_star
DECL|function|dasd_device_from_devno
id|dasd_device_from_devno
(paren
r_int
id|devno
)paren
(brace
id|major_info_t
op_star
id|major_info
op_assign
id|dasd_major_info
suffix:semicolon
r_int
id|devindex
op_assign
id|dasd_devindex_from_devno
(paren
id|devno
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|dasd_major_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|major_info
op_assign
id|dasd_major_info
suffix:semicolon
id|major_info
suffix:semicolon
id|major_info
op_assign
id|major_info-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|devindex
OL
id|DASD_PER_MAJOR
)paren
(brace
id|spin_unlock_irqrestore
(paren
op_amp
id|dasd_major_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_amp
id|major_info-&gt;dasd_device
(braket
id|devindex
)braket
suffix:semicolon
)brace
id|devindex
op_sub_assign
id|DASD_PER_MAJOR
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|dasd_major_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* SECTION: managing dasd disciplines */
multiline_comment|/* anchor and spinlock for list of disciplines */
DECL|variable|dasd_disciplines
r_static
id|dasd_discipline_t
op_star
id|dasd_disciplines
suffix:semicolon
DECL|variable|discipline_lock
r_static
id|spinlock_t
id|discipline_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* &n; * function dasd_discipline_enq &n; * chains the discpline given as argument to the head of disiplines&n; * head chaining policy is required to allow module disciplines to&n; * be preferred against those, who are statically linked&n; */
r_void
DECL|function|dasd_discipline_enq
id|dasd_discipline_enq
(paren
id|dasd_discipline_t
op_star
id|d
)paren
(brace
id|spin_lock
(paren
op_amp
id|discipline_lock
)paren
suffix:semicolon
id|d-&gt;next
op_assign
id|dasd_disciplines
suffix:semicolon
id|dasd_disciplines
op_assign
id|d
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|discipline_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * function dasd_discipline_deq &n; * removes the discipline given as argument from the list of disciplines&n; */
r_int
DECL|function|dasd_discipline_deq
id|dasd_discipline_deq
(paren
id|dasd_discipline_t
op_star
id|d
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|spin_lock
(paren
op_amp
id|discipline_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dasd_disciplines
op_eq
id|d
)paren
(brace
id|dasd_disciplines
op_assign
id|dasd_disciplines-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|dasd_discipline_t
op_star
id|b
suffix:semicolon
id|b
op_assign
id|dasd_disciplines
suffix:semicolon
r_while
c_loop
(paren
id|b
op_logical_and
id|b-&gt;next
op_ne
id|d
)paren
id|b
op_assign
id|b-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|b
op_ne
l_int|NULL
)paren
(brace
id|b-&gt;next
op_assign
id|b-&gt;next-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|rc
op_assign
op_minus
id|ENOENT
suffix:semicolon
)brace
)brace
id|spin_unlock
(paren
op_amp
id|discipline_lock
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_static
r_inline
id|dasd_discipline_t
op_star
DECL|function|dasd_find_discipline
id|dasd_find_discipline
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
id|dasd_discipline_t
op_star
id|temp
suffix:semicolon
r_for
c_loop
(paren
id|temp
op_assign
id|dasd_disciplines
suffix:semicolon
id|temp
op_ne
l_int|NULL
suffix:semicolon
id|temp
op_assign
id|temp-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|temp-&gt;id_check
)paren
r_if
c_cond
(paren
id|temp-&gt;id_check
(paren
op_amp
id|device-&gt;devinfo
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|temp-&gt;check_characteristics
)paren
(brace
r_if
c_cond
(paren
id|temp-&gt;check_characteristics
(paren
id|device
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
r_return
id|temp
suffix:semicolon
)brace
multiline_comment|/* SECTION: profiling stuff */
DECL|variable|dasd_global_profile
r_static
id|dasd_profile_info_t
id|dasd_global_profile
suffix:semicolon
multiline_comment|/*&n; * macro: dasd_profile_add_counter&n; * increments counter in global and local profiling structures&n; * according to the value&n; */
DECL|macro|dasd_profile_add_counter
mdefine_line|#define dasd_profile_add_counter( value, counter, device ) &bslash;&n;{ &bslash;&n;        int ind; &bslash;&n;        long help; &bslash;&n;&t;for (ind = 0, help = value &gt;&gt; 3; &bslash;&n;             ind &lt; 31 &amp;&amp; help; &bslash;&n;             help = help &gt;&gt; 1, ind++) {} &bslash;&n;&t;dasd_global_profile.counter[ind]++; &bslash;&n;        device-&gt;profile.counter[ind]++; &bslash;&n;}
multiline_comment|/*&n; * function dasd_profile_add &n; * adds the profiling information from the cqr given as argument to the&n; * global and device specific profiling information &n; */
r_void
DECL|function|dasd_profile_add
id|dasd_profile_add
(paren
id|ccw_req_t
op_star
id|cqr
)paren
(brace
r_int
id|strtime
comma
id|irqtime
comma
id|endtime
comma
id|tottime
suffix:semicolon
r_int
id|tottimeps
comma
id|sectors
suffix:semicolon
id|dasd_device_t
op_star
id|device
op_assign
id|cqr-&gt;device
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cqr-&gt;req
)paren
multiline_comment|/* safeguard against abnormal cqrs */
r_return
suffix:semicolon
id|sectors
op_assign
(paren
(paren
r_struct
id|request
op_star
)paren
(paren
id|cqr-&gt;req
)paren
)paren
op_member_access_from_pointer
id|nr_sectors
suffix:semicolon
id|strtime
op_assign
(paren
(paren
id|cqr-&gt;startclk
op_minus
id|cqr-&gt;buildclk
)paren
op_rshift
l_int|12
)paren
suffix:semicolon
id|irqtime
op_assign
(paren
(paren
id|cqr-&gt;stopclk
op_minus
id|cqr-&gt;startclk
)paren
op_rshift
l_int|12
)paren
suffix:semicolon
id|endtime
op_assign
(paren
(paren
id|cqr-&gt;endclk
op_minus
id|cqr-&gt;stopclk
)paren
op_rshift
l_int|12
)paren
suffix:semicolon
id|tottime
op_assign
(paren
(paren
id|cqr-&gt;endclk
op_minus
id|cqr-&gt;buildclk
)paren
op_rshift
l_int|12
)paren
suffix:semicolon
id|tottimeps
op_assign
id|tottime
op_div
id|sectors
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dasd_global_profile.dasd_io_reqs
)paren
(brace
id|memset
(paren
op_amp
id|dasd_global_profile
comma
l_int|0
comma
r_sizeof
(paren
id|dasd_profile_info_t
)paren
)paren
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device-&gt;profile.dasd_io_reqs
)paren
(brace
id|memset
(paren
op_amp
id|device-&gt;profile
comma
l_int|0
comma
r_sizeof
(paren
id|dasd_profile_info_t
)paren
)paren
suffix:semicolon
)brace
suffix:semicolon
id|dasd_global_profile.dasd_io_reqs
op_increment
suffix:semicolon
id|device-&gt;profile.dasd_io_reqs
op_increment
suffix:semicolon
id|dasd_profile_add_counter
(paren
id|sectors
comma
id|dasd_io_secs
comma
id|device
)paren
suffix:semicolon
id|dasd_profile_add_counter
(paren
id|tottime
comma
id|dasd_io_times
comma
id|device
)paren
suffix:semicolon
id|dasd_profile_add_counter
(paren
id|tottimeps
comma
id|dasd_io_timps
comma
id|device
)paren
suffix:semicolon
id|dasd_profile_add_counter
(paren
id|strtime
comma
id|dasd_io_time1
comma
id|device
)paren
suffix:semicolon
id|dasd_profile_add_counter
(paren
id|irqtime
comma
id|dasd_io_time2
comma
id|device
)paren
suffix:semicolon
id|dasd_profile_add_counter
(paren
id|irqtime
op_div
id|sectors
comma
id|dasd_io_time2ps
comma
id|device
)paren
suffix:semicolon
id|dasd_profile_add_counter
(paren
id|endtime
comma
id|dasd_io_time3
comma
id|device
)paren
suffix:semicolon
)brace
multiline_comment|/* SECTION: (de)queueing of requests to channel program queues */
multiline_comment|/* &n; * function dasd_chanq_enq &n; * appends the cqr given as argument to the queue&n; * has to be called with the queue lock (namely the s390_irq_lock) acquired&n; */
r_static
r_inline
r_void
DECL|function|dasd_chanq_enq
id|dasd_chanq_enq
(paren
id|dasd_chanq_t
op_star
id|q
comma
id|ccw_req_t
op_star
id|cqr
)paren
(brace
r_if
c_cond
(paren
id|q-&gt;head
op_ne
l_int|NULL
)paren
(brace
id|q-&gt;tail-&gt;next
op_assign
id|cqr
suffix:semicolon
)brace
r_else
id|q-&gt;head
op_assign
id|cqr
suffix:semicolon
id|cqr-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|q-&gt;tail
op_assign
id|cqr
suffix:semicolon
id|check_then_set
(paren
op_amp
id|cqr-&gt;status
comma
id|CQR_STATUS_FILLED
comma
id|CQR_STATUS_QUEUED
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * function dasd_chanq_enq_head&n; * chains the cqr given as argument to the queue head&n; * has to be called with the queue lock (namely the s390_irq_lock) acquired&n; */
r_static
r_inline
r_void
DECL|function|dasd_chanq_enq_head
id|dasd_chanq_enq_head
(paren
id|dasd_chanq_t
op_star
id|q
comma
id|ccw_req_t
op_star
id|cqr
)paren
(brace
id|cqr-&gt;next
op_assign
id|q-&gt;head
suffix:semicolon
id|q-&gt;head
op_assign
id|cqr
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;tail
op_eq
l_int|NULL
)paren
id|q-&gt;tail
op_assign
id|cqr
suffix:semicolon
id|check_then_set
(paren
op_amp
id|cqr-&gt;status
comma
id|CQR_STATUS_FILLED
comma
id|CQR_STATUS_QUEUED
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * function dasd_chanq_deq&n; * dechains the cqr given as argument from the queue&n; * has to be called with the queue lock (namely the s390_irq_lock) acquired&n; */
r_int
DECL|function|dasd_chanq_deq
id|dasd_chanq_deq
(paren
id|dasd_chanq_t
op_star
id|q
comma
id|ccw_req_t
op_star
id|cqr
)paren
(brace
id|ccw_req_t
op_star
id|prev
suffix:semicolon
r_if
c_cond
(paren
id|cqr
op_eq
l_int|NULL
)paren
id|BUG
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr
op_eq
id|q-&gt;head
)paren
(brace
id|q-&gt;head
op_assign
id|cqr-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;head
op_eq
l_int|NULL
)paren
id|q-&gt;tail
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|prev
op_assign
id|q-&gt;head
suffix:semicolon
r_while
c_loop
(paren
id|prev
op_logical_and
id|prev-&gt;next
op_ne
id|cqr
)paren
id|prev
op_assign
id|prev-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|prev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|prev-&gt;next
op_assign
id|cqr-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|prev-&gt;next
op_eq
l_int|NULL
)paren
id|q-&gt;tail
op_assign
id|prev
suffix:semicolon
)brace
id|cqr-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* SECTION: All the gendisk stuff */
multiline_comment|/* &n; * function dasd_partn_detect&n; * calls the function in genhd, which is appropriate to setup a partitioned disk&n; */
r_static
r_void
DECL|function|dasd_partn_detect
id|dasd_partn_detect
(paren
id|dasd_device_t
op_star
id|dev
)paren
(brace
id|major_info_t
op_star
id|major_info
op_assign
id|dev-&gt;major_info
suffix:semicolon
r_struct
id|gendisk
op_star
id|dd
op_assign
op_amp
id|major_info-&gt;gendisk
suffix:semicolon
r_int
id|minor
op_assign
id|MINOR
(paren
id|dev-&gt;kdev
)paren
suffix:semicolon
id|register_disk
(paren
id|dd
comma
id|MKDEV
(paren
id|dd-&gt;major
comma
id|minor
)paren
comma
l_int|1
op_lshift
id|DASD_PARTN_BITS
comma
op_amp
id|dasd_device_operations
comma
(paren
id|dev-&gt;sizes.blocks
op_lshift
id|dev-&gt;sizes.s2b_shift
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* SECTION: Managing wrappers for ccwcache */
multiline_comment|/* array and spinlock of emergency requests */
DECL|variable|dasd_emergency_req
r_static
id|ccw_req_t
op_star
id|dasd_emergency_req
(braket
id|DASD_EMERGENCY_REQUESTS
)braket
suffix:semicolon
DECL|variable|dasd_emergency_req_lock
r_static
id|spinlock_t
id|dasd_emergency_req_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* &n; * function dasd_init_emergeny_req&n; * allocates emergeny requests&n; */
r_static
r_inline
r_void
id|__init
DECL|function|dasd_init_emergency_req
id|dasd_init_emergency_req
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DASD_EMERGENCY_REQUESTS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dasd_emergency_req
(braket
id|i
)braket
op_assign
(paren
id|ccw_req_t
op_star
)paren
id|get_free_page
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
(paren
id|dasd_emergency_req
(braket
id|i
)braket
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * function dasd_cleanup_emergeny_req&n; * tries to free emergeny requests skipping those, which are currently in use&n; */
r_static
r_inline
r_void
DECL|function|dasd_cleanup_emergency_req
id|dasd_cleanup_emergency_req
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DASD_EMERGENCY_REQUESTS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dasd_emergency_req
(braket
id|i
)braket
)paren
id|free_page
(paren
(paren
r_int
)paren
(paren
id|dasd_emergency_req
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
r_else
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot;losing page for emergency request in use&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * function dasd_alloc_request&n; * tries to return space for a channel program of length cplength with&n; * additional data of size datasize. &n; * If the ccwcache cannot fulfill the request it tries the emergeny requests&n; * before giving up finally&n; * FIXME: initialization of ccw_req_t should be done by function of ccwcache&n; */
id|ccw_req_t
op_star
DECL|function|dasd_alloc_request
id|dasd_alloc_request
(paren
r_char
op_star
id|magic
comma
r_int
id|cplength
comma
r_int
id|datasize
)paren
(brace
id|ccw_req_t
op_star
id|rv
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rv
op_assign
id|ccw_alloc_request
(paren
id|magic
comma
id|cplength
comma
id|datasize
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_return
id|rv
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
(paren
r_sizeof
(paren
id|ccw_req_t
)paren
op_plus
l_int|7
)paren
op_amp
op_minus
l_int|8
)paren
op_plus
id|cplength
op_star
r_sizeof
(paren
id|ccw1_t
)paren
op_plus
id|datasize
)paren
OG
id|PAGE_SIZE
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
(paren
op_amp
id|dasd_emergency_req_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DASD_EMERGENCY_REQUESTS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dasd_emergency_req
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
id|rv
op_assign
id|dasd_emergency_req
(braket
id|i
)braket
suffix:semicolon
id|dasd_emergency_req
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|dasd_emergency_req_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
(brace
id|memset
(paren
id|rv
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|rv-&gt;cache
op_assign
(paren
id|kmem_cache_t
op_star
)paren
(paren
id|dasd_emergency_req
op_plus
id|i
)paren
suffix:semicolon
id|strncpy
(paren
(paren
r_char
op_star
)paren
(paren
op_amp
id|rv-&gt;magic
)paren
comma
id|magic
comma
l_int|4
)paren
suffix:semicolon
id|ASCEBC
(paren
(paren
r_char
op_star
)paren
(paren
op_amp
id|rv-&gt;magic
)paren
comma
l_int|4
)paren
suffix:semicolon
id|rv-&gt;cplength
op_assign
id|cplength
suffix:semicolon
id|rv-&gt;datasize
op_assign
id|datasize
suffix:semicolon
id|rv-&gt;data
op_assign
(paren
r_void
op_star
)paren
(paren
(paren
r_int
)paren
id|rv
op_plus
id|PAGE_SIZE
op_minus
id|datasize
)paren
suffix:semicolon
id|rv-&gt;cpaddr
op_assign
(paren
id|ccw1_t
op_star
)paren
(paren
(paren
r_int
)paren
id|rv
op_plus
r_sizeof
(paren
id|ccw_req_t
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|panic
(paren
l_string|&quot;No way to fulfill request for I/O request&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/* &n; * function dasd_free_request&n; * returns a ccw_req_t to the appropriate cache or emergeny request line&n; */
r_void
DECL|function|dasd_free_request
id|dasd_free_request
(paren
id|ccw_req_t
op_star
id|request
)paren
(brace
r_if
c_cond
(paren
(paren
id|request-&gt;cache
op_ge
(paren
id|kmem_cache_t
op_star
)paren
id|dasd_emergency_req
)paren
op_logical_and
(paren
id|request-&gt;cache
OL
(paren
id|kmem_cache_t
op_star
)paren
(paren
id|dasd_emergency_req
op_plus
id|DASD_EMERGENCY_REQUESTS
)paren
)paren
)paren
(brace
op_star
(paren
(paren
id|ccw_req_t
op_star
op_star
)paren
(paren
id|request-&gt;cache
)paren
)paren
op_assign
id|request
suffix:semicolon
)brace
r_else
(brace
id|ccw_free_request
(paren
id|request
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* SECTION: Managing the device queues etc. */
multiline_comment|/* &n; * function dasd_start_IO&n; * attempts to start the IO and returns an appropriate return code&n; */
r_int
DECL|function|dasd_start_IO
id|dasd_start_IO
(paren
id|ccw_req_t
op_star
id|cqr
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|dasd_device_t
op_star
id|device
op_assign
id|cqr-&gt;device
suffix:semicolon
r_int
id|irq
suffix:semicolon
r_int
r_int
r_int
id|now
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cqr
)paren
(brace
id|BUG
(paren
)paren
suffix:semicolon
)brace
id|irq
op_assign
id|device-&gt;devinfo.irq
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
(paren
(paren
r_char
op_star
)paren
op_amp
id|cqr-&gt;magic
comma
id|device-&gt;discipline-&gt;ebcname
comma
l_int|4
)paren
)paren
(brace
id|DASD_MESSAGE
(paren
id|KERN_WARNING
comma
id|device
comma
l_string|&quot; ccw_req_t 0x%08X magic doesn&squot;t match&quot;
l_string|&quot; discipline 0x%08X&bslash;n&quot;
comma
id|cqr-&gt;magic
comma
op_star
(paren
r_int
r_int
op_star
)paren
id|device-&gt;discipline-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|asm
r_volatile
(paren
l_string|&quot;STCK %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|now
)paren
)paren
suffix:semicolon
id|rc
op_assign
id|do_IO
(paren
id|irq
comma
id|cqr-&gt;cpaddr
comma
(paren
r_int
)paren
id|cqr
comma
id|cqr-&gt;lpm
comma
id|cqr-&gt;options
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|rc
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
op_minus
id|ENODEV
suffix:colon
id|check_then_set
(paren
op_amp
id|cqr-&gt;status
comma
id|CQR_STATUS_QUEUED
comma
id|CQR_STATUS_FAILED
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|EIO
suffix:colon
id|check_then_set
(paren
op_amp
id|cqr-&gt;status
comma
id|CQR_STATUS_QUEUED
comma
id|CQR_STATUS_FAILED
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|EBUSY
suffix:colon
id|DASD_MESSAGE
(paren
id|KERN_WARNING
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;device busy, retry later&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DASD_MESSAGE
(paren
id|KERN_ERR
comma
id|device
comma
l_string|&quot;line %d unknown RC=%d, please report&quot;
l_string|&quot; to linux390@de.ibm.com&bslash;n&quot;
comma
id|__LINE__
comma
id|rc
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|check_then_set
(paren
op_amp
id|cqr-&gt;status
comma
id|CQR_STATUS_QUEUED
comma
id|CQR_STATUS_IN_IO
)paren
suffix:semicolon
id|cqr-&gt;startclk
op_assign
id|now
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* &n; * function sleep_on_req&n; * attempts to start the IO and waits for completion&n; * FIXME: replace handmade sleeping by wait_event&n; */
r_static
r_int
DECL|function|sleep_on_req
id|sleep_on_req
(paren
id|ccw_req_t
op_star
id|req
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|cs
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|dasd_device_t
op_star
id|device
op_assign
(paren
id|dasd_device_t
op_star
)paren
id|req-&gt;device
suffix:semicolon
id|s390irq_spin_lock_irqsave
(paren
id|device-&gt;devinfo.irq
comma
id|flags
)paren
suffix:semicolon
id|dasd_chanq_enq
(paren
op_amp
id|device-&gt;queue
comma
id|req
)paren
suffix:semicolon
multiline_comment|/* let the bh start the request to keep them in order */
id|dasd_schedule_bh
(paren
id|device
)paren
suffix:semicolon
r_do
(brace
id|s390irq_spin_unlock_irqrestore
(paren
id|device-&gt;devinfo.irq
comma
id|flags
)paren
suffix:semicolon
id|wait_event
(paren
id|device-&gt;wait_q
comma
(paren
(paren
(paren
id|cs
op_assign
id|req-&gt;status
)paren
op_eq
id|CQR_STATUS_DONE
)paren
op_logical_or
(paren
id|cs
op_eq
id|CQR_STATUS_FAILED
)paren
)paren
)paren
suffix:semicolon
id|s390irq_spin_lock_irqsave
(paren
id|device-&gt;devinfo.irq
comma
id|flags
)paren
suffix:semicolon
id|cs
op_assign
id|req-&gt;status
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cs
op_ne
id|CQR_STATUS_DONE
op_logical_and
id|cs
op_ne
id|CQR_STATUS_FAILED
)paren
suffix:semicolon
id|s390irq_spin_unlock_irqrestore
(paren
id|device-&gt;devinfo.irq
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cs
op_eq
id|CQR_STATUS_FAILED
)paren
(brace
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* end sleep_on_req */
multiline_comment|/* &n; * function dasd_end_request&n; * posts the buffer_cache about a finalized request&n; * FIXME: for requests splitted to serveral cqrs&n; */
r_static
r_inline
r_void
DECL|function|dasd_end_request
id|dasd_end_request
(paren
r_struct
id|request
op_star
id|req
comma
r_int
id|uptodate
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|req-&gt;bh
)paren
op_ne
l_int|NULL
)paren
(brace
id|req-&gt;bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
id|bh-&gt;b_reqnext
op_assign
l_int|NULL
suffix:semicolon
id|bh-&gt;b_end_io
(paren
id|bh
comma
id|uptodate
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|end_that_request_first
(paren
id|req
comma
id|uptodate
comma
id|DASD_NAME
)paren
)paren
(brace
macro_line|#ifndef DEVICE_NO_RANDOM
id|add_blkdev_randomness
(paren
id|MAJOR
(paren
id|req-&gt;rq_dev
)paren
)paren
suffix:semicolon
macro_line|#endif
id|end_that_request_last
(paren
id|req
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* &n; * function dasd_get_queue&n; * returns the queue corresponding to a device behind a kdev&n; */
r_static
id|request_queue_t
op_star
DECL|function|dasd_get_queue
id|dasd_get_queue
(paren
id|kdev_t
id|kdev
)paren
(brace
id|dasd_device_t
op_star
id|device
op_assign
id|dasd_device_from_kdev
(paren
id|kdev
)paren
suffix:semicolon
r_return
op_amp
id|device-&gt;request_queue
suffix:semicolon
)brace
multiline_comment|/* &n; * function dasd_check_expire_time&n; * check the request given as argument for expiration&n; * and returns 0 if not yet expired, nonzero else&n; */
r_static
r_inline
r_int
DECL|function|dasd_check_expire_time
id|dasd_check_expire_time
(paren
id|ccw_req_t
op_star
id|cqr
)paren
(brace
r_int
r_int
r_int
id|now
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;STCK %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|now
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;expires
op_plus
id|cqr-&gt;startclk
OL
id|now
)paren
(brace
id|DASD_MESSAGE
(paren
id|KERN_ERR
comma
(paren
(paren
id|dasd_device_t
op_star
)paren
id|cqr-&gt;device
)paren
comma
l_string|&quot;IO timeout 0x%08lx%08lx usecs with req %p&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|cqr-&gt;expires
op_rshift
l_int|44
)paren
comma
(paren
r_int
)paren
(paren
id|cqr-&gt;expires
op_rshift
l_int|12
)paren
comma
id|cqr
)paren
suffix:semicolon
id|cqr-&gt;expires
op_lshift_assign
l_int|1
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* &n; * function dasd_finalize_request&n; * implemets the actions to perform, when a request is finally finished&n; * namely in status CQR_STATUS_DONE || CQR_STATUS_FAILED&n; */
r_static
r_inline
r_void
DECL|function|dasd_finalize_request
id|dasd_finalize_request
(paren
id|ccw_req_t
op_star
id|cqr
)paren
(brace
id|dasd_device_t
op_star
id|device
op_assign
id|cqr-&gt;device
suffix:semicolon
id|dasd_discipline_t
op_star
id|discipline
op_assign
id|device-&gt;discipline
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;STCK %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|cqr-&gt;endclk
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;req
)paren
(brace
id|dasd_end_request
(paren
id|cqr-&gt;req
comma
(paren
id|cqr-&gt;status
op_eq
id|CQR_STATUS_DONE
)paren
)paren
suffix:semicolon
id|dasd_profile_add
(paren
id|cqr
)paren
suffix:semicolon
multiline_comment|/* free request if nobody is waiting on it */
id|dasd_free_request
(paren
id|cqr
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* during format we don&squot;t have the request structure */
multiline_comment|/* notify sleeping task about finished postprocessing */
id|wake_up
(paren
op_amp
id|device-&gt;wait_q
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* &n; * function dasd_process_queues&n; * transfers the requests on the queue given as argument to the chanq&n; * if possible, the request ist started on a fastpath&n; */
r_static
r_void
DECL|function|dasd_process_queues
id|dasd_process_queues
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|request
op_star
id|req
suffix:semicolon
id|request_queue_t
op_star
id|queue
op_assign
op_amp
id|device-&gt;request_queue
suffix:semicolon
id|dasd_chanq_t
op_star
id|qp
op_assign
op_amp
id|device-&gt;queue
suffix:semicolon
r_int
id|irq
op_assign
id|device
op_member_access_from_pointer
id|devinfo.irq
suffix:semicolon
id|ccw_req_t
op_star
id|final_requests
op_assign
l_int|NULL
suffix:semicolon
r_static
r_int
id|chanq_min_size
op_assign
id|DASD_MIN_SIZE_FOR_QUEUE
suffix:semicolon
r_int
id|chanq_max_size
op_assign
id|DASD_CHANQ_MAX_SIZE
suffix:semicolon
id|ccw_req_t
op_star
id|cqr
op_assign
l_int|NULL
comma
op_star
id|temp
suffix:semicolon
id|dasd_erp_postaction_fn_t
id|erp_postaction
suffix:semicolon
id|s390irq_spin_lock_irqsave
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* First we dechain the requests, processed with completed status */
r_while
c_loop
(paren
id|qp
op_member_access_from_pointer
id|head
op_logical_and
(paren
(paren
id|qp
op_member_access_from_pointer
id|head
op_member_access_from_pointer
id|status
op_eq
id|CQR_STATUS_DONE
)paren
op_logical_or
(paren
id|qp
op_member_access_from_pointer
id|head
op_member_access_from_pointer
id|status
op_eq
id|CQR_STATUS_FAILED
)paren
op_logical_or
(paren
id|qp
op_member_access_from_pointer
id|head
op_member_access_from_pointer
id|status
op_eq
id|CQR_STATUS_ERROR
)paren
)paren
)paren
(brace
id|dasd_erp_action_fn_t
id|erp_action
suffix:semicolon
id|ccw_req_t
op_star
id|erp_cqr
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*  preprocess requests with CQR_STATUS_ERROR */
r_if
c_cond
(paren
id|qp
op_member_access_from_pointer
id|head
op_member_access_from_pointer
id|status
op_eq
id|CQR_STATUS_ERROR
)paren
(brace
r_if
c_cond
(paren
(paren
id|qp
op_member_access_from_pointer
id|head
op_member_access_from_pointer
id|dstat
op_member_access_from_pointer
id|flag
op_amp
id|DEVSTAT_HALT_FUNCTION
)paren
op_logical_or
(paren
id|qp-&gt;head-&gt;retries
op_decrement
op_eq
l_int|0
)paren
op_logical_or
(paren
id|device-&gt;discipline-&gt;erp_action
op_eq
l_int|NULL
)paren
op_logical_or
(paren
(paren
id|erp_action
op_assign
id|device-&gt;discipline
op_member_access_from_pointer
id|erp_action
c_func
(paren
id|qp-&gt;head
)paren
)paren
op_eq
l_int|NULL
)paren
op_logical_or
(paren
(paren
id|erp_cqr
op_assign
id|erp_action
c_func
(paren
id|qp-&gt;head
)paren
)paren
op_eq
l_int|NULL
)paren
)paren
(brace
id|check_then_set
(paren
op_amp
id|qp-&gt;head-&gt;status
comma
id|CQR_STATUS_ERROR
comma
id|CQR_STATUS_FAILED
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
(brace
id|dasd_chanq_enq_head
(paren
id|qp
comma
id|erp_cqr
)paren
suffix:semicolon
multiline_comment|/* chain of completed requests is now broken */
r_break
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|qp
op_member_access_from_pointer
id|head
op_member_access_from_pointer
id|refers
)paren
(brace
multiline_comment|/* we deal with an ERP */
r_char
op_star
id|uptodatestr
suffix:semicolon
r_if
c_cond
(paren
id|qp
op_member_access_from_pointer
id|head
op_member_access_from_pointer
id|status
op_eq
id|CQR_STATUS_DONE
)paren
(brace
id|uptodatestr
op_assign
l_string|&quot;ERP successful&quot;
suffix:semicolon
)brace
r_else
(brace
id|uptodatestr
op_assign
l_string|&quot;ERP unsuccessful&quot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|device-&gt;discipline-&gt;erp_postaction
op_eq
l_int|NULL
op_logical_or
(paren
(paren
id|erp_postaction
op_assign
id|device-&gt;discipline-&gt;erp_postaction
(paren
id|qp-&gt;head
)paren
)paren
op_eq
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* &n;                                                         * maybe we shoud set it to FAILED, &n;                                                         * because we are very paranoid ;) &n;                                                         */
id|erp_postaction
op_assign
id|default_erp_postaction
suffix:semicolon
)brace
id|DASD_MESSAGE
(paren
id|KERN_INFO
comma
id|device
comma
l_string|&quot;%s: postaction [&lt;%p&gt;]&bslash;n&quot;
comma
id|uptodatestr
comma
id|erp_postaction
)paren
suffix:semicolon
id|erp_postaction
(paren
id|qp-&gt;head
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* dechain request now */
r_if
c_cond
(paren
id|final_requests
op_eq
l_int|NULL
)paren
id|final_requests
op_assign
id|qp
op_member_access_from_pointer
id|head
suffix:semicolon
id|cqr
op_assign
id|qp
op_member_access_from_pointer
id|head
suffix:semicolon
id|qp
op_member_access_from_pointer
id|head
op_assign
id|qp
op_member_access_from_pointer
id|head
op_member_access_from_pointer
id|next
suffix:semicolon
r_if
c_cond
(paren
id|qp-&gt;head
op_eq
l_int|NULL
)paren
id|qp-&gt;tail
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cqr
)paren
id|cqr
op_member_access_from_pointer
id|next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Now we try to fetch requests from the request queue */
r_for
c_loop
(paren
id|temp
op_assign
id|cqr
suffix:semicolon
id|temp
op_ne
l_int|NULL
suffix:semicolon
id|temp
op_assign
id|temp
op_member_access_from_pointer
id|next
)paren
r_if
c_cond
(paren
id|temp
op_member_access_from_pointer
id|status
op_eq
id|CQR_STATUS_QUEUED
)paren
id|chanq_max_size
op_decrement
suffix:semicolon
r_while
c_loop
(paren
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|queue-&gt;queue_head
)paren
)paren
op_logical_and
(paren
id|req
op_assign
id|dasd_next_request
c_func
(paren
id|queue
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* queue empty or certain critera fulfilled -&gt; transfer */
r_if
c_cond
(paren
id|qp
op_member_access_from_pointer
id|head
op_eq
l_int|NULL
op_logical_or
id|chanq_max_size
OG
l_int|0
op_logical_or
(paren
id|req-&gt;nr_sectors
op_ge
id|chanq_min_size
)paren
)paren
(brace
id|ccw_req_t
op_star
id|cqr
suffix:semicolon
multiline_comment|/* relocate request according to partition table */
id|req-&gt;sector
op_add_assign
id|device-&gt;major_info-&gt;gendisk.part
(braket
id|MINOR
(paren
id|req-&gt;rq_dev
)paren
)braket
dot
id|start_sect
suffix:semicolon
id|cqr
op_assign
id|device-&gt;discipline-&gt;build_cp_from_req
(paren
id|device
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr
op_eq
l_int|NULL
)paren
(brace
id|DASD_MESSAGE
(paren
id|KERN_WARNING
comma
id|device
comma
l_string|&quot;CCW creation failed on request %p&bslash;n&quot;
comma
id|req
)paren
suffix:semicolon
multiline_comment|/* revert relocation of request */
id|req-&gt;sector
op_sub_assign
id|device-&gt;major_info-&gt;gendisk.part
(braket
id|MINOR
(paren
id|req-&gt;rq_dev
)paren
)braket
dot
id|start_sect
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* terminate request queue loop */
)brace
macro_line|#ifdef CONFIG_DYNAMIC_QUEUE_MIN_SIZE
id|chanq_min_size
op_assign
(paren
id|chanq_min_size
op_plus
id|req-&gt;nr_sectors
)paren
op_rshift
l_int|1
suffix:semicolon
macro_line|#endif /* CONFIG_DYNAMIC_QUEUE_MIN_SIZE */
id|dasd_dequeue_request
c_func
(paren
id|queue
comma
id|req
)paren
suffix:semicolon
id|dasd_chanq_enq
(paren
id|qp
comma
id|cqr
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* queue not empty OR criteria not met */
r_break
suffix:semicolon
multiline_comment|/* terminate request queue loop */
)brace
)brace
multiline_comment|/* we process the requests with non-final status */
r_if
c_cond
(paren
id|qp
op_member_access_from_pointer
id|head
)paren
(brace
r_switch
c_cond
(paren
id|qp-&gt;head-&gt;status
)paren
(brace
r_case
id|CQR_STATUS_QUEUED
suffix:colon
multiline_comment|/* try to start the first I/O that can be started */
r_if
c_cond
(paren
id|device-&gt;discipline-&gt;start_IO
(paren
id|qp-&gt;head
)paren
op_ne
l_int|0
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CQR_STATUS_IN_IO
suffix:colon
multiline_comment|/* Check, if to invoke the missing interrupt handler */
r_if
c_cond
(paren
id|dasd_check_expire_time
(paren
id|qp-&gt;head
)paren
)paren
(brace
multiline_comment|/* to be filled with MIH */
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Now clean the requests with final status */
r_while
c_loop
(paren
id|final_requests
)paren
(brace
id|cqr
op_assign
id|final_requests
suffix:semicolon
id|final_requests
op_assign
id|cqr
op_member_access_from_pointer
id|next
suffix:semicolon
id|dasd_finalize_request
c_func
(paren
id|cqr
)paren
suffix:semicolon
)brace
id|s390irq_spin_unlock_irqrestore
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * function dasd_run_bh&n; * acquires the locks needed and then runs the bh&n; */
r_static
r_void
DECL|function|dasd_run_bh
id|dasd_run_bh
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|device-&gt;bh_scheduled
comma
l_int|0
)paren
suffix:semicolon
id|dasd_process_queues
(paren
id|device
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * function dasd_schedule_bh&n; * schedules the request_fn to run with next run_bh cycle&n; */
r_void
DECL|function|dasd_schedule_bh
id|dasd_schedule_bh
(paren
id|dasd_device_t
op_star
id|device
)paren
(brace
multiline_comment|/* Protect against rescheduling, when already running */
r_if
c_cond
(paren
id|atomic_compare_and_swap
c_func
(paren
l_int|0
comma
l_int|1
comma
op_amp
id|device-&gt;bh_scheduled
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|device-&gt;bh_tq.list
)paren
suffix:semicolon
id|device-&gt;bh_tq.sync
op_assign
l_int|0
suffix:semicolon
id|device-&gt;bh_tq.routine
op_assign
(paren
r_void
op_star
)paren
(paren
r_void
op_star
)paren
id|dasd_run_bh
suffix:semicolon
id|device-&gt;bh_tq.data
op_assign
id|device
suffix:semicolon
id|queue_task
(paren
op_amp
id|device-&gt;bh_tq
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* &n; * function do_dasd_request&n; * is called from ll_rw_blk.c and provides the caller of &n; * dasd_process_queues&n; */
macro_line|#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,3,98))
r_static
r_void
DECL|function|do_dasd_request
id|do_dasd_request
(paren
id|request_queue_t
op_star
id|queue
)paren
(brace
id|dasd_device_t
op_star
id|device
op_assign
(paren
id|dasd_device_t
op_star
)paren
(paren
(paren
r_int
)paren
id|queue
op_minus
(paren
r_int
)paren
m_offsetof
(paren
id|dasd_device_t
comma
id|request_queue
)paren
)paren
suffix:semicolon
id|dasd_process_queues
(paren
id|device
)paren
suffix:semicolon
)brace
macro_line|#else
r_static
r_void
DECL|function|do_dasd_request
id|do_dasd_request
(paren
r_void
)paren
(brace
id|major_info_t
op_star
id|major_info
suffix:semicolon
id|dasd_device_t
op_star
id|device
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|major_info
op_assign
id|dasd_major_info
suffix:semicolon
id|major_info
op_ne
l_int|NULL
suffix:semicolon
id|major_info
op_assign
id|major_info-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DASD_PER_MAJOR
suffix:semicolon
id|i
op_increment
)paren
(brace
id|device
op_assign
id|major_info-&gt;dasd_device
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device
)paren
r_continue
suffix:semicolon
multiline_comment|/* remove indentation level */
id|dasd_process_queues
(paren
id|device
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif&t;&t;&t;&t;/* LINUX_IS_24 */
multiline_comment|/* &n; * function dasd_int_handler&n; * is the DASD driver&squot;s default interrupt handler for SSCH-IO&n; */
r_void
DECL|function|dasd_int_handler
id|dasd_int_handler
(paren
r_int
id|irq
comma
r_void
op_star
id|ds
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|ip
suffix:semicolon
r_int
id|devno
suffix:semicolon
id|ccw_req_t
op_star
id|cqr
suffix:semicolon
id|dasd_device_t
op_star
id|device
suffix:semicolon
r_int
r_int
r_int
id|now
suffix:semicolon
macro_line|#ifdef ERP_DEBUG
r_static
r_int
id|counter
suffix:semicolon
macro_line|#endif
id|dasd_era_t
id|era
op_assign
id|dasd_era_none
suffix:semicolon
multiline_comment|/* default is everything is okay */
id|devstat_t
op_star
id|stat
op_assign
(paren
id|devstat_t
op_star
)paren
id|ds
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;STCK %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|now
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_eq
l_int|NULL
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|ip
op_assign
id|stat-&gt;intparm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ip
)paren
(brace
multiline_comment|/* no intparm: unsolicited interrupt */
id|printk
(paren
id|KERN_INFO
id|PRINTK_HEADER
l_string|&quot;unsolicited interrupt: irq0x%x devno%04X&bslash;n&quot;
comma
id|irq
comma
id|stat-&gt;devno
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip
op_amp
l_int|0x80000001
)paren
(brace
id|printk
(paren
id|KERN_INFO
id|PRINTK_HEADER
l_string|&quot;spurious interrupt: irq0x%x devno%04X, parm %08x&bslash;n&quot;
comma
id|irq
comma
id|stat-&gt;devno
comma
id|ip
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|cqr
op_assign
(paren
id|ccw_req_t
op_star
)paren
(paren
r_int
)paren
id|ip
suffix:semicolon
id|device
op_assign
(paren
id|dasd_device_t
op_star
)paren
id|cqr-&gt;device
suffix:semicolon
r_if
c_cond
(paren
id|device
op_eq
l_int|NULL
op_logical_or
id|device
op_ne
id|ds
op_minus
m_offsetof
(paren
id|dasd_device_t
comma
id|dev_status
)paren
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|devno
op_assign
id|device-&gt;devinfo.devno
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;devinfo.irq
op_ne
id|irq
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strncmp
(paren
id|device-&gt;discipline-&gt;ebcname
comma
(paren
r_char
op_star
)paren
op_amp
id|cqr-&gt;magic
comma
l_int|4
)paren
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef ERP_DEBUG
id|counter
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|counter
op_mod
l_int|137
op_eq
l_int|0
)paren
(brace
id|stat-&gt;flag
op_or_assign
id|DEVSTAT_FLAG_SENSE_AVAIL
suffix:semicolon
id|stat-&gt;cstat
op_assign
l_int|0x00
suffix:semicolon
id|stat-&gt;dstat
op_assign
l_int|0x02
suffix:semicolon
id|memset
c_func
(paren
id|stat-&gt;ii.sense.data
comma
l_int|0
comma
l_int|32
)paren
suffix:semicolon
id|stat-&gt;ii.sense.data
(braket
l_int|2
)braket
op_assign
l_int|0x06
suffix:semicolon
id|stat-&gt;ii.sense.data
(braket
l_int|4
)braket
op_assign
l_int|0x04
suffix:semicolon
id|stat-&gt;ii.sense.data
(braket
l_int|5
)braket
op_assign
l_int|0x60
suffix:semicolon
id|stat-&gt;ii.sense.data
(braket
l_int|6
)braket
op_assign
l_int|0x41
suffix:semicolon
id|stat-&gt;ii.sense.data
(braket
l_int|8
)braket
op_assign
l_int|0xff
suffix:semicolon
id|stat-&gt;ii.sense.data
(braket
l_int|9
)braket
op_assign
l_int|0xff
suffix:semicolon
id|stat-&gt;ii.sense.data
(braket
l_int|15
)braket
op_assign
l_int|0x05
suffix:semicolon
id|stat-&gt;ii.sense.data
(braket
l_int|16
)braket
op_assign
l_int|0x21
suffix:semicolon
id|stat-&gt;ii.sense.data
(braket
l_int|18
)braket
op_assign
l_int|0x60
suffix:semicolon
id|stat-&gt;ii.sense.data
(braket
l_int|19
)braket
op_assign
l_int|0x3b
suffix:semicolon
id|stat-&gt;ii.sense.data
(braket
l_int|20
)braket
op_assign
l_int|0x24
suffix:semicolon
id|stat-&gt;ii.sense.data
(braket
l_int|21
)braket
op_assign
l_int|0x61
suffix:semicolon
id|stat-&gt;ii.sense.data
(braket
l_int|22
)braket
op_assign
l_int|0x65
suffix:semicolon
id|stat-&gt;ii.sense.data
(braket
l_int|23
)braket
op_assign
l_int|0x03
suffix:semicolon
id|stat-&gt;ii.sense.data
(braket
l_int|24
)braket
op_assign
l_int|0x04
suffix:semicolon
id|stat-&gt;ii.sense.data
(braket
l_int|25
)braket
op_assign
l_int|0x10
suffix:semicolon
id|stat-&gt;ii.sense.data
(braket
l_int|26
)braket
op_assign
l_int|0x4e
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* first of all lets try to find out the appropriate era_action */
r_if
c_cond
(paren
id|stat-&gt;flag
op_amp
id|DEVSTAT_FLAG_SENSE_AVAIL
op_logical_or
id|stat-&gt;dstat
op_amp
op_complement
(paren
id|DEV_STAT_CHN_END
op_or
id|DEV_STAT_DEV_END
)paren
)paren
(brace
multiline_comment|/* anything abnormal ? */
r_if
c_cond
(paren
id|device-&gt;discipline-&gt;examine_error
op_eq
l_int|NULL
op_logical_or
id|stat-&gt;flag
op_amp
id|DEVSTAT_HALT_FUNCTION
)paren
(brace
id|era
op_assign
id|dasd_era_fatal
suffix:semicolon
)brace
r_else
(brace
id|era
op_assign
id|device-&gt;discipline-&gt;examine_error
(paren
id|cqr
comma
id|stat
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|era
op_eq
id|dasd_era_none
)paren
(brace
r_if
c_cond
(paren
id|device-&gt;level
op_eq
id|DASD_DEVICE_LEVEL_ANALYSIS_PENDING
)paren
id|device-&gt;level
op_assign
id|DASD_DEVICE_LEVEL_ANALYSIS_PREPARED
suffix:semicolon
id|check_then_set
c_func
(paren
op_amp
id|cqr-&gt;status
comma
id|CQR_STATUS_IN_IO
comma
id|CQR_STATUS_DONE
)paren
suffix:semicolon
id|cqr-&gt;stopclk
op_assign
id|now
suffix:semicolon
id|cqr
op_assign
id|cqr-&gt;next
suffix:semicolon
multiline_comment|/* start the next queued request if possible -&gt; fast_io */
r_if
c_cond
(paren
id|cqr-&gt;status
op_eq
id|CQR_STATUS_QUEUED
)paren
(brace
r_if
c_cond
(paren
id|device-&gt;discipline-&gt;start_IO
(paren
id|cqr
)paren
op_ne
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot;Interrupt fastpath failed!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* error */
r_if
c_cond
(paren
id|cqr-&gt;dstat
op_eq
l_int|NULL
)paren
id|cqr-&gt;dstat
op_assign
id|kmalloc
(paren
r_sizeof
(paren
id|devstat_t
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr-&gt;dstat
)paren
(brace
id|memcpy
(paren
id|cqr-&gt;dstat
comma
id|stat
comma
r_sizeof
(paren
id|devstat_t
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINT_ERR
(paren
l_string|&quot;no memory for dstat...ignoring&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* dump sense data */
r_if
c_cond
(paren
id|device-&gt;discipline
op_logical_and
id|device-&gt;discipline-&gt;dump_sense
)paren
(brace
r_char
op_star
id|errmsg
op_assign
id|device-&gt;discipline-&gt;dump_sense
(paren
id|device
comma
id|cqr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errmsg
op_ne
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;Sense data:&bslash;n%s&quot;
comma
id|errmsg
)paren
suffix:semicolon
id|free_page
(paren
(paren
r_int
r_int
)paren
id|errmsg
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot;No memory to dump error message&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|era
)paren
(brace
r_case
id|dasd_era_fatal
suffix:colon
id|check_then_set
(paren
op_amp
id|cqr-&gt;status
comma
id|CQR_STATUS_IN_IO
comma
id|CQR_STATUS_FAILED
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|dasd_era_recover
suffix:colon
id|check_then_set
(paren
op_amp
id|cqr-&gt;status
comma
id|CQR_STATUS_IN_IO
comma
id|CQR_STATUS_ERROR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|dasd_schedule_bh
(paren
id|device
)paren
suffix:semicolon
)brace
multiline_comment|/* SECTION: Some stuff related to error recovery */
multiline_comment|/*&n; * DEFAULT_ERP_ACTION&n; *&n; * DESCRIPTION&n; *   sets up the default-ERP ccw_req_t, namely one, which performs a TIC&n; *   to the original channel program with a retry counter of 16&n; *&n; * PARAMETER&n; *   cqr                failed CQR&n; *&n; * RETURN VALUES&n; *   erp                CQR performing the ERP&n; */
id|ccw_req_t
op_star
DECL|function|default_erp_action
id|default_erp_action
(paren
id|ccw_req_t
op_star
id|cqr
)paren
(brace
id|ccw_req_t
op_star
id|erp
op_assign
id|ccw_alloc_request
(paren
(paren
r_char
op_star
)paren
op_amp
id|cqr-&gt;magic
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot;Default ERP called... &bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|erp
)paren
r_return
l_int|NULL
suffix:semicolon
id|erp-&gt;cpaddr-&gt;cmd_code
op_assign
id|CCW_CMD_TIC
suffix:semicolon
id|erp-&gt;cpaddr-&gt;cda
op_assign
(paren
id|__u32
)paren
(paren
r_void
op_star
)paren
id|cqr-&gt;cpaddr
suffix:semicolon
id|erp-&gt;function
op_assign
id|default_erp_action
suffix:semicolon
id|erp-&gt;refers
op_assign
id|cqr
suffix:semicolon
id|erp-&gt;device
op_assign
id|cqr-&gt;device
suffix:semicolon
id|erp-&gt;magic
op_assign
id|cqr-&gt;magic
suffix:semicolon
id|erp-&gt;retries
op_assign
l_int|16
suffix:semicolon
id|erp-&gt;status
op_assign
id|CQR_STATUS_FILLED
suffix:semicolon
r_return
id|erp
suffix:semicolon
)brace
multiline_comment|/*&n; * DEFAULT_ERP_POSTACTION&n; *&n; * DESCRIPTION&n; *   Frees all ERPs of the current ERP Chain and set the status&n; *   of the original CQR either to CQR_STATUS_DONE if ERP was successful&n; *   or to CQR_STATUS_FAILED if ERP was NOT successful.&n; *&n; * PARAMETER&n; *   erp                current erp_head&n; *&n; * RETURN VALUES&n; *   cqr                pointer to the original CQR&n; */
id|ccw_req_t
op_star
DECL|function|default_erp_postaction
id|default_erp_postaction
(paren
id|ccw_req_t
op_star
id|erp
)paren
(brace
id|dasd_device_t
op_star
id|device
op_assign
l_int|NULL
suffix:semicolon
id|ccw_req_t
op_star
id|free_erp
suffix:semicolon
r_int
id|success
suffix:semicolon
id|device
op_assign
(paren
id|dasd_device_t
op_star
)paren
(paren
id|erp-&gt;device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|erp-&gt;status
op_eq
id|CQR_STATUS_DONE
)paren
id|success
op_assign
l_int|1
suffix:semicolon
r_else
id|success
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|erp-&gt;refers
op_eq
l_int|NULL
op_logical_or
id|erp-&gt;function
op_eq
l_int|NULL
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|erp-&gt;function
op_ne
id|default_erp_action
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot;default ERP postaction called ERP action [&lt;%p&gt;]&bslash;n&quot;
comma
id|erp-&gt;function
)paren
suffix:semicolon
)brace
multiline_comment|/* free all ERPs - but NOT the original cqr */
r_while
c_loop
(paren
id|erp-&gt;refers
op_ne
l_int|NULL
)paren
(brace
id|free_erp
op_assign
id|erp
suffix:semicolon
id|erp
op_assign
id|erp-&gt;refers
suffix:semicolon
id|dasd_chanq_deq
(paren
op_amp
id|device-&gt;queue
comma
id|free_erp
)paren
suffix:semicolon
id|dasd_free_request
(paren
id|free_erp
)paren
suffix:semicolon
)brace
multiline_comment|/* save ptr to original cqr */
multiline_comment|/*&n;         * printk (KERN_INFO PRINTK_HEADER&n;         * &quot;default_erp_postaction - left original request = %p &bslash;n&quot;,erp);&n;         */
multiline_comment|/* set corresponding status to original cqr */
r_if
c_cond
(paren
id|success
)paren
(brace
id|check_then_set
(paren
op_amp
id|erp-&gt;status
comma
id|CQR_STATUS_ERROR
comma
id|CQR_STATUS_DONE
)paren
suffix:semicolon
)brace
r_else
(brace
id|check_then_set
(paren
op_amp
id|erp-&gt;status
comma
id|CQR_STATUS_ERROR
comma
id|CQR_STATUS_FAILED
)paren
suffix:semicolon
)brace
multiline_comment|/* print current erp_chain */
macro_line|#if 0
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot;default ERP postaction finished with remaining chain:&bslash;n&quot;
)paren
suffix:semicolon
(brace
id|ccw_req_t
op_star
id|temp_erp
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|temp_erp
op_assign
id|erp
suffix:semicolon
id|temp_erp
op_ne
l_int|NULL
suffix:semicolon
id|temp_erp
op_assign
id|temp_erp-&gt;refers
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot; erp %p refers to %p &bslash;n&quot;
comma
id|temp_erp
comma
id|temp_erp-&gt;refers
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_return
id|erp
suffix:semicolon
)brace
multiline_comment|/* end default_erp_postaction */
multiline_comment|/* SECTION: The helpers of the struct file_operations */
multiline_comment|/* &n; * function dasd_format &n; * performs formatting of _device_ according to _fdata_&n; * Note: The discipline&squot;s format_function is assumed to deliver formatting&n; * commands to format a single unit of the device. In terms of the ECKD&n; * devices this means CCWs are generated to format a single track.&n; */
r_static
r_int
DECL|function|dasd_format
id|dasd_format
(paren
id|dasd_device_t
op_star
id|device
comma
id|format_data_t
op_star
id|fdata
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|ccw_req_t
op_star
id|req
op_assign
l_int|NULL
suffix:semicolon
id|format_data_t
id|temp
op_assign
(brace
id|fdata-&gt;start_unit
comma
id|fdata-&gt;stop_unit
comma
id|fdata-&gt;blksize
comma
id|fdata-&gt;intensity
)brace
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;open_count
op_ne
l_int|1
)paren
(brace
id|DASD_MESSAGE
(paren
id|KERN_INFO
comma
id|device
comma
l_string|&quot;device is already open %d times&quot;
comma
id|device-&gt;open_count
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|device-&gt;discipline-&gt;format_device
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* downgrade state of the device */
id|dasd_set_device_level
(paren
id|device-&gt;devinfo.irq
comma
id|DASD_DEVICE_LEVEL_RECOGNIZED
comma
id|device-&gt;discipline
comma
l_int|0
)paren
suffix:semicolon
id|DASD_MESSAGE
(paren
id|KERN_INFO
comma
id|device
comma
l_string|&quot;Starting format from %d to %d (%d B blocks flags %d&quot;
comma
id|fdata-&gt;start_unit
comma
id|fdata-&gt;stop_unit
comma
id|fdata-&gt;blksize
comma
id|fdata-&gt;intensity
)paren
suffix:semicolon
multiline_comment|/* Invalidate first track */
r_if
c_cond
(paren
id|fdata-&gt;start_unit
op_eq
id|DASD_FORMAT_DEFAULT_START_UNIT
op_logical_and
id|fdata-&gt;stop_unit
op_eq
id|DASD_FORMAT_DEFAULT_STOP_UNIT
op_logical_and
id|fdata-&gt;intensity
op_eq
id|DASD_FORMAT_DEFAULT_INTENSITY
)paren
(brace
id|format_data_t
id|temp2
op_assign
(brace
l_int|0
comma
l_int|0
comma
id|DASD_FORMAT_DEFAULT_BLOCKSIZE
comma
l_int|0x04
)brace
suffix:semicolon
id|DASD_MESSAGE
(paren
id|KERN_INFO
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;Invalidating first track...&quot;
)paren
suffix:semicolon
id|req
op_assign
id|device-&gt;discipline-&gt;format_device
(paren
id|device
comma
op_amp
id|temp2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
id|rc
op_assign
id|sleep_on_req
(paren
id|req
)paren
suffix:semicolon
id|dasd_free_request
(paren
id|req
)paren
suffix:semicolon
multiline_comment|/* request is no longer used */
)brace
r_else
(brace
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot;Can&squot;t invalidate Track 0&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|temp.start_unit
op_increment
suffix:semicolon
id|DASD_MESSAGE
(paren
id|KERN_INFO
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;...Invalidation complete&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* format remainnig tracks of device */
r_while
c_loop
(paren
op_logical_neg
id|rc
op_logical_and
(paren
(paren
id|req
op_assign
id|device-&gt;discipline-&gt;format_device
(paren
id|device
comma
op_amp
id|temp
)paren
)paren
op_ne
l_int|NULL
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|sleep_on_req
(paren
id|req
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|DASD_MESSAGE
(paren
id|KERN_WARNING
comma
id|device
comma
l_string|&quot; Formatting failed with rc = %d&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dasd_free_request
(paren
id|req
)paren
suffix:semicolon
multiline_comment|/* request is no longer used */
id|temp.start_unit
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rc
op_logical_and
id|req
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|fdata-&gt;start_unit
op_eq
id|DASD_FORMAT_DEFAULT_START_UNIT
op_logical_and
id|fdata-&gt;stop_unit
op_eq
id|DASD_FORMAT_DEFAULT_STOP_UNIT
op_logical_and
id|fdata-&gt;intensity
op_eq
id|DASD_FORMAT_DEFAULT_INTENSITY
)paren
(brace
id|format_data_t
id|temp2
op_assign
(brace
l_int|0
comma
l_int|0
comma
id|fdata-&gt;blksize
comma
id|fdata-&gt;intensity
)brace
suffix:semicolon
id|DASD_MESSAGE
(paren
id|KERN_INFO
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;Revalidating first track...&quot;
)paren
suffix:semicolon
id|req
op_assign
id|device-&gt;discipline-&gt;format_device
(paren
id|device
comma
op_amp
id|temp2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
id|rc
op_assign
id|sleep_on_req
(paren
id|req
)paren
suffix:semicolon
id|dasd_free_request
(paren
id|req
)paren
suffix:semicolon
multiline_comment|/* request is no longer used */
)brace
r_else
(brace
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot;Can&squot;t revalidate Track 0&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|DASD_MESSAGE
(paren
id|KERN_INFO
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot;...Revalidation complete&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end if no more requests */
r_if
c_cond
(paren
id|rc
)paren
id|DASD_MESSAGE
(paren
id|KERN_WARNING
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot; Formatting finished unsuccessfully&quot;
)paren
suffix:semicolon
r_else
id|DASD_MESSAGE
(paren
id|KERN_INFO
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot; Formatting finished successfully&quot;
)paren
suffix:semicolon
multiline_comment|/* re-activate device even if formatting was unsuccessful */
multiline_comment|/* Horst Hummel - 17/10/00 - ITPM PL020062RSC             */
id|dasd_set_device_level
(paren
id|device-&gt;devinfo.irq
comma
id|DASD_DEVICE_LEVEL_ANALYSIS_PREPARED
comma
id|device-&gt;discipline
comma
l_int|0
)paren
suffix:semicolon
id|udelay
(paren
l_int|1500000
)paren
suffix:semicolon
id|dasd_set_device_level
(paren
id|device-&gt;devinfo.irq
comma
id|DASD_DEVICE_LEVEL_ANALYSED
comma
id|device-&gt;discipline
comma
l_int|0
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* end dasd_format */
r_static
r_int
DECL|function|do_dasd_ioctl
id|do_dasd_ioctl
(paren
r_struct
id|inode
op_star
id|inp
comma
multiline_comment|/* unsigned */
r_int
id|no
comma
r_int
r_int
id|data
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|dasd_device_t
op_star
id|device
op_assign
id|dasd_device_from_kdev
(paren
id|inp-&gt;i_rdev
)paren
suffix:semicolon
id|major_info_t
op_star
id|major_info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot;No device registered as device (%d:%d)&bslash;n&quot;
comma
id|MAJOR
(paren
id|inp-&gt;i_rdev
)paren
comma
id|MINOR
(paren
id|inp-&gt;i_rdev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|_IOC_DIR
(paren
id|no
)paren
op_ne
id|_IOC_NONE
)paren
op_logical_and
(paren
id|data
op_eq
l_int|0
)paren
)paren
(brace
id|PRINT_DEBUG
(paren
l_string|&quot;empty data ptr&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|major_info
op_assign
id|device-&gt;major_info
suffix:semicolon
macro_line|#if 0
id|printk
(paren
id|KERN_DEBUG
id|PRINTK_HEADER
l_string|&quot;ioctl 0x%08x %s&squot;0x%x&squot;%d(%d) on /dev/%s (%d:%d,&quot;
l_string|&quot; devno 0x%04X on irq %d) with data %8lx&bslash;n&quot;
comma
id|no
comma
id|_IOC_DIR
(paren
id|no
)paren
op_eq
id|_IOC_NONE
ques
c_cond
l_string|&quot;0&quot;
suffix:colon
id|_IOC_DIR
(paren
id|no
)paren
op_eq
id|_IOC_READ
ques
c_cond
l_string|&quot;r&quot;
suffix:colon
id|_IOC_DIR
(paren
id|no
)paren
op_eq
id|_IOC_WRITE
ques
c_cond
l_string|&quot;w&quot;
suffix:colon
id|_IOC_DIR
(paren
id|no
)paren
op_eq
(paren
id|_IOC_READ
op_or
id|_IOC_WRITE
)paren
ques
c_cond
l_string|&quot;rw&quot;
suffix:colon
l_string|&quot;u&quot;
comma
id|_IOC_TYPE
(paren
id|no
)paren
comma
id|_IOC_NR
(paren
id|no
)paren
comma
id|_IOC_SIZE
(paren
id|no
)paren
comma
id|device-&gt;name
comma
id|MAJOR
(paren
id|inp-&gt;i_rdev
)paren
comma
id|MINOR
(paren
id|inp-&gt;i_rdev
)paren
comma
id|device-&gt;devinfo.devno
comma
id|device-&gt;devinfo.irq
comma
id|data
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|no
)paren
(brace
r_case
id|BLKGETSIZE
suffix:colon
(brace
multiline_comment|/* Return device size */
r_int
id|blocks
op_assign
id|blk_size
(braket
id|MAJOR
(paren
id|inp-&gt;i_rdev
)paren
)braket
(braket
id|MINOR
(paren
id|inp-&gt;i_rdev
)paren
)braket
op_lshift
l_int|1
suffix:semicolon
id|rc
op_assign
id|copy_to_user
(paren
(paren
r_int
op_star
)paren
id|data
comma
op_amp
id|blocks
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
id|rc
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|BLKRRPART
suffix:colon
(brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|EACCES
suffix:semicolon
r_break
suffix:semicolon
)brace
id|fsync_dev
c_func
(paren
id|inp-&gt;i_rdev
)paren
suffix:semicolon
id|dasd_partn_detect
(paren
id|device
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|inp-&gt;i_rdev
)paren
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|HDIO_GETGEO
suffix:colon
(brace
r_struct
id|hd_geometry
id|geo
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;discipline-&gt;fill_geometry
)paren
id|device-&gt;discipline-&gt;fill_geometry
(paren
id|device
comma
op_amp
id|geo
)paren
suffix:semicolon
id|rc
op_assign
id|copy_to_user
(paren
(paren
r_struct
id|hd_geometry
op_star
)paren
id|data
comma
op_amp
id|geo
comma
r_sizeof
(paren
r_struct
id|hd_geometry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
id|rc
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,3,98))
r_case
id|BLKSSZGET
suffix:colon
r_case
id|BLKROSET
suffix:colon
r_case
id|BLKROGET
suffix:colon
r_case
id|BLKRASET
suffix:colon
r_case
id|BLKRAGET
suffix:colon
r_case
id|BLKFLSBUF
suffix:colon
r_case
id|BLKPG
suffix:colon
r_case
id|BLKELVGET
suffix:colon
r_case
id|BLKELVSET
suffix:colon
r_return
id|blk_ioctl
c_func
(paren
id|inp-&gt;i_rdev
comma
id|no
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#else
r_case
id|BLKRASET
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
(brace
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dev
op_logical_or
id|arg
OG
l_int|0xff
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|read_ahead
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
op_assign
id|arg
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BLKRAGET
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|rc
op_assign
id|put_user
c_func
(paren
id|read_ahead
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BLKSSZGET
suffix:colon
(brace
multiline_comment|/* Block size of media */
id|rc
op_assign
id|copy_to_user
c_func
(paren
(paren
r_int
op_star
)paren
id|data
comma
op_amp
id|blksize_size
(braket
id|MAJOR
c_func
(paren
id|device-&gt;kdev
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|device-&gt;kdev
)paren
)braket
comma
r_sizeof
(paren
r_int
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
id|RO_IOCTLS
(paren
id|inp-&gt;i_rdev
comma
id|data
)paren
suffix:semicolon
r_case
id|BLKFLSBUF
suffix:colon
(brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|fsync_dev
c_func
(paren
id|inp-&gt;i_rdev
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|inp-&gt;i_rdev
)paren
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* LINUX_IS_24 */
r_case
id|BIODASDRSID
suffix:colon
(brace
id|rc
op_assign
id|copy_to_user
(paren
(paren
r_void
op_star
)paren
id|data
comma
op_amp
(paren
id|device-&gt;devinfo.sid_data
)paren
comma
r_sizeof
(paren
id|senseid_t
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|BIODASDRWTB
suffix:colon
(brace
r_int
id|offset
op_assign
l_int|0
suffix:semicolon
r_int
id|xlt
suffix:semicolon
id|rc
op_assign
id|copy_from_user
(paren
op_amp
id|xlt
comma
(paren
r_void
op_star
)paren
id|data
comma
r_sizeof
(paren
r_int
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_break
suffix:semicolon
id|offset
op_assign
id|major_info-&gt;gendisk.part
(braket
id|MINOR
(paren
id|inp-&gt;i_rdev
)paren
)braket
dot
id|start_sect
op_rshift
id|device-&gt;sizes.s2b_shift
suffix:semicolon
id|xlt
op_add_assign
id|offset
suffix:semicolon
id|rc
op_assign
id|copy_to_user
(paren
(paren
r_void
op_star
)paren
id|data
comma
op_amp
id|xlt
comma
r_sizeof
(paren
r_int
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|BIODASDFORMAT
suffix:colon
(brace
multiline_comment|/* fdata == NULL is a valid arg to dasd_format ! */
r_int
id|partn
suffix:semicolon
id|format_data_t
id|fdata
op_assign
(brace
id|DASD_FORMAT_DEFAULT_START_UNIT
comma
id|DASD_FORMAT_DEFAULT_STOP_UNIT
comma
id|DASD_FORMAT_DEFAULT_BLOCKSIZE
comma
id|DASD_FORMAT_DEFAULT_INTENSITY
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|EACCES
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|data
)paren
(brace
id|rc
op_assign
id|copy_from_user
(paren
op_amp
id|fdata
comma
(paren
r_void
op_star
)paren
id|data
comma
r_sizeof
(paren
id|format_data_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|rc
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|partn
op_assign
id|MINOR
(paren
id|inp-&gt;i_rdev
)paren
op_amp
(paren
(paren
l_int|1
op_lshift
id|major_info-&gt;gendisk.minor_shift
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|partn
op_ne
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot; devno 0x%04X on subchannel %d = /dev/%s (%d:%d)&quot;
l_string|&quot; Cannot low-level format a partition&bslash;n&quot;
comma
id|device-&gt;devinfo.devno
comma
id|device-&gt;devinfo.irq
comma
id|device-&gt;name
comma
id|MAJOR
(paren
id|inp-&gt;i_rdev
)paren
comma
id|MINOR
(paren
id|inp-&gt;i_rdev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|rc
op_assign
id|dasd_format
(paren
id|device
comma
op_amp
id|fdata
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|BIODASDRSRV
suffix:colon
(brace
id|ccw_req_t
op_star
id|req
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|EACCES
suffix:semicolon
r_break
suffix:semicolon
)brace
id|req
op_assign
id|device-&gt;discipline-&gt;reserve
(paren
id|device
)paren
suffix:semicolon
id|rc
op_assign
id|sleep_on_req
(paren
id|req
)paren
suffix:semicolon
id|dasd_free_request
(paren
id|req
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|BIODASDRLSE
suffix:colon
(brace
id|ccw_req_t
op_star
id|req
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|EACCES
suffix:semicolon
r_break
suffix:semicolon
)brace
id|req
op_assign
id|device-&gt;discipline-&gt;release
(paren
id|device
)paren
suffix:semicolon
id|rc
op_assign
id|sleep_on_req
(paren
id|req
)paren
suffix:semicolon
id|dasd_free_request
(paren
id|req
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|BIODASDSLCK
suffix:colon
(brace
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot;Unsupported ioctl BIODASDSLCK&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
(brace
id|DASD_MESSAGE
(paren
id|KERN_INFO
comma
id|device
comma
l_string|&quot;ioctl 0x%08x=%s&squot;0x%x&squot;%d(%d) data %8lx&bslash;n&quot;
comma
id|no
comma
id|_IOC_DIR
(paren
id|no
)paren
op_eq
id|_IOC_NONE
ques
c_cond
l_string|&quot;0&quot;
suffix:colon
id|_IOC_DIR
(paren
id|no
)paren
op_eq
id|_IOC_READ
ques
c_cond
l_string|&quot;r&quot;
suffix:colon
id|_IOC_DIR
(paren
id|no
)paren
op_eq
id|_IOC_WRITE
ques
c_cond
l_string|&quot;w&quot;
suffix:colon
id|_IOC_DIR
(paren
id|no
)paren
op_eq
(paren
id|_IOC_READ
op_or
id|_IOC_WRITE
)paren
ques
c_cond
l_string|&quot;rw&quot;
suffix:colon
l_string|&quot;u&quot;
comma
id|_IOC_TYPE
(paren
id|no
)paren
comma
id|_IOC_NR
(paren
id|no
)paren
comma
id|_IOC_SIZE
(paren
id|no
)paren
comma
id|data
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* SECTION: The members of the struct file_operations */
r_static
r_int
DECL|function|dasd_ioctl
id|dasd_ioctl
(paren
r_struct
id|inode
op_star
id|inp
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|no
comma
r_int
r_int
id|data
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|inp
)paren
op_logical_or
op_logical_neg
(paren
id|inp-&gt;i_rdev
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|rc
op_assign
id|do_dasd_ioctl
(paren
id|inp
comma
id|no
comma
id|data
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_static
r_int
DECL|function|dasd_open
id|dasd_open
(paren
r_struct
id|inode
op_star
id|inp
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|dasd_device_t
op_star
id|device
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|inp
)paren
op_logical_or
op_logical_neg
(paren
id|inp-&gt;i_rdev
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dasd_probeonly
)paren
(brace
id|printk
(paren
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
id|PRINTK_HEADER
l_string|&quot;No access to device (%d:%d) due to probeonly mode&bslash;n&quot;
comma
id|MAJOR
(paren
id|inp-&gt;i_rdev
)paren
comma
id|MINOR
(paren
id|inp-&gt;i_rdev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|device
op_assign
id|dasd_device_from_kdev
(paren
id|inp-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot;No device registered as (%d:%d)&bslash;n&quot;
comma
id|MAJOR
(paren
id|inp-&gt;i_rdev
)paren
comma
id|MINOR
(paren
id|inp-&gt;i_rdev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|device-&gt;level
OL
id|DASD_DEVICE_LEVEL_RECOGNIZED
op_logical_or
id|device-&gt;discipline
op_eq
l_int|NULL
)paren
(brace
id|DASD_MESSAGE
(paren
id|KERN_WARNING
comma
id|device
comma
l_string|&quot; %s&quot;
comma
l_string|&quot; Cannot open unrecognized device&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#ifdef MODULE
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* MODULE */
id|device-&gt;open_count
op_increment
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_static
r_int
DECL|function|dasd_release
id|dasd_release
(paren
r_struct
id|inode
op_star
id|inp
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|dasd_device_t
op_star
id|device
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|inp
)paren
op_logical_or
op_logical_neg
(paren
id|inp-&gt;i_rdev
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|device
op_assign
id|dasd_device_from_kdev
(paren
id|inp-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot;No device registered as %d:%d&bslash;n&quot;
comma
id|MAJOR
(paren
id|inp-&gt;i_rdev
)paren
comma
id|MINOR
(paren
id|inp-&gt;i_rdev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|device-&gt;open_count
op_decrement
)paren
(brace
macro_line|#ifdef MODULE
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* MODULE */
)brace
id|fsync_dev
c_func
(paren
id|inp-&gt;i_rdev
)paren
suffix:semicolon
multiline_comment|/* sync the device */
r_if
c_cond
(paren
id|device-&gt;open_count
op_eq
l_int|0
)paren
multiline_comment|/* finally invalidate buffers */
id|invalidate_buffers
c_func
(paren
id|inp-&gt;i_rdev
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_static
r_struct
DECL|variable|dasd_device_operations
id|block_device_operations
id|dasd_device_operations
op_assign
(brace
id|open
suffix:colon
id|dasd_open
comma
id|release
suffix:colon
id|dasd_release
comma
id|ioctl
suffix:colon
id|dasd_ioctl
comma
macro_line|#if ! (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,3,98))
id|read
suffix:colon
id|block_read
comma
id|write
suffix:colon
id|block_write
comma
id|fsync
suffix:colon
id|block_fsync
comma
macro_line|#endif&t;&t;&t;&t;/* LINUX_IS_24 */
)brace
suffix:semicolon
multiline_comment|/* SECTION: Management of device list */
multiline_comment|/* This one is needed for naming 18000+ possible dasd devices */
r_int
DECL|function|dasd_device_name
id|dasd_device_name
(paren
r_char
op_star
id|str
comma
r_int
id|index
comma
r_int
id|partition
comma
r_struct
id|gendisk
op_star
id|hd
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_char
id|first
comma
id|second
comma
id|third
suffix:semicolon
r_if
c_cond
(paren
id|hd
)paren
(brace
id|major_info_t
op_star
id|major_info
suffix:semicolon
r_for
c_loop
(paren
id|major_info
op_assign
id|dasd_major_info
suffix:semicolon
id|major_info
suffix:semicolon
id|major_info
op_assign
id|major_info-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_amp
id|major_info-&gt;gendisk
op_eq
id|hd
)paren
(brace
r_break
suffix:semicolon
)brace
id|index
op_add_assign
id|DASD_PER_MAJOR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|major_info
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
id|third
op_assign
id|index
op_mod
l_int|26
suffix:semicolon
id|second
op_assign
(paren
id|index
op_div
l_int|26
)paren
op_mod
l_int|27
suffix:semicolon
id|first
op_assign
(paren
(paren
id|index
op_div
l_int|26
)paren
op_div
l_int|27
)paren
op_mod
l_int|27
suffix:semicolon
id|len
op_assign
id|sprintf
(paren
id|str
comma
l_string|&quot;dasd&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first
)paren
(brace
id|len
op_add_assign
id|sprintf
(paren
id|str
op_plus
id|len
comma
l_string|&quot;%c&quot;
comma
id|first
op_plus
l_char|&squot;a&squot;
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|second
)paren
(brace
id|len
op_add_assign
id|sprintf
(paren
id|str
op_plus
id|len
comma
l_string|&quot;%c&quot;
comma
id|second
op_plus
l_char|&squot;a&squot;
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
(paren
id|str
op_plus
id|len
comma
l_string|&quot;%c&quot;
comma
id|third
op_plus
l_char|&squot;a&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|partition
)paren
(brace
r_if
c_cond
(paren
id|partition
OG
l_int|9
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
id|len
op_add_assign
id|sprintf
(paren
id|str
op_plus
id|len
comma
l_string|&quot;%d&quot;
comma
id|partition
)paren
suffix:semicolon
)brace
)brace
id|str
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_DASD_DYNAMIC
r_static
r_void
DECL|function|dasd_not_oper_handler
id|dasd_not_oper_handler
(paren
r_int
id|irq
comma
r_int
id|status
)paren
(brace
id|dasd_device_t
op_star
id|device
op_assign
l_int|NULL
suffix:semicolon
id|major_info_t
op_star
id|major_info
suffix:semicolon
r_int
id|i
comma
id|devno
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_for
c_loop
(paren
id|major_info
op_assign
id|dasd_major_info
suffix:semicolon
id|major_info
op_ne
l_int|NULL
suffix:semicolon
id|major_info
op_assign
id|major_info-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DASD_PER_MAJOR
suffix:semicolon
id|i
op_increment
)paren
(brace
id|device
op_assign
id|major_info-&gt;dasd_device
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|device
op_logical_and
id|device-&gt;devinfo.irq
op_eq
id|irq
)paren
(brace
id|devno
op_assign
id|device-&gt;devinfo.devno
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|devno
op_ne
op_minus
id|ENODEV
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|devno
OL
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot;not_oper_handler called on irq %d no devno!&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
(paren
id|KERN_INFO
id|PRINTK_HEADER
l_string|&quot;not_oper_handler called on irq %d devno %04X&bslash;n&quot;
comma
id|irq
comma
id|devno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;open_count
op_ne
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_ALERT
id|PRINTK_HEADER
l_string|&quot;Device %04X detached has still been open. expect errors&bslash;n&quot;
comma
id|devno
)paren
suffix:semicolon
)brace
id|dasd_set_device_level
(paren
id|irq
comma
id|DASD_DEVICE_LEVEL_UNKNOWN
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|dasd_enable_single_volume
id|dasd_enable_single_volume
(paren
r_int
id|irq
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|dasd_set_device_level
(paren
id|irq
comma
id|DASD_DEVICE_LEVEL_ANALYSIS_PREPARED
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|printk
(paren
id|KERN_INFO
id|PRINTK_HEADER
l_string|&quot;waiting for response...&bslash;n&quot;
)paren
suffix:semicolon
(brace
r_static
id|wait_queue_head_t
id|wait_queue
suffix:semicolon
id|init_waitqueue_head
(paren
op_amp
id|wait_queue
)paren
suffix:semicolon
id|interruptible_sleep_on_timeout
(paren
op_amp
id|wait_queue
comma
(paren
l_int|5
op_star
id|HZ
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
)brace
id|dasd_set_device_level
(paren
id|irq
comma
id|DASD_DEVICE_LEVEL_ANALYSED
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_int
DECL|function|dasd_oper_handler
id|dasd_oper_handler
(paren
r_int
id|irq
comma
id|devreg_t
op_star
id|devreg
)paren
(brace
r_int
id|devno
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|devno
op_assign
id|get_devno_by_irq
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devno
op_eq
op_minus
id|ENODEV
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|dasd_autodetect
)paren
(brace
id|dasd_add_range
(paren
id|devno
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|rc
op_assign
id|dasd_enable_single_volume
(paren
id|irq
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_DASD_DYNAMIC */
multiline_comment|/* &n; * function dasd_set_device_level &n; */
r_static
r_int
DECL|function|dasd_set_device_level
id|dasd_set_device_level
(paren
r_int
r_int
id|irq
comma
r_int
id|desired_level
comma
id|dasd_discipline_t
op_star
id|discipline
comma
r_int
id|flags
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|devno
suffix:semicolon
id|dasd_device_t
op_star
op_star
id|device_addr
comma
op_star
id|device
suffix:semicolon
r_int
id|current_level
suffix:semicolon
id|major_info_t
op_star
id|major_info
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
comma
id|minor
comma
id|major
suffix:semicolon
id|ccw_req_t
op_star
id|cqr
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|gendisk
op_star
id|dd
suffix:semicolon
id|devno
op_assign
id|get_devno_by_irq
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devno
OL
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot; no device appears to be connected to SCH %d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dasd_devindex_from_devno
(paren
id|devno
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|device_addr
op_assign
id|dasd_device_from_devno
(paren
id|devno
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dasd_register_major
(paren
l_int|NULL
)paren
)paren
OG
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_INFO
id|PRINTK_HEADER
l_string|&quot;Registered to major number: %u&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot;Couldn&squot;t register to another major no&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ERANGE
suffix:semicolon
)brace
)brace
id|device
op_assign
op_star
id|device_addr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device
)paren
(brace
multiline_comment|/* allocate device descriptor */
id|device
op_assign
id|kmalloc
(paren
r_sizeof
(paren
id|dasd_device_t
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot; No memory for device descriptor&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|nomem
suffix:semicolon
)brace
id|memset
(paren
id|device
comma
l_int|0
comma
r_sizeof
(paren
id|dasd_device_t
)paren
)paren
suffix:semicolon
op_star
id|device_addr
op_assign
id|device
suffix:semicolon
)brace
r_for
c_loop
(paren
id|major_info
op_assign
id|dasd_major_info
suffix:semicolon
id|major_info
suffix:semicolon
id|major_info
op_assign
id|major_info-&gt;next
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DASD_PER_MAJOR
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|major_info-&gt;dasd_device
(braket
id|i
)braket
op_eq
id|device
)paren
(brace
id|device-&gt;kdev
op_assign
id|MKDEV
(paren
id|major_info-&gt;gendisk.major
comma
id|i
op_lshift
id|DASD_PARTN_BITS
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
OL
id|DASD_PER_MAJOR
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|major_info
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|device-&gt;major_info
op_assign
id|major_info
suffix:semicolon
id|dasd_device_name
(paren
id|device-&gt;name
comma
(paren
(paren
r_int
)paren
id|device_addr
op_minus
(paren
r_int
)paren
id|device-&gt;major_info-&gt;dasd_device
)paren
op_div
r_sizeof
(paren
id|dasd_device_t
op_star
)paren
comma
l_int|0
comma
op_amp
id|major_info-&gt;gendisk
)paren
suffix:semicolon
id|minor
op_assign
id|MINOR
(paren
id|device-&gt;kdev
)paren
suffix:semicolon
id|major
op_assign
id|MAJOR
(paren
id|device-&gt;kdev
)paren
suffix:semicolon
id|current_level
op_assign
id|device-&gt;level
suffix:semicolon
r_if
c_cond
(paren
id|desired_level
OG
id|current_level
)paren
(brace
r_switch
c_cond
(paren
id|current_level
)paren
(brace
r_case
id|DASD_DEVICE_LEVEL_UNKNOWN
suffix:colon
multiline_comment|/* Find a discipline */
id|rc
op_assign
id|get_dev_info_by_irq
(paren
id|irq
comma
op_amp
id|device-&gt;devinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|discipline
op_assign
id|dasd_find_discipline
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|discipline
op_logical_and
op_logical_neg
id|rc
)paren
(brace
id|DASD_MESSAGE
(paren
id|KERN_INFO
comma
id|device
comma
l_string|&quot;%s&quot;
comma
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
id|device-&gt;discipline
op_assign
id|discipline
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;discipline-&gt;int_handler
)paren
(brace
macro_line|#ifdef CONFIG_DASD_DYNAMIC
id|s390_request_irq_special
(paren
id|irq
comma
id|device-&gt;discipline-&gt;int_handler
comma
id|dasd_not_oper_handler
comma
l_int|0
comma
id|DASD_NAME
comma
op_amp
id|device-&gt;dev_status
)paren
suffix:semicolon
macro_line|#else&t;&t;&t;&t;/* !defined(CONFIG_DASD_DYNAMIC) */
id|request_irq
(paren
id|irq
comma
id|device-&gt;discipline-&gt;int_handler
comma
l_int|0
comma
id|DASD_NAME
comma
op_amp
id|device-&gt;dev_status
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_DYNAMIC */
)brace
id|device-&gt;proc_dir
op_assign
(paren
r_struct
id|proc_dir_entry
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|proc_dir_entry
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;proc_dir
)paren
(brace
id|memset
(paren
id|device-&gt;proc_dir
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|proc_dir_entry
)paren
)paren
suffix:semicolon
id|device-&gt;proc_info
op_assign
(paren
r_struct
id|proc_dir_entry
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|proc_dir_entry
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;proc_info
)paren
(brace
id|memset
(paren
id|device-&gt;proc_info
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|proc_dir_entry
)paren
)paren
suffix:semicolon
)brace
id|device-&gt;proc_stats
op_assign
(paren
r_struct
id|proc_dir_entry
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|proc_dir_entry
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;proc_stats
)paren
(brace
id|memset
(paren
id|device-&gt;proc_stats
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|proc_dir_entry
)paren
)paren
suffix:semicolon
)brace
)brace
id|init_waitqueue_head
(paren
op_amp
id|device-&gt;wait_q
)paren
suffix:semicolon
id|blk_init_queue
(paren
op_amp
id|device-&gt;request_queue
comma
id|do_dasd_request
)paren
suffix:semicolon
id|blk_queue_headactive
(paren
op_amp
id|device-&gt;request_queue
comma
l_int|0
)paren
suffix:semicolon
id|check_then_set
(paren
op_amp
id|device-&gt;level
comma
id|DASD_DEVICE_LEVEL_UNKNOWN
comma
id|DASD_DEVICE_LEVEL_RECOGNIZED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|desired_level
op_eq
id|DASD_DEVICE_LEVEL_RECOGNIZED
)paren
r_break
suffix:semicolon
r_case
id|DASD_DEVICE_LEVEL_RECOGNIZED
suffix:colon
multiline_comment|/* Fallthrough ?? */
r_if
c_cond
(paren
id|device-&gt;discipline-&gt;init_analysis
)paren
(brace
id|cqr
op_assign
id|device-&gt;discipline-&gt;init_analysis
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cqr
op_ne
l_int|NULL
)paren
(brace
id|dasd_chanq_enq
(paren
op_amp
id|device-&gt;queue
comma
id|cqr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;discipline-&gt;start_IO
)paren
(brace
r_int
id|flags
suffix:semicolon
id|s390irq_spin_lock_irqsave
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
id|device-&gt;discipline-&gt;start_IO
(paren
id|cqr
)paren
suffix:semicolon
id|check_then_set
(paren
op_amp
id|device-&gt;level
comma
id|DASD_DEVICE_LEVEL_RECOGNIZED
comma
id|DASD_DEVICE_LEVEL_ANALYSIS_PENDING
)paren
suffix:semicolon
id|s390irq_spin_unlock_irqrestore
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|check_then_set
(paren
op_amp
id|device-&gt;level
comma
id|DASD_DEVICE_LEVEL_RECOGNIZED
comma
id|DASD_DEVICE_LEVEL_ANALYSIS_PREPARED
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|desired_level
op_ge
id|DASD_DEVICE_LEVEL_ANALYSIS_PENDING
)paren
r_break
suffix:semicolon
r_case
id|DASD_DEVICE_LEVEL_ANALYSIS_PENDING
suffix:colon
multiline_comment|/* Fallthrough ?? */
r_return
op_minus
id|EAGAIN
suffix:semicolon
r_case
id|DASD_DEVICE_LEVEL_ANALYSIS_PREPARED
suffix:colon
multiline_comment|/* Re-entering here ! */
r_if
c_cond
(paren
id|device-&gt;discipline-&gt;do_analysis
)paren
r_if
c_cond
(paren
id|device-&gt;discipline-&gt;do_analysis
(paren
id|device
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_switch
c_cond
(paren
id|device-&gt;sizes.bp_block
)paren
(brace
r_case
l_int|512
suffix:colon
r_case
l_int|1024
suffix:colon
r_case
l_int|2048
suffix:colon
r_case
l_int|4096
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
(brace
id|printk
(paren
id|KERN_INFO
id|PRINTK_HEADER
l_string|&quot;/dev/%s (devno 0x%04X): Detected invalid blocksize of %d bytes&quot;
l_string|&quot; Did you format the drive?&bslash;n&quot;
comma
id|device-&gt;name
comma
id|devno
comma
id|device-&gt;sizes.bp_block
)paren
suffix:semicolon
r_return
op_minus
id|EMEDIUMTYPE
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
l_int|1
op_lshift
id|DASD_PARTN_BITS
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
id|blk_size
(braket
id|major
)braket
(braket
id|minor
)braket
op_assign
(paren
id|device-&gt;sizes.blocks
op_lshift
id|device-&gt;sizes.s2b_shift
)paren
op_rshift
l_int|1
suffix:semicolon
r_else
id|blk_size
(braket
id|major
)braket
(braket
id|minor
op_plus
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|hardsect_size
(braket
id|major
)braket
(braket
id|minor
op_plus
id|i
)braket
op_assign
id|device-&gt;sizes.bp_block
suffix:semicolon
id|blksize_size
(braket
id|major
)braket
(braket
id|minor
op_plus
id|i
)braket
op_assign
id|device-&gt;sizes.bp_block
suffix:semicolon
r_if
c_cond
(paren
id|blksize_size
(braket
id|major
)braket
(braket
id|minor
op_plus
id|i
)braket
OL
l_int|1024
)paren
id|blksize_size
(braket
id|major
)braket
(braket
id|minor
op_plus
id|i
)braket
op_assign
l_int|1024
suffix:semicolon
id|max_sectors
(braket
id|major
)braket
(braket
id|minor
op_plus
id|i
)braket
op_assign
l_int|255
op_lshift
id|device-&gt;sizes.s2b_shift
suffix:semicolon
)brace
id|check_then_set
(paren
op_amp
id|device-&gt;level
comma
id|DASD_DEVICE_LEVEL_ANALYSIS_PREPARED
comma
id|DASD_DEVICE_LEVEL_ANALYSED
)paren
suffix:semicolon
id|dd
op_assign
op_amp
id|major_info-&gt;gendisk
suffix:semicolon
id|dd-&gt;sizes
(braket
id|minor
)braket
op_assign
(paren
id|device-&gt;sizes.blocks
op_lshift
id|device-&gt;sizes.s2b_shift
)paren
op_rshift
l_int|1
suffix:semicolon
macro_line|#if !(LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,3,98))
macro_line|#ifndef MODULE
r_if
c_cond
(paren
id|flags
op_amp
l_int|0x80
)paren
macro_line|#endif
macro_line|#endif&t;&t;&t;&t;/* KERNEL_VERSION */
id|dasd_partn_detect
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|desired_level
op_eq
id|DASD_DEVICE_LEVEL_ANALYSED
)paren
r_break
suffix:semicolon
r_case
id|DASD_DEVICE_LEVEL_ANALYSED
suffix:colon
multiline_comment|/* Fallthrough ?? */
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot;Internal error in &quot;
id|__FILE__
l_string|&quot; on line %d.&quot;
l_string|&quot; validate_dasd called from %p with &quot;
l_string|&quot; desired_level = %d, current_level =%d&quot;
l_string|&quot; Pls send this message and your System.map to&quot;
l_string|&quot; linux390@de.ibm.com&bslash;n&quot;
comma
id|__LINE__
comma
id|__builtin_return_address
(paren
l_int|0
)paren
comma
id|desired_level
comma
id|current_level
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|desired_level
OL
id|current_level
)paren
(brace
multiline_comment|/* donwgrade device status */
r_switch
c_cond
(paren
id|current_level
)paren
(brace
r_case
id|DASD_DEVICE_LEVEL_ANALYSED
suffix:colon
multiline_comment|/* Fallthrough ?? */
id|check_then_set
(paren
op_amp
id|device-&gt;level
comma
id|DASD_DEVICE_LEVEL_ANALYSED
comma
id|DASD_DEVICE_LEVEL_ANALYSIS_PREPARED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|desired_level
op_eq
id|DASD_DEVICE_LEVEL_ANALYSIS_PREPARED
)paren
r_break
suffix:semicolon
r_case
id|DASD_DEVICE_LEVEL_ANALYSIS_PREPARED
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
l_int|1
op_lshift
id|DASD_PARTN_BITS
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|blk_size
(braket
id|major
)braket
(braket
id|minor
)braket
op_assign
l_int|0
suffix:semicolon
id|hardsect_size
(braket
id|major
)braket
(braket
id|minor
op_plus
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|blksize_size
(braket
id|major
)braket
(braket
id|minor
op_plus
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|max_sectors
(braket
id|major
)braket
(braket
id|minor
op_plus
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|memset
(paren
op_amp
id|device-&gt;sizes
comma
l_int|0
comma
r_sizeof
(paren
id|dasd_sizes_t
)paren
)paren
suffix:semicolon
id|check_then_set
(paren
op_amp
id|device-&gt;level
comma
id|DASD_DEVICE_LEVEL_ANALYSIS_PREPARED
comma
id|DASD_DEVICE_LEVEL_ANALYSIS_PENDING
)paren
suffix:semicolon
r_if
c_cond
(paren
id|desired_level
op_eq
id|DASD_DEVICE_LEVEL_ANALYSIS_PENDING
)paren
r_break
suffix:semicolon
r_case
id|DASD_DEVICE_LEVEL_ANALYSIS_PENDING
suffix:colon
multiline_comment|/* Fallthrough ?? */
id|check_then_set
(paren
op_amp
id|device-&gt;level
comma
id|DASD_DEVICE_LEVEL_ANALYSIS_PENDING
comma
id|DASD_DEVICE_LEVEL_RECOGNIZED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|desired_level
op_eq
id|DASD_DEVICE_LEVEL_RECOGNIZED
)paren
r_break
suffix:semicolon
r_case
id|DASD_DEVICE_LEVEL_RECOGNIZED
suffix:colon
multiline_comment|/* Fallthrough ?? */
r_if
c_cond
(paren
id|device-&gt;discipline-&gt;int_handler
)paren
(brace
id|free_irq
(paren
id|irq
comma
op_amp
id|device-&gt;dev_status
)paren
suffix:semicolon
)brace
id|device-&gt;discipline
op_assign
l_int|NULL
suffix:semicolon
id|blk_cleanup_queue
(paren
op_amp
id|device-&gt;request_queue
)paren
suffix:semicolon
id|check_then_set
(paren
op_amp
id|device-&gt;level
comma
id|DASD_DEVICE_LEVEL_RECOGNIZED
comma
id|DASD_DEVICE_LEVEL_UNKNOWN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|desired_level
op_eq
id|DASD_DEVICE_LEVEL_UNKNOWN
)paren
r_break
suffix:semicolon
r_case
id|DASD_DEVICE_LEVEL_UNKNOWN
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot;Internal error in &quot;
id|__FILE__
l_string|&quot; on line %d.&quot;
l_string|&quot; validate_dasd called from %p with &quot;
l_string|&quot; desired_level = %d, current_level =%d&quot;
l_string|&quot; Pls send this message and your System.map to&quot;
l_string|&quot; linux390@de.ibm.com&bslash;n&quot;
comma
id|__LINE__
comma
id|__builtin_return_address
(paren
l_int|0
)paren
comma
id|desired_level
comma
id|current_level
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rc
)paren
(brace
r_goto
m_exit
suffix:semicolon
)brace
id|nomem
suffix:colon
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
m_exit
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* SECTION: Procfs stuff */
r_typedef
r_struct
(brace
DECL|member|data
r_char
op_star
id|data
suffix:semicolon
DECL|member|len
r_int
id|len
suffix:semicolon
DECL|typedef|tempinfo_t
)brace
id|tempinfo_t
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,3,98))
DECL|variable|dasd_proc_root_entry
r_static
r_struct
id|proc_dir_entry
op_star
id|dasd_proc_root_entry
op_assign
l_int|NULL
suffix:semicolon
macro_line|#else
DECL|variable|dasd_proc_root_entry
r_static
r_struct
id|proc_dir_entry
id|dasd_proc_root_entry
op_assign
(brace
id|low_ino
suffix:colon
l_int|0
comma
id|namelen
suffix:colon
l_int|4
comma
id|name
suffix:colon
l_string|&quot;dasd&quot;
comma
id|mode
suffix:colon
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
op_or
id|S_IWUSR
op_or
id|S_IWGRP
comma
id|nlink
suffix:colon
l_int|1
comma
id|uid
suffix:colon
l_int|0
comma
id|gid
suffix:colon
l_int|0
comma
id|size
suffix:colon
l_int|0
)brace
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* KERNEL_VERSION */
DECL|variable|dasd_devices_entry
r_static
r_struct
id|proc_dir_entry
op_star
id|dasd_devices_entry
suffix:semicolon
DECL|variable|dasd_statistics_entry
r_static
r_struct
id|proc_dir_entry
op_star
id|dasd_statistics_entry
suffix:semicolon
r_static
r_int
DECL|function|dasd_devices_open
id|dasd_devices_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|size
op_assign
l_int|1
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|major_info_t
op_star
id|temp
op_assign
id|dasd_major_info
suffix:semicolon
id|tempinfo_t
op_star
id|info
suffix:semicolon
id|info
op_assign
(paren
id|tempinfo_t
op_star
)paren
id|vmalloc
(paren
r_sizeof
(paren
id|tempinfo_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;No memory available for data&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
id|file-&gt;private_data
op_assign
(paren
r_void
op_star
)paren
id|info
suffix:semicolon
)brace
r_while
c_loop
(paren
id|temp
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1
op_lshift
(paren
id|MINORBITS
op_minus
id|DASD_PARTN_BITS
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dasd_device_t
op_star
id|device
op_assign
id|temp-&gt;dasd_device
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|device
)paren
(brace
id|size
op_add_assign
l_int|128
suffix:semicolon
)brace
)brace
id|temp
op_assign
id|temp-&gt;next
suffix:semicolon
)brace
id|temp
op_assign
id|dasd_major_info
suffix:semicolon
id|info-&gt;data
op_assign
(paren
r_char
op_star
)paren
id|vmalloc
(paren
id|size
)paren
suffix:semicolon
multiline_comment|/* FIXME! determine space needed in a better way */
r_if
c_cond
(paren
id|size
op_logical_and
id|info-&gt;data
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;No memory available for data&bslash;n&quot;
)paren
suffix:semicolon
id|vfree
(paren
id|info
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_while
c_loop
(paren
id|temp
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1
op_lshift
(paren
id|MINORBITS
op_minus
id|DASD_PARTN_BITS
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dasd_device_t
op_star
id|device
op_assign
id|temp-&gt;dasd_device
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|device
)paren
(brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;%04X(%s) at (%d:%d) is %7s:&quot;
comma
id|device-&gt;devinfo.devno
comma
id|device-&gt;discipline
ques
c_cond
id|device-&gt;discipline-&gt;name
suffix:colon
l_string|&quot;none&quot;
comma
id|temp-&gt;gendisk.major
comma
id|i
op_lshift
id|DASD_PARTN_BITS
comma
id|device-&gt;name
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|device-&gt;level
)paren
(brace
r_case
id|DASD_DEVICE_LEVEL_UNKNOWN
suffix:colon
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;unknown&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DASD_DEVICE_LEVEL_RECOGNIZED
suffix:colon
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;passive&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot; at blocksize: %d, %ld blocks, %ld MB&bslash;n&quot;
comma
id|device-&gt;sizes.bp_block
comma
id|device-&gt;sizes.blocks
comma
(paren
(paren
id|device-&gt;sizes.bp_block
op_rshift
l_int|9
)paren
op_star
id|device-&gt;sizes.blocks
)paren
op_rshift
l_int|11
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DASD_DEVICE_LEVEL_ANALYSIS_PENDING
suffix:colon
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;busy   &bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DASD_DEVICE_LEVEL_ANALYSIS_PREPARED
suffix:colon
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;n/f    &bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DASD_DEVICE_LEVEL_ANALYSED
suffix:colon
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;active &quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot; at blocksize: %d, %ld blocks, %ld MB&bslash;n&quot;
comma
id|device-&gt;sizes.bp_block
comma
id|device-&gt;sizes.blocks
comma
(paren
(paren
id|device-&gt;sizes.bp_block
op_rshift
l_int|9
)paren
op_star
id|device-&gt;sizes.blocks
)paren
op_rshift
l_int|11
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;no stat&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|temp
op_assign
id|temp-&gt;next
suffix:semicolon
)brace
id|info-&gt;len
op_assign
id|len
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|macro|MIN
mdefine_line|#define MIN(a,b) ((a)&lt;(b)?(a):(b))
r_static
id|ssize_t
DECL|function|dasd_devices_read
id|dasd_devices_read
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|user_buf
comma
r_int
id|user_len
comma
id|loff_t
op_star
id|offset
)paren
(brace
id|loff_t
id|len
suffix:semicolon
id|tempinfo_t
op_star
id|p_info
op_assign
(paren
id|tempinfo_t
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
op_star
id|offset
op_ge
id|p_info-&gt;len
)paren
(brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* EOF */
)brace
r_else
(brace
id|len
op_assign
id|MIN
(paren
id|user_len
comma
(paren
id|p_info-&gt;len
op_minus
op_star
id|offset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
(paren
id|user_buf
comma
op_amp
(paren
id|p_info-&gt;data
(braket
op_star
id|offset
)braket
)paren
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
(paren
op_star
id|offset
)paren
op_add_assign
id|len
suffix:semicolon
r_return
id|len
suffix:semicolon
multiline_comment|/* number of bytes &quot;read&quot; */
)brace
)brace
r_static
id|ssize_t
DECL|function|dasd_devices_write
id|dasd_devices_write
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|user_buf
comma
r_int
id|user_len
comma
id|loff_t
op_star
id|offset
)paren
(brace
r_char
op_star
id|buffer
op_assign
id|vmalloc
(paren
id|user_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
id|buffer
comma
id|user_buf
comma
id|user_len
)paren
)paren
(brace
id|vfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|buffer
(braket
id|user_len
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
(paren
id|KERN_INFO
id|PRINTK_HEADER
l_string|&quot;Now executing %s&bslash;n&quot;
comma
id|buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
(paren
id|buffer
comma
l_string|&quot;add range&quot;
comma
id|strlen
(paren
l_string|&quot;add_range&quot;
)paren
)paren
)paren
(brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
(paren
id|buffer
comma
l_string|&quot;enable device&quot;
comma
id|strlen
(paren
l_string|&quot;enable device&quot;
)paren
)paren
)paren
(brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
(paren
id|buffer
comma
l_string|&quot;disable device&quot;
comma
id|strlen
(paren
l_string|&quot;disable device&quot;
)paren
)paren
)paren
(brace
)brace
r_else
(brace
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot;unknown command %s&quot;
comma
id|buffer
)paren
suffix:semicolon
)brace
id|vfree
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|user_len
suffix:semicolon
)brace
r_static
r_int
DECL|function|dasd_devices_close
id|dasd_devices_close
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|tempinfo_t
op_star
id|p_info
op_assign
(paren
id|tempinfo_t
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|p_info
)paren
(brace
r_if
c_cond
(paren
id|p_info-&gt;data
)paren
id|vfree
(paren
id|p_info-&gt;data
)paren
suffix:semicolon
id|vfree
(paren
id|p_info
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|variable|dasd_devices_file_ops
r_static
r_struct
id|file_operations
id|dasd_devices_file_ops
op_assign
(brace
id|read
suffix:colon
id|dasd_devices_read
comma
multiline_comment|/* read */
id|write
suffix:colon
id|dasd_devices_write
comma
multiline_comment|/* write */
id|open
suffix:colon
id|dasd_devices_open
comma
multiline_comment|/* open */
id|release
suffix:colon
id|dasd_devices_close
comma
multiline_comment|/* close */
)brace
suffix:semicolon
DECL|variable|dasd_devices_inode_ops
r_static
r_struct
id|inode_operations
id|dasd_devices_inode_ops
op_assign
(brace
macro_line|#if !(LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,3,98))
id|default_file_ops
suffix:colon
op_amp
id|dasd_devices_file_ops
multiline_comment|/* file ops */
macro_line|#endif&t;&t;&t;&t;/* LINUX_IS_24 */
)brace
suffix:semicolon
r_static
r_int
DECL|function|dasd_statistics_open
id|dasd_statistics_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|tempinfo_t
op_star
id|info
suffix:semicolon
r_int
id|shift
comma
id|i
comma
id|help
op_assign
l_int|0
suffix:semicolon
id|info
op_assign
(paren
id|tempinfo_t
op_star
)paren
id|vmalloc
(paren
r_sizeof
(paren
id|tempinfo_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;No memory available for data&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
id|file-&gt;private_data
op_assign
(paren
r_void
op_star
)paren
id|info
suffix:semicolon
)brace
id|info-&gt;data
op_assign
(paren
r_char
op_star
)paren
id|vmalloc
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
multiline_comment|/* FIXME! determine space needed in a better way */
r_if
c_cond
(paren
id|info-&gt;data
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;No memory available for data&bslash;n&quot;
)paren
suffix:semicolon
id|vfree
(paren
id|info
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_for
c_loop
(paren
id|shift
op_assign
l_int|0
comma
id|help
op_assign
id|dasd_global_profile.dasd_io_reqs
suffix:semicolon
id|help
OG
l_int|8192
suffix:semicolon
id|help
op_assign
id|help
op_rshift
l_int|1
comma
id|shift
op_increment
)paren
suffix:semicolon
id|len
op_assign
id|sprintf
(paren
id|info-&gt;data
comma
l_string|&quot;%ld dasd I/O requests&bslash;n&quot;
comma
id|dasd_global_profile.dasd_io_reqs
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;__&lt;4 ___8 __16 __32 __64 _128 _256 _512 __1k __2k __4k __8k _16k _32k _64k 128k&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;_256 _512 __1M __2M __4M __8M _16M _32M _64M 128M 256M 512M __1G __2G __4G _&gt;4G&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;Histogram of sizes (512B secs)&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;%4ld &quot;
comma
id|dasd_global_profile.dasd_io_secs
(braket
id|i
)braket
op_rshift
id|shift
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;Histogram of I/O times&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;%4ld &quot;
comma
id|dasd_global_profile.dasd_io_times
(braket
id|i
)braket
op_rshift
id|shift
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;%4ld &quot;
comma
id|dasd_global_profile.dasd_io_times
(braket
id|i
)braket
op_rshift
id|shift
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;Histogram of I/O times per sector&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;%4ld &quot;
comma
id|dasd_global_profile.dasd_io_timps
(braket
id|i
)braket
op_rshift
id|shift
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;%4ld &quot;
comma
id|dasd_global_profile.dasd_io_timps
(braket
id|i
)braket
op_rshift
id|shift
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;Histogram of I/O time till ssch&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;%4ld &quot;
comma
id|dasd_global_profile.dasd_io_time1
(braket
id|i
)braket
op_rshift
id|shift
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;%4ld &quot;
comma
id|dasd_global_profile.dasd_io_time1
(braket
id|i
)braket
op_rshift
id|shift
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;Histogram of I/O time between ssch and irq&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;%4ld &quot;
comma
id|dasd_global_profile.dasd_io_time2
(braket
id|i
)braket
op_rshift
id|shift
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;%4ld &quot;
comma
id|dasd_global_profile.dasd_io_time2
(braket
id|i
)braket
op_rshift
id|shift
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;Histogram of I/O time between ssch and irq per sector&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;%4ld &quot;
comma
id|dasd_global_profile.dasd_io_time2ps
(braket
id|i
)braket
op_rshift
id|shift
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;%4ld &quot;
comma
id|dasd_global_profile.dasd_io_time2ps
(braket
id|i
)braket
op_rshift
id|shift
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;Histogram of I/O time between irq and end&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;%4ld &quot;
comma
id|dasd_global_profile.dasd_io_time3
(braket
id|i
)braket
op_rshift
id|shift
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;%4ld &quot;
comma
id|dasd_global_profile.dasd_io_time3
(braket
id|i
)braket
op_rshift
id|shift
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
(paren
id|info-&gt;data
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|info-&gt;len
op_assign
id|len
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|variable|dasd_statistics_file_ops
r_static
r_struct
id|file_operations
id|dasd_statistics_file_ops
op_assign
(brace
id|read
suffix:colon
id|dasd_devices_read
comma
multiline_comment|/* read */
id|open
suffix:colon
id|dasd_statistics_open
comma
multiline_comment|/* open */
id|release
suffix:colon
id|dasd_devices_close
comma
multiline_comment|/* close */
)brace
suffix:semicolon
DECL|variable|dasd_statistics_inode_ops
r_static
r_struct
id|inode_operations
id|dasd_statistics_inode_ops
op_assign
(brace
macro_line|#if !(LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,3,98))
id|default_file_ops
suffix:colon
op_amp
id|dasd_statistics_file_ops
multiline_comment|/* file ops */
macro_line|#endif&t;&t;&t;&t;/* LINUX_IS_24 */
)brace
suffix:semicolon
r_int
DECL|function|dasd_proc_init
id|dasd_proc_init
(paren
r_void
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,3,98))
id|dasd_proc_root_entry
op_assign
id|proc_mkdir
(paren
l_string|&quot;dasd&quot;
comma
op_amp
id|proc_root
)paren
suffix:semicolon
id|dasd_devices_entry
op_assign
id|create_proc_entry
(paren
l_string|&quot;devices&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
comma
id|dasd_proc_root_entry
)paren
suffix:semicolon
id|dasd_devices_entry-&gt;proc_fops
op_assign
op_amp
id|dasd_devices_file_ops
suffix:semicolon
id|dasd_devices_entry-&gt;proc_iops
op_assign
op_amp
id|dasd_devices_inode_ops
suffix:semicolon
id|dasd_statistics_entry
op_assign
id|create_proc_entry
(paren
l_string|&quot;statistics&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
comma
id|dasd_proc_root_entry
)paren
suffix:semicolon
id|dasd_statistics_entry-&gt;proc_fops
op_assign
op_amp
id|dasd_statistics_file_ops
suffix:semicolon
id|dasd_statistics_entry-&gt;proc_iops
op_assign
op_amp
id|dasd_statistics_inode_ops
suffix:semicolon
macro_line|#else
id|proc_register
(paren
op_amp
id|proc_root
comma
op_amp
id|dasd_proc_root_entry
)paren
suffix:semicolon
id|dasd_devices_entry
op_assign
(paren
r_struct
id|proc_dir_entry
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|proc_dir_entry
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dasd_devices_entry
)paren
(brace
id|memset
(paren
id|dasd_devices_entry
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|proc_dir_entry
)paren
)paren
suffix:semicolon
id|dasd_devices_entry-&gt;name
op_assign
l_string|&quot;devices&quot;
suffix:semicolon
id|dasd_devices_entry-&gt;namelen
op_assign
id|strlen
(paren
l_string|&quot;devices&quot;
)paren
suffix:semicolon
id|dasd_devices_entry-&gt;low_ino
op_assign
l_int|0
suffix:semicolon
id|dasd_devices_entry-&gt;mode
op_assign
(paren
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
)paren
suffix:semicolon
id|dasd_devices_entry-&gt;nlink
op_assign
l_int|1
suffix:semicolon
id|dasd_devices_entry-&gt;uid
op_assign
l_int|0
suffix:semicolon
id|dasd_devices_entry-&gt;gid
op_assign
l_int|0
suffix:semicolon
id|dasd_devices_entry-&gt;size
op_assign
l_int|0
suffix:semicolon
id|dasd_devices_entry-&gt;get_info
op_assign
l_int|NULL
suffix:semicolon
id|dasd_devices_entry-&gt;ops
op_assign
op_amp
id|dasd_devices_inode_ops
suffix:semicolon
id|proc_register
(paren
op_amp
id|dasd_proc_root_entry
comma
id|dasd_devices_entry
)paren
suffix:semicolon
)brace
id|dasd_statistics_entry
op_assign
(paren
r_struct
id|proc_dir_entry
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|proc_dir_entry
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dasd_statistics_entry
)paren
(brace
id|memset
(paren
id|dasd_statistics_entry
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|proc_dir_entry
)paren
)paren
suffix:semicolon
id|dasd_statistics_entry-&gt;name
op_assign
l_string|&quot;statistics&quot;
suffix:semicolon
id|dasd_statistics_entry-&gt;namelen
op_assign
id|strlen
(paren
l_string|&quot;statistics&quot;
)paren
suffix:semicolon
id|dasd_statistics_entry-&gt;low_ino
op_assign
l_int|0
suffix:semicolon
id|dasd_statistics_entry-&gt;mode
op_assign
(paren
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
)paren
suffix:semicolon
id|dasd_statistics_entry-&gt;nlink
op_assign
l_int|1
suffix:semicolon
id|dasd_statistics_entry-&gt;uid
op_assign
l_int|0
suffix:semicolon
id|dasd_statistics_entry-&gt;gid
op_assign
l_int|0
suffix:semicolon
id|dasd_statistics_entry-&gt;size
op_assign
l_int|0
suffix:semicolon
id|dasd_statistics_entry-&gt;get_info
op_assign
l_int|NULL
suffix:semicolon
id|dasd_statistics_entry-&gt;ops
op_assign
op_amp
id|dasd_statistics_inode_ops
suffix:semicolon
id|proc_register
(paren
op_amp
id|dasd_proc_root_entry
comma
id|dasd_statistics_entry
)paren
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* LINUX_IS_24 */
r_return
id|rc
suffix:semicolon
)brace
r_void
DECL|function|dasd_proc_cleanup
id|dasd_proc_cleanup
(paren
r_void
)paren
(brace
macro_line|#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,3,98))
id|remove_proc_entry
(paren
l_string|&quot;devices&quot;
comma
id|dasd_proc_root_entry
)paren
suffix:semicolon
id|remove_proc_entry
(paren
l_string|&quot;statistics&quot;
comma
id|dasd_proc_root_entry
)paren
suffix:semicolon
id|remove_proc_entry
(paren
l_string|&quot;dasd&quot;
comma
op_amp
id|proc_root
)paren
suffix:semicolon
macro_line|#else
id|proc_unregister
(paren
op_amp
id|dasd_proc_root_entry
comma
id|dasd_statistics_entry-&gt;low_ino
)paren
suffix:semicolon
id|kfree
(paren
id|dasd_statistics_entry
)paren
suffix:semicolon
id|proc_unregister
(paren
op_amp
id|dasd_proc_root_entry
comma
id|dasd_devices_entry-&gt;low_ino
)paren
suffix:semicolon
id|kfree
(paren
id|dasd_devices_entry
)paren
suffix:semicolon
id|proc_unregister
(paren
op_amp
id|proc_root
comma
id|dasd_proc_root_entry.low_ino
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* LINUX_IS_24 */
)brace
multiline_comment|/* SECTION: Initializing the driver */
r_int
id|__init
DECL|function|dasd_init
id|dasd_init
(paren
r_void
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|irq
suffix:semicolon
r_int
id|j
suffix:semicolon
id|major_info_t
op_star
id|major_info
suffix:semicolon
id|dasd_range_t
op_star
id|range
suffix:semicolon
id|printk
(paren
id|KERN_INFO
id|PRINTK_HEADER
l_string|&quot;initializing...&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|major_info
op_assign
id|dasd_major_info
suffix:semicolon
id|major_info
suffix:semicolon
id|major_info
op_assign
id|major_info-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dasd_register_major
(paren
id|major_info
)paren
)paren
OG
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_INFO
id|PRINTK_HEADER
l_string|&quot;Registered successfully to major no %u&bslash;n&quot;
comma
id|major_info-&gt;gendisk.major
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot;Couldn&squot;t register successfully to major no %d&bslash;n&quot;
comma
id|major_info-&gt;gendisk.major
)paren
suffix:semicolon
multiline_comment|/* revert registration of major infos */
r_goto
id|major_failed
suffix:semicolon
)brace
)brace
macro_line|#ifndef MODULE
id|dasd_split_parm_string
(paren
id|dasd_parm_string
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* ! MODULE */
id|dasd_parse
(paren
id|dasd
)paren
suffix:semicolon
id|dasd_init_emergency_req
(paren
)paren
suffix:semicolon
id|rc
op_assign
id|dasd_proc_init
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
r_goto
id|proc_failed
suffix:semicolon
)brace
id|genhd_dasd_name
op_assign
id|dasd_device_name
suffix:semicolon
macro_line|#ifdef CONFIG_DASD_ECKD
id|rc
op_assign
id|dasd_eckd_init
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_INFO
id|PRINTK_HEADER
l_string|&quot;Registered ECKD discipline successfully&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_goto
id|eckd_failed
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_ECKD */
macro_line|#ifdef CONFIG_DASD_FBA
id|rc
op_assign
id|dasd_fba_init
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_INFO
id|PRINTK_HEADER
l_string|&quot;Registered FBA discipline successfully&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_goto
id|fba_failed
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_FBA */
macro_line|#ifdef CONFIG_DASD_MDSK
r_if
c_cond
(paren
id|MACHINE_IS_VM
)paren
(brace
id|rc
op_assign
id|dasd_diag_init
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_INFO
id|PRINTK_HEADER
l_string|&quot;Registered MDSK discipline successfully&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_goto
id|mdsk_failed
suffix:semicolon
)brace
)brace
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_MDSK */
id|rc
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|range
op_assign
id|dasd_range_head
suffix:semicolon
id|range
suffix:semicolon
id|range
op_assign
id|range-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
id|range-&gt;from
suffix:semicolon
id|j
op_le
id|range-&gt;to
suffix:semicolon
id|j
op_increment
)paren
(brace
id|irq
op_assign
id|get_irq_by_devno
(paren
id|j
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ge
l_int|0
)paren
id|dasd_set_device_level
(paren
id|irq
comma
id|DASD_DEVICE_LEVEL_ANALYSIS_PREPARED
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dasd_autodetect
)paren
(brace
r_for
c_loop
(paren
id|irq
op_assign
id|get_irq_first
(paren
)paren
suffix:semicolon
id|irq
op_ne
op_minus
id|ENODEV
suffix:semicolon
id|irq
op_assign
id|get_irq_next
(paren
id|irq
)paren
)paren
(brace
r_int
id|devno
op_assign
id|get_devno_by_irq
(paren
id|irq
)paren
suffix:semicolon
r_int
id|index
op_assign
id|dasd_devindex_from_devno
(paren
id|devno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_eq
op_minus
id|ENODEV
)paren
(brace
multiline_comment|/* not included in ranges */
id|dasd_add_range
(paren
id|devno
comma
l_int|0
)paren
suffix:semicolon
id|dasd_set_device_level
(paren
id|irq
comma
id|DASD_DEVICE_LEVEL_ANALYSIS_PREPARED
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
id|printk
(paren
id|KERN_INFO
id|PRINTK_HEADER
l_string|&quot;waiting for responses...&bslash;n&quot;
)paren
suffix:semicolon
(brace
r_static
id|wait_queue_head_t
id|wait_queue
suffix:semicolon
id|init_waitqueue_head
(paren
op_amp
id|wait_queue
)paren
suffix:semicolon
id|interruptible_sleep_on_timeout
(paren
op_amp
id|wait_queue
comma
(paren
l_int|5
op_star
id|HZ
)paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|range
op_assign
id|dasd_range_head
suffix:semicolon
id|range
suffix:semicolon
id|range
op_assign
id|range-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
id|range-&gt;from
suffix:semicolon
id|j
op_le
id|range-&gt;to
suffix:semicolon
id|j
op_increment
)paren
(brace
id|irq
op_assign
id|get_irq_by_devno
(paren
id|j
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ge
l_int|0
)paren
(brace
id|dasd_set_device_level
(paren
id|irq
comma
id|DASD_DEVICE_LEVEL_ANALYSED
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
r_goto
id|out
suffix:semicolon
macro_line|#ifdef CONFIG_DASD_MDSK
id|mdsk_failed
suffix:colon
id|dasd_diag_cleanup
(paren
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_MDSK */
macro_line|#ifdef CONFIG_DASD_FBA
id|fba_failed
suffix:colon
id|dasd_fba_cleanup
(paren
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_FBA */
macro_line|#ifdef CONFIG_DASD_ECKD
id|eckd_failed
suffix:colon
id|dasd_eckd_cleanup
(paren
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* CONFIG_DASD_ECKD */
id|proc_failed
suffix:colon
id|dasd_proc_cleanup
(paren
)paren
suffix:semicolon
id|major_failed
suffix:colon
(brace
id|major_info_t
op_star
id|temp
suffix:semicolon
r_for
c_loop
(paren
id|temp
op_assign
id|dasd_major_info
suffix:semicolon
id|temp
op_logical_and
(paren
id|temp
op_ne
id|major_info
)paren
suffix:semicolon
id|temp
op_assign
id|temp-&gt;next
)paren
(brace
id|dasd_unregister_major
(paren
id|temp
)paren
suffix:semicolon
)brace
)brace
id|dasd_cleanup_emergency_req
(paren
)paren
suffix:semicolon
id|printk
(paren
id|KERN_INFO
id|PRINTK_HEADER
l_string|&quot;initialization not performed due to errors&bslash;n&quot;
)paren
suffix:semicolon
id|out
suffix:colon
id|printk
(paren
id|KERN_INFO
id|PRINTK_HEADER
l_string|&quot;initialization finished&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_void
DECL|function|cleanup_dasd
id|cleanup_dasd
(paren
r_void
)paren
(brace
r_int
id|j
comma
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|irq
suffix:semicolon
id|major_info_t
op_star
id|major_info
suffix:semicolon
id|dasd_range_t
op_star
id|range
comma
op_star
id|next
suffix:semicolon
id|printk
(paren
id|KERN_INFO
id|PRINTK_HEADER
l_string|&quot;shutting down&bslash;n&quot;
)paren
suffix:semicolon
id|dasd_proc_cleanup
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|range
op_assign
id|dasd_range_head
suffix:semicolon
id|range
suffix:semicolon
id|range
op_assign
id|range-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
id|range-&gt;from
suffix:semicolon
id|j
op_le
id|range-&gt;to
suffix:semicolon
id|j
op_increment
)paren
(brace
id|irq
op_assign
id|get_irq_by_devno
(paren
id|j
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ge
l_int|0
)paren
(brace
id|dasd_set_device_level
(paren
id|irq
comma
id|DASD_DEVICE_LEVEL_UNKNOWN
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
r_for
c_loop
(paren
id|major_info
op_assign
id|dasd_major_info
suffix:semicolon
id|major_info
suffix:semicolon
id|major_info
op_assign
id|major_info-&gt;next
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DASD_PER_MAJOR
suffix:semicolon
id|i
op_increment
)paren
(brace
id|kfree
(paren
id|major_info-&gt;dasd_device
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dasd_unregister_major
(paren
id|major_info
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_INFO
id|PRINTK_HEADER
l_string|&quot;Unregistered successfully from major no %u&bslash;n&quot;
comma
id|major_info-&gt;gendisk.major
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_WARNING
id|PRINTK_HEADER
l_string|&quot;Couldn&squot;t unregister successfully from major no %d rc = %d&bslash;n&quot;
comma
id|major_info-&gt;gendisk.major
comma
id|rc
)paren
suffix:semicolon
)brace
)brace
id|dasd_cleanup_emergency_req
(paren
)paren
suffix:semicolon
id|range
op_assign
id|dasd_range_head
suffix:semicolon
r_while
c_loop
(paren
id|range
)paren
(brace
id|next
op_assign
id|range-&gt;next
suffix:semicolon
id|kfree
(paren
id|range
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
r_else
id|range
op_assign
id|next
suffix:semicolon
)brace
id|dasd_range_head
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef CONFIG_DASD_DYNAMIC
(brace
id|dasd_devreg_t
op_star
id|reg
suffix:semicolon
r_while
c_loop
(paren
id|dasd_devreg_head
)paren
(brace
id|reg
op_assign
id|dasd_devreg_head-&gt;next
suffix:semicolon
id|kfree
(paren
id|dasd_devreg_head
)paren
suffix:semicolon
id|dasd_devreg_head
op_assign
id|reg
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* CONFIG_DASD_DYNAMIC */
id|printk
(paren
id|KERN_INFO
id|PRINTK_HEADER
l_string|&quot;shutdown completed&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
r_int
DECL|function|init_module
id|init_module
(paren
r_void
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_return
id|dasd_init
(paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_void
DECL|function|cleanup_module
id|cleanup_module
(paren
r_void
)paren
(brace
id|cleanup_dasd
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Overrides for Emacs so that we follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-indent-level: 4 &n; * c-brace-imaginary-offset: 0&n; * c-brace-offset: -4&n; * c-argdecl-indent: 4&n; * c-label-offset: -4&n; * c-continued-statement-offset: 4&n; * c-continued-brace-offset: 0&n; * indent-tabs-mode: nil&n; * tab-width: 8&n; * End:&n; */
eof
