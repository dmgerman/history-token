multiline_comment|/* Authors: Karl MacMillan &lt;kmacmillan@tresys.com&gt;&n; *          Frank Mayer &lt;mayerf@tresys.com&gt;&n; *&n; * Copyright (C) 2003 - 2004 Tresys Technology, LLC&n; *&t;This program is free software; you can redistribute it and/or modify&n; *  &t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation, version 2.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &quot;security.h&quot;
macro_line|#include &quot;conditional.h&quot;
multiline_comment|/*&n; * cond_evaluate_expr evaluates a conditional expr&n; * in reverse polish notation. It returns true (1), false (0),&n; * or undefined (-1). Undefined occurs when the expression&n; * exceeds the stack depth of COND_EXPR_MAXDEPTH.&n; */
DECL|function|cond_evaluate_expr
r_static
r_int
id|cond_evaluate_expr
c_func
(paren
r_struct
id|policydb
op_star
id|p
comma
r_struct
id|cond_expr
op_star
id|expr
)paren
(brace
r_struct
id|cond_expr
op_star
id|cur
suffix:semicolon
r_int
id|s
(braket
id|COND_EXPR_MAXDEPTH
)braket
suffix:semicolon
r_int
id|sp
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|cur
op_assign
id|expr
suffix:semicolon
id|cur
op_ne
l_int|NULL
suffix:semicolon
id|cur
op_assign
id|cur-&gt;next
)paren
(brace
r_switch
c_cond
(paren
id|cur-&gt;expr_type
)paren
(brace
r_case
id|COND_BOOL
suffix:colon
r_if
c_cond
(paren
id|sp
op_eq
(paren
id|COND_EXPR_MAXDEPTH
op_minus
l_int|1
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|sp
op_increment
suffix:semicolon
id|s
(braket
id|sp
)braket
op_assign
id|p-&gt;bool_val_to_struct
(braket
id|cur
op_member_access_from_pointer
r_bool
op_minus
l_int|1
)braket
op_member_access_from_pointer
id|state
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COND_NOT
suffix:colon
r_if
c_cond
(paren
id|sp
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|s
(braket
id|sp
)braket
op_assign
op_logical_neg
id|s
(braket
id|sp
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COND_OR
suffix:colon
r_if
c_cond
(paren
id|sp
OL
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|sp
op_decrement
suffix:semicolon
id|s
(braket
id|sp
)braket
op_or_assign
id|s
(braket
id|sp
op_plus
l_int|1
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COND_AND
suffix:colon
r_if
c_cond
(paren
id|sp
OL
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|sp
op_decrement
suffix:semicolon
id|s
(braket
id|sp
)braket
op_and_assign
id|s
(braket
id|sp
op_plus
l_int|1
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COND_XOR
suffix:colon
r_if
c_cond
(paren
id|sp
OL
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|sp
op_decrement
suffix:semicolon
id|s
(braket
id|sp
)braket
op_xor_assign
id|s
(braket
id|sp
op_plus
l_int|1
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COND_EQ
suffix:colon
r_if
c_cond
(paren
id|sp
OL
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|sp
op_decrement
suffix:semicolon
id|s
(braket
id|sp
)braket
op_assign
(paren
id|s
(braket
id|sp
)braket
op_eq
id|s
(braket
id|sp
op_plus
l_int|1
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COND_NEQ
suffix:colon
r_if
c_cond
(paren
id|sp
OL
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|sp
op_decrement
suffix:semicolon
id|s
(braket
id|sp
)braket
op_assign
(paren
id|s
(braket
id|sp
)braket
op_ne
id|s
(braket
id|sp
op_plus
l_int|1
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|s
(braket
l_int|0
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * evaluate_cond_node evaluates the conditional stored in&n; * a struct cond_node and if the result is different than the&n; * current state of the node it sets the rules in the true/false&n; * list appropriately. If the result of the expression is undefined&n; * all of the rules are disabled for safety.&n; */
DECL|function|evaluate_cond_node
r_int
id|evaluate_cond_node
c_func
(paren
r_struct
id|policydb
op_star
id|p
comma
r_struct
id|cond_node
op_star
id|node
)paren
(brace
r_int
id|new_state
suffix:semicolon
r_struct
id|cond_av_list
op_star
id|cur
suffix:semicolon
id|new_state
op_assign
id|cond_evaluate_expr
c_func
(paren
id|p
comma
id|node-&gt;expr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_state
op_ne
id|node-&gt;cur_state
)paren
(brace
id|node-&gt;cur_state
op_assign
id|new_state
suffix:semicolon
r_if
c_cond
(paren
id|new_state
op_eq
op_minus
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security: expression result was undefined - disabling all rules.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* turn the rules on or off */
r_for
c_loop
(paren
id|cur
op_assign
id|node-&gt;true_list
suffix:semicolon
id|cur
op_ne
l_int|NULL
suffix:semicolon
id|cur
op_assign
id|cur-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|new_state
op_le
l_int|0
)paren
(brace
id|cur-&gt;node-&gt;datum.specified
op_and_assign
op_complement
id|AVTAB_ENABLED
suffix:semicolon
)brace
r_else
(brace
id|cur-&gt;node-&gt;datum.specified
op_or_assign
id|AVTAB_ENABLED
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|cur
op_assign
id|node-&gt;false_list
suffix:semicolon
id|cur
op_ne
l_int|NULL
suffix:semicolon
id|cur
op_assign
id|cur-&gt;next
)paren
(brace
multiline_comment|/* -1 or 1 */
r_if
c_cond
(paren
id|new_state
)paren
(brace
id|cur-&gt;node-&gt;datum.specified
op_and_assign
op_complement
id|AVTAB_ENABLED
suffix:semicolon
)brace
r_else
(brace
id|cur-&gt;node-&gt;datum.specified
op_or_assign
id|AVTAB_ENABLED
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cond_policydb_init
r_int
id|cond_policydb_init
c_func
(paren
r_struct
id|policydb
op_star
id|p
)paren
(brace
id|p-&gt;bool_val_to_struct
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;cond_list
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|avtab_init
c_func
(paren
op_amp
id|p-&gt;te_cond_avtab
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cond_av_list_destroy
r_static
r_void
id|cond_av_list_destroy
c_func
(paren
r_struct
id|cond_av_list
op_star
id|list
)paren
(brace
r_struct
id|cond_av_list
op_star
id|cur
comma
op_star
id|next
suffix:semicolon
r_for
c_loop
(paren
id|cur
op_assign
id|list
suffix:semicolon
id|cur
op_ne
l_int|NULL
suffix:semicolon
id|cur
op_assign
id|next
)paren
(brace
id|next
op_assign
id|cur-&gt;next
suffix:semicolon
multiline_comment|/* the avtab_ptr_t node is destroy by the avtab */
id|kfree
c_func
(paren
id|cur
)paren
suffix:semicolon
)brace
)brace
DECL|function|cond_node_destroy
r_static
r_void
id|cond_node_destroy
c_func
(paren
r_struct
id|cond_node
op_star
id|node
)paren
(brace
r_struct
id|cond_expr
op_star
id|cur_expr
comma
op_star
id|next_expr
suffix:semicolon
r_for
c_loop
(paren
id|cur_expr
op_assign
id|node-&gt;expr
suffix:semicolon
id|cur_expr
op_ne
l_int|NULL
suffix:semicolon
id|cur_expr
op_assign
id|next_expr
)paren
(brace
id|next_expr
op_assign
id|cur_expr-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|cur_expr
)paren
suffix:semicolon
)brace
id|cond_av_list_destroy
c_func
(paren
id|node-&gt;true_list
)paren
suffix:semicolon
id|cond_av_list_destroy
c_func
(paren
id|node-&gt;false_list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|node
)paren
suffix:semicolon
)brace
DECL|function|cond_list_destroy
r_static
r_void
id|cond_list_destroy
c_func
(paren
r_struct
id|cond_node
op_star
id|list
)paren
(brace
r_struct
id|cond_node
op_star
id|next
comma
op_star
id|cur
suffix:semicolon
r_if
c_cond
(paren
id|list
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|cur
op_assign
id|list
suffix:semicolon
id|cur
op_ne
l_int|NULL
suffix:semicolon
id|cur
op_assign
id|next
)paren
(brace
id|next
op_assign
id|cur-&gt;next
suffix:semicolon
id|cond_node_destroy
c_func
(paren
id|cur
)paren
suffix:semicolon
)brace
)brace
DECL|function|cond_policydb_destroy
r_void
id|cond_policydb_destroy
c_func
(paren
r_struct
id|policydb
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;bool_val_to_struct
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|p-&gt;bool_val_to_struct
)paren
suffix:semicolon
id|avtab_destroy
c_func
(paren
op_amp
id|p-&gt;te_cond_avtab
)paren
suffix:semicolon
id|cond_list_destroy
c_func
(paren
id|p-&gt;cond_list
)paren
suffix:semicolon
)brace
DECL|function|cond_init_bool_indexes
r_int
id|cond_init_bool_indexes
c_func
(paren
r_struct
id|policydb
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;bool_val_to_struct
)paren
id|kfree
c_func
(paren
id|p-&gt;bool_val_to_struct
)paren
suffix:semicolon
id|p-&gt;bool_val_to_struct
op_assign
(paren
r_struct
id|cond_bool_datum
op_star
op_star
)paren
id|kmalloc
c_func
(paren
id|p-&gt;p_bools.nprim
op_star
r_sizeof
(paren
r_struct
id|cond_bool_datum
op_star
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;bool_val_to_struct
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cond_destroy_bool
r_int
id|cond_destroy_bool
c_func
(paren
r_void
op_star
id|key
comma
r_void
op_star
id|datum
comma
r_void
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
id|key
)paren
id|kfree
c_func
(paren
id|key
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|datum
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cond_index_bool
r_int
id|cond_index_bool
c_func
(paren
r_void
op_star
id|key
comma
r_void
op_star
id|datum
comma
r_void
op_star
id|datap
)paren
(brace
r_struct
id|policydb
op_star
id|p
suffix:semicolon
r_struct
id|cond_bool_datum
op_star
id|booldatum
suffix:semicolon
id|booldatum
op_assign
id|datum
suffix:semicolon
id|p
op_assign
id|datap
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|booldatum-&gt;value
op_logical_or
id|booldatum-&gt;value
OG
id|p-&gt;p_bools.nprim
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|p-&gt;p_bool_val_to_name
(braket
id|booldatum-&gt;value
op_minus
l_int|1
)braket
op_assign
id|key
suffix:semicolon
id|p-&gt;bool_val_to_struct
(braket
id|booldatum-&gt;value
op_minus
l_int|1
)braket
op_assign
id|booldatum
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bool_isvalid
r_int
id|bool_isvalid
c_func
(paren
r_struct
id|cond_bool_datum
op_star
id|b
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|b-&gt;state
op_eq
l_int|0
op_logical_or
id|b-&gt;state
op_eq
l_int|1
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|cond_read_bool
r_int
id|cond_read_bool
c_func
(paren
r_struct
id|policydb
op_star
id|p
comma
r_struct
id|hashtab
op_star
id|h
comma
r_void
op_star
id|fp
)paren
(brace
r_char
op_star
id|key
op_assign
l_int|0
suffix:semicolon
r_struct
id|cond_bool_datum
op_star
id|booldatum
suffix:semicolon
id|__u32
op_star
id|buf
comma
id|len
suffix:semicolon
id|booldatum
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|cond_bool_datum
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|booldatum
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|memset
c_func
(paren
id|booldatum
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|cond_bool_datum
)paren
)paren
suffix:semicolon
id|buf
op_assign
id|next_entry
c_func
(paren
id|fp
comma
r_sizeof
(paren
id|__u32
)paren
op_star
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_goto
id|err
suffix:semicolon
id|booldatum-&gt;value
op_assign
id|le32_to_cpu
c_func
(paren
id|buf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|booldatum-&gt;state
op_assign
id|le32_to_cpu
c_func
(paren
id|buf
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bool_isvalid
c_func
(paren
id|booldatum
)paren
)paren
r_goto
id|err
suffix:semicolon
id|len
op_assign
id|le32_to_cpu
c_func
(paren
id|buf
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|buf
op_assign
id|next_entry
c_func
(paren
id|fp
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_goto
id|err
suffix:semicolon
id|key
op_assign
id|kmalloc
c_func
(paren
id|len
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|key
)paren
r_goto
id|err
suffix:semicolon
id|memcpy
c_func
(paren
id|key
comma
id|buf
comma
id|len
)paren
suffix:semicolon
id|key
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|hashtab_insert
c_func
(paren
id|h
comma
id|key
comma
id|booldatum
)paren
)paren
r_goto
id|err
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err
suffix:colon
id|cond_destroy_bool
c_func
(paren
id|key
comma
id|booldatum
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|cond_read_av_list
r_static
r_int
id|cond_read_av_list
c_func
(paren
r_struct
id|policydb
op_star
id|p
comma
r_void
op_star
id|fp
comma
r_struct
id|cond_av_list
op_star
op_star
id|ret_list
comma
r_struct
id|cond_av_list
op_star
id|other
)paren
(brace
r_struct
id|cond_av_list
op_star
id|list
comma
op_star
id|last
op_assign
l_int|NULL
comma
op_star
id|cur
suffix:semicolon
r_struct
id|avtab_key
id|key
suffix:semicolon
r_struct
id|avtab_datum
id|datum
suffix:semicolon
r_struct
id|avtab_node
op_star
id|node_ptr
suffix:semicolon
r_int
id|len
comma
id|i
suffix:semicolon
id|__u32
op_star
id|buf
suffix:semicolon
id|__u8
id|found
suffix:semicolon
op_star
id|ret_list
op_assign
l_int|NULL
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
id|buf
op_assign
id|next_entry
c_func
(paren
id|fp
comma
r_sizeof
(paren
id|__u32
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|len
op_assign
id|le32_to_cpu
c_func
(paren
id|buf
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|avtab_read_item
c_func
(paren
id|fp
comma
op_amp
id|datum
comma
op_amp
id|key
)paren
)paren
r_goto
id|err
suffix:semicolon
multiline_comment|/*&n;&t;&t; * For type rules we have to make certain there aren&squot;t any&n;&t;&t; * conflicting rules by searching the te_avtab and the&n;&t;&t; * cond_te_avtab.&n;&t;&t; */
r_if
c_cond
(paren
id|datum.specified
op_amp
id|AVTAB_TYPE
)paren
(brace
r_if
c_cond
(paren
id|avtab_search
c_func
(paren
op_amp
id|p-&gt;te_avtab
comma
op_amp
id|key
comma
id|AVTAB_TYPE
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;security: type rule already exists outside of a conditional.&quot;
)paren
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If we are reading the false list other will be a pointer to&n;&t;&t;&t; * the true list. We can have duplicate entries if there is only&n;&t;&t;&t; * 1 other entry and it is in our true list.&n;&t;&t;&t; *&n;&t;&t;&t; * If we are reading the true list (other == NULL) there shouldn&squot;t&n;&t;&t;&t; * be any other entries.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|other
)paren
(brace
id|node_ptr
op_assign
id|avtab_search_node
c_func
(paren
op_amp
id|p-&gt;te_cond_avtab
comma
op_amp
id|key
comma
id|AVTAB_TYPE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|node_ptr
)paren
(brace
r_if
c_cond
(paren
id|avtab_search_node_next
c_func
(paren
id|node_ptr
comma
id|AVTAB_TYPE
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;security: too many conflicting type rules.&quot;
)paren
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
id|found
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|cur
op_assign
id|other
suffix:semicolon
id|cur
op_ne
l_int|NULL
suffix:semicolon
id|cur
op_assign
id|cur-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cur-&gt;node
op_eq
id|node_ptr
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;security: conflicting type rules.&quot;
)paren
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|avtab_search
c_func
(paren
op_amp
id|p-&gt;te_cond_avtab
comma
op_amp
id|key
comma
id|AVTAB_TYPE
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;security: conflicting type rules when adding type rule for true.&quot;
)paren
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
)brace
)brace
id|node_ptr
op_assign
id|avtab_insert_nonunique
c_func
(paren
op_amp
id|p-&gt;te_cond_avtab
comma
op_amp
id|key
comma
op_amp
id|datum
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|node_ptr
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;security: could not insert rule.&quot;
)paren
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
id|list
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|cond_av_list
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list
)paren
r_goto
id|err
suffix:semicolon
id|memset
c_func
(paren
id|list
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|cond_av_list
)paren
)paren
suffix:semicolon
id|list-&gt;node
op_assign
id|node_ptr
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
op_star
id|ret_list
op_assign
id|list
suffix:semicolon
r_else
id|last-&gt;next
op_assign
id|list
suffix:semicolon
id|last
op_assign
id|list
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|err
suffix:colon
id|cond_av_list_destroy
c_func
(paren
op_star
id|ret_list
)paren
suffix:semicolon
op_star
id|ret_list
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|expr_isvalid
r_static
r_int
id|expr_isvalid
c_func
(paren
r_struct
id|policydb
op_star
id|p
comma
r_struct
id|cond_expr
op_star
id|expr
)paren
(brace
r_if
c_cond
(paren
id|expr-&gt;expr_type
op_le
l_int|0
op_logical_or
id|expr-&gt;expr_type
OG
id|COND_LAST
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;security: conditional expressions uses unknown operator.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|expr
op_member_access_from_pointer
r_bool
OG
id|p-&gt;p_bools.nprim
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;security: conditional expressions uses unknown bool.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|cond_read_node
r_static
r_int
id|cond_read_node
c_func
(paren
r_struct
id|policydb
op_star
id|p
comma
r_struct
id|cond_node
op_star
id|node
comma
r_void
op_star
id|fp
)paren
(brace
id|__u32
op_star
id|buf
suffix:semicolon
r_int
id|len
comma
id|i
suffix:semicolon
r_struct
id|cond_expr
op_star
id|expr
op_assign
l_int|NULL
comma
op_star
id|last
op_assign
l_int|NULL
suffix:semicolon
id|buf
op_assign
id|next_entry
c_func
(paren
id|fp
comma
r_sizeof
(paren
id|__u32
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|node-&gt;cur_state
op_assign
id|le32_to_cpu
c_func
(paren
id|buf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
id|buf
op_assign
id|next_entry
c_func
(paren
id|fp
comma
r_sizeof
(paren
id|__u32
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* expr */
id|len
op_assign
id|le32_to_cpu
c_func
(paren
id|buf
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|buf
op_assign
id|next_entry
c_func
(paren
id|fp
comma
r_sizeof
(paren
id|__u32
)paren
op_star
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_goto
id|err
suffix:semicolon
id|expr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|cond_expr
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|expr
)paren
(brace
r_goto
id|err
suffix:semicolon
)brace
id|memset
c_func
(paren
id|expr
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|cond_expr
)paren
)paren
suffix:semicolon
id|expr-&gt;expr_type
op_assign
id|le32_to_cpu
c_func
(paren
id|buf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|expr
op_member_access_from_pointer
r_bool
op_assign
id|le32_to_cpu
c_func
(paren
id|buf
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|expr_isvalid
c_func
(paren
id|p
comma
id|expr
)paren
)paren
r_goto
id|err
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|node-&gt;expr
op_assign
id|expr
suffix:semicolon
)brace
r_else
(brace
id|last-&gt;next
op_assign
id|expr
suffix:semicolon
)brace
id|last
op_assign
id|expr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cond_read_av_list
c_func
(paren
id|p
comma
id|fp
comma
op_amp
id|node-&gt;true_list
comma
l_int|NULL
)paren
op_ne
l_int|0
)paren
r_goto
id|err
suffix:semicolon
r_if
c_cond
(paren
id|cond_read_av_list
c_func
(paren
id|p
comma
id|fp
comma
op_amp
id|node-&gt;false_list
comma
id|node-&gt;true_list
)paren
op_ne
l_int|0
)paren
r_goto
id|err
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err
suffix:colon
id|cond_node_destroy
c_func
(paren
id|node
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|cond_read_list
r_int
id|cond_read_list
c_func
(paren
r_struct
id|policydb
op_star
id|p
comma
r_void
op_star
id|fp
)paren
(brace
r_struct
id|cond_node
op_star
id|node
comma
op_star
id|last
op_assign
l_int|NULL
suffix:semicolon
id|__u32
op_star
id|buf
suffix:semicolon
r_int
id|i
comma
id|len
suffix:semicolon
id|buf
op_assign
id|next_entry
c_func
(paren
id|fp
comma
r_sizeof
(paren
id|__u32
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|len
op_assign
id|le32_to_cpu
c_func
(paren
id|buf
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|node
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|cond_node
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|node
)paren
r_goto
id|err
suffix:semicolon
id|memset
c_func
(paren
id|node
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|cond_node
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cond_read_node
c_func
(paren
id|p
comma
id|node
comma
id|fp
)paren
op_ne
l_int|0
)paren
r_goto
id|err
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|p-&gt;cond_list
op_assign
id|node
suffix:semicolon
)brace
r_else
(brace
id|last-&gt;next
op_assign
id|node
suffix:semicolon
)brace
id|last
op_assign
id|node
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|err
suffix:colon
id|cond_list_destroy
c_func
(paren
id|p-&gt;cond_list
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Determine whether additional permissions are granted by the conditional&n; * av table, and if so, add them to the result&n; */
DECL|function|cond_compute_av
r_void
id|cond_compute_av
c_func
(paren
r_struct
id|avtab
op_star
id|ctab
comma
r_struct
id|avtab_key
op_star
id|key
comma
r_struct
id|av_decision
op_star
id|avd
)paren
(brace
r_struct
id|avtab_node
op_star
id|node
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctab
op_logical_or
op_logical_neg
id|key
op_logical_or
op_logical_neg
id|avd
)paren
(brace
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|node
op_assign
id|avtab_search_node
c_func
(paren
id|ctab
comma
id|key
comma
id|AVTAB_AV
)paren
suffix:semicolon
id|node
op_ne
l_int|NULL
suffix:semicolon
id|node
op_assign
id|avtab_search_node_next
c_func
(paren
id|node
comma
id|AVTAB_AV
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|__u32
)paren
(paren
id|AVTAB_ALLOWED
op_or
id|AVTAB_ENABLED
)paren
op_eq
(paren
id|node-&gt;datum.specified
op_amp
(paren
id|AVTAB_ALLOWED
op_or
id|AVTAB_ENABLED
)paren
)paren
)paren
id|avd-&gt;allowed
op_or_assign
id|avtab_allowed
c_func
(paren
op_amp
id|node-&gt;datum
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|__u32
)paren
(paren
id|AVTAB_AUDITDENY
op_or
id|AVTAB_ENABLED
)paren
op_eq
(paren
id|node-&gt;datum.specified
op_amp
(paren
id|AVTAB_AUDITDENY
op_or
id|AVTAB_ENABLED
)paren
)paren
)paren
multiline_comment|/* Since a &squot;0&squot; in an auditdeny mask represents a&n;&t;&t;&t; * permission we do NOT want to audit (dontaudit), we use&n;&t;&t;&t; * the &squot;&amp;&squot; operand to ensure that all &squot;0&squot;s in the mask&n;&t;&t;&t; * are retained (much unlike the allow and auditallow cases).&n;&t;&t;&t; */
id|avd-&gt;auditdeny
op_and_assign
id|avtab_auditdeny
c_func
(paren
op_amp
id|node-&gt;datum
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|__u32
)paren
(paren
id|AVTAB_AUDITALLOW
op_or
id|AVTAB_ENABLED
)paren
op_eq
(paren
id|node-&gt;datum.specified
op_amp
(paren
id|AVTAB_AUDITALLOW
op_or
id|AVTAB_ENABLED
)paren
)paren
)paren
id|avd-&gt;auditallow
op_or_assign
id|avtab_auditallow
c_func
(paren
op_amp
id|node-&gt;datum
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
eof
