multiline_comment|/*&n; * Implementation of the security services.&n; *&n; * Authors : Stephen Smalley, &lt;sds@epoch.ncsc.mil&gt;&n; *           James Morris &lt;jmorris@redhat.com&gt;&n; *&n; * Updated: Trusted Computer Solutions, Inc. &lt;dgoeddel@trustedcs.com&gt;&n; *&n; *&t;Support for enhanced MLS infrastructure.&n; *&n; * Updated: Frank Mayer &lt;mayerf@tresys.com&gt; and Karl MacMillan &lt;kmacmillan@tresys.com&gt;&n; *&n; * &t;Added conditional policy language extensions&n; *&n; * Copyright (C) 2004-2005 Trusted Computer Solutions, Inc.&n; * Copyright (C) 2003 - 2004 Tresys Technology, LLC&n; * Copyright (C) 2003 Red Hat, Inc., James Morris &lt;jmorris@redhat.com&gt;&n; *&t;This program is free software; you can redistribute it and/or modify&n; *  &t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation, version 2.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/audit.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &quot;flask.h&quot;
macro_line|#include &quot;avc.h&quot;
macro_line|#include &quot;avc_ss.h&quot;
macro_line|#include &quot;security.h&quot;
macro_line|#include &quot;context.h&quot;
macro_line|#include &quot;policydb.h&quot;
macro_line|#include &quot;sidtab.h&quot;
macro_line|#include &quot;services.h&quot;
macro_line|#include &quot;conditional.h&quot;
macro_line|#include &quot;mls.h&quot;
r_extern
r_void
id|selnl_notify_policyload
c_func
(paren
id|u32
id|seqno
)paren
suffix:semicolon
DECL|variable|policydb_loaded_version
r_int
r_int
id|policydb_loaded_version
suffix:semicolon
r_static
id|DEFINE_RWLOCK
c_func
(paren
id|policy_rwlock
)paren
suffix:semicolon
DECL|macro|POLICY_RDLOCK
mdefine_line|#define POLICY_RDLOCK read_lock(&amp;policy_rwlock)
DECL|macro|POLICY_WRLOCK
mdefine_line|#define POLICY_WRLOCK write_lock_irq(&amp;policy_rwlock)
DECL|macro|POLICY_RDUNLOCK
mdefine_line|#define POLICY_RDUNLOCK read_unlock(&amp;policy_rwlock)
DECL|macro|POLICY_WRUNLOCK
mdefine_line|#define POLICY_WRUNLOCK write_unlock_irq(&amp;policy_rwlock)
r_static
id|DECLARE_MUTEX
c_func
(paren
id|load_sem
)paren
suffix:semicolon
DECL|macro|LOAD_LOCK
mdefine_line|#define LOAD_LOCK down(&amp;load_sem)
DECL|macro|LOAD_UNLOCK
mdefine_line|#define LOAD_UNLOCK up(&amp;load_sem)
DECL|variable|sidtab
r_static
r_struct
id|sidtab
id|sidtab
suffix:semicolon
DECL|variable|policydb
r_struct
id|policydb
id|policydb
suffix:semicolon
DECL|variable|ss_initialized
r_int
id|ss_initialized
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * The largest sequence number that has been used when&n; * providing an access decision to the access vector cache.&n; * The sequence number only changes when a policy change&n; * occurs.&n; */
DECL|variable|latest_granting
r_static
id|u32
id|latest_granting
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Forward declaration. */
r_static
r_int
id|context_struct_to_string
c_func
(paren
r_struct
id|context
op_star
id|context
comma
r_char
op_star
op_star
id|scontext
comma
id|u32
op_star
id|scontext_len
)paren
suffix:semicolon
multiline_comment|/*&n; * Return the boolean value of a constraint expression&n; * when it is applied to the specified source and target&n; * security contexts.&n; *&n; * xcontext is a special beast...  It is used by the validatetrans rules&n; * only.  For these rules, scontext is the context before the transition,&n; * tcontext is the context after the transition, and xcontext is the context&n; * of the process performing the transition.  All other callers of&n; * constraint_expr_eval should pass in NULL for xcontext.&n; */
DECL|function|constraint_expr_eval
r_static
r_int
id|constraint_expr_eval
c_func
(paren
r_struct
id|context
op_star
id|scontext
comma
r_struct
id|context
op_star
id|tcontext
comma
r_struct
id|context
op_star
id|xcontext
comma
r_struct
id|constraint_expr
op_star
id|cexpr
)paren
(brace
id|u32
id|val1
comma
id|val2
suffix:semicolon
r_struct
id|context
op_star
id|c
suffix:semicolon
r_struct
id|role_datum
op_star
id|r1
comma
op_star
id|r2
suffix:semicolon
r_struct
id|mls_level
op_star
id|l1
comma
op_star
id|l2
suffix:semicolon
r_struct
id|constraint_expr
op_star
id|e
suffix:semicolon
r_int
id|s
(braket
id|CEXPR_MAXDEPTH
)braket
suffix:semicolon
r_int
id|sp
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
id|cexpr
suffix:semicolon
id|e
suffix:semicolon
id|e
op_assign
id|e-&gt;next
)paren
(brace
r_switch
c_cond
(paren
id|e-&gt;expr_type
)paren
(brace
r_case
id|CEXPR_NOT
suffix:colon
id|BUG_ON
c_func
(paren
id|sp
OL
l_int|0
)paren
suffix:semicolon
id|s
(braket
id|sp
)braket
op_assign
op_logical_neg
id|s
(braket
id|sp
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CEXPR_AND
suffix:colon
id|BUG_ON
c_func
(paren
id|sp
OL
l_int|1
)paren
suffix:semicolon
id|sp
op_decrement
suffix:semicolon
id|s
(braket
id|sp
)braket
op_and_assign
id|s
(braket
id|sp
op_plus
l_int|1
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CEXPR_OR
suffix:colon
id|BUG_ON
c_func
(paren
id|sp
OL
l_int|1
)paren
suffix:semicolon
id|sp
op_decrement
suffix:semicolon
id|s
(braket
id|sp
)braket
op_or_assign
id|s
(braket
id|sp
op_plus
l_int|1
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CEXPR_ATTR
suffix:colon
r_if
c_cond
(paren
id|sp
op_eq
(paren
id|CEXPR_MAXDEPTH
op_minus
l_int|1
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|e-&gt;attr
)paren
(brace
r_case
id|CEXPR_USER
suffix:colon
id|val1
op_assign
id|scontext-&gt;user
suffix:semicolon
id|val2
op_assign
id|tcontext-&gt;user
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CEXPR_TYPE
suffix:colon
id|val1
op_assign
id|scontext-&gt;type
suffix:semicolon
id|val2
op_assign
id|tcontext-&gt;type
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CEXPR_ROLE
suffix:colon
id|val1
op_assign
id|scontext-&gt;role
suffix:semicolon
id|val2
op_assign
id|tcontext-&gt;role
suffix:semicolon
id|r1
op_assign
id|policydb.role_val_to_struct
(braket
id|val1
op_minus
l_int|1
)braket
suffix:semicolon
id|r2
op_assign
id|policydb.role_val_to_struct
(braket
id|val2
op_minus
l_int|1
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|e-&gt;op
)paren
(brace
r_case
id|CEXPR_DOM
suffix:colon
id|s
(braket
op_increment
id|sp
)braket
op_assign
id|ebitmap_get_bit
c_func
(paren
op_amp
id|r1-&gt;dominates
comma
id|val2
op_minus
l_int|1
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|CEXPR_DOMBY
suffix:colon
id|s
(braket
op_increment
id|sp
)braket
op_assign
id|ebitmap_get_bit
c_func
(paren
op_amp
id|r2-&gt;dominates
comma
id|val1
op_minus
l_int|1
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|CEXPR_INCOMP
suffix:colon
id|s
(braket
op_increment
id|sp
)braket
op_assign
(paren
op_logical_neg
id|ebitmap_get_bit
c_func
(paren
op_amp
id|r1-&gt;dominates
comma
id|val2
op_minus
l_int|1
)paren
op_logical_and
op_logical_neg
id|ebitmap_get_bit
c_func
(paren
op_amp
id|r2-&gt;dominates
comma
id|val1
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CEXPR_L1L2
suffix:colon
id|l1
op_assign
op_amp
(paren
id|scontext-&gt;range.level
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|l2
op_assign
op_amp
(paren
id|tcontext-&gt;range.level
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_goto
id|mls_ops
suffix:semicolon
r_case
id|CEXPR_L1H2
suffix:colon
id|l1
op_assign
op_amp
(paren
id|scontext-&gt;range.level
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|l2
op_assign
op_amp
(paren
id|tcontext-&gt;range.level
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_goto
id|mls_ops
suffix:semicolon
r_case
id|CEXPR_H1L2
suffix:colon
id|l1
op_assign
op_amp
(paren
id|scontext-&gt;range.level
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|l2
op_assign
op_amp
(paren
id|tcontext-&gt;range.level
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_goto
id|mls_ops
suffix:semicolon
r_case
id|CEXPR_H1H2
suffix:colon
id|l1
op_assign
op_amp
(paren
id|scontext-&gt;range.level
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|l2
op_assign
op_amp
(paren
id|tcontext-&gt;range.level
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_goto
id|mls_ops
suffix:semicolon
r_case
id|CEXPR_L1H1
suffix:colon
id|l1
op_assign
op_amp
(paren
id|scontext-&gt;range.level
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|l2
op_assign
op_amp
(paren
id|scontext-&gt;range.level
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_goto
id|mls_ops
suffix:semicolon
r_case
id|CEXPR_L2H2
suffix:colon
id|l1
op_assign
op_amp
(paren
id|tcontext-&gt;range.level
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|l2
op_assign
op_amp
(paren
id|tcontext-&gt;range.level
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_goto
id|mls_ops
suffix:semicolon
id|mls_ops
suffix:colon
r_switch
c_cond
(paren
id|e-&gt;op
)paren
(brace
r_case
id|CEXPR_EQ
suffix:colon
id|s
(braket
op_increment
id|sp
)braket
op_assign
id|mls_level_eq
c_func
(paren
id|l1
comma
id|l2
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|CEXPR_NEQ
suffix:colon
id|s
(braket
op_increment
id|sp
)braket
op_assign
op_logical_neg
id|mls_level_eq
c_func
(paren
id|l1
comma
id|l2
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|CEXPR_DOM
suffix:colon
id|s
(braket
op_increment
id|sp
)braket
op_assign
id|mls_level_dom
c_func
(paren
id|l1
comma
id|l2
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|CEXPR_DOMBY
suffix:colon
id|s
(braket
op_increment
id|sp
)braket
op_assign
id|mls_level_dom
c_func
(paren
id|l2
comma
id|l1
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|CEXPR_INCOMP
suffix:colon
id|s
(braket
op_increment
id|sp
)braket
op_assign
id|mls_level_incomp
c_func
(paren
id|l2
comma
id|l1
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|e-&gt;op
)paren
(brace
r_case
id|CEXPR_EQ
suffix:colon
id|s
(braket
op_increment
id|sp
)braket
op_assign
(paren
id|val1
op_eq
id|val2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CEXPR_NEQ
suffix:colon
id|s
(braket
op_increment
id|sp
)braket
op_assign
(paren
id|val1
op_ne
id|val2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CEXPR_NAMES
suffix:colon
r_if
c_cond
(paren
id|sp
op_eq
(paren
id|CEXPR_MAXDEPTH
op_minus
l_int|1
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|c
op_assign
id|scontext
suffix:semicolon
r_if
c_cond
(paren
id|e-&gt;attr
op_amp
id|CEXPR_TARGET
)paren
id|c
op_assign
id|tcontext
suffix:semicolon
r_else
r_if
c_cond
(paren
id|e-&gt;attr
op_amp
id|CEXPR_XTARGET
)paren
(brace
id|c
op_assign
id|xcontext
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|e-&gt;attr
op_amp
id|CEXPR_USER
)paren
id|val1
op_assign
id|c-&gt;user
suffix:semicolon
r_else
r_if
c_cond
(paren
id|e-&gt;attr
op_amp
id|CEXPR_ROLE
)paren
id|val1
op_assign
id|c-&gt;role
suffix:semicolon
r_else
r_if
c_cond
(paren
id|e-&gt;attr
op_amp
id|CEXPR_TYPE
)paren
id|val1
op_assign
id|c-&gt;type
suffix:semicolon
r_else
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|e-&gt;op
)paren
(brace
r_case
id|CEXPR_EQ
suffix:colon
id|s
(braket
op_increment
id|sp
)braket
op_assign
id|ebitmap_get_bit
c_func
(paren
op_amp
id|e-&gt;names
comma
id|val1
op_minus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CEXPR_NEQ
suffix:colon
id|s
(braket
op_increment
id|sp
)braket
op_assign
op_logical_neg
id|ebitmap_get_bit
c_func
(paren
op_amp
id|e-&gt;names
comma
id|val1
op_minus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|BUG_ON
c_func
(paren
id|sp
op_ne
l_int|0
)paren
suffix:semicolon
r_return
id|s
(braket
l_int|0
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * Compute access vectors based on a context structure pair for&n; * the permissions in a particular class.&n; */
DECL|function|context_struct_compute_av
r_static
r_int
id|context_struct_compute_av
c_func
(paren
r_struct
id|context
op_star
id|scontext
comma
r_struct
id|context
op_star
id|tcontext
comma
id|u16
id|tclass
comma
id|u32
id|requested
comma
r_struct
id|av_decision
op_star
id|avd
)paren
(brace
r_struct
id|constraint_node
op_star
id|constraint
suffix:semicolon
r_struct
id|role_allow
op_star
id|ra
suffix:semicolon
r_struct
id|avtab_key
id|avkey
suffix:semicolon
r_struct
id|avtab_datum
op_star
id|avdatum
suffix:semicolon
r_struct
id|class_datum
op_star
id|tclass_datum
suffix:semicolon
multiline_comment|/*&n;&t; * Remap extended Netlink classes for old policy versions.&n;&t; * Do this here rather than socket_type_to_security_class()&n;&t; * in case a newer policy version is loaded, allowing sockets&n;&t; * to remain in the correct class.&n;&t; */
r_if
c_cond
(paren
id|policydb_loaded_version
OL
id|POLICYDB_VERSION_NLCLASS
)paren
r_if
c_cond
(paren
id|tclass
op_ge
id|SECCLASS_NETLINK_ROUTE_SOCKET
op_logical_and
id|tclass
op_le
id|SECCLASS_NETLINK_DNRT_SOCKET
)paren
id|tclass
op_assign
id|SECCLASS_NETLINK_SOCKET
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tclass
op_logical_or
id|tclass
OG
id|policydb.p_classes.nprim
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security_compute_av:  unrecognized class %d&bslash;n&quot;
comma
id|tclass
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|tclass_datum
op_assign
id|policydb.class_val_to_struct
(braket
id|tclass
op_minus
l_int|1
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the access vectors to the default values.&n;&t; */
id|avd-&gt;allowed
op_assign
l_int|0
suffix:semicolon
id|avd-&gt;decided
op_assign
l_int|0xffffffff
suffix:semicolon
id|avd-&gt;auditallow
op_assign
l_int|0
suffix:semicolon
id|avd-&gt;auditdeny
op_assign
l_int|0xffffffff
suffix:semicolon
id|avd-&gt;seqno
op_assign
id|latest_granting
suffix:semicolon
multiline_comment|/*&n;&t; * If a specific type enforcement rule was defined for&n;&t; * this permission check, then use it.&n;&t; */
id|avkey.source_type
op_assign
id|scontext-&gt;type
suffix:semicolon
id|avkey.target_type
op_assign
id|tcontext-&gt;type
suffix:semicolon
id|avkey.target_class
op_assign
id|tclass
suffix:semicolon
id|avdatum
op_assign
id|avtab_search
c_func
(paren
op_amp
id|policydb.te_avtab
comma
op_amp
id|avkey
comma
id|AVTAB_AV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|avdatum
)paren
(brace
r_if
c_cond
(paren
id|avdatum-&gt;specified
op_amp
id|AVTAB_ALLOWED
)paren
id|avd-&gt;allowed
op_assign
id|avtab_allowed
c_func
(paren
id|avdatum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|avdatum-&gt;specified
op_amp
id|AVTAB_AUDITDENY
)paren
id|avd-&gt;auditdeny
op_assign
id|avtab_auditdeny
c_func
(paren
id|avdatum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|avdatum-&gt;specified
op_amp
id|AVTAB_AUDITALLOW
)paren
id|avd-&gt;auditallow
op_assign
id|avtab_auditallow
c_func
(paren
id|avdatum
)paren
suffix:semicolon
)brace
multiline_comment|/* Check conditional av table for additional permissions */
id|cond_compute_av
c_func
(paren
op_amp
id|policydb.te_cond_avtab
comma
op_amp
id|avkey
comma
id|avd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Remove any permissions prohibited by a constraint (this includes&n;&t; * the MLS policy).&n;&t; */
id|constraint
op_assign
id|tclass_datum-&gt;constraints
suffix:semicolon
r_while
c_loop
(paren
id|constraint
)paren
(brace
r_if
c_cond
(paren
(paren
id|constraint-&gt;permissions
op_amp
(paren
id|avd-&gt;allowed
)paren
)paren
op_logical_and
op_logical_neg
id|constraint_expr_eval
c_func
(paren
id|scontext
comma
id|tcontext
comma
l_int|NULL
comma
id|constraint-&gt;expr
)paren
)paren
(brace
id|avd-&gt;allowed
op_assign
(paren
id|avd-&gt;allowed
)paren
op_amp
op_complement
(paren
id|constraint-&gt;permissions
)paren
suffix:semicolon
)brace
id|constraint
op_assign
id|constraint-&gt;next
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If checking process transition permission and the&n;&t; * role is changing, then check the (current_role, new_role)&n;&t; * pair.&n;&t; */
r_if
c_cond
(paren
id|tclass
op_eq
id|SECCLASS_PROCESS
op_logical_and
(paren
id|avd-&gt;allowed
op_amp
(paren
id|PROCESS__TRANSITION
op_or
id|PROCESS__DYNTRANSITION
)paren
)paren
op_logical_and
id|scontext-&gt;role
op_ne
id|tcontext-&gt;role
)paren
(brace
r_for
c_loop
(paren
id|ra
op_assign
id|policydb.role_allow
suffix:semicolon
id|ra
suffix:semicolon
id|ra
op_assign
id|ra-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|scontext-&gt;role
op_eq
id|ra-&gt;role
op_logical_and
id|tcontext-&gt;role
op_eq
id|ra-&gt;new_role
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ra
)paren
id|avd-&gt;allowed
op_assign
(paren
id|avd-&gt;allowed
)paren
op_amp
op_complement
(paren
id|PROCESS__TRANSITION
op_or
id|PROCESS__DYNTRANSITION
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|security_validtrans_handle_fail
r_static
r_int
id|security_validtrans_handle_fail
c_func
(paren
r_struct
id|context
op_star
id|ocontext
comma
r_struct
id|context
op_star
id|ncontext
comma
r_struct
id|context
op_star
id|tcontext
comma
id|u16
id|tclass
)paren
(brace
r_char
op_star
id|o
op_assign
l_int|NULL
comma
op_star
id|n
op_assign
l_int|NULL
comma
op_star
id|t
op_assign
l_int|NULL
suffix:semicolon
id|u32
id|olen
comma
id|nlen
comma
id|tlen
suffix:semicolon
r_if
c_cond
(paren
id|context_struct_to_string
c_func
(paren
id|ocontext
comma
op_amp
id|o
comma
op_amp
id|olen
)paren
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|context_struct_to_string
c_func
(paren
id|ncontext
comma
op_amp
id|n
comma
op_amp
id|nlen
)paren
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|context_struct_to_string
c_func
(paren
id|tcontext
comma
op_amp
id|t
comma
op_amp
id|tlen
)paren
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|audit_log
c_func
(paren
id|current-&gt;audit_context
comma
l_string|&quot;security_validate_transition:  denied for&quot;
l_string|&quot; oldcontext=%s newcontext=%s taskcontext=%s tclass=%s&quot;
comma
id|o
comma
id|n
comma
id|t
comma
id|policydb.p_class_val_to_name
(braket
id|tclass
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|out
suffix:colon
id|kfree
c_func
(paren
id|o
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|n
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|t
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|selinux_enforcing
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
DECL|function|security_validate_transition
r_int
id|security_validate_transition
c_func
(paren
id|u32
id|oldsid
comma
id|u32
id|newsid
comma
id|u32
id|tasksid
comma
id|u16
id|tclass
)paren
(brace
r_struct
id|context
op_star
id|ocontext
suffix:semicolon
r_struct
id|context
op_star
id|ncontext
suffix:semicolon
r_struct
id|context
op_star
id|tcontext
suffix:semicolon
r_struct
id|class_datum
op_star
id|tclass_datum
suffix:semicolon
r_struct
id|constraint_node
op_star
id|constraint
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ss_initialized
)paren
r_return
l_int|0
suffix:semicolon
id|POLICY_RDLOCK
suffix:semicolon
multiline_comment|/*&n;&t; * Remap extended Netlink classes for old policy versions.&n;&t; * Do this here rather than socket_type_to_security_class()&n;&t; * in case a newer policy version is loaded, allowing sockets&n;&t; * to remain in the correct class.&n;&t; */
r_if
c_cond
(paren
id|policydb_loaded_version
OL
id|POLICYDB_VERSION_NLCLASS
)paren
r_if
c_cond
(paren
id|tclass
op_ge
id|SECCLASS_NETLINK_ROUTE_SOCKET
op_logical_and
id|tclass
op_le
id|SECCLASS_NETLINK_DNRT_SOCKET
)paren
id|tclass
op_assign
id|SECCLASS_NETLINK_SOCKET
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tclass
op_logical_or
id|tclass
OG
id|policydb.p_classes.nprim
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security_validate_transition:  &quot;
l_string|&quot;unrecognized class %d&bslash;n&quot;
comma
id|tclass
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|tclass_datum
op_assign
id|policydb.class_val_to_struct
(braket
id|tclass
op_minus
l_int|1
)braket
suffix:semicolon
id|ocontext
op_assign
id|sidtab_search
c_func
(paren
op_amp
id|sidtab
comma
id|oldsid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ocontext
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security_validate_transition: &quot;
l_string|&quot; unrecognized SID %d&bslash;n&quot;
comma
id|oldsid
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|ncontext
op_assign
id|sidtab_search
c_func
(paren
op_amp
id|sidtab
comma
id|newsid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ncontext
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security_validate_transition: &quot;
l_string|&quot; unrecognized SID %d&bslash;n&quot;
comma
id|newsid
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|tcontext
op_assign
id|sidtab_search
c_func
(paren
op_amp
id|sidtab
comma
id|tasksid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcontext
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security_validate_transition: &quot;
l_string|&quot; unrecognized SID %d&bslash;n&quot;
comma
id|tasksid
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|constraint
op_assign
id|tclass_datum-&gt;validatetrans
suffix:semicolon
r_while
c_loop
(paren
id|constraint
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|constraint_expr_eval
c_func
(paren
id|ocontext
comma
id|ncontext
comma
id|tcontext
comma
id|constraint-&gt;expr
)paren
)paren
(brace
id|rc
op_assign
id|security_validtrans_handle_fail
c_func
(paren
id|ocontext
comma
id|ncontext
comma
id|tcontext
comma
id|tclass
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|constraint
op_assign
id|constraint-&gt;next
suffix:semicolon
)brace
id|out
suffix:colon
id|POLICY_RDUNLOCK
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; * security_compute_av - Compute access vector decisions.&n; * @ssid: source security identifier&n; * @tsid: target security identifier&n; * @tclass: target security class&n; * @requested: requested permissions&n; * @avd: access vector decisions&n; *&n; * Compute a set of access vector decisions based on the&n; * SID pair (@ssid, @tsid) for the permissions in @tclass.&n; * Return -%EINVAL if any of the parameters are invalid or %0&n; * if the access vector decisions were computed successfully.&n; */
DECL|function|security_compute_av
r_int
id|security_compute_av
c_func
(paren
id|u32
id|ssid
comma
id|u32
id|tsid
comma
id|u16
id|tclass
comma
id|u32
id|requested
comma
r_struct
id|av_decision
op_star
id|avd
)paren
(brace
r_struct
id|context
op_star
id|scontext
op_assign
l_int|NULL
comma
op_star
id|tcontext
op_assign
l_int|NULL
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ss_initialized
)paren
(brace
id|avd-&gt;allowed
op_assign
id|requested
suffix:semicolon
id|avd-&gt;decided
op_assign
id|requested
suffix:semicolon
id|avd-&gt;auditallow
op_assign
l_int|0
suffix:semicolon
id|avd-&gt;auditdeny
op_assign
l_int|0xffffffff
suffix:semicolon
id|avd-&gt;seqno
op_assign
id|latest_granting
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|POLICY_RDLOCK
suffix:semicolon
id|scontext
op_assign
id|sidtab_search
c_func
(paren
op_amp
id|sidtab
comma
id|ssid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scontext
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security_compute_av:  unrecognized SID %d&bslash;n&quot;
comma
id|ssid
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|tcontext
op_assign
id|sidtab_search
c_func
(paren
op_amp
id|sidtab
comma
id|tsid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcontext
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security_compute_av:  unrecognized SID %d&bslash;n&quot;
comma
id|tsid
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|rc
op_assign
id|context_struct_compute_av
c_func
(paren
id|scontext
comma
id|tcontext
comma
id|tclass
comma
id|requested
comma
id|avd
)paren
suffix:semicolon
id|out
suffix:colon
id|POLICY_RDUNLOCK
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Write the security context string representation of&n; * the context structure `context&squot; into a dynamically&n; * allocated string of the correct size.  Set `*scontext&squot;&n; * to point to this string and set `*scontext_len&squot; to&n; * the length of the string.&n; */
DECL|function|context_struct_to_string
r_static
r_int
id|context_struct_to_string
c_func
(paren
r_struct
id|context
op_star
id|context
comma
r_char
op_star
op_star
id|scontext
comma
id|u32
op_star
id|scontext_len
)paren
(brace
r_char
op_star
id|scontextp
suffix:semicolon
op_star
id|scontext
op_assign
l_int|NULL
suffix:semicolon
op_star
id|scontext_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Compute the size of the context. */
op_star
id|scontext_len
op_add_assign
id|strlen
c_func
(paren
id|policydb.p_user_val_to_name
(braket
id|context-&gt;user
op_minus
l_int|1
)braket
)paren
op_plus
l_int|1
suffix:semicolon
op_star
id|scontext_len
op_add_assign
id|strlen
c_func
(paren
id|policydb.p_role_val_to_name
(braket
id|context-&gt;role
op_minus
l_int|1
)braket
)paren
op_plus
l_int|1
suffix:semicolon
op_star
id|scontext_len
op_add_assign
id|strlen
c_func
(paren
id|policydb.p_type_val_to_name
(braket
id|context-&gt;type
op_minus
l_int|1
)braket
)paren
op_plus
l_int|1
suffix:semicolon
op_star
id|scontext_len
op_add_assign
id|mls_compute_context_len
c_func
(paren
id|context
)paren
suffix:semicolon
multiline_comment|/* Allocate space for the context; caller must free this space. */
id|scontextp
op_assign
id|kmalloc
c_func
(paren
op_star
id|scontext_len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scontextp
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
op_star
id|scontext
op_assign
id|scontextp
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the user name, role name and type name into the context.&n;&t; */
id|sprintf
c_func
(paren
id|scontextp
comma
l_string|&quot;%s:%s:%s&quot;
comma
id|policydb.p_user_val_to_name
(braket
id|context-&gt;user
op_minus
l_int|1
)braket
comma
id|policydb.p_role_val_to_name
(braket
id|context-&gt;role
op_minus
l_int|1
)braket
comma
id|policydb.p_type_val_to_name
(braket
id|context-&gt;type
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|scontextp
op_add_assign
id|strlen
c_func
(paren
id|policydb.p_user_val_to_name
(braket
id|context-&gt;user
op_minus
l_int|1
)braket
)paren
op_plus
l_int|1
op_plus
id|strlen
c_func
(paren
id|policydb.p_role_val_to_name
(braket
id|context-&gt;role
op_minus
l_int|1
)braket
)paren
op_plus
l_int|1
op_plus
id|strlen
c_func
(paren
id|policydb.p_type_val_to_name
(braket
id|context-&gt;type
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|mls_sid_to_context
c_func
(paren
id|context
comma
op_amp
id|scontextp
)paren
suffix:semicolon
op_star
id|scontextp
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#include &quot;initial_sid_to_string.h&quot;
multiline_comment|/**&n; * security_sid_to_context - Obtain a context for a given SID.&n; * @sid: security identifier, SID&n; * @scontext: security context&n; * @scontext_len: length in bytes&n; *&n; * Write the string representation of the context associated with @sid&n; * into a dynamically allocated string of the correct size.  Set @scontext&n; * to point to this string and set @scontext_len to the length of the string.&n; */
DECL|function|security_sid_to_context
r_int
id|security_sid_to_context
c_func
(paren
id|u32
id|sid
comma
r_char
op_star
op_star
id|scontext
comma
id|u32
op_star
id|scontext_len
)paren
(brace
r_struct
id|context
op_star
id|context
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ss_initialized
)paren
(brace
r_if
c_cond
(paren
id|sid
op_le
id|SECINITSID_NUM
)paren
(brace
r_char
op_star
id|scontextp
suffix:semicolon
op_star
id|scontext_len
op_assign
id|strlen
c_func
(paren
id|initial_sid_to_string
(braket
id|sid
)braket
)paren
op_plus
l_int|1
suffix:semicolon
id|scontextp
op_assign
id|kmalloc
c_func
(paren
op_star
id|scontext_len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|scontextp
comma
id|initial_sid_to_string
(braket
id|sid
)braket
)paren
suffix:semicolon
op_star
id|scontext
op_assign
id|scontextp
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security_sid_to_context:  called before initial &quot;
l_string|&quot;load_policy on unknown SID %d&bslash;n&quot;
comma
id|sid
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|POLICY_RDLOCK
suffix:semicolon
id|context
op_assign
id|sidtab_search
c_func
(paren
op_amp
id|sidtab
comma
id|sid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|context
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security_sid_to_context:  unrecognized SID &quot;
l_string|&quot;%d&bslash;n&quot;
comma
id|sid
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|rc
op_assign
id|context_struct_to_string
c_func
(paren
id|context
comma
id|scontext
comma
id|scontext_len
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|POLICY_RDUNLOCK
suffix:semicolon
id|out
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; * security_context_to_sid - Obtain a SID for a given security context.&n; * @scontext: security context&n; * @scontext_len: length in bytes&n; * @sid: security identifier, SID&n; *&n; * Obtains a SID associated with the security context that&n; * has the string representation specified by @scontext.&n; * Returns -%EINVAL if the context is invalid, -%ENOMEM if insufficient&n; * memory is available, or 0 on success.&n; */
DECL|function|security_context_to_sid
r_int
id|security_context_to_sid
c_func
(paren
r_char
op_star
id|scontext
comma
id|u32
id|scontext_len
comma
id|u32
op_star
id|sid
)paren
(brace
r_char
op_star
id|scontext2
suffix:semicolon
r_struct
id|context
id|context
suffix:semicolon
r_struct
id|role_datum
op_star
id|role
suffix:semicolon
r_struct
id|type_datum
op_star
id|typdatum
suffix:semicolon
r_struct
id|user_datum
op_star
id|usrdatum
suffix:semicolon
r_char
op_star
id|scontextp
comma
op_star
id|p
comma
id|oldc
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ss_initialized
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|SECINITSID_NUM
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|initial_sid_to_string
(braket
id|i
)braket
comma
id|scontext
)paren
)paren
(brace
op_star
id|sid
op_assign
id|i
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
op_star
id|sid
op_assign
id|SECINITSID_KERNEL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
op_star
id|sid
op_assign
id|SECSID_NULL
suffix:semicolon
multiline_comment|/* Copy the string so that we can modify the copy as we parse it.&n;&t;   The string should already by null terminated, but we append a&n;&t;   null suffix to the copy to avoid problems with the existing&n;&t;   attr package, which doesn&squot;t view the null terminator as part&n;&t;   of the attribute value. */
id|scontext2
op_assign
id|kmalloc
c_func
(paren
id|scontext_len
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scontext2
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|scontext2
comma
id|scontext
comma
id|scontext_len
)paren
suffix:semicolon
id|scontext2
(braket
id|scontext_len
)braket
op_assign
l_int|0
suffix:semicolon
id|context_init
c_func
(paren
op_amp
id|context
)paren
suffix:semicolon
op_star
id|sid
op_assign
id|SECSID_NULL
suffix:semicolon
id|POLICY_RDLOCK
suffix:semicolon
multiline_comment|/* Parse the security context. */
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|scontextp
op_assign
(paren
r_char
op_star
)paren
id|scontext2
suffix:semicolon
multiline_comment|/* Extract the user. */
id|p
op_assign
id|scontextp
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
op_logical_and
op_star
id|p
op_ne
l_char|&squot;:&squot;
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_eq
l_int|0
)paren
r_goto
id|out_unlock
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_int|0
suffix:semicolon
id|usrdatum
op_assign
id|hashtab_search
c_func
(paren
id|policydb.p_users.table
comma
id|scontextp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|usrdatum
)paren
r_goto
id|out_unlock
suffix:semicolon
id|context.user
op_assign
id|usrdatum-&gt;value
suffix:semicolon
multiline_comment|/* Extract role. */
id|scontextp
op_assign
id|p
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
op_logical_and
op_star
id|p
op_ne
l_char|&squot;:&squot;
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_eq
l_int|0
)paren
r_goto
id|out_unlock
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_int|0
suffix:semicolon
id|role
op_assign
id|hashtab_search
c_func
(paren
id|policydb.p_roles.table
comma
id|scontextp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|role
)paren
r_goto
id|out_unlock
suffix:semicolon
id|context.role
op_assign
id|role-&gt;value
suffix:semicolon
multiline_comment|/* Extract type. */
id|scontextp
op_assign
id|p
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
op_logical_and
op_star
id|p
op_ne
l_char|&squot;:&squot;
)paren
id|p
op_increment
suffix:semicolon
id|oldc
op_assign
op_star
id|p
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_int|0
suffix:semicolon
id|typdatum
op_assign
id|hashtab_search
c_func
(paren
id|policydb.p_types.table
comma
id|scontextp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|typdatum
)paren
r_goto
id|out_unlock
suffix:semicolon
id|context.type
op_assign
id|typdatum-&gt;value
suffix:semicolon
id|rc
op_assign
id|mls_context_to_sid
c_func
(paren
id|oldc
comma
op_amp
id|p
comma
op_amp
id|context
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|out_unlock
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p
op_minus
id|scontext2
)paren
OL
id|scontext_len
)paren
(brace
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* Check the validity of the new context. */
r_if
c_cond
(paren
op_logical_neg
id|policydb_context_isvalid
c_func
(paren
op_amp
id|policydb
comma
op_amp
id|context
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* Obtain the new sid. */
id|rc
op_assign
id|sidtab_context_to_sid
c_func
(paren
op_amp
id|sidtab
comma
op_amp
id|context
comma
id|sid
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|POLICY_RDUNLOCK
suffix:semicolon
id|context_destroy
c_func
(paren
op_amp
id|context
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|scontext2
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|compute_sid_handle_invalid_context
r_static
r_int
id|compute_sid_handle_invalid_context
c_func
(paren
r_struct
id|context
op_star
id|scontext
comma
r_struct
id|context
op_star
id|tcontext
comma
id|u16
id|tclass
comma
r_struct
id|context
op_star
id|newcontext
)paren
(brace
r_char
op_star
id|s
op_assign
l_int|NULL
comma
op_star
id|t
op_assign
l_int|NULL
comma
op_star
id|n
op_assign
l_int|NULL
suffix:semicolon
id|u32
id|slen
comma
id|tlen
comma
id|nlen
suffix:semicolon
r_if
c_cond
(paren
id|context_struct_to_string
c_func
(paren
id|scontext
comma
op_amp
id|s
comma
op_amp
id|slen
)paren
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|context_struct_to_string
c_func
(paren
id|tcontext
comma
op_amp
id|t
comma
op_amp
id|tlen
)paren
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|context_struct_to_string
c_func
(paren
id|newcontext
comma
op_amp
id|n
comma
op_amp
id|nlen
)paren
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|audit_log
c_func
(paren
id|current-&gt;audit_context
comma
l_string|&quot;security_compute_sid:  invalid context %s&quot;
l_string|&quot; for scontext=%s&quot;
l_string|&quot; tcontext=%s&quot;
l_string|&quot; tclass=%s&quot;
comma
id|n
comma
id|s
comma
id|t
comma
id|policydb.p_class_val_to_name
(braket
id|tclass
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|out
suffix:colon
id|kfree
c_func
(paren
id|s
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|t
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|selinux_enforcing
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
DECL|function|security_compute_sid
r_static
r_int
id|security_compute_sid
c_func
(paren
id|u32
id|ssid
comma
id|u32
id|tsid
comma
id|u16
id|tclass
comma
id|u32
id|specified
comma
id|u32
op_star
id|out_sid
)paren
(brace
r_struct
id|context
op_star
id|scontext
op_assign
l_int|NULL
comma
op_star
id|tcontext
op_assign
l_int|NULL
comma
id|newcontext
suffix:semicolon
r_struct
id|role_trans
op_star
id|roletr
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|avtab_key
id|avkey
suffix:semicolon
r_struct
id|avtab_datum
op_star
id|avdatum
suffix:semicolon
r_struct
id|avtab_node
op_star
id|node
suffix:semicolon
r_int
r_int
id|type_change
op_assign
l_int|0
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ss_initialized
)paren
(brace
r_switch
c_cond
(paren
id|tclass
)paren
(brace
r_case
id|SECCLASS_PROCESS
suffix:colon
op_star
id|out_sid
op_assign
id|ssid
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
op_star
id|out_sid
op_assign
id|tsid
suffix:semicolon
r_break
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
id|POLICY_RDLOCK
suffix:semicolon
id|scontext
op_assign
id|sidtab_search
c_func
(paren
op_amp
id|sidtab
comma
id|ssid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scontext
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security_compute_sid:  unrecognized SID %d&bslash;n&quot;
comma
id|ssid
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|tcontext
op_assign
id|sidtab_search
c_func
(paren
op_amp
id|sidtab
comma
id|tsid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcontext
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security_compute_sid:  unrecognized SID %d&bslash;n&quot;
comma
id|tsid
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|context_init
c_func
(paren
op_amp
id|newcontext
)paren
suffix:semicolon
multiline_comment|/* Set the user identity. */
r_switch
c_cond
(paren
id|specified
)paren
(brace
r_case
id|AVTAB_TRANSITION
suffix:colon
r_case
id|AVTAB_CHANGE
suffix:colon
multiline_comment|/* Use the process user identity. */
id|newcontext.user
op_assign
id|scontext-&gt;user
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AVTAB_MEMBER
suffix:colon
multiline_comment|/* Use the related object owner. */
id|newcontext.user
op_assign
id|tcontext-&gt;user
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Set the role and type to default values. */
r_switch
c_cond
(paren
id|tclass
)paren
(brace
r_case
id|SECCLASS_PROCESS
suffix:colon
multiline_comment|/* Use the current role and type of process. */
id|newcontext.role
op_assign
id|scontext-&gt;role
suffix:semicolon
id|newcontext.type
op_assign
id|scontext-&gt;type
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Use the well-defined object role. */
id|newcontext.role
op_assign
id|OBJECT_R_VAL
suffix:semicolon
multiline_comment|/* Use the type of the related object. */
id|newcontext.type
op_assign
id|tcontext-&gt;type
suffix:semicolon
)brace
multiline_comment|/* Look for a type transition/member/change rule. */
id|avkey.source_type
op_assign
id|scontext-&gt;type
suffix:semicolon
id|avkey.target_type
op_assign
id|tcontext-&gt;type
suffix:semicolon
id|avkey.target_class
op_assign
id|tclass
suffix:semicolon
id|avdatum
op_assign
id|avtab_search
c_func
(paren
op_amp
id|policydb.te_avtab
comma
op_amp
id|avkey
comma
id|AVTAB_TYPE
)paren
suffix:semicolon
multiline_comment|/* If no permanent rule, also check for enabled conditional rules */
r_if
c_cond
(paren
op_logical_neg
id|avdatum
)paren
(brace
id|node
op_assign
id|avtab_search_node
c_func
(paren
op_amp
id|policydb.te_cond_avtab
comma
op_amp
id|avkey
comma
id|specified
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|node
op_ne
l_int|NULL
suffix:semicolon
id|node
op_assign
id|avtab_search_node_next
c_func
(paren
id|node
comma
id|specified
)paren
)paren
(brace
r_if
c_cond
(paren
id|node-&gt;datum.specified
op_amp
id|AVTAB_ENABLED
)paren
(brace
id|avdatum
op_assign
op_amp
id|node-&gt;datum
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|type_change
op_assign
(paren
id|avdatum
op_logical_and
(paren
id|avdatum-&gt;specified
op_amp
id|specified
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type_change
)paren
(brace
multiline_comment|/* Use the type from the type transition/member/change rule. */
r_switch
c_cond
(paren
id|specified
)paren
(brace
r_case
id|AVTAB_TRANSITION
suffix:colon
id|newcontext.type
op_assign
id|avtab_transition
c_func
(paren
id|avdatum
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AVTAB_MEMBER
suffix:colon
id|newcontext.type
op_assign
id|avtab_member
c_func
(paren
id|avdatum
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AVTAB_CHANGE
suffix:colon
id|newcontext.type
op_assign
id|avtab_change
c_func
(paren
id|avdatum
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Check for class-specific changes. */
r_switch
c_cond
(paren
id|tclass
)paren
(brace
r_case
id|SECCLASS_PROCESS
suffix:colon
r_if
c_cond
(paren
id|specified
op_amp
id|AVTAB_TRANSITION
)paren
(brace
multiline_comment|/* Look for a role transition rule. */
r_for
c_loop
(paren
id|roletr
op_assign
id|policydb.role_tr
suffix:semicolon
id|roletr
suffix:semicolon
id|roletr
op_assign
id|roletr-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|roletr-&gt;role
op_eq
id|scontext-&gt;role
op_logical_and
id|roletr-&gt;type
op_eq
id|tcontext-&gt;type
)paren
(brace
multiline_comment|/* Use the role transition rule. */
id|newcontext.role
op_assign
id|roletr-&gt;new_role
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/* Set the MLS attributes.&n;&t;   This is done last because it may allocate memory. */
id|rc
op_assign
id|mls_compute_sid
c_func
(paren
id|scontext
comma
id|tcontext
comma
id|tclass
comma
id|specified
comma
op_amp
id|newcontext
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|out_unlock
suffix:semicolon
multiline_comment|/* Check the validity of the context. */
r_if
c_cond
(paren
op_logical_neg
id|policydb_context_isvalid
c_func
(paren
op_amp
id|policydb
comma
op_amp
id|newcontext
)paren
)paren
(brace
id|rc
op_assign
id|compute_sid_handle_invalid_context
c_func
(paren
id|scontext
comma
id|tcontext
comma
id|tclass
comma
op_amp
id|newcontext
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* Obtain the sid for the context. */
id|rc
op_assign
id|sidtab_context_to_sid
c_func
(paren
op_amp
id|sidtab
comma
op_amp
id|newcontext
comma
id|out_sid
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|POLICY_RDUNLOCK
suffix:semicolon
id|context_destroy
c_func
(paren
op_amp
id|newcontext
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; * security_transition_sid - Compute the SID for a new subject/object.&n; * @ssid: source security identifier&n; * @tsid: target security identifier&n; * @tclass: target security class&n; * @out_sid: security identifier for new subject/object&n; *&n; * Compute a SID to use for labeling a new subject or object in the&n; * class @tclass based on a SID pair (@ssid, @tsid).&n; * Return -%EINVAL if any of the parameters are invalid, -%ENOMEM&n; * if insufficient memory is available, or %0 if the new SID was&n; * computed successfully.&n; */
DECL|function|security_transition_sid
r_int
id|security_transition_sid
c_func
(paren
id|u32
id|ssid
comma
id|u32
id|tsid
comma
id|u16
id|tclass
comma
id|u32
op_star
id|out_sid
)paren
(brace
r_return
id|security_compute_sid
c_func
(paren
id|ssid
comma
id|tsid
comma
id|tclass
comma
id|AVTAB_TRANSITION
comma
id|out_sid
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * security_member_sid - Compute the SID for member selection.&n; * @ssid: source security identifier&n; * @tsid: target security identifier&n; * @tclass: target security class&n; * @out_sid: security identifier for selected member&n; *&n; * Compute a SID to use when selecting a member of a polyinstantiated&n; * object of class @tclass based on a SID pair (@ssid, @tsid).&n; * Return -%EINVAL if any of the parameters are invalid, -%ENOMEM&n; * if insufficient memory is available, or %0 if the SID was&n; * computed successfully.&n; */
DECL|function|security_member_sid
r_int
id|security_member_sid
c_func
(paren
id|u32
id|ssid
comma
id|u32
id|tsid
comma
id|u16
id|tclass
comma
id|u32
op_star
id|out_sid
)paren
(brace
r_return
id|security_compute_sid
c_func
(paren
id|ssid
comma
id|tsid
comma
id|tclass
comma
id|AVTAB_MEMBER
comma
id|out_sid
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * security_change_sid - Compute the SID for object relabeling.&n; * @ssid: source security identifier&n; * @tsid: target security identifier&n; * @tclass: target security class&n; * @out_sid: security identifier for selected member&n; *&n; * Compute a SID to use for relabeling an object of class @tclass&n; * based on a SID pair (@ssid, @tsid).&n; * Return -%EINVAL if any of the parameters are invalid, -%ENOMEM&n; * if insufficient memory is available, or %0 if the SID was&n; * computed successfully.&n; */
DECL|function|security_change_sid
r_int
id|security_change_sid
c_func
(paren
id|u32
id|ssid
comma
id|u32
id|tsid
comma
id|u16
id|tclass
comma
id|u32
op_star
id|out_sid
)paren
(brace
r_return
id|security_compute_sid
c_func
(paren
id|ssid
comma
id|tsid
comma
id|tclass
comma
id|AVTAB_CHANGE
comma
id|out_sid
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Verify that each permission that is defined under the&n; * existing policy is still defined with the same value&n; * in the new policy.&n; */
DECL|function|validate_perm
r_static
r_int
id|validate_perm
c_func
(paren
r_void
op_star
id|key
comma
r_void
op_star
id|datum
comma
r_void
op_star
id|p
)paren
(brace
r_struct
id|hashtab
op_star
id|h
suffix:semicolon
r_struct
id|perm_datum
op_star
id|perdatum
comma
op_star
id|perdatum2
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|h
op_assign
id|p
suffix:semicolon
id|perdatum
op_assign
id|datum
suffix:semicolon
id|perdatum2
op_assign
id|hashtab_search
c_func
(paren
id|h
comma
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|perdatum2
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security:  permission %s disappeared&quot;
comma
(paren
r_char
op_star
)paren
id|key
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|perdatum-&gt;value
op_ne
id|perdatum2-&gt;value
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security:  the value of permission %s changed&quot;
comma
(paren
r_char
op_star
)paren
id|key
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Verify that each class that is defined under the&n; * existing policy is still defined with the same&n; * attributes in the new policy.&n; */
DECL|function|validate_class
r_static
r_int
id|validate_class
c_func
(paren
r_void
op_star
id|key
comma
r_void
op_star
id|datum
comma
r_void
op_star
id|p
)paren
(brace
r_struct
id|policydb
op_star
id|newp
suffix:semicolon
r_struct
id|class_datum
op_star
id|cladatum
comma
op_star
id|cladatum2
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|newp
op_assign
id|p
suffix:semicolon
id|cladatum
op_assign
id|datum
suffix:semicolon
id|cladatum2
op_assign
id|hashtab_search
c_func
(paren
id|newp-&gt;p_classes.table
comma
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cladatum2
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security:  class %s disappeared&bslash;n&quot;
comma
(paren
r_char
op_star
)paren
id|key
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cladatum-&gt;value
op_ne
id|cladatum2-&gt;value
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security:  the value of class %s changed&bslash;n&quot;
comma
(paren
r_char
op_star
)paren
id|key
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|cladatum-&gt;comdatum
op_logical_and
op_logical_neg
id|cladatum2-&gt;comdatum
)paren
op_logical_or
(paren
op_logical_neg
id|cladatum-&gt;comdatum
op_logical_and
id|cladatum2-&gt;comdatum
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security:  the inherits clause for the access &quot;
l_string|&quot;vector definition for class %s changed&bslash;n&quot;
comma
(paren
r_char
op_star
)paren
id|key
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cladatum-&gt;comdatum
)paren
(brace
id|rc
op_assign
id|hashtab_map
c_func
(paren
id|cladatum-&gt;comdatum-&gt;permissions.table
comma
id|validate_perm
comma
id|cladatum2-&gt;comdatum-&gt;permissions.table
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; in the access vector definition for class &quot;
l_string|&quot;%s&bslash;n&quot;
comma
(paren
r_char
op_star
)paren
id|key
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|rc
op_assign
id|hashtab_map
c_func
(paren
id|cladatum-&gt;permissions.table
comma
id|validate_perm
comma
id|cladatum2-&gt;permissions.table
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
id|printk
c_func
(paren
l_string|&quot; in access vector definition for class %s&bslash;n&quot;
comma
(paren
r_char
op_star
)paren
id|key
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* Clone the SID into the new SID table. */
DECL|function|clone_sid
r_static
r_int
id|clone_sid
c_func
(paren
id|u32
id|sid
comma
r_struct
id|context
op_star
id|context
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|sidtab
op_star
id|s
op_assign
id|arg
suffix:semicolon
r_return
id|sidtab_insert
c_func
(paren
id|s
comma
id|sid
comma
id|context
)paren
suffix:semicolon
)brace
DECL|function|convert_context_handle_invalid_context
r_static
r_inline
r_int
id|convert_context_handle_invalid_context
c_func
(paren
r_struct
id|context
op_star
id|context
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|selinux_enforcing
)paren
(brace
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
r_char
op_star
id|s
suffix:semicolon
id|u32
id|len
suffix:semicolon
id|context_struct_to_string
c_func
(paren
id|context
comma
op_amp
id|s
comma
op_amp
id|len
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security:  context %s is invalid&bslash;n&quot;
comma
id|s
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|struct|convert_context_args
r_struct
id|convert_context_args
(brace
DECL|member|oldp
r_struct
id|policydb
op_star
id|oldp
suffix:semicolon
DECL|member|newp
r_struct
id|policydb
op_star
id|newp
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Convert the values in the security context&n; * structure `c&squot; from the values specified&n; * in the policy `p-&gt;oldp&squot; to the values specified&n; * in the policy `p-&gt;newp&squot;.  Verify that the&n; * context is valid under the new policy.&n; */
DECL|function|convert_context
r_static
r_int
id|convert_context
c_func
(paren
id|u32
id|key
comma
r_struct
id|context
op_star
id|c
comma
r_void
op_star
id|p
)paren
(brace
r_struct
id|convert_context_args
op_star
id|args
suffix:semicolon
r_struct
id|context
id|oldc
suffix:semicolon
r_struct
id|role_datum
op_star
id|role
suffix:semicolon
r_struct
id|type_datum
op_star
id|typdatum
suffix:semicolon
r_struct
id|user_datum
op_star
id|usrdatum
suffix:semicolon
r_char
op_star
id|s
suffix:semicolon
id|u32
id|len
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|args
op_assign
id|p
suffix:semicolon
id|rc
op_assign
id|context_cpy
c_func
(paren
op_amp
id|oldc
comma
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|out
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Convert the user. */
id|usrdatum
op_assign
id|hashtab_search
c_func
(paren
id|args-&gt;newp-&gt;p_users.table
comma
id|args-&gt;oldp-&gt;p_user_val_to_name
(braket
id|c-&gt;user
op_minus
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|usrdatum
)paren
(brace
r_goto
id|bad
suffix:semicolon
)brace
id|c-&gt;user
op_assign
id|usrdatum-&gt;value
suffix:semicolon
multiline_comment|/* Convert the role. */
id|role
op_assign
id|hashtab_search
c_func
(paren
id|args-&gt;newp-&gt;p_roles.table
comma
id|args-&gt;oldp-&gt;p_role_val_to_name
(braket
id|c-&gt;role
op_minus
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|role
)paren
(brace
r_goto
id|bad
suffix:semicolon
)brace
id|c-&gt;role
op_assign
id|role-&gt;value
suffix:semicolon
multiline_comment|/* Convert the type. */
id|typdatum
op_assign
id|hashtab_search
c_func
(paren
id|args-&gt;newp-&gt;p_types.table
comma
id|args-&gt;oldp-&gt;p_type_val_to_name
(braket
id|c-&gt;type
op_minus
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|typdatum
)paren
(brace
r_goto
id|bad
suffix:semicolon
)brace
id|c-&gt;type
op_assign
id|typdatum-&gt;value
suffix:semicolon
id|rc
op_assign
id|mls_convert_context
c_func
(paren
id|args-&gt;oldp
comma
id|args-&gt;newp
comma
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|bad
suffix:semicolon
multiline_comment|/* Check the validity of the new context. */
r_if
c_cond
(paren
op_logical_neg
id|policydb_context_isvalid
c_func
(paren
id|args-&gt;newp
comma
id|c
)paren
)paren
(brace
id|rc
op_assign
id|convert_context_handle_invalid_context
c_func
(paren
op_amp
id|oldc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|bad
suffix:semicolon
)brace
id|context_destroy
c_func
(paren
op_amp
id|oldc
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|rc
suffix:semicolon
id|bad
suffix:colon
id|context_struct_to_string
c_func
(paren
op_amp
id|oldc
comma
op_amp
id|s
comma
op_amp
id|len
)paren
suffix:semicolon
id|context_destroy
c_func
(paren
op_amp
id|oldc
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security:  invalidating context %s&bslash;n&quot;
comma
id|s
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|s
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_extern
r_void
id|selinux_complete_init
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/**&n; * security_load_policy - Load a security policy configuration.&n; * @data: binary policy data&n; * @len: length of data in bytes&n; *&n; * Load a new set of security policy configuration data,&n; * validate it and convert the SID table as necessary.&n; * This function will flush the access vector cache after&n; * loading the new policy.&n; */
DECL|function|security_load_policy
r_int
id|security_load_policy
c_func
(paren
r_void
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_struct
id|policydb
id|oldpolicydb
comma
id|newpolicydb
suffix:semicolon
r_struct
id|sidtab
id|oldsidtab
comma
id|newsidtab
suffix:semicolon
r_struct
id|convert_context_args
id|args
suffix:semicolon
id|u32
id|seqno
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_struct
id|policy_file
id|file
op_assign
(brace
id|data
comma
id|len
)brace
comma
op_star
id|fp
op_assign
op_amp
id|file
suffix:semicolon
id|LOAD_LOCK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ss_initialized
)paren
(brace
id|avtab_cache_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|policydb_read
c_func
(paren
op_amp
id|policydb
comma
id|fp
)paren
)paren
(brace
id|LOAD_UNLOCK
suffix:semicolon
id|avtab_cache_destroy
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|policydb_load_isids
c_func
(paren
op_amp
id|policydb
comma
op_amp
id|sidtab
)paren
)paren
(brace
id|LOAD_UNLOCK
suffix:semicolon
id|policydb_destroy
c_func
(paren
op_amp
id|policydb
)paren
suffix:semicolon
id|avtab_cache_destroy
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|policydb_loaded_version
op_assign
id|policydb.policyvers
suffix:semicolon
id|ss_initialized
op_assign
l_int|1
suffix:semicolon
id|LOAD_UNLOCK
suffix:semicolon
id|selinux_complete_init
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if 0
id|sidtab_hash_eval
c_func
(paren
op_amp
id|sidtab
comma
l_string|&quot;sids&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|policydb_read
c_func
(paren
op_amp
id|newpolicydb
comma
id|fp
)paren
)paren
(brace
id|LOAD_UNLOCK
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|sidtab_init
c_func
(paren
op_amp
id|newsidtab
)paren
suffix:semicolon
multiline_comment|/* Verify that the existing classes did not change. */
r_if
c_cond
(paren
id|hashtab_map
c_func
(paren
id|policydb.p_classes.table
comma
id|validate_class
comma
op_amp
id|newpolicydb
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security:  the definition of an existing &quot;
l_string|&quot;class changed&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
multiline_comment|/* Clone the SID table. */
id|sidtab_shutdown
c_func
(paren
op_amp
id|sidtab
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sidtab_map
c_func
(paren
op_amp
id|sidtab
comma
id|clone_sid
comma
op_amp
id|newsidtab
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
multiline_comment|/* Convert the internal representations of contexts&n;&t;   in the new SID table and remove invalid SIDs. */
id|args.oldp
op_assign
op_amp
id|policydb
suffix:semicolon
id|args.newp
op_assign
op_amp
id|newpolicydb
suffix:semicolon
id|sidtab_map_remove_on_error
c_func
(paren
op_amp
id|newsidtab
comma
id|convert_context
comma
op_amp
id|args
)paren
suffix:semicolon
multiline_comment|/* Save the old policydb and SID table to free later. */
id|memcpy
c_func
(paren
op_amp
id|oldpolicydb
comma
op_amp
id|policydb
comma
r_sizeof
id|policydb
)paren
suffix:semicolon
id|sidtab_set
c_func
(paren
op_amp
id|oldsidtab
comma
op_amp
id|sidtab
)paren
suffix:semicolon
multiline_comment|/* Install the new policydb and SID table. */
id|POLICY_WRLOCK
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|policydb
comma
op_amp
id|newpolicydb
comma
r_sizeof
id|policydb
)paren
suffix:semicolon
id|sidtab_set
c_func
(paren
op_amp
id|sidtab
comma
op_amp
id|newsidtab
)paren
suffix:semicolon
id|seqno
op_assign
op_increment
id|latest_granting
suffix:semicolon
id|policydb_loaded_version
op_assign
id|policydb.policyvers
suffix:semicolon
id|POLICY_WRUNLOCK
suffix:semicolon
id|LOAD_UNLOCK
suffix:semicolon
multiline_comment|/* Free the old policydb and SID table. */
id|policydb_destroy
c_func
(paren
op_amp
id|oldpolicydb
)paren
suffix:semicolon
id|sidtab_destroy
c_func
(paren
op_amp
id|oldsidtab
)paren
suffix:semicolon
id|avc_ss_reset
c_func
(paren
id|seqno
)paren
suffix:semicolon
id|selnl_notify_policyload
c_func
(paren
id|seqno
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err
suffix:colon
id|LOAD_UNLOCK
suffix:semicolon
id|sidtab_destroy
c_func
(paren
op_amp
id|newsidtab
)paren
suffix:semicolon
id|policydb_destroy
c_func
(paren
op_amp
id|newpolicydb
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; * security_port_sid - Obtain the SID for a port.&n; * @domain: communication domain aka address family&n; * @type: socket type&n; * @protocol: protocol number&n; * @port: port number&n; * @out_sid: security identifier&n; */
DECL|function|security_port_sid
r_int
id|security_port_sid
c_func
(paren
id|u16
id|domain
comma
id|u16
id|type
comma
id|u8
id|protocol
comma
id|u16
id|port
comma
id|u32
op_star
id|out_sid
)paren
(brace
r_struct
id|ocontext
op_star
id|c
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|POLICY_RDLOCK
suffix:semicolon
id|c
op_assign
id|policydb.ocontexts
(braket
id|OCON_PORT
)braket
suffix:semicolon
r_while
c_loop
(paren
id|c
)paren
(brace
r_if
c_cond
(paren
id|c-&gt;u.port.protocol
op_eq
id|protocol
op_logical_and
id|c-&gt;u.port.low_port
op_le
id|port
op_logical_and
id|c-&gt;u.port.high_port
op_ge
id|port
)paren
r_break
suffix:semicolon
id|c
op_assign
id|c-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;sid
(braket
l_int|0
)braket
)paren
(brace
id|rc
op_assign
id|sidtab_context_to_sid
c_func
(paren
op_amp
id|sidtab
comma
op_amp
id|c-&gt;context
(braket
l_int|0
)braket
comma
op_amp
id|c-&gt;sid
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|out
suffix:semicolon
)brace
op_star
id|out_sid
op_assign
id|c-&gt;sid
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_else
(brace
op_star
id|out_sid
op_assign
id|SECINITSID_PORT
suffix:semicolon
)brace
id|out
suffix:colon
id|POLICY_RDUNLOCK
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; * security_netif_sid - Obtain the SID for a network interface.&n; * @name: interface name&n; * @if_sid: interface SID&n; * @msg_sid: default SID for received packets&n; */
DECL|function|security_netif_sid
r_int
id|security_netif_sid
c_func
(paren
r_char
op_star
id|name
comma
id|u32
op_star
id|if_sid
comma
id|u32
op_star
id|msg_sid
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_struct
id|ocontext
op_star
id|c
suffix:semicolon
id|POLICY_RDLOCK
suffix:semicolon
id|c
op_assign
id|policydb.ocontexts
(braket
id|OCON_NETIF
)braket
suffix:semicolon
r_while
c_loop
(paren
id|c
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|name
comma
id|c-&gt;u.name
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|c
op_assign
id|c-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;sid
(braket
l_int|0
)braket
op_logical_or
op_logical_neg
id|c-&gt;sid
(braket
l_int|1
)braket
)paren
(brace
id|rc
op_assign
id|sidtab_context_to_sid
c_func
(paren
op_amp
id|sidtab
comma
op_amp
id|c-&gt;context
(braket
l_int|0
)braket
comma
op_amp
id|c-&gt;sid
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|out
suffix:semicolon
id|rc
op_assign
id|sidtab_context_to_sid
c_func
(paren
op_amp
id|sidtab
comma
op_amp
id|c-&gt;context
(braket
l_int|1
)braket
comma
op_amp
id|c-&gt;sid
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|out
suffix:semicolon
)brace
op_star
id|if_sid
op_assign
id|c-&gt;sid
(braket
l_int|0
)braket
suffix:semicolon
op_star
id|msg_sid
op_assign
id|c-&gt;sid
(braket
l_int|1
)braket
suffix:semicolon
)brace
r_else
(brace
op_star
id|if_sid
op_assign
id|SECINITSID_NETIF
suffix:semicolon
op_star
id|msg_sid
op_assign
id|SECINITSID_NETMSG
suffix:semicolon
)brace
id|out
suffix:colon
id|POLICY_RDUNLOCK
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|match_ipv6_addrmask
r_static
r_int
id|match_ipv6_addrmask
c_func
(paren
id|u32
op_star
id|input
comma
id|u32
op_star
id|addr
comma
id|u32
op_star
id|mask
)paren
(brace
r_int
id|i
comma
id|fail
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|addr
(braket
id|i
)braket
op_ne
(paren
id|input
(braket
id|i
)braket
op_amp
id|mask
(braket
id|i
)braket
)paren
)paren
(brace
id|fail
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
op_logical_neg
id|fail
suffix:semicolon
)brace
multiline_comment|/**&n; * security_node_sid - Obtain the SID for a node (host).&n; * @domain: communication domain aka address family&n; * @addrp: address&n; * @addrlen: address length in bytes&n; * @out_sid: security identifier&n; */
DECL|function|security_node_sid
r_int
id|security_node_sid
c_func
(paren
id|u16
id|domain
comma
r_void
op_star
id|addrp
comma
id|u32
id|addrlen
comma
id|u32
op_star
id|out_sid
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_struct
id|ocontext
op_star
id|c
suffix:semicolon
id|POLICY_RDLOCK
suffix:semicolon
r_switch
c_cond
(paren
id|domain
)paren
(brace
r_case
id|AF_INET
suffix:colon
(brace
id|u32
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|addrlen
op_ne
r_sizeof
(paren
id|u32
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|addr
op_assign
op_star
(paren
(paren
id|u32
op_star
)paren
id|addrp
)paren
suffix:semicolon
id|c
op_assign
id|policydb.ocontexts
(braket
id|OCON_NODE
)braket
suffix:semicolon
r_while
c_loop
(paren
id|c
)paren
(brace
r_if
c_cond
(paren
id|c-&gt;u.node.addr
op_eq
(paren
id|addr
op_amp
id|c-&gt;u.node.mask
)paren
)paren
r_break
suffix:semicolon
id|c
op_assign
id|c-&gt;next
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_case
id|AF_INET6
suffix:colon
r_if
c_cond
(paren
id|addrlen
op_ne
r_sizeof
(paren
id|u64
)paren
op_star
l_int|2
)paren
(brace
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|c
op_assign
id|policydb.ocontexts
(braket
id|OCON_NODE6
)braket
suffix:semicolon
r_while
c_loop
(paren
id|c
)paren
(brace
r_if
c_cond
(paren
id|match_ipv6_addrmask
c_func
(paren
id|addrp
comma
id|c-&gt;u.node6.addr
comma
id|c-&gt;u.node6.mask
)paren
)paren
r_break
suffix:semicolon
id|c
op_assign
id|c-&gt;next
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
op_star
id|out_sid
op_assign
id|SECINITSID_NODE
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;sid
(braket
l_int|0
)braket
)paren
(brace
id|rc
op_assign
id|sidtab_context_to_sid
c_func
(paren
op_amp
id|sidtab
comma
op_amp
id|c-&gt;context
(braket
l_int|0
)braket
comma
op_amp
id|c-&gt;sid
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|out
suffix:semicolon
)brace
op_star
id|out_sid
op_assign
id|c-&gt;sid
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_else
(brace
op_star
id|out_sid
op_assign
id|SECINITSID_NODE
suffix:semicolon
)brace
id|out
suffix:colon
id|POLICY_RDUNLOCK
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|macro|SIDS_NEL
mdefine_line|#define SIDS_NEL 25
multiline_comment|/**&n; * security_get_user_sids - Obtain reachable SIDs for a user.&n; * @fromsid: starting SID&n; * @username: username&n; * @sids: array of reachable SIDs for user&n; * @nel: number of elements in @sids&n; *&n; * Generate the set of SIDs for legal security contexts&n; * for a given user that can be reached by @fromsid.&n; * Set *@sids to point to a dynamically allocated&n; * array containing the set of SIDs.  Set *@nel to the&n; * number of elements in the array.&n; */
DECL|function|security_get_user_sids
r_int
id|security_get_user_sids
c_func
(paren
id|u32
id|fromsid
comma
r_char
op_star
id|username
comma
id|u32
op_star
op_star
id|sids
comma
id|u32
op_star
id|nel
)paren
(brace
r_struct
id|context
op_star
id|fromcon
comma
id|usercon
suffix:semicolon
id|u32
op_star
id|mysids
comma
op_star
id|mysids2
comma
id|sid
suffix:semicolon
id|u32
id|mynel
op_assign
l_int|0
comma
id|maxnel
op_assign
id|SIDS_NEL
suffix:semicolon
r_struct
id|user_datum
op_star
id|user
suffix:semicolon
r_struct
id|role_datum
op_star
id|role
suffix:semicolon
r_struct
id|av_decision
id|avd
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
comma
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ss_initialized
)paren
(brace
op_star
id|sids
op_assign
l_int|NULL
suffix:semicolon
op_star
id|nel
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|POLICY_RDLOCK
suffix:semicolon
id|fromcon
op_assign
id|sidtab_search
c_func
(paren
op_amp
id|sidtab
comma
id|fromsid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fromcon
)paren
(brace
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|user
op_assign
id|hashtab_search
c_func
(paren
id|policydb.p_users.table
comma
id|username
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|user
)paren
(brace
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|usercon.user
op_assign
id|user-&gt;value
suffix:semicolon
id|mysids
op_assign
id|kmalloc
c_func
(paren
id|maxnel
op_star
r_sizeof
(paren
op_star
id|mysids
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mysids
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|memset
c_func
(paren
id|mysids
comma
l_int|0
comma
id|maxnel
op_star
r_sizeof
(paren
op_star
id|mysids
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|ebitmap_startbit
c_func
(paren
op_amp
id|user-&gt;roles
)paren
suffix:semicolon
id|i
OL
id|ebitmap_length
c_func
(paren
op_amp
id|user-&gt;roles
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ebitmap_get_bit
c_func
(paren
op_amp
id|user-&gt;roles
comma
id|i
)paren
)paren
r_continue
suffix:semicolon
id|role
op_assign
id|policydb.role_val_to_struct
(braket
id|i
)braket
suffix:semicolon
id|usercon.role
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|ebitmap_startbit
c_func
(paren
op_amp
id|role-&gt;types
)paren
suffix:semicolon
id|j
OL
id|ebitmap_length
c_func
(paren
op_amp
id|role-&gt;types
)paren
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ebitmap_get_bit
c_func
(paren
op_amp
id|role-&gt;types
comma
id|j
)paren
)paren
r_continue
suffix:semicolon
id|usercon.type
op_assign
id|j
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|mls_setup_user_range
c_func
(paren
id|fromcon
comma
id|user
comma
op_amp
id|usercon
)paren
)paren
r_continue
suffix:semicolon
id|rc
op_assign
id|context_struct_compute_av
c_func
(paren
id|fromcon
comma
op_amp
id|usercon
comma
id|SECCLASS_PROCESS
comma
id|PROCESS__TRANSITION
comma
op_amp
id|avd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_logical_or
op_logical_neg
(paren
id|avd.allowed
op_amp
id|PROCESS__TRANSITION
)paren
)paren
r_continue
suffix:semicolon
id|rc
op_assign
id|sidtab_context_to_sid
c_func
(paren
op_amp
id|sidtab
comma
op_amp
id|usercon
comma
op_amp
id|sid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|kfree
c_func
(paren
id|mysids
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mynel
OL
id|maxnel
)paren
(brace
id|mysids
(braket
id|mynel
op_increment
)braket
op_assign
id|sid
suffix:semicolon
)brace
r_else
(brace
id|maxnel
op_add_assign
id|SIDS_NEL
suffix:semicolon
id|mysids2
op_assign
id|kmalloc
c_func
(paren
id|maxnel
op_star
r_sizeof
(paren
op_star
id|mysids2
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mysids2
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|kfree
c_func
(paren
id|mysids
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|memset
c_func
(paren
id|mysids2
comma
l_int|0
comma
id|maxnel
op_star
r_sizeof
(paren
op_star
id|mysids2
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|mysids2
comma
id|mysids
comma
id|mynel
op_star
r_sizeof
(paren
op_star
id|mysids2
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mysids
)paren
suffix:semicolon
id|mysids
op_assign
id|mysids2
suffix:semicolon
id|mysids
(braket
id|mynel
op_increment
)braket
op_assign
id|sid
suffix:semicolon
)brace
)brace
)brace
op_star
id|sids
op_assign
id|mysids
suffix:semicolon
op_star
id|nel
op_assign
id|mynel
suffix:semicolon
id|out_unlock
suffix:colon
id|POLICY_RDUNLOCK
suffix:semicolon
id|out
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; * security_genfs_sid - Obtain a SID for a file in a filesystem&n; * @fstype: filesystem type&n; * @path: path from root of mount&n; * @sclass: file security class&n; * @sid: SID for path&n; *&n; * Obtain a SID to use for a file in a filesystem that&n; * cannot support xattr or use a fixed labeling behavior like&n; * transition SIDs or task SIDs.&n; */
DECL|function|security_genfs_sid
r_int
id|security_genfs_sid
c_func
(paren
r_const
r_char
op_star
id|fstype
comma
r_char
op_star
id|path
comma
id|u16
id|sclass
comma
id|u32
op_star
id|sid
)paren
(brace
r_int
id|len
suffix:semicolon
r_struct
id|genfs
op_star
id|genfs
suffix:semicolon
r_struct
id|ocontext
op_star
id|c
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
comma
id|cmp
op_assign
l_int|0
suffix:semicolon
id|POLICY_RDLOCK
suffix:semicolon
r_for
c_loop
(paren
id|genfs
op_assign
id|policydb.genfs
suffix:semicolon
id|genfs
suffix:semicolon
id|genfs
op_assign
id|genfs-&gt;next
)paren
(brace
id|cmp
op_assign
id|strcmp
c_func
(paren
id|fstype
comma
id|genfs-&gt;fstype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
op_le
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|genfs
op_logical_or
id|cmp
)paren
(brace
op_star
id|sid
op_assign
id|SECINITSID_UNLABELED
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_for
c_loop
(paren
id|c
op_assign
id|genfs-&gt;head
suffix:semicolon
id|c
suffix:semicolon
id|c
op_assign
id|c-&gt;next
)paren
(brace
id|len
op_assign
id|strlen
c_func
(paren
id|c-&gt;u.name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|c-&gt;v.sclass
op_logical_or
id|sclass
op_eq
id|c-&gt;v.sclass
)paren
op_logical_and
(paren
id|strncmp
c_func
(paren
id|c-&gt;u.name
comma
id|path
comma
id|len
)paren
op_eq
l_int|0
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
(brace
op_star
id|sid
op_assign
id|SECINITSID_UNLABELED
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;sid
(braket
l_int|0
)braket
)paren
(brace
id|rc
op_assign
id|sidtab_context_to_sid
c_func
(paren
op_amp
id|sidtab
comma
op_amp
id|c-&gt;context
(braket
l_int|0
)braket
comma
op_amp
id|c-&gt;sid
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|out
suffix:semicolon
)brace
op_star
id|sid
op_assign
id|c-&gt;sid
(braket
l_int|0
)braket
suffix:semicolon
id|out
suffix:colon
id|POLICY_RDUNLOCK
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; * security_fs_use - Determine how to handle labeling for a filesystem.&n; * @fstype: filesystem type&n; * @behavior: labeling behavior&n; * @sid: SID for filesystem (superblock)&n; */
DECL|function|security_fs_use
r_int
id|security_fs_use
c_func
(paren
r_const
r_char
op_star
id|fstype
comma
r_int
r_int
op_star
id|behavior
comma
id|u32
op_star
id|sid
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_struct
id|ocontext
op_star
id|c
suffix:semicolon
id|POLICY_RDLOCK
suffix:semicolon
id|c
op_assign
id|policydb.ocontexts
(braket
id|OCON_FSUSE
)braket
suffix:semicolon
r_while
c_loop
(paren
id|c
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|fstype
comma
id|c-&gt;u.name
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|c
op_assign
id|c-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
)paren
(brace
op_star
id|behavior
op_assign
id|c-&gt;v.behavior
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;sid
(braket
l_int|0
)braket
)paren
(brace
id|rc
op_assign
id|sidtab_context_to_sid
c_func
(paren
op_amp
id|sidtab
comma
op_amp
id|c-&gt;context
(braket
l_int|0
)braket
comma
op_amp
id|c-&gt;sid
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|out
suffix:semicolon
)brace
op_star
id|sid
op_assign
id|c-&gt;sid
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_else
(brace
id|rc
op_assign
id|security_genfs_sid
c_func
(paren
id|fstype
comma
l_string|&quot;/&quot;
comma
id|SECCLASS_DIR
comma
id|sid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
op_star
id|behavior
op_assign
id|SECURITY_FS_USE_NONE
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
op_star
id|behavior
op_assign
id|SECURITY_FS_USE_GENFS
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|POLICY_RDUNLOCK
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|security_get_bools
r_int
id|security_get_bools
c_func
(paren
r_int
op_star
id|len
comma
r_char
op_star
op_star
op_star
id|names
comma
r_int
op_star
op_star
id|values
)paren
(brace
r_int
id|i
comma
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|POLICY_RDLOCK
suffix:semicolon
op_star
id|names
op_assign
l_int|NULL
suffix:semicolon
op_star
id|values
op_assign
l_int|NULL
suffix:semicolon
op_star
id|len
op_assign
id|policydb.p_bools.nprim
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|len
)paren
(brace
id|rc
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
op_star
id|names
op_assign
(paren
r_char
op_star
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_char
op_star
)paren
op_star
op_star
id|len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|names
)paren
r_goto
id|err
suffix:semicolon
id|memset
c_func
(paren
op_star
id|names
comma
l_int|0
comma
r_sizeof
(paren
r_char
op_star
)paren
op_star
op_star
id|len
)paren
suffix:semicolon
op_star
id|values
op_assign
(paren
r_int
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_int
)paren
op_star
op_star
id|len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|values
)paren
r_goto
id|err
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
op_star
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|name_len
suffix:semicolon
(paren
op_star
id|values
)paren
(braket
id|i
)braket
op_assign
id|policydb.bool_val_to_struct
(braket
id|i
)braket
op_member_access_from_pointer
id|state
suffix:semicolon
id|name_len
op_assign
id|strlen
c_func
(paren
id|policydb.p_bool_val_to_name
(braket
id|i
)braket
)paren
op_plus
l_int|1
suffix:semicolon
(paren
op_star
id|names
)paren
(braket
id|i
)braket
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_char
)paren
op_star
id|name_len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|names
)paren
(braket
id|i
)braket
)paren
r_goto
id|err
suffix:semicolon
id|strncpy
c_func
(paren
(paren
op_star
id|names
)paren
(braket
id|i
)braket
comma
id|policydb.p_bool_val_to_name
(braket
id|i
)braket
comma
id|name_len
)paren
suffix:semicolon
(paren
op_star
id|names
)paren
(braket
id|i
)braket
(braket
id|name_len
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|rc
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|POLICY_RDUNLOCK
suffix:semicolon
r_return
id|rc
suffix:semicolon
id|err
suffix:colon
r_if
c_cond
(paren
op_star
id|names
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
op_star
id|len
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
op_star
id|names
)paren
(braket
id|i
)braket
)paren
id|kfree
c_func
(paren
(paren
op_star
id|names
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|values
)paren
id|kfree
c_func
(paren
op_star
id|values
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|function|security_set_bools
r_int
id|security_set_bools
c_func
(paren
r_int
id|len
comma
r_int
op_star
id|values
)paren
(brace
r_int
id|i
comma
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|lenp
comma
id|seqno
op_assign
l_int|0
suffix:semicolon
r_struct
id|cond_node
op_star
id|cur
suffix:semicolon
id|POLICY_WRLOCK
suffix:semicolon
id|lenp
op_assign
id|policydb.p_bools.nprim
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
id|lenp
)paren
(brace
id|rc
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;security: committed booleans { &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|values
(braket
id|i
)braket
)paren
(brace
id|policydb.bool_val_to_struct
(braket
id|i
)braket
op_member_access_from_pointer
id|state
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|policydb.bool_val_to_struct
(braket
id|i
)braket
op_member_access_from_pointer
id|state
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;, &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s:%d&quot;
comma
id|policydb.p_bool_val_to_name
(braket
id|i
)braket
comma
id|policydb.bool_val_to_struct
(braket
id|i
)braket
op_member_access_from_pointer
id|state
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; }&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cur
op_assign
id|policydb.cond_list
suffix:semicolon
id|cur
op_ne
l_int|NULL
suffix:semicolon
id|cur
op_assign
id|cur-&gt;next
)paren
(brace
id|rc
op_assign
id|evaluate_cond_node
c_func
(paren
op_amp
id|policydb
comma
id|cur
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|out
suffix:semicolon
)brace
id|seqno
op_assign
op_increment
id|latest_granting
suffix:semicolon
id|out
suffix:colon
id|POLICY_WRUNLOCK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
(brace
id|avc_ss_reset
c_func
(paren
id|seqno
)paren
suffix:semicolon
id|selnl_notify_policyload
c_func
(paren
id|seqno
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|security_get_bool_value
r_int
id|security_get_bool_value
c_func
(paren
r_int
r_bool
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|len
suffix:semicolon
id|POLICY_RDLOCK
suffix:semicolon
id|len
op_assign
id|policydb.p_bools.nprim
suffix:semicolon
r_if
c_cond
(paren
r_bool
op_ge
id|len
)paren
(brace
id|rc
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|rc
op_assign
id|policydb.bool_val_to_struct
(braket
r_bool
)braket
op_member_access_from_pointer
id|state
suffix:semicolon
id|out
suffix:colon
id|POLICY_RDUNLOCK
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
eof
