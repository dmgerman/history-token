multiline_comment|/*&n; * Implementation of the access vector table type.&n; *&n; * Author : Stephen Smalley, &lt;sds@epoch.ncsc.mil&gt;&n; */
multiline_comment|/* Updated: Frank Mayer &lt;mayerf@tresys.com&gt; and Karl MacMillan &lt;kmacmillan@tresys.com&gt;&n; *&n; * &t;Added conditional policy language extensions&n; *&n; * Copyright (C) 2003 Tresys Technology, LLC&n; *&t;This program is free software; you can redistribute it and/or modify&n; *  &t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation, version 2.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &quot;avtab.h&quot;
macro_line|#include &quot;policydb.h&quot;
DECL|macro|AVTAB_HASH
mdefine_line|#define AVTAB_HASH(keyp) &bslash;&n;((keyp-&gt;target_class + &bslash;&n; (keyp-&gt;target_type &lt;&lt; 2) + &bslash;&n; (keyp-&gt;source_type &lt;&lt; 9)) &amp; &bslash;&n; AVTAB_HASH_MASK)
DECL|variable|avtab_node_cachep
r_static
id|kmem_cache_t
op_star
id|avtab_node_cachep
suffix:semicolon
r_static
r_struct
id|avtab_node
op_star
DECL|function|avtab_insert_node
id|avtab_insert_node
c_func
(paren
r_struct
id|avtab
op_star
id|h
comma
r_int
id|hvalue
comma
r_struct
id|avtab_node
op_star
id|prev
comma
r_struct
id|avtab_node
op_star
id|cur
comma
r_struct
id|avtab_key
op_star
id|key
comma
r_struct
id|avtab_datum
op_star
id|datum
)paren
(brace
r_struct
id|avtab_node
op_star
id|newnode
suffix:semicolon
id|newnode
op_assign
id|kmem_cache_alloc
c_func
(paren
id|avtab_node_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newnode
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|newnode
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|avtab_node
)paren
)paren
suffix:semicolon
id|newnode-&gt;key
op_assign
op_star
id|key
suffix:semicolon
id|newnode-&gt;datum
op_assign
op_star
id|datum
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
(brace
id|newnode-&gt;next
op_assign
id|prev-&gt;next
suffix:semicolon
id|prev-&gt;next
op_assign
id|newnode
suffix:semicolon
)brace
r_else
(brace
id|newnode-&gt;next
op_assign
id|h-&gt;htable
(braket
id|hvalue
)braket
suffix:semicolon
id|h-&gt;htable
(braket
id|hvalue
)braket
op_assign
id|newnode
suffix:semicolon
)brace
id|h-&gt;nel
op_increment
suffix:semicolon
r_return
id|newnode
suffix:semicolon
)brace
DECL|function|avtab_insert
r_int
id|avtab_insert
c_func
(paren
r_struct
id|avtab
op_star
id|h
comma
r_struct
id|avtab_key
op_star
id|key
comma
r_struct
id|avtab_datum
op_star
id|datum
)paren
(brace
r_int
id|hvalue
suffix:semicolon
r_struct
id|avtab_node
op_star
id|prev
comma
op_star
id|cur
comma
op_star
id|newnode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|h
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|hvalue
op_assign
id|AVTAB_HASH
c_func
(paren
id|key
)paren
suffix:semicolon
r_for
c_loop
(paren
id|prev
op_assign
l_int|NULL
comma
id|cur
op_assign
id|h-&gt;htable
(braket
id|hvalue
)braket
suffix:semicolon
id|cur
suffix:semicolon
id|prev
op_assign
id|cur
comma
id|cur
op_assign
id|cur-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|key-&gt;source_type
op_eq
id|cur-&gt;key.source_type
op_logical_and
id|key-&gt;target_type
op_eq
id|cur-&gt;key.target_type
op_logical_and
id|key-&gt;target_class
op_eq
id|cur-&gt;key.target_class
op_logical_and
(paren
id|datum-&gt;specified
op_amp
id|cur-&gt;datum.specified
)paren
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;source_type
OL
id|cur-&gt;key.source_type
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;source_type
op_eq
id|cur-&gt;key.source_type
op_logical_and
id|key-&gt;target_type
OL
id|cur-&gt;key.target_type
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;source_type
op_eq
id|cur-&gt;key.source_type
op_logical_and
id|key-&gt;target_type
op_eq
id|cur-&gt;key.target_type
op_logical_and
id|key-&gt;target_class
OL
id|cur-&gt;key.target_class
)paren
r_break
suffix:semicolon
)brace
id|newnode
op_assign
id|avtab_insert_node
c_func
(paren
id|h
comma
id|hvalue
comma
id|prev
comma
id|cur
comma
id|key
comma
id|datum
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newnode
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Unlike avtab_insert(), this function allow multiple insertions of the same&n; * key/specified mask into the table, as needed by the conditional avtab.&n; * It also returns a pointer to the node inserted.&n; */
r_struct
id|avtab_node
op_star
DECL|function|avtab_insert_nonunique
id|avtab_insert_nonunique
c_func
(paren
r_struct
id|avtab
op_star
id|h
comma
r_struct
id|avtab_key
op_star
id|key
comma
r_struct
id|avtab_datum
op_star
id|datum
)paren
(brace
r_int
id|hvalue
suffix:semicolon
r_struct
id|avtab_node
op_star
id|prev
comma
op_star
id|cur
comma
op_star
id|newnode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|h
)paren
r_return
l_int|NULL
suffix:semicolon
id|hvalue
op_assign
id|AVTAB_HASH
c_func
(paren
id|key
)paren
suffix:semicolon
r_for
c_loop
(paren
id|prev
op_assign
l_int|NULL
comma
id|cur
op_assign
id|h-&gt;htable
(braket
id|hvalue
)braket
suffix:semicolon
id|cur
suffix:semicolon
id|prev
op_assign
id|cur
comma
id|cur
op_assign
id|cur-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|key-&gt;source_type
op_eq
id|cur-&gt;key.source_type
op_logical_and
id|key-&gt;target_type
op_eq
id|cur-&gt;key.target_type
op_logical_and
id|key-&gt;target_class
op_eq
id|cur-&gt;key.target_class
op_logical_and
(paren
id|datum-&gt;specified
op_amp
id|cur-&gt;datum.specified
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;source_type
OL
id|cur-&gt;key.source_type
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;source_type
op_eq
id|cur-&gt;key.source_type
op_logical_and
id|key-&gt;target_type
OL
id|cur-&gt;key.target_type
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;source_type
op_eq
id|cur-&gt;key.source_type
op_logical_and
id|key-&gt;target_type
op_eq
id|cur-&gt;key.target_type
op_logical_and
id|key-&gt;target_class
OL
id|cur-&gt;key.target_class
)paren
r_break
suffix:semicolon
)brace
id|newnode
op_assign
id|avtab_insert_node
c_func
(paren
id|h
comma
id|hvalue
comma
id|prev
comma
id|cur
comma
id|key
comma
id|datum
)paren
suffix:semicolon
r_return
id|newnode
suffix:semicolon
)brace
DECL|function|avtab_search
r_struct
id|avtab_datum
op_star
id|avtab_search
c_func
(paren
r_struct
id|avtab
op_star
id|h
comma
r_struct
id|avtab_key
op_star
id|key
comma
r_int
id|specified
)paren
(brace
r_int
id|hvalue
suffix:semicolon
r_struct
id|avtab_node
op_star
id|cur
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|h
)paren
r_return
l_int|NULL
suffix:semicolon
id|hvalue
op_assign
id|AVTAB_HASH
c_func
(paren
id|key
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cur
op_assign
id|h-&gt;htable
(braket
id|hvalue
)braket
suffix:semicolon
id|cur
suffix:semicolon
id|cur
op_assign
id|cur-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|key-&gt;source_type
op_eq
id|cur-&gt;key.source_type
op_logical_and
id|key-&gt;target_type
op_eq
id|cur-&gt;key.target_type
op_logical_and
id|key-&gt;target_class
op_eq
id|cur-&gt;key.target_class
op_logical_and
(paren
id|specified
op_amp
id|cur-&gt;datum.specified
)paren
)paren
r_return
op_amp
id|cur-&gt;datum
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;source_type
OL
id|cur-&gt;key.source_type
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;source_type
op_eq
id|cur-&gt;key.source_type
op_logical_and
id|key-&gt;target_type
OL
id|cur-&gt;key.target_type
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;source_type
op_eq
id|cur-&gt;key.source_type
op_logical_and
id|key-&gt;target_type
op_eq
id|cur-&gt;key.target_type
op_logical_and
id|key-&gt;target_class
OL
id|cur-&gt;key.target_class
)paren
r_break
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* This search function returns a node pointer, and can be used in&n; * conjunction with avtab_search_next_node()&n; */
r_struct
id|avtab_node
op_star
DECL|function|avtab_search_node
id|avtab_search_node
c_func
(paren
r_struct
id|avtab
op_star
id|h
comma
r_struct
id|avtab_key
op_star
id|key
comma
r_int
id|specified
)paren
(brace
r_int
id|hvalue
suffix:semicolon
r_struct
id|avtab_node
op_star
id|cur
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|h
)paren
r_return
l_int|NULL
suffix:semicolon
id|hvalue
op_assign
id|AVTAB_HASH
c_func
(paren
id|key
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cur
op_assign
id|h-&gt;htable
(braket
id|hvalue
)braket
suffix:semicolon
id|cur
suffix:semicolon
id|cur
op_assign
id|cur-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|key-&gt;source_type
op_eq
id|cur-&gt;key.source_type
op_logical_and
id|key-&gt;target_type
op_eq
id|cur-&gt;key.target_type
op_logical_and
id|key-&gt;target_class
op_eq
id|cur-&gt;key.target_class
op_logical_and
(paren
id|specified
op_amp
id|cur-&gt;datum.specified
)paren
)paren
r_return
id|cur
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;source_type
OL
id|cur-&gt;key.source_type
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;source_type
op_eq
id|cur-&gt;key.source_type
op_logical_and
id|key-&gt;target_type
OL
id|cur-&gt;key.target_type
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;source_type
op_eq
id|cur-&gt;key.source_type
op_logical_and
id|key-&gt;target_type
op_eq
id|cur-&gt;key.target_type
op_logical_and
id|key-&gt;target_class
OL
id|cur-&gt;key.target_class
)paren
r_break
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_struct
id|avtab_node
op_star
DECL|function|avtab_search_node_next
id|avtab_search_node_next
c_func
(paren
r_struct
id|avtab_node
op_star
id|node
comma
r_int
id|specified
)paren
(brace
r_struct
id|avtab_node
op_star
id|cur
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|node
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|cur
op_assign
id|node-&gt;next
suffix:semicolon
id|cur
suffix:semicolon
id|cur
op_assign
id|cur-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|node-&gt;key.source_type
op_eq
id|cur-&gt;key.source_type
op_logical_and
id|node-&gt;key.target_type
op_eq
id|cur-&gt;key.target_type
op_logical_and
id|node-&gt;key.target_class
op_eq
id|cur-&gt;key.target_class
op_logical_and
(paren
id|specified
op_amp
id|cur-&gt;datum.specified
)paren
)paren
r_return
id|cur
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;key.source_type
OL
id|cur-&gt;key.source_type
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;key.source_type
op_eq
id|cur-&gt;key.source_type
op_logical_and
id|node-&gt;key.target_type
OL
id|cur-&gt;key.target_type
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;key.source_type
op_eq
id|cur-&gt;key.source_type
op_logical_and
id|node-&gt;key.target_type
op_eq
id|cur-&gt;key.target_type
op_logical_and
id|node-&gt;key.target_class
OL
id|cur-&gt;key.target_class
)paren
r_break
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|avtab_destroy
r_void
id|avtab_destroy
c_func
(paren
r_struct
id|avtab
op_star
id|h
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|avtab_node
op_star
id|cur
comma
op_star
id|temp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|h
op_logical_or
op_logical_neg
id|h-&gt;htable
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AVTAB_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cur
op_assign
id|h-&gt;htable
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
id|cur
op_ne
l_int|NULL
)paren
(brace
id|temp
op_assign
id|cur
suffix:semicolon
id|cur
op_assign
id|cur-&gt;next
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|avtab_node_cachep
comma
id|temp
)paren
suffix:semicolon
)brace
id|h-&gt;htable
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|vfree
c_func
(paren
id|h-&gt;htable
)paren
suffix:semicolon
id|h-&gt;htable
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|avtab_map
r_int
id|avtab_map
c_func
(paren
r_struct
id|avtab
op_star
id|h
comma
r_int
(paren
op_star
id|apply
)paren
(paren
r_struct
id|avtab_key
op_star
id|k
comma
r_struct
id|avtab_datum
op_star
id|d
comma
r_void
op_star
id|args
)paren
comma
r_void
op_star
id|args
)paren
(brace
r_int
id|i
comma
id|ret
suffix:semicolon
r_struct
id|avtab_node
op_star
id|cur
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|h
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AVTAB_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cur
op_assign
id|h-&gt;htable
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
id|cur
op_ne
l_int|NULL
)paren
(brace
id|ret
op_assign
id|apply
c_func
(paren
op_amp
id|cur-&gt;key
comma
op_amp
id|cur-&gt;datum
comma
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
id|cur
op_assign
id|cur-&gt;next
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|avtab_init
r_int
id|avtab_init
c_func
(paren
r_struct
id|avtab
op_star
id|h
)paren
(brace
r_int
id|i
suffix:semicolon
id|h-&gt;htable
op_assign
id|vmalloc
c_func
(paren
r_sizeof
(paren
op_star
(paren
id|h-&gt;htable
)paren
)paren
op_star
id|AVTAB_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|h-&gt;htable
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AVTAB_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|h-&gt;htable
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|h-&gt;nel
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|avtab_hash_eval
r_void
id|avtab_hash_eval
c_func
(paren
r_struct
id|avtab
op_star
id|h
comma
r_char
op_star
id|tag
)paren
(brace
r_int
id|i
comma
id|chain_len
comma
id|slots_used
comma
id|max_chain_len
suffix:semicolon
r_struct
id|avtab_node
op_star
id|cur
suffix:semicolon
id|slots_used
op_assign
l_int|0
suffix:semicolon
id|max_chain_len
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AVTAB_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cur
op_assign
id|h-&gt;htable
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cur
)paren
(brace
id|slots_used
op_increment
suffix:semicolon
id|chain_len
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cur
)paren
(brace
id|chain_len
op_increment
suffix:semicolon
id|cur
op_assign
id|cur-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chain_len
OG
id|max_chain_len
)paren
id|max_chain_len
op_assign
id|chain_len
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s:  %d entries and %d/%d buckets used, longest &quot;
l_string|&quot;chain length %d&bslash;n&quot;
comma
id|tag
comma
id|h-&gt;nel
comma
id|slots_used
comma
id|AVTAB_SIZE
comma
id|max_chain_len
)paren
suffix:semicolon
)brace
DECL|function|avtab_read_item
r_int
id|avtab_read_item
c_func
(paren
r_void
op_star
id|fp
comma
r_struct
id|avtab_datum
op_star
id|avdatum
comma
r_struct
id|avtab_key
op_star
id|avkey
)paren
(brace
id|u32
id|buf
(braket
l_int|7
)braket
suffix:semicolon
id|u32
id|items
comma
id|items2
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|memset
c_func
(paren
id|avkey
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|avtab_key
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|avdatum
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|avtab_datum
)paren
)paren
suffix:semicolon
id|rc
op_assign
id|next_entry
c_func
(paren
id|buf
comma
id|fp
comma
r_sizeof
(paren
id|u32
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security: avtab: truncated entry&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|bad
suffix:semicolon
)brace
id|items2
op_assign
id|le32_to_cpu
c_func
(paren
id|buf
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|items2
OG
id|ARRAY_SIZE
c_func
(paren
id|buf
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security: avtab: entry overflow&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|bad
suffix:semicolon
)brace
id|rc
op_assign
id|next_entry
c_func
(paren
id|buf
comma
id|fp
comma
r_sizeof
(paren
id|u32
)paren
op_star
id|items2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security: avtab: truncated entry&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|bad
suffix:semicolon
)brace
id|items
op_assign
l_int|0
suffix:semicolon
id|avkey-&gt;source_type
op_assign
id|le32_to_cpu
c_func
(paren
id|buf
(braket
id|items
op_increment
)braket
)paren
suffix:semicolon
id|avkey-&gt;target_type
op_assign
id|le32_to_cpu
c_func
(paren
id|buf
(braket
id|items
op_increment
)braket
)paren
suffix:semicolon
id|avkey-&gt;target_class
op_assign
id|le32_to_cpu
c_func
(paren
id|buf
(braket
id|items
op_increment
)braket
)paren
suffix:semicolon
id|avdatum-&gt;specified
op_assign
id|le32_to_cpu
c_func
(paren
id|buf
(braket
id|items
op_increment
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|avdatum-&gt;specified
op_amp
(paren
id|AVTAB_AV
op_or
id|AVTAB_TYPE
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security: avtab: null entry&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|bad
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|avdatum-&gt;specified
op_amp
id|AVTAB_AV
)paren
op_logical_and
(paren
id|avdatum-&gt;specified
op_amp
id|AVTAB_TYPE
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security: avtab: entry has both access vectors and types&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|bad
suffix:semicolon
)brace
r_if
c_cond
(paren
id|avdatum-&gt;specified
op_amp
id|AVTAB_AV
)paren
(brace
r_if
c_cond
(paren
id|avdatum-&gt;specified
op_amp
id|AVTAB_ALLOWED
)paren
id|avtab_allowed
c_func
(paren
id|avdatum
)paren
op_assign
id|le32_to_cpu
c_func
(paren
id|buf
(braket
id|items
op_increment
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|avdatum-&gt;specified
op_amp
id|AVTAB_AUDITDENY
)paren
id|avtab_auditdeny
c_func
(paren
id|avdatum
)paren
op_assign
id|le32_to_cpu
c_func
(paren
id|buf
(braket
id|items
op_increment
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|avdatum-&gt;specified
op_amp
id|AVTAB_AUDITALLOW
)paren
id|avtab_auditallow
c_func
(paren
id|avdatum
)paren
op_assign
id|le32_to_cpu
c_func
(paren
id|buf
(braket
id|items
op_increment
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|avdatum-&gt;specified
op_amp
id|AVTAB_TRANSITION
)paren
id|avtab_transition
c_func
(paren
id|avdatum
)paren
op_assign
id|le32_to_cpu
c_func
(paren
id|buf
(braket
id|items
op_increment
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|avdatum-&gt;specified
op_amp
id|AVTAB_CHANGE
)paren
id|avtab_change
c_func
(paren
id|avdatum
)paren
op_assign
id|le32_to_cpu
c_func
(paren
id|buf
(braket
id|items
op_increment
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|avdatum-&gt;specified
op_amp
id|AVTAB_MEMBER
)paren
id|avtab_member
c_func
(paren
id|avdatum
)paren
op_assign
id|le32_to_cpu
c_func
(paren
id|buf
(braket
id|items
op_increment
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|items
op_ne
id|items2
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security: avtab: entry only had %d items, expected %d&bslash;n&quot;
comma
id|items2
comma
id|items
)paren
suffix:semicolon
r_goto
id|bad
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|bad
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|avtab_read
r_int
id|avtab_read
c_func
(paren
r_struct
id|avtab
op_star
id|a
comma
r_void
op_star
id|fp
comma
id|u32
id|config
)paren
(brace
r_int
id|rc
suffix:semicolon
r_struct
id|avtab_key
id|avkey
suffix:semicolon
r_struct
id|avtab_datum
id|avdatum
suffix:semicolon
id|u32
id|buf
(braket
l_int|1
)braket
suffix:semicolon
id|u32
id|nel
comma
id|i
suffix:semicolon
id|rc
op_assign
id|next_entry
c_func
(paren
id|buf
comma
id|fp
comma
r_sizeof
(paren
id|u32
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security: avtab: truncated table&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|bad
suffix:semicolon
)brace
id|nel
op_assign
id|le32_to_cpu
c_func
(paren
id|buf
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nel
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security: avtab: table is empty&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|bad
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nel
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|avtab_read_item
c_func
(paren
id|fp
comma
op_amp
id|avdatum
comma
op_amp
id|avkey
)paren
)paren
r_goto
id|bad
suffix:semicolon
id|rc
op_assign
id|avtab_insert
c_func
(paren
id|a
comma
op_amp
id|avkey
comma
op_amp
id|avdatum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
r_if
c_cond
(paren
id|rc
op_eq
op_minus
id|ENOMEM
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security: avtab: out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
id|EEXIST
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;security: avtab: duplicate entry&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|bad
suffix:semicolon
)brace
)brace
id|rc
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|rc
suffix:semicolon
id|bad
suffix:colon
id|avtab_destroy
c_func
(paren
id|a
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|function|avtab_cache_init
r_void
id|avtab_cache_init
c_func
(paren
r_void
)paren
(brace
id|avtab_node_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;avtab_node&quot;
comma
r_sizeof
(paren
r_struct
id|avtab_node
)paren
comma
l_int|0
comma
id|SLAB_PANIC
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|avtab_cache_destroy
r_void
id|avtab_cache_destroy
c_func
(paren
r_void
)paren
(brace
id|kmem_cache_destroy
(paren
id|avtab_node_cachep
)paren
suffix:semicolon
)brace
eof
