multiline_comment|/* keyctl.c: userspace keyctl operations&n; *&n; * Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.&n; * Written by David Howells (dhowells@redhat.com)&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/syscalls.h&gt;
macro_line|#include &lt;linux/keyctl.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/err.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;internal.h&quot;
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * extract the description of a new key from userspace and either add it as a&n; * new key to the specified keyring or update a matching key in that keyring&n; * - the keyring must be writable&n; * - returns the new key&squot;s serial number&n; * - implements add_key()&n; */
DECL|function|sys_add_key
id|asmlinkage
r_int
id|sys_add_key
c_func
(paren
r_const
r_char
id|__user
op_star
id|_type
comma
r_const
r_char
id|__user
op_star
id|_description
comma
r_const
r_void
id|__user
op_star
id|_payload
comma
r_int
id|plen
comma
id|key_serial_t
id|ringid
)paren
(brace
r_struct
id|key
op_star
id|keyring
comma
op_star
id|key
suffix:semicolon
r_char
id|type
(braket
l_int|32
)braket
comma
op_star
id|description
suffix:semicolon
r_void
op_star
id|payload
suffix:semicolon
r_int
id|dlen
comma
id|ret
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|plen
OG
l_int|32767
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* draw all the data into kernel space */
id|ret
op_assign
id|strncpy_from_user
c_func
(paren
id|type
comma
id|_type
comma
r_sizeof
(paren
id|type
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|error
suffix:semicolon
id|type
(braket
l_int|31
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|dlen
op_assign
id|strnlen_user
c_func
(paren
id|_description
comma
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dlen
op_le
l_int|0
)paren
r_goto
id|error
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|dlen
OG
id|PAGE_SIZE
op_minus
l_int|1
)paren
r_goto
id|error
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|description
op_assign
id|kmalloc
c_func
(paren
id|dlen
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|description
)paren
r_goto
id|error
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|description
comma
id|_description
comma
id|dlen
op_plus
l_int|1
)paren
op_ne
l_int|0
)paren
r_goto
id|error2
suffix:semicolon
multiline_comment|/* pull the payload in if one was supplied */
id|payload
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|_payload
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|payload
op_assign
id|kmalloc
c_func
(paren
id|plen
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|payload
)paren
r_goto
id|error2
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|payload
comma
id|_payload
comma
id|plen
)paren
op_ne
l_int|0
)paren
r_goto
id|error3
suffix:semicolon
)brace
multiline_comment|/* find the target keyring (which must be writable) */
id|keyring
op_assign
id|lookup_user_key
c_func
(paren
id|ringid
comma
l_int|1
comma
l_int|0
comma
id|KEY_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|keyring
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|keyring
)paren
suffix:semicolon
r_goto
id|error3
suffix:semicolon
)brace
multiline_comment|/* create or update the requested key and add it to the target&n;&t; * keyring */
id|key
op_assign
id|key_create_or_update
c_func
(paren
id|keyring
comma
id|type
comma
id|description
comma
id|payload
comma
id|plen
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|key
)paren
)paren
(brace
id|ret
op_assign
id|key-&gt;serial
suffix:semicolon
id|key_put
c_func
(paren
id|key
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|key
)paren
suffix:semicolon
)brace
id|key_put
c_func
(paren
id|keyring
)paren
suffix:semicolon
id|error3
suffix:colon
id|kfree
c_func
(paren
id|payload
)paren
suffix:semicolon
id|error2
suffix:colon
id|kfree
c_func
(paren
id|description
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end sys_add_key() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * search the process keyrings for a matching key&n; * - nested keyrings may also be searched if they have Search permission&n; * - if a key is found, it will be attached to the destination keyring if&n; *   there&squot;s one specified&n; * - /sbin/request-key will be invoked if _callout_info is non-NULL&n; *   - the _callout_info string will be passed to /sbin/request-key&n; *   - if the _callout_info string is empty, it will be rendered as &quot;-&quot;&n; * - implements request_key()&n; */
DECL|function|sys_request_key
id|asmlinkage
r_int
id|sys_request_key
c_func
(paren
r_const
r_char
id|__user
op_star
id|_type
comma
r_const
r_char
id|__user
op_star
id|_description
comma
r_const
r_char
id|__user
op_star
id|_callout_info
comma
id|key_serial_t
id|destringid
)paren
(brace
r_struct
id|key_type
op_star
id|ktype
suffix:semicolon
r_struct
id|key
op_star
id|key
comma
op_star
id|dest
suffix:semicolon
r_char
id|type
(braket
l_int|32
)braket
comma
op_star
id|description
comma
op_star
id|callout_info
suffix:semicolon
r_int
id|dlen
comma
id|ret
suffix:semicolon
multiline_comment|/* pull the type into kernel space */
id|ret
op_assign
id|strncpy_from_user
c_func
(paren
id|type
comma
id|_type
comma
r_sizeof
(paren
id|type
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|error
suffix:semicolon
id|type
(braket
l_int|31
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* pull the description into kernel space */
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|dlen
op_assign
id|strnlen_user
c_func
(paren
id|_description
comma
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dlen
op_le
l_int|0
)paren
r_goto
id|error
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|dlen
OG
id|PAGE_SIZE
op_minus
l_int|1
)paren
r_goto
id|error
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|description
op_assign
id|kmalloc
c_func
(paren
id|dlen
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|description
)paren
r_goto
id|error
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|description
comma
id|_description
comma
id|dlen
op_plus
l_int|1
)paren
op_ne
l_int|0
)paren
r_goto
id|error2
suffix:semicolon
multiline_comment|/* pull the callout info into kernel space */
id|callout_info
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|_callout_info
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|dlen
op_assign
id|strnlen_user
c_func
(paren
id|_callout_info
comma
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dlen
op_le
l_int|0
)paren
r_goto
id|error2
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|dlen
OG
id|PAGE_SIZE
op_minus
l_int|1
)paren
r_goto
id|error2
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|callout_info
op_assign
id|kmalloc
c_func
(paren
id|dlen
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|callout_info
)paren
r_goto
id|error2
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|callout_info
comma
id|_callout_info
comma
id|dlen
op_plus
l_int|1
)paren
op_ne
l_int|0
)paren
r_goto
id|error3
suffix:semicolon
)brace
multiline_comment|/* get the destination keyring if specified */
id|dest
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|destringid
)paren
(brace
id|dest
op_assign
id|lookup_user_key
c_func
(paren
id|destringid
comma
l_int|1
comma
l_int|0
comma
id|KEY_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dest
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|dest
)paren
suffix:semicolon
r_goto
id|error3
suffix:semicolon
)brace
)brace
multiline_comment|/* find the key type */
id|ktype
op_assign
id|key_type_lookup
c_func
(paren
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|ktype
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|ktype
)paren
suffix:semicolon
r_goto
id|error4
suffix:semicolon
)brace
multiline_comment|/* do the search */
id|key
op_assign
id|request_key
c_func
(paren
id|ktype
comma
id|description
comma
id|callout_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|key
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|key
)paren
suffix:semicolon
r_goto
id|error5
suffix:semicolon
)brace
multiline_comment|/* link the resulting key to the destination keyring */
r_if
c_cond
(paren
id|dest
)paren
(brace
id|ret
op_assign
id|key_link
c_func
(paren
id|dest
comma
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|error6
suffix:semicolon
)brace
id|ret
op_assign
id|key-&gt;serial
suffix:semicolon
id|error6
suffix:colon
id|key_put
c_func
(paren
id|key
)paren
suffix:semicolon
id|error5
suffix:colon
id|key_type_put
c_func
(paren
id|ktype
)paren
suffix:semicolon
id|error4
suffix:colon
id|key_put
c_func
(paren
id|dest
)paren
suffix:semicolon
id|error3
suffix:colon
id|kfree
c_func
(paren
id|callout_info
)paren
suffix:semicolon
id|error2
suffix:colon
id|kfree
c_func
(paren
id|description
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end sys_request_key() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * get the ID of the specified process keyring&n; * - the keyring must have search permission to be found&n; * - implements keyctl(KEYCTL_GET_KEYRING_ID)&n; */
DECL|function|keyctl_get_keyring_ID
r_int
id|keyctl_get_keyring_ID
c_func
(paren
id|key_serial_t
id|id
comma
r_int
id|create
)paren
(brace
r_struct
id|key
op_star
id|key
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|key
op_assign
id|lookup_user_key
c_func
(paren
id|id
comma
id|create
comma
l_int|0
comma
id|KEY_SEARCH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|key
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|key
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|ret
op_assign
id|key-&gt;serial
suffix:semicolon
id|key_put
c_func
(paren
id|key
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end keyctl_get_keyring_ID() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * join the session keyring&n; * - implements keyctl(KEYCTL_JOIN_SESSION_KEYRING)&n; */
DECL|function|keyctl_join_session_keyring
r_int
id|keyctl_join_session_keyring
c_func
(paren
r_const
r_char
id|__user
op_star
id|_name
)paren
(brace
r_char
op_star
id|name
suffix:semicolon
r_int
id|nlen
comma
id|ret
suffix:semicolon
multiline_comment|/* fetch the name from userspace */
id|name
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|_name
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|nlen
op_assign
id|strnlen_user
c_func
(paren
id|_name
comma
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nlen
op_le
l_int|0
)paren
r_goto
id|error
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|nlen
OG
id|PAGE_SIZE
op_minus
l_int|1
)paren
r_goto
id|error
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|name
op_assign
id|kmalloc
c_func
(paren
id|nlen
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
r_goto
id|error
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|name
comma
id|_name
comma
id|nlen
op_plus
l_int|1
)paren
op_ne
l_int|0
)paren
r_goto
id|error2
suffix:semicolon
)brace
multiline_comment|/* join the session */
id|ret
op_assign
id|join_session_keyring
c_func
(paren
id|name
)paren
suffix:semicolon
id|error2
suffix:colon
id|kfree
c_func
(paren
id|name
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end keyctl_join_session_keyring() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * update a key&squot;s data payload&n; * - the key must be writable&n; * - implements keyctl(KEYCTL_UPDATE)&n; */
DECL|function|keyctl_update_key
r_int
id|keyctl_update_key
c_func
(paren
id|key_serial_t
id|id
comma
r_const
r_void
id|__user
op_star
id|_payload
comma
r_int
id|plen
)paren
(brace
r_struct
id|key
op_star
id|key
suffix:semicolon
r_void
op_star
id|payload
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|plen
OG
id|PAGE_SIZE
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* pull the payload in if one was supplied */
id|payload
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|_payload
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|payload
op_assign
id|kmalloc
c_func
(paren
id|plen
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|payload
)paren
r_goto
id|error
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|payload
comma
id|_payload
comma
id|plen
)paren
op_ne
l_int|0
)paren
r_goto
id|error2
suffix:semicolon
)brace
multiline_comment|/* find the target key (which must be writable) */
id|key
op_assign
id|lookup_user_key
c_func
(paren
id|id
comma
l_int|0
comma
l_int|0
comma
id|KEY_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|key
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|key
)paren
suffix:semicolon
r_goto
id|error2
suffix:semicolon
)brace
multiline_comment|/* update the key */
id|ret
op_assign
id|key_update
c_func
(paren
id|key
comma
id|payload
comma
id|plen
)paren
suffix:semicolon
id|key_put
c_func
(paren
id|key
)paren
suffix:semicolon
id|error2
suffix:colon
id|kfree
c_func
(paren
id|payload
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end keyctl_update_key() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * revoke a key&n; * - the key must be writable&n; * - implements keyctl(KEYCTL_REVOKE)&n; */
DECL|function|keyctl_revoke_key
r_int
id|keyctl_revoke_key
c_func
(paren
id|key_serial_t
id|id
)paren
(brace
r_struct
id|key
op_star
id|key
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|key
op_assign
id|lookup_user_key
c_func
(paren
id|id
comma
l_int|0
comma
l_int|0
comma
id|KEY_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|key
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|key
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|key_revoke
c_func
(paren
id|key
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|key_put
c_func
(paren
id|key
)paren
suffix:semicolon
id|error
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end keyctl_revoke_key() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * clear the specified process keyring&n; * - the keyring must be writable&n; * - implements keyctl(KEYCTL_CLEAR)&n; */
DECL|function|keyctl_keyring_clear
r_int
id|keyctl_keyring_clear
c_func
(paren
id|key_serial_t
id|ringid
)paren
(brace
r_struct
id|key
op_star
id|keyring
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|keyring
op_assign
id|lookup_user_key
c_func
(paren
id|ringid
comma
l_int|1
comma
l_int|0
comma
id|KEY_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|keyring
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|keyring
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|ret
op_assign
id|keyring_clear
c_func
(paren
id|keyring
)paren
suffix:semicolon
id|key_put
c_func
(paren
id|keyring
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end keyctl_keyring_clear() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * link a key into a keyring&n; * - the keyring must be writable&n; * - the key must be linkable&n; * - implements keyctl(KEYCTL_LINK)&n; */
DECL|function|keyctl_keyring_link
r_int
id|keyctl_keyring_link
c_func
(paren
id|key_serial_t
id|id
comma
id|key_serial_t
id|ringid
)paren
(brace
r_struct
id|key
op_star
id|keyring
comma
op_star
id|key
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|keyring
op_assign
id|lookup_user_key
c_func
(paren
id|ringid
comma
l_int|1
comma
l_int|0
comma
id|KEY_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|keyring
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|keyring
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|key
op_assign
id|lookup_user_key
c_func
(paren
id|id
comma
l_int|1
comma
l_int|0
comma
id|KEY_LINK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|key
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|key
)paren
suffix:semicolon
r_goto
id|error2
suffix:semicolon
)brace
id|ret
op_assign
id|key_link
c_func
(paren
id|keyring
comma
id|key
)paren
suffix:semicolon
id|key_put
c_func
(paren
id|key
)paren
suffix:semicolon
id|error2
suffix:colon
id|key_put
c_func
(paren
id|keyring
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end keyctl_keyring_link() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * unlink the first attachment of a key from a keyring&n; * - the keyring must be writable&n; * - we don&squot;t need any permissions on the key&n; * - implements keyctl(KEYCTL_UNLINK)&n; */
DECL|function|keyctl_keyring_unlink
r_int
id|keyctl_keyring_unlink
c_func
(paren
id|key_serial_t
id|id
comma
id|key_serial_t
id|ringid
)paren
(brace
r_struct
id|key
op_star
id|keyring
comma
op_star
id|key
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|keyring
op_assign
id|lookup_user_key
c_func
(paren
id|ringid
comma
l_int|0
comma
l_int|0
comma
id|KEY_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|keyring
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|keyring
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|key
op_assign
id|lookup_user_key
c_func
(paren
id|id
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|key
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|key
)paren
suffix:semicolon
r_goto
id|error2
suffix:semicolon
)brace
id|ret
op_assign
id|key_unlink
c_func
(paren
id|keyring
comma
id|key
)paren
suffix:semicolon
id|key_put
c_func
(paren
id|key
)paren
suffix:semicolon
id|error2
suffix:colon
id|key_put
c_func
(paren
id|keyring
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end keyctl_keyring_unlink() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * describe a user key&n; * - the key must have view permission&n; * - if there&squot;s a buffer, we place up to buflen bytes of data into it&n; * - unless there&squot;s an error, we return the amount of description available,&n; *   irrespective of how much we may have copied&n; * - the description is formatted thus:&n; *&t;type;uid;gid;perm;description&lt;NUL&gt;&n; * - implements keyctl(KEYCTL_DESCRIBE)&n; */
DECL|function|keyctl_describe_key
r_int
id|keyctl_describe_key
c_func
(paren
id|key_serial_t
id|keyid
comma
r_char
id|__user
op_star
id|buffer
comma
r_int
id|buflen
)paren
(brace
r_struct
id|key
op_star
id|key
suffix:semicolon
r_char
op_star
id|tmpbuf
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|key
op_assign
id|lookup_user_key
c_func
(paren
id|keyid
comma
l_int|0
comma
l_int|1
comma
id|KEY_VIEW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|key
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|key
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* calculate how much description we&squot;re going to return */
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|tmpbuf
op_assign
id|kmalloc
c_func
(paren
id|PAGE_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmpbuf
)paren
r_goto
id|error2
suffix:semicolon
id|ret
op_assign
id|snprintf
c_func
(paren
id|tmpbuf
comma
id|PAGE_SIZE
op_minus
l_int|1
comma
l_string|&quot;%s;%d;%d;%06x;%s&quot;
comma
id|key-&gt;type-&gt;name
comma
id|key-&gt;uid
comma
id|key-&gt;gid
comma
id|key-&gt;perm
comma
id|key-&gt;description
ques
c_cond
id|key-&gt;description
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
multiline_comment|/* include a NUL char at the end of the data */
r_if
c_cond
(paren
id|ret
OG
id|PAGE_SIZE
op_minus
l_int|1
)paren
id|ret
op_assign
id|PAGE_SIZE
op_minus
l_int|1
suffix:semicolon
id|tmpbuf
(braket
id|ret
)braket
op_assign
l_int|0
suffix:semicolon
id|ret
op_increment
suffix:semicolon
multiline_comment|/* consider returning the data */
r_if
c_cond
(paren
id|buffer
op_logical_and
id|buflen
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|buflen
OG
id|ret
)paren
id|buflen
op_assign
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buffer
comma
id|tmpbuf
comma
id|buflen
)paren
op_ne
l_int|0
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|tmpbuf
)paren
suffix:semicolon
id|error2
suffix:colon
id|key_put
c_func
(paren
id|key
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end keyctl_describe_key() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * search the specified keyring for a matching key&n; * - the start keyring must be searchable&n; * - nested keyrings may also be searched if they are searchable&n; * - only keys with search permission may be found&n; * - if a key is found, it will be attached to the destination keyring if&n; *   there&squot;s one specified&n; * - implements keyctl(KEYCTL_SEARCH)&n; */
DECL|function|keyctl_keyring_search
r_int
id|keyctl_keyring_search
c_func
(paren
id|key_serial_t
id|ringid
comma
r_const
r_char
id|__user
op_star
id|_type
comma
r_const
r_char
id|__user
op_star
id|_description
comma
id|key_serial_t
id|destringid
)paren
(brace
r_struct
id|key_type
op_star
id|ktype
suffix:semicolon
r_struct
id|key
op_star
id|keyring
comma
op_star
id|key
comma
op_star
id|dest
suffix:semicolon
r_char
id|type
(braket
l_int|32
)braket
comma
op_star
id|description
suffix:semicolon
r_int
id|dlen
comma
id|ret
suffix:semicolon
multiline_comment|/* pull the type and description into kernel space */
id|ret
op_assign
id|strncpy_from_user
c_func
(paren
id|type
comma
id|_type
comma
r_sizeof
(paren
id|type
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|error
suffix:semicolon
id|type
(braket
l_int|31
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|dlen
op_assign
id|strnlen_user
c_func
(paren
id|_description
comma
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dlen
op_le
l_int|0
)paren
r_goto
id|error
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|dlen
OG
id|PAGE_SIZE
op_minus
l_int|1
)paren
r_goto
id|error
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|description
op_assign
id|kmalloc
c_func
(paren
id|dlen
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|description
)paren
r_goto
id|error
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|description
comma
id|_description
comma
id|dlen
op_plus
l_int|1
)paren
op_ne
l_int|0
)paren
r_goto
id|error2
suffix:semicolon
multiline_comment|/* get the keyring at which to begin the search */
id|keyring
op_assign
id|lookup_user_key
c_func
(paren
id|ringid
comma
l_int|0
comma
l_int|0
comma
id|KEY_SEARCH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|keyring
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|keyring
)paren
suffix:semicolon
r_goto
id|error2
suffix:semicolon
)brace
multiline_comment|/* get the destination keyring if specified */
id|dest
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|destringid
)paren
(brace
id|dest
op_assign
id|lookup_user_key
c_func
(paren
id|destringid
comma
l_int|1
comma
l_int|0
comma
id|KEY_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dest
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|dest
)paren
suffix:semicolon
r_goto
id|error3
suffix:semicolon
)brace
)brace
multiline_comment|/* find the key type */
id|ktype
op_assign
id|key_type_lookup
c_func
(paren
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|ktype
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|ktype
)paren
suffix:semicolon
r_goto
id|error4
suffix:semicolon
)brace
multiline_comment|/* do the search */
id|key
op_assign
id|keyring_search
c_func
(paren
id|keyring
comma
id|ktype
comma
id|description
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|key
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|key
)paren
suffix:semicolon
multiline_comment|/* treat lack or presence of a negative key the same */
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EAGAIN
)paren
id|ret
op_assign
op_minus
id|ENOKEY
suffix:semicolon
r_goto
id|error5
suffix:semicolon
)brace
multiline_comment|/* link the resulting key to the destination keyring if we can */
r_if
c_cond
(paren
id|dest
)paren
(brace
id|ret
op_assign
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|key_permission
c_func
(paren
id|key
comma
id|KEY_LINK
)paren
)paren
r_goto
id|error6
suffix:semicolon
id|ret
op_assign
id|key_link
c_func
(paren
id|dest
comma
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|error6
suffix:semicolon
)brace
id|ret
op_assign
id|key-&gt;serial
suffix:semicolon
id|error6
suffix:colon
id|key_put
c_func
(paren
id|key
)paren
suffix:semicolon
id|error5
suffix:colon
id|key_type_put
c_func
(paren
id|ktype
)paren
suffix:semicolon
id|error4
suffix:colon
id|key_put
c_func
(paren
id|dest
)paren
suffix:semicolon
id|error3
suffix:colon
id|key_put
c_func
(paren
id|keyring
)paren
suffix:semicolon
id|error2
suffix:colon
id|kfree
c_func
(paren
id|description
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end keyctl_keyring_search() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * see if the key we&squot;re looking at is the target key&n; */
DECL|function|keyctl_read_key_same
r_static
r_int
id|keyctl_read_key_same
c_func
(paren
r_const
r_struct
id|key
op_star
id|key
comma
r_const
r_void
op_star
id|target
)paren
(brace
r_return
id|key
op_eq
id|target
suffix:semicolon
)brace
multiline_comment|/* end keyctl_read_key_same() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * read a user key&squot;s payload&n; * - the keyring must be readable or the key must be searchable from the&n; *   process&squot;s keyrings&n; * - if there&squot;s a buffer, we place up to buflen bytes of data into it&n; * - unless there&squot;s an error, we return the amount of data in the key,&n; *   irrespective of how much we may have copied&n; * - implements keyctl(KEYCTL_READ)&n; */
DECL|function|keyctl_read_key
r_int
id|keyctl_read_key
c_func
(paren
id|key_serial_t
id|keyid
comma
r_char
id|__user
op_star
id|buffer
comma
r_int
id|buflen
)paren
(brace
r_struct
id|key
op_star
id|key
comma
op_star
id|skey
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* find the key first */
id|key
op_assign
id|lookup_user_key
c_func
(paren
id|keyid
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|key
)paren
)paren
(brace
multiline_comment|/* see if we can read it directly */
r_if
c_cond
(paren
id|key_permission
c_func
(paren
id|key
comma
id|KEY_READ
)paren
)paren
r_goto
id|can_read_key
suffix:semicolon
multiline_comment|/* can&squot;t; see if it&squot;s searchable from this process&squot;s&n;&t;&t; * keyrings */
id|ret
op_assign
op_minus
id|ENOKEY
suffix:semicolon
r_if
c_cond
(paren
id|key_permission
c_func
(paren
id|key
comma
id|KEY_SEARCH
)paren
)paren
(brace
multiline_comment|/* okay - we do have search permission on the key&n;&t;&t;&t; * itself, but do we have the key? */
id|skey
op_assign
id|search_process_keyrings_aux
c_func
(paren
id|key-&gt;type
comma
id|key
comma
id|keyctl_read_key_same
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|skey
)paren
)paren
r_goto
id|can_read_key2
suffix:semicolon
)brace
r_goto
id|error2
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|ENOKEY
suffix:semicolon
r_goto
id|error
suffix:semicolon
multiline_comment|/* the key is probably readable - now try to read it */
id|can_read_key2
suffix:colon
id|key_put
c_func
(paren
id|skey
)paren
suffix:semicolon
id|can_read_key
suffix:colon
id|ret
op_assign
id|key_validate
c_func
(paren
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;type-&gt;read
)paren
(brace
multiline_comment|/* read the data with the semaphore held (since we&n;&t;&t;&t; * might sleep) */
id|down_read
c_func
(paren
op_amp
id|key-&gt;sem
)paren
suffix:semicolon
id|ret
op_assign
id|key-&gt;type
op_member_access_from_pointer
id|read
c_func
(paren
id|key
comma
id|buffer
comma
id|buflen
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|key-&gt;sem
)paren
suffix:semicolon
)brace
)brace
id|error2
suffix:colon
id|key_put
c_func
(paren
id|key
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end keyctl_read_key() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * change the ownership of a key&n; * - the keyring owned by the changer&n; * - if the uid or gid is -1, then that parameter is not changed&n; * - implements keyctl(KEYCTL_CHOWN)&n; */
DECL|function|keyctl_chown_key
r_int
id|keyctl_chown_key
c_func
(paren
id|key_serial_t
id|id
comma
id|uid_t
id|uid
comma
id|gid_t
id|gid
)paren
(brace
r_struct
id|key
op_star
id|key
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|uid
op_eq
(paren
id|uid_t
)paren
op_minus
l_int|1
op_logical_and
id|gid
op_eq
(paren
id|gid_t
)paren
op_minus
l_int|1
)paren
r_goto
id|error
suffix:semicolon
id|key
op_assign
id|lookup_user_key
c_func
(paren
id|id
comma
l_int|1
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|key
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|key
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* make the changes with the locks held to prevent chown/chown races */
id|ret
op_assign
op_minus
id|EACCES
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|key-&gt;sem
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|key-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
(brace
multiline_comment|/* only the sysadmin can chown a key to some other UID */
r_if
c_cond
(paren
id|uid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
op_logical_and
id|key-&gt;uid
op_ne
id|uid
)paren
r_goto
id|no_access
suffix:semicolon
multiline_comment|/* only the sysadmin can set the key&squot;s GID to a group other&n;&t;&t; * than one of those that the current process subscribes to */
r_if
c_cond
(paren
id|gid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
op_logical_and
id|gid
op_ne
id|key-&gt;gid
op_logical_and
op_logical_neg
id|in_group_p
c_func
(paren
id|gid
)paren
)paren
r_goto
id|no_access
suffix:semicolon
)brace
multiline_comment|/* change the UID (have to update the quotas) */
r_if
c_cond
(paren
id|uid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
op_logical_and
id|uid
op_ne
id|key-&gt;uid
)paren
(brace
multiline_comment|/* don&squot;t support UID changing yet */
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|no_access
suffix:semicolon
)brace
multiline_comment|/* change the GID */
r_if
c_cond
(paren
id|gid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
)paren
id|key-&gt;gid
op_assign
id|gid
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|no_access
suffix:colon
id|write_unlock
c_func
(paren
op_amp
id|key-&gt;lock
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|key-&gt;sem
)paren
suffix:semicolon
id|key_put
c_func
(paren
id|key
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end keyctl_chown_key() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * change the permission mask on a key&n; * - the keyring owned by the changer&n; * - implements keyctl(KEYCTL_SETPERM)&n; */
DECL|function|keyctl_setperm_key
r_int
id|keyctl_setperm_key
c_func
(paren
id|key_serial_t
id|id
comma
id|key_perm_t
id|perm
)paren
(brace
r_struct
id|key
op_star
id|key
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|perm
op_amp
op_complement
(paren
id|KEY_USR_ALL
op_or
id|KEY_GRP_ALL
op_or
id|KEY_OTH_ALL
)paren
)paren
r_goto
id|error
suffix:semicolon
id|key
op_assign
id|lookup_user_key
c_func
(paren
id|id
comma
l_int|1
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|key
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|key
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* make the changes with the locks held to prevent chown/chmod&n;&t; * races */
id|ret
op_assign
op_minus
id|EACCES
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|key-&gt;sem
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|key-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* if we&squot;re not the sysadmin, we can only chmod a key that we&n;&t; * own */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
op_logical_and
id|key-&gt;uid
op_ne
id|current-&gt;fsuid
)paren
r_goto
id|no_access
suffix:semicolon
multiline_comment|/* changing the permissions mask */
id|key-&gt;perm
op_assign
id|perm
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|no_access
suffix:colon
id|write_unlock
c_func
(paren
op_amp
id|key-&gt;lock
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|key-&gt;sem
)paren
suffix:semicolon
id|key_put
c_func
(paren
id|key
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end keyctl_setperm_key() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * instantiate the key with the specified payload, and, if one is given, link&n; * the key into the keyring&n; */
DECL|function|keyctl_instantiate_key
r_int
id|keyctl_instantiate_key
c_func
(paren
id|key_serial_t
id|id
comma
r_const
r_void
id|__user
op_star
id|_payload
comma
r_int
id|plen
comma
id|key_serial_t
id|ringid
)paren
(brace
r_struct
id|key
op_star
id|key
comma
op_star
id|keyring
suffix:semicolon
r_void
op_star
id|payload
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|plen
OG
l_int|32767
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* pull the payload in if one was supplied */
id|payload
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|_payload
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|payload
op_assign
id|kmalloc
c_func
(paren
id|plen
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|payload
)paren
r_goto
id|error
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|payload
comma
id|_payload
comma
id|plen
)paren
op_ne
l_int|0
)paren
r_goto
id|error2
suffix:semicolon
)brace
multiline_comment|/* find the target key (which must be writable) */
id|key
op_assign
id|lookup_user_key
c_func
(paren
id|id
comma
l_int|0
comma
l_int|1
comma
id|KEY_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|key
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|key
)paren
suffix:semicolon
r_goto
id|error2
suffix:semicolon
)brace
multiline_comment|/* find the destination keyring if present (which must also be&n;&t; * writable) */
id|keyring
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ringid
)paren
(brace
id|keyring
op_assign
id|lookup_user_key
c_func
(paren
id|ringid
comma
l_int|1
comma
l_int|0
comma
id|KEY_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|keyring
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|keyring
)paren
suffix:semicolon
r_goto
id|error3
suffix:semicolon
)brace
)brace
multiline_comment|/* instantiate the key and link it into a keyring */
id|ret
op_assign
id|key_instantiate_and_link
c_func
(paren
id|key
comma
id|payload
comma
id|plen
comma
id|keyring
)paren
suffix:semicolon
id|key_put
c_func
(paren
id|keyring
)paren
suffix:semicolon
id|error3
suffix:colon
id|key_put
c_func
(paren
id|key
)paren
suffix:semicolon
id|error2
suffix:colon
id|kfree
c_func
(paren
id|payload
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end keyctl_instantiate_key() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * negatively instantiate the key with the given timeout (in seconds), and, if&n; * one is given, link the key into the keyring&n; */
DECL|function|keyctl_negate_key
r_int
id|keyctl_negate_key
c_func
(paren
id|key_serial_t
id|id
comma
r_int
id|timeout
comma
id|key_serial_t
id|ringid
)paren
(brace
r_struct
id|key
op_star
id|key
comma
op_star
id|keyring
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* find the target key (which must be writable) */
id|key
op_assign
id|lookup_user_key
c_func
(paren
id|id
comma
l_int|0
comma
l_int|1
comma
id|KEY_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|key
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|key
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* find the destination keyring if present (which must also be&n;&t; * writable) */
id|keyring
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ringid
)paren
(brace
id|keyring
op_assign
id|lookup_user_key
c_func
(paren
id|ringid
comma
l_int|1
comma
l_int|0
comma
id|KEY_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|keyring
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|keyring
)paren
suffix:semicolon
r_goto
id|error2
suffix:semicolon
)brace
)brace
multiline_comment|/* instantiate the key and link it into a keyring */
id|ret
op_assign
id|key_negate_and_link
c_func
(paren
id|key
comma
id|timeout
comma
id|keyring
)paren
suffix:semicolon
id|key_put
c_func
(paren
id|keyring
)paren
suffix:semicolon
id|error2
suffix:colon
id|key_put
c_func
(paren
id|key
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end keyctl_negate_key() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * the key control system call&n; */
DECL|function|sys_keyctl
id|asmlinkage
r_int
id|sys_keyctl
c_func
(paren
r_int
id|option
comma
r_int
r_int
id|arg2
comma
r_int
r_int
id|arg3
comma
r_int
r_int
id|arg4
comma
r_int
r_int
id|arg5
)paren
(brace
r_switch
c_cond
(paren
id|option
)paren
(brace
r_case
id|KEYCTL_GET_KEYRING_ID
suffix:colon
r_return
id|keyctl_get_keyring_ID
c_func
(paren
(paren
id|key_serial_t
)paren
id|arg2
comma
(paren
r_int
)paren
id|arg3
)paren
suffix:semicolon
r_case
id|KEYCTL_JOIN_SESSION_KEYRING
suffix:colon
r_return
id|keyctl_join_session_keyring
c_func
(paren
(paren
r_const
r_char
id|__user
op_star
)paren
id|arg3
)paren
suffix:semicolon
r_case
id|KEYCTL_UPDATE
suffix:colon
r_return
id|keyctl_update_key
c_func
(paren
(paren
id|key_serial_t
)paren
id|arg2
comma
(paren
r_const
r_void
id|__user
op_star
)paren
id|arg3
comma
(paren
r_int
)paren
id|arg4
)paren
suffix:semicolon
r_case
id|KEYCTL_REVOKE
suffix:colon
r_return
id|keyctl_revoke_key
c_func
(paren
(paren
id|key_serial_t
)paren
id|arg2
)paren
suffix:semicolon
r_case
id|KEYCTL_DESCRIBE
suffix:colon
r_return
id|keyctl_describe_key
c_func
(paren
(paren
id|key_serial_t
)paren
id|arg2
comma
(paren
r_char
id|__user
op_star
)paren
id|arg3
comma
(paren
r_int
)paren
id|arg4
)paren
suffix:semicolon
r_case
id|KEYCTL_CLEAR
suffix:colon
r_return
id|keyctl_keyring_clear
c_func
(paren
(paren
id|key_serial_t
)paren
id|arg2
)paren
suffix:semicolon
r_case
id|KEYCTL_LINK
suffix:colon
r_return
id|keyctl_keyring_link
c_func
(paren
(paren
id|key_serial_t
)paren
id|arg2
comma
(paren
id|key_serial_t
)paren
id|arg3
)paren
suffix:semicolon
r_case
id|KEYCTL_UNLINK
suffix:colon
r_return
id|keyctl_keyring_unlink
c_func
(paren
(paren
id|key_serial_t
)paren
id|arg2
comma
(paren
id|key_serial_t
)paren
id|arg3
)paren
suffix:semicolon
r_case
id|KEYCTL_SEARCH
suffix:colon
r_return
id|keyctl_keyring_search
c_func
(paren
(paren
id|key_serial_t
)paren
id|arg2
comma
(paren
r_const
r_char
id|__user
op_star
)paren
id|arg3
comma
(paren
r_const
r_char
id|__user
op_star
)paren
id|arg4
comma
(paren
id|key_serial_t
)paren
id|arg5
)paren
suffix:semicolon
r_case
id|KEYCTL_READ
suffix:colon
r_return
id|keyctl_read_key
c_func
(paren
(paren
id|key_serial_t
)paren
id|arg2
comma
(paren
r_char
id|__user
op_star
)paren
id|arg3
comma
(paren
r_int
)paren
id|arg4
)paren
suffix:semicolon
r_case
id|KEYCTL_CHOWN
suffix:colon
r_return
id|keyctl_chown_key
c_func
(paren
(paren
id|key_serial_t
)paren
id|arg2
comma
(paren
id|uid_t
)paren
id|arg3
comma
(paren
id|gid_t
)paren
id|arg4
)paren
suffix:semicolon
r_case
id|KEYCTL_SETPERM
suffix:colon
r_return
id|keyctl_setperm_key
c_func
(paren
(paren
id|key_serial_t
)paren
id|arg2
comma
(paren
id|key_perm_t
)paren
id|arg3
)paren
suffix:semicolon
r_case
id|KEYCTL_INSTANTIATE
suffix:colon
r_return
id|keyctl_instantiate_key
c_func
(paren
(paren
id|key_serial_t
)paren
id|arg2
comma
(paren
r_const
r_void
id|__user
op_star
)paren
id|arg3
comma
(paren
r_int
)paren
id|arg4
comma
(paren
id|key_serial_t
)paren
id|arg5
)paren
suffix:semicolon
r_case
id|KEYCTL_NEGATE
suffix:colon
r_return
id|keyctl_negate_key
c_func
(paren
(paren
id|key_serial_t
)paren
id|arg2
comma
(paren
r_int
)paren
id|arg3
comma
(paren
id|key_serial_t
)paren
id|arg4
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
)brace
multiline_comment|/* end sys_keyctl() */
eof
