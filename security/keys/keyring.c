multiline_comment|/* keyring.c: keyring handling&n; *&n; * Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.&n; * Written by David Howells (dhowells@redhat.com)&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/err.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;internal.h&quot;
multiline_comment|/*&n; * when plumbing the depths of the key tree, this sets a hard limit set on how&n; * deep we&squot;re willing to go&n; */
DECL|macro|KEYRING_SEARCH_MAX_DEPTH
mdefine_line|#define KEYRING_SEARCH_MAX_DEPTH 6
multiline_comment|/*&n; * we keep all named keyrings in a hash to speed looking them up&n; */
DECL|macro|KEYRING_NAME_HASH_SIZE
mdefine_line|#define KEYRING_NAME_HASH_SIZE&t;(1 &lt;&lt; 5)
DECL|variable|keyring_name_hash
r_static
r_struct
id|list_head
id|keyring_name_hash
(braket
id|KEYRING_NAME_HASH_SIZE
)braket
suffix:semicolon
r_static
id|DEFINE_RWLOCK
c_func
(paren
id|keyring_name_lock
)paren
suffix:semicolon
DECL|function|keyring_hash
r_static
r_inline
r_int
id|keyring_hash
c_func
(paren
r_const
r_char
op_star
id|desc
)paren
(brace
r_int
id|bucket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
op_star
id|desc
suffix:semicolon
id|desc
op_increment
)paren
id|bucket
op_add_assign
(paren
r_int
r_char
)paren
op_star
id|desc
suffix:semicolon
r_return
id|bucket
op_amp
(paren
id|KEYRING_NAME_HASH_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * the keyring type definition&n; */
r_static
r_int
id|keyring_instantiate
c_func
(paren
r_struct
id|key
op_star
id|keyring
comma
r_const
r_void
op_star
id|data
comma
r_int
id|datalen
)paren
suffix:semicolon
r_static
r_int
id|keyring_duplicate
c_func
(paren
r_struct
id|key
op_star
id|keyring
comma
r_const
r_struct
id|key
op_star
id|source
)paren
suffix:semicolon
r_static
r_int
id|keyring_match
c_func
(paren
r_const
r_struct
id|key
op_star
id|keyring
comma
r_const
r_void
op_star
id|criterion
)paren
suffix:semicolon
r_static
r_void
id|keyring_destroy
c_func
(paren
r_struct
id|key
op_star
id|keyring
)paren
suffix:semicolon
r_static
r_void
id|keyring_describe
c_func
(paren
r_const
r_struct
id|key
op_star
id|keyring
comma
r_struct
id|seq_file
op_star
id|m
)paren
suffix:semicolon
r_static
r_int
id|keyring_read
c_func
(paren
r_const
r_struct
id|key
op_star
id|keyring
comma
r_char
id|__user
op_star
id|buffer
comma
r_int
id|buflen
)paren
suffix:semicolon
DECL|variable|key_type_keyring
r_struct
id|key_type
id|key_type_keyring
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;keyring&quot;
comma
dot
id|def_datalen
op_assign
r_sizeof
(paren
r_struct
id|keyring_list
)paren
comma
dot
id|instantiate
op_assign
id|keyring_instantiate
comma
dot
id|duplicate
op_assign
id|keyring_duplicate
comma
dot
id|match
op_assign
id|keyring_match
comma
dot
id|destroy
op_assign
id|keyring_destroy
comma
dot
id|describe
op_assign
id|keyring_describe
comma
dot
id|read
op_assign
id|keyring_read
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * semaphore to serialise link/link calls to prevent two link calls in parallel&n; * introducing a cycle&n; */
DECL|variable|keyring_serialise_link_sem
id|DECLARE_RWSEM
c_func
(paren
id|keyring_serialise_link_sem
)paren
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * publish the name of a keyring so that it can be found by name (if it has&n; * one)&n; */
DECL|function|keyring_publish_name
r_void
id|keyring_publish_name
c_func
(paren
r_struct
id|key
op_star
id|keyring
)paren
(brace
r_int
id|bucket
suffix:semicolon
r_if
c_cond
(paren
id|keyring-&gt;description
)paren
(brace
id|bucket
op_assign
id|keyring_hash
c_func
(paren
id|keyring-&gt;description
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|keyring_name_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|keyring_name_hash
(braket
id|bucket
)braket
dot
id|next
)paren
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|keyring_name_hash
(braket
id|bucket
)braket
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|keyring-&gt;type_data.link
comma
op_amp
id|keyring_name_hash
(braket
id|bucket
)braket
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|keyring_name_lock
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end keyring_publish_name() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * initialise a keyring&n; * - we object if we were given any data&n; */
DECL|function|keyring_instantiate
r_static
r_int
id|keyring_instantiate
c_func
(paren
r_struct
id|key
op_star
id|keyring
comma
r_const
r_void
op_star
id|data
comma
r_int
id|datalen
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|datalen
op_eq
l_int|0
)paren
(brace
multiline_comment|/* make the keyring available by name if it has one */
id|keyring_publish_name
c_func
(paren
id|keyring
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end keyring_instantiate() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * duplicate the list of subscribed keys from a source keyring into this one&n; */
DECL|function|keyring_duplicate
r_static
r_int
id|keyring_duplicate
c_func
(paren
r_struct
id|key
op_star
id|keyring
comma
r_const
r_struct
id|key
op_star
id|source
)paren
(brace
r_struct
id|keyring_list
op_star
id|sklist
comma
op_star
id|klist
suffix:semicolon
r_int
id|max
suffix:semicolon
r_int
id|size
suffix:semicolon
r_int
id|loop
comma
id|ret
suffix:semicolon
r_const
r_int
id|limit
op_assign
(paren
id|PAGE_SIZE
op_minus
r_sizeof
(paren
op_star
id|klist
)paren
)paren
op_div
r_sizeof
(paren
r_struct
id|key
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|sklist
op_assign
id|source-&gt;payload.subscriptions
suffix:semicolon
r_if
c_cond
(paren
id|sklist
op_logical_and
id|sklist-&gt;nkeys
OG
l_int|0
)paren
(brace
id|max
op_assign
id|sklist-&gt;nkeys
suffix:semicolon
id|BUG_ON
c_func
(paren
id|max
OG
id|limit
)paren
suffix:semicolon
id|max
op_assign
(paren
id|max
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|max
OG
id|limit
)paren
id|max
op_assign
id|limit
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|size
op_assign
r_sizeof
(paren
op_star
id|klist
)paren
op_plus
r_sizeof
(paren
r_struct
id|key
)paren
op_star
id|max
suffix:semicolon
id|klist
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|klist
)paren
r_goto
id|error
suffix:semicolon
id|klist-&gt;maxkeys
op_assign
id|max
suffix:semicolon
id|klist-&gt;nkeys
op_assign
id|sklist-&gt;nkeys
suffix:semicolon
id|memcpy
c_func
(paren
id|klist-&gt;keys
comma
id|sklist-&gt;keys
comma
id|sklist-&gt;nkeys
op_star
r_sizeof
(paren
r_struct
id|key
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
id|klist-&gt;nkeys
op_minus
l_int|1
suffix:semicolon
id|loop
op_ge
l_int|0
suffix:semicolon
id|loop
op_decrement
)paren
id|atomic_inc
c_func
(paren
op_amp
id|klist-&gt;keys
(braket
id|loop
)braket
op_member_access_from_pointer
id|usage
)paren
suffix:semicolon
id|keyring-&gt;payload.subscriptions
op_assign
id|klist
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end keyring_duplicate() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * match keyrings on their name&n; */
DECL|function|keyring_match
r_static
r_int
id|keyring_match
c_func
(paren
r_const
r_struct
id|key
op_star
id|keyring
comma
r_const
r_void
op_star
id|description
)paren
(brace
r_return
id|keyring-&gt;description
op_logical_and
id|strcmp
c_func
(paren
id|keyring-&gt;description
comma
id|description
)paren
op_eq
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end keyring_match() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * dispose of the data dangling from the corpse of a keyring&n; */
DECL|function|keyring_destroy
r_static
r_void
id|keyring_destroy
c_func
(paren
r_struct
id|key
op_star
id|keyring
)paren
(brace
r_struct
id|keyring_list
op_star
id|klist
suffix:semicolon
r_int
id|loop
suffix:semicolon
r_if
c_cond
(paren
id|keyring-&gt;description
)paren
(brace
id|write_lock
c_func
(paren
op_amp
id|keyring_name_lock
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|keyring-&gt;type_data.link
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|keyring_name_lock
)paren
suffix:semicolon
)brace
id|klist
op_assign
id|keyring-&gt;payload.subscriptions
suffix:semicolon
r_if
c_cond
(paren
id|klist
)paren
(brace
r_for
c_loop
(paren
id|loop
op_assign
id|klist-&gt;nkeys
op_minus
l_int|1
suffix:semicolon
id|loop
op_ge
l_int|0
suffix:semicolon
id|loop
op_decrement
)paren
id|key_put
c_func
(paren
id|klist-&gt;keys
(braket
id|loop
)braket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|klist
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end keyring_destroy() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * describe the keyring&n; */
DECL|function|keyring_describe
r_static
r_void
id|keyring_describe
c_func
(paren
r_const
r_struct
id|key
op_star
id|keyring
comma
r_struct
id|seq_file
op_star
id|m
)paren
(brace
r_struct
id|keyring_list
op_star
id|klist
suffix:semicolon
r_if
c_cond
(paren
id|keyring-&gt;description
)paren
(brace
id|seq_puts
c_func
(paren
id|m
comma
id|keyring-&gt;description
)paren
suffix:semicolon
)brace
r_else
(brace
id|seq_puts
c_func
(paren
id|m
comma
l_string|&quot;[anon]&quot;
)paren
suffix:semicolon
)brace
id|klist
op_assign
id|keyring-&gt;payload.subscriptions
suffix:semicolon
r_if
c_cond
(paren
id|klist
)paren
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;: %u/%u&quot;
comma
id|klist-&gt;nkeys
comma
id|klist-&gt;maxkeys
)paren
suffix:semicolon
r_else
id|seq_puts
c_func
(paren
id|m
comma
l_string|&quot;: empty&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* end keyring_describe() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * read a list of key IDs from the keyring&squot;s contents&n; */
DECL|function|keyring_read
r_static
r_int
id|keyring_read
c_func
(paren
r_const
r_struct
id|key
op_star
id|keyring
comma
r_char
id|__user
op_star
id|buffer
comma
r_int
id|buflen
)paren
(brace
r_struct
id|keyring_list
op_star
id|klist
suffix:semicolon
r_struct
id|key
op_star
id|key
suffix:semicolon
r_int
id|qty
comma
id|tmp
suffix:semicolon
r_int
id|loop
comma
id|ret
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|klist
op_assign
id|keyring-&gt;payload.subscriptions
suffix:semicolon
r_if
c_cond
(paren
id|klist
)paren
(brace
multiline_comment|/* calculate how much data we could return */
id|qty
op_assign
id|klist-&gt;nkeys
op_star
r_sizeof
(paren
id|key_serial_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_logical_and
id|buflen
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|buflen
OG
id|qty
)paren
id|buflen
op_assign
id|qty
suffix:semicolon
multiline_comment|/* copy the IDs of the subscribed keys into the&n;&t;&t;&t; * buffer */
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|klist-&gt;nkeys
suffix:semicolon
id|loop
op_increment
)paren
(brace
id|key
op_assign
id|klist-&gt;keys
(braket
id|loop
)braket
suffix:semicolon
id|tmp
op_assign
r_sizeof
(paren
id|key_serial_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OG
id|buflen
)paren
id|tmp
op_assign
id|buflen
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buffer
comma
op_amp
id|key-&gt;serial
comma
id|tmp
)paren
op_ne
l_int|0
)paren
r_goto
id|error
suffix:semicolon
id|buflen
op_sub_assign
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|buflen
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|buffer
op_add_assign
id|tmp
suffix:semicolon
)brace
)brace
id|ret
op_assign
id|qty
suffix:semicolon
)brace
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end keyring_read() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * allocate a keyring and link into the destination keyring&n; */
DECL|function|keyring_alloc
r_struct
id|key
op_star
id|keyring_alloc
c_func
(paren
r_const
r_char
op_star
id|description
comma
id|uid_t
id|uid
comma
id|gid_t
id|gid
comma
r_int
id|not_in_quota
comma
r_struct
id|key
op_star
id|dest
)paren
(brace
r_struct
id|key
op_star
id|keyring
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|keyring
op_assign
id|key_alloc
c_func
(paren
op_amp
id|key_type_keyring
comma
id|description
comma
id|uid
comma
id|gid
comma
id|KEY_USR_ALL
comma
id|not_in_quota
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|keyring
)paren
)paren
(brace
id|ret
op_assign
id|key_instantiate_and_link
c_func
(paren
id|keyring
comma
l_int|NULL
comma
l_int|0
comma
id|dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|key_put
c_func
(paren
id|keyring
)paren
suffix:semicolon
id|keyring
op_assign
id|ERR_PTR
c_func
(paren
id|ret
)paren
suffix:semicolon
)brace
)brace
r_return
id|keyring
suffix:semicolon
)brace
multiline_comment|/* end keyring_alloc() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * search the supplied keyring tree for a key that matches the criterion&n; * - perform a breadth-then-depth search up to the prescribed limit&n; * - we only find keys on which we have search permission&n; * - we use the supplied match function to see if the description (or other&n; *   feature of interest) matches&n; * - we readlock the keyrings as we search down the tree&n; * - we return -EAGAIN if we didn&squot;t find any matching key&n; * - we return -ENOKEY if we only found negative matching keys&n; */
DECL|function|keyring_search_aux
r_struct
id|key
op_star
id|keyring_search_aux
c_func
(paren
r_struct
id|key
op_star
id|keyring
comma
r_struct
id|key_type
op_star
id|type
comma
r_const
r_void
op_star
id|description
comma
id|key_match_func_t
id|match
)paren
(brace
r_struct
(brace
r_struct
id|key
op_star
id|keyring
suffix:semicolon
r_int
id|kix
suffix:semicolon
)brace
id|stack
(braket
id|KEYRING_SEARCH_MAX_DEPTH
)braket
suffix:semicolon
r_struct
id|keyring_list
op_star
id|keylist
suffix:semicolon
r_struct
id|timespec
id|now
suffix:semicolon
r_struct
id|key
op_star
id|key
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
id|sp
comma
id|psp
comma
id|kix
suffix:semicolon
id|key_check
c_func
(paren
id|keyring
)paren
suffix:semicolon
multiline_comment|/* top keyring must have search permission to begin the search */
id|key
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EACCES
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|key_permission
c_func
(paren
id|keyring
comma
id|KEY_SEARCH
)paren
)paren
r_goto
id|error
suffix:semicolon
id|key
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOTDIR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|keyring-&gt;type
op_ne
op_amp
id|key_type_keyring
)paren
r_goto
id|error
suffix:semicolon
id|now
op_assign
id|current_kernel_time
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EAGAIN
suffix:semicolon
id|sp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* start processing a new keyring */
id|descend
suffix:colon
id|read_lock
c_func
(paren
op_amp
id|keyring-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|keyring-&gt;flags
op_amp
id|KEY_FLAG_REVOKED
)paren
r_goto
id|not_this_keyring
suffix:semicolon
id|keylist
op_assign
id|keyring-&gt;payload.subscriptions
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|keylist
)paren
r_goto
id|not_this_keyring
suffix:semicolon
multiline_comment|/* iterate through the keys in this keyring first */
r_for
c_loop
(paren
id|kix
op_assign
l_int|0
suffix:semicolon
id|kix
OL
id|keylist-&gt;nkeys
suffix:semicolon
id|kix
op_increment
)paren
(brace
id|key
op_assign
id|keylist-&gt;keys
(braket
id|kix
)braket
suffix:semicolon
multiline_comment|/* ignore keys not of this type */
r_if
c_cond
(paren
id|key-&gt;type
op_ne
id|type
)paren
r_continue
suffix:semicolon
multiline_comment|/* skip revoked keys and expired keys */
r_if
c_cond
(paren
id|key-&gt;flags
op_amp
id|KEY_FLAG_REVOKED
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;expiry
op_logical_and
id|now.tv_sec
op_ge
id|key-&gt;expiry
)paren
r_continue
suffix:semicolon
multiline_comment|/* keys that don&squot;t match */
r_if
c_cond
(paren
op_logical_neg
id|match
c_func
(paren
id|key
comma
id|description
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* key must have search permissions */
r_if
c_cond
(paren
op_logical_neg
id|key_permission
c_func
(paren
id|key
comma
id|KEY_SEARCH
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* we set a different error code if we find a negative key */
r_if
c_cond
(paren
id|key-&gt;flags
op_amp
id|KEY_FLAG_NEGATIVE
)paren
(brace
id|err
op_assign
op_minus
id|ENOKEY
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_goto
id|found
suffix:semicolon
)brace
multiline_comment|/* search through the keyrings nested in this one */
id|kix
op_assign
l_int|0
suffix:semicolon
id|ascend
suffix:colon
r_while
c_loop
(paren
id|kix
OL
id|keylist-&gt;nkeys
)paren
(brace
id|key
op_assign
id|keylist-&gt;keys
(braket
id|kix
)braket
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;type
op_ne
op_amp
id|key_type_keyring
)paren
r_goto
id|next
suffix:semicolon
multiline_comment|/* recursively search nested keyrings&n;&t;&t; * - only search keyrings for which we have search permission&n;&t;&t; */
r_if
c_cond
(paren
id|sp
op_ge
id|KEYRING_SEARCH_MAX_DEPTH
)paren
r_goto
id|next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|key_permission
c_func
(paren
id|key
comma
id|KEY_SEARCH
)paren
)paren
r_goto
id|next
suffix:semicolon
multiline_comment|/* evade loops in the keyring tree */
r_for
c_loop
(paren
id|psp
op_assign
l_int|0
suffix:semicolon
id|psp
OL
id|sp
suffix:semicolon
id|psp
op_increment
)paren
r_if
c_cond
(paren
id|stack
(braket
id|psp
)braket
dot
id|keyring
op_eq
id|keyring
)paren
r_goto
id|next
suffix:semicolon
multiline_comment|/* stack the current position */
id|stack
(braket
id|sp
)braket
dot
id|keyring
op_assign
id|keyring
suffix:semicolon
id|stack
(braket
id|sp
)braket
dot
id|kix
op_assign
id|kix
suffix:semicolon
id|sp
op_increment
suffix:semicolon
multiline_comment|/* begin again with the new keyring */
id|keyring
op_assign
id|key
suffix:semicolon
r_goto
id|descend
suffix:semicolon
id|next
suffix:colon
id|kix
op_increment
suffix:semicolon
)brace
multiline_comment|/* the keyring we&squot;re looking at was disqualified or didn&squot;t contain a&n;&t; * matching key */
id|not_this_keyring
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|keyring-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sp
OG
l_int|0
)paren
(brace
multiline_comment|/* resume the processing of a keyring higher up in the tree */
id|sp
op_decrement
suffix:semicolon
id|keyring
op_assign
id|stack
(braket
id|sp
)braket
dot
id|keyring
suffix:semicolon
id|keylist
op_assign
id|keyring-&gt;payload.subscriptions
suffix:semicolon
id|kix
op_assign
id|stack
(braket
id|sp
)braket
dot
id|kix
op_plus
l_int|1
suffix:semicolon
r_goto
id|ascend
suffix:semicolon
)brace
id|key
op_assign
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
multiline_comment|/* we found a viable match */
id|found
suffix:colon
id|atomic_inc
c_func
(paren
op_amp
id|key-&gt;usage
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|keyring-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* unwind the keyring stack */
r_while
c_loop
(paren
id|sp
OG
l_int|0
)paren
(brace
id|sp
op_decrement
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|stack
(braket
id|sp
)braket
dot
id|keyring-&gt;lock
)paren
suffix:semicolon
)brace
id|key_check
c_func
(paren
id|key
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|key
suffix:semicolon
)brace
multiline_comment|/* end keyring_search_aux() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * search the supplied keyring tree for a key that matches the criterion&n; * - perform a breadth-then-depth search up to the prescribed limit&n; * - we only find keys on which we have search permission&n; * - we readlock the keyrings as we search down the tree&n; * - we return -EAGAIN if we didn&squot;t find any matching key&n; * - we return -ENOKEY if we only found negative matching keys&n; */
DECL|function|keyring_search
r_struct
id|key
op_star
id|keyring_search
c_func
(paren
r_struct
id|key
op_star
id|keyring
comma
r_struct
id|key_type
op_star
id|type
comma
r_const
r_char
op_star
id|description
)paren
(brace
r_return
id|keyring_search_aux
c_func
(paren
id|keyring
comma
id|type
comma
id|description
comma
id|type-&gt;match
)paren
suffix:semicolon
)brace
multiline_comment|/* end keyring_search() */
DECL|variable|keyring_search
id|EXPORT_SYMBOL
c_func
(paren
id|keyring_search
)paren
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * search the given keyring only (no recursion)&n; * - keyring must be locked by caller&n; */
DECL|function|__keyring_search_one
r_struct
id|key
op_star
id|__keyring_search_one
c_func
(paren
r_struct
id|key
op_star
id|keyring
comma
r_const
r_struct
id|key_type
op_star
id|ktype
comma
r_const
r_char
op_star
id|description
comma
id|key_perm_t
id|perm
)paren
(brace
r_struct
id|keyring_list
op_star
id|klist
suffix:semicolon
r_struct
id|key
op_star
id|key
suffix:semicolon
r_int
id|loop
suffix:semicolon
id|klist
op_assign
id|keyring-&gt;payload.subscriptions
suffix:semicolon
r_if
c_cond
(paren
id|klist
)paren
(brace
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|klist-&gt;nkeys
suffix:semicolon
id|loop
op_increment
)paren
(brace
id|key
op_assign
id|klist-&gt;keys
(braket
id|loop
)braket
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;type
op_eq
id|ktype
op_logical_and
id|key-&gt;type
op_member_access_from_pointer
id|match
c_func
(paren
id|key
comma
id|description
)paren
op_logical_and
id|key_permission
c_func
(paren
id|key
comma
id|perm
)paren
op_logical_and
op_logical_neg
(paren
id|key-&gt;flags
op_amp
id|KEY_FLAG_REVOKED
)paren
)paren
r_goto
id|found
suffix:semicolon
)brace
)brace
id|key
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOKEY
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
id|found
suffix:colon
id|atomic_inc
c_func
(paren
op_amp
id|key-&gt;usage
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|key
suffix:semicolon
)brace
multiline_comment|/* end __keyring_search_one() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * find a keyring with the specified name&n; * - all named keyrings are searched&n; * - only find keyrings with search permission for the process&n; * - only find keyrings with a serial number greater than the one specified&n; */
DECL|function|find_keyring_by_name
r_struct
id|key
op_star
id|find_keyring_by_name
c_func
(paren
r_const
r_char
op_star
id|name
comma
id|key_serial_t
id|bound
)paren
(brace
r_struct
id|key
op_star
id|keyring
suffix:semicolon
r_int
id|bucket
suffix:semicolon
id|keyring
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
r_goto
id|error
suffix:semicolon
id|bucket
op_assign
id|keyring_hash
c_func
(paren
id|name
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|keyring_name_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|keyring_name_hash
(braket
id|bucket
)braket
dot
id|next
)paren
(brace
multiline_comment|/* search this hash bucket for a keyring with a matching name&n;&t;&t; * that&squot;s readable and that hasn&squot;t been revoked */
id|list_for_each_entry
c_func
(paren
id|keyring
comma
op_amp
id|keyring_name_hash
(braket
id|bucket
)braket
comma
id|type_data.link
)paren
(brace
r_if
c_cond
(paren
id|keyring-&gt;flags
op_amp
id|KEY_FLAG_REVOKED
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|keyring-&gt;description
comma
id|name
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|key_permission
c_func
(paren
id|keyring
comma
id|KEY_SEARCH
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* found a potential candidate, but we still need to&n;&t;&t;&t; * check the serial number */
r_if
c_cond
(paren
id|keyring-&gt;serial
op_le
id|bound
)paren
r_continue
suffix:semicolon
multiline_comment|/* we&squot;ve got a match */
id|atomic_inc
c_func
(paren
op_amp
id|keyring-&gt;usage
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|keyring_name_lock
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|keyring_name_lock
)paren
suffix:semicolon
id|keyring
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOKEY
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|keyring
suffix:semicolon
)brace
multiline_comment|/* end find_keyring_by_name() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * see if a cycle will will be created by inserting acyclic tree B in acyclic&n; * tree A at the topmost level (ie: as a direct child of A)&n; * - since we are adding B to A at the top level, checking for cycles should&n; *   just be a matter of seeing if node A is somewhere in tree B&n; */
DECL|function|keyring_detect_cycle
r_static
r_int
id|keyring_detect_cycle
c_func
(paren
r_struct
id|key
op_star
id|A
comma
r_struct
id|key
op_star
id|B
)paren
(brace
r_struct
(brace
r_struct
id|key
op_star
id|subtree
suffix:semicolon
r_int
id|kix
suffix:semicolon
)brace
id|stack
(braket
id|KEYRING_SEARCH_MAX_DEPTH
)braket
suffix:semicolon
r_struct
id|keyring_list
op_star
id|keylist
suffix:semicolon
r_struct
id|key
op_star
id|subtree
comma
op_star
id|key
suffix:semicolon
r_int
id|sp
comma
id|kix
comma
id|ret
suffix:semicolon
id|ret
op_assign
op_minus
id|EDEADLK
suffix:semicolon
r_if
c_cond
(paren
id|A
op_eq
id|B
)paren
r_goto
id|error
suffix:semicolon
id|subtree
op_assign
id|B
suffix:semicolon
id|sp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* start processing a new keyring */
id|descend
suffix:colon
id|read_lock
c_func
(paren
op_amp
id|subtree-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|subtree-&gt;flags
op_amp
id|KEY_FLAG_REVOKED
)paren
r_goto
id|not_this_keyring
suffix:semicolon
id|keylist
op_assign
id|subtree-&gt;payload.subscriptions
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|keylist
)paren
r_goto
id|not_this_keyring
suffix:semicolon
id|kix
op_assign
l_int|0
suffix:semicolon
id|ascend
suffix:colon
multiline_comment|/* iterate through the remaining keys in this keyring */
r_for
c_loop
(paren
suffix:semicolon
id|kix
OL
id|keylist-&gt;nkeys
suffix:semicolon
id|kix
op_increment
)paren
(brace
id|key
op_assign
id|keylist-&gt;keys
(braket
id|kix
)braket
suffix:semicolon
r_if
c_cond
(paren
id|key
op_eq
id|A
)paren
r_goto
id|cycle_detected
suffix:semicolon
multiline_comment|/* recursively check nested keyrings */
r_if
c_cond
(paren
id|key-&gt;type
op_eq
op_amp
id|key_type_keyring
)paren
(brace
r_if
c_cond
(paren
id|sp
op_ge
id|KEYRING_SEARCH_MAX_DEPTH
)paren
r_goto
id|too_deep
suffix:semicolon
multiline_comment|/* stack the current position */
id|stack
(braket
id|sp
)braket
dot
id|subtree
op_assign
id|subtree
suffix:semicolon
id|stack
(braket
id|sp
)braket
dot
id|kix
op_assign
id|kix
suffix:semicolon
id|sp
op_increment
suffix:semicolon
multiline_comment|/* begin again with the new keyring */
id|subtree
op_assign
id|key
suffix:semicolon
r_goto
id|descend
suffix:semicolon
)brace
)brace
multiline_comment|/* the keyring we&squot;re looking at was disqualified or didn&squot;t contain a&n;&t; * matching key */
id|not_this_keyring
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|subtree-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sp
OG
l_int|0
)paren
(brace
multiline_comment|/* resume the checking of a keyring higher up in the tree */
id|sp
op_decrement
suffix:semicolon
id|subtree
op_assign
id|stack
(braket
id|sp
)braket
dot
id|subtree
suffix:semicolon
id|keylist
op_assign
id|subtree-&gt;payload.subscriptions
suffix:semicolon
id|kix
op_assign
id|stack
(braket
id|sp
)braket
dot
id|kix
op_plus
l_int|1
suffix:semicolon
r_goto
id|ascend
suffix:semicolon
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no cycles detected */
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
id|too_deep
suffix:colon
id|ret
op_assign
op_minus
id|ELOOP
suffix:semicolon
r_goto
id|error_unwind
suffix:semicolon
id|cycle_detected
suffix:colon
id|ret
op_assign
op_minus
id|EDEADLK
suffix:semicolon
id|error_unwind
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|subtree-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* unwind the keyring stack */
r_while
c_loop
(paren
id|sp
OG
l_int|0
)paren
(brace
id|sp
op_decrement
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|stack
(braket
id|sp
)braket
dot
id|subtree-&gt;lock
)paren
suffix:semicolon
)brace
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* end keyring_detect_cycle() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * link a key into to a keyring&n; * - must be called with the keyring&squot;s semaphore held&n; */
DECL|function|__key_link
r_int
id|__key_link
c_func
(paren
r_struct
id|key
op_star
id|keyring
comma
r_struct
id|key
op_star
id|key
)paren
(brace
r_struct
id|keyring_list
op_star
id|klist
comma
op_star
id|nklist
suffix:semicolon
r_int
id|max
suffix:semicolon
r_int
id|size
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ret
op_assign
op_minus
id|EKEYREVOKED
suffix:semicolon
r_if
c_cond
(paren
id|keyring-&gt;flags
op_amp
id|KEY_FLAG_REVOKED
)paren
r_goto
id|error
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOTDIR
suffix:semicolon
r_if
c_cond
(paren
id|keyring-&gt;type
op_ne
op_amp
id|key_type_keyring
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* serialise link/link calls to prevent parallel calls causing a&n;&t; * cycle when applied to two keyring in opposite orders */
id|down_write
c_func
(paren
op_amp
id|keyring_serialise_link_sem
)paren
suffix:semicolon
multiline_comment|/* check that we aren&squot;t going to create a cycle adding one keyring to&n;&t; * another */
r_if
c_cond
(paren
id|key-&gt;type
op_eq
op_amp
id|key_type_keyring
)paren
(brace
id|ret
op_assign
id|keyring_detect_cycle
c_func
(paren
id|keyring
comma
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|error2
suffix:semicolon
)brace
multiline_comment|/* check that we aren&squot;t going to overrun the user&squot;s quota */
id|ret
op_assign
id|key_payload_reserve
c_func
(paren
id|keyring
comma
id|keyring-&gt;datalen
op_plus
id|KEYQUOTA_LINK_BYTES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|error2
suffix:semicolon
id|klist
op_assign
id|keyring-&gt;payload.subscriptions
suffix:semicolon
r_if
c_cond
(paren
id|klist
op_logical_and
id|klist-&gt;nkeys
OL
id|klist-&gt;maxkeys
)paren
(brace
multiline_comment|/* there&squot;s sufficient slack space to add directly */
id|atomic_inc
c_func
(paren
op_amp
id|key-&gt;usage
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|keyring-&gt;lock
)paren
suffix:semicolon
id|klist-&gt;keys
(braket
id|klist-&gt;nkeys
op_increment
)braket
op_assign
id|key
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|keyring-&gt;lock
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* grow the key list */
id|max
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|klist
)paren
id|max
op_add_assign
id|klist-&gt;maxkeys
suffix:semicolon
id|ret
op_assign
op_minus
id|ENFILE
suffix:semicolon
id|size
op_assign
r_sizeof
(paren
op_star
id|klist
)paren
op_plus
r_sizeof
(paren
op_star
id|key
)paren
op_star
id|max
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|PAGE_SIZE
)paren
r_goto
id|error3
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|nklist
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nklist
)paren
r_goto
id|error3
suffix:semicolon
id|nklist-&gt;maxkeys
op_assign
id|max
suffix:semicolon
id|nklist-&gt;nkeys
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|klist
)paren
(brace
id|nklist-&gt;nkeys
op_assign
id|klist-&gt;nkeys
suffix:semicolon
id|memcpy
c_func
(paren
id|nklist-&gt;keys
comma
id|klist-&gt;keys
comma
r_sizeof
(paren
r_struct
id|key
op_star
)paren
op_star
id|klist-&gt;nkeys
)paren
suffix:semicolon
)brace
multiline_comment|/* add the key into the new space */
id|atomic_inc
c_func
(paren
op_amp
id|key-&gt;usage
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|keyring-&gt;lock
)paren
suffix:semicolon
id|keyring-&gt;payload.subscriptions
op_assign
id|nklist
suffix:semicolon
id|nklist-&gt;keys
(braket
id|nklist-&gt;nkeys
op_increment
)braket
op_assign
id|key
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|keyring-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* dispose of the old keyring list */
id|kfree
c_func
(paren
id|klist
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|error2
suffix:colon
id|up_write
c_func
(paren
op_amp
id|keyring_serialise_link_sem
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
id|error3
suffix:colon
multiline_comment|/* undo the quota changes */
id|key_payload_reserve
c_func
(paren
id|keyring
comma
id|keyring-&gt;datalen
op_minus
id|KEYQUOTA_LINK_BYTES
)paren
suffix:semicolon
r_goto
id|error2
suffix:semicolon
)brace
multiline_comment|/* end __key_link() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * link a key to a keyring&n; */
DECL|function|key_link
r_int
id|key_link
c_func
(paren
r_struct
id|key
op_star
id|keyring
comma
r_struct
id|key
op_star
id|key
)paren
(brace
r_int
id|ret
suffix:semicolon
id|key_check
c_func
(paren
id|keyring
)paren
suffix:semicolon
id|key_check
c_func
(paren
id|key
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|keyring-&gt;sem
)paren
suffix:semicolon
id|ret
op_assign
id|__key_link
c_func
(paren
id|keyring
comma
id|key
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|keyring-&gt;sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end key_link() */
DECL|variable|key_link
id|EXPORT_SYMBOL
c_func
(paren
id|key_link
)paren
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * unlink the first link to a key from a keyring&n; */
DECL|function|key_unlink
r_int
id|key_unlink
c_func
(paren
r_struct
id|key
op_star
id|keyring
comma
r_struct
id|key
op_star
id|key
)paren
(brace
r_struct
id|keyring_list
op_star
id|klist
suffix:semicolon
r_int
id|loop
comma
id|ret
suffix:semicolon
id|key_check
c_func
(paren
id|keyring
)paren
suffix:semicolon
id|key_check
c_func
(paren
id|key
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOTDIR
suffix:semicolon
r_if
c_cond
(paren
id|keyring-&gt;type
op_ne
op_amp
id|key_type_keyring
)paren
r_goto
id|error
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|keyring-&gt;sem
)paren
suffix:semicolon
id|klist
op_assign
id|keyring-&gt;payload.subscriptions
suffix:semicolon
r_if
c_cond
(paren
id|klist
)paren
(brace
multiline_comment|/* search the keyring for the key */
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|klist-&gt;nkeys
suffix:semicolon
id|loop
op_increment
)paren
r_if
c_cond
(paren
id|klist-&gt;keys
(braket
id|loop
)braket
op_eq
id|key
)paren
r_goto
id|key_is_present
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|keyring-&gt;sem
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|error
suffix:semicolon
id|key_is_present
suffix:colon
multiline_comment|/* adjust the user&squot;s quota */
id|key_payload_reserve
c_func
(paren
id|keyring
comma
id|keyring-&gt;datalen
op_minus
id|KEYQUOTA_LINK_BYTES
)paren
suffix:semicolon
multiline_comment|/* shuffle down the key pointers&n;&t; * - it might be worth shrinking the allocated memory, but that runs&n;&t; *   the risk of ENOMEM as we would have to copy&n;&t; */
id|write_lock
c_func
(paren
op_amp
id|keyring-&gt;lock
)paren
suffix:semicolon
id|klist-&gt;nkeys
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|loop
OL
id|klist-&gt;nkeys
)paren
id|memcpy
c_func
(paren
op_amp
id|klist-&gt;keys
(braket
id|loop
)braket
comma
op_amp
id|klist-&gt;keys
(braket
id|loop
op_plus
l_int|1
)braket
comma
(paren
id|klist-&gt;nkeys
op_minus
id|loop
)paren
op_star
r_sizeof
(paren
r_struct
id|key
op_star
)paren
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|keyring-&gt;lock
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|keyring-&gt;sem
)paren
suffix:semicolon
id|key_put
c_func
(paren
id|key
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end key_unlink() */
DECL|variable|key_unlink
id|EXPORT_SYMBOL
c_func
(paren
id|key_unlink
)paren
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * clear the specified process keyring&n; * - implements keyctl(KEYCTL_CLEAR)&n; */
DECL|function|keyring_clear
r_int
id|keyring_clear
c_func
(paren
r_struct
id|key
op_star
id|keyring
)paren
(brace
r_struct
id|keyring_list
op_star
id|klist
suffix:semicolon
r_int
id|loop
comma
id|ret
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOTDIR
suffix:semicolon
r_if
c_cond
(paren
id|keyring-&gt;type
op_eq
op_amp
id|key_type_keyring
)paren
(brace
multiline_comment|/* detach the pointer block with the locks held */
id|down_write
c_func
(paren
op_amp
id|keyring-&gt;sem
)paren
suffix:semicolon
id|klist
op_assign
id|keyring-&gt;payload.subscriptions
suffix:semicolon
r_if
c_cond
(paren
id|klist
)paren
(brace
multiline_comment|/* adjust the quota */
id|key_payload_reserve
c_func
(paren
id|keyring
comma
r_sizeof
(paren
r_struct
id|keyring_list
)paren
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|keyring-&gt;lock
)paren
suffix:semicolon
id|keyring-&gt;payload.subscriptions
op_assign
l_int|NULL
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|keyring-&gt;lock
)paren
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|keyring-&gt;sem
)paren
suffix:semicolon
multiline_comment|/* free the keys after the locks have been dropped */
r_if
c_cond
(paren
id|klist
)paren
(brace
r_for
c_loop
(paren
id|loop
op_assign
id|klist-&gt;nkeys
op_minus
l_int|1
suffix:semicolon
id|loop
op_ge
l_int|0
suffix:semicolon
id|loop
op_decrement
)paren
id|key_put
c_func
(paren
id|klist-&gt;keys
(braket
id|loop
)braket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|klist
)paren
suffix:semicolon
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end keyring_clear() */
DECL|variable|keyring_clear
id|EXPORT_SYMBOL
c_func
(paren
id|keyring_clear
)paren
suffix:semicolon
eof
