multiline_comment|/* key.c: basic authentication token and access key management&n; *&n; * Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.&n; * Written by David Howells (dhowells@redhat.com)&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;linux/err.h&gt;
macro_line|#include &quot;internal.h&quot;
DECL|variable|key_jar
r_static
id|kmem_cache_t
op_star
id|key_jar
suffix:semicolon
DECL|variable|key_serial_next
r_static
id|key_serial_t
id|key_serial_next
op_assign
l_int|3
suffix:semicolon
DECL|variable|key_serial_tree
r_struct
id|rb_root
id|key_serial_tree
suffix:semicolon
multiline_comment|/* tree of keys indexed by serial */
DECL|variable|key_serial_lock
id|DEFINE_SPINLOCK
c_func
(paren
id|key_serial_lock
)paren
suffix:semicolon
DECL|variable|key_user_tree
r_struct
id|rb_root
id|key_user_tree
suffix:semicolon
multiline_comment|/* tree of quota records indexed by UID */
DECL|variable|key_user_lock
id|DEFINE_SPINLOCK
c_func
(paren
id|key_user_lock
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|key_types_list
)paren
suffix:semicolon
r_static
id|DECLARE_RWSEM
c_func
(paren
id|key_types_sem
)paren
suffix:semicolon
r_static
r_void
id|key_cleanup
c_func
(paren
r_void
op_star
id|data
)paren
suffix:semicolon
r_static
id|DECLARE_WORK
c_func
(paren
id|key_cleanup_task
comma
id|key_cleanup
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* we serialise key instantiation and link */
DECL|variable|key_construction_sem
id|DECLARE_RWSEM
c_func
(paren
id|key_construction_sem
)paren
suffix:semicolon
multiline_comment|/* any key who&squot;s type gets unegistered will be re-typed to this */
DECL|variable|key_type_dead
r_struct
id|key_type
id|key_type_dead
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;dead&quot;
comma
)brace
suffix:semicolon
macro_line|#ifdef KEY_DEBUGGING
DECL|function|__key_check
r_void
id|__key_check
c_func
(paren
r_const
r_struct
id|key
op_star
id|key
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;__key_check: key %p {%08x} should be {%08x}&bslash;n&quot;
comma
id|key
comma
id|key-&gt;magic
comma
id|KEY_DEBUG_MAGIC
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * get the key quota record for a user, allocating a new record if one doesn&squot;t&n; * already exist&n; */
DECL|function|key_user_lookup
r_struct
id|key_user
op_star
id|key_user_lookup
c_func
(paren
id|uid_t
id|uid
)paren
(brace
r_struct
id|key_user
op_star
id|candidate
op_assign
l_int|NULL
comma
op_star
id|user
suffix:semicolon
r_struct
id|rb_node
op_star
id|parent
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|rb_node
op_star
op_star
id|p
op_assign
op_amp
id|key_user_tree.rb_node
suffix:semicolon
id|try_again
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|key_user_lock
)paren
suffix:semicolon
multiline_comment|/* search the tree for a user record with a matching UID */
r_while
c_loop
(paren
op_star
id|p
)paren
(brace
id|parent
op_assign
op_star
id|p
suffix:semicolon
id|user
op_assign
id|rb_entry
c_func
(paren
id|parent
comma
r_struct
id|key_user
comma
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uid
OL
id|user-&gt;uid
)paren
id|p
op_assign
op_amp
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|rb_left
suffix:semicolon
r_else
r_if
c_cond
(paren
id|uid
OG
id|user-&gt;uid
)paren
id|p
op_assign
op_amp
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|rb_right
suffix:semicolon
r_else
r_goto
id|found
suffix:semicolon
)brace
multiline_comment|/* if we get here, we failed to find a match in the tree */
r_if
c_cond
(paren
op_logical_neg
id|candidate
)paren
(brace
multiline_comment|/* allocate a candidate user record if we don&squot;t already have&n;&t;&t; * one */
id|spin_unlock
c_func
(paren
op_amp
id|key_user_lock
)paren
suffix:semicolon
id|user
op_assign
l_int|NULL
suffix:semicolon
id|candidate
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|key_user
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|candidate
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* the allocation may have scheduled, so we need to repeat the&n;&t;&t; * search lest someone else added the record whilst we were&n;&t;&t; * asleep */
r_goto
id|try_again
suffix:semicolon
)brace
multiline_comment|/* if we get here, then the user record still hadn&squot;t appeared on the&n;&t; * second pass - so we use the candidate record */
id|atomic_set
c_func
(paren
op_amp
id|candidate-&gt;usage
comma
l_int|1
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|candidate-&gt;nkeys
comma
l_int|0
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|candidate-&gt;nikeys
comma
l_int|0
)paren
suffix:semicolon
id|candidate-&gt;uid
op_assign
id|uid
suffix:semicolon
id|candidate-&gt;qnkeys
op_assign
l_int|0
suffix:semicolon
id|candidate-&gt;qnbytes
op_assign
l_int|0
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|candidate-&gt;lock
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|candidate-&gt;consq
)paren
suffix:semicolon
id|rb_link_node
c_func
(paren
op_amp
id|candidate-&gt;node
comma
id|parent
comma
id|p
)paren
suffix:semicolon
id|rb_insert_color
c_func
(paren
op_amp
id|candidate-&gt;node
comma
op_amp
id|key_user_tree
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|key_user_lock
)paren
suffix:semicolon
id|user
op_assign
id|candidate
suffix:semicolon
r_goto
id|out
suffix:semicolon
multiline_comment|/* okay - we found a user record for this UID */
id|found
suffix:colon
id|atomic_inc
c_func
(paren
op_amp
id|user-&gt;usage
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|key_user_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|candidate
)paren
id|kfree
c_func
(paren
id|candidate
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|user
suffix:semicolon
)brace
multiline_comment|/* end key_user_lookup() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * dispose of a user structure&n; */
DECL|function|key_user_put
r_void
id|key_user_put
c_func
(paren
r_struct
id|key_user
op_star
id|user
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_lock
c_func
(paren
op_amp
id|user-&gt;usage
comma
op_amp
id|key_user_lock
)paren
)paren
(brace
id|rb_erase
c_func
(paren
op_amp
id|user-&gt;node
comma
op_amp
id|key_user_tree
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|key_user_lock
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|user
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end key_user_put() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * insert a key with a fixed serial number&n; */
DECL|function|__key_insert_serial
r_static
r_void
id|__init
id|__key_insert_serial
c_func
(paren
r_struct
id|key
op_star
id|key
)paren
(brace
r_struct
id|rb_node
op_star
id|parent
comma
op_star
op_star
id|p
suffix:semicolon
r_struct
id|key
op_star
id|xkey
suffix:semicolon
id|parent
op_assign
l_int|NULL
suffix:semicolon
id|p
op_assign
op_amp
id|key_serial_tree.rb_node
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
)paren
(brace
id|parent
op_assign
op_star
id|p
suffix:semicolon
id|xkey
op_assign
id|rb_entry
c_func
(paren
id|parent
comma
r_struct
id|key
comma
id|serial_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;serial
OL
id|xkey-&gt;serial
)paren
id|p
op_assign
op_amp
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|rb_left
suffix:semicolon
r_else
r_if
c_cond
(paren
id|key-&gt;serial
OG
id|xkey-&gt;serial
)paren
id|p
op_assign
op_amp
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|rb_right
suffix:semicolon
r_else
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* we&squot;ve found a suitable hole - arrange for this key to occupy it */
id|rb_link_node
c_func
(paren
op_amp
id|key-&gt;serial_node
comma
id|parent
comma
id|p
)paren
suffix:semicolon
id|rb_insert_color
c_func
(paren
op_amp
id|key-&gt;serial_node
comma
op_amp
id|key_serial_tree
)paren
suffix:semicolon
)brace
multiline_comment|/* end __key_insert_serial() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * assign a key the next unique serial number&n; * - we work through all the serial numbers between 2 and 2^31-1 in turn and&n; *   then wrap&n; */
DECL|function|key_alloc_serial
r_static
r_inline
r_void
id|key_alloc_serial
c_func
(paren
r_struct
id|key
op_star
id|key
)paren
(brace
r_struct
id|rb_node
op_star
id|parent
comma
op_star
op_star
id|p
suffix:semicolon
r_struct
id|key
op_star
id|xkey
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|key_serial_lock
)paren
suffix:semicolon
multiline_comment|/* propose a likely serial number and look for a hole for it in the&n;&t; * serial number tree */
id|key-&gt;serial
op_assign
id|key_serial_next
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;serial
OL
l_int|3
)paren
id|key-&gt;serial
op_assign
l_int|3
suffix:semicolon
id|key_serial_next
op_assign
id|key-&gt;serial
op_plus
l_int|1
suffix:semicolon
id|parent
op_assign
l_int|NULL
suffix:semicolon
id|p
op_assign
op_amp
id|key_serial_tree.rb_node
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
)paren
(brace
id|parent
op_assign
op_star
id|p
suffix:semicolon
id|xkey
op_assign
id|rb_entry
c_func
(paren
id|parent
comma
r_struct
id|key
comma
id|serial_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;serial
OL
id|xkey-&gt;serial
)paren
id|p
op_assign
op_amp
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|rb_left
suffix:semicolon
r_else
r_if
c_cond
(paren
id|key-&gt;serial
OG
id|xkey-&gt;serial
)paren
id|p
op_assign
op_amp
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|rb_right
suffix:semicolon
r_else
r_goto
id|serial_exists
suffix:semicolon
)brace
r_goto
id|insert_here
suffix:semicolon
multiline_comment|/* we found a key with the proposed serial number - walk the tree from&n;&t; * that point looking for the next unused serial number */
id|serial_exists
suffix:colon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|key-&gt;serial
op_assign
id|key_serial_next
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;serial
OL
l_int|2
)paren
id|key-&gt;serial
op_assign
l_int|2
suffix:semicolon
id|key_serial_next
op_assign
id|key-&gt;serial
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent-&gt;rb_parent
)paren
id|p
op_assign
op_amp
id|key_serial_tree.rb_node
suffix:semicolon
r_else
r_if
c_cond
(paren
id|parent-&gt;rb_parent-&gt;rb_left
op_eq
id|parent
)paren
id|p
op_assign
op_amp
id|parent-&gt;rb_parent-&gt;rb_left
suffix:semicolon
r_else
id|p
op_assign
op_amp
id|parent-&gt;rb_parent-&gt;rb_right
suffix:semicolon
id|parent
op_assign
id|rb_next
c_func
(paren
id|parent
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent
)paren
r_break
suffix:semicolon
id|xkey
op_assign
id|rb_entry
c_func
(paren
id|parent
comma
r_struct
id|key
comma
id|serial_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;serial
OL
id|xkey-&gt;serial
)paren
r_goto
id|insert_here
suffix:semicolon
)brace
multiline_comment|/* we&squot;ve found a suitable hole - arrange for this key to occupy it */
id|insert_here
suffix:colon
id|rb_link_node
c_func
(paren
op_amp
id|key-&gt;serial_node
comma
id|parent
comma
id|p
)paren
suffix:semicolon
id|rb_insert_color
c_func
(paren
op_amp
id|key-&gt;serial_node
comma
op_amp
id|key_serial_tree
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|key_serial_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* end key_alloc_serial() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * allocate a key of the specified type&n; * - update the user&squot;s quota to reflect the existence of the key&n; * - called from a key-type operation with key_types_sem read-locked by either&n; *   key_create_or_update() or by key_duplicate(); this prevents unregistration&n; *   of the key type&n; * - upon return the key is as yet uninstantiated; the caller needs to either&n; *   instantiate the key or discard it before returning&n; */
DECL|function|key_alloc
r_struct
id|key
op_star
id|key_alloc
c_func
(paren
r_struct
id|key_type
op_star
id|type
comma
r_const
r_char
op_star
id|desc
comma
id|uid_t
id|uid
comma
id|gid_t
id|gid
comma
id|key_perm_t
id|perm
comma
r_int
id|not_in_quota
)paren
(brace
r_struct
id|key_user
op_star
id|user
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|key
op_star
id|key
suffix:semicolon
r_int
id|desclen
comma
id|quotalen
suffix:semicolon
id|key
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|desc
op_logical_or
op_logical_neg
op_star
id|desc
)paren
r_goto
id|error
suffix:semicolon
id|desclen
op_assign
id|strlen
c_func
(paren
id|desc
)paren
op_plus
l_int|1
suffix:semicolon
id|quotalen
op_assign
id|desclen
op_plus
id|type-&gt;def_datalen
suffix:semicolon
multiline_comment|/* get hold of the key tracking for this user */
id|user
op_assign
id|key_user_lookup
c_func
(paren
id|uid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|user
)paren
r_goto
id|no_memory_1
suffix:semicolon
multiline_comment|/* check that the user&squot;s quota permits allocation of another key and&n;&t; * its description */
r_if
c_cond
(paren
op_logical_neg
id|not_in_quota
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|user-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|user-&gt;qnkeys
op_plus
l_int|1
op_ge
id|KEYQUOTA_MAX_KEYS
op_logical_and
id|user-&gt;qnbytes
op_plus
id|quotalen
op_ge
id|KEYQUOTA_MAX_BYTES
)paren
r_goto
id|no_quota
suffix:semicolon
id|user-&gt;qnkeys
op_increment
suffix:semicolon
id|user-&gt;qnbytes
op_add_assign
id|quotalen
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|user-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/* allocate and initialise the key and its description */
id|key
op_assign
id|kmem_cache_alloc
c_func
(paren
id|key_jar
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|key
)paren
r_goto
id|no_memory_2
suffix:semicolon
r_if
c_cond
(paren
id|desc
)paren
(brace
id|key-&gt;description
op_assign
id|kmalloc
c_func
(paren
id|desclen
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|key-&gt;description
)paren
r_goto
id|no_memory_3
suffix:semicolon
id|memcpy
c_func
(paren
id|key-&gt;description
comma
id|desc
comma
id|desclen
)paren
suffix:semicolon
)brace
id|atomic_set
c_func
(paren
op_amp
id|key-&gt;usage
comma
l_int|1
)paren
suffix:semicolon
id|rwlock_init
c_func
(paren
op_amp
id|key-&gt;lock
)paren
suffix:semicolon
id|init_rwsem
c_func
(paren
op_amp
id|key-&gt;sem
)paren
suffix:semicolon
id|key-&gt;type
op_assign
id|type
suffix:semicolon
id|key-&gt;user
op_assign
id|user
suffix:semicolon
id|key-&gt;quotalen
op_assign
id|quotalen
suffix:semicolon
id|key-&gt;datalen
op_assign
id|type-&gt;def_datalen
suffix:semicolon
id|key-&gt;uid
op_assign
id|uid
suffix:semicolon
id|key-&gt;gid
op_assign
id|gid
suffix:semicolon
id|key-&gt;perm
op_assign
id|perm
suffix:semicolon
id|key-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|key-&gt;expiry
op_assign
l_int|0
suffix:semicolon
id|key-&gt;payload.data
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|not_in_quota
)paren
id|key-&gt;flags
op_or_assign
id|KEY_FLAG_IN_QUOTA
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|key-&gt;type_data
comma
l_int|0
comma
r_sizeof
(paren
id|key-&gt;type_data
)paren
)paren
suffix:semicolon
macro_line|#ifdef KEY_DEBUGGING
id|key-&gt;magic
op_assign
id|KEY_DEBUG_MAGIC
suffix:semicolon
macro_line|#endif
multiline_comment|/* publish the key by giving it a serial number */
id|atomic_inc
c_func
(paren
op_amp
id|user-&gt;nkeys
)paren
suffix:semicolon
id|key_alloc_serial
c_func
(paren
id|key
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|key
suffix:semicolon
id|no_memory_3
suffix:colon
id|kmem_cache_free
c_func
(paren
id|key_jar
comma
id|key
)paren
suffix:semicolon
id|no_memory_2
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|not_in_quota
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|user-&gt;lock
)paren
suffix:semicolon
id|user-&gt;qnkeys
op_decrement
suffix:semicolon
id|user-&gt;qnbytes
op_sub_assign
id|quotalen
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|user-&gt;lock
)paren
suffix:semicolon
)brace
id|key_user_put
c_func
(paren
id|user
)paren
suffix:semicolon
id|no_memory_1
suffix:colon
id|key
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
id|no_quota
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|user-&gt;lock
)paren
suffix:semicolon
id|key_user_put
c_func
(paren
id|user
)paren
suffix:semicolon
id|key
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EDQUOT
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* end key_alloc() */
DECL|variable|key_alloc
id|EXPORT_SYMBOL
c_func
(paren
id|key_alloc
)paren
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * reserve an amount of quota for the key&squot;s payload&n; */
DECL|function|key_payload_reserve
r_int
id|key_payload_reserve
c_func
(paren
r_struct
id|key
op_star
id|key
comma
r_int
id|datalen
)paren
(brace
r_int
id|delta
op_assign
(paren
r_int
)paren
id|datalen
op_minus
id|key-&gt;datalen
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|key_check
c_func
(paren
id|key
)paren
suffix:semicolon
multiline_comment|/* contemplate the quota adjustment */
r_if
c_cond
(paren
id|delta
op_ne
l_int|0
op_logical_and
id|key-&gt;flags
op_amp
id|KEY_FLAG_IN_QUOTA
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|key-&gt;user-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta
OG
l_int|0
op_logical_and
id|key-&gt;user-&gt;qnbytes
op_plus
id|delta
OG
id|KEYQUOTA_MAX_BYTES
)paren
(brace
id|ret
op_assign
op_minus
id|EDQUOT
suffix:semicolon
)brace
r_else
(brace
id|key-&gt;user-&gt;qnbytes
op_add_assign
id|delta
suffix:semicolon
id|key-&gt;quotalen
op_add_assign
id|delta
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|key-&gt;user-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/* change the recorded data length if that didn&squot;t generate an error */
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|key-&gt;datalen
op_assign
id|datalen
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end key_payload_reserve() */
DECL|variable|key_payload_reserve
id|EXPORT_SYMBOL
c_func
(paren
id|key_payload_reserve
)paren
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * instantiate a key and link it into the target keyring atomically&n; * - called with the target keyring&squot;s semaphore writelocked&n; */
DECL|function|__key_instantiate_and_link
r_static
r_int
id|__key_instantiate_and_link
c_func
(paren
r_struct
id|key
op_star
id|key
comma
r_const
r_void
op_star
id|data
comma
r_int
id|datalen
comma
r_struct
id|key
op_star
id|keyring
)paren
(brace
r_int
id|ret
comma
id|awaken
suffix:semicolon
id|key_check
c_func
(paren
id|key
)paren
suffix:semicolon
id|key_check
c_func
(paren
id|keyring
)paren
suffix:semicolon
id|awaken
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|key_construction_sem
)paren
suffix:semicolon
multiline_comment|/* can&squot;t instantiate twice */
r_if
c_cond
(paren
op_logical_neg
(paren
id|key-&gt;flags
op_amp
id|KEY_FLAG_INSTANTIATED
)paren
)paren
(brace
multiline_comment|/* instantiate the key */
id|ret
op_assign
id|key-&gt;type
op_member_access_from_pointer
id|instantiate
c_func
(paren
id|key
comma
id|data
comma
id|datalen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
multiline_comment|/* mark the key as being instantiated */
id|write_lock
c_func
(paren
op_amp
id|key-&gt;lock
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|key-&gt;user-&gt;nikeys
)paren
suffix:semicolon
id|key-&gt;flags
op_or_assign
id|KEY_FLAG_INSTANTIATED
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;flags
op_amp
id|KEY_FLAG_USER_CONSTRUCT
)paren
(brace
id|key-&gt;flags
op_and_assign
op_complement
id|KEY_FLAG_USER_CONSTRUCT
suffix:semicolon
id|awaken
op_assign
l_int|1
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|key-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* and link it into the destination keyring */
r_if
c_cond
(paren
id|keyring
)paren
id|ret
op_assign
id|__key_link
c_func
(paren
id|keyring
comma
id|key
)paren
suffix:semicolon
)brace
)brace
id|up_write
c_func
(paren
op_amp
id|key_construction_sem
)paren
suffix:semicolon
multiline_comment|/* wake up anyone waiting for a key to be constructed */
r_if
c_cond
(paren
id|awaken
)paren
id|wake_up_all
c_func
(paren
op_amp
id|request_key_conswq
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end __key_instantiate_and_link() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * instantiate a key and link it into the target keyring atomically&n; */
DECL|function|key_instantiate_and_link
r_int
id|key_instantiate_and_link
c_func
(paren
r_struct
id|key
op_star
id|key
comma
r_const
r_void
op_star
id|data
comma
r_int
id|datalen
comma
r_struct
id|key
op_star
id|keyring
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|keyring
)paren
id|down_write
c_func
(paren
op_amp
id|keyring-&gt;sem
)paren
suffix:semicolon
id|ret
op_assign
id|__key_instantiate_and_link
c_func
(paren
id|key
comma
id|data
comma
id|datalen
comma
id|keyring
)paren
suffix:semicolon
r_if
c_cond
(paren
id|keyring
)paren
id|up_write
c_func
(paren
op_amp
id|keyring-&gt;sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end key_instantiate_and_link() */
DECL|variable|key_instantiate_and_link
id|EXPORT_SYMBOL
c_func
(paren
id|key_instantiate_and_link
)paren
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * negatively instantiate a key and link it into the target keyring atomically&n; */
DECL|function|key_negate_and_link
r_int
id|key_negate_and_link
c_func
(paren
r_struct
id|key
op_star
id|key
comma
r_int
id|timeout
comma
r_struct
id|key
op_star
id|keyring
)paren
(brace
r_struct
id|timespec
id|now
suffix:semicolon
r_int
id|ret
comma
id|awaken
suffix:semicolon
id|key_check
c_func
(paren
id|key
)paren
suffix:semicolon
id|key_check
c_func
(paren
id|keyring
)paren
suffix:semicolon
id|awaken
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|keyring
)paren
id|down_write
c_func
(paren
op_amp
id|keyring-&gt;sem
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|key_construction_sem
)paren
suffix:semicolon
multiline_comment|/* can&squot;t instantiate twice */
r_if
c_cond
(paren
op_logical_neg
(paren
id|key-&gt;flags
op_amp
id|KEY_FLAG_INSTANTIATED
)paren
)paren
(brace
multiline_comment|/* mark the key as being negatively instantiated */
id|write_lock
c_func
(paren
op_amp
id|key-&gt;lock
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|key-&gt;user-&gt;nikeys
)paren
suffix:semicolon
id|key-&gt;flags
op_or_assign
id|KEY_FLAG_INSTANTIATED
op_or
id|KEY_FLAG_NEGATIVE
suffix:semicolon
id|now
op_assign
id|current_kernel_time
c_func
(paren
)paren
suffix:semicolon
id|key-&gt;expiry
op_assign
id|now.tv_sec
op_plus
id|timeout
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;flags
op_amp
id|KEY_FLAG_USER_CONSTRUCT
)paren
(brace
id|key-&gt;flags
op_and_assign
op_complement
id|KEY_FLAG_USER_CONSTRUCT
suffix:semicolon
id|awaken
op_assign
l_int|1
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|key-&gt;lock
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* and link it into the destination keyring */
r_if
c_cond
(paren
id|keyring
)paren
id|ret
op_assign
id|__key_link
c_func
(paren
id|keyring
comma
id|key
)paren
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|key_construction_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|keyring
)paren
id|up_write
c_func
(paren
op_amp
id|keyring-&gt;sem
)paren
suffix:semicolon
multiline_comment|/* wake up anyone waiting for a key to be constructed */
r_if
c_cond
(paren
id|awaken
)paren
id|wake_up_all
c_func
(paren
op_amp
id|request_key_conswq
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end key_negate_and_link() */
DECL|variable|key_negate_and_link
id|EXPORT_SYMBOL
c_func
(paren
id|key_negate_and_link
)paren
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * do cleaning up in process context so that we don&squot;t have to disable&n; * interrupts all over the place&n; */
DECL|function|key_cleanup
r_static
r_void
id|key_cleanup
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|rb_node
op_star
id|_n
suffix:semicolon
r_struct
id|key
op_star
id|key
suffix:semicolon
id|go_again
suffix:colon
multiline_comment|/* look for a dead key in the tree */
id|spin_lock
c_func
(paren
op_amp
id|key_serial_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|_n
op_assign
id|rb_first
c_func
(paren
op_amp
id|key_serial_tree
)paren
suffix:semicolon
id|_n
suffix:semicolon
id|_n
op_assign
id|rb_next
c_func
(paren
id|_n
)paren
)paren
(brace
id|key
op_assign
id|rb_entry
c_func
(paren
id|_n
comma
r_struct
id|key
comma
id|serial_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|key-&gt;usage
)paren
op_eq
l_int|0
)paren
r_goto
id|found_dead_key
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|key_serial_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
id|found_dead_key
suffix:colon
multiline_comment|/* we found a dead key - once we&squot;ve removed it from the tree, we can&n;&t; * drop the lock */
id|rb_erase
c_func
(paren
op_amp
id|key-&gt;serial_node
comma
op_amp
id|key_serial_tree
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|key_serial_lock
)paren
suffix:semicolon
multiline_comment|/* deal with the user&squot;s key tracking and quota */
r_if
c_cond
(paren
id|key-&gt;flags
op_amp
id|KEY_FLAG_IN_QUOTA
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|key-&gt;user-&gt;lock
)paren
suffix:semicolon
id|key-&gt;user-&gt;qnkeys
op_decrement
suffix:semicolon
id|key-&gt;user-&gt;qnbytes
op_sub_assign
id|key-&gt;quotalen
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|key-&gt;user-&gt;lock
)paren
suffix:semicolon
)brace
id|atomic_dec
c_func
(paren
op_amp
id|key-&gt;user-&gt;nkeys
)paren
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;flags
op_amp
id|KEY_FLAG_INSTANTIATED
)paren
id|atomic_dec
c_func
(paren
op_amp
id|key-&gt;user-&gt;nikeys
)paren
suffix:semicolon
id|key_user_put
c_func
(paren
id|key-&gt;user
)paren
suffix:semicolon
multiline_comment|/* now throw away the key memory */
r_if
c_cond
(paren
id|key-&gt;type-&gt;destroy
)paren
id|key-&gt;type
op_member_access_from_pointer
id|destroy
c_func
(paren
id|key
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|key-&gt;description
)paren
suffix:semicolon
macro_line|#ifdef KEY_DEBUGGING
id|key-&gt;magic
op_assign
id|KEY_DEBUG_MAGIC_X
suffix:semicolon
macro_line|#endif
id|kmem_cache_free
c_func
(paren
id|key_jar
comma
id|key
)paren
suffix:semicolon
multiline_comment|/* there may, of course, be more than one key to destroy */
r_goto
id|go_again
suffix:semicolon
)brace
multiline_comment|/* end key_cleanup() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * dispose of a reference to a key&n; * - when all the references are gone, we schedule the cleanup task to come and&n; *   pull it out of the tree in definite process context&n; */
DECL|function|key_put
r_void
id|key_put
c_func
(paren
r_struct
id|key
op_star
id|key
)paren
(brace
r_if
c_cond
(paren
id|key
)paren
(brace
id|key_check
c_func
(paren
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|key-&gt;usage
)paren
)paren
id|schedule_work
c_func
(paren
op_amp
id|key_cleanup_task
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end key_put() */
DECL|variable|key_put
id|EXPORT_SYMBOL
c_func
(paren
id|key_put
)paren
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * find a key by its serial number&n; */
DECL|function|key_lookup
r_struct
id|key
op_star
id|key_lookup
c_func
(paren
id|key_serial_t
id|id
)paren
(brace
r_struct
id|rb_node
op_star
id|n
suffix:semicolon
r_struct
id|key
op_star
id|key
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|key_serial_lock
)paren
suffix:semicolon
multiline_comment|/* search the tree for the specified key */
id|n
op_assign
id|key_serial_tree.rb_node
suffix:semicolon
r_while
c_loop
(paren
id|n
)paren
(brace
id|key
op_assign
id|rb_entry
c_func
(paren
id|n
comma
r_struct
id|key
comma
id|serial_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
OL
id|key-&gt;serial
)paren
id|n
op_assign
id|n-&gt;rb_left
suffix:semicolon
r_else
r_if
c_cond
(paren
id|id
OG
id|key-&gt;serial
)paren
id|n
op_assign
id|n-&gt;rb_right
suffix:semicolon
r_else
r_goto
id|found
suffix:semicolon
)brace
id|not_found
suffix:colon
id|key
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOKEY
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
id|found
suffix:colon
multiline_comment|/* pretent doesn&squot;t exist if it&squot;s dead */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|key-&gt;usage
)paren
op_eq
l_int|0
op_logical_or
(paren
id|key-&gt;flags
op_amp
id|KEY_FLAG_DEAD
)paren
op_logical_or
id|key-&gt;type
op_eq
op_amp
id|key_type_dead
)paren
r_goto
id|not_found
suffix:semicolon
multiline_comment|/* this races with key_put(), but that doesn&squot;t matter since key_put()&n;&t; * doesn&squot;t actually change the key&n;&t; */
id|atomic_inc
c_func
(paren
op_amp
id|key-&gt;usage
)paren
suffix:semicolon
id|error
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|key_serial_lock
)paren
suffix:semicolon
r_return
id|key
suffix:semicolon
)brace
multiline_comment|/* end key_lookup() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * find and lock the specified key type against removal&n; * - we return with the sem readlocked&n; */
DECL|function|key_type_lookup
r_struct
id|key_type
op_star
id|key_type_lookup
c_func
(paren
r_const
r_char
op_star
id|type
)paren
(brace
r_struct
id|key_type
op_star
id|ktype
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|key_types_sem
)paren
suffix:semicolon
multiline_comment|/* look up the key type to see if it&squot;s one of the registered kernel&n;&t; * types */
id|list_for_each_entry
c_func
(paren
id|ktype
comma
op_amp
id|key_types_list
comma
id|link
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|ktype-&gt;name
comma
id|type
)paren
op_eq
l_int|0
)paren
r_goto
id|found_kernel_type
suffix:semicolon
)brace
id|up_read
c_func
(paren
op_amp
id|key_types_sem
)paren
suffix:semicolon
id|ktype
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOKEY
)paren
suffix:semicolon
id|found_kernel_type
suffix:colon
r_return
id|ktype
suffix:semicolon
)brace
multiline_comment|/* end key_type_lookup() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * unlock a key type&n; */
DECL|function|key_type_put
r_void
id|key_type_put
c_func
(paren
r_struct
id|key_type
op_star
id|ktype
)paren
(brace
id|up_read
c_func
(paren
op_amp
id|key_types_sem
)paren
suffix:semicolon
)brace
multiline_comment|/* end key_type_put() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * attempt to update an existing key&n; * - the key has an incremented refcount&n; * - we need to put the key if we get an error&n; */
DECL|function|__key_update
r_static
r_inline
r_struct
id|key
op_star
id|__key_update
c_func
(paren
r_struct
id|key
op_star
id|key
comma
r_const
r_void
op_star
id|payload
comma
r_int
id|plen
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/* need write permission on the key to update it */
id|ret
op_assign
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|key_permission
c_func
(paren
id|key
comma
id|KEY_WRITE
)paren
)paren
r_goto
id|error
suffix:semicolon
id|ret
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|key-&gt;type-&gt;update
)paren
r_goto
id|error
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|key-&gt;sem
)paren
suffix:semicolon
id|ret
op_assign
id|key-&gt;type
op_member_access_from_pointer
id|update
c_func
(paren
id|key
comma
id|payload
comma
id|plen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
multiline_comment|/* updating a negative key instantiates it */
id|write_lock
c_func
(paren
op_amp
id|key-&gt;lock
)paren
suffix:semicolon
id|key-&gt;flags
op_and_assign
op_complement
id|KEY_FLAG_NEGATIVE
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|key-&gt;lock
)paren
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|key-&gt;sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|error
suffix:semicolon
id|out
suffix:colon
r_return
id|key
suffix:semicolon
id|error
suffix:colon
id|key_put
c_func
(paren
id|key
)paren
suffix:semicolon
id|key
op_assign
id|ERR_PTR
c_func
(paren
id|ret
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* end __key_update() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * search the specified keyring for a key of the same description; if one is&n; * found, update it, otherwise add a new one&n; */
DECL|function|key_create_or_update
r_struct
id|key
op_star
id|key_create_or_update
c_func
(paren
r_struct
id|key
op_star
id|keyring
comma
r_const
r_char
op_star
id|type
comma
r_const
r_char
op_star
id|description
comma
r_const
r_void
op_star
id|payload
comma
r_int
id|plen
comma
r_int
id|not_in_quota
)paren
(brace
r_struct
id|key_type
op_star
id|ktype
suffix:semicolon
r_struct
id|key
op_star
id|key
op_assign
l_int|NULL
suffix:semicolon
id|key_perm_t
id|perm
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|key_check
c_func
(paren
id|keyring
)paren
suffix:semicolon
multiline_comment|/* look up the key type to see if it&squot;s one of the registered kernel&n;&t; * types */
id|ktype
op_assign
id|key_type_lookup
c_func
(paren
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|ktype
)paren
)paren
(brace
id|key
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ktype-&gt;match
op_logical_or
op_logical_neg
id|ktype-&gt;instantiate
)paren
r_goto
id|error_2
suffix:semicolon
multiline_comment|/* search for an existing key of the same type and description in the&n;&t; * destination keyring&n;&t; */
id|down_write
c_func
(paren
op_amp
id|keyring-&gt;sem
)paren
suffix:semicolon
id|key
op_assign
id|__keyring_search_one
c_func
(paren
id|keyring
comma
id|ktype
comma
id|description
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|key
)paren
)paren
r_goto
id|found_matching_key
suffix:semicolon
multiline_comment|/* if we&squot;re going to allocate a new key, we&squot;re going to have to modify&n;&t; * the keyring */
id|ret
op_assign
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|key_permission
c_func
(paren
id|keyring
comma
id|KEY_WRITE
)paren
)paren
r_goto
id|error_3
suffix:semicolon
multiline_comment|/* decide on the permissions we want */
id|perm
op_assign
id|KEY_USR_VIEW
op_or
id|KEY_USR_SEARCH
op_or
id|KEY_USR_LINK
suffix:semicolon
r_if
c_cond
(paren
id|ktype-&gt;read
)paren
id|perm
op_or_assign
id|KEY_USR_READ
suffix:semicolon
r_if
c_cond
(paren
id|ktype
op_eq
op_amp
id|key_type_keyring
op_logical_or
id|ktype-&gt;update
)paren
id|perm
op_or_assign
id|KEY_USR_WRITE
suffix:semicolon
multiline_comment|/* allocate a new key */
id|key
op_assign
id|key_alloc
c_func
(paren
id|ktype
comma
id|description
comma
id|current-&gt;fsuid
comma
id|current-&gt;fsgid
comma
id|perm
comma
id|not_in_quota
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|key
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|key
)paren
suffix:semicolon
r_goto
id|error_3
suffix:semicolon
)brace
multiline_comment|/* instantiate it and link it into the target keyring */
id|ret
op_assign
id|__key_instantiate_and_link
c_func
(paren
id|key
comma
id|payload
comma
id|plen
comma
id|keyring
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|key_put
c_func
(paren
id|key
)paren
suffix:semicolon
id|key
op_assign
id|ERR_PTR
c_func
(paren
id|ret
)paren
suffix:semicolon
)brace
id|error_3
suffix:colon
id|up_write
c_func
(paren
op_amp
id|keyring-&gt;sem
)paren
suffix:semicolon
id|error_2
suffix:colon
id|key_type_put
c_func
(paren
id|ktype
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|key
suffix:semicolon
id|found_matching_key
suffix:colon
multiline_comment|/* we found a matching key, so we&squot;re going to try to update it&n;&t; * - we can drop the locks first as we have the key pinned&n;&t; */
id|up_write
c_func
(paren
op_amp
id|keyring-&gt;sem
)paren
suffix:semicolon
id|key_type_put
c_func
(paren
id|ktype
)paren
suffix:semicolon
id|key
op_assign
id|__key_update
c_func
(paren
id|key
comma
id|payload
comma
id|plen
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* end key_create_or_update() */
DECL|variable|key_create_or_update
id|EXPORT_SYMBOL
c_func
(paren
id|key_create_or_update
)paren
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * update a key&n; */
DECL|function|key_update
r_int
id|key_update
c_func
(paren
r_struct
id|key
op_star
id|key
comma
r_const
r_void
op_star
id|payload
comma
r_int
id|plen
)paren
(brace
r_int
id|ret
suffix:semicolon
id|key_check
c_func
(paren
id|key
)paren
suffix:semicolon
multiline_comment|/* the key must be writable */
id|ret
op_assign
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|key_permission
c_func
(paren
id|key
comma
id|KEY_WRITE
)paren
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* attempt to update it if supported */
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;type-&gt;update
)paren
(brace
id|down_write
c_func
(paren
op_amp
id|key-&gt;sem
)paren
suffix:semicolon
id|ret
op_assign
id|key-&gt;type
op_member_access_from_pointer
id|update
c_func
(paren
id|key
comma
id|payload
comma
id|plen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
multiline_comment|/* updating a negative key instantiates it */
id|write_lock
c_func
(paren
op_amp
id|key-&gt;lock
)paren
suffix:semicolon
id|key-&gt;flags
op_and_assign
op_complement
id|KEY_FLAG_NEGATIVE
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|key-&gt;lock
)paren
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|key-&gt;sem
)paren
suffix:semicolon
)brace
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end key_update() */
DECL|variable|key_update
id|EXPORT_SYMBOL
c_func
(paren
id|key_update
)paren
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * duplicate a key, potentially with a revised description&n; * - must be supported by the keytype (keyrings for instance can be duplicated)&n; */
DECL|function|key_duplicate
r_struct
id|key
op_star
id|key_duplicate
c_func
(paren
r_struct
id|key
op_star
id|source
comma
r_const
r_char
op_star
id|desc
)paren
(brace
r_struct
id|key
op_star
id|key
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|key_check
c_func
(paren
id|source
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|desc
)paren
id|desc
op_assign
id|source-&gt;description
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|key_types_sem
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|source-&gt;type-&gt;duplicate
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* allocate and instantiate a key */
id|key
op_assign
id|key_alloc
c_func
(paren
id|source-&gt;type
comma
id|desc
comma
id|current-&gt;fsuid
comma
id|current-&gt;fsgid
comma
id|source-&gt;perm
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|key
)paren
)paren
r_goto
id|error_k
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|source-&gt;sem
)paren
suffix:semicolon
id|ret
op_assign
id|key-&gt;type
op_member_access_from_pointer
id|duplicate
c_func
(paren
id|key
comma
id|source
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|source-&gt;sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|error2
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|key-&gt;user-&gt;nikeys
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|key-&gt;lock
)paren
suffix:semicolon
id|key-&gt;flags
op_or_assign
id|KEY_FLAG_INSTANTIATED
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|key-&gt;lock
)paren
suffix:semicolon
id|error_k
suffix:colon
id|up_read
c_func
(paren
op_amp
id|key_types_sem
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|key
suffix:semicolon
id|error2
suffix:colon
id|key_put
c_func
(paren
id|key
)paren
suffix:semicolon
id|error
suffix:colon
id|up_read
c_func
(paren
op_amp
id|key_types_sem
)paren
suffix:semicolon
id|key
op_assign
id|ERR_PTR
c_func
(paren
id|ret
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* end key_duplicate() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * revoke a key&n; */
DECL|function|key_revoke
r_void
id|key_revoke
c_func
(paren
r_struct
id|key
op_star
id|key
)paren
(brace
id|key_check
c_func
(paren
id|key
)paren
suffix:semicolon
multiline_comment|/* make sure no one&squot;s trying to change or use the key when we mark&n;&t; * it */
id|down_write
c_func
(paren
op_amp
id|key-&gt;sem
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|key-&gt;lock
)paren
suffix:semicolon
id|key-&gt;flags
op_or_assign
id|KEY_FLAG_REVOKED
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|key-&gt;lock
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|key-&gt;sem
)paren
suffix:semicolon
)brace
multiline_comment|/* end key_revoke() */
DECL|variable|key_revoke
id|EXPORT_SYMBOL
c_func
(paren
id|key_revoke
)paren
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * register a type of key&n; */
DECL|function|register_key_type
r_int
id|register_key_type
c_func
(paren
r_struct
id|key_type
op_star
id|ktype
)paren
(brace
r_struct
id|key_type
op_star
id|p
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ret
op_assign
op_minus
id|EEXIST
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|key_types_sem
)paren
suffix:semicolon
multiline_comment|/* disallow key types with the same name */
id|list_for_each_entry
c_func
(paren
id|p
comma
op_amp
id|key_types_list
comma
id|link
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|p-&gt;name
comma
id|ktype-&gt;name
)paren
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* store the type */
id|list_add
c_func
(paren
op_amp
id|ktype-&gt;link
comma
op_amp
id|key_types_list
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|up_write
c_func
(paren
op_amp
id|key_types_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end register_key_type() */
DECL|variable|register_key_type
id|EXPORT_SYMBOL
c_func
(paren
id|register_key_type
)paren
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * unregister a type of key&n; */
DECL|function|unregister_key_type
r_void
id|unregister_key_type
c_func
(paren
r_struct
id|key_type
op_star
id|ktype
)paren
(brace
r_struct
id|rb_node
op_star
id|_n
suffix:semicolon
r_struct
id|key
op_star
id|key
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|key_types_sem
)paren
suffix:semicolon
multiline_comment|/* withdraw the key type */
id|list_del_init
c_func
(paren
op_amp
id|ktype-&gt;link
)paren
suffix:semicolon
multiline_comment|/* need to withdraw all keys of this type */
id|spin_lock
c_func
(paren
op_amp
id|key_serial_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|_n
op_assign
id|rb_first
c_func
(paren
op_amp
id|key_serial_tree
)paren
suffix:semicolon
id|_n
suffix:semicolon
id|_n
op_assign
id|rb_next
c_func
(paren
id|_n
)paren
)paren
(brace
id|key
op_assign
id|rb_entry
c_func
(paren
id|_n
comma
r_struct
id|key
comma
id|serial_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;type
op_ne
id|ktype
)paren
r_continue
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|key-&gt;lock
)paren
suffix:semicolon
id|key-&gt;type
op_assign
op_amp
id|key_type_dead
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|key-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* there shouldn&squot;t be anyone looking at the description or&n;&t;&t; * payload now */
r_if
c_cond
(paren
id|ktype-&gt;destroy
)paren
id|ktype
op_member_access_from_pointer
id|destroy
c_func
(paren
id|key
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|key-&gt;payload
comma
l_int|0xbd
comma
r_sizeof
(paren
id|key-&gt;payload
)paren
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|key_serial_lock
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|key_types_sem
)paren
suffix:semicolon
)brace
multiline_comment|/* end unregister_key_type() */
DECL|variable|unregister_key_type
id|EXPORT_SYMBOL
c_func
(paren
id|unregister_key_type
)paren
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * initialise the key management stuff&n; */
DECL|function|key_init
r_void
id|__init
id|key_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* allocate a slab in which we can store keys */
id|key_jar
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;key_jar&quot;
comma
r_sizeof
(paren
r_struct
id|key
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
op_or
id|SLAB_PANIC
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* add the special key types */
id|list_add_tail
c_func
(paren
op_amp
id|key_type_keyring.link
comma
op_amp
id|key_types_list
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|key_type_dead.link
comma
op_amp
id|key_types_list
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|key_type_user.link
comma
op_amp
id|key_types_list
)paren
suffix:semicolon
multiline_comment|/* record the root user tracking */
id|rb_link_node
c_func
(paren
op_amp
id|root_key_user.node
comma
l_int|NULL
comma
op_amp
id|key_user_tree.rb_node
)paren
suffix:semicolon
id|rb_insert_color
c_func
(paren
op_amp
id|root_key_user.node
comma
op_amp
id|key_user_tree
)paren
suffix:semicolon
multiline_comment|/* record root&squot;s user standard keyrings */
id|key_check
c_func
(paren
op_amp
id|root_user_keyring
)paren
suffix:semicolon
id|key_check
c_func
(paren
op_amp
id|root_session_keyring
)paren
suffix:semicolon
id|__key_insert_serial
c_func
(paren
op_amp
id|root_user_keyring
)paren
suffix:semicolon
id|__key_insert_serial
c_func
(paren
op_amp
id|root_session_keyring
)paren
suffix:semicolon
id|keyring_publish_name
c_func
(paren
op_amp
id|root_user_keyring
)paren
suffix:semicolon
id|keyring_publish_name
c_func
(paren
op_amp
id|root_session_keyring
)paren
suffix:semicolon
multiline_comment|/* link the two root keyrings together */
id|key_link
c_func
(paren
op_amp
id|root_session_keyring
comma
op_amp
id|root_user_keyring
)paren
suffix:semicolon
)brace
multiline_comment|/* end key_init() */
eof
