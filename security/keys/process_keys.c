multiline_comment|/* process_keys.c: management of a process&squot;s keyrings&n; *&n; * Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.&n; * Written by David Howells (dhowells@redhat.com)&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/keyctl.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/err.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;internal.h&quot;
multiline_comment|/* session keyring create vs join semaphore */
r_static
id|DECLARE_MUTEX
c_func
(paren
id|key_session_sem
)paren
suffix:semicolon
multiline_comment|/* the root user&squot;s tracking struct */
DECL|variable|root_key_user
r_struct
id|key_user
id|root_key_user
op_assign
(brace
dot
id|usage
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|3
)paren
comma
dot
id|consq
op_assign
id|LIST_HEAD_INIT
c_func
(paren
id|root_key_user.consq
)paren
comma
dot
id|lock
op_assign
id|SPIN_LOCK_UNLOCKED
comma
dot
id|nkeys
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|2
)paren
comma
dot
id|nikeys
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|2
)paren
comma
dot
id|uid
op_assign
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* the root user&squot;s UID keyring */
DECL|variable|root_user_keyring
r_struct
id|key
id|root_user_keyring
op_assign
(brace
dot
id|usage
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|1
)paren
comma
dot
id|serial
op_assign
l_int|2
comma
dot
id|type
op_assign
op_amp
id|key_type_keyring
comma
dot
id|user
op_assign
op_amp
id|root_key_user
comma
dot
id|lock
op_assign
id|RW_LOCK_UNLOCKED
comma
dot
id|sem
op_assign
id|__RWSEM_INITIALIZER
c_func
(paren
id|root_user_keyring.sem
)paren
comma
dot
id|perm
op_assign
id|KEY_USR_ALL
comma
dot
id|flags
op_assign
id|KEY_FLAG_INSTANTIATED
comma
dot
id|description
op_assign
l_string|&quot;_uid.0&quot;
comma
macro_line|#ifdef KEY_DEBUGGING
dot
id|magic
op_assign
id|KEY_DEBUG_MAGIC
comma
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/* the root user&squot;s default session keyring */
DECL|variable|root_session_keyring
r_struct
id|key
id|root_session_keyring
op_assign
(brace
dot
id|usage
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|1
)paren
comma
dot
id|serial
op_assign
l_int|1
comma
dot
id|type
op_assign
op_amp
id|key_type_keyring
comma
dot
id|user
op_assign
op_amp
id|root_key_user
comma
dot
id|lock
op_assign
id|RW_LOCK_UNLOCKED
comma
dot
id|sem
op_assign
id|__RWSEM_INITIALIZER
c_func
(paren
id|root_session_keyring.sem
)paren
comma
dot
id|perm
op_assign
id|KEY_USR_ALL
comma
dot
id|flags
op_assign
id|KEY_FLAG_INSTANTIATED
comma
dot
id|description
op_assign
l_string|&quot;_uid_ses.0&quot;
comma
macro_line|#ifdef KEY_DEBUGGING
dot
id|magic
op_assign
id|KEY_DEBUG_MAGIC
comma
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * allocate the keyrings to be associated with a UID&n; */
DECL|function|alloc_uid_keyring
r_int
id|alloc_uid_keyring
c_func
(paren
r_struct
id|user_struct
op_star
id|user
)paren
(brace
r_struct
id|key
op_star
id|uid_keyring
comma
op_star
id|session_keyring
suffix:semicolon
r_char
id|buf
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* concoct a default session keyring */
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;_uid_ses.%u&quot;
comma
id|user-&gt;uid
)paren
suffix:semicolon
id|session_keyring
op_assign
id|keyring_alloc
c_func
(paren
id|buf
comma
id|user-&gt;uid
comma
(paren
id|gid_t
)paren
op_minus
l_int|1
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|session_keyring
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|session_keyring
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* and a UID specific keyring, pointed to by the default session&n;&t; * keyring */
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;_uid.%u&quot;
comma
id|user-&gt;uid
)paren
suffix:semicolon
id|uid_keyring
op_assign
id|keyring_alloc
c_func
(paren
id|buf
comma
id|user-&gt;uid
comma
(paren
id|gid_t
)paren
op_minus
l_int|1
comma
l_int|0
comma
id|session_keyring
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|uid_keyring
)paren
)paren
(brace
id|key_put
c_func
(paren
id|session_keyring
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|uid_keyring
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* install the keyrings */
id|user-&gt;uid_keyring
op_assign
id|uid_keyring
suffix:semicolon
id|user-&gt;session_keyring
op_assign
id|session_keyring
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end alloc_uid_keyring() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * deal with the UID changing&n; */
DECL|function|switch_uid_keyring
r_void
id|switch_uid_keyring
c_func
(paren
r_struct
id|user_struct
op_star
id|new_user
)paren
(brace
macro_line|#if 0 /* do nothing for now */
r_struct
id|key
op_star
id|old
suffix:semicolon
multiline_comment|/* switch to the new user&squot;s session keyring if we were running under&n;&t; * root&squot;s default session keyring */
r_if
c_cond
(paren
id|new_user-&gt;uid
op_ne
l_int|0
op_logical_and
id|current-&gt;session_keyring
op_eq
op_amp
id|root_session_keyring
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|new_user-&gt;session_keyring-&gt;usage
)paren
suffix:semicolon
id|task_lock
c_func
(paren
id|current
)paren
suffix:semicolon
id|old
op_assign
id|current-&gt;session_keyring
suffix:semicolon
id|current-&gt;session_keyring
op_assign
id|new_user-&gt;session_keyring
suffix:semicolon
id|task_unlock
c_func
(paren
id|current
)paren
suffix:semicolon
id|key_put
c_func
(paren
id|old
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/* end switch_uid_keyring() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * install a fresh thread keyring, discarding the old one&n; */
DECL|function|install_thread_keyring
r_int
id|install_thread_keyring
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_struct
id|key
op_star
id|keyring
comma
op_star
id|old
suffix:semicolon
r_char
id|buf
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;_tid.%u&quot;
comma
id|tsk-&gt;pid
)paren
suffix:semicolon
id|keyring
op_assign
id|keyring_alloc
c_func
(paren
id|buf
comma
id|tsk-&gt;uid
comma
id|tsk-&gt;gid
comma
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|keyring
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|keyring
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|task_lock
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|old
op_assign
id|tsk-&gt;thread_keyring
suffix:semicolon
id|tsk-&gt;thread_keyring
op_assign
id|keyring
suffix:semicolon
id|task_unlock
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|key_put
c_func
(paren
id|old
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end install_thread_keyring() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * install a fresh process keyring, discarding the old one&n; */
DECL|function|install_process_keyring
r_static
r_int
id|install_process_keyring
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_struct
id|key
op_star
id|keyring
comma
op_star
id|old
suffix:semicolon
r_char
id|buf
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;_pid.%u&quot;
comma
id|tsk-&gt;tgid
)paren
suffix:semicolon
id|keyring
op_assign
id|keyring_alloc
c_func
(paren
id|buf
comma
id|tsk-&gt;uid
comma
id|tsk-&gt;gid
comma
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|keyring
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|keyring
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|task_lock
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|old
op_assign
id|tsk-&gt;process_keyring
suffix:semicolon
id|tsk-&gt;process_keyring
op_assign
id|keyring
suffix:semicolon
id|task_unlock
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|key_put
c_func
(paren
id|old
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end install_process_keyring() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * install a session keyring, discarding the old one&n; * - if a keyring is not supplied, an empty one is invented&n; */
DECL|function|install_session_keyring
r_static
r_int
id|install_session_keyring
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_struct
id|key
op_star
id|keyring
)paren
(brace
r_struct
id|key
op_star
id|old
suffix:semicolon
r_char
id|buf
(braket
l_int|20
)braket
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* create an empty session keyring */
r_if
c_cond
(paren
op_logical_neg
id|keyring
)paren
(brace
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;_ses.%u&quot;
comma
id|tsk-&gt;tgid
)paren
suffix:semicolon
id|keyring
op_assign
id|keyring_alloc
c_func
(paren
id|buf
comma
id|tsk-&gt;uid
comma
id|tsk-&gt;gid
comma
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|keyring
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|keyring
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
)brace
r_else
(brace
id|atomic_inc
c_func
(paren
op_amp
id|keyring-&gt;usage
)paren
suffix:semicolon
)brace
multiline_comment|/* install the keyring */
id|task_lock
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|old
op_assign
id|tsk-&gt;session_keyring
suffix:semicolon
id|tsk-&gt;session_keyring
op_assign
id|keyring
suffix:semicolon
id|task_unlock
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|key_put
c_func
(paren
id|old
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end install_session_keyring() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * copy the keys for fork&n; */
DECL|function|copy_keys
r_int
id|copy_keys
c_func
(paren
r_int
r_int
id|clone_flags
comma
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|key_check
c_func
(paren
id|tsk-&gt;session_keyring
)paren
suffix:semicolon
id|key_check
c_func
(paren
id|tsk-&gt;process_keyring
)paren
suffix:semicolon
id|key_check
c_func
(paren
id|tsk-&gt;thread_keyring
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tsk-&gt;session_keyring
)paren
id|atomic_inc
c_func
(paren
op_amp
id|tsk-&gt;session_keyring-&gt;usage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tsk-&gt;process_keyring
)paren
(brace
r_if
c_cond
(paren
id|clone_flags
op_amp
id|CLONE_THREAD
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|tsk-&gt;process_keyring-&gt;usage
)paren
suffix:semicolon
)brace
r_else
(brace
id|tsk-&gt;process_keyring
op_assign
l_int|NULL
suffix:semicolon
id|ret
op_assign
id|install_process_keyring
c_func
(paren
id|tsk
)paren
suffix:semicolon
)brace
)brace
id|tsk-&gt;thread_keyring
op_assign
l_int|NULL
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end copy_keys() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * dispose of keys upon exit&n; */
DECL|function|exit_keys
r_void
id|exit_keys
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
id|key_put
c_func
(paren
id|tsk-&gt;session_keyring
)paren
suffix:semicolon
id|key_put
c_func
(paren
id|tsk-&gt;process_keyring
)paren
suffix:semicolon
id|key_put
c_func
(paren
id|tsk-&gt;thread_keyring
)paren
suffix:semicolon
)brace
multiline_comment|/* end exit_keys() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * deal with execve()&n; */
DECL|function|exec_keys
r_int
id|exec_keys
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_struct
id|key
op_star
id|old
suffix:semicolon
multiline_comment|/* newly exec&squot;d tasks don&squot;t get a thread keyring */
id|task_lock
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|old
op_assign
id|tsk-&gt;thread_keyring
suffix:semicolon
id|tsk-&gt;thread_keyring
op_assign
l_int|NULL
suffix:semicolon
id|task_unlock
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|key_put
c_func
(paren
id|old
)paren
suffix:semicolon
multiline_comment|/* newly exec&squot;d tasks get a fresh process keyring */
r_return
id|install_process_keyring
c_func
(paren
id|tsk
)paren
suffix:semicolon
)brace
multiline_comment|/* end exec_keys() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * deal with SUID programs&n; * - we might want to make this invent a new session keyring&n; */
DECL|function|suid_keys
r_int
id|suid_keys
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end suid_keys() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * the filesystem user ID changed&n; */
DECL|function|key_fsuid_changed
r_void
id|key_fsuid_changed
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
multiline_comment|/* update the ownership of the process keyring */
r_if
c_cond
(paren
id|tsk-&gt;process_keyring
)paren
(brace
id|down_write
c_func
(paren
op_amp
id|tsk-&gt;process_keyring-&gt;sem
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|tsk-&gt;process_keyring-&gt;lock
)paren
suffix:semicolon
id|tsk-&gt;process_keyring-&gt;uid
op_assign
id|tsk-&gt;fsuid
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|tsk-&gt;process_keyring-&gt;lock
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|tsk-&gt;process_keyring-&gt;sem
)paren
suffix:semicolon
)brace
multiline_comment|/* update the ownership of the thread keyring */
r_if
c_cond
(paren
id|tsk-&gt;thread_keyring
)paren
(brace
id|down_write
c_func
(paren
op_amp
id|tsk-&gt;thread_keyring-&gt;sem
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|tsk-&gt;thread_keyring-&gt;lock
)paren
suffix:semicolon
id|tsk-&gt;thread_keyring-&gt;uid
op_assign
id|tsk-&gt;fsuid
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|tsk-&gt;thread_keyring-&gt;lock
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|tsk-&gt;thread_keyring-&gt;sem
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end key_fsuid_changed() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * the filesystem group ID changed&n; */
DECL|function|key_fsgid_changed
r_void
id|key_fsgid_changed
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
multiline_comment|/* update the ownership of the process keyring */
r_if
c_cond
(paren
id|tsk-&gt;process_keyring
)paren
(brace
id|down_write
c_func
(paren
op_amp
id|tsk-&gt;process_keyring-&gt;sem
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|tsk-&gt;process_keyring-&gt;lock
)paren
suffix:semicolon
id|tsk-&gt;process_keyring-&gt;gid
op_assign
id|tsk-&gt;fsgid
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|tsk-&gt;process_keyring-&gt;lock
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|tsk-&gt;process_keyring-&gt;sem
)paren
suffix:semicolon
)brace
multiline_comment|/* update the ownership of the thread keyring */
r_if
c_cond
(paren
id|tsk-&gt;thread_keyring
)paren
(brace
id|down_write
c_func
(paren
op_amp
id|tsk-&gt;thread_keyring-&gt;sem
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|tsk-&gt;thread_keyring-&gt;lock
)paren
suffix:semicolon
id|tsk-&gt;thread_keyring-&gt;gid
op_assign
id|tsk-&gt;fsgid
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|tsk-&gt;thread_keyring-&gt;lock
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|tsk-&gt;thread_keyring-&gt;sem
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end key_fsgid_changed() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * search the process keyrings for the first matching key&n; * - we use the supplied match function to see if the description (or other&n; *   feature of interest) matches&n; * - we return -EAGAIN if we didn&squot;t find any matching key&n; * - we return -ENOKEY if we found only negative matching keys&n; */
DECL|function|search_process_keyrings_aux
r_struct
id|key
op_star
id|search_process_keyrings_aux
c_func
(paren
r_struct
id|key_type
op_star
id|type
comma
r_const
r_void
op_star
id|description
comma
id|key_match_func_t
id|match
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
r_struct
id|key
op_star
id|key
comma
op_star
id|ret
comma
op_star
id|err
comma
op_star
id|session
suffix:semicolon
multiline_comment|/* we want to return -EAGAIN or -ENOKEY if any of the keyrings were&n;&t; * searchable, but we failed to find a key or we found a negative key;&n;&t; * otherwise we want to return a sample error (probably -EACCES) if&n;&t; * none of the keyrings were searchable&n;&t; *&n;&t; * in terms of priority: success &gt; -ENOKEY &gt; -EAGAIN &gt; other error&n;&t; */
id|key
op_assign
l_int|NULL
suffix:semicolon
id|ret
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
multiline_comment|/* search the thread keyring first */
r_if
c_cond
(paren
id|tsk-&gt;thread_keyring
)paren
(brace
id|key
op_assign
id|keyring_search_aux
c_func
(paren
id|tsk-&gt;thread_keyring
comma
id|type
comma
id|description
comma
id|match
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|key
)paren
)paren
r_goto
id|found
suffix:semicolon
r_switch
c_cond
(paren
id|PTR_ERR
c_func
(paren
id|key
)paren
)paren
(brace
r_case
op_minus
id|EAGAIN
suffix:colon
multiline_comment|/* no key */
r_if
c_cond
(paren
id|ret
)paren
r_break
suffix:semicolon
r_case
op_minus
id|ENOKEY
suffix:colon
multiline_comment|/* negative key */
id|ret
op_assign
id|key
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
id|key
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* search the process keyring second */
r_if
c_cond
(paren
id|tsk-&gt;process_keyring
)paren
(brace
id|key
op_assign
id|keyring_search_aux
c_func
(paren
id|tsk-&gt;process_keyring
comma
id|type
comma
id|description
comma
id|match
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|key
)paren
)paren
r_goto
id|found
suffix:semicolon
r_switch
c_cond
(paren
id|PTR_ERR
c_func
(paren
id|key
)paren
)paren
(brace
r_case
op_minus
id|EAGAIN
suffix:colon
multiline_comment|/* no key */
r_if
c_cond
(paren
id|ret
)paren
r_break
suffix:semicolon
r_case
op_minus
id|ENOKEY
suffix:colon
multiline_comment|/* negative key */
id|ret
op_assign
id|key
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
id|key
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* search the session keyring last */
id|session
op_assign
id|tsk-&gt;session_keyring
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|session
)paren
id|session
op_assign
id|tsk-&gt;user-&gt;session_keyring
suffix:semicolon
id|key
op_assign
id|keyring_search_aux
c_func
(paren
id|session
comma
id|type
comma
id|description
comma
id|match
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|key
)paren
)paren
r_goto
id|found
suffix:semicolon
r_switch
c_cond
(paren
id|PTR_ERR
c_func
(paren
id|key
)paren
)paren
(brace
r_case
op_minus
id|EAGAIN
suffix:colon
multiline_comment|/* no key */
r_if
c_cond
(paren
id|ret
)paren
r_break
suffix:semicolon
r_case
op_minus
id|ENOKEY
suffix:colon
multiline_comment|/* negative key */
id|ret
op_assign
id|key
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
id|key
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* no key - decide on the error we&squot;re going to go for */
id|key
op_assign
id|ret
ques
c_cond
id|ret
suffix:colon
id|err
suffix:semicolon
id|found
suffix:colon
r_return
id|key
suffix:semicolon
)brace
multiline_comment|/* end search_process_keyrings_aux() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * search the process keyrings for the first matching key&n; * - we return -EAGAIN if we didn&squot;t find any matching key&n; * - we return -ENOKEY if we found only negative matching keys&n; */
DECL|function|search_process_keyrings
r_struct
id|key
op_star
id|search_process_keyrings
c_func
(paren
r_struct
id|key_type
op_star
id|type
comma
r_const
r_char
op_star
id|description
)paren
(brace
r_return
id|search_process_keyrings_aux
c_func
(paren
id|type
comma
id|description
comma
id|type-&gt;match
)paren
suffix:semicolon
)brace
multiline_comment|/* end search_process_keyrings() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * lookup a key given a key ID from userspace with a given permissions mask&n; * - don&squot;t create special keyrings unless so requested&n; * - partially constructed keys aren&squot;t found unless requested&n; */
DECL|function|lookup_user_key
r_struct
id|key
op_star
id|lookup_user_key
c_func
(paren
id|key_serial_t
id|id
comma
r_int
id|create
comma
r_int
id|partial
comma
id|key_perm_t
id|perm
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
r_struct
id|key
op_star
id|key
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|key
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOKEY
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|id
)paren
(brace
r_case
id|KEY_SPEC_THREAD_KEYRING
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|tsk-&gt;thread_keyring
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|create
)paren
r_goto
id|error
suffix:semicolon
id|ret
op_assign
id|install_thread_keyring
c_func
(paren
id|tsk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|key
op_assign
id|ERR_PTR
c_func
(paren
id|ret
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
)brace
id|key
op_assign
id|tsk-&gt;thread_keyring
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|key-&gt;usage
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KEY_SPEC_PROCESS_KEYRING
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|tsk-&gt;process_keyring
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|create
)paren
r_goto
id|error
suffix:semicolon
id|ret
op_assign
id|install_process_keyring
c_func
(paren
id|tsk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|key
op_assign
id|ERR_PTR
c_func
(paren
id|ret
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
)brace
id|key
op_assign
id|tsk-&gt;process_keyring
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|key-&gt;usage
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KEY_SPEC_SESSION_KEYRING
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|tsk-&gt;session_keyring
)paren
(brace
multiline_comment|/* always install a session keyring upon access if one&n;&t;&t;&t; * doesn&squot;t exist yet */
id|ret
op_assign
id|install_session_keyring
c_func
(paren
id|tsk
comma
id|tsk-&gt;user-&gt;session_keyring
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|error
suffix:semicolon
)brace
id|key
op_assign
id|tsk-&gt;session_keyring
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|key-&gt;usage
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KEY_SPEC_USER_KEYRING
suffix:colon
id|key
op_assign
id|tsk-&gt;user-&gt;uid_keyring
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|key-&gt;usage
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KEY_SPEC_USER_SESSION_KEYRING
suffix:colon
id|key
op_assign
id|tsk-&gt;user-&gt;session_keyring
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|key-&gt;usage
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KEY_SPEC_GROUP_KEYRING
suffix:colon
multiline_comment|/* group keyrings are not yet supported */
id|key
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
r_default
suffix:colon
id|key
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
OL
l_int|1
)paren
r_goto
id|error
suffix:semicolon
id|key
op_assign
id|key_lookup
c_func
(paren
id|id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|key
)paren
)paren
r_goto
id|error
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* check the status and permissions */
r_if
c_cond
(paren
id|perm
)paren
(brace
id|ret
op_assign
id|key_validate
c_func
(paren
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|invalid_key
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|partial
op_logical_and
op_logical_neg
(paren
id|key-&gt;flags
op_amp
id|KEY_FLAG_INSTANTIATED
)paren
)paren
r_goto
id|invalid_key
suffix:semicolon
id|ret
op_assign
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|key_permission
c_func
(paren
id|key
comma
id|perm
)paren
)paren
r_goto
id|invalid_key
suffix:semicolon
id|error
suffix:colon
r_return
id|key
suffix:semicolon
id|invalid_key
suffix:colon
id|key_put
c_func
(paren
id|key
)paren
suffix:semicolon
id|key
op_assign
id|ERR_PTR
c_func
(paren
id|ret
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* end lookup_user_key() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * join the named keyring as the session keyring if possible, or attempt to&n; * create a new one of that name if not&n; * - if the name is NULL, an empty anonymous keyring is installed instead&n; * - named session keyring joining is done with a semaphore held&n; */
DECL|function|join_session_keyring
r_int
id|join_session_keyring
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
r_struct
id|key
op_star
id|keyring
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* if no name is provided, install an anonymous keyring */
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
id|ret
op_assign
id|install_session_keyring
c_func
(paren
id|tsk
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|error
suffix:semicolon
id|ret
op_assign
id|tsk-&gt;session_keyring-&gt;serial
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* allow the user to join or create a named keyring */
id|down
c_func
(paren
op_amp
id|key_session_sem
)paren
suffix:semicolon
multiline_comment|/* look for an existing keyring of this name */
id|keyring
op_assign
id|find_keyring_by_name
c_func
(paren
id|name
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PTR_ERR
c_func
(paren
id|keyring
)paren
op_eq
op_minus
id|ENOKEY
)paren
(brace
multiline_comment|/* not found - try and create a new one */
id|keyring
op_assign
id|keyring_alloc
c_func
(paren
id|name
comma
id|tsk-&gt;uid
comma
id|tsk-&gt;gid
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|keyring
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|keyring
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|keyring
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|keyring
)paren
suffix:semicolon
r_goto
id|error2
suffix:semicolon
)brace
multiline_comment|/* we&squot;ve got a keyring - now to install it */
id|ret
op_assign
id|install_session_keyring
c_func
(paren
id|tsk
comma
id|keyring
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|error2
suffix:semicolon
id|key_put
c_func
(paren
id|keyring
)paren
suffix:semicolon
id|ret
op_assign
id|tsk-&gt;session_keyring-&gt;serial
suffix:semicolon
id|error2
suffix:colon
id|up
c_func
(paren
op_amp
id|key_session_sem
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end join_session_keyring() */
eof
