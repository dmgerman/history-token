multiline_comment|/* request_key.c: request a key from userspace&n; *&n; * Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.&n; * Written by David Howells (dhowells@redhat.com)&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/err.h&gt;
macro_line|#include &quot;internal.h&quot;
DECL|struct|key_construction
r_struct
id|key_construction
(brace
DECL|member|link
r_struct
id|list_head
id|link
suffix:semicolon
multiline_comment|/* link in construction queue */
DECL|member|key
r_struct
id|key
op_star
id|key
suffix:semicolon
multiline_comment|/* key being constructed */
)brace
suffix:semicolon
multiline_comment|/* when waiting for someone else&squot;s keys, you get added to this */
DECL|variable|request_key_conswq
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|request_key_conswq
)paren
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * request userspace finish the construction of a key&n; * - execute &quot;/sbin/request-key &lt;op&gt; &lt;key&gt; &lt;uid&gt; &lt;gid&gt; &lt;keyring&gt; &lt;keyring&gt; &lt;keyring&gt; &lt;info&gt;&quot;&n; * - if callout_info is an empty string, it&squot;ll be rendered as a &quot;-&quot; instead&n; */
DECL|function|call_request_key
r_static
r_int
id|call_request_key
c_func
(paren
r_struct
id|key
op_star
id|key
comma
r_const
r_char
op_star
id|op
comma
r_const
r_char
op_star
id|callout_info
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
r_char
op_star
id|argv
(braket
l_int|10
)braket
comma
op_star
id|envp
(braket
l_int|3
)braket
comma
id|uid_str
(braket
l_int|12
)braket
comma
id|gid_str
(braket
l_int|12
)braket
suffix:semicolon
r_char
id|key_str
(braket
l_int|12
)braket
comma
id|keyring_str
(braket
l_int|3
)braket
(braket
l_int|12
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* record the UID and GID */
id|sprintf
c_func
(paren
id|uid_str
comma
l_string|&quot;%d&quot;
comma
id|current-&gt;fsuid
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|gid_str
comma
l_string|&quot;%d&quot;
comma
id|current-&gt;fsgid
)paren
suffix:semicolon
multiline_comment|/* we say which key is under construction */
id|sprintf
c_func
(paren
id|key_str
comma
l_string|&quot;%d&quot;
comma
id|key-&gt;serial
)paren
suffix:semicolon
multiline_comment|/* we specify the process&squot;s default keyrings */
id|task_lock
c_func
(paren
id|current
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|keyring_str
(braket
l_int|0
)braket
comma
l_string|&quot;%d&quot;
comma
id|tsk-&gt;thread_keyring
ques
c_cond
id|tsk-&gt;thread_keyring-&gt;serial
suffix:colon
l_int|0
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|keyring_str
(braket
l_int|1
)braket
comma
l_string|&quot;%d&quot;
comma
id|tsk-&gt;process_keyring
ques
c_cond
id|tsk-&gt;process_keyring-&gt;serial
suffix:colon
l_int|0
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|keyring_str
(braket
l_int|2
)braket
comma
l_string|&quot;%d&quot;
comma
(paren
id|tsk-&gt;session_keyring
ques
c_cond
id|tsk-&gt;session_keyring-&gt;serial
suffix:colon
id|tsk-&gt;user-&gt;session_keyring-&gt;serial
)paren
)paren
suffix:semicolon
id|task_unlock
c_func
(paren
id|tsk
)paren
suffix:semicolon
multiline_comment|/* set up a minimal environment */
id|i
op_assign
l_int|0
suffix:semicolon
id|envp
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;HOME=/&quot;
suffix:semicolon
id|envp
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;PATH=/sbin:/bin:/usr/sbin:/usr/bin&quot;
suffix:semicolon
id|envp
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* set up the argument list */
id|i
op_assign
l_int|0
suffix:semicolon
id|argv
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;/sbin/request-key&quot;
suffix:semicolon
id|argv
(braket
id|i
op_increment
)braket
op_assign
(paren
r_char
op_star
)paren
id|op
suffix:semicolon
id|argv
(braket
id|i
op_increment
)braket
op_assign
id|key_str
suffix:semicolon
id|argv
(braket
id|i
op_increment
)braket
op_assign
id|uid_str
suffix:semicolon
id|argv
(braket
id|i
op_increment
)braket
op_assign
id|gid_str
suffix:semicolon
id|argv
(braket
id|i
op_increment
)braket
op_assign
id|keyring_str
(braket
l_int|0
)braket
suffix:semicolon
id|argv
(braket
id|i
op_increment
)braket
op_assign
id|keyring_str
(braket
l_int|1
)braket
suffix:semicolon
id|argv
(braket
id|i
op_increment
)braket
op_assign
id|keyring_str
(braket
l_int|2
)braket
suffix:semicolon
id|argv
(braket
id|i
op_increment
)braket
op_assign
id|callout_info
(braket
l_int|0
)braket
ques
c_cond
(paren
r_char
op_star
)paren
id|callout_info
suffix:colon
l_string|&quot;-&quot;
suffix:semicolon
id|argv
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* do it */
r_return
id|call_usermodehelper
c_func
(paren
id|argv
(braket
l_int|0
)braket
comma
id|argv
comma
id|envp
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* end call_request_key() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * call out to userspace for the key&n; * - called with the construction sem held, but the sem is dropped here&n; * - we ignore program failure and go on key status instead&n; */
DECL|function|__request_key_construction
r_static
r_struct
id|key
op_star
id|__request_key_construction
c_func
(paren
r_struct
id|key_type
op_star
id|type
comma
r_const
r_char
op_star
id|description
comma
r_const
r_char
op_star
id|callout_info
)paren
(brace
r_struct
id|key_construction
id|cons
suffix:semicolon
r_struct
id|timespec
id|now
suffix:semicolon
r_struct
id|key
op_star
id|key
suffix:semicolon
r_int
id|ret
comma
id|negative
suffix:semicolon
multiline_comment|/* create a key and add it to the queue */
id|key
op_assign
id|key_alloc
c_func
(paren
id|type
comma
id|description
comma
id|current-&gt;fsuid
comma
id|current-&gt;fsgid
comma
id|KEY_USR_ALL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|key
)paren
)paren
r_goto
id|alloc_failed
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|key-&gt;lock
)paren
suffix:semicolon
id|key-&gt;flags
op_or_assign
id|KEY_FLAG_USER_CONSTRUCT
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|key-&gt;lock
)paren
suffix:semicolon
id|cons.key
op_assign
id|key
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|cons.link
comma
op_amp
id|key-&gt;user-&gt;consq
)paren
suffix:semicolon
multiline_comment|/* we drop the construction sem here on behalf of the caller */
id|up_write
c_func
(paren
op_amp
id|key_construction_sem
)paren
suffix:semicolon
multiline_comment|/* make the call */
id|ret
op_assign
id|call_request_key
c_func
(paren
id|key
comma
l_string|&quot;create&quot;
comma
id|callout_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|request_failed
suffix:semicolon
multiline_comment|/* if the key wasn&squot;t instantiated, then we want to give an error */
id|ret
op_assign
op_minus
id|ENOKEY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|key-&gt;flags
op_amp
id|KEY_FLAG_INSTANTIATED
)paren
)paren
r_goto
id|request_failed
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|key_construction_sem
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|cons.link
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|key_construction_sem
)paren
suffix:semicolon
multiline_comment|/* also give an error if the key was negatively instantiated */
id|check_not_negative
suffix:colon
r_if
c_cond
(paren
id|key-&gt;flags
op_amp
id|KEY_FLAG_NEGATIVE
)paren
(brace
id|key_put
c_func
(paren
id|key
)paren
suffix:semicolon
id|key
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOKEY
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|key
suffix:semicolon
id|request_failed
suffix:colon
multiline_comment|/* it wasn&squot;t instantiated&n;&t; * - remove from construction queue&n;&t; * - mark the key as dead&n;&t; */
id|negative
op_assign
l_int|0
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|key_construction_sem
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|cons.link
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|key-&gt;lock
)paren
suffix:semicolon
id|key-&gt;flags
op_and_assign
op_complement
id|KEY_FLAG_USER_CONSTRUCT
suffix:semicolon
multiline_comment|/* check it didn&squot;t get instantiated between the check and the down */
r_if
c_cond
(paren
op_logical_neg
(paren
id|key-&gt;flags
op_amp
id|KEY_FLAG_INSTANTIATED
)paren
)paren
(brace
id|key-&gt;flags
op_or_assign
id|KEY_FLAG_INSTANTIATED
op_or
id|KEY_FLAG_NEGATIVE
suffix:semicolon
id|negative
op_assign
l_int|1
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|key-&gt;lock
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|key_construction_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|negative
)paren
r_goto
id|check_not_negative
suffix:semicolon
multiline_comment|/* surprisingly, the key got&n;&t;&t;&t;&t;&t;  * instantiated */
multiline_comment|/* set the timeout and store in the session keyring if we can */
id|now
op_assign
id|current_kernel_time
c_func
(paren
)paren
suffix:semicolon
id|key-&gt;expiry
op_assign
id|now.tv_sec
op_plus
id|key_negative_timeout
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;session_keyring
)paren
id|key_link
c_func
(paren
id|current-&gt;session_keyring
comma
id|key
)paren
suffix:semicolon
id|key_put
c_func
(paren
id|key
)paren
suffix:semicolon
multiline_comment|/* notify anyone who was waiting */
id|wake_up_all
c_func
(paren
op_amp
id|request_key_conswq
)paren
suffix:semicolon
id|key
op_assign
id|ERR_PTR
c_func
(paren
id|ret
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|alloc_failed
suffix:colon
id|up_write
c_func
(paren
op_amp
id|key_construction_sem
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* end __request_key_construction() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * call out to userspace to request the key&n; * - we check the construction queue first to see if an appropriate key is&n; *   already being constructed by userspace&n; */
DECL|function|request_key_construction
r_static
r_struct
id|key
op_star
id|request_key_construction
c_func
(paren
r_struct
id|key_type
op_star
id|type
comma
r_const
r_char
op_star
id|description
comma
r_struct
id|key_user
op_star
id|user
comma
r_const
r_char
op_star
id|callout_info
)paren
(brace
r_struct
id|key_construction
op_star
id|pcons
suffix:semicolon
r_struct
id|key
op_star
id|key
comma
op_star
id|ckey
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|myself
comma
id|current
)paren
suffix:semicolon
multiline_comment|/* see if there&squot;s such a key under construction already */
id|down_write
c_func
(paren
op_amp
id|key_construction_sem
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|pcons
comma
op_amp
id|user-&gt;consq
comma
id|link
)paren
(brace
id|ckey
op_assign
id|pcons-&gt;key
suffix:semicolon
r_if
c_cond
(paren
id|ckey-&gt;type
op_ne
id|type
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|type
op_member_access_from_pointer
id|match
c_func
(paren
id|ckey
comma
id|description
)paren
)paren
r_goto
id|found_key_under_construction
suffix:semicolon
)brace
multiline_comment|/* see about getting userspace to construct the key */
id|key
op_assign
id|__request_key_construction
c_func
(paren
id|type
comma
id|description
comma
id|callout_info
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|key
suffix:semicolon
multiline_comment|/* someone else has the same key under construction&n;&t; * - we want to keep an eye on their key&n;&t; */
id|found_key_under_construction
suffix:colon
id|atomic_inc
c_func
(paren
op_amp
id|ckey-&gt;usage
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|key_construction_sem
)paren
suffix:semicolon
multiline_comment|/* wait for the key to be completed one way or another */
id|add_wait_queue
c_func
(paren
op_amp
id|request_key_conswq
comma
op_amp
id|myself
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ckey-&gt;flags
op_amp
id|KEY_FLAG_USER_CONSTRUCT
)paren
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|request_key_conswq
comma
op_amp
id|myself
)paren
suffix:semicolon
multiline_comment|/* we&squot;ll need to search this process&squot;s keyrings to see if the key is&n;&t; * now there since we can&squot;t automatically assume it&squot;s also available&n;&t; * there */
id|key_put
c_func
(paren
id|ckey
)paren
suffix:semicolon
id|ckey
op_assign
l_int|NULL
suffix:semicolon
id|key
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* request a retry */
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* end request_key_construction() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * request a key&n; * - search the process&squot;s keyrings&n; * - check the list of keys being created or updated&n; * - call out to userspace for a key if requested (supplementary info can be&n; *   passed)&n; */
DECL|function|request_key
r_struct
id|key
op_star
id|request_key
c_func
(paren
r_struct
id|key_type
op_star
id|type
comma
r_const
r_char
op_star
id|description
comma
r_const
r_char
op_star
id|callout_info
)paren
(brace
r_struct
id|key_user
op_star
id|user
suffix:semicolon
r_struct
id|key
op_star
id|key
suffix:semicolon
multiline_comment|/* search all the process keyrings for a key */
id|key
op_assign
id|search_process_keyrings_aux
c_func
(paren
id|type
comma
id|description
comma
id|type-&gt;match
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PTR_ERR
c_func
(paren
id|key
)paren
op_eq
op_minus
id|EAGAIN
)paren
(brace
multiline_comment|/* the search failed, but the keyrings were searchable, so we&n;&t;&t; * should consult userspace if we can */
id|key
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOKEY
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|callout_info
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* - get hold of the user&squot;s construction queue */
id|user
op_assign
id|key_user_lookup
c_func
(paren
id|current-&gt;fsuid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|user
)paren
)paren
(brace
id|key
op_assign
id|ERR_PTR
c_func
(paren
id|PTR_ERR
c_func
(paren
id|user
)paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* ask userspace (returns NULL if it waited on a key&n;&t;&t;&t; * being constructed) */
id|key
op_assign
id|request_key_construction
c_func
(paren
id|type
comma
id|description
comma
id|user
comma
id|callout_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|key
)paren
r_break
suffix:semicolon
multiline_comment|/* someone else made the key we want, so we need to&n;&t;&t;&t; * search again as it might now be available to us */
id|key
op_assign
id|search_process_keyrings_aux
c_func
(paren
id|type
comma
id|description
comma
id|type-&gt;match
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PTR_ERR
c_func
(paren
id|key
)paren
op_ne
op_minus
id|EAGAIN
)paren
r_break
suffix:semicolon
)brace
id|key_user_put
c_func
(paren
id|user
)paren
suffix:semicolon
)brace
id|error
suffix:colon
r_return
id|key
suffix:semicolon
)brace
multiline_comment|/* end request_key() */
DECL|variable|request_key
id|EXPORT_SYMBOL
c_func
(paren
id|request_key
)paren
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * validate a key&n; */
DECL|function|key_validate
r_int
id|key_validate
c_func
(paren
r_struct
id|key
op_star
id|key
)paren
(brace
r_struct
id|timespec
id|now
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|key
)paren
(brace
multiline_comment|/* check it&squot;s still accessible */
id|ret
op_assign
op_minus
id|EKEYREVOKED
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;flags
op_amp
(paren
id|KEY_FLAG_REVOKED
op_or
id|KEY_FLAG_DEAD
)paren
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* check it hasn&squot;t expired */
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;expiry
)paren
(brace
id|now
op_assign
id|current_kernel_time
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|now.tv_sec
op_ge
id|key-&gt;expiry
)paren
id|ret
op_assign
op_minus
id|EKEYEXPIRED
suffix:semicolon
)brace
)brace
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end key_validate() */
DECL|variable|key_validate
id|EXPORT_SYMBOL
c_func
(paren
id|key_validate
)paren
suffix:semicolon
eof
