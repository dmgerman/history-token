multiline_comment|/* user_defined.c: user defined key type&n; *&n; * Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.&n; * Written by David Howells (dhowells@redhat.com)&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/err.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;internal.h&quot;
r_static
r_int
id|user_instantiate
c_func
(paren
r_struct
id|key
op_star
id|key
comma
r_const
r_void
op_star
id|data
comma
r_int
id|datalen
)paren
suffix:semicolon
r_static
r_int
id|user_duplicate
c_func
(paren
r_struct
id|key
op_star
id|key
comma
r_const
r_struct
id|key
op_star
id|source
)paren
suffix:semicolon
r_static
r_int
id|user_update
c_func
(paren
r_struct
id|key
op_star
id|key
comma
r_const
r_void
op_star
id|data
comma
r_int
id|datalen
)paren
suffix:semicolon
r_static
r_int
id|user_match
c_func
(paren
r_const
r_struct
id|key
op_star
id|key
comma
r_const
r_void
op_star
id|criterion
)paren
suffix:semicolon
r_static
r_void
id|user_destroy
c_func
(paren
r_struct
id|key
op_star
id|key
)paren
suffix:semicolon
r_static
r_void
id|user_describe
c_func
(paren
r_const
r_struct
id|key
op_star
id|user
comma
r_struct
id|seq_file
op_star
id|m
)paren
suffix:semicolon
r_static
r_int
id|user_read
c_func
(paren
r_const
r_struct
id|key
op_star
id|key
comma
r_char
id|__user
op_star
id|buffer
comma
r_int
id|buflen
)paren
suffix:semicolon
multiline_comment|/*&n; * user defined keys take an arbitrary string as the description and an&n; * arbitrary blob of data as the payload&n; */
DECL|variable|key_type_user
r_struct
id|key_type
id|key_type_user
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;user&quot;
comma
dot
id|instantiate
op_assign
id|user_instantiate
comma
dot
id|duplicate
op_assign
id|user_duplicate
comma
dot
id|update
op_assign
id|user_update
comma
dot
id|match
op_assign
id|user_match
comma
dot
id|destroy
op_assign
id|user_destroy
comma
dot
id|describe
op_assign
id|user_describe
comma
dot
id|read
op_assign
id|user_read
comma
)brace
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * instantiate a user defined key&n; */
DECL|function|user_instantiate
r_static
r_int
id|user_instantiate
c_func
(paren
r_struct
id|key
op_star
id|key
comma
r_const
r_void
op_star
id|data
comma
r_int
id|datalen
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|datalen
op_le
l_int|0
op_logical_or
id|datalen
OG
l_int|32767
op_logical_or
op_logical_neg
id|data
)paren
r_goto
id|error
suffix:semicolon
id|ret
op_assign
id|key_payload_reserve
c_func
(paren
id|key
comma
id|datalen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* attach the data */
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|key-&gt;payload.data
op_assign
id|kmalloc
c_func
(paren
id|datalen
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|key-&gt;payload.data
)paren
r_goto
id|error
suffix:semicolon
id|memcpy
c_func
(paren
id|key-&gt;payload.data
comma
id|data
comma
id|datalen
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end user_instantiate() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * duplicate a user defined key&n; */
DECL|function|user_duplicate
r_static
r_int
id|user_duplicate
c_func
(paren
r_struct
id|key
op_star
id|key
comma
r_const
r_struct
id|key
op_star
id|source
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/* just copy the payload */
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|key-&gt;payload.data
op_assign
id|kmalloc
c_func
(paren
id|source-&gt;datalen
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;payload.data
)paren
(brace
id|key-&gt;datalen
op_assign
id|source-&gt;datalen
suffix:semicolon
id|memcpy
c_func
(paren
id|key-&gt;payload.data
comma
id|source-&gt;payload.data
comma
id|source-&gt;datalen
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end user_duplicate() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * update a user defined key&n; */
DECL|function|user_update
r_static
r_int
id|user_update
c_func
(paren
r_struct
id|key
op_star
id|key
comma
r_const
r_void
op_star
id|data
comma
r_int
id|datalen
)paren
(brace
r_void
op_star
r_new
comma
op_star
id|zap
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|datalen
op_le
l_int|0
op_logical_or
id|datalen
OG
l_int|32767
op_logical_or
op_logical_neg
id|data
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* copy the data */
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_new
op_assign
id|kmalloc
c_func
(paren
id|datalen
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_goto
id|error
suffix:semicolon
id|memcpy
c_func
(paren
r_new
comma
id|data
comma
id|datalen
)paren
suffix:semicolon
multiline_comment|/* check the quota and attach the new data */
id|zap
op_assign
r_new
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|key-&gt;lock
)paren
suffix:semicolon
id|ret
op_assign
id|key_payload_reserve
c_func
(paren
id|key
comma
id|datalen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
multiline_comment|/* attach the new data, displacing the old */
id|zap
op_assign
id|key-&gt;payload.data
suffix:semicolon
id|key-&gt;payload.data
op_assign
r_new
suffix:semicolon
id|key-&gt;expiry
op_assign
l_int|0
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|key-&gt;lock
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|zap
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end user_update() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * match users on their name&n; */
DECL|function|user_match
r_static
r_int
id|user_match
c_func
(paren
r_const
r_struct
id|key
op_star
id|key
comma
r_const
r_void
op_star
id|description
)paren
(brace
r_return
id|strcmp
c_func
(paren
id|key-&gt;description
comma
id|description
)paren
op_eq
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end user_match() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * dispose of the data dangling from the corpse of a user&n; */
DECL|function|user_destroy
r_static
r_void
id|user_destroy
c_func
(paren
r_struct
id|key
op_star
id|key
)paren
(brace
id|kfree
c_func
(paren
id|key-&gt;payload.data
)paren
suffix:semicolon
)brace
multiline_comment|/* end user_destroy() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * describe the user&n; */
DECL|function|user_describe
r_static
r_void
id|user_describe
c_func
(paren
r_const
r_struct
id|key
op_star
id|key
comma
r_struct
id|seq_file
op_star
id|m
)paren
(brace
id|seq_puts
c_func
(paren
id|m
comma
id|key-&gt;description
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;: %u&quot;
comma
id|key-&gt;datalen
)paren
suffix:semicolon
)brace
multiline_comment|/* end user_describe() */
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; * read the key data&n; */
DECL|function|user_read
r_static
r_int
id|user_read
c_func
(paren
r_const
r_struct
id|key
op_star
id|key
comma
r_char
id|__user
op_star
id|buffer
comma
r_int
id|buflen
)paren
(brace
r_int
id|ret
op_assign
id|key-&gt;datalen
suffix:semicolon
multiline_comment|/* we can return the data as is */
r_if
c_cond
(paren
id|buffer
op_logical_and
id|buflen
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|buflen
OG
id|key-&gt;datalen
)paren
id|buflen
op_assign
id|key-&gt;datalen
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buffer
comma
id|key-&gt;payload.data
comma
id|buflen
)paren
op_ne
l_int|0
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end user_read() */
eof
