multiline_comment|/**&n; * BSD Secure Levels LSM&n; *&n; * Maintainers:&n; *&t;Michael A. Halcrow &lt;mike@halcrow.us&gt;&n; *&t;Serge Hallyn &lt;hallyn@cs.wm.edu&gt;&n; *&n; * Copyright (c) 2001 WireX Communications, Inc &lt;chris@wirex.com&gt;&n; * Copyright (c) 2001 Greg Kroah-Hartman &lt;greg@kroah.com&gt;&n; * Copyright (c) 2002 International Business Machines &lt;robb@austin.ibm.com&gt;&n; *&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2 of the License, or&n; *&t;(at your option) any later version.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/security.h&gt;
macro_line|#include &lt;linux/netlink.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/namei.h&gt;
macro_line|#include &lt;linux/mount.h&gt;
macro_line|#include &lt;linux/capability.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/kobject.h&gt;
macro_line|#include &lt;linux/crypto.h&gt;
macro_line|#include &lt;asm/scatterlist.h&gt;
macro_line|#include &lt;linux/gfp.h&gt;
macro_line|#include &lt;linux/sysfs.h&gt;
DECL|macro|SHA1_DIGEST_SIZE
mdefine_line|#define SHA1_DIGEST_SIZE 20
multiline_comment|/**&n; * Module parameter that defines the initial secure level.&n; *&n; * When built as a module, it defaults to seclvl 1, which is the&n; * behavior of BSD secure levels.  Note that this default behavior&n; * wrecks havoc on a machine when the seclvl module is compiled into&n; * the kernel.&t;In that case, we default to seclvl 0.&n; */
macro_line|#ifdef CONFIG_SECURITY_SECLVL_MODULE
DECL|variable|initlvl
r_static
r_int
id|initlvl
op_assign
l_int|1
suffix:semicolon
macro_line|#else
DECL|variable|initlvl
r_static
r_int
id|initlvl
suffix:semicolon
macro_line|#endif
id|module_param
c_func
(paren
id|initlvl
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|initlvl
comma
l_string|&quot;Initial secure level (defaults to 1)&quot;
)paren
suffix:semicolon
multiline_comment|/* Module parameter that defines the verbosity level */
DECL|variable|verbosity
r_static
r_int
id|verbosity
suffix:semicolon
id|module_param
c_func
(paren
id|verbosity
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|verbosity
comma
l_string|&quot;Initial verbosity level (0 or 1; defaults to &quot;
l_string|&quot;0, which is Quiet)&quot;
)paren
suffix:semicolon
multiline_comment|/**&n; * Optional password which can be passed in to bring seclvl to 0&n; * (i.e., for halt/reboot).  Defaults to NULL (the passwd attribute&n; * file will not be registered in sysfs).&n; *&n; * This gets converted to its SHA1 hash when stored.  It&squot;s probably&n; * not a good idea to use this parameter when loading seclvl from a&n; * script; use sha1_passwd instead.&n; */
DECL|macro|MAX_PASSWD_SIZE
mdefine_line|#define MAX_PASSWD_SIZE&t;32
DECL|variable|passwd
r_static
r_char
id|passwd
(braket
id|MAX_PASSWD_SIZE
)braket
suffix:semicolon
id|module_param_string
c_func
(paren
id|passwd
comma
id|passwd
comma
r_sizeof
(paren
id|passwd
)paren
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|passwd
comma
l_string|&quot;Plaintext of password that sets seclvl=0 when written to &quot;
l_string|&quot;(sysfs mount point)/seclvl/passwd&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/**&n; * SHA1 hashed version of the optional password which can be passed in&n; * to bring seclvl to 0 (i.e., for halt/reboot).  Must be in&n; * hexadecimal format (40 characters).&t;Defaults to NULL (the passwd&n; * attribute file will not be registered in sysfs).&n; *&n; * Use the sha1sum utility to generate the SHA1 hash of a password:&n; *&n; * echo -n &quot;secret&quot; | sha1sum&n; */
DECL|macro|MAX_SHA1_PASSWD
mdefine_line|#define MAX_SHA1_PASSWD&t;41
DECL|variable|sha1_passwd
r_static
r_char
id|sha1_passwd
(braket
id|MAX_SHA1_PASSWD
)braket
suffix:semicolon
id|module_param_string
c_func
(paren
id|sha1_passwd
comma
id|sha1_passwd
comma
r_sizeof
(paren
id|sha1_passwd
)paren
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|sha1_passwd
comma
l_string|&quot;SHA1 hash (40 hexadecimal characters) of password that &quot;
l_string|&quot;sets seclvl=0 when plaintext password is written to &quot;
l_string|&quot;(sysfs mount point)/seclvl/passwd&bslash;n&quot;
)paren
suffix:semicolon
DECL|variable|hideHash
r_static
r_int
id|hideHash
op_assign
l_int|1
suffix:semicolon
id|module_param
c_func
(paren
id|hideHash
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|hideHash
comma
l_string|&quot;When set to 0, reading seclvl/passwd from sysfs &quot;
l_string|&quot;will return the SHA1-hashed value of the password that &quot;
l_string|&quot;lowers the secure level to 0.&bslash;n&quot;
)paren
suffix:semicolon
DECL|macro|MY_NAME
mdefine_line|#define MY_NAME &quot;seclvl&quot;
multiline_comment|/**&n; * This time-limits log writes to one per second.&n; */
DECL|macro|seclvl_printk
mdefine_line|#define seclvl_printk(verb, type, fmt, arg...)&t;&t;&t;&bslash;&n;&t;do {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (verbosity &gt;= verb) {&t;&t;&t;&bslash;&n;&t;&t;&t;static unsigned long _prior;&t;&t;&bslash;&n;&t;&t;&t;unsigned long _now = jiffies;&t;&t;&bslash;&n;&t;&t;&t;if ((_now - _prior) &gt; HZ) {&t;&t;&bslash;&n;&t;&t;&t;&t;printk(type &quot;%s: %s: &quot; fmt,&t;&bslash;&n;&t;&t;&t;&t;&t;MY_NAME, __FUNCTION__ ,&t;&bslash;&n;&t;&t;&t;&t;&t;## arg);&t;&t;&bslash;&n;&t;&t;&t;&t;_prior = _now;&t;&t;&t;&bslash;&n;&t;&t;&t;}&t;&t;&t;&t;&t;&bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&bslash;&n;&t;} while (0)
multiline_comment|/**&n; * kobject stuff&n; */
DECL|variable|seclvl_subsys
r_struct
id|subsystem
id|seclvl_subsys
suffix:semicolon
DECL|struct|seclvl_obj
r_struct
id|seclvl_obj
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|slot_list
r_struct
id|list_head
id|slot_list
suffix:semicolon
DECL|member|kobj
r_struct
id|kobject
id|kobj
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/**&n; * There is a seclvl_attribute struct for each file in sysfs.&n; *&n; * In our case, we have one of these structs for &quot;passwd&quot; and another&n; * for &quot;seclvl&quot;.&n; */
DECL|struct|seclvl_attribute
r_struct
id|seclvl_attribute
(brace
DECL|member|attr
r_struct
id|attribute
id|attr
suffix:semicolon
DECL|member|show
id|ssize_t
c_func
(paren
op_star
id|show
)paren
(paren
r_struct
id|seclvl_obj
op_star
comma
r_char
op_star
)paren
suffix:semicolon
DECL|member|store
id|ssize_t
c_func
(paren
op_star
id|store
)paren
(paren
r_struct
id|seclvl_obj
op_star
comma
r_const
r_char
op_star
comma
r_int
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/**&n; * When this function is called, one of the files in sysfs is being&n; * written to.  attribute-&gt;store is a function pointer to whatever the&n; * struct seclvl_attribute store function pointer points to.  It is&n; * unique for &quot;passwd&quot; and &quot;seclvl&quot;.&n; */
r_static
id|ssize_t
DECL|function|seclvl_attr_store
id|seclvl_attr_store
c_func
(paren
r_struct
id|kobject
op_star
id|kobj
comma
r_struct
id|attribute
op_star
id|attr
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|seclvl_obj
op_star
id|obj
op_assign
id|container_of
c_func
(paren
id|kobj
comma
r_struct
id|seclvl_obj
comma
id|kobj
)paren
suffix:semicolon
r_struct
id|seclvl_attribute
op_star
id|attribute
op_assign
id|container_of
c_func
(paren
id|attr
comma
r_struct
id|seclvl_attribute
comma
id|attr
)paren
suffix:semicolon
r_return
(paren
id|attribute-&gt;store
ques
c_cond
id|attribute
op_member_access_from_pointer
id|store
c_func
(paren
id|obj
comma
id|buf
comma
id|len
)paren
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|seclvl_attr_show
id|seclvl_attr_show
c_func
(paren
r_struct
id|kobject
op_star
id|kobj
comma
r_struct
id|attribute
op_star
id|attr
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|seclvl_obj
op_star
id|obj
op_assign
id|container_of
c_func
(paren
id|kobj
comma
r_struct
id|seclvl_obj
comma
id|kobj
)paren
suffix:semicolon
r_struct
id|seclvl_attribute
op_star
id|attribute
op_assign
id|container_of
c_func
(paren
id|attr
comma
r_struct
id|seclvl_attribute
comma
id|attr
)paren
suffix:semicolon
r_return
(paren
id|attribute-&gt;show
ques
c_cond
id|attribute
op_member_access_from_pointer
id|show
c_func
(paren
id|obj
comma
id|buf
)paren
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Callback function pointers for show and store&n; */
DECL|variable|seclvlfs_sysfs_ops
r_static
r_struct
id|sysfs_ops
id|seclvlfs_sysfs_ops
op_assign
(brace
dot
id|show
op_assign
id|seclvl_attr_show
comma
dot
id|store
op_assign
id|seclvl_attr_store
comma
)brace
suffix:semicolon
DECL|variable|seclvl_ktype
r_static
r_struct
id|kobj_type
id|seclvl_ktype
op_assign
(brace
dot
id|sysfs_ops
op_assign
op_amp
id|seclvlfs_sysfs_ops
)brace
suffix:semicolon
id|decl_subsys
c_func
(paren
id|seclvl
comma
op_amp
id|seclvl_ktype
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/**&n; * The actual security level.  Ranges between -1 and 2 inclusive.&n; */
DECL|variable|seclvl
r_static
r_int
id|seclvl
suffix:semicolon
multiline_comment|/**&n; * flag to keep track of how we were registered&n; */
DECL|variable|secondary
r_static
r_int
id|secondary
suffix:semicolon
multiline_comment|/**&n; * Verifies that the requested secure level is valid, given the current&n; * secure level.&n; */
DECL|function|seclvl_sanity
r_static
r_int
id|seclvl_sanity
c_func
(paren
r_int
id|reqlvl
)paren
(brace
r_if
c_cond
(paren
(paren
id|reqlvl
OL
op_minus
l_int|1
)paren
op_logical_or
(paren
id|reqlvl
OG
l_int|2
)paren
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|1
comma
id|KERN_WARNING
comma
l_string|&quot;Attempt to set seclvl out of &quot;
l_string|&quot;range: [%d]&bslash;n&quot;
comma
id|reqlvl
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|seclvl
op_eq
l_int|0
)paren
op_logical_and
(paren
id|reqlvl
op_eq
op_minus
l_int|1
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|reqlvl
OL
id|seclvl
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|1
comma
id|KERN_WARNING
comma
l_string|&quot;Attempt to lower seclvl to &quot;
l_string|&quot;[%d]&bslash;n&quot;
comma
id|reqlvl
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Called whenever the user reads the sysfs handle to this kernel&n; * object&n; */
DECL|function|seclvl_read_file
r_static
id|ssize_t
id|seclvl_read_file
c_func
(paren
r_struct
id|seclvl_obj
op_star
id|obj
comma
r_char
op_star
id|buff
)paren
(brace
r_return
id|snprintf
c_func
(paren
id|buff
comma
id|PAGE_SIZE
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|seclvl
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * security level advancement rules:&n; *   Valid levels are -1 through 2, inclusive.&n; *   From -1, stuck.  [ in case compiled into kernel ]&n; *   From 0 or above, can only increment.&n; */
DECL|function|do_seclvl_advance
r_static
r_int
id|do_seclvl_advance
c_func
(paren
r_int
id|newlvl
)paren
(brace
r_if
c_cond
(paren
id|newlvl
op_le
id|seclvl
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|1
comma
id|KERN_WARNING
comma
l_string|&quot;Cannot advance to seclvl &quot;
l_string|&quot;[%d]&bslash;n&quot;
comma
id|newlvl
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newlvl
OG
l_int|2
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|1
comma
id|KERN_WARNING
comma
l_string|&quot;Cannot advance to seclvl &quot;
l_string|&quot;[%d]&bslash;n&quot;
comma
id|newlvl
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|seclvl
op_eq
op_minus
l_int|1
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|1
comma
id|KERN_WARNING
comma
l_string|&quot;Not allowed to advance to &quot;
l_string|&quot;seclvl [%d]&bslash;n&quot;
comma
id|seclvl
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|seclvl
op_assign
id|newlvl
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Called whenever the user writes to the sysfs handle to this kernel&n; * object (seclvl/seclvl).  It expects a single-digit number.&n; */
r_static
id|ssize_t
DECL|function|seclvl_write_file
id|seclvl_write_file
c_func
(paren
r_struct
id|seclvl_obj
op_star
id|obj
comma
r_const
r_char
op_star
id|buff
comma
r_int
id|count
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|2
op_logical_or
(paren
id|count
op_eq
l_int|2
op_logical_and
id|buff
(braket
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|1
comma
id|KERN_WARNING
comma
l_string|&quot;Invalid value passed to &quot;
l_string|&quot;seclvl: [%s]&bslash;n&quot;
comma
id|buff
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|val
op_assign
id|buff
(braket
l_int|0
)braket
op_minus
l_int|48
suffix:semicolon
r_if
c_cond
(paren
id|seclvl_sanity
c_func
(paren
id|val
)paren
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|1
comma
id|KERN_WARNING
comma
l_string|&quot;Illegal secure level &quot;
l_string|&quot;requested: [%d]&bslash;n&quot;
comma
(paren
r_int
)paren
id|val
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|do_seclvl_advance
c_func
(paren
id|val
)paren
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|0
comma
id|KERN_ERR
comma
l_string|&quot;Failure advancing security level &quot;
l_string|&quot;to %lu&bslash;n&quot;
comma
id|val
)paren
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/* Generate sysfs_attr_seclvl */
DECL|variable|sysfs_attr_seclvl
r_static
r_struct
id|seclvl_attribute
id|sysfs_attr_seclvl
op_assign
id|__ATTR
c_func
(paren
id|seclvl
comma
(paren
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
)paren
comma
id|seclvl_read_file
comma
id|seclvl_write_file
)paren
suffix:semicolon
DECL|variable|hashedPassword
r_static
r_int
r_char
id|hashedPassword
(braket
id|SHA1_DIGEST_SIZE
)braket
suffix:semicolon
multiline_comment|/**&n; * Called whenever the user reads the sysfs passwd handle.&n; */
DECL|function|seclvl_read_passwd
r_static
id|ssize_t
id|seclvl_read_passwd
c_func
(paren
r_struct
id|seclvl_obj
op_star
id|obj
comma
r_char
op_star
id|buff
)paren
(brace
multiline_comment|/* So just how good *is* your password? :-) */
r_char
id|tmp
(braket
l_int|3
)braket
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|buff
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|hideHash
)paren
(brace
multiline_comment|/* Security through obscurity */
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
OL
id|SHA1_DIGEST_SIZE
)paren
(brace
id|snprintf
c_func
(paren
id|tmp
comma
l_int|3
comma
l_string|&quot;%02x&quot;
comma
id|hashedPassword
(braket
id|i
)braket
)paren
suffix:semicolon
id|strncat
c_func
(paren
id|buff
comma
id|tmp
comma
l_int|2
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
id|strcat
c_func
(paren
id|buff
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
(paren
id|SHA1_DIGEST_SIZE
op_star
l_int|2
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * Converts a block of plaintext of into its SHA1 hashed value.&n; *&n; * It would be nice if crypto had a wrapper to do this for us linear&n; * people...&n; */
r_static
r_int
DECL|function|plaintext_to_sha1
id|plaintext_to_sha1
c_func
(paren
r_int
r_char
op_star
id|hash
comma
r_const
r_char
op_star
id|plaintext
comma
r_int
id|len
)paren
(brace
r_char
op_star
id|pgVirtAddr
suffix:semicolon
r_struct
id|crypto_tfm
op_star
id|tfm
suffix:semicolon
r_struct
id|scatterlist
id|sg
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|PAGE_SIZE
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|0
comma
id|KERN_ERR
comma
l_string|&quot;Plaintext password too large (%d &quot;
l_string|&quot;characters).  Largest possible is %lu &quot;
l_string|&quot;bytes.&bslash;n&quot;
comma
id|len
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|tfm
op_assign
id|crypto_alloc_tfm
c_func
(paren
l_string|&quot;sha1&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tfm
op_eq
l_int|NULL
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|0
comma
id|KERN_ERR
comma
l_string|&quot;Failed to load transform for SHA1&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
singleline_comment|// Just get a new page; don&squot;t play around with page boundaries
singleline_comment|// and scatterlists.
id|pgVirtAddr
op_assign
(paren
r_char
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
id|sg
(braket
l_int|0
)braket
dot
id|page
op_assign
id|virt_to_page
c_func
(paren
id|pgVirtAddr
)paren
suffix:semicolon
id|sg
(braket
l_int|0
)braket
dot
id|offset
op_assign
l_int|0
suffix:semicolon
id|sg
(braket
l_int|0
)braket
dot
id|length
op_assign
id|len
suffix:semicolon
id|strncpy
c_func
(paren
id|pgVirtAddr
comma
id|plaintext
comma
id|len
)paren
suffix:semicolon
id|crypto_digest_init
c_func
(paren
id|tfm
)paren
suffix:semicolon
id|crypto_digest_update
c_func
(paren
id|tfm
comma
id|sg
comma
l_int|1
)paren
suffix:semicolon
id|crypto_digest_final
c_func
(paren
id|tfm
comma
id|hash
)paren
suffix:semicolon
id|crypto_free_tfm
c_func
(paren
id|tfm
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|pgVirtAddr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Called whenever the user writes to the sysfs passwd handle to this kernel&n; * object.  It hashes the password and compares the hashed results.&n; */
r_static
id|ssize_t
DECL|function|seclvl_write_passwd
id|seclvl_write_passwd
c_func
(paren
r_struct
id|seclvl_obj
op_star
id|obj
comma
r_const
r_char
op_star
id|buff
comma
r_int
id|count
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|tmp
(braket
id|SHA1_DIGEST_SIZE
)braket
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|passwd
op_logical_and
op_logical_neg
op_star
id|sha1_passwd
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|0
comma
id|KERN_ERR
comma
l_string|&quot;Attempt to password-unlock the &quot;
l_string|&quot;seclvl module, but neither a plain text &quot;
l_string|&quot;password nor a SHA1 hashed password was &quot;
l_string|&quot;passed in as a module parameter!  This is a &quot;
l_string|&quot;bug, since it should not be possible to be in &quot;
l_string|&quot;this part of the module; please tell a &quot;
l_string|&quot;maintainer about this event.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|len
op_assign
id|strlen
c_func
(paren
id|buff
)paren
suffix:semicolon
multiline_comment|/* ``echo &quot;secret&quot; &gt; seclvl/passwd&squot;&squot; includes a newline */
r_if
c_cond
(paren
id|buff
(braket
id|len
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|len
op_decrement
suffix:semicolon
)brace
multiline_comment|/* Hash the password, then compare the hashed values */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|plaintext_to_sha1
c_func
(paren
id|tmp
comma
id|buff
comma
id|len
)paren
)paren
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|0
comma
id|KERN_ERR
comma
l_string|&quot;Error hashing password: rc = &quot;
l_string|&quot;[%d]&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SHA1_DIGEST_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hashedPassword
(braket
id|i
)braket
op_ne
id|tmp
(braket
id|i
)braket
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
)brace
id|seclvl_printk
c_func
(paren
l_int|0
comma
id|KERN_INFO
comma
l_string|&quot;Password accepted; seclvl reduced to 0.&bslash;n&quot;
)paren
suffix:semicolon
id|seclvl
op_assign
l_int|0
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/* Generate sysfs_attr_passwd */
DECL|variable|sysfs_attr_passwd
r_static
r_struct
id|seclvl_attribute
id|sysfs_attr_passwd
op_assign
id|__ATTR
c_func
(paren
id|passwd
comma
(paren
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
)paren
comma
id|seclvl_read_passwd
comma
id|seclvl_write_passwd
)paren
suffix:semicolon
multiline_comment|/**&n; * Explicitely disallow ptrace&squot;ing the init process.&n; */
DECL|function|seclvl_ptrace
r_static
r_int
id|seclvl_ptrace
c_func
(paren
r_struct
id|task_struct
op_star
id|parent
comma
r_struct
id|task_struct
op_star
id|child
)paren
(brace
r_if
c_cond
(paren
id|seclvl
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|child-&gt;pid
op_eq
l_int|1
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|1
comma
id|KERN_WARNING
comma
l_string|&quot;Attempt to ptrace &quot;
l_string|&quot;the init process dissallowed in &quot;
l_string|&quot;secure level %d&bslash;n&quot;
comma
id|seclvl
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Capability checks for seclvl.  The majority of the policy&n; * enforcement for seclvl takes place here.&n; */
DECL|function|seclvl_capable
r_static
r_int
id|seclvl_capable
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
id|cap
)paren
(brace
multiline_comment|/* init can do anything it wants */
r_if
c_cond
(paren
id|tsk-&gt;pid
op_eq
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|seclvl
)paren
(brace
r_case
l_int|2
suffix:colon
multiline_comment|/* fall through */
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|cap
op_eq
id|CAP_LINUX_IMMUTABLE
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|1
comma
id|KERN_WARNING
comma
l_string|&quot;Attempt to modify &quot;
l_string|&quot;the IMMUTABLE and/or APPEND extended &quot;
l_string|&quot;attribute on a file with the IMMUTABLE &quot;
l_string|&quot;and/or APPEND extended attribute set &quot;
l_string|&quot;denied in seclvl [%d]&bslash;n&quot;
comma
id|seclvl
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cap
op_eq
id|CAP_SYS_RAWIO
)paren
(brace
singleline_comment|// Somewhat broad...
id|seclvl_printk
c_func
(paren
l_int|1
comma
id|KERN_WARNING
comma
l_string|&quot;Attempt to perform &quot;
l_string|&quot;raw I/O while in secure level [%d] &quot;
l_string|&quot;denied&bslash;n&quot;
comma
id|seclvl
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cap
op_eq
id|CAP_NET_ADMIN
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|1
comma
id|KERN_WARNING
comma
l_string|&quot;Attempt to perform &quot;
l_string|&quot;network administrative task while &quot;
l_string|&quot;in secure level [%d] denied&bslash;n&quot;
comma
id|seclvl
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cap
op_eq
id|CAP_SETUID
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|1
comma
id|KERN_WARNING
comma
l_string|&quot;Attempt to setuid &quot;
l_string|&quot;while in secure level [%d] denied&bslash;n&quot;
comma
id|seclvl
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cap
op_eq
id|CAP_SETGID
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|1
comma
id|KERN_WARNING
comma
l_string|&quot;Attempt to setgid &quot;
l_string|&quot;while in secure level [%d] denied&bslash;n&quot;
comma
id|seclvl
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cap
op_eq
id|CAP_SYS_MODULE
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|1
comma
id|KERN_WARNING
comma
l_string|&quot;Attempt to perform &quot;
l_string|&quot;a module operation while in secure &quot;
l_string|&quot;level [%d] denied&bslash;n&quot;
comma
id|seclvl
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/* from dummy.c */
r_if
c_cond
(paren
id|cap_is_fs_cap
c_func
(paren
id|cap
)paren
ques
c_cond
id|tsk-&gt;fsuid
op_eq
l_int|0
suffix:colon
id|tsk-&gt;euid
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* capability granted */
id|seclvl_printk
c_func
(paren
l_int|1
comma
id|KERN_WARNING
comma
l_string|&quot;Capability denied&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* capability denied */
)brace
multiline_comment|/**&n; * Disallow reversing the clock in seclvl &gt; 1&n; */
DECL|function|seclvl_settime
r_static
r_int
id|seclvl_settime
c_func
(paren
r_struct
id|timespec
op_star
id|tv
comma
r_struct
id|timezone
op_star
id|tz
)paren
(brace
r_struct
id|timespec
id|now
suffix:semicolon
r_if
c_cond
(paren
id|seclvl
OG
l_int|1
)paren
(brace
id|now
op_assign
id|current_kernel_time
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tv-&gt;tv_sec
OL
id|now.tv_sec
op_logical_or
(paren
id|tv-&gt;tv_sec
op_eq
id|now.tv_sec
op_logical_and
id|tv-&gt;tv_nsec
OL
id|now.tv_nsec
)paren
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|1
comma
id|KERN_WARNING
comma
l_string|&quot;Attempt to decrement &quot;
l_string|&quot;time in secure level %d denied: &quot;
l_string|&quot;current-&gt;pid = [%d], &quot;
l_string|&quot;current-&gt;group_leader-&gt;pid = [%d]&bslash;n&quot;
comma
id|seclvl
comma
id|current-&gt;pid
comma
id|current-&gt;group_leader-&gt;pid
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
multiline_comment|/* if attempt to decrement time */
)brace
multiline_comment|/* if seclvl &gt; 1 */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* claim the blockdev to exclude mounters, release on file close */
DECL|function|seclvl_bd_claim
r_static
r_int
id|seclvl_bd_claim
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_int
id|holder
suffix:semicolon
r_struct
id|block_device
op_star
id|bdev
op_assign
l_int|NULL
suffix:semicolon
id|dev_t
id|dev
op_assign
id|inode-&gt;i_rdev
suffix:semicolon
id|bdev
op_assign
id|open_by_devnum
c_func
(paren
id|dev
comma
id|FMODE_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdev
)paren
(brace
r_if
c_cond
(paren
id|bd_claim
c_func
(paren
id|bdev
comma
op_amp
id|holder
)paren
)paren
(brace
id|blkdev_put
c_func
(paren
id|bdev
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
multiline_comment|/* claimed, mark it to release on close */
id|inode-&gt;i_security
op_assign
id|current
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* release the blockdev if you claimed it */
DECL|function|seclvl_bd_release
r_static
r_void
id|seclvl_bd_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_if
c_cond
(paren
id|inode
op_logical_and
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
id|inode-&gt;i_security
op_eq
id|current
)paren
(brace
r_struct
id|block_device
op_star
id|bdev
op_assign
id|inode-&gt;i_bdev
suffix:semicolon
r_if
c_cond
(paren
id|bdev
)paren
(brace
id|bd_release
c_func
(paren
id|bdev
)paren
suffix:semicolon
id|blkdev_put
c_func
(paren
id|bdev
)paren
suffix:semicolon
id|inode-&gt;i_security
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/**&n; * Security for writes to block devices is regulated by this seclvl&n; * function.  Deny all writes to block devices in seclvl 2.  In&n; * seclvl 1, we only deny writes to *mounted* block devices.&n; */
r_static
r_int
DECL|function|seclvl_inode_permission
id|seclvl_inode_permission
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|mask
comma
r_struct
id|nameidata
op_star
id|nd
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;pid
op_ne
l_int|1
op_logical_and
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
(paren
id|mask
op_amp
id|MAY_WRITE
)paren
)paren
(brace
r_switch
c_cond
(paren
id|seclvl
)paren
(brace
r_case
l_int|2
suffix:colon
id|seclvl_printk
c_func
(paren
l_int|1
comma
id|KERN_WARNING
comma
l_string|&quot;Write to block device &quot;
l_string|&quot;denied in secure level [%d]&bslash;n&quot;
comma
id|seclvl
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|seclvl_bd_claim
c_func
(paren
id|inode
)paren
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|1
comma
id|KERN_WARNING
comma
l_string|&quot;Write to mounted block device &quot;
l_string|&quot;denied in secure level [%d]&bslash;n&quot;
comma
id|seclvl
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * The SUID and SGID bits cannot be set in seclvl &gt;= 1&n; */
DECL|function|seclvl_inode_setattr
r_static
r_int
id|seclvl_inode_setattr
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|iattr
op_star
id|iattr
)paren
(brace
r_if
c_cond
(paren
id|seclvl
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|iattr-&gt;ia_valid
op_amp
id|ATTR_MODE
)paren
r_if
c_cond
(paren
id|iattr-&gt;ia_mode
op_amp
id|S_ISUID
op_logical_or
id|iattr-&gt;ia_mode
op_amp
id|S_ISGID
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|1
comma
id|KERN_WARNING
comma
l_string|&quot;Attempt to &quot;
l_string|&quot;modify SUID or SGID bit &quot;
l_string|&quot;denied in seclvl [%d]&bslash;n&quot;
comma
id|seclvl
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* release busied block devices */
DECL|function|seclvl_file_free_security
r_static
r_void
id|seclvl_file_free_security
c_func
(paren
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|filp-&gt;f_dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|dentry
)paren
(brace
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|seclvl_bd_release
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * Cannot unmount in secure level 2&n; */
DECL|function|seclvl_umount
r_static
r_int
id|seclvl_umount
c_func
(paren
r_struct
id|vfsmount
op_star
id|mnt
comma
r_int
id|flags
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;pid
op_eq
l_int|1
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|seclvl
op_eq
l_int|2
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|1
comma
id|KERN_WARNING
comma
l_string|&quot;Attempt to unmount in secure &quot;
l_string|&quot;level %d&bslash;n&quot;
comma
id|seclvl
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|seclvl_ops
r_static
r_struct
id|security_operations
id|seclvl_ops
op_assign
(brace
dot
id|ptrace
op_assign
id|seclvl_ptrace
comma
dot
id|capable
op_assign
id|seclvl_capable
comma
dot
id|inode_permission
op_assign
id|seclvl_inode_permission
comma
dot
id|inode_setattr
op_assign
id|seclvl_inode_setattr
comma
dot
id|file_free_security
op_assign
id|seclvl_file_free_security
comma
dot
id|settime
op_assign
id|seclvl_settime
comma
dot
id|sb_umount
op_assign
id|seclvl_umount
comma
)brace
suffix:semicolon
multiline_comment|/**&n; * Process the password-related module parameters&n; */
DECL|function|processPassword
r_static
r_int
id|processPassword
c_func
(paren
r_void
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|hashedPassword
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
op_star
id|passwd
)paren
(brace
r_if
c_cond
(paren
op_star
id|sha1_passwd
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|0
comma
id|KERN_ERR
comma
l_string|&quot;Error: Both &quot;
l_string|&quot;passwd and sha1_passwd &quot;
l_string|&quot;were set, but they are mutually &quot;
l_string|&quot;exclusive.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|plaintext_to_sha1
c_func
(paren
id|hashedPassword
comma
id|passwd
comma
id|strlen
c_func
(paren
id|passwd
)paren
)paren
)paren
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|0
comma
id|KERN_ERR
comma
l_string|&quot;Error: SHA1 support not &quot;
l_string|&quot;in kernel&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* All static data goes to the BSS, which zero&squot;s the&n;&t;&t; * plaintext password out for us. */
)brace
r_else
r_if
c_cond
(paren
op_star
id|sha1_passwd
)paren
(brace
singleline_comment|// Base 16
r_int
id|i
suffix:semicolon
id|i
op_assign
id|strlen
c_func
(paren
id|sha1_passwd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
(paren
id|SHA1_DIGEST_SIZE
op_star
l_int|2
)paren
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|0
comma
id|KERN_ERR
comma
l_string|&quot;Received [%d] bytes; &quot;
l_string|&quot;expected [%d] for the hexadecimal &quot;
l_string|&quot;representation of the SHA1 hash of &quot;
l_string|&quot;the password.&bslash;n&quot;
comma
id|i
comma
(paren
id|SHA1_DIGEST_SIZE
op_star
l_int|2
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|i
op_sub_assign
l_int|2
)paren
op_plus
l_int|2
)paren
(brace
r_int
r_char
id|tmp
suffix:semicolon
id|tmp
op_assign
id|sha1_passwd
(braket
id|i
op_plus
l_int|2
)braket
suffix:semicolon
id|sha1_passwd
(braket
id|i
op_plus
l_int|2
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|hashedPassword
(braket
id|i
op_div
l_int|2
)braket
op_assign
(paren
r_int
r_char
)paren
id|simple_strtol
c_func
(paren
op_amp
id|sha1_passwd
(braket
id|i
)braket
comma
l_int|NULL
comma
l_int|16
)paren
suffix:semicolon
id|sha1_passwd
(braket
id|i
op_plus
l_int|2
)braket
op_assign
id|tmp
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Sysfs registrations&n; */
DECL|function|doSysfsRegistrations
r_static
r_int
id|doSysfsRegistrations
c_func
(paren
r_void
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|subsystem_register
c_func
(paren
op_amp
id|seclvl_subsys
)paren
)paren
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|0
comma
id|KERN_WARNING
comma
l_string|&quot;Error [%d] registering seclvl subsystem&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|sysfs_create_file
c_func
(paren
op_amp
id|seclvl_subsys.kset.kobj
comma
op_amp
id|sysfs_attr_seclvl.attr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|passwd
op_logical_or
op_star
id|sha1_passwd
)paren
(brace
id|sysfs_create_file
c_func
(paren
op_amp
id|seclvl_subsys.kset.kobj
comma
op_amp
id|sysfs_attr_passwd.attr
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Initialize the seclvl module.&n; */
DECL|function|seclvl_init
r_static
r_int
id|__init
id|seclvl_init
c_func
(paren
r_void
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|verbosity
template_param
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Error: bad verbosity [%d]; only 0 or 1 &quot;
l_string|&quot;are valid values&bslash;n&quot;
comma
id|verbosity
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
id|sysfs_attr_seclvl.attr.owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|sysfs_attr_passwd.attr.owner
op_assign
id|THIS_MODULE
suffix:semicolon
r_if
c_cond
(paren
id|initlvl
template_param
l_int|2
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|0
comma
id|KERN_ERR
comma
l_string|&quot;Error: bad initial securelevel &quot;
l_string|&quot;[%d].&bslash;n&quot;
comma
id|initlvl
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
id|seclvl
op_assign
id|initlvl
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|processPassword
c_func
(paren
)paren
)paren
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|0
comma
id|KERN_ERR
comma
l_string|&quot;Error processing the password &quot;
l_string|&quot;module parameter(s): rc = [%d]&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
multiline_comment|/* register ourselves with the security framework */
r_if
c_cond
(paren
id|register_security
c_func
(paren
op_amp
id|seclvl_ops
)paren
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|0
comma
id|KERN_ERR
comma
l_string|&quot;seclvl: Failure registering with the &quot;
l_string|&quot;kernel.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* try registering with primary module */
id|rc
op_assign
id|mod_reg_security
c_func
(paren
id|MY_NAME
comma
op_amp
id|seclvl_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|0
comma
id|KERN_ERR
comma
l_string|&quot;seclvl: Failure &quot;
l_string|&quot;registering with primary security &quot;
l_string|&quot;module.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
multiline_comment|/* if primary module registered */
id|secondary
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* if we registered ourselves with the security framework */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|doSysfsRegistrations
c_func
(paren
)paren
)paren
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|0
comma
id|KERN_ERR
comma
l_string|&quot;Error registering with sysfs&bslash;n&quot;
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
id|seclvl_printk
c_func
(paren
l_int|0
comma
id|KERN_INFO
comma
l_string|&quot;seclvl: Successfully initialized.&bslash;n&quot;
)paren
suffix:semicolon
m_exit
suffix:colon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;seclvl: Error during initialization: rc = &quot;
l_string|&quot;[%d]&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; * Remove the seclvl module.&n; */
DECL|function|seclvl_exit
r_static
r_void
id|__exit
id|seclvl_exit
c_func
(paren
r_void
)paren
(brace
id|sysfs_remove_file
c_func
(paren
op_amp
id|seclvl_subsys.kset.kobj
comma
op_amp
id|sysfs_attr_seclvl.attr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|passwd
op_logical_or
op_star
id|sha1_passwd
)paren
(brace
id|sysfs_remove_file
c_func
(paren
op_amp
id|seclvl_subsys.kset.kobj
comma
op_amp
id|sysfs_attr_passwd.attr
)paren
suffix:semicolon
)brace
id|subsystem_unregister
c_func
(paren
op_amp
id|seclvl_subsys
)paren
suffix:semicolon
r_if
c_cond
(paren
id|secondary
op_eq
l_int|1
)paren
(brace
id|mod_unreg_security
c_func
(paren
id|MY_NAME
comma
op_amp
id|seclvl_ops
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|unregister_security
c_func
(paren
op_amp
id|seclvl_ops
)paren
)paren
(brace
id|seclvl_printk
c_func
(paren
l_int|0
comma
id|KERN_INFO
comma
l_string|&quot;seclvl: Failure unregistering with the &quot;
l_string|&quot;kernel&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|variable|seclvl_init
id|module_init
c_func
(paren
id|seclvl_init
)paren
suffix:semicolon
DECL|variable|seclvl_exit
id|module_exit
c_func
(paren
id|seclvl_exit
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Michael A. Halcrow &lt;mike@halcrow.us&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;LSM implementation of the BSD Secure Levels&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
