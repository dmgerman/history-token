multiline_comment|/* calibrate.c: default delay calibration&n; *&n; * Excised from init/main.c&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
DECL|variable|preset_lpj
r_static
r_int
r_int
id|preset_lpj
suffix:semicolon
DECL|function|lpj_setup
r_static
r_int
id|__init
id|lpj_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|preset_lpj
op_assign
id|simple_strtoul
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;lpj=&quot;
comma
id|lpj_setup
)paren
suffix:semicolon
multiline_comment|/*&n; * This is the number of bits of precision for the loops_per_jiffy.  Each&n; * bit takes on average 1.5/HZ seconds.  This (like the original) is a little&n; * better than 1%&n; */
DECL|macro|LPS_PREC
mdefine_line|#define LPS_PREC 8
DECL|function|calibrate_delay
r_void
id|__devinit
id|calibrate_delay
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|ticks
comma
id|loopbit
suffix:semicolon
r_int
id|lps_precision
op_assign
id|LPS_PREC
suffix:semicolon
r_if
c_cond
(paren
id|preset_lpj
)paren
(brace
id|loops_per_jiffy
op_assign
id|preset_lpj
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Calibrating delay loop (skipped)... &quot;
l_string|&quot;%lu.%02lu BogoMIPS preset&bslash;n&quot;
comma
id|loops_per_jiffy
op_div
(paren
l_int|500000
op_div
id|HZ
)paren
comma
(paren
id|loops_per_jiffy
op_div
(paren
l_int|5000
op_div
id|HZ
)paren
)paren
op_mod
l_int|100
)paren
suffix:semicolon
)brace
r_else
(brace
id|loops_per_jiffy
op_assign
(paren
l_int|1
op_lshift
l_int|12
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Calibrating delay loop... &quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|loops_per_jiffy
op_lshift_assign
l_int|1
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* wait for &quot;start of&quot; clock tick */
id|ticks
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
id|ticks
op_eq
id|jiffies
)paren
multiline_comment|/* nothing */
suffix:semicolon
multiline_comment|/* Go .. */
id|ticks
op_assign
id|jiffies
suffix:semicolon
id|__delay
c_func
(paren
id|loops_per_jiffy
)paren
suffix:semicolon
id|ticks
op_assign
id|jiffies
op_minus
id|ticks
suffix:semicolon
r_if
c_cond
(paren
id|ticks
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Do a binary approximation to get loops_per_jiffy set to&n;&t;&t; * equal one clock (up to lps_precision bits)&n;&t;&t; */
id|loops_per_jiffy
op_rshift_assign
l_int|1
suffix:semicolon
id|loopbit
op_assign
id|loops_per_jiffy
suffix:semicolon
r_while
c_loop
(paren
id|lps_precision
op_decrement
op_logical_and
(paren
id|loopbit
op_rshift_assign
l_int|1
)paren
)paren
(brace
id|loops_per_jiffy
op_or_assign
id|loopbit
suffix:semicolon
id|ticks
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
id|ticks
op_eq
id|jiffies
)paren
multiline_comment|/* nothing */
suffix:semicolon
id|ticks
op_assign
id|jiffies
suffix:semicolon
id|__delay
c_func
(paren
id|loops_per_jiffy
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jiffies
op_ne
id|ticks
)paren
multiline_comment|/* longer than 1 tick */
id|loops_per_jiffy
op_and_assign
op_complement
id|loopbit
suffix:semicolon
)brace
multiline_comment|/* Round the value and print it */
id|printk
c_func
(paren
l_string|&quot;%lu.%02lu BogoMIPS (lpj=%lu)&bslash;n&quot;
comma
id|loops_per_jiffy
op_div
(paren
l_int|500000
op_div
id|HZ
)paren
comma
(paren
id|loops_per_jiffy
op_div
(paren
l_int|5000
op_div
id|HZ
)paren
)paren
op_mod
l_int|100
comma
id|loops_per_jiffy
)paren
suffix:semicolon
)brace
)brace
eof
