multiline_comment|/*&n; *  linux/init/main.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; *&n; *  GK 2/5/95  -  Changed to support mounting root fs via NFS&n; *  Added initrd &amp; change_root: Werner Almesberger &amp; Hans Lermen, Feb &squot;96&n; *  Moan early if gcc is old, avoiding bogus kernels - Paul Gortmaker, May &squot;96&n; *  Simplified starting of init:  Michael A. Griffith &lt;grif@acm.org&gt; &n; */
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/syscalls.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/utsname.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/initrd.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/gfp.h&gt;
macro_line|#include &lt;linux/percpu.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/security.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;linux/profile.h&gt;
macro_line|#include &lt;linux/rcupdate.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/kallsyms.h&gt;
macro_line|#include &lt;linux/writeback.h&gt;
macro_line|#include &lt;linux/cpu.h&gt;
macro_line|#include &lt;linux/efi.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/rmap.h&gt;
macro_line|#include &lt;linux/mempolicy.h&gt;
macro_line|#include &lt;linux/key.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/bugs.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
multiline_comment|/*&n; * This is one of the first .c files built. Error out early&n; * if we have compiler trouble..&n; */
macro_line|#if __GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ == 96
macro_line|#ifdef CONFIG_FRAME_POINTER
macro_line|#error This compiler cannot compile correctly with frame pointers enabled
macro_line|#endif
macro_line|#endif
macro_line|#ifdef CONFIG_X86_LOCAL_APIC
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#endif
multiline_comment|/*&n; * Versions of gcc older than that listed below may actually compile&n; * and link okay, but the end product can have subtle run time bugs.&n; * To avoid associated bogus bug reports, we flatly refuse to compile&n; * with a gcc that is known to be too old from the very beginning.&n; */
macro_line|#if __GNUC__ &lt; 2 || (__GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt; 95)
macro_line|#error Sorry, your GCC is too old. It builds incorrect kernels.
macro_line|#endif
r_static
r_int
id|init
c_func
(paren
r_void
op_star
)paren
suffix:semicolon
r_extern
r_void
id|init_IRQ
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|sock_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|fork_init
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_extern
r_void
id|mca_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|sbus_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|sysctl_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|signals_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|buffer_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|pidhash_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|pidmap_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|prio_tree_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|radix_tree_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|free_initmem
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|populate_rootfs
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|driver_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|prepare_namespace
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef&t;CONFIG_ACPI
r_extern
r_void
id|acpi_early_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#else
DECL|function|acpi_early_init
r_static
r_inline
r_void
id|acpi_early_init
c_func
(paren
r_void
)paren
(brace
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_TC
r_extern
r_void
id|tc_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|system_state
r_enum
id|system_states
id|system_state
suffix:semicolon
DECL|variable|system_state
id|EXPORT_SYMBOL
c_func
(paren
id|system_state
)paren
suffix:semicolon
multiline_comment|/*&n; * Boot command-line arguments&n; */
DECL|macro|MAX_INIT_ARGS
mdefine_line|#define MAX_INIT_ARGS 32
DECL|macro|MAX_INIT_ENVS
mdefine_line|#define MAX_INIT_ENVS 32
r_extern
r_void
id|time_init
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* Default late time init is NULL. archs can override this later. */
DECL|variable|late_time_init
r_void
(paren
op_star
id|late_time_init
)paren
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|softirq_init
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* Untouched command line (eg. for /proc) saved by arch-specific code. */
DECL|variable|saved_command_line
r_char
id|saved_command_line
(braket
id|COMMAND_LINE_SIZE
)braket
suffix:semicolon
DECL|variable|execute_command
r_static
r_char
op_star
id|execute_command
suffix:semicolon
multiline_comment|/* Setup configured maximum number of CPUs to activate */
DECL|variable|max_cpus
r_static
r_int
r_int
id|max_cpus
op_assign
id|NR_CPUS
suffix:semicolon
multiline_comment|/*&n; * Setup routine for controlling SMP activation&n; *&n; * Command-line option of &quot;nosmp&quot; or &quot;maxcpus=0&quot; will disable SMP&n; * activation entirely (the MPS table probe still happens, though).&n; *&n; * Command-line option of &quot;maxcpus=&lt;NUM&gt;&quot;, where &lt;NUM&gt; is an integer&n; * greater than 0, limits the maximum number of CPUs activated in&n; * SMP mode to &lt;NUM&gt;.&n; */
DECL|function|nosmp
r_static
r_int
id|__init
id|nosmp
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|max_cpus
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;nosmp&quot;
comma
id|nosmp
)paren
suffix:semicolon
DECL|function|maxcpus
r_static
r_int
id|__init
id|maxcpus
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|max_cpus
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;maxcpus=&quot;
comma
id|maxcpus
)paren
suffix:semicolon
DECL|variable|argv_init
r_static
r_char
op_star
id|argv_init
(braket
id|MAX_INIT_ARGS
op_plus
l_int|2
)braket
op_assign
(brace
l_string|&quot;init&quot;
comma
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|envp_init
r_char
op_star
id|envp_init
(braket
id|MAX_INIT_ENVS
op_plus
l_int|2
)braket
op_assign
(brace
l_string|&quot;HOME=/&quot;
comma
l_string|&quot;TERM=linux&quot;
comma
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|panic_later
DECL|variable|panic_param
r_static
r_const
r_char
op_star
id|panic_later
comma
op_star
id|panic_param
suffix:semicolon
r_extern
r_struct
id|obs_kernel_param
id|__setup_start
(braket
)braket
comma
id|__setup_end
(braket
)braket
suffix:semicolon
DECL|function|obsolete_checksetup
r_static
r_int
id|__init
id|obsolete_checksetup
c_func
(paren
r_char
op_star
id|line
)paren
(brace
r_struct
id|obs_kernel_param
op_star
id|p
suffix:semicolon
id|p
op_assign
id|__setup_start
suffix:semicolon
r_do
(brace
r_int
id|n
op_assign
id|strlen
c_func
(paren
id|p-&gt;str
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|line
comma
id|p-&gt;str
comma
id|n
)paren
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;early
)paren
(brace
multiline_comment|/* Already done in parse_early_param?  (Needs&n;&t;&t;&t;&t; * exact match on param part) */
r_if
c_cond
(paren
id|line
(braket
id|n
)braket
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_or
id|line
(braket
id|n
)braket
op_eq
l_char|&squot;=&squot;
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;setup_func
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Parameter %s is obsolete,&quot;
l_string|&quot; ignored&bslash;n&quot;
comma
id|p-&gt;str
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p
op_member_access_from_pointer
id|setup_func
c_func
(paren
id|line
op_plus
id|n
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
id|p
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|p
OL
id|__setup_end
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This should be approx 2 Bo*oMips to start (note initial shift), and will&n; * still work even if initially too large, it will just take slightly longer&n; */
DECL|variable|loops_per_jiffy
r_int
r_int
id|loops_per_jiffy
op_assign
(paren
l_int|1
op_lshift
l_int|12
)paren
suffix:semicolon
DECL|variable|loops_per_jiffy
id|EXPORT_SYMBOL
c_func
(paren
id|loops_per_jiffy
)paren
suffix:semicolon
DECL|function|debug_kernel
r_static
r_int
id|__init
id|debug_kernel
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_if
c_cond
(paren
op_star
id|str
)paren
r_return
l_int|0
suffix:semicolon
id|console_loglevel
op_assign
l_int|10
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|quiet_kernel
r_static
r_int
id|__init
id|quiet_kernel
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_if
c_cond
(paren
op_star
id|str
)paren
r_return
l_int|0
suffix:semicolon
id|console_loglevel
op_assign
l_int|4
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;debug&quot;
comma
id|debug_kernel
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;quiet&quot;
comma
id|quiet_kernel
)paren
suffix:semicolon
DECL|function|loglevel
r_static
r_int
id|__init
id|loglevel
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|console_loglevel
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;loglevel=&quot;
comma
id|loglevel
)paren
suffix:semicolon
multiline_comment|/*&n; * Unknown boot options get handed to init, unless they look like&n; * failed parameters&n; */
DECL|function|unknown_bootoption
r_static
r_int
id|__init
id|unknown_bootoption
c_func
(paren
r_char
op_star
id|param
comma
r_char
op_star
id|val
)paren
(brace
multiline_comment|/* Change NUL term back to &quot;=&quot;, to make &quot;param&quot; the whole string. */
r_if
c_cond
(paren
id|val
)paren
(brace
multiline_comment|/* param=val or param=&quot;val&quot;? */
r_if
c_cond
(paren
id|val
op_eq
id|param
op_plus
id|strlen
c_func
(paren
id|param
)paren
op_plus
l_int|1
)paren
id|val
(braket
op_minus
l_int|1
)braket
op_assign
l_char|&squot;=&squot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|val
op_eq
id|param
op_plus
id|strlen
c_func
(paren
id|param
)paren
op_plus
l_int|2
)paren
(brace
id|val
(braket
op_minus
l_int|2
)braket
op_assign
l_char|&squot;=&squot;
suffix:semicolon
id|memmove
c_func
(paren
id|val
op_minus
l_int|1
comma
id|val
comma
id|strlen
c_func
(paren
id|val
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|val
op_decrement
suffix:semicolon
)brace
r_else
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Handle obsolete-style parameters */
r_if
c_cond
(paren
id|obsolete_checksetup
c_func
(paren
id|param
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Preemptive maintenance for &quot;why didn&squot;t my mispelled command&n;&t; * line work?&quot;&n;&t; */
r_if
c_cond
(paren
id|strchr
c_func
(paren
id|param
comma
l_char|&squot;.&squot;
)paren
op_logical_and
(paren
op_logical_neg
id|val
op_logical_or
id|strchr
c_func
(paren
id|param
comma
l_char|&squot;.&squot;
)paren
OL
id|val
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unknown boot option `%s&squot;: ignoring&bslash;n&quot;
comma
id|param
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|panic_later
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val
)paren
(brace
multiline_comment|/* Environment option */
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|envp_init
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|MAX_INIT_ENVS
)paren
(brace
id|panic_later
op_assign
l_string|&quot;Too many boot env vars at `%s&squot;&quot;
suffix:semicolon
id|panic_param
op_assign
id|param
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|param
comma
id|envp_init
(braket
id|i
)braket
comma
id|val
op_minus
id|param
)paren
)paren
r_break
suffix:semicolon
)brace
id|envp_init
(braket
id|i
)braket
op_assign
id|param
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Command line option */
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|argv_init
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|MAX_INIT_ARGS
)paren
(brace
id|panic_later
op_assign
l_string|&quot;Too many boot init vars at `%s&squot;&quot;
suffix:semicolon
id|panic_param
op_assign
id|param
suffix:semicolon
)brace
)brace
id|argv_init
(braket
id|i
)braket
op_assign
id|param
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|init_setup
r_static
r_int
id|__init
id|init_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|execute_command
op_assign
id|str
suffix:semicolon
multiline_comment|/*&n;&t; * In case LILO is going to boot us with default command line,&n;&t; * it prepends &quot;auto&quot; before the whole cmdline which makes&n;&t; * the shell think it should execute a script with such name.&n;&t; * So we ignore all arguments entered _before_ init=... [MJ]&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|MAX_INIT_ARGS
suffix:semicolon
id|i
op_increment
)paren
id|argv_init
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;init=&quot;
comma
id|init_setup
)paren
suffix:semicolon
r_extern
r_void
id|setup_arch
c_func
(paren
r_char
op_star
op_star
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_SMP
macro_line|#ifdef CONFIG_X86_LOCAL_APIC
DECL|function|smp_init
r_static
r_void
id|__init
id|smp_init
c_func
(paren
r_void
)paren
(brace
id|APIC_init_uniprocessor
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|smp_init
mdefine_line|#define smp_init()&t;do { } while (0)
macro_line|#endif
DECL|function|setup_per_cpu_areas
r_static
r_inline
r_void
id|setup_per_cpu_areas
c_func
(paren
r_void
)paren
(brace
)brace
DECL|function|smp_prepare_cpus
r_static
r_inline
r_void
id|smp_prepare_cpus
c_func
(paren
r_int
r_int
id|maxcpus
)paren
(brace
)brace
macro_line|#else
macro_line|#ifdef __GENERIC_PER_CPU
DECL|variable|__per_cpu_offset
r_int
r_int
id|__per_cpu_offset
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|variable|__per_cpu_offset
id|EXPORT_SYMBOL
c_func
(paren
id|__per_cpu_offset
)paren
suffix:semicolon
DECL|function|setup_per_cpu_areas
r_static
r_void
id|__init
id|setup_per_cpu_areas
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|size
comma
id|i
suffix:semicolon
r_char
op_star
id|ptr
suffix:semicolon
multiline_comment|/* Created by linker magic */
r_extern
r_char
id|__per_cpu_start
(braket
)braket
comma
id|__per_cpu_end
(braket
)braket
suffix:semicolon
multiline_comment|/* Copy section for each CPU (we discard the original) */
id|size
op_assign
id|ALIGN
c_func
(paren
id|__per_cpu_end
op_minus
id|__per_cpu_start
comma
id|SMP_CACHE_BYTES
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MODULES
r_if
c_cond
(paren
id|size
OL
id|PERCPU_ENOUGH_ROOM
)paren
id|size
op_assign
id|PERCPU_ENOUGH_ROOM
suffix:semicolon
macro_line|#endif
id|ptr
op_assign
id|alloc_bootmem
c_func
(paren
id|size
op_star
id|NR_CPUS
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
comma
id|ptr
op_add_assign
id|size
)paren
(brace
id|__per_cpu_offset
(braket
id|i
)braket
op_assign
id|ptr
op_minus
id|__per_cpu_start
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
comma
id|__per_cpu_start
comma
id|__per_cpu_end
op_minus
id|__per_cpu_start
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* !__GENERIC_PER_CPU */
multiline_comment|/* Called by boot processor to activate the rest. */
DECL|function|smp_init
r_static
r_void
id|__init
id|smp_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
multiline_comment|/* FIXME: This should be done in userspace --RR */
id|for_each_present_cpu
c_func
(paren
id|i
)paren
(brace
r_if
c_cond
(paren
id|num_online_cpus
c_func
(paren
)paren
op_ge
id|max_cpus
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_online
c_func
(paren
id|i
)paren
)paren
id|cpu_up
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* Any cleanup work */
id|printk
c_func
(paren
l_string|&quot;Brought up %ld CPUs&bslash;n&quot;
comma
(paren
r_int
)paren
id|num_online_cpus
c_func
(paren
)paren
)paren
suffix:semicolon
id|smp_cpus_done
c_func
(paren
id|max_cpus
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* Get other processors into their bootup holding patterns. */
id|smp_threads_ready
op_assign
l_int|1
suffix:semicolon
id|smp_commence
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif
multiline_comment|/*&n; * We need to finalize in a non-__init function or else race conditions&n; * between the root thread and the init thread may cause start_kernel to&n; * be reaped by free_initmem before the root thread has proceeded to&n; * cpu_idle.&n; *&n; * gcc-3.4 accidentally inlines this function, so use noinline.&n; */
r_static
r_void
id|noinline
id|rest_init
c_func
(paren
r_void
)paren
DECL|function|__releases
id|__releases
c_func
(paren
id|kernel_lock
)paren
(brace
id|kernel_thread
c_func
(paren
id|init
comma
l_int|NULL
comma
id|CLONE_FS
op_or
id|CLONE_SIGHAND
)paren
suffix:semicolon
id|numa_default_policy
c_func
(paren
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|preempt_enable_no_resched
c_func
(paren
)paren
suffix:semicolon
id|cpu_idle
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Check for early params. */
DECL|function|do_early_param
r_static
r_int
id|__init
id|do_early_param
c_func
(paren
r_char
op_star
id|param
comma
r_char
op_star
id|val
)paren
(brace
r_struct
id|obs_kernel_param
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|__setup_start
suffix:semicolon
id|p
OL
id|__setup_end
suffix:semicolon
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;early
op_logical_and
id|strcmp
c_func
(paren
id|param
comma
id|p-&gt;str
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|p
op_member_access_from_pointer
id|setup_func
c_func
(paren
id|val
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Malformed early option &squot;%s&squot;&bslash;n&quot;
comma
id|param
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* We accept everything at this stage. */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Arch code calls this early on, or if not, just before other parsing. */
DECL|function|parse_early_param
r_void
id|__init
id|parse_early_param
c_func
(paren
r_void
)paren
(brace
r_static
id|__initdata
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_static
id|__initdata
r_char
id|tmp_cmdline
(braket
id|COMMAND_LINE_SIZE
)braket
suffix:semicolon
r_if
c_cond
(paren
id|done
)paren
r_return
suffix:semicolon
multiline_comment|/* All fall through to do_early_param. */
id|strlcpy
c_func
(paren
id|tmp_cmdline
comma
id|saved_command_line
comma
id|COMMAND_LINE_SIZE
)paren
suffix:semicolon
id|parse_args
c_func
(paren
l_string|&quot;early options&quot;
comma
id|tmp_cmdline
comma
l_int|NULL
comma
l_int|0
comma
id|do_early_param
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Activate the first processor.&n; */
DECL|function|start_kernel
id|asmlinkage
r_void
id|__init
id|start_kernel
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|command_line
suffix:semicolon
r_extern
r_struct
id|kernel_param
id|__start___param
(braket
)braket
comma
id|__stop___param
(braket
)braket
suffix:semicolon
multiline_comment|/*&n; * Interrupts are still disabled. Do necessary setups, then&n; * enable them&n; */
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|page_address_init
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|linux_banner
)paren
suffix:semicolon
id|setup_arch
c_func
(paren
op_amp
id|command_line
)paren
suffix:semicolon
id|setup_per_cpu_areas
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mark the boot cpu &quot;online&quot; so that it can call console drivers in&n;&t; * printk() and can access its per-cpu storage.&n;&t; */
id|smp_prepare_boot_cpu
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set up the scheduler prior starting any interrupts (such as the&n;&t; * timer interrupt). Full topology setup happens at smp_init()&n;&t; * time - but meanwhile we still have a functioning scheduler.&n;&t; */
id|sched_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Disable preemption - early bootup scheduling is extremely&n;&t; * fragile until we cpu_idle() for the first time.&n;&t; */
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
id|build_all_zonelists
c_func
(paren
)paren
suffix:semicolon
id|page_alloc_init
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Kernel command line: %s&bslash;n&quot;
comma
id|saved_command_line
)paren
suffix:semicolon
id|parse_early_param
c_func
(paren
)paren
suffix:semicolon
id|parse_args
c_func
(paren
l_string|&quot;Booting kernel&quot;
comma
id|command_line
comma
id|__start___param
comma
id|__stop___param
op_minus
id|__start___param
comma
op_amp
id|unknown_bootoption
)paren
suffix:semicolon
id|sort_main_extable
c_func
(paren
)paren
suffix:semicolon
id|trap_init
c_func
(paren
)paren
suffix:semicolon
id|rcu_init
c_func
(paren
)paren
suffix:semicolon
id|init_IRQ
c_func
(paren
)paren
suffix:semicolon
id|pidhash_init
c_func
(paren
)paren
suffix:semicolon
id|init_timers
c_func
(paren
)paren
suffix:semicolon
id|softirq_init
c_func
(paren
)paren
suffix:semicolon
id|time_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * HACK ALERT! This is early. We&squot;re enabling the console before&n;&t; * we&squot;ve done PCI setups etc, and console_init() must be aware of&n;&t; * this. But we do want output early, in case something goes wrong.&n;&t; */
id|console_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|panic_later
)paren
id|panic
c_func
(paren
id|panic_later
comma
id|panic_param
)paren
suffix:semicolon
id|profile_init
c_func
(paren
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_if
c_cond
(paren
id|initrd_start
op_logical_and
op_logical_neg
id|initrd_below_start_ok
op_logical_and
id|initrd_start
OL
id|min_low_pfn
op_lshift
id|PAGE_SHIFT
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;initrd overwritten (0x%08lx &lt; 0x%08lx) - &quot;
l_string|&quot;disabling it.&bslash;n&quot;
comma
id|initrd_start
comma
id|min_low_pfn
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|initrd_start
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
id|vfs_caches_init_early
c_func
(paren
)paren
suffix:semicolon
id|mem_init
c_func
(paren
)paren
suffix:semicolon
id|kmem_cache_init
c_func
(paren
)paren
suffix:semicolon
id|numa_policy_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|late_time_init
)paren
id|late_time_init
c_func
(paren
)paren
suffix:semicolon
id|calibrate_delay
c_func
(paren
)paren
suffix:semicolon
id|pidmap_init
c_func
(paren
)paren
suffix:semicolon
id|pgtable_cache_init
c_func
(paren
)paren
suffix:semicolon
id|prio_tree_init
c_func
(paren
)paren
suffix:semicolon
id|anon_vma_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_X86
r_if
c_cond
(paren
id|efi_enabled
)paren
id|efi_enter_virtual_mode
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|fork_init
c_func
(paren
id|num_physpages
)paren
suffix:semicolon
id|proc_caches_init
c_func
(paren
)paren
suffix:semicolon
id|buffer_init
c_func
(paren
)paren
suffix:semicolon
id|unnamed_dev_init
c_func
(paren
)paren
suffix:semicolon
id|key_init
c_func
(paren
)paren
suffix:semicolon
id|security_init
c_func
(paren
)paren
suffix:semicolon
id|vfs_caches_init
c_func
(paren
id|num_physpages
)paren
suffix:semicolon
id|radix_tree_init
c_func
(paren
)paren
suffix:semicolon
id|signals_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* rootfs populating might need page-writeback */
id|page_writeback_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|proc_root_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|check_bugs
c_func
(paren
)paren
suffix:semicolon
id|acpi_early_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* before LAPIC and SMP init */
multiline_comment|/* Do the rest non-__init&squot;ed, we&squot;re now alive */
id|rest_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|initcall_debug
r_static
r_int
id|__initdata
id|initcall_debug
suffix:semicolon
DECL|function|initcall_debug_setup
r_static
r_int
id|__init
id|initcall_debug_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|initcall_debug
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;initcall_debug&quot;
comma
id|initcall_debug_setup
)paren
suffix:semicolon
DECL|variable|child_reaper
r_struct
id|task_struct
op_star
id|child_reaper
op_assign
op_amp
id|init_task
suffix:semicolon
r_extern
id|initcall_t
id|__initcall_start
(braket
)braket
comma
id|__initcall_end
(braket
)braket
suffix:semicolon
DECL|function|do_initcalls
r_static
r_void
id|__init
id|do_initcalls
c_func
(paren
r_void
)paren
(brace
id|initcall_t
op_star
id|call
suffix:semicolon
r_int
id|count
op_assign
id|preempt_count
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|call
op_assign
id|__initcall_start
suffix:semicolon
id|call
OL
id|__initcall_end
suffix:semicolon
id|call
op_increment
)paren
(brace
r_char
op_star
id|msg
suffix:semicolon
r_if
c_cond
(paren
id|initcall_debug
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Calling initcall 0x%p&quot;
comma
op_star
id|call
)paren
suffix:semicolon
id|print_fn_descriptor_symbol
c_func
(paren
l_string|&quot;: %s()&quot;
comma
(paren
r_int
r_int
)paren
op_star
id|call
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
(paren
op_star
id|call
)paren
(paren
)paren
suffix:semicolon
id|msg
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|preempt_count
c_func
(paren
)paren
op_ne
id|count
)paren
(brace
id|msg
op_assign
l_string|&quot;preemption imbalance&quot;
suffix:semicolon
id|preempt_count
c_func
(paren
)paren
op_assign
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irqs_disabled
c_func
(paren
)paren
)paren
(brace
id|msg
op_assign
l_string|&quot;disabled interrupts&quot;
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|msg
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;error in initcall at 0x%p: &quot;
l_string|&quot;returned with %s&bslash;n&quot;
comma
op_star
id|call
comma
id|msg
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Make sure there is no pending stuff from the initcall sequence */
id|flush_scheduled_work
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Ok, the machine is now initialized. None of the devices&n; * have been touched yet, but the CPU subsystem is up and&n; * running, and memory and process management works.&n; *&n; * Now we can finally start doing some real work..&n; */
DECL|function|do_basic_setup
r_static
r_void
id|__init
id|do_basic_setup
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* drivers will send hotplug events */
id|init_workqueues
c_func
(paren
)paren
suffix:semicolon
id|usermodehelper_init
c_func
(paren
)paren
suffix:semicolon
id|driver_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SYSCTL
id|sysctl_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Networking initialization needs a process context */
id|sock_init
c_func
(paren
)paren
suffix:semicolon
id|do_initcalls
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|do_pre_smp_initcalls
r_static
r_void
id|do_pre_smp_initcalls
c_func
(paren
r_void
)paren
(brace
r_extern
r_int
id|spawn_ksoftirqd
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_extern
r_int
id|migration_init
c_func
(paren
r_void
)paren
suffix:semicolon
id|migration_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|spawn_ksoftirqd
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|run_init_process
r_static
r_void
id|run_init_process
c_func
(paren
r_char
op_star
id|init_filename
)paren
(brace
id|argv_init
(braket
l_int|0
)braket
op_assign
id|init_filename
suffix:semicolon
id|execve
c_func
(paren
id|init_filename
comma
id|argv_init
comma
id|envp_init
)paren
suffix:semicolon
)brace
DECL|function|fixup_cpu_present_map
r_static
r_inline
r_void
id|fixup_cpu_present_map
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_SMP
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * If arch is not hotplug ready and did not populate&n;&t; * cpu_present_map, just make cpu_present_map same as cpu_possible_map&n;&t; * for other cpu bringup code to function as normal. e.g smp_init() etc.&n;&t; */
r_if
c_cond
(paren
id|cpus_empty
c_func
(paren
id|cpu_present_map
)paren
)paren
(brace
id|for_each_cpu
c_func
(paren
id|i
)paren
(brace
id|cpu_set
c_func
(paren
id|i
comma
id|cpu_present_map
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
DECL|function|init
r_static
r_int
id|init
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * init can run on any cpu.&n;&t; */
id|set_cpus_allowed
c_func
(paren
id|current
comma
id|CPU_MASK_ALL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Tell the world that we&squot;re going to be the grim&n;&t; * reaper of innocent orphaned children.&n;&t; *&n;&t; * We don&squot;t want people to have to make incorrect&n;&t; * assumptions about where in the task array this&n;&t; * can be found.&n;&t; */
id|child_reaper
op_assign
id|current
suffix:semicolon
multiline_comment|/* Sets up cpus_possible() */
id|smp_prepare_cpus
c_func
(paren
id|max_cpus
)paren
suffix:semicolon
id|do_pre_smp_initcalls
c_func
(paren
)paren
suffix:semicolon
id|fixup_cpu_present_map
c_func
(paren
)paren
suffix:semicolon
id|smp_init
c_func
(paren
)paren
suffix:semicolon
id|sched_init_smp
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do this before initcalls, because some drivers want to access&n;&t; * firmware files.&n;&t; */
id|populate_rootfs
c_func
(paren
)paren
suffix:semicolon
id|do_basic_setup
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * check if there is an early userspace init.  If yes, let it do all&n;&t; * the work&n;&t; */
r_if
c_cond
(paren
id|sys_access
c_func
(paren
(paren
r_const
r_char
id|__user
op_star
)paren
l_string|&quot;/init&quot;
comma
l_int|0
)paren
op_eq
l_int|0
)paren
id|execute_command
op_assign
l_string|&quot;/init&quot;
suffix:semicolon
r_else
id|prepare_namespace
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, we have completed the initial bootup, and&n;&t; * we&squot;re essentially up and running. Get rid of the&n;&t; * initmem segments and start the user-mode stuff..&n;&t; */
id|free_initmem
c_func
(paren
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|system_state
op_assign
id|SYSTEM_RUNNING
suffix:semicolon
id|numa_default_policy
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sys_open
c_func
(paren
(paren
r_const
r_char
id|__user
op_star
)paren
l_string|&quot;/dev/console&quot;
comma
id|O_RDWR
comma
l_int|0
)paren
OL
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;Warning: unable to open an initial console.&bslash;n&quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|sys_dup
c_func
(paren
l_int|0
)paren
suffix:semicolon
(paren
r_void
)paren
id|sys_dup
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We try each of these until one succeeds.&n;&t; *&n;&t; * The Bourne shell can be used instead of init if we are &n;&t; * trying to recover a really broken machine.&n;&t; */
r_if
c_cond
(paren
id|execute_command
)paren
id|run_init_process
c_func
(paren
id|execute_command
)paren
suffix:semicolon
id|run_init_process
c_func
(paren
l_string|&quot;/sbin/init&quot;
)paren
suffix:semicolon
id|run_init_process
c_func
(paren
l_string|&quot;/etc/init&quot;
)paren
suffix:semicolon
id|run_init_process
c_func
(paren
l_string|&quot;/bin/init&quot;
)paren
suffix:semicolon
id|run_init_process
c_func
(paren
l_string|&quot;/bin/sh&quot;
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;No init found.  Try passing init= option to kernel.&quot;
)paren
suffix:semicolon
)brace
eof
