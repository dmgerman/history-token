DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/fd.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/suspend.h&gt;
macro_line|#include &lt;linux/root_dev.h&gt;
macro_line|#include &lt;linux/mount.h&gt;
macro_line|#include &lt;linux/security.h&gt;
macro_line|#include &lt;linux/nfs_fs.h&gt;
macro_line|#include &lt;linux/nfs_fs_sb.h&gt;
macro_line|#include &lt;linux/nfs_mount.h&gt;
macro_line|#include &lt;linux/minix_fs.h&gt;
macro_line|#include &lt;linux/ext2_fs.h&gt;
macro_line|#include &lt;linux/romfs_fs.h&gt;
macro_line|#include &lt;linux/raid/md.h&gt;
DECL|macro|BUILD_CRAMDISK
mdefine_line|#define BUILD_CRAMDISK
r_extern
r_int
id|get_filesystem_list
c_func
(paren
r_char
op_star
id|buf
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_int
id|sys_mount
c_func
(paren
r_char
op_star
id|dev_name
comma
r_char
op_star
id|dir_name
comma
r_char
op_star
id|type
comma
r_int
r_int
id|flags
comma
r_void
op_star
id|data
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_int
id|sys_mkdir
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|mode
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_int
id|sys_rmdir
c_func
(paren
r_const
r_char
op_star
id|name
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_int
id|sys_chdir
c_func
(paren
r_const
r_char
op_star
id|name
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_int
id|sys_fchdir
c_func
(paren
r_int
id|fd
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_int
id|sys_chroot
c_func
(paren
r_const
r_char
op_star
id|name
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_int
id|sys_unlink
c_func
(paren
r_const
r_char
op_star
id|name
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_int
id|sys_symlink
c_func
(paren
r_const
r_char
op_star
id|old
comma
r_const
r_char
op_star
r_new
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_int
id|sys_mknod
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|mode
comma
id|dev_t
id|dev
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_int
id|sys_umount
c_func
(paren
r_char
op_star
id|name
comma
r_int
id|flags
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_int
id|sys_ioctl
c_func
(paren
r_int
id|fd
comma
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_int
id|sys_access
c_func
(paren
r_const
r_char
op_star
id|filename
comma
r_int
id|mode
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_int
id|sys_newstat
c_func
(paren
r_char
op_star
id|filename
comma
r_struct
id|stat
op_star
id|statbuf
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_int
id|sys_getdents64
c_func
(paren
r_int
r_int
id|fd
comma
r_void
op_star
id|dirent
comma
r_int
r_int
id|count
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
DECL|variable|real_root_dev
r_int
r_int
id|real_root_dev
suffix:semicolon
multiline_comment|/* do_proc_dointvec cannot handle kdev_t */
DECL|variable|mount_initrd
r_static
r_int
id|__initdata
id|mount_initrd
op_assign
l_int|1
suffix:semicolon
DECL|function|no_initrd
r_static
r_int
id|__init
id|no_initrd
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|mount_initrd
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;noinitrd&quot;
comma
id|no_initrd
)paren
suffix:semicolon
macro_line|#else
DECL|variable|mount_initrd
r_static
r_int
id|__initdata
id|mount_initrd
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
DECL|variable|rd_doload
r_int
id|__initdata
id|rd_doload
suffix:semicolon
multiline_comment|/* 1 = load RAM disk, 0 = don&squot;t load */
DECL|variable|root_mountflags
r_int
id|root_mountflags
op_assign
id|MS_RDONLY
op_or
id|MS_VERBOSE
suffix:semicolon
DECL|variable|root_device_name
r_static
r_char
id|root_device_name
(braket
l_int|64
)braket
suffix:semicolon
DECL|variable|saved_root_name
r_static
r_char
id|saved_root_name
(braket
l_int|64
)braket
suffix:semicolon
multiline_comment|/* this is initialized in init/main.c */
DECL|variable|ROOT_DEV
id|dev_t
id|ROOT_DEV
suffix:semicolon
DECL|variable|do_devfs
r_static
r_int
id|do_devfs
op_assign
l_int|0
suffix:semicolon
DECL|function|load_ramdisk
r_static
r_int
id|__init
id|load_ramdisk
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|rd_doload
op_assign
id|simple_strtol
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
op_amp
l_int|3
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;load_ramdisk=&quot;
comma
id|load_ramdisk
)paren
suffix:semicolon
DECL|function|readonly
r_static
r_int
id|__init
id|readonly
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_if
c_cond
(paren
op_star
id|str
)paren
r_return
l_int|0
suffix:semicolon
id|root_mountflags
op_or_assign
id|MS_RDONLY
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|readwrite
r_static
r_int
id|__init
id|readwrite
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_if
c_cond
(paren
op_star
id|str
)paren
r_return
l_int|0
suffix:semicolon
id|root_mountflags
op_and_assign
op_complement
id|MS_RDONLY
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;ro&quot;
comma
id|readonly
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;rw&quot;
comma
id|readwrite
)paren
suffix:semicolon
DECL|function|try_name
r_static
id|__init
id|dev_t
id|try_name
c_func
(paren
r_char
op_star
id|name
comma
r_int
id|part
)paren
(brace
r_char
id|path
(braket
l_int|64
)braket
suffix:semicolon
r_char
id|buf
(braket
l_int|32
)braket
suffix:semicolon
r_int
id|range
suffix:semicolon
id|dev_t
id|res
suffix:semicolon
r_char
op_star
id|s
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|fd
suffix:semicolon
multiline_comment|/* read device number from .../dev */
id|sprintf
c_func
(paren
id|path
comma
l_string|&quot;/sys/block/%s/dev&quot;
comma
id|name
)paren
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|path
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
r_goto
id|fail
suffix:semicolon
id|len
op_assign
id|read
c_func
(paren
id|fd
comma
id|buf
comma
l_int|32
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
l_int|0
op_logical_or
id|len
op_eq
l_int|32
op_logical_or
id|buf
(braket
id|len
op_minus
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
r_goto
id|fail
suffix:semicolon
id|buf
(braket
id|len
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|res
op_assign
(paren
id|dev_t
)paren
id|simple_strtoul
c_func
(paren
id|buf
comma
op_amp
id|s
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
)paren
r_goto
id|fail
suffix:semicolon
multiline_comment|/* if it&squot;s there and we are not looking for a partition - that&squot;s it */
r_if
c_cond
(paren
op_logical_neg
id|part
)paren
r_return
id|res
suffix:semicolon
multiline_comment|/* otherwise read range from .../range */
id|sprintf
c_func
(paren
id|path
comma
l_string|&quot;/sys/block/%s/range&quot;
comma
id|name
)paren
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|path
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
r_goto
id|fail
suffix:semicolon
id|len
op_assign
id|read
c_func
(paren
id|fd
comma
id|buf
comma
l_int|32
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
l_int|0
op_logical_or
id|len
op_eq
l_int|32
op_logical_or
id|buf
(braket
id|len
op_minus
l_int|1
)braket
op_ne
l_char|&squot;&bslash;n&squot;
)paren
r_goto
id|fail
suffix:semicolon
id|buf
(braket
id|len
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|range
op_assign
id|simple_strtoul
c_func
(paren
id|buf
comma
op_amp
id|s
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
)paren
r_goto
id|fail
suffix:semicolon
multiline_comment|/* if partition is within range - we got it */
r_if
c_cond
(paren
id|part
OL
id|range
)paren
r_return
id|res
op_plus
id|part
suffix:semicolon
id|fail
suffix:colon
r_return
(paren
id|dev_t
)paren
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Convert a name into device number.  We accept the following variants:&n; *&n; *&t;1) device number in hexadecimal&t;represents itself&n; *&t;2) /dev/nfs represents Root_NFS (0xff)&n; *&t;3) /dev/&lt;disk_name&gt; represents the device number of disk&n; *&t;4) /dev/&lt;disk_name&gt;&lt;decimal&gt; represents the device number&n; *         of partition - device number of disk plus the partition number&n; *&t;5) /dev/&lt;disk_name&gt;p&lt;decimal&gt; - same as the above, that form is&n; *&t;   used when disk name of partitioned disk ends on a digit.&n; *&n; *&t;If name doesn&squot;t have fall into the categories above, we return 0.&n; *&t;Driverfs is used to check if something is a disk name - it has&n; *&t;all known disks under bus/block/devices.  If the disk name&n; *&t;contains slashes, name of driverfs node has them replaced with&n; *&t;dots.  try_name() does the actual checks, assuming that driverfs&n; *&t;is mounted on rootfs /sys.&n; */
DECL|function|name_to_dev_t
id|__init
id|dev_t
id|name_to_dev_t
c_func
(paren
r_char
op_star
id|name
)paren
(brace
r_char
id|s
(braket
l_int|32
)braket
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
id|dev_t
id|res
op_assign
l_int|0
suffix:semicolon
r_int
id|part
suffix:semicolon
id|sys_mkdir
c_func
(paren
l_string|&quot;/sys&quot;
comma
l_int|0700
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sys_mount
c_func
(paren
l_string|&quot;sysfs&quot;
comma
l_string|&quot;/sys&quot;
comma
l_string|&quot;sysfs&quot;
comma
l_int|0
comma
l_int|NULL
)paren
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|name
comma
l_string|&quot;/dev/&quot;
comma
l_int|5
)paren
op_ne
l_int|0
)paren
(brace
id|res
op_assign
(paren
id|dev_t
)paren
id|simple_strtoul
c_func
(paren
id|name
comma
op_amp
id|p
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
)paren
r_goto
id|fail
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|name
op_add_assign
l_int|5
suffix:semicolon
id|res
op_assign
id|Root_NFS
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;nfs&quot;
)paren
op_eq
l_int|0
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|name
)paren
OG
l_int|31
)paren
r_goto
id|fail
suffix:semicolon
id|strcpy
c_func
(paren
id|s
comma
id|name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|s
suffix:semicolon
op_star
id|p
suffix:semicolon
id|p
op_increment
)paren
r_if
c_cond
(paren
op_star
id|p
op_eq
l_char|&squot;/&squot;
)paren
op_star
id|p
op_assign
l_char|&squot;.&squot;
suffix:semicolon
id|res
op_assign
id|try_name
c_func
(paren
id|s
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
r_goto
id|done
suffix:semicolon
r_while
c_loop
(paren
id|p
OG
id|s
op_logical_and
id|isdigit
c_func
(paren
id|p
(braket
op_minus
l_int|1
)braket
)paren
)paren
id|p
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
id|s
op_logical_or
op_logical_neg
op_star
id|p
op_logical_or
op_star
id|p
op_eq
l_char|&squot;0&squot;
)paren
r_goto
id|fail
suffix:semicolon
id|part
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
op_star
id|p
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|res
op_assign
id|try_name
c_func
(paren
id|s
comma
id|part
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
id|p
OL
id|s
op_plus
l_int|2
op_logical_or
op_logical_neg
id|isdigit
c_func
(paren
id|p
(braket
op_minus
l_int|2
)braket
)paren
op_logical_or
id|p
(braket
op_minus
l_int|1
)braket
op_ne
l_char|&squot;p&squot;
)paren
r_goto
id|fail
suffix:semicolon
id|p
(braket
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|res
op_assign
id|try_name
c_func
(paren
id|s
comma
id|part
)paren
suffix:semicolon
id|done
suffix:colon
id|sys_umount
c_func
(paren
l_string|&quot;/sys&quot;
comma
l_int|0
)paren
suffix:semicolon
id|out
suffix:colon
id|sys_rmdir
c_func
(paren
l_string|&quot;/sys&quot;
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
id|fail
suffix:colon
id|res
op_assign
(paren
id|dev_t
)paren
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
DECL|function|root_dev_setup
r_static
r_int
id|__init
id|root_dev_setup
c_func
(paren
r_char
op_star
id|line
)paren
(brace
id|strncpy
c_func
(paren
id|saved_root_name
comma
id|line
comma
l_int|64
)paren
suffix:semicolon
id|saved_root_name
(braket
l_int|63
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;root=&quot;
comma
id|root_dev_setup
)paren
suffix:semicolon
DECL|variable|root_mount_data
r_static
r_char
op_star
id|__initdata
id|root_mount_data
suffix:semicolon
DECL|function|root_data_setup
r_static
r_int
id|__init
id|root_data_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|root_mount_data
op_assign
id|str
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|root_fs_names
r_static
r_char
op_star
id|__initdata
id|root_fs_names
suffix:semicolon
DECL|function|fs_names_setup
r_static
r_int
id|__init
id|fs_names_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|root_fs_names
op_assign
id|str
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;rootflags=&quot;
comma
id|root_data_setup
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;rootfstype=&quot;
comma
id|fs_names_setup
)paren
suffix:semicolon
DECL|function|get_fs_names
r_static
r_void
id|__init
id|get_fs_names
c_func
(paren
r_char
op_star
id|page
)paren
(brace
r_char
op_star
id|s
op_assign
id|page
suffix:semicolon
r_if
c_cond
(paren
id|root_fs_names
)paren
(brace
id|strcpy
c_func
(paren
id|page
comma
id|root_fs_names
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|s
op_increment
)paren
(brace
r_if
c_cond
(paren
id|s
(braket
op_minus
l_int|1
)braket
op_eq
l_char|&squot;,&squot;
)paren
id|s
(braket
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
id|len
op_assign
id|get_filesystem_list
c_func
(paren
id|page
)paren
suffix:semicolon
r_char
op_star
id|p
comma
op_star
id|next
suffix:semicolon
id|page
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|page
op_minus
l_int|1
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|next
)paren
(brace
id|next
op_assign
id|strchr
c_func
(paren
op_increment
id|p
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_increment
op_ne
l_char|&squot;&bslash;t&squot;
)paren
r_continue
suffix:semicolon
r_while
c_loop
(paren
(paren
op_star
id|s
op_increment
op_assign
op_star
id|p
op_increment
)paren
op_ne
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|s
(braket
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
)brace
op_star
id|s
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
DECL|function|mount_block_root
r_static
r_void
id|__init
id|mount_block_root
c_func
(paren
r_char
op_star
id|name
comma
r_int
id|flags
)paren
(brace
r_char
op_star
id|fs_names
op_assign
id|__getname
c_func
(paren
)paren
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
id|get_fs_names
c_func
(paren
id|fs_names
)paren
suffix:semicolon
id|retry
suffix:colon
r_for
c_loop
(paren
id|p
op_assign
id|fs_names
suffix:semicolon
op_star
id|p
suffix:semicolon
id|p
op_add_assign
id|strlen
c_func
(paren
id|p
)paren
op_plus
l_int|1
)paren
(brace
r_int
id|err
op_assign
id|sys_mount
c_func
(paren
id|name
comma
l_string|&quot;/root&quot;
comma
id|p
comma
id|flags
comma
id|root_mount_data
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|err
)paren
(brace
r_case
l_int|0
suffix:colon
r_goto
id|out
suffix:semicolon
r_case
op_minus
id|EACCES
suffix:colon
id|flags
op_or_assign
id|MS_RDONLY
suffix:semicolon
r_goto
id|retry
suffix:semicolon
r_case
op_minus
id|EINVAL
suffix:colon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Allow the user to distinguish between failed open&n;&t;&t; * and bad superblock on root device.&n;&t;&t; */
id|printk
(paren
l_string|&quot;VFS: Cannot open root device &bslash;&quot;%s&bslash;&quot; or %s&bslash;n&quot;
comma
id|root_device_name
comma
id|kdevname
(paren
id|to_kdev_t
c_func
(paren
id|ROOT_DEV
)paren
)paren
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Please append a correct &bslash;&quot;root=&bslash;&quot; boot option&bslash;n&quot;
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;VFS: Unable to mount root fs on %s&quot;
comma
id|kdevname
c_func
(paren
id|to_kdev_t
c_func
(paren
id|ROOT_DEV
)paren
)paren
)paren
suffix:semicolon
)brace
id|panic
c_func
(paren
l_string|&quot;VFS: Unable to mount root fs on %s&quot;
comma
id|kdevname
c_func
(paren
id|to_kdev_t
c_func
(paren
id|ROOT_DEV
)paren
)paren
)paren
suffix:semicolon
id|out
suffix:colon
id|putname
c_func
(paren
id|fs_names
)paren
suffix:semicolon
id|sys_chdir
c_func
(paren
l_string|&quot;/root&quot;
)paren
suffix:semicolon
id|ROOT_DEV
op_assign
id|current-&gt;fs-&gt;pwdmnt-&gt;mnt_sb-&gt;s_dev
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;VFS: Mounted root (%s filesystem)%s.&bslash;n&quot;
comma
id|current-&gt;fs-&gt;pwdmnt-&gt;mnt_sb-&gt;s_type-&gt;name
comma
(paren
id|current-&gt;fs-&gt;pwdmnt-&gt;mnt_sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
ques
c_cond
l_string|&quot; readonly&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_ROOT_NFS
DECL|function|mount_nfs_root
r_static
r_int
id|__init
id|mount_nfs_root
c_func
(paren
r_void
)paren
(brace
r_void
op_star
id|data
op_assign
id|nfs_root_data
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_logical_and
id|sys_mount
c_func
(paren
l_string|&quot;/dev/root&quot;
comma
l_string|&quot;/root&quot;
comma
l_string|&quot;nfs&quot;
comma
id|root_mountflags
comma
id|data
)paren
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_DEVFS_FS
DECL|function|do_read_dir
r_static
r_int
id|__init
id|do_read_dir
c_func
(paren
r_int
id|fd
comma
r_void
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
id|bytes
comma
id|n
suffix:semicolon
r_char
op_star
id|p
op_assign
id|buf
suffix:semicolon
id|lseek
c_func
(paren
id|fd
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bytes
op_assign
l_int|0
comma
id|p
op_assign
id|buf
suffix:semicolon
id|bytes
OL
id|len
suffix:semicolon
id|bytes
op_add_assign
id|n
comma
id|p
op_add_assign
id|n
)paren
(brace
id|n
op_assign
id|sys_getdents64
c_func
(paren
id|fd
comma
id|p
comma
id|len
op_minus
id|bytes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|0
)paren
r_return
id|bytes
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_dir
r_static
r_void
op_star
id|__init
id|read_dir
c_func
(paren
r_char
op_star
id|path
comma
r_int
op_star
id|len
)paren
(brace
r_int
id|size
suffix:semicolon
r_int
id|fd
op_assign
id|open
c_func
(paren
id|path
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
op_star
id|len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|size
op_assign
l_int|1
op_lshift
l_int|9
suffix:semicolon
id|size
OL
(paren
l_int|1
op_lshift
l_int|18
)paren
suffix:semicolon
id|size
op_lshift_assign
l_int|1
)paren
(brace
r_void
op_star
id|p
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_int
id|n
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_break
suffix:semicolon
id|n
op_assign
id|do_read_dir
c_func
(paren
id|fd
comma
id|p
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|0
)paren
(brace
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
op_star
id|len
op_assign
id|n
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif
DECL|struct|linux_dirent64
r_struct
id|linux_dirent64
(brace
DECL|member|d_ino
id|u64
id|d_ino
suffix:semicolon
DECL|member|d_off
id|s64
id|d_off
suffix:semicolon
DECL|member|d_reclen
r_int
r_int
id|d_reclen
suffix:semicolon
DECL|member|d_type
r_int
r_char
id|d_type
suffix:semicolon
DECL|member|d_name
r_char
id|d_name
(braket
l_int|0
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|function|find_in_devfs
r_static
r_int
id|__init
id|find_in_devfs
c_func
(paren
r_char
op_star
id|path
comma
id|dev_t
id|dev
)paren
(brace
macro_line|#ifdef CONFIG_DEVFS_FS
r_struct
id|stat
id|buf
suffix:semicolon
r_char
op_star
id|end
op_assign
id|path
op_plus
id|strlen
c_func
(paren
id|path
)paren
suffix:semicolon
r_int
id|rest
op_assign
id|path
op_plus
l_int|64
op_minus
id|end
suffix:semicolon
r_int
id|size
suffix:semicolon
r_char
op_star
id|p
op_assign
id|read_dir
c_func
(paren
id|path
comma
op_amp
id|size
)paren
suffix:semicolon
r_char
op_star
id|s
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|s
op_assign
id|p
suffix:semicolon
id|s
OL
id|p
op_plus
id|size
suffix:semicolon
id|s
op_add_assign
(paren
(paren
r_struct
id|linux_dirent64
op_star
)paren
id|s
)paren
op_member_access_from_pointer
id|d_reclen
)paren
(brace
r_struct
id|linux_dirent64
op_star
id|d
op_assign
(paren
r_struct
id|linux_dirent64
op_star
)paren
id|s
suffix:semicolon
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|d-&gt;d_name
)paren
op_plus
l_int|2
OG
id|rest
)paren
r_continue
suffix:semicolon
r_switch
c_cond
(paren
id|d-&gt;d_type
)paren
(brace
r_case
id|DT_BLK
suffix:colon
id|sprintf
c_func
(paren
id|end
comma
l_string|&quot;/%s&quot;
comma
id|d-&gt;d_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sys_newstat
c_func
(paren
id|path
comma
op_amp
id|buf
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISBLK
c_func
(paren
id|buf.st_mode
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|buf.st_rdev
op_ne
id|dev
)paren
r_break
suffix:semicolon
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|DT_DIR
suffix:colon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|d-&gt;d_name
comma
l_string|&quot;.&quot;
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|d-&gt;d_name
comma
l_string|&quot;..&quot;
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|sprintf
c_func
(paren
id|end
comma
l_string|&quot;/%s&quot;
comma
id|d-&gt;d_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|find_in_devfs
c_func
(paren
id|path
comma
id|dev
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|create_dev
r_static
r_int
id|__init
id|create_dev
c_func
(paren
r_char
op_star
id|name
comma
id|dev_t
id|dev
comma
r_char
op_star
id|devfs_name
)paren
(brace
r_char
id|path
(braket
l_int|64
)braket
suffix:semicolon
id|sys_unlink
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|do_devfs
)paren
r_return
id|sys_mknod
c_func
(paren
id|name
comma
id|S_IFBLK
op_or
l_int|0600
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devfs_name
op_logical_and
id|devfs_name
(braket
l_int|0
)braket
)paren
(brace
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|devfs_name
comma
l_string|&quot;/dev/&quot;
comma
l_int|5
)paren
op_eq
l_int|0
)paren
id|devfs_name
op_add_assign
l_int|5
suffix:semicolon
id|sprintf
c_func
(paren
id|path
comma
l_string|&quot;/dev/%s&quot;
comma
id|devfs_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sys_access
c_func
(paren
id|path
comma
l_int|0
)paren
op_eq
l_int|0
)paren
r_return
id|sys_symlink
c_func
(paren
id|devfs_name
comma
id|name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|strcpy
c_func
(paren
id|path
comma
l_string|&quot;/dev&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|find_in_devfs
c_func
(paren
id|path
comma
id|dev
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
id|sys_symlink
c_func
(paren
id|path
op_plus
l_int|5
comma
id|name
)paren
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_BLK_DEV_RAM) || defined(CONFIG_BLK_DEV_FD)
DECL|function|change_floppy
r_static
r_void
id|__init
id|change_floppy
c_func
(paren
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
r_struct
id|termios
id|termios
suffix:semicolon
r_char
id|buf
(braket
l_int|80
)braket
suffix:semicolon
r_char
id|c
suffix:semicolon
r_int
id|fd
suffix:semicolon
id|va_list
id|args
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|vsprintf
c_func
(paren
id|buf
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
l_string|&quot;/dev/root&quot;
comma
id|O_RDWR
op_or
id|O_NDELAY
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
op_ge
l_int|0
)paren
(brace
id|sys_ioctl
c_func
(paren
id|fd
comma
id|FDEJECT
comma
l_int|0
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;VFS: Insert %s and press ENTER&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
l_string|&quot;/dev/console&quot;
comma
id|O_RDWR
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
op_ge
l_int|0
)paren
(brace
id|sys_ioctl
c_func
(paren
id|fd
comma
id|TCGETS
comma
(paren
r_int
)paren
op_amp
id|termios
)paren
suffix:semicolon
id|termios.c_lflag
op_and_assign
op_complement
id|ICANON
suffix:semicolon
id|sys_ioctl
c_func
(paren
id|fd
comma
id|TCSETSF
comma
(paren
r_int
)paren
op_amp
id|termios
)paren
suffix:semicolon
id|read
c_func
(paren
id|fd
comma
op_amp
id|c
comma
l_int|1
)paren
suffix:semicolon
id|termios.c_lflag
op_or_assign
id|ICANON
suffix:semicolon
id|sys_ioctl
c_func
(paren
id|fd
comma
id|TCSETSF
comma
(paren
r_int
)paren
op_amp
id|termios
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_RAM
DECL|variable|rd_prompt
r_int
id|__initdata
id|rd_prompt
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* 1 = prompt for RAM disk, 0 = don&squot;t prompt */
DECL|function|prompt_ramdisk
r_static
r_int
id|__init
id|prompt_ramdisk
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|rd_prompt
op_assign
id|simple_strtol
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
op_amp
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;prompt_ramdisk=&quot;
comma
id|prompt_ramdisk
)paren
suffix:semicolon
DECL|variable|rd_image_start
r_int
id|__initdata
id|rd_image_start
suffix:semicolon
multiline_comment|/* starting block # of image */
DECL|function|ramdisk_start_setup
r_static
r_int
id|__init
id|ramdisk_start_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|rd_image_start
op_assign
id|simple_strtol
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;ramdisk_start=&quot;
comma
id|ramdisk_start_setup
)paren
suffix:semicolon
r_static
r_int
id|__init
id|crd_load
c_func
(paren
r_int
id|in_fd
comma
r_int
id|out_fd
)paren
suffix:semicolon
multiline_comment|/*&n; * This routine tries to find a RAM disk image to load, and returns the&n; * number of blocks to read for a non-compressed image, 0 if the image&n; * is a compressed image, and -1 if an image with the right magic&n; * numbers could not be found.&n; *&n; * We currently check for the following magic numbers:&n; * &t;minix&n; * &t;ext2&n; *&t;romfs&n; * &t;gzip&n; */
r_static
r_int
id|__init
DECL|function|identify_ramdisk_image
id|identify_ramdisk_image
c_func
(paren
r_int
id|fd
comma
r_int
id|start_block
)paren
(brace
r_const
r_int
id|size
op_assign
l_int|512
suffix:semicolon
r_struct
id|minix_super_block
op_star
id|minixsb
suffix:semicolon
r_struct
id|ext2_super_block
op_star
id|ext2sb
suffix:semicolon
r_struct
id|romfs_super_block
op_star
id|romfsb
suffix:semicolon
r_int
id|nblocks
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
r_char
op_star
id|buf
suffix:semicolon
id|buf
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|minixsb
op_assign
(paren
r_struct
id|minix_super_block
op_star
)paren
id|buf
suffix:semicolon
id|ext2sb
op_assign
(paren
r_struct
id|ext2_super_block
op_star
)paren
id|buf
suffix:semicolon
id|romfsb
op_assign
(paren
r_struct
id|romfs_super_block
op_star
)paren
id|buf
suffix:semicolon
id|memset
c_func
(paren
id|buf
comma
l_int|0xe5
comma
id|size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Read block 0 to test for gzipped kernel&n;&t; */
id|lseek
c_func
(paren
id|fd
comma
id|start_block
op_star
id|BLOCK_SIZE
comma
l_int|0
)paren
suffix:semicolon
id|read
c_func
(paren
id|fd
comma
id|buf
comma
id|size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If it matches the gzip magic numbers, return -1&n;&t; */
r_if
c_cond
(paren
id|buf
(braket
l_int|0
)braket
op_eq
l_int|037
op_logical_and
(paren
(paren
id|buf
(braket
l_int|1
)braket
op_eq
l_int|0213
)paren
op_logical_or
(paren
id|buf
(braket
l_int|1
)braket
op_eq
l_int|0236
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RAMDISK: Compressed image found at block %d&bslash;n&quot;
comma
id|start_block
)paren
suffix:semicolon
id|nblocks
op_assign
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* romfs is at block zero too */
r_if
c_cond
(paren
id|romfsb-&gt;word0
op_eq
id|ROMSB_WORD0
op_logical_and
id|romfsb-&gt;word1
op_eq
id|ROMSB_WORD1
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RAMDISK: romfs filesystem found at block %d&bslash;n&quot;
comma
id|start_block
)paren
suffix:semicolon
id|nblocks
op_assign
(paren
id|ntohl
c_func
(paren
id|romfsb-&gt;size
)paren
op_plus
id|BLOCK_SIZE
op_minus
l_int|1
)paren
op_rshift
id|BLOCK_SIZE_BITS
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Read block 1 to test for minix and ext2 superblock&n;&t; */
id|lseek
c_func
(paren
id|fd
comma
(paren
id|start_block
op_plus
l_int|1
)paren
op_star
id|BLOCK_SIZE
comma
l_int|0
)paren
suffix:semicolon
id|read
c_func
(paren
id|fd
comma
id|buf
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* Try minix */
r_if
c_cond
(paren
id|minixsb-&gt;s_magic
op_eq
id|MINIX_SUPER_MAGIC
op_logical_or
id|minixsb-&gt;s_magic
op_eq
id|MINIX_SUPER_MAGIC2
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RAMDISK: Minix filesystem found at block %d&bslash;n&quot;
comma
id|start_block
)paren
suffix:semicolon
id|nblocks
op_assign
id|minixsb-&gt;s_nzones
op_lshift
id|minixsb-&gt;s_log_zone_size
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* Try ext2 */
r_if
c_cond
(paren
id|ext2sb-&gt;s_magic
op_eq
id|cpu_to_le16
c_func
(paren
id|EXT2_SUPER_MAGIC
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RAMDISK: ext2 filesystem found at block %d&bslash;n&quot;
comma
id|start_block
)paren
suffix:semicolon
id|nblocks
op_assign
id|le32_to_cpu
c_func
(paren
id|ext2sb-&gt;s_blocks_count
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RAMDISK: Couldn&squot;t find valid RAM disk image starting at %d.&bslash;n&quot;
comma
id|start_block
)paren
suffix:semicolon
id|done
suffix:colon
id|lseek
c_func
(paren
id|fd
comma
id|start_block
op_star
id|BLOCK_SIZE
comma
l_int|0
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|nblocks
suffix:semicolon
)brace
macro_line|#endif
DECL|function|rd_load_image
r_static
r_int
id|__init
id|rd_load_image
c_func
(paren
r_char
op_star
id|from
)paren
(brace
r_int
id|res
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_RAM
r_int
id|in_fd
comma
id|out_fd
suffix:semicolon
r_int
id|nblocks
comma
id|rd_blocks
comma
id|devblocks
comma
id|i
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
r_int
r_int
id|rotate
op_assign
l_int|0
suffix:semicolon
macro_line|#if !defined(CONFIG_ARCH_S390) &amp;&amp; !defined(CONFIG_PPC_ISERIES)
r_char
id|rotator
(braket
l_int|4
)braket
op_assign
(brace
l_char|&squot;|&squot;
comma
l_char|&squot;/&squot;
comma
l_char|&squot;-&squot;
comma
l_char|&squot;&bslash;&bslash;&squot;
)brace
suffix:semicolon
macro_line|#endif
id|out_fd
op_assign
id|open
c_func
(paren
l_string|&quot;/dev/ram&quot;
comma
id|O_RDWR
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|out_fd
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|in_fd
op_assign
id|open
c_func
(paren
id|from
comma
id|O_RDONLY
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_fd
OL
l_int|0
)paren
r_goto
id|noclose_input
suffix:semicolon
id|nblocks
op_assign
id|identify_ramdisk_image
c_func
(paren
id|in_fd
comma
id|rd_image_start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nblocks
OL
l_int|0
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
id|nblocks
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef BUILD_CRAMDISK
r_if
c_cond
(paren
id|crd_load
c_func
(paren
id|in_fd
comma
id|out_fd
)paren
op_eq
l_int|0
)paren
r_goto
id|successful_load
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RAMDISK: Kernel does not support compressed &quot;
l_string|&quot;RAM disk images&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * NOTE NOTE: nblocks suppose that the blocksize is BLOCK_SIZE, so&n;&t; * rd_load_image will work only with filesystem BLOCK_SIZE wide!&n;&t; * So make sure to use 1k blocksize while generating ext2fs&n;&t; * ramdisk-images.&n;&t; */
r_if
c_cond
(paren
id|sys_ioctl
c_func
(paren
id|out_fd
comma
id|BLKGETSIZE
comma
(paren
r_int
r_int
)paren
op_amp
id|rd_blocks
)paren
OL
l_int|0
)paren
id|rd_blocks
op_assign
l_int|0
suffix:semicolon
r_else
id|rd_blocks
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|nblocks
OG
id|rd_blocks
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RAMDISK: image too big! (%d/%d blocks)&bslash;n&quot;
comma
id|nblocks
comma
id|rd_blocks
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * OK, time to copy in the data&n;&t; */
id|buf
op_assign
id|kmalloc
c_func
(paren
id|BLOCK_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;RAMDISK: could not allocate buffer&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sys_ioctl
c_func
(paren
id|in_fd
comma
id|BLKGETSIZE
comma
(paren
r_int
r_int
)paren
op_amp
id|devblocks
)paren
OL
l_int|0
)paren
id|devblocks
op_assign
l_int|0
suffix:semicolon
r_else
id|devblocks
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|from
comma
l_string|&quot;/dev/initrd&quot;
)paren
op_eq
l_int|0
)paren
id|devblocks
op_assign
id|nblocks
suffix:semicolon
r_if
c_cond
(paren
id|devblocks
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;RAMDISK: could not determine device size&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RAMDISK: Loading %d blocks [%d disk%s] into ram disk... &quot;
comma
id|nblocks
comma
(paren
(paren
id|nblocks
op_minus
l_int|1
)paren
op_div
id|devblocks
)paren
op_plus
l_int|1
comma
id|nblocks
OG
id|devblocks
ques
c_cond
l_string|&quot;s&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nblocks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_logical_and
(paren
id|i
op_mod
id|devblocks
op_eq
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;done disk #%d.&bslash;n&quot;
comma
id|i
op_div
id|devblocks
)paren
suffix:semicolon
id|rotate
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|close
c_func
(paren
id|in_fd
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Error closing the disk.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|noclose_input
suffix:semicolon
)brace
id|change_floppy
c_func
(paren
l_string|&quot;disk #%d&quot;
comma
id|i
op_div
id|devblocks
op_plus
l_int|1
)paren
suffix:semicolon
id|in_fd
op_assign
id|open
c_func
(paren
id|from
comma
id|O_RDONLY
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_fd
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Error opening disk.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|noclose_input
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Loading disk #%d... &quot;
comma
id|i
op_div
id|devblocks
op_plus
l_int|1
)paren
suffix:semicolon
)brace
id|read
c_func
(paren
id|in_fd
comma
id|buf
comma
id|BLOCK_SIZE
)paren
suffix:semicolon
id|write
c_func
(paren
id|out_fd
comma
id|buf
comma
id|BLOCK_SIZE
)paren
suffix:semicolon
macro_line|#if !defined(CONFIG_ARCH_S390) &amp;&amp; !defined(CONFIG_PPC_ISERIES)
r_if
c_cond
(paren
op_logical_neg
(paren
id|i
op_mod
l_int|16
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%c&bslash;b&quot;
comma
id|rotator
(braket
id|rotate
op_amp
l_int|0x3
)braket
)paren
suffix:semicolon
id|rotate
op_increment
suffix:semicolon
)brace
macro_line|#endif
)brace
id|printk
c_func
(paren
l_string|&quot;done.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
id|successful_load
suffix:colon
id|res
op_assign
l_int|1
suffix:semicolon
id|done
suffix:colon
id|close
c_func
(paren
id|in_fd
)paren
suffix:semicolon
id|noclose_input
suffix:colon
id|close
c_func
(paren
id|out_fd
)paren
suffix:semicolon
id|out
suffix:colon
id|sys_unlink
c_func
(paren
l_string|&quot;/dev/ram&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|res
suffix:semicolon
)brace
DECL|function|rd_load_disk
r_static
r_int
id|__init
id|rd_load_disk
c_func
(paren
r_int
id|n
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_RAM
r_if
c_cond
(paren
id|rd_prompt
)paren
id|change_floppy
c_func
(paren
l_string|&quot;root floppy disk to be loaded into RAM disk&quot;
)paren
suffix:semicolon
id|create_dev
c_func
(paren
l_string|&quot;/dev/ram&quot;
comma
id|MKDEV
c_func
(paren
id|RAMDISK_MAJOR
comma
id|n
)paren
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
r_return
id|rd_load_image
c_func
(paren
l_string|&quot;/dev/root&quot;
)paren
suffix:semicolon
)brace
DECL|function|mount_root
r_static
r_void
id|__init
id|mount_root
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_ROOT_NFS
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|ROOT_DEV
)paren
op_eq
id|UNNAMED_MAJOR
)paren
(brace
r_if
c_cond
(paren
id|mount_nfs_root
c_func
(paren
)paren
)paren
(brace
id|sys_chdir
c_func
(paren
l_string|&quot;/root&quot;
)paren
suffix:semicolon
id|ROOT_DEV
op_assign
id|current-&gt;fs-&gt;pwdmnt-&gt;mnt_sb-&gt;s_dev
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;VFS: Mounted root (nfs filesystem).&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: Unable to mount root fs via NFS, trying floppy.&bslash;n&quot;
)paren
suffix:semicolon
id|ROOT_DEV
op_assign
id|Root_FD0
suffix:semicolon
)brace
macro_line|#endif
id|create_dev
c_func
(paren
l_string|&quot;/dev/root&quot;
comma
id|ROOT_DEV
comma
id|root_device_name
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_FD
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|ROOT_DEV
)paren
op_eq
id|FLOPPY_MAJOR
)paren
(brace
multiline_comment|/* rd_doload is 2 for a dual initrd/ramload setup */
r_if
c_cond
(paren
id|rd_doload
op_eq
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|rd_load_disk
c_func
(paren
l_int|1
)paren
)paren
(brace
id|ROOT_DEV
op_assign
id|Root_RAM1
suffix:semicolon
id|create_dev
c_func
(paren
l_string|&quot;/dev/root&quot;
comma
id|ROOT_DEV
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
r_else
id|change_floppy
c_func
(paren
l_string|&quot;root floppy&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|mount_block_root
c_func
(paren
l_string|&quot;/dev/root&quot;
comma
id|root_mountflags
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
DECL|variable|old_fd
DECL|variable|root_fd
r_static
r_int
id|old_fd
comma
id|root_fd
suffix:semicolon
DECL|function|do_linuxrc
r_static
r_int
id|do_linuxrc
c_func
(paren
r_void
op_star
id|shell
)paren
(brace
r_static
r_char
op_star
id|argv
(braket
)braket
op_assign
(brace
l_string|&quot;linuxrc&quot;
comma
l_int|NULL
comma
)brace
suffix:semicolon
r_extern
r_char
op_star
id|envp_init
(braket
)braket
suffix:semicolon
id|close
c_func
(paren
id|old_fd
)paren
suffix:semicolon
id|close
c_func
(paren
id|root_fd
)paren
suffix:semicolon
id|close
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|close
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|close
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|setsid
c_func
(paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|open
c_func
(paren
l_string|&quot;/dev/console&quot;
comma
id|O_RDWR
comma
l_int|0
)paren
suffix:semicolon
(paren
r_void
)paren
id|dup
c_func
(paren
l_int|0
)paren
suffix:semicolon
(paren
r_void
)paren
id|dup
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
id|execve
c_func
(paren
id|shell
comma
id|argv
comma
id|envp_init
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|handle_initrd
r_static
r_void
id|__init
id|handle_initrd
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_int
id|error
suffix:semicolon
r_int
id|i
comma
id|pid
suffix:semicolon
id|create_dev
c_func
(paren
l_string|&quot;/dev/root.old&quot;
comma
id|Root_RAM0
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* mount initrd on rootfs&squot; /root */
id|mount_block_root
c_func
(paren
l_string|&quot;/dev/root.old&quot;
comma
id|root_mountflags
op_amp
op_complement
id|MS_RDONLY
)paren
suffix:semicolon
id|sys_mkdir
c_func
(paren
l_string|&quot;/old&quot;
comma
l_int|0700
)paren
suffix:semicolon
id|root_fd
op_assign
id|open
c_func
(paren
l_string|&quot;/&quot;
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|old_fd
op_assign
id|open
c_func
(paren
l_string|&quot;/old&quot;
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* move initrd over / and chdir/chroot in initrd root */
id|sys_chdir
c_func
(paren
l_string|&quot;/root&quot;
)paren
suffix:semicolon
id|sys_mount
c_func
(paren
l_string|&quot;.&quot;
comma
l_string|&quot;/&quot;
comma
l_int|NULL
comma
id|MS_MOVE
comma
l_int|NULL
)paren
suffix:semicolon
id|sys_chroot
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
id|mount_devfs_fs
(paren
)paren
suffix:semicolon
id|pid
op_assign
id|kernel_thread
c_func
(paren
id|do_linuxrc
comma
l_string|&quot;/linuxrc&quot;
comma
id|SIGCHLD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pid
OG
l_int|0
)paren
(brace
r_while
c_loop
(paren
id|pid
op_ne
id|waitpid
c_func
(paren
op_minus
l_int|1
comma
op_amp
id|i
comma
l_int|0
)paren
)paren
id|yield
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* move initrd to rootfs&squot; /old */
id|sys_fchdir
c_func
(paren
id|old_fd
)paren
suffix:semicolon
id|sys_mount
c_func
(paren
l_string|&quot;/&quot;
comma
l_string|&quot;.&quot;
comma
l_int|NULL
comma
id|MS_MOVE
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* switch root and cwd back to / of rootfs */
id|sys_fchdir
c_func
(paren
id|root_fd
)paren
suffix:semicolon
id|sys_chroot
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
id|close
c_func
(paren
id|old_fd
)paren
suffix:semicolon
id|close
c_func
(paren
id|root_fd
)paren
suffix:semicolon
id|sys_umount
c_func
(paren
l_string|&quot;/old/dev&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|real_root_dev
op_eq
id|Root_RAM0
)paren
(brace
id|sys_chdir
c_func
(paren
l_string|&quot;/old&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ROOT_DEV
op_assign
id|real_root_dev
suffix:semicolon
id|mount_root
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Trying to move old root to /initrd ... &quot;
)paren
suffix:semicolon
id|error
op_assign
id|sys_mount
c_func
(paren
l_string|&quot;/old&quot;
comma
l_string|&quot;/root/initrd&quot;
comma
l_int|NULL
comma
id|MS_MOVE
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|printk
c_func
(paren
l_string|&quot;okay&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
r_int
id|fd
op_assign
id|open
c_func
(paren
l_string|&quot;/dev/root.old&quot;
comma
id|O_RDWR
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;failed&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Unmounting old root&bslash;n&quot;
)paren
suffix:semicolon
id|sys_umount
c_func
(paren
l_string|&quot;/old&quot;
comma
id|MNT_DETACH
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Trying to free ramdisk memory ... &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
id|error
op_assign
id|fd
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
id|sys_ioctl
c_func
(paren
id|fd
comma
id|BLKFLSBUF
comma
l_int|0
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
op_logical_neg
id|error
ques
c_cond
l_string|&quot;okay&bslash;n&quot;
suffix:colon
l_string|&quot;failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
DECL|function|initrd_load
r_static
r_int
id|__init
id|initrd_load
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
id|create_dev
c_func
(paren
l_string|&quot;/dev/ram&quot;
comma
id|MKDEV
c_func
(paren
id|RAMDISK_MAJOR
comma
l_int|0
)paren
comma
l_int|NULL
)paren
suffix:semicolon
id|create_dev
c_func
(paren
l_string|&quot;/dev/initrd&quot;
comma
id|MKDEV
c_func
(paren
id|RAMDISK_MAJOR
comma
id|INITRD_MINOR
)paren
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
r_return
id|rd_load_image
c_func
(paren
l_string|&quot;/dev/initrd&quot;
)paren
suffix:semicolon
)brace
r_static
r_void
id|__init
id|md_run_setup
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * Prepare the namespace - decide what/where to mount, load ramdisks, etc.&n; */
DECL|function|prepare_namespace
r_void
id|prepare_namespace
c_func
(paren
r_void
)paren
(brace
r_int
id|is_floppy
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_FS
id|sys_mount
c_func
(paren
l_string|&quot;devfs&quot;
comma
l_string|&quot;/dev&quot;
comma
l_string|&quot;devfs&quot;
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|do_devfs
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
id|md_run_setup
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|saved_root_name
(braket
l_int|0
)braket
)paren
(brace
r_char
op_star
id|p
op_assign
id|saved_root_name
suffix:semicolon
id|ROOT_DEV
op_assign
id|name_to_dev_t
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|p
comma
l_string|&quot;/dev/&quot;
comma
l_int|5
)paren
op_eq
l_int|0
)paren
id|p
op_add_assign
l_int|5
suffix:semicolon
id|strcpy
c_func
(paren
id|root_device_name
comma
id|p
)paren
suffix:semicolon
)brace
id|is_floppy
op_assign
id|MAJOR
c_func
(paren
id|ROOT_DEV
)paren
op_eq
id|FLOPPY_MAJOR
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_if
c_cond
(paren
op_logical_neg
id|initrd_start
)paren
id|mount_initrd
op_assign
l_int|0
suffix:semicolon
id|real_root_dev
op_assign
id|ROOT_DEV
suffix:semicolon
macro_line|#endif
id|create_dev
c_func
(paren
l_string|&quot;/dev/root&quot;
comma
id|ROOT_DEV
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* This has to be before mounting root, because even readonly mount of reiserfs would replay&n;&t;   log corrupting stuff */
id|software_resume
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mount_initrd
)paren
(brace
r_if
c_cond
(paren
id|initrd_load
c_func
(paren
)paren
op_logical_and
id|ROOT_DEV
op_ne
id|Root_RAM0
)paren
(brace
id|handle_initrd
c_func
(paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|is_floppy
op_logical_and
id|rd_doload
op_logical_and
id|rd_load_disk
c_func
(paren
l_int|0
)paren
)paren
id|ROOT_DEV
op_assign
id|Root_RAM0
suffix:semicolon
id|mount_root
c_func
(paren
)paren
suffix:semicolon
id|out
suffix:colon
id|sys_umount
c_func
(paren
l_string|&quot;/dev&quot;
comma
l_int|0
)paren
suffix:semicolon
id|sys_mount
c_func
(paren
l_string|&quot;.&quot;
comma
l_string|&quot;/&quot;
comma
l_int|NULL
comma
id|MS_MOVE
comma
l_int|NULL
)paren
suffix:semicolon
id|sys_chroot
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
id|security_sb_post_mountroot
c_func
(paren
)paren
suffix:semicolon
id|mount_devfs_fs
(paren
)paren
suffix:semicolon
)brace
macro_line|#if defined(BUILD_CRAMDISK) &amp;&amp; defined(CONFIG_BLK_DEV_RAM)
multiline_comment|/*&n; * gzip declarations&n; */
DECL|macro|OF
mdefine_line|#define OF(args)  args
macro_line|#ifndef memzero
DECL|macro|memzero
mdefine_line|#define memzero(s, n)     memset ((s), 0, (n))
macro_line|#endif
DECL|typedef|uch
r_typedef
r_int
r_char
id|uch
suffix:semicolon
DECL|typedef|ush
r_typedef
r_int
r_int
id|ush
suffix:semicolon
DECL|typedef|ulg
r_typedef
r_int
r_int
id|ulg
suffix:semicolon
DECL|macro|INBUFSIZ
mdefine_line|#define INBUFSIZ 4096
DECL|macro|WSIZE
mdefine_line|#define WSIZE 0x8000    /* window size--must be a power of two, and */
multiline_comment|/*  at least 32K for zip&squot;s deflate method */
DECL|variable|inbuf
r_static
id|uch
op_star
id|inbuf
suffix:semicolon
DECL|variable|window
r_static
id|uch
op_star
id|window
suffix:semicolon
DECL|variable|insize
r_static
r_int
id|insize
suffix:semicolon
multiline_comment|/* valid bytes in inbuf */
DECL|variable|inptr
r_static
r_int
id|inptr
suffix:semicolon
multiline_comment|/* index of next byte to be processed in inbuf */
DECL|variable|outcnt
r_static
r_int
id|outcnt
suffix:semicolon
multiline_comment|/* bytes in output buffer */
DECL|variable|exit_code
r_static
r_int
id|exit_code
suffix:semicolon
DECL|variable|bytes_out
r_static
r_int
id|bytes_out
suffix:semicolon
DECL|variable|crd_infd
DECL|variable|crd_outfd
r_static
r_int
id|crd_infd
comma
id|crd_outfd
suffix:semicolon
DECL|macro|get_byte
mdefine_line|#define get_byte()  (inptr &lt; insize ? inbuf[inptr++] : fill_inbuf())
multiline_comment|/* Diagnostic functions (stubbed out) */
DECL|macro|Assert
mdefine_line|#define Assert(cond,msg)
DECL|macro|Trace
mdefine_line|#define Trace(x)
DECL|macro|Tracev
mdefine_line|#define Tracev(x)
DECL|macro|Tracevv
mdefine_line|#define Tracevv(x)
DECL|macro|Tracec
mdefine_line|#define Tracec(c,x)
DECL|macro|Tracecv
mdefine_line|#define Tracecv(c,x)
DECL|macro|STATIC
mdefine_line|#define STATIC static
r_static
r_int
id|fill_inbuf
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|flush_window
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
op_star
id|malloc
c_func
(paren
r_int
id|size
)paren
suffix:semicolon
r_static
r_void
id|free
c_func
(paren
r_void
op_star
id|where
)paren
suffix:semicolon
r_static
r_void
id|error
c_func
(paren
r_char
op_star
id|m
)paren
suffix:semicolon
r_static
r_void
id|gzip_mark
c_func
(paren
r_void
op_star
op_star
)paren
suffix:semicolon
r_static
r_void
id|gzip_release
c_func
(paren
r_void
op_star
op_star
)paren
suffix:semicolon
macro_line|#include &quot;../lib/inflate.c&quot;
DECL|function|malloc
r_static
r_void
id|__init
op_star
id|malloc
c_func
(paren
r_int
id|size
)paren
(brace
r_return
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
DECL|function|free
r_static
r_void
id|__init
id|free
c_func
(paren
r_void
op_star
id|where
)paren
(brace
id|kfree
c_func
(paren
id|where
)paren
suffix:semicolon
)brace
DECL|function|gzip_mark
r_static
r_void
id|__init
id|gzip_mark
c_func
(paren
r_void
op_star
op_star
id|ptr
)paren
(brace
)brace
DECL|function|gzip_release
r_static
r_void
id|__init
id|gzip_release
c_func
(paren
r_void
op_star
op_star
id|ptr
)paren
(brace
)brace
multiline_comment|/* ===========================================================================&n; * Fill the input buffer. This is called only when the buffer is empty&n; * and at least one byte is really needed.&n; */
DECL|function|fill_inbuf
r_static
r_int
id|__init
id|fill_inbuf
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|exit_code
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|insize
op_assign
id|read
c_func
(paren
id|crd_infd
comma
id|inbuf
comma
id|INBUFSIZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|insize
op_eq
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|inptr
op_assign
l_int|1
suffix:semicolon
r_return
id|inbuf
(braket
l_int|0
)braket
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Write the output window window[0..outcnt-1] and update crc and bytes_out.&n; * (Used for the decompressed data only.)&n; */
DECL|function|flush_window
r_static
r_void
id|__init
id|flush_window
c_func
(paren
r_void
)paren
(brace
id|ulg
id|c
op_assign
id|crc
suffix:semicolon
multiline_comment|/* temporary variable */
r_int
id|n
suffix:semicolon
id|uch
op_star
id|in
comma
id|ch
suffix:semicolon
id|write
c_func
(paren
id|crd_outfd
comma
id|window
comma
id|outcnt
)paren
suffix:semicolon
id|in
op_assign
id|window
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|outcnt
suffix:semicolon
id|n
op_increment
)paren
(brace
id|ch
op_assign
op_star
id|in
op_increment
suffix:semicolon
id|c
op_assign
id|crc_32_tab
(braket
(paren
(paren
r_int
)paren
id|c
op_xor
id|ch
)paren
op_amp
l_int|0xff
)braket
op_xor
(paren
id|c
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
id|crc
op_assign
id|c
suffix:semicolon
id|bytes_out
op_add_assign
(paren
id|ulg
)paren
id|outcnt
suffix:semicolon
id|outcnt
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|error
r_static
r_void
id|__init
id|error
c_func
(paren
r_char
op_star
id|x
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s&quot;
comma
id|x
)paren
suffix:semicolon
id|exit_code
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|crd_load
r_static
r_int
id|__init
id|crd_load
c_func
(paren
r_int
id|in_fd
comma
r_int
id|out_fd
)paren
(brace
r_int
id|result
suffix:semicolon
id|insize
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* valid bytes in inbuf */
id|inptr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* index of next byte to be processed in inbuf */
id|outcnt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* bytes in output buffer */
id|exit_code
op_assign
l_int|0
suffix:semicolon
id|bytes_out
op_assign
l_int|0
suffix:semicolon
id|crc
op_assign
(paren
id|ulg
)paren
l_int|0xffffffffL
suffix:semicolon
multiline_comment|/* shift register contents */
id|crd_infd
op_assign
id|in_fd
suffix:semicolon
id|crd_outfd
op_assign
id|out_fd
suffix:semicolon
id|inbuf
op_assign
id|kmalloc
c_func
(paren
id|INBUFSIZ
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inbuf
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;RAMDISK: Couldn&squot;t allocate gzip buffer&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|window
op_assign
id|kmalloc
c_func
(paren
id|WSIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|window
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;RAMDISK: Couldn&squot;t allocate gzip window&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|inbuf
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|makecrc
c_func
(paren
)paren
suffix:semicolon
id|result
op_assign
id|gunzip
c_func
(paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|inbuf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|window
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
macro_line|#endif  /* BUILD_CRAMDISK &amp;&amp; CONFIG_BLK_DEV_RAM */
macro_line|#ifdef CONFIG_BLK_DEV_MD
multiline_comment|/*&n; * When md (and any require personalities) are compiled into the kernel&n; * (not a module), arrays can be assembles are boot time using with AUTODETECT&n; * where specially marked partitions are registered with md_autodetect_dev(),&n; * and with MD_BOOT where devices to be collected are given on the boot line&n; * with md=.....&n; * The code for that is here.&n; */
r_struct
(brace
DECL|member|set
r_int
id|set
suffix:semicolon
DECL|member|noautodetect
r_int
id|noautodetect
suffix:semicolon
DECL|variable|__initdata
)brace
id|raid_setup_args
id|__initdata
suffix:semicolon
r_static
r_struct
(brace
DECL|member|device_set
r_char
id|device_set
(braket
id|MAX_MD_DEVS
)braket
suffix:semicolon
DECL|member|pers
r_int
id|pers
(braket
id|MAX_MD_DEVS
)braket
suffix:semicolon
DECL|member|chunk
r_int
id|chunk
(braket
id|MAX_MD_DEVS
)braket
suffix:semicolon
DECL|member|device_names
r_char
op_star
id|device_names
(braket
id|MAX_MD_DEVS
)braket
suffix:semicolon
DECL|variable|__initdata
)brace
id|md_setup_args
id|__initdata
suffix:semicolon
multiline_comment|/*&n; * Parse the command-line parameters given our kernel, but do not&n; * actually try to invoke the MD device now; that is handled by&n; * md_setup_drive after the low-level disk drivers have initialised.&n; *&n; * 27/11/1999: Fixed to work correctly with the 2.3 kernel (which&n; *             assigns the task of parsing integer arguments to the&n; *             invoked program now).  Added ability to initialise all&n; *             the MD devices (by specifying multiple &quot;md=&quot; lines)&n; *             instead of just one.  -- KTK&n; * 18May2000: Added support for persistent-superblock arrays:&n; *             md=n,0,factor,fault,device-list   uses RAID0 for device n&n; *             md=n,-1,factor,fault,device-list  uses LINEAR for device n&n; *             md=n,device-list      reads a RAID superblock from the devices&n; *             elements in device-list are read by name_to_kdev_t so can be&n; *             a hex number or something like /dev/hda1 /dev/sdb&n; * 2001-06-03: Dave Cinege &lt;dcinege@psychosis.com&gt;&n; *&t;&t;Shifted name_to_kdev_t() and related operations to md_set_drive()&n; *&t;&t;for later execution. Rewrote section to make devfs compatible.&n; */
DECL|function|md_setup
r_static
r_int
id|__init
id|md_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|minor
comma
id|level
comma
id|factor
comma
id|fault
comma
id|pers
suffix:semicolon
r_char
op_star
id|pername
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_char
op_star
id|str1
op_assign
id|str
suffix:semicolon
r_if
c_cond
(paren
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|minor
)paren
op_ne
l_int|2
)paren
(brace
multiline_comment|/* MD Number */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: Too few arguments supplied to md=.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|minor
op_ge
id|MAX_MD_DEVS
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: md=%d, Minor device number too high.&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|md_setup_args.device_names
(braket
id|minor
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: md=%d, Specified more than once. &quot;
l_string|&quot;Replacing previous definition.&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|level
)paren
)paren
(brace
multiline_comment|/* RAID Personality */
r_case
l_int|2
suffix:colon
multiline_comment|/* could be 0 or -1.. */
r_if
c_cond
(paren
id|level
op_eq
l_int|0
op_logical_or
id|level
op_eq
id|LEVEL_LINEAR
)paren
(brace
r_if
c_cond
(paren
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|factor
)paren
op_ne
l_int|2
op_logical_or
multiline_comment|/* Chunk Size */
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|fault
)paren
op_ne
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: Too few arguments supplied to md=.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|md_setup_args.pers
(braket
id|minor
)braket
op_assign
id|level
suffix:semicolon
id|md_setup_args.chunk
(braket
id|minor
)braket
op_assign
l_int|1
op_lshift
(paren
id|factor
op_plus
l_int|12
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|level
)paren
(brace
r_case
id|LEVEL_LINEAR
suffix:colon
id|pers
op_assign
id|LINEAR
suffix:semicolon
id|pername
op_assign
l_string|&quot;linear&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
id|pers
op_assign
id|RAID0
suffix:semicolon
id|pername
op_assign
l_string|&quot;raid0&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: The kernel has not been configured for raid%d support!&bslash;n&quot;
comma
id|level
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|md_setup_args.pers
(braket
id|minor
)braket
op_assign
id|pers
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* FALL THROUGH */
r_case
l_int|1
suffix:colon
multiline_comment|/* the first device is numeric */
id|str
op_assign
id|str1
suffix:semicolon
multiline_comment|/* FALL THROUGH */
r_case
l_int|0
suffix:colon
id|md_setup_args.pers
(braket
id|minor
)braket
op_assign
l_int|0
suffix:semicolon
id|pername
op_assign
l_string|&quot;super-block&quot;
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: Will configure md%d (%s) from %s, below.&bslash;n&quot;
comma
id|minor
comma
id|pername
comma
id|str
)paren
suffix:semicolon
id|md_setup_args.device_names
(braket
id|minor
)braket
op_assign
id|str
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|md_setup_drive
r_static
r_void
id|__init
id|md_setup_drive
c_func
(paren
r_void
)paren
(brace
r_int
id|minor
comma
id|i
suffix:semicolon
id|dev_t
id|dev
suffix:semicolon
id|dev_t
id|devices
(braket
id|MD_SB_DISKS
op_plus
l_int|1
)braket
suffix:semicolon
r_for
c_loop
(paren
id|minor
op_assign
l_int|0
suffix:semicolon
id|minor
OL
id|MAX_MD_DEVS
suffix:semicolon
id|minor
op_increment
)paren
(brace
r_int
id|fd
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|devname
suffix:semicolon
id|mdu_disk_info_t
id|dinfo
suffix:semicolon
r_char
id|name
(braket
l_int|16
)braket
comma
id|devfs_name
(braket
l_int|16
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|devname
op_assign
id|md_setup_args.device_names
(braket
id|minor
)braket
)paren
)paren
r_continue
suffix:semicolon
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;/dev/md%d&quot;
comma
id|minor
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|devfs_name
comma
l_string|&quot;/dev/md/%d&quot;
comma
id|minor
)paren
suffix:semicolon
id|create_dev
c_func
(paren
id|name
comma
id|MKDEV
c_func
(paren
id|MD_MAJOR
comma
id|minor
)paren
comma
id|devfs_name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
op_logical_and
id|devname
op_ne
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
r_char
id|comp_name
(braket
l_int|64
)braket
suffix:semicolon
r_struct
id|stat
id|buf
suffix:semicolon
id|p
op_assign
id|strchr
c_func
(paren
id|devname
comma
l_char|&squot;,&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
op_star
id|p
op_increment
op_assign
l_int|0
suffix:semicolon
id|dev
op_assign
id|name_to_dev_t
c_func
(paren
id|devname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|devname
comma
l_string|&quot;/dev/&quot;
comma
l_int|5
)paren
)paren
id|devname
op_add_assign
l_int|5
suffix:semicolon
id|snprintf
c_func
(paren
id|comp_name
comma
l_int|63
comma
l_string|&quot;/dev/%s&quot;
comma
id|devname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sys_newstat
c_func
(paren
id|comp_name
comma
op_amp
id|buf
)paren
op_eq
l_int|0
op_logical_and
id|S_ISBLK
c_func
(paren
id|buf.st_mode
)paren
)paren
id|dev
op_assign
id|buf.st_rdev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: Unknown device name: %s&bslash;n&quot;
comma
id|devname
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|devices
(braket
id|i
)braket
op_assign
id|dev
suffix:semicolon
id|md_setup_args.device_set
(braket
id|minor
)braket
op_assign
l_int|1
suffix:semicolon
id|devname
op_assign
id|p
suffix:semicolon
)brace
id|devices
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|md_setup_args.device_set
(braket
id|minor
)braket
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: Loading md%d: %s&bslash;n&quot;
comma
id|minor
comma
id|md_setup_args.device_names
(braket
id|minor
)braket
)paren
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|name
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;md: open failed - cannot start array %d&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sys_ioctl
c_func
(paren
id|fd
comma
id|SET_ARRAY_INFO
comma
l_int|0
)paren
op_eq
op_minus
id|EBUSY
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: Ignoring md=%d, already autodetected. (Use raid=noautodetect)&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|md_setup_args.pers
(braket
id|minor
)braket
)paren
(brace
multiline_comment|/* non-persistent */
id|mdu_array_info_t
id|ainfo
suffix:semicolon
id|ainfo.level
op_assign
id|pers_to_level
c_func
(paren
id|md_setup_args.pers
(braket
id|minor
)braket
)paren
suffix:semicolon
id|ainfo.size
op_assign
l_int|0
suffix:semicolon
id|ainfo.nr_disks
op_assign
l_int|0
suffix:semicolon
id|ainfo.raid_disks
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|devices
(braket
id|ainfo.raid_disks
)braket
)paren
id|ainfo.raid_disks
op_increment
suffix:semicolon
id|ainfo.md_minor
op_assign
id|minor
suffix:semicolon
id|ainfo.not_persistent
op_assign
l_int|1
suffix:semicolon
id|ainfo.state
op_assign
(paren
l_int|1
op_lshift
id|MD_SB_CLEAN
)paren
suffix:semicolon
id|ainfo.layout
op_assign
l_int|0
suffix:semicolon
id|ainfo.chunk_size
op_assign
id|md_setup_args.chunk
(braket
id|minor
)braket
suffix:semicolon
id|err
op_assign
id|sys_ioctl
c_func
(paren
id|fd
comma
id|SET_ARRAY_INFO
comma
(paren
r_int
)paren
op_amp
id|ainfo
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|err
op_logical_and
id|i
op_le
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev
op_assign
id|devices
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_break
suffix:semicolon
id|dinfo.number
op_assign
id|i
suffix:semicolon
id|dinfo.raid_disk
op_assign
id|i
suffix:semicolon
id|dinfo.state
op_assign
(paren
l_int|1
op_lshift
id|MD_DISK_ACTIVE
)paren
op_or
(paren
l_int|1
op_lshift
id|MD_DISK_SYNC
)paren
suffix:semicolon
id|dinfo.major
op_assign
id|MAJOR
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dinfo.minor
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
suffix:semicolon
id|err
op_assign
id|sys_ioctl
c_func
(paren
id|fd
comma
id|ADD_NEW_DISK
comma
(paren
r_int
)paren
op_amp
id|dinfo
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* persistent */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev
op_assign
id|devices
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_break
suffix:semicolon
id|dinfo.major
op_assign
id|MAJOR
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dinfo.minor
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
suffix:semicolon
id|sys_ioctl
c_func
(paren
id|fd
comma
id|ADD_NEW_DISK
comma
(paren
r_int
)paren
op_amp
id|dinfo
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
id|sys_ioctl
c_func
(paren
id|fd
comma
id|RUN_ARRAY
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;md: starting md%d failed&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
)brace
DECL|function|raid_setup
r_static
r_int
id|__init
id|raid_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|len
comma
id|pos
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|str
)paren
op_plus
l_int|1
suffix:semicolon
id|pos
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|pos
OL
id|len
)paren
(brace
r_char
op_star
id|comma
op_assign
id|strchr
c_func
(paren
id|str
op_plus
id|pos
comma
l_char|&squot;,&squot;
)paren
suffix:semicolon
r_int
id|wlen
suffix:semicolon
r_if
c_cond
(paren
id|comma
)paren
id|wlen
op_assign
(paren
id|comma
op_minus
id|str
)paren
op_minus
id|pos
suffix:semicolon
r_else
id|wlen
op_assign
(paren
id|len
op_minus
l_int|1
)paren
op_minus
id|pos
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|str
comma
l_string|&quot;noautodetect&quot;
comma
id|wlen
)paren
)paren
id|raid_setup_args.noautodetect
op_assign
l_int|1
suffix:semicolon
id|pos
op_add_assign
id|wlen
op_plus
l_int|1
suffix:semicolon
)brace
id|raid_setup_args.set
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;raid=&quot;
comma
id|raid_setup
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;md=&quot;
comma
id|md_setup
)paren
suffix:semicolon
macro_line|#endif
DECL|function|md_run_setup
r_static
r_void
id|__init
id|md_run_setup
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_MD
id|create_dev
c_func
(paren
l_string|&quot;/dev/md0&quot;
comma
id|MKDEV
c_func
(paren
id|MD_MAJOR
comma
l_int|0
)paren
comma
l_string|&quot;md/0&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|raid_setup_args.noautodetect
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;md: Skipping autodetection of RAID arrays. (raid=noautodetect)&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
r_int
id|fd
op_assign
id|open
c_func
(paren
l_string|&quot;/dev/md0&quot;
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
op_ge
l_int|0
)paren
(brace
id|sys_ioctl
c_func
(paren
id|fd
comma
id|RAID_AUTORUN
comma
l_int|0
)paren
suffix:semicolon
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
)brace
id|md_setup_drive
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
eof
