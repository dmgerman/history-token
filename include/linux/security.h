multiline_comment|/*&n; * Linux Security plug&n; *&n; * Copyright (C) 2001 WireX Communications, Inc &lt;chris@wirex.com&gt;&n; * Copyright (C) 2001 Greg Kroah-Hartman &lt;greg@kroah.com&gt;&n; * Copyright (C) 2001 Networks Associates Technology, Inc &lt;ssmalley@nai.com&gt;&n; * Copyright (C) 2001 James Morris &lt;jmorris@intercode.com.au&gt;&n; * Copyright (C) 2001 Silicon Graphics, Inc. (Trust Technology Group)&n; *&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2 of the License, or&n; *&t;(at your option) any later version.&n; *&n; *&t;Due to this file being licensed under the GPL there is controversy over&n; *&t;whether this permits you to write a module that #includes this file&n; *&t;without placing your module under the GPL.  Please consult a lawyer for&n; *&t;advice before doing this.&n; *&n; */
macro_line|#ifndef __LINUX_SECURITY_H
DECL|macro|__LINUX_SECURITY_H
mdefine_line|#define __LINUX_SECURITY_H
macro_line|#ifdef __KERNEL__
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/binfmts.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/resource.h&gt;
macro_line|#include &lt;linux/sem.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;linux/shm.h&gt;
macro_line|#include &lt;linux/msg.h&gt;
multiline_comment|/*&n; * Values used in the task_security_ops calls&n; */
multiline_comment|/* setuid or setgid, id0 == uid or gid */
DECL|macro|LSM_SETID_ID
mdefine_line|#define LSM_SETID_ID&t;1
multiline_comment|/* setreuid or setregid, id0 == real, id1 == eff */
DECL|macro|LSM_SETID_RE
mdefine_line|#define LSM_SETID_RE&t;2
multiline_comment|/* setresuid or setresgid, id0 == real, id1 == eff, uid2 == saved */
DECL|macro|LSM_SETID_RES
mdefine_line|#define LSM_SETID_RES&t;4
multiline_comment|/* setfsuid or setfsgid, id0 == fsuid or fsgid */
DECL|macro|LSM_SETID_FS
mdefine_line|#define LSM_SETID_FS&t;8
multiline_comment|/* forward declares to avoid warnings */
r_struct
id|sk_buff
suffix:semicolon
r_struct
id|net_device
suffix:semicolon
r_struct
id|nfsctl_arg
suffix:semicolon
r_struct
id|sched_param
suffix:semicolon
r_struct
id|swap_info_struct
suffix:semicolon
multiline_comment|/**&n; * struct security_operations - main security structure&n; *&n; * Security hooks for program execution operations.&n; *&n; * @bprm_alloc_security:&n; *&t;Allocate and attach a security structure to the @bprm-&gt;security field.&n; *&t;The security field is initialized to NULL when the bprm structure is&n; *&t;allocated.&n; *&t;@bprm contains the linux_binprm structure to be modified.&n; *&t;Return 0 if operation was successful.&n; * @bprm_free_security:&n; *&t;@bprm contains the linux_binprm structure to be modified.&n; *&t;Deallocate and clear the @bprm-&gt;security field.&n; * @bprm_compute_creds:&n; *&t;Compute and set the security attributes of a process being transformed&n; *&t;by an execve operation based on the old attributes (current-&gt;security)&n; *&t;and the information saved in @bprm-&gt;security by the set_security hook.&n; *&t;Since this hook function (and its caller) are void, this hook can not&n; *&t;return an error.  However, it can leave the security attributes of the&n; *&t;process unchanged if an access failure occurs at this point. It can&n; *&t;also perform other state changes on the process (e.g.  closing open&n; *&t;file descriptors to which access is no longer granted if the attributes&n; *&t;were changed). &n; *&t;@bprm contains the linux_binprm structure.&n; * @bprm_set_security:&n; *&t;Save security information in the bprm-&gt;security field, typically based&n; *&t;on information about the bprm-&gt;file, for later use by the compute_creds&n; *&t;hook.  This hook may also optionally check permissions (e.g. for&n; *&t;transitions between security domains).&n; *&t;This hook may be called multiple times during a single execve, e.g. for&n; *&t;interpreters.  The hook can tell whether it has already been called by&n; *&t;checking to see if @bprm-&gt;security is non-NULL.  If so, then the hook&n; *&t;may decide either to retain the security information saved earlier or&n; *&t;to replace it.&n; *&t;@bprm contains the linux_binprm structure.&n; *&t;Return 0 if the hook is successful and permission is granted.&n; * @bprm_check_security:&n; * &t;This hook mediates the point when a search for a binary handler&t;will&n; * &t;begin.  It allows a check the @bprm-&gt;security value which is set in&n; * &t;the preceding set_security call.  The primary difference from&n; * &t;set_security is that the argv list and envp list are reliably&n; * &t;available in @bprm.  This hook may be called multiple times&n; * &t;during a single execve; and in each pass set_security is called&n; * &t;first.&n; * &t;@bprm contains the linux_binprm structure.&n; *&t;Return 0 if the hook is successful and permission is granted.&n; *&n; * Security hooks for task operations.&n; *&n; * @task_create:&n; *&t;Check permission before creating a child process.  See the clone(2)&n; *&t;manual page for definitions of the @clone_flags.&n; *&t;@clone_flags contains the flags indicating what should be shared.&n; *&t;Return 0 if permission is granted.&n; * @task_alloc_security:&n; *&t;@p contains the task_struct for child process.&n; *&t;Allocate and attach a security structure to the p-&gt;security field. The&n; *&t;security field is initialized to NULL when the task structure is&n; *&t;allocated.&n; *&t;Return 0 if operation was successful.&n; * @task_free_security:&n; *&t;@p contains the task_struct for process.&n; *&t;Deallocate and clear the p-&gt;security field.&n; * @task_setuid:&n; *&t;Check permission before setting one or more of the user identity&n; *&t;attributes of the current process.  The @flags parameter indicates&n; *&t;which of the set*uid system calls invoked this hook and how to&n; *&t;interpret the @id0, @id1, and @id2 parameters.  See the LSM_SETID&n; *&t;definitions at the beginning of this file for the @flags values and&n; *&t;their meanings.&n; *&t;@id0 contains a uid.&n; *&t;@id1 contains a uid.&n; *&t;@id2 contains a uid.&n; *&t;@flags contains one of the LSM_SETID_* values.&n; *&t;Return 0 if permission is granted.&n; * @task_post_setuid:&n; *&t;Update the module&squot;s state after setting one or more of the user&n; *&t;identity attributes of the current process.  The @flags parameter&n; *&t;indicates which of the set*uid system calls invoked this hook.  If&n; *&t;@flags is LSM_SETID_FS, then @old_ruid is the old fs uid and the other&n; *&t;parameters are not used.&n; *&t;@old_ruid contains the old real uid (or fs uid if LSM_SETID_FS).&n; *&t;@old_euid contains the old effective uid (or -1 if LSM_SETID_FS).&n; *&t;@old_suid contains the old saved uid (or -1 if LSM_SETID_FS).&n; *&t;@flags contains one of the LSM_SETID_* values.&n; *&t;Return 0 on success.&n; * @task_setgid:&n; *&t;Check permission before setting one or more of the group identity&n; *&t;attributes of the current process.  The @flags parameter indicates&n; *&t;which of the set*gid system calls invoked this hook and how to&n; *&t;interpret the @id0, @id1, and @id2 parameters.  See the LSM_SETID&n; *&t;definitions at the beginning of this file for the @flags values and&n; *&t;their meanings.&n; *&t;@id0 contains a gid.&n; *&t;@id1 contains a gid.&n; *&t;@id2 contains a gid.&n; *&t;@flags contains one of the LSM_SETID_* values.&n; *&t;Return 0 if permission is granted.&n; * @task_setpgid:&n; *&t;Check permission before setting the process group identifier of the&n; *&t;process @p to @pgid.&n; *&t;@p contains the task_struct for process being modified.&n; *&t;@pgid contains the new pgid.&n; *&t;Return 0 if permission is granted.&n; * @task_getpgid:&n; *&t;Check permission before getting the process group identifier of the&n; *&t;process @p.&n; *&t;@p contains the task_struct for the process.&n; *&t;Return 0 if permission is granted.&n; * @task_getsid:&n; *&t;Check permission before getting the session identifier of the process&n; *&t;@p.&n; *&t;@p contains the task_struct for the process.&n; *&t;Return 0 if permission is granted.&n; * @task_setgroups:&n; *&t;Check permission before setting the supplementary group set of the&n; *&t;current process to @grouplist.&n; *&t;@gidsetsize contains the number of elements in @grouplist.&n; *&t;@grouplist contains the array of gids.&n; *&t;Return 0 if permission is granted.&n; * @task_setnice:&n; *&t;Check permission before setting the nice value of @p to @nice.&n; *&t;@p contains the task_struct of process.&n; *&t;@nice contains the new nice value.&n; *&t;Return 0 if permission is granted.&n; * @task_setrlimit:&n; *&t;Check permission before setting the resource limits of the current&n; *&t;process for @resource to @new_rlim.  The old resource limit values can&n; *&t;be examined by dereferencing (current-&gt;rlim + resource).&n; *&t;@resource contains the resource whose limit is being set.&n; *&t;@new_rlim contains the new limits for @resource.&n; *&t;Return 0 if permission is granted.&n; * @task_setscheduler:&n; *&t;Check permission before setting scheduling policy and/or parameters of&n; *&t;process @p based on @policy and @lp.&n; *&t;@p contains the task_struct for process.&n; *&t;@policy contains the scheduling policy.&n; *&t;@lp contains the scheduling parameters.&n; *&t;Return 0 if permission is granted.&n; * @task_getscheduler:&n; *&t;Check permission before obtaining scheduling information for process&n; *&t;@p.&n; *&t;@p contains the task_struct for process.&n; *&t;Return 0 if permission is granted.&n; * @task_kill:&n; *&t;Check permission before sending signal @sig to @p.  @info can be NULL,&n; *&t;the constant 1, or a pointer to a siginfo structure.  If @info is 1 or&n; *&t;SI_FROMKERNEL(info) is true, then the signal should be viewed as coming&n; *&t;from the kernel and should typically be permitted.&n; *&t;SIGIO signals are handled separately by the send_sigiotask hook in&n; *&t;file_security_ops.&n; *&t;@p contains the task_struct for process.&n; *&t;@info contains the signal information.&n; *&t;@sig contains the signal value.&n; *&t;Return 0 if permission is granted.&n; * @task_wait:&n; *&t;Check permission before allowing a process to reap a child process @p&n; *&t;and collect its status information.&n; *&t;@p contains the task_struct for process.&n; *&t;Return 0 if permission is granted.&n; * @task_prctl:&n; *&t;Check permission before performing a process control operation on the&n; *&t;current process.&n; *&t;@option contains the operation.&n; *&t;@arg2 contains a argument.&n; *&t;@arg3 contains a argument.&n; *&t;@arg4 contains a argument.&n; *&t;@arg5 contains a argument.&n; *&t;Return 0 if permission is granted.&n; * @task_kmod_set_label:&n; *&t;Set the security attributes in current-&gt;security for the kernel module&n; *&t;loader thread, so that it has the permissions needed to perform its&n; *&t;function.&n; * @task_reparent_to_init:&n; * &t;Set the security attributes in @p-&gt;security for a kernel thread that&n; * &t;is being reparented to the init task.&n; *&t;@p contains the task_struct for the kernel thread.&n; *&n; * @ptrace:&n; *&t;Check permission before allowing the @parent process to trace the&n; *&t;@child process.&n; *&t;Security modules may also want to perform a process tracing check&n; *&t;during an execve in the set_security or compute_creds hooks of&n; *&t;binprm_security_ops if the process is being traced and its security&n; *&t;attributes would be changed by the execve.&n; *&t;@parent contains the task_struct structure for parent process.&n; *&t;@child contains the task_struct structure for child process.&n; *&t;Return 0 if permission is granted.&n; * @capget:&n; *&t;Get the @effective, @inheritable, and @permitted capability sets for&n; *&t;the @target process.  The hook may also perform permission checking to&n; *&t;determine if the current process is allowed to see the capability sets&n; *&t;of the @target process.&n; *&t;@target contains the task_struct structure for target process.&n; *&t;@effective contains the effective capability set.&n; *&t;@inheritable contains the inheritable capability set.&n; *&t;@permitted contains the permitted capability set.&n; *&t;Return 0 if the capability sets were successfully obtained.&n; * @capset_check:&n; *&t;Check permission before setting the @effective, @inheritable, and&n; *&t;@permitted capability sets for the @target process.&n; *&t;Caveat:  @target is also set to current if a set of processes is&n; *&t;specified (i.e. all processes other than current and init or a&n; *&t;particular process group).  Hence, the capset_set hook may need to&n; *&t;revalidate permission to the actual target process.&n; *&t;@target contains the task_struct structure for target process.&n; *&t;@effective contains the effective capability set.&n; *&t;@inheritable contains the inheritable capability set.&n; *&t;@permitted contains the permitted capability set.&n; *&t;Return 0 if permission is granted.&n; * @capset_set:&n; *&t;Set the @effective, @inheritable, and @permitted capability sets for&n; *&t;the @target process.  Since capset_check cannot always check permission&n; *&t;to the real @target process, this hook may also perform permission&n; *&t;checking to determine if the current process is allowed to set the&n; *&t;capability sets of the @target process.  However, this hook has no way&n; *&t;of returning an error due to the structure of the sys_capset code.&n; *&t;@target contains the task_struct structure for target process.&n; *&t;@effective contains the effective capability set.&n; *&t;@inheritable contains the inheritable capability set.&n; *&t;@permitted contains the permitted capability set.&n; * @capable:&n; *&t;Check whether the @tsk process has the @cap capability.&n; *&t;@tsk contains the task_struct for the process.&n; *&t;@cap contains the capability &lt;include/linux/capability.h&gt;.&n; *&t;Return 0 if the capability is granted for @tsk.&n; * @sys_security:&n; *&t;Security modules may use this hook to implement new system calls for&n; *&t;security-aware applications.  The interface is similar to socketcall,&n; *&t;but with an @id parameter to help identify the security module whose&n; *&t;call is being invoked.  The module is responsible for interpreting the&n; *&t;parameters, and must copy in the @args array from user space if it is&n; *&t;used.&n; *&t;The recommended convention for creating the hexadecimal @id value is&n; *&t;echo &quot;Name_of_module&quot; | md5sum | cut -c -8; by using this convention,&n; *&t;there is no need for a central registry.&n; *&t;@id contains the security module identifier.&n; *&t;@call contains the call value.&n; *&t;@args contains the call arguments (user space pointer).&n; *&t;The module should return -ENOSYS if it does not implement any new&n; *&t;system calls.&n; *&n; * @register_security:&n; * &t;allow module stacking.&n; * &t;@name contains the name of the security module being stacked.&n; * &t;@ops contains a pointer to the struct security_operations of the module to stack.&n; * @unregister_security:&n; *&t;remove a stacked module.&n; *&t;@name contains the name of the security module being unstacked.&n; *&t;@ops contains a pointer to the struct security_operations of the module to unstack.&n; * &n; * This is the main security structure.&n; */
DECL|struct|security_operations
r_struct
id|security_operations
(brace
DECL|member|ptrace
r_int
(paren
op_star
id|ptrace
)paren
(paren
r_struct
id|task_struct
op_star
id|parent
comma
r_struct
id|task_struct
op_star
id|child
)paren
suffix:semicolon
DECL|member|capget
r_int
(paren
op_star
id|capget
)paren
(paren
r_struct
id|task_struct
op_star
id|target
comma
id|kernel_cap_t
op_star
id|effective
comma
id|kernel_cap_t
op_star
id|inheritable
comma
id|kernel_cap_t
op_star
id|permitted
)paren
suffix:semicolon
DECL|member|capset_check
r_int
(paren
op_star
id|capset_check
)paren
(paren
r_struct
id|task_struct
op_star
id|target
comma
id|kernel_cap_t
op_star
id|effective
comma
id|kernel_cap_t
op_star
id|inheritable
comma
id|kernel_cap_t
op_star
id|permitted
)paren
suffix:semicolon
DECL|member|capset_set
r_void
(paren
op_star
id|capset_set
)paren
(paren
r_struct
id|task_struct
op_star
id|target
comma
id|kernel_cap_t
op_star
id|effective
comma
id|kernel_cap_t
op_star
id|inheritable
comma
id|kernel_cap_t
op_star
id|permitted
)paren
suffix:semicolon
DECL|member|capable
r_int
(paren
op_star
id|capable
)paren
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
id|cap
)paren
suffix:semicolon
DECL|member|sys_security
r_int
(paren
op_star
id|sys_security
)paren
(paren
r_int
r_int
id|id
comma
r_int
id|call
comma
r_int
r_int
op_star
id|args
)paren
suffix:semicolon
DECL|member|bprm_alloc_security
r_int
(paren
op_star
id|bprm_alloc_security
)paren
(paren
r_struct
id|linux_binprm
op_star
id|bprm
)paren
suffix:semicolon
DECL|member|bprm_free_security
r_void
(paren
op_star
id|bprm_free_security
)paren
(paren
r_struct
id|linux_binprm
op_star
id|bprm
)paren
suffix:semicolon
DECL|member|bprm_compute_creds
r_void
(paren
op_star
id|bprm_compute_creds
)paren
(paren
r_struct
id|linux_binprm
op_star
id|bprm
)paren
suffix:semicolon
DECL|member|bprm_set_security
r_int
(paren
op_star
id|bprm_set_security
)paren
(paren
r_struct
id|linux_binprm
op_star
id|bprm
)paren
suffix:semicolon
DECL|member|bprm_check_security
r_int
(paren
op_star
id|bprm_check_security
)paren
(paren
r_struct
id|linux_binprm
op_star
id|bprm
)paren
suffix:semicolon
DECL|member|task_create
r_int
(paren
op_star
id|task_create
)paren
(paren
r_int
r_int
id|clone_flags
)paren
suffix:semicolon
DECL|member|task_alloc_security
r_int
(paren
op_star
id|task_alloc_security
)paren
(paren
r_struct
id|task_struct
op_star
id|p
)paren
suffix:semicolon
DECL|member|task_free_security
r_void
(paren
op_star
id|task_free_security
)paren
(paren
r_struct
id|task_struct
op_star
id|p
)paren
suffix:semicolon
DECL|member|task_setuid
r_int
(paren
op_star
id|task_setuid
)paren
(paren
id|uid_t
id|id0
comma
id|uid_t
id|id1
comma
id|uid_t
id|id2
comma
r_int
id|flags
)paren
suffix:semicolon
DECL|member|task_post_setuid
r_int
(paren
op_star
id|task_post_setuid
)paren
(paren
id|uid_t
id|old_ruid
multiline_comment|/* or fsuid */
comma
id|uid_t
id|old_euid
comma
id|uid_t
id|old_suid
comma
r_int
id|flags
)paren
suffix:semicolon
DECL|member|task_setgid
r_int
(paren
op_star
id|task_setgid
)paren
(paren
id|gid_t
id|id0
comma
id|gid_t
id|id1
comma
id|gid_t
id|id2
comma
r_int
id|flags
)paren
suffix:semicolon
DECL|member|task_setpgid
r_int
(paren
op_star
id|task_setpgid
)paren
(paren
r_struct
id|task_struct
op_star
id|p
comma
id|pid_t
id|pgid
)paren
suffix:semicolon
DECL|member|task_getpgid
r_int
(paren
op_star
id|task_getpgid
)paren
(paren
r_struct
id|task_struct
op_star
id|p
)paren
suffix:semicolon
DECL|member|task_getsid
r_int
(paren
op_star
id|task_getsid
)paren
(paren
r_struct
id|task_struct
op_star
id|p
)paren
suffix:semicolon
DECL|member|task_setgroups
r_int
(paren
op_star
id|task_setgroups
)paren
(paren
r_int
id|gidsetsize
comma
id|gid_t
op_star
id|grouplist
)paren
suffix:semicolon
DECL|member|task_setnice
r_int
(paren
op_star
id|task_setnice
)paren
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
id|nice
)paren
suffix:semicolon
DECL|member|task_setrlimit
r_int
(paren
op_star
id|task_setrlimit
)paren
(paren
r_int
r_int
id|resource
comma
r_struct
id|rlimit
op_star
id|new_rlim
)paren
suffix:semicolon
DECL|member|task_setscheduler
r_int
(paren
op_star
id|task_setscheduler
)paren
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
id|policy
comma
r_struct
id|sched_param
op_star
id|lp
)paren
suffix:semicolon
DECL|member|task_getscheduler
r_int
(paren
op_star
id|task_getscheduler
)paren
(paren
r_struct
id|task_struct
op_star
id|p
)paren
suffix:semicolon
DECL|member|task_kill
r_int
(paren
op_star
id|task_kill
)paren
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_struct
id|siginfo
op_star
id|info
comma
r_int
id|sig
)paren
suffix:semicolon
DECL|member|task_wait
r_int
(paren
op_star
id|task_wait
)paren
(paren
r_struct
id|task_struct
op_star
id|p
)paren
suffix:semicolon
DECL|member|task_prctl
r_int
(paren
op_star
id|task_prctl
)paren
(paren
r_int
id|option
comma
r_int
r_int
id|arg2
comma
r_int
r_int
id|arg3
comma
r_int
r_int
id|arg4
comma
r_int
r_int
id|arg5
)paren
suffix:semicolon
DECL|member|task_kmod_set_label
r_void
(paren
op_star
id|task_kmod_set_label
)paren
(paren
r_void
)paren
suffix:semicolon
DECL|member|task_reparent_to_init
r_void
(paren
op_star
id|task_reparent_to_init
)paren
(paren
r_struct
id|task_struct
op_star
id|p
)paren
suffix:semicolon
multiline_comment|/* allow module stacking */
DECL|member|register_security
r_int
(paren
op_star
id|register_security
)paren
(paren
r_const
r_char
op_star
id|name
comma
r_struct
id|security_operations
op_star
id|ops
)paren
suffix:semicolon
DECL|member|unregister_security
r_int
(paren
op_star
id|unregister_security
)paren
(paren
r_const
r_char
op_star
id|name
comma
r_struct
id|security_operations
op_star
id|ops
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* prototypes */
r_extern
r_int
id|security_scaffolding_startup
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|register_security
(paren
r_struct
id|security_operations
op_star
id|ops
)paren
suffix:semicolon
r_extern
r_int
id|unregister_security
(paren
r_struct
id|security_operations
op_star
id|ops
)paren
suffix:semicolon
r_extern
r_int
id|mod_reg_security
(paren
r_const
r_char
op_star
id|name
comma
r_struct
id|security_operations
op_star
id|ops
)paren
suffix:semicolon
r_extern
r_int
id|mod_unreg_security
(paren
r_const
r_char
op_star
id|name
comma
r_struct
id|security_operations
op_star
id|ops
)paren
suffix:semicolon
r_extern
r_int
id|capable
(paren
r_int
id|cap
)paren
suffix:semicolon
multiline_comment|/* global variables */
r_extern
r_struct
id|security_operations
op_star
id|security_ops
suffix:semicolon
macro_line|#endif /* __KERNEL__ */
macro_line|#endif /* ! __LINUX_SECURITY_H */
eof
