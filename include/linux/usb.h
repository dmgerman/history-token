macro_line|#ifndef __LINUX_USB_H
DECL|macro|__LINUX_USB_H
mdefine_line|#define __LINUX_USB_H
macro_line|#include &lt;linux/mod_devicetable.h&gt;
macro_line|#include &lt;linux/usb_ch9.h&gt;
DECL|macro|USB_MAJOR
mdefine_line|#define USB_MAJOR&t;&t;&t;180
macro_line|#ifdef __KERNEL__
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;        /* for -ENODEV */
macro_line|#include &lt;linux/delay.h&gt;&t;/* for mdelay() */
macro_line|#include &lt;linux/interrupt.h&gt;&t;/* for in_interrupt() */
macro_line|#include &lt;linux/list.h&gt;&t;&t;/* for struct list_head */
macro_line|#include &lt;linux/device.h&gt;&t;/* for struct device */
macro_line|#include &lt;linux/fs.h&gt;&t;&t;/* for struct file_operations */
macro_line|#include &lt;linux/completion.h&gt;&t;/* for struct completion */
DECL|function|wait_ms
r_static
id|__inline__
r_void
id|wait_ms
c_func
(paren
r_int
r_int
id|ms
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|in_interrupt
c_func
(paren
)paren
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
op_plus
id|ms
op_star
id|HZ
op_div
l_int|1000
)paren
suffix:semicolon
)brace
r_else
id|mdelay
c_func
(paren
id|ms
)paren
suffix:semicolon
)brace
r_struct
id|usb_device
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * Host-side wrappers for standard USB descriptors ... these are parsed&n; * from the data provided by devices.  Parsing turns them from a flat&n; * sequence of descriptors into a hierarchy:&n; *&n; *  - devices have one (usually) or more configs;&n; *  - configs have one (often) or more interfaces;&n; *  - interfaces have one (usually) or more settings;&n; *  - each interface setting has zero or (usually) more endpoints.&n; *&n; * And there might be other descriptors mixed in with those.&n; *&n; * Devices may also have class-specific or vendor-specific descriptors.&n; */
multiline_comment|/* host-side wrapper for parsed endpoint descriptors */
DECL|struct|usb_host_endpoint
r_struct
id|usb_host_endpoint
(brace
DECL|member|desc
r_struct
id|usb_endpoint_descriptor
id|desc
suffix:semicolon
DECL|member|extra
r_int
r_char
op_star
id|extra
suffix:semicolon
multiline_comment|/* Extra descriptors */
DECL|member|extralen
r_int
id|extralen
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* host-side wrapper for one interface setting&squot;s parsed descriptors */
DECL|struct|usb_host_interface
r_struct
id|usb_host_interface
(brace
DECL|member|desc
r_struct
id|usb_interface_descriptor
id|desc
suffix:semicolon
multiline_comment|/* array of desc.bNumEndpoint endpoints associated with this&n;&t; * interface setting.  these will be in no particular order.&n;&t; */
DECL|member|endpoint
r_struct
id|usb_host_endpoint
op_star
id|endpoint
suffix:semicolon
DECL|member|extra
r_int
r_char
op_star
id|extra
suffix:semicolon
multiline_comment|/* Extra descriptors */
DECL|member|extralen
r_int
id|extralen
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/**&n; * struct usb_interface - what usb device drivers talk to&n; * @altsetting: array of interface descriptors, one for each alternate&n; * &t;setting that may be selected.  each one includes a set of&n; * &t;endpoint configurations.&n; * @num_altsetting: number of altsettings defined.&n; * @act_altsetting: index of current altsetting.  this number is always&n; *&t;less than num_altsetting.  after the device is configured, each&n; *&t;interface uses its default setting of zero.&n; * @dev: driver model&squot;s view of this device&n; *&n; * USB device drivers attach to interfaces on a physical device.  Each&n; * interface encapsulates a single high level function, such as feeding&n; * an audio stream to a speaker or reporting a change in a volume control.&n; * Many USB devices only have one interface.  The protocol used to talk to&n; * an interface&squot;s endpoints can be defined in a usb &quot;class&quot; specification,&n; * or by a product&squot;s vendor.  The (default) control endpoint is part of&n; * every interface, but is never listed among the interface&squot;s descriptors.&n; *&n; * The driver that is bound to the interface can use standard driver model&n; * calls such as dev_get_drvdata() on the dev member of this structure.&n; *&n; * Each interface may have alternate settings.  The initial configuration&n; * of a device sets the first of these, but the device driver can change&n; * that setting using usb_set_interface().  Alternate settings are often&n; * used to control the the use of periodic endpoints, such as by having&n; * different endpoints use different amounts of reserved USB bandwidth.&n; * All standards-conformant USB devices that use isochronous endpoints&n; * will use them in non-default settings.&n; */
DECL|struct|usb_interface
r_struct
id|usb_interface
(brace
multiline_comment|/* array of alternate settings for this interface.&n;&t; * these will be in numeric order, 0..num_altsettting&n;&t; */
DECL|member|altsetting
r_struct
id|usb_host_interface
op_star
id|altsetting
suffix:semicolon
DECL|member|act_altsetting
r_int
id|act_altsetting
suffix:semicolon
multiline_comment|/* active alternate setting */
DECL|member|num_altsetting
r_int
id|num_altsetting
suffix:semicolon
multiline_comment|/* number of alternate settings */
DECL|member|max_altsetting
r_int
id|max_altsetting
suffix:semicolon
multiline_comment|/* total memory allocated */
DECL|member|driver
r_struct
id|usb_driver
op_star
id|driver
suffix:semicolon
multiline_comment|/* driver */
DECL|member|kdev
id|kdev_t
id|kdev
suffix:semicolon
multiline_comment|/* node this interface is bound to */
DECL|member|dev
r_struct
id|device
id|dev
suffix:semicolon
multiline_comment|/* interface specific device info */
)brace
suffix:semicolon
DECL|macro|to_usb_interface
mdefine_line|#define&t;to_usb_interface(d) container_of(d, struct usb_interface, dev)
DECL|macro|interface_to_usbdev
mdefine_line|#define&t;interface_to_usbdev(intf) &bslash;&n;&t;container_of(intf-&gt;dev.parent, struct usb_device, dev)
DECL|function|usb_get_intfdata
r_static
r_inline
r_void
op_star
id|usb_get_intfdata
(paren
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
r_return
id|dev_get_drvdata
(paren
op_amp
id|intf-&gt;dev
)paren
suffix:semicolon
)brace
DECL|function|usb_set_intfdata
r_static
r_inline
r_void
id|usb_set_intfdata
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|dev_set_drvdata
(paren
op_amp
id|intf-&gt;dev
comma
id|data
)paren
suffix:semicolon
)brace
multiline_comment|/* USB_DT_CONFIG: Configuration descriptor information.&n; *&n; * USB_DT_OTHER_SPEED_CONFIG is the same descriptor, except that the&n; * descriptor type is different.  Highspeed-capable devices can look&n; * different depending on what speed they&squot;re currently running.  Only&n; * devices with a USB_DT_DEVICE_QUALIFIER have an OTHER_SPEED_CONFIG.&n; */
DECL|struct|usb_host_config
r_struct
id|usb_host_config
(brace
DECL|member|desc
r_struct
id|usb_config_descriptor
id|desc
suffix:semicolon
multiline_comment|/* the interfaces associated with this configuration&n;&t; * these will be in numeric order, 0..desc.bNumInterfaces&n;&t; */
DECL|member|interface
r_struct
id|usb_interface
op_star
id|interface
suffix:semicolon
DECL|member|extra
r_int
r_char
op_star
id|extra
suffix:semicolon
multiline_comment|/* Extra descriptors */
DECL|member|extralen
r_int
id|extralen
suffix:semicolon
)brace
suffix:semicolon
singleline_comment|// FIXME remove; exported only for drivers/usb/misc/auserwald.c
singleline_comment|// prefer usb_device-&gt;epnum[0..31]
r_extern
r_struct
id|usb_endpoint_descriptor
op_star
id|usb_epnum_to_ep_desc
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|epnum
)paren
suffix:semicolon
r_int
id|__usb_get_extra_descriptor
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
id|size
comma
r_int
r_char
id|type
comma
r_void
op_star
op_star
id|ptr
)paren
suffix:semicolon
DECL|macro|usb_get_extra_descriptor
mdefine_line|#define usb_get_extra_descriptor(ifpoint,type,ptr)&bslash;&n;&t;__usb_get_extra_descriptor((ifpoint)-&gt;extra,(ifpoint)-&gt;extralen,&bslash;&n;&t;&t;type,(void**)ptr)
multiline_comment|/* -------------------------------------------------------------------------- */
r_struct
id|usb_operations
suffix:semicolon
multiline_comment|/* USB device number allocation bitmap */
DECL|struct|usb_devmap
r_struct
id|usb_devmap
(brace
DECL|member|devicemap
r_int
r_int
id|devicemap
(braket
l_int|128
op_div
(paren
l_int|8
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Allocated per bus (tree of devices) we have:&n; */
DECL|struct|usb_bus
r_struct
id|usb_bus
(brace
DECL|member|controller
r_struct
id|device
op_star
id|controller
suffix:semicolon
multiline_comment|/* host/master side hardware */
DECL|member|busnum
r_int
id|busnum
suffix:semicolon
multiline_comment|/* Bus number (in order of reg) */
DECL|member|bus_name
r_char
op_star
id|bus_name
suffix:semicolon
multiline_comment|/* stable id (PCI slot_name etc) */
DECL|member|devnum_next
r_int
id|devnum_next
suffix:semicolon
multiline_comment|/* Next open device number in round-robin allocation */
DECL|member|devmap
r_struct
id|usb_devmap
id|devmap
suffix:semicolon
multiline_comment|/* device address allocation map */
DECL|member|op
r_struct
id|usb_operations
op_star
id|op
suffix:semicolon
multiline_comment|/* Operations (specific to the HC) */
DECL|member|root_hub
r_struct
id|usb_device
op_star
id|root_hub
suffix:semicolon
multiline_comment|/* Root hub */
DECL|member|bus_list
r_struct
id|list_head
id|bus_list
suffix:semicolon
multiline_comment|/* list of busses */
DECL|member|hcpriv
r_void
op_star
id|hcpriv
suffix:semicolon
multiline_comment|/* Host Controller private data */
DECL|member|bandwidth_allocated
r_int
id|bandwidth_allocated
suffix:semicolon
multiline_comment|/* on this bus: how much of the time&n;&t;&t;&t;&t;&t; * reserved for periodic (intr/iso)&n;&t;&t;&t;&t;&t; * requests is used, on average?&n;&t;&t;&t;&t;&t; * Units: microseconds/frame.&n;&t;&t;&t;&t;&t; * Limits: Full/low speed reserve 90%,&n;&t;&t;&t;&t;&t; * while high speed reserves 80%.&n;&t;&t;&t;&t;&t; */
DECL|member|bandwidth_int_reqs
r_int
id|bandwidth_int_reqs
suffix:semicolon
multiline_comment|/* number of Interrupt requests */
DECL|member|bandwidth_isoc_reqs
r_int
id|bandwidth_isoc_reqs
suffix:semicolon
multiline_comment|/* number of Isoc. requests */
DECL|member|usbfs_dentry
r_struct
id|dentry
op_star
id|usbfs_dentry
suffix:semicolon
multiline_comment|/* usbfs dentry entry for the bus */
DECL|member|usbdevfs_dentry
r_struct
id|dentry
op_star
id|usbdevfs_dentry
suffix:semicolon
multiline_comment|/* usbdevfs dentry entry for the bus */
DECL|member|refcnt
id|atomic_t
id|refcnt
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* -------------------------------------------------------------------------- */
multiline_comment|/* This is arbitrary.&n; * From USB 2.0 spec Table 11-13, offset 7, a hub can&n; * have up to 255 ports. The most yet reported is 10.&n; */
DECL|macro|USB_MAXCHILDREN
mdefine_line|#define USB_MAXCHILDREN&t;&t;(16)
r_struct
id|usb_tt
suffix:semicolon
DECL|struct|usb_device
r_struct
id|usb_device
(brace
DECL|member|devnum
r_int
id|devnum
suffix:semicolon
multiline_comment|/* Address on USB bus */
DECL|member|devpath
r_char
id|devpath
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* Use in messages: /port/port/... */
DECL|member|speed
r_enum
id|usb_device_speed
id|speed
suffix:semicolon
multiline_comment|/* high/full/low (or error) */
DECL|member|tt
r_struct
id|usb_tt
op_star
id|tt
suffix:semicolon
multiline_comment|/* low/full speed dev, highspeed hub */
DECL|member|ttport
r_int
id|ttport
suffix:semicolon
multiline_comment|/* device port on that tt hub */
DECL|member|serialize
r_struct
id|semaphore
id|serialize
suffix:semicolon
DECL|member|toggle
r_int
r_int
id|toggle
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* one bit for each endpoint ([0] = IN, [1] = OUT) */
DECL|member|halted
r_int
r_int
id|halted
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* endpoint halts; one bit per endpoint # &amp; direction; */
multiline_comment|/* [0] = IN, [1] = OUT */
DECL|member|epmaxpacketin
r_int
id|epmaxpacketin
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* INput endpoint specific maximums */
DECL|member|epmaxpacketout
r_int
id|epmaxpacketout
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* OUTput endpoint specific maximums */
DECL|member|parent
r_struct
id|usb_device
op_star
id|parent
suffix:semicolon
multiline_comment|/* our hub, unless we&squot;re the root */
DECL|member|bus
r_struct
id|usb_bus
op_star
id|bus
suffix:semicolon
multiline_comment|/* Bus we&squot;re part of */
DECL|member|dev
r_struct
id|device
id|dev
suffix:semicolon
multiline_comment|/* Generic device interface */
DECL|member|descriptor
r_struct
id|usb_device_descriptor
id|descriptor
suffix:semicolon
multiline_comment|/* Descriptor */
DECL|member|config
r_struct
id|usb_host_config
op_star
id|config
suffix:semicolon
multiline_comment|/* All of the configs */
DECL|member|actconfig
r_struct
id|usb_host_config
op_star
id|actconfig
suffix:semicolon
multiline_comment|/* the active configuration */
DECL|member|rawdescriptors
r_char
op_star
op_star
id|rawdescriptors
suffix:semicolon
multiline_comment|/* Raw descriptors for each config */
DECL|member|have_langid
r_int
id|have_langid
suffix:semicolon
multiline_comment|/* whether string_langid is valid yet */
DECL|member|string_langid
r_int
id|string_langid
suffix:semicolon
multiline_comment|/* language ID for strings */
DECL|member|hcpriv
r_void
op_star
id|hcpriv
suffix:semicolon
multiline_comment|/* Host Controller private data */
DECL|member|filelist
r_struct
id|list_head
id|filelist
suffix:semicolon
DECL|member|usbfs_dentry
r_struct
id|dentry
op_star
id|usbfs_dentry
suffix:semicolon
multiline_comment|/* usbfs dentry entry for the device */
DECL|member|usbdevfs_dentry
r_struct
id|dentry
op_star
id|usbdevfs_dentry
suffix:semicolon
multiline_comment|/* usbdevfs dentry entry for the device */
multiline_comment|/*&n;&t; * Child devices - these can be either new devices&n;&t; * (if this is a hub device), or different instances&n;&t; * of this same device.&n;&t; *&n;&t; * Each instance needs its own set of data structures.&n;&t; */
DECL|member|maxchild
r_int
id|maxchild
suffix:semicolon
multiline_comment|/* Number of ports if hub */
DECL|member|children
r_struct
id|usb_device
op_star
id|children
(braket
id|USB_MAXCHILDREN
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|to_usb_device
mdefine_line|#define&t;to_usb_device(d) container_of(d, struct usb_device, dev)
r_extern
r_struct
id|usb_device
op_star
id|usb_alloc_dev
c_func
(paren
r_struct
id|usb_device
op_star
id|parent
comma
r_struct
id|usb_bus
op_star
)paren
suffix:semicolon
r_extern
r_struct
id|usb_device
op_star
id|usb_get_dev
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
suffix:semicolon
r_extern
r_void
id|usb_put_dev
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* mostly for devices emulating SCSI over USB */
r_extern
r_int
id|usb_reset_device
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* for drivers using iso endpoints */
r_extern
r_int
id|usb_get_current_frame_number
(paren
r_struct
id|usb_device
op_star
id|usb_dev
)paren
suffix:semicolon
multiline_comment|/* used these for multi-interface device registration */
r_extern
r_void
id|usb_driver_claim_interface
c_func
(paren
r_struct
id|usb_driver
op_star
id|driver
comma
r_struct
id|usb_interface
op_star
id|iface
comma
r_void
op_star
id|priv
)paren
suffix:semicolon
r_extern
r_int
id|usb_interface_claimed
c_func
(paren
r_struct
id|usb_interface
op_star
id|iface
)paren
suffix:semicolon
r_extern
r_void
id|usb_driver_release_interface
c_func
(paren
r_struct
id|usb_driver
op_star
id|driver
comma
r_struct
id|usb_interface
op_star
id|iface
)paren
suffix:semicolon
r_const
r_struct
id|usb_device_id
op_star
id|usb_match_id
c_func
(paren
r_struct
id|usb_interface
op_star
id|interface
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
suffix:semicolon
r_extern
r_struct
id|usb_interface
op_star
id|usb_find_interface
c_func
(paren
r_struct
id|usb_driver
op_star
id|drv
comma
id|kdev_t
id|kdev
)paren
suffix:semicolon
r_extern
r_struct
id|usb_interface
op_star
id|usb_ifnum_to_if
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|ifnum
)paren
suffix:semicolon
multiline_comment|/**&n; * usb_make_path - returns stable device path in the usb tree&n; * @dev: the device whose path is being constructed&n; * @buf: where to put the string&n; * @size: how big is &quot;buf&quot;?&n; *&n; * Returns length of the string (&gt; 0) or negative if size was too small.&n; *&n; * This identifier is intended to be &quot;stable&quot;, reflecting physical paths in&n; * hardware such as physical bus addresses for host controllers or ports on&n; * USB hubs.  That makes it stay the same until systems are physically&n; * reconfigured, by re-cabling a tree of USB devices or by moving USB host&n; * controllers.  Adding and removing devices, including virtual root hubs&n; * in host controller driver modules, does not change these path identifers;&n; * neither does rebooting or re-enumerating.  These are more useful identifiers&n; * than changeable (&quot;unstable&quot;) ones like bus numbers or device addresses.&n; *&n; * With a partial exception for devices connected to USB 2.0 root hubs, these&n; * identifiers are also predictable.  So long as the device tree isn&squot;t changed,&n; * plugging any USB device into a given hub port always gives it the same path.&n; * Because of the use of &quot;companion&quot; controllers, devices connected to ports on&n; * USB 2.0 root hubs (EHCI host controllers) will get one path ID if they are&n; * high speed, and a different one if they are full or low speed.&n; */
DECL|function|usb_make_path
r_static
r_inline
r_int
id|usb_make_path
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
id|size
)paren
(brace
r_int
id|actual
suffix:semicolon
id|actual
op_assign
id|snprintf
(paren
id|buf
comma
id|size
comma
l_string|&quot;usb-%s-%s&quot;
comma
id|dev-&gt;bus-&gt;bus_name
comma
id|dev-&gt;devpath
)paren
suffix:semicolon
r_return
(paren
id|actual
op_ge
id|size
)paren
ques
c_cond
op_minus
l_int|1
suffix:colon
id|actual
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|macro|USB_DEVICE_ID_MATCH_DEVICE
mdefine_line|#define USB_DEVICE_ID_MATCH_DEVICE&t;&t;(USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_PRODUCT)
DECL|macro|USB_DEVICE_ID_MATCH_DEV_RANGE
mdefine_line|#define USB_DEVICE_ID_MATCH_DEV_RANGE&t;&t;(USB_DEVICE_ID_MATCH_DEV_LO | USB_DEVICE_ID_MATCH_DEV_HI)
DECL|macro|USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION
mdefine_line|#define USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION&t;(USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_DEV_RANGE)
DECL|macro|USB_DEVICE_ID_MATCH_DEV_INFO
mdefine_line|#define USB_DEVICE_ID_MATCH_DEV_INFO &bslash;&n;&t;(USB_DEVICE_ID_MATCH_DEV_CLASS | USB_DEVICE_ID_MATCH_DEV_SUBCLASS | USB_DEVICE_ID_MATCH_DEV_PROTOCOL)
DECL|macro|USB_DEVICE_ID_MATCH_INT_INFO
mdefine_line|#define USB_DEVICE_ID_MATCH_INT_INFO &bslash;&n;&t;(USB_DEVICE_ID_MATCH_INT_CLASS | USB_DEVICE_ID_MATCH_INT_SUBCLASS | USB_DEVICE_ID_MATCH_INT_PROTOCOL)
multiline_comment|/**&n; * USB_DEVICE - macro used to describe a specific usb device&n; * @vend: the 16 bit USB Vendor ID&n; * @prod: the 16 bit USB Product ID&n; *&n; * This macro is used to create a struct usb_device_id that matches a&n; * specific device.&n; */
DECL|macro|USB_DEVICE
mdefine_line|#define USB_DEVICE(vend,prod) &bslash;&n;&t;.match_flags = USB_DEVICE_ID_MATCH_DEVICE, .idVendor = (vend), .idProduct = (prod)
multiline_comment|/**&n; * USB_DEVICE_VER - macro used to describe a specific usb device with a version range&n; * @vend: the 16 bit USB Vendor ID&n; * @prod: the 16 bit USB Product ID&n; * @lo: the bcdDevice_lo value&n; * @hi: the bcdDevice_hi value&n; *&n; * This macro is used to create a struct usb_device_id that matches a&n; * specific device, with a version range.&n; */
DECL|macro|USB_DEVICE_VER
mdefine_line|#define USB_DEVICE_VER(vend,prod,lo,hi) &bslash;&n;&t;.match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION, .idVendor = (vend), .idProduct = (prod), .bcdDevice_lo = (lo), .bcdDevice_hi = (hi)
multiline_comment|/**&n; * USB_DEVICE_INFO - macro used to describe a class of usb devices&n; * @cl: bDeviceClass value&n; * @sc: bDeviceSubClass value&n; * @pr: bDeviceProtocol value&n; *&n; * This macro is used to create a struct usb_device_id that matches a&n; * specific class of devices.&n; */
DECL|macro|USB_DEVICE_INFO
mdefine_line|#define USB_DEVICE_INFO(cl,sc,pr) &bslash;&n;&t;.match_flags = USB_DEVICE_ID_MATCH_DEV_INFO, .bDeviceClass = (cl), .bDeviceSubClass = (sc), .bDeviceProtocol = (pr)
multiline_comment|/**&n; * USB_INTERFACE_INFO - macro used to describe a class of usb interfaces &n; * @cl: bInterfaceClass value&n; * @sc: bInterfaceSubClass value&n; * @pr: bInterfaceProtocol value&n; *&n; * This macro is used to create a struct usb_device_id that matches a&n; * specific class of interfaces.&n; */
DECL|macro|USB_INTERFACE_INFO
mdefine_line|#define USB_INTERFACE_INFO(cl,sc,pr) &bslash;&n;&t;.match_flags = USB_DEVICE_ID_MATCH_INT_INFO, .bInterfaceClass = (cl), .bInterfaceSubClass = (sc), .bInterfaceProtocol = (pr)
multiline_comment|/* -------------------------------------------------------------------------- */
multiline_comment|/**&n; * struct usb_driver - identifies USB driver to usbcore&n; * @owner: Pointer to the module owner of this driver; initialize&n; *&t;it using THIS_MODULE.&n; * @name: The driver name should be unique among USB drivers,&n; *&t;and should normally be the same as the module name.&n; * @probe: Called to see if the driver is willing to manage a particular&n; *&t;interface on a device.  If it is, probe returns zero and uses&n; *&t;dev_set_drvdata() to associate driver-specific data with the&n; *&t;interface.  It may also use usb_set_interface() to specify the&n; *&t;appropriate altsetting.  If unwilling to manage the interface,&n; *&t;return a negative errno value.&n; * @disconnect: Called when the interface is no longer accessible, usually&n; *&t;because its device has been (or is being) disconnected or the&n; *&t;driver module is being unloaded.&n; * @ioctl: Used for drivers that want to talk to userspace through&n; *&t;the &quot;usbfs&quot; filesystem.  This lets devices provide ways to&n; *&t;expose information to user space regardless of where they&n; *&t;do (or don&squot;t) show up otherwise in the filesystem.&n; * @id_table: USB drivers use ID table to support hotplugging.&n; *&t;Export this with MODULE_DEVICE_TABLE(usb,...).  This must be set&n; *&t;or your driver&squot;s probe function will never get called. &n; *&n; * USB drivers must provide a name, probe() and disconnect() methods,&n; * and an id_table.  Other driver fields are optional.&n; *&n; * The id_table is used in hotplugging.  It holds a set of descriptors,&n; * and specialized data may be associated with each entry.  That table&n; * is used by both user and kernel mode hotplugging support.&n; *&n; * The probe() and disconnect() methods are called in a context where&n; * they can sleep, but they should avoid abusing the privilege.  Most&n; * work to connect to a device should be done when the device is opened,&n; * and undone at the last close.  The disconnect code needs to address&n; * concurrency issues with respect to open() and close() methods, as&n; * well as forcing all pending I/O requests to complete (by unlinking&n; * them as necessary, and blocking until the unlinks complete).&n; */
DECL|struct|usb_driver
r_struct
id|usb_driver
(brace
DECL|member|owner
r_struct
id|module
op_star
id|owner
suffix:semicolon
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|probe
r_int
(paren
op_star
id|probe
)paren
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
suffix:semicolon
DECL|member|disconnect
r_void
(paren
op_star
id|disconnect
)paren
(paren
r_struct
id|usb_interface
op_star
id|intf
)paren
suffix:semicolon
DECL|member|ioctl
r_int
(paren
op_star
id|ioctl
)paren
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_int
r_int
id|code
comma
r_void
op_star
id|buf
)paren
suffix:semicolon
DECL|member|id_table
r_const
r_struct
id|usb_device_id
op_star
id|id_table
suffix:semicolon
DECL|member|driver
r_struct
id|device_driver
id|driver
suffix:semicolon
DECL|member|serialize
r_struct
id|semaphore
id|serialize
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|to_usb_driver
mdefine_line|#define&t;to_usb_driver(d) container_of(d, struct usb_driver, driver)
r_extern
r_struct
id|bus_type
id|usb_bus_type
suffix:semicolon
multiline_comment|/*&n; * use these in module_init()/module_exit()&n; * and don&squot;t forget MODULE_DEVICE_TABLE(usb, ...)&n; */
r_extern
r_int
id|usb_register
c_func
(paren
r_struct
id|usb_driver
op_star
)paren
suffix:semicolon
r_extern
r_void
id|usb_deregister
c_func
(paren
r_struct
id|usb_driver
op_star
)paren
suffix:semicolon
r_extern
r_int
id|usb_register_dev
c_func
(paren
r_struct
id|file_operations
op_star
id|fops
comma
r_int
id|minor
comma
r_int
id|num_minors
comma
r_int
op_star
id|start_minor
)paren
suffix:semicolon
r_extern
r_void
id|usb_deregister_dev
c_func
(paren
r_int
id|num_minors
comma
r_int
id|start_minor
)paren
suffix:semicolon
r_extern
r_int
id|usb_device_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_extern
r_int
id|usb_device_remove
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_extern
r_int
id|usb_disabled
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* -------------------------------------------------------------------------- */
multiline_comment|/*&n; * URB support, for asynchronous request completions&n; */
multiline_comment|/*&n; * urb-&gt;transfer_flags:&n; */
DECL|macro|URB_SHORT_NOT_OK
mdefine_line|#define URB_SHORT_NOT_OK&t;0x0001&t;/* report short reads as errors */
DECL|macro|URB_ISO_ASAP
mdefine_line|#define URB_ISO_ASAP&t;&t;0x0002&t;/* iso-only, urb-&gt;start_frame ignored */
DECL|macro|URB_NO_DMA_MAP
mdefine_line|#define URB_NO_DMA_MAP&t;&t;0x0004&t;/* urb-&gt;*_dma are valid on submit */
DECL|macro|URB_ASYNC_UNLINK
mdefine_line|#define URB_ASYNC_UNLINK&t;0x0008&t;/* usb_unlink_urb() returns asap */
DECL|macro|URB_NO_FSBR
mdefine_line|#define URB_NO_FSBR&t;&t;0x0020&t;/* UHCI-specific */
DECL|macro|URB_ZERO_PACKET
mdefine_line|#define URB_ZERO_PACKET&t;&t;0x0040&t;/* Finish bulk OUTs with short packet */
DECL|macro|URB_NO_INTERRUPT
mdefine_line|#define URB_NO_INTERRUPT&t;0x0080&t;/* HINT: no non-error interrupt needed */
DECL|struct|usb_iso_packet_descriptor
r_struct
id|usb_iso_packet_descriptor
(brace
DECL|member|offset
r_int
r_int
id|offset
suffix:semicolon
DECL|member|length
r_int
r_int
id|length
suffix:semicolon
multiline_comment|/* expected length */
DECL|member|actual_length
r_int
r_int
id|actual_length
suffix:semicolon
DECL|member|status
r_int
r_int
id|status
suffix:semicolon
)brace
suffix:semicolon
r_struct
id|urb
suffix:semicolon
r_struct
id|pt_regs
suffix:semicolon
DECL|typedef|usb_complete_t
r_typedef
r_void
(paren
op_star
id|usb_complete_t
)paren
(paren
r_struct
id|urb
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
multiline_comment|/**&n; * struct urb - USB Request Block&n; * @urb_list: For use by current owner of the URB.&n; * @pipe: Holds endpoint number, direction, type, and more.&n; *&t;Create these values with the eight macros available;&n; *&t;usb_{snd,rcv}TYPEpipe(dev,endpoint), where the type is &quot;ctrl&quot;&n; *&t;(control), &quot;bulk&quot;, &quot;int&quot; (interrupt), or &quot;iso&quot; (isochronous).&n; *&t;For example usb_sndbulkpipe() or usb_rcvintpipe().  Endpoint&n; *&t;numbers range from zero to fifteen.  Note that &quot;in&quot; endpoint two&n; *&t;is a different endpoint (and pipe) from &quot;out&quot; endpoint two.&n; *&t;The current configuration controls the existence, type, and&n; *&t;maximum packet size of any given endpoint.&n; * @dev: Identifies the USB device to perform the request.&n; * @status: This is read in non-iso completion functions to get the&n; *&t;status of the particular request.  ISO requests only use it&n; *&t;to tell whether the URB was unlinked; detailed status for&n; *&t;each frame is in the fields of the iso_frame-desc.&n; * @transfer_flags: A variety of flags may be used to affect how URB&n; *&t;submission, unlinking, or operation are handled.  Different&n; *&t;kinds of URB can use different flags.&n; * @transfer_buffer:  This identifies the buffer to (or from) which&n; * &t;the I/O request will be performed (unless URB_NO_DMA_MAP is set).&n; *&t;This buffer must be suitable for DMA; allocate it with kmalloc()&n; *&t;or equivalent.  For transfers to &quot;in&quot; endpoints, contents of&n; *&t;this buffer will be modified.  This buffer is used for data&n; *&t;phases of control transfers.&n; * @transfer_dma: When transfer_flags includes URB_NO_DMA_MAP, the device&n; * &t;driver is saying that it provided this DMA address, which the host&n; * &t;controller driver should use instead of the transfer_buffer.&n; * @transfer_buffer_length: How big is transfer_buffer.  The transfer may&n; *&t;be broken up into chunks according to the current maximum packet&n; *&t;size for the endpoint, which is a function of the configuration&n; *&t;and is encoded in the pipe.  When the length is zero, neither&n; *&t;transfer_buffer nor transfer_dma is used.&n; * @actual_length: This is read in non-iso completion functions, and&n; *&t;it tells how many bytes (out of transfer_buffer_length) were&n; *&t;transferred.  It will normally be the same as requested, unless&n; *&t;either an error was reported or a short read was performed.&n; *&t;The URB_SHORT_NOT_OK transfer flag may be used to make such&n; *&t;short reads be reported as errors. &n; * @setup_packet: Only used for control transfers, this points to eight bytes&n; *&t;of setup data.  Control transfers always start by sending this data&n; *&t;to the device.  Then transfer_buffer is read or written, if needed.&n; *&t;(Not used when URB_NO_DMA_MAP is set.)&n; * @setup_dma: For control transfers with URB_NO_DMA_MAP set, the device&n; * &t;driver has provided this DMA address for the setup packet.  The&n; * &t;host controller driver should use this instead of setup_buffer.&n; * &t;If there is a data phase, its buffer is identified by transfer_dma.&n; * @start_frame: Returns the initial frame for interrupt or isochronous&n; *&t;transfers.&n; * @number_of_packets: Lists the number of ISO transfer buffers.&n; * @interval: Specifies the polling interval for interrupt or isochronous&n; *&t;transfers.  The units are frames (milliseconds) for for full and low&n; *&t;speed devices, and microframes (1/8 millisecond) for highspeed ones.&n; * @error_count: Returns the number of ISO transfers that reported errors.&n; * @context: For use in completion functions.  This normally points to&n; *&t;request-specific driver context.&n; * @complete: Completion handler. This URB is passed as the parameter to the&n; *&t;completion function.  The completion function may then do what&n; *&t;it likes with the URB, including resubmitting or freeing it.&n; * @iso_frame_desc: Used to provide arrays of ISO transfer buffers and to &n; *&t;collect the transfer status for each buffer.&n; *&n; * This structure identifies USB transfer requests.  URBs must be allocated by&n; * calling usb_alloc_urb() and freed with a call to usb_free_urb().&n; * Initialization may be done using various usb_fill_*_urb() functions.  URBs&n; * are submitted using usb_submit_urb(), and pending requests may be canceled&n; * using usb_unlink_urb().&n; *&n; * Data Transfer Buffers:&n; *&n; * Normally drivers provide I/O buffers allocated with kmalloc() or otherwise&n; * taken from the general page pool.  That is provided by transfer_buffer&n; * (control requests also use setup_packet), and host controller drivers&n; * perform a dma mapping (and unmapping) for each buffer transferred.  Those&n; * mapping operations can be expensive on some platforms (perhaps using a dma&n; * bounce buffer or talking to an IOMMU),&n; * although they&squot;re cheap on commodity x86 and ppc hardware.&n; *&n; * Alternatively, drivers may pass the URB_NO_DMA_MAP transfer flag, which&n; * tells the host controller driver that no such mapping is needed since&n; * the device driver is DMA-aware.  For example, they might allocate a DMA&n; * buffer with usb_buffer_alloc(), or call usb_buffer_map().&n; * When this transfer flag is provided, host controller drivers will use the&n; * dma addresses found in the transfer_dma and/or setup_dma fields rather than&n; * determing a dma address themselves.&n; *&n; * Initialization:&n; *&n; * All URBs submitted must initialize dev, pipe,&n; * transfer_flags (may be zero), complete, timeout (may be zero).&n; * The URB_ASYNC_UNLINK transfer flag affects later invocations of&n; * the usb_unlink_urb() routine.&n; *&n; * All URBs must also initialize &n; * transfer_buffer and transfer_buffer_length.  They may provide the&n; * URB_SHORT_NOT_OK transfer flag, indicating that short reads are&n; * to be treated as errors; that flag is invalid for write requests.&n; *&n; * Bulk URBs may&n; * use the URB_ZERO_PACKET transfer flag, indicating that bulk OUT transfers&n; * should always terminate with a short packet, even if it means adding an&n; * extra zero length packet.&n; *&n; * Control URBs must provide a setup_packet.&n; *&n; * Interrupt UBS must provide an interval, saying how often (in milliseconds&n; * or, for highspeed devices, 125 microsecond units)&n; * to poll for transfers.  After the URB has been submitted, the interval&n; * and start_frame fields reflect how the transfer was actually scheduled.&n; * The polling interval may be more frequent than requested.&n; * For example, some controllers have a maximum interval of 32 microseconds,&n; * while others support intervals of up to 1024 microseconds.&n; * Isochronous URBs also have transfer intervals.  (Note that for isochronous&n; * endpoints, as well as high speed interrupt endpoints, the encoding of&n; * the transfer interval in the endpoint descriptor is logarithmic.)&n; *&n; * Isochronous URBs normally use the URB_ISO_ASAP transfer flag, telling&n; * the host controller to schedule the transfer as soon as bandwidth&n; * utilization allows, and then set start_frame to reflect the actual frame&n; * selected during submission.  Otherwise drivers must specify the start_frame&n; * and handle the case where the transfer can&squot;t begin then.  However, drivers&n; * won&squot;t know how bandwidth is currently allocated, and while they can&n; * find the current frame using usb_get_current_frame_number () they can&squot;t&n; * know the range for that frame number.  (Ranges for frame counter values&n; * are HC-specific, and can go from 256 to 65536 frames from &quot;now&quot;.)&n; *&n; * Isochronous URBs have a different data transfer model, in part because&n; * the quality of service is only &quot;best effort&quot;.  Callers provide specially&n; * allocated URBs, with number_of_packets worth of iso_frame_desc structures&n; * at the end.  Each such packet is an individual ISO transfer.  Isochronous&n; * URBs are normally queued, submitted by drivers to arrange that&n; * transfers are at least double buffered, and then explicitly resubmitted&n; * in completion handlers, so&n; * that data (such as audio or video) streams at as constant a rate as the&n; * host controller scheduler can support.&n; *&n; * Completion Callbacks:&n; *&n; * The completion callback is made in_interrupt(), and one of the first&n; * things that a completion handler should do is check the status field.&n; * The status field is provided for all URBs.  It is used to report&n; * unlinked URBs, and status for all non-ISO transfers.  It should not&n; * be examined before the URB is returned to the completion handler.&n; *&n; * The context field is normally used to link URBs back to the relevant&n; * driver or request state.&n; *&n; * When completion callback is invoked for non-isochronous URBs, the&n; * actual_length field tells how many bytes were transferred.&n; *&n; * ISO transfer status is reported in the status and actual_length fields&n; * of the iso_frame_desc array, and the number of errors is reported in&n; * error_count.  Completion callbacks for ISO transfers will normally&n; * (re)submit URBs to ensure a constant transfer rate.&n; */
DECL|struct|urb
r_struct
id|urb
(brace
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
multiline_comment|/* lock for the URB */
DECL|member|count
id|atomic_t
id|count
suffix:semicolon
multiline_comment|/* reference count of the URB */
DECL|member|hcpriv
r_void
op_star
id|hcpriv
suffix:semicolon
multiline_comment|/* private data for host controller */
DECL|member|urb_list
r_struct
id|list_head
id|urb_list
suffix:semicolon
multiline_comment|/* list pointer to all active urbs */
DECL|member|dev
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
multiline_comment|/* (in) pointer to associated device */
DECL|member|pipe
r_int
r_int
id|pipe
suffix:semicolon
multiline_comment|/* (in) pipe information */
DECL|member|status
r_int
id|status
suffix:semicolon
multiline_comment|/* (return) non-ISO status */
DECL|member|transfer_flags
r_int
r_int
id|transfer_flags
suffix:semicolon
multiline_comment|/* (in) URB_SHORT_NOT_OK | ...*/
DECL|member|transfer_buffer
r_void
op_star
id|transfer_buffer
suffix:semicolon
multiline_comment|/* (in) associated data buffer */
DECL|member|transfer_dma
id|dma_addr_t
id|transfer_dma
suffix:semicolon
multiline_comment|/* (in) dma addr for transfer_buffer */
DECL|member|transfer_buffer_length
r_int
id|transfer_buffer_length
suffix:semicolon
multiline_comment|/* (in) data buffer length */
DECL|member|actual_length
r_int
id|actual_length
suffix:semicolon
multiline_comment|/* (return) actual transfer length */
DECL|member|bandwidth
r_int
id|bandwidth
suffix:semicolon
multiline_comment|/* bandwidth for INT/ISO request */
DECL|member|setup_packet
r_int
r_char
op_star
id|setup_packet
suffix:semicolon
multiline_comment|/* (in) setup packet (control only) */
DECL|member|setup_dma
id|dma_addr_t
id|setup_dma
suffix:semicolon
multiline_comment|/* (in) dma addr for setup_packet */
DECL|member|start_frame
r_int
id|start_frame
suffix:semicolon
multiline_comment|/* (modify) start frame (INT/ISO) */
DECL|member|number_of_packets
r_int
id|number_of_packets
suffix:semicolon
multiline_comment|/* (in) number of ISO packets */
DECL|member|interval
r_int
id|interval
suffix:semicolon
multiline_comment|/* (in) transfer interval (INT/ISO) */
DECL|member|error_count
r_int
id|error_count
suffix:semicolon
multiline_comment|/* (return) number of ISO errors */
DECL|member|timeout
r_int
id|timeout
suffix:semicolon
multiline_comment|/* (in) timeout, in jiffies */
DECL|member|context
r_void
op_star
id|context
suffix:semicolon
multiline_comment|/* (in) context for completion */
DECL|member|complete
id|usb_complete_t
id|complete
suffix:semicolon
multiline_comment|/* (in) completion routine */
DECL|member|iso_frame_desc
r_struct
id|usb_iso_packet_descriptor
id|iso_frame_desc
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* (in) ISO ONLY */
)brace
suffix:semicolon
multiline_comment|/* -------------------------------------------------------------------------- */
multiline_comment|/**&n; * usb_fill_control_urb - initializes a control urb&n; * @urb: pointer to the urb to initialize.&n; * @dev: pointer to the struct usb_device for this urb.&n; * @pipe: the endpoint pipe&n; * @setup_packet: pointer to the setup_packet buffer&n; * @transfer_buffer: pointer to the transfer buffer&n; * @buffer_length: length of the transfer buffer&n; * @complete: pointer to the usb_complete_t function&n; * @context: what to set the urb context to.&n; *&n; * Initializes a control urb with the proper information needed to submit&n; * it to a device.&n; */
DECL|function|usb_fill_control_urb
r_static
r_inline
r_void
id|usb_fill_control_urb
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|pipe
comma
r_int
r_char
op_star
id|setup_packet
comma
r_void
op_star
id|transfer_buffer
comma
r_int
id|buffer_length
comma
id|usb_complete_t
id|complete
comma
r_void
op_star
id|context
)paren
(brace
id|spin_lock_init
c_func
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
id|urb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|urb-&gt;pipe
op_assign
id|pipe
suffix:semicolon
id|urb-&gt;setup_packet
op_assign
id|setup_packet
suffix:semicolon
id|urb-&gt;transfer_buffer
op_assign
id|transfer_buffer
suffix:semicolon
id|urb-&gt;transfer_buffer_length
op_assign
id|buffer_length
suffix:semicolon
id|urb-&gt;complete
op_assign
id|complete
suffix:semicolon
id|urb-&gt;context
op_assign
id|context
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_fill_bulk_urb - macro to help initialize a bulk urb&n; * @urb: pointer to the urb to initialize.&n; * @dev: pointer to the struct usb_device for this urb.&n; * @pipe: the endpoint pipe&n; * @transfer_buffer: pointer to the transfer buffer&n; * @buffer_length: length of the transfer buffer&n; * @complete: pointer to the usb_complete_t function&n; * @context: what to set the urb context to.&n; *&n; * Initializes a bulk urb with the proper information needed to submit it&n; * to a device.&n; */
DECL|function|usb_fill_bulk_urb
r_static
r_inline
r_void
id|usb_fill_bulk_urb
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|pipe
comma
r_void
op_star
id|transfer_buffer
comma
r_int
id|buffer_length
comma
id|usb_complete_t
id|complete
comma
r_void
op_star
id|context
)paren
(brace
id|spin_lock_init
c_func
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
id|urb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|urb-&gt;pipe
op_assign
id|pipe
suffix:semicolon
id|urb-&gt;transfer_buffer
op_assign
id|transfer_buffer
suffix:semicolon
id|urb-&gt;transfer_buffer_length
op_assign
id|buffer_length
suffix:semicolon
id|urb-&gt;complete
op_assign
id|complete
suffix:semicolon
id|urb-&gt;context
op_assign
id|context
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_fill_int_urb - macro to help initialize a interrupt urb&n; * @urb: pointer to the urb to initialize.&n; * @dev: pointer to the struct usb_device for this urb.&n; * @pipe: the endpoint pipe&n; * @transfer_buffer: pointer to the transfer buffer&n; * @buffer_length: length of the transfer buffer&n; * @complete: pointer to the usb_complete_t function&n; * @context: what to set the urb context to.&n; * @interval: what to set the urb interval to, encoded like&n; *&t;the endpoint descriptor&squot;s bInterval value.&n; *&n; * Initializes a interrupt urb with the proper information needed to submit&n; * it to a device.&n; * Note that high speed interrupt endpoints use a logarithmic encoding of&n; * the endpoint interval, and express polling intervals in microframes&n; * (eight per millisecond) rather than in frames (one per millisecond).&n; */
DECL|function|usb_fill_int_urb
r_static
r_inline
r_void
id|usb_fill_int_urb
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|pipe
comma
r_void
op_star
id|transfer_buffer
comma
r_int
id|buffer_length
comma
id|usb_complete_t
id|complete
comma
r_void
op_star
id|context
comma
r_int
id|interval
)paren
(brace
id|spin_lock_init
c_func
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
id|urb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|urb-&gt;pipe
op_assign
id|pipe
suffix:semicolon
id|urb-&gt;transfer_buffer
op_assign
id|transfer_buffer
suffix:semicolon
id|urb-&gt;transfer_buffer_length
op_assign
id|buffer_length
suffix:semicolon
id|urb-&gt;complete
op_assign
id|complete
suffix:semicolon
id|urb-&gt;context
op_assign
id|context
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
id|urb-&gt;interval
op_assign
l_int|1
op_lshift
(paren
id|interval
op_minus
l_int|1
)paren
suffix:semicolon
r_else
id|urb-&gt;interval
op_assign
id|interval
suffix:semicolon
id|urb-&gt;start_frame
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_extern
r_struct
id|urb
op_star
id|usb_alloc_urb
c_func
(paren
r_int
id|iso_packets
comma
r_int
id|mem_flags
)paren
suffix:semicolon
r_extern
r_void
id|usb_free_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
DECL|macro|usb_put_urb
mdefine_line|#define usb_put_urb usb_free_urb
r_extern
r_struct
id|urb
op_star
id|usb_get_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_extern
r_int
id|usb_submit_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mem_flags
)paren
suffix:semicolon
r_extern
r_int
id|usb_unlink_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
DECL|macro|HAVE_USB_BUFFERS
mdefine_line|#define HAVE_USB_BUFFERS
r_void
op_star
id|usb_buffer_alloc
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|size
comma
r_int
id|mem_flags
comma
id|dma_addr_t
op_star
id|dma
)paren
suffix:semicolon
r_void
id|usb_buffer_free
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|size
comma
r_void
op_star
id|addr
comma
id|dma_addr_t
id|dma
)paren
suffix:semicolon
r_struct
id|urb
op_star
id|usb_buffer_map
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_void
id|usb_buffer_dmasync
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_void
id|usb_buffer_unmap
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_struct
id|scatterlist
suffix:semicolon
r_int
id|usb_buffer_map_sg
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|pipe
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
)paren
suffix:semicolon
r_void
id|usb_buffer_dmasync_sg
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|pipe
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|n_hw_ents
)paren
suffix:semicolon
r_void
id|usb_buffer_unmap_sg
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|pipe
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|n_hw_ents
)paren
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------*&n; *                         SYNCHRONOUS CALL SUPPORT                  *&n; *-------------------------------------------------------------------*/
r_extern
r_int
id|usb_control_msg
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|pipe
comma
id|__u8
id|request
comma
id|__u8
id|requesttype
comma
id|__u16
id|value
comma
id|__u16
id|index
comma
r_void
op_star
id|data
comma
id|__u16
id|size
comma
r_int
id|timeout
)paren
suffix:semicolon
r_extern
r_int
id|usb_bulk_msg
c_func
(paren
r_struct
id|usb_device
op_star
id|usb_dev
comma
r_int
r_int
id|pipe
comma
r_void
op_star
id|data
comma
r_int
id|len
comma
r_int
op_star
id|actual_length
comma
r_int
id|timeout
)paren
suffix:semicolon
multiline_comment|/* wrappers around usb_control_msg() for the most common standard requests */
r_extern
r_int
id|usb_get_descriptor
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_char
id|desctype
comma
r_int
r_char
id|descindex
comma
r_void
op_star
id|buf
comma
r_int
id|size
)paren
suffix:semicolon
r_extern
r_int
id|usb_get_device_descriptor
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
suffix:semicolon
r_extern
r_int
id|usb_get_status
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|type
comma
r_int
id|target
comma
r_void
op_star
id|data
)paren
suffix:semicolon
r_extern
r_int
id|usb_get_string
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|langid
comma
r_int
r_char
id|index
comma
r_void
op_star
id|buf
comma
r_int
id|size
)paren
suffix:semicolon
r_extern
r_int
id|usb_string
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|index
comma
r_char
op_star
id|buf
comma
r_int
id|size
)paren
suffix:semicolon
multiline_comment|/* wrappers that also update important state inside usbcore */
r_extern
r_int
id|usb_clear_halt
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|pipe
)paren
suffix:semicolon
r_extern
r_int
id|usb_set_configuration
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|configuration
)paren
suffix:semicolon
r_extern
r_int
id|usb_set_interface
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|ifnum
comma
r_int
id|alternate
)paren
suffix:semicolon
multiline_comment|/*&n; * timeouts, in seconds, used for sending/receiving control messages&n; * they typically complete within a few frames (msec) after they&squot;re issued&n; * USB identifies 5 second timeouts, maybe more in a few cases, and a few&n; * slow devices (like some MGE Ellipse UPSes) actually push that limit.&n; */
DECL|macro|USB_CTRL_GET_TIMEOUT
mdefine_line|#define USB_CTRL_GET_TIMEOUT&t;5
DECL|macro|USB_CTRL_SET_TIMEOUT
mdefine_line|#define USB_CTRL_SET_TIMEOUT&t;5
multiline_comment|/**&n; * struct usb_sg_request - support for scatter/gather I/O&n; * @status: zero indicates success, else negative errno&n; * @bytes: counts bytes transferred.&n; *&n; * These requests are initialized using usb_sg_init(), and then are used&n; * as request handles passed to usb_sg_wait() or usb_sg_cancel().  Most&n; * members of the request object aren&squot;t for driver access.&n; *&n; * The status and bytecount values are valid only after usb_sg_wait()&n; * returns.  If the status is zero, then the bytecount matches the total&n; * from the request.&n; *&n; * After an error completion, drivers may need to clear a halt condition&n; * on the endpoint.&n; */
DECL|struct|usb_sg_request
r_struct
id|usb_sg_request
(brace
DECL|member|status
r_int
id|status
suffix:semicolon
DECL|member|bytes
r_int
id|bytes
suffix:semicolon
singleline_comment|// members not documented above are private to usbcore,
singleline_comment|// and are not provided for driver access!
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|dev
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
DECL|member|pipe
r_int
id|pipe
suffix:semicolon
DECL|member|sg
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
DECL|member|nents
r_int
id|nents
suffix:semicolon
DECL|member|entries
r_int
id|entries
suffix:semicolon
DECL|member|urbs
r_struct
id|urb
op_star
op_star
id|urbs
suffix:semicolon
DECL|member|count
r_int
id|count
suffix:semicolon
DECL|member|complete
r_struct
id|completion
id|complete
suffix:semicolon
)brace
suffix:semicolon
r_int
id|usb_sg_init
(paren
r_struct
id|usb_sg_request
op_star
id|io
comma
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|pipe
comma
r_int
id|period
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
comma
r_int
id|length
comma
r_int
id|mem_flags
)paren
suffix:semicolon
r_void
id|usb_sg_cancel
(paren
r_struct
id|usb_sg_request
op_star
id|io
)paren
suffix:semicolon
r_void
id|usb_sg_wait
(paren
r_struct
id|usb_sg_request
op_star
id|io
)paren
suffix:semicolon
multiline_comment|/* -------------------------------------------------------------------------- */
multiline_comment|/*&n; * Calling this entity a &quot;pipe&quot; is glorifying it. A USB pipe&n; * is something embarrassingly simple: it basically consists&n; * of the following information:&n; *  - device number (7 bits)&n; *  - endpoint number (4 bits)&n; *  - current Data0/1 state (1 bit) [Historical; now gone]&n; *  - direction (1 bit)&n; *  - speed (1 bit) [Historical and specific to USB 1.1; now gone.]&n; *  - max packet size (2 bits: 8, 16, 32 or 64) [Historical; now gone.]&n; *  - pipe type (2 bits: control, interrupt, bulk, isochronous)&n; *&n; * That&squot;s 18 bits. Really. Nothing more. And the USB people have&n; * documented these eighteen bits as some kind of glorious&n; * virtual data structure.&n; *&n; * Let&squot;s not fall in that trap. We&squot;ll just encode it as a simple&n; * unsigned int. The encoding is:&n; *&n; *  - max size:&t;&t;bits 0-1&t;[Historical; now gone.]&n; *  - direction:&t;bit 7&t;&t;(0 = Host-to-Device [Out],&n; *&t;&t;&t;&t;&t; 1 = Device-to-Host [In] ...&n; *&t;&t;&t;&t;&t;like endpoint bEndpointAddress)&n; *  - device:&t;&t;bits 8-14       ... bit positions known to uhci-hcd&n; *  - endpoint:&t;&t;bits 15-18      ... bit positions known to uhci-hcd&n; *  - Data0/1:&t;&t;bit 19&t;&t;[Historical; now gone. ]&n; *  - lowspeed:&t;&t;bit 26&t;&t;[Historical; now gone. ]&n; *  - pipe type:&t;bits 30-31&t;(00 = isochronous, 01 = interrupt,&n; *&t;&t;&t;&t;&t; 10 = control, 11 = bulk)&n; *&n; * Why? Because it&squot;s arbitrary, and whatever encoding we select is really&n; * up to us. This one happens to share a lot of bit positions with the UHCI&n; * specification, so that much of the uhci driver can just mask the bits&n; * appropriately.&n; */
multiline_comment|/* NOTE:  these are not the standard USB_ENDPOINT_XFER_* values!! */
DECL|macro|PIPE_ISOCHRONOUS
mdefine_line|#define PIPE_ISOCHRONOUS&t;&t;0
DECL|macro|PIPE_INTERRUPT
mdefine_line|#define PIPE_INTERRUPT&t;&t;&t;1
DECL|macro|PIPE_CONTROL
mdefine_line|#define PIPE_CONTROL&t;&t;&t;2
DECL|macro|PIPE_BULK
mdefine_line|#define PIPE_BULK&t;&t;&t;3
DECL|macro|usb_maxpacket
mdefine_line|#define usb_maxpacket(dev, pipe, out)&t;(out &bslash;&n;&t;&t;&t;&t;? (dev)-&gt;epmaxpacketout[usb_pipeendpoint(pipe)] &bslash;&n;&t;&t;&t;&t;: (dev)-&gt;epmaxpacketin [usb_pipeendpoint(pipe)] )
DECL|macro|usb_pipein
mdefine_line|#define usb_pipein(pipe)&t;((pipe) &amp; USB_DIR_IN)
DECL|macro|usb_pipeout
mdefine_line|#define usb_pipeout(pipe)&t;(!usb_pipein(pipe))
DECL|macro|usb_pipedevice
mdefine_line|#define usb_pipedevice(pipe)&t;(((pipe) &gt;&gt; 8) &amp; 0x7f)
DECL|macro|usb_pipeendpoint
mdefine_line|#define usb_pipeendpoint(pipe)&t;(((pipe) &gt;&gt; 15) &amp; 0xf)
DECL|macro|usb_pipetype
mdefine_line|#define usb_pipetype(pipe)&t;(((pipe) &gt;&gt; 30) &amp; 3)
DECL|macro|usb_pipeisoc
mdefine_line|#define usb_pipeisoc(pipe)&t;(usb_pipetype((pipe)) == PIPE_ISOCHRONOUS)
DECL|macro|usb_pipeint
mdefine_line|#define usb_pipeint(pipe)&t;(usb_pipetype((pipe)) == PIPE_INTERRUPT)
DECL|macro|usb_pipecontrol
mdefine_line|#define usb_pipecontrol(pipe)&t;(usb_pipetype((pipe)) == PIPE_CONTROL)
DECL|macro|usb_pipebulk
mdefine_line|#define usb_pipebulk(pipe)&t;(usb_pipetype((pipe)) == PIPE_BULK)
multiline_comment|/* The D0/D1 toggle bits ... USE WITH CAUTION (they&squot;re almost hcd-internal) */
DECL|macro|usb_gettoggle
mdefine_line|#define usb_gettoggle(dev, ep, out) (((dev)-&gt;toggle[out] &gt;&gt; (ep)) &amp; 1)
DECL|macro|usb_dotoggle
mdefine_line|#define&t;usb_dotoggle(dev, ep, out)  ((dev)-&gt;toggle[out] ^= (1 &lt;&lt; (ep)))
DECL|macro|usb_settoggle
mdefine_line|#define usb_settoggle(dev, ep, out, bit) ((dev)-&gt;toggle[out] = ((dev)-&gt;toggle[out] &amp; ~(1 &lt;&lt; (ep))) | ((bit) &lt;&lt; (ep)))
multiline_comment|/* Endpoint halt control/status ... likewise USE WITH CAUTION */
DECL|macro|usb_endpoint_running
mdefine_line|#define usb_endpoint_running(dev, ep, out) ((dev)-&gt;halted[out] &amp;= ~(1 &lt;&lt; (ep)))
DECL|macro|usb_endpoint_halted
mdefine_line|#define usb_endpoint_halted(dev, ep, out) ((dev)-&gt;halted[out] &amp; (1 &lt;&lt; (ep)))
DECL|function|__create_pipe
r_static
r_inline
r_int
r_int
id|__create_pipe
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|endpoint
)paren
(brace
r_return
(paren
id|dev-&gt;devnum
op_lshift
l_int|8
)paren
op_or
(paren
id|endpoint
op_lshift
l_int|15
)paren
suffix:semicolon
)brace
multiline_comment|/* Create various pipes... */
DECL|macro|usb_sndctrlpipe
mdefine_line|#define usb_sndctrlpipe(dev,endpoint)&t;((PIPE_CONTROL &lt;&lt; 30) | __create_pipe(dev,endpoint))
DECL|macro|usb_rcvctrlpipe
mdefine_line|#define usb_rcvctrlpipe(dev,endpoint)&t;((PIPE_CONTROL &lt;&lt; 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
DECL|macro|usb_sndisocpipe
mdefine_line|#define usb_sndisocpipe(dev,endpoint)&t;((PIPE_ISOCHRONOUS &lt;&lt; 30) | __create_pipe(dev,endpoint))
DECL|macro|usb_rcvisocpipe
mdefine_line|#define usb_rcvisocpipe(dev,endpoint)&t;((PIPE_ISOCHRONOUS &lt;&lt; 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
DECL|macro|usb_sndbulkpipe
mdefine_line|#define usb_sndbulkpipe(dev,endpoint)&t;((PIPE_BULK &lt;&lt; 30) | __create_pipe(dev,endpoint))
DECL|macro|usb_rcvbulkpipe
mdefine_line|#define usb_rcvbulkpipe(dev,endpoint)&t;((PIPE_BULK &lt;&lt; 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
DECL|macro|usb_sndintpipe
mdefine_line|#define usb_sndintpipe(dev,endpoint)&t;((PIPE_INTERRUPT &lt;&lt; 30) | __create_pipe(dev,endpoint))
DECL|macro|usb_rcvintpipe
mdefine_line|#define usb_rcvintpipe(dev,endpoint)&t;((PIPE_INTERRUPT &lt;&lt; 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
DECL|macro|usb_snddefctrl
mdefine_line|#define usb_snddefctrl(dev)&t;&t;((PIPE_CONTROL &lt;&lt; 30))
DECL|macro|usb_rcvdefctrl
mdefine_line|#define usb_rcvdefctrl(dev)&t;&t;((PIPE_CONTROL &lt;&lt; 30) | USB_DIR_IN)
multiline_comment|/* -------------------------------------------------------------------------- */
multiline_comment|/*&n; * Debugging and troubleshooting/diagnostic helpers.&n; */
r_void
id|usb_show_device_descriptor
c_func
(paren
r_struct
id|usb_device_descriptor
op_star
)paren
suffix:semicolon
r_void
id|usb_show_config_descriptor
c_func
(paren
r_struct
id|usb_config_descriptor
op_star
)paren
suffix:semicolon
r_void
id|usb_show_interface_descriptor
c_func
(paren
r_struct
id|usb_interface_descriptor
op_star
)paren
suffix:semicolon
r_void
id|usb_show_endpoint_descriptor
c_func
(paren
r_struct
id|usb_endpoint_descriptor
op_star
)paren
suffix:semicolon
r_void
id|usb_show_device
c_func
(paren
r_struct
id|usb_device
op_star
)paren
suffix:semicolon
r_void
id|usb_show_string
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_char
op_star
id|id
comma
r_int
id|index
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
DECL|macro|dbg
mdefine_line|#define dbg(format, arg...) printk(KERN_DEBUG __FILE__ &quot;: &quot; format &quot;&bslash;n&quot; , ## arg)
macro_line|#else
DECL|macro|dbg
mdefine_line|#define dbg(format, arg...) do {} while (0)
macro_line|#endif
DECL|macro|err
mdefine_line|#define err(format, arg...) printk(KERN_ERR __FILE__ &quot;: &quot; format &quot;&bslash;n&quot; , ## arg)
DECL|macro|info
mdefine_line|#define info(format, arg...) printk(KERN_INFO __FILE__ &quot;: &quot; format &quot;&bslash;n&quot; , ## arg)
DECL|macro|warn
mdefine_line|#define warn(format, arg...) printk(KERN_WARNING __FILE__ &quot;: &quot; format &quot;&bslash;n&quot; , ## arg)
macro_line|#endif  /* __KERNEL__ */
macro_line|#endif
eof
