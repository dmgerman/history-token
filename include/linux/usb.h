macro_line|#ifndef __LINUX_USB_H
DECL|macro|__LINUX_USB_H
mdefine_line|#define __LINUX_USB_H
macro_line|#include &lt;linux/mod_devicetable.h&gt;
macro_line|#include &lt;linux/usb_ch9.h&gt;
DECL|macro|USB_MAJOR
mdefine_line|#define USB_MAJOR&t;&t;&t;180
macro_line|#ifdef __KERNEL__
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;        /* for -ENODEV */
macro_line|#include &lt;linux/delay.h&gt;&t;/* for mdelay() */
macro_line|#include &lt;linux/interrupt.h&gt;&t;/* for in_interrupt() */
macro_line|#include &lt;linux/list.h&gt;&t;&t;/* for struct list_head */
macro_line|#include &lt;linux/kref.h&gt;&t;&t;/* for struct kref */
macro_line|#include &lt;linux/device.h&gt;&t;/* for struct device */
macro_line|#include &lt;linux/fs.h&gt;&t;&t;/* for struct file_operations */
macro_line|#include &lt;linux/completion.h&gt;&t;/* for struct completion */
macro_line|#include &lt;linux/sched.h&gt;&t;/* for current &amp;&amp; schedule_timeout */
r_struct
id|usb_device
suffix:semicolon
r_struct
id|usb_driver
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * Host-side wrappers for standard USB descriptors ... these are parsed&n; * from the data provided by devices.  Parsing turns them from a flat&n; * sequence of descriptors into a hierarchy:&n; *&n; *  - devices have one (usually) or more configs;&n; *  - configs have one (often) or more interfaces;&n; *  - interfaces have one (usually) or more settings;&n; *  - each interface setting has zero or (usually) more endpoints.&n; *&n; * And there might be other descriptors mixed in with those.&n; *&n; * Devices may also have class-specific or vendor-specific descriptors.&n; */
multiline_comment|/**&n; * struct usb_host_endpoint - host-side endpoint descriptor and queue&n; * @desc: descriptor for this endpoint, wMaxPacketSize in native byteorder&n; * @urb_list: urbs queued to this endpoint; maintained by usbcore&n; * @hcpriv: for use by HCD; typically holds hardware dma queue head (QH)&n; *&t;with one or more transfer descriptors (TDs) per urb&n; * @extra: descriptors following this endpoint in the configuration&n; * @extralen: how many bytes of &quot;extra&quot; are valid&n; *&n; * USB requests are always queued to a given endpoint, identified by a&n; * descriptor within an active interface in a given USB configuration.&n; */
DECL|struct|usb_host_endpoint
r_struct
id|usb_host_endpoint
(brace
DECL|member|desc
r_struct
id|usb_endpoint_descriptor
id|desc
suffix:semicolon
DECL|member|urb_list
r_struct
id|list_head
id|urb_list
suffix:semicolon
DECL|member|hcpriv
r_void
op_star
id|hcpriv
suffix:semicolon
DECL|member|extra
r_int
r_char
op_star
id|extra
suffix:semicolon
multiline_comment|/* Extra descriptors */
DECL|member|extralen
r_int
id|extralen
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* host-side wrapper for one interface setting&squot;s parsed descriptors */
DECL|struct|usb_host_interface
r_struct
id|usb_host_interface
(brace
DECL|member|desc
r_struct
id|usb_interface_descriptor
id|desc
suffix:semicolon
multiline_comment|/* array of desc.bNumEndpoint endpoints associated with this&n;&t; * interface setting.  these will be in no particular order.&n;&t; */
DECL|member|endpoint
r_struct
id|usb_host_endpoint
op_star
id|endpoint
suffix:semicolon
DECL|member|extra
r_int
r_char
op_star
id|extra
suffix:semicolon
multiline_comment|/* Extra descriptors */
DECL|member|extralen
r_int
id|extralen
suffix:semicolon
)brace
suffix:semicolon
DECL|enum|usb_interface_condition
r_enum
id|usb_interface_condition
(brace
DECL|enumerator|USB_INTERFACE_UNBOUND
id|USB_INTERFACE_UNBOUND
op_assign
l_int|0
comma
DECL|enumerator|USB_INTERFACE_BINDING
id|USB_INTERFACE_BINDING
comma
DECL|enumerator|USB_INTERFACE_BOUND
id|USB_INTERFACE_BOUND
comma
DECL|enumerator|USB_INTERFACE_UNBINDING
id|USB_INTERFACE_UNBINDING
comma
)brace
suffix:semicolon
multiline_comment|/**&n; * struct usb_interface - what usb device drivers talk to&n; * @altsetting: array of interface structures, one for each alternate&n; * &t;setting that may be selected.  Each one includes a set of&n; * &t;endpoint configurations.  They will be in no particular order.&n; * @num_altsetting: number of altsettings defined.&n; * @cur_altsetting: the current altsetting.&n; * @driver: the USB driver that is bound to this interface.&n; * @minor: the minor number assigned to this interface, if this&n; *&t;interface is bound to a driver that uses the USB major number.&n; *&t;If this interface does not use the USB major, this field should&n; *&t;be unused.  The driver should set this value in the probe()&n; *&t;function of the driver, after it has been assigned a minor&n; *&t;number from the USB core by calling usb_register_dev().&n; * @condition: binding state of the interface: not bound, binding&n; *&t;(in probe()), bound to a driver, or unbinding (in disconnect())&n; * @dev: driver model&squot;s view of this device&n; * @class_dev: driver model&squot;s class view of this device.&n; *&n; * USB device drivers attach to interfaces on a physical device.  Each&n; * interface encapsulates a single high level function, such as feeding&n; * an audio stream to a speaker or reporting a change in a volume control.&n; * Many USB devices only have one interface.  The protocol used to talk to&n; * an interface&squot;s endpoints can be defined in a usb &quot;class&quot; specification,&n; * or by a product&squot;s vendor.  The (default) control endpoint is part of&n; * every interface, but is never listed among the interface&squot;s descriptors.&n; *&n; * The driver that is bound to the interface can use standard driver model&n; * calls such as dev_get_drvdata() on the dev member of this structure.&n; *&n; * Each interface may have alternate settings.  The initial configuration&n; * of a device sets altsetting 0, but the device driver can change&n; * that setting using usb_set_interface().  Alternate settings are often&n; * used to control the the use of periodic endpoints, such as by having&n; * different endpoints use different amounts of reserved USB bandwidth.&n; * All standards-conformant USB devices that use isochronous endpoints&n; * will use them in non-default settings.&n; *&n; * The USB specification says that alternate setting numbers must run from&n; * 0 to one less than the total number of alternate settings.  But some&n; * devices manage to mess this up, and the structures aren&squot;t necessarily&n; * stored in numerical order anyhow.  Use usb_altnum_to_altsetting() to&n; * look up an alternate setting in the altsetting array based on its number.&n; */
DECL|struct|usb_interface
r_struct
id|usb_interface
(brace
multiline_comment|/* array of alternate settings for this interface,&n;&t; * stored in no particular order */
DECL|member|altsetting
r_struct
id|usb_host_interface
op_star
id|altsetting
suffix:semicolon
DECL|member|cur_altsetting
r_struct
id|usb_host_interface
op_star
id|cur_altsetting
suffix:semicolon
multiline_comment|/* the currently&n;&t;&t;&t;&t;&t; * active alternate setting */
DECL|member|num_altsetting
r_int
id|num_altsetting
suffix:semicolon
multiline_comment|/* number of alternate settings */
DECL|member|minor
r_int
id|minor
suffix:semicolon
multiline_comment|/* minor number this interface is bound to */
DECL|member|condition
r_enum
id|usb_interface_condition
id|condition
suffix:semicolon
multiline_comment|/* state of binding */
DECL|member|dev
r_struct
id|device
id|dev
suffix:semicolon
multiline_comment|/* interface specific device info */
DECL|member|class_dev
r_struct
id|class_device
op_star
id|class_dev
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|to_usb_interface
mdefine_line|#define&t;to_usb_interface(d) container_of(d, struct usb_interface, dev)
DECL|macro|interface_to_usbdev
mdefine_line|#define&t;interface_to_usbdev(intf) &bslash;&n;&t;container_of(intf-&gt;dev.parent, struct usb_device, dev)
DECL|function|usb_get_intfdata
r_static
r_inline
r_void
op_star
id|usb_get_intfdata
(paren
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
r_return
id|dev_get_drvdata
(paren
op_amp
id|intf-&gt;dev
)paren
suffix:semicolon
)brace
DECL|function|usb_set_intfdata
r_static
r_inline
r_void
id|usb_set_intfdata
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_void
op_star
id|data
)paren
(brace
id|dev_set_drvdata
c_func
(paren
op_amp
id|intf-&gt;dev
comma
id|data
)paren
suffix:semicolon
)brace
r_struct
id|usb_interface
op_star
id|usb_get_intf
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
)paren
suffix:semicolon
r_void
id|usb_put_intf
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
)paren
suffix:semicolon
multiline_comment|/* this maximum is arbitrary */
DECL|macro|USB_MAXINTERFACES
mdefine_line|#define USB_MAXINTERFACES&t;32
multiline_comment|/**&n; * struct usb_interface_cache - long-term representation of a device interface&n; * @num_altsetting: number of altsettings defined.&n; * @ref: reference counter.&n; * @altsetting: variable-length array of interface structures, one for&n; *&t;each alternate setting that may be selected.  Each one includes a&n; *&t;set of endpoint configurations.  They will be in no particular order.&n; *&n; * These structures persist for the lifetime of a usb_device, unlike&n; * struct usb_interface (which persists only as long as its configuration&n; * is installed).  The altsetting arrays can be accessed through these&n; * structures at any time, permitting comparison of configurations and&n; * providing support for the /proc/bus/usb/devices pseudo-file.&n; */
DECL|struct|usb_interface_cache
r_struct
id|usb_interface_cache
(brace
DECL|member|num_altsetting
r_int
id|num_altsetting
suffix:semicolon
multiline_comment|/* number of alternate settings */
DECL|member|ref
r_struct
id|kref
id|ref
suffix:semicolon
multiline_comment|/* reference counter */
multiline_comment|/* variable-length array of alternate settings for this interface,&n;&t; * stored in no particular order */
DECL|member|altsetting
r_struct
id|usb_host_interface
id|altsetting
(braket
l_int|0
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|ref_to_usb_interface_cache
mdefine_line|#define&t;ref_to_usb_interface_cache(r) &bslash;&n;&t;&t;container_of(r, struct usb_interface_cache, ref)
DECL|macro|altsetting_to_usb_interface_cache
mdefine_line|#define&t;altsetting_to_usb_interface_cache(a) &bslash;&n;&t;&t;container_of(a, struct usb_interface_cache, altsetting[0])
multiline_comment|/**&n; * struct usb_host_config - representation of a device&squot;s configuration&n; * @desc: the device&squot;s configuration descriptor.&n; * @interface: array of pointers to usb_interface structures, one for each&n; *&t;interface in the configuration.  The number of interfaces is stored&n; *&t;in desc.bNumInterfaces.  These pointers are valid only while the&n; *&t;the configuration is active.&n; * @intf_cache: array of pointers to usb_interface_cache structures, one&n; *&t;for each interface in the configuration.  These structures exist&n; *&t;for the entire life of the device.&n; * @extra: pointer to buffer containing all extra descriptors associated&n; *&t;with this configuration (those preceding the first interface&n; *&t;descriptor).&n; * @extralen: length of the extra descriptors buffer.&n; *&n; * USB devices may have multiple configurations, but only one can be active&n; * at any time.  Each encapsulates a different operational environment;&n; * for example, a dual-speed device would have separate configurations for&n; * full-speed and high-speed operation.  The number of configurations&n; * available is stored in the device descriptor as bNumConfigurations.&n; *&n; * A configuration can contain multiple interfaces.  Each corresponds to&n; * a different function of the USB device, and all are available whenever&n; * the configuration is active.  The USB standard says that interfaces&n; * are supposed to be numbered from 0 to desc.bNumInterfaces-1, but a lot&n; * of devices get this wrong.  In addition, the interface array is not&n; * guaranteed to be sorted in numerical order.  Use usb_ifnum_to_if() to&n; * look up an interface entry based on its number.&n; *&n; * Device drivers should not attempt to activate configurations.  The choice&n; * of which configuration to install is a policy decision based on such&n; * considerations as available power, functionality provided, and the user&squot;s&n; * desires (expressed through hotplug scripts).  However, drivers can call&n; * usb_reset_configuration() to reinitialize the current configuration and&n; * all its interfaces.&n; */
DECL|struct|usb_host_config
r_struct
id|usb_host_config
(brace
DECL|member|desc
r_struct
id|usb_config_descriptor
id|desc
suffix:semicolon
multiline_comment|/* the interfaces associated with this configuration,&n;&t; * stored in no particular order */
DECL|member|interface
r_struct
id|usb_interface
op_star
id|interface
(braket
id|USB_MAXINTERFACES
)braket
suffix:semicolon
multiline_comment|/* Interface information available even when this is not the&n;&t; * active configuration */
DECL|member|intf_cache
r_struct
id|usb_interface_cache
op_star
id|intf_cache
(braket
id|USB_MAXINTERFACES
)braket
suffix:semicolon
DECL|member|extra
r_int
r_char
op_star
id|extra
suffix:semicolon
multiline_comment|/* Extra descriptors */
DECL|member|extralen
r_int
id|extralen
suffix:semicolon
)brace
suffix:semicolon
r_int
id|__usb_get_extra_descriptor
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
id|size
comma
r_int
r_char
id|type
comma
r_void
op_star
op_star
id|ptr
)paren
suffix:semicolon
DECL|macro|usb_get_extra_descriptor
mdefine_line|#define usb_get_extra_descriptor(ifpoint,type,ptr)&bslash;&n;&t;__usb_get_extra_descriptor((ifpoint)-&gt;extra,(ifpoint)-&gt;extralen,&bslash;&n;&t;&t;type,(void**)ptr)
multiline_comment|/* -------------------------------------------------------------------------- */
r_struct
id|usb_operations
suffix:semicolon
multiline_comment|/* USB device number allocation bitmap */
DECL|struct|usb_devmap
r_struct
id|usb_devmap
(brace
DECL|member|devicemap
r_int
r_int
id|devicemap
(braket
l_int|128
op_div
(paren
l_int|8
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Allocated per bus (tree of devices) we have:&n; */
DECL|struct|usb_bus
r_struct
id|usb_bus
(brace
DECL|member|controller
r_struct
id|device
op_star
id|controller
suffix:semicolon
multiline_comment|/* host/master side hardware */
DECL|member|busnum
r_int
id|busnum
suffix:semicolon
multiline_comment|/* Bus number (in order of reg) */
DECL|member|bus_name
r_char
op_star
id|bus_name
suffix:semicolon
multiline_comment|/* stable id (PCI slot_name etc) */
DECL|member|otg_port
id|u8
id|otg_port
suffix:semicolon
multiline_comment|/* 0, or number of OTG/HNP port */
DECL|member|is_b_host
r_int
id|is_b_host
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* true during some HNP roleswitches */
DECL|member|b_hnp_enable
r_int
id|b_hnp_enable
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* OTG: did A-Host enable HNP? */
DECL|member|devnum_next
r_int
id|devnum_next
suffix:semicolon
multiline_comment|/* Next open device number in round-robin allocation */
DECL|member|devmap
r_struct
id|usb_devmap
id|devmap
suffix:semicolon
multiline_comment|/* device address allocation map */
DECL|member|op
r_struct
id|usb_operations
op_star
id|op
suffix:semicolon
multiline_comment|/* Operations (specific to the HC) */
DECL|member|root_hub
r_struct
id|usb_device
op_star
id|root_hub
suffix:semicolon
multiline_comment|/* Root hub */
DECL|member|bus_list
r_struct
id|list_head
id|bus_list
suffix:semicolon
multiline_comment|/* list of busses */
DECL|member|hcpriv
r_void
op_star
id|hcpriv
suffix:semicolon
multiline_comment|/* Host Controller private data */
DECL|member|bandwidth_allocated
r_int
id|bandwidth_allocated
suffix:semicolon
multiline_comment|/* on this bus: how much of the time&n;&t;&t;&t;&t;&t; * reserved for periodic (intr/iso)&n;&t;&t;&t;&t;&t; * requests is used, on average?&n;&t;&t;&t;&t;&t; * Units: microseconds/frame.&n;&t;&t;&t;&t;&t; * Limits: Full/low speed reserve 90%,&n;&t;&t;&t;&t;&t; * while high speed reserves 80%.&n;&t;&t;&t;&t;&t; */
DECL|member|bandwidth_int_reqs
r_int
id|bandwidth_int_reqs
suffix:semicolon
multiline_comment|/* number of Interrupt requests */
DECL|member|bandwidth_isoc_reqs
r_int
id|bandwidth_isoc_reqs
suffix:semicolon
multiline_comment|/* number of Isoc. requests */
DECL|member|usbfs_dentry
r_struct
id|dentry
op_star
id|usbfs_dentry
suffix:semicolon
multiline_comment|/* usbfs dentry entry for the bus */
DECL|member|class_dev
r_struct
id|class_device
id|class_dev
suffix:semicolon
multiline_comment|/* class device for this bus */
DECL|member|release
r_void
(paren
op_star
id|release
)paren
(paren
r_struct
id|usb_bus
op_star
id|bus
)paren
suffix:semicolon
multiline_comment|/* function to destroy this bus&squot;s memory */
)brace
suffix:semicolon
DECL|macro|to_usb_bus
mdefine_line|#define&t;to_usb_bus(d) container_of(d, struct usb_bus, class_dev)
multiline_comment|/* -------------------------------------------------------------------------- */
multiline_comment|/* This is arbitrary.&n; * From USB 2.0 spec Table 11-13, offset 7, a hub can&n; * have up to 255 ports. The most yet reported is 10.&n; */
DECL|macro|USB_MAXCHILDREN
mdefine_line|#define USB_MAXCHILDREN&t;&t;(16)
r_struct
id|usb_tt
suffix:semicolon
multiline_comment|/*&n; * struct usb_device - kernel&squot;s representation of a USB device&n; *&n; * FIXME: Write the kerneldoc!&n; *&n; * Usbcore drivers should not set usbdev-&gt;state directly.  Instead use&n; * usb_set_device_state().&n; */
DECL|struct|usb_device
r_struct
id|usb_device
(brace
DECL|member|devnum
r_int
id|devnum
suffix:semicolon
multiline_comment|/* Address on USB bus */
DECL|member|devpath
r_char
id|devpath
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* Use in messages: /port/port/... */
DECL|member|state
r_enum
id|usb_device_state
id|state
suffix:semicolon
multiline_comment|/* configured, not attached, etc */
DECL|member|speed
r_enum
id|usb_device_speed
id|speed
suffix:semicolon
multiline_comment|/* high/full/low (or error) */
DECL|member|tt
r_struct
id|usb_tt
op_star
id|tt
suffix:semicolon
multiline_comment|/* low/full speed dev, highspeed hub */
DECL|member|ttport
r_int
id|ttport
suffix:semicolon
multiline_comment|/* device port on that tt hub */
DECL|member|serialize
r_struct
id|semaphore
id|serialize
suffix:semicolon
DECL|member|toggle
r_int
r_int
id|toggle
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* one bit for each endpoint ([0] = IN, [1] = OUT) */
DECL|member|parent
r_struct
id|usb_device
op_star
id|parent
suffix:semicolon
multiline_comment|/* our hub, unless we&squot;re the root */
DECL|member|bus
r_struct
id|usb_bus
op_star
id|bus
suffix:semicolon
multiline_comment|/* Bus we&squot;re part of */
DECL|member|ep0
r_struct
id|usb_host_endpoint
id|ep0
suffix:semicolon
DECL|member|dev
r_struct
id|device
id|dev
suffix:semicolon
multiline_comment|/* Generic device interface */
DECL|member|descriptor
r_struct
id|usb_device_descriptor
id|descriptor
suffix:semicolon
multiline_comment|/* Descriptor */
DECL|member|config
r_struct
id|usb_host_config
op_star
id|config
suffix:semicolon
multiline_comment|/* All of the configs */
DECL|member|actconfig
r_struct
id|usb_host_config
op_star
id|actconfig
suffix:semicolon
multiline_comment|/* the active configuration */
DECL|member|ep_in
r_struct
id|usb_host_endpoint
op_star
id|ep_in
(braket
l_int|16
)braket
suffix:semicolon
DECL|member|ep_out
r_struct
id|usb_host_endpoint
op_star
id|ep_out
(braket
l_int|16
)braket
suffix:semicolon
DECL|member|rawdescriptors
r_char
op_star
op_star
id|rawdescriptors
suffix:semicolon
multiline_comment|/* Raw descriptors for each config */
DECL|member|have_langid
r_int
id|have_langid
suffix:semicolon
multiline_comment|/* whether string_langid is valid yet */
DECL|member|string_langid
r_int
id|string_langid
suffix:semicolon
multiline_comment|/* language ID for strings */
DECL|member|filelist
r_struct
id|list_head
id|filelist
suffix:semicolon
DECL|member|usbfs_dentry
r_struct
id|dentry
op_star
id|usbfs_dentry
suffix:semicolon
multiline_comment|/* usbfs dentry entry for the device */
multiline_comment|/*&n;&t; * Child devices - these can be either new devices&n;&t; * (if this is a hub device), or different instances&n;&t; * of this same device.&n;&t; *&n;&t; * Each instance needs its own set of data structures.&n;&t; */
DECL|member|maxchild
r_int
id|maxchild
suffix:semicolon
multiline_comment|/* Number of ports if hub */
DECL|member|children
r_struct
id|usb_device
op_star
id|children
(braket
id|USB_MAXCHILDREN
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|to_usb_device
mdefine_line|#define&t;to_usb_device(d) container_of(d, struct usb_device, dev)
r_extern
r_struct
id|usb_device
op_star
id|usb_get_dev
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
suffix:semicolon
r_extern
r_void
id|usb_put_dev
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
suffix:semicolon
r_extern
r_void
id|usb_lock_device
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
suffix:semicolon
r_extern
r_int
id|usb_trylock_device
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
suffix:semicolon
r_extern
r_int
id|usb_lock_device_for_reset
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
comma
r_struct
id|usb_interface
op_star
id|iface
)paren
suffix:semicolon
r_extern
r_void
id|usb_unlock_device
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
suffix:semicolon
multiline_comment|/* USB port reset for device reinitialization */
r_extern
r_int
id|usb_reset_device
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
suffix:semicolon
r_extern
r_struct
id|usb_device
op_star
id|usb_find_device
c_func
(paren
id|u16
id|vendor_id
comma
id|u16
id|product_id
)paren
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* for drivers using iso endpoints */
r_extern
r_int
id|usb_get_current_frame_number
(paren
r_struct
id|usb_device
op_star
id|usb_dev
)paren
suffix:semicolon
multiline_comment|/* used these for multi-interface device registration */
r_extern
r_int
id|usb_driver_claim_interface
c_func
(paren
r_struct
id|usb_driver
op_star
id|driver
comma
r_struct
id|usb_interface
op_star
id|iface
comma
r_void
op_star
id|priv
)paren
suffix:semicolon
multiline_comment|/**&n; * usb_interface_claimed - returns true iff an interface is claimed&n; * @iface: the interface being checked&n; *&n; * Returns true (nonzero) iff the interface is claimed, else false (zero).&n; * Callers must own the driver model&squot;s usb bus readlock.  So driver&n; * probe() entries don&squot;t need extra locking, but other call contexts&n; * may need to explicitly claim that lock.&n; *&n; */
DECL|function|usb_interface_claimed
r_static
r_inline
r_int
id|usb_interface_claimed
c_func
(paren
r_struct
id|usb_interface
op_star
id|iface
)paren
(brace
r_return
(paren
id|iface-&gt;dev.driver
op_ne
l_int|NULL
)paren
suffix:semicolon
)brace
r_extern
r_void
id|usb_driver_release_interface
c_func
(paren
r_struct
id|usb_driver
op_star
id|driver
comma
r_struct
id|usb_interface
op_star
id|iface
)paren
suffix:semicolon
r_const
r_struct
id|usb_device_id
op_star
id|usb_match_id
c_func
(paren
r_struct
id|usb_interface
op_star
id|interface
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
suffix:semicolon
r_extern
r_struct
id|usb_interface
op_star
id|usb_find_interface
c_func
(paren
r_struct
id|usb_driver
op_star
id|drv
comma
r_int
id|minor
)paren
suffix:semicolon
r_extern
r_struct
id|usb_interface
op_star
id|usb_ifnum_to_if
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|ifnum
)paren
suffix:semicolon
r_extern
r_struct
id|usb_host_interface
op_star
id|usb_altnum_to_altsetting
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_int
r_int
id|altnum
)paren
suffix:semicolon
multiline_comment|/**&n; * usb_make_path - returns stable device path in the usb tree&n; * @dev: the device whose path is being constructed&n; * @buf: where to put the string&n; * @size: how big is &quot;buf&quot;?&n; *&n; * Returns length of the string (&gt; 0) or negative if size was too small.&n; *&n; * This identifier is intended to be &quot;stable&quot;, reflecting physical paths in&n; * hardware such as physical bus addresses for host controllers or ports on&n; * USB hubs.  That makes it stay the same until systems are physically&n; * reconfigured, by re-cabling a tree of USB devices or by moving USB host&n; * controllers.  Adding and removing devices, including virtual root hubs&n; * in host controller driver modules, does not change these path identifers;&n; * neither does rebooting or re-enumerating.  These are more useful identifiers&n; * than changeable (&quot;unstable&quot;) ones like bus numbers or device addresses.&n; *&n; * With a partial exception for devices connected to USB 2.0 root hubs, these&n; * identifiers are also predictable.  So long as the device tree isn&squot;t changed,&n; * plugging any USB device into a given hub port always gives it the same path.&n; * Because of the use of &quot;companion&quot; controllers, devices connected to ports on&n; * USB 2.0 root hubs (EHCI host controllers) will get one path ID if they are&n; * high speed, and a different one if they are full or low speed.&n; */
DECL|function|usb_make_path
r_static
r_inline
r_int
id|usb_make_path
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
id|size
)paren
(brace
r_int
id|actual
suffix:semicolon
id|actual
op_assign
id|snprintf
(paren
id|buf
comma
id|size
comma
l_string|&quot;usb-%s-%s&quot;
comma
id|dev-&gt;bus-&gt;bus_name
comma
id|dev-&gt;devpath
)paren
suffix:semicolon
r_return
(paren
id|actual
op_ge
(paren
r_int
)paren
id|size
)paren
ques
c_cond
op_minus
l_int|1
suffix:colon
id|actual
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|macro|USB_DEVICE_ID_MATCH_DEVICE
mdefine_line|#define USB_DEVICE_ID_MATCH_DEVICE&t;&t;(USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_PRODUCT)
DECL|macro|USB_DEVICE_ID_MATCH_DEV_RANGE
mdefine_line|#define USB_DEVICE_ID_MATCH_DEV_RANGE&t;&t;(USB_DEVICE_ID_MATCH_DEV_LO | USB_DEVICE_ID_MATCH_DEV_HI)
DECL|macro|USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION
mdefine_line|#define USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION&t;(USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_DEV_RANGE)
DECL|macro|USB_DEVICE_ID_MATCH_DEV_INFO
mdefine_line|#define USB_DEVICE_ID_MATCH_DEV_INFO &bslash;&n;&t;(USB_DEVICE_ID_MATCH_DEV_CLASS | USB_DEVICE_ID_MATCH_DEV_SUBCLASS | USB_DEVICE_ID_MATCH_DEV_PROTOCOL)
DECL|macro|USB_DEVICE_ID_MATCH_INT_INFO
mdefine_line|#define USB_DEVICE_ID_MATCH_INT_INFO &bslash;&n;&t;(USB_DEVICE_ID_MATCH_INT_CLASS | USB_DEVICE_ID_MATCH_INT_SUBCLASS | USB_DEVICE_ID_MATCH_INT_PROTOCOL)
multiline_comment|/**&n; * USB_DEVICE - macro used to describe a specific usb device&n; * @vend: the 16 bit USB Vendor ID&n; * @prod: the 16 bit USB Product ID&n; *&n; * This macro is used to create a struct usb_device_id that matches a&n; * specific device.&n; */
DECL|macro|USB_DEVICE
mdefine_line|#define USB_DEVICE(vend,prod) &bslash;&n;&t;.match_flags = USB_DEVICE_ID_MATCH_DEVICE, .idVendor = (vend), .idProduct = (prod)
multiline_comment|/**&n; * USB_DEVICE_VER - macro used to describe a specific usb device with a version range&n; * @vend: the 16 bit USB Vendor ID&n; * @prod: the 16 bit USB Product ID&n; * @lo: the bcdDevice_lo value&n; * @hi: the bcdDevice_hi value&n; *&n; * This macro is used to create a struct usb_device_id that matches a&n; * specific device, with a version range.&n; */
DECL|macro|USB_DEVICE_VER
mdefine_line|#define USB_DEVICE_VER(vend,prod,lo,hi) &bslash;&n;&t;.match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION, .idVendor = (vend), .idProduct = (prod), .bcdDevice_lo = (lo), .bcdDevice_hi = (hi)
multiline_comment|/**&n; * USB_DEVICE_INFO - macro used to describe a class of usb devices&n; * @cl: bDeviceClass value&n; * @sc: bDeviceSubClass value&n; * @pr: bDeviceProtocol value&n; *&n; * This macro is used to create a struct usb_device_id that matches a&n; * specific class of devices.&n; */
DECL|macro|USB_DEVICE_INFO
mdefine_line|#define USB_DEVICE_INFO(cl,sc,pr) &bslash;&n;&t;.match_flags = USB_DEVICE_ID_MATCH_DEV_INFO, .bDeviceClass = (cl), .bDeviceSubClass = (sc), .bDeviceProtocol = (pr)
multiline_comment|/**&n; * USB_INTERFACE_INFO - macro used to describe a class of usb interfaces &n; * @cl: bInterfaceClass value&n; * @sc: bInterfaceSubClass value&n; * @pr: bInterfaceProtocol value&n; *&n; * This macro is used to create a struct usb_device_id that matches a&n; * specific class of interfaces.&n; */
DECL|macro|USB_INTERFACE_INFO
mdefine_line|#define USB_INTERFACE_INFO(cl,sc,pr) &bslash;&n;&t;.match_flags = USB_DEVICE_ID_MATCH_INT_INFO, .bInterfaceClass = (cl), .bInterfaceSubClass = (sc), .bInterfaceProtocol = (pr)
multiline_comment|/* -------------------------------------------------------------------------- */
multiline_comment|/**&n; * struct usb_driver - identifies USB driver to usbcore&n; * @owner: Pointer to the module owner of this driver; initialize&n; *&t;it using THIS_MODULE.&n; * @name: The driver name should be unique among USB drivers,&n; *&t;and should normally be the same as the module name.&n; * @probe: Called to see if the driver is willing to manage a particular&n; *&t;interface on a device.  If it is, probe returns zero and uses&n; *&t;dev_set_drvdata() to associate driver-specific data with the&n; *&t;interface.  It may also use usb_set_interface() to specify the&n; *&t;appropriate altsetting.  If unwilling to manage the interface,&n; *&t;return a negative errno value.&n; * @disconnect: Called when the interface is no longer accessible, usually&n; *&t;because its device has been (or is being) disconnected or the&n; *&t;driver module is being unloaded.&n; * @ioctl: Used for drivers that want to talk to userspace through&n; *&t;the &quot;usbfs&quot; filesystem.  This lets devices provide ways to&n; *&t;expose information to user space regardless of where they&n; *&t;do (or don&squot;t) show up otherwise in the filesystem.&n; * @suspend: Called when the device is going to be suspended by the system.&n; * @resume: Called when the device is being resumed by the system.&n; * @id_table: USB drivers use ID table to support hotplugging.&n; *&t;Export this with MODULE_DEVICE_TABLE(usb,...).  This must be set&n; *&t;or your driver&squot;s probe function will never get called.&n; * @driver: the driver model core driver structure.&n; *&n; * USB drivers must provide a name, probe() and disconnect() methods,&n; * and an id_table.  Other driver fields are optional.&n; *&n; * The id_table is used in hotplugging.  It holds a set of descriptors,&n; * and specialized data may be associated with each entry.  That table&n; * is used by both user and kernel mode hotplugging support.&n; *&n; * The probe() and disconnect() methods are called in a context where&n; * they can sleep, but they should avoid abusing the privilege.  Most&n; * work to connect to a device should be done when the device is opened,&n; * and undone at the last close.  The disconnect code needs to address&n; * concurrency issues with respect to open() and close() methods, as&n; * well as forcing all pending I/O requests to complete (by unlinking&n; * them as necessary, and blocking until the unlinks complete).&n; */
DECL|struct|usb_driver
r_struct
id|usb_driver
(brace
DECL|member|owner
r_struct
id|module
op_star
id|owner
suffix:semicolon
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|probe
r_int
(paren
op_star
id|probe
)paren
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
suffix:semicolon
DECL|member|disconnect
r_void
(paren
op_star
id|disconnect
)paren
(paren
r_struct
id|usb_interface
op_star
id|intf
)paren
suffix:semicolon
DECL|member|ioctl
r_int
(paren
op_star
id|ioctl
)paren
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_int
r_int
id|code
comma
r_void
op_star
id|buf
)paren
suffix:semicolon
DECL|member|suspend
r_int
(paren
op_star
id|suspend
)paren
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
id|u32
id|state
)paren
suffix:semicolon
DECL|member|resume
r_int
(paren
op_star
id|resume
)paren
(paren
r_struct
id|usb_interface
op_star
id|intf
)paren
suffix:semicolon
DECL|member|id_table
r_const
r_struct
id|usb_device_id
op_star
id|id_table
suffix:semicolon
DECL|member|driver
r_struct
id|device_driver
id|driver
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|to_usb_driver
mdefine_line|#define&t;to_usb_driver(d) container_of(d, struct usb_driver, driver)
r_extern
r_struct
id|bus_type
id|usb_bus_type
suffix:semicolon
multiline_comment|/**&n; * struct usb_class_driver - identifies a USB driver that wants to use the USB major number&n; * @name: devfs name for this driver.  Will also be used by the driver&n; *&t;class code to create a usb class device.&n; * @fops: pointer to the struct file_operations of this driver.&n; * @mode: the mode for the devfs file to be created for this driver.&n; * @minor_base: the start of the minor range for this driver.&n; *&n; * This structure is used for the usb_register_dev() and&n; * usb_unregister_dev() functions, to consolidate a number of the&n; * parameters used for them.&n; */
DECL|struct|usb_class_driver
r_struct
id|usb_class_driver
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|fops
r_struct
id|file_operations
op_star
id|fops
suffix:semicolon
DECL|member|mode
id|mode_t
id|mode
suffix:semicolon
DECL|member|minor_base
r_int
id|minor_base
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * use these in module_init()/module_exit()&n; * and don&squot;t forget MODULE_DEVICE_TABLE(usb, ...)&n; */
r_extern
r_int
id|usb_register
c_func
(paren
r_struct
id|usb_driver
op_star
)paren
suffix:semicolon
r_extern
r_void
id|usb_deregister
c_func
(paren
r_struct
id|usb_driver
op_star
)paren
suffix:semicolon
r_extern
r_int
id|usb_register_dev
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_struct
id|usb_class_driver
op_star
id|class_driver
)paren
suffix:semicolon
r_extern
r_void
id|usb_deregister_dev
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_struct
id|usb_class_driver
op_star
id|class_driver
)paren
suffix:semicolon
r_extern
r_int
id|usb_disabled
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* -------------------------------------------------------------------------- */
multiline_comment|/*&n; * URB support, for asynchronous request completions&n; */
multiline_comment|/*&n; * urb-&gt;transfer_flags:&n; */
DECL|macro|URB_SHORT_NOT_OK
mdefine_line|#define URB_SHORT_NOT_OK&t;0x0001&t;/* report short reads as errors */
DECL|macro|URB_ISO_ASAP
mdefine_line|#define URB_ISO_ASAP&t;&t;0x0002&t;/* iso-only, urb-&gt;start_frame ignored */
DECL|macro|URB_NO_TRANSFER_DMA_MAP
mdefine_line|#define URB_NO_TRANSFER_DMA_MAP&t;0x0004&t;/* urb-&gt;transfer_dma valid on submit */
DECL|macro|URB_NO_SETUP_DMA_MAP
mdefine_line|#define URB_NO_SETUP_DMA_MAP&t;0x0008&t;/* urb-&gt;setup_dma valid on submit */
DECL|macro|URB_ASYNC_UNLINK
mdefine_line|#define URB_ASYNC_UNLINK&t;0x0010&t;/* usb_unlink_urb() returns asap */
DECL|macro|URB_NO_FSBR
mdefine_line|#define URB_NO_FSBR&t;&t;0x0020&t;/* UHCI-specific */
DECL|macro|URB_ZERO_PACKET
mdefine_line|#define URB_ZERO_PACKET&t;&t;0x0040&t;/* Finish bulk OUTs with short packet */
DECL|macro|URB_NO_INTERRUPT
mdefine_line|#define URB_NO_INTERRUPT&t;0x0080&t;/* HINT: no non-error interrupt needed */
DECL|struct|usb_iso_packet_descriptor
r_struct
id|usb_iso_packet_descriptor
(brace
DECL|member|offset
r_int
r_int
id|offset
suffix:semicolon
DECL|member|length
r_int
r_int
id|length
suffix:semicolon
multiline_comment|/* expected length */
DECL|member|actual_length
r_int
r_int
id|actual_length
suffix:semicolon
DECL|member|status
r_int
r_int
id|status
suffix:semicolon
)brace
suffix:semicolon
r_struct
id|urb
suffix:semicolon
r_struct
id|pt_regs
suffix:semicolon
DECL|typedef|usb_complete_t
r_typedef
r_void
(paren
op_star
id|usb_complete_t
)paren
(paren
r_struct
id|urb
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
multiline_comment|/**&n; * struct urb - USB Request Block&n; * @urb_list: For use by current owner of the URB.&n; * @pipe: Holds endpoint number, direction, type, and more.&n; *&t;Create these values with the eight macros available;&n; *&t;usb_{snd,rcv}TYPEpipe(dev,endpoint), where the TYPE is &quot;ctrl&quot;&n; *&t;(control), &quot;bulk&quot;, &quot;int&quot; (interrupt), or &quot;iso&quot; (isochronous).&n; *&t;For example usb_sndbulkpipe() or usb_rcvintpipe().  Endpoint&n; *&t;numbers range from zero to fifteen.  Note that &quot;in&quot; endpoint two&n; *&t;is a different endpoint (and pipe) from &quot;out&quot; endpoint two.&n; *&t;The current configuration controls the existence, type, and&n; *&t;maximum packet size of any given endpoint.&n; * @dev: Identifies the USB device to perform the request.&n; * @status: This is read in non-iso completion functions to get the&n; *&t;status of the particular request.  ISO requests only use it&n; *&t;to tell whether the URB was unlinked; detailed status for&n; *&t;each frame is in the fields of the iso_frame-desc.&n; * @transfer_flags: A variety of flags may be used to affect how URB&n; *&t;submission, unlinking, or operation are handled.  Different&n; *&t;kinds of URB can use different flags.&n; * @transfer_buffer:  This identifies the buffer to (or from) which&n; * &t;the I/O request will be performed (unless URB_NO_TRANSFER_DMA_MAP&n; *&t;is set).  This buffer must be suitable for DMA; allocate it with&n; *&t;kmalloc() or equivalent.  For transfers to &quot;in&quot; endpoints, contents&n; *&t;of this buffer will be modified.  This buffer is used for the data&n; *&t;stage of control transfers.&n; * @transfer_dma: When transfer_flags includes URB_NO_TRANSFER_DMA_MAP,&n; *&t;the device driver is saying that it provided this DMA address,&n; *&t;which the host controller driver should use in preference to the&n; *&t;transfer_buffer.&n; * @transfer_buffer_length: How big is transfer_buffer.  The transfer may&n; *&t;be broken up into chunks according to the current maximum packet&n; *&t;size for the endpoint, which is a function of the configuration&n; *&t;and is encoded in the pipe.  When the length is zero, neither&n; *&t;transfer_buffer nor transfer_dma is used.&n; * @actual_length: This is read in non-iso completion functions, and&n; *&t;it tells how many bytes (out of transfer_buffer_length) were&n; *&t;transferred.  It will normally be the same as requested, unless&n; *&t;either an error was reported or a short read was performed.&n; *&t;The URB_SHORT_NOT_OK transfer flag may be used to make such&n; *&t;short reads be reported as errors. &n; * @setup_packet: Only used for control transfers, this points to eight bytes&n; *&t;of setup data.  Control transfers always start by sending this data&n; *&t;to the device.  Then transfer_buffer is read or written, if needed.&n; * @setup_dma: For control transfers with URB_NO_SETUP_DMA_MAP set, the&n; *&t;device driver has provided this DMA address for the setup packet.&n; *&t;The host controller driver should use this in preference to&n; *&t;setup_packet.&n; * @start_frame: Returns the initial frame for isochronous transfers.&n; * @number_of_packets: Lists the number of ISO transfer buffers.&n; * @interval: Specifies the polling interval for interrupt or isochronous&n; *&t;transfers.  The units are frames (milliseconds) for for full and low&n; *&t;speed devices, and microframes (1/8 millisecond) for highspeed ones.&n; * @error_count: Returns the number of ISO transfers that reported errors.&n; * @context: For use in completion functions.  This normally points to&n; *&t;request-specific driver context.&n; * @complete: Completion handler. This URB is passed as the parameter to the&n; *&t;completion function.  The completion function may then do what&n; *&t;it likes with the URB, including resubmitting or freeing it.&n; * @iso_frame_desc: Used to provide arrays of ISO transfer buffers and to &n; *&t;collect the transfer status for each buffer.&n; *&n; * This structure identifies USB transfer requests.  URBs must be allocated by&n; * calling usb_alloc_urb() and freed with a call to usb_free_urb().&n; * Initialization may be done using various usb_fill_*_urb() functions.  URBs&n; * are submitted using usb_submit_urb(), and pending requests may be canceled&n; * using usb_unlink_urb() or usb_kill_urb().&n; *&n; * Data Transfer Buffers:&n; *&n; * Normally drivers provide I/O buffers allocated with kmalloc() or otherwise&n; * taken from the general page pool.  That is provided by transfer_buffer&n; * (control requests also use setup_packet), and host controller drivers&n; * perform a dma mapping (and unmapping) for each buffer transferred.  Those&n; * mapping operations can be expensive on some platforms (perhaps using a dma&n; * bounce buffer or talking to an IOMMU),&n; * although they&squot;re cheap on commodity x86 and ppc hardware.&n; *&n; * Alternatively, drivers may pass the URB_NO_xxx_DMA_MAP transfer flags,&n; * which tell the host controller driver that no such mapping is needed since&n; * the device driver is DMA-aware.  For example, a device driver might&n; * allocate a DMA buffer with usb_buffer_alloc() or call usb_buffer_map().&n; * When these transfer flags are provided, host controller drivers will&n; * attempt to use the dma addresses found in the transfer_dma and/or&n; * setup_dma fields rather than determining a dma address themselves.  (Note&n; * that transfer_buffer and setup_packet must still be set because not all&n; * host controllers use DMA, nor do virtual root hubs).&n; *&n; * Initialization:&n; *&n; * All URBs submitted must initialize the dev, pipe, transfer_flags (may be&n; * zero), and complete fields.&n; * The URB_ASYNC_UNLINK transfer flag affects later invocations of&n; * the usb_unlink_urb() routine.  Note: Failure to set URB_ASYNC_UNLINK&n; * with usb_unlink_urb() is deprecated.  For synchronous unlinks use&n; * usb_kill_urb() instead.&n; *&n; * All URBs must also initialize &n; * transfer_buffer and transfer_buffer_length.  They may provide the&n; * URB_SHORT_NOT_OK transfer flag, indicating that short reads are&n; * to be treated as errors; that flag is invalid for write requests.&n; *&n; * Bulk URBs may&n; * use the URB_ZERO_PACKET transfer flag, indicating that bulk OUT transfers&n; * should always terminate with a short packet, even if it means adding an&n; * extra zero length packet.&n; *&n; * Control URBs must provide a setup_packet.  The setup_packet and&n; * transfer_buffer may each be mapped for DMA or not, independently of&n; * the other.  The transfer_flags bits URB_NO_TRANSFER_DMA_MAP and&n; * URB_NO_SETUP_DMA_MAP indicate which buffers have already been mapped.&n; * URB_NO_SETUP_DMA_MAP is ignored for non-control URBs.&n; *&n; * Interrupt URBs must provide an interval, saying how often (in milliseconds&n; * or, for highspeed devices, 125 microsecond units)&n; * to poll for transfers.  After the URB has been submitted, the interval&n; * field reflects how the transfer was actually scheduled.&n; * The polling interval may be more frequent than requested.&n; * For example, some controllers have a maximum interval of 32 milliseconds,&n; * while others support intervals of up to 1024 milliseconds.&n; * Isochronous URBs also have transfer intervals.  (Note that for isochronous&n; * endpoints, as well as high speed interrupt endpoints, the encoding of&n; * the transfer interval in the endpoint descriptor is logarithmic.&n; * Device drivers must convert that value to linear units themselves.)&n; *&n; * Isochronous URBs normally use the URB_ISO_ASAP transfer flag, telling&n; * the host controller to schedule the transfer as soon as bandwidth&n; * utilization allows, and then set start_frame to reflect the actual frame&n; * selected during submission.  Otherwise drivers must specify the start_frame&n; * and handle the case where the transfer can&squot;t begin then.  However, drivers&n; * won&squot;t know how bandwidth is currently allocated, and while they can&n; * find the current frame using usb_get_current_frame_number () they can&squot;t&n; * know the range for that frame number.  (Ranges for frame counter values&n; * are HC-specific, and can go from 256 to 65536 frames from &quot;now&quot;.)&n; *&n; * Isochronous URBs have a different data transfer model, in part because&n; * the quality of service is only &quot;best effort&quot;.  Callers provide specially&n; * allocated URBs, with number_of_packets worth of iso_frame_desc structures&n; * at the end.  Each such packet is an individual ISO transfer.  Isochronous&n; * URBs are normally queued, submitted by drivers to arrange that&n; * transfers are at least double buffered, and then explicitly resubmitted&n; * in completion handlers, so&n; * that data (such as audio or video) streams at as constant a rate as the&n; * host controller scheduler can support.&n; *&n; * Completion Callbacks:&n; *&n; * The completion callback is made in_interrupt(), and one of the first&n; * things that a completion handler should do is check the status field.&n; * The status field is provided for all URBs.  It is used to report&n; * unlinked URBs, and status for all non-ISO transfers.  It should not&n; * be examined before the URB is returned to the completion handler.&n; *&n; * The context field is normally used to link URBs back to the relevant&n; * driver or request state.&n; *&n; * When the completion callback is invoked for non-isochronous URBs, the&n; * actual_length field tells how many bytes were transferred.  This field&n; * is updated even when the URB terminated with an error or was unlinked.&n; *&n; * ISO transfer status is reported in the status and actual_length fields&n; * of the iso_frame_desc array, and the number of errors is reported in&n; * error_count.  Completion callbacks for ISO transfers will normally&n; * (re)submit URBs to ensure a constant transfer rate.&n; */
DECL|struct|urb
r_struct
id|urb
(brace
multiline_comment|/* private, usb core and host controller only fields in the urb */
DECL|member|kref
r_struct
id|kref
id|kref
suffix:semicolon
multiline_comment|/* reference count of the URB */
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
multiline_comment|/* lock for the URB */
DECL|member|hcpriv
r_void
op_star
id|hcpriv
suffix:semicolon
multiline_comment|/* private data for host controller */
DECL|member|urb_list
r_struct
id|list_head
id|urb_list
suffix:semicolon
multiline_comment|/* list pointer to all active urbs */
DECL|member|bandwidth
r_int
id|bandwidth
suffix:semicolon
multiline_comment|/* bandwidth for INT/ISO request */
DECL|member|use_count
id|atomic_t
id|use_count
suffix:semicolon
multiline_comment|/* concurrent submissions counter */
DECL|member|reject
id|u8
id|reject
suffix:semicolon
multiline_comment|/* submissions will fail */
multiline_comment|/* public, documented fields in the urb that can be used by drivers */
DECL|member|dev
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
multiline_comment|/* (in) pointer to associated device */
DECL|member|pipe
r_int
r_int
id|pipe
suffix:semicolon
multiline_comment|/* (in) pipe information */
DECL|member|status
r_int
id|status
suffix:semicolon
multiline_comment|/* (return) non-ISO status */
DECL|member|transfer_flags
r_int
r_int
id|transfer_flags
suffix:semicolon
multiline_comment|/* (in) URB_SHORT_NOT_OK | ...*/
DECL|member|transfer_buffer
r_void
op_star
id|transfer_buffer
suffix:semicolon
multiline_comment|/* (in) associated data buffer */
DECL|member|transfer_dma
id|dma_addr_t
id|transfer_dma
suffix:semicolon
multiline_comment|/* (in) dma addr for transfer_buffer */
DECL|member|transfer_buffer_length
r_int
id|transfer_buffer_length
suffix:semicolon
multiline_comment|/* (in) data buffer length */
DECL|member|actual_length
r_int
id|actual_length
suffix:semicolon
multiline_comment|/* (return) actual transfer length */
DECL|member|setup_packet
r_int
r_char
op_star
id|setup_packet
suffix:semicolon
multiline_comment|/* (in) setup packet (control only) */
DECL|member|setup_dma
id|dma_addr_t
id|setup_dma
suffix:semicolon
multiline_comment|/* (in) dma addr for setup_packet */
DECL|member|start_frame
r_int
id|start_frame
suffix:semicolon
multiline_comment|/* (modify) start frame (ISO) */
DECL|member|number_of_packets
r_int
id|number_of_packets
suffix:semicolon
multiline_comment|/* (in) number of ISO packets */
DECL|member|interval
r_int
id|interval
suffix:semicolon
multiline_comment|/* (modify) transfer interval (INT/ISO) */
DECL|member|error_count
r_int
id|error_count
suffix:semicolon
multiline_comment|/* (return) number of ISO errors */
DECL|member|context
r_void
op_star
id|context
suffix:semicolon
multiline_comment|/* (in) context for completion */
DECL|member|complete
id|usb_complete_t
id|complete
suffix:semicolon
multiline_comment|/* (in) completion routine */
DECL|member|iso_frame_desc
r_struct
id|usb_iso_packet_descriptor
id|iso_frame_desc
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* (in) ISO ONLY */
)brace
suffix:semicolon
multiline_comment|/* -------------------------------------------------------------------------- */
multiline_comment|/**&n; * usb_fill_control_urb - initializes a control urb&n; * @urb: pointer to the urb to initialize.&n; * @dev: pointer to the struct usb_device for this urb.&n; * @pipe: the endpoint pipe&n; * @setup_packet: pointer to the setup_packet buffer&n; * @transfer_buffer: pointer to the transfer buffer&n; * @buffer_length: length of the transfer buffer&n; * @complete: pointer to the usb_complete_t function&n; * @context: what to set the urb context to.&n; *&n; * Initializes a control urb with the proper information needed to submit&n; * it to a device.&n; */
DECL|function|usb_fill_control_urb
r_static
r_inline
r_void
id|usb_fill_control_urb
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|pipe
comma
r_int
r_char
op_star
id|setup_packet
comma
r_void
op_star
id|transfer_buffer
comma
r_int
id|buffer_length
comma
id|usb_complete_t
id|complete
comma
r_void
op_star
id|context
)paren
(brace
id|spin_lock_init
c_func
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
id|urb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|urb-&gt;pipe
op_assign
id|pipe
suffix:semicolon
id|urb-&gt;setup_packet
op_assign
id|setup_packet
suffix:semicolon
id|urb-&gt;transfer_buffer
op_assign
id|transfer_buffer
suffix:semicolon
id|urb-&gt;transfer_buffer_length
op_assign
id|buffer_length
suffix:semicolon
id|urb-&gt;complete
op_assign
id|complete
suffix:semicolon
id|urb-&gt;context
op_assign
id|context
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_fill_bulk_urb - macro to help initialize a bulk urb&n; * @urb: pointer to the urb to initialize.&n; * @dev: pointer to the struct usb_device for this urb.&n; * @pipe: the endpoint pipe&n; * @transfer_buffer: pointer to the transfer buffer&n; * @buffer_length: length of the transfer buffer&n; * @complete: pointer to the usb_complete_t function&n; * @context: what to set the urb context to.&n; *&n; * Initializes a bulk urb with the proper information needed to submit it&n; * to a device.&n; */
DECL|function|usb_fill_bulk_urb
r_static
r_inline
r_void
id|usb_fill_bulk_urb
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|pipe
comma
r_void
op_star
id|transfer_buffer
comma
r_int
id|buffer_length
comma
id|usb_complete_t
id|complete
comma
r_void
op_star
id|context
)paren
(brace
id|spin_lock_init
c_func
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
id|urb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|urb-&gt;pipe
op_assign
id|pipe
suffix:semicolon
id|urb-&gt;transfer_buffer
op_assign
id|transfer_buffer
suffix:semicolon
id|urb-&gt;transfer_buffer_length
op_assign
id|buffer_length
suffix:semicolon
id|urb-&gt;complete
op_assign
id|complete
suffix:semicolon
id|urb-&gt;context
op_assign
id|context
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_fill_int_urb - macro to help initialize a interrupt urb&n; * @urb: pointer to the urb to initialize.&n; * @dev: pointer to the struct usb_device for this urb.&n; * @pipe: the endpoint pipe&n; * @transfer_buffer: pointer to the transfer buffer&n; * @buffer_length: length of the transfer buffer&n; * @complete: pointer to the usb_complete_t function&n; * @context: what to set the urb context to.&n; * @interval: what to set the urb interval to, encoded like&n; *&t;the endpoint descriptor&squot;s bInterval value.&n; *&n; * Initializes a interrupt urb with the proper information needed to submit&n; * it to a device.&n; * Note that high speed interrupt endpoints use a logarithmic encoding of&n; * the endpoint interval, and express polling intervals in microframes&n; * (eight per millisecond) rather than in frames (one per millisecond).&n; */
DECL|function|usb_fill_int_urb
r_static
r_inline
r_void
id|usb_fill_int_urb
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|pipe
comma
r_void
op_star
id|transfer_buffer
comma
r_int
id|buffer_length
comma
id|usb_complete_t
id|complete
comma
r_void
op_star
id|context
comma
r_int
id|interval
)paren
(brace
id|spin_lock_init
c_func
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
id|urb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|urb-&gt;pipe
op_assign
id|pipe
suffix:semicolon
id|urb-&gt;transfer_buffer
op_assign
id|transfer_buffer
suffix:semicolon
id|urb-&gt;transfer_buffer_length
op_assign
id|buffer_length
suffix:semicolon
id|urb-&gt;complete
op_assign
id|complete
suffix:semicolon
id|urb-&gt;context
op_assign
id|context
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
id|urb-&gt;interval
op_assign
l_int|1
op_lshift
(paren
id|interval
op_minus
l_int|1
)paren
suffix:semicolon
r_else
id|urb-&gt;interval
op_assign
id|interval
suffix:semicolon
id|urb-&gt;start_frame
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_extern
r_void
id|usb_init_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_extern
r_struct
id|urb
op_star
id|usb_alloc_urb
c_func
(paren
r_int
id|iso_packets
comma
r_int
id|mem_flags
)paren
suffix:semicolon
r_extern
r_void
id|usb_free_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
DECL|macro|usb_put_urb
mdefine_line|#define usb_put_urb usb_free_urb
r_extern
r_struct
id|urb
op_star
id|usb_get_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_extern
r_int
id|usb_submit_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mem_flags
)paren
suffix:semicolon
r_extern
r_int
id|usb_unlink_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_extern
r_void
id|usb_kill_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
DECL|macro|HAVE_USB_BUFFERS
mdefine_line|#define HAVE_USB_BUFFERS
r_void
op_star
id|usb_buffer_alloc
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|size
comma
r_int
id|mem_flags
comma
id|dma_addr_t
op_star
id|dma
)paren
suffix:semicolon
r_void
id|usb_buffer_free
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|size
comma
r_void
op_star
id|addr
comma
id|dma_addr_t
id|dma
)paren
suffix:semicolon
r_struct
id|urb
op_star
id|usb_buffer_map
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
macro_line|#if 0
r_void
id|usb_buffer_dmasync
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
macro_line|#endif
r_void
id|usb_buffer_unmap
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_struct
id|scatterlist
suffix:semicolon
r_int
id|usb_buffer_map_sg
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|pipe
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
)paren
suffix:semicolon
macro_line|#if 0
r_void
id|usb_buffer_dmasync_sg
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|pipe
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|n_hw_ents
)paren
suffix:semicolon
macro_line|#endif
r_void
id|usb_buffer_unmap_sg
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|pipe
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|n_hw_ents
)paren
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------*&n; *                         SYNCHRONOUS CALL SUPPORT                  *&n; *-------------------------------------------------------------------*/
r_extern
r_int
id|usb_control_msg
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|pipe
comma
id|__u8
id|request
comma
id|__u8
id|requesttype
comma
id|__u16
id|value
comma
id|__u16
id|index
comma
r_void
op_star
id|data
comma
id|__u16
id|size
comma
r_int
id|timeout
)paren
suffix:semicolon
r_extern
r_int
id|usb_bulk_msg
c_func
(paren
r_struct
id|usb_device
op_star
id|usb_dev
comma
r_int
r_int
id|pipe
comma
r_void
op_star
id|data
comma
r_int
id|len
comma
r_int
op_star
id|actual_length
comma
r_int
id|timeout
)paren
suffix:semicolon
multiline_comment|/* selective suspend/resume */
r_extern
r_int
id|usb_suspend_device
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
id|u32
id|state
)paren
suffix:semicolon
r_extern
r_int
id|usb_resume_device
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* wrappers around usb_control_msg() for the most common standard requests */
r_extern
r_int
id|usb_get_descriptor
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_char
id|desctype
comma
r_int
r_char
id|descindex
comma
r_void
op_star
id|buf
comma
r_int
id|size
)paren
suffix:semicolon
r_extern
r_int
id|usb_get_status
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|type
comma
r_int
id|target
comma
r_void
op_star
id|data
)paren
suffix:semicolon
r_extern
r_int
id|usb_get_string
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|langid
comma
r_int
r_char
id|index
comma
r_void
op_star
id|buf
comma
r_int
id|size
)paren
suffix:semicolon
r_extern
r_int
id|usb_string
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|index
comma
r_char
op_star
id|buf
comma
r_int
id|size
)paren
suffix:semicolon
multiline_comment|/* wrappers that also update important state inside usbcore */
r_extern
r_int
id|usb_clear_halt
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|pipe
)paren
suffix:semicolon
r_extern
r_int
id|usb_reset_configuration
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
suffix:semicolon
r_extern
r_int
id|usb_set_interface
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|ifnum
comma
r_int
id|alternate
)paren
suffix:semicolon
multiline_comment|/*&n; * timeouts, in seconds, used for sending/receiving control messages&n; * they typically complete within a few frames (msec) after they&squot;re issued&n; * USB identifies 5 second timeouts, maybe more in a few cases, and a few&n; * slow devices (like some MGE Ellipse UPSes) actually push that limit.&n; */
DECL|macro|USB_CTRL_GET_TIMEOUT
mdefine_line|#define USB_CTRL_GET_TIMEOUT&t;5
DECL|macro|USB_CTRL_SET_TIMEOUT
mdefine_line|#define USB_CTRL_SET_TIMEOUT&t;5
multiline_comment|/**&n; * struct usb_sg_request - support for scatter/gather I/O&n; * @status: zero indicates success, else negative errno&n; * @bytes: counts bytes transferred.&n; *&n; * These requests are initialized using usb_sg_init(), and then are used&n; * as request handles passed to usb_sg_wait() or usb_sg_cancel().  Most&n; * members of the request object aren&squot;t for driver access.&n; *&n; * The status and bytecount values are valid only after usb_sg_wait()&n; * returns.  If the status is zero, then the bytecount matches the total&n; * from the request.&n; *&n; * After an error completion, drivers may need to clear a halt condition&n; * on the endpoint.&n; */
DECL|struct|usb_sg_request
r_struct
id|usb_sg_request
(brace
DECL|member|status
r_int
id|status
suffix:semicolon
DECL|member|bytes
r_int
id|bytes
suffix:semicolon
multiline_comment|/* &n;&t; * members below are private to usbcore,&n;&t; * and are not provided for driver access!&n;&t; */
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|dev
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
DECL|member|pipe
r_int
id|pipe
suffix:semicolon
DECL|member|sg
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
DECL|member|nents
r_int
id|nents
suffix:semicolon
DECL|member|entries
r_int
id|entries
suffix:semicolon
DECL|member|urbs
r_struct
id|urb
op_star
op_star
id|urbs
suffix:semicolon
DECL|member|count
r_int
id|count
suffix:semicolon
DECL|member|complete
r_struct
id|completion
id|complete
suffix:semicolon
)brace
suffix:semicolon
r_int
id|usb_sg_init
(paren
r_struct
id|usb_sg_request
op_star
id|io
comma
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|pipe
comma
r_int
id|period
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
comma
r_int
id|length
comma
r_int
id|mem_flags
)paren
suffix:semicolon
r_void
id|usb_sg_cancel
(paren
r_struct
id|usb_sg_request
op_star
id|io
)paren
suffix:semicolon
r_void
id|usb_sg_wait
(paren
r_struct
id|usb_sg_request
op_star
id|io
)paren
suffix:semicolon
multiline_comment|/* -------------------------------------------------------------------------- */
multiline_comment|/*&n; * For various legacy reasons, Linux has a small cookie that&squot;s paired with&n; * a struct usb_device to identify an endpoint queue.  Queue characteristics&n; * are defined by the endpoint&squot;s descriptor.  This cookie is called a &quot;pipe&quot;,&n; * an unsigned int encoded as:&n; *&n; *  - direction:&t;bit 7&t;&t;(0 = Host-to-Device [Out],&n; *&t;&t;&t;&t;&t; 1 = Device-to-Host [In] ...&n; *&t;&t;&t;&t;&t;like endpoint bEndpointAddress)&n; *  - device address:&t;bits 8-14       ... bit positions known to uhci-hcd&n; *  - endpoint:&t;&t;bits 15-18      ... bit positions known to uhci-hcd&n; *  - pipe type:&t;bits 30-31&t;(00 = isochronous, 01 = interrupt,&n; *&t;&t;&t;&t;&t; 10 = control, 11 = bulk)&n; *&n; * Given the device address and endpoint descriptor, pipes are redundant.&n; */
multiline_comment|/* NOTE:  these are not the standard USB_ENDPOINT_XFER_* values!! */
multiline_comment|/* (yet ... they&squot;re the values used by usbfs) */
DECL|macro|PIPE_ISOCHRONOUS
mdefine_line|#define PIPE_ISOCHRONOUS&t;&t;0
DECL|macro|PIPE_INTERRUPT
mdefine_line|#define PIPE_INTERRUPT&t;&t;&t;1
DECL|macro|PIPE_CONTROL
mdefine_line|#define PIPE_CONTROL&t;&t;&t;2
DECL|macro|PIPE_BULK
mdefine_line|#define PIPE_BULK&t;&t;&t;3
DECL|macro|usb_pipein
mdefine_line|#define usb_pipein(pipe)&t;((pipe) &amp; USB_DIR_IN)
DECL|macro|usb_pipeout
mdefine_line|#define usb_pipeout(pipe)&t;(!usb_pipein(pipe))
DECL|macro|usb_pipedevice
mdefine_line|#define usb_pipedevice(pipe)&t;(((pipe) &gt;&gt; 8) &amp; 0x7f)
DECL|macro|usb_pipeendpoint
mdefine_line|#define usb_pipeendpoint(pipe)&t;(((pipe) &gt;&gt; 15) &amp; 0xf)
DECL|macro|usb_pipetype
mdefine_line|#define usb_pipetype(pipe)&t;(((pipe) &gt;&gt; 30) &amp; 3)
DECL|macro|usb_pipeisoc
mdefine_line|#define usb_pipeisoc(pipe)&t;(usb_pipetype((pipe)) == PIPE_ISOCHRONOUS)
DECL|macro|usb_pipeint
mdefine_line|#define usb_pipeint(pipe)&t;(usb_pipetype((pipe)) == PIPE_INTERRUPT)
DECL|macro|usb_pipecontrol
mdefine_line|#define usb_pipecontrol(pipe)&t;(usb_pipetype((pipe)) == PIPE_CONTROL)
DECL|macro|usb_pipebulk
mdefine_line|#define usb_pipebulk(pipe)&t;(usb_pipetype((pipe)) == PIPE_BULK)
multiline_comment|/* The D0/D1 toggle bits ... USE WITH CAUTION (they&squot;re almost hcd-internal) */
DECL|macro|usb_gettoggle
mdefine_line|#define usb_gettoggle(dev, ep, out) (((dev)-&gt;toggle[out] &gt;&gt; (ep)) &amp; 1)
DECL|macro|usb_dotoggle
mdefine_line|#define&t;usb_dotoggle(dev, ep, out)  ((dev)-&gt;toggle[out] ^= (1 &lt;&lt; (ep)))
DECL|macro|usb_settoggle
mdefine_line|#define usb_settoggle(dev, ep, out, bit) ((dev)-&gt;toggle[out] = ((dev)-&gt;toggle[out] &amp; ~(1 &lt;&lt; (ep))) | ((bit) &lt;&lt; (ep)))
DECL|function|__create_pipe
r_static
r_inline
r_int
r_int
id|__create_pipe
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|endpoint
)paren
(brace
r_return
(paren
id|dev-&gt;devnum
op_lshift
l_int|8
)paren
op_or
(paren
id|endpoint
op_lshift
l_int|15
)paren
suffix:semicolon
)brace
multiline_comment|/* Create various pipes... */
DECL|macro|usb_sndctrlpipe
mdefine_line|#define usb_sndctrlpipe(dev,endpoint)&t;((PIPE_CONTROL &lt;&lt; 30) | __create_pipe(dev,endpoint))
DECL|macro|usb_rcvctrlpipe
mdefine_line|#define usb_rcvctrlpipe(dev,endpoint)&t;((PIPE_CONTROL &lt;&lt; 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
DECL|macro|usb_sndisocpipe
mdefine_line|#define usb_sndisocpipe(dev,endpoint)&t;((PIPE_ISOCHRONOUS &lt;&lt; 30) | __create_pipe(dev,endpoint))
DECL|macro|usb_rcvisocpipe
mdefine_line|#define usb_rcvisocpipe(dev,endpoint)&t;((PIPE_ISOCHRONOUS &lt;&lt; 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
DECL|macro|usb_sndbulkpipe
mdefine_line|#define usb_sndbulkpipe(dev,endpoint)&t;((PIPE_BULK &lt;&lt; 30) | __create_pipe(dev,endpoint))
DECL|macro|usb_rcvbulkpipe
mdefine_line|#define usb_rcvbulkpipe(dev,endpoint)&t;((PIPE_BULK &lt;&lt; 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
DECL|macro|usb_sndintpipe
mdefine_line|#define usb_sndintpipe(dev,endpoint)&t;((PIPE_INTERRUPT &lt;&lt; 30) | __create_pipe(dev,endpoint))
DECL|macro|usb_rcvintpipe
mdefine_line|#define usb_rcvintpipe(dev,endpoint)&t;((PIPE_INTERRUPT &lt;&lt; 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_inline
id|__u16
DECL|function|usb_maxpacket
id|usb_maxpacket
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
comma
r_int
id|pipe
comma
r_int
id|is_out
)paren
(brace
r_struct
id|usb_host_endpoint
op_star
id|ep
suffix:semicolon
r_int
id|epnum
op_assign
id|usb_pipeendpoint
c_func
(paren
id|pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_out
)paren
(brace
id|WARN_ON
c_func
(paren
id|usb_pipein
c_func
(paren
id|pipe
)paren
)paren
suffix:semicolon
id|ep
op_assign
id|udev-&gt;ep_out
(braket
id|epnum
)braket
suffix:semicolon
)brace
r_else
(brace
id|WARN_ON
c_func
(paren
id|usb_pipeout
c_func
(paren
id|pipe
)paren
)paren
suffix:semicolon
id|ep
op_assign
id|udev-&gt;ep_in
(braket
id|epnum
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ep
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* NOTE:  only 0x07ff bits are for packet size... */
r_return
id|le16_to_cpu
c_func
(paren
id|ep-&gt;desc.wMaxPacketSize
)paren
suffix:semicolon
)brace
multiline_comment|/* -------------------------------------------------------------------------- */
macro_line|#ifdef DEBUG
DECL|macro|dbg
mdefine_line|#define dbg(format, arg...) printk(KERN_DEBUG &quot;%s: &quot; format &quot;&bslash;n&quot; , __FILE__ , ## arg)
macro_line|#else
DECL|macro|dbg
mdefine_line|#define dbg(format, arg...) do {} while (0)
macro_line|#endif
DECL|macro|err
mdefine_line|#define err(format, arg...) printk(KERN_ERR &quot;%s: &quot; format &quot;&bslash;n&quot; , __FILE__ , ## arg)
DECL|macro|info
mdefine_line|#define info(format, arg...) printk(KERN_INFO &quot;%s: &quot; format &quot;&bslash;n&quot; , __FILE__ , ## arg)
DECL|macro|warn
mdefine_line|#define warn(format, arg...) printk(KERN_WARNING &quot;%s: &quot; format &quot;&bslash;n&quot; , __FILE__ , ## arg)
macro_line|#endif  /* __KERNEL__ */
macro_line|#endif
eof
