macro_line|#ifndef _LINUX_RMAP_H
DECL|macro|_LINUX_RMAP_H
mdefine_line|#define _LINUX_RMAP_H
multiline_comment|/*&n; * Declarations for Reverse Mapping functions in mm/rmap.c&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
DECL|macro|page_map_lock
mdefine_line|#define page_map_lock(page) &bslash;&n;&t;bit_spin_lock(PG_maplock, (unsigned long *)&amp;(page)-&gt;flags)
DECL|macro|page_map_unlock
mdefine_line|#define page_map_unlock(page) &bslash;&n;&t;bit_spin_unlock(PG_maplock, (unsigned long *)&amp;(page)-&gt;flags)
multiline_comment|/*&n; * The anon_vma heads a list of private &quot;related&quot; vmas, to scan if&n; * an anonymous page pointing to this anon_vma needs to be unmapped:&n; * the vmas on the list will be related by forking, or by splitting.&n; *&n; * Since vmas come and go as they are split and merged (particularly&n; * in mprotect), the mapping field of an anonymous page cannot point&n; * directly to a vma: instead it points to an anon_vma, on whose list&n; * the related vmas can be easily linked or unlinked.&n; *&n; * After unlinking the last vma on the list, we must garbage collect&n; * the anon_vma object itself: we&squot;re guaranteed no page can be&n; * pointing to this anon_vma once its vma list is empty.&n; */
DECL|struct|anon_vma
r_struct
id|anon_vma
(brace
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
multiline_comment|/* Serialize access to vma list */
DECL|member|head
r_struct
id|list_head
id|head
suffix:semicolon
multiline_comment|/* List of private &quot;related&quot; vmas */
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_MMU
r_extern
id|kmem_cache_t
op_star
id|anon_vma_cachep
suffix:semicolon
DECL|function|anon_vma_alloc
r_static
r_inline
r_struct
id|anon_vma
op_star
id|anon_vma_alloc
c_func
(paren
r_void
)paren
(brace
r_return
id|kmem_cache_alloc
c_func
(paren
id|anon_vma_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
)brace
DECL|function|anon_vma_free
r_static
r_inline
r_void
id|anon_vma_free
c_func
(paren
r_struct
id|anon_vma
op_star
id|anon_vma
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|anon_vma_cachep
comma
id|anon_vma
)paren
suffix:semicolon
)brace
DECL|function|anon_vma_lock
r_static
r_inline
r_void
id|anon_vma_lock
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|anon_vma
op_star
id|anon_vma
op_assign
id|vma-&gt;anon_vma
suffix:semicolon
r_if
c_cond
(paren
id|anon_vma
)paren
id|spin_lock
c_func
(paren
op_amp
id|anon_vma-&gt;lock
)paren
suffix:semicolon
)brace
DECL|function|anon_vma_unlock
r_static
r_inline
r_void
id|anon_vma_unlock
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|anon_vma
op_star
id|anon_vma
op_assign
id|vma-&gt;anon_vma
suffix:semicolon
r_if
c_cond
(paren
id|anon_vma
)paren
id|spin_unlock
c_func
(paren
op_amp
id|anon_vma-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * anon_vma helper functions.&n; */
r_void
id|anon_vma_init
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* create anon_vma_cachep */
r_int
id|anon_vma_prepare
c_func
(paren
r_struct
id|vm_area_struct
op_star
)paren
suffix:semicolon
r_void
id|__anon_vma_merge
c_func
(paren
r_struct
id|vm_area_struct
op_star
comma
r_struct
id|vm_area_struct
op_star
)paren
suffix:semicolon
r_void
id|anon_vma_unlink
c_func
(paren
r_struct
id|vm_area_struct
op_star
)paren
suffix:semicolon
r_void
id|anon_vma_link
c_func
(paren
r_struct
id|vm_area_struct
op_star
)paren
suffix:semicolon
r_void
id|__anon_vma_link
c_func
(paren
r_struct
id|vm_area_struct
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * rmap interfaces called when adding or removing pte of page&n; */
r_void
id|page_add_anon_rmap
c_func
(paren
r_struct
id|page
op_star
comma
r_struct
id|vm_area_struct
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_void
id|page_add_file_rmap
c_func
(paren
r_struct
id|page
op_star
)paren
suffix:semicolon
r_void
id|page_remove_rmap
c_func
(paren
r_struct
id|page
op_star
)paren
suffix:semicolon
multiline_comment|/**&n; * page_dup_rmap - duplicate pte mapping to a page&n; * @page:&t;the page to add the mapping to&n; *&n; * For copy_page_range only: minimal extract from page_add_rmap,&n; * avoiding unnecessary tests (already checked) so it&squot;s quicker.&n; */
DECL|function|page_dup_rmap
r_static
r_inline
r_void
id|page_dup_rmap
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|page_map_lock
c_func
(paren
id|page
)paren
suffix:semicolon
id|page-&gt;mapcount
op_increment
suffix:semicolon
id|page_map_unlock
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called from mm/vmscan.c to handle paging out&n; */
r_int
id|page_referenced
c_func
(paren
r_struct
id|page
op_star
)paren
suffix:semicolon
r_int
id|try_to_unmap
c_func
(paren
r_struct
id|page
op_star
)paren
suffix:semicolon
macro_line|#else&t;/* !CONFIG_MMU */
DECL|macro|anon_vma_init
mdefine_line|#define anon_vma_init()&t;&t;do {} while (0)
DECL|macro|anon_vma_prepare
mdefine_line|#define anon_vma_prepare(vma)&t;(0)
DECL|macro|anon_vma_link
mdefine_line|#define anon_vma_link(vma)&t;do {} while (0)
DECL|macro|page_referenced
mdefine_line|#define page_referenced(page)&t;TestClearPageReferenced(page)
DECL|macro|try_to_unmap
mdefine_line|#define try_to_unmap(page)&t;SWAP_FAIL
macro_line|#endif&t;/* CONFIG_MMU */
multiline_comment|/*&n; * Return values of try_to_unmap&n; */
DECL|macro|SWAP_SUCCESS
mdefine_line|#define SWAP_SUCCESS&t;0
DECL|macro|SWAP_AGAIN
mdefine_line|#define SWAP_AGAIN&t;1
DECL|macro|SWAP_FAIL
mdefine_line|#define SWAP_FAIL&t;2
macro_line|#endif&t;/* _LINUX_RMAP_H */
eof
