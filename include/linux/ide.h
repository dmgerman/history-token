macro_line|#ifndef _IDE_H
DECL|macro|_IDE_H
mdefine_line|#define _IDE_H
multiline_comment|/*&n; *  linux/include/linux/ide.h&n; *&n; *  Copyright (C) 1994-2002  Linus Torvalds &amp; authors&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/hdsmart.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
multiline_comment|/*&n; * This is the multiple IDE interface driver, as evolved from hd.c.&n; * It supports up to four IDE interfaces, on one or more IRQs (usually 14 &amp; 15).&n; * There can be up to two drives per interface, as per the ATA-2 spec.&n; *&n; * Primary i/f:    ide0: major=3;  (hda)         minor=0; (hdb)         minor=64&n; * Secondary i/f:  ide1: major=22; (hdc or hd1a) minor=0; (hdd or hd1b) minor=64&n; * Tertiary i/f:   ide2: major=33; (hde)         minor=0; (hdf)         minor=64&n; * Quaternary i/f: ide3: major=34; (hdg)         minor=0; (hdh)         minor=64&n; */
multiline_comment|/******************************************************************************&n; * IDE driver configuration options (play with these as desired):&n; *&n; * REALLY_SLOW_IO can be defined in ide.c and ide-cd.c, if necessary&n; */
DECL|macro|INITIAL_MULT_COUNT
mdefine_line|#define INITIAL_MULT_COUNT&t;0&t;/* off=0; on=2,4,8,16,32, etc.. */
macro_line|#ifndef SUPPORT_SLOW_DATA_PORTS&t;&t;/* 1 to support slow data ports */
DECL|macro|SUPPORT_SLOW_DATA_PORTS
mdefine_line|#define SUPPORT_SLOW_DATA_PORTS&t;1&t;/* 0 to reduce kernel size */
macro_line|#endif
macro_line|#ifndef SUPPORT_VLB_SYNC&t;&t;/* 1 to support weird 32-bit chips */
DECL|macro|SUPPORT_VLB_SYNC
mdefine_line|#define SUPPORT_VLB_SYNC&t;1&t;/* 0 to reduce kernel size */
macro_line|#endif
macro_line|#ifndef OK_TO_RESET_CONTROLLER&t;&t;/* 1 needed for good error recovery */
DECL|macro|OK_TO_RESET_CONTROLLER
mdefine_line|#define OK_TO_RESET_CONTROLLER&t;1&t;/* 0 for use with AH2372A/B interface */
macro_line|#endif
macro_line|#ifndef DISABLE_IRQ_NOSYNC
DECL|macro|DISABLE_IRQ_NOSYNC
mdefine_line|#define DISABLE_IRQ_NOSYNC&t;0
macro_line|#endif
multiline_comment|/*&n; * Used to indicate &quot;no IRQ&quot;, should be a value that cannot be an IRQ&n; * number.&n; */
DECL|macro|IDE_NO_IRQ
mdefine_line|#define IDE_NO_IRQ&t;&t;(-1)
multiline_comment|/*&n; *  &quot;No user-serviceable parts&quot; beyond this point  :)&n; *****************************************************************************/
DECL|typedef|byte
r_typedef
r_int
r_char
id|byte
suffix:semicolon
multiline_comment|/* used everywhere */
multiline_comment|/*&n; * Probably not wise to fiddle with these&n; */
DECL|macro|ERROR_MAX
mdefine_line|#define ERROR_MAX&t;8&t;/* Max read/write errors per sector */
DECL|macro|ERROR_RESET
mdefine_line|#define ERROR_RESET&t;3&t;/* Reset controller every 4th retry */
DECL|macro|ERROR_RECAL
mdefine_line|#define ERROR_RECAL&t;1&t;/* Recalibrate every 2nd retry */
multiline_comment|/*&n; * Tune flags&n; */
DECL|macro|IDE_TUNE_NOAUTO
mdefine_line|#define IDE_TUNE_NOAUTO&t;&t;2
DECL|macro|IDE_TUNE_AUTO
mdefine_line|#define IDE_TUNE_AUTO&t;&t;1
DECL|macro|IDE_TUNE_DEFAULT
mdefine_line|#define IDE_TUNE_DEFAULT&t;0
multiline_comment|/*&n; * state flags&n; */
DECL|macro|DMA_PIO_RETRY
mdefine_line|#define DMA_PIO_RETRY&t;1&t;/* retrying in PIO */
DECL|macro|HWIF
mdefine_line|#define HWIF(drive)&t;&t;((ide_hwif_t *)((drive)-&gt;hwif))
DECL|macro|HWGROUP
mdefine_line|#define HWGROUP(drive)&t;&t;((ide_hwgroup_t *)(HWIF(drive)-&gt;hwgroup))
multiline_comment|/*&n; * Definitions for accessing IDE controller registers&n; */
DECL|macro|IDE_NR_PORTS
mdefine_line|#define IDE_NR_PORTS&t;&t;(10)
DECL|macro|IDE_DATA_OFFSET
mdefine_line|#define IDE_DATA_OFFSET&t;&t;(0)
DECL|macro|IDE_ERROR_OFFSET
mdefine_line|#define IDE_ERROR_OFFSET&t;(1)
DECL|macro|IDE_NSECTOR_OFFSET
mdefine_line|#define IDE_NSECTOR_OFFSET&t;(2)
DECL|macro|IDE_SECTOR_OFFSET
mdefine_line|#define IDE_SECTOR_OFFSET&t;(3)
DECL|macro|IDE_LCYL_OFFSET
mdefine_line|#define IDE_LCYL_OFFSET&t;&t;(4)
DECL|macro|IDE_HCYL_OFFSET
mdefine_line|#define IDE_HCYL_OFFSET&t;&t;(5)
DECL|macro|IDE_SELECT_OFFSET
mdefine_line|#define IDE_SELECT_OFFSET&t;(6)
DECL|macro|IDE_STATUS_OFFSET
mdefine_line|#define IDE_STATUS_OFFSET&t;(7)
DECL|macro|IDE_CONTROL_OFFSET
mdefine_line|#define IDE_CONTROL_OFFSET&t;(8)
DECL|macro|IDE_IRQ_OFFSET
mdefine_line|#define IDE_IRQ_OFFSET&t;&t;(9)
DECL|macro|IDE_FEATURE_OFFSET
mdefine_line|#define IDE_FEATURE_OFFSET&t;IDE_ERROR_OFFSET
DECL|macro|IDE_COMMAND_OFFSET
mdefine_line|#define IDE_COMMAND_OFFSET&t;IDE_STATUS_OFFSET
DECL|macro|IDE_CONTROL_OFFSET_HOB
mdefine_line|#define IDE_CONTROL_OFFSET_HOB&t;(7)
DECL|macro|IDE_DATA_REG
mdefine_line|#define IDE_DATA_REG&t;&t;(HWIF(drive)-&gt;io_ports[IDE_DATA_OFFSET])
DECL|macro|IDE_ERROR_REG
mdefine_line|#define IDE_ERROR_REG&t;&t;(HWIF(drive)-&gt;io_ports[IDE_ERROR_OFFSET])
DECL|macro|IDE_NSECTOR_REG
mdefine_line|#define IDE_NSECTOR_REG&t;&t;(HWIF(drive)-&gt;io_ports[IDE_NSECTOR_OFFSET])
DECL|macro|IDE_SECTOR_REG
mdefine_line|#define IDE_SECTOR_REG&t;&t;(HWIF(drive)-&gt;io_ports[IDE_SECTOR_OFFSET])
DECL|macro|IDE_LCYL_REG
mdefine_line|#define IDE_LCYL_REG&t;&t;(HWIF(drive)-&gt;io_ports[IDE_LCYL_OFFSET])
DECL|macro|IDE_HCYL_REG
mdefine_line|#define IDE_HCYL_REG&t;&t;(HWIF(drive)-&gt;io_ports[IDE_HCYL_OFFSET])
DECL|macro|IDE_SELECT_REG
mdefine_line|#define IDE_SELECT_REG&t;&t;(HWIF(drive)-&gt;io_ports[IDE_SELECT_OFFSET])
DECL|macro|IDE_STATUS_REG
mdefine_line|#define IDE_STATUS_REG&t;&t;(HWIF(drive)-&gt;io_ports[IDE_STATUS_OFFSET])
DECL|macro|IDE_CONTROL_REG
mdefine_line|#define IDE_CONTROL_REG&t;&t;(HWIF(drive)-&gt;io_ports[IDE_CONTROL_OFFSET])
DECL|macro|IDE_IRQ_REG
mdefine_line|#define IDE_IRQ_REG&t;&t;(HWIF(drive)-&gt;io_ports[IDE_IRQ_OFFSET])
DECL|macro|IDE_FEATURE_REG
mdefine_line|#define IDE_FEATURE_REG&t;&t;IDE_ERROR_REG
DECL|macro|IDE_COMMAND_REG
mdefine_line|#define IDE_COMMAND_REG&t;&t;IDE_STATUS_REG
DECL|macro|IDE_ALTSTATUS_REG
mdefine_line|#define IDE_ALTSTATUS_REG&t;IDE_CONTROL_REG
DECL|macro|IDE_IREASON_REG
mdefine_line|#define IDE_IREASON_REG&t;&t;IDE_NSECTOR_REG
DECL|macro|IDE_BCOUNTL_REG
mdefine_line|#define IDE_BCOUNTL_REG&t;&t;IDE_LCYL_REG
DECL|macro|IDE_BCOUNTH_REG
mdefine_line|#define IDE_BCOUNTH_REG&t;&t;IDE_HCYL_REG
DECL|macro|OK_STAT
mdefine_line|#define OK_STAT(stat,good,bad)&t;(((stat)&amp;((good)|(bad)))==(good))
DECL|macro|BAD_R_STAT
mdefine_line|#define BAD_R_STAT&t;&t;(BUSY_STAT   | ERR_STAT)
DECL|macro|BAD_W_STAT
mdefine_line|#define BAD_W_STAT&t;&t;(BAD_R_STAT  | WRERR_STAT)
DECL|macro|BAD_STAT
mdefine_line|#define BAD_STAT&t;&t;(BAD_R_STAT  | DRQ_STAT)
DECL|macro|DRIVE_READY
mdefine_line|#define DRIVE_READY&t;&t;(READY_STAT  | SEEK_STAT)
DECL|macro|DATA_READY
mdefine_line|#define DATA_READY&t;&t;(DRQ_STAT)
DECL|macro|BAD_CRC
mdefine_line|#define BAD_CRC&t;&t;&t;(ABRT_ERR    | ICRC_ERR)
DECL|macro|SATA_NR_PORTS
mdefine_line|#define SATA_NR_PORTS&t;&t;(3)&t;/* 16 possible ?? */
DECL|macro|SATA_STATUS_OFFSET
mdefine_line|#define SATA_STATUS_OFFSET&t;(0)
DECL|macro|SATA_STATUS_REG
mdefine_line|#define SATA_STATUS_REG&t;&t;(HWIF(drive)-&gt;sata_scr[SATA_STATUS_OFFSET])
DECL|macro|SATA_ERROR_OFFSET
mdefine_line|#define SATA_ERROR_OFFSET&t;(1)
DECL|macro|SATA_ERROR_REG
mdefine_line|#define SATA_ERROR_REG&t;&t;(HWIF(drive)-&gt;sata_scr[SATA_ERROR_OFFSET])
DECL|macro|SATA_CONTROL_OFFSET
mdefine_line|#define SATA_CONTROL_OFFSET&t;(2)
DECL|macro|SATA_CONTROL_REG
mdefine_line|#define SATA_CONTROL_REG&t;(HWIF(drive)-&gt;sata_scr[SATA_CONTROL_OFFSET])
DECL|macro|SATA_MISC_OFFSET
mdefine_line|#define SATA_MISC_OFFSET&t;(0)
DECL|macro|SATA_MISC_REG
mdefine_line|#define SATA_MISC_REG&t;&t;(HWIF(drive)-&gt;sata_misc[SATA_MISC_OFFSET])
DECL|macro|SATA_PHY_OFFSET
mdefine_line|#define SATA_PHY_OFFSET&t;&t;(1)
DECL|macro|SATA_PHY_REG
mdefine_line|#define SATA_PHY_REG&t;&t;(HWIF(drive)-&gt;sata_misc[SATA_PHY_OFFSET])
DECL|macro|SATA_IEN_OFFSET
mdefine_line|#define SATA_IEN_OFFSET&t;&t;(2)
DECL|macro|SATA_IEN_REG
mdefine_line|#define SATA_IEN_REG&t;&t;(HWIF(drive)-&gt;sata_misc[SATA_IEN_OFFSET])
multiline_comment|/*&n; * Our Physical Region Descriptor (PRD) table should be large enough&n; * to handle the biggest I/O request we are likely to see.  Since requests&n; * can have no more than 256 sectors, and since the typical blocksize is&n; * two or more sectors, we could get by with a limit of 128 entries here for&n; * the usual worst case.  Most requests seem to include some contiguous blocks,&n; * further reducing the number of table entries required.&n; *&n; * The driver reverts to PIO mode for individual requests that exceed&n; * this limit (possible with 512 byte blocksizes, eg. MSDOS f/s), so handling&n; * 100% of all crazy scenarios here is not necessary.&n; *&n; * As it turns out though, we must allocate a full 4KB page for this,&n; * so the two PRD tables (ide0 &amp; ide1) will each get half of that,&n; * allowing each to have about 256 entries (8 bytes each) from this.&n; */
DECL|macro|PRD_BYTES
mdefine_line|#define PRD_BYTES       8
DECL|macro|PRD_ENTRIES
mdefine_line|#define PRD_ENTRIES&t;256
multiline_comment|/*&n; * Some more useful definitions&n; */
DECL|macro|PARTN_BITS
mdefine_line|#define PARTN_BITS&t;6&t;/* number of minor dev bits for partitions */
DECL|macro|MAX_DRIVES
mdefine_line|#define MAX_DRIVES&t;2&t;/* per interface; 2 assumed by lots of code */
DECL|macro|SECTOR_SIZE
mdefine_line|#define SECTOR_SIZE&t;512
DECL|macro|SECTOR_WORDS
mdefine_line|#define SECTOR_WORDS&t;(SECTOR_SIZE / 4)&t;/* number of 32bit words per sector */
DECL|macro|IDE_LARGE_SEEK
mdefine_line|#define IDE_LARGE_SEEK(b1,b2,t)&t;(((b1) &gt; (b2) + (t)) || ((b2) &gt; (b1) + (t)))
multiline_comment|/*&n; * Timeouts for various operations:&n; */
DECL|macro|WAIT_DRQ
mdefine_line|#define WAIT_DRQ&t;(HZ/10)&t;&t;/* 100msec - spec allows up to 20ms */
DECL|macro|WAIT_READY
mdefine_line|#define WAIT_READY&t;(5*HZ)&t;&t;/* 5sec - some laptops are very slow */
DECL|macro|WAIT_PIDENTIFY
mdefine_line|#define WAIT_PIDENTIFY&t;(10*HZ)&t;/* 10sec  - should be less than 3ms (?), if all ATAPI CD is closed at boot */
DECL|macro|WAIT_WORSTCASE
mdefine_line|#define WAIT_WORSTCASE&t;(30*HZ)&t;/* 30sec  - worst case when spinning up */
DECL|macro|WAIT_CMD
mdefine_line|#define WAIT_CMD&t;(10*HZ)&t;/* 10sec  - maximum wait for an IRQ to happen */
DECL|macro|WAIT_MIN_SLEEP
mdefine_line|#define WAIT_MIN_SLEEP&t;(2*HZ/100)&t;/* 20msec - minimum sleep time */
DECL|macro|HOST
mdefine_line|#define HOST(hwif,chipset)&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;return ((hwif)-&gt;chipset == chipset) ? 1 : 0;&t;&t;&bslash;&n;}
multiline_comment|/*&n; * Check for an interrupt and acknowledge the interrupt status&n; */
r_struct
id|hwif_s
suffix:semicolon
DECL|typedef|ide_ack_intr_t
r_typedef
r_int
(paren
id|ide_ack_intr_t
)paren
(paren
r_struct
id|hwif_s
op_star
)paren
suffix:semicolon
macro_line|#ifndef NO_DMA
DECL|macro|NO_DMA
mdefine_line|#define NO_DMA  255
macro_line|#endif
multiline_comment|/*&n; * hwif_chipset_t is used to keep track of the specific hardware&n; * chipset used by each IDE interface, if known.&n; */
DECL|enumerator|ide_unknown
DECL|enumerator|ide_generic
DECL|enumerator|ide_pci
r_typedef
r_enum
(brace
id|ide_unknown
comma
id|ide_generic
comma
id|ide_pci
comma
DECL|enumerator|ide_cmd640
DECL|enumerator|ide_dtc2278
DECL|enumerator|ide_ali14xx
id|ide_cmd640
comma
id|ide_dtc2278
comma
id|ide_ali14xx
comma
DECL|enumerator|ide_qd65xx
DECL|enumerator|ide_umc8672
DECL|enumerator|ide_ht6560b
id|ide_qd65xx
comma
id|ide_umc8672
comma
id|ide_ht6560b
comma
DECL|enumerator|ide_rz1000
DECL|enumerator|ide_trm290
id|ide_rz1000
comma
id|ide_trm290
comma
DECL|enumerator|ide_cmd646
DECL|enumerator|ide_cy82c693
DECL|enumerator|ide_4drives
id|ide_cmd646
comma
id|ide_cy82c693
comma
id|ide_4drives
comma
DECL|enumerator|ide_pmac
DECL|enumerator|ide_etrax100
DECL|enumerator|ide_acorn
id|ide_pmac
comma
id|ide_etrax100
comma
id|ide_acorn
comma
DECL|enumerator|ide_forced
id|ide_forced
DECL|typedef|hwif_chipset_t
)brace
id|hwif_chipset_t
suffix:semicolon
multiline_comment|/*&n; * Structure to hold all information about the location of this port&n; */
DECL|struct|hw_regs_s
r_typedef
r_struct
id|hw_regs_s
(brace
DECL|member|io_ports
r_int
r_int
id|io_ports
(braket
id|IDE_NR_PORTS
)braket
suffix:semicolon
multiline_comment|/* task file registers */
DECL|member|irq
r_int
id|irq
suffix:semicolon
multiline_comment|/* our irq number */
DECL|member|dma
r_int
id|dma
suffix:semicolon
multiline_comment|/* our dma entry */
DECL|member|ack_intr
id|ide_ack_intr_t
op_star
id|ack_intr
suffix:semicolon
multiline_comment|/* acknowledge interrupt */
DECL|member|chipset
id|hwif_chipset_t
id|chipset
suffix:semicolon
DECL|typedef|hw_regs_t
)brace
id|hw_regs_t
suffix:semicolon
multiline_comment|/*&n; * Register new hardware with ide&n; */
r_int
id|ide_register_hw
c_func
(paren
id|hw_regs_t
op_star
id|hw
comma
r_struct
id|hwif_s
op_star
op_star
id|hwifp
)paren
suffix:semicolon
r_int
id|ide_register_hw_with_fixup
c_func
(paren
id|hw_regs_t
op_star
comma
r_struct
id|hwif_s
op_star
op_star
comma
r_void
(paren
op_star
)paren
(paren
r_struct
id|hwif_s
op_star
)paren
)paren
suffix:semicolon
multiline_comment|/*&n; * Set up hw_regs_t structure before calling ide_register_hw (optional)&n; */
r_void
id|ide_setup_ports
c_func
(paren
id|hw_regs_t
op_star
id|hw
comma
r_int
r_int
id|base
comma
r_int
op_star
id|offsets
comma
r_int
r_int
id|ctrl
comma
r_int
r_int
id|intr
comma
id|ide_ack_intr_t
op_star
id|ack_intr
comma
macro_line|#if 0
id|ide_io_ops_t
op_star
id|iops
comma
macro_line|#endif
r_int
id|irq
)paren
suffix:semicolon
DECL|function|ide_std_init_ports
r_static
r_inline
r_void
id|ide_std_init_ports
c_func
(paren
id|hw_regs_t
op_star
id|hw
comma
r_int
r_int
id|io_addr
comma
r_int
r_int
id|ctl_addr
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|IDE_DATA_OFFSET
suffix:semicolon
id|i
op_le
id|IDE_STATUS_OFFSET
suffix:semicolon
id|i
op_increment
)paren
id|hw-&gt;io_ports
(braket
id|i
)braket
op_assign
id|io_addr
op_increment
suffix:semicolon
id|hw-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
op_assign
id|ctl_addr
suffix:semicolon
)brace
macro_line|#include &lt;asm/ide.h&gt;
multiline_comment|/* needed on alpha, x86/x86_64, ia64, mips, ppc32 and sh */
macro_line|#ifndef IDE_ARCH_OBSOLETE_DEFAULTS
DECL|macro|ide_default_io_base
macro_line|# define ide_default_io_base(index)&t;(0)
DECL|macro|ide_default_irq
macro_line|# define ide_default_irq(base)&t;&t;(0)
DECL|macro|ide_init_default_irq
macro_line|# define ide_init_default_irq(base)&t;(0)
macro_line|#endif
multiline_comment|/*&n; * ide_init_hwif_ports() is OBSOLETE and will be removed in 2.7 series.&n; * New ports shouldn&squot;t define IDE_ARCH_OBSOLETE_INIT in &lt;asm/ide.h&gt;.&n; */
macro_line|#ifdef IDE_ARCH_OBSOLETE_INIT
DECL|function|ide_init_hwif_ports
r_static
r_inline
r_void
id|ide_init_hwif_ports
c_func
(paren
id|hw_regs_t
op_star
id|hw
comma
r_int
r_int
id|io_addr
comma
r_int
r_int
id|ctl_addr
comma
r_int
op_star
id|irq
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ctl_addr
)paren
id|ide_std_init_ports
c_func
(paren
id|hw
comma
id|io_addr
comma
id|ide_default_io_ctl
c_func
(paren
id|io_addr
)paren
)paren
suffix:semicolon
r_else
id|ide_std_init_ports
c_func
(paren
id|hw
comma
id|io_addr
comma
id|ctl_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
)paren
op_star
id|irq
op_assign
l_int|0
suffix:semicolon
id|hw-&gt;io_ports
(braket
id|IDE_IRQ_OFFSET
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_PPC32
r_if
c_cond
(paren
id|ppc_ide_md.ide_init_hwif
)paren
id|ppc_ide_md
dot
id|ide_init_hwif
c_func
(paren
id|hw
comma
id|io_addr
comma
id|ctl_addr
comma
id|irq
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#else
DECL|function|ide_init_hwif_ports
r_static
r_inline
r_void
id|ide_init_hwif_ports
c_func
(paren
id|hw_regs_t
op_star
id|hw
comma
r_int
r_int
id|io_addr
comma
r_int
r_int
id|ctl_addr
comma
r_int
op_star
id|irq
)paren
(brace
r_if
c_cond
(paren
id|io_addr
op_logical_or
id|ctl_addr
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: must not be called&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
macro_line|#endif /* IDE_ARCH_OBSOLETE_INIT */
multiline_comment|/* Currently only m68k, apus and m8xx need it */
macro_line|#ifndef IDE_ARCH_ACK_INTR
DECL|macro|ide_ack_intr
macro_line|# define ide_ack_intr(hwif) (1)
macro_line|#endif
multiline_comment|/* Currently only Atari needs it */
macro_line|#ifndef IDE_ARCH_LOCK
DECL|macro|ide_release_lock
macro_line|# define ide_release_lock()&t;&t;&t;do {} while (0)
DECL|macro|ide_get_lock
macro_line|# define ide_get_lock(hdlr, data)&t;&t;do {} while (0)
macro_line|#endif /* IDE_ARCH_LOCK */
multiline_comment|/*&n; * Now for the data we need to maintain per-drive:  ide_drive_t&n; */
DECL|macro|ide_scsi
mdefine_line|#define ide_scsi&t;0x21
DECL|macro|ide_disk
mdefine_line|#define ide_disk&t;0x20
DECL|macro|ide_optical
mdefine_line|#define ide_optical&t;0x7
DECL|macro|ide_cdrom
mdefine_line|#define ide_cdrom&t;0x5
DECL|macro|ide_tape
mdefine_line|#define ide_tape&t;0x1
DECL|macro|ide_floppy
mdefine_line|#define ide_floppy&t;0x0
multiline_comment|/*&n; * Special Driver Flags&n; *&n; * set_geometry&t;: respecify drive geometry&n; * recalibrate&t;: seek to cyl 0&n; * set_multmode&t;: set multmode count&n; * set_tune&t;: tune interface for drive&n; * serviced&t;: service command&n; * reserved&t;: unused&n; */
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|8
suffix:semicolon
r_struct
(brace
macro_line|#if defined(__LITTLE_ENDIAN_BITFIELD)
DECL|member|set_geometry
r_int
id|set_geometry
suffix:colon
l_int|1
suffix:semicolon
DECL|member|recalibrate
r_int
id|recalibrate
suffix:colon
l_int|1
suffix:semicolon
DECL|member|set_multmode
r_int
id|set_multmode
suffix:colon
l_int|1
suffix:semicolon
DECL|member|set_tune
r_int
id|set_tune
suffix:colon
l_int|1
suffix:semicolon
DECL|member|serviced
r_int
id|serviced
suffix:colon
l_int|1
suffix:semicolon
DECL|member|reserved
r_int
id|reserved
suffix:colon
l_int|3
suffix:semicolon
macro_line|#elif defined(__BIG_ENDIAN_BITFIELD)
r_int
id|reserved
suffix:colon
l_int|3
suffix:semicolon
r_int
id|serviced
suffix:colon
l_int|1
suffix:semicolon
r_int
id|set_tune
suffix:colon
l_int|1
suffix:semicolon
r_int
id|set_multmode
suffix:colon
l_int|1
suffix:semicolon
r_int
id|recalibrate
suffix:colon
l_int|1
suffix:semicolon
r_int
id|set_geometry
suffix:colon
l_int|1
suffix:semicolon
macro_line|#else
macro_line|#error &quot;Please fix &lt;asm/byteorder.h&gt;&quot;
macro_line|#endif
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|special_t
)brace
id|special_t
suffix:semicolon
multiline_comment|/*&n; * ATA DATA Register Special.&n; * ATA NSECTOR Count Register().&n; * ATAPI Byte Count Register.&n; * Channel index ordering pairs.&n; */
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|16
suffix:semicolon
r_struct
(brace
macro_line|#if defined(__LITTLE_ENDIAN_BITFIELD)
DECL|member|low
r_int
id|low
suffix:colon
l_int|8
suffix:semicolon
multiline_comment|/* LSB */
DECL|member|high
r_int
id|high
suffix:colon
l_int|8
suffix:semicolon
multiline_comment|/* MSB */
macro_line|#elif defined(__BIG_ENDIAN_BITFIELD)
r_int
id|high
suffix:colon
l_int|8
suffix:semicolon
multiline_comment|/* MSB */
r_int
id|low
suffix:colon
l_int|8
suffix:semicolon
multiline_comment|/* LSB */
macro_line|#else
macro_line|#error &quot;Please fix &lt;asm/byteorder.h&gt;&quot;
macro_line|#endif
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|ata_nsector_t
DECL|typedef|ata_data_t
DECL|typedef|atapi_bcount_t
DECL|typedef|ata_index_t
)brace
id|ata_nsector_t
comma
id|ata_data_t
comma
id|atapi_bcount_t
comma
id|ata_index_t
suffix:semicolon
multiline_comment|/*&n; * ATA-IDE Error Register&n; *&n; * mark&t;&t;: Bad address mark&n; * tzero&t;: Couldn&squot;t find track 0&n; * abrt&t;&t;: Aborted Command&n; * mcr&t;&t;: Media Change Request&n; * id&t;&t;: ID field not found&n; * mce&t;&t;: Media Change Event&n; * ecc&t;&t;: Uncorrectable ECC error&n; * bdd&t;&t;: dual meaing&n; */
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|8
suffix:semicolon
r_struct
(brace
macro_line|#if defined(__LITTLE_ENDIAN_BITFIELD)
DECL|member|mark
r_int
id|mark
suffix:colon
l_int|1
suffix:semicolon
DECL|member|tzero
r_int
id|tzero
suffix:colon
l_int|1
suffix:semicolon
DECL|member|abrt
r_int
id|abrt
suffix:colon
l_int|1
suffix:semicolon
DECL|member|mcr
r_int
id|mcr
suffix:colon
l_int|1
suffix:semicolon
DECL|member|id
r_int
id|id
suffix:colon
l_int|1
suffix:semicolon
DECL|member|mce
r_int
id|mce
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ecc
r_int
id|ecc
suffix:colon
l_int|1
suffix:semicolon
DECL|member|bdd
r_int
id|bdd
suffix:colon
l_int|1
suffix:semicolon
macro_line|#elif defined(__BIG_ENDIAN_BITFIELD)
r_int
id|bdd
suffix:colon
l_int|1
suffix:semicolon
r_int
id|ecc
suffix:colon
l_int|1
suffix:semicolon
r_int
id|mce
suffix:colon
l_int|1
suffix:semicolon
r_int
id|id
suffix:colon
l_int|1
suffix:semicolon
r_int
id|mcr
suffix:colon
l_int|1
suffix:semicolon
r_int
id|abrt
suffix:colon
l_int|1
suffix:semicolon
r_int
id|tzero
suffix:colon
l_int|1
suffix:semicolon
r_int
id|mark
suffix:colon
l_int|1
suffix:semicolon
macro_line|#else
macro_line|#error &quot;Please fix &lt;asm/byteorder.h&gt;&quot;
macro_line|#endif
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|ata_error_t
)brace
id|ata_error_t
suffix:semicolon
multiline_comment|/*&n; * ATA-IDE Select Register, aka Device-Head&n; *&n; * head&t;&t;: always zeros here&n; * unit&t;&t;: drive select number: 0/1&n; * bit5&t;&t;: always 1&n; * lba&t;&t;: using LBA instead of CHS&n; * bit7&t;&t;: always 1&n; */
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|8
suffix:semicolon
r_struct
(brace
macro_line|#if defined(__LITTLE_ENDIAN_BITFIELD)
DECL|member|head
r_int
id|head
suffix:colon
l_int|4
suffix:semicolon
DECL|member|unit
r_int
id|unit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|bit5
r_int
id|bit5
suffix:colon
l_int|1
suffix:semicolon
DECL|member|lba
r_int
id|lba
suffix:colon
l_int|1
suffix:semicolon
DECL|member|bit7
r_int
id|bit7
suffix:colon
l_int|1
suffix:semicolon
macro_line|#elif defined(__BIG_ENDIAN_BITFIELD)
r_int
id|bit7
suffix:colon
l_int|1
suffix:semicolon
r_int
id|lba
suffix:colon
l_int|1
suffix:semicolon
r_int
id|bit5
suffix:colon
l_int|1
suffix:semicolon
r_int
id|unit
suffix:colon
l_int|1
suffix:semicolon
r_int
id|head
suffix:colon
l_int|4
suffix:semicolon
macro_line|#else
macro_line|#error &quot;Please fix &lt;asm/byteorder.h&gt;&quot;
macro_line|#endif
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|select_t
DECL|typedef|ata_select_t
)brace
id|select_t
comma
id|ata_select_t
suffix:semicolon
multiline_comment|/*&n; * The ATA-IDE Status Register.&n; * The ATAPI Status Register.&n; *&n; * check&t;: Error occurred&n; * idx&t;&t;: Index Error&n; * corr&t;&t;: Correctable error occurred&n; * drq&t;&t;: Data is request by the device&n; * dsc&t;&t;: Disk Seek Complete&t;&t;&t;: ata&n; *&t;&t;: Media access command finished&t;&t;: atapi&n; * df&t;&t;: Device Fault&t;&t;&t;&t;: ata&n; *&t;&t;: Reserved&t;&t;&t;&t;: atapi&n; * drdy&t;&t;: Ready, Command Mode Capable&t;&t;: ata&n; *&t;&t;: Ignored for ATAPI commands&t;&t;: atapi&n; * bsy&t;&t;: Disk is Busy&n; *&t;&t;: The device has access to the command block&n; */
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|8
suffix:semicolon
r_struct
(brace
macro_line|#if defined(__LITTLE_ENDIAN_BITFIELD)
DECL|member|check
r_int
id|check
suffix:colon
l_int|1
suffix:semicolon
DECL|member|idx
r_int
id|idx
suffix:colon
l_int|1
suffix:semicolon
DECL|member|corr
r_int
id|corr
suffix:colon
l_int|1
suffix:semicolon
DECL|member|drq
r_int
id|drq
suffix:colon
l_int|1
suffix:semicolon
DECL|member|dsc
r_int
id|dsc
suffix:colon
l_int|1
suffix:semicolon
DECL|member|df
r_int
id|df
suffix:colon
l_int|1
suffix:semicolon
DECL|member|drdy
r_int
id|drdy
suffix:colon
l_int|1
suffix:semicolon
DECL|member|bsy
r_int
id|bsy
suffix:colon
l_int|1
suffix:semicolon
macro_line|#elif defined(__BIG_ENDIAN_BITFIELD)
r_int
id|bsy
suffix:colon
l_int|1
suffix:semicolon
r_int
id|drdy
suffix:colon
l_int|1
suffix:semicolon
r_int
id|df
suffix:colon
l_int|1
suffix:semicolon
r_int
id|dsc
suffix:colon
l_int|1
suffix:semicolon
r_int
id|drq
suffix:colon
l_int|1
suffix:semicolon
r_int
id|corr
suffix:colon
l_int|1
suffix:semicolon
r_int
id|idx
suffix:colon
l_int|1
suffix:semicolon
r_int
id|check
suffix:colon
l_int|1
suffix:semicolon
macro_line|#else
macro_line|#error &quot;Please fix &lt;asm/byteorder.h&gt;&quot;
macro_line|#endif
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|ata_status_t
DECL|typedef|atapi_status_t
)brace
id|ata_status_t
comma
id|atapi_status_t
suffix:semicolon
multiline_comment|/*&n; * ATA-IDE Control Register&n; *&n; * bit0&t;&t;: Should be set to zero&n; * nIEN&t;&t;: device INTRQ to host&n; * SRST&t;&t;: host soft reset bit&n; * bit3&t;&t;: ATA-2 thingy, Should be set to 1&n; * reserved456&t;: Reserved&n; * HOB&t;&t;: 48-bit address ordering, High Ordered Bit&n; */
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|8
suffix:semicolon
r_struct
(brace
macro_line|#if defined(__LITTLE_ENDIAN_BITFIELD)
DECL|member|bit0
r_int
id|bit0
suffix:colon
l_int|1
suffix:semicolon
DECL|member|nIEN
r_int
id|nIEN
suffix:colon
l_int|1
suffix:semicolon
DECL|member|SRST
r_int
id|SRST
suffix:colon
l_int|1
suffix:semicolon
DECL|member|bit3
r_int
id|bit3
suffix:colon
l_int|1
suffix:semicolon
DECL|member|reserved456
r_int
id|reserved456
suffix:colon
l_int|3
suffix:semicolon
DECL|member|HOB
r_int
id|HOB
suffix:colon
l_int|1
suffix:semicolon
macro_line|#elif defined(__BIG_ENDIAN_BITFIELD)
r_int
id|HOB
suffix:colon
l_int|1
suffix:semicolon
r_int
id|reserved456
suffix:colon
l_int|3
suffix:semicolon
r_int
id|bit3
suffix:colon
l_int|1
suffix:semicolon
r_int
id|SRST
suffix:colon
l_int|1
suffix:semicolon
r_int
id|nIEN
suffix:colon
l_int|1
suffix:semicolon
r_int
id|bit0
suffix:colon
l_int|1
suffix:semicolon
macro_line|#else
macro_line|#error &quot;Please fix &lt;asm/byteorder.h&gt;&quot;
macro_line|#endif
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|ata_control_t
)brace
id|ata_control_t
suffix:semicolon
multiline_comment|/*&n; * ATAPI Feature Register&n; *&n; * dma&t;&t;: Using DMA or PIO&n; * reserved321&t;: Reserved&n; * reserved654&t;: Reserved (Tag Type)&n; * reserved7&t;: Reserved&n; */
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|8
suffix:semicolon
r_struct
(brace
macro_line|#if defined(__LITTLE_ENDIAN_BITFIELD)
DECL|member|dma
r_int
id|dma
suffix:colon
l_int|1
suffix:semicolon
DECL|member|reserved321
r_int
id|reserved321
suffix:colon
l_int|3
suffix:semicolon
DECL|member|reserved654
r_int
id|reserved654
suffix:colon
l_int|3
suffix:semicolon
DECL|member|reserved7
r_int
id|reserved7
suffix:colon
l_int|1
suffix:semicolon
macro_line|#elif defined(__BIG_ENDIAN_BITFIELD)
r_int
id|reserved7
suffix:colon
l_int|1
suffix:semicolon
r_int
id|reserved654
suffix:colon
l_int|3
suffix:semicolon
r_int
id|reserved321
suffix:colon
l_int|3
suffix:semicolon
r_int
id|dma
suffix:colon
l_int|1
suffix:semicolon
macro_line|#else
macro_line|#error &quot;Please fix &lt;asm/byteorder.h&gt;&quot;
macro_line|#endif
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|atapi_feature_t
)brace
id|atapi_feature_t
suffix:semicolon
multiline_comment|/*&n; * ATAPI Interrupt Reason Register.&n; *&n; * cod&t;&t;: Information transferred is command (1) or data (0)&n; * io&t;&t;: The device requests us to read (1) or write (0)&n; * reserved&t;: Reserved&n; */
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|8
suffix:semicolon
r_struct
(brace
macro_line|#if defined(__LITTLE_ENDIAN_BITFIELD)
DECL|member|cod
r_int
id|cod
suffix:colon
l_int|1
suffix:semicolon
DECL|member|io
r_int
id|io
suffix:colon
l_int|1
suffix:semicolon
DECL|member|reserved
r_int
id|reserved
suffix:colon
l_int|6
suffix:semicolon
macro_line|#elif defined(__BIG_ENDIAN_BITFIELD)
r_int
id|reserved
suffix:colon
l_int|6
suffix:semicolon
r_int
id|io
suffix:colon
l_int|1
suffix:semicolon
r_int
id|cod
suffix:colon
l_int|1
suffix:semicolon
macro_line|#else
macro_line|#error &quot;Please fix &lt;asm/byteorder.h&gt;&quot;
macro_line|#endif
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|atapi_ireason_t
)brace
id|atapi_ireason_t
suffix:semicolon
multiline_comment|/*&n; * The ATAPI error register.&n; *&n; * ili&t;&t;: Illegal Length Indication&n; * eom&t;&t;: End Of Media Detected&n; * abrt&t;&t;: Aborted command - As defined by ATA&n; * mcr&t;&t;: Media Change Requested - As defined by ATA&n; * sense_key&t;: Sense key of the last failed packet command&n; */
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|8
suffix:semicolon
r_struct
(brace
macro_line|#if defined(__LITTLE_ENDIAN_BITFIELD)
DECL|member|ili
r_int
id|ili
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eom
r_int
id|eom
suffix:colon
l_int|1
suffix:semicolon
DECL|member|abrt
r_int
id|abrt
suffix:colon
l_int|1
suffix:semicolon
DECL|member|mcr
r_int
id|mcr
suffix:colon
l_int|1
suffix:semicolon
DECL|member|sense_key
r_int
id|sense_key
suffix:colon
l_int|4
suffix:semicolon
macro_line|#elif defined(__BIG_ENDIAN_BITFIELD)
r_int
id|sense_key
suffix:colon
l_int|4
suffix:semicolon
r_int
id|mcr
suffix:colon
l_int|1
suffix:semicolon
r_int
id|abrt
suffix:colon
l_int|1
suffix:semicolon
r_int
id|eom
suffix:colon
l_int|1
suffix:semicolon
r_int
id|ili
suffix:colon
l_int|1
suffix:semicolon
macro_line|#else
macro_line|#error &quot;Please fix &lt;asm/byteorder.h&gt;&quot;
macro_line|#endif
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|atapi_error_t
)brace
id|atapi_error_t
suffix:semicolon
multiline_comment|/*&n; * ATAPI floppy Drive Select Register&n; *&n; * sam_lun&t;: Logical unit number&n; * reserved3&t;: Reserved&n; * drv&t;&t;: The responding drive will be drive 0 (0) or drive 1 (1)&n; * one5&t;&t;: Should be set to 1&n; * reserved6&t;: Reserved&n; * one7&t;&t;: Should be set to 1&n; */
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|8
suffix:semicolon
r_struct
(brace
macro_line|#if defined(__LITTLE_ENDIAN_BITFIELD)
DECL|member|sam_lun
r_int
id|sam_lun
suffix:colon
l_int|3
suffix:semicolon
DECL|member|reserved3
r_int
id|reserved3
suffix:colon
l_int|1
suffix:semicolon
DECL|member|drv
r_int
id|drv
suffix:colon
l_int|1
suffix:semicolon
DECL|member|one5
r_int
id|one5
suffix:colon
l_int|1
suffix:semicolon
DECL|member|reserved6
r_int
id|reserved6
suffix:colon
l_int|1
suffix:semicolon
DECL|member|one7
r_int
id|one7
suffix:colon
l_int|1
suffix:semicolon
macro_line|#elif defined(__BIG_ENDIAN_BITFIELD)
r_int
id|one7
suffix:colon
l_int|1
suffix:semicolon
r_int
id|reserved6
suffix:colon
l_int|1
suffix:semicolon
r_int
id|one5
suffix:colon
l_int|1
suffix:semicolon
r_int
id|drv
suffix:colon
l_int|1
suffix:semicolon
r_int
id|reserved3
suffix:colon
l_int|1
suffix:semicolon
r_int
id|sam_lun
suffix:colon
l_int|3
suffix:semicolon
macro_line|#else
macro_line|#error &quot;Please fix &lt;asm/byteorder.h&gt;&quot;
macro_line|#endif
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|atapi_select_t
)brace
id|atapi_select_t
suffix:semicolon
multiline_comment|/*&n; * Status returned from various ide_ functions&n; */
r_typedef
r_enum
(brace
DECL|enumerator|ide_stopped
id|ide_stopped
comma
multiline_comment|/* no drive operation was started */
DECL|enumerator|ide_started
id|ide_started
comma
multiline_comment|/* a drive operation was started, handler was set */
DECL|typedef|ide_startstop_t
)brace
id|ide_startstop_t
suffix:semicolon
r_struct
id|ide_driver_s
suffix:semicolon
r_struct
id|ide_settings_s
suffix:semicolon
DECL|struct|ide_drive_s
r_typedef
r_struct
id|ide_drive_s
(brace
DECL|member|name
r_char
id|name
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* drive name, such as &quot;hda&quot; */
DECL|member|driver_req
r_char
id|driver_req
(braket
l_int|10
)braket
suffix:semicolon
multiline_comment|/* requests specific driver */
DECL|member|queue
id|request_queue_t
op_star
id|queue
suffix:semicolon
multiline_comment|/* request queue */
DECL|member|rq
r_struct
id|request
op_star
id|rq
suffix:semicolon
multiline_comment|/* current request */
DECL|member|next
r_struct
id|ide_drive_s
op_star
id|next
suffix:semicolon
multiline_comment|/* circular list of hwgroup drives */
DECL|member|driver
r_struct
id|ide_driver_s
op_star
id|driver
suffix:semicolon
multiline_comment|/* (ide_driver_t *) */
DECL|member|driver_data
r_void
op_star
id|driver_data
suffix:semicolon
multiline_comment|/* extra driver data */
DECL|member|id
r_struct
id|hd_driveid
op_star
id|id
suffix:semicolon
multiline_comment|/* drive model identification info */
DECL|member|proc
r_struct
id|proc_dir_entry
op_star
id|proc
suffix:semicolon
multiline_comment|/* /proc/ide/ directory entry */
DECL|member|settings
r_struct
id|ide_settings_s
op_star
id|settings
suffix:semicolon
multiline_comment|/* /proc/ide/ drive settings */
DECL|member|devfs_name
r_char
id|devfs_name
(braket
l_int|64
)braket
suffix:semicolon
multiline_comment|/* devfs crap */
DECL|member|hwif
r_struct
id|hwif_s
op_star
id|hwif
suffix:semicolon
multiline_comment|/* actually (ide_hwif_t *) */
DECL|member|sleep
r_int
r_int
id|sleep
suffix:semicolon
multiline_comment|/* sleep until this time */
DECL|member|service_start
r_int
r_int
id|service_start
suffix:semicolon
multiline_comment|/* time we started last request */
DECL|member|service_time
r_int
r_int
id|service_time
suffix:semicolon
multiline_comment|/* service time of last request */
DECL|member|timeout
r_int
r_int
id|timeout
suffix:semicolon
multiline_comment|/* max time to wait for irq */
DECL|member|special
id|special_t
id|special
suffix:semicolon
multiline_comment|/* special action flags */
DECL|member|select
id|select_t
id|select
suffix:semicolon
multiline_comment|/* basic drive/head select reg value */
DECL|member|keep_settings
id|u8
id|keep_settings
suffix:semicolon
multiline_comment|/* restore settings after drive reset */
DECL|member|autodma
id|u8
id|autodma
suffix:semicolon
multiline_comment|/* device can safely use dma on host */
DECL|member|using_dma
id|u8
id|using_dma
suffix:semicolon
multiline_comment|/* disk is using dma for read/write */
DECL|member|retry_pio
id|u8
id|retry_pio
suffix:semicolon
multiline_comment|/* retrying dma capable host in pio */
DECL|member|state
id|u8
id|state
suffix:semicolon
multiline_comment|/* retry state */
DECL|member|waiting_for_dma
id|u8
id|waiting_for_dma
suffix:semicolon
multiline_comment|/* dma currently in progress */
DECL|member|unmask
id|u8
id|unmask
suffix:semicolon
multiline_comment|/* okay to unmask other irqs */
DECL|member|bswap
id|u8
id|bswap
suffix:semicolon
multiline_comment|/* byte swap data */
DECL|member|dsc_overlap
id|u8
id|dsc_overlap
suffix:semicolon
multiline_comment|/* DSC overlap */
DECL|member|nice1
id|u8
id|nice1
suffix:semicolon
multiline_comment|/* give potential excess bandwidth */
DECL|member|present
r_int
id|present
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* drive is physically present */
DECL|member|dead
r_int
id|dead
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* device ejected hint */
DECL|member|id_read
r_int
id|id_read
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 1=id read from disk 0 = synthetic */
DECL|member|noprobe
r_int
id|noprobe
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* from:  hdx=noprobe */
DECL|member|removable
r_int
id|removable
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 1 if need to do check_media_change */
DECL|member|attach
r_int
id|attach
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* needed for removable devices */
DECL|member|is_flash
r_int
id|is_flash
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 1 if probed as flash */
DECL|member|forced_geom
r_int
id|forced_geom
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 1 if hdx=c,h,s was given at boot */
DECL|member|no_unmask
r_int
id|no_unmask
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* disallow setting unmask bit */
DECL|member|no_io_32bit
r_int
id|no_io_32bit
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* disallow enabling 32bit I/O */
DECL|member|atapi_overlap
r_int
id|atapi_overlap
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* ATAPI overlap (not supported) */
DECL|member|nice0
r_int
id|nice0
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* give obvious excess bandwidth */
DECL|member|nice2
r_int
id|nice2
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* give a share in our own bandwidth */
DECL|member|doorlocking
r_int
id|doorlocking
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* for removable only: door lock/unlock works */
DECL|member|autotune
r_int
id|autotune
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* 0=default, 1=autotune, 2=noautotune */
DECL|member|remap_0_to_1
r_int
id|remap_0_to_1
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 0=noremap, 1=remap 0-&gt;1 (for EZDrive) */
DECL|member|blocked
r_int
id|blocked
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 1=powermanagment told us not to do anything, so sleep nicely */
DECL|member|vdma
r_int
id|vdma
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 1=doing PIO over DMA 0=doing normal DMA */
DECL|member|addressing
r_int
id|addressing
suffix:semicolon
multiline_comment|/*      : 3;&n;&t;&t;&t;&t;&t; *  0=28-bit&n;&t;&t;&t;&t;&t; *  1=48-bit&n;&t;&t;&t;&t;&t; *  2=48-bit doing 28-bit&n;&t;&t;&t;&t;&t; *  3=64-bit&n;&t;&t;&t;&t;&t; */
DECL|member|scsi
r_int
id|scsi
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 0=default, 1=ide-scsi emulation */
DECL|member|quirk_list
id|u8
id|quirk_list
suffix:semicolon
multiline_comment|/* considered quirky, set for a specific host */
DECL|member|init_speed
id|u8
id|init_speed
suffix:semicolon
multiline_comment|/* transfer rate set at boot */
DECL|member|pio_speed
id|u8
id|pio_speed
suffix:semicolon
multiline_comment|/* unused by core, used by some drivers for fallback from DMA */
DECL|member|current_speed
id|u8
id|current_speed
suffix:semicolon
multiline_comment|/* current transfer rate set */
DECL|member|dn
id|u8
id|dn
suffix:semicolon
multiline_comment|/* now wide spread use */
DECL|member|wcache
id|u8
id|wcache
suffix:semicolon
multiline_comment|/* status of write cache */
DECL|member|acoustic
id|u8
id|acoustic
suffix:semicolon
multiline_comment|/* acoustic management */
DECL|member|media
id|u8
id|media
suffix:semicolon
multiline_comment|/* disk, cdrom, tape, floppy, ... */
DECL|member|ctl
id|u8
id|ctl
suffix:semicolon
multiline_comment|/* &quot;normal&quot; value for IDE_CONTROL_REG */
DECL|member|ready_stat
id|u8
id|ready_stat
suffix:semicolon
multiline_comment|/* min status value for drive ready */
DECL|member|mult_count
id|u8
id|mult_count
suffix:semicolon
multiline_comment|/* current multiple sector setting */
DECL|member|mult_req
id|u8
id|mult_req
suffix:semicolon
multiline_comment|/* requested multiple sector setting */
DECL|member|tune_req
id|u8
id|tune_req
suffix:semicolon
multiline_comment|/* requested drive tuning setting */
DECL|member|io_32bit
id|u8
id|io_32bit
suffix:semicolon
multiline_comment|/* 0=16-bit, 1=32-bit, 2/3=32bit+sync */
DECL|member|bad_wstat
id|u8
id|bad_wstat
suffix:semicolon
multiline_comment|/* used for ignoring WRERR_STAT */
DECL|member|nowerr
id|u8
id|nowerr
suffix:semicolon
multiline_comment|/* used for ignoring WRERR_STAT */
DECL|member|sect0
id|u8
id|sect0
suffix:semicolon
multiline_comment|/* offset of first sector for DM6:DDO */
DECL|member|head
id|u8
id|head
suffix:semicolon
multiline_comment|/* &quot;real&quot; number of heads */
DECL|member|sect
id|u8
id|sect
suffix:semicolon
multiline_comment|/* &quot;real&quot; sectors per track */
DECL|member|bios_head
id|u8
id|bios_head
suffix:semicolon
multiline_comment|/* BIOS/fdisk/LILO number of heads */
DECL|member|bios_sect
id|u8
id|bios_sect
suffix:semicolon
multiline_comment|/* BIOS/fdisk/LILO sectors per track */
DECL|member|doing_barrier
id|u8
id|doing_barrier
suffix:semicolon
multiline_comment|/* state, 1=currently doing flush */
DECL|member|bios_cyl
r_int
r_int
id|bios_cyl
suffix:semicolon
multiline_comment|/* BIOS/fdisk/LILO number of cyls */
DECL|member|cyl
r_int
r_int
id|cyl
suffix:semicolon
multiline_comment|/* &quot;real&quot; number of cyls */
DECL|member|drive_data
r_int
r_int
id|drive_data
suffix:semicolon
multiline_comment|/* use by tuneproc/selectproc */
DECL|member|usage
r_int
r_int
id|usage
suffix:semicolon
multiline_comment|/* current &quot;open()&quot; count for drive */
DECL|member|failures
r_int
r_int
id|failures
suffix:semicolon
multiline_comment|/* current failure count */
DECL|member|max_failures
r_int
r_int
id|max_failures
suffix:semicolon
multiline_comment|/* maximum allowed failure count */
DECL|member|capacity64
id|u64
id|capacity64
suffix:semicolon
multiline_comment|/* total number of sectors */
DECL|member|lun
r_int
id|lun
suffix:semicolon
multiline_comment|/* logical unit */
DECL|member|crc_count
r_int
id|crc_count
suffix:semicolon
multiline_comment|/* crc counter to reduce drive speed */
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|gendev
r_struct
id|device
id|gendev
suffix:semicolon
DECL|member|gendev_rel_sem
r_struct
id|semaphore
id|gendev_rel_sem
suffix:semicolon
multiline_comment|/* to deal with device release() */
DECL|member|disk
r_struct
id|gendisk
op_star
id|disk
suffix:semicolon
DECL|typedef|ide_drive_t
)brace
id|ide_drive_t
suffix:semicolon
DECL|macro|IDE_CHIPSET_PCI_MASK
mdefine_line|#define IDE_CHIPSET_PCI_MASK&t;&bslash;&n;    ((1&lt;&lt;ide_pci)|(1&lt;&lt;ide_cmd646)|(1&lt;&lt;ide_ali14xx))
DECL|macro|IDE_CHIPSET_IS_PCI
mdefine_line|#define IDE_CHIPSET_IS_PCI(c)&t;((IDE_CHIPSET_PCI_MASK &gt;&gt; (c)) &amp; 1)
r_struct
id|ide_pci_device_s
suffix:semicolon
DECL|struct|hwif_s
r_typedef
r_struct
id|hwif_s
(brace
DECL|member|next
r_struct
id|hwif_s
op_star
id|next
suffix:semicolon
multiline_comment|/* for linked-list in ide_hwgroup_t */
DECL|member|mate
r_struct
id|hwif_s
op_star
id|mate
suffix:semicolon
multiline_comment|/* other hwif from same PCI chip */
DECL|member|hwgroup
r_struct
id|hwgroup_s
op_star
id|hwgroup
suffix:semicolon
multiline_comment|/* actually (ide_hwgroup_t *) */
DECL|member|proc
r_struct
id|proc_dir_entry
op_star
id|proc
suffix:semicolon
multiline_comment|/* /proc/ide/ directory entry */
DECL|member|name
r_char
id|name
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/* name of interface, eg. &quot;ide0&quot; */
multiline_comment|/* task file registers for pata and sata */
DECL|member|io_ports
r_int
r_int
id|io_ports
(braket
id|IDE_NR_PORTS
)braket
suffix:semicolon
DECL|member|sata_scr
r_int
r_int
id|sata_scr
(braket
id|SATA_NR_PORTS
)braket
suffix:semicolon
DECL|member|sata_misc
r_int
r_int
id|sata_misc
(braket
id|SATA_NR_PORTS
)braket
suffix:semicolon
DECL|member|hw
id|hw_regs_t
id|hw
suffix:semicolon
multiline_comment|/* Hardware info */
DECL|member|drives
id|ide_drive_t
id|drives
(braket
id|MAX_DRIVES
)braket
suffix:semicolon
multiline_comment|/* drive info */
DECL|member|major
id|u8
id|major
suffix:semicolon
multiline_comment|/* our major number */
DECL|member|index
id|u8
id|index
suffix:semicolon
multiline_comment|/* 0 for ide0; 1 for ide1; ... */
DECL|member|channel
id|u8
id|channel
suffix:semicolon
multiline_comment|/* for dual-port chips: 0=primary, 1=secondary */
DECL|member|straight8
id|u8
id|straight8
suffix:semicolon
multiline_comment|/* Alan&squot;s straight 8 check */
DECL|member|bus_state
id|u8
id|bus_state
suffix:semicolon
multiline_comment|/* power state of the IDE bus */
DECL|member|atapi_dma
id|u8
id|atapi_dma
suffix:semicolon
multiline_comment|/* host supports atapi_dma */
DECL|member|ultra_mask
id|u8
id|ultra_mask
suffix:semicolon
DECL|member|mwdma_mask
id|u8
id|mwdma_mask
suffix:semicolon
DECL|member|swdma_mask
id|u8
id|swdma_mask
suffix:semicolon
DECL|member|chipset
id|hwif_chipset_t
id|chipset
suffix:semicolon
multiline_comment|/* sub-module for tuning.. */
DECL|member|pci_dev
r_struct
id|pci_dev
op_star
id|pci_dev
suffix:semicolon
multiline_comment|/* for pci chipsets */
DECL|member|cds
r_struct
id|ide_pci_device_s
op_star
id|cds
suffix:semicolon
multiline_comment|/* chipset device struct */
DECL|member|rw_disk
id|ide_startstop_t
(paren
op_star
id|rw_disk
)paren
(paren
id|ide_drive_t
op_star
comma
r_struct
id|request
op_star
comma
id|sector_t
)paren
suffix:semicolon
macro_line|#if 0
id|ide_hwif_ops_t
op_star
id|hwifops
suffix:semicolon
macro_line|#else
multiline_comment|/* routine to tune PIO mode for drives */
DECL|member|tuneproc
r_void
(paren
op_star
id|tuneproc
)paren
(paren
id|ide_drive_t
op_star
comma
id|u8
)paren
suffix:semicolon
multiline_comment|/* routine to retune DMA modes for drives */
DECL|member|speedproc
r_int
(paren
op_star
id|speedproc
)paren
(paren
id|ide_drive_t
op_star
comma
id|u8
)paren
suffix:semicolon
multiline_comment|/* tweaks hardware to select drive */
DECL|member|selectproc
r_void
(paren
op_star
id|selectproc
)paren
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
multiline_comment|/* chipset polling based on hba specifics */
DECL|member|reset_poll
r_int
(paren
op_star
id|reset_poll
)paren
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
multiline_comment|/* chipset specific changes to default for device-hba resets */
DECL|member|pre_reset
r_void
(paren
op_star
id|pre_reset
)paren
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
multiline_comment|/* routine to reset controller after a disk reset */
DECL|member|resetproc
r_void
(paren
op_star
id|resetproc
)paren
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
multiline_comment|/* special interrupt handling for shared pci interrupts */
DECL|member|intrproc
r_void
(paren
op_star
id|intrproc
)paren
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
multiline_comment|/* special host masking for drive selection */
DECL|member|maskproc
r_void
(paren
op_star
id|maskproc
)paren
(paren
id|ide_drive_t
op_star
comma
r_int
)paren
suffix:semicolon
multiline_comment|/* check host&squot;s drive quirk list */
DECL|member|quirkproc
r_int
(paren
op_star
id|quirkproc
)paren
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
multiline_comment|/* driver soft-power interface */
DECL|member|busproc
r_int
(paren
op_star
id|busproc
)paren
(paren
id|ide_drive_t
op_star
comma
r_int
)paren
suffix:semicolon
singleline_comment|//&t;/* host rate limiter */
singleline_comment|//&t;u8&t;(*ratemask)(ide_drive_t *);
singleline_comment|//&t;/* device rate limiter */
singleline_comment|//&t;u8&t;(*ratefilter)(ide_drive_t *, u8);
macro_line|#endif
DECL|member|ata_input_data
r_void
(paren
op_star
id|ata_input_data
)paren
(paren
id|ide_drive_t
op_star
comma
r_void
op_star
comma
id|u32
)paren
suffix:semicolon
DECL|member|ata_output_data
r_void
(paren
op_star
id|ata_output_data
)paren
(paren
id|ide_drive_t
op_star
comma
r_void
op_star
comma
id|u32
)paren
suffix:semicolon
DECL|member|atapi_input_bytes
r_void
(paren
op_star
id|atapi_input_bytes
)paren
(paren
id|ide_drive_t
op_star
comma
r_void
op_star
comma
id|u32
)paren
suffix:semicolon
DECL|member|atapi_output_bytes
r_void
(paren
op_star
id|atapi_output_bytes
)paren
(paren
id|ide_drive_t
op_star
comma
r_void
op_star
comma
id|u32
)paren
suffix:semicolon
DECL|member|dma_setup
r_int
(paren
op_star
id|dma_setup
)paren
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
DECL|member|dma_exec_cmd
r_void
(paren
op_star
id|dma_exec_cmd
)paren
(paren
id|ide_drive_t
op_star
comma
id|u8
)paren
suffix:semicolon
DECL|member|dma_start
r_void
(paren
op_star
id|dma_start
)paren
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
DECL|member|ide_dma_end
r_int
(paren
op_star
id|ide_dma_end
)paren
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
DECL|member|ide_dma_check
r_int
(paren
op_star
id|ide_dma_check
)paren
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
DECL|member|ide_dma_on
r_int
(paren
op_star
id|ide_dma_on
)paren
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
DECL|member|ide_dma_off_quietly
r_int
(paren
op_star
id|ide_dma_off_quietly
)paren
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
DECL|member|ide_dma_test_irq
r_int
(paren
op_star
id|ide_dma_test_irq
)paren
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
DECL|member|ide_dma_host_on
r_int
(paren
op_star
id|ide_dma_host_on
)paren
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
DECL|member|ide_dma_host_off
r_int
(paren
op_star
id|ide_dma_host_off
)paren
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
DECL|member|ide_dma_lostirq
r_int
(paren
op_star
id|ide_dma_lostirq
)paren
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
DECL|member|ide_dma_timeout
r_int
(paren
op_star
id|ide_dma_timeout
)paren
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
DECL|member|OUTB
r_void
(paren
op_star
id|OUTB
)paren
(paren
id|u8
id|addr
comma
r_int
r_int
id|port
)paren
suffix:semicolon
DECL|member|OUTBSYNC
r_void
(paren
op_star
id|OUTBSYNC
)paren
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
id|addr
comma
r_int
r_int
id|port
)paren
suffix:semicolon
DECL|member|OUTW
r_void
(paren
op_star
id|OUTW
)paren
(paren
id|u16
id|addr
comma
r_int
r_int
id|port
)paren
suffix:semicolon
DECL|member|OUTL
r_void
(paren
op_star
id|OUTL
)paren
(paren
id|u32
id|addr
comma
r_int
r_int
id|port
)paren
suffix:semicolon
DECL|member|OUTSW
r_void
(paren
op_star
id|OUTSW
)paren
(paren
r_int
r_int
id|port
comma
r_void
op_star
id|addr
comma
id|u32
id|count
)paren
suffix:semicolon
DECL|member|OUTSL
r_void
(paren
op_star
id|OUTSL
)paren
(paren
r_int
r_int
id|port
comma
r_void
op_star
id|addr
comma
id|u32
id|count
)paren
suffix:semicolon
DECL|member|INB
id|u8
(paren
op_star
id|INB
)paren
(paren
r_int
r_int
id|port
)paren
suffix:semicolon
DECL|member|INW
id|u16
(paren
op_star
id|INW
)paren
(paren
r_int
r_int
id|port
)paren
suffix:semicolon
DECL|member|INL
id|u32
(paren
op_star
id|INL
)paren
(paren
r_int
r_int
id|port
)paren
suffix:semicolon
DECL|member|INSW
r_void
(paren
op_star
id|INSW
)paren
(paren
r_int
r_int
id|port
comma
r_void
op_star
id|addr
comma
id|u32
id|count
)paren
suffix:semicolon
DECL|member|INSL
r_void
(paren
op_star
id|INSL
)paren
(paren
r_int
r_int
id|port
comma
r_void
op_star
id|addr
comma
id|u32
id|count
)paren
suffix:semicolon
multiline_comment|/* dma physical region descriptor table (cpu view) */
DECL|member|dmatable_cpu
r_int
r_int
op_star
id|dmatable_cpu
suffix:semicolon
multiline_comment|/* dma physical region descriptor table (dma view) */
DECL|member|dmatable_dma
id|dma_addr_t
id|dmatable_dma
suffix:semicolon
multiline_comment|/* Scatter-gather list used to build the above */
DECL|member|sg_table
r_struct
id|scatterlist
op_star
id|sg_table
suffix:semicolon
DECL|member|sg_max_nents
r_int
id|sg_max_nents
suffix:semicolon
multiline_comment|/* Maximum number of entries in it */
DECL|member|sg_nents
r_int
id|sg_nents
suffix:semicolon
multiline_comment|/* Current number of entries in it */
DECL|member|sg_dma_direction
r_int
id|sg_dma_direction
suffix:semicolon
multiline_comment|/* dma transfer direction */
multiline_comment|/* data phase of the active command (currently only valid for PIO/DMA) */
DECL|member|data_phase
r_int
id|data_phase
suffix:semicolon
DECL|member|nsect
r_int
r_int
id|nsect
suffix:semicolon
DECL|member|nleft
r_int
r_int
id|nleft
suffix:semicolon
DECL|member|cursg
r_int
r_int
id|cursg
suffix:semicolon
DECL|member|cursg_ofs
r_int
r_int
id|cursg_ofs
suffix:semicolon
DECL|member|mmio
r_int
id|mmio
suffix:semicolon
multiline_comment|/* hosts iomio (0) or custom (2) select */
DECL|member|rqsize
r_int
id|rqsize
suffix:semicolon
multiline_comment|/* max sectors per request */
DECL|member|irq
r_int
id|irq
suffix:semicolon
multiline_comment|/* our irq number */
DECL|member|dma_master
r_int
r_int
id|dma_master
suffix:semicolon
multiline_comment|/* reference base addr dmabase */
DECL|member|dma_base
r_int
r_int
id|dma_base
suffix:semicolon
multiline_comment|/* base addr for dma ports */
DECL|member|dma_command
r_int
r_int
id|dma_command
suffix:semicolon
multiline_comment|/* dma command register */
DECL|member|dma_vendor1
r_int
r_int
id|dma_vendor1
suffix:semicolon
multiline_comment|/* dma vendor 1 register */
DECL|member|dma_status
r_int
r_int
id|dma_status
suffix:semicolon
multiline_comment|/* dma status register */
DECL|member|dma_vendor3
r_int
r_int
id|dma_vendor3
suffix:semicolon
multiline_comment|/* dma vendor 3 register */
DECL|member|dma_prdtable
r_int
r_int
id|dma_prdtable
suffix:semicolon
multiline_comment|/* actual prd table address */
DECL|member|dma_base2
r_int
r_int
id|dma_base2
suffix:semicolon
multiline_comment|/* extended base addr for dma ports */
DECL|member|dma_extra
r_int
id|dma_extra
suffix:semicolon
multiline_comment|/* extra addr for dma ports */
DECL|member|config_data
r_int
r_int
id|config_data
suffix:semicolon
multiline_comment|/* for use by chipset-specific code */
DECL|member|select_data
r_int
r_int
id|select_data
suffix:semicolon
multiline_comment|/* for use by chipset-specific code */
DECL|member|noprobe
r_int
id|noprobe
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* don&squot;t probe for this interface */
DECL|member|present
r_int
id|present
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* this interface exists */
DECL|member|hold
r_int
id|hold
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* this interface is always present */
DECL|member|serialized
r_int
id|serialized
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* serialized all channel operation */
DECL|member|sharing_irq
r_int
id|sharing_irq
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 1 = sharing irq with another hwif */
DECL|member|reset
r_int
id|reset
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* reset after probe */
DECL|member|autodma
r_int
id|autodma
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* auto-attempt using DMA at boot */
DECL|member|udma_four
r_int
id|udma_four
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 1=ATA-66 capable, 0=default */
DECL|member|no_lba48
r_int
id|no_lba48
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 1 = cannot do LBA48 */
DECL|member|no_lba48_dma
r_int
id|no_lba48_dma
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 1 = cannot do LBA48 DMA */
DECL|member|no_dsc
r_int
id|no_dsc
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 0 default, 1 dsc_overlap disabled */
DECL|member|auto_poll
r_int
id|auto_poll
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* supports nop auto-poll */
DECL|member|sg_mapped
r_int
id|sg_mapped
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* sg_table and sg_nents are ready */
DECL|member|gendev
r_struct
id|device
id|gendev
suffix:semicolon
DECL|member|gendev_rel_sem
r_struct
id|semaphore
id|gendev_rel_sem
suffix:semicolon
multiline_comment|/* To deal with device release() */
DECL|member|hwif_data
r_void
op_star
id|hwif_data
suffix:semicolon
multiline_comment|/* extra hwif data */
DECL|member|dma
r_int
id|dma
suffix:semicolon
DECL|member|led_act
r_void
(paren
op_star
id|led_act
)paren
(paren
r_void
op_star
id|data
comma
r_int
id|rw
)paren
suffix:semicolon
DECL|typedef|ide_hwif_t
)brace
id|ide_hwif_t
suffix:semicolon
multiline_comment|/*&n; *  internal ide interrupt handler type&n; */
DECL|typedef|ide_pre_handler_t
r_typedef
id|ide_startstop_t
(paren
id|ide_pre_handler_t
)paren
(paren
id|ide_drive_t
op_star
comma
r_struct
id|request
op_star
)paren
suffix:semicolon
DECL|typedef|ide_handler_t
r_typedef
id|ide_startstop_t
(paren
id|ide_handler_t
)paren
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
DECL|typedef|ide_expiry_t
r_typedef
r_int
(paren
id|ide_expiry_t
)paren
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
DECL|struct|hwgroup_s
r_typedef
r_struct
id|hwgroup_s
(brace
multiline_comment|/* irq handler, if active */
DECL|member|handler
id|ide_startstop_t
(paren
op_star
id|handler
)paren
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
multiline_comment|/* irq handler, suspended if active */
DECL|member|handler_save
id|ide_startstop_t
(paren
op_star
id|handler_save
)paren
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
multiline_comment|/* BOOL: protects all fields below */
DECL|member|busy
r_volatile
r_int
id|busy
suffix:semicolon
multiline_comment|/* BOOL: wake us up on timer expiry */
DECL|member|sleeping
r_int
id|sleeping
suffix:semicolon
multiline_comment|/* current drive */
DECL|member|drive
id|ide_drive_t
op_star
id|drive
suffix:semicolon
multiline_comment|/* ptr to current hwif in linked-list */
DECL|member|hwif
id|ide_hwif_t
op_star
id|hwif
suffix:semicolon
multiline_comment|/* for pci chipsets */
DECL|member|pci_dev
r_struct
id|pci_dev
op_star
id|pci_dev
suffix:semicolon
multiline_comment|/* chipset device struct */
DECL|member|cds
r_struct
id|ide_pci_device_s
op_star
id|cds
suffix:semicolon
multiline_comment|/* current request */
DECL|member|rq
r_struct
id|request
op_star
id|rq
suffix:semicolon
multiline_comment|/* failsafe timer */
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
multiline_comment|/* local copy of current write rq */
DECL|member|wrq
r_struct
id|request
id|wrq
suffix:semicolon
multiline_comment|/* timeout value during long polls */
DECL|member|poll_timeout
r_int
r_int
id|poll_timeout
suffix:semicolon
multiline_comment|/* queried upon timeouts */
DECL|member|expiry
r_int
(paren
op_star
id|expiry
)paren
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
multiline_comment|/* ide_system_bus_speed */
DECL|member|pio_clock
r_int
id|pio_clock
suffix:semicolon
DECL|member|cmd_buf
r_int
r_char
id|cmd_buf
(braket
l_int|4
)braket
suffix:semicolon
DECL|typedef|ide_hwgroup_t
)brace
id|ide_hwgroup_t
suffix:semicolon
multiline_comment|/* structure attached to the request for IDE_TASK_CMDS */
multiline_comment|/*&n; * configurable drive settings&n; */
DECL|macro|TYPE_INT
mdefine_line|#define TYPE_INT&t;0
DECL|macro|TYPE_INTA
mdefine_line|#define TYPE_INTA&t;1
DECL|macro|TYPE_BYTE
mdefine_line|#define TYPE_BYTE&t;2
DECL|macro|TYPE_SHORT
mdefine_line|#define TYPE_SHORT&t;3
DECL|macro|SETTING_READ
mdefine_line|#define SETTING_READ&t;(1 &lt;&lt; 0)
DECL|macro|SETTING_WRITE
mdefine_line|#define SETTING_WRITE&t;(1 &lt;&lt; 1)
DECL|macro|SETTING_RW
mdefine_line|#define SETTING_RW&t;(SETTING_READ | SETTING_WRITE)
DECL|typedef|ide_procset_t
r_typedef
r_int
(paren
id|ide_procset_t
)paren
(paren
id|ide_drive_t
op_star
comma
r_int
)paren
suffix:semicolon
DECL|struct|ide_settings_s
r_typedef
r_struct
id|ide_settings_s
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|rw
r_int
id|rw
suffix:semicolon
DECL|member|read_ioctl
r_int
id|read_ioctl
suffix:semicolon
DECL|member|write_ioctl
r_int
id|write_ioctl
suffix:semicolon
DECL|member|data_type
r_int
id|data_type
suffix:semicolon
DECL|member|min
r_int
id|min
suffix:semicolon
DECL|member|max
r_int
id|max
suffix:semicolon
DECL|member|mul_factor
r_int
id|mul_factor
suffix:semicolon
DECL|member|div_factor
r_int
id|div_factor
suffix:semicolon
DECL|member|data
r_void
op_star
id|data
suffix:semicolon
DECL|member|set
id|ide_procset_t
op_star
id|set
suffix:semicolon
DECL|member|auto_remove
r_int
id|auto_remove
suffix:semicolon
DECL|member|next
r_struct
id|ide_settings_s
op_star
id|next
suffix:semicolon
DECL|typedef|ide_settings_t
)brace
id|ide_settings_t
suffix:semicolon
r_extern
r_struct
id|semaphore
id|ide_setting_sem
suffix:semicolon
r_extern
r_int
id|ide_add_setting
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_const
r_char
op_star
id|name
comma
r_int
id|rw
comma
r_int
id|read_ioctl
comma
r_int
id|write_ioctl
comma
r_int
id|data_type
comma
r_int
id|min
comma
r_int
id|max
comma
r_int
id|mul_factor
comma
r_int
id|div_factor
comma
r_void
op_star
id|data
comma
id|ide_procset_t
op_star
id|set
)paren
suffix:semicolon
r_extern
id|ide_settings_t
op_star
id|ide_find_setting_by_name
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_char
op_star
id|name
)paren
suffix:semicolon
r_extern
r_int
id|ide_read_setting
c_func
(paren
id|ide_drive_t
op_star
id|t
comma
id|ide_settings_t
op_star
id|setting
)paren
suffix:semicolon
r_extern
r_int
id|ide_write_setting
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_settings_t
op_star
id|setting
comma
r_int
id|val
)paren
suffix:semicolon
r_extern
r_void
id|ide_add_generic_settings
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n; * /proc/ide interface&n; */
r_typedef
r_struct
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|mode
id|mode_t
id|mode
suffix:semicolon
DECL|member|read_proc
id|read_proc_t
op_star
id|read_proc
suffix:semicolon
DECL|member|write_proc
id|write_proc_t
op_star
id|write_proc
suffix:semicolon
DECL|typedef|ide_proc_entry_t
)brace
id|ide_proc_entry_t
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
r_extern
r_struct
id|proc_dir_entry
op_star
id|proc_ide_root
suffix:semicolon
r_extern
r_void
id|proc_ide_create
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|proc_ide_destroy
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|create_proc_ide_interfaces
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|destroy_proc_ide_interface
c_func
(paren
id|ide_hwif_t
op_star
)paren
suffix:semicolon
r_extern
r_void
id|ide_add_proc_entries
c_func
(paren
r_struct
id|proc_dir_entry
op_star
comma
id|ide_proc_entry_t
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_extern
r_void
id|ide_remove_proc_entries
c_func
(paren
r_struct
id|proc_dir_entry
op_star
comma
id|ide_proc_entry_t
op_star
)paren
suffix:semicolon
DECL|variable|proc_ide_read_capacity
id|read_proc_t
id|proc_ide_read_capacity
suffix:semicolon
DECL|variable|proc_ide_read_geometry
id|read_proc_t
id|proc_ide_read_geometry
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEPCI
r_void
id|ide_pci_create_host_proc
c_func
(paren
r_const
r_char
op_star
comma
id|get_info_t
op_star
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Standard exit stuff:&n; */
DECL|macro|PROC_IDE_READ_RETURN
mdefine_line|#define PROC_IDE_READ_RETURN(page,start,off,count,eof,len) &bslash;&n;{&t;&t;&t;&t;&t;&bslash;&n;&t;len -= off;&t;&t;&t;&bslash;&n;&t;if (len &lt; count) {&t;&t;&bslash;&n;&t;&t;*eof = 1;&t;&t;&bslash;&n;&t;&t;if (len &lt;= 0)&t;&t;&bslash;&n;&t;&t;&t;return 0;&t;&bslash;&n;&t;} else&t;&t;&t;&t;&bslash;&n;&t;&t;len = count;&t;&t;&bslash;&n;&t;*start = page + off;&t;&t;&bslash;&n;&t;return len;&t;&t;&t;&bslash;&n;}
macro_line|#else
DECL|function|create_proc_ide_interfaces
r_static
r_inline
r_void
id|create_proc_ide_interfaces
c_func
(paren
r_void
)paren
(brace
suffix:semicolon
)brace
DECL|function|destroy_proc_ide_interface
r_static
r_inline
r_void
id|destroy_proc_ide_interface
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
suffix:semicolon
)brace
DECL|macro|PROC_IDE_READ_RETURN
mdefine_line|#define PROC_IDE_READ_RETURN(page,start,off,count,eof,len) return 0;
macro_line|#endif
multiline_comment|/*&n; * Power Management step value (rq-&gt;pm-&gt;pm_step).&n; *&n; * The step value starts at 0 (ide_pm_state_start_suspend) for a&n; * suspend operation or 1000 (ide_pm_state_start_resume) for a&n; * resume operation.&n; *&n; * For each step, the core calls the subdriver start_power_step() first.&n; * This can return:&n; *&t;- ide_stopped :&t;In this case, the core calls us back again unless&n; *&t;&t;&t;step have been set to ide_power_state_completed.&n; *&t;- ide_started :&t;In this case, the channel is left busy until an&n; *&t;&t;&t;async event (interrupt) occurs.&n; * Typically, start_power_step() will issue a taskfile request with&n; * do_rw_taskfile().&n; *&n; * Upon reception of the interrupt, the core will call complete_power_step()&n; * with the error code if any. This routine should update the step value&n; * and return. It should not start a new request. The core will call&n; * start_power_step for the new step value, unless step have been set to&n; * ide_power_state_completed.&n; *&n; * Subdrivers are expected to define their own additional power&n; * steps from 1..999 for suspend and from 1001..1999 for resume,&n; * other values are reserved for future use.&n; */
r_enum
(brace
DECL|enumerator|ide_pm_state_completed
id|ide_pm_state_completed
op_assign
op_minus
l_int|1
comma
DECL|enumerator|ide_pm_state_start_suspend
id|ide_pm_state_start_suspend
op_assign
l_int|0
comma
DECL|enumerator|ide_pm_state_start_resume
id|ide_pm_state_start_resume
op_assign
l_int|1000
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Subdrivers support.&n; */
DECL|struct|ide_driver_s
r_typedef
r_struct
id|ide_driver_s
(brace
DECL|member|owner
r_struct
id|module
op_star
id|owner
suffix:semicolon
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|version
r_const
r_char
op_star
id|version
suffix:semicolon
DECL|member|media
id|u8
id|media
suffix:semicolon
DECL|member|busy
r_int
id|busy
suffix:colon
l_int|1
suffix:semicolon
DECL|member|supports_dsc_overlap
r_int
id|supports_dsc_overlap
suffix:colon
l_int|1
suffix:semicolon
DECL|member|cleanup
r_int
(paren
op_star
id|cleanup
)paren
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
DECL|member|do_request
id|ide_startstop_t
(paren
op_star
id|do_request
)paren
(paren
id|ide_drive_t
op_star
comma
r_struct
id|request
op_star
comma
id|sector_t
)paren
suffix:semicolon
DECL|member|end_request
r_int
(paren
op_star
id|end_request
)paren
(paren
id|ide_drive_t
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
DECL|member|error
id|ide_startstop_t
(paren
op_star
id|error
)paren
(paren
id|ide_drive_t
op_star
comma
r_struct
id|request
op_star
id|rq
comma
id|u8
comma
id|u8
)paren
suffix:semicolon
DECL|member|abort
id|ide_startstop_t
(paren
op_star
m_abort
)paren
(paren
id|ide_drive_t
op_star
comma
r_struct
id|request
op_star
id|rq
)paren
suffix:semicolon
DECL|member|ioctl
r_int
(paren
op_star
id|ioctl
)paren
(paren
id|ide_drive_t
op_star
comma
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
DECL|member|pre_reset
r_void
(paren
op_star
id|pre_reset
)paren
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
DECL|member|capacity
id|sector_t
(paren
op_star
id|capacity
)paren
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
DECL|member|special
id|ide_startstop_t
(paren
op_star
id|special
)paren
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
DECL|member|proc
id|ide_proc_entry_t
op_star
id|proc
suffix:semicolon
DECL|member|attach
r_int
(paren
op_star
id|attach
)paren
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
DECL|member|ata_prebuilder
r_void
(paren
op_star
id|ata_prebuilder
)paren
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
DECL|member|atapi_prebuilder
r_void
(paren
op_star
id|atapi_prebuilder
)paren
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
DECL|member|start_power_step
id|ide_startstop_t
(paren
op_star
id|start_power_step
)paren
(paren
id|ide_drive_t
op_star
comma
r_struct
id|request
op_star
)paren
suffix:semicolon
DECL|member|complete_power_step
r_void
(paren
op_star
id|complete_power_step
)paren
(paren
id|ide_drive_t
op_star
comma
r_struct
id|request
op_star
comma
id|u8
comma
id|u8
)paren
suffix:semicolon
DECL|member|gen_driver
r_struct
id|device_driver
id|gen_driver
suffix:semicolon
DECL|member|drives
r_struct
id|list_head
id|drives
suffix:semicolon
DECL|member|drivers
r_struct
id|list_head
id|drivers
suffix:semicolon
DECL|typedef|ide_driver_t
)brace
id|ide_driver_t
suffix:semicolon
DECL|macro|DRIVER
mdefine_line|#define DRIVER(drive)&t;&t;((drive)-&gt;driver)
r_extern
r_int
id|generic_ide_ioctl
c_func
(paren
r_struct
id|file
op_star
comma
r_struct
id|block_device
op_star
comma
r_int
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * ide_hwifs[] is the master data structure used to keep track&n; * of just about everything in ide.c.  Whenever possible, routines&n; * should be using pointers to a drive (ide_drive_t *) or&n; * pointers to a hwif (ide_hwif_t *), rather than indexing this&n; * structure directly (the allocation/layout may change!).&n; *&n; */
macro_line|#ifndef _IDE_C
r_extern
id|ide_hwif_t
id|ide_hwifs
(braket
)braket
suffix:semicolon
multiline_comment|/* master data repository */
macro_line|#endif
r_extern
r_int
id|noautodma
suffix:semicolon
r_extern
r_int
id|ide_end_request
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|uptodate
comma
r_int
id|nrsecs
)paren
suffix:semicolon
multiline_comment|/*&n; * This is used on exit from the driver to designate the next irq handler&n; * and also to start the safety timer.&n; */
r_extern
r_void
id|ide_set_handler
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_handler_t
op_star
id|handler
comma
r_int
r_int
id|timeout
comma
id|ide_expiry_t
op_star
id|expiry
)paren
suffix:semicolon
multiline_comment|/*&n; * This is used on exit from the driver to designate the next irq handler&n; * and start the safety time safely and atomically from the IRQ handler&n; * with respect to the command issue (which it also does)&n; */
r_extern
r_void
id|ide_execute_command
c_func
(paren
id|ide_drive_t
op_star
comma
id|task_ioreg_t
id|cmd
comma
id|ide_handler_t
op_star
comma
r_int
r_int
comma
id|ide_expiry_t
op_star
)paren
suffix:semicolon
id|ide_startstop_t
id|__ide_error
c_func
(paren
id|ide_drive_t
op_star
comma
r_struct
id|request
op_star
comma
id|u8
comma
id|u8
)paren
suffix:semicolon
multiline_comment|/*&n; * ide_error() takes action based on the error returned by the controller.&n; * The caller should return immediately after invoking this.&n; *&n; * (drive, msg, status)&n; */
id|ide_startstop_t
id|ide_error
(paren
id|ide_drive_t
op_star
id|drive
comma
r_const
r_char
op_star
id|msg
comma
id|byte
id|stat
)paren
suffix:semicolon
id|ide_startstop_t
id|__ide_abort
c_func
(paren
id|ide_drive_t
op_star
comma
r_struct
id|request
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * Abort a running command on the controller triggering the abort&n; * from a host side, non error situation&n; * (drive, msg)&n; */
r_extern
id|ide_startstop_t
id|ide_abort
c_func
(paren
id|ide_drive_t
op_star
comma
r_const
r_char
op_star
)paren
suffix:semicolon
r_extern
r_void
id|ide_fix_driveid
c_func
(paren
r_struct
id|hd_driveid
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * ide_fixstring() cleans up and (optionally) byte-swaps a text string,&n; * removing leading/trailing blanks and compressing internal blanks.&n; * It is primarily used to tidy up the model name/number fields as&n; * returned by the WIN_[P]IDENTIFY commands.&n; *&n; * (s, bytecount, byteswap)&n; */
r_extern
r_void
id|ide_fixstring
c_func
(paren
id|u8
op_star
comma
r_const
r_int
comma
r_const
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * This routine busy-waits for the drive status to be not &quot;busy&quot;.&n; * It then checks the status for all of the &quot;good&quot; bits and none&n; * of the &quot;bad&quot; bits, and if all is okay it returns 0.  All other&n; * cases return 1 after doing &quot;*startstop = ide_error()&quot;, and the&n; * caller should return the updated value of &quot;startstop&quot; in this case.&n; * &quot;startstop&quot; is unchanged when the function returns 0;&n; * (startstop, drive, good, bad, timeout)&n; */
r_extern
r_int
id|ide_wait_stat
c_func
(paren
id|ide_startstop_t
op_star
comma
id|ide_drive_t
op_star
comma
id|u8
comma
id|u8
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * Start a reset operation for an IDE interface.&n; * The caller should return immediately after invoking this.&n; */
r_extern
id|ide_startstop_t
id|ide_do_reset
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * This function is intended to be used prior to invoking ide_do_drive_cmd().&n; */
r_extern
r_void
id|ide_init_drive_cmd
(paren
r_struct
id|request
op_star
id|rq
)paren
suffix:semicolon
multiline_comment|/*&n; * this function returns error location sector offset in case of a write error&n; */
r_extern
id|u64
id|ide_get_error_location
c_func
(paren
id|ide_drive_t
op_star
comma
r_char
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * &quot;action&quot; parameter type for ide_do_drive_cmd() below.&n; */
r_typedef
r_enum
(brace
DECL|enumerator|ide_wait
id|ide_wait
comma
multiline_comment|/* insert rq at end of list, and wait for it */
DECL|enumerator|ide_next
id|ide_next
comma
multiline_comment|/* insert rq immediately after current request */
DECL|enumerator|ide_preempt
id|ide_preempt
comma
multiline_comment|/* insert rq in front of current request */
DECL|enumerator|ide_head_wait
id|ide_head_wait
comma
multiline_comment|/* insert rq in front of current request and wait for it */
DECL|enumerator|ide_end
id|ide_end
multiline_comment|/* insert rq at end of list, but don&squot;t wait for it */
DECL|typedef|ide_action_t
)brace
id|ide_action_t
suffix:semicolon
multiline_comment|/*&n; * This function issues a special IDE device request&n; * onto the request queue.&n; *&n; * If action is ide_wait, then the rq is queued at the end of the&n; * request queue, and the function sleeps until it has been processed.&n; * This is for use when invoked from an ioctl handler.&n; *&n; * If action is ide_preempt, then the rq is queued at the head of&n; * the request queue, displacing the currently-being-processed&n; * request and this function returns immediately without waiting&n; * for the new rq to be completed.  This is VERY DANGEROUS, and is&n; * intended for careful use by the ATAPI tape/cdrom driver code.&n; *&n; * If action is ide_next, then the rq is queued immediately after&n; * the currently-being-processed-request (if any), and the function&n; * returns without waiting for the new rq to be completed.  As above,&n; * This is VERY DANGEROUS, and is intended for careful use by the&n; * ATAPI tape/cdrom driver code.&n; *&n; * If action is ide_end, then the rq is queued at the end of the&n; * request queue, and the function returns immediately without waiting&n; * for the new rq to be completed. This is again intended for careful&n; * use by the ATAPI tape/cdrom driver code.&n; */
r_extern
r_int
id|ide_do_drive_cmd
c_func
(paren
id|ide_drive_t
op_star
comma
r_struct
id|request
op_star
comma
id|ide_action_t
)paren
suffix:semicolon
multiline_comment|/*&n; * Clean up after success/failure of an explicit drive cmd.&n; * stat/err are used only when (HWGROUP(drive)-&gt;rq-&gt;cmd == IDE_DRIVE_CMD).&n; * stat/err are used only when (HWGROUP(drive)-&gt;rq-&gt;cmd == IDE_DRIVE_TASK_MASK).&n; *&n; * (ide_drive_t *drive, u8 stat, u8 err)&n; */
r_extern
r_void
id|ide_end_drive_cmd
c_func
(paren
id|ide_drive_t
op_star
comma
id|u8
comma
id|u8
)paren
suffix:semicolon
multiline_comment|/*&n; * Issue ATA command and wait for completion.&n; * Use for implementing commands in kernel&n; *&n; *  (ide_drive_t *drive, u8 cmd, u8 nsect, u8 feature, u8 sectors, u8 *buf)&n; */
r_extern
r_int
id|ide_wait_cmd
c_func
(paren
id|ide_drive_t
op_star
comma
id|u8
comma
id|u8
comma
id|u8
comma
id|u8
comma
id|u8
op_star
)paren
suffix:semicolon
DECL|struct|ide_task_s
r_typedef
r_struct
id|ide_task_s
(brace
multiline_comment|/*&n; *&t;struct hd_drive_task_hdr&t;tf;&n; *&t;task_struct_t&t;&t;tf;&n; *&t;struct hd_drive_hob_hdr&t;&t;hobf;&n; *&t;hob_struct_t&t;&t;hobf;&n; */
DECL|member|tfRegister
id|task_ioreg_t
id|tfRegister
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|hobRegister
id|task_ioreg_t
id|hobRegister
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|tf_out_flags
id|ide_reg_valid_t
id|tf_out_flags
suffix:semicolon
DECL|member|tf_in_flags
id|ide_reg_valid_t
id|tf_in_flags
suffix:semicolon
DECL|member|data_phase
r_int
id|data_phase
suffix:semicolon
DECL|member|command_type
r_int
id|command_type
suffix:semicolon
DECL|member|prehandler
id|ide_pre_handler_t
op_star
id|prehandler
suffix:semicolon
DECL|member|handler
id|ide_handler_t
op_star
id|handler
suffix:semicolon
DECL|member|rq
r_struct
id|request
op_star
id|rq
suffix:semicolon
multiline_comment|/* copy of request */
DECL|member|special
r_void
op_star
id|special
suffix:semicolon
multiline_comment|/* valid_t generally */
DECL|typedef|ide_task_t
)brace
id|ide_task_t
suffix:semicolon
DECL|struct|pkt_task_s
r_typedef
r_struct
id|pkt_task_s
(brace
multiline_comment|/*&n; *&t;struct hd_drive_task_hdr&t;pktf;&n; *&t;task_struct_t&t;&t;pktf;&n; *&t;u8&t;&t;&t;pkcdb[12];&n; */
DECL|member|tfRegister
id|task_ioreg_t
id|tfRegister
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|data_phase
r_int
id|data_phase
suffix:semicolon
DECL|member|command_type
r_int
id|command_type
suffix:semicolon
DECL|member|handler
id|ide_handler_t
op_star
id|handler
suffix:semicolon
DECL|member|rq
r_struct
id|request
op_star
id|rq
suffix:semicolon
multiline_comment|/* copy of request */
DECL|member|special
r_void
op_star
id|special
suffix:semicolon
DECL|typedef|pkt_task_t
)brace
id|pkt_task_t
suffix:semicolon
r_extern
id|u32
id|ide_read_24
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_extern
r_void
id|SELECT_DRIVE
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_extern
r_void
id|SELECT_INTERRUPT
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_extern
r_void
id|SELECT_MASK
c_func
(paren
id|ide_drive_t
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_void
id|QUIRK_LIST
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_extern
r_void
id|ata_input_data
c_func
(paren
id|ide_drive_t
op_star
comma
r_void
op_star
comma
id|u32
)paren
suffix:semicolon
r_extern
r_void
id|ata_output_data
c_func
(paren
id|ide_drive_t
op_star
comma
r_void
op_star
comma
id|u32
)paren
suffix:semicolon
r_extern
r_void
id|atapi_input_bytes
c_func
(paren
id|ide_drive_t
op_star
comma
r_void
op_star
comma
id|u32
)paren
suffix:semicolon
r_extern
r_void
id|atapi_output_bytes
c_func
(paren
id|ide_drive_t
op_star
comma
r_void
op_star
comma
id|u32
)paren
suffix:semicolon
r_extern
r_int
id|drive_is_ready
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|wait_for_ready
c_func
(paren
id|ide_drive_t
op_star
comma
r_int
multiline_comment|/* timeout */
)paren
suffix:semicolon
multiline_comment|/*&n; * taskfile io for disks for now...and builds request from ide_ioctl&n; */
r_extern
id|ide_startstop_t
id|do_rw_taskfile
c_func
(paren
id|ide_drive_t
op_star
comma
id|ide_task_t
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * Special Flagged Register Validation Caller&n; */
r_extern
id|ide_startstop_t
id|flagged_taskfile
c_func
(paren
id|ide_drive_t
op_star
comma
id|ide_task_t
op_star
)paren
suffix:semicolon
r_extern
id|ide_startstop_t
id|set_multmode_intr
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_extern
id|ide_startstop_t
id|set_geometry_intr
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_extern
id|ide_startstop_t
id|recal_intr
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_extern
id|ide_startstop_t
id|task_no_data_intr
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_extern
id|ide_startstop_t
id|task_in_intr
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_extern
id|ide_startstop_t
id|pre_task_out_intr
c_func
(paren
id|ide_drive_t
op_star
comma
r_struct
id|request
op_star
)paren
suffix:semicolon
r_extern
r_int
id|ide_raw_taskfile
c_func
(paren
id|ide_drive_t
op_star
comma
id|ide_task_t
op_star
comma
id|u8
op_star
)paren
suffix:semicolon
r_int
id|ide_taskfile_ioctl
c_func
(paren
id|ide_drive_t
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_int
id|ide_cmd_ioctl
c_func
(paren
id|ide_drive_t
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_int
id|ide_task_ioctl
c_func
(paren
id|ide_drive_t
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_int
id|system_bus_clock
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|ide_driveid_update
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|ide_ata66_check
c_func
(paren
id|ide_drive_t
op_star
comma
id|ide_task_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|ide_config_drive_speed
c_func
(paren
id|ide_drive_t
op_star
comma
id|u8
)paren
suffix:semicolon
r_extern
id|u8
id|eighty_ninty_three
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|set_transfer
c_func
(paren
id|ide_drive_t
op_star
comma
id|ide_task_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|taskfile_lib_get_identify
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
op_star
)paren
suffix:semicolon
r_extern
r_int
id|ide_wait_not_busy
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
comma
r_int
r_int
id|timeout
)paren
suffix:semicolon
id|ide_startstop_t
id|__ide_do_rw_disk
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
id|sector_t
id|block
)paren
suffix:semicolon
multiline_comment|/*&n; * ide_system_bus_speed() returns what we think is the system VESA/PCI&n; * bus speed (in MHz).  This is used for calculating interface PIO timings.&n; * The default is 40 for known PCI systems, 50 otherwise.&n; * The &quot;idebus=xx&quot; parameter can be used to override this value.&n; */
r_extern
r_int
id|ide_system_bus_speed
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * ide_stall_queue() can be used by a drive to give excess bandwidth back&n; * to the hwgroup by sleeping for timeout jiffies.&n; */
r_extern
r_void
id|ide_stall_queue
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|timeout
)paren
suffix:semicolon
r_extern
r_int
id|ide_spin_wait_hwgroup
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_extern
r_void
id|ide_timer_expiry
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_extern
id|irqreturn_t
id|ide_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_extern
r_void
id|do_ide_request
c_func
(paren
id|request_queue_t
op_star
)paren
suffix:semicolon
r_extern
r_void
id|ide_init_subdrivers
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_struct
id|block_device_operations
id|ide_fops
(braket
)braket
suffix:semicolon
r_extern
id|ide_proc_entry_t
id|generic_subdriver_entries
(braket
)braket
suffix:semicolon
r_extern
r_int
id|ata_attach
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|ideprobe_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|ide_scan_pcibus
c_func
(paren
r_int
id|scan_direction
)paren
id|__init
suffix:semicolon
r_extern
r_int
id|ide_pci_register_driver
c_func
(paren
r_struct
id|pci_driver
op_star
id|driver
)paren
suffix:semicolon
r_extern
r_void
id|ide_pci_unregister_driver
c_func
(paren
r_struct
id|pci_driver
op_star
id|driver
)paren
suffix:semicolon
r_void
id|ide_pci_setup_ports
c_func
(paren
r_struct
id|pci_dev
op_star
comma
r_struct
id|ide_pci_device_s
op_star
comma
r_int
comma
id|ata_index_t
op_star
)paren
suffix:semicolon
r_extern
r_void
id|ide_setup_pci_noise
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_struct
id|ide_pci_device_s
op_star
id|d
)paren
suffix:semicolon
r_extern
r_void
id|default_hwif_iops
c_func
(paren
id|ide_hwif_t
op_star
)paren
suffix:semicolon
r_extern
r_void
id|default_hwif_mmiops
c_func
(paren
id|ide_hwif_t
op_star
)paren
suffix:semicolon
r_extern
r_void
id|default_hwif_transport
c_func
(paren
id|ide_hwif_t
op_star
)paren
suffix:semicolon
r_int
id|ide_register_driver
c_func
(paren
id|ide_driver_t
op_star
id|driver
)paren
suffix:semicolon
r_void
id|ide_unregister_driver
c_func
(paren
id|ide_driver_t
op_star
id|driver
)paren
suffix:semicolon
r_int
id|ide_register_subdriver
c_func
(paren
id|ide_drive_t
op_star
comma
id|ide_driver_t
op_star
)paren
suffix:semicolon
r_int
id|ide_unregister_subdriver
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_int
id|ide_replace_subdriver
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_const
r_char
op_star
id|driver
)paren
suffix:semicolon
DECL|macro|ON_BOARD
mdefine_line|#define ON_BOARD&t;&t;1
DECL|macro|NEVER_BOARD
mdefine_line|#define NEVER_BOARD&t;&t;0
macro_line|#ifdef CONFIG_BLK_DEV_OFFBOARD
DECL|macro|OFF_BOARD
macro_line|#  define OFF_BOARD&t;&t;ON_BOARD
macro_line|#else /* CONFIG_BLK_DEV_OFFBOARD */
DECL|macro|OFF_BOARD
macro_line|#  define OFF_BOARD&t;&t;NEVER_BOARD
macro_line|#endif /* CONFIG_BLK_DEV_OFFBOARD */
DECL|macro|NODMA
mdefine_line|#define NODMA 0
DECL|macro|NOAUTODMA
mdefine_line|#define NOAUTODMA 1
DECL|macro|AUTODMA
mdefine_line|#define AUTODMA 2
DECL|struct|ide_pci_enablebit_s
r_typedef
r_struct
id|ide_pci_enablebit_s
(brace
DECL|member|reg
id|u8
id|reg
suffix:semicolon
multiline_comment|/* byte pci reg holding the enable-bit */
DECL|member|mask
id|u8
id|mask
suffix:semicolon
multiline_comment|/* mask to isolate the enable-bit */
DECL|member|val
id|u8
id|val
suffix:semicolon
multiline_comment|/* value of masked reg when &quot;enabled&quot; */
DECL|typedef|ide_pci_enablebit_t
)brace
id|ide_pci_enablebit_t
suffix:semicolon
r_enum
(brace
multiline_comment|/* Uses ISA control ports not PCI ones. */
DECL|enumerator|IDEPCI_FLAG_ISA_PORTS
id|IDEPCI_FLAG_ISA_PORTS
op_assign
(paren
l_int|1
op_lshift
l_int|0
)paren
comma
DECL|enumerator|IDEPCI_FLAG_FORCE_PDC
id|IDEPCI_FLAG_FORCE_PDC
op_assign
(paren
l_int|1
op_lshift
l_int|1
)paren
comma
)brace
suffix:semicolon
DECL|struct|ide_pci_device_s
r_typedef
r_struct
id|ide_pci_device_s
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|init_setup
r_int
(paren
op_star
id|init_setup
)paren
(paren
r_struct
id|pci_dev
op_star
comma
r_struct
id|ide_pci_device_s
op_star
)paren
suffix:semicolon
DECL|member|init_setup_dma
r_void
(paren
op_star
id|init_setup_dma
)paren
(paren
r_struct
id|pci_dev
op_star
comma
r_struct
id|ide_pci_device_s
op_star
comma
id|ide_hwif_t
op_star
)paren
suffix:semicolon
DECL|member|init_chipset
r_int
r_int
(paren
op_star
id|init_chipset
)paren
(paren
r_struct
id|pci_dev
op_star
comma
r_const
r_char
op_star
)paren
suffix:semicolon
DECL|member|init_iops
r_void
(paren
op_star
id|init_iops
)paren
(paren
id|ide_hwif_t
op_star
)paren
suffix:semicolon
DECL|member|init_hwif
r_void
(paren
op_star
id|init_hwif
)paren
(paren
id|ide_hwif_t
op_star
)paren
suffix:semicolon
DECL|member|init_dma
r_void
(paren
op_star
id|init_dma
)paren
(paren
id|ide_hwif_t
op_star
comma
r_int
r_int
)paren
suffix:semicolon
DECL|member|fixup
r_void
(paren
op_star
id|fixup
)paren
(paren
id|ide_hwif_t
op_star
)paren
suffix:semicolon
DECL|member|channels
id|u8
id|channels
suffix:semicolon
DECL|member|autodma
id|u8
id|autodma
suffix:semicolon
DECL|member|enablebits
id|ide_pci_enablebit_t
id|enablebits
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|bootable
id|u8
id|bootable
suffix:semicolon
DECL|member|extra
r_int
r_int
id|extra
suffix:semicolon
DECL|member|next
r_struct
id|ide_pci_device_s
op_star
id|next
suffix:semicolon
DECL|member|flags
id|u8
id|flags
suffix:semicolon
DECL|typedef|ide_pci_device_t
)brace
id|ide_pci_device_t
suffix:semicolon
r_extern
r_int
id|ide_setup_pci_device
c_func
(paren
r_struct
id|pci_dev
op_star
comma
id|ide_pci_device_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|ide_setup_pci_devices
c_func
(paren
r_struct
id|pci_dev
op_star
comma
r_struct
id|pci_dev
op_star
comma
id|ide_pci_device_t
op_star
)paren
suffix:semicolon
r_void
id|ide_map_sg
c_func
(paren
id|ide_drive_t
op_star
comma
r_struct
id|request
op_star
)paren
suffix:semicolon
r_void
id|ide_init_sg_cmd
c_func
(paren
id|ide_drive_t
op_star
comma
r_struct
id|request
op_star
)paren
suffix:semicolon
DECL|macro|BAD_DMA_DRIVE
mdefine_line|#define BAD_DMA_DRIVE&t;&t;0
DECL|macro|GOOD_DMA_DRIVE
mdefine_line|#define GOOD_DMA_DRIVE&t;&t;1
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA
r_int
id|__ide_dma_bad_drive
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_int
id|__ide_dma_good_drive
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_int
id|ide_use_dma
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_int
id|__ide_dma_off
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_void
id|ide_dma_verbose
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
id|ide_startstop_t
id|ide_dma_intr
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
r_extern
r_int
id|ide_build_sglist
c_func
(paren
id|ide_drive_t
op_star
comma
r_struct
id|request
op_star
)paren
suffix:semicolon
r_extern
r_int
id|ide_build_dmatable
c_func
(paren
id|ide_drive_t
op_star
comma
r_struct
id|request
op_star
)paren
suffix:semicolon
r_extern
r_void
id|ide_destroy_dmatable
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|ide_release_dma
c_func
(paren
id|ide_hwif_t
op_star
)paren
suffix:semicolon
r_extern
r_void
id|ide_setup_dma
c_func
(paren
id|ide_hwif_t
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_int
id|__ide_dma_host_off
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|__ide_dma_off_quietly
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|__ide_dma_host_on
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|__ide_dma_on
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|__ide_dma_check
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|ide_dma_setup
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_extern
r_void
id|ide_dma_start
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|__ide_dma_end
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|__ide_dma_test_irq
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|__ide_dma_lostirq
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|__ide_dma_timeout
c_func
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
macro_line|#else
DECL|function|ide_use_dma
r_static
r_inline
r_int
id|ide_use_dma
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__ide_dma_off
r_static
r_inline
r_int
id|__ide_dma_off
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ide_dma_verbose
r_static
r_inline
r_void
id|ide_dma_verbose
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA */
macro_line|#ifndef CONFIG_BLK_DEV_IDEDMA_PCI
DECL|function|ide_release_dma
r_static
r_inline
r_void
id|ide_release_dma
c_func
(paren
id|ide_hwif_t
op_star
id|drive
)paren
(brace
suffix:semicolon
)brace
macro_line|#endif
r_extern
r_int
id|ide_hwif_request_regions
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
suffix:semicolon
r_extern
r_void
id|ide_hwif_release_regions
c_func
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
suffix:semicolon
r_extern
r_void
id|ide_unregister
(paren
r_int
r_int
id|index
)paren
suffix:semicolon
r_void
id|ide_undecoded_slave
c_func
(paren
id|ide_hwif_t
op_star
)paren
suffix:semicolon
r_int
id|probe_hwif_init_with_fixup
c_func
(paren
id|ide_hwif_t
op_star
comma
r_void
(paren
op_star
)paren
(paren
id|ide_hwif_t
op_star
)paren
)paren
suffix:semicolon
r_extern
r_int
id|probe_hwif_init
c_func
(paren
id|ide_hwif_t
op_star
)paren
suffix:semicolon
DECL|function|ide_get_hwifdata
r_static
r_inline
r_void
op_star
id|ide_get_hwifdata
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
r_return
id|hwif-&gt;hwif_data
suffix:semicolon
)brace
DECL|function|ide_set_hwifdata
r_static
r_inline
r_void
id|ide_set_hwifdata
(paren
id|ide_hwif_t
op_star
id|hwif
comma
r_void
op_star
id|data
)paren
(brace
id|hwif-&gt;hwif_data
op_assign
id|data
suffix:semicolon
)brace
multiline_comment|/* ide-lib.c */
r_extern
id|u8
id|ide_dma_speed
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
id|mode
)paren
suffix:semicolon
r_extern
id|u8
id|ide_rate_filter
c_func
(paren
id|u8
id|mode
comma
id|u8
id|speed
)paren
suffix:semicolon
r_extern
r_int
id|ide_dma_enable
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_extern
r_char
op_star
id|ide_xfer_verbose
c_func
(paren
id|u8
id|xfer_rate
)paren
suffix:semicolon
r_extern
r_void
id|ide_toggle_bounce
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|on
)paren
suffix:semicolon
r_extern
r_int
id|ide_set_xfer_rate
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
id|rate
)paren
suffix:semicolon
id|u8
id|ide_dump_status
c_func
(paren
id|ide_drive_t
op_star
comma
r_const
r_char
op_star
comma
id|u8
)paren
suffix:semicolon
DECL|struct|ide_pio_timings_s
r_typedef
r_struct
id|ide_pio_timings_s
(brace
DECL|member|setup_time
r_int
id|setup_time
suffix:semicolon
multiline_comment|/* Address setup (ns) minimum */
DECL|member|active_time
r_int
id|active_time
suffix:semicolon
multiline_comment|/* Active pulse (ns) minimum */
DECL|member|cycle_time
r_int
id|cycle_time
suffix:semicolon
multiline_comment|/* Cycle time (ns) minimum = (setup + active + recovery) */
DECL|typedef|ide_pio_timings_t
)brace
id|ide_pio_timings_t
suffix:semicolon
DECL|struct|ide_pio_data_s
r_typedef
r_struct
id|ide_pio_data_s
(brace
DECL|member|pio_mode
id|u8
id|pio_mode
suffix:semicolon
DECL|member|use_iordy
id|u8
id|use_iordy
suffix:semicolon
DECL|member|overridden
id|u8
id|overridden
suffix:semicolon
DECL|member|blacklisted
id|u8
id|blacklisted
suffix:semicolon
DECL|member|cycle_time
r_int
r_int
id|cycle_time
suffix:semicolon
DECL|typedef|ide_pio_data_t
)brace
id|ide_pio_data_t
suffix:semicolon
r_extern
id|u8
id|ide_get_best_pio_mode
(paren
id|ide_drive_t
op_star
id|drive
comma
id|u8
id|mode_wanted
comma
id|u8
id|max_mode
comma
id|ide_pio_data_t
op_star
id|d
)paren
suffix:semicolon
r_extern
r_const
id|ide_pio_timings_t
id|ide_pio_timings
(braket
l_int|6
)braket
suffix:semicolon
r_extern
id|spinlock_t
id|ide_lock
suffix:semicolon
r_extern
r_struct
id|semaphore
id|ide_cfg_sem
suffix:semicolon
multiline_comment|/*&n; * Structure locking:&n; *&n; * ide_cfg_sem and ide_lock together protect changes to&n; * ide_hwif_t-&gt;{next,hwgroup}&n; * ide_drive_t-&gt;next&n; *&n; * ide_hwgroup_t-&gt;busy: ide_lock&n; * ide_hwgroup_t-&gt;hwif: ide_lock&n; * ide_hwif_t-&gt;mate: constant, no locking&n; * ide_drive_t-&gt;hwif: constant, no locking&n; */
DECL|macro|local_irq_set
mdefine_line|#define local_irq_set(flags)&t;do { local_save_flags((flags)); local_irq_enable(); } while (0)
r_extern
r_struct
id|bus_type
id|ide_bus_type
suffix:semicolon
multiline_comment|/* check if CACHE FLUSH (EXT) command is supported (bits defined in ATA-6) */
DECL|macro|ide_id_has_flush_cache
mdefine_line|#define ide_id_has_flush_cache(id)&t;((id)-&gt;cfs_enable_2 &amp; 0x3000)
multiline_comment|/* some Maxtor disks have bit 13 defined incorrectly so check bit 10 too */
DECL|macro|ide_id_has_flush_cache_ext
mdefine_line|#define ide_id_has_flush_cache_ext(id)&t;&bslash;&n;&t;(((id)-&gt;cfs_enable_2 &amp; 0x2400) == 0x2400)
macro_line|#endif /* _IDE_H */
eof
