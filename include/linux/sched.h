macro_line|#ifndef _LINUX_SCHED_H
DECL|macro|_LINUX_SCHED_H
mdefine_line|#define _LINUX_SCHED_H
macro_line|#include &lt;asm/param.h&gt;&t;/* for HZ */
r_extern
r_int
r_int
id|event
suffix:semicolon
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/capability.h&gt;
macro_line|#include &lt;linux/tqueue.h&gt;
macro_line|#include &lt;linux/threads.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/times.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &lt;linux/jiffies.h&gt;
macro_line|#include &lt;linux/rbtree.h&gt;
macro_line|#include &lt;linux/thread_info.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/sem.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/securebits.h&gt;
macro_line|#include &lt;linux/fs_struct.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
r_struct
id|exec_domain
suffix:semicolon
multiline_comment|/*&n; * cloning flags:&n; */
DECL|macro|CSIGNAL
mdefine_line|#define CSIGNAL&t;&t;0x000000ff&t;/* signal mask to be sent at exit */
DECL|macro|CLONE_VM
mdefine_line|#define CLONE_VM&t;0x00000100&t;/* set if VM shared between processes */
DECL|macro|CLONE_FS
mdefine_line|#define CLONE_FS&t;0x00000200&t;/* set if fs info shared between processes */
DECL|macro|CLONE_FILES
mdefine_line|#define CLONE_FILES&t;0x00000400&t;/* set if open files shared between processes */
DECL|macro|CLONE_SIGHAND
mdefine_line|#define CLONE_SIGHAND&t;0x00000800&t;/* set if signal handlers and blocked signals shared */
DECL|macro|CLONE_IDLETASK
mdefine_line|#define CLONE_IDLETASK&t;0x00001000&t;/* set if new pid should be 0 (kernel only)*/
DECL|macro|CLONE_PTRACE
mdefine_line|#define CLONE_PTRACE&t;0x00002000&t;/* set if we want to let tracing continue on the child too */
DECL|macro|CLONE_VFORK
mdefine_line|#define CLONE_VFORK&t;0x00004000&t;/* set if the parent wants the child to wake it up on mm_release */
DECL|macro|CLONE_PARENT
mdefine_line|#define CLONE_PARENT&t;0x00008000&t;/* set if we want to have the same parent as the cloner */
DECL|macro|CLONE_THREAD
mdefine_line|#define CLONE_THREAD&t;0x00010000&t;/* Same thread group? */
DECL|macro|CLONE_NEWNS
mdefine_line|#define CLONE_NEWNS&t;0x00020000&t;/* New namespace group? */
DECL|macro|CLONE_SYSVSEM
mdefine_line|#define CLONE_SYSVSEM&t;0x00040000&t;/* share system V SEM_UNDO semantics */
DECL|macro|CLONE_SIGNAL
mdefine_line|#define CLONE_SIGNAL&t;(CLONE_SIGHAND | CLONE_THREAD)
multiline_comment|/*&n; * These are the constant used to fake the fixed-point load-average&n; * counting. Some notes:&n; *  - 11 bit fractions expand to 22 bits by the multiplies: this gives&n; *    a load-average precision of 10 bits integer + 11 bits fractional&n; *  - if you want to count load-averages more often, you need more&n; *    precision, or rounding will get you. With 2-second counting freq,&n; *    the EXP_n values would be 1981, 2034 and 2043 if still using only&n; *    11 bit fractions.&n; */
r_extern
r_int
r_int
id|avenrun
(braket
)braket
suffix:semicolon
multiline_comment|/* Load averages */
DECL|macro|FSHIFT
mdefine_line|#define FSHIFT&t;&t;11&t;&t;/* nr of bits of precision */
DECL|macro|FIXED_1
mdefine_line|#define FIXED_1&t;&t;(1&lt;&lt;FSHIFT)&t;/* 1.0 as fixed-point */
DECL|macro|LOAD_FREQ
mdefine_line|#define LOAD_FREQ&t;(5*HZ)&t;&t;/* 5 sec intervals */
DECL|macro|EXP_1
mdefine_line|#define EXP_1&t;&t;1884&t;&t;/* 1/exp(5sec/1min) as fixed-point */
DECL|macro|EXP_5
mdefine_line|#define EXP_5&t;&t;2014&t;&t;/* 1/exp(5sec/5min) */
DECL|macro|EXP_15
mdefine_line|#define EXP_15&t;&t;2037&t;&t;/* 1/exp(5sec/15min) */
DECL|macro|CALC_LOAD
mdefine_line|#define CALC_LOAD(load,exp,n) &bslash;&n;&t;load *= exp; &bslash;&n;&t;load += n*(FIXED_1-exp); &bslash;&n;&t;load &gt;&gt;= FSHIFT;
DECL|macro|CT_TO_SECS
mdefine_line|#define CT_TO_SECS(x)&t;((x) / HZ)
DECL|macro|CT_TO_USECS
mdefine_line|#define CT_TO_USECS(x)&t;(((x) % HZ) * 1000000/HZ)
r_extern
r_int
id|nr_threads
suffix:semicolon
r_extern
r_int
id|last_pid
suffix:semicolon
r_extern
r_int
r_int
id|nr_running
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
r_int
id|nr_uninterruptible
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/param.h&gt;
macro_line|#include &lt;linux/resource.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
DECL|macro|TASK_RUNNING
mdefine_line|#define TASK_RUNNING&t;&t;0
DECL|macro|TASK_INTERRUPTIBLE
mdefine_line|#define TASK_INTERRUPTIBLE&t;1
DECL|macro|TASK_UNINTERRUPTIBLE
mdefine_line|#define TASK_UNINTERRUPTIBLE&t;2
DECL|macro|TASK_ZOMBIE
mdefine_line|#define TASK_ZOMBIE&t;&t;4
DECL|macro|TASK_STOPPED
mdefine_line|#define TASK_STOPPED&t;&t;8
DECL|macro|__set_task_state
mdefine_line|#define __set_task_state(tsk, state_value)&t;&t;&bslash;&n;&t;do { (tsk)-&gt;state = (state_value); } while (0)
macro_line|#ifdef CONFIG_SMP
DECL|macro|set_task_state
mdefine_line|#define set_task_state(tsk, state_value)&t;&t;&bslash;&n;&t;set_mb((tsk)-&gt;state, (state_value))
macro_line|#else
DECL|macro|set_task_state
mdefine_line|#define set_task_state(tsk, state_value)&t;&t;&bslash;&n;&t;__set_task_state((tsk), (state_value))
macro_line|#endif
DECL|macro|__set_current_state
mdefine_line|#define __set_current_state(state_value)&t;&t;&t;&bslash;&n;&t;do { current-&gt;state = (state_value); } while (0)
macro_line|#ifdef CONFIG_SMP
DECL|macro|set_current_state
mdefine_line|#define set_current_state(state_value)&t;&t;&bslash;&n;&t;set_mb(current-&gt;state, (state_value))
macro_line|#else
DECL|macro|set_current_state
mdefine_line|#define set_current_state(state_value)&t;&t;&bslash;&n;&t;__set_current_state(state_value)
macro_line|#endif
multiline_comment|/*&n; * Scheduling policies&n; */
DECL|macro|SCHED_OTHER
mdefine_line|#define SCHED_OTHER&t;&t;0
DECL|macro|SCHED_FIFO
mdefine_line|#define SCHED_FIFO&t;&t;1
DECL|macro|SCHED_RR
mdefine_line|#define SCHED_RR&t;&t;2
DECL|struct|sched_param
r_struct
id|sched_param
(brace
DECL|member|sched_priority
r_int
id|sched_priority
suffix:semicolon
)brace
suffix:semicolon
r_struct
id|completion
suffix:semicolon
macro_line|#ifdef __KERNEL__
macro_line|#include &lt;linux/spinlock.h&gt;
multiline_comment|/*&n; * This serializes &quot;schedule()&quot; and also protects&n; * the run-queue from deletions/modifications (but&n; * _adding_ to the beginning of the run-queue has&n; * a separate lock).&n; */
r_extern
id|rwlock_t
id|tasklist_lock
suffix:semicolon
r_extern
id|spinlock_t
id|mmlist_lock
suffix:semicolon
DECL|typedef|task_t
r_typedef
r_struct
id|task_struct
id|task_t
suffix:semicolon
r_extern
r_void
id|sched_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|init_idle
c_func
(paren
id|task_t
op_star
id|idle
comma
r_int
id|cpu
)paren
suffix:semicolon
r_extern
r_void
id|show_state
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|cpu_init
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|trap_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|update_process_times
c_func
(paren
r_int
id|user
)paren
suffix:semicolon
r_extern
r_void
id|update_one_process
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
r_int
id|user
comma
r_int
r_int
id|system
comma
r_int
id|cpu
)paren
suffix:semicolon
r_extern
r_void
id|scheduler_tick
c_func
(paren
r_int
id|user_tick
comma
r_int
id|system
)paren
suffix:semicolon
r_extern
r_void
id|migration_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
r_int
id|cache_decay_ticks
suffix:semicolon
DECL|macro|MAX_SCHEDULE_TIMEOUT
mdefine_line|#define&t;MAX_SCHEDULE_TIMEOUT&t;LONG_MAX
r_extern
r_int
r_int
id|FASTCALL
c_func
(paren
id|schedule_timeout
c_func
(paren
r_int
r_int
id|timeout
)paren
)paren
suffix:semicolon
id|asmlinkage
r_void
id|schedule
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|schedule_task
c_func
(paren
r_struct
id|tq_struct
op_star
id|task
)paren
suffix:semicolon
r_extern
r_void
id|flush_scheduled_tasks
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|start_context_thread
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|current_is_keventd
c_func
(paren
r_void
)paren
suffix:semicolon
r_struct
r_namespace
suffix:semicolon
multiline_comment|/* Maximum number of active map areas.. This is a random (large) number */
DECL|macro|MAX_MAP_COUNT
mdefine_line|#define MAX_MAP_COUNT&t;(65536)
DECL|struct|mm_struct
r_struct
id|mm_struct
(brace
DECL|member|mmap
r_struct
id|vm_area_struct
op_star
id|mmap
suffix:semicolon
multiline_comment|/* list of VMAs */
DECL|member|mm_rb
id|rb_root_t
id|mm_rb
suffix:semicolon
DECL|member|mmap_cache
r_struct
id|vm_area_struct
op_star
id|mmap_cache
suffix:semicolon
multiline_comment|/* last find_vma result */
DECL|member|pgd
id|pgd_t
op_star
id|pgd
suffix:semicolon
DECL|member|mm_users
id|atomic_t
id|mm_users
suffix:semicolon
multiline_comment|/* How many users with user space? */
DECL|member|mm_count
id|atomic_t
id|mm_count
suffix:semicolon
multiline_comment|/* How many references to &quot;struct mm_struct&quot; (users count as 1) */
DECL|member|map_count
r_int
id|map_count
suffix:semicolon
multiline_comment|/* number of VMAs */
DECL|member|mmap_sem
r_struct
id|rw_semaphore
id|mmap_sem
suffix:semicolon
DECL|member|page_table_lock
id|spinlock_t
id|page_table_lock
suffix:semicolon
multiline_comment|/* Protects task page tables and mm-&gt;rss */
DECL|member|mmlist
r_struct
id|list_head
id|mmlist
suffix:semicolon
multiline_comment|/* List of all active mm&squot;s.  These are globally strung&n;&t;&t;&t;&t;&t;&t; * together off init_mm.mmlist, and are protected&n;&t;&t;&t;&t;&t;&t; * by mmlist_lock&n;&t;&t;&t;&t;&t;&t; */
DECL|member|start_code
DECL|member|end_code
DECL|member|start_data
DECL|member|end_data
r_int
r_int
id|start_code
comma
id|end_code
comma
id|start_data
comma
id|end_data
suffix:semicolon
DECL|member|start_brk
DECL|member|brk
DECL|member|start_stack
r_int
r_int
id|start_brk
comma
id|brk
comma
id|start_stack
suffix:semicolon
DECL|member|arg_start
DECL|member|arg_end
DECL|member|env_start
DECL|member|env_end
r_int
r_int
id|arg_start
comma
id|arg_end
comma
id|env_start
comma
id|env_end
suffix:semicolon
DECL|member|rss
DECL|member|total_vm
DECL|member|locked_vm
r_int
r_int
id|rss
comma
id|total_vm
comma
id|locked_vm
suffix:semicolon
DECL|member|def_flags
r_int
r_int
id|def_flags
suffix:semicolon
DECL|member|cpu_vm_mask
r_int
r_int
id|cpu_vm_mask
suffix:semicolon
DECL|member|swap_address
r_int
r_int
id|swap_address
suffix:semicolon
DECL|member|dumpable
r_int
id|dumpable
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Architecture-specific MM context */
DECL|member|context
id|mm_context_t
id|context
suffix:semicolon
)brace
suffix:semicolon
r_extern
r_int
id|mmlist_nr
suffix:semicolon
DECL|struct|signal_struct
r_struct
id|signal_struct
(brace
DECL|member|count
id|atomic_t
id|count
suffix:semicolon
DECL|member|action
r_struct
id|k_sigaction
id|action
(braket
id|_NSIG
)braket
suffix:semicolon
DECL|member|siglock
id|spinlock_t
id|siglock
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Priority of a process goes from 0..MAX_PRIO-1, valid RT&n; * priority is 0..MAX_RT_PRIO-1, and SCHED_OTHER tasks are&n; * in the range MAX_RT_PRIO..MAX_PRIO-1. Priority values&n; * are inverted: lower p-&gt;prio value means higher priority.&n; *&n; * The MAX_RT_USER_PRIO value allows the actual maximum&n; * RT priority to be separate from the value exported to&n; * user-space.  This allows kernel threads to set their&n; * priority to a value higher than any user task. Note:&n; * MAX_RT_PRIO must not be smaller than MAX_USER_RT_PRIO.&n; */
DECL|macro|MAX_USER_RT_PRIO
mdefine_line|#define MAX_USER_RT_PRIO&t;100
DECL|macro|MAX_RT_PRIO
mdefine_line|#define MAX_RT_PRIO&t;&t;MAX_USER_RT_PRIO
DECL|macro|MAX_PRIO
mdefine_line|#define MAX_PRIO&t;&t;(MAX_RT_PRIO + 40)
multiline_comment|/*&n; * Some day this will be a full-fledged user tracking system..&n; */
DECL|struct|user_struct
r_struct
id|user_struct
(brace
DECL|member|__count
id|atomic_t
id|__count
suffix:semicolon
multiline_comment|/* reference count */
DECL|member|processes
id|atomic_t
id|processes
suffix:semicolon
multiline_comment|/* How many processes does this user have? */
DECL|member|files
id|atomic_t
id|files
suffix:semicolon
multiline_comment|/* How many open files does this user have? */
multiline_comment|/* Hash table maintenance information */
DECL|member|uidhash_list
r_struct
id|list_head
id|uidhash_list
suffix:semicolon
DECL|member|uid
id|uid_t
id|uid
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|get_current_user
mdefine_line|#define get_current_user() ({ &t;&t;&t;&t;&bslash;&n;&t;struct user_struct *__user = current-&gt;user;&t;&bslash;&n;&t;atomic_inc(&amp;__user-&gt;__count);&t;&t;&t;&bslash;&n;&t;__user; })
r_extern
r_struct
id|user_struct
id|root_user
suffix:semicolon
DECL|macro|INIT_USER
mdefine_line|#define INIT_USER (&amp;root_user)
DECL|typedef|prio_array_t
r_typedef
r_struct
id|prio_array
id|prio_array_t
suffix:semicolon
DECL|struct|task_struct
r_struct
id|task_struct
(brace
DECL|member|state
r_volatile
r_int
id|state
suffix:semicolon
multiline_comment|/* -1 unrunnable, 0 runnable, &gt;0 stopped */
DECL|member|thread_info
r_struct
id|thread_info
op_star
id|thread_info
suffix:semicolon
DECL|member|usage
id|atomic_t
id|usage
suffix:semicolon
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* per process flags, defined below */
DECL|member|ptrace
r_int
r_int
id|ptrace
suffix:semicolon
DECL|member|lock_depth
r_int
id|lock_depth
suffix:semicolon
multiline_comment|/* Lock depth */
DECL|member|prio
DECL|member|static_prio
r_int
id|prio
comma
id|static_prio
suffix:semicolon
DECL|member|run_list
id|list_t
id|run_list
suffix:semicolon
DECL|member|array
id|prio_array_t
op_star
id|array
suffix:semicolon
DECL|member|sleep_avg
r_int
r_int
id|sleep_avg
suffix:semicolon
DECL|member|sleep_timestamp
r_int
r_int
id|sleep_timestamp
suffix:semicolon
DECL|member|policy
r_int
r_int
id|policy
suffix:semicolon
DECL|member|cpus_allowed
r_int
r_int
id|cpus_allowed
suffix:semicolon
DECL|member|time_slice
r_int
r_int
id|time_slice
suffix:semicolon
DECL|member|tasks
r_struct
id|list_head
id|tasks
suffix:semicolon
DECL|member|mm
DECL|member|active_mm
r_struct
id|mm_struct
op_star
id|mm
comma
op_star
id|active_mm
suffix:semicolon
DECL|member|local_pages
r_struct
id|list_head
id|local_pages
suffix:semicolon
DECL|member|allocation_order
DECL|member|nr_local_pages
r_int
r_int
id|allocation_order
comma
id|nr_local_pages
suffix:semicolon
multiline_comment|/* task state */
DECL|member|binfmt
r_struct
id|linux_binfmt
op_star
id|binfmt
suffix:semicolon
DECL|member|exit_code
DECL|member|exit_signal
r_int
id|exit_code
comma
id|exit_signal
suffix:semicolon
DECL|member|pdeath_signal
r_int
id|pdeath_signal
suffix:semicolon
multiline_comment|/*  The signal sent when the parent dies  */
multiline_comment|/* ??? */
DECL|member|personality
r_int
r_int
id|personality
suffix:semicolon
DECL|member|did_exec
r_int
id|did_exec
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pid
id|pid_t
id|pid
suffix:semicolon
DECL|member|pgrp
id|pid_t
id|pgrp
suffix:semicolon
DECL|member|tty_old_pgrp
id|pid_t
id|tty_old_pgrp
suffix:semicolon
DECL|member|session
id|pid_t
id|session
suffix:semicolon
DECL|member|tgid
id|pid_t
id|tgid
suffix:semicolon
multiline_comment|/* boolean value for session group leader */
DECL|member|leader
r_int
id|leader
suffix:semicolon
multiline_comment|/* &n;&t; * pointers to (original) parent process, youngest child, younger sibling,&n;&t; * older sibling, respectively.  (p-&gt;father can be replaced with &n;&t; * p-&gt;parent-&gt;pid)&n;&t; */
DECL|member|real_parent
r_struct
id|task_struct
op_star
id|real_parent
suffix:semicolon
multiline_comment|/* real parent process (when being debugged) */
DECL|member|parent
r_struct
id|task_struct
op_star
id|parent
suffix:semicolon
multiline_comment|/* parent process */
DECL|member|children
r_struct
id|list_head
id|children
suffix:semicolon
multiline_comment|/* list of my children */
DECL|member|sibling
r_struct
id|list_head
id|sibling
suffix:semicolon
multiline_comment|/* linkage in my parent&squot;s children list */
DECL|member|thread_group
r_struct
id|list_head
id|thread_group
suffix:semicolon
multiline_comment|/* PID hash table linkage. */
DECL|member|pidhash_next
r_struct
id|task_struct
op_star
id|pidhash_next
suffix:semicolon
DECL|member|pidhash_pprev
r_struct
id|task_struct
op_star
op_star
id|pidhash_pprev
suffix:semicolon
DECL|member|wait_chldexit
id|wait_queue_head_t
id|wait_chldexit
suffix:semicolon
multiline_comment|/* for wait4() */
DECL|member|vfork_done
r_struct
id|completion
op_star
id|vfork_done
suffix:semicolon
multiline_comment|/* for vfork() */
DECL|member|rt_priority
r_int
r_int
id|rt_priority
suffix:semicolon
DECL|member|it_real_value
DECL|member|it_prof_value
DECL|member|it_virt_value
r_int
r_int
id|it_real_value
comma
id|it_prof_value
comma
id|it_virt_value
suffix:semicolon
DECL|member|it_real_incr
DECL|member|it_prof_incr
DECL|member|it_virt_incr
r_int
r_int
id|it_real_incr
comma
id|it_prof_incr
comma
id|it_virt_incr
suffix:semicolon
DECL|member|real_timer
r_struct
id|timer_list
id|real_timer
suffix:semicolon
DECL|member|times
r_struct
id|tms
id|times
suffix:semicolon
DECL|member|start_time
r_int
r_int
id|start_time
suffix:semicolon
DECL|member|per_cpu_utime
DECL|member|per_cpu_stime
r_int
id|per_cpu_utime
(braket
id|NR_CPUS
)braket
comma
id|per_cpu_stime
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */
DECL|member|min_flt
DECL|member|maj_flt
DECL|member|nswap
DECL|member|cmin_flt
DECL|member|cmaj_flt
DECL|member|cnswap
r_int
r_int
id|min_flt
comma
id|maj_flt
comma
id|nswap
comma
id|cmin_flt
comma
id|cmaj_flt
comma
id|cnswap
suffix:semicolon
DECL|member|swappable
r_int
id|swappable
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* process credentials */
DECL|member|uid
DECL|member|euid
DECL|member|suid
DECL|member|fsuid
id|uid_t
id|uid
comma
id|euid
comma
id|suid
comma
id|fsuid
suffix:semicolon
DECL|member|gid
DECL|member|egid
DECL|member|sgid
DECL|member|fsgid
id|gid_t
id|gid
comma
id|egid
comma
id|sgid
comma
id|fsgid
suffix:semicolon
DECL|member|ngroups
r_int
id|ngroups
suffix:semicolon
DECL|member|groups
id|gid_t
id|groups
(braket
id|NGROUPS
)braket
suffix:semicolon
DECL|member|cap_effective
DECL|member|cap_inheritable
DECL|member|cap_permitted
id|kernel_cap_t
id|cap_effective
comma
id|cap_inheritable
comma
id|cap_permitted
suffix:semicolon
DECL|member|keep_capabilities
r_int
id|keep_capabilities
suffix:colon
l_int|1
suffix:semicolon
DECL|member|user
r_struct
id|user_struct
op_star
id|user
suffix:semicolon
multiline_comment|/* limits */
DECL|member|rlim
r_struct
id|rlimit
id|rlim
(braket
id|RLIM_NLIMITS
)braket
suffix:semicolon
DECL|member|used_math
r_int
r_int
id|used_math
suffix:semicolon
DECL|member|comm
r_char
id|comm
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* file system info */
DECL|member|link_count
DECL|member|total_link_count
r_int
id|link_count
comma
id|total_link_count
suffix:semicolon
DECL|member|tty
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
multiline_comment|/* NULL if no tty */
DECL|member|locks
r_int
r_int
id|locks
suffix:semicolon
multiline_comment|/* How many file locks are being held */
multiline_comment|/* ipc stuff */
DECL|member|sysvsem
r_struct
id|sysv_sem
id|sysvsem
suffix:semicolon
multiline_comment|/* CPU-specific state of this task */
DECL|member|thread
r_struct
id|thread_struct
id|thread
suffix:semicolon
multiline_comment|/* filesystem information */
DECL|member|fs
r_struct
id|fs_struct
op_star
id|fs
suffix:semicolon
multiline_comment|/* open file information */
DECL|member|files
r_struct
id|files_struct
op_star
id|files
suffix:semicolon
multiline_comment|/* namespace */
DECL|member|namespace
r_struct
r_namespace
op_star
r_namespace
suffix:semicolon
multiline_comment|/* signal handlers */
DECL|member|sigmask_lock
id|spinlock_t
id|sigmask_lock
suffix:semicolon
multiline_comment|/* Protects signal and blocked */
DECL|member|sig
r_struct
id|signal_struct
op_star
id|sig
suffix:semicolon
DECL|member|blocked
id|sigset_t
id|blocked
suffix:semicolon
DECL|member|pending
r_struct
id|sigpending
id|pending
suffix:semicolon
DECL|member|sas_ss_sp
r_int
r_int
id|sas_ss_sp
suffix:semicolon
DECL|member|sas_ss_size
r_int
id|sas_ss_size
suffix:semicolon
DECL|member|notifier
r_int
(paren
op_star
id|notifier
)paren
(paren
r_void
op_star
id|priv
)paren
suffix:semicolon
DECL|member|notifier_data
r_void
op_star
id|notifier_data
suffix:semicolon
DECL|member|notifier_mask
id|sigset_t
op_star
id|notifier_mask
suffix:semicolon
multiline_comment|/* Thread group tracking */
DECL|member|parent_exec_id
id|u32
id|parent_exec_id
suffix:semicolon
DECL|member|self_exec_id
id|u32
id|self_exec_id
suffix:semicolon
multiline_comment|/* Protection of (de-)allocation: mm, files, fs, tty */
DECL|member|alloc_lock
id|spinlock_t
id|alloc_lock
suffix:semicolon
multiline_comment|/* journalling filesystem info */
DECL|member|journal_info
r_void
op_star
id|journal_info
suffix:semicolon
DECL|member|proc_dentry
r_struct
id|dentry
op_star
id|proc_dentry
suffix:semicolon
)brace
suffix:semicolon
r_extern
r_void
id|__put_task_struct
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
suffix:semicolon
DECL|macro|get_task_struct
mdefine_line|#define get_task_struct(tsk) do { atomic_inc(&amp;(tsk)-&gt;usage); } while(0)
DECL|macro|put_task_struct
mdefine_line|#define put_task_struct(tsk) &bslash;&n;do { if (atomic_dec_and_test(&amp;(tsk)-&gt;usage)) __put_task_struct(tsk); } while(0)
multiline_comment|/*&n; * Per process flags&n; */
DECL|macro|PF_ALIGNWARN
mdefine_line|#define PF_ALIGNWARN&t;0x00000001&t;/* Print alignment warning msgs */
multiline_comment|/* Not implemented yet, only for 486*/
DECL|macro|PF_STARTING
mdefine_line|#define PF_STARTING&t;0x00000002&t;/* being created */
DECL|macro|PF_EXITING
mdefine_line|#define PF_EXITING&t;0x00000004&t;/* getting shut down */
DECL|macro|PF_FORKNOEXEC
mdefine_line|#define PF_FORKNOEXEC&t;0x00000040&t;/* forked but didn&squot;t exec */
DECL|macro|PF_SUPERPRIV
mdefine_line|#define PF_SUPERPRIV&t;0x00000100&t;/* used super-user privileges */
DECL|macro|PF_DUMPCORE
mdefine_line|#define PF_DUMPCORE&t;0x00000200&t;/* dumped core */
DECL|macro|PF_SIGNALED
mdefine_line|#define PF_SIGNALED&t;0x00000400&t;/* killed by a signal */
DECL|macro|PF_MEMALLOC
mdefine_line|#define PF_MEMALLOC&t;0x00000800&t;/* Allocating memory */
DECL|macro|PF_MEMDIE
mdefine_line|#define PF_MEMDIE&t;0x00001000&t;/* Killed for out-of-memory */
DECL|macro|PF_FREE_PAGES
mdefine_line|#define PF_FREE_PAGES&t;0x00002000&t;/* per process page freeing */
DECL|macro|PF_FLUSHER
mdefine_line|#define PF_FLUSHER&t;0x00004000&t;/* responsible for disk writeback */
DECL|macro|PF_RADIX_TREE
mdefine_line|#define PF_RADIX_TREE&t;0x00008000&t;/* debug: performing radix tree alloc */
DECL|macro|PF_FREEZE
mdefine_line|#define PF_FREEZE&t;0x00010000&t;/* this task should be frozen for suspend */
DECL|macro|PF_IOTHREAD
mdefine_line|#define PF_IOTHREAD&t;0x00020000&t;/* this thread is needed for doing I/O to swap */
DECL|macro|PF_FROZEN
mdefine_line|#define PF_FROZEN&t;0x00040000&t;/* frozen for system suspend */
multiline_comment|/*&n; * Ptrace flags&n; */
DECL|macro|PT_PTRACED
mdefine_line|#define PT_PTRACED&t;0x00000001
DECL|macro|PT_DTRACE
mdefine_line|#define PT_DTRACE&t;0x00000002&t;/* delayed trace (used on m68k, i386) */
DECL|macro|PT_TRACESYSGOOD
mdefine_line|#define PT_TRACESYSGOOD&t;0x00000004
DECL|macro|PT_PTRACE_CAP
mdefine_line|#define PT_PTRACE_CAP&t;0x00000008&t;/* ptracer can follow suid-exec */
multiline_comment|/*&n; * Limit the stack by to some sane default: root can always&n; * increase this limit if needed..  8MB seems reasonable.&n; */
DECL|macro|_STK_LIM
mdefine_line|#define _STK_LIM&t;(8*1024*1024)
macro_line|#if CONFIG_SMP
r_extern
r_void
id|set_cpus_allowed
c_func
(paren
id|task_t
op_star
id|p
comma
r_int
r_int
id|new_mask
)paren
suffix:semicolon
macro_line|#else
DECL|macro|set_cpus_allowed
macro_line|# define set_cpus_allowed(p, new_mask) do { } while (0)
macro_line|#endif
r_extern
r_void
id|set_user_nice
c_func
(paren
id|task_t
op_star
id|p
comma
r_int
id|nice
)paren
suffix:semicolon
r_extern
r_int
id|task_prio
c_func
(paren
id|task_t
op_star
id|p
)paren
suffix:semicolon
r_extern
r_int
id|task_nice
c_func
(paren
id|task_t
op_star
id|p
)paren
suffix:semicolon
r_extern
r_int
id|idle_cpu
c_func
(paren
r_int
id|cpu
)paren
suffix:semicolon
id|asmlinkage
r_int
id|sys_sched_yield
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|yield
mdefine_line|#define yield() sys_sched_yield()
multiline_comment|/*&n; * The default (Linux) execution domain.&n; */
r_extern
r_struct
id|exec_domain
id|default_exec_domain
suffix:semicolon
macro_line|#ifndef INIT_THREAD_SIZE
DECL|macro|INIT_THREAD_SIZE
macro_line|# define INIT_THREAD_SIZE&t;2048*sizeof(long)
macro_line|#endif
DECL|union|thread_union
r_union
id|thread_union
(brace
DECL|member|thread_info
r_struct
id|thread_info
id|thread_info
suffix:semicolon
DECL|member|stack
r_int
r_int
id|stack
(braket
id|INIT_THREAD_SIZE
op_div
r_sizeof
(paren
r_int
)paren
)braket
suffix:semicolon
)brace
suffix:semicolon
r_extern
r_union
id|thread_union
id|init_thread_union
suffix:semicolon
r_extern
r_struct
id|task_struct
id|init_task
suffix:semicolon
r_extern
r_struct
id|mm_struct
id|init_mm
suffix:semicolon
r_extern
r_struct
id|task_struct
op_star
id|init_tasks
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* PID hashing. (shouldnt this be dynamic?) */
DECL|macro|PIDHASH_SZ
mdefine_line|#define PIDHASH_SZ (4096 &gt;&gt; 2)
r_extern
r_struct
id|task_struct
op_star
id|pidhash
(braket
id|PIDHASH_SZ
)braket
suffix:semicolon
DECL|macro|pid_hashfn
mdefine_line|#define pid_hashfn(x)&t;((((x) &gt;&gt; 8) ^ (x)) &amp; (PIDHASH_SZ - 1))
DECL|function|hash_pid
r_static
r_inline
r_void
id|hash_pid
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_struct
id|task_struct
op_star
op_star
id|htable
op_assign
op_amp
id|pidhash
(braket
id|pid_hashfn
c_func
(paren
id|p-&gt;pid
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;pidhash_next
op_assign
op_star
id|htable
)paren
op_ne
l_int|NULL
)paren
(brace
(paren
op_star
id|htable
)paren
op_member_access_from_pointer
id|pidhash_pprev
op_assign
op_amp
id|p-&gt;pidhash_next
suffix:semicolon
)brace
op_star
id|htable
op_assign
id|p
suffix:semicolon
id|p-&gt;pidhash_pprev
op_assign
id|htable
suffix:semicolon
)brace
DECL|function|unhash_pid
r_static
r_inline
r_void
id|unhash_pid
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;pidhash_next
)paren
(brace
id|p-&gt;pidhash_next-&gt;pidhash_pprev
op_assign
id|p-&gt;pidhash_pprev
suffix:semicolon
)brace
op_star
id|p-&gt;pidhash_pprev
op_assign
id|p-&gt;pidhash_next
suffix:semicolon
)brace
DECL|function|find_task_by_pid
r_static
r_inline
r_struct
id|task_struct
op_star
id|find_task_by_pid
c_func
(paren
r_int
id|pid
)paren
(brace
r_struct
id|task_struct
op_star
id|p
comma
op_star
op_star
id|htable
op_assign
op_amp
id|pidhash
(braket
id|pid_hashfn
c_func
(paren
id|pid
)paren
)braket
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
op_star
id|htable
suffix:semicolon
id|p
op_logical_and
id|p-&gt;pid
op_ne
id|pid
suffix:semicolon
id|p
op_assign
id|p-&gt;pidhash_next
)paren
(brace
suffix:semicolon
)brace
r_return
id|p
suffix:semicolon
)brace
multiline_comment|/* per-UID process charging. */
r_extern
r_struct
id|user_struct
op_star
id|alloc_uid
c_func
(paren
id|uid_t
)paren
suffix:semicolon
r_extern
r_void
id|free_uid
c_func
(paren
r_struct
id|user_struct
op_star
)paren
suffix:semicolon
macro_line|#include &lt;asm/current.h&gt;
r_extern
r_int
r_int
id|itimer_ticks
suffix:semicolon
r_extern
r_int
r_int
id|itimer_next
suffix:semicolon
r_extern
r_void
id|do_timer
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_extern
r_int
r_int
op_star
id|prof_buffer
suffix:semicolon
r_extern
r_int
r_int
id|prof_len
suffix:semicolon
r_extern
r_int
r_int
id|prof_shift
suffix:semicolon
r_extern
r_void
id|FASTCALL
c_func
(paren
id|__wake_up
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
r_int
r_int
id|mode
comma
r_int
id|nr
)paren
)paren
suffix:semicolon
r_extern
r_void
id|FASTCALL
c_func
(paren
id|sleep_on
c_func
(paren
id|wait_queue_head_t
op_star
id|q
)paren
)paren
suffix:semicolon
r_extern
r_int
id|FASTCALL
c_func
(paren
id|sleep_on_timeout
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
r_int
r_int
id|timeout
)paren
)paren
suffix:semicolon
r_extern
r_void
id|FASTCALL
c_func
(paren
id|interruptible_sleep_on
c_func
(paren
id|wait_queue_head_t
op_star
id|q
)paren
)paren
suffix:semicolon
r_extern
r_int
id|FASTCALL
c_func
(paren
id|interruptible_sleep_on_timeout
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
r_int
r_int
id|timeout
)paren
)paren
suffix:semicolon
r_extern
r_int
id|FASTCALL
c_func
(paren
id|wake_up_process
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
)paren
suffix:semicolon
r_extern
r_void
id|FASTCALL
c_func
(paren
id|wake_up_forked_process
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
)paren
suffix:semicolon
r_extern
r_void
id|FASTCALL
c_func
(paren
id|sched_exit
c_func
(paren
id|task_t
op_star
id|p
)paren
)paren
suffix:semicolon
DECL|macro|wake_up
mdefine_line|#define wake_up(x)&t;&t;&t;__wake_up((x),TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE, 1)
DECL|macro|wake_up_nr
mdefine_line|#define wake_up_nr(x, nr)&t;&t;__wake_up((x),TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE, nr)
DECL|macro|wake_up_all
mdefine_line|#define wake_up_all(x)&t;&t;&t;__wake_up((x),TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE, 0)
DECL|macro|wake_up_interruptible
mdefine_line|#define wake_up_interruptible(x)&t;__wake_up((x),TASK_INTERRUPTIBLE, 1)
DECL|macro|wake_up_interruptible_nr
mdefine_line|#define wake_up_interruptible_nr(x, nr)&t;__wake_up((x),TASK_INTERRUPTIBLE, nr)
DECL|macro|wake_up_interruptible_all
mdefine_line|#define wake_up_interruptible_all(x)&t;__wake_up((x),TASK_INTERRUPTIBLE, 0)
id|asmlinkage
r_int
id|sys_wait4
c_func
(paren
id|pid_t
id|pid
comma
r_int
r_int
op_star
id|stat_addr
comma
r_int
id|options
comma
r_struct
id|rusage
op_star
id|ru
)paren
suffix:semicolon
r_extern
r_int
id|in_group_p
c_func
(paren
id|gid_t
)paren
suffix:semicolon
r_extern
r_int
id|in_egroup_p
c_func
(paren
id|gid_t
)paren
suffix:semicolon
r_extern
r_void
id|proc_caches_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|flush_signals
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|flush_signal_handlers
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|sig_exit
c_func
(paren
r_int
comma
r_int
comma
r_struct
id|siginfo
op_star
)paren
suffix:semicolon
r_extern
r_int
id|dequeue_signal
c_func
(paren
id|sigset_t
op_star
comma
id|siginfo_t
op_star
)paren
suffix:semicolon
r_extern
r_void
id|block_all_signals
c_func
(paren
r_int
(paren
op_star
id|notifier
)paren
(paren
r_void
op_star
id|priv
)paren
comma
r_void
op_star
id|priv
comma
id|sigset_t
op_star
id|mask
)paren
suffix:semicolon
r_extern
r_void
id|unblock_all_signals
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|send_sig_info
c_func
(paren
r_int
comma
r_struct
id|siginfo
op_star
comma
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_int
id|force_sig_info
c_func
(paren
r_int
comma
r_struct
id|siginfo
op_star
comma
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_int
id|kill_pg_info
c_func
(paren
r_int
comma
r_struct
id|siginfo
op_star
comma
id|pid_t
)paren
suffix:semicolon
r_extern
r_int
id|kill_sl_info
c_func
(paren
r_int
comma
r_struct
id|siginfo
op_star
comma
id|pid_t
)paren
suffix:semicolon
r_extern
r_int
id|kill_proc_info
c_func
(paren
r_int
comma
r_struct
id|siginfo
op_star
comma
id|pid_t
)paren
suffix:semicolon
r_extern
r_void
id|notify_parent
c_func
(paren
r_struct
id|task_struct
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_void
id|do_notify_parent
c_func
(paren
r_struct
id|task_struct
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_void
id|force_sig
c_func
(paren
r_int
comma
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_int
id|send_sig
c_func
(paren
r_int
comma
r_struct
id|task_struct
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|kill_pg
c_func
(paren
id|pid_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|kill_sl
c_func
(paren
id|pid_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|kill_proc
c_func
(paren
id|pid_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|do_sigaction
c_func
(paren
r_int
comma
r_const
r_struct
id|k_sigaction
op_star
comma
r_struct
id|k_sigaction
op_star
)paren
suffix:semicolon
r_extern
r_int
id|do_sigaltstack
c_func
(paren
r_const
id|stack_t
op_star
comma
id|stack_t
op_star
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * Re-calculate pending state from the set of locally pending&n; * signals, globally pending signals, and blocked signals.&n; */
DECL|function|has_pending_signals
r_static
r_inline
r_int
id|has_pending_signals
c_func
(paren
id|sigset_t
op_star
id|signal
comma
id|sigset_t
op_star
id|blocked
)paren
(brace
r_int
r_int
id|ready
suffix:semicolon
r_int
id|i
suffix:semicolon
r_switch
c_cond
(paren
id|_NSIG_WORDS
)paren
(brace
r_default
suffix:colon
(brace
)brace
r_for
c_loop
(paren
id|i
op_assign
id|_NSIG_WORDS
comma
id|ready
op_assign
l_int|0
suffix:semicolon
op_decrement
id|i
op_ge
l_int|0
suffix:semicolon
)paren
id|ready
op_or_assign
id|signal-&gt;sig
(braket
id|i
)braket
op_amp
op_complement
id|blocked-&gt;sig
(braket
id|i
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|ready
op_assign
id|signal-&gt;sig
(braket
l_int|3
)braket
op_amp
op_complement
id|blocked-&gt;sig
(braket
l_int|3
)braket
suffix:semicolon
id|ready
op_or_assign
id|signal-&gt;sig
(braket
l_int|2
)braket
op_amp
op_complement
id|blocked-&gt;sig
(braket
l_int|2
)braket
suffix:semicolon
id|ready
op_or_assign
id|signal-&gt;sig
(braket
l_int|1
)braket
op_amp
op_complement
id|blocked-&gt;sig
(braket
l_int|1
)braket
suffix:semicolon
id|ready
op_or_assign
id|signal-&gt;sig
(braket
l_int|0
)braket
op_amp
op_complement
id|blocked-&gt;sig
(braket
l_int|0
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|ready
op_assign
id|signal-&gt;sig
(braket
l_int|1
)braket
op_amp
op_complement
id|blocked-&gt;sig
(braket
l_int|1
)braket
suffix:semicolon
id|ready
op_or_assign
id|signal-&gt;sig
(braket
l_int|0
)braket
op_amp
op_complement
id|blocked-&gt;sig
(braket
l_int|0
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|ready
op_assign
id|signal-&gt;sig
(braket
l_int|0
)braket
op_amp
op_complement
id|blocked-&gt;sig
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_return
id|ready
op_ne
l_int|0
suffix:semicolon
)brace
multiline_comment|/* True if we are on the alternate signal stack.  */
DECL|function|on_sig_stack
r_static
r_inline
r_int
id|on_sig_stack
c_func
(paren
r_int
r_int
id|sp
)paren
(brace
r_return
(paren
id|sp
op_minus
id|current-&gt;sas_ss_sp
OL
id|current-&gt;sas_ss_size
)paren
suffix:semicolon
)brace
DECL|function|sas_ss_flags
r_static
r_inline
r_int
id|sas_ss_flags
c_func
(paren
r_int
r_int
id|sp
)paren
(brace
r_return
(paren
id|current-&gt;sas_ss_size
op_eq
l_int|0
ques
c_cond
id|SS_DISABLE
suffix:colon
id|on_sig_stack
c_func
(paren
id|sp
)paren
ques
c_cond
id|SS_ONSTACK
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_extern
r_int
id|request_irq
c_func
(paren
r_int
r_int
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
comma
r_const
r_char
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_extern
r_void
id|free_irq
c_func
(paren
r_int
r_int
comma
r_void
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * This has now become a routine instead of a macro, it sets a flag if&n; * it returns true (to do BSD-style accounting where the process is flagged&n; * if it uses root privs). The implication of this is that you should do&n; * normal permissions checks first, and check suser() last.&n; *&n; * [Dec 1997 -- Chris Evans]&n; * For correctness, the above considerations need to be extended to&n; * fsuser(). This is done, along with moving fsuser() checks to be&n; * last.&n; *&n; * These will be removed, but in the mean time, when the SECURE_NOROOT &n; * flag is set, uids don&squot;t grant privilege.&n; */
DECL|function|suser
r_static
r_inline
r_int
id|suser
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|issecure
c_func
(paren
id|SECURE_NOROOT
)paren
op_logical_and
id|current-&gt;euid
op_eq
l_int|0
)paren
(brace
id|current-&gt;flags
op_or_assign
id|PF_SUPERPRIV
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fsuser
r_static
r_inline
r_int
id|fsuser
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|issecure
c_func
(paren
id|SECURE_NOROOT
)paren
op_logical_and
id|current-&gt;fsuid
op_eq
l_int|0
)paren
(brace
id|current-&gt;flags
op_or_assign
id|PF_SUPERPRIV
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * capable() checks for a particular capability.  &n; * New privilege checks should use this interface, rather than suser() or&n; * fsuser(). See include/linux/capability.h for defined capabilities.&n; */
DECL|function|capable
r_static
r_inline
r_int
id|capable
c_func
(paren
r_int
id|cap
)paren
(brace
macro_line|#if 1 /* ok now */
r_if
c_cond
(paren
id|cap_raised
c_func
(paren
id|current-&gt;cap_effective
comma
id|cap
)paren
)paren
macro_line|#else
r_if
c_cond
(paren
id|cap_is_fs_cap
c_func
(paren
id|cap
)paren
ques
c_cond
id|current-&gt;fsuid
op_eq
l_int|0
suffix:colon
id|current-&gt;euid
op_eq
l_int|0
)paren
macro_line|#endif
(brace
id|current-&gt;flags
op_or_assign
id|PF_SUPERPRIV
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Routines for handling mm_structs&n; */
r_extern
r_struct
id|mm_struct
op_star
id|mm_alloc
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_struct
id|mm_struct
op_star
id|start_lazy_tlb
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|end_lazy_tlb
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
suffix:semicolon
multiline_comment|/* mmdrop drops the mm and the page tables */
r_extern
r_inline
r_void
id|FASTCALL
c_func
(paren
id|__mmdrop
c_func
(paren
r_struct
id|mm_struct
op_star
)paren
)paren
suffix:semicolon
DECL|function|mmdrop
r_static
r_inline
r_void
id|mmdrop
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|mm-&gt;mm_count
)paren
)paren
id|__mmdrop
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
multiline_comment|/* mmput gets rid of the mappings and all user-space */
r_extern
r_void
id|mmput
c_func
(paren
r_struct
id|mm_struct
op_star
)paren
suffix:semicolon
multiline_comment|/* Remove the current tasks stale references to the old mm_struct */
r_extern
r_void
id|mm_release
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * Routines for handling the fd arrays&n; */
r_extern
r_struct
id|file
op_star
op_star
id|alloc_fd_array
c_func
(paren
r_int
)paren
suffix:semicolon
r_extern
r_int
id|expand_fd_array
c_func
(paren
r_struct
id|files_struct
op_star
comma
r_int
id|nr
)paren
suffix:semicolon
r_extern
r_void
id|free_fd_array
c_func
(paren
r_struct
id|file
op_star
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
id|fd_set
op_star
id|alloc_fdset
c_func
(paren
r_int
)paren
suffix:semicolon
r_extern
r_int
id|expand_fdset
c_func
(paren
r_struct
id|files_struct
op_star
comma
r_int
id|nr
)paren
suffix:semicolon
r_extern
r_void
id|free_fdset
c_func
(paren
id|fd_set
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|copy_thread
c_func
(paren
r_int
comma
r_int
r_int
comma
r_int
r_int
comma
r_int
r_int
comma
r_struct
id|task_struct
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_extern
r_void
id|flush_thread
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|exit_thread
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|exit_mm
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|exit_files
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|exit_sighand
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|reparent_to_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|daemonize
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|task_t
op_star
id|child_reaper
suffix:semicolon
r_extern
r_int
id|do_execve
c_func
(paren
r_char
op_star
comma
r_char
op_star
op_star
comma
r_char
op_star
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_extern
r_struct
id|task_struct
op_star
id|do_fork
c_func
(paren
r_int
r_int
comma
r_int
r_int
comma
r_struct
id|pt_regs
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_void
id|FASTCALL
c_func
(paren
id|add_wait_queue
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
id|wait_queue_t
op_star
id|wait
)paren
)paren
suffix:semicolon
r_extern
r_void
id|FASTCALL
c_func
(paren
id|add_wait_queue_exclusive
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
id|wait_queue_t
op_star
id|wait
)paren
)paren
suffix:semicolon
r_extern
r_void
id|FASTCALL
c_func
(paren
id|remove_wait_queue
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
id|wait_queue_t
op_star
id|wait
)paren
)paren
suffix:semicolon
r_extern
r_void
id|wait_task_inactive
c_func
(paren
id|task_t
op_star
id|p
)paren
suffix:semicolon
r_extern
r_void
id|kick_if_running
c_func
(paren
id|task_t
op_star
id|p
)paren
suffix:semicolon
DECL|macro|__wait_event
mdefine_line|#define __wait_event(wq, condition) &t;&t;&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;wait_queue_t __wait;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;init_waitqueue_entry(&amp;__wait, current);&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;add_wait_queue(&amp;wq, &amp;__wait);&t;&t;&t;&t;&t;&bslash;&n;&t;for (;;) {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;set_current_state(TASK_UNINTERRUPTIBLE);&t;&t;&bslash;&n;&t;&t;if (condition)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;schedule();&t;&t;&t;&t;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;current-&gt;state = TASK_RUNNING;&t;&t;&t;&t;&t;&bslash;&n;&t;remove_wait_queue(&amp;wq, &amp;__wait);&t;&t;&t;&t;&bslash;&n;} while (0)
DECL|macro|wait_event
mdefine_line|#define wait_event(wq, condition) &t;&t;&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (condition)&t; &t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;__wait_event(wq, condition);&t;&t;&t;&t;&t;&bslash;&n;} while (0)
DECL|macro|__wait_event_interruptible
mdefine_line|#define __wait_event_interruptible(wq, condition, ret)&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;wait_queue_t __wait;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;init_waitqueue_entry(&amp;__wait, current);&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;add_wait_queue(&amp;wq, &amp;__wait);&t;&t;&t;&t;&t;&bslash;&n;&t;for (;;) {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;set_current_state(TASK_INTERRUPTIBLE);&t;&t;&t;&bslash;&n;&t;&t;if (condition)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (!signal_pending(current)) {&t;&t;&t;&t;&bslash;&n;&t;&t;&t;schedule();&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;continue;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;ret = -ERESTARTSYS;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;current-&gt;state = TASK_RUNNING;&t;&t;&t;&t;&t;&bslash;&n;&t;remove_wait_queue(&amp;wq, &amp;__wait);&t;&t;&t;&t;&bslash;&n;} while (0)
DECL|macro|wait_event_interruptible
mdefine_line|#define wait_event_interruptible(wq, condition)&t;&t;&t;&t;&bslash;&n;({&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;int __ret = 0;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (!(condition))&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;__wait_event_interruptible(wq, condition, __ret);&t;&bslash;&n;&t;__ret;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;})
DECL|macro|remove_parent
mdefine_line|#define remove_parent(p)&t;list_del_init(&amp;(p)-&gt;sibling)
DECL|macro|add_parent
mdefine_line|#define add_parent(p, parent)&t;list_add_tail(&amp;(p)-&gt;sibling,&amp;(parent)-&gt;children)
DECL|macro|REMOVE_LINKS
mdefine_line|#define REMOVE_LINKS(p) do {&t;&t;&t;&t;&bslash;&n;&t;list_del_init(&amp;(p)-&gt;tasks);&t;&t;&t;&bslash;&n;&t;remove_parent(p);&t;&t;&t;&t;&bslash;&n;&t;} while (0)
DECL|macro|SET_LINKS
mdefine_line|#define SET_LINKS(p) do {&t;&t;&t;&t;&bslash;&n;&t;list_add_tail(&amp;(p)-&gt;tasks,&amp;init_task.tasks);&t;&bslash;&n;&t;add_parent(p, (p)-&gt;parent);&t;&t;&t;&bslash;&n;&t;} while (0)
DECL|function|eldest_child
r_static
r_inline
r_struct
id|task_struct
op_star
id|eldest_child
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|p-&gt;children
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|list_entry
c_func
(paren
id|p-&gt;children.next
comma
r_struct
id|task_struct
comma
id|sibling
)paren
suffix:semicolon
)brace
DECL|function|youngest_child
r_static
r_inline
r_struct
id|task_struct
op_star
id|youngest_child
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|p-&gt;children
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|list_entry
c_func
(paren
id|p-&gt;children.prev
comma
r_struct
id|task_struct
comma
id|sibling
)paren
suffix:semicolon
)brace
DECL|function|older_sibling
r_static
r_inline
r_struct
id|task_struct
op_star
id|older_sibling
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;sibling.prev
op_eq
op_amp
id|p-&gt;parent-&gt;children
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|list_entry
c_func
(paren
id|p-&gt;sibling.prev
comma
r_struct
id|task_struct
comma
id|sibling
)paren
suffix:semicolon
)brace
DECL|function|younger_sibling
r_static
r_inline
r_struct
id|task_struct
op_star
id|younger_sibling
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;sibling.next
op_eq
op_amp
id|p-&gt;parent-&gt;children
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|list_entry
c_func
(paren
id|p-&gt;sibling.next
comma
r_struct
id|task_struct
comma
id|sibling
)paren
suffix:semicolon
)brace
DECL|macro|next_task
mdefine_line|#define next_task(p)&t;list_entry((p)-&gt;tasks.next, struct task_struct, tasks)
DECL|macro|prev_task
mdefine_line|#define prev_task(p)&t;list_entry((p)-&gt;tasks.prev, struct task_struct, tasks)
DECL|macro|for_each_task
mdefine_line|#define for_each_task(p) &bslash;&n;&t;for (p = &amp;init_task ; (p = next_task(p)) != &amp;init_task ; )
DECL|macro|for_each_thread
mdefine_line|#define for_each_thread(task) &bslash;&n;&t;for (task = next_thread(current) ; task != current ; task = next_thread(task))
DECL|macro|next_thread
mdefine_line|#define next_thread(p) &bslash;&n;&t;list_entry((p)-&gt;thread_group.next, struct task_struct, thread_group)
DECL|macro|thread_group_leader
mdefine_line|#define thread_group_leader(p)&t;(p-&gt;pid == p-&gt;tgid)
r_extern
r_void
id|unhash_process
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
suffix:semicolon
multiline_comment|/* Protects -&gt;fs, -&gt;files, -&gt;mm, and synchronises with wait4().  Nests inside tasklist_lock */
DECL|function|task_lock
r_static
r_inline
r_void
id|task_lock
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|p-&gt;alloc_lock
)paren
suffix:semicolon
)brace
DECL|function|task_unlock
r_static
r_inline
r_void
id|task_unlock
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|p-&gt;alloc_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* write full pathname into buffer and return start of pathname */
DECL|function|d_path
r_static
r_inline
r_char
op_star
id|d_path
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|vfsmount
op_star
id|vfsmnt
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
)paren
(brace
r_char
op_star
id|res
suffix:semicolon
r_struct
id|vfsmount
op_star
id|rootmnt
suffix:semicolon
r_struct
id|dentry
op_star
id|root
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|current-&gt;fs-&gt;lock
)paren
suffix:semicolon
id|rootmnt
op_assign
id|mntget
c_func
(paren
id|current-&gt;fs-&gt;rootmnt
)paren
suffix:semicolon
id|root
op_assign
id|dget
c_func
(paren
id|current-&gt;fs-&gt;root
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|current-&gt;fs-&gt;lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|res
op_assign
id|__d_path
c_func
(paren
id|dentry
comma
id|vfsmnt
comma
id|root
comma
id|rootmnt
comma
id|buf
comma
id|buflen
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|dput
c_func
(paren
id|root
)paren
suffix:semicolon
id|mntput
c_func
(paren
id|rootmnt
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/* set thread flags in other task&squot;s structures&n; * - see asm/thread_info.h for TIF_xxxx flags available&n; */
DECL|function|set_tsk_thread_flag
r_static
r_inline
r_void
id|set_tsk_thread_flag
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
id|flag
)paren
(brace
id|set_ti_thread_flag
c_func
(paren
id|tsk-&gt;thread_info
comma
id|flag
)paren
suffix:semicolon
)brace
DECL|function|clear_tsk_thread_flag
r_static
r_inline
r_void
id|clear_tsk_thread_flag
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
id|flag
)paren
(brace
id|clear_ti_thread_flag
c_func
(paren
id|tsk-&gt;thread_info
comma
id|flag
)paren
suffix:semicolon
)brace
DECL|function|test_and_set_tsk_thread_flag
r_static
r_inline
r_int
id|test_and_set_tsk_thread_flag
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
id|flag
)paren
(brace
r_return
id|test_and_set_ti_thread_flag
c_func
(paren
id|tsk-&gt;thread_info
comma
id|flag
)paren
suffix:semicolon
)brace
DECL|function|test_and_clear_tsk_thread_flag
r_static
r_inline
r_int
id|test_and_clear_tsk_thread_flag
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
id|flag
)paren
(brace
r_return
id|test_and_clear_ti_thread_flag
c_func
(paren
id|tsk-&gt;thread_info
comma
id|flag
)paren
suffix:semicolon
)brace
DECL|function|test_tsk_thread_flag
r_static
r_inline
r_int
id|test_tsk_thread_flag
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
id|flag
)paren
(brace
r_return
id|test_ti_thread_flag
c_func
(paren
id|tsk-&gt;thread_info
comma
id|flag
)paren
suffix:semicolon
)brace
DECL|function|set_tsk_need_resched
r_static
r_inline
r_void
id|set_tsk_need_resched
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
id|set_tsk_thread_flag
c_func
(paren
id|tsk
comma
id|TIF_NEED_RESCHED
)paren
suffix:semicolon
)brace
DECL|function|clear_tsk_need_resched
r_static
r_inline
r_void
id|clear_tsk_need_resched
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
id|clear_tsk_thread_flag
c_func
(paren
id|tsk
comma
id|TIF_NEED_RESCHED
)paren
suffix:semicolon
)brace
DECL|function|signal_pending
r_static
r_inline
r_int
id|signal_pending
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_return
id|unlikely
c_func
(paren
id|test_tsk_thread_flag
c_func
(paren
id|p
comma
id|TIF_SIGPENDING
)paren
)paren
suffix:semicolon
)brace
DECL|function|need_resched
r_static
r_inline
r_int
id|need_resched
c_func
(paren
r_void
)paren
(brace
r_return
id|unlikely
c_func
(paren
id|test_thread_flag
c_func
(paren
id|TIF_NEED_RESCHED
)paren
)paren
suffix:semicolon
)brace
DECL|function|cond_resched
r_static
r_inline
r_void
id|cond_resched
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|need_resched
c_func
(paren
)paren
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Reevaluate whether the task has signals pending delivery.&n;   This is required every time the blocked sigset_t changes.&n;   Athread cathreaders should have t-&gt;sigmask_lock.  */
DECL|function|recalc_sigpending_tsk
r_static
r_inline
r_void
id|recalc_sigpending_tsk
c_func
(paren
r_struct
id|task_struct
op_star
id|t
)paren
(brace
r_if
c_cond
(paren
id|has_pending_signals
c_func
(paren
op_amp
id|t-&gt;pending.signal
comma
op_amp
id|t-&gt;blocked
)paren
)paren
id|set_tsk_thread_flag
c_func
(paren
id|t
comma
id|TIF_SIGPENDING
)paren
suffix:semicolon
r_else
id|clear_tsk_thread_flag
c_func
(paren
id|t
comma
id|TIF_SIGPENDING
)paren
suffix:semicolon
)brace
DECL|function|recalc_sigpending
r_static
r_inline
r_void
id|recalc_sigpending
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|has_pending_signals
c_func
(paren
op_amp
id|current-&gt;pending.signal
comma
op_amp
id|current-&gt;blocked
)paren
)paren
id|set_thread_flag
c_func
(paren
id|TIF_SIGPENDING
)paren
suffix:semicolon
r_else
id|clear_thread_flag
c_func
(paren
id|TIF_SIGPENDING
)paren
suffix:semicolon
)brace
macro_line|#endif /* __KERNEL__ */
macro_line|#endif
eof
