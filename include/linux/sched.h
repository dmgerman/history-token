macro_line|#ifndef _LINUX_SCHED_H
DECL|macro|_LINUX_SCHED_H
mdefine_line|#define _LINUX_SCHED_H
macro_line|#include &lt;asm/param.h&gt;&t;/* for HZ */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/capability.h&gt;
macro_line|#include &lt;linux/threads.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &lt;linux/jiffies.h&gt;
macro_line|#include &lt;linux/rbtree.h&gt;
macro_line|#include &lt;linux/thread_info.h&gt;
macro_line|#include &lt;linux/cpumask.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#include &lt;asm/cputime.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/sem.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/securebits.h&gt;
macro_line|#include &lt;linux/fs_struct.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/pid.h&gt;
macro_line|#include &lt;linux/percpu.h&gt;
macro_line|#include &lt;linux/topology.h&gt;
r_struct
id|exec_domain
suffix:semicolon
multiline_comment|/*&n; * cloning flags:&n; */
DECL|macro|CSIGNAL
mdefine_line|#define CSIGNAL&t;&t;0x000000ff&t;/* signal mask to be sent at exit */
DECL|macro|CLONE_VM
mdefine_line|#define CLONE_VM&t;0x00000100&t;/* set if VM shared between processes */
DECL|macro|CLONE_FS
mdefine_line|#define CLONE_FS&t;0x00000200&t;/* set if fs info shared between processes */
DECL|macro|CLONE_FILES
mdefine_line|#define CLONE_FILES&t;0x00000400&t;/* set if open files shared between processes */
DECL|macro|CLONE_SIGHAND
mdefine_line|#define CLONE_SIGHAND&t;0x00000800&t;/* set if signal handlers and blocked signals shared */
DECL|macro|CLONE_PTRACE
mdefine_line|#define CLONE_PTRACE&t;0x00002000&t;/* set if we want to let tracing continue on the child too */
DECL|macro|CLONE_VFORK
mdefine_line|#define CLONE_VFORK&t;0x00004000&t;/* set if the parent wants the child to wake it up on mm_release */
DECL|macro|CLONE_PARENT
mdefine_line|#define CLONE_PARENT&t;0x00008000&t;/* set if we want to have the same parent as the cloner */
DECL|macro|CLONE_THREAD
mdefine_line|#define CLONE_THREAD&t;0x00010000&t;/* Same thread group? */
DECL|macro|CLONE_NEWNS
mdefine_line|#define CLONE_NEWNS&t;0x00020000&t;/* New namespace group? */
DECL|macro|CLONE_SYSVSEM
mdefine_line|#define CLONE_SYSVSEM&t;0x00040000&t;/* share system V SEM_UNDO semantics */
DECL|macro|CLONE_SETTLS
mdefine_line|#define CLONE_SETTLS&t;0x00080000&t;/* create a new TLS for the child */
DECL|macro|CLONE_PARENT_SETTID
mdefine_line|#define CLONE_PARENT_SETTID&t;0x00100000&t;/* set the TID in the parent */
DECL|macro|CLONE_CHILD_CLEARTID
mdefine_line|#define CLONE_CHILD_CLEARTID&t;0x00200000&t;/* clear the TID in the child */
DECL|macro|CLONE_DETACHED
mdefine_line|#define CLONE_DETACHED&t;&t;0x00400000&t;/* Unused, ignored */
DECL|macro|CLONE_UNTRACED
mdefine_line|#define CLONE_UNTRACED&t;&t;0x00800000&t;/* set if the tracing process can&squot;t force CLONE_PTRACE on this clone */
DECL|macro|CLONE_CHILD_SETTID
mdefine_line|#define CLONE_CHILD_SETTID&t;0x01000000&t;/* set the TID in the child */
DECL|macro|CLONE_STOPPED
mdefine_line|#define CLONE_STOPPED&t;&t;0x02000000&t;/* Start in stopped state */
multiline_comment|/*&n; * List of flags we want to share for kernel threads,&n; * if only because they are not used by them anyway.&n; */
DECL|macro|CLONE_KERNEL
mdefine_line|#define CLONE_KERNEL&t;(CLONE_FS | CLONE_FILES | CLONE_SIGHAND)
multiline_comment|/*&n; * These are the constant used to fake the fixed-point load-average&n; * counting. Some notes:&n; *  - 11 bit fractions expand to 22 bits by the multiplies: this gives&n; *    a load-average precision of 10 bits integer + 11 bits fractional&n; *  - if you want to count load-averages more often, you need more&n; *    precision, or rounding will get you. With 2-second counting freq,&n; *    the EXP_n values would be 1981, 2034 and 2043 if still using only&n; *    11 bit fractions.&n; */
r_extern
r_int
r_int
id|avenrun
(braket
)braket
suffix:semicolon
multiline_comment|/* Load averages */
DECL|macro|FSHIFT
mdefine_line|#define FSHIFT&t;&t;11&t;&t;/* nr of bits of precision */
DECL|macro|FIXED_1
mdefine_line|#define FIXED_1&t;&t;(1&lt;&lt;FSHIFT)&t;/* 1.0 as fixed-point */
DECL|macro|LOAD_FREQ
mdefine_line|#define LOAD_FREQ&t;(5*HZ)&t;&t;/* 5 sec intervals */
DECL|macro|EXP_1
mdefine_line|#define EXP_1&t;&t;1884&t;&t;/* 1/exp(5sec/1min) as fixed-point */
DECL|macro|EXP_5
mdefine_line|#define EXP_5&t;&t;2014&t;&t;/* 1/exp(5sec/5min) */
DECL|macro|EXP_15
mdefine_line|#define EXP_15&t;&t;2037&t;&t;/* 1/exp(5sec/15min) */
DECL|macro|CALC_LOAD
mdefine_line|#define CALC_LOAD(load,exp,n) &bslash;&n;&t;load *= exp; &bslash;&n;&t;load += n*(FIXED_1-exp); &bslash;&n;&t;load &gt;&gt;= FSHIFT;
r_extern
r_int
r_int
id|total_forks
suffix:semicolon
r_extern
r_int
id|nr_threads
suffix:semicolon
r_extern
r_int
id|last_pid
suffix:semicolon
id|DECLARE_PER_CPU
c_func
(paren
r_int
r_int
comma
id|process_counts
)paren
suffix:semicolon
r_extern
r_int
id|nr_processes
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
r_int
id|nr_running
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
r_int
id|nr_uninterruptible
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
r_int
id|nr_iowait
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/param.h&gt;
macro_line|#include &lt;linux/resource.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
DECL|macro|TASK_RUNNING
mdefine_line|#define TASK_RUNNING&t;&t;0
DECL|macro|TASK_INTERRUPTIBLE
mdefine_line|#define TASK_INTERRUPTIBLE&t;1
DECL|macro|TASK_UNINTERRUPTIBLE
mdefine_line|#define TASK_UNINTERRUPTIBLE&t;2
DECL|macro|TASK_STOPPED
mdefine_line|#define TASK_STOPPED&t;&t;4
DECL|macro|TASK_TRACED
mdefine_line|#define TASK_TRACED&t;&t;8
DECL|macro|EXIT_ZOMBIE
mdefine_line|#define EXIT_ZOMBIE&t;&t;16
DECL|macro|EXIT_DEAD
mdefine_line|#define EXIT_DEAD&t;&t;32
DECL|macro|__set_task_state
mdefine_line|#define __set_task_state(tsk, state_value)&t;&t;&bslash;&n;&t;do { (tsk)-&gt;state = (state_value); } while (0)
DECL|macro|set_task_state
mdefine_line|#define set_task_state(tsk, state_value)&t;&t;&bslash;&n;&t;set_mb((tsk)-&gt;state, (state_value))
DECL|macro|__set_current_state
mdefine_line|#define __set_current_state(state_value)&t;&t;&t;&bslash;&n;&t;do { current-&gt;state = (state_value); } while (0)
DECL|macro|set_current_state
mdefine_line|#define set_current_state(state_value)&t;&t;&bslash;&n;&t;set_mb(current-&gt;state, (state_value))
multiline_comment|/* Task command name length */
DECL|macro|TASK_COMM_LEN
mdefine_line|#define TASK_COMM_LEN 16
multiline_comment|/*&n; * Scheduling policies&n; */
DECL|macro|SCHED_NORMAL
mdefine_line|#define SCHED_NORMAL&t;&t;0
DECL|macro|SCHED_FIFO
mdefine_line|#define SCHED_FIFO&t;&t;1
DECL|macro|SCHED_RR
mdefine_line|#define SCHED_RR&t;&t;2
DECL|struct|sched_param
r_struct
id|sched_param
(brace
DECL|member|sched_priority
r_int
id|sched_priority
suffix:semicolon
)brace
suffix:semicolon
macro_line|#ifdef __KERNEL__
macro_line|#include &lt;linux/spinlock.h&gt;
multiline_comment|/*&n; * This serializes &quot;schedule()&quot; and also protects&n; * the run-queue from deletions/modifications (but&n; * _adding_ to the beginning of the run-queue has&n; * a separate lock).&n; */
r_extern
id|rwlock_t
id|tasklist_lock
suffix:semicolon
r_extern
id|spinlock_t
id|mmlist_lock
suffix:semicolon
DECL|typedef|task_t
r_typedef
r_struct
id|task_struct
id|task_t
suffix:semicolon
r_extern
r_void
id|sched_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|sched_init_smp
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|init_idle
c_func
(paren
id|task_t
op_star
id|idle
comma
r_int
id|cpu
)paren
suffix:semicolon
r_extern
id|cpumask_t
id|nohz_cpu_mask
suffix:semicolon
r_extern
r_void
id|show_state
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|show_regs
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * TASK is a pointer to the task whose backtrace we want to see (or NULL for current&n; * task), SP is the stack pointer of the first frame that should be shown in the back&n; * trace (or NULL if the entire call-chain of the task should be shown).&n; */
r_extern
r_void
id|show_stack
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
r_int
op_star
id|sp
)paren
suffix:semicolon
r_void
id|io_schedule
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|io_schedule_timeout
c_func
(paren
r_int
id|timeout
)paren
suffix:semicolon
r_extern
r_void
id|cpu_init
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|trap_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|update_process_times
c_func
(paren
r_int
id|user
)paren
suffix:semicolon
r_extern
r_void
id|scheduler_tick
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
r_int
id|cache_decay_ticks
suffix:semicolon
multiline_comment|/* Attach to any functions which should be ignored in wchan output. */
DECL|macro|__sched
mdefine_line|#define __sched&t;&t;__attribute__((__section__(&quot;.sched.text&quot;)))
multiline_comment|/* Is this address in the __sched functions? */
r_extern
r_int
id|in_sched_functions
c_func
(paren
r_int
r_int
id|addr
)paren
suffix:semicolon
DECL|macro|MAX_SCHEDULE_TIMEOUT
mdefine_line|#define&t;MAX_SCHEDULE_TIMEOUT&t;LONG_MAX
r_extern
r_int
r_int
id|FASTCALL
c_func
(paren
id|schedule_timeout
c_func
(paren
r_int
r_int
id|timeout
)paren
)paren
suffix:semicolon
id|asmlinkage
r_void
id|schedule
c_func
(paren
r_void
)paren
suffix:semicolon
r_struct
r_namespace
suffix:semicolon
multiline_comment|/* Maximum number of active map areas.. This is a random (large) number */
DECL|macro|DEFAULT_MAX_MAP_COUNT
mdefine_line|#define DEFAULT_MAX_MAP_COUNT&t;65536
r_extern
r_int
id|sysctl_max_map_count
suffix:semicolon
macro_line|#include &lt;linux/aio.h&gt;
r_extern
r_int
r_int
id|arch_get_unmapped_area
c_func
(paren
r_struct
id|file
op_star
comma
r_int
r_int
comma
r_int
r_int
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_int
r_int
id|arch_get_unmapped_area_topdown
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|len
comma
r_int
r_int
id|pgoff
comma
r_int
r_int
id|flags
)paren
suffix:semicolon
r_extern
r_void
id|arch_unmap_area
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|area
)paren
suffix:semicolon
r_extern
r_void
id|arch_unmap_area_topdown
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|area
)paren
suffix:semicolon
DECL|struct|mm_struct
r_struct
id|mm_struct
(brace
DECL|member|mmap
r_struct
id|vm_area_struct
op_star
id|mmap
suffix:semicolon
multiline_comment|/* list of VMAs */
DECL|member|mm_rb
r_struct
id|rb_root
id|mm_rb
suffix:semicolon
DECL|member|mmap_cache
r_struct
id|vm_area_struct
op_star
id|mmap_cache
suffix:semicolon
multiline_comment|/* last find_vma result */
DECL|member|get_unmapped_area
r_int
r_int
(paren
op_star
id|get_unmapped_area
)paren
(paren
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|len
comma
r_int
r_int
id|pgoff
comma
r_int
r_int
id|flags
)paren
suffix:semicolon
DECL|member|unmap_area
r_void
(paren
op_star
id|unmap_area
)paren
(paren
r_struct
id|vm_area_struct
op_star
id|area
)paren
suffix:semicolon
DECL|member|mmap_base
r_int
r_int
id|mmap_base
suffix:semicolon
multiline_comment|/* base of mmap area */
DECL|member|free_area_cache
r_int
r_int
id|free_area_cache
suffix:semicolon
multiline_comment|/* first hole */
DECL|member|pgd
id|pgd_t
op_star
id|pgd
suffix:semicolon
DECL|member|mm_users
id|atomic_t
id|mm_users
suffix:semicolon
multiline_comment|/* How many users with user space? */
DECL|member|mm_count
id|atomic_t
id|mm_count
suffix:semicolon
multiline_comment|/* How many references to &quot;struct mm_struct&quot; (users count as 1) */
DECL|member|map_count
r_int
id|map_count
suffix:semicolon
multiline_comment|/* number of VMAs */
DECL|member|mmap_sem
r_struct
id|rw_semaphore
id|mmap_sem
suffix:semicolon
DECL|member|page_table_lock
id|spinlock_t
id|page_table_lock
suffix:semicolon
multiline_comment|/* Protects page tables, mm-&gt;rss, mm-&gt;anon_rss */
DECL|member|mmlist
r_struct
id|list_head
id|mmlist
suffix:semicolon
multiline_comment|/* List of maybe swapped mm&squot;s.  These are globally strung&n;&t;&t;&t;&t;&t;&t; * together off init_mm.mmlist, and are protected&n;&t;&t;&t;&t;&t;&t; * by mmlist_lock&n;&t;&t;&t;&t;&t;&t; */
DECL|member|start_code
DECL|member|end_code
DECL|member|start_data
DECL|member|end_data
r_int
r_int
id|start_code
comma
id|end_code
comma
id|start_data
comma
id|end_data
suffix:semicolon
DECL|member|start_brk
DECL|member|brk
DECL|member|start_stack
r_int
r_int
id|start_brk
comma
id|brk
comma
id|start_stack
suffix:semicolon
DECL|member|arg_start
DECL|member|arg_end
DECL|member|env_start
DECL|member|env_end
r_int
r_int
id|arg_start
comma
id|arg_end
comma
id|env_start
comma
id|env_end
suffix:semicolon
DECL|member|rss
DECL|member|anon_rss
DECL|member|total_vm
DECL|member|locked_vm
DECL|member|shared_vm
r_int
r_int
id|rss
comma
id|anon_rss
comma
id|total_vm
comma
id|locked_vm
comma
id|shared_vm
suffix:semicolon
DECL|member|exec_vm
DECL|member|stack_vm
DECL|member|reserved_vm
DECL|member|def_flags
DECL|member|nr_ptes
r_int
r_int
id|exec_vm
comma
id|stack_vm
comma
id|reserved_vm
comma
id|def_flags
comma
id|nr_ptes
suffix:semicolon
DECL|member|saved_auxv
r_int
r_int
id|saved_auxv
(braket
l_int|42
)braket
suffix:semicolon
multiline_comment|/* for /proc/PID/auxv */
DECL|member|dumpable
r_int
id|dumpable
suffix:colon
l_int|1
suffix:semicolon
DECL|member|cpu_vm_mask
id|cpumask_t
id|cpu_vm_mask
suffix:semicolon
multiline_comment|/* Architecture-specific MM context */
DECL|member|context
id|mm_context_t
id|context
suffix:semicolon
multiline_comment|/* Token based thrashing protection. */
DECL|member|swap_token_time
r_int
r_int
id|swap_token_time
suffix:semicolon
DECL|member|recent_pagein
r_char
id|recent_pagein
suffix:semicolon
multiline_comment|/* coredumping support */
DECL|member|core_waiters
r_int
id|core_waiters
suffix:semicolon
DECL|member|core_startup_done
DECL|member|core_done
r_struct
id|completion
op_star
id|core_startup_done
comma
id|core_done
suffix:semicolon
multiline_comment|/* aio bits */
DECL|member|ioctx_list_lock
id|rwlock_t
id|ioctx_list_lock
suffix:semicolon
DECL|member|ioctx_list
r_struct
id|kioctx
op_star
id|ioctx_list
suffix:semicolon
DECL|member|default_kioctx
r_struct
id|kioctx
id|default_kioctx
suffix:semicolon
DECL|member|hiwater_rss
r_int
r_int
id|hiwater_rss
suffix:semicolon
multiline_comment|/* High-water RSS usage */
DECL|member|hiwater_vm
r_int
r_int
id|hiwater_vm
suffix:semicolon
multiline_comment|/* High-water virtual memory usage */
)brace
suffix:semicolon
DECL|struct|sighand_struct
r_struct
id|sighand_struct
(brace
DECL|member|count
id|atomic_t
id|count
suffix:semicolon
DECL|member|action
r_struct
id|k_sigaction
id|action
(braket
id|_NSIG
)braket
suffix:semicolon
DECL|member|siglock
id|spinlock_t
id|siglock
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * NOTE! &quot;signal_struct&quot; does not have it&squot;s own&n; * locking, because a shared signal_struct always&n; * implies a shared sighand_struct, so locking&n; * sighand_struct is always a proper superset of&n; * the locking of signal_struct.&n; */
DECL|struct|signal_struct
r_struct
id|signal_struct
(brace
DECL|member|count
id|atomic_t
id|count
suffix:semicolon
DECL|member|live
id|atomic_t
id|live
suffix:semicolon
DECL|member|wait_chldexit
id|wait_queue_head_t
id|wait_chldexit
suffix:semicolon
multiline_comment|/* for wait4() */
multiline_comment|/* current thread group signal load-balancing target: */
DECL|member|curr_target
id|task_t
op_star
id|curr_target
suffix:semicolon
multiline_comment|/* shared signal handling: */
DECL|member|shared_pending
r_struct
id|sigpending
id|shared_pending
suffix:semicolon
multiline_comment|/* thread group exit support */
DECL|member|group_exit_code
r_int
id|group_exit_code
suffix:semicolon
multiline_comment|/* overloaded:&n;&t; * - notify group_exit_task when -&gt;count is equal to notify_count&n;&t; * - everyone except group_exit_task is stopped during signal delivery&n;&t; *   of fatal signals, group_exit_task processes the signal.&n;&t; */
DECL|member|group_exit_task
r_struct
id|task_struct
op_star
id|group_exit_task
suffix:semicolon
DECL|member|notify_count
r_int
id|notify_count
suffix:semicolon
multiline_comment|/* thread group stop support, overloads group_exit_code too */
DECL|member|group_stop_count
r_int
id|group_stop_count
suffix:semicolon
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* see SIGNAL_* flags below */
multiline_comment|/* POSIX.1b Interval Timers */
DECL|member|posix_timers
r_struct
id|list_head
id|posix_timers
suffix:semicolon
multiline_comment|/* job control IDs */
DECL|member|pgrp
id|pid_t
id|pgrp
suffix:semicolon
DECL|member|tty_old_pgrp
id|pid_t
id|tty_old_pgrp
suffix:semicolon
DECL|member|session
id|pid_t
id|session
suffix:semicolon
multiline_comment|/* boolean value for session group leader */
DECL|member|leader
r_int
id|leader
suffix:semicolon
DECL|member|tty
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
multiline_comment|/* NULL if no tty */
multiline_comment|/*&n;&t; * Cumulative resource counters for dead threads in the group,&n;&t; * and for reaped dead child processes forked by this group.&n;&t; * Live threads maintain their own counters and add to these&n;&t; * in __exit_signal, except for the group leader.&n;&t; */
DECL|member|utime
DECL|member|stime
DECL|member|cutime
DECL|member|cstime
id|cputime_t
id|utime
comma
id|stime
comma
id|cutime
comma
id|cstime
suffix:semicolon
DECL|member|nvcsw
DECL|member|nivcsw
DECL|member|cnvcsw
DECL|member|cnivcsw
r_int
r_int
id|nvcsw
comma
id|nivcsw
comma
id|cnvcsw
comma
id|cnivcsw
suffix:semicolon
DECL|member|min_flt
DECL|member|maj_flt
DECL|member|cmin_flt
DECL|member|cmaj_flt
r_int
r_int
id|min_flt
comma
id|maj_flt
comma
id|cmin_flt
comma
id|cmaj_flt
suffix:semicolon
multiline_comment|/*&n;&t; * We don&squot;t bother to synchronize most readers of this at all,&n;&t; * because there is no reader checking a limit that actually needs&n;&t; * to get both rlim_cur and rlim_max atomically, and either one&n;&t; * alone is a single word that can safely be read normally.&n;&t; * getrlimit/setrlimit use task_lock(current-&gt;group_leader) to&n;&t; * protect this instead of the siglock, because they really&n;&t; * have no need to disable irqs.&n;&t; */
DECL|member|rlim
r_struct
id|rlimit
id|rlim
(braket
id|RLIM_NLIMITS
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Bits in flags field of signal_struct.&n; */
DECL|macro|SIGNAL_STOP_STOPPED
mdefine_line|#define SIGNAL_STOP_STOPPED&t;0x00000001 /* job control stop in effect */
DECL|macro|SIGNAL_STOP_DEQUEUED
mdefine_line|#define SIGNAL_STOP_DEQUEUED&t;0x00000002 /* stop signal dequeued */
DECL|macro|SIGNAL_STOP_CONTINUED
mdefine_line|#define SIGNAL_STOP_CONTINUED&t;0x00000004 /* SIGCONT since WCONTINUED reap */
DECL|macro|SIGNAL_GROUP_EXIT
mdefine_line|#define SIGNAL_GROUP_EXIT&t;0x00000008 /* group exit in progress */
multiline_comment|/*&n; * Priority of a process goes from 0..MAX_PRIO-1, valid RT&n; * priority is 0..MAX_RT_PRIO-1, and SCHED_NORMAL tasks are&n; * in the range MAX_RT_PRIO..MAX_PRIO-1. Priority values&n; * are inverted: lower p-&gt;prio value means higher priority.&n; *&n; * The MAX_USER_RT_PRIO value allows the actual maximum&n; * RT priority to be separate from the value exported to&n; * user-space.  This allows kernel threads to set their&n; * priority to a value higher than any user task. Note:&n; * MAX_RT_PRIO must not be smaller than MAX_USER_RT_PRIO.&n; */
DECL|macro|MAX_USER_RT_PRIO
mdefine_line|#define MAX_USER_RT_PRIO&t;100
DECL|macro|MAX_RT_PRIO
mdefine_line|#define MAX_RT_PRIO&t;&t;MAX_USER_RT_PRIO
DECL|macro|MAX_PRIO
mdefine_line|#define MAX_PRIO&t;&t;(MAX_RT_PRIO + 40)
DECL|macro|rt_task
mdefine_line|#define rt_task(p)&t;&t;(unlikely((p)-&gt;prio &lt; MAX_RT_PRIO))
multiline_comment|/*&n; * Some day this will be a full-fledged user tracking system..&n; */
DECL|struct|user_struct
r_struct
id|user_struct
(brace
DECL|member|__count
id|atomic_t
id|__count
suffix:semicolon
multiline_comment|/* reference count */
DECL|member|processes
id|atomic_t
id|processes
suffix:semicolon
multiline_comment|/* How many processes does this user have? */
DECL|member|files
id|atomic_t
id|files
suffix:semicolon
multiline_comment|/* How many open files does this user have? */
DECL|member|sigpending
id|atomic_t
id|sigpending
suffix:semicolon
multiline_comment|/* How many pending signals does this user have? */
multiline_comment|/* protected by mq_lock&t;*/
DECL|member|mq_bytes
r_int
r_int
id|mq_bytes
suffix:semicolon
multiline_comment|/* How many bytes can be allocated to mqueue? */
DECL|member|locked_shm
r_int
r_int
id|locked_shm
suffix:semicolon
multiline_comment|/* How many pages of mlocked shm ? */
macro_line|#ifdef CONFIG_KEYS
DECL|member|uid_keyring
r_struct
id|key
op_star
id|uid_keyring
suffix:semicolon
multiline_comment|/* UID specific keyring */
DECL|member|session_keyring
r_struct
id|key
op_star
id|session_keyring
suffix:semicolon
multiline_comment|/* UID&squot;s default session keyring */
macro_line|#endif
multiline_comment|/* Hash table maintenance information */
DECL|member|uidhash_list
r_struct
id|list_head
id|uidhash_list
suffix:semicolon
DECL|member|uid
id|uid_t
id|uid
suffix:semicolon
)brace
suffix:semicolon
r_extern
r_struct
id|user_struct
op_star
id|find_user
c_func
(paren
id|uid_t
)paren
suffix:semicolon
r_extern
r_struct
id|user_struct
id|root_user
suffix:semicolon
DECL|macro|INIT_USER
mdefine_line|#define INIT_USER (&amp;root_user)
DECL|typedef|prio_array_t
r_typedef
r_struct
id|prio_array
id|prio_array_t
suffix:semicolon
r_struct
id|backing_dev_info
suffix:semicolon
r_struct
id|reclaim_state
suffix:semicolon
macro_line|#ifdef CONFIG_SCHEDSTATS
DECL|struct|sched_info
r_struct
id|sched_info
(brace
multiline_comment|/* cumulative counters */
DECL|member|cpu_time
r_int
r_int
id|cpu_time
comma
multiline_comment|/* time spent on the cpu */
DECL|member|run_delay
id|run_delay
comma
multiline_comment|/* time spent waiting on a runqueue */
DECL|member|pcnt
id|pcnt
suffix:semicolon
multiline_comment|/* # of timeslices run on this cpu */
multiline_comment|/* timestamps */
DECL|member|last_arrival
r_int
r_int
id|last_arrival
comma
multiline_comment|/* when we last ran on a cpu */
DECL|member|last_queued
id|last_queued
suffix:semicolon
multiline_comment|/* when we were last queued to run */
)brace
suffix:semicolon
r_extern
r_struct
id|file_operations
id|proc_schedstat_operations
suffix:semicolon
macro_line|#endif
DECL|enum|idle_type
r_enum
id|idle_type
(brace
DECL|enumerator|SCHED_IDLE
id|SCHED_IDLE
comma
DECL|enumerator|NOT_IDLE
id|NOT_IDLE
comma
DECL|enumerator|NEWLY_IDLE
id|NEWLY_IDLE
comma
DECL|enumerator|MAX_IDLE_TYPES
id|MAX_IDLE_TYPES
)brace
suffix:semicolon
multiline_comment|/*&n; * sched-domains (multiprocessor balancing) declarations:&n; */
macro_line|#ifdef CONFIG_SMP
DECL|macro|SCHED_LOAD_SCALE
mdefine_line|#define SCHED_LOAD_SCALE&t;128UL&t;/* increase resolution of load */
DECL|macro|SD_LOAD_BALANCE
mdefine_line|#define SD_LOAD_BALANCE&t;&t;1&t;/* Do load balancing on this domain. */
DECL|macro|SD_BALANCE_NEWIDLE
mdefine_line|#define SD_BALANCE_NEWIDLE&t;2&t;/* Balance when about to become idle */
DECL|macro|SD_BALANCE_EXEC
mdefine_line|#define SD_BALANCE_EXEC&t;&t;4&t;/* Balance on exec */
DECL|macro|SD_WAKE_IDLE
mdefine_line|#define SD_WAKE_IDLE&t;&t;8&t;/* Wake to idle CPU on task wakeup */
DECL|macro|SD_WAKE_AFFINE
mdefine_line|#define SD_WAKE_AFFINE&t;&t;16&t;/* Wake task to waking CPU */
DECL|macro|SD_WAKE_BALANCE
mdefine_line|#define SD_WAKE_BALANCE&t;&t;32&t;/* Perform balancing at task wakeup */
DECL|macro|SD_SHARE_CPUPOWER
mdefine_line|#define SD_SHARE_CPUPOWER&t;64&t;/* Domain members share cpu power */
DECL|struct|sched_group
r_struct
id|sched_group
(brace
DECL|member|next
r_struct
id|sched_group
op_star
id|next
suffix:semicolon
multiline_comment|/* Must be a circular list */
DECL|member|cpumask
id|cpumask_t
id|cpumask
suffix:semicolon
multiline_comment|/*&n;&t; * CPU power of this group, SCHED_LOAD_SCALE being max power for a&n;&t; * single CPU. This is read only (except for setup, hotplug CPU).&n;&t; */
DECL|member|cpu_power
r_int
r_int
id|cpu_power
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|sched_domain
r_struct
id|sched_domain
(brace
multiline_comment|/* These fields must be setup */
DECL|member|parent
r_struct
id|sched_domain
op_star
id|parent
suffix:semicolon
multiline_comment|/* top domain must be null terminated */
DECL|member|groups
r_struct
id|sched_group
op_star
id|groups
suffix:semicolon
multiline_comment|/* the balancing groups of the domain */
DECL|member|span
id|cpumask_t
id|span
suffix:semicolon
multiline_comment|/* span of all CPUs in this domain */
DECL|member|min_interval
r_int
r_int
id|min_interval
suffix:semicolon
multiline_comment|/* Minimum balance interval ms */
DECL|member|max_interval
r_int
r_int
id|max_interval
suffix:semicolon
multiline_comment|/* Maximum balance interval ms */
DECL|member|busy_factor
r_int
r_int
id|busy_factor
suffix:semicolon
multiline_comment|/* less balancing by factor if busy */
DECL|member|imbalance_pct
r_int
r_int
id|imbalance_pct
suffix:semicolon
multiline_comment|/* No balance until over watermark */
DECL|member|cache_hot_time
r_int
r_int
r_int
id|cache_hot_time
suffix:semicolon
multiline_comment|/* Task considered cache hot (ns) */
DECL|member|cache_nice_tries
r_int
r_int
id|cache_nice_tries
suffix:semicolon
multiline_comment|/* Leave cache hot tasks for # tries */
DECL|member|per_cpu_gain
r_int
r_int
id|per_cpu_gain
suffix:semicolon
multiline_comment|/* CPU % gained by adding domain cpus */
DECL|member|flags
r_int
id|flags
suffix:semicolon
multiline_comment|/* See SD_* */
multiline_comment|/* Runtime fields. */
DECL|member|last_balance
r_int
r_int
id|last_balance
suffix:semicolon
multiline_comment|/* init to jiffies. units in jiffies */
DECL|member|balance_interval
r_int
r_int
id|balance_interval
suffix:semicolon
multiline_comment|/* initialise to 1. units in ms. */
DECL|member|nr_balance_failed
r_int
r_int
id|nr_balance_failed
suffix:semicolon
multiline_comment|/* initialise to 0 */
macro_line|#ifdef CONFIG_SCHEDSTATS
multiline_comment|/* load_balance() stats */
DECL|member|lb_cnt
r_int
r_int
id|lb_cnt
(braket
id|MAX_IDLE_TYPES
)braket
suffix:semicolon
DECL|member|lb_failed
r_int
r_int
id|lb_failed
(braket
id|MAX_IDLE_TYPES
)braket
suffix:semicolon
DECL|member|lb_imbalance
r_int
r_int
id|lb_imbalance
(braket
id|MAX_IDLE_TYPES
)braket
suffix:semicolon
DECL|member|lb_nobusyg
r_int
r_int
id|lb_nobusyg
(braket
id|MAX_IDLE_TYPES
)braket
suffix:semicolon
DECL|member|lb_nobusyq
r_int
r_int
id|lb_nobusyq
(braket
id|MAX_IDLE_TYPES
)braket
suffix:semicolon
multiline_comment|/* sched_balance_exec() stats */
DECL|member|sbe_attempts
r_int
r_int
id|sbe_attempts
suffix:semicolon
DECL|member|sbe_pushed
r_int
r_int
id|sbe_pushed
suffix:semicolon
multiline_comment|/* try_to_wake_up() stats */
DECL|member|ttwu_wake_affine
r_int
r_int
id|ttwu_wake_affine
suffix:semicolon
DECL|member|ttwu_wake_balance
r_int
r_int
id|ttwu_wake_balance
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
macro_line|#ifdef ARCH_HAS_SCHED_DOMAIN
multiline_comment|/* Useful helpers that arch setup code may use. Defined in kernel/sched.c */
r_extern
id|cpumask_t
id|cpu_isolated_map
suffix:semicolon
r_extern
r_void
id|init_sched_build_groups
c_func
(paren
r_struct
id|sched_group
id|groups
(braket
)braket
comma
id|cpumask_t
id|span
comma
r_int
(paren
op_star
id|group_fn
)paren
(paren
r_int
id|cpu
)paren
)paren
suffix:semicolon
r_extern
r_void
id|cpu_attach_domain
c_func
(paren
r_struct
id|sched_domain
op_star
id|sd
comma
r_int
id|cpu
)paren
suffix:semicolon
macro_line|#endif /* ARCH_HAS_SCHED_DOMAIN */
macro_line|#endif /* CONFIG_SMP */
r_struct
id|io_context
suffix:semicolon
multiline_comment|/* See blkdev.h */
r_void
id|exit_io_context
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|NGROUPS_SMALL
mdefine_line|#define NGROUPS_SMALL&t;&t;32
DECL|macro|NGROUPS_PER_BLOCK
mdefine_line|#define NGROUPS_PER_BLOCK&t;((int)(PAGE_SIZE / sizeof(gid_t)))
DECL|struct|group_info
r_struct
id|group_info
(brace
DECL|member|ngroups
r_int
id|ngroups
suffix:semicolon
DECL|member|usage
id|atomic_t
id|usage
suffix:semicolon
DECL|member|small_block
id|gid_t
id|small_block
(braket
id|NGROUPS_SMALL
)braket
suffix:semicolon
DECL|member|nblocks
r_int
id|nblocks
suffix:semicolon
DECL|member|blocks
id|gid_t
op_star
id|blocks
(braket
l_int|0
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * get_group_info() must be called with the owning task locked (via task_lock())&n; * when task != current.  The reason being that the vast majority of callers are&n; * looking at current-&gt;group_info, which can not be changed except by the&n; * current task.  Changing current-&gt;group_info requires the task lock, too.&n; */
DECL|macro|get_group_info
mdefine_line|#define get_group_info(group_info) do { &bslash;&n;&t;atomic_inc(&amp;(group_info)-&gt;usage); &bslash;&n;} while (0)
DECL|macro|put_group_info
mdefine_line|#define put_group_info(group_info) do { &bslash;&n;&t;if (atomic_dec_and_test(&amp;(group_info)-&gt;usage)) &bslash;&n;&t;&t;groups_free(group_info); &bslash;&n;} while (0)
r_struct
id|group_info
op_star
id|groups_alloc
c_func
(paren
r_int
id|gidsetsize
)paren
suffix:semicolon
r_void
id|groups_free
c_func
(paren
r_struct
id|group_info
op_star
id|group_info
)paren
suffix:semicolon
r_int
id|set_current_groups
c_func
(paren
r_struct
id|group_info
op_star
id|group_info
)paren
suffix:semicolon
multiline_comment|/* access the groups &quot;array&quot; with this macro */
DECL|macro|GROUP_AT
mdefine_line|#define GROUP_AT(gi, i) &bslash;&n;    ((gi)-&gt;blocks[(i)/NGROUPS_PER_BLOCK][(i)%NGROUPS_PER_BLOCK])
r_struct
id|audit_context
suffix:semicolon
multiline_comment|/* See audit.c */
r_struct
id|mempolicy
suffix:semicolon
DECL|struct|task_struct
r_struct
id|task_struct
(brace
DECL|member|state
r_volatile
r_int
id|state
suffix:semicolon
multiline_comment|/* -1 unrunnable, 0 runnable, &gt;0 stopped */
DECL|member|thread_info
r_struct
id|thread_info
op_star
id|thread_info
suffix:semicolon
DECL|member|usage
id|atomic_t
id|usage
suffix:semicolon
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* per process flags, defined below */
DECL|member|ptrace
r_int
r_int
id|ptrace
suffix:semicolon
DECL|member|lock_depth
r_int
id|lock_depth
suffix:semicolon
multiline_comment|/* Lock depth */
DECL|member|prio
DECL|member|static_prio
r_int
id|prio
comma
id|static_prio
suffix:semicolon
DECL|member|run_list
r_struct
id|list_head
id|run_list
suffix:semicolon
DECL|member|array
id|prio_array_t
op_star
id|array
suffix:semicolon
DECL|member|sleep_avg
r_int
r_int
id|sleep_avg
suffix:semicolon
DECL|member|timestamp
DECL|member|last_ran
r_int
r_int
r_int
id|timestamp
comma
id|last_ran
suffix:semicolon
DECL|member|activated
r_int
id|activated
suffix:semicolon
DECL|member|policy
r_int
r_int
id|policy
suffix:semicolon
DECL|member|cpus_allowed
id|cpumask_t
id|cpus_allowed
suffix:semicolon
DECL|member|time_slice
DECL|member|first_time_slice
r_int
r_int
id|time_slice
comma
id|first_time_slice
suffix:semicolon
macro_line|#ifdef CONFIG_SCHEDSTATS
DECL|member|sched_info
r_struct
id|sched_info
id|sched_info
suffix:semicolon
macro_line|#endif
DECL|member|tasks
r_struct
id|list_head
id|tasks
suffix:semicolon
multiline_comment|/*&n;&t; * ptrace_list/ptrace_children forms the list of my children&n;&t; * that were stolen by a ptracer.&n;&t; */
DECL|member|ptrace_children
r_struct
id|list_head
id|ptrace_children
suffix:semicolon
DECL|member|ptrace_list
r_struct
id|list_head
id|ptrace_list
suffix:semicolon
DECL|member|mm
DECL|member|active_mm
r_struct
id|mm_struct
op_star
id|mm
comma
op_star
id|active_mm
suffix:semicolon
multiline_comment|/* task state */
DECL|member|binfmt
r_struct
id|linux_binfmt
op_star
id|binfmt
suffix:semicolon
DECL|member|exit_state
r_int
id|exit_state
suffix:semicolon
DECL|member|exit_code
DECL|member|exit_signal
r_int
id|exit_code
comma
id|exit_signal
suffix:semicolon
DECL|member|pdeath_signal
r_int
id|pdeath_signal
suffix:semicolon
multiline_comment|/*  The signal sent when the parent dies  */
multiline_comment|/* ??? */
DECL|member|personality
r_int
r_int
id|personality
suffix:semicolon
DECL|member|did_exec
r_int
id|did_exec
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pid
id|pid_t
id|pid
suffix:semicolon
DECL|member|tgid
id|pid_t
id|tgid
suffix:semicolon
multiline_comment|/* &n;&t; * pointers to (original) parent process, youngest child, younger sibling,&n;&t; * older sibling, respectively.  (p-&gt;father can be replaced with &n;&t; * p-&gt;parent-&gt;pid)&n;&t; */
DECL|member|real_parent
r_struct
id|task_struct
op_star
id|real_parent
suffix:semicolon
multiline_comment|/* real parent process (when being debugged) */
DECL|member|parent
r_struct
id|task_struct
op_star
id|parent
suffix:semicolon
multiline_comment|/* parent process */
multiline_comment|/*&n;&t; * children/sibling forms the list of my children plus the&n;&t; * tasks I&squot;m ptracing.&n;&t; */
DECL|member|children
r_struct
id|list_head
id|children
suffix:semicolon
multiline_comment|/* list of my children */
DECL|member|sibling
r_struct
id|list_head
id|sibling
suffix:semicolon
multiline_comment|/* linkage in my parent&squot;s children list */
DECL|member|group_leader
r_struct
id|task_struct
op_star
id|group_leader
suffix:semicolon
multiline_comment|/* threadgroup leader */
multiline_comment|/* PID/PID hash table linkage. */
DECL|member|pids
r_struct
id|pid
id|pids
(braket
id|PIDTYPE_MAX
)braket
suffix:semicolon
DECL|member|vfork_done
r_struct
id|completion
op_star
id|vfork_done
suffix:semicolon
multiline_comment|/* for vfork() */
DECL|member|set_child_tid
r_int
id|__user
op_star
id|set_child_tid
suffix:semicolon
multiline_comment|/* CLONE_CHILD_SETTID */
DECL|member|clear_child_tid
r_int
id|__user
op_star
id|clear_child_tid
suffix:semicolon
multiline_comment|/* CLONE_CHILD_CLEARTID */
DECL|member|rt_priority
r_int
r_int
id|rt_priority
suffix:semicolon
DECL|member|it_real_value
DECL|member|it_real_incr
r_int
r_int
id|it_real_value
comma
id|it_real_incr
suffix:semicolon
DECL|member|it_virt_value
DECL|member|it_virt_incr
id|cputime_t
id|it_virt_value
comma
id|it_virt_incr
suffix:semicolon
DECL|member|it_prof_value
DECL|member|it_prof_incr
id|cputime_t
id|it_prof_value
comma
id|it_prof_incr
suffix:semicolon
DECL|member|real_timer
r_struct
id|timer_list
id|real_timer
suffix:semicolon
DECL|member|utime
DECL|member|stime
id|cputime_t
id|utime
comma
id|stime
suffix:semicolon
DECL|member|nvcsw
DECL|member|nivcsw
r_int
r_int
id|nvcsw
comma
id|nivcsw
suffix:semicolon
multiline_comment|/* context switch counts */
DECL|member|start_time
r_struct
id|timespec
id|start_time
suffix:semicolon
multiline_comment|/* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */
DECL|member|min_flt
DECL|member|maj_flt
r_int
r_int
id|min_flt
comma
id|maj_flt
suffix:semicolon
multiline_comment|/* process credentials */
DECL|member|uid
DECL|member|euid
DECL|member|suid
DECL|member|fsuid
id|uid_t
id|uid
comma
id|euid
comma
id|suid
comma
id|fsuid
suffix:semicolon
DECL|member|gid
DECL|member|egid
DECL|member|sgid
DECL|member|fsgid
id|gid_t
id|gid
comma
id|egid
comma
id|sgid
comma
id|fsgid
suffix:semicolon
DECL|member|group_info
r_struct
id|group_info
op_star
id|group_info
suffix:semicolon
DECL|member|cap_effective
DECL|member|cap_inheritable
DECL|member|cap_permitted
id|kernel_cap_t
id|cap_effective
comma
id|cap_inheritable
comma
id|cap_permitted
suffix:semicolon
DECL|member|keep_capabilities
r_int
id|keep_capabilities
suffix:colon
l_int|1
suffix:semicolon
DECL|member|user
r_struct
id|user_struct
op_star
id|user
suffix:semicolon
macro_line|#ifdef CONFIG_KEYS
DECL|member|session_keyring
r_struct
id|key
op_star
id|session_keyring
suffix:semicolon
multiline_comment|/* keyring inherited over fork */
DECL|member|process_keyring
r_struct
id|key
op_star
id|process_keyring
suffix:semicolon
multiline_comment|/* keyring private to this process (CLONE_THREAD) */
DECL|member|thread_keyring
r_struct
id|key
op_star
id|thread_keyring
suffix:semicolon
multiline_comment|/* keyring private to this thread */
macro_line|#endif
DECL|member|used_math
r_int
r_int
id|used_math
suffix:semicolon
DECL|member|comm
r_char
id|comm
(braket
id|TASK_COMM_LEN
)braket
suffix:semicolon
multiline_comment|/* file system info */
DECL|member|link_count
DECL|member|total_link_count
r_int
id|link_count
comma
id|total_link_count
suffix:semicolon
multiline_comment|/* ipc stuff */
DECL|member|sysvsem
r_struct
id|sysv_sem
id|sysvsem
suffix:semicolon
multiline_comment|/* CPU-specific state of this task */
DECL|member|thread
r_struct
id|thread_struct
id|thread
suffix:semicolon
multiline_comment|/* filesystem information */
DECL|member|fs
r_struct
id|fs_struct
op_star
id|fs
suffix:semicolon
multiline_comment|/* open file information */
DECL|member|files
r_struct
id|files_struct
op_star
id|files
suffix:semicolon
multiline_comment|/* namespace */
DECL|member|namespace
r_struct
r_namespace
op_star
r_namespace
suffix:semicolon
multiline_comment|/* signal handlers */
DECL|member|signal
r_struct
id|signal_struct
op_star
id|signal
suffix:semicolon
DECL|member|sighand
r_struct
id|sighand_struct
op_star
id|sighand
suffix:semicolon
DECL|member|blocked
DECL|member|real_blocked
id|sigset_t
id|blocked
comma
id|real_blocked
suffix:semicolon
DECL|member|pending
r_struct
id|sigpending
id|pending
suffix:semicolon
DECL|member|sas_ss_sp
r_int
r_int
id|sas_ss_sp
suffix:semicolon
DECL|member|sas_ss_size
r_int
id|sas_ss_size
suffix:semicolon
DECL|member|notifier
r_int
(paren
op_star
id|notifier
)paren
(paren
r_void
op_star
id|priv
)paren
suffix:semicolon
DECL|member|notifier_data
r_void
op_star
id|notifier_data
suffix:semicolon
DECL|member|notifier_mask
id|sigset_t
op_star
id|notifier_mask
suffix:semicolon
DECL|member|security
r_void
op_star
id|security
suffix:semicolon
DECL|member|audit_context
r_struct
id|audit_context
op_star
id|audit_context
suffix:semicolon
multiline_comment|/* Thread group tracking */
DECL|member|parent_exec_id
id|u32
id|parent_exec_id
suffix:semicolon
DECL|member|self_exec_id
id|u32
id|self_exec_id
suffix:semicolon
multiline_comment|/* Protection of (de-)allocation: mm, files, fs, tty, keyrings */
DECL|member|alloc_lock
id|spinlock_t
id|alloc_lock
suffix:semicolon
multiline_comment|/* Protection of proc_dentry: nesting proc_lock, dcache_lock, write_lock_irq(&amp;tasklist_lock); */
DECL|member|proc_lock
id|spinlock_t
id|proc_lock
suffix:semicolon
multiline_comment|/* context-switch lock */
DECL|member|switch_lock
id|spinlock_t
id|switch_lock
suffix:semicolon
multiline_comment|/* journalling filesystem info */
DECL|member|journal_info
r_void
op_star
id|journal_info
suffix:semicolon
multiline_comment|/* VM state */
DECL|member|reclaim_state
r_struct
id|reclaim_state
op_star
id|reclaim_state
suffix:semicolon
DECL|member|proc_dentry
r_struct
id|dentry
op_star
id|proc_dentry
suffix:semicolon
DECL|member|backing_dev_info
r_struct
id|backing_dev_info
op_star
id|backing_dev_info
suffix:semicolon
DECL|member|io_context
r_struct
id|io_context
op_star
id|io_context
suffix:semicolon
DECL|member|ptrace_message
r_int
r_int
id|ptrace_message
suffix:semicolon
DECL|member|last_siginfo
id|siginfo_t
op_star
id|last_siginfo
suffix:semicolon
multiline_comment|/* For ptrace use.  */
multiline_comment|/*&n; * current io wait handle: wait queue entry to use for io waits&n; * If this thread is processing aio, this points at the waitqueue&n; * inside the currently handled kiocb. It may be NULL (i.e. default&n; * to a stack based synchronous wait) if its doing sync IO.&n; */
DECL|member|io_wait
id|wait_queue_t
op_star
id|io_wait
suffix:semicolon
multiline_comment|/* i/o counters(bytes read/written, #syscalls */
DECL|member|rchar
DECL|member|wchar
DECL|member|syscr
DECL|member|syscw
id|u64
id|rchar
comma
id|wchar
comma
id|syscr
comma
id|syscw
suffix:semicolon
macro_line|#if defined(CONFIG_BSD_PROCESS_ACCT)
DECL|member|acct_rss_mem1
id|u64
id|acct_rss_mem1
suffix:semicolon
multiline_comment|/* accumulated rss usage */
DECL|member|acct_vm_mem1
id|u64
id|acct_vm_mem1
suffix:semicolon
multiline_comment|/* accumulated virtual memory usage */
DECL|member|acct_stimexpd
id|clock_t
id|acct_stimexpd
suffix:semicolon
multiline_comment|/* clock_t-converted stime since last update */
macro_line|#endif
macro_line|#ifdef CONFIG_NUMA
DECL|member|mempolicy
r_struct
id|mempolicy
op_star
id|mempolicy
suffix:semicolon
DECL|member|il_next
r_int
id|il_next
suffix:semicolon
multiline_comment|/* could be shared with used_math */
macro_line|#endif
)brace
suffix:semicolon
DECL|function|process_group
r_static
r_inline
id|pid_t
id|process_group
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_return
id|tsk-&gt;signal-&gt;pgrp
suffix:semicolon
)brace
multiline_comment|/**&n; * pid_alive - check that a task structure is not stale&n; * @p: Task structure to be checked.&n; *&n; * Test if a process is not yet dead (at most zombie state)&n; * If pid_alive fails, then pointers within the task structure&n; * can be stale and must not be dereferenced.&n; */
DECL|function|pid_alive
r_static
r_inline
r_int
id|pid_alive
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_return
id|p-&gt;pids
(braket
id|PIDTYPE_PID
)braket
dot
id|nr
op_ne
l_int|0
suffix:semicolon
)brace
r_extern
r_void
id|free_task
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
suffix:semicolon
r_extern
r_void
id|__put_task_struct
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
suffix:semicolon
DECL|macro|get_task_struct
mdefine_line|#define get_task_struct(tsk) do { atomic_inc(&amp;(tsk)-&gt;usage); } while(0)
DECL|macro|put_task_struct
mdefine_line|#define put_task_struct(tsk) &bslash;&n;do { if (atomic_dec_and_test(&amp;(tsk)-&gt;usage)) __put_task_struct(tsk); } while(0)
multiline_comment|/*&n; * Per process flags&n; */
DECL|macro|PF_ALIGNWARN
mdefine_line|#define PF_ALIGNWARN&t;0x00000001&t;/* Print alignment warning msgs */
multiline_comment|/* Not implemented yet, only for 486*/
DECL|macro|PF_STARTING
mdefine_line|#define PF_STARTING&t;0x00000002&t;/* being created */
DECL|macro|PF_EXITING
mdefine_line|#define PF_EXITING&t;0x00000004&t;/* getting shut down */
DECL|macro|PF_DEAD
mdefine_line|#define PF_DEAD&t;&t;0x00000008&t;/* Dead */
DECL|macro|PF_FORKNOEXEC
mdefine_line|#define PF_FORKNOEXEC&t;0x00000040&t;/* forked but didn&squot;t exec */
DECL|macro|PF_SUPERPRIV
mdefine_line|#define PF_SUPERPRIV&t;0x00000100&t;/* used super-user privileges */
DECL|macro|PF_DUMPCORE
mdefine_line|#define PF_DUMPCORE&t;0x00000200&t;/* dumped core */
DECL|macro|PF_SIGNALED
mdefine_line|#define PF_SIGNALED&t;0x00000400&t;/* killed by a signal */
DECL|macro|PF_MEMALLOC
mdefine_line|#define PF_MEMALLOC&t;0x00000800&t;/* Allocating memory */
DECL|macro|PF_MEMDIE
mdefine_line|#define PF_MEMDIE&t;0x00001000&t;/* Killed for out-of-memory */
DECL|macro|PF_FLUSHER
mdefine_line|#define PF_FLUSHER&t;0x00002000&t;/* responsible for disk writeback */
DECL|macro|PF_FREEZE
mdefine_line|#define PF_FREEZE&t;0x00004000&t;/* this task is being frozen for suspend now */
DECL|macro|PF_NOFREEZE
mdefine_line|#define PF_NOFREEZE&t;0x00008000&t;/* this thread should not be frozen */
DECL|macro|PF_FROZEN
mdefine_line|#define PF_FROZEN&t;0x00010000&t;/* frozen for system suspend */
DECL|macro|PF_FSTRANS
mdefine_line|#define PF_FSTRANS&t;0x00020000&t;/* inside a filesystem transaction */
DECL|macro|PF_KSWAPD
mdefine_line|#define PF_KSWAPD&t;0x00040000&t;/* I am kswapd */
DECL|macro|PF_SWAPOFF
mdefine_line|#define PF_SWAPOFF&t;0x00080000&t;/* I am in swapoff */
DECL|macro|PF_LESS_THROTTLE
mdefine_line|#define PF_LESS_THROTTLE 0x00100000&t;/* Throttle me less: I clean memory */
DECL|macro|PF_SYNCWRITE
mdefine_line|#define PF_SYNCWRITE&t;0x00200000&t;/* I am doing a sync write */
DECL|macro|PF_BORROWED_MM
mdefine_line|#define PF_BORROWED_MM&t;0x00400000&t;/* I am a kthread doing use_mm */
macro_line|#ifdef CONFIG_SMP
r_extern
r_int
id|set_cpus_allowed
c_func
(paren
id|task_t
op_star
id|p
comma
id|cpumask_t
id|new_mask
)paren
suffix:semicolon
macro_line|#else
DECL|function|set_cpus_allowed
r_static
r_inline
r_int
id|set_cpus_allowed
c_func
(paren
id|task_t
op_star
id|p
comma
id|cpumask_t
id|new_mask
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cpus_intersects
c_func
(paren
id|new_mask
comma
id|cpu_online_map
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_extern
r_int
r_int
r_int
id|sched_clock
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* sched_exec is called by processes performing an exec */
macro_line|#ifdef CONFIG_SMP
r_extern
r_void
id|sched_exec
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#else
DECL|macro|sched_exec
mdefine_line|#define sched_exec()   {}
macro_line|#endif
macro_line|#ifdef CONFIG_HOTPLUG_CPU
r_extern
r_void
id|idle_task_exit
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#else
DECL|function|idle_task_exit
r_static
r_inline
r_void
id|idle_task_exit
c_func
(paren
r_void
)paren
(brace
)brace
macro_line|#endif
r_extern
r_void
id|sched_idle_next
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|set_user_nice
c_func
(paren
id|task_t
op_star
id|p
comma
r_int
id|nice
)paren
suffix:semicolon
r_extern
r_int
id|task_prio
c_func
(paren
r_const
id|task_t
op_star
id|p
)paren
suffix:semicolon
r_extern
r_int
id|task_nice
c_func
(paren
r_const
id|task_t
op_star
id|p
)paren
suffix:semicolon
r_extern
r_int
id|task_curr
c_func
(paren
r_const
id|task_t
op_star
id|p
)paren
suffix:semicolon
r_extern
r_int
id|idle_cpu
c_func
(paren
r_int
id|cpu
)paren
suffix:semicolon
r_extern
r_int
id|sched_setscheduler
c_func
(paren
r_struct
id|task_struct
op_star
comma
r_int
comma
r_struct
id|sched_param
op_star
)paren
suffix:semicolon
r_extern
id|task_t
op_star
id|idle_task
c_func
(paren
r_int
id|cpu
)paren
suffix:semicolon
r_void
id|yield
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * The default (Linux) execution domain.&n; */
r_extern
r_struct
id|exec_domain
id|default_exec_domain
suffix:semicolon
DECL|union|thread_union
r_union
id|thread_union
(brace
DECL|member|thread_info
r_struct
id|thread_info
id|thread_info
suffix:semicolon
DECL|member|stack
r_int
r_int
id|stack
(braket
id|THREAD_SIZE
op_div
r_sizeof
(paren
r_int
)paren
)braket
suffix:semicolon
)brace
suffix:semicolon
macro_line|#ifndef __HAVE_ARCH_KSTACK_END
DECL|function|kstack_end
r_static
r_inline
r_int
id|kstack_end
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
multiline_comment|/* Reliable end of stack detection:&n;&t; * Some APM bios versions misalign the stack&n;&t; */
r_return
op_logical_neg
(paren
(paren
(paren
r_int
r_int
)paren
id|addr
op_plus
r_sizeof
(paren
r_void
op_star
)paren
op_minus
l_int|1
)paren
op_amp
(paren
id|THREAD_SIZE
op_minus
r_sizeof
(paren
r_void
op_star
)paren
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_extern
r_union
id|thread_union
id|init_thread_union
suffix:semicolon
r_extern
r_struct
id|task_struct
id|init_task
suffix:semicolon
r_extern
r_struct
id|mm_struct
id|init_mm
suffix:semicolon
DECL|macro|find_task_by_pid
mdefine_line|#define find_task_by_pid(nr)&t;find_task_by_pid_type(PIDTYPE_PID, nr)
r_extern
r_struct
id|task_struct
op_star
id|find_task_by_pid_type
c_func
(paren
r_int
id|type
comma
r_int
id|pid
)paren
suffix:semicolon
r_extern
r_void
id|set_special_pids
c_func
(paren
id|pid_t
id|session
comma
id|pid_t
id|pgrp
)paren
suffix:semicolon
r_extern
r_void
id|__set_special_pids
c_func
(paren
id|pid_t
id|session
comma
id|pid_t
id|pgrp
)paren
suffix:semicolon
multiline_comment|/* per-UID process charging. */
r_extern
r_struct
id|user_struct
op_star
id|alloc_uid
c_func
(paren
id|uid_t
)paren
suffix:semicolon
DECL|function|get_uid
r_static
r_inline
r_struct
id|user_struct
op_star
id|get_uid
c_func
(paren
r_struct
id|user_struct
op_star
id|u
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|u-&gt;__count
)paren
suffix:semicolon
r_return
id|u
suffix:semicolon
)brace
r_extern
r_void
id|free_uid
c_func
(paren
r_struct
id|user_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|switch_uid
c_func
(paren
r_struct
id|user_struct
op_star
)paren
suffix:semicolon
macro_line|#include &lt;asm/current.h&gt;
r_extern
r_void
id|do_timer
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_extern
r_int
id|FASTCALL
c_func
(paren
id|wake_up_state
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
r_int
id|state
)paren
)paren
suffix:semicolon
r_extern
r_int
id|FASTCALL
c_func
(paren
id|wake_up_process
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
)paren
suffix:semicolon
r_extern
r_void
id|FASTCALL
c_func
(paren
id|wake_up_new_task
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
r_int
id|clone_flags
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_extern
r_void
id|kick_process
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
suffix:semicolon
macro_line|#else
DECL|function|kick_process
r_static
r_inline
r_void
id|kick_process
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
)brace
macro_line|#endif
r_extern
r_void
id|FASTCALL
c_func
(paren
id|sched_fork
c_func
(paren
id|task_t
op_star
id|p
)paren
)paren
suffix:semicolon
r_extern
r_void
id|FASTCALL
c_func
(paren
id|sched_exit
c_func
(paren
id|task_t
op_star
id|p
)paren
)paren
suffix:semicolon
r_extern
r_int
id|in_group_p
c_func
(paren
id|gid_t
)paren
suffix:semicolon
r_extern
r_int
id|in_egroup_p
c_func
(paren
id|gid_t
)paren
suffix:semicolon
r_extern
r_void
id|proc_caches_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|flush_signals
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|flush_signal_handlers
c_func
(paren
r_struct
id|task_struct
op_star
comma
r_int
id|force_default
)paren
suffix:semicolon
r_extern
r_int
id|dequeue_signal
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
id|sigset_t
op_star
id|mask
comma
id|siginfo_t
op_star
id|info
)paren
suffix:semicolon
DECL|function|dequeue_signal_lock
r_static
r_inline
r_int
id|dequeue_signal_lock
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
id|sigset_t
op_star
id|mask
comma
id|siginfo_t
op_star
id|info
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tsk-&gt;sighand-&gt;siglock
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|dequeue_signal
c_func
(paren
id|tsk
comma
id|mask
comma
id|info
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tsk-&gt;sighand-&gt;siglock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_extern
r_void
id|block_all_signals
c_func
(paren
r_int
(paren
op_star
id|notifier
)paren
(paren
r_void
op_star
id|priv
)paren
comma
r_void
op_star
id|priv
comma
id|sigset_t
op_star
id|mask
)paren
suffix:semicolon
r_extern
r_void
id|unblock_all_signals
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|release_task
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
suffix:semicolon
r_extern
r_int
id|send_sig_info
c_func
(paren
r_int
comma
r_struct
id|siginfo
op_star
comma
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_int
id|send_group_sig_info
c_func
(paren
r_int
comma
r_struct
id|siginfo
op_star
comma
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_int
id|force_sigsegv
c_func
(paren
r_int
comma
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_int
id|force_sig_info
c_func
(paren
r_int
comma
r_struct
id|siginfo
op_star
comma
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_int
id|__kill_pg_info
c_func
(paren
r_int
id|sig
comma
r_struct
id|siginfo
op_star
id|info
comma
id|pid_t
id|pgrp
)paren
suffix:semicolon
r_extern
r_int
id|kill_pg_info
c_func
(paren
r_int
comma
r_struct
id|siginfo
op_star
comma
id|pid_t
)paren
suffix:semicolon
r_extern
r_int
id|kill_proc_info
c_func
(paren
r_int
comma
r_struct
id|siginfo
op_star
comma
id|pid_t
)paren
suffix:semicolon
r_extern
r_void
id|do_notify_parent
c_func
(paren
r_struct
id|task_struct
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_void
id|force_sig
c_func
(paren
r_int
comma
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|force_sig_specific
c_func
(paren
r_int
comma
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_int
id|send_sig
c_func
(paren
r_int
comma
r_struct
id|task_struct
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_void
id|zap_other_threads
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
suffix:semicolon
r_extern
r_int
id|kill_pg
c_func
(paren
id|pid_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|kill_sl
c_func
(paren
id|pid_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|kill_proc
c_func
(paren
id|pid_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_struct
id|sigqueue
op_star
id|sigqueue_alloc
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|sigqueue_free
c_func
(paren
r_struct
id|sigqueue
op_star
)paren
suffix:semicolon
r_extern
r_int
id|send_sigqueue
c_func
(paren
r_int
comma
r_struct
id|sigqueue
op_star
comma
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_int
id|send_group_sigqueue
c_func
(paren
r_int
comma
r_struct
id|sigqueue
op_star
comma
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_int
id|do_sigaction
c_func
(paren
r_int
comma
r_const
r_struct
id|k_sigaction
op_star
comma
r_struct
id|k_sigaction
op_star
)paren
suffix:semicolon
r_extern
r_int
id|do_sigaltstack
c_func
(paren
r_const
id|stack_t
id|__user
op_star
comma
id|stack_t
id|__user
op_star
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* These can be the second arg to send_sig_info/send_group_sig_info.  */
DECL|macro|SEND_SIG_NOINFO
mdefine_line|#define SEND_SIG_NOINFO ((struct siginfo *) 0)
DECL|macro|SEND_SIG_PRIV
mdefine_line|#define SEND_SIG_PRIV&t;((struct siginfo *) 1)
DECL|macro|SEND_SIG_FORCED
mdefine_line|#define SEND_SIG_FORCED&t;((struct siginfo *) 2)
multiline_comment|/* True if we are on the alternate signal stack.  */
DECL|function|on_sig_stack
r_static
r_inline
r_int
id|on_sig_stack
c_func
(paren
r_int
r_int
id|sp
)paren
(brace
r_return
(paren
id|sp
op_minus
id|current-&gt;sas_ss_sp
OL
id|current-&gt;sas_ss_size
)paren
suffix:semicolon
)brace
DECL|function|sas_ss_flags
r_static
r_inline
r_int
id|sas_ss_flags
c_func
(paren
r_int
r_int
id|sp
)paren
(brace
r_return
(paren
id|current-&gt;sas_ss_size
op_eq
l_int|0
ques
c_cond
id|SS_DISABLE
suffix:colon
id|on_sig_stack
c_func
(paren
id|sp
)paren
ques
c_cond
id|SS_ONSTACK
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SECURITY
multiline_comment|/* code is in security.c */
r_extern
r_int
id|capable
c_func
(paren
r_int
id|cap
)paren
suffix:semicolon
macro_line|#else
DECL|function|capable
r_static
r_inline
r_int
id|capable
c_func
(paren
r_int
id|cap
)paren
(brace
r_if
c_cond
(paren
id|cap_raised
c_func
(paren
id|current-&gt;cap_effective
comma
id|cap
)paren
)paren
(brace
id|current-&gt;flags
op_or_assign
id|PF_SUPERPRIV
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Routines for handling mm_structs&n; */
r_extern
r_struct
id|mm_struct
op_star
id|mm_alloc
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* mmdrop drops the mm and the page tables */
r_extern
r_void
id|FASTCALL
c_func
(paren
id|__mmdrop
c_func
(paren
r_struct
id|mm_struct
op_star
)paren
)paren
suffix:semicolon
DECL|function|mmdrop
r_static
r_inline
r_void
id|mmdrop
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|mm-&gt;mm_count
)paren
)paren
id|__mmdrop
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
multiline_comment|/* mmput gets rid of the mappings and all user-space */
r_extern
r_void
id|mmput
c_func
(paren
r_struct
id|mm_struct
op_star
)paren
suffix:semicolon
multiline_comment|/* Grab a reference to a task&squot;s mm, if it is not already going away */
r_extern
r_struct
id|mm_struct
op_star
id|get_task_mm
c_func
(paren
r_struct
id|task_struct
op_star
id|task
)paren
suffix:semicolon
multiline_comment|/* Remove the current tasks stale references to the old mm_struct */
r_extern
r_void
id|mm_release
c_func
(paren
r_struct
id|task_struct
op_star
comma
r_struct
id|mm_struct
op_star
)paren
suffix:semicolon
r_extern
r_int
id|copy_thread
c_func
(paren
r_int
comma
r_int
r_int
comma
r_int
r_int
comma
r_int
r_int
comma
r_struct
id|task_struct
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_extern
r_void
id|flush_thread
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|exit_thread
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|exit_mm
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|exit_files
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|exit_signal
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|__exit_signal
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|exit_sighand
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|__exit_sighand
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|exit_itimers
c_func
(paren
r_struct
id|signal_struct
op_star
)paren
suffix:semicolon
r_extern
id|NORET_TYPE
r_void
id|do_group_exit
c_func
(paren
r_int
)paren
suffix:semicolon
r_extern
r_void
id|reparent_to_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|daemonize
c_func
(paren
r_const
r_char
op_star
comma
dot
dot
dot
)paren
suffix:semicolon
r_extern
r_int
id|allow_signal
c_func
(paren
r_int
)paren
suffix:semicolon
r_extern
r_int
id|disallow_signal
c_func
(paren
r_int
)paren
suffix:semicolon
r_extern
id|task_t
op_star
id|child_reaper
suffix:semicolon
r_extern
r_int
id|do_execve
c_func
(paren
r_char
op_star
comma
r_char
id|__user
op_star
id|__user
op_star
comma
r_char
id|__user
op_star
id|__user
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_extern
r_int
id|do_fork
c_func
(paren
r_int
r_int
comma
r_int
r_int
comma
r_struct
id|pt_regs
op_star
comma
r_int
r_int
comma
r_int
id|__user
op_star
comma
r_int
id|__user
op_star
)paren
suffix:semicolon
id|task_t
op_star
id|fork_idle
c_func
(paren
r_int
)paren
suffix:semicolon
r_extern
r_void
id|set_task_comm
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_char
op_star
id|from
)paren
suffix:semicolon
r_extern
r_void
id|get_task_comm
c_func
(paren
r_char
op_star
id|to
comma
r_struct
id|task_struct
op_star
id|tsk
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_extern
r_void
id|wait_task_inactive
c_func
(paren
id|task_t
op_star
id|p
)paren
suffix:semicolon
macro_line|#else
DECL|macro|wait_task_inactive
mdefine_line|#define wait_task_inactive(p)&t;do { } while (0)
macro_line|#endif
DECL|macro|remove_parent
mdefine_line|#define remove_parent(p)&t;list_del_init(&amp;(p)-&gt;sibling)
DECL|macro|add_parent
mdefine_line|#define add_parent(p, parent)&t;list_add_tail(&amp;(p)-&gt;sibling,&amp;(parent)-&gt;children)
DECL|macro|REMOVE_LINKS
mdefine_line|#define REMOVE_LINKS(p) do {&t;&t;&t;&t;&t;&bslash;&n;&t;if (thread_group_leader(p))&t;&t;&t;&t;&bslash;&n;&t;&t;list_del_init(&amp;(p)-&gt;tasks);&t;&t;&t;&bslash;&n;&t;remove_parent(p);&t;&t;&t;&t;&t;&bslash;&n;&t;} while (0)
DECL|macro|SET_LINKS
mdefine_line|#define SET_LINKS(p) do {&t;&t;&t;&t;&t;&bslash;&n;&t;if (thread_group_leader(p))&t;&t;&t;&t;&bslash;&n;&t;&t;list_add_tail(&amp;(p)-&gt;tasks,&amp;init_task.tasks);&t;&bslash;&n;&t;add_parent(p, (p)-&gt;parent);&t;&t;&t;&t;&bslash;&n;&t;} while (0)
DECL|macro|next_task
mdefine_line|#define next_task(p)&t;list_entry((p)-&gt;tasks.next, struct task_struct, tasks)
DECL|macro|prev_task
mdefine_line|#define prev_task(p)&t;list_entry((p)-&gt;tasks.prev, struct task_struct, tasks)
DECL|macro|for_each_process
mdefine_line|#define for_each_process(p) &bslash;&n;&t;for (p = &amp;init_task ; (p = next_task(p)) != &amp;init_task ; )
multiline_comment|/*&n; * Careful: do_each_thread/while_each_thread is a double loop so&n; *          &squot;break&squot; will not work as expected - use goto instead.&n; */
DECL|macro|do_each_thread
mdefine_line|#define do_each_thread(g, t) &bslash;&n;&t;for (g = t = &amp;init_task ; (g = t = next_task(g)) != &amp;init_task ; ) do
DECL|macro|while_each_thread
mdefine_line|#define while_each_thread(g, t) &bslash;&n;&t;while ((t = next_thread(t)) != g)
r_extern
id|task_t
op_star
id|FASTCALL
c_func
(paren
id|next_thread
c_func
(paren
r_const
id|task_t
op_star
id|p
)paren
)paren
suffix:semicolon
DECL|macro|thread_group_leader
mdefine_line|#define thread_group_leader(p)&t;(p-&gt;pid == p-&gt;tgid)
DECL|function|thread_group_empty
r_static
r_inline
r_int
id|thread_group_empty
c_func
(paren
id|task_t
op_star
id|p
)paren
(brace
r_return
id|list_empty
c_func
(paren
op_amp
id|p-&gt;pids
(braket
id|PIDTYPE_TGID
)braket
dot
id|pid_list
)paren
suffix:semicolon
)brace
DECL|macro|delay_group_leader
mdefine_line|#define delay_group_leader(p) &bslash;&n;&t;&t;(thread_group_leader(p) &amp;&amp; !thread_group_empty(p))
r_extern
r_void
id|unhash_process
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
suffix:semicolon
multiline_comment|/*&n; * Protects -&gt;fs, -&gt;files, -&gt;mm, -&gt;ptrace, -&gt;group_info, -&gt;comm, keyring&n; * subscriptions and synchronises with wait4().  Also used in procfs.&n; *&n; * Nests both inside and outside of read_lock(&amp;tasklist_lock).&n; * It must not be nested with write_lock_irq(&amp;tasklist_lock),&n; * neither inside nor outside.&n; */
DECL|function|task_lock
r_static
r_inline
r_void
id|task_lock
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|p-&gt;alloc_lock
)paren
suffix:semicolon
)brace
DECL|function|task_unlock
r_static
r_inline
r_void
id|task_unlock
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|p-&gt;alloc_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* set thread flags in other task&squot;s structures&n; * - see asm/thread_info.h for TIF_xxxx flags available&n; */
DECL|function|set_tsk_thread_flag
r_static
r_inline
r_void
id|set_tsk_thread_flag
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
id|flag
)paren
(brace
id|set_ti_thread_flag
c_func
(paren
id|tsk-&gt;thread_info
comma
id|flag
)paren
suffix:semicolon
)brace
DECL|function|clear_tsk_thread_flag
r_static
r_inline
r_void
id|clear_tsk_thread_flag
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
id|flag
)paren
(brace
id|clear_ti_thread_flag
c_func
(paren
id|tsk-&gt;thread_info
comma
id|flag
)paren
suffix:semicolon
)brace
DECL|function|test_and_set_tsk_thread_flag
r_static
r_inline
r_int
id|test_and_set_tsk_thread_flag
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
id|flag
)paren
(brace
r_return
id|test_and_set_ti_thread_flag
c_func
(paren
id|tsk-&gt;thread_info
comma
id|flag
)paren
suffix:semicolon
)brace
DECL|function|test_and_clear_tsk_thread_flag
r_static
r_inline
r_int
id|test_and_clear_tsk_thread_flag
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
id|flag
)paren
(brace
r_return
id|test_and_clear_ti_thread_flag
c_func
(paren
id|tsk-&gt;thread_info
comma
id|flag
)paren
suffix:semicolon
)brace
DECL|function|test_tsk_thread_flag
r_static
r_inline
r_int
id|test_tsk_thread_flag
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
id|flag
)paren
(brace
r_return
id|test_ti_thread_flag
c_func
(paren
id|tsk-&gt;thread_info
comma
id|flag
)paren
suffix:semicolon
)brace
DECL|function|set_tsk_need_resched
r_static
r_inline
r_void
id|set_tsk_need_resched
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
id|set_tsk_thread_flag
c_func
(paren
id|tsk
comma
id|TIF_NEED_RESCHED
)paren
suffix:semicolon
)brace
DECL|function|clear_tsk_need_resched
r_static
r_inline
r_void
id|clear_tsk_need_resched
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
id|clear_tsk_thread_flag
c_func
(paren
id|tsk
comma
id|TIF_NEED_RESCHED
)paren
suffix:semicolon
)brace
DECL|function|signal_pending
r_static
r_inline
r_int
id|signal_pending
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_return
id|unlikely
c_func
(paren
id|test_tsk_thread_flag
c_func
(paren
id|p
comma
id|TIF_SIGPENDING
)paren
)paren
suffix:semicolon
)brace
DECL|function|need_resched
r_static
r_inline
r_int
id|need_resched
c_func
(paren
r_void
)paren
(brace
r_return
id|unlikely
c_func
(paren
id|test_thread_flag
c_func
(paren
id|TIF_NEED_RESCHED
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * cond_resched() and cond_resched_lock(): latency reduction via&n; * explicit rescheduling in places that are safe. The return&n; * value indicates whether a reschedule was done in fact.&n; * cond_resched_lock() will drop the spinlock before scheduling,&n; * cond_resched_softirq() will enable bhs before scheduling.&n; */
r_extern
r_int
id|cond_resched
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|cond_resched_lock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
suffix:semicolon
r_extern
r_int
id|cond_resched_softirq
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * Does a critical section need to be broken due to another&n; * task waiting?:&n; */
macro_line|#if defined(CONFIG_PREEMPT) &amp;&amp; defined(CONFIG_SMP)
DECL|macro|need_lockbreak
macro_line|# define need_lockbreak(lock) ((lock)-&gt;break_lock)
macro_line|#else
DECL|macro|need_lockbreak
macro_line|# define need_lockbreak(lock) 0
macro_line|#endif
multiline_comment|/*&n; * Does a critical section need to be broken due to another&n; * task waiting or preemption being signalled:&n; */
DECL|function|lock_need_resched
r_static
r_inline
r_int
id|lock_need_resched
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
r_if
c_cond
(paren
id|need_lockbreak
c_func
(paren
id|lock
)paren
op_logical_or
id|need_resched
c_func
(paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Reevaluate whether the task has signals pending delivery.&n;   This is required every time the blocked sigset_t changes.&n;   callers must hold sighand-&gt;siglock.  */
r_extern
id|FASTCALL
c_func
(paren
r_void
id|recalc_sigpending_tsk
c_func
(paren
r_struct
id|task_struct
op_star
id|t
)paren
)paren
suffix:semicolon
r_extern
r_void
id|recalc_sigpending
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|signal_wake_up
c_func
(paren
r_struct
id|task_struct
op_star
id|t
comma
r_int
id|resume_stopped
)paren
suffix:semicolon
multiline_comment|/*&n; * Wrappers for p-&gt;thread_info-&gt;cpu access. No-op on UP.&n; */
macro_line|#ifdef CONFIG_SMP
DECL|function|task_cpu
r_static
r_inline
r_int
r_int
id|task_cpu
c_func
(paren
r_const
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_return
id|p-&gt;thread_info-&gt;cpu
suffix:semicolon
)brace
DECL|function|set_task_cpu
r_static
r_inline
r_void
id|set_task_cpu
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
r_int
id|cpu
)paren
(brace
id|p-&gt;thread_info-&gt;cpu
op_assign
id|cpu
suffix:semicolon
)brace
macro_line|#else
DECL|function|task_cpu
r_static
r_inline
r_int
r_int
id|task_cpu
c_func
(paren
r_const
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|set_task_cpu
r_static
r_inline
r_void
id|set_task_cpu
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
r_int
id|cpu
)paren
(brace
)brace
macro_line|#endif /* CONFIG_SMP */
macro_line|#ifdef HAVE_ARCH_PICK_MMAP_LAYOUT
r_extern
r_void
id|arch_pick_mmap_layout
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
suffix:semicolon
macro_line|#else
DECL|function|arch_pick_mmap_layout
r_static
r_inline
r_void
id|arch_pick_mmap_layout
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
id|mm-&gt;mmap_base
op_assign
id|TASK_UNMAPPED_BASE
suffix:semicolon
id|mm-&gt;get_unmapped_area
op_assign
id|arch_get_unmapped_area
suffix:semicolon
id|mm-&gt;unmap_area
op_assign
id|arch_unmap_area
suffix:semicolon
)brace
macro_line|#endif
r_extern
r_int
id|sched_setaffinity
c_func
(paren
id|pid_t
id|pid
comma
id|cpumask_t
id|new_mask
)paren
suffix:semicolon
r_extern
r_int
id|sched_getaffinity
c_func
(paren
id|pid_t
id|pid
comma
id|cpumask_t
op_star
id|mask
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MAGIC_SYSRQ
r_extern
r_void
id|normalize_rt_tasks
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* try_to_freeze&n; *&n; * Checks whether we need to enter the refrigerator&n; * and returns 1 if we did so.&n; */
macro_line|#ifdef CONFIG_PM
r_extern
r_void
id|refrigerator
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_extern
r_int
id|freeze_processes
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|thaw_processes
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|try_to_freeze
r_static
r_inline
r_int
id|try_to_freeze
c_func
(paren
r_int
r_int
id|refrigerator_flags
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|current-&gt;flags
op_amp
id|PF_FREEZE
)paren
)paren
(brace
id|refrigerator
c_func
(paren
id|refrigerator_flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#else
DECL|function|refrigerator
r_static
r_inline
r_void
id|refrigerator
c_func
(paren
r_int
r_int
id|flag
)paren
(brace
)brace
DECL|function|freeze_processes
r_static
r_inline
r_int
id|freeze_processes
c_func
(paren
r_void
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|thaw_processes
r_static
r_inline
r_void
id|thaw_processes
c_func
(paren
r_void
)paren
(brace
)brace
DECL|function|try_to_freeze
r_static
r_inline
r_int
id|try_to_freeze
c_func
(paren
r_int
r_int
id|refrigerator_flags
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PM */
macro_line|#endif /* __KERNEL__ */
macro_line|#endif
eof
