multiline_comment|/*&n; *&t;Definitions for the &squot;struct sk_buff&squot; memory handlers.&n; *&n; *&t;Authors:&n; *&t;&t;Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;Florian La Roche, &lt;rzsfl@rz.uni-sb.de&gt;&n; *&n; *&t;This program is free software; you can redistribute it and/or&n; *&t;modify it under the terms of the GNU General Public License&n; *&t;as published by the Free Software Foundation; either version&n; *&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#ifndef _LINUX_SKBUFF_H
DECL|macro|_LINUX_SKBUFF_H
mdefine_line|#define _LINUX_SKBUFF_H
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/cache.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/types.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/net.h&gt;
DECL|macro|HAVE_ALLOC_SKB
mdefine_line|#define HAVE_ALLOC_SKB&t;&t;/* For the drivers to know */
DECL|macro|HAVE_ALIGNABLE_SKB
mdefine_line|#define HAVE_ALIGNABLE_SKB&t;/* Ditto 8)&t;&t;   */
DECL|macro|SLAB_SKB
mdefine_line|#define SLAB_SKB &t;&t;/* Slabified skbuffs &t;   */
DECL|macro|CHECKSUM_NONE
mdefine_line|#define CHECKSUM_NONE 0
DECL|macro|CHECKSUM_HW
mdefine_line|#define CHECKSUM_HW 1
DECL|macro|CHECKSUM_UNNECESSARY
mdefine_line|#define CHECKSUM_UNNECESSARY 2
DECL|macro|SKB_DATA_ALIGN
mdefine_line|#define SKB_DATA_ALIGN(X)&t;(((X) + (SMP_CACHE_BYTES - 1)) &amp; &bslash;&n;&t;&t;&t;&t; ~(SMP_CACHE_BYTES - 1))
DECL|macro|SKB_MAX_ORDER
mdefine_line|#define SKB_MAX_ORDER(X, ORDER)&t;(((PAGE_SIZE &lt;&lt; (ORDER)) - (X) - &bslash;&n;&t;&t;&t;&t;  sizeof(struct skb_shared_info)) &amp; &bslash;&n;&t;&t;&t;&t;  ~(SMP_CACHE_BYTES - 1))
DECL|macro|SKB_MAX_HEAD
mdefine_line|#define SKB_MAX_HEAD(X)&t;&t;(SKB_MAX_ORDER((X), 0))
DECL|macro|SKB_MAX_ALLOC
mdefine_line|#define SKB_MAX_ALLOC&t;&t;(SKB_MAX_ORDER(0, 2))
multiline_comment|/* A. Checksumming of received packets by device.&n; *&n; *&t;NONE: device failed to checksum this packet.&n; *&t;&t;skb-&gt;csum is undefined.&n; *&n; *&t;UNNECESSARY: device parsed packet and wouldbe verified checksum.&n; *&t;&t;skb-&gt;csum is undefined.&n; *&t;      It is bad option, but, unfortunately, many of vendors do this.&n; *&t;      Apparently with secret goal to sell you new device, when you&n; *&t;      will add new protocol to your host. F.e. IPv6. 8)&n; *&n; *&t;HW: the most generic way. Device supplied checksum of _all_&n; *&t;    the packet as seen by netif_rx in skb-&gt;csum.&n; *&t;    NOTE: Even if device supports only some protocols, but&n; *&t;    is able to produce some skb-&gt;csum, it MUST use HW,&n; *&t;    not UNNECESSARY.&n; *&n; * B. Checksumming on output.&n; *&n; *&t;NONE: skb is checksummed by protocol or csum is not required.&n; *&n; *&t;HW: device is required to csum packet as seen by hard_start_xmit&n; *&t;from skb-&gt;h.raw to the end and to record the checksum&n; *&t;at skb-&gt;h.raw+skb-&gt;csum.&n; *&n; *&t;Device must show its capabilities in dev-&gt;features, set&n; *&t;at device setup time.&n; *&t;NETIF_F_HW_CSUM&t;- it is clever device, it is able to checksum&n; *&t;&t;&t;  everything.&n; *&t;NETIF_F_NO_CSUM - loopback or reliable single hop media.&n; *&t;NETIF_F_IP_CSUM - device is dumb. It is able to csum only&n; *&t;&t;&t;  TCP/UDP over IPv4. Sigh. Vendors like this&n; *&t;&t;&t;  way by an unknown reason. Though, see comment above&n; *&t;&t;&t;  about CHECKSUM_UNNECESSARY. 8)&n; *&n; *&t;Any questions? No questions, good. &t;&t;--ANK&n; */
macro_line|#ifdef __i386__
DECL|macro|NET_CALLER
mdefine_line|#define NET_CALLER(arg) (*(((void **)&amp;arg) - 1))
macro_line|#else
DECL|macro|NET_CALLER
mdefine_line|#define NET_CALLER(arg) __builtin_return_address(0)
macro_line|#endif
macro_line|#ifdef CONFIG_NETFILTER
DECL|struct|nf_conntrack
r_struct
id|nf_conntrack
(brace
DECL|member|use
id|atomic_t
id|use
suffix:semicolon
DECL|member|destroy
r_void
(paren
op_star
id|destroy
)paren
(paren
r_struct
id|nf_conntrack
op_star
)paren
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|nf_ct_info
r_struct
id|nf_ct_info
(brace
DECL|member|master
r_struct
id|nf_conntrack
op_star
id|master
suffix:semicolon
)brace
suffix:semicolon
macro_line|#if defined(CONFIG_BRIDGE) || defined(CONFIG_BRIDGE_MODULE)
DECL|struct|nf_bridge_info
r_struct
id|nf_bridge_info
(brace
DECL|member|use
id|atomic_t
id|use
suffix:semicolon
DECL|member|physindev
r_struct
id|net_device
op_star
id|physindev
suffix:semicolon
DECL|member|physoutdev
r_struct
id|net_device
op_star
id|physoutdev
suffix:semicolon
DECL|member|mask
r_int
r_int
id|mask
suffix:semicolon
DECL|member|hh
r_int
r_int
id|hh
(braket
l_int|16
op_div
r_sizeof
(paren
r_int
r_int
)paren
)braket
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
macro_line|#endif
DECL|struct|sk_buff_head
r_struct
id|sk_buff_head
(brace
multiline_comment|/* These two members must be first. */
DECL|member|next
r_struct
id|sk_buff
op_star
id|next
suffix:semicolon
DECL|member|prev
r_struct
id|sk_buff
op_star
id|prev
suffix:semicolon
DECL|member|qlen
id|__u32
id|qlen
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
)brace
suffix:semicolon
r_struct
id|sk_buff
suffix:semicolon
multiline_comment|/* To allow 64K frame to be packed as single skb without frag_list */
DECL|macro|MAX_SKB_FRAGS
mdefine_line|#define MAX_SKB_FRAGS (65536/PAGE_SIZE + 2)
DECL|typedef|skb_frag_t
r_typedef
r_struct
id|skb_frag_struct
id|skb_frag_t
suffix:semicolon
DECL|struct|skb_frag_struct
r_struct
id|skb_frag_struct
(brace
DECL|member|page
r_struct
id|page
op_star
id|page
suffix:semicolon
DECL|member|page_offset
id|__u16
id|page_offset
suffix:semicolon
DECL|member|size
id|__u16
id|size
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* This data is invariant across clones and lives at&n; * the end of the header data, ie. at skb-&gt;end.&n; */
DECL|struct|skb_shared_info
r_struct
id|skb_shared_info
(brace
DECL|member|dataref
id|atomic_t
id|dataref
suffix:semicolon
DECL|member|nr_frags
r_int
r_int
id|nr_frags
suffix:semicolon
DECL|member|tso_size
r_int
r_int
id|tso_size
suffix:semicolon
DECL|member|tso_segs
r_int
r_int
id|tso_segs
suffix:semicolon
DECL|member|frag_list
r_struct
id|sk_buff
op_star
id|frag_list
suffix:semicolon
DECL|member|frags
id|skb_frag_t
id|frags
(braket
id|MAX_SKB_FRAGS
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/** &n; *&t;struct sk_buff - socket buffer&n; *&t;@next: Next buffer in list&n; *&t;@prev: Previous buffer in list&n; *&t;@list: List we are on&n; *&t;@sk: Socket we are owned by&n; *&t;@stamp: Time we arrived&n; *&t;@dev: Device we arrived on/are leaving by&n; *&t;@h: Transport layer header&n; *&t;@nh: Network layer header&n; *&t;@mac: Link layer header&n; *&t;@dst: FIXME: Describe this field&n; *&t;@cb: Control buffer. Free for use by every layer. Put private vars here&n; *&t;@len: Length of actual data&n; *&t;@data_len: Data length&n; *&t;@csum: Checksum&n; *&t;@__unused: Dead field, may be reused&n; *&t;@cloned: Head may be cloned (check refcnt to be sure)&n; *&t;@pkt_type: Packet class&n; *&t;@ip_summed: Driver fed us an IP checksum&n; *&t;@priority: Packet queueing priority&n; *&t;@users: User count - see {datagram,tcp}.c&n; *&t;@protocol: Packet protocol from driver&n; *&t;@security: Security level of packet&n; *&t;@truesize: Buffer size &n; *&t;@head: Head of buffer&n; *&t;@data: Data head pointer&n; *&t;@tail: Tail pointer&n; *&t;@end: End pointer&n; *&t;@destructor: Destruct function&n; *&t;@nfmark: Can be used for communication between hooks&n; *&t;@nfcache: Cache info&n; *&t;@nfct: Associated connection, if any&n; *&t;@nf_debug: Netfilter debugging&n; *&t;@nf_bridge: Saved data about a bridged frame - see br_netfilter.c&n; *&t;@tc_index: Traffic control index&n; */
DECL|struct|sk_buff
r_struct
id|sk_buff
(brace
multiline_comment|/* These two members must be first. */
DECL|member|next
r_struct
id|sk_buff
op_star
id|next
suffix:semicolon
DECL|member|prev
r_struct
id|sk_buff
op_star
id|prev
suffix:semicolon
DECL|member|list
r_struct
id|sk_buff_head
op_star
id|list
suffix:semicolon
DECL|member|sk
r_struct
id|sock
op_star
id|sk
suffix:semicolon
DECL|member|stamp
r_struct
id|timeval
id|stamp
suffix:semicolon
DECL|member|dev
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_union
(brace
DECL|member|th
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
DECL|member|uh
r_struct
id|udphdr
op_star
id|uh
suffix:semicolon
DECL|member|icmph
r_struct
id|icmphdr
op_star
id|icmph
suffix:semicolon
DECL|member|igmph
r_struct
id|igmphdr
op_star
id|igmph
suffix:semicolon
DECL|member|ipiph
r_struct
id|iphdr
op_star
id|ipiph
suffix:semicolon
DECL|member|raw
r_int
r_char
op_star
id|raw
suffix:semicolon
DECL|member|h
)brace
id|h
suffix:semicolon
r_union
(brace
DECL|member|iph
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
DECL|member|ipv6h
r_struct
id|ipv6hdr
op_star
id|ipv6h
suffix:semicolon
DECL|member|arph
r_struct
id|arphdr
op_star
id|arph
suffix:semicolon
DECL|member|raw
r_int
r_char
op_star
id|raw
suffix:semicolon
DECL|member|nh
)brace
id|nh
suffix:semicolon
r_union
(brace
DECL|member|ethernet
r_struct
id|ethhdr
op_star
id|ethernet
suffix:semicolon
DECL|member|raw
r_int
r_char
op_star
id|raw
suffix:semicolon
DECL|member|mac
)brace
id|mac
suffix:semicolon
DECL|member|dst
r_struct
id|dst_entry
op_star
id|dst
suffix:semicolon
DECL|member|sp
r_struct
id|sec_path
op_star
id|sp
suffix:semicolon
multiline_comment|/*&n;&t; * This is the control buffer. It is free to use for every&n;&t; * layer. Please put your private variables there. If you&n;&t; * want to keep them across layers you have to do a skb_clone()&n;&t; * first. This is owned by whoever has the skb queued ATM.&n;&t; */
DECL|member|cb
r_char
id|cb
(braket
l_int|48
)braket
suffix:semicolon
DECL|member|len
r_int
r_int
id|len
comma
DECL|member|data_len
id|data_len
comma
DECL|member|csum
id|csum
suffix:semicolon
DECL|member|__unused
r_int
r_char
id|__unused
comma
DECL|member|cloned
id|cloned
comma
DECL|member|pkt_type
id|pkt_type
comma
DECL|member|ip_summed
id|ip_summed
suffix:semicolon
DECL|member|priority
id|__u32
id|priority
suffix:semicolon
DECL|member|users
id|atomic_t
id|users
suffix:semicolon
DECL|member|protocol
r_int
r_int
id|protocol
comma
DECL|member|security
id|security
suffix:semicolon
DECL|member|truesize
r_int
r_int
id|truesize
suffix:semicolon
DECL|member|head
r_int
r_char
op_star
id|head
comma
DECL|member|data
op_star
id|data
comma
DECL|member|tail
op_star
id|tail
comma
DECL|member|end
op_star
id|end
suffix:semicolon
DECL|member|destructor
r_void
(paren
op_star
id|destructor
)paren
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER
DECL|member|nfmark
r_int
r_int
id|nfmark
suffix:semicolon
DECL|member|nfcache
id|__u32
id|nfcache
suffix:semicolon
DECL|member|nfct
r_struct
id|nf_ct_info
op_star
id|nfct
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
DECL|member|nf_debug
r_int
r_int
id|nf_debug
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_BRIDGE) || defined(CONFIG_BRIDGE_MODULE)
DECL|member|nf_bridge
r_struct
id|nf_bridge_info
op_star
id|nf_bridge
suffix:semicolon
macro_line|#endif
macro_line|#endif /* CONFIG_NETFILTER */
macro_line|#if defined(CONFIG_HIPPI)
r_union
(brace
DECL|member|ifield
id|__u32
id|ifield
suffix:semicolon
DECL|member|private
)brace
r_private
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCHED
DECL|member|tc_index
id|__u32
id|tc_index
suffix:semicolon
multiline_comment|/* traffic control index */
macro_line|#endif
)brace
suffix:semicolon
DECL|macro|SK_WMEM_MAX
mdefine_line|#define SK_WMEM_MAX&t;65535
DECL|macro|SK_RMEM_MAX
mdefine_line|#define SK_RMEM_MAX&t;65535
macro_line|#ifdef __KERNEL__
multiline_comment|/*&n; *&t;Handling routines are only of interest to the kernel&n; */
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/system.h&gt;
r_extern
r_void
id|__kfree_skb
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|alloc_skb
c_func
(paren
r_int
r_int
id|size
comma
r_int
id|priority
)paren
suffix:semicolon
r_extern
r_void
id|kfree_skbmem
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|skb_clone
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|priority
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|skb_copy
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|priority
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|pskb_copy
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|gfp_mask
)paren
suffix:semicolon
r_extern
r_int
id|pskb_expand_head
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|nhead
comma
r_int
id|ntail
comma
r_int
id|gfp_mask
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|skb_realloc_headroom
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|headroom
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|skb_copy_expand
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|newheadroom
comma
r_int
id|newtailroom
comma
r_int
id|priority
)paren
suffix:semicolon
DECL|macro|dev_kfree_skb
mdefine_line|#define dev_kfree_skb(a)&t;kfree_skb(a)
r_extern
r_void
id|skb_over_panic
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|len
comma
r_void
op_star
id|here
)paren
suffix:semicolon
r_extern
r_void
id|skb_under_panic
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|len
comma
r_void
op_star
id|here
)paren
suffix:semicolon
multiline_comment|/* Internal */
DECL|macro|skb_shinfo
mdefine_line|#define skb_shinfo(SKB)&t;&t;((struct skb_shared_info *)((SKB)-&gt;end))
multiline_comment|/**&n; *&t;skb_queue_empty - check if a queue is empty&n; *&t;@list: queue head&n; *&n; *&t;Returns true if the queue is empty, false otherwise.&n; */
DECL|function|skb_queue_empty
r_static
r_inline
r_int
id|skb_queue_empty
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
r_return
id|list-&gt;next
op_eq
(paren
r_struct
id|sk_buff
op_star
)paren
id|list
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_get - reference buffer&n; *&t;@skb: buffer to reference&n; *&n; *&t;Makes another reference to a socket buffer and returns a pointer&n; *&t;to the buffer.&n; */
DECL|function|skb_get
r_static
r_inline
r_struct
id|sk_buff
op_star
id|skb_get
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|skb-&gt;users
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/*&n; * If users == 1, we are the only owner and are can avoid redundant&n; * atomic change.&n; */
multiline_comment|/**&n; *&t;kfree_skb - free an sk_buff&n; *&t;@skb: buffer to free&n; *&n; *&t;Drop a reference to the buffer and free it if the usage count has&n; *&t;hit zero.&n; */
DECL|function|kfree_skb
r_static
r_inline
r_void
id|kfree_skb
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|skb-&gt;users
)paren
op_eq
l_int|1
op_logical_or
id|atomic_dec_and_test
c_func
(paren
op_amp
id|skb-&gt;users
)paren
)paren
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* Use this if you didn&squot;t touch the skb state [for fast switching] */
DECL|function|kfree_skb_fast
r_static
r_inline
r_void
id|kfree_skb_fast
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|skb-&gt;users
)paren
op_eq
l_int|1
op_logical_or
id|atomic_dec_and_test
c_func
(paren
op_amp
id|skb-&gt;users
)paren
)paren
id|kfree_skbmem
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_cloned - is the buffer a clone&n; *&t;@skb: buffer to check&n; *&n; *&t;Returns true if the buffer was generated with skb_clone() and is&n; *&t;one of multiple shared copies of the buffer. Cloned buffers are&n; *&t;shared data so must not be written to under normal circumstances.&n; */
DECL|function|skb_cloned
r_static
r_inline
r_int
id|skb_cloned
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_return
id|skb-&gt;cloned
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|dataref
)paren
op_ne
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_shared - is the buffer shared&n; *&t;@skb: buffer to check&n; *&n; *&t;Returns true if more than one person has a reference to this&n; *&t;buffer.&n; */
DECL|function|skb_shared
r_static
r_inline
r_int
id|skb_shared
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_return
id|atomic_read
c_func
(paren
op_amp
id|skb-&gt;users
)paren
op_ne
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_share_check - check if buffer is shared and if so clone it&n; *&t;@skb: buffer to check&n; *&t;@pri: priority for memory allocation&n; *&n; *&t;If the buffer is shared the buffer is cloned and the old copy&n; *&t;drops a reference. A new clone with a single reference is returned.&n; *&t;If the buffer is not shared the original buffer is returned. When&n; *&t;being called from interrupt status or with spinlocks held pri must&n; *&t;be GFP_ATOMIC.&n; *&n; *&t;NULL is returned on a memory allocation failure.&n; */
DECL|function|skb_share_check
r_static
r_inline
r_struct
id|sk_buff
op_star
id|skb_share_check
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|pri
)paren
(brace
r_if
c_cond
(paren
id|skb_shared
c_func
(paren
id|skb
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|nskb
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|pri
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb
op_assign
id|nskb
suffix:semicolon
)brace
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Copy shared buffers into a new sk_buff. We effectively do COW on&n; *&t;packets to handle cases where we have a local reader and forward&n; *&t;and a couple of other messy ones. The normal one is tcpdumping&n; *&t;a packet thats being forwarded.&n; */
multiline_comment|/**&n; *&t;skb_unshare - make a copy of a shared buffer&n; *&t;@skb: buffer to check&n; *&t;@pri: priority for memory allocation&n; *&n; *&t;If the socket buffer is a clone then this function creates a new&n; *&t;copy of the data, drops a reference count on the old copy and returns&n; *&t;the new copy with the reference count at 1. If the buffer is not a clone&n; *&t;the original buffer is returned. When called with a spinlock held or&n; *&t;from interrupt state @pri must be %GFP_ATOMIC&n; *&n; *&t;%NULL is returned on a memory allocation failure.&n; */
DECL|function|skb_unshare
r_static
r_inline
r_struct
id|sk_buff
op_star
id|skb_unshare
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|pri
)paren
(brace
r_if
c_cond
(paren
id|skb_cloned
c_func
(paren
id|skb
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|nskb
op_assign
id|skb_copy
c_func
(paren
id|skb
comma
id|pri
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Free our shared copy */
id|skb
op_assign
id|nskb
suffix:semicolon
)brace
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_peek&n; *&t;@list_: list to peek at&n; *&n; *&t;Peek an &amp;sk_buff. Unlike most other operations you _MUST_&n; *&t;be careful with this one. A peek leaves the buffer on the&n; *&t;list and someone else may run off with it. You must hold&n; *&t;the appropriate locks or have a private queue to do this.&n; *&n; *&t;Returns %NULL for an empty list or a pointer to the head element.&n; *&t;The reference count is not incremented and the reference is therefore&n; *&t;volatile. Use with caution.&n; */
DECL|function|skb_peek
r_static
r_inline
r_struct
id|sk_buff
op_star
id|skb_peek
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list_
)paren
(brace
r_struct
id|sk_buff
op_star
id|list
op_assign
(paren
(paren
r_struct
id|sk_buff
op_star
)paren
id|list_
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
r_if
c_cond
(paren
id|list
op_eq
(paren
r_struct
id|sk_buff
op_star
)paren
id|list_
)paren
id|list
op_assign
l_int|NULL
suffix:semicolon
r_return
id|list
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_peek_tail&n; *&t;@list_: list to peek at&n; *&n; *&t;Peek an &amp;sk_buff. Unlike most other operations you _MUST_&n; *&t;be careful with this one. A peek leaves the buffer on the&n; *&t;list and someone else may run off with it. You must hold&n; *&t;the appropriate locks or have a private queue to do this.&n; *&n; *&t;Returns %NULL for an empty list or a pointer to the tail element.&n; *&t;The reference count is not incremented and the reference is therefore&n; *&t;volatile. Use with caution.&n; */
DECL|function|skb_peek_tail
r_static
r_inline
r_struct
id|sk_buff
op_star
id|skb_peek_tail
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list_
)paren
(brace
r_struct
id|sk_buff
op_star
id|list
op_assign
(paren
(paren
r_struct
id|sk_buff
op_star
)paren
id|list_
)paren
op_member_access_from_pointer
id|prev
suffix:semicolon
r_if
c_cond
(paren
id|list
op_eq
(paren
r_struct
id|sk_buff
op_star
)paren
id|list_
)paren
id|list
op_assign
l_int|NULL
suffix:semicolon
r_return
id|list
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_queue_len&t;- get queue length&n; *&t;@list_: list to measure&n; *&n; *&t;Return the length of an &amp;sk_buff queue.&n; */
DECL|function|skb_queue_len
r_static
r_inline
id|__u32
id|skb_queue_len
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list_
)paren
(brace
r_return
id|list_-&gt;qlen
suffix:semicolon
)brace
DECL|function|skb_queue_head_init
r_static
r_inline
r_void
id|skb_queue_head_init
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
id|spin_lock_init
c_func
(paren
op_amp
id|list-&gt;lock
)paren
suffix:semicolon
id|list-&gt;prev
op_assign
id|list-&gt;next
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|list
suffix:semicolon
id|list-&gt;qlen
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Insert an sk_buff at the start of a list.&n; *&n; *&t;The &quot;__skb_xxxx()&quot; functions are the non-atomic ones that&n; *&t;can only be called with interrupts disabled.&n; */
multiline_comment|/**&n; *&t;__skb_queue_head - queue a buffer at the list head&n; *&t;@list: list to use&n; *&t;@newsk: buffer to queue&n; *&n; *&t;Queue a buffer at the start of a list. This function takes no locks&n; *&t;and you must therefore hold required locks before calling it.&n; *&n; *&t;A buffer cannot be placed on two lists at the same time.&n; */
DECL|function|__skb_queue_head
r_static
r_inline
r_void
id|__skb_queue_head
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
comma
r_struct
id|sk_buff
op_star
id|newsk
)paren
(brace
r_struct
id|sk_buff
op_star
id|prev
comma
op_star
id|next
suffix:semicolon
id|newsk-&gt;list
op_assign
id|list
suffix:semicolon
id|list-&gt;qlen
op_increment
suffix:semicolon
id|prev
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|list
suffix:semicolon
id|next
op_assign
id|prev-&gt;next
suffix:semicolon
id|newsk-&gt;next
op_assign
id|next
suffix:semicolon
id|newsk-&gt;prev
op_assign
id|prev
suffix:semicolon
id|next-&gt;prev
op_assign
id|prev-&gt;next
op_assign
id|newsk
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_queue_head - queue a buffer at the list head&n; *&t;@list: list to use&n; *&t;@newsk: buffer to queue&n; *&n; *&t;Queue a buffer at the start of the list. This function takes the&n; *&t;list lock and can be used safely with other locking &amp;sk_buff functions&n; *&t;safely.&n; *&n; *&t;A buffer cannot be placed on two lists at the same time.&n; */
DECL|function|skb_queue_head
r_static
r_inline
r_void
id|skb_queue_head
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
comma
r_struct
id|sk_buff
op_star
id|newsk
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__skb_queue_head
c_func
(paren
id|list
comma
id|newsk
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;__skb_queue_tail - queue a buffer at the list tail&n; *&t;@list: list to use&n; *&t;@newsk: buffer to queue&n; *&n; *&t;Queue a buffer at the end of a list. This function takes no locks&n; *&t;and you must therefore hold required locks before calling it.&n; *&n; *&t;A buffer cannot be placed on two lists at the same time.&n; */
DECL|function|__skb_queue_tail
r_static
r_inline
r_void
id|__skb_queue_tail
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
comma
r_struct
id|sk_buff
op_star
id|newsk
)paren
(brace
r_struct
id|sk_buff
op_star
id|prev
comma
op_star
id|next
suffix:semicolon
id|newsk-&gt;list
op_assign
id|list
suffix:semicolon
id|list-&gt;qlen
op_increment
suffix:semicolon
id|next
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|list
suffix:semicolon
id|prev
op_assign
id|next-&gt;prev
suffix:semicolon
id|newsk-&gt;next
op_assign
id|next
suffix:semicolon
id|newsk-&gt;prev
op_assign
id|prev
suffix:semicolon
id|next-&gt;prev
op_assign
id|prev-&gt;next
op_assign
id|newsk
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_queue_tail - queue a buffer at the list tail&n; *&t;@list: list to use&n; *&t;@newsk: buffer to queue&n; *&n; *&t;Queue a buffer at the tail of the list. This function takes the&n; *&t;list lock and can be used safely with other locking &amp;sk_buff functions&n; *&t;safely.&n; *&n; *&t;A buffer cannot be placed on two lists at the same time.&n; */
DECL|function|skb_queue_tail
r_static
r_inline
r_void
id|skb_queue_tail
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
comma
r_struct
id|sk_buff
op_star
id|newsk
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__skb_queue_tail
c_func
(paren
id|list
comma
id|newsk
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;__skb_dequeue - remove from the head of the queue&n; *&t;@list: list to dequeue from&n; *&n; *&t;Remove the head of the list. This function does not take any locks&n; *&t;so must be used with appropriate locks held only. The head item is&n; *&t;returned or %NULL if the list is empty.&n; */
DECL|function|__skb_dequeue
r_static
r_inline
r_struct
id|sk_buff
op_star
id|__skb_dequeue
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
r_struct
id|sk_buff
op_star
id|next
comma
op_star
id|prev
comma
op_star
id|result
suffix:semicolon
id|prev
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|list
suffix:semicolon
id|next
op_assign
id|prev-&gt;next
suffix:semicolon
id|result
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|next
op_ne
id|prev
)paren
(brace
id|result
op_assign
id|next
suffix:semicolon
id|next
op_assign
id|next-&gt;next
suffix:semicolon
id|list-&gt;qlen
op_decrement
suffix:semicolon
id|next-&gt;prev
op_assign
id|prev
suffix:semicolon
id|prev-&gt;next
op_assign
id|next
suffix:semicolon
id|result-&gt;next
op_assign
id|result-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|result-&gt;list
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_dequeue - remove from the head of the queue&n; *&t;@list: list to dequeue from&n; *&n; *&t;Remove the head of the list. The list lock is taken so the function&n; *&t;may be used safely with other locking list functions. The head item is&n; *&t;returned or %NULL if the list is empty.&n; */
DECL|function|skb_dequeue
r_static
r_inline
r_struct
id|sk_buff
op_star
id|skb_dequeue
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sk_buff
op_star
id|result
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|result
op_assign
id|__skb_dequeue
c_func
(paren
id|list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Insert a packet on a list.&n; */
DECL|function|__skb_insert
r_static
r_inline
r_void
id|__skb_insert
c_func
(paren
r_struct
id|sk_buff
op_star
id|newsk
comma
r_struct
id|sk_buff
op_star
id|prev
comma
r_struct
id|sk_buff
op_star
id|next
comma
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
id|newsk-&gt;next
op_assign
id|next
suffix:semicolon
id|newsk-&gt;prev
op_assign
id|prev
suffix:semicolon
id|next-&gt;prev
op_assign
id|prev-&gt;next
op_assign
id|newsk
suffix:semicolon
id|newsk-&gt;list
op_assign
id|list
suffix:semicolon
id|list-&gt;qlen
op_increment
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_insert&t;-&t;insert a buffer&n; *&t;@old: buffer to insert before&n; *&t;@newsk: buffer to insert&n; *&n; *&t;Place a packet before a given packet in a list. The list locks are taken&n; *&t;and this function is atomic with respect to other list locked calls&n; *&t;A buffer cannot be placed on two lists at the same time.&n; */
DECL|function|skb_insert
r_static
r_inline
r_void
id|skb_insert
c_func
(paren
r_struct
id|sk_buff
op_star
id|old
comma
r_struct
id|sk_buff
op_star
id|newsk
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|old-&gt;list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__skb_insert
c_func
(paren
id|newsk
comma
id|old-&gt;prev
comma
id|old
comma
id|old-&gt;list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|old-&gt;list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Place a packet after a given packet in a list.&n; */
DECL|function|__skb_append
r_static
r_inline
r_void
id|__skb_append
c_func
(paren
r_struct
id|sk_buff
op_star
id|old
comma
r_struct
id|sk_buff
op_star
id|newsk
)paren
(brace
id|__skb_insert
c_func
(paren
id|newsk
comma
id|old
comma
id|old-&gt;next
comma
id|old-&gt;list
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_append&t;-&t;append a buffer&n; *&t;@old: buffer to insert after&n; *&t;@newsk: buffer to insert&n; *&n; *&t;Place a packet after a given packet in a list. The list locks are taken&n; *&t;and this function is atomic with respect to other list locked calls.&n; *&t;A buffer cannot be placed on two lists at the same time.&n; */
DECL|function|skb_append
r_static
r_inline
r_void
id|skb_append
c_func
(paren
r_struct
id|sk_buff
op_star
id|old
comma
r_struct
id|sk_buff
op_star
id|newsk
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|old-&gt;list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__skb_append
c_func
(paren
id|old
comma
id|newsk
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|old-&gt;list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * remove sk_buff from list. _Must_ be called atomically, and with&n; * the list known..&n; */
DECL|function|__skb_unlink
r_static
r_inline
r_void
id|__skb_unlink
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
r_struct
id|sk_buff
op_star
id|next
comma
op_star
id|prev
suffix:semicolon
id|list-&gt;qlen
op_decrement
suffix:semicolon
id|next
op_assign
id|skb-&gt;next
suffix:semicolon
id|prev
op_assign
id|skb-&gt;prev
suffix:semicolon
id|skb-&gt;next
op_assign
id|skb-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;list
op_assign
l_int|NULL
suffix:semicolon
id|next-&gt;prev
op_assign
id|prev
suffix:semicolon
id|prev-&gt;next
op_assign
id|next
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_unlink&t;-&t;remove a buffer from a list&n; *&t;@skb: buffer to remove&n; *&n; *&t;Place a packet after a given packet in a list. The list locks are taken&n; *&t;and this function is atomic with respect to other list locked calls&n; *&n; *&t;Works even without knowing the list it is sitting on, which can be&n; *&t;handy at times. It also means that THE LIST MUST EXIST when you&n; *&t;unlink. Thus a list must have its contents unlinked before it is&n; *&t;destroyed.&n; */
DECL|function|skb_unlink
r_static
r_inline
r_void
id|skb_unlink
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sk_buff_head
op_star
id|list
op_assign
id|skb-&gt;list
suffix:semicolon
r_if
c_cond
(paren
id|list
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;list
op_eq
id|list
)paren
id|__skb_unlink
c_func
(paren
id|skb
comma
id|skb-&gt;list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* XXX: more streamlined implementation */
multiline_comment|/**&n; *&t;__skb_dequeue_tail - remove from the tail of the queue&n; *&t;@list: list to dequeue from&n; *&n; *&t;Remove the tail of the list. This function does not take any locks&n; *&t;so must be used with appropriate locks held only. The tail item is&n; *&t;returned or %NULL if the list is empty.&n; */
DECL|function|__skb_dequeue_tail
r_static
r_inline
r_struct
id|sk_buff
op_star
id|__skb_dequeue_tail
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|skb_peek_tail
c_func
(paren
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|__skb_unlink
c_func
(paren
id|skb
comma
id|list
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_dequeue - remove from the head of the queue&n; *&t;@list: list to dequeue from&n; *&n; *&t;Remove the head of the list. The list lock is taken so the function&n; *&t;may be used safely with other locking list functions. The tail item is&n; *&t;returned or %NULL if the list is empty.&n; */
DECL|function|skb_dequeue_tail
r_static
r_inline
r_struct
id|sk_buff
op_star
id|skb_dequeue_tail
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|sk_buff
op_star
id|result
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|result
op_assign
id|__skb_dequeue_tail
c_func
(paren
id|list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|skb_is_nonlinear
r_static
r_inline
r_int
id|skb_is_nonlinear
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_return
id|skb-&gt;data_len
suffix:semicolon
)brace
DECL|function|skb_headlen
r_static
r_inline
r_int
id|skb_headlen
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_return
id|skb-&gt;len
op_minus
id|skb-&gt;data_len
suffix:semicolon
)brace
DECL|function|skb_pagelen
r_static
r_inline
r_int
id|skb_pagelen
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|i
comma
id|len
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
(paren
r_int
)paren
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|nr_frags
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
id|len
op_add_assign
id|skb_shinfo
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|frags
(braket
id|i
)braket
dot
id|size
suffix:semicolon
r_return
id|len
op_plus
id|skb_headlen
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
DECL|macro|SKB_PAGE_ASSERT
mdefine_line|#define SKB_PAGE_ASSERT(skb) do { if (skb_shinfo(skb)-&gt;nr_frags) &bslash;&n;&t;&t;&t;&t;&t;BUG(); } while (0)
DECL|macro|SKB_FRAG_ASSERT
mdefine_line|#define SKB_FRAG_ASSERT(skb) do { if (skb_shinfo(skb)-&gt;frag_list) &bslash;&n;&t;&t;&t;&t;&t;BUG(); } while (0)
DECL|macro|SKB_LINEAR_ASSERT
mdefine_line|#define SKB_LINEAR_ASSERT(skb) do { if (skb_is_nonlinear(skb)) &bslash;&n;&t;&t;&t;&t;&t;BUG(); } while (0)
multiline_comment|/*&n; *&t;Add data to an sk_buff&n; */
DECL|function|__skb_put
r_static
r_inline
r_int
r_char
op_star
id|__skb_put
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
r_int
r_char
op_star
id|tmp
op_assign
id|skb-&gt;tail
suffix:semicolon
id|SKB_LINEAR_ASSERT
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb-&gt;tail
op_add_assign
id|len
suffix:semicolon
id|skb-&gt;len
op_add_assign
id|len
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_put - add data to a buffer&n; *&t;@skb: buffer to use&n; *&t;@len: amount of data to add&n; *&n; *&t;This function extends the used data area of the buffer. If this would&n; *&t;exceed the total buffer size the kernel will panic. A pointer to the&n; *&t;first byte of the extra data is returned.&n; */
DECL|function|skb_put
r_static
r_inline
r_int
r_char
op_star
id|skb_put
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
r_int
r_char
op_star
id|tmp
op_assign
id|skb-&gt;tail
suffix:semicolon
id|SKB_LINEAR_ASSERT
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb-&gt;tail
op_add_assign
id|len
suffix:semicolon
id|skb-&gt;len
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;tail
OG
id|skb-&gt;end
)paren
id|skb_over_panic
c_func
(paren
id|skb
comma
id|len
comma
id|current_text_addr
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
DECL|function|__skb_push
r_static
r_inline
r_int
r_char
op_star
id|__skb_push
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
id|skb-&gt;data
op_sub_assign
id|len
suffix:semicolon
id|skb-&gt;len
op_add_assign
id|len
suffix:semicolon
r_return
id|skb-&gt;data
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_push - add data to the start of a buffer&n; *&t;@skb: buffer to use&n; *&t;@len: amount of data to add&n; *&n; *&t;This function extends the used data area of the buffer at the buffer&n; *&t;start. If this would exceed the total buffer headroom the kernel will&n; *&t;panic. A pointer to the first byte of the extra data is returned.&n; */
DECL|function|skb_push
r_static
r_inline
r_int
r_char
op_star
id|skb_push
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
id|skb-&gt;data
op_sub_assign
id|len
suffix:semicolon
id|skb-&gt;len
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;data
OL
id|skb-&gt;head
)paren
id|skb_under_panic
c_func
(paren
id|skb
comma
id|len
comma
id|current_text_addr
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|skb-&gt;data
suffix:semicolon
)brace
DECL|function|__skb_pull
r_static
r_inline
r_char
op_star
id|__skb_pull
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
id|skb-&gt;len
op_sub_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
OL
id|skb-&gt;data_len
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
id|skb-&gt;data
op_add_assign
id|len
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_pull - remove data from the start of a buffer&n; *&t;@skb: buffer to use&n; *&t;@len: amount of data to remove&n; *&n; *&t;This function removes data from the start of a buffer, returning&n; *&t;the memory to the headroom. A pointer to the next data in the buffer&n; *&t;is returned. Once the data has been pulled future pushes will overwrite&n; *&t;the old data.&n; */
DECL|function|skb_pull
r_static
r_inline
r_int
r_char
op_star
id|skb_pull
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
r_return
(paren
id|len
OG
id|skb-&gt;len
)paren
ques
c_cond
l_int|NULL
suffix:colon
id|__skb_pull
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
)brace
r_extern
r_int
r_char
op_star
id|__pskb_pull_tail
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|delta
)paren
suffix:semicolon
DECL|function|__pskb_pull
r_static
r_inline
r_char
op_star
id|__pskb_pull
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
OG
id|skb_headlen
c_func
(paren
id|skb
)paren
op_logical_and
op_logical_neg
id|__pskb_pull_tail
c_func
(paren
id|skb
comma
id|len
op_minus
id|skb_headlen
c_func
(paren
id|skb
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|skb-&gt;len
op_sub_assign
id|len
suffix:semicolon
r_return
id|skb-&gt;data
op_add_assign
id|len
suffix:semicolon
)brace
DECL|function|pskb_pull
r_static
r_inline
r_int
r_char
op_star
id|pskb_pull
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
r_return
(paren
id|len
OG
id|skb-&gt;len
)paren
ques
c_cond
l_int|NULL
suffix:colon
id|__pskb_pull
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
)brace
DECL|function|pskb_may_pull
r_static
r_inline
r_int
id|pskb_may_pull
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
op_le
id|skb_headlen
c_func
(paren
id|skb
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|skb-&gt;len
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|__pskb_pull_tail
c_func
(paren
id|skb
comma
id|len
op_minus
id|skb_headlen
c_func
(paren
id|skb
)paren
)paren
op_ne
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_headroom - bytes at buffer head&n; *&t;@skb: buffer to check&n; *&n; *&t;Return the number of bytes of free space at the head of an &amp;sk_buff.&n; */
DECL|function|skb_headroom
r_static
r_inline
r_int
id|skb_headroom
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_return
id|skb-&gt;data
op_minus
id|skb-&gt;head
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_tailroom - bytes at buffer end&n; *&t;@skb: buffer to check&n; *&n; *&t;Return the number of bytes of free space at the tail of an sk_buff&n; */
DECL|function|skb_tailroom
r_static
r_inline
r_int
id|skb_tailroom
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_return
id|skb_is_nonlinear
c_func
(paren
id|skb
)paren
ques
c_cond
l_int|0
suffix:colon
id|skb-&gt;end
op_minus
id|skb-&gt;tail
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_reserve - adjust headroom&n; *&t;@skb: buffer to alter&n; *&t;@len: bytes to move&n; *&n; *&t;Increase the headroom of an empty &amp;sk_buff by reducing the tail&n; *&t;room. This is only allowed for an empty buffer.&n; */
DECL|function|skb_reserve
r_static
r_inline
r_void
id|skb_reserve
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
id|skb-&gt;data
op_add_assign
id|len
suffix:semicolon
id|skb-&gt;tail
op_add_assign
id|len
suffix:semicolon
)brace
r_extern
r_int
id|___pskb_trim
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
comma
r_int
id|realloc
)paren
suffix:semicolon
DECL|function|__skb_trim
r_static
r_inline
r_void
id|__skb_trim
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;data_len
)paren
(brace
id|skb-&gt;len
op_assign
id|len
suffix:semicolon
id|skb-&gt;tail
op_assign
id|skb-&gt;data
op_plus
id|len
suffix:semicolon
)brace
r_else
id|___pskb_trim
c_func
(paren
id|skb
comma
id|len
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_trim - remove end from a buffer&n; *&t;@skb: buffer to alter&n; *&t;@len: new length&n; *&n; *&t;Cut the length of a buffer down by removing data from the tail. If&n; *&t;the buffer is already under the length specified it is not modified.&n; */
DECL|function|skb_trim
r_static
r_inline
r_void
id|skb_trim
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;len
OG
id|len
)paren
id|__skb_trim
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
)brace
DECL|function|__pskb_trim
r_static
r_inline
r_int
id|__pskb_trim
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;data_len
)paren
(brace
id|skb-&gt;len
op_assign
id|len
suffix:semicolon
id|skb-&gt;tail
op_assign
id|skb-&gt;data
op_plus
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|___pskb_trim
c_func
(paren
id|skb
comma
id|len
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|pskb_trim
r_static
r_inline
r_int
id|pskb_trim
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
r_return
(paren
id|len
OL
id|skb-&gt;len
)paren
ques
c_cond
id|__pskb_trim
c_func
(paren
id|skb
comma
id|len
)paren
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_orphan - orphan a buffer&n; *&t;@skb: buffer to orphan&n; *&n; *&t;If a buffer currently has an owner then we call the owner&squot;s&n; *&t;destructor function and make the @skb unowned. The buffer continues&n; *&t;to exist but is no longer charged to its former owner.&n; */
DECL|function|skb_orphan
r_static
r_inline
r_void
id|skb_orphan
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;destructor
)paren
id|skb
op_member_access_from_pointer
id|destructor
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb-&gt;destructor
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_queue_purge - empty a list&n; *&t;@list: list to empty&n; *&n; *&t;Delete all buffers on an &amp;sk_buff list. Each buffer is removed from&n; *&t;the list and one reference dropped. This function takes the list&n; *&t;lock and is atomic with respect to other list locking functions.&n; */
DECL|function|skb_queue_purge
r_static
r_inline
r_void
id|skb_queue_purge
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
id|list
)paren
)paren
op_ne
l_int|NULL
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;__skb_queue_purge - empty a list&n; *&t;@list: list to empty&n; *&n; *&t;Delete all buffers on an &amp;sk_buff list. Each buffer is removed from&n; *&t;the list and one reference dropped. This function does not take the&n; *&t;list lock and the caller must hold the relevant locks to use it.&n; */
DECL|function|__skb_queue_purge
r_static
r_inline
r_void
id|__skb_queue_purge
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|__skb_dequeue
c_func
(paren
id|list
)paren
)paren
op_ne
l_int|NULL
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;__dev_alloc_skb - allocate an skbuff for sending&n; *&t;@length: length to allocate&n; *&t;@gfp_mask: get_free_pages mask, passed to alloc_skb&n; *&n; *&t;Allocate a new &amp;sk_buff and assign it a usage count of one. The&n; *&t;buffer has unspecified headroom built in. Users should allocate&n; *&t;the headroom they think they need without accounting for the&n; *&t;built in space. The built in space is used for optimisations.&n; *&n; *&t;%NULL is returned in there is no free memory.&n; */
DECL|function|__dev_alloc_skb
r_static
r_inline
r_struct
id|sk_buff
op_star
id|__dev_alloc_skb
c_func
(paren
r_int
r_int
id|length
comma
r_int
id|gfp_mask
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|length
op_plus
l_int|16
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|16
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;dev_alloc_skb - allocate an skbuff for sending&n; *&t;@length: length to allocate&n; *&n; *&t;Allocate a new &amp;sk_buff and assign it a usage count of one. The&n; *&t;buffer has unspecified headroom built in. Users should allocate&n; *&t;the headroom they think they need without accounting for the&n; *&t;built in space. The built in space is used for optimisations.&n; *&n; *&t;%NULL is returned in there is no free memory. Although this function&n; *&t;allocates memory it can be called from an interrupt.&n; */
DECL|function|dev_alloc_skb
r_static
r_inline
r_struct
id|sk_buff
op_star
id|dev_alloc_skb
c_func
(paren
r_int
r_int
id|length
)paren
(brace
r_return
id|__dev_alloc_skb
c_func
(paren
id|length
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_cow - copy header of skb when it is required&n; *&t;@skb: buffer to cow&n; *&t;@headroom: needed headroom&n; *&n; *&t;If the skb passed lacks sufficient headroom or its data part&n; *&t;is shared, data is reallocated. If reallocation fails, an error&n; *&t;is returned and original skb is not changed.&n; *&n; *&t;The result is skb with writable area skb-&gt;head...skb-&gt;tail&n; *&t;and at least @headroom of space at head.&n; */
DECL|function|skb_cow
r_static
r_inline
r_int
id|skb_cow
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|headroom
)paren
(brace
r_int
id|delta
op_assign
(paren
id|headroom
OG
l_int|16
ques
c_cond
id|headroom
suffix:colon
l_int|16
)paren
op_minus
id|skb_headroom
c_func
(paren
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta
OL
l_int|0
)paren
id|delta
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|delta
op_logical_or
id|skb_cloned
c_func
(paren
id|skb
)paren
)paren
r_return
id|pskb_expand_head
c_func
(paren
id|skb
comma
(paren
id|delta
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
comma
l_int|0
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_linearize - convert paged skb to linear one&n; *&t;@skb: buffer to linarize&n; *&t;@gfp: allocation mode&n; *&n; *&t;If there is no free memory -ENOMEM is returned, otherwise zero&n; *&t;is returned and the old skb data released.&n; */
r_int
id|skb_linearize
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|gfp
)paren
suffix:semicolon
DECL|function|kmap_skb_frag
r_static
r_inline
r_void
op_star
id|kmap_skb_frag
c_func
(paren
r_const
id|skb_frag_t
op_star
id|frag
)paren
(brace
macro_line|#ifdef CONFIG_HIGHMEM
r_if
c_cond
(paren
id|in_irq
c_func
(paren
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|local_bh_disable
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
id|kmap_atomic
c_func
(paren
id|frag-&gt;page
comma
id|KM_SKB_DATA_SOFTIRQ
)paren
suffix:semicolon
)brace
DECL|function|kunmap_skb_frag
r_static
r_inline
r_void
id|kunmap_skb_frag
c_func
(paren
r_void
op_star
id|vaddr
)paren
(brace
id|kunmap_atomic
c_func
(paren
id|vaddr
comma
id|KM_SKB_DATA_SOFTIRQ
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_HIGHMEM
id|local_bh_enable
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|macro|skb_queue_walk
mdefine_line|#define skb_queue_walk(queue, skb) &bslash;&n;&t;&t;for (skb = (queue)-&gt;next;&t;&t;&t;&bslash;&n;&t;&t;     (skb != (struct sk_buff *)(queue));&t;&bslash;&n;&t;&t;     skb = skb-&gt;next)
r_extern
r_struct
id|sk_buff
op_star
id|skb_recv_datagram
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
comma
r_int
id|noblock
comma
r_int
op_star
id|err
)paren
suffix:semicolon
r_extern
r_int
r_int
id|datagram_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|poll_table_struct
op_star
id|wait
)paren
suffix:semicolon
r_extern
r_int
id|skb_copy_datagram
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|from
comma
r_int
id|offset
comma
r_char
op_star
id|to
comma
r_int
id|size
)paren
suffix:semicolon
r_extern
r_int
id|skb_copy_datagram_iovec
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|from
comma
r_int
id|offset
comma
r_struct
id|iovec
op_star
id|to
comma
r_int
id|size
)paren
suffix:semicolon
r_extern
r_int
id|skb_copy_and_csum_datagram
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|offset
comma
id|u8
op_star
id|to
comma
r_int
id|len
comma
r_int
r_int
op_star
id|csump
)paren
suffix:semicolon
r_extern
r_int
id|skb_copy_and_csum_datagram_iovec
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|hlen
comma
r_struct
id|iovec
op_star
id|iov
)paren
suffix:semicolon
r_extern
r_void
id|skb_free_datagram
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_extern
r_int
r_int
id|skb_checksum
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|offset
comma
r_int
id|len
comma
r_int
r_int
id|csum
)paren
suffix:semicolon
r_extern
r_int
id|skb_copy_bits
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|offset
comma
r_void
op_star
id|to
comma
r_int
id|len
)paren
suffix:semicolon
r_extern
r_int
r_int
id|skb_copy_and_csum_bits
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|offset
comma
id|u8
op_star
id|to
comma
r_int
id|len
comma
r_int
r_int
id|csum
)paren
suffix:semicolon
r_extern
r_void
id|skb_copy_and_csum_dev
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
id|u8
op_star
id|to
)paren
suffix:semicolon
r_extern
r_void
id|skb_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|skb_add_mtu
c_func
(paren
r_int
id|mtu
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER
DECL|function|nf_conntrack_put
r_static
r_inline
r_void
id|nf_conntrack_put
c_func
(paren
r_struct
id|nf_ct_info
op_star
id|nfct
)paren
(brace
r_if
c_cond
(paren
id|nfct
op_logical_and
id|atomic_dec_and_test
c_func
(paren
op_amp
id|nfct-&gt;master-&gt;use
)paren
)paren
id|nfct-&gt;master
op_member_access_from_pointer
id|destroy
c_func
(paren
id|nfct-&gt;master
)paren
suffix:semicolon
)brace
DECL|function|nf_conntrack_get
r_static
r_inline
r_void
id|nf_conntrack_get
c_func
(paren
r_struct
id|nf_ct_info
op_star
id|nfct
)paren
(brace
r_if
c_cond
(paren
id|nfct
)paren
id|atomic_inc
c_func
(paren
op_amp
id|nfct-&gt;master-&gt;use
)paren
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_BRIDGE) || defined(CONFIG_BRIDGE_MODULE)
DECL|function|nf_bridge_put
r_static
r_inline
r_void
id|nf_bridge_put
c_func
(paren
r_struct
id|nf_bridge_info
op_star
id|nf_bridge
)paren
(brace
r_if
c_cond
(paren
id|nf_bridge
op_logical_and
id|atomic_dec_and_test
c_func
(paren
op_amp
id|nf_bridge-&gt;use
)paren
)paren
id|kfree
c_func
(paren
id|nf_bridge
)paren
suffix:semicolon
)brace
DECL|function|nf_bridge_get
r_static
r_inline
r_void
id|nf_bridge_get
c_func
(paren
r_struct
id|nf_bridge_info
op_star
id|nf_bridge
)paren
(brace
r_if
c_cond
(paren
id|nf_bridge
)paren
id|atomic_inc
c_func
(paren
op_amp
id|nf_bridge-&gt;use
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#endif
macro_line|#endif&t;/* __KERNEL__ */
macro_line|#endif&t;/* _LINUX_SKBUFF_H */
eof
