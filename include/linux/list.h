macro_line|#ifndef _LINUX_LIST_H
DECL|macro|_LINUX_LIST_H
mdefine_line|#define _LINUX_LIST_H
macro_line|#if defined(__KERNEL__) || defined(_LVM_H_INCLUDE)
macro_line|#include &lt;linux/prefetch.h&gt;
multiline_comment|/*&n; * Simple doubly linked list implementation.&n; *&n; * Some of the internal functions (&quot;__xxx&quot;) are useful when&n; * manipulating whole lists rather than single entries, as&n; * sometimes we already know the next/prev entries and we can&n; * generate better code by using them directly rather than&n; * using the generic single-entry routines.&n; */
DECL|struct|list_head
r_struct
id|list_head
(brace
DECL|member|next
DECL|member|prev
r_struct
id|list_head
op_star
id|next
comma
op_star
id|prev
suffix:semicolon
)brace
suffix:semicolon
DECL|typedef|list_t
r_typedef
r_struct
id|list_head
id|list_t
suffix:semicolon
DECL|macro|LIST_HEAD_INIT
mdefine_line|#define LIST_HEAD_INIT(name) { &amp;(name), &amp;(name) }
DECL|macro|LIST_HEAD
mdefine_line|#define LIST_HEAD(name) &bslash;&n;&t;list_t name = LIST_HEAD_INIT(name)
DECL|macro|INIT_LIST_HEAD
mdefine_line|#define INIT_LIST_HEAD(ptr) do { &bslash;&n;&t;(ptr)-&gt;next = (ptr); (ptr)-&gt;prev = (ptr); &bslash;&n;} while (0)
multiline_comment|/*&n; * Insert a new entry between two known consecutive entries. &n; *&n; * This is only for internal list manipulation where we know&n; * the prev/next entries already!&n; */
DECL|function|__list_add
r_static
r_inline
r_void
id|__list_add
c_func
(paren
id|list_t
op_star
r_new
comma
id|list_t
op_star
id|prev
comma
id|list_t
op_star
id|next
)paren
(brace
id|next-&gt;prev
op_assign
r_new
suffix:semicolon
r_new
op_member_access_from_pointer
id|next
op_assign
id|next
suffix:semicolon
r_new
op_member_access_from_pointer
id|prev
op_assign
id|prev
suffix:semicolon
id|prev-&gt;next
op_assign
r_new
suffix:semicolon
)brace
multiline_comment|/**&n; * list_add - add a new entry&n; * @new: new entry to be added&n; * @head: list head to add it after&n; *&n; * Insert a new entry after the specified head.&n; * This is good for implementing stacks.&n; */
DECL|function|list_add
r_static
r_inline
r_void
id|list_add
c_func
(paren
id|list_t
op_star
r_new
comma
id|list_t
op_star
id|head
)paren
(brace
id|__list_add
c_func
(paren
r_new
comma
id|head
comma
id|head-&gt;next
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * list_add_tail - add a new entry&n; * @new: new entry to be added&n; * @head: list head to add it before&n; *&n; * Insert a new entry before the specified head.&n; * This is useful for implementing queues.&n; */
DECL|function|list_add_tail
r_static
r_inline
r_void
id|list_add_tail
c_func
(paren
id|list_t
op_star
r_new
comma
id|list_t
op_star
id|head
)paren
(brace
id|__list_add
c_func
(paren
r_new
comma
id|head-&gt;prev
comma
id|head
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Delete a list entry by making the prev/next entries&n; * point to each other.&n; *&n; * This is only for internal list manipulation where we know&n; * the prev/next entries already!&n; */
DECL|function|__list_del
r_static
r_inline
r_void
id|__list_del
c_func
(paren
id|list_t
op_star
id|prev
comma
id|list_t
op_star
id|next
)paren
(brace
id|next-&gt;prev
op_assign
id|prev
suffix:semicolon
id|prev-&gt;next
op_assign
id|next
suffix:semicolon
)brace
multiline_comment|/**&n; * list_del - deletes entry from list.&n; * @entry: the element to delete from the list.&n; * Note: list_empty on entry does not return true after this, the entry is in an undefined state.&n; */
DECL|function|list_del
r_static
r_inline
r_void
id|list_del
c_func
(paren
id|list_t
op_star
id|entry
)paren
(brace
id|__list_del
c_func
(paren
id|entry-&gt;prev
comma
id|entry-&gt;next
)paren
suffix:semicolon
id|entry-&gt;next
op_assign
(paren
r_void
op_star
)paren
l_int|0
suffix:semicolon
id|entry-&gt;prev
op_assign
(paren
r_void
op_star
)paren
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * list_del_init - deletes entry from list and reinitialize it.&n; * @entry: the element to delete from the list.&n; */
DECL|function|list_del_init
r_static
r_inline
r_void
id|list_del_init
c_func
(paren
id|list_t
op_star
id|entry
)paren
(brace
id|__list_del
c_func
(paren
id|entry-&gt;prev
comma
id|entry-&gt;next
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * list_move - delete from one list and add as another&squot;s head&n; * @list: the entry to move&n; * @head: the head that will precede our entry&n; */
DECL|function|list_move
r_static
r_inline
r_void
id|list_move
c_func
(paren
id|list_t
op_star
id|list
comma
id|list_t
op_star
id|head
)paren
(brace
id|__list_del
c_func
(paren
id|list-&gt;prev
comma
id|list-&gt;next
)paren
suffix:semicolon
id|list_add
c_func
(paren
id|list
comma
id|head
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * list_move_tail - delete from one list and add as another&squot;s tail&n; * @list: the entry to move&n; * @head: the head that will follow our entry&n; */
DECL|function|list_move_tail
r_static
r_inline
r_void
id|list_move_tail
c_func
(paren
id|list_t
op_star
id|list
comma
id|list_t
op_star
id|head
)paren
(brace
id|__list_del
c_func
(paren
id|list-&gt;prev
comma
id|list-&gt;next
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
id|list
comma
id|head
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * list_empty - tests whether a list is empty&n; * @head: the list to test.&n; */
DECL|function|list_empty
r_static
r_inline
r_int
id|list_empty
c_func
(paren
id|list_t
op_star
id|head
)paren
(brace
r_return
id|head-&gt;next
op_eq
id|head
suffix:semicolon
)brace
DECL|function|__list_splice
r_static
r_inline
r_void
id|__list_splice
c_func
(paren
id|list_t
op_star
id|list
comma
id|list_t
op_star
id|head
)paren
(brace
id|list_t
op_star
id|first
op_assign
id|list-&gt;next
suffix:semicolon
id|list_t
op_star
id|last
op_assign
id|list-&gt;prev
suffix:semicolon
id|list_t
op_star
id|at
op_assign
id|head-&gt;next
suffix:semicolon
id|first-&gt;prev
op_assign
id|head
suffix:semicolon
id|head-&gt;next
op_assign
id|first
suffix:semicolon
id|last-&gt;next
op_assign
id|at
suffix:semicolon
id|at-&gt;prev
op_assign
id|last
suffix:semicolon
)brace
multiline_comment|/**&n; * list_splice - join two lists&n; * @list: the new list to add.&n; * @head: the place to add it in the first list.&n; */
DECL|function|list_splice
r_static
r_inline
r_void
id|list_splice
c_func
(paren
id|list_t
op_star
id|list
comma
id|list_t
op_star
id|head
)paren
(brace
id|list_t
op_star
id|first
op_assign
id|list-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|first
op_ne
id|list
)paren
id|__list_splice
c_func
(paren
id|list
comma
id|head
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * list_splice_init - join two lists and reinitialise the emptied list.&n; * @list: the new list to add.&n; * @head: the place to add it in the first list.&n; *&n; * The list at @list is reinitialised&n; */
DECL|function|list_splice_init
r_static
r_inline
r_void
id|list_splice_init
c_func
(paren
id|list_t
op_star
id|list
comma
id|list_t
op_star
id|head
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|list
)paren
)paren
(brace
id|__list_splice
c_func
(paren
id|list
comma
id|head
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
id|list
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * list_entry - get the struct for this entry&n; * @ptr:&t;the &amp;list_t pointer.&n; * @type:&t;the type of the struct this is embedded in.&n; * @member:&t;the name of the list_struct within the struct.&n; */
DECL|macro|list_entry
mdefine_line|#define list_entry(ptr, type, member) &bslash;&n;&t;((type *)((char *)(ptr)-(unsigned long)(&amp;((type *)0)-&gt;member)))
multiline_comment|/**&n; * list_for_each&t;-&t;iterate over a list&n; * @pos:&t;the &amp;list_t to use as a loop counter.&n; * @head:&t;the head for your list.&n; */
DECL|macro|list_for_each
mdefine_line|#define list_for_each(pos, head) &bslash;&n;&t;for (pos = (head)-&gt;next, prefetch(pos-&gt;next); pos != (head); &bslash;&n;        &t;pos = pos-&gt;next, prefetch(pos-&gt;next))
multiline_comment|/**&n; * list_for_each_prev&t;-&t;iterate over a list backwards&n; * @pos:&t;the &amp;list_t to use as a loop counter.&n; * @head:&t;the head for your list.&n; */
DECL|macro|list_for_each_prev
mdefine_line|#define list_for_each_prev(pos, head) &bslash;&n;&t;for (pos = (head)-&gt;prev, prefetch(pos-&gt;prev); pos != (head); &bslash;&n;        &t;pos = pos-&gt;prev, prefetch(pos-&gt;prev))
multiline_comment|/**&n; * list_for_each_safe&t;-&t;iterate over a list safe against removal of list entry&n; * @pos:&t;the &amp;list_t to use as a loop counter.&n; * @n:&t;&t;another &amp;list_t to use as temporary storage&n; * @head:&t;the head for your list.&n; */
DECL|macro|list_for_each_safe
mdefine_line|#define list_for_each_safe(pos, n, head) &bslash;&n;&t;for (pos = (head)-&gt;next, n = pos-&gt;next; pos != (head); &bslash;&n;&t;&t;pos = n, n = pos-&gt;next)
macro_line|#endif /* __KERNEL__ || _LVM_H_INCLUDE */
macro_line|#endif
eof
