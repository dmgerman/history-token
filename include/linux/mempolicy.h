macro_line|#ifndef _LINUX_MEMPOLICY_H
DECL|macro|_LINUX_MEMPOLICY_H
mdefine_line|#define _LINUX_MEMPOLICY_H 1
macro_line|#include &lt;linux/errno.h&gt;
multiline_comment|/*&n; * NUMA memory policies for Linux.&n; * Copyright 2003,2004 Andi Kleen SuSE Labs&n; */
multiline_comment|/* Policies */
DECL|macro|MPOL_DEFAULT
mdefine_line|#define MPOL_DEFAULT&t;0
DECL|macro|MPOL_PREFERRED
mdefine_line|#define MPOL_PREFERRED&t;1
DECL|macro|MPOL_BIND
mdefine_line|#define MPOL_BIND&t;2
DECL|macro|MPOL_INTERLEAVE
mdefine_line|#define MPOL_INTERLEAVE&t;3
DECL|macro|MPOL_MAX
mdefine_line|#define MPOL_MAX MPOL_INTERLEAVE
multiline_comment|/* Flags for get_mem_policy */
DECL|macro|MPOL_F_NODE
mdefine_line|#define MPOL_F_NODE&t;(1&lt;&lt;0)&t;/* return next IL mode instead of node mask */
DECL|macro|MPOL_F_ADDR
mdefine_line|#define MPOL_F_ADDR&t;(1&lt;&lt;1)&t;/* look up vma using address */
multiline_comment|/* Flags for mbind */
DECL|macro|MPOL_MF_STRICT
mdefine_line|#define MPOL_MF_STRICT&t;(1&lt;&lt;0)&t;/* Verify existing pages in the mapping */
macro_line|#ifdef __KERNEL__
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/mmzone.h&gt;
macro_line|#include &lt;linux/bitmap.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/rbtree.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
r_struct
id|vm_area_struct
suffix:semicolon
macro_line|#ifdef CONFIG_NUMA
multiline_comment|/*&n; * Describe a memory policy.&n; *&n; * A mempolicy can be either associated with a process or with a VMA.&n; * For VMA related allocations the VMA policy is preferred, otherwise&n; * the process policy is used. Interrupts ignore the memory policy&n; * of the current process.&n; *&n; * Locking policy for interlave:&n; * In process context there is no locking because only the process accesses&n; * its own state. All vma manipulation is somewhat protected by a down_read on&n; * mmap_sem. For allocating in the interleave policy the page_table_lock&n; * must be also aquired to protect il_next.&n; *&n; * Freeing policy:&n; * When policy is MPOL_BIND v.zonelist is kmalloc&squot;ed and must be kfree&squot;d.&n; * All other policies don&squot;t have any external state. mpol_free() handles this.&n; *&n; * Copying policy objects:&n; * For MPOL_BIND the zonelist must be always duplicated. mpol_clone() does this.&n; */
DECL|struct|mempolicy
r_struct
id|mempolicy
(brace
DECL|member|refcnt
id|atomic_t
id|refcnt
suffix:semicolon
DECL|member|policy
r_int
id|policy
suffix:semicolon
multiline_comment|/* See MPOL_* above */
r_union
(brace
DECL|member|zonelist
r_struct
id|zonelist
op_star
id|zonelist
suffix:semicolon
multiline_comment|/* bind */
DECL|member|preferred_node
r_int
id|preferred_node
suffix:semicolon
multiline_comment|/* preferred */
id|DECLARE_BITMAP
c_func
(paren
id|nodes
comma
id|MAX_NUMNODES
)paren
suffix:semicolon
multiline_comment|/* interleave */
multiline_comment|/* undefined for default */
DECL|member|v
)brace
id|v
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* An NULL mempolicy pointer is a synonym of &amp;default_policy. */
r_extern
r_struct
id|mempolicy
id|default_policy
suffix:semicolon
multiline_comment|/*&n; * Support for managing mempolicy data objects (clone, copy, destroy)&n; * The default fast path of a NULL MPOL_DEFAULT policy is always inlined.&n; */
r_extern
r_void
id|__mpol_free
c_func
(paren
r_struct
id|mempolicy
op_star
id|pol
)paren
suffix:semicolon
DECL|function|mpol_free
r_static
r_inline
r_void
id|mpol_free
c_func
(paren
r_struct
id|mempolicy
op_star
id|pol
)paren
(brace
r_if
c_cond
(paren
id|pol
)paren
id|__mpol_free
c_func
(paren
id|pol
)paren
suffix:semicolon
)brace
r_extern
r_struct
id|mempolicy
op_star
id|__mpol_copy
c_func
(paren
r_struct
id|mempolicy
op_star
id|pol
)paren
suffix:semicolon
DECL|function|mpol_copy
r_static
r_inline
r_struct
id|mempolicy
op_star
id|mpol_copy
c_func
(paren
r_struct
id|mempolicy
op_star
id|pol
)paren
(brace
r_if
c_cond
(paren
id|pol
)paren
id|pol
op_assign
id|__mpol_copy
c_func
(paren
id|pol
)paren
suffix:semicolon
r_return
id|pol
suffix:semicolon
)brace
DECL|macro|vma_policy
mdefine_line|#define vma_policy(vma) ((vma)-&gt;vm_policy)
DECL|macro|vma_set_policy
mdefine_line|#define vma_set_policy(vma, pol) ((vma)-&gt;vm_policy = (pol))
DECL|function|mpol_get
r_static
r_inline
r_void
id|mpol_get
c_func
(paren
r_struct
id|mempolicy
op_star
id|pol
)paren
(brace
r_if
c_cond
(paren
id|pol
)paren
id|atomic_inc
c_func
(paren
op_amp
id|pol-&gt;refcnt
)paren
suffix:semicolon
)brace
r_extern
r_int
id|__mpol_equal
c_func
(paren
r_struct
id|mempolicy
op_star
id|a
comma
r_struct
id|mempolicy
op_star
id|b
)paren
suffix:semicolon
DECL|function|mpol_equal
r_static
r_inline
r_int
id|mpol_equal
c_func
(paren
r_struct
id|mempolicy
op_star
id|a
comma
r_struct
id|mempolicy
op_star
id|b
)paren
(brace
r_if
c_cond
(paren
id|a
op_eq
id|b
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|__mpol_equal
c_func
(paren
id|a
comma
id|b
)paren
suffix:semicolon
)brace
DECL|macro|vma_mpol_equal
mdefine_line|#define vma_mpol_equal(a,b) mpol_equal(vma_policy(a), vma_policy(b))
multiline_comment|/* Could later add inheritance of the process policy here. */
DECL|macro|mpol_set_vma_default
mdefine_line|#define mpol_set_vma_default(vma) ((vma)-&gt;vm_policy = NULL)
multiline_comment|/*&n; * Hugetlb policy. i386 hugetlb so far works with node numbers&n; * instead of zone lists, so give it special interfaces for now.&n; */
r_extern
r_int
id|mpol_first_node
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|addr
)paren
suffix:semicolon
r_extern
r_int
id|mpol_node_valid
c_func
(paren
r_int
id|nid
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|addr
)paren
suffix:semicolon
multiline_comment|/*&n; * Tree of shared policies for a shared memory region.&n; * Maintain the policies in a pseudo mm that contains vmas. The vmas&n; * carry the policy. As a special twist the pseudo mm is indexed in pages, not&n; * bytes, so that we can work with shared memory segments bigger than&n; * unsigned long.&n; */
DECL|struct|sp_node
r_struct
id|sp_node
(brace
DECL|member|nd
r_struct
id|rb_node
id|nd
suffix:semicolon
DECL|member|start
DECL|member|end
r_int
r_int
id|start
comma
id|end
suffix:semicolon
DECL|member|policy
r_struct
id|mempolicy
op_star
id|policy
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|shared_policy
r_struct
id|shared_policy
(brace
DECL|member|root
r_struct
id|rb_root
id|root
suffix:semicolon
DECL|member|sem
r_struct
id|semaphore
id|sem
suffix:semicolon
)brace
suffix:semicolon
DECL|function|mpol_shared_policy_init
r_static
r_inline
r_void
id|mpol_shared_policy_init
c_func
(paren
r_struct
id|shared_policy
op_star
id|info
)paren
(brace
id|info-&gt;root
op_assign
id|RB_ROOT
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|info-&gt;sem
)paren
suffix:semicolon
)brace
r_int
id|mpol_set_shared_policy
c_func
(paren
r_struct
id|shared_policy
op_star
id|info
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|mempolicy
op_star
r_new
)paren
suffix:semicolon
r_void
id|mpol_free_shared_policy
c_func
(paren
r_struct
id|shared_policy
op_star
id|p
)paren
suffix:semicolon
r_struct
id|mempolicy
op_star
id|mpol_shared_policy_lookup
c_func
(paren
r_struct
id|shared_policy
op_star
id|sp
comma
r_int
r_int
id|idx
)paren
suffix:semicolon
macro_line|#else
DECL|struct|mempolicy
r_struct
id|mempolicy
(brace
)brace
suffix:semicolon
DECL|function|mpol_equal
r_static
r_inline
r_int
id|mpol_equal
c_func
(paren
r_struct
id|mempolicy
op_star
id|a
comma
r_struct
id|mempolicy
op_star
id|b
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|macro|vma_mpol_equal
mdefine_line|#define vma_mpol_equal(a,b) 1
DECL|macro|mpol_set_vma_default
mdefine_line|#define mpol_set_vma_default(vma) do {} while(0)
DECL|function|mpol_free
r_static
r_inline
r_void
id|mpol_free
c_func
(paren
r_struct
id|mempolicy
op_star
id|p
)paren
(brace
)brace
DECL|function|mpol_get
r_static
r_inline
r_void
id|mpol_get
c_func
(paren
r_struct
id|mempolicy
op_star
id|pol
)paren
(brace
)brace
DECL|function|mpol_copy
r_static
r_inline
r_struct
id|mempolicy
op_star
id|mpol_copy
c_func
(paren
r_struct
id|mempolicy
op_star
id|old
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|mpol_first_node
r_static
r_inline
r_int
id|mpol_first_node
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|a
)paren
(brace
r_return
id|numa_node_id
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|mpol_node_valid
id|mpol_node_valid
c_func
(paren
r_int
id|nid
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|a
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|struct|shared_policy
r_struct
id|shared_policy
(brace
)brace
suffix:semicolon
DECL|function|mpol_set_shared_policy
r_static
r_inline
r_int
id|mpol_set_shared_policy
c_func
(paren
r_struct
id|shared_policy
op_star
id|info
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|mempolicy
op_star
r_new
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|mpol_shared_policy_init
r_static
r_inline
r_void
id|mpol_shared_policy_init
c_func
(paren
r_struct
id|shared_policy
op_star
id|info
)paren
(brace
)brace
DECL|function|mpol_free_shared_policy
r_static
r_inline
r_void
id|mpol_free_shared_policy
c_func
(paren
r_struct
id|shared_policy
op_star
id|p
)paren
(brace
)brace
r_static
r_inline
r_struct
id|mempolicy
op_star
DECL|function|mpol_shared_policy_lookup
id|mpol_shared_policy_lookup
c_func
(paren
r_struct
id|shared_policy
op_star
id|sp
comma
r_int
r_int
id|idx
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|macro|vma_policy
mdefine_line|#define vma_policy(vma) NULL
DECL|macro|vma_set_policy
mdefine_line|#define vma_set_policy(vma, pol) do {} while(0)
macro_line|#endif /* CONFIG_NUMA */
macro_line|#endif /* __KERNEL__ */
macro_line|#endif
eof
