macro_line|#ifndef _LINUX_MM_H
DECL|macro|_LINUX_MM_H
mdefine_line|#define _LINUX_MM_H
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#ifdef __KERNEL__
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/gfp.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/mmzone.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/rbtree.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
r_extern
r_int
r_int
id|max_mapnr
suffix:semicolon
r_extern
r_int
r_int
id|num_physpages
suffix:semicolon
r_extern
r_void
op_star
id|high_memory
suffix:semicolon
r_extern
r_int
id|page_cluster
suffix:semicolon
multiline_comment|/* The inactive_clean lists are per zone. */
r_extern
r_struct
id|list_head
id|active_list
suffix:semicolon
r_extern
r_struct
id|list_head
id|inactive_list
suffix:semicolon
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
multiline_comment|/*&n; * Linux kernel virtual memory manager primitives.&n; * The idea being to have a &quot;virtual&quot; mm in the same way&n; * we have a virtual fs - giving a cleaner interface to the&n; * mm details, and allowing different kinds of memory mappings&n; * (from shared memory to executable loading to arbitrary&n; * mmap() functions).&n; */
multiline_comment|/*&n; * This struct defines a memory VMM memory area. There is one of these&n; * per VM-area/task.  A VM area is any part of the process virtual memory&n; * space that has a special rule for the page-fault handlers (ie a shared&n; * library, the executable area etc).&n; */
DECL|struct|vm_area_struct
r_struct
id|vm_area_struct
(brace
DECL|member|vm_mm
r_struct
id|mm_struct
op_star
id|vm_mm
suffix:semicolon
multiline_comment|/* The address space we belong to. */
DECL|member|vm_start
r_int
r_int
id|vm_start
suffix:semicolon
multiline_comment|/* Our start address within vm_mm. */
DECL|member|vm_end
r_int
r_int
id|vm_end
suffix:semicolon
multiline_comment|/* The first byte after our end address&n;&t;&t;&t;&t;&t;   within vm_mm. */
multiline_comment|/* linked list of VM areas per task, sorted by address */
DECL|member|vm_next
r_struct
id|vm_area_struct
op_star
id|vm_next
suffix:semicolon
DECL|member|vm_page_prot
id|pgprot_t
id|vm_page_prot
suffix:semicolon
multiline_comment|/* Access permissions of this VMA. */
DECL|member|vm_flags
r_int
r_int
id|vm_flags
suffix:semicolon
multiline_comment|/* Flags, listed below. */
DECL|member|vm_rb
id|rb_node_t
id|vm_rb
suffix:semicolon
multiline_comment|/*&n;&t; * For areas with an address space and backing store,&n;&t; * one of the address_space-&gt;i_mmap{,shared} lists,&n;&t; * for shm areas, the list of attaches, otherwise unused.&n;&t; */
DECL|member|shared
id|list_t
id|shared
suffix:semicolon
multiline_comment|/* Function pointers to deal with this struct. */
DECL|member|vm_ops
r_struct
id|vm_operations_struct
op_star
id|vm_ops
suffix:semicolon
multiline_comment|/* Information about our backing store: */
DECL|member|vm_pgoff
r_int
r_int
id|vm_pgoff
suffix:semicolon
multiline_comment|/* Offset (within vm_file) in PAGE_SIZE&n;&t;&t;&t;&t;&t;   units, *not* PAGE_CACHE_SIZE */
DECL|member|vm_file
r_struct
id|file
op_star
id|vm_file
suffix:semicolon
multiline_comment|/* File we map to (can be NULL). */
DECL|member|vm_raend
r_int
r_int
id|vm_raend
suffix:semicolon
multiline_comment|/* XXX: put full readahead info here. */
DECL|member|vm_private_data
r_void
op_star
id|vm_private_data
suffix:semicolon
multiline_comment|/* was vm_pte (shared mem) */
)brace
suffix:semicolon
multiline_comment|/*&n; * vm_flags..&n; */
DECL|macro|VM_READ
mdefine_line|#define VM_READ&t;&t;0x00000001&t;/* currently active flags */
DECL|macro|VM_WRITE
mdefine_line|#define VM_WRITE&t;0x00000002
DECL|macro|VM_EXEC
mdefine_line|#define VM_EXEC&t;&t;0x00000004
DECL|macro|VM_SHARED
mdefine_line|#define VM_SHARED&t;0x00000008
DECL|macro|VM_MAYREAD
mdefine_line|#define VM_MAYREAD&t;0x00000010&t;/* limits for mprotect() etc */
DECL|macro|VM_MAYWRITE
mdefine_line|#define VM_MAYWRITE&t;0x00000020
DECL|macro|VM_MAYEXEC
mdefine_line|#define VM_MAYEXEC&t;0x00000040
DECL|macro|VM_MAYSHARE
mdefine_line|#define VM_MAYSHARE&t;0x00000080
DECL|macro|VM_GROWSDOWN
mdefine_line|#define VM_GROWSDOWN&t;0x00000100&t;/* general info on the segment */
DECL|macro|VM_GROWSUP
mdefine_line|#define VM_GROWSUP&t;0x00000200
DECL|macro|VM_SHM
mdefine_line|#define VM_SHM&t;&t;0x00000400&t;/* shared memory area, don&squot;t swap out */
DECL|macro|VM_DENYWRITE
mdefine_line|#define VM_DENYWRITE&t;0x00000800&t;/* ETXTBSY on write attempts.. */
DECL|macro|VM_EXECUTABLE
mdefine_line|#define VM_EXECUTABLE&t;0x00001000
DECL|macro|VM_LOCKED
mdefine_line|#define VM_LOCKED&t;0x00002000
DECL|macro|VM_IO
mdefine_line|#define VM_IO           0x00004000&t;/* Memory mapped I/O or similar */
multiline_comment|/* Used by sys_madvise() */
DECL|macro|VM_SEQ_READ
mdefine_line|#define VM_SEQ_READ&t;0x00008000&t;/* App will access data sequentially */
DECL|macro|VM_RAND_READ
mdefine_line|#define VM_RAND_READ&t;0x00010000&t;/* App will not benefit from clustered reads */
DECL|macro|VM_DONTCOPY
mdefine_line|#define VM_DONTCOPY&t;0x00020000      /* Do not copy this vma on fork */
DECL|macro|VM_DONTEXPAND
mdefine_line|#define VM_DONTEXPAND&t;0x00040000&t;/* Cannot expand with mremap() */
DECL|macro|VM_RESERVED
mdefine_line|#define VM_RESERVED&t;0x00080000&t;/* Don&squot;t unmap it from swap_out */
DECL|macro|VM_STACK_FLAGS
mdefine_line|#define VM_STACK_FLAGS&t;(0x00000100 | VM_DATA_DEFAULT_FLAGS)
DECL|macro|VM_READHINTMASK
mdefine_line|#define VM_READHINTMASK&t;&t;&t;(VM_SEQ_READ | VM_RAND_READ)
DECL|macro|VM_ClearReadHint
mdefine_line|#define VM_ClearReadHint(v)&t;&t;(v)-&gt;vm_flags &amp;= ~VM_READHINTMASK
DECL|macro|VM_NormalReadHint
mdefine_line|#define VM_NormalReadHint(v)&t;&t;(!((v)-&gt;vm_flags &amp; VM_READHINTMASK))
DECL|macro|VM_SequentialReadHint
mdefine_line|#define VM_SequentialReadHint(v)&t;((v)-&gt;vm_flags &amp; VM_SEQ_READ)
DECL|macro|VM_RandomReadHint
mdefine_line|#define VM_RandomReadHint(v)&t;&t;((v)-&gt;vm_flags &amp; VM_RAND_READ)
multiline_comment|/*&n; * mapping from the currently active vm_flags protection bits (the&n; * low four bits) to a page protection mask..&n; */
r_extern
id|pgprot_t
id|protection_map
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/*&n; * These are the virtual MM functions - opening of an area, closing and&n; * unmapping it (needed to keep files on disk up-to-date etc), pointer&n; * to the functions called when a no-page or a wp-page exception occurs. &n; */
DECL|struct|vm_operations_struct
r_struct
id|vm_operations_struct
(brace
DECL|member|open
r_void
(paren
op_star
id|open
)paren
(paren
r_struct
id|vm_area_struct
op_star
id|area
)paren
suffix:semicolon
DECL|member|close
r_void
(paren
op_star
id|close
)paren
(paren
r_struct
id|vm_area_struct
op_star
id|area
)paren
suffix:semicolon
DECL|member|nopage
r_struct
id|page
op_star
(paren
op_star
id|nopage
)paren
(paren
r_struct
id|vm_area_struct
op_star
id|area
comma
r_int
r_int
id|address
comma
r_int
id|unused
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Each physical page in the system has a struct page associated with&n; * it to keep track of whatever it is we are using the page for at the&n; * moment. Note that we have no way to track which tasks are using&n; * a page.&n; *&n; * Try to keep the most commonly accessed fields in single cache lines&n; * here (16 bytes or greater).  This ordering should be particularly&n; * beneficial on 32-bit processors.&n; *&n; * The first line is data used in page cache lookup, the second line&n; * is used for linear searches (eg. clock algorithm scans). &n; *&n; * TODO: make this structure smaller, it could be as small as 32 bytes.&n; */
DECL|struct|page
r_typedef
r_struct
id|page
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
multiline_comment|/* -&gt;mapping has some page lists. */
DECL|member|mapping
r_struct
id|address_space
op_star
id|mapping
suffix:semicolon
multiline_comment|/* The inode (or ...) we belong to. */
DECL|member|index
r_int
r_int
id|index
suffix:semicolon
multiline_comment|/* Our offset within mapping. */
DECL|member|count
id|atomic_t
id|count
suffix:semicolon
multiline_comment|/* Usage count, see below. */
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* atomic flags, some possibly&n;&t;&t;&t;&t;&t;   updated asynchronously */
DECL|member|lru
r_struct
id|list_head
id|lru
suffix:semicolon
multiline_comment|/* Pageout list, eg. active_list;&n;&t;&t;&t;&t;&t;   protected by pagemap_lru_lock !! */
DECL|member|private
r_int
r_int
r_private
suffix:semicolon
multiline_comment|/* mapping-private opaque data */
multiline_comment|/*&n;&t; * On machines where all RAM is mapped into kernel address space,&n;&t; * we can simply calculate the virtual address. On machines with&n;&t; * highmem some memory is mapped into kernel virtual memory&n;&t; * dynamically, so we need a place to store that address.&n;&t; * Note that this field could be 16 bits on x86 ... ;)&n;&t; *&n;&t; * Architectures with slow multiplication can define&n;&t; * WANT_PAGE_VIRTUAL in asm/page.h&n;&t; */
macro_line|#if defined(CONFIG_HIGHMEM) || defined(WANT_PAGE_VIRTUAL)
DECL|member|virtual
r_void
op_star
r_virtual
suffix:semicolon
multiline_comment|/* Kernel virtual address (NULL if&n;&t;&t;&t;&t;&t;   not kmapped, ie. highmem) */
macro_line|#endif /* CONFIG_HIGMEM || WANT_PAGE_VIRTUAL */
DECL|typedef|mem_map_t
)brace
id|mem_map_t
suffix:semicolon
multiline_comment|/*&n; * Methods to modify the page usage count.&n; *&n; * What counts for a page usage:&n; * - cache mapping   (page-&gt;mapping)&n; * - private data    (page-&gt;private)&n; * - page mapped in a task&squot;s page tables, each mapping&n; *   is counted separately&n; *&n; * Also, many kernel routines increase the page count before a critical&n; * routine so they can be sure the page doesn&squot;t go away from under them.&n; */
DECL|macro|get_page
mdefine_line|#define get_page(p)&t;&t;atomic_inc(&amp;(p)-&gt;count)
DECL|macro|put_page
mdefine_line|#define put_page(p)&t;&t;__free_page(p)
DECL|macro|put_page_testzero
mdefine_line|#define put_page_testzero(p) &t;atomic_dec_and_test(&amp;(p)-&gt;count)
DECL|macro|page_count
mdefine_line|#define page_count(p)&t;&t;atomic_read(&amp;(p)-&gt;count)
DECL|macro|set_page_count
mdefine_line|#define set_page_count(p,v) &t;atomic_set(&amp;(p)-&gt;count, v)
multiline_comment|/*&n; * Multiple processes may &quot;see&quot; the same page. E.g. for untouched&n; * mappings of /dev/null, all processes see the same page full of&n; * zeroes, and text pages of executables and shared libraries have&n; * only one copy in memory, at most, normally.&n; *&n; * For the non-reserved pages, page-&gt;count denotes a reference count.&n; *   page-&gt;count == 0 means the page is free.&n; *   page-&gt;count == 1 means the page is used for exactly one purpose&n; *   (e.g. a private data page of one process).&n; *&n; * A page may be used for kmalloc() or anyone else who does a&n; * __get_free_page(). In this case the page-&gt;count is at least 1, and&n; * all other fields are unused but should be 0 or NULL. The&n; * management of this page is the responsibility of the one who uses&n; * it.&n; *&n; * The other pages (we may call them &quot;process pages&quot;) are completely&n; * managed by the Linux memory manager: I/O, buffers, swapping etc.&n; * The following discussion applies only to them.&n; *&n; * A page may belong to an inode&squot;s memory mapping. In this case,&n; * page-&gt;mapping is the pointer to the inode, and page-&gt;index is the&n; * file offset of the page, in units of PAGE_CACHE_SIZE.&n; *&n; * A page contains an opaque `private&squot; member, which belongs to the&n; * page&squot;s address_space.  Usually, this is the address of a circular&n; * list of the page&squot;s disk buffers.&n; *&n; * For pages belonging to inodes, the page-&gt;count is the number of&n; * attaches, plus 1 if `private&squot; contains something, plus one for&n; * the page cache itself.&n; *&n; * All pages belonging to an inode are in these doubly linked lists:&n; * mapping-&gt;clean_pages, mapping-&gt;dirty_pages and mapping-&gt;locked_pages;&n; * using the page-&gt;list list_head. These fields are also used for&n; * freelist managemet (when page-&gt;count==0).&n; *&n; * There is also a per-mapping radix tree mapping index to the page&n; * in memory if present. The tree is rooted at mapping-&gt;root.  &n; *&n; * All process pages can do I/O:&n; * - inode pages may need to be read from disk,&n; * - inode pages which have been modified and are MAP_SHARED may need&n; *   to be written to disk,&n; * - private pages which have been modified may need to be swapped out&n; *   to swap space and (later) to be read back into memory.&n; */
multiline_comment|/*&n; * FIXME: take this include out, include page-flags.h in&n; * files which need it (119 of them)&n; */
macro_line|#include &lt;linux/page-flags.h&gt;
multiline_comment|/*&n; * The zone field is never updated after free_area_init_core()&n; * sets it, so none of the operations on it need to be atomic.&n; */
DECL|macro|NODE_SHIFT
mdefine_line|#define NODE_SHIFT 4
DECL|macro|ZONE_SHIFT
mdefine_line|#define ZONE_SHIFT (BITS_PER_LONG - 8)
r_struct
id|zone_struct
suffix:semicolon
r_extern
r_struct
id|zone_struct
op_star
id|zone_table
(braket
)braket
suffix:semicolon
DECL|function|page_zone
r_static
r_inline
id|zone_t
op_star
id|page_zone
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_return
id|zone_table
(braket
id|page-&gt;flags
op_rshift
id|ZONE_SHIFT
)braket
suffix:semicolon
)brace
DECL|function|set_page_zone
r_static
r_inline
r_void
id|set_page_zone
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|zone_num
)paren
(brace
id|page-&gt;flags
op_and_assign
op_complement
(paren
op_complement
l_int|0UL
op_lshift
id|ZONE_SHIFT
)paren
suffix:semicolon
id|page-&gt;flags
op_or_assign
id|zone_num
op_lshift
id|ZONE_SHIFT
suffix:semicolon
)brace
multiline_comment|/*&n; * In order to avoid #ifdefs within C code itself, we define&n; * set_page_address to a noop for non-highmem machines, where&n; * the field isn&squot;t useful.&n; * The same is true for page_address() in arch-dependent code.&n; */
macro_line|#if defined(CONFIG_HIGHMEM) || defined(WANT_PAGE_VIRTUAL)
DECL|macro|set_page_address
mdefine_line|#define set_page_address(page, address)&t;&t;&t;&bslash;&n;&t;do {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;(page)-&gt;virtual = (address);&t;&t;&bslash;&n;&t;} while(0)
macro_line|#else /* CONFIG_HIGHMEM || WANT_PAGE_VIRTUAL */
DECL|macro|set_page_address
mdefine_line|#define set_page_address(page, address)  do { } while(0)
macro_line|#endif /* CONFIG_HIGHMEM || WANT_PAGE_VIRTUAL */
multiline_comment|/*&n; * Permanent address of a page. Obviously must never be&n; * called on a highmem page.&n; */
macro_line|#if defined(CONFIG_HIGHMEM) || defined(WANT_PAGE_VIRTUAL)
DECL|macro|page_address
mdefine_line|#define page_address(page) ((page)-&gt;virtual)
macro_line|#else /* CONFIG_HIGHMEM || WANT_PAGE_VIRTUAL */
DECL|macro|page_address
mdefine_line|#define page_address(page)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;__va( (((page) - page_zone(page)-&gt;zone_mem_map) &lt;&lt; PAGE_SHIFT)&t;&bslash;&n;&t;&t;&t;+ page_zone(page)-&gt;zone_start_paddr)
macro_line|#endif /* CONFIG_HIGHMEM || WANT_PAGE_VIRTUAL */
multiline_comment|/*&n; * Error return values for the *_nopage functions&n; */
DECL|macro|NOPAGE_SIGBUS
mdefine_line|#define NOPAGE_SIGBUS&t;(NULL)
DECL|macro|NOPAGE_OOM
mdefine_line|#define NOPAGE_OOM&t;((struct page *) (-1))
multiline_comment|/* The array of struct pages */
r_extern
id|mem_map_t
op_star
id|mem_map
suffix:semicolon
r_extern
r_void
id|show_free_areas
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|show_free_areas_node
c_func
(paren
id|pg_data_t
op_star
id|pgdat
)paren
suffix:semicolon
r_extern
r_void
id|clear_page_tables
c_func
(paren
r_struct
id|mm_struct
op_star
comma
r_int
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|fail_writepage
c_func
(paren
r_struct
id|page
op_star
)paren
suffix:semicolon
r_struct
id|page
op_star
id|shmem_nopage
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
r_int
id|unused
)paren
suffix:semicolon
r_struct
id|file
op_star
id|shmem_file_setup
c_func
(paren
r_char
op_star
id|name
comma
id|loff_t
id|size
)paren
suffix:semicolon
r_extern
r_void
id|shmem_lock
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
id|lock
)paren
suffix:semicolon
r_extern
r_int
id|shmem_zero_setup
c_func
(paren
r_struct
id|vm_area_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|zap_page_range
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
r_int
r_int
id|size
)paren
suffix:semicolon
r_extern
r_int
id|copy_page_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|dst
comma
r_struct
id|mm_struct
op_star
id|src
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
suffix:semicolon
r_extern
r_int
id|remap_page_range
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|from
comma
r_int
r_int
id|to
comma
r_int
r_int
id|size
comma
id|pgprot_t
id|prot
)paren
suffix:semicolon
r_extern
r_int
id|zeromap_page_range
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|from
comma
r_int
r_int
id|size
comma
id|pgprot_t
id|prot
)paren
suffix:semicolon
r_extern
r_int
id|vmtruncate
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|loff_t
id|offset
)paren
suffix:semicolon
r_extern
id|pmd_t
op_star
id|FASTCALL
c_func
(paren
id|__pmd_alloc
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
id|pgd_t
op_star
id|pgd
comma
r_int
r_int
id|address
)paren
)paren
suffix:semicolon
r_extern
id|pte_t
op_star
id|FASTCALL
c_func
(paren
id|pte_alloc_kernel
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
id|pmd_t
op_star
id|pmd
comma
r_int
r_int
id|address
)paren
)paren
suffix:semicolon
r_extern
id|pte_t
op_star
id|FASTCALL
c_func
(paren
id|pte_alloc_map
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
id|pmd_t
op_star
id|pmd
comma
r_int
r_int
id|address
)paren
)paren
suffix:semicolon
r_extern
r_int
id|handle_mm_fault
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
r_int
id|write_access
)paren
suffix:semicolon
r_extern
r_int
id|make_pages_present
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|end
)paren
suffix:semicolon
r_extern
r_int
id|access_process_vm
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
r_int
id|addr
comma
r_void
op_star
id|buf
comma
r_int
id|len
comma
r_int
id|write
)paren
suffix:semicolon
r_extern
r_int
id|ptrace_readdata
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
r_int
id|src
comma
r_char
op_star
id|dst
comma
r_int
id|len
)paren
suffix:semicolon
r_extern
r_int
id|ptrace_writedata
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_char
op_star
id|src
comma
r_int
r_int
id|dst
comma
r_int
id|len
)paren
suffix:semicolon
r_extern
r_int
id|ptrace_attach
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
suffix:semicolon
r_extern
r_int
id|ptrace_detach
c_func
(paren
r_struct
id|task_struct
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_void
id|ptrace_disable
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_int
id|ptrace_check_attach
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
id|kill
)paren
suffix:semicolon
r_int
id|get_user_pages
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
id|len
comma
r_int
id|write
comma
r_int
id|force
comma
r_struct
id|page
op_star
op_star
id|pages
comma
r_struct
id|vm_area_struct
op_star
op_star
id|vmas
)paren
suffix:semicolon
r_int
id|__set_page_dirty_buffers
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
suffix:semicolon
r_int
id|__set_page_dirty_nobuffers
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
suffix:semicolon
multiline_comment|/*&n; * If the mapping doesn&squot;t provide a set_page_dirty a_op, then&n; * just fall through and assume that it wants buffer_heads.&n; * FIXME: make the method unconditional.&n; */
DECL|function|set_page_dirty
r_static
r_inline
r_int
id|set_page_dirty
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
id|page-&gt;mapping
)paren
(brace
r_int
(paren
op_star
id|spd
)paren
(paren
r_struct
id|page
op_star
)paren
suffix:semicolon
id|spd
op_assign
id|page-&gt;mapping-&gt;a_ops-&gt;set_page_dirty
suffix:semicolon
r_if
c_cond
(paren
id|spd
)paren
r_return
(paren
op_star
id|spd
)paren
(paren
id|page
)paren
suffix:semicolon
)brace
r_return
id|__set_page_dirty_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * On a two-level page table, this ends up being trivial. Thus the&n; * inlining and the symmetry break with pte_alloc_map() that does all&n; * of this out-of-line.&n; */
DECL|function|pmd_alloc
r_static
r_inline
id|pmd_t
op_star
id|pmd_alloc
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
id|pgd_t
op_star
id|pgd
comma
r_int
r_int
id|address
)paren
(brace
r_if
c_cond
(paren
id|pgd_none
c_func
(paren
op_star
id|pgd
)paren
)paren
r_return
id|__pmd_alloc
c_func
(paren
id|mm
comma
id|pgd
comma
id|address
)paren
suffix:semicolon
r_return
id|pmd_offset
c_func
(paren
id|pgd
comma
id|address
)paren
suffix:semicolon
)brace
r_extern
r_void
id|free_area_init
c_func
(paren
r_int
r_int
op_star
id|zones_size
)paren
suffix:semicolon
r_extern
r_void
id|free_area_init_node
c_func
(paren
r_int
id|nid
comma
id|pg_data_t
op_star
id|pgdat
comma
r_struct
id|page
op_star
id|pmap
comma
r_int
r_int
op_star
id|zones_size
comma
r_int
r_int
id|zone_start_paddr
comma
r_int
r_int
op_star
id|zholes_size
)paren
suffix:semicolon
r_extern
r_void
id|mem_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|show_mem
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|si_meminfo
c_func
(paren
r_struct
id|sysinfo
op_star
id|val
)paren
suffix:semicolon
r_extern
r_void
id|swapin_readahead
c_func
(paren
id|swp_entry_t
)paren
suffix:semicolon
r_extern
r_int
id|can_share_swap_page
c_func
(paren
r_struct
id|page
op_star
)paren
suffix:semicolon
r_extern
r_int
id|remove_exclusive_swap_page
c_func
(paren
r_struct
id|page
op_star
)paren
suffix:semicolon
r_extern
r_void
id|__free_pte
c_func
(paren
id|pte_t
)paren
suffix:semicolon
multiline_comment|/* mmap.c */
r_extern
r_void
id|lock_vma_mappings
c_func
(paren
r_struct
id|vm_area_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|unlock_vma_mappings
c_func
(paren
r_struct
id|vm_area_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|insert_vm_struct
c_func
(paren
r_struct
id|mm_struct
op_star
comma
r_struct
id|vm_area_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|__insert_vm_struct
c_func
(paren
r_struct
id|mm_struct
op_star
comma
r_struct
id|vm_area_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|build_mmap_rb
c_func
(paren
r_struct
id|mm_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|exit_mmap
c_func
(paren
r_struct
id|mm_struct
op_star
)paren
suffix:semicolon
r_extern
r_int
r_int
id|get_unmapped_area
c_func
(paren
r_struct
id|file
op_star
comma
r_int
r_int
comma
r_int
r_int
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_int
r_int
id|do_mmap_pgoff
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|len
comma
r_int
r_int
id|prot
comma
r_int
r_int
id|flag
comma
r_int
r_int
id|pgoff
)paren
suffix:semicolon
DECL|function|do_mmap
r_static
r_inline
r_int
r_int
id|do_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|len
comma
r_int
r_int
id|prot
comma
r_int
r_int
id|flag
comma
r_int
r_int
id|offset
)paren
(brace
r_int
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|offset
op_plus
id|PAGE_ALIGN
c_func
(paren
id|len
)paren
)paren
OL
id|offset
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|offset
op_amp
op_complement
id|PAGE_MASK
)paren
)paren
id|ret
op_assign
id|do_mmap_pgoff
c_func
(paren
id|file
comma
id|addr
comma
id|len
comma
id|prot
comma
id|flag
comma
id|offset
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
r_extern
r_int
id|do_munmap
c_func
(paren
r_struct
id|mm_struct
op_star
comma
r_int
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
r_int
id|do_brk
c_func
(paren
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
DECL|function|__vma_unlink
r_static
r_inline
r_void
id|__vma_unlink
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|vm_area_struct
op_star
id|prev
)paren
(brace
id|prev-&gt;vm_next
op_assign
id|vma-&gt;vm_next
suffix:semicolon
id|rb_erase
c_func
(paren
op_amp
id|vma-&gt;vm_rb
comma
op_amp
id|mm-&gt;mm_rb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mm-&gt;mmap_cache
op_eq
id|vma
)paren
id|mm-&gt;mmap_cache
op_assign
id|prev
suffix:semicolon
)brace
DECL|function|can_vma_merge
r_static
r_inline
r_int
id|can_vma_merge
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|vm_flags
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|vma-&gt;vm_file
op_logical_and
id|vma-&gt;vm_flags
op_eq
id|vm_flags
)paren
r_return
l_int|1
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_struct
id|zone_t
suffix:semicolon
multiline_comment|/* filemap.c */
r_extern
r_void
id|remove_inode_page
c_func
(paren
r_struct
id|page
op_star
)paren
suffix:semicolon
r_extern
r_int
r_int
id|page_unuse
c_func
(paren
r_struct
id|page
op_star
)paren
suffix:semicolon
r_extern
r_void
id|truncate_inode_pages
c_func
(paren
r_struct
id|address_space
op_star
comma
id|loff_t
)paren
suffix:semicolon
multiline_comment|/* generic vm_area_ops exported for stackable file systems */
r_extern
r_int
id|filemap_sync
c_func
(paren
r_struct
id|vm_area_struct
op_star
comma
r_int
r_int
comma
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_struct
id|page
op_star
id|filemap_nopage
c_func
(paren
r_struct
id|vm_area_struct
op_star
comma
r_int
r_int
comma
r_int
)paren
suffix:semicolon
multiline_comment|/* mm/page-writeback.c */
r_int
id|generic_writeback_mapping
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_int
op_star
id|nr_to_write
)paren
suffix:semicolon
multiline_comment|/* readahead.c */
DECL|macro|VM_MAX_READAHEAD
mdefine_line|#define VM_MAX_READAHEAD&t;128&t;/* kbytes */
DECL|macro|VM_MIN_READAHEAD
mdefine_line|#define VM_MIN_READAHEAD&t;16&t;/* kbytes (includes current page) */
r_void
id|do_page_cache_readahead
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|nr_to_read
)paren
suffix:semicolon
r_void
id|page_cache_readahead
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|offset
)paren
suffix:semicolon
r_void
id|page_cache_readaround
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|offset
)paren
suffix:semicolon
r_void
id|handle_ra_thrashing
c_func
(paren
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_extern
r_int
r_int
id|default_ra_pages
suffix:semicolon
multiline_comment|/* vma is the first one with  address &lt; vma-&gt;vm_end,&n; * and even  address &lt; vma-&gt;vm_start. Have to extend vma. */
DECL|function|expand_stack
r_static
r_inline
r_int
id|expand_stack
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
)paren
(brace
r_int
r_int
id|grow
suffix:semicolon
multiline_comment|/*&n;&t; * vma-&gt;vm_start/vm_end cannot change under us because the caller is required&n;&t; * to hold the mmap_sem in write mode. We need to get the spinlock only&n;&t; * before relocating the vma range ourself.&n;&t; */
id|address
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|grow
op_assign
(paren
id|vma-&gt;vm_start
op_minus
id|address
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_end
op_minus
id|address
OG
id|current-&gt;rlim
(braket
id|RLIMIT_STACK
)braket
dot
id|rlim_cur
op_logical_or
(paren
(paren
id|vma-&gt;vm_mm-&gt;total_vm
op_plus
id|grow
)paren
op_lshift
id|PAGE_SHIFT
)paren
OG
id|current-&gt;rlim
(braket
id|RLIMIT_AS
)braket
dot
id|rlim_cur
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|vma-&gt;vm_mm-&gt;page_table_lock
)paren
suffix:semicolon
id|vma-&gt;vm_start
op_assign
id|address
suffix:semicolon
id|vma-&gt;vm_pgoff
op_sub_assign
id|grow
suffix:semicolon
id|vma-&gt;vm_mm-&gt;total_vm
op_add_assign
id|grow
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_LOCKED
)paren
id|vma-&gt;vm_mm-&gt;locked_vm
op_add_assign
id|grow
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|vma-&gt;vm_mm-&gt;page_table_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Look up the first VMA which satisfies  addr &lt; vm_end,  NULL if none. */
r_extern
r_struct
id|vm_area_struct
op_star
id|find_vma
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
)paren
suffix:semicolon
r_extern
r_struct
id|vm_area_struct
op_star
id|find_vma_prev
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
comma
r_struct
id|vm_area_struct
op_star
op_star
id|pprev
)paren
suffix:semicolon
multiline_comment|/* Look up the first VMA which intersects the interval start_addr..end_addr-1,&n;   NULL if none.  Assume start_addr &lt; end_addr. */
DECL|function|find_vma_intersection
r_static
r_inline
r_struct
id|vm_area_struct
op_star
id|find_vma_intersection
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start_addr
comma
r_int
r_int
id|end_addr
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|start_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma
op_logical_and
id|end_addr
op_le
id|vma-&gt;vm_start
)paren
id|vma
op_assign
l_int|NULL
suffix:semicolon
r_return
id|vma
suffix:semicolon
)brace
r_extern
r_struct
id|vm_area_struct
op_star
id|find_extend_vma
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
)paren
suffix:semicolon
r_extern
r_struct
id|page
op_star
id|vmalloc_to_page
c_func
(paren
r_void
op_star
id|addr
)paren
suffix:semicolon
r_extern
r_int
r_int
id|get_page_cache_size
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif /* __KERNEL__ */
macro_line|#endif
eof
