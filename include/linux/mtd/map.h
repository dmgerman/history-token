multiline_comment|/* Overhauled routines for dealing with different mmap regions of flash */
multiline_comment|/* $Id: map.h,v 1.25 2001/09/09 15:04:17 dwmw2 Exp $ */
macro_line|#ifndef __LINUX_MTD_MAP_H__
DECL|macro|__LINUX_MTD_MAP_H__
mdefine_line|#define __LINUX_MTD_MAP_H__
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
multiline_comment|/* The map stuff is very simple. You fill in your struct map_info with&n;   a handful of routines for accessing the device, making sure they handle&n;   paging etc. correctly if your device needs it. Then you pass it off&n;   to a chip driver which deals with a mapped device - generally either&n;   do_cfi_probe() or do_ram_probe(), either of which will return a &n;   struct mtd_info if they liked what they saw. At which point, you&n;   fill in the mtd-&gt;module with your own module address, and register &n;   it.&n;   &n;   The mtd-&gt;priv field will point to the struct map_info, and any further&n;   private data required by the chip driver is linked from the &n;   mtd-&gt;priv-&gt;fldrv_priv field. This allows the map driver to get at &n;   the destructor function map-&gt;fldrv_destroy() when it&squot;s tired&n;   of living.&n;*/
DECL|struct|map_info
r_struct
id|map_info
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|size
r_int
r_int
id|size
suffix:semicolon
DECL|member|buswidth
r_int
id|buswidth
suffix:semicolon
multiline_comment|/* in octets */
DECL|member|read8
id|__u8
(paren
op_star
id|read8
)paren
(paren
r_struct
id|map_info
op_star
comma
r_int
r_int
)paren
suffix:semicolon
DECL|member|read16
id|__u16
(paren
op_star
id|read16
)paren
(paren
r_struct
id|map_info
op_star
comma
r_int
r_int
)paren
suffix:semicolon
DECL|member|read32
id|__u32
(paren
op_star
id|read32
)paren
(paren
r_struct
id|map_info
op_star
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* If it returned a &squot;long&squot; I&squot;d call it readl.&n;&t; * It doesn&squot;t.&n;&t; * I won&squot;t.&n;&t; * dwmw2 */
DECL|member|copy_from
r_void
(paren
op_star
id|copy_from
)paren
(paren
r_struct
id|map_info
op_star
comma
r_void
op_star
comma
r_int
r_int
comma
id|ssize_t
)paren
suffix:semicolon
DECL|member|write8
r_void
(paren
op_star
id|write8
)paren
(paren
r_struct
id|map_info
op_star
comma
id|__u8
comma
r_int
r_int
)paren
suffix:semicolon
DECL|member|write16
r_void
(paren
op_star
id|write16
)paren
(paren
r_struct
id|map_info
op_star
comma
id|__u16
comma
r_int
r_int
)paren
suffix:semicolon
DECL|member|write32
r_void
(paren
op_star
id|write32
)paren
(paren
r_struct
id|map_info
op_star
comma
id|__u32
comma
r_int
r_int
)paren
suffix:semicolon
DECL|member|copy_to
r_void
(paren
op_star
id|copy_to
)paren
(paren
r_struct
id|map_info
op_star
comma
r_int
r_int
comma
r_const
r_void
op_star
comma
id|ssize_t
)paren
suffix:semicolon
DECL|member|set_vpp
r_void
(paren
op_star
id|set_vpp
)paren
(paren
r_struct
id|map_info
op_star
comma
r_int
)paren
suffix:semicolon
multiline_comment|/* We put these two here rather than a single void *map_priv, &n;&t;   because we want mappers to be able to have quickly-accessible&n;&t;   cache for the &squot;currently-mapped page&squot; without the _extra_&n;&t;   redirection that would be necessary. If you need more than&n;&t;   two longs, turn the second into a pointer. dwmw2 */
DECL|member|map_priv_1
r_int
r_int
id|map_priv_1
suffix:semicolon
DECL|member|map_priv_2
r_int
r_int
id|map_priv_2
suffix:semicolon
DECL|member|fldrv_priv
r_void
op_star
id|fldrv_priv
suffix:semicolon
DECL|member|fldrv
r_struct
id|mtd_chip_driver
op_star
id|fldrv
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|mtd_chip_driver
r_struct
id|mtd_chip_driver
(brace
DECL|member|probe
r_struct
id|mtd_info
op_star
(paren
op_star
id|probe
)paren
(paren
r_struct
id|map_info
op_star
id|map
)paren
suffix:semicolon
DECL|member|destroy
r_void
(paren
op_star
id|destroy
)paren
(paren
r_struct
id|mtd_info
op_star
)paren
suffix:semicolon
DECL|member|module
r_struct
id|module
op_star
id|module
suffix:semicolon
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
)brace
suffix:semicolon
r_void
id|register_mtd_chip_driver
c_func
(paren
r_struct
id|mtd_chip_driver
op_star
)paren
suffix:semicolon
r_void
id|unregister_mtd_chip_driver
c_func
(paren
r_struct
id|mtd_chip_driver
op_star
)paren
suffix:semicolon
r_struct
id|mtd_info
op_star
id|do_map_probe
c_func
(paren
r_char
op_star
id|name
comma
r_struct
id|map_info
op_star
id|map
)paren
suffix:semicolon
multiline_comment|/*&n; * Destroy an MTD device which was created for a map device.&n; * Make sure the MTD device is already unregistered before calling this&n; */
DECL|function|map_destroy
r_static
r_inline
r_void
id|map_destroy
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|map_info
op_star
id|map
op_assign
id|mtd-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|map-&gt;fldrv-&gt;destroy
)paren
id|map-&gt;fldrv
op_member_access_from_pointer
id|destroy
c_func
(paren
id|mtd
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MODULES
r_if
c_cond
(paren
id|map-&gt;fldrv-&gt;module
)paren
id|__MOD_DEC_USE_COUNT
c_func
(paren
id|map-&gt;fldrv-&gt;module
)paren
suffix:semicolon
macro_line|#endif
id|kfree
c_func
(paren
id|mtd
)paren
suffix:semicolon
)brace
DECL|macro|ENABLE_VPP
mdefine_line|#define ENABLE_VPP(map) do { if(map-&gt;set_vpp) map-&gt;set_vpp(map, 1); } while(0)
DECL|macro|DISABLE_VPP
mdefine_line|#define DISABLE_VPP(map) do { if(map-&gt;set_vpp) map-&gt;set_vpp(map, 0); } while(0)
macro_line|#endif /* __LINUX_MTD_MAP_H__ */
eof
