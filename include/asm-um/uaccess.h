multiline_comment|/* &n; * Copyright (C) 2000 Jeff Dike (jdike@karaya.com)&n; * Licensed under the GPL&n; */
macro_line|#ifndef __UM_UACCESS_H
DECL|macro|__UM_UACCESS_H
mdefine_line|#define __UM_UACCESS_H
macro_line|#include &quot;linux/string.h&quot;
macro_line|#include &quot;linux/sched.h&quot;
macro_line|#include &quot;asm/processor.h&quot;
macro_line|#include &quot;asm/errno.h&quot;
macro_line|#include &quot;asm/current.h&quot;
macro_line|#include &quot;asm/a.out.h&quot;
DECL|macro|VERIFY_READ
mdefine_line|#define VERIFY_READ 0
DECL|macro|VERIFY_WRITE
mdefine_line|#define VERIFY_WRITE 1
multiline_comment|/*&n; * The fs value determines whether argument validity checking should be&n; * performed or not.  If get_fs() == USER_DS, checking is performed, with&n; * get_fs() == KERNEL_DS, checking is bypassed.&n; *&n; * For historical reasons, these macros are grossly misnamed.&n; */
DECL|macro|MAKE_MM_SEG
mdefine_line|#define MAKE_MM_SEG(s)&t;((mm_segment_t) { (s) })
DECL|macro|ABOVE_KMEM
mdefine_line|#define ABOVE_KMEM (16 * 1024 * 1024)
DECL|macro|KERNEL_DS
mdefine_line|#define KERNEL_DS&t;MAKE_MM_SEG(0xFFFFFFFF)
DECL|macro|USER_DS
mdefine_line|#define USER_DS&t;&t;MAKE_MM_SEG(TASK_SIZE)
DECL|macro|get_ds
mdefine_line|#define get_ds()&t;(KERNEL_DS)
DECL|macro|get_fs
mdefine_line|#define get_fs()&t;(current_thread_info()-&gt;addr_limit)
DECL|macro|set_fs
mdefine_line|#define set_fs(x)&t;(current_thread_info()-&gt;addr_limit = (x))
r_extern
r_int
r_int
id|end_vm
suffix:semicolon
r_extern
r_int
r_int
id|uml_physmem
suffix:semicolon
DECL|macro|under_task_size
mdefine_line|#define under_task_size(addr, size) &bslash;&n;&t;(((unsigned long) (addr) &lt; TASK_SIZE) &amp;&amp; &bslash;&n;         (((unsigned long) (addr) + (size)) &lt; TASK_SIZE))
DECL|macro|is_stack
mdefine_line|#define is_stack(addr, size) &bslash;&n;&t;(((unsigned long) (addr) &lt; STACK_TOP) &amp;&amp; &bslash;&n;&t; ((unsigned long) (addr) &gt;= STACK_TOP - ABOVE_KMEM) &amp;&amp; &bslash;&n;&t; (((unsigned long) (addr) + (size)) &lt;= STACK_TOP))
DECL|macro|segment_eq
mdefine_line|#define segment_eq(a, b) ((a).seg == (b).seg)
DECL|macro|access_ok
mdefine_line|#define access_ok(type, addr, size) &bslash;&n;&t;((type == VERIFY_READ) || (segment_eq(get_fs(), KERNEL_DS)) || &bslash;&n;         (((unsigned long) (addr) &lt;= ((unsigned long) (addr) + (size))) &amp;&amp; &bslash;&n;          (under_task_size(addr, size) || is_stack(addr, size))))
DECL|function|verify_area
r_static
r_inline
r_int
id|verify_area
c_func
(paren
r_int
id|type
comma
r_const
r_void
op_star
id|addr
comma
r_int
r_int
id|size
)paren
(brace
r_return
id|access_ok
c_func
(paren
id|type
comma
id|addr
comma
id|size
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EFAULT
suffix:semicolon
)brace
r_extern
r_int
r_int
id|get_fault_addr
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|__do_copy_from_user
c_func
(paren
r_void
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
id|n
comma
r_void
op_star
op_star
id|fault_addr
comma
r_void
op_star
op_star
id|fault_catcher
)paren
suffix:semicolon
DECL|function|copy_from_user
r_static
r_inline
r_int
id|copy_from_user
c_func
(paren
r_void
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
id|n
)paren
(brace
r_return
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|from
comma
id|n
)paren
ques
c_cond
id|__do_copy_from_user
c_func
(paren
id|to
comma
id|from
comma
id|n
comma
op_amp
id|current-&gt;thread.fault_addr
comma
op_amp
id|current-&gt;thread.fault_catcher
)paren
suffix:colon
id|n
suffix:semicolon
)brace
DECL|macro|__copy_from_user
mdefine_line|#define __copy_from_user(to, from, n) copy_from_user(to, from, n)
r_extern
r_int
id|__do_copy_to_user
c_func
(paren
r_void
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
id|n
comma
r_void
op_star
op_star
id|fault_addr
comma
r_void
op_star
op_star
id|fault_catcher
)paren
suffix:semicolon
DECL|function|copy_to_user
r_static
r_inline
r_int
id|copy_to_user
c_func
(paren
r_void
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
id|n
)paren
(brace
r_return
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|to
comma
id|n
)paren
ques
c_cond
id|__do_copy_to_user
c_func
(paren
id|to
comma
id|from
comma
id|n
comma
op_amp
id|current-&gt;thread.fault_addr
comma
op_amp
id|current-&gt;thread.fault_catcher
)paren
suffix:colon
id|n
suffix:semicolon
)brace
DECL|macro|__copy_to_user
mdefine_line|#define __copy_to_user(to, from, n) copy_to_user(to, from, n)
DECL|macro|__get_user
mdefine_line|#define __get_user(x, ptr) &bslash;&n;({ &bslash;&n;        const __typeof__(ptr) __private_ptr = ptr; &bslash;&n;        __typeof__(*(__private_ptr)) __private_val; &bslash;&n;        int __private_ret = -EFAULT; &bslash;&n;        (x) = 0; &bslash;&n;&t;if (__copy_from_user(&amp;__private_val, (__private_ptr), &bslash;&n;&t;    sizeof(*(__private_ptr))) == 0) {&bslash;&n;        &t;(x) = (__typeof__(*(__private_ptr))) __private_val; &bslash;&n;&t;&t;__private_ret = 0; &bslash;&n;&t;} &bslash;&n;        __private_ret; &bslash;&n;}) 
DECL|macro|get_user
mdefine_line|#define get_user(x, ptr) &bslash;&n;({ &bslash;&n;        const __typeof__((*ptr)) *private_ptr = (ptr); &bslash;&n;        (access_ok(VERIFY_READ, private_ptr, sizeof(*private_ptr)) ? &bslash;&n;&t; __get_user(x, private_ptr) : ((x) = 0, -EFAULT)); &bslash;&n;})
DECL|macro|__put_user
mdefine_line|#define __put_user(x, ptr) &bslash;&n;({ &bslash;&n;        __typeof__(ptr) __private_ptr = ptr; &bslash;&n;        __typeof__(*(__private_ptr)) __private_val; &bslash;&n;        int __private_ret = -EFAULT; &bslash;&n;        __private_val = (__typeof__(*(__private_ptr))) (x); &bslash;&n;        if (__copy_to_user((__private_ptr), &amp;__private_val, &bslash;&n;&t;&t;&t;   sizeof(*(__private_ptr))) == 0) { &bslash;&n;&t;&t;__private_ret = 0; &bslash;&n;&t;} &bslash;&n;        __private_ret; &bslash;&n;})
DECL|macro|put_user
mdefine_line|#define put_user(x, ptr) &bslash;&n;({ &bslash;&n;        __typeof__(*(ptr)) *private_ptr = (ptr); &bslash;&n;        (access_ok(VERIFY_WRITE, private_ptr, sizeof(*private_ptr)) ? &bslash;&n;&t; __put_user(x, private_ptr) : -EFAULT); &bslash;&n;})
r_extern
r_int
id|__do_strncpy_from_user
c_func
(paren
r_char
op_star
id|dst
comma
r_const
r_char
op_star
id|src
comma
r_int
id|n
comma
r_void
op_star
op_star
id|fault_addr
comma
r_void
op_star
op_star
id|fault_catcher
)paren
suffix:semicolon
DECL|function|strncpy_from_user
r_static
r_inline
r_int
id|strncpy_from_user
c_func
(paren
r_char
op_star
id|dst
comma
r_const
r_char
op_star
id|src
comma
r_int
id|count
)paren
(brace
r_int
id|n
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|src
comma
l_int|1
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|n
op_assign
id|__do_strncpy_from_user
c_func
(paren
id|dst
comma
id|src
comma
id|count
comma
op_amp
id|current-&gt;thread.fault_addr
comma
op_amp
id|current-&gt;thread.fault_catcher
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
id|n
suffix:semicolon
)brace
r_extern
r_int
id|__do_clear_user
c_func
(paren
r_void
op_star
id|mem
comma
r_int
id|len
comma
r_void
op_star
op_star
id|fault_addr
comma
r_void
op_star
op_star
id|fault_catcher
)paren
suffix:semicolon
DECL|function|__clear_user
r_static
r_inline
r_int
id|__clear_user
c_func
(paren
r_void
op_star
id|mem
comma
r_int
id|len
)paren
(brace
r_return
id|__do_clear_user
c_func
(paren
id|mem
comma
id|len
comma
op_amp
id|current-&gt;thread.fault_addr
comma
op_amp
id|current-&gt;thread.fault_catcher
)paren
suffix:semicolon
)brace
DECL|function|clear_user
r_static
r_inline
r_int
id|clear_user
c_func
(paren
r_void
op_star
id|mem
comma
r_int
id|len
)paren
(brace
r_return
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|mem
comma
id|len
)paren
ques
c_cond
id|__do_clear_user
c_func
(paren
id|mem
comma
id|len
comma
op_amp
id|current-&gt;thread.fault_addr
comma
op_amp
id|current-&gt;thread.fault_catcher
)paren
suffix:colon
id|len
suffix:semicolon
)brace
r_extern
r_int
id|__do_strnlen_user
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_int
r_int
id|n
comma
r_void
op_star
op_star
id|fault_addr
comma
r_void
op_star
op_star
id|fault_catcher
)paren
suffix:semicolon
DECL|function|strnlen_user
r_static
r_inline
r_int
id|strnlen_user
c_func
(paren
r_void
op_star
id|str
comma
r_int
id|len
)paren
(brace
r_return
id|__do_strnlen_user
c_func
(paren
id|str
comma
id|len
comma
op_amp
id|current-&gt;thread.fault_addr
comma
op_amp
id|current-&gt;thread.fault_catcher
)paren
suffix:semicolon
)brace
DECL|macro|strlen_user
mdefine_line|#define strlen_user(str) strnlen_user(str, ~0UL &gt;&gt; 1)
DECL|struct|exception_table_entry
r_struct
id|exception_table_entry
(brace
DECL|member|insn
r_int
r_int
id|insn
suffix:semicolon
DECL|member|fixup
r_int
r_int
id|fixup
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Overrides for Emacs so that we follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-file-style: &quot;linux&quot;&n; * End:&n; */
eof
