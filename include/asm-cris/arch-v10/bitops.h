multiline_comment|/* asm/arch/bitops.h for Linux/CRISv10 */
macro_line|#ifndef _CRIS_ARCH_BITOPS_H
DECL|macro|_CRIS_ARCH_BITOPS_H
mdefine_line|#define _CRIS_ARCH_BITOPS_H
multiline_comment|/*&n; * Helper functions for the core of the ff[sz] functions, wrapping the&n; * syntactically awkward asms.  The asms compute the number of leading&n; * zeroes of a bits-in-byte and byte-in-word and word-in-dword-swapped&n; * number.  They differ in that the first function also inverts all bits&n; * in the input.&n; */
DECL|function|cris_swapnwbrlz
r_extern
r_inline
r_int
r_int
id|cris_swapnwbrlz
c_func
(paren
r_int
r_int
id|w
)paren
(brace
multiline_comment|/* Let&squot;s just say we return the result in the same register as the&n;&t;   input.  Saying we clobber the input but can return the result&n;&t;   in another register:&n;&t;   !  __asm__ (&quot;swapnwbr %2&bslash;n&bslash;tlz %2,%0&quot;&n;&t;   !&t;      : &quot;=r,r&quot; (res), &quot;=r,X&quot; (dummy) : &quot;1,0&quot; (w));&n;&t;   confuses gcc (sched.c, gcc from cris-dist-1.14).  */
r_int
r_int
id|res
suffix:semicolon
id|__asm__
(paren
l_string|&quot;swapnwbr %0 &bslash;n&bslash;t&quot;
l_string|&quot;lz %0,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|res
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|w
)paren
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|cris_swapwbrlz
r_extern
r_inline
r_int
r_int
id|cris_swapwbrlz
c_func
(paren
r_int
r_int
id|w
)paren
(brace
r_int
id|res
suffix:semicolon
id|__asm__
(paren
l_string|&quot;swapwbr %0 &bslash;n&bslash;t&quot;
l_string|&quot;lz %0,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|res
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|w
)paren
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/*&n; * ffz = Find First Zero in word. Undefined if no zero exists,&n; * so code should check against ~0UL first..&n; */
DECL|function|ffz
r_extern
r_inline
r_int
r_int
id|ffz
c_func
(paren
r_int
r_int
id|w
)paren
(brace
r_return
id|cris_swapnwbrlz
c_func
(paren
id|w
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * __ffs - find first bit in word.&n; * @word: The word to search&n; *&n; * Undefined if no bit exists, so code should check against 0 first.&n; */
DECL|function|__ffs
r_extern
id|__inline__
r_int
r_int
id|__ffs
c_func
(paren
r_int
r_int
id|word
)paren
(brace
r_return
id|cris_swapnwbrlz
c_func
(paren
op_complement
id|word
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ffs - find first bit set&n; * @x: the word to search&n; *&n; * This is defined the same way as&n; * the libc and compiler builtin ffs routines, therefore&n; * differs in spirit from the above ffz (man ffs).&n; */
DECL|function|kernel_ffs
r_extern
r_inline
r_int
r_int
id|kernel_ffs
c_func
(paren
r_int
r_int
id|w
)paren
(brace
r_return
id|w
ques
c_cond
id|cris_swapwbrlz
(paren
id|w
)paren
op_plus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
macro_line|#endif
eof
