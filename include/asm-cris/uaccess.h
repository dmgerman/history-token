multiline_comment|/* &n; * Authors:    Bjorn Wesen (bjornw@axis.com)&n; *&t;       Hans-Peter Nilsson (hp@axis.com)&n; *&n; * $Log: uaccess.h,v $&n; * Revision 1.8  2001/10/29 13:01:48  bjornw&n; * Removed unused variable tmp2 in strnlen_user&n; *&n; * Revision 1.7  2001/10/02 12:44:52  hp&n; * Add support for 64-bit put_user/get_user&n; *&n; * Revision 1.6  2001/10/01 14:51:17  bjornw&n; * Added register prefixes and removed underscores&n; *&n; * Revision 1.5  2000/10/25 03:33:21  hp&n; * - Provide implementation for everything else but get_user and put_user;&n; *   copying inline to/from user for constant length 0..16, 20, 24, and&n; *   clearing for 0..4, 8, 12, 16, 20, 24, strncpy_from_user and strnlen_user&n; *   always inline.&n; * - Constraints for destination addr in get_user cannot be memory, only reg.&n; * - Correct labels for PC at expected fault points.&n; * - Nits with assembly code.&n; * - Don&squot;t use statement expressions without value; use &quot;do {} while (0)&quot;.&n; * - Return correct values from __generic_... functions.&n; *&n; * Revision 1.4  2000/09/12 16:28:25  bjornw&n; * * Removed comments from the get/put user asm code&n; * * Constrains for destination addr in put_user cannot be memory, only reg&n; *&n; * Revision 1.3  2000/09/12 14:30:20  bjornw&n; * MAX_ADDR_USER does not exist anymore&n; *&n; * Revision 1.2  2000/07/13 15:52:48  bjornw&n; * New user-access functions&n; *&n; * Revision 1.1.1.1  2000/07/10 16:32:31  bjornw&n; * CRIS architecture, working draft&n; *&n; *&n; *&n; */
multiline_comment|/* Asm:s have been tweaked (within the domain of correctness) to give&n;   satisfactory results for &quot;gcc version 2.96 20000427 (experimental)&quot;.&n;&n;   Check regularly...&n;&n;   Register $r9 is chosen for temporaries, being a call-clobbered register&n;   first in line to be used (notably for local blocks), not colliding with&n;   parameter registers.  */
macro_line|#ifndef _CRIS_UACCESS_H
DECL|macro|_CRIS_UACCESS_H
mdefine_line|#define _CRIS_UACCESS_H
macro_line|#ifndef __ASSEMBLY__
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/page.h&gt;
DECL|macro|VERIFY_READ
mdefine_line|#define VERIFY_READ&t;0
DECL|macro|VERIFY_WRITE
mdefine_line|#define VERIFY_WRITE&t;1
multiline_comment|/*&n; * The fs value determines whether argument validity checking should be&n; * performed or not.  If get_fs() == USER_DS, checking is performed, with&n; * get_fs() == KERNEL_DS, checking is bypassed.&n; *&n; * For historical reasons, these macros are grossly misnamed.&n; */
DECL|macro|MAKE_MM_SEG
mdefine_line|#define MAKE_MM_SEG(s)&t;((mm_segment_t) { (s) })
multiline_comment|/* addr_limit is the maximum accessible address for the task. we misuse&n; * the KERNEL_DS and USER_DS values to both assign and compare the &n; * addr_limit values through the equally misnamed get/set_fs macros.&n; * (see above)&n; */
DECL|macro|KERNEL_DS
mdefine_line|#define KERNEL_DS&t;MAKE_MM_SEG(0xFFFFFFFF)
DECL|macro|USER_DS
mdefine_line|#define USER_DS&t;&t;MAKE_MM_SEG(TASK_SIZE)
DECL|macro|get_ds
mdefine_line|#define get_ds()&t;(KERNEL_DS)
DECL|macro|get_fs
mdefine_line|#define get_fs()&t;(current_thread_info()-&gt;addr_limit)
DECL|macro|set_fs
mdefine_line|#define set_fs(x)&t;(current_thread_info()-&gt;addr_limit = (x))
DECL|macro|segment_eq
mdefine_line|#define segment_eq(a,b)&t;((a).seg == (b).seg)
DECL|macro|__kernel_ok
mdefine_line|#define __kernel_ok (segment_eq(get_fs(), KERNEL_DS))
DECL|macro|__user_ok
mdefine_line|#define __user_ok(addr,size) (((size) &lt;= TASK_SIZE)&amp;&amp;((addr) &lt;= TASK_SIZE-(size)))
DECL|macro|__access_ok
mdefine_line|#define __access_ok(addr,size) (__kernel_ok || __user_ok((addr),(size)))
DECL|macro|access_ok
mdefine_line|#define access_ok(type,addr,size) __access_ok((unsigned long)(addr),(size))
DECL|function|verify_area
r_extern
r_inline
r_int
id|verify_area
c_func
(paren
r_int
id|type
comma
r_const
r_void
id|__user
op_star
id|addr
comma
r_int
r_int
id|size
)paren
(brace
r_return
id|access_ok
c_func
(paren
id|type
comma
id|addr
comma
id|size
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EFAULT
suffix:semicolon
)brace
macro_line|#include &lt;asm/arch/uaccess.h&gt;
multiline_comment|/*&n; * The exception table consists of pairs of addresses: the first is the&n; * address of an instruction that is allowed to fault, and the second is&n; * the address at which the program should continue.  No registers are&n; * modified, so it is entirely up to the continuation code to figure out&n; * what to do.&n; *&n; * All the routines below use bits of fixup code that are out of line&n; * with the main instruction path.  This means when everything is well,&n; * we don&squot;t even have to jump over them.  Further, they do not intrude&n; * on our cache or tlb entries.&n; */
DECL|struct|exception_table_entry
r_struct
id|exception_table_entry
(brace
DECL|member|insn
DECL|member|fixup
r_int
r_int
id|insn
comma
id|fixup
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * These are the main single-value transfer routines.  They automatically&n; * use the right size if we just have the right pointer type.&n; *&n; * This gets kind of ugly. We want to return _two_ values in &quot;get_user()&quot;&n; * and yet we don&squot;t want to do any pointers, because that is too much&n; * of a performance impact. Thus we have a few rather ugly macros here,&n; * and hide all the ugliness from the user.&n; *&n; * The &quot;__xxx&quot; versions of the user access functions are versions that&n; * do not verify the address space, that must have been done previously&n; * with a separate &quot;access_ok()&quot; call (this is used when we do multiple&n; * accesses to the same area of user memory).&n; *&n; * As we use the same address space for kernel and user data on&n; * CRIS, we can just do these as direct assignments.  (Of course, the&n; * exception handling means that it&squot;s no longer &quot;just&quot;...)&n; */
DECL|macro|get_user
mdefine_line|#define get_user(x,ptr) &bslash;&n;  __get_user_check((x),(ptr),sizeof(*(ptr)))
DECL|macro|put_user
mdefine_line|#define put_user(x,ptr) &bslash;&n;  __put_user_check((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
DECL|macro|__get_user
mdefine_line|#define __get_user(x,ptr) &bslash;&n;  __get_user_nocheck((x),(ptr),sizeof(*(ptr)))
DECL|macro|__put_user
mdefine_line|#define __put_user(x,ptr) &bslash;&n;  __put_user_nocheck((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
r_extern
r_int
id|__put_user_bad
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|__put_user_size
mdefine_line|#define __put_user_size(x,ptr,size,retval)&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;retval = 0;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;switch (size) {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  case 1: __put_user_asm(x,ptr,retval,&quot;move.b&quot;); break;&t;&bslash;&n;&t;  case 2: __put_user_asm(x,ptr,retval,&quot;move.w&quot;); break;&t;&bslash;&n;&t;  case 4: __put_user_asm(x,ptr,retval,&quot;move.d&quot;); break;&t;&bslash;&n;&t;  case 8: __put_user_asm_64(x,ptr,retval); break;&t;&bslash;&n;&t;  default: __put_user_bad();&t;&t;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&bslash;&n;} while (0)
DECL|macro|__get_user_size
mdefine_line|#define __get_user_size(x,ptr,size,retval)&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;retval = 0;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;switch (size) {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  case 1: __get_user_asm(x,ptr,retval,&quot;move.b&quot;); break;&t;&bslash;&n;&t;  case 2: __get_user_asm(x,ptr,retval,&quot;move.w&quot;); break;&t;&bslash;&n;&t;  case 4: __get_user_asm(x,ptr,retval,&quot;move.d&quot;); break;&t;&bslash;&n;&t;  case 8: __get_user_asm_64(x,ptr,retval); break;&t;&bslash;&n;&t;  default: (x) = __get_user_bad();&t;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&bslash;&n;} while (0)
DECL|macro|__put_user_nocheck
mdefine_line|#define __put_user_nocheck(x,ptr,size)&t;&t;&t;&bslash;&n;({&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;long __pu_err;&t;&t;&t;&t;&t;&bslash;&n;&t;__put_user_size((x),(ptr),(size),__pu_err);&t;&bslash;&n;&t;__pu_err;&t;&t;&t;&t;&t;&bslash;&n;})
DECL|macro|__put_user_check
mdefine_line|#define __put_user_check(x,ptr,size)&t;&t;&t;&t;&bslash;&n;({&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;long __pu_err = -EFAULT;&t;&t;&t;&t;&bslash;&n;&t;__typeof__(*(ptr)) *__pu_addr = (ptr);&t;&t;&t;&bslash;&n;&t;if (access_ok(VERIFY_WRITE,__pu_addr,size))&t;&t;&bslash;&n;&t;&t;__put_user_size((x),__pu_addr,(size),__pu_err);&t;&bslash;&n;&t;__pu_err;&t;&t;&t;&t;&t;&t;&bslash;&n;})
DECL|struct|__large_struct
DECL|member|buf
r_struct
id|__large_struct
(brace
r_int
r_int
id|buf
(braket
l_int|100
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|__m
mdefine_line|#define __m(x) (*(struct __large_struct *)(x))
DECL|macro|__get_user_nocheck
mdefine_line|#define __get_user_nocheck(x,ptr,size)&t;&t;&t;&t;&bslash;&n;({&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;long __gu_err, __gu_val;&t;&t;&t;&t;&bslash;&n;&t;__get_user_size(__gu_val,(ptr),(size),__gu_err);&t;&bslash;&n;&t;(x) = (__typeof__(*(ptr)))__gu_val;&t;&t;&t;&bslash;&n;&t;__gu_err;&t;&t;&t;&t;&t;&t;&bslash;&n;})
DECL|macro|__get_user_check
mdefine_line|#define __get_user_check(x,ptr,size)&t;&t;&t;&t;&t;&bslash;&n;({&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;long __gu_err = -EFAULT, __gu_val = 0;&t;&t;&t;&t;&bslash;&n;&t;const __typeof__(*(ptr)) *__gu_addr = (ptr);&t;&t;&t;&bslash;&n;&t;if (access_ok(VERIFY_READ,__gu_addr,size))&t;&t;&t;&bslash;&n;&t;&t;__get_user_size(__gu_val,__gu_addr,(size),__gu_err);&t;&bslash;&n;&t;(x) = (__typeof__(*(ptr)))__gu_val;&t;&t;&t;&t;&bslash;&n;&t;__gu_err;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;})
r_extern
r_int
id|__get_user_bad
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* More complex functions.  Most are inline, but some call functions that&n;   live in lib/usercopy.c  */
r_extern
r_int
r_int
id|__copy_user
c_func
(paren
r_void
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
r_int
id|n
)paren
suffix:semicolon
r_extern
r_int
r_int
id|__copy_user_zeroing
c_func
(paren
r_void
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
r_int
id|n
)paren
suffix:semicolon
r_extern
r_int
r_int
id|__do_clear_user
c_func
(paren
r_void
op_star
id|to
comma
r_int
r_int
id|n
)paren
suffix:semicolon
r_extern
r_inline
r_int
r_int
DECL|function|__generic_copy_to_user
id|__generic_copy_to_user
c_func
(paren
r_void
id|__user
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
r_int
id|n
)paren
(brace
r_if
c_cond
(paren
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|to
comma
id|n
)paren
)paren
r_return
id|__copy_user
c_func
(paren
id|to
comma
id|from
comma
id|n
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
r_extern
r_inline
r_int
r_int
DECL|function|__generic_copy_from_user
id|__generic_copy_from_user
c_func
(paren
r_void
op_star
id|to
comma
r_const
r_void
id|__user
op_star
id|from
comma
r_int
r_int
id|n
)paren
(brace
r_if
c_cond
(paren
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|from
comma
id|n
)paren
)paren
r_return
id|__copy_user_zeroing
c_func
(paren
id|to
comma
id|from
comma
id|n
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
r_extern
r_inline
r_int
r_int
DECL|function|__generic_clear_user
id|__generic_clear_user
c_func
(paren
r_void
id|__user
op_star
id|to
comma
r_int
r_int
id|n
)paren
(brace
r_if
c_cond
(paren
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|to
comma
id|n
)paren
)paren
r_return
id|__do_clear_user
c_func
(paren
id|to
comma
id|n
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
r_extern
r_inline
r_int
DECL|function|__strncpy_from_user
id|__strncpy_from_user
c_func
(paren
r_char
op_star
id|dst
comma
r_const
r_char
id|__user
op_star
id|src
comma
r_int
id|count
)paren
(brace
r_return
id|__do_strncpy_from_user
c_func
(paren
id|dst
comma
id|src
comma
id|count
)paren
suffix:semicolon
)brace
r_extern
r_inline
r_int
DECL|function|strncpy_from_user
id|strncpy_from_user
c_func
(paren
r_char
op_star
id|dst
comma
r_const
r_char
id|__user
op_star
id|src
comma
r_int
id|count
)paren
(brace
r_int
id|res
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|src
comma
l_int|1
)paren
)paren
id|res
op_assign
id|__do_strncpy_from_user
c_func
(paren
id|dst
comma
id|src
comma
id|count
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/* Note that if these expand awfully if made into switch constructs, so&n;   don&squot;t do that.  */
r_extern
r_inline
r_int
r_int
DECL|function|__constant_copy_from_user
id|__constant_copy_from_user
c_func
(paren
r_void
op_star
id|to
comma
r_const
r_void
id|__user
op_star
id|from
comma
r_int
r_int
id|n
)paren
(brace
r_int
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|0
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|1
)paren
id|__asm_copy_from_user_1
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|2
)paren
id|__asm_copy_from_user_2
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|3
)paren
id|__asm_copy_from_user_3
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|4
)paren
id|__asm_copy_from_user_4
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|5
)paren
id|__asm_copy_from_user_5
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|6
)paren
id|__asm_copy_from_user_6
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|7
)paren
id|__asm_copy_from_user_7
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|8
)paren
id|__asm_copy_from_user_8
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|9
)paren
id|__asm_copy_from_user_9
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|10
)paren
id|__asm_copy_from_user_10
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|11
)paren
id|__asm_copy_from_user_11
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|12
)paren
id|__asm_copy_from_user_12
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|13
)paren
id|__asm_copy_from_user_13
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|14
)paren
id|__asm_copy_from_user_14
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|15
)paren
id|__asm_copy_from_user_15
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|16
)paren
id|__asm_copy_from_user_16
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|20
)paren
id|__asm_copy_from_user_20
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|24
)paren
id|__asm_copy_from_user_24
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
id|ret
op_assign
id|__generic_copy_from_user
c_func
(paren
id|to
comma
id|from
comma
id|n
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Ditto, don&squot;t make a switch out of this.  */
r_extern
r_inline
r_int
r_int
DECL|function|__constant_copy_to_user
id|__constant_copy_to_user
c_func
(paren
r_void
id|__user
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
r_int
id|n
)paren
(brace
r_int
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|0
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|1
)paren
id|__asm_copy_to_user_1
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|2
)paren
id|__asm_copy_to_user_2
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|3
)paren
id|__asm_copy_to_user_3
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|4
)paren
id|__asm_copy_to_user_4
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|5
)paren
id|__asm_copy_to_user_5
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|6
)paren
id|__asm_copy_to_user_6
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|7
)paren
id|__asm_copy_to_user_7
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|8
)paren
id|__asm_copy_to_user_8
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|9
)paren
id|__asm_copy_to_user_9
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|10
)paren
id|__asm_copy_to_user_10
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|11
)paren
id|__asm_copy_to_user_11
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|12
)paren
id|__asm_copy_to_user_12
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|13
)paren
id|__asm_copy_to_user_13
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|14
)paren
id|__asm_copy_to_user_14
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|15
)paren
id|__asm_copy_to_user_15
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|16
)paren
id|__asm_copy_to_user_16
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|20
)paren
id|__asm_copy_to_user_20
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|24
)paren
id|__asm_copy_to_user_24
c_func
(paren
id|to
comma
id|from
comma
id|ret
)paren
suffix:semicolon
r_else
id|ret
op_assign
id|__generic_copy_to_user
c_func
(paren
id|to
comma
id|from
comma
id|n
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* No switch, please.  */
r_extern
r_inline
r_int
r_int
DECL|function|__constant_clear_user
id|__constant_clear_user
c_func
(paren
r_void
id|__user
op_star
id|to
comma
r_int
r_int
id|n
)paren
(brace
r_int
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|0
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|1
)paren
id|__asm_clear_1
c_func
(paren
id|to
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|2
)paren
id|__asm_clear_2
c_func
(paren
id|to
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|3
)paren
id|__asm_clear_3
c_func
(paren
id|to
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|4
)paren
id|__asm_clear_4
c_func
(paren
id|to
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|8
)paren
id|__asm_clear_8
c_func
(paren
id|to
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|12
)paren
id|__asm_clear_12
c_func
(paren
id|to
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|16
)paren
id|__asm_clear_16
c_func
(paren
id|to
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|20
)paren
id|__asm_clear_20
c_func
(paren
id|to
comma
id|ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_eq
l_int|24
)paren
id|__asm_clear_24
c_func
(paren
id|to
comma
id|ret
)paren
suffix:semicolon
r_else
id|ret
op_assign
id|__generic_clear_user
c_func
(paren
id|to
comma
id|n
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|macro|clear_user
mdefine_line|#define clear_user(to, n)&t;&t;&t;&bslash;&n;(__builtin_constant_p(n) ?&t;&t;&t;&bslash;&n; __constant_clear_user(to, n) :&t;&t;&t;&bslash;&n; __generic_clear_user(to, n))
DECL|macro|copy_from_user
mdefine_line|#define copy_from_user(to, from, n)&t;&t;&bslash;&n;(__builtin_constant_p(n) ?&t;&t;&t;&bslash;&n; __constant_copy_from_user(to, from, n) :&t;&bslash;&n; __generic_copy_from_user(to, from, n))
DECL|macro|copy_to_user
mdefine_line|#define copy_to_user(to, from, n)&t;&t;&bslash;&n;(__builtin_constant_p(n) ?&t;&t;&t;&bslash;&n; __constant_copy_to_user(to, from, n) :&t;&t;&bslash;&n; __generic_copy_to_user(to, from, n))
multiline_comment|/* We let the __ versions of copy_from/to_user inline, because they&squot;re often&n; * used in fast paths and have only a small space overhead.&n; */
r_extern
r_inline
r_int
r_int
DECL|function|__generic_copy_from_user_nocheck
id|__generic_copy_from_user_nocheck
c_func
(paren
r_void
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
r_int
id|n
)paren
(brace
r_return
id|__copy_user_zeroing
c_func
(paren
id|to
comma
id|from
comma
id|n
)paren
suffix:semicolon
)brace
r_extern
r_inline
r_int
r_int
DECL|function|__generic_copy_to_user_nocheck
id|__generic_copy_to_user_nocheck
c_func
(paren
r_void
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
r_int
id|n
)paren
(brace
r_return
id|__copy_user
c_func
(paren
id|to
comma
id|from
comma
id|n
)paren
suffix:semicolon
)brace
r_extern
r_inline
r_int
r_int
DECL|function|__generic_clear_user_nocheck
id|__generic_clear_user_nocheck
c_func
(paren
r_void
op_star
id|to
comma
r_int
r_int
id|n
)paren
(brace
r_return
id|__do_clear_user
c_func
(paren
id|to
comma
id|n
)paren
suffix:semicolon
)brace
multiline_comment|/* without checking */
DECL|macro|__copy_to_user
mdefine_line|#define __copy_to_user(to,from,n)   __generic_copy_to_user_nocheck((to),(from),(n))
DECL|macro|__copy_from_user
mdefine_line|#define __copy_from_user(to,from,n) __generic_copy_from_user_nocheck((to),(from),(n))
DECL|macro|__clear_user
mdefine_line|#define __clear_user(to,n) __generic_clear_user_nocheck((to),(n))
DECL|macro|strlen_user
mdefine_line|#define strlen_user(str)&t;strnlen_user((str), 0x7ffffffe)
macro_line|#endif  /* __ASSEMBLY__ */
macro_line|#endif&t;/* _CRIS_UACCESS_H */
eof
