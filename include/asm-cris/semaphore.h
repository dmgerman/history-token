multiline_comment|/* $Id: semaphore.h,v 1.2 2000/07/13 16:52:46 bjornw Exp $ */
multiline_comment|/* On the i386 these are coded in asm, perhaps we should as well. Later.. */
macro_line|#ifndef _CRIS_SEMAPHORE_H
DECL|macro|_CRIS_SEMAPHORE_H
mdefine_line|#define _CRIS_SEMAPHORE_H
DECL|macro|RW_LOCK_BIAS
mdefine_line|#define RW_LOCK_BIAS             0x01000000
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
multiline_comment|/*&n; * CRIS semaphores, implemented in C-only so far. &n; */
r_int
id|printk
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
suffix:semicolon
DECL|struct|semaphore
r_struct
id|semaphore
(brace
DECL|member|count
r_int
id|count
suffix:semicolon
multiline_comment|/* not atomic_t since we do the atomicity here already */
DECL|member|waking
id|atomic_t
id|waking
suffix:semicolon
DECL|member|wait
id|wait_queue_head_t
id|wait
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
DECL|member|__magic
r_int
id|__magic
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
DECL|macro|__SEM_DEBUG_INIT
macro_line|# define __SEM_DEBUG_INIT(name)         , (long)&amp;(name).__magic
macro_line|#else
DECL|macro|__SEM_DEBUG_INIT
macro_line|# define __SEM_DEBUG_INIT(name)
macro_line|#endif
DECL|macro|__SEMAPHORE_INITIALIZER
mdefine_line|#define __SEMAPHORE_INITIALIZER(name,count)             &bslash;&n;        { count, ATOMIC_INIT(0),          &bslash;&n;          __WAIT_QUEUE_HEAD_INITIALIZER((name).wait)    &bslash;&n;          __SEM_DEBUG_INIT(name) }
DECL|macro|__MUTEX_INITIALIZER
mdefine_line|#define __MUTEX_INITIALIZER(name) &bslash;&n;        __SEMAPHORE_INITIALIZER(name,1)
DECL|macro|__DECLARE_SEMAPHORE_GENERIC
mdefine_line|#define __DECLARE_SEMAPHORE_GENERIC(name,count) &bslash;&n;        struct semaphore name = __SEMAPHORE_INITIALIZER(name,count)
DECL|macro|DECLARE_MUTEX
mdefine_line|#define DECLARE_MUTEX(name) __DECLARE_SEMAPHORE_GENERIC(name,1)
DECL|macro|DECLARE_MUTEX_LOCKED
mdefine_line|#define DECLARE_MUTEX_LOCKED(name) __DECLARE_SEMAPHORE_GENERIC(name,0)
DECL|function|sema_init
r_extern
r_inline
r_void
id|sema_init
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
comma
r_int
id|val
)paren
(brace
op_star
id|sem
op_assign
(paren
r_struct
id|semaphore
)paren
id|__SEMAPHORE_INITIALIZER
c_func
(paren
(paren
op_star
id|sem
)paren
comma
id|val
)paren
suffix:semicolon
)brace
DECL|function|init_MUTEX
r_static
r_inline
r_void
id|init_MUTEX
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
id|sema_init
c_func
(paren
id|sem
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|init_MUTEX_LOCKED
r_static
r_inline
r_void
id|init_MUTEX_LOCKED
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
id|sema_init
c_func
(paren
id|sem
comma
l_int|0
)paren
suffix:semicolon
)brace
r_extern
r_void
id|__down
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
suffix:semicolon
r_extern
r_int
id|__down_interruptible
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
suffix:semicolon
r_extern
r_int
id|__down_trylock
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
suffix:semicolon
r_extern
r_void
id|__up
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
suffix:semicolon
multiline_comment|/* notice - we probably can do cli/sti here instead of saving */
DECL|function|down
r_extern
r_inline
r_void
id|down
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|failed
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
id|CHECK_MAGIC
c_func
(paren
id|sem-&gt;__magic
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* atomically decrement the semaphores count, and if its negative, we wait */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|failed
op_assign
op_decrement
(paren
id|sem-&gt;count
)paren
OL
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|failed
)paren
(brace
id|__down
c_func
(paren
id|sem
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This version waits in interruptible state so that the waiting&n; * process can be killed.  The down_interruptible routine&n; * returns negative for signalled and zero for semaphore acquired.&n; */
DECL|function|down_interruptible
r_extern
r_inline
r_int
id|down_interruptible
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|failed
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
id|CHECK_MAGIC
c_func
(paren
id|sem-&gt;__magic
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* atomically decrement the semaphores count, and if its negative, we wait */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|failed
op_assign
op_decrement
(paren
id|sem-&gt;count
)paren
OL
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|failed
)paren
(brace
id|failed
op_assign
id|__down_interruptible
c_func
(paren
id|sem
)paren
suffix:semicolon
)brace
r_return
id|failed
suffix:semicolon
)brace
DECL|function|down_trylock
r_extern
r_inline
r_int
id|down_trylock
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|failed
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
id|CHECK_MAGIC
c_func
(paren
id|sem-&gt;__magic
)paren
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|failed
op_assign
op_decrement
(paren
id|sem-&gt;count
)paren
OL
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|failed
)paren
(brace
id|failed
op_assign
id|__down_trylock
c_func
(paren
id|sem
)paren
suffix:semicolon
)brace
r_return
id|failed
suffix:semicolon
)brace
multiline_comment|/*&n; * Note! This is subtle. We jump to wake people up only if&n; * the semaphore was negative (== somebody was waiting on it).&n; * The default case (no contention) will result in NO&n; * jumps for both down() and up().&n; */
DECL|function|up
r_extern
r_inline
r_void
id|up
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|wakeup
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
id|CHECK_MAGIC
c_func
(paren
id|sem-&gt;__magic
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* atomically increment the semaphores count, and if it was negative, we wake people */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|wakeup
op_assign
op_increment
(paren
id|sem-&gt;count
)paren
op_le
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wakeup
)paren
(brace
id|__up
c_func
(paren
id|sem
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* rw mutexes (should that be mutices? =) -- throw rw&n; * spinlocks and semaphores together, and this is what we&n; * end up with...&n; *&n; * The lock is initialized to BIAS.  This way, a writer&n; * subtracts BIAS ands gets 0 for the case of an uncontended&n; * lock.  Readers decrement by 1 and see a positive value&n; * when uncontended, negative if there are writers waiting&n; * (in which case it goes to sleep).&n; *&n; * In terms of fairness, this should result in the lock&n; * flopping back and forth between readers and writers&n; * under heavy use.&n; *&n; *              -ben&n; */
DECL|struct|rw_semaphore
r_struct
id|rw_semaphore
(brace
DECL|member|count
id|atomic_t
id|count
suffix:semicolon
multiline_comment|/* bit 0 means read bias granted;&n;&t;   bit 1 means write bias granted.  */
DECL|member|granted
r_int
id|granted
suffix:semicolon
DECL|member|wait
id|wait_queue_head_t
id|wait
suffix:semicolon
DECL|member|write_bias_wait
id|wait_queue_head_t
id|write_bias_wait
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
DECL|member|__magic
r_int
id|__magic
suffix:semicolon
DECL|member|readers
id|atomic_t
id|readers
suffix:semicolon
DECL|member|writers
id|atomic_t
id|writers
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
DECL|macro|__RWSEM_DEBUG_INIT
mdefine_line|#define __RWSEM_DEBUG_INIT      , ATOMIC_INIT(0), ATOMIC_INIT(0)
macro_line|#else
DECL|macro|__RWSEM_DEBUG_INIT
mdefine_line|#define __RWSEM_DEBUG_INIT      /* */
macro_line|#endif
DECL|macro|__RWSEM_INITIALIZER
mdefine_line|#define __RWSEM_INITIALIZER(name,count) &bslash;&n;{ ATOMIC_INIT(count), 0, __WAIT_QUEUE_HEAD_INITIALIZER((name).wait), &bslash;&n;        __WAIT_QUEUE_HEAD_INITIALIZER((name).write_bias_wait) &bslash;&n;        __SEM_DEBUG_INIT(name) __RWSEM_DEBUG_INIT }
DECL|macro|__DECLARE_RWSEM_GENERIC
mdefine_line|#define __DECLARE_RWSEM_GENERIC(name,count) &bslash;&n;        struct rw_semaphore name = __RWSEM_INITIALIZER(name,count)
DECL|macro|DECLARE_RWSEM
mdefine_line|#define DECLARE_RWSEM(name) __DECLARE_RWSEM_GENERIC(name,RW_LOCK_BIAS)
DECL|macro|DECLARE_RWSEM_READ_LOCKED
mdefine_line|#define DECLARE_RWSEM_READ_LOCKED(name) __DECLARE_RWSEM_GENERIC(name,RW_LOCK_BIAS-1)
DECL|macro|DECLARE_RWSEM_WRITE_LOCKED
mdefine_line|#define DECLARE_RWSEM_WRITE_LOCKED(name) __DECLARE_RWSEM_GENERIC(name,0)
DECL|function|init_rwsem
r_extern
r_inline
r_void
id|init_rwsem
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|sem-&gt;count
comma
id|RW_LOCK_BIAS
)paren
suffix:semicolon
id|sem-&gt;granted
op_assign
l_int|0
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|sem-&gt;write_bias_wait
)paren
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
id|sem-&gt;__magic
op_assign
(paren
r_int
)paren
op_amp
id|sem-&gt;__magic
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|sem-&gt;readers
comma
l_int|0
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|sem-&gt;writers
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* The expensive part is outlined.  */
r_extern
r_void
id|__down_read
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
comma
r_int
id|count
)paren
suffix:semicolon
r_extern
r_void
id|__down_write
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
comma
r_int
id|count
)paren
suffix:semicolon
r_extern
r_void
id|__rwsem_wake
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
comma
r_int
r_int
id|readers
)paren
suffix:semicolon
DECL|function|down_read
r_extern
r_inline
r_void
id|down_read
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_int
id|count
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
id|CHECK_MAGIC
c_func
(paren
id|sem-&gt;__magic
)paren
suffix:semicolon
macro_line|#endif
id|count
op_assign
id|atomic_dec_return
c_func
(paren
op_amp
id|sem-&gt;count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
l_int|0
)paren
(brace
id|__down_read
c_func
(paren
id|sem
comma
id|count
)paren
suffix:semicolon
)brace
id|mb
c_func
(paren
)paren
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
r_if
c_cond
(paren
id|sem-&gt;granted
op_amp
l_int|2
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;writers
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|sem-&gt;readers
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|down_write
r_extern
r_inline
r_void
id|down_write
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_int
id|count
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
id|CHECK_MAGIC
c_func
(paren
id|sem-&gt;__magic
)paren
suffix:semicolon
macro_line|#endif
id|count
op_assign
id|atomic_sub_return
c_func
(paren
id|RW_LOCK_BIAS
comma
op_amp
id|sem-&gt;count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
id|__down_write
c_func
(paren
id|sem
comma
id|count
)paren
suffix:semicolon
)brace
id|mb
c_func
(paren
)paren
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;writers
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;readers
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sem-&gt;granted
op_amp
l_int|3
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|sem-&gt;writers
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* When a reader does a release, the only significant case is when&n;   there was a writer waiting, and we&squot;ve bumped the count to 0: we must&n;   wake the writer up.  */
DECL|function|up_read
r_extern
r_inline
r_void
id|up_read
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
macro_line|#if WAITQUEUE_DEBUG
id|CHECK_MAGIC
c_func
(paren
id|sem-&gt;__magic
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sem-&gt;granted
op_amp
l_int|2
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;writers
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|sem-&gt;readers
)paren
suffix:semicolon
macro_line|#endif
id|mb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_inc_return
c_func
(paren
op_amp
id|sem-&gt;count
)paren
op_eq
l_int|0
)paren
id|__rwsem_wake
c_func
(paren
id|sem
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Releasing the writer is easy -- just release it and wake up any sleepers.&n; */
DECL|function|up_write
r_extern
r_inline
r_void
id|up_write
c_func
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_int
id|count
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
id|CHECK_MAGIC
c_func
(paren
id|sem-&gt;__magic
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sem-&gt;granted
op_amp
l_int|3
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;readers
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;writers
)paren
op_ne
l_int|1
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|sem-&gt;writers
)paren
suffix:semicolon
macro_line|#endif
id|mb
c_func
(paren
)paren
suffix:semicolon
id|count
op_assign
id|atomic_add_return
c_func
(paren
id|RW_LOCK_BIAS
comma
op_amp
id|sem-&gt;count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_minus
id|RW_LOCK_BIAS
OL
l_int|0
op_logical_and
id|count
op_ge
l_int|0
)paren
(brace
multiline_comment|/* Only do the wake if we&squot;re no longer negative.  */
id|__rwsem_wake
c_func
(paren
id|sem
comma
id|count
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
eof
