macro_line|#ifndef _PARISC_CACHEFLUSH_H
DECL|macro|_PARISC_CACHEFLUSH_H
mdefine_line|#define _PARISC_CACHEFLUSH_H
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
multiline_comment|/* The usual comment is &quot;Caches aren&squot;t brain-dead on the &lt;architecture&gt;&quot;.&n; * Unfortunately, that doesn&squot;t apply to PA-RISC. */
multiline_comment|/* Cache flush operations */
macro_line|#ifdef CONFIG_SMP
DECL|macro|flush_cache_mm
mdefine_line|#define flush_cache_mm(mm) flush_cache_all()
macro_line|#else
DECL|macro|flush_cache_mm
mdefine_line|#define flush_cache_mm(mm) flush_cache_all_local()
macro_line|#endif
DECL|macro|flush_kernel_dcache_range
mdefine_line|#define flush_kernel_dcache_range(start,size) &bslash;&n;&t;flush_kernel_dcache_range_asm((start), (start)+(size));
r_extern
r_void
id|flush_cache_all_local
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|cacheflush_h_tmp_function
r_static
r_inline
r_void
id|cacheflush_h_tmp_function
c_func
(paren
r_void
op_star
id|dummy
)paren
(brace
id|flush_cache_all_local
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|flush_cache_all
r_static
r_inline
r_void
id|flush_cache_all
c_func
(paren
r_void
)paren
(brace
id|on_each_cpu
c_func
(paren
id|cacheflush_h_tmp_function
comma
l_int|NULL
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|macro|flush_cache_vmap
mdefine_line|#define flush_cache_vmap(start, end)&t;&t;flush_cache_all()
DECL|macro|flush_cache_vunmap
mdefine_line|#define flush_cache_vunmap(start, end)&t;&t;flush_cache_all()
multiline_comment|/* The following value needs to be tuned and probably scaled with the&n; * cache size.&n; */
DECL|macro|FLUSH_THRESHOLD
mdefine_line|#define FLUSH_THRESHOLD 0x80000
r_static
r_inline
r_void
DECL|function|flush_user_dcache_range
id|flush_user_dcache_range
c_func
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
macro_line|#ifdef CONFIG_SMP
id|flush_user_dcache_range_asm
c_func
(paren
id|start
comma
id|end
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
(paren
id|end
op_minus
id|start
)paren
OL
id|FLUSH_THRESHOLD
)paren
id|flush_user_dcache_range_asm
c_func
(paren
id|start
comma
id|end
)paren
suffix:semicolon
r_else
id|flush_data_cache
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_static
r_inline
r_void
DECL|function|flush_user_icache_range
id|flush_user_icache_range
c_func
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
macro_line|#ifdef CONFIG_SMP
id|flush_user_icache_range_asm
c_func
(paren
id|start
comma
id|end
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
(paren
id|end
op_minus
id|start
)paren
OL
id|FLUSH_THRESHOLD
)paren
id|flush_user_icache_range_asm
c_func
(paren
id|start
comma
id|end
)paren
suffix:semicolon
r_else
id|flush_instruction_cache
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_extern
r_void
id|flush_dcache_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
suffix:semicolon
DECL|macro|flush_dcache_mmap_lock
mdefine_line|#define flush_dcache_mmap_lock(mapping) &bslash;&n;&t;spin_lock_irq(&amp;(mapping)-&gt;tree_lock)
DECL|macro|flush_dcache_mmap_unlock
mdefine_line|#define flush_dcache_mmap_unlock(mapping) &bslash;&n;&t;spin_unlock_irq(&amp;(mapping)-&gt;tree_lock)
DECL|macro|flush_icache_page
mdefine_line|#define flush_icache_page(vma,page)&t;do { flush_kernel_dcache_page(page_address(page)); flush_kernel_icache_page(page_address(page)); } while (0)
DECL|macro|flush_icache_range
mdefine_line|#define flush_icache_range(s,e)&t;&t;do { flush_kernel_dcache_range_asm(s,e); flush_kernel_icache_range_asm(s,e); } while (0)
DECL|macro|copy_to_user_page
mdefine_line|#define copy_to_user_page(vma, page, vaddr, dst, src, len) &bslash;&n;do { memcpy(dst, src, len); &bslash;&n;     flush_kernel_dcache_range_asm((unsigned long)dst, (unsigned long)dst + len); &bslash;&n;} while (0)
DECL|macro|copy_from_user_page
mdefine_line|#define copy_from_user_page(vma, page, vaddr, dst, src, len) &bslash;&n;&t;memcpy(dst, src, len)
DECL|function|flush_cache_range
r_static
r_inline
r_void
id|flush_cache_range
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_int
id|sr3
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma-&gt;vm_mm-&gt;context
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sr3
op_assign
id|mfsp
c_func
(paren
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_mm-&gt;context
op_eq
id|sr3
)paren
(brace
id|flush_user_dcache_range
c_func
(paren
id|start
comma
id|end
)paren
suffix:semicolon
id|flush_user_icache_range
c_func
(paren
id|start
comma
id|end
)paren
suffix:semicolon
)brace
r_else
(brace
id|flush_cache_all
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Simple function to work out if we have an existing address translation&n; * for a user space vma. */
DECL|function|__translation_exists
r_static
r_inline
id|pte_t
op_star
id|__translation_exists
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
)paren
(brace
id|pgd_t
op_star
id|pgd
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|addr
)paren
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
r_if
c_cond
(paren
id|pgd_none
c_func
(paren
op_star
id|pgd
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
op_logical_or
id|pmd_bad
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|pte
op_assign
id|pte_offset_map
c_func
(paren
id|pmd
comma
id|addr
)paren
suffix:semicolon
multiline_comment|/* The PA flush mappings show up as pte_none, but they&squot;re&n;&t; * valid none the less */
r_if
c_cond
(paren
id|pte_none
c_func
(paren
op_star
id|pte
)paren
op_logical_and
(paren
(paren
id|pte_val
c_func
(paren
op_star
id|pte
)paren
op_amp
id|_PAGE_FLUSH
)paren
op_eq
l_int|0
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|pte
suffix:semicolon
)brace
DECL|macro|translation_exists
mdefine_line|#define&t;translation_exists(vma, addr)&t;__translation_exists((vma)-&gt;vm_mm, addr)
multiline_comment|/* Private function to flush a page from the cache of a non-current&n; * process.  cr25 contains the Page Directory of the current user&n; * process; we&squot;re going to hijack both it and the user space %sr3 to&n; * temporarily make the non-current process current.  We have to do&n; * this because cache flushing may cause a non-access tlb miss which&n; * the handlers have to fill in from the pgd of the non-current&n; * process. */
r_static
r_inline
r_void
DECL|function|flush_user_cache_page_non_current
id|flush_user_cache_page_non_current
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|vmaddr
)paren
(brace
multiline_comment|/* save the current process space and pgd */
r_int
r_int
id|space
op_assign
id|mfsp
c_func
(paren
l_int|3
)paren
comma
id|pgd
op_assign
id|mfctl
c_func
(paren
l_int|25
)paren
suffix:semicolon
multiline_comment|/* we don&squot;t mind taking interrups since they may not&n;&t; * do anything with user space, but we can&squot;t&n;&t; * be preempted here */
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* make us current */
id|mtctl
c_func
(paren
id|__pa
c_func
(paren
id|vma-&gt;vm_mm-&gt;pgd
)paren
comma
l_int|25
)paren
suffix:semicolon
id|mtsp
c_func
(paren
id|vma-&gt;vm_mm-&gt;context
comma
l_int|3
)paren
suffix:semicolon
id|flush_user_dcache_page
c_func
(paren
id|vmaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
)paren
(brace
id|flush_user_icache_page
c_func
(paren
id|vmaddr
)paren
suffix:semicolon
)brace
multiline_comment|/* put the old current process back */
id|mtsp
c_func
(paren
id|space
comma
l_int|3
)paren
suffix:semicolon
id|mtctl
c_func
(paren
id|pgd
comma
l_int|25
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|__flush_cache_page
id|__flush_cache_page
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|vmaddr
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|vma-&gt;vm_mm-&gt;context
op_eq
id|mfsp
c_func
(paren
l_int|3
)paren
)paren
)paren
(brace
id|flush_user_dcache_page
c_func
(paren
id|vmaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
)paren
id|flush_user_icache_page
c_func
(paren
id|vmaddr
)paren
suffix:semicolon
)brace
r_else
(brace
id|flush_user_cache_page_non_current
c_func
(paren
id|vma
comma
id|vmaddr
)paren
suffix:semicolon
)brace
)brace
r_static
r_inline
r_void
DECL|function|flush_cache_page
id|flush_cache_page
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|vmaddr
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|vma-&gt;vm_mm-&gt;context
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|translation_exists
c_func
(paren
id|vma
comma
id|vmaddr
)paren
)paren
)paren
(brace
id|__flush_cache_page
c_func
(paren
id|vma
comma
id|vmaddr
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
eof
