macro_line|#ifndef __ASM_SPINLOCK_H
DECL|macro|__ASM_SPINLOCK_H
mdefine_line|#define __ASM_SPINLOCK_H
macro_line|#include &lt;asm/system.h&gt;
multiline_comment|/* Note that PA-RISC has to use `1&squot; to mean unlocked and `0&squot; to mean locked&n; * since it only has load-and-zero. Moreover, at least on some PA processors,&n; * the semaphore address has to be 16-byte aligned.&n; */
macro_line|#ifndef CONFIG_DEBUG_SPINLOCK
DECL|macro|__SPIN_LOCK_UNLOCKED
mdefine_line|#define __SPIN_LOCK_UNLOCKED&t;{ { 1, 1, 1, 1 } }
DECL|macro|SPIN_LOCK_UNLOCKED
macro_line|#undef SPIN_LOCK_UNLOCKED
DECL|macro|SPIN_LOCK_UNLOCKED
mdefine_line|#define SPIN_LOCK_UNLOCKED (spinlock_t) __SPIN_LOCK_UNLOCKED
DECL|macro|spin_lock_init
mdefine_line|#define spin_lock_init(x)&t;do { *(x) = SPIN_LOCK_UNLOCKED; } while(0)
DECL|function|spin_is_locked
r_static
r_inline
r_int
id|spin_is_locked
c_func
(paren
id|spinlock_t
op_star
id|x
)paren
(brace
r_volatile
r_int
r_int
op_star
id|a
op_assign
id|__ldcw_align
c_func
(paren
id|x
)paren
suffix:semicolon
r_return
op_star
id|a
op_eq
l_int|0
suffix:semicolon
)brace
DECL|macro|spin_unlock_wait
mdefine_line|#define spin_unlock_wait(x)&t;do { barrier(); } while(spin_is_locked(x))
DECL|macro|_raw_spin_lock_flags
mdefine_line|#define _raw_spin_lock_flags(lock, flags) _raw_spin_lock(lock)
DECL|function|_raw_spin_lock
r_static
r_inline
r_void
id|_raw_spin_lock
c_func
(paren
id|spinlock_t
op_star
id|x
)paren
(brace
r_volatile
r_int
r_int
op_star
id|a
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|a
op_assign
id|__ldcw_align
c_func
(paren
id|x
)paren
suffix:semicolon
r_while
c_loop
(paren
id|__ldcw
c_func
(paren
id|a
)paren
op_eq
l_int|0
)paren
r_while
c_loop
(paren
op_star
id|a
op_eq
l_int|0
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|_raw_spin_unlock
r_static
r_inline
r_void
id|_raw_spin_unlock
c_func
(paren
id|spinlock_t
op_star
id|x
)paren
(brace
r_volatile
r_int
r_int
op_star
id|a
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|a
op_assign
id|__ldcw_align
c_func
(paren
id|x
)paren
suffix:semicolon
op_star
id|a
op_assign
l_int|1
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|_raw_spin_trylock
r_static
r_inline
r_int
id|_raw_spin_trylock
c_func
(paren
id|spinlock_t
op_star
id|x
)paren
(brace
r_volatile
r_int
r_int
op_star
id|a
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|a
op_assign
id|__ldcw_align
c_func
(paren
id|x
)paren
suffix:semicolon
id|ret
op_assign
id|__ldcw
c_func
(paren
id|a
)paren
op_ne
l_int|0
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|macro|spin_lock_own
mdefine_line|#define spin_lock_own(LOCK, LOCATION)&t;((void)0)
macro_line|#else /* !(CONFIG_DEBUG_SPINLOCK) */
DECL|macro|SPINLOCK_MAGIC
mdefine_line|#define SPINLOCK_MAGIC&t;0x1D244B3C
DECL|macro|__SPIN_LOCK_UNLOCKED
mdefine_line|#define __SPIN_LOCK_UNLOCKED&t;{ { 1, 1, 1, 1 }, SPINLOCK_MAGIC, 10, __FILE__ , NULL, 0, -1, NULL, NULL }
DECL|macro|SPIN_LOCK_UNLOCKED
macro_line|#undef SPIN_LOCK_UNLOCKED
DECL|macro|SPIN_LOCK_UNLOCKED
mdefine_line|#define SPIN_LOCK_UNLOCKED (spinlock_t) __SPIN_LOCK_UNLOCKED
DECL|macro|spin_lock_init
mdefine_line|#define spin_lock_init(x)&t;do { *(x) = SPIN_LOCK_UNLOCKED; } while(0)
DECL|macro|CHECK_LOCK
mdefine_line|#define CHECK_LOCK(x)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;do {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t; &t;if (unlikely((x)-&gt;magic != SPINLOCK_MAGIC)) {&t;&t;&t;&bslash;&n;&t;&t;&t;printk(KERN_ERR &quot;%s:%d: spin_is_locked&quot;&t;&t;&bslash;&n;&t;&t;&t;&quot; on uninitialized spinlock %p.&bslash;n&quot;,&t;&t;&bslash;&n;&t;&t;&t;&t;__FILE__, __LINE__, (x)); &t;&t;&bslash;&n;&t;&t;} &t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;} while(0)
DECL|macro|spin_is_locked
mdefine_line|#define spin_is_locked(x)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;({&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t; &t;CHECK_LOCK(x);&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;volatile unsigned int *a = __ldcw_align(x);&t;&t;&bslash;&n;&t;&t;if (unlikely((*a == 0) &amp;&amp; (x)-&gt;babble)) {&t;&t;&t;&t;&bslash;&n;&t;&t;&t;(x)-&gt;babble--;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;printk(&quot;KERN_WARNING&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;%s:%d: spin_is_locked(%s/%p) already&quot;&t;&bslash;&n;&t;&t;&t;&t;&quot; locked by %s:%d in %s at %p(%d)&bslash;n&quot;,&t;&bslash;&n;&t;&t;&t;&t;__FILE__,__LINE__, (x)-&gt;module,&t;(x),&t;&bslash;&n;&t;&t;&t;&t;(x)-&gt;bfile, (x)-&gt;bline, (x)-&gt;task-&gt;comm,&bslash;&n;&t;&t;&t;&t;(x)-&gt;previous, (x)-&gt;oncpu);&t;&t;&bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;*a == 0;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;})
DECL|macro|spin_unlock_wait
mdefine_line|#define spin_unlock_wait(x)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;do {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t; &t;CHECK_LOCK(x);&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;volatile unsigned int *a = __ldcw_align(x);&t;&t;&bslash;&n;&t;&t;if (unlikely((*a == 0) &amp;&amp; (x)-&gt;babble)) {&t;&t;&t;&t;&bslash;&n;&t;&t;&t;(x)-&gt;babble--;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;printk(&quot;KERN_WARNING&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;%s:%d: spin_unlock_wait(%s/%p)&quot;&t;&t;&bslash;&n;&t;&t;&t;&t;&quot; owned by %s:%d in %s at %p(%d)&bslash;n&quot;,&t;&bslash;&n;&t;&t;&t;&t;__FILE__,__LINE__, (x)-&gt;module, (x),&t;&bslash;&n;&t;&t;&t;&t;(x)-&gt;bfile, (x)-&gt;bline, (x)-&gt;task-&gt;comm,&bslash;&n;&t;&t;&t;&t;(x)-&gt;previous, (x)-&gt;oncpu);&t;&t;&bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;barrier();&t;&t;&t;&t;&t;&t;&bslash;&n;&t;} while (*((volatile unsigned char *)(__ldcw_align(x))) == 0)
r_extern
r_void
id|_dbg_spin_lock
c_func
(paren
id|spinlock_t
op_star
id|lock
comma
r_const
r_char
op_star
id|base_file
comma
r_int
id|line_no
)paren
suffix:semicolon
r_extern
r_void
id|_dbg_spin_unlock
c_func
(paren
id|spinlock_t
op_star
id|lock
comma
r_const
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|_dbg_spin_trylock
c_func
(paren
id|spinlock_t
op_star
id|lock
comma
r_const
r_char
op_star
comma
r_int
)paren
suffix:semicolon
DECL|macro|_raw_spin_lock_flags
mdefine_line|#define _raw_spin_lock_flags(lock, flags) _raw_spin_lock(lock)
DECL|macro|_raw_spin_unlock
mdefine_line|#define _raw_spin_unlock(lock)&t;_dbg_spin_unlock(lock, __FILE__, __LINE__)
DECL|macro|_raw_spin_lock
mdefine_line|#define _raw_spin_lock(lock) _dbg_spin_lock(lock, __FILE__, __LINE__)
DECL|macro|_raw_spin_trylock
mdefine_line|#define _raw_spin_trylock(lock) _dbg_spin_trylock(lock, __FILE__, __LINE__)
multiline_comment|/* just in case we need it */
DECL|macro|spin_lock_own
mdefine_line|#define spin_lock_own(LOCK, LOCATION)&t;&t;&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;volatile unsigned int *a = __ldcw_align(LOCK);&t;&t;&t;&bslash;&n;&t;if (!((*a == 0) &amp;&amp; ((LOCK)-&gt;oncpu == smp_processor_id())))&t;&bslash;&n;&t;&t;printk(&quot;KERN_WARNING&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;%s: called on %d from %p but lock %s on %d&bslash;n&quot;,&t;&bslash;&n;&t;&t;&t;LOCATION, smp_processor_id(),&t;&t;&t;&bslash;&n;&t;&t;&t;__builtin_return_address(0),&t;&t;&t;&bslash;&n;&t;&t;&t;(*a == 0) ? &quot;taken&quot; : &quot;freed&quot;, (LOCK)-&gt;on_cpu);&t;&bslash;&n;} while (0)
macro_line|#endif /* !(CONFIG_DEBUG_SPINLOCK) */
multiline_comment|/*&n; * Read-write spinlocks, allowing multiple readers&n; * but only one writer.&n; */
r_typedef
r_struct
(brace
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|counter
r_volatile
r_int
id|counter
suffix:semicolon
macro_line|#ifdef CONFIG_PREEMPT
DECL|member|break_lock
r_int
r_int
id|break_lock
suffix:semicolon
macro_line|#endif
DECL|typedef|rwlock_t
)brace
id|rwlock_t
suffix:semicolon
DECL|macro|RW_LOCK_UNLOCKED
mdefine_line|#define RW_LOCK_UNLOCKED (rwlock_t) { __SPIN_LOCK_UNLOCKED, 0 }
DECL|macro|rwlock_init
mdefine_line|#define rwlock_init(lp)&t;do { *(lp) = RW_LOCK_UNLOCKED; } while (0)
DECL|macro|_raw_read_trylock
mdefine_line|#define _raw_read_trylock(lock) generic_raw_read_trylock(lock)
multiline_comment|/* read_lock, read_unlock are pretty straightforward.  Of course it somehow&n; * sucks we end up saving/restoring flags twice for read_lock_irqsave aso. */
macro_line|#ifdef CONFIG_DEBUG_RWLOCK
r_extern
r_void
id|_dbg_read_lock
c_func
(paren
id|rwlock_t
op_star
id|rw
comma
r_const
r_char
op_star
id|bfile
comma
r_int
id|bline
)paren
suffix:semicolon
DECL|macro|_raw_read_lock
mdefine_line|#define _raw_read_lock(rw) _dbg_read_lock(rw, __FILE__, __LINE__)
macro_line|#else
DECL|function|_raw_read_lock
r_static
id|__inline__
r_void
id|_raw_read_lock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|_raw_spin_lock
c_func
(paren
op_amp
id|rw-&gt;lock
)paren
suffix:semicolon
id|rw-&gt;counter
op_increment
suffix:semicolon
id|_raw_spin_unlock
c_func
(paren
op_amp
id|rw-&gt;lock
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_DEBUG_RWLOCK */
DECL|function|_raw_read_unlock
r_static
id|__inline__
r_void
id|_raw_read_unlock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|_raw_spin_lock
c_func
(paren
op_amp
id|rw-&gt;lock
)paren
suffix:semicolon
id|rw-&gt;counter
op_decrement
suffix:semicolon
id|_raw_spin_unlock
c_func
(paren
op_amp
id|rw-&gt;lock
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* write_lock is less trivial.  We optimistically grab the lock and check&n; * if we surprised any readers.  If so we release the lock and wait till&n; * they&squot;re all gone before trying again&n; *&n; * Also note that we don&squot;t use the _irqsave / _irqrestore suffixes here.&n; * If we&squot;re called with interrupts enabled and we&squot;ve got readers (or other&n; * writers) in interrupt handlers someone fucked up and we&squot;d dead-lock&n; * sooner or later anyway.   prumpf */
macro_line|#ifdef CONFIG_DEBUG_RWLOCK
r_extern
r_void
id|_dbg_write_lock
c_func
(paren
id|rwlock_t
op_star
id|rw
comma
r_const
r_char
op_star
id|bfile
comma
r_int
id|bline
)paren
suffix:semicolon
DECL|macro|_raw_write_lock
mdefine_line|#define _raw_write_lock(rw) _dbg_write_lock(rw, __FILE__, __LINE__)
macro_line|#else
DECL|function|_raw_write_lock
r_static
id|__inline__
r_void
id|_raw_write_lock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
id|retry
suffix:colon
id|_raw_spin_lock
c_func
(paren
op_amp
id|rw-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rw-&gt;counter
op_ne
l_int|0
)paren
(brace
multiline_comment|/* this basically never happens */
id|_raw_spin_unlock
c_func
(paren
op_amp
id|rw-&gt;lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|rw-&gt;counter
op_ne
l_int|0
)paren
(brace
suffix:semicolon
)brace
r_goto
id|retry
suffix:semicolon
)brace
multiline_comment|/* got it.  now leave without unlocking */
id|rw-&gt;counter
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* remember we are locked */
)brace
macro_line|#endif /* CONFIG_DEBUG_RWLOCK */
multiline_comment|/* write_unlock is absolutely trivial - we don&squot;t have to wait for anything */
DECL|function|_raw_write_unlock
r_static
id|__inline__
r_void
id|_raw_write_unlock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
id|rw-&gt;counter
op_assign
l_int|0
suffix:semicolon
id|_raw_spin_unlock
c_func
(paren
op_amp
id|rw-&gt;lock
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_DEBUG_RWLOCK
r_extern
r_void
id|_dbg_write_trylock
c_func
(paren
id|rwlock_t
op_star
id|rw
comma
r_const
r_char
op_star
id|bfile
comma
r_int
id|bline
)paren
suffix:semicolon
DECL|macro|_raw_write_trylock
mdefine_line|#define _raw_write_trylock(rw) _dbg_write_trylock(rw, __FILE__, __LINE__)
macro_line|#else
DECL|function|_raw_write_trylock
r_static
id|__inline__
r_int
id|_raw_write_trylock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
id|_raw_spin_lock
c_func
(paren
op_amp
id|rw-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rw-&gt;counter
op_ne
l_int|0
)paren
(brace
multiline_comment|/* this basically never happens */
id|_raw_spin_unlock
c_func
(paren
op_amp
id|rw-&gt;lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* got it.  now leave without unlocking */
id|rw-&gt;counter
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* remember we are locked */
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_DEBUG_RWLOCK */
DECL|function|is_read_locked
r_static
id|__inline__
r_int
id|is_read_locked
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
r_return
id|rw-&gt;counter
OG
l_int|0
suffix:semicolon
)brace
DECL|function|is_write_locked
r_static
id|__inline__
r_int
id|is_write_locked
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
r_return
id|rw-&gt;counter
OL
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* __ASM_SPINLOCK_H */
eof
