multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000-2001 Silicon Graphics, Inc. All rights reserved.&n; */
macro_line|#ifndef _ASM_SN_PCI_PCIBR_H
DECL|macro|_ASM_SN_PCI_PCIBR_H
mdefine_line|#define _ASM_SN_PCI_PCIBR_H
macro_line|#if defined(__KERNEL__)
macro_line|#include &lt;asm/sn/dmamap.h&gt;
macro_line|#include &lt;asm/sn/driver.h&gt;
macro_line|#include &lt;asm/sn/pio.h&gt;
macro_line|#include &lt;asm/sn/pci/pciio.h&gt;
macro_line|#include &lt;asm/sn/pci/bridge.h&gt;
multiline_comment|/* =====================================================================&n; *    symbolic constants used by pcibr&squot;s xtalk bus provider&n; */
DECL|macro|PCIBR_PIOMAP_BUSY
mdefine_line|#define PCIBR_PIOMAP_BUSY&t;&t;0x80000000
DECL|macro|PCIBR_DMAMAP_BUSY
mdefine_line|#define PCIBR_DMAMAP_BUSY&t;&t;0x80000000
DECL|macro|PCIBR_DMAMAP_SSRAM
mdefine_line|#define&t;PCIBR_DMAMAP_SSRAM&t;&t;0x40000000
DECL|macro|PCIBR_INTR_BLOCKED
mdefine_line|#define PCIBR_INTR_BLOCKED&t;&t;0x40000000
DECL|macro|PCIBR_INTR_BUSY
mdefine_line|#define PCIBR_INTR_BUSY&t;&t;&t;0x80000000
macro_line|#ifndef __ASSEMBLY__
multiline_comment|/* =====================================================================&n; *    opaque types used by pcibr&squot;s xtalk bus provider&n; */
DECL|typedef|pcibr_piomap_t
r_typedef
r_struct
id|pcibr_piomap_s
op_star
id|pcibr_piomap_t
suffix:semicolon
DECL|typedef|pcibr_dmamap_t
r_typedef
r_struct
id|pcibr_dmamap_s
op_star
id|pcibr_dmamap_t
suffix:semicolon
DECL|typedef|pcibr_intr_t
r_typedef
r_struct
id|pcibr_intr_s
op_star
id|pcibr_intr_t
suffix:semicolon
multiline_comment|/* =====================================================================&n; *    primary entry points: Bridge (pcibr) device driver&n; *&n; *&t;These functions are normal device driver entry points&n; *&t;and are called along with the similar entry points from&n; *&t;other device drivers. They are included here as documentation&n; *&t;of their existence and purpose.&n; *&n; *&t;pcibr_init() is called to inform us that there is a pcibr driver&n; *&t;configured into the kernel; it is responsible for registering&n; *&t;as a crosstalk widget and providing a routine to be called&n; *&t;when a widget with the proper part number is observed.&n; *&n; *&t;pcibr_attach() is called for each vertex in the hardware graph&n; *&t;corresponding to a crosstalk widget with the manufacturer&n; *&t;code and part number registered by pcibr_init().&n; */
r_extern
r_void
id|pcibr_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_attach
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
multiline_comment|/* =====================================================================&n; *    bus provider function table&n; *&n; *&t;Normally, this table is only handed off explicitly&n; *&t;during provider initialization, and the PCI generic&n; *&t;layer will stash a pointer to it in the vertex; however,&n; *&t;exporting it explicitly enables a performance hack in&n; *&t;the generic PCI provider where if we know at compile&n; *&t;time that the only possible PCI provider is a&n; *&t;pcibr, we can go directly to this ops table.&n; */
r_extern
id|pciio_provider_t
id|pcibr_provider
suffix:semicolon
multiline_comment|/* =====================================================================&n; *    secondary entry points: pcibr PCI bus provider&n; *&n; *&t;These functions are normally exported explicitly by&n; *&t;a direct call from the pcibr initialization routine&n; *&t;into the generic crosstalk provider; they are included&n; *&t;here to enable a more aggressive performance hack in&n; *&t;the generic crosstalk layer, where if we know that the&n; *&t;only possible crosstalk provider is pcibr, and we can&n; *&t;guarantee that all entry points are properly named, and&n; *&t;we can deal with the implicit casting properly, then&n; *&t;we can turn many of the generic provider routines into&n; *&t;plain brances, or even eliminate them (given sufficient&n; *&t;smarts on the part of the compilation system).&n; */
r_extern
id|pcibr_piomap_t
id|pcibr_piomap_alloc
c_func
(paren
id|devfs_handle_t
id|dev
comma
id|device_desc_t
id|dev_desc
comma
id|pciio_space_t
id|space
comma
id|iopaddr_t
id|pci_addr
comma
r_int
id|byte_count
comma
r_int
id|byte_count_max
comma
r_int
id|flags
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_piomap_free
c_func
(paren
id|pcibr_piomap_t
id|piomap
)paren
suffix:semicolon
r_extern
id|caddr_t
id|pcibr_piomap_addr
c_func
(paren
id|pcibr_piomap_t
id|piomap
comma
id|iopaddr_t
id|xtalk_addr
comma
r_int
id|byte_count
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_piomap_done
c_func
(paren
id|pcibr_piomap_t
id|piomap
)paren
suffix:semicolon
r_extern
id|caddr_t
id|pcibr_piotrans_addr
c_func
(paren
id|devfs_handle_t
id|dev
comma
id|device_desc_t
id|dev_desc
comma
id|pciio_space_t
id|space
comma
id|iopaddr_t
id|pci_addr
comma
r_int
id|byte_count
comma
r_int
id|flags
)paren
suffix:semicolon
r_extern
id|iopaddr_t
id|pcibr_piospace_alloc
c_func
(paren
id|devfs_handle_t
id|dev
comma
id|device_desc_t
id|dev_desc
comma
id|pciio_space_t
id|space
comma
r_int
id|byte_count
comma
r_int
id|alignment
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_piospace_free
c_func
(paren
id|devfs_handle_t
id|dev
comma
id|pciio_space_t
id|space
comma
id|iopaddr_t
id|pciaddr
comma
r_int
id|byte_count
)paren
suffix:semicolon
r_extern
id|pcibr_dmamap_t
id|pcibr_dmamap_alloc
c_func
(paren
id|devfs_handle_t
id|dev
comma
id|device_desc_t
id|dev_desc
comma
r_int
id|byte_count_max
comma
r_int
id|flags
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_dmamap_free
c_func
(paren
id|pcibr_dmamap_t
id|dmamap
)paren
suffix:semicolon
r_extern
id|iopaddr_t
id|pcibr_dmamap_addr
c_func
(paren
id|pcibr_dmamap_t
id|dmamap
comma
id|paddr_t
id|paddr
comma
r_int
id|byte_count
)paren
suffix:semicolon
r_extern
id|alenlist_t
id|pcibr_dmamap_list
c_func
(paren
id|pcibr_dmamap_t
id|dmamap
comma
id|alenlist_t
id|palenlist
comma
r_int
id|flags
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_dmamap_done
c_func
(paren
id|pcibr_dmamap_t
id|dmamap
)paren
suffix:semicolon
multiline_comment|/*&n; * pcibr_get_dmatrans_node() will return the compact node id to which  &n; * all 32-bit Direct Mapping memory accesses will be directed.&n; * (This node id can be different for each PCI bus.) &n; */
r_extern
id|cnodeid_t
id|pcibr_get_dmatrans_node
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
)paren
suffix:semicolon
r_extern
id|iopaddr_t
id|pcibr_dmatrans_addr
c_func
(paren
id|devfs_handle_t
id|dev
comma
id|device_desc_t
id|dev_desc
comma
id|paddr_t
id|paddr
comma
r_int
id|byte_count
comma
r_int
id|flags
)paren
suffix:semicolon
r_extern
id|alenlist_t
id|pcibr_dmatrans_list
c_func
(paren
id|devfs_handle_t
id|dev
comma
id|device_desc_t
id|dev_desc
comma
id|alenlist_t
id|palenlist
comma
r_int
id|flags
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_dmamap_drain
c_func
(paren
id|pcibr_dmamap_t
id|map
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_dmaaddr_drain
c_func
(paren
id|devfs_handle_t
id|vhdl
comma
id|paddr_t
id|addr
comma
r_int
id|bytes
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_dmalist_drain
c_func
(paren
id|devfs_handle_t
id|vhdl
comma
id|alenlist_t
id|list
)paren
suffix:semicolon
DECL|typedef|pcibr_intr_ibit_f
r_typedef
r_int
id|pcibr_intr_ibit_f
c_func
(paren
id|pciio_info_t
id|info
comma
id|pciio_intr_line_t
id|lines
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_intr_ibit_set
c_func
(paren
id|devfs_handle_t
comma
id|pcibr_intr_ibit_f
op_star
)paren
suffix:semicolon
r_extern
id|pcibr_intr_t
id|pcibr_intr_alloc
c_func
(paren
id|devfs_handle_t
id|dev
comma
id|device_desc_t
id|dev_desc
comma
id|pciio_intr_line_t
id|lines
comma
id|devfs_handle_t
id|owner_dev
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_intr_free
c_func
(paren
id|pcibr_intr_t
id|intr
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_intr_connect
c_func
(paren
id|pcibr_intr_t
id|intr
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_intr_disconnect
c_func
(paren
id|pcibr_intr_t
id|intr
)paren
suffix:semicolon
r_extern
id|devfs_handle_t
id|pcibr_intr_cpu_get
c_func
(paren
id|pcibr_intr_t
id|intr
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_provider_startup
c_func
(paren
id|devfs_handle_t
id|pcibr
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_provider_shutdown
c_func
(paren
id|devfs_handle_t
id|pcibr
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_reset
c_func
(paren
id|devfs_handle_t
id|dev
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_write_gather_flush
c_func
(paren
id|devfs_handle_t
id|dev
)paren
suffix:semicolon
r_extern
id|pciio_endian_t
id|pcibr_endian_set
c_func
(paren
id|devfs_handle_t
id|dev
comma
id|pciio_endian_t
id|device_end
comma
id|pciio_endian_t
id|desired_end
)paren
suffix:semicolon
r_extern
id|pciio_priority_t
id|pcibr_priority_set
c_func
(paren
id|devfs_handle_t
id|dev
comma
id|pciio_priority_t
id|device_prio
)paren
suffix:semicolon
r_extern
r_uint64
id|pcibr_config_get
c_func
(paren
id|devfs_handle_t
id|conn
comma
r_int
id|reg
comma
r_int
id|size
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_config_set
c_func
(paren
id|devfs_handle_t
id|conn
comma
r_int
id|reg
comma
r_int
id|size
comma
r_uint64
id|value
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_error_devenable
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
comma
r_int
id|error_code
)paren
suffix:semicolon
r_extern
id|pciio_slot_t
id|pcibr_error_extract
c_func
(paren
id|devfs_handle_t
id|pcibr_vhdl
comma
id|pciio_space_t
op_star
id|spacep
comma
id|iopaddr_t
op_star
id|addrp
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_wrb_flush
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_rrb_check
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
comma
r_int
op_star
id|count_vchan0
comma
r_int
op_star
id|count_vchan1
comma
r_int
op_star
id|count_reserved
comma
r_int
op_star
id|count_pool
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_alloc_all_rrbs
c_func
(paren
id|devfs_handle_t
id|vhdl
comma
r_int
id|even_odd
comma
r_int
id|dev_1_rrbs
comma
r_int
id|virt1
comma
r_int
id|dev_2_rrbs
comma
r_int
id|virt2
comma
r_int
id|dev_3_rrbs
comma
r_int
id|virt3
comma
r_int
id|dev_4_rrbs
comma
r_int
id|virt4
)paren
suffix:semicolon
r_typedef
r_void
DECL|typedef|rrb_alloc_funct_f
id|rrb_alloc_funct_f
(paren
id|devfs_handle_t
id|xconn_vhdl
comma
r_int
op_star
id|vendor_list
)paren
suffix:semicolon
DECL|typedef|rrb_alloc_funct_t
r_typedef
id|rrb_alloc_funct_f
op_star
id|rrb_alloc_funct_t
suffix:semicolon
r_void
id|pcibr_set_rrb_callback
c_func
(paren
id|devfs_handle_t
id|xconn_vhdl
comma
id|rrb_alloc_funct_f
op_star
id|func
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_device_unregister
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_dma_enabled
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
multiline_comment|/*&n; * Bridge-specific flags that can be set via pcibr_device_flags_set&n; * and cleared via pcibr_device_flags_clear.  Other flags are&n; * more generic and are maniuplated through PCI-generic interfaces.&n; *&n; * Note that all PCI implementation-specific flags (Bridge flags, in&n; * this case) are in bits 15-31.  The lower 15 bits are reserved&n; * for PCI-generic flags.&n; *&n; * Some of these flags have been &quot;promoted&quot; to the&n; * generic layer, so they can be used without having&n; * to &quot;know&quot; that the PCI bus is hosted by a Bridge.&n; *&n; * PCIBR_NO_ATE_ROUNDUP: Request that no rounding up be done when &n; * allocating ATE&squot;s. ATE count computation will assume that the&n; * address to be mapped will start on a page boundary.&n; */
DECL|macro|PCIBR_NO_ATE_ROUNDUP
mdefine_line|#define PCIBR_NO_ATE_ROUNDUP    0x00008000
DECL|macro|PCIBR_WRITE_GATHER
mdefine_line|#define PCIBR_WRITE_GATHER&t;0x00010000&t;/* please use PCIIO version */
DECL|macro|PCIBR_NOWRITE_GATHER
mdefine_line|#define PCIBR_NOWRITE_GATHER&t;0x00020000&t;/* please use PCIIO version */
DECL|macro|PCIBR_PREFETCH
mdefine_line|#define PCIBR_PREFETCH&t;&t;0x00040000&t;/* please use PCIIO version */
DECL|macro|PCIBR_NOPREFETCH
mdefine_line|#define PCIBR_NOPREFETCH&t;0x00080000&t;/* please use PCIIO version */
DECL|macro|PCIBR_PRECISE
mdefine_line|#define PCIBR_PRECISE&t;&t;0x00100000
DECL|macro|PCIBR_NOPRECISE
mdefine_line|#define PCIBR_NOPRECISE&t;&t;0x00200000
DECL|macro|PCIBR_BARRIER
mdefine_line|#define PCIBR_BARRIER&t;&t;0x00400000
DECL|macro|PCIBR_NOBARRIER
mdefine_line|#define PCIBR_NOBARRIER&t;&t;0x00800000
DECL|macro|PCIBR_VCHAN0
mdefine_line|#define PCIBR_VCHAN0&t;&t;0x01000000
DECL|macro|PCIBR_VCHAN1
mdefine_line|#define PCIBR_VCHAN1&t;&t;0x02000000
DECL|macro|PCIBR_64BIT
mdefine_line|#define PCIBR_64BIT&t;&t;0x04000000
DECL|macro|PCIBR_NO64BIT
mdefine_line|#define PCIBR_NO64BIT&t;&t;0x08000000
DECL|macro|PCIBR_SWAP
mdefine_line|#define PCIBR_SWAP&t;&t;0x10000000
DECL|macro|PCIBR_NOSWAP
mdefine_line|#define PCIBR_NOSWAP&t;&t;0x20000000
DECL|macro|PCIBR_EXTERNAL_ATES
mdefine_line|#define&t;PCIBR_EXTERNAL_ATES&t;0x40000000&t;/* uses external ATEs */
DECL|macro|PCIBR_ACTIVE
mdefine_line|#define&t;PCIBR_ACTIVE&t;&t;0x80000000&t;/* need a &quot;done&quot; */
multiline_comment|/* Flags that have meaning to pcibr_device_flags_{set,clear} */
DECL|macro|PCIBR_DEVICE_FLAGS
mdefine_line|#define PCIBR_DEVICE_FLAGS (&t;&bslash;&n;&t;PCIBR_WRITE_GATHER&t;|&bslash;&n;&t;PCIBR_NOWRITE_GATHER&t;|&bslash;&n;&t;PCIBR_PREFETCH&t;&t;|&bslash;&n;&t;PCIBR_NOPREFETCH&t;|&bslash;&n;&t;PCIBR_PRECISE&t;&t;|&bslash;&n;&t;PCIBR_NOPRECISE&t;&t;|&bslash;&n;&t;PCIBR_BARRIER&t;&t;|&bslash;&n;&t;PCIBR_NOBARRIER&t;&t;&bslash;&n;)
multiline_comment|/* Flags that have meaning to *_dmamap_alloc, *_dmatrans_{addr,list} */
DECL|macro|PCIBR_DMA_FLAGS
mdefine_line|#define PCIBR_DMA_FLAGS (&t;&bslash;&n;&t;PCIBR_PREFETCH&t;&t;|&bslash;&n;&t;PCIBR_NOPREFETCH&t;|&bslash;&n;&t;PCIBR_PRECISE&t;&t;|&bslash;&n;&t;PCIBR_NOPRECISE&t;&t;|&bslash;&n;&t;PCIBR_BARRIER&t;&t;|&bslash;&n;&t;PCIBR_NOBARRIER&t;&t;|&bslash;&n;&t;PCIBR_VCHAN0&t;&t;|&bslash;&n;&t;PCIBR_VCHAN1&t;&t;&bslash;&n;)
DECL|typedef|pcibr_device_flags_t
r_typedef
r_int
id|pcibr_device_flags_t
suffix:semicolon
multiline_comment|/*&n; * Set bits in the Bridge Device(x) register for this device.&n; * &quot;flags&quot; are defined above. NOTE: this includes turning&n; * things *OFF* as well as turning them *ON* ...&n; */
r_extern
r_int
id|pcibr_device_flags_set
c_func
(paren
id|devfs_handle_t
id|dev
comma
id|pcibr_device_flags_t
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n; * Allocate Read Response Buffers for use by the specified device.&n; * count_vchan0 is the total number of buffers desired for the&n; * &quot;normal&quot; channel.  count_vchan1 is the total number of buffers&n; * desired for the &quot;virtual&quot; channel.  Returns 0 on success, or&n; * &lt;0 on failure, which occurs when we&squot;re unable to allocate any&n; * buffers to a channel that desires at least one buffer.&n; */
r_extern
r_int
id|pcibr_rrb_alloc
c_func
(paren
id|devfs_handle_t
id|pconn_vhdl
comma
r_int
op_star
id|count_vchan0
comma
r_int
op_star
id|count_vchan1
)paren
suffix:semicolon
multiline_comment|/*&n; * Get the starting PCIbus address out of the given DMA map.&n; * This function is supposed to be used by a close friend of PCI bridge&n; * since it relies on the fact that the starting address of the map is fixed at&n; * the allocation time in the current implementation of PCI bridge.&n; */
r_extern
id|iopaddr_t
id|pcibr_dmamap_pciaddr_get
c_func
(paren
id|pcibr_dmamap_t
)paren
suffix:semicolon
r_extern
id|xwidget_intr_preset_f
id|pcibr_xintr_preset
suffix:semicolon
r_extern
r_void
id|pcibr_hints_fix_rrbs
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_hints_dualslot
c_func
(paren
id|devfs_handle_t
comma
id|pciio_slot_t
comma
id|pciio_slot_t
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_hints_subdevs
c_func
(paren
id|devfs_handle_t
comma
id|pciio_slot_t
comma
id|ulong
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_hints_handsoff
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
DECL|typedef|pcibr_intr_bits_f
r_typedef
r_int
id|pcibr_intr_bits_f
c_func
(paren
id|pciio_info_t
comma
id|pciio_intr_line_t
)paren
suffix:semicolon
r_extern
r_void
id|pcibr_hints_intr_bits
c_func
(paren
id|devfs_handle_t
comma
id|pcibr_intr_bits_f
op_star
)paren
suffix:semicolon
r_extern
r_int
id|pcibr_asic_rev
c_func
(paren
id|devfs_handle_t
)paren
suffix:semicolon
macro_line|#endif &t;/* __ASSEMBLY__ */
macro_line|#endif&t;/* #if defined(__KERNEL__) */
multiline_comment|/* &n; * Some useful ioctls into the pcibr driver&n; */
DECL|macro|PCIBR
mdefine_line|#define PCIBR&t;&t;&t;&squot;p&squot;
DECL|macro|_PCIBR
mdefine_line|#define _PCIBR(x)&t;&t;((PCIBR &lt;&lt; 8) | (x))
DECL|macro|PCIBR_SLOT_STARTUP
mdefine_line|#define PCIBR_SLOT_STARTUP&t;_PCIBR(1)
DECL|macro|PCIBR_SLOT_SHUTDOWN
mdefine_line|#define PCIBR_SLOT_SHUTDOWN     _PCIBR(2)
DECL|macro|PCIBR_SLOT_QUERY
mdefine_line|#define PCIBR_SLOT_QUERY&t;_PCIBR(3)
multiline_comment|/*&n; * Bit defintions for variable slot_status in struct&n; * pcibr_soft_slot_s.  They are here so that both&n; * the pcibr driver and the pciconfig command can&n; * reference them.&n; */
DECL|macro|SLOT_STARTUP_CMPLT
mdefine_line|#define SLOT_STARTUP_CMPLT      0x01
DECL|macro|SLOT_STARTUP_INCMPLT
mdefine_line|#define SLOT_STARTUP_INCMPLT    0x02
DECL|macro|SLOT_SHUTDOWN_CMPLT
mdefine_line|#define SLOT_SHUTDOWN_CMPLT     0x04
DECL|macro|SLOT_SHUTDOWN_INCMPLT
mdefine_line|#define SLOT_SHUTDOWN_INCMPLT   0x08
DECL|macro|SLOT_POWER_UP
mdefine_line|#define SLOT_POWER_UP           0x10
DECL|macro|SLOT_POWER_DOWN
mdefine_line|#define SLOT_POWER_DOWN         0x20
DECL|macro|SLOT_IS_SYS_CRITICAL
mdefine_line|#define SLOT_IS_SYS_CRITICAL    0x40
DECL|macro|SLOT_STATUS_MASK
mdefine_line|#define SLOT_STATUS_MASK        (SLOT_STARTUP_CMPLT | SLOT_STARTUP_INCMPLT | &bslash;&n;                                 SLOT_SHUTDOWN_CMPLT | SLOT_SHUTDOWN_INCMPLT)
DECL|macro|SLOT_POWER_MASK
mdefine_line|#define SLOT_POWER_MASK         (SLOT_POWER_UP | SLOT_POWER_DOWN)
multiline_comment|/*&n; * Bit definitions for variable resp_f_staus.&n; * They are here so that both the pcibr driver&n; * and the pciconfig command can reference them.&n; */
DECL|macro|FUNC_IS_VALID
mdefine_line|#define FUNC_IS_VALID           0x01
DECL|macro|FUNC_IS_SYS_CRITICAL
mdefine_line|#define FUNC_IS_SYS_CRITICAL    0x02
multiline_comment|/*&n; * Structures for requesting PCI bridge information and receiving a response&n; */
DECL|typedef|pcibr_slot_req_t
r_typedef
r_struct
id|pcibr_slot_req_s
op_star
id|pcibr_slot_req_t
suffix:semicolon
DECL|typedef|pcibr_slot_up_resp_t
r_typedef
r_struct
id|pcibr_slot_up_resp_s
op_star
id|pcibr_slot_up_resp_t
suffix:semicolon
DECL|typedef|pcibr_slot_down_resp_t
r_typedef
r_struct
id|pcibr_slot_down_resp_s
op_star
id|pcibr_slot_down_resp_t
suffix:semicolon
DECL|typedef|pcibr_slot_info_resp_t
r_typedef
r_struct
id|pcibr_slot_info_resp_s
op_star
id|pcibr_slot_info_resp_t
suffix:semicolon
DECL|typedef|pcibr_slot_func_info_resp_t
r_typedef
r_struct
id|pcibr_slot_func_info_resp_s
op_star
id|pcibr_slot_func_info_resp_t
suffix:semicolon
DECL|macro|L1_QSIZE
mdefine_line|#define L1_QSIZE                128      /* our L1 message buffer size */
DECL|struct|pcibr_slot_req_s
r_struct
id|pcibr_slot_req_s
(brace
DECL|member|req_slot
r_int
id|req_slot
suffix:semicolon
r_union
(brace
DECL|member|up
id|pcibr_slot_up_resp_t
id|up
suffix:semicolon
DECL|member|down
id|pcibr_slot_down_resp_t
id|down
suffix:semicolon
DECL|member|query
id|pcibr_slot_info_resp_t
id|query
suffix:semicolon
DECL|member|any
r_void
op_star
id|any
suffix:semicolon
DECL|member|req_respp
)brace
id|req_respp
suffix:semicolon
DECL|member|req_size
r_int
id|req_size
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|pcibr_slot_up_resp_s
r_struct
id|pcibr_slot_up_resp_s
(brace
DECL|member|resp_sub_errno
r_int
id|resp_sub_errno
suffix:semicolon
DECL|member|resp_l1_msg
r_char
id|resp_l1_msg
(braket
id|L1_QSIZE
op_plus
l_int|1
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|pcibr_slot_down_resp_s
r_struct
id|pcibr_slot_down_resp_s
(brace
DECL|member|resp_sub_errno
r_int
id|resp_sub_errno
suffix:semicolon
DECL|member|resp_l1_msg
r_char
id|resp_l1_msg
(braket
id|L1_QSIZE
op_plus
l_int|1
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|pcibr_slot_info_req_s
r_struct
id|pcibr_slot_info_req_s
(brace
DECL|member|req_slot
r_int
id|req_slot
suffix:semicolon
DECL|member|req_respp
id|pcibr_slot_info_resp_t
id|req_respp
suffix:semicolon
DECL|member|req_size
r_int
id|req_size
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|pcibr_slot_info_resp_s
r_struct
id|pcibr_slot_info_resp_s
(brace
DECL|member|resp_has_host
r_int
id|resp_has_host
suffix:semicolon
DECL|member|resp_host_slot
r_char
id|resp_host_slot
suffix:semicolon
DECL|member|resp_slot_conn
id|devfs_handle_t
id|resp_slot_conn
suffix:semicolon
DECL|member|resp_slot_conn_name
r_char
id|resp_slot_conn_name
(braket
id|MAXDEVNAME
)braket
suffix:semicolon
DECL|member|resp_slot_status
r_int
id|resp_slot_status
suffix:semicolon
DECL|member|resp_l1_bus_num
r_int
id|resp_l1_bus_num
suffix:semicolon
DECL|member|resp_bss_ninfo
r_int
id|resp_bss_ninfo
suffix:semicolon
DECL|member|resp_bss_devio_bssd_space
r_char
id|resp_bss_devio_bssd_space
(braket
l_int|16
)braket
suffix:semicolon
DECL|member|resp_bss_devio_bssd_base
id|iopaddr_t
id|resp_bss_devio_bssd_base
suffix:semicolon
DECL|member|resp_bss_device
id|bridgereg_t
id|resp_bss_device
suffix:semicolon
DECL|member|resp_bss_pmu_uctr
r_int
id|resp_bss_pmu_uctr
suffix:semicolon
DECL|member|resp_bss_d32_uctr
r_int
id|resp_bss_d32_uctr
suffix:semicolon
DECL|member|resp_bss_d64_uctr
r_int
id|resp_bss_d64_uctr
suffix:semicolon
DECL|member|resp_bss_d64_base
id|iopaddr_t
id|resp_bss_d64_base
suffix:semicolon
DECL|member|resp_bss_d64_flags
r_int
id|resp_bss_d64_flags
suffix:semicolon
DECL|member|resp_bss_d32_base
id|iopaddr_t
id|resp_bss_d32_base
suffix:semicolon
DECL|member|resp_bss_d32_flags
r_int
id|resp_bss_d32_flags
suffix:semicolon
DECL|member|resp_bss_ext_ates_active
r_int
id|resp_bss_ext_ates_active
suffix:semicolon
DECL|member|resp_bss_cmd_pointer
r_volatile
r_int
op_star
id|resp_bss_cmd_pointer
suffix:semicolon
DECL|member|resp_bss_cmd_shadow
r_int
id|resp_bss_cmd_shadow
suffix:semicolon
DECL|member|resp_bs_rrb_valid
r_int
id|resp_bs_rrb_valid
suffix:semicolon
DECL|member|resp_bs_rrb_valid_v
r_int
id|resp_bs_rrb_valid_v
suffix:semicolon
DECL|member|resp_bs_rrb_res
r_int
id|resp_bs_rrb_res
suffix:semicolon
DECL|member|resp_b_resp
id|bridgereg_t
id|resp_b_resp
suffix:semicolon
DECL|member|resp_b_int_device
id|bridgereg_t
id|resp_b_int_device
suffix:semicolon
DECL|member|resp_b_int_enable
id|bridgereg_t
id|resp_b_int_enable
suffix:semicolon
DECL|member|resp_b_int_host
id|bridgereg_t
id|resp_b_int_host
suffix:semicolon
DECL|struct|pcibr_slot_func_info_resp_s
r_struct
id|pcibr_slot_func_info_resp_s
(brace
DECL|member|resp_f_status
r_int
id|resp_f_status
suffix:semicolon
DECL|member|resp_f_slot_name
r_char
id|resp_f_slot_name
(braket
id|MAXDEVNAME
)braket
suffix:semicolon
DECL|member|resp_f_bus
r_char
id|resp_f_bus
suffix:semicolon
DECL|member|resp_f_slot
r_char
id|resp_f_slot
suffix:semicolon
DECL|member|resp_f_func
r_char
id|resp_f_func
suffix:semicolon
DECL|member|resp_f_master_name
r_char
id|resp_f_master_name
(braket
id|MAXDEVNAME
)braket
suffix:semicolon
DECL|member|resp_f_pops
r_void
op_star
id|resp_f_pops
suffix:semicolon
DECL|member|resp_f_efunc
id|error_handler_f
op_star
id|resp_f_efunc
suffix:semicolon
DECL|member|resp_f_einfo
id|error_handler_arg_t
id|resp_f_einfo
suffix:semicolon
DECL|member|resp_f_vendor
r_int
id|resp_f_vendor
suffix:semicolon
DECL|member|resp_f_device
r_int
id|resp_f_device
suffix:semicolon
r_struct
(brace
DECL|member|resp_w_space
r_char
id|resp_w_space
(braket
l_int|16
)braket
suffix:semicolon
DECL|member|resp_w_base
id|iopaddr_t
id|resp_w_base
suffix:semicolon
DECL|member|resp_w_size
r_int
id|resp_w_size
suffix:semicolon
DECL|member|resp_f_window
)brace
id|resp_f_window
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|resp_f_rbase
r_int
id|resp_f_rbase
suffix:semicolon
DECL|member|resp_f_rsize
r_int
id|resp_f_rsize
suffix:semicolon
DECL|member|resp_f_ibit
r_int
id|resp_f_ibit
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|resp_f_att_det_error
r_int
id|resp_f_att_det_error
suffix:semicolon
DECL|member|resp_func
)brace
id|resp_func
(braket
l_int|8
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * PCI specific errors, interpreted by pciconfig command&n; */
multiline_comment|/* EPERM                          1    */
DECL|macro|PCI_SLOT_ALREADY_UP
mdefine_line|#define PCI_SLOT_ALREADY_UP       2     /* slot already up */
DECL|macro|PCI_SLOT_ALREADY_DOWN
mdefine_line|#define PCI_SLOT_ALREADY_DOWN     3     /* slot already down */
DECL|macro|PCI_IS_SYS_CRITICAL
mdefine_line|#define PCI_IS_SYS_CRITICAL       4     /* slot is system critical */
multiline_comment|/* EIO                            5    */
multiline_comment|/* ENXIO                          6    */
DECL|macro|PCI_L1_ERR
mdefine_line|#define PCI_L1_ERR                7     /* L1 console command error */
DECL|macro|PCI_NOT_A_BRIDGE
mdefine_line|#define PCI_NOT_A_BRIDGE          8     /* device is not a bridge */
DECL|macro|PCI_SLOT_IN_SHOEHORN
mdefine_line|#define PCI_SLOT_IN_SHOEHORN      9     /* slot is in a shorhorn */
DECL|macro|PCI_NOT_A_SLOT
mdefine_line|#define PCI_NOT_A_SLOT           10     /* slot is invalid */
DECL|macro|PCI_RESP_AREA_TOO_SMALL
mdefine_line|#define PCI_RESP_AREA_TOO_SMALL  11     /* slot is invalid */
multiline_comment|/* ENOMEM                        12    */
DECL|macro|PCI_NO_DRIVER
mdefine_line|#define PCI_NO_DRIVER            13     /* no driver for device */
multiline_comment|/* EFAULT                        14    */
DECL|macro|PCI_EMPTY_33MHZ
mdefine_line|#define PCI_EMPTY_33MHZ          15     /* empty 33 MHz bus */
multiline_comment|/* EBUSY                         16    */
DECL|macro|PCI_SLOT_RESET_ERR
mdefine_line|#define PCI_SLOT_RESET_ERR       17     /* slot reset error */
DECL|macro|PCI_SLOT_INFO_INIT_ERR
mdefine_line|#define PCI_SLOT_INFO_INIT_ERR   18     /* slot info init error */
multiline_comment|/* ENODEV                        19    */
DECL|macro|PCI_SLOT_ADDR_INIT_ERR
mdefine_line|#define PCI_SLOT_ADDR_INIT_ERR   20     /* slot addr space init error */
DECL|macro|PCI_SLOT_DEV_INIT_ERR
mdefine_line|#define PCI_SLOT_DEV_INIT_ERR    21     /* slot device init error */
multiline_comment|/* EINVAL                        22    */
DECL|macro|PCI_SLOT_GUEST_INIT_ERR
mdefine_line|#define PCI_SLOT_GUEST_INIT_ERR  23     /* slot guest info init error */
DECL|macro|PCI_SLOT_RRB_ALLOC_ERR
mdefine_line|#define PCI_SLOT_RRB_ALLOC_ERR   24     /* slot initial rrb alloc error */
DECL|macro|PCI_SLOT_DRV_ATTACH_ERR
mdefine_line|#define PCI_SLOT_DRV_ATTACH_ERR  25     /* driver attach error */
DECL|macro|PCI_SLOT_DRV_DETACH_ERR
mdefine_line|#define PCI_SLOT_DRV_DETACH_ERR  26     /* driver detach error */
multiline_comment|/* ERANGE                        34    */
multiline_comment|/* EUNATCH                       42    */
macro_line|#endif&t;&t;&t;&t;/* _ASM_SN_PCI_PCIBR_H */
eof
