multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000-2001 Silicon Graphics, Inc. All rights reserved.&n; */
macro_line|#ifndef _ASM_IA64_SN_SN1_HUBPI_H
DECL|macro|_ASM_IA64_SN_SN1_HUBPI_H
mdefine_line|#define _ASM_IA64_SN_SN1_HUBPI_H
multiline_comment|/************************************************************************&n; *                                                                      *&n; *      WARNING!!!  WARNING!!!  WARNING!!!  WARNING!!!  WARNING!!!      *&n; *                                                                      *&n; * This file is created by an automated script. Any (minimal) changes   *&n; * made manually to this  file should be made with care.                *&n; *                                                                      *&n; *               MAKE ALL ADDITIONS TO THE END OF THIS FILE             *&n; *                                                                      *&n; ************************************************************************/
DECL|macro|PI_CPU_PROTECT
mdefine_line|#define    PI_CPU_PROTECT            0x00000000    /* CPU Protection         */
DECL|macro|PI_PROT_OVRRD
mdefine_line|#define    PI_PROT_OVRRD             0x00000008    /*&n;                                                    * Clear CPU&n;                                                    * Protection bit in &n;                                                    * CPU_PROTECT&n;                                                    */
DECL|macro|PI_IO_PROTECT
mdefine_line|#define    PI_IO_PROTECT             0x00000010    /*&n;                                                    * Interrupt Pending&n;                                                    * Protection for IO&n;                                                    * access&n;                                                    */
DECL|macro|PI_REGION_PRESENT
mdefine_line|#define    PI_REGION_PRESENT         0x00000018    /* Region present         */
DECL|macro|PI_CPU_NUM
mdefine_line|#define    PI_CPU_NUM                0x00000020    /* CPU Number ID          */
DECL|macro|PI_CALIAS_SIZE
mdefine_line|#define    PI_CALIAS_SIZE            0x00000028    /* Cached Alias Size      */
DECL|macro|PI_MAX_CRB_TIMEOUT
mdefine_line|#define    PI_MAX_CRB_TIMEOUT        0x00000030    /*&n;                                                    * Maximum Timeout for&n;                                                    * CRB&n;                                                    */
DECL|macro|PI_CRB_SFACTOR
mdefine_line|#define    PI_CRB_SFACTOR            0x00000038    /*&n;                                                    * Scale Factor for&n;                                                    * CRB Timeout&n;                                                    */
DECL|macro|PI_CPU_PRESENT_A
mdefine_line|#define    PI_CPU_PRESENT_A          0x00000040    /*&n;                                                    * CPU Present for&n;                                                    * CPU_A&n;                                                    */
DECL|macro|PI_CPU_PRESENT_B
mdefine_line|#define    PI_CPU_PRESENT_B          0x00000048    /*&n;                                                    * CPU Present for&n;                                                    * CPU_B&n;                                                    */
DECL|macro|PI_CPU_ENABLE_A
mdefine_line|#define    PI_CPU_ENABLE_A           0x00000050    /*&n;                                                    * CPU Enable for&n;                                                    * CPU_A&n;                                                    */
DECL|macro|PI_CPU_ENABLE_B
mdefine_line|#define    PI_CPU_ENABLE_B           0x00000058    /*&n;                                                    * CPU Enable for&n;                                                    * CPU_B&n;                                                    */
DECL|macro|PI_REPLY_LEVEL
mdefine_line|#define    PI_REPLY_LEVEL            0x00010060    /*&n;                                                    * Reply FIFO Priority&n;                                                    * Control&n;                                                    */
DECL|macro|PI_GFX_CREDIT_MODE
mdefine_line|#define    PI_GFX_CREDIT_MODE        0x00020068    /*&n;                                                    * Graphics Credit&n;                                                    * Mode&n;                                                    */
DECL|macro|PI_NMI_A
mdefine_line|#define    PI_NMI_A                  0x00000070    /*&n;                                                    * Non-maskable&n;                                                    * Interrupt to CPU A&n;                                                    */
DECL|macro|PI_NMI_B
mdefine_line|#define    PI_NMI_B                  0x00000078    /*&n;                                                    * Non-maskable&n;                                                    * Interrupt to CPU B&n;                                                    */
DECL|macro|PI_INT_PEND_MOD
mdefine_line|#define    PI_INT_PEND_MOD           0x00000090    /*&n;                                                    * Interrupt Pending&n;                                                    * Modify&n;                                                    */
DECL|macro|PI_INT_PEND0
mdefine_line|#define    PI_INT_PEND0              0x00000098    /* Interrupt Pending 0    */
DECL|macro|PI_INT_PEND1
mdefine_line|#define    PI_INT_PEND1              0x000000A0    /* Interrupt Pending 1    */
DECL|macro|PI_INT_MASK0_A
mdefine_line|#define    PI_INT_MASK0_A            0x000000A8    /*&n;                                                    * Interrupt Mask 0&n;                                                    * for CPU A&n;                                                    */
DECL|macro|PI_INT_MASK1_A
mdefine_line|#define    PI_INT_MASK1_A            0x000000B0    /*&n;                                                    * Interrupt Mask 1&n;                                                    * for CPU A&n;                                                    */
DECL|macro|PI_INT_MASK0_B
mdefine_line|#define    PI_INT_MASK0_B            0x000000B8    /*&n;                                                    * Interrupt Mask 0&n;                                                    * for CPU B&n;                                                    */
DECL|macro|PI_INT_MASK1_B
mdefine_line|#define    PI_INT_MASK1_B            0x000000C0    /*&n;                                                    * Interrupt Mask 1&n;                                                    * for CPU B&n;                                                    */
DECL|macro|PI_CC_PEND_SET_A
mdefine_line|#define    PI_CC_PEND_SET_A          0x000000C8    /*&n;                                                    * CC Interrupt&n;                                                    * Pending for CPU A&n;                                                    */
DECL|macro|PI_CC_PEND_SET_B
mdefine_line|#define    PI_CC_PEND_SET_B          0x000000D0    /*&n;                                                    * CC Interrupt&n;                                                    * Pending for CPU B&n;                                                    */
DECL|macro|PI_CC_PEND_CLR_A
mdefine_line|#define    PI_CC_PEND_CLR_A          0x000000D8    /*&n;                                                    * CPU to CPU&n;                                                    * Interrupt Pending&n;                                                    * Clear for CPU A&n;                                                    */
DECL|macro|PI_CC_PEND_CLR_B
mdefine_line|#define    PI_CC_PEND_CLR_B          0x000000E0    /*&n;                                                    * CPU to CPU&n;                                                    * Interrupt Pending&n;                                                    * Clear for CPU B&n;                                                    */
DECL|macro|PI_CC_MASK
mdefine_line|#define    PI_CC_MASK                0x000000E8    /*&n;                                                    * Mask of both&n;                                                    * CC_PENDs&n;                                                    */
DECL|macro|PI_INT_PEND1_REMAP
mdefine_line|#define    PI_INT_PEND1_REMAP        0x000000F0    /*&n;                                                    * Remap Interrupt&n;                                                    * Pending&n;                                                    */
DECL|macro|PI_RT_COUNTER
mdefine_line|#define    PI_RT_COUNTER             0x00030100    /* Real Time Counter      */
DECL|macro|PI_RT_COMPARE_A
mdefine_line|#define    PI_RT_COMPARE_A           0x00000108    /* Real Time Compare A    */
DECL|macro|PI_RT_COMPARE_B
mdefine_line|#define    PI_RT_COMPARE_B           0x00000110    /* Real Time Compare B    */
DECL|macro|PI_PROFILE_COMPARE
mdefine_line|#define    PI_PROFILE_COMPARE        0x00000118    /* Profiling Compare      */
DECL|macro|PI_RT_INT_PEND_A
mdefine_line|#define    PI_RT_INT_PEND_A          0x00000120    /*&n;                                                    * RT interrupt&n;                                                    * pending&n;                                                    */
DECL|macro|PI_RT_INT_PEND_B
mdefine_line|#define    PI_RT_INT_PEND_B          0x00000128    /*&n;                                                    * RT interrupt&n;                                                    * pending&n;                                                    */
DECL|macro|PI_PROF_INT_PEND_A
mdefine_line|#define    PI_PROF_INT_PEND_A        0x00000130    /*&n;                                                    * Profiling interrupt&n;                                                    * pending&n;                                                    */
DECL|macro|PI_PROF_INT_PEND_B
mdefine_line|#define    PI_PROF_INT_PEND_B        0x00000138    /*&n;                                                    * Profiling interrupt&n;                                                    * pending&n;                                                    */
DECL|macro|PI_RT_INT_EN_A
mdefine_line|#define    PI_RT_INT_EN_A            0x00000140    /* RT Interrupt Enable    */
DECL|macro|PI_RT_INT_EN_B
mdefine_line|#define    PI_RT_INT_EN_B            0x00000148    /* RT Interrupt Enable    */
DECL|macro|PI_PROF_INT_EN_A
mdefine_line|#define    PI_PROF_INT_EN_A          0x00000150    /*&n;                                                    * Profiling Interrupt&n;                                                    * Enable&n;                                                    */
DECL|macro|PI_PROF_INT_EN_B
mdefine_line|#define    PI_PROF_INT_EN_B          0x00000158    /*&n;                                                    * Profiling Interrupt&n;                                                    * Enable&n;                                                    */
DECL|macro|PI_DEBUG_SEL
mdefine_line|#define    PI_DEBUG_SEL              0x00000160    /* PI Debug Select        */
DECL|macro|PI_INT_PEND_MOD_ALIAS
mdefine_line|#define    PI_INT_PEND_MOD_ALIAS     0x00000180    /*&n;                                                    * Interrupt Pending&n;                                                    * Modify&n;                                                    */
DECL|macro|PI_PERF_CNTL_A
mdefine_line|#define    PI_PERF_CNTL_A            0x00040200    /*&n;                                                    * Performance Counter&n;                                                    * Control A&n;                                                    */
DECL|macro|PI_PERF_CNTR0_A
mdefine_line|#define    PI_PERF_CNTR0_A           0x00040208    /*&n;                                                    * Performance Counter&n;                                                    * 0 A&n;                                                    */
DECL|macro|PI_PERF_CNTR1_A
mdefine_line|#define    PI_PERF_CNTR1_A           0x00040210    /*&n;                                                    * Performance Counter&n;                                                    * 1 A&n;                                                    */
DECL|macro|PI_PERF_CNTL_B
mdefine_line|#define    PI_PERF_CNTL_B            0x00050200    /*&n;                                                    * Performance Counter&n;                                                    * Control B&n;                                                    */
DECL|macro|PI_PERF_CNTR0_B
mdefine_line|#define    PI_PERF_CNTR0_B           0x00050208    /*&n;                                                    * Performance Counter&n;                                                    * 0 B&n;                                                    */
DECL|macro|PI_PERF_CNTR1_B
mdefine_line|#define    PI_PERF_CNTR1_B           0x00050210    /*&n;                                                    * Performance Counter&n;                                                    * 1 B&n;                                                    */
DECL|macro|PI_GFX_PAGE_A
mdefine_line|#define    PI_GFX_PAGE_A             0x00000300    /* Graphics Page          */
DECL|macro|PI_GFX_CREDIT_CNTR_A
mdefine_line|#define    PI_GFX_CREDIT_CNTR_A      0x00000308    /*&n;                                                    * Graphics Credit&n;                                                    * Counter&n;                                                    */
DECL|macro|PI_GFX_BIAS_A
mdefine_line|#define    PI_GFX_BIAS_A             0x00000310    /* TRex+ BIAS             */
DECL|macro|PI_GFX_INT_CNTR_A
mdefine_line|#define    PI_GFX_INT_CNTR_A         0x00000318    /*&n;                                                    * Graphics Interrupt&n;                                                    * Counter&n;                                                    */
DECL|macro|PI_GFX_INT_CMP_A
mdefine_line|#define    PI_GFX_INT_CMP_A          0x00000320    /*&n;                                                    * Graphics Interrupt&n;                                                    * Compare&n;                                                    */
DECL|macro|PI_GFX_PAGE_B
mdefine_line|#define    PI_GFX_PAGE_B             0x00000328    /* Graphics Page          */
DECL|macro|PI_GFX_CREDIT_CNTR_B
mdefine_line|#define    PI_GFX_CREDIT_CNTR_B      0x00000330    /*&n;                                                    * Graphics Credit&n;                                                    * Counter&n;                                                    */
DECL|macro|PI_GFX_BIAS_B
mdefine_line|#define    PI_GFX_BIAS_B             0x00000338    /* TRex+ BIAS             */
DECL|macro|PI_GFX_INT_CNTR_B
mdefine_line|#define    PI_GFX_INT_CNTR_B         0x00000340    /*&n;                                                    * Graphics Interrupt&n;                                                    * Counter&n;                                                    */
DECL|macro|PI_GFX_INT_CMP_B
mdefine_line|#define    PI_GFX_INT_CMP_B          0x00000348    /*&n;                                                    * Graphics Interrupt&n;                                                    * Compare&n;                                                    */
DECL|macro|PI_ERR_INT_PEND_WR
mdefine_line|#define    PI_ERR_INT_PEND_WR        0x000003F8    /*&n;                                                    * Error Interrupt&n;                                                    * Pending (Writable)&n;                                                    */
DECL|macro|PI_ERR_INT_PEND
mdefine_line|#define    PI_ERR_INT_PEND           0x00000400    /*&n;                                                    * Error Interrupt&n;                                                    * Pending&n;                                                    */
DECL|macro|PI_ERR_INT_MASK_A
mdefine_line|#define    PI_ERR_INT_MASK_A         0x00000408    /*&n;                                                    * Error Interrupt&n;                                                    * Mask CPU_A&n;                                                    */
DECL|macro|PI_ERR_INT_MASK_B
mdefine_line|#define    PI_ERR_INT_MASK_B         0x00000410    /*&n;                                                    * Error Interrupt&n;                                                    * Mask CPU_B&n;                                                    */
DECL|macro|PI_ERR_STACK_ADDR_A
mdefine_line|#define    PI_ERR_STACK_ADDR_A       0x00000418    /*&n;                                                    * Error Stack Address&n;                                                    * Pointer&n;                                                    */
DECL|macro|PI_ERR_STACK_ADDR_B
mdefine_line|#define    PI_ERR_STACK_ADDR_B       0x00000420    /*&n;                                                    * Error Stack Address&n;                                                    * Pointer&n;                                                    */
DECL|macro|PI_ERR_STACK_SIZE
mdefine_line|#define    PI_ERR_STACK_SIZE         0x00000428    /* Error Stack Size       */
DECL|macro|PI_ERR_STATUS0_A
mdefine_line|#define    PI_ERR_STATUS0_A          0x00000430    /* Error Status 0         */
DECL|macro|PI_ERR_STATUS0_A_CLR
mdefine_line|#define    PI_ERR_STATUS0_A_CLR      0x00000438    /* Error Status 0         */
DECL|macro|PI_ERR_STATUS1_A
mdefine_line|#define    PI_ERR_STATUS1_A          0x00000440    /* Error Status 1         */
DECL|macro|PI_ERR_STATUS1_A_CLR
mdefine_line|#define    PI_ERR_STATUS1_A_CLR      0x00000448    /* Error Status 1         */
DECL|macro|PI_ERR_STATUS0_B
mdefine_line|#define    PI_ERR_STATUS0_B          0x00000450    /* Error Status 0         */
DECL|macro|PI_ERR_STATUS0_B_CLR
mdefine_line|#define    PI_ERR_STATUS0_B_CLR      0x00000458    /* Error Status 0         */
DECL|macro|PI_ERR_STATUS1_B
mdefine_line|#define    PI_ERR_STATUS1_B          0x00000460    /* Error Status 1         */
DECL|macro|PI_ERR_STATUS1_B_CLR
mdefine_line|#define    PI_ERR_STATUS1_B_CLR      0x00000468    /* Error Status 1         */
DECL|macro|PI_SPOOL_CMP_A
mdefine_line|#define    PI_SPOOL_CMP_A            0x00000470    /* Spool Compare          */
DECL|macro|PI_SPOOL_CMP_B
mdefine_line|#define    PI_SPOOL_CMP_B            0x00000478    /* Spool Compare          */
DECL|macro|PI_CRB_TIMEOUT_A
mdefine_line|#define    PI_CRB_TIMEOUT_A          0x00000480    /*&n;                                                    * CRB entries which&n;                                                    * have timed out but&n;                                                    * are still valid&n;                                                    */
DECL|macro|PI_CRB_TIMEOUT_B
mdefine_line|#define    PI_CRB_TIMEOUT_B          0x00000488    /*&n;                                                    * CRB entries which&n;                                                    * have timed out but&n;                                                    * are still valid&n;                                                    */
DECL|macro|PI_SYSAD_ERRCHK_EN
mdefine_line|#define    PI_SYSAD_ERRCHK_EN        0x00000490    /*&n;                                                    * enables&n;                                                    * sysad/cmd/state&n;                                                    * error checking&n;                                                    */
DECL|macro|PI_FORCE_BAD_CHECK_BIT_A
mdefine_line|#define    PI_FORCE_BAD_CHECK_BIT_A  0x00000498    /*&n;                                                    * force SysAD Check&n;                                                    * Bit error&n;                                                    */
DECL|macro|PI_FORCE_BAD_CHECK_BIT_B
mdefine_line|#define    PI_FORCE_BAD_CHECK_BIT_B  0x000004A0    /*&n;                                                    * force SysAD Check&n;                                                    * Bit error&n;                                                    */
DECL|macro|PI_NACK_CNT_A
mdefine_line|#define    PI_NACK_CNT_A             0x000004A8    /*&n;                                                    * consecutive NACK&n;                                                    * counter&n;                                                    */
DECL|macro|PI_NACK_CNT_B
mdefine_line|#define    PI_NACK_CNT_B             0x000004B0    /*&n;                                                    * consecutive NACK&n;                                                    * counter&n;                                                    */
DECL|macro|PI_NACK_CMP
mdefine_line|#define    PI_NACK_CMP               0x000004B8    /* NACK count compare     */
DECL|macro|PI_SPOOL_MASK
mdefine_line|#define    PI_SPOOL_MASK             0x000004C0    /* Spool error mask       */
DECL|macro|PI_SPURIOUS_HDR_0
mdefine_line|#define    PI_SPURIOUS_HDR_0         0x000004C8    /* Spurious Error 0       */
DECL|macro|PI_SPURIOUS_HDR_1
mdefine_line|#define    PI_SPURIOUS_HDR_1         0x000004D0    /* Spurious Error 1       */
DECL|macro|PI_ERR_INJECT
mdefine_line|#define    PI_ERR_INJECT             0x000004D8    /*&n;                                                    * SysAD bus error&n;                                                    * injection&n;                                                    */
macro_line|#ifndef __ASSEMBLY__
multiline_comment|/************************************************************************&n; *                                                                      *&n; * Description:  This read/write register determines on a               *&n; * bit-per-region basis whether incoming CPU-initiated PIO Read and     *&n; * Write to local PI registers are allowed. If access is allowed, the   *&n; * PI&squot;s response to a partial read is a PRPLY message, and the          *&n; * response to a partial write is a PACK message. If access is not      *&n; * allowed, the PI&squot;s response to a partial read is a PRERR message,     *&n; * and the response to a partial write is a PWERR message.              *&n; * This register is not reset by a soft reset.                          *&n; *                                                                      *&n; ************************************************************************/
DECL|union|pi_cpu_protect_u
r_typedef
r_union
id|pi_cpu_protect_u
(brace
DECL|member|pi_cpu_protect_regval
id|bdrkreg_t
id|pi_cpu_protect_regval
suffix:semicolon
r_struct
(brace
DECL|member|cp_cpu_protect
id|bdrkreg_t
id|cp_cpu_protect
suffix:colon
l_int|64
suffix:semicolon
DECL|member|pi_cpu_protect_fld_s
)brace
id|pi_cpu_protect_fld_s
suffix:semicolon
DECL|typedef|pi_cpu_protect_u_t
)brace
id|pi_cpu_protect_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  A write with a special data pattern allows any CPU to set its       *&n; * region&squot;s bit in CPU_PROTECT. This register has data pattern          *&n; * protection.                                                          *&n; *                                                                      *&n; ************************************************************************/
DECL|union|pi_prot_ovrrd_u
r_typedef
r_union
id|pi_prot_ovrrd_u
(brace
DECL|member|pi_prot_ovrrd_regval
id|bdrkreg_t
id|pi_prot_ovrrd_regval
suffix:semicolon
r_struct
(brace
DECL|member|po_prot_ovrrd
id|bdrkreg_t
id|po_prot_ovrrd
suffix:colon
l_int|64
suffix:semicolon
DECL|member|pi_prot_ovrrd_fld_s
)brace
id|pi_prot_ovrrd_fld_s
suffix:semicolon
DECL|typedef|pi_prot_ovrrd_u_t
)brace
id|pi_prot_ovrrd_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; * Description:  This read/write register determines on a               *&n; * bit-per-region basis whether incoming IO-initiated interrupts are    *&n; * allowed to set bits in INT_PEND0 and INT_PEND1. If access is         *&n; * allowed, the PI&squot;s response to a partial read is a PRPLY message,     *&n; * and the response to a partial write is a PACK message. If access     *&n; * is not allowed, the PI&squot;s response to a partial read is a PRERR       *&n; * message, and the response to a partial write is a PWERR message.     *&n; * This register is not reset by a soft reset.                          *&n; *                                                                      *&n; ************************************************************************/
DECL|union|pi_io_protect_u
r_typedef
r_union
id|pi_io_protect_u
(brace
DECL|member|pi_io_protect_regval
id|bdrkreg_t
id|pi_io_protect_regval
suffix:semicolon
r_struct
(brace
DECL|member|ip_io_protect
id|bdrkreg_t
id|ip_io_protect
suffix:colon
l_int|64
suffix:semicolon
DECL|member|pi_io_protect_fld_s
)brace
id|pi_io_protect_fld_s
suffix:semicolon
DECL|typedef|pi_io_protect_u_t
)brace
id|pi_io_protect_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; * Description:  This read/write register determines on a               *&n; * bit-per-region basis whether read access from a local processor to   *&n; * the region is permissible. For example, setting a bit to 0           *&n; * prevents speculative reads to that non-existent node. If a read      *&n; * request to a non-present region occurs, an ERR response is issued    *&n; * to the TRex+ (no PI error registers are modified). It is up to       *&n; * software to load this register with the proper contents.             *&n; * Region-present checking is only done for coherent read requests -    *&n; * partial reads/writes will be issued to a non-present region. The     *&n; * setting of these bits does not affect a node&squot;s access to its         *&n; * CALIAS space.                                                        *&n; * This register is not reset by a soft reset.                          *&n; *                                                                      *&n; ************************************************************************/
DECL|union|pi_region_present_u
r_typedef
r_union
id|pi_region_present_u
(brace
DECL|member|pi_region_present_regval
id|bdrkreg_t
id|pi_region_present_regval
suffix:semicolon
r_struct
(brace
DECL|member|rp_region_present
id|bdrkreg_t
id|rp_region_present
suffix:colon
l_int|64
suffix:semicolon
DECL|member|pi_region_present_fld_s
)brace
id|pi_region_present_fld_s
suffix:semicolon
DECL|typedef|pi_region_present_u_t
)brace
id|pi_region_present_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  A read to the location will allow a CPU to identify itself as       *&n; * either CPU_A or CPU_B, and will indicate whether the CPU is          *&n; * connected to PI 0 or PI 1.                                           *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_cpu_num_u
r_typedef
r_union
id|pi_cpu_num_u
(brace
DECL|member|pi_cpu_num_regval
id|bdrkreg_t
id|pi_cpu_num_regval
suffix:semicolon
r_struct
(brace
DECL|member|cn_cpu_num
id|bdrkreg_t
id|cn_cpu_num
suffix:colon
l_int|1
suffix:semicolon
DECL|member|cn_pi_id
id|bdrkreg_t
id|cn_pi_id
suffix:colon
l_int|1
suffix:semicolon
DECL|member|cn_rsvd
id|bdrkreg_t
id|cn_rsvd
suffix:colon
l_int|62
suffix:semicolon
DECL|member|pi_cpu_num_fld_s
)brace
id|pi_cpu_num_fld_s
suffix:semicolon
DECL|typedef|pi_cpu_num_u_t
)brace
id|pi_cpu_num_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_cpu_num_u
r_typedef
r_union
id|pi_cpu_num_u
(brace
DECL|member|pi_cpu_num_regval
id|bdrkreg_t
id|pi_cpu_num_regval
suffix:semicolon
r_struct
(brace
DECL|member|cn_rsvd
id|bdrkreg_t
id|cn_rsvd
suffix:colon
l_int|62
suffix:semicolon
DECL|member|cn_pi_id
id|bdrkreg_t
id|cn_pi_id
suffix:colon
l_int|1
suffix:semicolon
DECL|member|cn_cpu_num
id|bdrkreg_t
id|cn_cpu_num
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_cpu_num_fld_s
)brace
id|pi_cpu_num_fld_s
suffix:semicolon
DECL|typedef|pi_cpu_num_u_t
)brace
id|pi_cpu_num_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; * Description:  This read/write location determines the size of the    *&n; * Calias Space.                                                        *&n; * This register is not reset by a soft reset.                          *&n; * NOTE: For predictable behavior, all Calias spaces in a system must   *&n; * be set to the same size.                                             *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_calias_size_u
r_typedef
r_union
id|pi_calias_size_u
(brace
DECL|member|pi_calias_size_regval
id|bdrkreg_t
id|pi_calias_size_regval
suffix:semicolon
r_struct
(brace
DECL|member|cs_calias_size
id|bdrkreg_t
id|cs_calias_size
suffix:colon
l_int|4
suffix:semicolon
DECL|member|cs_rsvd
id|bdrkreg_t
id|cs_rsvd
suffix:colon
l_int|60
suffix:semicolon
DECL|member|pi_calias_size_fld_s
)brace
id|pi_calias_size_fld_s
suffix:semicolon
DECL|typedef|pi_calias_size_u_t
)brace
id|pi_calias_size_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_calias_size_u
r_typedef
r_union
id|pi_calias_size_u
(brace
DECL|member|pi_calias_size_regval
id|bdrkreg_t
id|pi_calias_size_regval
suffix:semicolon
r_struct
(brace
DECL|member|cs_rsvd
id|bdrkreg_t
id|cs_rsvd
suffix:colon
l_int|60
suffix:semicolon
DECL|member|cs_calias_size
id|bdrkreg_t
id|cs_calias_size
suffix:colon
l_int|4
suffix:semicolon
DECL|member|pi_calias_size_fld_s
)brace
id|pi_calias_size_fld_s
suffix:semicolon
DECL|typedef|pi_calias_size_u_t
)brace
id|pi_calias_size_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This Read/Write location determines at which value (increment)      *&n; * the CRB Timeout Counters cause a timeout error to occur. See         *&n; * Section 3.4.2.2, &amp;quot;Time-outs in RRB and WRB&amp;quot; in the         *&n; * Processor Interface chapter, volume 1 of this document for more      *&n; * details.                                                             *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_max_crb_timeout_u
r_typedef
r_union
id|pi_max_crb_timeout_u
(brace
DECL|member|pi_max_crb_timeout_regval
id|bdrkreg_t
id|pi_max_crb_timeout_regval
suffix:semicolon
r_struct
(brace
DECL|member|mct_max_timeout
id|bdrkreg_t
id|mct_max_timeout
suffix:colon
l_int|8
suffix:semicolon
DECL|member|mct_rsvd
id|bdrkreg_t
id|mct_rsvd
suffix:colon
l_int|56
suffix:semicolon
DECL|member|pi_max_crb_timeout_fld_s
)brace
id|pi_max_crb_timeout_fld_s
suffix:semicolon
DECL|typedef|pi_max_crb_timeout_u_t
)brace
id|pi_max_crb_timeout_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_max_crb_timeout_u
r_typedef
r_union
id|pi_max_crb_timeout_u
(brace
DECL|member|pi_max_crb_timeout_regval
id|bdrkreg_t
id|pi_max_crb_timeout_regval
suffix:semicolon
r_struct
(brace
DECL|member|mct_rsvd
id|bdrkreg_t
id|mct_rsvd
suffix:colon
l_int|56
suffix:semicolon
DECL|member|mct_max_timeout
id|bdrkreg_t
id|mct_max_timeout
suffix:colon
l_int|8
suffix:semicolon
DECL|member|pi_max_crb_timeout_fld_s
)brace
id|pi_max_crb_timeout_fld_s
suffix:semicolon
DECL|typedef|pi_max_crb_timeout_u_t
)brace
id|pi_max_crb_timeout_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This Read/Write location determines how often a valid CRB&squot;s         *&n; * Timeout Counter is incremented. See Section 3.4.2.2,                 *&n; * &amp;quot;Time-outs in RRB and WRB&amp;quot; in the Processor Interface      *&n; * chapter, volume 1 of this document for more details.                 *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_crb_sfactor_u
r_typedef
r_union
id|pi_crb_sfactor_u
(brace
DECL|member|pi_crb_sfactor_regval
id|bdrkreg_t
id|pi_crb_sfactor_regval
suffix:semicolon
r_struct
(brace
DECL|member|cs_sfactor
id|bdrkreg_t
id|cs_sfactor
suffix:colon
l_int|24
suffix:semicolon
DECL|member|cs_rsvd
id|bdrkreg_t
id|cs_rsvd
suffix:colon
l_int|40
suffix:semicolon
DECL|member|pi_crb_sfactor_fld_s
)brace
id|pi_crb_sfactor_fld_s
suffix:semicolon
DECL|typedef|pi_crb_sfactor_u_t
)brace
id|pi_crb_sfactor_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_crb_sfactor_u
r_typedef
r_union
id|pi_crb_sfactor_u
(brace
DECL|member|pi_crb_sfactor_regval
id|bdrkreg_t
id|pi_crb_sfactor_regval
suffix:semicolon
r_struct
(brace
DECL|member|cs_rsvd
id|bdrkreg_t
id|cs_rsvd
suffix:colon
l_int|40
suffix:semicolon
DECL|member|cs_sfactor
id|bdrkreg_t
id|cs_sfactor
suffix:colon
l_int|24
suffix:semicolon
DECL|member|pi_crb_sfactor_fld_s
)brace
id|pi_crb_sfactor_fld_s
suffix:semicolon
DECL|typedef|pi_crb_sfactor_u_t
)brace
id|pi_crb_sfactor_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. The PI sets this      *&n; * bit when it sees the first transaction initiated by the associated   *&n; * CPU.                                                                 *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_cpu_present_a_u
r_typedef
r_union
id|pi_cpu_present_a_u
(brace
DECL|member|pi_cpu_present_a_regval
id|bdrkreg_t
id|pi_cpu_present_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|cpa_cpu_present
id|bdrkreg_t
id|cpa_cpu_present
suffix:colon
l_int|1
suffix:semicolon
DECL|member|cpa_rsvd
id|bdrkreg_t
id|cpa_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|pi_cpu_present_a_fld_s
)brace
id|pi_cpu_present_a_fld_s
suffix:semicolon
DECL|typedef|pi_cpu_present_a_u_t
)brace
id|pi_cpu_present_a_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_cpu_present_a_u
r_typedef
r_union
id|pi_cpu_present_a_u
(brace
DECL|member|pi_cpu_present_a_regval
id|bdrkreg_t
id|pi_cpu_present_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|cpa_rsvd
id|bdrkreg_t
id|cpa_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|cpa_cpu_present
id|bdrkreg_t
id|cpa_cpu_present
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_cpu_present_a_fld_s
)brace
id|pi_cpu_present_a_fld_s
suffix:semicolon
DECL|typedef|pi_cpu_present_a_u_t
)brace
id|pi_cpu_present_a_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. The PI sets this      *&n; * bit when it sees the first transaction initiated by the associated   *&n; * CPU.                                                                 *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_cpu_present_b_u
r_typedef
r_union
id|pi_cpu_present_b_u
(brace
DECL|member|pi_cpu_present_b_regval
id|bdrkreg_t
id|pi_cpu_present_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|cpb_cpu_present
id|bdrkreg_t
id|cpb_cpu_present
suffix:colon
l_int|1
suffix:semicolon
DECL|member|cpb_rsvd
id|bdrkreg_t
id|cpb_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|pi_cpu_present_b_fld_s
)brace
id|pi_cpu_present_b_fld_s
suffix:semicolon
DECL|typedef|pi_cpu_present_b_u_t
)brace
id|pi_cpu_present_b_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_cpu_present_b_u
r_typedef
r_union
id|pi_cpu_present_b_u
(brace
DECL|member|pi_cpu_present_b_regval
id|bdrkreg_t
id|pi_cpu_present_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|cpb_rsvd
id|bdrkreg_t
id|cpb_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|cpb_cpu_present
id|bdrkreg_t
id|cpb_cpu_present
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_cpu_present_b_fld_s
)brace
id|pi_cpu_present_b_fld_s
suffix:semicolon
DECL|typedef|pi_cpu_present_b_u_t
)brace
id|pi_cpu_present_b_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; * Description:  There is one of these registers for each CPU. This     *&n; * Read/Write location determines whether the associated CPU is         *&n; * enabled to issue external requests. When this bit is zero for a      *&n; * processor, the PI ignores SysReq_L from that processor, and so       *&n; * never grants it the bus.                                             *&n; * This register is not reset by a soft reset.                          *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_cpu_enable_a_u
r_typedef
r_union
id|pi_cpu_enable_a_u
(brace
DECL|member|pi_cpu_enable_a_regval
id|bdrkreg_t
id|pi_cpu_enable_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|cea_cpu_enable
id|bdrkreg_t
id|cea_cpu_enable
suffix:colon
l_int|1
suffix:semicolon
DECL|member|cea_rsvd
id|bdrkreg_t
id|cea_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|pi_cpu_enable_a_fld_s
)brace
id|pi_cpu_enable_a_fld_s
suffix:semicolon
DECL|typedef|pi_cpu_enable_a_u_t
)brace
id|pi_cpu_enable_a_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_cpu_enable_a_u
r_typedef
r_union
id|pi_cpu_enable_a_u
(brace
DECL|member|pi_cpu_enable_a_regval
id|bdrkreg_t
id|pi_cpu_enable_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|cea_rsvd
id|bdrkreg_t
id|cea_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|cea_cpu_enable
id|bdrkreg_t
id|cea_cpu_enable
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_cpu_enable_a_fld_s
)brace
id|pi_cpu_enable_a_fld_s
suffix:semicolon
DECL|typedef|pi_cpu_enable_a_u_t
)brace
id|pi_cpu_enable_a_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; * Description:  There is one of these registers for each CPU. This     *&n; * Read/Write location determines whether the associated CPU is         *&n; * enabled to issue external requests. When this bit is zero for a      *&n; * processor, the PI ignores SysReq_L from that processor, and so       *&n; * never grants it the bus.                                             *&n; * This register is not reset by a soft reset.                          *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_cpu_enable_b_u
r_typedef
r_union
id|pi_cpu_enable_b_u
(brace
DECL|member|pi_cpu_enable_b_regval
id|bdrkreg_t
id|pi_cpu_enable_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|ceb_cpu_enable
id|bdrkreg_t
id|ceb_cpu_enable
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ceb_rsvd
id|bdrkreg_t
id|ceb_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|pi_cpu_enable_b_fld_s
)brace
id|pi_cpu_enable_b_fld_s
suffix:semicolon
DECL|typedef|pi_cpu_enable_b_u_t
)brace
id|pi_cpu_enable_b_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_cpu_enable_b_u
r_typedef
r_union
id|pi_cpu_enable_b_u
(brace
DECL|member|pi_cpu_enable_b_regval
id|bdrkreg_t
id|pi_cpu_enable_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|ceb_rsvd
id|bdrkreg_t
id|ceb_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|ceb_cpu_enable
id|bdrkreg_t
id|ceb_cpu_enable
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_cpu_enable_b_fld_s
)brace
id|pi_cpu_enable_b_fld_s
suffix:semicolon
DECL|typedef|pi_cpu_enable_b_u_t
)brace
id|pi_cpu_enable_b_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. A write to this       *&n; * location will cause an NMI to be issued to the CPU.                  *&n; *                                                                      *&n; ************************************************************************/
DECL|union|pi_nmi_a_u
r_typedef
r_union
id|pi_nmi_a_u
(brace
DECL|member|pi_nmi_a_regval
id|bdrkreg_t
id|pi_nmi_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|na_nmi_cpu
id|bdrkreg_t
id|na_nmi_cpu
suffix:colon
l_int|64
suffix:semicolon
DECL|member|pi_nmi_a_fld_s
)brace
id|pi_nmi_a_fld_s
suffix:semicolon
DECL|typedef|pi_nmi_a_u_t
)brace
id|pi_nmi_a_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. A write to this       *&n; * location will cause an NMI to be issued to the CPU.                  *&n; *                                                                      *&n; ************************************************************************/
DECL|union|pi_nmi_b_u
r_typedef
r_union
id|pi_nmi_b_u
(brace
DECL|member|pi_nmi_b_regval
id|bdrkreg_t
id|pi_nmi_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|nb_nmi_cpu
id|bdrkreg_t
id|nb_nmi_cpu
suffix:colon
l_int|64
suffix:semicolon
DECL|member|pi_nmi_b_fld_s
)brace
id|pi_nmi_b_fld_s
suffix:semicolon
DECL|typedef|pi_nmi_b_u_t
)brace
id|pi_nmi_b_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  A write to this register allows a single bit in the INT_PEND0 or    *&n; * INT_PEND1 registers to be set or cleared. If 6 is clear, a bit is    *&n; * modified in INT_PEND0, while if 6 is set, a bit is modified in       *&n; * INT_PEND1. The value in 5:0 (ranging from 63 to 0) will determine    *&n; * which bit in the register is effected. The value of 8 will           *&n; * determine whether the desired bit is set (8=1) or cleared (8=0).     *&n; * This is the only register which is accessible by IO issued PWRI      *&n; * command and is protected through the IO_PROTECT register. If the     *&n; * region bit in the IO_PROTECT is not set then a WERR reply is         *&n; * issued. CPU access is controlled through CPU_PROTECT. The contents   *&n; * of this register are masked with the contents of INT_MASK_A          *&n; * (INT_MASK_B) to determine whether an L2 interrupt is issued to       *&n; * CPU_A (CPU_B).                                                       *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_int_pend_mod_u
r_typedef
r_union
id|pi_int_pend_mod_u
(brace
DECL|member|pi_int_pend_mod_regval
id|bdrkreg_t
id|pi_int_pend_mod_regval
suffix:semicolon
r_struct
(brace
DECL|member|ipm_bit_select
id|bdrkreg_t
id|ipm_bit_select
suffix:colon
l_int|6
suffix:semicolon
DECL|member|ipm_reg_select
id|bdrkreg_t
id|ipm_reg_select
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ipm_rsvd_1
id|bdrkreg_t
id|ipm_rsvd_1
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ipm_value
id|bdrkreg_t
id|ipm_value
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ipm_rsvd
id|bdrkreg_t
id|ipm_rsvd
suffix:colon
l_int|55
suffix:semicolon
DECL|member|pi_int_pend_mod_fld_s
)brace
id|pi_int_pend_mod_fld_s
suffix:semicolon
DECL|typedef|pi_int_pend_mod_u_t
)brace
id|pi_int_pend_mod_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_int_pend_mod_u
r_typedef
r_union
id|pi_int_pend_mod_u
(brace
DECL|member|pi_int_pend_mod_regval
id|bdrkreg_t
id|pi_int_pend_mod_regval
suffix:semicolon
r_struct
(brace
DECL|member|ipm_rsvd
id|bdrkreg_t
id|ipm_rsvd
suffix:colon
l_int|55
suffix:semicolon
DECL|member|ipm_value
id|bdrkreg_t
id|ipm_value
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ipm_rsvd_1
id|bdrkreg_t
id|ipm_rsvd_1
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ipm_reg_select
id|bdrkreg_t
id|ipm_reg_select
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ipm_bit_select
id|bdrkreg_t
id|ipm_bit_select
suffix:colon
l_int|6
suffix:semicolon
DECL|member|pi_int_pend_mod_fld_s
)brace
id|pi_int_pend_mod_fld_s
suffix:semicolon
DECL|typedef|pi_int_pend_mod_u_t
)brace
id|pi_int_pend_mod_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This read-only register provides information about interrupts       *&n; * that are currently pending. The interrupts in this register map to   *&n; * interrupt level 2 (L2). The GFX_INT_A/B bits are set by hardware     *&n; * but must be cleared by software.                                     *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_int_pend0_u
r_typedef
r_union
id|pi_int_pend0_u
(brace
DECL|member|pi_int_pend0_regval
id|bdrkreg_t
id|pi_int_pend0_regval
suffix:semicolon
r_struct
(brace
DECL|member|ip_int_pend0_lo
id|bdrkreg_t
id|ip_int_pend0_lo
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_gfx_int_a
id|bdrkreg_t
id|ip_gfx_int_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_gfx_int_b
id|bdrkreg_t
id|ip_gfx_int_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_page_migration
id|bdrkreg_t
id|ip_page_migration
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_uart_ucntrl
id|bdrkreg_t
id|ip_uart_ucntrl
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_or_cc_pend_a
id|bdrkreg_t
id|ip_or_cc_pend_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_or_cc_pend_b
id|bdrkreg_t
id|ip_or_cc_pend_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_int_pend0_hi
id|bdrkreg_t
id|ip_int_pend0_hi
suffix:colon
l_int|57
suffix:semicolon
DECL|member|pi_int_pend0_fld_s
)brace
id|pi_int_pend0_fld_s
suffix:semicolon
DECL|typedef|pi_int_pend0_u_t
)brace
id|pi_int_pend0_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_int_pend0_u
r_typedef
r_union
id|pi_int_pend0_u
(brace
DECL|member|pi_int_pend0_regval
id|bdrkreg_t
id|pi_int_pend0_regval
suffix:semicolon
r_struct
(brace
DECL|member|ip_int_pend0_hi
id|bdrkreg_t
id|ip_int_pend0_hi
suffix:colon
l_int|57
suffix:semicolon
DECL|member|ip_or_cc_pend_b
id|bdrkreg_t
id|ip_or_cc_pend_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_or_cc_pend_a
id|bdrkreg_t
id|ip_or_cc_pend_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_uart_ucntrl
id|bdrkreg_t
id|ip_uart_ucntrl
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_page_migration
id|bdrkreg_t
id|ip_page_migration
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_gfx_int_b
id|bdrkreg_t
id|ip_gfx_int_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_gfx_int_a
id|bdrkreg_t
id|ip_gfx_int_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_int_pend0_lo
id|bdrkreg_t
id|ip_int_pend0_lo
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_int_pend0_fld_s
)brace
id|pi_int_pend0_fld_s
suffix:semicolon
DECL|typedef|pi_int_pend0_u_t
)brace
id|pi_int_pend0_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This read-only register provides information about interrupts       *&n; * that are currently pending. The interrupts in this register map to   *&n; * interrupt level 3 (L3), unless remapped by the INT_PEND1_REMAP       *&n; * register. The SYS_COR_ERR_A/B, RTC_DROP_OUT, and NACK_INT_A/B bits   *&n; * are set by hardware but must be cleared by software. The             *&n; * SYSTEM_SHUTDOWN, NI_ERROR, LB_ERROR and XB_ERROR bits just reflect   *&n; * the value of other logic, and cannot be changed by PI register       *&n; * writes.                                                              *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_int_pend1_u
r_typedef
r_union
id|pi_int_pend1_u
(brace
DECL|member|pi_int_pend1_regval
id|bdrkreg_t
id|pi_int_pend1_regval
suffix:semicolon
r_struct
(brace
DECL|member|ip_int_pend1
id|bdrkreg_t
id|ip_int_pend1
suffix:colon
l_int|54
suffix:semicolon
DECL|member|ip_xb_error
id|bdrkreg_t
id|ip_xb_error
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_lb_error
id|bdrkreg_t
id|ip_lb_error
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_nack_int_a
id|bdrkreg_t
id|ip_nack_int_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_nack_int_b
id|bdrkreg_t
id|ip_nack_int_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_perf_cntr_oflow
id|bdrkreg_t
id|ip_perf_cntr_oflow
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_sys_cor_err_b
id|bdrkreg_t
id|ip_sys_cor_err_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_sys_cor_err_a
id|bdrkreg_t
id|ip_sys_cor_err_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_md_corr_error
id|bdrkreg_t
id|ip_md_corr_error
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_ni_error
id|bdrkreg_t
id|ip_ni_error
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_system_shutdown
id|bdrkreg_t
id|ip_system_shutdown
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_int_pend1_fld_s
)brace
id|pi_int_pend1_fld_s
suffix:semicolon
DECL|typedef|pi_int_pend1_u_t
)brace
id|pi_int_pend1_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_int_pend1_u
r_typedef
r_union
id|pi_int_pend1_u
(brace
DECL|member|pi_int_pend1_regval
id|bdrkreg_t
id|pi_int_pend1_regval
suffix:semicolon
r_struct
(brace
DECL|member|ip_system_shutdown
id|bdrkreg_t
id|ip_system_shutdown
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_ni_error
id|bdrkreg_t
id|ip_ni_error
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_md_corr_error
id|bdrkreg_t
id|ip_md_corr_error
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_sys_cor_err_a
id|bdrkreg_t
id|ip_sys_cor_err_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_sys_cor_err_b
id|bdrkreg_t
id|ip_sys_cor_err_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_perf_cntr_oflow
id|bdrkreg_t
id|ip_perf_cntr_oflow
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_nack_int_b
id|bdrkreg_t
id|ip_nack_int_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_nack_int_a
id|bdrkreg_t
id|ip_nack_int_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_lb_error
id|bdrkreg_t
id|ip_lb_error
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_xb_error
id|bdrkreg_t
id|ip_xb_error
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ip_int_pend1
id|bdrkreg_t
id|ip_int_pend1
suffix:colon
l_int|54
suffix:semicolon
DECL|member|pi_int_pend1_fld_s
)brace
id|pi_int_pend1_fld_s
suffix:semicolon
DECL|typedef|pi_int_pend1_u_t
)brace
id|pi_int_pend1_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This read/write register masks the contents of INT_PEND0 to         *&n; * determine whether an L2 interrupt (bit 10 of the processor&squot;s Cause   *&n; * register) is sent to CPU_A if the same bit in the INT_PEND0          *&n; * register is also set. Only one processor in a Bedrock should         *&n; * enable the PAGE_MIGRATION bit/interrupt.                             *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_int_mask0_a_u
r_typedef
r_union
id|pi_int_mask0_a_u
(brace
DECL|member|pi_int_mask0_a_regval
id|bdrkreg_t
id|pi_int_mask0_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|ima_int_mask0_lo
id|bdrkreg_t
id|ima_int_mask0_lo
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ima_gfx_int_a
id|bdrkreg_t
id|ima_gfx_int_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ima_gfx_int_b
id|bdrkreg_t
id|ima_gfx_int_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ima_page_migration
id|bdrkreg_t
id|ima_page_migration
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ima_uart_ucntrl
id|bdrkreg_t
id|ima_uart_ucntrl
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ima_or_ccp_mask_a
id|bdrkreg_t
id|ima_or_ccp_mask_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ima_or_ccp_mask_b
id|bdrkreg_t
id|ima_or_ccp_mask_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ima_int_mask0_hi
id|bdrkreg_t
id|ima_int_mask0_hi
suffix:colon
l_int|57
suffix:semicolon
DECL|member|pi_int_mask0_a_fld_s
)brace
id|pi_int_mask0_a_fld_s
suffix:semicolon
DECL|typedef|pi_int_mask0_a_u_t
)brace
id|pi_int_mask0_a_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_int_mask0_a_u
r_typedef
r_union
id|pi_int_mask0_a_u
(brace
DECL|member|pi_int_mask0_a_regval
id|bdrkreg_t
id|pi_int_mask0_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|ima_int_mask0_hi
id|bdrkreg_t
id|ima_int_mask0_hi
suffix:colon
l_int|57
suffix:semicolon
DECL|member|ima_or_ccp_mask_b
id|bdrkreg_t
id|ima_or_ccp_mask_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ima_or_ccp_mask_a
id|bdrkreg_t
id|ima_or_ccp_mask_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ima_uart_ucntrl
id|bdrkreg_t
id|ima_uart_ucntrl
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ima_page_migration
id|bdrkreg_t
id|ima_page_migration
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ima_gfx_int_b
id|bdrkreg_t
id|ima_gfx_int_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ima_gfx_int_a
id|bdrkreg_t
id|ima_gfx_int_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ima_int_mask0_lo
id|bdrkreg_t
id|ima_int_mask0_lo
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_int_mask0_a_fld_s
)brace
id|pi_int_mask0_a_fld_s
suffix:semicolon
DECL|typedef|pi_int_mask0_a_u_t
)brace
id|pi_int_mask0_a_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This read/write register masks the contents of INT_PEND1 to         *&n; * determine whether an interrupt should be sent. Bits 63:32 always     *&n; * generate an L3 interrupt (bit 11 of the processor&squot;s Cause            *&n; * register) is sent to CPU_A if the same bit in the INT_PEND1          *&n; * register is set. Bits 31:0 can generate either an L3 or L2           *&n; * interrupt, depending on the value of INT_PEND1_REMAP[3:0]. Only      *&n; * one processor in a Bedrock should enable the NI_ERROR, LB_ERROR,     *&n; * XB_ERROR and MD_CORR_ERROR bits.                                     *&n; *                                                                      *&n; ************************************************************************/
DECL|union|pi_int_mask1_a_u
r_typedef
r_union
id|pi_int_mask1_a_u
(brace
DECL|member|pi_int_mask1_a_regval
id|bdrkreg_t
id|pi_int_mask1_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|ima_int_mask1
id|bdrkreg_t
id|ima_int_mask1
suffix:colon
l_int|64
suffix:semicolon
DECL|member|pi_int_mask1_a_fld_s
)brace
id|pi_int_mask1_a_fld_s
suffix:semicolon
DECL|typedef|pi_int_mask1_a_u_t
)brace
id|pi_int_mask1_a_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This read/write register masks the contents of INT_PEND0 to         *&n; * determine whether an L2 interrupt (bit 10 of the processor&squot;s Cause   *&n; * register) is sent to CPU_B if the same bit in the INT_PEND0          *&n; * register is also set. Only one processor in a Bedrock should         *&n; * enable the PAGE_MIGRATION bit/interrupt.                             *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_int_mask0_b_u
r_typedef
r_union
id|pi_int_mask0_b_u
(brace
DECL|member|pi_int_mask0_b_regval
id|bdrkreg_t
id|pi_int_mask0_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|imb_int_mask0_lo
id|bdrkreg_t
id|imb_int_mask0_lo
suffix:colon
l_int|1
suffix:semicolon
DECL|member|imb_gfx_int_a
id|bdrkreg_t
id|imb_gfx_int_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|imb_gfx_int_b
id|bdrkreg_t
id|imb_gfx_int_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|imb_page_migration
id|bdrkreg_t
id|imb_page_migration
suffix:colon
l_int|1
suffix:semicolon
DECL|member|imb_uart_ucntrl
id|bdrkreg_t
id|imb_uart_ucntrl
suffix:colon
l_int|1
suffix:semicolon
DECL|member|imb_or_ccp_mask_a
id|bdrkreg_t
id|imb_or_ccp_mask_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|imb_or_ccp_mask_b
id|bdrkreg_t
id|imb_or_ccp_mask_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|imb_int_mask0_hi
id|bdrkreg_t
id|imb_int_mask0_hi
suffix:colon
l_int|57
suffix:semicolon
DECL|member|pi_int_mask0_b_fld_s
)brace
id|pi_int_mask0_b_fld_s
suffix:semicolon
DECL|typedef|pi_int_mask0_b_u_t
)brace
id|pi_int_mask0_b_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_int_mask0_b_u
r_typedef
r_union
id|pi_int_mask0_b_u
(brace
DECL|member|pi_int_mask0_b_regval
id|bdrkreg_t
id|pi_int_mask0_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|imb_int_mask0_hi
id|bdrkreg_t
id|imb_int_mask0_hi
suffix:colon
l_int|57
suffix:semicolon
DECL|member|imb_or_ccp_mask_b
id|bdrkreg_t
id|imb_or_ccp_mask_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|imb_or_ccp_mask_a
id|bdrkreg_t
id|imb_or_ccp_mask_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|imb_uart_ucntrl
id|bdrkreg_t
id|imb_uart_ucntrl
suffix:colon
l_int|1
suffix:semicolon
DECL|member|imb_page_migration
id|bdrkreg_t
id|imb_page_migration
suffix:colon
l_int|1
suffix:semicolon
DECL|member|imb_gfx_int_b
id|bdrkreg_t
id|imb_gfx_int_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|imb_gfx_int_a
id|bdrkreg_t
id|imb_gfx_int_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|imb_int_mask0_lo
id|bdrkreg_t
id|imb_int_mask0_lo
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_int_mask0_b_fld_s
)brace
id|pi_int_mask0_b_fld_s
suffix:semicolon
DECL|typedef|pi_int_mask0_b_u_t
)brace
id|pi_int_mask0_b_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This read/write register masks the contents of INT_PEND1 to         *&n; * determine whether an interrupt should be sent. Bits 63:32 always     *&n; * generate an L3 interrupt (bit 11 of the processor&squot;s Cause            *&n; * register) is sent to CPU_B if the same bit in the INT_PEND1          *&n; * register is set. Bits 31:0 can generate either an L3 or L2           *&n; * interrupt, depending on the value of INT_PEND1_REMAP[3:0]. Only      *&n; * one processor in a Bedrock should enable the NI_ERROR, LB_ERROR,     *&n; * XB_ERROR and MD_CORR_ERROR bits.                                     *&n; *                                                                      *&n; ************************************************************************/
DECL|union|pi_int_mask1_b_u
r_typedef
r_union
id|pi_int_mask1_b_u
(brace
DECL|member|pi_int_mask1_b_regval
id|bdrkreg_t
id|pi_int_mask1_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|imb_int_mask1
id|bdrkreg_t
id|imb_int_mask1
suffix:colon
l_int|64
suffix:semicolon
DECL|member|pi_int_mask1_b_fld_s
)brace
id|pi_int_mask1_b_fld_s
suffix:semicolon
DECL|typedef|pi_int_mask1_b_u_t
)brace
id|pi_int_mask1_b_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. These registers do    *&n; * not have access protection. A store to this location by a CPU will   *&n; * cause the bit corresponding to the source&squot;s region to be set in      *&n; * CC_PEND_A (or CC_PEND_B). The contents of CC_PEND_A (or CC_PEND_B)   *&n; * determines on a bit-per-region basis whether a CPU-to-CPU            *&n; * interrupt is pending CPU_A (or CPU_B).                               *&n; *                                                                      *&n; ************************************************************************/
DECL|union|pi_cc_pend_set_a_u
r_typedef
r_union
id|pi_cc_pend_set_a_u
(brace
DECL|member|pi_cc_pend_set_a_regval
id|bdrkreg_t
id|pi_cc_pend_set_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|cpsa_cc_pend
id|bdrkreg_t
id|cpsa_cc_pend
suffix:colon
l_int|64
suffix:semicolon
DECL|member|pi_cc_pend_set_a_fld_s
)brace
id|pi_cc_pend_set_a_fld_s
suffix:semicolon
DECL|typedef|pi_cc_pend_set_a_u_t
)brace
id|pi_cc_pend_set_a_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. These registers do    *&n; * not have access protection. A store to this location by a CPU will   *&n; * cause the bit corresponding to the source&squot;s region to be set in      *&n; * CC_PEND_A (or CC_PEND_B). The contents of CC_PEND_A (or CC_PEND_B)   *&n; * determines on a bit-per-region basis whether a CPU-to-CPU            *&n; * interrupt is pending CPU_A (or CPU_B).                               *&n; *                                                                      *&n; ************************************************************************/
DECL|union|pi_cc_pend_set_b_u
r_typedef
r_union
id|pi_cc_pend_set_b_u
(brace
DECL|member|pi_cc_pend_set_b_regval
id|bdrkreg_t
id|pi_cc_pend_set_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|cpsb_cc_pend
id|bdrkreg_t
id|cpsb_cc_pend
suffix:colon
l_int|64
suffix:semicolon
DECL|member|pi_cc_pend_set_b_fld_s
)brace
id|pi_cc_pend_set_b_fld_s
suffix:semicolon
DECL|typedef|pi_cc_pend_set_b_u_t
)brace
id|pi_cc_pend_set_b_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. Reading this          *&n; * location will return the contents of CC_PEND_A (or CC_PEND_B).       *&n; * Writing this location will clear the bits corresponding to which     *&n; * data bits are driven high during the store; therefore, storing all   *&n; * ones would clear all bits.                                           *&n; *                                                                      *&n; ************************************************************************/
DECL|union|pi_cc_pend_clr_a_u
r_typedef
r_union
id|pi_cc_pend_clr_a_u
(brace
DECL|member|pi_cc_pend_clr_a_regval
id|bdrkreg_t
id|pi_cc_pend_clr_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|cpca_cc_pend
id|bdrkreg_t
id|cpca_cc_pend
suffix:colon
l_int|64
suffix:semicolon
DECL|member|pi_cc_pend_clr_a_fld_s
)brace
id|pi_cc_pend_clr_a_fld_s
suffix:semicolon
DECL|typedef|pi_cc_pend_clr_a_u_t
)brace
id|pi_cc_pend_clr_a_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. Reading this          *&n; * location will return the contents of CC_PEND_A (or CC_PEND_B).       *&n; * Writing this location will clear the bits corresponding to which     *&n; * data bits are driven high during the store; therefore, storing all   *&n; * ones would clear all bits.                                           *&n; *                                                                      *&n; ************************************************************************/
DECL|union|pi_cc_pend_clr_b_u
r_typedef
r_union
id|pi_cc_pend_clr_b_u
(brace
DECL|member|pi_cc_pend_clr_b_regval
id|bdrkreg_t
id|pi_cc_pend_clr_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|cpcb_cc_pend
id|bdrkreg_t
id|cpcb_cc_pend
suffix:colon
l_int|64
suffix:semicolon
DECL|member|pi_cc_pend_clr_b_fld_s
)brace
id|pi_cc_pend_clr_b_fld_s
suffix:semicolon
DECL|typedef|pi_cc_pend_clr_b_u_t
)brace
id|pi_cc_pend_clr_b_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This read/write register masks the contents of both CC_PEND_A and   *&n; * CC_PEND_B.                                                           *&n; *                                                                      *&n; ************************************************************************/
DECL|union|pi_cc_mask_u
r_typedef
r_union
id|pi_cc_mask_u
(brace
DECL|member|pi_cc_mask_regval
id|bdrkreg_t
id|pi_cc_mask_regval
suffix:semicolon
r_struct
(brace
DECL|member|cm_cc_mask
id|bdrkreg_t
id|cm_cc_mask
suffix:colon
l_int|64
suffix:semicolon
DECL|member|pi_cc_mask_fld_s
)brace
id|pi_cc_mask_fld_s
suffix:semicolon
DECL|typedef|pi_cc_mask_u_t
)brace
id|pi_cc_mask_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This read/write register redirects INT_PEND1[31:0] from L3 to L2    *&n; * interrupt level.Bit 4 in this register is used to enable error       *&n; * interrupt forwarding to the II. When this bit is set, if any of      *&n; * the three memory interrupts (correctable error, uncorrectable        *&n; * error, or page migration), or the NI, LB or XB error interrupts      *&n; * are set, the PI_II_ERROR_INT wire will be asserted. When this wire   *&n; * is asserted, the II will send an interrupt to the node specified     *&n; * in its IIDSR (Interrupt Destination Register). This allows these     *&n; * interrupts to be forwarded to another node.                          *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_int_pend1_remap_u
r_typedef
r_union
id|pi_int_pend1_remap_u
(brace
DECL|member|pi_int_pend1_remap_regval
id|bdrkreg_t
id|pi_int_pend1_remap_regval
suffix:semicolon
r_struct
(brace
DECL|member|ipr_remap_0
id|bdrkreg_t
id|ipr_remap_0
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ipr_remap_1
id|bdrkreg_t
id|ipr_remap_1
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ipr_remap_2
id|bdrkreg_t
id|ipr_remap_2
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ipr_remap_3
id|bdrkreg_t
id|ipr_remap_3
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ipr_error_forward
id|bdrkreg_t
id|ipr_error_forward
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ipr_reserved
id|bdrkreg_t
id|ipr_reserved
suffix:colon
l_int|59
suffix:semicolon
DECL|member|pi_int_pend1_remap_fld_s
)brace
id|pi_int_pend1_remap_fld_s
suffix:semicolon
DECL|typedef|pi_int_pend1_remap_u_t
)brace
id|pi_int_pend1_remap_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_int_pend1_remap_u
r_typedef
r_union
id|pi_int_pend1_remap_u
(brace
DECL|member|pi_int_pend1_remap_regval
id|bdrkreg_t
id|pi_int_pend1_remap_regval
suffix:semicolon
r_struct
(brace
DECL|member|ipr_reserved
id|bdrkreg_t
id|ipr_reserved
suffix:colon
l_int|59
suffix:semicolon
DECL|member|ipr_error_forward
id|bdrkreg_t
id|ipr_error_forward
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ipr_remap_3
id|bdrkreg_t
id|ipr_remap_3
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ipr_remap_2
id|bdrkreg_t
id|ipr_remap_2
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ipr_remap_1
id|bdrkreg_t
id|ipr_remap_1
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ipr_remap_0
id|bdrkreg_t
id|ipr_remap_0
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_int_pend1_remap_fld_s
)brace
id|pi_int_pend1_remap_fld_s
suffix:semicolon
DECL|typedef|pi_int_pend1_remap_u_t
)brace
id|pi_int_pend1_remap_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. When the real time    *&n; * counter (RT_Counter) is equal to the value in this register, the     *&n; * RT_INT_PEND register is set, which causes a Level-4 interrupt to     *&n; * be sent to the processor.                                            *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_rt_compare_a_u
r_typedef
r_union
id|pi_rt_compare_a_u
(brace
DECL|member|pi_rt_compare_a_regval
id|bdrkreg_t
id|pi_rt_compare_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|rca_rt_compare
id|bdrkreg_t
id|rca_rt_compare
suffix:colon
l_int|55
suffix:semicolon
DECL|member|rca_rsvd
id|bdrkreg_t
id|rca_rsvd
suffix:colon
l_int|9
suffix:semicolon
DECL|member|pi_rt_compare_a_fld_s
)brace
id|pi_rt_compare_a_fld_s
suffix:semicolon
DECL|typedef|pi_rt_compare_a_u_t
)brace
id|pi_rt_compare_a_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_rt_compare_a_u
r_typedef
r_union
id|pi_rt_compare_a_u
(brace
DECL|member|pi_rt_compare_a_regval
id|bdrkreg_t
id|pi_rt_compare_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|rca_rsvd
id|bdrkreg_t
id|rca_rsvd
suffix:colon
l_int|9
suffix:semicolon
DECL|member|rca_rt_compare
id|bdrkreg_t
id|rca_rt_compare
suffix:colon
l_int|55
suffix:semicolon
DECL|member|pi_rt_compare_a_fld_s
)brace
id|pi_rt_compare_a_fld_s
suffix:semicolon
DECL|typedef|pi_rt_compare_a_u_t
)brace
id|pi_rt_compare_a_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. When the real time    *&n; * counter (RT_Counter) is equal to the value in this register, the     *&n; * RT_INT_PEND register is set, which causes a Level-4 interrupt to     *&n; * be sent to the processor.                                            *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_rt_compare_b_u
r_typedef
r_union
id|pi_rt_compare_b_u
(brace
DECL|member|pi_rt_compare_b_regval
id|bdrkreg_t
id|pi_rt_compare_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|rcb_rt_compare
id|bdrkreg_t
id|rcb_rt_compare
suffix:colon
l_int|55
suffix:semicolon
DECL|member|rcb_rsvd
id|bdrkreg_t
id|rcb_rsvd
suffix:colon
l_int|9
suffix:semicolon
DECL|member|pi_rt_compare_b_fld_s
)brace
id|pi_rt_compare_b_fld_s
suffix:semicolon
DECL|typedef|pi_rt_compare_b_u_t
)brace
id|pi_rt_compare_b_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_rt_compare_b_u
r_typedef
r_union
id|pi_rt_compare_b_u
(brace
DECL|member|pi_rt_compare_b_regval
id|bdrkreg_t
id|pi_rt_compare_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|rcb_rsvd
id|bdrkreg_t
id|rcb_rsvd
suffix:colon
l_int|9
suffix:semicolon
DECL|member|rcb_rt_compare
id|bdrkreg_t
id|rcb_rt_compare
suffix:colon
l_int|55
suffix:semicolon
DECL|member|pi_rt_compare_b_fld_s
)brace
id|pi_rt_compare_b_fld_s
suffix:semicolon
DECL|typedef|pi_rt_compare_b_u_t
)brace
id|pi_rt_compare_b_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  When the least significant 32 bits of the real time counter         *&n; * (RT_Counter) are equal to the value in this register, the            *&n; * PROF_INT_PEND_A and PROF_INT_PEND_B registers are set to 0x1.        *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_profile_compare_u
r_typedef
r_union
id|pi_profile_compare_u
(brace
DECL|member|pi_profile_compare_regval
id|bdrkreg_t
id|pi_profile_compare_regval
suffix:semicolon
r_struct
(brace
DECL|member|pc_profile_compare
id|bdrkreg_t
id|pc_profile_compare
suffix:colon
l_int|32
suffix:semicolon
DECL|member|pc_rsvd
id|bdrkreg_t
id|pc_rsvd
suffix:colon
l_int|32
suffix:semicolon
DECL|member|pi_profile_compare_fld_s
)brace
id|pi_profile_compare_fld_s
suffix:semicolon
DECL|typedef|pi_profile_compare_u_t
)brace
id|pi_profile_compare_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_profile_compare_u
r_typedef
r_union
id|pi_profile_compare_u
(brace
DECL|member|pi_profile_compare_regval
id|bdrkreg_t
id|pi_profile_compare_regval
suffix:semicolon
r_struct
(brace
DECL|member|pc_rsvd
id|bdrkreg_t
id|pc_rsvd
suffix:colon
l_int|32
suffix:semicolon
DECL|member|pc_profile_compare
id|bdrkreg_t
id|pc_profile_compare
suffix:colon
l_int|32
suffix:semicolon
DECL|member|pi_profile_compare_fld_s
)brace
id|pi_profile_compare_fld_s
suffix:semicolon
DECL|typedef|pi_profile_compare_u_t
)brace
id|pi_profile_compare_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. If the bit in the     *&n; * corresponding RT_INT_EN_A/B register is set, the processor&squot;s level   *&n; * 5 interrupt is set to the value of the RTC_INT_PEND bit in this      *&n; * register. Storing any value to this location will clear the          *&n; * RTC_INT_PEND bit in the register.                                    *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_rt_int_pend_a_u
r_typedef
r_union
id|pi_rt_int_pend_a_u
(brace
DECL|member|pi_rt_int_pend_a_regval
id|bdrkreg_t
id|pi_rt_int_pend_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|ripa_rtc_int_pend
id|bdrkreg_t
id|ripa_rtc_int_pend
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ripa_rsvd
id|bdrkreg_t
id|ripa_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|pi_rt_int_pend_a_fld_s
)brace
id|pi_rt_int_pend_a_fld_s
suffix:semicolon
DECL|typedef|pi_rt_int_pend_a_u_t
)brace
id|pi_rt_int_pend_a_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_rt_int_pend_a_u
r_typedef
r_union
id|pi_rt_int_pend_a_u
(brace
DECL|member|pi_rt_int_pend_a_regval
id|bdrkreg_t
id|pi_rt_int_pend_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|ripa_rsvd
id|bdrkreg_t
id|ripa_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|ripa_rtc_int_pend
id|bdrkreg_t
id|ripa_rtc_int_pend
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_rt_int_pend_a_fld_s
)brace
id|pi_rt_int_pend_a_fld_s
suffix:semicolon
DECL|typedef|pi_rt_int_pend_a_u_t
)brace
id|pi_rt_int_pend_a_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. If the bit in the     *&n; * corresponding RT_INT_EN_A/B register is set, the processor&squot;s level   *&n; * 5 interrupt is set to the value of the RTC_INT_PEND bit in this      *&n; * register. Storing any value to this location will clear the          *&n; * RTC_INT_PEND bit in the register.                                    *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_rt_int_pend_b_u
r_typedef
r_union
id|pi_rt_int_pend_b_u
(brace
DECL|member|pi_rt_int_pend_b_regval
id|bdrkreg_t
id|pi_rt_int_pend_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|ripb_rtc_int_pend
id|bdrkreg_t
id|ripb_rtc_int_pend
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ripb_rsvd
id|bdrkreg_t
id|ripb_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|pi_rt_int_pend_b_fld_s
)brace
id|pi_rt_int_pend_b_fld_s
suffix:semicolon
DECL|typedef|pi_rt_int_pend_b_u_t
)brace
id|pi_rt_int_pend_b_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_rt_int_pend_b_u
r_typedef
r_union
id|pi_rt_int_pend_b_u
(brace
DECL|member|pi_rt_int_pend_b_regval
id|bdrkreg_t
id|pi_rt_int_pend_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|ripb_rsvd
id|bdrkreg_t
id|ripb_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|ripb_rtc_int_pend
id|bdrkreg_t
id|ripb_rtc_int_pend
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_rt_int_pend_b_fld_s
)brace
id|pi_rt_int_pend_b_fld_s
suffix:semicolon
DECL|typedef|pi_rt_int_pend_b_u_t
)brace
id|pi_rt_int_pend_b_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. Both registers are    *&n; * set when the PROFILE_COMPARE register is equal to bits [31:0] of     *&n; * the RT_Counter. If the bit in the corresponding PROF_INT_EN_A/B      *&n; * register is set, the processor&squot;s level 5 interrupt is set to the     *&n; * value of the PROF_INT_PEND bit in this register. Storing any value   *&n; * to this location will clear the PROF_INT_PEND bit in the register.   *&n; * The reason for having A and B versions of this register is that      *&n; * they need to be cleared independently.                               *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_prof_int_pend_a_u
r_typedef
r_union
id|pi_prof_int_pend_a_u
(brace
DECL|member|pi_prof_int_pend_a_regval
id|bdrkreg_t
id|pi_prof_int_pend_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|pipa_prof_int_pend
id|bdrkreg_t
id|pipa_prof_int_pend
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pipa_rsvd
id|bdrkreg_t
id|pipa_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|pi_prof_int_pend_a_fld_s
)brace
id|pi_prof_int_pend_a_fld_s
suffix:semicolon
DECL|typedef|pi_prof_int_pend_a_u_t
)brace
id|pi_prof_int_pend_a_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_prof_int_pend_a_u
r_typedef
r_union
id|pi_prof_int_pend_a_u
(brace
DECL|member|pi_prof_int_pend_a_regval
id|bdrkreg_t
id|pi_prof_int_pend_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|pipa_rsvd
id|bdrkreg_t
id|pipa_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|pipa_prof_int_pend
id|bdrkreg_t
id|pipa_prof_int_pend
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_prof_int_pend_a_fld_s
)brace
id|pi_prof_int_pend_a_fld_s
suffix:semicolon
DECL|typedef|pi_prof_int_pend_a_u_t
)brace
id|pi_prof_int_pend_a_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. Both registers are    *&n; * set when the PROFILE_COMPARE register is equal to bits [31:0] of     *&n; * the RT_Counter. If the bit in the corresponding PROF_INT_EN_A/B      *&n; * register is set, the processor&squot;s level 5 interrupt is set to the     *&n; * value of the PROF_INT_PEND bit in this register. Storing any value   *&n; * to this location will clear the PROF_INT_PEND bit in the register.   *&n; * The reason for having A and B versions of this register is that      *&n; * they need to be cleared independently.                               *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_prof_int_pend_b_u
r_typedef
r_union
id|pi_prof_int_pend_b_u
(brace
DECL|member|pi_prof_int_pend_b_regval
id|bdrkreg_t
id|pi_prof_int_pend_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|pipb_prof_int_pend
id|bdrkreg_t
id|pipb_prof_int_pend
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pipb_rsvd
id|bdrkreg_t
id|pipb_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|pi_prof_int_pend_b_fld_s
)brace
id|pi_prof_int_pend_b_fld_s
suffix:semicolon
DECL|typedef|pi_prof_int_pend_b_u_t
)brace
id|pi_prof_int_pend_b_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_prof_int_pend_b_u
r_typedef
r_union
id|pi_prof_int_pend_b_u
(brace
DECL|member|pi_prof_int_pend_b_regval
id|bdrkreg_t
id|pi_prof_int_pend_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|pipb_rsvd
id|bdrkreg_t
id|pipb_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|pipb_prof_int_pend
id|bdrkreg_t
id|pipb_prof_int_pend
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_prof_int_pend_b_fld_s
)brace
id|pi_prof_int_pend_b_fld_s
suffix:semicolon
DECL|typedef|pi_prof_int_pend_b_u_t
)brace
id|pi_prof_int_pend_b_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. Enables RTC           *&n; * interrupt to the associated CPU.                                     *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_rt_int_en_a_u
r_typedef
r_union
id|pi_rt_int_en_a_u
(brace
DECL|member|pi_rt_int_en_a_regval
id|bdrkreg_t
id|pi_rt_int_en_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|riea_rtc_int_en
id|bdrkreg_t
id|riea_rtc_int_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|riea_rsvd
id|bdrkreg_t
id|riea_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|pi_rt_int_en_a_fld_s
)brace
id|pi_rt_int_en_a_fld_s
suffix:semicolon
DECL|typedef|pi_rt_int_en_a_u_t
)brace
id|pi_rt_int_en_a_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_rt_int_en_a_u
r_typedef
r_union
id|pi_rt_int_en_a_u
(brace
DECL|member|pi_rt_int_en_a_regval
id|bdrkreg_t
id|pi_rt_int_en_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|riea_rsvd
id|bdrkreg_t
id|riea_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|riea_rtc_int_en
id|bdrkreg_t
id|riea_rtc_int_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_rt_int_en_a_fld_s
)brace
id|pi_rt_int_en_a_fld_s
suffix:semicolon
DECL|typedef|pi_rt_int_en_a_u_t
)brace
id|pi_rt_int_en_a_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. Enables RTC           *&n; * interrupt to the associated CPU.                                     *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_rt_int_en_b_u
r_typedef
r_union
id|pi_rt_int_en_b_u
(brace
DECL|member|pi_rt_int_en_b_regval
id|bdrkreg_t
id|pi_rt_int_en_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|rieb_rtc_int_en
id|bdrkreg_t
id|rieb_rtc_int_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|rieb_rsvd
id|bdrkreg_t
id|rieb_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|pi_rt_int_en_b_fld_s
)brace
id|pi_rt_int_en_b_fld_s
suffix:semicolon
DECL|typedef|pi_rt_int_en_b_u_t
)brace
id|pi_rt_int_en_b_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_rt_int_en_b_u
r_typedef
r_union
id|pi_rt_int_en_b_u
(brace
DECL|member|pi_rt_int_en_b_regval
id|bdrkreg_t
id|pi_rt_int_en_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|rieb_rsvd
id|bdrkreg_t
id|rieb_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|rieb_rtc_int_en
id|bdrkreg_t
id|rieb_rtc_int_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_rt_int_en_b_fld_s
)brace
id|pi_rt_int_en_b_fld_s
suffix:semicolon
DECL|typedef|pi_rt_int_en_b_u_t
)brace
id|pi_rt_int_en_b_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. Enables profiling     *&n; * interrupt to the associated CPU.                                     *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_prof_int_en_a_u
r_typedef
r_union
id|pi_prof_int_en_a_u
(brace
DECL|member|pi_prof_int_en_a_regval
id|bdrkreg_t
id|pi_prof_int_en_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|piea_prof_int_en
id|bdrkreg_t
id|piea_prof_int_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|piea_rsvd
id|bdrkreg_t
id|piea_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|pi_prof_int_en_a_fld_s
)brace
id|pi_prof_int_en_a_fld_s
suffix:semicolon
DECL|typedef|pi_prof_int_en_a_u_t
)brace
id|pi_prof_int_en_a_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_prof_int_en_a_u
r_typedef
r_union
id|pi_prof_int_en_a_u
(brace
DECL|member|pi_prof_int_en_a_regval
id|bdrkreg_t
id|pi_prof_int_en_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|piea_rsvd
id|bdrkreg_t
id|piea_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|piea_prof_int_en
id|bdrkreg_t
id|piea_prof_int_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_prof_int_en_a_fld_s
)brace
id|pi_prof_int_en_a_fld_s
suffix:semicolon
DECL|typedef|pi_prof_int_en_a_u_t
)brace
id|pi_prof_int_en_a_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. Enables profiling     *&n; * interrupt to the associated CPU.                                     *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_prof_int_en_b_u
r_typedef
r_union
id|pi_prof_int_en_b_u
(brace
DECL|member|pi_prof_int_en_b_regval
id|bdrkreg_t
id|pi_prof_int_en_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|pieb_prof_int_en
id|bdrkreg_t
id|pieb_prof_int_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pieb_rsvd
id|bdrkreg_t
id|pieb_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|pi_prof_int_en_b_fld_s
)brace
id|pi_prof_int_en_b_fld_s
suffix:semicolon
DECL|typedef|pi_prof_int_en_b_u_t
)brace
id|pi_prof_int_en_b_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_prof_int_en_b_u
r_typedef
r_union
id|pi_prof_int_en_b_u
(brace
DECL|member|pi_prof_int_en_b_regval
id|bdrkreg_t
id|pi_prof_int_en_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|pieb_rsvd
id|bdrkreg_t
id|pieb_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|pieb_prof_int_en
id|bdrkreg_t
id|pieb_prof_int_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_prof_int_en_b_fld_s
)brace
id|pi_prof_int_en_b_fld_s
suffix:semicolon
DECL|typedef|pi_prof_int_en_b_u_t
)brace
id|pi_prof_int_en_b_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register controls operation of the debug data from the PI,     *&n; * along with Debug_Sel[2:0] from the Debug module. For some values     *&n; * of Debug_Sel[2:0], the B_SEL bit selects whether the debug bits      *&n; * are looking at the processor A or processor B logic. The remaining   *&n; * bits select which signal(s) are ORed to create DebugData bits 31     *&n; * and 30 for all of the PI debug selections.                           *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_debug_sel_u
r_typedef
r_union
id|pi_debug_sel_u
(brace
DECL|member|pi_debug_sel_regval
id|bdrkreg_t
id|pi_debug_sel_regval
suffix:semicolon
r_struct
(brace
DECL|member|ds_low_t5cc_a
id|bdrkreg_t
id|ds_low_t5cc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_low_t5cc_b
id|bdrkreg_t
id|ds_low_t5cc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_low_totcc_a
id|bdrkreg_t
id|ds_low_totcc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_low_totcc_b
id|bdrkreg_t
id|ds_low_totcc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_low_reqcc_a
id|bdrkreg_t
id|ds_low_reqcc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_low_reqcc_b
id|bdrkreg_t
id|ds_low_reqcc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_low_rplcc_a
id|bdrkreg_t
id|ds_low_rplcc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_low_rplcc_b
id|bdrkreg_t
id|ds_low_rplcc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_low_intcc
id|bdrkreg_t
id|ds_low_intcc
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_low_perf_inc_a_0
id|bdrkreg_t
id|ds_low_perf_inc_a_0
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_low_perf_inc_a_1
id|bdrkreg_t
id|ds_low_perf_inc_a_1
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_low_perf_inc_b_0
id|bdrkreg_t
id|ds_low_perf_inc_b_0
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_low_perf_inc_b_1
id|bdrkreg_t
id|ds_low_perf_inc_b_1
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_t5cc_a
id|bdrkreg_t
id|ds_high_t5cc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_t5cc_b
id|bdrkreg_t
id|ds_high_t5cc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_totcc_a
id|bdrkreg_t
id|ds_high_totcc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_totcc_b
id|bdrkreg_t
id|ds_high_totcc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_reqcc_a
id|bdrkreg_t
id|ds_high_reqcc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_reqcc_b
id|bdrkreg_t
id|ds_high_reqcc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_rplcc_a
id|bdrkreg_t
id|ds_high_rplcc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_rplcc_b
id|bdrkreg_t
id|ds_high_rplcc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_intcc
id|bdrkreg_t
id|ds_high_intcc
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_perf_inc_a_0
id|bdrkreg_t
id|ds_high_perf_inc_a_0
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_perf_inc_a_1
id|bdrkreg_t
id|ds_high_perf_inc_a_1
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_perf_inc_b_0
id|bdrkreg_t
id|ds_high_perf_inc_b_0
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_perf_inc_b_1
id|bdrkreg_t
id|ds_high_perf_inc_b_1
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_b_sel
id|bdrkreg_t
id|ds_b_sel
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_rsvd
id|bdrkreg_t
id|ds_rsvd
suffix:colon
l_int|37
suffix:semicolon
DECL|member|pi_debug_sel_fld_s
)brace
id|pi_debug_sel_fld_s
suffix:semicolon
DECL|typedef|pi_debug_sel_u_t
)brace
id|pi_debug_sel_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_debug_sel_u
r_typedef
r_union
id|pi_debug_sel_u
(brace
DECL|member|pi_debug_sel_regval
id|bdrkreg_t
id|pi_debug_sel_regval
suffix:semicolon
r_struct
(brace
DECL|member|ds_rsvd
id|bdrkreg_t
id|ds_rsvd
suffix:colon
l_int|37
suffix:semicolon
DECL|member|ds_b_sel
id|bdrkreg_t
id|ds_b_sel
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_perf_inc_b_1
id|bdrkreg_t
id|ds_high_perf_inc_b_1
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_perf_inc_b_0
id|bdrkreg_t
id|ds_high_perf_inc_b_0
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_perf_inc_a_1
id|bdrkreg_t
id|ds_high_perf_inc_a_1
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_perf_inc_a_0
id|bdrkreg_t
id|ds_high_perf_inc_a_0
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_intcc
id|bdrkreg_t
id|ds_high_intcc
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_rplcc_b
id|bdrkreg_t
id|ds_high_rplcc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_rplcc_a
id|bdrkreg_t
id|ds_high_rplcc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_reqcc_b
id|bdrkreg_t
id|ds_high_reqcc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_reqcc_a
id|bdrkreg_t
id|ds_high_reqcc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_totcc_b
id|bdrkreg_t
id|ds_high_totcc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_totcc_a
id|bdrkreg_t
id|ds_high_totcc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_t5cc_b
id|bdrkreg_t
id|ds_high_t5cc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_high_t5cc_a
id|bdrkreg_t
id|ds_high_t5cc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_low_perf_inc_b_1
id|bdrkreg_t
id|ds_low_perf_inc_b_1
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_low_perf_inc_b_0
id|bdrkreg_t
id|ds_low_perf_inc_b_0
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_low_perf_inc_a_1
id|bdrkreg_t
id|ds_low_perf_inc_a_1
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_low_perf_inc_a_0
id|bdrkreg_t
id|ds_low_perf_inc_a_0
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_low_intcc
id|bdrkreg_t
id|ds_low_intcc
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_low_rplcc_b
id|bdrkreg_t
id|ds_low_rplcc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_low_rplcc_a
id|bdrkreg_t
id|ds_low_rplcc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_low_reqcc_b
id|bdrkreg_t
id|ds_low_reqcc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_low_reqcc_a
id|bdrkreg_t
id|ds_low_reqcc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_low_totcc_b
id|bdrkreg_t
id|ds_low_totcc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_low_totcc_a
id|bdrkreg_t
id|ds_low_totcc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_low_t5cc_b
id|bdrkreg_t
id|ds_low_t5cc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ds_low_t5cc_a
id|bdrkreg_t
id|ds_low_t5cc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_debug_sel_fld_s
)brace
id|pi_debug_sel_fld_s
suffix:semicolon
DECL|typedef|pi_debug_sel_u_t
)brace
id|pi_debug_sel_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  A write to this register allows a single bit in the INT_PEND0 or    *&n; * INT_PEND1 registers to be set or cleared. If 6 is clear, a bit is    *&n; * modified in INT_PEND0, while if 6 is set, a bit is modified in       *&n; * INT_PEND1. The value in 5:0 (ranging from 63 to 0) will determine    *&n; * which bit in the register is effected. The value of 8 will           *&n; * determine whether the desired bit is set (8=1) or cleared (8=0).     *&n; * This is the only register which is accessible by IO issued PWRI      *&n; * command and is protected through the IO_PROTECT register. If the     *&n; * region bit in the IO_PROTECT is not set then a WERR reply is         *&n; * issued. CPU access is controlled through CPU_PROTECT. The contents   *&n; * of this register are masked with the contents of INT_MASK_A          *&n; * (INT_MASK_B) to determine whether an L2 interrupt is issued to       *&n; * CPU_A (CPU_B).                                                       *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_int_pend_mod_alias_u
r_typedef
r_union
id|pi_int_pend_mod_alias_u
(brace
DECL|member|pi_int_pend_mod_alias_regval
id|bdrkreg_t
id|pi_int_pend_mod_alias_regval
suffix:semicolon
r_struct
(brace
DECL|member|ipma_bit_select
id|bdrkreg_t
id|ipma_bit_select
suffix:colon
l_int|6
suffix:semicolon
DECL|member|ipma_reg_select
id|bdrkreg_t
id|ipma_reg_select
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ipma_rsvd_1
id|bdrkreg_t
id|ipma_rsvd_1
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ipma_value
id|bdrkreg_t
id|ipma_value
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ipma_rsvd
id|bdrkreg_t
id|ipma_rsvd
suffix:colon
l_int|55
suffix:semicolon
DECL|member|pi_int_pend_mod_alias_fld_s
)brace
id|pi_int_pend_mod_alias_fld_s
suffix:semicolon
DECL|typedef|pi_int_pend_mod_alias_u_t
)brace
id|pi_int_pend_mod_alias_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_int_pend_mod_alias_u
r_typedef
r_union
id|pi_int_pend_mod_alias_u
(brace
DECL|member|pi_int_pend_mod_alias_regval
id|bdrkreg_t
id|pi_int_pend_mod_alias_regval
suffix:semicolon
r_struct
(brace
DECL|member|ipma_rsvd
id|bdrkreg_t
id|ipma_rsvd
suffix:colon
l_int|55
suffix:semicolon
DECL|member|ipma_value
id|bdrkreg_t
id|ipma_value
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ipma_rsvd_1
id|bdrkreg_t
id|ipma_rsvd_1
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ipma_reg_select
id|bdrkreg_t
id|ipma_reg_select
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ipma_bit_select
id|bdrkreg_t
id|ipma_bit_select
suffix:colon
l_int|6
suffix:semicolon
DECL|member|pi_int_pend_mod_alias_fld_s
)brace
id|pi_int_pend_mod_alias_fld_s
suffix:semicolon
DECL|typedef|pi_int_pend_mod_alias_u_t
)brace
id|pi_int_pend_mod_alias_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. This register         *&n; * specifies the value of the Graphics Page. Uncached writes into the   *&n; * Graphics Page (with uncached attribute of IO) are done with GFXWS    *&n; * commands rather than the normal PWRI commands. GFXWS commands are    *&n; * tracked with the graphics credit counters.                           *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_gfx_page_a_u
r_typedef
r_union
id|pi_gfx_page_a_u
(brace
DECL|member|pi_gfx_page_a_regval
id|bdrkreg_t
id|pi_gfx_page_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|gpa_rsvd_1
id|bdrkreg_t
id|gpa_rsvd_1
suffix:colon
l_int|17
suffix:semicolon
DECL|member|gpa_gfx_page_addr
id|bdrkreg_t
id|gpa_gfx_page_addr
suffix:colon
l_int|23
suffix:semicolon
DECL|member|gpa_en_gfx_page
id|bdrkreg_t
id|gpa_en_gfx_page
suffix:colon
l_int|1
suffix:semicolon
DECL|member|gpa_rsvd
id|bdrkreg_t
id|gpa_rsvd
suffix:colon
l_int|23
suffix:semicolon
DECL|member|pi_gfx_page_a_fld_s
)brace
id|pi_gfx_page_a_fld_s
suffix:semicolon
DECL|typedef|pi_gfx_page_a_u_t
)brace
id|pi_gfx_page_a_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_gfx_page_a_u
r_typedef
r_union
id|pi_gfx_page_a_u
(brace
DECL|member|pi_gfx_page_a_regval
id|bdrkreg_t
id|pi_gfx_page_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|gpa_rsvd
id|bdrkreg_t
id|gpa_rsvd
suffix:colon
l_int|23
suffix:semicolon
DECL|member|gpa_en_gfx_page
id|bdrkreg_t
id|gpa_en_gfx_page
suffix:colon
l_int|1
suffix:semicolon
DECL|member|gpa_gfx_page_addr
id|bdrkreg_t
id|gpa_gfx_page_addr
suffix:colon
l_int|23
suffix:semicolon
DECL|member|gpa_rsvd_1
id|bdrkreg_t
id|gpa_rsvd_1
suffix:colon
l_int|17
suffix:semicolon
DECL|member|pi_gfx_page_a_fld_s
)brace
id|pi_gfx_page_a_fld_s
suffix:semicolon
DECL|typedef|pi_gfx_page_a_u_t
)brace
id|pi_gfx_page_a_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. This register         *&n; * counts graphics credits. This counter is decremented for each        *&n; * doubleword sent to graphics with GFXWS or GFXWL commands. It is      *&n; * incremented for each doubleword acknowledge from graphics. When      *&n; * this counter has a smaller value than the GFX_BIAS register,         *&n; * SysWrRdy_L is deasserted, an interrupt is sent to the processor,     *&n; * and SysWrRdy_L is allowed to be asserted again. This is the basic    *&n; * mechanism for flow-controlling graphics writes.                      *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_gfx_credit_cntr_a_u
r_typedef
r_union
id|pi_gfx_credit_cntr_a_u
(brace
DECL|member|pi_gfx_credit_cntr_a_regval
id|bdrkreg_t
id|pi_gfx_credit_cntr_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|gcca_gfx_credit_cntr
id|bdrkreg_t
id|gcca_gfx_credit_cntr
suffix:colon
l_int|12
suffix:semicolon
DECL|member|gcca_rsvd
id|bdrkreg_t
id|gcca_rsvd
suffix:colon
l_int|52
suffix:semicolon
DECL|member|pi_gfx_credit_cntr_a_fld_s
)brace
id|pi_gfx_credit_cntr_a_fld_s
suffix:semicolon
DECL|typedef|pi_gfx_credit_cntr_a_u_t
)brace
id|pi_gfx_credit_cntr_a_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_gfx_credit_cntr_a_u
r_typedef
r_union
id|pi_gfx_credit_cntr_a_u
(brace
DECL|member|pi_gfx_credit_cntr_a_regval
id|bdrkreg_t
id|pi_gfx_credit_cntr_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|gcca_rsvd
id|bdrkreg_t
id|gcca_rsvd
suffix:colon
l_int|52
suffix:semicolon
DECL|member|gcca_gfx_credit_cntr
id|bdrkreg_t
id|gcca_gfx_credit_cntr
suffix:colon
l_int|12
suffix:semicolon
DECL|member|pi_gfx_credit_cntr_a_fld_s
)brace
id|pi_gfx_credit_cntr_a_fld_s
suffix:semicolon
DECL|typedef|pi_gfx_credit_cntr_a_u_t
)brace
id|pi_gfx_credit_cntr_a_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. When the graphics     *&n; * credit counter is less than or equal to this value, a flow control   *&n; * interrupt is sent.                                                   *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_gfx_bias_a_u
r_typedef
r_union
id|pi_gfx_bias_a_u
(brace
DECL|member|pi_gfx_bias_a_regval
id|bdrkreg_t
id|pi_gfx_bias_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|gba_gfx_bias
id|bdrkreg_t
id|gba_gfx_bias
suffix:colon
l_int|12
suffix:semicolon
DECL|member|gba_rsvd
id|bdrkreg_t
id|gba_rsvd
suffix:colon
l_int|52
suffix:semicolon
DECL|member|pi_gfx_bias_a_fld_s
)brace
id|pi_gfx_bias_a_fld_s
suffix:semicolon
DECL|typedef|pi_gfx_bias_a_u_t
)brace
id|pi_gfx_bias_a_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_gfx_bias_a_u
r_typedef
r_union
id|pi_gfx_bias_a_u
(brace
DECL|member|pi_gfx_bias_a_regval
id|bdrkreg_t
id|pi_gfx_bias_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|gba_rsvd
id|bdrkreg_t
id|gba_rsvd
suffix:colon
l_int|52
suffix:semicolon
DECL|member|gba_gfx_bias
id|bdrkreg_t
id|gba_gfx_bias
suffix:colon
l_int|12
suffix:semicolon
DECL|member|pi_gfx_bias_a_fld_s
)brace
id|pi_gfx_bias_a_fld_s
suffix:semicolon
DECL|typedef|pi_gfx_bias_a_u_t
)brace
id|pi_gfx_bias_a_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; * Description:  There is one of these registers for each CPU. When     *&n; * this counter reaches the value of the GFX_INT_CMP register, an       *&n; * interrupt is sent to the associated processor. At each clock         *&n; * cycle, the value in this register can be changed by any one of the   *&n; * following actions:                                                   *&n; * - Written by software.                                               *&n; * - Loaded with the value of GFX_INT_CMP, when an interrupt, NMI, or   *&n; * soft reset occurs, thus preventing an additional interrupt.          *&n; * - Zeroed, when the GFX_CREDIT_CNTR rises above the bias value.       *&n; * - Incremented (by one at each clock) for each clock that the         *&n; * GFX_CREDIT_CNTR is less than or equal to zero.                       *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_gfx_int_cntr_a_u
r_typedef
r_union
id|pi_gfx_int_cntr_a_u
(brace
DECL|member|pi_gfx_int_cntr_a_regval
id|bdrkreg_t
id|pi_gfx_int_cntr_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|gica_gfx_int_cntr
id|bdrkreg_t
id|gica_gfx_int_cntr
suffix:colon
l_int|26
suffix:semicolon
DECL|member|gica_rsvd
id|bdrkreg_t
id|gica_rsvd
suffix:colon
l_int|38
suffix:semicolon
DECL|member|pi_gfx_int_cntr_a_fld_s
)brace
id|pi_gfx_int_cntr_a_fld_s
suffix:semicolon
DECL|typedef|pi_gfx_int_cntr_a_u_t
)brace
id|pi_gfx_int_cntr_a_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_gfx_int_cntr_a_u
r_typedef
r_union
id|pi_gfx_int_cntr_a_u
(brace
DECL|member|pi_gfx_int_cntr_a_regval
id|bdrkreg_t
id|pi_gfx_int_cntr_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|gica_rsvd
id|bdrkreg_t
id|gica_rsvd
suffix:colon
l_int|38
suffix:semicolon
DECL|member|gica_gfx_int_cntr
id|bdrkreg_t
id|gica_gfx_int_cntr
suffix:colon
l_int|26
suffix:semicolon
DECL|member|pi_gfx_int_cntr_a_fld_s
)brace
id|pi_gfx_int_cntr_a_fld_s
suffix:semicolon
DECL|typedef|pi_gfx_int_cntr_a_u_t
)brace
id|pi_gfx_int_cntr_a_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. The value in this     *&n; * register is loaded into the GFX_INT_CNTR register when an            *&n; * interrupt, NMI, or soft reset is sent to the processor. The value    *&n; * in this register is compared to the value of GFX_INT_CNTR and an     *&n; * interrupt is sent when they become equal.                            *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LINUX
DECL|union|pi_gfx_int_cmp_a_u
r_typedef
r_union
id|pi_gfx_int_cmp_a_u
(brace
DECL|member|pi_gfx_int_cmp_a_regval
id|bdrkreg_t
id|pi_gfx_int_cmp_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|gica_gfx_int_cmp
id|bdrkreg_t
id|gica_gfx_int_cmp
suffix:colon
l_int|26
suffix:semicolon
DECL|member|gica_rsvd
id|bdrkreg_t
id|gica_rsvd
suffix:colon
l_int|38
suffix:semicolon
DECL|member|pi_gfx_int_cmp_a_fld_s
)brace
id|pi_gfx_int_cmp_a_fld_s
suffix:semicolon
DECL|typedef|pi_gfx_int_cmp_a_u_t
)brace
id|pi_gfx_int_cmp_a_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_gfx_int_cmp_a_u
r_typedef
r_union
id|pi_gfx_int_cmp_a_u
(brace
DECL|member|pi_gfx_int_cmp_a_regval
id|bdrkreg_t
id|pi_gfx_int_cmp_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|gica_rsvd
id|bdrkreg_t
id|gica_rsvd
suffix:colon
l_int|38
suffix:semicolon
DECL|member|gica_gfx_int_cmp
id|bdrkreg_t
id|gica_gfx_int_cmp
suffix:colon
l_int|26
suffix:semicolon
DECL|member|pi_gfx_int_cmp_a_fld_s
)brace
id|pi_gfx_int_cmp_a_fld_s
suffix:semicolon
DECL|typedef|pi_gfx_int_cmp_a_u_t
)brace
id|pi_gfx_int_cmp_a_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. This register         *&n; * specifies the value of the Graphics Page. Uncached writes into the   *&n; * Graphics Page (with uncached attribute of IO) are done with GFXWS    *&n; * commands rather than the normal PWRI commands. GFXWS commands are    *&n; * tracked with the graphics credit counters.                           *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_gfx_page_b_u
r_typedef
r_union
id|pi_gfx_page_b_u
(brace
DECL|member|pi_gfx_page_b_regval
id|bdrkreg_t
id|pi_gfx_page_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|gpb_rsvd_1
id|bdrkreg_t
id|gpb_rsvd_1
suffix:colon
l_int|17
suffix:semicolon
DECL|member|gpb_gfx_page_addr
id|bdrkreg_t
id|gpb_gfx_page_addr
suffix:colon
l_int|23
suffix:semicolon
DECL|member|gpb_en_gfx_page
id|bdrkreg_t
id|gpb_en_gfx_page
suffix:colon
l_int|1
suffix:semicolon
DECL|member|gpb_rsvd
id|bdrkreg_t
id|gpb_rsvd
suffix:colon
l_int|23
suffix:semicolon
DECL|member|pi_gfx_page_b_fld_s
)brace
id|pi_gfx_page_b_fld_s
suffix:semicolon
DECL|typedef|pi_gfx_page_b_u_t
)brace
id|pi_gfx_page_b_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_gfx_page_b_u
r_typedef
r_union
id|pi_gfx_page_b_u
(brace
DECL|member|pi_gfx_page_b_regval
id|bdrkreg_t
id|pi_gfx_page_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|gpb_rsvd
id|bdrkreg_t
id|gpb_rsvd
suffix:colon
l_int|23
suffix:semicolon
DECL|member|gpb_en_gfx_page
id|bdrkreg_t
id|gpb_en_gfx_page
suffix:colon
l_int|1
suffix:semicolon
DECL|member|gpb_gfx_page_addr
id|bdrkreg_t
id|gpb_gfx_page_addr
suffix:colon
l_int|23
suffix:semicolon
DECL|member|gpb_rsvd_1
id|bdrkreg_t
id|gpb_rsvd_1
suffix:colon
l_int|17
suffix:semicolon
DECL|member|pi_gfx_page_b_fld_s
)brace
id|pi_gfx_page_b_fld_s
suffix:semicolon
DECL|typedef|pi_gfx_page_b_u_t
)brace
id|pi_gfx_page_b_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. This register         *&n; * counts graphics credits. This counter is decremented for each        *&n; * doubleword sent to graphics with GFXWS or GFXWL commands. It is      *&n; * incremented for each doubleword acknowledge from graphics. When      *&n; * this counter has a smaller value than the GFX_BIAS register,         *&n; * SysWrRdy_L is deasserted, an interrupt is sent to the processor,     *&n; * and SysWrRdy_L is allowed to be asserted again. This is the basic    *&n; * mechanism for flow-controlling graphics writes.                      *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_gfx_credit_cntr_b_u
r_typedef
r_union
id|pi_gfx_credit_cntr_b_u
(brace
DECL|member|pi_gfx_credit_cntr_b_regval
id|bdrkreg_t
id|pi_gfx_credit_cntr_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|gccb_gfx_credit_cntr
id|bdrkreg_t
id|gccb_gfx_credit_cntr
suffix:colon
l_int|12
suffix:semicolon
DECL|member|gccb_rsvd
id|bdrkreg_t
id|gccb_rsvd
suffix:colon
l_int|52
suffix:semicolon
DECL|member|pi_gfx_credit_cntr_b_fld_s
)brace
id|pi_gfx_credit_cntr_b_fld_s
suffix:semicolon
DECL|typedef|pi_gfx_credit_cntr_b_u_t
)brace
id|pi_gfx_credit_cntr_b_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_gfx_credit_cntr_b_u
r_typedef
r_union
id|pi_gfx_credit_cntr_b_u
(brace
DECL|member|pi_gfx_credit_cntr_b_regval
id|bdrkreg_t
id|pi_gfx_credit_cntr_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|gccb_rsvd
id|bdrkreg_t
id|gccb_rsvd
suffix:colon
l_int|52
suffix:semicolon
DECL|member|gccb_gfx_credit_cntr
id|bdrkreg_t
id|gccb_gfx_credit_cntr
suffix:colon
l_int|12
suffix:semicolon
DECL|member|pi_gfx_credit_cntr_b_fld_s
)brace
id|pi_gfx_credit_cntr_b_fld_s
suffix:semicolon
DECL|typedef|pi_gfx_credit_cntr_b_u_t
)brace
id|pi_gfx_credit_cntr_b_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. When the graphics     *&n; * credit counter is less than or equal to this value, a flow control   *&n; * interrupt is sent.                                                   *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_gfx_bias_b_u
r_typedef
r_union
id|pi_gfx_bias_b_u
(brace
DECL|member|pi_gfx_bias_b_regval
id|bdrkreg_t
id|pi_gfx_bias_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|gbb_gfx_bias
id|bdrkreg_t
id|gbb_gfx_bias
suffix:colon
l_int|12
suffix:semicolon
DECL|member|gbb_rsvd
id|bdrkreg_t
id|gbb_rsvd
suffix:colon
l_int|52
suffix:semicolon
DECL|member|pi_gfx_bias_b_fld_s
)brace
id|pi_gfx_bias_b_fld_s
suffix:semicolon
DECL|typedef|pi_gfx_bias_b_u_t
)brace
id|pi_gfx_bias_b_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_gfx_bias_b_u
r_typedef
r_union
id|pi_gfx_bias_b_u
(brace
DECL|member|pi_gfx_bias_b_regval
id|bdrkreg_t
id|pi_gfx_bias_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|gbb_rsvd
id|bdrkreg_t
id|gbb_rsvd
suffix:colon
l_int|52
suffix:semicolon
DECL|member|gbb_gfx_bias
id|bdrkreg_t
id|gbb_gfx_bias
suffix:colon
l_int|12
suffix:semicolon
DECL|member|pi_gfx_bias_b_fld_s
)brace
id|pi_gfx_bias_b_fld_s
suffix:semicolon
DECL|typedef|pi_gfx_bias_b_u_t
)brace
id|pi_gfx_bias_b_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; * Description:  There is one of these registers for each CPU. When     *&n; * this counter reaches the value of the GFX_INT_CMP register, an       *&n; * interrupt is sent to the associated processor. At each clock         *&n; * cycle, the value in this register can be changed by any one of the   *&n; * following actions:                                                   *&n; * - Written by software.                                               *&n; * - Loaded with the value of GFX_INT_CMP, when an interrupt, NMI, or   *&n; * soft reset occurs, thus preventing an additional interrupt.          *&n; * - Zeroed, when the GFX_CREDIT_CNTR rises above the bias value.       *&n; * - Incremented (by one at each clock) for each clock that the         *&n; * GFX_CREDIT_CNTR is less than or equal to zero.                       *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_gfx_int_cntr_b_u
r_typedef
r_union
id|pi_gfx_int_cntr_b_u
(brace
DECL|member|pi_gfx_int_cntr_b_regval
id|bdrkreg_t
id|pi_gfx_int_cntr_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|gicb_gfx_int_cntr
id|bdrkreg_t
id|gicb_gfx_int_cntr
suffix:colon
l_int|26
suffix:semicolon
DECL|member|gicb_rsvd
id|bdrkreg_t
id|gicb_rsvd
suffix:colon
l_int|38
suffix:semicolon
DECL|member|pi_gfx_int_cntr_b_fld_s
)brace
id|pi_gfx_int_cntr_b_fld_s
suffix:semicolon
DECL|typedef|pi_gfx_int_cntr_b_u_t
)brace
id|pi_gfx_int_cntr_b_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_gfx_int_cntr_b_u
r_typedef
r_union
id|pi_gfx_int_cntr_b_u
(brace
DECL|member|pi_gfx_int_cntr_b_regval
id|bdrkreg_t
id|pi_gfx_int_cntr_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|gicb_rsvd
id|bdrkreg_t
id|gicb_rsvd
suffix:colon
l_int|38
suffix:semicolon
DECL|member|gicb_gfx_int_cntr
id|bdrkreg_t
id|gicb_gfx_int_cntr
suffix:colon
l_int|26
suffix:semicolon
DECL|member|pi_gfx_int_cntr_b_fld_s
)brace
id|pi_gfx_int_cntr_b_fld_s
suffix:semicolon
DECL|typedef|pi_gfx_int_cntr_b_u_t
)brace
id|pi_gfx_int_cntr_b_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. The value in this     *&n; * register is loaded into the GFX_INT_CNTR register when an            *&n; * interrupt, NMI, or soft reset is sent to the processor. The value    *&n; * in this register is compared to the value of GFX_INT_CNTR and an     *&n; * interrupt is sent when they become equal.                            *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_gfx_int_cmp_b_u
r_typedef
r_union
id|pi_gfx_int_cmp_b_u
(brace
DECL|member|pi_gfx_int_cmp_b_regval
id|bdrkreg_t
id|pi_gfx_int_cmp_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|gicb_gfx_int_cmp
id|bdrkreg_t
id|gicb_gfx_int_cmp
suffix:colon
l_int|26
suffix:semicolon
DECL|member|gicb_rsvd
id|bdrkreg_t
id|gicb_rsvd
suffix:colon
l_int|38
suffix:semicolon
DECL|member|pi_gfx_int_cmp_b_fld_s
)brace
id|pi_gfx_int_cmp_b_fld_s
suffix:semicolon
DECL|typedef|pi_gfx_int_cmp_b_u_t
)brace
id|pi_gfx_int_cmp_b_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_gfx_int_cmp_b_u
r_typedef
r_union
id|pi_gfx_int_cmp_b_u
(brace
DECL|member|pi_gfx_int_cmp_b_regval
id|bdrkreg_t
id|pi_gfx_int_cmp_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|gicb_rsvd
id|bdrkreg_t
id|gicb_rsvd
suffix:colon
l_int|38
suffix:semicolon
DECL|member|gicb_gfx_int_cmp
id|bdrkreg_t
id|gicb_gfx_int_cmp
suffix:colon
l_int|26
suffix:semicolon
DECL|member|pi_gfx_int_cmp_b_fld_s
)brace
id|pi_gfx_int_cmp_b_fld_s
suffix:semicolon
DECL|typedef|pi_gfx_int_cmp_b_u_t
)brace
id|pi_gfx_int_cmp_b_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; * Description:  A read of this register returns all sources of         *&n; * Bedrock Error Interrupts. Storing to the write-with-clear location   *&n; * clears any bit for which a one appears on the data bus. Storing to   *&n; * the writable location does a direct write to all unreserved bits     *&n; * (except for MEM_UNC).                                                *&n; * In Synergy mode, the processor that is the source of the command     *&n; * that got an error is independent of the A or B SysAD bus. So in      *&n; * Synergy mode, Synergy provides the source processor number in bit    *&n; * 52 of the SysAD bus in all commands. The PI saves this in the RRB    *&n; * or WRB entry, and uses that value to determine which error bit (A    *&n; * or B) to set, as well as which ERR_STATUS and spool registers to     *&n; * use, for all error types in this register that are specified as an   *&n; * error to CPU_A or CPU_B.                                             *&n; * This register is not cleared at reset.                               *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_err_int_pend_wr_u
r_typedef
r_union
id|pi_err_int_pend_wr_u
(brace
DECL|member|pi_err_int_pend_wr_regval
id|bdrkreg_t
id|pi_err_int_pend_wr_regval
suffix:semicolon
r_struct
(brace
DECL|member|eipw_spool_comp_b
id|bdrkreg_t
id|eipw_spool_comp_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_spool_comp_a
id|bdrkreg_t
id|eipw_spool_comp_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_spurious_b
id|bdrkreg_t
id|eipw_spurious_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_spurious_a
id|bdrkreg_t
id|eipw_spurious_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_wrb_terr_b
id|bdrkreg_t
id|eipw_wrb_terr_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_wrb_terr_a
id|bdrkreg_t
id|eipw_wrb_terr_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_wrb_werr_b
id|bdrkreg_t
id|eipw_wrb_werr_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_wrb_werr_a
id|bdrkreg_t
id|eipw_wrb_werr_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_sysstate_par_b
id|bdrkreg_t
id|eipw_sysstate_par_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_sysstate_par_a
id|bdrkreg_t
id|eipw_sysstate_par_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_sysad_data_ecc_b
id|bdrkreg_t
id|eipw_sysad_data_ecc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_sysad_data_ecc_a
id|bdrkreg_t
id|eipw_sysad_data_ecc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_sysad_addr_ecc_b
id|bdrkreg_t
id|eipw_sysad_addr_ecc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_sysad_addr_ecc_a
id|bdrkreg_t
id|eipw_sysad_addr_ecc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_syscmd_data_par_b
id|bdrkreg_t
id|eipw_syscmd_data_par_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_syscmd_data_par_a
id|bdrkreg_t
id|eipw_syscmd_data_par_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_syscmd_addr_par_b
id|bdrkreg_t
id|eipw_syscmd_addr_par_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_syscmd_addr_par_a
id|bdrkreg_t
id|eipw_syscmd_addr_par_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_spool_err_b
id|bdrkreg_t
id|eipw_spool_err_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_spool_err_a
id|bdrkreg_t
id|eipw_spool_err_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_ue_uncached_b
id|bdrkreg_t
id|eipw_ue_uncached_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_ue_uncached_a
id|bdrkreg_t
id|eipw_ue_uncached_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_sysstate_tag_b
id|bdrkreg_t
id|eipw_sysstate_tag_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_sysstate_tag_a
id|bdrkreg_t
id|eipw_sysstate_tag_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_mem_unc
id|bdrkreg_t
id|eipw_mem_unc
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_sysad_bad_data_b
id|bdrkreg_t
id|eipw_sysad_bad_data_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_sysad_bad_data_a
id|bdrkreg_t
id|eipw_sysad_bad_data_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_ue_cached_b
id|bdrkreg_t
id|eipw_ue_cached_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_ue_cached_a
id|bdrkreg_t
id|eipw_ue_cached_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_pkt_len_err_b
id|bdrkreg_t
id|eipw_pkt_len_err_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_pkt_len_err_a
id|bdrkreg_t
id|eipw_pkt_len_err_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_irb_err_b
id|bdrkreg_t
id|eipw_irb_err_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_irb_err_a
id|bdrkreg_t
id|eipw_irb_err_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_irb_timeout_b
id|bdrkreg_t
id|eipw_irb_timeout_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_irb_timeout_a
id|bdrkreg_t
id|eipw_irb_timeout_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_rsvd
id|bdrkreg_t
id|eipw_rsvd
suffix:colon
l_int|29
suffix:semicolon
DECL|member|pi_err_int_pend_wr_fld_s
)brace
id|pi_err_int_pend_wr_fld_s
suffix:semicolon
DECL|typedef|pi_err_int_pend_wr_u_t
)brace
id|pi_err_int_pend_wr_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_err_int_pend_wr_u
r_typedef
r_union
id|pi_err_int_pend_wr_u
(brace
DECL|member|pi_err_int_pend_wr_regval
id|bdrkreg_t
id|pi_err_int_pend_wr_regval
suffix:semicolon
r_struct
(brace
DECL|member|eipw_rsvd
id|bdrkreg_t
id|eipw_rsvd
suffix:colon
l_int|29
suffix:semicolon
DECL|member|eipw_irb_timeout_a
id|bdrkreg_t
id|eipw_irb_timeout_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_irb_timeout_b
id|bdrkreg_t
id|eipw_irb_timeout_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_irb_err_a
id|bdrkreg_t
id|eipw_irb_err_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_irb_err_b
id|bdrkreg_t
id|eipw_irb_err_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_pkt_len_err_a
id|bdrkreg_t
id|eipw_pkt_len_err_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_pkt_len_err_b
id|bdrkreg_t
id|eipw_pkt_len_err_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_ue_cached_a
id|bdrkreg_t
id|eipw_ue_cached_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_ue_cached_b
id|bdrkreg_t
id|eipw_ue_cached_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_sysad_bad_data_a
id|bdrkreg_t
id|eipw_sysad_bad_data_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_sysad_bad_data_b
id|bdrkreg_t
id|eipw_sysad_bad_data_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_mem_unc
id|bdrkreg_t
id|eipw_mem_unc
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_sysstate_tag_a
id|bdrkreg_t
id|eipw_sysstate_tag_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_sysstate_tag_b
id|bdrkreg_t
id|eipw_sysstate_tag_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_ue_uncached_a
id|bdrkreg_t
id|eipw_ue_uncached_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_ue_uncached_b
id|bdrkreg_t
id|eipw_ue_uncached_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_spool_err_a
id|bdrkreg_t
id|eipw_spool_err_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_spool_err_b
id|bdrkreg_t
id|eipw_spool_err_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_syscmd_addr_par_a
id|bdrkreg_t
id|eipw_syscmd_addr_par_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_syscmd_addr_par_b
id|bdrkreg_t
id|eipw_syscmd_addr_par_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_syscmd_data_par_a
id|bdrkreg_t
id|eipw_syscmd_data_par_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_syscmd_data_par_b
id|bdrkreg_t
id|eipw_syscmd_data_par_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_sysad_addr_ecc_a
id|bdrkreg_t
id|eipw_sysad_addr_ecc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_sysad_addr_ecc_b
id|bdrkreg_t
id|eipw_sysad_addr_ecc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_sysad_data_ecc_a
id|bdrkreg_t
id|eipw_sysad_data_ecc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_sysad_data_ecc_b
id|bdrkreg_t
id|eipw_sysad_data_ecc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_sysstate_par_a
id|bdrkreg_t
id|eipw_sysstate_par_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_sysstate_par_b
id|bdrkreg_t
id|eipw_sysstate_par_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_wrb_werr_a
id|bdrkreg_t
id|eipw_wrb_werr_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_wrb_werr_b
id|bdrkreg_t
id|eipw_wrb_werr_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_wrb_terr_a
id|bdrkreg_t
id|eipw_wrb_terr_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_wrb_terr_b
id|bdrkreg_t
id|eipw_wrb_terr_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_spurious_a
id|bdrkreg_t
id|eipw_spurious_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_spurious_b
id|bdrkreg_t
id|eipw_spurious_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_spool_comp_a
id|bdrkreg_t
id|eipw_spool_comp_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eipw_spool_comp_b
id|bdrkreg_t
id|eipw_spool_comp_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_err_int_pend_wr_fld_s
)brace
id|pi_err_int_pend_wr_fld_s
suffix:semicolon
DECL|typedef|pi_err_int_pend_wr_u_t
)brace
id|pi_err_int_pend_wr_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; * Description:  A read of this register returns all sources of         *&n; * Bedrock Error Interrupts. Storing to the write-with-clear location   *&n; * clears any bit for which a one appears on the data bus. Storing to   *&n; * the writable location does a direct write to all unreserved bits     *&n; * (except for MEM_UNC).                                                *&n; * In Synergy mode, the processor that is the source of the command     *&n; * that got an error is independent of the A or B SysAD bus. So in      *&n; * Synergy mode, Synergy provides the source processor number in bit    *&n; * 52 of the SysAD bus in all commands. The PI saves this in the RRB    *&n; * or WRB entry, and uses that value to determine which error bit (A    *&n; * or B) to set, as well as which ERR_STATUS and spool registers to     *&n; * use, for all error types in this register that are specified as an   *&n; * error to CPU_A or CPU_B.                                             *&n; * This register is not cleared at reset.                               *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_err_int_pend_u
r_typedef
r_union
id|pi_err_int_pend_u
(brace
DECL|member|pi_err_int_pend_regval
id|bdrkreg_t
id|pi_err_int_pend_regval
suffix:semicolon
r_struct
(brace
DECL|member|eip_spool_comp_b
id|bdrkreg_t
id|eip_spool_comp_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_spool_comp_a
id|bdrkreg_t
id|eip_spool_comp_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_spurious_b
id|bdrkreg_t
id|eip_spurious_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_spurious_a
id|bdrkreg_t
id|eip_spurious_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_wrb_terr_b
id|bdrkreg_t
id|eip_wrb_terr_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_wrb_terr_a
id|bdrkreg_t
id|eip_wrb_terr_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_wrb_werr_b
id|bdrkreg_t
id|eip_wrb_werr_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_wrb_werr_a
id|bdrkreg_t
id|eip_wrb_werr_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_sysstate_par_b
id|bdrkreg_t
id|eip_sysstate_par_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_sysstate_par_a
id|bdrkreg_t
id|eip_sysstate_par_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_sysad_data_ecc_b
id|bdrkreg_t
id|eip_sysad_data_ecc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_sysad_data_ecc_a
id|bdrkreg_t
id|eip_sysad_data_ecc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_sysad_addr_ecc_b
id|bdrkreg_t
id|eip_sysad_addr_ecc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_sysad_addr_ecc_a
id|bdrkreg_t
id|eip_sysad_addr_ecc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_syscmd_data_par_b
id|bdrkreg_t
id|eip_syscmd_data_par_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_syscmd_data_par_a
id|bdrkreg_t
id|eip_syscmd_data_par_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_syscmd_addr_par_b
id|bdrkreg_t
id|eip_syscmd_addr_par_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_syscmd_addr_par_a
id|bdrkreg_t
id|eip_syscmd_addr_par_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_spool_err_b
id|bdrkreg_t
id|eip_spool_err_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_spool_err_a
id|bdrkreg_t
id|eip_spool_err_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_ue_uncached_b
id|bdrkreg_t
id|eip_ue_uncached_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_ue_uncached_a
id|bdrkreg_t
id|eip_ue_uncached_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_sysstate_tag_b
id|bdrkreg_t
id|eip_sysstate_tag_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_sysstate_tag_a
id|bdrkreg_t
id|eip_sysstate_tag_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_mem_unc
id|bdrkreg_t
id|eip_mem_unc
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_sysad_bad_data_b
id|bdrkreg_t
id|eip_sysad_bad_data_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_sysad_bad_data_a
id|bdrkreg_t
id|eip_sysad_bad_data_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_ue_cached_b
id|bdrkreg_t
id|eip_ue_cached_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_ue_cached_a
id|bdrkreg_t
id|eip_ue_cached_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_pkt_len_err_b
id|bdrkreg_t
id|eip_pkt_len_err_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_pkt_len_err_a
id|bdrkreg_t
id|eip_pkt_len_err_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_irb_err_b
id|bdrkreg_t
id|eip_irb_err_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_irb_err_a
id|bdrkreg_t
id|eip_irb_err_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_irb_timeout_b
id|bdrkreg_t
id|eip_irb_timeout_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_irb_timeout_a
id|bdrkreg_t
id|eip_irb_timeout_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_rsvd
id|bdrkreg_t
id|eip_rsvd
suffix:colon
l_int|29
suffix:semicolon
DECL|member|pi_err_int_pend_fld_s
)brace
id|pi_err_int_pend_fld_s
suffix:semicolon
DECL|typedef|pi_err_int_pend_u_t
)brace
id|pi_err_int_pend_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_err_int_pend_u
r_typedef
r_union
id|pi_err_int_pend_u
(brace
DECL|member|pi_err_int_pend_regval
id|bdrkreg_t
id|pi_err_int_pend_regval
suffix:semicolon
r_struct
(brace
DECL|member|eip_rsvd
id|bdrkreg_t
id|eip_rsvd
suffix:colon
l_int|29
suffix:semicolon
DECL|member|eip_irb_timeout_a
id|bdrkreg_t
id|eip_irb_timeout_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_irb_timeout_b
id|bdrkreg_t
id|eip_irb_timeout_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_irb_err_a
id|bdrkreg_t
id|eip_irb_err_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_irb_err_b
id|bdrkreg_t
id|eip_irb_err_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_pkt_len_err_a
id|bdrkreg_t
id|eip_pkt_len_err_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_pkt_len_err_b
id|bdrkreg_t
id|eip_pkt_len_err_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_ue_cached_a
id|bdrkreg_t
id|eip_ue_cached_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_ue_cached_b
id|bdrkreg_t
id|eip_ue_cached_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_sysad_bad_data_a
id|bdrkreg_t
id|eip_sysad_bad_data_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_sysad_bad_data_b
id|bdrkreg_t
id|eip_sysad_bad_data_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_mem_unc
id|bdrkreg_t
id|eip_mem_unc
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_sysstate_tag_a
id|bdrkreg_t
id|eip_sysstate_tag_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_sysstate_tag_b
id|bdrkreg_t
id|eip_sysstate_tag_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_ue_uncached_a
id|bdrkreg_t
id|eip_ue_uncached_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_ue_uncached_b
id|bdrkreg_t
id|eip_ue_uncached_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_spool_err_a
id|bdrkreg_t
id|eip_spool_err_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_spool_err_b
id|bdrkreg_t
id|eip_spool_err_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_syscmd_addr_par_a
id|bdrkreg_t
id|eip_syscmd_addr_par_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_syscmd_addr_par_b
id|bdrkreg_t
id|eip_syscmd_addr_par_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_syscmd_data_par_a
id|bdrkreg_t
id|eip_syscmd_data_par_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_syscmd_data_par_b
id|bdrkreg_t
id|eip_syscmd_data_par_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_sysad_addr_ecc_a
id|bdrkreg_t
id|eip_sysad_addr_ecc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_sysad_addr_ecc_b
id|bdrkreg_t
id|eip_sysad_addr_ecc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_sysad_data_ecc_a
id|bdrkreg_t
id|eip_sysad_data_ecc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_sysad_data_ecc_b
id|bdrkreg_t
id|eip_sysad_data_ecc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_sysstate_par_a
id|bdrkreg_t
id|eip_sysstate_par_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_sysstate_par_b
id|bdrkreg_t
id|eip_sysstate_par_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_wrb_werr_a
id|bdrkreg_t
id|eip_wrb_werr_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_wrb_werr_b
id|bdrkreg_t
id|eip_wrb_werr_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_wrb_terr_a
id|bdrkreg_t
id|eip_wrb_terr_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_wrb_terr_b
id|bdrkreg_t
id|eip_wrb_terr_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_spurious_a
id|bdrkreg_t
id|eip_spurious_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_spurious_b
id|bdrkreg_t
id|eip_spurious_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_spool_comp_a
id|bdrkreg_t
id|eip_spool_comp_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eip_spool_comp_b
id|bdrkreg_t
id|eip_spool_comp_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_err_int_pend_fld_s
)brace
id|pi_err_int_pend_fld_s
suffix:semicolon
DECL|typedef|pi_err_int_pend_u_t
)brace
id|pi_err_int_pend_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. This read/write       *&n; * register masks the contents of ERR_INT_PEND to determine which       *&n; * conditions cause a Level-6 interrupt to CPU_A or CPU_B. A bit set    *&n; * allows the interrupt. Only one processor in a Bedrock should         *&n; * enable the Memory/Directory Uncorrectable Error bit.                 *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_err_int_mask_a_u
r_typedef
r_union
id|pi_err_int_mask_a_u
(brace
DECL|member|pi_err_int_mask_a_regval
id|bdrkreg_t
id|pi_err_int_mask_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|eima_mask
id|bdrkreg_t
id|eima_mask
suffix:colon
l_int|35
suffix:semicolon
DECL|member|eima_rsvd
id|bdrkreg_t
id|eima_rsvd
suffix:colon
l_int|29
suffix:semicolon
DECL|member|pi_err_int_mask_a_fld_s
)brace
id|pi_err_int_mask_a_fld_s
suffix:semicolon
DECL|typedef|pi_err_int_mask_a_u_t
)brace
id|pi_err_int_mask_a_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_err_int_mask_a_u
r_typedef
r_union
id|pi_err_int_mask_a_u
(brace
DECL|member|pi_err_int_mask_a_regval
id|bdrkreg_t
id|pi_err_int_mask_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|eima_rsvd
id|bdrkreg_t
id|eima_rsvd
suffix:colon
l_int|29
suffix:semicolon
DECL|member|eima_mask
id|bdrkreg_t
id|eima_mask
suffix:colon
l_int|35
suffix:semicolon
DECL|member|pi_err_int_mask_a_fld_s
)brace
id|pi_err_int_mask_a_fld_s
suffix:semicolon
DECL|typedef|pi_err_int_mask_a_u_t
)brace
id|pi_err_int_mask_a_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. This read/write       *&n; * register masks the contents of ERR_INT_PEND to determine which       *&n; * conditions cause a Level-6 interrupt to CPU_A or CPU_B. A bit set    *&n; * allows the interrupt. Only one processor in a Bedrock should         *&n; * enable the Memory/Directory Uncorrectable Error bit.                 *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_err_int_mask_b_u
r_typedef
r_union
id|pi_err_int_mask_b_u
(brace
DECL|member|pi_err_int_mask_b_regval
id|bdrkreg_t
id|pi_err_int_mask_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|eimb_mask
id|bdrkreg_t
id|eimb_mask
suffix:colon
l_int|35
suffix:semicolon
DECL|member|eimb_rsvd
id|bdrkreg_t
id|eimb_rsvd
suffix:colon
l_int|29
suffix:semicolon
DECL|member|pi_err_int_mask_b_fld_s
)brace
id|pi_err_int_mask_b_fld_s
suffix:semicolon
DECL|typedef|pi_err_int_mask_b_u_t
)brace
id|pi_err_int_mask_b_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_err_int_mask_b_u
r_typedef
r_union
id|pi_err_int_mask_b_u
(brace
DECL|member|pi_err_int_mask_b_regval
id|bdrkreg_t
id|pi_err_int_mask_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|eimb_rsvd
id|bdrkreg_t
id|eimb_rsvd
suffix:colon
l_int|29
suffix:semicolon
DECL|member|eimb_mask
id|bdrkreg_t
id|eimb_mask
suffix:colon
l_int|35
suffix:semicolon
DECL|member|pi_err_int_mask_b_fld_s
)brace
id|pi_err_int_mask_b_fld_s
suffix:semicolon
DECL|typedef|pi_err_int_mask_b_u_t
)brace
id|pi_err_int_mask_b_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; * Description:  There is one of these registers for each CPU. This     *&n; * register is the address of the next write to the error stack. This   *&n; * register is incremented after each such write. Only the low N bits   *&n; * are incremented, where N is defined by the size of the error stack   *&n; * specified in the ERR_STACK_SIZE register.                            *&n; * This register is not reset by a soft reset.                          *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_err_stack_addr_a_u
r_typedef
r_union
id|pi_err_stack_addr_a_u
(brace
DECL|member|pi_err_stack_addr_a_regval
id|bdrkreg_t
id|pi_err_stack_addr_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|esaa_rsvd_1
id|bdrkreg_t
id|esaa_rsvd_1
suffix:colon
l_int|3
suffix:semicolon
DECL|member|esaa_addr
id|bdrkreg_t
id|esaa_addr
suffix:colon
l_int|30
suffix:semicolon
DECL|member|esaa_rsvd
id|bdrkreg_t
id|esaa_rsvd
suffix:colon
l_int|31
suffix:semicolon
DECL|member|pi_err_stack_addr_a_fld_s
)brace
id|pi_err_stack_addr_a_fld_s
suffix:semicolon
DECL|typedef|pi_err_stack_addr_a_u_t
)brace
id|pi_err_stack_addr_a_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_err_stack_addr_a_u
r_typedef
r_union
id|pi_err_stack_addr_a_u
(brace
DECL|member|pi_err_stack_addr_a_regval
id|bdrkreg_t
id|pi_err_stack_addr_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|esaa_rsvd
id|bdrkreg_t
id|esaa_rsvd
suffix:colon
l_int|31
suffix:semicolon
DECL|member|esaa_addr
id|bdrkreg_t
id|esaa_addr
suffix:colon
l_int|30
suffix:semicolon
DECL|member|esaa_rsvd_1
id|bdrkreg_t
id|esaa_rsvd_1
suffix:colon
l_int|3
suffix:semicolon
DECL|member|pi_err_stack_addr_a_fld_s
)brace
id|pi_err_stack_addr_a_fld_s
suffix:semicolon
DECL|typedef|pi_err_stack_addr_a_u_t
)brace
id|pi_err_stack_addr_a_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; * Description:  There is one of these registers for each CPU. This     *&n; * register is the address of the next write to the error stack. This   *&n; * register is incremented after each such write. Only the low N bits   *&n; * are incremented, where N is defined by the size of the error stack   *&n; * specified in the ERR_STACK_SIZE register.                            *&n; * This register is not reset by a soft reset.                          *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_err_stack_addr_b_u
r_typedef
r_union
id|pi_err_stack_addr_b_u
(brace
DECL|member|pi_err_stack_addr_b_regval
id|bdrkreg_t
id|pi_err_stack_addr_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|esab_rsvd_1
id|bdrkreg_t
id|esab_rsvd_1
suffix:colon
l_int|3
suffix:semicolon
DECL|member|esab_addr
id|bdrkreg_t
id|esab_addr
suffix:colon
l_int|30
suffix:semicolon
DECL|member|esab_rsvd
id|bdrkreg_t
id|esab_rsvd
suffix:colon
l_int|31
suffix:semicolon
DECL|member|pi_err_stack_addr_b_fld_s
)brace
id|pi_err_stack_addr_b_fld_s
suffix:semicolon
DECL|typedef|pi_err_stack_addr_b_u_t
)brace
id|pi_err_stack_addr_b_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_err_stack_addr_b_u
r_typedef
r_union
id|pi_err_stack_addr_b_u
(brace
DECL|member|pi_err_stack_addr_b_regval
id|bdrkreg_t
id|pi_err_stack_addr_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|esab_rsvd
id|bdrkreg_t
id|esab_rsvd
suffix:colon
l_int|31
suffix:semicolon
DECL|member|esab_addr
id|bdrkreg_t
id|esab_addr
suffix:colon
l_int|30
suffix:semicolon
DECL|member|esab_rsvd_1
id|bdrkreg_t
id|esab_rsvd_1
suffix:colon
l_int|3
suffix:semicolon
DECL|member|pi_err_stack_addr_b_fld_s
)brace
id|pi_err_stack_addr_b_fld_s
suffix:semicolon
DECL|typedef|pi_err_stack_addr_b_u_t
)brace
id|pi_err_stack_addr_b_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; * Description:  Sets the size (number of 64-bit entries) in the        *&n; * error stack that is spooled to local memory when an error occurs.    *&n; * Table16 defines the format of each entry in the spooled error        *&n; * stack.                                                               *&n; * This register is not reset by a soft reset.                          *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_err_stack_size_u
r_typedef
r_union
id|pi_err_stack_size_u
(brace
DECL|member|pi_err_stack_size_regval
id|bdrkreg_t
id|pi_err_stack_size_regval
suffix:semicolon
r_struct
(brace
DECL|member|ess_size
id|bdrkreg_t
id|ess_size
suffix:colon
l_int|4
suffix:semicolon
DECL|member|ess_rsvd
id|bdrkreg_t
id|ess_rsvd
suffix:colon
l_int|60
suffix:semicolon
DECL|member|pi_err_stack_size_fld_s
)brace
id|pi_err_stack_size_fld_s
suffix:semicolon
DECL|typedef|pi_err_stack_size_u_t
)brace
id|pi_err_stack_size_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_err_stack_size_u
r_typedef
r_union
id|pi_err_stack_size_u
(brace
DECL|member|pi_err_stack_size_regval
id|bdrkreg_t
id|pi_err_stack_size_regval
suffix:semicolon
r_struct
(brace
DECL|member|ess_rsvd
id|bdrkreg_t
id|ess_rsvd
suffix:colon
l_int|60
suffix:semicolon
DECL|member|ess_size
id|bdrkreg_t
id|ess_size
suffix:colon
l_int|4
suffix:semicolon
DECL|member|pi_err_stack_size_fld_s
)brace
id|pi_err_stack_size_fld_s
suffix:semicolon
DECL|typedef|pi_err_stack_size_u_t
)brace
id|pi_err_stack_size_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register is not cleared at reset. Writing this register with   *&n; * the Write-clear address (with any data) clears both the              *&n; * ERR_STATUS0_A and ERR_STATUS1_A registers.                           *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_err_status0_a_u
r_typedef
r_union
id|pi_err_status0_a_u
(brace
DECL|member|pi_err_status0_a_regval
id|bdrkreg_t
id|pi_err_status0_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|esa_error_type
id|bdrkreg_t
id|esa_error_type
suffix:colon
l_int|3
suffix:semicolon
DECL|member|esa_proc_req_num
id|bdrkreg_t
id|esa_proc_req_num
suffix:colon
l_int|3
suffix:semicolon
DECL|member|esa_supplemental
id|bdrkreg_t
id|esa_supplemental
suffix:colon
l_int|11
suffix:semicolon
DECL|member|esa_cmd
id|bdrkreg_t
id|esa_cmd
suffix:colon
l_int|8
suffix:semicolon
DECL|member|esa_addr
id|bdrkreg_t
id|esa_addr
suffix:colon
l_int|37
suffix:semicolon
DECL|member|esa_over_run
id|bdrkreg_t
id|esa_over_run
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esa_valid
id|bdrkreg_t
id|esa_valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_err_status0_a_fld_s
)brace
id|pi_err_status0_a_fld_s
suffix:semicolon
DECL|typedef|pi_err_status0_a_u_t
)brace
id|pi_err_status0_a_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_err_status0_a_u
r_typedef
r_union
id|pi_err_status0_a_u
(brace
DECL|member|pi_err_status0_a_regval
id|bdrkreg_t
id|pi_err_status0_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|esa_valid
id|bdrkreg_t
id|esa_valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esa_over_run
id|bdrkreg_t
id|esa_over_run
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esa_addr
id|bdrkreg_t
id|esa_addr
suffix:colon
l_int|37
suffix:semicolon
DECL|member|esa_cmd
id|bdrkreg_t
id|esa_cmd
suffix:colon
l_int|8
suffix:semicolon
DECL|member|esa_supplemental
id|bdrkreg_t
id|esa_supplemental
suffix:colon
l_int|11
suffix:semicolon
DECL|member|esa_proc_req_num
id|bdrkreg_t
id|esa_proc_req_num
suffix:colon
l_int|3
suffix:semicolon
DECL|member|esa_error_type
id|bdrkreg_t
id|esa_error_type
suffix:colon
l_int|3
suffix:semicolon
DECL|member|pi_err_status0_a_fld_s
)brace
id|pi_err_status0_a_fld_s
suffix:semicolon
DECL|typedef|pi_err_status0_a_u_t
)brace
id|pi_err_status0_a_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register is not cleared at reset. Writing this register with   *&n; * the Write-clear address (with any data) clears both the              *&n; * ERR_STATUS0_A and ERR_STATUS1_A registers.                           *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_err_status0_a_clr_u
r_typedef
r_union
id|pi_err_status0_a_clr_u
(brace
DECL|member|pi_err_status0_a_clr_regval
id|bdrkreg_t
id|pi_err_status0_a_clr_regval
suffix:semicolon
r_struct
(brace
DECL|member|esac_error_type
id|bdrkreg_t
id|esac_error_type
suffix:colon
l_int|3
suffix:semicolon
DECL|member|esac_proc_req_num
id|bdrkreg_t
id|esac_proc_req_num
suffix:colon
l_int|3
suffix:semicolon
DECL|member|esac_supplemental
id|bdrkreg_t
id|esac_supplemental
suffix:colon
l_int|11
suffix:semicolon
DECL|member|esac_cmd
id|bdrkreg_t
id|esac_cmd
suffix:colon
l_int|8
suffix:semicolon
DECL|member|esac_addr
id|bdrkreg_t
id|esac_addr
suffix:colon
l_int|37
suffix:semicolon
DECL|member|esac_over_run
id|bdrkreg_t
id|esac_over_run
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esac_valid
id|bdrkreg_t
id|esac_valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_err_status0_a_clr_fld_s
)brace
id|pi_err_status0_a_clr_fld_s
suffix:semicolon
DECL|typedef|pi_err_status0_a_clr_u_t
)brace
id|pi_err_status0_a_clr_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_err_status0_a_clr_u
r_typedef
r_union
id|pi_err_status0_a_clr_u
(brace
DECL|member|pi_err_status0_a_clr_regval
id|bdrkreg_t
id|pi_err_status0_a_clr_regval
suffix:semicolon
r_struct
(brace
DECL|member|esac_valid
id|bdrkreg_t
id|esac_valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esac_over_run
id|bdrkreg_t
id|esac_over_run
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esac_addr
id|bdrkreg_t
id|esac_addr
suffix:colon
l_int|37
suffix:semicolon
DECL|member|esac_cmd
id|bdrkreg_t
id|esac_cmd
suffix:colon
l_int|8
suffix:semicolon
DECL|member|esac_supplemental
id|bdrkreg_t
id|esac_supplemental
suffix:colon
l_int|11
suffix:semicolon
DECL|member|esac_proc_req_num
id|bdrkreg_t
id|esac_proc_req_num
suffix:colon
l_int|3
suffix:semicolon
DECL|member|esac_error_type
id|bdrkreg_t
id|esac_error_type
suffix:colon
l_int|3
suffix:semicolon
DECL|member|pi_err_status0_a_clr_fld_s
)brace
id|pi_err_status0_a_clr_fld_s
suffix:semicolon
DECL|typedef|pi_err_status0_a_clr_u_t
)brace
id|pi_err_status0_a_clr_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register is not cleared at reset. Writing this register with   *&n; * the Write-clear address (with any data) clears both the              *&n; * ERR_STATUS0_A and ERR_STATUS1_A registers.                           *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_err_status1_a_u
r_typedef
r_union
id|pi_err_status1_a_u
(brace
DECL|member|pi_err_status1_a_regval
id|bdrkreg_t
id|pi_err_status1_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|esa_spool_count
id|bdrkreg_t
id|esa_spool_count
suffix:colon
l_int|21
suffix:semicolon
DECL|member|esa_time_out_count
id|bdrkreg_t
id|esa_time_out_count
suffix:colon
l_int|8
suffix:semicolon
DECL|member|esa_inval_count
id|bdrkreg_t
id|esa_inval_count
suffix:colon
l_int|10
suffix:semicolon
DECL|member|esa_crb_num
id|bdrkreg_t
id|esa_crb_num
suffix:colon
l_int|3
suffix:semicolon
DECL|member|esa_wrb
id|bdrkreg_t
id|esa_wrb
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esa_e_bits
id|bdrkreg_t
id|esa_e_bits
suffix:colon
l_int|2
suffix:semicolon
DECL|member|esa_t_bit
id|bdrkreg_t
id|esa_t_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esa_i_bit
id|bdrkreg_t
id|esa_i_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esa_h_bit
id|bdrkreg_t
id|esa_h_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esa_w_bit
id|bdrkreg_t
id|esa_w_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esa_a_bit
id|bdrkreg_t
id|esa_a_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esa_r_bit
id|bdrkreg_t
id|esa_r_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esa_v_bit
id|bdrkreg_t
id|esa_v_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esa_p_bit
id|bdrkreg_t
id|esa_p_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esa_source
id|bdrkreg_t
id|esa_source
suffix:colon
l_int|11
suffix:semicolon
DECL|member|pi_err_status1_a_fld_s
)brace
id|pi_err_status1_a_fld_s
suffix:semicolon
DECL|typedef|pi_err_status1_a_u_t
)brace
id|pi_err_status1_a_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_err_status1_a_u
r_typedef
r_union
id|pi_err_status1_a_u
(brace
DECL|member|pi_err_status1_a_regval
id|bdrkreg_t
id|pi_err_status1_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|esa_source
id|bdrkreg_t
id|esa_source
suffix:colon
l_int|11
suffix:semicolon
DECL|member|esa_p_bit
id|bdrkreg_t
id|esa_p_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esa_v_bit
id|bdrkreg_t
id|esa_v_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esa_r_bit
id|bdrkreg_t
id|esa_r_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esa_a_bit
id|bdrkreg_t
id|esa_a_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esa_w_bit
id|bdrkreg_t
id|esa_w_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esa_h_bit
id|bdrkreg_t
id|esa_h_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esa_i_bit
id|bdrkreg_t
id|esa_i_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esa_t_bit
id|bdrkreg_t
id|esa_t_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esa_e_bits
id|bdrkreg_t
id|esa_e_bits
suffix:colon
l_int|2
suffix:semicolon
DECL|member|esa_wrb
id|bdrkreg_t
id|esa_wrb
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esa_crb_num
id|bdrkreg_t
id|esa_crb_num
suffix:colon
l_int|3
suffix:semicolon
DECL|member|esa_inval_count
id|bdrkreg_t
id|esa_inval_count
suffix:colon
l_int|10
suffix:semicolon
DECL|member|esa_time_out_count
id|bdrkreg_t
id|esa_time_out_count
suffix:colon
l_int|8
suffix:semicolon
DECL|member|esa_spool_count
id|bdrkreg_t
id|esa_spool_count
suffix:colon
l_int|21
suffix:semicolon
DECL|member|pi_err_status1_a_fld_s
)brace
id|pi_err_status1_a_fld_s
suffix:semicolon
DECL|typedef|pi_err_status1_a_u_t
)brace
id|pi_err_status1_a_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register is not cleared at reset. Writing this register with   *&n; * the Write-clear address (with any data) clears both the              *&n; * ERR_STATUS0_A and ERR_STATUS1_A registers.                           *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_err_status1_a_clr_u
r_typedef
r_union
id|pi_err_status1_a_clr_u
(brace
DECL|member|pi_err_status1_a_clr_regval
id|bdrkreg_t
id|pi_err_status1_a_clr_regval
suffix:semicolon
r_struct
(brace
DECL|member|esac_spool_count
id|bdrkreg_t
id|esac_spool_count
suffix:colon
l_int|21
suffix:semicolon
DECL|member|esac_time_out_count
id|bdrkreg_t
id|esac_time_out_count
suffix:colon
l_int|8
suffix:semicolon
DECL|member|esac_inval_count
id|bdrkreg_t
id|esac_inval_count
suffix:colon
l_int|10
suffix:semicolon
DECL|member|esac_crb_num
id|bdrkreg_t
id|esac_crb_num
suffix:colon
l_int|3
suffix:semicolon
DECL|member|esac_wrb
id|bdrkreg_t
id|esac_wrb
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esac_e_bits
id|bdrkreg_t
id|esac_e_bits
suffix:colon
l_int|2
suffix:semicolon
DECL|member|esac_t_bit
id|bdrkreg_t
id|esac_t_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esac_i_bit
id|bdrkreg_t
id|esac_i_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esac_h_bit
id|bdrkreg_t
id|esac_h_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esac_w_bit
id|bdrkreg_t
id|esac_w_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esac_a_bit
id|bdrkreg_t
id|esac_a_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esac_r_bit
id|bdrkreg_t
id|esac_r_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esac_v_bit
id|bdrkreg_t
id|esac_v_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esac_p_bit
id|bdrkreg_t
id|esac_p_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esac_source
id|bdrkreg_t
id|esac_source
suffix:colon
l_int|11
suffix:semicolon
DECL|member|pi_err_status1_a_clr_fld_s
)brace
id|pi_err_status1_a_clr_fld_s
suffix:semicolon
DECL|typedef|pi_err_status1_a_clr_u_t
)brace
id|pi_err_status1_a_clr_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_err_status1_a_clr_u
r_typedef
r_union
id|pi_err_status1_a_clr_u
(brace
DECL|member|pi_err_status1_a_clr_regval
id|bdrkreg_t
id|pi_err_status1_a_clr_regval
suffix:semicolon
r_struct
(brace
DECL|member|esac_source
id|bdrkreg_t
id|esac_source
suffix:colon
l_int|11
suffix:semicolon
DECL|member|esac_p_bit
id|bdrkreg_t
id|esac_p_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esac_v_bit
id|bdrkreg_t
id|esac_v_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esac_r_bit
id|bdrkreg_t
id|esac_r_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esac_a_bit
id|bdrkreg_t
id|esac_a_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esac_w_bit
id|bdrkreg_t
id|esac_w_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esac_h_bit
id|bdrkreg_t
id|esac_h_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esac_i_bit
id|bdrkreg_t
id|esac_i_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esac_t_bit
id|bdrkreg_t
id|esac_t_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esac_e_bits
id|bdrkreg_t
id|esac_e_bits
suffix:colon
l_int|2
suffix:semicolon
DECL|member|esac_wrb
id|bdrkreg_t
id|esac_wrb
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esac_crb_num
id|bdrkreg_t
id|esac_crb_num
suffix:colon
l_int|3
suffix:semicolon
DECL|member|esac_inval_count
id|bdrkreg_t
id|esac_inval_count
suffix:colon
l_int|10
suffix:semicolon
DECL|member|esac_time_out_count
id|bdrkreg_t
id|esac_time_out_count
suffix:colon
l_int|8
suffix:semicolon
DECL|member|esac_spool_count
id|bdrkreg_t
id|esac_spool_count
suffix:colon
l_int|21
suffix:semicolon
DECL|member|pi_err_status1_a_clr_fld_s
)brace
id|pi_err_status1_a_clr_fld_s
suffix:semicolon
DECL|typedef|pi_err_status1_a_clr_u_t
)brace
id|pi_err_status1_a_clr_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register is not cleared at reset. Writing this register with   *&n; * the Write-clear address (with any data) clears both the              *&n; * ERR_STATUS0_B and ERR_STATUS1_B registers.                           *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_err_status0_b_u
r_typedef
r_union
id|pi_err_status0_b_u
(brace
DECL|member|pi_err_status0_b_regval
id|bdrkreg_t
id|pi_err_status0_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|esb_error_type
id|bdrkreg_t
id|esb_error_type
suffix:colon
l_int|3
suffix:semicolon
DECL|member|esb_proc_request_number
id|bdrkreg_t
id|esb_proc_request_number
suffix:colon
l_int|3
suffix:semicolon
DECL|member|esb_supplemental
id|bdrkreg_t
id|esb_supplemental
suffix:colon
l_int|11
suffix:semicolon
DECL|member|esb_cmd
id|bdrkreg_t
id|esb_cmd
suffix:colon
l_int|8
suffix:semicolon
DECL|member|esb_addr
id|bdrkreg_t
id|esb_addr
suffix:colon
l_int|37
suffix:semicolon
DECL|member|esb_over_run
id|bdrkreg_t
id|esb_over_run
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esb_valid
id|bdrkreg_t
id|esb_valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_err_status0_b_fld_s
)brace
id|pi_err_status0_b_fld_s
suffix:semicolon
DECL|typedef|pi_err_status0_b_u_t
)brace
id|pi_err_status0_b_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_err_status0_b_u
r_typedef
r_union
id|pi_err_status0_b_u
(brace
DECL|member|pi_err_status0_b_regval
id|bdrkreg_t
id|pi_err_status0_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|esb_valid
id|bdrkreg_t
id|esb_valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esb_over_run
id|bdrkreg_t
id|esb_over_run
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esb_addr
id|bdrkreg_t
id|esb_addr
suffix:colon
l_int|37
suffix:semicolon
DECL|member|esb_cmd
id|bdrkreg_t
id|esb_cmd
suffix:colon
l_int|8
suffix:semicolon
DECL|member|esb_supplemental
id|bdrkreg_t
id|esb_supplemental
suffix:colon
l_int|11
suffix:semicolon
DECL|member|esb_proc_request_number
id|bdrkreg_t
id|esb_proc_request_number
suffix:colon
l_int|3
suffix:semicolon
DECL|member|esb_error_type
id|bdrkreg_t
id|esb_error_type
suffix:colon
l_int|3
suffix:semicolon
DECL|member|pi_err_status0_b_fld_s
)brace
id|pi_err_status0_b_fld_s
suffix:semicolon
DECL|typedef|pi_err_status0_b_u_t
)brace
id|pi_err_status0_b_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register is not cleared at reset. Writing this register with   *&n; * the Write-clear address (with any data) clears both the              *&n; * ERR_STATUS0_B and ERR_STATUS1_B registers.                           *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_err_status0_b_clr_u
r_typedef
r_union
id|pi_err_status0_b_clr_u
(brace
DECL|member|pi_err_status0_b_clr_regval
id|bdrkreg_t
id|pi_err_status0_b_clr_regval
suffix:semicolon
r_struct
(brace
DECL|member|esbc_error_type
id|bdrkreg_t
id|esbc_error_type
suffix:colon
l_int|3
suffix:semicolon
DECL|member|esbc_proc_request_number
id|bdrkreg_t
id|esbc_proc_request_number
suffix:colon
l_int|3
suffix:semicolon
DECL|member|esbc_supplemental
id|bdrkreg_t
id|esbc_supplemental
suffix:colon
l_int|11
suffix:semicolon
DECL|member|esbc_cmd
id|bdrkreg_t
id|esbc_cmd
suffix:colon
l_int|8
suffix:semicolon
DECL|member|esbc_addr
id|bdrkreg_t
id|esbc_addr
suffix:colon
l_int|37
suffix:semicolon
DECL|member|esbc_over_run
id|bdrkreg_t
id|esbc_over_run
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esbc_valid
id|bdrkreg_t
id|esbc_valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_err_status0_b_clr_fld_s
)brace
id|pi_err_status0_b_clr_fld_s
suffix:semicolon
DECL|typedef|pi_err_status0_b_clr_u_t
)brace
id|pi_err_status0_b_clr_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_err_status0_b_clr_u
r_typedef
r_union
id|pi_err_status0_b_clr_u
(brace
DECL|member|pi_err_status0_b_clr_regval
id|bdrkreg_t
id|pi_err_status0_b_clr_regval
suffix:semicolon
r_struct
(brace
DECL|member|esbc_valid
id|bdrkreg_t
id|esbc_valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esbc_over_run
id|bdrkreg_t
id|esbc_over_run
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esbc_addr
id|bdrkreg_t
id|esbc_addr
suffix:colon
l_int|37
suffix:semicolon
DECL|member|esbc_cmd
id|bdrkreg_t
id|esbc_cmd
suffix:colon
l_int|8
suffix:semicolon
DECL|member|esbc_supplemental
id|bdrkreg_t
id|esbc_supplemental
suffix:colon
l_int|11
suffix:semicolon
DECL|member|esbc_proc_request_number
id|bdrkreg_t
id|esbc_proc_request_number
suffix:colon
l_int|3
suffix:semicolon
DECL|member|esbc_error_type
id|bdrkreg_t
id|esbc_error_type
suffix:colon
l_int|3
suffix:semicolon
DECL|member|pi_err_status0_b_clr_fld_s
)brace
id|pi_err_status0_b_clr_fld_s
suffix:semicolon
DECL|typedef|pi_err_status0_b_clr_u_t
)brace
id|pi_err_status0_b_clr_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register is not cleared at reset. Writing this register with   *&n; * the Write-clear address (with any data) clears both the              *&n; * ERR_STATUS0_B and ERR_STATUS1_B registers.                           *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_err_status1_b_u
r_typedef
r_union
id|pi_err_status1_b_u
(brace
DECL|member|pi_err_status1_b_regval
id|bdrkreg_t
id|pi_err_status1_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|esb_spool_count
id|bdrkreg_t
id|esb_spool_count
suffix:colon
l_int|21
suffix:semicolon
DECL|member|esb_time_out_count
id|bdrkreg_t
id|esb_time_out_count
suffix:colon
l_int|8
suffix:semicolon
DECL|member|esb_inval_count
id|bdrkreg_t
id|esb_inval_count
suffix:colon
l_int|10
suffix:semicolon
DECL|member|esb_crb_num
id|bdrkreg_t
id|esb_crb_num
suffix:colon
l_int|3
suffix:semicolon
DECL|member|esb_wrb
id|bdrkreg_t
id|esb_wrb
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esb_e_bits
id|bdrkreg_t
id|esb_e_bits
suffix:colon
l_int|2
suffix:semicolon
DECL|member|esb_t_bit
id|bdrkreg_t
id|esb_t_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esb_i_bit
id|bdrkreg_t
id|esb_i_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esb_h_bit
id|bdrkreg_t
id|esb_h_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esb_w_bit
id|bdrkreg_t
id|esb_w_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esb_a_bit
id|bdrkreg_t
id|esb_a_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esb_r_bit
id|bdrkreg_t
id|esb_r_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esb_v_bit
id|bdrkreg_t
id|esb_v_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esb_p_bit
id|bdrkreg_t
id|esb_p_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esb_source
id|bdrkreg_t
id|esb_source
suffix:colon
l_int|11
suffix:semicolon
DECL|member|pi_err_status1_b_fld_s
)brace
id|pi_err_status1_b_fld_s
suffix:semicolon
DECL|typedef|pi_err_status1_b_u_t
)brace
id|pi_err_status1_b_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_err_status1_b_u
r_typedef
r_union
id|pi_err_status1_b_u
(brace
DECL|member|pi_err_status1_b_regval
id|bdrkreg_t
id|pi_err_status1_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|esb_source
id|bdrkreg_t
id|esb_source
suffix:colon
l_int|11
suffix:semicolon
DECL|member|esb_p_bit
id|bdrkreg_t
id|esb_p_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esb_v_bit
id|bdrkreg_t
id|esb_v_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esb_r_bit
id|bdrkreg_t
id|esb_r_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esb_a_bit
id|bdrkreg_t
id|esb_a_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esb_w_bit
id|bdrkreg_t
id|esb_w_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esb_h_bit
id|bdrkreg_t
id|esb_h_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esb_i_bit
id|bdrkreg_t
id|esb_i_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esb_t_bit
id|bdrkreg_t
id|esb_t_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esb_e_bits
id|bdrkreg_t
id|esb_e_bits
suffix:colon
l_int|2
suffix:semicolon
DECL|member|esb_wrb
id|bdrkreg_t
id|esb_wrb
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esb_crb_num
id|bdrkreg_t
id|esb_crb_num
suffix:colon
l_int|3
suffix:semicolon
DECL|member|esb_inval_count
id|bdrkreg_t
id|esb_inval_count
suffix:colon
l_int|10
suffix:semicolon
DECL|member|esb_time_out_count
id|bdrkreg_t
id|esb_time_out_count
suffix:colon
l_int|8
suffix:semicolon
DECL|member|esb_spool_count
id|bdrkreg_t
id|esb_spool_count
suffix:colon
l_int|21
suffix:semicolon
DECL|member|pi_err_status1_b_fld_s
)brace
id|pi_err_status1_b_fld_s
suffix:semicolon
DECL|typedef|pi_err_status1_b_u_t
)brace
id|pi_err_status1_b_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register is not cleared at reset. Writing this register with   *&n; * the Write-clear address (with any data) clears both the              *&n; * ERR_STATUS0_B and ERR_STATUS1_B registers.                           *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_err_status1_b_clr_u
r_typedef
r_union
id|pi_err_status1_b_clr_u
(brace
DECL|member|pi_err_status1_b_clr_regval
id|bdrkreg_t
id|pi_err_status1_b_clr_regval
suffix:semicolon
r_struct
(brace
DECL|member|esbc_spool_count
id|bdrkreg_t
id|esbc_spool_count
suffix:colon
l_int|21
suffix:semicolon
DECL|member|esbc_time_out_count
id|bdrkreg_t
id|esbc_time_out_count
suffix:colon
l_int|8
suffix:semicolon
DECL|member|esbc_inval_count
id|bdrkreg_t
id|esbc_inval_count
suffix:colon
l_int|10
suffix:semicolon
DECL|member|esbc_crb_num
id|bdrkreg_t
id|esbc_crb_num
suffix:colon
l_int|3
suffix:semicolon
DECL|member|esbc_wrb
id|bdrkreg_t
id|esbc_wrb
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esbc_e_bits
id|bdrkreg_t
id|esbc_e_bits
suffix:colon
l_int|2
suffix:semicolon
DECL|member|esbc_t_bit
id|bdrkreg_t
id|esbc_t_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esbc_i_bit
id|bdrkreg_t
id|esbc_i_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esbc_h_bit
id|bdrkreg_t
id|esbc_h_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esbc_w_bit
id|bdrkreg_t
id|esbc_w_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esbc_a_bit
id|bdrkreg_t
id|esbc_a_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esbc_r_bit
id|bdrkreg_t
id|esbc_r_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esbc_v_bit
id|bdrkreg_t
id|esbc_v_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esbc_p_bit
id|bdrkreg_t
id|esbc_p_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esbc_source
id|bdrkreg_t
id|esbc_source
suffix:colon
l_int|11
suffix:semicolon
DECL|member|pi_err_status1_b_clr_fld_s
)brace
id|pi_err_status1_b_clr_fld_s
suffix:semicolon
DECL|typedef|pi_err_status1_b_clr_u_t
)brace
id|pi_err_status1_b_clr_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_err_status1_b_clr_u
r_typedef
r_union
id|pi_err_status1_b_clr_u
(brace
DECL|member|pi_err_status1_b_clr_regval
id|bdrkreg_t
id|pi_err_status1_b_clr_regval
suffix:semicolon
r_struct
(brace
DECL|member|esbc_source
id|bdrkreg_t
id|esbc_source
suffix:colon
l_int|11
suffix:semicolon
DECL|member|esbc_p_bit
id|bdrkreg_t
id|esbc_p_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esbc_v_bit
id|bdrkreg_t
id|esbc_v_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esbc_r_bit
id|bdrkreg_t
id|esbc_r_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esbc_a_bit
id|bdrkreg_t
id|esbc_a_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esbc_w_bit
id|bdrkreg_t
id|esbc_w_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esbc_h_bit
id|bdrkreg_t
id|esbc_h_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esbc_i_bit
id|bdrkreg_t
id|esbc_i_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esbc_t_bit
id|bdrkreg_t
id|esbc_t_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esbc_e_bits
id|bdrkreg_t
id|esbc_e_bits
suffix:colon
l_int|2
suffix:semicolon
DECL|member|esbc_wrb
id|bdrkreg_t
id|esbc_wrb
suffix:colon
l_int|1
suffix:semicolon
DECL|member|esbc_crb_num
id|bdrkreg_t
id|esbc_crb_num
suffix:colon
l_int|3
suffix:semicolon
DECL|member|esbc_inval_count
id|bdrkreg_t
id|esbc_inval_count
suffix:colon
l_int|10
suffix:semicolon
DECL|member|esbc_time_out_count
id|bdrkreg_t
id|esbc_time_out_count
suffix:colon
l_int|8
suffix:semicolon
DECL|member|esbc_spool_count
id|bdrkreg_t
id|esbc_spool_count
suffix:colon
l_int|21
suffix:semicolon
DECL|member|pi_err_status1_b_clr_fld_s
)brace
id|pi_err_status1_b_clr_fld_s
suffix:semicolon
DECL|typedef|pi_err_status1_b_clr_u_t
)brace
id|pi_err_status1_b_clr_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU.                       *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_spool_cmp_a_u
r_typedef
r_union
id|pi_spool_cmp_a_u
(brace
DECL|member|pi_spool_cmp_a_regval
id|bdrkreg_t
id|pi_spool_cmp_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|sca_compare
id|bdrkreg_t
id|sca_compare
suffix:colon
l_int|20
suffix:semicolon
DECL|member|sca_rsvd
id|bdrkreg_t
id|sca_rsvd
suffix:colon
l_int|44
suffix:semicolon
DECL|member|pi_spool_cmp_a_fld_s
)brace
id|pi_spool_cmp_a_fld_s
suffix:semicolon
DECL|typedef|pi_spool_cmp_a_u_t
)brace
id|pi_spool_cmp_a_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_spool_cmp_a_u
r_typedef
r_union
id|pi_spool_cmp_a_u
(brace
DECL|member|pi_spool_cmp_a_regval
id|bdrkreg_t
id|pi_spool_cmp_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|sca_rsvd
id|bdrkreg_t
id|sca_rsvd
suffix:colon
l_int|44
suffix:semicolon
DECL|member|sca_compare
id|bdrkreg_t
id|sca_compare
suffix:colon
l_int|20
suffix:semicolon
DECL|member|pi_spool_cmp_a_fld_s
)brace
id|pi_spool_cmp_a_fld_s
suffix:semicolon
DECL|typedef|pi_spool_cmp_a_u_t
)brace
id|pi_spool_cmp_a_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU.                       *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_spool_cmp_b_u
r_typedef
r_union
id|pi_spool_cmp_b_u
(brace
DECL|member|pi_spool_cmp_b_regval
id|bdrkreg_t
id|pi_spool_cmp_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|scb_compare
id|bdrkreg_t
id|scb_compare
suffix:colon
l_int|20
suffix:semicolon
DECL|member|scb_rsvd
id|bdrkreg_t
id|scb_rsvd
suffix:colon
l_int|44
suffix:semicolon
DECL|member|pi_spool_cmp_b_fld_s
)brace
id|pi_spool_cmp_b_fld_s
suffix:semicolon
DECL|typedef|pi_spool_cmp_b_u_t
)brace
id|pi_spool_cmp_b_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_spool_cmp_b_u
r_typedef
r_union
id|pi_spool_cmp_b_u
(brace
DECL|member|pi_spool_cmp_b_regval
id|bdrkreg_t
id|pi_spool_cmp_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|scb_rsvd
id|bdrkreg_t
id|scb_rsvd
suffix:colon
l_int|44
suffix:semicolon
DECL|member|scb_compare
id|bdrkreg_t
id|scb_compare
suffix:colon
l_int|20
suffix:semicolon
DECL|member|pi_spool_cmp_b_fld_s
)brace
id|pi_spool_cmp_b_fld_s
suffix:semicolon
DECL|typedef|pi_spool_cmp_b_u_t
)brace
id|pi_spool_cmp_b_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. A timeout can be      *&n; * forced by writing one(s).                                            *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_crb_timeout_a_u
r_typedef
r_union
id|pi_crb_timeout_a_u
(brace
DECL|member|pi_crb_timeout_a_regval
id|bdrkreg_t
id|pi_crb_timeout_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|cta_rrb
id|bdrkreg_t
id|cta_rrb
suffix:colon
l_int|4
suffix:semicolon
DECL|member|cta_wrb
id|bdrkreg_t
id|cta_wrb
suffix:colon
l_int|8
suffix:semicolon
DECL|member|cta_rsvd
id|bdrkreg_t
id|cta_rsvd
suffix:colon
l_int|52
suffix:semicolon
DECL|member|pi_crb_timeout_a_fld_s
)brace
id|pi_crb_timeout_a_fld_s
suffix:semicolon
DECL|typedef|pi_crb_timeout_a_u_t
)brace
id|pi_crb_timeout_a_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_crb_timeout_a_u
r_typedef
r_union
id|pi_crb_timeout_a_u
(brace
DECL|member|pi_crb_timeout_a_regval
id|bdrkreg_t
id|pi_crb_timeout_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|cta_rsvd
id|bdrkreg_t
id|cta_rsvd
suffix:colon
l_int|52
suffix:semicolon
DECL|member|cta_wrb
id|bdrkreg_t
id|cta_wrb
suffix:colon
l_int|8
suffix:semicolon
DECL|member|cta_rrb
id|bdrkreg_t
id|cta_rrb
suffix:colon
l_int|4
suffix:semicolon
DECL|member|pi_crb_timeout_a_fld_s
)brace
id|pi_crb_timeout_a_fld_s
suffix:semicolon
DECL|typedef|pi_crb_timeout_a_u_t
)brace
id|pi_crb_timeout_a_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. A timeout can be      *&n; * forced by writing one(s).                                            *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_crb_timeout_b_u
r_typedef
r_union
id|pi_crb_timeout_b_u
(brace
DECL|member|pi_crb_timeout_b_regval
id|bdrkreg_t
id|pi_crb_timeout_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|ctb_rrb
id|bdrkreg_t
id|ctb_rrb
suffix:colon
l_int|4
suffix:semicolon
DECL|member|ctb_wrb
id|bdrkreg_t
id|ctb_wrb
suffix:colon
l_int|8
suffix:semicolon
DECL|member|ctb_rsvd
id|bdrkreg_t
id|ctb_rsvd
suffix:colon
l_int|52
suffix:semicolon
DECL|member|pi_crb_timeout_b_fld_s
)brace
id|pi_crb_timeout_b_fld_s
suffix:semicolon
DECL|typedef|pi_crb_timeout_b_u_t
)brace
id|pi_crb_timeout_b_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_crb_timeout_b_u
r_typedef
r_union
id|pi_crb_timeout_b_u
(brace
DECL|member|pi_crb_timeout_b_regval
id|bdrkreg_t
id|pi_crb_timeout_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|ctb_rsvd
id|bdrkreg_t
id|ctb_rsvd
suffix:colon
l_int|52
suffix:semicolon
DECL|member|ctb_wrb
id|bdrkreg_t
id|ctb_wrb
suffix:colon
l_int|8
suffix:semicolon
DECL|member|ctb_rrb
id|bdrkreg_t
id|ctb_rrb
suffix:colon
l_int|4
suffix:semicolon
DECL|member|pi_crb_timeout_b_fld_s
)brace
id|pi_crb_timeout_b_fld_s
suffix:semicolon
DECL|typedef|pi_crb_timeout_b_u_t
)brace
id|pi_crb_timeout_b_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register controls error checking and forwarding of SysAD       *&n; * errors.                                                              *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_sysad_errchk_en_u
r_typedef
r_union
id|pi_sysad_errchk_en_u
(brace
DECL|member|pi_sysad_errchk_en_regval
id|bdrkreg_t
id|pi_sysad_errchk_en_regval
suffix:semicolon
r_struct
(brace
DECL|member|see_ecc_gen_en
id|bdrkreg_t
id|see_ecc_gen_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|see_qual_gen_en
id|bdrkreg_t
id|see_qual_gen_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|see_sadp_chk_en
id|bdrkreg_t
id|see_sadp_chk_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|see_cmdp_chk_en
id|bdrkreg_t
id|see_cmdp_chk_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|see_state_chk_en
id|bdrkreg_t
id|see_state_chk_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|see_qual_chk_en
id|bdrkreg_t
id|see_qual_chk_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|see_rsvd
id|bdrkreg_t
id|see_rsvd
suffix:colon
l_int|58
suffix:semicolon
DECL|member|pi_sysad_errchk_en_fld_s
)brace
id|pi_sysad_errchk_en_fld_s
suffix:semicolon
DECL|typedef|pi_sysad_errchk_en_u_t
)brace
id|pi_sysad_errchk_en_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_sysad_errchk_en_u
r_typedef
r_union
id|pi_sysad_errchk_en_u
(brace
DECL|member|pi_sysad_errchk_en_regval
id|bdrkreg_t
id|pi_sysad_errchk_en_regval
suffix:semicolon
r_struct
(brace
DECL|member|see_rsvd
id|bdrkreg_t
id|see_rsvd
suffix:colon
l_int|58
suffix:semicolon
DECL|member|see_qual_chk_en
id|bdrkreg_t
id|see_qual_chk_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|see_state_chk_en
id|bdrkreg_t
id|see_state_chk_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|see_cmdp_chk_en
id|bdrkreg_t
id|see_cmdp_chk_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|see_sadp_chk_en
id|bdrkreg_t
id|see_sadp_chk_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|see_qual_gen_en
id|bdrkreg_t
id|see_qual_gen_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|see_ecc_gen_en
id|bdrkreg_t
id|see_ecc_gen_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_sysad_errchk_en_fld_s
)brace
id|pi_sysad_errchk_en_fld_s
suffix:semicolon
DECL|typedef|pi_sysad_errchk_en_u_t
)brace
id|pi_sysad_errchk_en_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. If any bit in this    *&n; * register is set, then whenever reply data arrives with the UE        *&n; * (uncorrectable error) indication set, the check-bits that are        *&n; * generated and sent to the SysAD will be inverted corresponding to    *&n; * the bits set in the register. This will also prevent the assertion   *&n; * of the data quality indicator.                                       *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_force_bad_check_bit_a_u
r_typedef
r_union
id|pi_force_bad_check_bit_a_u
(brace
DECL|member|pi_force_bad_check_bit_a_regval
id|bdrkreg_t
id|pi_force_bad_check_bit_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|fbcba_bad_check_bit
id|bdrkreg_t
id|fbcba_bad_check_bit
suffix:colon
l_int|8
suffix:semicolon
DECL|member|fbcba_rsvd
id|bdrkreg_t
id|fbcba_rsvd
suffix:colon
l_int|56
suffix:semicolon
DECL|member|pi_force_bad_check_bit_a_fld_s
)brace
id|pi_force_bad_check_bit_a_fld_s
suffix:semicolon
DECL|typedef|pi_force_bad_check_bit_a_u_t
)brace
id|pi_force_bad_check_bit_a_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_force_bad_check_bit_a_u
r_typedef
r_union
id|pi_force_bad_check_bit_a_u
(brace
DECL|member|pi_force_bad_check_bit_a_regval
id|bdrkreg_t
id|pi_force_bad_check_bit_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|fbcba_rsvd
id|bdrkreg_t
id|fbcba_rsvd
suffix:colon
l_int|56
suffix:semicolon
DECL|member|fbcba_bad_check_bit
id|bdrkreg_t
id|fbcba_bad_check_bit
suffix:colon
l_int|8
suffix:semicolon
DECL|member|pi_force_bad_check_bit_a_fld_s
)brace
id|pi_force_bad_check_bit_a_fld_s
suffix:semicolon
DECL|typedef|pi_force_bad_check_bit_a_u_t
)brace
id|pi_force_bad_check_bit_a_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. If any bit in this    *&n; * register is set, then whenever reply data arrives with the UE        *&n; * (uncorrectable error) indication set, the check-bits that are        *&n; * generated and sent to the SysAD will be inverted corresponding to    *&n; * the bits set in the register. This will also prevent the assertion   *&n; * of the data quality indicator.                                       *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_force_bad_check_bit_b_u
r_typedef
r_union
id|pi_force_bad_check_bit_b_u
(brace
DECL|member|pi_force_bad_check_bit_b_regval
id|bdrkreg_t
id|pi_force_bad_check_bit_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|fbcbb_bad_check_bit
id|bdrkreg_t
id|fbcbb_bad_check_bit
suffix:colon
l_int|8
suffix:semicolon
DECL|member|fbcbb_rsvd
id|bdrkreg_t
id|fbcbb_rsvd
suffix:colon
l_int|56
suffix:semicolon
DECL|member|pi_force_bad_check_bit_b_fld_s
)brace
id|pi_force_bad_check_bit_b_fld_s
suffix:semicolon
DECL|typedef|pi_force_bad_check_bit_b_u_t
)brace
id|pi_force_bad_check_bit_b_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_force_bad_check_bit_b_u
r_typedef
r_union
id|pi_force_bad_check_bit_b_u
(brace
DECL|member|pi_force_bad_check_bit_b_regval
id|bdrkreg_t
id|pi_force_bad_check_bit_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|fbcbb_rsvd
id|bdrkreg_t
id|fbcbb_rsvd
suffix:colon
l_int|56
suffix:semicolon
DECL|member|fbcbb_bad_check_bit
id|bdrkreg_t
id|fbcbb_bad_check_bit
suffix:colon
l_int|8
suffix:semicolon
DECL|member|pi_force_bad_check_bit_b_fld_s
)brace
id|pi_force_bad_check_bit_b_fld_s
suffix:semicolon
DECL|typedef|pi_force_bad_check_bit_b_u_t
)brace
id|pi_force_bad_check_bit_b_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. When a counter is     *&n; * enabled, it increments each time a DNACK reply is received. The      *&n; * counter is cleared when any other reply is received. The register    *&n; * is cleared when the CNT_EN bit is zero. If a DNACK reply is          *&n; * received when the counter equals the value in the NACK_CMP           *&n; * register, the counter is cleared, an error response is sent to the   *&n; * CPU instead of a nack response, and the NACK_INT_A/B bit is set in   *&n; * INT_PEND1.                                                           *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_nack_cnt_a_u
r_typedef
r_union
id|pi_nack_cnt_a_u
(brace
DECL|member|pi_nack_cnt_a_regval
id|bdrkreg_t
id|pi_nack_cnt_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|nca_nack_cnt
id|bdrkreg_t
id|nca_nack_cnt
suffix:colon
l_int|20
suffix:semicolon
DECL|member|nca_cnt_en
id|bdrkreg_t
id|nca_cnt_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|nca_rsvd
id|bdrkreg_t
id|nca_rsvd
suffix:colon
l_int|43
suffix:semicolon
DECL|member|pi_nack_cnt_a_fld_s
)brace
id|pi_nack_cnt_a_fld_s
suffix:semicolon
DECL|typedef|pi_nack_cnt_a_u_t
)brace
id|pi_nack_cnt_a_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_nack_cnt_a_u
r_typedef
r_union
id|pi_nack_cnt_a_u
(brace
DECL|member|pi_nack_cnt_a_regval
id|bdrkreg_t
id|pi_nack_cnt_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|nca_rsvd
id|bdrkreg_t
id|nca_rsvd
suffix:colon
l_int|43
suffix:semicolon
DECL|member|nca_cnt_en
id|bdrkreg_t
id|nca_cnt_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|nca_nack_cnt
id|bdrkreg_t
id|nca_nack_cnt
suffix:colon
l_int|20
suffix:semicolon
DECL|member|pi_nack_cnt_a_fld_s
)brace
id|pi_nack_cnt_a_fld_s
suffix:semicolon
DECL|typedef|pi_nack_cnt_a_u_t
)brace
id|pi_nack_cnt_a_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  There is one of these registers for each CPU. When a counter is     *&n; * enabled, it increments each time a DNACK reply is received. The      *&n; * counter is cleared when any other reply is received. The register    *&n; * is cleared when the CNT_EN bit is zero. If a DNACK reply is          *&n; * received when the counter equals the value in the NACK_CMP           *&n; * register, the counter is cleared, an error response is sent to the   *&n; * CPU instead of a nack response, and the NACK_INT_A/B bit is set in   *&n; * INT_PEND1.                                                           *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_nack_cnt_b_u
r_typedef
r_union
id|pi_nack_cnt_b_u
(brace
DECL|member|pi_nack_cnt_b_regval
id|bdrkreg_t
id|pi_nack_cnt_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|ncb_nack_cnt
id|bdrkreg_t
id|ncb_nack_cnt
suffix:colon
l_int|20
suffix:semicolon
DECL|member|ncb_cnt_en
id|bdrkreg_t
id|ncb_cnt_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ncb_rsvd
id|bdrkreg_t
id|ncb_rsvd
suffix:colon
l_int|43
suffix:semicolon
DECL|member|pi_nack_cnt_b_fld_s
)brace
id|pi_nack_cnt_b_fld_s
suffix:semicolon
DECL|typedef|pi_nack_cnt_b_u_t
)brace
id|pi_nack_cnt_b_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_nack_cnt_b_u
r_typedef
r_union
id|pi_nack_cnt_b_u
(brace
DECL|member|pi_nack_cnt_b_regval
id|bdrkreg_t
id|pi_nack_cnt_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|ncb_rsvd
id|bdrkreg_t
id|ncb_rsvd
suffix:colon
l_int|43
suffix:semicolon
DECL|member|ncb_cnt_en
id|bdrkreg_t
id|ncb_cnt_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ncb_nack_cnt
id|bdrkreg_t
id|ncb_nack_cnt
suffix:colon
l_int|20
suffix:semicolon
DECL|member|pi_nack_cnt_b_fld_s
)brace
id|pi_nack_cnt_b_fld_s
suffix:semicolon
DECL|typedef|pi_nack_cnt_b_u_t
)brace
id|pi_nack_cnt_b_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  The setting of this register affects both CPUs on this PI.          *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_nack_cmp_u
r_typedef
r_union
id|pi_nack_cmp_u
(brace
DECL|member|pi_nack_cmp_regval
id|bdrkreg_t
id|pi_nack_cmp_regval
suffix:semicolon
r_struct
(brace
DECL|member|nc_nack_cmp
id|bdrkreg_t
id|nc_nack_cmp
suffix:colon
l_int|20
suffix:semicolon
DECL|member|nc_rsvd
id|bdrkreg_t
id|nc_rsvd
suffix:colon
l_int|44
suffix:semicolon
DECL|member|pi_nack_cmp_fld_s
)brace
id|pi_nack_cmp_fld_s
suffix:semicolon
DECL|typedef|pi_nack_cmp_u_t
)brace
id|pi_nack_cmp_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_nack_cmp_u
r_typedef
r_union
id|pi_nack_cmp_u
(brace
DECL|member|pi_nack_cmp_regval
id|bdrkreg_t
id|pi_nack_cmp_regval
suffix:semicolon
r_struct
(brace
DECL|member|nc_rsvd
id|bdrkreg_t
id|nc_rsvd
suffix:colon
l_int|44
suffix:semicolon
DECL|member|nc_nack_cmp
id|bdrkreg_t
id|nc_nack_cmp
suffix:colon
l_int|20
suffix:semicolon
DECL|member|pi_nack_cmp_fld_s
)brace
id|pi_nack_cmp_fld_s
suffix:semicolon
DECL|typedef|pi_nack_cmp_u_t
)brace
id|pi_nack_cmp_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register controls which errors are spooled. When a bit in      *&n; * this register is set, the corresponding error is spooled. The        *&n; * setting of this register affects both CPUs on this PI.               *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_spool_mask_u
r_typedef
r_union
id|pi_spool_mask_u
(brace
DECL|member|pi_spool_mask_regval
id|bdrkreg_t
id|pi_spool_mask_regval
suffix:semicolon
r_struct
(brace
DECL|member|sm_access_err
id|bdrkreg_t
id|sm_access_err
suffix:colon
l_int|1
suffix:semicolon
DECL|member|sm_uncached_err
id|bdrkreg_t
id|sm_uncached_err
suffix:colon
l_int|1
suffix:semicolon
DECL|member|sm_dir_err
id|bdrkreg_t
id|sm_dir_err
suffix:colon
l_int|1
suffix:semicolon
DECL|member|sm_timeout_err
id|bdrkreg_t
id|sm_timeout_err
suffix:colon
l_int|1
suffix:semicolon
DECL|member|sm_poison_err
id|bdrkreg_t
id|sm_poison_err
suffix:colon
l_int|1
suffix:semicolon
DECL|member|sm_nack_oflow_err
id|bdrkreg_t
id|sm_nack_oflow_err
suffix:colon
l_int|1
suffix:semicolon
DECL|member|sm_rsvd
id|bdrkreg_t
id|sm_rsvd
suffix:colon
l_int|58
suffix:semicolon
DECL|member|pi_spool_mask_fld_s
)brace
id|pi_spool_mask_fld_s
suffix:semicolon
DECL|typedef|pi_spool_mask_u_t
)brace
id|pi_spool_mask_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_spool_mask_u
r_typedef
r_union
id|pi_spool_mask_u
(brace
DECL|member|pi_spool_mask_regval
id|bdrkreg_t
id|pi_spool_mask_regval
suffix:semicolon
r_struct
(brace
DECL|member|sm_rsvd
id|bdrkreg_t
id|sm_rsvd
suffix:colon
l_int|58
suffix:semicolon
DECL|member|sm_nack_oflow_err
id|bdrkreg_t
id|sm_nack_oflow_err
suffix:colon
l_int|1
suffix:semicolon
DECL|member|sm_poison_err
id|bdrkreg_t
id|sm_poison_err
suffix:colon
l_int|1
suffix:semicolon
DECL|member|sm_timeout_err
id|bdrkreg_t
id|sm_timeout_err
suffix:colon
l_int|1
suffix:semicolon
DECL|member|sm_dir_err
id|bdrkreg_t
id|sm_dir_err
suffix:colon
l_int|1
suffix:semicolon
DECL|member|sm_uncached_err
id|bdrkreg_t
id|sm_uncached_err
suffix:colon
l_int|1
suffix:semicolon
DECL|member|sm_access_err
id|bdrkreg_t
id|sm_access_err
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_spool_mask_fld_s
)brace
id|pi_spool_mask_fld_s
suffix:semicolon
DECL|typedef|pi_spool_mask_u_t
)brace
id|pi_spool_mask_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register is not cleared at reset. When the VALID bit is        *&n; * zero, this register (along with SPURIOUS_HDR_1) will capture the     *&n; * header of an incoming spurious message received from the XBar. A     *&n; * spurious message is a message that does not match up with any of     *&n; * the CRB entries. This is a read/write register, so it is cleared     *&n; * by writing of all zeros.                                             *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_spurious_hdr_0_u
r_typedef
r_union
id|pi_spurious_hdr_0_u
(brace
DECL|member|pi_spurious_hdr_0_regval
id|bdrkreg_t
id|pi_spurious_hdr_0_regval
suffix:semicolon
r_struct
(brace
DECL|member|sh0_prev_valid_b
id|bdrkreg_t
id|sh0_prev_valid_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|sh0_prev_valid_a
id|bdrkreg_t
id|sh0_prev_valid_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|sh0_rsvd
id|bdrkreg_t
id|sh0_rsvd
suffix:colon
l_int|4
suffix:semicolon
DECL|member|sh0_supplemental
id|bdrkreg_t
id|sh0_supplemental
suffix:colon
l_int|11
suffix:semicolon
DECL|member|sh0_cmd
id|bdrkreg_t
id|sh0_cmd
suffix:colon
l_int|8
suffix:semicolon
DECL|member|sh0_addr
id|bdrkreg_t
id|sh0_addr
suffix:colon
l_int|37
suffix:semicolon
DECL|member|sh0_tail
id|bdrkreg_t
id|sh0_tail
suffix:colon
l_int|1
suffix:semicolon
DECL|member|sh0_valid
id|bdrkreg_t
id|sh0_valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_spurious_hdr_0_fld_s
)brace
id|pi_spurious_hdr_0_fld_s
suffix:semicolon
DECL|typedef|pi_spurious_hdr_0_u_t
)brace
id|pi_spurious_hdr_0_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_spurious_hdr_0_u
r_typedef
r_union
id|pi_spurious_hdr_0_u
(brace
DECL|member|pi_spurious_hdr_0_regval
id|bdrkreg_t
id|pi_spurious_hdr_0_regval
suffix:semicolon
r_struct
(brace
DECL|member|sh0_valid
id|bdrkreg_t
id|sh0_valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|sh0_tail
id|bdrkreg_t
id|sh0_tail
suffix:colon
l_int|1
suffix:semicolon
DECL|member|sh0_addr
id|bdrkreg_t
id|sh0_addr
suffix:colon
l_int|37
suffix:semicolon
DECL|member|sh0_cmd
id|bdrkreg_t
id|sh0_cmd
suffix:colon
l_int|8
suffix:semicolon
DECL|member|sh0_supplemental
id|bdrkreg_t
id|sh0_supplemental
suffix:colon
l_int|11
suffix:semicolon
DECL|member|sh0_rsvd
id|bdrkreg_t
id|sh0_rsvd
suffix:colon
l_int|4
suffix:semicolon
DECL|member|sh0_prev_valid_a
id|bdrkreg_t
id|sh0_prev_valid_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|sh0_prev_valid_b
id|bdrkreg_t
id|sh0_prev_valid_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_spurious_hdr_0_fld_s
)brace
id|pi_spurious_hdr_0_fld_s
suffix:semicolon
DECL|typedef|pi_spurious_hdr_0_u_t
)brace
id|pi_spurious_hdr_0_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register is not cleared at reset. When the VALID bit in        *&n; * SPURIOUS_HDR_0 is zero, this register (along with SPURIOUS_HDR_0)    *&n; * will capture the header of an incoming spurious message received     *&n; * from the XBar. A spurious message is a message that does not match   *&n; * up with any of the CRB entries. This is a read/write register, so    *&n; * it is cleared by writing of all zeros.                               *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_spurious_hdr_1_u
r_typedef
r_union
id|pi_spurious_hdr_1_u
(brace
DECL|member|pi_spurious_hdr_1_regval
id|bdrkreg_t
id|pi_spurious_hdr_1_regval
suffix:semicolon
r_struct
(brace
DECL|member|sh1_rsvd
id|bdrkreg_t
id|sh1_rsvd
suffix:colon
l_int|53
suffix:semicolon
DECL|member|sh1_source
id|bdrkreg_t
id|sh1_source
suffix:colon
l_int|11
suffix:semicolon
DECL|member|pi_spurious_hdr_1_fld_s
)brace
id|pi_spurious_hdr_1_fld_s
suffix:semicolon
DECL|typedef|pi_spurious_hdr_1_u_t
)brace
id|pi_spurious_hdr_1_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_spurious_hdr_1_u
r_typedef
r_union
id|pi_spurious_hdr_1_u
(brace
DECL|member|pi_spurious_hdr_1_regval
id|bdrkreg_t
id|pi_spurious_hdr_1_regval
suffix:semicolon
r_struct
(brace
DECL|member|sh1_source
id|bdrkreg_t
id|sh1_source
suffix:colon
l_int|11
suffix:semicolon
DECL|member|sh1_rsvd
id|bdrkreg_t
id|sh1_rsvd
suffix:colon
l_int|53
suffix:semicolon
DECL|member|pi_spurious_hdr_1_fld_s
)brace
id|pi_spurious_hdr_1_fld_s
suffix:semicolon
DECL|typedef|pi_spurious_hdr_1_u_t
)brace
id|pi_spurious_hdr_1_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; * Description:  This register controls the injection of errors in      *&n; * outbound SysAD transfers. When a write sets a bit in this            *&n; * register, the PI logic is &quot;armed&quot; to inject that error. At the       *&n; * first transfer of the specified type, the error is injected and      *&n; * the bit in this register is cleared. Writing to this register does   *&n; * not cause a transaction to occur. A bit in this register will        *&n; * remain set until a transaction of the specified type occurs as a     *&n; * result of normal system activity. This register can be polled to     *&n; * determine if an error has been injected or is still &quot;armed&quot;.         *&n; * This register does not control injection of data quality bad         *&n; * indicator on a data cycle. This type of error can be created by      *&n; * reading from a memory location that has an uncorrectable ECC         *&n; * error.                                                               *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_err_inject_u
r_typedef
r_union
id|pi_err_inject_u
(brace
DECL|member|pi_err_inject_regval
id|bdrkreg_t
id|pi_err_inject_regval
suffix:semicolon
r_struct
(brace
DECL|member|ei_cmd_syscmd_par_a
id|bdrkreg_t
id|ei_cmd_syscmd_par_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_data_syscmd_par_a
id|bdrkreg_t
id|ei_data_syscmd_par_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_cmd_sysad_corecc_a
id|bdrkreg_t
id|ei_cmd_sysad_corecc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_data_sysad_corecc_a
id|bdrkreg_t
id|ei_data_sysad_corecc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_cmd_sysad_uncecc_a
id|bdrkreg_t
id|ei_cmd_sysad_uncecc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_data_sysad_uncecc_a
id|bdrkreg_t
id|ei_data_sysad_uncecc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_sysresp_par_a
id|bdrkreg_t
id|ei_sysresp_par_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_reserved_1
id|bdrkreg_t
id|ei_reserved_1
suffix:colon
l_int|25
suffix:semicolon
DECL|member|ei_cmd_syscmd_par_b
id|bdrkreg_t
id|ei_cmd_syscmd_par_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_data_syscmd_par_b
id|bdrkreg_t
id|ei_data_syscmd_par_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_cmd_sysad_corecc_b
id|bdrkreg_t
id|ei_cmd_sysad_corecc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_data_sysad_corecc_b
id|bdrkreg_t
id|ei_data_sysad_corecc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_cmd_sysad_uncecc_b
id|bdrkreg_t
id|ei_cmd_sysad_uncecc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_data_sysad_uncecc_b
id|bdrkreg_t
id|ei_data_sysad_uncecc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_sysresp_par_b
id|bdrkreg_t
id|ei_sysresp_par_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_reserved
id|bdrkreg_t
id|ei_reserved
suffix:colon
l_int|25
suffix:semicolon
DECL|member|pi_err_inject_fld_s
)brace
id|pi_err_inject_fld_s
suffix:semicolon
DECL|typedef|pi_err_inject_u_t
)brace
id|pi_err_inject_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_err_inject_u
r_typedef
r_union
id|pi_err_inject_u
(brace
DECL|member|pi_err_inject_regval
id|bdrkreg_t
id|pi_err_inject_regval
suffix:semicolon
r_struct
(brace
DECL|member|ei_reserved
id|bdrkreg_t
id|ei_reserved
suffix:colon
l_int|25
suffix:semicolon
DECL|member|ei_sysresp_par_b
id|bdrkreg_t
id|ei_sysresp_par_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_data_sysad_uncecc_b
id|bdrkreg_t
id|ei_data_sysad_uncecc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_cmd_sysad_uncecc_b
id|bdrkreg_t
id|ei_cmd_sysad_uncecc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_data_sysad_corecc_b
id|bdrkreg_t
id|ei_data_sysad_corecc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_cmd_sysad_corecc_b
id|bdrkreg_t
id|ei_cmd_sysad_corecc_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_data_syscmd_par_b
id|bdrkreg_t
id|ei_data_syscmd_par_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_cmd_syscmd_par_b
id|bdrkreg_t
id|ei_cmd_syscmd_par_b
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_reserved_1
id|bdrkreg_t
id|ei_reserved_1
suffix:colon
l_int|25
suffix:semicolon
DECL|member|ei_sysresp_par_a
id|bdrkreg_t
id|ei_sysresp_par_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_data_sysad_uncecc_a
id|bdrkreg_t
id|ei_data_sysad_uncecc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_cmd_sysad_uncecc_a
id|bdrkreg_t
id|ei_cmd_sysad_uncecc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_data_sysad_corecc_a
id|bdrkreg_t
id|ei_data_sysad_corecc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_cmd_sysad_corecc_a
id|bdrkreg_t
id|ei_cmd_sysad_corecc_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_data_syscmd_par_a
id|bdrkreg_t
id|ei_data_syscmd_par_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ei_cmd_syscmd_par_a
id|bdrkreg_t
id|ei_cmd_syscmd_par_a
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_err_inject_fld_s
)brace
id|pi_err_inject_fld_s
suffix:semicolon
DECL|typedef|pi_err_inject_u_t
)brace
id|pi_err_inject_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This Read/Write location determines at what point the TRex+ is      *&n; * stopped from issuing requests, based on the number of entries in     *&n; * the incoming reply FIFO. When the number of entries in the Reply     *&n; * FIFO is greater than the value of this register, the PI will         *&n; * deassert both SysWrRdy and SysRdRdy to both processors. The Reply    *&n; * FIFO has a depth of 0x3F entries, so setting this register to 0x3F   *&n; * effectively disables this feature, allowing requests to be issued    *&n; * always. Setting this register to 0x00 effectively lowers the         *&n; * TRex+&squot;s priority below the reply FIFO, disabling TRex+ requests      *&n; * any time there is an entry waiting in the incoming FIFO.This         *&n; * register is in its own 64KB page so that it can be mapped to user    *&n; * space.                                                               *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_reply_level_u
r_typedef
r_union
id|pi_reply_level_u
(brace
DECL|member|pi_reply_level_regval
id|bdrkreg_t
id|pi_reply_level_regval
suffix:semicolon
r_struct
(brace
DECL|member|rl_reply_level
id|bdrkreg_t
id|rl_reply_level
suffix:colon
l_int|6
suffix:semicolon
DECL|member|rl_rsvd
id|bdrkreg_t
id|rl_rsvd
suffix:colon
l_int|58
suffix:semicolon
DECL|member|pi_reply_level_fld_s
)brace
id|pi_reply_level_fld_s
suffix:semicolon
DECL|typedef|pi_reply_level_u_t
)brace
id|pi_reply_level_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_reply_level_u
r_typedef
r_union
id|pi_reply_level_u
(brace
DECL|member|pi_reply_level_regval
id|bdrkreg_t
id|pi_reply_level_regval
suffix:semicolon
r_struct
(brace
DECL|member|rl_rsvd
id|bdrkreg_t
id|rl_rsvd
suffix:colon
l_int|58
suffix:semicolon
DECL|member|rl_reply_level
id|bdrkreg_t
id|rl_reply_level
suffix:colon
l_int|6
suffix:semicolon
DECL|member|pi_reply_level_fld_s
)brace
id|pi_reply_level_fld_s
suffix:semicolon
DECL|typedef|pi_reply_level_u_t
)brace
id|pi_reply_level_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register is used to change the graphics credit counter         *&n; * operation from &quot;Doubleword&quot; mode to &quot;Transaction&quot; mode. This         *&n; * register is in its own 64KB page so that it can be mapped to user    *&n; * space.                                                               *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_gfx_credit_mode_u
r_typedef
r_union
id|pi_gfx_credit_mode_u
(brace
DECL|member|pi_gfx_credit_mode_regval
id|bdrkreg_t
id|pi_gfx_credit_mode_regval
suffix:semicolon
r_struct
(brace
DECL|member|gcm_trans_mode
id|bdrkreg_t
id|gcm_trans_mode
suffix:colon
l_int|1
suffix:semicolon
DECL|member|gcm_rsvd
id|bdrkreg_t
id|gcm_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|pi_gfx_credit_mode_fld_s
)brace
id|pi_gfx_credit_mode_fld_s
suffix:semicolon
DECL|typedef|pi_gfx_credit_mode_u_t
)brace
id|pi_gfx_credit_mode_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_gfx_credit_mode_u
r_typedef
r_union
id|pi_gfx_credit_mode_u
(brace
DECL|member|pi_gfx_credit_mode_regval
id|bdrkreg_t
id|pi_gfx_credit_mode_regval
suffix:semicolon
r_struct
(brace
DECL|member|gcm_rsvd
id|bdrkreg_t
id|gcm_rsvd
suffix:colon
l_int|63
suffix:semicolon
DECL|member|gcm_trans_mode
id|bdrkreg_t
id|gcm_trans_mode
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_gfx_credit_mode_fld_s
)brace
id|pi_gfx_credit_mode_fld_s
suffix:semicolon
DECL|typedef|pi_gfx_credit_mode_u_t
)brace
id|pi_gfx_credit_mode_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This location contains a 55-bit read/write counter that wraps to    *&n; * zero when the maximum value is reached. This counter is              *&n; * incremented at each rising edge of the global clock (GCLK). This     *&n; * register is in its own 64KB page so that it can be mapped to user    *&n; * space.                                                               *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_rt_counter_u
r_typedef
r_union
id|pi_rt_counter_u
(brace
DECL|member|pi_rt_counter_regval
id|bdrkreg_t
id|pi_rt_counter_regval
suffix:semicolon
r_struct
(brace
DECL|member|rc_count
id|bdrkreg_t
id|rc_count
suffix:colon
l_int|55
suffix:semicolon
DECL|member|rc_rsvd
id|bdrkreg_t
id|rc_rsvd
suffix:colon
l_int|9
suffix:semicolon
DECL|member|pi_rt_counter_fld_s
)brace
id|pi_rt_counter_fld_s
suffix:semicolon
DECL|typedef|pi_rt_counter_u_t
)brace
id|pi_rt_counter_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_rt_counter_u
r_typedef
r_union
id|pi_rt_counter_u
(brace
DECL|member|pi_rt_counter_regval
id|bdrkreg_t
id|pi_rt_counter_regval
suffix:semicolon
r_struct
(brace
DECL|member|rc_rsvd
id|bdrkreg_t
id|rc_rsvd
suffix:colon
l_int|9
suffix:semicolon
DECL|member|rc_count
id|bdrkreg_t
id|rc_count
suffix:colon
l_int|55
suffix:semicolon
DECL|member|pi_rt_counter_fld_s
)brace
id|pi_rt_counter_fld_s
suffix:semicolon
DECL|typedef|pi_rt_counter_u_t
)brace
id|pi_rt_counter_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register controls the performance counters for one CPU.        *&n; * There are two counters for each CPU. Each counter can be             *&n; * configured to count a variety of events. The performance counter     *&n; * registers for each processor are in their own 64KB page so that      *&n; * they can be mapped to user space.                                    *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_perf_cntl_a_u
r_typedef
r_union
id|pi_perf_cntl_a_u
(brace
DECL|member|pi_perf_cntl_a_regval
id|bdrkreg_t
id|pi_perf_cntl_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|pca_cntr_0_select
id|bdrkreg_t
id|pca_cntr_0_select
suffix:colon
l_int|28
suffix:semicolon
DECL|member|pca_cntr_0_mode
id|bdrkreg_t
id|pca_cntr_0_mode
suffix:colon
l_int|3
suffix:semicolon
DECL|member|pca_cntr_0_enable
id|bdrkreg_t
id|pca_cntr_0_enable
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pca_cntr_1_select
id|bdrkreg_t
id|pca_cntr_1_select
suffix:colon
l_int|28
suffix:semicolon
DECL|member|pca_cntr_1_mode
id|bdrkreg_t
id|pca_cntr_1_mode
suffix:colon
l_int|3
suffix:semicolon
DECL|member|pca_cntr_1_enable
id|bdrkreg_t
id|pca_cntr_1_enable
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_perf_cntl_a_fld_s
)brace
id|pi_perf_cntl_a_fld_s
suffix:semicolon
DECL|typedef|pi_perf_cntl_a_u_t
)brace
id|pi_perf_cntl_a_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_perf_cntl_a_u
r_typedef
r_union
id|pi_perf_cntl_a_u
(brace
DECL|member|pi_perf_cntl_a_regval
id|bdrkreg_t
id|pi_perf_cntl_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|pca_cntr_1_enable
id|bdrkreg_t
id|pca_cntr_1_enable
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pca_cntr_1_mode
id|bdrkreg_t
id|pca_cntr_1_mode
suffix:colon
l_int|3
suffix:semicolon
DECL|member|pca_cntr_1_select
id|bdrkreg_t
id|pca_cntr_1_select
suffix:colon
l_int|28
suffix:semicolon
DECL|member|pca_cntr_0_enable
id|bdrkreg_t
id|pca_cntr_0_enable
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pca_cntr_0_mode
id|bdrkreg_t
id|pca_cntr_0_mode
suffix:colon
l_int|3
suffix:semicolon
DECL|member|pca_cntr_0_select
id|bdrkreg_t
id|pca_cntr_0_select
suffix:colon
l_int|28
suffix:semicolon
DECL|member|pi_perf_cntl_a_fld_s
)brace
id|pi_perf_cntl_a_fld_s
suffix:semicolon
DECL|typedef|pi_perf_cntl_a_u_t
)brace
id|pi_perf_cntl_a_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register accesses the performance counter 0 for each CPU.      *&n; * Each performance counter is 40-bits wide. On overflow, It wraps to   *&n; * zero, sets the overflow bit in this register, and sets the           *&n; * PERF_CNTR_OFLOW bit in the INT_PEND1 register.                       *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_perf_cntr0_a_u
r_typedef
r_union
id|pi_perf_cntr0_a_u
(brace
DECL|member|pi_perf_cntr0_a_regval
id|bdrkreg_t
id|pi_perf_cntr0_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|pca_count_value
id|bdrkreg_t
id|pca_count_value
suffix:colon
l_int|40
suffix:semicolon
DECL|member|pca_overflow
id|bdrkreg_t
id|pca_overflow
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pca_rsvd
id|bdrkreg_t
id|pca_rsvd
suffix:colon
l_int|23
suffix:semicolon
DECL|member|pi_perf_cntr0_a_fld_s
)brace
id|pi_perf_cntr0_a_fld_s
suffix:semicolon
DECL|typedef|pi_perf_cntr0_a_u_t
)brace
id|pi_perf_cntr0_a_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_perf_cntr0_a_u
r_typedef
r_union
id|pi_perf_cntr0_a_u
(brace
DECL|member|pi_perf_cntr0_a_regval
id|bdrkreg_t
id|pi_perf_cntr0_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|pca_rsvd
id|bdrkreg_t
id|pca_rsvd
suffix:colon
l_int|23
suffix:semicolon
DECL|member|pca_overflow
id|bdrkreg_t
id|pca_overflow
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pca_count_value
id|bdrkreg_t
id|pca_count_value
suffix:colon
l_int|40
suffix:semicolon
DECL|member|pi_perf_cntr0_a_fld_s
)brace
id|pi_perf_cntr0_a_fld_s
suffix:semicolon
DECL|typedef|pi_perf_cntr0_a_u_t
)brace
id|pi_perf_cntr0_a_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register accesses the performance counter 1for each CPU.       *&n; * Each performance counter is 40-bits wide. On overflow, It wraps to   *&n; * zero, sets the overflow bit in this register, and sets the           *&n; * PERF_CNTR_OFLOW bit in the INT_PEND1 register.                       *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_perf_cntr1_a_u
r_typedef
r_union
id|pi_perf_cntr1_a_u
(brace
DECL|member|pi_perf_cntr1_a_regval
id|bdrkreg_t
id|pi_perf_cntr1_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|pca_count_value
id|bdrkreg_t
id|pca_count_value
suffix:colon
l_int|40
suffix:semicolon
DECL|member|pca_overflow
id|bdrkreg_t
id|pca_overflow
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pca_rsvd
id|bdrkreg_t
id|pca_rsvd
suffix:colon
l_int|23
suffix:semicolon
DECL|member|pi_perf_cntr1_a_fld_s
)brace
id|pi_perf_cntr1_a_fld_s
suffix:semicolon
DECL|typedef|pi_perf_cntr1_a_u_t
)brace
id|pi_perf_cntr1_a_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_perf_cntr1_a_u
r_typedef
r_union
id|pi_perf_cntr1_a_u
(brace
DECL|member|pi_perf_cntr1_a_regval
id|bdrkreg_t
id|pi_perf_cntr1_a_regval
suffix:semicolon
r_struct
(brace
DECL|member|pca_rsvd
id|bdrkreg_t
id|pca_rsvd
suffix:colon
l_int|23
suffix:semicolon
DECL|member|pca_overflow
id|bdrkreg_t
id|pca_overflow
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pca_count_value
id|bdrkreg_t
id|pca_count_value
suffix:colon
l_int|40
suffix:semicolon
DECL|member|pi_perf_cntr1_a_fld_s
)brace
id|pi_perf_cntr1_a_fld_s
suffix:semicolon
DECL|typedef|pi_perf_cntr1_a_u_t
)brace
id|pi_perf_cntr1_a_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register controls the performance counters for one CPU.        *&n; * There are two counters for each CPU. Each counter can be             *&n; * configured to count a variety of events. The performance counter     *&n; * registers for each processor are in their own 64KB page so that      *&n; * they can be mapped to user space.                                    *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_perf_cntl_b_u
r_typedef
r_union
id|pi_perf_cntl_b_u
(brace
DECL|member|pi_perf_cntl_b_regval
id|bdrkreg_t
id|pi_perf_cntl_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|pcb_cntr_0_select
id|bdrkreg_t
id|pcb_cntr_0_select
suffix:colon
l_int|28
suffix:semicolon
DECL|member|pcb_cntr_0_mode
id|bdrkreg_t
id|pcb_cntr_0_mode
suffix:colon
l_int|3
suffix:semicolon
DECL|member|pcb_cntr_0_enable
id|bdrkreg_t
id|pcb_cntr_0_enable
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pcb_cntr_1_select
id|bdrkreg_t
id|pcb_cntr_1_select
suffix:colon
l_int|28
suffix:semicolon
DECL|member|pcb_cntr_1_mode
id|bdrkreg_t
id|pcb_cntr_1_mode
suffix:colon
l_int|3
suffix:semicolon
DECL|member|pcb_cntr_1_enable
id|bdrkreg_t
id|pcb_cntr_1_enable
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pi_perf_cntl_b_fld_s
)brace
id|pi_perf_cntl_b_fld_s
suffix:semicolon
DECL|typedef|pi_perf_cntl_b_u_t
)brace
id|pi_perf_cntl_b_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_perf_cntl_b_u
r_typedef
r_union
id|pi_perf_cntl_b_u
(brace
DECL|member|pi_perf_cntl_b_regval
id|bdrkreg_t
id|pi_perf_cntl_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|pcb_cntr_1_enable
id|bdrkreg_t
id|pcb_cntr_1_enable
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pcb_cntr_1_mode
id|bdrkreg_t
id|pcb_cntr_1_mode
suffix:colon
l_int|3
suffix:semicolon
DECL|member|pcb_cntr_1_select
id|bdrkreg_t
id|pcb_cntr_1_select
suffix:colon
l_int|28
suffix:semicolon
DECL|member|pcb_cntr_0_enable
id|bdrkreg_t
id|pcb_cntr_0_enable
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pcb_cntr_0_mode
id|bdrkreg_t
id|pcb_cntr_0_mode
suffix:colon
l_int|3
suffix:semicolon
DECL|member|pcb_cntr_0_select
id|bdrkreg_t
id|pcb_cntr_0_select
suffix:colon
l_int|28
suffix:semicolon
DECL|member|pi_perf_cntl_b_fld_s
)brace
id|pi_perf_cntl_b_fld_s
suffix:semicolon
DECL|typedef|pi_perf_cntl_b_u_t
)brace
id|pi_perf_cntl_b_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register accesses the performance counter 0 for each CPU.      *&n; * Each performance counter is 40-bits wide. On overflow, It wraps to   *&n; * zero, sets the overflow bit in this register, and sets the           *&n; * PERF_CNTR_OFLOW bit in the INT_PEND1 register.                       *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_perf_cntr0_b_u
r_typedef
r_union
id|pi_perf_cntr0_b_u
(brace
DECL|member|pi_perf_cntr0_b_regval
id|bdrkreg_t
id|pi_perf_cntr0_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|pcb_count_value
id|bdrkreg_t
id|pcb_count_value
suffix:colon
l_int|40
suffix:semicolon
DECL|member|pcb_overflow
id|bdrkreg_t
id|pcb_overflow
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pcb_rsvd
id|bdrkreg_t
id|pcb_rsvd
suffix:colon
l_int|23
suffix:semicolon
DECL|member|pi_perf_cntr0_b_fld_s
)brace
id|pi_perf_cntr0_b_fld_s
suffix:semicolon
DECL|typedef|pi_perf_cntr0_b_u_t
)brace
id|pi_perf_cntr0_b_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_perf_cntr0_b_u
r_typedef
r_union
id|pi_perf_cntr0_b_u
(brace
DECL|member|pi_perf_cntr0_b_regval
id|bdrkreg_t
id|pi_perf_cntr0_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|pcb_rsvd
id|bdrkreg_t
id|pcb_rsvd
suffix:colon
l_int|23
suffix:semicolon
DECL|member|pcb_overflow
id|bdrkreg_t
id|pcb_overflow
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pcb_count_value
id|bdrkreg_t
id|pcb_count_value
suffix:colon
l_int|40
suffix:semicolon
DECL|member|pi_perf_cntr0_b_fld_s
)brace
id|pi_perf_cntr0_b_fld_s
suffix:semicolon
DECL|typedef|pi_perf_cntr0_b_u_t
)brace
id|pi_perf_cntr0_b_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register accesses the performance counter 1for each CPU.       *&n; * Each performance counter is 40-bits wide. On overflow, It wraps to   *&n; * zero, sets the overflow bit in this register, and sets the           *&n; * PERF_CNTR_OFLOW bit in the INT_PEND1 register.                       *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|pi_perf_cntr1_b_u
r_typedef
r_union
id|pi_perf_cntr1_b_u
(brace
DECL|member|pi_perf_cntr1_b_regval
id|bdrkreg_t
id|pi_perf_cntr1_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|pcb_count_value
id|bdrkreg_t
id|pcb_count_value
suffix:colon
l_int|40
suffix:semicolon
DECL|member|pcb_overflow
id|bdrkreg_t
id|pcb_overflow
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pcb_rsvd
id|bdrkreg_t
id|pcb_rsvd
suffix:colon
l_int|23
suffix:semicolon
DECL|member|pi_perf_cntr1_b_fld_s
)brace
id|pi_perf_cntr1_b_fld_s
suffix:semicolon
DECL|typedef|pi_perf_cntr1_b_u_t
)brace
id|pi_perf_cntr1_b_u_t
suffix:semicolon
macro_line|#else
DECL|union|pi_perf_cntr1_b_u
r_typedef
r_union
id|pi_perf_cntr1_b_u
(brace
DECL|member|pi_perf_cntr1_b_regval
id|bdrkreg_t
id|pi_perf_cntr1_b_regval
suffix:semicolon
r_struct
(brace
DECL|member|pcb_rsvd
id|bdrkreg_t
id|pcb_rsvd
suffix:colon
l_int|23
suffix:semicolon
DECL|member|pcb_overflow
id|bdrkreg_t
id|pcb_overflow
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pcb_count_value
id|bdrkreg_t
id|pcb_count_value
suffix:colon
l_int|40
suffix:semicolon
DECL|member|pi_perf_cntr1_b_fld_s
)brace
id|pi_perf_cntr1_b_fld_s
suffix:semicolon
DECL|typedef|pi_perf_cntr1_b_u_t
)brace
id|pi_perf_cntr1_b_u_t
suffix:semicolon
macro_line|#endif
macro_line|#endif /* __ASSEMBLY__ */
multiline_comment|/************************************************************************&n; *                                                                      *&n; *               MAKE ALL ADDITIONS AFTER THIS LINE                     *&n; *                                                                      *&n; ************************************************************************/
DECL|macro|PI_GFX_OFFSET
mdefine_line|#define PI_GFX_OFFSET&t;&t;(PI_GFX_PAGE_B - PI_GFX_PAGE_A)
DECL|macro|PI_GFX_PAGE_ENABLE
mdefine_line|#define PI_GFX_PAGE_ENABLE&t;0x0000010000000000LL
macro_line|#endif /* _ASM_IA64_SN_SN1_HUBPI_H */
eof
