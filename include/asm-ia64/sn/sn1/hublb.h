multiline_comment|/* $Id$&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1992 - 1997, 2000 Silicon Graphics, Inc.&n; * Copyright (C) 2000 by Colin Ngam&n; */
multiline_comment|/************************************************************************&n; *                                                                      *&n; *      WARNING!!!  WARNING!!!  WARNING!!!  WARNING!!!  WARNING!!!      *&n; *                                                                      *&n; * This file is created by an automated script. Any (minimal) changes   *&n; * made manually to this  file should be made with care.                *&n; *                                                                      *&n; *               MAKE ALL ADDITIONS TO THE END OF THIS FILE             *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifndef _ASM_SN_SN1_HUBLB_H
DECL|macro|_ASM_SN_SN1_HUBLB_H
mdefine_line|#define _ASM_SN_SN1_HUBLB_H
DECL|macro|LB_REV_ID
mdefine_line|#define    LB_REV_ID                 0x00600000    /*&n;                                                    * Bedrock Revision&n;                                                    * and ID&n;                                                    */
DECL|macro|LB_CPU_PERMISSION
mdefine_line|#define    LB_CPU_PERMISSION         0x00604000    /*&n;                                                    * CPU PIO access&n;                                                    * permission bits&n;                                                    */
DECL|macro|LB_CPU_PERM_OVRRD
mdefine_line|#define    LB_CPU_PERM_OVRRD         0x00604008    /*&n;                                                    * CPU PIO access&n;                                                    * permission bit&n;                                                    * override&n;                                                    */
DECL|macro|LB_IO_PERMISSION
mdefine_line|#define    LB_IO_PERMISSION          0x00604010    /*&n;                                                    * IO PIO access&n;                                                    * permission bits&n;                                                    */
DECL|macro|LB_SOFT_RESET
mdefine_line|#define    LB_SOFT_RESET             0x00604018    /*&n;                                                    * Soft reset the&n;                                                    * Bedrock chip&n;                                                    */
DECL|macro|LB_REGION_PRESENT
mdefine_line|#define    LB_REGION_PRESENT         0x00604020    /*&n;                                                    * Regions Present for&n;                                                    * Invalidates&n;                                                    */
DECL|macro|LB_NODES_ABSENT
mdefine_line|#define    LB_NODES_ABSENT           0x00604028    /*&n;                                                    * Nodes Absent for&n;                                                    * Invalidates&n;                                                    */
DECL|macro|LB_MICROLAN_CTL
mdefine_line|#define    LB_MICROLAN_CTL           0x00604030    /*&n;                                                    * Microlan Control&n;                                                    * (NIC)&n;                                                    */
DECL|macro|LB_ERROR_BITS
mdefine_line|#define    LB_ERROR_BITS             0x00604040    /*&n;                                                    * Local Block error&n;                                                    * bits&n;                                                    */
DECL|macro|LB_ERROR_MASK_CLR
mdefine_line|#define    LB_ERROR_MASK_CLR         0x00604048    /*&n;                                                    * Bit mask write to&n;                                                    * clear error bits&n;                                                    */
DECL|macro|LB_ERROR_HDR1
mdefine_line|#define    LB_ERROR_HDR1             0x00604050    /*&n;                                                    * Source, Suppl and&n;                                                    * Cmd fields&n;                                                    */
DECL|macro|LB_ERROR_HDR2
mdefine_line|#define    LB_ERROR_HDR2             0x00604058    /*&n;                                                    * Address field from&n;                                                    * first error&n;                                                    */
DECL|macro|LB_ERROR_DATA
mdefine_line|#define    LB_ERROR_DATA             0x00604060    /*&n;                                                    * Data flit (if any)&n;                                                    * from first error&n;                                                    */
DECL|macro|LB_DEBUG_SELECT
mdefine_line|#define    LB_DEBUG_SELECT           0x00604100    /*&n;                                                    * Choice of debug&n;                                                    * signals from chip&n;                                                    */
DECL|macro|LB_DEBUG_PINS
mdefine_line|#define    LB_DEBUG_PINS             0x00604108    /*&n;                                                    * Value on the chip&squot;s&n;                                                    * debug pins&n;                                                    */
DECL|macro|LB_RT_LOCAL_CTRL
mdefine_line|#define    LB_RT_LOCAL_CTRL          0x00604200    /*&n;                                                    * Local generation of&n;                                                    * real-time clock&n;                                                    */
DECL|macro|LB_RT_FILTER_CTRL
mdefine_line|#define    LB_RT_FILTER_CTRL         0x00604208    /*&n;                                                    * Control of&n;                                                    * filtering of global&n;                                                    * clock&n;                                                    */
DECL|macro|LB_SCRATCH_REG0
mdefine_line|#define    LB_SCRATCH_REG0           0x00608000    /* Scratch Register 0     */
DECL|macro|LB_SCRATCH_REG1
mdefine_line|#define    LB_SCRATCH_REG1           0x00608008    /* Scratch Register 1     */
DECL|macro|LB_SCRATCH_REG2
mdefine_line|#define    LB_SCRATCH_REG2           0x00608010    /* Scratch Register 2     */
DECL|macro|LB_SCRATCH_REG3
mdefine_line|#define    LB_SCRATCH_REG3           0x00608018    /* Scratch Register 3     */
DECL|macro|LB_SCRATCH_REG4
mdefine_line|#define    LB_SCRATCH_REG4           0x00608020    /* Scratch Register 4     */
DECL|macro|LB_SCRATCH_REG0_WZ
mdefine_line|#define    LB_SCRATCH_REG0_WZ        0x00608040    /*&n;                                                    * Scratch Register 0&n;                                                    * (WZ alias)&n;                                                    */
DECL|macro|LB_SCRATCH_REG1_WZ
mdefine_line|#define    LB_SCRATCH_REG1_WZ        0x00608048    /*&n;                                                    * Scratch Register 1&n;                                                    * (WZ alias)&n;                                                    */
DECL|macro|LB_SCRATCH_REG2_WZ
mdefine_line|#define    LB_SCRATCH_REG2_WZ        0x00608050    /*&n;                                                    * Scratch Register 2&n;                                                    * (WZ alias)&n;                                                    */
DECL|macro|LB_SCRATCH_REG3_RZ
mdefine_line|#define    LB_SCRATCH_REG3_RZ        0x00608058    /*&n;                                                    * Scratch Register 3&n;                                                    * (RZ alias)&n;                                                    */
DECL|macro|LB_SCRATCH_REG4_RZ
mdefine_line|#define    LB_SCRATCH_REG4_RZ        0x00608060    /*&n;                                                    * Scratch Register 4&n;                                                    * (RZ alias)&n;                                                    */
DECL|macro|LB_VECTOR_PARMS
mdefine_line|#define    LB_VECTOR_PARMS           0x0060C000    /*&n;                                                    * Vector PIO&n;                                                    * parameters&n;                                                    */
DECL|macro|LB_VECTOR_ROUTE
mdefine_line|#define    LB_VECTOR_ROUTE           0x0060C008    /*&n;                                                    * Vector PIO Vector&n;                                                    * Route&n;                                                    */
DECL|macro|LB_VECTOR_DATA
mdefine_line|#define    LB_VECTOR_DATA            0x0060C010    /*&n;                                                    * Vector PIO Write&n;                                                    * Data&n;                                                    */
DECL|macro|LB_VECTOR_STATUS
mdefine_line|#define    LB_VECTOR_STATUS          0x0060C020    /*&n;                                                    * Vector PIO Return&n;                                                    * Status&n;                                                    */
DECL|macro|LB_VECTOR_RETURN
mdefine_line|#define    LB_VECTOR_RETURN          0x0060C028    /*&n;                                                    * Vector PIO Return&n;                                                    * Route&n;                                                    */
DECL|macro|LB_VECTOR_READ_DATA
mdefine_line|#define    LB_VECTOR_READ_DATA       0x0060C030    /*&n;                                                    * Vector PIO Read&n;                                                    * Data&n;                                                    */
DECL|macro|LB_VECTOR_STATUS_CLEAR
mdefine_line|#define    LB_VECTOR_STATUS_CLEAR    0x0060C038    /*&n;                                                    * Clear Vector PIO&n;                                                    * Return Status&n;                                                    */
macro_line|#ifdef _LANGUAGE_C
multiline_comment|/************************************************************************&n; *                                                                      *&n; * Description:  This register contains information that allows         *&n; * exploratory software to probe for chip type. This is also the        *&n; * register that sets this node&squot;s ID and the size of each region        *&n; * (which affects the maximum possible system size). IBM assigns the    *&n; * values for the REVISION, PART_NUMBER and MANUFACTURER fields, in     *&n; * accordance with the IEEE 1149.1 standard; SGI is not at liberty to   *&n; * unilaterally change the values of these fields.                      *&n; *  .                                                                   *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|lb_rev_id_u
r_typedef
r_union
id|lb_rev_id_u
(brace
DECL|member|lb_rev_id_regval
id|bdrkreg_t
id|lb_rev_id_regval
suffix:semicolon
r_struct
(brace
DECL|member|ri_reserved_2
id|bdrkreg_t
id|ri_reserved_2
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ri_manufacturer
id|bdrkreg_t
id|ri_manufacturer
suffix:colon
l_int|11
suffix:semicolon
DECL|member|ri_part_number
id|bdrkreg_t
id|ri_part_number
suffix:colon
l_int|16
suffix:semicolon
DECL|member|ri_revision
id|bdrkreg_t
id|ri_revision
suffix:colon
l_int|4
suffix:semicolon
DECL|member|ri_node_id
id|bdrkreg_t
id|ri_node_id
suffix:colon
l_int|8
suffix:semicolon
DECL|member|ri_reserved_1
id|bdrkreg_t
id|ri_reserved_1
suffix:colon
l_int|6
suffix:semicolon
DECL|member|ri_region_size
id|bdrkreg_t
id|ri_region_size
suffix:colon
l_int|2
suffix:semicolon
DECL|member|ri_reserved
id|bdrkreg_t
id|ri_reserved
suffix:colon
l_int|16
suffix:semicolon
DECL|member|lb_rev_id_fld_s
)brace
id|lb_rev_id_fld_s
suffix:semicolon
DECL|typedef|lb_rev_id_u_t
)brace
id|lb_rev_id_u_t
suffix:semicolon
macro_line|#else
DECL|union|lb_rev_id_u
r_typedef
r_union
id|lb_rev_id_u
(brace
DECL|member|lb_rev_id_regval
id|bdrkreg_t
id|lb_rev_id_regval
suffix:semicolon
r_struct
(brace
DECL|member|ri_reserved
id|bdrkreg_t
id|ri_reserved
suffix:colon
l_int|16
suffix:semicolon
DECL|member|ri_region_size
id|bdrkreg_t
id|ri_region_size
suffix:colon
l_int|2
suffix:semicolon
DECL|member|ri_reserved_1
id|bdrkreg_t
id|ri_reserved_1
suffix:colon
l_int|6
suffix:semicolon
DECL|member|ri_node_id
id|bdrkreg_t
id|ri_node_id
suffix:colon
l_int|8
suffix:semicolon
DECL|member|ri_revision
id|bdrkreg_t
id|ri_revision
suffix:colon
l_int|4
suffix:semicolon
DECL|member|ri_part_number
id|bdrkreg_t
id|ri_part_number
suffix:colon
l_int|16
suffix:semicolon
DECL|member|ri_manufacturer
id|bdrkreg_t
id|ri_manufacturer
suffix:colon
l_int|11
suffix:semicolon
DECL|member|ri_reserved_2
id|bdrkreg_t
id|ri_reserved_2
suffix:colon
l_int|1
suffix:semicolon
DECL|member|lb_rev_id_fld_s
)brace
id|lb_rev_id_fld_s
suffix:semicolon
DECL|typedef|lb_rev_id_u_t
)brace
id|lb_rev_id_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register contains the PI-access-rights bit-vector for the      *&n; * LB, NI, XB and MD portions of the Bedrock local register space. If   *&n; * a bit in the bit-vector is set, the region corresponding to that     *&n; * bit has read/write permission on the LB, NI, XB and MD local         *&n; * registers. If the bit is clear, that region has no write access to   *&n; * the local registers and no read access if the read will cause any    *&n; * state change. If a write or a read with side effects is attempted    *&n; * by a PI in a region for which access is restricted, the LB will      *&n; * not perform the operation and will send back a reply which           *&n; * indicates an error.                                                  *&n; *                                                                      *&n; ************************************************************************/
DECL|union|lb_cpu_permission_u
r_typedef
r_union
id|lb_cpu_permission_u
(brace
DECL|member|lb_cpu_permission_regval
id|bdrkreg_t
id|lb_cpu_permission_regval
suffix:semicolon
r_struct
(brace
DECL|member|cp_cpu_access
id|bdrkreg_t
id|cp_cpu_access
suffix:colon
l_int|64
suffix:semicolon
DECL|member|lb_cpu_permission_fld_s
)brace
id|lb_cpu_permission_fld_s
suffix:semicolon
DECL|typedef|lb_cpu_permission_u_t
)brace
id|lb_cpu_permission_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  A write to this register of the 64-bit value &quot;SGIrules&quot; will        *&n; * cause the bit in the LB_CPU_PROTECT register corresponding to the    *&n; * region of the requester to be set.                                   *&n; *                                                                      *&n; ************************************************************************/
DECL|union|lb_cpu_perm_ovrrd_u
r_typedef
r_union
id|lb_cpu_perm_ovrrd_u
(brace
DECL|member|lb_cpu_perm_ovrrd_regval
id|bdrkreg_t
id|lb_cpu_perm_ovrrd_regval
suffix:semicolon
r_struct
(brace
DECL|member|cpo_cpu_perm_ovr
id|bdrkreg_t
id|cpo_cpu_perm_ovr
suffix:colon
l_int|64
suffix:semicolon
DECL|member|lb_cpu_perm_ovrrd_fld_s
)brace
id|lb_cpu_perm_ovrrd_fld_s
suffix:semicolon
DECL|typedef|lb_cpu_perm_ovrrd_u_t
)brace
id|lb_cpu_perm_ovrrd_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register contains the II-access-rights bit-vector for the      *&n; * LB, NI, XB and MD portions of the Bedrock local register space. If   *&n; * a bit in the bit-vector is set, the region corresponding to that     *&n; * bit has read/write permission on the LB, NI, XB and MD local         *&n; * registers. If the bit is clear, then that region has no write        *&n; * access to the local registers and no read access if the read         *&n; * results in any state change. If a write or a read with side          *&n; * effects is attempted by an II in a region for which access is        *&n; * restricted, the LB will not perform the operation and will send      *&n; * back a reply which indicates an error.                               *&n; *                                                                      *&n; ************************************************************************/
DECL|union|lb_io_permission_u
r_typedef
r_union
id|lb_io_permission_u
(brace
DECL|member|lb_io_permission_regval
id|bdrkreg_t
id|lb_io_permission_regval
suffix:semicolon
r_struct
(brace
DECL|member|ip_io_permission
id|bdrkreg_t
id|ip_io_permission
suffix:colon
l_int|64
suffix:semicolon
DECL|member|lb_io_permission_fld_s
)brace
id|lb_io_permission_fld_s
suffix:semicolon
DECL|typedef|lb_io_permission_u_t
)brace
id|lb_io_permission_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  A write to this bit resets the Bedrock chip with a soft reset.      *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|lb_soft_reset_u
r_typedef
r_union
id|lb_soft_reset_u
(brace
DECL|member|lb_soft_reset_regval
id|bdrkreg_t
id|lb_soft_reset_regval
suffix:semicolon
r_struct
(brace
DECL|member|sr_soft_reset
id|bdrkreg_t
id|sr_soft_reset
suffix:colon
l_int|1
suffix:semicolon
DECL|member|sr_reserved
id|bdrkreg_t
id|sr_reserved
suffix:colon
l_int|63
suffix:semicolon
DECL|member|lb_soft_reset_fld_s
)brace
id|lb_soft_reset_fld_s
suffix:semicolon
DECL|typedef|lb_soft_reset_u_t
)brace
id|lb_soft_reset_u_t
suffix:semicolon
macro_line|#else
DECL|union|lb_soft_reset_u
r_typedef
r_union
id|lb_soft_reset_u
(brace
DECL|member|lb_soft_reset_regval
id|bdrkreg_t
id|lb_soft_reset_regval
suffix:semicolon
r_struct
(brace
DECL|member|sr_reserved
id|bdrkreg_t
id|sr_reserved
suffix:colon
l_int|63
suffix:semicolon
DECL|member|sr_soft_reset
id|bdrkreg_t
id|sr_soft_reset
suffix:colon
l_int|1
suffix:semicolon
DECL|member|lb_soft_reset_fld_s
)brace
id|lb_soft_reset_fld_s
suffix:semicolon
DECL|typedef|lb_soft_reset_u_t
)brace
id|lb_soft_reset_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register indicates which regions are present and capable of    *&n; * receiving an invalidate (INVAL) request. The LB samples this         *&n; * register at the start of processing each LINVAL. When an LINVAL      *&n; * indicates that a particular PI unit might hold a shared copy of a    *&n; * cache block but this PI is in a region which is not present (i.e.,   *&n; * its bit in LB_REGION_PRESENT is clear), then the LB sends an IVACK   *&n; * reply packet on behalf of this PI. The REGION_SIZE field in the      *&n; * LB_REV_ID register determines the number of nodes per region (and    *&n; * hence, the number of PI units which share a common bit in the        *&n; * LB_REGION_PRESENT register).                                         *&n; *                                                                      *&n; ************************************************************************/
DECL|union|lb_region_present_u
r_typedef
r_union
id|lb_region_present_u
(brace
DECL|member|lb_region_present_regval
id|bdrkreg_t
id|lb_region_present_regval
suffix:semicolon
r_struct
(brace
DECL|member|rp_present_bits
id|bdrkreg_t
id|rp_present_bits
suffix:colon
l_int|64
suffix:semicolon
DECL|member|lb_region_present_fld_s
)brace
id|lb_region_present_fld_s
suffix:semicolon
DECL|typedef|lb_region_present_u_t
)brace
id|lb_region_present_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; * Description:  This register indicates which nodes are absent and     *&n; * not capable of receiving an invalidate (INVAL) request. The LB       *&n; * samples this register at the start of processing each LINVAL. When   *&n; * an LINVAL indicates that a particular PI unit might hold a shared    *&n; * copy of a cache block but this PI unit&squot;s node is not present         *&n; * (i.e., its node ID is listed in the LB_NODES_ABSENT register),       *&n; * then the LB sends an IVACK reply packet on behalf of this PI.        *&n; *                                                                      *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|lb_nodes_absent_u
r_typedef
r_union
id|lb_nodes_absent_u
(brace
DECL|member|lb_nodes_absent_regval
id|bdrkreg_t
id|lb_nodes_absent_regval
suffix:semicolon
r_struct
(brace
DECL|member|na_node_0
id|bdrkreg_t
id|na_node_0
suffix:colon
l_int|8
suffix:semicolon
DECL|member|na_reserved_3
id|bdrkreg_t
id|na_reserved_3
suffix:colon
l_int|7
suffix:semicolon
DECL|member|na_node_0_valid
id|bdrkreg_t
id|na_node_0_valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|na_node_1
id|bdrkreg_t
id|na_node_1
suffix:colon
l_int|8
suffix:semicolon
DECL|member|na_reserved_2
id|bdrkreg_t
id|na_reserved_2
suffix:colon
l_int|7
suffix:semicolon
DECL|member|na_node_1_valid
id|bdrkreg_t
id|na_node_1_valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|na_node_2
id|bdrkreg_t
id|na_node_2
suffix:colon
l_int|8
suffix:semicolon
DECL|member|na_reserved_1
id|bdrkreg_t
id|na_reserved_1
suffix:colon
l_int|7
suffix:semicolon
DECL|member|na_node_2_valid
id|bdrkreg_t
id|na_node_2_valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|na_node_3
id|bdrkreg_t
id|na_node_3
suffix:colon
l_int|8
suffix:semicolon
DECL|member|na_reserved
id|bdrkreg_t
id|na_reserved
suffix:colon
l_int|7
suffix:semicolon
DECL|member|na_node_3_valid
id|bdrkreg_t
id|na_node_3_valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|lb_nodes_absent_fld_s
)brace
id|lb_nodes_absent_fld_s
suffix:semicolon
DECL|typedef|lb_nodes_absent_u_t
)brace
id|lb_nodes_absent_u_t
suffix:semicolon
macro_line|#else
DECL|union|lb_nodes_absent_u
r_typedef
r_union
id|lb_nodes_absent_u
(brace
DECL|member|lb_nodes_absent_regval
id|bdrkreg_t
id|lb_nodes_absent_regval
suffix:semicolon
r_struct
(brace
DECL|member|na_node_3_valid
id|bdrkreg_t
id|na_node_3_valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|na_reserved
id|bdrkreg_t
id|na_reserved
suffix:colon
l_int|7
suffix:semicolon
DECL|member|na_node_3
id|bdrkreg_t
id|na_node_3
suffix:colon
l_int|8
suffix:semicolon
DECL|member|na_node_2_valid
id|bdrkreg_t
id|na_node_2_valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|na_reserved_1
id|bdrkreg_t
id|na_reserved_1
suffix:colon
l_int|7
suffix:semicolon
DECL|member|na_node_2
id|bdrkreg_t
id|na_node_2
suffix:colon
l_int|8
suffix:semicolon
DECL|member|na_node_1_valid
id|bdrkreg_t
id|na_node_1_valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|na_reserved_2
id|bdrkreg_t
id|na_reserved_2
suffix:colon
l_int|7
suffix:semicolon
DECL|member|na_node_1
id|bdrkreg_t
id|na_node_1
suffix:colon
l_int|8
suffix:semicolon
DECL|member|na_node_0_valid
id|bdrkreg_t
id|na_node_0_valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|na_reserved_3
id|bdrkreg_t
id|na_reserved_3
suffix:colon
l_int|7
suffix:semicolon
DECL|member|na_node_0
id|bdrkreg_t
id|na_node_0
suffix:colon
l_int|8
suffix:semicolon
DECL|member|lb_nodes_absent_fld_s
)brace
id|lb_nodes_absent_fld_s
suffix:semicolon
DECL|typedef|lb_nodes_absent_u_t
)brace
id|lb_nodes_absent_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register provides access to the Number-In-a-Can add-only       *&n; * serial PROM that is used to store node board serial number and       *&n; * configuration information. (Refer to NIC datasheet Dallas 1990A      *&n; * that is viewable at                                                  *&n; * URL::http://www.dalsemi.com/DocControl/PDFs/pdfindex.html). Data     *&n; * comes from this interface LSB first.                                 *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|lb_microlan_ctl_u
r_typedef
r_union
id|lb_microlan_ctl_u
(brace
DECL|member|lb_microlan_ctl_regval
id|bdrkreg_t
id|lb_microlan_ctl_regval
suffix:semicolon
r_struct
(brace
DECL|member|mc_rd_data
id|bdrkreg_t
id|mc_rd_data
suffix:colon
l_int|1
suffix:semicolon
DECL|member|mc_done
id|bdrkreg_t
id|mc_done
suffix:colon
l_int|1
suffix:semicolon
DECL|member|mc_sample
id|bdrkreg_t
id|mc_sample
suffix:colon
l_int|8
suffix:semicolon
DECL|member|mc_pulse
id|bdrkreg_t
id|mc_pulse
suffix:colon
l_int|10
suffix:semicolon
DECL|member|mc_clkdiv_phi0
id|bdrkreg_t
id|mc_clkdiv_phi0
suffix:colon
l_int|7
suffix:semicolon
DECL|member|mc_clkdiv_phi1
id|bdrkreg_t
id|mc_clkdiv_phi1
suffix:colon
l_int|7
suffix:semicolon
DECL|member|mc_reserved
id|bdrkreg_t
id|mc_reserved
suffix:colon
l_int|30
suffix:semicolon
DECL|member|lb_microlan_ctl_fld_s
)brace
id|lb_microlan_ctl_fld_s
suffix:semicolon
DECL|typedef|lb_microlan_ctl_u_t
)brace
id|lb_microlan_ctl_u_t
suffix:semicolon
macro_line|#else
DECL|union|lb_microlan_ctl_u
r_typedef
r_union
id|lb_microlan_ctl_u
(brace
DECL|member|lb_microlan_ctl_regval
id|bdrkreg_t
id|lb_microlan_ctl_regval
suffix:semicolon
r_struct
(brace
DECL|member|mc_reserved
id|bdrkreg_t
id|mc_reserved
suffix:colon
l_int|30
suffix:semicolon
DECL|member|mc_clkdiv_phi1
id|bdrkreg_t
id|mc_clkdiv_phi1
suffix:colon
l_int|7
suffix:semicolon
DECL|member|mc_clkdiv_phi0
id|bdrkreg_t
id|mc_clkdiv_phi0
suffix:colon
l_int|7
suffix:semicolon
DECL|member|mc_pulse
id|bdrkreg_t
id|mc_pulse
suffix:colon
l_int|10
suffix:semicolon
DECL|member|mc_sample
id|bdrkreg_t
id|mc_sample
suffix:colon
l_int|8
suffix:semicolon
DECL|member|mc_done
id|bdrkreg_t
id|mc_done
suffix:colon
l_int|1
suffix:semicolon
DECL|member|mc_rd_data
id|bdrkreg_t
id|mc_rd_data
suffix:colon
l_int|1
suffix:semicolon
DECL|member|lb_microlan_ctl_fld_s
)brace
id|lb_microlan_ctl_fld_s
suffix:semicolon
DECL|typedef|lb_microlan_ctl_u_t
)brace
id|lb_microlan_ctl_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; * Description:  This register contains the LB error status bits.       *&n; * Whenever a particular type of error occurs, the LB sets its bit in   *&n; * this register so that software will be aware that such an event      *&n; * has happened. Reads from this register are non-destructive and the   *&n; * contents of this register remain intact across reset operations.     *&n; * Whenever any of these bits is set, the LB will assert its            *&n; * interrupt request output signals that go to the PI units.            *&n; *  Software can simulate the occurrence of an error by first writing   *&n; * appropriate values into the LB_ERROR_HDR1, LB_ERROR_HDR2 and         *&n; * LB_ERROR_DATA registers, and then writing to the LB_ERROR_BITS       *&n; * register to set the error bits in a particular way. Setting one or   *&n; * more error bits will cause the LB to interrupt a processor and       *&n; * invoke error-handling software.                                      *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|lb_error_bits_u
r_typedef
r_union
id|lb_error_bits_u
(brace
DECL|member|lb_error_bits_regval
id|bdrkreg_t
id|lb_error_bits_regval
suffix:semicolon
r_struct
(brace
DECL|member|eb_rq_bad_cmd
id|bdrkreg_t
id|eb_rq_bad_cmd
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eb_rp_bad_cmd
id|bdrkreg_t
id|eb_rp_bad_cmd
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eb_rq_short
id|bdrkreg_t
id|eb_rq_short
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eb_rp_short
id|bdrkreg_t
id|eb_rp_short
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eb_rq_long
id|bdrkreg_t
id|eb_rq_long
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eb_rp_long
id|bdrkreg_t
id|eb_rp_long
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eb_rq_bad_data
id|bdrkreg_t
id|eb_rq_bad_data
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eb_rp_bad_data
id|bdrkreg_t
id|eb_rp_bad_data
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eb_rq_bad_addr
id|bdrkreg_t
id|eb_rq_bad_addr
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eb_rq_bad_linval
id|bdrkreg_t
id|eb_rq_bad_linval
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eb_gclk_drop
id|bdrkreg_t
id|eb_gclk_drop
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eb_reserved
id|bdrkreg_t
id|eb_reserved
suffix:colon
l_int|53
suffix:semicolon
DECL|member|lb_error_bits_fld_s
)brace
id|lb_error_bits_fld_s
suffix:semicolon
DECL|typedef|lb_error_bits_u_t
)brace
id|lb_error_bits_u_t
suffix:semicolon
macro_line|#else
DECL|union|lb_error_bits_u
r_typedef
r_union
id|lb_error_bits_u
(brace
DECL|member|lb_error_bits_regval
id|bdrkreg_t
id|lb_error_bits_regval
suffix:semicolon
r_struct
(brace
DECL|member|eb_reserved
id|bdrkreg_t
id|eb_reserved
suffix:colon
l_int|53
suffix:semicolon
DECL|member|eb_gclk_drop
id|bdrkreg_t
id|eb_gclk_drop
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eb_rq_bad_linval
id|bdrkreg_t
id|eb_rq_bad_linval
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eb_rq_bad_addr
id|bdrkreg_t
id|eb_rq_bad_addr
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eb_rp_bad_data
id|bdrkreg_t
id|eb_rp_bad_data
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eb_rq_bad_data
id|bdrkreg_t
id|eb_rq_bad_data
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eb_rp_long
id|bdrkreg_t
id|eb_rp_long
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eb_rq_long
id|bdrkreg_t
id|eb_rq_long
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eb_rp_short
id|bdrkreg_t
id|eb_rp_short
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eb_rq_short
id|bdrkreg_t
id|eb_rq_short
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eb_rp_bad_cmd
id|bdrkreg_t
id|eb_rp_bad_cmd
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eb_rq_bad_cmd
id|bdrkreg_t
id|eb_rq_bad_cmd
suffix:colon
l_int|1
suffix:semicolon
DECL|member|lb_error_bits_fld_s
)brace
id|lb_error_bits_fld_s
suffix:semicolon
DECL|typedef|lb_error_bits_u_t
)brace
id|lb_error_bits_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register lets software clear some of the bits in the           *&n; * LB_ERROR_BITS register without affecting other bits.  Essentially,   *&n; * it provides bit mask functionality. When software writes to the      *&n; * LB_ERROR_MASK_CLR register, the bits which are set in the data       *&n; * value indicate which bits are to be cleared in LB_ERROR_BITS. If a   *&n; * bit is clear in the data value written to the LB_ERROR_MASK_CLR      *&n; * register, then its corresponding bit in the LB_ERROR_BITS register   *&n; * is not affected. Hence, software can atomically clear any subset     *&n; * of the error bits in the LB_ERROR_BITS register.                     *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|lb_error_mask_clr_u
r_typedef
r_union
id|lb_error_mask_clr_u
(brace
DECL|member|lb_error_mask_clr_regval
id|bdrkreg_t
id|lb_error_mask_clr_regval
suffix:semicolon
r_struct
(brace
DECL|member|emc_clr_rq_bad_cmd
id|bdrkreg_t
id|emc_clr_rq_bad_cmd
suffix:colon
l_int|1
suffix:semicolon
DECL|member|emc_clr_rp_bad_cmd
id|bdrkreg_t
id|emc_clr_rp_bad_cmd
suffix:colon
l_int|1
suffix:semicolon
DECL|member|emc_clr_rq_short
id|bdrkreg_t
id|emc_clr_rq_short
suffix:colon
l_int|1
suffix:semicolon
DECL|member|emc_clr_rp_short
id|bdrkreg_t
id|emc_clr_rp_short
suffix:colon
l_int|1
suffix:semicolon
DECL|member|emc_clr_rq_long
id|bdrkreg_t
id|emc_clr_rq_long
suffix:colon
l_int|1
suffix:semicolon
DECL|member|emc_clr_rp_long
id|bdrkreg_t
id|emc_clr_rp_long
suffix:colon
l_int|1
suffix:semicolon
DECL|member|emc_clr_rq_bad_data
id|bdrkreg_t
id|emc_clr_rq_bad_data
suffix:colon
l_int|1
suffix:semicolon
DECL|member|emc_clr_rp_bad_data
id|bdrkreg_t
id|emc_clr_rp_bad_data
suffix:colon
l_int|1
suffix:semicolon
DECL|member|emc_clr_rq_bad_addr
id|bdrkreg_t
id|emc_clr_rq_bad_addr
suffix:colon
l_int|1
suffix:semicolon
DECL|member|emc_clr_rq_bad_linval
id|bdrkreg_t
id|emc_clr_rq_bad_linval
suffix:colon
l_int|1
suffix:semicolon
DECL|member|emc_clr_gclk_drop
id|bdrkreg_t
id|emc_clr_gclk_drop
suffix:colon
l_int|1
suffix:semicolon
DECL|member|emc_reserved
id|bdrkreg_t
id|emc_reserved
suffix:colon
l_int|53
suffix:semicolon
DECL|member|lb_error_mask_clr_fld_s
)brace
id|lb_error_mask_clr_fld_s
suffix:semicolon
DECL|typedef|lb_error_mask_clr_u_t
)brace
id|lb_error_mask_clr_u_t
suffix:semicolon
macro_line|#else
DECL|union|lb_error_mask_clr_u
r_typedef
r_union
id|lb_error_mask_clr_u
(brace
DECL|member|lb_error_mask_clr_regval
id|bdrkreg_t
id|lb_error_mask_clr_regval
suffix:semicolon
r_struct
(brace
DECL|member|emc_reserved
id|bdrkreg_t
id|emc_reserved
suffix:colon
l_int|53
suffix:semicolon
DECL|member|emc_clr_gclk_drop
id|bdrkreg_t
id|emc_clr_gclk_drop
suffix:colon
l_int|1
suffix:semicolon
DECL|member|emc_clr_rq_bad_linval
id|bdrkreg_t
id|emc_clr_rq_bad_linval
suffix:colon
l_int|1
suffix:semicolon
DECL|member|emc_clr_rq_bad_addr
id|bdrkreg_t
id|emc_clr_rq_bad_addr
suffix:colon
l_int|1
suffix:semicolon
DECL|member|emc_clr_rp_bad_data
id|bdrkreg_t
id|emc_clr_rp_bad_data
suffix:colon
l_int|1
suffix:semicolon
DECL|member|emc_clr_rq_bad_data
id|bdrkreg_t
id|emc_clr_rq_bad_data
suffix:colon
l_int|1
suffix:semicolon
DECL|member|emc_clr_rp_long
id|bdrkreg_t
id|emc_clr_rp_long
suffix:colon
l_int|1
suffix:semicolon
DECL|member|emc_clr_rq_long
id|bdrkreg_t
id|emc_clr_rq_long
suffix:colon
l_int|1
suffix:semicolon
DECL|member|emc_clr_rp_short
id|bdrkreg_t
id|emc_clr_rp_short
suffix:colon
l_int|1
suffix:semicolon
DECL|member|emc_clr_rq_short
id|bdrkreg_t
id|emc_clr_rq_short
suffix:colon
l_int|1
suffix:semicolon
DECL|member|emc_clr_rp_bad_cmd
id|bdrkreg_t
id|emc_clr_rp_bad_cmd
suffix:colon
l_int|1
suffix:semicolon
DECL|member|emc_clr_rq_bad_cmd
id|bdrkreg_t
id|emc_clr_rq_bad_cmd
suffix:colon
l_int|1
suffix:semicolon
DECL|member|lb_error_mask_clr_fld_s
)brace
id|lb_error_mask_clr_fld_s
suffix:semicolon
DECL|typedef|lb_error_mask_clr_u_t
)brace
id|lb_error_mask_clr_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  If the LB detects an error when VALID==0 in the LB_ERROR_HDR1       *&n; * register, then it saves the contents of the offending packet&squot;s       *&n; * header flit in the LB_ERROR_HDR1 and LB_ERROR_HDR2 registers, sets   *&n; * the VALID bit in LB_ERROR_HDR1 and clears the OVERRUN bit in         *&n; * LB_ERROR_HDR1 (and it will also set the corresponding bit in the     *&n; * LB_ERROR_BITS register). The ERR_TYPE field indicates specifically   *&n; * what kind of error occurred.  Its encoding corresponds to the bit    *&n; * positions in the LB_ERROR_BITS register (e.g., ERR_TYPE==5           *&n; * indicates a RP_LONG error).  If an error (of any type except         *&n; * GCLK_DROP) subsequently happens while VALID==1, then the LB sets     *&n; * the OVERRUN bit in LB_ERROR_HDR1. This register is not relevant      *&n; * when a GCLK_DROP error occurs; the LB does not even attempt to       *&n; * change the ERR_TYPE, VALID or OVERRUN field when a GCLK_DROP error   *&n; * happens.                                                             *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|lb_error_hdr1_u
r_typedef
r_union
id|lb_error_hdr1_u
(brace
DECL|member|lb_error_hdr1_regval
id|bdrkreg_t
id|lb_error_hdr1_regval
suffix:semicolon
r_struct
(brace
DECL|member|eh_command
id|bdrkreg_t
id|eh_command
suffix:colon
l_int|7
suffix:semicolon
DECL|member|eh_reserved_5
id|bdrkreg_t
id|eh_reserved_5
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eh_suppl
id|bdrkreg_t
id|eh_suppl
suffix:colon
l_int|11
suffix:semicolon
DECL|member|eh_reserved_4
id|bdrkreg_t
id|eh_reserved_4
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eh_source
id|bdrkreg_t
id|eh_source
suffix:colon
l_int|11
suffix:semicolon
DECL|member|eh_reserved_3
id|bdrkreg_t
id|eh_reserved_3
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eh_err_type
id|bdrkreg_t
id|eh_err_type
suffix:colon
l_int|4
suffix:semicolon
DECL|member|eh_reserved_2
id|bdrkreg_t
id|eh_reserved_2
suffix:colon
l_int|4
suffix:semicolon
DECL|member|eh_overrun
id|bdrkreg_t
id|eh_overrun
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eh_reserved_1
id|bdrkreg_t
id|eh_reserved_1
suffix:colon
l_int|3
suffix:semicolon
DECL|member|eh_valid
id|bdrkreg_t
id|eh_valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eh_reserved
id|bdrkreg_t
id|eh_reserved
suffix:colon
l_int|19
suffix:semicolon
DECL|member|lb_error_hdr1_fld_s
)brace
id|lb_error_hdr1_fld_s
suffix:semicolon
DECL|typedef|lb_error_hdr1_u_t
)brace
id|lb_error_hdr1_u_t
suffix:semicolon
macro_line|#else
DECL|union|lb_error_hdr1_u
r_typedef
r_union
id|lb_error_hdr1_u
(brace
DECL|member|lb_error_hdr1_regval
id|bdrkreg_t
id|lb_error_hdr1_regval
suffix:semicolon
r_struct
(brace
DECL|member|eh_reserved
id|bdrkreg_t
id|eh_reserved
suffix:colon
l_int|19
suffix:semicolon
DECL|member|eh_valid
id|bdrkreg_t
id|eh_valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eh_reserved_1
id|bdrkreg_t
id|eh_reserved_1
suffix:colon
l_int|3
suffix:semicolon
DECL|member|eh_overrun
id|bdrkreg_t
id|eh_overrun
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eh_reserved_2
id|bdrkreg_t
id|eh_reserved_2
suffix:colon
l_int|4
suffix:semicolon
DECL|member|eh_err_type
id|bdrkreg_t
id|eh_err_type
suffix:colon
l_int|4
suffix:semicolon
DECL|member|eh_reserved_3
id|bdrkreg_t
id|eh_reserved_3
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eh_source
id|bdrkreg_t
id|eh_source
suffix:colon
l_int|11
suffix:semicolon
DECL|member|eh_reserved_4
id|bdrkreg_t
id|eh_reserved_4
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eh_suppl
id|bdrkreg_t
id|eh_suppl
suffix:colon
l_int|11
suffix:semicolon
DECL|member|eh_reserved_5
id|bdrkreg_t
id|eh_reserved_5
suffix:colon
l_int|1
suffix:semicolon
DECL|member|eh_command
id|bdrkreg_t
id|eh_command
suffix:colon
l_int|7
suffix:semicolon
DECL|member|lb_error_hdr1_fld_s
)brace
id|lb_error_hdr1_fld_s
suffix:semicolon
DECL|typedef|lb_error_hdr1_u_t
)brace
id|lb_error_hdr1_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  Contents of the Address field from header flit of first packet      *&n; * that causes an error. This register is not relevant when a           *&n; * GCLK_DROP error occurs.                                              *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|lb_error_hdr2_u
r_typedef
r_union
id|lb_error_hdr2_u
(brace
DECL|member|lb_error_hdr2_regval
id|bdrkreg_t
id|lb_error_hdr2_regval
suffix:semicolon
r_struct
(brace
DECL|member|eh_address
id|bdrkreg_t
id|eh_address
suffix:colon
l_int|38
suffix:semicolon
DECL|member|eh_reserved
id|bdrkreg_t
id|eh_reserved
suffix:colon
l_int|26
suffix:semicolon
DECL|member|lb_error_hdr2_fld_s
)brace
id|lb_error_hdr2_fld_s
suffix:semicolon
DECL|typedef|lb_error_hdr2_u_t
)brace
id|lb_error_hdr2_u_t
suffix:semicolon
macro_line|#else
DECL|union|lb_error_hdr2_u
r_typedef
r_union
id|lb_error_hdr2_u
(brace
DECL|member|lb_error_hdr2_regval
id|bdrkreg_t
id|lb_error_hdr2_regval
suffix:semicolon
r_struct
(brace
DECL|member|eh_reserved
id|bdrkreg_t
id|eh_reserved
suffix:colon
l_int|26
suffix:semicolon
DECL|member|eh_address
id|bdrkreg_t
id|eh_address
suffix:colon
l_int|38
suffix:semicolon
DECL|member|lb_error_hdr2_fld_s
)brace
id|lb_error_hdr2_fld_s
suffix:semicolon
DECL|typedef|lb_error_hdr2_u_t
)brace
id|lb_error_hdr2_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; * Description:  This register accompanies the LB_ERROR_HDR1 and        *&n; * LB_ERROR_HDR2 registers.  The LB updates the value in this           *&n; * register when an incoming packet with a data flit causes an error    *&n; * while VALID==0 in the LB_ERROR_HDR1 register.  This register         *&n; * retains the contents of the data flit from the incoming packet       *&n; * that caused the error. This register is relevant for the following   *&n; * types of errors:                                                     *&n; * &lt;UL &gt;                                                                *&n; * &lt;UL &gt;                                                                *&n; * &lt;UL &gt;                                                                *&n; * &lt;UL &gt;                                                                *&n; * &lt;UL &gt;                                                                *&n; * &lt;LI &gt;RQ_BAD_LINVAL for a LINVAL request.                             *&n; * &lt;LI &gt;RQ_BAD_ADDR for a normal or vector PIO request.                 *&n; * &lt;LI &gt;RP_BAD_DATA for a vector PIO reply.                             *&n; * &lt;LI &gt;RQ_BAD DATA for an incoming request with data.                  *&n; * &lt;LI &gt;RP_LONG for a vector PIO reply.                                 *&n; * &lt;LI &gt;RQ_LONG for an incoming request with expected data.             *&n; * &lt;BLOCKQUOTE &gt;                                                        *&n; * In the case of RQ_BAD_LINVAL, the register retains the 64-bit data   *&n; * value that followed the header flit.  In the case of RQ_BAD_ADDR     *&n; * or RQ_BAD_DATA, the register retains the incoming packet&squot;s 64-bit    *&n; * data value (i.e., 2nd flit in the packet for a normal PIO write or   *&n; * an LINVAL, 3rd flit for a vector PIO read or write). In the case     *&n; * of RP_BAD_DATA, the register retains the 64-bit data value in the    *&n; * 3rd flit of the packet. When a RP_LONG or RQ_LONG error occurs,      *&n; * the LB loads the LB_ERROR_DATA register with the contents of the     *&n; * expected data flit (i.e., the 3rd flit in the packet for a vector    *&n; * PIO request or reply, the 2nd flit for other packets), if any. The   *&n; * contents of the LB_ERROR_DATA register are undefined after a         *&n; * RP_SHORT, RQ_SHORT, RP_BAD_CMD or RQ_BAD_CMD error. The contents     *&n; * of the LB_ERROR_DATA register are also undefined after an incoming   *&n; * normal PIO read request which encounters a RQ_LONG error.            *&n; *                                                                      *&n; ************************************************************************/
DECL|union|lb_error_data_u
r_typedef
r_union
id|lb_error_data_u
(brace
DECL|member|lb_error_data_regval
id|bdrkreg_t
id|lb_error_data_regval
suffix:semicolon
r_struct
(brace
DECL|member|ed_data
id|bdrkreg_t
id|ed_data
suffix:colon
l_int|64
suffix:semicolon
DECL|member|lb_error_data_fld_s
)brace
id|lb_error_data_fld_s
suffix:semicolon
DECL|typedef|lb_error_data_u_t
)brace
id|lb_error_data_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register enables software to control what internal Bedrock     *&n; * signals are visible on the chip&squot;s debug pins. The LB provides the    *&n; * 6-bit value in this register to Bedrock&squot;s DEBUG unit. The JTAG       *&n; * unit provides a similar 6-bit selection input to the DEBUG unit,     *&n; * along with another signal that tells the DEBUG unit whether to use   *&n; * the selection signal from the LB or the JTAG unit. For a             *&n; * description of the menu of choices for debug signals, refer to the   *&n; * documentation for the DEBUG unit.                                    *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|lb_debug_select_u
r_typedef
r_union
id|lb_debug_select_u
(brace
DECL|member|lb_debug_select_regval
id|bdrkreg_t
id|lb_debug_select_regval
suffix:semicolon
r_struct
(brace
DECL|member|ds_debug_sel
id|bdrkreg_t
id|ds_debug_sel
suffix:colon
l_int|6
suffix:semicolon
DECL|member|ds_reserved
id|bdrkreg_t
id|ds_reserved
suffix:colon
l_int|58
suffix:semicolon
DECL|member|lb_debug_select_fld_s
)brace
id|lb_debug_select_fld_s
suffix:semicolon
DECL|typedef|lb_debug_select_u_t
)brace
id|lb_debug_select_u_t
suffix:semicolon
macro_line|#else
DECL|union|lb_debug_select_u
r_typedef
r_union
id|lb_debug_select_u
(brace
DECL|member|lb_debug_select_regval
id|bdrkreg_t
id|lb_debug_select_regval
suffix:semicolon
r_struct
(brace
DECL|member|ds_reserved
id|bdrkreg_t
id|ds_reserved
suffix:colon
l_int|58
suffix:semicolon
DECL|member|ds_debug_sel
id|bdrkreg_t
id|ds_debug_sel
suffix:colon
l_int|6
suffix:semicolon
DECL|member|lb_debug_select_fld_s
)brace
id|lb_debug_select_fld_s
suffix:semicolon
DECL|typedef|lb_debug_select_u_t
)brace
id|lb_debug_select_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  A PIO read from this register returns the 32-bit value that is      *&n; * currently on the Bedrock chip&squot;s debug pins. This register allows     *&n; * software to observe debug pin output values which do not change      *&n; * frequently (i.e., they remain constant over a period of many         *&n; * cycles).                                                             *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|lb_debug_pins_u
r_typedef
r_union
id|lb_debug_pins_u
(brace
DECL|member|lb_debug_pins_regval
id|bdrkreg_t
id|lb_debug_pins_regval
suffix:semicolon
r_struct
(brace
DECL|member|dp_debug_pins
id|bdrkreg_t
id|dp_debug_pins
suffix:colon
l_int|32
suffix:semicolon
DECL|member|dp_reserved
id|bdrkreg_t
id|dp_reserved
suffix:colon
l_int|32
suffix:semicolon
DECL|member|lb_debug_pins_fld_s
)brace
id|lb_debug_pins_fld_s
suffix:semicolon
DECL|typedef|lb_debug_pins_u_t
)brace
id|lb_debug_pins_u_t
suffix:semicolon
macro_line|#else
DECL|union|lb_debug_pins_u
r_typedef
r_union
id|lb_debug_pins_u
(brace
DECL|member|lb_debug_pins_regval
id|bdrkreg_t
id|lb_debug_pins_regval
suffix:semicolon
r_struct
(brace
DECL|member|dp_reserved
id|bdrkreg_t
id|dp_reserved
suffix:colon
l_int|32
suffix:semicolon
DECL|member|dp_debug_pins
id|bdrkreg_t
id|dp_debug_pins
suffix:colon
l_int|32
suffix:semicolon
DECL|member|lb_debug_pins_fld_s
)brace
id|lb_debug_pins_fld_s
suffix:semicolon
DECL|typedef|lb_debug_pins_u_t
)brace
id|lb_debug_pins_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  The LB unit provides the PI0 and PI1 units with a real-time clock   *&n; * signal. The LB can generate this signal itself, based on the         *&n; * Bedrock chip&squot;s system clock which the LB receives as an input.       *&n; * Alternatively, the LB can filter a global clock signal which it      *&n; * receives as an input and provide the filtered version to PI0 and     *&n; * PI1. The user can program the LB_RT_LOCAL_CTRL register to choose    *&n; * the source of the real-time clock. If the user chooses to generate   *&n; * the real-time clock internally within the LB, then the user can      *&n; * specify the period for the real-time clock signal.                   *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|lb_rt_local_ctrl_u
r_typedef
r_union
id|lb_rt_local_ctrl_u
(brace
DECL|member|lb_rt_local_ctrl_regval
id|bdrkreg_t
id|lb_rt_local_ctrl_regval
suffix:semicolon
r_struct
(brace
DECL|member|rlc_gclk_enable
id|bdrkreg_t
id|rlc_gclk_enable
suffix:colon
l_int|1
suffix:semicolon
DECL|member|rlc_reserved_4
id|bdrkreg_t
id|rlc_reserved_4
suffix:colon
l_int|3
suffix:semicolon
DECL|member|rlc_max_count
id|bdrkreg_t
id|rlc_max_count
suffix:colon
l_int|10
suffix:semicolon
DECL|member|rlc_reserved_3
id|bdrkreg_t
id|rlc_reserved_3
suffix:colon
l_int|2
suffix:semicolon
DECL|member|rlc_gclk_counter
id|bdrkreg_t
id|rlc_gclk_counter
suffix:colon
l_int|10
suffix:semicolon
DECL|member|rlc_reserved_2
id|bdrkreg_t
id|rlc_reserved_2
suffix:colon
l_int|2
suffix:semicolon
DECL|member|rlc_gclk
id|bdrkreg_t
id|rlc_gclk
suffix:colon
l_int|1
suffix:semicolon
DECL|member|rlc_reserved_1
id|bdrkreg_t
id|rlc_reserved_1
suffix:colon
l_int|3
suffix:semicolon
DECL|member|rlc_use_internal
id|bdrkreg_t
id|rlc_use_internal
suffix:colon
l_int|1
suffix:semicolon
DECL|member|rlc_reserved
id|bdrkreg_t
id|rlc_reserved
suffix:colon
l_int|31
suffix:semicolon
DECL|member|lb_rt_local_ctrl_fld_s
)brace
id|lb_rt_local_ctrl_fld_s
suffix:semicolon
DECL|typedef|lb_rt_local_ctrl_u_t
)brace
id|lb_rt_local_ctrl_u_t
suffix:semicolon
macro_line|#else
DECL|union|lb_rt_local_ctrl_u
r_typedef
r_union
id|lb_rt_local_ctrl_u
(brace
DECL|member|lb_rt_local_ctrl_regval
id|bdrkreg_t
id|lb_rt_local_ctrl_regval
suffix:semicolon
r_struct
(brace
DECL|member|rlc_reserved
id|bdrkreg_t
id|rlc_reserved
suffix:colon
l_int|31
suffix:semicolon
DECL|member|rlc_use_internal
id|bdrkreg_t
id|rlc_use_internal
suffix:colon
l_int|1
suffix:semicolon
DECL|member|rlc_reserved_1
id|bdrkreg_t
id|rlc_reserved_1
suffix:colon
l_int|3
suffix:semicolon
DECL|member|rlc_gclk
id|bdrkreg_t
id|rlc_gclk
suffix:colon
l_int|1
suffix:semicolon
DECL|member|rlc_reserved_2
id|bdrkreg_t
id|rlc_reserved_2
suffix:colon
l_int|2
suffix:semicolon
DECL|member|rlc_gclk_counter
id|bdrkreg_t
id|rlc_gclk_counter
suffix:colon
l_int|10
suffix:semicolon
DECL|member|rlc_reserved_3
id|bdrkreg_t
id|rlc_reserved_3
suffix:colon
l_int|2
suffix:semicolon
DECL|member|rlc_max_count
id|bdrkreg_t
id|rlc_max_count
suffix:colon
l_int|10
suffix:semicolon
DECL|member|rlc_reserved_4
id|bdrkreg_t
id|rlc_reserved_4
suffix:colon
l_int|3
suffix:semicolon
DECL|member|rlc_gclk_enable
id|bdrkreg_t
id|rlc_gclk_enable
suffix:colon
l_int|1
suffix:semicolon
DECL|member|lb_rt_local_ctrl_fld_s
)brace
id|lb_rt_local_ctrl_fld_s
suffix:semicolon
DECL|typedef|lb_rt_local_ctrl_u_t
)brace
id|lb_rt_local_ctrl_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  When the value of the USE_INTERNAL field in the LB_RT_LOCAL_CTRL    *&n; * register is 0, the LB filters an incoming global clock signal and    *&n; * provides the result to PI0 and PI1 for their real-time clock         *&n; * inputs. The LB can perform either simple filtering or complex        *&n; * filtering, depending on the value of the MASK_ENABLE bit. For the    *&n; * simple filtering option, the LB merely removes glitches from the     *&n; * incoming global clock; if the global clock goes high (or low) for    *&n; * only a single cycle, the LB considers it to be a glitch and does     *&n; * not pass it through to PI0 and PI1. For the complex filtering        *&n; * option, the LB expects positive edges on the incoming global clock   *&n; * to be spaced at fairly regular intervals and it looks for them at    *&n; * these times; the LB keeps track of unexpected or missing positive    *&n; * edges, and it generates an edge itself whenever the incoming         *&n; * global clock apparently misses an edge. For each filtering option,   *&n; * the real-time clock which the LB provides to PI0 and PI1 is not      *&n; * necessarily a square wave; when a positive edge happens, the         *&n; * real-time clock stays high for (2*MAX_COUNT+1-OFFSET)/2 cycles of    *&n; * the LB&squot;s system clock, and then is low until the next positive       *&n; * edge.                                                                *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|lb_rt_filter_ctrl_u
r_typedef
r_union
id|lb_rt_filter_ctrl_u
(brace
DECL|member|lb_rt_filter_ctrl_regval
id|bdrkreg_t
id|lb_rt_filter_ctrl_regval
suffix:semicolon
r_struct
(brace
DECL|member|rfc_offset
id|bdrkreg_t
id|rfc_offset
suffix:colon
l_int|5
suffix:semicolon
DECL|member|rfc_reserved_4
id|bdrkreg_t
id|rfc_reserved_4
suffix:colon
l_int|3
suffix:semicolon
DECL|member|rfc_mask_counter
id|bdrkreg_t
id|rfc_mask_counter
suffix:colon
l_int|12
suffix:semicolon
DECL|member|rfc_mask_enable
id|bdrkreg_t
id|rfc_mask_enable
suffix:colon
l_int|1
suffix:semicolon
DECL|member|rfc_reserved_3
id|bdrkreg_t
id|rfc_reserved_3
suffix:colon
l_int|3
suffix:semicolon
DECL|member|rfc_dropout_counter
id|bdrkreg_t
id|rfc_dropout_counter
suffix:colon
l_int|10
suffix:semicolon
DECL|member|rfc_reserved_2
id|bdrkreg_t
id|rfc_reserved_2
suffix:colon
l_int|2
suffix:semicolon
DECL|member|rfc_dropout_thresh
id|bdrkreg_t
id|rfc_dropout_thresh
suffix:colon
l_int|10
suffix:semicolon
DECL|member|rfc_reserved_1
id|bdrkreg_t
id|rfc_reserved_1
suffix:colon
l_int|2
suffix:semicolon
DECL|member|rfc_error_counter
id|bdrkreg_t
id|rfc_error_counter
suffix:colon
l_int|10
suffix:semicolon
DECL|member|rfc_reserved
id|bdrkreg_t
id|rfc_reserved
suffix:colon
l_int|6
suffix:semicolon
DECL|member|lb_rt_filter_ctrl_fld_s
)brace
id|lb_rt_filter_ctrl_fld_s
suffix:semicolon
DECL|typedef|lb_rt_filter_ctrl_u_t
)brace
id|lb_rt_filter_ctrl_u_t
suffix:semicolon
macro_line|#else
DECL|union|lb_rt_filter_ctrl_u
r_typedef
r_union
id|lb_rt_filter_ctrl_u
(brace
DECL|member|lb_rt_filter_ctrl_regval
id|bdrkreg_t
id|lb_rt_filter_ctrl_regval
suffix:semicolon
r_struct
(brace
DECL|member|rfc_reserved
id|bdrkreg_t
id|rfc_reserved
suffix:colon
l_int|6
suffix:semicolon
DECL|member|rfc_error_counter
id|bdrkreg_t
id|rfc_error_counter
suffix:colon
l_int|10
suffix:semicolon
DECL|member|rfc_reserved_1
id|bdrkreg_t
id|rfc_reserved_1
suffix:colon
l_int|2
suffix:semicolon
DECL|member|rfc_dropout_thresh
id|bdrkreg_t
id|rfc_dropout_thresh
suffix:colon
l_int|10
suffix:semicolon
DECL|member|rfc_reserved_2
id|bdrkreg_t
id|rfc_reserved_2
suffix:colon
l_int|2
suffix:semicolon
DECL|member|rfc_dropout_counter
id|bdrkreg_t
id|rfc_dropout_counter
suffix:colon
l_int|10
suffix:semicolon
DECL|member|rfc_reserved_3
id|bdrkreg_t
id|rfc_reserved_3
suffix:colon
l_int|3
suffix:semicolon
DECL|member|rfc_mask_enable
id|bdrkreg_t
id|rfc_mask_enable
suffix:colon
l_int|1
suffix:semicolon
DECL|member|rfc_mask_counter
id|bdrkreg_t
id|rfc_mask_counter
suffix:colon
l_int|12
suffix:semicolon
DECL|member|rfc_reserved_4
id|bdrkreg_t
id|rfc_reserved_4
suffix:colon
l_int|3
suffix:semicolon
DECL|member|rfc_offset
id|bdrkreg_t
id|rfc_offset
suffix:colon
l_int|5
suffix:semicolon
DECL|member|lb_rt_filter_ctrl_fld_s
)brace
id|lb_rt_filter_ctrl_fld_s
suffix:semicolon
DECL|typedef|lb_rt_filter_ctrl_u_t
)brace
id|lb_rt_filter_ctrl_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register is a scratch register that is reset to 0x0. At the    *&n; * normal address, the register is a simple storage location. At the    *&n; * Write-If-Zero address, the register accepts a new value from a       *&n; * write operation only if the current value is zero.                   *&n; *                                                                      *&n; ************************************************************************/
DECL|union|lb_scratch_reg0_u
r_typedef
r_union
id|lb_scratch_reg0_u
(brace
DECL|member|lb_scratch_reg0_regval
id|bdrkreg_t
id|lb_scratch_reg0_regval
suffix:semicolon
r_struct
(brace
DECL|member|sr_scratch_bits
id|bdrkreg_t
id|sr_scratch_bits
suffix:colon
l_int|64
suffix:semicolon
DECL|member|lb_scratch_reg0_fld_s
)brace
id|lb_scratch_reg0_fld_s
suffix:semicolon
DECL|typedef|lb_scratch_reg0_u_t
)brace
id|lb_scratch_reg0_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  These registers are scratch registers that are not reset. At a      *&n; * register&squot;s normal address, it is a simple storage location. At a     *&n; * register&squot;s Write-If-Zero address, it accepts a new value from a      *&n; * write operation only if the current value is zero.                   *&n; *                                                                      *&n; ************************************************************************/
DECL|union|lb_scratch_reg1_u
r_typedef
r_union
id|lb_scratch_reg1_u
(brace
DECL|member|lb_scratch_reg1_regval
id|bdrkreg_t
id|lb_scratch_reg1_regval
suffix:semicolon
r_struct
(brace
DECL|member|sr_scratch_bits
id|bdrkreg_t
id|sr_scratch_bits
suffix:colon
l_int|64
suffix:semicolon
DECL|member|lb_scratch_reg1_fld_s
)brace
id|lb_scratch_reg1_fld_s
suffix:semicolon
DECL|typedef|lb_scratch_reg1_u_t
)brace
id|lb_scratch_reg1_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  These registers are scratch registers that are not reset. At a      *&n; * register&squot;s normal address, it is a simple storage location. At a     *&n; * register&squot;s Write-If-Zero address, it accepts a new value from a      *&n; * write operation only if the current value is zero.                   *&n; *                                                                      *&n; ************************************************************************/
DECL|union|lb_scratch_reg2_u
r_typedef
r_union
id|lb_scratch_reg2_u
(brace
DECL|member|lb_scratch_reg2_regval
id|bdrkreg_t
id|lb_scratch_reg2_regval
suffix:semicolon
r_struct
(brace
DECL|member|sr_scratch_bits
id|bdrkreg_t
id|sr_scratch_bits
suffix:colon
l_int|64
suffix:semicolon
DECL|member|lb_scratch_reg2_fld_s
)brace
id|lb_scratch_reg2_fld_s
suffix:semicolon
DECL|typedef|lb_scratch_reg2_u_t
)brace
id|lb_scratch_reg2_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  These one-bit registers are scratch registers. At a register&squot;s      *&n; * normal address, it is a simple storage location. At a register&squot;s     *&n; * Read-Set-If-Zero address, it returns the original contents and       *&n; * sets the bit if the original value is zero.                          *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|lb_scratch_reg3_u
r_typedef
r_union
id|lb_scratch_reg3_u
(brace
DECL|member|lb_scratch_reg3_regval
id|bdrkreg_t
id|lb_scratch_reg3_regval
suffix:semicolon
r_struct
(brace
DECL|member|sr_scratch_bit
id|bdrkreg_t
id|sr_scratch_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|sr_reserved
id|bdrkreg_t
id|sr_reserved
suffix:colon
l_int|63
suffix:semicolon
DECL|member|lb_scratch_reg3_fld_s
)brace
id|lb_scratch_reg3_fld_s
suffix:semicolon
DECL|typedef|lb_scratch_reg3_u_t
)brace
id|lb_scratch_reg3_u_t
suffix:semicolon
macro_line|#else
DECL|union|lb_scratch_reg3_u
r_typedef
r_union
id|lb_scratch_reg3_u
(brace
DECL|member|lb_scratch_reg3_regval
id|bdrkreg_t
id|lb_scratch_reg3_regval
suffix:semicolon
r_struct
(brace
DECL|member|sr_reserved
id|bdrkreg_t
id|sr_reserved
suffix:colon
l_int|63
suffix:semicolon
DECL|member|sr_scratch_bit
id|bdrkreg_t
id|sr_scratch_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|lb_scratch_reg3_fld_s
)brace
id|lb_scratch_reg3_fld_s
suffix:semicolon
DECL|typedef|lb_scratch_reg3_u_t
)brace
id|lb_scratch_reg3_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  These one-bit registers are scratch registers. At a register&squot;s      *&n; * normal address, it is a simple storage location. At a register&squot;s     *&n; * Read-Set-If-Zero address, it returns the original contents and       *&n; * sets the bit if the original value is zero.                          *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|lb_scratch_reg4_u
r_typedef
r_union
id|lb_scratch_reg4_u
(brace
DECL|member|lb_scratch_reg4_regval
id|bdrkreg_t
id|lb_scratch_reg4_regval
suffix:semicolon
r_struct
(brace
DECL|member|sr_scratch_bit
id|bdrkreg_t
id|sr_scratch_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|sr_reserved
id|bdrkreg_t
id|sr_reserved
suffix:colon
l_int|63
suffix:semicolon
DECL|member|lb_scratch_reg4_fld_s
)brace
id|lb_scratch_reg4_fld_s
suffix:semicolon
DECL|typedef|lb_scratch_reg4_u_t
)brace
id|lb_scratch_reg4_u_t
suffix:semicolon
macro_line|#else
DECL|union|lb_scratch_reg4_u
r_typedef
r_union
id|lb_scratch_reg4_u
(brace
DECL|member|lb_scratch_reg4_regval
id|bdrkreg_t
id|lb_scratch_reg4_regval
suffix:semicolon
r_struct
(brace
DECL|member|sr_reserved
id|bdrkreg_t
id|sr_reserved
suffix:colon
l_int|63
suffix:semicolon
DECL|member|sr_scratch_bit
id|bdrkreg_t
id|sr_scratch_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|lb_scratch_reg4_fld_s
)brace
id|lb_scratch_reg4_fld_s
suffix:semicolon
DECL|typedef|lb_scratch_reg4_u_t
)brace
id|lb_scratch_reg4_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register is a scratch register that is reset to 0x0. At the    *&n; * normal address, the register is a simple storage location. At the    *&n; * Write-If-Zero address, the register accepts a new value from a       *&n; * write operation only if the current value is zero.                   *&n; *                                                                      *&n; ************************************************************************/
DECL|union|lb_scratch_reg0_wz_u
r_typedef
r_union
id|lb_scratch_reg0_wz_u
(brace
DECL|member|lb_scratch_reg0_wz_regval
id|bdrkreg_t
id|lb_scratch_reg0_wz_regval
suffix:semicolon
r_struct
(brace
DECL|member|srw_scratch_bits
id|bdrkreg_t
id|srw_scratch_bits
suffix:colon
l_int|64
suffix:semicolon
DECL|member|lb_scratch_reg0_wz_fld_s
)brace
id|lb_scratch_reg0_wz_fld_s
suffix:semicolon
DECL|typedef|lb_scratch_reg0_wz_u_t
)brace
id|lb_scratch_reg0_wz_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  These registers are scratch registers that are not reset. At a      *&n; * register&squot;s normal address, it is a simple storage location. At a     *&n; * register&squot;s Write-If-Zero address, it accepts a new value from a      *&n; * write operation only if the current value is zero.                   *&n; *                                                                      *&n; ************************************************************************/
DECL|union|lb_scratch_reg1_wz_u
r_typedef
r_union
id|lb_scratch_reg1_wz_u
(brace
DECL|member|lb_scratch_reg1_wz_regval
id|bdrkreg_t
id|lb_scratch_reg1_wz_regval
suffix:semicolon
r_struct
(brace
DECL|member|srw_scratch_bits
id|bdrkreg_t
id|srw_scratch_bits
suffix:colon
l_int|64
suffix:semicolon
DECL|member|lb_scratch_reg1_wz_fld_s
)brace
id|lb_scratch_reg1_wz_fld_s
suffix:semicolon
DECL|typedef|lb_scratch_reg1_wz_u_t
)brace
id|lb_scratch_reg1_wz_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  These registers are scratch registers that are not reset. At a      *&n; * register&squot;s normal address, it is a simple storage location. At a     *&n; * register&squot;s Write-If-Zero address, it accepts a new value from a      *&n; * write operation only if the current value is zero.                   *&n; *                                                                      *&n; ************************************************************************/
DECL|union|lb_scratch_reg2_wz_u
r_typedef
r_union
id|lb_scratch_reg2_wz_u
(brace
DECL|member|lb_scratch_reg2_wz_regval
id|bdrkreg_t
id|lb_scratch_reg2_wz_regval
suffix:semicolon
r_struct
(brace
DECL|member|srw_scratch_bits
id|bdrkreg_t
id|srw_scratch_bits
suffix:colon
l_int|64
suffix:semicolon
DECL|member|lb_scratch_reg2_wz_fld_s
)brace
id|lb_scratch_reg2_wz_fld_s
suffix:semicolon
DECL|typedef|lb_scratch_reg2_wz_u_t
)brace
id|lb_scratch_reg2_wz_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  These one-bit registers are scratch registers. At a register&squot;s      *&n; * normal address, it is a simple storage location. At a register&squot;s     *&n; * Read-Set-If-Zero address, it returns the original contents and       *&n; * sets the bit if the original value is zero.                          *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|lb_scratch_reg3_rz_u
r_typedef
r_union
id|lb_scratch_reg3_rz_u
(brace
DECL|member|lb_scratch_reg3_rz_regval
id|bdrkreg_t
id|lb_scratch_reg3_rz_regval
suffix:semicolon
r_struct
(brace
DECL|member|srr_scratch_bit
id|bdrkreg_t
id|srr_scratch_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|srr_reserved
id|bdrkreg_t
id|srr_reserved
suffix:colon
l_int|63
suffix:semicolon
DECL|member|lb_scratch_reg3_rz_fld_s
)brace
id|lb_scratch_reg3_rz_fld_s
suffix:semicolon
DECL|typedef|lb_scratch_reg3_rz_u_t
)brace
id|lb_scratch_reg3_rz_u_t
suffix:semicolon
macro_line|#else
DECL|union|lb_scratch_reg3_rz_u
r_typedef
r_union
id|lb_scratch_reg3_rz_u
(brace
DECL|member|lb_scratch_reg3_rz_regval
id|bdrkreg_t
id|lb_scratch_reg3_rz_regval
suffix:semicolon
r_struct
(brace
DECL|member|srr_reserved
id|bdrkreg_t
id|srr_reserved
suffix:colon
l_int|63
suffix:semicolon
DECL|member|srr_scratch_bit
id|bdrkreg_t
id|srr_scratch_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|lb_scratch_reg3_rz_fld_s
)brace
id|lb_scratch_reg3_rz_fld_s
suffix:semicolon
DECL|typedef|lb_scratch_reg3_rz_u_t
)brace
id|lb_scratch_reg3_rz_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  These one-bit registers are scratch registers. At a register&squot;s      *&n; * normal address, it is a simple storage location. At a register&squot;s     *&n; * Read-Set-If-Zero address, it returns the original contents and       *&n; * sets the bit if the original value is zero.                          *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|lb_scratch_reg4_rz_u
r_typedef
r_union
id|lb_scratch_reg4_rz_u
(brace
DECL|member|lb_scratch_reg4_rz_regval
id|bdrkreg_t
id|lb_scratch_reg4_rz_regval
suffix:semicolon
r_struct
(brace
DECL|member|srr_scratch_bit
id|bdrkreg_t
id|srr_scratch_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|srr_reserved
id|bdrkreg_t
id|srr_reserved
suffix:colon
l_int|63
suffix:semicolon
DECL|member|lb_scratch_reg4_rz_fld_s
)brace
id|lb_scratch_reg4_rz_fld_s
suffix:semicolon
DECL|typedef|lb_scratch_reg4_rz_u_t
)brace
id|lb_scratch_reg4_rz_u_t
suffix:semicolon
macro_line|#else
DECL|union|lb_scratch_reg4_rz_u
r_typedef
r_union
id|lb_scratch_reg4_rz_u
(brace
DECL|member|lb_scratch_reg4_rz_regval
id|bdrkreg_t
id|lb_scratch_reg4_rz_regval
suffix:semicolon
r_struct
(brace
DECL|member|srr_reserved
id|bdrkreg_t
id|srr_reserved
suffix:colon
l_int|63
suffix:semicolon
DECL|member|srr_scratch_bit
id|bdrkreg_t
id|srr_scratch_bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|lb_scratch_reg4_rz_fld_s
)brace
id|lb_scratch_reg4_rz_fld_s
suffix:semicolon
DECL|typedef|lb_scratch_reg4_rz_u_t
)brace
id|lb_scratch_reg4_rz_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; * Description:  This register contains vector PIO parameters. A        *&n; * write to this register triggers the LB to send out a vector PIO      *&n; * request packet. Immediately after servicing a write request to the   *&n; * LB_VECTOR_PARMS register, the LB sends back a reply (i.e., the LB    *&n; * doesn&squot;t wait for the vector PIO operation to finish first). Three    *&n; * LB registers provide the contents for an outgoing vector PIO         *&n; * request packet. Software should wait until the BUSY bit in           *&n; * LB_VECTOR_PARMS is clear and then initialize all three of these      *&n; * registers before initiating a vector PIO operation. The three        *&n; * vector PIO registers are:                                            *&n; * LB_VECTOR_ROUTE                                                      *&n; * LB_VECTOR_DATA                                                       *&n; * LB_VECTOR_PARMS (should be written last)                             *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|lb_vector_parms_u
r_typedef
r_union
id|lb_vector_parms_u
(brace
DECL|member|lb_vector_parms_regval
id|bdrkreg_t
id|lb_vector_parms_regval
suffix:semicolon
r_struct
(brace
DECL|member|vp_type
id|bdrkreg_t
id|vp_type
suffix:colon
l_int|1
suffix:semicolon
DECL|member|vp_reserved_2
id|bdrkreg_t
id|vp_reserved_2
suffix:colon
l_int|2
suffix:semicolon
DECL|member|vp_address
id|bdrkreg_t
id|vp_address
suffix:colon
l_int|21
suffix:semicolon
DECL|member|vp_reserved_1
id|bdrkreg_t
id|vp_reserved_1
suffix:colon
l_int|8
suffix:semicolon
DECL|member|vp_write_id
id|bdrkreg_t
id|vp_write_id
suffix:colon
l_int|8
suffix:semicolon
DECL|member|vp_pio_id
id|bdrkreg_t
id|vp_pio_id
suffix:colon
l_int|11
suffix:semicolon
DECL|member|vp_reserved
id|bdrkreg_t
id|vp_reserved
suffix:colon
l_int|12
suffix:semicolon
DECL|member|vp_busy
id|bdrkreg_t
id|vp_busy
suffix:colon
l_int|1
suffix:semicolon
DECL|member|lb_vector_parms_fld_s
)brace
id|lb_vector_parms_fld_s
suffix:semicolon
DECL|typedef|lb_vector_parms_u_t
)brace
id|lb_vector_parms_u_t
suffix:semicolon
macro_line|#else
DECL|union|lb_vector_parms_u
r_typedef
r_union
id|lb_vector_parms_u
(brace
DECL|member|lb_vector_parms_regval
id|bdrkreg_t
id|lb_vector_parms_regval
suffix:semicolon
r_struct
(brace
DECL|member|vp_busy
id|bdrkreg_t
id|vp_busy
suffix:colon
l_int|1
suffix:semicolon
DECL|member|vp_reserved
id|bdrkreg_t
id|vp_reserved
suffix:colon
l_int|12
suffix:semicolon
DECL|member|vp_pio_id
id|bdrkreg_t
id|vp_pio_id
suffix:colon
l_int|11
suffix:semicolon
DECL|member|vp_write_id
id|bdrkreg_t
id|vp_write_id
suffix:colon
l_int|8
suffix:semicolon
DECL|member|vp_reserved_1
id|bdrkreg_t
id|vp_reserved_1
suffix:colon
l_int|8
suffix:semicolon
DECL|member|vp_address
id|bdrkreg_t
id|vp_address
suffix:colon
l_int|21
suffix:semicolon
DECL|member|vp_reserved_2
id|bdrkreg_t
id|vp_reserved_2
suffix:colon
l_int|2
suffix:semicolon
DECL|member|vp_type
id|bdrkreg_t
id|vp_type
suffix:colon
l_int|1
suffix:semicolon
DECL|member|lb_vector_parms_fld_s
)brace
id|lb_vector_parms_fld_s
suffix:semicolon
DECL|typedef|lb_vector_parms_u_t
)brace
id|lb_vector_parms_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register contains the vector PIO route. This is one of the 3   *&n; * vector PIO control registers.                                        *&n; *                                                                      *&n; ************************************************************************/
DECL|union|lb_vector_route_u
r_typedef
r_union
id|lb_vector_route_u
(brace
DECL|member|lb_vector_route_regval
id|bdrkreg_t
id|lb_vector_route_regval
suffix:semicolon
r_struct
(brace
DECL|member|vr_vector
id|bdrkreg_t
id|vr_vector
suffix:colon
l_int|64
suffix:semicolon
DECL|member|lb_vector_route_fld_s
)brace
id|lb_vector_route_fld_s
suffix:semicolon
DECL|typedef|lb_vector_route_u_t
)brace
id|lb_vector_route_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register contains the vector PIO write data. This is one of    *&n; * the 3 vector PIO control registers. The contents of this register    *&n; * also provide the data value to be sent in outgoing vector PIO read   *&n; * requests and vector PIO write replies.                               *&n; *                                                                      *&n; ************************************************************************/
DECL|union|lb_vector_data_u
r_typedef
r_union
id|lb_vector_data_u
(brace
DECL|member|lb_vector_data_regval
id|bdrkreg_t
id|lb_vector_data_regval
suffix:semicolon
r_struct
(brace
DECL|member|vd_write_data
id|bdrkreg_t
id|vd_write_data
suffix:colon
l_int|64
suffix:semicolon
DECL|member|lb_vector_data_fld_s
)brace
id|lb_vector_data_fld_s
suffix:semicolon
DECL|typedef|lb_vector_data_u_t
)brace
id|lb_vector_data_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; * Description:  This register contains the vector PIO return status.   *&n; * Software should clear this register before launching a vector PIO    *&n; * request from the LB. The LB will not modify this register&squot;s value    *&n; * if an incoming reply packet encounters any kind of error. If an      *&n; * incoming reply packet does not encounter an error but the            *&n; * STATUS_VALID bit is already set, then the LB sets the OVERRUN bit    *&n; * and leaves the other fields unchanged. The LB updates the values     *&n; * of the SOURCE, PIO_ID, WRITE_ID, ADDRESS and TYPE fields only if     *&n; * an incoming vector PIO reply packet does not encounter an error      *&n; * and the STATUS_VALID bit is clear; at the same time, the LB sets     *&n; * the STATUS_VALID bit and will also update the LB_VECTOR_RETURN and   *&n; * LB_VECTOR_READ_DATA registers.                                       *&n; *                                                                      *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|lb_vector_status_u
r_typedef
r_union
id|lb_vector_status_u
(brace
DECL|member|lb_vector_status_regval
id|bdrkreg_t
id|lb_vector_status_regval
suffix:semicolon
r_struct
(brace
DECL|member|vs_type
id|bdrkreg_t
id|vs_type
suffix:colon
l_int|3
suffix:semicolon
DECL|member|vs_address
id|bdrkreg_t
id|vs_address
suffix:colon
l_int|21
suffix:semicolon
DECL|member|vs_reserved
id|bdrkreg_t
id|vs_reserved
suffix:colon
l_int|8
suffix:semicolon
DECL|member|vs_write_id
id|bdrkreg_t
id|vs_write_id
suffix:colon
l_int|8
suffix:semicolon
DECL|member|vs_pio_id
id|bdrkreg_t
id|vs_pio_id
suffix:colon
l_int|11
suffix:semicolon
DECL|member|vs_source
id|bdrkreg_t
id|vs_source
suffix:colon
l_int|11
suffix:semicolon
DECL|member|vs_overrun
id|bdrkreg_t
id|vs_overrun
suffix:colon
l_int|1
suffix:semicolon
DECL|member|vs_status_valid
id|bdrkreg_t
id|vs_status_valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|lb_vector_status_fld_s
)brace
id|lb_vector_status_fld_s
suffix:semicolon
DECL|typedef|lb_vector_status_u_t
)brace
id|lb_vector_status_u_t
suffix:semicolon
macro_line|#else
DECL|union|lb_vector_status_u
r_typedef
r_union
id|lb_vector_status_u
(brace
DECL|member|lb_vector_status_regval
id|bdrkreg_t
id|lb_vector_status_regval
suffix:semicolon
r_struct
(brace
DECL|member|vs_status_valid
id|bdrkreg_t
id|vs_status_valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|vs_overrun
id|bdrkreg_t
id|vs_overrun
suffix:colon
l_int|1
suffix:semicolon
DECL|member|vs_source
id|bdrkreg_t
id|vs_source
suffix:colon
l_int|11
suffix:semicolon
DECL|member|vs_pio_id
id|bdrkreg_t
id|vs_pio_id
suffix:colon
l_int|11
suffix:semicolon
DECL|member|vs_write_id
id|bdrkreg_t
id|vs_write_id
suffix:colon
l_int|8
suffix:semicolon
DECL|member|vs_reserved
id|bdrkreg_t
id|vs_reserved
suffix:colon
l_int|8
suffix:semicolon
DECL|member|vs_address
id|bdrkreg_t
id|vs_address
suffix:colon
l_int|21
suffix:semicolon
DECL|member|vs_type
id|bdrkreg_t
id|vs_type
suffix:colon
l_int|3
suffix:semicolon
DECL|member|lb_vector_status_fld_s
)brace
id|lb_vector_status_fld_s
suffix:semicolon
DECL|typedef|lb_vector_status_u_t
)brace
id|lb_vector_status_u_t
suffix:semicolon
macro_line|#endif
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register contains the return vector PIO route. The LB will     *&n; * not modify this register&squot;s value if an incoming reply packet         *&n; * encounters any kind of error. The LB also will not modify this       *&n; * register&squot;s value if the STATUS_VALID bit in the LB_VECTOR_STATUS     *&n; * register is set when it receives an incoming vector PIO reply. The   *&n; * LB stores an incoming vector PIO reply packet&squot;s vector route flit    *&n; * in this register only if the packet does not encounter an error      *&n; * and the STATUS_VALID bit is clear.                                   *&n; *                                                                      *&n; ************************************************************************/
DECL|union|lb_vector_return_u
r_typedef
r_union
id|lb_vector_return_u
(brace
DECL|member|lb_vector_return_regval
id|bdrkreg_t
id|lb_vector_return_regval
suffix:semicolon
r_struct
(brace
DECL|member|vr_return_vector
id|bdrkreg_t
id|vr_return_vector
suffix:colon
l_int|64
suffix:semicolon
DECL|member|lb_vector_return_fld_s
)brace
id|lb_vector_return_fld_s
suffix:semicolon
DECL|typedef|lb_vector_return_u_t
)brace
id|lb_vector_return_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; *  This register contains the vector PIO read data, if any. The LB     *&n; * will not modify this register&squot;s value if an incoming reply packet    *&n; * encounters any kind of error. The LB also will not modify this       *&n; * register&squot;s value if the STATUS_VALID bit in the LB_VECTOR_STATUS     *&n; * register is set when it receives an incoming vector PIO reply. The   *&n; * LB stores an incoming vector PIO reply packet&squot;s data flit in this    *&n; * register only if the packet does not encounter an error and the      *&n; * STATUS_VALID bit is clear.                                           *&n; *                                                                      *&n; ************************************************************************/
DECL|union|lb_vector_read_data_u
r_typedef
r_union
id|lb_vector_read_data_u
(brace
DECL|member|lb_vector_read_data_regval
id|bdrkreg_t
id|lb_vector_read_data_regval
suffix:semicolon
r_struct
(brace
DECL|member|vrd_read_data
id|bdrkreg_t
id|vrd_read_data
suffix:colon
l_int|64
suffix:semicolon
DECL|member|lb_vector_read_data_fld_s
)brace
id|lb_vector_read_data_fld_s
suffix:semicolon
DECL|typedef|lb_vector_read_data_u_t
)brace
id|lb_vector_read_data_u_t
suffix:semicolon
multiline_comment|/************************************************************************&n; *                                                                      *&n; * Description:  This register contains the vector PIO return status.   *&n; * Software should clear this register before launching a vector PIO    *&n; * request from the LB. The LB will not modify this register&squot;s value    *&n; * if an incoming reply packet encounters any kind of error. If an      *&n; * incoming reply packet does not encounter an error but the            *&n; * STATUS_VALID bit is already set, then the LB sets the OVERRUN bit    *&n; * and leaves the other fields unchanged. The LB updates the values     *&n; * of the SOURCE, PIO_ID, WRITE_ID, ADDRESS and TYPE fields only if     *&n; * an incoming vector PIO reply packet does not encounter an error      *&n; * and the STATUS_VALID bit is clear; at the same time, the LB sets     *&n; * the STATUS_VALID bit and will also update the LB_VECTOR_RETURN and   *&n; * LB_VECTOR_READ_DATA registers.                                       *&n; *                                                                      *&n; *                                                                      *&n; ************************************************************************/
macro_line|#ifdef LITTLE_ENDIAN
DECL|union|lb_vector_status_clear_u
r_typedef
r_union
id|lb_vector_status_clear_u
(brace
DECL|member|lb_vector_status_clear_regval
id|bdrkreg_t
id|lb_vector_status_clear_regval
suffix:semicolon
r_struct
(brace
DECL|member|vsc_type
id|bdrkreg_t
id|vsc_type
suffix:colon
l_int|3
suffix:semicolon
DECL|member|vsc_address
id|bdrkreg_t
id|vsc_address
suffix:colon
l_int|21
suffix:semicolon
DECL|member|vsc_reserved
id|bdrkreg_t
id|vsc_reserved
suffix:colon
l_int|8
suffix:semicolon
DECL|member|vsc_write_id
id|bdrkreg_t
id|vsc_write_id
suffix:colon
l_int|8
suffix:semicolon
DECL|member|vsc_pio_id
id|bdrkreg_t
id|vsc_pio_id
suffix:colon
l_int|11
suffix:semicolon
DECL|member|vsc_source
id|bdrkreg_t
id|vsc_source
suffix:colon
l_int|11
suffix:semicolon
DECL|member|vsc_overrun
id|bdrkreg_t
id|vsc_overrun
suffix:colon
l_int|1
suffix:semicolon
DECL|member|vsc_status_valid
id|bdrkreg_t
id|vsc_status_valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|lb_vector_status_clear_fld_s
)brace
id|lb_vector_status_clear_fld_s
suffix:semicolon
DECL|typedef|lb_vector_status_clear_u_t
)brace
id|lb_vector_status_clear_u_t
suffix:semicolon
macro_line|#else
DECL|union|lb_vector_status_clear_u
r_typedef
r_union
id|lb_vector_status_clear_u
(brace
DECL|member|lb_vector_status_clear_regval
id|bdrkreg_t
id|lb_vector_status_clear_regval
suffix:semicolon
r_struct
(brace
DECL|member|vsc_status_valid
id|bdrkreg_t
id|vsc_status_valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|vsc_overrun
id|bdrkreg_t
id|vsc_overrun
suffix:colon
l_int|1
suffix:semicolon
DECL|member|vsc_source
id|bdrkreg_t
id|vsc_source
suffix:colon
l_int|11
suffix:semicolon
DECL|member|vsc_pio_id
id|bdrkreg_t
id|vsc_pio_id
suffix:colon
l_int|11
suffix:semicolon
DECL|member|vsc_write_id
id|bdrkreg_t
id|vsc_write_id
suffix:colon
l_int|8
suffix:semicolon
DECL|member|vsc_reserved
id|bdrkreg_t
id|vsc_reserved
suffix:colon
l_int|8
suffix:semicolon
DECL|member|vsc_address
id|bdrkreg_t
id|vsc_address
suffix:colon
l_int|21
suffix:semicolon
DECL|member|vsc_type
id|bdrkreg_t
id|vsc_type
suffix:colon
l_int|3
suffix:semicolon
DECL|member|lb_vector_status_clear_fld_s
)brace
id|lb_vector_status_clear_fld_s
suffix:semicolon
DECL|typedef|lb_vector_status_clear_u_t
)brace
id|lb_vector_status_clear_u_t
suffix:semicolon
macro_line|#endif
macro_line|#endif /* _LANGUAGE_C */
multiline_comment|/************************************************************************&n; *                                                                      *&n; *               MAKE ALL ADDITIONS AFTER THIS LINE                     *&n; *                                                                      *&n; ************************************************************************/
macro_line|#endif /* _ASM_SN_SN1_HUBLB_H */
eof
