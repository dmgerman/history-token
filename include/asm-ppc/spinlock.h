macro_line|#ifndef __ASM_SPINLOCK_H
DECL|macro|__ASM_SPINLOCK_H
mdefine_line|#define __ASM_SPINLOCK_H
macro_line|#include &lt;asm/system.h&gt;
multiline_comment|/*&n; * Simple spin lock operations.&n; */
r_typedef
r_struct
(brace
DECL|member|lock
r_volatile
r_int
r_int
id|lock
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_SPINLOCK
DECL|member|owner_pc
r_volatile
r_int
r_int
id|owner_pc
suffix:semicolon
DECL|member|owner_cpu
r_volatile
r_int
r_int
id|owner_cpu
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_PREEMPT
DECL|member|break_lock
r_int
r_int
id|break_lock
suffix:semicolon
macro_line|#endif
DECL|typedef|spinlock_t
)brace
id|spinlock_t
suffix:semicolon
macro_line|#ifdef __KERNEL__
macro_line|#ifdef CONFIG_DEBUG_SPINLOCK
DECL|macro|SPINLOCK_DEBUG_INIT
mdefine_line|#define SPINLOCK_DEBUG_INIT     , 0, 0
macro_line|#else
DECL|macro|SPINLOCK_DEBUG_INIT
mdefine_line|#define SPINLOCK_DEBUG_INIT     /* */
macro_line|#endif
DECL|macro|SPIN_LOCK_UNLOCKED
mdefine_line|#define SPIN_LOCK_UNLOCKED&t;(spinlock_t) { 0 SPINLOCK_DEBUG_INIT }
DECL|macro|spin_lock_init
mdefine_line|#define spin_lock_init(x) &t;do { *(x) = SPIN_LOCK_UNLOCKED; } while(0)
DECL|macro|spin_is_locked
mdefine_line|#define spin_is_locked(x)&t;((x)-&gt;lock != 0)
DECL|macro|spin_unlock_wait
mdefine_line|#define spin_unlock_wait(x)&t;do { barrier(); } while(spin_is_locked(x))
DECL|macro|_raw_spin_lock_flags
mdefine_line|#define _raw_spin_lock_flags(lock, flags) _raw_spin_lock(lock)
macro_line|#ifndef CONFIG_DEBUG_SPINLOCK
DECL|function|_raw_spin_lock
r_static
r_inline
r_void
id|_raw_spin_lock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;b&t;1f&t;&t;# spin_lock&bslash;n&bslash;&n;2:&t;lwzx&t;%0,0,%1&bslash;n&bslash;&n;&t;cmpwi&t;0,%0,0&bslash;n&bslash;&n;&t;bne+&t;2b&bslash;n&bslash;&n;1:&t;lwarx&t;%0,0,%1&bslash;n&bslash;&n;&t;cmpwi&t;0,%0,0&bslash;n&bslash;&n;&t;bne-&t;2b&bslash;n&quot;
id|PPC405_ERR77
c_func
(paren
l_int|0
comma
op_mod
l_int|1
)paren
l_string|&quot;&t;stwcx.&t;%2,0,%1&bslash;n&bslash;&n;&t;bne-&t;2b&bslash;n&bslash;&n;&t;isync&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
op_amp
id|lock-&gt;lock
)paren
comma
l_string|&quot;r&quot;
(paren
l_int|1
)paren
suffix:colon
l_string|&quot;cr0&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
DECL|function|_raw_spin_unlock
r_static
r_inline
r_void
id|_raw_spin_unlock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;eieio&t;&t;# spin_unlock&quot;
suffix:colon
suffix:colon
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
id|lock-&gt;lock
op_assign
l_int|0
suffix:semicolon
)brace
DECL|macro|_raw_spin_trylock
mdefine_line|#define _raw_spin_trylock(l) (!test_and_set_bit(0,&amp;(l)-&gt;lock))
macro_line|#else
r_extern
r_void
id|_raw_spin_lock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
suffix:semicolon
r_extern
r_void
id|_raw_spin_unlock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
suffix:semicolon
r_extern
r_int
id|_raw_spin_trylock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Read-write spinlocks, allowing multiple readers&n; * but only one writer.&n; *&n; * NOTE! it is quite common to have readers in interrupts&n; * but no interrupt writers. For those circumstances we&n; * can &quot;mix&quot; irq-safe locks - any writer needs to get a&n; * irq-safe write-lock, but readers can get non-irqsafe&n; * read-locks.&n; */
r_typedef
r_struct
(brace
DECL|member|lock
r_volatile
r_int
r_int
id|lock
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_SPINLOCK
DECL|member|owner_pc
r_volatile
r_int
r_int
id|owner_pc
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_PREEMPT
DECL|member|break_lock
r_int
r_int
id|break_lock
suffix:semicolon
macro_line|#endif
DECL|typedef|rwlock_t
)brace
id|rwlock_t
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_SPINLOCK
DECL|macro|RWLOCK_DEBUG_INIT
mdefine_line|#define RWLOCK_DEBUG_INIT     , 0
macro_line|#else
DECL|macro|RWLOCK_DEBUG_INIT
mdefine_line|#define RWLOCK_DEBUG_INIT     /* */
macro_line|#endif
DECL|macro|RW_LOCK_UNLOCKED
mdefine_line|#define RW_LOCK_UNLOCKED (rwlock_t) { 0 RWLOCK_DEBUG_INIT }
DECL|macro|rwlock_init
mdefine_line|#define rwlock_init(lp) do { *(lp) = RW_LOCK_UNLOCKED; } while(0)
DECL|macro|rwlock_is_locked
mdefine_line|#define rwlock_is_locked(x)&t;((x)-&gt;lock != 0)
macro_line|#ifndef CONFIG_DEBUG_SPINLOCK
DECL|function|_raw_read_lock
r_static
id|__inline__
r_void
id|_raw_read_lock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;b&t;2f&t;&t;# read_lock&bslash;n&bslash;&n;1:&t;lwzx&t;%0,0,%1&bslash;n&bslash;&n;&t;cmpwi&t;0,%0,0&bslash;n&bslash;&n;&t;blt+&t;1b&bslash;n&bslash;&n;2:&t;lwarx&t;%0,0,%1&bslash;n&bslash;&n;&t;addic.&t;%0,%0,1&bslash;n&bslash;&n;&t;ble-&t;1b&bslash;n&quot;
id|PPC405_ERR77
c_func
(paren
l_int|0
comma
op_mod
l_int|1
)paren
l_string|&quot;&t;stwcx.&t;%0,0,%1&bslash;n&bslash;&n;&t;bne-&t;2b&bslash;n&bslash;&n;&t;isync&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
op_amp
id|rw-&gt;lock
)paren
suffix:colon
l_string|&quot;cr0&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
DECL|function|_raw_read_unlock
r_static
id|__inline__
r_void
id|_raw_read_unlock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;eieio&t;&t;&t;# read_unlock&bslash;n&bslash;&n;1:&t;lwarx&t;%0,0,%1&bslash;n&bslash;&n;&t;addic&t;%0,%0,-1&bslash;n&quot;
id|PPC405_ERR77
c_func
(paren
l_int|0
comma
op_mod
l_int|1
)paren
l_string|&quot;&t;stwcx.&t;%0,0,%1&bslash;n&bslash;&n;&t;bne-&t;1b&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
op_amp
id|rw-&gt;lock
)paren
suffix:colon
l_string|&quot;cr0&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
DECL|function|_raw_write_trylock
r_static
id|__inline__
r_int
id|_raw_write_trylock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;2:&t;lwarx&t;%0,0,%1&t;&t;# write_trylock&bslash;n&bslash;&n;&t;cmpwi&t;0,%0,0&bslash;n&bslash;&n;&t;bne-&t;1f&bslash;n&quot;
id|PPC405_ERR77
c_func
(paren
l_int|0
comma
op_mod
l_int|1
)paren
l_string|&quot;&t;stwcx.&t;%2,0,%1&bslash;n&bslash;&n;&t;bne-&t;2b&bslash;n&bslash;&n;&t;isync&bslash;n&bslash;&n;1:&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
op_amp
id|rw-&gt;lock
)paren
comma
l_string|&quot;r&quot;
(paren
op_minus
l_int|1
)paren
suffix:colon
l_string|&quot;cr0&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|tmp
op_eq
l_int|0
suffix:semicolon
)brace
DECL|function|_raw_write_lock
r_static
id|__inline__
r_void
id|_raw_write_lock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;b&t;2f&t;&t;# write_lock&bslash;n&bslash;&n;1:  &t;lwzx&t;%0,0,%1&bslash;n&bslash;&n;&t;cmpwi&t;0,%0,0&bslash;n&bslash;&n;&t;bne+&t;1b&bslash;n&bslash;&n;2:&t;lwarx&t;%0,0,%1&bslash;n&bslash;&n;&t;cmpwi&t;0,%0,0&bslash;n&bslash;&n;&t;bne-&t;1b&bslash;n&quot;
id|PPC405_ERR77
c_func
(paren
l_int|0
comma
op_mod
l_int|1
)paren
l_string|&quot;&t;stwcx.&t;%2,0,%1&bslash;n&bslash;&n;&t;bne-&t;2b&bslash;n&bslash;&n;&t;isync&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
op_amp
id|rw-&gt;lock
)paren
comma
l_string|&quot;r&quot;
(paren
op_minus
l_int|1
)paren
suffix:colon
l_string|&quot;cr0&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
DECL|function|_raw_write_unlock
r_static
id|__inline__
r_void
id|_raw_write_unlock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;eieio&t;&t;# write_unlock&quot;
suffix:colon
suffix:colon
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
id|rw-&gt;lock
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#else
r_extern
r_void
id|_raw_read_lock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
suffix:semicolon
r_extern
r_void
id|_raw_read_unlock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
suffix:semicolon
r_extern
r_void
id|_raw_write_lock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
suffix:semicolon
r_extern
r_void
id|_raw_write_unlock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
suffix:semicolon
r_extern
r_int
id|_raw_write_trylock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
suffix:semicolon
macro_line|#endif
DECL|macro|_raw_read_trylock
mdefine_line|#define _raw_read_trylock(lock) generic_raw_read_trylock(lock)
macro_line|#endif /* __ASM_SPINLOCK_H */
macro_line|#endif /* __KERNEL__ */
eof
