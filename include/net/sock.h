multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Definitions for the AF_INET socket handler.&n; *&n; * Version:&t;@(#)sock.h&t;1.0.4&t;05/13/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;&n; *&t;&t;Florian La Roche &lt;flla@stud.uni-sb.de&gt;&n; *&n; * Fixes:&n; *&t;&t;Alan Cox&t;:&t;Volatiles in skbuff pointers. See&n; *&t;&t;&t;&t;&t;skbuff comments. May be overdone,&n; *&t;&t;&t;&t;&t;better to prove they can be removed&n; *&t;&t;&t;&t;&t;than the reverse.&n; *&t;&t;Alan Cox&t;:&t;Added a zapped field for tcp to note&n; *&t;&t;&t;&t;&t;a socket is reset and must stay shut up&n; *&t;&t;Alan Cox&t;:&t;New fields for options&n; *&t;Pauline Middelink&t;:&t;identd support&n; *&t;&t;Alan Cox&t;:&t;Eliminate low level recv/recvfrom&n; *&t;&t;David S. Miller&t;:&t;New socket lookup architecture.&n; *              Steve Whitehouse:       Default routines for sock_ops&n; *              Arnaldo C. Melo :&t;removed net_pinfo, tp_pinfo and made&n; *              &t;&t;&t;protinfo be just a void pointer, as the&n; *              &t;&t;&t;protocol specific parts were moved to&n; *              &t;&t;&t;respective headers and ipv4/v6, etc now&n; *              &t;&t;&t;use private slabcaches for its socks&n; *              Pedro Hortas&t;:&t;New flags field for socket options&n; *&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#ifndef _SOCK_H
DECL|macro|_SOCK_H
mdefine_line|#define _SOCK_H
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/cache.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;&t;/* struct sk_buff */
macro_line|#include &lt;linux/security.h&gt;
macro_line|#include &lt;linux/filter.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;net/dst.h&gt;
multiline_comment|/*&n; * This structure really needs to be cleaned up.&n; * Most of it is for TCP, and not used by any of&n; * the other protocols.&n; */
multiline_comment|/* Define this to get the sk-&gt;debug debugging facility. */
DECL|macro|SOCK_DEBUGGING
mdefine_line|#define SOCK_DEBUGGING
macro_line|#ifdef SOCK_DEBUGGING
DECL|macro|SOCK_DEBUG
mdefine_line|#define SOCK_DEBUG(sk, msg...) do { if((sk) &amp;&amp; ((sk)-&gt;debug)) printk(KERN_DEBUG msg); } while (0)
macro_line|#else
DECL|macro|SOCK_DEBUG
mdefine_line|#define SOCK_DEBUG(sk, msg...) do { } while (0)
macro_line|#endif
multiline_comment|/* This is the per-socket lock.  The spinlock provides a synchronization&n; * between user contexts and software interrupt processing, whereas the&n; * mini-semaphore synchronizes multiple users amongst themselves.&n; */
r_struct
id|sock_iocb
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|slock
id|spinlock_t
id|slock
suffix:semicolon
DECL|member|owner
r_struct
id|sock_iocb
op_star
id|owner
suffix:semicolon
DECL|member|wq
id|wait_queue_head_t
id|wq
suffix:semicolon
DECL|typedef|socket_lock_t
)brace
id|socket_lock_t
suffix:semicolon
DECL|macro|sock_lock_init
mdefine_line|#define sock_lock_init(__sk) &bslash;&n;do {&t;spin_lock_init(&amp;((__sk)-&gt;lock.slock)); &bslash;&n;&t;(__sk)-&gt;lock.owner = NULL; &bslash;&n;&t;init_waitqueue_head(&amp;((__sk)-&gt;lock.wq)); &bslash;&n;} while(0)
multiline_comment|/**&n;  *&t;struct sock - network layer representation of sockets&n;  *&t;@state - Connection state&n;  *&t;@zapped&t;- ax25 &amp; ipx means !linked&n;  *&t;@reuse - %SO_REUSEADDR setting&n;  *&t;@shutdown - mask of %SEND_SHUTDOWN and/or %RCV_SHUTDOWN&n;  *&t;@bound_dev_if - bound device index if != 0&n;  *&t;@next - main hash linkage for various protocol lookup tables&n;  *&t;@pprev - main hash linkage for various protocol lookup tables&n;  *&t;@bind_next - main hash linkage for various protocol lookup tables&n;  *&t;@bind_pprev - main hash linkage for various protocol lookup tables&n;  *&t;@refcnt - reference count&n;  *&t;@family - network address family&n;  *&t;@use_write_queue - wheter to call sk-&gt;write_space(sk) in sock_wfree&n;  *&t;@userlocks - %SO_SNDBUF and %SO_RCVBUF settings&n;  *&t;@lock -&t;synchronizer&n;  *&t;@rcvbuf - size of receive buffer in bytes&n;  *&t;@sleep - sock wait queue&n;  *&t;@dst_cache - destination cache&n;  *&t;@dst_lock - destination cache lock&n;  *&t;@policy - flow policy&n;  *&t;@rmem_alloc - receive queue bytes committed&n;  *&t;@receive_queue - incoming packets&n;  *&t;@wmem_alloc - transmit queue bytes committed&n;  *&t;@write_queue - Packet sending queue&n;  *&t;@omem_alloc - &quot;o&quot; is &quot;option&quot; or &quot;other&quot;&n;  *&t;@wmem_queued - persistent queue size&n;  *&t;@forward_alloc - space allocated forward&n;  *&t;@allocation - allocation mode&n;  *&t;@sndbuf - size of send buffer in bytes&n;  *&t;@prev - pointer to previous sock in the list this sock is in&n;  *&t;@flags - %SO_LINGER (l_onoff), %SO_BROADCAST, %SO_KEEPALIVE, %SO_OOBINLINE settings&n;  *&t;@no_check - %SO_NO_CHECK setting, wether or not checkup packets&n;  *&t;@debug - %SO_DEBUG setting&n;  *&t;@rcvtstamp - %SO_TIMESTAMP setting&n;  *&t;@no_largesend - whether to sent large segments or not&n;  *&t;@route_caps - route capabilities (e.g. %NETIF_F_TSO)&n;  *&t;@lingertime - %SO_LINGER l_linger setting&n;  *&t;@hashent - hash entry in several tables (e.g. tcp_ehash)&n;  *&t;@pair - socket pair (e.g. AF_UNIX/unix_peer)&n;  *&t;@backlog - always used with the per-socket spinlock held&n;  *&t;@callback_lock - used with the callbacks in the end of this struct&n;  *&t;@error_queue - rarely used&n;  *&t;@prot - protocol handlers inside a network family&n;  *&t;@err - last error&n;  *&t;@err_soft - errors that don&squot;t cause failure but are the cause of a persistent failure not just &squot;timed out&squot;&n;  *&t;@ack_backlog - current listen backlog&n;  *&t;@max_ack_backlog - listen backlog set in listen()&n;  *&t;@priority - %SO_PRIORITY setting&n;  *&t;@type - socket type (%SOCK_STREAM, etc)&n;  *&t;@localroute - route locally only, %SO_DONTROUTE setting&n;  *&t;@protocol - which protocol this socket belongs in this network family&n;  *&t;@peercred - %SO_PEERCRED setting&n;  *&t;@rcvlowat - %SO_RCVLOWAT setting&n;  *&t;@rcvtimeo - %SO_RCVTIMEO setting&n;  *&t;@sndtimeo - %SO_SNDTIMEO setting&n;  *&t;@filter - socket filtering instructions&n;  *&t;@protinfo - private area, net family specific, when not using slab&n;  *&t;@slab - the slabcache this instance was allocated from&n;  *&t;@timer - sock cleanup timer&n;  *&t;@stamp - time stamp of last packet received&n;  *&t;@socket - Identd and reporting IO signals&n;  *&t;@user_data - RPC layer private data&n;  *&t;@owner - module that owns this socket&n;  *&t;@state_change - callback to indicate change in the state of the sock&n;  *&t;@data_ready - callback to indicate there is data to be processed&n;  *&t;@write_space - callback to indicate there is bf sending space available&n;  *&t;@error_report - callback to indicate errors (e.g. %MSG_ERRQUEUE)&n;  *&t;@backlog_rcv - callback to process the backlog&n;  *&t;@destruct - called at sock freeing time, i.e. when all refcnt == 0&n; */
DECL|struct|sock
r_struct
id|sock
(brace
multiline_comment|/* Begin of struct sock/struct tcp_tw_bucket shared layout */
DECL|member|family
r_int
r_int
id|family
suffix:semicolon
DECL|member|state
r_volatile
r_int
r_char
id|state
suffix:semicolon
DECL|member|reuse
r_int
r_char
id|reuse
suffix:semicolon
DECL|member|bound_dev_if
r_int
id|bound_dev_if
suffix:semicolon
DECL|member|next
r_struct
id|sock
op_star
id|next
suffix:semicolon
DECL|member|pprev
r_struct
id|sock
op_star
op_star
id|pprev
suffix:semicolon
DECL|member|bind_next
r_struct
id|sock
op_star
id|bind_next
suffix:semicolon
DECL|member|bind_pprev
r_struct
id|sock
op_star
op_star
id|bind_pprev
suffix:semicolon
DECL|member|refcnt
id|atomic_t
id|refcnt
suffix:semicolon
multiline_comment|/* End of struct sock/struct tcp_tw_bucket shared layout */
DECL|member|zapped
r_volatile
r_int
r_char
id|zapped
suffix:semicolon
DECL|member|shutdown
r_int
r_char
id|shutdown
suffix:semicolon
DECL|member|use_write_queue
r_int
r_char
id|use_write_queue
suffix:semicolon
DECL|member|userlocks
r_int
r_char
id|userlocks
suffix:semicolon
DECL|member|lock
id|socket_lock_t
id|lock
suffix:semicolon
DECL|member|rcvbuf
r_int
id|rcvbuf
suffix:semicolon
DECL|member|sleep
id|wait_queue_head_t
op_star
id|sleep
suffix:semicolon
DECL|member|dst_cache
r_struct
id|dst_entry
op_star
id|dst_cache
suffix:semicolon
DECL|member|dst_lock
id|rwlock_t
id|dst_lock
suffix:semicolon
DECL|member|policy
r_struct
id|xfrm_policy
op_star
id|policy
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|rmem_alloc
id|atomic_t
id|rmem_alloc
suffix:semicolon
DECL|member|receive_queue
r_struct
id|sk_buff_head
id|receive_queue
suffix:semicolon
DECL|member|wmem_alloc
id|atomic_t
id|wmem_alloc
suffix:semicolon
DECL|member|write_queue
r_struct
id|sk_buff_head
id|write_queue
suffix:semicolon
DECL|member|omem_alloc
id|atomic_t
id|omem_alloc
suffix:semicolon
DECL|member|wmem_queued
r_int
id|wmem_queued
suffix:semicolon
DECL|member|forward_alloc
r_int
id|forward_alloc
suffix:semicolon
DECL|member|allocation
r_int
r_int
id|allocation
suffix:semicolon
DECL|member|sndbuf
r_int
id|sndbuf
suffix:semicolon
DECL|member|prev
r_struct
id|sock
op_star
id|prev
suffix:semicolon
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
DECL|member|no_check
r_char
id|no_check
suffix:semicolon
DECL|member|debug
r_int
r_char
id|debug
suffix:semicolon
DECL|member|rcvtstamp
r_int
r_char
id|rcvtstamp
suffix:semicolon
DECL|member|no_largesend
r_int
r_char
id|no_largesend
suffix:semicolon
DECL|member|route_caps
r_int
id|route_caps
suffix:semicolon
DECL|member|lingertime
r_int
r_int
id|lingertime
suffix:semicolon
DECL|member|hashent
r_int
id|hashent
suffix:semicolon
DECL|member|pair
r_struct
id|sock
op_star
id|pair
suffix:semicolon
multiline_comment|/*&n;&t; * The backlog queue is special, it is always used with&n;&t; * the per-socket spinlock held and requires low latency&n;&t; * access. Therefore we special case it&squot;s implementation.&n;&t; */
r_struct
(brace
DECL|member|head
r_struct
id|sk_buff
op_star
id|head
suffix:semicolon
DECL|member|tail
r_struct
id|sk_buff
op_star
id|tail
suffix:semicolon
DECL|member|backlog
)brace
id|backlog
suffix:semicolon
DECL|member|callback_lock
id|rwlock_t
id|callback_lock
suffix:semicolon
DECL|member|error_queue
r_struct
id|sk_buff_head
id|error_queue
suffix:semicolon
DECL|member|prot
r_struct
id|proto
op_star
id|prot
suffix:semicolon
DECL|member|err
r_int
id|err
comma
DECL|member|err_soft
id|err_soft
suffix:semicolon
DECL|member|ack_backlog
r_int
r_int
id|ack_backlog
suffix:semicolon
DECL|member|max_ack_backlog
r_int
r_int
id|max_ack_backlog
suffix:semicolon
DECL|member|priority
id|__u32
id|priority
suffix:semicolon
DECL|member|type
r_int
r_int
id|type
suffix:semicolon
DECL|member|localroute
r_int
r_char
id|localroute
suffix:semicolon
DECL|member|protocol
r_int
r_char
id|protocol
suffix:semicolon
DECL|member|peercred
r_struct
id|ucred
id|peercred
suffix:semicolon
DECL|member|rcvlowat
r_int
id|rcvlowat
suffix:semicolon
DECL|member|rcvtimeo
r_int
id|rcvtimeo
suffix:semicolon
DECL|member|sndtimeo
r_int
id|sndtimeo
suffix:semicolon
DECL|member|filter
r_struct
id|sk_filter
op_star
id|filter
suffix:semicolon
DECL|member|protinfo
r_void
op_star
id|protinfo
suffix:semicolon
DECL|member|slab
id|kmem_cache_t
op_star
id|slab
suffix:semicolon
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
DECL|member|stamp
r_struct
id|timeval
id|stamp
suffix:semicolon
DECL|member|socket
r_struct
id|socket
op_star
id|socket
suffix:semicolon
DECL|member|user_data
r_void
op_star
id|user_data
suffix:semicolon
DECL|member|owner
r_struct
id|module
op_star
id|owner
suffix:semicolon
DECL|member|state_change
r_void
(paren
op_star
id|state_change
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|data_ready
r_void
(paren
op_star
id|data_ready
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|bytes
)paren
suffix:semicolon
DECL|member|write_space
r_void
(paren
op_star
id|write_space
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|error_report
r_void
(paren
op_star
id|error_report
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|backlog_rcv
r_int
(paren
op_star
id|backlog_rcv
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
DECL|member|destruct
r_void
(paren
op_star
id|destruct
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Sock flags */
DECL|enum|sock_flags
r_enum
id|sock_flags
(brace
DECL|enumerator|SOCK_DEAD
id|SOCK_DEAD
comma
DECL|enumerator|SOCK_DONE
id|SOCK_DONE
comma
DECL|enumerator|SOCK_URGINLINE
id|SOCK_URGINLINE
comma
DECL|enumerator|SOCK_KEEPOPEN
id|SOCK_KEEPOPEN
comma
DECL|enumerator|SOCK_LINGER
id|SOCK_LINGER
comma
DECL|enumerator|SOCK_DESTROY
id|SOCK_DESTROY
comma
DECL|enumerator|SOCK_BROADCAST
id|SOCK_BROADCAST
comma
)brace
suffix:semicolon
DECL|function|sock_set_flag
r_static
r_inline
r_void
id|sock_set_flag
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_enum
id|sock_flags
id|flag
)paren
(brace
id|__set_bit
c_func
(paren
id|flag
comma
op_amp
id|sk-&gt;flags
)paren
suffix:semicolon
)brace
DECL|function|sock_reset_flag
r_static
r_inline
r_void
id|sock_reset_flag
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_enum
id|sock_flags
id|flag
)paren
(brace
id|__clear_bit
c_func
(paren
id|flag
comma
op_amp
id|sk-&gt;flags
)paren
suffix:semicolon
)brace
DECL|function|sock_flag
r_static
r_inline
r_int
id|sock_flag
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_enum
id|sock_flags
id|flag
)paren
(brace
r_return
id|test_bit
c_func
(paren
id|flag
comma
op_amp
id|sk-&gt;flags
)paren
suffix:semicolon
)brace
multiline_comment|/* The per-socket spinlock must be held here. */
DECL|macro|sk_add_backlog
mdefine_line|#define sk_add_backlog(__sk, __skb)&t;&t;&t;&bslash;&n;do {&t;if((__sk)-&gt;backlog.tail == NULL) {&t;&t;&bslash;&n;&t;&t;(__sk)-&gt;backlog.head =&t;&t;&t;&bslash;&n;&t;&t;     (__sk)-&gt;backlog.tail = (__skb);&t;&bslash;&n;&t;} else {&t;&t;&t;&t;&t;&bslash;&n;&t;&t;((__sk)-&gt;backlog.tail)-&gt;next = (__skb);&t;&bslash;&n;&t;&t;(__sk)-&gt;backlog.tail = (__skb);&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&bslash;&n;&t;(__skb)-&gt;next = NULL;&t;&t;&t;&t;&bslash;&n;} while(0)
multiline_comment|/* IP protocol blocks we attach to sockets.&n; * socket layer -&gt; transport layer interface&n; * transport -&gt; network interface is defined by struct inet_proto&n; */
DECL|struct|proto
r_struct
id|proto
(brace
DECL|member|close
r_void
(paren
op_star
id|close
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|timeout
)paren
suffix:semicolon
DECL|member|connect
r_int
(paren
op_star
id|connect
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
id|addr_len
)paren
suffix:semicolon
DECL|member|disconnect
r_int
(paren
op_star
id|disconnect
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
)paren
suffix:semicolon
DECL|member|accept
r_struct
id|sock
op_star
(paren
op_star
id|accept
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
comma
r_int
op_star
id|err
)paren
suffix:semicolon
DECL|member|ioctl
r_int
(paren
op_star
id|ioctl
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
DECL|member|init
r_int
(paren
op_star
id|init
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|destroy
r_int
(paren
op_star
id|destroy
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|shutdown
r_void
(paren
op_star
id|shutdown
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|how
)paren
suffix:semicolon
DECL|member|setsockopt
r_int
(paren
op_star
id|setsockopt
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
suffix:semicolon
DECL|member|getsockopt
r_int
(paren
op_star
id|getsockopt
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|option
)paren
suffix:semicolon
DECL|member|sendmsg
r_int
(paren
op_star
id|sendmsg
)paren
(paren
r_struct
id|kiocb
op_star
id|iocb
comma
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|len
)paren
suffix:semicolon
DECL|member|recvmsg
r_int
(paren
op_star
id|recvmsg
)paren
(paren
r_struct
id|kiocb
op_star
id|iocb
comma
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|len
comma
r_int
id|noblock
comma
r_int
id|flags
comma
r_int
op_star
id|addr_len
)paren
suffix:semicolon
DECL|member|sendpage
r_int
(paren
op_star
id|sendpage
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|offset
comma
r_int
id|size
comma
r_int
id|flags
)paren
suffix:semicolon
DECL|member|bind
r_int
(paren
op_star
id|bind
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
id|addr_len
)paren
suffix:semicolon
DECL|member|backlog_rcv
r_int
(paren
op_star
id|backlog_rcv
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
multiline_comment|/* Keeping track of sk&squot;s, looking them up, and port selection methods. */
DECL|member|hash
r_void
(paren
op_star
id|hash
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|unhash
r_void
(paren
op_star
id|unhash
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|get_port
r_int
(paren
op_star
id|get_port
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|snum
)paren
suffix:semicolon
DECL|member|name
r_char
id|name
(braket
l_int|32
)braket
suffix:semicolon
r_struct
(brace
DECL|member|inuse
r_int
id|inuse
suffix:semicolon
DECL|member|__pad
id|u8
id|__pad
(braket
id|SMP_CACHE_BYTES
op_minus
r_sizeof
(paren
r_int
)paren
)braket
suffix:semicolon
DECL|member|stats
)brace
id|stats
(braket
id|NR_CPUS
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|function|sk_set_owner
r_static
id|__inline__
r_void
id|sk_set_owner
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|module
op_star
id|owner
)paren
(brace
multiline_comment|/*&n;&t; * One should use sk_set_owner just once, after struct sock creation,&n;&t; * be it shortly after sk_alloc or after a function that returns a new&n;&t; * struct sock (and that down the call chain called sk_alloc), e.g. the&n;&t; * IPv4 and IPv6 modules share tcp_create_openreq_child, so if&n;&t; * tcp_create_openreq_child called sk_set_owner IPv6 would have to&n;&t; * change the ownership of this struct sock, with one not needed&n;&t; * transient sk_set_owner call.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|sk-&gt;owner
op_ne
l_int|NULL
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|sk-&gt;owner
op_assign
id|owner
suffix:semicolon
id|__module_get
c_func
(paren
id|owner
)paren
suffix:semicolon
)brace
multiline_comment|/* Called with local bh disabled */
DECL|function|sock_prot_inc_use
r_static
id|__inline__
r_void
id|sock_prot_inc_use
c_func
(paren
r_struct
id|proto
op_star
id|prot
)paren
(brace
id|prot-&gt;stats
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
dot
id|inuse
op_increment
suffix:semicolon
)brace
DECL|function|sock_prot_dec_use
r_static
id|__inline__
r_void
id|sock_prot_dec_use
c_func
(paren
r_struct
id|proto
op_star
id|prot
)paren
(brace
id|prot-&gt;stats
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
dot
id|inuse
op_decrement
suffix:semicolon
)brace
multiline_comment|/* About 10 seconds */
DECL|macro|SOCK_DESTROY_TIME
mdefine_line|#define SOCK_DESTROY_TIME (10*HZ)
multiline_comment|/* Sockets 0-1023 can&squot;t be bound to unless you are superuser */
DECL|macro|PROT_SOCK
mdefine_line|#define PROT_SOCK&t;1024
DECL|macro|SHUTDOWN_MASK
mdefine_line|#define SHUTDOWN_MASK&t;3
DECL|macro|RCV_SHUTDOWN
mdefine_line|#define RCV_SHUTDOWN&t;1
DECL|macro|SEND_SHUTDOWN
mdefine_line|#define SEND_SHUTDOWN&t;2
DECL|macro|SOCK_SNDBUF_LOCK
mdefine_line|#define SOCK_SNDBUF_LOCK&t;1
DECL|macro|SOCK_RCVBUF_LOCK
mdefine_line|#define SOCK_RCVBUF_LOCK&t;2
DECL|macro|SOCK_BINDADDR_LOCK
mdefine_line|#define SOCK_BINDADDR_LOCK&t;4
DECL|macro|SOCK_BINDPORT_LOCK
mdefine_line|#define SOCK_BINDPORT_LOCK&t;8
multiline_comment|/* sock_iocb: used to kick off async processing of socket ios */
DECL|struct|sock_iocb
r_struct
id|sock_iocb
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|flags
r_int
id|flags
suffix:semicolon
DECL|member|size
r_int
id|size
suffix:semicolon
DECL|member|sock
r_struct
id|socket
op_star
id|sock
suffix:semicolon
DECL|member|sk
r_struct
id|sock
op_star
id|sk
suffix:semicolon
DECL|member|scm
r_struct
id|scm_cookie
op_star
id|scm
suffix:semicolon
DECL|member|msg
DECL|member|async_msg
r_struct
id|msghdr
op_star
id|msg
comma
id|async_msg
suffix:semicolon
DECL|member|async_iov
r_struct
id|iovec
id|async_iov
suffix:semicolon
)brace
suffix:semicolon
DECL|function|kiocb_to_siocb
r_static
r_inline
r_struct
id|sock_iocb
op_star
id|kiocb_to_siocb
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
)paren
(brace
id|BUG_ON
c_func
(paren
r_sizeof
(paren
r_struct
id|sock_iocb
)paren
OG
id|KIOCB_PRIVATE_SIZE
)paren
suffix:semicolon
r_return
(paren
r_struct
id|sock_iocb
op_star
)paren
id|iocb
op_member_access_from_pointer
r_private
suffix:semicolon
)brace
DECL|function|siocb_to_kiocb
r_static
r_inline
r_struct
id|kiocb
op_star
id|siocb_to_kiocb
c_func
(paren
r_struct
id|sock_iocb
op_star
id|si
)paren
(brace
r_return
id|container_of
c_func
(paren
(paren
r_void
op_star
)paren
id|si
comma
r_struct
id|kiocb
comma
r_private
)paren
suffix:semicolon
)brace
DECL|struct|socket_alloc
r_struct
id|socket_alloc
(brace
DECL|member|socket
r_struct
id|socket
id|socket
suffix:semicolon
DECL|member|vfs_inode
r_struct
id|inode
id|vfs_inode
suffix:semicolon
)brace
suffix:semicolon
DECL|function|SOCKET_I
r_static
r_inline
r_struct
id|socket
op_star
id|SOCKET_I
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_return
op_amp
id|container_of
c_func
(paren
id|inode
comma
r_struct
id|socket_alloc
comma
id|vfs_inode
)paren
op_member_access_from_pointer
id|socket
suffix:semicolon
)brace
DECL|function|SOCK_INODE
r_static
r_inline
r_struct
id|inode
op_star
id|SOCK_INODE
c_func
(paren
r_struct
id|socket
op_star
id|socket
)paren
(brace
r_return
op_amp
id|container_of
c_func
(paren
id|socket
comma
r_struct
id|socket_alloc
comma
id|socket
)paren
op_member_access_from_pointer
id|vfs_inode
suffix:semicolon
)brace
multiline_comment|/* Used by processes to &quot;lock&quot; a socket state, so that&n; * interrupts and bottom half handlers won&squot;t change it&n; * from under us. It essentially blocks any incoming&n; * packets, so that we won&squot;t get any new data or any&n; * packets that change the state of the socket.&n; *&n; * While locked, BH processing will add new packets to&n; * the backlog queue.  This queue is processed by the&n; * owner of the socket lock right before it is released.&n; *&n; * Since ~2.3.5 it is also exclusive sleep lock serializing&n; * accesses from user process context.&n; */
r_extern
r_void
id|__lock_sock
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_void
id|__release_sock
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|macro|sock_owned_by_user
mdefine_line|#define sock_owned_by_user(sk)&t;(NULL != (sk)-&gt;lock.owner)
DECL|macro|lock_sock
mdefine_line|#define lock_sock(__sk) &bslash;&n;do {&t;might_sleep(); &bslash;&n;&t;spin_lock_bh(&amp;((__sk)-&gt;lock.slock)); &bslash;&n;&t;if ((__sk)-&gt;lock.owner != NULL) &bslash;&n;&t;&t;__lock_sock(__sk); &bslash;&n;&t;(__sk)-&gt;lock.owner = (void *)1; &bslash;&n;&t;spin_unlock_bh(&amp;((__sk)-&gt;lock.slock)); &bslash;&n;} while(0)
DECL|macro|release_sock
mdefine_line|#define release_sock(__sk) &bslash;&n;do {&t;spin_lock_bh(&amp;((__sk)-&gt;lock.slock)); &bslash;&n;&t;if ((__sk)-&gt;backlog.tail != NULL) &bslash;&n;&t;&t;__release_sock(__sk); &bslash;&n;&t;(__sk)-&gt;lock.owner = NULL; &bslash;&n;        if (waitqueue_active(&amp;((__sk)-&gt;lock.wq))) wake_up(&amp;((__sk)-&gt;lock.wq)); &bslash;&n;&t;spin_unlock_bh(&amp;((__sk)-&gt;lock.slock)); &bslash;&n;} while(0)
multiline_comment|/* BH context may only use the following locking interface. */
DECL|macro|bh_lock_sock
mdefine_line|#define bh_lock_sock(__sk)&t;spin_lock(&amp;((__sk)-&gt;lock.slock))
DECL|macro|bh_unlock_sock
mdefine_line|#define bh_unlock_sock(__sk)&t;spin_unlock(&amp;((__sk)-&gt;lock.slock))
r_extern
r_struct
id|sock
op_star
id|sk_alloc
c_func
(paren
r_int
id|family
comma
r_int
id|priority
comma
r_int
id|zero_it
comma
id|kmem_cache_t
op_star
id|slab
)paren
suffix:semicolon
r_extern
r_void
id|sk_free
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|sock_wmalloc
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|size
comma
r_int
id|force
comma
r_int
id|priority
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|sock_rmalloc
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|size
comma
r_int
id|force
comma
r_int
id|priority
)paren
suffix:semicolon
r_extern
r_void
id|sock_wfree
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_extern
r_void
id|sock_rfree
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_extern
r_int
id|sock_setsockopt
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|level
comma
r_int
id|op
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|optlen
)paren
suffix:semicolon
r_extern
r_int
id|sock_getsockopt
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|level
comma
r_int
id|op
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|__user
op_star
id|optlen
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|sock_alloc_send_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|size
comma
r_int
id|noblock
comma
r_int
op_star
id|errcode
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|sock_alloc_send_pskb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|header_len
comma
r_int
r_int
id|data_len
comma
r_int
id|noblock
comma
r_int
op_star
id|errcode
)paren
suffix:semicolon
r_extern
r_void
op_star
id|sock_kmalloc
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|size
comma
r_int
id|priority
)paren
suffix:semicolon
r_extern
r_void
id|sock_kfree_s
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_void
op_star
id|mem
comma
r_int
id|size
)paren
suffix:semicolon
r_extern
r_void
id|sk_send_sigurg
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n; * Functions to fill in entries in struct proto_ops when a protocol&n; * does not implement a particular function.&n; */
r_extern
r_int
id|sock_no_release
c_func
(paren
r_struct
id|socket
op_star
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_bind
c_func
(paren
r_struct
id|socket
op_star
comma
r_struct
id|sockaddr
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_connect
c_func
(paren
r_struct
id|socket
op_star
comma
r_struct
id|sockaddr
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_socketpair
c_func
(paren
r_struct
id|socket
op_star
comma
r_struct
id|socket
op_star
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_accept
c_func
(paren
r_struct
id|socket
op_star
comma
r_struct
id|socket
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_getname
c_func
(paren
r_struct
id|socket
op_star
comma
r_struct
id|sockaddr
op_star
comma
r_int
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
r_int
id|sock_no_poll
c_func
(paren
r_struct
id|file
op_star
comma
r_struct
id|socket
op_star
comma
r_struct
id|poll_table_struct
op_star
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_ioctl
c_func
(paren
r_struct
id|socket
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_listen
c_func
(paren
r_struct
id|socket
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_shutdown
c_func
(paren
r_struct
id|socket
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_getsockopt
c_func
(paren
r_struct
id|socket
op_star
comma
r_int
comma
r_int
comma
r_char
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_setsockopt
c_func
(paren
r_struct
id|socket
op_star
comma
r_int
comma
r_int
comma
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_sendmsg
c_func
(paren
r_struct
id|kiocb
op_star
comma
r_struct
id|socket
op_star
comma
r_struct
id|msghdr
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_recvmsg
c_func
(paren
r_struct
id|kiocb
op_star
comma
r_struct
id|socket
op_star
comma
r_struct
id|msghdr
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
suffix:semicolon
r_extern
id|ssize_t
id|sock_no_sendpage
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|offset
comma
r_int
id|size
comma
r_int
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Default socket callbacks and setup code&n; */
r_extern
r_void
id|sock_def_destruct
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
multiline_comment|/* Initialise core socket variables */
r_extern
r_void
id|sock_init_data
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;sk_filter - run a packet through a socket filter&n; *&t;@sk: sock associated with &amp;sk_buff&n; *&t;@skb: buffer to filter&n; *&t;@needlock: set to 1 if the sock is not locked by caller.&n; *&n; * Run the filter code and then cut skb-&gt;data to correct size returned by&n; * sk_run_filter. If pkt_len is 0 we toss packet. If skb-&gt;len is smaller&n; * than pkt_len we keep whole skb-&gt;data. This is the socket level&n; * wrapper to sk_run_filter. It returns 0 if the packet should&n; * be accepted or -EPERM if the packet should be tossed.&n; *&n; */
DECL|function|sk_filter
r_static
r_inline
r_int
id|sk_filter
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|needlock
)paren
(brace
r_int
id|err
suffix:semicolon
id|err
op_assign
id|security_sock_rcv_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;filter
)paren
(brace
r_struct
id|sk_filter
op_star
id|filter
suffix:semicolon
r_if
c_cond
(paren
id|needlock
)paren
id|bh_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|filter
op_assign
id|sk-&gt;filter
suffix:semicolon
r_if
c_cond
(paren
id|filter
)paren
(brace
r_int
id|pkt_len
op_assign
id|sk_run_filter
c_func
(paren
id|skb
comma
id|filter-&gt;insns
comma
id|filter-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pkt_len
)paren
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_else
id|skb_trim
c_func
(paren
id|skb
comma
id|pkt_len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|needlock
)paren
id|bh_unlock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;sk_filter_release: Release a socket filter&n; *&t;@sk: socket&n; *&t;@fp: filter to remove&n; *&n; *&t;Remove a filter from a socket and release its resources.&n; */
DECL|function|sk_filter_release
r_static
r_inline
r_void
id|sk_filter_release
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_filter
op_star
id|fp
)paren
(brace
r_int
r_int
id|size
op_assign
id|sk_filter_len
c_func
(paren
id|fp
)paren
suffix:semicolon
id|atomic_sub
c_func
(paren
id|size
comma
op_amp
id|sk-&gt;omem_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|fp-&gt;refcnt
)paren
)paren
id|kfree
c_func
(paren
id|fp
)paren
suffix:semicolon
)brace
DECL|function|sk_filter_charge
r_static
r_inline
r_void
id|sk_filter_charge
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_filter
op_star
id|fp
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|fp-&gt;refcnt
)paren
suffix:semicolon
id|atomic_add
c_func
(paren
id|sk_filter_len
c_func
(paren
id|fp
)paren
comma
op_amp
id|sk-&gt;omem_alloc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Socket reference counting postulates.&n; *&n; * * Each user of socket SHOULD hold a reference count.&n; * * Each access point to socket (an hash table bucket, reference from a list,&n; *   running timer, skb in flight MUST hold a reference count.&n; * * When reference count hits 0, it means it will never increase back.&n; * * When reference count hits 0, it means that no references from&n; *   outside exist to this socket and current process on current CPU&n; *   is last user and may/should destroy this socket.&n; * * sk_free is called from any context: process, BH, IRQ. When&n; *   it is called, socket has no references from outside -&gt; sk_free&n; *   may release descendant resources allocated by the socket, but&n; *   to the time when it is called, socket is NOT referenced by any&n; *   hash tables, lists etc.&n; * * Packets, delivered from outside (from network or from another process)&n; *   and enqueued on receive/error queues SHOULD NOT grab reference count,&n; *   when they sit in queue. Otherwise, packets will leak to hole, when&n; *   socket is looked up by one cpu and unhasing is made by another CPU.&n; *   It is true for udp/raw, netlink (leak to receive and error queues), tcp&n; *   (leak to backlog). Packet socket does all the processing inside&n; *   BR_NETPROTO_LOCK, so that it has not this race condition. UNIX sockets&n; *   use separate SMP lock, so that they are prone too.&n; */
multiline_comment|/* Grab socket reference count. This operation is valid only&n;   when sk is ALREADY grabbed f.e. it is found in hash table&n;   or a list and the lookup is made under lock preventing hash table&n;   modifications.&n; */
DECL|function|sock_hold
r_static
r_inline
r_void
id|sock_hold
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|sk-&gt;refcnt
)paren
suffix:semicolon
)brace
multiline_comment|/* Ungrab socket in the context, which assumes that socket refcnt&n;   cannot hit zero, f.e. it is true in context of any socketcall.&n; */
DECL|function|__sock_put
r_static
r_inline
r_void
id|__sock_put
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|sk-&gt;refcnt
)paren
suffix:semicolon
)brace
multiline_comment|/* Ungrab socket and destroy it, if it was the last reference. */
DECL|function|sock_put
r_static
r_inline
r_void
id|sock_put
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|sk-&gt;refcnt
)paren
)paren
id|sk_free
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/* Detach socket from process context.&n; * Announce socket dead, detach it from wait queue and inode.&n; * Note that parent inode held reference count on this struct sock,&n; * we do not release it in this function, because protocol&n; * probably wants some additional cleanups or even continuing&n; * to work with this socket (TCP).&n; */
DECL|function|sock_orphan
r_static
r_inline
r_void
id|sock_orphan
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
id|sock_set_flag
c_func
(paren
id|sk
comma
id|SOCK_DEAD
)paren
suffix:semicolon
id|sk-&gt;socket
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;sleep
op_assign
l_int|NULL
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
)brace
DECL|function|sock_graft
r_static
r_inline
r_void
id|sock_graft
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|socket
op_star
id|parent
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
id|sk-&gt;sleep
op_assign
op_amp
id|parent-&gt;wait
suffix:semicolon
id|parent-&gt;sk
op_assign
id|sk
suffix:semicolon
id|sk-&gt;socket
op_assign
id|parent
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
)brace
DECL|function|sock_i_uid
r_static
r_inline
r_int
id|sock_i_uid
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|uid
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
id|uid
op_assign
id|sk-&gt;socket
ques
c_cond
id|SOCK_INODE
c_func
(paren
id|sk-&gt;socket
)paren
op_member_access_from_pointer
id|i_uid
suffix:colon
l_int|0
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
r_return
id|uid
suffix:semicolon
)brace
DECL|function|sock_i_ino
r_static
r_inline
r_int
r_int
id|sock_i_ino
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
r_int
id|ino
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
id|ino
op_assign
id|sk-&gt;socket
ques
c_cond
id|SOCK_INODE
c_func
(paren
id|sk-&gt;socket
)paren
op_member_access_from_pointer
id|i_ino
suffix:colon
l_int|0
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
r_return
id|ino
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|dst_entry
op_star
DECL|function|__sk_dst_get
id|__sk_dst_get
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|sk-&gt;dst_cache
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|dst_entry
op_star
DECL|function|sk_dst_get
id|sk_dst_get
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|dst_entry
op_star
id|dst
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|sk-&gt;dst_lock
)paren
suffix:semicolon
id|dst
op_assign
id|sk-&gt;dst_cache
suffix:semicolon
r_if
c_cond
(paren
id|dst
)paren
id|dst_hold
c_func
(paren
id|dst
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|sk-&gt;dst_lock
)paren
suffix:semicolon
r_return
id|dst
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|__sk_dst_set
id|__sk_dst_set
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|dst_entry
op_star
id|dst
)paren
(brace
r_struct
id|dst_entry
op_star
id|old_dst
suffix:semicolon
id|old_dst
op_assign
id|sk-&gt;dst_cache
suffix:semicolon
id|sk-&gt;dst_cache
op_assign
id|dst
suffix:semicolon
id|dst_release
c_func
(paren
id|old_dst
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|sk_dst_set
id|sk_dst_set
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|dst_entry
op_star
id|dst
)paren
(brace
id|write_lock
c_func
(paren
op_amp
id|sk-&gt;dst_lock
)paren
suffix:semicolon
id|__sk_dst_set
c_func
(paren
id|sk
comma
id|dst
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|sk-&gt;dst_lock
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|__sk_dst_reset
id|__sk_dst_reset
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|dst_entry
op_star
id|old_dst
suffix:semicolon
id|old_dst
op_assign
id|sk-&gt;dst_cache
suffix:semicolon
id|sk-&gt;dst_cache
op_assign
l_int|NULL
suffix:semicolon
id|dst_release
c_func
(paren
id|old_dst
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|sk_dst_reset
id|sk_dst_reset
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|write_lock
c_func
(paren
op_amp
id|sk-&gt;dst_lock
)paren
suffix:semicolon
id|__sk_dst_reset
c_func
(paren
id|sk
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|sk-&gt;dst_lock
)paren
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|dst_entry
op_star
DECL|function|__sk_dst_check
id|__sk_dst_check
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|cookie
)paren
(brace
r_struct
id|dst_entry
op_star
id|dst
op_assign
id|sk-&gt;dst_cache
suffix:semicolon
r_if
c_cond
(paren
id|dst
op_logical_and
id|dst-&gt;obsolete
op_logical_and
id|dst-&gt;ops
op_member_access_from_pointer
id|check
c_func
(paren
id|dst
comma
id|cookie
)paren
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;dst_cache
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|dst
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|dst_entry
op_star
DECL|function|sk_dst_check
id|sk_dst_check
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|cookie
)paren
(brace
r_struct
id|dst_entry
op_star
id|dst
op_assign
id|sk_dst_get
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dst
op_logical_and
id|dst-&gt;obsolete
op_logical_and
id|dst-&gt;ops
op_member_access_from_pointer
id|check
c_func
(paren
id|dst
comma
id|cookie
)paren
op_eq
l_int|NULL
)paren
(brace
id|sk_dst_reset
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|dst
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Queue a received datagram if it will fit. Stream and sequenced&n; *&t;protocols can&squot;t normally use this as they need to fit buffers in&n; *&t;and play with them.&n; *&n; * &t;Inlined as it&squot;s very short and called for pretty much every&n; *&t;packet ever received.&n; */
DECL|function|skb_set_owner_w
r_static
r_inline
r_void
id|skb_set_owner_w
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|skb-&gt;destructor
op_assign
id|sock_wfree
suffix:semicolon
id|atomic_add
c_func
(paren
id|skb-&gt;truesize
comma
op_amp
id|sk-&gt;wmem_alloc
)paren
suffix:semicolon
)brace
DECL|function|skb_set_owner_r
r_static
r_inline
r_void
id|skb_set_owner_r
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|skb-&gt;destructor
op_assign
id|sock_rfree
suffix:semicolon
id|atomic_add
c_func
(paren
id|skb-&gt;truesize
comma
op_amp
id|sk-&gt;rmem_alloc
)paren
suffix:semicolon
)brace
DECL|function|sock_queue_rcv_skb
r_static
r_inline
r_int
id|sock_queue_rcv_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Cast skb-&gt;rcvbuf to unsigned... It&squot;s pointless, but reduces&n;&t;   number of warnings when compiling with -W --ANK&n;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
op_plus
id|skb-&gt;truesize
op_ge
(paren
r_int
)paren
id|sk-&gt;rcvbuf
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* It would be deadlock, if sock_queue_rcv_skb is used&n;&t;   with socket lock! We assume that users of this&n;&t;   function are lock free.&n;&t;*/
id|err
op_assign
id|sk_filter
c_func
(paren
id|sk
comma
id|skb
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|skb-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
id|skb_set_owner_r
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sock_flag
c_func
(paren
id|sk
comma
id|SOCK_DEAD
)paren
)paren
id|sk
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|sk
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sock_queue_err_skb
r_static
r_inline
r_int
id|sock_queue_err_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
multiline_comment|/* Cast skb-&gt;rcvbuf to unsigned... It&squot;s pointless, but reduces&n;&t;   number of warnings when compiling with -W --ANK&n;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
op_plus
id|skb-&gt;truesize
op_ge
(paren
r_int
)paren
id|sk-&gt;rcvbuf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|skb_set_owner_r
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;error_queue
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sock_flag
c_func
(paren
id|sk
comma
id|SOCK_DEAD
)paren
)paren
id|sk
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|sk
comma
id|skb-&gt;len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Recover an error report and clear atomically&n; */
DECL|function|sock_error
r_static
r_inline
r_int
id|sock_error
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|err
op_assign
id|xchg
c_func
(paren
op_amp
id|sk-&gt;err
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|err
suffix:semicolon
)brace
DECL|function|sock_wspace
r_static
r_inline
r_int
r_int
id|sock_wspace
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|amt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
)paren
(brace
id|amt
op_assign
id|sk-&gt;sndbuf
op_minus
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|amt
OL
l_int|0
)paren
id|amt
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|amt
suffix:semicolon
)brace
DECL|function|sk_wake_async
r_static
r_inline
r_void
id|sk_wake_async
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|how
comma
r_int
id|band
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;socket
op_logical_and
id|sk-&gt;socket-&gt;fasync_list
)paren
id|sock_wake_async
c_func
(paren
id|sk-&gt;socket
comma
id|how
comma
id|band
)paren
suffix:semicolon
)brace
DECL|macro|SOCK_MIN_SNDBUF
mdefine_line|#define SOCK_MIN_SNDBUF 2048
DECL|macro|SOCK_MIN_RCVBUF
mdefine_line|#define SOCK_MIN_RCVBUF 256
multiline_comment|/*&n; *&t;Default write policy as shown to user space via poll/select/SIGIO&n; */
DECL|function|sock_writeable
r_static
r_inline
r_int
id|sock_writeable
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
OL
(paren
id|sk-&gt;sndbuf
op_div
l_int|2
)paren
suffix:semicolon
)brace
DECL|function|gfp_any
r_static
r_inline
r_int
id|gfp_any
c_func
(paren
r_void
)paren
(brace
r_return
id|in_softirq
c_func
(paren
)paren
ques
c_cond
id|GFP_ATOMIC
suffix:colon
id|GFP_KERNEL
suffix:semicolon
)brace
DECL|function|sock_rcvtimeo
r_static
r_inline
r_int
id|sock_rcvtimeo
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|noblock
)paren
(brace
r_return
id|noblock
ques
c_cond
l_int|0
suffix:colon
id|sk-&gt;rcvtimeo
suffix:semicolon
)brace
DECL|function|sock_sndtimeo
r_static
r_inline
r_int
id|sock_sndtimeo
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|noblock
)paren
(brace
r_return
id|noblock
ques
c_cond
l_int|0
suffix:colon
id|sk-&gt;sndtimeo
suffix:semicolon
)brace
DECL|function|sock_rcvlowat
r_static
r_inline
r_int
id|sock_rcvlowat
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|waitall
comma
r_int
id|len
)paren
(brace
r_return
(paren
id|waitall
ques
c_cond
id|len
suffix:colon
id|min_t
c_func
(paren
r_int
comma
id|sk-&gt;rcvlowat
comma
id|len
)paren
)paren
ques
c_cond
suffix:colon
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Alas, with timeout socket operations are not restartable.&n; * Compare this to poll().&n; */
DECL|function|sock_intr_errno
r_static
r_inline
r_int
id|sock_intr_errno
c_func
(paren
r_int
id|timeo
)paren
(brace
r_return
id|timeo
op_eq
id|MAX_SCHEDULE_TIMEOUT
ques
c_cond
op_minus
id|ERESTARTSYS
suffix:colon
op_minus
id|EINTR
suffix:semicolon
)brace
r_static
id|__inline__
r_void
DECL|function|sock_recv_timestamp
id|sock_recv_timestamp
c_func
(paren
r_struct
id|msghdr
op_star
id|msg
comma
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;rcvtstamp
)paren
id|put_cmsg
c_func
(paren
id|msg
comma
id|SOL_SOCKET
comma
id|SO_TIMESTAMP
comma
r_sizeof
(paren
id|skb-&gt;stamp
)paren
comma
op_amp
id|skb-&gt;stamp
)paren
suffix:semicolon
r_else
id|sk-&gt;stamp
op_assign
id|skb-&gt;stamp
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Enable debug/info messages &n; */
macro_line|#if 0
mdefine_line|#define NETDEBUG(x)&t;do { } while (0)
macro_line|#else
DECL|macro|NETDEBUG
mdefine_line|#define NETDEBUG(x)&t;do { x; } while (0)
macro_line|#endif
multiline_comment|/*&n; * Macros for sleeping on a socket. Use them like this:&n; *&n; * SOCK_SLEEP_PRE(sk)&n; * if (condition)&n; * &t;schedule();&n; * SOCK_SLEEP_POST(sk)&n; *&n; * N.B. These are now obsolete and were, afaik, only ever used in DECnet&n; * and when the last use of them in DECnet has gone, I&squot;m intending to&n; * remove them.&n; */
DECL|macro|SOCK_SLEEP_PRE
mdefine_line|#define SOCK_SLEEP_PRE(sk) &t;{ struct task_struct *tsk = current; &bslash;&n;&t;&t;&t;&t;DECLARE_WAITQUEUE(wait, tsk); &bslash;&n;&t;&t;&t;&t;tsk-&gt;state = TASK_INTERRUPTIBLE; &bslash;&n;&t;&t;&t;&t;add_wait_queue((sk)-&gt;sleep, &amp;wait); &bslash;&n;&t;&t;&t;&t;release_sock(sk);
DECL|macro|SOCK_SLEEP_POST
mdefine_line|#define SOCK_SLEEP_POST(sk)&t;tsk-&gt;state = TASK_RUNNING; &bslash;&n;&t;&t;&t;&t;remove_wait_queue((sk)-&gt;sleep, &amp;wait); &bslash;&n;&t;&t;&t;&t;lock_sock(sk); &bslash;&n;&t;&t;&t;&t;}
DECL|function|sock_valbool_flag
r_static
r_inline
r_void
id|sock_valbool_flag
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|bit
comma
r_int
id|valbool
)paren
(brace
r_if
c_cond
(paren
id|valbool
)paren
id|sock_set_flag
c_func
(paren
id|sk
comma
id|bit
)paren
suffix:semicolon
r_else
id|sock_reset_flag
c_func
(paren
id|sk
comma
id|bit
)paren
suffix:semicolon
)brace
r_extern
id|__u32
id|sysctl_wmem_max
suffix:semicolon
r_extern
id|__u32
id|sysctl_rmem_max
suffix:semicolon
r_int
id|siocdevprivate_ioctl
c_func
(paren
r_int
r_int
id|fd
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
macro_line|#endif&t;/* _SOCK_H */
eof
