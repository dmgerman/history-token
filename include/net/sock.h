multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Definitions for the AF_INET socket handler.&n; *&n; * Version:&t;@(#)sock.h&t;1.0.4&t;05/13/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;&n; *&t;&t;Florian La Roche &lt;flla@stud.uni-sb.de&gt;&n; *&n; * Fixes:&n; *&t;&t;Alan Cox&t;:&t;Volatiles in skbuff pointers. See&n; *&t;&t;&t;&t;&t;skbuff comments. May be overdone,&n; *&t;&t;&t;&t;&t;better to prove they can be removed&n; *&t;&t;&t;&t;&t;than the reverse.&n; *&t;&t;Alan Cox&t;:&t;Added a zapped field for tcp to note&n; *&t;&t;&t;&t;&t;a socket is reset and must stay shut up&n; *&t;&t;Alan Cox&t;:&t;New fields for options&n; *&t;Pauline Middelink&t;:&t;identd support&n; *&t;&t;Alan Cox&t;:&t;Eliminate low level recv/recvfrom&n; *&t;&t;David S. Miller&t;:&t;New socket lookup architecture.&n; *              Steve Whitehouse:       Default routines for sock_ops&n; *              Arnaldo C. Melo :&t;removed net_pinfo, tp_pinfo and made&n; *              &t;&t;&t;protinfo be just a void pointer, as the&n; *              &t;&t;&t;protocol specific parts were moved to&n; *              &t;&t;&t;respective headers and ipv4/v6, etc now&n; *              &t;&t;&t;use private slabcaches for its socks&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#ifndef _SOCK_H
DECL|macro|_SOCK_H
mdefine_line|#define _SOCK_H
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/cache.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;&t;/* struct sk_buff */
macro_line|#ifdef CONFIG_FILTER
macro_line|#include &lt;linux/filter.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;net/dst.h&gt;
macro_line|#include &lt;net/scm.h&gt;&t;/* for sock_iocb */
multiline_comment|/*&n; * This structure really needs to be cleaned up.&n; * Most of it is for TCP, and not used by any of&n; * the other protocols.&n; */
multiline_comment|/* Define this to get the sk-&gt;debug debugging facility. */
DECL|macro|SOCK_DEBUGGING
mdefine_line|#define SOCK_DEBUGGING
macro_line|#ifdef SOCK_DEBUGGING
DECL|macro|SOCK_DEBUG
mdefine_line|#define SOCK_DEBUG(sk, msg...) do { if((sk) &amp;&amp; ((sk)-&gt;debug)) printk(KERN_DEBUG msg); } while (0)
macro_line|#else
DECL|macro|SOCK_DEBUG
mdefine_line|#define SOCK_DEBUG(sk, msg...) do { } while (0)
macro_line|#endif
multiline_comment|/* This is the per-socket lock.  The spinlock provides a synchronization&n; * between user contexts and software interrupt processing, whereas the&n; * mini-semaphore synchronizes multiple users amongst themselves.&n; */
r_struct
id|sock_iocb
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|slock
id|spinlock_t
id|slock
suffix:semicolon
DECL|member|owner
r_struct
id|sock_iocb
op_star
id|owner
suffix:semicolon
DECL|member|wq
id|wait_queue_head_t
id|wq
suffix:semicolon
DECL|typedef|socket_lock_t
)brace
id|socket_lock_t
suffix:semicolon
DECL|macro|sock_lock_init
mdefine_line|#define sock_lock_init(__sk) &bslash;&n;do {&t;spin_lock_init(&amp;((__sk)-&gt;lock.slock)); &bslash;&n;&t;(__sk)-&gt;lock.owner = NULL; &bslash;&n;&t;init_waitqueue_head(&amp;((__sk)-&gt;lock.wq)); &bslash;&n;} while(0)
DECL|struct|sock
r_struct
id|sock
(brace
multiline_comment|/* Begin of struct sock/struct tcp_tw_bucket shared layout */
DECL|member|state
r_volatile
r_int
r_char
id|state
comma
multiline_comment|/* Connection state */
DECL|member|zapped
id|zapped
suffix:semicolon
multiline_comment|/* ax25 &amp; ipx means !linked */
DECL|member|reuse
r_int
r_char
id|reuse
suffix:semicolon
multiline_comment|/* SO_REUSEADDR setting */
DECL|member|shutdown
r_int
r_char
id|shutdown
suffix:semicolon
DECL|member|bound_dev_if
r_int
id|bound_dev_if
suffix:semicolon
multiline_comment|/* Bound device index if != 0 */
multiline_comment|/* Main hash linkage for various protocol lookup tables. */
DECL|member|next
r_struct
id|sock
op_star
id|next
suffix:semicolon
DECL|member|pprev
r_struct
id|sock
op_star
op_star
id|pprev
suffix:semicolon
DECL|member|bind_next
r_struct
id|sock
op_star
id|bind_next
suffix:semicolon
DECL|member|bind_pprev
r_struct
id|sock
op_star
op_star
id|bind_pprev
suffix:semicolon
DECL|member|refcnt
id|atomic_t
id|refcnt
suffix:semicolon
multiline_comment|/* Reference count&t;&t;&t;*/
DECL|member|family
r_int
r_int
id|family
suffix:semicolon
multiline_comment|/* Address family */
multiline_comment|/* End of struct sock/struct tcp_tw_bucket shared layout */
DECL|member|use_write_queue
r_int
r_char
id|use_write_queue
suffix:semicolon
DECL|member|userlocks
r_int
r_char
id|userlocks
suffix:semicolon
DECL|member|lock
id|socket_lock_t
id|lock
suffix:semicolon
multiline_comment|/* Synchronizer...&t;&t;&t;*/
DECL|member|rcvbuf
r_int
id|rcvbuf
suffix:semicolon
multiline_comment|/* Size of receive buffer in bytes&t;*/
DECL|member|sleep
id|wait_queue_head_t
op_star
id|sleep
suffix:semicolon
multiline_comment|/* Sock wait queue&t;&t;&t;*/
DECL|member|dst_cache
r_struct
id|dst_entry
op_star
id|dst_cache
suffix:semicolon
multiline_comment|/* Destination cache&t;&t;&t;*/
DECL|member|dst_lock
id|rwlock_t
id|dst_lock
suffix:semicolon
DECL|member|rmem_alloc
id|atomic_t
id|rmem_alloc
suffix:semicolon
multiline_comment|/* Receive queue bytes committed&t;*/
DECL|member|receive_queue
r_struct
id|sk_buff_head
id|receive_queue
suffix:semicolon
multiline_comment|/* Incoming packets&t;&t;&t;*/
DECL|member|wmem_alloc
id|atomic_t
id|wmem_alloc
suffix:semicolon
multiline_comment|/* Transmit queue bytes committed&t;*/
DECL|member|write_queue
r_struct
id|sk_buff_head
id|write_queue
suffix:semicolon
multiline_comment|/* Packet sending queue&t;&t;&t;*/
DECL|member|omem_alloc
id|atomic_t
id|omem_alloc
suffix:semicolon
multiline_comment|/* &quot;o&quot; is &quot;option&quot; or &quot;other&quot; */
DECL|member|wmem_queued
r_int
id|wmem_queued
suffix:semicolon
multiline_comment|/* Persistent queue size */
DECL|member|forward_alloc
r_int
id|forward_alloc
suffix:semicolon
multiline_comment|/* Space allocated forward. */
DECL|member|allocation
r_int
r_int
id|allocation
suffix:semicolon
multiline_comment|/* Allocation mode&t;&t;&t;*/
DECL|member|sndbuf
r_int
id|sndbuf
suffix:semicolon
multiline_comment|/* Size of send buffer in bytes&t;&t;*/
DECL|member|prev
r_struct
id|sock
op_star
id|prev
suffix:semicolon
multiline_comment|/* Not all are volatile, but some are, so we might as well say they all are.&n;&t; * XXX Make this a flag word -DaveM&n;&t; */
DECL|member|dead
r_volatile
r_char
id|dead
comma
DECL|member|done
id|done
comma
DECL|member|urginline
id|urginline
comma
DECL|member|keepopen
id|keepopen
comma
DECL|member|linger
id|linger
comma
DECL|member|destroy
id|destroy
comma
DECL|member|no_check
id|no_check
comma
DECL|member|broadcast
id|broadcast
comma
DECL|member|bsdism
id|bsdism
suffix:semicolon
DECL|member|debug
r_int
r_char
id|debug
suffix:semicolon
DECL|member|rcvtstamp
r_int
r_char
id|rcvtstamp
suffix:semicolon
DECL|member|no_largesend
r_int
r_char
id|no_largesend
suffix:semicolon
DECL|member|route_caps
r_int
id|route_caps
suffix:semicolon
DECL|member|lingertime
r_int
r_int
id|lingertime
suffix:semicolon
DECL|member|hashent
r_int
id|hashent
suffix:semicolon
DECL|member|pair
r_struct
id|sock
op_star
id|pair
suffix:semicolon
multiline_comment|/* The backlog queue is special, it is always used with&n;&t; * the per-socket spinlock held and requires low latency&n;&t; * access.  Therefore we special case it&squot;s implementation.&n;&t; */
r_struct
(brace
DECL|member|head
r_struct
id|sk_buff
op_star
id|head
suffix:semicolon
DECL|member|tail
r_struct
id|sk_buff
op_star
id|tail
suffix:semicolon
DECL|member|backlog
)brace
id|backlog
suffix:semicolon
DECL|member|callback_lock
id|rwlock_t
id|callback_lock
suffix:semicolon
multiline_comment|/* Error queue, rarely used. */
DECL|member|error_queue
r_struct
id|sk_buff_head
id|error_queue
suffix:semicolon
DECL|member|prot
r_struct
id|proto
op_star
id|prot
suffix:semicolon
DECL|member|err
DECL|member|err_soft
r_int
id|err
comma
id|err_soft
suffix:semicolon
multiline_comment|/* Soft holds errors that don&squot;t&n;&t;&t;&t;&t;&t;&t;   cause failure but are the cause&n;&t;&t;&t;&t;&t;&t;   of a persistent failure not just&n;&t;&t;&t;&t;&t;&t;   &squot;timed out&squot; */
DECL|member|ack_backlog
r_int
r_int
id|ack_backlog
suffix:semicolon
DECL|member|max_ack_backlog
r_int
r_int
id|max_ack_backlog
suffix:semicolon
DECL|member|priority
id|__u32
id|priority
suffix:semicolon
DECL|member|type
r_int
r_int
id|type
suffix:semicolon
DECL|member|localroute
r_int
r_char
id|localroute
suffix:semicolon
multiline_comment|/* Route locally only */
DECL|member|protocol
r_int
r_char
id|protocol
suffix:semicolon
DECL|member|peercred
r_struct
id|ucred
id|peercred
suffix:semicolon
DECL|member|rcvlowat
r_int
id|rcvlowat
suffix:semicolon
DECL|member|rcvtimeo
r_int
id|rcvtimeo
suffix:semicolon
DECL|member|sndtimeo
r_int
id|sndtimeo
suffix:semicolon
macro_line|#ifdef CONFIG_FILTER
multiline_comment|/* Socket Filtering Instructions */
DECL|member|filter
r_struct
id|sk_filter
op_star
id|filter
suffix:semicolon
macro_line|#endif /* CONFIG_FILTER */
multiline_comment|/* This is where all the private (optional) areas that don&squot;t&n;&t; * overlap will eventually live. &n;&t; */
DECL|member|protinfo
r_void
op_star
id|protinfo
suffix:semicolon
multiline_comment|/* The slabcache this instance was allocated from, it is sk_cachep for most&n;&t; * protocols, but a private slab for protocols such as IPv4, IPv6, SPX&n;&t; * and Unix.&n;&t; */
DECL|member|slab
id|kmem_cache_t
op_star
id|slab
suffix:semicolon
multiline_comment|/* This part is used for the timeout functions. */
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
multiline_comment|/* This is the sock cleanup timer. */
DECL|member|stamp
r_struct
id|timeval
id|stamp
suffix:semicolon
multiline_comment|/* Identd and reporting IO signals */
DECL|member|socket
r_struct
id|socket
op_star
id|socket
suffix:semicolon
multiline_comment|/* RPC layer private data */
DECL|member|user_data
r_void
op_star
id|user_data
suffix:semicolon
multiline_comment|/* Callbacks */
DECL|member|state_change
r_void
(paren
op_star
id|state_change
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|data_ready
r_void
(paren
op_star
id|data_ready
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|bytes
)paren
suffix:semicolon
DECL|member|write_space
r_void
(paren
op_star
id|write_space
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|error_report
r_void
(paren
op_star
id|error_report
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|backlog_rcv
r_int
(paren
op_star
id|backlog_rcv
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
DECL|member|destruct
r_void
(paren
op_star
id|destruct
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* The per-socket spinlock must be held here. */
DECL|macro|sk_add_backlog
mdefine_line|#define sk_add_backlog(__sk, __skb)&t;&t;&t;&bslash;&n;do {&t;if((__sk)-&gt;backlog.tail == NULL) {&t;&t;&bslash;&n;&t;&t;(__sk)-&gt;backlog.head =&t;&t;&t;&bslash;&n;&t;&t;     (__sk)-&gt;backlog.tail = (__skb);&t;&bslash;&n;&t;} else {&t;&t;&t;&t;&t;&bslash;&n;&t;&t;((__sk)-&gt;backlog.tail)-&gt;next = (__skb);&t;&bslash;&n;&t;&t;(__sk)-&gt;backlog.tail = (__skb);&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&bslash;&n;&t;(__skb)-&gt;next = NULL;&t;&t;&t;&t;&bslash;&n;} while(0)
multiline_comment|/* IP protocol blocks we attach to sockets.&n; * socket layer -&gt; transport layer interface&n; * transport -&gt; network interface is defined by struct inet_proto&n; */
DECL|struct|proto
r_struct
id|proto
(brace
DECL|member|close
r_void
(paren
op_star
id|close
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|timeout
)paren
suffix:semicolon
DECL|member|connect
r_int
(paren
op_star
id|connect
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
id|addr_len
)paren
suffix:semicolon
DECL|member|disconnect
r_int
(paren
op_star
id|disconnect
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
)paren
suffix:semicolon
DECL|member|accept
r_struct
id|sock
op_star
(paren
op_star
id|accept
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
comma
r_int
op_star
id|err
)paren
suffix:semicolon
DECL|member|ioctl
r_int
(paren
op_star
id|ioctl
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
DECL|member|init
r_int
(paren
op_star
id|init
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|destroy
r_int
(paren
op_star
id|destroy
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|shutdown
r_void
(paren
op_star
id|shutdown
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|how
)paren
suffix:semicolon
DECL|member|setsockopt
r_int
(paren
op_star
id|setsockopt
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
suffix:semicolon
DECL|member|getsockopt
r_int
(paren
op_star
id|getsockopt
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|option
)paren
suffix:semicolon
DECL|member|sendmsg
r_int
(paren
op_star
id|sendmsg
)paren
(paren
r_struct
id|kiocb
op_star
id|iocb
comma
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|len
)paren
suffix:semicolon
DECL|member|recvmsg
r_int
(paren
op_star
id|recvmsg
)paren
(paren
r_struct
id|kiocb
op_star
id|iocb
comma
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|len
comma
r_int
id|noblock
comma
r_int
id|flags
comma
r_int
op_star
id|addr_len
)paren
suffix:semicolon
DECL|member|bind
r_int
(paren
op_star
id|bind
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
id|addr_len
)paren
suffix:semicolon
DECL|member|backlog_rcv
r_int
(paren
op_star
id|backlog_rcv
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
multiline_comment|/* Keeping track of sk&squot;s, looking them up, and port selection methods. */
DECL|member|hash
r_void
(paren
op_star
id|hash
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|unhash
r_void
(paren
op_star
id|unhash
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|get_port
r_int
(paren
op_star
id|get_port
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|snum
)paren
suffix:semicolon
DECL|member|name
r_char
id|name
(braket
l_int|32
)braket
suffix:semicolon
r_struct
(brace
DECL|member|inuse
r_int
id|inuse
suffix:semicolon
DECL|member|__pad
id|u8
id|__pad
(braket
id|SMP_CACHE_BYTES
op_minus
r_sizeof
(paren
r_int
)paren
)braket
suffix:semicolon
DECL|member|stats
)brace
id|stats
(braket
id|NR_CPUS
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Called with local bh disabled */
DECL|function|sock_prot_inc_use
r_static
id|__inline__
r_void
id|sock_prot_inc_use
c_func
(paren
r_struct
id|proto
op_star
id|prot
)paren
(brace
id|prot-&gt;stats
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
dot
id|inuse
op_increment
suffix:semicolon
)brace
DECL|function|sock_prot_dec_use
r_static
id|__inline__
r_void
id|sock_prot_dec_use
c_func
(paren
r_struct
id|proto
op_star
id|prot
)paren
(brace
id|prot-&gt;stats
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
dot
id|inuse
op_decrement
suffix:semicolon
)brace
multiline_comment|/* About 10 seconds */
DECL|macro|SOCK_DESTROY_TIME
mdefine_line|#define SOCK_DESTROY_TIME (10*HZ)
multiline_comment|/* Sockets 0-1023 can&squot;t be bound to unless you are superuser */
DECL|macro|PROT_SOCK
mdefine_line|#define PROT_SOCK&t;1024
DECL|macro|SHUTDOWN_MASK
mdefine_line|#define SHUTDOWN_MASK&t;3
DECL|macro|RCV_SHUTDOWN
mdefine_line|#define RCV_SHUTDOWN&t;1
DECL|macro|SEND_SHUTDOWN
mdefine_line|#define SEND_SHUTDOWN&t;2
DECL|macro|SOCK_SNDBUF_LOCK
mdefine_line|#define SOCK_SNDBUF_LOCK&t;1
DECL|macro|SOCK_RCVBUF_LOCK
mdefine_line|#define SOCK_RCVBUF_LOCK&t;2
DECL|macro|SOCK_BINDADDR_LOCK
mdefine_line|#define SOCK_BINDADDR_LOCK&t;4
DECL|macro|SOCK_BINDPORT_LOCK
mdefine_line|#define SOCK_BINDPORT_LOCK&t;8
multiline_comment|/* sock_iocb: used to kick off async processing of socket ios */
DECL|struct|sock_iocb
r_struct
id|sock_iocb
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|flags
r_int
id|flags
suffix:semicolon
DECL|member|size
r_int
id|size
suffix:semicolon
DECL|member|sock
r_struct
id|socket
op_star
id|sock
suffix:semicolon
DECL|member|sk
r_struct
id|sock
op_star
id|sk
suffix:semicolon
DECL|member|msg
DECL|member|async_msg
r_struct
id|msghdr
op_star
id|msg
comma
id|async_msg
suffix:semicolon
DECL|member|async_iov
r_struct
id|iovec
id|async_iov
suffix:semicolon
DECL|member|scm
DECL|member|async_scm
r_struct
id|scm_cookie
op_star
id|scm
comma
id|async_scm
suffix:semicolon
)brace
suffix:semicolon
DECL|function|kiocb_to_siocb
r_static
r_inline
r_struct
id|sock_iocb
op_star
id|kiocb_to_siocb
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
)paren
(brace
id|BUG_ON
c_func
(paren
r_sizeof
(paren
r_struct
id|sock_iocb
)paren
OG
id|KIOCB_PRIVATE_SIZE
)paren
suffix:semicolon
r_return
(paren
r_struct
id|sock_iocb
op_star
)paren
id|iocb
op_member_access_from_pointer
r_private
suffix:semicolon
)brace
DECL|function|siocb_to_kiocb
r_static
r_inline
r_struct
id|kiocb
op_star
id|siocb_to_kiocb
c_func
(paren
r_struct
id|sock_iocb
op_star
id|si
)paren
(brace
r_return
id|container_of
c_func
(paren
(paren
r_void
op_star
)paren
id|si
comma
r_struct
id|kiocb
comma
r_private
)paren
suffix:semicolon
)brace
multiline_comment|/* Used by processes to &quot;lock&quot; a socket state, so that&n; * interrupts and bottom half handlers won&squot;t change it&n; * from under us. It essentially blocks any incoming&n; * packets, so that we won&squot;t get any new data or any&n; * packets that change the state of the socket.&n; *&n; * While locked, BH processing will add new packets to&n; * the backlog queue.  This queue is processed by the&n; * owner of the socket lock right before it is released.&n; *&n; * Since ~2.3.5 it is also exclusive sleep lock serializing&n; * accesses from user process context.&n; */
r_extern
r_void
id|__lock_sock
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_void
id|__release_sock
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|macro|sock_owned_by_user
mdefine_line|#define sock_owned_by_user(sk)&t;(NULL != (sk)-&gt;lock.owner)
DECL|macro|lock_sock
mdefine_line|#define lock_sock(__sk) &bslash;&n;do {&t;might_sleep(); &bslash;&n;&t;spin_lock_bh(&amp;((__sk)-&gt;lock.slock)); &bslash;&n;&t;if ((__sk)-&gt;lock.owner != NULL) &bslash;&n;&t;&t;__lock_sock(__sk); &bslash;&n;&t;(__sk)-&gt;lock.owner = (void *)1; &bslash;&n;&t;spin_unlock_bh(&amp;((__sk)-&gt;lock.slock)); &bslash;&n;} while(0)
DECL|macro|release_sock
mdefine_line|#define release_sock(__sk) &bslash;&n;do {&t;spin_lock_bh(&amp;((__sk)-&gt;lock.slock)); &bslash;&n;&t;if ((__sk)-&gt;backlog.tail != NULL) &bslash;&n;&t;&t;__release_sock(__sk); &bslash;&n;&t;(__sk)-&gt;lock.owner = NULL; &bslash;&n;        if (waitqueue_active(&amp;((__sk)-&gt;lock.wq))) wake_up(&amp;((__sk)-&gt;lock.wq)); &bslash;&n;&t;spin_unlock_bh(&amp;((__sk)-&gt;lock.slock)); &bslash;&n;} while(0)
multiline_comment|/* BH context may only use the following locking interface. */
DECL|macro|bh_lock_sock
mdefine_line|#define bh_lock_sock(__sk)&t;spin_lock(&amp;((__sk)-&gt;lock.slock))
DECL|macro|bh_unlock_sock
mdefine_line|#define bh_unlock_sock(__sk)&t;spin_unlock(&amp;((__sk)-&gt;lock.slock))
r_extern
r_struct
id|sock
op_star
id|sk_alloc
c_func
(paren
r_int
id|family
comma
r_int
id|priority
comma
r_int
id|zero_it
comma
id|kmem_cache_t
op_star
id|slab
)paren
suffix:semicolon
r_extern
r_void
id|sk_free
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|sock_wmalloc
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|size
comma
r_int
id|force
comma
r_int
id|priority
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|sock_rmalloc
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|size
comma
r_int
id|force
comma
r_int
id|priority
)paren
suffix:semicolon
r_extern
r_void
id|sock_wfree
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_extern
r_void
id|sock_rfree
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_extern
r_int
id|sock_setsockopt
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|level
comma
r_int
id|op
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
suffix:semicolon
r_extern
r_int
id|sock_getsockopt
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|level
comma
r_int
id|op
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|sock_alloc_send_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|size
comma
r_int
id|noblock
comma
r_int
op_star
id|errcode
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|sock_alloc_send_pskb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|header_len
comma
r_int
r_int
id|data_len
comma
r_int
id|noblock
comma
r_int
op_star
id|errcode
)paren
suffix:semicolon
r_extern
r_void
op_star
id|sock_kmalloc
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|size
comma
r_int
id|priority
)paren
suffix:semicolon
r_extern
r_void
id|sock_kfree_s
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_void
op_star
id|mem
comma
r_int
id|size
)paren
suffix:semicolon
r_extern
r_void
id|sk_send_sigurg
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n; * Functions to fill in entries in struct proto_ops when a protocol&n; * does not implement a particular function.&n; */
r_extern
r_int
id|sock_no_release
c_func
(paren
r_struct
id|socket
op_star
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_bind
c_func
(paren
r_struct
id|socket
op_star
comma
r_struct
id|sockaddr
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_connect
c_func
(paren
r_struct
id|socket
op_star
comma
r_struct
id|sockaddr
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_socketpair
c_func
(paren
r_struct
id|socket
op_star
comma
r_struct
id|socket
op_star
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_accept
c_func
(paren
r_struct
id|socket
op_star
comma
r_struct
id|socket
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_getname
c_func
(paren
r_struct
id|socket
op_star
comma
r_struct
id|sockaddr
op_star
comma
r_int
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
r_int
id|sock_no_poll
c_func
(paren
r_struct
id|file
op_star
comma
r_struct
id|socket
op_star
comma
r_struct
id|poll_table_struct
op_star
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_ioctl
c_func
(paren
r_struct
id|socket
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_listen
c_func
(paren
r_struct
id|socket
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_shutdown
c_func
(paren
r_struct
id|socket
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_getsockopt
c_func
(paren
r_struct
id|socket
op_star
comma
r_int
comma
r_int
comma
r_char
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_setsockopt
c_func
(paren
r_struct
id|socket
op_star
comma
r_int
comma
r_int
comma
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_sendmsg
c_func
(paren
r_struct
id|kiocb
op_star
comma
r_struct
id|socket
op_star
comma
r_struct
id|msghdr
op_star
comma
r_int
comma
r_struct
id|scm_cookie
op_star
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_recvmsg
c_func
(paren
r_struct
id|kiocb
op_star
comma
r_struct
id|socket
op_star
comma
r_struct
id|msghdr
op_star
comma
r_int
comma
r_int
comma
r_struct
id|scm_cookie
op_star
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
suffix:semicolon
r_extern
id|ssize_t
id|sock_no_sendpage
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|offset
comma
r_int
id|size
comma
r_int
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Default socket callbacks and setup code&n; */
r_extern
r_void
id|sock_def_destruct
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
multiline_comment|/* Initialise core socket variables */
r_extern
r_void
id|sock_init_data
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_void
id|sklist_remove_socket
c_func
(paren
r_struct
id|sock
op_star
op_star
id|list
comma
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_void
id|sklist_insert_socket
c_func
(paren
r_struct
id|sock
op_star
op_star
id|list
comma
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_void
id|sklist_destroy_socket
c_func
(paren
r_struct
id|sock
op_star
op_star
id|list
comma
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_FILTER
multiline_comment|/**&n; *&t;sk_filter - run a packet through a socket filter&n; *&t;@skb: buffer to filter&n; *&t;@filter: filter to apply&n; *&n; * Run the filter code and then cut skb-&gt;data to correct size returned by&n; * sk_run_filter. If pkt_len is 0 we toss packet. If skb-&gt;len is smaller&n; * than pkt_len we keep whole skb-&gt;data. This is the socket level&n; * wrapper to sk_run_filter. It returns 0 if the packet should&n; * be accepted or 1 if the packet should be tossed.&n; */
DECL|function|sk_filter
r_static
r_inline
r_int
id|sk_filter
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sk_filter
op_star
id|filter
)paren
(brace
r_int
id|pkt_len
suffix:semicolon
id|pkt_len
op_assign
id|sk_run_filter
c_func
(paren
id|skb
comma
id|filter-&gt;insns
comma
id|filter-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pkt_len
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Toss Packet */
r_else
id|skb_trim
c_func
(paren
id|skb
comma
id|pkt_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;sk_filter_release: Release a socket filter&n; *&t;@sk: socket&n; *&t;@fp: filter to remove&n; *&n; *&t;Remove a filter from a socket and release its resources.&n; */
DECL|function|sk_filter_release
r_static
r_inline
r_void
id|sk_filter_release
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_filter
op_star
id|fp
)paren
(brace
r_int
r_int
id|size
op_assign
id|sk_filter_len
c_func
(paren
id|fp
)paren
suffix:semicolon
id|atomic_sub
c_func
(paren
id|size
comma
op_amp
id|sk-&gt;omem_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|fp-&gt;refcnt
)paren
)paren
id|kfree
c_func
(paren
id|fp
)paren
suffix:semicolon
)brace
DECL|function|sk_filter_charge
r_static
r_inline
r_void
id|sk_filter_charge
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_filter
op_star
id|fp
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|fp-&gt;refcnt
)paren
suffix:semicolon
id|atomic_add
c_func
(paren
id|sk_filter_len
c_func
(paren
id|fp
)paren
comma
op_amp
id|sk-&gt;omem_alloc
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_FILTER */
multiline_comment|/*&n; * Socket reference counting postulates.&n; *&n; * * Each user of socket SHOULD hold a reference count.&n; * * Each access point to socket (an hash table bucket, reference from a list,&n; *   running timer, skb in flight MUST hold a reference count.&n; * * When reference count hits 0, it means it will never increase back.&n; * * When reference count hits 0, it means that no references from&n; *   outside exist to this socket and current process on current CPU&n; *   is last user and may/should destroy this socket.&n; * * sk_free is called from any context: process, BH, IRQ. When&n; *   it is called, socket has no references from outside -&gt; sk_free&n; *   may release descendant resources allocated by the socket, but&n; *   to the time when it is called, socket is NOT referenced by any&n; *   hash tables, lists etc.&n; * * Packets, delivered from outside (from network or from another process)&n; *   and enqueued on receive/error queues SHOULD NOT grab reference count,&n; *   when they sit in queue. Otherwise, packets will leak to hole, when&n; *   socket is looked up by one cpu and unhasing is made by another CPU.&n; *   It is true for udp/raw, netlink (leak to receive and error queues), tcp&n; *   (leak to backlog). Packet socket does all the processing inside&n; *   BR_NETPROTO_LOCK, so that it has not this race condition. UNIX sockets&n; *   use separate SMP lock, so that they are prone too.&n; */
multiline_comment|/* Grab socket reference count. This operation is valid only&n;   when sk is ALREADY grabbed f.e. it is found in hash table&n;   or a list and the lookup is made under lock preventing hash table&n;   modifications.&n; */
DECL|function|sock_hold
r_static
r_inline
r_void
id|sock_hold
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|sk-&gt;refcnt
)paren
suffix:semicolon
)brace
multiline_comment|/* Ungrab socket in the context, which assumes that socket refcnt&n;   cannot hit zero, f.e. it is true in context of any socketcall.&n; */
DECL|function|__sock_put
r_static
r_inline
r_void
id|__sock_put
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|sk-&gt;refcnt
)paren
suffix:semicolon
)brace
multiline_comment|/* Ungrab socket and destroy it, if it was the last reference. */
DECL|function|sock_put
r_static
r_inline
r_void
id|sock_put
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|sk-&gt;refcnt
)paren
)paren
id|sk_free
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/* Detach socket from process context.&n; * Announce socket dead, detach it from wait queue and inode.&n; * Note that parent inode held reference count on this struct sock,&n; * we do not release it in this function, because protocol&n; * probably wants some additional cleanups or even continuing&n; * to work with this socket (TCP).&n; */
DECL|function|sock_orphan
r_static
r_inline
r_void
id|sock_orphan
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
id|sk-&gt;dead
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;socket
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;sleep
op_assign
l_int|NULL
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
)brace
DECL|function|sock_graft
r_static
r_inline
r_void
id|sock_graft
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|socket
op_star
id|parent
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
id|sk-&gt;sleep
op_assign
op_amp
id|parent-&gt;wait
suffix:semicolon
id|parent-&gt;sk
op_assign
id|sk
suffix:semicolon
id|sk-&gt;socket
op_assign
id|parent
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
)brace
DECL|function|sock_i_uid
r_static
r_inline
r_int
id|sock_i_uid
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|uid
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
id|uid
op_assign
id|sk-&gt;socket
ques
c_cond
id|SOCK_INODE
c_func
(paren
id|sk-&gt;socket
)paren
op_member_access_from_pointer
id|i_uid
suffix:colon
l_int|0
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
r_return
id|uid
suffix:semicolon
)brace
DECL|function|sock_i_ino
r_static
r_inline
r_int
r_int
id|sock_i_ino
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
r_int
id|ino
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
id|ino
op_assign
id|sk-&gt;socket
ques
c_cond
id|SOCK_INODE
c_func
(paren
id|sk-&gt;socket
)paren
op_member_access_from_pointer
id|i_ino
suffix:colon
l_int|0
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
r_return
id|ino
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|dst_entry
op_star
DECL|function|__sk_dst_get
id|__sk_dst_get
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|sk-&gt;dst_cache
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|dst_entry
op_star
DECL|function|sk_dst_get
id|sk_dst_get
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|dst_entry
op_star
id|dst
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|sk-&gt;dst_lock
)paren
suffix:semicolon
id|dst
op_assign
id|sk-&gt;dst_cache
suffix:semicolon
r_if
c_cond
(paren
id|dst
)paren
id|dst_hold
c_func
(paren
id|dst
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|sk-&gt;dst_lock
)paren
suffix:semicolon
r_return
id|dst
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|__sk_dst_set
id|__sk_dst_set
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|dst_entry
op_star
id|dst
)paren
(brace
r_struct
id|dst_entry
op_star
id|old_dst
suffix:semicolon
id|old_dst
op_assign
id|sk-&gt;dst_cache
suffix:semicolon
id|sk-&gt;dst_cache
op_assign
id|dst
suffix:semicolon
id|dst_release
c_func
(paren
id|old_dst
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|sk_dst_set
id|sk_dst_set
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|dst_entry
op_star
id|dst
)paren
(brace
id|write_lock
c_func
(paren
op_amp
id|sk-&gt;dst_lock
)paren
suffix:semicolon
id|__sk_dst_set
c_func
(paren
id|sk
comma
id|dst
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|sk-&gt;dst_lock
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|__sk_dst_reset
id|__sk_dst_reset
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|dst_entry
op_star
id|old_dst
suffix:semicolon
id|old_dst
op_assign
id|sk-&gt;dst_cache
suffix:semicolon
id|sk-&gt;dst_cache
op_assign
l_int|NULL
suffix:semicolon
id|dst_release
c_func
(paren
id|old_dst
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|sk_dst_reset
id|sk_dst_reset
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|write_lock
c_func
(paren
op_amp
id|sk-&gt;dst_lock
)paren
suffix:semicolon
id|__sk_dst_reset
c_func
(paren
id|sk
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|sk-&gt;dst_lock
)paren
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|dst_entry
op_star
DECL|function|__sk_dst_check
id|__sk_dst_check
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|cookie
)paren
(brace
r_struct
id|dst_entry
op_star
id|dst
op_assign
id|sk-&gt;dst_cache
suffix:semicolon
r_if
c_cond
(paren
id|dst
op_logical_and
id|dst-&gt;obsolete
op_logical_and
id|dst-&gt;ops
op_member_access_from_pointer
id|check
c_func
(paren
id|dst
comma
id|cookie
)paren
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;dst_cache
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|dst
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|dst_entry
op_star
DECL|function|sk_dst_check
id|sk_dst_check
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|cookie
)paren
(brace
r_struct
id|dst_entry
op_star
id|dst
op_assign
id|sk_dst_get
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dst
op_logical_and
id|dst-&gt;obsolete
op_logical_and
id|dst-&gt;ops
op_member_access_from_pointer
id|check
c_func
(paren
id|dst
comma
id|cookie
)paren
op_eq
l_int|NULL
)paren
(brace
id|sk_dst_reset
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|dst
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Queue a received datagram if it will fit. Stream and sequenced&n; *&t;protocols can&squot;t normally use this as they need to fit buffers in&n; *&t;and play with them.&n; *&n; * &t;Inlined as it&squot;s very short and called for pretty much every&n; *&t;packet ever received.&n; */
DECL|function|skb_set_owner_w
r_static
r_inline
r_void
id|skb_set_owner_w
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|skb-&gt;destructor
op_assign
id|sock_wfree
suffix:semicolon
id|atomic_add
c_func
(paren
id|skb-&gt;truesize
comma
op_amp
id|sk-&gt;wmem_alloc
)paren
suffix:semicolon
)brace
DECL|function|skb_set_owner_r
r_static
r_inline
r_void
id|skb_set_owner_r
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|skb-&gt;destructor
op_assign
id|sock_rfree
suffix:semicolon
id|atomic_add
c_func
(paren
id|skb-&gt;truesize
comma
op_amp
id|sk-&gt;rmem_alloc
)paren
suffix:semicolon
)brace
DECL|function|sock_queue_rcv_skb
r_static
r_inline
r_int
id|sock_queue_rcv_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
multiline_comment|/* Cast skb-&gt;rcvbuf to unsigned... It&squot;s pointless, but reduces&n;&t;   number of warnings when compiling with -W --ANK&n;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
op_plus
id|skb-&gt;truesize
op_ge
(paren
r_int
)paren
id|sk-&gt;rcvbuf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
macro_line|#ifdef CONFIG_FILTER
r_if
c_cond
(paren
id|sk-&gt;filter
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|sk_filter
op_star
id|filter
suffix:semicolon
multiline_comment|/* It would be deadlock, if sock_queue_rcv_skb is used&n;&t;&t;   with socket lock! We assume that users of this&n;&t;&t;   function are lock free.&n;&t;&t; */
id|bh_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|filter
op_assign
id|sk-&gt;filter
)paren
op_ne
l_int|NULL
op_logical_and
id|sk_filter
c_func
(paren
id|skb
comma
id|filter
)paren
)paren
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
id|bh_unlock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/* Toss packet */
)brace
macro_line|#endif /* CONFIG_FILTER */
id|skb-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
id|skb_set_owner_r
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|sk
comma
id|skb-&gt;len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sock_queue_err_skb
r_static
r_inline
r_int
id|sock_queue_err_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
multiline_comment|/* Cast skb-&gt;rcvbuf to unsigned... It&squot;s pointless, but reduces&n;&t;   number of warnings when compiling with -W --ANK&n;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
op_plus
id|skb-&gt;truesize
op_ge
(paren
r_int
)paren
id|sk-&gt;rcvbuf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|skb_set_owner_r
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;error_queue
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|sk
comma
id|skb-&gt;len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Recover an error report and clear atomically&n; */
DECL|function|sock_error
r_static
r_inline
r_int
id|sock_error
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|err
op_assign
id|xchg
c_func
(paren
op_amp
id|sk-&gt;err
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|err
suffix:semicolon
)brace
DECL|function|sock_wspace
r_static
r_inline
r_int
r_int
id|sock_wspace
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|amt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
)paren
(brace
id|amt
op_assign
id|sk-&gt;sndbuf
op_minus
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|amt
OL
l_int|0
)paren
id|amt
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|amt
suffix:semicolon
)brace
DECL|function|sk_wake_async
r_static
r_inline
r_void
id|sk_wake_async
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|how
comma
r_int
id|band
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;socket
op_logical_and
id|sk-&gt;socket-&gt;fasync_list
)paren
id|sock_wake_async
c_func
(paren
id|sk-&gt;socket
comma
id|how
comma
id|band
)paren
suffix:semicolon
)brace
DECL|macro|SOCK_MIN_SNDBUF
mdefine_line|#define SOCK_MIN_SNDBUF 2048
DECL|macro|SOCK_MIN_RCVBUF
mdefine_line|#define SOCK_MIN_RCVBUF 256
multiline_comment|/*&n; *&t;Default write policy as shown to user space via poll/select/SIGIO&n; */
DECL|function|sock_writeable
r_static
r_inline
r_int
id|sock_writeable
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
OL
(paren
id|sk-&gt;sndbuf
op_div
l_int|2
)paren
suffix:semicolon
)brace
DECL|function|gfp_any
r_static
r_inline
r_int
id|gfp_any
c_func
(paren
r_void
)paren
(brace
r_return
id|in_softirq
c_func
(paren
)paren
ques
c_cond
id|GFP_ATOMIC
suffix:colon
id|GFP_KERNEL
suffix:semicolon
)brace
DECL|function|sock_rcvtimeo
r_static
r_inline
r_int
id|sock_rcvtimeo
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|noblock
)paren
(brace
r_return
id|noblock
ques
c_cond
l_int|0
suffix:colon
id|sk-&gt;rcvtimeo
suffix:semicolon
)brace
DECL|function|sock_sndtimeo
r_static
r_inline
r_int
id|sock_sndtimeo
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|noblock
)paren
(brace
r_return
id|noblock
ques
c_cond
l_int|0
suffix:colon
id|sk-&gt;sndtimeo
suffix:semicolon
)brace
DECL|function|sock_rcvlowat
r_static
r_inline
r_int
id|sock_rcvlowat
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|waitall
comma
r_int
id|len
)paren
(brace
r_return
(paren
id|waitall
ques
c_cond
id|len
suffix:colon
id|min_t
c_func
(paren
r_int
comma
id|sk-&gt;rcvlowat
comma
id|len
)paren
)paren
ques
c_cond
suffix:colon
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Alas, with timeout socket operations are not restartable.&n; * Compare this to poll().&n; */
DECL|function|sock_intr_errno
r_static
r_inline
r_int
id|sock_intr_errno
c_func
(paren
r_int
id|timeo
)paren
(brace
r_return
id|timeo
op_eq
id|MAX_SCHEDULE_TIMEOUT
ques
c_cond
op_minus
id|ERESTARTSYS
suffix:colon
op_minus
id|EINTR
suffix:semicolon
)brace
r_static
id|__inline__
r_void
DECL|function|sock_recv_timestamp
id|sock_recv_timestamp
c_func
(paren
r_struct
id|msghdr
op_star
id|msg
comma
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;rcvtstamp
)paren
id|put_cmsg
c_func
(paren
id|msg
comma
id|SOL_SOCKET
comma
id|SO_TIMESTAMP
comma
r_sizeof
(paren
id|skb-&gt;stamp
)paren
comma
op_amp
id|skb-&gt;stamp
)paren
suffix:semicolon
r_else
id|sk-&gt;stamp
op_assign
id|skb-&gt;stamp
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Enable debug/info messages &n; */
macro_line|#if 0
mdefine_line|#define NETDEBUG(x)&t;do { } while (0)
macro_line|#else
DECL|macro|NETDEBUG
mdefine_line|#define NETDEBUG(x)&t;do { x; } while (0)
macro_line|#endif
multiline_comment|/*&n; * Macros for sleeping on a socket. Use them like this:&n; *&n; * SOCK_SLEEP_PRE(sk)&n; * if (condition)&n; * &t;schedule();&n; * SOCK_SLEEP_POST(sk)&n; *&n; */
DECL|macro|SOCK_SLEEP_PRE
mdefine_line|#define SOCK_SLEEP_PRE(sk) &t;{ struct task_struct *tsk = current; &bslash;&n;&t;&t;&t;&t;DECLARE_WAITQUEUE(wait, tsk); &bslash;&n;&t;&t;&t;&t;tsk-&gt;state = TASK_INTERRUPTIBLE; &bslash;&n;&t;&t;&t;&t;add_wait_queue((sk)-&gt;sleep, &amp;wait); &bslash;&n;&t;&t;&t;&t;release_sock(sk);
DECL|macro|SOCK_SLEEP_POST
mdefine_line|#define SOCK_SLEEP_POST(sk)&t;tsk-&gt;state = TASK_RUNNING; &bslash;&n;&t;&t;&t;&t;remove_wait_queue((sk)-&gt;sleep, &amp;wait); &bslash;&n;&t;&t;&t;&t;lock_sock(sk); &bslash;&n;&t;&t;&t;&t;}
r_extern
id|__u32
id|sysctl_wmem_max
suffix:semicolon
r_extern
id|__u32
id|sysctl_rmem_max
suffix:semicolon
macro_line|#endif&t;/* _SOCK_H */
eof
