multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Definitions for the AF_INET socket handler.&n; *&n; * Version:&t;@(#)sock.h&t;1.0.4&t;05/13/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;&n; *&t;&t;Florian La Roche &lt;flla@stud.uni-sb.de&gt;&n; *&n; * Fixes:&n; *&t;&t;Alan Cox&t;:&t;Volatiles in skbuff pointers. See&n; *&t;&t;&t;&t;&t;skbuff comments. May be overdone,&n; *&t;&t;&t;&t;&t;better to prove they can be removed&n; *&t;&t;&t;&t;&t;than the reverse.&n; *&t;&t;Alan Cox&t;:&t;Added a zapped field for tcp to note&n; *&t;&t;&t;&t;&t;a socket is reset and must stay shut up&n; *&t;&t;Alan Cox&t;:&t;New fields for options&n; *&t;Pauline Middelink&t;:&t;identd support&n; *&t;&t;Alan Cox&t;:&t;Eliminate low level recv/recvfrom&n; *&t;&t;David S. Miller&t;:&t;New socket lookup architecture.&n; *              Steve Whitehouse:       Default routines for sock_ops&n; *              Arnaldo C. Melo :&t;removed net_pinfo, tp_pinfo and made&n; *              &t;&t;&t;protinfo be just a void pointer, as the&n; *              &t;&t;&t;protocol specific parts were moved to&n; *              &t;&t;&t;respective headers and ipv4/v6, etc now&n; *              &t;&t;&t;use private slabcaches for its socks&n; *              Pedro Hortas&t;:&t;New flags field for socket options&n; *&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#ifndef _SOCK_H
DECL|macro|_SOCK_H
mdefine_line|#define _SOCK_H
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/cache.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;&t;/* struct sk_buff */
macro_line|#include &lt;linux/security.h&gt;
macro_line|#include &lt;linux/filter.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;net/dst.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
multiline_comment|/*&n; * This structure really needs to be cleaned up.&n; * Most of it is for TCP, and not used by any of&n; * the other protocols.&n; */
multiline_comment|/* Define this to get the sk-&gt;sk_debug debugging facility. */
DECL|macro|SOCK_DEBUGGING
mdefine_line|#define SOCK_DEBUGGING
macro_line|#ifdef SOCK_DEBUGGING
DECL|macro|SOCK_DEBUG
mdefine_line|#define SOCK_DEBUG(sk, msg...) do { if ((sk) &amp;&amp; ((sk)-&gt;sk_debug)) &bslash;&n;&t;&t;&t;&t;&t;printk(KERN_DEBUG msg); } while (0)
macro_line|#else
DECL|macro|SOCK_DEBUG
mdefine_line|#define SOCK_DEBUG(sk, msg...) do { } while (0)
macro_line|#endif
multiline_comment|/* This is the per-socket lock.  The spinlock provides a synchronization&n; * between user contexts and software interrupt processing, whereas the&n; * mini-semaphore synchronizes multiple users amongst themselves.&n; */
r_struct
id|sock_iocb
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|slock
id|spinlock_t
id|slock
suffix:semicolon
DECL|member|owner
r_struct
id|sock_iocb
op_star
id|owner
suffix:semicolon
DECL|member|wq
id|wait_queue_head_t
id|wq
suffix:semicolon
DECL|typedef|socket_lock_t
)brace
id|socket_lock_t
suffix:semicolon
DECL|macro|sock_lock_init
mdefine_line|#define sock_lock_init(__sk) &bslash;&n;do {&t;spin_lock_init(&amp;((__sk)-&gt;sk_lock.slock)); &bslash;&n;&t;(__sk)-&gt;sk_lock.owner = NULL; &bslash;&n;&t;init_waitqueue_head(&amp;((__sk)-&gt;sk_lock.wq)); &bslash;&n;} while(0)
r_struct
id|sock
suffix:semicolon
multiline_comment|/**&n;  *&t;struct sock_common - minimal network layer representation of sockets&n;  *&t;@skc_family - network address family&n;  *&t;@skc_state - Connection state&n;  *&t;@skc_reuse - %SO_REUSEADDR setting&n;  *&t;@skc_bound_dev_if - bound device index if != 0&n;  *&t;@skc_node - main hash linkage for various protocol lookup tables&n;  *&t;@skc_bind_node - bind hash linkage for various protocol lookup tables&n;  *&t;@skc_refcnt - reference count&n;  *&n;  *&t;This is the minimal network layer representation of sockets, the header&n;  *&t;for struct sock and struct tcp_tw_bucket.&n;  */
DECL|struct|sock_common
r_struct
id|sock_common
(brace
DECL|member|skc_family
r_int
r_int
id|skc_family
suffix:semicolon
DECL|member|skc_state
r_volatile
r_int
r_char
id|skc_state
suffix:semicolon
DECL|member|skc_reuse
r_int
r_char
id|skc_reuse
suffix:semicolon
DECL|member|skc_bound_dev_if
r_int
id|skc_bound_dev_if
suffix:semicolon
DECL|member|skc_node
r_struct
id|hlist_node
id|skc_node
suffix:semicolon
DECL|member|skc_bind_node
r_struct
id|hlist_node
id|skc_bind_node
suffix:semicolon
DECL|member|skc_refcnt
id|atomic_t
id|skc_refcnt
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/**&n;  *&t;struct sock - network layer representation of sockets&n;  *&t;@__sk_common - shared layout with tcp_tw_bucket&n;  *&t;@sk_zapped - ax25 &amp; ipx means !linked&n;  *&t;@sk_shutdown - mask of %SEND_SHUTDOWN and/or %RCV_SHUTDOWN&n;  *&t;@sk_use_write_queue - wheter to call sk-&gt;sk_write_space in sock_wfree&n;  *&t;@sk_userlocks - %SO_SNDBUF and %SO_RCVBUF settings&n;  *&t;@sk_lock -&t;synchronizer&n;  *&t;@sk_rcvbuf - size of receive buffer in bytes&n;  *&t;@sk_sleep - sock wait queue&n;  *&t;@sk_dst_cache - destination cache&n;  *&t;@sk_dst_lock - destination cache lock&n;  *&t;@sk_policy - flow policy&n;  *&t;@sk_rmem_alloc - receive queue bytes committed&n;  *&t;@sk_receive_queue - incoming packets&n;  *&t;@sk_wmem_alloc - transmit queue bytes committed&n;  *&t;@sk_write_queue - Packet sending queue&n;  *&t;@sk_omem_alloc - &quot;o&quot; is &quot;option&quot; or &quot;other&quot;&n;  *&t;@sk_wmem_queued - persistent queue size&n;  *&t;@sk_forward_alloc - space allocated forward&n;  *&t;@sk_allocation - allocation mode&n;  *&t;@sk_sndbuf - size of send buffer in bytes&n;  *&t;@sk_flags - %SO_LINGER (l_onoff), %SO_BROADCAST, %SO_KEEPALIVE, %SO_OOBINLINE settings&n;  *&t;@sk_no_check - %SO_NO_CHECK setting, wether or not checkup packets&n;  *&t;@sk_debug - %SO_DEBUG setting&n;  *&t;@sk_rcvtstamp - %SO_TIMESTAMP setting&n;  *&t;@sk_no_largesend - whether to sent large segments or not&n;  *&t;@sk_route_caps - route capabilities (e.g. %NETIF_F_TSO)&n;  *&t;@sk_lingertime - %SO_LINGER l_linger setting&n;  *&t;@sk_hashent - hash entry in several tables (e.g. tcp_ehash)&n;  *&t;@sk_backlog - always used with the per-socket spinlock held&n;  *&t;@sk_callback_lock - used with the callbacks in the end of this struct&n;  *&t;@sk_error_queue - rarely used&n;  *&t;@sk_prot - protocol handlers inside a network family&n;  *&t;@sk_err - last error&n;  *&t;@sk_err_soft - errors that don&squot;t cause failure but are the cause of a persistent failure not just &squot;timed out&squot;&n;  *&t;@sk_ack_backlog - current listen backlog&n;  *&t;@sk_max_ack_backlog - listen backlog set in listen()&n;  *&t;@sk_priority - %SO_PRIORITY setting&n;  *&t;@sk_type - socket type (%SOCK_STREAM, etc)&n;  *&t;@sk_localroute - route locally only, %SO_DONTROUTE setting&n;  *&t;@sk_protocol - which protocol this socket belongs in this network family&n;  *&t;@sk_peercred - %SO_PEERCRED setting&n;  *&t;@sk_rcvlowat - %SO_RCVLOWAT setting&n;  *&t;@sk_rcvtimeo - %SO_RCVTIMEO setting&n;  *&t;@sk_sndtimeo - %SO_SNDTIMEO setting&n;  *&t;@sk_filter - socket filtering instructions&n;  *&t;@sk_protinfo - private area, net family specific, when not using slab&n;  *&t;@sk_slab - the slabcache this instance was allocated from&n;  *&t;@sk_timer - sock cleanup timer&n;  *&t;@sk_stamp - time stamp of last packet received&n;  *&t;@sk_socket - Identd and reporting IO signals&n;  *&t;@sk_user_data - RPC layer private data&n;  *&t;@sk_owner - module that owns this socket&n;  *&t;@sk_sndmsg_page - cached page for sendmsg&n;  *&t;@sk_sndmsg_off - cached offset for sendmsg&n;  *&t;@sk_send_head - front of stuff to transmit&n;  *&t;@sk_write_pending - a write to stream socket waits to start&n;  *&t;@sk_queue_shrunk - write queue has been shrunk recently&n;  *&t;@sk_state_change - callback to indicate change in the state of the sock&n;  *&t;@sk_data_ready - callback to indicate there is data to be processed&n;  *&t;@sk_write_space - callback to indicate there is bf sending space available&n;  *&t;@sk_error_report - callback to indicate errors (e.g. %MSG_ERRQUEUE)&n;  *&t;@sk_backlog_rcv - callback to process the backlog&n;  *&t;@sk_destruct - called at sock freeing time, i.e. when all refcnt == 0&n; */
DECL|struct|sock
r_struct
id|sock
(brace
multiline_comment|/*&n;&t; * Now struct tcp_tw_bucket also uses sock_common, so please just&n;&t; * don&squot;t add nothing before this first member (__sk_common) --acme&n;&t; */
DECL|member|__sk_common
r_struct
id|sock_common
id|__sk_common
suffix:semicolon
DECL|macro|sk_family
mdefine_line|#define sk_family&t;&t;__sk_common.skc_family
DECL|macro|sk_state
mdefine_line|#define sk_state&t;&t;__sk_common.skc_state
DECL|macro|sk_reuse
mdefine_line|#define sk_reuse&t;&t;__sk_common.skc_reuse
DECL|macro|sk_bound_dev_if
mdefine_line|#define sk_bound_dev_if&t;&t;__sk_common.skc_bound_dev_if
DECL|macro|sk_node
mdefine_line|#define sk_node&t;&t;&t;__sk_common.skc_node
DECL|macro|sk_bind_node
mdefine_line|#define sk_bind_node&t;&t;__sk_common.skc_bind_node
DECL|macro|sk_refcnt
mdefine_line|#define sk_refcnt&t;&t;__sk_common.skc_refcnt
DECL|member|sk_zapped
r_volatile
r_int
r_char
id|sk_zapped
suffix:semicolon
DECL|member|sk_shutdown
r_int
r_char
id|sk_shutdown
suffix:semicolon
DECL|member|sk_use_write_queue
r_int
r_char
id|sk_use_write_queue
suffix:semicolon
DECL|member|sk_userlocks
r_int
r_char
id|sk_userlocks
suffix:semicolon
DECL|member|sk_lock
id|socket_lock_t
id|sk_lock
suffix:semicolon
DECL|member|sk_rcvbuf
r_int
id|sk_rcvbuf
suffix:semicolon
DECL|member|sk_sleep
id|wait_queue_head_t
op_star
id|sk_sleep
suffix:semicolon
DECL|member|sk_dst_cache
r_struct
id|dst_entry
op_star
id|sk_dst_cache
suffix:semicolon
DECL|member|sk_dst_lock
id|rwlock_t
id|sk_dst_lock
suffix:semicolon
DECL|member|sk_policy
r_struct
id|xfrm_policy
op_star
id|sk_policy
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|sk_rmem_alloc
id|atomic_t
id|sk_rmem_alloc
suffix:semicolon
DECL|member|sk_receive_queue
r_struct
id|sk_buff_head
id|sk_receive_queue
suffix:semicolon
DECL|member|sk_wmem_alloc
id|atomic_t
id|sk_wmem_alloc
suffix:semicolon
DECL|member|sk_write_queue
r_struct
id|sk_buff_head
id|sk_write_queue
suffix:semicolon
DECL|member|sk_omem_alloc
id|atomic_t
id|sk_omem_alloc
suffix:semicolon
DECL|member|sk_wmem_queued
r_int
id|sk_wmem_queued
suffix:semicolon
DECL|member|sk_forward_alloc
r_int
id|sk_forward_alloc
suffix:semicolon
DECL|member|sk_allocation
r_int
r_int
id|sk_allocation
suffix:semicolon
DECL|member|sk_sndbuf
r_int
id|sk_sndbuf
suffix:semicolon
DECL|member|sk_flags
r_int
r_int
id|sk_flags
suffix:semicolon
DECL|member|sk_no_check
r_char
id|sk_no_check
suffix:semicolon
DECL|member|sk_debug
r_int
r_char
id|sk_debug
suffix:semicolon
DECL|member|sk_rcvtstamp
r_int
r_char
id|sk_rcvtstamp
suffix:semicolon
DECL|member|sk_no_largesend
r_int
r_char
id|sk_no_largesend
suffix:semicolon
DECL|member|sk_route_caps
r_int
id|sk_route_caps
suffix:semicolon
DECL|member|sk_lingertime
r_int
r_int
id|sk_lingertime
suffix:semicolon
DECL|member|sk_hashent
r_int
id|sk_hashent
suffix:semicolon
multiline_comment|/*&n;&t; * The backlog queue is special, it is always used with&n;&t; * the per-socket spinlock held and requires low latency&n;&t; * access. Therefore we special case it&squot;s implementation.&n;&t; */
r_struct
(brace
DECL|member|head
r_struct
id|sk_buff
op_star
id|head
suffix:semicolon
DECL|member|tail
r_struct
id|sk_buff
op_star
id|tail
suffix:semicolon
DECL|member|sk_backlog
)brace
id|sk_backlog
suffix:semicolon
DECL|member|sk_callback_lock
id|rwlock_t
id|sk_callback_lock
suffix:semicolon
DECL|member|sk_error_queue
r_struct
id|sk_buff_head
id|sk_error_queue
suffix:semicolon
DECL|member|sk_prot
r_struct
id|proto
op_star
id|sk_prot
suffix:semicolon
DECL|member|sk_err
r_int
id|sk_err
comma
DECL|member|sk_err_soft
id|sk_err_soft
suffix:semicolon
DECL|member|sk_ack_backlog
r_int
r_int
id|sk_ack_backlog
suffix:semicolon
DECL|member|sk_max_ack_backlog
r_int
r_int
id|sk_max_ack_backlog
suffix:semicolon
DECL|member|sk_priority
id|__u32
id|sk_priority
suffix:semicolon
DECL|member|sk_type
r_int
r_int
id|sk_type
suffix:semicolon
DECL|member|sk_localroute
r_int
r_char
id|sk_localroute
suffix:semicolon
DECL|member|sk_protocol
r_int
r_char
id|sk_protocol
suffix:semicolon
DECL|member|sk_peercred
r_struct
id|ucred
id|sk_peercred
suffix:semicolon
DECL|member|sk_rcvlowat
r_int
id|sk_rcvlowat
suffix:semicolon
DECL|member|sk_rcvtimeo
r_int
id|sk_rcvtimeo
suffix:semicolon
DECL|member|sk_sndtimeo
r_int
id|sk_sndtimeo
suffix:semicolon
DECL|member|sk_filter
r_struct
id|sk_filter
op_star
id|sk_filter
suffix:semicolon
DECL|member|sk_protinfo
r_void
op_star
id|sk_protinfo
suffix:semicolon
DECL|member|sk_slab
id|kmem_cache_t
op_star
id|sk_slab
suffix:semicolon
DECL|member|sk_timer
r_struct
id|timer_list
id|sk_timer
suffix:semicolon
DECL|member|sk_stamp
r_struct
id|timeval
id|sk_stamp
suffix:semicolon
DECL|member|sk_socket
r_struct
id|socket
op_star
id|sk_socket
suffix:semicolon
DECL|member|sk_user_data
r_void
op_star
id|sk_user_data
suffix:semicolon
DECL|member|sk_owner
r_struct
id|module
op_star
id|sk_owner
suffix:semicolon
DECL|member|sk_sndmsg_page
r_struct
id|page
op_star
id|sk_sndmsg_page
suffix:semicolon
DECL|member|sk_sndmsg_off
id|__u32
id|sk_sndmsg_off
suffix:semicolon
DECL|member|sk_send_head
r_struct
id|sk_buff
op_star
id|sk_send_head
suffix:semicolon
DECL|member|sk_write_pending
r_int
id|sk_write_pending
suffix:semicolon
DECL|member|sk_security
r_void
op_star
id|sk_security
suffix:semicolon
DECL|member|sk_queue_shrunk
id|__u8
id|sk_queue_shrunk
suffix:semicolon
multiline_comment|/* three bytes hole, try to pack */
DECL|member|sk_state_change
r_void
(paren
op_star
id|sk_state_change
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|sk_data_ready
r_void
(paren
op_star
id|sk_data_ready
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|bytes
)paren
suffix:semicolon
DECL|member|sk_write_space
r_void
(paren
op_star
id|sk_write_space
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|sk_error_report
r_void
(paren
op_star
id|sk_error_report
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|sk_backlog_rcv
r_int
(paren
op_star
id|sk_backlog_rcv
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
DECL|member|sk_destruct
r_void
(paren
op_star
id|sk_destruct
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Hashed lists helper routines&n; */
DECL|function|__sk_head
r_static
r_inline
r_struct
id|sock
op_star
id|__sk_head
c_func
(paren
r_struct
id|hlist_head
op_star
id|head
)paren
(brace
r_return
id|hlist_entry
c_func
(paren
id|head-&gt;first
comma
r_struct
id|sock
comma
id|sk_node
)paren
suffix:semicolon
)brace
DECL|function|sk_head
r_static
r_inline
r_struct
id|sock
op_star
id|sk_head
c_func
(paren
r_struct
id|hlist_head
op_star
id|head
)paren
(brace
r_return
id|hlist_empty
c_func
(paren
id|head
)paren
ques
c_cond
l_int|NULL
suffix:colon
id|__sk_head
c_func
(paren
id|head
)paren
suffix:semicolon
)brace
DECL|function|sk_next
r_static
r_inline
r_struct
id|sock
op_star
id|sk_next
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|sk-&gt;sk_node.next
ques
c_cond
id|hlist_entry
c_func
(paren
id|sk-&gt;sk_node.next
comma
r_struct
id|sock
comma
id|sk_node
)paren
suffix:colon
l_int|NULL
suffix:semicolon
)brace
DECL|function|sk_unhashed
r_static
r_inline
r_int
id|sk_unhashed
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|hlist_unhashed
c_func
(paren
op_amp
id|sk-&gt;sk_node
)paren
suffix:semicolon
)brace
DECL|function|sk_hashed
r_static
r_inline
r_int
id|sk_hashed
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|sk-&gt;sk_node.pprev
op_ne
l_int|NULL
suffix:semicolon
)brace
DECL|function|sk_node_init
r_static
id|__inline__
r_void
id|sk_node_init
c_func
(paren
r_struct
id|hlist_node
op_star
id|node
)paren
(brace
id|node-&gt;pprev
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|__sk_del_node
r_static
id|__inline__
r_void
id|__sk_del_node
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|__hlist_del
c_func
(paren
op_amp
id|sk-&gt;sk_node
)paren
suffix:semicolon
)brace
DECL|function|__sk_del_node_init
r_static
id|__inline__
r_int
id|__sk_del_node_init
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
id|sk_hashed
c_func
(paren
id|sk
)paren
)paren
(brace
id|__sk_del_node
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk_node_init
c_func
(paren
op_amp
id|sk-&gt;sk_node
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Grab socket reference count. This operation is valid only&n;   when sk is ALREADY grabbed f.e. it is found in hash table&n;   or a list and the lookup is made under lock preventing hash table&n;   modifications.&n; */
DECL|function|sock_hold
r_static
r_inline
r_void
id|sock_hold
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|sk-&gt;sk_refcnt
)paren
suffix:semicolon
)brace
multiline_comment|/* Ungrab socket in the context, which assumes that socket refcnt&n;   cannot hit zero, f.e. it is true in context of any socketcall.&n; */
DECL|function|__sock_put
r_static
r_inline
r_void
id|__sock_put
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|sk-&gt;sk_refcnt
)paren
suffix:semicolon
)brace
DECL|function|sk_del_node_init
r_static
id|__inline__
r_int
id|sk_del_node_init
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|rc
op_assign
id|__sk_del_node_init
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
multiline_comment|/* paranoid for a while -acme */
id|WARN_ON
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;sk_refcnt
)paren
op_eq
l_int|1
)paren
suffix:semicolon
id|__sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|__sk_add_node
r_static
id|__inline__
r_void
id|__sk_add_node
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|hlist_head
op_star
id|list
)paren
(brace
id|hlist_add_head
c_func
(paren
op_amp
id|sk-&gt;sk_node
comma
id|list
)paren
suffix:semicolon
)brace
DECL|function|sk_add_node
r_static
id|__inline__
r_void
id|sk_add_node
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|hlist_head
op_star
id|list
)paren
(brace
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
id|__sk_add_node
c_func
(paren
id|sk
comma
id|list
)paren
suffix:semicolon
)brace
DECL|function|__sk_del_bind_node
r_static
id|__inline__
r_void
id|__sk_del_bind_node
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|__hlist_del
c_func
(paren
op_amp
id|sk-&gt;sk_bind_node
)paren
suffix:semicolon
)brace
DECL|function|sk_add_bind_node
r_static
id|__inline__
r_void
id|sk_add_bind_node
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|hlist_head
op_star
id|list
)paren
(brace
id|hlist_add_head
c_func
(paren
op_amp
id|sk-&gt;sk_bind_node
comma
id|list
)paren
suffix:semicolon
)brace
DECL|macro|sk_for_each
mdefine_line|#define sk_for_each(__sk, node, list) &bslash;&n;&t;hlist_for_each_entry(__sk, node, list, sk_node)
DECL|macro|sk_for_each_from
mdefine_line|#define sk_for_each_from(__sk, node) &bslash;&n;&t;if (__sk &amp;&amp; ({ node = &amp;(__sk)-&gt;sk_node; 1; })) &bslash;&n;&t;&t;hlist_for_each_entry_from(__sk, node, sk_node)
DECL|macro|sk_for_each_continue
mdefine_line|#define sk_for_each_continue(__sk, node) &bslash;&n;&t;if (__sk &amp;&amp; ({ node = &amp;(__sk)-&gt;sk_node; 1; })) &bslash;&n;&t;&t;hlist_for_each_entry_continue(__sk, node, sk_node)
DECL|macro|sk_for_each_safe
mdefine_line|#define sk_for_each_safe(__sk, node, tmp, list) &bslash;&n;&t;hlist_for_each_entry_safe(__sk, node, tmp, list, sk_node)
DECL|macro|sk_for_each_bound
mdefine_line|#define sk_for_each_bound(__sk, node, list) &bslash;&n;&t;hlist_for_each_entry(__sk, node, list, sk_bind_node)
multiline_comment|/* Sock flags */
DECL|enum|sock_flags
r_enum
id|sock_flags
(brace
DECL|enumerator|SOCK_DEAD
id|SOCK_DEAD
comma
DECL|enumerator|SOCK_DONE
id|SOCK_DONE
comma
DECL|enumerator|SOCK_URGINLINE
id|SOCK_URGINLINE
comma
DECL|enumerator|SOCK_KEEPOPEN
id|SOCK_KEEPOPEN
comma
DECL|enumerator|SOCK_LINGER
id|SOCK_LINGER
comma
DECL|enumerator|SOCK_DESTROY
id|SOCK_DESTROY
comma
DECL|enumerator|SOCK_BROADCAST
id|SOCK_BROADCAST
comma
DECL|enumerator|SOCK_TIMESTAMP
id|SOCK_TIMESTAMP
comma
)brace
suffix:semicolon
DECL|function|sock_set_flag
r_static
r_inline
r_void
id|sock_set_flag
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_enum
id|sock_flags
id|flag
)paren
(brace
id|__set_bit
c_func
(paren
id|flag
comma
op_amp
id|sk-&gt;sk_flags
)paren
suffix:semicolon
)brace
DECL|function|sock_reset_flag
r_static
r_inline
r_void
id|sock_reset_flag
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_enum
id|sock_flags
id|flag
)paren
(brace
id|__clear_bit
c_func
(paren
id|flag
comma
op_amp
id|sk-&gt;sk_flags
)paren
suffix:semicolon
)brace
DECL|function|sock_flag
r_static
r_inline
r_int
id|sock_flag
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_enum
id|sock_flags
id|flag
)paren
(brace
r_return
id|test_bit
c_func
(paren
id|flag
comma
op_amp
id|sk-&gt;sk_flags
)paren
suffix:semicolon
)brace
DECL|function|sk_acceptq_removed
r_static
r_inline
r_void
id|sk_acceptq_removed
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|sk-&gt;sk_ack_backlog
op_decrement
suffix:semicolon
)brace
DECL|function|sk_acceptq_added
r_static
r_inline
r_void
id|sk_acceptq_added
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|sk-&gt;sk_ack_backlog
op_increment
suffix:semicolon
)brace
DECL|function|sk_acceptq_is_full
r_static
r_inline
r_int
id|sk_acceptq_is_full
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|sk-&gt;sk_ack_backlog
OG
id|sk-&gt;sk_max_ack_backlog
suffix:semicolon
)brace
multiline_comment|/*&n; * Compute minimal free write space needed to queue new packets.&n; */
DECL|function|sk_stream_min_wspace
r_static
r_inline
r_int
id|sk_stream_min_wspace
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|sk-&gt;sk_wmem_queued
op_div
l_int|2
suffix:semicolon
)brace
DECL|function|sk_stream_wspace
r_static
r_inline
r_int
id|sk_stream_wspace
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|sk-&gt;sk_sndbuf
op_minus
id|sk-&gt;sk_wmem_queued
suffix:semicolon
)brace
r_extern
r_void
id|sk_stream_write_space
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|function|sk_stream_memory_free
r_static
r_inline
r_int
id|sk_stream_memory_free
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|sk-&gt;sk_wmem_queued
OL
id|sk-&gt;sk_sndbuf
suffix:semicolon
)brace
r_extern
r_void
id|sk_stream_rfree
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
DECL|function|sk_stream_set_owner_r
r_static
r_inline
r_void
id|sk_stream_set_owner_r
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|skb-&gt;destructor
op_assign
id|sk_stream_rfree
suffix:semicolon
id|atomic_add
c_func
(paren
id|skb-&gt;truesize
comma
op_amp
id|sk-&gt;sk_rmem_alloc
)paren
suffix:semicolon
id|sk-&gt;sk_forward_alloc
op_sub_assign
id|skb-&gt;truesize
suffix:semicolon
)brace
DECL|function|sk_stream_free_skb
r_static
r_inline
r_void
id|sk_stream_free_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|sk-&gt;sk_queue_shrunk
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;sk_wmem_queued
op_sub_assign
id|skb-&gt;truesize
suffix:semicolon
id|sk-&gt;sk_forward_alloc
op_add_assign
id|skb-&gt;truesize
suffix:semicolon
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* The per-socket spinlock must be held here. */
DECL|macro|sk_add_backlog
mdefine_line|#define sk_add_backlog(__sk, __skb)&t;&t;&t;&t;&bslash;&n;do {&t;if (!(__sk)-&gt;sk_backlog.tail) {&t;&t;&t;&t;&bslash;&n;&t;&t;(__sk)-&gt;sk_backlog.head =&t;&t;&t;&bslash;&n;&t;&t;     (__sk)-&gt;sk_backlog.tail = (__skb);&t;&t;&bslash;&n;&t;} else {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;((__sk)-&gt;sk_backlog.tail)-&gt;next = (__skb);&t;&bslash;&n;&t;&t;(__sk)-&gt;sk_backlog.tail = (__skb);&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;(__skb)-&gt;next = NULL;&t;&t;&t;&t;&t;&bslash;&n;} while(0)
DECL|macro|sk_wait_event
mdefine_line|#define sk_wait_event(__sk, __timeo, __condition)&t;&t;&bslash;&n;({&t;int rc;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;release_sock(__sk);&t;&t;&t;&t;&t;&bslash;&n;&t;rc = __condition;&t;&t;&t;&t;&t;&bslash;&n;&t;if (!rc) {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;*(__timeo) = schedule_timeout(*(__timeo));&t;&bslash;&n;&t;&t;rc = __condition;&t;&t;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;lock_sock(__sk);&t;&t;&t;&t;&t;&bslash;&n;&t;rc;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;})
r_extern
r_int
id|sk_stream_wait_connect
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
op_star
id|timeo_p
)paren
suffix:semicolon
r_extern
r_int
id|sk_stream_wait_memory
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
op_star
id|timeo_p
)paren
suffix:semicolon
r_extern
r_void
id|sk_stream_wait_close
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|timeo_p
)paren
suffix:semicolon
r_extern
r_int
id|sk_stream_error
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
comma
r_int
id|err
)paren
suffix:semicolon
r_extern
r_void
id|sk_stream_kill_queues
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_int
id|sk_wait_data
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
op_star
id|timeo
)paren
suffix:semicolon
multiline_comment|/* Networking protocol blocks we attach to sockets.&n; * socket layer -&gt; transport layer interface&n; * transport -&gt; network interface is defined by struct inet_proto&n; */
DECL|struct|proto
r_struct
id|proto
(brace
DECL|member|close
r_void
(paren
op_star
id|close
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|timeout
)paren
suffix:semicolon
DECL|member|connect
r_int
(paren
op_star
id|connect
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
id|addr_len
)paren
suffix:semicolon
DECL|member|disconnect
r_int
(paren
op_star
id|disconnect
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
)paren
suffix:semicolon
DECL|member|accept
r_struct
id|sock
op_star
(paren
op_star
id|accept
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
comma
r_int
op_star
id|err
)paren
suffix:semicolon
DECL|member|ioctl
r_int
(paren
op_star
id|ioctl
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
DECL|member|init
r_int
(paren
op_star
id|init
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|destroy
r_int
(paren
op_star
id|destroy
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|shutdown
r_void
(paren
op_star
id|shutdown
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|how
)paren
suffix:semicolon
DECL|member|setsockopt
r_int
(paren
op_star
id|setsockopt
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|optlen
)paren
suffix:semicolon
DECL|member|getsockopt
r_int
(paren
op_star
id|getsockopt
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|__user
op_star
id|option
)paren
suffix:semicolon
DECL|member|sendmsg
r_int
(paren
op_star
id|sendmsg
)paren
(paren
r_struct
id|kiocb
op_star
id|iocb
comma
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|len
)paren
suffix:semicolon
DECL|member|recvmsg
r_int
(paren
op_star
id|recvmsg
)paren
(paren
r_struct
id|kiocb
op_star
id|iocb
comma
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|len
comma
r_int
id|noblock
comma
r_int
id|flags
comma
r_int
op_star
id|addr_len
)paren
suffix:semicolon
DECL|member|sendpage
r_int
(paren
op_star
id|sendpage
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|offset
comma
r_int
id|size
comma
r_int
id|flags
)paren
suffix:semicolon
DECL|member|bind
r_int
(paren
op_star
id|bind
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
id|addr_len
)paren
suffix:semicolon
DECL|member|backlog_rcv
r_int
(paren
op_star
id|backlog_rcv
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
multiline_comment|/* Keeping track of sk&squot;s, looking them up, and port selection methods. */
DECL|member|hash
r_void
(paren
op_star
id|hash
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|unhash
r_void
(paren
op_star
id|unhash
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|get_port
r_int
(paren
op_star
id|get_port
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|snum
)paren
suffix:semicolon
multiline_comment|/* Memory pressure */
DECL|member|enter_memory_pressure
r_void
(paren
op_star
id|enter_memory_pressure
)paren
(paren
r_void
)paren
suffix:semicolon
DECL|member|memory_allocated
id|atomic_t
op_star
id|memory_allocated
suffix:semicolon
multiline_comment|/* Current allocated memory. */
DECL|member|sockets_allocated
id|atomic_t
op_star
id|sockets_allocated
suffix:semicolon
multiline_comment|/* Current number of sockets. */
multiline_comment|/*&n;&t; * Pressure flag: try to collapse.&n;&t; * Technical note: it is used by multiple contexts non atomically.&n;&t; * All the sk_stream_mem_schedule() is of this nature: accounting&n;&t; * is strict, actions are advisory and have some latency.&n;&t; */
DECL|member|memory_pressure
r_int
op_star
id|memory_pressure
suffix:semicolon
DECL|member|sysctl_mem
r_int
op_star
id|sysctl_mem
suffix:semicolon
DECL|member|sysctl_wmem
r_int
op_star
id|sysctl_wmem
suffix:semicolon
DECL|member|sysctl_rmem
r_int
op_star
id|sysctl_rmem
suffix:semicolon
DECL|member|max_header
r_int
id|max_header
suffix:semicolon
DECL|member|slab
id|kmem_cache_t
op_star
id|slab
suffix:semicolon
DECL|member|slab_obj_size
r_int
id|slab_obj_size
suffix:semicolon
DECL|member|name
r_char
id|name
(braket
l_int|32
)braket
suffix:semicolon
r_struct
(brace
DECL|member|inuse
r_int
id|inuse
suffix:semicolon
DECL|member|__pad
id|u8
id|__pad
(braket
id|SMP_CACHE_BYTES
op_minus
r_sizeof
(paren
r_int
)paren
)braket
suffix:semicolon
DECL|member|stats
)brace
id|stats
(braket
id|NR_CPUS
)braket
suffix:semicolon
)brace
suffix:semicolon
r_extern
r_int
id|sk_alloc_slab
c_func
(paren
r_struct
id|proto
op_star
id|prot
comma
r_char
op_star
id|name
)paren
suffix:semicolon
r_extern
r_void
id|sk_free_slab
c_func
(paren
r_struct
id|proto
op_star
id|prot
)paren
suffix:semicolon
DECL|function|sk_alloc_slab_error
r_static
r_inline
r_void
id|sk_alloc_slab_error
c_func
(paren
r_struct
id|proto
op_star
id|proto
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s: Can&squot;t create sock SLAB cache!&bslash;n&quot;
comma
id|proto-&gt;name
)paren
suffix:semicolon
)brace
DECL|function|sk_set_owner
r_static
id|__inline__
r_void
id|sk_set_owner
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|module
op_star
id|owner
)paren
(brace
multiline_comment|/*&n;&t; * One should use sk_set_owner just once, after struct sock creation,&n;&t; * be it shortly after sk_alloc or after a function that returns a new&n;&t; * struct sock (and that down the call chain called sk_alloc), e.g. the&n;&t; * IPv4 and IPv6 modules share tcp_create_openreq_child, so if&n;&t; * tcp_create_openreq_child called sk_set_owner IPv6 would have to&n;&t; * change the ownership of this struct sock, with one not needed&n;&t; * transient sk_set_owner call.&n;&t; */
id|BUG_ON
c_func
(paren
id|sk-&gt;sk_owner
op_ne
l_int|NULL
)paren
suffix:semicolon
id|sk-&gt;sk_owner
op_assign
id|owner
suffix:semicolon
id|__module_get
c_func
(paren
id|owner
)paren
suffix:semicolon
)brace
multiline_comment|/* Called with local bh disabled */
DECL|function|sock_prot_inc_use
r_static
id|__inline__
r_void
id|sock_prot_inc_use
c_func
(paren
r_struct
id|proto
op_star
id|prot
)paren
(brace
id|prot-&gt;stats
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
dot
id|inuse
op_increment
suffix:semicolon
)brace
DECL|function|sock_prot_dec_use
r_static
id|__inline__
r_void
id|sock_prot_dec_use
c_func
(paren
r_struct
id|proto
op_star
id|prot
)paren
(brace
id|prot-&gt;stats
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
dot
id|inuse
op_decrement
suffix:semicolon
)brace
multiline_comment|/* About 10 seconds */
DECL|macro|SOCK_DESTROY_TIME
mdefine_line|#define SOCK_DESTROY_TIME (10*HZ)
multiline_comment|/* Sockets 0-1023 can&squot;t be bound to unless you are superuser */
DECL|macro|PROT_SOCK
mdefine_line|#define PROT_SOCK&t;1024
DECL|macro|SHUTDOWN_MASK
mdefine_line|#define SHUTDOWN_MASK&t;3
DECL|macro|RCV_SHUTDOWN
mdefine_line|#define RCV_SHUTDOWN&t;1
DECL|macro|SEND_SHUTDOWN
mdefine_line|#define SEND_SHUTDOWN&t;2
DECL|macro|SOCK_SNDBUF_LOCK
mdefine_line|#define SOCK_SNDBUF_LOCK&t;1
DECL|macro|SOCK_RCVBUF_LOCK
mdefine_line|#define SOCK_RCVBUF_LOCK&t;2
DECL|macro|SOCK_BINDADDR_LOCK
mdefine_line|#define SOCK_BINDADDR_LOCK&t;4
DECL|macro|SOCK_BINDPORT_LOCK
mdefine_line|#define SOCK_BINDPORT_LOCK&t;8
multiline_comment|/* sock_iocb: used to kick off async processing of socket ios */
DECL|struct|sock_iocb
r_struct
id|sock_iocb
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|flags
r_int
id|flags
suffix:semicolon
DECL|member|size
r_int
id|size
suffix:semicolon
DECL|member|sock
r_struct
id|socket
op_star
id|sock
suffix:semicolon
DECL|member|sk
r_struct
id|sock
op_star
id|sk
suffix:semicolon
DECL|member|scm
r_struct
id|scm_cookie
op_star
id|scm
suffix:semicolon
DECL|member|msg
DECL|member|async_msg
r_struct
id|msghdr
op_star
id|msg
comma
id|async_msg
suffix:semicolon
DECL|member|async_iov
r_struct
id|iovec
id|async_iov
suffix:semicolon
DECL|member|kiocb
r_struct
id|kiocb
op_star
id|kiocb
suffix:semicolon
)brace
suffix:semicolon
DECL|function|kiocb_to_siocb
r_static
r_inline
r_struct
id|sock_iocb
op_star
id|kiocb_to_siocb
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
)paren
(brace
r_return
(paren
r_struct
id|sock_iocb
op_star
)paren
id|iocb
op_member_access_from_pointer
r_private
suffix:semicolon
)brace
DECL|function|siocb_to_kiocb
r_static
r_inline
r_struct
id|kiocb
op_star
id|siocb_to_kiocb
c_func
(paren
r_struct
id|sock_iocb
op_star
id|si
)paren
(brace
r_return
id|si-&gt;kiocb
suffix:semicolon
)brace
DECL|struct|socket_alloc
r_struct
id|socket_alloc
(brace
DECL|member|socket
r_struct
id|socket
id|socket
suffix:semicolon
DECL|member|vfs_inode
r_struct
id|inode
id|vfs_inode
suffix:semicolon
)brace
suffix:semicolon
DECL|function|SOCKET_I
r_static
r_inline
r_struct
id|socket
op_star
id|SOCKET_I
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_return
op_amp
id|container_of
c_func
(paren
id|inode
comma
r_struct
id|socket_alloc
comma
id|vfs_inode
)paren
op_member_access_from_pointer
id|socket
suffix:semicolon
)brace
DECL|function|SOCK_INODE
r_static
r_inline
r_struct
id|inode
op_star
id|SOCK_INODE
c_func
(paren
r_struct
id|socket
op_star
id|socket
)paren
(brace
r_return
op_amp
id|container_of
c_func
(paren
id|socket
comma
r_struct
id|socket_alloc
comma
id|socket
)paren
op_member_access_from_pointer
id|vfs_inode
suffix:semicolon
)brace
r_extern
r_void
id|__sk_stream_mem_reclaim
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_int
id|sk_stream_mem_schedule
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|size
comma
r_int
id|kind
)paren
suffix:semicolon
DECL|macro|SK_STREAM_MEM_QUANTUM
mdefine_line|#define SK_STREAM_MEM_QUANTUM ((int)PAGE_SIZE)
DECL|function|sk_stream_pages
r_static
r_inline
r_int
id|sk_stream_pages
c_func
(paren
r_int
id|amt
)paren
(brace
r_return
(paren
id|amt
op_plus
id|SK_STREAM_MEM_QUANTUM
op_minus
l_int|1
)paren
op_div
id|SK_STREAM_MEM_QUANTUM
suffix:semicolon
)brace
DECL|function|sk_stream_mem_reclaim
r_static
r_inline
r_void
id|sk_stream_mem_reclaim
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;sk_forward_alloc
op_ge
id|SK_STREAM_MEM_QUANTUM
)paren
id|__sk_stream_mem_reclaim
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
DECL|function|sk_stream_writequeue_purge
r_static
r_inline
r_void
id|sk_stream_writequeue_purge
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|__skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;sk_write_queue
)paren
)paren
op_ne
l_int|NULL
)paren
id|sk_stream_free_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
id|sk_stream_mem_reclaim
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
DECL|function|sk_stream_rmem_schedule
r_static
r_inline
r_int
id|sk_stream_rmem_schedule
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_return
(paren
r_int
)paren
id|skb-&gt;truesize
op_le
id|sk-&gt;sk_forward_alloc
op_logical_or
id|sk_stream_mem_schedule
c_func
(paren
id|sk
comma
id|skb-&gt;truesize
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Used by processes to &quot;lock&quot; a socket state, so that&n; * interrupts and bottom half handlers won&squot;t change it&n; * from under us. It essentially blocks any incoming&n; * packets, so that we won&squot;t get any new data or any&n; * packets that change the state of the socket.&n; *&n; * While locked, BH processing will add new packets to&n; * the backlog queue.  This queue is processed by the&n; * owner of the socket lock right before it is released.&n; *&n; * Since ~2.3.5 it is also exclusive sleep lock serializing&n; * accesses from user process context.&n; */
r_extern
r_void
id|__lock_sock
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_void
id|__release_sock
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|macro|sock_owned_by_user
mdefine_line|#define sock_owned_by_user(sk)&t;((sk)-&gt;sk_lock.owner)
r_extern
r_void
id|FASTCALL
c_func
(paren
id|lock_sock
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
)paren
suffix:semicolon
r_extern
r_void
id|FASTCALL
c_func
(paren
id|release_sock
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
)paren
suffix:semicolon
multiline_comment|/* BH context may only use the following locking interface. */
DECL|macro|bh_lock_sock
mdefine_line|#define bh_lock_sock(__sk)&t;spin_lock(&amp;((__sk)-&gt;sk_lock.slock))
DECL|macro|bh_unlock_sock
mdefine_line|#define bh_unlock_sock(__sk)&t;spin_unlock(&amp;((__sk)-&gt;sk_lock.slock))
r_extern
r_struct
id|sock
op_star
id|sk_alloc
c_func
(paren
r_int
id|family
comma
r_int
id|priority
comma
r_int
id|zero_it
comma
id|kmem_cache_t
op_star
id|slab
)paren
suffix:semicolon
r_extern
r_void
id|sk_free
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|sock_wmalloc
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|size
comma
r_int
id|force
comma
r_int
id|priority
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|sock_rmalloc
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|size
comma
r_int
id|force
comma
r_int
id|priority
)paren
suffix:semicolon
r_extern
r_void
id|sock_wfree
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_extern
r_void
id|sock_rfree
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_extern
r_int
id|sock_setsockopt
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|level
comma
r_int
id|op
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|optlen
)paren
suffix:semicolon
r_extern
r_int
id|sock_getsockopt
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|level
comma
r_int
id|op
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|__user
op_star
id|optlen
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|sock_alloc_send_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|size
comma
r_int
id|noblock
comma
r_int
op_star
id|errcode
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|sock_alloc_send_pskb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|header_len
comma
r_int
r_int
id|data_len
comma
r_int
id|noblock
comma
r_int
op_star
id|errcode
)paren
suffix:semicolon
r_extern
r_void
op_star
id|sock_kmalloc
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|size
comma
r_int
id|priority
)paren
suffix:semicolon
r_extern
r_void
id|sock_kfree_s
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_void
op_star
id|mem
comma
r_int
id|size
)paren
suffix:semicolon
r_extern
r_void
id|sk_send_sigurg
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n; * Functions to fill in entries in struct proto_ops when a protocol&n; * does not implement a particular function.&n; */
r_extern
r_int
id|sock_no_bind
c_func
(paren
r_struct
id|socket
op_star
comma
r_struct
id|sockaddr
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_connect
c_func
(paren
r_struct
id|socket
op_star
comma
r_struct
id|sockaddr
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_socketpair
c_func
(paren
r_struct
id|socket
op_star
comma
r_struct
id|socket
op_star
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_accept
c_func
(paren
r_struct
id|socket
op_star
comma
r_struct
id|socket
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_getname
c_func
(paren
r_struct
id|socket
op_star
comma
r_struct
id|sockaddr
op_star
comma
r_int
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
r_int
id|sock_no_poll
c_func
(paren
r_struct
id|file
op_star
comma
r_struct
id|socket
op_star
comma
r_struct
id|poll_table_struct
op_star
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_ioctl
c_func
(paren
r_struct
id|socket
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_listen
c_func
(paren
r_struct
id|socket
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_shutdown
c_func
(paren
r_struct
id|socket
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_getsockopt
c_func
(paren
r_struct
id|socket
op_star
comma
r_int
comma
r_int
comma
r_char
id|__user
op_star
comma
r_int
id|__user
op_star
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_setsockopt
c_func
(paren
r_struct
id|socket
op_star
comma
r_int
comma
r_int
comma
r_char
id|__user
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_sendmsg
c_func
(paren
r_struct
id|kiocb
op_star
comma
r_struct
id|socket
op_star
comma
r_struct
id|msghdr
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_recvmsg
c_func
(paren
r_struct
id|kiocb
op_star
comma
r_struct
id|socket
op_star
comma
r_struct
id|msghdr
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
suffix:semicolon
r_extern
id|ssize_t
id|sock_no_sendpage
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|offset
comma
r_int
id|size
comma
r_int
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n; * Functions to fill in entries in struct proto_ops when a protocol&n; * uses the inet style.&n; */
r_extern
r_int
id|sock_common_getsockopt
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|__user
op_star
id|optlen
)paren
suffix:semicolon
r_extern
r_int
id|sock_common_recvmsg
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
comma
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|size
comma
r_int
id|flags
)paren
suffix:semicolon
r_extern
r_int
id|sock_common_setsockopt
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
id|__user
op_star
id|optval
comma
r_int
id|optlen
)paren
suffix:semicolon
r_extern
r_void
id|sk_common_release
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Default socket callbacks and setup code&n; */
r_extern
r_void
id|sock_def_destruct
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
multiline_comment|/* Initialise core socket variables */
r_extern
r_void
id|sock_init_data
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;sk_filter - run a packet through a socket filter&n; *&t;@sk: sock associated with &amp;sk_buff&n; *&t;@skb: buffer to filter&n; *&t;@needlock: set to 1 if the sock is not locked by caller.&n; *&n; * Run the filter code and then cut skb-&gt;data to correct size returned by&n; * sk_run_filter. If pkt_len is 0 we toss packet. If skb-&gt;len is smaller&n; * than pkt_len we keep whole skb-&gt;data. This is the socket level&n; * wrapper to sk_run_filter. It returns 0 if the packet should&n; * be accepted or -EPERM if the packet should be tossed.&n; *&n; */
DECL|function|sk_filter
r_static
r_inline
r_int
id|sk_filter
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|needlock
)paren
(brace
r_int
id|err
suffix:semicolon
id|err
op_assign
id|security_sock_rcv_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;sk_filter
)paren
(brace
r_struct
id|sk_filter
op_star
id|filter
suffix:semicolon
r_if
c_cond
(paren
id|needlock
)paren
id|bh_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
id|filter
op_assign
id|sk-&gt;sk_filter
suffix:semicolon
r_if
c_cond
(paren
id|filter
)paren
(brace
r_int
id|pkt_len
op_assign
id|sk_run_filter
c_func
(paren
id|skb
comma
id|filter-&gt;insns
comma
id|filter-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pkt_len
)paren
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_else
id|skb_trim
c_func
(paren
id|skb
comma
id|pkt_len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|needlock
)paren
id|bh_unlock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;sk_filter_release: Release a socket filter&n; *&t;@sk: socket&n; *&t;@fp: filter to remove&n; *&n; *&t;Remove a filter from a socket and release its resources.&n; */
DECL|function|sk_filter_release
r_static
r_inline
r_void
id|sk_filter_release
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_filter
op_star
id|fp
)paren
(brace
r_int
r_int
id|size
op_assign
id|sk_filter_len
c_func
(paren
id|fp
)paren
suffix:semicolon
id|atomic_sub
c_func
(paren
id|size
comma
op_amp
id|sk-&gt;sk_omem_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|fp-&gt;refcnt
)paren
)paren
id|kfree
c_func
(paren
id|fp
)paren
suffix:semicolon
)brace
DECL|function|sk_filter_charge
r_static
r_inline
r_void
id|sk_filter_charge
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_filter
op_star
id|fp
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|fp-&gt;refcnt
)paren
suffix:semicolon
id|atomic_add
c_func
(paren
id|sk_filter_len
c_func
(paren
id|fp
)paren
comma
op_amp
id|sk-&gt;sk_omem_alloc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Socket reference counting postulates.&n; *&n; * * Each user of socket SHOULD hold a reference count.&n; * * Each access point to socket (an hash table bucket, reference from a list,&n; *   running timer, skb in flight MUST hold a reference count.&n; * * When reference count hits 0, it means it will never increase back.&n; * * When reference count hits 0, it means that no references from&n; *   outside exist to this socket and current process on current CPU&n; *   is last user and may/should destroy this socket.&n; * * sk_free is called from any context: process, BH, IRQ. When&n; *   it is called, socket has no references from outside -&gt; sk_free&n; *   may release descendant resources allocated by the socket, but&n; *   to the time when it is called, socket is NOT referenced by any&n; *   hash tables, lists etc.&n; * * Packets, delivered from outside (from network or from another process)&n; *   and enqueued on receive/error queues SHOULD NOT grab reference count,&n; *   when they sit in queue. Otherwise, packets will leak to hole, when&n; *   socket is looked up by one cpu and unhasing is made by another CPU.&n; *   It is true for udp/raw, netlink (leak to receive and error queues), tcp&n; *   (leak to backlog). Packet socket does all the processing inside&n; *   BR_NETPROTO_LOCK, so that it has not this race condition. UNIX sockets&n; *   use separate SMP lock, so that they are prone too.&n; */
multiline_comment|/* Ungrab socket and destroy it, if it was the last reference. */
DECL|function|sock_put
r_static
r_inline
r_void
id|sock_put
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|sk-&gt;sk_refcnt
)paren
)paren
id|sk_free
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/* Detach socket from process context.&n; * Announce socket dead, detach it from wait queue and inode.&n; * Note that parent inode held reference count on this struct sock,&n; * we do not release it in this function, because protocol&n; * probably wants some additional cleanups or even continuing&n; * to work with this socket (TCP).&n; */
DECL|function|sock_orphan
r_static
r_inline
r_void
id|sock_orphan
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|sk-&gt;sk_callback_lock
)paren
suffix:semicolon
id|sock_set_flag
c_func
(paren
id|sk
comma
id|SOCK_DEAD
)paren
suffix:semicolon
id|sk-&gt;sk_socket
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;sk_sleep
op_assign
l_int|NULL
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|sk-&gt;sk_callback_lock
)paren
suffix:semicolon
)brace
DECL|function|sock_graft
r_static
r_inline
r_void
id|sock_graft
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|socket
op_star
id|parent
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|sk-&gt;sk_callback_lock
)paren
suffix:semicolon
id|sk-&gt;sk_sleep
op_assign
op_amp
id|parent-&gt;wait
suffix:semicolon
id|parent-&gt;sk
op_assign
id|sk
suffix:semicolon
id|sk-&gt;sk_socket
op_assign
id|parent
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|sk-&gt;sk_callback_lock
)paren
suffix:semicolon
)brace
r_extern
r_int
id|sock_i_uid
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_int
r_int
id|sock_i_ino
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_static
r_inline
r_struct
id|dst_entry
op_star
DECL|function|__sk_dst_get
id|__sk_dst_get
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|sk-&gt;sk_dst_cache
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|dst_entry
op_star
DECL|function|sk_dst_get
id|sk_dst_get
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|dst_entry
op_star
id|dst
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|sk-&gt;sk_dst_lock
)paren
suffix:semicolon
id|dst
op_assign
id|sk-&gt;sk_dst_cache
suffix:semicolon
r_if
c_cond
(paren
id|dst
)paren
id|dst_hold
c_func
(paren
id|dst
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|sk-&gt;sk_dst_lock
)paren
suffix:semicolon
r_return
id|dst
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|__sk_dst_set
id|__sk_dst_set
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|dst_entry
op_star
id|dst
)paren
(brace
r_struct
id|dst_entry
op_star
id|old_dst
suffix:semicolon
id|old_dst
op_assign
id|sk-&gt;sk_dst_cache
suffix:semicolon
id|sk-&gt;sk_dst_cache
op_assign
id|dst
suffix:semicolon
id|dst_release
c_func
(paren
id|old_dst
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|sk_dst_set
id|sk_dst_set
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|dst_entry
op_star
id|dst
)paren
(brace
id|write_lock
c_func
(paren
op_amp
id|sk-&gt;sk_dst_lock
)paren
suffix:semicolon
id|__sk_dst_set
c_func
(paren
id|sk
comma
id|dst
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|sk-&gt;sk_dst_lock
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|__sk_dst_reset
id|__sk_dst_reset
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|dst_entry
op_star
id|old_dst
suffix:semicolon
id|old_dst
op_assign
id|sk-&gt;sk_dst_cache
suffix:semicolon
id|sk-&gt;sk_dst_cache
op_assign
l_int|NULL
suffix:semicolon
id|dst_release
c_func
(paren
id|old_dst
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|sk_dst_reset
id|sk_dst_reset
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|write_lock
c_func
(paren
op_amp
id|sk-&gt;sk_dst_lock
)paren
suffix:semicolon
id|__sk_dst_reset
c_func
(paren
id|sk
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|sk-&gt;sk_dst_lock
)paren
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|dst_entry
op_star
DECL|function|__sk_dst_check
id|__sk_dst_check
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|cookie
)paren
(brace
r_struct
id|dst_entry
op_star
id|dst
op_assign
id|sk-&gt;sk_dst_cache
suffix:semicolon
r_if
c_cond
(paren
id|dst
op_logical_and
id|dst-&gt;obsolete
op_logical_and
id|dst-&gt;ops
op_member_access_from_pointer
id|check
c_func
(paren
id|dst
comma
id|cookie
)paren
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;sk_dst_cache
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|dst
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|dst_entry
op_star
DECL|function|sk_dst_check
id|sk_dst_check
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|cookie
)paren
(brace
r_struct
id|dst_entry
op_star
id|dst
op_assign
id|sk_dst_get
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dst
op_logical_and
id|dst-&gt;obsolete
op_logical_and
id|dst-&gt;ops
op_member_access_from_pointer
id|check
c_func
(paren
id|dst
comma
id|cookie
)paren
op_eq
l_int|NULL
)paren
(brace
id|sk_dst_reset
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|dst
suffix:semicolon
)brace
DECL|function|sk_charge_skb
r_static
r_inline
r_void
id|sk_charge_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|sk-&gt;sk_wmem_queued
op_add_assign
id|skb-&gt;truesize
suffix:semicolon
id|sk-&gt;sk_forward_alloc
op_sub_assign
id|skb-&gt;truesize
suffix:semicolon
)brace
DECL|function|skb_copy_to_page
r_static
r_inline
r_int
id|skb_copy_to_page
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_char
id|__user
op_star
id|from
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|off
comma
r_int
id|copy
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;ip_summed
op_eq
id|CHECKSUM_NONE
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|csum
op_assign
id|csum_and_copy_from_user
c_func
(paren
id|from
comma
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|off
comma
id|copy
comma
l_int|0
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|skb-&gt;csum
op_assign
id|csum_block_add
c_func
(paren
id|skb-&gt;csum
comma
id|csum
comma
id|skb-&gt;len
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|off
comma
id|from
comma
id|copy
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|skb-&gt;len
op_add_assign
id|copy
suffix:semicolon
id|skb-&gt;data_len
op_add_assign
id|copy
suffix:semicolon
id|skb-&gt;truesize
op_add_assign
id|copy
suffix:semicolon
id|sk-&gt;sk_wmem_queued
op_add_assign
id|copy
suffix:semicolon
id|sk-&gt;sk_forward_alloc
op_sub_assign
id|copy
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Queue a received datagram if it will fit. Stream and sequenced&n; *&t;protocols can&squot;t normally use this as they need to fit buffers in&n; *&t;and play with them.&n; *&n; * &t;Inlined as it&squot;s very short and called for pretty much every&n; *&t;packet ever received.&n; */
DECL|function|skb_set_owner_w
r_static
r_inline
r_void
id|skb_set_owner_w
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|skb-&gt;destructor
op_assign
id|sock_wfree
suffix:semicolon
id|atomic_add
c_func
(paren
id|skb-&gt;truesize
comma
op_amp
id|sk-&gt;sk_wmem_alloc
)paren
suffix:semicolon
)brace
DECL|function|skb_set_owner_r
r_static
r_inline
r_void
id|skb_set_owner_r
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|skb-&gt;destructor
op_assign
id|sock_rfree
suffix:semicolon
id|atomic_add
c_func
(paren
id|skb-&gt;truesize
comma
op_amp
id|sk-&gt;sk_rmem_alloc
)paren
suffix:semicolon
)brace
r_extern
r_void
id|sk_reset_timer
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|timer_list
op_star
id|timer
comma
r_int
r_int
id|expires
)paren
suffix:semicolon
r_extern
r_void
id|sk_stop_timer
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|timer_list
op_star
id|timer
)paren
suffix:semicolon
DECL|function|sock_queue_rcv_skb
r_static
r_inline
r_int
id|sock_queue_rcv_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|skb_len
suffix:semicolon
multiline_comment|/* Cast skb-&gt;rcvbuf to unsigned... It&squot;s pointless, but reduces&n;&t;   number of warnings when compiling with -W --ANK&n;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;sk_rmem_alloc
)paren
op_plus
id|skb-&gt;truesize
op_ge
(paren
r_int
)paren
id|sk-&gt;sk_rcvbuf
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* It would be deadlock, if sock_queue_rcv_skb is used&n;&t;   with socket lock! We assume that users of this&n;&t;   function are lock free.&n;&t;*/
id|err
op_assign
id|sk_filter
c_func
(paren
id|sk
comma
id|skb
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|skb-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
id|skb_set_owner_r
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
multiline_comment|/* Cache the SKB length before we tack it onto the receive&n;&t; * queue.  Once it is added it no longer belongs to us and&n;&t; * may be freed by other threads of control pulling packets&n;&t; * from the queue.&n;&t; */
id|skb_len
op_assign
id|skb-&gt;len
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;sk_receive_queue
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sock_flag
c_func
(paren
id|sk
comma
id|SOCK_DEAD
)paren
)paren
id|sk
op_member_access_from_pointer
id|sk_data_ready
c_func
(paren
id|sk
comma
id|skb_len
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sock_queue_err_skb
r_static
r_inline
r_int
id|sock_queue_err_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
multiline_comment|/* Cast skb-&gt;rcvbuf to unsigned... It&squot;s pointless, but reduces&n;&t;   number of warnings when compiling with -W --ANK&n;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;sk_rmem_alloc
)paren
op_plus
id|skb-&gt;truesize
op_ge
(paren
r_int
)paren
id|sk-&gt;sk_rcvbuf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|skb_set_owner_r
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;sk_error_queue
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sock_flag
c_func
(paren
id|sk
comma
id|SOCK_DEAD
)paren
)paren
id|sk
op_member_access_from_pointer
id|sk_data_ready
c_func
(paren
id|sk
comma
id|skb-&gt;len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Recover an error report and clear atomically&n; */
DECL|function|sock_error
r_static
r_inline
r_int
id|sock_error
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|err
op_assign
id|xchg
c_func
(paren
op_amp
id|sk-&gt;sk_err
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|err
suffix:semicolon
)brace
DECL|function|sock_wspace
r_static
r_inline
r_int
r_int
id|sock_wspace
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|amt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sk-&gt;sk_shutdown
op_amp
id|SEND_SHUTDOWN
)paren
)paren
(brace
id|amt
op_assign
id|sk-&gt;sk_sndbuf
op_minus
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;sk_wmem_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|amt
OL
l_int|0
)paren
id|amt
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|amt
suffix:semicolon
)brace
DECL|function|sk_wake_async
r_static
r_inline
r_void
id|sk_wake_async
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|how
comma
r_int
id|band
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;sk_socket
op_logical_and
id|sk-&gt;sk_socket-&gt;fasync_list
)paren
id|sock_wake_async
c_func
(paren
id|sk-&gt;sk_socket
comma
id|how
comma
id|band
)paren
suffix:semicolon
)brace
DECL|macro|SOCK_MIN_SNDBUF
mdefine_line|#define SOCK_MIN_SNDBUF 2048
DECL|macro|SOCK_MIN_RCVBUF
mdefine_line|#define SOCK_MIN_RCVBUF 256
DECL|function|sk_stream_moderate_sndbuf
r_static
r_inline
r_void
id|sk_stream_moderate_sndbuf
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|sk-&gt;sk_userlocks
op_amp
id|SOCK_SNDBUF_LOCK
)paren
)paren
(brace
id|sk-&gt;sk_sndbuf
op_assign
id|min
c_func
(paren
id|sk-&gt;sk_sndbuf
comma
id|sk-&gt;sk_wmem_queued
op_div
l_int|2
)paren
suffix:semicolon
id|sk-&gt;sk_sndbuf
op_assign
id|max
c_func
(paren
id|sk-&gt;sk_sndbuf
comma
id|SOCK_MIN_SNDBUF
)paren
suffix:semicolon
)brace
)brace
DECL|function|sk_stream_alloc_pskb
r_static
r_inline
r_struct
id|sk_buff
op_star
id|sk_stream_alloc_pskb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|size
comma
r_int
id|mem
comma
r_int
id|gfp
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|size
op_plus
id|sk-&gt;sk_prot-&gt;max_header
comma
id|gfp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
id|skb-&gt;truesize
op_add_assign
id|mem
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;sk_forward_alloc
op_ge
(paren
r_int
)paren
id|skb-&gt;truesize
op_logical_or
id|sk_stream_mem_schedule
c_func
(paren
id|sk
comma
id|skb-&gt;truesize
comma
l_int|0
)paren
)paren
(brace
id|skb_reserve
c_func
(paren
id|skb
comma
id|sk-&gt;sk_prot-&gt;max_header
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
id|sk-&gt;sk_prot
op_member_access_from_pointer
id|enter_memory_pressure
c_func
(paren
)paren
suffix:semicolon
id|sk_stream_moderate_sndbuf
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|sk_stream_alloc_skb
r_static
r_inline
r_struct
id|sk_buff
op_star
id|sk_stream_alloc_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|size
comma
r_int
id|gfp
)paren
(brace
r_return
id|sk_stream_alloc_pskb
c_func
(paren
id|sk
comma
id|size
comma
l_int|0
comma
id|gfp
)paren
suffix:semicolon
)brace
DECL|function|sk_stream_alloc_page
r_static
r_inline
r_struct
id|page
op_star
id|sk_stream_alloc_page
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;sk_forward_alloc
op_ge
(paren
r_int
)paren
id|PAGE_SIZE
op_logical_or
id|sk_stream_mem_schedule
c_func
(paren
id|sk
comma
id|PAGE_SIZE
comma
l_int|0
)paren
)paren
id|page
op_assign
id|alloc_pages
c_func
(paren
id|sk-&gt;sk_allocation
comma
l_int|0
)paren
suffix:semicolon
r_else
(brace
id|sk-&gt;sk_prot
op_member_access_from_pointer
id|enter_memory_pressure
c_func
(paren
)paren
suffix:semicolon
id|sk_stream_moderate_sndbuf
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_return
id|page
suffix:semicolon
)brace
DECL|macro|sk_stream_for_retrans_queue
mdefine_line|#define sk_stream_for_retrans_queue(skb, sk)&t;&t;&t;&t;&bslash;&n;&t;&t;for (skb = (sk)-&gt;sk_write_queue.next;&t;&t;&t;&bslash;&n;&t;&t;     (skb != (sk)-&gt;sk_send_head) &amp;&amp;&t;&t;&t;&bslash;&n;&t;&t;     (skb != (struct sk_buff *)&amp;(sk)-&gt;sk_write_queue);&t;&bslash;&n;&t;&t;     skb = skb-&gt;next)
multiline_comment|/*&n; *&t;Default write policy as shown to user space via poll/select/SIGIO&n; */
DECL|function|sock_writeable
r_static
r_inline
r_int
id|sock_writeable
c_func
(paren
r_const
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;sk_wmem_alloc
)paren
OL
(paren
id|sk-&gt;sk_sndbuf
op_div
l_int|2
)paren
suffix:semicolon
)brace
DECL|function|gfp_any
r_static
r_inline
r_int
id|gfp_any
c_func
(paren
r_void
)paren
(brace
r_return
id|in_softirq
c_func
(paren
)paren
ques
c_cond
id|GFP_ATOMIC
suffix:colon
id|GFP_KERNEL
suffix:semicolon
)brace
DECL|function|sock_rcvtimeo
r_static
r_inline
r_int
id|sock_rcvtimeo
c_func
(paren
r_const
r_struct
id|sock
op_star
id|sk
comma
r_int
id|noblock
)paren
(brace
r_return
id|noblock
ques
c_cond
l_int|0
suffix:colon
id|sk-&gt;sk_rcvtimeo
suffix:semicolon
)brace
DECL|function|sock_sndtimeo
r_static
r_inline
r_int
id|sock_sndtimeo
c_func
(paren
r_const
r_struct
id|sock
op_star
id|sk
comma
r_int
id|noblock
)paren
(brace
r_return
id|noblock
ques
c_cond
l_int|0
suffix:colon
id|sk-&gt;sk_sndtimeo
suffix:semicolon
)brace
DECL|function|sock_rcvlowat
r_static
r_inline
r_int
id|sock_rcvlowat
c_func
(paren
r_const
r_struct
id|sock
op_star
id|sk
comma
r_int
id|waitall
comma
r_int
id|len
)paren
(brace
r_return
(paren
id|waitall
ques
c_cond
id|len
suffix:colon
id|min_t
c_func
(paren
r_int
comma
id|sk-&gt;sk_rcvlowat
comma
id|len
)paren
)paren
ques
c_cond
suffix:colon
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Alas, with timeout socket operations are not restartable.&n; * Compare this to poll().&n; */
DECL|function|sock_intr_errno
r_static
r_inline
r_int
id|sock_intr_errno
c_func
(paren
r_int
id|timeo
)paren
(brace
r_return
id|timeo
op_eq
id|MAX_SCHEDULE_TIMEOUT
ques
c_cond
op_minus
id|ERESTARTSYS
suffix:colon
op_minus
id|EINTR
suffix:semicolon
)brace
r_static
id|__inline__
r_void
DECL|function|sock_recv_timestamp
id|sock_recv_timestamp
c_func
(paren
r_struct
id|msghdr
op_star
id|msg
comma
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|timeval
op_star
id|stamp
op_assign
op_amp
id|skb-&gt;stamp
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;sk_rcvtstamp
)paren
(brace
multiline_comment|/* Race occurred between timestamp enabling and packet&n;&t;&t;   receiving.  Fill in the current time for now. */
r_if
c_cond
(paren
id|stamp-&gt;tv_sec
op_eq
l_int|0
)paren
id|do_gettimeofday
c_func
(paren
id|stamp
)paren
suffix:semicolon
id|put_cmsg
c_func
(paren
id|msg
comma
id|SOL_SOCKET
comma
id|SO_TIMESTAMP
comma
r_sizeof
(paren
r_struct
id|timeval
)paren
comma
id|stamp
)paren
suffix:semicolon
)brace
r_else
id|sk-&gt;sk_stamp
op_assign
op_star
id|stamp
suffix:semicolon
)brace
multiline_comment|/**&n; * sk_eat_skb - Release a skb if it is no longer needed&n; * @sk - socket to eat this skb from&n; * @skb - socket buffer to eat&n; *&n; * This routine must be called with interrupts disabled or with the socket&n; * locked so that the sk_buff queue operation is ok.&n;*/
DECL|function|sk_eat_skb
r_static
r_inline
r_void
id|sk_eat_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|__skb_unlink
c_func
(paren
id|skb
comma
op_amp
id|sk-&gt;sk_receive_queue
)paren
suffix:semicolon
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_extern
id|atomic_t
id|netstamp_needed
suffix:semicolon
r_extern
r_void
id|sock_enable_timestamp
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|function|net_timestamp
r_static
r_inline
r_void
id|net_timestamp
c_func
(paren
r_struct
id|timeval
op_star
id|stamp
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|netstamp_needed
)paren
)paren
id|do_gettimeofday
c_func
(paren
id|stamp
)paren
suffix:semicolon
r_else
(brace
id|stamp-&gt;tv_sec
op_assign
l_int|0
suffix:semicolon
id|stamp-&gt;tv_usec
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_extern
r_int
id|sock_get_timestamp
c_func
(paren
r_struct
id|sock
op_star
comma
r_struct
id|timeval
id|__user
op_star
)paren
suffix:semicolon
multiline_comment|/* &n; *&t;Enable debug/info messages &n; */
macro_line|#if 0
mdefine_line|#define NETDEBUG(x)&t;do { } while (0)
mdefine_line|#define LIMIT_NETDEBUG(x) do {} while(0)
macro_line|#else
DECL|macro|NETDEBUG
mdefine_line|#define NETDEBUG(x)&t;do { x; } while (0)
DECL|macro|LIMIT_NETDEBUG
mdefine_line|#define LIMIT_NETDEBUG(x) do { if (net_ratelimit()) { x; } } while(0)
macro_line|#endif
multiline_comment|/*&n; * Macros for sleeping on a socket. Use them like this:&n; *&n; * SOCK_SLEEP_PRE(sk)&n; * if (condition)&n; * &t;schedule();&n; * SOCK_SLEEP_POST(sk)&n; *&n; * N.B. These are now obsolete and were, afaik, only ever used in DECnet&n; * and when the last use of them in DECnet has gone, I&squot;m intending to&n; * remove them.&n; */
DECL|macro|SOCK_SLEEP_PRE
mdefine_line|#define SOCK_SLEEP_PRE(sk) &t;{ struct task_struct *tsk = current; &bslash;&n;&t;&t;&t;&t;DECLARE_WAITQUEUE(wait, tsk); &bslash;&n;&t;&t;&t;&t;tsk-&gt;state = TASK_INTERRUPTIBLE; &bslash;&n;&t;&t;&t;&t;add_wait_queue((sk)-&gt;sk_sleep, &amp;wait); &bslash;&n;&t;&t;&t;&t;release_sock(sk);
DECL|macro|SOCK_SLEEP_POST
mdefine_line|#define SOCK_SLEEP_POST(sk)&t;tsk-&gt;state = TASK_RUNNING; &bslash;&n;&t;&t;&t;&t;remove_wait_queue((sk)-&gt;sk_sleep, &amp;wait); &bslash;&n;&t;&t;&t;&t;lock_sock(sk); &bslash;&n;&t;&t;&t;&t;}
DECL|function|sock_valbool_flag
r_static
r_inline
r_void
id|sock_valbool_flag
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|bit
comma
r_int
id|valbool
)paren
(brace
r_if
c_cond
(paren
id|valbool
)paren
id|sock_set_flag
c_func
(paren
id|sk
comma
id|bit
)paren
suffix:semicolon
r_else
id|sock_reset_flag
c_func
(paren
id|sk
comma
id|bit
)paren
suffix:semicolon
)brace
r_extern
id|__u32
id|sysctl_wmem_max
suffix:semicolon
r_extern
id|__u32
id|sysctl_rmem_max
suffix:semicolon
macro_line|#ifdef CONFIG_NET
r_int
id|siocdevprivate_ioctl
c_func
(paren
r_int
r_int
id|fd
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
macro_line|#else
DECL|function|siocdevprivate_ioctl
r_static
r_inline
r_int
id|siocdevprivate_ioctl
c_func
(paren
r_int
r_int
id|fd
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
macro_line|#endif
macro_line|#endif&t;/* _SOCK_H */
eof
