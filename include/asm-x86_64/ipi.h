macro_line|#ifndef __ASM_IPI_H
DECL|macro|__ASM_IPI_H
mdefine_line|#define __ASM_IPI_H
multiline_comment|/*&n; * Copyright 2004 James Cleverdon, IBM.&n; * Subject to the GNU Public License, v.2&n; *&n; * Generic APIC InterProcessor Interrupt code.&n; *&n; * Moved to include file by James Cleverdon from&n; * arch/x86-64/kernel/smp.c&n; *&n; * Copyrights from kernel/smp.c:&n; *&n; * (c) 1995 Alan Cox, Building #3 &lt;alan@redhat.com&gt;&n; * (c) 1998-99, 2000 Ingo Molnar &lt;mingo@redhat.com&gt;&n; * (c) 2002,2003 Andi Kleen, SuSE Labs.&n; * Subject to the GNU Public License, v.2&n; */
macro_line|#include &lt;asm/fixmap.h&gt;
macro_line|#include &lt;asm/hw_irq.h&gt;
macro_line|#include &lt;asm/apicdef.h&gt;
macro_line|#include &lt;asm/genapic.h&gt;
multiline_comment|/*&n; * the following functions deal with sending IPIs between CPUs.&n; *&n; * We use &squot;broadcast&squot;, CPU-&gt;CPU IPIs and self-IPIs too.&n; */
DECL|function|__prepare_ICR
r_static
r_inline
r_int
r_int
id|__prepare_ICR
(paren
r_int
r_int
id|shortcut
comma
r_int
id|vector
comma
r_int
r_int
id|dest
)paren
(brace
r_int
r_int
id|icr
op_assign
id|APIC_DM_FIXED
op_or
id|shortcut
op_or
id|vector
op_or
id|dest
suffix:semicolon
r_if
c_cond
(paren
id|vector
op_eq
id|KDB_VECTOR
)paren
id|icr
op_assign
(paren
id|icr
op_amp
(paren
op_complement
id|APIC_VECTOR_MASK
)paren
)paren
op_or
id|APIC_DM_NMI
suffix:semicolon
r_return
id|icr
suffix:semicolon
)brace
DECL|function|__prepare_ICR2
r_static
r_inline
r_int
id|__prepare_ICR2
(paren
r_int
r_int
id|mask
)paren
(brace
r_return
id|SET_APIC_DEST_FIELD
c_func
(paren
id|mask
)paren
suffix:semicolon
)brace
DECL|function|__send_IPI_shortcut
r_static
r_inline
r_void
id|__send_IPI_shortcut
c_func
(paren
r_int
r_int
id|shortcut
comma
r_int
id|vector
comma
r_int
r_int
id|dest
)paren
(brace
multiline_comment|/*&n;&t; * Subtle. In the case of the &squot;never do double writes&squot; workaround&n;&t; * we have to lock out interrupts to be safe.  As we don&squot;t care&n;&t; * of the value read we use an atomic rmw access to avoid costly&n;&t; * cli/sti.  Otherwise we use an even cheaper single atomic write&n;&t; * to the APIC.&n;&t; */
r_int
r_int
id|cfg
suffix:semicolon
multiline_comment|/*&n;&t; * Wait for idle.&n;&t; */
id|apic_wait_icr_idle
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * No need to touch the target chip field&n;&t; */
id|cfg
op_assign
id|__prepare_ICR
c_func
(paren
id|shortcut
comma
id|vector
comma
id|dest
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Send the IPI. The write to APIC_ICR fires this off.&n;&t; */
id|apic_write_around
c_func
(paren
id|APIC_ICR
comma
id|cfg
)paren
suffix:semicolon
)brace
DECL|function|send_IPI_mask_sequence
r_static
r_inline
r_void
id|send_IPI_mask_sequence
c_func
(paren
id|cpumask_t
id|mask
comma
r_int
id|vector
)paren
(brace
r_int
r_int
id|cfg
comma
id|flags
suffix:semicolon
r_int
r_int
id|query_cpu
suffix:semicolon
multiline_comment|/*&n;&t; * Hack. The clustered APIC addressing mode doesn&squot;t allow us to send&n;&t; * to an arbitrary mask, so I do a unicast to each CPU instead.&n;&t; * - mbligh&n;&t; */
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|query_cpu
op_assign
l_int|0
suffix:semicolon
id|query_cpu
OL
id|NR_CPUS
suffix:semicolon
op_increment
id|query_cpu
)paren
(brace
r_if
c_cond
(paren
id|cpu_isset
c_func
(paren
id|query_cpu
comma
id|mask
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Wait for idle.&n;&t;&t;&t; */
id|apic_wait_icr_idle
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * prepare target chip field&n;&t;&t;&t; */
id|cfg
op_assign
id|__prepare_ICR2
c_func
(paren
id|x86_cpu_to_apicid
(braket
id|query_cpu
)braket
)paren
suffix:semicolon
id|apic_write_around
c_func
(paren
id|APIC_ICR2
comma
id|cfg
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * program the ICR&n;&t;&t;&t; */
id|cfg
op_assign
id|__prepare_ICR
c_func
(paren
l_int|0
comma
id|vector
comma
id|APIC_DEST_PHYSICAL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Send the IPI. The write to APIC_ICR fires this off.&n;&t;&t;&t; */
id|apic_write_around
c_func
(paren
id|APIC_ICR
comma
id|cfg
)paren
suffix:semicolon
)brace
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif /* __ASM_IPI_H */
eof
