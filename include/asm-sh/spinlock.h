multiline_comment|/*&n; * include/asm-sh/spinlock.h&n; *&n; * Copyright (C) 2002, 2003 Paul Mundt&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; */
macro_line|#ifndef __ASM_SH_SPINLOCK_H
DECL|macro|__ASM_SH_SPINLOCK_H
mdefine_line|#define __ASM_SH_SPINLOCK_H
macro_line|#include &lt;asm/atomic.h&gt;
multiline_comment|/*&n; * Your basic SMP spinlocks, allowing only a single CPU anywhere&n; */
r_typedef
r_struct
(brace
DECL|member|lock
r_volatile
r_int
r_int
id|lock
suffix:semicolon
macro_line|#ifdef CONFIG_PREEMPT
DECL|member|break_lock
r_int
r_int
id|break_lock
suffix:semicolon
macro_line|#endif
DECL|typedef|spinlock_t
)brace
id|spinlock_t
suffix:semicolon
DECL|macro|SPIN_LOCK_UNLOCKED
mdefine_line|#define SPIN_LOCK_UNLOCKED&t;(spinlock_t) { 0 }
DECL|macro|spin_lock_init
mdefine_line|#define spin_lock_init(x)&t;do { *(x) = SPIN_LOCK_UNLOCKED; } while(0)
DECL|macro|spin_is_locked
mdefine_line|#define spin_is_locked(x)&t;((x)-&gt;lock != 0)
DECL|macro|spin_unlock_wait
mdefine_line|#define spin_unlock_wait(x)&t;do { barrier(); } while (spin_is_locked(x))
DECL|macro|_raw_spin_lock_flags
mdefine_line|#define _raw_spin_lock_flags(lock, flags) _raw_spin_lock(lock)
multiline_comment|/*&n; * Simple spin lock operations.  There are two variants, one clears IRQ&squot;s&n; * on the local processor, one does not.&n; *&n; * We make no fairness assumptions.  They have a cost.&n; */
DECL|function|_raw_spin_lock
r_static
r_inline
r_void
id|_raw_spin_lock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;1:&bslash;n&bslash;t&quot;
l_string|&quot;tas.b @%0&bslash;n&bslash;t&quot;
l_string|&quot;bf/s 1b&bslash;n&bslash;t&quot;
l_string|&quot;nop&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|lock-&gt;lock
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
op_amp
id|lock-&gt;lock
)paren
suffix:colon
l_string|&quot;t&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
DECL|function|_raw_spin_unlock
r_static
r_inline
r_void
id|_raw_spin_unlock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
macro_line|#ifdef CONFIG_DEBUG_SPINLOCK
id|BUG_ON
c_func
(paren
op_logical_neg
id|spin_is_locked
c_func
(paren
id|lock
)paren
)paren
suffix:semicolon
macro_line|#endif
id|lock-&gt;lock
op_assign
l_int|0
suffix:semicolon
)brace
DECL|macro|_raw_spin_trylock
mdefine_line|#define _raw_spin_trylock(x) (!test_and_set_bit(0, &amp;(x)-&gt;lock))
multiline_comment|/*&n; * Read-write spinlocks, allowing multiple readers but only one writer.&n; *&n; * NOTE! it is quite common to have readers in interrupts but no interrupt&n; * writers. For those circumstances we can &quot;mix&quot; irq-safe locks - any writer&n; * needs to get a irq-safe write-lock, but readers can get non-irqsafe&n; * read-locks.&n; */
r_typedef
r_struct
(brace
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|counter
id|atomic_t
id|counter
suffix:semicolon
macro_line|#ifdef CONFIG_PREEMPT
DECL|member|break_lock
r_int
r_int
id|break_lock
suffix:semicolon
macro_line|#endif
DECL|typedef|rwlock_t
)brace
id|rwlock_t
suffix:semicolon
DECL|macro|RW_LOCK_BIAS
mdefine_line|#define RW_LOCK_BIAS&t;&t;0x01000000
DECL|macro|RW_LOCK_UNLOCKED
mdefine_line|#define RW_LOCK_UNLOCKED&t;(rwlock_t) { { 0 }, { RW_LOCK_BIAS } }
DECL|macro|rwlock_init
mdefine_line|#define rwlock_init(x)&t;&t;do { *(x) = RW_LOCK_UNLOCKED; } while (0)
DECL|macro|rwlock_is_locked
mdefine_line|#define rwlock_is_locked(x)&t;(atomic_read(&amp;(x)-&gt;counter) != RW_LOCK_BIAS)
DECL|function|_raw_read_lock
r_static
r_inline
r_void
id|_raw_read_lock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
id|_raw_spin_lock
c_func
(paren
op_amp
id|rw-&gt;lock
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|rw-&gt;counter
)paren
suffix:semicolon
id|_raw_spin_unlock
c_func
(paren
op_amp
id|rw-&gt;lock
)paren
suffix:semicolon
)brace
DECL|function|_raw_read_unlock
r_static
r_inline
r_void
id|_raw_read_unlock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
id|_raw_spin_lock
c_func
(paren
op_amp
id|rw-&gt;lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|rw-&gt;counter
)paren
suffix:semicolon
id|_raw_spin_unlock
c_func
(paren
op_amp
id|rw-&gt;lock
)paren
suffix:semicolon
)brace
DECL|function|_raw_write_lock
r_static
r_inline
r_void
id|_raw_write_lock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
id|_raw_spin_lock
c_func
(paren
op_amp
id|rw-&gt;lock
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|rw-&gt;counter
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|_raw_write_unlock
r_static
r_inline
r_void
id|_raw_write_unlock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|rw-&gt;counter
comma
l_int|0
)paren
suffix:semicolon
id|_raw_spin_unlock
c_func
(paren
op_amp
id|rw-&gt;lock
)paren
suffix:semicolon
)brace
DECL|macro|_raw_read_trylock
mdefine_line|#define _raw_read_trylock(lock) generic_raw_read_trylock(lock)
DECL|function|_raw_write_trylock
r_static
r_inline
r_int
id|_raw_write_trylock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
r_if
c_cond
(paren
id|atomic_sub_and_test
c_func
(paren
id|RW_LOCK_BIAS
comma
op_amp
id|rw-&gt;counter
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|atomic_add
c_func
(paren
id|RW_LOCK_BIAS
comma
op_amp
id|rw-&gt;counter
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* __ASM_SH_SPINLOCK_H */
eof
