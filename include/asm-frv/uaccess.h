multiline_comment|/* uaccess.h: userspace accessor functions&n; *&n; * Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.&n; * Written by David Howells (dhowells@redhat.com)&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; */
macro_line|#ifndef _ASM_UACCESS_H
DECL|macro|_ASM_UACCESS_H
mdefine_line|#define _ASM_UACCESS_H
multiline_comment|/*&n; * User space memory access functions&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/sections.h&gt;
DECL|macro|HAVE_ARCH_UNMAPPED_AREA
mdefine_line|#define HAVE_ARCH_UNMAPPED_AREA&t;/* we decide where to put mmaps */
DECL|macro|__ptr
mdefine_line|#define __ptr(x) ((unsigned long *)(x))
DECL|macro|VERIFY_READ
mdefine_line|#define VERIFY_READ&t;0
DECL|macro|VERIFY_WRITE
mdefine_line|#define VERIFY_WRITE&t;1
DECL|macro|__addr_ok
mdefine_line|#define __addr_ok(addr) ((unsigned long)(addr) &lt; get_addr_limit())
multiline_comment|/*&n; * check that a range of addresses falls within the current address limit&n; */
DECL|function|___range_ok
r_static
r_inline
r_int
id|___range_ok
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|size
)paren
(brace
macro_line|#ifdef CONFIG_MMU
r_int
id|flag
op_assign
op_minus
id|EFAULT
comma
id|tmp
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;&t;addcc&t;%3,%2,%1,icc0&t;&bslash;n&quot;
multiline_comment|/* set C-flag if addr+size&gt;4GB */
l_string|&quot;&t;subcc.p&t;%1,%4,gr0,icc1&t;&bslash;n&quot;
multiline_comment|/* jump if addr+size&gt;limit */
l_string|&quot;&t;bc&t;icc0,#0,0f&t;&bslash;n&quot;
l_string|&quot;&t;bhi&t;icc1,#0,0f&t;&bslash;n&quot;
l_string|&quot;&t;setlos&t;#0,%0&t;&t;&bslash;n&quot;
multiline_comment|/* mark okay */
l_string|&quot;0:&t;&t;&t;&t;&bslash;n&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|flag
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|addr
)paren
comma
l_string|&quot;r&quot;
(paren
id|size
)paren
comma
l_string|&quot;r&quot;
(paren
id|get_addr_limit
c_func
(paren
)paren
)paren
comma
l_string|&quot;0&quot;
(paren
id|flag
)paren
)paren
suffix:semicolon
r_return
id|flag
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|addr
template_param
id|memory_end
op_logical_or
id|size
OG
id|memory_end
op_minus
id|memory_start
op_logical_or
id|addr
op_plus
id|size
OG
id|memory_end
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#endif
)brace
DECL|macro|__range_ok
mdefine_line|#define __range_ok(addr,size) ___range_ok((unsigned long) (addr), (unsigned long) (size))
DECL|macro|access_ok
mdefine_line|#define access_ok(type,addr,size) (__range_ok((addr), (size)) == 0)
DECL|macro|__access_ok
mdefine_line|#define __access_ok(addr,size) (__range_ok((addr), (size)) == 0)
DECL|function|verify_area
r_static
r_inline
r_int
id|verify_area
c_func
(paren
r_int
id|type
comma
r_const
r_void
op_star
id|addr
comma
r_int
r_int
id|size
)paren
(brace
r_return
id|__range_ok
c_func
(paren
id|addr
comma
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The exception table consists of pairs of addresses: the first is the&n; * address of an instruction that is allowed to fault, and the second is&n; * the address at which the program should continue.  No registers are&n; * modified, so it is entirely up to the continuation code to figure out&n; * what to do.&n; *&n; * All the routines below use bits of fixup code that are out of line&n; * with the main instruction path.  This means when everything is well,&n; * we don&squot;t even have to jump over them.  Further, they do not intrude&n; * on our cache or tlb entries.&n; */
DECL|struct|exception_table_entry
r_struct
id|exception_table_entry
(brace
DECL|member|insn
DECL|member|fixup
r_int
r_int
id|insn
comma
id|fixup
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Returns 0 if exception not found and fixup otherwise.  */
r_extern
r_int
r_int
id|search_exception_table
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * These are the main single-value transfer routines.  They automatically&n; * use the right size if we just have the right pointer type.&n; */
DECL|macro|__put_user
mdefine_line|#define __put_user(x, ptr)&t;&t;&t;&t;&t;&t;&bslash;&n;({&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;int __pu_err = 0;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;typeof(*(ptr)) __pu_val = (x);&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;switch (sizeof (*(ptr))) {&t;&t;&t;&t;&t;&bslash;&n;&t;case 1:&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;__put_user_asm(__pu_err, __pu_val, ptr, &quot;b&quot;, &quot;r&quot;);&t;&bslash;&n;&t;&t;break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;case 2:&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;__put_user_asm(__pu_err, __pu_val, ptr, &quot;h&quot;, &quot;r&quot;);&t;&bslash;&n;&t;&t;break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;case 4:&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;__put_user_asm(__pu_err, __pu_val, ptr, &quot;&quot;,  &quot;r&quot;);&t;&bslash;&n;&t;&t;break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;case 8:&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;__put_user_asm(__pu_err, __pu_val, ptr, &quot;d&quot;, &quot;e&quot;);&t;&bslash;&n;&t;&t;break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;default:&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;__pu_err = __put_user_bad();&t;&t;&t;&t;&bslash;&n;&t;&t;break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;__pu_err;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;})
DECL|macro|put_user
mdefine_line|#define put_user(x, ptr)&t;&t;&t;&bslash;&n;({&t;&t;&t;&t;&t;&t;&bslash;&n;&t;typeof(&amp;*ptr) _p = (ptr);&t;&t;&bslash;&n;&t;int _e;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;_e = __range_ok(_p, sizeof(*_p));&t;&bslash;&n;&t;if (_e == 0)&t;&t;&t;&t;&bslash;&n;&t;&t;_e = __put_user((x), _p);&t;&bslash;&n;&t;_e;&t;&t;&t;&t;&t;&bslash;&n;})
r_extern
r_int
id|__put_user_bad
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * Tell gcc we read from memory instead of writing: this is because&n; * we do not write to any memory gcc knows about, so there are no&n; * aliasing issues.&n; */
macro_line|#ifdef CONFIG_MMU
DECL|macro|__put_user_asm
mdefine_line|#define __put_user_asm(err,x,ptr,dsize,constraint)&t;&t;&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;asm volatile(&quot;1:&t;st&quot;dsize&quot;%I1&t;%2,%M1&t;&bslash;n&quot;&t;&t;&t;&t;&bslash;&n;&t;&t;     &quot;2:&t;&t;&t;&t;&bslash;n&quot;&t;&t;&t;&t;&bslash;&n;&t;&t;     &quot;.subsection 2&t;&t;&t;&bslash;n&quot;&t;&t;&t;&t;&bslash;&n;&t;&t;     &quot;3:&t;setlos&t;&t;%3,%0&t;&bslash;n&quot;&t;&t;&t;&t;&bslash;&n;&t;&t;     &quot;&t;&t;bra&t;&t;2b&t;&bslash;n&quot;&t;&t;&t;&t;&bslash;&n;&t;&t;     &quot;.previous&t;&t;&t;&t;&bslash;n&quot;&t;&t;&t;&t;&bslash;&n;&t;&t;     &quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&t;&t;&bslash;n&quot;&t;&t;&t;&t;&bslash;&n;&t;&t;     &quot;&t;&t;.balign&t;&t;8&t;&bslash;n&quot;&t;&t;&t;&t;&bslash;&n;&t;&t;     &quot;&t;&t;.long&t;&t;1b,3b&t;&bslash;n&quot;&t;&t;&t;&t;&bslash;&n;&t;&t;     &quot;.previous&quot;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;     : &quot;=r&quot; (err)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;     : &quot;m&quot; (*__ptr(ptr)), constraint (x), &quot;i&quot;(-EFAULT), &quot;0&quot;(err)&t;&bslash;&n;&t;&t;     : &quot;memory&quot;);&t;&t;&t;&t;&t;&t;&t;&bslash;&n;} while (0)
macro_line|#else
DECL|macro|__put_user_asm
mdefine_line|#define __put_user_asm(err,x,ptr,bwl,con)&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;asm(&quot;&t;st&quot;bwl&quot;%I0&t;%1,%M0&t;&bslash;n&quot;&t;&bslash;&n;&t;    &quot;&t;membar&t;&t;&t;&bslash;n&quot;&t;&bslash;&n;&t;    :&t;&t;&t;&t;&t;&bslash;&n;&t;    : &quot;m&quot; (*__ptr(ptr)), con (x)&t;&bslash;&n;&t;    : &quot;memory&quot;);&t;&t;&t;&bslash;&n;} while (0)
macro_line|#endif
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&n; */
DECL|macro|__get_user
mdefine_line|#define __get_user(x, ptr)&t;&t;&t;&t;&t;&t;&bslash;&n;({&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;typeof(*(ptr)) __gu_val = 0;&t;&t;&t;&t;&t;&bslash;&n;&t;int __gu_err = 0;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;switch (sizeof(*(ptr))) {&t;&t;&t;&t;&t;&bslash;&n;&t;case 1:&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;__get_user_asm(__gu_err, __gu_val, ptr, &quot;ub&quot;, &quot;=r&quot;);&t;&bslash;&n;&t;&t;break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;case 2:&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;__get_user_asm(__gu_err, __gu_val, ptr, &quot;uh&quot;, &quot;=r&quot;);&t;&bslash;&n;&t;&t;break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;case 4:&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;__get_user_asm(__gu_err, __gu_val, ptr, &quot;&quot;, &quot;=r&quot;);&t;&bslash;&n;&t;&t;break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;case 8:&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;__get_user_asm(__gu_err, __gu_val, ptr, &quot;d&quot;, &quot;=e&quot;);&t;&bslash;&n;&t;&t;break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;default:&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;__gu_err = __get_user_bad();&t;&t;&t;&t;&bslash;&n;&t;&t;break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;(x) = __gu_val;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;__gu_err;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;})
DECL|macro|get_user
mdefine_line|#define get_user(x, ptr)&t;&t;&t;&bslash;&n;({&t;&t;&t;&t;&t;&t;&bslash;&n;&t;typeof(&amp;*ptr) _p = (ptr);&t;&t;&bslash;&n;&t;int _e;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;_e = __range_ok(_p, sizeof(*_p));&t;&bslash;&n;&t;if (likely(_e == 0))&t;&t;&t;&bslash;&n;&t;&t;_e = __get_user((x), _p);&t;&bslash;&n;&t;else&t;&t;&t;&t;&t;&bslash;&n;&t;&t;(x) = (typeof(x)) 0;&t;&t;&bslash;&n;&t;_e;&t;&t;&t;&t;&t;&bslash;&n;})
r_extern
r_int
id|__get_user_bad
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MMU
DECL|macro|__get_user_asm
mdefine_line|#define __get_user_asm(err,x,ptr,dtype,constraint)&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;asm(&quot;1:&t;&t;ld&quot;dtype&quot;%I2&t;%M2,%1&t;&bslash;n&quot;&t;&bslash;&n;&t;    &quot;2:&t;&t;&t;&t;&t;&bslash;n&quot;&t;&bslash;&n;&t;    &quot;.subsection 2&t;&t;&t;&bslash;n&quot;&t;&bslash;&n;&t;    &quot;3:&t;&t;setlos&t;&t;%3,%0&t;&bslash;n&quot;&t;&bslash;&n;&t;    &quot;&t;&t;setlos&t;&t;#0,%1&t;&bslash;n&quot;&t;&bslash;&n;&t;    &quot;&t;&t;bra&t;&t;2b&t;&bslash;n&quot;&t;&bslash;&n;&t;    &quot;.previous&t;&t;&t;&t;&bslash;n&quot;&t;&bslash;&n;&t;    &quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&t;&t;&bslash;n&quot;&t;&bslash;&n;&t;    &quot;&t;&t;.balign&t;&t;8&t;&bslash;n&quot;&t;&bslash;&n;&t;    &quot;&t;&t;.long&t;&t;1b,3b&t;&bslash;n&quot;&t;&bslash;&n;&t;    &quot;.previous&quot;&t;&t;&t;&t;&t;&bslash;&n;&t;    : &quot;=r&quot; (err), constraint (x)&t;&t;&bslash;&n;&t;    : &quot;m&quot; (*__ptr(ptr)), &quot;i&quot;(-EFAULT), &quot;0&quot;(err)&t;&bslash;&n;&t;    );&t;&t;&t;&t;&t;&t;&bslash;&n;} while(0)
macro_line|#else
DECL|macro|__get_user_asm
mdefine_line|#define __get_user_asm(err,x,ptr,bwl,con)&t;&bslash;&n;&t;asm(&quot;&t;ld&quot;bwl&quot;%I1&t;%M1,%0&t;&bslash;n&quot;&t;&bslash;&n;&t;    &quot;&t;membar&t;&t;&t;&bslash;n&quot;&t;&bslash;&n;&t;    : con(x)&t;&t;&t;&t;&bslash;&n;&t;    : &quot;m&quot; (*__ptr(ptr)))
macro_line|#endif
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&n; */
macro_line|#ifdef CONFIG_MMU
r_extern
r_int
id|__memset_user
c_func
(paren
r_void
op_star
id|dst
comma
r_int
r_int
id|count
)paren
suffix:semicolon
r_extern
r_int
id|__memcpy_user
c_func
(paren
r_void
op_star
id|dst
comma
r_const
r_void
op_star
id|src
comma
r_int
r_int
id|count
)paren
suffix:semicolon
DECL|macro|clear_user
mdefine_line|#define clear_user(dst,count)&t;&t;&t;__memset_user((dst), (count))
DECL|macro|__copy_from_user_inatomic
mdefine_line|#define __copy_from_user_inatomic(to, from, n)&t;__memcpy_user((to), (from), (n))
DECL|macro|__copy_to_user_inatomic
mdefine_line|#define __copy_to_user_inatomic(to, from, n)&t;__memcpy_user((to), (from), (n))
macro_line|#else
DECL|macro|clear_user
mdefine_line|#define clear_user(dst,count)&t;&t;&t;(memset((dst), 0, (count)), 0)
DECL|macro|__copy_from_user_inatomic
mdefine_line|#define __copy_from_user_inatomic(to, from, n)&t;(memcpy((to), (from), (n)), 0)
DECL|macro|__copy_to_user_inatomic
mdefine_line|#define __copy_to_user_inatomic(to, from, n)&t;(memcpy((to), (from), (n)), 0)
macro_line|#endif
r_static
r_inline
r_int
r_int
id|__must_check
DECL|function|__copy_to_user
id|__copy_to_user
c_func
(paren
r_void
id|__user
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
r_int
id|n
)paren
(brace
id|might_sleep
c_func
(paren
)paren
suffix:semicolon
r_return
id|__copy_to_user_inatomic
c_func
(paren
id|to
comma
id|from
comma
id|n
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
r_int
DECL|function|__copy_from_user
id|__copy_from_user
c_func
(paren
r_void
op_star
id|to
comma
r_const
r_void
id|__user
op_star
id|from
comma
r_int
r_int
id|n
)paren
(brace
id|might_sleep
c_func
(paren
)paren
suffix:semicolon
r_return
id|__copy_from_user_inatomic
c_func
(paren
id|to
comma
id|from
comma
id|n
)paren
suffix:semicolon
)brace
DECL|function|copy_from_user
r_static
r_inline
r_int
id|copy_from_user
c_func
(paren
r_void
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
r_int
id|n
)paren
(brace
r_int
r_int
id|ret
op_assign
id|n
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|__access_ok
c_func
(paren
id|from
comma
id|n
)paren
)paren
)paren
id|ret
op_assign
id|__copy_from_user
c_func
(paren
id|to
comma
id|from
comma
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ret
op_ne
l_int|0
)paren
)paren
id|memset
c_func
(paren
id|to
op_plus
(paren
id|n
op_minus
id|ret
)paren
comma
l_int|0
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|copy_to_user
r_static
r_inline
r_int
id|copy_to_user
c_func
(paren
r_void
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
r_int
id|n
)paren
(brace
r_return
id|likely
c_func
(paren
id|__access_ok
c_func
(paren
id|to
comma
id|n
)paren
)paren
ques
c_cond
id|__copy_to_user
c_func
(paren
id|to
comma
id|from
comma
id|n
)paren
suffix:colon
id|n
suffix:semicolon
)brace
DECL|macro|copy_to_user_ret
mdefine_line|#define copy_to_user_ret(to,from,n,retval)&t;({ if (copy_to_user(to,from,n)) return retval; })
DECL|macro|copy_from_user_ret
mdefine_line|#define copy_from_user_ret(to,from,n,retval)&t;({ if (copy_from_user(to,from,n)) return retval; })
r_extern
r_int
id|strncpy_from_user
c_func
(paren
r_char
op_star
id|dst
comma
r_const
r_char
op_star
id|src
comma
r_int
id|count
)paren
suffix:semicolon
r_extern
r_int
id|strnlen_user
c_func
(paren
r_const
r_char
op_star
id|src
comma
r_int
id|count
)paren
suffix:semicolon
DECL|macro|strlen_user
mdefine_line|#define strlen_user(str) strnlen_user(str, 32767)
r_extern
r_int
r_int
id|search_exception_table
c_func
(paren
r_int
r_int
id|addr
)paren
suffix:semicolon
DECL|macro|copy_to_user_page
mdefine_line|#define copy_to_user_page(vma, page, vaddr, dst, src, len)&t;memcpy(dst, src, len)
DECL|macro|copy_from_user_page
mdefine_line|#define copy_from_user_page(vma, page, vaddr, dst, src, len)&t;memcpy(dst, src, len)
macro_line|#endif /* _ASM_UACCESS_H */
eof
