macro_line|#ifndef _ALPHA_SPINLOCK_H
DECL|macro|_ALPHA_SPINLOCK_H
mdefine_line|#define _ALPHA_SPINLOCK_H
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;asm/current.h&gt;
multiline_comment|/*&n; * Simple spin lock operations.  There are two variants, one clears IRQ&squot;s&n; * on the local processor, one does not.&n; *&n; * We make no fairness assumptions. They have a cost.&n; */
r_typedef
r_struct
(brace
DECL|member|lock
r_volatile
r_int
r_int
id|lock
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_SPINLOCK
DECL|member|on_cpu
r_int
id|on_cpu
suffix:semicolon
DECL|member|line_no
r_int
id|line_no
suffix:semicolon
DECL|member|previous
r_void
op_star
id|previous
suffix:semicolon
DECL|member|task
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
DECL|member|base_file
r_const
r_char
op_star
id|base_file
suffix:semicolon
macro_line|#endif
DECL|typedef|spinlock_t
)brace
id|spinlock_t
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_SPINLOCK
DECL|macro|SPIN_LOCK_UNLOCKED
mdefine_line|#define SPIN_LOCK_UNLOCKED&t;(spinlock_t){ 0, -1, 0, NULL, NULL, NULL }
macro_line|#else
DECL|macro|SPIN_LOCK_UNLOCKED
mdefine_line|#define SPIN_LOCK_UNLOCKED&t;(spinlock_t){ 0 }
macro_line|#endif
DECL|macro|spin_lock_init
mdefine_line|#define spin_lock_init(x)&t;do { *(x) = SPIN_LOCK_UNLOCKED; } while(0)
DECL|macro|spin_is_locked
mdefine_line|#define spin_is_locked(x)&t;((x)-&gt;lock != 0)
DECL|macro|spin_unlock_wait
mdefine_line|#define spin_unlock_wait(x)&t;do { barrier(); } while ((x)-&gt;lock)
macro_line|#ifdef CONFIG_DEBUG_SPINLOCK
r_extern
r_void
id|_raw_spin_unlock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
suffix:semicolon
r_extern
r_void
id|debug_spin_lock
c_func
(paren
id|spinlock_t
op_star
id|lock
comma
r_const
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|debug_spin_trylock
c_func
(paren
id|spinlock_t
op_star
id|lock
comma
r_const
r_char
op_star
comma
r_int
)paren
suffix:semicolon
DECL|macro|_raw_spin_lock
mdefine_line|#define _raw_spin_lock(LOCK) &bslash;&n;&t;debug_spin_lock(LOCK, __BASE_FILE__, __LINE__)
DECL|macro|_raw_spin_trylock
mdefine_line|#define _raw_spin_trylock(LOCK) &bslash;&n;&t;debug_spin_trylock(LOCK, __BASE_FILE__, __LINE__)
macro_line|#else
DECL|function|_raw_spin_unlock
r_static
r_inline
r_void
id|_raw_spin_unlock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
id|mb
c_func
(paren
)paren
suffix:semicolon
id|lock-&gt;lock
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|_raw_spin_lock
r_static
r_inline
r_void
id|_raw_spin_lock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
r_int
id|tmp
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldl_l&t;%0,%1&bslash;n&quot;
l_string|&quot;&t;bne&t;%0,2f&bslash;n&quot;
l_string|&quot;&t;lda&t;%0,1&bslash;n&quot;
l_string|&quot;&t;stl_c&t;%0,%1&bslash;n&quot;
l_string|&quot;&t;beq&t;%0,2f&bslash;n&quot;
l_string|&quot;&t;mb&bslash;n&quot;
l_string|&quot;.subsection 2&bslash;n&quot;
l_string|&quot;2:&t;ldl&t;%0,%1&bslash;n&quot;
l_string|&quot;&t;bne&t;%0,2b&bslash;n&quot;
l_string|&quot;&t;br&t;1b&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|tmp
)paren
comma
l_string|&quot;=m&quot;
(paren
id|lock-&gt;lock
)paren
suffix:colon
l_string|&quot;m&quot;
(paren
id|lock-&gt;lock
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
DECL|function|_raw_spin_trylock
r_static
r_inline
r_int
id|_raw_spin_trylock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
r_return
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|lock-&gt;lock
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_DEBUG_SPINLOCK */
DECL|macro|_raw_spin_lock_flags
mdefine_line|#define _raw_spin_lock_flags(lock, flags) _raw_spin_lock(lock)
multiline_comment|/***********************************************************/
r_typedef
r_struct
(brace
DECL|member|lock
r_volatile
r_int
r_int
id|lock
suffix:semicolon
DECL|typedef|rwlock_t
)brace
id|rwlock_t
suffix:semicolon
DECL|macro|RW_LOCK_UNLOCKED
mdefine_line|#define RW_LOCK_UNLOCKED&t;(rwlock_t){ 0 }
DECL|macro|rwlock_init
mdefine_line|#define rwlock_init(x)&t;&t;do { *(x) = RW_LOCK_UNLOCKED; } while(0)
DECL|function|read_can_lock
r_static
r_inline
r_int
id|read_can_lock
c_func
(paren
id|rwlock_t
op_star
id|lock
)paren
(brace
r_return
(paren
id|lock-&gt;lock
op_amp
l_int|1
)paren
op_eq
l_int|0
suffix:semicolon
)brace
DECL|function|write_can_lock
r_static
r_inline
r_int
id|write_can_lock
c_func
(paren
id|rwlock_t
op_star
id|lock
)paren
(brace
r_return
id|lock-&gt;lock
op_eq
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_DEBUG_RWLOCK
r_extern
r_void
id|_raw_write_lock
c_func
(paren
id|rwlock_t
op_star
id|lock
)paren
suffix:semicolon
r_extern
r_void
id|_raw_read_lock
c_func
(paren
id|rwlock_t
op_star
id|lock
)paren
suffix:semicolon
macro_line|#else
DECL|function|_raw_write_lock
r_static
r_inline
r_void
id|_raw_write_lock
c_func
(paren
id|rwlock_t
op_star
id|lock
)paren
(brace
r_int
id|regx
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldl_l&t;%1,%0&bslash;n&quot;
l_string|&quot;&t;bne&t;%1,6f&bslash;n&quot;
l_string|&quot;&t;lda&t;%1,1&bslash;n&quot;
l_string|&quot;&t;stl_c&t;%1,%0&bslash;n&quot;
l_string|&quot;&t;beq&t;%1,6f&bslash;n&quot;
l_string|&quot;&t;mb&bslash;n&quot;
l_string|&quot;.subsection 2&bslash;n&quot;
l_string|&quot;6:&t;ldl&t;%1,%0&bslash;n&quot;
l_string|&quot;&t;bne&t;%1,6b&bslash;n&quot;
l_string|&quot;&t;br&t;1b&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
op_star
id|lock
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|regx
)paren
suffix:colon
l_string|&quot;m&quot;
(paren
op_star
id|lock
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
DECL|function|_raw_read_lock
r_static
r_inline
r_void
id|_raw_read_lock
c_func
(paren
id|rwlock_t
op_star
id|lock
)paren
(brace
r_int
id|regx
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldl_l&t;%1,%0&bslash;n&quot;
l_string|&quot;&t;blbs&t;%1,6f&bslash;n&quot;
l_string|&quot;&t;subl&t;%1,2,%1&bslash;n&quot;
l_string|&quot;&t;stl_c&t;%1,%0&bslash;n&quot;
l_string|&quot;&t;beq&t;%1,6f&bslash;n&quot;
l_string|&quot;&t;mb&bslash;n&quot;
l_string|&quot;.subsection 2&bslash;n&quot;
l_string|&quot;6:&t;ldl&t;%1,%0&bslash;n&quot;
l_string|&quot;&t;blbs&t;%1,6b&bslash;n&quot;
l_string|&quot;&t;br&t;1b&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
op_star
id|lock
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|regx
)paren
suffix:colon
l_string|&quot;m&quot;
(paren
op_star
id|lock
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_DEBUG_RWLOCK */
DECL|function|_raw_read_trylock
r_static
r_inline
r_int
id|_raw_read_trylock
c_func
(paren
id|rwlock_t
op_star
id|lock
)paren
(brace
r_int
id|regx
suffix:semicolon
r_int
id|success
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldl_l&t;%1,%0&bslash;n&quot;
l_string|&quot;&t;lda&t;%2,0&bslash;n&quot;
l_string|&quot;&t;blbs&t;%1,2f&bslash;n&quot;
l_string|&quot;&t;subl&t;%1,2,%2&bslash;n&quot;
l_string|&quot;&t;stl_c&t;%2,%0&bslash;n&quot;
l_string|&quot;&t;beq&t;%2,6f&bslash;n&quot;
l_string|&quot;2:&t;mb&bslash;n&quot;
l_string|&quot;.subsection 2&bslash;n&quot;
l_string|&quot;6:&t;br&t;1b&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
op_star
id|lock
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|regx
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|success
)paren
suffix:colon
l_string|&quot;m&quot;
(paren
op_star
id|lock
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|success
suffix:semicolon
)brace
DECL|function|_raw_write_trylock
r_static
r_inline
r_int
id|_raw_write_trylock
c_func
(paren
id|rwlock_t
op_star
id|lock
)paren
(brace
r_int
id|regx
suffix:semicolon
r_int
id|success
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldl_l&t;%1,%0&bslash;n&quot;
l_string|&quot;&t;lda&t;%2,0&bslash;n&quot;
l_string|&quot;&t;bne&t;%1,2f&bslash;n&quot;
l_string|&quot;&t;lda&t;%2,1&bslash;n&quot;
l_string|&quot;&t;stl_c&t;%2,%0&bslash;n&quot;
l_string|&quot;&t;beq&t;%2,6f&bslash;n&quot;
l_string|&quot;2:&t;mb&bslash;n&quot;
l_string|&quot;.subsection 2&bslash;n&quot;
l_string|&quot;6:&t;br&t;1b&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
op_star
id|lock
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|regx
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|success
)paren
suffix:colon
l_string|&quot;m&quot;
(paren
op_star
id|lock
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|success
suffix:semicolon
)brace
DECL|function|_raw_write_unlock
r_static
r_inline
r_void
id|_raw_write_unlock
c_func
(paren
id|rwlock_t
op_star
id|lock
)paren
(brace
id|mb
c_func
(paren
)paren
suffix:semicolon
id|lock-&gt;lock
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|_raw_read_unlock
r_static
r_inline
r_void
id|_raw_read_unlock
c_func
(paren
id|rwlock_t
op_star
id|lock
)paren
(brace
r_int
id|regx
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;&t;mb&bslash;n&quot;
l_string|&quot;1:&t;ldl_l&t;%1,%0&bslash;n&quot;
l_string|&quot;&t;addl&t;%1,2,%1&bslash;n&quot;
l_string|&quot;&t;stl_c&t;%1,%0&bslash;n&quot;
l_string|&quot;&t;beq&t;%1,6f&bslash;n&quot;
l_string|&quot;.subsection 2&bslash;n&quot;
l_string|&quot;6:&t;br&t;1b&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
op_star
id|lock
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|regx
)paren
suffix:colon
l_string|&quot;m&quot;
(paren
op_star
id|lock
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* _ALPHA_SPINLOCK_H */
eof
