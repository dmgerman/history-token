multiline_comment|/*&n; * SMP- and interrupt-safe semaphores helper functions.&n; *&n; * Copyright (C) 1996 Linus Torvalds&n; * Copyright (C) 1999 Andrea Arcangeli&n; * Copyright (C) 1999, 2001, 2002 Ralf Baechle&n; * Copyright (C) 1999, 2001 Silicon Graphics, Inc.&n; * Copyright (C) 2000 MIPS Technologies, Inc.&n; */
macro_line|#ifndef _ASM_SEMAPHORE_HELPER_H
DECL|macro|_ASM_SEMAPHORE_HELPER_H
mdefine_line|#define _ASM_SEMAPHORE_HELPER_H
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
DECL|macro|sem_read
mdefine_line|#define sem_read(a) ((a)-&gt;counter)
DECL|macro|sem_inc
mdefine_line|#define sem_inc(a) (((a)-&gt;counter)++)
DECL|macro|sem_dec
mdefine_line|#define sem_dec(a) (((a)-&gt;counter)--)
multiline_comment|/*&n; * These two _must_ execute atomically wrt each other.&n; */
DECL|function|wake_one_more
r_static
r_inline
r_void
id|wake_one_more
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|sem-&gt;waking
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_CPU_HAS_LLSC
DECL|function|waking_non_zero
r_static
r_inline
r_int
id|waking_non_zero
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
id|ret
comma
id|tmp
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&bslash;tll&bslash;t%1, %2&bslash;t&bslash;t&bslash;t# waking_non_zero&bslash;n&bslash;t&quot;
l_string|&quot;blez&bslash;t%1, 2f&bslash;n&bslash;t&quot;
l_string|&quot;subu&bslash;t%0, %1, 1&bslash;n&bslash;t&quot;
l_string|&quot;sc&bslash;t%0, %2&bslash;n&bslash;t&quot;
l_string|&quot;beqz&bslash;t%0, 1b&bslash;n&quot;
l_string|&quot;2:&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ret
)paren
comma
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
comma
l_string|&quot;+m&quot;
(paren
id|sem-&gt;waking
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#else /* !CONFIG_CPU_HAS_LLSC */
multiline_comment|/*&n; * It doesn&squot;t make sense, IMHO, to endlessly turn interrupts off and on again.&n; * Do it once and that&squot;s it. ll/sc *has* it&squot;s advantages. HK&n; */
DECL|function|waking_non_zero
r_static
r_inline
r_int
id|waking_non_zero
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sem_read
c_func
(paren
op_amp
id|sem-&gt;waking
)paren
OG
l_int|0
)paren
(brace
id|sem_dec
c_func
(paren
op_amp
id|sem-&gt;waking
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif /* !CONFIG_CPU_HAS_LLSC */
macro_line|#ifdef CONFIG_CPU_HAS_LLDSCD
multiline_comment|/*&n; * waking_non_zero_interruptible:&n; *&t;1&t;got the lock&n; *&t;0&t;go to sleep&n; *&t;-EINTR&t;interrupted&n; *&n; * We must undo the sem-&gt;count down_interruptible decrement&n; * simultaneously and atomically with the sem-&gt;waking adjustment,&n; * otherwise we can race with wake_one_more.&n; *&n; * This is accomplished by doing a 64-bit lld/scd on the 2 32-bit words.&n; *&n; * This is crazy.  Normally it&squot;s strictly forbidden to use 64-bit operations&n; * in the 32-bit MIPS kernel.  In this case it&squot;s however ok because if an&n; * interrupt has destroyed the upper half of registers sc will fail.&n; * Note also that this will not work for MIPS32 CPUs!&n; *&n; * Pseudocode:&n; *&n; * If(sem-&gt;waking &gt; 0) {&n; *&t;Decrement(sem-&gt;waking)&n; *&t;Return(SUCCESS)&n; * } else If(signal_pending(tsk)) {&n; *&t;Increment(sem-&gt;count)&n; *&t;Return(-EINTR)&n; * } else {&n; *&t;Return(SLEEP)&n; * }&n; */
r_static
r_inline
r_int
DECL|function|waking_non_zero_interruptible
id|waking_non_zero_interruptible
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
comma
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_int
id|ret
comma
id|tmp
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;.set&bslash;tpush&bslash;t&bslash;t&bslash;t# waking_non_zero_interruptible&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tmips3&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tnoat&bslash;n&quot;
l_string|&quot;0:&bslash;tlld&bslash;t%1, %2&bslash;n&bslash;t&quot;
l_string|&quot;li&bslash;t%0, 0&bslash;n&bslash;t&quot;
l_string|&quot;sll&bslash;t$1, %1, 0&bslash;n&bslash;t&quot;
l_string|&quot;blez&bslash;t$1, 1f&bslash;n&bslash;t&quot;
l_string|&quot;daddiu&bslash;t%1, %1, -1&bslash;n&bslash;t&quot;
l_string|&quot;li&bslash;t%0, 1&bslash;n&bslash;t&quot;
l_string|&quot;b&bslash;t2f&bslash;n&quot;
l_string|&quot;1:&bslash;tbeqz&bslash;t%3, 2f&bslash;n&bslash;t&quot;
l_string|&quot;li&bslash;t%0, %4&bslash;n&bslash;t&quot;
l_string|&quot;dli&bslash;t$1, 0x0000000100000000&bslash;n&bslash;t&quot;
l_string|&quot;daddu&bslash;t%1, %1, $1&bslash;n&quot;
l_string|&quot;2:&bslash;tscd&bslash;t%1, %2&bslash;n&bslash;t&quot;
l_string|&quot;beqz&bslash;t%1, 0b&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tpop&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|ret
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp
)paren
comma
l_string|&quot;=m&quot;
(paren
op_star
id|sem
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|signal_pending
c_func
(paren
id|tsk
)paren
)paren
comma
l_string|&quot;i&quot;
(paren
op_minus
id|EINTR
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * waking_non_zero_trylock is unused.  we do everything in&n; * down_trylock and let non-ll/sc hosts bounce around.&n; */
DECL|function|waking_non_zero_trylock
r_static
r_inline
r_int
id|waking_non_zero_trylock
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
macro_line|#if WAITQUEUE_DEBUG
id|CHECK_MAGIC
c_func
(paren
id|sem-&gt;__magic
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#else /* !CONFIG_CPU_HAS_LLDSCD */
DECL|function|waking_non_zero_interruptible
r_static
r_inline
r_int
id|waking_non_zero_interruptible
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
comma
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sem_read
c_func
(paren
op_amp
id|sem-&gt;waking
)paren
OG
l_int|0
)paren
(brace
id|sem_dec
c_func
(paren
op_amp
id|sem-&gt;waking
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|tsk
)paren
)paren
(brace
id|sem_inc
c_func
(paren
op_amp
id|sem-&gt;count
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINTR
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|waking_non_zero_trylock
r_static
r_inline
r_int
id|waking_non_zero_trylock
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sem_read
c_func
(paren
op_amp
id|sem-&gt;waking
)paren
op_le
l_int|0
)paren
id|sem_inc
c_func
(paren
op_amp
id|sem-&gt;count
)paren
suffix:semicolon
r_else
(brace
id|sem_dec
c_func
(paren
op_amp
id|sem-&gt;waking
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif /* !CONFIG_CPU_HAS_LLDSCD */
macro_line|#endif /* _ASM_SEMAPHORE_HELPER_H */
eof
