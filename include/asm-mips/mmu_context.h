multiline_comment|/*&n; * Switch a MMU context.&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1996, 1997, 1998, 1999 by Ralf Baechle&n; * Copyright (C) 1999 Silicon Graphics, Inc.&n; */
macro_line|#ifndef _ASM_MMU_CONTEXT_H
DECL|macro|_ASM_MMU_CONTEXT_H
mdefine_line|#define _ASM_MMU_CONTEXT_H
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/cacheflush.h&gt;
macro_line|#include &lt;asm/tlbflush.h&gt;
multiline_comment|/*&n; * For the fast tlb miss handlers, we currently keep a per cpu array&n; * of pointers to the current pgd for each processor. Also, the proc.&n; * id is stuffed into the context register. This should be changed to&n; * use the processor id via current-&gt;processor, where current is stored&n; * in watchhi/lo. The context register should be used to contiguously&n; * map the page tables.&n; */
DECL|macro|TLBMISS_HANDLER_SETUP_PGD
mdefine_line|#define TLBMISS_HANDLER_SETUP_PGD(pgd) &bslash;&n;&t;pgd_current[smp_processor_id()] = (unsigned long)(pgd)
macro_line|#ifdef CONFIG_MIPS32
DECL|macro|TLBMISS_HANDLER_SETUP
mdefine_line|#define TLBMISS_HANDLER_SETUP() &bslash;&n;&t;write_c0_context((unsigned long) smp_processor_id() &lt;&lt; 23); &bslash;&n;&t;TLBMISS_HANDLER_SETUP_PGD(swapper_pg_dir)
macro_line|#endif
macro_line|#ifdef CONFIG_MIPS64
DECL|macro|TLBMISS_HANDLER_SETUP
mdefine_line|#define TLBMISS_HANDLER_SETUP() &bslash;&n;&t;write_c0_context((unsigned long) &amp;pgd_current[smp_processor_id()] &lt;&lt; 23); &bslash;&n;&t;TLBMISS_HANDLER_SETUP_PGD(swapper_pg_dir)
macro_line|#endif
r_extern
r_int
r_int
id|pgd_current
(braket
)braket
suffix:semicolon
macro_line|#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
DECL|macro|ASID_INC
mdefine_line|#define ASID_INC&t;0x40
DECL|macro|ASID_MASK
mdefine_line|#define ASID_MASK&t;0xfc0
macro_line|#elif defined(CONFIG_CPU_R8000)
DECL|macro|ASID_INC
mdefine_line|#define ASID_INC&t;0x10
DECL|macro|ASID_MASK
mdefine_line|#define ASID_MASK&t;0xff0
macro_line|#elif defined(CONFIG_CPU_RM9000)
DECL|macro|ASID_INC
mdefine_line|#define ASID_INC&t;0x1
DECL|macro|ASID_MASK
mdefine_line|#define ASID_MASK&t;0xfff
macro_line|#else /* FIXME: not correct for R6000 */
DECL|macro|ASID_INC
mdefine_line|#define ASID_INC&t;0x1
DECL|macro|ASID_MASK
mdefine_line|#define ASID_MASK&t;0xff
macro_line|#endif
DECL|macro|cpu_context
mdefine_line|#define cpu_context(cpu, mm)&t;((mm)-&gt;context[cpu])
DECL|macro|cpu_asid
mdefine_line|#define cpu_asid(cpu, mm)&t;(cpu_context((cpu), (mm)) &amp; ASID_MASK)
DECL|macro|asid_cache
mdefine_line|#define asid_cache(cpu)&t;&t;(cpu_data[cpu].asid_cache)
DECL|function|enter_lazy_tlb
r_static
r_inline
r_void
id|enter_lazy_tlb
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
)brace
multiline_comment|/*&n; *  All unused by hardware upper bits will be considered&n; *  as a software asid extension.&n; */
DECL|macro|ASID_VERSION_MASK
mdefine_line|#define ASID_VERSION_MASK  ((unsigned long)~(ASID_MASK|(ASID_MASK-1)))
DECL|macro|ASID_FIRST_VERSION
mdefine_line|#define ASID_FIRST_VERSION ((unsigned long)(~ASID_VERSION_MASK) + 1)
r_static
r_inline
r_void
DECL|function|get_new_mmu_context
id|get_new_mmu_context
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|cpu
)paren
(brace
r_int
r_int
id|asid
op_assign
id|asid_cache
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|asid
op_add_assign
id|ASID_INC
)paren
op_amp
id|ASID_MASK
)paren
)paren
(brace
r_if
c_cond
(paren
id|cpu_has_vtag_icache
)paren
id|flush_icache_all
c_func
(paren
)paren
suffix:semicolon
id|local_flush_tlb_all
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* start new asid cycle */
r_if
c_cond
(paren
op_logical_neg
id|asid
)paren
multiline_comment|/* fix version if needed */
id|asid
op_assign
id|ASID_FIRST_VERSION
suffix:semicolon
)brace
id|cpu_context
c_func
(paren
id|cpu
comma
id|mm
)paren
op_assign
id|asid_cache
c_func
(paren
id|cpu
)paren
op_assign
id|asid
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize the context related info for a new mm_struct&n; * instance.&n; */
r_static
r_inline
r_int
DECL|function|init_new_context
id|init_new_context
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_online_cpus
c_func
(paren
)paren
suffix:semicolon
id|i
op_increment
)paren
id|cpu_context
c_func
(paren
id|i
comma
id|mm
)paren
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|switch_mm
r_static
r_inline
r_void
id|switch_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|prev
comma
r_struct
id|mm_struct
op_star
id|next
comma
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_int
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Check if our ASID is of an older version and thus invalid */
r_if
c_cond
(paren
(paren
id|cpu_context
c_func
(paren
id|cpu
comma
id|next
)paren
op_xor
id|asid_cache
c_func
(paren
id|cpu
)paren
)paren
op_amp
id|ASID_VERSION_MASK
)paren
id|get_new_mmu_context
c_func
(paren
id|next
comma
id|cpu
)paren
suffix:semicolon
id|write_c0_entryhi
c_func
(paren
id|cpu_context
c_func
(paren
id|cpu
comma
id|next
)paren
)paren
suffix:semicolon
id|TLBMISS_HANDLER_SETUP_PGD
c_func
(paren
id|next-&gt;pgd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mark current-&gt;active_mm as not &quot;active&quot; anymore.&n;&t; * We don&squot;t want to mislead possible IPI tlb flush routines.&n;&t; */
id|cpu_clear
c_func
(paren
id|cpu
comma
id|prev-&gt;cpu_vm_mask
)paren
suffix:semicolon
id|cpu_set
c_func
(paren
id|cpu
comma
id|next-&gt;cpu_vm_mask
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Destroy context related info for an mm_struct that is about&n; * to be put to rest.&n; */
DECL|function|destroy_context
r_static
r_inline
r_void
id|destroy_context
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
)brace
DECL|macro|deactivate_mm
mdefine_line|#define deactivate_mm(tsk,mm)&t;do { } while (0)
multiline_comment|/*&n; * After we have set current-&gt;mm to a new value, this activates&n; * the context for the new mm so we see the new mappings.&n; */
r_static
r_inline
r_void
DECL|function|activate_mm
id|activate_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|prev
comma
r_struct
id|mm_struct
op_star
id|next
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Unconditionally get a new ASID.  */
id|get_new_mmu_context
c_func
(paren
id|next
comma
id|cpu
)paren
suffix:semicolon
id|write_c0_entryhi
c_func
(paren
id|cpu_context
c_func
(paren
id|cpu
comma
id|next
)paren
)paren
suffix:semicolon
id|TLBMISS_HANDLER_SETUP_PGD
c_func
(paren
id|next-&gt;pgd
)paren
suffix:semicolon
multiline_comment|/* mark mmu ownership change */
id|cpu_clear
c_func
(paren
id|cpu
comma
id|prev-&gt;cpu_vm_mask
)paren
suffix:semicolon
id|cpu_set
c_func
(paren
id|cpu
comma
id|next-&gt;cpu_vm_mask
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * If mm is currently active_mm, we can&squot;t really drop it.  Instead,&n; * we will get a new one for it.&n; */
r_static
r_inline
r_void
DECL|function|drop_mmu_context
id|drop_mmu_context
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
id|cpu
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu_isset
c_func
(paren
id|cpu
comma
id|mm-&gt;cpu_vm_mask
)paren
)paren
(brace
id|get_new_mmu_context
c_func
(paren
id|mm
comma
id|cpu
)paren
suffix:semicolon
id|write_c0_entryhi
c_func
(paren
id|cpu_asid
c_func
(paren
id|cpu
comma
id|mm
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* will get a new context next time */
id|cpu_context
c_func
(paren
id|cpu
comma
id|mm
)paren
op_assign
l_int|0
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif /* _ASM_MMU_CONTEXT_H */
eof
