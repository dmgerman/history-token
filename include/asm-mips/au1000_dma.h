multiline_comment|/*&n; * BRIEF MODULE DESCRIPTION&n; *&t;Defines for using and allocating dma channels on the Alchemy&n; *      Au1000 mips processor.&n; *&n; * Copyright 2000 MontaVista Software Inc.&n; * Author: MontaVista Software, Inc.&n; *         &t;stevel@mvista.com or source@mvista.com&n; *&n; *  This program is free software; you can redistribute  it and/or modify it&n; *  under  the terms of  the GNU General  Public License as published by the&n; *  Free Software Foundation;  either version 2 of the  License, or (at your&n; *  option) any later version.&n; *&n; *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS&squot;&squot; AND   ANY  EXPRESS OR IMPLIED&n; *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF&n; *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN&n; *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,&n; *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT&n; *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF&n; *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON&n; *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT&n; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF&n; *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; *&n; *  You should have received a copy of the  GNU General Public License along&n; *  with this program; if not, write  to the Free Software Foundation, Inc.,&n; *  675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; */
macro_line|#ifndef __ASM_AU1000_DMA_H
DECL|macro|__ASM_AU1000_DMA_H
mdefine_line|#define __ASM_AU1000_DMA_H
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;asm/io.h&gt;&t;&t;/* need byte IO */
macro_line|#include &lt;linux/spinlock.h&gt;&t;/* And spinlocks */
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/system.h&gt;
DECL|macro|NUM_AU1000_DMA_CHANNELS
mdefine_line|#define NUM_AU1000_DMA_CHANNELS&t;8
multiline_comment|/* DMA Channel Base Addresses */
DECL|macro|DMA_CHANNEL_BASE
mdefine_line|#define DMA_CHANNEL_BASE&t;0xB4002000
DECL|macro|DMA_CHANNEL_LEN
mdefine_line|#define DMA_CHANNEL_LEN&t;&t;0x00000100
multiline_comment|/* DMA Channel Register Offsets */
DECL|macro|DMA_MODE_SET
mdefine_line|#define DMA_MODE_SET&t;&t;0x00000000
DECL|macro|DMA_MODE_READ
mdefine_line|#define DMA_MODE_READ&t;&t;DMA_MODE_SET
DECL|macro|DMA_MODE_CLEAR
mdefine_line|#define DMA_MODE_CLEAR&t;&t;0x00000004
multiline_comment|/* DMA Mode register bits follow */
DECL|macro|DMA_DAH_MASK
mdefine_line|#define DMA_DAH_MASK&t;&t;(0x0f &lt;&lt; 20)
DECL|macro|DMA_DID_BIT
mdefine_line|#define DMA_DID_BIT&t;&t;16
DECL|macro|DMA_DID_MASK
mdefine_line|#define DMA_DID_MASK&t;&t;(0x0f &lt;&lt; DMA_DID_BIT)
DECL|macro|DMA_BE
mdefine_line|#define DMA_BE&t;&t;&t;(1&lt;&lt;13)
DECL|macro|DMA_DR
mdefine_line|#define DMA_DR&t;&t;&t;(1&lt;&lt;12)
DECL|macro|DMA_TS8
mdefine_line|#define DMA_TS8&t;&t;&t;(1&lt;&lt;11)
DECL|macro|DMA_DW_BIT
mdefine_line|#define DMA_DW_BIT&t;&t;9
DECL|macro|DMA_DW_MASK
mdefine_line|#define DMA_DW_MASK&t;&t;(0x03 &lt;&lt; DMA_DW_BIT)
DECL|macro|DMA_DW8
mdefine_line|#define DMA_DW8&t;&t;&t;(0 &lt;&lt; DMA_DW_BIT)
DECL|macro|DMA_DW16
mdefine_line|#define DMA_DW16&t;&t;(1 &lt;&lt; DMA_DW_BIT)
DECL|macro|DMA_DW32
mdefine_line|#define DMA_DW32&t;&t;(2 &lt;&lt; DMA_DW_BIT)
DECL|macro|DMA_NC
mdefine_line|#define DMA_NC&t;&t;&t;(1&lt;&lt;8)
DECL|macro|DMA_IE
mdefine_line|#define DMA_IE&t;&t;&t;(1&lt;&lt;7)
DECL|macro|DMA_HALT
mdefine_line|#define DMA_HALT&t;&t;(1&lt;&lt;6)
DECL|macro|DMA_GO
mdefine_line|#define DMA_GO&t;&t;&t;(1&lt;&lt;5)
DECL|macro|DMA_AB
mdefine_line|#define DMA_AB&t;&t;&t;(1&lt;&lt;4)
DECL|macro|DMA_D1
mdefine_line|#define DMA_D1&t;&t;&t;(1&lt;&lt;3)
DECL|macro|DMA_BE1
mdefine_line|#define DMA_BE1&t;&t;&t;(1&lt;&lt;2)
DECL|macro|DMA_D0
mdefine_line|#define DMA_D0&t;&t;&t;(1&lt;&lt;1)
DECL|macro|DMA_BE0
mdefine_line|#define DMA_BE0&t;&t;&t;(1&lt;&lt;0)
DECL|macro|DMA_PERIPHERAL_ADDR
mdefine_line|#define DMA_PERIPHERAL_ADDR       0x00000008
DECL|macro|DMA_BUFFER0_START
mdefine_line|#define DMA_BUFFER0_START         0x0000000C
DECL|macro|DMA_BUFFER1_START
mdefine_line|#define DMA_BUFFER1_START         0x00000014
DECL|macro|DMA_BUFFER0_COUNT
mdefine_line|#define DMA_BUFFER0_COUNT         0x00000010
DECL|macro|DMA_BUFFER1_COUNT
mdefine_line|#define DMA_BUFFER1_COUNT         0x00000018
DECL|macro|DMA_BAH_BIT
mdefine_line|#define DMA_BAH_BIT 16
DECL|macro|DMA_BAH_MASK
mdefine_line|#define DMA_BAH_MASK (0x0f &lt;&lt; DMA_BAH_BIT)
DECL|macro|DMA_COUNT_BIT
mdefine_line|#define DMA_COUNT_BIT 0
DECL|macro|DMA_COUNT_MASK
mdefine_line|#define DMA_COUNT_MASK (0xffff &lt;&lt; DMA_COUNT_BIT)
multiline_comment|/* DMA Device ID&squot;s follow */
r_enum
(brace
DECL|enumerator|DMA_ID_UART0_TX
id|DMA_ID_UART0_TX
op_assign
l_int|0
comma
DECL|enumerator|DMA_ID_UART0_RX
id|DMA_ID_UART0_RX
comma
DECL|enumerator|DMA_ID_GP04
id|DMA_ID_GP04
comma
DECL|enumerator|DMA_ID_GP05
id|DMA_ID_GP05
comma
DECL|enumerator|DMA_ID_AC97C_TX
id|DMA_ID_AC97C_TX
comma
DECL|enumerator|DMA_ID_AC97C_RX
id|DMA_ID_AC97C_RX
comma
DECL|enumerator|DMA_ID_UART3_TX
id|DMA_ID_UART3_TX
comma
DECL|enumerator|DMA_ID_UART3_RX
id|DMA_ID_UART3_RX
comma
DECL|enumerator|DMA_ID_USBDEV_EP0_RX
id|DMA_ID_USBDEV_EP0_RX
comma
DECL|enumerator|DMA_ID_USBDEV_EP0_TX
id|DMA_ID_USBDEV_EP0_TX
comma
DECL|enumerator|DMA_ID_USBDEV_EP2_TX
id|DMA_ID_USBDEV_EP2_TX
comma
DECL|enumerator|DMA_ID_USBDEV_EP3_TX
id|DMA_ID_USBDEV_EP3_TX
comma
DECL|enumerator|DMA_ID_USBDEV_EP4_RX
id|DMA_ID_USBDEV_EP4_RX
comma
DECL|enumerator|DMA_ID_USBDEV_EP5_RX
id|DMA_ID_USBDEV_EP5_RX
comma
DECL|enumerator|DMA_ID_I2S_TX
id|DMA_ID_I2S_TX
comma
DECL|enumerator|DMA_ID_I2S_RX
id|DMA_ID_I2S_RX
comma
DECL|enumerator|DMA_NUM_DEV
id|DMA_NUM_DEV
)brace
suffix:semicolon
DECL|struct|dma_chan
r_struct
id|dma_chan
(brace
DECL|member|dev_id
r_int
id|dev_id
suffix:semicolon
singleline_comment|// this channel is allocated if &gt;=0, free otherwise
DECL|member|io
r_int
r_int
id|io
suffix:semicolon
DECL|member|dev_str
r_const
r_char
op_star
id|dev_str
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
DECL|member|irq_dev
r_void
op_star
id|irq_dev
suffix:semicolon
DECL|member|fifo_addr
r_int
r_int
id|fifo_addr
suffix:semicolon
DECL|member|mode
r_int
r_int
id|mode
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* These are in arch/mips/au1000/common/dma.c */
r_extern
r_struct
id|dma_chan
id|au1000_dma_table
(braket
)braket
suffix:semicolon
r_extern
r_int
id|request_au1000_dma
c_func
(paren
r_int
id|dev_id
comma
r_const
r_char
op_star
id|dev_str
comma
r_void
(paren
op_star
id|irqhandler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
id|irqflags
comma
r_void
op_star
id|irq_dev_id
)paren
suffix:semicolon
r_extern
r_void
id|free_au1000_dma
c_func
(paren
r_int
r_int
id|dmanr
)paren
suffix:semicolon
r_extern
r_int
id|au1000_dma_read_proc
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|fpos
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
suffix:semicolon
r_extern
r_void
id|dump_au1000_dma_channel
c_func
(paren
r_int
r_int
id|dmanr
)paren
suffix:semicolon
r_extern
id|spinlock_t
id|au1000_dma_spin_lock
suffix:semicolon
DECL|function|get_dma_chan
r_static
id|__inline__
r_struct
id|dma_chan
op_star
id|get_dma_chan
c_func
(paren
r_int
r_int
id|dmanr
)paren
(brace
r_if
c_cond
(paren
id|dmanr
OG
id|NUM_AU1000_DMA_CHANNELS
op_logical_or
id|au1000_dma_table
(braket
id|dmanr
)braket
dot
id|dev_id
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
op_amp
id|au1000_dma_table
(braket
id|dmanr
)braket
suffix:semicolon
)brace
DECL|function|claim_dma_lock
r_static
id|__inline__
r_int
r_int
id|claim_dma_lock
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|au1000_dma_spin_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|flags
suffix:semicolon
)brace
DECL|function|release_dma_lock
r_static
id|__inline__
r_void
id|release_dma_lock
c_func
(paren
r_int
r_int
id|flags
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|au1000_dma_spin_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the DMA buffer enable bits in the mode register.&n; */
DECL|function|enable_dma_buffer0
r_static
id|__inline__
r_void
id|enable_dma_buffer0
c_func
(paren
r_int
r_int
id|dmanr
)paren
(brace
r_struct
id|dma_chan
op_star
id|chan
op_assign
id|get_dma_chan
c_func
(paren
id|dmanr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan
)paren
r_return
suffix:semicolon
id|au_writel
c_func
(paren
id|DMA_BE0
comma
id|chan-&gt;io
op_plus
id|DMA_MODE_SET
)paren
suffix:semicolon
)brace
DECL|function|enable_dma_buffer1
r_static
id|__inline__
r_void
id|enable_dma_buffer1
c_func
(paren
r_int
r_int
id|dmanr
)paren
(brace
r_struct
id|dma_chan
op_star
id|chan
op_assign
id|get_dma_chan
c_func
(paren
id|dmanr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan
)paren
r_return
suffix:semicolon
id|au_writel
c_func
(paren
id|DMA_BE1
comma
id|chan-&gt;io
op_plus
id|DMA_MODE_SET
)paren
suffix:semicolon
)brace
DECL|function|enable_dma_buffers
r_static
id|__inline__
r_void
id|enable_dma_buffers
c_func
(paren
r_int
r_int
id|dmanr
)paren
(brace
r_struct
id|dma_chan
op_star
id|chan
op_assign
id|get_dma_chan
c_func
(paren
id|dmanr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan
)paren
r_return
suffix:semicolon
id|au_writel
c_func
(paren
id|DMA_BE0
op_or
id|DMA_BE1
comma
id|chan-&gt;io
op_plus
id|DMA_MODE_SET
)paren
suffix:semicolon
)brace
DECL|function|start_dma
r_static
id|__inline__
r_void
id|start_dma
c_func
(paren
r_int
r_int
id|dmanr
)paren
(brace
r_struct
id|dma_chan
op_star
id|chan
op_assign
id|get_dma_chan
c_func
(paren
id|dmanr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan
)paren
r_return
suffix:semicolon
id|au_writel
c_func
(paren
id|DMA_GO
comma
id|chan-&gt;io
op_plus
id|DMA_MODE_SET
)paren
suffix:semicolon
)brace
DECL|macro|DMA_HALT_POLL
mdefine_line|#define DMA_HALT_POLL 0x5000
DECL|function|halt_dma
r_static
id|__inline__
r_void
id|halt_dma
c_func
(paren
r_int
r_int
id|dmanr
)paren
(brace
r_struct
id|dma_chan
op_star
id|chan
op_assign
id|get_dma_chan
c_func
(paren
id|dmanr
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan
)paren
r_return
suffix:semicolon
id|au_writel
c_func
(paren
id|DMA_GO
comma
id|chan-&gt;io
op_plus
id|DMA_MODE_CLEAR
)paren
suffix:semicolon
singleline_comment|// poll the halt bit
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DMA_HALT_POLL
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|au_readl
c_func
(paren
id|chan-&gt;io
op_plus
id|DMA_MODE_READ
)paren
op_amp
id|DMA_HALT
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|DMA_HALT_POLL
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;halt_dma: HALT poll expired!&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|disable_dma
r_static
id|__inline__
r_void
id|disable_dma
c_func
(paren
r_int
r_int
id|dmanr
)paren
(brace
r_struct
id|dma_chan
op_star
id|chan
op_assign
id|get_dma_chan
c_func
(paren
id|dmanr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan
)paren
r_return
suffix:semicolon
id|halt_dma
c_func
(paren
id|dmanr
)paren
suffix:semicolon
singleline_comment|// now we can disable the buffers
id|au_writel
c_func
(paren
op_complement
id|DMA_GO
comma
id|chan-&gt;io
op_plus
id|DMA_MODE_CLEAR
)paren
suffix:semicolon
)brace
DECL|function|dma_halted
r_static
id|__inline__
r_int
id|dma_halted
c_func
(paren
r_int
r_int
id|dmanr
)paren
(brace
r_struct
id|dma_chan
op_star
id|chan
op_assign
id|get_dma_chan
c_func
(paren
id|dmanr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan
)paren
r_return
l_int|1
suffix:semicolon
r_return
(paren
id|au_readl
c_func
(paren
id|chan-&gt;io
op_plus
id|DMA_MODE_READ
)paren
op_amp
id|DMA_HALT
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/* initialize a DMA channel */
DECL|function|init_dma
r_static
id|__inline__
r_void
id|init_dma
c_func
(paren
r_int
r_int
id|dmanr
)paren
(brace
r_struct
id|dma_chan
op_star
id|chan
op_assign
id|get_dma_chan
c_func
(paren
id|dmanr
)paren
suffix:semicolon
id|u32
id|mode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan
)paren
r_return
suffix:semicolon
id|disable_dma
c_func
(paren
id|dmanr
)paren
suffix:semicolon
singleline_comment|// set device FIFO address
id|au_writel
c_func
(paren
id|PHYSADDR
c_func
(paren
id|chan-&gt;fifo_addr
)paren
comma
id|chan-&gt;io
op_plus
id|DMA_PERIPHERAL_ADDR
)paren
suffix:semicolon
id|mode
op_assign
id|chan-&gt;mode
op_or
(paren
id|chan-&gt;dev_id
op_lshift
id|DMA_DID_BIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;irq
)paren
id|mode
op_or_assign
id|DMA_IE
suffix:semicolon
id|au_writel
c_func
(paren
op_complement
id|mode
comma
id|chan-&gt;io
op_plus
id|DMA_MODE_CLEAR
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|mode
comma
id|chan-&gt;io
op_plus
id|DMA_MODE_SET
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * set mode for a specific DMA channel&n; */
DECL|function|set_dma_mode
r_static
id|__inline__
r_void
id|set_dma_mode
c_func
(paren
r_int
r_int
id|dmanr
comma
r_int
r_int
id|mode
)paren
(brace
r_struct
id|dma_chan
op_star
id|chan
op_assign
id|get_dma_chan
c_func
(paren
id|dmanr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * set_dma_mode is only allowed to change endianess, direction,&n;&t; * transfer size, device FIFO width, and coherency settings.&n;&t; * Make sure anything else is masked off.&n;&t; */
id|mode
op_and_assign
(paren
id|DMA_BE
op_or
id|DMA_DR
op_or
id|DMA_TS8
op_or
id|DMA_DW_MASK
op_or
id|DMA_NC
)paren
suffix:semicolon
id|chan-&gt;mode
op_and_assign
op_complement
(paren
id|DMA_BE
op_or
id|DMA_DR
op_or
id|DMA_TS8
op_or
id|DMA_DW_MASK
op_or
id|DMA_NC
)paren
suffix:semicolon
id|chan-&gt;mode
op_or_assign
id|mode
suffix:semicolon
)brace
DECL|function|get_dma_mode
r_static
id|__inline__
r_int
r_int
id|get_dma_mode
c_func
(paren
r_int
r_int
id|dmanr
)paren
(brace
r_struct
id|dma_chan
op_star
id|chan
op_assign
id|get_dma_chan
c_func
(paren
id|dmanr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|chan-&gt;mode
suffix:semicolon
)brace
DECL|function|get_dma_active_buffer
r_static
id|__inline__
r_int
id|get_dma_active_buffer
c_func
(paren
r_int
r_int
id|dmanr
)paren
(brace
r_struct
id|dma_chan
op_star
id|chan
op_assign
id|get_dma_chan
c_func
(paren
id|dmanr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
(paren
id|au_readl
c_func
(paren
id|chan-&gt;io
op_plus
id|DMA_MODE_READ
)paren
op_amp
id|DMA_AB
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * set the device FIFO address for a specific DMA channel - only&n; * applicable to GPO4 and GPO5. All the other devices have fixed&n; * FIFO addresses.&n; */
DECL|function|set_dma_fifo_addr
r_static
id|__inline__
r_void
id|set_dma_fifo_addr
c_func
(paren
r_int
r_int
id|dmanr
comma
r_int
r_int
id|a
)paren
(brace
r_struct
id|dma_chan
op_star
id|chan
op_assign
id|get_dma_chan
c_func
(paren
id|dmanr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|chan-&gt;dev_id
op_ne
id|DMA_ID_GP04
op_logical_and
id|chan-&gt;dev_id
op_ne
id|DMA_ID_GP05
)paren
r_return
suffix:semicolon
id|au_writel
c_func
(paren
id|PHYSADDR
c_func
(paren
id|a
)paren
comma
id|chan-&gt;io
op_plus
id|DMA_PERIPHERAL_ADDR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Clear the DMA buffer done bits in the mode register.&n; */
DECL|function|clear_dma_done0
r_static
id|__inline__
r_void
id|clear_dma_done0
c_func
(paren
r_int
r_int
id|dmanr
)paren
(brace
r_struct
id|dma_chan
op_star
id|chan
op_assign
id|get_dma_chan
c_func
(paren
id|dmanr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan
)paren
r_return
suffix:semicolon
id|au_writel
c_func
(paren
id|DMA_D0
comma
id|chan-&gt;io
op_plus
id|DMA_MODE_CLEAR
)paren
suffix:semicolon
)brace
DECL|function|clear_dma_done1
r_static
id|__inline__
r_void
id|clear_dma_done1
c_func
(paren
r_int
r_int
id|dmanr
)paren
(brace
r_struct
id|dma_chan
op_star
id|chan
op_assign
id|get_dma_chan
c_func
(paren
id|dmanr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan
)paren
r_return
suffix:semicolon
id|au_writel
c_func
(paren
id|DMA_D1
comma
id|chan-&gt;io
op_plus
id|DMA_MODE_CLEAR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This does nothing - not applicable to Au1000 DMA.&n; */
DECL|function|set_dma_page
r_static
id|__inline__
r_void
id|set_dma_page
c_func
(paren
r_int
r_int
id|dmanr
comma
r_char
id|pagenr
)paren
(brace
)brace
multiline_comment|/*&n; * Set Buffer 0 transfer address for specific DMA channel.&n; */
DECL|function|set_dma_addr0
r_static
id|__inline__
r_void
id|set_dma_addr0
c_func
(paren
r_int
r_int
id|dmanr
comma
r_int
r_int
id|a
)paren
(brace
r_struct
id|dma_chan
op_star
id|chan
op_assign
id|get_dma_chan
c_func
(paren
id|dmanr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan
)paren
r_return
suffix:semicolon
id|au_writel
c_func
(paren
id|a
comma
id|chan-&gt;io
op_plus
id|DMA_BUFFER0_START
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Set Buffer 1 transfer address for specific DMA channel.&n; */
DECL|function|set_dma_addr1
r_static
id|__inline__
r_void
id|set_dma_addr1
c_func
(paren
r_int
r_int
id|dmanr
comma
r_int
r_int
id|a
)paren
(brace
r_struct
id|dma_chan
op_star
id|chan
op_assign
id|get_dma_chan
c_func
(paren
id|dmanr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan
)paren
r_return
suffix:semicolon
id|au_writel
c_func
(paren
id|a
comma
id|chan-&gt;io
op_plus
id|DMA_BUFFER1_START
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Set Buffer 0 transfer size (max 64k) for a specific DMA channel.&n; */
DECL|function|set_dma_count0
r_static
id|__inline__
r_void
id|set_dma_count0
c_func
(paren
r_int
r_int
id|dmanr
comma
r_int
r_int
id|count
)paren
(brace
r_struct
id|dma_chan
op_star
id|chan
op_assign
id|get_dma_chan
c_func
(paren
id|dmanr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan
)paren
r_return
suffix:semicolon
id|count
op_and_assign
id|DMA_COUNT_MASK
suffix:semicolon
id|au_writel
c_func
(paren
id|count
comma
id|chan-&gt;io
op_plus
id|DMA_BUFFER0_COUNT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Set Buffer 1 transfer size (max 64k) for a specific DMA channel.&n; */
DECL|function|set_dma_count1
r_static
id|__inline__
r_void
id|set_dma_count1
c_func
(paren
r_int
r_int
id|dmanr
comma
r_int
r_int
id|count
)paren
(brace
r_struct
id|dma_chan
op_star
id|chan
op_assign
id|get_dma_chan
c_func
(paren
id|dmanr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan
)paren
r_return
suffix:semicolon
id|count
op_and_assign
id|DMA_COUNT_MASK
suffix:semicolon
id|au_writel
c_func
(paren
id|count
comma
id|chan-&gt;io
op_plus
id|DMA_BUFFER1_COUNT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Set both buffer transfer sizes (max 64k) for a specific DMA channel.&n; */
DECL|function|set_dma_count
r_static
id|__inline__
r_void
id|set_dma_count
c_func
(paren
r_int
r_int
id|dmanr
comma
r_int
r_int
id|count
)paren
(brace
r_struct
id|dma_chan
op_star
id|chan
op_assign
id|get_dma_chan
c_func
(paren
id|dmanr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan
)paren
r_return
suffix:semicolon
id|count
op_and_assign
id|DMA_COUNT_MASK
suffix:semicolon
id|au_writel
c_func
(paren
id|count
comma
id|chan-&gt;io
op_plus
id|DMA_BUFFER0_COUNT
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|count
comma
id|chan-&gt;io
op_plus
id|DMA_BUFFER1_COUNT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns which buffer has its done bit set in the mode register.&n; * Returns -1 if neither or both done bits set.&n; */
DECL|function|get_dma_buffer_done
r_static
id|__inline__
r_int
r_int
id|get_dma_buffer_done
c_func
(paren
r_int
r_int
id|dmanr
)paren
(brace
r_struct
id|dma_chan
op_star
id|chan
op_assign
id|get_dma_chan
c_func
(paren
id|dmanr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|au_readl
c_func
(paren
id|chan-&gt;io
op_plus
id|DMA_MODE_READ
)paren
op_amp
(paren
id|DMA_D0
op_or
id|DMA_D1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns the DMA channel&squot;s Buffer Done IRQ number.&n; */
DECL|function|get_dma_done_irq
r_static
id|__inline__
r_int
id|get_dma_done_irq
c_func
(paren
r_int
r_int
id|dmanr
)paren
(brace
r_struct
id|dma_chan
op_star
id|chan
op_assign
id|get_dma_chan
c_func
(paren
id|dmanr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
id|chan-&gt;irq
suffix:semicolon
)brace
multiline_comment|/*&n; * Get DMA residue count. Returns the number of _bytes_ left to transfer.&n; */
DECL|function|get_dma_residue
r_static
id|__inline__
r_int
id|get_dma_residue
c_func
(paren
r_int
r_int
id|dmanr
)paren
(brace
r_int
id|curBufCntReg
comma
id|count
suffix:semicolon
r_struct
id|dma_chan
op_star
id|chan
op_assign
id|get_dma_chan
c_func
(paren
id|dmanr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|chan
)paren
r_return
l_int|0
suffix:semicolon
id|curBufCntReg
op_assign
(paren
id|au_readl
c_func
(paren
id|chan-&gt;io
op_plus
id|DMA_MODE_READ
)paren
op_amp
id|DMA_AB
)paren
ques
c_cond
id|DMA_BUFFER1_COUNT
suffix:colon
id|DMA_BUFFER0_COUNT
suffix:semicolon
id|count
op_assign
id|au_readl
c_func
(paren
id|chan-&gt;io
op_plus
id|curBufCntReg
)paren
op_amp
id|DMA_COUNT_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|chan-&gt;mode
op_amp
id|DMA_DW_MASK
)paren
op_eq
id|DMA_DW16
)paren
id|count
op_lshift_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|chan-&gt;mode
op_amp
id|DMA_DW_MASK
)paren
op_eq
id|DMA_DW32
)paren
id|count
op_lshift_assign
l_int|2
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
macro_line|#endif /* __ASM_AU1000_DMA_H */
eof
