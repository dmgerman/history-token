multiline_comment|/*&n; * IBM PowerPC Virtual I/O Infrastructure Support.&n; *&n; *    Copyright (c) 2003 IBM Corp.&n; *     Dave Engebretsen engebret@us.ibm.com&n; *     Santiago Leon santil@us.ibm.com&n; *&n; *      This program is free software; you can redistribute it and/or&n; *      modify it under the terms of the GNU General Public License&n; *      as published by the Free Software Foundation; either version&n; *      2 of the License, or (at your option) any later version.&n; */
macro_line|#ifndef _VIO_H
DECL|macro|_VIO_H
mdefine_line|#define _VIO_H
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/hvcall.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/scatterlist.h&gt;
multiline_comment|/* &n; * Architecture-specific constants for drivers to&n; * extract attributes of the device using vio_get_attribute()&n;*/
DECL|macro|VETH_MAC_ADDR
mdefine_line|#define VETH_MAC_ADDR &quot;local-mac-address&quot;
DECL|macro|VETH_MCAST_FILTER_SIZE
mdefine_line|#define VETH_MCAST_FILTER_SIZE &quot;ibm,mac-address-filters&quot;
multiline_comment|/* End architecture-specific constants */
DECL|macro|h_vio_signal
mdefine_line|#define h_vio_signal(ua, mode) &bslash;&n;  plpar_hcall_norets(H_VIO_SIGNAL, ua, mode)
DECL|macro|VIO_IRQ_DISABLE
mdefine_line|#define VIO_IRQ_DISABLE&t;&t;0UL
DECL|macro|VIO_IRQ_ENABLE
mdefine_line|#define VIO_IRQ_ENABLE&t;&t;1UL
r_struct
id|vio_dev
suffix:semicolon
r_struct
id|vio_driver
suffix:semicolon
r_struct
id|vio_device_id
suffix:semicolon
r_struct
id|TceTable
suffix:semicolon
r_int
id|vio_register_driver
c_func
(paren
r_struct
id|vio_driver
op_star
id|drv
)paren
suffix:semicolon
r_int
id|vio_unregister_driver
c_func
(paren
r_struct
id|vio_driver
op_star
id|drv
)paren
suffix:semicolon
r_const
r_struct
id|vio_device_id
op_star
id|vio_match_device
c_func
(paren
r_const
r_struct
id|vio_device_id
op_star
id|ids
comma
r_const
r_struct
id|vio_dev
op_star
id|dev
)paren
suffix:semicolon
r_struct
id|vio_dev
op_star
id|__devinit
id|vio_register_device
c_func
(paren
r_struct
id|device_node
op_star
id|node_vdev
)paren
suffix:semicolon
r_int
id|__devinit
id|vio_unregister_device
c_func
(paren
r_struct
id|vio_dev
op_star
id|dev
)paren
suffix:semicolon
r_const
r_void
op_star
id|vio_get_attribute
c_func
(paren
r_struct
id|vio_dev
op_star
id|vdev
comma
r_void
op_star
id|which
comma
r_int
op_star
id|length
)paren
suffix:semicolon
r_int
id|vio_get_irq
c_func
(paren
r_struct
id|vio_dev
op_star
id|dev
)paren
suffix:semicolon
r_struct
id|TceTable
op_star
id|vio_build_tce_table
c_func
(paren
r_struct
id|vio_dev
op_star
id|dev
)paren
suffix:semicolon
r_int
id|vio_enable_interrupts
c_func
(paren
r_struct
id|vio_dev
op_star
id|dev
)paren
suffix:semicolon
r_int
id|vio_disable_interrupts
c_func
(paren
r_struct
id|vio_dev
op_star
id|dev
)paren
suffix:semicolon
id|dma_addr_t
id|vio_map_single
c_func
(paren
r_struct
id|vio_dev
op_star
id|dev
comma
r_void
op_star
id|vaddr
comma
r_int
id|size
comma
r_int
id|direction
)paren
suffix:semicolon
r_void
id|vio_unmap_single
c_func
(paren
r_struct
id|vio_dev
op_star
id|dev
comma
id|dma_addr_t
id|dma_handle
comma
r_int
id|size
comma
r_int
id|direction
)paren
suffix:semicolon
r_int
id|vio_map_sg
c_func
(paren
r_struct
id|vio_dev
op_star
id|vdev
comma
r_struct
id|scatterlist
op_star
id|sglist
comma
r_int
id|nelems
comma
r_int
id|direction
)paren
suffix:semicolon
r_void
id|vio_unmap_sg
c_func
(paren
r_struct
id|vio_dev
op_star
id|vdev
comma
r_struct
id|scatterlist
op_star
id|sglist
comma
r_int
id|nelems
comma
r_int
id|direction
)paren
suffix:semicolon
r_void
op_star
id|vio_alloc_consistent
c_func
(paren
r_struct
id|vio_dev
op_star
id|dev
comma
r_int
id|size
comma
id|dma_addr_t
op_star
id|dma_handle
)paren
suffix:semicolon
r_void
id|vio_free_consistent
c_func
(paren
r_struct
id|vio_dev
op_star
id|dev
comma
r_int
id|size
comma
r_void
op_star
id|vaddr
comma
id|dma_addr_t
id|dma_handle
)paren
suffix:semicolon
DECL|struct|vio_device_id
r_struct
id|vio_device_id
(brace
DECL|member|type
r_char
op_star
id|type
suffix:semicolon
DECL|member|compat
r_char
op_star
id|compat
suffix:semicolon
multiline_comment|/* I don&squot;t think we need this&n;&t;unsigned long driver_data;&t;*/
multiline_comment|/* Data private to the driver */
)brace
suffix:semicolon
DECL|struct|vio_driver
r_struct
id|vio_driver
(brace
DECL|member|node
r_struct
id|list_head
id|node
suffix:semicolon
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|id_table
r_const
r_struct
id|vio_device_id
op_star
id|id_table
suffix:semicolon
multiline_comment|/* NULL if wants all devices */
DECL|member|probe
r_int
(paren
op_star
id|probe
)paren
(paren
r_struct
id|vio_dev
op_star
id|dev
comma
r_const
r_struct
id|vio_device_id
op_star
id|id
)paren
suffix:semicolon
multiline_comment|/* New device inserted */
DECL|member|remove
r_void
(paren
op_star
id|remove
)paren
(paren
r_struct
id|vio_dev
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* Device removed (NULL if not a hot-plug capable driver) */
DECL|member|driver_data
r_int
r_int
id|driver_data
suffix:semicolon
)brace
suffix:semicolon
r_struct
id|vio_bus
suffix:semicolon
multiline_comment|/*&n; * The vio_dev structure is used to describe virtual I/O devices.&n; */
DECL|struct|vio_dev
r_struct
id|vio_dev
(brace
DECL|member|devices_list
r_struct
id|list_head
id|devices_list
suffix:semicolon
multiline_comment|/* node in list of all vio devices */
DECL|member|archdata
r_struct
id|device_node
op_star
id|archdata
suffix:semicolon
multiline_comment|/* Open Firmware node */
DECL|member|bus
r_struct
id|vio_bus
op_star
id|bus
suffix:semicolon
multiline_comment|/* bus this device is on */
DECL|member|driver
r_struct
id|vio_driver
op_star
id|driver
suffix:semicolon
multiline_comment|/* owning driver */
DECL|member|driver_data
r_void
op_star
id|driver_data
suffix:semicolon
multiline_comment|/* data private to the driver */
DECL|member|unit_address
r_int
r_int
id|unit_address
suffix:semicolon
DECL|member|tce_table
r_struct
id|TceTable
op_star
id|tce_table
suffix:semicolon
multiline_comment|/* vio_map_* uses this */
DECL|member|irq
r_int
r_int
id|irq
suffix:semicolon
DECL|member|procent
r_struct
id|proc_dir_entry
op_star
id|procent
suffix:semicolon
multiline_comment|/* device entry in /proc/bus/vio */
)brace
suffix:semicolon
DECL|struct|vio_bus
r_struct
id|vio_bus
(brace
DECL|member|devices
r_struct
id|list_head
id|devices
suffix:semicolon
multiline_comment|/* list of virtual devices */
)brace
suffix:semicolon
DECL|function|vio_module_init
r_static
r_inline
r_int
id|vio_module_init
c_func
(paren
r_struct
id|vio_driver
op_star
id|drv
)paren
(brace
r_int
id|rc
op_assign
id|vio_register_driver
(paren
id|drv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OG
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* iff CONFIG_HOTPLUG and built into kernel, we should&n;         * leave the driver around for future hotplug events.&n;         * For the module case, a hotplug daemon of some sort&n;         * should load a module in response to an insert event. */
macro_line|#if defined(CONFIG_HOTPLUG) &amp;&amp; !defined(MODULE)
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
macro_line|#endif
multiline_comment|/* if we get here, we need to clean up vio driver instance&n;         * and return some sort of error */
r_return
id|rc
suffix:semicolon
)brace
macro_line|#endif /* _PHYP_H */
eof
