multiline_comment|/* &n; * eeh.h&n; * Copyright (C) 2001  Dave Engebretsen &amp; Todd Inglett IBM Corporation.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; * &n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; * &n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA&n; */
multiline_comment|/* Start Change Log&n; * 2001/10/27 : engebret : Created.&n; * End Change Log &n; */
macro_line|#ifndef _EEH_H
DECL|macro|_EEH_H
mdefine_line|#define _EEH_H
r_struct
id|pci_dev
suffix:semicolon
DECL|macro|IO_UNMAPPED_REGION_ID
mdefine_line|#define IO_UNMAPPED_REGION_ID 0xaUL
DECL|macro|IO_TOKEN_TO_ADDR
mdefine_line|#define IO_TOKEN_TO_ADDR(token) ((((unsigned long)(token)) &amp; 0xFFFFFFFF) | (0xEUL &lt;&lt; 60))
multiline_comment|/* Flag bits encoded in the 3 unused function bits of devfn */
DECL|macro|EEH_TOKEN_DISABLED
mdefine_line|#define EEH_TOKEN_DISABLED (1UL &lt;&lt; 34UL)&t;/* eeh is disabled for this token */
DECL|macro|IS_EEH_TOKEN_DISABLED
mdefine_line|#define IS_EEH_TOKEN_DISABLED(token) ((unsigned long)(token) &amp; EEH_TOKEN_DISABLED)
DECL|macro|EEH_STATE_OVERRIDE
mdefine_line|#define EEH_STATE_OVERRIDE 1   /* IOA does not require eeh traps */
DECL|macro|EEH_STATE_FAILURE
mdefine_line|#define EEH_STATE_FAILURE  16  /* */
multiline_comment|/* This is for profiling only and should be removed */
r_extern
r_int
r_int
id|eeh_total_mmio_reads
suffix:semicolon
r_extern
r_int
r_int
id|eeh_total_mmio_ffs
suffix:semicolon
r_void
id|eeh_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|eeh_get_state
c_func
(paren
r_int
r_int
id|ea
)paren
suffix:semicolon
r_int
r_int
id|eeh_check_failure
c_func
(paren
r_void
op_star
id|token
comma
r_int
r_int
id|val
)paren
suffix:semicolon
DECL|macro|EEH_DISABLE
mdefine_line|#define EEH_DISABLE&t;&t;0
DECL|macro|EEH_ENABLE
mdefine_line|#define EEH_ENABLE&t;&t;1
DECL|macro|EEH_RELEASE_LOADSTORE
mdefine_line|#define EEH_RELEASE_LOADSTORE&t;2
DECL|macro|EEH_RELEASE_DMA
mdefine_line|#define EEH_RELEASE_DMA&t;&t;3
r_int
id|eeh_set_option
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|options
)paren
suffix:semicolon
multiline_comment|/* Given a PCI device check if eeh should be configured or not.&n; * This may look at firmware properties and/or kernel cmdline options.&n; */
r_int
id|is_eeh_configured
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* Generate an EEH token.&n; * The high nibble of the offset is cleared, otherwise bounds checking is performed.&n; * Use IO_TOKEN_TO_ADDR(token) to translate this token back to a mapped virtual addr.&n; * Do NOT do this to perform IO -- use the read/write macros!&n; */
r_int
r_int
id|eeh_token
c_func
(paren
r_int
r_int
id|phb
comma
r_int
r_int
id|bus
comma
r_int
r_int
id|devfn
comma
r_int
r_int
id|offset
)paren
suffix:semicolon
r_extern
r_void
op_star
id|memcpy
c_func
(paren
r_void
op_star
comma
r_const
r_void
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_void
op_star
id|memset
c_func
(paren
r_void
op_star
comma
r_int
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* EEH_POSSIBLE_ERROR() -- test for possible MMIO failure.&n; *&n; * Order this macro for performance.&n; * If EEH is off for a device and it is a memory BAR, ioremap will&n; * map it to the IOREGION.  In this case addr == vaddr and since these&n; * should be in registers we compare them first.  Next we check for&n; * all ones which is perhaps fastest as ~val.  Finally we weed out&n; * EEH disabled IO BARs.&n; *&n; * If this macro yields TRUE, the caller relays to eeh_check_failure()&n; * which does further tests out of line.&n; */
multiline_comment|/* #define EEH_POSSIBLE_ERROR(addr, vaddr, val) ((vaddr) != (addr) &amp;&amp; ~(val) == 0 &amp;&amp; !IS_EEH_TOKEN_DISABLED(addr)) */
multiline_comment|/* This version is rearranged to collect some profiling data */
DECL|macro|EEH_POSSIBLE_ERROR
mdefine_line|#define EEH_POSSIBLE_ERROR(addr, vaddr, val) (++eeh_total_mmio_reads, (~(val) == 0 &amp;&amp; (++eeh_total_mmio_ffs, (vaddr) != (addr) &amp;&amp; !IS_EEH_TOKEN_DISABLED(addr))))
multiline_comment|/* &n; * MMIO read/write operations with EEH support.&n; *&n; * addr: 64b token of the form 0xA0PPBBDDyyyyyyyy&n; *       0xA0     : Unmapped MMIO region&n; *       PP       : PHB index (starting at zero)&n; *&t; BB&t;  : PCI Bus number under given PHB&n; *&t; DD&t;  : PCI devfn under given bus&n; *       yyyyyyyy : Virtual address offset&n; * &n; * An actual virtual address is produced from this token&n; * by masking into the form:&n; *   0xE0000000yyyyyyyy&n; */
DECL|function|eeh_readb
r_static
r_inline
id|u8
id|eeh_readb
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
r_volatile
id|u8
op_star
id|vaddr
op_assign
(paren
r_volatile
id|u8
op_star
)paren
id|IO_TOKEN_TO_ADDR
c_func
(paren
id|addr
)paren
suffix:semicolon
id|u8
id|val
op_assign
id|in_8
c_func
(paren
id|vaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|EEH_POSSIBLE_ERROR
c_func
(paren
id|addr
comma
id|vaddr
comma
id|val
)paren
)paren
r_return
id|eeh_check_failure
c_func
(paren
id|addr
comma
id|val
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
DECL|function|eeh_writeb
r_static
r_inline
r_void
id|eeh_writeb
c_func
(paren
id|u8
id|val
comma
r_void
op_star
id|addr
)paren
(brace
r_volatile
id|u8
op_star
id|vaddr
op_assign
(paren
r_volatile
id|u8
op_star
)paren
id|IO_TOKEN_TO_ADDR
c_func
(paren
id|addr
)paren
suffix:semicolon
id|out_8
c_func
(paren
id|vaddr
comma
id|val
)paren
suffix:semicolon
)brace
DECL|function|eeh_readw
r_static
r_inline
id|u16
id|eeh_readw
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
r_volatile
id|u16
op_star
id|vaddr
op_assign
(paren
r_volatile
id|u16
op_star
)paren
id|IO_TOKEN_TO_ADDR
c_func
(paren
id|addr
)paren
suffix:semicolon
id|u16
id|val
op_assign
id|in_le16
c_func
(paren
id|vaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|EEH_POSSIBLE_ERROR
c_func
(paren
id|addr
comma
id|vaddr
comma
id|val
)paren
)paren
r_return
id|eeh_check_failure
c_func
(paren
id|addr
comma
id|val
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
DECL|function|eeh_writew
r_static
r_inline
r_void
id|eeh_writew
c_func
(paren
id|u16
id|val
comma
r_void
op_star
id|addr
)paren
(brace
r_volatile
id|u16
op_star
id|vaddr
op_assign
(paren
r_volatile
id|u16
op_star
)paren
id|IO_TOKEN_TO_ADDR
c_func
(paren
id|addr
)paren
suffix:semicolon
id|out_le16
c_func
(paren
id|vaddr
comma
id|val
)paren
suffix:semicolon
)brace
DECL|function|eeh_readl
r_static
r_inline
id|u32
id|eeh_readl
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
r_volatile
id|u32
op_star
id|vaddr
op_assign
(paren
r_volatile
id|u32
op_star
)paren
id|IO_TOKEN_TO_ADDR
c_func
(paren
id|addr
)paren
suffix:semicolon
id|u32
id|val
op_assign
id|in_le32
c_func
(paren
id|vaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|EEH_POSSIBLE_ERROR
c_func
(paren
id|addr
comma
id|vaddr
comma
id|val
)paren
)paren
r_return
id|eeh_check_failure
c_func
(paren
id|addr
comma
id|val
)paren
suffix:semicolon
r_return
id|val
suffix:semicolon
)brace
DECL|function|eeh_writel
r_static
r_inline
r_void
id|eeh_writel
c_func
(paren
id|u32
id|val
comma
r_void
op_star
id|addr
)paren
(brace
r_volatile
id|u32
op_star
id|vaddr
op_assign
(paren
r_volatile
id|u32
op_star
)paren
id|IO_TOKEN_TO_ADDR
c_func
(paren
id|addr
)paren
suffix:semicolon
id|out_le32
c_func
(paren
id|vaddr
comma
id|val
)paren
suffix:semicolon
)brace
DECL|function|eeh_memset_io
r_static
r_inline
r_void
id|eeh_memset_io
c_func
(paren
r_void
op_star
id|addr
comma
r_int
id|c
comma
r_int
r_int
id|n
)paren
(brace
r_void
op_star
id|vaddr
op_assign
(paren
r_void
op_star
)paren
id|IO_TOKEN_TO_ADDR
c_func
(paren
id|addr
)paren
suffix:semicolon
id|memset
c_func
(paren
id|vaddr
comma
id|c
comma
id|n
)paren
suffix:semicolon
)brace
DECL|function|eeh_memcpy_fromio
r_static
r_inline
r_void
id|eeh_memcpy_fromio
c_func
(paren
r_void
op_star
id|dest
comma
r_void
op_star
id|src
comma
r_int
r_int
id|n
)paren
(brace
r_void
op_star
id|vsrc
op_assign
(paren
r_void
op_star
)paren
id|IO_TOKEN_TO_ADDR
c_func
(paren
id|src
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|dest
comma
id|vsrc
comma
id|n
)paren
suffix:semicolon
multiline_comment|/* look for ffff&squot;s here at dest[n] */
)brace
DECL|function|eeh_memcpy_toio
r_static
r_inline
r_void
id|eeh_memcpy_toio
c_func
(paren
r_void
op_star
id|dest
comma
r_void
op_star
id|src
comma
r_int
r_int
id|n
)paren
(brace
r_void
op_star
id|vdest
op_assign
(paren
r_void
op_star
)paren
id|IO_TOKEN_TO_ADDR
c_func
(paren
id|dest
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|vdest
comma
id|src
comma
id|n
)paren
suffix:semicolon
)brace
macro_line|#endif /* _EEH_H */
eof
