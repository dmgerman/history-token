multiline_comment|/*&n; *  linux/include/asm-arm/proc-armv/pgalloc.h&n; *&n; *  Copyright (C) 2001 Russell King&n; *&n; * Page table allocation/freeing primitives for 32-bit ARM processors.&n; */
multiline_comment|/* unfortunately, this includes linux/mm.h and the rest of the universe. */
macro_line|#include &lt;linux/slab.h&gt;
r_extern
id|kmem_cache_t
op_star
id|pte_cache
suffix:semicolon
multiline_comment|/*&n; * Allocate one PTE table.&n; *&n; * Note that we keep the processor copy of the PTE entries separate&n; * from the Linux copy.  The processor copies are offset by -PTRS_PER_PTE&n; * words from the Linux copy.&n; */
r_static
r_inline
id|pte_t
op_star
DECL|function|pte_alloc_one_kernel
id|pte_alloc_one_kernel
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
)paren
(brace
id|pte_t
op_star
id|pte
suffix:semicolon
id|pte
op_assign
id|kmem_cache_alloc
c_func
(paren
id|pte_cache
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte
)paren
id|pte
op_add_assign
id|PTRS_PER_PTE
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|page
op_star
DECL|function|pte_alloc_one
id|pte_alloc_one
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
)paren
(brace
id|pte_t
op_star
id|pte
suffix:semicolon
id|pte
op_assign
id|kmem_cache_alloc
c_func
(paren
id|pte_cache
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte
)paren
id|pte
op_add_assign
id|PTRS_PER_PTE
suffix:semicolon
r_return
(paren
r_struct
id|page
op_star
)paren
id|pte
suffix:semicolon
)brace
multiline_comment|/*&n; * Free one PTE table.&n; */
DECL|function|pte_free_kernel
r_static
r_inline
r_void
id|pte_free_kernel
c_func
(paren
id|pte_t
op_star
id|pte
)paren
(brace
r_if
c_cond
(paren
id|pte
)paren
(brace
id|pte
op_sub_assign
id|PTRS_PER_PTE
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|pte_cache
comma
id|pte
)paren
suffix:semicolon
)brace
)brace
DECL|function|pte_free
r_static
r_inline
r_void
id|pte_free
c_func
(paren
r_struct
id|page
op_star
id|pte
)paren
(brace
id|pte_t
op_star
id|_pte
op_assign
(paren
id|pte_t
op_star
)paren
id|pte
suffix:semicolon
r_if
c_cond
(paren
id|pte
)paren
(brace
id|_pte
op_sub_assign
id|PTRS_PER_PTE
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|pte_cache
comma
id|_pte
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Populate the pmdp entry with a pointer to the pte.  This pmd is part&n; * of the mm address space.&n; *&n; * If &squot;mm&squot; is the init tasks mm, then we are doing a vmalloc, and we&n; * need to set stuff up correctly for it.&n; */
DECL|macro|pmd_populate_kernel
mdefine_line|#define pmd_populate_kernel(mm,pmdp,pte)&t;&t;&t;&bslash;&n;&t;do {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;BUG_ON(mm != &amp;init_mm);&t;&t;&t;&t;&bslash;&n;&t;&t;set_pmd(pmdp, __mk_pmd(pte, _PAGE_KERNEL_TABLE));&bslash;&n;&t;} while (0)
DECL|macro|pmd_populate
mdefine_line|#define pmd_populate(mm,pmdp,pte)&t;&t;&t;&t;&bslash;&n;&t;do {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;BUG_ON(mm == &amp;init_mm);&t;&t;&t;&t;&bslash;&n;&t;&t;set_pmd(pmdp, __mk_pmd(pte, _PAGE_USER_TABLE));&t;&bslash;&n;&t;} while (0)
eof
