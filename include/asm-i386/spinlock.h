macro_line|#ifndef __ASM_SPINLOCK_H
DECL|macro|__ASM_SPINLOCK_H
mdefine_line|#define __ASM_SPINLOCK_H
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/rwlock.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
id|asmlinkage
r_int
id|printk
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
id|__attribute__
(paren
(paren
id|format
(paren
id|printf
comma
l_int|1
comma
l_int|2
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n; * Your basic SMP spinlocks, allowing only a single CPU anywhere&n; */
r_typedef
r_struct
(brace
DECL|member|slock
r_volatile
r_int
r_int
id|slock
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_SPINLOCK
DECL|member|magic
r_int
id|magic
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_PREEMPT
DECL|member|break_lock
r_int
r_int
id|break_lock
suffix:semicolon
macro_line|#endif
DECL|typedef|spinlock_t
)brace
id|spinlock_t
suffix:semicolon
DECL|macro|SPINLOCK_MAGIC
mdefine_line|#define SPINLOCK_MAGIC&t;0xdead4ead
macro_line|#ifdef CONFIG_DEBUG_SPINLOCK
DECL|macro|SPINLOCK_MAGIC_INIT
mdefine_line|#define SPINLOCK_MAGIC_INIT&t;, SPINLOCK_MAGIC
macro_line|#else
DECL|macro|SPINLOCK_MAGIC_INIT
mdefine_line|#define SPINLOCK_MAGIC_INIT&t;/* */
macro_line|#endif
DECL|macro|SPIN_LOCK_UNLOCKED
mdefine_line|#define SPIN_LOCK_UNLOCKED (spinlock_t) { 1 SPINLOCK_MAGIC_INIT }
DECL|macro|spin_lock_init
mdefine_line|#define spin_lock_init(x)&t;do { *(x) = SPIN_LOCK_UNLOCKED; } while(0)
multiline_comment|/*&n; * Simple spin lock operations.  There are two variants, one clears IRQ&squot;s&n; * on the local processor, one does not.&n; *&n; * We make no fairness assumptions. They have a cost.&n; */
DECL|macro|spin_is_locked
mdefine_line|#define spin_is_locked(x)&t;(*(volatile signed char *)(&amp;(x)-&gt;slock) &lt;= 0)
DECL|macro|spin_unlock_wait
mdefine_line|#define spin_unlock_wait(x)&t;do { barrier(); } while(spin_is_locked(x))
DECL|macro|spin_lock_string
mdefine_line|#define spin_lock_string &bslash;&n;&t;&quot;&bslash;n1:&bslash;t&quot; &bslash;&n;&t;&quot;lock ; decb %0&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;jns 3f&bslash;n&quot; &bslash;&n;&t;&quot;2:&bslash;t&quot; &bslash;&n;&t;&quot;rep;nop&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;cmpb $0,%0&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;jle 2b&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;jmp 1b&bslash;n&quot; &bslash;&n;&t;&quot;3:&bslash;n&bslash;t&quot;
DECL|macro|spin_lock_string_flags
mdefine_line|#define spin_lock_string_flags &bslash;&n;&t;&quot;&bslash;n1:&bslash;t&quot; &bslash;&n;&t;&quot;lock ; decb %0&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;jns 4f&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;2:&bslash;t&quot; &bslash;&n;&t;&quot;testl $0x200, %1&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;jz 3f&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;sti&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;3:&bslash;t&quot; &bslash;&n;&t;&quot;rep;nop&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;cmpb $0, %0&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;jle 3b&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;cli&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;jmp 1b&bslash;n&quot; &bslash;&n;&t;&quot;4:&bslash;n&bslash;t&quot;
multiline_comment|/*&n; * This works. Despite all the confusion.&n; * (except on PPro SMP or if we are using OOSTORE)&n; * (PPro errata 66, 92)&n; */
macro_line|#if !defined(CONFIG_X86_OOSTORE) &amp;&amp; !defined(CONFIG_X86_PPRO_FENCE)
DECL|macro|spin_unlock_string
mdefine_line|#define spin_unlock_string &bslash;&n;&t;&quot;movb $1,%0&quot; &bslash;&n;&t;&t;:&quot;=m&quot; (lock-&gt;slock) : : &quot;memory&quot;
DECL|function|_raw_spin_unlock
r_static
r_inline
r_void
id|_raw_spin_unlock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
macro_line|#ifdef CONFIG_DEBUG_SPINLOCK
id|BUG_ON
c_func
(paren
id|lock-&gt;magic
op_ne
id|SPINLOCK_MAGIC
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|spin_is_locked
c_func
(paren
id|lock
)paren
)paren
suffix:semicolon
macro_line|#endif
id|__asm__
id|__volatile__
c_func
(paren
id|spin_unlock_string
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|spin_unlock_string
mdefine_line|#define spin_unlock_string &bslash;&n;&t;&quot;xchgb %b0, %1&quot; &bslash;&n;&t;&t;:&quot;=q&quot; (oldval), &quot;=m&quot; (lock-&gt;slock) &bslash;&n;&t;&t;:&quot;0&quot; (oldval) : &quot;memory&quot;
DECL|function|_raw_spin_unlock
r_static
r_inline
r_void
id|_raw_spin_unlock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
r_char
id|oldval
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_SPINLOCK
id|BUG_ON
c_func
(paren
id|lock-&gt;magic
op_ne
id|SPINLOCK_MAGIC
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|spin_is_locked
c_func
(paren
id|lock
)paren
)paren
suffix:semicolon
macro_line|#endif
id|__asm__
id|__volatile__
c_func
(paren
id|spin_unlock_string
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|_raw_spin_trylock
r_static
r_inline
r_int
id|_raw_spin_trylock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
r_char
id|oldval
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;xchgb %b0,%1&quot;
suffix:colon
l_string|&quot;=q&quot;
(paren
id|oldval
)paren
comma
l_string|&quot;=m&quot;
(paren
id|lock-&gt;slock
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
l_int|0
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|oldval
OG
l_int|0
suffix:semicolon
)brace
DECL|function|_raw_spin_lock
r_static
r_inline
r_void
id|_raw_spin_lock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
macro_line|#ifdef CONFIG_DEBUG_SPINLOCK
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|lock-&gt;magic
op_ne
id|SPINLOCK_MAGIC
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eip: %p&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|__asm__
id|__volatile__
c_func
(paren
id|spin_lock_string
suffix:colon
l_string|&quot;=m&quot;
(paren
id|lock-&gt;slock
)paren
suffix:colon
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
DECL|function|_raw_spin_lock_flags
r_static
r_inline
r_void
id|_raw_spin_lock_flags
(paren
id|spinlock_t
op_star
id|lock
comma
r_int
r_int
id|flags
)paren
(brace
macro_line|#ifdef CONFIG_DEBUG_SPINLOCK
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|lock-&gt;magic
op_ne
id|SPINLOCK_MAGIC
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eip: %p&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|__asm__
id|__volatile__
c_func
(paren
id|spin_lock_string_flags
suffix:colon
l_string|&quot;=m&quot;
(paren
id|lock-&gt;slock
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|flags
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read-write spinlocks, allowing multiple readers&n; * but only one writer.&n; *&n; * NOTE! it is quite common to have readers in interrupts&n; * but no interrupt writers. For those circumstances we&n; * can &quot;mix&quot; irq-safe locks - any writer needs to get a&n; * irq-safe write-lock, but readers can get non-irqsafe&n; * read-locks.&n; */
r_typedef
r_struct
(brace
DECL|member|lock
r_volatile
r_int
r_int
id|lock
suffix:semicolon
macro_line|#ifdef CONFIG_DEBUG_SPINLOCK
DECL|member|magic
r_int
id|magic
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_PREEMPT
DECL|member|break_lock
r_int
r_int
id|break_lock
suffix:semicolon
macro_line|#endif
DECL|typedef|rwlock_t
)brace
id|rwlock_t
suffix:semicolon
DECL|macro|RWLOCK_MAGIC
mdefine_line|#define RWLOCK_MAGIC&t;0xdeaf1eed
macro_line|#ifdef CONFIG_DEBUG_SPINLOCK
DECL|macro|RWLOCK_MAGIC_INIT
mdefine_line|#define RWLOCK_MAGIC_INIT&t;, RWLOCK_MAGIC
macro_line|#else
DECL|macro|RWLOCK_MAGIC_INIT
mdefine_line|#define RWLOCK_MAGIC_INIT&t;/* */
macro_line|#endif
DECL|macro|RW_LOCK_UNLOCKED
mdefine_line|#define RW_LOCK_UNLOCKED (rwlock_t) { RW_LOCK_BIAS RWLOCK_MAGIC_INIT }
DECL|macro|rwlock_init
mdefine_line|#define rwlock_init(x)&t;do { *(x) = RW_LOCK_UNLOCKED; } while(0)
multiline_comment|/**&n; * read_can_lock - would read_trylock() succeed?&n; * @lock: the rwlock in question.&n; */
DECL|macro|read_can_lock
mdefine_line|#define read_can_lock(x) ((int)(x)-&gt;lock &gt; 0)
multiline_comment|/**&n; * write_can_lock - would write_trylock() succeed?&n; * @lock: the rwlock in question.&n; */
DECL|macro|write_can_lock
mdefine_line|#define write_can_lock(x) ((x)-&gt;lock == RW_LOCK_BIAS)
multiline_comment|/*&n; * On x86, we implement read-write locks as a 32-bit counter&n; * with the high bit (sign) being the &quot;contended&quot; bit.&n; *&n; * The inline assembly is non-obvious. Think about it.&n; *&n; * Changed to use the same technique as rw semaphores.  See&n; * semaphore.h for details.  -ben&n; */
multiline_comment|/* the spinlock helpers are in arch/i386/kernel/semaphore.c */
DECL|function|_raw_read_lock
r_static
r_inline
r_void
id|_raw_read_lock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
macro_line|#ifdef CONFIG_DEBUG_SPINLOCK
id|BUG_ON
c_func
(paren
id|rw-&gt;magic
op_ne
id|RWLOCK_MAGIC
)paren
suffix:semicolon
macro_line|#endif
id|__build_read_lock
c_func
(paren
id|rw
comma
l_string|&quot;__read_lock_failed&quot;
)paren
suffix:semicolon
)brace
DECL|function|_raw_write_lock
r_static
r_inline
r_void
id|_raw_write_lock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
macro_line|#ifdef CONFIG_DEBUG_SPINLOCK
id|BUG_ON
c_func
(paren
id|rw-&gt;magic
op_ne
id|RWLOCK_MAGIC
)paren
suffix:semicolon
macro_line|#endif
id|__build_write_lock
c_func
(paren
id|rw
comma
l_string|&quot;__write_lock_failed&quot;
)paren
suffix:semicolon
)brace
DECL|macro|_raw_read_unlock
mdefine_line|#define _raw_read_unlock(rw)&t;&t;asm volatile(&quot;lock ; incl %0&quot; :&quot;=m&quot; ((rw)-&gt;lock) : : &quot;memory&quot;)
DECL|macro|_raw_write_unlock
mdefine_line|#define _raw_write_unlock(rw)&t;asm volatile(&quot;lock ; addl $&quot; RW_LOCK_BIAS_STR &quot;,%0&quot;:&quot;=m&quot; ((rw)-&gt;lock) : : &quot;memory&quot;)
DECL|function|_raw_read_trylock
r_static
r_inline
r_int
id|_raw_read_trylock
c_func
(paren
id|rwlock_t
op_star
id|lock
)paren
(brace
id|atomic_t
op_star
id|count
op_assign
(paren
id|atomic_t
op_star
)paren
id|lock
suffix:semicolon
id|atomic_dec
c_func
(paren
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
id|count
)paren
op_ge
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|atomic_inc
c_func
(paren
id|count
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|_raw_write_trylock
r_static
r_inline
r_int
id|_raw_write_trylock
c_func
(paren
id|rwlock_t
op_star
id|lock
)paren
(brace
id|atomic_t
op_star
id|count
op_assign
(paren
id|atomic_t
op_star
)paren
id|lock
suffix:semicolon
r_if
c_cond
(paren
id|atomic_sub_and_test
c_func
(paren
id|RW_LOCK_BIAS
comma
id|count
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|atomic_add
c_func
(paren
id|RW_LOCK_BIAS
comma
id|count
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* __ASM_SPINLOCK_H */
eof
