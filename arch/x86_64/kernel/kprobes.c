multiline_comment|/*&n; *  Kernel Probes (KProbes)&n; *  arch/x86_64/kernel/kprobes.c&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.&n; *&n; * Copyright (C) IBM Corporation, 2002, 2004&n; *&n; * 2002-Oct&t;Created by Vamsi Krishna S &lt;vamsi_krishna@in.ibm.com&gt; Kernel&n; *&t;&t;Probes initial implementation ( includes contributions from&n; *&t;&t;Rusty Russell).&n; * 2004-July&t;Suparna Bhattacharya &lt;suparna@in.ibm.com&gt; added jumper probes&n; *&t;&t;interface to access function arguments.&n; * 2004-Oct&t;Jim Keniston &lt;kenistoj@us.ibm.com&gt; and Prasanna S Panchamukhi&n; *&t;&t;&lt;prasanna@in.ibm.com&gt; adapted for x86_64&n; * 2005-Mar&t;Roland McGrath &lt;roland@redhat.com&gt;&n; *&t;&t;Fixed to handle %rip-relative addressing mode correctly.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kprobes.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/preempt.h&gt;
macro_line|#include &lt;linux/moduleloader.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/kdebug.h&gt;
r_static
id|DECLARE_MUTEX
c_func
(paren
id|kprobe_mutex
)paren
suffix:semicolon
multiline_comment|/* kprobe_status settings */
DECL|macro|KPROBE_HIT_ACTIVE
mdefine_line|#define KPROBE_HIT_ACTIVE&t;0x00000001
DECL|macro|KPROBE_HIT_SS
mdefine_line|#define KPROBE_HIT_SS&t;&t;0x00000002
DECL|variable|current_kprobe
r_static
r_struct
id|kprobe
op_star
id|current_kprobe
suffix:semicolon
DECL|variable|kprobe_status
DECL|variable|kprobe_old_rflags
DECL|variable|kprobe_saved_rflags
r_static
r_int
r_int
id|kprobe_status
comma
id|kprobe_old_rflags
comma
id|kprobe_saved_rflags
suffix:semicolon
DECL|variable|jprobe_saved_regs
r_static
r_struct
id|pt_regs
id|jprobe_saved_regs
suffix:semicolon
DECL|variable|jprobe_saved_rsp
r_static
r_int
op_star
id|jprobe_saved_rsp
suffix:semicolon
r_static
id|kprobe_opcode_t
op_star
id|get_insn_slot
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|free_insn_slot
c_func
(paren
id|kprobe_opcode_t
op_star
id|slot
)paren
suffix:semicolon
r_void
id|jprobe_return_end
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* copy of the kernel stack at the probe fire time */
DECL|variable|jprobes_stack
r_static
id|kprobe_opcode_t
id|jprobes_stack
(braket
id|MAX_STACK_SIZE
)braket
suffix:semicolon
multiline_comment|/*&n; * returns non-zero if opcode modifies the interrupt flag.&n; */
DECL|function|is_IF_modifier
r_static
r_inline
r_int
id|is_IF_modifier
c_func
(paren
id|kprobe_opcode_t
op_star
id|insn
)paren
(brace
r_switch
c_cond
(paren
op_star
id|insn
)paren
(brace
r_case
l_int|0xfa
suffix:colon
multiline_comment|/* cli */
r_case
l_int|0xfb
suffix:colon
multiline_comment|/* sti */
r_case
l_int|0xcf
suffix:colon
multiline_comment|/* iret/iretd */
r_case
l_int|0x9d
suffix:colon
multiline_comment|/* popf/popfd */
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|insn
op_ge
l_int|0x40
op_logical_and
op_star
id|insn
op_le
l_int|0x4f
op_logical_and
op_star
op_increment
id|insn
op_eq
l_int|0xcf
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|arch_prepare_kprobe
r_int
id|arch_prepare_kprobe
c_func
(paren
r_struct
id|kprobe
op_star
id|p
)paren
(brace
multiline_comment|/* insn: must be on special executable page on x86_64. */
id|up
c_func
(paren
op_amp
id|kprobe_mutex
)paren
suffix:semicolon
id|p-&gt;ainsn.insn
op_assign
id|get_insn_slot
c_func
(paren
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|kprobe_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;ainsn.insn
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Determine if the instruction uses the %rip-relative addressing mode.&n; * If it does, return the address of the 32-bit displacement word.&n; * If not, return null.&n; */
DECL|function|is_riprel
r_static
r_inline
id|s32
op_star
id|is_riprel
c_func
(paren
id|u8
op_star
id|insn
)paren
(brace
DECL|macro|W
mdefine_line|#define W(row,b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,ba,bb,bc,bd,be,bf)&t;&t;      &bslash;&n;&t;(((b0##UL &lt;&lt; 0x0)|(b1##UL &lt;&lt; 0x1)|(b2##UL &lt;&lt; 0x2)|(b3##UL &lt;&lt; 0x3) |   &bslash;&n;&t;  (b4##UL &lt;&lt; 0x4)|(b5##UL &lt;&lt; 0x5)|(b6##UL &lt;&lt; 0x6)|(b7##UL &lt;&lt; 0x7) |   &bslash;&n;&t;  (b8##UL &lt;&lt; 0x8)|(b9##UL &lt;&lt; 0x9)|(ba##UL &lt;&lt; 0xa)|(bb##UL &lt;&lt; 0xb) |   &bslash;&n;&t;  (bc##UL &lt;&lt; 0xc)|(bd##UL &lt;&lt; 0xd)|(be##UL &lt;&lt; 0xe)|(bf##UL &lt;&lt; 0xf))    &bslash;&n;&t; &lt;&lt; (row % 64))
r_static
r_const
id|u64
id|onebyte_has_modrm
(braket
l_int|256
op_div
l_int|64
)braket
op_assign
(brace
multiline_comment|/*      0 1 2 3 4 5 6 7 8 9 a b c d e f         */
multiline_comment|/*      -------------------------------         */
id|W
c_func
(paren
l_int|0x00
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
op_or
multiline_comment|/* 00 */
id|W
c_func
(paren
l_int|0x10
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
op_or
multiline_comment|/* 10 */
id|W
c_func
(paren
l_int|0x20
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
op_or
multiline_comment|/* 20 */
id|W
c_func
(paren
l_int|0x30
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
multiline_comment|/* 30 */
id|W
c_func
(paren
l_int|0x40
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
op_or
multiline_comment|/* 40 */
id|W
c_func
(paren
l_int|0x50
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
op_or
multiline_comment|/* 50 */
id|W
c_func
(paren
l_int|0x60
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
op_or
multiline_comment|/* 60 */
id|W
c_func
(paren
l_int|0x70
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
multiline_comment|/* 70 */
id|W
c_func
(paren
l_int|0x80
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
)paren
op_or
multiline_comment|/* 80 */
id|W
c_func
(paren
l_int|0x90
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
op_or
multiline_comment|/* 90 */
id|W
c_func
(paren
l_int|0xa0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
op_or
multiline_comment|/* a0 */
id|W
c_func
(paren
l_int|0xb0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
multiline_comment|/* b0 */
id|W
c_func
(paren
l_int|0xc0
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
op_or
multiline_comment|/* c0 */
id|W
c_func
(paren
l_int|0xd0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
)paren
op_or
multiline_comment|/* d0 */
id|W
c_func
(paren
l_int|0xe0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
op_or
multiline_comment|/* e0 */
id|W
c_func
(paren
l_int|0xf0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
)paren
multiline_comment|/* f0 */
multiline_comment|/*      -------------------------------         */
multiline_comment|/*      0 1 2 3 4 5 6 7 8 9 a b c d e f         */
)brace
suffix:semicolon
r_static
r_const
id|u64
id|twobyte_has_modrm
(braket
l_int|256
op_div
l_int|64
)braket
op_assign
(brace
multiline_comment|/*      0 1 2 3 4 5 6 7 8 9 a b c d e f         */
multiline_comment|/*      -------------------------------         */
id|W
c_func
(paren
l_int|0x00
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
)paren
op_or
multiline_comment|/* 0f */
id|W
c_func
(paren
l_int|0x10
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
op_or
multiline_comment|/* 1f */
id|W
c_func
(paren
l_int|0x20
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
)paren
op_or
multiline_comment|/* 2f */
id|W
c_func
(paren
l_int|0x30
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
multiline_comment|/* 3f */
id|W
c_func
(paren
l_int|0x40
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
)paren
op_or
multiline_comment|/* 4f */
id|W
c_func
(paren
l_int|0x50
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
)paren
op_or
multiline_comment|/* 5f */
id|W
c_func
(paren
l_int|0x60
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
)paren
op_or
multiline_comment|/* 6f */
id|W
c_func
(paren
l_int|0x70
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
)paren
comma
multiline_comment|/* 7f */
id|W
c_func
(paren
l_int|0x80
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
op_or
multiline_comment|/* 8f */
id|W
c_func
(paren
l_int|0x90
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
)paren
op_or
multiline_comment|/* 9f */
id|W
c_func
(paren
l_int|0xa0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
)paren
op_or
multiline_comment|/* af */
id|W
c_func
(paren
l_int|0xb0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
)paren
comma
multiline_comment|/* bf */
id|W
c_func
(paren
l_int|0xc0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
op_or
multiline_comment|/* cf */
id|W
c_func
(paren
l_int|0xd0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
)paren
op_or
multiline_comment|/* df */
id|W
c_func
(paren
l_int|0xe0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
)paren
op_or
multiline_comment|/* ef */
id|W
c_func
(paren
l_int|0xf0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
)paren
multiline_comment|/* ff */
multiline_comment|/*      -------------------------------         */
multiline_comment|/*      0 1 2 3 4 5 6 7 8 9 a b c d e f         */
)brace
suffix:semicolon
DECL|macro|W
macro_line|#undef&t;W
r_int
id|need_modrm
suffix:semicolon
multiline_comment|/* Skip legacy instruction prefixes.  */
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_switch
c_cond
(paren
op_star
id|insn
)paren
(brace
r_case
l_int|0x66
suffix:colon
r_case
l_int|0x67
suffix:colon
r_case
l_int|0x2e
suffix:colon
r_case
l_int|0x3e
suffix:colon
r_case
l_int|0x26
suffix:colon
r_case
l_int|0x64
suffix:colon
r_case
l_int|0x65
suffix:colon
r_case
l_int|0x36
suffix:colon
r_case
l_int|0xf0
suffix:colon
r_case
l_int|0xf3
suffix:colon
r_case
l_int|0xf2
suffix:colon
op_increment
id|insn
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* Skip REX instruction prefix.  */
r_if
c_cond
(paren
(paren
op_star
id|insn
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x40
)paren
op_increment
id|insn
suffix:semicolon
r_if
c_cond
(paren
op_star
id|insn
op_eq
l_int|0x0f
)paren
(brace
multiline_comment|/* Two-byte opcode.  */
op_increment
id|insn
suffix:semicolon
id|need_modrm
op_assign
id|test_bit
c_func
(paren
op_star
id|insn
comma
id|twobyte_has_modrm
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* One-byte opcode.  */
id|need_modrm
op_assign
id|test_bit
c_func
(paren
op_star
id|insn
comma
id|onebyte_has_modrm
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|need_modrm
)paren
(brace
id|u8
id|modrm
op_assign
op_star
op_increment
id|insn
suffix:semicolon
r_if
c_cond
(paren
(paren
id|modrm
op_amp
l_int|0xc7
)paren
op_eq
l_int|0x05
)paren
(brace
multiline_comment|/* %rip+disp32 addressing mode */
multiline_comment|/* Displacement follows ModRM byte.  */
r_return
(paren
id|s32
op_star
)paren
op_increment
id|insn
suffix:semicolon
)brace
)brace
multiline_comment|/* No %rip-relative addressing mode here.  */
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|arch_copy_kprobe
r_void
id|arch_copy_kprobe
c_func
(paren
r_struct
id|kprobe
op_star
id|p
)paren
(brace
id|s32
op_star
id|ripdisp
suffix:semicolon
id|memcpy
c_func
(paren
id|p-&gt;ainsn.insn
comma
id|p-&gt;addr
comma
id|MAX_INSN_SIZE
)paren
suffix:semicolon
id|ripdisp
op_assign
id|is_riprel
c_func
(paren
id|p-&gt;ainsn.insn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ripdisp
)paren
(brace
multiline_comment|/*&n;&t;&t; * The copied instruction uses the %rip-relative&n;&t;&t; * addressing mode.  Adjust the displacement for the&n;&t;&t; * difference between the original location of this&n;&t;&t; * instruction and the location of the copy that will&n;&t;&t; * actually be run.  The tricky bit here is making sure&n;&t;&t; * that the sign extension happens correctly in this&n;&t;&t; * calculation, since we need a signed 32-bit result to&n;&t;&t; * be sign-extended to 64 bits when it&squot;s added to the&n;&t;&t; * %rip value and yield the same 64-bit result that the&n;&t;&t; * sign-extension of the original signed 32-bit&n;&t;&t; * displacement would have given.&n;&t;&t; */
id|s64
id|disp
op_assign
(paren
id|u8
op_star
)paren
id|p-&gt;addr
op_plus
op_star
id|ripdisp
op_minus
(paren
id|u8
op_star
)paren
id|p-&gt;ainsn.insn
suffix:semicolon
id|BUG_ON
c_func
(paren
(paren
id|s64
)paren
(paren
id|s32
)paren
id|disp
op_ne
id|disp
)paren
suffix:semicolon
multiline_comment|/* Sanity check.  */
op_star
id|ripdisp
op_assign
id|disp
suffix:semicolon
)brace
)brace
DECL|function|arch_remove_kprobe
r_void
id|arch_remove_kprobe
c_func
(paren
r_struct
id|kprobe
op_star
id|p
)paren
(brace
id|up
c_func
(paren
op_amp
id|kprobe_mutex
)paren
suffix:semicolon
id|free_insn_slot
c_func
(paren
id|p-&gt;ainsn.insn
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|kprobe_mutex
)paren
suffix:semicolon
)brace
DECL|function|disarm_kprobe
r_static
r_inline
r_void
id|disarm_kprobe
c_func
(paren
r_struct
id|kprobe
op_star
id|p
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
op_star
id|p-&gt;addr
op_assign
id|p-&gt;opcode
suffix:semicolon
id|regs-&gt;rip
op_assign
(paren
r_int
r_int
)paren
id|p-&gt;addr
suffix:semicolon
)brace
DECL|function|prepare_singlestep
r_static
r_void
id|prepare_singlestep
c_func
(paren
r_struct
id|kprobe
op_star
id|p
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|regs-&gt;eflags
op_or_assign
id|TF_MASK
suffix:semicolon
id|regs-&gt;eflags
op_and_assign
op_complement
id|IF_MASK
suffix:semicolon
multiline_comment|/*single step inline if the instruction is an int3*/
r_if
c_cond
(paren
id|p-&gt;opcode
op_eq
id|BREAKPOINT_INSTRUCTION
)paren
id|regs-&gt;rip
op_assign
(paren
r_int
r_int
)paren
id|p-&gt;addr
suffix:semicolon
r_else
id|regs-&gt;rip
op_assign
(paren
r_int
r_int
)paren
id|p-&gt;ainsn.insn
suffix:semicolon
)brace
multiline_comment|/*&n; * Interrupts are disabled on entry as trap3 is an interrupt gate and they&n; * remain disabled thorough out this function.&n; */
DECL|function|kprobe_handler
r_int
id|kprobe_handler
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|kprobe
op_star
id|p
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|kprobe_opcode_t
op_star
id|addr
op_assign
(paren
id|kprobe_opcode_t
op_star
)paren
(paren
id|regs-&gt;rip
op_minus
r_sizeof
(paren
id|kprobe_opcode_t
)paren
)paren
suffix:semicolon
multiline_comment|/* We&squot;re in an interrupt, but this is clear and BUG()-safe. */
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Check we&squot;re not actually recursing */
r_if
c_cond
(paren
id|kprobe_running
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* We *are* holding lock here, so this is safe.&n;&t;&t;   Disarm the probe we just hit, and ignore it. */
id|p
op_assign
id|get_kprobe
c_func
(paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
id|kprobe_status
op_eq
id|KPROBE_HIT_SS
)paren
(brace
id|regs-&gt;eflags
op_and_assign
op_complement
id|TF_MASK
suffix:semicolon
id|regs-&gt;eflags
op_or_assign
id|kprobe_saved_rflags
suffix:semicolon
id|unlock_kprobes
c_func
(paren
)paren
suffix:semicolon
r_goto
id|no_kprobe
suffix:semicolon
)brace
id|disarm_kprobe
c_func
(paren
id|p
comma
id|regs
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|p
op_assign
id|current_kprobe
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;break_handler
op_logical_and
id|p
op_member_access_from_pointer
id|break_handler
c_func
(paren
id|p
comma
id|regs
)paren
)paren
(brace
r_goto
id|ss_probe
suffix:semicolon
)brace
)brace
multiline_comment|/* If it&squot;s not ours, can&squot;t be delete race, (we hold lock). */
r_goto
id|no_kprobe
suffix:semicolon
)brace
id|lock_kprobes
c_func
(paren
)paren
suffix:semicolon
id|p
op_assign
id|get_kprobe
c_func
(paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|unlock_kprobes
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|addr
op_ne
id|BREAKPOINT_INSTRUCTION
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The breakpoint instruction was removed right&n;&t;&t;&t; * after we hit it.  Another cpu has removed&n;&t;&t;&t; * either a probepoint or a debugger breakpoint&n;&t;&t;&t; * at this address.  In either case, no further&n;&t;&t;&t; * handling of this interrupt is appropriate.&n;&t;&t;&t; */
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Not one of ours: let kernel handle it */
r_goto
id|no_kprobe
suffix:semicolon
)brace
id|kprobe_status
op_assign
id|KPROBE_HIT_ACTIVE
suffix:semicolon
id|current_kprobe
op_assign
id|p
suffix:semicolon
id|kprobe_saved_rflags
op_assign
id|kprobe_old_rflags
op_assign
(paren
id|regs-&gt;eflags
op_amp
(paren
id|TF_MASK
op_or
id|IF_MASK
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_IF_modifier
c_func
(paren
id|p-&gt;ainsn.insn
)paren
)paren
id|kprobe_saved_rflags
op_and_assign
op_complement
id|IF_MASK
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;pre_handler
op_logical_and
id|p
op_member_access_from_pointer
id|pre_handler
c_func
(paren
id|p
comma
id|regs
)paren
)paren
multiline_comment|/* handler has already set things up, so skip ss setup */
r_return
l_int|1
suffix:semicolon
id|ss_probe
suffix:colon
id|prepare_singlestep
c_func
(paren
id|p
comma
id|regs
)paren
suffix:semicolon
id|kprobe_status
op_assign
id|KPROBE_HIT_SS
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|no_kprobe
suffix:colon
id|preempt_enable_no_resched
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Called after single-stepping.  p-&gt;addr is the address of the&n; * instruction whose first byte has been replaced by the &quot;int 3&quot;&n; * instruction.  To avoid the SMP problems that can occur when we&n; * temporarily put back the original opcode to single-step, we&n; * single-stepped a copy of the instruction.  The address of this&n; * copy is p-&gt;ainsn.insn.&n; *&n; * This function prepares to return from the post-single-step&n; * interrupt.  We have to fix up the stack as follows:&n; *&n; * 0) Except in the case of absolute or indirect jump or call instructions,&n; * the new rip is relative to the copied instruction.  We need to make&n; * it relative to the original instruction.&n; *&n; * 1) If the single-stepped instruction was pushfl, then the TF and IF&n; * flags are set in the just-pushed eflags, and may need to be cleared.&n; *&n; * 2) If the single-stepped instruction was a call, the return address&n; * that is atop the stack is the address following the copied instruction.&n; * We need to make it the address following the original instruction.&n; */
DECL|function|resume_execution
r_static
r_void
id|resume_execution
c_func
(paren
r_struct
id|kprobe
op_star
id|p
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
op_star
id|tos
op_assign
(paren
r_int
r_int
op_star
)paren
id|regs-&gt;rsp
suffix:semicolon
r_int
r_int
id|next_rip
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|copy_rip
op_assign
(paren
r_int
r_int
)paren
id|p-&gt;ainsn.insn
suffix:semicolon
r_int
r_int
id|orig_rip
op_assign
(paren
r_int
r_int
)paren
id|p-&gt;addr
suffix:semicolon
id|kprobe_opcode_t
op_star
id|insn
op_assign
id|p-&gt;ainsn.insn
suffix:semicolon
multiline_comment|/*skip the REX prefix*/
r_if
c_cond
(paren
op_star
id|insn
op_ge
l_int|0x40
op_logical_and
op_star
id|insn
op_le
l_int|0x4f
)paren
id|insn
op_increment
suffix:semicolon
r_switch
c_cond
(paren
op_star
id|insn
)paren
(brace
r_case
l_int|0x9c
suffix:colon
multiline_comment|/* pushfl */
op_star
id|tos
op_and_assign
op_complement
(paren
id|TF_MASK
op_or
id|IF_MASK
)paren
suffix:semicolon
op_star
id|tos
op_or_assign
id|kprobe_old_rflags
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xe8
suffix:colon
multiline_comment|/* call relative - Fix return addr */
op_star
id|tos
op_assign
id|orig_rip
op_plus
(paren
op_star
id|tos
op_minus
id|copy_rip
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xff
suffix:colon
r_if
c_cond
(paren
(paren
op_star
id|insn
op_amp
l_int|0x30
)paren
op_eq
l_int|0x10
)paren
(brace
multiline_comment|/* call absolute, indirect */
multiline_comment|/* Fix return addr; rip is correct. */
id|next_rip
op_assign
id|regs-&gt;rip
suffix:semicolon
op_star
id|tos
op_assign
id|orig_rip
op_plus
(paren
op_star
id|tos
op_minus
id|copy_rip
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
op_star
id|insn
op_amp
l_int|0x31
)paren
op_eq
l_int|0x20
)paren
op_logical_or
multiline_comment|/* jmp near, absolute indirect */
(paren
(paren
op_star
id|insn
op_amp
l_int|0x31
)paren
op_eq
l_int|0x21
)paren
)paren
(brace
multiline_comment|/* jmp far, absolute indirect */
multiline_comment|/* rip is correct. */
id|next_rip
op_assign
id|regs-&gt;rip
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0xea
suffix:colon
multiline_comment|/* jmp absolute -- rip is correct */
id|next_rip
op_assign
id|regs-&gt;rip
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|regs-&gt;eflags
op_and_assign
op_complement
id|TF_MASK
suffix:semicolon
r_if
c_cond
(paren
id|next_rip
)paren
(brace
id|regs-&gt;rip
op_assign
id|next_rip
suffix:semicolon
)brace
r_else
(brace
id|regs-&gt;rip
op_assign
id|orig_rip
op_plus
(paren
id|regs-&gt;rip
op_minus
id|copy_rip
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Interrupts are disabled on entry as trap1 is an interrupt gate and they&n; * remain disabled thoroughout this function.  And we hold kprobe lock.&n; */
DECL|function|post_kprobe_handler
r_int
id|post_kprobe_handler
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|kprobe_running
c_func
(paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|current_kprobe-&gt;post_handler
)paren
id|current_kprobe
op_member_access_from_pointer
id|post_handler
c_func
(paren
id|current_kprobe
comma
id|regs
comma
l_int|0
)paren
suffix:semicolon
id|resume_execution
c_func
(paren
id|current_kprobe
comma
id|regs
)paren
suffix:semicolon
id|regs-&gt;eflags
op_or_assign
id|kprobe_saved_rflags
suffix:semicolon
id|unlock_kprobes
c_func
(paren
)paren
suffix:semicolon
id|preempt_enable_no_resched
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * if somebody else is singlestepping across a probe point, eflags&n;&t; * will have TF set, in which case, continue the remaining processing&n;&t; * of do_debug, as if this is not a probe hit.&n;&t; */
r_if
c_cond
(paren
id|regs-&gt;eflags
op_amp
id|TF_MASK
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Interrupts disabled, kprobe_lock held. */
DECL|function|kprobe_fault_handler
r_int
id|kprobe_fault_handler
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|trapnr
)paren
(brace
r_if
c_cond
(paren
id|current_kprobe-&gt;fault_handler
op_logical_and
id|current_kprobe
op_member_access_from_pointer
id|fault_handler
c_func
(paren
id|current_kprobe
comma
id|regs
comma
id|trapnr
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|kprobe_status
op_amp
id|KPROBE_HIT_SS
)paren
(brace
id|resume_execution
c_func
(paren
id|current_kprobe
comma
id|regs
)paren
suffix:semicolon
id|regs-&gt;eflags
op_or_assign
id|kprobe_old_rflags
suffix:semicolon
id|unlock_kprobes
c_func
(paren
)paren
suffix:semicolon
id|preempt_enable_no_resched
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Wrapper routine for handling exceptions.&n; */
DECL|function|kprobe_exceptions_notify
r_int
id|kprobe_exceptions_notify
c_func
(paren
r_struct
id|notifier_block
op_star
id|self
comma
r_int
r_int
id|val
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|die_args
op_star
id|args
op_assign
(paren
r_struct
id|die_args
op_star
)paren
id|data
suffix:semicolon
r_switch
c_cond
(paren
id|val
)paren
(brace
r_case
id|DIE_INT3
suffix:colon
r_if
c_cond
(paren
id|kprobe_handler
c_func
(paren
id|args-&gt;regs
)paren
)paren
r_return
id|NOTIFY_STOP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DIE_DEBUG
suffix:colon
r_if
c_cond
(paren
id|post_kprobe_handler
c_func
(paren
id|args-&gt;regs
)paren
)paren
r_return
id|NOTIFY_STOP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DIE_GPF
suffix:colon
r_if
c_cond
(paren
id|kprobe_running
c_func
(paren
)paren
op_logical_and
id|kprobe_fault_handler
c_func
(paren
id|args-&gt;regs
comma
id|args-&gt;trapnr
)paren
)paren
r_return
id|NOTIFY_STOP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DIE_PAGE_FAULT
suffix:colon
r_if
c_cond
(paren
id|kprobe_running
c_func
(paren
)paren
op_logical_and
id|kprobe_fault_handler
c_func
(paren
id|args-&gt;regs
comma
id|args-&gt;trapnr
)paren
)paren
r_return
id|NOTIFY_STOP
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
DECL|function|setjmp_pre_handler
r_int
id|setjmp_pre_handler
c_func
(paren
r_struct
id|kprobe
op_star
id|p
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|jprobe
op_star
id|jp
op_assign
id|container_of
c_func
(paren
id|p
comma
r_struct
id|jprobe
comma
id|kp
)paren
suffix:semicolon
r_int
r_int
id|addr
suffix:semicolon
id|jprobe_saved_regs
op_assign
op_star
id|regs
suffix:semicolon
id|jprobe_saved_rsp
op_assign
(paren
r_int
op_star
)paren
id|regs-&gt;rsp
suffix:semicolon
id|addr
op_assign
(paren
r_int
r_int
)paren
id|jprobe_saved_rsp
suffix:semicolon
multiline_comment|/*&n;&t; * As Linus pointed out, gcc assumes that the callee&n;&t; * owns the argument space and could overwrite it, e.g.&n;&t; * tailcall optimization. So, to be absolutely safe&n;&t; * we also save and restore enough stack bytes to cover&n;&t; * the argument area.&n;&t; */
id|memcpy
c_func
(paren
id|jprobes_stack
comma
(paren
id|kprobe_opcode_t
op_star
)paren
id|addr
comma
id|MIN_STACK_SIZE
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
id|regs-&gt;eflags
op_and_assign
op_complement
id|IF_MASK
suffix:semicolon
id|regs-&gt;rip
op_assign
(paren
r_int
r_int
)paren
(paren
id|jp-&gt;entry
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|jprobe_return
r_void
id|jprobe_return
c_func
(paren
r_void
)paren
(brace
id|preempt_enable_no_resched
c_func
(paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;       xchg   %%rbx,%%rsp     &bslash;n&quot;
l_string|&quot;       int3&t;&t;&t;&bslash;n&quot;
l_string|&quot;       .globl jprobe_return_end&t;&bslash;n&quot;
l_string|&quot;       jprobe_return_end:&t;&bslash;n&quot;
l_string|&quot;       nop&t;&t;&t;&bslash;n&quot;
op_scope_resolution
l_string|&quot;b&quot;
(paren
id|jprobe_saved_rsp
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
DECL|function|longjmp_break_handler
r_int
id|longjmp_break_handler
c_func
(paren
r_struct
id|kprobe
op_star
id|p
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|u8
op_star
id|addr
op_assign
(paren
id|u8
op_star
)paren
(paren
id|regs-&gt;rip
op_minus
l_int|1
)paren
suffix:semicolon
r_int
r_int
id|stack_addr
op_assign
(paren
r_int
r_int
)paren
id|jprobe_saved_rsp
suffix:semicolon
r_struct
id|jprobe
op_star
id|jp
op_assign
id|container_of
c_func
(paren
id|p
comma
r_struct
id|jprobe
comma
id|kp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr
OG
(paren
id|u8
op_star
)paren
id|jprobe_return
)paren
op_logical_and
(paren
id|addr
OL
(paren
id|u8
op_star
)paren
id|jprobe_return_end
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
op_star
)paren
id|regs-&gt;rsp
op_ne
id|jprobe_saved_rsp
)paren
(brace
r_struct
id|pt_regs
op_star
id|saved_regs
op_assign
id|container_of
c_func
(paren
id|jprobe_saved_rsp
comma
r_struct
id|pt_regs
comma
id|rsp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;current rsp %p does not match saved rsp %p&bslash;n&quot;
comma
(paren
r_int
op_star
)paren
id|regs-&gt;rsp
comma
id|jprobe_saved_rsp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Saved registers for jprobe %p&bslash;n&quot;
comma
id|jp
)paren
suffix:semicolon
id|show_registers
c_func
(paren
id|saved_regs
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Current registers&bslash;n&quot;
)paren
suffix:semicolon
id|show_registers
c_func
(paren
id|regs
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
op_star
id|regs
op_assign
id|jprobe_saved_regs
suffix:semicolon
id|memcpy
c_func
(paren
(paren
id|kprobe_opcode_t
op_star
)paren
id|stack_addr
comma
id|jprobes_stack
comma
id|MIN_STACK_SIZE
c_func
(paren
id|stack_addr
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * kprobe-&gt;ainsn.insn points to the copy of the instruction to be single-stepped.&n; * By default on x86_64, pages we get from kmalloc or vmalloc are not&n; * executable.  Single-stepping an instruction on such a page yields an&n; * oops.  So instead of storing the instruction copies in their respective&n; * kprobe objects, we allocate a page, map it executable, and store all the&n; * instruction copies there.  (We can allocate additional pages if somebody&n; * inserts a huge number of probes.)  Each page can hold up to INSNS_PER_PAGE&n; * instruction slots, each of which is MAX_INSN_SIZE*sizeof(kprobe_opcode_t)&n; * bytes.&n; */
DECL|macro|INSNS_PER_PAGE
mdefine_line|#define INSNS_PER_PAGE (PAGE_SIZE/(MAX_INSN_SIZE*sizeof(kprobe_opcode_t)))
DECL|struct|kprobe_insn_page
r_struct
id|kprobe_insn_page
(brace
DECL|member|hlist
r_struct
id|hlist_node
id|hlist
suffix:semicolon
DECL|member|insns
id|kprobe_opcode_t
op_star
id|insns
suffix:semicolon
multiline_comment|/* page of instruction slots */
DECL|member|slot_used
r_char
id|slot_used
(braket
id|INSNS_PER_PAGE
)braket
suffix:semicolon
DECL|member|nused
r_int
id|nused
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|kprobe_insn_pages
r_static
r_struct
id|hlist_head
id|kprobe_insn_pages
suffix:semicolon
multiline_comment|/**&n; * get_insn_slot() - Find a slot on an executable page for an instruction.&n; * We allocate an executable page if there&squot;s no room on existing ones.&n; */
DECL|function|get_insn_slot
r_static
id|kprobe_opcode_t
op_star
id|get_insn_slot
c_func
(paren
r_void
)paren
(brace
r_struct
id|kprobe_insn_page
op_star
id|kip
suffix:semicolon
r_struct
id|hlist_node
op_star
id|pos
suffix:semicolon
id|hlist_for_each
c_func
(paren
id|pos
comma
op_amp
id|kprobe_insn_pages
)paren
(brace
id|kip
op_assign
id|hlist_entry
c_func
(paren
id|pos
comma
r_struct
id|kprobe_insn_page
comma
id|hlist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kip-&gt;nused
OL
id|INSNS_PER_PAGE
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INSNS_PER_PAGE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|kip-&gt;slot_used
(braket
id|i
)braket
)paren
(brace
id|kip-&gt;slot_used
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
id|kip-&gt;nused
op_increment
suffix:semicolon
r_return
id|kip-&gt;insns
op_plus
(paren
id|i
op_star
id|MAX_INSN_SIZE
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Surprise!  No unused slots.  Fix kip-&gt;nused. */
id|kip-&gt;nused
op_assign
id|INSNS_PER_PAGE
suffix:semicolon
)brace
)brace
multiline_comment|/* All out of space.  Need to allocate a new page. Use slot 0.*/
id|kip
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|kprobe_insn_page
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kip
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * For the %rip-relative displacement fixups to be doable, we&n;&t; * need our instruction copy to be within +/- 2GB of any data it&n;&t; * might access via %rip.  That is, within 2GB of where the&n;&t; * kernel image and loaded module images reside.  So we allocate&n;&t; * a page in the module loading area.&n;&t; */
id|kip-&gt;insns
op_assign
id|module_alloc
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kip-&gt;insns
)paren
(brace
id|kfree
c_func
(paren
id|kip
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|INIT_HLIST_NODE
c_func
(paren
op_amp
id|kip-&gt;hlist
)paren
suffix:semicolon
id|hlist_add_head
c_func
(paren
op_amp
id|kip-&gt;hlist
comma
op_amp
id|kprobe_insn_pages
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kip-&gt;slot_used
comma
l_int|0
comma
id|INSNS_PER_PAGE
)paren
suffix:semicolon
id|kip-&gt;slot_used
(braket
l_int|0
)braket
op_assign
l_int|1
suffix:semicolon
id|kip-&gt;nused
op_assign
l_int|1
suffix:semicolon
r_return
id|kip-&gt;insns
suffix:semicolon
)brace
multiline_comment|/**&n; * free_insn_slot() - Free instruction slot obtained from get_insn_slot().&n; */
DECL|function|free_insn_slot
r_static
r_void
id|free_insn_slot
c_func
(paren
id|kprobe_opcode_t
op_star
id|slot
)paren
(brace
r_struct
id|kprobe_insn_page
op_star
id|kip
suffix:semicolon
r_struct
id|hlist_node
op_star
id|pos
suffix:semicolon
id|hlist_for_each
c_func
(paren
id|pos
comma
op_amp
id|kprobe_insn_pages
)paren
(brace
id|kip
op_assign
id|hlist_entry
c_func
(paren
id|pos
comma
r_struct
id|kprobe_insn_page
comma
id|hlist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kip-&gt;insns
op_le
id|slot
op_logical_and
id|slot
OL
id|kip-&gt;insns
op_plus
(paren
id|INSNS_PER_PAGE
op_star
id|MAX_INSN_SIZE
)paren
)paren
(brace
r_int
id|i
op_assign
(paren
id|slot
op_minus
id|kip-&gt;insns
)paren
op_div
id|MAX_INSN_SIZE
suffix:semicolon
id|kip-&gt;slot_used
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|kip-&gt;nused
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|kip-&gt;nused
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Page is no longer in use.  Free it unless&n;&t;&t;&t;&t; * it&squot;s the last one.  We keep the last one&n;&t;&t;&t;&t; * so as not to have to set it up again the&n;&t;&t;&t;&t; * next time somebody inserts a probe.&n;&t;&t;&t;&t; */
id|hlist_del
c_func
(paren
op_amp
id|kip-&gt;hlist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hlist_empty
c_func
(paren
op_amp
id|kprobe_insn_pages
)paren
)paren
(brace
id|INIT_HLIST_NODE
c_func
(paren
op_amp
id|kip-&gt;hlist
)paren
suffix:semicolon
id|hlist_add_head
c_func
(paren
op_amp
id|kip-&gt;hlist
comma
op_amp
id|kprobe_insn_pages
)paren
suffix:semicolon
)brace
r_else
(brace
id|module_free
c_func
(paren
l_int|NULL
comma
id|kip-&gt;insns
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|kip
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
)brace
)brace
eof
