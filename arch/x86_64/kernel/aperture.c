multiline_comment|/* &n; * Firmware replacement code.&n; * &n; * Work around broken BIOSes that don&squot;t set an aperture or only set the&n; * aperture in the AGP bridge. &n; * If all fails map the aperture over some low memory.  This is cheaper than &n; * doing bounce buffering. The memory is lost. This is done at early boot &n; * because only the bootmem allocator can allocate 32+MB. &n; * &n; * Copyright 2002 Andi Kleen, SuSE Labs.&n; * $Id: aperture.c,v 1.7 2003/08/01 03:36:18 ak Exp $&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/mmzone.h&gt;
macro_line|#include &lt;linux/pci_ids.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;asm/e820.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/proto.h&gt;
macro_line|#include &lt;asm/pci-direct.h&gt;
DECL|variable|iommu_aperture
r_int
id|iommu_aperture
suffix:semicolon
DECL|variable|__initdata
r_int
id|iommu_aperture_disabled
id|__initdata
op_assign
l_int|0
suffix:semicolon
DECL|variable|__initdata
r_int
id|iommu_aperture_allowed
id|__initdata
op_assign
l_int|0
suffix:semicolon
DECL|variable|__initdata
r_int
id|fallback_aper_order
id|__initdata
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* 64MB */
DECL|variable|__initdata
r_int
id|fallback_aper_force
id|__initdata
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This code runs before the PCI subsystem is initialized, so just &n;   access the northbridge directly. */
DECL|macro|NB_ID_3
mdefine_line|#define NB_ID_3 (PCI_VENDOR_ID_AMD | (0x1103&lt;&lt;16))
DECL|function|allocate_aperture
r_static
id|u32
id|__init
id|allocate_aperture
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_DISCONTIGMEM
id|pg_data_t
op_star
id|nd0
op_assign
id|NODE_DATA
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#else
id|pg_data_t
op_star
id|nd0
op_assign
op_amp
id|contig_page_data
suffix:semicolon
macro_line|#endif&t;
id|u32
id|aper_size
suffix:semicolon
r_void
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|fallback_aper_order
OG
l_int|7
)paren
id|fallback_aper_order
op_assign
l_int|7
suffix:semicolon
id|aper_size
op_assign
(paren
l_int|32
op_star
l_int|1024
op_star
l_int|1024
)paren
op_lshift
id|fallback_aper_order
suffix:semicolon
multiline_comment|/* &n;&t; * Aperture has to be naturally aligned. This means an 2GB aperture won&squot;t &n;&t; * have much chances to find a place in the lower 4GB of memory. &n;&t; * Unfortunately we cannot move it up because that would make the &n;&t; * IOMMU useless.&n;&t; */
id|p
op_assign
id|__alloc_bootmem_node
c_func
(paren
id|nd0
comma
id|aper_size
comma
id|aper_size
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
op_logical_or
id|__pa
c_func
(paren
id|p
)paren
op_plus
id|aper_size
OG
l_int|0xffffffff
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Cannot allocate aperture memory hole (%p,%uK)&bslash;n&quot;
comma
id|p
comma
id|aper_size
op_rshift
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|free_bootmem_node
c_func
(paren
id|nd0
comma
(paren
r_int
r_int
)paren
id|p
comma
id|aper_size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Mapping aperture over %d KB of RAM @ %lx&bslash;n&quot;
comma
id|aper_size
op_rshift
l_int|10
comma
id|__pa
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
r_return
(paren
id|u32
)paren
id|__pa
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
DECL|function|aperture_valid
r_static
r_int
id|__init
id|aperture_valid
c_func
(paren
r_char
op_star
id|name
comma
id|u64
id|aper_base
comma
id|u32
id|aper_size
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|aper_base
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|aper_size
OL
l_int|64
op_star
l_int|1024
op_star
l_int|1024
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Aperture from %s too small (%d MB)&bslash;n&quot;
comma
id|name
comma
id|aper_size
op_rshift
l_int|20
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aper_base
op_plus
id|aper_size
op_ge
l_int|0xffffffff
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Aperture from %s beyond 4GB. Ignoring.&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e820_mapped
c_func
(paren
id|aper_base
comma
id|aper_base
op_plus
id|aper_size
comma
id|E820_RAM
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Aperture from %s pointing to e820 RAM. Ignoring.&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Find a PCI capability */
DECL|function|find_cap
r_static
id|__u32
id|__init
id|find_cap
c_func
(paren
r_int
id|num
comma
r_int
id|slot
comma
r_int
id|func
comma
r_int
id|cap
)paren
(brace
id|u8
id|pos
suffix:semicolon
r_int
id|bytes
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|read_pci_config_16
c_func
(paren
id|num
comma
id|slot
comma
id|func
comma
id|PCI_STATUS
)paren
op_amp
id|PCI_STATUS_CAP_LIST
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|pos
op_assign
id|read_pci_config_byte
c_func
(paren
id|num
comma
id|slot
comma
id|func
comma
id|PCI_CAPABILITY_LIST
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bytes
op_assign
l_int|0
suffix:semicolon
id|bytes
OL
l_int|48
op_logical_and
id|pos
op_ge
l_int|0x40
suffix:semicolon
id|bytes
op_increment
)paren
(brace
id|u8
id|id
suffix:semicolon
id|pos
op_and_assign
op_complement
l_int|3
suffix:semicolon
id|id
op_assign
id|read_pci_config_byte
c_func
(paren
id|num
comma
id|slot
comma
id|func
comma
id|pos
op_plus
id|PCI_CAP_LIST_ID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
op_eq
l_int|0xff
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|id
op_eq
id|cap
)paren
r_return
id|pos
suffix:semicolon
id|pos
op_assign
id|read_pci_config_byte
c_func
(paren
id|num
comma
id|slot
comma
id|func
comma
id|pos
op_plus
id|PCI_CAP_LIST_NEXT
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Read a standard AGPv3 bridge header */
DECL|function|read_agp
r_static
id|__u32
id|__init
id|read_agp
c_func
(paren
r_int
id|num
comma
r_int
id|slot
comma
r_int
id|func
comma
r_int
id|cap
comma
id|u32
op_star
id|order
)paren
(brace
id|u32
id|apsize
suffix:semicolon
id|u32
id|apsizereg
suffix:semicolon
r_int
id|nbits
suffix:semicolon
id|u32
id|aper_low
comma
id|aper_hi
suffix:semicolon
id|u64
id|aper
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;AGP bridge at %02x:%02x:%02x&bslash;n&quot;
comma
id|num
comma
id|slot
comma
id|func
)paren
suffix:semicolon
id|apsizereg
op_assign
id|read_pci_config_16
c_func
(paren
id|num
comma
id|slot
comma
id|func
comma
id|cap
op_plus
l_int|0x14
)paren
suffix:semicolon
r_if
c_cond
(paren
id|apsizereg
op_eq
l_int|0xffffffff
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;APSIZE in AGP bridge unreadable&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|apsize
op_assign
id|apsizereg
op_amp
l_int|0xfff
suffix:semicolon
multiline_comment|/* Some BIOS use weird encodings not in the AGPv3 table. */
r_if
c_cond
(paren
id|apsize
op_amp
l_int|0xff
)paren
id|apsize
op_or_assign
l_int|0xf00
suffix:semicolon
id|nbits
op_assign
id|hweight16
c_func
(paren
id|apsize
)paren
suffix:semicolon
op_star
id|order
op_assign
l_int|7
op_minus
id|nbits
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
op_star
id|order
OL
l_int|0
)paren
multiline_comment|/* &lt; 32MB */
op_star
id|order
op_assign
l_int|0
suffix:semicolon
id|aper_low
op_assign
id|read_pci_config
c_func
(paren
id|num
comma
id|slot
comma
id|func
comma
l_int|0x10
)paren
suffix:semicolon
id|aper_hi
op_assign
id|read_pci_config
c_func
(paren
id|num
comma
id|slot
comma
id|func
comma
l_int|0x14
)paren
suffix:semicolon
id|aper
op_assign
(paren
id|aper_low
op_amp
op_complement
(paren
(paren
l_int|1
op_lshift
l_int|22
)paren
op_minus
l_int|1
)paren
)paren
op_or
(paren
(paren
id|u64
)paren
id|aper_hi
op_lshift
l_int|32
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Aperture from AGP @ %Lx size %u MB (APSIZE %x)&bslash;n&quot;
comma
id|aper
comma
l_int|32
op_lshift
op_star
id|order
comma
id|apsizereg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|aperture_valid
c_func
(paren
l_string|&quot;AGP bridge&quot;
comma
id|aper
comma
(paren
l_int|32
op_star
l_int|1024
op_star
l_int|1024
)paren
op_lshift
op_star
id|order
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
(paren
id|u32
)paren
id|aper
suffix:semicolon
)brace
multiline_comment|/* Look for an AGP bridge. Windows only expects the aperture in the&n;   AGP bridge and some BIOS forget to initialize the Northbridge too.&n;   Work around this here. &n;&n;   Do an PCI bus scan by hand because we&squot;re running before the PCI&n;   subsystem. &n;&n;   All K8 AGP bridges are AGPv3 compliant, so we can do this scan&n;   generically. It&squot;s probably overkill to always scan all slots because&n;   the AGP bridges should be always an own bus on the HT hierarchy, &n;   but do it here for future safety. */
DECL|function|search_agp_bridge
r_static
id|__u32
id|__init
id|search_agp_bridge
c_func
(paren
id|u32
op_star
id|order
comma
r_int
op_star
id|valid_agp
)paren
(brace
r_int
id|num
comma
id|slot
comma
id|func
suffix:semicolon
multiline_comment|/* Poor man&squot;s PCI discovery */
r_for
c_loop
(paren
id|num
op_assign
l_int|0
suffix:semicolon
id|num
OL
l_int|32
suffix:semicolon
id|num
op_increment
)paren
(brace
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|32
suffix:semicolon
id|slot
op_increment
)paren
(brace
r_for
c_loop
(paren
id|func
op_assign
l_int|0
suffix:semicolon
id|func
OL
l_int|8
suffix:semicolon
id|func
op_increment
)paren
(brace
id|u32
r_class
comma
id|cap
suffix:semicolon
id|u8
id|type
suffix:semicolon
r_class
op_assign
id|read_pci_config
c_func
(paren
id|num
comma
id|slot
comma
id|func
comma
id|PCI_CLASS_REVISION
)paren
suffix:semicolon
r_if
c_cond
(paren
r_class
op_eq
l_int|0xffffffff
)paren
r_break
suffix:semicolon
r_switch
c_cond
(paren
r_class
op_rshift
l_int|16
)paren
(brace
r_case
id|PCI_CLASS_BRIDGE_HOST
suffix:colon
r_case
id|PCI_CLASS_BRIDGE_OTHER
suffix:colon
multiline_comment|/* needed? */
multiline_comment|/* AGP bridge? */
id|cap
op_assign
id|find_cap
c_func
(paren
id|num
comma
id|slot
comma
id|func
comma
id|PCI_CAP_ID_AGP
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cap
)paren
r_break
suffix:semicolon
op_star
id|valid_agp
op_assign
l_int|1
suffix:semicolon
r_return
id|read_agp
c_func
(paren
id|num
comma
id|slot
comma
id|func
comma
id|cap
comma
id|order
)paren
suffix:semicolon
)brace
multiline_comment|/* No multi-function device? */
id|type
op_assign
id|read_pci_config_byte
c_func
(paren
id|num
comma
id|slot
comma
id|func
comma
id|PCI_HEADER_TYPE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|type
op_amp
l_int|0x80
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;No AGP bridge found&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|iommu_hole_init
r_void
id|__init
id|iommu_hole_init
c_func
(paren
r_void
)paren
(brace
r_int
id|fix
comma
id|num
suffix:semicolon
id|u32
id|aper_size
comma
id|aper_alloc
op_assign
l_int|0
comma
id|aper_order
suffix:semicolon
id|u64
id|aper_base
suffix:semicolon
r_int
id|valid_agp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|iommu_aperture_disabled
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Checking aperture...&bslash;n&quot;
)paren
suffix:semicolon
id|fix
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|num
op_assign
l_int|24
suffix:semicolon
id|num
OL
l_int|32
suffix:semicolon
id|num
op_increment
)paren
(brace
r_char
id|name
(braket
l_int|30
)braket
suffix:semicolon
r_if
c_cond
(paren
id|read_pci_config
c_func
(paren
l_int|0
comma
id|num
comma
l_int|3
comma
l_int|0x00
)paren
op_ne
id|NB_ID_3
)paren
r_continue
suffix:semicolon
id|iommu_aperture
op_assign
l_int|1
suffix:semicolon
id|aper_order
op_assign
(paren
id|read_pci_config
c_func
(paren
l_int|0
comma
id|num
comma
l_int|3
comma
l_int|0x90
)paren
op_rshift
l_int|1
)paren
op_amp
l_int|7
suffix:semicolon
id|aper_size
op_assign
(paren
l_int|32
op_star
l_int|1024
op_star
l_int|1024
)paren
op_lshift
id|aper_order
suffix:semicolon
id|aper_base
op_assign
id|read_pci_config
c_func
(paren
l_int|0
comma
id|num
comma
l_int|3
comma
l_int|0x94
)paren
op_amp
l_int|0x7fff
suffix:semicolon
id|aper_base
op_lshift_assign
l_int|25
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CPU %d: aperture @ %Lx size %u MB&bslash;n&quot;
comma
id|num
op_minus
l_int|24
comma
id|aper_base
comma
id|aper_size
op_rshift
l_int|20
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;northbridge cpu %d&quot;
comma
id|num
op_minus
l_int|24
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|aperture_valid
c_func
(paren
id|name
comma
id|aper_base
comma
id|aper_size
)paren
)paren
(brace
id|fix
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|fix
op_logical_and
op_logical_neg
id|fallback_aper_force
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fallback_aper_force
)paren
id|aper_alloc
op_assign
id|search_agp_bridge
c_func
(paren
op_amp
id|aper_order
comma
op_amp
id|valid_agp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aper_alloc
)paren
(brace
multiline_comment|/* Got the aperture from the AGP bridge */
)brace
r_else
r_if
c_cond
(paren
(paren
op_logical_neg
id|no_iommu
op_logical_and
id|end_pfn
op_ge
l_int|0xffffffff
op_rshift
id|PAGE_SHIFT
)paren
op_logical_or
id|force_iommu
op_logical_or
id|valid_agp
op_logical_or
id|fallback_aper_force
)paren
(brace
multiline_comment|/* When there is a AGP bridge in the system assume the&n;&t;&t;   user wants to use the AGP driver too and needs an&n;&t;&t;   aperture.  However this case (AGP but no good&n;&t;&t;   aperture) should only happen with a more broken than&n;&t;&t;   usual BIOS, because it would even break Windows. */
id|printk
c_func
(paren
l_string|&quot;Your BIOS doesn&squot;t leave a aperture memory hole&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Please enable the IOMMU option in the BIOS setup&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;This costs you %d MB of RAM&bslash;n&quot;
comma
l_int|32
op_lshift
id|fallback_aper_order
)paren
suffix:semicolon
id|aper_order
op_assign
id|fallback_aper_order
suffix:semicolon
id|aper_alloc
op_assign
id|allocate_aperture
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|aper_alloc
)paren
(brace
multiline_comment|/* Could disable AGP and IOMMU here, but it&squot;s probably&n;&t;&t;&t;   not worth it. But the later users cannot deal with&n;&t;&t;&t;   bad apertures and turning on the aperture over memory&n;&t;&t;&t;   causes very strange problems, so it&squot;s better to &n;&t;&t;&t;   panic early. */
id|panic
c_func
(paren
l_string|&quot;Not enough memory for aperture&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Fix up the north bridges */
r_for
c_loop
(paren
id|num
op_assign
l_int|24
suffix:semicolon
id|num
OL
l_int|32
suffix:semicolon
id|num
op_increment
)paren
(brace
r_if
c_cond
(paren
id|read_pci_config
c_func
(paren
l_int|0
comma
id|num
comma
l_int|3
comma
l_int|0x00
)paren
op_ne
id|NB_ID_3
)paren
r_continue
suffix:semicolon
multiline_comment|/* Don&squot;t enable translation yet. That is done later. &n;&t;&t;   Assume this BIOS didn&squot;t initialise the GART so &n;&t;&t;   just overwrite all previous bits */
id|write_pci_config
c_func
(paren
l_int|0
comma
id|num
comma
l_int|3
comma
l_int|0x90
comma
id|aper_order
op_lshift
l_int|1
)paren
suffix:semicolon
id|write_pci_config
c_func
(paren
l_int|0
comma
id|num
comma
l_int|3
comma
l_int|0x94
comma
id|aper_alloc
op_rshift
l_int|25
)paren
suffix:semicolon
)brace
)brace
eof
