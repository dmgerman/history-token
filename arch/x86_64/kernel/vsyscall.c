multiline_comment|/*&n; *  linux/arch/x86_64/kernel/vsyscall.c&n; *&n; *  Copyright (C) 2001 Andrea Arcangeli &lt;andrea@suse.de&gt; SuSE&n; *  Copyright 2003 Andi Kleen, SuSE Labs.&n; *&n; *  Thanks to hpa@transmeta.com for some useful hint.&n; *  Special thanks to Ingo Molnar for his early experience with&n; *  a different vsyscall implementation for Linux/IA32 and for the name.&n; *&n; *  vsyscall 1 is located at -10Mbyte, vsyscall 2 is located&n; *  at virtual address -10Mbyte+1024bytes etc... There are at max 8192&n; *  vsyscalls. One vsyscall can reserve more than 1 slot to avoid&n; *  jumping out of line if necessary.&n; *&n; *  Note: the concept clashes with user mode linux. If you use UML just&n; *  set the kernel.vsyscall sysctl to 0.&n; */
multiline_comment|/*&n; * TODO 2001-03-20:&n; *&n; * 1) make page fault handler detect faults on page1-page-last of the vsyscall&n; *    virtual space, and make it increase %rip and write -ENOSYS in %rax (so&n; *    we&squot;ll be able to upgrade to a new glibc without upgrading kernel after&n; *    we add more vsyscalls.&n; * 2) Possibly we need a fixmap table for the vsyscalls too if we want&n; *    to avoid SIGSEGV and we want to return -EFAULT from the vsyscalls as well.&n; *    Can we segfault inside a &quot;syscall&quot;? We can fix this anytime and those fixes&n; *    won&squot;t be visible for userspace. Not fixing this is a noop for correct programs,&n; *    broken programs will segfault and there&squot;s no security risk until we choose to&n; *    fix it.&n; *&n; * These are not urgent things that we need to address only before shipping the first&n; * production binary kernels.&n; */
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/seqlock.h&gt;
macro_line|#include &lt;linux/jiffies.h&gt;
macro_line|#include &lt;asm/vsyscall.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/fixmap.h&gt;
macro_line|#include &lt;asm/errno.h&gt;
macro_line|#include &lt;asm/io.h&gt;
DECL|macro|__vsyscall
mdefine_line|#define __vsyscall(nr) __attribute__ ((unused,__section__(&quot;.vsyscall_&quot; #nr)))
DECL|macro|force_inline
mdefine_line|#define force_inline __attribute__((always_inline)) inline
DECL|variable|__section_sysctl_vsyscall
r_int
id|__sysctl_vsyscall
id|__section_sysctl_vsyscall
op_assign
l_int|1
suffix:semicolon
DECL|variable|__section_xtime_lock
id|seqlock_t
id|__xtime_lock
id|__section_xtime_lock
op_assign
id|SEQLOCK_UNLOCKED
suffix:semicolon
macro_line|#include &lt;asm/unistd.h&gt;
DECL|function|timeval_normalize
r_static
id|force_inline
r_void
id|timeval_normalize
c_func
(paren
r_struct
id|timeval
op_star
id|tv
)paren
(brace
id|time_t
id|__sec
suffix:semicolon
id|__sec
op_assign
id|tv-&gt;tv_usec
op_div
l_int|1000000
suffix:semicolon
r_if
c_cond
(paren
id|__sec
)paren
(brace
id|tv-&gt;tv_usec
op_mod_assign
l_int|1000000
suffix:semicolon
id|tv-&gt;tv_sec
op_add_assign
id|__sec
suffix:semicolon
)brace
)brace
DECL|function|do_vgettimeofday
r_static
id|force_inline
r_void
id|do_vgettimeofday
c_func
(paren
r_struct
id|timeval
op_star
id|tv
)paren
(brace
r_int
id|sequence
comma
id|t
suffix:semicolon
r_int
r_int
id|sec
comma
id|usec
suffix:semicolon
r_do
(brace
id|sequence
op_assign
id|read_seqbegin
c_func
(paren
op_amp
id|__xtime_lock
)paren
suffix:semicolon
id|sec
op_assign
id|__xtime.tv_sec
suffix:semicolon
id|usec
op_assign
(paren
id|__xtime.tv_nsec
op_div
l_int|1000
)paren
op_plus
(paren
id|__jiffies
op_minus
id|__wall_jiffies
)paren
op_star
(paren
l_int|1000000
op_div
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__vxtime.mode
op_eq
id|VXTIME_TSC
)paren
(brace
id|sync_core
c_func
(paren
)paren
suffix:semicolon
id|rdtscll
c_func
(paren
id|t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
OL
id|__vxtime.last_tsc
)paren
id|t
op_assign
id|__vxtime.last_tsc
suffix:semicolon
id|usec
op_add_assign
(paren
(paren
id|t
op_minus
id|__vxtime.last_tsc
)paren
op_star
id|__vxtime.tsc_quot
)paren
op_rshift
l_int|32
suffix:semicolon
multiline_comment|/* See comment in x86_64 do_gettimeofday. */
)brace
r_else
(brace
id|usec
op_add_assign
(paren
(paren
id|readl
c_func
(paren
(paren
r_void
op_star
)paren
id|fix_to_virt
c_func
(paren
id|VSYSCALL_HPET
)paren
op_plus
l_int|0xf0
)paren
op_minus
id|__vxtime.last
)paren
op_star
id|__vxtime.quot
)paren
op_rshift
l_int|32
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|read_seqretry
c_func
(paren
op_amp
id|__xtime_lock
comma
id|sequence
)paren
)paren
suffix:semicolon
id|tv-&gt;tv_sec
op_assign
id|sec
op_plus
id|usec
op_div
l_int|1000000
suffix:semicolon
id|tv-&gt;tv_usec
op_assign
id|usec
op_mod
l_int|1000000
suffix:semicolon
)brace
multiline_comment|/* RED-PEN may want to readd seq locking, but then the variable should be write-once. */
DECL|function|do_get_tz
r_static
id|force_inline
r_void
id|do_get_tz
c_func
(paren
r_struct
id|timezone
op_star
id|tz
)paren
(brace
op_star
id|tz
op_assign
id|__sys_tz
suffix:semicolon
)brace
DECL|function|gettimeofday
r_static
id|force_inline
r_int
id|gettimeofday
c_func
(paren
r_struct
id|timeval
op_star
id|tv
comma
r_struct
id|timezone
op_star
id|tz
)paren
(brace
r_int
id|ret
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;syscall&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|ret
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|__NR_gettimeofday
)paren
comma
l_string|&quot;D&quot;
(paren
id|tv
)paren
comma
l_string|&quot;S&quot;
(paren
id|tz
)paren
suffix:colon
id|__syscall_clobber
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|time_syscall
r_static
id|force_inline
r_int
id|time_syscall
c_func
(paren
r_int
op_star
id|t
)paren
(brace
r_int
id|secs
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;syscall&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|secs
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|__NR_time
)paren
comma
l_string|&quot;D&quot;
(paren
id|t
)paren
suffix:colon
id|__syscall_clobber
)paren
suffix:semicolon
r_return
id|secs
suffix:semicolon
)brace
DECL|function|vgettimeofday
r_static
r_int
id|__vsyscall
c_func
(paren
l_int|0
)paren
id|vgettimeofday
c_func
(paren
r_struct
id|timeval
op_star
id|tv
comma
r_struct
id|timezone
op_star
id|tz
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|__sysctl_vsyscall
)paren
)paren
r_return
id|gettimeofday
c_func
(paren
id|tv
comma
id|tz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tv
)paren
id|do_vgettimeofday
c_func
(paren
id|tv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tz
)paren
id|do_get_tz
c_func
(paren
id|tz
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This will break when the xtime seconds get inaccurate, but that is&n; * unlikely */
DECL|function|vtime
r_static
id|time_t
id|__vsyscall
c_func
(paren
l_int|1
)paren
id|vtime
c_func
(paren
id|time_t
op_star
id|t
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|__sysctl_vsyscall
)paren
)paren
r_return
id|time_syscall
c_func
(paren
id|t
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|t
)paren
op_star
id|t
op_assign
id|__xtime.tv_sec
suffix:semicolon
r_return
id|__xtime.tv_sec
suffix:semicolon
)brace
DECL|function|venosys_0
r_static
r_int
id|__vsyscall
c_func
(paren
l_int|2
)paren
id|venosys_0
c_func
(paren
r_void
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
DECL|function|venosys_1
r_static
r_int
id|__vsyscall
c_func
(paren
l_int|3
)paren
id|venosys_1
c_func
(paren
r_void
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
DECL|function|map_vsyscall
r_static
r_void
id|__init
id|map_vsyscall
c_func
(paren
r_void
)paren
(brace
r_extern
r_char
id|__vsyscall_0
suffix:semicolon
r_int
r_int
id|physaddr_page0
op_assign
id|__pa_symbol
c_func
(paren
op_amp
id|__vsyscall_0
)paren
suffix:semicolon
id|__set_fixmap
c_func
(paren
id|VSYSCALL_FIRST_PAGE
comma
id|physaddr_page0
comma
id|PAGE_KERNEL_VSYSCALL
)paren
suffix:semicolon
)brace
DECL|function|vsyscall_init
r_static
r_int
id|__init
id|vsyscall_init
c_func
(paren
r_void
)paren
(brace
id|BUG_ON
c_func
(paren
(paren
(paren
r_int
r_int
)paren
op_amp
id|vgettimeofday
op_ne
id|VSYSCALL_ADDR
c_func
(paren
id|__NR_vgettimeofday
)paren
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|vtime
op_ne
id|VSYSCALL_ADDR
c_func
(paren
id|__NR_vtime
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
(paren
id|VSYSCALL_ADDR
c_func
(paren
l_int|0
)paren
op_ne
id|__fix_to_virt
c_func
(paren
id|VSYSCALL_FIRST_PAGE
)paren
)paren
)paren
suffix:semicolon
id|map_vsyscall
c_func
(paren
)paren
suffix:semicolon
id|sysctl_vsyscall
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|vsyscall_init
id|__initcall
c_func
(paren
id|vsyscall_init
)paren
suffix:semicolon
eof
