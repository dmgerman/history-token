multiline_comment|/*&n; *  linux/arch/x86-64/traps.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; *  Copyright (C) 2000, 2001, 2002 Andi Kleen, SuSE Labs&n; *&n; *  Pentium III FXSR, SSE support&n; *&t;Gareth Hughes &lt;gareth@valinux.com&gt;, May 2000&n; *&n; *  $Id: traps.c,v 1.36 2002/03/24 11:09:10 ak Exp $&n; */
multiline_comment|/*&n; * &squot;Traps.c&squot; handles hardware traps and faults after we have saved some&n; * state in &squot;entry.S&squot;.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/debugreg.h&gt;
macro_line|#include &lt;asm/desc.h&gt;
macro_line|#include &lt;asm/i387.h&gt;
macro_line|#include &lt;asm/kdebug.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/pda.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
id|asmlinkage
r_int
id|system_call
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_int
id|kernel_syscall
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|ia32_syscall
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_struct
id|gate_struct
id|idt_table
(braket
l_int|256
)braket
suffix:semicolon
id|asmlinkage
r_void
id|divide_error
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|debug
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|nmi
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|int3
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|overflow
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|bounds
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|invalid_op
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|device_not_available
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|double_fault
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|coprocessor_segment_overrun
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|invalid_TSS
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|segment_not_present
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|stack_segment
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|general_protection
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|page_fault
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|coprocessor_error
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|simd_coprocessor_error
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|reserved
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|alignment_check
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|machine_check
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|spurious_interrupt_bug
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|call_debug
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|exception_trace
suffix:semicolon
DECL|variable|die_chain
r_struct
id|notifier_block
op_star
id|die_chain
suffix:semicolon
DECL|function|conditional_sti
r_static
r_inline
r_void
id|conditional_sti
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|regs-&gt;eflags
op_amp
id|X86_EFLAGS_IF
)paren
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|kstack_depth_to_print
r_static
r_int
id|kstack_depth_to_print
op_assign
l_int|10
suffix:semicolon
macro_line|#ifdef CONFIG_KALLSYMS
macro_line|#include &lt;linux/kallsyms.h&gt; 
DECL|function|printk_address
r_int
id|printk_address
c_func
(paren
r_int
r_int
id|address
)paren
(brace
r_int
r_int
id|offset
op_assign
l_int|0
comma
id|symsize
suffix:semicolon
r_const
r_char
op_star
id|symname
suffix:semicolon
r_char
op_star
id|modname
suffix:semicolon
r_char
op_star
id|delim
op_assign
l_string|&quot;:&quot;
suffix:semicolon
r_char
id|namebuf
(braket
l_int|128
)braket
suffix:semicolon
id|symname
op_assign
id|kallsyms_lookup
c_func
(paren
id|address
comma
op_amp
id|symsize
comma
op_amp
id|offset
comma
op_amp
id|modname
comma
id|namebuf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|symname
)paren
r_return
id|printk
c_func
(paren
l_string|&quot;[&lt;%016lx&gt;]&quot;
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|modname
)paren
id|modname
op_assign
id|delim
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_return
id|printk
c_func
(paren
l_string|&quot;&lt;%016lx&gt;{%s%s%s%s%+ld}&quot;
comma
id|address
comma
id|delim
comma
id|modname
comma
id|delim
comma
id|symname
comma
id|offset
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|function|printk_address
r_int
id|printk_address
c_func
(paren
r_int
r_int
id|address
)paren
(brace
r_return
id|printk
c_func
(paren
l_string|&quot;[&lt;%016lx&gt;]&quot;
comma
id|address
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|in_exception_stack
r_int
r_int
op_star
id|in_exception_stack
c_func
(paren
r_int
id|cpu
comma
r_int
r_int
id|stack
)paren
(brace
r_int
id|k
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|N_EXCEPTION_STACKS
suffix:semicolon
id|k
op_increment
)paren
(brace
r_int
r_int
id|end
op_assign
id|init_tss
(braket
id|cpu
)braket
dot
id|ist
(braket
id|k
)braket
op_plus
id|EXCEPTION_STKSZ
suffix:semicolon
r_if
c_cond
(paren
id|stack
op_ge
id|init_tss
(braket
id|cpu
)braket
dot
id|ist
(braket
id|k
)braket
op_logical_and
id|stack
op_le
id|end
)paren
r_return
(paren
r_int
r_int
op_star
)paren
id|end
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * x86-64 can have upto three kernel stacks: &n; * process stack&n; * interrupt stack&n; * severe exception (double fault, nmi, stack fault) hardware stack&n; * Check and process them in order.&n; */
DECL|function|show_trace
r_void
id|show_trace
c_func
(paren
r_int
r_int
op_star
id|stack
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_int
r_int
op_star
id|irqstack
comma
op_star
id|irqstack_end
comma
op_star
id|estack_end
suffix:semicolon
r_const
r_int
id|cpu
op_assign
id|safe_smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nCall Trace:&quot;
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|estack_end
op_assign
id|in_exception_stack
c_func
(paren
id|cpu
comma
(paren
r_int
r_int
)paren
id|stack
)paren
suffix:semicolon
r_if
c_cond
(paren
id|estack_end
)paren
(brace
r_while
c_loop
(paren
id|stack
OL
id|estack_end
)paren
(brace
id|addr
op_assign
op_star
id|stack
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|kernel_text_address
c_func
(paren
id|addr
)paren
)paren
(brace
id|i
op_add_assign
id|printk_address
c_func
(paren
id|addr
)paren
suffix:semicolon
id|i
op_add_assign
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|50
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
id|i
op_add_assign
id|printk
c_func
(paren
l_string|&quot; &lt;EOE&gt; &quot;
)paren
suffix:semicolon
id|i
op_add_assign
l_int|7
suffix:semicolon
id|stack
op_assign
(paren
r_int
r_int
op_star
)paren
id|estack_end
(braket
op_minus
l_int|2
)braket
suffix:semicolon
)brace
id|irqstack_end
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|cpu_pda
(braket
id|cpu
)braket
dot
id|irqstackptr
)paren
suffix:semicolon
id|irqstack
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|cpu_pda
(braket
id|cpu
)braket
dot
id|irqstackptr
op_minus
id|IRQSTACKSIZE
op_plus
l_int|64
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stack
op_ge
id|irqstack
op_logical_and
id|stack
OL
id|irqstack_end
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&lt;IRQ&gt; &quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|stack
OL
id|irqstack_end
)paren
(brace
id|addr
op_assign
op_star
id|stack
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If the address is either in the text segment of the&n;&t;&t;&t; * kernel, or in the region which contains vmalloc&squot;ed&n;&t;&t;&t; * memory, it *may* be the address of a calling&n;&t;&t;&t; * routine; if so, print it so that someone tracing&n;&t;&t;&t; * down the cause of the crash will be able to figure&n;&t;&t;&t; * out the call path that was taken.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|kernel_text_address
c_func
(paren
id|addr
)paren
)paren
(brace
id|i
op_add_assign
id|printk_address
c_func
(paren
id|addr
)paren
suffix:semicolon
id|i
op_add_assign
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|50
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n       &quot;
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
id|stack
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|irqstack_end
(braket
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; &lt;EOI&gt; &quot;
)paren
suffix:semicolon
id|i
op_add_assign
l_int|7
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
(paren
r_int
)paren
id|stack
op_amp
(paren
id|THREAD_SIZE
op_minus
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|addr
op_assign
op_star
id|stack
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|kernel_text_address
c_func
(paren
id|addr
)paren
)paren
(brace
id|i
op_add_assign
id|printk_address
c_func
(paren
id|addr
)paren
suffix:semicolon
id|i
op_add_assign
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|50
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n       &quot;
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|show_trace_task
r_void
id|show_trace_task
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_int
r_int
id|rsp
op_assign
id|tsk-&gt;thread.rsp
suffix:semicolon
multiline_comment|/* User space on another CPU? */
r_if
c_cond
(paren
(paren
id|rsp
op_xor
(paren
r_int
r_int
)paren
id|tsk-&gt;thread_info
)paren
op_amp
(paren
id|PAGE_MASK
op_lshift
l_int|1
)paren
)paren
r_return
suffix:semicolon
id|show_trace
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|rsp
)paren
suffix:semicolon
)brace
DECL|function|show_stack
r_void
id|show_stack
c_func
(paren
r_int
r_int
op_star
id|rsp
)paren
(brace
r_int
r_int
op_star
id|stack
suffix:semicolon
r_int
id|i
suffix:semicolon
r_const
r_int
id|cpu
op_assign
id|safe_smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
op_star
id|irqstack_end
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|cpu_pda
(braket
id|cpu
)braket
dot
id|irqstackptr
)paren
suffix:semicolon
r_int
r_int
op_star
id|irqstack
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|cpu_pda
(braket
id|cpu
)braket
dot
id|irqstackptr
op_minus
id|IRQSTACKSIZE
)paren
suffix:semicolon
singleline_comment|// debugging aid: &quot;show_stack(NULL);&quot; prints the
singleline_comment|// back trace for this cpu.
r_if
c_cond
(paren
id|rsp
op_eq
l_int|NULL
)paren
(brace
id|rsp
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
id|rsp
suffix:semicolon
)brace
id|stack
op_assign
id|rsp
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|kstack_depth_to_print
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|stack
op_ge
id|irqstack
op_logical_and
id|stack
op_le
id|irqstack_end
)paren
(brace
r_if
c_cond
(paren
id|stack
op_eq
id|irqstack_end
)paren
(brace
id|stack
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|irqstack_end
(braket
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; &lt;EOI&gt; &quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|stack
op_amp
(paren
id|THREAD_SIZE
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_logical_and
(paren
(paren
id|i
op_mod
l_int|4
)paren
op_eq
l_int|0
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n       &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%016lx &quot;
comma
op_star
id|stack
op_increment
)paren
suffix:semicolon
)brace
id|show_trace
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|rsp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The architecture-independent dump_stack generator&n; */
DECL|function|dump_stack
r_void
id|dump_stack
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|dummy
suffix:semicolon
id|show_trace
c_func
(paren
op_amp
id|dummy
)paren
suffix:semicolon
)brace
DECL|function|show_registers
r_void
id|show_registers
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|in_kernel
op_assign
(paren
id|regs-&gt;cs
op_amp
l_int|3
)paren
op_eq
l_int|0
suffix:semicolon
r_int
r_int
id|rsp
suffix:semicolon
r_const
r_int
id|cpu
op_assign
id|safe_smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_struct
id|task_struct
op_star
id|cur
op_assign
id|cpu_pda
(braket
id|cpu
)braket
dot
id|pcurrent
suffix:semicolon
id|rsp
op_assign
id|regs-&gt;rsp
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CPU %d &quot;
comma
id|cpu
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Process %s (pid: %d, stackpage=%08lx)&bslash;n&quot;
comma
id|cur-&gt;comm
comma
id|cur-&gt;pid
comma
l_int|4096
op_plus
(paren
r_int
r_int
)paren
id|cur
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * When in-kernel, we also print out the stack and code at the&n;&t; * time of the fault..&n;&t; */
r_if
c_cond
(paren
id|in_kernel
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Stack: &quot;
)paren
suffix:semicolon
id|show_stack
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|rsp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nCode: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;rip
OL
id|PAGE_OFFSET
)paren
(brace
r_goto
id|bad
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|20
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_char
id|c
suffix:semicolon
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|c
comma
op_amp
(paren
(paren
r_int
r_char
op_star
)paren
id|regs-&gt;rip
)paren
(braket
id|i
)braket
)paren
)paren
(brace
id|bad
suffix:colon
id|printk
c_func
(paren
l_string|&quot; Bad RIP value.&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|c
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|handle_BUG
r_void
id|handle_BUG
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|bug_frame
id|f
suffix:semicolon
r_char
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;cs
op_amp
l_int|3
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|__copy_from_user
c_func
(paren
op_amp
id|f
comma
(paren
r_struct
id|bug_frame
op_star
)paren
id|regs-&gt;rip
comma
r_sizeof
(paren
r_struct
id|bug_frame
)paren
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|f.filename
OL
id|__PAGE_OFFSET
op_logical_or
id|f.ud2
(braket
l_int|0
)braket
op_ne
l_int|0x0f
op_logical_or
id|f.ud2
(braket
l_int|1
)braket
op_ne
l_int|0x0b
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|tmp
comma
id|f.filename
)paren
)paren
id|f.filename
op_assign
l_string|&quot;unmapped filename&quot;
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;----------- [cut here ] --------- [please bite here ] ---------&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Kernel BUG at %.50s:%d&bslash;n&quot;
comma
id|f.filename
comma
id|f.line
)paren
suffix:semicolon
)brace
DECL|function|out_of_line_bug
r_void
id|out_of_line_bug
c_func
(paren
r_void
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|die_lock
id|spinlock_t
id|die_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|die_owner
r_int
id|die_owner
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|function|die
r_void
id|die
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
r_int
id|cpu
suffix:semicolon
r_struct
id|die_args
id|args
op_assign
(brace
id|regs
comma
id|str
comma
id|err
)brace
suffix:semicolon
r_static
r_int
id|die_counter
suffix:semicolon
id|console_verbose
c_func
(paren
)paren
suffix:semicolon
id|notifier_call_chain
c_func
(paren
op_amp
id|die_chain
comma
id|DIE_DIE
comma
op_amp
id|args
)paren
suffix:semicolon
id|bust_spinlocks
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|handle_BUG
c_func
(paren
id|regs
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %04lx [#%d]&bslash;n&quot;
comma
id|str
comma
id|err
op_amp
l_int|0xffff
comma
op_increment
id|die_counter
)paren
suffix:semicolon
id|cpu
op_assign
id|safe_smp_processor_id
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* racy, but better than risking deadlock. */
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|spin_trylock
c_func
(paren
op_amp
id|die_lock
)paren
)paren
(brace
r_if
c_cond
(paren
id|cpu
op_eq
id|die_owner
)paren
multiline_comment|/* nested oops. should stop eventually */
suffix:semicolon
r_else
id|spin_lock
c_func
(paren
op_amp
id|die_lock
)paren
suffix:semicolon
)brace
id|die_owner
op_assign
id|cpu
suffix:semicolon
id|show_registers
c_func
(paren
id|regs
)paren
suffix:semicolon
id|bust_spinlocks
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|die_lock
)paren
suffix:semicolon
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
)brace
DECL|function|die_if_kernel
r_static
r_inline
r_void
id|die_if_kernel
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|regs-&gt;eflags
op_amp
id|VM_MASK
)paren
op_logical_and
(paren
id|regs-&gt;cs
op_eq
id|__KERNEL_CS
)paren
)paren
id|die
c_func
(paren
id|str
comma
id|regs
comma
id|err
)paren
suffix:semicolon
)brace
DECL|function|get_cr2
r_static
r_inline
r_int
r_int
id|get_cr2
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|address
suffix:semicolon
multiline_comment|/* get the address */
id|__asm__
c_func
(paren
l_string|&quot;movq %%cr2,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|address
)paren
)paren
suffix:semicolon
r_return
id|address
suffix:semicolon
)brace
DECL|function|do_trap
r_static
r_void
id|do_trap
c_func
(paren
r_int
id|trapnr
comma
r_int
id|signr
comma
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
comma
id|siginfo_t
op_star
id|info
)paren
(brace
id|conditional_sti
c_func
(paren
id|regs
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_CHECKING
(brace
r_int
r_int
id|gs
suffix:semicolon
r_struct
id|x8664_pda
op_star
id|pda
op_assign
id|cpu_pda
op_plus
id|safe_smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|rdmsrl
c_func
(paren
id|MSR_GS_BASE
comma
id|gs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gs
op_ne
(paren
r_int
r_int
)paren
id|pda
)paren
(brace
id|wrmsrl
c_func
(paren
id|MSR_GS_BASE
comma
id|pda
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: wrong gs %lx expected %p rip %lx&bslash;n&quot;
comma
id|str
comma
id|gs
comma
id|pda
comma
id|regs-&gt;rip
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
id|regs-&gt;cs
op_amp
l_int|3
)paren
op_ne
l_int|0
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
r_if
c_cond
(paren
id|exception_trace
op_logical_and
id|trapnr
op_ne
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;%s[%d] trap %s at rip:%lx rsp:%lx err:%lx&bslash;n&quot;
comma
id|tsk-&gt;comm
comma
id|tsk-&gt;pid
comma
id|str
comma
id|regs-&gt;rip
comma
id|regs-&gt;rsp
comma
id|error_code
)paren
suffix:semicolon
id|tsk-&gt;thread.error_code
op_assign
id|error_code
suffix:semicolon
id|tsk-&gt;thread.trap_no
op_assign
id|trapnr
suffix:semicolon
r_if
c_cond
(paren
id|info
)paren
id|force_sig_info
c_func
(paren
id|signr
comma
id|info
comma
id|tsk
)paren
suffix:semicolon
r_else
id|force_sig
c_func
(paren
id|signr
comma
id|tsk
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* kernel trap */
(brace
r_const
r_struct
id|exception_table_entry
op_star
id|fixup
suffix:semicolon
id|fixup
op_assign
id|search_exception_tables
c_func
(paren
id|regs-&gt;rip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fixup
)paren
(brace
r_extern
r_int
id|exception_trace
suffix:semicolon
r_if
c_cond
(paren
id|exception_trace
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: fixed kernel exception at %lx err:%ld&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|regs-&gt;rip
comma
id|error_code
)paren
suffix:semicolon
id|regs-&gt;rip
op_assign
id|fixup-&gt;fixup
suffix:semicolon
)brace
r_else
id|die
c_func
(paren
id|str
comma
id|regs
comma
id|error_code
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
DECL|macro|DO_ERROR
mdefine_line|#define DO_ERROR(trapnr, signr, str, name) &bslash;&n;asmlinkage void do_##name(struct pt_regs * regs, long error_code) &bslash;&n;{ &bslash;&n;&t;if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr) == NOTIFY_BAD) &bslash;&n;&t;&t;return; &bslash;&n;&t;do_trap(trapnr, signr, str, regs, error_code, NULL); &bslash;&n;}
DECL|macro|DO_ERROR_INFO
mdefine_line|#define DO_ERROR_INFO(trapnr, signr, str, name, sicode, siaddr) &bslash;&n;asmlinkage void do_##name(struct pt_regs * regs, long error_code) &bslash;&n;{ &bslash;&n;&t;siginfo_t info; &bslash;&n;&t;info.si_signo = signr; &bslash;&n;&t;info.si_errno = 0; &bslash;&n;&t;info.si_code = sicode; &bslash;&n;&t;info.si_addr = (void *)siaddr; &bslash;&n;&t;if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr) == NOTIFY_BAD) &bslash;&n;&t;&t;return; &bslash;&n;&t;do_trap(trapnr, signr, str, regs, error_code, &amp;info); &bslash;&n;}
id|DO_ERROR_INFO
c_func
(paren
l_int|0
comma
id|SIGFPE
comma
l_string|&quot;divide error&quot;
comma
id|divide_error
comma
id|FPE_INTDIV
comma
id|regs-&gt;rip
)paren
id|DO_ERROR
c_func
(paren
l_int|3
comma
id|SIGTRAP
comma
l_string|&quot;int3&quot;
comma
id|int3
)paren
suffix:semicolon
id|DO_ERROR
c_func
(paren
l_int|4
comma
id|SIGSEGV
comma
l_string|&quot;overflow&quot;
comma
id|overflow
)paren
id|DO_ERROR
c_func
(paren
l_int|5
comma
id|SIGSEGV
comma
l_string|&quot;bounds&quot;
comma
id|bounds
)paren
id|DO_ERROR_INFO
c_func
(paren
l_int|6
comma
id|SIGILL
comma
l_string|&quot;invalid operand&quot;
comma
id|invalid_op
comma
id|ILL_ILLOPN
comma
id|regs-&gt;rip
)paren
id|DO_ERROR
c_func
(paren
l_int|7
comma
id|SIGSEGV
comma
l_string|&quot;device not available&quot;
comma
id|device_not_available
)paren
id|DO_ERROR
c_func
(paren
l_int|8
comma
id|SIGSEGV
comma
l_string|&quot;double fault&quot;
comma
id|double_fault
)paren
id|DO_ERROR
c_func
(paren
l_int|9
comma
id|SIGFPE
comma
l_string|&quot;coprocessor segment overrun&quot;
comma
id|coprocessor_segment_overrun
)paren
id|DO_ERROR
c_func
(paren
l_int|10
comma
id|SIGSEGV
comma
l_string|&quot;invalid TSS&quot;
comma
id|invalid_TSS
)paren
id|DO_ERROR
c_func
(paren
l_int|11
comma
id|SIGBUS
comma
l_string|&quot;segment not present&quot;
comma
id|segment_not_present
)paren
id|DO_ERROR
c_func
(paren
l_int|12
comma
id|SIGBUS
comma
l_string|&quot;stack segment&quot;
comma
id|stack_segment
)paren
id|DO_ERROR_INFO
c_func
(paren
l_int|17
comma
id|SIGBUS
comma
l_string|&quot;alignment check&quot;
comma
id|alignment_check
comma
id|BUS_ADRALN
comma
id|get_cr2
c_func
(paren
)paren
)paren
id|DO_ERROR
c_func
(paren
l_int|18
comma
id|SIGSEGV
comma
l_string|&quot;reserved&quot;
comma
id|reserved
)paren
r_extern
r_void
id|dump_pagetable
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
DECL|function|do_general_protection
id|asmlinkage
r_void
id|do_general_protection
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
(brace
id|conditional_sti
c_func
(paren
id|regs
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_CHECKING
(brace
r_int
r_int
id|gs
suffix:semicolon
r_struct
id|x8664_pda
op_star
id|pda
op_assign
id|cpu_pda
op_plus
id|safe_smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|rdmsrl
c_func
(paren
id|MSR_GS_BASE
comma
id|gs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gs
op_ne
(paren
r_int
r_int
)paren
id|pda
)paren
(brace
id|wrmsrl
c_func
(paren
id|MSR_GS_BASE
comma
id|pda
)paren
suffix:semicolon
id|oops_in_progress
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;general protection handler: wrong gs %lx expected %p&bslash;n&quot;
comma
id|gs
comma
id|pda
)paren
suffix:semicolon
id|oops_in_progress
op_decrement
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
id|regs-&gt;cs
op_amp
l_int|3
)paren
op_ne
l_int|0
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
r_if
c_cond
(paren
id|exception_trace
)paren
id|printk
c_func
(paren
l_string|&quot;%s[%d] #gp at rip:%lx rsp:%lx err:%lx&bslash;n&quot;
comma
id|tsk-&gt;comm
comma
id|tsk-&gt;pid
comma
id|regs-&gt;rip
comma
id|regs-&gt;rsp
comma
id|error_code
)paren
suffix:semicolon
id|tsk-&gt;thread.error_code
op_assign
id|error_code
suffix:semicolon
id|tsk-&gt;thread.trap_no
op_assign
l_int|13
suffix:semicolon
id|force_sig
c_func
(paren
id|SIGSEGV
comma
id|tsk
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* kernel gp */
(brace
r_const
r_struct
id|exception_table_entry
op_star
id|fixup
suffix:semicolon
id|fixup
op_assign
id|search_exception_tables
c_func
(paren
id|regs-&gt;rip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fixup
)paren
(brace
id|regs-&gt;rip
op_assign
id|fixup-&gt;fixup
suffix:semicolon
r_return
suffix:semicolon
)brace
id|notify_die
c_func
(paren
id|DIE_GPF
comma
l_string|&quot;general protection fault&quot;
comma
id|regs
comma
id|error_code
comma
l_int|13
comma
id|SIGSEGV
)paren
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;general protection fault&quot;
comma
id|regs
comma
id|error_code
)paren
suffix:semicolon
)brace
)brace
DECL|function|mem_parity_error
r_static
r_void
id|mem_parity_error
c_func
(paren
r_int
r_char
id|reason
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Uhhuh. NMI received. Dazed and confused, but trying to continue&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;You probably have a hardware problem with your RAM chips&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Clear and disable the memory parity error line. */
id|reason
op_assign
(paren
id|reason
op_amp
l_int|0xf
)paren
op_or
l_int|4
suffix:semicolon
id|outb
c_func
(paren
id|reason
comma
l_int|0x61
)paren
suffix:semicolon
)brace
DECL|function|io_check_error
r_static
r_void
id|io_check_error
c_func
(paren
r_int
r_char
id|reason
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NMI: IOCK error (debug interrupt?)&bslash;n&quot;
)paren
suffix:semicolon
id|show_registers
c_func
(paren
id|regs
)paren
suffix:semicolon
multiline_comment|/* Re-enable the IOCK line, wait for a few seconds */
id|reason
op_assign
(paren
id|reason
op_amp
l_int|0xf
)paren
op_or
l_int|8
suffix:semicolon
id|outb
c_func
(paren
id|reason
comma
l_int|0x61
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|2000
)paren
suffix:semicolon
id|reason
op_and_assign
op_complement
l_int|8
suffix:semicolon
id|outb
c_func
(paren
id|reason
comma
l_int|0x61
)paren
suffix:semicolon
)brace
DECL|function|unknown_nmi_error
r_static
r_void
id|unknown_nmi_error
c_func
(paren
r_int
r_char
id|reason
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Uhhuh. NMI received for unknown reason %02x.&bslash;n&quot;
comma
id|reason
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Dazed and confused, but trying to continue&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Do you have a strange power saving mode enabled?&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|default_do_nmi
id|asmlinkage
r_void
id|default_do_nmi
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_char
id|reason
op_assign
id|inb
c_func
(paren
l_int|0x61
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|reason
op_amp
l_int|0xc0
)paren
)paren
(brace
macro_line|#if CONFIG_X86_LOCAL_APIC
multiline_comment|/*&n;&t;&t; * Ok, so this is none of the documented NMI sources,&n;&t;&t; * so it must be the NMI watchdog.&n;&t;&t; */
r_if
c_cond
(paren
id|nmi_watchdog
)paren
(brace
id|nmi_watchdog_tick
c_func
(paren
id|regs
comma
id|reason
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
id|unknown_nmi_error
c_func
(paren
id|reason
comma
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|notify_die
c_func
(paren
id|DIE_NMI
comma
l_string|&quot;nmi&quot;
comma
id|regs
comma
id|reason
comma
l_int|0
comma
id|SIGINT
)paren
op_eq
id|NOTIFY_BAD
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|reason
op_amp
l_int|0x80
)paren
id|mem_parity_error
c_func
(paren
id|reason
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reason
op_amp
l_int|0x40
)paren
id|io_check_error
c_func
(paren
id|reason
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reassert NMI in case it became active meanwhile&n;&t; * as it&squot;s edge-triggered.&n;&t; */
id|outb
c_func
(paren
l_int|0x8f
comma
l_int|0x70
)paren
suffix:semicolon
id|inb
c_func
(paren
l_int|0x71
)paren
suffix:semicolon
multiline_comment|/* dummy */
id|outb
c_func
(paren
l_int|0x0f
comma
l_int|0x70
)paren
suffix:semicolon
id|inb
c_func
(paren
l_int|0x71
)paren
suffix:semicolon
multiline_comment|/* dummy */
)brace
DECL|function|do_debug
id|asmlinkage
r_void
id|do_debug
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
(brace
r_int
r_int
id|condition
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|siginfo_t
id|info
suffix:semicolon
macro_line|#ifdef CONFIG_CHECKING
(brace
multiline_comment|/* RED-PEN interaction with debugger - could destroy gs */
r_int
r_int
id|gs
suffix:semicolon
r_struct
id|x8664_pda
op_star
id|pda
op_assign
id|cpu_pda
op_plus
id|safe_smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|rdmsrl
c_func
(paren
id|MSR_GS_BASE
comma
id|gs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gs
op_ne
(paren
r_int
r_int
)paren
id|pda
)paren
(brace
id|wrmsrl
c_func
(paren
id|MSR_GS_BASE
comma
id|pda
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;debug handler: wrong gs %lx expected %p&bslash;n&quot;
comma
id|gs
comma
id|pda
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
id|asm
c_func
(paren
l_string|&quot;movq %%db6,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|condition
)paren
)paren
suffix:semicolon
id|conditional_sti
c_func
(paren
id|regs
)paren
suffix:semicolon
multiline_comment|/* Mask out spurious debug traps due to lazy DR7 setting */
r_if
c_cond
(paren
id|condition
op_amp
(paren
id|DR_TRAP0
op_or
id|DR_TRAP1
op_or
id|DR_TRAP2
op_or
id|DR_TRAP3
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tsk-&gt;thread.debugreg
(braket
l_int|7
)braket
)paren
(brace
r_goto
id|clear_dr7
suffix:semicolon
)brace
)brace
id|tsk-&gt;thread.debugreg
(braket
l_int|6
)braket
op_assign
id|condition
suffix:semicolon
multiline_comment|/* Mask out spurious TF errors due to lazy TF clearing */
r_if
c_cond
(paren
id|condition
op_amp
id|DR_STEP
)paren
(brace
multiline_comment|/*&n;&t;&t; * The TF error should be masked out only if the current&n;&t;&t; * process is not traced and if the TRAP flag has been set&n;&t;&t; * previously by a tracing process (condition detected by&n;&t;&t; * the PT_DTRACE flag); remember that the i386 TRAP flag&n;&t;&t; * can be modified by the process itself in user mode,&n;&t;&t; * allowing programs to debug themselves without the ptrace()&n;&t;&t; * interface.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|regs-&gt;cs
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
r_goto
id|clear_TF_reenable
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tsk-&gt;ptrace
op_amp
(paren
id|PT_DTRACE
op_or
id|PT_PTRACED
)paren
)paren
op_eq
id|PT_DTRACE
)paren
r_goto
id|clear_TF
suffix:semicolon
)brace
multiline_comment|/* Ok, finally something we can handle */
id|tsk-&gt;thread.trap_no
op_assign
l_int|1
suffix:semicolon
id|tsk-&gt;thread.error_code
op_assign
id|error_code
suffix:semicolon
id|info.si_signo
op_assign
id|SIGTRAP
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
id|info.si_code
op_assign
id|TRAP_BRKPT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|regs-&gt;cs
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
r_goto
id|clear_dr7
suffix:semicolon
id|info.si_addr
op_assign
(paren
r_void
op_star
)paren
id|regs-&gt;rip
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGTRAP
comma
op_amp
id|info
comma
id|tsk
)paren
suffix:semicolon
id|clear_dr7
suffix:colon
id|asm
r_volatile
(paren
l_string|&quot;movq %0,%%db7&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
l_int|0UL
)paren
)paren
suffix:semicolon
id|notify_die
c_func
(paren
id|DIE_DEBUG
comma
l_string|&quot;debug&quot;
comma
id|regs
comma
id|error_code
comma
l_int|1
comma
id|SIGTRAP
)paren
suffix:semicolon
r_return
suffix:semicolon
id|clear_TF_reenable
suffix:colon
id|set_tsk_thread_flag
c_func
(paren
id|tsk
comma
id|TIF_SINGLESTEP
)paren
suffix:semicolon
id|clear_TF
suffix:colon
multiline_comment|/* RED-PEN could cause spurious errors */
r_if
c_cond
(paren
id|notify_die
c_func
(paren
id|DIE_DEBUG
comma
l_string|&quot;debug2&quot;
comma
id|regs
comma
id|error_code
comma
l_int|1
comma
id|SIGTRAP
)paren
op_ne
id|NOTIFY_BAD
)paren
id|regs-&gt;eflags
op_and_assign
op_complement
id|TF_MASK
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Note that we play around with the &squot;TS&squot; bit in an attempt to get&n; * the correct behaviour even in the presence of the asynchronous&n; * IRQ13 behaviour&n; */
DECL|function|math_error
r_void
id|math_error
c_func
(paren
r_void
op_star
id|rip
)paren
(brace
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
id|siginfo_t
id|info
suffix:semicolon
r_int
r_int
id|cwd
comma
id|swd
suffix:semicolon
multiline_comment|/*&n;&t; * Save the info for the exception handler and clear the error.&n;&t; */
id|task
op_assign
id|current
suffix:semicolon
id|save_init_fpu
c_func
(paren
id|task
)paren
suffix:semicolon
id|task-&gt;thread.trap_no
op_assign
l_int|16
suffix:semicolon
id|task-&gt;thread.error_code
op_assign
l_int|0
suffix:semicolon
id|info.si_signo
op_assign
id|SIGFPE
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
id|info.si_code
op_assign
id|__SI_FAULT
suffix:semicolon
id|info.si_addr
op_assign
id|rip
suffix:semicolon
multiline_comment|/*&n;&t; * (~cwd &amp; swd) will mask out exceptions that are not set to unmasked&n;&t; * status.  0x3f is the exception bits in these regs, 0x200 is the&n;&t; * C1 reg you need in case of a stack fault, 0x040 is the stack&n;&t; * fault bit.  We should only be taking one exception at a time,&n;&t; * so if this combination doesn&squot;t produce any single exception,&n;&t; * then we have a bad program that isn&squot;t syncronizing its FPU usage&n;&t; * and it will suffer the consequences since we won&squot;t be able to&n;&t; * fully reproduce the context of the exception&n;&t; */
id|cwd
op_assign
id|get_fpu_cwd
c_func
(paren
id|task
)paren
suffix:semicolon
id|swd
op_assign
id|get_fpu_swd
c_func
(paren
id|task
)paren
suffix:semicolon
r_switch
c_cond
(paren
(paren
(paren
op_complement
id|cwd
)paren
op_amp
id|swd
op_amp
l_int|0x3f
)paren
op_or
(paren
id|swd
op_amp
l_int|0x240
)paren
)paren
(brace
r_case
l_int|0x000
suffix:colon
r_default
suffix:colon
r_break
suffix:semicolon
r_case
l_int|0x001
suffix:colon
multiline_comment|/* Invalid Op */
r_case
l_int|0x040
suffix:colon
multiline_comment|/* Stack Fault */
r_case
l_int|0x240
suffix:colon
multiline_comment|/* Stack Fault | Direction */
id|info.si_code
op_assign
id|FPE_FLTINV
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x002
suffix:colon
multiline_comment|/* Denormalize */
r_case
l_int|0x010
suffix:colon
multiline_comment|/* Underflow */
id|info.si_code
op_assign
id|FPE_FLTUND
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x004
suffix:colon
multiline_comment|/* Zero Divide */
id|info.si_code
op_assign
id|FPE_FLTDIV
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x008
suffix:colon
multiline_comment|/* Overflow */
id|info.si_code
op_assign
id|FPE_FLTOVF
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x020
suffix:colon
multiline_comment|/* Precision */
id|info.si_code
op_assign
id|FPE_FLTRES
suffix:semicolon
r_break
suffix:semicolon
)brace
id|force_sig_info
c_func
(paren
id|SIGFPE
comma
op_amp
id|info
comma
id|task
)paren
suffix:semicolon
)brace
DECL|function|do_coprocessor_error
id|asmlinkage
r_void
id|do_coprocessor_error
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
(brace
id|conditional_sti
c_func
(paren
id|regs
)paren
suffix:semicolon
id|math_error
c_func
(paren
(paren
r_void
op_star
)paren
id|regs-&gt;rip
)paren
suffix:semicolon
)brace
DECL|function|bad_intr
id|asmlinkage
r_void
id|bad_intr
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bad interrupt&quot;
)paren
suffix:semicolon
)brace
DECL|function|simd_math_error
r_static
r_inline
r_void
id|simd_math_error
c_func
(paren
r_void
op_star
id|rip
)paren
(brace
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
id|siginfo_t
id|info
suffix:semicolon
r_int
r_int
id|mxcsr
suffix:semicolon
multiline_comment|/*&n;&t; * Save the info for the exception handler and clear the error.&n;&t; */
id|task
op_assign
id|current
suffix:semicolon
id|save_init_fpu
c_func
(paren
id|task
)paren
suffix:semicolon
id|task-&gt;thread.trap_no
op_assign
l_int|19
suffix:semicolon
id|task-&gt;thread.error_code
op_assign
l_int|0
suffix:semicolon
id|info.si_signo
op_assign
id|SIGFPE
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
id|info.si_code
op_assign
id|__SI_FAULT
suffix:semicolon
id|info.si_addr
op_assign
id|rip
suffix:semicolon
multiline_comment|/*&n;&t; * The SIMD FPU exceptions are handled a little differently, as there&n;&t; * is only a single status/control register.  Thus, to determine which&n;&t; * unmasked exception was caught we must mask the exception mask bits&n;&t; * at 0x1f80, and then use these to mask the exception bits at 0x3f.&n;&t; */
id|mxcsr
op_assign
id|get_fpu_mxcsr
c_func
(paren
id|task
)paren
suffix:semicolon
r_switch
c_cond
(paren
op_complement
(paren
(paren
id|mxcsr
op_amp
l_int|0x1f80
)paren
op_rshift
l_int|7
)paren
op_amp
(paren
id|mxcsr
op_amp
l_int|0x3f
)paren
)paren
(brace
r_case
l_int|0x000
suffix:colon
r_default
suffix:colon
r_break
suffix:semicolon
r_case
l_int|0x001
suffix:colon
multiline_comment|/* Invalid Op */
id|info.si_code
op_assign
id|FPE_FLTINV
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x002
suffix:colon
multiline_comment|/* Denormalize */
r_case
l_int|0x010
suffix:colon
multiline_comment|/* Underflow */
id|info.si_code
op_assign
id|FPE_FLTUND
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x004
suffix:colon
multiline_comment|/* Zero Divide */
id|info.si_code
op_assign
id|FPE_FLTDIV
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x008
suffix:colon
multiline_comment|/* Overflow */
id|info.si_code
op_assign
id|FPE_FLTOVF
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x020
suffix:colon
multiline_comment|/* Precision */
id|info.si_code
op_assign
id|FPE_FLTRES
suffix:semicolon
r_break
suffix:semicolon
)brace
id|force_sig_info
c_func
(paren
id|SIGFPE
comma
op_amp
id|info
comma
id|task
)paren
suffix:semicolon
)brace
DECL|function|do_simd_coprocessor_error
id|asmlinkage
r_void
id|do_simd_coprocessor_error
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
(brace
id|conditional_sti
c_func
(paren
id|regs
)paren
suffix:semicolon
id|simd_math_error
c_func
(paren
(paren
r_void
op_star
)paren
id|regs-&gt;rip
)paren
suffix:semicolon
)brace
DECL|function|do_spurious_interrupt_bug
id|asmlinkage
r_void
id|do_spurious_interrupt_bug
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
)brace
multiline_comment|/*&n; *  &squot;math_state_restore()&squot; saves the current math information in the&n; * old math state array, and gets the new ones from the current task&n; *&n; * Careful.. There are problems with IBM-designed IRQ13 behaviour.&n; * Don&squot;t touch unless you *really* know how it works.&n; */
DECL|function|math_state_restore
id|asmlinkage
r_void
id|math_state_restore
c_func
(paren
r_void
)paren
(brace
r_struct
id|task_struct
op_star
id|me
op_assign
id|current
suffix:semicolon
id|clts
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Allow maths ops (or we recurse) */
r_if
c_cond
(paren
op_logical_neg
id|me-&gt;used_math
)paren
id|init_fpu
c_func
(paren
id|me
)paren
suffix:semicolon
id|restore_fpu_checking
c_func
(paren
op_amp
id|me-&gt;thread.i387.fxsave
)paren
suffix:semicolon
id|me-&gt;thread_info-&gt;status
op_or_assign
id|TS_USEDFPU
suffix:semicolon
)brace
DECL|function|math_emulate
id|asmlinkage
r_void
id|math_emulate
c_func
(paren
r_void
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|do_call_debug
r_void
id|do_call_debug
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|notify_die
c_func
(paren
id|DIE_CALL
comma
l_string|&quot;debug call&quot;
comma
id|regs
comma
l_int|0
comma
l_int|255
comma
id|SIGINT
)paren
suffix:semicolon
)brace
DECL|function|trap_init
r_void
id|__init
id|trap_init
c_func
(paren
r_void
)paren
(brace
id|set_intr_gate
c_func
(paren
l_int|0
comma
op_amp
id|divide_error
)paren
suffix:semicolon
id|set_intr_gate
c_func
(paren
l_int|1
comma
op_amp
id|debug
)paren
suffix:semicolon
id|set_intr_gate_ist
c_func
(paren
l_int|2
comma
op_amp
id|nmi
comma
id|NMI_STACK
)paren
suffix:semicolon
id|set_system_gate
c_func
(paren
l_int|3
comma
op_amp
id|int3
)paren
suffix:semicolon
multiline_comment|/* int3-5 can be called from all */
id|set_system_gate
c_func
(paren
l_int|4
comma
op_amp
id|overflow
)paren
suffix:semicolon
id|set_system_gate
c_func
(paren
l_int|5
comma
op_amp
id|bounds
)paren
suffix:semicolon
id|set_intr_gate
c_func
(paren
l_int|6
comma
op_amp
id|invalid_op
)paren
suffix:semicolon
id|set_intr_gate
c_func
(paren
l_int|7
comma
op_amp
id|device_not_available
)paren
suffix:semicolon
id|set_intr_gate_ist
c_func
(paren
l_int|8
comma
op_amp
id|double_fault
comma
id|DOUBLEFAULT_STACK
)paren
suffix:semicolon
id|set_intr_gate
c_func
(paren
l_int|9
comma
op_amp
id|coprocessor_segment_overrun
)paren
suffix:semicolon
id|set_intr_gate
c_func
(paren
l_int|10
comma
op_amp
id|invalid_TSS
)paren
suffix:semicolon
id|set_intr_gate
c_func
(paren
l_int|11
comma
op_amp
id|segment_not_present
)paren
suffix:semicolon
id|set_intr_gate_ist
c_func
(paren
l_int|12
comma
op_amp
id|stack_segment
comma
id|STACKFAULT_STACK
)paren
suffix:semicolon
id|set_intr_gate
c_func
(paren
l_int|13
comma
op_amp
id|general_protection
)paren
suffix:semicolon
id|set_intr_gate
c_func
(paren
l_int|14
comma
op_amp
id|page_fault
)paren
suffix:semicolon
id|set_intr_gate
c_func
(paren
l_int|15
comma
op_amp
id|spurious_interrupt_bug
)paren
suffix:semicolon
id|set_intr_gate
c_func
(paren
l_int|16
comma
op_amp
id|coprocessor_error
)paren
suffix:semicolon
id|set_intr_gate
c_func
(paren
l_int|17
comma
op_amp
id|alignment_check
)paren
suffix:semicolon
id|set_intr_gate
c_func
(paren
l_int|18
comma
op_amp
id|machine_check
)paren
suffix:semicolon
id|set_intr_gate
c_func
(paren
l_int|19
comma
op_amp
id|simd_coprocessor_error
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IA32_EMULATION
id|set_intr_gate
c_func
(paren
id|IA32_SYSCALL_VECTOR
comma
id|ia32_syscall
)paren
suffix:semicolon
macro_line|#endif
id|set_intr_gate
c_func
(paren
id|KDB_VECTOR
comma
id|call_debug
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Should be a barrier for any external CPU state.&n;&t; */
id|cpu_init
c_func
(paren
)paren
suffix:semicolon
)brace
eof
