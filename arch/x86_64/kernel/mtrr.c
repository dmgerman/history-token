multiline_comment|/*  x86-64 MTRR (Memory Type Range Register) driver.&n;&t;Based largely upon arch/i386/kernel/mtrr.c&n;&n;    Copyright (C) 1997-2000  Richard Gooch&n;&t;Copyright (C) 2002 Dave Jones.&n;&n;    This library is free software; you can redistribute it and/or&n;    modify it under the terms of the GNU Library General Public&n;    License as published by the Free Software Foundation; either&n;    version 2 of the License, or (at your option) any later version.&n;&n;    This library is distributed in the hope that it will be useful,&n;    but WITHOUT ANY WARRANTY; without even the implied warranty of&n;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n;    Library General Public License for more details.&n;&n;    You should have received a copy of the GNU Library General Public&n;    License along with this library; if not, write to the Free&n;    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n;&t;(For earlier history, see arch/i386/kernel/mtrr.c)&n;&t;September 2001&t;Dave Jones &lt;davej@suse.de&gt;&n;&t;&t;Initial rewrite for x86-64.&n;&n;*/
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/module.h&gt;
DECL|macro|MTRR_NEED_STRINGS
mdefine_line|#define MTRR_NEED_STRINGS
macro_line|#include &lt;asm/mtrr.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/msr.h&gt;
macro_line|#include &lt;asm/hardirq.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
DECL|macro|MTRR_VERSION
mdefine_line|#define MTRR_VERSION            &quot;2.00 (20020207)&quot;
DECL|macro|TRUE
mdefine_line|#define TRUE  1
DECL|macro|FALSE
mdefine_line|#define FALSE 0
DECL|macro|MTRRcap_MSR
mdefine_line|#define MTRRcap_MSR     0x0fe
DECL|macro|MTRRdefType_MSR
mdefine_line|#define MTRRdefType_MSR 0x2ff
DECL|macro|MTRRphysBase_MSR
mdefine_line|#define MTRRphysBase_MSR(reg) (0x200 + 2 * (reg))
DECL|macro|MTRRphysMask_MSR
mdefine_line|#define MTRRphysMask_MSR(reg) (0x200 + 2 * (reg) + 1)
DECL|macro|NUM_FIXED_RANGES
mdefine_line|#define NUM_FIXED_RANGES 88
DECL|macro|MTRRfix64K_00000_MSR
mdefine_line|#define MTRRfix64K_00000_MSR 0x250
DECL|macro|MTRRfix16K_80000_MSR
mdefine_line|#define MTRRfix16K_80000_MSR 0x258
DECL|macro|MTRRfix16K_A0000_MSR
mdefine_line|#define MTRRfix16K_A0000_MSR 0x259
DECL|macro|MTRRfix4K_C0000_MSR
mdefine_line|#define MTRRfix4K_C0000_MSR 0x268
DECL|macro|MTRRfix4K_C8000_MSR
mdefine_line|#define MTRRfix4K_C8000_MSR 0x269
DECL|macro|MTRRfix4K_D0000_MSR
mdefine_line|#define MTRRfix4K_D0000_MSR 0x26a
DECL|macro|MTRRfix4K_D8000_MSR
mdefine_line|#define MTRRfix4K_D8000_MSR 0x26b
DECL|macro|MTRRfix4K_E0000_MSR
mdefine_line|#define MTRRfix4K_E0000_MSR 0x26c
DECL|macro|MTRRfix4K_E8000_MSR
mdefine_line|#define MTRRfix4K_E8000_MSR 0x26d
DECL|macro|MTRRfix4K_F0000_MSR
mdefine_line|#define MTRRfix4K_F0000_MSR 0x26e
DECL|macro|MTRRfix4K_F8000_MSR
mdefine_line|#define MTRRfix4K_F8000_MSR 0x26f
macro_line|#ifdef CONFIG_SMP
DECL|macro|MTRR_CHANGE_MASK_FIXED
mdefine_line|#define MTRR_CHANGE_MASK_FIXED     0x01
DECL|macro|MTRR_CHANGE_MASK_VARIABLE
mdefine_line|#define MTRR_CHANGE_MASK_VARIABLE  0x02
DECL|macro|MTRR_CHANGE_MASK_DEFTYPE
mdefine_line|#define MTRR_CHANGE_MASK_DEFTYPE   0x04
macro_line|#endif
DECL|typedef|mtrr_type
r_typedef
id|u8
id|mtrr_type
suffix:semicolon
DECL|macro|LINE_SIZE
mdefine_line|#define LINE_SIZE      80
macro_line|#ifdef CONFIG_SMP
DECL|macro|set_mtrr
mdefine_line|#define set_mtrr(reg,base,size,type) set_mtrr_smp (reg, base, size, type)
macro_line|#else
DECL|macro|set_mtrr
mdefine_line|#define set_mtrr(reg,base,size,type) (*set_mtrr_up) (reg, base, size, type, &bslash;&n;&t;&t;&t;&t;&t;&t;       TRUE)
macro_line|#endif
macro_line|#if defined(CONFIG_PROC_FS) || defined(CONFIG_DEVFS_FS)
DECL|macro|USERSPACE_INTERFACE
mdefine_line|#define USERSPACE_INTERFACE
macro_line|#endif
macro_line|#ifndef USERSPACE_INTERFACE
DECL|macro|compute_ascii
mdefine_line|#define compute_ascii() while (0)
macro_line|#endif
macro_line|#ifdef USERSPACE_INTERFACE
DECL|variable|ascii_buffer
r_static
r_char
op_star
id|ascii_buffer
suffix:semicolon
DECL|variable|ascii_buf_bytes
r_static
r_int
r_int
id|ascii_buf_bytes
suffix:semicolon
macro_line|#endif
DECL|variable|usage_table
r_static
r_int
r_int
op_star
id|usage_table
suffix:semicolon
r_static
id|DECLARE_MUTEX
(paren
id|main_lock
)paren
suffix:semicolon
multiline_comment|/*  Private functions  */
macro_line|#ifdef USERSPACE_INTERFACE
r_static
r_void
id|compute_ascii
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
DECL|struct|set_mtrr_context
r_struct
id|set_mtrr_context
(brace
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
DECL|member|deftype_lo
r_int
r_int
id|deftype_lo
suffix:semicolon
DECL|member|deftype_hi
r_int
r_int
id|deftype_hi
suffix:semicolon
DECL|member|cr4val
r_int
r_int
id|cr4val
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*  Put the processor into a state where MTRRs can be safely set  */
DECL|function|set_mtrr_prepare
r_static
r_void
id|set_mtrr_prepare
(paren
r_struct
id|set_mtrr_context
op_star
id|ctxt
)paren
(brace
r_int
r_int
id|cr0
suffix:semicolon
multiline_comment|/* Disable interrupts locally */
id|__save_flags
c_func
(paren
id|ctxt-&gt;flags
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*  Save value of CR4 and clear Page Global Enable (bit 7)  */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|X86_FEATURE_PGE
comma
op_amp
id|boot_cpu_data.x86_capability
)paren
)paren
(brace
id|ctxt-&gt;cr4val
op_assign
id|read_cr4
c_func
(paren
)paren
suffix:semicolon
id|write_cr4
c_func
(paren
id|ctxt-&gt;cr4val
op_amp
op_complement
(paren
l_int|1UL
op_lshift
l_int|7
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*  Disable and flush caches. Note that wbinvd flushes the TLBs as&n;&t;a side-effect  */
id|cr0
op_assign
id|read_cr0
c_func
(paren
)paren
op_or
l_int|0x40000000
suffix:semicolon
id|wbinvd
c_func
(paren
)paren
suffix:semicolon
id|write_cr0
c_func
(paren
id|cr0
)paren
suffix:semicolon
id|wbinvd
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*  Disable MTRRs, and set the default type to uncached  */
id|rdmsr
c_func
(paren
id|MTRRdefType_MSR
comma
id|ctxt-&gt;deftype_lo
comma
id|ctxt-&gt;deftype_hi
)paren
suffix:semicolon
id|wrmsr
c_func
(paren
id|MTRRdefType_MSR
comma
id|ctxt-&gt;deftype_lo
op_amp
l_int|0xf300UL
comma
id|ctxt-&gt;deftype_hi
)paren
suffix:semicolon
)brace
multiline_comment|/*  Restore the processor after a set_mtrr_prepare  */
DECL|function|set_mtrr_done
r_static
r_void
id|set_mtrr_done
(paren
r_struct
id|set_mtrr_context
op_star
id|ctxt
)paren
(brace
multiline_comment|/*  Flush caches and TLBs  */
id|wbinvd
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*  Restore MTRRdefType  */
id|wrmsr
c_func
(paren
id|MTRRdefType_MSR
comma
id|ctxt-&gt;deftype_lo
comma
id|ctxt-&gt;deftype_hi
)paren
suffix:semicolon
multiline_comment|/*  Enable caches  */
id|write_cr0
c_func
(paren
id|read_cr0
c_func
(paren
)paren
op_amp
l_int|0xbfffffff
)paren
suffix:semicolon
multiline_comment|/*  Restore value of CR4  */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|X86_FEATURE_PGE
comma
op_amp
id|boot_cpu_data.x86_capability
)paren
)paren
id|write_cr4
(paren
id|ctxt-&gt;cr4val
)paren
suffix:semicolon
multiline_comment|/*  Re-enable interrupts locally (if enabled previously)  */
id|__restore_flags
c_func
(paren
id|ctxt-&gt;flags
)paren
suffix:semicolon
)brace
multiline_comment|/*  This function returns the number of variable MTRRs  */
DECL|function|get_num_var_ranges
r_static
r_int
r_int
id|get_num_var_ranges
(paren
r_void
)paren
(brace
r_int
r_int
id|config
comma
id|dummy
suffix:semicolon
id|rdmsr
(paren
id|MTRRcap_MSR
comma
id|config
comma
id|dummy
)paren
suffix:semicolon
r_return
(paren
id|config
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
multiline_comment|/*  Returns non-zero if we have the write-combining memory type  */
DECL|function|have_wrcomb
r_static
r_int
id|have_wrcomb
(paren
r_void
)paren
(brace
r_int
r_int
id|config
comma
id|dummy
suffix:semicolon
id|rdmsr
(paren
id|MTRRcap_MSR
comma
id|config
comma
id|dummy
)paren
suffix:semicolon
r_return
(paren
id|config
op_amp
(paren
l_int|1
op_lshift
l_int|10
)paren
)paren
suffix:semicolon
)brace
DECL|variable|size_or_mask
DECL|variable|size_and_mask
r_static
id|u32
id|size_or_mask
comma
id|size_and_mask
suffix:semicolon
DECL|function|get_mtrr
r_static
r_void
id|get_mtrr
(paren
r_int
r_int
id|reg
comma
r_int
r_int
op_star
id|base
comma
r_int
r_int
op_star
id|size
comma
id|mtrr_type
op_star
id|type
)paren
(brace
r_int
r_int
id|mask_lo
comma
id|mask_hi
comma
id|base_lo
comma
id|base_hi
suffix:semicolon
id|rdmsr
(paren
id|MTRRphysMask_MSR
(paren
id|reg
)paren
comma
id|mask_lo
comma
id|mask_hi
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mask_lo
op_amp
l_int|0x800
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*  Invalid (i.e. free) range  */
op_star
id|base
op_assign
l_int|0
suffix:semicolon
op_star
id|size
op_assign
l_int|0
suffix:semicolon
op_star
id|type
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rdmsr
(paren
id|MTRRphysBase_MSR
(paren
id|reg
)paren
comma
id|base_lo
comma
id|base_hi
)paren
suffix:semicolon
multiline_comment|/* Work out the shifted address mask. */
id|mask_lo
op_assign
id|size_or_mask
op_or
id|mask_hi
op_lshift
(paren
l_int|32
op_minus
id|PAGE_SHIFT
)paren
op_or
id|mask_lo
op_rshift
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/* This works correctly if size is a power of two, i.e. a&n;       contiguous range. */
op_star
id|size
op_assign
op_minus
id|mask_lo
suffix:semicolon
op_star
id|base
op_assign
id|base_hi
op_lshift
(paren
l_int|32
op_minus
id|PAGE_SHIFT
)paren
op_or
id|base_lo
op_rshift
id|PAGE_SHIFT
suffix:semicolon
op_star
id|type
op_assign
id|base_lo
op_amp
l_int|0xff
suffix:semicolon
)brace
DECL|function|set_mtrr_up
r_static
r_void
id|set_mtrr_up
(paren
r_int
r_int
id|reg
comma
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
id|mtrr_type
id|type
comma
r_int
id|do_safe
)paren
multiline_comment|/*  [SUMMARY] Set variable MTRR register on the local CPU.&n;    &lt;reg&gt; The register to set.&n;    &lt;base&gt; The base address of the region.&n;    &lt;size&gt; The size of the region. If this is 0 the region is disabled.&n;    &lt;type&gt; The type of the region.&n;    &lt;do_safe&gt; If TRUE, do the change safely. If FALSE, safety measures should&n;    be done externally.&n;    [RETURNS] Nothing.&n;*/
(brace
r_struct
id|set_mtrr_context
id|ctxt
suffix:semicolon
r_if
c_cond
(paren
id|do_safe
)paren
id|set_mtrr_prepare
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
(brace
multiline_comment|/* The invalid bit is kept in the mask, so we simply clear the&n;&t;   relevant mask register to disable a range. */
id|wrmsr
(paren
id|MTRRphysMask_MSR
(paren
id|reg
)paren
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|wrmsr
(paren
id|MTRRphysBase_MSR
(paren
id|reg
)paren
comma
id|base
op_lshift
id|PAGE_SHIFT
op_or
id|type
comma
(paren
id|base
op_amp
id|size_and_mask
)paren
op_rshift
(paren
l_int|32
op_minus
id|PAGE_SHIFT
)paren
)paren
suffix:semicolon
id|wrmsr
(paren
id|MTRRphysMask_MSR
(paren
id|reg
)paren
comma
op_minus
id|size
op_lshift
id|PAGE_SHIFT
op_or
l_int|0x800
comma
(paren
op_minus
id|size
op_amp
id|size_and_mask
)paren
op_rshift
(paren
l_int|32
op_minus
id|PAGE_SHIFT
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|do_safe
)paren
id|set_mtrr_done
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
DECL|struct|mtrr_var_range
r_struct
id|mtrr_var_range
(brace
DECL|member|base_lo
r_int
r_int
id|base_lo
suffix:semicolon
DECL|member|base_hi
r_int
r_int
id|base_hi
suffix:semicolon
DECL|member|mask_lo
r_int
r_int
id|mask_lo
suffix:semicolon
DECL|member|mask_hi
r_int
r_int
id|mask_hi
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*  Get the MSR pair relating to a var range  */
DECL|function|get_mtrr_var_range
r_static
r_void
id|__init
id|get_mtrr_var_range
(paren
r_int
r_int
id|index
comma
r_struct
id|mtrr_var_range
op_star
id|vr
)paren
(brace
id|rdmsr
(paren
id|MTRRphysBase_MSR
(paren
id|index
)paren
comma
id|vr-&gt;base_lo
comma
id|vr-&gt;base_hi
)paren
suffix:semicolon
id|rdmsr
(paren
id|MTRRphysMask_MSR
(paren
id|index
)paren
comma
id|vr-&gt;mask_lo
comma
id|vr-&gt;mask_hi
)paren
suffix:semicolon
)brace
multiline_comment|/*  Set the MSR pair relating to a var range. Returns TRUE if&n;    changes are made  */
r_static
r_int
id|__init
DECL|function|set_mtrr_var_range_testing
id|set_mtrr_var_range_testing
(paren
r_int
r_int
id|index
comma
r_struct
id|mtrr_var_range
op_star
id|vr
)paren
(brace
r_int
r_int
id|lo
comma
id|hi
suffix:semicolon
r_int
id|changed
op_assign
id|FALSE
suffix:semicolon
id|rdmsr
(paren
id|MTRRphysBase_MSR
(paren
id|index
)paren
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vr-&gt;base_lo
op_amp
l_int|0xfffff0ffUL
)paren
op_ne
(paren
id|lo
op_amp
l_int|0xfffff0ffUL
)paren
op_logical_or
(paren
id|vr-&gt;base_hi
op_amp
l_int|0xfUL
)paren
op_ne
(paren
id|hi
op_amp
l_int|0xfUL
)paren
)paren
(brace
id|wrmsr
(paren
id|MTRRphysBase_MSR
(paren
id|index
)paren
comma
id|vr-&gt;base_lo
comma
id|vr-&gt;base_hi
)paren
suffix:semicolon
id|changed
op_assign
id|TRUE
suffix:semicolon
)brace
id|rdmsr
(paren
id|MTRRphysMask_MSR
(paren
id|index
)paren
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vr-&gt;mask_lo
op_amp
l_int|0xfffff800UL
)paren
op_ne
(paren
id|lo
op_amp
l_int|0xfffff800UL
)paren
op_logical_or
(paren
id|vr-&gt;mask_hi
op_amp
l_int|0xfUL
)paren
op_ne
(paren
id|hi
op_amp
l_int|0xfUL
)paren
)paren
(brace
id|wrmsr
(paren
id|MTRRphysMask_MSR
(paren
id|index
)paren
comma
id|vr-&gt;mask_lo
comma
id|vr-&gt;mask_hi
)paren
suffix:semicolon
id|changed
op_assign
id|TRUE
suffix:semicolon
)brace
r_return
id|changed
suffix:semicolon
)brace
DECL|function|get_fixed_ranges
r_static
r_void
id|__init
id|get_fixed_ranges
(paren
id|mtrr_type
op_star
id|frs
)paren
(brace
r_int
r_int
op_star
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
id|frs
suffix:semicolon
r_int
id|i
suffix:semicolon
id|rdmsr
(paren
id|MTRRfix64K_00000_MSR
comma
id|p
(braket
l_int|0
)braket
comma
id|p
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
id|rdmsr
(paren
id|MTRRfix16K_80000_MSR
op_plus
id|i
comma
id|p
(braket
l_int|2
op_plus
id|i
op_star
l_int|2
)braket
comma
id|p
(braket
l_int|3
op_plus
id|i
op_star
l_int|2
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|rdmsr
(paren
id|MTRRfix4K_C0000_MSR
op_plus
id|i
comma
id|p
(braket
l_int|6
op_plus
id|i
op_star
l_int|2
)braket
comma
id|p
(braket
l_int|7
op_plus
id|i
op_star
l_int|2
)braket
)paren
suffix:semicolon
)brace
DECL|function|set_fixed_ranges_testing
r_static
r_int
id|__init
id|set_fixed_ranges_testing
(paren
id|mtrr_type
op_star
id|frs
)paren
(brace
r_int
r_int
op_star
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
id|frs
suffix:semicolon
r_int
id|changed
op_assign
id|FALSE
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|lo
comma
id|hi
suffix:semicolon
id|rdmsr
(paren
id|MTRRfix64K_00000_MSR
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
op_ne
id|lo
op_logical_or
id|p
(braket
l_int|1
)braket
op_ne
id|hi
)paren
(brace
id|wrmsr
(paren
id|MTRRfix64K_00000_MSR
comma
id|p
(braket
l_int|0
)braket
comma
id|p
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|changed
op_assign
id|TRUE
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rdmsr
(paren
id|MTRRfix16K_80000_MSR
op_plus
id|i
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|2
op_plus
id|i
op_star
l_int|2
)braket
op_ne
id|lo
op_logical_or
id|p
(braket
l_int|3
op_plus
id|i
op_star
l_int|2
)braket
op_ne
id|hi
)paren
(brace
id|wrmsr
(paren
id|MTRRfix16K_80000_MSR
op_plus
id|i
comma
id|p
(braket
l_int|2
op_plus
id|i
op_star
l_int|2
)braket
comma
id|p
(braket
l_int|3
op_plus
id|i
op_star
l_int|2
)braket
)paren
suffix:semicolon
id|changed
op_assign
id|TRUE
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rdmsr
(paren
id|MTRRfix4K_C0000_MSR
op_plus
id|i
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|6
op_plus
id|i
op_star
l_int|2
)braket
op_ne
id|lo
op_logical_or
id|p
(braket
l_int|7
op_plus
id|i
op_star
l_int|2
)braket
op_ne
id|hi
)paren
(brace
id|wrmsr
(paren
id|MTRRfix4K_C0000_MSR
op_plus
id|i
comma
id|p
(braket
l_int|6
op_plus
id|i
op_star
l_int|2
)braket
comma
id|p
(braket
l_int|7
op_plus
id|i
op_star
l_int|2
)braket
)paren
suffix:semicolon
id|changed
op_assign
id|TRUE
suffix:semicolon
)brace
)brace
r_return
id|changed
suffix:semicolon
)brace
DECL|struct|mtrr_state
r_struct
id|mtrr_state
(brace
DECL|member|num_var_ranges
r_int
r_int
id|num_var_ranges
suffix:semicolon
DECL|member|var_ranges
r_struct
id|mtrr_var_range
op_star
id|var_ranges
suffix:semicolon
DECL|member|fixed_ranges
id|mtrr_type
id|fixed_ranges
(braket
id|NUM_FIXED_RANGES
)braket
suffix:semicolon
DECL|member|enabled
r_int
r_char
id|enabled
suffix:semicolon
DECL|member|def_type
id|mtrr_type
id|def_type
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*  Grab all of the MTRR state for this CPU into *state  */
DECL|function|get_mtrr_state
r_static
r_void
id|__init
id|get_mtrr_state
(paren
r_struct
id|mtrr_state
op_star
id|state
)paren
(brace
r_int
r_int
id|nvrs
comma
id|i
suffix:semicolon
r_struct
id|mtrr_var_range
op_star
id|vrs
suffix:semicolon
r_int
r_int
id|lo
comma
id|dummy
suffix:semicolon
id|nvrs
op_assign
id|state-&gt;num_var_ranges
op_assign
id|get_num_var_ranges
(paren
)paren
suffix:semicolon
id|vrs
op_assign
id|state-&gt;var_ranges
op_assign
id|kmalloc
(paren
id|nvrs
op_star
r_sizeof
(paren
r_struct
id|mtrr_var_range
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vrs
op_eq
l_int|NULL
)paren
id|nvrs
op_assign
id|state-&gt;num_var_ranges
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nvrs
suffix:semicolon
id|i
op_increment
)paren
id|get_mtrr_var_range
(paren
id|i
comma
op_amp
id|vrs
(braket
id|i
)braket
)paren
suffix:semicolon
id|get_fixed_ranges
(paren
id|state-&gt;fixed_ranges
)paren
suffix:semicolon
id|rdmsr
(paren
id|MTRRdefType_MSR
comma
id|lo
comma
id|dummy
)paren
suffix:semicolon
id|state-&gt;def_type
op_assign
(paren
id|lo
op_amp
l_int|0xff
)paren
suffix:semicolon
id|state-&gt;enabled
op_assign
(paren
id|lo
op_amp
l_int|0xc00
)paren
op_rshift
l_int|10
suffix:semicolon
)brace
multiline_comment|/*  Free resources associated with a struct mtrr_state  */
DECL|function|finalize_mtrr_state
r_static
r_void
id|__init
id|finalize_mtrr_state
(paren
r_struct
id|mtrr_state
op_star
id|state
)paren
(brace
r_if
c_cond
(paren
id|state-&gt;var_ranges
)paren
id|kfree
(paren
id|state-&gt;var_ranges
)paren
suffix:semicolon
)brace
DECL|function|set_mtrr_state
r_static
r_int
r_int
id|__init
id|set_mtrr_state
(paren
r_struct
id|mtrr_state
op_star
id|state
comma
r_struct
id|set_mtrr_context
op_star
id|ctxt
)paren
multiline_comment|/*  [SUMMARY] Set the MTRR state for this CPU.&n;    &lt;state&gt; The MTRR state information to read.&n;    &lt;ctxt&gt; Some relevant CPU context.&n;    [NOTE] The CPU must already be in a safe state for MTRR changes.&n;    [RETURNS] 0 if no changes made, else a mask indication what was changed.&n;*/
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|change_mask
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|state-&gt;num_var_ranges
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|set_mtrr_var_range_testing
(paren
id|i
comma
op_amp
id|state-&gt;var_ranges
(braket
id|i
)braket
)paren
)paren
id|change_mask
op_or_assign
id|MTRR_CHANGE_MASK_VARIABLE
suffix:semicolon
r_if
c_cond
(paren
id|set_fixed_ranges_testing
(paren
id|state-&gt;fixed_ranges
)paren
)paren
id|change_mask
op_or_assign
id|MTRR_CHANGE_MASK_FIXED
suffix:semicolon
multiline_comment|/*  Set_mtrr_restore restores the old value of MTRRdefType,&n;&t;so to set it we fiddle with the saved value  */
r_if
c_cond
(paren
(paren
id|ctxt-&gt;deftype_lo
op_amp
l_int|0xff
)paren
op_ne
id|state-&gt;def_type
op_logical_or
(paren
(paren
id|ctxt-&gt;deftype_lo
op_amp
l_int|0xc00
)paren
op_rshift
l_int|10
)paren
op_ne
id|state-&gt;enabled
)paren
(brace
id|ctxt-&gt;deftype_lo
op_or_assign
(paren
id|state-&gt;def_type
op_or
id|state-&gt;enabled
op_lshift
l_int|10
)paren
suffix:semicolon
id|change_mask
op_or_assign
id|MTRR_CHANGE_MASK_DEFTYPE
suffix:semicolon
)brace
r_return
id|change_mask
suffix:semicolon
)brace
DECL|variable|undone_count
r_static
id|atomic_t
id|undone_count
suffix:semicolon
DECL|variable|wait_barrier_execute
r_static
r_volatile
r_int
id|wait_barrier_execute
op_assign
id|FALSE
suffix:semicolon
DECL|variable|wait_barrier_cache_enable
r_static
r_volatile
r_int
id|wait_barrier_cache_enable
op_assign
id|FALSE
suffix:semicolon
DECL|struct|set_mtrr_data
r_struct
id|set_mtrr_data
(brace
DECL|member|smp_base
r_int
r_int
id|smp_base
suffix:semicolon
DECL|member|smp_size
r_int
r_int
id|smp_size
suffix:semicolon
DECL|member|smp_reg
r_int
r_int
id|smp_reg
suffix:semicolon
DECL|member|smp_type
id|mtrr_type
id|smp_type
suffix:semicolon
)brace
suffix:semicolon
DECL|function|ipi_handler
r_static
r_void
id|ipi_handler
(paren
r_void
op_star
id|info
)paren
multiline_comment|/*  [SUMMARY] Synchronisation handler. Executed by &quot;other&quot; CPUs.&n;    [RETURNS] Nothing.&n;*/
(brace
r_struct
id|set_mtrr_data
op_star
id|data
op_assign
id|info
suffix:semicolon
r_struct
id|set_mtrr_context
id|ctxt
suffix:semicolon
id|set_mtrr_prepare
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
multiline_comment|/*  Notify master that I&squot;ve flushed and disabled my cache  */
id|atomic_dec
(paren
op_amp
id|undone_count
)paren
suffix:semicolon
r_while
c_loop
(paren
id|wait_barrier_execute
)paren
id|barrier
(paren
)paren
suffix:semicolon
multiline_comment|/*  The master has cleared me to execute  */
(paren
op_star
id|set_mtrr_up
)paren
(paren
id|data-&gt;smp_reg
comma
id|data-&gt;smp_base
comma
id|data-&gt;smp_size
comma
id|data-&gt;smp_type
comma
id|FALSE
)paren
suffix:semicolon
multiline_comment|/*  Notify master CPU that I&squot;ve executed the function  */
id|atomic_dec
(paren
op_amp
id|undone_count
)paren
suffix:semicolon
multiline_comment|/*  Wait for master to clear me to enable cache and return  */
r_while
c_loop
(paren
id|wait_barrier_cache_enable
)paren
id|barrier
(paren
)paren
suffix:semicolon
id|set_mtrr_done
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
)brace
DECL|function|set_mtrr_smp
r_static
r_void
id|set_mtrr_smp
(paren
r_int
r_int
id|reg
comma
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
id|mtrr_type
id|type
)paren
(brace
r_struct
id|set_mtrr_data
id|data
suffix:semicolon
r_struct
id|set_mtrr_context
id|ctxt
suffix:semicolon
id|data.smp_reg
op_assign
id|reg
suffix:semicolon
id|data.smp_base
op_assign
id|base
suffix:semicolon
id|data.smp_size
op_assign
id|size
suffix:semicolon
id|data.smp_type
op_assign
id|type
suffix:semicolon
id|wait_barrier_execute
op_assign
id|TRUE
suffix:semicolon
id|wait_barrier_cache_enable
op_assign
id|TRUE
suffix:semicolon
id|atomic_set
(paren
op_amp
id|undone_count
comma
id|smp_num_cpus
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*  Start the ball rolling on other CPUs  */
r_if
c_cond
(paren
id|smp_call_function
(paren
id|ipi_handler
comma
op_amp
id|data
comma
l_int|1
comma
l_int|0
)paren
op_ne
l_int|0
)paren
id|panic
(paren
l_string|&quot;mtrr: timed out waiting for other CPUs&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Flush and disable the local CPU&squot;s cache */
id|set_mtrr_prepare
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
multiline_comment|/*  Wait for all other CPUs to flush and disable their caches  */
r_while
c_loop
(paren
id|atomic_read
(paren
op_amp
id|undone_count
)paren
OG
l_int|0
)paren
id|barrier
(paren
)paren
suffix:semicolon
multiline_comment|/* Set up for completion wait and then release other CPUs to change MTRRs */
id|atomic_set
(paren
op_amp
id|undone_count
comma
id|smp_num_cpus
op_minus
l_int|1
)paren
suffix:semicolon
id|wait_barrier_execute
op_assign
id|FALSE
suffix:semicolon
(paren
op_star
id|set_mtrr_up
)paren
(paren
id|reg
comma
id|base
comma
id|size
comma
id|type
comma
id|FALSE
)paren
suffix:semicolon
multiline_comment|/*  Now wait for other CPUs to complete the function  */
r_while
c_loop
(paren
id|atomic_read
(paren
op_amp
id|undone_count
)paren
OG
l_int|0
)paren
id|barrier
(paren
)paren
suffix:semicolon
multiline_comment|/*  Now all CPUs should have finished the function. Release the barrier to&n;&t;allow them to re-enable their caches and return from their interrupt,&n;&t;then enable the local cache and return  */
id|wait_barrier_cache_enable
op_assign
id|FALSE
suffix:semicolon
id|set_mtrr_done
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
)brace
multiline_comment|/*  Some BIOS&squot;s are fucked and don&squot;t set all MTRRs the same!  */
DECL|function|mtrr_state_warn
r_static
r_void
id|__init
id|mtrr_state_warn
(paren
r_int
r_int
id|mask
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mask
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
id|MTRR_CHANGE_MASK_FIXED
)paren
id|printk
(paren
l_string|&quot;mtrr: your CPUs had inconsistent fixed MTRR settings&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
id|MTRR_CHANGE_MASK_VARIABLE
)paren
id|printk
(paren
l_string|&quot;mtrr: your CPUs had inconsistent variable MTRR settings&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
id|MTRR_CHANGE_MASK_DEFTYPE
)paren
id|printk
(paren
l_string|&quot;mtrr: your CPUs had inconsistent MTRRdefType settings&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: probably your BIOS does not setup all CPUs&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif  /*  CONFIG_SMP  */
DECL|function|attrib_to_str
r_static
r_char
r_inline
op_star
id|attrib_to_str
(paren
r_int
id|x
)paren
(brace
r_return
(paren
id|x
op_le
l_int|6
)paren
ques
c_cond
id|mtrr_strings
(braket
id|x
)braket
suffix:colon
l_string|&quot;?&quot;
suffix:semicolon
)brace
DECL|function|init_table
r_static
r_void
id|__init
id|init_table
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|max
suffix:semicolon
id|max
op_assign
id|get_num_var_ranges
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|usage_table
op_assign
id|kmalloc
(paren
id|max
op_star
r_sizeof
op_star
id|usage_table
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: could not allocate&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
id|i
op_increment
)paren
id|usage_table
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef USERSPACE_INTERFACE
r_if
c_cond
(paren
(paren
id|ascii_buffer
op_assign
id|kmalloc
(paren
id|max
op_star
id|LINE_SIZE
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: could not allocate&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ascii_buf_bytes
op_assign
l_int|0
suffix:semicolon
id|compute_ascii
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|generic_get_free_region
r_static
r_int
id|generic_get_free_region
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|size
)paren
multiline_comment|/*  [SUMMARY] Get a free MTRR.&n;    &lt;base&gt; The starting (base) address of the region.&n;    &lt;size&gt; The size (in bytes) of the region.&n;    [RETURNS] The index of the region on success, else -1 on error.&n;*/
(brace
r_int
id|i
comma
id|max
suffix:semicolon
id|mtrr_type
id|ltype
suffix:semicolon
r_int
r_int
id|lbase
comma
id|lsize
suffix:semicolon
id|max
op_assign
id|get_num_var_ranges
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
op_increment
id|i
)paren
(brace
(paren
op_star
id|get_mtrr
)paren
(paren
id|i
comma
op_amp
id|lbase
comma
op_amp
id|lsize
comma
op_amp
id|ltype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lsize
op_eq
l_int|0
)paren
r_return
id|i
suffix:semicolon
)brace
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
DECL|variable|get_free_region
r_static
r_int
(paren
op_star
id|get_free_region
)paren
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|size
)paren
op_assign
id|generic_get_free_region
suffix:semicolon
multiline_comment|/**&n; *&t;mtrr_add_page - Add a memory type region&n; *&t;@base: Physical base address of region in pages (4 KB)&n; *&t;@size: Physical size of region in pages (4 KB)&n; *&t;@type: Type of MTRR desired&n; *&t;@increment: If this is true do usage counting on the region&n; *&n; *&t;Memory type region registers control the caching on newer Intel and&n; *&t;non Intel processors. This function allows drivers to request an&n; *&t;MTRR is added. The details and hardware specifics of each processor&squot;s&n; *&t;implementation are hidden from the caller, but nevertheless the &n; *&t;caller should expect to need to provide a power of two size on an&n; *&t;equivalent power of two boundary.&n; *&n; *&t;If the region cannot be added either because all regions are in use&n; *&t;or the CPU cannot support it a negative value is returned. On success&n; *&t;the register number for this entry is returned, but should be treated&n; *&t;as a cookie only.&n; *&n; *&t;On a multiprocessor machine the changes are made to all processors.&n; *&t;This is required on x86 by the Intel processors.&n; *&n; *&t;The available types are&n; *&n; *&t;%MTRR_TYPE_UNCACHABLE&t;-&t;No caching&n; *&n; *&t;%MTRR_TYPE_WRBACK&t;-&t;Write data back in bursts whenever&n; *&n; *&t;%MTRR_TYPE_WRCOMB&t;-&t;Write data back soon but allow bursts&n; *&n; *&t;%MTRR_TYPE_WRTHROUGH&t;-&t;Cache reads but not writes&n; *&n; *&t;BUGS: Needs a quiet flag for the cases where drivers do not mind&n; *&t;failures and do not wish system log messages to be sent.&n; */
DECL|function|mtrr_add_page
r_int
id|mtrr_add_page
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
r_int
r_int
id|type
comma
r_char
id|increment
)paren
(brace
multiline_comment|/*  [SUMMARY] Add an MTRR entry.&n;    &lt;base&gt; The starting (base, in pages) address of the region.&n;    &lt;size&gt; The size of the region. (in pages)&n;    &lt;type&gt; The type of the new region.&n;    &lt;increment&gt; If true and the region already exists, the usage count will be&n;    incremented.&n;    [RETURNS] The MTRR register on success, else a negative number indicating&n;    the error code.&n;    [NOTE] This routine uses a spinlock.&n;*/
r_int
id|i
comma
id|max
suffix:semicolon
id|mtrr_type
id|ltype
suffix:semicolon
r_int
r_int
id|lbase
comma
id|lsize
comma
id|last
suffix:semicolon
r_if
c_cond
(paren
id|base
op_plus
id|size
OL
l_int|0x100
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;mtrr: cannot set region below 1 MiB (0x%lx000,0x%lx000)&bslash;n&quot;
comma
id|base
comma
id|size
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*  Check upper bits of base and last are equal and lower bits are 0&n;&t;    for base and 1 for last  */
id|last
op_assign
id|base
op_plus
id|size
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|lbase
op_assign
id|base
suffix:semicolon
op_logical_neg
(paren
id|lbase
op_amp
l_int|1
)paren
op_logical_and
(paren
id|last
op_amp
l_int|1
)paren
suffix:semicolon
id|lbase
op_assign
id|lbase
op_rshift
l_int|1
comma
id|last
op_assign
id|last
op_rshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lbase
op_ne
id|last
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;mtrr: base(0x%lx000) is not aligned on a size(0x%lx000) boundary&bslash;n&quot;
comma
id|base
comma
id|size
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
op_ge
id|MTRR_NUM_TYPES
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: type: %u illegal&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*  If the type is WC, check that this processor supports it  */
r_if
c_cond
(paren
(paren
id|type
op_eq
id|MTRR_TYPE_WRCOMB
)paren
op_logical_and
op_logical_neg
id|have_wrcomb
(paren
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;mtrr: your processor doesn&squot;t support write-combining&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base
op_amp
id|size_or_mask
op_logical_or
id|size
op_amp
id|size_or_mask
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: base or size exceeds the MTRR width&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|increment
op_assign
id|increment
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|max
op_assign
id|get_num_var_ranges
(paren
)paren
suffix:semicolon
multiline_comment|/*  Search for existing MTRR  */
id|down
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
op_increment
id|i
)paren
(brace
(paren
op_star
id|get_mtrr
)paren
(paren
id|i
comma
op_amp
id|lbase
comma
op_amp
id|lsize
comma
op_amp
id|ltype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
op_ge
id|lbase
op_plus
id|lsize
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base
OL
id|lbase
)paren
op_logical_and
(paren
id|base
op_plus
id|size
op_le
id|lbase
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*  At this point we know there is some kind of overlap/enclosure  */
r_if
c_cond
(paren
(paren
id|base
OL
id|lbase
)paren
op_logical_or
(paren
id|base
op_plus
id|size
OG
id|lbase
op_plus
id|lsize
)paren
)paren
(brace
id|up
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;mtrr: 0x%lx000,0x%lx000 overlaps existing&quot;
l_string|&quot; 0x%lx000,0x%lx000&bslash;n&quot;
comma
id|base
comma
id|size
comma
id|lbase
comma
id|lsize
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*  New region is enclosed by an existing region  */
r_if
c_cond
(paren
id|ltype
op_ne
id|type
)paren
(brace
r_if
c_cond
(paren
id|type
op_eq
id|MTRR_TYPE_UNCACHABLE
)paren
r_continue
suffix:semicolon
id|up
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: type mismatch for %lx000,%lx000 old: %s new: %s&bslash;n&quot;
comma
id|base
comma
id|size
comma
id|attrib_to_str
(paren
id|ltype
)paren
comma
id|attrib_to_str
(paren
id|type
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|increment
)paren
op_increment
id|usage_table
(braket
id|i
)braket
suffix:semicolon
id|compute_ascii
(paren
)paren
suffix:semicolon
id|up
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*  Search for an empty MTRR  */
id|i
op_assign
(paren
op_star
id|get_free_region
)paren
(paren
id|base
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|up
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: no more MTRRs available&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
id|set_mtrr
(paren
id|i
comma
id|base
comma
id|size
comma
id|type
)paren
suffix:semicolon
id|usage_table
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
id|compute_ascii
(paren
)paren
suffix:semicolon
id|up
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mtrr_add - Add a memory type region&n; *&t;@base: Physical base address of region&n; *&t;@size: Physical size of region&n; *&t;@type: Type of MTRR desired&n; *&t;@increment: If this is true do usage counting on the region&n; *&n; *&t;Memory type region registers control the caching on newer Intel and&n; *&t;non Intel processors. This function allows drivers to request an&n; *&t;MTRR is added. The details and hardware specifics of each processor&squot;s&n; *&t;implementation are hidden from the caller, but nevertheless the &n; *&t;caller should expect to need to provide a power of two size on an&n; *&t;equivalent power of two boundary.&n; *&n; *&t;If the region cannot be added either because all regions are in use&n; *&t;or the CPU cannot support it a negative value is returned. On success&n; *&t;the register number for this entry is returned, but should be treated&n; *&t;as a cookie only.&n; *&n; *&t;On a multiprocessor machine the changes are made to all processors.&n; *&t;This is required on x86 by the Intel processors.&n; *&n; *&t;The available types are&n; *&n; *&t;%MTRR_TYPE_UNCACHABLE&t;-&t;No caching&n; *&n; *&t;%MTRR_TYPE_WRBACK&t;-&t;Write data back in bursts whenever&n; *&n; *&t;%MTRR_TYPE_WRCOMB&t;-&t;Write data back soon but allow bursts&n; *&n; *&t;%MTRR_TYPE_WRTHROUGH&t;-&t;Cache reads but not writes&n; *&n; *&t;BUGS: Needs a quiet flag for the cases where drivers do not mind&n; *&t;failures and do not wish system log messages to be sent.&n; */
DECL|function|mtrr_add
r_int
id|mtrr_add
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
r_int
r_int
id|type
comma
r_char
id|increment
)paren
(brace
multiline_comment|/*  [SUMMARY] Add an MTRR entry.&n;    &lt;base&gt; The starting (base) address of the region.&n;    &lt;size&gt; The size (in bytes) of the region.&n;    &lt;type&gt; The type of the new region.&n;    &lt;increment&gt; If true and the region already exists, the usage count will be&n;    incremented.&n;    [RETURNS] The MTRR register on success, else a negative number indicating&n;    the error code.&n;*/
r_if
c_cond
(paren
(paren
id|base
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
op_logical_or
(paren
id|size
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: size and base must be multiples of 4 kiB&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: size: 0x%lx  base: 0x%lx&bslash;n&quot;
comma
id|size
comma
id|base
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|mtrr_add_page
(paren
id|base
op_rshift
id|PAGE_SHIFT
comma
id|size
op_rshift
id|PAGE_SHIFT
comma
id|type
comma
id|increment
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mtrr_del_page - delete a memory type region&n; *&t;@reg: Register returned by mtrr_add&n; *&t;@base: Physical base address&n; *&t;@size: Size of region&n; *&n; *&t;If register is supplied then base and size are ignored. This is&n; *&t;how drivers should call it.&n; *&n; *&t;Releases an MTRR region. If the usage count drops to zero the &n; *&t;register is freed and the region returns to default state.&n; *&t;On success the register is returned, on failure a negative error&n; *&t;code.&n; */
DECL|function|mtrr_del_page
r_int
id|mtrr_del_page
(paren
r_int
id|reg
comma
r_int
r_int
id|base
comma
r_int
r_int
id|size
)paren
multiline_comment|/*  [SUMMARY] Delete MTRR/decrement usage count.&n;    &lt;reg&gt; The register. If this is less than 0 then &lt;&lt;base&gt;&gt; and &lt;&lt;size&gt;&gt; must&n;    be supplied.&n;    &lt;base&gt; The base address of the region. This is ignored if &lt;&lt;reg&gt;&gt; is &gt;= 0.&n;    &lt;size&gt; The size of the region. This is ignored if &lt;&lt;reg&gt;&gt; is &gt;= 0.&n;    [RETURNS] The register on success, else a negative number indicating&n;    the error code.&n;    [NOTE] This routine uses a spinlock.&n;*/
(brace
r_int
id|i
comma
id|max
suffix:semicolon
id|mtrr_type
id|ltype
suffix:semicolon
r_int
r_int
id|lbase
comma
id|lsize
suffix:semicolon
id|max
op_assign
id|get_num_var_ranges
(paren
)paren
suffix:semicolon
id|down
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
OL
l_int|0
)paren
(brace
multiline_comment|/*  Search for existing MTRR  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
op_increment
id|i
)paren
(brace
(paren
op_star
id|get_mtrr
)paren
(paren
id|i
comma
op_amp
id|lbase
comma
op_amp
id|lsize
comma
op_amp
id|ltype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lbase
op_eq
id|base
op_logical_and
id|lsize
op_eq
id|size
)paren
(brace
id|reg
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|reg
OL
l_int|0
)paren
(brace
id|up
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: no MTRR for %lx000,%lx000 found&bslash;n&quot;
comma
id|base
comma
id|size
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|reg
op_ge
id|max
)paren
(brace
id|up
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: register: %d too big&bslash;n&quot;
comma
id|reg
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
(paren
op_star
id|get_mtrr
)paren
(paren
id|reg
comma
op_amp
id|lbase
comma
op_amp
id|lsize
comma
op_amp
id|ltype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lsize
OL
l_int|1
)paren
(brace
id|up
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: MTRR %d not used&bslash;n&quot;
comma
id|reg
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usage_table
(braket
id|reg
)braket
OL
l_int|1
)paren
(brace
id|up
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: reg: %d has count=0&bslash;n&quot;
comma
id|reg
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|usage_table
(braket
id|reg
)braket
OL
l_int|1
)paren
id|set_mtrr
(paren
id|reg
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|compute_ascii
(paren
)paren
suffix:semicolon
id|up
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
r_return
id|reg
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;mtrr_del - delete a memory type region&n; *&t;@reg: Register returned by mtrr_add&n; *&t;@base: Physical base address&n; *&t;@size: Size of region&n; *&n; *&t;If register is supplied then base and size are ignored. This is&n; *&t;how drivers should call it.&n; *&n; *&t;Releases an MTRR region. If the usage count drops to zero the &n; *&t;register is freed and the region returns to default state.&n; *&t;On success the register is returned, on failure a negative error&n; *&t;code.&n; */
DECL|function|mtrr_del
r_int
id|mtrr_del
(paren
r_int
id|reg
comma
r_int
r_int
id|base
comma
r_int
r_int
id|size
)paren
multiline_comment|/*  [SUMMARY] Delete MTRR/decrement usage count.&n;    &lt;reg&gt; The register. If this is less than 0 then &lt;&lt;base&gt;&gt; and &lt;&lt;size&gt;&gt; must&n;    be supplied.&n;    &lt;base&gt; The base address of the region. This is ignored if &lt;&lt;reg&gt;&gt; is &gt;= 0.&n;    &lt;size&gt; The size of the region. This is ignored if &lt;&lt;reg&gt;&gt; is &gt;= 0.&n;    [RETURNS] The register on success, else a negative number indicating&n;    the error code.&n;*/
(brace
r_if
c_cond
(paren
(paren
id|base
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
op_logical_or
(paren
id|size
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: size and base must be multiples of 4 kiB&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: size: 0x%lx  base: 0x%lx&bslash;n&quot;
comma
id|size
comma
id|base
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|mtrr_del_page
(paren
id|reg
comma
id|base
op_rshift
id|PAGE_SHIFT
comma
id|size
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
)brace
macro_line|#ifdef USERSPACE_INTERFACE
DECL|function|mtrr_file_add
r_static
r_int
id|mtrr_file_add
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
r_int
r_int
id|type
comma
r_char
id|increment
comma
r_struct
id|file
op_star
id|file
comma
r_int
id|page
)paren
(brace
r_int
id|reg
comma
id|max
suffix:semicolon
r_int
r_int
op_star
id|fcount
op_assign
id|file-&gt;private_data
suffix:semicolon
id|max
op_assign
id|get_num_var_ranges
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fcount
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|fcount
op_assign
id|kmalloc
(paren
id|max
op_star
r_sizeof
op_star
id|fcount
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: could not allocate&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
(paren
id|fcount
comma
l_int|0
comma
id|max
op_star
r_sizeof
op_star
id|fcount
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
id|fcount
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
r_if
c_cond
(paren
(paren
id|base
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
op_logical_or
(paren
id|size
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: size and base must be multiples of 4 kiB&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: size: 0x%lx  base: 0x%lx&bslash;n&quot;
comma
id|size
comma
id|base
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|base
op_rshift_assign
id|PAGE_SHIFT
suffix:semicolon
id|size
op_rshift_assign
id|PAGE_SHIFT
suffix:semicolon
)brace
id|reg
op_assign
id|mtrr_add_page
(paren
id|base
comma
id|size
comma
id|type
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_ge
l_int|0
)paren
op_increment
id|fcount
(braket
id|reg
)braket
suffix:semicolon
r_return
id|reg
suffix:semicolon
)brace
DECL|function|mtrr_file_del
r_static
r_int
id|mtrr_file_del
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
r_struct
id|file
op_star
id|file
comma
r_int
id|page
)paren
(brace
r_int
id|reg
suffix:semicolon
r_int
r_int
op_star
id|fcount
op_assign
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
r_if
c_cond
(paren
(paren
id|base
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
op_logical_or
(paren
id|size
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: size and base must be multiples of 4 kiB&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: size: 0x%lx  base: 0x%lx&bslash;n&quot;
comma
id|size
comma
id|base
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|base
op_rshift_assign
id|PAGE_SHIFT
suffix:semicolon
id|size
op_rshift_assign
id|PAGE_SHIFT
suffix:semicolon
)brace
id|reg
op_assign
id|mtrr_del_page
(paren
op_minus
l_int|1
comma
id|base
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
OL
l_int|0
)paren
r_return
id|reg
suffix:semicolon
r_if
c_cond
(paren
id|fcount
op_eq
l_int|NULL
)paren
r_return
id|reg
suffix:semicolon
r_if
c_cond
(paren
id|fcount
(braket
id|reg
)braket
OL
l_int|1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
op_decrement
id|fcount
(braket
id|reg
)braket
suffix:semicolon
r_return
id|reg
suffix:semicolon
)brace
DECL|function|mtrr_read
r_static
id|ssize_t
id|mtrr_read
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|len
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_if
c_cond
(paren
op_star
id|ppos
op_ge
id|ascii_buf_bytes
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ppos
op_plus
id|len
OG
id|ascii_buf_bytes
)paren
id|len
op_assign
id|ascii_buf_bytes
op_minus
op_star
id|ppos
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
(paren
id|buf
comma
id|ascii_buffer
op_plus
op_star
id|ppos
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
op_star
id|ppos
op_add_assign
id|len
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|mtrr_write
r_static
id|ssize_t
id|mtrr_write
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|len
comma
id|loff_t
op_star
id|ppos
)paren
multiline_comment|/*  Format of control line:&n;    &quot;base=%Lx size=%Lx type=%s&quot;     OR:&n;    &quot;disable=%d&quot;&n;*/
(brace
r_int
id|i
comma
id|err
suffix:semicolon
r_int
r_int
id|reg
suffix:semicolon
r_int
r_int
r_int
id|base
comma
id|size
suffix:semicolon
r_char
op_star
id|ptr
suffix:semicolon
r_char
id|line
(braket
id|LINE_SIZE
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/*  Can&squot;t seek (pwrite) on this device  */
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
id|memset
(paren
id|line
comma
l_int|0
comma
id|LINE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|LINE_SIZE
)paren
id|len
op_assign
id|LINE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
id|line
comma
id|buf
comma
id|len
op_minus
l_int|1
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ptr
op_assign
id|line
op_plus
id|strlen
(paren
id|line
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ptr
op_eq
l_char|&squot;&bslash;n&squot;
)paren
op_star
id|ptr
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
(paren
id|line
comma
l_string|&quot;disable=&quot;
comma
l_int|8
)paren
)paren
(brace
id|reg
op_assign
id|simple_strtoul
(paren
id|line
op_plus
l_int|8
comma
op_amp
id|ptr
comma
l_int|0
)paren
suffix:semicolon
id|err
op_assign
id|mtrr_del_page
(paren
id|reg
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strncmp
(paren
id|line
comma
l_string|&quot;base=&quot;
comma
l_int|5
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: no &bslash;&quot;base=&bslash;&quot; in line: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|line
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|base
op_assign
id|simple_strtoull
(paren
id|line
op_plus
l_int|5
comma
op_amp
id|ptr
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|isspace
(paren
op_star
id|ptr
)paren
suffix:semicolon
op_increment
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
(paren
id|ptr
comma
l_string|&quot;size=&quot;
comma
l_int|5
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: no &bslash;&quot;size=&bslash;&quot; in line: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|line
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|size
op_assign
id|simple_strtoull
(paren
id|ptr
op_plus
l_int|5
comma
op_amp
id|ptr
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base
op_amp
l_int|0xfff
)paren
op_logical_or
(paren
id|size
op_amp
l_int|0xfff
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: size and base must be multiples of 4 kiB&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: size: 0x%Lx  base: 0x%Lx&bslash;n&quot;
comma
id|size
comma
id|base
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|isspace
(paren
op_star
id|ptr
)paren
suffix:semicolon
op_increment
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
(paren
id|ptr
comma
l_string|&quot;type=&quot;
comma
l_int|5
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: no &bslash;&quot;type=&bslash;&quot; in line: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|line
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ptr
op_add_assign
l_int|5
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|isspace
(paren
op_star
id|ptr
)paren
suffix:semicolon
op_increment
id|ptr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MTRR_NUM_TYPES
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|strcmp
(paren
id|ptr
comma
id|mtrr_strings
(braket
id|i
)braket
)paren
)paren
r_continue
suffix:semicolon
id|base
op_rshift_assign
id|PAGE_SHIFT
suffix:semicolon
id|size
op_rshift_assign
id|PAGE_SHIFT
suffix:semicolon
id|err
op_assign
id|mtrr_add_page
(paren
(paren
r_int
r_int
)paren
id|base
comma
(paren
r_int
r_int
)paren
id|size
comma
id|i
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;mtrr: illegal type: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|ptr
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|mtrr_ioctl
r_static
r_int
id|mtrr_ioctl
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|err
suffix:semicolon
id|mtrr_type
id|type
suffix:semicolon
r_struct
id|mtrr_sentry
id|sentry
suffix:semicolon
r_struct
id|mtrr_gentry
id|gentry
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
r_case
id|MTRRIOC_ADD_ENTRY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|sentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|sentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|mtrr_file_add
(paren
id|sentry.base
comma
id|sentry.size
comma
id|sentry.type
comma
l_int|1
comma
id|file
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRRIOC_SET_ENTRY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|sentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|sentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|mtrr_add
(paren
id|sentry.base
comma
id|sentry.size
comma
id|sentry.type
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRRIOC_DEL_ENTRY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|sentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|sentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|mtrr_file_del
(paren
id|sentry.base
comma
id|sentry.size
comma
id|file
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRRIOC_KILL_ENTRY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|sentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|sentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|mtrr_del
(paren
op_minus
l_int|1
comma
id|sentry.base
comma
id|sentry.size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRRIOC_GET_ENTRY
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|gentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|gentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|gentry.regnum
op_ge
id|get_num_var_ranges
(paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
(paren
op_star
id|get_mtrr
)paren
(paren
id|gentry.regnum
comma
op_amp
id|gentry.base
comma
op_amp
id|gentry.size
comma
op_amp
id|type
)paren
suffix:semicolon
multiline_comment|/* Hide entries that go above 4GB */
r_if
c_cond
(paren
id|gentry.base
op_plus
id|gentry.size
OG
l_int|0x100000
op_logical_or
id|gentry.size
op_eq
l_int|0x100000
)paren
id|gentry.base
op_assign
id|gentry.size
op_assign
id|gentry.type
op_assign
l_int|0
suffix:semicolon
r_else
(brace
id|gentry.base
op_lshift_assign
id|PAGE_SHIFT
suffix:semicolon
id|gentry.size
op_lshift_assign
id|PAGE_SHIFT
suffix:semicolon
id|gentry.type
op_assign
id|type
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|gentry
comma
r_sizeof
id|gentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRRIOC_ADD_PAGE_ENTRY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|sentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|sentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|mtrr_file_add
(paren
id|sentry.base
comma
id|sentry.size
comma
id|sentry.type
comma
l_int|1
comma
id|file
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRRIOC_SET_PAGE_ENTRY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|sentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|sentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|mtrr_add_page
(paren
id|sentry.base
comma
id|sentry.size
comma
id|sentry.type
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRRIOC_DEL_PAGE_ENTRY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|sentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|sentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|mtrr_file_del
(paren
id|sentry.base
comma
id|sentry.size
comma
id|file
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRRIOC_KILL_PAGE_ENTRY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|sentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|sentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|mtrr_del_page
(paren
op_minus
l_int|1
comma
id|sentry.base
comma
id|sentry.size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRRIOC_GET_PAGE_ENTRY
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|gentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|gentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|gentry.regnum
op_ge
id|get_num_var_ranges
(paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
(paren
op_star
id|get_mtrr
)paren
(paren
id|gentry.regnum
comma
op_amp
id|gentry.base
comma
op_amp
id|gentry.size
comma
op_amp
id|type
)paren
suffix:semicolon
id|gentry.type
op_assign
id|type
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|gentry
comma
r_sizeof
id|gentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mtrr_close
r_static
r_int
id|mtrr_close
(paren
r_struct
id|inode
op_star
id|ino
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|i
comma
id|max
suffix:semicolon
r_int
r_int
op_star
id|fcount
op_assign
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|fcount
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|lock_kernel
(paren
)paren
suffix:semicolon
id|max
op_assign
id|get_num_var_ranges
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
op_increment
id|i
)paren
(brace
r_while
c_loop
(paren
id|fcount
(braket
id|i
)braket
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|mtrr_del
(paren
id|i
comma
l_int|0
comma
l_int|0
)paren
OL
l_int|0
)paren
id|printk
(paren
l_string|&quot;mtrr: reg %d not used&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
op_decrement
id|fcount
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
id|unlock_kernel
(paren
)paren
suffix:semicolon
id|kfree
(paren
id|fcount
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|mtrr_fops
r_static
r_struct
id|file_operations
id|mtrr_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|read
suffix:colon
id|mtrr_read
comma
id|write
suffix:colon
id|mtrr_write
comma
id|ioctl
suffix:colon
id|mtrr_ioctl
comma
id|release
suffix:colon
id|mtrr_close
comma
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
DECL|variable|proc_root_mtrr
r_static
r_struct
id|proc_dir_entry
op_star
id|proc_root_mtrr
suffix:semicolon
macro_line|#endif
DECL|variable|devfs_handle
r_static
id|devfs_handle_t
id|devfs_handle
suffix:semicolon
DECL|function|compute_ascii
r_static
r_void
id|compute_ascii
(paren
r_void
)paren
(brace
r_char
id|factor
suffix:semicolon
r_int
id|i
comma
id|max
suffix:semicolon
id|mtrr_type
id|type
suffix:semicolon
r_int
r_int
id|base
comma
id|size
suffix:semicolon
id|ascii_buf_bytes
op_assign
l_int|0
suffix:semicolon
id|max
op_assign
id|get_num_var_ranges
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
id|i
op_increment
)paren
(brace
(paren
op_star
id|get_mtrr
)paren
(paren
id|i
comma
op_amp
id|base
comma
op_amp
id|size
comma
op_amp
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
id|usage_table
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|size
OL
(paren
l_int|0x100000
op_rshift
id|PAGE_SHIFT
)paren
)paren
(brace
multiline_comment|/* less than 1MB */
id|factor
op_assign
l_char|&squot;K&squot;
suffix:semicolon
id|size
op_lshift_assign
id|PAGE_SHIFT
op_minus
l_int|10
suffix:semicolon
)brace
r_else
(brace
id|factor
op_assign
l_char|&squot;M&squot;
suffix:semicolon
id|size
op_rshift_assign
l_int|20
op_minus
id|PAGE_SHIFT
suffix:semicolon
)brace
id|sprintf
(paren
id|ascii_buffer
op_plus
id|ascii_buf_bytes
comma
l_string|&quot;reg%02i: base=0x%05lx000 (%4liMB), size=%4li%cB: %s, count=%d&bslash;n&quot;
comma
id|i
comma
id|base
comma
id|base
op_rshift
(paren
l_int|20
op_minus
id|PAGE_SHIFT
)paren
comma
id|size
comma
id|factor
comma
id|attrib_to_str
(paren
id|type
)paren
comma
id|usage_table
(braket
id|i
)braket
)paren
suffix:semicolon
id|ascii_buf_bytes
op_add_assign
id|strlen
(paren
id|ascii_buffer
op_plus
id|ascii_buf_bytes
)paren
suffix:semicolon
)brace
)brace
id|devfs_set_file_size
(paren
id|devfs_handle
comma
id|ascii_buf_bytes
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
r_if
c_cond
(paren
id|proc_root_mtrr
)paren
id|proc_root_mtrr-&gt;size
op_assign
id|ascii_buf_bytes
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif&t;/*  USERSPACE_INTERFACE  */
DECL|variable|mtrr_add
id|EXPORT_SYMBOL
(paren
id|mtrr_add
)paren
suffix:semicolon
DECL|variable|mtrr_del
id|EXPORT_SYMBOL
(paren
id|mtrr_del
)paren
suffix:semicolon
DECL|function|mtrr_setup
r_static
r_void
id|__init
id|mtrr_setup
(paren
r_void
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: v%s)&bslash;n&quot;
comma
id|MTRR_VERSION
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
(paren
id|X86_FEATURE_MTRR
comma
op_amp
id|boot_cpu_data.x86_capability
)paren
)paren
(brace
multiline_comment|/* Query the width (in bits) of the physical&n;&t;&t;   addressable memory on the Hammer family. */
r_if
c_cond
(paren
(paren
id|cpuid_eax
(paren
l_int|0x80000000
)paren
op_ge
l_int|0x80000008
)paren
)paren
(brace
id|u32
id|phys_addr
suffix:semicolon
id|phys_addr
op_assign
id|cpuid_eax
(paren
l_int|0x80000008
)paren
op_amp
l_int|0xff
suffix:semicolon
id|size_or_mask
op_assign
op_complement
(paren
(paren
l_int|1
op_lshift
(paren
id|phys_addr
op_minus
id|PAGE_SHIFT
)paren
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|size_and_mask
op_assign
op_complement
id|size_or_mask
op_amp
l_int|0xfff00000
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* FIXME: This is to make it work on Athlon during debugging. */
id|size_or_mask
op_assign
l_int|0xff000000
suffix:semicolon
multiline_comment|/* 36 bits */
id|size_and_mask
op_assign
l_int|0x00f00000
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;mtrr: detected mtrr type: x86-64&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_SMP
DECL|variable|__initdata
r_static
r_volatile
r_int
r_int
id|smp_changes_mask
id|__initdata
op_assign
l_int|0
suffix:semicolon
DECL|variable|__initdata
r_static
r_struct
id|mtrr_state
id|smp_mtrr_state
id|__initdata
op_assign
(brace
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|function|mtrr_init_boot_cpu
r_void
id|__init
id|mtrr_init_boot_cpu
(paren
r_void
)paren
(brace
id|mtrr_setup
c_func
(paren
)paren
suffix:semicolon
id|get_mtrr_state
(paren
op_amp
id|smp_mtrr_state
)paren
suffix:semicolon
)brace
DECL|function|mtrr_init_secondary_cpu
r_void
id|__init
id|mtrr_init_secondary_cpu
(paren
r_void
)paren
(brace
r_int
r_int
id|mask
comma
id|count
suffix:semicolon
r_struct
id|set_mtrr_context
id|ctxt
suffix:semicolon
multiline_comment|/*  Note that this is not ideal, since the cache is only flushed/disabled&n;&t;for this CPU while the MTRRs are changed, but changing this requires&n;&t;more invasive changes to the way the kernel boots  */
id|set_mtrr_prepare
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
id|mask
op_assign
id|set_mtrr_state
(paren
op_amp
id|smp_mtrr_state
comma
op_amp
id|ctxt
)paren
suffix:semicolon
id|set_mtrr_done
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
multiline_comment|/*  Use the atomic bitops to update the global mask  */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
r_sizeof
id|mask
op_star
l_int|8
suffix:semicolon
op_increment
id|count
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x01
)paren
id|set_bit
(paren
id|count
comma
op_amp
id|smp_changes_mask
)paren
suffix:semicolon
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#endif  /*  CONFIG_SMP  */
DECL|function|mtrr_init
r_int
id|__init
id|mtrr_init
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* mtrr_setup() should already have been called from mtrr_init_boot_cpu() */
id|finalize_mtrr_state
(paren
op_amp
id|smp_mtrr_state
)paren
suffix:semicolon
id|mtrr_state_warn
(paren
id|smp_changes_mask
)paren
suffix:semicolon
macro_line|#else
id|mtrr_setup
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_PROC_FS
id|proc_root_mtrr
op_assign
id|create_proc_entry
(paren
l_string|&quot;mtrr&quot;
comma
id|S_IWUSR
op_or
id|S_IRUGO
comma
op_amp
id|proc_root
)paren
suffix:semicolon
r_if
c_cond
(paren
id|proc_root_mtrr
)paren
(brace
id|proc_root_mtrr-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|proc_root_mtrr-&gt;proc_fops
op_assign
op_amp
id|mtrr_fops
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_DEVFS_FS
id|devfs_handle
op_assign
id|devfs_register
(paren
l_int|NULL
comma
l_string|&quot;cpu/mtrr&quot;
comma
id|DEVFS_FL_DEFAULT
comma
l_int|0
comma
l_int|0
comma
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
comma
op_amp
id|mtrr_fops
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
id|init_table
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
