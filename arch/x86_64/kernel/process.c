multiline_comment|/*&n; *  linux/arch/x86-64/kernel/process.c&n; *&n; *  Copyright (C) 1995  Linus Torvalds&n; *&n; *  Pentium III FXSR, SSE support&n; *&t;Gareth Hughes &lt;gareth@valinux.com&gt;, May 2000&n; * &n; *  X86-64 port&n; *&t;Andi Kleen.&n; * &n; *  $Id: process.c,v 1.38 2002/01/15 10:08:03 ak Exp $&n; */
multiline_comment|/*&n; * This file handles the architecture-dependent parts of process handling..&n; */
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/user.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/a.out.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/ldt.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/i387.h&gt;
macro_line|#include &lt;asm/desc.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/pda.h&gt;
macro_line|#include &lt;asm/prctl.h&gt;
macro_line|#include &lt;asm/kdebug.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
id|asmlinkage
r_extern
r_void
id|ret_from_fork
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|sys_arch_prctl
c_func
(paren
r_int
id|code
comma
r_int
r_int
id|addr
)paren
suffix:semicolon
DECL|variable|kernel_thread_flags
r_int
r_int
id|kernel_thread_flags
op_assign
id|CLONE_VM
op_or
id|CLONE_UNTRACED
suffix:semicolon
DECL|variable|hlt_counter
r_int
id|hlt_counter
suffix:semicolon
multiline_comment|/*&n; * Powermanagement idle function, if any..&n; */
DECL|variable|pm_idle
r_void
(paren
op_star
id|pm_idle
)paren
(paren
r_void
)paren
suffix:semicolon
DECL|function|disable_hlt
r_void
id|disable_hlt
c_func
(paren
r_void
)paren
(brace
id|hlt_counter
op_increment
suffix:semicolon
)brace
DECL|function|enable_hlt
r_void
id|enable_hlt
c_func
(paren
r_void
)paren
(brace
id|hlt_counter
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n; * We use this if we don&squot;t have any better&n; * idle routine..&n; */
DECL|function|default_idle
r_void
id|default_idle
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hlt_counter
)paren
(brace
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|need_resched
c_func
(paren
)paren
)paren
id|safe_halt
c_func
(paren
)paren
suffix:semicolon
r_else
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * On SMP it&squot;s slightly faster (but much more power-consuming!)&n; * to poll the -&gt;need_resched flag instead of waiting for the&n; * cross-CPU IPI to arrive. Use this option with caution.&n; */
DECL|function|poll_idle
r_static
r_void
id|poll_idle
(paren
r_void
)paren
(brace
r_int
id|oldval
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Deal with another CPU just having chosen a thread to&n;&t; * run here:&n;&t; */
id|oldval
op_assign
id|test_and_clear_thread_flag
c_func
(paren
id|TIF_NEED_RESCHED
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|oldval
)paren
(brace
id|set_thread_flag
c_func
(paren
id|TIF_POLLING_NRFLAG
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;2:&quot;
l_string|&quot;testl %0,%1;&quot;
l_string|&quot;rep; nop;&quot;
l_string|&quot;je 2b;&quot;
suffix:colon
suffix:colon
l_string|&quot;i&quot;
(paren
id|_TIF_NEED_RESCHED
)paren
comma
l_string|&quot;m&quot;
(paren
id|current_thread_info
c_func
(paren
)paren
op_member_access_from_pointer
id|flags
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|set_need_resched
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * The idle thread. There&squot;s no useful work to be&n; * done, so just try to conserve power and have a&n; * low exit latency (ie sit in a loop waiting for&n; * somebody to say that they&squot;d like to reschedule)&n; */
DECL|function|cpu_idle
r_void
id|cpu_idle
(paren
r_void
)paren
(brace
multiline_comment|/* endless idle loop with no priority at all */
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_void
(paren
op_star
id|idle
)paren
(paren
r_void
)paren
op_assign
id|pm_idle
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|idle
)paren
id|idle
op_assign
id|default_idle
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|need_resched
c_func
(paren
)paren
)paren
id|idle
c_func
(paren
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|idle_setup
r_static
r_int
id|__init
id|idle_setup
(paren
r_char
op_star
id|str
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|str
comma
l_string|&quot;poll&quot;
comma
l_int|4
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;using polling idle threads.&bslash;n&quot;
)paren
suffix:semicolon
id|pm_idle
op_assign
id|poll_idle
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;idle=&quot;
comma
id|idle_setup
)paren
suffix:semicolon
multiline_comment|/* Prints also some state that isn&squot;t saved in the pt_regs */
DECL|function|show_regs
r_void
id|show_regs
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|cr0
op_assign
l_int|0L
comma
id|cr2
op_assign
l_int|0L
comma
id|cr3
op_assign
l_int|0L
comma
id|cr4
op_assign
l_int|0L
comma
id|fs
comma
id|gs
comma
id|shadowgs
suffix:semicolon
r_int
r_int
id|fsindex
comma
id|gsindex
suffix:semicolon
r_int
r_int
id|ds
comma
id|cs
comma
id|es
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|print_modules
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Pid: %d, comm: %.20s %s&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|current-&gt;comm
comma
id|print_tainted
c_func
(paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;RIP: %04lx:[&lt;%016lx&gt;] &quot;
comma
id|regs-&gt;cs
op_amp
l_int|0xffff
comma
id|regs-&gt;rip
)paren
suffix:semicolon
id|printk_address
c_func
(paren
id|regs-&gt;rip
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nRSP: %04lx:%016lx  EFLAGS: %08lx&bslash;n&quot;
comma
id|regs-&gt;ss
comma
id|regs-&gt;rsp
comma
id|regs-&gt;eflags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;RAX: %016lx RBX: %016lx RCX: %016lx&bslash;n&quot;
comma
id|regs-&gt;rax
comma
id|regs-&gt;rbx
comma
id|regs-&gt;rcx
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;RDX: %016lx RSI: %016lx RDI: %016lx&bslash;n&quot;
comma
id|regs-&gt;rdx
comma
id|regs-&gt;rsi
comma
id|regs-&gt;rdi
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;RBP: %016lx R08: %016lx R09: %016lx&bslash;n&quot;
comma
id|regs-&gt;rbp
comma
id|regs-&gt;r8
comma
id|regs-&gt;r9
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R10: %016lx R11: %016lx R12: %016lx&bslash;n&quot;
comma
id|regs-&gt;r10
comma
id|regs-&gt;r11
comma
id|regs-&gt;r12
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R13: %016lx R14: %016lx R15: %016lx&bslash;n&quot;
comma
id|regs-&gt;r13
comma
id|regs-&gt;r14
comma
id|regs-&gt;r15
)paren
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;movl %%ds,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ds
)paren
)paren
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;movl %%cs,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|cs
)paren
)paren
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;movl %%es,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|es
)paren
)paren
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;movl %%fs,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|fsindex
)paren
)paren
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;movl %%gs,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|gsindex
)paren
)paren
suffix:semicolon
id|rdmsrl
c_func
(paren
id|MSR_FS_BASE
comma
id|fs
)paren
suffix:semicolon
id|rdmsrl
c_func
(paren
id|MSR_GS_BASE
comma
id|gs
)paren
suffix:semicolon
id|rdmsrl
c_func
(paren
id|MSR_KERNEL_GS_BASE
comma
id|shadowgs
)paren
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;movq %%cr0, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|cr0
)paren
)paren
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;movq %%cr2, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|cr2
)paren
)paren
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;movq %%cr3, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|cr3
)paren
)paren
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;movq %%cr4, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|cr4
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;FS:  %016lx(%04x) GS:%016lx(%04x) knlGS:%016lx&bslash;n&quot;
comma
id|fs
comma
id|fsindex
comma
id|gs
comma
id|gsindex
comma
id|shadowgs
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CS:  %04x DS: %04x ES: %04x CR0: %016lx&bslash;n&quot;
comma
id|cs
comma
id|ds
comma
id|es
comma
id|cr0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CR2: %016lx CR3: %016lx CR4: %016lx&bslash;n&quot;
comma
id|cr2
comma
id|cr3
comma
id|cr4
)paren
suffix:semicolon
)brace
r_extern
r_void
id|load_gs_index
c_func
(paren
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * Free current thread data structures etc..&n; */
DECL|function|exit_thread
r_void
id|exit_thread
c_func
(paren
r_void
)paren
(brace
r_struct
id|task_struct
op_star
id|me
op_assign
id|current
suffix:semicolon
r_if
c_cond
(paren
id|me-&gt;thread.io_bitmap_ptr
)paren
(brace
id|kfree
c_func
(paren
id|me-&gt;thread.io_bitmap_ptr
)paren
suffix:semicolon
id|me-&gt;thread.io_bitmap_ptr
op_assign
l_int|NULL
suffix:semicolon
(paren
id|init_tss
op_plus
id|smp_processor_id
c_func
(paren
)paren
)paren
op_member_access_from_pointer
id|io_map_base
op_assign
id|INVALID_IO_BITMAP_OFFSET
suffix:semicolon
)brace
)brace
DECL|function|flush_thread
r_void
id|flush_thread
c_func
(paren
r_void
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|memset
c_func
(paren
id|tsk-&gt;thread.debugreg
comma
l_int|0
comma
r_sizeof
(paren
r_int
r_int
)paren
op_star
l_int|8
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Forget coprocessor state..&n;&t; */
id|clear_fpu
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|tsk-&gt;used_math
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|release_thread
r_void
id|release_thread
c_func
(paren
r_struct
id|task_struct
op_star
id|dead_task
)paren
(brace
r_if
c_cond
(paren
id|dead_task-&gt;mm
)paren
(brace
r_if
c_cond
(paren
id|dead_task-&gt;mm-&gt;context.size
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;WARNING: dead process %8s still has LDT? &lt;%p/%d&gt;&bslash;n&quot;
comma
id|dead_task-&gt;comm
comma
id|dead_task-&gt;mm-&gt;context.ldt
comma
id|dead_task-&gt;mm-&gt;context.size
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|copy_thread
r_int
id|copy_thread
c_func
(paren
r_int
id|nr
comma
r_int
r_int
id|clone_flags
comma
r_int
r_int
id|rsp
comma
r_int
r_int
id|unused
comma
r_struct
id|task_struct
op_star
id|p
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|pt_regs
op_star
id|childregs
suffix:semicolon
r_struct
id|task_struct
op_star
id|me
op_assign
id|current
suffix:semicolon
id|childregs
op_assign
(paren
(paren
r_struct
id|pt_regs
op_star
)paren
(paren
id|THREAD_SIZE
op_plus
(paren
r_int
r_int
)paren
id|p-&gt;thread_info
)paren
)paren
op_minus
l_int|1
suffix:semicolon
op_star
id|childregs
op_assign
op_star
id|regs
suffix:semicolon
id|childregs-&gt;rax
op_assign
l_int|0
suffix:semicolon
id|childregs-&gt;rsp
op_assign
id|rsp
suffix:semicolon
r_if
c_cond
(paren
id|rsp
op_eq
op_complement
l_int|0
)paren
(brace
id|childregs-&gt;rsp
op_assign
(paren
r_int
r_int
)paren
id|childregs
suffix:semicolon
)brace
id|p-&gt;user_tid
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;thread.rsp
op_assign
(paren
r_int
r_int
)paren
id|childregs
suffix:semicolon
id|p-&gt;thread.rsp0
op_assign
(paren
r_int
r_int
)paren
(paren
id|childregs
op_plus
l_int|1
)paren
suffix:semicolon
id|p-&gt;thread.userrsp
op_assign
id|current-&gt;thread.userrsp
suffix:semicolon
id|p-&gt;thread.rip
op_assign
(paren
r_int
r_int
)paren
id|ret_from_fork
suffix:semicolon
id|p-&gt;thread.fs
op_assign
id|me-&gt;thread.fs
suffix:semicolon
id|p-&gt;thread.gs
op_assign
id|me-&gt;thread.gs
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;movl %%gs,%0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|p-&gt;thread.gsindex
)paren
)paren
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;movl %%fs,%0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|p-&gt;thread.fsindex
)paren
)paren
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;movl %%es,%0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|p-&gt;thread.es
)paren
)paren
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;movl %%ds,%0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|p-&gt;thread.ds
)paren
)paren
suffix:semicolon
id|unlazy_fpu
c_func
(paren
id|current
)paren
suffix:semicolon
id|p-&gt;thread.i387
op_assign
id|current-&gt;thread.i387
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|me-&gt;thread.io_bitmap_ptr
op_ne
l_int|NULL
)paren
)paren
(brace
id|p-&gt;thread.io_bitmap_ptr
op_assign
id|kmalloc
c_func
(paren
(paren
id|IO_BITMAP_SIZE
op_plus
l_int|1
)paren
op_star
l_int|4
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;thread.io_bitmap_ptr
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memcpy
c_func
(paren
id|p-&gt;thread.io_bitmap_ptr
comma
id|me-&gt;thread.io_bitmap_ptr
comma
(paren
id|IO_BITMAP_SIZE
op_plus
l_int|1
)paren
op_star
l_int|4
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set a new TLS for the child thread?&n;&t; */
r_if
c_cond
(paren
id|clone_flags
op_amp
id|CLONE_SETTLS
)paren
(brace
r_struct
id|n_desc_struct
op_star
id|desc
suffix:semicolon
r_struct
id|user_desc
id|info
suffix:semicolon
r_int
id|idx
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|info
comma
id|test_thread_flag
c_func
(paren
id|TIF_IA32
)paren
ques
c_cond
(paren
r_void
op_star
)paren
id|childregs-&gt;rsi
suffix:colon
(paren
r_void
op_star
)paren
id|childregs-&gt;rdx
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|LDT_empty
c_func
(paren
op_amp
id|info
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|idx
op_assign
id|info.entry_number
suffix:semicolon
r_if
c_cond
(paren
id|idx
template_param
id|GDT_ENTRY_TLS_MAX
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|desc
op_assign
(paren
r_struct
id|n_desc_struct
op_star
)paren
(paren
id|p-&gt;thread.tls_array
)paren
op_plus
id|idx
op_minus
id|GDT_ENTRY_TLS_MIN
suffix:semicolon
id|desc-&gt;a
op_assign
id|LDT_entry_a
c_func
(paren
op_amp
id|info
)paren
suffix:semicolon
id|desc-&gt;b
op_assign
id|LDT_entry_b
c_func
(paren
op_amp
id|info
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This special macro can be used to load a debugging register&n; */
DECL|macro|loaddebug
mdefine_line|#define loaddebug(thread,register) &bslash;&n;&t;&t;set_debug(thread-&gt;debugreg[register], register)
multiline_comment|/*&n; *&t;switch_to(x,y) should switch tasks from x to y.&n; *&n; * We fsave/fwait so that an exception goes off at the right time&n; * (as a call from the fsave or fwait in effect) rather than to&n; * the wrong process. &n; * &n; * This could still be optimized: &n; * - fold all the options into a flag word and test it with a single test.&n; * - could test fs/gs bitsliced&n; */
DECL|function|__switch_to
r_void
id|__switch_to
c_func
(paren
r_struct
id|task_struct
op_star
id|prev_p
comma
r_struct
id|task_struct
op_star
id|next_p
)paren
(brace
r_struct
id|thread_struct
op_star
id|prev
op_assign
op_amp
id|prev_p-&gt;thread
comma
op_star
id|next
op_assign
op_amp
id|next_p-&gt;thread
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_struct
id|tss_struct
op_star
id|tss
op_assign
id|init_tss
op_plus
id|cpu
suffix:semicolon
id|unlazy_fpu
c_func
(paren
id|prev_p
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reload esp0, LDT and the page table pointer:&n;&t; */
id|tss-&gt;rsp0
op_assign
id|next-&gt;rsp0
suffix:semicolon
multiline_comment|/* &n;&t; * Switch DS and ES.&n;&t; * This won&squot;t pick up thread selector changes, but I guess that is ok.&n;&t; */
id|asm
r_volatile
(paren
l_string|&quot;movl %%es,%0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|prev-&gt;es
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|next-&gt;es
op_or
id|prev-&gt;es
)paren
)paren
id|loadsegment
c_func
(paren
id|es
comma
id|next-&gt;es
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movl %%ds,%0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|prev-&gt;ds
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|next-&gt;ds
op_or
id|prev-&gt;ds
)paren
)paren
id|loadsegment
c_func
(paren
id|ds
comma
id|next-&gt;ds
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Switch FS and GS.&n;&t; * XXX Check if this is safe on SMP (!= -&gt; |)&n;&t; * Need to simplify this.&n;&t; */
(brace
r_int
r_int
id|fsindex
suffix:semicolon
r_int
r_int
id|gsindex
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movl %%fs,%0&quot;
suffix:colon
l_string|&quot;=g&quot;
(paren
id|fsindex
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movl %%gs,%0&quot;
suffix:colon
l_string|&quot;=g&quot;
(paren
id|gsindex
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Load the per-thread Thread-Local Storage descriptor.&n;&t;&t; */
r_if
c_cond
(paren
id|load_TLS
c_func
(paren
id|next
comma
id|cpu
)paren
)paren
(brace
id|loadsegment
c_func
(paren
id|fs
comma
id|next-&gt;fsindex
)paren
suffix:semicolon
multiline_comment|/* should find a way to optimize this away - it is&n;&t;&t;&t;   slow */
r_goto
id|loadgs
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|fsindex
op_ne
id|next-&gt;fsindex
)paren
id|loadsegment
c_func
(paren
id|fs
comma
id|next-&gt;fsindex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gsindex
op_ne
id|next-&gt;gsindex
)paren
(brace
id|loadgs
suffix:colon
id|load_gs_index
c_func
(paren
id|next-&gt;gsindex
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|fsindex
op_ne
id|prev-&gt;fsindex
)paren
)paren
id|prev-&gt;fs
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fsindex
op_ne
id|prev-&gt;fsindex
)paren
op_logical_or
(paren
id|prev-&gt;fs
op_ne
id|next-&gt;fs
)paren
)paren
id|wrmsrl
c_func
(paren
id|MSR_FS_BASE
comma
id|next-&gt;fs
)paren
suffix:semicolon
id|prev-&gt;fsindex
op_assign
id|fsindex
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|gsindex
op_ne
id|prev-&gt;gsindex
)paren
)paren
id|prev-&gt;gs
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|gsindex
op_ne
id|prev-&gt;gsindex
op_logical_or
id|prev-&gt;gs
op_ne
id|next-&gt;gs
)paren
id|wrmsrl
c_func
(paren
id|MSR_KERNEL_GS_BASE
comma
id|next-&gt;gs
)paren
suffix:semicolon
id|prev-&gt;gsindex
op_assign
id|gsindex
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * Switch the PDA context.&n;&t; */
id|prev-&gt;userrsp
op_assign
id|read_pda
c_func
(paren
id|oldrsp
)paren
suffix:semicolon
id|write_pda
c_func
(paren
id|oldrsp
comma
id|next-&gt;userrsp
)paren
suffix:semicolon
id|write_pda
c_func
(paren
id|pcurrent
comma
id|next_p
)paren
suffix:semicolon
id|write_pda
c_func
(paren
id|kernelstack
comma
(paren
r_int
r_int
)paren
id|next_p-&gt;thread_info
op_plus
id|THREAD_SIZE
op_minus
id|PDA_STACKOFFSET
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now maybe reload the debug registers&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|next-&gt;debugreg
(braket
l_int|7
)braket
)paren
)paren
(brace
id|loaddebug
c_func
(paren
id|next
comma
l_int|0
)paren
suffix:semicolon
id|loaddebug
c_func
(paren
id|next
comma
l_int|1
)paren
suffix:semicolon
id|loaddebug
c_func
(paren
id|next
comma
l_int|2
)paren
suffix:semicolon
id|loaddebug
c_func
(paren
id|next
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/* no 4 and 5 */
id|loaddebug
c_func
(paren
id|next
comma
l_int|6
)paren
suffix:semicolon
id|loaddebug
c_func
(paren
id|next
comma
l_int|7
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * Handle the IO bitmap &n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|prev-&gt;io_bitmap_ptr
op_logical_or
id|next-&gt;io_bitmap_ptr
)paren
)paren
(brace
r_if
c_cond
(paren
id|next-&gt;io_bitmap_ptr
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * 4 cachelines copy ... not good, but not that&n;&t;&t;&t; * bad either. Anyone got something better?&n;&t;&t;&t; * This only affects processes which use ioperm().&n;&t;&t;&t; */
id|memcpy
c_func
(paren
id|tss-&gt;io_bitmap
comma
id|next-&gt;io_bitmap_ptr
comma
id|IO_BITMAP_SIZE
op_star
r_sizeof
(paren
id|u32
)paren
)paren
suffix:semicolon
id|tss-&gt;io_map_base
op_assign
id|IO_BITMAP_OFFSET
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * a bitmap offset pointing outside of the TSS limit&n;&t;&t;&t; * causes a nicely controllable SIGSEGV if a process&n;&t;&t;&t; * tries to use a port IO instruction. The first&n;&t;&t;&t; * sys_ioperm() call sets up the bitmap properly.&n;&t;&t;&t; */
id|tss-&gt;io_map_base
op_assign
id|INVALID_IO_BITMAP_OFFSET
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * sys_execve() executes a new program.&n; */
id|asmlinkage
DECL|function|sys_execve
r_int
id|sys_execve
c_func
(paren
r_char
op_star
id|name
comma
r_char
op_star
op_star
id|argv
comma
r_char
op_star
op_star
id|envp
comma
r_struct
id|pt_regs
id|regs
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|filename
suffix:semicolon
id|filename
op_assign
id|getname
c_func
(paren
id|name
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|filename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|filename
)paren
)paren
r_return
id|error
suffix:semicolon
id|error
op_assign
id|do_execve
c_func
(paren
id|filename
comma
id|argv
comma
id|envp
comma
op_amp
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
l_int|0
)paren
id|current-&gt;ptrace
op_and_assign
op_complement
id|PT_DTRACE
suffix:semicolon
id|putname
c_func
(paren
id|filename
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|set_personality_64bit
r_void
id|set_personality_64bit
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* inherit personality from parent */
multiline_comment|/* Make sure to be in 64bit mode */
id|clear_thread_flag
c_func
(paren
id|TIF_IA32
)paren
suffix:semicolon
)brace
DECL|function|sys_fork
id|asmlinkage
r_int
id|sys_fork
c_func
(paren
r_struct
id|pt_regs
id|regs
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|p
op_assign
id|do_fork
c_func
(paren
id|SIGCHLD
comma
id|regs.rsp
comma
op_amp
id|regs
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|IS_ERR
c_func
(paren
id|p
)paren
ques
c_cond
id|PTR_ERR
c_func
(paren
id|p
)paren
suffix:colon
id|p-&gt;pid
suffix:semicolon
)brace
DECL|function|sys_clone
id|asmlinkage
r_int
id|sys_clone
c_func
(paren
r_int
r_int
id|clone_flags
comma
r_int
r_int
id|newsp
comma
r_void
op_star
id|user_tid
comma
r_struct
id|pt_regs
id|regs
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newsp
)paren
id|newsp
op_assign
id|regs.rsp
suffix:semicolon
id|p
op_assign
id|do_fork
c_func
(paren
id|clone_flags
op_amp
op_complement
id|CLONE_IDLETASK
comma
id|newsp
comma
op_amp
id|regs
comma
l_int|0
comma
id|user_tid
)paren
suffix:semicolon
r_return
id|IS_ERR
c_func
(paren
id|p
)paren
ques
c_cond
id|PTR_ERR
c_func
(paren
id|p
)paren
suffix:colon
id|p-&gt;pid
suffix:semicolon
)brace
multiline_comment|/*&n; * This is trivial, and on the face of it looks like it&n; * could equally well be done in user mode.&n; *&n; * Not so, for quite unobvious reasons - register pressure.&n; * In user mode vfork() cannot have a stack frame, and if&n; * done by calling the &quot;clone()&quot; system call directly, you&n; * do not have enough call-clobbered registers to hold all&n; * the information you need.&n; */
DECL|function|sys_vfork
id|asmlinkage
r_int
id|sys_vfork
c_func
(paren
r_struct
id|pt_regs
id|regs
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|p
op_assign
id|do_fork
c_func
(paren
id|CLONE_VFORK
op_or
id|CLONE_VM
op_or
id|SIGCHLD
comma
id|regs.rsp
comma
op_amp
id|regs
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|IS_ERR
c_func
(paren
id|p
)paren
ques
c_cond
id|PTR_ERR
c_func
(paren
id|p
)paren
suffix:colon
id|p-&gt;pid
suffix:semicolon
)brace
multiline_comment|/*&n; * These bracket the sleeping functions..&n; */
r_extern
r_void
id|scheduling_functions_start_here
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|scheduling_functions_end_here
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|first_sched
mdefine_line|#define first_sched&t;((unsigned long) scheduling_functions_start_here)
DECL|macro|last_sched
mdefine_line|#define last_sched&t;((unsigned long) scheduling_functions_end_here)
DECL|function|get_wchan
r_int
r_int
id|get_wchan
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
id|u64
id|fp
comma
id|rip
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
op_logical_or
id|p
op_eq
id|current
op_logical_or
id|p-&gt;state
op_eq
id|TASK_RUNNING
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;thread.rsp
template_param
(paren
id|u64
)paren
id|p
op_plus
id|THREAD_SIZE
)paren
r_return
l_int|0
suffix:semicolon
id|fp
op_assign
op_star
(paren
id|u64
op_star
)paren
(paren
id|p-&gt;thread.rsp
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|fp
template_param
(paren
r_int
r_int
)paren
id|p
op_plus
id|THREAD_SIZE
)paren
r_return
l_int|0
suffix:semicolon
id|rip
op_assign
op_star
(paren
id|u64
op_star
)paren
(paren
id|fp
op_plus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rip
OL
id|first_sched
op_logical_or
id|rip
op_ge
id|last_sched
)paren
r_return
id|rip
suffix:semicolon
id|fp
op_assign
op_star
(paren
id|u64
op_star
)paren
id|fp
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
op_increment
OL
l_int|16
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|last_sched
macro_line|#undef last_sched
DECL|macro|first_sched
macro_line|#undef first_sched
DECL|function|sys_arch_prctl
r_int
id|sys_arch_prctl
c_func
(paren
r_int
id|code
comma
r_int
r_int
id|addr
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
r_switch
c_cond
(paren
id|code
)paren
(brace
r_case
id|ARCH_SET_GS
suffix:colon
r_if
c_cond
(paren
id|addr
op_ge
id|TASK_SIZE
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movw %%gs,%0&quot;
suffix:colon
l_string|&quot;=g&quot;
(paren
id|current-&gt;thread.gsindex
)paren
)paren
suffix:semicolon
id|current-&gt;thread.gs
op_assign
id|addr
suffix:semicolon
id|ret
op_assign
id|checking_wrmsrl
c_func
(paren
id|MSR_KERNEL_GS_BASE
comma
id|addr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ARCH_SET_FS
suffix:colon
multiline_comment|/* Not strictly needed for fs, but do it for symmetry&n;&t;&t;   with gs */
r_if
c_cond
(paren
id|addr
op_ge
id|TASK_SIZE
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movw %%fs,%0&quot;
suffix:colon
l_string|&quot;=g&quot;
(paren
id|current-&gt;thread.fsindex
)paren
)paren
suffix:semicolon
id|current-&gt;thread.fs
op_assign
id|addr
suffix:semicolon
id|ret
op_assign
id|checking_wrmsrl
c_func
(paren
id|MSR_FS_BASE
comma
id|addr
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Returned value may not be correct when the user changed fs/gs */
r_case
id|ARCH_GET_FS
suffix:colon
id|rdmsrl
c_func
(paren
id|MSR_FS_BASE
comma
id|tmp
)paren
suffix:semicolon
id|ret
op_assign
id|put_user
c_func
(paren
id|tmp
comma
(paren
r_int
r_int
op_star
)paren
id|addr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ARCH_GET_GS
suffix:colon
id|rdmsrl
c_func
(paren
id|MSR_KERNEL_GS_BASE
comma
id|tmp
)paren
suffix:semicolon
id|ret
op_assign
id|put_user
c_func
(paren
id|tmp
comma
(paren
r_int
r_int
op_star
)paren
id|addr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * sys_alloc_thread_area: get a yet unused TLS descriptor index.&n; */
DECL|function|get_free_idx
r_static
r_int
id|get_free_idx
c_func
(paren
r_void
)paren
(brace
r_struct
id|thread_struct
op_star
id|t
op_assign
op_amp
id|current-&gt;thread
suffix:semicolon
r_int
id|idx
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|GDT_ENTRY_TLS_ENTRIES
suffix:semicolon
id|idx
op_increment
)paren
r_if
c_cond
(paren
id|desc_empty
c_func
(paren
(paren
r_struct
id|n_desc_struct
op_star
)paren
(paren
id|t-&gt;tls_array
)paren
op_plus
id|idx
)paren
)paren
r_return
id|idx
op_plus
id|GDT_ENTRY_TLS_MIN
suffix:semicolon
r_return
op_minus
id|ESRCH
suffix:semicolon
)brace
multiline_comment|/*&n; * Set a given TLS descriptor:&n; * When you want addresses &gt; 32bit use arch_prctl() &n; */
DECL|function|sys_set_thread_area
id|asmlinkage
r_int
id|sys_set_thread_area
c_func
(paren
r_struct
id|user_desc
op_star
id|u_info
)paren
(brace
r_struct
id|thread_struct
op_star
id|t
op_assign
op_amp
id|current-&gt;thread
suffix:semicolon
r_struct
id|user_desc
id|info
suffix:semicolon
r_struct
id|n_desc_struct
op_star
id|desc
suffix:semicolon
r_int
id|cpu
comma
id|idx
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|info
comma
id|u_info
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|idx
op_assign
id|info.entry_number
suffix:semicolon
multiline_comment|/*&n;&t; * index -1 means the kernel should try to find and&n;&t; * allocate an empty descriptor:&n;&t; */
r_if
c_cond
(paren
id|idx
op_eq
op_minus
l_int|1
)paren
(brace
id|idx
op_assign
id|get_free_idx
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idx
OL
l_int|0
)paren
r_return
id|idx
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|idx
comma
op_amp
id|u_info-&gt;entry_number
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|idx
template_param
id|GDT_ENTRY_TLS_MAX
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|desc
op_assign
(paren
(paren
r_struct
id|n_desc_struct
op_star
)paren
id|t-&gt;tls_array
)paren
op_plus
id|idx
op_minus
id|GDT_ENTRY_TLS_MIN
suffix:semicolon
multiline_comment|/*&n;&t; * We must not get preempted while modifying the TLS.&n;&t; */
id|cpu
op_assign
id|get_cpu
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|LDT_empty
c_func
(paren
op_amp
id|info
)paren
)paren
(brace
id|desc-&gt;a
op_assign
l_int|0
suffix:semicolon
id|desc-&gt;b
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|desc-&gt;a
op_assign
id|LDT_entry_a
c_func
(paren
op_amp
id|info
)paren
suffix:semicolon
id|desc-&gt;b
op_assign
id|LDT_entry_b
c_func
(paren
op_amp
id|info
)paren
suffix:semicolon
)brace
id|load_TLS
c_func
(paren
id|t
comma
id|cpu
)paren
suffix:semicolon
id|put_cpu
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the current Thread-Local Storage area:&n; */
DECL|macro|GET_BASE
mdefine_line|#define GET_BASE(desc) ( &bslash;&n;&t;(((desc)-&gt;a &gt;&gt; 16) &amp; 0x0000ffff) | &bslash;&n;&t;(((desc)-&gt;b &lt;&lt; 16) &amp; 0x00ff0000) | &bslash;&n;&t;( (desc)-&gt;b        &amp; 0xff000000)   )
DECL|macro|GET_LIMIT
mdefine_line|#define GET_LIMIT(desc) ( &bslash;&n;&t;((desc)-&gt;a &amp; 0x0ffff) | &bslash;&n;&t; ((desc)-&gt;b &amp; 0xf0000) )
DECL|macro|GET_32BIT
mdefine_line|#define GET_32BIT(desc)&t;&t;(((desc)-&gt;b &gt;&gt; 23) &amp; 1)
DECL|macro|GET_CONTENTS
mdefine_line|#define GET_CONTENTS(desc)&t;(((desc)-&gt;b &gt;&gt; 10) &amp; 3)
DECL|macro|GET_WRITABLE
mdefine_line|#define GET_WRITABLE(desc)&t;(((desc)-&gt;b &gt;&gt;  9) &amp; 1)
DECL|macro|GET_LIMIT_PAGES
mdefine_line|#define GET_LIMIT_PAGES(desc)&t;(((desc)-&gt;b &gt;&gt; 23) &amp; 1)
DECL|macro|GET_PRESENT
mdefine_line|#define GET_PRESENT(desc)&t;(((desc)-&gt;b &gt;&gt; 15) &amp; 1)
DECL|macro|GET_USEABLE
mdefine_line|#define GET_USEABLE(desc)&t;(((desc)-&gt;b &gt;&gt; 20) &amp; 1)
DECL|function|sys_get_thread_area
id|asmlinkage
r_int
id|sys_get_thread_area
c_func
(paren
r_struct
id|user_desc
op_star
id|u_info
)paren
(brace
r_struct
id|user_desc
id|info
suffix:semicolon
r_struct
id|n_desc_struct
op_star
id|desc
suffix:semicolon
r_int
id|idx
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|idx
comma
op_amp
id|u_info-&gt;entry_number
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|idx
template_param
id|GDT_ENTRY_TLS_MAX
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|desc
op_assign
(paren
(paren
r_struct
id|n_desc_struct
op_star
)paren
id|current-&gt;thread.tls_array
)paren
op_plus
id|idx
op_minus
id|GDT_ENTRY_TLS_MIN
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|info
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|user_desc
)paren
)paren
suffix:semicolon
id|info.entry_number
op_assign
id|idx
suffix:semicolon
id|info.base_addr
op_assign
id|GET_BASE
c_func
(paren
id|desc
)paren
suffix:semicolon
id|info.limit
op_assign
id|GET_LIMIT
c_func
(paren
id|desc
)paren
suffix:semicolon
id|info.seg_32bit
op_assign
id|GET_32BIT
c_func
(paren
id|desc
)paren
suffix:semicolon
id|info.contents
op_assign
id|GET_CONTENTS
c_func
(paren
id|desc
)paren
suffix:semicolon
id|info.read_exec_only
op_assign
op_logical_neg
id|GET_WRITABLE
c_func
(paren
id|desc
)paren
suffix:semicolon
id|info.limit_in_pages
op_assign
id|GET_LIMIT_PAGES
c_func
(paren
id|desc
)paren
suffix:semicolon
id|info.seg_not_present
op_assign
op_logical_neg
id|GET_PRESENT
c_func
(paren
id|desc
)paren
suffix:semicolon
id|info.useable
op_assign
id|GET_USEABLE
c_func
(paren
id|desc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|u_info
comma
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
