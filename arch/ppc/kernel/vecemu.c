multiline_comment|/*&n; * Routines to emulate some Altivec/VMX instructions, specifically&n; * those that can trap when given denormalized operands in Java mode.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/* Functions in vector.S */
r_extern
r_void
id|vaddfp
c_func
(paren
id|vector128
op_star
id|dst
comma
id|vector128
op_star
id|a
comma
id|vector128
op_star
id|b
)paren
suffix:semicolon
r_extern
r_void
id|vsubfp
c_func
(paren
id|vector128
op_star
id|dst
comma
id|vector128
op_star
id|a
comma
id|vector128
op_star
id|b
)paren
suffix:semicolon
r_extern
r_void
id|vmaddfp
c_func
(paren
id|vector128
op_star
id|dst
comma
id|vector128
op_star
id|a
comma
id|vector128
op_star
id|b
comma
id|vector128
op_star
id|c
)paren
suffix:semicolon
r_extern
r_void
id|vnmsubfp
c_func
(paren
id|vector128
op_star
id|dst
comma
id|vector128
op_star
id|a
comma
id|vector128
op_star
id|b
comma
id|vector128
op_star
id|c
)paren
suffix:semicolon
r_extern
r_void
id|vrefp
c_func
(paren
id|vector128
op_star
id|dst
comma
id|vector128
op_star
id|src
)paren
suffix:semicolon
r_extern
r_void
id|vrsqrtefp
c_func
(paren
id|vector128
op_star
id|dst
comma
id|vector128
op_star
id|src
)paren
suffix:semicolon
r_extern
r_void
id|vexptep
c_func
(paren
id|vector128
op_star
id|dst
comma
id|vector128
op_star
id|src
)paren
suffix:semicolon
DECL|variable|exp2s
r_static
r_int
r_int
id|exp2s
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x800000
comma
l_int|0x8b95c2
comma
l_int|0x9837f0
comma
l_int|0xa5fed7
comma
l_int|0xb504f3
comma
l_int|0xc5672a
comma
l_int|0xd744fd
comma
l_int|0xeac0c7
)brace
suffix:semicolon
multiline_comment|/*&n; * Computes an estimate of 2^x.  The `s&squot; argument is the 32-bit&n; * single-precision floating-point representation of x.&n; */
DECL|function|eexp2
r_static
r_int
r_int
id|eexp2
c_func
(paren
r_int
r_int
id|s
)paren
(brace
r_int
id|exp
comma
id|pwr
suffix:semicolon
r_int
r_int
id|mant
comma
id|frac
suffix:semicolon
multiline_comment|/* extract exponent field from input */
id|exp
op_assign
(paren
(paren
id|s
op_rshift
l_int|23
)paren
op_amp
l_int|0xff
)paren
op_minus
l_int|127
suffix:semicolon
r_if
c_cond
(paren
id|exp
OG
l_int|7
)paren
(brace
multiline_comment|/* check for NaN input */
r_if
c_cond
(paren
id|exp
op_eq
l_int|128
op_logical_and
(paren
id|s
op_amp
l_int|0x7fffff
)paren
op_ne
l_int|0
)paren
r_return
id|s
op_or
l_int|0x400000
suffix:semicolon
multiline_comment|/* return QNaN */
multiline_comment|/* 2^-big = 0, 2^+big = +Inf */
r_return
(paren
id|s
op_amp
l_int|0x80000000
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|0x7f800000
suffix:semicolon
multiline_comment|/* 0 or +Inf */
)brace
r_if
c_cond
(paren
id|exp
OL
op_minus
l_int|23
)paren
r_return
l_int|0x3f800000
suffix:semicolon
multiline_comment|/* 1.0 */
multiline_comment|/* convert to fixed point integer in 9.23 representation */
id|pwr
op_assign
(paren
id|s
op_amp
l_int|0x7fffff
)paren
op_or
l_int|0x800000
suffix:semicolon
r_if
c_cond
(paren
id|exp
OG
l_int|0
)paren
id|pwr
op_lshift_assign
id|exp
suffix:semicolon
r_else
id|pwr
op_rshift_assign
op_minus
id|exp
suffix:semicolon
r_if
c_cond
(paren
id|s
op_amp
l_int|0x80000000
)paren
id|pwr
op_assign
op_minus
id|pwr
suffix:semicolon
multiline_comment|/* extract integer part, which becomes exponent part of result */
id|exp
op_assign
(paren
id|pwr
op_rshift
l_int|23
)paren
op_plus
l_int|126
suffix:semicolon
r_if
c_cond
(paren
id|exp
op_ge
l_int|254
)paren
r_return
l_int|0x7f800000
suffix:semicolon
r_if
c_cond
(paren
id|exp
OL
op_minus
l_int|23
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* table lookup on top 3 bits of fraction to get mantissa */
id|mant
op_assign
id|exp2s
(braket
(paren
id|pwr
op_rshift
l_int|20
)paren
op_amp
l_int|7
)braket
suffix:semicolon
multiline_comment|/* linear interpolation using remaining 20 bits of fraction */
id|asm
c_func
(paren
l_string|&quot;mulhwu %0,%1,%2&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|frac
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|pwr
op_lshift
l_int|12
)paren
comma
l_string|&quot;r&quot;
(paren
l_int|0x172b83ff
)paren
)paren
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;mulhwu %0,%1,%2&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|frac
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|frac
)paren
comma
l_string|&quot;r&quot;
(paren
id|mant
)paren
)paren
suffix:semicolon
id|mant
op_add_assign
id|frac
suffix:semicolon
r_if
c_cond
(paren
id|exp
op_ge
l_int|0
)paren
r_return
id|mant
op_plus
(paren
id|exp
op_lshift
l_int|23
)paren
suffix:semicolon
multiline_comment|/* denormalized result */
id|exp
op_assign
op_minus
id|exp
suffix:semicolon
id|mant
op_add_assign
l_int|1
op_lshift
(paren
id|exp
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|mant
op_rshift
id|exp
suffix:semicolon
)brace
multiline_comment|/*&n; * Computes an estimate of log_2(x).  The `s&squot; argument is the 32-bit&n; * single-precision floating-point representation of x.&n; */
DECL|function|elog2
r_static
r_int
r_int
id|elog2
c_func
(paren
r_int
r_int
id|s
)paren
(brace
r_int
id|exp
comma
id|mant
comma
id|lz
comma
id|frac
suffix:semicolon
id|exp
op_assign
id|s
op_amp
l_int|0x7f800000
suffix:semicolon
id|mant
op_assign
id|s
op_amp
l_int|0x7fffff
suffix:semicolon
r_if
c_cond
(paren
id|exp
op_eq
l_int|0x7f800000
)paren
(brace
multiline_comment|/* Inf or NaN */
r_if
c_cond
(paren
id|mant
op_ne
l_int|0
)paren
id|s
op_or_assign
l_int|0x400000
suffix:semicolon
multiline_comment|/* turn NaN into QNaN */
r_return
id|s
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|exp
op_or
id|mant
)paren
op_eq
l_int|0
)paren
multiline_comment|/* +0 or -0 */
r_return
l_int|0xff800000
suffix:semicolon
multiline_comment|/* return -Inf */
r_if
c_cond
(paren
id|exp
op_eq
l_int|0
)paren
(brace
multiline_comment|/* denormalized */
id|asm
c_func
(paren
l_string|&quot;cntlzw %0,%1&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|lz
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|mant
)paren
)paren
suffix:semicolon
id|mant
op_lshift_assign
id|lz
op_minus
l_int|8
suffix:semicolon
id|exp
op_assign
(paren
op_minus
l_int|118
op_minus
id|lz
)paren
op_lshift
l_int|23
suffix:semicolon
)brace
r_else
(brace
id|mant
op_or_assign
l_int|0x800000
suffix:semicolon
id|exp
op_sub_assign
l_int|127
op_lshift
l_int|23
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mant
op_ge
l_int|0xb504f3
)paren
(brace
multiline_comment|/* 2^0.5 * 2^23 */
id|exp
op_or_assign
l_int|0x400000
suffix:semicolon
multiline_comment|/* 0.5 * 2^23 */
id|asm
c_func
(paren
l_string|&quot;mulhwu %0,%1,%2&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|mant
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|mant
)paren
comma
l_string|&quot;r&quot;
(paren
l_int|0xb504f334
)paren
)paren
suffix:semicolon
multiline_comment|/* 2^-0.5 * 2^32 */
)brace
r_if
c_cond
(paren
id|mant
op_ge
l_int|0x9837f0
)paren
(brace
multiline_comment|/* 2^0.25 * 2^23 */
id|exp
op_or_assign
l_int|0x200000
suffix:semicolon
multiline_comment|/* 0.25 * 2^23 */
id|asm
c_func
(paren
l_string|&quot;mulhwu %0,%1,%2&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|mant
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|mant
)paren
comma
l_string|&quot;r&quot;
(paren
l_int|0xd744fccb
)paren
)paren
suffix:semicolon
multiline_comment|/* 2^-0.25 * 2^32 */
)brace
r_if
c_cond
(paren
id|mant
op_ge
l_int|0x8b95c2
)paren
(brace
multiline_comment|/* 2^0.125 * 2^23 */
id|exp
op_or_assign
l_int|0x100000
suffix:semicolon
multiline_comment|/* 0.125 * 2^23 */
id|asm
c_func
(paren
l_string|&quot;mulhwu %0,%1,%2&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|mant
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|mant
)paren
comma
l_string|&quot;r&quot;
(paren
l_int|0xeac0c6e8
)paren
)paren
suffix:semicolon
multiline_comment|/* 2^-0.125 * 2^32 */
)brace
r_if
c_cond
(paren
id|mant
OG
l_int|0x800000
)paren
(brace
multiline_comment|/* 1.0 * 2^23 */
multiline_comment|/* calculate (mant - 1) * 1.381097463 */
multiline_comment|/* 1.381097463 == 0.125 / (2^0.125 - 1) */
id|asm
c_func
(paren
l_string|&quot;mulhwu %0,%1,%2&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|frac
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
(paren
id|mant
op_minus
l_int|0x800000
)paren
op_lshift
l_int|1
)paren
comma
l_string|&quot;r&quot;
(paren
l_int|0xb0c7cd3a
)paren
)paren
suffix:semicolon
id|exp
op_add_assign
id|frac
suffix:semicolon
)brace
id|s
op_assign
id|exp
op_amp
l_int|0x80000000
suffix:semicolon
r_if
c_cond
(paren
id|exp
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|s
)paren
id|exp
op_assign
op_minus
id|exp
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;cntlzw %0,%1&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|lz
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|exp
)paren
)paren
suffix:semicolon
id|lz
op_assign
l_int|8
op_minus
id|lz
suffix:semicolon
r_if
c_cond
(paren
id|lz
OG
l_int|0
)paren
id|exp
op_rshift_assign
id|lz
suffix:semicolon
r_else
r_if
c_cond
(paren
id|lz
OL
l_int|0
)paren
id|exp
op_lshift_assign
op_minus
id|lz
suffix:semicolon
id|s
op_add_assign
(paren
(paren
id|lz
op_plus
l_int|126
)paren
op_lshift
l_int|23
)paren
op_plus
id|exp
suffix:semicolon
)brace
r_return
id|s
suffix:semicolon
)brace
DECL|macro|VSCR_SAT
mdefine_line|#define VSCR_SAT&t;1
DECL|function|ctsxs
r_static
r_int
id|ctsxs
c_func
(paren
r_int
r_int
id|x
comma
r_int
id|scale
comma
r_int
r_int
op_star
id|vscrp
)paren
(brace
r_int
id|exp
comma
id|mant
suffix:semicolon
id|exp
op_assign
(paren
id|x
op_rshift
l_int|23
)paren
op_amp
l_int|0xff
suffix:semicolon
id|mant
op_assign
id|x
op_amp
l_int|0x7fffff
suffix:semicolon
r_if
c_cond
(paren
id|exp
op_eq
l_int|255
op_logical_and
id|mant
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* NaN -&gt; 0 */
id|exp
op_assign
id|exp
op_minus
l_int|127
op_plus
id|scale
suffix:semicolon
r_if
c_cond
(paren
id|exp
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* round towards zero */
r_if
c_cond
(paren
id|exp
op_ge
l_int|31
)paren
(brace
multiline_comment|/* saturate, unless the result would be -2^31 */
r_if
c_cond
(paren
id|x
op_plus
(paren
id|scale
op_lshift
l_int|23
)paren
op_ne
l_int|0xcf000000
)paren
op_star
id|vscrp
op_or_assign
id|VSCR_SAT
suffix:semicolon
r_return
(paren
id|x
op_amp
l_int|0x80000000
)paren
ques
c_cond
l_int|0x80000000
suffix:colon
l_int|0x7fffffff
suffix:semicolon
)brace
id|mant
op_or_assign
l_int|0x800000
suffix:semicolon
id|mant
op_assign
(paren
id|mant
op_lshift
l_int|7
)paren
op_rshift
(paren
l_int|30
op_minus
id|exp
)paren
suffix:semicolon
r_return
(paren
id|x
op_amp
l_int|0x80000000
)paren
ques
c_cond
op_minus
id|mant
suffix:colon
id|mant
suffix:semicolon
)brace
DECL|function|ctuxs
r_static
r_int
r_int
id|ctuxs
c_func
(paren
r_int
r_int
id|x
comma
r_int
id|scale
comma
r_int
r_int
op_star
id|vscrp
)paren
(brace
r_int
id|exp
suffix:semicolon
r_int
r_int
id|mant
suffix:semicolon
id|exp
op_assign
(paren
id|x
op_rshift
l_int|23
)paren
op_amp
l_int|0xff
suffix:semicolon
id|mant
op_assign
id|x
op_amp
l_int|0x7fffff
suffix:semicolon
r_if
c_cond
(paren
id|exp
op_eq
l_int|255
op_logical_and
id|mant
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* NaN -&gt; 0 */
id|exp
op_assign
id|exp
op_minus
l_int|127
op_plus
id|scale
suffix:semicolon
r_if
c_cond
(paren
id|exp
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* round towards zero */
r_if
c_cond
(paren
id|x
op_amp
l_int|0x80000000
)paren
(brace
multiline_comment|/* negative =&gt; saturate to 0 */
op_star
id|vscrp
op_or_assign
id|VSCR_SAT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|exp
op_ge
l_int|32
)paren
(brace
multiline_comment|/* saturate */
op_star
id|vscrp
op_or_assign
id|VSCR_SAT
suffix:semicolon
r_return
l_int|0xffffffff
suffix:semicolon
)brace
id|mant
op_or_assign
l_int|0x800000
suffix:semicolon
id|mant
op_assign
(paren
id|mant
op_lshift
l_int|8
)paren
op_rshift
(paren
l_int|31
op_minus
id|exp
)paren
suffix:semicolon
r_return
id|mant
suffix:semicolon
)brace
multiline_comment|/* Round to floating integer, towards 0 */
DECL|function|rfiz
r_static
r_int
r_int
id|rfiz
c_func
(paren
r_int
r_int
id|x
)paren
(brace
r_int
id|exp
suffix:semicolon
id|exp
op_assign
(paren
(paren
id|x
op_rshift
l_int|23
)paren
op_amp
l_int|0xff
)paren
op_minus
l_int|127
suffix:semicolon
r_if
c_cond
(paren
id|exp
op_eq
l_int|128
op_logical_and
(paren
id|x
op_amp
l_int|0x7fffff
)paren
op_ne
l_int|0
)paren
r_return
id|x
op_or
l_int|0x400000
suffix:semicolon
multiline_comment|/* NaN -&gt; make it a QNaN */
r_if
c_cond
(paren
id|exp
op_ge
l_int|23
)paren
r_return
id|x
suffix:semicolon
multiline_comment|/* it&squot;s an integer already (or Inf) */
r_if
c_cond
(paren
id|exp
OL
l_int|0
)paren
r_return
id|x
op_amp
l_int|0x80000000
suffix:semicolon
multiline_comment|/* |x| &lt; 1.0 rounds to 0 */
r_return
id|x
op_amp
op_complement
(paren
l_int|0x7fffff
op_rshift
id|exp
)paren
suffix:semicolon
)brace
multiline_comment|/* Round to floating integer, towards +/- Inf */
DECL|function|rfii
r_static
r_int
r_int
id|rfii
c_func
(paren
r_int
r_int
id|x
)paren
(brace
r_int
id|exp
comma
id|mask
suffix:semicolon
id|exp
op_assign
(paren
(paren
id|x
op_rshift
l_int|23
)paren
op_amp
l_int|0xff
)paren
op_minus
l_int|127
suffix:semicolon
r_if
c_cond
(paren
id|exp
op_eq
l_int|128
op_logical_and
(paren
id|x
op_amp
l_int|0x7fffff
)paren
op_ne
l_int|0
)paren
r_return
id|x
op_or
l_int|0x400000
suffix:semicolon
multiline_comment|/* NaN -&gt; make it a QNaN */
r_if
c_cond
(paren
id|exp
op_ge
l_int|23
)paren
r_return
id|x
suffix:semicolon
multiline_comment|/* it&squot;s an integer already (or Inf) */
r_if
c_cond
(paren
(paren
id|x
op_amp
l_int|0x7fffffff
)paren
op_eq
l_int|0
)paren
r_return
id|x
suffix:semicolon
multiline_comment|/* +/-0 -&gt; +/-0 */
r_if
c_cond
(paren
id|exp
OL
l_int|0
)paren
multiline_comment|/* 0 &lt; |x| &lt; 1.0 rounds to +/- 1.0 */
r_return
(paren
id|x
op_amp
l_int|0x80000000
)paren
op_or
l_int|0x3f800000
suffix:semicolon
id|mask
op_assign
l_int|0x7fffff
op_rshift
id|exp
suffix:semicolon
multiline_comment|/* mantissa overflows into exponent - that&squot;s OK,&n;&t;   it can&squot;t overflow into the sign bit */
r_return
(paren
id|x
op_plus
id|mask
)paren
op_amp
op_complement
id|mask
suffix:semicolon
)brace
multiline_comment|/* Round to floating integer, to nearest */
DECL|function|rfin
r_static
r_int
r_int
id|rfin
c_func
(paren
r_int
r_int
id|x
)paren
(brace
r_int
id|exp
comma
id|half
suffix:semicolon
id|exp
op_assign
(paren
(paren
id|x
op_rshift
l_int|23
)paren
op_amp
l_int|0xff
)paren
op_minus
l_int|127
suffix:semicolon
r_if
c_cond
(paren
id|exp
op_eq
l_int|128
op_logical_and
(paren
id|x
op_amp
l_int|0x7fffff
)paren
op_ne
l_int|0
)paren
r_return
id|x
op_or
l_int|0x400000
suffix:semicolon
multiline_comment|/* NaN -&gt; make it a QNaN */
r_if
c_cond
(paren
id|exp
op_ge
l_int|23
)paren
r_return
id|x
suffix:semicolon
multiline_comment|/* it&squot;s an integer already (or Inf) */
r_if
c_cond
(paren
id|exp
OL
op_minus
l_int|1
)paren
r_return
id|x
op_amp
l_int|0x80000000
suffix:semicolon
multiline_comment|/* |x| &lt; 0.5 -&gt; +/-0 */
r_if
c_cond
(paren
id|exp
op_eq
op_minus
l_int|1
)paren
multiline_comment|/* 0.5 &lt;= |x| &lt; 1.0 rounds to +/- 1.0 */
r_return
(paren
id|x
op_amp
l_int|0x80000000
)paren
op_or
l_int|0x3f800000
suffix:semicolon
id|half
op_assign
l_int|0x400000
op_rshift
id|exp
suffix:semicolon
multiline_comment|/* add 0.5 to the magnitude and chop off the fraction bits */
r_return
(paren
id|x
op_plus
id|half
)paren
op_amp
op_complement
(paren
l_int|0x7fffff
op_rshift
id|exp
)paren
suffix:semicolon
)brace
DECL|function|emulate_altivec
r_int
id|emulate_altivec
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|instr
comma
id|i
suffix:semicolon
r_int
r_int
id|va
comma
id|vb
comma
id|vc
comma
id|vd
suffix:semicolon
id|vector128
op_star
id|vrs
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|instr
comma
(paren
r_int
r_int
id|__user
op_star
)paren
id|regs-&gt;nip
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|instr
op_rshift
l_int|26
)paren
op_ne
l_int|4
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* not an altivec instruction */
id|vd
op_assign
(paren
id|instr
op_rshift
l_int|21
)paren
op_amp
l_int|0x1f
suffix:semicolon
id|va
op_assign
(paren
id|instr
op_rshift
l_int|16
)paren
op_amp
l_int|0x1f
suffix:semicolon
id|vb
op_assign
(paren
id|instr
op_rshift
l_int|11
)paren
op_amp
l_int|0x1f
suffix:semicolon
id|vc
op_assign
(paren
id|instr
op_rshift
l_int|6
)paren
op_amp
l_int|0x1f
suffix:semicolon
id|vrs
op_assign
id|current-&gt;thread.vr
suffix:semicolon
r_switch
c_cond
(paren
id|instr
op_amp
l_int|0x3f
)paren
(brace
r_case
l_int|10
suffix:colon
r_switch
c_cond
(paren
id|vc
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* vaddfp */
id|vaddfp
c_func
(paren
op_amp
id|vrs
(braket
id|vd
)braket
comma
op_amp
id|vrs
(braket
id|va
)braket
comma
op_amp
id|vrs
(braket
id|vb
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* vsubfp */
id|vsubfp
c_func
(paren
op_amp
id|vrs
(braket
id|vd
)braket
comma
op_amp
id|vrs
(braket
id|va
)braket
comma
op_amp
id|vrs
(braket
id|vb
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
multiline_comment|/* vrefp */
id|vrefp
c_func
(paren
op_amp
id|vrs
(braket
id|vd
)braket
comma
op_amp
id|vrs
(braket
id|vb
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
multiline_comment|/* vrsqrtefp */
id|vrsqrtefp
c_func
(paren
op_amp
id|vrs
(braket
id|vd
)braket
comma
op_amp
id|vrs
(braket
id|vb
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
multiline_comment|/* vexptefp */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
id|vrs
(braket
id|vd
)braket
dot
id|u
(braket
id|i
)braket
op_assign
id|eexp2
c_func
(paren
id|vrs
(braket
id|vb
)braket
dot
id|u
(braket
id|i
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
multiline_comment|/* vlogefp */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
id|vrs
(braket
id|vd
)braket
dot
id|u
(braket
id|i
)braket
op_assign
id|elog2
c_func
(paren
id|vrs
(braket
id|vb
)braket
dot
id|u
(braket
id|i
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
multiline_comment|/* vrfin */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
id|vrs
(braket
id|vd
)braket
dot
id|u
(braket
id|i
)braket
op_assign
id|rfin
c_func
(paren
id|vrs
(braket
id|vb
)braket
dot
id|u
(braket
id|i
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
suffix:colon
multiline_comment|/* vrfiz */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
id|vrs
(braket
id|vd
)braket
dot
id|u
(braket
id|i
)braket
op_assign
id|rfiz
c_func
(paren
id|vrs
(braket
id|vb
)braket
dot
id|u
(braket
id|i
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|10
suffix:colon
multiline_comment|/* vrfip */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
(brace
id|u32
id|x
op_assign
id|vrs
(braket
id|vb
)braket
dot
id|u
(braket
id|i
)braket
suffix:semicolon
id|x
op_assign
(paren
id|x
op_amp
l_int|0x80000000
)paren
ques
c_cond
id|rfiz
c_func
(paren
id|x
)paren
suffix:colon
id|rfii
c_func
(paren
id|x
)paren
suffix:semicolon
id|vrs
(braket
id|vd
)braket
dot
id|u
(braket
id|i
)braket
op_assign
id|x
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|11
suffix:colon
multiline_comment|/* vrfim */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
(brace
id|u32
id|x
op_assign
id|vrs
(braket
id|vb
)braket
dot
id|u
(braket
id|i
)braket
suffix:semicolon
id|x
op_assign
(paren
id|x
op_amp
l_int|0x80000000
)paren
ques
c_cond
id|rfii
c_func
(paren
id|x
)paren
suffix:colon
id|rfiz
c_func
(paren
id|x
)paren
suffix:semicolon
id|vrs
(braket
id|vd
)braket
dot
id|u
(braket
id|i
)braket
op_assign
id|x
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|14
suffix:colon
multiline_comment|/* vctuxs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
id|vrs
(braket
id|vd
)braket
dot
id|u
(braket
id|i
)braket
op_assign
id|ctuxs
c_func
(paren
id|vrs
(braket
id|vb
)braket
dot
id|u
(braket
id|i
)braket
comma
id|va
comma
op_amp
id|current-&gt;thread.vscr.u
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|15
suffix:colon
multiline_comment|/* vctsxs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
id|vrs
(braket
id|vd
)braket
dot
id|u
(braket
id|i
)braket
op_assign
id|ctsxs
c_func
(paren
id|vrs
(braket
id|vb
)braket
dot
id|u
(braket
id|i
)braket
comma
id|va
comma
op_amp
id|current-&gt;thread.vscr.u
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|46
suffix:colon
multiline_comment|/* vmaddfp */
id|vmaddfp
c_func
(paren
op_amp
id|vrs
(braket
id|vd
)braket
comma
op_amp
id|vrs
(braket
id|va
)braket
comma
op_amp
id|vrs
(braket
id|vb
)braket
comma
op_amp
id|vrs
(braket
id|vc
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|47
suffix:colon
multiline_comment|/* vnmsubfp */
id|vnmsubfp
c_func
(paren
op_amp
id|vrs
(braket
id|vd
)braket
comma
op_amp
id|vrs
(braket
id|va
)braket
comma
op_amp
id|vrs
(braket
id|vb
)braket
comma
op_amp
id|vrs
(braket
id|vc
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
