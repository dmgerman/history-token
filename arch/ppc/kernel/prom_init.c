multiline_comment|/*&n; * Note that prom_init() and anything called from prom_init()&n; * may be running at an address that is different from the address&n; * that it was linked at.  References to static data items are&n; * handled by compiling this file with -mrelocatable-lib.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/threads.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/sections.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/bootx.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt;
macro_line|#include &lt;asm/btext.h&gt;
macro_line|#include &lt;asm/pci-bridge.h&gt;
macro_line|#include &lt;asm/open_pic.h&gt;
macro_line|#ifdef CONFIG_FB
macro_line|#include &lt;asm/linux_logo.h&gt;
macro_line|#endif
multiline_comment|/*&n; * Properties whose value is longer than this get excluded from our&n; * copy of the device tree.  This way we don&squot;t waste space storing&n; * things like &quot;driver,AAPL,MacOS,PowerPC&quot; properties.  But this value&n; * does need to be big enough to ensure that we don&squot;t lose things&n; * like the interrupt-map property on a PCI-PCI bridge.&n; */
DECL|macro|MAX_PROPERTY_LENGTH
mdefine_line|#define MAX_PROPERTY_LENGTH&t;4096
macro_line|#ifndef FB_MAX&t;&t;&t;/* avoid pulling in all of the fb stuff */
DECL|macro|FB_MAX
mdefine_line|#define FB_MAX&t;8
macro_line|#endif
DECL|macro|ALIGNUL
mdefine_line|#define ALIGNUL(x) (((x) + sizeof(unsigned long)-1) &amp; -sizeof(unsigned long))
DECL|struct|prom_args
r_struct
id|prom_args
(brace
DECL|member|service
r_const
r_char
op_star
id|service
suffix:semicolon
DECL|member|nargs
r_int
id|nargs
suffix:semicolon
DECL|member|nret
r_int
id|nret
suffix:semicolon
DECL|member|args
r_void
op_star
id|args
(braket
l_int|10
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|pci_address
r_struct
id|pci_address
(brace
DECL|member|a_hi
r_int
id|a_hi
suffix:semicolon
DECL|member|a_mid
r_int
id|a_mid
suffix:semicolon
DECL|member|a_lo
r_int
id|a_lo
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|pci_reg_property
r_struct
id|pci_reg_property
(brace
DECL|member|addr
r_struct
id|pci_address
id|addr
suffix:semicolon
DECL|member|size_hi
r_int
id|size_hi
suffix:semicolon
DECL|member|size_lo
r_int
id|size_lo
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|pci_range
r_struct
id|pci_range
(brace
DECL|member|addr
r_struct
id|pci_address
id|addr
suffix:semicolon
DECL|member|phys
r_int
id|phys
suffix:semicolon
DECL|member|size_hi
r_int
id|size_hi
suffix:semicolon
DECL|member|size_lo
r_int
id|size_lo
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|isa_reg_property
r_struct
id|isa_reg_property
(brace
DECL|member|space
r_int
id|space
suffix:semicolon
DECL|member|address
r_int
id|address
suffix:semicolon
DECL|member|size
r_int
id|size
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|pci_intr_map
r_struct
id|pci_intr_map
(brace
DECL|member|addr
r_struct
id|pci_address
id|addr
suffix:semicolon
DECL|member|dunno
r_int
id|dunno
suffix:semicolon
DECL|member|int_ctrler
id|phandle
id|int_ctrler
suffix:semicolon
DECL|member|intr
r_int
id|intr
suffix:semicolon
)brace
suffix:semicolon
r_static
r_void
id|prom_exit
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
op_star
id|call_prom
c_func
(paren
r_const
r_char
op_star
id|service
comma
r_int
id|nargs
comma
r_int
id|nret
comma
dot
dot
dot
)paren
suffix:semicolon
r_static
r_void
op_star
id|call_prom_ret
c_func
(paren
r_const
r_char
op_star
id|service
comma
r_int
id|nargs
comma
r_int
id|nret
comma
r_void
op_star
op_star
id|rets
comma
dot
dot
dot
)paren
suffix:semicolon
r_static
r_void
id|prom_print_hex
c_func
(paren
r_int
r_int
id|v
)paren
suffix:semicolon
r_static
r_int
id|prom_set_color
c_func
(paren
id|ihandle
id|ih
comma
r_int
id|i
comma
r_int
id|r
comma
r_int
id|g
comma
r_int
id|b
)paren
suffix:semicolon
r_static
r_int
id|prom_next_node
c_func
(paren
id|phandle
op_star
id|nodep
)paren
suffix:semicolon
r_static
r_int
r_int
id|check_display
c_func
(paren
r_int
r_int
id|mem
)paren
suffix:semicolon
r_static
r_void
id|setup_disp_fake_bi
c_func
(paren
id|ihandle
id|dp
)paren
suffix:semicolon
r_static
r_int
r_int
id|copy_device_tree
c_func
(paren
r_int
r_int
id|mem_start
comma
r_int
r_int
id|mem_end
)paren
suffix:semicolon
r_static
r_int
r_int
id|inspect_node
c_func
(paren
id|phandle
id|node
comma
r_struct
id|device_node
op_star
id|dad
comma
r_int
r_int
id|mem_start
comma
r_int
r_int
id|mem_end
comma
r_struct
id|device_node
op_star
op_star
op_star
id|allnextpp
)paren
suffix:semicolon
r_static
r_void
id|prom_hold_cpus
c_func
(paren
r_int
r_int
id|mem
)paren
suffix:semicolon
r_static
r_void
id|prom_instantiate_rtas
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
op_star
id|early_get_property
c_func
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|node
comma
r_char
op_star
id|prop
)paren
suffix:semicolon
DECL|variable|__initdata
id|prom_entry
id|prom
id|__initdata
op_assign
l_int|0
suffix:semicolon
DECL|variable|__initdata
id|ihandle
id|prom_chosen
id|__initdata
op_assign
l_int|0
suffix:semicolon
DECL|variable|__initdata
id|ihandle
id|prom_stdout
id|__initdata
op_assign
l_int|0
suffix:semicolon
DECL|variable|__initdata
r_char
op_star
id|prom_display_paths
(braket
id|FB_MAX
)braket
id|__initdata
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|__initdata
id|phandle
id|prom_display_nodes
(braket
id|FB_MAX
)braket
id|__initdata
suffix:semicolon
DECL|variable|__initdata
r_int
r_int
id|prom_num_displays
id|__initdata
op_assign
l_int|0
suffix:semicolon
DECL|variable|__initdata
r_static
r_char
op_star
id|of_stdout_device
id|__initdata
op_assign
l_int|0
suffix:semicolon
DECL|variable|__initdata
r_static
id|ihandle
id|prom_disp_node
id|__initdata
op_assign
l_int|0
suffix:semicolon
DECL|variable|rtas_data
r_int
r_int
id|rtas_data
suffix:semicolon
multiline_comment|/* physical pointer */
DECL|variable|rtas_entry
r_int
r_int
id|rtas_entry
suffix:semicolon
multiline_comment|/* physical pointer */
DECL|variable|rtas_size
r_int
r_int
id|rtas_size
suffix:semicolon
DECL|variable|old_rtas
r_int
r_int
id|old_rtas
suffix:semicolon
DECL|variable|boot_infos
id|boot_infos_t
op_star
id|boot_infos
suffix:semicolon
DECL|variable|bootpath
r_char
op_star
id|bootpath
suffix:semicolon
DECL|variable|bootdevice
r_char
op_star
id|bootdevice
suffix:semicolon
DECL|variable|allnodes
r_struct
id|device_node
op_star
id|allnodes
suffix:semicolon
r_extern
r_char
op_star
id|klimit
suffix:semicolon
r_extern
r_char
id|_stext
suffix:semicolon
r_static
r_void
id|__init
DECL|function|prom_exit
id|prom_exit
c_func
(paren
r_void
)paren
(brace
r_struct
id|prom_args
id|args
suffix:semicolon
id|args.service
op_assign
l_string|&quot;exit&quot;
suffix:semicolon
id|args.nargs
op_assign
l_int|0
suffix:semicolon
id|args.nret
op_assign
l_int|0
suffix:semicolon
id|prom
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
multiline_comment|/* should never get here */
suffix:semicolon
)brace
r_static
r_void
op_star
id|__init
DECL|function|call_prom
id|call_prom
c_func
(paren
r_const
r_char
op_star
id|service
comma
r_int
id|nargs
comma
r_int
id|nret
comma
dot
dot
dot
)paren
(brace
id|va_list
id|list
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|prom_args
id|prom_args
suffix:semicolon
id|prom_args.service
op_assign
id|service
suffix:semicolon
id|prom_args.nargs
op_assign
id|nargs
suffix:semicolon
id|prom_args.nret
op_assign
id|nret
suffix:semicolon
id|va_start
c_func
(paren
id|list
comma
id|nret
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nargs
suffix:semicolon
op_increment
id|i
)paren
id|prom_args.args
(braket
id|i
)braket
op_assign
id|va_arg
c_func
(paren
id|list
comma
r_void
op_star
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|list
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nret
suffix:semicolon
op_increment
id|i
)paren
id|prom_args.args
(braket
id|i
op_plus
id|nargs
)braket
op_assign
l_int|0
suffix:semicolon
id|prom
c_func
(paren
op_amp
id|prom_args
)paren
suffix:semicolon
r_return
id|prom_args.args
(braket
id|nargs
)braket
suffix:semicolon
)brace
r_static
r_void
op_star
id|__init
DECL|function|call_prom_ret
id|call_prom_ret
c_func
(paren
r_const
r_char
op_star
id|service
comma
r_int
id|nargs
comma
r_int
id|nret
comma
r_void
op_star
op_star
id|rets
comma
dot
dot
dot
)paren
(brace
id|va_list
id|list
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|prom_args
id|prom_args
suffix:semicolon
id|prom_args.service
op_assign
id|service
suffix:semicolon
id|prom_args.nargs
op_assign
id|nargs
suffix:semicolon
id|prom_args.nret
op_assign
id|nret
suffix:semicolon
id|va_start
c_func
(paren
id|list
comma
id|rets
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nargs
suffix:semicolon
op_increment
id|i
)paren
id|prom_args.args
(braket
id|i
)braket
op_assign
id|va_arg
c_func
(paren
id|list
comma
r_void
op_star
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|list
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nret
suffix:semicolon
op_increment
id|i
)paren
id|prom_args.args
(braket
id|i
op_plus
id|nargs
)braket
op_assign
l_int|0
suffix:semicolon
id|prom
c_func
(paren
op_amp
id|prom_args
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|nret
suffix:semicolon
op_increment
id|i
)paren
id|rets
(braket
id|i
op_minus
l_int|1
)braket
op_assign
id|prom_args.args
(braket
id|nargs
op_plus
id|i
)braket
suffix:semicolon
r_return
id|prom_args.args
(braket
id|nargs
)braket
suffix:semicolon
)brace
r_void
id|__init
DECL|function|prom_print
id|prom_print
c_func
(paren
r_const
r_char
op_star
id|msg
)paren
(brace
r_const
r_char
op_star
id|p
comma
op_star
id|q
suffix:semicolon
r_if
c_cond
(paren
id|prom_stdout
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|msg
suffix:semicolon
op_star
id|p
op_ne
l_int|0
suffix:semicolon
id|p
op_assign
id|q
)paren
(brace
r_for
c_loop
(paren
id|q
op_assign
id|p
suffix:semicolon
op_star
id|q
op_ne
l_int|0
op_logical_and
op_star
id|q
op_ne
l_char|&squot;&bslash;n&squot;
suffix:semicolon
op_increment
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
OG
id|p
)paren
id|call_prom
c_func
(paren
l_string|&quot;write&quot;
comma
l_int|3
comma
l_int|1
comma
id|prom_stdout
comma
id|p
comma
id|q
op_minus
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|q
op_ne
l_int|0
)paren
(brace
op_increment
id|q
suffix:semicolon
id|call_prom
c_func
(paren
l_string|&quot;write&quot;
comma
l_int|3
comma
l_int|1
comma
id|prom_stdout
comma
l_string|&quot;&bslash;r&bslash;n&quot;
comma
l_int|2
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_void
id|__init
DECL|function|prom_print_hex
id|prom_print_hex
c_func
(paren
r_int
r_int
id|v
)paren
(brace
r_char
id|buf
(braket
l_int|16
)braket
suffix:semicolon
r_int
id|i
comma
id|c
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
)paren
(brace
id|c
op_assign
(paren
id|v
op_rshift
(paren
(paren
l_int|7
op_minus
id|i
)paren
op_star
l_int|4
)paren
)paren
op_amp
l_int|0xf
suffix:semicolon
id|c
op_add_assign
(paren
id|c
op_ge
l_int|10
)paren
ques
c_cond
(paren
l_char|&squot;a&squot;
op_minus
l_int|10
)paren
suffix:colon
l_char|&squot;0&squot;
suffix:semicolon
id|buf
(braket
id|i
)braket
op_assign
id|c
suffix:semicolon
)brace
id|buf
(braket
id|i
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
id|buf
(braket
id|i
op_plus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|prom_print
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|prom_set_color
id|prom_set_color
c_func
(paren
id|ihandle
id|ih
comma
r_int
id|i
comma
r_int
id|r
comma
r_int
id|g
comma
r_int
id|b
)paren
(brace
r_struct
id|prom_args
id|prom_args
suffix:semicolon
id|prom_args.service
op_assign
l_string|&quot;call-method&quot;
suffix:semicolon
id|prom_args.nargs
op_assign
l_int|6
suffix:semicolon
id|prom_args.nret
op_assign
l_int|1
suffix:semicolon
id|prom_args.args
(braket
l_int|0
)braket
op_assign
l_string|&quot;color!&quot;
suffix:semicolon
id|prom_args.args
(braket
l_int|1
)braket
op_assign
id|ih
suffix:semicolon
id|prom_args.args
(braket
l_int|2
)braket
op_assign
(paren
r_void
op_star
)paren
id|i
suffix:semicolon
id|prom_args.args
(braket
l_int|3
)braket
op_assign
(paren
r_void
op_star
)paren
id|b
suffix:semicolon
id|prom_args.args
(braket
l_int|4
)braket
op_assign
(paren
r_void
op_star
)paren
id|g
suffix:semicolon
id|prom_args.args
(braket
l_int|5
)braket
op_assign
(paren
r_void
op_star
)paren
id|r
suffix:semicolon
id|prom
c_func
(paren
op_amp
id|prom_args
)paren
suffix:semicolon
r_return
(paren
r_int
)paren
id|prom_args.args
(braket
l_int|6
)braket
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|prom_next_node
id|prom_next_node
c_func
(paren
id|phandle
op_star
id|nodep
)paren
(brace
id|phandle
id|node
suffix:semicolon
r_if
c_cond
(paren
(paren
id|node
op_assign
op_star
id|nodep
)paren
op_ne
l_int|0
op_logical_and
(paren
op_star
id|nodep
op_assign
id|call_prom
c_func
(paren
l_string|&quot;child&quot;
comma
l_int|1
comma
l_int|1
comma
id|node
)paren
)paren
op_ne
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|nodep
op_assign
id|call_prom
c_func
(paren
l_string|&quot;peer&quot;
comma
l_int|1
comma
l_int|1
comma
id|node
)paren
)paren
op_ne
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
(paren
id|node
op_assign
id|call_prom
c_func
(paren
l_string|&quot;parent&quot;
comma
l_int|1
comma
l_int|1
comma
id|node
)paren
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|nodep
op_assign
id|call_prom
c_func
(paren
l_string|&quot;peer&quot;
comma
l_int|1
comma
l_int|1
comma
id|node
)paren
)paren
op_ne
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * If we have a display that we don&squot;t know how to drive,&n; * we will want to try to execute OF&squot;s open method for it&n; * later.  However, OF will probably fall over if we do that&n; * we&squot;ve taken over the MMU.&n; * So we check whether we will need to open the display,&n; * and if so, open it now.&n; */
r_static
r_int
r_int
id|__init
DECL|function|check_display
id|check_display
c_func
(paren
r_int
r_int
id|mem
)paren
(brace
id|phandle
id|node
suffix:semicolon
id|ihandle
id|ih
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
id|type
(braket
l_int|16
)braket
comma
op_star
id|path
suffix:semicolon
r_static
r_int
r_char
id|default_colors
(braket
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0xaa
comma
l_int|0x00
comma
l_int|0xaa
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0xaa
comma
l_int|0xaa
comma
l_int|0xaa
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0xaa
comma
l_int|0x00
comma
l_int|0xaa
comma
l_int|0xaa
comma
l_int|0xaa
comma
l_int|0x00
comma
l_int|0xaa
comma
l_int|0xaa
comma
l_int|0xaa
comma
l_int|0x55
comma
l_int|0x55
comma
l_int|0x55
comma
l_int|0x55
comma
l_int|0x55
comma
l_int|0xff
comma
l_int|0x55
comma
l_int|0xff
comma
l_int|0x55
comma
l_int|0x55
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0x55
comma
l_int|0x55
comma
l_int|0xff
comma
l_int|0x55
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0x55
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
)brace
suffix:semicolon
id|prom_disp_node
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|prom_next_node
c_func
(paren
op_amp
id|node
)paren
suffix:semicolon
)paren
(brace
id|type
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|call_prom
c_func
(paren
l_string|&quot;getprop&quot;
comma
l_int|4
comma
l_int|1
comma
id|node
comma
l_string|&quot;device_type&quot;
comma
id|type
comma
r_sizeof
(paren
id|type
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|type
comma
l_string|&quot;display&quot;
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* It seems OF doesn&squot;t null-terminate the path :-( */
id|path
op_assign
(paren
r_char
op_star
)paren
id|mem
suffix:semicolon
id|memset
c_func
(paren
id|path
comma
l_int|0
comma
l_int|256
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|call_prom
c_func
(paren
l_string|&quot;package-to-path&quot;
comma
l_int|3
comma
l_int|1
comma
id|node
comma
id|path
comma
l_int|255
)paren
OL
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If this display is the device that OF is using for stdout,&n;&t;&t; * move it to the front of the list.&n;&t;&t; */
id|mem
op_add_assign
id|strlen
c_func
(paren
id|path
)paren
op_plus
l_int|1
suffix:semicolon
id|i
op_assign
id|prom_num_displays
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|of_stdout_device
op_ne
l_int|0
op_logical_and
id|i
OG
l_int|0
op_logical_and
id|strcmp
c_func
(paren
id|of_stdout_device
comma
id|path
)paren
op_eq
l_int|0
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
)paren
(brace
id|prom_display_paths
(braket
id|i
)braket
op_assign
id|prom_display_paths
(braket
id|i
op_minus
l_int|1
)braket
suffix:semicolon
id|prom_display_nodes
(braket
id|i
)braket
op_assign
id|prom_display_nodes
(braket
id|i
op_minus
l_int|1
)braket
suffix:semicolon
)brace
)brace
id|prom_display_paths
(braket
id|i
)braket
op_assign
id|path
suffix:semicolon
id|prom_display_nodes
(braket
id|i
)braket
op_assign
id|node
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
id|prom_disp_node
op_assign
id|node
suffix:semicolon
r_if
c_cond
(paren
id|prom_num_displays
op_ge
id|FB_MAX
)paren
r_break
suffix:semicolon
)brace
id|try_again
suffix:colon
multiline_comment|/*&n;&t; * Open the first display and set its colormap.&n;&t; */
r_if
c_cond
(paren
id|prom_num_displays
OG
l_int|0
)paren
(brace
id|path
op_assign
id|prom_display_paths
(braket
l_int|0
)braket
suffix:semicolon
id|prom_print
c_func
(paren
l_string|&quot;opening display &quot;
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|path
)paren
suffix:semicolon
id|ih
op_assign
id|call_prom
c_func
(paren
l_string|&quot;open&quot;
comma
l_int|1
comma
l_int|1
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ih
op_eq
l_int|0
op_logical_or
id|ih
op_eq
(paren
id|ihandle
)paren
op_minus
l_int|1
)paren
(brace
id|prom_print
c_func
(paren
l_string|&quot;... failed&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|prom_num_displays
suffix:semicolon
id|i
op_increment
)paren
(brace
id|prom_display_paths
(braket
id|i
op_minus
l_int|1
)braket
op_assign
id|prom_display_paths
(braket
id|i
)braket
suffix:semicolon
id|prom_display_nodes
(braket
id|i
op_minus
l_int|1
)braket
op_assign
id|prom_display_nodes
(braket
id|i
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|prom_num_displays
OG
l_int|0
)paren
id|prom_disp_node
op_assign
id|prom_display_nodes
(braket
l_int|0
)braket
suffix:semicolon
r_else
id|prom_disp_node
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|try_again
suffix:semicolon
)brace
r_else
(brace
id|prom_print
c_func
(paren
l_string|&quot;... ok&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Setup a usable color table when the appropriate&n;&t;&t;&t; * method is available.&n;&t;&t;&t; * Should update this to use set-colors.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|prom_set_color
c_func
(paren
id|ih
comma
id|i
comma
id|default_colors
(braket
id|i
op_star
l_int|3
)braket
comma
id|default_colors
(braket
id|i
op_star
l_int|3
op_plus
l_int|1
)braket
comma
id|default_colors
(braket
id|i
op_star
l_int|3
op_plus
l_int|2
)braket
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_FB
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|LINUX_LOGO_COLORS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|prom_set_color
c_func
(paren
id|ih
comma
id|i
op_plus
l_int|32
comma
id|linux_logo_red
(braket
id|i
)braket
comma
id|linux_logo_green
(braket
id|i
)braket
comma
id|linux_logo_blue
(braket
id|i
)braket
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
macro_line|#endif /* CONFIG_FB */
)brace
)brace
r_return
id|ALIGNUL
c_func
(paren
id|mem
)paren
suffix:semicolon
)brace
multiline_comment|/* This function will enable the early boot text when doing OF booting. This&n; * way, xmon output should work too&n; */
r_static
r_void
id|__init
DECL|function|setup_disp_fake_bi
id|setup_disp_fake_bi
c_func
(paren
id|ihandle
id|dp
)paren
(brace
macro_line|#ifdef CONFIG_BOOTX_TEXT
r_int
id|width
op_assign
l_int|640
comma
id|height
op_assign
l_int|480
comma
id|depth
op_assign
l_int|8
comma
id|pitch
suffix:semicolon
r_int
id|address
suffix:semicolon
r_struct
id|pci_reg_property
id|addrs
(braket
l_int|8
)braket
suffix:semicolon
r_int
id|i
comma
id|naddrs
suffix:semicolon
r_char
id|name
(braket
l_int|32
)braket
suffix:semicolon
r_char
op_star
id|getprop
op_assign
l_string|&quot;getprop&quot;
suffix:semicolon
id|prom_print
c_func
(paren
l_string|&quot;Initializing fake screen: &quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
id|name
comma
l_int|0
comma
r_sizeof
(paren
id|name
)paren
)paren
suffix:semicolon
id|call_prom
c_func
(paren
id|getprop
comma
l_int|4
comma
l_int|1
comma
id|dp
comma
l_string|&quot;name&quot;
comma
id|name
comma
r_sizeof
(paren
id|name
)paren
)paren
suffix:semicolon
id|name
(braket
r_sizeof
(paren
id|name
)paren
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|prom_print
c_func
(paren
id|name
)paren
suffix:semicolon
id|prom_print
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|call_prom
c_func
(paren
id|getprop
comma
l_int|4
comma
l_int|1
comma
id|dp
comma
l_string|&quot;width&quot;
comma
op_amp
id|width
comma
r_sizeof
(paren
id|width
)paren
)paren
suffix:semicolon
id|call_prom
c_func
(paren
id|getprop
comma
l_int|4
comma
l_int|1
comma
id|dp
comma
l_string|&quot;height&quot;
comma
op_amp
id|height
comma
r_sizeof
(paren
id|height
)paren
)paren
suffix:semicolon
id|call_prom
c_func
(paren
id|getprop
comma
l_int|4
comma
l_int|1
comma
id|dp
comma
l_string|&quot;depth&quot;
comma
op_amp
id|depth
comma
r_sizeof
(paren
id|depth
)paren
)paren
suffix:semicolon
id|pitch
op_assign
id|width
op_star
(paren
(paren
id|depth
op_plus
l_int|7
)paren
op_div
l_int|8
)paren
suffix:semicolon
id|call_prom
c_func
(paren
id|getprop
comma
l_int|4
comma
l_int|1
comma
id|dp
comma
l_string|&quot;linebytes&quot;
comma
op_amp
id|pitch
comma
r_sizeof
(paren
id|pitch
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pitch
op_eq
l_int|1
)paren
id|pitch
op_assign
l_int|0x1000
suffix:semicolon
multiline_comment|/* for strange IBM display */
id|address
op_assign
l_int|0
suffix:semicolon
id|call_prom
c_func
(paren
id|getprop
comma
l_int|4
comma
l_int|1
comma
id|dp
comma
l_string|&quot;address&quot;
comma
op_amp
id|address
comma
r_sizeof
(paren
id|address
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|address
op_eq
l_int|0
)paren
(brace
multiline_comment|/* look for an assigned address with a size of &gt;= 1MB */
id|naddrs
op_assign
(paren
r_int
)paren
id|call_prom
c_func
(paren
id|getprop
comma
l_int|4
comma
l_int|1
comma
id|dp
comma
l_string|&quot;assigned-addresses&quot;
comma
id|addrs
comma
r_sizeof
(paren
id|addrs
)paren
)paren
suffix:semicolon
id|naddrs
op_div_assign
r_sizeof
(paren
r_struct
id|pci_reg_property
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|naddrs
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|addrs
(braket
id|i
)braket
dot
id|size_lo
op_ge
(paren
l_int|1
op_lshift
l_int|20
)paren
)paren
(brace
id|address
op_assign
id|addrs
(braket
id|i
)braket
dot
id|addr.a_lo
suffix:semicolon
multiline_comment|/* use the BE aperture if possible */
r_if
c_cond
(paren
id|addrs
(braket
id|i
)braket
dot
id|size_lo
op_ge
(paren
l_int|16
op_lshift
l_int|20
)paren
)paren
id|address
op_add_assign
(paren
l_int|8
op_lshift
l_int|20
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|address
op_eq
l_int|0
)paren
(brace
id|prom_print
c_func
(paren
l_string|&quot;Failed to get address&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* kludge for valkyrie */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;valkyrie&quot;
)paren
op_eq
l_int|0
)paren
id|address
op_add_assign
l_int|0x1000
suffix:semicolon
id|btext_setup_display
c_func
(paren
id|width
comma
id|height
comma
id|depth
comma
id|pitch
comma
id|address
)paren
suffix:semicolon
id|btext_prepare_BAT
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BOOTX_TEXT */
)brace
multiline_comment|/*&n; * Make a copy of the device tree from the PROM.&n; */
r_static
r_int
r_int
id|__init
DECL|function|copy_device_tree
id|copy_device_tree
c_func
(paren
r_int
r_int
id|mem_start
comma
r_int
r_int
id|mem_end
)paren
(brace
id|phandle
id|root
suffix:semicolon
r_int
r_int
id|new_start
suffix:semicolon
r_struct
id|device_node
op_star
op_star
id|allnextp
suffix:semicolon
id|root
op_assign
id|call_prom
c_func
(paren
l_string|&quot;peer&quot;
comma
l_int|1
comma
l_int|1
comma
(paren
id|phandle
)paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|root
op_eq
(paren
id|phandle
)paren
l_int|0
)paren
(brace
id|prom_print
c_func
(paren
l_string|&quot;couldn&squot;t get device tree root&bslash;n&quot;
)paren
suffix:semicolon
id|prom_exit
c_func
(paren
)paren
suffix:semicolon
)brace
id|allnextp
op_assign
op_amp
id|allnodes
suffix:semicolon
id|mem_start
op_assign
id|ALIGNUL
c_func
(paren
id|mem_start
)paren
suffix:semicolon
id|new_start
op_assign
id|inspect_node
c_func
(paren
id|root
comma
l_int|0
comma
id|mem_start
comma
id|mem_end
comma
op_amp
id|allnextp
)paren
suffix:semicolon
op_star
id|allnextp
op_assign
l_int|0
suffix:semicolon
r_return
id|new_start
suffix:semicolon
)brace
r_static
r_int
r_int
id|__init
DECL|function|inspect_node
id|inspect_node
c_func
(paren
id|phandle
id|node
comma
r_struct
id|device_node
op_star
id|dad
comma
r_int
r_int
id|mem_start
comma
r_int
r_int
id|mem_end
comma
r_struct
id|device_node
op_star
op_star
op_star
id|allnextpp
)paren
(brace
r_int
id|l
suffix:semicolon
id|phandle
id|child
suffix:semicolon
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_struct
id|property
op_star
id|pp
comma
op_star
op_star
id|prev_propp
suffix:semicolon
r_char
op_star
id|prev_name
comma
op_star
id|namep
suffix:semicolon
r_int
r_char
op_star
id|valp
suffix:semicolon
id|np
op_assign
(paren
r_struct
id|device_node
op_star
)paren
id|mem_start
suffix:semicolon
id|mem_start
op_add_assign
r_sizeof
(paren
r_struct
id|device_node
)paren
suffix:semicolon
id|memset
c_func
(paren
id|np
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;node
op_assign
id|node
suffix:semicolon
op_star
op_star
id|allnextpp
op_assign
id|PTRUNRELOC
c_func
(paren
id|np
)paren
suffix:semicolon
op_star
id|allnextpp
op_assign
op_amp
id|np-&gt;allnext
suffix:semicolon
r_if
c_cond
(paren
id|dad
op_ne
l_int|0
)paren
(brace
id|np-&gt;parent
op_assign
id|PTRUNRELOC
c_func
(paren
id|dad
)paren
suffix:semicolon
multiline_comment|/* we temporarily use the `next&squot; field as `last_child&squot;. */
r_if
c_cond
(paren
id|dad-&gt;next
op_eq
l_int|0
)paren
id|dad-&gt;child
op_assign
id|PTRUNRELOC
c_func
(paren
id|np
)paren
suffix:semicolon
r_else
id|dad-&gt;next-&gt;sibling
op_assign
id|PTRUNRELOC
c_func
(paren
id|np
)paren
suffix:semicolon
id|dad-&gt;next
op_assign
id|np
suffix:semicolon
)brace
multiline_comment|/* get and store all properties */
id|prev_propp
op_assign
op_amp
id|np-&gt;properties
suffix:semicolon
id|prev_name
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|pp
op_assign
(paren
r_struct
id|property
op_star
)paren
id|mem_start
suffix:semicolon
id|namep
op_assign
(paren
r_char
op_star
)paren
(paren
id|pp
op_plus
l_int|1
)paren
suffix:semicolon
id|pp-&gt;name
op_assign
id|PTRUNRELOC
c_func
(paren
id|namep
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|call_prom
c_func
(paren
l_string|&quot;nextprop&quot;
comma
l_int|3
comma
l_int|1
comma
id|node
comma
id|prev_name
comma
id|namep
)paren
op_le
l_int|0
)paren
r_break
suffix:semicolon
id|mem_start
op_assign
id|ALIGNUL
c_func
(paren
(paren
r_int
r_int
)paren
id|namep
op_plus
id|strlen
c_func
(paren
id|namep
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|prev_name
op_assign
id|namep
suffix:semicolon
id|valp
op_assign
(paren
r_int
r_char
op_star
)paren
id|mem_start
suffix:semicolon
id|pp-&gt;value
op_assign
id|PTRUNRELOC
c_func
(paren
id|valp
)paren
suffix:semicolon
id|pp-&gt;length
op_assign
(paren
r_int
)paren
id|call_prom
c_func
(paren
l_string|&quot;getprop&quot;
comma
l_int|4
comma
l_int|1
comma
id|node
comma
id|namep
comma
id|valp
comma
id|mem_end
op_minus
id|mem_start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;length
OL
l_int|0
)paren
r_continue
suffix:semicolon
macro_line|#ifdef MAX_PROPERTY_LENGTH
r_if
c_cond
(paren
id|pp-&gt;length
OG
id|MAX_PROPERTY_LENGTH
)paren
r_continue
suffix:semicolon
multiline_comment|/* ignore this property */
macro_line|#endif
id|mem_start
op_assign
id|ALIGNUL
c_func
(paren
id|mem_start
op_plus
id|pp-&gt;length
)paren
suffix:semicolon
op_star
id|prev_propp
op_assign
id|PTRUNRELOC
c_func
(paren
id|pp
)paren
suffix:semicolon
id|prev_propp
op_assign
op_amp
id|pp-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|np-&gt;node
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Add a &quot;linux,phandle&quot; property&quot; */
id|pp
op_assign
(paren
r_struct
id|property
op_star
)paren
id|mem_start
suffix:semicolon
op_star
id|prev_propp
op_assign
id|PTRUNRELOC
c_func
(paren
id|pp
)paren
suffix:semicolon
id|prev_propp
op_assign
op_amp
id|pp-&gt;next
suffix:semicolon
id|namep
op_assign
(paren
r_char
op_star
)paren
(paren
id|pp
op_plus
l_int|1
)paren
suffix:semicolon
id|pp-&gt;name
op_assign
id|PTRUNRELOC
c_func
(paren
id|namep
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|namep
comma
l_string|&quot;linux,phandle&quot;
)paren
suffix:semicolon
id|mem_start
op_assign
id|ALIGNUL
c_func
(paren
(paren
r_int
r_int
)paren
id|namep
op_plus
id|strlen
c_func
(paren
id|namep
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|pp-&gt;value
op_assign
(paren
r_int
r_char
op_star
)paren
id|PTRUNRELOC
c_func
(paren
op_amp
id|np-&gt;node
)paren
suffix:semicolon
id|pp-&gt;length
op_assign
r_sizeof
(paren
id|np-&gt;node
)paren
suffix:semicolon
)brace
op_star
id|prev_propp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* get the node&squot;s full name */
id|l
op_assign
(paren
r_int
)paren
id|call_prom
c_func
(paren
l_string|&quot;package-to-path&quot;
comma
l_int|3
comma
l_int|1
comma
id|node
comma
(paren
r_char
op_star
)paren
id|mem_start
comma
id|mem_end
op_minus
id|mem_start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l
op_ge
l_int|0
)paren
(brace
id|np-&gt;full_name
op_assign
id|PTRUNRELOC
c_func
(paren
(paren
r_char
op_star
)paren
id|mem_start
)paren
suffix:semicolon
op_star
(paren
r_char
op_star
)paren
(paren
id|mem_start
op_plus
id|l
)paren
op_assign
l_int|0
suffix:semicolon
id|mem_start
op_assign
id|ALIGNUL
c_func
(paren
id|mem_start
op_plus
id|l
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* do all our children */
id|child
op_assign
id|call_prom
c_func
(paren
l_string|&quot;child&quot;
comma
l_int|1
comma
l_int|1
comma
id|node
)paren
suffix:semicolon
r_while
c_loop
(paren
id|child
op_ne
(paren
r_void
op_star
)paren
l_int|0
)paren
(brace
id|mem_start
op_assign
id|inspect_node
c_func
(paren
id|child
comma
id|np
comma
id|mem_start
comma
id|mem_end
comma
id|allnextpp
)paren
suffix:semicolon
id|child
op_assign
id|call_prom
c_func
(paren
l_string|&quot;peer&quot;
comma
l_int|1
comma
l_int|1
comma
id|child
)paren
suffix:semicolon
)brace
r_return
id|mem_start
suffix:semicolon
)brace
DECL|variable|__initdata
r_int
r_int
id|smp_chrp_cpu_nr
id|__initdata
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * With CHRP SMP we need to use the OF to start the other&n; * processors so we can&squot;t wait until smp_boot_cpus (the OF is&n; * trashed by then) so we have to put the processors into&n; * a holding pattern controlled by the kernel (not OF) before&n; * we destroy the OF.&n; *&n; * This uses a chunk of high memory, puts some holding pattern&n; * code there and sends the other processors off to there until&n; * smp_boot_cpus tells them to do something.  We do that by using&n; * physical address 0x0.  The holding pattern checks that address&n; * until its cpu # is there, when it is that cpu jumps to&n; * __secondary_start().  smp_boot_cpus() takes care of setting those&n; * values.&n; *&n; * We also use physical address 0x4 here to tell when a cpu&n; * is in its holding pattern code.&n; *&n; * -- Cort&n; *&n; * Note that we have to do this if we have more than one CPU,&n; * even if this is a UP kernel.  Otherwise when we trash OF&n; * the other CPUs will start executing some random instructions&n; * and crash the system.  -- paulus&n; */
r_static
r_void
id|__init
DECL|function|prom_hold_cpus
id|prom_hold_cpus
c_func
(paren
r_int
r_int
id|mem
)paren
(brace
r_extern
r_void
id|__secondary_hold
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_int
id|cpu
suffix:semicolon
id|phandle
id|node
suffix:semicolon
r_char
id|type
(braket
l_int|16
)braket
comma
op_star
id|path
suffix:semicolon
r_int
r_int
id|reg
suffix:semicolon
multiline_comment|/*&n;&t; * XXX: hack to make sure we&squot;re chrp, assume that if we&squot;re&n;&t; *      chrp we have a device_type property -- Cort&n;&t; */
id|node
op_assign
id|call_prom
c_func
(paren
l_string|&quot;finddevice&quot;
comma
l_int|1
comma
l_int|1
comma
l_string|&quot;/&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|call_prom
c_func
(paren
l_string|&quot;getprop&quot;
comma
l_int|4
comma
l_int|1
comma
id|node
comma
l_string|&quot;device_type&quot;
comma
id|type
comma
r_sizeof
(paren
id|type
)paren
)paren
op_le
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* copy the holding pattern code to someplace safe (0) */
multiline_comment|/* the holding pattern is now within the first 0x100&n;&t;   bytes of the kernel image -- paulus */
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
l_int|0
comma
op_amp
id|_stext
comma
l_int|0x100
)paren
suffix:semicolon
id|flush_icache_range
c_func
(paren
l_int|0
comma
l_int|0x100
)paren
suffix:semicolon
multiline_comment|/* look for cpus */
op_star
(paren
r_int
r_int
op_star
)paren
(paren
l_int|0x0
)paren
op_assign
l_int|0
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;dcbf 0,%0&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
l_int|0
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|node
op_assign
l_int|0
suffix:semicolon
id|prom_next_node
c_func
(paren
op_amp
id|node
)paren
suffix:semicolon
)paren
(brace
id|type
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|call_prom
c_func
(paren
l_string|&quot;getprop&quot;
comma
l_int|4
comma
l_int|1
comma
id|node
comma
l_string|&quot;device_type&quot;
comma
id|type
comma
r_sizeof
(paren
id|type
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|type
comma
l_string|&quot;cpu&quot;
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
id|path
op_assign
(paren
r_char
op_star
)paren
id|mem
suffix:semicolon
id|memset
c_func
(paren
id|path
comma
l_int|0
comma
l_int|256
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|call_prom
c_func
(paren
l_string|&quot;package-to-path&quot;
comma
l_int|3
comma
l_int|1
comma
id|node
comma
id|path
comma
l_int|255
)paren
OL
l_int|0
)paren
r_continue
suffix:semicolon
id|reg
op_assign
op_minus
l_int|1
suffix:semicolon
id|call_prom
c_func
(paren
l_string|&quot;getprop&quot;
comma
l_int|4
comma
l_int|1
comma
id|node
comma
l_string|&quot;reg&quot;
comma
op_amp
id|reg
comma
r_sizeof
(paren
id|reg
)paren
)paren
suffix:semicolon
id|cpu
op_assign
id|smp_chrp_cpu_nr
op_increment
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|smp_hw_index
(braket
id|cpu
)braket
op_assign
id|reg
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
multiline_comment|/* XXX: hack - don&squot;t start cpu 0, this cpu -- Cort */
r_if
c_cond
(paren
id|cpu
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|prom_print
c_func
(paren
l_string|&quot;starting cpu &quot;
)paren
suffix:semicolon
id|prom_print
c_func
(paren
id|path
)paren
suffix:semicolon
op_star
(paren
id|ulong
op_star
)paren
(paren
l_int|0x4
)paren
op_assign
l_int|0
suffix:semicolon
id|call_prom
c_func
(paren
l_string|&quot;start-cpu&quot;
comma
l_int|3
comma
l_int|0
comma
id|node
comma
(paren
r_char
op_star
)paren
id|__secondary_hold
op_minus
op_amp
id|_stext
comma
id|cpu
)paren
suffix:semicolon
id|prom_print
c_func
(paren
l_string|&quot;...&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
l_int|10000
)paren
op_logical_and
(paren
op_star
(paren
id|ulong
op_star
)paren
(paren
l_int|0x4
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|i
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
id|ulong
op_star
)paren
(paren
l_int|0x4
)paren
op_eq
id|cpu
)paren
id|prom_print
c_func
(paren
l_string|&quot;ok&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
id|prom_print
c_func
(paren
l_string|&quot;failed: &quot;
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
op_star
(paren
id|ulong
op_star
)paren
l_int|0x4
)paren
suffix:semicolon
id|prom_print
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_void
id|__init
DECL|function|prom_instantiate_rtas
id|prom_instantiate_rtas
c_func
(paren
r_void
)paren
(brace
id|ihandle
id|prom_rtas
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_struct
id|prom_args
id|prom_args
suffix:semicolon
id|prom_rtas
op_assign
id|call_prom
c_func
(paren
l_string|&quot;finddevice&quot;
comma
l_int|1
comma
l_int|1
comma
l_string|&quot;/rtas&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prom_rtas
op_eq
(paren
r_void
op_star
)paren
op_minus
l_int|1
)paren
r_return
suffix:semicolon
id|rtas_size
op_assign
l_int|0
suffix:semicolon
id|call_prom
c_func
(paren
l_string|&quot;getprop&quot;
comma
l_int|4
comma
l_int|1
comma
id|prom_rtas
comma
l_string|&quot;rtas-size&quot;
comma
op_amp
id|rtas_size
comma
r_sizeof
(paren
id|rtas_size
)paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
l_string|&quot;instantiating rtas&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtas_size
op_eq
l_int|0
)paren
(brace
id|rtas_data
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Ask OF for some space for RTAS.&n;&t;&t; * Actually OF has bugs so we just arbitrarily&n;&t;&t; * use memory at the 6MB point.&n;&t;&t; */
id|rtas_data
op_assign
l_int|6
op_lshift
l_int|20
suffix:semicolon
id|prom_print
c_func
(paren
l_string|&quot; at &quot;
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|rtas_data
)paren
suffix:semicolon
)brace
id|prom_rtas
op_assign
id|call_prom
c_func
(paren
l_string|&quot;open&quot;
comma
l_int|1
comma
l_int|1
comma
l_string|&quot;/rtas&quot;
)paren
suffix:semicolon
id|prom_print
c_func
(paren
l_string|&quot;...&quot;
)paren
suffix:semicolon
id|prom_args.service
op_assign
l_string|&quot;call-method&quot;
suffix:semicolon
id|prom_args.nargs
op_assign
l_int|3
suffix:semicolon
id|prom_args.nret
op_assign
l_int|2
suffix:semicolon
id|prom_args.args
(braket
l_int|0
)braket
op_assign
l_string|&quot;instantiate-rtas&quot;
suffix:semicolon
id|prom_args.args
(braket
l_int|1
)braket
op_assign
id|prom_rtas
suffix:semicolon
id|prom_args.args
(braket
l_int|2
)braket
op_assign
(paren
r_void
op_star
)paren
id|rtas_data
suffix:semicolon
id|prom
c_func
(paren
op_amp
id|prom_args
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|prom_args.args
(braket
l_int|3
)braket
op_eq
l_int|0
)paren
id|i
op_assign
(paren
r_int
r_int
)paren
id|prom_args.args
(braket
l_int|4
)braket
suffix:semicolon
id|rtas_entry
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rtas_entry
op_eq
op_minus
l_int|1
)paren
op_logical_or
(paren
id|rtas_entry
op_eq
l_int|0
)paren
)paren
id|prom_print
c_func
(paren
l_string|&quot; failed&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|prom_print
c_func
(paren
l_string|&quot; done&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We enter here early on, when the Open Firmware prom is still&n; * handling exceptions and the MMU hash table for us.&n; */
r_int
r_int
id|__init
DECL|function|prom_init
id|prom_init
c_func
(paren
r_int
id|r3
comma
r_int
id|r4
comma
id|prom_entry
id|pp
)paren
(brace
r_int
r_int
id|mem
suffix:semicolon
id|ihandle
id|prom_mmu
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|reloc_offset
c_func
(paren
)paren
suffix:semicolon
r_int
id|i
comma
id|l
suffix:semicolon
r_char
op_star
id|p
comma
op_star
id|d
suffix:semicolon
r_int
r_int
id|phys
suffix:semicolon
r_void
op_star
id|result
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Default */
id|phys
op_assign
(paren
r_int
r_int
)paren
op_amp
id|_stext
suffix:semicolon
multiline_comment|/* First get a handle for the stdout device */
id|prom
op_assign
id|pp
suffix:semicolon
id|prom_chosen
op_assign
id|call_prom
c_func
(paren
l_string|&quot;finddevice&quot;
comma
l_int|1
comma
l_int|1
comma
l_string|&quot;/chosen&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prom_chosen
op_eq
(paren
r_void
op_star
)paren
op_minus
l_int|1
)paren
id|prom_exit
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|call_prom
c_func
(paren
l_string|&quot;getprop&quot;
comma
l_int|4
comma
l_int|1
comma
id|prom_chosen
comma
l_string|&quot;stdout&quot;
comma
op_amp
id|prom_stdout
comma
r_sizeof
(paren
id|prom_stdout
)paren
)paren
op_le
l_int|0
)paren
id|prom_exit
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Get the full OF pathname of the stdout device */
id|mem
op_assign
(paren
r_int
r_int
)paren
id|klimit
op_plus
id|offset
suffix:semicolon
id|p
op_assign
(paren
r_char
op_star
)paren
id|mem
suffix:semicolon
id|memset
c_func
(paren
id|p
comma
l_int|0
comma
l_int|256
)paren
suffix:semicolon
id|call_prom
c_func
(paren
l_string|&quot;instance-to-path&quot;
comma
l_int|3
comma
l_int|1
comma
id|prom_stdout
comma
id|p
comma
l_int|255
)paren
suffix:semicolon
id|of_stdout_device
op_assign
id|p
suffix:semicolon
id|mem
op_add_assign
id|strlen
c_func
(paren
id|p
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Get the boot device and translate it to a full OF pathname. */
id|p
op_assign
(paren
r_char
op_star
)paren
id|mem
suffix:semicolon
id|l
op_assign
(paren
r_int
)paren
id|call_prom
c_func
(paren
l_string|&quot;getprop&quot;
comma
l_int|4
comma
l_int|1
comma
id|prom_chosen
comma
l_string|&quot;bootpath&quot;
comma
id|p
comma
l_int|1
op_lshift
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l
OG
l_int|0
)paren
(brace
id|p
(braket
id|l
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* should already be null-terminated */
id|bootpath
op_assign
id|PTRUNRELOC
c_func
(paren
id|p
)paren
suffix:semicolon
id|mem
op_add_assign
id|l
op_plus
l_int|1
suffix:semicolon
id|d
op_assign
(paren
r_char
op_star
)paren
id|mem
suffix:semicolon
op_star
id|d
op_assign
l_int|0
suffix:semicolon
id|call_prom
c_func
(paren
l_string|&quot;canon&quot;
comma
l_int|3
comma
l_int|1
comma
id|p
comma
id|d
comma
l_int|1
op_lshift
l_int|20
)paren
suffix:semicolon
id|bootdevice
op_assign
id|PTRUNRELOC
c_func
(paren
id|d
)paren
suffix:semicolon
id|mem
op_assign
id|ALIGNUL
c_func
(paren
id|mem
op_plus
id|strlen
c_func
(paren
id|d
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
id|prom_instantiate_rtas
c_func
(paren
)paren
suffix:semicolon
id|mem
op_assign
id|check_display
c_func
(paren
id|mem
)paren
suffix:semicolon
id|prom_print
c_func
(paren
l_string|&quot;copying OF device tree...&quot;
)paren
suffix:semicolon
id|mem
op_assign
id|copy_device_tree
c_func
(paren
id|mem
comma
id|mem
op_plus
(paren
l_int|1
op_lshift
l_int|20
)paren
)paren
suffix:semicolon
id|prom_print
c_func
(paren
l_string|&quot;done&bslash;n&quot;
)paren
suffix:semicolon
id|prom_hold_cpus
c_func
(paren
id|mem
)paren
suffix:semicolon
id|klimit
op_assign
(paren
r_char
op_star
)paren
(paren
id|mem
op_minus
id|offset
)paren
suffix:semicolon
multiline_comment|/* If we are already running at 0xc0000000, we assume we were&n;&t; * loaded by an OF bootloader which did set a BAT for us.&n;&t; * This breaks OF translate so we force phys to be 0.&n;&t; */
r_if
c_cond
(paren
id|offset
op_eq
l_int|0
)paren
id|phys
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
r_int
)paren
id|call_prom
c_func
(paren
l_string|&quot;getprop&quot;
comma
l_int|4
comma
l_int|1
comma
id|prom_chosen
comma
l_string|&quot;mmu&quot;
comma
op_amp
id|prom_mmu
comma
r_sizeof
(paren
id|prom_mmu
)paren
)paren
op_le
l_int|0
)paren
(brace
id|prom_print
c_func
(paren
l_string|&quot; no MMU found&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
r_int
)paren
id|call_prom_ret
c_func
(paren
l_string|&quot;call-method&quot;
comma
l_int|4
comma
l_int|4
comma
id|result
comma
l_string|&quot;translate&quot;
comma
id|prom_mmu
comma
op_amp
id|_stext
comma
l_int|1
)paren
op_ne
l_int|0
)paren
(brace
id|prom_print
c_func
(paren
l_string|&quot; (translate failed)&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We assume the phys. address size is 3 cells */
id|phys
op_assign
(paren
r_int
r_int
)paren
id|result
(braket
l_int|2
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prom_disp_node
op_ne
l_int|0
)paren
id|setup_disp_fake_bi
c_func
(paren
id|prom_disp_node
)paren
suffix:semicolon
multiline_comment|/* Use quiesce call to get OF to shut down any devices it&squot;s using */
id|prom_print
c_func
(paren
l_string|&quot;Calling quiesce ...&bslash;n&quot;
)paren
suffix:semicolon
id|call_prom
c_func
(paren
l_string|&quot;quiesce&quot;
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Relocate various pointers which will be used once the&n;&t;   kernel is running at the address it was linked at. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|prom_num_displays
suffix:semicolon
op_increment
id|i
)paren
id|prom_display_paths
(braket
id|i
)braket
op_assign
id|PTRUNRELOC
c_func
(paren
id|prom_display_paths
(braket
id|i
)braket
)paren
suffix:semicolon
id|prom_print
c_func
(paren
l_string|&quot;returning 0x&quot;
)paren
suffix:semicolon
id|prom_print_hex
c_func
(paren
id|phys
)paren
suffix:semicolon
id|prom_print
c_func
(paren
l_string|&quot;from prom_init&bslash;n&quot;
)paren
suffix:semicolon
id|prom_stdout
op_assign
l_int|0
suffix:semicolon
r_return
id|phys
suffix:semicolon
)brace
multiline_comment|/*&n; * early_get_property is used to access the device tree image prepared&n; * by BootX very early on, before the pointers in it have been relocated.&n; */
r_static
r_void
op_star
id|__init
DECL|function|early_get_property
id|early_get_property
c_func
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|node
comma
r_char
op_star
id|prop
)paren
(brace
r_struct
id|device_node
op_star
id|np
op_assign
(paren
r_struct
id|device_node
op_star
)paren
(paren
id|base
op_plus
id|node
)paren
suffix:semicolon
r_struct
id|property
op_star
id|pp
suffix:semicolon
r_for
c_loop
(paren
id|pp
op_assign
id|np-&gt;properties
suffix:semicolon
id|pp
op_ne
l_int|0
suffix:semicolon
id|pp
op_assign
id|pp-&gt;next
)paren
(brace
id|pp
op_assign
(paren
r_struct
id|property
op_star
)paren
(paren
id|base
op_plus
(paren
r_int
r_int
)paren
id|pp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
(paren
r_char
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|pp-&gt;name
op_plus
id|base
)paren
comma
id|prop
)paren
op_eq
l_int|0
)paren
(brace
r_return
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|pp-&gt;value
op_plus
id|base
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Is boot-info compatible ? */
DECL|macro|BOOT_INFO_IS_COMPATIBLE
mdefine_line|#define BOOT_INFO_IS_COMPATIBLE(bi)&t;&t;((bi)-&gt;compatible_version &lt;= BOOT_INFO_VERSION)
DECL|macro|BOOT_INFO_IS_V2_COMPATIBLE
mdefine_line|#define BOOT_INFO_IS_V2_COMPATIBLE(bi)&t;((bi)-&gt;version &gt;= 2)
DECL|macro|BOOT_INFO_IS_V4_COMPATIBLE
mdefine_line|#define BOOT_INFO_IS_V4_COMPATIBLE(bi)&t;((bi)-&gt;version &gt;= 4)
r_void
id|__init
DECL|function|bootx_init
id|bootx_init
c_func
(paren
r_int
r_int
id|r4
comma
r_int
r_int
id|phys
)paren
(brace
id|boot_infos_t
op_star
id|bi
op_assign
(paren
id|boot_infos_t
op_star
)paren
id|r4
suffix:semicolon
r_int
r_int
id|space
suffix:semicolon
r_int
r_int
id|ptr
comma
id|x
suffix:semicolon
r_char
op_star
id|model
suffix:semicolon
id|boot_infos
op_assign
id|PTRUNRELOC
c_func
(paren
id|bi
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|BOOT_INFO_IS_V2_COMPATIBLE
c_func
(paren
id|bi
)paren
)paren
id|bi-&gt;logicalDisplayBase
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_BOOTX_TEXT
id|btext_init
c_func
(paren
id|bi
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Test if boot-info is compatible.  Done only in config&n;&t; * CONFIG_BOOTX_TEXT since there is nothing much we can do&n;&t; * with an incompatible version, except display a message&n;&t; * and eventually hang the processor...&n;&t; *&n;&t; * I&squot;ll try to keep enough of boot-info compatible in the&n;&t; * future to always allow display of this message;&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|BOOT_INFO_IS_COMPATIBLE
c_func
(paren
id|bi
)paren
)paren
(brace
id|btext_drawstring
c_func
(paren
l_string|&quot; !!! WARNING - Incompatible version of BootX !!!&bslash;n&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|btext_flushscreen
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_BOOTX_TEXT */
multiline_comment|/* New BootX enters kernel with MMU off, i/os are not allowed&n;&t;   here. This hack will have been done by the boostrap anyway.&n;&t;*/
r_if
c_cond
(paren
id|bi-&gt;version
OL
l_int|4
)paren
(brace
multiline_comment|/*&n;&t;&t; * XXX If this is an iMac, turn off the USB controller.&n;&t;&t; */
id|model
op_assign
(paren
r_char
op_star
)paren
id|early_get_property
(paren
id|r4
op_plus
id|bi-&gt;deviceTreeOffset
comma
l_int|4
comma
l_string|&quot;model&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|model
op_logical_and
(paren
id|strcmp
c_func
(paren
id|model
comma
l_string|&quot;iMac,1&quot;
)paren
op_eq
l_int|0
op_logical_or
id|strcmp
c_func
(paren
id|model
comma
l_string|&quot;PowerMac1,1&quot;
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|out_le32
c_func
(paren
(paren
r_int
op_star
)paren
l_int|0x80880008
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* XXX */
)brace
)brace
multiline_comment|/* Move klimit to enclose device tree, args, ramdisk, etc... */
r_if
c_cond
(paren
id|bi-&gt;version
OL
l_int|5
)paren
(brace
id|space
op_assign
id|bi-&gt;deviceTreeOffset
op_plus
id|bi-&gt;deviceTreeSize
suffix:semicolon
r_if
c_cond
(paren
id|bi-&gt;ramDisk
)paren
id|space
op_assign
id|bi-&gt;ramDisk
op_plus
id|bi-&gt;ramDiskSize
suffix:semicolon
)brace
r_else
id|space
op_assign
id|bi-&gt;totalParamsSize
suffix:semicolon
id|klimit
op_assign
id|PTRUNRELOC
c_func
(paren
(paren
r_char
op_star
)paren
id|bi
op_plus
id|space
)paren
suffix:semicolon
multiline_comment|/* New BootX will have flushed all TLBs and enters kernel with&n;&t;   MMU switched OFF, so this should not be useful anymore.&n;&t;*/
r_if
c_cond
(paren
id|bi-&gt;version
OL
l_int|4
)paren
(brace
multiline_comment|/*&n;&t;&t; * Touch each page to make sure the PTEs for them&n;&t;&t; * are in the hash table - the aim is to try to avoid&n;&t;&t; * getting DSI exceptions while copying the kernel image.&n;&t;&t; */
r_for
c_loop
(paren
id|ptr
op_assign
(paren
(paren
r_int
r_int
)paren
op_amp
id|_stext
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
id|ptr
OL
(paren
r_int
r_int
)paren
id|bi
op_plus
id|space
suffix:semicolon
id|ptr
op_add_assign
id|PAGE_SIZE
)paren
id|x
op_assign
op_star
(paren
r_volatile
r_int
r_int
op_star
)paren
id|ptr
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BOOTX_TEXT
multiline_comment|/*&n;&t; * Note that after we call btext_prepare_BAT, we can&squot;t do&n;&t; * prom_draw*, flushscreen or clearscreen until we turn the MMU&n;&t; * on, since btext_prepare_BAT sets disp_bi.logicalDisplayBase&n;&t; * to a virtual address.&n;&t; */
id|btext_prepare_BAT
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
eof
