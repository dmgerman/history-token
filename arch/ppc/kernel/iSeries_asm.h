multiline_comment|/*&n; * arch/ppc/kernel/iSeries_asm.h&n; *&n; * Definitions used by various bits of low-level assembly code on iSeries.&n; *&n; * Copyright (C) 2001 IBM Corp.&n; *&n; *  This program is free software; you can redistribute it and/or&n; *  modify it under the terms of the GNU General Public License&n; *  as published by the Free Software Foundation; either version&n; *  2 of the License, or (at your option) any later version.&n; */
DECL|macro|CHECKLPQUEUE
mdefine_line|#define CHECKLPQUEUE(ra,rb,rc)         &bslash;&n;&t;mfspr   rb,SPRG1;       /* Get Paca address */&bslash;&n;&t;lbz ra,PACALPPACA+LPPACAIPIINT(rb); /* Get IPI int flag */&bslash;&n;&t;cmpi    0,ra,0;         /* IPI occurred in hypervisor ? */&bslash;&n;&t;bne 99f;            /* If so, skip rest */&bslash;&n;&t;lwz ra,PACALPQUEUE(rb); /* Get LpQueue address */&bslash;&n;&t;cmpi    0,ra,0;         /* Does LpQueue exist? */&bslash;&n;&t;beq 99f;            /* If not skip rest */&bslash;&n;&t;lbz rb,LPQINUSEWORD(ra);    /* Test for LpQueue recursion */&bslash;&n;&t;cmpi    0,rb,1;         /* If we are about to recurse */&bslash;&n;&t;beq 99f;            /* If so, skip rest */&bslash;&n;&t;lwz rb,LPQCUREVENTPTR(ra);  /* Get current LpEvent */&bslash;&n;&t;lbz rb,LPEVENTFLAGS(rb);    /* Get Valid bit */&bslash;&n;&t;lbz rc,LPQOVERFLOW(ra); /* Get LpQueue overflow */&bslash;&n;&t;andi.   ra,rb,0x0080;       /* Isolate Valid bit */&bslash;&n;&t;or. ra,ra,rc;       /* 0 == no pending events */&bslash;&n;99:
DECL|macro|CHECKDECR
mdefine_line|#define CHECKDECR(ra,rb)           &bslash;&n;&t;mfspr   rb,SPRG1;       /* Get Paca address */&bslash;&n;&t;lbz ra,PACALPPACA+LPPACADECRINT(rb); /* Get DECR int flag */&bslash;&n;&t;cmpi    0,ra,0;         /* DECR occurred in hypervisor ? */&bslash;&n;&t;beq 99f;            /* If not, skip rest */&bslash;&n;&t;xor ra,ra,ra;           &bslash;&n;&t;stb ra,PACALPPACA+LPPACADECRINT(rb); /* Clear DECR int flag */&bslash;&n;99:
DECL|macro|CHECKANYINT
mdefine_line|#define CHECKANYINT(ra,rb,rc)&t;&t;&t;&bslash;&n;&t;mfspr&t;rb,SPRG1;&t;&t;/* Get Paca address */&bslash;&n;&t;ld&t;ra,PACALPPACA+LPPACAANYINT(rb); /* Get all interrupt flags */&bslash;&n;&t;&t;&t;&t;&t;/* Note use of ld, protected by soft/hard disabled */&bslash;&n;&t;cmpldi&t;0,ra,0;&t;&t;&t;/* Any interrupt occurred while soft disabled? */&bslash;&n;&t;bne&t;99f;&t;&t;&t;/* If so, skip rest */&bslash;&n;&t;lwz&t;ra,PACALPQUEUE(rb);&t;/* Get LpQueue address */&bslash;&n;&t;cmpi&t;0,ra,0;&t;&t;&t;/* Does LpQueue exist? */&bslash;&n;&t;beq&t;99f;&t;&t;&t;/* If not skip rest */&bslash;&n;&t;lwz&t;rb,LPQINUSEWORD(ra);&t;/* Test for LpQueue recursion */&bslash;&n;&t;cmpi&t;0,rb,1;&t;&t;&t;/* If we are about to recurse */&bslash;&n;&t;beq&t;99f;&t;&t;&t;/* If so, skip rest */&bslash;&n;&t;lwz&t;rb,LPQCUREVENTPTR(ra);&t;/* Get current LpEvent */&bslash;&n;&t;lbz&t;rb,LPEVENTFLAGS(rb);&t;/* Get Valid bit */&bslash;&n;&t;lbz&t;rc,LPQOVERFLOW(ra);&t;/* Get LpQueue overflow */&bslash;&n;&t;andi.&t;ra,rb,0x0080;&t;&t;/* Isolate Valid bit */&bslash;&n;&t;or.&t;ra,ra,rc;&t;&t;/* 0 == no pending events */&bslash;&n;99:
eof
