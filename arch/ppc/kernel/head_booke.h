macro_line|#ifndef __HEAD_BOOKE_H__
DECL|macro|__HEAD_BOOKE_H__
mdefine_line|#define __HEAD_BOOKE_H__
multiline_comment|/*&n; * Macros used for common Book-e exception handling&n; */
DECL|macro|SET_IVOR
mdefine_line|#define SET_IVOR(vector_number, vector_label)&t;&t;&bslash;&n;&t;&t;li&t;r26,vector_label@l; &t;&t;&bslash;&n;&t;&t;mtspr&t;SPRN_IVOR##vector_number,r26;&t;&bslash;&n;&t;&t;sync
DECL|macro|NORMAL_EXCEPTION_PROLOG
mdefine_line|#define NORMAL_EXCEPTION_PROLOG&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mtspr&t;SPRN_SPRG0,r10;&t;&t;/* save two registers to work with */&bslash;&n;&t;mtspr&t;SPRN_SPRG1,r11;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mtspr&t;SPRN_SPRG4W,r1;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mfcr&t;r10;&t;&t;&t;/* save CR in r10 for now&t;   */&bslash;&n;&t;mfspr&t;r11,SPRN_SRR1;&t;&t;/* check whether user or kernel    */&bslash;&n;&t;andi.&t;r11,r11,MSR_PR;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;beq&t;1f;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r1,SPRN_SPRG3;&t;&t;/* if from user, start at top of   */&bslash;&n;&t;lwz&t;r1,THREAD_INFO-THREAD(r1); /* this thread&squot;s kernel stack   */&bslash;&n;&t;addi&t;r1,r1,THREAD_SIZE;&t;&t;&t;&t;&t;     &bslash;&n;1:&t;subi&t;r1,r1,INT_FRAME_SIZE;&t;/* Allocate an exception frame     */&bslash;&n;&t;mr&t;r11,r1;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,_CCR(r11);          /* save various registers&t;   */&bslash;&n;&t;stw&t;r12,GPR12(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r9,GPR9(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r10,SPRN_SPRG0;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,GPR10(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r12,SPRN_SPRG1;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r12,GPR11(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mflr&t;r10;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,_LINK(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r10,SPRN_SPRG4R;&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r12,SPRN_SRR0;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,GPR1(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r9,SPRN_SRR1;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,0(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;rlwinm&t;r9,r9,0,14,12;&t;&t;/* clear MSR_WE (necessary?)&t;   */&bslash;&n;&t;stw&t;r0,GPR0(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;SAVE_4GPRS(3, r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;SAVE_2GPRS(7, r11)
multiline_comment|/* To handle the additional exception priority levels on 40x and Book-E&n; * processors we allocate a 4k stack per additional priority level. The various&n; * head_xxx.S files allocate space (exception_stack_top) for each priority&squot;s&n; * stack times the number of CPUs&n; *&n; * On 40x critical is the only additional level&n; * On 44x/e500 we have critical and machine check&n; *&n; * Additionally we reserve a SPRG for each priority level so we can free up a&n; * GPR to use as the base for indirect access to the exception stacks.  This&n; * is necessary since the MMU is always on, for Book-E parts, and the stacks&n; * are offset from KERNELBASE.&n; *&n; */
DECL|macro|BOOKE_EXCEPTION_STACK_SIZE
mdefine_line|#define BOOKE_EXCEPTION_STACK_SIZE&t;(8192)
multiline_comment|/* CRIT_SPRG only used in critical exception handling */
DECL|macro|CRIT_SPRG
mdefine_line|#define CRIT_SPRG&t;SPRN_SPRG2
multiline_comment|/* MCHECK_SPRG only used in critical exception handling */
DECL|macro|MCHECK_SPRG
mdefine_line|#define MCHECK_SPRG&t;SPRN_SPRG6W
DECL|macro|MCHECK_STACK_TOP
mdefine_line|#define MCHECK_STACK_TOP&t;(exception_stack_top - 4096)
DECL|macro|CRIT_STACK_TOP
mdefine_line|#define CRIT_STACK_TOP&t;&t;(exception_stack_top)
macro_line|#ifdef CONFIG_SMP
DECL|macro|BOOKE_LOAD_CRIT_STACK
mdefine_line|#define BOOKE_LOAD_CRIT_STACK&t;&t;&t;&t;&bslash;&n;&t;mfspr&t;r8,SPRN_PIR;&t;&t;&t;&t;&bslash;&n;&t;mulli&t;r8,r8,BOOKE_EXCEPTION_STACK_SIZE;&t;&bslash;&n;&t;neg&t;r8,r8;&t;&t;&t;&t;&t;&bslash;&n;&t;addis&t;r8,r8,CRIT_STACK_TOP@ha;&t;&t;&bslash;&n;&t;addi&t;r8,r8,CRIT_STACK_TOP@l
DECL|macro|BOOKE_LOAD_MCHECK_STACK
mdefine_line|#define BOOKE_LOAD_MCHECK_STACK&t;&t;&t;&t;&bslash;&n;&t;mfspr&t;r8,SPRN_PIR;&t;&t;&t;&t;&bslash;&n;&t;mulli&t;r8,r8,BOOKE_EXCEPTION_STACK_SIZE;&t;&bslash;&n;&t;neg&t;r8,r8;&t;&t;&t;&t;&t;&bslash;&n;&t;addis&t;r8,r8,MCHECK_STACK_TOP@ha;&t;&t;&bslash;&n;&t;addi&t;r8,r8,MCHECK_STACK_TOP@l
macro_line|#else
DECL|macro|BOOKE_LOAD_CRIT_STACK
mdefine_line|#define BOOKE_LOAD_CRIT_STACK&t;&t;&t;&t;&bslash;&n;&t;lis&t;r8,CRIT_STACK_TOP@h;&t;&t;&t;&bslash;&n;&t;ori&t;r8,r8,CRIT_STACK_TOP@l
DECL|macro|BOOKE_LOAD_MCHECK_STACK
mdefine_line|#define BOOKE_LOAD_MCHECK_STACK&t;&t;&t;&t;&bslash;&n;&t;lis&t;r8,MCHECK_STACK_TOP@h;&t;&t;&t;&bslash;&n;&t;ori&t;r8,r8,MCHECK_STACK_TOP@l
macro_line|#endif
multiline_comment|/*&n; * Exception prolog for critical exceptions.  This is a little different&n; * from the normal exception prolog above since a critical exception&n; * can potentially occur at any point during normal exception processing.&n; * Thus we cannot use the same SPRG registers as the normal prolog above.&n; * Instead we use a portion of the critical exception stack at low physical&n; * addresses.&n; */
DECL|macro|CRITICAL_EXCEPTION_PROLOG
mdefine_line|#define CRITICAL_EXCEPTION_PROLOG&t;&t;&t;&t;&t;     &bslash;&n;&t;mtspr&t;CRIT_SPRG,r8;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;BOOKE_LOAD_CRIT_STACK;&t;&t;/* r8 points to the crit stack */    &bslash;&n;&t;stw&t;r10,GPR10-INT_FRAME_SIZE(r8);&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r11,GPR11-INT_FRAME_SIZE(r8);&t;&t;&t;&t;     &bslash;&n;&t;mfcr&t;r10;&t;&t;&t;/* save CR in r10 for now&t;   */&bslash;&n;&t;mfspr&t;r11,SPRN_CSRR1;&t;&t;/* check whether user or kernel    */&bslash;&n;&t;andi.&t;r11,r11,MSR_PR;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mr&t;r11,r8;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r8,CRIT_SPRG;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;beq&t;1f;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;/* COMING FROM USER MODE */&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r11,SPRN_SPRG3;&t;&t;/* if from user, start at top of   */&bslash;&n;&t;lwz&t;r11,THREAD_INFO-THREAD(r11); /* this thread&squot;s kernel stack */&bslash;&n;&t;addi&t;r11,r11,THREAD_SIZE;&t;&t;&t;&t;&t;     &bslash;&n;1:&t;subi&t;r11,r11,INT_FRAME_SIZE;&t;/* Allocate an exception frame     */&bslash;&n;&t;stw&t;r10,_CCR(r11);          /* save various registers&t;   */&bslash;&n;&t;stw&t;r12,GPR12(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r9,GPR9(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mflr&t;r10;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,_LINK(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r12,SPRN_DEAR;&t;&t;/* save DEAR and ESR in the frame  */&bslash;&n;&t;stw&t;r12,_DEAR(r11);&t;&t;/* since they may have had stuff   */&bslash;&n;&t;mfspr&t;r9,SPRN_ESR;&t;&t;/* in them at the point where the  */&bslash;&n;&t;stw&t;r9,_ESR(r11);&t;&t;/* exception was taken&t;&t;   */&bslash;&n;&t;mfspr&t;r12,SPRN_CSRR0;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r1,GPR1(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r9,SPRN_CSRR1;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r1,0(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mr&t;r1,r11;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;rlwinm&t;r9,r9,0,14,12;&t;&t;/* clear MSR_WE (necessary?)&t;   */&bslash;&n;&t;stw&t;r0,GPR0(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;SAVE_4GPRS(3, r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;SAVE_2GPRS(7, r11)
multiline_comment|/*&n; * Exception prolog for machine check exceptions.  This is similar to&n; * the critical exception prolog, except that machine check exceptions&n; * have their stack.&n; */
DECL|macro|MCHECK_EXCEPTION_PROLOG
mdefine_line|#define MCHECK_EXCEPTION_PROLOG&t;&t;&t;&t;&t;     &bslash;&n;&t;mtspr&t;MCHECK_SPRG,r8;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;BOOKE_LOAD_MCHECK_STACK;&t;/* r8 points to the mcheck stack   */&bslash;&n;&t;stw&t;r10,GPR10-INT_FRAME_SIZE(r8);&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r11,GPR11-INT_FRAME_SIZE(r8);&t;&t;&t;&t;     &bslash;&n;&t;mfcr&t;r10;&t;&t;&t;/* save CR in r10 for now&t;   */&bslash;&n;&t;mfspr&t;r11,SPRN_MCSRR1;&t;/* check whether user or kernel    */&bslash;&n;&t;andi.&t;r11,r11,MSR_PR;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mr&t;r11,r8;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r8,MCHECK_SPRG;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;beq&t;1f;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;/* COMING FROM USER MODE */&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r11,SPRN_SPRG3;&t;&t;/* if from user, start at top of   */&bslash;&n;&t;lwz&t;r11,THREAD_INFO-THREAD(r11); /* this thread&squot;s kernel stack */&bslash;&n;&t;addi&t;r11,r11,THREAD_SIZE;&t;&t;&t;&t;&t;     &bslash;&n;1:&t;subi&t;r11,r11,INT_FRAME_SIZE;&t;/* Allocate an exception frame     */&bslash;&n;&t;stw&t;r10,_CCR(r11);          /* save various registers&t;   */&bslash;&n;&t;stw&t;r12,GPR12(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r9,GPR9(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mflr&t;r10;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,_LINK(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r12,SPRN_DEAR;&t;&t;/* save DEAR and ESR in the frame  */&bslash;&n;&t;stw&t;r12,_DEAR(r11);&t;&t;/* since they may have had stuff   */&bslash;&n;&t;mfspr&t;r9,SPRN_ESR;&t;&t;/* in them at the point where the  */&bslash;&n;&t;stw&t;r9,_ESR(r11);&t;&t;/* exception was taken&t;&t;   */&bslash;&n;&t;mfspr&t;r12,SPRN_MCSRR0;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r1,GPR1(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r9,SPRN_MCSRR1;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r1,0(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mr&t;r1,r11;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;rlwinm&t;r9,r9,0,14,12;&t;&t;/* clear MSR_WE (necessary?)&t;   */&bslash;&n;&t;stw&t;r0,GPR0(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;SAVE_4GPRS(3, r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;SAVE_2GPRS(7, r11)
multiline_comment|/*&n; * Exception vectors.&n; */
DECL|macro|START_EXCEPTION
mdefine_line|#define&t;START_EXCEPTION(label)&t;&t;&t;&t;&t;&t;     &bslash;&n;        .align 5;              &t;&t;&t;&t;&t;&t;     &bslash;&n;label:
DECL|macro|FINISH_EXCEPTION
mdefine_line|#define FINISH_EXCEPTION(func)&t;&t;&t;&t;&t;&bslash;&n;&t;bl&t;transfer_to_handler_full;&t;&t;&t;&bslash;&n;&t;.long&t;func;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;.long&t;ret_from_except_full
DECL|macro|EXCEPTION
mdefine_line|#define EXCEPTION(n, label, hdlr, xfer)&t;&t;&t;&t;&bslash;&n;&t;START_EXCEPTION(label);&t;&t;&t;&t;&t;&bslash;&n;&t;NORMAL_EXCEPTION_PROLOG;&t;&t;&t;&t;&bslash;&n;&t;addi&t;r3,r1,STACK_FRAME_OVERHEAD;&t;&t;&t;&bslash;&n;&t;xfer(n, hdlr)
DECL|macro|CRITICAL_EXCEPTION
mdefine_line|#define CRITICAL_EXCEPTION(n, label, hdlr)&t;&t;&t;&bslash;&n;&t;START_EXCEPTION(label);&t;&t;&t;&t;&t;&bslash;&n;&t;CRITICAL_EXCEPTION_PROLOG;&t;&t;&t;&t;&bslash;&n;&t;addi&t;r3,r1,STACK_FRAME_OVERHEAD;&t;&t;&t;&bslash;&n;&t;EXC_XFER_TEMPLATE(hdlr, n+2, (MSR_KERNEL &amp; ~(MSR_ME|MSR_DE|MSR_CE)), &bslash;&n;&t;&t;&t;  NOCOPY, crit_transfer_to_handler, &bslash;&n;&t;&t;&t;  ret_from_crit_exc)
DECL|macro|MCHECK_EXCEPTION
mdefine_line|#define MCHECK_EXCEPTION(n, label, hdlr)&t;&t;&t;&bslash;&n;&t;START_EXCEPTION(label);&t;&t;&t;&t;&t;&bslash;&n;&t;MCHECK_EXCEPTION_PROLOG;&t;&t;&t;&t;&bslash;&n;&t;mfspr&t;r5,SPRN_ESR;&t;&t;&t;&t;&t;&bslash;&n;&t;stw&t;r5,_ESR(r11);&t;&t;&t;&t;&t;&bslash;&n;&t;addi&t;r3,r1,STACK_FRAME_OVERHEAD;&t;&t;&t;&bslash;&n;&t;EXC_XFER_TEMPLATE(hdlr, n+2, (MSR_KERNEL &amp; ~(MSR_ME|MSR_DE|MSR_CE)), &bslash;&n;&t;&t;&t;  NOCOPY, mcheck_transfer_to_handler,   &bslash;&n;&t;&t;&t;  ret_from_mcheck_exc)
DECL|macro|EXC_XFER_TEMPLATE
mdefine_line|#define EXC_XFER_TEMPLATE(hdlr, trap, msr, copyee, tfer, ret)&t;&bslash;&n;&t;li&t;r10,trap;&t;&t;&t;&t;&t;&bslash;&n;&t;stw&t;r10,TRAP(r11);&t;&t;&t;&t;&t;&bslash;&n;&t;lis&t;r10,msr@h;&t;&t;&t;&t;&t;&bslash;&n;&t;ori&t;r10,r10,msr@l;&t;&t;&t;&t;&t;&bslash;&n;&t;copyee(r10, r9);&t;&t;&t;&t;&t;&bslash;&n;&t;bl&t;tfer;&t;&t; &t;&t;&t;&t;&bslash;&n;&t;.long&t;hdlr;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;.long&t;ret
DECL|macro|COPY_EE
mdefine_line|#define COPY_EE(d, s)&t;&t;rlwimi d,s,0,16,16
DECL|macro|NOCOPY
mdefine_line|#define NOCOPY(d, s)
DECL|macro|EXC_XFER_STD
mdefine_line|#define EXC_XFER_STD(n, hdlr)&t;&t;&bslash;&n;&t;EXC_XFER_TEMPLATE(hdlr, n, MSR_KERNEL, NOCOPY, transfer_to_handler_full, &bslash;&n;&t;&t;&t;  ret_from_except_full)
DECL|macro|EXC_XFER_LITE
mdefine_line|#define EXC_XFER_LITE(n, hdlr)&t;&t;&bslash;&n;&t;EXC_XFER_TEMPLATE(hdlr, n+1, MSR_KERNEL, NOCOPY, transfer_to_handler, &bslash;&n;&t;&t;&t;  ret_from_except)
DECL|macro|EXC_XFER_EE
mdefine_line|#define EXC_XFER_EE(n, hdlr)&t;&t;&bslash;&n;&t;EXC_XFER_TEMPLATE(hdlr, n, MSR_KERNEL, COPY_EE, transfer_to_handler_full, &bslash;&n;&t;&t;&t;  ret_from_except_full)
DECL|macro|EXC_XFER_EE_LITE
mdefine_line|#define EXC_XFER_EE_LITE(n, hdlr)&t;&bslash;&n;&t;EXC_XFER_TEMPLATE(hdlr, n+1, MSR_KERNEL, COPY_EE, transfer_to_handler, &bslash;&n;&t;&t;&t;  ret_from_except)
multiline_comment|/* Check for a single step debug exception while in an exception&n; * handler before state has been saved.  This is to catch the case&n; * where an instruction that we are trying to single step causes&n; * an exception (eg ITLB/DTLB miss) and thus the first instruction of&n; * the exception handler generates a single step debug exception.&n; *&n; * If we get a debug trap on the first instruction of an exception handler,&n; * we reset the MSR_DE in the _exception handler&squot;s_ MSR (the debug trap is&n; * a critical exception, so we are using SPRN_CSRR1 to manipulate the MSR).&n; * The exception handler was handling a non-critical interrupt, so it will&n; * save (and later restore) the MSR via SPRN_CSRR1, which will still have&n; * the MSR_DE bit set.&n; */
DECL|macro|DEBUG_EXCEPTION
mdefine_line|#define DEBUG_EXCEPTION&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;START_EXCEPTION(Debug);&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;CRITICAL_EXCEPTION_PROLOG;&t;&t;&t;&t;&t;      &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;/*&t;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t; * If there is a single step or branch-taken exception in an&t;      &bslash;&n;&t; * exception entry sequence, it was probably meant to apply to&t;      &bslash;&n;&t; * the code where the exception occurred (since exception entry&t;      &bslash;&n;&t; * doesn&squot;t turn off DE automatically).  We simulate the effect&t;      &bslash;&n;&t; * of turning off DE on entry to an exception handler by turning      &bslash;&n;&t; * off DE in the CSRR1 value and clearing the debug status.&t;      &bslash;&n;&t; */&t;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;mfspr&t;r10,SPRN_DBSR;&t;&t;/* check single-step/branch taken */  &bslash;&n;&t;andis.&t;r10,r10,DBSR_IC@h;&t;&t;&t;&t;&t;      &bslash;&n;&t;beq+&t;2f;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;lis&t;r10,KERNELBASE@h;&t;/* check if exception in vectors */   &bslash;&n;&t;ori&t;r10,r10,KERNELBASE@l;&t;&t;&t;&t;&t;      &bslash;&n;&t;cmplw&t;r12,r10;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;blt+&t;2f;&t;&t;&t;/* addr below exception vectors */    &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;lis&t;r10,Debug@h;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;ori&t;r10,r10,Debug@l;&t;&t;&t;&t;&t;      &bslash;&n;&t;cmplw&t;r12,r10;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;bgt+&t;2f;&t;&t;&t;/* addr above exception vectors */    &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;/* here it looks like we got an inappropriate debug exception. */     &bslash;&n;1:&t;rlwinm&t;r9,r9,0,~MSR_DE;&t;/* clear DE in the CSRR1 value */     &bslash;&n;&t;lis&t;r10,DBSR_IC@h;&t;&t;/* clear the IC event */&t;      &bslash;&n;&t;mtspr&t;SPRN_DBSR,r10;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;/* restore state and get out */&t;&t;&t;&t;&t;      &bslash;&n;&t;lwz&t;r10,_CCR(r11);&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;lwz&t;r0,GPR0(r11);&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;lwz&t;r1,GPR1(r11);&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;mtcrf&t;0x80,r10;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;mtspr&t;SPRN_CSRR0,r12;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;mtspr&t;SPRN_CSRR1,r9;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;lwz&t;r9,GPR9(r11);&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;lwz&t;r12,GPR12(r11);&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;mtspr&t;CRIT_SPRG,r8;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;BOOKE_LOAD_CRIT_STACK;&t;&t;/* r8 points to the crit stack */     &bslash;&n;&t;lwz&t;r10,GPR10-INT_FRAME_SIZE(r8);&t;&t;&t;&t;      &bslash;&n;&t;lwz&t;r11,GPR11-INT_FRAME_SIZE(r8);&t;&t;&t;&t;      &bslash;&n;&t;mfspr&t;r8,CRIT_SPRG;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;rfci;&t;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;b&t;.;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;/* continue normal handling for a critical exception... */&t;      &bslash;&n;2:&t;mfspr&t;r4,SPRN_DBSR;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;addi&t;r3,r1,STACK_FRAME_OVERHEAD;&t;&t;&t;&t;      &bslash;&n;&t;EXC_XFER_TEMPLATE(DebugException, 0x2002, (MSR_KERNEL &amp; ~(MSR_ME|MSR_DE|MSR_CE)), NOCOPY, crit_transfer_to_handler, ret_from_crit_exc)
DECL|macro|INSTRUCTION_STORAGE_EXCEPTION
mdefine_line|#define INSTRUCTION_STORAGE_EXCEPTION&t;&t;&t;&t;&t;      &bslash;&n;&t;START_EXCEPTION(InstructionStorage)&t;&t;&t;&t;      &bslash;&n;&t;NORMAL_EXCEPTION_PROLOG;&t;&t;&t;&t;&t;      &bslash;&n;&t;mfspr&t;r5,SPRN_ESR;&t;&t;/* Grab the ESR and save it */&t;      &bslash;&n;&t;stw&t;r5,_ESR(r11);&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;mr      r4,r12;                 /* Pass SRR0 as arg2 */&t;&t;      &bslash;&n;&t;li      r5,0;                   /* Pass zero as arg3 */&t;&t;      &bslash;&n;&t;EXC_XFER_EE_LITE(0x0400, handle_page_fault)
DECL|macro|ALIGNMENT_EXCEPTION
mdefine_line|#define ALIGNMENT_EXCEPTION&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;START_EXCEPTION(Alignment)&t;&t;&t;&t;&t;      &bslash;&n;&t;NORMAL_EXCEPTION_PROLOG;&t;&t;&t;&t;&t;      &bslash;&n;&t;mfspr   r4,SPRN_DEAR;           /* Grab the DEAR and save it */&t;      &bslash;&n;&t;stw     r4,_DEAR(r11);&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;addi    r3,r1,STACK_FRAME_OVERHEAD;&t;&t;&t;&t;      &bslash;&n;&t;EXC_XFER_EE(0x0600, AlignmentException)
DECL|macro|PROGRAM_EXCEPTION
mdefine_line|#define PROGRAM_EXCEPTION&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;START_EXCEPTION(Program)&t;&t;&t;&t;&t;      &bslash;&n;&t;NORMAL_EXCEPTION_PROLOG;&t;&t;&t;&t;&t;      &bslash;&n;&t;mfspr&t;r4,SPRN_ESR;&t;&t;/* Grab the ESR and save it */&t;      &bslash;&n;&t;stw&t;r4,_ESR(r11);&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;addi&t;r3,r1,STACK_FRAME_OVERHEAD;&t;&t;&t;&t;      &bslash;&n;&t;EXC_XFER_STD(0x0700, ProgramCheckException)
DECL|macro|DECREMENTER_EXCEPTION
mdefine_line|#define DECREMENTER_EXCEPTION&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;START_EXCEPTION(Decrementer)&t;&t;&t;&t;&t;      &bslash;&n;&t;NORMAL_EXCEPTION_PROLOG;&t;&t;&t;&t;&t;      &bslash;&n;&t;lis     r0,TSR_DIS@h;           /* Setup the DEC interrupt mask */    &bslash;&n;&t;mtspr   SPRN_TSR,r0;&t;&t;/* Clear the DEC interrupt */&t;      &bslash;&n;&t;addi    r3,r1,STACK_FRAME_OVERHEAD;&t;&t;&t;&t;      &bslash;&n;&t;EXC_XFER_LITE(0x0900, timer_interrupt)
macro_line|#endif /* __HEAD_BOOKE_H__ */
eof
