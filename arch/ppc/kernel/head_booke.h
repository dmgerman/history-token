macro_line|#ifndef __HEAD_BOOKE_H__
DECL|macro|__HEAD_BOOKE_H__
mdefine_line|#define __HEAD_BOOKE_H__
multiline_comment|/*&n; * Macros used for common Book-e exception handling&n; */
DECL|macro|SET_IVOR
mdefine_line|#define SET_IVOR(vector_number, vector_label)&t;&t;&bslash;&n;&t;&t;li&t;r26,vector_label@l; &t;&t;&bslash;&n;&t;&t;mtspr&t;SPRN_IVOR##vector_number,r26;&t;&bslash;&n;&t;&t;sync
DECL|macro|NORMAL_EXCEPTION_PROLOG
mdefine_line|#define NORMAL_EXCEPTION_PROLOG&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mtspr&t;SPRN_SPRG0,r10;&t;&t;/* save two registers to work with */&bslash;&n;&t;mtspr&t;SPRN_SPRG1,r11;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mtspr&t;SPRN_SPRG4W,r1;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mfcr&t;r10;&t;&t;&t;/* save CR in r10 for now&t;   */&bslash;&n;&t;mfspr&t;r11,SPRN_SRR1;&t;&t;/* check whether user or kernel    */&bslash;&n;&t;andi.&t;r11,r11,MSR_PR;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;beq&t;1f;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r1,SPRG3;&t;&t;/* if from user, start at top of   */&bslash;&n;&t;lwz&t;r1,THREAD_INFO-THREAD(r1); /* this thread&squot;s kernel stack   */&bslash;&n;&t;addi&t;r1,r1,THREAD_SIZE;&t;&t;&t;&t;&t;     &bslash;&n;1:&t;subi&t;r1,r1,INT_FRAME_SIZE;&t;/* Allocate an exception frame     */&bslash;&n;&t;tophys(r11,r1);&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,_CCR(r11);          /* save various registers&t;   */&bslash;&n;&t;stw&t;r12,GPR12(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r9,GPR9(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r10,SPRG0;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,GPR10(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r12,SPRG1;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r12,GPR11(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mflr&t;r10;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,_LINK(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r10,SPRG4R;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r12,SRR0;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,GPR1(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r9,SRR1;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,0(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;rlwinm&t;r9,r9,0,14,12;&t;&t;/* clear MSR_WE (necessary?)&t;   */&bslash;&n;&t;stw&t;r0,GPR0(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;SAVE_4GPRS(3, r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;SAVE_2GPRS(7, r11)
multiline_comment|/*&n; * Exception prolog for critical exceptions.  This is a little different&n; * from the normal exception prolog above since a critical exception&n; * can potentially occur at any point during normal exception processing.&n; * Thus we cannot use the same SPRG registers as the normal prolog above.&n; * Instead we use a couple of words of memory at low physical addresses.&n; * This is OK since we don&squot;t support SMP on these processors. For Book E&n; * processors, we also have a reserved register (SPRG2) that is only used&n; * in critical exceptions so we can free up a GPR to use as the base for&n; * indirect access to the critical exception save area.  This is necessary&n; * since the MMU is always on and the save area is offset from KERNELBASE.&n; */
DECL|macro|CRITICAL_EXCEPTION_PROLOG
mdefine_line|#define CRITICAL_EXCEPTION_PROLOG&t;&t;&t;&t;&t;     &bslash;&n;&t;mtspr&t;SPRG2,r8;&t;&t;/* SPRG2 only used in criticals */   &bslash;&n;&t;lis&t;r8,crit_save@ha;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,crit_r10@l(r8);&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r11,crit_r11@l(r8);&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r10,SPRG0;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,crit_sprg0@l(r8);&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r10,SPRG1;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,crit_sprg1@l(r8);&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r10,SPRG4R;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,crit_sprg4@l(r8);&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r10,SPRG5R;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,crit_sprg5@l(r8);&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r10,SPRG7R;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,crit_sprg7@l(r8);&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r10,SPRN_PID;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,crit_pid@l(r8);&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r10,SRR0;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,crit_srr0@l(r8);&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r10,SRR1;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,crit_srr1@l(r8);&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r8,SPRG2;&t;&t;/* SPRG2 only used in criticals */   &bslash;&n;&t;mfcr&t;r10;&t;&t;&t;/* save CR in r10 for now&t;   */&bslash;&n;&t;mfspr&t;r11,SPRN_CSRR1;&t;&t;/* check whether user or kernel    */&bslash;&n;&t;andi.&t;r11,r11,MSR_PR;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;lis&t;r11,critical_stack_top@h;&t;&t;&t;&t;     &bslash;&n;&t;ori&t;r11,r11,critical_stack_top@l;&t;&t;&t;&t;     &bslash;&n;&t;beq&t;1f;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;/* COMING FROM USER MODE */&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r11,SPRG3;&t;&t;/* if from user, start at top of   */&bslash;&n;&t;lwz&t;r11,THREAD_INFO-THREAD(r11); /* this thread&squot;s kernel stack */&bslash;&n;&t;addi&t;r11,r11,THREAD_SIZE;&t;&t;&t;&t;&t;     &bslash;&n;1:&t;subi&t;r11,r11,INT_FRAME_SIZE;&t;/* Allocate an exception frame     */&bslash;&n;&t;stw&t;r10,_CCR(r11);          /* save various registers&t;   */&bslash;&n;&t;stw&t;r12,GPR12(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r9,GPR9(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mflr&t;r10;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,_LINK(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r12,SPRN_DEAR;&t;&t;/* save DEAR and ESR in the frame  */&bslash;&n;&t;stw&t;r12,_DEAR(r11);&t;&t;/* since they may have had stuff   */&bslash;&n;&t;mfspr&t;r9,SPRN_ESR;&t;&t;/* in them at the point where the  */&bslash;&n;&t;stw&t;r9,_ESR(r11);&t;&t;/* exception was taken&t;&t;   */&bslash;&n;&t;mfspr&t;r12,CSRR0;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r1,GPR1(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r9,CSRR1;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r1,0(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;tovirt(r1,r11);&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;rlwinm&t;r9,r9,0,14,12;&t;&t;/* clear MSR_WE (necessary?)&t;   */&bslash;&n;&t;stw&t;r0,GPR0(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;SAVE_4GPRS(3, r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;SAVE_2GPRS(7, r11)
multiline_comment|/*&n; * Exception prolog for machine check exceptions.  This is similar to&n; * the critical exception prolog, except that machine check exceptions&n; * have their own save area.  For Book E processors, we also have a&n; * reserved register (SPRG6) that is only used in machine check exceptions&n; * so we can free up a GPR to use as the base for indirect access to the&n; * machine check exception save area.  This is necessary since the MMU&n; * is always on and the save area is offset from KERNELBASE.&n; */
DECL|macro|MCHECK_EXCEPTION_PROLOG
mdefine_line|#define MCHECK_EXCEPTION_PROLOG&t;&t;&t;&t;&t;     &bslash;&n;&t;mtspr&t;SPRG6W,r8;&t;&t;/* SPRG6 used in machine checks */   &bslash;&n;&t;lis&t;r8,mcheck_save@ha;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,mcheck_r10@l(r8);&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r11,mcheck_r11@l(r8);&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r10,SPRG0;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,mcheck_sprg0@l(r8);&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r10,SPRG1;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,mcheck_sprg1@l(r8);&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r10,SPRG4R;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,mcheck_sprg4@l(r8);&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r10,SPRG5R;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,mcheck_sprg5@l(r8);&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r10,SPRG7R;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,mcheck_sprg7@l(r8);&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r10,SPRN_PID;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,mcheck_pid@l(r8);&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r10,SRR0;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,mcheck_srr0@l(r8);&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r10,SRR1;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,mcheck_srr1@l(r8);&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r10,CSRR0;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,mcheck_csrr0@l(r8);&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r10,CSRR1;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,mcheck_csrr1@l(r8);&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r8,SPRG6R;&t;&t;/* SPRG6 used in machine checks */   &bslash;&n;&t;mfcr&t;r10;&t;&t;&t;/* save CR in r10 for now&t;   */&bslash;&n;&t;mfspr&t;r11,SPRN_MCSRR1;&t;/* check whether user or kernel    */&bslash;&n;&t;andi.&t;r11,r11,MSR_PR;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;lis&t;r11,mcheck_stack_top@h;&t;&t;&t;&t;&t;     &bslash;&n;&t;ori&t;r11,r11,mcheck_stack_top@l;&t;&t;&t;&t;     &bslash;&n;&t;beq&t;1f;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;/* COMING FROM USER MODE */&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r11,SPRG3;&t;&t;/* if from user, start at top of   */&bslash;&n;&t;lwz&t;r11,THREAD_INFO-THREAD(r11); /* this thread&squot;s kernel stack */&bslash;&n;&t;addi&t;r11,r11,THREAD_SIZE;&t;&t;&t;&t;&t;     &bslash;&n;1:&t;subi&t;r11,r11,INT_FRAME_SIZE;&t;/* Allocate an exception frame     */&bslash;&n;&t;stw&t;r10,_CCR(r11);          /* save various registers&t;   */&bslash;&n;&t;stw&t;r12,GPR12(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r9,GPR9(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mflr&t;r10;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r10,_LINK(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r12,SPRN_DEAR;&t;&t;/* save DEAR and ESR in the frame  */&bslash;&n;&t;stw&t;r12,_DEAR(r11);&t;&t;/* since they may have had stuff   */&bslash;&n;&t;mfspr&t;r9,SPRN_ESR;&t;&t;/* in them at the point where the  */&bslash;&n;&t;stw&t;r9,_ESR(r11);&t;&t;/* exception was taken&t;&t;   */&bslash;&n;&t;mfspr&t;r12,MCSRR0;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r1,GPR1(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;mfspr&t;r9,MCSRR1;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;stw&t;r1,0(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;tovirt(r1,r11);&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;rlwinm&t;r9,r9,0,14,12;&t;&t;/* clear MSR_WE (necessary?)&t;   */&bslash;&n;&t;stw&t;r0,GPR0(r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;SAVE_4GPRS(3, r11);&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;SAVE_2GPRS(7, r11)
multiline_comment|/*&n; * Exception vectors.&n; */
DECL|macro|START_EXCEPTION
mdefine_line|#define&t;START_EXCEPTION(label)&t;&t;&t;&t;&t;&t;     &bslash;&n;        .align 5;              &t;&t;&t;&t;&t;&t;     &bslash;&n;label:
DECL|macro|FINISH_EXCEPTION
mdefine_line|#define FINISH_EXCEPTION(func)&t;&t;&t;&t;&t;&bslash;&n;&t;bl&t;transfer_to_handler_full;&t;&t;&t;&bslash;&n;&t;.long&t;func;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;.long&t;ret_from_except_full
DECL|macro|EXCEPTION
mdefine_line|#define EXCEPTION(n, label, hdlr, xfer)&t;&t;&t;&t;&bslash;&n;&t;START_EXCEPTION(label);&t;&t;&t;&t;&t;&bslash;&n;&t;NORMAL_EXCEPTION_PROLOG;&t;&t;&t;&t;&bslash;&n;&t;addi&t;r3,r1,STACK_FRAME_OVERHEAD;&t;&t;&t;&bslash;&n;&t;xfer(n, hdlr)
DECL|macro|CRITICAL_EXCEPTION
mdefine_line|#define CRITICAL_EXCEPTION(n, label, hdlr)&t;&t;&t;&bslash;&n;&t;START_EXCEPTION(label);&t;&t;&t;&t;&t;&bslash;&n;&t;CRITICAL_EXCEPTION_PROLOG;&t;&t;&t;&t;&bslash;&n;&t;addi&t;r3,r1,STACK_FRAME_OVERHEAD;&t;&t;&t;&bslash;&n;&t;EXC_XFER_TEMPLATE(hdlr, n+2, (MSR_KERNEL &amp; ~(MSR_ME|MSR_DE|MSR_CE)), &bslash;&n;&t;&t;&t;  NOCOPY, crit_transfer_to_handler, &bslash;&n;&t;&t;&t;  ret_from_crit_exc)
DECL|macro|MCHECK_EXCEPTION
mdefine_line|#define MCHECK_EXCEPTION(n, label, hdlr)&t;&t;&t;&bslash;&n;&t;START_EXCEPTION(label);&t;&t;&t;&t;&t;&bslash;&n;&t;MCHECK_EXCEPTION_PROLOG;&t;&t;&t;&t;&bslash;&n;&t;mfspr&t;r5,SPRN_ESR;&t;&t;&t;&t;&t;&bslash;&n;&t;stw&t;r5,_ESR(r11);&t;&t;&t;&t;&t;&bslash;&n;&t;addi&t;r3,r1,STACK_FRAME_OVERHEAD;&t;&t;&t;&bslash;&n;&t;EXC_XFER_TEMPLATE(hdlr, n+2, (MSR_KERNEL &amp; ~(MSR_ME|MSR_DE|MSR_CE)), &bslash;&n;&t;&t;&t;  NOCOPY, mcheck_transfer_to_handler,   &bslash;&n;&t;&t;&t;  ret_from_mcheck_exc)
DECL|macro|EXC_XFER_TEMPLATE
mdefine_line|#define EXC_XFER_TEMPLATE(hdlr, trap, msr, copyee, tfer, ret)&t;&bslash;&n;&t;li&t;r10,trap;&t;&t;&t;&t;&t;&bslash;&n;&t;stw&t;r10,TRAP(r11);&t;&t;&t;&t;&t;&bslash;&n;&t;lis&t;r10,msr@h;&t;&t;&t;&t;&t;&bslash;&n;&t;ori&t;r10,r10,msr@l;&t;&t;&t;&t;&t;&bslash;&n;&t;copyee(r10, r9);&t;&t;&t;&t;&t;&bslash;&n;&t;bl&t;tfer;&t;&t; &t;&t;&t;&t;&bslash;&n;&t;.long&t;hdlr;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;.long&t;ret
DECL|macro|COPY_EE
mdefine_line|#define COPY_EE(d, s)&t;&t;rlwimi d,s,0,16,16
DECL|macro|NOCOPY
mdefine_line|#define NOCOPY(d, s)
DECL|macro|EXC_XFER_STD
mdefine_line|#define EXC_XFER_STD(n, hdlr)&t;&t;&bslash;&n;&t;EXC_XFER_TEMPLATE(hdlr, n, MSR_KERNEL, NOCOPY, transfer_to_handler_full, &bslash;&n;&t;&t;&t;  ret_from_except_full)
DECL|macro|EXC_XFER_LITE
mdefine_line|#define EXC_XFER_LITE(n, hdlr)&t;&t;&bslash;&n;&t;EXC_XFER_TEMPLATE(hdlr, n+1, MSR_KERNEL, NOCOPY, transfer_to_handler, &bslash;&n;&t;&t;&t;  ret_from_except)
DECL|macro|EXC_XFER_EE
mdefine_line|#define EXC_XFER_EE(n, hdlr)&t;&t;&bslash;&n;&t;EXC_XFER_TEMPLATE(hdlr, n, MSR_KERNEL, COPY_EE, transfer_to_handler_full, &bslash;&n;&t;&t;&t;  ret_from_except_full)
DECL|macro|EXC_XFER_EE_LITE
mdefine_line|#define EXC_XFER_EE_LITE(n, hdlr)&t;&bslash;&n;&t;EXC_XFER_TEMPLATE(hdlr, n+1, MSR_KERNEL, COPY_EE, transfer_to_handler, &bslash;&n;&t;&t;&t;  ret_from_except)
multiline_comment|/* Check for a single step debug exception while in an exception&n; * handler before state has been saved.  This is to catch the case&n; * where an instruction that we are trying to single step causes&n; * an exception (eg ITLB/DTLB miss) and thus the first instruction of&n; * the exception handler generates a single step debug exception.&n; *&n; * If we get a debug trap on the first instruction of an exception handler,&n; * we reset the MSR_DE in the _exception handler&squot;s_ MSR (the debug trap is&n; * a critical exception, so we are using SPRN_CSRR1 to manipulate the MSR).&n; * The exception handler was handling a non-critical interrupt, so it will&n; * save (and later restore) the MSR via SPRN_CSRR1, which will still have&n; * the MSR_DE bit set.&n; */
DECL|macro|DEBUG_EXCEPTION
mdefine_line|#define DEBUG_EXCEPTION&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;START_EXCEPTION(Debug);&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;CRITICAL_EXCEPTION_PROLOG;&t;&t;&t;&t;&t;      &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;/*&t;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t; * If there is a single step or branch-taken exception in an&t;      &bslash;&n;&t; * exception entry sequence, it was probably meant to apply to&t;      &bslash;&n;&t; * the code where the exception occurred (since exception entry&t;      &bslash;&n;&t; * doesn&squot;t turn off DE automatically).  We simulate the effect&t;      &bslash;&n;&t; * of turning off DE on entry to an exception handler by turning      &bslash;&n;&t; * off DE in the CSRR1 value and clearing the debug status.&t;      &bslash;&n;&t; */&t;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;mfspr&t;r10,SPRN_DBSR;&t;&t;/* check single-step/branch taken */  &bslash;&n;&t;andis.&t;r10,r10,DBSR_IC@h;&t;&t;&t;&t;&t;      &bslash;&n;&t;beq+&t;2f;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;lis&t;r10,KERNELBASE@h;&t;/* check if exception in vectors */   &bslash;&n;&t;ori&t;r10,r10,KERNELBASE@l;&t;&t;&t;&t;&t;      &bslash;&n;&t;cmplw&t;r12,r10;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;blt+&t;2f;&t;&t;&t;/* addr below exception vectors */    &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;lis&t;r10,Debug@h;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;ori&t;r10,r10,Debug@l;&t;&t;&t;&t;&t;      &bslash;&n;&t;cmplw&t;r12,r10;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;bgt+&t;2f;&t;&t;&t;/* addr above exception vectors */    &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;/* here it looks like we got an inappropriate debug exception. */     &bslash;&n;1:&t;rlwinm&t;r9,r9,0,~MSR_DE;&t;/* clear DE in the CSRR1 value */     &bslash;&n;&t;lis&t;r10,DBSR_IC@h;&t;&t;/* clear the IC event */&t;      &bslash;&n;&t;mtspr&t;SPRN_DBSR,r10;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;/* restore state and get out */&t;&t;&t;&t;&t;      &bslash;&n;&t;lwz&t;r10,_CCR(r11);&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;lwz&t;r0,GPR0(r11);&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;lwz&t;r1,GPR1(r11);&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;mtcrf&t;0x80,r10;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;mtspr&t;CSRR0,r12;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;mtspr&t;CSRR1,r9;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;lwz&t;r9,GPR9(r11);&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;lwz&t;r12,GPR12(r11);&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;mtspr&t;SPRG2,r8;&t;&t;/* SPRG2 only used in criticals */    &bslash;&n;&t;lis&t;r8,crit_save@ha;&t;&t;&t;&t;&t;      &bslash;&n;&t;lwz&t;r10,crit_r10@l(r8);&t;&t;&t;&t;&t;      &bslash;&n;&t;lwz&t;r11,crit_r11@l(r8);&t;&t;&t;&t;&t;      &bslash;&n;&t;mfspr&t;r8,SPRG2;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;rfci;&t;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;b&t;.;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;/* continue normal handling for a critical exception... */&t;      &bslash;&n;2:&t;mfspr&t;r4,SPRN_DBSR;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;addi&t;r3,r1,STACK_FRAME_OVERHEAD;&t;&t;&t;&t;      &bslash;&n;&t;EXC_XFER_TEMPLATE(DebugException, 0x2002, (MSR_KERNEL &amp; ~(MSR_ME|MSR_DE|MSR_CE)), NOCOPY, crit_transfer_to_handler, ret_from_crit_exc)
DECL|macro|INSTRUCTION_STORAGE_EXCEPTION
mdefine_line|#define INSTRUCTION_STORAGE_EXCEPTION&t;&t;&t;&t;&t;      &bslash;&n;&t;START_EXCEPTION(InstructionStorage)&t;&t;&t;&t;      &bslash;&n;&t;NORMAL_EXCEPTION_PROLOG;&t;&t;&t;&t;&t;      &bslash;&n;&t;mfspr&t;r5,SPRN_ESR;&t;&t;/* Grab the ESR and save it */&t;      &bslash;&n;&t;stw&t;r5,_ESR(r11);&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;mr      r4,r12;                 /* Pass SRR0 as arg2 */&t;&t;      &bslash;&n;&t;li      r5,0;                   /* Pass zero as arg3 */&t;&t;      &bslash;&n;&t;EXC_XFER_EE_LITE(0x0400, handle_page_fault)
DECL|macro|ALIGNMENT_EXCEPTION
mdefine_line|#define ALIGNMENT_EXCEPTION&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;START_EXCEPTION(Alignment)&t;&t;&t;&t;&t;      &bslash;&n;&t;NORMAL_EXCEPTION_PROLOG;&t;&t;&t;&t;&t;      &bslash;&n;&t;mfspr   r4,SPRN_DEAR;           /* Grab the DEAR and save it */&t;      &bslash;&n;&t;stw     r4,_DEAR(r11);&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;addi    r3,r1,STACK_FRAME_OVERHEAD;&t;&t;&t;&t;      &bslash;&n;&t;EXC_XFER_EE(0x0600, AlignmentException)
DECL|macro|PROGRAM_EXCEPTION
mdefine_line|#define PROGRAM_EXCEPTION&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;START_EXCEPTION(Program)&t;&t;&t;&t;&t;      &bslash;&n;&t;NORMAL_EXCEPTION_PROLOG;&t;&t;&t;&t;&t;      &bslash;&n;&t;mfspr&t;r4,SPRN_ESR;&t;&t;/* Grab the ESR and save it */&t;      &bslash;&n;&t;stw&t;r4,_ESR(r11);&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;addi&t;r3,r1,STACK_FRAME_OVERHEAD;&t;&t;&t;&t;      &bslash;&n;&t;EXC_XFER_STD(0x0700, ProgramCheckException)
DECL|macro|DECREMENTER_EXCEPTION
mdefine_line|#define DECREMENTER_EXCEPTION&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;START_EXCEPTION(Decrementer)&t;&t;&t;&t;&t;      &bslash;&n;&t;NORMAL_EXCEPTION_PROLOG;&t;&t;&t;&t;&t;      &bslash;&n;&t;lis     r0,TSR_DIS@h;           /* Setup the DEC interrupt mask */    &bslash;&n;&t;mtspr   SPRN_TSR,r0;&t;&t;/* Clear the DEC interrupt */&t;      &bslash;&n;&t;addi    r3,r1,STACK_FRAME_OVERHEAD;&t;&t;&t;&t;      &bslash;&n;&t;EXC_XFER_LITE(0x0900, timer_interrupt)
macro_line|#endif /* __HEAD_BOOKE_H__ */
eof
