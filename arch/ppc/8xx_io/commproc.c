multiline_comment|/*&n; * General Purpose functions for the global management of the&n; * Communication Processor Module.&n; * Copyright (c) 1997 Dan Malek (dmalek@jlc.net)&n; *&n; * In addition to the individual control of the communication&n; * channels, there are a few functions that globally affect the&n; * communication processor.&n; *&n; * Buffer descriptors must be allocated from the dual ported memory&n; * space.  The allocator for that is here.  When the communication&n; * process is reset, we reclaim the memory available.  There is&n; * currently no deallocator for this memory.&n; * The amount of space available is platform dependent.  On the&n; * MBX, the EPPC software loads additional microcode into the&n; * communication processor, and uses some of the DP ram for this&n; * purpose.  Current, the first 512 bytes and the last 256 bytes of&n; * memory are used.  Right now I am conservative and only use the&n; * memory that can never be used for microcode.  If there are&n; * applications that require more DP ram, we can expand the boundaries&n; * but then we have to be careful of any downloaded microcode.&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/dma-mapping.h&gt;
macro_line|#include &lt;linux/param.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/mpc8xx.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/8xx_immap.h&gt;
macro_line|#include &lt;asm/commproc.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/tlbflush.h&gt;
macro_line|#include &lt;asm/rheap.h&gt;
r_extern
r_int
id|get_pteptr
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|addr
comma
id|pte_t
op_star
op_star
id|ptep
)paren
suffix:semicolon
r_static
r_void
id|m8xx_cpm_dpinit
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|host_buffer
r_static
id|uint
id|host_buffer
suffix:semicolon
multiline_comment|/* One page of host buffer */
DECL|variable|host_end
r_static
id|uint
id|host_end
suffix:semicolon
multiline_comment|/* end + 1 */
DECL|variable|cpmp
id|cpm8xx_t
op_star
id|cpmp
suffix:semicolon
multiline_comment|/* Pointer to comm processor space */
multiline_comment|/* CPM interrupt vector functions.&n;*/
DECL|struct|cpm_action
r_struct
id|cpm_action
(brace
DECL|member|handler
r_void
(paren
op_star
id|handler
)paren
(paren
r_void
op_star
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|member|dev_id
r_void
op_star
id|dev_id
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|cpm_vecs
r_static
r_struct
id|cpm_action
id|cpm_vecs
(braket
id|CPMVEC_NR
)braket
suffix:semicolon
r_static
id|irqreturn_t
id|cpm_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
id|irqreturn_t
id|cpm_error_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|alloc_host_memory
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* Define a table of names to identify CPM interrupt handlers in&n; * /proc/interrupts.&n; */
DECL|variable|cpm_int_name
r_const
r_char
op_star
id|cpm_int_name
(braket
)braket
op_assign
(brace
l_string|&quot;error&quot;
comma
l_string|&quot;PC4&quot;
comma
l_string|&quot;PC5&quot;
comma
l_string|&quot;SMC2&quot;
comma
l_string|&quot;SMC1&quot;
comma
l_string|&quot;SPI&quot;
comma
l_string|&quot;PC6&quot;
comma
l_string|&quot;Timer 4&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;PC7&quot;
comma
l_string|&quot;PC8&quot;
comma
l_string|&quot;PC9&quot;
comma
l_string|&quot;Timer 3&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;PC10&quot;
comma
l_string|&quot;PC11&quot;
comma
l_string|&quot;I2C&quot;
comma
l_string|&quot;RISC Timer&quot;
comma
l_string|&quot;Timer 2&quot;
comma
l_string|&quot;&quot;
comma
l_string|&quot;IDMA2&quot;
comma
l_string|&quot;IDMA1&quot;
comma
l_string|&quot;SDMA error&quot;
comma
l_string|&quot;PC12&quot;
comma
l_string|&quot;PC13&quot;
comma
l_string|&quot;Timer 1&quot;
comma
l_string|&quot;PC14&quot;
comma
l_string|&quot;SCC4&quot;
comma
l_string|&quot;SCC3&quot;
comma
l_string|&quot;SCC2&quot;
comma
l_string|&quot;SCC1&quot;
comma
l_string|&quot;PC15&quot;
)brace
suffix:semicolon
r_static
r_void
DECL|function|cpm_mask_irq
id|cpm_mask_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|cpm_vec
op_assign
id|irq
op_minus
id|CPM_IRQ_OFFSET
suffix:semicolon
(paren
(paren
id|immap_t
op_star
)paren
id|IMAP_ADDR
)paren
op_member_access_from_pointer
id|im_cpic.cpic_cimr
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|cpm_vec
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|cpm_unmask_irq
id|cpm_unmask_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|cpm_vec
op_assign
id|irq
op_minus
id|CPM_IRQ_OFFSET
suffix:semicolon
(paren
(paren
id|immap_t
op_star
)paren
id|IMAP_ADDR
)paren
op_member_access_from_pointer
id|im_cpic.cpic_cimr
op_or_assign
(paren
l_int|1
op_lshift
id|cpm_vec
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|cpm_ack
id|cpm_ack
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
multiline_comment|/* We do not need to do anything here. */
)brace
r_static
r_void
DECL|function|cpm_eoi
id|cpm_eoi
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|cpm_vec
op_assign
id|irq
op_minus
id|CPM_IRQ_OFFSET
suffix:semicolon
(paren
(paren
id|immap_t
op_star
)paren
id|IMAP_ADDR
)paren
op_member_access_from_pointer
id|im_cpic.cpic_cisr
op_assign
(paren
l_int|1
op_lshift
id|cpm_vec
)paren
suffix:semicolon
)brace
DECL|variable|cpm_pic
r_struct
id|hw_interrupt_type
id|cpm_pic
op_assign
(brace
dot
r_typename
op_assign
l_string|&quot; CPM      &quot;
comma
dot
id|enable
op_assign
id|cpm_unmask_irq
comma
dot
id|disable
op_assign
id|cpm_mask_irq
comma
dot
id|ack
op_assign
id|cpm_ack
comma
dot
id|end
op_assign
id|cpm_eoi
comma
)brace
suffix:semicolon
r_extern
r_void
id|flush_tlb_page
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|vmaddr
)paren
suffix:semicolon
r_void
DECL|function|m8xx_cpm_reset
id|m8xx_cpm_reset
c_func
(paren
id|uint
id|bootpage
)paren
(brace
r_volatile
id|immap_t
op_star
id|imp
suffix:semicolon
r_volatile
id|cpm8xx_t
op_star
id|commproc
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
id|imp
op_assign
(paren
id|immap_t
op_star
)paren
id|IMAP_ADDR
suffix:semicolon
id|commproc
op_assign
(paren
id|cpm8xx_t
op_star
)paren
op_amp
id|imp-&gt;im_cpm
suffix:semicolon
macro_line|#ifdef CONFIG_UCODE_PATCH
multiline_comment|/* Perform a reset.&n;&t;*/
id|commproc-&gt;cp_cpcr
op_assign
(paren
id|CPM_CR_RST
op_or
id|CPM_CR_FLG
)paren
suffix:semicolon
multiline_comment|/* Wait for it.&n;&t;*/
r_while
c_loop
(paren
id|commproc-&gt;cp_cpcr
op_amp
id|CPM_CR_FLG
)paren
suffix:semicolon
id|cpm_load_patch
c_func
(paren
id|imp
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Set SDMA Bus Request priority 5.&n;&t; * On 860T, this also enables FEC priority 6.  I am not sure&n;&t; * this is what we realy want for some applications, but the&n;&t; * manual recommends it.&n;&t; * Bit 25, FAM can also be set to use FEC aggressive mode (860T).&n;&t; */
id|imp-&gt;im_siu_conf.sc_sdcr
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Reclaim the DP memory for our use. */
id|m8xx_cpm_dpinit
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* get the PTE for the bootpage */
r_if
c_cond
(paren
op_logical_neg
id|get_pteptr
c_func
(paren
op_amp
id|init_mm
comma
id|bootpage
comma
op_amp
id|pte
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;get_pteptr failed&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* and make it uncachable */
id|pte_val
c_func
(paren
op_star
id|pte
)paren
op_or_assign
id|_PAGE_NO_CACHE
suffix:semicolon
id|_tlbie
c_func
(paren
id|bootpage
)paren
suffix:semicolon
id|host_buffer
op_assign
id|bootpage
suffix:semicolon
id|host_end
op_assign
id|host_buffer
op_plus
id|PAGE_SIZE
suffix:semicolon
multiline_comment|/* Tell everyone where the comm processor resides.&n;&t;*/
id|cpmp
op_assign
(paren
id|cpm8xx_t
op_star
)paren
id|commproc
suffix:semicolon
)brace
multiline_comment|/* We used to do this earlier, but have to postpone as long as possible&n; * to ensure the kernel VM is now running.&n; */
r_static
r_void
DECL|function|alloc_host_memory
id|alloc_host_memory
c_func
(paren
r_void
)paren
(brace
id|dma_addr_t
id|physaddr
suffix:semicolon
multiline_comment|/* Set the host page for allocation.&n;&t;*/
id|host_buffer
op_assign
(paren
id|uint
)paren
id|dma_alloc_coherent
c_func
(paren
l_int|NULL
comma
id|PAGE_SIZE
comma
op_amp
id|physaddr
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|host_end
op_assign
id|host_buffer
op_plus
id|PAGE_SIZE
suffix:semicolon
)brace
multiline_comment|/* This is called during init_IRQ.  We used to do it above, but this&n; * was too early since init_IRQ was not yet called.&n; */
DECL|variable|cpm_error_irqaction
r_static
r_struct
id|irqaction
id|cpm_error_irqaction
op_assign
(brace
dot
id|handler
op_assign
id|cpm_error_interrupt
comma
dot
id|mask
op_assign
id|CPU_MASK_NONE
comma
)brace
suffix:semicolon
DECL|variable|cpm_interrupt_irqaction
r_static
r_struct
id|irqaction
id|cpm_interrupt_irqaction
op_assign
(brace
dot
id|handler
op_assign
id|cpm_interrupt
comma
dot
id|mask
op_assign
id|CPU_MASK_NONE
comma
dot
id|name
op_assign
l_string|&quot;CPM cascade&quot;
comma
)brace
suffix:semicolon
r_void
DECL|function|cpm_interrupt_init
id|cpm_interrupt_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Initialize the CPM interrupt controller.&n;&t;*/
(paren
(paren
id|immap_t
op_star
)paren
id|IMAP_ADDR
)paren
op_member_access_from_pointer
id|im_cpic.cpic_cicr
op_assign
(paren
id|CICR_SCD_SCC4
op_or
id|CICR_SCC_SCC3
op_or
id|CICR_SCB_SCC2
op_or
id|CICR_SCA_SCC1
)paren
op_or
(paren
(paren
id|CPM_INTERRUPT
op_div
l_int|2
)paren
op_lshift
l_int|13
)paren
op_or
id|CICR_HP_MASK
suffix:semicolon
(paren
(paren
id|immap_t
op_star
)paren
id|IMAP_ADDR
)paren
op_member_access_from_pointer
id|im_cpic.cpic_cimr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* install the CPM interrupt controller routines for the CPM&n;         * interrupt vectors&n;         */
r_for
c_loop
(paren
id|i
op_assign
id|CPM_IRQ_OFFSET
suffix:semicolon
id|i
OL
id|CPM_IRQ_OFFSET
op_plus
id|NR_CPM_INTS
suffix:semicolon
id|i
op_increment
)paren
id|irq_desc
(braket
id|i
)braket
dot
id|handler
op_assign
op_amp
id|cpm_pic
suffix:semicolon
multiline_comment|/* Set our interrupt handler with the core CPU.&t;*/
r_if
c_cond
(paren
id|setup_irq
c_func
(paren
id|CPM_INTERRUPT
comma
op_amp
id|cpm_interrupt_irqaction
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Could not allocate CPM IRQ!&quot;
)paren
suffix:semicolon
multiline_comment|/* Install our own error handler. */
id|cpm_error_irqaction.name
op_assign
id|cpm_int_name
(braket
id|CPMVEC_ERROR
)braket
suffix:semicolon
r_if
c_cond
(paren
id|setup_irq
c_func
(paren
id|CPM_IRQ_OFFSET
op_plus
id|CPMVEC_ERROR
comma
op_amp
id|cpm_error_irqaction
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Could not allocate CPM error IRQ!&quot;
)paren
suffix:semicolon
(paren
(paren
id|immap_t
op_star
)paren
id|IMAP_ADDR
)paren
op_member_access_from_pointer
id|im_cpic.cpic_cicr
op_or_assign
id|CICR_IEN
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the CPM interrupt vector.&n; */
r_int
DECL|function|cpm_get_irq
id|cpm_get_irq
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|cpm_vec
suffix:semicolon
multiline_comment|/* Get the vector by setting the ACK bit and then reading&n;&t; * the register.&n;&t; */
(paren
(paren
r_volatile
id|immap_t
op_star
)paren
id|IMAP_ADDR
)paren
op_member_access_from_pointer
id|im_cpic.cpic_civr
op_assign
l_int|1
suffix:semicolon
id|cpm_vec
op_assign
(paren
(paren
r_volatile
id|immap_t
op_star
)paren
id|IMAP_ADDR
)paren
op_member_access_from_pointer
id|im_cpic.cpic_civr
suffix:semicolon
id|cpm_vec
op_rshift_assign
l_int|11
suffix:semicolon
r_return
id|cpm_vec
suffix:semicolon
)brace
multiline_comment|/* CPM interrupt controller cascade interrupt.&n;*/
r_static
id|irqreturn_t
DECL|function|cpm_interrupt
id|cpm_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* This interrupt handler never actually gets called.  It is&n;&t; * installed only to unmask the CPM cascade interrupt in the SIU&n;&t; * and to make the CPM cascade interrupt visible in /proc/interrupts.&n;&t; */
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/* The CPM can generate the error interrupt when there is a race condition&n; * between generating and masking interrupts.  All we have to do is ACK it&n; * and return.  This is a no-op function so we don&squot;t need any special&n; * tests in the interrupt handler.&n; */
r_static
id|irqreturn_t
DECL|function|cpm_error_interrupt
id|cpm_error_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/* A helper function to translate the handler prototype required by&n; * request_irq() to the handler prototype required by cpm_install_handler().&n; */
r_static
id|irqreturn_t
DECL|function|cpm_handler_helper
id|cpm_handler_helper
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|cpm_vec
op_assign
id|irq
op_minus
id|CPM_IRQ_OFFSET
suffix:semicolon
(paren
op_star
id|cpm_vecs
(braket
id|cpm_vec
)braket
dot
id|handler
)paren
(paren
id|dev_id
comma
id|regs
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/* Install a CPM interrupt handler.&n; * This routine accepts a CPM interrupt vector in the range 0 to 31.&n; * This routine is retained for backward compatibility.  Rather than using&n; * this routine to install a CPM interrupt handler, you can now use&n; * request_irq() with an IRQ in the range CPM_IRQ_OFFSET to&n; * CPM_IRQ_OFFSET + NR_CPM_INTS - 1 (16 to 47).&n; *&n; * Notice that the prototype of the interrupt handler function must be&n; * different depending on whether you install the handler with&n; * request_irq() or cpm_install_handler().&n; */
r_void
DECL|function|cpm_install_handler
id|cpm_install_handler
c_func
(paren
r_int
id|cpm_vec
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_void
op_star
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
comma
r_void
op_star
id|dev_id
)paren
(brace
r_int
id|err
suffix:semicolon
multiline_comment|/* If null handler, assume we are trying to free the IRQ.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|handler
)paren
(brace
id|free_irq
c_func
(paren
id|CPM_IRQ_OFFSET
op_plus
id|cpm_vec
comma
id|dev_id
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cpm_vecs
(braket
id|cpm_vec
)braket
dot
id|handler
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;CPM interrupt %x replacing %x&bslash;n&quot;
comma
(paren
id|uint
)paren
id|handler
comma
(paren
id|uint
)paren
id|cpm_vecs
(braket
id|cpm_vec
)braket
dot
id|handler
)paren
suffix:semicolon
id|cpm_vecs
(braket
id|cpm_vec
)braket
dot
id|handler
op_assign
id|handler
suffix:semicolon
id|cpm_vecs
(braket
id|cpm_vec
)braket
dot
id|dev_id
op_assign
id|dev_id
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|request_irq
c_func
(paren
id|CPM_IRQ_OFFSET
op_plus
id|cpm_vec
comma
id|cpm_handler_helper
comma
l_int|0
comma
id|cpm_int_name
(braket
id|cpm_vec
)braket
comma
id|dev_id
)paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;request_irq() returned %d for CPM vector %d&bslash;n&quot;
comma
id|err
comma
id|cpm_vec
)paren
suffix:semicolon
)brace
multiline_comment|/* Free a CPM interrupt handler.&n; * This routine accepts a CPM interrupt vector in the range 0 to 31.&n; * This routine is retained for backward compatibility.&n; */
r_void
DECL|function|cpm_free_handler
id|cpm_free_handler
c_func
(paren
r_int
id|cpm_vec
)paren
(brace
id|request_irq
c_func
(paren
id|CPM_IRQ_OFFSET
op_plus
id|cpm_vec
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
id|cpm_vecs
(braket
id|cpm_vec
)braket
dot
id|dev_id
)paren
suffix:semicolon
id|cpm_vecs
(braket
id|cpm_vec
)braket
dot
id|handler
op_assign
l_int|NULL
suffix:semicolon
id|cpm_vecs
(braket
id|cpm_vec
)braket
dot
id|dev_id
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* We also own one page of host buffer space for the allocation of&n; * UART &quot;fifos&quot; and the like.&n; */
id|uint
DECL|function|m8xx_cpm_hostalloc
id|m8xx_cpm_hostalloc
c_func
(paren
id|uint
id|size
)paren
(brace
id|uint
id|retloc
suffix:semicolon
r_if
c_cond
(paren
id|host_buffer
op_eq
l_int|0
)paren
id|alloc_host_memory
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|host_buffer
op_plus
id|size
)paren
op_ge
id|host_end
)paren
r_return
l_int|0
suffix:semicolon
id|retloc
op_assign
id|host_buffer
suffix:semicolon
id|host_buffer
op_add_assign
id|size
suffix:semicolon
r_return
id|retloc
suffix:semicolon
)brace
multiline_comment|/* Set a baud rate generator.  This needs lots of work.  There are&n; * four BRGs, any of which can be wired to any channel.&n; * The internal baud rate clock is the system clock divided by 16.&n; * This assumes the baudrate is 16x oversampled by the uart.&n; */
DECL|macro|BRG_INT_CLK
mdefine_line|#define BRG_INT_CLK&t;&t;(((bd_t *)__res)-&gt;bi_intfreq)
DECL|macro|BRG_UART_CLK
mdefine_line|#define BRG_UART_CLK&t;&t;(BRG_INT_CLK/16)
DECL|macro|BRG_UART_CLK_DIV16
mdefine_line|#define BRG_UART_CLK_DIV16&t;(BRG_UART_CLK/16)
r_void
DECL|function|cpm_setbrg
id|cpm_setbrg
c_func
(paren
id|uint
id|brg
comma
id|uint
id|rate
)paren
(brace
r_volatile
id|uint
op_star
id|bp
suffix:semicolon
multiline_comment|/* This is good enough to get SMCs running.....&n;&t;*/
id|bp
op_assign
(paren
id|uint
op_star
)paren
op_amp
id|cpmp-&gt;cp_brgc1
suffix:semicolon
id|bp
op_add_assign
id|brg
suffix:semicolon
multiline_comment|/* The BRG has a 12-bit counter.  For really slow baud rates (or&n;&t; * really fast processors), we may have to further divide by 16.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|BRG_UART_CLK
op_div
id|rate
)paren
op_minus
l_int|1
)paren
OL
l_int|4096
)paren
op_star
id|bp
op_assign
(paren
(paren
(paren
id|BRG_UART_CLK
op_div
id|rate
)paren
op_minus
l_int|1
)paren
op_lshift
l_int|1
)paren
op_or
id|CPM_BRG_EN
suffix:semicolon
r_else
op_star
id|bp
op_assign
(paren
(paren
(paren
id|BRG_UART_CLK_DIV16
op_div
id|rate
)paren
op_minus
l_int|1
)paren
op_lshift
l_int|1
)paren
op_or
id|CPM_BRG_EN
op_or
id|CPM_BRG_DIV16
suffix:semicolon
)brace
multiline_comment|/*&n; * dpalloc / dpfree bits.&n; */
DECL|variable|cpm_dpmem_lock
r_static
id|spinlock_t
id|cpm_dpmem_lock
suffix:semicolon
multiline_comment|/*&n; * 16 blocks should be enough to satisfy all requests&n; * until the memory subsystem goes up...&n; */
DECL|variable|cpm_boot_dpmem_rh_block
r_static
id|rh_block_t
id|cpm_boot_dpmem_rh_block
(braket
l_int|16
)braket
suffix:semicolon
DECL|variable|cpm_dpmem_info
r_static
id|rh_info_t
id|cpm_dpmem_info
suffix:semicolon
DECL|macro|CPM_DPMEM_ALIGNMENT
mdefine_line|#define CPM_DPMEM_ALIGNMENT&t;8
DECL|function|m8xx_cpm_dpinit
r_void
id|m8xx_cpm_dpinit
c_func
(paren
r_void
)paren
(brace
id|cpm8xx_t
op_star
id|cp
op_assign
op_amp
(paren
(paren
id|immap_t
op_star
)paren
id|IMAP_ADDR
)paren
op_member_access_from_pointer
id|im_cpm
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|cpm_dpmem_lock
)paren
suffix:semicolon
multiline_comment|/* Initialize the info header */
id|rh_init
c_func
(paren
op_amp
id|cpm_dpmem_info
comma
id|CPM_DPMEM_ALIGNMENT
comma
r_sizeof
(paren
id|cpm_boot_dpmem_rh_block
)paren
op_div
r_sizeof
(paren
id|cpm_boot_dpmem_rh_block
(braket
l_int|0
)braket
)paren
comma
id|cpm_boot_dpmem_rh_block
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Attach the usable dpmem area.&n;&t; * XXX: This is actually crap.  CPM_DATAONLY_BASE and&n;&t; * CPM_DATAONLY_SIZE are a subset of the available dparm.  It varies&n;&t; * with the processor and the microcode patches applied / activated.&n;&t; * But the following should be at least safe.&n;&t; */
id|rh_attach_region
c_func
(paren
op_amp
id|cpm_dpmem_info
comma
(paren
r_void
op_star
)paren
id|CPM_DATAONLY_BASE
comma
id|CPM_DATAONLY_SIZE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate the requested size worth of DP memory.&n; * This function used to return an index into the DPRAM area.&n; * Now it returns the actuall physical address of that area.&n; * use m8xx_cpm_dpram_offset() to get the index&n; */
DECL|function|cpm_dpalloc
id|uint
id|cpm_dpalloc
c_func
(paren
id|uint
id|size
comma
id|uint
id|align
)paren
(brace
r_void
op_star
id|start
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cpm_dpmem_lock
comma
id|flags
)paren
suffix:semicolon
id|cpm_dpmem_info.alignment
op_assign
id|align
suffix:semicolon
id|start
op_assign
id|rh_alloc
c_func
(paren
op_amp
id|cpm_dpmem_info
comma
id|size
comma
l_string|&quot;commproc&quot;
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cpm_dpmem_lock
comma
id|flags
)paren
suffix:semicolon
r_return
(paren
id|uint
)paren
id|start
suffix:semicolon
)brace
DECL|variable|cpm_dpalloc
id|EXPORT_SYMBOL
c_func
(paren
id|cpm_dpalloc
)paren
suffix:semicolon
DECL|function|cpm_dpfree
r_int
id|cpm_dpfree
c_func
(paren
id|uint
id|offset
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cpm_dpmem_lock
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|rh_free
c_func
(paren
op_amp
id|cpm_dpmem_info
comma
(paren
r_void
op_star
)paren
id|offset
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cpm_dpmem_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|cpm_dpfree
id|EXPORT_SYMBOL
c_func
(paren
id|cpm_dpfree
)paren
suffix:semicolon
DECL|function|cpm_dpalloc_fixed
id|uint
id|cpm_dpalloc_fixed
c_func
(paren
id|uint
id|offset
comma
id|uint
id|size
comma
id|uint
id|align
)paren
(brace
r_void
op_star
id|start
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cpm_dpmem_lock
comma
id|flags
)paren
suffix:semicolon
id|cpm_dpmem_info.alignment
op_assign
id|align
suffix:semicolon
id|start
op_assign
id|rh_alloc_fixed
c_func
(paren
op_amp
id|cpm_dpmem_info
comma
(paren
r_void
op_star
)paren
id|offset
comma
id|size
comma
l_string|&quot;commproc&quot;
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cpm_dpmem_lock
comma
id|flags
)paren
suffix:semicolon
r_return
(paren
id|uint
)paren
id|start
suffix:semicolon
)brace
DECL|variable|cpm_dpalloc_fixed
id|EXPORT_SYMBOL
c_func
(paren
id|cpm_dpalloc_fixed
)paren
suffix:semicolon
DECL|function|cpm_dpdump
r_void
id|cpm_dpdump
c_func
(paren
r_void
)paren
(brace
id|rh_dump
c_func
(paren
op_amp
id|cpm_dpmem_info
)paren
suffix:semicolon
)brace
DECL|variable|cpm_dpdump
id|EXPORT_SYMBOL
c_func
(paren
id|cpm_dpdump
)paren
suffix:semicolon
DECL|function|cpm_dpram_addr
r_void
op_star
id|cpm_dpram_addr
c_func
(paren
id|uint
id|offset
)paren
(brace
r_return
(paren
(paren
id|immap_t
op_star
)paren
id|IMAP_ADDR
)paren
op_member_access_from_pointer
id|im_cpm.cp_dpmem
op_plus
id|offset
suffix:semicolon
)brace
DECL|variable|cpm_dpram_addr
id|EXPORT_SYMBOL
c_func
(paren
id|cpm_dpram_addr
)paren
suffix:semicolon
eof
