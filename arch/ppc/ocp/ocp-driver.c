multiline_comment|/*&n; * FILE NAME: ocp-driver.c&n; *&n; * BRIEF MODULE DESCRIPTION: &n; * driver callback, id matching and registration&n; * Based on drivers/pci/pci-driver, Copyright (c) 1997--1999 Martin Mares&n; *&n; * Maintained by: Armin &lt;akuster@mvista.com&gt;&n; *&n; *&n; *  This program is free software; you can redistribute  it and/or modify it&n; *  under  the terms of  the GNU General  Public License as published by the&n; *  Free Software Foundation;  either version 2 of the  License, or (at your&n; *  option) any later version.&n; *&n; *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS&squot;&squot; AND   ANY  EXPRESS OR IMPLIED&n; *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF&n; *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN&n; *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,&n; *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT&n; *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF&n; *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON&n; *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT&n; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF&n; *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; *&n; *  You should have received a copy of the  GNU General Public License along&n; *  with this program; if not, write  to the Free Software Foundation, Inc.,&n; *  675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;asm/ocp.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
multiline_comment|/*&n; *  Registration of OCP drivers and handling of hot-pluggable devices.&n; */
r_static
r_int
DECL|function|ocp_device_probe
id|ocp_device_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_struct
id|ocp_driver
op_star
id|drv
suffix:semicolon
r_struct
id|ocp_device
op_star
id|ocp_dev
suffix:semicolon
id|drv
op_assign
id|to_ocp_driver
c_func
(paren
id|dev-&gt;driver
)paren
suffix:semicolon
id|ocp_dev
op_assign
id|to_ocp_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;probe
)paren
(brace
id|error
op_assign
id|drv
op_member_access_from_pointer
id|probe
c_func
(paren
id|ocp_dev
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;probe return code %d&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ge
l_int|0
)paren
(brace
id|ocp_dev-&gt;driver
op_assign
id|drv
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|error
suffix:semicolon
)brace
r_static
r_int
DECL|function|ocp_device_remove
id|ocp_device_remove
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|ocp_device
op_star
id|ocp_dev
op_assign
id|to_ocp_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ocp_dev-&gt;driver
)paren
(brace
r_if
c_cond
(paren
id|ocp_dev-&gt;driver-&gt;remove
)paren
id|ocp_dev-&gt;driver
op_member_access_from_pointer
id|remove
c_func
(paren
id|ocp_dev
)paren
suffix:semicolon
id|ocp_dev-&gt;driver
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|ocp_device_suspend
id|ocp_device_suspend
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u32
id|state
comma
id|u32
id|level
)paren
(brace
r_struct
id|ocp_device
op_star
id|ocp_dev
op_assign
id|to_ocp_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ocp_dev-&gt;driver
)paren
(brace
r_if
c_cond
(paren
id|level
op_eq
id|SUSPEND_SAVE_STATE
op_logical_and
id|ocp_dev-&gt;driver-&gt;save_state
)paren
id|error
op_assign
id|ocp_dev-&gt;driver
op_member_access_from_pointer
id|save_state
c_func
(paren
id|ocp_dev
comma
id|state
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|level
op_eq
id|SUSPEND_POWER_DOWN
op_logical_and
id|ocp_dev-&gt;driver-&gt;suspend
)paren
id|error
op_assign
id|ocp_dev-&gt;driver
op_member_access_from_pointer
id|suspend
c_func
(paren
id|ocp_dev
comma
id|state
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
r_static
r_int
DECL|function|ocp_device_resume
id|ocp_device_resume
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u32
id|level
)paren
(brace
r_struct
id|ocp_device
op_star
id|ocp_dev
op_assign
id|to_ocp_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ocp_dev-&gt;driver
)paren
(brace
r_if
c_cond
(paren
id|level
op_eq
id|RESUME_POWER_ON
op_logical_and
id|ocp_dev-&gt;driver-&gt;resume
)paren
id|ocp_dev-&gt;driver
op_member_access_from_pointer
id|resume
c_func
(paren
id|ocp_dev
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * ocp_bus_match - Works out whether an OCP device matches any&n; * of the IDs listed for a given OCP driver.&n; * @dev: the generic device struct for the OCP device&n; * @drv: the generic driver struct for the OCP driver&n; * &n; * Used by a driver to check whether a OCP device present in the&n; * system is in its list of supported devices.  Returns 1 for a&n; * match, or 0 if there is no match.&n; */
r_static
r_int
DECL|function|ocp_bus_match
id|ocp_bus_match
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|device_driver
op_star
id|drv
)paren
(brace
r_struct
id|ocp_device
op_star
id|ocp_dev
op_assign
id|to_ocp_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|ocp_driver
op_star
id|ocp_drv
op_assign
id|to_ocp_driver
c_func
(paren
id|drv
)paren
suffix:semicolon
r_const
r_struct
id|ocp_device_id
op_star
id|ids
op_assign
id|ocp_drv-&gt;id_table
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ids
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|ids-&gt;vendor
op_logical_or
id|ids-&gt;device
)paren
(brace
r_if
c_cond
(paren
(paren
id|ids-&gt;vendor
op_eq
id|OCP_ANY_ID
op_logical_or
id|ids-&gt;vendor
op_eq
id|ocp_dev-&gt;vendor
)paren
op_logical_and
(paren
id|ids-&gt;device
op_eq
id|OCP_ANY_ID
op_logical_or
id|ids-&gt;device
op_eq
id|ocp_dev-&gt;device
)paren
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot;Bus match -vendor:%x device:%x&bslash;n&quot;
comma
id|ids-&gt;vendor
comma
id|ids-&gt;device
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|ids
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ocp_bus_type
r_struct
id|bus_type
id|ocp_bus_type
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ocp&quot;
comma
dot
id|match
op_assign
id|ocp_bus_match
comma
)brace
suffix:semicolon
r_static
r_int
id|__init
DECL|function|ocp_driver_init
id|ocp_driver_init
c_func
(paren
r_void
)paren
(brace
r_return
id|bus_register
c_func
(paren
op_amp
id|ocp_bus_type
)paren
suffix:semicolon
)brace
DECL|variable|ocp_driver_init
id|postcore_initcall
c_func
(paren
id|ocp_driver_init
)paren
suffix:semicolon
multiline_comment|/**&n; * ocp_register_driver - register a new ocp driver&n; * @drv: the driver structure to register&n; * &n; * Adds the driver structure to the list of registered drivers&n; * Returns the number of ocp devices which were claimed by the driver&n; * during registration.  The driver remains registered even if the&n; * return value is zero.&n; */
r_int
DECL|function|ocp_register_driver
id|ocp_register_driver
c_func
(paren
r_struct
id|ocp_driver
op_star
id|drv
)paren
(brace
r_int
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* initialize common driver fields */
id|drv-&gt;driver.name
op_assign
id|drv-&gt;name
suffix:semicolon
id|drv-&gt;driver.bus
op_assign
op_amp
id|ocp_bus_type
suffix:semicolon
id|drv-&gt;driver.probe
op_assign
id|ocp_device_probe
suffix:semicolon
id|drv-&gt;driver.resume
op_assign
id|ocp_device_resume
suffix:semicolon
id|drv-&gt;driver.suspend
op_assign
id|ocp_device_suspend
suffix:semicolon
id|drv-&gt;driver.remove
op_assign
id|ocp_device_remove
suffix:semicolon
multiline_comment|/* register with core */
id|count
op_assign
id|driver_register
c_func
(paren
op_amp
id|drv-&gt;driver
)paren
suffix:semicolon
r_return
id|count
ques
c_cond
id|count
suffix:colon
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * ocp_unregister_driver - unregister a ocp driver&n; * @drv: the driver structure to unregister&n; * &n; * Deletes the driver structure from the list of registered OCP drivers,&n; * gives it a chance to clean up by calling its remove() function for&n; * each device it was responsible for, and marks those devices as&n; * driverless.&n; */
r_void
DECL|function|ocp_unregister_driver
id|ocp_unregister_driver
c_func
(paren
r_struct
id|ocp_driver
op_star
id|drv
)paren
(brace
id|driver_unregister
c_func
(paren
op_amp
id|drv-&gt;driver
)paren
suffix:semicolon
)brace
DECL|variable|ocp_register_driver
id|EXPORT_SYMBOL
c_func
(paren
id|ocp_register_driver
)paren
suffix:semicolon
DECL|variable|ocp_unregister_driver
id|EXPORT_SYMBOL
c_func
(paren
id|ocp_unregister_driver
)paren
suffix:semicolon
DECL|variable|ocp_bus_type
id|EXPORT_SYMBOL
c_func
(paren
id|ocp_bus_type
)paren
suffix:semicolon
eof
