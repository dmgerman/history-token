multiline_comment|/*&n; * iSeries_dma.c&n; * Copyright (C) 2001 Mike Corrigan  IBM Corporation&n; *&n; * Dynamic DMA mapping support.&n; * &n; * Manages the TCE space assigned to this partition&n; * &n; * modeled from pci-dma.c&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; * &n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; * &n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA&n; */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/iSeries/HvCallXm.h&gt;
macro_line|#include &lt;asm/iSeries/LparData.h&gt;
macro_line|#include &lt;asm/iSeries/iSeries_dma.h&gt;
macro_line|#include &lt;asm/iSeries/iSeries_pci.h&gt;
DECL|variable|iSeries_veth_dev
r_struct
id|pci_dev
op_star
id|iSeries_veth_dev
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|iSeries_vio_dev
r_struct
id|pci_dev
op_star
id|iSeries_vio_dev
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|virtBusTceTable
r_struct
id|TceTable
id|virtBusTceTable
suffix:semicolon
multiline_comment|/* Tce table for virtual bus */
DECL|variable|tceTables
r_struct
id|TceTable
op_star
id|tceTables
(braket
l_int|256
)braket
suffix:semicolon
singleline_comment|// Tce tables for 256 busses
singleline_comment|// Bus 255 is the virtual bus
singleline_comment|// zero indicates no bus defined
singleline_comment|// allocates a contiguous range of tces (power-of-2 size)
r_static
r_int
id|alloc_tce_range
c_func
(paren
r_struct
id|TceTable
op_star
comma
r_int
id|order
)paren
suffix:semicolon
singleline_comment|// allocates a contiguous range of tces (power-of-2 size)
singleline_comment|// assumes lock already held
r_static
r_int
id|alloc_tce_range_nolock
c_func
(paren
r_struct
id|TceTable
op_star
comma
r_int
id|order
)paren
suffix:semicolon
singleline_comment|// frees a contiguous range of tces (power-of-2 size)
r_static
r_void
id|free_tce_range
c_func
(paren
r_struct
id|TceTable
op_star
comma
r_int
id|tcenum
comma
r_int
id|order
)paren
suffix:semicolon
singleline_comment|// frees a contiguous rnage of tces (power-of-2 size)
singleline_comment|// assumes lock already held
r_static
r_void
id|free_tce_range_nolock
c_func
(paren
r_struct
id|TceTable
op_star
comma
r_int
id|tcenum
comma
r_int
id|order
)paren
suffix:semicolon
singleline_comment|// allocates a range of tces and sets them to the 
singleline_comment|// pages 
r_static
id|dma_addr_t
id|get_tces
c_func
(paren
r_struct
id|TceTable
op_star
comma
r_int
id|order
comma
r_void
op_star
id|page
comma
r_int
id|numPages
comma
r_int
id|tceType
comma
r_int
id|direction
)paren
suffix:semicolon
r_static
r_void
id|free_tces
c_func
(paren
r_struct
id|TceTable
op_star
comma
id|dma_addr_t
id|tce
comma
r_int
id|order
comma
r_int
id|numPages
)paren
suffix:semicolon
r_static
r_int
id|test_tce_range
c_func
(paren
r_struct
id|TceTable
op_star
comma
r_int
id|tcenum
comma
r_int
id|order
)paren
suffix:semicolon
r_static
r_int
id|fill_scatterlist_sg
c_func
(paren
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
comma
id|dma_addr_t
id|dma_addr
comma
r_int
r_int
id|numTces
)paren
suffix:semicolon
r_static
r_int
r_int
id|num_tces_sg
c_func
(paren
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
)paren
suffix:semicolon
r_static
id|dma_addr_t
id|create_tces_sg
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
comma
r_int
id|numTces
comma
r_int
id|tceType
comma
r_int
id|direction
)paren
suffix:semicolon
DECL|function|count_leading_zeros32
r_static
r_int
id|__inline__
id|count_leading_zeros32
c_func
(paren
r_int
r_int
id|x
)paren
(brace
r_int
id|lz
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;cntlzw %0,%1&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|lz
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|x
)paren
)paren
suffix:semicolon
r_return
id|lz
suffix:semicolon
)brace
DECL|function|build_tce
r_static
r_void
id|__inline__
id|build_tce
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_int
id|tcenum
comma
r_int
r_int
id|uaddr
comma
r_int
id|tceType
comma
r_int
id|direction
)paren
(brace
r_union
id|Tce
id|tce
suffix:semicolon
id|tce.wholeTce
op_assign
l_int|0
suffix:semicolon
id|tce.tceBits.rpn
op_assign
(paren
id|virt_to_absolute
c_func
(paren
id|uaddr
)paren
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
singleline_comment|// If for virtual bus
r_if
c_cond
(paren
id|tceType
op_eq
id|TCE_VB
)paren
(brace
id|tce.tceBits.valid
op_assign
l_int|1
suffix:semicolon
id|tce.tceBits.allIo
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_ne
id|PCI_DMA_TODEVICE
)paren
id|tce.tceBits.readWrite
op_assign
l_int|1
suffix:semicolon
)brace
singleline_comment|// If for PCI bus
r_else
(brace
id|tce.tceBits.readWrite
op_assign
l_int|1
suffix:semicolon
singleline_comment|// Read allowed 
r_if
c_cond
(paren
id|direction
op_ne
id|PCI_DMA_TODEVICE
)paren
id|tce.tceBits.pciWrite
op_assign
l_int|1
suffix:semicolon
)brace
id|HvCallXm_setTce
c_func
(paren
(paren
id|u64
)paren
id|tbl-&gt;index
comma
(paren
id|u64
)paren
id|tcenum
comma
id|tce.wholeTce
)paren
suffix:semicolon
)brace
singleline_comment|// Build a TceTable structure.  This contains a multi-level bit map which
singleline_comment|// is used to manage allocation of the tce space.
DECL|function|build_tce_table
r_struct
id|TceTable
op_star
id|build_tce_table
c_func
(paren
r_struct
id|HvTceTableManagerCB
op_star
id|tceTableParms
comma
r_struct
id|TceTable
op_star
id|tbl
)paren
(brace
r_int
r_int
id|bits
comma
id|bytes
comma
id|totalBytes
suffix:semicolon
r_int
r_int
id|numBits
(braket
id|NUM_TCE_LEVELS
)braket
comma
id|numBytes
(braket
id|NUM_TCE_LEVELS
)braket
suffix:semicolon
r_int
id|i
comma
id|k
comma
id|m
suffix:semicolon
r_int
r_char
op_star
id|pos
comma
op_star
id|p
comma
id|b
suffix:semicolon
id|tbl-&gt;size
op_assign
id|tceTableParms-&gt;size
suffix:semicolon
id|tbl-&gt;busNumber
op_assign
id|tceTableParms-&gt;busNumber
suffix:semicolon
id|tbl-&gt;startOffset
op_assign
id|tceTableParms-&gt;startOffset
suffix:semicolon
id|tbl-&gt;index
op_assign
id|tceTableParms-&gt;index
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|tbl-&gt;lock
)paren
)paren
suffix:semicolon
id|tbl-&gt;mlbm.maxLevel
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Compute number of bits and bytes for each level of the
singleline_comment|// multi-level bit map
singleline_comment|// 
id|totalBytes
op_assign
l_int|0
suffix:semicolon
id|bits
op_assign
id|tbl-&gt;size
op_star
(paren
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_union
id|Tce
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_TCE_LEVELS
suffix:semicolon
op_increment
id|i
)paren
(brace
id|bytes
op_assign
(paren
id|bits
op_plus
l_int|7
)paren
op_div
l_int|8
suffix:semicolon
macro_line|#ifdef DEBUG_TCE
id|printk
c_func
(paren
l_string|&quot;build_tce_table: level %d bits=%ld, bytes=%ld&bslash;n&quot;
comma
id|i
comma
id|bits
comma
id|bytes
)paren
suffix:semicolon
macro_line|#endif
id|numBits
(braket
id|i
)braket
op_assign
id|bits
suffix:semicolon
id|numBytes
(braket
id|i
)braket
op_assign
id|bytes
suffix:semicolon
id|bits
op_div_assign
l_int|2
suffix:semicolon
multiline_comment|/* we need extra space at the end that&squot;s a multiple of 8 bytes */
multiline_comment|/* for the cntlzw algorithm to work correctly. */
multiline_comment|/* but we don&squot;t want the bits turned on or used, so we don&squot;t muck with numBytes[i] */
id|totalBytes
op_add_assign
(paren
id|bytes
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_TCE
id|printk
c_func
(paren
l_string|&quot;build_tce_table: totalBytes=%ld&bslash;n&quot;
comma
id|totalBytes
)paren
suffix:semicolon
macro_line|#endif
id|pos
op_assign
(paren
r_char
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|get_order
c_func
(paren
id|totalBytes
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pos
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|pos
comma
l_int|0
comma
id|totalBytes
)paren
suffix:semicolon
singleline_comment|// For each level, fill in the pointer to the bit map,
singleline_comment|// and turn on the last bit in the bit map (if the
singleline_comment|// number of bits in the map is odd).  The highest
singleline_comment|// level will get all of its bits turned on.
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_TCE_LEVELS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|numBytes
(braket
id|i
)braket
)paren
(brace
id|tbl-&gt;mlbm.level
(braket
id|i
)braket
dot
id|map
op_assign
id|pos
suffix:semicolon
id|tbl-&gt;mlbm.maxLevel
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|numBits
(braket
id|i
)braket
op_amp
l_int|1
)paren
(brace
id|p
op_assign
id|pos
op_plus
id|numBytes
(braket
id|i
)braket
op_minus
l_int|1
suffix:semicolon
id|m
op_assign
(paren
(paren
id|numBits
(braket
id|i
)braket
op_mod
l_int|8
)paren
op_minus
l_int|1
)paren
op_amp
l_int|7
suffix:semicolon
op_star
id|p
op_assign
l_int|0x80
op_rshift
id|m
suffix:semicolon
macro_line|#ifdef DEBUG_TCE
id|printk
c_func
(paren
l_string|&quot;build_tce_table: level %d last bit %x&bslash;n&quot;
comma
id|i
comma
l_int|0x80
op_rshift
id|m
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;
)brace
)brace
r_else
id|tbl-&gt;mlbm.level
(braket
id|i
)braket
dot
id|map
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* see the comment up above on the totalBytes calculation for why we do this. */
id|pos
op_add_assign
(paren
id|numBytes
(braket
id|i
)braket
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
suffix:semicolon
id|tbl-&gt;mlbm.level
(braket
id|i
)braket
dot
id|numBits
op_assign
id|numBits
(braket
id|i
)braket
suffix:semicolon
id|tbl-&gt;mlbm.level
(braket
id|i
)braket
dot
id|numBytes
op_assign
id|numBytes
(braket
id|i
)braket
suffix:semicolon
)brace
singleline_comment|// For the highest level, turn on all the bits
id|i
op_assign
id|tbl-&gt;mlbm.maxLevel
suffix:semicolon
id|p
op_assign
id|tbl-&gt;mlbm.level
(braket
id|i
)braket
dot
id|map
suffix:semicolon
id|m
op_assign
id|numBits
(braket
id|i
)braket
suffix:semicolon
macro_line|#ifdef DEBUG_TCE
id|printk
c_func
(paren
l_string|&quot;build_tce_table: highest level (%d) has all bits set&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
macro_line|#endif&t;
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|numBytes
(braket
id|i
)braket
suffix:semicolon
op_increment
id|k
)paren
(brace
r_if
c_cond
(paren
id|m
op_ge
l_int|8
)paren
(brace
singleline_comment|// handle full bytes
op_star
id|p
op_increment
op_assign
l_int|0xff
suffix:semicolon
id|m
op_sub_assign
l_int|8
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// handle the last partial byte
id|b
op_assign
l_int|0x80
suffix:semicolon
op_star
id|p
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|m
)paren
(brace
op_star
id|p
op_or_assign
id|b
suffix:semicolon
id|b
op_rshift_assign
l_int|1
suffix:semicolon
op_decrement
id|m
suffix:semicolon
)brace
)brace
)brace
r_return
id|tbl
suffix:semicolon
)brace
DECL|function|alloc_tce_range
r_static
r_int
id|alloc_tce_range
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_int
id|order
)paren
(brace
r_int
id|retval
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
singleline_comment|// Lock the tce allocation bitmap
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|tbl-&gt;lock
)paren
comma
id|flags
)paren
suffix:semicolon
singleline_comment|// Do the actual work
id|retval
op_assign
id|alloc_tce_range_nolock
c_func
(paren
id|tbl
comma
id|order
)paren
suffix:semicolon
singleline_comment|// Unlock the tce allocation bitmap
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|tbl-&gt;lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|alloc_tce_range_nolock
r_static
r_int
id|alloc_tce_range_nolock
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_int
id|order
)paren
(brace
r_int
r_int
id|numBits
comma
id|numBytes
suffix:semicolon
r_int
r_int
id|i
comma
id|bit
comma
id|block
comma
id|mask
suffix:semicolon
r_int
id|tcenum
suffix:semicolon
id|u32
op_star
id|map
suffix:semicolon
singleline_comment|// If the order (power of 2 size) requested is larger than our
singleline_comment|// biggest, indicate failure
r_if
c_cond
(paren
id|order
OG
id|tbl-&gt;mlbm.maxLevel
)paren
(brace
macro_line|#ifdef DEBUG_TCE
id|printk
c_func
(paren
l_string|&quot;alloc_tce_range_nolock: invalid order requested, order = %d&bslash;n&quot;
comma
id|order
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|numBits
op_assign
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|numBits
suffix:semicolon
id|numBytes
op_assign
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|numBytes
suffix:semicolon
id|map
op_assign
(paren
id|u32
op_star
)paren
(paren
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|map
)paren
suffix:semicolon
singleline_comment|// Initialize return value to -1 (failure)
id|tcenum
op_assign
op_minus
l_int|1
suffix:semicolon
singleline_comment|// Loop through the bytes of the bitmap
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numBytes
op_div
l_int|4
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
op_star
id|map
)paren
(brace
singleline_comment|// A free block is found, compute the block
singleline_comment|// number (of this size)
id|bit
op_assign
id|count_leading_zeros32
c_func
(paren
op_star
id|map
)paren
suffix:semicolon
id|block
op_assign
(paren
id|i
op_star
l_int|32
)paren
op_plus
id|bit
suffix:semicolon
singleline_comment|// turn off the bit in the map to indicate
singleline_comment|// that the block is now in use
id|mask
op_assign
l_int|0xffffffff
op_xor
(paren
l_int|0x80000000
op_rshift
id|bit
)paren
suffix:semicolon
op_star
id|map
op_and_assign
id|mask
suffix:semicolon
singleline_comment|// compute the index into our tce table for
singleline_comment|// the first tce in the block
macro_line|#ifdef DEBUG_TCE
id|printk
c_func
(paren
l_string|&quot;alloc_tce_range_nolock: allocating block %ld, (byte=%ld, bit=%ld) order %d&bslash;n&quot;
comma
id|block
comma
id|i
comma
id|bit
comma
id|order
)paren
suffix:semicolon
macro_line|#endif
id|tcenum
op_assign
id|block
op_lshift
id|order
suffix:semicolon
r_break
suffix:semicolon
)brace
op_increment
id|map
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_TCE
r_if
c_cond
(paren
id|tcenum
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;alloc_tce_range_nolock: no available blocks of order = %d&bslash;n&quot;
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
id|order
OL
id|tbl-&gt;mlbm.maxLevel
)paren
id|printk
c_func
(paren
l_string|&quot;alloc_tce_range_nolock: trying next bigger size&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;alloc_tce_range_nolock: maximum size reached...failing&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif&t;
singleline_comment|// If no block of the requested size was found, try the next
singleline_comment|// size bigger.  If one of those is found, return the second
singleline_comment|// half of the block to freespace and keep the first half
r_if
c_cond
(paren
(paren
id|tcenum
op_eq
op_minus
l_int|1
)paren
op_logical_and
(paren
id|order
OL
id|tbl-&gt;mlbm.maxLevel
)paren
)paren
(brace
id|tcenum
op_assign
id|alloc_tce_range_nolock
c_func
(paren
id|tbl
comma
id|order
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcenum
op_ne
op_minus
l_int|1
)paren
(brace
id|free_tce_range_nolock
c_func
(paren
id|tbl
comma
id|tcenum
op_plus
(paren
l_int|1
op_lshift
id|order
)paren
comma
id|order
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// Return the index of the first tce in the block
singleline_comment|// (or -1 if we failed)
r_return
id|tcenum
suffix:semicolon
)brace
DECL|function|free_tce_range
r_static
r_void
id|free_tce_range
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_int
id|tcenum
comma
r_int
id|order
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
singleline_comment|// Lock the tce allocation bitmap
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|tbl-&gt;lock
)paren
comma
id|flags
)paren
suffix:semicolon
singleline_comment|// Do the actual work
id|free_tce_range_nolock
c_func
(paren
id|tbl
comma
id|tcenum
comma
id|order
)paren
suffix:semicolon
singleline_comment|// Unlock the tce allocation bitmap
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|tbl-&gt;lock
)paren
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|free_tce_range_nolock
r_static
r_void
id|free_tce_range_nolock
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_int
id|tcenum
comma
r_int
id|order
)paren
(brace
r_int
r_int
id|block
suffix:semicolon
r_int
id|byte
comma
id|bit
comma
id|mask
comma
id|b
suffix:semicolon
r_int
r_char
op_star
id|map
comma
op_star
id|bytep
suffix:semicolon
r_if
c_cond
(paren
id|order
OG
id|tbl-&gt;mlbm.maxLevel
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;free_tce_range: order too large, order = %d&bslash;n&quot;
comma
id|order
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|block
op_assign
id|tcenum
op_rshift
id|order
suffix:semicolon
r_if
c_cond
(paren
id|tcenum
op_ne
(paren
id|block
op_lshift
id|order
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;free_tce_range: tcenum %lx is not on appropriate boundary for order %x&bslash;n&quot;
comma
id|tcenum
comma
id|order
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|block
op_ge
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|numBits
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;free_tce_range: tcenum %lx is outside the range of this map (order %x, numBits %lx&bslash;n&quot;
comma
id|tcenum
comma
id|order
comma
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|numBits
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_TCE&t;
r_if
c_cond
(paren
id|test_tce_range
c_func
(paren
id|tbl
comma
id|tcenum
comma
id|order
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;free_tce_range: freeing range not completely allocated.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;free_tce_range:   TceTable %p, tcenum %lx, order %x&bslash;n&quot;
comma
id|tbl
comma
id|tcenum
comma
id|order
)paren
suffix:semicolon
)brace
macro_line|#endif
id|map
op_assign
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|map
suffix:semicolon
id|byte
op_assign
id|block
op_div
l_int|8
suffix:semicolon
id|bit
op_assign
id|block
op_mod
l_int|8
suffix:semicolon
id|mask
op_assign
l_int|0x80
op_rshift
id|bit
suffix:semicolon
id|bytep
op_assign
id|map
op_plus
id|byte
suffix:semicolon
macro_line|#ifdef DEBUG_TCE
id|printk
c_func
(paren
l_string|&quot;free_tce_range_nolock: freeing block %ld (byte=%d, bit=%d) of order %d&bslash;n&quot;
comma
id|block
comma
id|byte
comma
id|bit
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|bytep
op_amp
id|mask
)paren
id|printk
c_func
(paren
l_string|&quot;free_tce_range: already free: TceTable %p, tcenum %lx, order %x&bslash;n&quot;
comma
id|tbl
comma
id|tcenum
comma
id|order
)paren
suffix:semicolon
macro_line|#endif&t;
op_star
id|bytep
op_or_assign
id|mask
suffix:semicolon
singleline_comment|// If there is a higher level in the bit map than this we may be
singleline_comment|// able to buddy up this block with its partner.
singleline_comment|//   If this is the highest level we can&squot;t buddy up
singleline_comment|//   If this level has an odd number of bits and
singleline_comment|//      we are freeing the last block we can&squot;t buddy up
singleline_comment|// don&squot;t buddy up if it&squot;s in the first 1/4 of the bits
r_if
c_cond
(paren
(paren
id|order
OL
id|tbl-&gt;mlbm.maxLevel
)paren
op_logical_and
(paren
(paren
l_int|0
op_eq
(paren
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|numBits
op_amp
l_int|1
)paren
)paren
op_logical_or
(paren
id|block
OL
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|numBits
op_minus
l_int|1
)paren
)paren
op_logical_and
(paren
id|block
OG
(paren
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|numBits
op_div
l_int|4
)paren
)paren
)paren
(brace
singleline_comment|// See if we can buddy up the block we just freed
id|bit
op_and_assign
l_int|6
suffix:semicolon
singleline_comment|// get to the first of the buddy bits
id|mask
op_assign
l_int|0xc0
op_rshift
id|bit
suffix:semicolon
singleline_comment|// build two bit mask
id|b
op_assign
op_star
id|bytep
op_amp
id|mask
suffix:semicolon
singleline_comment|// Get the two bits
r_if
c_cond
(paren
l_int|0
op_eq
(paren
id|b
op_xor
id|mask
)paren
)paren
(brace
singleline_comment|// If both bits are on
singleline_comment|// both of the buddy blocks are free we can combine them
op_star
id|bytep
op_xor_assign
id|mask
suffix:semicolon
singleline_comment|// turn off the two bits
id|block
op_assign
(paren
id|byte
op_star
l_int|8
)paren
op_plus
id|bit
suffix:semicolon
singleline_comment|// block of first of buddies
id|tcenum
op_assign
id|block
op_lshift
id|order
suffix:semicolon
singleline_comment|// free the buddied block
macro_line|#ifdef DEBUG_TCE
id|printk
c_func
(paren
l_string|&quot;free_tce_range: buddying up block %ld and block %ld&bslash;n&quot;
comma
id|block
comma
id|block
op_plus
l_int|1
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;
id|free_tce_range_nolock
c_func
(paren
id|tbl
comma
id|tcenum
comma
id|order
op_plus
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|test_tce_range
r_static
r_int
id|test_tce_range
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_int
id|tcenum
comma
r_int
id|order
)paren
(brace
r_int
r_int
id|block
suffix:semicolon
r_int
id|byte
comma
id|bit
comma
id|mask
comma
id|b
suffix:semicolon
r_int
id|retval
comma
id|retLeft
comma
id|retRight
suffix:semicolon
r_int
r_char
op_star
id|map
suffix:semicolon
id|map
op_assign
id|tbl-&gt;mlbm.level
(braket
id|order
)braket
dot
id|map
suffix:semicolon
id|block
op_assign
id|tcenum
op_rshift
id|order
suffix:semicolon
id|byte
op_assign
id|block
op_div
l_int|8
suffix:semicolon
singleline_comment|// Byte within bitmap
id|bit
op_assign
id|block
op_mod
l_int|8
suffix:semicolon
singleline_comment|// Bit within byte
id|mask
op_assign
l_int|0x80
op_rshift
id|bit
suffix:semicolon
id|b
op_assign
(paren
op_star
(paren
id|map
op_plus
id|byte
)paren
op_amp
id|mask
)paren
suffix:semicolon
singleline_comment|// 0 if block is allocated, else free
r_if
c_cond
(paren
id|b
)paren
id|retval
op_assign
l_int|1
suffix:semicolon
singleline_comment|// 1 == block is free
r_else
id|retval
op_assign
l_int|0
suffix:semicolon
singleline_comment|// 0 == block is allocated
singleline_comment|// Test bits at all levels below this to ensure that all agree
r_if
c_cond
(paren
id|order
)paren
(brace
id|retLeft
op_assign
id|test_tce_range
c_func
(paren
id|tbl
comma
id|tcenum
comma
id|order
op_minus
l_int|1
)paren
suffix:semicolon
id|retRight
op_assign
id|test_tce_range
c_func
(paren
id|tbl
comma
id|tcenum
op_plus
(paren
l_int|1
op_lshift
(paren
id|order
op_minus
l_int|1
)paren
)paren
comma
id|order
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retLeft
op_logical_or
id|retRight
)paren
(brace
id|retval
op_assign
l_int|2
suffix:semicolon
)brace
)brace
singleline_comment|// Test bits at all levels above this to ensure that all agree
r_return
id|retval
suffix:semicolon
)brace
DECL|function|get_tces
r_static
id|dma_addr_t
id|get_tces
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_int
id|order
comma
r_void
op_star
id|page
comma
r_int
id|numPages
comma
r_int
id|tceType
comma
r_int
id|direction
)paren
(brace
r_int
id|tcenum
suffix:semicolon
r_int
r_int
id|uaddr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dma_addr_t
id|retTce
op_assign
id|NO_TCE
suffix:semicolon
id|uaddr
op_assign
(paren
r_int
r_int
)paren
id|page
op_amp
id|PAGE_MASK
suffix:semicolon
singleline_comment|// Allocate a range of tces
id|tcenum
op_assign
id|alloc_tce_range
c_func
(paren
id|tbl
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcenum
op_ne
op_minus
l_int|1
)paren
(brace
singleline_comment|// We got the tces we wanted
id|tcenum
op_add_assign
id|tbl-&gt;startOffset
suffix:semicolon
singleline_comment|// Offset into real TCE table
id|retTce
op_assign
id|tcenum
op_lshift
id|PAGE_SHIFT
suffix:semicolon
singleline_comment|// Set the return dma address
singleline_comment|// Setup a tce for each page
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numPages
suffix:semicolon
op_increment
id|i
)paren
(brace
id|build_tce
c_func
(paren
id|tbl
comma
id|tcenum
comma
id|uaddr
comma
id|tceType
comma
id|direction
)paren
suffix:semicolon
op_increment
id|tcenum
suffix:semicolon
id|uaddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG_TCE
r_else
id|printk
c_func
(paren
l_string|&quot;alloc_tce_range failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif&t;
r_return
id|retTce
suffix:semicolon
)brace
DECL|function|free_tces
r_static
r_void
id|free_tces
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
id|dma_addr_t
id|dma_addr
comma
r_int
id|order
comma
r_int
id|numPages
)paren
(brace
r_int
id|tcenum
comma
id|freeTce
comma
id|maxTcenum
suffix:semicolon
r_int
id|i
suffix:semicolon
r_union
id|Tce
id|tce
suffix:semicolon
id|maxTcenum
op_assign
(paren
id|tbl-&gt;size
op_star
(paren
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_union
id|Tce
)paren
)paren
)paren
op_minus
l_int|1
suffix:semicolon
id|tcenum
op_assign
id|dma_addr
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|tcenum
op_sub_assign
id|tbl-&gt;startOffset
suffix:semicolon
r_if
c_cond
(paren
id|tcenum
OG
id|maxTcenum
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;free_tces: tcenum &gt; maxTcenum, tcenum = %ld, maxTcenum = %ld&bslash;n&quot;
comma
id|tcenum
comma
id|maxTcenum
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;free_tces:    TCE Table at %16lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|tbl
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;free_tces:      bus#     %lu&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|tbl-&gt;busNumber
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;free_tces:      size     %lu&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|tbl-&gt;size
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;free_tces:      startOff %lu&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|tbl-&gt;startOffset
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;free_tces:      index    %lu&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|tbl-&gt;index
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|freeTce
op_assign
id|tcenum
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numPages
suffix:semicolon
op_increment
id|i
)paren
(brace
id|tce.wholeTce
op_assign
l_int|0
suffix:semicolon
id|HvCallXm_setTce
c_func
(paren
(paren
id|u64
)paren
id|tbl-&gt;index
comma
(paren
id|u64
)paren
id|tcenum
comma
id|tce.wholeTce
)paren
suffix:semicolon
op_increment
id|tcenum
suffix:semicolon
)brace
id|free_tce_range
c_func
(paren
id|tbl
comma
id|freeTce
comma
id|order
)paren
suffix:semicolon
)brace
DECL|function|create_virtual_bus_tce_table
r_void
id|__init
id|create_virtual_bus_tce_table
c_func
(paren
r_void
)paren
(brace
r_struct
id|TceTable
op_star
id|t
suffix:semicolon
r_struct
id|HvTceTableManagerCB
id|virtBusTceTableParms
suffix:semicolon
id|u64
id|absParmsPtr
suffix:semicolon
id|virtBusTceTableParms.busNumber
op_assign
l_int|255
suffix:semicolon
multiline_comment|/* Bus 255 is the virtual bus */
id|virtBusTceTableParms.virtualBusFlag
op_assign
l_int|0xff
suffix:semicolon
multiline_comment|/* Ask for virtual bus */
id|absParmsPtr
op_assign
id|virt_to_absolute
c_func
(paren
(paren
id|u32
)paren
op_amp
id|virtBusTceTableParms
)paren
suffix:semicolon
id|HvCallXm_getTceTableParms
c_func
(paren
id|absParmsPtr
)paren
suffix:semicolon
id|t
op_assign
id|build_tce_table
c_func
(paren
op_amp
id|virtBusTceTableParms
comma
op_amp
id|virtBusTceTable
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
(brace
id|tceTables
(braket
l_int|255
)braket
op_assign
id|t
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Virtual Bus TCE table built successfully.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  TCE table size = %ld entries&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|t-&gt;size
op_star
(paren
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_union
id|Tce
)paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  TCE table token = %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|t-&gt;index
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  TCE table start entry = 0x%lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|t-&gt;startOffset
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;Virtual Bus TCE table failed.&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|create_pci_bus_tce_table
r_void
id|__init
id|create_pci_bus_tce_table
c_func
(paren
r_int
id|busNumber
)paren
(brace
r_struct
id|TceTable
op_star
id|t
suffix:semicolon
r_struct
id|TceTable
op_star
id|newTceTable
suffix:semicolon
r_struct
id|HvTceTableManagerCB
id|pciBusTceTableParms
suffix:semicolon
id|u64
id|absParmsPtr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|busNumber
OG
l_int|254
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PCI Bus TCE table failed.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Invalid bus number %u&bslash;n&quot;
comma
id|busNumber
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|newTceTable
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|TceTable
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|pciBusTceTableParms.busNumber
op_assign
id|busNumber
suffix:semicolon
id|pciBusTceTableParms.virtualBusFlag
op_assign
l_int|0
suffix:semicolon
id|absParmsPtr
op_assign
id|virt_to_absolute
c_func
(paren
(paren
id|u32
)paren
op_amp
id|pciBusTceTableParms
)paren
suffix:semicolon
id|HvCallXm_getTceTableParms
c_func
(paren
id|absParmsPtr
)paren
suffix:semicolon
singleline_comment|// Determine if the table identified by the index and startOffset
singleline_comment|// returned by the hypervisor for this bus has already been created.
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|255
suffix:semicolon
op_increment
id|i
)paren
(brace
id|t
op_assign
id|tceTables
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
(brace
r_if
c_cond
(paren
(paren
id|t-&gt;index
op_eq
id|pciBusTceTableParms.index
)paren
op_logical_and
(paren
id|t-&gt;startOffset
op_eq
id|pciBusTceTableParms.startOffset
)paren
)paren
(brace
r_if
c_cond
(paren
id|t-&gt;size
op_ne
id|pciBusTceTableParms.size
)paren
id|printk
c_func
(paren
l_string|&quot;PCI Bus %d Shares a TCE table with Bus %d, but sizes differ&bslash;n&quot;
comma
id|busNumber
comma
id|i
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;PCI Bus %d Shares a TCE table with bus %d&bslash;n&quot;
comma
id|busNumber
comma
id|i
)paren
suffix:semicolon
id|tceTables
(braket
id|busNumber
)braket
op_assign
id|t
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|tceTables
(braket
id|busNumber
)braket
)paren
(brace
id|t
op_assign
id|build_tce_table
c_func
(paren
op_amp
id|pciBusTceTableParms
comma
id|newTceTable
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
(brace
id|tceTables
(braket
id|busNumber
)braket
op_assign
id|t
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PCI Bus %d TCE table built successfully.&bslash;n&quot;
comma
id|busNumber
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  TCE table size = %ld entries&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|t-&gt;size
op_star
(paren
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_union
id|Tce
)paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  TCE table token = %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|t-&gt;index
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  TCE table start entry = 0x%lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|t-&gt;startOffset
)paren
suffix:semicolon
)brace
r_else
(brace
id|kfree
c_func
(paren
id|newTceTable
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PCI Bus %d TCE table failed.&bslash;n&quot;
comma
id|busNumber
)paren
suffix:semicolon
)brace
)brace
)brace
singleline_comment|// Allocates a contiguous real buffer and creates TCEs over it.
singleline_comment|// Returns the virtual address of the buffer and sets dma_handle
singleline_comment|// to the dma address (tce) of the first page.
DECL|function|pci_alloc_consistent
r_void
op_star
id|pci_alloc_consistent
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_int
id|size
comma
id|dma_addr_t
op_star
id|dma_handle
)paren
(brace
r_struct
id|TceTable
op_star
id|tbl
suffix:semicolon
r_void
op_star
id|ret
op_assign
l_int|NULL
suffix:semicolon
r_int
id|order
comma
id|nPages
comma
id|bus
suffix:semicolon
id|dma_addr_t
id|tce
suffix:semicolon
r_int
id|tceType
suffix:semicolon
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|size
)paren
suffix:semicolon
id|order
op_assign
id|get_order
c_func
(paren
id|size
)paren
suffix:semicolon
id|nPages
op_assign
l_int|1
op_lshift
id|order
suffix:semicolon
singleline_comment|// If no pci_dev then use virtual bus
r_if
c_cond
(paren
id|hwdev
op_eq
l_int|NULL
)paren
(brace
id|bus
op_assign
l_int|255
suffix:semicolon
id|tceType
op_assign
id|TCE_VB
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef CONFIG_PCI        
singleline_comment|// Get the iSeries bus # to use as an index
singleline_comment|// into the TCE table array
id|bus
op_assign
id|ISERIES_GET_BUS
c_func
(paren
id|hwdev
)paren
suffix:semicolon
id|tceType
op_assign
id|TCE_PCI
suffix:semicolon
macro_line|#else
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
macro_line|#endif /* CONFIG_PCI */
)brace
id|tbl
op_assign
id|tceTables
(braket
id|bus
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tbl
)paren
(brace
singleline_comment|// Alloc enough pages (and possibly more)
id|ret
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
singleline_comment|// Page allocation succeeded
id|memset
c_func
(paren
id|ret
comma
l_int|0
comma
id|nPages
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
singleline_comment|// Set up tces to cover the allocated range
id|tce
op_assign
id|get_tces
c_func
(paren
id|tbl
comma
id|order
comma
id|ret
comma
id|nPages
comma
id|tceType
comma
id|PCI_DMA_BIDIRECTIONAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tce
op_eq
id|NO_TCE
)paren
(brace
macro_line|#ifdef DEBUG_TCE&t;&t;&t;&t;
id|printk
c_func
(paren
l_string|&quot;pci_alloc_consistent: get_tces failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|ret
comma
id|order
)paren
suffix:semicolon
id|ret
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
op_star
id|dma_handle
op_assign
id|tce
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG_TCE
r_else
id|printk
c_func
(paren
l_string|&quot;pci_alloc_consistent: __get_free_pages failed for order = %d&bslash;n&quot;
comma
id|order
)paren
suffix:semicolon
macro_line|#endif&t;&t;
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|pci_free_consistent
r_void
id|pci_free_consistent
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_int
id|size
comma
r_void
op_star
id|vaddr
comma
id|dma_addr_t
id|dma_handle
)paren
(brace
r_struct
id|TceTable
op_star
id|tbl
suffix:semicolon
r_int
id|order
comma
id|nPages
comma
id|bus
suffix:semicolon
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|size
)paren
suffix:semicolon
id|order
op_assign
id|get_order
c_func
(paren
id|size
)paren
suffix:semicolon
id|nPages
op_assign
l_int|1
op_lshift
id|order
suffix:semicolon
singleline_comment|// If no pci_dev then use virtual bus
r_if
c_cond
(paren
id|hwdev
op_eq
l_int|NULL
)paren
id|bus
op_assign
l_int|255
suffix:semicolon
r_else
(brace
macro_line|#ifdef CONFIG_PCI        
singleline_comment|// Get the iSeries bus # to use as an index
singleline_comment|// into the TCE table array
id|bus
op_assign
id|ISERIES_GET_BUS
c_func
(paren
id|hwdev
)paren
suffix:semicolon
macro_line|#else
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#endif /* CONFIG_PCI */
)brace
r_if
c_cond
(paren
id|bus
OG
l_int|255
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pci_free_consistent: invalid bus # %d&bslash;n&quot;
comma
id|bus
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_free_consistent:   hwdev = %08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|hwdev
)paren
suffix:semicolon
)brace
id|tbl
op_assign
id|tceTables
(braket
id|bus
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tbl
)paren
(brace
id|free_tces
c_func
(paren
id|tbl
comma
id|dma_handle
comma
id|order
comma
id|nPages
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|vaddr
comma
id|order
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// Creates TCEs for a user provided buffer.  The user buffer must be 
singleline_comment|// contiguous real kernel storage (not vmalloc).  The address of the buffer
singleline_comment|// passed here is the kernel (virtual) address of the buffer.  The buffer
singleline_comment|// need not be page aligned, the dma_addr_t returned will point to the same
singleline_comment|// byte within the page as vaddr.
DECL|function|pci_map_single
id|dma_addr_t
id|pci_map_single
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_void
op_star
id|vaddr
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
r_struct
id|TceTable
op_star
id|tbl
suffix:semicolon
id|dma_addr_t
id|dma_handle
suffix:semicolon
r_int
r_int
id|uaddr
suffix:semicolon
r_int
id|order
comma
id|nPages
comma
id|bus
suffix:semicolon
r_int
id|tceType
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|dma_handle
op_assign
id|NO_TCE
suffix:semicolon
id|uaddr
op_assign
(paren
r_int
r_int
)paren
id|vaddr
suffix:semicolon
id|nPages
op_assign
id|PAGE_ALIGN
c_func
(paren
id|uaddr
op_plus
id|size
)paren
op_minus
(paren
id|uaddr
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
id|order
op_assign
id|get_order
c_func
(paren
id|nPages
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
id|nPages
op_rshift_assign
id|PAGE_SHIFT
suffix:semicolon
singleline_comment|// If no pci_dev then use virtual bus
r_if
c_cond
(paren
id|hwdev
op_eq
l_int|NULL
)paren
(brace
id|bus
op_assign
l_int|255
suffix:semicolon
id|tceType
op_assign
id|TCE_VB
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef CONFIG_PCI        
singleline_comment|// Get the iSeries bus # to use as an index
singleline_comment|// into the TCE table array
id|bus
op_assign
id|ISERIES_GET_BUS
c_func
(paren
id|hwdev
)paren
suffix:semicolon
id|tceType
op_assign
id|TCE_PCI
suffix:semicolon
macro_line|#else
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
id|NO_TCE
suffix:semicolon
macro_line|#endif /* CONFIG_PCI */
)brace
id|tbl
op_assign
id|tceTables
(braket
id|bus
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tbl
)paren
(brace
id|dma_handle
op_assign
id|get_tces
c_func
(paren
id|tbl
comma
id|order
comma
id|vaddr
comma
id|nPages
comma
id|tceType
comma
id|direction
)paren
suffix:semicolon
id|dma_handle
op_or_assign
(paren
id|uaddr
op_amp
op_complement
id|PAGE_MASK
)paren
suffix:semicolon
)brace
r_return
id|dma_handle
suffix:semicolon
)brace
DECL|function|pci_unmap_single
r_void
id|pci_unmap_single
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
id|dma_addr_t
id|dma_handle
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
r_struct
id|TceTable
op_star
id|tbl
suffix:semicolon
r_int
id|order
comma
id|nPages
comma
id|bus
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|nPages
op_assign
id|PAGE_ALIGN
c_func
(paren
id|dma_handle
op_plus
id|size
)paren
op_minus
(paren
id|dma_handle
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
id|order
op_assign
id|get_order
c_func
(paren
id|nPages
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
id|nPages
op_rshift_assign
id|PAGE_SHIFT
suffix:semicolon
singleline_comment|// If no pci_dev then use virtual bus
r_if
c_cond
(paren
id|hwdev
op_eq
l_int|NULL
)paren
id|bus
op_assign
l_int|255
suffix:semicolon
r_else
(brace
macro_line|#ifdef CONFIG_PCI        
singleline_comment|// Get the iSeries bus # to use as an index
singleline_comment|// into the TCE table array
id|bus
op_assign
id|ISERIES_GET_BUS
c_func
(paren
id|hwdev
)paren
suffix:semicolon
macro_line|#else
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#endif /* CONFIG_PCI */
)brace
r_if
c_cond
(paren
id|bus
OG
l_int|255
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pci_unmap_single: invalid bus # %d&bslash;n&quot;
comma
id|bus
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_unmap_single:   hwdev = %08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|hwdev
)paren
suffix:semicolon
)brace
id|tbl
op_assign
id|tceTables
(braket
id|bus
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tbl
)paren
id|free_tces
c_func
(paren
id|tbl
comma
id|dma_handle
comma
id|order
comma
id|nPages
)paren
suffix:semicolon
)brace
singleline_comment|// Figure out how many TCEs are actually going to be required
singleline_comment|// to map this scatterlist.  This code is not optimal.  It 
singleline_comment|// takes into account the case where entry n ends in the same
singleline_comment|// page in which entry n+1 starts.  It does not handle the 
singleline_comment|// general case of entry n ending in the same page in which 
singleline_comment|// entry m starts.   
DECL|function|num_tces_sg
r_static
r_int
r_int
id|num_tces_sg
c_func
(paren
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
)paren
(brace
r_int
r_int
id|nTces
comma
id|numPages
comma
id|startPage
comma
id|endPage
comma
id|prevEndPage
suffix:semicolon
r_int
id|i
suffix:semicolon
id|prevEndPage
op_assign
l_int|0
suffix:semicolon
id|nTces
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nents
suffix:semicolon
op_increment
id|i
)paren
(brace
singleline_comment|// Compute the starting page number and
singleline_comment|// the ending page number for this entry
id|startPage
op_assign
(paren
r_int
r_int
)paren
id|sg-&gt;address
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|endPage
op_assign
(paren
(paren
r_int
r_int
)paren
id|sg-&gt;address
op_plus
id|sg-&gt;length
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|numPages
op_assign
id|endPage
op_minus
id|startPage
op_plus
l_int|1
suffix:semicolon
singleline_comment|// Simple optimization: if the previous entry ended
singleline_comment|// in the same page in which this entry starts
singleline_comment|// then we can reduce the required pages by one.
singleline_comment|// This matches assumptions in fill_scatterlist_sg and
singleline_comment|// create_tces_sg
r_if
c_cond
(paren
id|startPage
op_eq
id|prevEndPage
)paren
op_decrement
id|numPages
suffix:semicolon
id|nTces
op_add_assign
id|numPages
suffix:semicolon
id|prevEndPage
op_assign
id|endPage
suffix:semicolon
id|sg
op_increment
suffix:semicolon
)brace
r_return
id|nTces
suffix:semicolon
)brace
singleline_comment|// Fill in the dma data in the scatterlist
singleline_comment|// return the number of dma sg entries created
DECL|function|fill_scatterlist_sg
r_static
r_int
id|fill_scatterlist_sg
c_func
(paren
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
comma
id|dma_addr_t
id|dma_addr
comma
r_int
r_int
id|numTces
)paren
(brace
r_struct
id|scatterlist
op_star
id|dma_sg
suffix:semicolon
id|u32
id|cur_start_dma
suffix:semicolon
r_int
r_int
id|cur_len_dma
comma
id|cur_end_virt
comma
id|uaddr
suffix:semicolon
r_int
id|num_dma_ents
suffix:semicolon
id|dma_sg
op_assign
id|sg
suffix:semicolon
id|num_dma_ents
op_assign
l_int|1
suffix:semicolon
singleline_comment|// Process the first sg entry
id|cur_start_dma
op_assign
id|dma_addr
op_plus
(paren
(paren
r_int
r_int
)paren
id|sg-&gt;address
op_amp
(paren
op_complement
id|PAGE_MASK
)paren
)paren
suffix:semicolon
id|cur_len_dma
op_assign
id|sg-&gt;length
suffix:semicolon
singleline_comment|// cur_end_virt holds the address of the byte immediately after the
singleline_comment|// end of the current buffer.
id|cur_end_virt
op_assign
(paren
r_int
r_int
)paren
id|sg-&gt;address
op_plus
id|cur_len_dma
suffix:semicolon
singleline_comment|// Later code assumes that unused sg-&gt;dma_address and sg-&gt;dma_length
singleline_comment|// fields will be zero.  Other archs seem to assume that the user
singleline_comment|// (device driver) guarantees that...I don&squot;t want to depend on that
id|sg-&gt;dma_address
op_assign
id|sg-&gt;dma_length
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Process the rest of the sg entries
r_while
c_loop
(paren
op_decrement
id|nents
)paren
(brace
op_increment
id|sg
suffix:semicolon
singleline_comment|// Clear possibly unused fields. Note: sg &gt;= dma_sg so
singleline_comment|// this can&squot;t be clearing a field we&squot;ve already set
id|sg-&gt;dma_address
op_assign
id|sg-&gt;dma_length
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Check if it is possible to make this next entry
singleline_comment|// contiguous (in dma space) with the previous entry.
singleline_comment|// The entries can be contiguous in dma space if
singleline_comment|// the previous entry ends immediately before the
singleline_comment|// start of the current entry (in virtual space)
singleline_comment|// or if the previous entry ends at a page boundary
singleline_comment|// and the current entry starts at a page boundary.
id|uaddr
op_assign
(paren
r_int
r_int
)paren
id|sg-&gt;address
suffix:semicolon
r_if
c_cond
(paren
(paren
id|uaddr
op_ne
id|cur_end_virt
)paren
op_logical_and
(paren
(paren
(paren
id|uaddr
op_or
id|cur_end_virt
)paren
op_amp
(paren
op_complement
id|PAGE_MASK
)paren
)paren
op_logical_or
(paren
(paren
id|uaddr
op_amp
id|PAGE_MASK
)paren
op_eq
(paren
(paren
id|cur_end_virt
op_minus
l_int|1
)paren
op_amp
id|PAGE_MASK
)paren
)paren
)paren
)paren
(brace
singleline_comment|// This entry can not be contiguous in dma space.
singleline_comment|// save the previous dma entry and start a new one
id|dma_sg-&gt;dma_address
op_assign
id|cur_start_dma
suffix:semicolon
id|dma_sg-&gt;dma_length
op_assign
id|cur_len_dma
suffix:semicolon
op_increment
id|dma_sg
suffix:semicolon
op_increment
id|num_dma_ents
suffix:semicolon
id|cur_start_dma
op_add_assign
id|cur_len_dma
op_minus
l_int|1
suffix:semicolon
singleline_comment|// If the previous entry ends and this entry starts
singleline_comment|// in the same page then they share a tce.  In that
singleline_comment|// case don&squot;t bump cur_start_dma to the next page 
singleline_comment|// in dma space.  This matches assumptions made in
singleline_comment|// num_tces_sg and create_tces_sg.
r_if
c_cond
(paren
(paren
id|uaddr
op_amp
id|PAGE_MASK
)paren
op_eq
(paren
(paren
id|cur_end_virt
op_minus
l_int|1
)paren
op_amp
id|PAGE_MASK
)paren
)paren
id|cur_start_dma
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_else
id|cur_start_dma
op_assign
id|PAGE_ALIGN
c_func
(paren
id|cur_start_dma
op_plus
l_int|1
)paren
suffix:semicolon
id|cur_start_dma
op_add_assign
(paren
id|uaddr
op_amp
(paren
op_complement
id|PAGE_MASK
)paren
)paren
suffix:semicolon
id|cur_len_dma
op_assign
l_int|0
suffix:semicolon
)brace
singleline_comment|// Accumulate the length of this entry for the next 
singleline_comment|// dma entry
id|cur_len_dma
op_add_assign
id|sg-&gt;length
suffix:semicolon
id|cur_end_virt
op_assign
id|uaddr
op_plus
id|sg-&gt;length
suffix:semicolon
)brace
singleline_comment|// Fill in the last dma entry
id|dma_sg-&gt;dma_address
op_assign
id|cur_start_dma
suffix:semicolon
id|dma_sg-&gt;dma_length
op_assign
id|cur_len_dma
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
(paren
id|cur_start_dma
op_plus
id|cur_len_dma
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
)paren
op_minus
(paren
id|dma_addr
op_rshift
id|PAGE_SHIFT
)paren
op_plus
l_int|1
)paren
op_ne
id|numTces
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fill_scatterlist_sg: numTces %ld, used tces %d&bslash;n&quot;
comma
id|numTces
comma
(paren
r_int
)paren
(paren
(paren
(paren
id|cur_start_dma
op_plus
id|cur_len_dma
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
)paren
op_minus
(paren
id|dma_addr
op_rshift
id|PAGE_SHIFT
)paren
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_return
id|num_dma_ents
suffix:semicolon
)brace
singleline_comment|// Call the hypervisor to create the TCE entries.
singleline_comment|// return the number of TCEs created
DECL|function|create_tces_sg
r_static
id|dma_addr_t
id|create_tces_sg
c_func
(paren
r_struct
id|TceTable
op_star
id|tbl
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
comma
r_int
id|numTces
comma
r_int
id|tceType
comma
r_int
id|direction
)paren
(brace
r_int
id|order
comma
id|i
comma
id|j
suffix:semicolon
r_int
r_int
id|startPage
comma
id|endPage
comma
id|prevEndPage
comma
id|numPages
comma
id|uaddr
suffix:semicolon
r_int
id|tcenum
comma
id|starttcenum
suffix:semicolon
id|dma_addr_t
id|dmaAddr
suffix:semicolon
id|dmaAddr
op_assign
id|NO_TCE
suffix:semicolon
id|order
op_assign
id|get_order
c_func
(paren
id|numTces
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
singleline_comment|// allocate a block of tces
id|tcenum
op_assign
id|alloc_tce_range
c_func
(paren
id|tbl
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tcenum
op_ne
op_minus
l_int|1
)paren
(brace
id|tcenum
op_add_assign
id|tbl-&gt;startOffset
suffix:semicolon
id|starttcenum
op_assign
id|tcenum
suffix:semicolon
id|dmaAddr
op_assign
id|tcenum
op_lshift
id|PAGE_SHIFT
suffix:semicolon
id|prevEndPage
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|nents
suffix:semicolon
op_increment
id|j
)paren
(brace
id|startPage
op_assign
(paren
r_int
r_int
)paren
id|sg-&gt;address
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|endPage
op_assign
(paren
(paren
r_int
r_int
)paren
id|sg-&gt;address
op_plus
id|sg-&gt;length
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|numPages
op_assign
id|endPage
op_minus
id|startPage
op_plus
l_int|1
suffix:semicolon
id|uaddr
op_assign
(paren
r_int
r_int
)paren
id|sg-&gt;address
suffix:semicolon
singleline_comment|// If the previous entry ended in the same page that
singleline_comment|// the current page starts then they share that
singleline_comment|// tce and we reduce the number of tces we need
singleline_comment|// by one.  This matches assumptions made in
singleline_comment|// num_tces_sg and fill_scatterlist_sg
r_if
c_cond
(paren
id|startPage
op_eq
id|prevEndPage
)paren
(brace
op_decrement
id|numPages
suffix:semicolon
id|uaddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numPages
suffix:semicolon
op_increment
id|i
)paren
(brace
id|build_tce
c_func
(paren
id|tbl
comma
id|tcenum
comma
id|uaddr
comma
id|tceType
comma
id|direction
)paren
suffix:semicolon
op_increment
id|tcenum
suffix:semicolon
id|uaddr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|prevEndPage
op_assign
id|endPage
suffix:semicolon
id|sg
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|tcenum
op_minus
id|starttcenum
)paren
op_ne
id|numTces
)paren
id|printk
c_func
(paren
l_string|&quot;create_tces_sg: numTces %d, tces used %d&bslash;n&quot;
comma
id|numTces
comma
(paren
r_int
)paren
(paren
id|tcenum
op_minus
id|starttcenum
)paren
)paren
suffix:semicolon
)brace
r_return
id|dmaAddr
suffix:semicolon
)brace
DECL|function|pci_map_sg
r_int
id|pci_map_sg
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
comma
r_int
id|direction
)paren
(brace
r_struct
id|TceTable
op_star
id|tbl
suffix:semicolon
r_int
id|bus
comma
id|numTces
suffix:semicolon
r_int
id|tceType
comma
id|num_dma
suffix:semicolon
id|dma_addr_t
id|dma_handle
suffix:semicolon
singleline_comment|// Fast path for a single entry scatterlist
r_if
c_cond
(paren
id|nents
op_eq
l_int|1
)paren
(brace
id|sg-&gt;dma_address
op_assign
id|pci_map_single
c_func
(paren
id|hwdev
comma
id|sg-&gt;address
comma
id|sg-&gt;length
comma
id|direction
)paren
suffix:semicolon
id|sg-&gt;dma_length
op_assign
id|sg-&gt;length
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// If no pci_dev then use virtual bus
r_if
c_cond
(paren
id|hwdev
op_eq
l_int|NULL
)paren
(brace
id|bus
op_assign
l_int|255
suffix:semicolon
id|tceType
op_assign
id|TCE_VB
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef CONFIG_PCI        
singleline_comment|// Get the iSeries bus # to use as an index
singleline_comment|// into the TCE table array
id|bus
op_assign
id|ISERIES_GET_BUS
c_func
(paren
id|hwdev
)paren
suffix:semicolon
id|tceType
op_assign
id|TCE_PCI
suffix:semicolon
macro_line|#else
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#endif /* CONFIG_PCI */
)brace
id|tbl
op_assign
id|tceTables
(braket
id|bus
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tbl
)paren
(brace
singleline_comment|// Compute the number of tces required
id|numTces
op_assign
id|num_tces_sg
c_func
(paren
id|sg
comma
id|nents
)paren
suffix:semicolon
singleline_comment|// Create the tces and get the dma address
id|dma_handle
op_assign
id|create_tces_sg
c_func
(paren
id|tbl
comma
id|sg
comma
id|nents
comma
id|numTces
comma
id|tceType
comma
id|direction
)paren
suffix:semicolon
singleline_comment|// Fill in the dma scatterlist
id|num_dma
op_assign
id|fill_scatterlist_sg
c_func
(paren
id|sg
comma
id|nents
comma
id|dma_handle
comma
id|numTces
)paren
suffix:semicolon
)brace
r_return
id|num_dma
suffix:semicolon
)brace
DECL|function|pci_unmap_sg
r_void
id|pci_unmap_sg
c_func
(paren
r_struct
id|pci_dev
op_star
id|hwdev
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nelms
comma
r_int
id|direction
)paren
(brace
r_struct
id|TceTable
op_star
id|tbl
suffix:semicolon
r_int
id|order
comma
id|numTces
comma
id|bus
comma
id|i
suffix:semicolon
id|dma_addr_t
id|dma_end_page
comma
id|dma_start_page
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|PCI_DMA_NONE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|dma_start_page
op_assign
id|sg-&gt;dma_address
op_amp
id|PAGE_MASK
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|nelms
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
)paren
(brace
r_int
id|k
op_assign
id|i
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sg
(braket
id|k
)braket
dot
id|dma_length
)paren
(brace
id|dma_end_page
op_assign
(paren
id|sg
(braket
id|k
)braket
dot
id|dma_address
op_plus
id|sg
(braket
id|k
)braket
dot
id|dma_length
op_minus
l_int|1
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|numTces
op_assign
(paren
(paren
id|dma_end_page
op_minus
id|dma_start_page
)paren
op_rshift
id|PAGE_SHIFT
)paren
op_plus
l_int|1
suffix:semicolon
id|order
op_assign
id|get_order
c_func
(paren
id|numTces
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
singleline_comment|// If no pci_dev then use virtual bus
r_if
c_cond
(paren
id|hwdev
op_eq
l_int|NULL
)paren
id|bus
op_assign
l_int|255
suffix:semicolon
r_else
(brace
macro_line|#ifdef CONFIG_PCI        
singleline_comment|// Get the iSeries bus # to use as an index
singleline_comment|// into the TCE table array
id|bus
op_assign
id|ISERIES_GET_BUS
c_func
(paren
id|hwdev
)paren
suffix:semicolon
macro_line|#else
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#endif /* CONFIG_PCI */
)brace
r_if
c_cond
(paren
id|bus
OG
l_int|255
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pci_unmap_sg: invalid bus # %d&bslash;n&quot;
comma
id|bus
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pci_unmap_sg:   hwdev = %08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|hwdev
)paren
suffix:semicolon
)brace
id|tbl
op_assign
id|tceTables
(braket
id|bus
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tbl
)paren
id|free_tces
c_func
(paren
id|tbl
comma
id|dma_start_page
comma
id|order
comma
id|numTces
)paren
suffix:semicolon
)brace
eof
