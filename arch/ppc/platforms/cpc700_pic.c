multiline_comment|/*&n; * arch/ppc/platforms/cpc700_pic.c&n; * &n; * Interrupt controller support for IBM Spruce&n; *&n; * Authors: Mark Greer, Matt Porter, and Johnnie Peters&n; *&t;    mgreer@mvista.com&n; *          mporter@mvista.com&n; *          jpeters@mvista.com&n; *&n; * Copyright 2001-2002 MontaVista Software Inc.&n; *&n; * This program is free software; you can redistribute  it and/or modify it&n; * under  the terms of  the GNU General  Public License as published by the&n; * Free Software Foundation;  either version 2 of the  License, or (at your&n; * option) any later version.&n; *&n; * THIS  SOFTWARE  IS PROVIDED   ``AS  IS&squot;&squot; AND   ANY  EXPRESS OR   IMPLIED&n; * WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF&n; * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN&n; * NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,&n; * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT&n; * NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF&n; * USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON&n; * ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT&n; * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF&n; * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; *&n; * You should have received a copy of the  GNU General Public License along&n; * with this program; if not, write  to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &quot;cpc700.h&quot;
r_static
r_void
DECL|function|cpc700_unmask_irq
id|cpc700_unmask_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|tr_bits
suffix:semicolon
multiline_comment|/*&n;&t; * IRQ 31 is largest IRQ supported.&n;&t; * IRQs 17-19 are reserved.&n;&t; */
r_if
c_cond
(paren
(paren
id|irq
op_le
l_int|31
)paren
op_logical_and
(paren
(paren
id|irq
OL
l_int|17
)paren
op_logical_or
(paren
id|irq
OG
l_int|19
)paren
)paren
)paren
(brace
id|tr_bits
op_assign
id|CPC700_IN_32
c_func
(paren
id|CPC700_UIC_UICTR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tr_bits
op_amp
(paren
l_int|1
op_lshift
(paren
l_int|31
op_minus
id|irq
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* level trigger interrupt, clear bit in status&n;&t;&t;&t; * register */
id|CPC700_OUT_32
c_func
(paren
id|CPC700_UIC_UICSR
comma
l_int|1
op_lshift
(paren
l_int|31
op_minus
id|irq
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Know IRQ fits in entry 0 of ppc_cached_irq_mask[] */
id|ppc_cached_irq_mask
(braket
l_int|0
)braket
op_or_assign
id|CPC700_UIC_IRQ_BIT
c_func
(paren
id|irq
)paren
suffix:semicolon
id|CPC700_OUT_32
c_func
(paren
id|CPC700_UIC_UICER
comma
id|ppc_cached_irq_mask
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|cpc700_mask_irq
id|cpc700_mask_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
multiline_comment|/*&n;&t; * IRQ 31 is largest IRQ supported.&n;&t; * IRQs 17-19 are reserved.&n;&t; */
r_if
c_cond
(paren
(paren
id|irq
op_le
l_int|31
)paren
op_logical_and
(paren
(paren
id|irq
OL
l_int|17
)paren
op_logical_or
(paren
id|irq
OG
l_int|19
)paren
)paren
)paren
(brace
multiline_comment|/* Know IRQ fits in entry 0 of ppc_cached_irq_mask[] */
id|ppc_cached_irq_mask
(braket
l_int|0
)braket
op_and_assign
op_complement
id|CPC700_UIC_IRQ_BIT
c_func
(paren
id|irq
)paren
suffix:semicolon
id|CPC700_OUT_32
c_func
(paren
id|CPC700_UIC_UICER
comma
id|ppc_cached_irq_mask
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|cpc700_mask_and_ack_irq
id|cpc700_mask_and_ack_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|u_int
id|bit
suffix:semicolon
multiline_comment|/*&n;&t; * IRQ 31 is largest IRQ supported.&n;&t; * IRQs 17-19 are reserved.&n;&t; */
r_if
c_cond
(paren
(paren
id|irq
op_le
l_int|31
)paren
op_logical_and
(paren
(paren
id|irq
OL
l_int|17
)paren
op_logical_or
(paren
id|irq
OG
l_int|19
)paren
)paren
)paren
(brace
multiline_comment|/* Know IRQ fits in entry 0 of ppc_cached_irq_mask[] */
id|bit
op_assign
id|CPC700_UIC_IRQ_BIT
c_func
(paren
id|irq
)paren
suffix:semicolon
id|ppc_cached_irq_mask
(braket
l_int|0
)braket
op_and_assign
op_complement
id|bit
suffix:semicolon
id|CPC700_OUT_32
c_func
(paren
id|CPC700_UIC_UICER
comma
id|ppc_cached_irq_mask
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|CPC700_OUT_32
c_func
(paren
id|CPC700_UIC_UICSR
comma
id|bit
)paren
suffix:semicolon
multiline_comment|/* Write 1 clears IRQ */
)brace
r_return
suffix:semicolon
)brace
DECL|variable|cpc700_pic
r_static
r_struct
id|hw_interrupt_type
id|cpc700_pic
op_assign
(brace
l_string|&quot;CPC700 PIC&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
id|cpc700_unmask_irq
comma
id|cpc700_mask_irq
comma
id|cpc700_mask_and_ack_irq
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
id|__init
r_static
r_void
DECL|function|cpc700_pic_init_irq
id|cpc700_pic_init_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
multiline_comment|/* Set interrupt sense */
id|tmp
op_assign
id|CPC700_IN_32
c_func
(paren
id|CPC700_UIC_UICTR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpc700_irq_assigns
(braket
id|irq
)braket
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
(brace
id|tmp
op_and_assign
op_complement
id|CPC700_UIC_IRQ_BIT
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
r_else
(brace
id|tmp
op_or_assign
id|CPC700_UIC_IRQ_BIT
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
id|CPC700_OUT_32
c_func
(paren
id|CPC700_UIC_UICTR
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/* Set interrupt polarity */
id|tmp
op_assign
id|CPC700_IN_32
c_func
(paren
id|CPC700_UIC_UICPR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpc700_irq_assigns
(braket
id|irq
)braket
(braket
l_int|1
)braket
)paren
(brace
id|tmp
op_or_assign
id|CPC700_UIC_IRQ_BIT
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
r_else
(brace
id|tmp
op_and_assign
op_complement
id|CPC700_UIC_IRQ_BIT
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
id|CPC700_OUT_32
c_func
(paren
id|CPC700_UIC_UICPR
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/* Set interrupt critical */
id|tmp
op_assign
id|CPC700_IN_32
c_func
(paren
id|CPC700_UIC_UICCR
)paren
suffix:semicolon
id|tmp
op_or_assign
id|CPC700_UIC_IRQ_BIT
c_func
(paren
id|irq
)paren
suffix:semicolon
id|CPC700_OUT_32
c_func
(paren
id|CPC700_UIC_UICCR
comma
id|tmp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|__init
r_void
DECL|function|cpc700_init_IRQ
id|cpc700_init_IRQ
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|ppc_cached_irq_mask
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|CPC700_OUT_32
c_func
(paren
id|CPC700_UIC_UICER
comma
l_int|0x00000000
)paren
suffix:semicolon
multiline_comment|/* Disable all irq&squot;s */
id|CPC700_OUT_32
c_func
(paren
id|CPC700_UIC_UICSR
comma
l_int|0xffffffff
)paren
suffix:semicolon
multiline_comment|/* Clear cur intrs */
id|CPC700_OUT_32
c_func
(paren
id|CPC700_UIC_UICCR
comma
l_int|0xffffffff
)paren
suffix:semicolon
multiline_comment|/* Gen INT not MCP */
id|CPC700_OUT_32
c_func
(paren
id|CPC700_UIC_UICPR
comma
l_int|0x00000000
)paren
suffix:semicolon
multiline_comment|/* Active low */
id|CPC700_OUT_32
c_func
(paren
id|CPC700_UIC_UICTR
comma
l_int|0x00000000
)paren
suffix:semicolon
multiline_comment|/* Level Sensitive */
id|CPC700_OUT_32
c_func
(paren
id|CPC700_UIC_UICVR
comma
id|CPC700_UIC_UICVCR_0_HI
)paren
suffix:semicolon
multiline_comment|/* IRQ 0 is highest */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|17
suffix:semicolon
id|i
op_increment
)paren
(brace
id|irq_desc
(braket
id|i
)braket
dot
id|handler
op_assign
op_amp
id|cpc700_pic
suffix:semicolon
id|cpc700_pic_init_irq
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|20
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|irq_desc
(braket
id|i
)braket
dot
id|handler
op_assign
op_amp
id|cpc700_pic
suffix:semicolon
id|cpc700_pic_init_irq
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the highest IRQ that generating an interrupt, if any.&n; */
r_int
DECL|function|cpc700_get_irq
id|cpc700_get_irq
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|irq
op_assign
l_int|0
suffix:semicolon
id|u_int
id|irq_status
comma
id|irq_test
op_assign
l_int|1
suffix:semicolon
id|irq_status
op_assign
id|CPC700_IN_32
c_func
(paren
id|CPC700_UIC_UICMSR
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|irq_status
op_amp
id|irq_test
)paren
r_break
suffix:semicolon
id|irq
op_increment
suffix:semicolon
id|irq_test
op_lshift_assign
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|irq
OL
id|NR_IRQS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_eq
id|NR_IRQS
)paren
id|irq
op_assign
l_int|33
suffix:semicolon
r_return
(paren
l_int|31
op_minus
id|irq
)paren
suffix:semicolon
)brace
eof
