multiline_comment|/*&n; * BK Id: %F% %I% %G% %U% %#%&n; */
multiline_comment|/*&n; *  arch/ppc/platforms/setup.c&n; *&n; *  Copyright (C) 1995  Linus Torvalds&n; *  Adapted from &squot;alpha&squot; version by Gary Thomas&n; *  Modified by Cort Dougan (cort@cs.nmt.edu)&n; *&n; * Support for PReP (Motorola MTX/MVME)&n; * by Troy Benjegerdes (hozer@drgw.net)&n; */
multiline_comment|/*&n; * bootup setup stuff..&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/user.h&gt;
macro_line|#include &lt;linux/a.out.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/root_dev.h&gt;
macro_line|#include &lt;asm/sections.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/residual.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/cache.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/mk48t59.h&gt;
macro_line|#include &lt;asm/prep_nvram.h&gt;
macro_line|#include &lt;asm/raven.h&gt;
macro_line|#include &lt;asm/vga.h&gt;
macro_line|#include &lt;asm/time.h&gt;
macro_line|#include &lt;asm/mpc10x.h&gt;
macro_line|#include &lt;asm/i8259.h&gt;
macro_line|#include &lt;asm/open_pic.h&gt;
DECL|variable|ucSystemType
r_int
r_char
id|ucSystemType
suffix:semicolon
DECL|variable|ucBoardRev
r_int
r_char
id|ucBoardRev
suffix:semicolon
DECL|variable|ucBoardRevMaj
DECL|variable|ucBoardRevMin
r_int
r_char
id|ucBoardRevMaj
comma
id|ucBoardRevMin
suffix:semicolon
r_extern
r_int
r_int
id|mc146818_get_rtc_time
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|mc146818_set_rtc_time
c_func
(paren
r_int
r_int
id|nowtime
)paren
suffix:semicolon
r_extern
r_int
r_int
id|mk48t59_get_rtc_time
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|mk48t59_set_rtc_time
c_func
(paren
r_int
r_int
id|nowtime
)paren
suffix:semicolon
r_extern
r_int
r_char
id|prep_nvram_read_val
c_func
(paren
r_int
id|addr
)paren
suffix:semicolon
r_extern
r_void
id|prep_nvram_write_val
c_func
(paren
r_int
id|addr
comma
r_int
r_char
id|val
)paren
suffix:semicolon
r_extern
r_int
r_char
id|rs_nvram_read_val
c_func
(paren
r_int
id|addr
)paren
suffix:semicolon
r_extern
r_void
id|rs_nvram_write_val
c_func
(paren
r_int
id|addr
comma
r_int
r_char
id|val
)paren
suffix:semicolon
r_extern
r_void
id|ibm_prep_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|prep_find_bridges
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_char
id|saved_command_line
(braket
)braket
suffix:semicolon
DECL|variable|_prep_type
r_int
id|_prep_type
suffix:semicolon
DECL|macro|cached_21
mdefine_line|#define cached_21&t;(((char *)(ppc_cached_irq_mask))[3])
DECL|macro|cached_A1
mdefine_line|#define cached_A1&t;(((char *)(ppc_cached_irq_mask))[2])
multiline_comment|/* for the mac fs */
DECL|variable|boot_dev
id|kdev_t
id|boot_dev
suffix:semicolon
macro_line|#ifdef CONFIG_SOUND_CS4232 
DECL|variable|ppc_cs4232_dma
DECL|variable|ppc_cs4232_dma2
r_int
id|ppc_cs4232_dma
comma
id|ppc_cs4232_dma2
suffix:semicolon
macro_line|#endif
r_extern
id|PTE
op_star
id|Hash
comma
op_star
id|Hash_end
suffix:semicolon
r_extern
r_int
r_int
id|Hash_size
comma
id|Hash_mask
suffix:semicolon
r_extern
r_int
id|probingmem
suffix:semicolon
r_extern
r_int
r_int
id|loops_per_jiffy
suffix:semicolon
macro_line|#ifdef CONFIG_SOUND_CS4232 
DECL|variable|ppc_cs4232_dma
id|EXPORT_SYMBOL
c_func
(paren
id|ppc_cs4232_dma
)paren
suffix:semicolon
DECL|variable|ppc_cs4232_dma2
id|EXPORT_SYMBOL
c_func
(paren
id|ppc_cs4232_dma2
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
id|__prep
DECL|function|prep_show_cpuinfo
id|prep_show_cpuinfo
c_func
(paren
r_struct
id|seq_file
op_star
id|m
)paren
(brace
r_extern
r_char
op_star
id|Motherboard_map_name
suffix:semicolon
r_int
id|cachew
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;machine&bslash;t&bslash;t: PReP %s&bslash;n&quot;
comma
id|Motherboard_map_name
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|_prep_type
)paren
(brace
r_case
id|_PREP_IBM
suffix:colon
id|cachew
op_assign
id|inw
c_func
(paren
l_int|0x80c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachew
op_amp
(paren
l_int|1
op_lshift
l_int|6
)paren
)paren
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;Upgrade CPU&bslash;n&quot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;L2&bslash;t&bslash;t: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cachew
op_amp
(paren
l_int|1
op_lshift
l_int|7
)paren
)paren
(brace
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;not present&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|no_l2
suffix:semicolon
)brace
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;%sKb,&quot;
comma
(paren
id|cachew
op_amp
(paren
l_int|1
op_lshift
l_int|10
)paren
)paren
ques
c_cond
l_string|&quot;512&quot;
suffix:colon
l_string|&quot;256&quot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;%ssync&bslash;n&quot;
comma
(paren
id|cachew
op_amp
(paren
l_int|1
op_lshift
l_int|15
)paren
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;a&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_PREP_Motorola
suffix:colon
id|cachew
op_assign
op_star
(paren
(paren
r_int
r_char
op_star
)paren
id|CACHECRBA
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;L2&bslash;t&bslash;t: &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cachew
op_amp
id|L2CACHE_MASK
)paren
(brace
r_case
id|L2CACHE_512KB
suffix:colon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;512Kb&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|L2CACHE_256KB
suffix:colon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;256Kb&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|L2CACHE_1MB
suffix:colon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;1MB&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|L2CACHE_NONE
suffix:colon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;none&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|no_l2
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;%x&bslash;n&quot;
comma
id|cachew
)paren
suffix:semicolon
)brace
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;, parity %s&quot;
comma
(paren
id|cachew
op_amp
id|L2CACHE_PARITY
)paren
ques
c_cond
l_string|&quot;enabled&quot;
suffix:colon
l_string|&quot;disabled&quot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot; SRAM:&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
(paren
(paren
id|cachew
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
)paren
op_amp
op_complement
(paren
l_int|0x3
)paren
)paren
(brace
r_case
l_int|1
suffix:colon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;synchronous,parity,flow-through&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;asynchronous,no parity&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;asynchronous,parity&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;synchronous,pipelined,no parity&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|no_l2
suffix:colon
macro_line|#ifdef CONFIG_PREP_RESIDUAL
r_if
c_cond
(paren
id|res-&gt;ResidualLength
op_ne
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* print info about SIMMs */
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;simms&bslash;t&bslash;t: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|res-&gt;ActualNumMemories
)paren
op_logical_and
(paren
id|i
OL
id|MAX_MEMS
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|res-&gt;Memories
(braket
id|i
)braket
dot
id|SIMMSize
op_ne
l_int|0
)paren
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;%d:%ldM &quot;
comma
id|i
comma
(paren
id|res-&gt;Memories
(braket
id|i
)braket
dot
id|SIMMSize
OG
l_int|1024
)paren
ques
c_cond
id|res-&gt;Memories
(braket
id|i
)braket
dot
id|SIMMSize
op_rshift
l_int|20
suffix:colon
id|res-&gt;Memories
(braket
id|i
)braket
dot
id|SIMMSize
)paren
suffix:semicolon
)brace
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
id|__prep
DECL|function|prep_show_percpuinfo
id|prep_show_percpuinfo
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_int
id|i
)paren
(brace
multiline_comment|/* PREP&squot;s without residual data will give incorrect values here */
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;clock&bslash;t&bslash;t: &quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PREP_RESIDUAL&t;
r_if
c_cond
(paren
id|res-&gt;ResidualLength
)paren
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;%ldMHz&bslash;n&quot;
comma
(paren
id|res-&gt;VitalProductData.ProcessorHz
OG
l_int|1024
)paren
ques
c_cond
id|res-&gt;VitalProductData.ProcessorHz
op_div
l_int|1000000
suffix:colon
id|res-&gt;VitalProductData.ProcessorHz
)paren
suffix:semicolon
r_else
macro_line|#endif /* CONFIG_PREP_RESIDUAL */
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;???&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SOUND_CS4232 
DECL|function|masktoint
r_static
r_int
id|__init
id|masktoint
c_func
(paren
r_int
r_int
id|i
)paren
(brace
r_int
id|t
op_assign
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|i
op_rshift
op_increment
id|t
)paren
suffix:semicolon
r_return
(paren
id|t
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ppc_cs4232_dma and ppc_cs4232_dma2 are used in include/asm/dma.h&n; * to distinguish sound dma-channels from others. This is because &n; * blocksize on 16 bit dma-channels 5,6,7 is 128k, but&n; * the cs4232.c uses 64k like on 8 bit dma-channels 0,1,2,3&n; */
DECL|function|prep_init_sound
r_static
r_void
id|__init
id|prep_init_sound
c_func
(paren
r_void
)paren
(brace
id|PPC_DEVICE
op_star
id|audiodevice
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Get the needed resource informations from residual data.&n;&t; * &n;&t; */
macro_line|#ifdef CONFIG_PREP_RESIDUAL
id|audiodevice
op_assign
id|residual_find_device
c_func
(paren
op_complement
l_int|0
comma
l_int|NULL
comma
id|MultimediaController
comma
id|AudioController
comma
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|audiodevice
op_ne
l_int|NULL
)paren
(brace
id|PnP_TAG_PACKET
op_star
id|pkt
suffix:semicolon
id|pkt
op_assign
id|PnP_find_packet
c_func
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|res-&gt;DevicePnPHeap
(braket
id|audiodevice-&gt;AllocatedOffset
)braket
comma
id|S5_Packet
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt
op_ne
l_int|NULL
)paren
id|ppc_cs4232_dma
op_assign
id|masktoint
c_func
(paren
id|pkt-&gt;S5_Pack.DMAMask
)paren
suffix:semicolon
id|pkt
op_assign
id|PnP_find_packet
c_func
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|res-&gt;DevicePnPHeap
(braket
id|audiodevice-&gt;AllocatedOffset
)braket
comma
id|S5_Packet
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt
op_ne
l_int|NULL
)paren
id|ppc_cs4232_dma2
op_assign
id|masktoint
c_func
(paren
id|pkt-&gt;S5_Pack.DMAMask
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * These are the PReP specs&squot; defaults for the cs4231.  We use these&n;&t; * as fallback incase we don&squot;t have residual data.&n;&t; * At least the IBM Thinkpad 850 with IDE DMA Channels at 6 and 7 &n;&t; * will use the other values.&n;&t; */
r_if
c_cond
(paren
id|audiodevice
op_eq
l_int|NULL
)paren
(brace
r_switch
c_cond
(paren
id|_prep_type
)paren
(brace
r_case
id|_PREP_IBM
suffix:colon
id|ppc_cs4232_dma
op_assign
l_int|1
suffix:semicolon
id|ppc_cs4232_dma2
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ppc_cs4232_dma
op_assign
l_int|6
suffix:semicolon
id|ppc_cs4232_dma2
op_assign
l_int|7
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Find a way to push these informations to the cs4232 driver&n;&t; * Give it out with printk, when not in cmd_line?&n;&t; * Append it to  cmd_line and saved_command_line?&n;&t; * Format is cs4232=io,irq,dma,dma2&n;&t; */
)brace
macro_line|#endif /* CONFIG_SOUND_CS4232 */
multiline_comment|/*&n; * Fill out screen_info according to the residual data. This allows us to use&n; * at least vesafb.&n; */
r_static
r_void
id|__init
DECL|function|prep_init_vesa
id|prep_init_vesa
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined(CONFIG_PREP_RESIDUAL) &amp;&amp; &bslash;&n;&t;(defined(CONFIG_FB_VGA16) || defined(CONFIG_FB_VGA_16_MODULE) || &bslash;&n;&t; defined(CONFIG_FB_VESA))
id|PPC_DEVICE
op_star
id|vgadev
suffix:semicolon
id|vgadev
op_assign
id|residual_find_device
c_func
(paren
op_complement
l_int|0
comma
l_int|NULL
comma
id|DisplayController
comma
id|SVGAController
comma
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vgadev
op_ne
l_int|NULL
)paren
(brace
id|PnP_TAG_PACKET
op_star
id|pkt
suffix:semicolon
id|pkt
op_assign
id|PnP_find_large_vendor_packet
c_func
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|res-&gt;DevicePnPHeap
(braket
id|vgadev-&gt;AllocatedOffset
)braket
comma
l_int|0x04
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* 0x04 = Display Tag */
r_if
c_cond
(paren
id|pkt
op_ne
l_int|NULL
)paren
(brace
r_int
r_char
op_star
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
id|pkt
suffix:semicolon
r_if
c_cond
(paren
id|ptr
(braket
l_int|4
)braket
)paren
(brace
multiline_comment|/* graphics mode */
id|screen_info.orig_video_isVGA
op_assign
id|VIDEO_TYPE_VLFB
suffix:semicolon
id|screen_info.lfb_depth
op_assign
id|ptr
(braket
l_int|4
)braket
op_star
l_int|8
suffix:semicolon
id|screen_info.lfb_width
op_assign
id|swab16
c_func
(paren
op_star
(paren
r_int
op_star
)paren
(paren
id|ptr
op_plus
l_int|6
)paren
)paren
suffix:semicolon
id|screen_info.lfb_height
op_assign
id|swab16
c_func
(paren
op_star
(paren
r_int
op_star
)paren
(paren
id|ptr
op_plus
l_int|8
)paren
)paren
suffix:semicolon
id|screen_info.lfb_linelength
op_assign
id|swab16
c_func
(paren
op_star
(paren
r_int
op_star
)paren
(paren
id|ptr
op_plus
l_int|10
)paren
)paren
suffix:semicolon
id|screen_info.lfb_base
op_assign
id|swab32
c_func
(paren
op_star
(paren
r_int
op_star
)paren
(paren
id|ptr
op_plus
l_int|12
)paren
)paren
suffix:semicolon
id|screen_info.lfb_size
op_assign
id|swab32
c_func
(paren
op_star
(paren
r_int
op_star
)paren
(paren
id|ptr
op_plus
l_int|20
)paren
)paren
op_div
l_int|65536
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* CONFIG_PREP_RESIDUAL */
)brace
r_static
r_void
id|__init
DECL|function|prep_setup_arch
id|prep_setup_arch
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|reg
suffix:semicolon
multiline_comment|/* init to some ~sane value until calibrate_delay() runs */
id|loops_per_jiffy
op_assign
l_int|50000000
suffix:semicolon
multiline_comment|/* Lookup PCI host bridges */
id|prep_find_bridges
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Set up floppy in PS/2 mode */
id|outb
c_func
(paren
l_int|0x09
comma
id|SIO_CONFIG_RA
)paren
suffix:semicolon
id|reg
op_assign
id|inb
c_func
(paren
id|SIO_CONFIG_RD
)paren
suffix:semicolon
id|reg
op_assign
(paren
id|reg
op_amp
l_int|0x3F
)paren
op_or
l_int|0x40
suffix:semicolon
id|outb
c_func
(paren
id|reg
comma
id|SIO_CONFIG_RD
)paren
suffix:semicolon
id|outb
c_func
(paren
id|reg
comma
id|SIO_CONFIG_RD
)paren
suffix:semicolon
multiline_comment|/* Have to write twice to change! */
multiline_comment|/* we should determine this according to what we find! -- Cort */
r_switch
c_cond
(paren
id|_prep_type
)paren
(brace
r_case
id|_PREP_IBM
suffix:colon
multiline_comment|/* Enable L2.  Assume we don&squot;t need to flush -- Cort*/
op_star
(paren
r_int
r_char
op_star
)paren
(paren
l_int|0x8000081c
)paren
op_or_assign
l_int|3
suffix:semicolon
id|ROOT_DEV
op_assign
id|Root_HDA1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_PREP_Motorola
suffix:colon
multiline_comment|/* Enable L2.  Assume we don&squot;t need to flush -- Cort*/
op_star
(paren
r_int
r_char
op_star
)paren
(paren
l_int|0x8000081c
)paren
op_or_assign
l_int|3
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_if
c_cond
(paren
id|initrd_start
)paren
id|ROOT_DEV
op_assign
id|Root_RAM0
suffix:semicolon
r_else
macro_line|#endif
macro_line|#ifdef CONFIG_ROOT_NFS
id|ROOT_DEV
op_assign
id|Root_NFS
suffix:semicolon
macro_line|#else
id|ROOT_DEV
op_assign
id|Root_SDA2
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
multiline_comment|/* Read in NVRAM data */
id|init_prep_nvram
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* if no bootargs, look in NVRAM */
r_if
c_cond
(paren
id|cmd_line
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
(brace
r_char
op_star
id|bootargs
suffix:semicolon
id|bootargs
op_assign
id|prep_nvram_get_var
c_func
(paren
l_string|&quot;bootargs&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootargs
op_ne
l_int|NULL
)paren
(brace
id|strcpy
c_func
(paren
id|cmd_line
comma
id|bootargs
)paren
suffix:semicolon
multiline_comment|/* again.. */
id|strcpy
c_func
(paren
id|saved_command_line
comma
id|cmd_line
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_SOUND_CS4232 
id|prep_init_sound
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SOUND_CS4232 */
id|prep_init_vesa
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|_prep_type
)paren
(brace
r_case
id|_PREP_Motorola
suffix:colon
id|raven_init
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|_PREP_IBM
suffix:colon
id|ibm_prep_init
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_VGA_CONSOLE
multiline_comment|/* vgacon.c needs to know where we mapped IO memory in io_block_mapping() */
id|vgacon_remap_base
op_assign
l_int|0xf0000000
suffix:semicolon
id|conswitchp
op_assign
op_amp
id|vga_con
suffix:semicolon
macro_line|#elif defined(CONFIG_DUMMY_CONSOLE)
id|conswitchp
op_assign
op_amp
id|dummy_con
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Determine the decrementer frequency from the residual data&n; * This allows for a faster boot as we do not need to calibrate the&n; * decrementer against another clock. This is important for embedded systems.&n; */
r_static
r_int
id|__init
DECL|function|prep_res_calibrate_decr
id|prep_res_calibrate_decr
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_PREP_RESIDUAL
r_int
r_int
id|freq
comma
id|divisor
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|res-&gt;VitalProductData.ProcessorBusHz
)paren
(brace
id|freq
op_assign
id|res-&gt;VitalProductData.ProcessorBusHz
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;time_init: decrementer frequency = %lu.%.6lu MHz&bslash;n&quot;
comma
(paren
id|freq
op_div
id|divisor
)paren
op_div
l_int|1000000
comma
(paren
id|freq
op_div
id|divisor
)paren
op_mod
l_int|1000000
)paren
suffix:semicolon
id|tb_to_us
op_assign
id|mulhwu_scale_factor
c_func
(paren
id|freq
op_div
id|divisor
comma
l_int|1000000
)paren
suffix:semicolon
id|tb_ticks_per_jiffy
op_assign
id|freq
op_div
id|HZ
op_div
id|divisor
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
macro_line|#endif&t;
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Uses the on-board timer to calibrate the on-chip decrementer register&n; * for prep systems.  On the pmac the OF tells us what the frequency is&n; * but on prep we have to figure it out.&n; * -- Cort&n; */
multiline_comment|/* Done with 3 interrupts: the first one primes the cache and the&n; * 2 following ones measure the interval. The precision of the method&n; * is still doubtful due to the short interval sampled.&n; */
DECL|variable|__initdata
r_static
r_volatile
r_int
id|calibrate_steps
id|__initdata
op_assign
l_int|3
suffix:semicolon
DECL|variable|__initdata
r_static
r_int
id|tbstamp
id|__initdata
op_assign
l_int|0
suffix:semicolon
r_static
r_void
id|__init
DECL|function|prep_calibrate_decr_handler
id|prep_calibrate_decr_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|t
comma
id|freq
suffix:semicolon
r_int
id|step
op_assign
op_decrement
id|calibrate_steps
suffix:semicolon
id|t
op_assign
id|get_tbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|step
OG
l_int|0
)paren
(brace
id|tbstamp
op_assign
id|t
suffix:semicolon
)brace
r_else
(brace
id|freq
op_assign
(paren
id|t
op_minus
id|tbstamp
)paren
op_star
id|HZ
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;time_init: decrementer frequency = %lu.%.6lu MHz&bslash;n&quot;
comma
id|freq
op_div
l_int|1000000
comma
id|freq
op_mod
l_int|1000000
)paren
suffix:semicolon
id|tb_ticks_per_jiffy
op_assign
id|freq
op_div
id|HZ
suffix:semicolon
id|tb_to_us
op_assign
id|mulhwu_scale_factor
c_func
(paren
id|freq
comma
l_int|1000000
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
id|__init
DECL|function|prep_calibrate_decr
id|prep_calibrate_decr
c_func
(paren
r_void
)paren
(brace
r_int
id|res
suffix:semicolon
multiline_comment|/* Try and get this from the residual data. */
id|res
op_assign
id|prep_res_calibrate_decr
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If we didn&squot;t get it from the residual data, try this. */
r_if
c_cond
(paren
id|res
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
DECL|macro|TIMER0_COUNT
mdefine_line|#define TIMER0_COUNT 0x40
DECL|macro|TIMER_CONTROL
mdefine_line|#define TIMER_CONTROL 0x43
multiline_comment|/* set timer to periodic mode */
id|outb_p
c_func
(paren
l_int|0x34
comma
id|TIMER_CONTROL
)paren
suffix:semicolon
multiline_comment|/* binary, mode 2, LSB/MSB, ch 0 */
multiline_comment|/* set the clock to ~100 Hz */
id|outb_p
c_func
(paren
id|LATCH
op_amp
l_int|0xff
comma
id|TIMER0_COUNT
)paren
suffix:semicolon
multiline_comment|/* LSB */
id|outb
c_func
(paren
id|LATCH
op_rshift
l_int|8
comma
id|TIMER0_COUNT
)paren
suffix:semicolon
multiline_comment|/* MSB */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
l_int|0
comma
id|prep_calibrate_decr_handler
comma
l_int|0
comma
l_string|&quot;timer&quot;
comma
l_int|NULL
)paren
op_ne
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Could not allocate timer IRQ!&quot;
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait for calibrate */
r_while
c_loop
(paren
id|calibrate_steps
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|free_irq
c_func
(paren
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
id|__init
DECL|function|mk48t59_init
id|mk48t59_init
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|tmp
suffix:semicolon
id|tmp
op_assign
id|ppc_md
dot
id|nvram_read_val
c_func
(paren
id|MK48T59_RTC_CONTROLB
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_amp
id|MK48T59_RTC_CB_STOP
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning: RTC was stopped, date will be wrong.&bslash;n&quot;
)paren
suffix:semicolon
id|ppc_md
dot
id|nvram_write_val
c_func
(paren
id|MK48T59_RTC_CONTROLB
comma
id|tmp
op_amp
op_complement
id|MK48T59_RTC_CB_STOP
)paren
suffix:semicolon
multiline_comment|/* Low frequency crystal oscillators may take a very long&n;&t;&t; * time to startup and stabilize. For now just ignore the&n;&t;&t; * the issue, but attempting to calibrate the decrementer&n;&t;&t; * from the RTC just after this wakeup is likely to be very &n;&t;&t; * inaccurate. Firmware should not allow to load&n;&t;&t; * the OS with the clock stopped anyway...&n;&t;&t; */
)brace
multiline_comment|/* Ensure that the clock registers are updated */
id|tmp
op_assign
id|ppc_md
dot
id|nvram_read_val
c_func
(paren
id|MK48T59_RTC_CONTROLA
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
(paren
id|MK48T59_RTC_CA_READ
op_or
id|MK48T59_RTC_CA_WRITE
)paren
suffix:semicolon
id|ppc_md
dot
id|nvram_write_val
c_func
(paren
id|MK48T59_RTC_CONTROLA
comma
id|tmp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We use the NVRAM RTC to time a second to calibrate the decrementer,&n; * the RTC registers have just been set up in the right state by the&n; * preceding routine.&n; */
r_static
r_void
id|__init
DECL|function|mk48t59_calibrate_decr
id|mk48t59_calibrate_decr
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|freq
suffix:semicolon
r_int
r_int
id|t1
suffix:semicolon
r_int
r_char
id|save_control
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_char
id|sec
suffix:semicolon
multiline_comment|/* Make sure the time is not stopped. */
id|save_control
op_assign
id|ppc_md
dot
id|nvram_read_val
c_func
(paren
id|MK48T59_RTC_CONTROLB
)paren
suffix:semicolon
id|ppc_md
dot
id|nvram_write_val
c_func
(paren
id|MK48T59_RTC_CONTROLA
comma
(paren
id|save_control
op_amp
(paren
op_complement
id|MK48T59_RTC_CB_STOP
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Now make sure the read bit is off so the value will change. */
id|save_control
op_assign
id|ppc_md
dot
id|nvram_read_val
c_func
(paren
id|MK48T59_RTC_CONTROLA
)paren
suffix:semicolon
id|save_control
op_and_assign
op_complement
id|MK48T59_RTC_CA_READ
suffix:semicolon
id|ppc_md
dot
id|nvram_write_val
c_func
(paren
id|MK48T59_RTC_CONTROLA
comma
id|save_control
)paren
suffix:semicolon
multiline_comment|/* Read the seconds value to see when it changes. */
id|sec
op_assign
id|ppc_md
dot
id|nvram_read_val
c_func
(paren
id|MK48T59_RTC_SECONDS
)paren
suffix:semicolon
multiline_comment|/* Actually this is bad for precision, we should have a loop in&n;&t; * which we only read the seconds counter. nvram_read_val writes&n;&t; * the address bytes on every call and this takes a lot of time.&n;&t; * Perhaps an nvram_wait_change method returning a time&n;&t; * stamp with a loop count as parameter would be the  solution.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1000000
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* may take up to 1 second... */
id|t1
op_assign
id|get_tbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppc_md
dot
id|nvram_read_val
c_func
(paren
id|MK48T59_RTC_SECONDS
)paren
op_ne
id|sec
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|sec
op_assign
id|ppc_md
dot
id|nvram_read_val
c_func
(paren
id|MK48T59_RTC_SECONDS
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1000000
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Should take up 1 second... */
id|freq
op_assign
id|get_tbl
c_func
(paren
)paren
op_minus
id|t1
suffix:semicolon
r_if
c_cond
(paren
id|ppc_md
dot
id|nvram_read_val
c_func
(paren
id|MK48T59_RTC_SECONDS
)paren
op_ne
id|sec
)paren
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;time_init: decrementer frequency = %lu.%.6lu MHz&bslash;n&quot;
comma
id|freq
op_div
l_int|1000000
comma
id|freq
op_mod
l_int|1000000
)paren
suffix:semicolon
id|tb_ticks_per_jiffy
op_assign
id|freq
op_div
id|HZ
suffix:semicolon
id|tb_to_us
op_assign
id|mulhwu_scale_factor
c_func
(paren
id|freq
comma
l_int|1000000
)paren
suffix:semicolon
)brace
r_static
r_void
id|__prep
DECL|function|prep_restart
id|prep_restart
c_func
(paren
r_char
op_star
id|cmd
)paren
(brace
r_int
r_int
id|i
op_assign
l_int|10000
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* set exception prefix high - to the prom */
id|_nmask_and_or_msr
c_func
(paren
l_int|0
comma
id|MSR_IP
)paren
suffix:semicolon
multiline_comment|/* make sure bit 0 (reset) is a 0 */
id|outb
c_func
(paren
id|inb
c_func
(paren
l_int|0x92
)paren
op_amp
op_complement
l_int|1L
comma
l_int|0x92
)paren
suffix:semicolon
multiline_comment|/* signal a reset to system control port A - soft reset */
id|outb
c_func
(paren
id|inb
c_func
(paren
l_int|0x92
)paren
op_or
l_int|1
comma
l_int|0x92
)paren
suffix:semicolon
r_while
c_loop
(paren
id|i
op_ne
l_int|0
)paren
id|i
op_increment
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;restart failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_static
r_void
id|__prep
DECL|function|prep_halt
id|prep_halt
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* set exception prefix high - to the prom */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
op_or
id|MSR_IP
)paren
suffix:semicolon
multiline_comment|/* make sure bit 0 (reset) is a 0 */
id|outb
c_func
(paren
id|inb
c_func
(paren
l_int|0x92
)paren
op_amp
op_complement
l_int|1L
comma
l_int|0x92
)paren
suffix:semicolon
multiline_comment|/* signal a reset to system control port A - soft reset */
id|outb
c_func
(paren
id|inb
c_func
(paren
l_int|0x92
)paren
op_or
l_int|1
comma
l_int|0x92
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Not reached&n;&t; */
)brace
multiline_comment|/*&n; * On IBM PReP&squot;s, power management is handled by a Signetics 87c750 behind the&n; * Utah component on the ISA bus. To access the 750 you must write a series of&n; * nibbles to port 0x82a (decoded by the Utah). This is described somewhat in&n; * the IBM Carolina Technical Specification.&n; * -Hollis&n; */
r_static
r_void
id|__prep
DECL|function|utah_sig87c750_setbit
id|utah_sig87c750_setbit
c_func
(paren
r_int
r_int
id|bytenum
comma
r_int
r_int
id|bitnum
comma
r_int
id|value
)paren
(brace
multiline_comment|/*&n;&t; * byte1: 0 0 0 1 0  d  a5 a4&n;&t; * byte2: 0 0 0 1 a3 a2 a1 a0&n;&t; *&n;&t; * d = the bit&squot;s value, enabled or disabled&n;&t; * (a5 a4 a3) = the byte number, minus 20&n;&t; * (a2 a1 a0) = the bit number&n;&t; *&n;&t; * example: set the 5th bit of byte 21 (21.5)&n;&t; *     a5 a4 a3 = 001 (byte 1)&n;&t; *     a2 a1 a0 = 101 (bit 5)&n;&t; *&n;&t; *     byte1 = 0001 0100 (0x14)&n;&t; *     byte2 = 0001 1101 (0x1d)&n;&t; */
r_int
r_char
id|byte1
op_assign
l_int|0x10
comma
id|byte2
op_assign
l_int|0x10
suffix:semicolon
r_const
r_int
r_int
id|pm_reg_1
op_assign
l_int|0x82a
suffix:semicolon
multiline_comment|/* ISA address */
multiline_comment|/* the 750&squot;s &squot;20.0&squot; is accessed as &squot;0.0&squot; through Utah (which adds 20) */
id|bytenum
op_sub_assign
l_int|20
suffix:semicolon
id|byte1
op_or_assign
(paren
op_logical_neg
op_logical_neg
id|value
)paren
op_lshift
l_int|2
suffix:semicolon
multiline_comment|/* set d */
id|byte1
op_or_assign
(paren
id|bytenum
op_rshift
l_int|1
)paren
op_amp
l_int|0x3
suffix:semicolon
multiline_comment|/* set a5, a4 */
id|byte2
op_or_assign
(paren
id|bytenum
op_amp
l_int|0x1
)paren
op_lshift
l_int|3
suffix:semicolon
multiline_comment|/* set a3 */
id|byte2
op_or_assign
id|bitnum
op_amp
l_int|0x7
suffix:semicolon
multiline_comment|/* set a2, a1, a0 */
id|outb
c_func
(paren
id|byte1
comma
id|pm_reg_1
)paren
suffix:semicolon
multiline_comment|/* first nibble */
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* important: let controller recover */
id|outb
c_func
(paren
id|byte2
comma
id|pm_reg_1
)paren
suffix:semicolon
multiline_comment|/* second nibble */
id|mb
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* important: let controller recover */
)brace
r_static
r_void
id|__prep
DECL|function|prep_power_off
id|prep_power_off
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|_prep_type
op_eq
id|_PREP_IBM
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* set exception prefix high - to the prom */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
op_or
id|MSR_IP
)paren
suffix:semicolon
id|utah_sig87c750_setbit
c_func
(paren
l_int|21
comma
l_int|5
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* set bit 21.5, &quot;PMEXEC_OFF&quot; */
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* not reached */
)brace
r_else
(brace
id|prep_halt
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
r_int
id|__prep
DECL|function|prep_irq_cannonicalize
id|prep_irq_cannonicalize
c_func
(paren
id|u_int
id|irq
)paren
(brace
r_if
c_cond
(paren
id|irq
op_eq
l_int|2
)paren
(brace
r_return
l_int|9
suffix:semicolon
)brace
r_else
(brace
r_return
id|irq
suffix:semicolon
)brace
)brace
r_static
r_void
id|__init
DECL|function|prep_init_IRQ
id|prep_init_IRQ
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|OpenPIC_Addr
op_ne
l_int|NULL
)paren
id|openpic_init
c_func
(paren
id|NUM_8259_INTERRUPTS
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_8259_INTERRUPTS
suffix:semicolon
id|i
op_increment
)paren
id|irq_desc
(braket
id|i
)braket
dot
id|handler
op_assign
op_amp
id|i8259_pic
suffix:semicolon
id|i8259_init
c_func
(paren
id|MPC10X_MAPA_PCI_INTACK_ADDR
)paren
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE)
multiline_comment|/*&n; * IDE stuff.&n; */
r_static
r_int
id|__prep
DECL|function|prep_ide_default_irq
id|prep_ide_default_irq
c_func
(paren
id|ide_ioreg_t
id|base
)paren
(brace
r_switch
c_cond
(paren
id|base
)paren
(brace
r_case
l_int|0x1f0
suffix:colon
r_return
l_int|13
suffix:semicolon
r_case
l_int|0x170
suffix:colon
r_return
l_int|13
suffix:semicolon
r_case
l_int|0x1e8
suffix:colon
r_return
l_int|11
suffix:semicolon
r_case
l_int|0x168
suffix:colon
r_return
l_int|10
suffix:semicolon
r_case
l_int|0xfff0
suffix:colon
r_return
l_int|14
suffix:semicolon
multiline_comment|/* MCP(N)750 ide0 */
r_case
l_int|0xffe0
suffix:colon
r_return
l_int|15
suffix:semicolon
multiline_comment|/* MCP(N)750 ide1 */
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_static
id|ide_ioreg_t
id|__prep
DECL|function|prep_ide_default_io_base
id|prep_ide_default_io_base
c_func
(paren
r_int
id|index
)paren
(brace
r_switch
c_cond
(paren
id|index
)paren
(brace
r_case
l_int|0
suffix:colon
r_return
l_int|0x1f0
suffix:semicolon
r_case
l_int|1
suffix:colon
r_return
l_int|0x170
suffix:semicolon
r_case
l_int|2
suffix:colon
r_return
l_int|0x1e8
suffix:semicolon
r_case
l_int|3
suffix:colon
r_return
l_int|0x168
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* PReP (MTX) support */
r_static
r_int
id|__init
DECL|function|smp_prep_probe
id|smp_prep_probe
c_func
(paren
r_void
)paren
(brace
r_extern
r_int
id|mot_multi
suffix:semicolon
r_if
c_cond
(paren
id|mot_multi
)paren
(brace
id|openpic_request_IPIs
c_func
(paren
)paren
suffix:semicolon
id|smp_hw_index
(braket
l_int|1
)braket
op_assign
l_int|1
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_void
id|__init
DECL|function|smp_prep_kick_cpu
id|smp_prep_kick_cpu
c_func
(paren
r_int
id|nr
)paren
(brace
op_star
(paren
r_int
r_int
op_star
)paren
id|KERNELBASE
op_assign
id|nr
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;dcbf 0,%0&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|KERNELBASE
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CPU1 reset, waiting&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_static
r_void
id|__init
DECL|function|smp_prep_setup_cpu
id|smp_prep_setup_cpu
c_func
(paren
r_int
id|cpu_nr
)paren
(brace
r_if
c_cond
(paren
id|OpenPIC_Addr
)paren
id|do_openpic_setup_cpu
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|__prepdata
r_static
r_struct
id|smp_ops_t
id|prep_smp_ops
id|__prepdata
op_assign
(brace
id|smp_openpic_message_pass
comma
id|smp_prep_probe
comma
id|smp_prep_kick_cpu
comma
id|smp_prep_setup_cpu
comma
dot
id|give_timebase
op_assign
id|smp_generic_give_timebase
comma
dot
id|take_timebase
op_assign
id|smp_generic_take_timebase
comma
)brace
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
multiline_comment|/*&n; * This finds the amount of physical ram and does necessary&n; * setup for prep.  This is pretty architecture specific so&n; * this will likely stay separate from the pmac.&n; * -- Cort&n; */
r_static
r_int
r_int
id|__init
DECL|function|prep_find_end_of_memory
id|prep_find_end_of_memory
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|total
op_assign
l_int|0
suffix:semicolon
r_extern
r_int
r_int
id|boot_mem_size
suffix:semicolon
macro_line|#ifdef CONFIG_PREP_RESIDUAL&t;
id|total
op_assign
id|res-&gt;TotalMemory
suffix:semicolon
macro_line|#endif&t;
r_if
c_cond
(paren
id|total
op_eq
l_int|0
op_logical_and
id|boot_mem_size
op_ne
l_int|0
)paren
id|total
op_assign
id|boot_mem_size
suffix:semicolon
r_else
r_if
c_cond
(paren
id|total
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * I need a way to probe the amount of memory if the residual&n;&t;&t; * data doesn&squot;t contain it. -- Cort&n;&t;&t; */
id|total
op_assign
l_int|0x02000000
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Ramsize from residual data was 0&quot;
l_string|&quot; -- defaulting to %ldM&bslash;n&quot;
comma
id|total
op_rshift
l_int|20
)paren
suffix:semicolon
)brace
r_return
(paren
id|total
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Setup the bat mappings we&squot;re going to load that cover&n; * the io areas.  RAM was mapped by mapin_ram().&n; * -- Cort&n; */
r_static
r_void
id|__init
DECL|function|prep_map_io
id|prep_map_io
c_func
(paren
r_void
)paren
(brace
id|io_block_mapping
c_func
(paren
l_int|0x80000000
comma
id|PREP_ISA_IO_BASE
comma
l_int|0x10000000
comma
id|_PAGE_IO
)paren
suffix:semicolon
id|io_block_mapping
c_func
(paren
l_int|0xf0000000
comma
id|PREP_ISA_MEM_BASE
comma
l_int|0x08000000
comma
id|_PAGE_IO
)paren
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|prep_request_io
id|prep_request_io
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_NVRAM
id|request_region
c_func
(paren
id|PREP_NVRAM_AS0
comma
l_int|0x8
comma
l_string|&quot;nvram&quot;
)paren
suffix:semicolon
macro_line|#endif
id|request_region
c_func
(paren
l_int|0x00
comma
l_int|0x20
comma
l_string|&quot;dma1&quot;
)paren
suffix:semicolon
id|request_region
c_func
(paren
l_int|0x40
comma
l_int|0x20
comma
l_string|&quot;timer&quot;
)paren
suffix:semicolon
id|request_region
c_func
(paren
l_int|0x80
comma
l_int|0x10
comma
l_string|&quot;dma page reg&quot;
)paren
suffix:semicolon
id|request_region
c_func
(paren
l_int|0xc0
comma
l_int|0x20
comma
l_string|&quot;dma2&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|prep_request_io
id|device_initcall
c_func
(paren
id|prep_request_io
)paren
suffix:semicolon
r_void
id|__init
DECL|function|prep_init
id|prep_init
c_func
(paren
r_int
r_int
id|r3
comma
r_int
r_int
id|r4
comma
r_int
r_int
id|r5
comma
r_int
r_int
id|r6
comma
r_int
r_int
id|r7
)paren
(brace
macro_line|#ifdef CONFIG_PREP_RESIDUAL&t;
multiline_comment|/* make a copy of residual data */
r_if
c_cond
(paren
id|r3
)paren
(brace
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|res
comma
(paren
r_void
op_star
)paren
(paren
id|r3
op_plus
id|KERNELBASE
)paren
comma
r_sizeof
(paren
id|RESIDUAL
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|isa_io_base
op_assign
id|PREP_ISA_IO_BASE
suffix:semicolon
id|isa_mem_base
op_assign
id|PREP_ISA_MEM_BASE
suffix:semicolon
id|pci_dram_offset
op_assign
id|PREP_PCI_DRAM_OFFSET
suffix:semicolon
id|ISA_DMA_THRESHOLD
op_assign
l_int|0x00ffffff
suffix:semicolon
id|DMA_MODE_READ
op_assign
l_int|0x44
suffix:semicolon
id|DMA_MODE_WRITE
op_assign
l_int|0x48
suffix:semicolon
multiline_comment|/* figure out what kind of prep workstation we are */
macro_line|#ifdef CONFIG_PREP_RESIDUAL&t;
r_if
c_cond
(paren
id|res-&gt;ResidualLength
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|res-&gt;VitalProductData.PrintableModel
comma
l_string|&quot;IBM&quot;
comma
l_int|3
)paren
)paren
id|_prep_type
op_assign
id|_PREP_IBM
suffix:semicolon
r_else
id|_prep_type
op_assign
id|_PREP_Motorola
suffix:semicolon
)brace
r_else
multiline_comment|/* assume motorola if no residual (netboot?) */
macro_line|#endif
(brace
id|_prep_type
op_assign
id|_PREP_Motorola
suffix:semicolon
)brace
id|ppc_md.setup_arch
op_assign
id|prep_setup_arch
suffix:semicolon
id|ppc_md.show_percpuinfo
op_assign
id|prep_show_percpuinfo
suffix:semicolon
id|ppc_md.show_cpuinfo
op_assign
id|prep_show_cpuinfo
suffix:semicolon
id|ppc_md.irq_cannonicalize
op_assign
id|prep_irq_cannonicalize
suffix:semicolon
id|ppc_md.init_IRQ
op_assign
id|prep_init_IRQ
suffix:semicolon
multiline_comment|/* this gets changed later on if we have an OpenPIC -- Cort */
id|ppc_md.get_irq
op_assign
id|i8259_irq
suffix:semicolon
id|ppc_md.restart
op_assign
id|prep_restart
suffix:semicolon
id|ppc_md.power_off
op_assign
id|prep_power_off
suffix:semicolon
id|ppc_md.halt
op_assign
id|prep_halt
suffix:semicolon
id|ppc_md.nvram_read_val
op_assign
id|prep_nvram_read_val
suffix:semicolon
id|ppc_md.nvram_write_val
op_assign
id|prep_nvram_write_val
suffix:semicolon
id|ppc_md.time_init
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|_prep_type
op_eq
id|_PREP_IBM
)paren
(brace
id|ppc_md.set_rtc_time
op_assign
id|mc146818_set_rtc_time
suffix:semicolon
id|ppc_md.get_rtc_time
op_assign
id|mc146818_get_rtc_time
suffix:semicolon
id|ppc_md.calibrate_decr
op_assign
id|prep_calibrate_decr
suffix:semicolon
)brace
r_else
(brace
id|ppc_md.set_rtc_time
op_assign
id|mk48t59_set_rtc_time
suffix:semicolon
id|ppc_md.get_rtc_time
op_assign
id|mk48t59_get_rtc_time
suffix:semicolon
id|ppc_md.calibrate_decr
op_assign
id|mk48t59_calibrate_decr
suffix:semicolon
id|ppc_md.time_init
op_assign
id|mk48t59_init
suffix:semicolon
)brace
id|ppc_md.find_end_of_memory
op_assign
id|prep_find_end_of_memory
suffix:semicolon
id|ppc_md.setup_io_mappings
op_assign
id|prep_map_io
suffix:semicolon
macro_line|#if defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE)
id|ppc_ide_md.default_irq
op_assign
id|prep_ide_default_irq
suffix:semicolon
id|ppc_ide_md.default_io_base
op_assign
id|prep_ide_default_io_base
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SMP
id|ppc_md.smp_ops
op_assign
op_amp
id|prep_smp_ops
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
)brace
eof
