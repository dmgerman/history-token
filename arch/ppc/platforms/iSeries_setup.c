multiline_comment|/*&n; *&n; *&n; *    Copyright (c) 2000 Mike Corrigan &lt;mikejc@us.ibm.com&gt;&n; *    Copyright (c) 1999-2000 Grant Erickson &lt;grant@lcse.umn.edu&gt;&n; *&n; *    Module name: iSeries_setup.c&n; *&n; *    Description:&n; *      Architecture- / platform-specific boot-time initialization code for&n; *      the IBM iSeries LPAR.  Adapted from original code by Grant Erickson and&n; *      code by Gary Thomas, Cort Dougan &lt;cort@fsmlabs.com&gt;, and Dan Malek&n; *      &lt;dan@net4x.com&gt;.&n; *&n; */
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/threads.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/param.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;linux/root_dev.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt;
macro_line|#include &lt;asm/time.h&gt;
macro_line|#include &quot;iSeries_setup.h&quot;
macro_line|#include &lt;asm/iSeries/LparData.h&gt;
macro_line|#include &lt;asm/iSeries/HvCallHpt.h&gt;
macro_line|#include &lt;asm/iSeries/HvLpConfig.h&gt;
macro_line|#include &lt;asm/iSeries/HvCallEvent.h&gt;
macro_line|#include &lt;asm/iSeries/HvCallSm.h&gt;
macro_line|#include &lt;asm/iSeries/ItLpQueue.h&gt;
macro_line|#include &lt;asm/iSeries/IoHriMainStore.h&gt;
macro_line|#include &lt;asm/iSeries/iSeries_proc.h&gt;
macro_line|#include &lt;asm/iSeries/pmc_proc.h&gt;
macro_line|#include &lt;asm/iSeries/mf.h&gt;
macro_line|#include &lt;asm/pci-bridge.h&gt;
macro_line|#include &lt;asm/iSeries/HvCallXm.h&gt;
macro_line|#include &lt;asm/iSeries/iSeries_fixup.h&gt;
macro_line|#include &lt;asm/iSeries/HvReleaseData.h&gt;
multiline_comment|/* Function Prototypes */
r_extern
r_void
m_abort
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|build_iSeries_Memory_Map
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|setup_iSeries_cache_sizes
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|iSeries_pci_Initialize
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|iSeries_show_cpuinfo
c_func
(paren
r_struct
id|seq_file
op_star
id|m
)paren
suffix:semicolon
r_static
r_int
id|iSeries_show_percpuinfo
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_int
id|i
)paren
suffix:semicolon
r_extern
r_struct
id|pci_ops
id|iSeries_pci_ops
suffix:semicolon
multiline_comment|/* Global Variables */
DECL|variable|iSeries_icache_line_size
r_int
r_int
id|iSeries_icache_line_size
op_assign
l_int|0
suffix:semicolon
DECL|variable|iSeries_dcache_line_size
r_int
r_int
id|iSeries_dcache_line_size
op_assign
l_int|0
suffix:semicolon
DECL|variable|iSeries_icache_lines_per_page
r_int
r_int
id|iSeries_icache_lines_per_page
op_assign
l_int|0
suffix:semicolon
DECL|variable|iSeries_dcache_lines_per_page
r_int
r_int
id|iSeries_dcache_lines_per_page
op_assign
l_int|0
suffix:semicolon
DECL|variable|iSeries_log_icache_line_size
r_int
r_int
id|iSeries_log_icache_line_size
op_assign
l_int|0
suffix:semicolon
DECL|variable|iSeries_log_dcache_line_size
r_int
r_int
id|iSeries_log_dcache_line_size
op_assign
l_int|0
suffix:semicolon
DECL|variable|procFreqHz
r_int
r_int
id|procFreqHz
op_assign
l_int|0
suffix:semicolon
DECL|variable|procFreqMhz
r_int
r_int
id|procFreqMhz
op_assign
l_int|0
suffix:semicolon
DECL|variable|procFreqMhzHundreths
r_int
r_int
id|procFreqMhzHundreths
op_assign
l_int|0
suffix:semicolon
DECL|variable|tbFreqHz
r_int
r_int
id|tbFreqHz
op_assign
l_int|0
suffix:semicolon
DECL|variable|tbFreqMhz
r_int
r_int
id|tbFreqMhz
op_assign
l_int|0
suffix:semicolon
DECL|variable|tbFreqMhzHundreths
r_int
r_int
id|tbFreqMhzHundreths
op_assign
l_int|0
suffix:semicolon
DECL|variable|decr_overclock
r_int
r_int
id|decr_overclock
op_assign
l_int|8
suffix:semicolon
DECL|variable|decr_overclock_proc0
r_int
r_int
id|decr_overclock_proc0
op_assign
l_int|8
suffix:semicolon
DECL|variable|decr_overclock_set
r_int
r_int
id|decr_overclock_set
op_assign
l_int|0
suffix:semicolon
DECL|variable|decr_overclock_proc0_set
r_int
r_int
id|decr_overclock_proc0_set
op_assign
l_int|0
suffix:semicolon
r_extern
r_int
r_int
id|embedded_sysmap_start
suffix:semicolon
r_extern
r_int
r_int
id|embedded_sysmap_end
suffix:semicolon
r_extern
r_int
r_int
id|sysmap
suffix:semicolon
r_extern
r_int
r_int
id|sysmap_size
suffix:semicolon
r_extern
r_int
r_int
id|end_of_DRAM
suffix:semicolon
singleline_comment|// Defined in ppc/mm/init.c
macro_line|#ifdef CONFIG_SMP
r_extern
r_struct
id|smp_ops_t
id|iSeries_smp_ops
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
multiline_comment|/* XXX for now... */
macro_line|#ifndef CONFIG_PCI
DECL|variable|isa_io_base
r_int
r_int
id|isa_io_base
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * void __init platform_init()&n; *&n; * Description:&n; *   This routine...&n; *&n; * Input(s):&n; *   r3 - Optional pointer to a board information structure.&n; *   r4 - Optional pointer to the physical starting address of the init RAM&n; *        disk.&n; *   r5 - Optional pointer to the physical ending address of the init RAM&n; *        disk.&n; *   r6 - Optional pointer to the physical starting address of any kernel&n; *        command-line parameters.&n; *   r7 - Optional pointer to the physical ending address of any kernel&n; *        command-line parameters.&n; *&n; * Output(s):&n; *   N/A&n; *&n; * Returns:&n; *   N/A&n; *&n; */
r_extern
r_int
id|rd_size
suffix:semicolon
singleline_comment|// Defined in drivers/block/rd.c
r_extern
id|u64
id|next_jiffy_update_tb
(braket
)braket
suffix:semicolon
r_extern
id|u64
id|get_tb64
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|iSeries_find_end_of_memory
r_int
r_int
id|__init
id|iSeries_find_end_of_memory
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* totalLpChunks contains the size of memory (in units of 256K) */
r_int
r_int
id|memory_end
op_assign
(paren
id|totalLpChunks
op_lshift
l_int|18
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_HIGHMEM
multiline_comment|/* Max memory if highmem is not configured is 768 MB */
r_if
c_cond
(paren
id|memory_end
OG
(paren
l_int|768
op_lshift
l_int|20
)paren
)paren
id|memory_end
op_assign
l_int|768
op_lshift
l_int|20
suffix:semicolon
macro_line|#endif /* CONFIG_HIGHMEM */
r_return
id|memory_end
suffix:semicolon
)brace
r_void
id|__init
DECL|function|platform_init
id|platform_init
c_func
(paren
r_int
r_int
id|r3
comma
r_int
r_int
id|r4
comma
r_int
r_int
id|r5
comma
r_int
r_int
id|r6
comma
r_int
r_int
id|r7
)paren
(brace
id|parse_bootinfo
c_func
(paren
id|find_bootinfo
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_BLK_DEV_INITRD)
multiline_comment|/*&n;&t; * If the init RAM disk has been configured and there is&n;&t; * a non-zero starting address for it, set it up&n;&t; */
r_if
c_cond
(paren
id|xNaca.xRamDisk
)paren
(brace
id|initrd_start
op_assign
id|xNaca.xRamDisk
op_plus
id|KERNELBASE
suffix:semicolon
id|initrd_end
op_assign
id|initrd_start
op_plus
id|xNaca.xRamDiskSize
op_star
id|PAGE_SIZE
suffix:semicolon
id|initrd_below_start_ok
op_assign
l_int|1
suffix:semicolon
singleline_comment|// ramdisk in kernel space
id|ROOT_DEV
op_assign
id|Root_RAM0
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|rd_size
op_star
l_int|1024
)paren
op_div
id|PAGE_SIZE
)paren
OL
id|xNaca.xRamDiskSize
)paren
id|rd_size
op_assign
(paren
id|xNaca.xRamDiskSize
op_star
id|PAGE_SIZE
)paren
op_div
l_int|1024
suffix:semicolon
)brace
r_else
macro_line|#endif /* CONFIG_BLK_DEV_INITRD */
macro_line|#if CONFIG_VIODASD_IDE
(brace
id|ROOT_DEV
op_assign
id|Root_HDA1
suffix:semicolon
)brace
macro_line|#elif defined(CONFIG_VIODASD)
(brace
id|ROOT_DEV
op_assign
id|MKDEV
c_func
(paren
id|VIODASD_MAJOR
comma
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_VIODASD_IDE */
multiline_comment|/* If an embedded System.map has been added to the kernel,&n;&t; * set it up.&n;&t; */
r_if
c_cond
(paren
id|embedded_sysmap_start
)paren
(brace
id|sysmap
op_assign
id|embedded_sysmap_start
op_plus
id|KERNELBASE
suffix:semicolon
id|sysmap_size
op_assign
id|embedded_sysmap_end
op_minus
id|embedded_sysmap_start
suffix:semicolon
)brace
multiline_comment|/* Copy the kernel command line arguments to a safe place. */
r_if
c_cond
(paren
id|r6
)paren
(brace
op_star
(paren
r_char
op_star
)paren
(paren
id|r7
op_plus
id|KERNELBASE
)paren
op_assign
l_int|0
suffix:semicolon
id|strcpy
c_func
(paren
id|cmd_line
comma
(paren
r_char
op_star
)paren
(paren
id|r6
op_plus
id|KERNELBASE
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize the table which translate Linux physical addresses to&n;&t; * iSeries absolute addresses&n;&t; */
id|build_iSeries_Memory_Map
c_func
(paren
)paren
suffix:semicolon
id|setup_iSeries_cache_sizes
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Initialize machine-dependency vectors */
id|ppc_md.setup_arch
op_assign
id|iSeries_setup_arch
suffix:semicolon
id|ppc_md.show_cpuinfo
op_assign
id|iSeries_show_cpuinfo
suffix:semicolon
id|ppc_md.show_percpuinfo
op_assign
id|iSeries_show_percpuinfo
suffix:semicolon
id|ppc_md.irq_cannonicalize
op_assign
l_int|NULL
suffix:semicolon
id|ppc_md.init_IRQ
op_assign
id|iSeries_init_IRQ
suffix:semicolon
id|ppc_md.get_irq
op_assign
id|iSeries_get_irq
suffix:semicolon
id|ppc_md.init
op_assign
l_int|NULL
suffix:semicolon
id|ppc_md.restart
op_assign
id|iSeries_restart
suffix:semicolon
id|ppc_md.power_off
op_assign
id|iSeries_power_off
suffix:semicolon
id|ppc_md.halt
op_assign
id|iSeries_halt
suffix:semicolon
id|ppc_md.time_init
op_assign
l_int|NULL
suffix:semicolon
id|ppc_md.set_rtc_time
op_assign
id|iSeries_set_rtc_time
suffix:semicolon
id|ppc_md.get_rtc_time
op_assign
id|iSeries_get_rtc_time
suffix:semicolon
id|ppc_md.calibrate_decr
op_assign
id|iSeries_calibrate_decr
suffix:semicolon
id|ppc_md.progress
op_assign
id|iSeries_progress
suffix:semicolon
id|ppc_md.find_end_of_memory
op_assign
id|iSeries_find_end_of_memory
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
id|ppc_md.pcibios_fixup_bus
op_assign
id|iSeries_fixup_bus
suffix:semicolon
id|ppc_md.pcibios_fixup
op_assign
id|iSeries_fixup
suffix:semicolon
macro_line|#else
id|ppc_md.pcibios_fixup_bus
op_assign
l_int|NULL
suffix:semicolon
id|ppc_md.pcibios_fixup
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif /* CONFIG_PCI         */
macro_line|#ifdef CONFIG_SMP
id|ppc_md.smp_ops
op_assign
op_amp
id|iSeries_smp_ops
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
singleline_comment|// Associate Lp Event Queue 0 with processor 0
id|HvCallEvent_setLpEventQueueInterruptProc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
(brace
singleline_comment|// copy the command line parameter from the primary VSP
r_char
op_star
id|p
comma
op_star
id|q
suffix:semicolon
id|HvCallEvent_dmaToSp
c_func
(paren
id|cmd_line
comma
l_int|2
op_star
l_int|64
op_star
l_int|1024
comma
l_int|256
comma
id|HvLpDma_Direction_RemoteToLocal
)paren
suffix:semicolon
id|p
op_assign
id|q
op_assign
id|cmd_line
op_plus
l_int|255
suffix:semicolon
r_while
c_loop
(paren
id|p
OG
id|cmd_line
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|p
op_eq
l_int|0
)paren
op_logical_or
(paren
op_star
id|p
op_eq
l_char|&squot; &squot;
)paren
op_logical_or
(paren
op_star
id|p
op_eq
l_char|&squot;&bslash;n&squot;
)paren
)paren
op_decrement
id|p
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
OL
id|q
)paren
op_star
(paren
id|p
op_plus
l_int|1
)paren
op_assign
l_int|0
suffix:semicolon
)brace
id|next_jiffy_update_tb
(braket
l_int|0
)braket
op_assign
id|get_tb64
c_func
(paren
)paren
suffix:semicolon
id|iSeries_proc_early_init
c_func
(paren
)paren
suffix:semicolon
id|mf_init
c_func
(paren
)paren
suffix:semicolon
id|iSeries_proc_callback
c_func
(paren
op_amp
id|pmc_proc_init
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * The iSeries may have very large memories ( &gt; 128 GB ) and a partition&n; * may get memory in &quot;chunks&quot; that may be anywhere in the 2**52 real&n; * address space.  The chunks are 256K in size.  To map this to the&n; * memory model Linux expects, the iSeries specific code builds a&n; * translation table to translate what Linux thinks are &quot;physical&quot;&n; * addresses to the actual real addresses.  This allows us to make&n; * it appear to Linux that we have contiguous memory starting at&n; * physical address zero while in fact this could be far from the truth.&n; * To avoid confusion, I&squot;ll let the words physical and/or real address&n; * apply to the Linux addresses while I&squot;ll use &quot;absolute address&quot; to&n; * refer to the actual hardware real address.&n; *&n; * build_iSeries_Memory_Map gets information from the Hypervisor and&n; * looks at the Main Store VPD to determine the absolute addresses&n; * of the memory that has been assigned to our partition and builds&n; * a table used to translate Linux&squot;s physical addresses to these&n; * absolute addresses.  Absolute addresses are needed when&n; * communicating with the hypervisor (e.g. to build HPT entries)&n; */
DECL|function|build_iSeries_Memory_Map
r_static
r_void
id|__init
id|build_iSeries_Memory_Map
c_func
(paren
r_void
)paren
(brace
id|u32
id|loadAreaFirstChunk
comma
id|loadAreaLastChunk
comma
id|loadAreaSize
suffix:semicolon
id|u32
id|hptFirstChunk
comma
id|hptLastChunk
comma
id|hptSizeChunks
suffix:semicolon
id|u32
id|absAddrHi
comma
id|absAddrLo
suffix:semicolon
id|u32
id|nextPhysChunk
suffix:semicolon
id|u32
id|holeFirstChunk
comma
id|holeSizeChunks
suffix:semicolon
id|u32
id|totalChunks
comma
id|moreChunks
suffix:semicolon
id|u32
id|currChunk
comma
id|thisChunk
comma
id|absChunk
suffix:semicolon
id|u32
id|currDword
suffix:semicolon
id|u32
id|chunkBit
suffix:semicolon
id|u64
id|holeStart
comma
id|holeEnd
comma
id|holeSize
suffix:semicolon
id|u64
id|map
suffix:semicolon
r_struct
id|IoHriMainStoreSegment4
op_star
id|msVpd
suffix:semicolon
singleline_comment|// Get absolute address of our load area
singleline_comment|// and map it to physical address 0
singleline_comment|// This guarantees that the loadarea ends up at physical 0
singleline_comment|// otherwise, it might not be returned by PLIC as the first
singleline_comment|// chunks
id|loadAreaFirstChunk
op_assign
(paren
id|u32
)paren
(paren
id|itLpNaca.xLoadAreaAddr
op_rshift
l_int|18
)paren
suffix:semicolon
id|loadAreaSize
op_assign
id|itLpNaca.xLoadAreaChunks
suffix:semicolon
id|loadAreaLastChunk
op_assign
id|loadAreaFirstChunk
op_plus
id|loadAreaSize
op_minus
l_int|1
suffix:semicolon
singleline_comment|// Get absolute address of our HPT and remember it so
singleline_comment|// we won&squot;t map it to any physical address
id|hptFirstChunk
op_assign
(paren
id|u32
)paren
(paren
id|HvCallHpt_getHptAddress
c_func
(paren
)paren
op_rshift
l_int|18
)paren
suffix:semicolon
id|hptSizeChunks
op_assign
(paren
id|u32
)paren
(paren
id|HvCallHpt_getHptPages
c_func
(paren
)paren
op_rshift
l_int|6
)paren
suffix:semicolon
id|hptLastChunk
op_assign
id|hptFirstChunk
op_plus
id|hptSizeChunks
op_minus
l_int|1
suffix:semicolon
id|loadAreaLastChunk
op_assign
id|loadAreaFirstChunk
op_plus
id|loadAreaSize
op_minus
l_int|1
suffix:semicolon
id|absAddrLo
op_assign
id|loadAreaFirstChunk
op_lshift
l_int|18
suffix:semicolon
id|absAddrHi
op_assign
id|loadAreaFirstChunk
op_rshift
l_int|14
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Mapping load area - physical addr = 0, absolute addr = %08x%08x&bslash;n&quot;
comma
id|absAddrHi
comma
id|absAddrLo
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Load area size %dK&bslash;n&quot;
comma
id|loadAreaSize
op_star
l_int|256
)paren
suffix:semicolon
id|nextPhysChunk
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|absChunk
op_assign
id|loadAreaFirstChunk
suffix:semicolon
id|absChunk
op_le
id|loadAreaLastChunk
suffix:semicolon
op_increment
id|absChunk
)paren
(brace
r_if
c_cond
(paren
(paren
id|absChunk
OL
id|hptFirstChunk
)paren
op_logical_or
(paren
id|absChunk
OG
id|hptLastChunk
)paren
)paren
(brace
id|msChunks
(braket
id|nextPhysChunk
)braket
op_assign
id|absChunk
suffix:semicolon
op_increment
id|nextPhysChunk
suffix:semicolon
)brace
)brace
singleline_comment|// Get absolute address of our HPT and remember it so
singleline_comment|// we won&squot;t map it to any physical address
id|hptFirstChunk
op_assign
(paren
id|u32
)paren
(paren
id|HvCallHpt_getHptAddress
c_func
(paren
)paren
op_rshift
l_int|18
)paren
suffix:semicolon
id|hptSizeChunks
op_assign
(paren
id|u32
)paren
(paren
id|HvCallHpt_getHptPages
c_func
(paren
)paren
op_rshift
l_int|6
)paren
suffix:semicolon
id|hptLastChunk
op_assign
id|hptFirstChunk
op_plus
id|hptSizeChunks
op_minus
l_int|1
suffix:semicolon
id|absAddrLo
op_assign
id|hptFirstChunk
op_lshift
l_int|18
suffix:semicolon
id|absAddrHi
op_assign
id|hptFirstChunk
op_rshift
l_int|14
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;HPT absolute addr = %08x%08x, size = %dK&bslash;n&quot;
comma
id|absAddrHi
comma
id|absAddrLo
comma
id|hptSizeChunks
op_star
l_int|256
)paren
suffix:semicolon
singleline_comment|// Determine if absolute memory has any
singleline_comment|// holes so that we can interpret the
singleline_comment|// access map we get back from the hypervisor
singleline_comment|// correctly.
id|msVpd
op_assign
(paren
r_struct
id|IoHriMainStoreSegment4
op_star
)paren
id|xMsVpd
suffix:semicolon
id|holeStart
op_assign
id|msVpd-&gt;nonInterleavedBlocksStartAdr
suffix:semicolon
id|holeEnd
op_assign
id|msVpd-&gt;nonInterleavedBlocksEndAdr
suffix:semicolon
id|holeSize
op_assign
id|holeEnd
op_minus
id|holeStart
suffix:semicolon
r_if
c_cond
(paren
id|holeSize
)paren
(brace
id|holeStart
op_assign
id|holeStart
op_amp
l_int|0x000fffffffffffff
suffix:semicolon
id|holeStart
op_assign
id|holeStart
op_rshift
l_int|18
suffix:semicolon
id|holeFirstChunk
op_assign
(paren
id|u32
)paren
id|holeStart
suffix:semicolon
id|holeSize
op_assign
id|holeSize
op_rshift
l_int|18
suffix:semicolon
id|holeSizeChunks
op_assign
(paren
id|u32
)paren
id|holeSize
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Main store hole: start chunk = %0x, size = %0x chunks&bslash;n&quot;
comma
id|holeFirstChunk
comma
id|holeSizeChunks
)paren
suffix:semicolon
)brace
r_else
(brace
id|holeFirstChunk
op_assign
l_int|0xffffffff
suffix:semicolon
id|holeSizeChunks
op_assign
l_int|0
suffix:semicolon
)brace
singleline_comment|// Process the main store access map from the hypervisor
singleline_comment|// to build up our physical -&gt; absolute translation table
id|totalChunks
op_assign
(paren
id|u32
)paren
id|HvLpConfig_getMsChunks
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|totalChunks
op_minus
id|hptSizeChunks
)paren
OG
l_int|16384
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;More than 4GB of memory assigned to this partition&quot;
)paren
suffix:semicolon
)brace
id|currChunk
op_assign
l_int|0
suffix:semicolon
id|currDword
op_assign
l_int|0
suffix:semicolon
id|moreChunks
op_assign
id|totalChunks
suffix:semicolon
r_while
c_loop
(paren
id|moreChunks
)paren
(brace
id|map
op_assign
id|HvCallSm_get64BitsOfAccessMap
c_func
(paren
id|itLpNaca.xLpIndex
comma
id|currDword
)paren
suffix:semicolon
id|thisChunk
op_assign
id|currChunk
suffix:semicolon
r_while
c_loop
(paren
id|map
)paren
(brace
id|chunkBit
op_assign
id|map
op_rshift
l_int|63
suffix:semicolon
id|map
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|chunkBit
)paren
(brace
op_decrement
id|moreChunks
suffix:semicolon
id|absChunk
op_assign
id|thisChunk
suffix:semicolon
r_if
c_cond
(paren
id|absChunk
op_ge
id|holeFirstChunk
)paren
id|absChunk
op_add_assign
id|holeSizeChunks
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|absChunk
OL
id|hptFirstChunk
)paren
op_logical_or
(paren
id|absChunk
OG
id|hptLastChunk
)paren
)paren
op_logical_and
(paren
(paren
id|absChunk
OL
id|loadAreaFirstChunk
)paren
op_logical_or
(paren
id|absChunk
OG
id|loadAreaLastChunk
)paren
)paren
)paren
(brace
singleline_comment|//&t;&t;&t;&t;&t;printk( &quot;Mapping physical = %0x to absolute %0x for 256K&bslash;n&quot;, nextPhysChunk &lt;&lt; 18, absChunk &lt;&lt; 18 );
id|msChunks
(braket
id|nextPhysChunk
)braket
op_assign
id|absChunk
suffix:semicolon
op_increment
id|nextPhysChunk
suffix:semicolon
)brace
)brace
op_increment
id|thisChunk
suffix:semicolon
)brace
op_increment
id|currDword
suffix:semicolon
id|currChunk
op_add_assign
l_int|64
suffix:semicolon
)brace
singleline_comment|// main store size (in chunks) is
singleline_comment|//   totalChunks - hptSizeChunks
singleline_comment|// which should be equal to
singleline_comment|//   nextPhysChunk
id|totalLpChunks
op_assign
id|nextPhysChunk
suffix:semicolon
)brace
multiline_comment|/*&n; * Set up the variables that describe the cache line sizes&n; * for this machine.&n; */
DECL|function|setup_iSeries_cache_sizes
r_static
r_void
id|__init
id|setup_iSeries_cache_sizes
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|n
suffix:semicolon
id|iSeries_icache_line_size
op_assign
id|xIoHriProcessorVpd
(braket
l_int|0
)braket
dot
id|xInstCacheOperandSize
suffix:semicolon
id|iSeries_dcache_line_size
op_assign
id|xIoHriProcessorVpd
(braket
l_int|0
)braket
dot
id|xDataCacheOperandSize
suffix:semicolon
id|iSeries_icache_lines_per_page
op_assign
id|PAGE_SIZE
op_div
id|iSeries_icache_line_size
suffix:semicolon
id|iSeries_dcache_lines_per_page
op_assign
id|PAGE_SIZE
op_div
id|iSeries_dcache_line_size
suffix:semicolon
id|i
op_assign
id|iSeries_icache_line_size
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|i
op_assign
(paren
id|i
op_div
l_int|2
)paren
)paren
)paren
op_increment
id|n
suffix:semicolon
id|iSeries_log_icache_line_size
op_assign
id|n
suffix:semicolon
id|i
op_assign
id|iSeries_dcache_line_size
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|i
op_assign
(paren
id|i
op_div
l_int|2
)paren
)paren
)paren
op_increment
id|n
suffix:semicolon
id|iSeries_log_dcache_line_size
op_assign
id|n
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;D-cache line size = %d  (log = %d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|iSeries_dcache_line_size
comma
(paren
r_int
)paren
id|iSeries_log_dcache_line_size
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;I-cache line size = %d  (log = %d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|iSeries_icache_line_size
comma
(paren
r_int
)paren
id|iSeries_log_icache_line_size
)paren
suffix:semicolon
)brace
DECL|variable|piranha_simulator
r_int
id|piranha_simulator
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Document me.&n; */
r_void
id|__init
DECL|function|iSeries_setup_arch
id|iSeries_setup_arch
c_func
(paren
r_void
)paren
(brace
r_void
op_star
id|eventStack
suffix:semicolon
id|u32
id|procFreq
suffix:semicolon
id|u32
id|tbFreq
suffix:semicolon
singleline_comment|//&t;u32&t;evStackContigReal;
singleline_comment|//&t;u64&t;evStackReal;
multiline_comment|/* Setup the Lp Event Queue */
multiline_comment|/* Associate Lp Event Queue 0 with processor 0 */
singleline_comment|//&t;HvCallEvent_setLpEventQueueInterruptProc( 0, 0 );
multiline_comment|/* Allocate a page for the Event Stack&n;&t; * The hypervisor wants the absolute real address, so&n;&t; * we subtract out the KERNELBASE and add in the&n;&t; * absolute real address of the kernel load area&n;&t; */
id|eventStack
op_assign
id|alloc_bootmem_pages
c_func
(paren
id|LpEventStackSize
)paren
suffix:semicolon
id|memset
c_func
(paren
id|eventStack
comma
l_int|0
comma
id|LpEventStackSize
)paren
suffix:semicolon
multiline_comment|/* Invoke the hypervisor to initialize the event stack */
id|HvCallEvent_setLpEventStack
c_func
(paren
l_int|0
comma
id|eventStack
comma
id|LpEventStackSize
)paren
suffix:semicolon
multiline_comment|/* Initialize fields in our Lp Event Queue */
id|xItLpQueue.xHSlicEventStackPtr
op_assign
l_int|0
suffix:semicolon
id|xItLpQueue.xSlicEventStackPtr
op_assign
(paren
r_char
op_star
)paren
id|eventStack
suffix:semicolon
id|xItLpQueue.xHSlicCurEventPtr
op_assign
l_int|0
suffix:semicolon
id|xItLpQueue.xSlicCurEventPtr
op_assign
(paren
r_char
op_star
)paren
id|eventStack
suffix:semicolon
id|xItLpQueue.xHSlicLastValidEventPtr
op_assign
l_int|0
suffix:semicolon
id|xItLpQueue.xSlicLastValidEventPtr
op_assign
(paren
r_char
op_star
)paren
id|eventStack
op_plus
(paren
id|LpEventStackSize
op_minus
id|LpEventMaxSize
)paren
suffix:semicolon
id|xItLpQueue.xIndex
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|itLpNaca.xPirEnvironMode
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Running on Piranha simulator&bslash;n&quot;
)paren
suffix:semicolon
id|piranha_simulator
op_assign
l_int|1
suffix:semicolon
)brace
singleline_comment|// Compute processor frequency
id|procFreq
op_assign
(paren
l_int|0x40000000
op_div
(paren
id|xIoHriProcessorVpd
(braket
l_int|0
)braket
dot
id|xProcFreq
op_div
l_int|1600
)paren
)paren
suffix:semicolon
id|procFreqHz
op_assign
id|procFreq
op_star
l_int|10000
suffix:semicolon
id|procFreqMhz
op_assign
id|procFreq
op_div
l_int|100
suffix:semicolon
id|procFreqMhzHundreths
op_assign
id|procFreq
op_minus
(paren
id|procFreqMhz
op_star
l_int|100
)paren
suffix:semicolon
singleline_comment|// Compute time base frequency
id|tbFreq
op_assign
(paren
l_int|0x40000000
op_div
(paren
id|xIoHriProcessorVpd
(braket
l_int|0
)braket
dot
id|xTimeBaseFreq
op_div
l_int|400
)paren
)paren
suffix:semicolon
id|tbFreqHz
op_assign
id|tbFreq
op_star
l_int|10000
suffix:semicolon
id|tbFreqMhz
op_assign
id|tbFreq
op_div
l_int|100
suffix:semicolon
id|tbFreqMhzHundreths
op_assign
id|tbFreq
op_minus
(paren
id|tbFreqMhz
op_star
l_int|100
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Max  logical processors = %d&bslash;n&quot;
comma
id|itVpdAreas.xSlicMaxLogicalProcs
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Max physical processors = %d&bslash;n&quot;
comma
id|itVpdAreas.xSlicMaxPhysicalProcs
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Processor frequency = %lu.%02lu&bslash;n&quot;
comma
id|procFreqMhz
comma
id|procFreqMhzHundreths
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Time base frequency = %lu.%02lu&bslash;n&quot;
comma
id|tbFreqMhz
comma
id|tbFreqMhzHundreths
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Processor version = %x&bslash;n&quot;
comma
id|xIoHriProcessorVpd
(braket
l_int|0
)braket
dot
id|xPVR
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
multiline_comment|/* Initialize the flight recorder, global bus map and pci memory table */
id|iSeries_pci_Initialize
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Setup the PCI controller list */
id|iSeries_build_hose_list
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PCI         */
multiline_comment|/*&n;&t;// copy the command line parameter from the primary VSP&n;&t;HvCallEvent_dmaToSp( cmd_line,&n;&t;&t;&t;     2*64*1024,&n;&t;&t;&t;     256,&n;&t;&t;&t;     HvLpDma_Direction_RemoteToLocal );&n;&n;&t;mf_init();&n;&t;viopath_init();&n;*/
)brace
multiline_comment|/*&n; * int iSeries_show_percpuinfo()&n; *&n; * Description:&n; *   This routine pretty-prints CPU information gathered from the VPD&n; *   for use in /proc/cpuinfo&n; *&n; * Input(s):&n; *  *buffer - Buffer into which CPU data is to be printed.&n; *&n; * Output(s):&n; *  *buffer - Buffer with CPU data.&n; *&n; * Returns:&n; *   The number of bytes copied into &squot;buffer&squot; if OK, otherwise zero or less&n; *   on error.&n; */
r_static
r_int
DECL|function|iSeries_show_percpuinfo
id|iSeries_show_percpuinfo
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_int
id|i
)paren
(brace
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;clock&bslash;t&bslash;t: %lu.%02luMhz&bslash;n&quot;
comma
id|procFreqMhz
comma
id|procFreqMhzHundreths
)paren
suffix:semicolon
singleline_comment|//&t;seq_printf(m, &quot;  processor clock&bslash;t&bslash;t: %ldMHz&bslash;n&quot;,
singleline_comment|//&t;&t;((unsigned long)xIoHriProcessorVpd[0].xProcFreq)/1000000);
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;time base&bslash;t: %lu.%02luMHz&bslash;n&quot;
comma
id|tbFreqMhz
comma
id|tbFreqMhzHundreths
)paren
suffix:semicolon
singleline_comment|//&t;seq_printf(m, &quot;  time base freq&bslash;t&bslash;t: %ldMHz&bslash;n&quot;,
singleline_comment|//&t;&t;((unsigned long)xIoHriProcessorVpd[0].xTimeBaseFreq)/1000000);
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;i-cache&bslash;t&bslash;t: %d&bslash;n&quot;
comma
id|iSeries_icache_line_size
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;d-cache&bslash;t&bslash;t: %d&bslash;n&quot;
comma
id|iSeries_dcache_line_size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|iSeries_show_cpuinfo
r_static
r_int
id|iSeries_show_cpuinfo
c_func
(paren
r_struct
id|seq_file
op_star
id|m
)paren
(brace
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;machine&bslash;t&bslash;t: iSeries Logical Partition&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_PCI
multiline_comment|/*&n; * Document me.&n; * and Implement me.&n; * If no Native I/O, do nothing routine.&n; */
r_void
id|__init
DECL|function|iSeries_init_IRQ
id|iSeries_init_IRQ
c_func
(paren
r_void
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Document me.&n; * and Implement me.&n; */
r_int
DECL|function|iSeries_get_irq
id|iSeries_get_irq
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/*&n;&t;return (ppc4xx_pic_get_irq(regs));&n;*/
multiline_comment|/* -2 means ignore this interrupt */
r_return
op_minus
l_int|2
suffix:semicolon
)brace
multiline_comment|/*&n; * Document me.&n; */
r_void
DECL|function|iSeries_restart
id|iSeries_restart
c_func
(paren
r_char
op_star
id|cmd
)paren
(brace
id|mf_reboot
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Document me.&n; */
r_void
DECL|function|iSeries_power_off
id|iSeries_power_off
c_func
(paren
r_void
)paren
(brace
id|mf_powerOff
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Document me.&n; */
r_void
DECL|function|iSeries_halt
id|iSeries_halt
c_func
(paren
r_void
)paren
(brace
id|mf_powerOff
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Nothing to do here.&n; */
r_void
id|__init
DECL|function|iSeries_time_init
id|iSeries_time_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Nothing to do */
)brace
multiline_comment|/*&n; * Set the RTC in the virtual service processor&n; * This requires flowing LpEvents to the primary partition&n; */
DECL|function|iSeries_set_rtc_time
r_int
id|iSeries_set_rtc_time
c_func
(paren
r_int
r_int
id|time
)paren
(brace
id|mf_setRtcTime
c_func
(paren
id|time
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the RTC from the virtual service processor&n; * This requires flowing LpEvents to the primary partition&n; */
DECL|function|iSeries_get_rtc_time
r_int
r_int
id|iSeries_get_rtc_time
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* XXX - Implement me */
r_int
r_int
id|time
suffix:semicolon
id|mf_getRtcTime
c_func
(paren
op_amp
id|time
)paren
suffix:semicolon
r_return
(paren
id|time
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * void __init iSeries_calibrate_decr()&n; *&n; * Description:&n; *   This routine retrieves the internal processor frequency from the VPD,&n; *   and sets up the kernel timer decrementer based on that value.&n; *&n; */
r_void
id|__init
DECL|function|iSeries_calibrate_decr
id|iSeries_calibrate_decr
c_func
(paren
r_void
)paren
(brace
id|u32
id|freq
suffix:semicolon
id|u32
id|tbf
suffix:semicolon
r_struct
id|Paca
op_star
id|paca
suffix:semicolon
multiline_comment|/* Compute decrementer (and TB) frequency&n;&t; * in cycles/sec&n;&t; */
id|tbf
op_assign
id|xIoHriProcessorVpd
(braket
l_int|0
)braket
dot
id|xTimeBaseFreq
op_div
l_int|16
suffix:semicolon
id|freq
op_assign
l_int|0x010000000
suffix:semicolon
id|freq
op_assign
id|freq
op_div
id|tbf
suffix:semicolon
multiline_comment|/* cycles / usec */
id|freq
op_assign
id|freq
op_star
l_int|1000000
suffix:semicolon
multiline_comment|/* now in cycles/sec */
multiline_comment|/* Set the amount to refresh the decrementer by.  This&n;&t; * is the number of decrementer ticks it takes for&n;&t; * 1/HZ seconds.&n;&t; */
multiline_comment|/* decrementer_count = freq / HZ;&n;&t; * count_period_num = 1;&n;&t; * count_period_den = freq; */
r_if
c_cond
(paren
id|decr_overclock_set
op_logical_and
op_logical_neg
id|decr_overclock_proc0_set
)paren
id|decr_overclock_proc0
op_assign
id|decr_overclock
suffix:semicolon
id|tb_ticks_per_jiffy
op_assign
id|freq
op_div
id|HZ
suffix:semicolon
id|paca
op_assign
(paren
r_struct
id|Paca
op_star
)paren
id|mfspr
c_func
(paren
id|SPRG1
)paren
suffix:semicolon
id|paca-&gt;default_decr
op_assign
id|tb_ticks_per_jiffy
op_div
id|decr_overclock_proc0
suffix:semicolon
id|tb_to_us
op_assign
id|mulhwu_scale_factor
c_func
(paren
id|freq
comma
l_int|1000000
)paren
suffix:semicolon
)brace
r_void
id|__init
DECL|function|iSeries_progress
id|iSeries_progress
c_func
(paren
r_char
op_star
id|st
comma
r_int
r_int
id|code
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Progress: [%04x] - %s&bslash;n&quot;
comma
(paren
r_int
)paren
id|code
comma
id|st
)paren
suffix:semicolon
r_if
c_cond
(paren
id|code
op_ne
l_int|0xffff
)paren
id|mf_displayProgress
c_func
(paren
id|code
)paren
suffix:semicolon
r_else
id|mf_clearSrc
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PCI
multiline_comment|/*&n; * unsigned int __init iSeries_build_hose_list()&n; *&n; * Description:&n; *   This routine builds a list of the PCI host bridges that&n; *   connect PCI buses either partially or fully owned by&n; *   this guest partition&n; *&n; */
DECL|function|iSeries_build_hose_list
r_int
r_int
id|__init
id|iSeries_build_hose_list
(paren
)paren
(brace
r_struct
id|pci_controller
op_star
id|hose
suffix:semicolon
r_struct
id|iSeries_hose_arch_data
op_star
id|hose_data
suffix:semicolon
id|u64
id|hvRc
suffix:semicolon
id|u16
id|hvbusnum
suffix:semicolon
r_int
id|LxBusNumber
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Linux Bus number for grins */
multiline_comment|/* Check to make sure the device probing will work on this iSeries Release. */
r_if
c_cond
(paren
id|hvReleaseData.xVrmIndex
op_ne
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PCI: iSeries Lpar and Linux native PCI I/O code is incompatible.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PCI: A newer version of the Linux kernel is need for this iSeries release.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|hvbusnum
op_assign
l_int|0
suffix:semicolon
id|hvbusnum
OL
l_int|256
suffix:semicolon
id|hvbusnum
op_increment
)paren
(brace
multiline_comment|/* All PCI buses which could be owned by this guest partition will be numbered by the hypervisor between 1 &amp; 255 */
id|hvRc
op_assign
id|HvCallXm_testBus
(paren
id|hvbusnum
)paren
suffix:semicolon
multiline_comment|/* Call the system hypervisor to query guest partition ownership status of this bus */
r_if
c_cond
(paren
id|hvRc
op_eq
l_int|0
)paren
(brace
multiline_comment|/* This bus is partially/fully owned by this guest partition */
id|hose
op_assign
(paren
r_struct
id|pci_controller
op_star
)paren
id|pcibios_alloc_controller
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// Create the hose for this PCI bus
id|hose-&gt;first_busno
op_assign
id|LxBusNumber
suffix:semicolon
multiline_comment|/* This just for debug.   pcibios will */
id|hose-&gt;last_busno
op_assign
l_int|0xff
suffix:semicolon
multiline_comment|/* assign the bus numbers.             */
id|hose-&gt;ops
op_assign
op_amp
id|iSeries_pci_ops
suffix:semicolon
multiline_comment|/* Create the iSeries_arch_data for the hose and cache the HV bus number in it so that pci bios can build the global bus map */
id|hose_data
op_assign
(paren
r_struct
id|iSeries_hose_arch_data
op_star
)paren
id|alloc_bootmem
c_func
(paren
r_sizeof
(paren
r_struct
id|iSeries_hose_arch_data
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|hose_data
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|hose_data
)paren
)paren
suffix:semicolon
id|hose-&gt;arch_data
op_assign
(paren
r_void
op_star
)paren
id|hose_data
suffix:semicolon
(paren
(paren
r_struct
id|iSeries_hose_arch_data
op_star
)paren
(paren
id|hose-&gt;arch_data
)paren
)paren
op_member_access_from_pointer
id|hvBusNumber
op_assign
id|hvbusnum
suffix:semicolon
id|LxBusNumber
op_add_assign
l_int|1
suffix:semicolon
multiline_comment|/* Keep track for debug */
)brace
)brace
id|pci_assign_all_busses
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Let Linux assign the bus numbers in pcibios_init */
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PCI         */
DECL|function|iSeries_spread_lpevents
r_int
id|iSeries_spread_lpevents
c_func
(paren
r_char
op_star
id|str
)paren
(brace
multiline_comment|/* The parameter is the number of processors to share in processing lp events */
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|val
op_assign
id|simple_strtoul
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
OG
l_int|0
)paren
op_logical_and
(paren
id|val
op_le
id|maxPacas
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|val
suffix:semicolon
op_increment
id|i
)paren
(brace
id|xPaca
(braket
id|i
)braket
dot
id|lpQueuePtr
op_assign
id|xPaca
(braket
l_int|0
)braket
dot
id|lpQueuePtr
suffix:semicolon
)brace
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;invalid spread_lpevents %ld&bslash;n&quot;
comma
id|val
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|iSeries_decr_overclock_proc0
r_int
id|iSeries_decr_overclock_proc0
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
r_int
id|val
op_assign
id|simple_strtoul
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
op_ge
l_int|1
)paren
op_logical_and
(paren
id|val
op_le
l_int|48
)paren
)paren
(brace
id|decr_overclock_proc0_set
op_assign
l_int|1
suffix:semicolon
id|decr_overclock_proc0
op_assign
id|val
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;proc 0 decrementer overclock factor of %ld&bslash;n&quot;
comma
id|val
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;invalid proc 0 decrementer overclock factor of %ld&bslash;n&quot;
comma
id|val
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|iSeries_decr_overclock
r_int
id|iSeries_decr_overclock
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
r_int
id|val
op_assign
id|simple_strtoul
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
op_ge
l_int|1
)paren
op_logical_and
(paren
id|val
op_le
l_int|48
)paren
)paren
(brace
id|decr_overclock_set
op_assign
l_int|1
suffix:semicolon
id|decr_overclock
op_assign
id|val
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;decrementer overclock factor of %ld&bslash;n&quot;
comma
id|val
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;invalid decrementer overclock factor of %ld&bslash;n&quot;
comma
id|val
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;spread_lpevents=&quot;
comma
id|iSeries_spread_lpevents
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;decr_overclock_proc0=&quot;
comma
id|iSeries_decr_overclock_proc0
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;decr_overclock=&quot;
comma
id|iSeries_decr_overclock
)paren
suffix:semicolon
eof
