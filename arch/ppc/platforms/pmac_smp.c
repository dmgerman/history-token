multiline_comment|/*&n; * SMP support for power macintosh.&n; *&n; * We support both the old &quot;powersurge&quot; SMP architecture&n; * and the current Core99 (G4 PowerMac) machines.&n; *&n; * Note that we don&squot;t support the very first rev. of&n; * Apple/DayStar 2 CPUs board, the one with the funky&n; * watchdog. Hopefully, none of these should be there except&n; * maybe internally to Apple. I should probably still add some&n; * code to detect this card though and disable SMP. --BenH.&n; *&n; * Support Macintosh G4 SMP by Troy Benjegerdes (hozer@drgw.net)&n; * and Ben Herrenschmidt &lt;benh@kernel.crashing.org&gt;.&n; *&n; * Support for DayStar quad CPU cards&n; * Copyright (C) XLR8, Inc. 1994-2000&n; *&n; *  This program is free software; you can redistribute it and/or&n; *  modify it under the terms of the GNU General Public License&n; *  as published by the Free Software Foundation; either version&n; *  2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/hardirq.h&gt;
macro_line|#include &lt;asm/sections.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/residual.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/pmac_feature.h&gt;
macro_line|#include &lt;asm/time.h&gt;
macro_line|#include &lt;asm/open_pic.h&gt;
macro_line|#include &lt;asm/cacheflush.h&gt;
macro_line|#include &lt;asm/keylargo.h&gt;
multiline_comment|/*&n; * Powersurge (old powermac SMP) support.&n; */
r_extern
r_void
id|__secondary_start_psurge
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|__secondary_start_psurge2
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* Temporary horrible hack */
r_extern
r_void
id|__secondary_start_psurge3
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* Temporary horrible hack */
multiline_comment|/* Addresses for powersurge registers */
DECL|macro|HAMMERHEAD_BASE
mdefine_line|#define HAMMERHEAD_BASE&t;&t;0xf8000000
DECL|macro|HHEAD_CONFIG
mdefine_line|#define HHEAD_CONFIG&t;&t;0x90
DECL|macro|HHEAD_SEC_INTR
mdefine_line|#define HHEAD_SEC_INTR&t;&t;0xc0
multiline_comment|/* register for interrupting the primary processor on the powersurge */
multiline_comment|/* N.B. this is actually the ethernet ROM! */
DECL|macro|PSURGE_PRI_INTR
mdefine_line|#define PSURGE_PRI_INTR&t;&t;0xf3019000
multiline_comment|/* register for storing the start address for the secondary processor */
multiline_comment|/* N.B. this is the PCI config space address register for the 1st bridge */
DECL|macro|PSURGE_START
mdefine_line|#define PSURGE_START&t;&t;0xf2800000
multiline_comment|/* Daystar/XLR8 4-CPU card */
DECL|macro|PSURGE_QUAD_REG_ADDR
mdefine_line|#define PSURGE_QUAD_REG_ADDR&t;0xf8800000
DECL|macro|PSURGE_QUAD_IRQ_SET
mdefine_line|#define PSURGE_QUAD_IRQ_SET&t;0
DECL|macro|PSURGE_QUAD_IRQ_CLR
mdefine_line|#define PSURGE_QUAD_IRQ_CLR&t;1
DECL|macro|PSURGE_QUAD_IRQ_PRIMARY
mdefine_line|#define PSURGE_QUAD_IRQ_PRIMARY&t;2
DECL|macro|PSURGE_QUAD_CKSTOP_CTL
mdefine_line|#define PSURGE_QUAD_CKSTOP_CTL&t;3
DECL|macro|PSURGE_QUAD_PRIMARY_ARB
mdefine_line|#define PSURGE_QUAD_PRIMARY_ARB&t;4
DECL|macro|PSURGE_QUAD_BOARD_ID
mdefine_line|#define PSURGE_QUAD_BOARD_ID&t;6
DECL|macro|PSURGE_QUAD_WHICH_CPU
mdefine_line|#define PSURGE_QUAD_WHICH_CPU&t;7
DECL|macro|PSURGE_QUAD_CKSTOP_RDBK
mdefine_line|#define PSURGE_QUAD_CKSTOP_RDBK&t;8
DECL|macro|PSURGE_QUAD_RESET_CTL
mdefine_line|#define PSURGE_QUAD_RESET_CTL&t;11
DECL|macro|PSURGE_QUAD_OUT
mdefine_line|#define PSURGE_QUAD_OUT(r, v)&t;(out_8(quad_base + ((r) &lt;&lt; 4) + 4, (v)))
DECL|macro|PSURGE_QUAD_IN
mdefine_line|#define PSURGE_QUAD_IN(r)&t;(in_8(quad_base + ((r) &lt;&lt; 4) + 4) &amp; 0x0f)
DECL|macro|PSURGE_QUAD_BIS
mdefine_line|#define PSURGE_QUAD_BIS(r, v)&t;(PSURGE_QUAD_OUT((r), PSURGE_QUAD_IN(r) | (v)))
DECL|macro|PSURGE_QUAD_BIC
mdefine_line|#define PSURGE_QUAD_BIC(r, v)&t;(PSURGE_QUAD_OUT((r), PSURGE_QUAD_IN(r) &amp; ~(v)))
multiline_comment|/* virtual addresses for the above */
DECL|variable|hhead_base
r_static
r_volatile
id|u8
op_star
id|hhead_base
suffix:semicolon
DECL|variable|quad_base
r_static
r_volatile
id|u8
op_star
id|quad_base
suffix:semicolon
DECL|variable|psurge_pri_intr
r_static
r_volatile
id|u32
op_star
id|psurge_pri_intr
suffix:semicolon
DECL|variable|psurge_sec_intr
r_static
r_volatile
id|u8
op_star
id|psurge_sec_intr
suffix:semicolon
DECL|variable|psurge_start
r_static
r_volatile
id|u32
op_star
id|psurge_start
suffix:semicolon
multiline_comment|/* values for psurge_type */
DECL|macro|PSURGE_NONE
mdefine_line|#define PSURGE_NONE&t;&t;-1
DECL|macro|PSURGE_DUAL
mdefine_line|#define PSURGE_DUAL&t;&t;0
DECL|macro|PSURGE_QUAD_OKEE
mdefine_line|#define PSURGE_QUAD_OKEE&t;1
DECL|macro|PSURGE_QUAD_COTTON
mdefine_line|#define PSURGE_QUAD_COTTON&t;2
DECL|macro|PSURGE_QUAD_ICEGRASS
mdefine_line|#define PSURGE_QUAD_ICEGRASS&t;3
multiline_comment|/* what sort of powersurge board we have */
DECL|variable|psurge_type
r_static
r_int
id|psurge_type
op_assign
id|PSURGE_NONE
suffix:semicolon
multiline_comment|/* L2 and L3 cache settings to pass from CPU0 to CPU1 */
DECL|variable|core99_l2_cache
r_volatile
r_static
r_int
r_int
id|core99_l2_cache
suffix:semicolon
DECL|variable|core99_l3_cache
r_volatile
r_static
r_int
r_int
id|core99_l3_cache
suffix:semicolon
multiline_comment|/* Timebase freeze GPIO */
DECL|variable|core99_tb_gpio
r_static
r_int
r_int
id|core99_tb_gpio
suffix:semicolon
multiline_comment|/* Sync flag for HW tb sync */
DECL|variable|sec_tb_reset
r_static
r_volatile
r_int
id|sec_tb_reset
op_assign
l_int|0
suffix:semicolon
r_static
r_void
id|__init
DECL|function|core99_init_caches
id|core99_init_caches
c_func
(paren
r_int
id|cpu
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|cur_cpu_spec
(braket
l_int|0
)braket
op_member_access_from_pointer
id|cpu_features
op_amp
id|CPU_FTR_L2CR
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|cpu
op_eq
l_int|0
)paren
(brace
id|core99_l2_cache
op_assign
id|_get_L2CR
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CPU0: L2CR is %lx&bslash;n&quot;
comma
id|core99_l2_cache
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;CPU%d: L2CR was %lx&bslash;n&quot;
comma
id|cpu
comma
id|_get_L2CR
c_func
(paren
)paren
)paren
suffix:semicolon
id|_set_L2CR
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|_set_L2CR
c_func
(paren
id|core99_l2_cache
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CPU%d: L2CR set to %lx&bslash;n&quot;
comma
id|cpu
comma
id|core99_l2_cache
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|cur_cpu_spec
(braket
l_int|0
)braket
op_member_access_from_pointer
id|cpu_features
op_amp
id|CPU_FTR_L3CR
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|cpu
op_eq
l_int|0
)paren
(brace
id|core99_l3_cache
op_assign
id|_get_L3CR
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CPU0: L3CR is %lx&bslash;n&quot;
comma
id|core99_l3_cache
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;CPU%d: L3CR was %lx&bslash;n&quot;
comma
id|cpu
comma
id|_get_L3CR
c_func
(paren
)paren
)paren
suffix:semicolon
id|_set_L3CR
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|_set_L3CR
c_func
(paren
id|core99_l3_cache
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CPU%d: L3CR set to %lx&bslash;n&quot;
comma
id|cpu
comma
id|core99_l3_cache
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Set and clear IPIs for powersurge.&n; */
DECL|function|psurge_set_ipi
r_static
r_inline
r_void
id|psurge_set_ipi
c_func
(paren
r_int
id|cpu
)paren
(brace
r_if
c_cond
(paren
id|psurge_type
op_eq
id|PSURGE_NONE
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|cpu
op_eq
l_int|0
)paren
id|in_be32
c_func
(paren
id|psurge_pri_intr
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|psurge_type
op_eq
id|PSURGE_DUAL
)paren
id|out_8
c_func
(paren
id|psurge_sec_intr
comma
l_int|0
)paren
suffix:semicolon
r_else
id|PSURGE_QUAD_OUT
c_func
(paren
id|PSURGE_QUAD_IRQ_SET
comma
l_int|1
op_lshift
id|cpu
)paren
suffix:semicolon
)brace
DECL|function|psurge_clr_ipi
r_static
r_inline
r_void
id|psurge_clr_ipi
c_func
(paren
r_int
id|cpu
)paren
(brace
r_if
c_cond
(paren
id|cpu
OG
l_int|0
)paren
(brace
r_switch
c_cond
(paren
id|psurge_type
)paren
(brace
r_case
id|PSURGE_DUAL
suffix:colon
id|out_8
c_func
(paren
id|psurge_sec_intr
comma
op_complement
l_int|0
)paren
suffix:semicolon
r_case
id|PSURGE_NONE
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|PSURGE_QUAD_OUT
c_func
(paren
id|PSURGE_QUAD_IRQ_CLR
comma
l_int|1
op_lshift
id|cpu
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * On powersurge (old SMP powermac architecture) we don&squot;t have&n; * separate IPIs for separate messages like openpic does.  Instead&n; * we have a bitmap for each processor, where a 1 bit means that&n; * the corresponding message is pending for that processor.&n; * Ideally each cpu&squot;s entry would be in a different cache line.&n; *  -- paulus.&n; */
DECL|variable|psurge_smp_message
r_static
r_int
r_int
id|psurge_smp_message
(braket
id|NR_CPUS
)braket
suffix:semicolon
r_void
id|__pmac
DECL|function|psurge_smp_message_recv
id|psurge_smp_message_recv
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
id|msg
suffix:semicolon
multiline_comment|/* clear interrupt */
id|psurge_clr_ipi
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num_online_cpus
c_func
(paren
)paren
OL
l_int|2
)paren
r_return
suffix:semicolon
multiline_comment|/* make sure there is a message there */
r_for
c_loop
(paren
id|msg
op_assign
l_int|0
suffix:semicolon
id|msg
OL
l_int|4
suffix:semicolon
id|msg
op_increment
)paren
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|msg
comma
op_amp
id|psurge_smp_message
(braket
id|cpu
)braket
)paren
)paren
id|smp_message_recv
c_func
(paren
id|msg
comma
id|regs
)paren
suffix:semicolon
)brace
id|irqreturn_t
id|__pmac
DECL|function|psurge_primary_intr
id|psurge_primary_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|d
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|psurge_smp_message_recv
c_func
(paren
id|regs
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
r_static
r_void
id|__pmac
DECL|function|smp_psurge_message_pass
id|smp_psurge_message_pass
c_func
(paren
r_int
id|target
comma
r_int
id|msg
comma
r_int
r_int
id|data
comma
r_int
id|wait
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|num_online_cpus
c_func
(paren
)paren
OL
l_int|2
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cpu_online
c_func
(paren
id|i
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|target
op_eq
id|MSG_ALL
op_logical_or
(paren
id|target
op_eq
id|MSG_ALL_BUT_SELF
op_logical_and
id|i
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
op_logical_or
id|target
op_eq
id|i
)paren
(brace
id|set_bit
c_func
(paren
id|msg
comma
op_amp
id|psurge_smp_message
(braket
id|i
)braket
)paren
suffix:semicolon
id|psurge_set_ipi
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Determine a quad card presence. We read the board ID register, we&n; * force the data bus to change to something else, and we read it again.&n; * It it&squot;s stable, then the register probably exist (ugh !)&n; */
DECL|function|psurge_quad_probe
r_static
r_int
id|__init
id|psurge_quad_probe
c_func
(paren
r_void
)paren
(brace
r_int
id|type
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|type
op_assign
id|PSURGE_QUAD_IN
c_func
(paren
id|PSURGE_QUAD_BOARD_ID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
template_param
id|PSURGE_QUAD_ICEGRASS
op_logical_or
id|type
op_ne
id|PSURGE_QUAD_IN
c_func
(paren
id|PSURGE_QUAD_BOARD_ID
)paren
)paren
r_return
id|PSURGE_DUAL
suffix:semicolon
multiline_comment|/* looks OK, try a slightly more rigorous test */
multiline_comment|/* bogus is not necessarily cacheline-aligned,&n;&t;   though I don&squot;t suppose that really matters.  -- paulus */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
)paren
(brace
r_volatile
id|u32
id|bogus
(braket
l_int|8
)braket
suffix:semicolon
id|bogus
(braket
(paren
l_int|0
op_plus
id|i
)paren
op_mod
l_int|8
)braket
op_assign
l_int|0x00000000
suffix:semicolon
id|bogus
(braket
(paren
l_int|1
op_plus
id|i
)paren
op_mod
l_int|8
)braket
op_assign
l_int|0x55555555
suffix:semicolon
id|bogus
(braket
(paren
l_int|2
op_plus
id|i
)paren
op_mod
l_int|8
)braket
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|bogus
(braket
(paren
l_int|3
op_plus
id|i
)paren
op_mod
l_int|8
)braket
op_assign
l_int|0xAAAAAAAA
suffix:semicolon
id|bogus
(braket
(paren
l_int|4
op_plus
id|i
)paren
op_mod
l_int|8
)braket
op_assign
l_int|0x33333333
suffix:semicolon
id|bogus
(braket
(paren
l_int|5
op_plus
id|i
)paren
op_mod
l_int|8
)braket
op_assign
l_int|0xCCCCCCCC
suffix:semicolon
id|bogus
(braket
(paren
l_int|6
op_plus
id|i
)paren
op_mod
l_int|8
)braket
op_assign
l_int|0xCCCCCCCC
suffix:semicolon
id|bogus
(braket
(paren
l_int|7
op_plus
id|i
)paren
op_mod
l_int|8
)braket
op_assign
l_int|0x33333333
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;dcbf 0,%0&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|bogus
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|PSURGE_QUAD_IN
c_func
(paren
id|PSURGE_QUAD_BOARD_ID
)paren
)paren
r_return
id|PSURGE_DUAL
suffix:semicolon
)brace
r_return
id|type
suffix:semicolon
)brace
DECL|function|psurge_quad_init
r_static
r_void
id|__init
id|psurge_quad_init
c_func
(paren
r_void
)paren
(brace
r_int
id|procbits
suffix:semicolon
r_if
c_cond
(paren
id|ppc_md.progress
)paren
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;psurge_quad_init&quot;
comma
l_int|0x351
)paren
suffix:semicolon
id|procbits
op_assign
op_complement
id|PSURGE_QUAD_IN
c_func
(paren
id|PSURGE_QUAD_WHICH_CPU
)paren
suffix:semicolon
r_if
c_cond
(paren
id|psurge_type
op_eq
id|PSURGE_QUAD_ICEGRASS
)paren
id|PSURGE_QUAD_BIS
c_func
(paren
id|PSURGE_QUAD_RESET_CTL
comma
id|procbits
)paren
suffix:semicolon
r_else
id|PSURGE_QUAD_BIC
c_func
(paren
id|PSURGE_QUAD_CKSTOP_CTL
comma
id|procbits
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|33
)paren
suffix:semicolon
id|out_8
c_func
(paren
id|psurge_sec_intr
comma
op_complement
l_int|0
)paren
suffix:semicolon
id|PSURGE_QUAD_OUT
c_func
(paren
id|PSURGE_QUAD_IRQ_CLR
comma
id|procbits
)paren
suffix:semicolon
id|PSURGE_QUAD_BIS
c_func
(paren
id|PSURGE_QUAD_RESET_CTL
comma
id|procbits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|psurge_type
op_ne
id|PSURGE_QUAD_ICEGRASS
)paren
id|PSURGE_QUAD_BIS
c_func
(paren
id|PSURGE_QUAD_CKSTOP_CTL
comma
id|procbits
)paren
suffix:semicolon
id|PSURGE_QUAD_BIC
c_func
(paren
id|PSURGE_QUAD_PRIMARY_ARB
comma
id|procbits
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|33
)paren
suffix:semicolon
id|PSURGE_QUAD_BIC
c_func
(paren
id|PSURGE_QUAD_RESET_CTL
comma
id|procbits
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|33
)paren
suffix:semicolon
id|PSURGE_QUAD_BIS
c_func
(paren
id|PSURGE_QUAD_PRIMARY_ARB
comma
id|procbits
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|33
)paren
suffix:semicolon
)brace
DECL|function|smp_psurge_probe
r_static
r_int
id|__init
id|smp_psurge_probe
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|ncpus
suffix:semicolon
multiline_comment|/* We don&squot;t do SMP on the PPC601 -- paulus */
r_if
c_cond
(paren
id|PVR_VER
c_func
(paren
id|mfspr
c_func
(paren
id|PVR
)paren
)paren
op_eq
l_int|1
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * The powersurge cpu board can be used in the generation&n;&t; * of powermacs that have a socket for an upgradeable cpu card,&n;&t; * including the 7500, 8500, 9500, 9600.&n;&t; * The device tree doesn&squot;t tell you if you have 2 cpus because&n;&t; * OF doesn&squot;t know anything about the 2nd processor.&n;&t; * Instead we look for magic bits in magic registers,&n;&t; * in the hammerhead memory controller in the case of the&n;&t; * dual-cpu powersurge board.  -- paulus.&n;&t; */
r_if
c_cond
(paren
id|find_devices
c_func
(paren
l_string|&quot;hammerhead&quot;
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
id|hhead_base
op_assign
id|ioremap
c_func
(paren
id|HAMMERHEAD_BASE
comma
l_int|0x800
)paren
suffix:semicolon
id|quad_base
op_assign
id|ioremap
c_func
(paren
id|PSURGE_QUAD_REG_ADDR
comma
l_int|1024
)paren
suffix:semicolon
id|psurge_sec_intr
op_assign
id|hhead_base
op_plus
id|HHEAD_SEC_INTR
suffix:semicolon
id|psurge_type
op_assign
id|psurge_quad_probe
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|psurge_type
op_ne
id|PSURGE_DUAL
)paren
(brace
id|psurge_quad_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* All released cards using this HW design have 4 CPUs */
id|ncpus
op_assign
l_int|4
suffix:semicolon
)brace
r_else
(brace
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|quad_base
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|in_8
c_func
(paren
id|hhead_base
op_plus
id|HHEAD_CONFIG
)paren
op_amp
l_int|0x02
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* not a dual-cpu card */
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|hhead_base
)paren
suffix:semicolon
id|psurge_type
op_assign
id|PSURGE_NONE
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|ncpus
op_assign
l_int|2
suffix:semicolon
)brace
id|psurge_start
op_assign
id|ioremap
c_func
(paren
id|PSURGE_START
comma
l_int|4
)paren
suffix:semicolon
id|psurge_pri_intr
op_assign
id|ioremap
c_func
(paren
id|PSURGE_PRI_INTR
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* this is not actually strictly necessary -- paulus. */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|ncpus
suffix:semicolon
op_increment
id|i
)paren
id|smp_hw_index
(braket
id|i
)braket
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|ppc_md.progress
)paren
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;smp_psurge_probe - done&quot;
comma
l_int|0x352
)paren
suffix:semicolon
r_return
id|ncpus
suffix:semicolon
)brace
DECL|function|smp_psurge_kick_cpu
r_static
r_void
id|__init
id|smp_psurge_kick_cpu
c_func
(paren
r_int
id|nr
)paren
(brace
r_void
(paren
op_star
id|start
)paren
(paren
r_void
)paren
op_assign
id|__secondary_start_psurge
suffix:semicolon
r_int
r_int
id|a
suffix:semicolon
multiline_comment|/* may need to flush here if secondary bats aren&squot;t setup */
r_for
c_loop
(paren
id|a
op_assign
id|KERNELBASE
suffix:semicolon
id|a
OL
id|KERNELBASE
op_plus
l_int|0x800000
suffix:semicolon
id|a
op_add_assign
l_int|32
)paren
id|asm
r_volatile
(paren
l_string|&quot;dcbf 0,%0&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|a
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;sync&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppc_md.progress
)paren
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;smp_psurge_kick_cpu&quot;
comma
l_int|0x353
)paren
suffix:semicolon
multiline_comment|/* setup entry point of secondary processor */
r_switch
c_cond
(paren
id|nr
)paren
(brace
r_case
l_int|2
suffix:colon
id|start
op_assign
id|__secondary_start_psurge2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|start
op_assign
id|__secondary_start_psurge3
suffix:semicolon
r_break
suffix:semicolon
)brace
id|out_be32
c_func
(paren
id|psurge_start
comma
id|__pa
c_func
(paren
id|start
)paren
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|psurge_set_ipi
c_func
(paren
id|nr
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|psurge_clr_ipi
c_func
(paren
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppc_md.progress
)paren
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;smp_psurge_kick_cpu - done&quot;
comma
l_int|0x354
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * With the dual-cpu powersurge board, the decrementers and timebases&n; * of both cpus are frozen after the secondary cpu is started up,&n; * until we give the secondary cpu another interrupt.  This routine&n; * uses this to get the timebases synchronized.&n; *  -- paulus.&n; */
DECL|function|psurge_dual_sync_tb
r_static
r_void
id|__init
id|psurge_dual_sync_tb
c_func
(paren
r_int
id|cpu_nr
)paren
(brace
r_int
id|t
suffix:semicolon
id|set_dec
c_func
(paren
id|tb_ticks_per_jiffy
)paren
suffix:semicolon
id|set_tb
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|last_jiffy_stamp
c_func
(paren
id|cpu_nr
)paren
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cpu_nr
OG
l_int|0
)paren
(brace
id|mb
c_func
(paren
)paren
suffix:semicolon
id|sec_tb_reset
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* wait for the secondary to have reset its TB before proceeding */
r_for
c_loop
(paren
id|t
op_assign
l_int|10000000
suffix:semicolon
id|t
OG
l_int|0
op_logical_and
op_logical_neg
id|sec_tb_reset
suffix:semicolon
op_decrement
id|t
)paren
suffix:semicolon
multiline_comment|/* now interrupt the secondary, starting both TBs */
id|psurge_set_ipi
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|smp_tb_synchronized
op_assign
l_int|1
suffix:semicolon
)brace
r_static
r_void
id|__init
DECL|function|smp_psurge_setup_cpu
id|smp_psurge_setup_cpu
c_func
(paren
r_int
id|cpu_nr
)paren
(brace
r_if
c_cond
(paren
id|cpu_nr
op_eq
l_int|0
)paren
(brace
multiline_comment|/* If we failed to start the second CPU, we should still&n;&t;&t; * send it an IPI to start the timebase &amp; DEC or we might&n;&t;&t; * have them stuck.&n;&t;&t; */
r_if
c_cond
(paren
id|num_online_cpus
c_func
(paren
)paren
OL
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|psurge_type
op_eq
id|PSURGE_DUAL
)paren
id|psurge_set_ipi
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* reset the entry point so if we get another intr we won&squot;t&n;&t;&t; * try to startup again */
id|out_be32
c_func
(paren
id|psurge_start
comma
l_int|0x100
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
l_int|30
comma
id|psurge_primary_intr
comma
id|SA_INTERRUPT
comma
l_string|&quot;primary IPI&quot;
comma
l_int|0
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Couldn&squot;t get primary IPI interrupt&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|psurge_type
op_eq
id|PSURGE_DUAL
)paren
id|psurge_dual_sync_tb
c_func
(paren
id|cpu_nr
)paren
suffix:semicolon
)brace
r_void
id|__init
DECL|function|smp_psurge_take_timebase
id|smp_psurge_take_timebase
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Dummy implementation */
)brace
r_void
id|__init
DECL|function|smp_psurge_give_timebase
id|smp_psurge_give_timebase
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Dummy implementation */
)brace
r_static
r_int
id|__init
DECL|function|smp_core99_probe
id|smp_core99_probe
c_func
(paren
r_void
)paren
(brace
r_extern
r_int
id|powersave_nap
suffix:semicolon
r_struct
id|device_node
op_star
id|cpus
suffix:semicolon
r_int
id|i
comma
id|ncpus
op_assign
l_int|1
suffix:semicolon
id|u32
op_star
id|tbprop
suffix:semicolon
r_if
c_cond
(paren
id|ppc_md.progress
)paren
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;smp_core99_probe&quot;
comma
l_int|0x345
)paren
suffix:semicolon
id|cpus
op_assign
id|find_type_devices
c_func
(paren
l_string|&quot;cpu&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpus
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|tbprop
op_assign
(paren
id|u32
op_star
)paren
id|get_property
c_func
(paren
id|cpus
comma
l_string|&quot;timebase-enable&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tbprop
)paren
id|core99_tb_gpio
op_assign
op_star
id|tbprop
suffix:semicolon
r_else
id|core99_tb_gpio
op_assign
id|KL_GPIO_TB_ENABLE
suffix:semicolon
r_while
c_loop
(paren
(paren
id|cpus
op_assign
id|cpus-&gt;next
)paren
op_ne
l_int|NULL
)paren
op_increment
id|ncpus
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;smp_core99_probe: found %d cpus&bslash;n&quot;
comma
id|ncpus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ncpus
OG
l_int|1
)paren
(brace
id|openpic_request_IPIs
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|ncpus
suffix:semicolon
op_increment
id|i
)paren
id|smp_hw_index
(braket
id|i
)braket
op_assign
id|i
suffix:semicolon
macro_line|#ifdef CONFIG_6xx
id|powersave_nap
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|core99_init_caches
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|ncpus
suffix:semicolon
)brace
r_static
r_void
id|__init
DECL|function|smp_core99_kick_cpu
id|smp_core99_kick_cpu
c_func
(paren
r_int
id|nr
)paren
(brace
r_int
r_int
id|save_vector
comma
id|new_vector
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_volatile
r_int
r_int
op_star
id|vector
op_assign
(paren
(paren
r_volatile
r_int
r_int
op_star
)paren
(paren
id|KERNELBASE
op_plus
l_int|0x100
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
template_param
l_int|3
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ppc_md.progress
)paren
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;smp_core99_kick_cpu&quot;
comma
l_int|0x346
)paren
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Save reset vector */
id|save_vector
op_assign
op_star
id|vector
suffix:semicolon
multiline_comment|/* Setup fake reset vector that does&t;&n;&t; *   b __secondary_start_psurge - KERNELBASE&n;&t; */
r_switch
c_cond
(paren
id|nr
)paren
(brace
r_case
l_int|1
suffix:colon
id|new_vector
op_assign
(paren
r_int
r_int
)paren
id|__secondary_start_psurge
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|new_vector
op_assign
(paren
r_int
r_int
)paren
id|__secondary_start_psurge2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|new_vector
op_assign
(paren
r_int
r_int
)paren
id|__secondary_start_psurge3
suffix:semicolon
r_break
suffix:semicolon
)brace
op_star
id|vector
op_assign
l_int|0x48000002
op_plus
id|new_vector
op_minus
id|KERNELBASE
suffix:semicolon
multiline_comment|/* flush data cache and inval instruction cache */
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
id|vector
comma
(paren
r_int
r_int
)paren
id|vector
op_plus
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Put some life in our friend */
id|pmac_call_feature
c_func
(paren
id|PMAC_FTR_RESET_CPU
comma
l_int|NULL
comma
id|nr
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* FIXME: We wait a bit for the CPU to take the exception, I should&n;&t; * instead wait for the entry code to set something for me. Well,&n;&t; * ideally, all that crap will be done in prom.c and the CPU left&n;&t; * in a RAM-based wait loop like CHRP.&n;&t; */
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Restore our exception vector */
op_star
id|vector
op_assign
id|save_vector
suffix:semicolon
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
id|vector
comma
(paren
r_int
r_int
)paren
id|vector
op_plus
l_int|4
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppc_md.progress
)paren
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;smp_core99_kick_cpu done&quot;
comma
l_int|0x347
)paren
suffix:semicolon
)brace
r_static
r_void
id|__init
DECL|function|smp_core99_setup_cpu
id|smp_core99_setup_cpu
c_func
(paren
r_int
id|cpu_nr
)paren
(brace
multiline_comment|/* Setup some registers */
r_if
c_cond
(paren
id|cpu_nr
op_ne
l_int|0
)paren
id|core99_init_caches
c_func
(paren
id|cpu_nr
)paren
suffix:semicolon
multiline_comment|/* Setup openpic */
id|do_openpic_setup_cpu
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Setup L2/L3 */
r_if
c_cond
(paren
id|cpu_nr
op_eq
l_int|0
)paren
r_if
c_cond
(paren
id|ppc_md.progress
)paren
id|ppc_md
dot
id|progress
c_func
(paren
l_string|&quot;core99_setup_cpu 0 done&quot;
comma
l_int|0x349
)paren
suffix:semicolon
)brace
r_void
id|__init
DECL|function|smp_core99_take_timebase
id|smp_core99_take_timebase
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Secondary processor &quot;takes&quot; the timebase by freezing&n;&t; * it, resetting its local TB and telling CPU 0 to go on&n;&t; */
id|pmac_call_feature
c_func
(paren
id|PMAC_FTR_WRITE_GPIO
comma
l_int|NULL
comma
id|core99_tb_gpio
comma
l_int|4
)paren
suffix:semicolon
id|pmac_call_feature
c_func
(paren
id|PMAC_FTR_READ_GPIO
comma
l_int|NULL
comma
id|core99_tb_gpio
comma
l_int|0
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|set_dec
c_func
(paren
id|tb_ticks_per_jiffy
)paren
suffix:semicolon
id|set_tb
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|last_jiffy_stamp
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
)paren
op_assign
l_int|0
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|sec_tb_reset
op_assign
l_int|1
suffix:semicolon
)brace
r_void
id|__init
DECL|function|smp_core99_give_timebase
id|smp_core99_give_timebase
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|t
suffix:semicolon
multiline_comment|/* Primary processor waits for secondary to have frozen&n;&t; * the timebase, resets local TB, and kick timebase again&n;&t; */
multiline_comment|/* wait for the secondary to have reset its TB before proceeding */
r_for
c_loop
(paren
id|t
op_assign
l_int|1000
suffix:semicolon
id|t
OG
l_int|0
op_logical_and
op_logical_neg
id|sec_tb_reset
suffix:semicolon
op_decrement
id|t
)paren
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Timeout waiting sync on second CPU&bslash;n&quot;
)paren
suffix:semicolon
id|set_dec
c_func
(paren
id|tb_ticks_per_jiffy
)paren
suffix:semicolon
id|set_tb
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|last_jiffy_stamp
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
)paren
op_assign
l_int|0
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Now, restart the timebase by leaving the GPIO to an open collector */
id|pmac_call_feature
c_func
(paren
id|PMAC_FTR_WRITE_GPIO
comma
l_int|NULL
comma
id|core99_tb_gpio
comma
l_int|0
)paren
suffix:semicolon
id|pmac_call_feature
c_func
(paren
id|PMAC_FTR_READ_GPIO
comma
l_int|NULL
comma
id|core99_tb_gpio
comma
l_int|0
)paren
suffix:semicolon
id|smp_tb_synchronized
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* PowerSurge-style Macs */
DECL|variable|__pmacdata
r_struct
id|smp_ops_t
id|psurge_smp_ops
id|__pmacdata
op_assign
(brace
dot
id|message_pass
op_assign
id|smp_psurge_message_pass
comma
dot
id|probe
op_assign
id|smp_psurge_probe
comma
dot
id|kick_cpu
op_assign
id|smp_psurge_kick_cpu
comma
dot
id|setup_cpu
op_assign
id|smp_psurge_setup_cpu
comma
dot
id|give_timebase
op_assign
id|smp_psurge_give_timebase
comma
dot
id|take_timebase
op_assign
id|smp_psurge_take_timebase
comma
)brace
suffix:semicolon
multiline_comment|/* Core99 Macs (dual G4s) */
DECL|variable|__pmacdata
r_struct
id|smp_ops_t
id|core99_smp_ops
id|__pmacdata
op_assign
(brace
dot
id|message_pass
op_assign
id|smp_openpic_message_pass
comma
dot
id|probe
op_assign
id|smp_core99_probe
comma
dot
id|kick_cpu
op_assign
id|smp_core99_kick_cpu
comma
dot
id|setup_cpu
op_assign
id|smp_core99_setup_cpu
comma
dot
id|give_timebase
op_assign
id|smp_core99_give_timebase
comma
dot
id|take_timebase
op_assign
id|smp_core99_take_timebase
comma
)brace
suffix:semicolon
eof
