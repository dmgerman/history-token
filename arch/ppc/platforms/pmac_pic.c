multiline_comment|/*&n; *  Support for the interrupt controllers found on Power Macintosh,&n; *  currently Apple&squot;s &quot;Grand Central&quot; interrupt controller in all&n; *  it&squot;s incarnations. OpenPIC support used on newer machines is&n; *  in a separate file&n; *&n; *  Copyright (C) 1997 Paul Mackerras (paulus@cs.anu.edu.au)&n; *&n; *  Maintained by Benjamin Herrenschmidt (benh@kernel.crashing.org)&n; *&n; *  This program is free software; you can redistribute it and/or&n; *  modify it under the terms of the GNU General Public License&n; *  as published by the Free Software Foundation; either version&n; *  2 of the License, or (at your option) any later version.&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/sysdev.h&gt;
macro_line|#include &lt;linux/adb.h&gt;
macro_line|#include &lt;linux/pmu.h&gt;
macro_line|#include &lt;asm/sections.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/pci-bridge.h&gt;
macro_line|#include &lt;asm/time.h&gt;
macro_line|#include &lt;asm/open_pic.h&gt;
macro_line|#include &lt;asm/xmon.h&gt;
macro_line|#include &lt;asm/pmac_feature.h&gt;
macro_line|#include &quot;pmac_pic.h&quot;
multiline_comment|/*&n; * XXX this should be in xmon.h, but putting it there means xmon.h&n; * has to include &lt;linux/interrupt.h&gt; (to get irqreturn_t), which&n; * causes all sorts of problems.  -- paulus&n; */
r_extern
id|irqreturn_t
id|xmon_irq
c_func
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
DECL|struct|pmac_irq_hw
r_struct
id|pmac_irq_hw
(brace
DECL|member|event
r_int
r_int
id|event
suffix:semicolon
DECL|member|enable
r_int
r_int
id|enable
suffix:semicolon
DECL|member|ack
r_int
r_int
id|ack
suffix:semicolon
DECL|member|level
r_int
r_int
id|level
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Default addresses */
DECL|variable|__pmacdata
r_static
r_volatile
r_struct
id|pmac_irq_hw
op_star
id|pmac_irq_hw
(braket
l_int|4
)braket
id|__pmacdata
op_assign
(brace
(paren
r_struct
id|pmac_irq_hw
op_star
)paren
l_int|0xf3000020
comma
(paren
r_struct
id|pmac_irq_hw
op_star
)paren
l_int|0xf3000010
comma
(paren
r_struct
id|pmac_irq_hw
op_star
)paren
l_int|0xf4000020
comma
(paren
r_struct
id|pmac_irq_hw
op_star
)paren
l_int|0xf4000010
comma
)brace
suffix:semicolon
DECL|macro|GC_LEVEL_MASK
mdefine_line|#define GC_LEVEL_MASK&t;&t;0x3ff00000
DECL|macro|OHARE_LEVEL_MASK
mdefine_line|#define OHARE_LEVEL_MASK&t;0x1ff00000
DECL|macro|HEATHROW_LEVEL_MASK
mdefine_line|#define HEATHROW_LEVEL_MASK&t;0x1ff00000
DECL|variable|__pmacdata
r_static
r_int
id|max_irqs
id|__pmacdata
suffix:semicolon
DECL|variable|__pmacdata
r_static
r_int
id|max_real_irqs
id|__pmacdata
suffix:semicolon
DECL|variable|__pmacdata
r_static
id|u32
id|level_mask
(braket
l_int|4
)braket
id|__pmacdata
suffix:semicolon
DECL|variable|__pmacdata
r_static
id|spinlock_t
id|pmac_pic_lock
id|__pmacdata
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|macro|GATWICK_IRQ_POOL_SIZE
mdefine_line|#define GATWICK_IRQ_POOL_SIZE        10
DECL|variable|__pmacdata
r_static
r_struct
id|interrupt_info
id|gatwick_int_pool
(braket
id|GATWICK_IRQ_POOL_SIZE
)braket
id|__pmacdata
suffix:semicolon
multiline_comment|/*&n; * Mark an irq as &quot;lost&quot;.  This is only used on the pmac&n; * since it can lose interrupts (see pmac_set_irq_mask).&n; * -- Cort&n; */
r_void
id|__pmac
DECL|function|__set_lost
id|__set_lost
c_func
(paren
r_int
r_int
id|irq_nr
comma
r_int
id|nokick
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|irq_nr
comma
id|ppc_lost_interrupts
)paren
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|ppc_n_lost_interrupts
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nokick
)paren
id|set_dec
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
id|__pmac
DECL|function|pmac_mask_and_ack_irq
id|pmac_mask_and_ack_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
(brace
r_int
r_int
id|bit
op_assign
l_int|1UL
op_lshift
(paren
id|irq_nr
op_amp
l_int|0x1f
)paren
suffix:semicolon
r_int
id|i
op_assign
id|irq_nr
op_rshift
l_int|5
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|irq_nr
op_ge
id|max_irqs
)paren
r_return
suffix:semicolon
id|clear_bit
c_func
(paren
id|irq_nr
comma
id|ppc_cached_irq_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|irq_nr
comma
id|ppc_lost_interrupts
)paren
)paren
id|atomic_dec
c_func
(paren
op_amp
id|ppc_n_lost_interrupts
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pmac_pic_lock
comma
id|flags
)paren
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|pmac_irq_hw
(braket
id|i
)braket
op_member_access_from_pointer
id|enable
comma
id|ppc_cached_irq_mask
(braket
id|i
)braket
)paren
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|pmac_irq_hw
(braket
id|i
)braket
op_member_access_from_pointer
id|ack
comma
id|bit
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* make sure ack gets to controller before we enable&n;                   interrupts */
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|in_le32
c_func
(paren
op_amp
id|pmac_irq_hw
(braket
id|i
)braket
op_member_access_from_pointer
id|enable
)paren
op_amp
id|bit
)paren
op_ne
(paren
id|ppc_cached_irq_mask
(braket
id|i
)braket
op_amp
id|bit
)paren
)paren
(brace
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pmac_pic_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|pmac_set_irq_mask
r_static
r_void
id|__pmac
id|pmac_set_irq_mask
c_func
(paren
r_int
r_int
id|irq_nr
comma
r_int
id|nokicklost
)paren
(brace
r_int
r_int
id|bit
op_assign
l_int|1UL
op_lshift
(paren
id|irq_nr
op_amp
l_int|0x1f
)paren
suffix:semicolon
r_int
id|i
op_assign
id|irq_nr
op_rshift
l_int|5
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|irq_nr
op_ge
id|max_irqs
)paren
r_return
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pmac_pic_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* enable unmasked interrupts */
id|out_le32
c_func
(paren
op_amp
id|pmac_irq_hw
(braket
id|i
)braket
op_member_access_from_pointer
id|enable
comma
id|ppc_cached_irq_mask
(braket
id|i
)braket
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* make sure mask gets to controller before we&n;                   return to user */
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|in_le32
c_func
(paren
op_amp
id|pmac_irq_hw
(braket
id|i
)braket
op_member_access_from_pointer
id|enable
)paren
op_amp
id|bit
)paren
op_ne
(paren
id|ppc_cached_irq_mask
(braket
id|i
)braket
op_amp
id|bit
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/*&n;         * Unfortunately, setting the bit in the enable register&n;         * when the device interrupt is already on *doesn&squot;t* set&n;         * the bit in the flag register or request another interrupt.&n;         */
r_if
c_cond
(paren
id|bit
op_amp
id|ppc_cached_irq_mask
(braket
id|i
)braket
op_amp
id|in_le32
c_func
(paren
op_amp
id|pmac_irq_hw
(braket
id|i
)braket
op_member_access_from_pointer
id|level
)paren
)paren
id|__set_lost
c_func
(paren
(paren
id|ulong
)paren
id|irq_nr
comma
id|nokicklost
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pmac_pic_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|pmac_mask_irq
r_static
r_void
id|__pmac
id|pmac_mask_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
(brace
id|clear_bit
c_func
(paren
id|irq_nr
comma
id|ppc_cached_irq_mask
)paren
suffix:semicolon
id|pmac_set_irq_mask
c_func
(paren
id|irq_nr
comma
l_int|0
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|pmac_unmask_irq
r_static
r_void
id|__pmac
id|pmac_unmask_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
(brace
id|set_bit
c_func
(paren
id|irq_nr
comma
id|ppc_cached_irq_mask
)paren
suffix:semicolon
id|pmac_set_irq_mask
c_func
(paren
id|irq_nr
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|pmac_end_irq
r_static
r_void
id|__pmac
id|pmac_end_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|irq_desc
(braket
id|irq_nr
)braket
dot
id|status
op_amp
(paren
id|IRQ_DISABLED
op_or
id|IRQ_INPROGRESS
)paren
)paren
op_logical_and
id|irq_desc
(braket
id|irq_nr
)braket
dot
id|action
)paren
(brace
id|set_bit
c_func
(paren
id|irq_nr
comma
id|ppc_cached_irq_mask
)paren
suffix:semicolon
id|pmac_set_irq_mask
c_func
(paren
id|irq_nr
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
DECL|variable|pmac_pic
r_struct
id|hw_interrupt_type
id|pmac_pic
op_assign
(brace
l_string|&quot; PMAC-PIC &quot;
comma
l_int|NULL
comma
l_int|NULL
comma
id|pmac_unmask_irq
comma
id|pmac_mask_irq
comma
id|pmac_mask_and_ack_irq
comma
id|pmac_end_irq
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|gatwick_pic
r_struct
id|hw_interrupt_type
id|gatwick_pic
op_assign
(brace
l_string|&quot; GATWICK  &quot;
comma
l_int|NULL
comma
l_int|NULL
comma
id|pmac_unmask_irq
comma
id|pmac_mask_irq
comma
id|pmac_mask_and_ack_irq
comma
id|pmac_end_irq
comma
l_int|NULL
)brace
suffix:semicolon
DECL|function|gatwick_action
r_static
id|irqreturn_t
id|gatwick_action
c_func
(paren
r_int
id|cpl
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|irq
comma
id|bits
suffix:semicolon
r_for
c_loop
(paren
id|irq
op_assign
id|max_irqs
suffix:semicolon
(paren
id|irq
op_sub_assign
l_int|32
)paren
op_ge
id|max_real_irqs
suffix:semicolon
)paren
(brace
r_int
id|i
op_assign
id|irq
op_rshift
l_int|5
suffix:semicolon
id|bits
op_assign
id|in_le32
c_func
(paren
op_amp
id|pmac_irq_hw
(braket
id|i
)braket
op_member_access_from_pointer
id|event
)paren
op_or
id|ppc_lost_interrupts
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* We must read level interrupts from the level register */
id|bits
op_or_assign
(paren
id|in_le32
c_func
(paren
op_amp
id|pmac_irq_hw
(braket
id|i
)braket
op_member_access_from_pointer
id|level
)paren
op_amp
id|level_mask
(braket
id|i
)braket
)paren
suffix:semicolon
id|bits
op_and_assign
id|ppc_cached_irq_mask
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bits
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|irq
op_add_assign
id|__ilog2
c_func
(paren
id|bits
)paren
suffix:semicolon
id|ppc_irq_dispatch_handler
c_func
(paren
id|regs
comma
id|irq
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;gatwick irq not from gatwick pic&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|IRQ_NONE
suffix:semicolon
)brace
r_int
DECL|function|pmac_get_irq
id|pmac_get_irq
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|irq
suffix:semicolon
r_int
r_int
id|bits
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_void
id|psurge_smp_message_recv
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
multiline_comment|/* IPI&squot;s are a hack on the powersurge -- Cort */
r_if
c_cond
(paren
id|smp_processor_id
c_func
(paren
)paren
op_ne
l_int|0
)paren
(brace
id|psurge_smp_message_recv
c_func
(paren
id|regs
)paren
suffix:semicolon
r_return
op_minus
l_int|2
suffix:semicolon
multiline_comment|/* ignore, already handled */
)brace
macro_line|#endif /* CONFIG_SMP */
r_for
c_loop
(paren
id|irq
op_assign
id|max_real_irqs
suffix:semicolon
(paren
id|irq
op_sub_assign
l_int|32
)paren
op_ge
l_int|0
suffix:semicolon
)paren
(brace
r_int
id|i
op_assign
id|irq
op_rshift
l_int|5
suffix:semicolon
id|bits
op_assign
id|in_le32
c_func
(paren
op_amp
id|pmac_irq_hw
(braket
id|i
)braket
op_member_access_from_pointer
id|event
)paren
op_or
id|ppc_lost_interrupts
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* We must read level interrupts from the level register */
id|bits
op_or_assign
(paren
id|in_le32
c_func
(paren
op_amp
id|pmac_irq_hw
(braket
id|i
)braket
op_member_access_from_pointer
id|level
)paren
op_amp
id|level_mask
(braket
id|i
)braket
)paren
suffix:semicolon
id|bits
op_and_assign
id|ppc_cached_irq_mask
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bits
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|irq
op_add_assign
id|__ilog2
c_func
(paren
id|bits
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|irq
suffix:semicolon
)brace
multiline_comment|/* This routine will fix some missing interrupt values in the device tree&n; * on the gatwick mac-io controller used by some PowerBooks&n; */
r_static
r_void
id|__init
DECL|function|pmac_fix_gatwick_interrupts
id|pmac_fix_gatwick_interrupts
c_func
(paren
r_struct
id|device_node
op_star
id|gw
comma
r_int
id|irq_base
)paren
(brace
r_struct
id|device_node
op_star
id|node
suffix:semicolon
r_int
id|count
suffix:semicolon
id|memset
c_func
(paren
id|gatwick_int_pool
comma
l_int|0
comma
r_sizeof
(paren
id|gatwick_int_pool
)paren
)paren
suffix:semicolon
id|node
op_assign
id|gw-&gt;child
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|node
)paren
(brace
multiline_comment|/* Fix SCC */
r_if
c_cond
(paren
id|strcasecmp
c_func
(paren
id|node-&gt;name
comma
l_string|&quot;escc&quot;
)paren
op_eq
l_int|0
)paren
r_if
c_cond
(paren
id|node-&gt;child
)paren
(brace
r_if
c_cond
(paren
id|node-&gt;child-&gt;n_intrs
OL
l_int|3
)paren
(brace
id|node-&gt;child-&gt;intrs
op_assign
op_amp
id|gatwick_int_pool
(braket
id|count
)braket
suffix:semicolon
id|count
op_add_assign
l_int|3
suffix:semicolon
)brace
id|node-&gt;child-&gt;n_intrs
op_assign
l_int|3
suffix:semicolon
id|node-&gt;child-&gt;intrs
(braket
l_int|0
)braket
dot
id|line
op_assign
l_int|15
op_plus
id|irq_base
suffix:semicolon
id|node-&gt;child-&gt;intrs
(braket
l_int|1
)braket
dot
id|line
op_assign
l_int|4
op_plus
id|irq_base
suffix:semicolon
id|node-&gt;child-&gt;intrs
(braket
l_int|2
)braket
dot
id|line
op_assign
l_int|5
op_plus
id|irq_base
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;irq: fixed SCC on second controller (%d,%d,%d)&bslash;n&quot;
comma
id|node-&gt;child-&gt;intrs
(braket
l_int|0
)braket
dot
id|line
comma
id|node-&gt;child-&gt;intrs
(braket
l_int|1
)braket
dot
id|line
comma
id|node-&gt;child-&gt;intrs
(braket
l_int|2
)braket
dot
id|line
)paren
suffix:semicolon
)brace
multiline_comment|/* Fix media-bay &amp; left SWIM */
r_if
c_cond
(paren
id|strcasecmp
c_func
(paren
id|node-&gt;name
comma
l_string|&quot;media-bay&quot;
)paren
op_eq
l_int|0
)paren
(brace
r_struct
id|device_node
op_star
id|ya_node
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;n_intrs
op_eq
l_int|0
)paren
id|node-&gt;intrs
op_assign
op_amp
id|gatwick_int_pool
(braket
id|count
op_increment
)braket
suffix:semicolon
id|node-&gt;n_intrs
op_assign
l_int|1
suffix:semicolon
id|node-&gt;intrs
(braket
l_int|0
)braket
dot
id|line
op_assign
l_int|29
op_plus
id|irq_base
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;irq: fixed media-bay on second controller (%d)&bslash;n&quot;
comma
id|node-&gt;intrs
(braket
l_int|0
)braket
dot
id|line
)paren
suffix:semicolon
id|ya_node
op_assign
id|node-&gt;child
suffix:semicolon
r_while
c_loop
(paren
id|ya_node
)paren
(brace
r_if
c_cond
(paren
id|strcasecmp
c_func
(paren
id|ya_node-&gt;name
comma
l_string|&quot;floppy&quot;
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ya_node-&gt;n_intrs
OL
l_int|2
)paren
(brace
id|ya_node-&gt;intrs
op_assign
op_amp
id|gatwick_int_pool
(braket
id|count
)braket
suffix:semicolon
id|count
op_add_assign
l_int|2
suffix:semicolon
)brace
id|ya_node-&gt;n_intrs
op_assign
l_int|2
suffix:semicolon
id|ya_node-&gt;intrs
(braket
l_int|0
)braket
dot
id|line
op_assign
l_int|19
op_plus
id|irq_base
suffix:semicolon
id|ya_node-&gt;intrs
(braket
l_int|1
)braket
dot
id|line
op_assign
l_int|1
op_plus
id|irq_base
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;irq: fixed floppy on second controller (%d,%d)&bslash;n&quot;
comma
id|ya_node-&gt;intrs
(braket
l_int|0
)braket
dot
id|line
comma
id|ya_node-&gt;intrs
(braket
l_int|1
)braket
dot
id|line
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strcasecmp
c_func
(paren
id|ya_node-&gt;name
comma
l_string|&quot;ata4&quot;
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ya_node-&gt;n_intrs
OL
l_int|2
)paren
(brace
id|ya_node-&gt;intrs
op_assign
op_amp
id|gatwick_int_pool
(braket
id|count
)braket
suffix:semicolon
id|count
op_add_assign
l_int|2
suffix:semicolon
)brace
id|ya_node-&gt;n_intrs
op_assign
l_int|2
suffix:semicolon
id|ya_node-&gt;intrs
(braket
l_int|0
)braket
dot
id|line
op_assign
l_int|14
op_plus
id|irq_base
suffix:semicolon
id|ya_node-&gt;intrs
(braket
l_int|1
)braket
dot
id|line
op_assign
l_int|3
op_plus
id|irq_base
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;irq: fixed ide on second controller (%d,%d)&bslash;n&quot;
comma
id|ya_node-&gt;intrs
(braket
l_int|0
)braket
dot
id|line
comma
id|ya_node-&gt;intrs
(braket
l_int|1
)braket
dot
id|line
)paren
suffix:semicolon
)brace
id|ya_node
op_assign
id|ya_node-&gt;sibling
suffix:semicolon
)brace
)brace
id|node
op_assign
id|node-&gt;sibling
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OG
l_int|10
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;WARNING !! Gatwick interrupt pool overflow&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  GATWICK_IRQ_POOL_SIZE = %d&bslash;n&quot;
comma
id|GATWICK_IRQ_POOL_SIZE
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;              requested = %d&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * The PowerBook 3400/2400/3500 can have a combo ethernet/modem&n; * card which includes an ohare chip that acts as a second interrupt&n; * controller.  If we find this second ohare, set it up and fix the&n; * interrupt value in the device tree for the ethernet chip.&n; */
DECL|function|enable_second_ohare
r_static
r_int
id|__init
id|enable_second_ohare
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|bus
comma
id|devfn
suffix:semicolon
r_int
r_int
id|cmd
suffix:semicolon
r_int
r_int
id|addr
suffix:semicolon
r_struct
id|device_node
op_star
id|irqctrler
op_assign
id|find_devices
c_func
(paren
l_string|&quot;pci106b,7&quot;
)paren
suffix:semicolon
r_struct
id|device_node
op_star
id|ether
suffix:semicolon
r_if
c_cond
(paren
id|irqctrler
op_eq
l_int|NULL
op_logical_or
id|irqctrler-&gt;n_addrs
op_le
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|addr
op_assign
(paren
r_int
r_int
)paren
id|ioremap
c_func
(paren
id|irqctrler-&gt;addrs
(braket
l_int|0
)braket
dot
id|address
comma
l_int|0x40
)paren
suffix:semicolon
id|pmac_irq_hw
(braket
l_int|1
)braket
op_assign
(paren
r_volatile
r_struct
id|pmac_irq_hw
op_star
)paren
(paren
id|addr
op_plus
l_int|0x20
)paren
suffix:semicolon
id|max_irqs
op_assign
l_int|64
suffix:semicolon
r_if
c_cond
(paren
id|pci_device_from_OF_node
c_func
(paren
id|irqctrler
comma
op_amp
id|bus
comma
op_amp
id|devfn
)paren
op_eq
l_int|0
)paren
(brace
r_struct
id|pci_controller
op_star
id|hose
op_assign
id|pci_find_hose_for_OF_device
c_func
(paren
id|irqctrler
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hose
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Can&squot;t find PCI hose for OHare2 !&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
id|early_read_config_word
c_func
(paren
id|hose
comma
id|bus
comma
id|devfn
comma
id|PCI_COMMAND
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|cmd
op_or_assign
id|PCI_COMMAND_MEMORY
op_or
id|PCI_COMMAND_MASTER
suffix:semicolon
id|cmd
op_and_assign
op_complement
id|PCI_COMMAND_IO
suffix:semicolon
id|early_write_config_word
c_func
(paren
id|hose
comma
id|bus
comma
id|devfn
comma
id|PCI_COMMAND
comma
id|cmd
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Fix interrupt for the modem/ethernet combo controller. The number&n;&t;   in the device tree (27) is bogus (correct for the ethernet-only&n;&t;   board but not the combo ethernet/modem board).&n;&t;   The real interrupt is 28 on the second controller -&gt; 28+32 = 60.&n;&t;*/
id|ether
op_assign
id|find_devices
c_func
(paren
l_string|&quot;pci1011,14&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ether
op_logical_and
id|ether-&gt;n_intrs
OG
l_int|0
)paren
(brace
id|ether-&gt;intrs
(braket
l_int|0
)braket
dot
id|line
op_assign
l_int|60
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;irq: Fixed ethernet IRQ to %d&bslash;n&quot;
comma
id|ether-&gt;intrs
(braket
l_int|0
)braket
dot
id|line
)paren
suffix:semicolon
)brace
multiline_comment|/* Return the interrupt number of the cascade */
r_return
id|irqctrler-&gt;intrs
(braket
l_int|0
)braket
dot
id|line
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_POWER4
DECL|function|k2u3_action
r_static
id|irqreturn_t
id|k2u3_action
c_func
(paren
r_int
id|cpl
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|irq
suffix:semicolon
id|irq
op_assign
id|openpic2_get_irq
c_func
(paren
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ne
op_minus
l_int|1
)paren
id|ppc_irq_dispatch_handler
c_func
(paren
id|regs
comma
id|irq
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_POWER4 */
DECL|function|pmac_pic_init
r_void
id|__init
id|pmac_pic_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|device_node
op_star
id|irqctrler
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|device_node
op_star
id|irqctrler2
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_int
r_int
id|addr
suffix:semicolon
r_int
id|irq_cascade
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* We first try to detect Apple&squot;s new Core99 chipset, since mac-io&n;&t; * is quite different on those machines and contains an IBM MPIC2.&n;&t; */
id|np
op_assign
id|find_type_devices
c_func
(paren
l_string|&quot;open-pic&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|np
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;parent
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;parent-&gt;name
comma
l_string|&quot;u3&quot;
)paren
)paren
id|irqctrler2
op_assign
id|np
suffix:semicolon
r_else
id|irqctrler
op_assign
id|np
suffix:semicolon
id|np
op_assign
id|np-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irqctrler
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|irqctrler-&gt;n_addrs
OG
l_int|0
)paren
(brace
r_int
r_char
id|senses
(braket
l_int|128
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;PowerMac using OpenPIC irq controller at 0x%08x&bslash;n&quot;
comma
id|irqctrler-&gt;addrs
(braket
l_int|0
)braket
dot
id|address
)paren
suffix:semicolon
id|prom_get_irq_senses
c_func
(paren
id|senses
comma
l_int|0
comma
l_int|128
)paren
suffix:semicolon
id|OpenPIC_InitSenses
op_assign
id|senses
suffix:semicolon
id|OpenPIC_NumInitSenses
op_assign
l_int|128
suffix:semicolon
id|ppc_md.get_irq
op_assign
id|openpic_get_irq
suffix:semicolon
id|pmac_call_feature
c_func
(paren
id|PMAC_FTR_ENABLE_MPIC
comma
id|irqctrler
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|OpenPIC_Addr
op_assign
id|ioremap
c_func
(paren
id|irqctrler-&gt;addrs
(braket
l_int|0
)braket
dot
id|address
comma
id|irqctrler-&gt;addrs
(braket
l_int|0
)braket
dot
id|size
)paren
suffix:semicolon
id|openpic_init
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_POWER4
r_if
c_cond
(paren
id|irqctrler2
op_ne
l_int|NULL
op_logical_and
id|irqctrler2-&gt;n_intrs
OG
l_int|0
op_logical_and
id|irqctrler2-&gt;n_addrs
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Slave OpenPIC at 0x%08x hooked on IRQ %d&bslash;n&quot;
comma
id|irqctrler2-&gt;addrs
(braket
l_int|0
)braket
dot
id|address
comma
id|irqctrler2-&gt;intrs
(braket
l_int|0
)braket
dot
id|line
)paren
suffix:semicolon
id|pmac_call_feature
c_func
(paren
id|PMAC_FTR_ENABLE_MPIC
comma
id|irqctrler2
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|OpenPIC2_Addr
op_assign
id|ioremap
c_func
(paren
id|irqctrler2-&gt;addrs
(braket
l_int|0
)braket
dot
id|address
comma
id|irqctrler2-&gt;addrs
(braket
l_int|0
)braket
dot
id|size
)paren
suffix:semicolon
id|prom_get_irq_senses
c_func
(paren
id|senses
comma
id|PMAC_OPENPIC2_OFFSET
comma
id|PMAC_OPENPIC2_OFFSET
op_plus
l_int|128
)paren
suffix:semicolon
id|OpenPIC_InitSenses
op_assign
id|senses
suffix:semicolon
id|OpenPIC_NumInitSenses
op_assign
l_int|128
suffix:semicolon
id|openpic2_init
c_func
(paren
id|PMAC_OPENPIC2_OFFSET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|irqctrler2-&gt;intrs
(braket
l_int|0
)braket
dot
id|line
comma
id|k2u3_action
comma
l_int|0
comma
l_string|&quot;U3-&gt;K2 Cascade&quot;
comma
l_int|NULL
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;Unable to get OpenPIC IRQ for cascade&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_POWER4 */
macro_line|#ifdef CONFIG_XMON
(brace
r_struct
id|device_node
op_star
id|pswitch
suffix:semicolon
r_int
id|nmi_irq
suffix:semicolon
id|pswitch
op_assign
id|find_devices
c_func
(paren
l_string|&quot;programmer-switch&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pswitch
op_logical_and
id|pswitch-&gt;n_intrs
)paren
(brace
id|nmi_irq
op_assign
id|pswitch-&gt;intrs
(braket
l_int|0
)braket
dot
id|line
suffix:semicolon
id|openpic_init_nmi_irq
c_func
(paren
id|nmi_irq
)paren
suffix:semicolon
id|request_irq
c_func
(paren
id|nmi_irq
comma
id|xmon_irq
comma
l_int|0
comma
l_string|&quot;NMI - XMON&quot;
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* CONFIG_XMON */
r_return
suffix:semicolon
)brace
id|irqctrler
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Get the level/edge settings, assume if it&squot;s not&n;&t; * a Grand Central nor an OHare, then it&squot;s an Heathrow&n;&t; * (or Paddington).&n;&t; */
r_if
c_cond
(paren
id|find_devices
c_func
(paren
l_string|&quot;gc&quot;
)paren
)paren
id|level_mask
(braket
l_int|0
)braket
op_assign
id|GC_LEVEL_MASK
suffix:semicolon
r_else
r_if
c_cond
(paren
id|find_devices
c_func
(paren
l_string|&quot;ohare&quot;
)paren
)paren
(brace
id|level_mask
(braket
l_int|0
)braket
op_assign
id|OHARE_LEVEL_MASK
suffix:semicolon
multiline_comment|/* We might have a second cascaded ohare */
id|level_mask
(braket
l_int|1
)braket
op_assign
id|OHARE_LEVEL_MASK
suffix:semicolon
)brace
r_else
(brace
id|level_mask
(braket
l_int|0
)braket
op_assign
id|HEATHROW_LEVEL_MASK
suffix:semicolon
id|level_mask
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We might have a second cascaded heathrow */
id|level_mask
(braket
l_int|2
)braket
op_assign
id|HEATHROW_LEVEL_MASK
suffix:semicolon
id|level_mask
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * G3 powermacs and 1999 G3 PowerBooks have 64 interrupts,&n;&t; * 1998 G3 Series PowerBooks have 128,&n;&t; * other powermacs have 32.&n;&t; * The combo ethernet/modem card for the Powerstar powerbooks&n;&t; * (2400/3400/3500, ohare based) has a second ohare chip&n;&t; * effectively making a total of 64.&n;&t; */
id|max_irqs
op_assign
id|max_real_irqs
op_assign
l_int|32
suffix:semicolon
id|irqctrler
op_assign
id|find_devices
c_func
(paren
l_string|&quot;mac-io&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irqctrler
)paren
(brace
id|max_real_irqs
op_assign
l_int|64
suffix:semicolon
r_if
c_cond
(paren
id|irqctrler-&gt;next
)paren
id|max_irqs
op_assign
l_int|128
suffix:semicolon
r_else
id|max_irqs
op_assign
l_int|64
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max_real_irqs
suffix:semicolon
id|i
op_increment
)paren
id|irq_desc
(braket
id|i
)braket
dot
id|handler
op_assign
op_amp
id|pmac_pic
suffix:semicolon
multiline_comment|/* get addresses of first controller */
r_if
c_cond
(paren
id|irqctrler
)paren
(brace
r_if
c_cond
(paren
id|irqctrler-&gt;n_addrs
OG
l_int|0
)paren
(brace
id|addr
op_assign
(paren
r_int
r_int
)paren
id|ioremap
c_func
(paren
id|irqctrler-&gt;addrs
(braket
l_int|0
)braket
dot
id|address
comma
l_int|0x40
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
op_increment
id|i
)paren
id|pmac_irq_hw
(braket
id|i
)braket
op_assign
(paren
r_volatile
r_struct
id|pmac_irq_hw
op_star
)paren
(paren
id|addr
op_plus
(paren
l_int|2
op_minus
id|i
)paren
op_star
l_int|0x10
)paren
suffix:semicolon
)brace
multiline_comment|/* get addresses of second controller */
id|irqctrler
op_assign
id|irqctrler-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|irqctrler
op_logical_and
id|irqctrler-&gt;n_addrs
OG
l_int|0
)paren
(brace
id|addr
op_assign
(paren
r_int
r_int
)paren
id|ioremap
c_func
(paren
id|irqctrler-&gt;addrs
(braket
l_int|0
)braket
dot
id|address
comma
l_int|0x40
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|2
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
id|pmac_irq_hw
(braket
id|i
)braket
op_assign
(paren
r_volatile
r_struct
id|pmac_irq_hw
op_star
)paren
(paren
id|addr
op_plus
(paren
l_int|4
op_minus
id|i
)paren
op_star
l_int|0x10
)paren
suffix:semicolon
id|irq_cascade
op_assign
id|irqctrler-&gt;intrs
(braket
l_int|0
)braket
dot
id|line
suffix:semicolon
r_if
c_cond
(paren
id|device_is_compatible
c_func
(paren
id|irqctrler
comma
l_string|&quot;gatwick&quot;
)paren
)paren
id|pmac_fix_gatwick_interrupts
c_func
(paren
id|irqctrler
comma
id|max_real_irqs
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* older powermacs have a GC (grand central) or ohare at&n;&t;&t;   f3000000, with interrupt control registers at f3000020. */
id|addr
op_assign
(paren
r_int
r_int
)paren
id|ioremap
c_func
(paren
l_int|0xf3000000
comma
l_int|0x40
)paren
suffix:semicolon
id|pmac_irq_hw
(braket
l_int|0
)braket
op_assign
(paren
r_volatile
r_struct
id|pmac_irq_hw
op_star
)paren
(paren
id|addr
op_plus
l_int|0x20
)paren
suffix:semicolon
)brace
multiline_comment|/* PowerBooks 3400 and 3500 can have a second controller in a second&n;&t;   ohare chip, on the combo ethernet/modem card */
r_if
c_cond
(paren
id|machine_is_compatible
c_func
(paren
l_string|&quot;AAPL,3400/2400&quot;
)paren
op_logical_or
id|machine_is_compatible
c_func
(paren
l_string|&quot;AAPL,3500&quot;
)paren
)paren
id|irq_cascade
op_assign
id|enable_second_ohare
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* disable all interrupts in all controllers */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_star
l_int|32
OL
id|max_irqs
suffix:semicolon
op_increment
id|i
)paren
id|out_le32
c_func
(paren
op_amp
id|pmac_irq_hw
(braket
id|i
)braket
op_member_access_from_pointer
id|enable
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* mark level interrupts */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max_irqs
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|level_mask
(braket
id|i
op_rshift
l_int|5
)braket
op_amp
(paren
l_int|1UL
op_lshift
(paren
id|i
op_amp
l_int|0x1f
)paren
)paren
)paren
id|irq_desc
(braket
id|i
)braket
dot
id|status
op_assign
id|IRQ_LEVEL
suffix:semicolon
multiline_comment|/* get interrupt line of secondary interrupt controller */
r_if
c_cond
(paren
id|irq_cascade
op_ge
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;irq: secondary controller on irq %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|irq_cascade
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|max_real_irqs
suffix:semicolon
id|i
OL
id|max_irqs
suffix:semicolon
id|i
op_increment
)paren
id|irq_desc
(braket
id|i
)braket
dot
id|handler
op_assign
op_amp
id|gatwick_pic
suffix:semicolon
id|request_irq
c_func
(paren
id|irq_cascade
comma
id|gatwick_action
comma
id|SA_INTERRUPT
comma
l_string|&quot;cascade&quot;
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;System has %d possible interrupts&bslash;n&quot;
comma
id|max_irqs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_irqs
op_ne
id|max_real_irqs
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%d interrupts on main controller&bslash;n&quot;
comma
id|max_real_irqs
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_XMON
id|request_irq
c_func
(paren
l_int|20
comma
id|xmon_irq
comma
l_int|0
comma
l_string|&quot;NMI - XMON&quot;
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif&t;/* CONFIG_XMON */
)brace
macro_line|#ifdef CONFIG_PM
multiline_comment|/*&n; * These procedures are used in implementing sleep on the powerbooks.&n; * sleep_save_intrs() saves the states of all interrupt enables&n; * and disables all interrupts except for the nominated one.&n; * sleep_restore_intrs() restores the states of all interrupt enables.&n; */
DECL|variable|sleep_save_mask
r_int
r_int
id|sleep_save_mask
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* This used to be passed by the PMU driver but that link got&n; * broken with the new driver model. We use this tweak for now...&n; */
DECL|function|pmacpic_find_viaint
r_static
r_int
id|pmacpic_find_viaint
c_func
(paren
r_void
)paren
(brace
r_int
id|viaint
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_ADB_PMU
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_if
c_cond
(paren
id|pmu_get_model
c_func
(paren
)paren
op_ne
id|PMU_OHARE_BASED
)paren
r_goto
id|not_found
suffix:semicolon
id|np
op_assign
id|of_find_node_by_name
c_func
(paren
l_int|NULL
comma
l_string|&quot;via-pmu&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np
op_eq
l_int|NULL
)paren
r_goto
id|not_found
suffix:semicolon
id|viaint
op_assign
id|np-&gt;intrs
(braket
l_int|0
)braket
dot
id|line
suffix:semicolon
macro_line|#endif /* CONFIG_ADB_PMU */
id|not_found
suffix:colon
r_return
id|viaint
suffix:semicolon
)brace
DECL|function|pmacpic_suspend
r_static
r_int
id|pmacpic_suspend
c_func
(paren
r_struct
id|sys_device
op_star
id|sysdev
comma
id|u32
id|state
)paren
(brace
r_int
id|viaint
op_assign
id|pmacpic_find_viaint
c_func
(paren
)paren
suffix:semicolon
id|sleep_save_mask
(braket
l_int|0
)braket
op_assign
id|ppc_cached_irq_mask
(braket
l_int|0
)braket
suffix:semicolon
id|sleep_save_mask
(braket
l_int|1
)braket
op_assign
id|ppc_cached_irq_mask
(braket
l_int|1
)braket
suffix:semicolon
id|ppc_cached_irq_mask
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|ppc_cached_irq_mask
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|viaint
OG
l_int|0
)paren
id|set_bit
c_func
(paren
id|viaint
comma
id|ppc_cached_irq_mask
)paren
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|pmac_irq_hw
(braket
l_int|0
)braket
op_member_access_from_pointer
id|enable
comma
id|ppc_cached_irq_mask
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_real_irqs
OG
l_int|32
)paren
id|out_le32
c_func
(paren
op_amp
id|pmac_irq_hw
(braket
l_int|1
)braket
op_member_access_from_pointer
id|enable
comma
id|ppc_cached_irq_mask
(braket
l_int|1
)braket
)paren
suffix:semicolon
(paren
r_void
)paren
id|in_le32
c_func
(paren
op_amp
id|pmac_irq_hw
(braket
l_int|0
)braket
op_member_access_from_pointer
id|event
)paren
suffix:semicolon
multiline_comment|/* make sure mask gets to controller before we return to caller */
id|mb
c_func
(paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|in_le32
c_func
(paren
op_amp
id|pmac_irq_hw
(braket
l_int|0
)braket
op_member_access_from_pointer
id|enable
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pmacpic_resume
r_static
r_int
id|pmacpic_resume
c_func
(paren
r_struct
id|sys_device
op_star
id|sysdev
)paren
(brace
r_int
id|i
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|pmac_irq_hw
(braket
l_int|0
)braket
op_member_access_from_pointer
id|enable
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_real_irqs
OG
l_int|32
)paren
id|out_le32
c_func
(paren
op_amp
id|pmac_irq_hw
(braket
l_int|1
)braket
op_member_access_from_pointer
id|enable
comma
l_int|0
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max_real_irqs
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|i
comma
id|sleep_save_mask
)paren
)paren
id|pmac_unmask_irq
c_func
(paren
id|i
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PM */
DECL|variable|pmacpic_sysclass
r_static
r_struct
id|sysdev_class
id|pmacpic_sysclass
op_assign
(brace
id|set_kset_name
c_func
(paren
l_string|&quot;pmac_pic&quot;
)paren
comma
)brace
suffix:semicolon
DECL|variable|device_pmacpic
r_static
r_struct
id|sys_device
id|device_pmacpic
op_assign
(brace
dot
id|id
op_assign
l_int|0
comma
dot
id|cls
op_assign
op_amp
id|pmacpic_sysclass
comma
)brace
suffix:semicolon
DECL|variable|driver_pmacpic
r_static
r_struct
id|sysdev_driver
id|driver_pmacpic
op_assign
(brace
macro_line|#ifdef CONFIG_PM
dot
id|suspend
op_assign
op_amp
id|pmacpic_suspend
comma
dot
id|resume
op_assign
op_amp
id|pmacpic_resume
comma
macro_line|#endif /* CONFIG_PM */
)brace
suffix:semicolon
DECL|function|init_pmacpic_sysfs
r_static
r_int
id|__init
id|init_pmacpic_sysfs
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|max_irqs
op_eq
l_int|0
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Registering pmac pic with sysfs...&bslash;n&quot;
)paren
suffix:semicolon
id|sysdev_class_register
c_func
(paren
op_amp
id|pmacpic_sysclass
)paren
suffix:semicolon
id|sysdev_register
c_func
(paren
op_amp
id|device_pmacpic
)paren
suffix:semicolon
id|sysdev_driver_register
c_func
(paren
op_amp
id|pmacpic_sysclass
comma
op_amp
id|driver_pmacpic
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|init_pmacpic_sysfs
id|subsys_initcall
c_func
(paren
id|init_pmacpic_sysfs
)paren
suffix:semicolon
eof
