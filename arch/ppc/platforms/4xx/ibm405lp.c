multiline_comment|/*&n; * arch/ppc/platforms/ibm405lp.c  405LP-specific code&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA&n; *&n; * Copyright (C) 2002, International Business Machines Corporation&n; * All Rights Reserved.&n; *&n; * Bishop Brock&n; * IBM Research, Austin Center for Low-Power Computing&n; * bcbrock@us.ibm.com&n; * March, 2002&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
macro_line|#include &lt;asm/hardirq.h&gt;
macro_line|#include &lt;asm/ibm4xx.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/time.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/ocp.h&gt;
DECL|variable|__initdata
r_struct
id|ocp_def
id|core_ocp
(braket
)braket
id|__initdata
op_assign
(brace
(brace
id|OCP_VENDOR_IBM
comma
id|OCP_FUNC_OPB
comma
id|OPB0_BASE
comma
id|OCP_IRQ_NA
comma
id|OCP_CPM_NA
)brace
comma
(brace
id|OCP_VENDOR_IBM
comma
id|OCP_FUNC_16550
comma
id|UART0_IO_BASE
comma
id|UART0_INT
comma
id|IBM_CPM_UART0
)brace
comma
(brace
id|OCP_VENDOR_IBM
comma
id|OCP_FUNC_16550
comma
id|UART1_IO_BASE
comma
id|UART1_INT
comma
id|IBM_CPM_UART1
)brace
comma
(brace
id|OCP_VENDOR_IBM
comma
id|OCP_FUNC_IIC
comma
id|IIC0_BASE
comma
id|IIC0_IRQ
comma
id|IBM_CPM_IIC0
)brace
comma
(brace
id|OCP_VENDOR_IBM
comma
id|OCP_FUNC_GPIO
comma
id|GPIO0_BASE
comma
id|OCP_IRQ_NA
comma
id|IBM_CPM_GPIO0
)brace
comma
(brace
id|OCP_VENDOR_INVALID
comma
id|OCP_FUNC_INVALID
comma
l_int|0x0
comma
id|OCP_IRQ_NA
comma
id|OCP_CPM_NA
)brace
comma
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_PM
multiline_comment|/* Set up the 405LP clock and power management unit for aggressive power&n;   management.  &n;&n;   Briefly, there are 3 CPM &quot;classes&quot;:&n;&n;   Class 1 - Either completely asleep or awake.  The &quot;force&quot; state is&n;             equivalent to the &quot;enabled&quot; state.  Many Class 1 units are &n;             critical system components and are never power managed.&n;&n;   Class 2 - Can be enabled for power management, where sleep requests are&n;             made by the peripheral, typically after an inactivity timeout.&n;&t;     When sleeping, critical interfaces remain active, and&n;&t;     awaken the unit whenever it is targeted with a transaction.&n;&n;   Class 3 - Can be enabled for power management, where sleep requests are&n;             made by the CPM.  Power management for these units typically &n;             will require intelligence in a device driver.&n;&n;   In the current implementation, the &quot;force&quot; bits are only used on Class 1&n;   devices, and only when the associated driver has the intelligence necessary&n;   to &quot;unforce&quot; the power management state.  A previous scheme, which tried to&n;   enable power management based on whether a particular driver was compiled&n;   with the kernel, caused many problems and is never used here.  &n;&n;   Class 2 devices with timeouts are normally initialized for the most&n;   aggressive values.  There is no power management benefit of &quot;forcing&quot; Class&n;   2 devices over letting their inactivity timeouts take effect.  Therefore,&n;   after being set up here, Class 2 device drivers don&squot;t need to worry about&n;   CPM.  &n;&n;   No Class 3 devices are handled yet.  */
r_void
id|__init
DECL|function|ibm405lp_setup_cpm
id|ibm405lp_setup_cpm
c_func
(paren
r_void
)paren
(brace
id|u32
id|force
op_assign
l_int|0
suffix:semicolon
id|u32
id|enable
op_assign
l_int|0
suffix:semicolon
id|dma0_slp_t
id|dma0_slp
suffix:semicolon
id|dcp0_cfg_t
id|dcp0_cfg
suffix:semicolon
id|ebc0_cfg_t
id|ebc0_cfg
suffix:semicolon
id|sdram0_cfg_t
id|sdram0_cfg
suffix:semicolon
id|sdram0_pmit_t
id|sdram0_pmit
suffix:semicolon
id|sla0_slpmd_t
id|sla0_slpmd
suffix:semicolon
multiline_comment|/* Initialize the CPM state */
id|mtdcr
c_func
(paren
id|DCRN_CPMFR
comma
id|force
)paren
suffix:semicolon
id|mtdcr
c_func
(paren
id|DCRN_CPMER
comma
id|enable
)paren
suffix:semicolon
multiline_comment|/* IIC - Class 3 - Not handled yet.  The driver should at least be able&n;&t;   to force/unforce itself. */
multiline_comment|/* CPU - class 2 - There doesn&squot;t appear to be a timeout associated with&n;&t;   this, and the exact function is not documented anywhere.  It saves a&n;&t;   lot of power, though. I assume this gates core clocks when the CPU&n;&t;   core is asleep, and probably adds a couple of cycles of latency when&n;&t;   the CPU core wakes up. */
id|enable
op_or_assign
id|IBM_CPM_CPU
suffix:semicolon
multiline_comment|/* DMA - class 2. Set for the minimum timeout, which is 32 cycles. */
id|dma0_slp.reg
op_assign
id|mfdcr
c_func
(paren
id|DCRN_SLP
)paren
suffix:semicolon
id|dma0_slp.fields.sme
op_assign
l_int|1
suffix:semicolon
id|dma0_slp.fields.idu
op_assign
l_int|0
suffix:semicolon
id|mtdcr
c_func
(paren
id|DCRN_SLP
comma
id|dma0_slp.reg
)paren
suffix:semicolon
id|enable
op_or_assign
id|IBM_CPM_DMA
suffix:semicolon
multiline_comment|/* BRG - Class 2.  Seems to crash the system when enabled in 405LP Pass&n;&t;   1 &n;&n;&t;   DCP (CodePack) - Class 2.  The semantics of the sleep delay are not&n;&t;   documented. We&squot;ll use 32 (what the heck). */
id|dcp0_cfg.reg
op_assign
id|mfdcri
c_func
(paren
id|DCRN_DCP0
comma
id|CFG
)paren
suffix:semicolon
id|dcp0_cfg.fields.slen
op_assign
l_int|1
suffix:semicolon
id|dcp0_cfg.fields.sldy
op_assign
l_int|32
suffix:semicolon
id|mtdcri
c_func
(paren
id|DCRN_DCP0
comma
id|CFG
comma
id|dcp0_cfg.reg
)paren
suffix:semicolon
id|enable
op_or_assign
id|IBM_CPM_DCP
suffix:semicolon
multiline_comment|/* EBC - Class 2.  Set for minimum timeout, which is 32 cycles. [ I&n;&t;   think this is 32. It may be 64. I don&squot;t trust the documentation. ]&n;&t; */
id|ebc0_cfg.reg
op_assign
id|mfdcri
c_func
(paren
id|DCRN_EBC0
comma
id|CFG
)paren
suffix:semicolon
id|ebc0_cfg.fields.pme
op_assign
l_int|1
suffix:semicolon
id|ebc0_cfg.fields.pmt
op_assign
l_int|1
suffix:semicolon
id|mtdcri
c_func
(paren
id|DCRN_EBC0
comma
id|CFG
comma
id|ebc0_cfg.reg
)paren
suffix:semicolon
id|enable
op_or_assign
id|IBM_CPM_EBC
suffix:semicolon
multiline_comment|/* SDRAM - Class 2.  Set for the minimum 32-cycle timeout.&n;&n;&t;   The documentation on this core is clear - waking a sleeping SDRAM&n;&t;   controller takes 2 PLB cycles, which is added to the latency of the&n;&t;   memory operation. If someone can prove that this is affecting&n;&t;   performance we can easily back this off.  */
id|sdram0_cfg.reg
op_assign
id|mfdcri
c_func
(paren
id|DCRN_SDRAM0
comma
id|CFG
)paren
suffix:semicolon
id|sdram0_cfg.fields.pme
op_assign
l_int|1
suffix:semicolon
id|mtdcri
c_func
(paren
id|DCRN_SDRAM0
comma
id|CFG
comma
id|sdram0_cfg.reg
)paren
suffix:semicolon
id|sdram0_pmit.reg
op_assign
id|mfdcri
c_func
(paren
id|DCRN_SDRAM0
comma
id|PMIT
)paren
suffix:semicolon
id|sdram0_pmit.fields.cnt
op_assign
l_int|0
suffix:semicolon
id|mtdcri
c_func
(paren
id|DCRN_SDRAM0
comma
id|PMIT
comma
id|sdram0_pmit.reg
)paren
suffix:semicolon
id|enable
op_or_assign
id|IBM_CPM_SDRAM0
suffix:semicolon
multiline_comment|/* PLB - Class 2.  Seems to crash the system when enabled in 405LP Pass&n;&t;   1.&n;&n;&t;   GPIO - Class 1.  This unit is used for many things, and no single&n;&t;   driver controls all GPIO.  It&squot;s best left unmanaged (it doesn&squot;t use&n;&t;   much power anyway). NB: 405LP Pass 1 erratum - forcing PM on GPIO&n;&t;   kills the TPC.&n;&n;&t;   UART0 - Class 1&n;&t;   UART1 - Class 1&n;&n;&t;   Someone should work on the serial port drivers to enable PM support&n;&t;   for them. Any takers?&n;&n;&t;   UIC        - Class 1&n;&t;   CPU_TMRCLK - Class 1&n;&n;&t;   These system resources are never power managed.  */
multiline_comment|/* SLA - Class 2.  Set for the minimum 32-cycle timeout. */
id|sla0_slpmd.reg
op_assign
id|mfdcri
c_func
(paren
id|DCRN_SLA0
comma
id|SLPMD
)paren
suffix:semicolon
id|sla0_slpmd.fields.slen
op_assign
l_int|1
suffix:semicolon
id|sla0_slpmd.fields.slcr
op_assign
l_int|0
suffix:semicolon
id|mtdcri
c_func
(paren
id|DCRN_SLA0
comma
id|SLPMD
comma
id|sla0_slpmd.reg
)paren
suffix:semicolon
id|enable
op_or_assign
id|IBM_CPM_SLA
suffix:semicolon
multiline_comment|/* CSI  - Class 1.  &n;&t;   TPC  - Class 1.&n;&t;   TDES - Class 1.&n;&n;&t;   The drivers for these units are power-aware, and manage the device&n;&t;   properly. By default these units are forced off at boot. */
id|force
op_or_assign
id|IBM_CPM_CSI
suffix:semicolon
id|force
op_or_assign
id|IBM_CPM_TPC
suffix:semicolon
id|force
op_or_assign
id|IBM_CPM_TDES
suffix:semicolon
multiline_comment|/* Set the CPM state */
id|mtdcr
c_func
(paren
id|DCRN_CPMFR
comma
id|force
)paren
suffix:semicolon
id|mtdcr
c_func
(paren
id|DCRN_CPMER
comma
id|enable
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* This routine is included here because the framebuffer driver needs a way to&n;   tell the system the Pixel clock frequency it needs, regardless of whether&n;   run-time frequency scaling is configured.  A hook and a couple of global&n;   variables are always present and will be used by the RTVFS driver if it is&n;   loaded.&n;&n;   Pixel clock setting is kind of a hack, as the frequency steps available from&n;   the PLB/PixClk divider may be too large to guarantee that we&squot;ll hit within&n;   the given limits.  We never set the frequency above the upper bound, but due&n;   to quantization may need to set the frequency below the lower bound.  So far&n;   it works OK for the panels we&squot;ve tried.&n;&n;   In general, the choice of a system clock frequency should be made with&n;   consideration of the LCD panel to be attached, to guarantee a good clock&n;   divider for the Pixel clock regardless of frequency scaling.&n;&n;   Clock frequencies are in KHz. If pixclk_min or pixclk_max are zero, we set&n;   the lowest possible frequency to conserve energy. */
DECL|variable|set_pixclk_hook
r_int
(paren
op_star
id|set_pixclk_hook
)paren
(paren
r_int
id|pixclk_min
comma
r_int
id|pixclk_max
)paren
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|last_pixclk_min
r_int
id|last_pixclk_min
op_assign
l_int|0
suffix:semicolon
DECL|variable|last_pixclk_max
r_int
id|last_pixclk_max
op_assign
l_int|0
suffix:semicolon
DECL|variable|set_pixclk_hook
id|EXPORT_SYMBOL
c_func
(paren
id|set_pixclk_hook
)paren
suffix:semicolon
DECL|variable|last_pixclk_min
id|EXPORT_SYMBOL
c_func
(paren
id|last_pixclk_min
)paren
suffix:semicolon
DECL|variable|last_pixclk_max
id|EXPORT_SYMBOL
c_func
(paren
id|last_pixclk_max
)paren
suffix:semicolon
r_int
DECL|function|ibm405lp_set_pixclk
id|ibm405lp_set_pixclk
c_func
(paren
r_int
id|pixclk_min
comma
r_int
id|pixclk_max
)paren
(brace
r_int
id|divider
suffix:semicolon
id|bd_t
op_star
id|bip
op_assign
(paren
id|bd_t
op_star
)paren
id|__res
suffix:semicolon
r_int
id|plb_khz
op_assign
id|bip-&gt;bi_busfreq
op_div
l_int|1000
suffix:semicolon
id|cpc0_cgcr1_t
id|cgcr1
suffix:semicolon
r_if
c_cond
(paren
id|set_pixclk_hook
)paren
(brace
r_return
(paren
id|set_pixclk_hook
)paren
(paren
id|pixclk_min
comma
id|pixclk_max
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|pixclk_min
op_eq
l_int|0
)paren
op_logical_or
(paren
id|pixclk_max
op_eq
l_int|0
)paren
)paren
id|divider
op_assign
id|CPC0_DIV_MAX
suffix:semicolon
r_else
(brace
id|divider
op_assign
id|plb_khz
op_div
id|pixclk_min
suffix:semicolon
r_if
c_cond
(paren
id|divider
op_eq
l_int|0
)paren
id|divider
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|divider
OL
id|CPC0_DIV_MAX
)paren
op_logical_and
(paren
(paren
id|plb_khz
op_div
id|divider
)paren
OG
id|pixclk_max
)paren
)paren
id|divider
op_increment
suffix:semicolon
)brace
id|cgcr1.reg
op_assign
id|mfdcr
c_func
(paren
id|DCRN_CPC0_CGCR1
)paren
suffix:semicolon
id|cgcr1.fields.ppxl
op_assign
id|CPC0_DIV_ENCODE
c_func
(paren
id|divider
)paren
suffix:semicolon
id|mtdcr
c_func
(paren
id|DCRN_CPC0_CGCR1
comma
id|cgcr1.reg
)paren
suffix:semicolon
id|last_pixclk_min
op_assign
id|pixclk_min
suffix:semicolon
id|last_pixclk_max
op_assign
id|pixclk_max
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
eof
