multiline_comment|/************************************************************************/
multiline_comment|/* This module supports the iSeries PCI bus device detection            */
multiline_comment|/* Copyright (C) 20yy  &lt;Robert L Holtorf&gt; &lt;IBM Corp&gt;                    */
multiline_comment|/*                                                                      */
multiline_comment|/* This program is free software; you can redistribute it and/or modify */
multiline_comment|/* it under the terms of the GNU General Public License as published by */
multiline_comment|/* the Free Software Foundation; either version 2 of the License, or    */
multiline_comment|/* (at your option) any later version.                                  */
multiline_comment|/*                                                                      */
multiline_comment|/* This program is distributed in the hope that it will be useful,      */
multiline_comment|/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
multiline_comment|/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
multiline_comment|/* GNU General Public License for more details.                         */
multiline_comment|/*                                                                      */
multiline_comment|/* You should have received a copy of the GNU General Public License    */
multiline_comment|/* along with this program; if not, write to the:                       */
multiline_comment|/* Free Software Foundation, Inc.,                                      */
multiline_comment|/* 59 Temple Place, Suite 330,                                          */
multiline_comment|/* Boston, MA  02111-1307  USA                                          */
multiline_comment|/************************************************************************/
multiline_comment|/* Change Activity:                                                     */
multiline_comment|/*   Created, December 13, 2000 by Wayne Holm                           */
multiline_comment|/* End Change Activity                                                  */
multiline_comment|/************************************************************************/
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;asm/pci-bridge.h&gt;
macro_line|#include &lt;asm/iSeries/HvCallXm.h&gt;
macro_line|#include &lt;asm/iSeries/HvCallPci.h&gt;
macro_line|#include &lt;asm/iSeries/iSeries_fixup.h&gt;
macro_line|#include &lt;asm/iSeries/LparData.h&gt;
macro_line|#include &lt;asm/iSeries/iSeries_irq.h&gt;
macro_line|#include &lt;asm/iSeries/iSeries_dma.h&gt;
macro_line|#include &lt;asm/iSeries/iSeries_VpdInfo.h&gt;
macro_line|#include &lt;asm/iSeries/iSeries_pci.h&gt;
macro_line|#include &quot;iSeries_IoMmTable.h&quot;
macro_line|#include &quot;iSeries_pci.h&quot;
DECL|function|iSeries_scan_slot
r_int
r_int
id|__init
id|iSeries_scan_slot
c_func
(paren
r_struct
id|pci_dev
op_star
id|temp_dev
comma
id|u16
id|hvBus
comma
id|u8
id|slotSubBus
comma
id|u8
id|maxAgents
)paren
(brace
id|u8
id|hvIdSel
comma
id|hvFunction
comma
id|hvAgentId
suffix:semicolon
id|u64
id|hvRc
op_assign
l_int|0
suffix:semicolon
id|u64
id|noConnectRc
op_assign
l_int|0xFFFF
suffix:semicolon
id|HvAgentId
id|slotAgentId
suffix:semicolon
r_int
id|irq
suffix:semicolon
id|slotAgentId
op_assign
id|ISERIES_PCI_AGENTID
c_func
(paren
id|ISERIES_GET_DEVICE_FROM_SUBBUS
c_func
(paren
id|slotSubBus
)paren
comma
id|ISERIES_GET_FUNCTION_FROM_SUBBUS
c_func
(paren
id|slotSubBus
)paren
)paren
suffix:semicolon
id|irq
op_assign
id|iSeries_allocate_IRQ
c_func
(paren
id|hvBus
comma
l_int|0
comma
id|slotAgentId
)paren
suffix:semicolon
r_for
c_loop
(paren
id|hvIdSel
op_assign
l_int|1
suffix:semicolon
id|hvIdSel
op_le
id|maxAgents
suffix:semicolon
op_increment
id|hvIdSel
)paren
(brace
multiline_comment|/* Connect all functions of any device found.  However, only call pci_scan_slot&n;&t;   once for each idsel.  pci_scan_slot handles multifunction devices appropriately */
r_for
c_loop
(paren
id|hvFunction
op_assign
l_int|0
suffix:semicolon
id|hvFunction
OL
l_int|8
op_logical_and
id|hvRc
op_eq
l_int|0
suffix:semicolon
op_increment
id|hvFunction
)paren
(brace
id|hvAgentId
op_assign
id|ISERIES_PCI_AGENTID
c_func
(paren
id|hvIdSel
comma
id|hvFunction
)paren
suffix:semicolon
id|hvRc
op_assign
id|HvCallXm_connectBusUnit
c_func
(paren
id|hvBus
comma
id|slotSubBus
comma
id|hvAgentId
comma
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hvRc
op_eq
l_int|0
)paren
(brace
id|noConnectRc
op_assign
l_int|0
suffix:semicolon
id|HvCallPci_configStore8
c_func
(paren
id|hvBus
comma
id|slotSubBus
comma
id|hvAgentId
comma
id|PCI_INTERRUPT_LINE
comma
id|irq
)paren
suffix:semicolon
singleline_comment|// Store the irq in the interrupt line register of the function config space
)brace
)brace
r_if
c_cond
(paren
id|noConnectRc
op_eq
l_int|0
)paren
(brace
multiline_comment|/* This assumes that the node slot is always on the primary bus! */
id|temp_dev-&gt;devfn
op_assign
id|ISERIES_ENCODE_SUBBUS
c_func
(paren
id|ISERIES_GET_DEVICE_FROM_SUBBUS
c_func
(paren
id|slotSubBus
)paren
comma
id|ISERIES_GET_FUNCTION_FROM_SUBBUS
c_func
(paren
id|slotSubBus
)paren
comma
l_int|0
)paren
suffix:semicolon
id|iSeries_assign_IRQ
c_func
(paren
id|irq
comma
id|hvBus
comma
l_int|0
comma
id|slotAgentId
)paren
suffix:semicolon
id|pci_scan_slot
c_func
(paren
id|temp_dev
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|iSeries_fixup_bus
r_void
id|__init
id|iSeries_fixup_bus
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
)paren
(brace
r_struct
id|pci_dev
id|temp_dev
suffix:semicolon
r_struct
id|pci_controller
op_star
id|hose
suffix:semicolon
id|u16
id|hvBus
suffix:semicolon
id|u8
id|hvSubBus
comma
id|hvIdSel
comma
id|hvFunction
comma
id|hvAgentId
comma
id|maxAgents
comma
id|irq
suffix:semicolon
id|u64
id|hvRc
comma
id|devInfoRealAdd
comma
id|bridgeInfoRealAdd
suffix:semicolon
r_struct
id|HvCallPci_DeviceInfo
op_star
id|devInfo
suffix:semicolon
r_struct
id|HvCallPci_BridgeInfo
op_star
id|bridgeInfo
suffix:semicolon
id|u64
id|noConnectRc
op_assign
l_int|0xFFFF
suffix:semicolon
id|hose
op_assign
(paren
r_struct
id|pci_controller
op_star
)paren
(paren
id|bus-&gt;sysdata
)paren
suffix:semicolon
multiline_comment|/* Get the hv bus number from the hose arch_data */
id|hvBus
op_assign
id|ISERIES_GET_HOSE_HV_BUSNUM
c_func
(paren
id|hose
)paren
suffix:semicolon
multiline_comment|/* Initialize the global bus number map for this bus */
id|iSeries_GlobalBusMap
(braket
id|bus-&gt;number
)braket
(braket
id|_HVBUSNUMBER_
)braket
op_assign
id|hvBus
suffix:semicolon
id|iSeries_GlobalBusMap
(braket
id|bus-&gt;number
)braket
(braket
id|_HVSUBBUSNUMBER_
)braket
op_assign
l_int|0
suffix:semicolon
id|maxAgents
op_assign
l_int|7
suffix:semicolon
multiline_comment|/* If not a primary bus, set the hypervisor subBus number of this bus into the map */
r_if
c_cond
(paren
id|bus-&gt;parent
op_ne
l_int|NULL
)paren
(brace
id|bridgeInfo
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|bridgeInfo
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/* Perform linux virtual address to iSeries PLIC real address translation */
id|bridgeInfoRealAdd
op_assign
id|virt_to_absolute
c_func
(paren
(paren
id|u32
)paren
id|bridgeInfo
)paren
suffix:semicolon
id|bridgeInfoRealAdd
op_assign
id|bridgeInfoRealAdd
op_or
l_int|0x8000000000000000
suffix:semicolon
multiline_comment|/* Find the Hypervisor address of the bridge which created this bus... */
r_if
c_cond
(paren
id|ISERIES_IS_SUBBUS_ENCODED_IN_DEVFN
c_func
(paren
id|bus-&gt;self-&gt;devfn
)paren
)paren
(brace
singleline_comment|// This assumes that the bus passed to this function is connected to an EADS slot.  The subbus encoding algorithm only applies to bridge cards attached directly to EADS.  Future TODO is to allow for n levels of bridging.
id|hvSubBus
op_assign
id|ISERIES_DEVFN_DECODE_SUBBUS
c_func
(paren
id|bus-&gt;self-&gt;devfn
)paren
suffix:semicolon
id|hvIdSel
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The hose arch_data needs to map Linux bus number -&gt; PHB bus/subBus number&n;               Could also use a global table, might be cheaper for multiple PHBs */
singleline_comment|// hvSubBus = iSeries_GlobalBusMap[bus-&gt;parent-&gt;number][_HVSUBBUSNUMBER_];
id|hvSubBus
op_assign
l_int|0
suffix:semicolon
singleline_comment|// The bridge card devfn is not subbus encoded and is directly attached to the PCI primary bus.  Its subbus number is 0 and the card config space is accessed via type 0 config cycles.
id|hvIdSel
op_assign
id|PCI_SLOT
c_func
(paren
id|bus-&gt;self-&gt;devfn
)paren
suffix:semicolon
)brace
id|hvAgentId
op_assign
id|ISERIES_PCI_AGENTID
c_func
(paren
id|hvIdSel
comma
id|PCI_FUNC
c_func
(paren
id|bus-&gt;self-&gt;devfn
)paren
)paren
suffix:semicolon
multiline_comment|/* Now we know the HV bus/subbus/agent of the bridge creating this bus,&n;           go get the subbus number from HV */
id|hvRc
op_assign
id|HvCallPci_getBusUnitInfo
c_func
(paren
id|hvBus
comma
id|hvSubBus
comma
id|hvAgentId
comma
id|bridgeInfoRealAdd
comma
r_sizeof
(paren
op_star
id|bridgeInfo
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hvRc
op_ne
l_int|0
op_logical_or
id|bridgeInfo-&gt;busUnitInfo.deviceType
op_ne
id|HvCallPci_BridgeDevice
)paren
(brace
id|kfree
c_func
(paren
id|bridgeInfo
)paren
suffix:semicolon
singleline_comment|// return -1;
)brace
id|iSeries_GlobalBusMap
(braket
id|bus-&gt;number
)braket
(braket
id|_HVSUBBUSNUMBER_
)braket
op_assign
id|bridgeInfo-&gt;subBusNumber
suffix:semicolon
id|maxAgents
op_assign
id|bridgeInfo-&gt;maxAgents
suffix:semicolon
id|kfree
c_func
(paren
id|bridgeInfo
)paren
suffix:semicolon
)brace
multiline_comment|/* Bus number mapping is complete, from here on cfgIos should result in HvCalls */
id|hvSubBus
op_assign
id|iSeries_GlobalBusMap
(braket
id|bus-&gt;number
)braket
(braket
id|_HVSUBBUSNUMBER_
)braket
suffix:semicolon
id|devInfo
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|devInfo
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|devInfoRealAdd
op_assign
id|virt_to_absolute
c_func
(paren
(paren
id|u32
)paren
id|devInfo
)paren
suffix:semicolon
id|devInfoRealAdd
op_assign
id|devInfoRealAdd
op_or
l_int|0x8000000000000000
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|temp_dev
comma
l_int|0
comma
r_sizeof
(paren
id|temp_dev
)paren
)paren
suffix:semicolon
id|temp_dev.bus
op_assign
id|bus
suffix:semicolon
id|temp_dev.sysdata
op_assign
id|bus-&gt;sysdata
suffix:semicolon
r_for
c_loop
(paren
id|hvIdSel
op_assign
l_int|1
suffix:semicolon
id|hvIdSel
op_le
id|maxAgents
suffix:semicolon
op_increment
id|hvIdSel
)paren
(brace
id|hvRc
op_assign
id|HvCallPci_getDeviceInfo
c_func
(paren
id|hvBus
comma
id|hvSubBus
comma
id|hvIdSel
comma
id|devInfoRealAdd
comma
r_sizeof
(paren
op_star
id|devInfo
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hvRc
op_eq
l_int|0
)paren
(brace
r_switch
c_cond
(paren
id|devInfo-&gt;deviceType
)paren
(brace
r_case
id|HvCallPci_NodeDevice
suffix:colon
multiline_comment|/* bridgeInfo = kmalloc(HvCallPci_MaxBusUnitInfoSize, GFP_KERNEL); */
id|bridgeInfo
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|bridgeInfo
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/* Loop through each node function to find usable bridges.  Scan&n;&t;&t;       the node bridge to create devices.  The devices will appear&n;&t;&t;       as if they were connected to the primary bus. */
r_for
c_loop
(paren
id|hvFunction
op_assign
l_int|0
suffix:semicolon
id|hvFunction
OL
l_int|8
suffix:semicolon
op_increment
id|hvFunction
)paren
(brace
id|hvAgentId
op_assign
id|ISERIES_PCI_AGENTID
c_func
(paren
id|hvIdSel
comma
id|hvFunction
)paren
suffix:semicolon
id|irq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Note: hvSubBus should always be 0 here! */
id|hvRc
op_assign
id|HvCallXm_connectBusUnit
c_func
(paren
id|hvBus
comma
id|hvSubBus
comma
id|hvAgentId
comma
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hvRc
op_eq
l_int|0
)paren
(brace
id|bridgeInfoRealAdd
op_assign
id|virt_to_absolute
c_func
(paren
(paren
id|u32
)paren
id|bridgeInfo
)paren
suffix:semicolon
id|bridgeInfoRealAdd
op_assign
id|bridgeInfoRealAdd
op_or
l_int|0x8000000000000000
suffix:semicolon
id|hvRc
op_assign
id|HvCallPci_getBusUnitInfo
c_func
(paren
id|hvBus
comma
id|hvSubBus
comma
id|hvAgentId
comma
id|bridgeInfoRealAdd
comma
r_sizeof
(paren
op_star
id|bridgeInfo
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hvRc
op_eq
l_int|0
op_logical_and
id|bridgeInfo-&gt;busUnitInfo.deviceType
op_eq
id|HvCallPci_BridgeDevice
)paren
(brace
singleline_comment|// scan any card plugged into this slot
id|iSeries_scan_slot
c_func
(paren
op_amp
id|temp_dev
comma
id|hvBus
comma
id|bridgeInfo-&gt;subBusNumber
comma
id|bridgeInfo-&gt;maxAgents
)paren
suffix:semicolon
)brace
)brace
)brace
id|kfree
c_func
(paren
id|bridgeInfo
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HvCallPci_MultiFunctionDevice
suffix:colon
multiline_comment|/* Attempt to connect each device function, then use architecture independent&n;&t;&t;       pci_scan_slot to build the device(s) */
id|irq
op_assign
id|bus-&gt;self-&gt;irq
suffix:semicolon
singleline_comment|// Assume that this multi-function device is attached to a secondary bus.  Get the irq from the dev struct for the bus and pass to Hv on the function connects as well as write it into the interrupt line registers of each function
r_for
c_loop
(paren
id|hvFunction
op_assign
l_int|0
suffix:semicolon
id|hvFunction
OL
l_int|8
op_logical_and
id|hvRc
op_eq
l_int|0
suffix:semicolon
op_increment
id|hvFunction
)paren
(brace
id|hvAgentId
op_assign
id|ISERIES_PCI_AGENTID
c_func
(paren
id|hvIdSel
comma
id|hvFunction
)paren
suffix:semicolon
multiline_comment|/* Try to connect each function. */
id|hvRc
op_assign
id|HvCallXm_connectBusUnit
c_func
(paren
id|hvBus
comma
id|hvSubBus
comma
id|hvAgentId
comma
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hvRc
op_eq
l_int|0
)paren
(brace
id|noConnectRc
op_assign
l_int|0
suffix:semicolon
id|HvCallPci_configStore8
c_func
(paren
id|hvBus
comma
id|hvSubBus
comma
id|hvAgentId
comma
id|PCI_INTERRUPT_LINE
comma
id|irq
)paren
suffix:semicolon
singleline_comment|// Store the irq in the interrupt line register of the function config space
)brace
)brace
r_if
c_cond
(paren
id|noConnectRc
op_eq
l_int|0
)paren
(brace
id|noConnectRc
op_assign
l_int|0xFFFF
suffix:semicolon
singleline_comment|// Reset to error value in case other multi-function devices are attached to this bus
singleline_comment|// Note: using hvIdSel assumes this device is on a secondary bus!
id|temp_dev.devfn
op_assign
id|PCI_DEVFN
c_func
(paren
id|hvIdSel
comma
l_int|0
)paren
suffix:semicolon
id|pci_scan_slot
c_func
(paren
op_amp
id|temp_dev
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|HvCallPci_BridgeDevice
suffix:colon
r_case
id|HvCallPci_IoaDevice
suffix:colon
multiline_comment|/* Single function devices, just try to connect and use pci_scan_slot to&n;&t;&t;       build the device */
id|irq
op_assign
id|bus-&gt;self-&gt;irq
suffix:semicolon
id|hvAgentId
op_assign
id|ISERIES_PCI_AGENTID
c_func
(paren
id|hvIdSel
comma
l_int|0
)paren
suffix:semicolon
id|hvRc
op_assign
id|HvCallXm_connectBusUnit
c_func
(paren
id|hvBus
comma
id|hvSubBus
comma
id|hvAgentId
comma
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hvRc
op_eq
l_int|0
)paren
(brace
id|HvCallPci_configStore8
c_func
(paren
id|hvBus
comma
id|hvSubBus
comma
id|hvAgentId
comma
id|PCI_INTERRUPT_LINE
comma
id|irq
)paren
suffix:semicolon
singleline_comment|// Store the irq in the interrupt line register of the device config space
singleline_comment|// Note: using hvIdSel assumes this device is on a secondary bus!
id|temp_dev.devfn
op_assign
id|PCI_DEVFN
c_func
(paren
id|hvIdSel
comma
l_int|0
)paren
suffix:semicolon
id|pci_scan_slot
c_func
(paren
op_amp
id|temp_dev
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Unrecognized device */
r_break
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* end of switch */
)brace
)brace
id|kfree
c_func
(paren
id|devInfo
)paren
suffix:semicolon
singleline_comment|// return 0;
)brace
multiline_comment|/*  Initialize bar space base and limit addresses for each device in the tree   */
DECL|function|iSeries_fixup
r_void
id|__init
id|iSeries_fixup
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
suffix:semicolon
id|u8
id|LinuxBus
comma
id|iSeriesBus
comma
id|LastBusNumber
suffix:semicolon
r_char
id|DeviceInfoBuffer
(braket
l_int|256
)braket
suffix:semicolon
multiline_comment|/*********************************************************/
multiline_comment|/* PCI: Allocate Bars space for each device              */
multiline_comment|/*********************************************************/
id|pci_for_each_dev
c_func
(paren
id|dev
)paren
(brace
id|iSeries_allocateDeviceBars
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*********************************************************/
multiline_comment|/* Create the TCEs for each iSeries bus now that we know */
multiline_comment|/* how many buses there are.  Need only create TCE for   */
multiline_comment|/* for each iSeries bus.  Multiple linux buses could     */
multiline_comment|/* be on the same iSeries bus.                       AHT */
multiline_comment|/*********************************************************/
id|LastBusNumber
op_assign
l_int|0xFF
suffix:semicolon
multiline_comment|/* Invalid   */
r_for
c_loop
(paren
id|LinuxBus
op_assign
l_int|0
suffix:semicolon
id|LinuxBus
OL
l_int|255
suffix:semicolon
op_increment
id|LinuxBus
)paren
(brace
id|iSeriesBus
op_assign
id|ISERIES_GET_LPAR_BUS
c_func
(paren
id|LinuxBus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iSeriesBus
op_eq
l_int|0xFF
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* Done      */
r_else
r_if
c_cond
(paren
id|LastBusNumber
op_ne
id|iSeriesBus
)paren
(brace
multiline_comment|/* New Bus   */
id|create_pci_bus_tce_table
c_func
(paren
id|iSeriesBus
)paren
suffix:semicolon
id|LastBusNumber
op_assign
id|iSeriesBus
suffix:semicolon
multiline_comment|/* Remember  */
)brace
)brace
multiline_comment|/*********************************************************/
multiline_comment|/* List out all the PCI devices found... This will go    */
multiline_comment|/* into the etc/proc/iSeries/pci info as well....        */
multiline_comment|/* This is to help service figure out who is who......   */
multiline_comment|/*********************************************************/
id|pci_for_each_dev
c_func
(paren
id|dev
)paren
(brace
r_struct
id|resource
op_star
id|BarResource
op_assign
op_amp
id|dev-&gt;resource
(braket
l_int|0
)braket
suffix:semicolon
id|iSeries_Device_Information
c_func
(paren
id|dev
comma
id|DeviceInfoBuffer
comma
l_int|256
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|DeviceInfoBuffer
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PCI: Bus%3d, Device%3d, %s at 0x%08x, irq %3d&bslash;n&quot;
comma
id|dev-&gt;bus-&gt;number
comma
id|PCI_SLOT
c_func
(paren
id|dev-&gt;devfn
)paren
comma
id|dev-&gt;name
comma
(paren
r_int
)paren
id|BarResource-&gt;start
comma
id|dev-&gt;irq
)paren
suffix:semicolon
)brace
multiline_comment|/* */
id|iSeries_activate_IRQs
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// Unmask all device interrupts for assigned IRQs
)brace
eof
