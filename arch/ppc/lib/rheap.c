multiline_comment|/*&n; * arch/ppc/syslib/rheap.c&n; *&n; * A Remote Heap.  Remote means that we don&squot;t touch the memory that the&n; * heap points to. Normal heap implementations use the memory they manage&n; * to place their list. We cannot do that because the memory we manage may&n; * have special properties, for example it is uncachable or of different&n; * endianess.&n; *&n; * Author: Pantelis Antoniou &lt;panto@intracom.gr&gt;&n; *&n; * 2004 (c) INTRACOM S.A. Greece. This file is licensed under&n; * the terms of the GNU General Public License version 2. This program&n; * is licensed &quot;as is&quot; without any warranty of any kind, whether express&n; * or implied.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/rheap.h&gt;
multiline_comment|/*&n; * Fixup a list_head, needed when copying lists.  If the pointers fall&n; * between s and e, apply the delta.  This assumes that&n; * sizeof(struct list_head *) == sizeof(unsigned long *).&n; */
DECL|function|fixup
r_static
r_inline
r_void
id|fixup
c_func
(paren
r_int
r_int
id|s
comma
r_int
r_int
id|e
comma
r_int
id|d
comma
r_struct
id|list_head
op_star
id|l
)paren
(brace
r_int
r_int
op_star
id|pp
suffix:semicolon
id|pp
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
id|l-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pp
op_ge
id|s
op_logical_and
op_star
id|pp
OL
id|e
)paren
op_star
id|pp
op_add_assign
id|d
suffix:semicolon
id|pp
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
id|l-&gt;prev
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pp
op_ge
id|s
op_logical_and
op_star
id|pp
OL
id|e
)paren
op_star
id|pp
op_add_assign
id|d
suffix:semicolon
)brace
multiline_comment|/* Grow the allocated blocks */
DECL|function|grow
r_static
r_int
id|grow
c_func
(paren
id|rh_info_t
op_star
id|info
comma
r_int
id|max_blocks
)paren
(brace
id|rh_block_t
op_star
id|block
comma
op_star
id|blk
suffix:semicolon
r_int
id|i
comma
id|new_blocks
suffix:semicolon
r_int
id|delta
suffix:semicolon
r_int
r_int
id|blks
comma
id|blke
suffix:semicolon
r_if
c_cond
(paren
id|max_blocks
op_le
id|info-&gt;max_blocks
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|new_blocks
op_assign
id|max_blocks
op_minus
id|info-&gt;max_blocks
suffix:semicolon
id|block
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|rh_block_t
)paren
op_star
id|max_blocks
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;max_blocks
OG
l_int|0
)paren
(brace
multiline_comment|/* copy old block area */
id|memcpy
c_func
(paren
id|block
comma
id|info-&gt;block
comma
r_sizeof
(paren
id|rh_block_t
)paren
op_star
id|info-&gt;max_blocks
)paren
suffix:semicolon
id|delta
op_assign
(paren
r_char
op_star
)paren
id|block
op_minus
(paren
r_char
op_star
)paren
id|info-&gt;block
suffix:semicolon
multiline_comment|/* and fixup list pointers */
id|blks
op_assign
(paren
r_int
r_int
)paren
id|info-&gt;block
suffix:semicolon
id|blke
op_assign
(paren
r_int
r_int
)paren
(paren
id|info-&gt;block
op_plus
id|info-&gt;max_blocks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|blk
op_assign
id|block
suffix:semicolon
id|i
OL
id|info-&gt;max_blocks
suffix:semicolon
id|i
op_increment
comma
id|blk
op_increment
)paren
id|fixup
c_func
(paren
id|blks
comma
id|blke
comma
id|delta
comma
op_amp
id|blk-&gt;list
)paren
suffix:semicolon
id|fixup
c_func
(paren
id|blks
comma
id|blke
comma
id|delta
comma
op_amp
id|info-&gt;empty_list
)paren
suffix:semicolon
id|fixup
c_func
(paren
id|blks
comma
id|blke
comma
id|delta
comma
op_amp
id|info-&gt;free_list
)paren
suffix:semicolon
id|fixup
c_func
(paren
id|blks
comma
id|blke
comma
id|delta
comma
op_amp
id|info-&gt;taken_list
)paren
suffix:semicolon
multiline_comment|/* free the old allocated memory */
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|RHIF_STATIC_BLOCK
)paren
op_eq
l_int|0
)paren
id|kfree
c_func
(paren
id|info-&gt;block
)paren
suffix:semicolon
)brace
id|info-&gt;block
op_assign
id|block
suffix:semicolon
id|info-&gt;empty_slots
op_add_assign
id|new_blocks
suffix:semicolon
id|info-&gt;max_blocks
op_assign
id|max_blocks
suffix:semicolon
id|info-&gt;flags
op_and_assign
op_complement
id|RHIF_STATIC_BLOCK
suffix:semicolon
multiline_comment|/* add all new blocks to the free list */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|blk
op_assign
id|block
op_plus
id|info-&gt;max_blocks
suffix:semicolon
id|i
OL
id|new_blocks
suffix:semicolon
id|i
op_increment
comma
id|blk
op_increment
)paren
id|list_add
c_func
(paren
op_amp
id|blk-&gt;list
comma
op_amp
id|info-&gt;empty_list
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Assure at least the required amount of empty slots.  If this function&n; * causes a grow in the block area then all pointers kept to the block&n; * area are invalid!&n; */
DECL|function|assure_empty
r_static
r_int
id|assure_empty
c_func
(paren
id|rh_info_t
op_star
id|info
comma
r_int
id|slots
)paren
(brace
r_int
id|max_blocks
suffix:semicolon
multiline_comment|/* This function is not meant to be used to grow uncontrollably */
r_if
c_cond
(paren
id|slots
op_ge
l_int|4
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Enough space */
r_if
c_cond
(paren
id|info-&gt;empty_slots
op_ge
id|slots
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Next 16 sized block */
id|max_blocks
op_assign
(paren
(paren
id|info-&gt;max_blocks
op_plus
id|slots
)paren
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
suffix:semicolon
r_return
id|grow
c_func
(paren
id|info
comma
id|max_blocks
)paren
suffix:semicolon
)brace
DECL|function|get_slot
r_static
id|rh_block_t
op_star
id|get_slot
c_func
(paren
id|rh_info_t
op_star
id|info
)paren
(brace
id|rh_block_t
op_star
id|blk
suffix:semicolon
multiline_comment|/* If no more free slots, and failure to extend. */
multiline_comment|/* XXX: You should have called assure_empty before */
r_if
c_cond
(paren
id|info-&gt;empty_slots
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;rh: out of slots; crash is imminent.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Get empty slot to use */
id|blk
op_assign
id|list_entry
c_func
(paren
id|info-&gt;empty_list.next
comma
id|rh_block_t
comma
id|list
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|blk-&gt;list
)paren
suffix:semicolon
id|info-&gt;empty_slots
op_decrement
suffix:semicolon
multiline_comment|/* Initialize */
id|blk-&gt;start
op_assign
l_int|NULL
suffix:semicolon
id|blk-&gt;size
op_assign
l_int|0
suffix:semicolon
id|blk-&gt;owner
op_assign
l_int|NULL
suffix:semicolon
r_return
id|blk
suffix:semicolon
)brace
DECL|function|release_slot
r_static
r_inline
r_void
id|release_slot
c_func
(paren
id|rh_info_t
op_star
id|info
comma
id|rh_block_t
op_star
id|blk
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|blk-&gt;list
comma
op_amp
id|info-&gt;empty_list
)paren
suffix:semicolon
id|info-&gt;empty_slots
op_increment
suffix:semicolon
)brace
DECL|function|attach_free_block
r_static
r_void
id|attach_free_block
c_func
(paren
id|rh_info_t
op_star
id|info
comma
id|rh_block_t
op_star
id|blkn
)paren
(brace
id|rh_block_t
op_star
id|blk
suffix:semicolon
id|rh_block_t
op_star
id|before
suffix:semicolon
id|rh_block_t
op_star
id|after
suffix:semicolon
id|rh_block_t
op_star
id|next
suffix:semicolon
r_int
id|size
suffix:semicolon
r_int
r_int
id|s
comma
id|e
comma
id|bs
comma
id|be
suffix:semicolon
r_struct
id|list_head
op_star
id|l
suffix:semicolon
multiline_comment|/* We assume that they are aligned properly */
id|size
op_assign
id|blkn-&gt;size
suffix:semicolon
id|s
op_assign
(paren
r_int
r_int
)paren
id|blkn-&gt;start
suffix:semicolon
id|e
op_assign
id|s
op_plus
id|size
suffix:semicolon
multiline_comment|/* Find the blocks immediately before and after the given one&n;&t; * (if any) */
id|before
op_assign
l_int|NULL
suffix:semicolon
id|after
op_assign
l_int|NULL
suffix:semicolon
id|next
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|info-&gt;free_list
)paren
(brace
id|blk
op_assign
id|list_entry
c_func
(paren
id|l
comma
id|rh_block_t
comma
id|list
)paren
suffix:semicolon
id|bs
op_assign
(paren
r_int
r_int
)paren
id|blk-&gt;start
suffix:semicolon
id|be
op_assign
id|bs
op_plus
id|blk-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|next
op_eq
l_int|NULL
op_logical_and
id|s
op_ge
id|bs
)paren
id|next
op_assign
id|blk
suffix:semicolon
r_if
c_cond
(paren
id|be
op_eq
id|s
)paren
id|before
op_assign
id|blk
suffix:semicolon
r_if
c_cond
(paren
id|e
op_eq
id|bs
)paren
id|after
op_assign
id|blk
suffix:semicolon
multiline_comment|/* If both are not null, break now */
r_if
c_cond
(paren
id|before
op_ne
l_int|NULL
op_logical_and
id|after
op_ne
l_int|NULL
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Now check if they are really adjacent */
r_if
c_cond
(paren
id|before
op_ne
l_int|NULL
op_logical_and
id|s
op_ne
(paren
r_int
r_int
)paren
id|before-&gt;start
op_plus
id|before-&gt;size
)paren
id|before
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|after
op_ne
l_int|NULL
op_logical_and
id|e
op_ne
(paren
r_int
r_int
)paren
id|after-&gt;start
)paren
id|after
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* No coalescing; list insert and return */
r_if
c_cond
(paren
id|before
op_eq
l_int|NULL
op_logical_and
id|after
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|next
op_ne
l_int|NULL
)paren
id|list_add
c_func
(paren
op_amp
id|blkn-&gt;list
comma
op_amp
id|next-&gt;list
)paren
suffix:semicolon
r_else
id|list_add
c_func
(paren
op_amp
id|blkn-&gt;list
comma
op_amp
id|info-&gt;free_list
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* We don&squot;t need it anymore */
id|release_slot
c_func
(paren
id|info
comma
id|blkn
)paren
suffix:semicolon
multiline_comment|/* Grow the before block */
r_if
c_cond
(paren
id|before
op_ne
l_int|NULL
op_logical_and
id|after
op_eq
l_int|NULL
)paren
(brace
id|before-&gt;size
op_add_assign
id|size
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Grow the after block backwards */
r_if
c_cond
(paren
id|before
op_eq
l_int|NULL
op_logical_and
id|after
op_ne
l_int|NULL
)paren
(brace
id|after-&gt;start
op_assign
(paren
r_int8
op_star
)paren
id|after-&gt;start
op_minus
id|size
suffix:semicolon
id|after-&gt;size
op_add_assign
id|size
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Grow the before block, and release the after block */
id|before-&gt;size
op_add_assign
id|size
op_plus
id|after-&gt;size
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|after-&gt;list
)paren
suffix:semicolon
id|release_slot
c_func
(paren
id|info
comma
id|after
)paren
suffix:semicolon
)brace
DECL|function|attach_taken_block
r_static
r_void
id|attach_taken_block
c_func
(paren
id|rh_info_t
op_star
id|info
comma
id|rh_block_t
op_star
id|blkn
)paren
(brace
id|rh_block_t
op_star
id|blk
suffix:semicolon
r_struct
id|list_head
op_star
id|l
suffix:semicolon
multiline_comment|/* Find the block immediately before the given one (if any) */
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|info-&gt;taken_list
)paren
(brace
id|blk
op_assign
id|list_entry
c_func
(paren
id|l
comma
id|rh_block_t
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blk-&gt;start
OG
id|blkn-&gt;start
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|blkn-&gt;list
comma
op_amp
id|blk-&gt;list
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|list_add_tail
c_func
(paren
op_amp
id|blkn-&gt;list
comma
op_amp
id|info-&gt;taken_list
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a remote heap dynamically.  Note that no memory for the blocks&n; * are allocated.  It will upon the first allocation&n; */
DECL|function|rh_create
id|rh_info_t
op_star
id|rh_create
c_func
(paren
r_int
r_int
id|alignment
)paren
(brace
id|rh_info_t
op_star
id|info
suffix:semicolon
multiline_comment|/* Alignment must be a power of two */
r_if
c_cond
(paren
(paren
id|alignment
op_amp
(paren
id|alignment
op_minus
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
id|info
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info
op_eq
l_int|NULL
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|info-&gt;alignment
op_assign
id|alignment
suffix:semicolon
multiline_comment|/* Initially everything as empty */
id|info-&gt;block
op_assign
l_int|NULL
suffix:semicolon
id|info-&gt;max_blocks
op_assign
l_int|0
suffix:semicolon
id|info-&gt;empty_slots
op_assign
l_int|0
suffix:semicolon
id|info-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|info-&gt;empty_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|info-&gt;free_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|info-&gt;taken_list
)paren
suffix:semicolon
r_return
id|info
suffix:semicolon
)brace
multiline_comment|/*&n; * Destroy a dynamically created remote heap.  Deallocate only if the areas&n; * are not static&n; */
DECL|function|rh_destroy
r_void
id|rh_destroy
c_func
(paren
id|rh_info_t
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|RHIF_STATIC_BLOCK
)paren
op_eq
l_int|0
op_logical_and
id|info-&gt;block
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|info-&gt;block
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|RHIF_STATIC_INFO
)paren
op_eq
l_int|0
)paren
id|kfree
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize in place a remote heap info block.  This is needed to support&n; * operation very early in the startup of the kernel, when it is not yet safe&n; * to call kmalloc.&n; */
DECL|function|rh_init
r_void
id|rh_init
c_func
(paren
id|rh_info_t
op_star
id|info
comma
r_int
r_int
id|alignment
comma
r_int
id|max_blocks
comma
id|rh_block_t
op_star
id|block
)paren
(brace
r_int
id|i
suffix:semicolon
id|rh_block_t
op_star
id|blk
suffix:semicolon
multiline_comment|/* Alignment must be a power of two */
r_if
c_cond
(paren
(paren
id|alignment
op_amp
(paren
id|alignment
op_minus
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
r_return
suffix:semicolon
id|info-&gt;alignment
op_assign
id|alignment
suffix:semicolon
multiline_comment|/* Initially everything as empty */
id|info-&gt;block
op_assign
id|block
suffix:semicolon
id|info-&gt;max_blocks
op_assign
id|max_blocks
suffix:semicolon
id|info-&gt;empty_slots
op_assign
id|max_blocks
suffix:semicolon
id|info-&gt;flags
op_assign
id|RHIF_STATIC_INFO
op_or
id|RHIF_STATIC_BLOCK
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|info-&gt;empty_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|info-&gt;free_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|info-&gt;taken_list
)paren
suffix:semicolon
multiline_comment|/* Add all new blocks to the free list */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|blk
op_assign
id|block
suffix:semicolon
id|i
OL
id|max_blocks
suffix:semicolon
id|i
op_increment
comma
id|blk
op_increment
)paren
id|list_add
c_func
(paren
op_amp
id|blk-&gt;list
comma
op_amp
id|info-&gt;empty_list
)paren
suffix:semicolon
)brace
multiline_comment|/* Attach a free memory region, coalesces regions if adjuscent */
DECL|function|rh_attach_region
r_int
id|rh_attach_region
c_func
(paren
id|rh_info_t
op_star
id|info
comma
r_void
op_star
id|start
comma
r_int
id|size
)paren
(brace
id|rh_block_t
op_star
id|blk
suffix:semicolon
r_int
r_int
id|s
comma
id|e
comma
id|m
suffix:semicolon
r_int
id|r
suffix:semicolon
multiline_comment|/* The region must be aligned */
id|s
op_assign
(paren
r_int
r_int
)paren
id|start
suffix:semicolon
id|e
op_assign
id|s
op_plus
id|size
suffix:semicolon
id|m
op_assign
id|info-&gt;alignment
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Round start up */
id|s
op_assign
(paren
id|s
op_plus
id|m
)paren
op_amp
op_complement
id|m
suffix:semicolon
multiline_comment|/* Round end down */
id|e
op_assign
id|e
op_amp
op_complement
id|m
suffix:semicolon
multiline_comment|/* Take final values */
id|start
op_assign
(paren
r_void
op_star
)paren
id|s
suffix:semicolon
id|size
op_assign
(paren
r_int
)paren
(paren
id|e
op_minus
id|s
)paren
suffix:semicolon
multiline_comment|/* Grow the blocks, if needed */
id|r
op_assign
id|assure_empty
c_func
(paren
id|info
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
r_return
id|r
suffix:semicolon
id|blk
op_assign
id|get_slot
c_func
(paren
id|info
)paren
suffix:semicolon
id|blk-&gt;start
op_assign
id|start
suffix:semicolon
id|blk-&gt;size
op_assign
id|size
suffix:semicolon
id|blk-&gt;owner
op_assign
l_int|NULL
suffix:semicolon
id|attach_free_block
c_func
(paren
id|info
comma
id|blk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Detatch given address range, splits free block if needed. */
DECL|function|rh_detach_region
r_void
op_star
id|rh_detach_region
c_func
(paren
id|rh_info_t
op_star
id|info
comma
r_void
op_star
id|start
comma
r_int
id|size
)paren
(brace
r_struct
id|list_head
op_star
id|l
suffix:semicolon
id|rh_block_t
op_star
id|blk
comma
op_star
id|newblk
suffix:semicolon
r_int
r_int
id|s
comma
id|e
comma
id|m
comma
id|bs
comma
id|be
suffix:semicolon
multiline_comment|/* Validate size */
r_if
c_cond
(paren
id|size
op_le
l_int|0
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/* The region must be aligned */
id|s
op_assign
(paren
r_int
r_int
)paren
id|start
suffix:semicolon
id|e
op_assign
id|s
op_plus
id|size
suffix:semicolon
id|m
op_assign
id|info-&gt;alignment
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Round start up */
id|s
op_assign
(paren
id|s
op_plus
id|m
)paren
op_amp
op_complement
id|m
suffix:semicolon
multiline_comment|/* Round end down */
id|e
op_assign
id|e
op_amp
op_complement
id|m
suffix:semicolon
r_if
c_cond
(paren
id|assure_empty
c_func
(paren
id|info
comma
l_int|1
)paren
OL
l_int|0
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|blk
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|info-&gt;free_list
)paren
(brace
id|blk
op_assign
id|list_entry
c_func
(paren
id|l
comma
id|rh_block_t
comma
id|list
)paren
suffix:semicolon
multiline_comment|/* The range must lie entirely inside one free block */
id|bs
op_assign
(paren
r_int
r_int
)paren
id|blk-&gt;start
suffix:semicolon
id|be
op_assign
(paren
r_int
r_int
)paren
id|blk-&gt;start
op_plus
id|blk-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|s
op_ge
id|bs
op_logical_and
id|e
op_le
id|be
)paren
r_break
suffix:semicolon
id|blk
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|blk
op_eq
l_int|NULL
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
multiline_comment|/* Perfect fit */
r_if
c_cond
(paren
id|bs
op_eq
id|s
op_logical_and
id|be
op_eq
id|e
)paren
(brace
multiline_comment|/* Delete from free list, release slot */
id|list_del
c_func
(paren
op_amp
id|blk-&gt;list
)paren
suffix:semicolon
id|release_slot
c_func
(paren
id|info
comma
id|blk
)paren
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
id|s
suffix:semicolon
)brace
multiline_comment|/* blk still in free list, with updated start and/or size */
r_if
c_cond
(paren
id|bs
op_eq
id|s
op_logical_or
id|be
op_eq
id|e
)paren
(brace
r_if
c_cond
(paren
id|bs
op_eq
id|s
)paren
id|blk-&gt;start
op_assign
(paren
r_int8
op_star
)paren
id|blk-&gt;start
op_plus
id|size
suffix:semicolon
id|blk-&gt;size
op_sub_assign
id|size
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The front free fragment */
id|blk-&gt;size
op_assign
id|s
op_minus
id|bs
suffix:semicolon
multiline_comment|/* the back free fragment */
id|newblk
op_assign
id|get_slot
c_func
(paren
id|info
)paren
suffix:semicolon
id|newblk-&gt;start
op_assign
(paren
r_void
op_star
)paren
id|e
suffix:semicolon
id|newblk-&gt;size
op_assign
id|be
op_minus
id|e
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|newblk-&gt;list
comma
op_amp
id|blk-&gt;list
)paren
suffix:semicolon
)brace
r_return
(paren
r_void
op_star
)paren
id|s
suffix:semicolon
)brace
DECL|function|rh_alloc
r_void
op_star
id|rh_alloc
c_func
(paren
id|rh_info_t
op_star
id|info
comma
r_int
id|size
comma
r_const
r_char
op_star
id|owner
)paren
(brace
r_struct
id|list_head
op_star
id|l
suffix:semicolon
id|rh_block_t
op_star
id|blk
suffix:semicolon
id|rh_block_t
op_star
id|newblk
suffix:semicolon
r_void
op_star
id|start
suffix:semicolon
multiline_comment|/* Validate size */
r_if
c_cond
(paren
id|size
op_le
l_int|0
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/* Align to configured alignment */
id|size
op_assign
(paren
id|size
op_plus
(paren
id|info-&gt;alignment
op_minus
l_int|1
)paren
)paren
op_amp
op_complement
(paren
id|info-&gt;alignment
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|assure_empty
c_func
(paren
id|info
comma
l_int|1
)paren
OL
l_int|0
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|blk
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|info-&gt;free_list
)paren
(brace
id|blk
op_assign
id|list_entry
c_func
(paren
id|l
comma
id|rh_block_t
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_le
id|blk-&gt;size
)paren
r_break
suffix:semicolon
id|blk
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|blk
op_eq
l_int|NULL
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
multiline_comment|/* Just fits */
r_if
c_cond
(paren
id|blk-&gt;size
op_eq
id|size
)paren
(brace
multiline_comment|/* Move from free list to taken list */
id|list_del
c_func
(paren
op_amp
id|blk-&gt;list
)paren
suffix:semicolon
id|blk-&gt;owner
op_assign
id|owner
suffix:semicolon
id|start
op_assign
id|blk-&gt;start
suffix:semicolon
id|attach_taken_block
c_func
(paren
id|info
comma
id|blk
)paren
suffix:semicolon
r_return
id|start
suffix:semicolon
)brace
id|newblk
op_assign
id|get_slot
c_func
(paren
id|info
)paren
suffix:semicolon
id|newblk-&gt;start
op_assign
id|blk-&gt;start
suffix:semicolon
id|newblk-&gt;size
op_assign
id|size
suffix:semicolon
id|newblk-&gt;owner
op_assign
id|owner
suffix:semicolon
multiline_comment|/* blk still in free list, with updated start, size */
id|blk-&gt;start
op_assign
(paren
r_int8
op_star
)paren
id|blk-&gt;start
op_plus
id|size
suffix:semicolon
id|blk-&gt;size
op_sub_assign
id|size
suffix:semicolon
id|start
op_assign
id|newblk-&gt;start
suffix:semicolon
id|attach_taken_block
c_func
(paren
id|info
comma
id|newblk
)paren
suffix:semicolon
r_return
id|start
suffix:semicolon
)brace
multiline_comment|/* allocate at precisely the given address */
DECL|function|rh_alloc_fixed
r_void
op_star
id|rh_alloc_fixed
c_func
(paren
id|rh_info_t
op_star
id|info
comma
r_void
op_star
id|start
comma
r_int
id|size
comma
r_const
r_char
op_star
id|owner
)paren
(brace
r_struct
id|list_head
op_star
id|l
suffix:semicolon
id|rh_block_t
op_star
id|blk
comma
op_star
id|newblk1
comma
op_star
id|newblk2
suffix:semicolon
r_int
r_int
id|s
comma
id|e
comma
id|m
comma
id|bs
comma
id|be
suffix:semicolon
multiline_comment|/* Validate size */
r_if
c_cond
(paren
id|size
op_le
l_int|0
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/* The region must be aligned */
id|s
op_assign
(paren
r_int
r_int
)paren
id|start
suffix:semicolon
id|e
op_assign
id|s
op_plus
id|size
suffix:semicolon
id|m
op_assign
id|info-&gt;alignment
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Round start up */
id|s
op_assign
(paren
id|s
op_plus
id|m
)paren
op_amp
op_complement
id|m
suffix:semicolon
multiline_comment|/* Round end down */
id|e
op_assign
id|e
op_amp
op_complement
id|m
suffix:semicolon
r_if
c_cond
(paren
id|assure_empty
c_func
(paren
id|info
comma
l_int|2
)paren
OL
l_int|0
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|blk
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|info-&gt;free_list
)paren
(brace
id|blk
op_assign
id|list_entry
c_func
(paren
id|l
comma
id|rh_block_t
comma
id|list
)paren
suffix:semicolon
multiline_comment|/* The range must lie entirely inside one free block */
id|bs
op_assign
(paren
r_int
r_int
)paren
id|blk-&gt;start
suffix:semicolon
id|be
op_assign
(paren
r_int
r_int
)paren
id|blk-&gt;start
op_plus
id|blk-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|s
op_ge
id|bs
op_logical_and
id|e
op_le
id|be
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|blk
op_eq
l_int|NULL
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
multiline_comment|/* Perfect fit */
r_if
c_cond
(paren
id|bs
op_eq
id|s
op_logical_and
id|be
op_eq
id|e
)paren
(brace
multiline_comment|/* Move from free list to taken list */
id|list_del
c_func
(paren
op_amp
id|blk-&gt;list
)paren
suffix:semicolon
id|blk-&gt;owner
op_assign
id|owner
suffix:semicolon
id|start
op_assign
id|blk-&gt;start
suffix:semicolon
id|attach_taken_block
c_func
(paren
id|info
comma
id|blk
)paren
suffix:semicolon
r_return
id|start
suffix:semicolon
)brace
multiline_comment|/* blk still in free list, with updated start and/or size */
r_if
c_cond
(paren
id|bs
op_eq
id|s
op_logical_or
id|be
op_eq
id|e
)paren
(brace
r_if
c_cond
(paren
id|bs
op_eq
id|s
)paren
id|blk-&gt;start
op_assign
(paren
r_int8
op_star
)paren
id|blk-&gt;start
op_plus
id|size
suffix:semicolon
id|blk-&gt;size
op_sub_assign
id|size
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The front free fragment */
id|blk-&gt;size
op_assign
id|s
op_minus
id|bs
suffix:semicolon
multiline_comment|/* The back free fragment */
id|newblk2
op_assign
id|get_slot
c_func
(paren
id|info
)paren
suffix:semicolon
id|newblk2-&gt;start
op_assign
(paren
r_void
op_star
)paren
id|e
suffix:semicolon
id|newblk2-&gt;size
op_assign
id|be
op_minus
id|e
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|newblk2-&gt;list
comma
op_amp
id|blk-&gt;list
)paren
suffix:semicolon
)brace
id|newblk1
op_assign
id|get_slot
c_func
(paren
id|info
)paren
suffix:semicolon
id|newblk1-&gt;start
op_assign
(paren
r_void
op_star
)paren
id|s
suffix:semicolon
id|newblk1-&gt;size
op_assign
id|e
op_minus
id|s
suffix:semicolon
id|newblk1-&gt;owner
op_assign
id|owner
suffix:semicolon
id|start
op_assign
id|newblk1-&gt;start
suffix:semicolon
id|attach_taken_block
c_func
(paren
id|info
comma
id|newblk1
)paren
suffix:semicolon
r_return
id|start
suffix:semicolon
)brace
DECL|function|rh_free
r_int
id|rh_free
c_func
(paren
id|rh_info_t
op_star
id|info
comma
r_void
op_star
id|start
)paren
(brace
id|rh_block_t
op_star
id|blk
comma
op_star
id|blk2
suffix:semicolon
r_struct
id|list_head
op_star
id|l
suffix:semicolon
r_int
id|size
suffix:semicolon
multiline_comment|/* Linear search for block */
id|blk
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|info-&gt;taken_list
)paren
(brace
id|blk2
op_assign
id|list_entry
c_func
(paren
id|l
comma
id|rh_block_t
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start
OL
id|blk2-&gt;start
)paren
r_break
suffix:semicolon
id|blk
op_assign
id|blk2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|blk
op_eq
l_int|NULL
op_logical_or
id|start
OG
(paren
id|blk-&gt;start
op_plus
id|blk-&gt;size
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Remove from taken list */
id|list_del
c_func
(paren
op_amp
id|blk-&gt;list
)paren
suffix:semicolon
multiline_comment|/* Get size of freed block */
id|size
op_assign
id|blk-&gt;size
suffix:semicolon
id|attach_free_block
c_func
(paren
id|info
comma
id|blk
)paren
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
DECL|function|rh_get_stats
r_int
id|rh_get_stats
c_func
(paren
id|rh_info_t
op_star
id|info
comma
r_int
id|what
comma
r_int
id|max_stats
comma
id|rh_stats_t
op_star
id|stats
)paren
(brace
id|rh_block_t
op_star
id|blk
suffix:semicolon
r_struct
id|list_head
op_star
id|l
suffix:semicolon
r_struct
id|list_head
op_star
id|h
suffix:semicolon
r_int
id|nr
suffix:semicolon
r_switch
c_cond
(paren
id|what
)paren
(brace
r_case
id|RHGS_FREE
suffix:colon
id|h
op_assign
op_amp
id|info-&gt;free_list
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RHGS_TAKEN
suffix:colon
id|h
op_assign
op_amp
id|info-&gt;taken_list
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Linear search for block */
id|nr
op_assign
l_int|0
suffix:semicolon
id|list_for_each
c_func
(paren
id|l
comma
id|h
)paren
(brace
id|blk
op_assign
id|list_entry
c_func
(paren
id|l
comma
id|rh_block_t
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stats
op_ne
l_int|NULL
op_logical_and
id|nr
OL
id|max_stats
)paren
(brace
id|stats-&gt;start
op_assign
id|blk-&gt;start
suffix:semicolon
id|stats-&gt;size
op_assign
id|blk-&gt;size
suffix:semicolon
id|stats-&gt;owner
op_assign
id|blk-&gt;owner
suffix:semicolon
id|stats
op_increment
suffix:semicolon
)brace
id|nr
op_increment
suffix:semicolon
)brace
r_return
id|nr
suffix:semicolon
)brace
DECL|function|rh_set_owner
r_int
id|rh_set_owner
c_func
(paren
id|rh_info_t
op_star
id|info
comma
r_void
op_star
id|start
comma
r_const
r_char
op_star
id|owner
)paren
(brace
id|rh_block_t
op_star
id|blk
comma
op_star
id|blk2
suffix:semicolon
r_struct
id|list_head
op_star
id|l
suffix:semicolon
r_int
id|size
suffix:semicolon
multiline_comment|/* Linear search for block */
id|blk
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|info-&gt;taken_list
)paren
(brace
id|blk2
op_assign
id|list_entry
c_func
(paren
id|l
comma
id|rh_block_t
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start
OL
id|blk2-&gt;start
)paren
r_break
suffix:semicolon
id|blk
op_assign
id|blk2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|blk
op_eq
l_int|NULL
op_logical_or
id|start
OG
(paren
id|blk-&gt;start
op_plus
id|blk-&gt;size
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|blk-&gt;owner
op_assign
id|owner
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
DECL|function|rh_dump
r_void
id|rh_dump
c_func
(paren
id|rh_info_t
op_star
id|info
)paren
(brace
r_static
id|rh_stats_t
id|st
(braket
l_int|32
)braket
suffix:semicolon
multiline_comment|/* XXX maximum 32 blocks */
r_int
id|maxnr
suffix:semicolon
r_int
id|i
comma
id|nr
suffix:semicolon
id|maxnr
op_assign
r_sizeof
(paren
id|st
)paren
op_div
r_sizeof
(paren
id|st
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;info @0x%p (%d slots empty / %d max)&bslash;n&quot;
comma
id|info
comma
id|info-&gt;empty_slots
comma
id|info-&gt;max_blocks
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  Free:&bslash;n&quot;
)paren
suffix:semicolon
id|nr
op_assign
id|rh_get_stats
c_func
(paren
id|info
comma
id|RHGS_FREE
comma
id|maxnr
comma
id|st
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
OG
id|maxnr
)paren
id|nr
op_assign
id|maxnr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    0x%p-0x%p (%u)&bslash;n&quot;
comma
id|st
(braket
id|i
)braket
dot
id|start
comma
(paren
r_int8
op_star
)paren
id|st
(braket
id|i
)braket
dot
id|start
op_plus
id|st
(braket
id|i
)braket
dot
id|size
comma
id|st
(braket
id|i
)braket
dot
id|size
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  Taken:&bslash;n&quot;
)paren
suffix:semicolon
id|nr
op_assign
id|rh_get_stats
c_func
(paren
id|info
comma
id|RHGS_TAKEN
comma
id|maxnr
comma
id|st
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
OG
id|maxnr
)paren
id|nr
op_assign
id|maxnr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;    0x%p-0x%p (%u) %s&bslash;n&quot;
comma
id|st
(braket
id|i
)braket
dot
id|start
comma
(paren
r_int8
op_star
)paren
id|st
(braket
id|i
)braket
dot
id|start
op_plus
id|st
(braket
id|i
)braket
dot
id|size
comma
id|st
(braket
id|i
)braket
dot
id|size
comma
id|st
(braket
id|i
)braket
dot
id|owner
op_ne
l_int|NULL
ques
c_cond
id|st
(braket
id|i
)braket
dot
id|owner
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|rh_dump_blk
r_void
id|rh_dump_blk
c_func
(paren
id|rh_info_t
op_star
id|info
comma
id|rh_block_t
op_star
id|blk
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;blk @0x%p: 0x%p-0x%p (%u)&bslash;n&quot;
comma
id|blk
comma
id|blk-&gt;start
comma
(paren
r_int8
op_star
)paren
id|blk-&gt;start
op_plus
id|blk-&gt;size
comma
id|blk-&gt;size
)paren
suffix:semicolon
)brace
eof
