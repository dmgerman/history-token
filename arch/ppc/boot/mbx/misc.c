multiline_comment|/*&n; * BK Id: SCCS/s.misc.c 1.11 07/18/01 15:46:50 trini&n; */
multiline_comment|/*&n; * Adapted for PowerPC by Gary Thomas&n; *&n; * Rewritten by Cort Dougan (cort@cs.nmt.edu)&n; * One day to be replaced by a single bootloader for chrp/prep/pmac. -- Cort&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &quot;zlib.h&quot;
macro_line|#include &lt;asm/residual.h&gt;
macro_line|#include &lt;linux/elf.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#ifdef CONFIG_8xx
macro_line|#include &lt;asm/mpc8xx.h&gt;
macro_line|#endif
macro_line|#ifdef CONFIG_8260
macro_line|#include &lt;asm/mpc8260.h&gt;
macro_line|#endif
multiline_comment|/*&n; * The following references are needed to cause the linker to pull in the&n; * gzimage.o and rdimage.o files.  These object files are special,&n; * since they get placed into the .gzimage and .rdimage ELF sections &n; * of the zvmlinux and zvmlinux.initrd files.&n; */
r_extern
r_char
id|dummy_for_gzimage
suffix:semicolon
r_extern
r_char
id|dummy_for_rdimage
suffix:semicolon
multiline_comment|/*&n; * Please send me load/board info and such data for hardware not&n; * listed here so I can keep track since things are getting tricky&n; * with the different load addrs with different firmware.  This will&n; * help to avoid breaking the load/boot process.&n; * -- Cort&n; */
DECL|variable|avail_ram
r_char
op_star
id|avail_ram
suffix:semicolon
DECL|variable|end_avail
r_char
op_star
id|end_avail
suffix:semicolon
multiline_comment|/* See comment below.....&n;*/
DECL|variable|initrd_offset
DECL|variable|initrd_size
r_int
r_int
id|initrd_offset
comma
id|initrd_size
suffix:semicolon
multiline_comment|/* Because of the limited amount of memory on embedded, it presents&n; * loading problems.  The biggest is that we load this boot program&n; * into a relatively low memory address, and the Linux kernel Bss often&n; * extends into this space when it get loaded.  When the kernel starts&n; * and zeros the BSS space, it also writes over the information we&n; * save here and pass to the kernel (command line and board info).&n; * On these boards, we grab some known memory holes to hold this information.&n; */
DECL|variable|cmd_buf
r_char
id|cmd_buf
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|cmd_line
r_char
op_star
id|cmd_line
op_assign
id|cmd_buf
suffix:semicolon
multiline_comment|/* We need to pass along a &squot;dummy&squot; com_port. */
DECL|variable|com_port
r_int
r_int
id|com_port
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This is the default cmdline that will be given to the user at boot time..&n; * If none was specified at compile time, we&squot;ll give it one that should work.&n; * -- Tom */
macro_line|#ifdef CONFIG_CMDLINE_BOOL
DECL|variable|compiled_string
r_char
id|compiled_string
(braket
)braket
op_assign
id|CONFIG_CMDLINE
suffix:semicolon
macro_line|#endif
DECL|variable|ramroot_string
r_char
id|ramroot_string
(braket
)braket
op_assign
l_string|&quot;root=/dev/ram&quot;
suffix:semicolon
DECL|variable|netroot_string
r_char
id|netroot_string
(braket
)braket
op_assign
l_string|&quot;root=/dev/nfs rw&quot;
suffix:semicolon
DECL|variable|hold_resid_buf
id|bd_t
id|hold_resid_buf
suffix:semicolon
DECL|variable|hold_residual
id|bd_t
op_star
id|hold_residual
op_assign
op_amp
id|hold_resid_buf
suffix:semicolon
DECL|variable|initrd_start
DECL|variable|initrd_end
r_int
r_int
id|initrd_start
op_assign
l_int|0
comma
id|initrd_end
op_assign
l_int|0
suffix:semicolon
DECL|variable|zimage_start
r_char
op_star
id|zimage_start
suffix:semicolon
DECL|variable|zimage_size
r_int
id|zimage_size
suffix:semicolon
r_extern
r_void
id|puts
c_func
(paren
r_const
r_char
op_star
)paren
suffix:semicolon
r_extern
r_void
id|putc
c_func
(paren
r_const
r_char
id|c
)paren
suffix:semicolon
r_extern
r_void
id|udelay
c_func
(paren
r_int
id|x
)paren
suffix:semicolon
r_extern
r_void
id|puthex
c_func
(paren
r_int
r_int
id|val
)paren
suffix:semicolon
r_extern
r_void
op_star
id|memcpy
c_func
(paren
r_void
op_star
id|__dest
comma
id|__const
r_void
op_star
id|__src
comma
id|__kernel_size_t
id|__n
)paren
suffix:semicolon
r_extern
r_void
id|gunzip
c_func
(paren
r_void
op_star
comma
r_int
comma
r_int
r_char
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_extern
r_int
id|tstc
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|getc
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
r_int
DECL|function|decompress_kernel
id|decompress_kernel
c_func
(paren
r_int
r_int
id|load_addr
comma
r_int
id|num_words
comma
r_int
r_int
id|cksum
comma
id|bd_t
op_star
id|bp
)paren
(brace
r_int
id|timer
suffix:semicolon
r_extern
r_int
r_int
id|start
suffix:semicolon
r_char
op_star
id|cp
comma
id|ch
suffix:semicolon
macro_line|#ifdef CONFIG_8260
multiline_comment|/* I don&squot;t know why I didn&squot;t do it this way on the 8xx.......&n;&t;*/
id|embed_config
c_func
(paren
op_amp
id|bp
)paren
suffix:semicolon
id|serial_init
c_func
(paren
id|bp
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* These values must be variables.  If not, the compiler optimizer&n;&t; * will remove some code, causing the size of the code to vary&n;&t; * when these values are zero.  This is bad because we first&n;&t; * compile with these zero to determine the size and offsets&n;&t; * in an image, than compile again with these set to the proper&n;&t; * discovered value.....Ya know, we used to read these from the&n;&t; * header a long time ago.....&n;&t; */
id|initrd_offset
op_assign
id|INITRD_OFFSET
suffix:semicolon
id|initrd_size
op_assign
id|INITRD_SIZE
suffix:semicolon
multiline_comment|/* Grab some space for the command line and board info.  Since&n;&t; * we no longer use the ELF header, but it was loaded, grab&n;&t; * that space.&n;&t; */
macro_line|#ifdef CONFIG_MBX
id|cmd_line
op_assign
(paren
r_char
op_star
)paren
(paren
id|load_addr
op_minus
l_int|0x10000
)paren
suffix:semicolon
multiline_comment|/* To be like everyone else, we need one too, although this&n;&t; * board information is passed from the boot rom.&n;&t; */
id|bp-&gt;bi_baudrate
op_assign
l_int|9600
suffix:semicolon
macro_line|#else
id|cmd_line
op_assign
(paren
r_char
op_star
)paren
(paren
l_int|0x200000
)paren
suffix:semicolon
macro_line|#endif
id|hold_residual
op_assign
(paren
id|bd_t
op_star
)paren
(paren
id|cmd_line
op_plus
r_sizeof
(paren
id|cmd_buf
)paren
)paren
suffix:semicolon
multiline_comment|/* copy board data */
r_if
c_cond
(paren
id|bp
)paren
id|memcpy
c_func
(paren
id|hold_residual
comma
id|bp
comma
r_sizeof
(paren
id|bd_t
)paren
)paren
suffix:semicolon
multiline_comment|/* Set end of memory available to us.  It is always the highest&n;&t; * memory address provided by the board information.&n;&t; */
id|end_avail
op_assign
(paren
r_char
op_star
)paren
(paren
id|bp-&gt;bi_memsize
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;loaded at:     &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
id|load_addr
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
(paren
id|load_addr
op_plus
(paren
l_int|4
op_star
id|num_words
)paren
)paren
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|load_addr
op_ne
(paren
r_int
r_int
)paren
op_amp
id|start
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;relocated to:  &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|start
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
(paren
(paren
r_int
r_int
)paren
op_amp
id|start
op_plus
(paren
l_int|4
op_star
id|num_words
)paren
)paren
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bp
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;board data at: &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
id|bp
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
(paren
(paren
r_int
r_int
)paren
id|bp
op_plus
r_sizeof
(paren
id|bd_t
)paren
)paren
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;relocated to:  &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
id|hold_residual
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
(paren
(paren
r_int
r_int
)paren
id|hold_residual
op_plus
r_sizeof
(paren
id|bd_t
)paren
)paren
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* we have to subtract 0x10000 here to correct for objdump including the&n;&t;   size of the elf header which we strip -- Cort */
id|zimage_start
op_assign
(paren
r_char
op_star
)paren
(paren
id|load_addr
op_minus
l_int|0x10000
op_plus
id|ZIMAGE_OFFSET
)paren
suffix:semicolon
id|zimage_size
op_assign
id|ZIMAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|initrd_offset
)paren
id|initrd_start
op_assign
id|load_addr
op_minus
l_int|0x10000
op_plus
id|initrd_offset
suffix:semicolon
r_else
id|initrd_start
op_assign
l_int|0
suffix:semicolon
id|initrd_end
op_assign
id|initrd_size
op_plus
id|initrd_start
suffix:semicolon
multiline_comment|/*&n;&t; * setup avail_ram - this is the first part of ram usable&n;&t; * by the uncompress code. -- Cort&n;&t; */
id|avail_ram
op_assign
(paren
r_char
op_star
)paren
id|PAGE_ALIGN
c_func
(paren
(paren
r_int
r_int
)paren
id|zimage_start
op_plus
id|zimage_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|load_addr
op_plus
(paren
id|num_words
op_star
l_int|4
)paren
)paren
OG
(paren
r_int
r_int
)paren
id|avail_ram
)paren
op_logical_and
(paren
id|load_addr
op_le
l_int|0x01000000
)paren
)paren
id|avail_ram
op_assign
(paren
r_char
op_star
)paren
(paren
id|load_addr
op_plus
(paren
id|num_words
op_star
l_int|4
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
(paren
r_int
r_int
)paren
op_amp
id|start
op_plus
(paren
id|num_words
op_star
l_int|4
)paren
)paren
OG
(paren
r_int
r_int
)paren
id|avail_ram
)paren
op_logical_and
(paren
id|load_addr
op_le
l_int|0x01000000
)paren
)paren
id|avail_ram
op_assign
(paren
r_char
op_star
)paren
(paren
(paren
r_int
r_int
)paren
op_amp
id|start
op_plus
(paren
id|num_words
op_star
l_int|4
)paren
)paren
suffix:semicolon
multiline_comment|/* relocate zimage */
id|puts
c_func
(paren
l_string|&quot;zimage at:     &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
id|zimage_start
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
(paren
id|zimage_size
op_plus
id|zimage_start
)paren
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * There is no reason (yet) to relocate zImage for embedded boards.&n;&t; * To support boot from flash rom on 8xx embedded boards, I&n;&t; * assume if zimage start is over 16M we are booting from flash.&n;&t; * In this case, avilable ram will start just above the space we&n;&t; * have allocated for the command buffer and board information.&n;&t; */
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|zimage_start
OG
l_int|0x01000000
)paren
id|avail_ram
op_assign
(paren
r_char
op_star
)paren
id|PAGE_ALIGN
c_func
(paren
(paren
r_int
r_int
)paren
id|hold_residual
op_plus
r_sizeof
(paren
id|bd_t
)paren
)paren
suffix:semicolon
multiline_comment|/* relocate initrd */
r_if
c_cond
(paren
id|initrd_start
)paren
(brace
id|puts
c_func
(paren
l_string|&quot;initrd at:     &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
id|initrd_start
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
id|initrd_end
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* We only have to relocate initrd if we find it is in Flash&n;&t;&t; * rom.  This is because the kernel thinks it can toss the&n;&t;&t; * pages into the free memory pool after it is done.  Use&n;&t;&t; * the same 16M test.&n;&t;&t; */
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|initrd_start
OG
l_int|0x01000000
)paren
(brace
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|PAGE_ALIGN
c_func
(paren
op_minus
id|PAGE_SIZE
op_plus
(paren
r_int
r_int
)paren
id|end_avail
op_minus
id|INITRD_SIZE
)paren
comma
(paren
r_void
op_star
)paren
id|initrd_start
comma
id|initrd_size
)paren
suffix:semicolon
id|initrd_start
op_assign
id|PAGE_ALIGN
c_func
(paren
op_minus
id|PAGE_SIZE
op_plus
(paren
r_int
r_int
)paren
id|end_avail
op_minus
id|INITRD_SIZE
)paren
suffix:semicolon
id|initrd_end
op_assign
id|initrd_start
op_plus
id|initrd_size
suffix:semicolon
id|end_avail
op_assign
(paren
r_char
op_star
)paren
id|initrd_start
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;relocated to:  &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
id|initrd_start
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
id|initrd_end
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|avail_ram
op_assign
(paren
r_char
op_star
)paren
id|PAGE_ALIGN
c_func
(paren
(paren
r_int
r_int
)paren
id|initrd_end
)paren
suffix:semicolon
)brace
)brace
id|puts
c_func
(paren
l_string|&quot;avail ram:     &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
id|avail_ram
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|puthex
c_func
(paren
(paren
r_int
r_int
)paren
id|end_avail
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;&bslash;nLinux/PPC load: &quot;
)paren
suffix:semicolon
id|timer
op_assign
l_int|0
suffix:semicolon
id|cp
op_assign
id|cmd_line
suffix:semicolon
multiline_comment|/* This is where we try and pick the right command line for booting.&n;&t; * If we were given one at compile time, use it.  It Is Right.&n;&t; * If we weren&squot;t, see if we have a ramdisk.  If so, thats root.&n;&t; * When in doubt, give them the netroot (root=/dev/nfs rw) -- Tom */
macro_line|#ifdef CONFIG_CMDLINE_BOOL
id|memcpy
(paren
id|cmd_line
comma
id|compiled_string
comma
r_sizeof
(paren
id|compiled_string
)paren
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|initrd_start
)paren
id|memcpy
(paren
id|cmd_line
comma
id|ramroot_string
comma
r_sizeof
(paren
id|ramroot_string
)paren
)paren
suffix:semicolon
r_else
id|memcpy
(paren
id|cmd_line
comma
id|netroot_string
comma
r_sizeof
(paren
id|netroot_string
)paren
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
op_star
id|cp
)paren
id|putc
c_func
(paren
op_star
id|cp
op_increment
)paren
suffix:semicolon
r_while
c_loop
(paren
id|timer
op_increment
OL
l_int|5
op_star
l_int|1000
)paren
(brace
r_if
c_cond
(paren
id|tstc
c_func
(paren
)paren
)paren
(brace
r_while
c_loop
(paren
(paren
id|ch
op_assign
id|getc
c_func
(paren
)paren
)paren
op_ne
l_char|&squot;&bslash;n&squot;
op_logical_and
id|ch
op_ne
l_char|&squot;&bslash;r&squot;
)paren
(brace
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;&bslash;b&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;&bslash;177&squot;
)paren
(brace
r_if
c_cond
(paren
id|cp
op_ne
id|cmd_line
)paren
(brace
id|cp
op_decrement
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;&bslash;b &bslash;b&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;&bslash;030&squot;
multiline_comment|/* ^x */
op_logical_or
id|ch
op_eq
l_char|&squot;&bslash;025&squot;
)paren
(brace
multiline_comment|/* ^u */
r_while
c_loop
(paren
id|cp
op_ne
id|cmd_line
)paren
(brace
id|cp
op_decrement
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;&bslash;b &bslash;b&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
op_star
id|cp
op_increment
op_assign
id|ch
suffix:semicolon
id|putc
c_func
(paren
id|ch
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
multiline_comment|/* Exit &squot;timer&squot; loop */
)brace
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* 1 msec */
)brace
op_star
id|cp
op_assign
l_int|0
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;&bslash;nUncompressing Linux...&quot;
)paren
suffix:semicolon
id|gunzip
c_func
(paren
l_int|0
comma
l_int|0x400000
comma
id|zimage_start
comma
op_amp
id|zimage_size
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;done.&bslash;n&quot;
)paren
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;Now booting the kernel&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
id|hold_residual
suffix:semicolon
)brace
multiline_comment|/*&n; * PCI/ISA I/O support&n; */
DECL|variable|ISA_io
r_volatile
r_int
r_char
op_star
id|ISA_io
op_assign
(paren
r_int
r_char
op_star
)paren
l_int|0x80000000
suffix:semicolon
DECL|variable|ISA_mem
r_volatile
r_int
r_char
op_star
id|ISA_mem
op_assign
(paren
r_int
r_char
op_star
)paren
l_int|0xC0000000
suffix:semicolon
r_void
DECL|function|outb
id|outb
c_func
(paren
r_int
id|port
comma
r_char
id|val
)paren
(brace
multiline_comment|/* Ensure I/O operations complete */
id|__asm__
r_volatile
(paren
l_string|&quot;eieio&quot;
)paren
suffix:semicolon
id|ISA_io
(braket
id|port
)braket
op_assign
id|val
suffix:semicolon
)brace
r_int
r_char
DECL|function|inb
id|inb
c_func
(paren
r_int
id|port
)paren
(brace
multiline_comment|/* Ensure I/O operations complete */
id|__asm__
r_volatile
(paren
l_string|&quot;eieio&quot;
)paren
suffix:semicolon
r_return
(paren
id|ISA_io
(braket
id|port
)braket
)paren
suffix:semicolon
)brace
r_int
r_int
DECL|function|local_to_PCI
id|local_to_PCI
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_return
(paren
(paren
id|addr
op_amp
l_int|0x7FFFFFFF
)paren
op_or
l_int|0x80000000
)paren
suffix:semicolon
)brace
eof
