multiline_comment|/*&n; * Makes a tree bootable image for IBM Evaluation boards.&n; * Basically, just take a zImage, skip the ELF header, and stuff&n; * a 32 byte header on the front.&n; *&n; * We use htonl, which is a network macro, to make sure we&squot;re doing&n; * The Right Thing on an LE machine.  It&squot;s non-obvious, but it should&n; * work on anything BSD&squot;ish.&n; */
macro_line|#include &lt;fcntl.h&gt;
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;sys/stat.h&gt;
macro_line|#include &lt;unistd.h&gt;
macro_line|#include &lt;netinet/in.h&gt;
multiline_comment|/* This gets tacked on the front of the image.  There are also a few&n; * bytes allocated after the _start label used by the boot rom (see&n; * head.S for details).&n; */
DECL|struct|boot_block
r_typedef
r_struct
id|boot_block
(brace
DECL|member|bb_magic
r_int
r_int
id|bb_magic
suffix:semicolon
multiline_comment|/* 0x0052504F */
DECL|member|bb_dest
r_int
r_int
id|bb_dest
suffix:semicolon
multiline_comment|/* Target address of the image */
DECL|member|bb_num_512blocks
r_int
r_int
id|bb_num_512blocks
suffix:semicolon
multiline_comment|/* Size, rounded-up, in 512 byte blks */
DECL|member|bb_debug_flag
r_int
r_int
id|bb_debug_flag
suffix:semicolon
multiline_comment|/* Run debugger or image after load */
DECL|member|bb_entry_point
r_int
r_int
id|bb_entry_point
suffix:semicolon
multiline_comment|/* The image address to start */
DECL|member|bb_checksum
r_int
r_int
id|bb_checksum
suffix:semicolon
multiline_comment|/* 32 bit checksum including header */
DECL|member|reserved
r_int
r_int
id|reserved
(braket
l_int|2
)braket
suffix:semicolon
DECL|typedef|boot_block_t
)brace
id|boot_block_t
suffix:semicolon
DECL|macro|IMGBLK
mdefine_line|#define IMGBLK&t;512
DECL|variable|tmpbuf
r_char
id|tmpbuf
(braket
id|IMGBLK
)braket
suffix:semicolon
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
id|argv
(braket
)braket
)paren
(brace
r_int
id|in_fd
comma
id|out_fd
suffix:semicolon
r_int
id|nblks
comma
id|i
suffix:semicolon
id|uint
id|cksum
comma
op_star
id|cp
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
id|boot_block_t
id|bt
suffix:semicolon
r_if
c_cond
(paren
id|argc
OL
l_int|3
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;usage: %s &lt;zImage-file&gt; &lt;boot-image&gt; [entry-point]&bslash;n&quot;
comma
id|argv
(braket
l_int|0
)braket
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stat
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;stat&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|2
)paren
suffix:semicolon
)brace
id|nblks
op_assign
(paren
id|st.st_size
op_plus
id|IMGBLK
)paren
op_div
id|IMGBLK
suffix:semicolon
id|bt.bb_magic
op_assign
id|htonl
c_func
(paren
l_int|0x0052504F
)paren
suffix:semicolon
multiline_comment|/* If we have the optional entry point parameter, use it */
r_if
c_cond
(paren
id|argc
op_eq
l_int|4
)paren
id|bt.bb_dest
op_assign
id|bt.bb_entry_point
op_assign
id|htonl
c_func
(paren
id|strtoul
c_func
(paren
id|argv
(braket
l_int|3
)braket
comma
l_int|NULL
comma
l_int|0
)paren
)paren
suffix:semicolon
r_else
id|bt.bb_dest
op_assign
id|bt.bb_entry_point
op_assign
id|htonl
c_func
(paren
l_int|0x500000
)paren
suffix:semicolon
multiline_comment|/* We know these from the linker command.&n;&t; * ...and then move it up into memory a little more so the&n;&t; * relocation can happen.&n;&t; */
id|bt.bb_num_512blocks
op_assign
id|htonl
c_func
(paren
id|nblks
)paren
suffix:semicolon
id|bt.bb_debug_flag
op_assign
l_int|0
suffix:semicolon
id|bt.bb_checksum
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* To be neat and tidy :-).&n;&t;*/
id|bt.reserved
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|bt.reserved
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|in_fd
op_assign
id|open
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
id|O_RDONLY
)paren
)paren
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;zImage open&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|3
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|out_fd
op_assign
id|open
c_func
(paren
id|argv
(braket
l_int|2
)braket
comma
(paren
id|O_RDWR
op_or
id|O_CREAT
op_or
id|O_TRUNC
)paren
comma
l_int|0666
)paren
)paren
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;bootfile open&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|3
)paren
suffix:semicolon
)brace
id|cksum
op_assign
l_int|0
suffix:semicolon
id|cp
op_assign
(paren
id|uint
op_star
)paren
op_amp
id|bt
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|bt
)paren
op_div
r_sizeof
(paren
id|uint
)paren
suffix:semicolon
id|i
op_increment
)paren
id|cksum
op_add_assign
op_star
id|cp
op_increment
suffix:semicolon
multiline_comment|/* Assume zImage is an ELF file, and skip the 64K header.&n;&t;*/
r_if
c_cond
(paren
id|read
c_func
(paren
id|in_fd
comma
id|tmpbuf
comma
id|IMGBLK
)paren
op_ne
id|IMGBLK
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s is too small to be an ELF image&bslash;n&quot;
comma
id|argv
(braket
l_int|1
)braket
)paren
suffix:semicolon
m_exit
(paren
l_int|4
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_star
(paren
id|uint
op_star
)paren
id|tmpbuf
)paren
op_ne
id|htonl
c_func
(paren
l_int|0x7f454c46
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s is not an ELF image&bslash;n&quot;
comma
id|argv
(braket
l_int|1
)braket
)paren
suffix:semicolon
m_exit
(paren
l_int|4
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lseek
c_func
(paren
id|in_fd
comma
(paren
l_int|64
op_star
l_int|1024
)paren
comma
id|SEEK_SET
)paren
OL
l_int|0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s failed to seek in ELF image&bslash;n&quot;
comma
id|argv
(braket
l_int|1
)braket
)paren
suffix:semicolon
m_exit
(paren
l_int|4
)paren
suffix:semicolon
)brace
id|nblks
op_sub_assign
(paren
l_int|64
op_star
l_int|1024
)paren
op_div
id|IMGBLK
suffix:semicolon
multiline_comment|/* And away we go......&n;&t;*/
r_if
c_cond
(paren
id|write
c_func
(paren
id|out_fd
comma
op_amp
id|bt
comma
r_sizeof
(paren
id|bt
)paren
)paren
op_ne
r_sizeof
(paren
id|bt
)paren
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;boot-image write&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|5
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|nblks
op_decrement
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|read
c_func
(paren
id|in_fd
comma
id|tmpbuf
comma
id|IMGBLK
)paren
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;zImage read&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|5
)paren
suffix:semicolon
)brace
id|cp
op_assign
(paren
id|uint
op_star
)paren
id|tmpbuf
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|tmpbuf
)paren
op_div
r_sizeof
(paren
id|uint
)paren
suffix:semicolon
id|i
op_increment
)paren
id|cksum
op_add_assign
op_star
id|cp
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|write
c_func
(paren
id|out_fd
comma
id|tmpbuf
comma
r_sizeof
(paren
id|tmpbuf
)paren
)paren
op_ne
r_sizeof
(paren
id|tmpbuf
)paren
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;boot-image write&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|5
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* rewrite the header with the computed checksum.&n;&t;*/
id|bt.bb_checksum
op_assign
id|htonl
c_func
(paren
id|cksum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lseek
c_func
(paren
id|out_fd
comma
l_int|0
comma
id|SEEK_SET
)paren
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;rewrite seek&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|write
c_func
(paren
id|out_fd
comma
op_amp
id|bt
comma
r_sizeof
(paren
id|bt
)paren
)paren
op_ne
r_sizeof
(paren
id|bt
)paren
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;boot-image rewrite&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
m_exit
(paren
l_int|0
)paren
suffix:semicolon
)brace
eof
