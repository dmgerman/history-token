multiline_comment|/*&n; * BK Id: %F% %I% %G% %U% %#%&n; */
multiline_comment|/*&n; * This file contains the routines for TLB flushing.&n; * On machines where the MMU uses a hash table to store virtual to&n; * physical translations, these routines flush entries from the the&n; * hash table also.&n; *  -- paulus&n; * &n; *  Derived from arch/ppc/mm/init.c:&n; *    Copyright (C) 1995-1996 Gary Thomas (gdt@linuxppc.org)&n; *&n; *  Modifications by Paul Mackerras (PowerMac) (paulus@cs.anu.edu.au)&n; *  and Cort Dougan (PReP) (cort@cs.nmt.edu)&n; *    Copyright (C) 1996 Paul Mackerras&n; *  Amiga/APUS changes by Jesper Skov (jskov@cygnus.co.uk).&n; *&n; *  Derived from &quot;arch/i386/mm/init.c&quot;&n; *    Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds&n; *&n; *  This program is free software; you can redistribute it and/or&n; *  modify it under the terms of the GNU General Public License&n; *  as published by the Free Software Foundation; either version&n; *  2 of the License, or (at your option) any later version.&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &quot;mmu_decl.h&quot;
multiline_comment|/*&n; * TLB flushing:&n; *&n; *  - flush_tlb_all() flushes all processes TLBs&n; *  - flush_tlb_mm(mm) flushes the specified mm context TLB&squot;s&n; *  - flush_tlb_page(vma, vmaddr) flushes one page&n; *  - flush_tlb_range(mm, start, end) flushes a range of pages&n; *&n; * since the hardware hash table functions as an extension of the&n; * tlb as far as the linux tables are concerned, flush it too.&n; *    -- Cort&n; */
multiline_comment|/*&n; * Flush all tlb/hash table entries (except perhaps for those&n; * mapping RAM starting at PAGE_OFFSET, since they never change).&n; */
r_void
DECL|function|local_flush_tlb_all
id|local_flush_tlb_all
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* aargh!!! */
multiline_comment|/*&n;&t; * Just flush the kernel part of the address space, that&squot;s&n;&t; * all that the current callers of this require.&n;&t; * Eventually I hope to persuade the powers that be that&n;&t; * we can and should dispense with flush_tlb_all().&n;&t; *  -- paulus.&n;&t; */
id|local_flush_tlb_range
c_func
(paren
op_amp
id|init_mm
comma
id|TASK_SIZE
comma
op_complement
l_int|0UL
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|smp_send_tlb_invalidate
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
)brace
multiline_comment|/*&n; * Flush all the (user) entries for the address space described&n; * by mm.  We can&squot;t rely on mm-&gt;mmap describing all the entries&n; * that might be in the hash table.&n; */
r_void
DECL|function|local_flush_tlb_mm
id|local_flush_tlb_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_if
c_cond
(paren
id|Hash
op_eq
l_int|0
)paren
(brace
id|_tlbia
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mm-&gt;map_count
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|mp
suffix:semicolon
r_for
c_loop
(paren
id|mp
op_assign
id|mm-&gt;mmap
suffix:semicolon
id|mp
op_ne
l_int|NULL
suffix:semicolon
id|mp
op_assign
id|mp-&gt;vm_next
)paren
id|local_flush_tlb_range
c_func
(paren
id|mm
comma
id|mp-&gt;vm_start
comma
id|mp-&gt;vm_end
)paren
suffix:semicolon
)brace
r_else
id|local_flush_tlb_range
c_func
(paren
id|mm
comma
l_int|0
comma
id|TASK_SIZE
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|smp_send_tlb_invalidate
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
r_void
DECL|function|local_flush_tlb_page
id|local_flush_tlb_page
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|vmaddr
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
r_if
c_cond
(paren
id|Hash
op_eq
l_int|0
)paren
(brace
id|_tlbie
c_func
(paren
id|vmaddr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|mm
op_assign
(paren
id|vmaddr
OL
id|TASK_SIZE
)paren
ques
c_cond
id|vma-&gt;vm_mm
suffix:colon
op_amp
id|init_mm
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd_offset
c_func
(paren
id|mm
comma
id|vmaddr
)paren
comma
id|vmaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|pte
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|vmaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pte_val
c_func
(paren
op_star
id|pte
)paren
op_amp
id|_PAGE_HASHPTE
)paren
id|flush_hash_page
c_func
(paren
id|mm-&gt;context
comma
id|vmaddr
comma
id|pte
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
id|smp_send_tlb_invalidate
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
multiline_comment|/*&n; * For each address in the range, find the pte for the address&n; * and check _PAGE_HASHPTE bit; if it is set, find and destroy&n; * the corresponding HPTE.&n; */
r_void
DECL|function|local_flush_tlb_range
id|local_flush_tlb_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
r_int
r_int
id|pmd_end
suffix:semicolon
r_int
r_int
id|ctx
op_assign
id|mm-&gt;context
suffix:semicolon
r_if
c_cond
(paren
id|Hash
op_eq
l_int|0
)paren
(brace
id|_tlbia
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|start
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|start
op_ge
id|end
)paren
r_return
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd_offset
c_func
(paren
id|mm
comma
id|start
)paren
comma
id|start
)paren
suffix:semicolon
r_do
(brace
id|pmd_end
op_assign
(paren
id|start
op_plus
id|PGDIR_SIZE
)paren
op_amp
id|PGDIR_MASK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pmd_end
op_logical_or
id|pmd_end
OG
id|end
)paren
id|pmd_end
op_assign
id|end
suffix:semicolon
id|pte
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|start
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
(paren
id|pte_val
c_func
(paren
op_star
id|pte
)paren
op_amp
id|_PAGE_HASHPTE
)paren
op_ne
l_int|0
)paren
id|flush_hash_page
c_func
(paren
id|ctx
comma
id|start
comma
id|pte
)paren
suffix:semicolon
id|start
op_add_assign
id|PAGE_SIZE
suffix:semicolon
op_increment
id|pte
suffix:semicolon
)brace
r_while
c_loop
(paren
id|start
op_logical_and
id|start
OL
id|pmd_end
)paren
suffix:semicolon
)brace
r_else
(brace
id|start
op_assign
id|pmd_end
suffix:semicolon
)brace
op_increment
id|pmd
suffix:semicolon
)brace
r_while
c_loop
(paren
id|start
op_logical_and
id|start
OL
id|end
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|smp_send_tlb_invalidate
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
eof
