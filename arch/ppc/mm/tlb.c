multiline_comment|/*&n; * BK Id: %F% %I% %G% %U% %#%&n; */
multiline_comment|/*&n; * This file contains the routines for TLB flushing.&n; * On machines where the MMU uses a hash table to store virtual to&n; * physical translations, these routines flush entries from the the&n; * hash table also.&n; *  -- paulus&n; * &n; *  Derived from arch/ppc/mm/init.c:&n; *    Copyright (C) 1995-1996 Gary Thomas (gdt@linuxppc.org)&n; *&n; *  Modifications by Paul Mackerras (PowerMac) (paulus@cs.anu.edu.au)&n; *  and Cort Dougan (PReP) (cort@cs.nmt.edu)&n; *    Copyright (C) 1996 Paul Mackerras&n; *  Amiga/APUS changes by Jesper Skov (jskov@cygnus.co.uk).&n; *&n; *  Derived from &quot;arch/i386/mm/init.c&quot;&n; *    Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds&n; *&n; *  This program is free software; you can redistribute it and/or&n; *  modify it under the terms of the GNU General Public License&n; *  as published by the Free Software Foundation; either version&n; *  2 of the License, or (at your option) any later version.&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &quot;mmu_decl.h&quot;
multiline_comment|/*&n; * TLB flushing:&n; *&n; *  - flush_tlb_all() flushes all processes TLBs&n; *  - flush_tlb_mm(mm) flushes the specified mm context TLB&squot;s&n; *  - flush_tlb_page(vma, vmaddr) flushes one page&n; *  - flush_tlb_range(vma, start, end) flushes a range of pages&n; *  - flush_tlb_kernel_range(start, end) flushes kernel pages&n; *&n; * since the hardware hash table functions as an extension of the&n; * tlb as far as the linux tables are concerned, flush it too.&n; *    -- Cort&n; */
multiline_comment|/*&n; * 750 SMP is a Bad Idea because the 750 doesn&squot;t broadcast all&n; * the cache operations on the bus.  Hence we need to use an IPI&n; * to get the other CPU(s) to invalidate their TLBs.&n; */
macro_line|#ifdef CONFIG_SMP_750
DECL|macro|FINISH_FLUSH
mdefine_line|#define FINISH_FLUSH&t;smp_send_tlb_invalidate(0)
macro_line|#else
DECL|macro|FINISH_FLUSH
mdefine_line|#define FINISH_FLUSH&t;do { } while (0)
macro_line|#endif
DECL|function|flush_range
r_static
r_void
id|flush_range
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
id|pmd_t
op_star
id|pmd
suffix:semicolon
r_int
r_int
id|pmd_end
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
r_int
id|ctx
op_assign
id|mm-&gt;context
suffix:semicolon
r_if
c_cond
(paren
id|Hash
op_eq
l_int|0
)paren
(brace
id|_tlbia
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|start
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|start
op_ge
id|end
)paren
r_return
suffix:semicolon
id|end
op_assign
(paren
id|end
op_minus
l_int|1
)paren
op_or
op_complement
id|PAGE_MASK
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd_offset
c_func
(paren
id|mm
comma
id|start
)paren
comma
id|start
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|pmd_end
op_assign
(paren
(paren
id|start
op_plus
id|PGDIR_SIZE
)paren
op_amp
id|PGDIR_MASK
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pmd_end
OG
id|end
)paren
id|pmd_end
op_assign
id|end
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|count
op_assign
(paren
(paren
id|pmd_end
op_minus
id|start
)paren
op_rshift
id|PAGE_SHIFT
)paren
op_plus
l_int|1
suffix:semicolon
id|flush_hash_pages
c_func
(paren
id|ctx
comma
id|start
comma
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
comma
id|count
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pmd_end
op_eq
id|end
)paren
r_break
suffix:semicolon
id|start
op_assign
id|pmd_end
op_plus
l_int|1
suffix:semicolon
op_increment
id|pmd
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Flush all tlb/hash table entries (except perhaps for those&n; * mapping RAM starting at PAGE_OFFSET, since they never change).&n; */
r_void
DECL|function|flush_tlb_all
id|flush_tlb_all
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * Just flush the kernel part of the address space, that&squot;s&n;&t; * all that the current callers of this require.&n;&t; * Eventually I hope to persuade the powers that be that&n;&t; * we can and should dispense with flush_tlb_all().&n;&t; *  -- paulus.&n;&t; *&n;&t; * In fact this should never get called now that we&n;&t; * have flush_tlb_kernel_range.  -- paulus&n;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;flush_tlb_all called from %p&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|flush_range
c_func
(paren
op_amp
id|init_mm
comma
id|TASK_SIZE
comma
op_complement
l_int|0UL
)paren
suffix:semicolon
id|FINISH_FLUSH
suffix:semicolon
)brace
multiline_comment|/*&n; * Flush kernel TLB entries in the given range&n; */
DECL|function|flush_tlb_kernel_range
r_void
id|flush_tlb_kernel_range
c_func
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
id|flush_range
c_func
(paren
op_amp
id|init_mm
comma
id|start
comma
id|end
)paren
suffix:semicolon
id|FINISH_FLUSH
suffix:semicolon
)brace
multiline_comment|/*&n; * Flush all the (user) entries for the address space described&n; * by mm.  We can&squot;t rely on mm-&gt;mmap describing all the entries&n; * that might be in the hash table.&n; */
DECL|function|flush_tlb_mm
r_void
id|flush_tlb_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_if
c_cond
(paren
id|Hash
op_eq
l_int|0
)paren
(brace
id|_tlbia
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mm-&gt;map_count
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|mp
suffix:semicolon
r_for
c_loop
(paren
id|mp
op_assign
id|mm-&gt;mmap
suffix:semicolon
id|mp
op_ne
l_int|NULL
suffix:semicolon
id|mp
op_assign
id|mp-&gt;vm_next
)paren
id|flush_range
c_func
(paren
id|mp-&gt;vm_mm
comma
id|mp-&gt;vm_start
comma
id|mp-&gt;vm_end
)paren
suffix:semicolon
)brace
r_else
(brace
id|flush_range
c_func
(paren
id|mm
comma
l_int|0
comma
id|TASK_SIZE
)paren
suffix:semicolon
)brace
id|FINISH_FLUSH
suffix:semicolon
)brace
DECL|function|flush_tlb_page
r_void
id|flush_tlb_page
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|vmaddr
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
r_if
c_cond
(paren
id|Hash
op_eq
l_int|0
)paren
(brace
id|_tlbie
c_func
(paren
id|vmaddr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|mm
op_assign
(paren
id|vmaddr
OL
id|TASK_SIZE
)paren
ques
c_cond
id|vma-&gt;vm_mm
suffix:colon
op_amp
id|init_mm
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd_offset
c_func
(paren
id|mm
comma
id|vmaddr
)paren
comma
id|vmaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
id|flush_hash_pages
c_func
(paren
id|mm-&gt;context
comma
id|vmaddr
comma
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
comma
l_int|1
)paren
suffix:semicolon
id|FINISH_FLUSH
suffix:semicolon
)brace
multiline_comment|/*&n; * For each address in the range, find the pte for the address&n; * and check _PAGE_HASHPTE bit; if it is set, find and destroy&n; * the corresponding HPTE.&n; */
DECL|function|flush_tlb_range
r_void
id|flush_tlb_range
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
id|flush_range
c_func
(paren
id|vma-&gt;vm_mm
comma
id|start
comma
id|end
)paren
suffix:semicolon
id|FINISH_FLUSH
suffix:semicolon
)brace
eof
