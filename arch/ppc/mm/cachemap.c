multiline_comment|/*&n; *  PowerPC version derived from arch/arm/mm/consistent.c&n; *    Copyright (C) 2001 Dan Malek (dmalek@jlc.net)&n; *&n; *  arch/ppc/mm/cachemap.c&n; *&n; *  Copyright (C) 2000 Russell King&n; *&n; * Consistent memory allocators.  Used for DMA devices that want to&n; * share uncached memory with the processor core.  The function return&n; * is the virtual address and &squot;dma_handle&squot; is the physical address.&n; * Mostly stolen from the ARM port, with some changes for PowerPC.&n; *&t;&t;&t;&t;&t;&t;-- Dan&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License version 2 as&n; * published by the Free Software Foundation.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/dma-mapping.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/hardirq.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
r_int
id|map_page
c_func
(paren
r_int
r_int
id|va
comma
id|phys_addr_t
id|pa
comma
r_int
id|flags
)paren
suffix:semicolon
multiline_comment|/* This function will allocate the requested contiguous pages and&n; * map them into the kernel&squot;s vmalloc() space.  This is done so we&n; * get unique mapping for these pages, outside of the kernel&squot;s 1:1&n; * virtual:physical mapping.  This is necessary so we can cover large&n; * portions of the kernel with single large page TLB entries, and&n; * still get unique uncached pages for consistent DMA.&n; */
DECL|function|consistent_alloc
r_void
op_star
id|consistent_alloc
c_func
(paren
r_int
id|gfp
comma
r_int
id|size
comma
id|dma_addr_t
op_star
id|dma_handle
)paren
(brace
r_int
id|order
comma
id|err
suffix:semicolon
r_struct
id|page
op_star
id|page
comma
op_star
id|free
comma
op_star
id|end
suffix:semicolon
id|phys_addr_t
id|pa
suffix:semicolon
r_int
r_int
id|flags
comma
id|offset
suffix:semicolon
r_struct
id|vm_struct
op_star
id|area
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|va
op_assign
l_int|0
suffix:semicolon
id|BUG_ON
c_func
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Only allocate page size areas */
id|size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|size
)paren
suffix:semicolon
id|order
op_assign
id|get_order
c_func
(paren
id|size
)paren
suffix:semicolon
id|free
op_assign
id|page
op_assign
id|alloc_pages
c_func
(paren
id|gfp
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_return
l_int|NULL
suffix:semicolon
id|pa
op_assign
id|page_to_phys
c_func
(paren
id|page
)paren
suffix:semicolon
op_star
id|dma_handle
op_assign
id|page_to_bus
c_func
(paren
id|page
)paren
suffix:semicolon
id|end
op_assign
id|page
op_plus
(paren
l_int|1
op_lshift
id|order
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we need to ensure that there are no cachelines in use,&n;&t; * or worse dirty in this area.&n;&t; */
id|invalidate_dcache_range
c_func
(paren
(paren
r_int
r_int
)paren
id|page_address
c_func
(paren
id|page
)paren
comma
(paren
r_int
r_int
)paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * alloc_pages() expects the block to be handled as a unit, so&n;&t; * it only sets the page count on the first page.  We set the&n;&t; * counts on each page so they can be freed individually&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|page
OL
id|end
suffix:semicolon
id|page
op_increment
)paren
id|set_page_count
c_func
(paren
id|page
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Allocate some common virtual space to map the new pages*/
id|area
op_assign
id|get_vm_area
c_func
(paren
id|size
comma
id|VM_ALLOC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|area
)paren
r_goto
id|out
suffix:semicolon
id|va
op_assign
(paren
r_int
r_int
)paren
id|area-&gt;addr
suffix:semicolon
id|flags
op_assign
id|_PAGE_KERNEL
op_or
id|_PAGE_NO_CACHE
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
l_int|0
suffix:semicolon
id|offset
OL
id|size
suffix:semicolon
id|offset
op_add_assign
id|PAGE_SIZE
)paren
(brace
id|err
op_assign
id|map_page
c_func
(paren
id|va
op_plus
id|offset
comma
id|pa
op_plus
id|offset
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|vfree
c_func
(paren
(paren
r_void
op_star
)paren
id|va
)paren
suffix:semicolon
id|va
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|free
op_increment
suffix:semicolon
)brace
id|out
suffix:colon
multiline_comment|/* Free pages which weren&squot;t mapped */
r_for
c_loop
(paren
suffix:semicolon
id|free
OL
id|end
suffix:semicolon
id|free
op_increment
)paren
(brace
id|__free_page
c_func
(paren
id|free
)paren
suffix:semicolon
)brace
r_return
(paren
r_void
op_star
)paren
id|va
suffix:semicolon
)brace
multiline_comment|/*&n; * free page(s) as defined by the above mapping.&n; */
DECL|function|consistent_free
r_void
id|consistent_free
c_func
(paren
r_void
op_star
id|vaddr
)paren
(brace
id|BUG_ON
c_func
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|vaddr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * make an area consistent.&n; */
DECL|function|consistent_sync
r_void
id|consistent_sync
c_func
(paren
r_void
op_star
id|vaddr
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
r_int
r_int
id|start
op_assign
(paren
r_int
r_int
)paren
id|vaddr
suffix:semicolon
r_int
r_int
id|end
op_assign
id|start
op_plus
id|size
suffix:semicolon
r_switch
c_cond
(paren
id|direction
)paren
(brace
r_case
id|DMA_NONE
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_case
id|DMA_FROM_DEVICE
suffix:colon
multiline_comment|/* invalidate only */
id|invalidate_dcache_range
c_func
(paren
id|start
comma
id|end
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DMA_TO_DEVICE
suffix:colon
multiline_comment|/* writeback only */
id|clean_dcache_range
c_func
(paren
id|start
comma
id|end
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DMA_BIDIRECTIONAL
suffix:colon
multiline_comment|/* writeback and invalidate */
id|flush_dcache_range
c_func
(paren
id|start
comma
id|end
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * consistent_sync_page make a page are consistent. identical&n; * to consistent_sync, but takes a struct page instead of a virtual address&n; */
DECL|function|consistent_sync_page
r_void
id|consistent_sync_page
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
comma
r_int
id|size
comma
r_int
id|direction
)paren
(brace
r_int
r_int
id|start
suffix:semicolon
id|start
op_assign
(paren
r_int
r_int
)paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|offset
suffix:semicolon
id|consistent_sync
c_func
(paren
(paren
r_void
op_star
)paren
id|start
comma
id|size
comma
id|direction
)paren
suffix:semicolon
)brace
DECL|variable|consistent_sync_page
id|EXPORT_SYMBOL
c_func
(paren
id|consistent_sync_page
)paren
suffix:semicolon
eof
