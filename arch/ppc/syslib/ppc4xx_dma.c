multiline_comment|/*&n; * arch/ppc/kernel/ppc4xx_dma.c&n; *&n; * IBM PPC4xx DMA engine core library&n; *&n; * Copyright 2000-2004 MontaVista Software Inc.&n; *&n; * Cleaned up and converted to new DCR access&n; * Matt Porter &lt;mporter@kernel.crashing.org&gt;&n; *&n; * Original code by Armin Kuster &lt;akuster@mvista.com&gt;&n; * and Pete Popov &lt;ppopov@mvista.com&gt;&n; *&n; * This program is free software; you can redistribute  it and/or modify it&n; * under  the terms of  the GNU General  Public License as published by the&n; * Free Software Foundation;  either version 2 of the  License, or (at your&n; * option) any later version.&n; *&n; * You should have received a copy of the  GNU General Public License along&n; * with this program; if not, write  to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/ppc4xx_dma.h&gt;
DECL|variable|dma_channels
id|ppc_dma_ch_t
id|dma_channels
(braket
id|MAX_PPC4xx_DMA_CHANNELS
)braket
suffix:semicolon
r_int
DECL|function|ppc4xx_get_dma_status
id|ppc4xx_get_dma_status
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|mfdcr
c_func
(paren
id|DCRN_DMASR
)paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|ppc4xx_set_src_addr
id|ppc4xx_set_src_addr
c_func
(paren
r_int
id|dmanr
comma
id|phys_addr_t
id|src_addr
)paren
(brace
r_if
c_cond
(paren
id|dmanr
op_ge
id|MAX_PPC4xx_DMA_CHANNELS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;set_src_addr: bad channel: %d&bslash;n&quot;
comma
id|dmanr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef PPC4xx_DMA64BIT
id|mtdcr
c_func
(paren
id|DCRN_DMASAH0
op_plus
id|dmanr
op_star
l_int|2
comma
(paren
id|u32
)paren
(paren
id|src_addr
op_rshift
l_int|32
)paren
)paren
suffix:semicolon
macro_line|#else
id|mtdcr
c_func
(paren
id|DCRN_DMASA0
op_plus
id|dmanr
op_star
l_int|2
comma
(paren
id|u32
)paren
id|src_addr
)paren
suffix:semicolon
macro_line|#endif
)brace
r_void
DECL|function|ppc4xx_set_dst_addr
id|ppc4xx_set_dst_addr
c_func
(paren
r_int
id|dmanr
comma
id|phys_addr_t
id|dst_addr
)paren
(brace
r_if
c_cond
(paren
id|dmanr
op_ge
id|MAX_PPC4xx_DMA_CHANNELS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;set_dst_addr: bad channel: %d&bslash;n&quot;
comma
id|dmanr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef PPC4xx_DMA64BIT
id|mtdcr
c_func
(paren
id|DCRN_DMADAH0
op_plus
id|dmanr
op_star
l_int|2
comma
(paren
id|u32
)paren
(paren
id|dst_addr
op_rshift
l_int|32
)paren
)paren
suffix:semicolon
macro_line|#else
id|mtdcr
c_func
(paren
id|DCRN_DMADA0
op_plus
id|dmanr
op_star
l_int|2
comma
(paren
id|u32
)paren
id|dst_addr
)paren
suffix:semicolon
macro_line|#endif
)brace
r_void
DECL|function|ppc4xx_enable_dma
id|ppc4xx_enable_dma
c_func
(paren
r_int
r_int
id|dmanr
)paren
(brace
r_int
r_int
id|control
suffix:semicolon
id|ppc_dma_ch_t
op_star
id|p_dma_ch
op_assign
op_amp
id|dma_channels
(braket
id|dmanr
)braket
suffix:semicolon
r_int
r_int
id|status_bits
(braket
)braket
op_assign
(brace
id|DMA_CS0
op_or
id|DMA_TS0
op_or
id|DMA_CH0_ERR
comma
id|DMA_CS1
op_or
id|DMA_TS1
op_or
id|DMA_CH1_ERR
comma
id|DMA_CS2
op_or
id|DMA_TS2
op_or
id|DMA_CH2_ERR
comma
id|DMA_CS3
op_or
id|DMA_TS3
op_or
id|DMA_CH3_ERR
)brace
suffix:semicolon
r_if
c_cond
(paren
id|p_dma_ch-&gt;in_use
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;enable_dma: channel %d in use&bslash;n&quot;
comma
id|dmanr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmanr
op_ge
id|MAX_PPC4xx_DMA_CHANNELS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;enable_dma: bad channel: %d&bslash;n&quot;
comma
id|dmanr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p_dma_ch-&gt;mode
op_eq
id|DMA_MODE_READ
)paren
(brace
multiline_comment|/* peripheral to memory */
id|ppc4xx_set_src_addr
c_func
(paren
id|dmanr
comma
l_int|0
)paren
suffix:semicolon
id|ppc4xx_set_dst_addr
c_func
(paren
id|dmanr
comma
id|p_dma_ch-&gt;addr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p_dma_ch-&gt;mode
op_eq
id|DMA_MODE_WRITE
)paren
(brace
multiline_comment|/* memory to peripheral */
id|ppc4xx_set_src_addr
c_func
(paren
id|dmanr
comma
id|p_dma_ch-&gt;addr
)paren
suffix:semicolon
id|ppc4xx_set_dst_addr
c_func
(paren
id|dmanr
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* for other xfer modes, the addresses are already set */
id|control
op_assign
id|mfdcr
c_func
(paren
id|DCRN_DMACR0
op_plus
(paren
id|dmanr
op_star
l_int|0x8
)paren
)paren
suffix:semicolon
id|control
op_and_assign
op_complement
(paren
id|DMA_TM_MASK
op_or
id|DMA_TD
)paren
suffix:semicolon
multiline_comment|/* clear all mode bits */
r_if
c_cond
(paren
id|p_dma_ch-&gt;mode
op_eq
id|DMA_MODE_MM
)paren
(brace
multiline_comment|/* software initiated memory to memory */
id|control
op_or_assign
id|DMA_ETD_OUTPUT
op_or
id|DMA_TCE_ENABLE
suffix:semicolon
)brace
id|mtdcr
c_func
(paren
id|DCRN_DMACR0
op_plus
(paren
id|dmanr
op_star
l_int|0x8
)paren
comma
id|control
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clear the CS, TS, RI bits for the channel from DMASR.  This&n;&t; * has been observed to happen correctly only after the mode and&n;&t; * ETD/DCE bits in DMACRx are set above.  Must do this before&n;&t; * enabling the channel.&n;&t; */
id|mtdcr
c_func
(paren
id|DCRN_DMASR
comma
id|status_bits
(braket
id|dmanr
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * For device-paced transfers, Terminal Count Enable apparently&n;&t; * must be on, and this must be turned on after the mode, etc.&n;&t; * bits are cleared above (at least on Redwood-6).&n;&t; */
r_if
c_cond
(paren
(paren
id|p_dma_ch-&gt;mode
op_eq
id|DMA_MODE_MM_DEVATDST
)paren
op_logical_or
(paren
id|p_dma_ch-&gt;mode
op_eq
id|DMA_MODE_MM_DEVATSRC
)paren
)paren
id|control
op_or_assign
id|DMA_TCE_ENABLE
suffix:semicolon
multiline_comment|/*&n;&t; * Now enable the channel.&n;&t; */
id|control
op_or_assign
(paren
id|p_dma_ch-&gt;mode
op_or
id|DMA_CE_ENABLE
)paren
suffix:semicolon
id|mtdcr
c_func
(paren
id|DCRN_DMACR0
op_plus
(paren
id|dmanr
op_star
l_int|0x8
)paren
comma
id|control
)paren
suffix:semicolon
id|p_dma_ch-&gt;in_use
op_assign
l_int|1
suffix:semicolon
)brace
r_void
DECL|function|ppc4xx_disable_dma
id|ppc4xx_disable_dma
c_func
(paren
r_int
r_int
id|dmanr
)paren
(brace
r_int
r_int
id|control
suffix:semicolon
id|ppc_dma_ch_t
op_star
id|p_dma_ch
op_assign
op_amp
id|dma_channels
(braket
id|dmanr
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p_dma_ch-&gt;in_use
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;disable_dma: channel %d not in use&bslash;n&quot;
comma
id|dmanr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmanr
op_ge
id|MAX_PPC4xx_DMA_CHANNELS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;disable_dma: bad channel: %d&bslash;n&quot;
comma
id|dmanr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|control
op_assign
id|mfdcr
c_func
(paren
id|DCRN_DMACR0
op_plus
(paren
id|dmanr
op_star
l_int|0x8
)paren
)paren
suffix:semicolon
id|control
op_and_assign
op_complement
id|DMA_CE_ENABLE
suffix:semicolon
id|mtdcr
c_func
(paren
id|DCRN_DMACR0
op_plus
(paren
id|dmanr
op_star
l_int|0x8
)paren
comma
id|control
)paren
suffix:semicolon
id|p_dma_ch-&gt;in_use
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Sets the dma mode for single DMA transfers only.&n; * For scatter/gather transfers, the mode is passed to the&n; * alloc_dma_handle() function as one of the parameters.&n; *&n; * The mode is simply saved and used later.  This allows&n; * the driver to call set_dma_mode() and set_dma_addr() in&n; * any order.&n; *&n; * Valid mode values are:&n; *&n; * DMA_MODE_READ          peripheral to memory&n; * DMA_MODE_WRITE         memory to peripheral&n; * DMA_MODE_MM            memory to memory&n; * DMA_MODE_MM_DEVATSRC   device-paced memory to memory, device at src&n; * DMA_MODE_MM_DEVATDST   device-paced memory to memory, device at dst&n; */
r_int
DECL|function|ppc4xx_set_dma_mode
id|ppc4xx_set_dma_mode
c_func
(paren
r_int
r_int
id|dmanr
comma
r_int
r_int
id|mode
)paren
(brace
id|ppc_dma_ch_t
op_star
id|p_dma_ch
op_assign
op_amp
id|dma_channels
(braket
id|dmanr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dmanr
op_ge
id|MAX_PPC4xx_DMA_CHANNELS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;set_dma_mode: bad channel 0x%x&bslash;n&quot;
comma
id|dmanr
)paren
suffix:semicolon
r_return
id|DMA_STATUS_BAD_CHANNEL
suffix:semicolon
)brace
id|p_dma_ch-&gt;mode
op_assign
id|mode
suffix:semicolon
r_return
id|DMA_STATUS_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; * Sets the DMA Count register. Note that &squot;count&squot; is in bytes.&n; * However, the DMA Count register counts the number of &quot;transfers&quot;,&n; * where each transfer is equal to the bus width.  Thus, count&n; * MUST be a multiple of the bus width.&n; */
r_void
DECL|function|ppc4xx_set_dma_count
id|ppc4xx_set_dma_count
c_func
(paren
r_int
r_int
id|dmanr
comma
r_int
r_int
id|count
)paren
(brace
id|ppc_dma_ch_t
op_star
id|p_dma_ch
op_assign
op_amp
id|dma_channels
(braket
id|dmanr
)braket
suffix:semicolon
macro_line|#ifdef DEBUG_4xxDMA
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|p_dma_ch-&gt;pwidth
)paren
(brace
r_case
id|PW_8
suffix:colon
r_break
suffix:semicolon
r_case
id|PW_16
suffix:colon
r_if
c_cond
(paren
id|count
op_amp
l_int|0x1
)paren
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PW_32
suffix:colon
r_if
c_cond
(paren
id|count
op_amp
l_int|0x3
)paren
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PW_64
suffix:colon
r_if
c_cond
(paren
id|count
op_amp
l_int|0x7
)paren
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;set_dma_count: invalid bus width: 0x%x&bslash;n&quot;
comma
id|p_dma_ch-&gt;pwidth
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
id|printk
(paren
l_string|&quot;Warning: set_dma_count count 0x%x bus width %d&bslash;n&quot;
comma
id|count
comma
id|p_dma_ch-&gt;pwidth
)paren
suffix:semicolon
)brace
macro_line|#endif
id|count
op_assign
id|count
op_rshift
id|p_dma_ch-&gt;shift
suffix:semicolon
id|mtdcr
c_func
(paren
id|DCRN_DMACT0
op_plus
(paren
id|dmanr
op_star
l_int|0x8
)paren
comma
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *   Returns the number of bytes left to be transfered.&n; *   After a DMA transfer, this should return zero.&n; *   Reading this while a DMA transfer is still in progress will return&n; *   unpredictable results.&n; */
r_int
DECL|function|ppc4xx_get_dma_residue
id|ppc4xx_get_dma_residue
c_func
(paren
r_int
r_int
id|dmanr
)paren
(brace
r_int
r_int
id|count
suffix:semicolon
id|ppc_dma_ch_t
op_star
id|p_dma_ch
op_assign
op_amp
id|dma_channels
(braket
id|dmanr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dmanr
op_ge
id|MAX_PPC4xx_DMA_CHANNELS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_get_dma_residue: bad channel 0x%x&bslash;n&quot;
comma
id|dmanr
)paren
suffix:semicolon
r_return
id|DMA_STATUS_BAD_CHANNEL
suffix:semicolon
)brace
id|count
op_assign
id|mfdcr
c_func
(paren
id|DCRN_DMACT0
op_plus
(paren
id|dmanr
op_star
l_int|0x8
)paren
)paren
suffix:semicolon
r_return
(paren
id|count
op_lshift
id|p_dma_ch-&gt;shift
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Sets the DMA address for a memory to peripheral or peripheral&n; * to memory transfer.  The address is just saved in the channel&n; * structure for now and used later in enable_dma().&n; */
r_void
DECL|function|ppc4xx_set_dma_addr
id|ppc4xx_set_dma_addr
c_func
(paren
r_int
r_int
id|dmanr
comma
id|phys_addr_t
id|addr
)paren
(brace
id|ppc_dma_ch_t
op_star
id|p_dma_ch
op_assign
op_amp
id|dma_channels
(braket
id|dmanr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dmanr
op_ge
id|MAX_PPC4xx_DMA_CHANNELS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_set_dma_addr: bad channel: %d&bslash;n&quot;
comma
id|dmanr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_4xxDMA
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|p_dma_ch-&gt;pwidth
)paren
(brace
r_case
id|PW_8
suffix:colon
r_break
suffix:semicolon
r_case
id|PW_16
suffix:colon
r_if
c_cond
(paren
(paren
r_int
)paren
id|addr
op_amp
l_int|0x1
)paren
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PW_32
suffix:colon
r_if
c_cond
(paren
(paren
r_int
)paren
id|addr
op_amp
l_int|0x3
)paren
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PW_64
suffix:colon
r_if
c_cond
(paren
(paren
r_int
)paren
id|addr
op_amp
l_int|0x7
)paren
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ppc4xx_set_dma_addr: invalid bus width: 0x%x&bslash;n&quot;
comma
id|p_dma_ch-&gt;pwidth
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
id|printk
c_func
(paren
l_string|&quot;Warning: ppc4xx_set_dma_addr addr 0x%x bus width %d&bslash;n&quot;
comma
id|addr
comma
id|p_dma_ch-&gt;pwidth
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* save dma address and program it later after we know the xfer mode */
id|p_dma_ch-&gt;addr
op_assign
id|addr
suffix:semicolon
)brace
multiline_comment|/*&n; * Sets both DMA addresses for a memory to memory transfer.&n; * For memory to peripheral or peripheral to memory transfers&n; * the function set_dma_addr() should be used instead.&n; */
r_void
DECL|function|ppc4xx_set_dma_addr2
id|ppc4xx_set_dma_addr2
c_func
(paren
r_int
r_int
id|dmanr
comma
id|phys_addr_t
id|src_dma_addr
comma
id|phys_addr_t
id|dst_dma_addr
)paren
(brace
r_if
c_cond
(paren
id|dmanr
op_ge
id|MAX_PPC4xx_DMA_CHANNELS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_set_dma_addr2: bad channel: %d&bslash;n&quot;
comma
id|dmanr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_4xxDMA
(brace
id|ppc_dma_ch_t
op_star
id|p_dma_ch
op_assign
op_amp
id|dma_channels
(braket
id|dmanr
)braket
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|p_dma_ch-&gt;pwidth
)paren
(brace
r_case
id|PW_8
suffix:colon
r_break
suffix:semicolon
r_case
id|PW_16
suffix:colon
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|src_dma_addr
op_amp
l_int|0x1
)paren
op_logical_or
(paren
(paren
r_int
)paren
id|dst_dma_addr
op_amp
l_int|0x1
)paren
)paren
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PW_32
suffix:colon
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|src_dma_addr
op_amp
l_int|0x3
)paren
op_logical_or
(paren
(paren
r_int
)paren
id|dst_dma_addr
op_amp
l_int|0x3
)paren
)paren
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PW_64
suffix:colon
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|src_dma_addr
op_amp
l_int|0x7
)paren
op_logical_or
(paren
(paren
r_int
)paren
id|dst_dma_addr
op_amp
l_int|0x7
)paren
)paren
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ppc4xx_set_dma_addr2: invalid bus width: 0x%x&bslash;n&quot;
comma
id|p_dma_ch-&gt;pwidth
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
id|printk
(paren
l_string|&quot;Warning: ppc4xx_set_dma_addr2 src 0x%x dst 0x%x bus width %d&bslash;n&quot;
comma
id|src_dma_addr
comma
id|dst_dma_addr
comma
id|p_dma_ch-&gt;pwidth
)paren
suffix:semicolon
)brace
macro_line|#endif
id|ppc4xx_set_src_addr
c_func
(paren
id|dmanr
comma
id|src_dma_addr
)paren
suffix:semicolon
id|ppc4xx_set_dst_addr
c_func
(paren
id|dmanr
comma
id|dst_dma_addr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Enables the channel interrupt.&n; *&n; * If performing a scatter/gatter transfer, this function&n; * MUST be called before calling alloc_dma_handle() and building&n; * the sgl list.  Otherwise, interrupts will not be enabled, if&n; * they were previously disabled.&n; */
r_int
DECL|function|ppc4xx_enable_dma_interrupt
id|ppc4xx_enable_dma_interrupt
c_func
(paren
r_int
r_int
id|dmanr
)paren
(brace
r_int
r_int
id|control
suffix:semicolon
id|ppc_dma_ch_t
op_star
id|p_dma_ch
op_assign
op_amp
id|dma_channels
(braket
id|dmanr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dmanr
op_ge
id|MAX_PPC4xx_DMA_CHANNELS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_enable_dma_interrupt: bad channel: %d&bslash;n&quot;
comma
id|dmanr
)paren
suffix:semicolon
r_return
id|DMA_STATUS_BAD_CHANNEL
suffix:semicolon
)brace
id|p_dma_ch-&gt;int_enable
op_assign
l_int|1
suffix:semicolon
id|control
op_assign
id|mfdcr
c_func
(paren
id|DCRN_DMACR0
op_plus
(paren
id|dmanr
op_star
l_int|0x8
)paren
)paren
suffix:semicolon
id|control
op_or_assign
id|DMA_CIE_ENABLE
suffix:semicolon
multiline_comment|/* Channel Interrupt Enable */
id|mtdcr
c_func
(paren
id|DCRN_DMACR0
op_plus
(paren
id|dmanr
op_star
l_int|0x8
)paren
comma
id|control
)paren
suffix:semicolon
r_return
id|DMA_STATUS_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; * Disables the channel interrupt.&n; *&n; * If performing a scatter/gatter transfer, this function&n; * MUST be called before calling alloc_dma_handle() and building&n; * the sgl list.  Otherwise, interrupts will not be disabled, if&n; * they were previously enabled.&n; */
r_int
DECL|function|ppc4xx_disable_dma_interrupt
id|ppc4xx_disable_dma_interrupt
c_func
(paren
r_int
r_int
id|dmanr
)paren
(brace
r_int
r_int
id|control
suffix:semicolon
id|ppc_dma_ch_t
op_star
id|p_dma_ch
op_assign
op_amp
id|dma_channels
(braket
id|dmanr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dmanr
op_ge
id|MAX_PPC4xx_DMA_CHANNELS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_disable_dma_interrupt: bad channel: %d&bslash;n&quot;
comma
id|dmanr
)paren
suffix:semicolon
r_return
id|DMA_STATUS_BAD_CHANNEL
suffix:semicolon
)brace
id|p_dma_ch-&gt;int_enable
op_assign
l_int|0
suffix:semicolon
id|control
op_assign
id|mfdcr
c_func
(paren
id|DCRN_DMACR0
op_plus
(paren
id|dmanr
op_star
l_int|0x8
)paren
)paren
suffix:semicolon
id|control
op_and_assign
op_complement
id|DMA_CIE_ENABLE
suffix:semicolon
multiline_comment|/* Channel Interrupt Enable */
id|mtdcr
c_func
(paren
id|DCRN_DMACR0
op_plus
(paren
id|dmanr
op_star
l_int|0x8
)paren
comma
id|control
)paren
suffix:semicolon
r_return
id|DMA_STATUS_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; * Configures a DMA channel, including the peripheral bus width, if a&n; * peripheral is attached to the channel, the polarity of the DMAReq and&n; * DMAAck signals, etc.  This information should really be setup by the boot&n; * code, since most likely the configuration won&squot;t change dynamically.&n; * If the kernel has to call this function, it&squot;s recommended that it&squot;s&n; * called from platform specific init code.  The driver should not need to&n; * call this function.&n; */
r_int
DECL|function|ppc4xx_init_dma_channel
id|ppc4xx_init_dma_channel
c_func
(paren
r_int
r_int
id|dmanr
comma
id|ppc_dma_ch_t
op_star
id|p_init
)paren
(brace
r_int
r_int
id|polarity
suffix:semicolon
r_uint32
id|control
op_assign
l_int|0
suffix:semicolon
id|ppc_dma_ch_t
op_star
id|p_dma_ch
op_assign
op_amp
id|dma_channels
(braket
id|dmanr
)braket
suffix:semicolon
id|DMA_MODE_READ
op_assign
(paren
r_int
r_int
)paren
id|DMA_TD
suffix:semicolon
multiline_comment|/* Peripheral to Memory */
id|DMA_MODE_WRITE
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Memory to Peripheral */
r_if
c_cond
(paren
op_logical_neg
id|p_init
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_init_dma_channel: NULL p_init&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|DMA_STATUS_NULL_POINTER
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmanr
op_ge
id|MAX_PPC4xx_DMA_CHANNELS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_init_dma_channel: bad channel %d&bslash;n&quot;
comma
id|dmanr
)paren
suffix:semicolon
r_return
id|DMA_STATUS_BAD_CHANNEL
suffix:semicolon
)brace
macro_line|#if DCRN_POL &gt; 0
id|polarity
op_assign
id|mfdcr
c_func
(paren
id|DCRN_POL
)paren
suffix:semicolon
macro_line|#else
id|polarity
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* Setup the control register based on the values passed to&n;&t; * us in p_init.  Then, over-write the control register with this&n;&t; * new value.&n;&t; */
id|control
op_or_assign
id|SET_DMA_CONTROL
suffix:semicolon
multiline_comment|/* clear all polarity signals and then &quot;or&quot; in new signal levels */
id|polarity
op_and_assign
op_complement
id|GET_DMA_POLARITY
c_func
(paren
id|dmanr
)paren
suffix:semicolon
id|polarity
op_or_assign
id|p_init-&gt;polarity
suffix:semicolon
macro_line|#if DCRN_POL &gt; 0
id|mtdcr
c_func
(paren
id|DCRN_POL
comma
id|polarity
)paren
suffix:semicolon
macro_line|#endif
id|mtdcr
c_func
(paren
id|DCRN_DMACR0
op_plus
(paren
id|dmanr
op_star
l_int|0x8
)paren
comma
id|control
)paren
suffix:semicolon
multiline_comment|/* save these values in our dma channel structure */
id|memcpy
c_func
(paren
id|p_dma_ch
comma
id|p_init
comma
r_sizeof
(paren
id|ppc_dma_ch_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The peripheral width values written in the control register are:&n;&t; *   PW_8                 0&n;&t; *   PW_16                1&n;&t; *   PW_32                2&n;&t; *   PW_64                3&n;&t; *&n;&t; *   Since the DMA count register takes the number of &quot;transfers&quot;,&n;&t; *   we need to divide the count sent to us in certain&n;&t; *   functions by the appropriate number.  It so happens that our&n;&t; *   right shift value is equal to the peripheral width value.&n;&t; */
id|p_dma_ch-&gt;shift
op_assign
id|p_init-&gt;pwidth
suffix:semicolon
multiline_comment|/*&n;&t; * Save the control word for easy access.&n;&t; */
id|p_dma_ch-&gt;control
op_assign
id|control
suffix:semicolon
id|mtdcr
c_func
(paren
id|DCRN_DMASR
comma
l_int|0xffffffff
)paren
suffix:semicolon
multiline_comment|/* clear status register */
r_return
id|DMA_STATUS_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; * This function returns the channel configuration.&n; */
r_int
DECL|function|ppc4xx_get_channel_config
id|ppc4xx_get_channel_config
c_func
(paren
r_int
r_int
id|dmanr
comma
id|ppc_dma_ch_t
op_star
id|p_dma_ch
)paren
(brace
r_int
r_int
id|polarity
suffix:semicolon
r_int
r_int
id|control
suffix:semicolon
r_if
c_cond
(paren
id|dmanr
op_ge
id|MAX_PPC4xx_DMA_CHANNELS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_get_channel_config: bad channel %d&bslash;n&quot;
comma
id|dmanr
)paren
suffix:semicolon
r_return
id|DMA_STATUS_BAD_CHANNEL
suffix:semicolon
)brace
macro_line|#if DCRN_POL &gt; 0
id|polarity
op_assign
id|mfdcr
c_func
(paren
id|DCRN_POL
)paren
suffix:semicolon
macro_line|#else
id|polarity
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|p_dma_ch-&gt;polarity
op_assign
id|polarity
op_amp
id|GET_DMA_POLARITY
c_func
(paren
id|dmanr
)paren
suffix:semicolon
id|control
op_assign
id|mfdcr
c_func
(paren
id|DCRN_DMACR0
op_plus
(paren
id|dmanr
op_star
l_int|0x8
)paren
)paren
suffix:semicolon
id|p_dma_ch-&gt;cp
op_assign
id|GET_DMA_PRIORITY
c_func
(paren
id|control
)paren
suffix:semicolon
id|p_dma_ch-&gt;pwidth
op_assign
id|GET_DMA_PW
c_func
(paren
id|control
)paren
suffix:semicolon
id|p_dma_ch-&gt;psc
op_assign
id|GET_DMA_PSC
c_func
(paren
id|control
)paren
suffix:semicolon
id|p_dma_ch-&gt;pwc
op_assign
id|GET_DMA_PWC
c_func
(paren
id|control
)paren
suffix:semicolon
id|p_dma_ch-&gt;phc
op_assign
id|GET_DMA_PHC
c_func
(paren
id|control
)paren
suffix:semicolon
id|p_dma_ch-&gt;ce
op_assign
id|GET_DMA_CE_ENABLE
c_func
(paren
id|control
)paren
suffix:semicolon
id|p_dma_ch-&gt;int_enable
op_assign
id|GET_DMA_CIE_ENABLE
c_func
(paren
id|control
)paren
suffix:semicolon
id|p_dma_ch-&gt;shift
op_assign
id|GET_DMA_PW
c_func
(paren
id|control
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PPC4xx_EDMA
id|p_dma_ch-&gt;pf
op_assign
id|GET_DMA_PREFETCH
c_func
(paren
id|control
)paren
suffix:semicolon
macro_line|#else
id|p_dma_ch-&gt;ch_enable
op_assign
id|GET_DMA_CH
c_func
(paren
id|control
)paren
suffix:semicolon
id|p_dma_ch-&gt;ece_enable
op_assign
id|GET_DMA_ECE
c_func
(paren
id|control
)paren
suffix:semicolon
id|p_dma_ch-&gt;tcd_disable
op_assign
id|GET_DMA_TCD
c_func
(paren
id|control
)paren
suffix:semicolon
macro_line|#endif
r_return
id|DMA_STATUS_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; * Sets the priority for the DMA channel dmanr.&n; * Since this is setup by the hardware init function, this function&n; * can be used to dynamically change the priority of a channel.&n; *&n; * Acceptable priorities:&n; *&n; * PRIORITY_LOW&n; * PRIORITY_MID_LOW&n; * PRIORITY_MID_HIGH&n; * PRIORITY_HIGH&n; *&n; */
r_int
DECL|function|ppc4xx_set_channel_priority
id|ppc4xx_set_channel_priority
c_func
(paren
r_int
r_int
id|dmanr
comma
r_int
r_int
id|priority
)paren
(brace
r_int
r_int
id|control
suffix:semicolon
r_if
c_cond
(paren
id|dmanr
op_ge
id|MAX_PPC4xx_DMA_CHANNELS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_set_channel_priority: bad channel %d&bslash;n&quot;
comma
id|dmanr
)paren
suffix:semicolon
r_return
id|DMA_STATUS_BAD_CHANNEL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|priority
op_ne
id|PRIORITY_LOW
)paren
op_logical_and
(paren
id|priority
op_ne
id|PRIORITY_MID_LOW
)paren
op_logical_and
(paren
id|priority
op_ne
id|PRIORITY_MID_HIGH
)paren
op_logical_and
(paren
id|priority
op_ne
id|PRIORITY_HIGH
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_set_channel_priority: bad priority: 0x%x&bslash;n&quot;
comma
id|priority
)paren
suffix:semicolon
)brace
id|control
op_assign
id|mfdcr
c_func
(paren
id|DCRN_DMACR0
op_plus
(paren
id|dmanr
op_star
l_int|0x8
)paren
)paren
suffix:semicolon
id|control
op_or_assign
id|SET_DMA_PRIORITY
c_func
(paren
id|priority
)paren
suffix:semicolon
id|mtdcr
c_func
(paren
id|DCRN_DMACR0
op_plus
(paren
id|dmanr
op_star
l_int|0x8
)paren
comma
id|control
)paren
suffix:semicolon
r_return
id|DMA_STATUS_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns the width of the peripheral attached to this channel. This assumes&n; * that someone who knows the hardware configuration, boot code or some other&n; * init code, already set the width.&n; *&n; * The return value is one of:&n; *   PW_8&n; *   PW_16&n; *   PW_32&n; *   PW_64&n; *&n; *   The function returns 0 on error.&n; */
r_int
r_int
DECL|function|ppc4xx_get_peripheral_width
id|ppc4xx_get_peripheral_width
c_func
(paren
r_int
r_int
id|dmanr
)paren
(brace
r_int
r_int
id|control
suffix:semicolon
r_if
c_cond
(paren
id|dmanr
op_ge
id|MAX_PPC4xx_DMA_CHANNELS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_get_peripheral_width: bad channel %d&bslash;n&quot;
comma
id|dmanr
)paren
suffix:semicolon
r_return
id|DMA_STATUS_BAD_CHANNEL
suffix:semicolon
)brace
id|control
op_assign
id|mfdcr
c_func
(paren
id|DCRN_DMACR0
op_plus
(paren
id|dmanr
op_star
l_int|0x8
)paren
)paren
suffix:semicolon
r_return
(paren
id|GET_DMA_PW
c_func
(paren
id|control
)paren
)paren
suffix:semicolon
)brace
DECL|variable|ppc4xx_init_dma_channel
id|EXPORT_SYMBOL
c_func
(paren
id|ppc4xx_init_dma_channel
)paren
suffix:semicolon
DECL|variable|ppc4xx_get_channel_config
id|EXPORT_SYMBOL
c_func
(paren
id|ppc4xx_get_channel_config
)paren
suffix:semicolon
DECL|variable|ppc4xx_set_channel_priority
id|EXPORT_SYMBOL
c_func
(paren
id|ppc4xx_set_channel_priority
)paren
suffix:semicolon
DECL|variable|ppc4xx_get_peripheral_width
id|EXPORT_SYMBOL
c_func
(paren
id|ppc4xx_get_peripheral_width
)paren
suffix:semicolon
DECL|variable|dma_channels
id|EXPORT_SYMBOL
c_func
(paren
id|dma_channels
)paren
suffix:semicolon
DECL|variable|ppc4xx_set_src_addr
id|EXPORT_SYMBOL
c_func
(paren
id|ppc4xx_set_src_addr
)paren
suffix:semicolon
DECL|variable|ppc4xx_set_dst_addr
id|EXPORT_SYMBOL
c_func
(paren
id|ppc4xx_set_dst_addr
)paren
suffix:semicolon
DECL|variable|ppc4xx_set_dma_addr
id|EXPORT_SYMBOL
c_func
(paren
id|ppc4xx_set_dma_addr
)paren
suffix:semicolon
DECL|variable|ppc4xx_set_dma_addr2
id|EXPORT_SYMBOL
c_func
(paren
id|ppc4xx_set_dma_addr2
)paren
suffix:semicolon
DECL|variable|ppc4xx_enable_dma
id|EXPORT_SYMBOL
c_func
(paren
id|ppc4xx_enable_dma
)paren
suffix:semicolon
DECL|variable|ppc4xx_disable_dma
id|EXPORT_SYMBOL
c_func
(paren
id|ppc4xx_disable_dma
)paren
suffix:semicolon
DECL|variable|ppc4xx_set_dma_mode
id|EXPORT_SYMBOL
c_func
(paren
id|ppc4xx_set_dma_mode
)paren
suffix:semicolon
DECL|variable|ppc4xx_set_dma_count
id|EXPORT_SYMBOL
c_func
(paren
id|ppc4xx_set_dma_count
)paren
suffix:semicolon
DECL|variable|ppc4xx_get_dma_residue
id|EXPORT_SYMBOL
c_func
(paren
id|ppc4xx_get_dma_residue
)paren
suffix:semicolon
DECL|variable|ppc4xx_enable_dma_interrupt
id|EXPORT_SYMBOL
c_func
(paren
id|ppc4xx_enable_dma_interrupt
)paren
suffix:semicolon
DECL|variable|ppc4xx_disable_dma_interrupt
id|EXPORT_SYMBOL
c_func
(paren
id|ppc4xx_disable_dma_interrupt
)paren
suffix:semicolon
DECL|variable|ppc4xx_get_dma_status
id|EXPORT_SYMBOL
c_func
(paren
id|ppc4xx_get_dma_status
)paren
suffix:semicolon
eof
