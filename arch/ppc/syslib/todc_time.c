multiline_comment|/*&n; * arch/ppc/syslib/todc_time.c&n; *&n; * Time of Day Clock support for the M48T35, M48T37, M48T59, and MC146818&n; * Real Time Clocks/Timekeepers.&n; *&n; * Author: Mark A. Greer&n; *         mgreer@mvista.com&n; *&n; * 2001-2004 (c) MontaVista, Software, Inc.  This file is licensed under&n; * the terms of the GNU General Public License version 2.  This program&n; * is licensed &quot;as is&quot; without any warranty of any kind, whether express&n; * or implied.&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &lt;linux/bcd.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/time.h&gt;
macro_line|#include &lt;asm/todc.h&gt;
multiline_comment|/*&n; * Depending on the hardware on your board and your board design, the&n; * RTC/NVRAM may be accessed either directly (like normal memory) or via&n; * address/data registers.  If your board uses the direct method, set&n; * &squot;nvram_data&squot; to the base address of your nvram and leave &squot;nvram_as0&squot; and&n; * &squot;nvram_as1&squot; NULL.  If your board uses address/data regs to access nvram,&n; * set &squot;nvram_as0&squot; to the address of the lower byte, set &squot;nvram_as1&squot; to the&n; * address of the upper byte (leave NULL if using mc146818), and set&n; * &squot;nvram_data&squot; to the address of the 8-bit data register.&n; *&n; * In order to break the assumption that the RTC and NVRAM are accessed by&n; * the same mechanism, you need to explicitly set &squot;ppc_md.rtc_read_val&squot; and&n; * &squot;ppc_md.rtc_write_val&squot;, otherwise the values of &squot;ppc_md.rtc_read_val&squot;&n; * and &squot;ppc_md.rtc_write_val&squot; will be used.&n; *&n; * Note: Even though the documentation for the various RTC chips say that it&n; * &t; take up to a second before it starts updating once the &squot;R&squot; bit is&n; * &t; cleared, they always seem to update even though we bang on it many&n; * &t; times a second.  This is true, except for the Dallas Semi 1746/1747&n; * &t; (possibly others).  Those chips seem to have a real problem whenever&n; * &t; we set the &squot;R&squot; bit before reading them, they basically stop counting.&n; * &t; &t;&t;&t;&t;&t;--MAG&n; */
r_extern
id|spinlock_t
id|rtc_lock
suffix:semicolon
multiline_comment|/*&n; * &squot;todc_info&squot; should be initialized in your *_setup.c file to&n; * point to a fully initialized &squot;todc_info_t&squot; structure.&n; * This structure holds all the register offsets for your particular&n; * TODC/RTC chip.&n; * TODC_ALLOC()/TODC_INIT() will allocate and initialize this table for you.&n; */
macro_line|#ifdef&t;RTC_FREQ_SELECT
DECL|macro|RTC_FREQ_SELECT
macro_line|#undef&t;RTC_FREQ_SELECT
DECL|macro|RTC_FREQ_SELECT
mdefine_line|#define&t;RTC_FREQ_SELECT&t;&t;control_b&t;/* Register A */
macro_line|#endif
macro_line|#ifdef&t;RTC_CONTROL
DECL|macro|RTC_CONTROL
macro_line|#undef&t;RTC_CONTROL
DECL|macro|RTC_CONTROL
mdefine_line|#define&t;RTC_CONTROL&t;&t;control_a&t;/* Register B */
macro_line|#endif
macro_line|#ifdef&t;RTC_INTR_FLAGS
DECL|macro|RTC_INTR_FLAGS
macro_line|#undef&t;RTC_INTR_FLAGS
DECL|macro|RTC_INTR_FLAGS
mdefine_line|#define&t;RTC_INTR_FLAGS&t;&t;watchdog&t;/* Register C */
macro_line|#endif
macro_line|#ifdef&t;RTC_VALID
DECL|macro|RTC_VALID
macro_line|#undef&t;RTC_VALID
DECL|macro|RTC_VALID
mdefine_line|#define&t;RTC_VALID&t;&t;interrupts&t;/* Register D */
macro_line|#endif
multiline_comment|/* Access routines when RTC accessed directly (like normal memory) */
id|u_char
DECL|function|todc_direct_read_val
id|todc_direct_read_val
c_func
(paren
r_int
id|addr
)paren
(brace
r_return
id|readb
c_func
(paren
id|todc_info-&gt;nvram_data
op_plus
id|addr
)paren
suffix:semicolon
)brace
r_void
DECL|function|todc_direct_write_val
id|todc_direct_write_val
c_func
(paren
r_int
id|addr
comma
r_int
r_char
id|val
)paren
(brace
id|writeb
c_func
(paren
id|val
comma
id|todc_info-&gt;nvram_data
op_plus
id|addr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Access routines for accessing m48txx type chips via addr/data regs */
id|u_char
DECL|function|todc_m48txx_read_val
id|todc_m48txx_read_val
c_func
(paren
r_int
id|addr
)paren
(brace
id|outb
c_func
(paren
id|addr
comma
id|todc_info-&gt;nvram_as0
)paren
suffix:semicolon
id|outb
c_func
(paren
id|addr
op_rshift
id|todc_info-&gt;as0_bits
comma
id|todc_info-&gt;nvram_as1
)paren
suffix:semicolon
r_return
id|inb
c_func
(paren
id|todc_info-&gt;nvram_data
)paren
suffix:semicolon
)brace
r_void
DECL|function|todc_m48txx_write_val
id|todc_m48txx_write_val
c_func
(paren
r_int
id|addr
comma
r_int
r_char
id|val
)paren
(brace
id|outb
c_func
(paren
id|addr
comma
id|todc_info-&gt;nvram_as0
)paren
suffix:semicolon
id|outb
c_func
(paren
id|addr
op_rshift
id|todc_info-&gt;as0_bits
comma
id|todc_info-&gt;nvram_as1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|val
comma
id|todc_info-&gt;nvram_data
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Access routines for accessing mc146818 type chips via addr/data regs */
id|u_char
DECL|function|todc_mc146818_read_val
id|todc_mc146818_read_val
c_func
(paren
r_int
id|addr
)paren
(brace
id|outb_p
c_func
(paren
id|addr
comma
id|todc_info-&gt;nvram_as0
)paren
suffix:semicolon
r_return
id|inb_p
c_func
(paren
id|todc_info-&gt;nvram_data
)paren
suffix:semicolon
)brace
r_void
DECL|function|todc_mc146818_write_val
id|todc_mc146818_write_val
c_func
(paren
r_int
id|addr
comma
r_int
r_char
id|val
)paren
(brace
id|outb_p
c_func
(paren
id|addr
comma
id|todc_info-&gt;nvram_as0
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|val
comma
id|todc_info-&gt;nvram_data
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Routines to make RTC chips with NVRAM buried behind an addr/data pair&n; * have the NVRAM and clock regs appear at the same level.&n; * The NVRAM will appear to start at addr 0 and the clock regs will appear&n; * to start immediately after the NVRAM (actually, start at offset&n; * todc_info-&gt;nvram_size).&n; */
r_static
r_inline
id|u_char
DECL|function|todc_read_val
id|todc_read_val
c_func
(paren
r_int
id|addr
)paren
(brace
id|u_char
id|val
suffix:semicolon
r_if
c_cond
(paren
id|todc_info-&gt;sw_flags
op_amp
id|TODC_FLAG_2_LEVEL_NVRAM
)paren
(brace
r_if
c_cond
(paren
id|addr
OL
id|todc_info-&gt;nvram_size
)paren
(brace
multiline_comment|/* NVRAM */
id|ppc_md
dot
id|rtc_write_val
c_func
(paren
id|todc_info-&gt;nvram_addr_reg
comma
id|addr
)paren
suffix:semicolon
id|val
op_assign
id|ppc_md
dot
id|rtc_read_val
c_func
(paren
id|todc_info-&gt;nvram_data_reg
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Clock Reg */
id|addr
op_sub_assign
id|todc_info-&gt;nvram_size
suffix:semicolon
id|val
op_assign
id|ppc_md
dot
id|rtc_read_val
c_func
(paren
id|addr
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|val
op_assign
id|ppc_md
dot
id|rtc_read_val
c_func
(paren
id|addr
)paren
suffix:semicolon
)brace
r_return
id|val
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|todc_write_val
id|todc_write_val
c_func
(paren
r_int
id|addr
comma
id|u_char
id|val
)paren
(brace
r_if
c_cond
(paren
id|todc_info-&gt;sw_flags
op_amp
id|TODC_FLAG_2_LEVEL_NVRAM
)paren
(brace
r_if
c_cond
(paren
id|addr
OL
id|todc_info-&gt;nvram_size
)paren
(brace
multiline_comment|/* NVRAM */
id|ppc_md
dot
id|rtc_write_val
c_func
(paren
id|todc_info-&gt;nvram_addr_reg
comma
id|addr
)paren
suffix:semicolon
id|ppc_md
dot
id|rtc_write_val
c_func
(paren
id|todc_info-&gt;nvram_data_reg
comma
id|val
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Clock Reg */
id|addr
op_sub_assign
id|todc_info-&gt;nvram_size
suffix:semicolon
id|ppc_md
dot
id|rtc_write_val
c_func
(paren
id|addr
comma
id|val
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|ppc_md
dot
id|rtc_write_val
c_func
(paren
id|addr
comma
id|val
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * TODC routines&n; *&n; * There is some ugly stuff in that there are assumptions for the mc146818.&n; *&n; * Assumptions:&n; *&t;- todc_info-&gt;control_a has the offset as mc146818 Register B reg&n; *&t;- todc_info-&gt;control_b has the offset as mc146818 Register A reg&n; *&t;- m48txx control reg&squot;s write enable or &squot;W&squot; bit is same as&n; *&t;  mc146818 Register B &squot;SET&squot; bit (i.e., 0x80)&n; *&n; * These assumptions were made to make the code simpler.&n; */
r_int
id|__init
DECL|function|todc_time_init
id|todc_time_init
c_func
(paren
r_void
)paren
(brace
id|u_char
id|cntl_b
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ppc_md.rtc_read_val
)paren
id|ppc_md.rtc_read_val
op_assign
id|ppc_md.nvram_read_val
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ppc_md.rtc_write_val
)paren
id|ppc_md.rtc_write_val
op_assign
id|ppc_md.nvram_write_val
suffix:semicolon
id|cntl_b
op_assign
id|todc_read_val
c_func
(paren
id|todc_info-&gt;control_b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|todc_info-&gt;rtc_type
op_eq
id|TODC_TYPE_MC146818
)paren
(brace
r_if
c_cond
(paren
(paren
id|cntl_b
op_amp
l_int|0x70
)paren
op_ne
l_int|0x20
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;TODC %s %s&bslash;n&quot;
comma
l_string|&quot;real-time-clock was stopped.&quot;
comma
l_string|&quot;Now starting...&quot;
)paren
suffix:semicolon
id|cntl_b
op_and_assign
op_complement
l_int|0x70
suffix:semicolon
id|cntl_b
op_or_assign
l_int|0x20
suffix:semicolon
)brace
id|todc_write_val
c_func
(paren
id|todc_info-&gt;control_b
comma
id|cntl_b
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|todc_info-&gt;rtc_type
op_eq
id|TODC_TYPE_DS17285
)paren
(brace
id|u_char
id|mode
suffix:semicolon
id|mode
op_assign
id|todc_read_val
c_func
(paren
id|TODC_TYPE_DS17285_CNTL_A
)paren
suffix:semicolon
multiline_comment|/* Make sure countdown clear is not set */
id|mode
op_and_assign
op_complement
l_int|0x40
suffix:semicolon
multiline_comment|/* Enable oscillator, extended register set */
id|mode
op_or_assign
l_int|0x30
suffix:semicolon
id|todc_write_val
c_func
(paren
id|TODC_TYPE_DS17285_CNTL_A
comma
id|mode
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|todc_info-&gt;rtc_type
op_eq
id|TODC_TYPE_DS1501
)paren
(brace
id|u_char
id|month
suffix:semicolon
id|todc_info-&gt;enable_read
op_assign
id|TODC_DS1501_CNTL_B_TE
suffix:semicolon
id|todc_info-&gt;enable_write
op_assign
id|TODC_DS1501_CNTL_B_TE
suffix:semicolon
id|month
op_assign
id|todc_read_val
c_func
(paren
id|todc_info-&gt;month
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|month
op_amp
l_int|0x80
)paren
op_eq
l_int|0x80
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;TODC %s %s&bslash;n&quot;
comma
l_string|&quot;real-time-clock was stopped.&quot;
comma
l_string|&quot;Now starting...&quot;
)paren
suffix:semicolon
id|month
op_and_assign
op_complement
l_int|0x80
suffix:semicolon
id|todc_write_val
c_func
(paren
id|todc_info-&gt;month
comma
id|month
)paren
suffix:semicolon
)brace
id|cntl_b
op_and_assign
op_complement
id|TODC_DS1501_CNTL_B_TE
suffix:semicolon
id|todc_write_val
c_func
(paren
id|todc_info-&gt;control_b
comma
id|cntl_b
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* must be a m48txx type */
id|u_char
id|cntl_a
suffix:semicolon
id|todc_info-&gt;enable_read
op_assign
id|TODC_MK48TXX_CNTL_A_R
suffix:semicolon
id|todc_info-&gt;enable_write
op_assign
id|TODC_MK48TXX_CNTL_A_W
suffix:semicolon
id|cntl_a
op_assign
id|todc_read_val
c_func
(paren
id|todc_info-&gt;control_a
)paren
suffix:semicolon
multiline_comment|/* Check &amp; clear STOP bit in control B register */
r_if
c_cond
(paren
id|cntl_b
op_amp
id|TODC_MK48TXX_DAY_CB
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;TODC %s %s&bslash;n&quot;
comma
l_string|&quot;real-time-clock was stopped.&quot;
comma
l_string|&quot;Now starting...&quot;
)paren
suffix:semicolon
id|cntl_a
op_or_assign
id|todc_info-&gt;enable_write
suffix:semicolon
id|cntl_b
op_and_assign
op_complement
id|TODC_MK48TXX_DAY_CB
suffix:semicolon
multiline_comment|/* Start Oscil */
id|todc_write_val
c_func
(paren
id|todc_info-&gt;control_a
comma
id|cntl_a
)paren
suffix:semicolon
id|todc_write_val
c_func
(paren
id|todc_info-&gt;control_b
comma
id|cntl_b
)paren
suffix:semicolon
)brace
multiline_comment|/* Make sure READ &amp; WRITE bits are cleared. */
id|cntl_a
op_and_assign
op_complement
(paren
id|todc_info-&gt;enable_write
op_or
id|todc_info-&gt;enable_read
)paren
suffix:semicolon
id|todc_write_val
c_func
(paren
id|todc_info-&gt;control_a
comma
id|cntl_a
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * There is some ugly stuff in that there are assumptions that for a mc146818,&n; * the todc_info-&gt;control_a has the offset of the mc146818 Register B reg and&n; * that the register&squot;ss &squot;SET&squot; bit is the same as the m48txx&squot;s write enable&n; * bit in the control register of the m48txx (i.e., 0x80).&n; *&n; * It was done to make the code look simpler.&n; */
id|ulong
DECL|function|todc_get_rtc_time
id|todc_get_rtc_time
c_func
(paren
r_void
)paren
(brace
id|uint
id|year
comma
id|mon
comma
id|day
comma
id|hour
comma
id|min
comma
id|sec
suffix:semicolon
id|uint
id|limit
comma
id|i
suffix:semicolon
id|u_char
id|save_control
comma
id|uip
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|save_control
op_assign
id|todc_read_val
c_func
(paren
id|todc_info-&gt;control_a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|todc_info-&gt;rtc_type
op_ne
id|TODC_TYPE_MC146818
)paren
(brace
id|limit
op_assign
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|todc_info-&gt;rtc_type
)paren
(brace
r_case
id|TODC_TYPE_DS1557
suffix:colon
r_case
id|TODC_TYPE_DS1743
suffix:colon
r_case
id|TODC_TYPE_DS1746
suffix:colon
multiline_comment|/* XXXX BAD HACK -&gt; FIX */
r_case
id|TODC_TYPE_DS1747
suffix:colon
r_case
id|TODC_TYPE_DS17285
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|todc_write_val
c_func
(paren
id|todc_info-&gt;control_a
comma
(paren
id|save_control
op_or
id|todc_info-&gt;enable_read
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|limit
op_assign
l_int|100000000
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|limit
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|todc_info-&gt;rtc_type
op_eq
id|TODC_TYPE_MC146818
)paren
(brace
id|uip
op_assign
id|todc_read_val
c_func
(paren
id|todc_info-&gt;RTC_FREQ_SELECT
)paren
suffix:semicolon
)brace
id|sec
op_assign
id|todc_read_val
c_func
(paren
id|todc_info-&gt;seconds
)paren
op_amp
l_int|0x7f
suffix:semicolon
id|min
op_assign
id|todc_read_val
c_func
(paren
id|todc_info-&gt;minutes
)paren
op_amp
l_int|0x7f
suffix:semicolon
id|hour
op_assign
id|todc_read_val
c_func
(paren
id|todc_info-&gt;hours
)paren
op_amp
l_int|0x3f
suffix:semicolon
id|day
op_assign
id|todc_read_val
c_func
(paren
id|todc_info-&gt;day_of_month
)paren
op_amp
l_int|0x3f
suffix:semicolon
id|mon
op_assign
id|todc_read_val
c_func
(paren
id|todc_info-&gt;month
)paren
op_amp
l_int|0x1f
suffix:semicolon
id|year
op_assign
id|todc_read_val
c_func
(paren
id|todc_info-&gt;year
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|todc_info-&gt;rtc_type
op_eq
id|TODC_TYPE_MC146818
)paren
(brace
id|uip
op_or_assign
id|todc_read_val
c_func
(paren
id|todc_info-&gt;RTC_FREQ_SELECT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|uip
op_amp
id|RTC_UIP
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|todc_info-&gt;rtc_type
op_ne
id|TODC_TYPE_MC146818
)paren
(brace
r_switch
c_cond
(paren
id|todc_info-&gt;rtc_type
)paren
(brace
r_case
id|TODC_TYPE_DS1557
suffix:colon
r_case
id|TODC_TYPE_DS1743
suffix:colon
r_case
id|TODC_TYPE_DS1746
suffix:colon
multiline_comment|/* XXXX BAD HACK -&gt; FIX */
r_case
id|TODC_TYPE_DS1747
suffix:colon
r_case
id|TODC_TYPE_DS17285
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|save_control
op_and_assign
op_complement
(paren
id|todc_info-&gt;enable_read
)paren
suffix:semicolon
id|todc_write_val
c_func
(paren
id|todc_info-&gt;control_a
comma
id|save_control
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|todc_info-&gt;rtc_type
op_ne
id|TODC_TYPE_MC146818
)paren
op_logical_or
(paren
(paren
id|save_control
op_amp
id|RTC_DM_BINARY
)paren
op_eq
l_int|0
)paren
op_logical_or
id|RTC_ALWAYS_BCD
)paren
(brace
id|BCD_TO_BIN
c_func
(paren
id|sec
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|min
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|hour
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|day
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|mon
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|year
)paren
suffix:semicolon
)brace
id|year
op_assign
id|year
op_plus
l_int|1900
suffix:semicolon
r_if
c_cond
(paren
id|year
OL
l_int|1970
)paren
(brace
id|year
op_add_assign
l_int|100
suffix:semicolon
)brace
r_return
id|mktime
c_func
(paren
id|year
comma
id|mon
comma
id|day
comma
id|hour
comma
id|min
comma
id|sec
)paren
suffix:semicolon
)brace
r_int
DECL|function|todc_set_rtc_time
id|todc_set_rtc_time
c_func
(paren
r_int
r_int
id|nowtime
)paren
(brace
r_struct
id|rtc_time
id|tm
suffix:semicolon
id|u_char
id|save_control
comma
id|save_freq_select
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|to_tm
c_func
(paren
id|nowtime
comma
op_amp
id|tm
)paren
suffix:semicolon
id|save_control
op_assign
id|todc_read_val
c_func
(paren
id|todc_info-&gt;control_a
)paren
suffix:semicolon
multiline_comment|/* Assuming MK48T59_RTC_CA_WRITE &amp; RTC_SET are equal */
id|todc_write_val
c_func
(paren
id|todc_info-&gt;control_a
comma
(paren
id|save_control
op_or
id|todc_info-&gt;enable_write
)paren
)paren
suffix:semicolon
id|save_control
op_and_assign
op_complement
(paren
id|todc_info-&gt;enable_write
)paren
suffix:semicolon
multiline_comment|/* in case it was set */
r_if
c_cond
(paren
id|todc_info-&gt;rtc_type
op_eq
id|TODC_TYPE_MC146818
)paren
(brace
id|save_freq_select
op_assign
id|todc_read_val
c_func
(paren
id|todc_info-&gt;RTC_FREQ_SELECT
)paren
suffix:semicolon
id|todc_write_val
c_func
(paren
id|todc_info-&gt;RTC_FREQ_SELECT
comma
id|save_freq_select
op_or
id|RTC_DIV_RESET2
)paren
suffix:semicolon
)brace
id|tm.tm_year
op_assign
(paren
id|tm.tm_year
op_minus
l_int|1900
)paren
op_mod
l_int|100
suffix:semicolon
r_if
c_cond
(paren
(paren
id|todc_info-&gt;rtc_type
op_ne
id|TODC_TYPE_MC146818
)paren
op_logical_or
(paren
(paren
id|save_control
op_amp
id|RTC_DM_BINARY
)paren
op_eq
l_int|0
)paren
op_logical_or
id|RTC_ALWAYS_BCD
)paren
(brace
id|BIN_TO_BCD
c_func
(paren
id|tm.tm_sec
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|tm.tm_min
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|tm.tm_hour
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|tm.tm_mon
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|tm.tm_mday
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|tm.tm_year
)paren
suffix:semicolon
)brace
id|todc_write_val
c_func
(paren
id|todc_info-&gt;seconds
comma
id|tm.tm_sec
)paren
suffix:semicolon
id|todc_write_val
c_func
(paren
id|todc_info-&gt;minutes
comma
id|tm.tm_min
)paren
suffix:semicolon
id|todc_write_val
c_func
(paren
id|todc_info-&gt;hours
comma
id|tm.tm_hour
)paren
suffix:semicolon
id|todc_write_val
c_func
(paren
id|todc_info-&gt;month
comma
id|tm.tm_mon
)paren
suffix:semicolon
id|todc_write_val
c_func
(paren
id|todc_info-&gt;day_of_month
comma
id|tm.tm_mday
)paren
suffix:semicolon
id|todc_write_val
c_func
(paren
id|todc_info-&gt;year
comma
id|tm.tm_year
)paren
suffix:semicolon
id|todc_write_val
c_func
(paren
id|todc_info-&gt;control_a
comma
id|save_control
)paren
suffix:semicolon
r_if
c_cond
(paren
id|todc_info-&gt;rtc_type
op_eq
id|TODC_TYPE_MC146818
)paren
(brace
id|todc_write_val
c_func
(paren
id|todc_info-&gt;RTC_FREQ_SELECT
comma
id|save_freq_select
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Manipulates read bit to reliably read seconds at a high rate.&n; */
DECL|function|todc_read_timereg
r_static
r_int
r_char
id|__init
id|todc_read_timereg
c_func
(paren
r_int
id|addr
)paren
(brace
r_int
r_char
id|save_control
comma
id|val
suffix:semicolon
r_switch
c_cond
(paren
id|todc_info-&gt;rtc_type
)paren
(brace
r_case
id|TODC_TYPE_DS1557
suffix:colon
r_case
id|TODC_TYPE_DS1746
suffix:colon
multiline_comment|/* XXXX BAD HACK -&gt; FIX */
r_case
id|TODC_TYPE_DS1747
suffix:colon
r_case
id|TODC_TYPE_DS17285
suffix:colon
r_case
id|TODC_TYPE_MC146818
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|save_control
op_assign
id|todc_read_val
c_func
(paren
id|todc_info-&gt;control_a
)paren
suffix:semicolon
id|todc_write_val
c_func
(paren
id|todc_info-&gt;control_a
comma
(paren
id|save_control
op_or
id|todc_info-&gt;enable_read
)paren
)paren
suffix:semicolon
)brace
id|val
op_assign
id|todc_read_val
c_func
(paren
id|addr
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|todc_info-&gt;rtc_type
)paren
(brace
r_case
id|TODC_TYPE_DS1557
suffix:colon
r_case
id|TODC_TYPE_DS1746
suffix:colon
multiline_comment|/* XXXX BAD HACK -&gt; FIX */
r_case
id|TODC_TYPE_DS1747
suffix:colon
r_case
id|TODC_TYPE_DS17285
suffix:colon
r_case
id|TODC_TYPE_MC146818
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|save_control
op_and_assign
op_complement
(paren
id|todc_info-&gt;enable_read
)paren
suffix:semicolon
id|todc_write_val
c_func
(paren
id|todc_info-&gt;control_a
comma
id|save_control
)paren
suffix:semicolon
)brace
r_return
id|val
suffix:semicolon
)brace
multiline_comment|/*&n; * This was taken from prep_setup.c&n; * Use the NVRAM RTC to time a second to calibrate the decrementer.&n; */
r_void
id|__init
DECL|function|todc_calibrate_decr
id|todc_calibrate_decr
c_func
(paren
r_void
)paren
(brace
id|ulong
id|freq
suffix:semicolon
id|ulong
id|tbl
comma
id|tbu
suffix:semicolon
r_int
id|i
comma
id|loop_count
suffix:semicolon
id|u_char
id|sec
suffix:semicolon
id|todc_time_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Actually this is bad for precision, we should have a loop in&n;&t; * which we only read the seconds counter. todc_read_val writes&n;&t; * the address bytes on every call and this takes a lot of time.&n;&t; * Perhaps an nvram_wait_change method returning a time&n;&t; * stamp with a loop count as parameter would be the solution.&n;&t; */
multiline_comment|/*&n;&t; * Need to make sure the tbl doesn&squot;t roll over so if tbu increments&n;&t; * during this test, we need to do it again.&n;&t; */
id|loop_count
op_assign
l_int|0
suffix:semicolon
id|sec
op_assign
id|todc_read_timereg
c_func
(paren
id|todc_info-&gt;seconds
)paren
op_amp
l_int|0x7f
suffix:semicolon
r_do
(brace
id|tbu
op_assign
id|get_tbu
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10000000
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* may take up to 1 second */
id|tbl
op_assign
id|get_tbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|todc_read_timereg
c_func
(paren
id|todc_info-&gt;seconds
)paren
op_amp
l_int|0x7f
)paren
op_ne
id|sec
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|sec
op_assign
id|todc_read_timereg
c_func
(paren
id|todc_info-&gt;seconds
)paren
op_amp
l_int|0x7f
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10000000
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Should take 1 second */
id|freq
op_assign
id|get_tbl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|todc_read_timereg
c_func
(paren
id|todc_info-&gt;seconds
)paren
op_amp
l_int|0x7f
)paren
op_ne
id|sec
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|freq
op_sub_assign
id|tbl
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|get_tbu
c_func
(paren
)paren
op_ne
id|tbu
)paren
op_logical_and
(paren
op_increment
id|loop_count
OL
l_int|2
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;time_init: decrementer frequency = %lu.%.6lu MHz&bslash;n&quot;
comma
id|freq
op_div
l_int|1000000
comma
id|freq
op_mod
l_int|1000000
)paren
suffix:semicolon
id|tb_ticks_per_jiffy
op_assign
id|freq
op_div
id|HZ
suffix:semicolon
id|tb_to_us
op_assign
id|mulhwu_scale_factor
c_func
(paren
id|freq
comma
l_int|1000000
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
eof
