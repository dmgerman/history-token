multiline_comment|/*&n; * arch/ppc/kernel/ppc4xx_sgdma.c&n; *&n; * IBM PPC4xx DMA engine scatter/gather library&n; *&n; * Copyright 2002-2003 MontaVista Software Inc.&n; *&n; * Cleaned up and converted to new DCR access&n; * Matt Porter &lt;mporter@kernel.crashing.org&gt;&n; *&n; * Original code by Armin Kuster &lt;akuster@mvista.com&gt;&n; * and Pete Popov &lt;ppopov@mvista.com&gt;&n; *&n; * This program is free software; you can redistribute  it and/or modify it&n; * under  the terms of  the GNU General  Public License as published by the&n; * Free Software Foundation;  either version 2 of the  License, or (at your&n; * option) any later version.&n; *&n; * You should have received a copy of the  GNU General Public License along&n; * with this program; if not, write  to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/ppc4xx_dma.h&gt;
r_void
DECL|function|ppc4xx_set_sg_addr
id|ppc4xx_set_sg_addr
c_func
(paren
r_int
id|dmanr
comma
id|phys_addr_t
id|sg_addr
)paren
(brace
r_if
c_cond
(paren
id|dmanr
op_ge
id|MAX_PPC4xx_DMA_CHANNELS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_set_sg_addr: bad channel: %d&bslash;n&quot;
comma
id|dmanr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef PPC4xx_DMA_64BIT
id|mtdcr
c_func
(paren
id|DCRN_ASGH0
op_plus
(paren
id|dmanr
op_star
l_int|0x8
)paren
comma
(paren
id|u32
)paren
(paren
id|sg_addr
op_rshift
l_int|32
)paren
)paren
suffix:semicolon
macro_line|#endif
id|mtdcr
c_func
(paren
id|DCRN_ASG0
op_plus
(paren
id|dmanr
op_star
l_int|0x8
)paren
comma
(paren
id|u32
)paren
id|sg_addr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *   Add a new sgl descriptor to the end of a scatter/gather list&n; *   which was created by alloc_dma_handle().&n; *&n; *   For a memory to memory transfer, both dma addresses must be&n; *   valid. For a peripheral to memory transfer, one of the addresses&n; *   must be set to NULL, depending on the direction of the transfer:&n; *   memory to peripheral: set dst_addr to NULL,&n; *   peripheral to memory: set src_addr to NULL.&n; */
r_int
DECL|function|ppc4xx_add_dma_sgl
id|ppc4xx_add_dma_sgl
c_func
(paren
id|sgl_handle_t
id|handle
comma
id|phys_addr_t
id|src_addr
comma
id|phys_addr_t
id|dst_addr
comma
r_int
r_int
id|count
)paren
(brace
id|sgl_list_info_t
op_star
id|psgl
op_assign
(paren
id|sgl_list_info_t
op_star
)paren
id|handle
suffix:semicolon
id|ppc_dma_ch_t
op_star
id|p_dma_ch
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_add_dma_sgl: null handle&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|DMA_STATUS_BAD_HANDLE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|psgl-&gt;dmanr
op_ge
id|MAX_PPC4xx_DMA_CHANNELS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_add_dma_sgl: bad channel: %d&bslash;n&quot;
comma
id|psgl-&gt;dmanr
)paren
suffix:semicolon
r_return
id|DMA_STATUS_BAD_CHANNEL
suffix:semicolon
)brace
id|p_dma_ch
op_assign
op_amp
id|dma_channels
(braket
id|psgl-&gt;dmanr
)braket
suffix:semicolon
macro_line|#ifdef DEBUG_4xxDMA
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|aligned
op_assign
(paren
r_int
)paren
id|src_addr
op_or
(paren
r_int
)paren
id|dst_addr
op_or
id|count
suffix:semicolon
r_switch
c_cond
(paren
id|p_dma_ch-&gt;pwidth
)paren
(brace
r_case
id|PW_8
suffix:colon
r_break
suffix:semicolon
r_case
id|PW_16
suffix:colon
r_if
c_cond
(paren
id|aligned
op_amp
l_int|0x1
)paren
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PW_32
suffix:colon
r_if
c_cond
(paren
id|aligned
op_amp
l_int|0x3
)paren
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PW_64
suffix:colon
r_if
c_cond
(paren
id|aligned
op_amp
l_int|0x7
)paren
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ppc4xx_add_dma_sgl: invalid bus width: 0x%x&bslash;n&quot;
comma
id|p_dma_ch-&gt;pwidth
)paren
suffix:semicolon
r_return
id|DMA_STATUS_GENERAL_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
id|printk
(paren
l_string|&quot;Alignment warning: ppc4xx_add_dma_sgl src 0x%x dst 0x%x count 0x%x bus width var %d&bslash;n&quot;
comma
id|src_addr
comma
id|dst_addr
comma
id|count
comma
id|p_dma_ch-&gt;pwidth
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|psgl-&gt;ptail
op_plus
l_int|1
)paren
op_ge
(paren
(paren
r_int
)paren
id|psgl
op_plus
id|SGL_LIST_SIZE
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sgl handle out of memory &bslash;n&quot;
)paren
suffix:semicolon
r_return
id|DMA_STATUS_OUT_OF_MEMORY
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|psgl-&gt;ptail
)paren
(brace
id|psgl-&gt;phead
op_assign
(paren
id|ppc_sgl_t
op_star
)paren
(paren
(paren
r_int
)paren
id|psgl
op_plus
r_sizeof
(paren
id|sgl_list_info_t
)paren
)paren
suffix:semicolon
id|psgl-&gt;phead_dma
op_assign
id|psgl-&gt;dma_addr
op_plus
r_sizeof
(paren
id|sgl_list_info_t
)paren
suffix:semicolon
id|psgl-&gt;ptail
op_assign
id|psgl-&gt;phead
suffix:semicolon
id|psgl-&gt;ptail_dma
op_assign
id|psgl-&gt;phead_dma
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|p_dma_ch-&gt;int_on_final_sg
)paren
(brace
multiline_comment|/* mask out all dma interrupts, except error, on tail&n;&t;&t;&t;before adding new tail. */
id|psgl-&gt;ptail-&gt;control_count
op_and_assign
op_complement
(paren
id|SG_TCI_ENABLE
op_or
id|SG_ETI_ENABLE
)paren
suffix:semicolon
)brace
id|psgl-&gt;ptail-&gt;next
op_assign
id|psgl-&gt;ptail_dma
op_plus
r_sizeof
(paren
id|ppc_sgl_t
)paren
suffix:semicolon
id|psgl-&gt;ptail
op_increment
suffix:semicolon
id|psgl-&gt;ptail_dma
op_add_assign
r_sizeof
(paren
id|ppc_sgl_t
)paren
suffix:semicolon
)brace
id|psgl-&gt;ptail-&gt;control
op_assign
id|psgl-&gt;control
suffix:semicolon
id|psgl-&gt;ptail-&gt;src_addr
op_assign
id|src_addr
suffix:semicolon
id|psgl-&gt;ptail-&gt;dst_addr
op_assign
id|dst_addr
suffix:semicolon
id|psgl-&gt;ptail-&gt;control_count
op_assign
(paren
id|count
op_rshift
id|p_dma_ch-&gt;shift
)paren
op_or
id|psgl-&gt;sgl_control
suffix:semicolon
id|psgl-&gt;ptail-&gt;next
op_assign
(paren
r_uint32
)paren
l_int|NULL
suffix:semicolon
r_return
id|DMA_STATUS_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; * Enable (start) the DMA described by the sgl handle.&n; */
r_void
DECL|function|ppc4xx_enable_dma_sgl
id|ppc4xx_enable_dma_sgl
c_func
(paren
id|sgl_handle_t
id|handle
)paren
(brace
id|sgl_list_info_t
op_star
id|psgl
op_assign
(paren
id|sgl_list_info_t
op_star
)paren
id|handle
suffix:semicolon
id|ppc_dma_ch_t
op_star
id|p_dma_ch
suffix:semicolon
r_uint32
id|sg_command
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_enable_dma_sgl: null handle&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|psgl-&gt;dmanr
OG
(paren
id|MAX_PPC4xx_DMA_CHANNELS
op_minus
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_enable_dma_sgl: bad channel in handle %d&bslash;n&quot;
comma
id|psgl-&gt;dmanr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|psgl-&gt;phead
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_enable_dma_sgl: sg list empty&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|p_dma_ch
op_assign
op_amp
id|dma_channels
(braket
id|psgl-&gt;dmanr
)braket
suffix:semicolon
id|psgl-&gt;ptail-&gt;control_count
op_and_assign
op_complement
id|SG_LINK
suffix:semicolon
multiline_comment|/* make this the last dscrptr */
id|sg_command
op_assign
id|mfdcr
c_func
(paren
id|DCRN_ASGC
)paren
suffix:semicolon
id|ppc4xx_set_sg_addr
c_func
(paren
id|psgl-&gt;dmanr
comma
id|psgl-&gt;phead_dma
)paren
suffix:semicolon
id|sg_command
op_or_assign
id|SSG_ENABLE
c_func
(paren
id|psgl-&gt;dmanr
)paren
suffix:semicolon
id|mtdcr
c_func
(paren
id|DCRN_ASGC
comma
id|sg_command
)paren
suffix:semicolon
multiline_comment|/* start transfer */
)brace
multiline_comment|/*&n; * Halt an active scatter/gather DMA operation.&n; */
r_void
DECL|function|ppc4xx_disable_dma_sgl
id|ppc4xx_disable_dma_sgl
c_func
(paren
id|sgl_handle_t
id|handle
)paren
(brace
id|sgl_list_info_t
op_star
id|psgl
op_assign
(paren
id|sgl_list_info_t
op_star
)paren
id|handle
suffix:semicolon
r_uint32
id|sg_command
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_enable_dma_sgl: null handle&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|psgl-&gt;dmanr
OG
(paren
id|MAX_PPC4xx_DMA_CHANNELS
op_minus
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_enable_dma_sgl: bad channel in handle %d&bslash;n&quot;
comma
id|psgl-&gt;dmanr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sg_command
op_assign
id|mfdcr
c_func
(paren
id|DCRN_ASGC
)paren
suffix:semicolon
id|sg_command
op_and_assign
op_complement
id|SSG_ENABLE
c_func
(paren
id|psgl-&gt;dmanr
)paren
suffix:semicolon
id|mtdcr
c_func
(paren
id|DCRN_ASGC
comma
id|sg_command
)paren
suffix:semicolon
multiline_comment|/* stop transfer */
)brace
multiline_comment|/*&n; *  Returns number of bytes left to be transferred from the entire sgl list.&n; *  *src_addr and *dst_addr get set to the source/destination address of&n; *  the sgl descriptor where the DMA stopped.&n; *&n; *  An sgl transfer must NOT be active when this function is called.&n; */
r_int
DECL|function|ppc4xx_get_dma_sgl_residue
id|ppc4xx_get_dma_sgl_residue
c_func
(paren
id|sgl_handle_t
id|handle
comma
id|phys_addr_t
op_star
id|src_addr
comma
id|phys_addr_t
op_star
id|dst_addr
)paren
(brace
id|sgl_list_info_t
op_star
id|psgl
op_assign
(paren
id|sgl_list_info_t
op_star
)paren
id|handle
suffix:semicolon
id|ppc_dma_ch_t
op_star
id|p_dma_ch
suffix:semicolon
id|ppc_sgl_t
op_star
id|pnext
comma
op_star
id|sgl_addr
suffix:semicolon
r_uint32
id|count_left
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_get_dma_sgl_residue: null handle&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|DMA_STATUS_BAD_HANDLE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|psgl-&gt;dmanr
OG
(paren
id|MAX_PPC4xx_DMA_CHANNELS
op_minus
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_get_dma_sgl_residue: bad channel in handle %d&bslash;n&quot;
comma
id|psgl-&gt;dmanr
)paren
suffix:semicolon
r_return
id|DMA_STATUS_BAD_CHANNEL
suffix:semicolon
)brace
id|sgl_addr
op_assign
(paren
id|ppc_sgl_t
op_star
)paren
id|__va
c_func
(paren
id|mfdcr
c_func
(paren
id|DCRN_ASG0
op_plus
(paren
id|psgl-&gt;dmanr
op_star
l_int|0x8
)paren
)paren
)paren
suffix:semicolon
id|count_left
op_assign
id|mfdcr
c_func
(paren
id|DCRN_DMACT0
op_plus
(paren
id|psgl-&gt;dmanr
op_star
l_int|0x8
)paren
)paren
op_amp
id|SG_COUNT_MASK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sgl_addr
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_get_dma_sgl_residue: sgl addr register is null&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|pnext
op_assign
id|psgl-&gt;phead
suffix:semicolon
r_while
c_loop
(paren
id|pnext
op_logical_and
(paren
(paren
r_int
)paren
id|pnext
OL
(paren
(paren
r_int
)paren
id|psgl
op_plus
id|SGL_LIST_SIZE
)paren
op_logical_and
(paren
id|pnext
op_ne
id|sgl_addr
)paren
)paren
)paren
(brace
id|pnext
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pnext
op_eq
id|sgl_addr
)paren
(brace
multiline_comment|/* found the sgl descriptor */
op_star
id|src_addr
op_assign
id|pnext-&gt;src_addr
suffix:semicolon
op_star
id|dst_addr
op_assign
id|pnext-&gt;dst_addr
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Now search the remaining descriptors and add their count.&n;&t;&t; * We already have the remaining count from this descriptor in&n;&t;&t; * count_left.&n;&t;&t; */
id|pnext
op_increment
suffix:semicolon
r_while
c_loop
(paren
(paren
id|pnext
op_ne
id|psgl-&gt;ptail
)paren
op_logical_and
(paren
(paren
r_int
)paren
id|pnext
OL
(paren
(paren
r_int
)paren
id|psgl
op_plus
id|SGL_LIST_SIZE
)paren
)paren
)paren
(brace
id|count_left
op_add_assign
id|pnext-&gt;control_count
op_amp
id|SG_COUNT_MASK
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pnext
op_ne
id|psgl-&gt;ptail
)paren
(brace
multiline_comment|/* should never happen */
id|printk
(paren
l_string|&quot;ppc4xx_get_dma_sgl_residue error (1) psgl-&gt;ptail 0x%x handle 0x%x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|psgl-&gt;ptail
comma
(paren
r_int
r_int
)paren
id|handle
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* success */
id|p_dma_ch
op_assign
op_amp
id|dma_channels
(braket
id|psgl-&gt;dmanr
)braket
suffix:semicolon
r_return
(paren
id|count_left
op_lshift
id|p_dma_ch-&gt;shift
)paren
suffix:semicolon
multiline_comment|/* count in bytes */
)brace
r_else
(brace
multiline_comment|/* this shouldn&squot;t happen */
id|printk
(paren
l_string|&quot;get_dma_sgl_residue, unable to match current address 0x%x, handle 0x%x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|sgl_addr
comma
(paren
r_int
r_int
)paren
id|handle
)paren
suffix:semicolon
)brace
id|error
suffix:colon
op_star
id|src_addr
op_assign
(paren
id|phys_addr_t
)paren
l_int|NULL
suffix:semicolon
op_star
id|dst_addr
op_assign
(paren
id|phys_addr_t
)paren
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns the address(es) of the buffer(s) contained in the head element of&n; * the scatter/gather list.  The element is removed from the scatter/gather&n; * list and the next element becomes the head.&n; *&n; * This function should only be called when the DMA is not active.&n; */
r_int
DECL|function|ppc4xx_delete_dma_sgl_element
id|ppc4xx_delete_dma_sgl_element
c_func
(paren
id|sgl_handle_t
id|handle
comma
id|phys_addr_t
op_star
id|src_dma_addr
comma
id|phys_addr_t
op_star
id|dst_dma_addr
)paren
(brace
id|sgl_list_info_t
op_star
id|psgl
op_assign
(paren
id|sgl_list_info_t
op_star
)paren
id|handle
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_delete_sgl_element: null handle&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|DMA_STATUS_BAD_HANDLE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|psgl-&gt;dmanr
OG
(paren
id|MAX_PPC4xx_DMA_CHANNELS
op_minus
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_delete_sgl_element: bad channel in handle %d&bslash;n&quot;
comma
id|psgl-&gt;dmanr
)paren
suffix:semicolon
r_return
id|DMA_STATUS_BAD_CHANNEL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|psgl-&gt;phead
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_delete_sgl_element: sgl list empty&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|src_dma_addr
op_assign
(paren
id|phys_addr_t
)paren
l_int|NULL
suffix:semicolon
op_star
id|dst_dma_addr
op_assign
(paren
id|phys_addr_t
)paren
l_int|NULL
suffix:semicolon
r_return
id|DMA_STATUS_SGL_LIST_EMPTY
suffix:semicolon
)brace
op_star
id|src_dma_addr
op_assign
(paren
id|phys_addr_t
)paren
id|psgl-&gt;phead-&gt;src_addr
suffix:semicolon
op_star
id|dst_dma_addr
op_assign
(paren
id|phys_addr_t
)paren
id|psgl-&gt;phead-&gt;dst_addr
suffix:semicolon
r_if
c_cond
(paren
id|psgl-&gt;phead
op_eq
id|psgl-&gt;ptail
)paren
(brace
multiline_comment|/* last descriptor on the list */
id|psgl-&gt;phead
op_assign
l_int|NULL
suffix:semicolon
id|psgl-&gt;ptail
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|psgl-&gt;phead
op_increment
suffix:semicolon
id|psgl-&gt;phead_dma
op_add_assign
r_sizeof
(paren
id|ppc_sgl_t
)paren
suffix:semicolon
)brace
r_return
id|DMA_STATUS_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; *   Create a scatter/gather list handle.  This is simply a structure which&n; *   describes a scatter/gather list.&n; *&n; *   A handle is returned in &quot;handle&quot; which the driver should save in order to&n; *   be able to access this list later.  A chunk of memory will be allocated&n; *   to be used by the API for internal management purposes, including managing&n; *   the sg list and allocating memory for the sgl descriptors.  One page should&n; *   be more than enough for that purpose.  Perhaps it&squot;s a bit wasteful to use&n; *   a whole page for a single sg list, but most likely there will be only one&n; *   sg list per channel.&n; *&n; *   Interrupt notes:&n; *   Each sgl descriptor has a copy of the DMA control word which the DMA engine&n; *   loads in the control register.  The control word has a &quot;global&quot; interrupt&n; *   enable bit for that channel. Interrupts are further qualified by a few bits&n; *   in the sgl descriptor count register.  In order to setup an sgl, we have to&n; *   know ahead of time whether or not interrupts will be enabled at the completion&n; *   of the transfers.  Thus, enable_dma_interrupt()/disable_dma_interrupt() MUST&n; *   be called before calling alloc_dma_handle().  If the interrupt mode will never&n; *   change after powerup, then enable_dma_interrupt()/disable_dma_interrupt()&n; *   do not have to be called -- interrupts will be enabled or disabled based&n; *   on how the channel was configured after powerup by the hw_init_dma_channel()&n; *   function.  Each sgl descriptor will be setup to interrupt if an error occurs;&n; *   however, only the last descriptor will be setup to interrupt. Thus, an&n; *   interrupt will occur (if interrupts are enabled) only after the complete&n; *   sgl transfer is done.&n; */
r_int
DECL|function|ppc4xx_alloc_dma_handle
id|ppc4xx_alloc_dma_handle
c_func
(paren
id|sgl_handle_t
op_star
id|phandle
comma
r_int
r_int
id|mode
comma
r_int
r_int
id|dmanr
)paren
(brace
id|sgl_list_info_t
op_star
id|psgl
op_assign
l_int|NULL
suffix:semicolon
id|dma_addr_t
id|dma_addr
suffix:semicolon
id|ppc_dma_ch_t
op_star
id|p_dma_ch
op_assign
op_amp
id|dma_channels
(braket
id|dmanr
)braket
suffix:semicolon
r_uint32
id|sg_command
suffix:semicolon
r_uint32
id|ctc_settings
suffix:semicolon
r_void
op_star
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|dmanr
op_ge
id|MAX_PPC4xx_DMA_CHANNELS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_alloc_dma_handle: invalid channel 0x%x&bslash;n&quot;
comma
id|dmanr
)paren
suffix:semicolon
r_return
id|DMA_STATUS_BAD_CHANNEL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|phandle
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_alloc_dma_handle: null handle pointer&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|DMA_STATUS_NULL_POINTER
suffix:semicolon
)brace
multiline_comment|/* Get a page of memory, which is zeroed out by consistent_alloc() */
id|ret
op_assign
id|dma_alloc_coherent
c_func
(paren
l_int|NULL
comma
id|DMA_PPC4xx_SIZE
comma
op_amp
id|dma_addr
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|NULL
)paren
(brace
id|memset
c_func
(paren
id|ret
comma
l_int|0
comma
id|DMA_PPC4xx_SIZE
)paren
suffix:semicolon
id|psgl
op_assign
(paren
id|sgl_list_info_t
op_star
)paren
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|psgl
op_eq
l_int|NULL
)paren
(brace
op_star
id|phandle
op_assign
(paren
id|sgl_handle_t
)paren
l_int|NULL
suffix:semicolon
r_return
id|DMA_STATUS_OUT_OF_MEMORY
suffix:semicolon
)brace
id|psgl-&gt;dma_addr
op_assign
id|dma_addr
suffix:semicolon
id|psgl-&gt;dmanr
op_assign
id|dmanr
suffix:semicolon
multiline_comment|/*&n;&t; * Modify and save the control word. These words will be&n;&t; * written to each sgl descriptor.  The DMA engine then&n;&t; * loads this control word into the control register&n;&t; * every time it reads a new descriptor.&n;&t; */
id|psgl-&gt;control
op_assign
id|p_dma_ch-&gt;control
suffix:semicolon
multiline_comment|/* Clear all mode bits */
id|psgl-&gt;control
op_and_assign
op_complement
(paren
id|DMA_TM_MASK
op_or
id|DMA_TD
)paren
suffix:semicolon
multiline_comment|/* Save control word and mode */
id|psgl-&gt;control
op_or_assign
(paren
id|mode
op_or
id|DMA_CE_ENABLE
)paren
suffix:semicolon
multiline_comment|/* In MM mode, we must set ETD/TCE */
r_if
c_cond
(paren
id|mode
op_eq
id|DMA_MODE_MM
)paren
id|psgl-&gt;control
op_or_assign
id|DMA_ETD_OUTPUT
op_or
id|DMA_TCE_ENABLE
suffix:semicolon
r_if
c_cond
(paren
id|p_dma_ch-&gt;int_enable
)paren
(brace
multiline_comment|/* Enable channel interrupt */
id|psgl-&gt;control
op_or_assign
id|DMA_CIE_ENABLE
suffix:semicolon
)brace
r_else
(brace
id|psgl-&gt;control
op_and_assign
op_complement
id|DMA_CIE_ENABLE
suffix:semicolon
)brace
id|sg_command
op_assign
id|mfdcr
c_func
(paren
id|DCRN_ASGC
)paren
suffix:semicolon
id|sg_command
op_or_assign
id|SSG_MASK_ENABLE
c_func
(paren
id|dmanr
)paren
suffix:semicolon
multiline_comment|/* Enable SGL control access */
id|mtdcr
c_func
(paren
id|DCRN_ASGC
comma
id|sg_command
)paren
suffix:semicolon
id|psgl-&gt;sgl_control
op_assign
id|SG_ERI_ENABLE
op_or
id|SG_LINK
suffix:semicolon
multiline_comment|/* keep control count register settings */
id|ctc_settings
op_assign
id|mfdcr
c_func
(paren
id|DCRN_DMACT0
op_plus
(paren
id|dmanr
op_star
l_int|0x8
)paren
)paren
op_amp
(paren
id|DMA_CTC_BSIZ_MSK
op_or
id|DMA_CTC_BTEN
)paren
suffix:semicolon
multiline_comment|/*burst mode settings*/
id|psgl-&gt;sgl_control
op_or_assign
id|ctc_settings
suffix:semicolon
r_if
c_cond
(paren
id|p_dma_ch-&gt;int_enable
)paren
(brace
r_if
c_cond
(paren
id|p_dma_ch-&gt;tce_enable
)paren
id|psgl-&gt;sgl_control
op_or_assign
id|SG_TCI_ENABLE
suffix:semicolon
r_else
id|psgl-&gt;sgl_control
op_or_assign
id|SG_ETI_ENABLE
suffix:semicolon
)brace
op_star
id|phandle
op_assign
(paren
id|sgl_handle_t
)paren
id|psgl
suffix:semicolon
r_return
id|DMA_STATUS_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; * Destroy a scatter/gather list handle that was created by alloc_dma_handle().&n; * The list must be empty (contain no elements).&n; */
r_void
DECL|function|ppc4xx_free_dma_handle
id|ppc4xx_free_dma_handle
c_func
(paren
id|sgl_handle_t
id|handle
)paren
(brace
id|sgl_list_info_t
op_star
id|psgl
op_assign
(paren
id|sgl_list_info_t
op_star
)paren
id|handle
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_free_dma_handle: got NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|psgl-&gt;phead
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppc4xx_free_dma_handle: list not empty&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|psgl-&gt;dma_addr
)paren
(brace
multiline_comment|/* should never happen */
id|printk
c_func
(paren
l_string|&quot;ppc4xx_free_dma_handle: no dma address&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dma_free_coherent
c_func
(paren
l_int|NULL
comma
id|DMA_PPC4xx_SIZE
comma
(paren
r_void
op_star
)paren
id|psgl
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|variable|ppc4xx_alloc_dma_handle
id|EXPORT_SYMBOL
c_func
(paren
id|ppc4xx_alloc_dma_handle
)paren
suffix:semicolon
DECL|variable|ppc4xx_free_dma_handle
id|EXPORT_SYMBOL
c_func
(paren
id|ppc4xx_free_dma_handle
)paren
suffix:semicolon
DECL|variable|ppc4xx_add_dma_sgl
id|EXPORT_SYMBOL
c_func
(paren
id|ppc4xx_add_dma_sgl
)paren
suffix:semicolon
DECL|variable|ppc4xx_delete_dma_sgl_element
id|EXPORT_SYMBOL
c_func
(paren
id|ppc4xx_delete_dma_sgl_element
)paren
suffix:semicolon
DECL|variable|ppc4xx_enable_dma_sgl
id|EXPORT_SYMBOL
c_func
(paren
id|ppc4xx_enable_dma_sgl
)paren
suffix:semicolon
DECL|variable|ppc4xx_disable_dma_sgl
id|EXPORT_SYMBOL
c_func
(paren
id|ppc4xx_disable_dma_sgl
)paren
suffix:semicolon
DECL|variable|ppc4xx_get_dma_sgl_residue
id|EXPORT_SYMBOL
c_func
(paren
id|ppc4xx_get_dma_sgl_residue
)paren
suffix:semicolon
eof
