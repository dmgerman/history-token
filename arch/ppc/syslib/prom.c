multiline_comment|/*&n; * Procedures for interfacing to the Open Firmware PROM on&n; * Power Macintosh computers.&n; *&n; * In particular, we are interested in the device tree&n; * and in using some of its services (exit, write to stdout).&n; *&n; * Paul Mackerras&t;August 1996.&n; * Copyright (C) 1996 Paul Mackerras.&n; */
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/threads.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/sections.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/bootx.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt;
macro_line|#include &lt;asm/btext.h&gt;
macro_line|#include &lt;asm/pci-bridge.h&gt;
macro_line|#include &lt;asm/open_pic.h&gt;
DECL|struct|pci_address
r_struct
id|pci_address
(brace
DECL|member|a_hi
r_int
id|a_hi
suffix:semicolon
DECL|member|a_mid
r_int
id|a_mid
suffix:semicolon
DECL|member|a_lo
r_int
id|a_lo
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|pci_reg_property
r_struct
id|pci_reg_property
(brace
DECL|member|addr
r_struct
id|pci_address
id|addr
suffix:semicolon
DECL|member|size_hi
r_int
id|size_hi
suffix:semicolon
DECL|member|size_lo
r_int
id|size_lo
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|isa_reg_property
r_struct
id|isa_reg_property
(brace
DECL|member|space
r_int
id|space
suffix:semicolon
DECL|member|address
r_int
id|address
suffix:semicolon
DECL|member|size
r_int
id|size
suffix:semicolon
)brace
suffix:semicolon
DECL|typedef|interpret_func
r_typedef
r_int
r_int
id|interpret_func
c_func
(paren
r_struct
id|device_node
op_star
comma
r_int
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
DECL|variable|interpret_pci_props
r_static
id|interpret_func
id|interpret_pci_props
suffix:semicolon
DECL|variable|interpret_dbdma_props
r_static
id|interpret_func
id|interpret_dbdma_props
suffix:semicolon
DECL|variable|interpret_isa_props
r_static
id|interpret_func
id|interpret_isa_props
suffix:semicolon
DECL|variable|interpret_macio_props
r_static
id|interpret_func
id|interpret_macio_props
suffix:semicolon
DECL|variable|interpret_root_props
r_static
id|interpret_func
id|interpret_root_props
suffix:semicolon
r_extern
r_char
op_star
id|klimit
suffix:semicolon
multiline_comment|/* Set for a newworld or CHRP machine */
DECL|variable|use_of_interrupt_tree
r_int
id|use_of_interrupt_tree
suffix:semicolon
DECL|variable|dflt_interrupt_controller
r_struct
id|device_node
op_star
id|dflt_interrupt_controller
suffix:semicolon
DECL|variable|num_interrupt_controllers
r_int
id|num_interrupt_controllers
suffix:semicolon
DECL|variable|pmac_newworld
r_int
id|pmac_newworld
suffix:semicolon
r_extern
r_int
r_int
id|rtas_entry
suffix:semicolon
multiline_comment|/* physical pointer */
r_extern
r_struct
id|device_node
op_star
id|allnodes
suffix:semicolon
r_static
r_int
r_int
id|finish_node
c_func
(paren
r_struct
id|device_node
op_star
comma
r_int
r_int
comma
id|interpret_func
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_static
r_int
r_int
id|finish_node_interrupts
c_func
(paren
r_struct
id|device_node
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_struct
id|device_node
op_star
id|find_phandle
c_func
(paren
id|phandle
)paren
suffix:semicolon
r_extern
r_void
id|enter_rtas
c_func
(paren
r_void
op_star
)paren
suffix:semicolon
r_void
id|phys_call_rtas
c_func
(paren
r_int
comma
r_int
comma
r_int
comma
dot
dot
dot
)paren
suffix:semicolon
r_extern
r_char
id|cmd_line
(braket
l_int|512
)braket
suffix:semicolon
multiline_comment|/* XXX */
r_extern
id|boot_infos_t
op_star
id|boot_infos
suffix:semicolon
DECL|variable|dev_tree_size
r_int
r_int
id|dev_tree_size
suffix:semicolon
r_void
id|__openfirmware
DECL|function|phys_call_rtas
id|phys_call_rtas
c_func
(paren
r_int
id|service
comma
r_int
id|nargs
comma
r_int
id|nret
comma
dot
dot
dot
)paren
(brace
id|va_list
id|list
suffix:semicolon
r_union
(brace
r_int
r_int
id|words
(braket
l_int|16
)braket
suffix:semicolon
r_float
id|align
suffix:semicolon
)brace
id|u
suffix:semicolon
r_void
(paren
op_star
id|rtas
)paren
(paren
r_void
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u.words
(braket
l_int|0
)braket
op_assign
id|service
suffix:semicolon
id|u.words
(braket
l_int|1
)braket
op_assign
id|nargs
suffix:semicolon
id|u.words
(braket
l_int|2
)braket
op_assign
id|nret
suffix:semicolon
id|va_start
c_func
(paren
id|list
comma
id|nret
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nargs
suffix:semicolon
op_increment
id|i
)paren
id|u.words
(braket
id|i
op_plus
l_int|3
)braket
op_assign
id|va_arg
c_func
(paren
id|list
comma
r_int
r_int
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|list
)paren
suffix:semicolon
id|rtas
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_void
op_star
comma
r_int
r_int
)paren
)paren
id|rtas_entry
suffix:semicolon
id|rtas
c_func
(paren
op_amp
id|u
comma
id|rtas_data
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * finish_device_tree is called once things are running normally&n; * (i.e. with text and data mapped to the address they were linked at).&n; * It traverses the device tree and fills in the name, type,&n; * {n_}addrs and {n_}intrs fields of each node.&n; */
r_void
id|__init
DECL|function|finish_device_tree
id|finish_device_tree
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|mem
op_assign
(paren
r_int
r_int
)paren
id|klimit
suffix:semicolon
r_struct
id|device_node
op_star
id|np
suffix:semicolon
multiline_comment|/* All newworld pmac machines and CHRPs now use the interrupt tree */
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|NULL
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
(brace
r_if
c_cond
(paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;interrupt-parent&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|use_of_interrupt_tree
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|_machine
op_eq
id|_MACH_Pmac
op_logical_and
id|use_of_interrupt_tree
)paren
id|pmac_newworld
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_BOOTX_TEXT
r_if
c_cond
(paren
id|boot_infos
op_logical_and
id|pmac_newworld
)paren
(brace
id|prom_print
c_func
(paren
l_string|&quot;WARNING ! BootX/miBoot booting is not supported on this machine&bslash;n&quot;
)paren
suffix:semicolon
id|prom_print
c_func
(paren
l_string|&quot;          You should use an Open Firmware bootloader&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BOOTX_TEXT */
r_if
c_cond
(paren
id|use_of_interrupt_tree
)paren
(brace
multiline_comment|/*&n;&t;&t; * We want to find out here how many interrupt-controller&n;&t;&t; * nodes there are, and if we are booted from BootX,&n;&t;&t; * we need a pointer to the first (and hopefully only)&n;&t;&t; * such node.  But we can&squot;t use find_devices here since&n;&t;&t; * np-&gt;name has not been set yet.  -- paulus&n;&t;&t; */
r_int
id|n
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|name
comma
op_star
id|ic
suffix:semicolon
r_int
id|iclen
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|NULL
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
(brace
id|ic
op_assign
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;interrupt-controller&quot;
comma
op_amp
id|iclen
)paren
suffix:semicolon
id|name
op_assign
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;name&quot;
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* checking iclen makes sure we don&squot;t get a false&n;&t;&t;&t;   match on /chosen.interrupt_controller */
r_if
c_cond
(paren
(paren
id|name
op_ne
l_int|NULL
op_logical_and
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;interrupt-controller&quot;
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
id|ic
op_ne
l_int|NULL
op_logical_and
id|iclen
op_eq
l_int|0
op_logical_and
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;AppleKiwi&quot;
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|n
op_eq
l_int|0
)paren
id|dflt_interrupt_controller
op_assign
id|np
suffix:semicolon
op_increment
id|n
suffix:semicolon
)brace
)brace
id|num_interrupt_controllers
op_assign
id|n
suffix:semicolon
)brace
id|mem
op_assign
id|finish_node
c_func
(paren
id|allnodes
comma
id|mem
comma
l_int|NULL
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
id|dev_tree_size
op_assign
id|mem
op_minus
(paren
r_int
r_int
)paren
id|allnodes
suffix:semicolon
id|klimit
op_assign
(paren
r_char
op_star
)paren
id|mem
suffix:semicolon
)brace
r_static
r_int
r_int
id|__init
DECL|function|finish_node
id|finish_node
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
comma
id|interpret_func
op_star
id|ifunc
comma
r_int
id|naddrc
comma
r_int
id|nsizec
)paren
(brace
r_struct
id|device_node
op_star
id|child
suffix:semicolon
r_int
op_star
id|ip
suffix:semicolon
id|np-&gt;name
op_assign
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;name&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|np-&gt;type
op_assign
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;device_type&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;name
)paren
id|np-&gt;name
op_assign
l_string|&quot;&lt;NULL&gt;&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;type
)paren
id|np-&gt;type
op_assign
l_string|&quot;&lt;NULL&gt;&quot;
suffix:semicolon
multiline_comment|/* get the device addresses and interrupts */
r_if
c_cond
(paren
id|ifunc
op_ne
l_int|NULL
)paren
id|mem_start
op_assign
id|ifunc
c_func
(paren
id|np
comma
id|mem_start
comma
id|naddrc
comma
id|nsizec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|use_of_interrupt_tree
)paren
id|mem_start
op_assign
id|finish_node_interrupts
c_func
(paren
id|np
comma
id|mem_start
)paren
suffix:semicolon
multiline_comment|/* Look for #address-cells and #size-cells properties. */
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;#address-cells&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_ne
l_int|NULL
)paren
id|naddrc
op_assign
op_star
id|ip
suffix:semicolon
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;#size-cells&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_ne
l_int|NULL
)paren
id|nsizec
op_assign
op_star
id|ip
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;parent
op_eq
l_int|NULL
)paren
id|ifunc
op_assign
id|interpret_root_props
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;type
op_eq
l_int|0
)paren
id|ifunc
op_assign
l_int|NULL
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;pci&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;vci&quot;
)paren
)paren
id|ifunc
op_assign
id|interpret_pci_props
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;dbdma&quot;
)paren
)paren
id|ifunc
op_assign
id|interpret_dbdma_props
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;mac-io&quot;
)paren
op_logical_or
id|ifunc
op_eq
id|interpret_macio_props
)paren
id|ifunc
op_assign
id|interpret_macio_props
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;isa&quot;
)paren
)paren
id|ifunc
op_assign
id|interpret_isa_props
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;name
comma
l_string|&quot;uni-n&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;name
comma
l_string|&quot;u3&quot;
)paren
)paren
id|ifunc
op_assign
id|interpret_root_props
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|ifunc
op_eq
id|interpret_dbdma_props
op_logical_or
id|ifunc
op_eq
id|interpret_macio_props
)paren
op_logical_and
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;escc&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;media-bay&quot;
)paren
)paren
)paren
)paren
id|ifunc
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* if we were booted from BootX, convert the full name */
r_if
c_cond
(paren
id|boot_infos
op_logical_and
id|strncmp
c_func
(paren
id|np-&gt;full_name
comma
l_string|&quot;Devices:device-tree&quot;
comma
l_int|19
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;full_name
(braket
l_int|19
)braket
op_eq
l_int|0
)paren
(brace
id|strcpy
c_func
(paren
id|np-&gt;full_name
comma
l_string|&quot;/&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|np-&gt;full_name
(braket
l_int|19
)braket
op_eq
l_char|&squot;:&squot;
)paren
(brace
r_char
op_star
id|p
op_assign
id|np-&gt;full_name
op_plus
l_int|19
suffix:semicolon
id|np-&gt;full_name
op_assign
id|p
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
op_star
id|p
suffix:semicolon
op_increment
id|p
)paren
r_if
c_cond
(paren
op_star
id|p
op_eq
l_char|&squot;:&squot;
)paren
op_star
id|p
op_assign
l_char|&squot;/&squot;
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|child
op_assign
id|np-&gt;child
suffix:semicolon
id|child
op_ne
l_int|NULL
suffix:semicolon
id|child
op_assign
id|child-&gt;sibling
)paren
id|mem_start
op_assign
id|finish_node
c_func
(paren
id|child
comma
id|mem_start
comma
id|ifunc
comma
id|naddrc
comma
id|nsizec
)paren
suffix:semicolon
r_return
id|mem_start
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the interrupt parent of a node.&n; */
r_static
r_struct
id|device_node
op_star
id|__init
DECL|function|intr_parent
id|intr_parent
c_func
(paren
r_struct
id|device_node
op_star
id|p
)paren
(brace
id|phandle
op_star
id|parp
suffix:semicolon
id|parp
op_assign
(paren
id|phandle
op_star
)paren
id|get_property
c_func
(paren
id|p
comma
l_string|&quot;interrupt-parent&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parp
op_eq
l_int|NULL
)paren
r_return
id|p-&gt;parent
suffix:semicolon
id|p
op_assign
id|find_phandle
c_func
(paren
op_star
id|parp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ne
l_int|NULL
)paren
r_return
id|p
suffix:semicolon
multiline_comment|/*&n;&t; * On a powermac booted with BootX, we don&squot;t get to know the&n;&t; * phandles for any nodes, so find_phandle will return NULL.&n;&t; * Fortunately these machines only have one interrupt controller&n;&t; * so there isn&squot;t in fact any ambiguity.  -- paulus&n;&t; */
r_if
c_cond
(paren
id|num_interrupt_controllers
op_eq
l_int|1
)paren
id|p
op_assign
id|dflt_interrupt_controller
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
multiline_comment|/*&n; * Find out the size of each entry of the interrupts property&n; * for a node.&n; */
r_static
r_int
id|__init
DECL|function|prom_n_intr_cells
id|prom_n_intr_cells
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_struct
id|device_node
op_star
id|p
suffix:semicolon
r_int
r_int
op_star
id|icp
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|np
suffix:semicolon
(paren
id|p
op_assign
id|intr_parent
c_func
(paren
id|p
)paren
)paren
op_ne
l_int|NULL
suffix:semicolon
)paren
(brace
id|icp
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|p
comma
l_string|&quot;#interrupt-cells&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|icp
op_ne
l_int|NULL
)paren
r_return
op_star
id|icp
suffix:semicolon
r_if
c_cond
(paren
id|get_property
c_func
(paren
id|p
comma
l_string|&quot;interrupt-controller&quot;
comma
l_int|NULL
)paren
op_ne
l_int|NULL
op_logical_or
id|get_property
c_func
(paren
id|p
comma
l_string|&quot;interrupt-map&quot;
comma
l_int|NULL
)paren
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;oops, node %s doesn&squot;t have #interrupt-cells&bslash;n&quot;
comma
id|p-&gt;full_name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;prom_n_intr_cells failed for %s&bslash;n&quot;
comma
id|np-&gt;full_name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Map an interrupt from a device up to the platform interrupt&n; * descriptor.&n; */
r_static
r_int
id|__init
DECL|function|map_interrupt
id|map_interrupt
c_func
(paren
r_int
r_int
op_star
op_star
id|irq
comma
r_struct
id|device_node
op_star
op_star
id|ictrler
comma
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
op_star
id|ints
comma
r_int
id|nintrc
)paren
(brace
r_struct
id|device_node
op_star
id|p
comma
op_star
id|ipar
suffix:semicolon
r_int
r_int
op_star
id|imap
comma
op_star
id|imask
comma
op_star
id|ip
suffix:semicolon
r_int
id|i
comma
id|imaplen
comma
id|match
suffix:semicolon
r_int
id|newintrc
comma
id|newaddrc
suffix:semicolon
r_int
r_int
op_star
id|reg
suffix:semicolon
r_int
id|naddrc
suffix:semicolon
id|reg
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;reg&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|naddrc
op_assign
id|prom_n_addr_cells
c_func
(paren
id|np
)paren
suffix:semicolon
id|p
op_assign
id|intr_parent
c_func
(paren
id|np
)paren
suffix:semicolon
r_while
c_loop
(paren
id|p
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|get_property
c_func
(paren
id|p
comma
l_string|&quot;interrupt-controller&quot;
comma
l_int|NULL
)paren
op_ne
l_int|NULL
)paren
multiline_comment|/* this node is an interrupt controller, stop here */
r_break
suffix:semicolon
id|imap
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|p
comma
l_string|&quot;interrupt-map&quot;
comma
op_amp
id|imaplen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|imap
op_eq
l_int|NULL
)paren
(brace
id|p
op_assign
id|intr_parent
c_func
(paren
id|p
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|imask
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|p
comma
l_string|&quot;interrupt-map-mask&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|imask
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;oops, %s has interrupt-map but no mask&bslash;n&quot;
comma
id|p-&gt;full_name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|imaplen
op_div_assign
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|match
op_assign
l_int|0
suffix:semicolon
id|ipar
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|imaplen
OG
l_int|0
op_logical_and
op_logical_neg
id|match
)paren
(brace
multiline_comment|/* check the child-interrupt field */
id|match
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|naddrc
op_logical_and
id|match
suffix:semicolon
op_increment
id|i
)paren
id|match
op_assign
(paren
(paren
id|reg
(braket
id|i
)braket
op_xor
id|imap
(braket
id|i
)braket
)paren
op_amp
id|imask
(braket
id|i
)braket
)paren
op_eq
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|naddrc
op_plus
id|nintrc
op_logical_and
id|match
suffix:semicolon
op_increment
id|i
)paren
id|match
op_assign
(paren
(paren
id|ints
(braket
id|i
op_minus
id|naddrc
)braket
op_xor
id|imap
(braket
id|i
)braket
)paren
op_amp
id|imask
(braket
id|i
)braket
)paren
op_eq
l_int|0
suffix:semicolon
id|imap
op_add_assign
id|naddrc
op_plus
id|nintrc
suffix:semicolon
id|imaplen
op_sub_assign
id|naddrc
op_plus
id|nintrc
suffix:semicolon
multiline_comment|/* grab the interrupt parent */
id|ipar
op_assign
id|find_phandle
c_func
(paren
(paren
id|phandle
)paren
op_star
id|imap
op_increment
)paren
suffix:semicolon
op_decrement
id|imaplen
suffix:semicolon
r_if
c_cond
(paren
id|ipar
op_eq
l_int|NULL
op_logical_and
id|num_interrupt_controllers
op_eq
l_int|1
)paren
multiline_comment|/* cope with BootX not giving us phandles */
id|ipar
op_assign
id|dflt_interrupt_controller
suffix:semicolon
r_if
c_cond
(paren
id|ipar
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;oops, no int parent %x in map of %s&bslash;n&quot;
comma
id|imap
(braket
op_minus
l_int|1
)braket
comma
id|p-&gt;full_name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* find the parent&squot;s # addr and intr cells */
id|ip
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|ipar
comma
l_string|&quot;#interrupt-cells&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;oops, no #interrupt-cells on %s&bslash;n&quot;
comma
id|ipar-&gt;full_name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|newintrc
op_assign
op_star
id|ip
suffix:semicolon
id|ip
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|ipar
comma
l_string|&quot;#address-cells&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|newaddrc
op_assign
(paren
id|ip
op_eq
l_int|NULL
)paren
ques
c_cond
l_int|0
suffix:colon
op_star
id|ip
suffix:semicolon
id|imap
op_add_assign
id|newaddrc
op_plus
id|newintrc
suffix:semicolon
id|imaplen
op_sub_assign
id|newaddrc
op_plus
id|newintrc
suffix:semicolon
)brace
r_if
c_cond
(paren
id|imaplen
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;oops, error decoding int-map on %s, len=%d&bslash;n&quot;
comma
id|p-&gt;full_name
comma
id|imaplen
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|match
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;oops, no match in %s int-map for %s&bslash;n&quot;
comma
id|p-&gt;full_name
comma
id|np-&gt;full_name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|p
op_assign
id|ipar
suffix:semicolon
id|naddrc
op_assign
id|newaddrc
suffix:semicolon
id|nintrc
op_assign
id|newintrc
suffix:semicolon
id|ints
op_assign
id|imap
op_minus
id|nintrc
suffix:semicolon
id|reg
op_assign
id|ints
op_minus
id|naddrc
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
id|printk
c_func
(paren
l_string|&quot;hmmm, int tree for %s doesn&squot;t have ctrler&bslash;n&quot;
comma
id|np-&gt;full_name
)paren
suffix:semicolon
op_star
id|irq
op_assign
id|ints
suffix:semicolon
op_star
id|ictrler
op_assign
id|p
suffix:semicolon
r_return
id|nintrc
suffix:semicolon
)brace
multiline_comment|/*&n; * New version of finish_node_interrupts.&n; */
r_static
r_int
r_int
id|__init
DECL|function|finish_node_interrupts
id|finish_node_interrupts
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
)paren
(brace
r_int
r_int
op_star
id|ints
suffix:semicolon
r_int
id|intlen
comma
id|intrcells
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|n
comma
id|offset
suffix:semicolon
r_int
r_int
op_star
id|irq
suffix:semicolon
r_struct
id|device_node
op_star
id|ic
suffix:semicolon
id|ints
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;interrupts&quot;
comma
op_amp
id|intlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ints
op_eq
l_int|NULL
)paren
r_return
id|mem_start
suffix:semicolon
id|intrcells
op_assign
id|prom_n_intr_cells
c_func
(paren
id|np
)paren
suffix:semicolon
id|intlen
op_div_assign
id|intrcells
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|np-&gt;n_intrs
op_assign
id|intlen
suffix:semicolon
id|np-&gt;intrs
op_assign
(paren
r_struct
id|interrupt_info
op_star
)paren
id|mem_start
suffix:semicolon
id|mem_start
op_add_assign
id|intlen
op_star
r_sizeof
(paren
r_struct
id|interrupt_info
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|intlen
suffix:semicolon
op_increment
id|i
)paren
(brace
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|line
op_assign
l_int|0
suffix:semicolon
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|sense
op_assign
l_int|1
suffix:semicolon
id|n
op_assign
id|map_interrupt
c_func
(paren
op_amp
id|irq
comma
op_amp
id|ic
comma
id|np
comma
id|ints
comma
id|intrcells
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_le
l_int|0
)paren
r_continue
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * On a CHRP we have an 8259 which is subordinate to&n;&t;&t; * the openpic in the interrupt tree, but we want the&n;&t;&t; * openpic&squot;s interrupt numbers offsetted, not the 8259&squot;s.&n;&t;&t; * So we apply the offset if the controller is at the&n;&t;&t; * root of the interrupt tree, i.e. has no interrupt-parent.&n;&t;&t; * This doesn&squot;t cope with the general case of multiple&n;&t;&t; * cascaded interrupt controllers, but then neither will&n;&t;&t; * irq.c at the moment either.  -- paulus&n;&t;&t; * The G5 triggers that code, I add a machine test. On&n;&t;&t; * those machines, we want to offset interrupts from the&n;&t;&t; * second openpic by 128 -- BenH&n;&t;&t; */
r_if
c_cond
(paren
id|_machine
op_ne
id|_MACH_Pmac
op_logical_and
id|num_interrupt_controllers
OG
l_int|1
op_logical_and
id|ic
op_ne
l_int|NULL
op_logical_and
id|get_property
c_func
(paren
id|ic
comma
l_string|&quot;interrupt-parent&quot;
comma
l_int|NULL
)paren
op_eq
l_int|NULL
)paren
id|offset
op_assign
l_int|16
suffix:semicolon
r_else
r_if
c_cond
(paren
id|_machine
op_eq
id|_MACH_Pmac
op_logical_and
id|num_interrupt_controllers
OG
l_int|1
op_logical_and
id|ic
op_ne
l_int|NULL
op_logical_and
id|ic-&gt;parent
op_ne
l_int|NULL
)paren
(brace
r_char
op_star
id|name
op_assign
id|get_property
c_func
(paren
id|ic-&gt;parent
comma
l_string|&quot;name&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;u3&quot;
)paren
)paren
id|offset
op_assign
l_int|128
suffix:semicolon
)brace
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|line
op_assign
id|irq
(braket
l_int|0
)braket
op_plus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|1
)paren
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|sense
op_assign
id|irq
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;hmmm, got %d intr cells for %s:&quot;
comma
id|n
comma
id|np-&gt;full_name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|n
suffix:semicolon
op_increment
id|j
)paren
id|printk
c_func
(paren
l_string|&quot; %d&quot;
comma
id|irq
(braket
id|j
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|ints
op_add_assign
id|intrcells
suffix:semicolon
)brace
r_return
id|mem_start
suffix:semicolon
)brace
multiline_comment|/*&n; * When BootX makes a copy of the device tree from the MacOS&n; * Name Registry, it is in the format we use but all of the pointers&n; * are offsets from the start of the tree.&n; * This procedure updates the pointers.&n; */
r_void
id|__init
DECL|function|relocate_nodes
id|relocate_nodes
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|base
suffix:semicolon
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_struct
id|property
op_star
id|pp
suffix:semicolon
DECL|macro|ADDBASE
mdefine_line|#define ADDBASE(x)&t;(x = (typeof (x))((x)? ((unsigned long)(x) + base): 0))
id|base
op_assign
(paren
r_int
r_int
)paren
id|boot_infos
op_plus
id|boot_infos-&gt;deviceTreeOffset
suffix:semicolon
id|allnodes
op_assign
(paren
r_struct
id|device_node
op_star
)paren
(paren
id|base
op_plus
l_int|4
)paren
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
(brace
id|ADDBASE
c_func
(paren
id|np-&gt;full_name
)paren
suffix:semicolon
id|ADDBASE
c_func
(paren
id|np-&gt;properties
)paren
suffix:semicolon
id|ADDBASE
c_func
(paren
id|np-&gt;parent
)paren
suffix:semicolon
id|ADDBASE
c_func
(paren
id|np-&gt;child
)paren
suffix:semicolon
id|ADDBASE
c_func
(paren
id|np-&gt;sibling
)paren
suffix:semicolon
id|ADDBASE
c_func
(paren
id|np-&gt;allnext
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pp
op_assign
id|np-&gt;properties
suffix:semicolon
id|pp
op_ne
l_int|0
suffix:semicolon
id|pp
op_assign
id|pp-&gt;next
)paren
(brace
id|ADDBASE
c_func
(paren
id|pp-&gt;name
)paren
suffix:semicolon
id|ADDBASE
c_func
(paren
id|pp-&gt;value
)paren
suffix:semicolon
id|ADDBASE
c_func
(paren
id|pp-&gt;next
)paren
suffix:semicolon
)brace
)brace
)brace
r_int
DECL|function|prom_n_addr_cells
id|prom_n_addr_cells
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_int
op_star
id|ip
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|np-&gt;parent
)paren
id|np
op_assign
id|np-&gt;parent
suffix:semicolon
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;#address-cells&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_ne
l_int|NULL
)paren
r_return
op_star
id|ip
suffix:semicolon
)brace
r_while
c_loop
(paren
id|np-&gt;parent
)paren
suffix:semicolon
multiline_comment|/* No #address-cells property for the root node, default to 1 */
r_return
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|prom_n_size_cells
id|prom_n_size_cells
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_int
op_star
id|ip
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|np-&gt;parent
)paren
id|np
op_assign
id|np-&gt;parent
suffix:semicolon
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;#size-cells&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_ne
l_int|NULL
)paren
r_return
op_star
id|ip
suffix:semicolon
)brace
r_while
c_loop
(paren
id|np-&gt;parent
)paren
suffix:semicolon
multiline_comment|/* No #size-cells property for the root node, default to 1 */
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_int
r_int
id|__init
DECL|function|map_addr
id|map_addr
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|space
comma
r_int
r_int
id|addr
)paren
(brace
r_int
id|na
suffix:semicolon
r_int
r_int
op_star
id|ranges
suffix:semicolon
r_int
id|rlen
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|type
suffix:semicolon
id|type
op_assign
(paren
id|space
op_rshift
l_int|24
)paren
op_amp
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
l_int|0
)paren
r_return
id|addr
suffix:semicolon
r_while
c_loop
(paren
(paren
id|np
op_assign
id|np-&gt;parent
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|np-&gt;type
comma
l_string|&quot;pci&quot;
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* PCI bridge: map the address through the ranges property */
id|na
op_assign
id|prom_n_addr_cells
c_func
(paren
id|np
)paren
suffix:semicolon
id|ranges
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;ranges&quot;
comma
op_amp
id|rlen
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|rlen
op_sub_assign
(paren
id|na
op_plus
l_int|5
)paren
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|ranges
(braket
l_int|0
)braket
op_rshift
l_int|24
)paren
op_amp
l_int|3
)paren
op_eq
id|type
op_logical_and
id|ranges
(braket
l_int|2
)braket
op_le
id|addr
op_logical_and
id|addr
op_minus
id|ranges
(braket
l_int|2
)braket
OL
id|ranges
(braket
id|na
op_plus
l_int|4
)braket
)paren
(brace
multiline_comment|/* ok, this matches, translate it */
id|addr
op_add_assign
id|ranges
(braket
id|na
op_plus
l_int|2
)braket
op_minus
id|ranges
(braket
l_int|2
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ranges
op_add_assign
id|na
op_plus
l_int|5
suffix:semicolon
)brace
)brace
r_return
id|addr
suffix:semicolon
)brace
r_static
r_int
r_int
id|__init
DECL|function|interpret_pci_props
id|interpret_pci_props
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
comma
r_int
id|naddrc
comma
r_int
id|nsizec
)paren
(brace
r_struct
id|address_range
op_star
id|adr
suffix:semicolon
r_struct
id|pci_reg_property
op_star
id|pci_addrs
suffix:semicolon
r_int
id|i
comma
id|l
comma
op_star
id|ip
suffix:semicolon
id|pci_addrs
op_assign
(paren
r_struct
id|pci_reg_property
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;assigned-addresses&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_addrs
op_ne
l_int|0
op_logical_and
id|l
op_ge
r_sizeof
(paren
r_struct
id|pci_reg_property
)paren
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
id|adr
op_assign
(paren
r_struct
id|address_range
op_star
)paren
id|mem_start
suffix:semicolon
r_while
c_loop
(paren
(paren
id|l
op_sub_assign
r_sizeof
(paren
r_struct
id|pci_reg_property
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|adr
(braket
id|i
)braket
dot
id|space
op_assign
id|pci_addrs
(braket
id|i
)braket
dot
id|addr.a_hi
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|address
op_assign
id|map_addr
c_func
(paren
id|np
comma
id|pci_addrs
(braket
id|i
)braket
dot
id|addr.a_hi
comma
id|pci_addrs
(braket
id|i
)braket
dot
id|addr.a_lo
)paren
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|size
op_assign
id|pci_addrs
(braket
id|i
)braket
dot
id|size_lo
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
id|np-&gt;addrs
op_assign
id|adr
suffix:semicolon
id|np-&gt;n_addrs
op_assign
id|i
suffix:semicolon
id|mem_start
op_add_assign
id|i
op_star
r_sizeof
(paren
r_struct
id|address_range
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|use_of_interrupt_tree
)paren
r_return
id|mem_start
suffix:semicolon
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;AAPL,interrupts&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
l_int|0
op_logical_and
id|np-&gt;parent
)paren
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np-&gt;parent
comma
l_string|&quot;AAPL,interrupts&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
l_int|0
)paren
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;interrupts&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_ne
l_int|0
)paren
(brace
id|np-&gt;intrs
op_assign
(paren
r_struct
id|interrupt_info
op_star
)paren
id|mem_start
suffix:semicolon
id|np-&gt;n_intrs
op_assign
id|l
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|mem_start
op_add_assign
id|np-&gt;n_intrs
op_star
r_sizeof
(paren
r_struct
id|interrupt_info
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|np-&gt;n_intrs
suffix:semicolon
op_increment
id|i
)paren
(brace
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|line
op_assign
op_star
id|ip
op_increment
suffix:semicolon
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|sense
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|mem_start
suffix:semicolon
)brace
r_static
r_int
r_int
id|__init
DECL|function|interpret_dbdma_props
id|interpret_dbdma_props
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
comma
r_int
id|naddrc
comma
r_int
id|nsizec
)paren
(brace
r_struct
id|reg_property
op_star
id|rp
suffix:semicolon
r_struct
id|address_range
op_star
id|adr
suffix:semicolon
r_int
r_int
id|base_address
suffix:semicolon
r_int
id|i
comma
id|l
comma
op_star
id|ip
suffix:semicolon
r_struct
id|device_node
op_star
id|db
suffix:semicolon
id|base_address
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|db
op_assign
id|np-&gt;parent
suffix:semicolon
id|db
op_ne
l_int|NULL
suffix:semicolon
id|db
op_assign
id|db-&gt;parent
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|db-&gt;type
comma
l_string|&quot;dbdma&quot;
)paren
op_logical_and
id|db-&gt;n_addrs
op_ne
l_int|0
)paren
(brace
id|base_address
op_assign
id|db-&gt;addrs
(braket
l_int|0
)braket
dot
id|address
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|rp
op_assign
(paren
r_struct
id|reg_property
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;reg&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp
op_ne
l_int|0
op_logical_and
id|l
op_ge
r_sizeof
(paren
r_struct
id|reg_property
)paren
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
id|adr
op_assign
(paren
r_struct
id|address_range
op_star
)paren
id|mem_start
suffix:semicolon
r_while
c_loop
(paren
(paren
id|l
op_sub_assign
r_sizeof
(paren
r_struct
id|reg_property
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|adr
(braket
id|i
)braket
dot
id|space
op_assign
l_int|2
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|address
op_assign
id|rp
(braket
id|i
)braket
dot
id|address
op_plus
id|base_address
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|size
op_assign
id|rp
(braket
id|i
)braket
dot
id|size
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
id|np-&gt;addrs
op_assign
id|adr
suffix:semicolon
id|np-&gt;n_addrs
op_assign
id|i
suffix:semicolon
id|mem_start
op_add_assign
id|i
op_star
r_sizeof
(paren
r_struct
id|address_range
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|use_of_interrupt_tree
)paren
r_return
id|mem_start
suffix:semicolon
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;AAPL,interrupts&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
l_int|0
)paren
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;interrupts&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_ne
l_int|0
)paren
(brace
id|np-&gt;intrs
op_assign
(paren
r_struct
id|interrupt_info
op_star
)paren
id|mem_start
suffix:semicolon
id|np-&gt;n_intrs
op_assign
id|l
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|mem_start
op_add_assign
id|np-&gt;n_intrs
op_star
r_sizeof
(paren
r_struct
id|interrupt_info
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|np-&gt;n_intrs
suffix:semicolon
op_increment
id|i
)paren
(brace
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|line
op_assign
op_star
id|ip
op_increment
suffix:semicolon
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|sense
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|mem_start
suffix:semicolon
)brace
r_static
r_int
r_int
id|__init
DECL|function|interpret_macio_props
id|interpret_macio_props
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
comma
r_int
id|naddrc
comma
r_int
id|nsizec
)paren
(brace
r_struct
id|reg_property
op_star
id|rp
suffix:semicolon
r_struct
id|address_range
op_star
id|adr
suffix:semicolon
r_int
r_int
id|base_address
suffix:semicolon
r_int
id|i
comma
id|l
comma
op_star
id|ip
suffix:semicolon
r_struct
id|device_node
op_star
id|db
suffix:semicolon
id|base_address
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|db
op_assign
id|np-&gt;parent
suffix:semicolon
id|db
op_ne
l_int|NULL
suffix:semicolon
id|db
op_assign
id|db-&gt;parent
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|db-&gt;type
comma
l_string|&quot;mac-io&quot;
)paren
op_logical_and
id|db-&gt;n_addrs
op_ne
l_int|0
)paren
(brace
id|base_address
op_assign
id|db-&gt;addrs
(braket
l_int|0
)braket
dot
id|address
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|rp
op_assign
(paren
r_struct
id|reg_property
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;reg&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp
op_ne
l_int|0
op_logical_and
id|l
op_ge
r_sizeof
(paren
r_struct
id|reg_property
)paren
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
id|adr
op_assign
(paren
r_struct
id|address_range
op_star
)paren
id|mem_start
suffix:semicolon
r_while
c_loop
(paren
(paren
id|l
op_sub_assign
r_sizeof
(paren
r_struct
id|reg_property
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|adr
(braket
id|i
)braket
dot
id|space
op_assign
l_int|2
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|address
op_assign
id|rp
(braket
id|i
)braket
dot
id|address
op_plus
id|base_address
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|size
op_assign
id|rp
(braket
id|i
)braket
dot
id|size
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
id|np-&gt;addrs
op_assign
id|adr
suffix:semicolon
id|np-&gt;n_addrs
op_assign
id|i
suffix:semicolon
id|mem_start
op_add_assign
id|i
op_star
r_sizeof
(paren
r_struct
id|address_range
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|use_of_interrupt_tree
)paren
r_return
id|mem_start
suffix:semicolon
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;interrupts&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
l_int|0
)paren
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;AAPL,interrupts&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_ne
l_int|0
)paren
(brace
id|np-&gt;intrs
op_assign
(paren
r_struct
id|interrupt_info
op_star
)paren
id|mem_start
suffix:semicolon
id|np-&gt;n_intrs
op_assign
id|l
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|np-&gt;n_intrs
suffix:semicolon
op_increment
id|i
)paren
(brace
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|line
op_assign
op_star
id|ip
op_increment
suffix:semicolon
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|sense
op_assign
l_int|1
suffix:semicolon
)brace
id|mem_start
op_add_assign
id|np-&gt;n_intrs
op_star
r_sizeof
(paren
r_struct
id|interrupt_info
)paren
suffix:semicolon
)brace
r_return
id|mem_start
suffix:semicolon
)brace
r_static
r_int
r_int
id|__init
DECL|function|interpret_isa_props
id|interpret_isa_props
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
comma
r_int
id|naddrc
comma
r_int
id|nsizec
)paren
(brace
r_struct
id|isa_reg_property
op_star
id|rp
suffix:semicolon
r_struct
id|address_range
op_star
id|adr
suffix:semicolon
r_int
id|i
comma
id|l
comma
op_star
id|ip
suffix:semicolon
id|rp
op_assign
(paren
r_struct
id|isa_reg_property
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;reg&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp
op_ne
l_int|0
op_logical_and
id|l
op_ge
r_sizeof
(paren
r_struct
id|isa_reg_property
)paren
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
id|adr
op_assign
(paren
r_struct
id|address_range
op_star
)paren
id|mem_start
suffix:semicolon
r_while
c_loop
(paren
(paren
id|l
op_sub_assign
r_sizeof
(paren
r_struct
id|reg_property
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|adr
(braket
id|i
)braket
dot
id|space
op_assign
id|rp
(braket
id|i
)braket
dot
id|space
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|address
op_assign
id|rp
(braket
id|i
)braket
dot
id|address
op_plus
(paren
id|adr
(braket
id|i
)braket
dot
id|space
ques
c_cond
l_int|0
suffix:colon
id|_ISA_MEM_BASE
)paren
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|size
op_assign
id|rp
(braket
id|i
)braket
dot
id|size
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
id|np-&gt;addrs
op_assign
id|adr
suffix:semicolon
id|np-&gt;n_addrs
op_assign
id|i
suffix:semicolon
id|mem_start
op_add_assign
id|i
op_star
r_sizeof
(paren
r_struct
id|address_range
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|use_of_interrupt_tree
)paren
r_return
id|mem_start
suffix:semicolon
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;interrupts&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_ne
l_int|0
)paren
(brace
id|np-&gt;intrs
op_assign
(paren
r_struct
id|interrupt_info
op_star
)paren
id|mem_start
suffix:semicolon
id|np-&gt;n_intrs
op_assign
id|l
op_div
(paren
l_int|2
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|mem_start
op_add_assign
id|np-&gt;n_intrs
op_star
r_sizeof
(paren
r_struct
id|interrupt_info
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|np-&gt;n_intrs
suffix:semicolon
op_increment
id|i
)paren
(brace
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|line
op_assign
op_star
id|ip
op_increment
suffix:semicolon
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|sense
op_assign
op_star
id|ip
op_increment
suffix:semicolon
)brace
)brace
r_return
id|mem_start
suffix:semicolon
)brace
r_static
r_int
r_int
id|__init
DECL|function|interpret_root_props
id|interpret_root_props
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
r_int
id|mem_start
comma
r_int
id|naddrc
comma
r_int
id|nsizec
)paren
(brace
r_struct
id|address_range
op_star
id|adr
suffix:semicolon
r_int
id|i
comma
id|l
comma
op_star
id|ip
suffix:semicolon
r_int
r_int
op_star
id|rp
suffix:semicolon
r_int
id|rpsize
op_assign
(paren
id|naddrc
op_plus
id|nsizec
)paren
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|rp
op_assign
(paren
r_int
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;reg&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp
op_ne
l_int|0
op_logical_and
id|l
op_ge
id|rpsize
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
id|adr
op_assign
(paren
r_struct
id|address_range
op_star
)paren
id|mem_start
suffix:semicolon
r_while
c_loop
(paren
(paren
id|l
op_sub_assign
id|rpsize
)paren
op_ge
l_int|0
)paren
(brace
id|adr
(braket
id|i
)braket
dot
id|space
op_assign
(paren
id|naddrc
op_ge
l_int|2
ques
c_cond
id|rp
(braket
id|naddrc
op_minus
l_int|2
)braket
suffix:colon
l_int|2
)paren
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|address
op_assign
id|rp
(braket
id|naddrc
op_minus
l_int|1
)braket
suffix:semicolon
id|adr
(braket
id|i
)braket
dot
id|size
op_assign
id|rp
(braket
id|naddrc
op_plus
id|nsizec
op_minus
l_int|1
)braket
suffix:semicolon
op_increment
id|i
suffix:semicolon
id|rp
op_add_assign
id|naddrc
op_plus
id|nsizec
suffix:semicolon
)brace
id|np-&gt;addrs
op_assign
id|adr
suffix:semicolon
id|np-&gt;n_addrs
op_assign
id|i
suffix:semicolon
id|mem_start
op_add_assign
id|i
op_star
r_sizeof
(paren
r_struct
id|address_range
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|use_of_interrupt_tree
)paren
r_return
id|mem_start
suffix:semicolon
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;AAPL,interrupts&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
l_int|0
)paren
id|ip
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;interrupts&quot;
comma
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_ne
l_int|0
)paren
(brace
id|np-&gt;intrs
op_assign
(paren
r_struct
id|interrupt_info
op_star
)paren
id|mem_start
suffix:semicolon
id|np-&gt;n_intrs
op_assign
id|l
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|mem_start
op_add_assign
id|np-&gt;n_intrs
op_star
r_sizeof
(paren
r_struct
id|interrupt_info
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|np-&gt;n_intrs
suffix:semicolon
op_increment
id|i
)paren
(brace
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|line
op_assign
op_star
id|ip
op_increment
suffix:semicolon
id|np-&gt;intrs
(braket
id|i
)braket
dot
id|sense
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|mem_start
suffix:semicolon
)brace
multiline_comment|/*&n; * Work out the sense (active-low level / active-high edge)&n; * of each interrupt from the device tree.&n; */
r_void
id|__init
DECL|function|prom_get_irq_senses
id|prom_get_irq_senses
c_func
(paren
r_int
r_char
op_star
id|senses
comma
r_int
id|off
comma
r_int
id|max
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
multiline_comment|/* default to level-triggered */
id|memset
c_func
(paren
id|senses
comma
l_int|1
comma
id|max
op_minus
id|off
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|use_of_interrupt_tree
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|np-&gt;n_intrs
suffix:semicolon
id|j
op_increment
)paren
(brace
id|i
op_assign
id|np-&gt;intrs
(braket
id|j
)braket
dot
id|line
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|off
op_logical_and
id|i
OL
id|max
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;intrs
(braket
id|j
)braket
dot
id|sense
op_eq
l_int|1
)paren
id|senses
(braket
id|i
op_minus
id|off
)braket
op_assign
(paren
id|IRQ_SENSE_LEVEL
op_or
id|IRQ_POLARITY_NEGATIVE
)paren
suffix:semicolon
r_else
id|senses
(braket
id|i
op_minus
id|off
)braket
op_assign
(paren
id|IRQ_SENSE_EDGE
op_or
id|IRQ_POLARITY_POSITIVE
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n; * Construct and return a list of the device_nodes with a given name.&n; */
r_struct
id|device_node
op_star
DECL|function|find_devices
id|find_devices
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|device_node
op_star
id|head
comma
op_star
op_star
id|prevp
comma
op_star
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|head
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;name
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;name
comma
id|name
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|prevp
op_assign
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|np-&gt;next
suffix:semicolon
)brace
)brace
op_star
id|prevp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|head
suffix:semicolon
)brace
multiline_comment|/*&n; * Construct and return a list of the device_nodes with a given type.&n; */
r_struct
id|device_node
op_star
DECL|function|find_type_devices
id|find_type_devices
c_func
(paren
r_const
r_char
op_star
id|type
)paren
(brace
r_struct
id|device_node
op_star
id|head
comma
op_star
op_star
id|prevp
comma
op_star
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|head
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;type
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;type
comma
id|type
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|prevp
op_assign
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|np-&gt;next
suffix:semicolon
)brace
)brace
op_star
id|prevp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|head
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns all nodes linked together&n; */
r_struct
id|device_node
op_star
id|__openfirmware
DECL|function|find_all_nodes
id|find_all_nodes
c_func
(paren
r_void
)paren
(brace
r_struct
id|device_node
op_star
id|head
comma
op_star
op_star
id|prevp
comma
op_star
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|head
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
(brace
op_star
id|prevp
op_assign
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|np-&gt;next
suffix:semicolon
)brace
op_star
id|prevp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|head
suffix:semicolon
)brace
multiline_comment|/* Checks if the given &quot;compat&quot; string matches one of the strings in&n; * the device&squot;s &quot;compatible&quot; property&n; */
r_int
DECL|function|device_is_compatible
id|device_is_compatible
c_func
(paren
r_struct
id|device_node
op_star
id|device
comma
r_const
r_char
op_star
id|compat
)paren
(brace
r_const
r_char
op_star
id|cp
suffix:semicolon
r_int
id|cplen
comma
id|l
suffix:semicolon
id|cp
op_assign
(paren
r_char
op_star
)paren
id|get_property
c_func
(paren
id|device
comma
l_string|&quot;compatible&quot;
comma
op_amp
id|cplen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cplen
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|strncasecmp
c_func
(paren
id|cp
comma
id|compat
comma
id|strlen
c_func
(paren
id|compat
)paren
)paren
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|l
op_assign
id|strlen
c_func
(paren
id|cp
)paren
op_plus
l_int|1
suffix:semicolon
id|cp
op_add_assign
id|l
suffix:semicolon
id|cplen
op_sub_assign
id|l
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Indicates whether the root node has a given value in its&n; * compatible property.&n; */
r_int
DECL|function|machine_is_compatible
id|machine_is_compatible
c_func
(paren
r_const
r_char
op_star
id|compat
)paren
(brace
r_struct
id|device_node
op_star
id|root
suffix:semicolon
id|root
op_assign
id|find_path_device
c_func
(paren
l_string|&quot;/&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|root
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|device_is_compatible
c_func
(paren
id|root
comma
id|compat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Construct and return a list of the device_nodes with a given type&n; * and compatible property.&n; */
r_struct
id|device_node
op_star
DECL|function|find_compatible_devices
id|find_compatible_devices
c_func
(paren
r_const
r_char
op_star
id|type
comma
r_const
r_char
op_star
id|compat
)paren
(brace
r_struct
id|device_node
op_star
id|head
comma
op_star
op_star
id|prevp
comma
op_star
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|head
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
(brace
r_if
c_cond
(paren
id|type
op_ne
l_int|NULL
op_logical_and
op_logical_neg
(paren
id|np-&gt;type
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;type
comma
id|type
)paren
op_eq
l_int|0
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|device_is_compatible
c_func
(paren
id|np
comma
id|compat
)paren
)paren
(brace
op_star
id|prevp
op_assign
id|np
suffix:semicolon
id|prevp
op_assign
op_amp
id|np-&gt;next
suffix:semicolon
)brace
)brace
op_star
id|prevp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|head
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the device_node with a given full_name.&n; */
r_struct
id|device_node
op_star
DECL|function|find_path_device
id|find_path_device
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
r_if
c_cond
(paren
id|np-&gt;full_name
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;full_name
comma
id|path
)paren
op_eq
l_int|0
)paren
r_return
id|np
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*******&n; *&n; * New implementation of the OF &quot;find&quot; APIs, return a refcounted&n; * object, call of_node_put() when done. Currently, still lacks&n; * locking as old implementation, this is beeing done for ppc64.&n; *&n; * Note that property management will need some locking as well,&n; * this isn&squot;t dealt with yet&n; *&n; *******/
multiline_comment|/**&n; *&t;of_find_node_by_name - Find a node by it&squot;s &quot;name&quot; property&n; *&t;@from:&t;The node to start searching from or NULL, the node&n; *&t;&t;you pass will not be searched, only the next one&n; *&t;&t;will; typically, you pass what the previous call&n; *&t;&t;returned. of_node_put() will be called on it&n; *&t;@name:&t;The name string to match against&n; *&n; *&t;Returns a node pointer with refcount incremented, use&n; *&t;of_node_put() on it when done.&n; */
DECL|function|of_find_node_by_name
r_struct
id|device_node
op_star
id|of_find_node_by_name
c_func
(paren
r_struct
id|device_node
op_star
id|from
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|device_node
op_star
id|np
op_assign
id|from
ques
c_cond
id|from-&gt;allnext
suffix:colon
id|allnodes
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
r_if
c_cond
(paren
id|np-&gt;name
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;name
comma
id|name
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|from
)paren
id|of_node_put
c_func
(paren
id|from
)paren
suffix:semicolon
r_return
id|of_node_get
c_func
(paren
id|np
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;of_find_node_by_type - Find a node by it&squot;s &quot;device_type&quot; property&n; *&t;@from:&t;The node to start searching from or NULL, the node&n; *&t;&t;you pass will not be searched, only the next one&n; *&t;&t;will; typically, you pass what the previous call&n; *&t;&t;returned. of_node_put() will be called on it&n; *&t;@name:&t;The type string to match against&n; *&n; *&t;Returns a node pointer with refcount incremented, use&n; *&t;of_node_put() on it when done.&n; */
DECL|function|of_find_node_by_type
r_struct
id|device_node
op_star
id|of_find_node_by_type
c_func
(paren
r_struct
id|device_node
op_star
id|from
comma
r_const
r_char
op_star
id|type
)paren
(brace
r_struct
id|device_node
op_star
id|np
op_assign
id|from
ques
c_cond
id|from-&gt;allnext
suffix:colon
id|allnodes
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
r_if
c_cond
(paren
id|np-&gt;type
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;type
comma
id|type
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|from
)paren
id|of_node_put
c_func
(paren
id|from
)paren
suffix:semicolon
r_return
id|of_node_get
c_func
(paren
id|np
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;of_find_compatible_node - Find a node based on type and one of the&n; *                                tokens in it&squot;s &quot;compatible&quot; property&n; *&t;@from:&t;&t;The node to start searching from or NULL, the node&n; *&t;&t;&t;you pass will not be searched, only the next one&n; *&t;&t;&t;will; typically, you pass what the previous call&n; *&t;&t;&t;returned. of_node_put() will be called on it&n; *&t;@type:&t;&t;The type string to match &quot;device_type&quot; or NULL to ignore&n; *&t;@compatible:&t;The string to match to one of the tokens in the device&n; *&t;&t;&t;&quot;compatible&quot; list.&n; *&n; *&t;Returns a node pointer with refcount incremented, use&n; *&t;of_node_put() on it when done.&n; */
DECL|function|of_find_compatible_node
r_struct
id|device_node
op_star
id|of_find_compatible_node
c_func
(paren
r_struct
id|device_node
op_star
id|from
comma
r_const
r_char
op_star
id|type
comma
r_const
r_char
op_star
id|compatible
)paren
(brace
r_struct
id|device_node
op_star
id|np
op_assign
id|from
ques
c_cond
id|from-&gt;allnext
suffix:colon
id|allnodes
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
(brace
r_if
c_cond
(paren
id|type
op_ne
l_int|NULL
op_logical_and
op_logical_neg
(paren
id|np-&gt;type
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;type
comma
id|type
)paren
op_eq
l_int|0
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|device_is_compatible
c_func
(paren
id|np
comma
id|compatible
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|from
)paren
id|of_node_put
c_func
(paren
id|from
)paren
suffix:semicolon
r_return
id|of_node_get
c_func
(paren
id|np
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;of_find_node_by_path - Find a node matching a full OF path&n; *&t;@path:&t;The full path to match&n; *&n; *&t;Returns a node pointer with refcount incremented, use&n; *&t;of_node_put() on it when done.&n; */
DECL|function|of_find_node_by_path
r_struct
id|device_node
op_star
id|of_find_node_by_path
c_func
(paren
r_const
r_char
op_star
id|path
)paren
(brace
r_struct
id|device_node
op_star
id|np
op_assign
id|allnodes
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
r_if
c_cond
(paren
id|np-&gt;full_name
op_ne
l_int|0
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;full_name
comma
id|path
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_return
id|of_node_get
c_func
(paren
id|np
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;of_find_all_nodes - Get next node in global list&n; *&t;@prev:&t;Previous node or NULL to start iteration&n; *&t;&t;of_node_put() will be called on it&n; *&n; *&t;Returns a node pointer with refcount incremented, use&n; *&t;of_node_put() on it when done.&n; */
DECL|function|of_find_all_nodes
r_struct
id|device_node
op_star
id|of_find_all_nodes
c_func
(paren
r_struct
id|device_node
op_star
id|prev
)paren
(brace
r_return
id|of_node_get
c_func
(paren
id|prev
ques
c_cond
id|prev-&gt;allnext
suffix:colon
id|allnodes
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;of_get_parent - Get a node&squot;s parent if any&n; *&t;@node:&t;Node to get parent&n; *&n; *&t;Returns a node pointer with refcount incremented, use&n; *&t;of_node_put() on it when done.&n; */
DECL|function|of_get_parent
r_struct
id|device_node
op_star
id|of_get_parent
c_func
(paren
r_const
r_struct
id|device_node
op_star
id|node
)paren
(brace
r_return
id|node
ques
c_cond
id|of_node_get
c_func
(paren
id|node-&gt;parent
)paren
suffix:colon
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;of_get_next_child - Iterate a node childs&n; *&t;@node:&t;parent node&n; *&t;@prev:&t;previous child of the parent node, or NULL to get first&n; *&n; *&t;Returns a node pointer with refcount incremented, use&n; *&t;of_node_put() on it when done.&n; */
DECL|function|of_get_next_child
r_struct
id|device_node
op_star
id|of_get_next_child
c_func
(paren
r_const
r_struct
id|device_node
op_star
id|node
comma
r_struct
id|device_node
op_star
id|prev
)paren
(brace
r_struct
id|device_node
op_star
id|next
op_assign
id|prev
ques
c_cond
id|prev-&gt;sibling
suffix:colon
id|node-&gt;child
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|next
op_ne
l_int|0
suffix:semicolon
id|next
op_assign
id|next-&gt;sibling
)paren
r_if
c_cond
(paren
id|of_node_get
c_func
(paren
id|next
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
id|of_node_put
c_func
(paren
id|prev
)paren
suffix:semicolon
r_return
id|next
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;of_node_get - Increment refcount of a node&n; *&t;@node:&t;Node to inc refcount, NULL is supported to&n; *&t;&t;simplify writing of callers&n; *&n; *&t;Returns the node itself or NULL if gone. Current implementation&n; *&t;does nothing as we don&squot;t yet do dynamic node allocation on ppc32&n; */
DECL|function|of_node_get
r_struct
id|device_node
op_star
id|of_node_get
c_func
(paren
r_struct
id|device_node
op_star
id|node
)paren
(brace
r_return
id|node
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;of_node_put - Decrement refcount of a node&n; *&t;@node:&t;Node to dec refcount, NULL is supported to&n; *&t;&t;simplify writing of callers&n; *&n; *&t;Current implementation does nothing as we don&squot;t yet do dynamic node&n; *&t;allocation on ppc32&n; */
DECL|function|of_node_put
r_void
id|of_node_put
c_func
(paren
r_struct
id|device_node
op_star
id|node
)paren
(brace
)brace
multiline_comment|/*&n; * Find the device_node with a given phandle.&n; */
r_static
r_struct
id|device_node
op_star
id|__init
DECL|function|find_phandle
id|find_phandle
c_func
(paren
id|phandle
id|ph
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
id|allnodes
suffix:semicolon
id|np
op_ne
l_int|0
suffix:semicolon
id|np
op_assign
id|np-&gt;allnext
)paren
r_if
c_cond
(paren
id|np-&gt;node
op_eq
id|ph
)paren
r_return
id|np
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Find a property with a given name for a given node&n; * and return the value.&n; */
r_int
r_char
op_star
DECL|function|get_property
id|get_property
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_const
r_char
op_star
id|name
comma
r_int
op_star
id|lenp
)paren
(brace
r_struct
id|property
op_star
id|pp
suffix:semicolon
r_for
c_loop
(paren
id|pp
op_assign
id|np-&gt;properties
suffix:semicolon
id|pp
op_ne
l_int|0
suffix:semicolon
id|pp
op_assign
id|pp-&gt;next
)paren
r_if
c_cond
(paren
id|pp-&gt;name
op_ne
l_int|NULL
op_logical_and
id|strcmp
c_func
(paren
id|pp-&gt;name
comma
id|name
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|lenp
op_ne
l_int|0
)paren
op_star
id|lenp
op_assign
id|pp-&gt;length
suffix:semicolon
r_return
id|pp-&gt;value
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a property to a node&n; */
r_void
id|__openfirmware
DECL|function|prom_add_property
id|prom_add_property
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_struct
id|property
op_star
id|prop
)paren
(brace
r_struct
id|property
op_star
op_star
id|next
op_assign
op_amp
id|np-&gt;properties
suffix:semicolon
id|prop-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
op_star
id|next
)paren
id|next
op_assign
op_amp
(paren
op_star
id|next
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
op_star
id|next
op_assign
id|prop
suffix:semicolon
)brace
multiline_comment|/* I quickly hacked that one, check against spec ! */
r_static
r_inline
r_int
r_int
id|__openfirmware
DECL|function|bus_space_to_resource_flags
id|bus_space_to_resource_flags
c_func
(paren
r_int
r_int
id|bus_space
)paren
(brace
id|u8
id|space
op_assign
(paren
id|bus_space
op_rshift
l_int|24
)paren
op_amp
l_int|0xf
suffix:semicolon
r_if
c_cond
(paren
id|space
op_eq
l_int|0
)paren
id|space
op_assign
l_int|0x02
suffix:semicolon
r_if
c_cond
(paren
id|space
op_eq
l_int|0x02
)paren
r_return
id|IORESOURCE_MEM
suffix:semicolon
r_else
r_if
c_cond
(paren
id|space
op_eq
l_int|0x01
)paren
r_return
id|IORESOURCE_IO
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;prom.c: bus_space_to_resource_flags(), space: %x&bslash;n&quot;
comma
id|bus_space
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_static
r_struct
id|resource
op_star
id|__openfirmware
DECL|function|find_parent_pci_resource
id|find_parent_pci_resource
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_struct
id|address_range
op_star
id|range
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Check this one */
id|mask
op_assign
id|bus_space_to_resource_flags
c_func
(paren
id|range-&gt;space
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEVICE_COUNT_RESOURCE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|pdev-&gt;resource
(braket
id|i
)braket
dot
id|flags
op_amp
id|mask
)paren
op_eq
id|mask
op_logical_and
id|pdev-&gt;resource
(braket
id|i
)braket
dot
id|start
op_le
id|range-&gt;address
op_logical_and
id|pdev-&gt;resource
(braket
id|i
)braket
dot
id|end
OG
id|range-&gt;address
)paren
(brace
r_if
c_cond
(paren
(paren
id|range-&gt;address
op_plus
id|range-&gt;size
op_minus
l_int|1
)paren
OG
id|pdev-&gt;resource
(braket
id|i
)braket
dot
id|end
)paren
(brace
multiline_comment|/* Add better message */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;PCI/OF resource overlap !&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_eq
id|DEVICE_COUNT_RESOURCE
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
op_amp
id|pdev-&gt;resource
(braket
id|i
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * Request an OF device resource. Currently handles child of PCI devices,&n; * or other nodes attached to the root node. Ultimately, put some&n; * link to resources in the OF node.&n; */
r_struct
id|resource
op_star
id|__openfirmware
DECL|function|request_OF_resource
id|request_OF_resource
c_func
(paren
r_struct
id|device_node
op_star
id|node
comma
r_int
id|index
comma
r_const
r_char
op_star
id|name_postfix
)paren
(brace
r_struct
id|pci_dev
op_star
id|pcidev
suffix:semicolon
id|u8
id|pci_bus
comma
id|pci_devfn
suffix:semicolon
r_int
r_int
id|iomask
suffix:semicolon
r_struct
id|device_node
op_star
id|nd
suffix:semicolon
r_struct
id|resource
op_star
id|parent
suffix:semicolon
r_struct
id|resource
op_star
id|res
op_assign
l_int|NULL
suffix:semicolon
r_int
id|nlen
comma
id|plen
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
id|node-&gt;n_addrs
)paren
r_goto
id|fail
suffix:semicolon
multiline_comment|/* Sanity check on bus space */
id|iomask
op_assign
id|bus_space_to_resource_flags
c_func
(paren
id|node-&gt;addrs
(braket
id|index
)braket
dot
id|space
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iomask
op_amp
id|IORESOURCE_MEM
)paren
id|parent
op_assign
op_amp
id|iomem_resource
suffix:semicolon
r_else
r_if
c_cond
(paren
id|iomask
op_amp
id|IORESOURCE_IO
)paren
id|parent
op_assign
op_amp
id|ioport_resource
suffix:semicolon
r_else
r_goto
id|fail
suffix:semicolon
multiline_comment|/* Find a PCI parent if any */
id|nd
op_assign
id|node
suffix:semicolon
id|pcidev
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|nd
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pci_device_from_OF_node
c_func
(paren
id|nd
comma
op_amp
id|pci_bus
comma
op_amp
id|pci_devfn
)paren
)paren
id|pcidev
op_assign
id|pci_find_slot
c_func
(paren
id|pci_bus
comma
id|pci_devfn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcidev
)paren
r_break
suffix:semicolon
id|nd
op_assign
id|nd-&gt;parent
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pcidev
)paren
id|parent
op_assign
id|find_parent_pci_resource
c_func
(paren
id|pcidev
comma
op_amp
id|node-&gt;addrs
(braket
id|index
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;request_OF_resource(%s), parent not found&bslash;n&quot;
comma
id|node-&gt;name
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|res
op_assign
id|__request_region
c_func
(paren
id|parent
comma
id|node-&gt;addrs
(braket
id|index
)braket
dot
id|address
comma
id|node-&gt;addrs
(braket
id|index
)braket
dot
id|size
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
r_goto
id|fail
suffix:semicolon
id|nlen
op_assign
id|strlen
c_func
(paren
id|node-&gt;name
)paren
suffix:semicolon
id|plen
op_assign
id|name_postfix
ques
c_cond
id|strlen
c_func
(paren
id|name_postfix
)paren
suffix:colon
l_int|0
suffix:semicolon
id|res-&gt;name
op_assign
(paren
r_const
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|nlen
op_plus
id|plen
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res-&gt;name
)paren
(brace
id|strcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|res-&gt;name
comma
id|node-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|plen
)paren
id|strcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|res-&gt;name
op_plus
id|nlen
comma
id|name_postfix
)paren
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
id|fail
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
r_int
id|__openfirmware
DECL|function|release_OF_resource
id|release_OF_resource
c_func
(paren
r_struct
id|device_node
op_star
id|node
comma
r_int
id|index
)paren
(brace
r_struct
id|pci_dev
op_star
id|pcidev
suffix:semicolon
id|u8
id|pci_bus
comma
id|pci_devfn
suffix:semicolon
r_int
r_int
id|iomask
comma
id|start
comma
id|end
suffix:semicolon
r_struct
id|device_node
op_star
id|nd
suffix:semicolon
r_struct
id|resource
op_star
id|parent
suffix:semicolon
r_struct
id|resource
op_star
id|res
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
id|node-&gt;n_addrs
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Sanity check on bus space */
id|iomask
op_assign
id|bus_space_to_resource_flags
c_func
(paren
id|node-&gt;addrs
(braket
id|index
)braket
dot
id|space
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iomask
op_amp
id|IORESOURCE_MEM
)paren
id|parent
op_assign
op_amp
id|iomem_resource
suffix:semicolon
r_else
r_if
c_cond
(paren
id|iomask
op_amp
id|IORESOURCE_IO
)paren
id|parent
op_assign
op_amp
id|ioport_resource
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Find a PCI parent if any */
id|nd
op_assign
id|node
suffix:semicolon
id|pcidev
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|nd
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pci_device_from_OF_node
c_func
(paren
id|nd
comma
op_amp
id|pci_bus
comma
op_amp
id|pci_devfn
)paren
)paren
id|pcidev
op_assign
id|pci_find_slot
c_func
(paren
id|pci_bus
comma
id|pci_devfn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcidev
)paren
r_break
suffix:semicolon
id|nd
op_assign
id|nd-&gt;parent
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pcidev
)paren
id|parent
op_assign
id|find_parent_pci_resource
c_func
(paren
id|pcidev
comma
op_amp
id|node-&gt;addrs
(braket
id|index
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;release_OF_resource(%s), parent not found&bslash;n&quot;
comma
id|node-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* Find us in the parent and its childs */
id|res
op_assign
id|parent-&gt;child
suffix:semicolon
id|start
op_assign
id|node-&gt;addrs
(braket
id|index
)braket
dot
id|address
suffix:semicolon
id|end
op_assign
id|start
op_plus
id|node-&gt;addrs
(braket
id|index
)braket
dot
id|size
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|res
)paren
(brace
r_if
c_cond
(paren
id|res-&gt;start
op_eq
id|start
op_logical_and
id|res-&gt;end
op_eq
id|end
op_logical_and
(paren
id|res-&gt;flags
op_amp
id|IORESOURCE_BUSY
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|res-&gt;start
op_le
id|start
op_logical_and
id|res-&gt;end
op_ge
id|end
)paren
id|res
op_assign
id|res-&gt;child
suffix:semicolon
r_else
id|res
op_assign
id|res-&gt;sibling
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|res-&gt;name
)paren
(brace
id|kfree
c_func
(paren
id|res-&gt;name
)paren
suffix:semicolon
id|res-&gt;name
op_assign
l_int|NULL
suffix:semicolon
)brace
id|release_resource
c_func
(paren
id|res
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|res
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if 0
r_void
id|__openfirmware
id|print_properties
c_func
(paren
r_struct
id|device_node
op_star
id|np
)paren
(brace
r_struct
id|property
op_star
id|pp
suffix:semicolon
r_char
op_star
id|cp
suffix:semicolon
r_int
id|i
comma
id|n
suffix:semicolon
r_for
c_loop
(paren
id|pp
op_assign
id|np-&gt;properties
suffix:semicolon
id|pp
op_ne
l_int|0
suffix:semicolon
id|pp
op_assign
id|pp-&gt;next
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s&quot;
comma
id|pp-&gt;name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|strlen
c_func
(paren
id|pp-&gt;name
)paren
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
op_increment
id|i
)paren
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|cp
op_assign
(paren
r_char
op_star
)paren
id|pp-&gt;value
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|pp-&gt;length
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
comma
op_increment
id|cp
)paren
r_if
c_cond
(paren
(paren
id|i
OG
l_int|1
op_logical_and
(paren
op_star
id|cp
template_param
l_int|0x7e
)paren
)paren
op_logical_or
(paren
id|i
op_eq
l_int|1
op_logical_and
op_star
id|cp
op_ne
l_int|0
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
op_logical_and
id|pp-&gt;length
OG
l_int|1
)paren
(brace
multiline_comment|/* looks like a string */
id|printk
c_func
(paren
l_string|&quot; %s&bslash;n&quot;
comma
(paren
r_char
op_star
)paren
id|pp-&gt;value
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* dump it in hex */
id|n
op_assign
id|pp-&gt;length
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|64
)paren
id|n
op_assign
l_int|64
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;length
op_mod
l_int|4
op_eq
l_int|0
)paren
(brace
r_int
r_int
op_star
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
id|pp-&gt;value
suffix:semicolon
id|n
op_div_assign
l_int|4
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|i
op_ne
l_int|0
op_logical_and
(paren
id|i
op_mod
l_int|4
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n                &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %08x&quot;
comma
op_star
id|p
op_increment
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
r_char
op_star
id|bp
op_assign
id|pp-&gt;value
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|i
op_ne
l_int|0
op_logical_and
(paren
id|i
op_mod
l_int|16
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n                &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %02x&quot;
comma
op_star
id|bp
op_increment
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;length
OG
l_int|64
)paren
id|printk
c_func
(paren
l_string|&quot;                 ... (length = %d)&bslash;n&quot;
comma
id|pp-&gt;length
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
DECL|variable|rtas_lock
r_static
id|spinlock_t
id|rtas_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* this can be called after setup -- Cort */
r_int
id|__openfirmware
DECL|function|call_rtas
id|call_rtas
c_func
(paren
r_const
r_char
op_star
id|service
comma
r_int
id|nargs
comma
r_int
id|nret
comma
r_int
r_int
op_star
id|outputs
comma
dot
dot
dot
)paren
(brace
id|va_list
id|list
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
r_struct
id|device_node
op_star
id|rtas
suffix:semicolon
r_int
op_star
id|tokp
suffix:semicolon
r_union
(brace
r_int
r_int
id|words
(braket
l_int|16
)braket
suffix:semicolon
r_float
id|align
suffix:semicolon
)brace
id|u
suffix:semicolon
id|rtas
op_assign
id|find_devices
c_func
(paren
l_string|&quot;rtas&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtas
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|tokp
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|rtas
comma
id|service
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tokp
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;No RTAS service called %s&bslash;n&quot;
comma
id|service
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|u.words
(braket
l_int|0
)braket
op_assign
op_star
id|tokp
suffix:semicolon
id|u.words
(braket
l_int|1
)braket
op_assign
id|nargs
suffix:semicolon
id|u.words
(braket
l_int|2
)braket
op_assign
id|nret
suffix:semicolon
id|va_start
c_func
(paren
id|list
comma
id|outputs
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nargs
suffix:semicolon
op_increment
id|i
)paren
id|u.words
(braket
id|i
op_plus
l_int|3
)braket
op_assign
id|va_arg
c_func
(paren
id|list
comma
r_int
r_int
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|list
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * RTAS doesn&squot;t use floating point.&n;&t; * Or at least, according to the CHRP spec we enter RTAS&n;&t; * with FP disabled, and it doesn&squot;t change the FP registers.&n;&t; *  -- paulus.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|rtas_lock
comma
id|s
)paren
suffix:semicolon
id|enter_rtas
c_func
(paren
(paren
r_void
op_star
)paren
id|__pa
c_func
(paren
op_amp
id|u
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|rtas_lock
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nret
OG
l_int|1
op_logical_and
id|outputs
op_ne
l_int|NULL
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nret
op_minus
l_int|1
suffix:semicolon
op_increment
id|i
)paren
id|outputs
(braket
id|i
)braket
op_assign
id|u.words
(braket
id|i
op_plus
id|nargs
op_plus
l_int|4
)braket
suffix:semicolon
r_return
id|u.words
(braket
id|nargs
op_plus
l_int|3
)braket
suffix:semicolon
)brace
eof
