multiline_comment|/*&n; * General Purpose functions for the global management of the&n; * 8260 Communication Processor Module.&n; * Copyright (c) 1999 Dan Malek (dmalek@jlc.net)&n; * Copyright (c) 2000 MontaVista Software, Inc (source@mvista.com)&n; *&t;2.3.99 Updates&n; *&n; * In addition to the individual control of the communication&n; * channels, there are a few functions that globally affect the&n; * communication processor.&n; *&n; * Buffer descriptors must be allocated from the dual ported memory&n; * space.  The allocator for that is here.  When the communication&n; * process is reset, we reclaim the memory available.  There is&n; * currently no deallocator for this memory.&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/param.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/mpc8260.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/immap_cpm2.h&gt;
macro_line|#include &lt;asm/cpm2.h&gt;
macro_line|#include &lt;asm/rheap.h&gt;
r_static
r_void
id|cpm2_dpinit
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|cpmp
id|cpm_cpm2_t
op_star
id|cpmp
suffix:semicolon
multiline_comment|/* Pointer to comm processor space */
multiline_comment|/* We allocate this here because it is used almost exclusively for&n; * the communication processor devices.&n; */
DECL|variable|cpm2_immr
id|cpm2_map_t
op_star
id|cpm2_immr
suffix:semicolon
r_void
DECL|function|cpm2_reset
id|cpm2_reset
c_func
(paren
r_void
)paren
(brace
id|cpm2_immr
op_assign
(paren
id|cpm2_map_t
op_star
)paren
id|CPM_MAP_ADDR
suffix:semicolon
multiline_comment|/* Reclaim the DP memory for our use.&n;&t; */
id|cpm2_dpinit
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Tell everyone where the comm processor resides.&n;&t; */
id|cpmp
op_assign
op_amp
id|cpm2_immr-&gt;im_cpm
suffix:semicolon
)brace
multiline_comment|/* Set a baud rate generator.  This needs lots of work.  There are&n; * eight BRGs, which can be connected to the CPM channels or output&n; * as clocks.  The BRGs are in two different block of internal&n; * memory mapped space.&n; * The baud rate clock is the system clock divided by something.&n; * It was set up long ago during the initial boot phase and is&n; * is given to us.&n; * Baud rate clocks are zero-based in the driver code (as that maps&n; * to port numbers).  Documentation uses 1-based numbering.&n; */
DECL|macro|BRG_INT_CLK
mdefine_line|#define BRG_INT_CLK&t;(((bd_t *)__res)-&gt;bi_brgfreq)
DECL|macro|BRG_UART_CLK
mdefine_line|#define BRG_UART_CLK&t;(BRG_INT_CLK/16)
multiline_comment|/* This function is used by UARTS, or anything else that uses a 16x&n; * oversampled clock.&n; */
r_void
DECL|function|cpm2_setbrg
id|cpm2_setbrg
c_func
(paren
id|uint
id|brg
comma
id|uint
id|rate
)paren
(brace
r_volatile
id|uint
op_star
id|bp
suffix:semicolon
multiline_comment|/* This is good enough to get SMCs running.....&n;&t;*/
r_if
c_cond
(paren
id|brg
OL
l_int|4
)paren
(brace
id|bp
op_assign
(paren
id|uint
op_star
)paren
op_amp
id|cpm2_immr-&gt;im_brgc1
suffix:semicolon
)brace
r_else
(brace
id|bp
op_assign
(paren
id|uint
op_star
)paren
op_amp
id|cpm2_immr-&gt;im_brgc5
suffix:semicolon
id|brg
op_sub_assign
l_int|4
suffix:semicolon
)brace
id|bp
op_add_assign
id|brg
suffix:semicolon
op_star
id|bp
op_assign
(paren
(paren
id|BRG_UART_CLK
op_div
id|rate
)paren
op_lshift
l_int|1
)paren
op_or
id|CPM_BRG_EN
suffix:semicolon
)brace
multiline_comment|/* This function is used to set high speed synchronous baud rate&n; * clocks.&n; */
r_void
DECL|function|cpm2_fastbrg
id|cpm2_fastbrg
c_func
(paren
id|uint
id|brg
comma
id|uint
id|rate
comma
r_int
id|div16
)paren
(brace
r_volatile
id|uint
op_star
id|bp
suffix:semicolon
r_if
c_cond
(paren
id|brg
OL
l_int|4
)paren
(brace
id|bp
op_assign
(paren
id|uint
op_star
)paren
op_amp
id|cpm2_immr-&gt;im_brgc1
suffix:semicolon
)brace
r_else
(brace
id|bp
op_assign
(paren
id|uint
op_star
)paren
op_amp
id|cpm2_immr-&gt;im_brgc5
suffix:semicolon
id|brg
op_sub_assign
l_int|4
suffix:semicolon
)brace
id|bp
op_add_assign
id|brg
suffix:semicolon
op_star
id|bp
op_assign
(paren
(paren
id|BRG_INT_CLK
op_div
id|rate
)paren
op_lshift
l_int|1
)paren
op_or
id|CPM_BRG_EN
suffix:semicolon
r_if
c_cond
(paren
id|div16
)paren
op_star
id|bp
op_or_assign
id|CPM_BRG_DIV16
suffix:semicolon
)brace
multiline_comment|/*&n; * dpalloc / dpfree bits.&n; */
DECL|variable|cpm_dpmem_lock
r_static
id|spinlock_t
id|cpm_dpmem_lock
suffix:semicolon
multiline_comment|/* 16 blocks should be enough to satisfy all requests&n; * until the memory subsystem goes up... */
DECL|variable|cpm_boot_dpmem_rh_block
r_static
id|rh_block_t
id|cpm_boot_dpmem_rh_block
(braket
l_int|16
)braket
suffix:semicolon
DECL|variable|cpm_dpmem_info
r_static
id|rh_info_t
id|cpm_dpmem_info
suffix:semicolon
DECL|function|cpm2_dpinit
r_static
r_void
id|cpm2_dpinit
c_func
(paren
r_void
)paren
(brace
r_void
op_star
id|dprambase
op_assign
op_amp
(paren
(paren
id|cpm2_map_t
op_star
)paren
id|CPM_MAP_ADDR
)paren
op_member_access_from_pointer
id|im_dprambase
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|cpm_dpmem_lock
)paren
suffix:semicolon
multiline_comment|/* initialize the info header */
id|rh_init
c_func
(paren
op_amp
id|cpm_dpmem_info
comma
l_int|1
comma
r_sizeof
(paren
id|cpm_boot_dpmem_rh_block
)paren
op_div
r_sizeof
(paren
id|cpm_boot_dpmem_rh_block
(braket
l_int|0
)braket
)paren
comma
id|cpm_boot_dpmem_rh_block
)paren
suffix:semicolon
multiline_comment|/* Attach the usable dpmem area */
multiline_comment|/* XXX: This is actually crap. CPM_DATAONLY_BASE and&n;&t; * CPM_DATAONLY_SIZE is only a subset of the available dpram. It&n;&t; * varies with the processor and the microcode patches activated.&n;&t; * But the following should be at least safe.&n;&t; */
id|rh_attach_region
c_func
(paren
op_amp
id|cpm_dpmem_info
comma
id|dprambase
op_plus
id|CPM_DATAONLY_BASE
comma
id|CPM_DATAONLY_SIZE
)paren
suffix:semicolon
)brace
multiline_comment|/* This function used to return an index into the DPRAM area.&n; * Now it returns the actuall physical address of that area.&n; * use cpm2_dpram_offset() to get the index&n; */
DECL|function|cpm2_dpalloc
r_void
op_star
id|cpm2_dpalloc
c_func
(paren
id|uint
id|size
comma
id|uint
id|align
)paren
(brace
r_void
op_star
id|start
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cpm_dpmem_lock
comma
id|flags
)paren
suffix:semicolon
id|cpm_dpmem_info.alignment
op_assign
id|align
suffix:semicolon
id|start
op_assign
id|rh_alloc
c_func
(paren
op_amp
id|cpm_dpmem_info
comma
id|size
comma
l_string|&quot;commproc&quot;
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cpm_dpmem_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|start
suffix:semicolon
)brace
DECL|variable|cpm2_dpalloc
id|EXPORT_SYMBOL
c_func
(paren
id|cpm2_dpalloc
)paren
suffix:semicolon
DECL|function|cpm2_dpfree
r_int
id|cpm2_dpfree
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cpm_dpmem_lock
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|rh_free
c_func
(paren
op_amp
id|cpm_dpmem_info
comma
id|addr
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cpm_dpmem_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|cpm2_dpfree
id|EXPORT_SYMBOL
c_func
(paren
id|cpm2_dpfree
)paren
suffix:semicolon
multiline_comment|/* not sure if this is ever needed */
DECL|function|cpm2_dpalloc_fixed
r_void
op_star
id|cpm2_dpalloc_fixed
c_func
(paren
r_void
op_star
id|addr
comma
id|uint
id|size
comma
id|uint
id|align
)paren
(brace
r_void
op_star
id|start
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cpm_dpmem_lock
comma
id|flags
)paren
suffix:semicolon
id|cpm_dpmem_info.alignment
op_assign
id|align
suffix:semicolon
id|start
op_assign
id|rh_alloc_fixed
c_func
(paren
op_amp
id|cpm_dpmem_info
comma
id|addr
comma
id|size
comma
l_string|&quot;commproc&quot;
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|cpm_dpmem_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|start
suffix:semicolon
)brace
DECL|variable|cpm2_dpalloc_fixed
id|EXPORT_SYMBOL
c_func
(paren
id|cpm2_dpalloc_fixed
)paren
suffix:semicolon
DECL|function|cpm2_dpdump
r_void
id|cpm2_dpdump
c_func
(paren
r_void
)paren
(brace
id|rh_dump
c_func
(paren
op_amp
id|cpm_dpmem_info
)paren
suffix:semicolon
)brace
DECL|variable|cpm2_dpdump
id|EXPORT_SYMBOL
c_func
(paren
id|cpm2_dpdump
)paren
suffix:semicolon
DECL|function|cpm2_dpram_offset
id|uint
id|cpm2_dpram_offset
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
r_return
(paren
id|uint
)paren
(paren
(paren
id|u_char
op_star
)paren
id|addr
op_minus
(paren
(paren
id|uint
)paren
(paren
(paren
id|cpm2_map_t
op_star
)paren
id|CPM_MAP_ADDR
)paren
op_member_access_from_pointer
id|im_dprambase
)paren
)paren
suffix:semicolon
)brace
DECL|variable|cpm2_dpram_offset
id|EXPORT_SYMBOL
c_func
(paren
id|cpm2_dpram_offset
)paren
suffix:semicolon
DECL|function|cpm2_dpram_addr
r_void
op_star
id|cpm2_dpram_addr
c_func
(paren
r_int
id|offset
)paren
(brace
r_return
(paren
r_void
op_star
)paren
op_amp
(paren
(paren
id|cpm2_map_t
op_star
)paren
id|CPM_MAP_ADDR
)paren
op_member_access_from_pointer
id|im_dprambase
(braket
id|offset
)braket
suffix:semicolon
)brace
DECL|variable|cpm2_dpram_addr
id|EXPORT_SYMBOL
c_func
(paren
id|cpm2_dpram_addr
)paren
suffix:semicolon
eof
