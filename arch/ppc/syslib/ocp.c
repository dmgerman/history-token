multiline_comment|/*&n; * ocp.c&n; *&n; *      (c) Benjamin Herrenschmidt (benh@kernel.crashing.org)&n; *          Mipsys - France&n; *&n; *          Derived from work (c) Armin Kuster akuster@pacbell.net&n; *&n; *          Additional support and port to 2.6 LDM/sysfs by&n; *          Matt Porter &lt;mporter@kernel.crashing.org&gt;&n; *          Copyright 2004 MontaVista Software, Inc.&n; *&n; *  This program is free software; you can redistribute  it and/or modify it&n; *  under  the terms of  the GNU General Public License as published by the&n; *  Free Software Foundation;  either version 2 of the  License, or (at your&n; *  option) any later version.&n; *&n; *  OCP (On Chip Peripheral) is a software emulated &quot;bus&quot; with a&n; *  pseudo discovery method for dumb peripherals. Usually these type&n; *  of peripherals are found on embedded SoC (System On a Chip)&n; *  processors or highly integrated system controllers that have&n; *  a host bridge and many peripherals.  Common examples where&n; *  this is already used include the PPC4xx, PPC85xx, MPC52xx,&n; *  and MV64xxx parts.&n; *&n; *  This subsystem creates a standard OCP bus type within the&n; *  device model.  The devices on the OCP bus are seeded by an&n; *  an initial OCP device array created by the arch-specific&n; *  Device entries can be added/removed/modified through OCP&n; *  helper functions to accomodate system and  board-specific&n; *  parameters commonly found in embedded systems. OCP also&n; *  provides a standard method for devices to describe extended&n; *  attributes about themselves to the system.  A standard access&n; *  method allows OCP drivers to obtain the information, both&n; *  SoC-specific and system/board-specific, needed for operation.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/pm.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/ocp.h&gt;
macro_line|#include &lt;asm/errno.h&gt;
macro_line|#include &lt;asm/rwsem.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
singleline_comment|//#define DBG(x)&t;printk x
DECL|macro|DBG
mdefine_line|#define DBG(x)
r_extern
r_int
id|mem_init_done
suffix:semicolon
r_extern
r_struct
id|ocp_def
id|core_ocp
(braket
)braket
suffix:semicolon
multiline_comment|/* Static list of devices, provided by&n;&t;&t;&t;&t;&t;   CPU core */
DECL|variable|ocp_devices
id|LIST_HEAD
c_func
(paren
id|ocp_devices
)paren
suffix:semicolon
multiline_comment|/* List of all OCP devices */
DECL|variable|ocp_devices_sem
id|DECLARE_RWSEM
c_func
(paren
id|ocp_devices_sem
)paren
suffix:semicolon
multiline_comment|/* Global semaphores for those lists */
DECL|variable|ocp_inited
r_static
r_int
id|ocp_inited
suffix:semicolon
multiline_comment|/* Sysfs support */
DECL|macro|OCP_DEF_ATTR
mdefine_line|#define OCP_DEF_ATTR(field, format_string)&t;&t;&t;&t;&bslash;&n;static ssize_t&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;show_##field(struct device *dev, char *buf)&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;struct ocp_device *odev = to_ocp_dev(dev);&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;return sprintf(buf, format_string, odev-&gt;def-&gt;field);&t;&t;&bslash;&n;}&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;static DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
id|OCP_DEF_ATTR
c_func
(paren
id|vendor
comma
l_string|&quot;0x%04x&bslash;n&quot;
)paren
suffix:semicolon
id|OCP_DEF_ATTR
c_func
(paren
id|function
comma
l_string|&quot;0x%04x&bslash;n&quot;
)paren
suffix:semicolon
id|OCP_DEF_ATTR
c_func
(paren
id|index
comma
l_string|&quot;0x%04x&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PTE_64BIT
id|OCP_DEF_ATTR
c_func
(paren
id|paddr
comma
l_string|&quot;0x%16Lx&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
id|OCP_DEF_ATTR
c_func
(paren
id|paddr
comma
l_string|&quot;0x%08lx&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|OCP_DEF_ATTR
c_func
(paren
id|irq
comma
l_string|&quot;%d&bslash;n&quot;
)paren
suffix:semicolon
id|OCP_DEF_ATTR
c_func
(paren
id|pm
comma
l_string|&quot;%lu&bslash;n&quot;
)paren
suffix:semicolon
DECL|function|ocp_create_sysfs_dev_files
r_void
id|ocp_create_sysfs_dev_files
c_func
(paren
r_struct
id|ocp_device
op_star
id|odev
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
op_amp
id|odev-&gt;dev
suffix:semicolon
multiline_comment|/* Current OCP device def attributes */
id|device_create_file
c_func
(paren
id|dev
comma
op_amp
id|dev_attr_vendor
)paren
suffix:semicolon
id|device_create_file
c_func
(paren
id|dev
comma
op_amp
id|dev_attr_function
)paren
suffix:semicolon
id|device_create_file
c_func
(paren
id|dev
comma
op_amp
id|dev_attr_index
)paren
suffix:semicolon
id|device_create_file
c_func
(paren
id|dev
comma
op_amp
id|dev_attr_paddr
)paren
suffix:semicolon
id|device_create_file
c_func
(paren
id|dev
comma
op_amp
id|dev_attr_irq
)paren
suffix:semicolon
id|device_create_file
c_func
(paren
id|dev
comma
op_amp
id|dev_attr_pm
)paren
suffix:semicolon
multiline_comment|/* Current OCP device additions attributes */
r_if
c_cond
(paren
id|odev-&gt;def-&gt;additions
op_logical_and
id|odev-&gt;def-&gt;show
)paren
id|odev-&gt;def
op_member_access_from_pointer
id|show
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ocp_device_match&t;-&t;Match one driver to one device&n; *&t;@drv: driver to match&n; *&t;@dev: device to match&n; *&n; *&t;This function returns 0 if the driver and device don&squot;t match&n; */
r_static
r_int
DECL|function|ocp_device_match
id|ocp_device_match
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|device_driver
op_star
id|drv
)paren
(brace
r_struct
id|ocp_device
op_star
id|ocp_dev
op_assign
id|to_ocp_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|ocp_driver
op_star
id|ocp_drv
op_assign
id|to_ocp_drv
c_func
(paren
id|drv
)paren
suffix:semicolon
r_const
r_struct
id|ocp_device_id
op_star
id|ids
op_assign
id|ocp_drv-&gt;id_table
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ids
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|ids-&gt;vendor
op_logical_or
id|ids-&gt;function
)paren
(brace
r_if
c_cond
(paren
(paren
id|ids-&gt;vendor
op_eq
id|OCP_ANY_ID
op_logical_or
id|ids-&gt;vendor
op_eq
id|ocp_dev-&gt;def-&gt;vendor
)paren
op_logical_and
(paren
id|ids-&gt;function
op_eq
id|OCP_ANY_ID
op_logical_or
id|ids-&gt;function
op_eq
id|ocp_dev-&gt;def-&gt;function
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|ids
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|ocp_device_probe
id|ocp_device_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_struct
id|ocp_driver
op_star
id|drv
suffix:semicolon
r_struct
id|ocp_device
op_star
id|ocp_dev
suffix:semicolon
id|drv
op_assign
id|to_ocp_drv
c_func
(paren
id|dev-&gt;driver
)paren
suffix:semicolon
id|ocp_dev
op_assign
id|to_ocp_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;probe
)paren
(brace
id|error
op_assign
id|drv
op_member_access_from_pointer
id|probe
c_func
(paren
id|ocp_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ge
l_int|0
)paren
(brace
id|ocp_dev-&gt;driver
op_assign
id|drv
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|error
suffix:semicolon
)brace
r_static
r_int
DECL|function|ocp_device_remove
id|ocp_device_remove
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|ocp_device
op_star
id|ocp_dev
op_assign
id|to_ocp_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ocp_dev-&gt;driver
)paren
(brace
r_if
c_cond
(paren
id|ocp_dev-&gt;driver-&gt;remove
)paren
id|ocp_dev-&gt;driver
op_member_access_from_pointer
id|remove
c_func
(paren
id|ocp_dev
)paren
suffix:semicolon
id|ocp_dev-&gt;driver
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|ocp_device_suspend
id|ocp_device_suspend
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u32
id|state
)paren
(brace
r_struct
id|ocp_device
op_star
id|ocp_dev
op_assign
id|to_ocp_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|ocp_driver
op_star
id|ocp_drv
op_assign
id|to_ocp_drv
c_func
(paren
id|dev-&gt;driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;driver
op_logical_and
id|ocp_drv-&gt;suspend
)paren
r_return
id|ocp_drv
op_member_access_from_pointer
id|suspend
c_func
(paren
id|ocp_dev
comma
id|state
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|ocp_device_resume
id|ocp_device_resume
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|ocp_device
op_star
id|ocp_dev
op_assign
id|to_ocp_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|ocp_driver
op_star
id|ocp_drv
op_assign
id|to_ocp_drv
c_func
(paren
id|dev-&gt;driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;driver
op_logical_and
id|ocp_drv-&gt;resume
)paren
r_return
id|ocp_drv
op_member_access_from_pointer
id|resume
c_func
(paren
id|ocp_dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ocp_bus_type
r_struct
id|bus_type
id|ocp_bus_type
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ocp&quot;
comma
dot
id|match
op_assign
id|ocp_device_match
comma
dot
id|suspend
op_assign
id|ocp_device_suspend
comma
dot
id|resume
op_assign
id|ocp_device_resume
comma
)brace
suffix:semicolon
multiline_comment|/**&n; *&t;ocp_register_driver&t;-&t;Register an OCP driver&n; *&t;@drv: pointer to statically defined ocp_driver structure&n; *&n; *&t;The driver&squot;s probe() callback is called either recursively&n; *&t;by this function or upon later call of ocp_driver_init&n; *&n; *&t;NOTE: Detection of devices is a 2 pass step on this implementation,&n; *&t;hotswap isn&squot;t supported. First, all OCP devices are put in the device&n; *&t;list, _then_ all drivers are probed on each match.&n; */
r_int
DECL|function|ocp_register_driver
id|ocp_register_driver
c_func
(paren
r_struct
id|ocp_driver
op_star
id|drv
)paren
(brace
r_int
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* initialize common driver fields */
id|drv-&gt;driver.name
op_assign
id|drv-&gt;name
suffix:semicolon
id|drv-&gt;driver.bus
op_assign
op_amp
id|ocp_bus_type
suffix:semicolon
id|drv-&gt;driver.probe
op_assign
id|ocp_device_probe
suffix:semicolon
id|drv-&gt;driver.remove
op_assign
id|ocp_device_remove
suffix:semicolon
multiline_comment|/* register with core */
r_return
id|driver_register
c_func
(paren
op_amp
id|drv-&gt;driver
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ocp_unregister_driver&t;-&t;Unregister an OCP driver&n; *&t;@drv: pointer to statically defined ocp_driver structure&n; *&n; *&t;The driver&squot;s remove() callback is called recursively&n; *&t;by this function for any device already registered&n; */
r_void
DECL|function|ocp_unregister_driver
id|ocp_unregister_driver
c_func
(paren
r_struct
id|ocp_driver
op_star
id|drv
)paren
(brace
id|DBG
c_func
(paren
(paren
l_string|&quot;ocp: ocp_unregister_driver(%s)...&bslash;n&quot;
comma
id|drv-&gt;name
)paren
)paren
suffix:semicolon
id|driver_unregister
c_func
(paren
op_amp
id|drv-&gt;driver
)paren
suffix:semicolon
id|DBG
c_func
(paren
(paren
l_string|&quot;ocp: ocp_unregister_driver(%s)... done.&bslash;n&quot;
comma
id|drv-&gt;name
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Core of ocp_find_device(). Caller must hold ocp_devices_sem */
r_static
r_struct
id|ocp_device
op_star
DECL|function|__ocp_find_device
id|__ocp_find_device
c_func
(paren
r_int
r_int
id|vendor
comma
r_int
r_int
id|function
comma
r_int
id|index
)paren
(brace
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
r_struct
id|ocp_device
op_star
id|dev
comma
op_star
id|found
op_assign
l_int|NULL
suffix:semicolon
id|DBG
c_func
(paren
(paren
l_string|&quot;ocp: __ocp_find_device(vendor: %x, function: %x, index: %d)...&bslash;n&quot;
comma
id|vendor
comma
id|function
comma
id|index
)paren
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|entry
comma
op_amp
id|ocp_devices
)paren
(brace
id|dev
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|ocp_device
comma
id|link
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vendor
op_ne
id|OCP_ANY_ID
op_logical_and
id|vendor
op_ne
id|dev-&gt;def-&gt;vendor
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|function
op_ne
id|OCP_ANY_ID
op_logical_and
id|function
op_ne
id|dev-&gt;def-&gt;function
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ne
id|OCP_ANY_INDEX
op_logical_and
id|index
op_ne
id|dev-&gt;def-&gt;index
)paren
r_continue
suffix:semicolon
id|found
op_assign
id|dev
suffix:semicolon
r_break
suffix:semicolon
)brace
id|DBG
c_func
(paren
(paren
l_string|&quot;ocp: __ocp_find_device(vendor: %x, function: %x, index: %d)... done&bslash;n&quot;
comma
id|vendor
comma
id|function
comma
id|index
)paren
)paren
suffix:semicolon
r_return
id|found
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ocp_find_device&t;-&t;Find a device by function &amp; index&n; *      @vendor: vendor ID of the device (or OCP_ANY_ID)&n; *&t;@function: function code of the device (or OCP_ANY_ID)&n; *&t;@idx: index of the device (or OCP_ANY_INDEX)&n; *&n; *&t;This function allows a lookup of a given function by it&squot;s&n; *&t;index, it&squot;s typically used to find the MAL or ZMII associated&n; *&t;with an EMAC or similar horrors.&n; *      You can pass vendor, though you usually want OCP_ANY_ID there...&n; */
r_struct
id|ocp_device
op_star
DECL|function|ocp_find_device
id|ocp_find_device
c_func
(paren
r_int
r_int
id|vendor
comma
r_int
r_int
id|function
comma
r_int
id|index
)paren
(brace
r_struct
id|ocp_device
op_star
id|dev
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|ocp_devices_sem
)paren
suffix:semicolon
id|dev
op_assign
id|__ocp_find_device
c_func
(paren
id|vendor
comma
id|function
comma
id|index
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|ocp_devices_sem
)paren
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ocp_get_one_device -&t;Find a def by function &amp; index&n; *      @vendor: vendor ID of the device (or OCP_ANY_ID)&n; *&t;@function: function code of the device (or OCP_ANY_ID)&n; *&t;@idx: index of the device (or OCP_ANY_INDEX)&n; *&n; *&t;This function allows a lookup of a given ocp_def by it&squot;s&n; *&t;vendor, function, and index.  The main purpose for is to&n; *&t;allow modification of the def before binding to the driver&n; */
r_struct
id|ocp_def
op_star
DECL|function|ocp_get_one_device
id|ocp_get_one_device
c_func
(paren
r_int
r_int
id|vendor
comma
r_int
r_int
id|function
comma
r_int
id|index
)paren
(brace
r_struct
id|ocp_device
op_star
id|dev
suffix:semicolon
r_struct
id|ocp_def
op_star
id|found
op_assign
l_int|NULL
suffix:semicolon
id|DBG
c_func
(paren
(paren
l_string|&quot;ocp: ocp_get_one_device(vendor: %x, function: %x, index: %d)...&bslash;n&quot;
comma
id|vendor
comma
id|function
comma
id|index
)paren
)paren
suffix:semicolon
id|dev
op_assign
id|ocp_find_device
c_func
(paren
id|vendor
comma
id|function
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
id|found
op_assign
id|dev-&gt;def
suffix:semicolon
id|DBG
c_func
(paren
(paren
l_string|&quot;ocp: ocp_get_one_device(vendor: %x, function: %x, index: %d)... done.&bslash;n&quot;
comma
id|vendor
comma
id|function
comma
id|index
)paren
)paren
suffix:semicolon
r_return
id|found
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ocp_add_one_device&t;-&t;Add a device&n; *&t;@def: static device definition structure&n; *&n; *&t;This function adds a device definition to the&n; *&t;device list. It may only be called before&n; *&t;ocp_driver_init() and will return an error&n; *&t;otherwise.&n; */
r_int
DECL|function|ocp_add_one_device
id|ocp_add_one_device
c_func
(paren
r_struct
id|ocp_def
op_star
id|def
)paren
(brace
r_struct
id|ocp_device
op_star
id|dev
suffix:semicolon
id|DBG
c_func
(paren
(paren
l_string|&quot;ocp: ocp_add_one_device()...&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* Can&squot;t be called after ocp driver init */
r_if
c_cond
(paren
id|ocp_inited
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|mem_init_done
)paren
id|dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|dev
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_else
id|dev
op_assign
id|alloc_bootmem
c_func
(paren
r_sizeof
(paren
op_star
id|dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
id|memset
c_func
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|dev
)paren
)paren
suffix:semicolon
id|dev-&gt;def
op_assign
id|def
suffix:semicolon
id|dev-&gt;current_state
op_assign
l_int|4
suffix:semicolon
id|sprintf
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;OCP device %04x:%04x:%04x&quot;
comma
id|dev-&gt;def-&gt;vendor
comma
id|dev-&gt;def-&gt;function
comma
id|dev-&gt;def-&gt;index
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|ocp_devices_sem
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|dev-&gt;link
comma
op_amp
id|ocp_devices
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|ocp_devices_sem
)paren
suffix:semicolon
id|DBG
c_func
(paren
(paren
l_string|&quot;ocp: ocp_add_one_device()...done&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ocp_remove_one_device -&t;Remove a device by function &amp; index&n; *      @vendor: vendor ID of the device (or OCP_ANY_ID)&n; *&t;@function: function code of the device (or OCP_ANY_ID)&n; *&t;@idx: index of the device (or OCP_ANY_INDEX)&n; *&n; *&t;This function allows removal of a given function by its&n; *&t;index. It may only be called before ocp_driver_init()&n; *&t;and will return an error otherwise.&n; */
r_int
DECL|function|ocp_remove_one_device
id|ocp_remove_one_device
c_func
(paren
r_int
r_int
id|vendor
comma
r_int
r_int
id|function
comma
r_int
id|index
)paren
(brace
r_struct
id|ocp_device
op_star
id|dev
suffix:semicolon
id|DBG
c_func
(paren
(paren
l_string|&quot;ocp: ocp_remove_one_device(vendor: %x, function: %x, index: %d)...&bslash;n&quot;
comma
id|vendor
comma
id|function
comma
id|index
)paren
)paren
suffix:semicolon
multiline_comment|/* Can&squot;t be called after ocp driver init */
r_if
c_cond
(paren
id|ocp_inited
)paren
r_return
l_int|1
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|ocp_devices_sem
)paren
suffix:semicolon
id|dev
op_assign
id|__ocp_find_device
c_func
(paren
id|vendor
comma
id|function
comma
id|index
)paren
suffix:semicolon
id|list_del
c_func
(paren
(paren
r_struct
id|list_head
op_star
)paren
id|dev
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|ocp_devices_sem
)paren
suffix:semicolon
id|DBG
c_func
(paren
(paren
l_string|&quot;ocp: ocp_remove_one_device(vendor: %x, function: %x, index: %d)... done.&bslash;n&quot;
comma
id|vendor
comma
id|function
comma
id|index
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ocp_for_each_device&t;-&t;Iterate over OCP devices&n; *&t;@callback: routine to execute for each ocp device.&n; *&t;@arg: user data to be passed to callback routine.&n; *&n; *&t;This routine holds the ocp_device semaphore, so the&n; *&t;callback routine cannot modify the ocp_device list.&n; */
r_void
DECL|function|ocp_for_each_device
id|ocp_for_each_device
c_func
(paren
r_void
(paren
op_star
id|callback
)paren
(paren
r_struct
id|ocp_device
op_star
comma
r_void
op_star
id|arg
)paren
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
r_if
c_cond
(paren
id|callback
)paren
(brace
id|down_read
c_func
(paren
op_amp
id|ocp_devices_sem
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|entry
comma
op_amp
id|ocp_devices
)paren
id|callback
c_func
(paren
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|ocp_device
comma
id|link
)paren
comma
id|arg
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|ocp_devices_sem
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;ocp_early_init&t;-&t;Init OCP device management&n; *&n; *&t;This function builds the list of devices before setup_arch.&n; *&t;This allows platform code to modify the device lists before&n; *&t;they are bound to drivers (changes to paddr, removing devices&n; *&t;etc)&n; */
r_int
id|__init
DECL|function|ocp_early_init
id|ocp_early_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|ocp_def
op_star
id|def
suffix:semicolon
id|DBG
c_func
(paren
(paren
l_string|&quot;ocp: ocp_early_init()...&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* Fill the devices list */
r_for
c_loop
(paren
id|def
op_assign
id|core_ocp
suffix:semicolon
id|def-&gt;vendor
op_ne
id|OCP_VENDOR_INVALID
suffix:semicolon
id|def
op_increment
)paren
id|ocp_add_one_device
c_func
(paren
id|def
)paren
suffix:semicolon
id|DBG
c_func
(paren
(paren
l_string|&quot;ocp: ocp_early_init()... done.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ocp_driver_init&t;-&t;Init OCP device management&n; *&n; *&t;This function is meant to be called via OCP bus registration.&n; */
r_static
r_int
id|__init
DECL|function|ocp_driver_init
id|ocp_driver_init
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
op_assign
l_int|0
comma
id|index
op_assign
l_int|0
suffix:semicolon
r_struct
id|device
op_star
id|ocp_bus
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
r_struct
id|ocp_device
op_star
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|ocp_inited
)paren
r_return
id|ret
suffix:semicolon
id|ocp_inited
op_assign
l_int|1
suffix:semicolon
id|DBG
c_func
(paren
(paren
l_string|&quot;ocp: ocp_driver_init()...&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* Allocate/register primary OCP bus */
id|ocp_bus
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ocp_bus
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
id|memset
c_func
(paren
id|ocp_bus
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|device
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|ocp_bus-&gt;bus_id
comma
l_string|&quot;ocp&quot;
)paren
suffix:semicolon
id|bus_register
c_func
(paren
op_amp
id|ocp_bus_type
)paren
suffix:semicolon
id|device_register
c_func
(paren
id|ocp_bus
)paren
suffix:semicolon
multiline_comment|/* Put each OCP device into global device list */
id|list_for_each
c_func
(paren
id|entry
comma
op_amp
id|ocp_devices
)paren
(brace
id|dev
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|ocp_device
comma
id|link
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dev-&gt;dev.bus_id
comma
l_string|&quot;%2.2x&quot;
comma
id|index
)paren
suffix:semicolon
id|dev-&gt;dev.parent
op_assign
id|ocp_bus
suffix:semicolon
id|dev-&gt;dev.bus
op_assign
op_amp
id|ocp_bus_type
suffix:semicolon
id|device_register
c_func
(paren
op_amp
id|dev-&gt;dev
)paren
suffix:semicolon
id|ocp_create_sysfs_dev_files
c_func
(paren
id|dev
)paren
suffix:semicolon
id|index
op_increment
suffix:semicolon
)brace
id|DBG
c_func
(paren
(paren
l_string|&quot;ocp: ocp_driver_init()... done.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ocp_driver_init
id|postcore_initcall
c_func
(paren
id|ocp_driver_init
)paren
suffix:semicolon
DECL|variable|ocp_bus_type
id|EXPORT_SYMBOL
c_func
(paren
id|ocp_bus_type
)paren
suffix:semicolon
DECL|variable|ocp_find_device
id|EXPORT_SYMBOL
c_func
(paren
id|ocp_find_device
)paren
suffix:semicolon
DECL|variable|ocp_register_driver
id|EXPORT_SYMBOL
c_func
(paren
id|ocp_register_driver
)paren
suffix:semicolon
DECL|variable|ocp_unregister_driver
id|EXPORT_SYMBOL
c_func
(paren
id|ocp_unregister_driver
)paren
suffix:semicolon
eof
