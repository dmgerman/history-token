multiline_comment|/*&n; * arch/parisc/lib/io.c&n; *&n; * Copyright (c) Matthew Wilcox 2001 for Hewlett-Packard&n; * Copyright (c) Randolph Chung 2001 &lt;tausq@debian.org&gt;&n; *&n; * IO accessing functions which shouldn&squot;t be inlined because they&squot;re too big&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/io.h&gt;
multiline_comment|/* Copies a block of memory to a device in an efficient manner.&n; * Assumes the device can cope with 32-bit transfers.  If it can&squot;t,&n; * don&squot;t use this function.&n; */
DECL|function|memcpy_toio
r_void
id|memcpy_toio
c_func
(paren
r_volatile
r_void
id|__iomem
op_star
id|dst
comma
r_const
r_void
op_star
id|src
comma
r_int
id|count
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|dst
op_amp
l_int|3
)paren
op_ne
(paren
(paren
r_int
r_int
)paren
id|src
op_amp
l_int|3
)paren
)paren
r_goto
id|bytecopy
suffix:semicolon
r_while
c_loop
(paren
(paren
r_int
r_int
)paren
id|dst
op_amp
l_int|3
)paren
(brace
id|writeb
c_func
(paren
op_star
(paren
r_char
op_star
)paren
id|src
comma
id|dst
op_increment
)paren
suffix:semicolon
id|src
op_increment
suffix:semicolon
id|count
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
OG
l_int|3
)paren
(brace
id|__raw_writel
c_func
(paren
op_star
(paren
id|u32
op_star
)paren
id|src
comma
id|dst
)paren
suffix:semicolon
id|src
op_add_assign
l_int|4
suffix:semicolon
id|dst
op_add_assign
l_int|4
suffix:semicolon
id|count
op_sub_assign
l_int|4
suffix:semicolon
)brace
id|bytecopy
suffix:colon
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
id|writeb
c_func
(paren
op_star
(paren
r_char
op_star
)paren
id|src
comma
id|dst
op_increment
)paren
suffix:semicolon
id|src
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;** Copies a block of memory from a device in an efficient manner.&n;** Assumes the device can cope with 32-bit transfers.  If it can&squot;t,&n;** don&squot;t use this function.&n;**&n;** CR16 counts on C3000 reading 256 bytes from Symbios 896 RAM:&n;**&t;27341/64    = 427 cyc per int&n;**&t;61311/128   = 478 cyc per short&n;**&t;122637/256  = 479 cyc per byte&n;** Ergo bus latencies dominant (not transfer size).&n;**      Minimize total number of transfers at cost of CPU cycles.&n;**&t;TODO: only look at src alignment and adjust the stores to dest.&n;*/
DECL|function|memcpy_fromio
r_void
id|memcpy_fromio
c_func
(paren
r_void
op_star
id|dst
comma
r_const
r_volatile
r_void
id|__iomem
op_star
id|src
comma
r_int
id|count
)paren
(brace
multiline_comment|/* first compare alignment of src/dst */
r_if
c_cond
(paren
(paren
(paren
(paren
r_int
r_int
)paren
id|dst
op_xor
(paren
r_int
r_int
)paren
id|src
)paren
op_amp
l_int|1
)paren
op_logical_or
(paren
id|count
OL
l_int|2
)paren
)paren
r_goto
id|bytecopy
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
(paren
r_int
r_int
)paren
id|dst
op_xor
(paren
r_int
r_int
)paren
id|src
)paren
op_amp
l_int|2
)paren
op_logical_or
(paren
id|count
OL
l_int|4
)paren
)paren
r_goto
id|shortcopy
suffix:semicolon
multiline_comment|/* Then check for misaligned start address */
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|src
op_amp
l_int|1
)paren
(brace
op_star
(paren
id|u8
op_star
)paren
id|dst
op_assign
id|readb
c_func
(paren
id|src
)paren
suffix:semicolon
id|src
op_increment
suffix:semicolon
id|dst
op_increment
suffix:semicolon
id|count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
l_int|2
)paren
r_goto
id|bytecopy
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|src
op_amp
l_int|2
)paren
(brace
op_star
(paren
id|u16
op_star
)paren
id|dst
op_assign
id|__raw_readw
c_func
(paren
id|src
)paren
suffix:semicolon
id|src
op_add_assign
l_int|2
suffix:semicolon
id|dst
op_add_assign
l_int|2
suffix:semicolon
id|count
op_sub_assign
l_int|2
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
OG
l_int|3
)paren
(brace
op_star
(paren
id|u32
op_star
)paren
id|dst
op_assign
id|__raw_readl
c_func
(paren
id|src
)paren
suffix:semicolon
id|dst
op_add_assign
l_int|4
suffix:semicolon
id|src
op_add_assign
l_int|4
suffix:semicolon
id|count
op_sub_assign
l_int|4
suffix:semicolon
)brace
id|shortcopy
suffix:colon
r_while
c_loop
(paren
id|count
OG
l_int|1
)paren
(brace
op_star
(paren
id|u16
op_star
)paren
id|dst
op_assign
id|__raw_readw
c_func
(paren
id|src
)paren
suffix:semicolon
id|src
op_add_assign
l_int|2
suffix:semicolon
id|dst
op_add_assign
l_int|2
suffix:semicolon
id|count
op_sub_assign
l_int|2
suffix:semicolon
)brace
id|bytecopy
suffix:colon
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
op_star
(paren
r_char
op_star
)paren
id|dst
op_assign
id|readb
c_func
(paren
id|src
)paren
suffix:semicolon
id|src
op_increment
suffix:semicolon
id|dst
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Sets a block of memory on a device to a given value.&n; * Assumes the device can cope with 32-bit transfers.  If it can&squot;t,&n; * don&squot;t use this function.&n; */
DECL|function|memset_io
r_void
id|memset_io
c_func
(paren
r_volatile
r_void
id|__iomem
op_star
id|addr
comma
r_int
r_char
id|val
comma
r_int
id|count
)paren
(brace
id|u32
id|val32
op_assign
(paren
id|val
op_lshift
l_int|24
)paren
op_or
(paren
id|val
op_lshift
l_int|16
)paren
op_or
(paren
id|val
op_lshift
l_int|8
)paren
op_or
id|val
suffix:semicolon
r_while
c_loop
(paren
(paren
r_int
r_int
)paren
id|addr
op_amp
l_int|3
)paren
(brace
id|writeb
c_func
(paren
id|val
comma
id|addr
op_increment
)paren
suffix:semicolon
id|count
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
OG
l_int|3
)paren
(brace
id|__raw_writel
c_func
(paren
id|val32
comma
id|addr
)paren
suffix:semicolon
id|addr
op_add_assign
l_int|4
suffix:semicolon
id|count
op_sub_assign
l_int|4
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
id|writeb
c_func
(paren
id|val
comma
id|addr
op_increment
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Read COUNT 8-bit bytes from port PORT into memory starting at&n; * SRC.&n; */
DECL|function|insb
r_void
id|insb
(paren
r_int
r_int
id|port
comma
r_void
op_star
id|dst
comma
r_int
r_int
id|count
)paren
(brace
r_int
r_char
op_star
id|p
suffix:semicolon
id|p
op_assign
(paren
r_int
r_char
op_star
)paren
id|dst
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
r_int
r_int
)paren
id|p
)paren
op_amp
l_int|0x3
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
r_return
suffix:semicolon
id|count
op_decrement
suffix:semicolon
op_star
id|p
op_assign
id|inb
c_func
(paren
id|port
)paren
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
op_ge
l_int|4
)paren
(brace
r_int
r_int
id|w
suffix:semicolon
id|count
op_sub_assign
l_int|4
suffix:semicolon
id|w
op_assign
id|inb
c_func
(paren
id|port
)paren
op_lshift
l_int|24
suffix:semicolon
id|w
op_or_assign
id|inb
c_func
(paren
id|port
)paren
op_lshift
l_int|16
suffix:semicolon
id|w
op_or_assign
id|inb
c_func
(paren
id|port
)paren
op_lshift
l_int|8
suffix:semicolon
id|w
op_or_assign
id|inb
c_func
(paren
id|port
)paren
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
id|p
op_assign
id|w
suffix:semicolon
id|p
op_add_assign
l_int|4
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
)paren
(brace
op_decrement
id|count
suffix:semicolon
op_star
id|p
op_assign
id|inb
c_func
(paren
id|port
)paren
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Read COUNT 16-bit words from port PORT into memory starting at&n; * SRC.  SRC must be at least short aligned.  This is used by the&n; * IDE driver to read disk sectors.  Performance is important, but&n; * the interfaces seems to be slow: just using the inlined version&n; * of the inw() breaks things.&n; */
DECL|function|insw
r_void
id|insw
(paren
r_int
r_int
id|port
comma
r_void
op_star
id|dst
comma
r_int
r_int
id|count
)paren
(brace
r_int
r_int
id|l
op_assign
l_int|0
comma
id|l2
suffix:semicolon
r_int
r_char
op_star
id|p
suffix:semicolon
id|p
op_assign
(paren
r_int
r_char
op_star
)paren
id|dst
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
r_return
suffix:semicolon
r_switch
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|p
)paren
op_amp
l_int|0x3
)paren
(brace
r_case
l_int|0x00
suffix:colon
multiline_comment|/* Buffer 32-bit aligned */
r_while
c_loop
(paren
id|count
op_ge
l_int|2
)paren
(brace
id|count
op_sub_assign
l_int|2
suffix:semicolon
id|l
op_assign
id|cpu_to_le16
c_func
(paren
id|inw
c_func
(paren
id|port
)paren
)paren
op_lshift
l_int|16
suffix:semicolon
id|l
op_or_assign
id|cpu_to_le16
c_func
(paren
id|inw
c_func
(paren
id|port
)paren
)paren
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
id|p
op_assign
id|l
suffix:semicolon
id|p
op_add_assign
l_int|4
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
)paren
(brace
op_star
(paren
r_int
r_int
op_star
)paren
id|p
op_assign
id|cpu_to_le16
c_func
(paren
id|inw
c_func
(paren
id|port
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x02
suffix:colon
multiline_comment|/* Buffer 16-bit aligned */
op_star
(paren
r_int
r_int
op_star
)paren
id|p
op_assign
id|cpu_to_le16
c_func
(paren
id|inw
c_func
(paren
id|port
)paren
)paren
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
id|count
op_decrement
suffix:semicolon
r_while
c_loop
(paren
id|count
op_ge
l_int|2
)paren
(brace
id|count
op_sub_assign
l_int|2
suffix:semicolon
id|l
op_assign
id|cpu_to_le16
c_func
(paren
id|inw
c_func
(paren
id|port
)paren
)paren
op_lshift
l_int|16
suffix:semicolon
id|l
op_or_assign
id|cpu_to_le16
c_func
(paren
id|inw
c_func
(paren
id|port
)paren
)paren
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
id|p
op_assign
id|l
suffix:semicolon
id|p
op_add_assign
l_int|4
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
)paren
(brace
op_star
(paren
r_int
r_int
op_star
)paren
id|p
op_assign
id|cpu_to_le16
c_func
(paren
id|inw
c_func
(paren
id|port
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x01
suffix:colon
multiline_comment|/* Buffer 8-bit aligned */
r_case
l_int|0x03
suffix:colon
multiline_comment|/* I don&squot;t bother with 32bit transfers&n;&t;&t; * in this case, 16bit will have to do -- DE */
op_decrement
id|count
suffix:semicolon
id|l
op_assign
id|cpu_to_le16
c_func
(paren
id|inw
c_func
(paren
id|port
)paren
)paren
suffix:semicolon
op_star
id|p
op_assign
id|l
op_rshift
l_int|8
suffix:semicolon
id|p
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
id|l2
op_assign
id|cpu_to_le16
c_func
(paren
id|inw
c_func
(paren
id|port
)paren
)paren
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
id|p
op_assign
(paren
id|l
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
op_or
(paren
id|l2
op_rshift
l_int|8
)paren
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
id|l
op_assign
id|l2
suffix:semicolon
)brace
op_star
id|p
op_assign
id|l
op_amp
l_int|0xff
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Read COUNT 32-bit words from port PORT into memory starting at&n; * SRC. Now works with any alignment in SRC. Performance is important,&n; * but the interfaces seems to be slow: just using the inlined version&n; * of the inl() breaks things.&n; */
DECL|function|insl
r_void
id|insl
(paren
r_int
r_int
id|port
comma
r_void
op_star
id|dst
comma
r_int
r_int
id|count
)paren
(brace
r_int
r_int
id|l
op_assign
l_int|0
comma
id|l2
suffix:semicolon
r_int
r_char
op_star
id|p
suffix:semicolon
id|p
op_assign
(paren
r_int
r_char
op_star
)paren
id|dst
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
r_return
suffix:semicolon
r_switch
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|dst
)paren
op_amp
l_int|0x3
)paren
(brace
r_case
l_int|0x00
suffix:colon
multiline_comment|/* Buffer 32-bit aligned */
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
op_star
(paren
r_int
r_int
op_star
)paren
id|p
op_assign
id|cpu_to_le32
c_func
(paren
id|inl
c_func
(paren
id|port
)paren
)paren
suffix:semicolon
id|p
op_add_assign
l_int|4
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x02
suffix:colon
multiline_comment|/* Buffer 16-bit aligned */
op_decrement
id|count
suffix:semicolon
id|l
op_assign
id|cpu_to_le32
c_func
(paren
id|inl
c_func
(paren
id|port
)paren
)paren
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
id|p
op_assign
id|l
op_rshift
l_int|16
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
id|l2
op_assign
id|cpu_to_le32
c_func
(paren
id|inl
c_func
(paren
id|port
)paren
)paren
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
id|p
op_assign
(paren
id|l
op_amp
l_int|0xffff
)paren
op_lshift
l_int|16
op_or
(paren
id|l2
op_rshift
l_int|16
)paren
suffix:semicolon
id|p
op_add_assign
l_int|4
suffix:semicolon
id|l
op_assign
id|l2
suffix:semicolon
)brace
op_star
(paren
r_int
r_int
op_star
)paren
id|p
op_assign
id|l
op_amp
l_int|0xffff
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x01
suffix:colon
multiline_comment|/* Buffer 8-bit aligned */
op_decrement
id|count
suffix:semicolon
id|l
op_assign
id|cpu_to_le32
c_func
(paren
id|inl
c_func
(paren
id|port
)paren
)paren
suffix:semicolon
op_star
(paren
r_int
r_char
op_star
)paren
id|p
op_assign
id|l
op_rshift
l_int|24
suffix:semicolon
id|p
op_increment
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
id|p
op_assign
(paren
id|l
op_rshift
l_int|8
)paren
op_amp
l_int|0xffff
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
id|l2
op_assign
id|cpu_to_le32
c_func
(paren
id|inl
c_func
(paren
id|port
)paren
)paren
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
id|p
op_assign
(paren
id|l
op_amp
l_int|0xff
)paren
op_lshift
l_int|24
op_or
(paren
id|l2
op_rshift
l_int|8
)paren
suffix:semicolon
id|p
op_add_assign
l_int|4
suffix:semicolon
id|l
op_assign
id|l2
suffix:semicolon
)brace
op_star
id|p
op_assign
id|l
op_amp
l_int|0xff
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x03
suffix:colon
multiline_comment|/* Buffer 8-bit aligned */
op_decrement
id|count
suffix:semicolon
id|l
op_assign
id|cpu_to_le32
c_func
(paren
id|inl
c_func
(paren
id|port
)paren
)paren
suffix:semicolon
op_star
id|p
op_assign
id|l
op_rshift
l_int|24
suffix:semicolon
id|p
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
id|l2
op_assign
id|cpu_to_le32
c_func
(paren
id|inl
c_func
(paren
id|port
)paren
)paren
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
id|p
op_assign
(paren
id|l
op_amp
l_int|0xffffff
)paren
op_lshift
l_int|8
op_or
id|l2
op_rshift
l_int|24
suffix:semicolon
id|p
op_add_assign
l_int|4
suffix:semicolon
id|l
op_assign
id|l2
suffix:semicolon
)brace
op_star
(paren
r_int
r_int
op_star
)paren
id|p
op_assign
(paren
id|l
op_rshift
l_int|8
)paren
op_amp
l_int|0xffff
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
op_star
id|p
op_assign
id|l
op_amp
l_int|0xff
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Like insb but in the opposite direction.&n; * Don&squot;t worry as much about doing aligned memory transfers:&n; * doing byte reads the &quot;slow&quot; way isn&squot;t nearly as slow as&n; * doing byte writes the slow way (no r-m-w cycle).&n; */
DECL|function|outsb
r_void
id|outsb
c_func
(paren
r_int
r_int
id|port
comma
r_const
r_void
op_star
id|src
comma
r_int
r_int
id|count
)paren
(brace
r_const
r_int
r_char
op_star
id|p
suffix:semicolon
id|p
op_assign
(paren
r_const
r_int
r_char
op_star
)paren
id|src
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
id|count
op_decrement
suffix:semicolon
id|outb
c_func
(paren
op_star
id|p
comma
id|port
)paren
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Like insw but in the opposite direction.  This is used by the IDE&n; * driver to write disk sectors.  Performance is important, but the&n; * interfaces seems to be slow: just using the inlined version of the&n; * outw() breaks things.&n; */
DECL|function|outsw
r_void
id|outsw
(paren
r_int
r_int
id|port
comma
r_const
r_void
op_star
id|src
comma
r_int
r_int
id|count
)paren
(brace
r_int
r_int
id|l
op_assign
l_int|0
comma
id|l2
suffix:semicolon
r_const
r_int
r_char
op_star
id|p
suffix:semicolon
id|p
op_assign
(paren
r_const
r_int
r_char
op_star
)paren
id|src
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
r_return
suffix:semicolon
r_switch
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|p
)paren
op_amp
l_int|0x3
)paren
(brace
r_case
l_int|0x00
suffix:colon
multiline_comment|/* Buffer 32-bit aligned */
r_while
c_loop
(paren
id|count
op_ge
l_int|2
)paren
(brace
id|count
op_sub_assign
l_int|2
suffix:semicolon
id|l
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|p
suffix:semicolon
id|p
op_add_assign
l_int|4
suffix:semicolon
id|outw
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|l
op_rshift
l_int|16
)paren
comma
id|port
)paren
suffix:semicolon
id|outw
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|l
op_amp
l_int|0xffff
)paren
comma
id|port
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
)paren
(brace
id|outw
c_func
(paren
id|le16_to_cpu
c_func
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|p
)paren
comma
id|port
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x02
suffix:colon
multiline_comment|/* Buffer 16-bit aligned */
id|outw
c_func
(paren
id|le16_to_cpu
c_func
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|p
)paren
comma
id|port
)paren
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
id|count
op_decrement
suffix:semicolon
r_while
c_loop
(paren
id|count
op_ge
l_int|2
)paren
(brace
id|count
op_sub_assign
l_int|2
suffix:semicolon
id|l
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|p
suffix:semicolon
id|p
op_add_assign
l_int|4
suffix:semicolon
id|outw
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|l
op_rshift
l_int|16
)paren
comma
id|port
)paren
suffix:semicolon
id|outw
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|l
op_amp
l_int|0xffff
)paren
comma
id|port
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
)paren
(brace
id|outw
c_func
(paren
id|le16_to_cpu
c_func
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|p
)paren
comma
id|port
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x01
suffix:colon
multiline_comment|/* Buffer 8-bit aligned */
multiline_comment|/* I don&squot;t bother with 32bit transfers&n;&t;&t; * in this case, 16bit will have to do -- DE */
id|l
op_assign
op_star
id|p
op_lshift
l_int|8
suffix:semicolon
id|p
op_increment
suffix:semicolon
id|count
op_decrement
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
id|count
op_decrement
suffix:semicolon
id|l2
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|p
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
id|outw
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|l
op_or
id|l2
op_rshift
l_int|8
)paren
comma
id|port
)paren
suffix:semicolon
id|l
op_assign
id|l2
op_lshift
l_int|8
suffix:semicolon
)brace
id|l2
op_assign
op_star
(paren
r_int
r_char
op_star
)paren
id|p
suffix:semicolon
id|outw
(paren
id|le16_to_cpu
c_func
(paren
id|l
op_or
id|l2
op_rshift
l_int|8
)paren
comma
id|port
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Like insl but in the opposite direction.  This is used by the IDE&n; * driver to write disk sectors.  Works with any alignment in SRC.&n; *  Performance is important, but the interfaces seems to be slow:&n; * just using the inlined version of the outl() breaks things.&n; */
DECL|function|outsl
r_void
id|outsl
(paren
r_int
r_int
id|port
comma
r_const
r_void
op_star
id|src
comma
r_int
r_int
id|count
)paren
(brace
r_int
r_int
id|l
op_assign
l_int|0
comma
id|l2
suffix:semicolon
r_const
r_int
r_char
op_star
id|p
suffix:semicolon
id|p
op_assign
(paren
r_const
r_int
r_char
op_star
)paren
id|src
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
r_return
suffix:semicolon
r_switch
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|p
)paren
op_amp
l_int|0x3
)paren
(brace
r_case
l_int|0x00
suffix:colon
multiline_comment|/* Buffer 32-bit aligned */
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
id|outl
c_func
(paren
id|le32_to_cpu
c_func
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|p
)paren
comma
id|port
)paren
suffix:semicolon
id|p
op_add_assign
l_int|4
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x02
suffix:colon
multiline_comment|/* Buffer 16-bit aligned */
op_decrement
id|count
suffix:semicolon
id|l
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|p
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
id|l2
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|p
suffix:semicolon
id|p
op_add_assign
l_int|4
suffix:semicolon
id|outl
(paren
id|le32_to_cpu
c_func
(paren
id|l
op_lshift
l_int|16
op_or
id|l2
op_rshift
l_int|16
)paren
comma
id|port
)paren
suffix:semicolon
id|l
op_assign
id|l2
suffix:semicolon
)brace
id|l2
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|p
suffix:semicolon
id|outl
(paren
id|le32_to_cpu
c_func
(paren
id|l
op_lshift
l_int|16
op_or
id|l2
)paren
comma
id|port
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x01
suffix:colon
multiline_comment|/* Buffer 8-bit aligned */
op_decrement
id|count
suffix:semicolon
id|l
op_assign
op_star
id|p
op_lshift
l_int|24
suffix:semicolon
id|p
op_increment
suffix:semicolon
id|l
op_or_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|p
op_lshift
l_int|8
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
id|l2
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|p
suffix:semicolon
id|p
op_add_assign
l_int|4
suffix:semicolon
id|outl
(paren
id|le32_to_cpu
c_func
(paren
id|l
op_or
id|l2
op_rshift
l_int|24
)paren
comma
id|port
)paren
suffix:semicolon
id|l
op_assign
id|l2
op_lshift
l_int|8
suffix:semicolon
)brace
id|l2
op_assign
op_star
id|p
suffix:semicolon
id|outl
(paren
id|le32_to_cpu
c_func
(paren
id|l
op_or
id|l2
)paren
comma
id|port
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x03
suffix:colon
multiline_comment|/* Buffer 8-bit aligned */
op_decrement
id|count
suffix:semicolon
id|l
op_assign
op_star
id|p
op_lshift
l_int|24
suffix:semicolon
id|p
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
id|l2
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|p
suffix:semicolon
id|p
op_add_assign
l_int|4
suffix:semicolon
id|outl
(paren
id|le32_to_cpu
c_func
(paren
id|l
op_or
id|l2
op_rshift
l_int|8
)paren
comma
id|port
)paren
suffix:semicolon
id|l
op_assign
id|l2
op_lshift
l_int|24
suffix:semicolon
)brace
id|l2
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|p
op_lshift
l_int|16
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
id|l2
op_or_assign
op_star
id|p
suffix:semicolon
id|outl
(paren
id|le32_to_cpu
c_func
(paren
id|l
op_or
id|l2
)paren
comma
id|port
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|variable|insb
id|EXPORT_SYMBOL
c_func
(paren
id|insb
)paren
suffix:semicolon
DECL|variable|insw
id|EXPORT_SYMBOL
c_func
(paren
id|insw
)paren
suffix:semicolon
DECL|variable|insl
id|EXPORT_SYMBOL
c_func
(paren
id|insl
)paren
suffix:semicolon
DECL|variable|outsb
id|EXPORT_SYMBOL
c_func
(paren
id|outsb
)paren
suffix:semicolon
DECL|variable|outsw
id|EXPORT_SYMBOL
c_func
(paren
id|outsw
)paren
suffix:semicolon
DECL|variable|outsl
id|EXPORT_SYMBOL
c_func
(paren
id|outsl
)paren
suffix:semicolon
eof
