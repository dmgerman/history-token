multiline_comment|/*&n; * Linux/PA-RISC Project (http://www.parisc-linux.org/)&n; *&n; * Floating-point emulation code&n; *  Copyright (C) 2001 Hewlett-Packard (Paul Bame) &lt;bame@debian.org&gt;&n; *&n; *    This program is free software; you can redistribute it and/or modify&n; *    it under the terms of the GNU General Public License as published by&n; *    the Free Software Foundation; either version 2, or (at your option)&n; *    any later version.&n; *&n; *    This program is distributed in the hope that it will be useful,&n; *    but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *    GNU General Public License for more details.&n; *&n; *    You should have received a copy of the GNU General Public License&n; *    along with this program; if not, write to the Free Software&n; *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
multiline_comment|/*&n; * BEGIN_DESC&n; *&n; *  File:&n; *&t;@(#)&t;pa/spmath/fmpyfadd.c&t;&t;$Revision: 1.1 $&n; *&n; *  Purpose:&n; *&t;Double Floating-point Multiply Fused Add&n; *&t;Double Floating-point Multiply Negate Fused Add&n; *&t;Single Floating-point Multiply Fused Add&n; *&t;Single Floating-point Multiply Negate Fused Add&n; *&n; *  External Interfaces:&n; *&t;dbl_fmpyfadd(src1ptr,src2ptr,src3ptr,status,dstptr)&n; *&t;dbl_fmpynfadd(src1ptr,src2ptr,src3ptr,status,dstptr)&n; *&t;sgl_fmpyfadd(src1ptr,src2ptr,src3ptr,status,dstptr)&n; *&t;sgl_fmpynfadd(src1ptr,src2ptr,src3ptr,status,dstptr)&n; *&n; *  Internal Interfaces:&n; *&n; *  Theory:&n; *&t;&lt;&lt;please update with a overview of the operation of this file&gt;&gt;&n; *&n; * END_DESC&n;*/
macro_line|#include &quot;float.h&quot;
macro_line|#include &quot;sgl_float.h&quot;
macro_line|#include &quot;dbl_float.h&quot;
multiline_comment|/*&n; *  Double Floating-point Multiply Fused Add&n; */
r_int
DECL|function|dbl_fmpyfadd
id|dbl_fmpyfadd
c_func
(paren
id|dbl_floating_point
op_star
id|src1ptr
comma
id|dbl_floating_point
op_star
id|src2ptr
comma
id|dbl_floating_point
op_star
id|src3ptr
comma
r_int
r_int
op_star
id|status
comma
id|dbl_floating_point
op_star
id|dstptr
)paren
(brace
r_int
r_int
id|opnd1p1
comma
id|opnd1p2
comma
id|opnd2p1
comma
id|opnd2p2
comma
id|opnd3p1
comma
id|opnd3p2
suffix:semicolon
r_register
r_int
r_int
id|tmpresp1
comma
id|tmpresp2
comma
id|tmpresp3
comma
id|tmpresp4
suffix:semicolon
r_int
r_int
id|rightp1
comma
id|rightp2
comma
id|rightp3
comma
id|rightp4
suffix:semicolon
r_int
r_int
id|resultp1
comma
id|resultp2
op_assign
l_int|0
comma
id|resultp3
op_assign
l_int|0
comma
id|resultp4
op_assign
l_int|0
suffix:semicolon
r_register
r_int
id|mpy_exponent
comma
id|add_exponent
comma
id|count
suffix:semicolon
id|boolean
id|inexact
op_assign
id|FALSE
comma
id|is_tiny
op_assign
id|FALSE
suffix:semicolon
r_int
r_int
id|signlessleft1
comma
id|signlessright1
comma
id|save
suffix:semicolon
r_register
r_int
id|result_exponent
comma
id|diff_exponent
suffix:semicolon
r_int
id|sign_save
comma
id|jumpsize
suffix:semicolon
id|Dbl_copyfromptr
c_func
(paren
id|src1ptr
comma
id|opnd1p1
comma
id|opnd1p2
)paren
suffix:semicolon
id|Dbl_copyfromptr
c_func
(paren
id|src2ptr
comma
id|opnd2p1
comma
id|opnd2p2
)paren
suffix:semicolon
id|Dbl_copyfromptr
c_func
(paren
id|src3ptr
comma
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * set sign bit of result of multiply&n;&t; */
r_if
c_cond
(paren
id|Dbl_sign
c_func
(paren
id|opnd1p1
)paren
op_xor
id|Dbl_sign
c_func
(paren
id|opnd2p1
)paren
)paren
id|Dbl_setnegativezerop1
c_func
(paren
id|resultp1
)paren
suffix:semicolon
r_else
id|Dbl_setzerop1
c_func
(paren
id|resultp1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Generate multiply exponent &n;&t; */
id|mpy_exponent
op_assign
id|Dbl_exponent
c_func
(paren
id|opnd1p1
)paren
op_plus
id|Dbl_exponent
c_func
(paren
id|opnd2p1
)paren
op_minus
id|DBL_BIAS
suffix:semicolon
multiline_comment|/*&n;&t; * check first operand for NaN&squot;s or infinity&n;&t; */
r_if
c_cond
(paren
id|Dbl_isinfinity_exponent
c_func
(paren
id|opnd1p1
)paren
)paren
(brace
r_if
c_cond
(paren
id|Dbl_iszero_mantissa
c_func
(paren
id|opnd1p1
comma
id|opnd1p2
)paren
)paren
(brace
r_if
c_cond
(paren
id|Dbl_isnotnan
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
)paren
op_logical_and
id|Dbl_isnotnan
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
)paren
(brace
r_if
c_cond
(paren
id|Dbl_iszero_exponentmantissa
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t;&t; * invalid since operands are infinity &n;&t;&t;&t;&t;&t; * and zero &n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_makequietnan
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Check third operand for infinity with a&n;&t;&t;&t;&t; *  sign opposite of the multiply result&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Dbl_isinfinity
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
op_logical_and
(paren
id|Dbl_sign
c_func
(paren
id|resultp1
)paren
op_xor
id|Dbl_sign
c_func
(paren
id|opnd3p1
)paren
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t;&t; * invalid since attempting a magnitude&n;&t;&t;&t;&t;&t; * subtraction of infinities&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_makequietnan
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; &t; * return infinity&n;&t;&t;&t; &t; */
id|Dbl_setinfinity_exponentmantissa
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; &t; * is NaN; signaling or quiet?&n;&t;&t; &t; */
r_if
c_cond
(paren
id|Dbl_isone_signaling
c_func
(paren
id|opnd1p1
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_set_quiet
c_func
(paren
id|opnd1p1
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t;&t; * is second operand a signaling NaN? &n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|Dbl_is_signalingnan
c_func
(paren
id|opnd2p1
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_set_quiet
c_func
(paren
id|opnd2p1
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t;&t; * is third operand a signaling NaN? &n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|Dbl_is_signalingnan
c_func
(paren
id|opnd3p1
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_set_quiet
c_func
(paren
id|opnd3p1
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; &t; * return quiet NaN&n;&t;&t; &t; */
id|Dbl_copytoptr
c_func
(paren
id|opnd1p1
comma
id|opnd1p2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * check second operand for NaN&squot;s or infinity&n;&t; */
r_if
c_cond
(paren
id|Dbl_isinfinity_exponent
c_func
(paren
id|opnd2p1
)paren
)paren
(brace
r_if
c_cond
(paren
id|Dbl_iszero_mantissa
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
)paren
)paren
(brace
r_if
c_cond
(paren
id|Dbl_isnotnan
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
)paren
(brace
r_if
c_cond
(paren
id|Dbl_iszero_exponentmantissa
c_func
(paren
id|opnd1p1
comma
id|opnd1p2
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t;&t; * invalid since multiply operands are&n;&t;&t;&t;&t;&t; * zero &amp; infinity&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_makequietnan
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Check third operand for infinity with a&n;&t;&t;&t;&t; *  sign opposite of the multiply result&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Dbl_isinfinity
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
op_logical_and
(paren
id|Dbl_sign
c_func
(paren
id|resultp1
)paren
op_xor
id|Dbl_sign
c_func
(paren
id|opnd3p1
)paren
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t;&t; * invalid since attempting a magnitude&n;&t;&t;&t;&t;&t; * subtraction of infinities&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_makequietnan
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * return infinity&n;&t;&t;&t;&t; */
id|Dbl_setinfinity_exponentmantissa
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * is NaN; signaling or quiet?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Dbl_isone_signaling
c_func
(paren
id|opnd2p1
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_set_quiet
c_func
(paren
id|opnd2p1
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t;&t; * is third operand a signaling NaN? &n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|Dbl_is_signalingnan
c_func
(paren
id|opnd3p1
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_set_quiet
c_func
(paren
id|opnd3p1
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * return quiet NaN&n;&t;&t;&t; */
id|Dbl_copytoptr
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * check third operand for NaN&squot;s or infinity&n;&t; */
r_if
c_cond
(paren
id|Dbl_isinfinity_exponent
c_func
(paren
id|opnd3p1
)paren
)paren
(brace
r_if
c_cond
(paren
id|Dbl_iszero_mantissa
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
)paren
(brace
multiline_comment|/* return infinity */
id|Dbl_copytoptr
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * is NaN; signaling or quiet?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Dbl_isone_signaling
c_func
(paren
id|opnd3p1
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_set_quiet
c_func
(paren
id|opnd3p1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * return quiet NaN&n; &t;&t;&t; */
id|Dbl_copytoptr
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Generate multiply mantissa&n;&t; */
r_if
c_cond
(paren
id|Dbl_isnotzero_exponent
c_func
(paren
id|opnd1p1
)paren
)paren
(brace
multiline_comment|/* set hidden bit */
id|Dbl_clear_signexponent_set_hidden
c_func
(paren
id|opnd1p1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* check for zero */
r_if
c_cond
(paren
id|Dbl_iszero_mantissa
c_func
(paren
id|opnd1p1
comma
id|opnd1p2
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Perform the add opnd3 with zero here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Dbl_iszero_exponentmantissa
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
)paren
(brace
r_if
c_cond
(paren
id|Is_rounding_mode
c_func
(paren
id|ROUNDMINUS
)paren
)paren
(brace
id|Dbl_or_signs
c_func
(paren
id|opnd3p1
comma
id|resultp1
)paren
suffix:semicolon
)brace
r_else
(brace
id|Dbl_and_signs
c_func
(paren
id|opnd3p1
comma
id|resultp1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * Now let&squot;s check for trapped underflow case.&n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|Dbl_iszero_exponent
c_func
(paren
id|opnd3p1
)paren
op_logical_and
id|Is_underflowtrap_enabled
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* need to normalize results mantissa */
id|sign_save
op_assign
id|Dbl_signextendedsign
c_func
(paren
id|opnd3p1
)paren
suffix:semicolon
id|result_exponent
op_assign
l_int|0
suffix:semicolon
id|Dbl_leftshiftby1
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
id|Dbl_normalize
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|result_exponent
)paren
suffix:semicolon
id|Dbl_set_sign
c_func
(paren
id|opnd3p1
comma
multiline_comment|/*using*/
id|sign_save
)paren
suffix:semicolon
id|Dbl_setwrapped_exponent
c_func
(paren
id|opnd3p1
comma
id|result_exponent
comma
id|unfl
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|dstptr
)paren
suffix:semicolon
multiline_comment|/* inexact = FALSE */
r_return
id|OPC_2E_UNDERFLOWEXCEPTION
suffix:semicolon
)brace
id|Dbl_copytoptr
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/* is denormalized, adjust exponent */
id|Dbl_clear_signexponent
c_func
(paren
id|opnd1p1
)paren
suffix:semicolon
id|Dbl_leftshiftby1
c_func
(paren
id|opnd1p1
comma
id|opnd1p2
)paren
suffix:semicolon
id|Dbl_normalize
c_func
(paren
id|opnd1p1
comma
id|opnd1p2
comma
id|mpy_exponent
)paren
suffix:semicolon
)brace
multiline_comment|/* opnd2 needs to have hidden bit set with msb in hidden bit */
r_if
c_cond
(paren
id|Dbl_isnotzero_exponent
c_func
(paren
id|opnd2p1
)paren
)paren
(brace
id|Dbl_clear_signexponent_set_hidden
c_func
(paren
id|opnd2p1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* check for zero */
r_if
c_cond
(paren
id|Dbl_iszero_mantissa
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Perform the add opnd3 with zero here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Dbl_iszero_exponentmantissa
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
)paren
(brace
r_if
c_cond
(paren
id|Is_rounding_mode
c_func
(paren
id|ROUNDMINUS
)paren
)paren
(brace
id|Dbl_or_signs
c_func
(paren
id|opnd3p1
comma
id|resultp1
)paren
suffix:semicolon
)brace
r_else
(brace
id|Dbl_and_signs
c_func
(paren
id|opnd3p1
comma
id|resultp1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * Now let&squot;s check for trapped underflow case.&n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|Dbl_iszero_exponent
c_func
(paren
id|opnd3p1
)paren
op_logical_and
id|Is_underflowtrap_enabled
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* need to normalize results mantissa */
id|sign_save
op_assign
id|Dbl_signextendedsign
c_func
(paren
id|opnd3p1
)paren
suffix:semicolon
id|result_exponent
op_assign
l_int|0
suffix:semicolon
id|Dbl_leftshiftby1
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
id|Dbl_normalize
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|result_exponent
)paren
suffix:semicolon
id|Dbl_set_sign
c_func
(paren
id|opnd3p1
comma
multiline_comment|/*using*/
id|sign_save
)paren
suffix:semicolon
id|Dbl_setwrapped_exponent
c_func
(paren
id|opnd3p1
comma
id|result_exponent
comma
id|unfl
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|dstptr
)paren
suffix:semicolon
multiline_comment|/* inexact = FALSE */
r_return
id|OPC_2E_UNDERFLOWEXCEPTION
suffix:semicolon
)brace
id|Dbl_copytoptr
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/* is denormalized; want to normalize */
id|Dbl_clear_signexponent
c_func
(paren
id|opnd2p1
)paren
suffix:semicolon
id|Dbl_leftshiftby1
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
)paren
suffix:semicolon
id|Dbl_normalize
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
comma
id|mpy_exponent
)paren
suffix:semicolon
)brace
multiline_comment|/* Multiply the first two source mantissas together */
multiline_comment|/* &n;&t; * The intermediate result will be kept in tmpres,&n;&t; * which needs enough room for 106 bits of mantissa,&n;&t; * so lets call it a Double extended.&n;&t; */
id|Dblext_setzero
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|tmpresp3
comma
id|tmpresp4
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Four bits at a time are inspected in each loop, and a &n;&t; * simple shift and add multiply algorithm is used. &n;&t; */
r_for
c_loop
(paren
id|count
op_assign
id|DBL_P
op_minus
l_int|1
suffix:semicolon
id|count
op_ge
l_int|0
suffix:semicolon
id|count
op_sub_assign
l_int|4
)paren
(brace
id|Dblext_rightshiftby4
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|tmpresp3
comma
id|tmpresp4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Dbit28p2
c_func
(paren
id|opnd1p2
)paren
)paren
(brace
multiline_comment|/* Fourword_add should be an ADD followed by 3 ADDC&squot;s */
id|Fourword_add
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|tmpresp3
comma
id|tmpresp4
comma
id|opnd2p1
op_lshift
l_int|3
op_or
id|opnd2p2
op_rshift
l_int|29
comma
id|opnd2p2
op_lshift
l_int|3
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Dbit29p2
c_func
(paren
id|opnd1p2
)paren
)paren
(brace
id|Fourword_add
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|tmpresp3
comma
id|tmpresp4
comma
id|opnd2p1
op_lshift
l_int|2
op_or
id|opnd2p2
op_rshift
l_int|30
comma
id|opnd2p2
op_lshift
l_int|2
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Dbit30p2
c_func
(paren
id|opnd1p2
)paren
)paren
(brace
id|Fourword_add
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|tmpresp3
comma
id|tmpresp4
comma
id|opnd2p1
op_lshift
l_int|1
op_or
id|opnd2p2
op_rshift
l_int|31
comma
id|opnd2p2
op_lshift
l_int|1
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Dbit31p2
c_func
(paren
id|opnd1p2
)paren
)paren
(brace
id|Fourword_add
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|tmpresp3
comma
id|tmpresp4
comma
id|opnd2p1
comma
id|opnd2p2
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
id|Dbl_rightshiftby4
c_func
(paren
id|opnd1p1
comma
id|opnd1p2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Is_dexthiddenoverflow
c_func
(paren
id|tmpresp1
)paren
)paren
(brace
multiline_comment|/* result mantissa &gt;= 2 (mantissa overflow) */
id|mpy_exponent
op_increment
suffix:semicolon
id|Dblext_rightshiftby1
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|tmpresp3
comma
id|tmpresp4
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Restore the sign of the mpy result which was saved in resultp1.&n;&t; * The exponent will continue to be kept in mpy_exponent.&n;&t; */
id|Dblext_set_sign
c_func
(paren
id|tmpresp1
comma
id|Dbl_sign
c_func
(paren
id|resultp1
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * No rounding is required, since the result of the multiply&n;&t; * is exact in the extended format.&n;&t; */
multiline_comment|/*&n;&t; * Now we are ready to perform the add portion of the operation.&n;&t; *&n;&t; * The exponents need to be kept as integers for now, since the&n;&t; * multiply result might not fit into the exponent field.  We&n;&t; * can&squot;t overflow or underflow because of this yet, since the&n;&t; * add could bring the final result back into range.&n;&t; */
id|add_exponent
op_assign
id|Dbl_exponent
c_func
(paren
id|opnd3p1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check for denormalized or zero add operand.&n;&t; */
r_if
c_cond
(paren
id|add_exponent
op_eq
l_int|0
)paren
(brace
multiline_comment|/* check for zero */
r_if
c_cond
(paren
id|Dbl_iszero_mantissa
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
)paren
(brace
multiline_comment|/* right is zero */
multiline_comment|/* Left can&squot;t be zero and must be result.&n;&t;&t;&t; *&n;&t;&t;&t; * The final result is now in tmpres and mpy_exponent,&n;&t;&t;&t; * and needs to be rounded and squeezed back into&n;&t;&t;&t; * double precision format from double extended.&n;&t;&t;&t; */
id|result_exponent
op_assign
id|mpy_exponent
suffix:semicolon
id|Dblext_copy
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|tmpresp3
comma
id|tmpresp4
comma
id|resultp1
comma
id|resultp2
comma
id|resultp3
comma
id|resultp4
)paren
suffix:semicolon
id|sign_save
op_assign
id|Dbl_signextendedsign
c_func
(paren
id|resultp1
)paren
suffix:semicolon
multiline_comment|/*save sign*/
r_goto
id|round
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * Neither are zeroes.  &n;&t;&t; * Adjust exponent and normalize add operand.&n;&t;&t; */
id|sign_save
op_assign
id|Dbl_signextendedsign
c_func
(paren
id|opnd3p1
)paren
suffix:semicolon
multiline_comment|/* save sign */
id|Dbl_clear_signexponent
c_func
(paren
id|opnd3p1
)paren
suffix:semicolon
id|Dbl_leftshiftby1
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
id|Dbl_normalize
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|add_exponent
)paren
suffix:semicolon
id|Dbl_set_sign
c_func
(paren
id|opnd3p1
comma
id|sign_save
)paren
suffix:semicolon
multiline_comment|/* restore sign */
)brace
r_else
(brace
id|Dbl_clear_exponent_set_hidden
c_func
(paren
id|opnd3p1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Copy opnd3 to the double extended variable called right.&n;&t; */
id|Dbl_copyto_dblext
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|rightp1
comma
id|rightp2
comma
id|rightp3
comma
id|rightp4
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * A zero &quot;save&quot; helps discover equal operands (for later),&n;&t; * and is used in swapping operands (if needed).&n;&t; */
id|Dblext_xortointp1
c_func
(paren
id|tmpresp1
comma
id|rightp1
comma
multiline_comment|/*to*/
id|save
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Compare magnitude of operands.&n;&t; */
id|Dblext_copytoint_exponentmantissap1
c_func
(paren
id|tmpresp1
comma
id|signlessleft1
)paren
suffix:semicolon
id|Dblext_copytoint_exponentmantissap1
c_func
(paren
id|rightp1
comma
id|signlessright1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mpy_exponent
OL
id|add_exponent
op_logical_or
id|mpy_exponent
op_eq
id|add_exponent
op_logical_and
id|Dblext_ismagnitudeless
c_func
(paren
id|tmpresp2
comma
id|rightp2
comma
id|signlessleft1
comma
id|signlessright1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Set the left operand to the larger one by XOR swap.&n;&t;&t; * First finish the first word &quot;save&quot;.&n;&t;&t; */
id|Dblext_xorfromintp1
c_func
(paren
id|save
comma
id|rightp1
comma
multiline_comment|/*to*/
id|rightp1
)paren
suffix:semicolon
id|Dblext_xorfromintp1
c_func
(paren
id|save
comma
id|tmpresp1
comma
multiline_comment|/*to*/
id|tmpresp1
)paren
suffix:semicolon
id|Dblext_swap_lower
c_func
(paren
id|tmpresp2
comma
id|tmpresp3
comma
id|tmpresp4
comma
id|rightp2
comma
id|rightp3
comma
id|rightp4
)paren
suffix:semicolon
multiline_comment|/* also setup exponents used in rest of routine */
id|diff_exponent
op_assign
id|add_exponent
op_minus
id|mpy_exponent
suffix:semicolon
id|result_exponent
op_assign
id|add_exponent
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* also setup exponents used in rest of routine */
id|diff_exponent
op_assign
id|mpy_exponent
op_minus
id|add_exponent
suffix:semicolon
id|result_exponent
op_assign
id|mpy_exponent
suffix:semicolon
)brace
multiline_comment|/* Invariant: left is not smaller than right. */
multiline_comment|/*&n;&t; * Special case alignment of operands that would force alignment&n;&t; * beyond the extent of the extension.  A further optimization&n;&t; * could special case this but only reduces the path length for&n;&t; * this infrequent case.&n;&t; */
r_if
c_cond
(paren
id|diff_exponent
OG
id|DBLEXT_THRESHOLD
)paren
(brace
id|diff_exponent
op_assign
id|DBLEXT_THRESHOLD
suffix:semicolon
)brace
multiline_comment|/* Align right operand by shifting it to the right */
id|Dblext_clear_sign
c_func
(paren
id|rightp1
)paren
suffix:semicolon
id|Dblext_right_align
c_func
(paren
id|rightp1
comma
id|rightp2
comma
id|rightp3
comma
id|rightp4
comma
multiline_comment|/*shifted by*/
id|diff_exponent
)paren
suffix:semicolon
multiline_comment|/* Treat sum and difference of the operands separately. */
r_if
c_cond
(paren
(paren
r_int
)paren
id|save
OL
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Difference of the two operands.  Overflow can occur if the&n;&t;&t; * multiply overflowed.  A borrow can occur out of the hidden&n;&t;&t; * bit and force a post normalization phase.&n;&t;&t; */
id|Dblext_subtract
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|tmpresp3
comma
id|tmpresp4
comma
id|rightp1
comma
id|rightp2
comma
id|rightp3
comma
id|rightp4
comma
id|resultp1
comma
id|resultp2
comma
id|resultp3
comma
id|resultp4
)paren
suffix:semicolon
id|sign_save
op_assign
id|Dbl_signextendedsign
c_func
(paren
id|resultp1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Dbl_iszero_hidden
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* Handle normalization */
multiline_comment|/* A straight foward algorithm would now shift the&n;&t;&t; * result and extension left until the hidden bit&n;&t;&t; * becomes one.  Not all of the extension bits need&n;&t;&t; * participate in the shift.  Only the two most &n;&t;&t; * significant bits (round and guard) are needed.&n;&t;&t; * If only a single shift is needed then the guard&n;&t;&t; * bit becomes a significant low order bit and the&n;&t;&t; * extension must participate in the rounding.&n;&t;&t; * If more than a single shift is needed, then all&n;&t;&t; * bits to the right of the guard bit are zeros, &n;&t;&t; * and the guard bit may or may not be zero. */
id|Dblext_leftshiftby1
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|resultp3
comma
id|resultp4
)paren
suffix:semicolon
multiline_comment|/* Need to check for a zero result.  The sign and&n;&t;&t;&t; * exponent fields have already been zeroed.  The more&n;&t;&t;&t; * efficient test of the full object can be used.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Dblext_iszero
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|resultp3
comma
id|resultp4
)paren
)paren
(brace
multiline_comment|/* Must have been &quot;x-x&quot; or &quot;x+(-x)&quot;. */
r_if
c_cond
(paren
id|Is_rounding_mode
c_func
(paren
id|ROUNDMINUS
)paren
)paren
id|Dbl_setone_sign
c_func
(paren
id|resultp1
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
id|result_exponent
op_decrement
suffix:semicolon
multiline_comment|/* Look to see if normalization is finished. */
r_if
c_cond
(paren
id|Dbl_isone_hidden
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* No further normalization is needed */
r_goto
id|round
suffix:semicolon
)brace
multiline_comment|/* Discover first one bit to determine shift amount.&n;&t;&t;&t; * Use a modified binary search.  We have already&n;&t;&t;&t; * shifted the result one position right and still&n;&t;&t;&t; * not found a one so the remainder of the extension&n;&t;&t;&t; * must be zero and simplifies rounding. */
multiline_comment|/* Scan bytes */
r_while
c_loop
(paren
id|Dbl_iszero_hiddenhigh7mantissa
c_func
(paren
id|resultp1
)paren
)paren
(brace
id|Dblext_leftshiftby8
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|resultp3
comma
id|resultp4
)paren
suffix:semicolon
id|result_exponent
op_sub_assign
l_int|8
suffix:semicolon
)brace
multiline_comment|/* Now narrow it down to the nibble */
r_if
c_cond
(paren
id|Dbl_iszero_hiddenhigh3mantissa
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* The lower nibble contains the&n;&t;&t;&t;&t; * normalizing one */
id|Dblext_leftshiftby4
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|resultp3
comma
id|resultp4
)paren
suffix:semicolon
id|result_exponent
op_sub_assign
l_int|4
suffix:semicolon
)brace
multiline_comment|/* Select case where first bit is set (already&n;&t;&t;&t; * normalized) otherwise select the proper shift. */
id|jumpsize
op_assign
id|Dbl_hiddenhigh3mantissa
c_func
(paren
id|resultp1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jumpsize
op_le
l_int|7
)paren
r_switch
c_cond
(paren
id|jumpsize
)paren
(brace
r_case
l_int|1
suffix:colon
id|Dblext_leftshiftby3
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|resultp3
comma
id|resultp4
)paren
suffix:semicolon
id|result_exponent
op_sub_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_case
l_int|3
suffix:colon
id|Dblext_leftshiftby2
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|resultp3
comma
id|resultp4
)paren
suffix:semicolon
id|result_exponent
op_sub_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
r_case
l_int|5
suffix:colon
r_case
l_int|6
suffix:colon
r_case
l_int|7
suffix:colon
id|Dblext_leftshiftby1
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|resultp3
comma
id|resultp4
)paren
suffix:semicolon
id|result_exponent
op_sub_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* end if (hidden...)... */
multiline_comment|/* Fall through and round */
)brace
multiline_comment|/* end if (save &lt; 0)... */
r_else
(brace
multiline_comment|/* Add magnitudes */
id|Dblext_addition
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|tmpresp3
comma
id|tmpresp4
comma
id|rightp1
comma
id|rightp2
comma
id|rightp3
comma
id|rightp4
comma
multiline_comment|/*to*/
id|resultp1
comma
id|resultp2
comma
id|resultp3
comma
id|resultp4
)paren
suffix:semicolon
id|sign_save
op_assign
id|Dbl_signextendedsign
c_func
(paren
id|resultp1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Dbl_isone_hiddenoverflow
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* Prenormalization required. */
id|Dblext_arithrightshiftby1
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|resultp3
comma
id|resultp4
)paren
suffix:semicolon
id|result_exponent
op_increment
suffix:semicolon
)brace
multiline_comment|/* end if hiddenoverflow... */
)brace
multiline_comment|/* end else ...add magnitudes... */
multiline_comment|/* Round the result.  If the extension and lower two words are&n;&t; * all zeros, then the result is exact.  Otherwise round in the&n;&t; * correct direction.  Underflow is possible. If a postnormalization&n;&t; * is necessary, then the mantissa is all zeros so no shift is needed.&n;&t; */
id|round
suffix:colon
r_if
c_cond
(paren
id|result_exponent
op_le
l_int|0
op_logical_and
op_logical_neg
id|Is_underflowtrap_enabled
c_func
(paren
)paren
)paren
(brace
id|Dblext_denormalize
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|resultp3
comma
id|resultp4
comma
id|result_exponent
comma
id|is_tiny
)paren
suffix:semicolon
)brace
id|Dbl_set_sign
c_func
(paren
id|resultp1
comma
multiline_comment|/*using*/
id|sign_save
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Dblext_isnotzero_mantissap3
c_func
(paren
id|resultp3
)paren
op_logical_or
id|Dblext_isnotzero_mantissap4
c_func
(paren
id|resultp4
)paren
)paren
(brace
id|inexact
op_assign
id|TRUE
suffix:semicolon
r_switch
c_cond
(paren
id|Rounding_mode
c_func
(paren
)paren
)paren
(brace
r_case
id|ROUNDNEAREST
suffix:colon
multiline_comment|/* The default. */
r_if
c_cond
(paren
id|Dblext_isone_highp3
c_func
(paren
id|resultp3
)paren
)paren
(brace
multiline_comment|/* at least 1/2 ulp */
r_if
c_cond
(paren
id|Dblext_isnotzero_low31p3
c_func
(paren
id|resultp3
)paren
op_logical_or
id|Dblext_isnotzero_mantissap4
c_func
(paren
id|resultp4
)paren
op_logical_or
id|Dblext_isone_lowp2
c_func
(paren
id|resultp2
)paren
)paren
(brace
multiline_comment|/* either exactly half way and odd or&n;&t;&t;&t;&t;&t; * more than 1/2ulp */
id|Dbl_increment
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|ROUNDPLUS
suffix:colon
r_if
c_cond
(paren
id|Dbl_iszero_sign
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* Round up positive results */
id|Dbl_increment
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ROUNDMINUS
suffix:colon
r_if
c_cond
(paren
id|Dbl_isone_sign
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* Round down negative results */
id|Dbl_increment
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
)brace
r_case
id|ROUNDZERO
suffix:colon
suffix:semicolon
multiline_comment|/* truncate is simple */
)brace
multiline_comment|/* end switch... */
r_if
c_cond
(paren
id|Dbl_isone_hiddenoverflow
c_func
(paren
id|resultp1
)paren
)paren
id|result_exponent
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result_exponent
op_ge
id|DBL_INFINITY_EXPONENT
)paren
(brace
multiline_comment|/* trap if OVERFLOWTRAP enabled */
r_if
c_cond
(paren
id|Is_overflowtrap_enabled
c_func
(paren
)paren
)paren
(brace
multiline_comment|/*&n;                         * Adjust bias of result&n;                         */
id|Dbl_setwrapped_exponent
c_func
(paren
id|resultp1
comma
id|result_exponent
comma
id|ovfl
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inexact
)paren
r_if
c_cond
(paren
id|Is_inexacttrap_enabled
c_func
(paren
)paren
)paren
r_return
(paren
id|OPC_2E_OVERFLOWEXCEPTION
op_or
id|OPC_2E_INEXACTEXCEPTION
)paren
suffix:semicolon
r_else
id|Set_inexactflag
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
id|OPC_2E_OVERFLOWEXCEPTION
)paren
suffix:semicolon
)brace
id|inexact
op_assign
id|TRUE
suffix:semicolon
id|Set_overflowflag
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* set result to infinity or largest number */
id|Dbl_setoverflow
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|result_exponent
op_le
l_int|0
)paren
(brace
multiline_comment|/* underflow case */
r_if
c_cond
(paren
id|Is_underflowtrap_enabled
c_func
(paren
)paren
)paren
(brace
multiline_comment|/*&n;                         * Adjust bias of result&n;                         */
id|Dbl_setwrapped_exponent
c_func
(paren
id|resultp1
comma
id|result_exponent
comma
id|unfl
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inexact
)paren
r_if
c_cond
(paren
id|Is_inexacttrap_enabled
c_func
(paren
)paren
)paren
r_return
(paren
id|OPC_2E_UNDERFLOWEXCEPTION
op_or
id|OPC_2E_INEXACTEXCEPTION
)paren
suffix:semicolon
r_else
id|Set_inexactflag
c_func
(paren
)paren
suffix:semicolon
r_return
id|OPC_2E_UNDERFLOWEXCEPTION
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|inexact
op_logical_and
id|is_tiny
)paren
id|Set_underflowflag
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|Dbl_set_exponent
c_func
(paren
id|resultp1
comma
id|result_exponent
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inexact
)paren
r_if
c_cond
(paren
id|Is_inexacttrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INEXACTEXCEPTION
suffix:semicolon
r_else
id|Set_inexactflag
c_func
(paren
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n; *  Double Floating-point Multiply Negate Fused Add&n; */
DECL|function|dbl_fmpynfadd
id|dbl_fmpynfadd
c_func
(paren
id|src1ptr
comma
id|src2ptr
comma
id|src3ptr
comma
id|status
comma
id|dstptr
)paren
id|dbl_floating_point
op_star
id|src1ptr
comma
op_star
id|src2ptr
comma
op_star
id|src3ptr
comma
op_star
id|dstptr
suffix:semicolon
r_int
r_int
op_star
id|status
suffix:semicolon
(brace
r_int
r_int
id|opnd1p1
comma
id|opnd1p2
comma
id|opnd2p1
comma
id|opnd2p2
comma
id|opnd3p1
comma
id|opnd3p2
suffix:semicolon
r_register
r_int
r_int
id|tmpresp1
comma
id|tmpresp2
comma
id|tmpresp3
comma
id|tmpresp4
suffix:semicolon
r_int
r_int
id|rightp1
comma
id|rightp2
comma
id|rightp3
comma
id|rightp4
suffix:semicolon
r_int
r_int
id|resultp1
comma
id|resultp2
op_assign
l_int|0
comma
id|resultp3
op_assign
l_int|0
comma
id|resultp4
op_assign
l_int|0
suffix:semicolon
r_register
r_int
id|mpy_exponent
comma
id|add_exponent
comma
id|count
suffix:semicolon
id|boolean
id|inexact
op_assign
id|FALSE
comma
id|is_tiny
op_assign
id|FALSE
suffix:semicolon
r_int
r_int
id|signlessleft1
comma
id|signlessright1
comma
id|save
suffix:semicolon
r_register
r_int
id|result_exponent
comma
id|diff_exponent
suffix:semicolon
r_int
id|sign_save
comma
id|jumpsize
suffix:semicolon
id|Dbl_copyfromptr
c_func
(paren
id|src1ptr
comma
id|opnd1p1
comma
id|opnd1p2
)paren
suffix:semicolon
id|Dbl_copyfromptr
c_func
(paren
id|src2ptr
comma
id|opnd2p1
comma
id|opnd2p2
)paren
suffix:semicolon
id|Dbl_copyfromptr
c_func
(paren
id|src3ptr
comma
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * set sign bit of result of multiply&n;&t; */
r_if
c_cond
(paren
id|Dbl_sign
c_func
(paren
id|opnd1p1
)paren
op_xor
id|Dbl_sign
c_func
(paren
id|opnd2p1
)paren
)paren
id|Dbl_setzerop1
c_func
(paren
id|resultp1
)paren
suffix:semicolon
r_else
id|Dbl_setnegativezerop1
c_func
(paren
id|resultp1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Generate multiply exponent &n;&t; */
id|mpy_exponent
op_assign
id|Dbl_exponent
c_func
(paren
id|opnd1p1
)paren
op_plus
id|Dbl_exponent
c_func
(paren
id|opnd2p1
)paren
op_minus
id|DBL_BIAS
suffix:semicolon
multiline_comment|/*&n;&t; * check first operand for NaN&squot;s or infinity&n;&t; */
r_if
c_cond
(paren
id|Dbl_isinfinity_exponent
c_func
(paren
id|opnd1p1
)paren
)paren
(brace
r_if
c_cond
(paren
id|Dbl_iszero_mantissa
c_func
(paren
id|opnd1p1
comma
id|opnd1p2
)paren
)paren
(brace
r_if
c_cond
(paren
id|Dbl_isnotnan
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
)paren
op_logical_and
id|Dbl_isnotnan
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
)paren
(brace
r_if
c_cond
(paren
id|Dbl_iszero_exponentmantissa
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t;&t; * invalid since operands are infinity &n;&t;&t;&t;&t;&t; * and zero &n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_makequietnan
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Check third operand for infinity with a&n;&t;&t;&t;&t; *  sign opposite of the multiply result&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Dbl_isinfinity
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
op_logical_and
(paren
id|Dbl_sign
c_func
(paren
id|resultp1
)paren
op_xor
id|Dbl_sign
c_func
(paren
id|opnd3p1
)paren
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t;&t; * invalid since attempting a magnitude&n;&t;&t;&t;&t;&t; * subtraction of infinities&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_makequietnan
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; &t; * return infinity&n;&t;&t;&t; &t; */
id|Dbl_setinfinity_exponentmantissa
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; &t; * is NaN; signaling or quiet?&n;&t;&t; &t; */
r_if
c_cond
(paren
id|Dbl_isone_signaling
c_func
(paren
id|opnd1p1
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_set_quiet
c_func
(paren
id|opnd1p1
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t;&t; * is second operand a signaling NaN? &n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|Dbl_is_signalingnan
c_func
(paren
id|opnd2p1
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_set_quiet
c_func
(paren
id|opnd2p1
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t;&t; * is third operand a signaling NaN? &n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|Dbl_is_signalingnan
c_func
(paren
id|opnd3p1
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_set_quiet
c_func
(paren
id|opnd3p1
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; &t; * return quiet NaN&n;&t;&t; &t; */
id|Dbl_copytoptr
c_func
(paren
id|opnd1p1
comma
id|opnd1p2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * check second operand for NaN&squot;s or infinity&n;&t; */
r_if
c_cond
(paren
id|Dbl_isinfinity_exponent
c_func
(paren
id|opnd2p1
)paren
)paren
(brace
r_if
c_cond
(paren
id|Dbl_iszero_mantissa
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
)paren
)paren
(brace
r_if
c_cond
(paren
id|Dbl_isnotnan
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
)paren
(brace
r_if
c_cond
(paren
id|Dbl_iszero_exponentmantissa
c_func
(paren
id|opnd1p1
comma
id|opnd1p2
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t;&t; * invalid since multiply operands are&n;&t;&t;&t;&t;&t; * zero &amp; infinity&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_makequietnan
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Check third operand for infinity with a&n;&t;&t;&t;&t; *  sign opposite of the multiply result&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Dbl_isinfinity
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
op_logical_and
(paren
id|Dbl_sign
c_func
(paren
id|resultp1
)paren
op_xor
id|Dbl_sign
c_func
(paren
id|opnd3p1
)paren
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t;&t; * invalid since attempting a magnitude&n;&t;&t;&t;&t;&t; * subtraction of infinities&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_makequietnan
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * return infinity&n;&t;&t;&t;&t; */
id|Dbl_setinfinity_exponentmantissa
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * is NaN; signaling or quiet?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Dbl_isone_signaling
c_func
(paren
id|opnd2p1
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_set_quiet
c_func
(paren
id|opnd2p1
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t;&t; * is third operand a signaling NaN? &n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|Dbl_is_signalingnan
c_func
(paren
id|opnd3p1
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_set_quiet
c_func
(paren
id|opnd3p1
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * return quiet NaN&n;&t;&t;&t; */
id|Dbl_copytoptr
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * check third operand for NaN&squot;s or infinity&n;&t; */
r_if
c_cond
(paren
id|Dbl_isinfinity_exponent
c_func
(paren
id|opnd3p1
)paren
)paren
(brace
r_if
c_cond
(paren
id|Dbl_iszero_mantissa
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
)paren
(brace
multiline_comment|/* return infinity */
id|Dbl_copytoptr
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * is NaN; signaling or quiet?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Dbl_isone_signaling
c_func
(paren
id|opnd3p1
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_set_quiet
c_func
(paren
id|opnd3p1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * return quiet NaN&n; &t;&t;&t; */
id|Dbl_copytoptr
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Generate multiply mantissa&n;&t; */
r_if
c_cond
(paren
id|Dbl_isnotzero_exponent
c_func
(paren
id|opnd1p1
)paren
)paren
(brace
multiline_comment|/* set hidden bit */
id|Dbl_clear_signexponent_set_hidden
c_func
(paren
id|opnd1p1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* check for zero */
r_if
c_cond
(paren
id|Dbl_iszero_mantissa
c_func
(paren
id|opnd1p1
comma
id|opnd1p2
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Perform the add opnd3 with zero here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Dbl_iszero_exponentmantissa
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
)paren
(brace
r_if
c_cond
(paren
id|Is_rounding_mode
c_func
(paren
id|ROUNDMINUS
)paren
)paren
(brace
id|Dbl_or_signs
c_func
(paren
id|opnd3p1
comma
id|resultp1
)paren
suffix:semicolon
)brace
r_else
(brace
id|Dbl_and_signs
c_func
(paren
id|opnd3p1
comma
id|resultp1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * Now let&squot;s check for trapped underflow case.&n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|Dbl_iszero_exponent
c_func
(paren
id|opnd3p1
)paren
op_logical_and
id|Is_underflowtrap_enabled
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* need to normalize results mantissa */
id|sign_save
op_assign
id|Dbl_signextendedsign
c_func
(paren
id|opnd3p1
)paren
suffix:semicolon
id|result_exponent
op_assign
l_int|0
suffix:semicolon
id|Dbl_leftshiftby1
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
id|Dbl_normalize
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|result_exponent
)paren
suffix:semicolon
id|Dbl_set_sign
c_func
(paren
id|opnd3p1
comma
multiline_comment|/*using*/
id|sign_save
)paren
suffix:semicolon
id|Dbl_setwrapped_exponent
c_func
(paren
id|opnd3p1
comma
id|result_exponent
comma
id|unfl
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|dstptr
)paren
suffix:semicolon
multiline_comment|/* inexact = FALSE */
r_return
id|OPC_2E_UNDERFLOWEXCEPTION
suffix:semicolon
)brace
id|Dbl_copytoptr
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/* is denormalized, adjust exponent */
id|Dbl_clear_signexponent
c_func
(paren
id|opnd1p1
)paren
suffix:semicolon
id|Dbl_leftshiftby1
c_func
(paren
id|opnd1p1
comma
id|opnd1p2
)paren
suffix:semicolon
id|Dbl_normalize
c_func
(paren
id|opnd1p1
comma
id|opnd1p2
comma
id|mpy_exponent
)paren
suffix:semicolon
)brace
multiline_comment|/* opnd2 needs to have hidden bit set with msb in hidden bit */
r_if
c_cond
(paren
id|Dbl_isnotzero_exponent
c_func
(paren
id|opnd2p1
)paren
)paren
(brace
id|Dbl_clear_signexponent_set_hidden
c_func
(paren
id|opnd2p1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* check for zero */
r_if
c_cond
(paren
id|Dbl_iszero_mantissa
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Perform the add opnd3 with zero here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Dbl_iszero_exponentmantissa
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
)paren
(brace
r_if
c_cond
(paren
id|Is_rounding_mode
c_func
(paren
id|ROUNDMINUS
)paren
)paren
(brace
id|Dbl_or_signs
c_func
(paren
id|opnd3p1
comma
id|resultp1
)paren
suffix:semicolon
)brace
r_else
(brace
id|Dbl_and_signs
c_func
(paren
id|opnd3p1
comma
id|resultp1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * Now let&squot;s check for trapped underflow case.&n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|Dbl_iszero_exponent
c_func
(paren
id|opnd3p1
)paren
op_logical_and
id|Is_underflowtrap_enabled
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* need to normalize results mantissa */
id|sign_save
op_assign
id|Dbl_signextendedsign
c_func
(paren
id|opnd3p1
)paren
suffix:semicolon
id|result_exponent
op_assign
l_int|0
suffix:semicolon
id|Dbl_leftshiftby1
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
id|Dbl_normalize
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|result_exponent
)paren
suffix:semicolon
id|Dbl_set_sign
c_func
(paren
id|opnd3p1
comma
multiline_comment|/*using*/
id|sign_save
)paren
suffix:semicolon
id|Dbl_setwrapped_exponent
c_func
(paren
id|opnd3p1
comma
id|result_exponent
comma
id|unfl
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|dstptr
)paren
suffix:semicolon
multiline_comment|/* inexact = FALSE */
r_return
id|OPC_2E_UNDERFLOWEXCEPTION
suffix:semicolon
)brace
id|Dbl_copytoptr
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/* is denormalized; want to normalize */
id|Dbl_clear_signexponent
c_func
(paren
id|opnd2p1
)paren
suffix:semicolon
id|Dbl_leftshiftby1
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
)paren
suffix:semicolon
id|Dbl_normalize
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
comma
id|mpy_exponent
)paren
suffix:semicolon
)brace
multiline_comment|/* Multiply the first two source mantissas together */
multiline_comment|/* &n;&t; * The intermediate result will be kept in tmpres,&n;&t; * which needs enough room for 106 bits of mantissa,&n;&t; * so lets call it a Double extended.&n;&t; */
id|Dblext_setzero
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|tmpresp3
comma
id|tmpresp4
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Four bits at a time are inspected in each loop, and a &n;&t; * simple shift and add multiply algorithm is used. &n;&t; */
r_for
c_loop
(paren
id|count
op_assign
id|DBL_P
op_minus
l_int|1
suffix:semicolon
id|count
op_ge
l_int|0
suffix:semicolon
id|count
op_sub_assign
l_int|4
)paren
(brace
id|Dblext_rightshiftby4
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|tmpresp3
comma
id|tmpresp4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Dbit28p2
c_func
(paren
id|opnd1p2
)paren
)paren
(brace
multiline_comment|/* Fourword_add should be an ADD followed by 3 ADDC&squot;s */
id|Fourword_add
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|tmpresp3
comma
id|tmpresp4
comma
id|opnd2p1
op_lshift
l_int|3
op_or
id|opnd2p2
op_rshift
l_int|29
comma
id|opnd2p2
op_lshift
l_int|3
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Dbit29p2
c_func
(paren
id|opnd1p2
)paren
)paren
(brace
id|Fourword_add
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|tmpresp3
comma
id|tmpresp4
comma
id|opnd2p1
op_lshift
l_int|2
op_or
id|opnd2p2
op_rshift
l_int|30
comma
id|opnd2p2
op_lshift
l_int|2
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Dbit30p2
c_func
(paren
id|opnd1p2
)paren
)paren
(brace
id|Fourword_add
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|tmpresp3
comma
id|tmpresp4
comma
id|opnd2p1
op_lshift
l_int|1
op_or
id|opnd2p2
op_rshift
l_int|31
comma
id|opnd2p2
op_lshift
l_int|1
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Dbit31p2
c_func
(paren
id|opnd1p2
)paren
)paren
(brace
id|Fourword_add
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|tmpresp3
comma
id|tmpresp4
comma
id|opnd2p1
comma
id|opnd2p2
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
id|Dbl_rightshiftby4
c_func
(paren
id|opnd1p1
comma
id|opnd1p2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Is_dexthiddenoverflow
c_func
(paren
id|tmpresp1
)paren
)paren
(brace
multiline_comment|/* result mantissa &gt;= 2 (mantissa overflow) */
id|mpy_exponent
op_increment
suffix:semicolon
id|Dblext_rightshiftby1
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|tmpresp3
comma
id|tmpresp4
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Restore the sign of the mpy result which was saved in resultp1.&n;&t; * The exponent will continue to be kept in mpy_exponent.&n;&t; */
id|Dblext_set_sign
c_func
(paren
id|tmpresp1
comma
id|Dbl_sign
c_func
(paren
id|resultp1
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * No rounding is required, since the result of the multiply&n;&t; * is exact in the extended format.&n;&t; */
multiline_comment|/*&n;&t; * Now we are ready to perform the add portion of the operation.&n;&t; *&n;&t; * The exponents need to be kept as integers for now, since the&n;&t; * multiply result might not fit into the exponent field.  We&n;&t; * can&squot;t overflow or underflow because of this yet, since the&n;&t; * add could bring the final result back into range.&n;&t; */
id|add_exponent
op_assign
id|Dbl_exponent
c_func
(paren
id|opnd3p1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check for denormalized or zero add operand.&n;&t; */
r_if
c_cond
(paren
id|add_exponent
op_eq
l_int|0
)paren
(brace
multiline_comment|/* check for zero */
r_if
c_cond
(paren
id|Dbl_iszero_mantissa
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
)paren
(brace
multiline_comment|/* right is zero */
multiline_comment|/* Left can&squot;t be zero and must be result.&n;&t;&t;&t; *&n;&t;&t;&t; * The final result is now in tmpres and mpy_exponent,&n;&t;&t;&t; * and needs to be rounded and squeezed back into&n;&t;&t;&t; * double precision format from double extended.&n;&t;&t;&t; */
id|result_exponent
op_assign
id|mpy_exponent
suffix:semicolon
id|Dblext_copy
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|tmpresp3
comma
id|tmpresp4
comma
id|resultp1
comma
id|resultp2
comma
id|resultp3
comma
id|resultp4
)paren
suffix:semicolon
id|sign_save
op_assign
id|Dbl_signextendedsign
c_func
(paren
id|resultp1
)paren
suffix:semicolon
multiline_comment|/*save sign*/
r_goto
id|round
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * Neither are zeroes.  &n;&t;&t; * Adjust exponent and normalize add operand.&n;&t;&t; */
id|sign_save
op_assign
id|Dbl_signextendedsign
c_func
(paren
id|opnd3p1
)paren
suffix:semicolon
multiline_comment|/* save sign */
id|Dbl_clear_signexponent
c_func
(paren
id|opnd3p1
)paren
suffix:semicolon
id|Dbl_leftshiftby1
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
id|Dbl_normalize
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|add_exponent
)paren
suffix:semicolon
id|Dbl_set_sign
c_func
(paren
id|opnd3p1
comma
id|sign_save
)paren
suffix:semicolon
multiline_comment|/* restore sign */
)brace
r_else
(brace
id|Dbl_clear_exponent_set_hidden
c_func
(paren
id|opnd3p1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Copy opnd3 to the double extended variable called right.&n;&t; */
id|Dbl_copyto_dblext
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|rightp1
comma
id|rightp2
comma
id|rightp3
comma
id|rightp4
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * A zero &quot;save&quot; helps discover equal operands (for later),&n;&t; * and is used in swapping operands (if needed).&n;&t; */
id|Dblext_xortointp1
c_func
(paren
id|tmpresp1
comma
id|rightp1
comma
multiline_comment|/*to*/
id|save
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Compare magnitude of operands.&n;&t; */
id|Dblext_copytoint_exponentmantissap1
c_func
(paren
id|tmpresp1
comma
id|signlessleft1
)paren
suffix:semicolon
id|Dblext_copytoint_exponentmantissap1
c_func
(paren
id|rightp1
comma
id|signlessright1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mpy_exponent
OL
id|add_exponent
op_logical_or
id|mpy_exponent
op_eq
id|add_exponent
op_logical_and
id|Dblext_ismagnitudeless
c_func
(paren
id|tmpresp2
comma
id|rightp2
comma
id|signlessleft1
comma
id|signlessright1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Set the left operand to the larger one by XOR swap.&n;&t;&t; * First finish the first word &quot;save&quot;.&n;&t;&t; */
id|Dblext_xorfromintp1
c_func
(paren
id|save
comma
id|rightp1
comma
multiline_comment|/*to*/
id|rightp1
)paren
suffix:semicolon
id|Dblext_xorfromintp1
c_func
(paren
id|save
comma
id|tmpresp1
comma
multiline_comment|/*to*/
id|tmpresp1
)paren
suffix:semicolon
id|Dblext_swap_lower
c_func
(paren
id|tmpresp2
comma
id|tmpresp3
comma
id|tmpresp4
comma
id|rightp2
comma
id|rightp3
comma
id|rightp4
)paren
suffix:semicolon
multiline_comment|/* also setup exponents used in rest of routine */
id|diff_exponent
op_assign
id|add_exponent
op_minus
id|mpy_exponent
suffix:semicolon
id|result_exponent
op_assign
id|add_exponent
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* also setup exponents used in rest of routine */
id|diff_exponent
op_assign
id|mpy_exponent
op_minus
id|add_exponent
suffix:semicolon
id|result_exponent
op_assign
id|mpy_exponent
suffix:semicolon
)brace
multiline_comment|/* Invariant: left is not smaller than right. */
multiline_comment|/*&n;&t; * Special case alignment of operands that would force alignment&n;&t; * beyond the extent of the extension.  A further optimization&n;&t; * could special case this but only reduces the path length for&n;&t; * this infrequent case.&n;&t; */
r_if
c_cond
(paren
id|diff_exponent
OG
id|DBLEXT_THRESHOLD
)paren
(brace
id|diff_exponent
op_assign
id|DBLEXT_THRESHOLD
suffix:semicolon
)brace
multiline_comment|/* Align right operand by shifting it to the right */
id|Dblext_clear_sign
c_func
(paren
id|rightp1
)paren
suffix:semicolon
id|Dblext_right_align
c_func
(paren
id|rightp1
comma
id|rightp2
comma
id|rightp3
comma
id|rightp4
comma
multiline_comment|/*shifted by*/
id|diff_exponent
)paren
suffix:semicolon
multiline_comment|/* Treat sum and difference of the operands separately. */
r_if
c_cond
(paren
(paren
r_int
)paren
id|save
OL
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Difference of the two operands.  Overflow can occur if the&n;&t;&t; * multiply overflowed.  A borrow can occur out of the hidden&n;&t;&t; * bit and force a post normalization phase.&n;&t;&t; */
id|Dblext_subtract
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|tmpresp3
comma
id|tmpresp4
comma
id|rightp1
comma
id|rightp2
comma
id|rightp3
comma
id|rightp4
comma
id|resultp1
comma
id|resultp2
comma
id|resultp3
comma
id|resultp4
)paren
suffix:semicolon
id|sign_save
op_assign
id|Dbl_signextendedsign
c_func
(paren
id|resultp1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Dbl_iszero_hidden
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* Handle normalization */
multiline_comment|/* A straight foward algorithm would now shift the&n;&t;&t; * result and extension left until the hidden bit&n;&t;&t; * becomes one.  Not all of the extension bits need&n;&t;&t; * participate in the shift.  Only the two most &n;&t;&t; * significant bits (round and guard) are needed.&n;&t;&t; * If only a single shift is needed then the guard&n;&t;&t; * bit becomes a significant low order bit and the&n;&t;&t; * extension must participate in the rounding.&n;&t;&t; * If more than a single shift is needed, then all&n;&t;&t; * bits to the right of the guard bit are zeros, &n;&t;&t; * and the guard bit may or may not be zero. */
id|Dblext_leftshiftby1
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|resultp3
comma
id|resultp4
)paren
suffix:semicolon
multiline_comment|/* Need to check for a zero result.  The sign and&n;&t;&t;&t; * exponent fields have already been zeroed.  The more&n;&t;&t;&t; * efficient test of the full object can be used.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Dblext_iszero
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|resultp3
comma
id|resultp4
)paren
)paren
(brace
multiline_comment|/* Must have been &quot;x-x&quot; or &quot;x+(-x)&quot;. */
r_if
c_cond
(paren
id|Is_rounding_mode
c_func
(paren
id|ROUNDMINUS
)paren
)paren
id|Dbl_setone_sign
c_func
(paren
id|resultp1
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
id|result_exponent
op_decrement
suffix:semicolon
multiline_comment|/* Look to see if normalization is finished. */
r_if
c_cond
(paren
id|Dbl_isone_hidden
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* No further normalization is needed */
r_goto
id|round
suffix:semicolon
)brace
multiline_comment|/* Discover first one bit to determine shift amount.&n;&t;&t;&t; * Use a modified binary search.  We have already&n;&t;&t;&t; * shifted the result one position right and still&n;&t;&t;&t; * not found a one so the remainder of the extension&n;&t;&t;&t; * must be zero and simplifies rounding. */
multiline_comment|/* Scan bytes */
r_while
c_loop
(paren
id|Dbl_iszero_hiddenhigh7mantissa
c_func
(paren
id|resultp1
)paren
)paren
(brace
id|Dblext_leftshiftby8
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|resultp3
comma
id|resultp4
)paren
suffix:semicolon
id|result_exponent
op_sub_assign
l_int|8
suffix:semicolon
)brace
multiline_comment|/* Now narrow it down to the nibble */
r_if
c_cond
(paren
id|Dbl_iszero_hiddenhigh3mantissa
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* The lower nibble contains the&n;&t;&t;&t;&t; * normalizing one */
id|Dblext_leftshiftby4
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|resultp3
comma
id|resultp4
)paren
suffix:semicolon
id|result_exponent
op_sub_assign
l_int|4
suffix:semicolon
)brace
multiline_comment|/* Select case where first bit is set (already&n;&t;&t;&t; * normalized) otherwise select the proper shift. */
id|jumpsize
op_assign
id|Dbl_hiddenhigh3mantissa
c_func
(paren
id|resultp1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jumpsize
op_le
l_int|7
)paren
r_switch
c_cond
(paren
id|jumpsize
)paren
(brace
r_case
l_int|1
suffix:colon
id|Dblext_leftshiftby3
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|resultp3
comma
id|resultp4
)paren
suffix:semicolon
id|result_exponent
op_sub_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_case
l_int|3
suffix:colon
id|Dblext_leftshiftby2
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|resultp3
comma
id|resultp4
)paren
suffix:semicolon
id|result_exponent
op_sub_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
r_case
l_int|5
suffix:colon
r_case
l_int|6
suffix:colon
r_case
l_int|7
suffix:colon
id|Dblext_leftshiftby1
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|resultp3
comma
id|resultp4
)paren
suffix:semicolon
id|result_exponent
op_sub_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* end if (hidden...)... */
multiline_comment|/* Fall through and round */
)brace
multiline_comment|/* end if (save &lt; 0)... */
r_else
(brace
multiline_comment|/* Add magnitudes */
id|Dblext_addition
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|tmpresp3
comma
id|tmpresp4
comma
id|rightp1
comma
id|rightp2
comma
id|rightp3
comma
id|rightp4
comma
multiline_comment|/*to*/
id|resultp1
comma
id|resultp2
comma
id|resultp3
comma
id|resultp4
)paren
suffix:semicolon
id|sign_save
op_assign
id|Dbl_signextendedsign
c_func
(paren
id|resultp1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Dbl_isone_hiddenoverflow
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* Prenormalization required. */
id|Dblext_arithrightshiftby1
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|resultp3
comma
id|resultp4
)paren
suffix:semicolon
id|result_exponent
op_increment
suffix:semicolon
)brace
multiline_comment|/* end if hiddenoverflow... */
)brace
multiline_comment|/* end else ...add magnitudes... */
multiline_comment|/* Round the result.  If the extension and lower two words are&n;&t; * all zeros, then the result is exact.  Otherwise round in the&n;&t; * correct direction.  Underflow is possible. If a postnormalization&n;&t; * is necessary, then the mantissa is all zeros so no shift is needed.&n;&t; */
id|round
suffix:colon
r_if
c_cond
(paren
id|result_exponent
op_le
l_int|0
op_logical_and
op_logical_neg
id|Is_underflowtrap_enabled
c_func
(paren
)paren
)paren
(brace
id|Dblext_denormalize
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|resultp3
comma
id|resultp4
comma
id|result_exponent
comma
id|is_tiny
)paren
suffix:semicolon
)brace
id|Dbl_set_sign
c_func
(paren
id|resultp1
comma
multiline_comment|/*using*/
id|sign_save
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Dblext_isnotzero_mantissap3
c_func
(paren
id|resultp3
)paren
op_logical_or
id|Dblext_isnotzero_mantissap4
c_func
(paren
id|resultp4
)paren
)paren
(brace
id|inexact
op_assign
id|TRUE
suffix:semicolon
r_switch
c_cond
(paren
id|Rounding_mode
c_func
(paren
)paren
)paren
(brace
r_case
id|ROUNDNEAREST
suffix:colon
multiline_comment|/* The default. */
r_if
c_cond
(paren
id|Dblext_isone_highp3
c_func
(paren
id|resultp3
)paren
)paren
(brace
multiline_comment|/* at least 1/2 ulp */
r_if
c_cond
(paren
id|Dblext_isnotzero_low31p3
c_func
(paren
id|resultp3
)paren
op_logical_or
id|Dblext_isnotzero_mantissap4
c_func
(paren
id|resultp4
)paren
op_logical_or
id|Dblext_isone_lowp2
c_func
(paren
id|resultp2
)paren
)paren
(brace
multiline_comment|/* either exactly half way and odd or&n;&t;&t;&t;&t;&t; * more than 1/2ulp */
id|Dbl_increment
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|ROUNDPLUS
suffix:colon
r_if
c_cond
(paren
id|Dbl_iszero_sign
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* Round up positive results */
id|Dbl_increment
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ROUNDMINUS
suffix:colon
r_if
c_cond
(paren
id|Dbl_isone_sign
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* Round down negative results */
id|Dbl_increment
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
)brace
r_case
id|ROUNDZERO
suffix:colon
suffix:semicolon
multiline_comment|/* truncate is simple */
)brace
multiline_comment|/* end switch... */
r_if
c_cond
(paren
id|Dbl_isone_hiddenoverflow
c_func
(paren
id|resultp1
)paren
)paren
id|result_exponent
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result_exponent
op_ge
id|DBL_INFINITY_EXPONENT
)paren
(brace
multiline_comment|/* Overflow */
r_if
c_cond
(paren
id|Is_overflowtrap_enabled
c_func
(paren
)paren
)paren
(brace
multiline_comment|/*&n;                         * Adjust bias of result&n;                         */
id|Dbl_setwrapped_exponent
c_func
(paren
id|resultp1
comma
id|result_exponent
comma
id|ovfl
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inexact
)paren
r_if
c_cond
(paren
id|Is_inexacttrap_enabled
c_func
(paren
)paren
)paren
r_return
(paren
id|OPC_2E_OVERFLOWEXCEPTION
op_or
id|OPC_2E_INEXACTEXCEPTION
)paren
suffix:semicolon
r_else
id|Set_inexactflag
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
id|OPC_2E_OVERFLOWEXCEPTION
)paren
suffix:semicolon
)brace
id|inexact
op_assign
id|TRUE
suffix:semicolon
id|Set_overflowflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_setoverflow
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|result_exponent
op_le
l_int|0
)paren
(brace
multiline_comment|/* underflow case */
r_if
c_cond
(paren
id|Is_underflowtrap_enabled
c_func
(paren
)paren
)paren
(brace
multiline_comment|/*&n;                         * Adjust bias of result&n;                         */
id|Dbl_setwrapped_exponent
c_func
(paren
id|resultp1
comma
id|result_exponent
comma
id|unfl
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inexact
)paren
r_if
c_cond
(paren
id|Is_inexacttrap_enabled
c_func
(paren
)paren
)paren
r_return
(paren
id|OPC_2E_UNDERFLOWEXCEPTION
op_or
id|OPC_2E_INEXACTEXCEPTION
)paren
suffix:semicolon
r_else
id|Set_inexactflag
c_func
(paren
)paren
suffix:semicolon
r_return
id|OPC_2E_UNDERFLOWEXCEPTION
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|inexact
op_logical_and
id|is_tiny
)paren
id|Set_underflowflag
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|Dbl_set_exponent
c_func
(paren
id|resultp1
comma
id|result_exponent
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inexact
)paren
r_if
c_cond
(paren
id|Is_inexacttrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INEXACTEXCEPTION
suffix:semicolon
r_else
id|Set_inexactflag
c_func
(paren
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n; *  Single Floating-point Multiply Fused Add&n; */
DECL|function|sgl_fmpyfadd
id|sgl_fmpyfadd
c_func
(paren
id|src1ptr
comma
id|src2ptr
comma
id|src3ptr
comma
id|status
comma
id|dstptr
)paren
id|sgl_floating_point
op_star
id|src1ptr
comma
op_star
id|src2ptr
comma
op_star
id|src3ptr
comma
op_star
id|dstptr
suffix:semicolon
r_int
r_int
op_star
id|status
suffix:semicolon
(brace
r_int
r_int
id|opnd1
comma
id|opnd2
comma
id|opnd3
suffix:semicolon
r_register
r_int
r_int
id|tmpresp1
comma
id|tmpresp2
suffix:semicolon
r_int
r_int
id|rightp1
comma
id|rightp2
suffix:semicolon
r_int
r_int
id|resultp1
comma
id|resultp2
op_assign
l_int|0
suffix:semicolon
r_register
r_int
id|mpy_exponent
comma
id|add_exponent
comma
id|count
suffix:semicolon
id|boolean
id|inexact
op_assign
id|FALSE
comma
id|is_tiny
op_assign
id|FALSE
suffix:semicolon
r_int
r_int
id|signlessleft1
comma
id|signlessright1
comma
id|save
suffix:semicolon
r_register
r_int
id|result_exponent
comma
id|diff_exponent
suffix:semicolon
r_int
id|sign_save
comma
id|jumpsize
suffix:semicolon
id|Sgl_copyfromptr
c_func
(paren
id|src1ptr
comma
id|opnd1
)paren
suffix:semicolon
id|Sgl_copyfromptr
c_func
(paren
id|src2ptr
comma
id|opnd2
)paren
suffix:semicolon
id|Sgl_copyfromptr
c_func
(paren
id|src3ptr
comma
id|opnd3
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * set sign bit of result of multiply&n;&t; */
r_if
c_cond
(paren
id|Sgl_sign
c_func
(paren
id|opnd1
)paren
op_xor
id|Sgl_sign
c_func
(paren
id|opnd2
)paren
)paren
id|Sgl_setnegativezero
c_func
(paren
id|resultp1
)paren
suffix:semicolon
r_else
id|Sgl_setzero
c_func
(paren
id|resultp1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Generate multiply exponent &n;&t; */
id|mpy_exponent
op_assign
id|Sgl_exponent
c_func
(paren
id|opnd1
)paren
op_plus
id|Sgl_exponent
c_func
(paren
id|opnd2
)paren
op_minus
id|SGL_BIAS
suffix:semicolon
multiline_comment|/*&n;&t; * check first operand for NaN&squot;s or infinity&n;&t; */
r_if
c_cond
(paren
id|Sgl_isinfinity_exponent
c_func
(paren
id|opnd1
)paren
)paren
(brace
r_if
c_cond
(paren
id|Sgl_iszero_mantissa
c_func
(paren
id|opnd1
)paren
)paren
(brace
r_if
c_cond
(paren
id|Sgl_isnotnan
c_func
(paren
id|opnd2
)paren
op_logical_and
id|Sgl_isnotnan
c_func
(paren
id|opnd3
)paren
)paren
(brace
r_if
c_cond
(paren
id|Sgl_iszero_exponentmantissa
c_func
(paren
id|opnd2
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t;&t; * invalid since operands are infinity &n;&t;&t;&t;&t;&t; * and zero &n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_makequietnan
c_func
(paren
id|resultp1
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|resultp1
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Check third operand for infinity with a&n;&t;&t;&t;&t; *  sign opposite of the multiply result&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Sgl_isinfinity
c_func
(paren
id|opnd3
)paren
op_logical_and
(paren
id|Sgl_sign
c_func
(paren
id|resultp1
)paren
op_xor
id|Sgl_sign
c_func
(paren
id|opnd3
)paren
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t;&t; * invalid since attempting a magnitude&n;&t;&t;&t;&t;&t; * subtraction of infinities&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_makequietnan
c_func
(paren
id|resultp1
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|resultp1
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; &t; * return infinity&n;&t;&t;&t; &t; */
id|Sgl_setinfinity_exponentmantissa
c_func
(paren
id|resultp1
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|resultp1
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; &t; * is NaN; signaling or quiet?&n;&t;&t; &t; */
r_if
c_cond
(paren
id|Sgl_isone_signaling
c_func
(paren
id|opnd1
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_set_quiet
c_func
(paren
id|opnd1
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t;&t; * is second operand a signaling NaN? &n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|Sgl_is_signalingnan
c_func
(paren
id|opnd2
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_set_quiet
c_func
(paren
id|opnd2
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|opnd2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t;&t; * is third operand a signaling NaN? &n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|Sgl_is_signalingnan
c_func
(paren
id|opnd3
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_set_quiet
c_func
(paren
id|opnd3
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|opnd3
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; &t; * return quiet NaN&n;&t;&t; &t; */
id|Sgl_copytoptr
c_func
(paren
id|opnd1
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * check second operand for NaN&squot;s or infinity&n;&t; */
r_if
c_cond
(paren
id|Sgl_isinfinity_exponent
c_func
(paren
id|opnd2
)paren
)paren
(brace
r_if
c_cond
(paren
id|Sgl_iszero_mantissa
c_func
(paren
id|opnd2
)paren
)paren
(brace
r_if
c_cond
(paren
id|Sgl_isnotnan
c_func
(paren
id|opnd3
)paren
)paren
(brace
r_if
c_cond
(paren
id|Sgl_iszero_exponentmantissa
c_func
(paren
id|opnd1
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t;&t; * invalid since multiply operands are&n;&t;&t;&t;&t;&t; * zero &amp; infinity&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_makequietnan
c_func
(paren
id|opnd2
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|opnd2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Check third operand for infinity with a&n;&t;&t;&t;&t; *  sign opposite of the multiply result&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Sgl_isinfinity
c_func
(paren
id|opnd3
)paren
op_logical_and
(paren
id|Sgl_sign
c_func
(paren
id|resultp1
)paren
op_xor
id|Sgl_sign
c_func
(paren
id|opnd3
)paren
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t;&t; * invalid since attempting a magnitude&n;&t;&t;&t;&t;&t; * subtraction of infinities&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_makequietnan
c_func
(paren
id|resultp1
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|resultp1
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * return infinity&n;&t;&t;&t;&t; */
id|Sgl_setinfinity_exponentmantissa
c_func
(paren
id|resultp1
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|resultp1
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * is NaN; signaling or quiet?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Sgl_isone_signaling
c_func
(paren
id|opnd2
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_set_quiet
c_func
(paren
id|opnd2
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t;&t; * is third operand a signaling NaN? &n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|Sgl_is_signalingnan
c_func
(paren
id|opnd3
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_set_quiet
c_func
(paren
id|opnd3
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|opnd3
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * return quiet NaN&n;&t;&t;&t; */
id|Sgl_copytoptr
c_func
(paren
id|opnd2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * check third operand for NaN&squot;s or infinity&n;&t; */
r_if
c_cond
(paren
id|Sgl_isinfinity_exponent
c_func
(paren
id|opnd3
)paren
)paren
(brace
r_if
c_cond
(paren
id|Sgl_iszero_mantissa
c_func
(paren
id|opnd3
)paren
)paren
(brace
multiline_comment|/* return infinity */
id|Sgl_copytoptr
c_func
(paren
id|opnd3
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * is NaN; signaling or quiet?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Sgl_isone_signaling
c_func
(paren
id|opnd3
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_set_quiet
c_func
(paren
id|opnd3
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * return quiet NaN&n; &t;&t;&t; */
id|Sgl_copytoptr
c_func
(paren
id|opnd3
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Generate multiply mantissa&n;&t; */
r_if
c_cond
(paren
id|Sgl_isnotzero_exponent
c_func
(paren
id|opnd1
)paren
)paren
(brace
multiline_comment|/* set hidden bit */
id|Sgl_clear_signexponent_set_hidden
c_func
(paren
id|opnd1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* check for zero */
r_if
c_cond
(paren
id|Sgl_iszero_mantissa
c_func
(paren
id|opnd1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Perform the add opnd3 with zero here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Sgl_iszero_exponentmantissa
c_func
(paren
id|opnd3
)paren
)paren
(brace
r_if
c_cond
(paren
id|Is_rounding_mode
c_func
(paren
id|ROUNDMINUS
)paren
)paren
(brace
id|Sgl_or_signs
c_func
(paren
id|opnd3
comma
id|resultp1
)paren
suffix:semicolon
)brace
r_else
(brace
id|Sgl_and_signs
c_func
(paren
id|opnd3
comma
id|resultp1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * Now let&squot;s check for trapped underflow case.&n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|Sgl_iszero_exponent
c_func
(paren
id|opnd3
)paren
op_logical_and
id|Is_underflowtrap_enabled
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* need to normalize results mantissa */
id|sign_save
op_assign
id|Sgl_signextendedsign
c_func
(paren
id|opnd3
)paren
suffix:semicolon
id|result_exponent
op_assign
l_int|0
suffix:semicolon
id|Sgl_leftshiftby1
c_func
(paren
id|opnd3
)paren
suffix:semicolon
id|Sgl_normalize
c_func
(paren
id|opnd3
comma
id|result_exponent
)paren
suffix:semicolon
id|Sgl_set_sign
c_func
(paren
id|opnd3
comma
multiline_comment|/*using*/
id|sign_save
)paren
suffix:semicolon
id|Sgl_setwrapped_exponent
c_func
(paren
id|opnd3
comma
id|result_exponent
comma
id|unfl
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|opnd3
comma
id|dstptr
)paren
suffix:semicolon
multiline_comment|/* inexact = FALSE */
r_return
id|OPC_2E_UNDERFLOWEXCEPTION
suffix:semicolon
)brace
id|Sgl_copytoptr
c_func
(paren
id|opnd3
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/* is denormalized, adjust exponent */
id|Sgl_clear_signexponent
c_func
(paren
id|opnd1
)paren
suffix:semicolon
id|Sgl_leftshiftby1
c_func
(paren
id|opnd1
)paren
suffix:semicolon
id|Sgl_normalize
c_func
(paren
id|opnd1
comma
id|mpy_exponent
)paren
suffix:semicolon
)brace
multiline_comment|/* opnd2 needs to have hidden bit set with msb in hidden bit */
r_if
c_cond
(paren
id|Sgl_isnotzero_exponent
c_func
(paren
id|opnd2
)paren
)paren
(brace
id|Sgl_clear_signexponent_set_hidden
c_func
(paren
id|opnd2
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* check for zero */
r_if
c_cond
(paren
id|Sgl_iszero_mantissa
c_func
(paren
id|opnd2
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Perform the add opnd3 with zero here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Sgl_iszero_exponentmantissa
c_func
(paren
id|opnd3
)paren
)paren
(brace
r_if
c_cond
(paren
id|Is_rounding_mode
c_func
(paren
id|ROUNDMINUS
)paren
)paren
(brace
id|Sgl_or_signs
c_func
(paren
id|opnd3
comma
id|resultp1
)paren
suffix:semicolon
)brace
r_else
(brace
id|Sgl_and_signs
c_func
(paren
id|opnd3
comma
id|resultp1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * Now let&squot;s check for trapped underflow case.&n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|Sgl_iszero_exponent
c_func
(paren
id|opnd3
)paren
op_logical_and
id|Is_underflowtrap_enabled
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* need to normalize results mantissa */
id|sign_save
op_assign
id|Sgl_signextendedsign
c_func
(paren
id|opnd3
)paren
suffix:semicolon
id|result_exponent
op_assign
l_int|0
suffix:semicolon
id|Sgl_leftshiftby1
c_func
(paren
id|opnd3
)paren
suffix:semicolon
id|Sgl_normalize
c_func
(paren
id|opnd3
comma
id|result_exponent
)paren
suffix:semicolon
id|Sgl_set_sign
c_func
(paren
id|opnd3
comma
multiline_comment|/*using*/
id|sign_save
)paren
suffix:semicolon
id|Sgl_setwrapped_exponent
c_func
(paren
id|opnd3
comma
id|result_exponent
comma
id|unfl
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|opnd3
comma
id|dstptr
)paren
suffix:semicolon
multiline_comment|/* inexact = FALSE */
r_return
id|OPC_2E_UNDERFLOWEXCEPTION
suffix:semicolon
)brace
id|Sgl_copytoptr
c_func
(paren
id|opnd3
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/* is denormalized; want to normalize */
id|Sgl_clear_signexponent
c_func
(paren
id|opnd2
)paren
suffix:semicolon
id|Sgl_leftshiftby1
c_func
(paren
id|opnd2
)paren
suffix:semicolon
id|Sgl_normalize
c_func
(paren
id|opnd2
comma
id|mpy_exponent
)paren
suffix:semicolon
)brace
multiline_comment|/* Multiply the first two source mantissas together */
multiline_comment|/* &n;&t; * The intermediate result will be kept in tmpres,&n;&t; * which needs enough room for 106 bits of mantissa,&n;&t; * so lets call it a Double extended.&n;&t; */
id|Sglext_setzero
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Four bits at a time are inspected in each loop, and a &n;&t; * simple shift and add multiply algorithm is used. &n;&t; */
r_for
c_loop
(paren
id|count
op_assign
id|SGL_P
op_minus
l_int|1
suffix:semicolon
id|count
op_ge
l_int|0
suffix:semicolon
id|count
op_sub_assign
l_int|4
)paren
(brace
id|Sglext_rightshiftby4
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Sbit28
c_func
(paren
id|opnd1
)paren
)paren
(brace
multiline_comment|/* Twoword_add should be an ADD followed by 2 ADDC&squot;s */
id|Twoword_add
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|opnd2
op_lshift
l_int|3
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Sbit29
c_func
(paren
id|opnd1
)paren
)paren
(brace
id|Twoword_add
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|opnd2
op_lshift
l_int|2
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Sbit30
c_func
(paren
id|opnd1
)paren
)paren
(brace
id|Twoword_add
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|opnd2
op_lshift
l_int|1
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Sbit31
c_func
(paren
id|opnd1
)paren
)paren
(brace
id|Twoword_add
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|opnd2
comma
l_int|0
)paren
suffix:semicolon
)brace
id|Sgl_rightshiftby4
c_func
(paren
id|opnd1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Is_sexthiddenoverflow
c_func
(paren
id|tmpresp1
)paren
)paren
(brace
multiline_comment|/* result mantissa &gt;= 2 (mantissa overflow) */
id|mpy_exponent
op_increment
suffix:semicolon
id|Sglext_rightshiftby4
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
)paren
suffix:semicolon
)brace
r_else
(brace
id|Sglext_rightshiftby3
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Restore the sign of the mpy result which was saved in resultp1.&n;&t; * The exponent will continue to be kept in mpy_exponent.&n;&t; */
id|Sglext_set_sign
c_func
(paren
id|tmpresp1
comma
id|Sgl_sign
c_func
(paren
id|resultp1
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * No rounding is required, since the result of the multiply&n;&t; * is exact in the extended format.&n;&t; */
multiline_comment|/*&n;&t; * Now we are ready to perform the add portion of the operation.&n;&t; *&n;&t; * The exponents need to be kept as integers for now, since the&n;&t; * multiply result might not fit into the exponent field.  We&n;&t; * can&squot;t overflow or underflow because of this yet, since the&n;&t; * add could bring the final result back into range.&n;&t; */
id|add_exponent
op_assign
id|Sgl_exponent
c_func
(paren
id|opnd3
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check for denormalized or zero add operand.&n;&t; */
r_if
c_cond
(paren
id|add_exponent
op_eq
l_int|0
)paren
(brace
multiline_comment|/* check for zero */
r_if
c_cond
(paren
id|Sgl_iszero_mantissa
c_func
(paren
id|opnd3
)paren
)paren
(brace
multiline_comment|/* right is zero */
multiline_comment|/* Left can&squot;t be zero and must be result.&n;&t;&t;&t; *&n;&t;&t;&t; * The final result is now in tmpres and mpy_exponent,&n;&t;&t;&t; * and needs to be rounded and squeezed back into&n;&t;&t;&t; * double precision format from double extended.&n;&t;&t;&t; */
id|result_exponent
op_assign
id|mpy_exponent
suffix:semicolon
id|Sglext_copy
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|sign_save
op_assign
id|Sgl_signextendedsign
c_func
(paren
id|resultp1
)paren
suffix:semicolon
multiline_comment|/*save sign*/
r_goto
id|round
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * Neither are zeroes.  &n;&t;&t; * Adjust exponent and normalize add operand.&n;&t;&t; */
id|sign_save
op_assign
id|Sgl_signextendedsign
c_func
(paren
id|opnd3
)paren
suffix:semicolon
multiline_comment|/* save sign */
id|Sgl_clear_signexponent
c_func
(paren
id|opnd3
)paren
suffix:semicolon
id|Sgl_leftshiftby1
c_func
(paren
id|opnd3
)paren
suffix:semicolon
id|Sgl_normalize
c_func
(paren
id|opnd3
comma
id|add_exponent
)paren
suffix:semicolon
id|Sgl_set_sign
c_func
(paren
id|opnd3
comma
id|sign_save
)paren
suffix:semicolon
multiline_comment|/* restore sign */
)brace
r_else
(brace
id|Sgl_clear_exponent_set_hidden
c_func
(paren
id|opnd3
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Copy opnd3 to the double extended variable called right.&n;&t; */
id|Sgl_copyto_sglext
c_func
(paren
id|opnd3
comma
id|rightp1
comma
id|rightp2
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * A zero &quot;save&quot; helps discover equal operands (for later),&n;&t; * and is used in swapping operands (if needed).&n;&t; */
id|Sglext_xortointp1
c_func
(paren
id|tmpresp1
comma
id|rightp1
comma
multiline_comment|/*to*/
id|save
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Compare magnitude of operands.&n;&t; */
id|Sglext_copytoint_exponentmantissa
c_func
(paren
id|tmpresp1
comma
id|signlessleft1
)paren
suffix:semicolon
id|Sglext_copytoint_exponentmantissa
c_func
(paren
id|rightp1
comma
id|signlessright1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mpy_exponent
OL
id|add_exponent
op_logical_or
id|mpy_exponent
op_eq
id|add_exponent
op_logical_and
id|Sglext_ismagnitudeless
c_func
(paren
id|signlessleft1
comma
id|signlessright1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Set the left operand to the larger one by XOR swap.&n;&t;&t; * First finish the first word &quot;save&quot;.&n;&t;&t; */
id|Sglext_xorfromintp1
c_func
(paren
id|save
comma
id|rightp1
comma
multiline_comment|/*to*/
id|rightp1
)paren
suffix:semicolon
id|Sglext_xorfromintp1
c_func
(paren
id|save
comma
id|tmpresp1
comma
multiline_comment|/*to*/
id|tmpresp1
)paren
suffix:semicolon
id|Sglext_swap_lower
c_func
(paren
id|tmpresp2
comma
id|rightp2
)paren
suffix:semicolon
multiline_comment|/* also setup exponents used in rest of routine */
id|diff_exponent
op_assign
id|add_exponent
op_minus
id|mpy_exponent
suffix:semicolon
id|result_exponent
op_assign
id|add_exponent
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* also setup exponents used in rest of routine */
id|diff_exponent
op_assign
id|mpy_exponent
op_minus
id|add_exponent
suffix:semicolon
id|result_exponent
op_assign
id|mpy_exponent
suffix:semicolon
)brace
multiline_comment|/* Invariant: left is not smaller than right. */
multiline_comment|/*&n;&t; * Special case alignment of operands that would force alignment&n;&t; * beyond the extent of the extension.  A further optimization&n;&t; * could special case this but only reduces the path length for&n;&t; * this infrequent case.&n;&t; */
r_if
c_cond
(paren
id|diff_exponent
OG
id|SGLEXT_THRESHOLD
)paren
(brace
id|diff_exponent
op_assign
id|SGLEXT_THRESHOLD
suffix:semicolon
)brace
multiline_comment|/* Align right operand by shifting it to the right */
id|Sglext_clear_sign
c_func
(paren
id|rightp1
)paren
suffix:semicolon
id|Sglext_right_align
c_func
(paren
id|rightp1
comma
id|rightp2
comma
multiline_comment|/*shifted by*/
id|diff_exponent
)paren
suffix:semicolon
multiline_comment|/* Treat sum and difference of the operands separately. */
r_if
c_cond
(paren
(paren
r_int
)paren
id|save
OL
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Difference of the two operands.  Overflow can occur if the&n;&t;&t; * multiply overflowed.  A borrow can occur out of the hidden&n;&t;&t; * bit and force a post normalization phase.&n;&t;&t; */
id|Sglext_subtract
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|rightp1
comma
id|rightp2
comma
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|sign_save
op_assign
id|Sgl_signextendedsign
c_func
(paren
id|resultp1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Sgl_iszero_hidden
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* Handle normalization */
multiline_comment|/* A straight foward algorithm would now shift the&n;&t;&t; * result and extension left until the hidden bit&n;&t;&t; * becomes one.  Not all of the extension bits need&n;&t;&t; * participate in the shift.  Only the two most &n;&t;&t; * significant bits (round and guard) are needed.&n;&t;&t; * If only a single shift is needed then the guard&n;&t;&t; * bit becomes a significant low order bit and the&n;&t;&t; * extension must participate in the rounding.&n;&t;&t; * If more than a single shift is needed, then all&n;&t;&t; * bits to the right of the guard bit are zeros, &n;&t;&t; * and the guard bit may or may not be zero. */
id|Sglext_leftshiftby1
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
multiline_comment|/* Need to check for a zero result.  The sign and&n;&t;&t;&t; * exponent fields have already been zeroed.  The more&n;&t;&t;&t; * efficient test of the full object can be used.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Sglext_iszero
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
)paren
(brace
multiline_comment|/* Must have been &quot;x-x&quot; or &quot;x+(-x)&quot;. */
r_if
c_cond
(paren
id|Is_rounding_mode
c_func
(paren
id|ROUNDMINUS
)paren
)paren
id|Sgl_setone_sign
c_func
(paren
id|resultp1
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|resultp1
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
id|result_exponent
op_decrement
suffix:semicolon
multiline_comment|/* Look to see if normalization is finished. */
r_if
c_cond
(paren
id|Sgl_isone_hidden
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* No further normalization is needed */
r_goto
id|round
suffix:semicolon
)brace
multiline_comment|/* Discover first one bit to determine shift amount.&n;&t;&t;&t; * Use a modified binary search.  We have already&n;&t;&t;&t; * shifted the result one position right and still&n;&t;&t;&t; * not found a one so the remainder of the extension&n;&t;&t;&t; * must be zero and simplifies rounding. */
multiline_comment|/* Scan bytes */
r_while
c_loop
(paren
id|Sgl_iszero_hiddenhigh7mantissa
c_func
(paren
id|resultp1
)paren
)paren
(brace
id|Sglext_leftshiftby8
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|result_exponent
op_sub_assign
l_int|8
suffix:semicolon
)brace
multiline_comment|/* Now narrow it down to the nibble */
r_if
c_cond
(paren
id|Sgl_iszero_hiddenhigh3mantissa
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* The lower nibble contains the&n;&t;&t;&t;&t; * normalizing one */
id|Sglext_leftshiftby4
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|result_exponent
op_sub_assign
l_int|4
suffix:semicolon
)brace
multiline_comment|/* Select case where first bit is set (already&n;&t;&t;&t; * normalized) otherwise select the proper shift. */
id|jumpsize
op_assign
id|Sgl_hiddenhigh3mantissa
c_func
(paren
id|resultp1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jumpsize
op_le
l_int|7
)paren
r_switch
c_cond
(paren
id|jumpsize
)paren
(brace
r_case
l_int|1
suffix:colon
id|Sglext_leftshiftby3
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|result_exponent
op_sub_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_case
l_int|3
suffix:colon
id|Sglext_leftshiftby2
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|result_exponent
op_sub_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
r_case
l_int|5
suffix:colon
r_case
l_int|6
suffix:colon
r_case
l_int|7
suffix:colon
id|Sglext_leftshiftby1
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|result_exponent
op_sub_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* end if (hidden...)... */
multiline_comment|/* Fall through and round */
)brace
multiline_comment|/* end if (save &lt; 0)... */
r_else
(brace
multiline_comment|/* Add magnitudes */
id|Sglext_addition
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|rightp1
comma
id|rightp2
comma
multiline_comment|/*to*/
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|sign_save
op_assign
id|Sgl_signextendedsign
c_func
(paren
id|resultp1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Sgl_isone_hiddenoverflow
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* Prenormalization required. */
id|Sglext_arithrightshiftby1
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|result_exponent
op_increment
suffix:semicolon
)brace
multiline_comment|/* end if hiddenoverflow... */
)brace
multiline_comment|/* end else ...add magnitudes... */
multiline_comment|/* Round the result.  If the extension and lower two words are&n;&t; * all zeros, then the result is exact.  Otherwise round in the&n;&t; * correct direction.  Underflow is possible. If a postnormalization&n;&t; * is necessary, then the mantissa is all zeros so no shift is needed.&n;&t; */
id|round
suffix:colon
r_if
c_cond
(paren
id|result_exponent
op_le
l_int|0
op_logical_and
op_logical_neg
id|Is_underflowtrap_enabled
c_func
(paren
)paren
)paren
(brace
id|Sglext_denormalize
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|result_exponent
comma
id|is_tiny
)paren
suffix:semicolon
)brace
id|Sgl_set_sign
c_func
(paren
id|resultp1
comma
multiline_comment|/*using*/
id|sign_save
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Sglext_isnotzero_mantissap2
c_func
(paren
id|resultp2
)paren
)paren
(brace
id|inexact
op_assign
id|TRUE
suffix:semicolon
r_switch
c_cond
(paren
id|Rounding_mode
c_func
(paren
)paren
)paren
(brace
r_case
id|ROUNDNEAREST
suffix:colon
multiline_comment|/* The default. */
r_if
c_cond
(paren
id|Sglext_isone_highp2
c_func
(paren
id|resultp2
)paren
)paren
(brace
multiline_comment|/* at least 1/2 ulp */
r_if
c_cond
(paren
id|Sglext_isnotzero_low31p2
c_func
(paren
id|resultp2
)paren
op_logical_or
id|Sglext_isone_lowp1
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* either exactly half way and odd or&n;&t;&t;&t;&t;&t; * more than 1/2ulp */
id|Sgl_increment
c_func
(paren
id|resultp1
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|ROUNDPLUS
suffix:colon
r_if
c_cond
(paren
id|Sgl_iszero_sign
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* Round up positive results */
id|Sgl_increment
c_func
(paren
id|resultp1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ROUNDMINUS
suffix:colon
r_if
c_cond
(paren
id|Sgl_isone_sign
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* Round down negative results */
id|Sgl_increment
c_func
(paren
id|resultp1
)paren
suffix:semicolon
)brace
r_case
id|ROUNDZERO
suffix:colon
suffix:semicolon
multiline_comment|/* truncate is simple */
)brace
multiline_comment|/* end switch... */
r_if
c_cond
(paren
id|Sgl_isone_hiddenoverflow
c_func
(paren
id|resultp1
)paren
)paren
id|result_exponent
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result_exponent
op_ge
id|SGL_INFINITY_EXPONENT
)paren
(brace
multiline_comment|/* Overflow */
r_if
c_cond
(paren
id|Is_overflowtrap_enabled
c_func
(paren
)paren
)paren
(brace
multiline_comment|/*&n;                         * Adjust bias of result&n;                         */
id|Sgl_setwrapped_exponent
c_func
(paren
id|resultp1
comma
id|result_exponent
comma
id|ovfl
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|resultp1
comma
id|dstptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inexact
)paren
r_if
c_cond
(paren
id|Is_inexacttrap_enabled
c_func
(paren
)paren
)paren
r_return
(paren
id|OPC_2E_OVERFLOWEXCEPTION
op_or
id|OPC_2E_INEXACTEXCEPTION
)paren
suffix:semicolon
r_else
id|Set_inexactflag
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
id|OPC_2E_OVERFLOWEXCEPTION
)paren
suffix:semicolon
)brace
id|inexact
op_assign
id|TRUE
suffix:semicolon
id|Set_overflowflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_setoverflow
c_func
(paren
id|resultp1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|result_exponent
op_le
l_int|0
)paren
(brace
multiline_comment|/* underflow case */
r_if
c_cond
(paren
id|Is_underflowtrap_enabled
c_func
(paren
)paren
)paren
(brace
multiline_comment|/*&n;                         * Adjust bias of result&n;                         */
id|Sgl_setwrapped_exponent
c_func
(paren
id|resultp1
comma
id|result_exponent
comma
id|unfl
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|resultp1
comma
id|dstptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inexact
)paren
r_if
c_cond
(paren
id|Is_inexacttrap_enabled
c_func
(paren
)paren
)paren
r_return
(paren
id|OPC_2E_UNDERFLOWEXCEPTION
op_or
id|OPC_2E_INEXACTEXCEPTION
)paren
suffix:semicolon
r_else
id|Set_inexactflag
c_func
(paren
)paren
suffix:semicolon
r_return
id|OPC_2E_UNDERFLOWEXCEPTION
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|inexact
op_logical_and
id|is_tiny
)paren
id|Set_underflowflag
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|Sgl_set_exponent
c_func
(paren
id|resultp1
comma
id|result_exponent
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|resultp1
comma
id|dstptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inexact
)paren
r_if
c_cond
(paren
id|Is_inexacttrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INEXACTEXCEPTION
suffix:semicolon
r_else
id|Set_inexactflag
c_func
(paren
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n; *  Single Floating-point Multiply Negate Fused Add&n; */
DECL|function|sgl_fmpynfadd
id|sgl_fmpynfadd
c_func
(paren
id|src1ptr
comma
id|src2ptr
comma
id|src3ptr
comma
id|status
comma
id|dstptr
)paren
id|sgl_floating_point
op_star
id|src1ptr
comma
op_star
id|src2ptr
comma
op_star
id|src3ptr
comma
op_star
id|dstptr
suffix:semicolon
r_int
r_int
op_star
id|status
suffix:semicolon
(brace
r_int
r_int
id|opnd1
comma
id|opnd2
comma
id|opnd3
suffix:semicolon
r_register
r_int
r_int
id|tmpresp1
comma
id|tmpresp2
suffix:semicolon
r_int
r_int
id|rightp1
comma
id|rightp2
suffix:semicolon
r_int
r_int
id|resultp1
comma
id|resultp2
op_assign
l_int|0
suffix:semicolon
r_register
r_int
id|mpy_exponent
comma
id|add_exponent
comma
id|count
suffix:semicolon
id|boolean
id|inexact
op_assign
id|FALSE
comma
id|is_tiny
op_assign
id|FALSE
suffix:semicolon
r_int
r_int
id|signlessleft1
comma
id|signlessright1
comma
id|save
suffix:semicolon
r_register
r_int
id|result_exponent
comma
id|diff_exponent
suffix:semicolon
r_int
id|sign_save
comma
id|jumpsize
suffix:semicolon
id|Sgl_copyfromptr
c_func
(paren
id|src1ptr
comma
id|opnd1
)paren
suffix:semicolon
id|Sgl_copyfromptr
c_func
(paren
id|src2ptr
comma
id|opnd2
)paren
suffix:semicolon
id|Sgl_copyfromptr
c_func
(paren
id|src3ptr
comma
id|opnd3
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * set sign bit of result of multiply&n;&t; */
r_if
c_cond
(paren
id|Sgl_sign
c_func
(paren
id|opnd1
)paren
op_xor
id|Sgl_sign
c_func
(paren
id|opnd2
)paren
)paren
id|Sgl_setzero
c_func
(paren
id|resultp1
)paren
suffix:semicolon
r_else
id|Sgl_setnegativezero
c_func
(paren
id|resultp1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Generate multiply exponent &n;&t; */
id|mpy_exponent
op_assign
id|Sgl_exponent
c_func
(paren
id|opnd1
)paren
op_plus
id|Sgl_exponent
c_func
(paren
id|opnd2
)paren
op_minus
id|SGL_BIAS
suffix:semicolon
multiline_comment|/*&n;&t; * check first operand for NaN&squot;s or infinity&n;&t; */
r_if
c_cond
(paren
id|Sgl_isinfinity_exponent
c_func
(paren
id|opnd1
)paren
)paren
(brace
r_if
c_cond
(paren
id|Sgl_iszero_mantissa
c_func
(paren
id|opnd1
)paren
)paren
(brace
r_if
c_cond
(paren
id|Sgl_isnotnan
c_func
(paren
id|opnd2
)paren
op_logical_and
id|Sgl_isnotnan
c_func
(paren
id|opnd3
)paren
)paren
(brace
r_if
c_cond
(paren
id|Sgl_iszero_exponentmantissa
c_func
(paren
id|opnd2
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t;&t; * invalid since operands are infinity &n;&t;&t;&t;&t;&t; * and zero &n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_makequietnan
c_func
(paren
id|resultp1
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|resultp1
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Check third operand for infinity with a&n;&t;&t;&t;&t; *  sign opposite of the multiply result&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Sgl_isinfinity
c_func
(paren
id|opnd3
)paren
op_logical_and
(paren
id|Sgl_sign
c_func
(paren
id|resultp1
)paren
op_xor
id|Sgl_sign
c_func
(paren
id|opnd3
)paren
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t;&t; * invalid since attempting a magnitude&n;&t;&t;&t;&t;&t; * subtraction of infinities&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_makequietnan
c_func
(paren
id|resultp1
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|resultp1
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; &t; * return infinity&n;&t;&t;&t; &t; */
id|Sgl_setinfinity_exponentmantissa
c_func
(paren
id|resultp1
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|resultp1
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; &t; * is NaN; signaling or quiet?&n;&t;&t; &t; */
r_if
c_cond
(paren
id|Sgl_isone_signaling
c_func
(paren
id|opnd1
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_set_quiet
c_func
(paren
id|opnd1
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t;&t; * is second operand a signaling NaN? &n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|Sgl_is_signalingnan
c_func
(paren
id|opnd2
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_set_quiet
c_func
(paren
id|opnd2
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|opnd2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t;&t; * is third operand a signaling NaN? &n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|Sgl_is_signalingnan
c_func
(paren
id|opnd3
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_set_quiet
c_func
(paren
id|opnd3
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|opnd3
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; &t; * return quiet NaN&n;&t;&t; &t; */
id|Sgl_copytoptr
c_func
(paren
id|opnd1
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * check second operand for NaN&squot;s or infinity&n;&t; */
r_if
c_cond
(paren
id|Sgl_isinfinity_exponent
c_func
(paren
id|opnd2
)paren
)paren
(brace
r_if
c_cond
(paren
id|Sgl_iszero_mantissa
c_func
(paren
id|opnd2
)paren
)paren
(brace
r_if
c_cond
(paren
id|Sgl_isnotnan
c_func
(paren
id|opnd3
)paren
)paren
(brace
r_if
c_cond
(paren
id|Sgl_iszero_exponentmantissa
c_func
(paren
id|opnd1
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t;&t; * invalid since multiply operands are&n;&t;&t;&t;&t;&t; * zero &amp; infinity&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_makequietnan
c_func
(paren
id|opnd2
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|opnd2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Check third operand for infinity with a&n;&t;&t;&t;&t; *  sign opposite of the multiply result&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Sgl_isinfinity
c_func
(paren
id|opnd3
)paren
op_logical_and
(paren
id|Sgl_sign
c_func
(paren
id|resultp1
)paren
op_xor
id|Sgl_sign
c_func
(paren
id|opnd3
)paren
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t;&t; * invalid since attempting a magnitude&n;&t;&t;&t;&t;&t; * subtraction of infinities&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_makequietnan
c_func
(paren
id|resultp1
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|resultp1
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * return infinity&n;&t;&t;&t;&t; */
id|Sgl_setinfinity_exponentmantissa
c_func
(paren
id|resultp1
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|resultp1
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * is NaN; signaling or quiet?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Sgl_isone_signaling
c_func
(paren
id|opnd2
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_set_quiet
c_func
(paren
id|opnd2
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t;&t; * is third operand a signaling NaN? &n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|Sgl_is_signalingnan
c_func
(paren
id|opnd3
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_set_quiet
c_func
(paren
id|opnd3
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|opnd3
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * return quiet NaN&n;&t;&t;&t; */
id|Sgl_copytoptr
c_func
(paren
id|opnd2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * check third operand for NaN&squot;s or infinity&n;&t; */
r_if
c_cond
(paren
id|Sgl_isinfinity_exponent
c_func
(paren
id|opnd3
)paren
)paren
(brace
r_if
c_cond
(paren
id|Sgl_iszero_mantissa
c_func
(paren
id|opnd3
)paren
)paren
(brace
multiline_comment|/* return infinity */
id|Sgl_copytoptr
c_func
(paren
id|opnd3
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * is NaN; signaling or quiet?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Sgl_isone_signaling
c_func
(paren
id|opnd3
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_set_quiet
c_func
(paren
id|opnd3
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * return quiet NaN&n; &t;&t;&t; */
id|Sgl_copytoptr
c_func
(paren
id|opnd3
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Generate multiply mantissa&n;&t; */
r_if
c_cond
(paren
id|Sgl_isnotzero_exponent
c_func
(paren
id|opnd1
)paren
)paren
(brace
multiline_comment|/* set hidden bit */
id|Sgl_clear_signexponent_set_hidden
c_func
(paren
id|opnd1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* check for zero */
r_if
c_cond
(paren
id|Sgl_iszero_mantissa
c_func
(paren
id|opnd1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Perform the add opnd3 with zero here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Sgl_iszero_exponentmantissa
c_func
(paren
id|opnd3
)paren
)paren
(brace
r_if
c_cond
(paren
id|Is_rounding_mode
c_func
(paren
id|ROUNDMINUS
)paren
)paren
(brace
id|Sgl_or_signs
c_func
(paren
id|opnd3
comma
id|resultp1
)paren
suffix:semicolon
)brace
r_else
(brace
id|Sgl_and_signs
c_func
(paren
id|opnd3
comma
id|resultp1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * Now let&squot;s check for trapped underflow case.&n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|Sgl_iszero_exponent
c_func
(paren
id|opnd3
)paren
op_logical_and
id|Is_underflowtrap_enabled
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* need to normalize results mantissa */
id|sign_save
op_assign
id|Sgl_signextendedsign
c_func
(paren
id|opnd3
)paren
suffix:semicolon
id|result_exponent
op_assign
l_int|0
suffix:semicolon
id|Sgl_leftshiftby1
c_func
(paren
id|opnd3
)paren
suffix:semicolon
id|Sgl_normalize
c_func
(paren
id|opnd3
comma
id|result_exponent
)paren
suffix:semicolon
id|Sgl_set_sign
c_func
(paren
id|opnd3
comma
multiline_comment|/*using*/
id|sign_save
)paren
suffix:semicolon
id|Sgl_setwrapped_exponent
c_func
(paren
id|opnd3
comma
id|result_exponent
comma
id|unfl
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|opnd3
comma
id|dstptr
)paren
suffix:semicolon
multiline_comment|/* inexact = FALSE */
r_return
id|OPC_2E_UNDERFLOWEXCEPTION
suffix:semicolon
)brace
id|Sgl_copytoptr
c_func
(paren
id|opnd3
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/* is denormalized, adjust exponent */
id|Sgl_clear_signexponent
c_func
(paren
id|opnd1
)paren
suffix:semicolon
id|Sgl_leftshiftby1
c_func
(paren
id|opnd1
)paren
suffix:semicolon
id|Sgl_normalize
c_func
(paren
id|opnd1
comma
id|mpy_exponent
)paren
suffix:semicolon
)brace
multiline_comment|/* opnd2 needs to have hidden bit set with msb in hidden bit */
r_if
c_cond
(paren
id|Sgl_isnotzero_exponent
c_func
(paren
id|opnd2
)paren
)paren
(brace
id|Sgl_clear_signexponent_set_hidden
c_func
(paren
id|opnd2
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* check for zero */
r_if
c_cond
(paren
id|Sgl_iszero_mantissa
c_func
(paren
id|opnd2
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Perform the add opnd3 with zero here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Sgl_iszero_exponentmantissa
c_func
(paren
id|opnd3
)paren
)paren
(brace
r_if
c_cond
(paren
id|Is_rounding_mode
c_func
(paren
id|ROUNDMINUS
)paren
)paren
(brace
id|Sgl_or_signs
c_func
(paren
id|opnd3
comma
id|resultp1
)paren
suffix:semicolon
)brace
r_else
(brace
id|Sgl_and_signs
c_func
(paren
id|opnd3
comma
id|resultp1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * Now let&squot;s check for trapped underflow case.&n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|Sgl_iszero_exponent
c_func
(paren
id|opnd3
)paren
op_logical_and
id|Is_underflowtrap_enabled
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* need to normalize results mantissa */
id|sign_save
op_assign
id|Sgl_signextendedsign
c_func
(paren
id|opnd3
)paren
suffix:semicolon
id|result_exponent
op_assign
l_int|0
suffix:semicolon
id|Sgl_leftshiftby1
c_func
(paren
id|opnd3
)paren
suffix:semicolon
id|Sgl_normalize
c_func
(paren
id|opnd3
comma
id|result_exponent
)paren
suffix:semicolon
id|Sgl_set_sign
c_func
(paren
id|opnd3
comma
multiline_comment|/*using*/
id|sign_save
)paren
suffix:semicolon
id|Sgl_setwrapped_exponent
c_func
(paren
id|opnd3
comma
id|result_exponent
comma
id|unfl
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|opnd3
comma
id|dstptr
)paren
suffix:semicolon
multiline_comment|/* inexact = FALSE */
r_return
id|OPC_2E_UNDERFLOWEXCEPTION
suffix:semicolon
)brace
id|Sgl_copytoptr
c_func
(paren
id|opnd3
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/* is denormalized; want to normalize */
id|Sgl_clear_signexponent
c_func
(paren
id|opnd2
)paren
suffix:semicolon
id|Sgl_leftshiftby1
c_func
(paren
id|opnd2
)paren
suffix:semicolon
id|Sgl_normalize
c_func
(paren
id|opnd2
comma
id|mpy_exponent
)paren
suffix:semicolon
)brace
multiline_comment|/* Multiply the first two source mantissas together */
multiline_comment|/* &n;&t; * The intermediate result will be kept in tmpres,&n;&t; * which needs enough room for 106 bits of mantissa,&n;&t; * so lets call it a Double extended.&n;&t; */
id|Sglext_setzero
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Four bits at a time are inspected in each loop, and a &n;&t; * simple shift and add multiply algorithm is used. &n;&t; */
r_for
c_loop
(paren
id|count
op_assign
id|SGL_P
op_minus
l_int|1
suffix:semicolon
id|count
op_ge
l_int|0
suffix:semicolon
id|count
op_sub_assign
l_int|4
)paren
(brace
id|Sglext_rightshiftby4
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Sbit28
c_func
(paren
id|opnd1
)paren
)paren
(brace
multiline_comment|/* Twoword_add should be an ADD followed by 2 ADDC&squot;s */
id|Twoword_add
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|opnd2
op_lshift
l_int|3
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Sbit29
c_func
(paren
id|opnd1
)paren
)paren
(brace
id|Twoword_add
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|opnd2
op_lshift
l_int|2
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Sbit30
c_func
(paren
id|opnd1
)paren
)paren
(brace
id|Twoword_add
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|opnd2
op_lshift
l_int|1
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Sbit31
c_func
(paren
id|opnd1
)paren
)paren
(brace
id|Twoword_add
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|opnd2
comma
l_int|0
)paren
suffix:semicolon
)brace
id|Sgl_rightshiftby4
c_func
(paren
id|opnd1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Is_sexthiddenoverflow
c_func
(paren
id|tmpresp1
)paren
)paren
(brace
multiline_comment|/* result mantissa &gt;= 2 (mantissa overflow) */
id|mpy_exponent
op_increment
suffix:semicolon
id|Sglext_rightshiftby4
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
)paren
suffix:semicolon
)brace
r_else
(brace
id|Sglext_rightshiftby3
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Restore the sign of the mpy result which was saved in resultp1.&n;&t; * The exponent will continue to be kept in mpy_exponent.&n;&t; */
id|Sglext_set_sign
c_func
(paren
id|tmpresp1
comma
id|Sgl_sign
c_func
(paren
id|resultp1
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * No rounding is required, since the result of the multiply&n;&t; * is exact in the extended format.&n;&t; */
multiline_comment|/*&n;&t; * Now we are ready to perform the add portion of the operation.&n;&t; *&n;&t; * The exponents need to be kept as integers for now, since the&n;&t; * multiply result might not fit into the exponent field.  We&n;&t; * can&squot;t overflow or underflow because of this yet, since the&n;&t; * add could bring the final result back into range.&n;&t; */
id|add_exponent
op_assign
id|Sgl_exponent
c_func
(paren
id|opnd3
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check for denormalized or zero add operand.&n;&t; */
r_if
c_cond
(paren
id|add_exponent
op_eq
l_int|0
)paren
(brace
multiline_comment|/* check for zero */
r_if
c_cond
(paren
id|Sgl_iszero_mantissa
c_func
(paren
id|opnd3
)paren
)paren
(brace
multiline_comment|/* right is zero */
multiline_comment|/* Left can&squot;t be zero and must be result.&n;&t;&t;&t; *&n;&t;&t;&t; * The final result is now in tmpres and mpy_exponent,&n;&t;&t;&t; * and needs to be rounded and squeezed back into&n;&t;&t;&t; * double precision format from double extended.&n;&t;&t;&t; */
id|result_exponent
op_assign
id|mpy_exponent
suffix:semicolon
id|Sglext_copy
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|sign_save
op_assign
id|Sgl_signextendedsign
c_func
(paren
id|resultp1
)paren
suffix:semicolon
multiline_comment|/*save sign*/
r_goto
id|round
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * Neither are zeroes.  &n;&t;&t; * Adjust exponent and normalize add operand.&n;&t;&t; */
id|sign_save
op_assign
id|Sgl_signextendedsign
c_func
(paren
id|opnd3
)paren
suffix:semicolon
multiline_comment|/* save sign */
id|Sgl_clear_signexponent
c_func
(paren
id|opnd3
)paren
suffix:semicolon
id|Sgl_leftshiftby1
c_func
(paren
id|opnd3
)paren
suffix:semicolon
id|Sgl_normalize
c_func
(paren
id|opnd3
comma
id|add_exponent
)paren
suffix:semicolon
id|Sgl_set_sign
c_func
(paren
id|opnd3
comma
id|sign_save
)paren
suffix:semicolon
multiline_comment|/* restore sign */
)brace
r_else
(brace
id|Sgl_clear_exponent_set_hidden
c_func
(paren
id|opnd3
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Copy opnd3 to the double extended variable called right.&n;&t; */
id|Sgl_copyto_sglext
c_func
(paren
id|opnd3
comma
id|rightp1
comma
id|rightp2
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * A zero &quot;save&quot; helps discover equal operands (for later),&n;&t; * and is used in swapping operands (if needed).&n;&t; */
id|Sglext_xortointp1
c_func
(paren
id|tmpresp1
comma
id|rightp1
comma
multiline_comment|/*to*/
id|save
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Compare magnitude of operands.&n;&t; */
id|Sglext_copytoint_exponentmantissa
c_func
(paren
id|tmpresp1
comma
id|signlessleft1
)paren
suffix:semicolon
id|Sglext_copytoint_exponentmantissa
c_func
(paren
id|rightp1
comma
id|signlessright1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mpy_exponent
OL
id|add_exponent
op_logical_or
id|mpy_exponent
op_eq
id|add_exponent
op_logical_and
id|Sglext_ismagnitudeless
c_func
(paren
id|signlessleft1
comma
id|signlessright1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Set the left operand to the larger one by XOR swap.&n;&t;&t; * First finish the first word &quot;save&quot;.&n;&t;&t; */
id|Sglext_xorfromintp1
c_func
(paren
id|save
comma
id|rightp1
comma
multiline_comment|/*to*/
id|rightp1
)paren
suffix:semicolon
id|Sglext_xorfromintp1
c_func
(paren
id|save
comma
id|tmpresp1
comma
multiline_comment|/*to*/
id|tmpresp1
)paren
suffix:semicolon
id|Sglext_swap_lower
c_func
(paren
id|tmpresp2
comma
id|rightp2
)paren
suffix:semicolon
multiline_comment|/* also setup exponents used in rest of routine */
id|diff_exponent
op_assign
id|add_exponent
op_minus
id|mpy_exponent
suffix:semicolon
id|result_exponent
op_assign
id|add_exponent
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* also setup exponents used in rest of routine */
id|diff_exponent
op_assign
id|mpy_exponent
op_minus
id|add_exponent
suffix:semicolon
id|result_exponent
op_assign
id|mpy_exponent
suffix:semicolon
)brace
multiline_comment|/* Invariant: left is not smaller than right. */
multiline_comment|/*&n;&t; * Special case alignment of operands that would force alignment&n;&t; * beyond the extent of the extension.  A further optimization&n;&t; * could special case this but only reduces the path length for&n;&t; * this infrequent case.&n;&t; */
r_if
c_cond
(paren
id|diff_exponent
OG
id|SGLEXT_THRESHOLD
)paren
(brace
id|diff_exponent
op_assign
id|SGLEXT_THRESHOLD
suffix:semicolon
)brace
multiline_comment|/* Align right operand by shifting it to the right */
id|Sglext_clear_sign
c_func
(paren
id|rightp1
)paren
suffix:semicolon
id|Sglext_right_align
c_func
(paren
id|rightp1
comma
id|rightp2
comma
multiline_comment|/*shifted by*/
id|diff_exponent
)paren
suffix:semicolon
multiline_comment|/* Treat sum and difference of the operands separately. */
r_if
c_cond
(paren
(paren
r_int
)paren
id|save
OL
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Difference of the two operands.  Overflow can occur if the&n;&t;&t; * multiply overflowed.  A borrow can occur out of the hidden&n;&t;&t; * bit and force a post normalization phase.&n;&t;&t; */
id|Sglext_subtract
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|rightp1
comma
id|rightp2
comma
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|sign_save
op_assign
id|Sgl_signextendedsign
c_func
(paren
id|resultp1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Sgl_iszero_hidden
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* Handle normalization */
multiline_comment|/* A straight foward algorithm would now shift the&n;&t;&t; * result and extension left until the hidden bit&n;&t;&t; * becomes one.  Not all of the extension bits need&n;&t;&t; * participate in the shift.  Only the two most &n;&t;&t; * significant bits (round and guard) are needed.&n;&t;&t; * If only a single shift is needed then the guard&n;&t;&t; * bit becomes a significant low order bit and the&n;&t;&t; * extension must participate in the rounding.&n;&t;&t; * If more than a single shift is needed, then all&n;&t;&t; * bits to the right of the guard bit are zeros, &n;&t;&t; * and the guard bit may or may not be zero. */
id|Sglext_leftshiftby1
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
multiline_comment|/* Need to check for a zero result.  The sign and&n;&t;&t;&t; * exponent fields have already been zeroed.  The more&n;&t;&t;&t; * efficient test of the full object can be used.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|Sglext_iszero
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
)paren
(brace
multiline_comment|/* Must have been &quot;x-x&quot; or &quot;x+(-x)&quot;. */
r_if
c_cond
(paren
id|Is_rounding_mode
c_func
(paren
id|ROUNDMINUS
)paren
)paren
id|Sgl_setone_sign
c_func
(paren
id|resultp1
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|resultp1
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
id|result_exponent
op_decrement
suffix:semicolon
multiline_comment|/* Look to see if normalization is finished. */
r_if
c_cond
(paren
id|Sgl_isone_hidden
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* No further normalization is needed */
r_goto
id|round
suffix:semicolon
)brace
multiline_comment|/* Discover first one bit to determine shift amount.&n;&t;&t;&t; * Use a modified binary search.  We have already&n;&t;&t;&t; * shifted the result one position right and still&n;&t;&t;&t; * not found a one so the remainder of the extension&n;&t;&t;&t; * must be zero and simplifies rounding. */
multiline_comment|/* Scan bytes */
r_while
c_loop
(paren
id|Sgl_iszero_hiddenhigh7mantissa
c_func
(paren
id|resultp1
)paren
)paren
(brace
id|Sglext_leftshiftby8
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|result_exponent
op_sub_assign
l_int|8
suffix:semicolon
)brace
multiline_comment|/* Now narrow it down to the nibble */
r_if
c_cond
(paren
id|Sgl_iszero_hiddenhigh3mantissa
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* The lower nibble contains the&n;&t;&t;&t;&t; * normalizing one */
id|Sglext_leftshiftby4
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|result_exponent
op_sub_assign
l_int|4
suffix:semicolon
)brace
multiline_comment|/* Select case where first bit is set (already&n;&t;&t;&t; * normalized) otherwise select the proper shift. */
id|jumpsize
op_assign
id|Sgl_hiddenhigh3mantissa
c_func
(paren
id|resultp1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jumpsize
op_le
l_int|7
)paren
r_switch
c_cond
(paren
id|jumpsize
)paren
(brace
r_case
l_int|1
suffix:colon
id|Sglext_leftshiftby3
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|result_exponent
op_sub_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_case
l_int|3
suffix:colon
id|Sglext_leftshiftby2
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|result_exponent
op_sub_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
r_case
l_int|5
suffix:colon
r_case
l_int|6
suffix:colon
r_case
l_int|7
suffix:colon
id|Sglext_leftshiftby1
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|result_exponent
op_sub_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* end if (hidden...)... */
multiline_comment|/* Fall through and round */
)brace
multiline_comment|/* end if (save &lt; 0)... */
r_else
(brace
multiline_comment|/* Add magnitudes */
id|Sglext_addition
c_func
(paren
id|tmpresp1
comma
id|tmpresp2
comma
id|rightp1
comma
id|rightp2
comma
multiline_comment|/*to*/
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|sign_save
op_assign
id|Sgl_signextendedsign
c_func
(paren
id|resultp1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Sgl_isone_hiddenoverflow
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* Prenormalization required. */
id|Sglext_arithrightshiftby1
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|result_exponent
op_increment
suffix:semicolon
)brace
multiline_comment|/* end if hiddenoverflow... */
)brace
multiline_comment|/* end else ...add magnitudes... */
multiline_comment|/* Round the result.  If the extension and lower two words are&n;&t; * all zeros, then the result is exact.  Otherwise round in the&n;&t; * correct direction.  Underflow is possible. If a postnormalization&n;&t; * is necessary, then the mantissa is all zeros so no shift is needed.&n;&t; */
id|round
suffix:colon
r_if
c_cond
(paren
id|result_exponent
op_le
l_int|0
op_logical_and
op_logical_neg
id|Is_underflowtrap_enabled
c_func
(paren
)paren
)paren
(brace
id|Sglext_denormalize
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|result_exponent
comma
id|is_tiny
)paren
suffix:semicolon
)brace
id|Sgl_set_sign
c_func
(paren
id|resultp1
comma
multiline_comment|/*using*/
id|sign_save
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Sglext_isnotzero_mantissap2
c_func
(paren
id|resultp2
)paren
)paren
(brace
id|inexact
op_assign
id|TRUE
suffix:semicolon
r_switch
c_cond
(paren
id|Rounding_mode
c_func
(paren
)paren
)paren
(brace
r_case
id|ROUNDNEAREST
suffix:colon
multiline_comment|/* The default. */
r_if
c_cond
(paren
id|Sglext_isone_highp2
c_func
(paren
id|resultp2
)paren
)paren
(brace
multiline_comment|/* at least 1/2 ulp */
r_if
c_cond
(paren
id|Sglext_isnotzero_low31p2
c_func
(paren
id|resultp2
)paren
op_logical_or
id|Sglext_isone_lowp1
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* either exactly half way and odd or&n;&t;&t;&t;&t;&t; * more than 1/2ulp */
id|Sgl_increment
c_func
(paren
id|resultp1
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|ROUNDPLUS
suffix:colon
r_if
c_cond
(paren
id|Sgl_iszero_sign
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* Round up positive results */
id|Sgl_increment
c_func
(paren
id|resultp1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ROUNDMINUS
suffix:colon
r_if
c_cond
(paren
id|Sgl_isone_sign
c_func
(paren
id|resultp1
)paren
)paren
(brace
multiline_comment|/* Round down negative results */
id|Sgl_increment
c_func
(paren
id|resultp1
)paren
suffix:semicolon
)brace
r_case
id|ROUNDZERO
suffix:colon
suffix:semicolon
multiline_comment|/* truncate is simple */
)brace
multiline_comment|/* end switch... */
r_if
c_cond
(paren
id|Sgl_isone_hiddenoverflow
c_func
(paren
id|resultp1
)paren
)paren
id|result_exponent
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result_exponent
op_ge
id|SGL_INFINITY_EXPONENT
)paren
(brace
multiline_comment|/* Overflow */
r_if
c_cond
(paren
id|Is_overflowtrap_enabled
c_func
(paren
)paren
)paren
(brace
multiline_comment|/*&n;                         * Adjust bias of result&n;                         */
id|Sgl_setwrapped_exponent
c_func
(paren
id|resultp1
comma
id|result_exponent
comma
id|ovfl
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|resultp1
comma
id|dstptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inexact
)paren
r_if
c_cond
(paren
id|Is_inexacttrap_enabled
c_func
(paren
)paren
)paren
r_return
(paren
id|OPC_2E_OVERFLOWEXCEPTION
op_or
id|OPC_2E_INEXACTEXCEPTION
)paren
suffix:semicolon
r_else
id|Set_inexactflag
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
id|OPC_2E_OVERFLOWEXCEPTION
)paren
suffix:semicolon
)brace
id|inexact
op_assign
id|TRUE
suffix:semicolon
id|Set_overflowflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_setoverflow
c_func
(paren
id|resultp1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|result_exponent
op_le
l_int|0
)paren
(brace
multiline_comment|/* underflow case */
r_if
c_cond
(paren
id|Is_underflowtrap_enabled
c_func
(paren
)paren
)paren
(brace
multiline_comment|/*&n;                         * Adjust bias of result&n;                         */
id|Sgl_setwrapped_exponent
c_func
(paren
id|resultp1
comma
id|result_exponent
comma
id|unfl
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|resultp1
comma
id|dstptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inexact
)paren
r_if
c_cond
(paren
id|Is_inexacttrap_enabled
c_func
(paren
)paren
)paren
r_return
(paren
id|OPC_2E_UNDERFLOWEXCEPTION
op_or
id|OPC_2E_INEXACTEXCEPTION
)paren
suffix:semicolon
r_else
id|Set_inexactflag
c_func
(paren
)paren
suffix:semicolon
r_return
id|OPC_2E_UNDERFLOWEXCEPTION
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|inexact
op_logical_and
id|is_tiny
)paren
id|Set_underflowflag
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|Sgl_set_exponent
c_func
(paren
id|resultp1
comma
id|result_exponent
)paren
suffix:semicolon
id|Sgl_copytoptr
c_func
(paren
id|resultp1
comma
id|dstptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inexact
)paren
r_if
c_cond
(paren
id|Is_inexacttrap_enabled
c_func
(paren
)paren
)paren
r_return
id|OPC_2E_INEXACTEXCEPTION
suffix:semicolon
r_else
id|Set_inexactflag
c_func
(paren
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
eof
