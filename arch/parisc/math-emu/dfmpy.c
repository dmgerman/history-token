multiline_comment|/*&n; * Linux/PA-RISC Project (http://www.parisc-linux.org/)&n; *&n; * Floating-point emulation code&n; *  Copyright (C) 2001 Hewlett-Packard (Paul Bame) &lt;bame@debian.org&gt;&n; *&n; *    This program is free software; you can redistribute it and/or modify&n; *    it under the terms of the GNU General Public License as published by&n; *    the Free Software Foundation; either version 2, or (at your option)&n; *    any later version.&n; *&n; *    This program is distributed in the hope that it will be useful,&n; *    but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *    GNU General Public License for more details.&n; *&n; *    You should have received a copy of the GNU General Public License&n; *    along with this program; if not, write to the Free Software&n; *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
multiline_comment|/*&n; * BEGIN_DESC&n; *&n; *  File:&n; *&t;@(#)&t;pa/spmath/dfmpy.c&t;&t;$Revision: 1.1 $&n; *&n; *  Purpose:&n; *&t;Double Precision Floating-point Multiply&n; *&n; *  External Interfaces:&n; *&t;dbl_fmpy(srcptr1,srcptr2,dstptr,status)&n; *&n; *  Internal Interfaces:&n; *&n; *  Theory:&n; *&t;&lt;&lt;please update with a overview of the operation of this file&gt;&gt;&n; *&n; * END_DESC&n;*/
macro_line|#include &quot;float.h&quot;
macro_line|#include &quot;dbl_float.h&quot;
multiline_comment|/*&n; *  Double Precision Floating-point Multiply&n; */
r_int
DECL|function|dbl_fmpy
id|dbl_fmpy
c_func
(paren
id|dbl_floating_point
op_star
id|srcptr1
comma
id|dbl_floating_point
op_star
id|srcptr2
comma
id|dbl_floating_point
op_star
id|dstptr
comma
r_int
r_int
op_star
id|status
)paren
(brace
r_register
r_int
r_int
id|opnd1p1
comma
id|opnd1p2
comma
id|opnd2p1
comma
id|opnd2p2
suffix:semicolon
r_register
r_int
r_int
id|opnd3p1
comma
id|opnd3p2
comma
id|resultp1
comma
id|resultp2
suffix:semicolon
r_register
r_int
id|dest_exponent
comma
id|count
suffix:semicolon
r_register
id|boolean
id|inexact
op_assign
id|FALSE
comma
id|guardbit
op_assign
id|FALSE
comma
id|stickybit
op_assign
id|FALSE
suffix:semicolon
id|boolean
id|is_tiny
suffix:semicolon
id|Dbl_copyfromptr
c_func
(paren
id|srcptr1
comma
id|opnd1p1
comma
id|opnd1p2
)paren
suffix:semicolon
id|Dbl_copyfromptr
c_func
(paren
id|srcptr2
comma
id|opnd2p1
comma
id|opnd2p2
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * set sign bit of result &n;&t; */
r_if
c_cond
(paren
id|Dbl_sign
c_func
(paren
id|opnd1p1
)paren
op_xor
id|Dbl_sign
c_func
(paren
id|opnd2p1
)paren
)paren
id|Dbl_setnegativezerop1
c_func
(paren
id|resultp1
)paren
suffix:semicolon
r_else
id|Dbl_setzerop1
c_func
(paren
id|resultp1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * check first operand for NaN&squot;s or infinity&n;&t; */
r_if
c_cond
(paren
id|Dbl_isinfinity_exponent
c_func
(paren
id|opnd1p1
)paren
)paren
(brace
r_if
c_cond
(paren
id|Dbl_iszero_mantissa
c_func
(paren
id|opnd1p1
comma
id|opnd1p2
)paren
)paren
(brace
r_if
c_cond
(paren
id|Dbl_isnotnan
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
)paren
)paren
(brace
r_if
c_cond
(paren
id|Dbl_iszero_exponentmantissa
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t;&t; * invalid since operands are infinity &n;&t;&t;&t;&t;&t; * and zero &n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|INVALIDEXCEPTION
suffix:semicolon
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_makequietnan
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; &t; * return infinity&n;&t;&t;&t; &t; */
id|Dbl_setinfinity_exponentmantissa
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;                 &t; * is NaN; signaling or quiet?&n;                 &t; */
r_if
c_cond
(paren
id|Dbl_isone_signaling
c_func
(paren
id|opnd1p1
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_set_quiet
c_func
(paren
id|opnd1p1
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t;&t; * is second operand a signaling NaN? &n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|Dbl_is_signalingnan
c_func
(paren
id|opnd2p1
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_set_quiet
c_func
(paren
id|opnd2p1
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;                 &t; * return quiet NaN&n;                 &t; */
id|Dbl_copytoptr
c_func
(paren
id|opnd1p1
comma
id|opnd1p2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * check second operand for NaN&squot;s or infinity&n;&t; */
r_if
c_cond
(paren
id|Dbl_isinfinity_exponent
c_func
(paren
id|opnd2p1
)paren
)paren
(brace
r_if
c_cond
(paren
id|Dbl_iszero_mantissa
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
)paren
)paren
(brace
r_if
c_cond
(paren
id|Dbl_iszero_exponentmantissa
c_func
(paren
id|opnd1p1
comma
id|opnd1p2
)paren
)paren
(brace
multiline_comment|/* invalid since operands are zero &amp; infinity */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|INVALIDEXCEPTION
suffix:semicolon
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_makequietnan
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * return infinity&n;&t;&t;&t; */
id|Dbl_setinfinity_exponentmantissa
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;                 * is NaN; signaling or quiet?&n;                 */
r_if
c_cond
(paren
id|Dbl_isone_signaling
c_func
(paren
id|opnd2p1
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_set_quiet
c_func
(paren
id|opnd2p1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;                 * return quiet NaN&n;                 */
id|Dbl_copytoptr
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Generate exponent &n;&t; */
id|dest_exponent
op_assign
id|Dbl_exponent
c_func
(paren
id|opnd1p1
)paren
op_plus
id|Dbl_exponent
c_func
(paren
id|opnd2p1
)paren
op_minus
id|DBL_BIAS
suffix:semicolon
multiline_comment|/*&n;&t; * Generate mantissa&n;&t; */
r_if
c_cond
(paren
id|Dbl_isnotzero_exponent
c_func
(paren
id|opnd1p1
)paren
)paren
(brace
multiline_comment|/* set hidden bit */
id|Dbl_clear_signexponent_set_hidden
c_func
(paren
id|opnd1p1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* check for zero */
r_if
c_cond
(paren
id|Dbl_iszero_mantissa
c_func
(paren
id|opnd1p1
comma
id|opnd1p2
)paren
)paren
(brace
id|Dbl_setzero_exponentmantissa
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/* is denormalized, adjust exponent */
id|Dbl_clear_signexponent
c_func
(paren
id|opnd1p1
)paren
suffix:semicolon
id|Dbl_leftshiftby1
c_func
(paren
id|opnd1p1
comma
id|opnd1p2
)paren
suffix:semicolon
id|Dbl_normalize
c_func
(paren
id|opnd1p1
comma
id|opnd1p2
comma
id|dest_exponent
)paren
suffix:semicolon
)brace
multiline_comment|/* opnd2 needs to have hidden bit set with msb in hidden bit */
r_if
c_cond
(paren
id|Dbl_isnotzero_exponent
c_func
(paren
id|opnd2p1
)paren
)paren
(brace
id|Dbl_clear_signexponent_set_hidden
c_func
(paren
id|opnd2p1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* check for zero */
r_if
c_cond
(paren
id|Dbl_iszero_mantissa
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
)paren
)paren
(brace
id|Dbl_setzero_exponentmantissa
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/* is denormalized; want to normalize */
id|Dbl_clear_signexponent
c_func
(paren
id|opnd2p1
)paren
suffix:semicolon
id|Dbl_leftshiftby1
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
)paren
suffix:semicolon
id|Dbl_normalize
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
comma
id|dest_exponent
)paren
suffix:semicolon
)brace
multiline_comment|/* Multiply two source mantissas together */
multiline_comment|/* make room for guard bits */
id|Dbl_leftshiftby7
c_func
(paren
id|opnd2p1
comma
id|opnd2p2
)paren
suffix:semicolon
id|Dbl_setzero
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
multiline_comment|/* &n;         * Four bits at a time are inspected in each loop, and a &n;         * simple shift and add multiply algorithm is used. &n;         */
r_for
c_loop
(paren
id|count
op_assign
l_int|1
suffix:semicolon
id|count
op_le
id|DBL_P
suffix:semicolon
id|count
op_add_assign
l_int|4
)paren
(brace
id|stickybit
op_or_assign
id|Dlow4p2
c_func
(paren
id|opnd3p2
)paren
suffix:semicolon
id|Dbl_rightshiftby4
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Dbit28p2
c_func
(paren
id|opnd1p2
)paren
)paren
(brace
multiline_comment|/* Twoword_add should be an ADDC followed by an ADD. */
id|Twoword_add
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|opnd2p1
op_lshift
l_int|3
op_or
id|opnd2p2
op_rshift
l_int|29
comma
id|opnd2p2
op_lshift
l_int|3
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Dbit29p2
c_func
(paren
id|opnd1p2
)paren
)paren
(brace
id|Twoword_add
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|opnd2p1
op_lshift
l_int|2
op_or
id|opnd2p2
op_rshift
l_int|30
comma
id|opnd2p2
op_lshift
l_int|2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Dbit30p2
c_func
(paren
id|opnd1p2
)paren
)paren
(brace
id|Twoword_add
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|opnd2p1
op_lshift
l_int|1
op_or
id|opnd2p2
op_rshift
l_int|31
comma
id|opnd2p2
op_lshift
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Dbit31p2
c_func
(paren
id|opnd1p2
)paren
)paren
(brace
id|Twoword_add
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|opnd2p1
comma
id|opnd2p2
)paren
suffix:semicolon
)brace
id|Dbl_rightshiftby4
c_func
(paren
id|opnd1p1
comma
id|opnd1p2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Dbit3p1
c_func
(paren
id|opnd3p1
)paren
op_eq
l_int|0
)paren
(brace
id|Dbl_leftshiftby1
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* result mantissa &gt;= 2. */
id|dest_exponent
op_increment
suffix:semicolon
)brace
multiline_comment|/* check for denormalized result */
r_while
c_loop
(paren
id|Dbit3p1
c_func
(paren
id|opnd3p1
)paren
op_eq
l_int|0
)paren
(brace
id|Dbl_leftshiftby1
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
id|dest_exponent
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * check for guard, sticky and inexact bits &n;&t; */
id|stickybit
op_or_assign
id|Dallp2
c_func
(paren
id|opnd3p2
)paren
op_lshift
l_int|25
suffix:semicolon
id|guardbit
op_assign
(paren
id|Dallp2
c_func
(paren
id|opnd3p2
)paren
op_lshift
l_int|24
)paren
op_rshift
l_int|31
suffix:semicolon
id|inexact
op_assign
id|guardbit
op_or
id|stickybit
suffix:semicolon
multiline_comment|/* align result mantissa */
id|Dbl_rightshiftby8
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * round result &n;&t; */
r_if
c_cond
(paren
id|inexact
op_logical_and
(paren
id|dest_exponent
OG
l_int|0
op_logical_or
id|Is_underflowtrap_enabled
c_func
(paren
)paren
)paren
)paren
(brace
id|Dbl_clear_signexponent
c_func
(paren
id|opnd3p1
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|Rounding_mode
c_func
(paren
)paren
)paren
(brace
r_case
id|ROUNDPLUS
suffix:colon
r_if
c_cond
(paren
id|Dbl_iszero_sign
c_func
(paren
id|resultp1
)paren
)paren
id|Dbl_increment
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ROUNDMINUS
suffix:colon
r_if
c_cond
(paren
id|Dbl_isone_sign
c_func
(paren
id|resultp1
)paren
)paren
id|Dbl_increment
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ROUNDNEAREST
suffix:colon
r_if
c_cond
(paren
id|guardbit
)paren
(brace
r_if
c_cond
(paren
id|stickybit
op_logical_or
id|Dbl_isone_lowmantissap2
c_func
(paren
id|opnd3p2
)paren
)paren
id|Dbl_increment
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|Dbl_isone_hidden
c_func
(paren
id|opnd3p1
)paren
)paren
id|dest_exponent
op_increment
suffix:semicolon
)brace
id|Dbl_set_mantissa
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
multiline_comment|/* &n;         * Test for overflow&n;         */
r_if
c_cond
(paren
id|dest_exponent
op_ge
id|DBL_INFINITY_EXPONENT
)paren
(brace
multiline_comment|/* trap if OVERFLOWTRAP enabled */
r_if
c_cond
(paren
id|Is_overflowtrap_enabled
c_func
(paren
)paren
)paren
(brace
multiline_comment|/*&n;                         * Adjust bias of result&n;                         */
id|Dbl_setwrapped_exponent
c_func
(paren
id|resultp1
comma
id|dest_exponent
comma
id|ovfl
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inexact
)paren
r_if
c_cond
(paren
id|Is_inexacttrap_enabled
c_func
(paren
)paren
)paren
r_return
(paren
id|OVERFLOWEXCEPTION
op_or
id|INEXACTEXCEPTION
)paren
suffix:semicolon
r_else
id|Set_inexactflag
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
id|OVERFLOWEXCEPTION
)paren
suffix:semicolon
)brace
id|inexact
op_assign
id|TRUE
suffix:semicolon
id|Set_overflowflag
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* set result to infinity or largest number */
id|Dbl_setoverflow
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;         * Test for underflow&n;         */
r_else
r_if
c_cond
(paren
id|dest_exponent
op_le
l_int|0
)paren
(brace
multiline_comment|/* trap if UNDERFLOWTRAP enabled */
r_if
c_cond
(paren
id|Is_underflowtrap_enabled
c_func
(paren
)paren
)paren
(brace
multiline_comment|/*&n;                         * Adjust bias of result&n;                         */
id|Dbl_setwrapped_exponent
c_func
(paren
id|resultp1
comma
id|dest_exponent
comma
id|unfl
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inexact
)paren
r_if
c_cond
(paren
id|Is_inexacttrap_enabled
c_func
(paren
)paren
)paren
r_return
(paren
id|UNDERFLOWEXCEPTION
op_or
id|INEXACTEXCEPTION
)paren
suffix:semicolon
r_else
id|Set_inexactflag
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
id|UNDERFLOWEXCEPTION
)paren
suffix:semicolon
)brace
multiline_comment|/* Determine if should set underflow flag */
id|is_tiny
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|dest_exponent
op_eq
l_int|0
op_logical_and
id|inexact
)paren
(brace
r_switch
c_cond
(paren
id|Rounding_mode
c_func
(paren
)paren
)paren
(brace
r_case
id|ROUNDPLUS
suffix:colon
r_if
c_cond
(paren
id|Dbl_iszero_sign
c_func
(paren
id|resultp1
)paren
)paren
(brace
id|Dbl_increment
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Dbl_isone_hiddenoverflow
c_func
(paren
id|opnd3p1
)paren
)paren
id|is_tiny
op_assign
id|FALSE
suffix:semicolon
id|Dbl_decrement
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ROUNDMINUS
suffix:colon
r_if
c_cond
(paren
id|Dbl_isone_sign
c_func
(paren
id|resultp1
)paren
)paren
(brace
id|Dbl_increment
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Dbl_isone_hiddenoverflow
c_func
(paren
id|opnd3p1
)paren
)paren
id|is_tiny
op_assign
id|FALSE
suffix:semicolon
id|Dbl_decrement
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ROUNDNEAREST
suffix:colon
r_if
c_cond
(paren
id|guardbit
op_logical_and
(paren
id|stickybit
op_logical_or
id|Dbl_isone_lowmantissap2
c_func
(paren
id|opnd3p2
)paren
)paren
)paren
(brace
id|Dbl_increment
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Dbl_isone_hiddenoverflow
c_func
(paren
id|opnd3p1
)paren
)paren
id|is_tiny
op_assign
id|FALSE
suffix:semicolon
id|Dbl_decrement
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * denormalize result or set to signed zero&n;&t;&t; */
id|stickybit
op_assign
id|inexact
suffix:semicolon
id|Dbl_denormalize
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
comma
id|dest_exponent
comma
id|guardbit
comma
id|stickybit
comma
id|inexact
)paren
suffix:semicolon
multiline_comment|/* return zero or smallest number */
r_if
c_cond
(paren
id|inexact
)paren
(brace
r_switch
c_cond
(paren
id|Rounding_mode
c_func
(paren
)paren
)paren
(brace
r_case
id|ROUNDPLUS
suffix:colon
r_if
c_cond
(paren
id|Dbl_iszero_sign
c_func
(paren
id|resultp1
)paren
)paren
(brace
id|Dbl_increment
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ROUNDMINUS
suffix:colon
r_if
c_cond
(paren
id|Dbl_isone_sign
c_func
(paren
id|resultp1
)paren
)paren
(brace
id|Dbl_increment
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ROUNDNEAREST
suffix:colon
r_if
c_cond
(paren
id|guardbit
op_logical_and
(paren
id|stickybit
op_logical_or
id|Dbl_isone_lowmantissap2
c_func
(paren
id|opnd3p2
)paren
)paren
)paren
(brace
id|Dbl_increment
c_func
(paren
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_tiny
)paren
id|Set_underflowflag
c_func
(paren
)paren
suffix:semicolon
)brace
id|Dbl_set_exponentmantissa
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|opnd3p1
comma
id|opnd3p2
)paren
suffix:semicolon
)brace
r_else
id|Dbl_set_exponent
c_func
(paren
id|resultp1
comma
id|dest_exponent
)paren
suffix:semicolon
multiline_comment|/* check for inexact */
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inexact
)paren
(brace
r_if
c_cond
(paren
id|Is_inexacttrap_enabled
c_func
(paren
)paren
)paren
r_return
id|INEXACTEXCEPTION
suffix:semicolon
r_else
id|Set_inexactflag
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
eof
