multiline_comment|/*&n; * Linux/PA-RISC Project (http://www.parisc-linux.org/)&n; *&n; * Floating-point emulation code&n; *  Copyright (C) 2001 Hewlett-Packard (Paul Bame) &lt;bame@debian.org&gt;&n; *&n; *    This program is free software; you can redistribute it and/or modify&n; *    it under the terms of the GNU General Public License as published by&n; *    the Free Software Foundation; either version 2, or (at your option)&n; *    any later version.&n; *&n; *    This program is distributed in the hope that it will be useful,&n; *    but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *    GNU General Public License for more details.&n; *&n; *    You should have received a copy of the GNU General Public License&n; *    along with this program; if not, write to the Free Software&n; *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
multiline_comment|/*&n; * BEGIN_DESC&n; *&n; *  File:&n; *&t;@(#)&t;pa/spmath/dfsqrt.c&t;&t;$Revision: 1.1 $&n; *&n; *  Purpose:&n; *&t;Double Floating-point Square Root&n; *&n; *  External Interfaces:&n; *&t;dbl_fsqrt(srcptr,nullptr,dstptr,status)&n; *&n; *  Internal Interfaces:&n; *&n; *  Theory:&n; *&t;&lt;&lt;please update with a overview of the operation of this file&gt;&gt;&n; *&n; * END_DESC&n;*/
macro_line|#include &quot;float.h&quot;
macro_line|#include &quot;dbl_float.h&quot;
multiline_comment|/*&n; *  Double Floating-point Square Root&n; */
multiline_comment|/*ARGSUSED*/
r_int
r_int
DECL|function|dbl_fsqrt
id|dbl_fsqrt
c_func
(paren
id|dbl_floating_point
op_star
id|srcptr
comma
r_int
r_int
op_star
id|nullptr
comma
id|dbl_floating_point
op_star
id|dstptr
comma
r_int
r_int
op_star
id|status
)paren
(brace
r_register
r_int
r_int
id|srcp1
comma
id|srcp2
comma
id|resultp1
comma
id|resultp2
suffix:semicolon
r_register
r_int
r_int
id|newbitp1
comma
id|newbitp2
comma
id|sump1
comma
id|sump2
suffix:semicolon
r_register
r_int
id|src_exponent
suffix:semicolon
r_register
id|boolean
id|guardbit
op_assign
id|FALSE
comma
id|even_exponent
suffix:semicolon
id|Dbl_copyfromptr
c_func
(paren
id|srcptr
comma
id|srcp1
comma
id|srcp2
)paren
suffix:semicolon
multiline_comment|/*&n;         * check source operand for NaN or infinity&n;         */
r_if
c_cond
(paren
(paren
id|src_exponent
op_assign
id|Dbl_exponent
c_func
(paren
id|srcp1
)paren
)paren
op_eq
id|DBL_INFINITY_EXPONENT
)paren
(brace
multiline_comment|/*&n;                 * is signaling NaN?&n;                 */
r_if
c_cond
(paren
id|Dbl_isone_signaling
c_func
(paren
id|srcp1
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_set_quiet
c_func
(paren
id|srcp1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;                 * Return quiet NaN or positive infinity.&n;&t;&t; *  Fall thru to negative test if negative infinity.&n;                 */
r_if
c_cond
(paren
id|Dbl_iszero_sign
c_func
(paren
id|srcp1
)paren
op_logical_or
id|Dbl_isnotzero_mantissa
c_func
(paren
id|srcp1
comma
id|srcp2
)paren
)paren
(brace
id|Dbl_copytoptr
c_func
(paren
id|srcp1
comma
id|srcp2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;         * check for zero source operand&n;         */
r_if
c_cond
(paren
id|Dbl_iszero_exponentmantissa
c_func
(paren
id|srcp1
comma
id|srcp2
)paren
)paren
(brace
id|Dbl_copytoptr
c_func
(paren
id|srcp1
comma
id|srcp2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;         * check for negative source operand &n;         */
r_if
c_cond
(paren
id|Dbl_isone_sign
c_func
(paren
id|srcp1
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Dbl_makequietnan
c_func
(paren
id|srcp1
comma
id|srcp2
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|srcp1
comma
id|srcp2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Generate result&n;&t; */
r_if
c_cond
(paren
id|src_exponent
OG
l_int|0
)paren
(brace
id|even_exponent
op_assign
id|Dbl_hidden
c_func
(paren
id|srcp1
)paren
suffix:semicolon
id|Dbl_clear_signexponent_set_hidden
c_func
(paren
id|srcp1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* normalize operand */
id|Dbl_clear_signexponent
c_func
(paren
id|srcp1
)paren
suffix:semicolon
id|src_exponent
op_increment
suffix:semicolon
id|Dbl_normalize
c_func
(paren
id|srcp1
comma
id|srcp2
comma
id|src_exponent
)paren
suffix:semicolon
id|even_exponent
op_assign
id|src_exponent
op_amp
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|even_exponent
)paren
(brace
multiline_comment|/* exponent is even */
multiline_comment|/* Add comment here.  Explain why odd exponent needs correction */
id|Dbl_leftshiftby1
c_func
(paren
id|srcp1
comma
id|srcp2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Add comment here.  Explain following algorithm.&n;&t; * &n;&t; * Trust me, it works.&n;&t; *&n;&t; */
id|Dbl_setzero
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|Dbl_allp1
c_func
(paren
id|newbitp1
)paren
op_assign
l_int|1
op_lshift
(paren
id|DBL_P
op_minus
l_int|32
)paren
suffix:semicolon
id|Dbl_setzero_mantissap2
c_func
(paren
id|newbitp2
)paren
suffix:semicolon
r_while
c_loop
(paren
id|Dbl_isnotzero
c_func
(paren
id|newbitp1
comma
id|newbitp2
)paren
op_logical_and
id|Dbl_isnotzero
c_func
(paren
id|srcp1
comma
id|srcp2
)paren
)paren
(brace
id|Dbl_addition
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|newbitp1
comma
id|newbitp2
comma
id|sump1
comma
id|sump2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Dbl_isnotgreaterthan
c_func
(paren
id|sump1
comma
id|sump2
comma
id|srcp1
comma
id|srcp2
)paren
)paren
(brace
id|Dbl_leftshiftby1
c_func
(paren
id|newbitp1
comma
id|newbitp2
)paren
suffix:semicolon
multiline_comment|/* update result */
id|Dbl_addition
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|newbitp1
comma
id|newbitp2
comma
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
id|Dbl_subtract
c_func
(paren
id|srcp1
comma
id|srcp2
comma
id|sump1
comma
id|sump2
comma
id|srcp1
comma
id|srcp2
)paren
suffix:semicolon
id|Dbl_rightshiftby2
c_func
(paren
id|newbitp1
comma
id|newbitp2
)paren
suffix:semicolon
)brace
r_else
(brace
id|Dbl_rightshiftby1
c_func
(paren
id|newbitp1
comma
id|newbitp2
)paren
suffix:semicolon
)brace
id|Dbl_leftshiftby1
c_func
(paren
id|srcp1
comma
id|srcp2
)paren
suffix:semicolon
)brace
multiline_comment|/* correct exponent for pre-shift */
r_if
c_cond
(paren
id|even_exponent
)paren
(brace
id|Dbl_rightshiftby1
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
)brace
multiline_comment|/* check for inexact */
r_if
c_cond
(paren
id|Dbl_isnotzero
c_func
(paren
id|srcp1
comma
id|srcp2
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|even_exponent
op_logical_and
id|Dbl_islessthan
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|srcp1
comma
id|srcp2
)paren
)paren
(brace
id|Dbl_increment
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
)brace
id|guardbit
op_assign
id|Dbl_lowmantissap2
c_func
(paren
id|resultp2
)paren
suffix:semicolon
id|Dbl_rightshiftby1
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
multiline_comment|/*  now round result  */
r_switch
c_cond
(paren
id|Rounding_mode
c_func
(paren
)paren
)paren
(brace
r_case
id|ROUNDPLUS
suffix:colon
id|Dbl_increment
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ROUNDNEAREST
suffix:colon
multiline_comment|/* stickybit is always true, so guardbit &n;&t;&t;      * is enough to determine rounding */
r_if
c_cond
(paren
id|guardbit
)paren
(brace
id|Dbl_increment
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* increment result exponent by 1 if mantissa overflowed */
r_if
c_cond
(paren
id|Dbl_isone_hiddenoverflow
c_func
(paren
id|resultp1
)paren
)paren
id|src_exponent
op_add_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|Is_inexacttrap_enabled
c_func
(paren
)paren
)paren
(brace
id|Dbl_set_exponent
c_func
(paren
id|resultp1
comma
(paren
(paren
id|src_exponent
op_minus
id|DBL_BIAS
)paren
op_rshift
l_int|1
)paren
op_plus
id|DBL_BIAS
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|INEXACTEXCEPTION
suffix:semicolon
)brace
r_else
id|Set_inexactflag
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|Dbl_rightshiftby1
c_func
(paren
id|resultp1
comma
id|resultp2
)paren
suffix:semicolon
)brace
id|Dbl_set_exponent
c_func
(paren
id|resultp1
comma
(paren
(paren
id|src_exponent
op_minus
id|DBL_BIAS
)paren
op_rshift
l_int|1
)paren
op_plus
id|DBL_BIAS
)paren
suffix:semicolon
id|Dbl_copytoptr
c_func
(paren
id|resultp1
comma
id|resultp2
comma
id|dstptr
)paren
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
eof
