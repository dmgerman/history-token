multiline_comment|/*&n; * Linux/PA-RISC Project (http://www.parisc-linux.org/)&n; *&n; * Floating-point emulation code&n; *  Copyright (C) 2001 Hewlett-Packard (Paul Bame) &lt;bame@debian.org&gt;&n; *&n; *    This program is free software; you can redistribute it and/or modify&n; *    it under the terms of the GNU General Public License as published by&n; *    the Free Software Foundation; either version 2, or (at your option)&n; *    any later version.&n; *&n; *    This program is distributed in the hope that it will be useful,&n; *    but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *    GNU General Public License for more details.&n; *&n; *    You should have received a copy of the GNU General Public License&n; *    along with this program; if not, write to the Free Software&n; *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
multiline_comment|/*&n; * BEGIN_DESC&n; *&n; *  File:&n; *&t;@(#)&t;pa/spmath/sfrem.c&t;&t;$Revision: 1.1 $&n; *&n; *  Purpose:&n; *&t;Single Precision Floating-point Remainder&n; *&n; *  External Interfaces:&n; *&t;sgl_frem(srcptr1,srcptr2,dstptr,status)&n; *&n; *  Internal Interfaces:&n; *&n; *  Theory:&n; *&t;&lt;&lt;please update with a overview of the operation of this file&gt;&gt;&n; *&n; * END_DESC&n;*/
macro_line|#include &quot;float.h&quot;
macro_line|#include &quot;sgl_float.h&quot;
multiline_comment|/*&n; *  Single Precision Floating-point Remainder&n; */
r_int
DECL|function|sgl_frem
id|sgl_frem
(paren
id|sgl_floating_point
op_star
id|srcptr1
comma
id|sgl_floating_point
op_star
id|srcptr2
comma
id|sgl_floating_point
op_star
id|dstptr
comma
r_int
r_int
op_star
id|status
)paren
(brace
r_register
r_int
r_int
id|opnd1
comma
id|opnd2
comma
id|result
suffix:semicolon
r_register
r_int
id|opnd1_exponent
comma
id|opnd2_exponent
comma
id|dest_exponent
comma
id|stepcount
suffix:semicolon
r_register
id|boolean
id|roundup
op_assign
id|FALSE
suffix:semicolon
id|opnd1
op_assign
op_star
id|srcptr1
suffix:semicolon
id|opnd2
op_assign
op_star
id|srcptr2
suffix:semicolon
multiline_comment|/*&n;&t; * check first operand for NaN&squot;s or infinity&n;&t; */
r_if
c_cond
(paren
(paren
id|opnd1_exponent
op_assign
id|Sgl_exponent
c_func
(paren
id|opnd1
)paren
)paren
op_eq
id|SGL_INFINITY_EXPONENT
)paren
(brace
r_if
c_cond
(paren
id|Sgl_iszero_mantissa
c_func
(paren
id|opnd1
)paren
)paren
(brace
r_if
c_cond
(paren
id|Sgl_isnotnan
c_func
(paren
id|opnd2
)paren
)paren
(brace
multiline_comment|/* invalid since first operand is infinity */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|INVALIDEXCEPTION
suffix:semicolon
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_makequietnan
c_func
(paren
id|result
)paren
suffix:semicolon
op_star
id|dstptr
op_assign
id|result
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;                 &t; * is NaN; signaling or quiet?&n;                 &t; */
r_if
c_cond
(paren
id|Sgl_isone_signaling
c_func
(paren
id|opnd1
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_set_quiet
c_func
(paren
id|opnd1
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t;&t; * is second operand a signaling NaN? &n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|Sgl_is_signalingnan
c_func
(paren
id|opnd2
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_set_quiet
c_func
(paren
id|opnd2
)paren
suffix:semicolon
op_star
id|dstptr
op_assign
id|opnd2
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;                 &t; * return quiet NaN&n;                 &t; */
op_star
id|dstptr
op_assign
id|opnd1
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * check second operand for NaN&squot;s or infinity&n;&t; */
r_if
c_cond
(paren
(paren
id|opnd2_exponent
op_assign
id|Sgl_exponent
c_func
(paren
id|opnd2
)paren
)paren
op_eq
id|SGL_INFINITY_EXPONENT
)paren
(brace
r_if
c_cond
(paren
id|Sgl_iszero_mantissa
c_func
(paren
id|opnd2
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * return first operand&n;&t;&t;&t; */
op_star
id|dstptr
op_assign
id|opnd1
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;                 * is NaN; signaling or quiet?&n;                 */
r_if
c_cond
(paren
id|Sgl_isone_signaling
c_func
(paren
id|opnd2
)paren
)paren
(brace
multiline_comment|/* trap if INVALIDTRAP enabled */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|INVALIDEXCEPTION
suffix:semicolon
multiline_comment|/* make NaN quiet */
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_set_quiet
c_func
(paren
id|opnd2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;                 * return quiet NaN&n;                 */
op_star
id|dstptr
op_assign
id|opnd2
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * check second operand for zero&n;&t; */
r_if
c_cond
(paren
id|Sgl_iszero_exponentmantissa
c_func
(paren
id|opnd2
)paren
)paren
(brace
multiline_comment|/* invalid since second operand is zero */
r_if
c_cond
(paren
id|Is_invalidtrap_enabled
c_func
(paren
)paren
)paren
r_return
id|INVALIDEXCEPTION
suffix:semicolon
id|Set_invalidflag
c_func
(paren
)paren
suffix:semicolon
id|Sgl_makequietnan
c_func
(paren
id|result
)paren
suffix:semicolon
op_star
id|dstptr
op_assign
id|result
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * get sign of result&n;&t; */
id|result
op_assign
id|opnd1
suffix:semicolon
multiline_comment|/* &n;&t; * check for denormalized operands&n;&t; */
r_if
c_cond
(paren
id|opnd1_exponent
op_eq
l_int|0
)paren
(brace
multiline_comment|/* check for zero */
r_if
c_cond
(paren
id|Sgl_iszero_mantissa
c_func
(paren
id|opnd1
)paren
)paren
(brace
op_star
id|dstptr
op_assign
id|opnd1
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/* normalize, then continue */
id|opnd1_exponent
op_assign
l_int|1
suffix:semicolon
id|Sgl_normalize
c_func
(paren
id|opnd1
comma
id|opnd1_exponent
)paren
suffix:semicolon
)brace
r_else
(brace
id|Sgl_clear_signexponent_set_hidden
c_func
(paren
id|opnd1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|opnd2_exponent
op_eq
l_int|0
)paren
(brace
multiline_comment|/* normalize, then continue */
id|opnd2_exponent
op_assign
l_int|1
suffix:semicolon
id|Sgl_normalize
c_func
(paren
id|opnd2
comma
id|opnd2_exponent
)paren
suffix:semicolon
)brace
r_else
(brace
id|Sgl_clear_signexponent_set_hidden
c_func
(paren
id|opnd2
)paren
suffix:semicolon
)brace
multiline_comment|/* find result exponent and divide step loop count */
id|dest_exponent
op_assign
id|opnd2_exponent
op_minus
l_int|1
suffix:semicolon
id|stepcount
op_assign
id|opnd1_exponent
op_minus
id|opnd2_exponent
suffix:semicolon
multiline_comment|/*&n;&t; * check for opnd1/opnd2 &lt; 1&n;&t; */
r_if
c_cond
(paren
id|stepcount
OL
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * check for opnd1/opnd2 &gt; 1/2&n;&t;&t; *&n;&t;&t; * In this case n will round to 1, so &n;&t;&t; *    r = opnd1 - opnd2 &n;&t;&t; */
r_if
c_cond
(paren
id|stepcount
op_eq
op_minus
l_int|1
op_logical_and
id|Sgl_isgreaterthan
c_func
(paren
id|opnd1
comma
id|opnd2
)paren
)paren
(brace
id|Sgl_all
c_func
(paren
id|result
)paren
op_assign
op_complement
id|Sgl_all
c_func
(paren
id|result
)paren
suffix:semicolon
multiline_comment|/* set sign */
multiline_comment|/* align opnd2 with opnd1 */
id|Sgl_leftshiftby1
c_func
(paren
id|opnd2
)paren
suffix:semicolon
id|Sgl_subtract
c_func
(paren
id|opnd2
comma
id|opnd1
comma
id|opnd2
)paren
suffix:semicolon
multiline_comment|/* now normalize */
r_while
c_loop
(paren
id|Sgl_iszero_hidden
c_func
(paren
id|opnd2
)paren
)paren
(brace
id|Sgl_leftshiftby1
c_func
(paren
id|opnd2
)paren
suffix:semicolon
id|dest_exponent
op_decrement
suffix:semicolon
)brace
id|Sgl_set_exponentmantissa
c_func
(paren
id|result
comma
id|opnd2
)paren
suffix:semicolon
r_goto
id|testforunderflow
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * opnd1/opnd2 &lt;= 1/2&n;&t;&t; *&n;&t;&t; * In this case n will round to zero, so &n;&t;&t; *    r = opnd1&n;&t;&t; */
id|Sgl_set_exponentmantissa
c_func
(paren
id|result
comma
id|opnd1
)paren
suffix:semicolon
id|dest_exponent
op_assign
id|opnd1_exponent
suffix:semicolon
r_goto
id|testforunderflow
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Generate result&n;&t; *&n;&t; * Do iterative subtract until remainder is less than operand 2.&n;&t; */
r_while
c_loop
(paren
id|stepcount
op_decrement
OG
l_int|0
op_logical_and
id|Sgl_all
c_func
(paren
id|opnd1
)paren
)paren
(brace
r_if
c_cond
(paren
id|Sgl_isnotlessthan
c_func
(paren
id|opnd1
comma
id|opnd2
)paren
)paren
id|Sgl_subtract
c_func
(paren
id|opnd1
comma
id|opnd2
comma
id|opnd1
)paren
suffix:semicolon
id|Sgl_leftshiftby1
c_func
(paren
id|opnd1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Do last subtract, then determine which way to round if remainder &n;&t; * is exactly 1/2 of opnd2 &n;&t; */
r_if
c_cond
(paren
id|Sgl_isnotlessthan
c_func
(paren
id|opnd1
comma
id|opnd2
)paren
)paren
(brace
id|Sgl_subtract
c_func
(paren
id|opnd1
comma
id|opnd2
comma
id|opnd1
)paren
suffix:semicolon
id|roundup
op_assign
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stepcount
OG
l_int|0
op_logical_or
id|Sgl_iszero
c_func
(paren
id|opnd1
)paren
)paren
(brace
multiline_comment|/* division is exact, remainder is zero */
id|Sgl_setzero_exponentmantissa
c_func
(paren
id|result
)paren
suffix:semicolon
op_star
id|dstptr
op_assign
id|result
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * Check for cases where opnd1/opnd2 &lt; n &n;&t; *&n;&t; * In this case the result&squot;s sign will be opposite that of&n;&t; * opnd1.  The mantissa also needs some correction.&n;&t; */
id|Sgl_leftshiftby1
c_func
(paren
id|opnd1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Sgl_isgreaterthan
c_func
(paren
id|opnd1
comma
id|opnd2
)paren
)paren
(brace
id|Sgl_invert_sign
c_func
(paren
id|result
)paren
suffix:semicolon
id|Sgl_subtract
c_func
(paren
(paren
id|opnd2
op_lshift
l_int|1
)paren
comma
id|opnd1
comma
id|opnd1
)paren
suffix:semicolon
)brace
multiline_comment|/* check for remainder being exactly 1/2 of opnd2 */
r_else
r_if
c_cond
(paren
id|Sgl_isequal
c_func
(paren
id|opnd1
comma
id|opnd2
)paren
op_logical_and
id|roundup
)paren
(brace
id|Sgl_invert_sign
c_func
(paren
id|result
)paren
suffix:semicolon
)brace
multiline_comment|/* normalize result&squot;s mantissa */
r_while
c_loop
(paren
id|Sgl_iszero_hidden
c_func
(paren
id|opnd1
)paren
)paren
(brace
id|dest_exponent
op_decrement
suffix:semicolon
id|Sgl_leftshiftby1
c_func
(paren
id|opnd1
)paren
suffix:semicolon
)brace
id|Sgl_set_exponentmantissa
c_func
(paren
id|result
comma
id|opnd1
)paren
suffix:semicolon
multiline_comment|/* &n;         * Test for underflow&n;         */
id|testforunderflow
suffix:colon
r_if
c_cond
(paren
id|dest_exponent
op_le
l_int|0
)paren
(brace
multiline_comment|/* trap if UNDERFLOWTRAP enabled */
r_if
c_cond
(paren
id|Is_underflowtrap_enabled
c_func
(paren
)paren
)paren
(brace
multiline_comment|/*&n;                         * Adjust bias of result&n;                         */
id|Sgl_setwrapped_exponent
c_func
(paren
id|result
comma
id|dest_exponent
comma
id|unfl
)paren
suffix:semicolon
op_star
id|dstptr
op_assign
id|result
suffix:semicolon
multiline_comment|/* frem is always exact */
r_return
id|UNDERFLOWEXCEPTION
suffix:semicolon
)brace
multiline_comment|/*&n;                 * denormalize result or set to signed zero&n;                 */
r_if
c_cond
(paren
id|dest_exponent
op_ge
(paren
l_int|1
op_minus
id|SGL_P
)paren
)paren
(brace
id|Sgl_rightshift_exponentmantissa
c_func
(paren
id|result
comma
l_int|1
op_minus
id|dest_exponent
)paren
suffix:semicolon
)brace
r_else
(brace
id|Sgl_setzero_exponentmantissa
c_func
(paren
id|result
)paren
suffix:semicolon
)brace
)brace
r_else
id|Sgl_set_exponent
c_func
(paren
id|result
comma
id|dest_exponent
)paren
suffix:semicolon
op_star
id|dstptr
op_assign
id|result
suffix:semicolon
r_return
id|NOEXCEPTION
suffix:semicolon
)brace
eof
