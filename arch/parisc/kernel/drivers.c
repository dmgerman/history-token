multiline_comment|/*&n; * drivers.c&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; *&n; * Copyright (c) 1999 The Puffin Group&n; * Copyright (c) 2001 Matthew Wilcox for Hewlett Packard&n; * Copyright (c) 2001 Helge Deller &lt;deller@gmx.de&gt;&n; * Copyright (c) 2001,2002 Ryan Bradetich &n; * Copyright (c) 2004 Thibaut VARENE &lt;varenet@parisc-linux.org&gt;&n; * &n; * The file handles registering devices and drivers, then matching them.&n; * It&squot;s the closest we get to a dating agency.&n; *&n; * If you&squot;re thinking about modifying this file, here are some gotchas to&n; * bear in mind:&n; *  - 715/Mirage device paths have a dummy device between Lasi and its children&n; *  - The EISA adapter may show up as a sibling or child of Wax&n; *  - Dino has an optionally functional serial port.  If firmware enables it,&n; *    it shows up as a child of Dino.  If firmware disables it, the buswalk&n; *    finds it and it shows up as a child of Cujo&n; *  - Dino has both parisc and pci devices as children&n; *  - parisc devices are discovered in a random order, including children&n; *    before parents in some cases.&n; */
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/pdc.h&gt;
macro_line|#include &lt;asm/parisc-device.h&gt;
multiline_comment|/* See comments in include/asm-parisc/pci.h */
DECL|variable|hppa_dma_ops
r_struct
id|hppa_dma_ops
op_star
id|hppa_dma_ops
suffix:semicolon
DECL|variable|hppa_dma_ops
id|EXPORT_SYMBOL
c_func
(paren
id|hppa_dma_ops
)paren
suffix:semicolon
DECL|variable|root
r_static
r_struct
id|device
id|root
op_assign
(brace
dot
id|bus_id
op_assign
l_string|&quot;parisc&quot;
comma
)brace
suffix:semicolon
DECL|macro|for_each_padev
mdefine_line|#define for_each_padev(padev) &bslash;&n;&t;for (padev = next_dev(&amp;root); padev != NULL; &bslash;&n;&t;&t;&t;padev = next_dev(&amp;padev-&gt;dev))
DECL|macro|check_dev
mdefine_line|#define check_dev(padev) &bslash;&n;&t;(padev-&gt;id.hw_type != HPHW_FAULTY) ? padev : next_dev(&amp;padev-&gt;dev)
multiline_comment|/**&n; * next_dev - enumerates registered devices&n; * @dev: the previous device returned from next_dev&n; *&n; * next_dev does a depth-first search of the tree, returning parents&n; * before children.  Returns NULL when there are no more devices.&n; */
DECL|function|next_dev
r_static
r_struct
id|parisc_device
op_star
id|next_dev
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|dev-&gt;children
)paren
)paren
(brace
id|dev
op_assign
id|list_to_dev
c_func
(paren
id|dev-&gt;children.next
)paren
suffix:semicolon
r_return
id|check_dev
c_func
(paren
id|to_parisc_device
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dev
op_ne
op_amp
id|root
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;node.next
op_ne
op_amp
id|dev-&gt;parent-&gt;children
)paren
(brace
id|dev
op_assign
id|list_to_dev
c_func
(paren
id|dev-&gt;node.next
)paren
suffix:semicolon
r_return
id|to_parisc_device
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|dev
op_assign
id|dev-&gt;parent
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * match_device - Report whether this driver can handle this device&n; * @driver: the PA-RISC driver to try&n; * @dev: the PA-RISC device to try&n; */
DECL|function|match_device
r_static
r_int
id|match_device
c_func
(paren
r_struct
id|parisc_driver
op_star
id|driver
comma
r_struct
id|parisc_device
op_star
id|dev
)paren
(brace
r_const
r_struct
id|parisc_device_id
op_star
id|ids
suffix:semicolon
r_for
c_loop
(paren
id|ids
op_assign
id|driver-&gt;id_table
suffix:semicolon
id|ids-&gt;sversion
suffix:semicolon
id|ids
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|ids-&gt;sversion
op_ne
id|SVERSION_ANY_ID
)paren
op_logical_and
(paren
id|ids-&gt;sversion
op_ne
id|dev-&gt;id.sversion
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ids-&gt;hw_type
op_ne
id|HWTYPE_ANY_ID
)paren
op_logical_and
(paren
id|ids-&gt;hw_type
op_ne
id|dev-&gt;id.hw_type
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ids-&gt;hversion
op_ne
id|HVERSION_ANY_ID
)paren
op_logical_and
(paren
id|ids-&gt;hversion
op_ne
id|dev-&gt;id.hversion
)paren
)paren
r_continue
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|claim_device
r_static
r_void
id|claim_device
c_func
(paren
r_struct
id|parisc_driver
op_star
id|driver
comma
r_struct
id|parisc_device
op_star
id|dev
)paren
(brace
id|dev-&gt;driver
op_assign
id|driver
suffix:semicolon
id|request_mem_region
c_func
(paren
id|dev-&gt;hpa
comma
l_int|0x1000
comma
id|driver-&gt;name
)paren
suffix:semicolon
)brace
DECL|function|parisc_driver_probe
r_static
r_int
id|parisc_driver_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|rc
suffix:semicolon
r_struct
id|parisc_device
op_star
id|pa_dev
op_assign
id|to_parisc_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|parisc_driver
op_star
id|pa_drv
op_assign
id|to_parisc_driver
c_func
(paren
id|dev-&gt;driver
)paren
suffix:semicolon
id|rc
op_assign
id|pa_drv
op_member_access_from_pointer
id|probe
c_func
(paren
id|pa_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
(brace
id|claim_device
c_func
(paren
id|pa_drv
comma
id|pa_dev
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|parisc_driver_remove
r_static
r_int
id|parisc_driver_remove
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|parisc_device
op_star
id|pa_dev
op_assign
id|to_parisc_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|parisc_driver
op_star
id|pa_drv
op_assign
id|to_parisc_driver
c_func
(paren
id|dev-&gt;driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pa_drv-&gt;remove
)paren
id|pa_drv
op_member_access_from_pointer
id|remove
c_func
(paren
id|pa_dev
)paren
suffix:semicolon
id|release_mem_region
c_func
(paren
id|pa_dev-&gt;hpa
comma
l_int|0x1000
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * register_parisc_driver - Register this driver if it can handle a device&n; * @driver: the PA-RISC driver to try&n; */
DECL|function|register_parisc_driver
r_int
id|register_parisc_driver
c_func
(paren
r_struct
id|parisc_driver
op_star
id|driver
)paren
(brace
multiline_comment|/* FIXME: we need this because apparently the sti&n;&t; * driver can be registered twice */
r_if
c_cond
(paren
id|driver-&gt;drv.name
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;BUG: skipping previously registered driver %s&bslash;n&quot;
comma
id|driver-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|driver-&gt;probe
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;BUG: driver %s has no probe routine&bslash;n&quot;
comma
id|driver-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|driver-&gt;drv.bus
op_assign
op_amp
id|parisc_bus_type
suffix:semicolon
multiline_comment|/* We install our own probe and remove routines */
id|WARN_ON
c_func
(paren
id|driver-&gt;drv.probe
op_ne
l_int|NULL
)paren
suffix:semicolon
id|WARN_ON
c_func
(paren
id|driver-&gt;drv.remove
op_ne
l_int|NULL
)paren
suffix:semicolon
id|driver-&gt;drv.probe
op_assign
id|parisc_driver_probe
suffix:semicolon
id|driver-&gt;drv.remove
op_assign
id|parisc_driver_remove
suffix:semicolon
id|driver-&gt;drv.name
op_assign
id|driver-&gt;name
suffix:semicolon
r_return
id|driver_register
c_func
(paren
op_amp
id|driver-&gt;drv
)paren
suffix:semicolon
)brace
DECL|variable|register_parisc_driver
id|EXPORT_SYMBOL
c_func
(paren
id|register_parisc_driver
)paren
suffix:semicolon
multiline_comment|/**&n; * count_parisc_driver - count # of devices this driver would match&n; * @driver: the PA-RISC driver to try&n; *&n; * Use by IOMMU support to &quot;guess&quot; the right size IOPdir.&n; * Formula is something like memsize/(num_iommu * entry_size).&n; */
DECL|function|count_parisc_driver
r_int
id|count_parisc_driver
c_func
(paren
r_struct
id|parisc_driver
op_star
id|driver
)paren
(brace
r_struct
id|parisc_device
op_star
id|device
suffix:semicolon
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
id|for_each_padev
c_func
(paren
id|device
)paren
(brace
r_if
c_cond
(paren
id|match_device
c_func
(paren
id|driver
comma
id|device
)paren
)paren
id|cnt
op_increment
suffix:semicolon
)brace
r_return
id|cnt
suffix:semicolon
)brace
multiline_comment|/**&n; * unregister_parisc_driver - Unregister this driver from the list of drivers&n; * @driver: the PA-RISC driver to unregister&n; */
DECL|function|unregister_parisc_driver
r_int
id|unregister_parisc_driver
c_func
(paren
r_struct
id|parisc_driver
op_star
id|driver
)paren
(brace
id|driver_unregister
c_func
(paren
op_amp
id|driver-&gt;drv
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|unregister_parisc_driver
id|EXPORT_SYMBOL
c_func
(paren
id|unregister_parisc_driver
)paren
suffix:semicolon
DECL|function|find_device_by_addr
r_static
r_struct
id|parisc_device
op_star
id|find_device_by_addr
c_func
(paren
r_int
r_int
id|hpa
)paren
(brace
r_struct
id|parisc_device
op_star
id|dev
suffix:semicolon
id|for_each_padev
c_func
(paren
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;hpa
op_eq
id|hpa
)paren
r_return
id|dev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * find_pa_parent_type - Find a parent of a specific type&n; * @dev: The device to start searching from&n; * @type: The device type to search for.&n; *&n; * Walks up the device tree looking for a device of the specified type.&n; * If it finds it, it returns it.  If not, it returns NULL.&n; */
r_const
r_struct
id|parisc_device
op_star
DECL|function|find_pa_parent_type
id|find_pa_parent_type
c_func
(paren
r_const
r_struct
id|parisc_device
op_star
id|padev
comma
r_int
id|type
)paren
(brace
r_const
r_struct
id|device
op_star
id|dev
op_assign
op_amp
id|padev-&gt;dev
suffix:semicolon
r_while
c_loop
(paren
id|dev
op_ne
op_amp
id|root
)paren
(brace
r_struct
id|parisc_device
op_star
id|candidate
op_assign
id|to_parisc_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|candidate-&gt;id.hw_type
op_eq
id|type
)paren
r_return
id|candidate
suffix:semicolon
id|dev
op_assign
id|dev-&gt;parent
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PCI
DECL|function|is_pci_dev
r_static
r_inline
r_int
id|is_pci_dev
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_return
id|dev-&gt;bus
op_eq
op_amp
id|pci_bus_type
suffix:semicolon
)brace
macro_line|#else
DECL|function|is_pci_dev
r_static
r_inline
r_int
id|is_pci_dev
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * get_node_path fills in @path with the firmware path to the device.&n; * Note that if @node is a parisc device, we don&squot;t fill in the &squot;mod&squot; field.&n; * This is because both callers pass the parent and fill in the mod&n; * themselves.  If @node is a PCI device, we do fill it in, even though this&n; * is inconsistent.&n; */
DECL|function|get_node_path
r_static
r_void
id|get_node_path
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|hardware_path
op_star
id|path
)paren
(brace
r_int
id|i
op_assign
l_int|5
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|path-&gt;bc
comma
op_minus
l_int|1
comma
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_pci_dev
c_func
(paren
id|dev
)paren
)paren
(brace
r_int
r_int
id|devfn
op_assign
id|to_pci_dev
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|devfn
suffix:semicolon
id|path-&gt;mod
op_assign
id|PCI_FUNC
c_func
(paren
id|devfn
)paren
suffix:semicolon
id|path-&gt;bc
(braket
id|i
op_decrement
)braket
op_assign
id|PCI_SLOT
c_func
(paren
id|devfn
)paren
suffix:semicolon
id|dev
op_assign
id|dev-&gt;parent
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dev
op_ne
op_amp
id|root
)paren
(brace
r_if
c_cond
(paren
id|is_pci_dev
c_func
(paren
id|dev
)paren
)paren
(brace
r_int
r_int
id|devfn
op_assign
id|to_pci_dev
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|devfn
suffix:semicolon
id|path-&gt;bc
(braket
id|i
op_decrement
)braket
op_assign
id|PCI_SLOT
c_func
(paren
id|devfn
)paren
op_or
(paren
id|PCI_FUNC
c_func
(paren
id|devfn
)paren
op_lshift
l_int|5
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;bus
op_eq
op_amp
id|parisc_bus_type
)paren
(brace
id|path-&gt;bc
(braket
id|i
op_decrement
)braket
op_assign
id|to_parisc_device
c_func
(paren
id|dev
)paren
op_member_access_from_pointer
id|hw_path
suffix:semicolon
)brace
id|dev
op_assign
id|dev-&gt;parent
suffix:semicolon
)brace
)brace
DECL|function|print_hwpath
r_static
r_char
op_star
id|print_hwpath
c_func
(paren
r_struct
id|hardware_path
op_star
id|path
comma
r_char
op_star
id|output
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|path-&gt;bc
(braket
id|i
)braket
op_eq
op_minus
l_int|1
)paren
r_continue
suffix:semicolon
id|output
op_add_assign
id|sprintf
c_func
(paren
id|output
comma
l_string|&quot;%u/&quot;
comma
(paren
r_int
r_char
)paren
id|path-&gt;bc
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|output
op_add_assign
id|sprintf
c_func
(paren
id|output
comma
l_string|&quot;%u&quot;
comma
(paren
r_int
r_char
)paren
id|path-&gt;mod
)paren
suffix:semicolon
r_return
id|output
suffix:semicolon
)brace
multiline_comment|/**&n; * print_pa_hwpath - Returns hardware path for PA devices&n; * dev: The device to return the path for&n; * output: Pointer to a previously-allocated array to place the path in.&n; *&n; * This function fills in the output array with a human-readable path&n; * to a PA device.  This string is compatible with that used by PDC, and&n; * may be printed on the outside of the box.&n; */
DECL|function|print_pa_hwpath
r_char
op_star
id|print_pa_hwpath
c_func
(paren
r_struct
id|parisc_device
op_star
id|dev
comma
r_char
op_star
id|output
)paren
(brace
r_struct
id|hardware_path
id|path
suffix:semicolon
id|get_node_path
c_func
(paren
id|dev-&gt;dev.parent
comma
op_amp
id|path
)paren
suffix:semicolon
id|path.mod
op_assign
id|dev-&gt;hw_path
suffix:semicolon
r_return
id|print_hwpath
c_func
(paren
op_amp
id|path
comma
id|output
)paren
suffix:semicolon
)brace
DECL|variable|print_pa_hwpath
id|EXPORT_SYMBOL
c_func
(paren
id|print_pa_hwpath
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_PCI) || defined(CONFIG_ISA)
multiline_comment|/**&n; * get_pci_node_path - Determines the hardware path for a PCI device&n; * @pdev: The device to return the path for&n; * @path: Pointer to a previously-allocated array to place the path in.&n; *&n; * This function fills in the hardware_path structure with the route to&n; * the specified PCI device.  This structure is suitable for passing to&n; * PDC calls.&n; */
DECL|function|get_pci_node_path
r_void
id|get_pci_node_path
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_struct
id|hardware_path
op_star
id|path
)paren
(brace
id|get_node_path
c_func
(paren
op_amp
id|pdev-&gt;dev
comma
id|path
)paren
suffix:semicolon
)brace
DECL|variable|get_pci_node_path
id|EXPORT_SYMBOL
c_func
(paren
id|get_pci_node_path
)paren
suffix:semicolon
multiline_comment|/**&n; * print_pci_hwpath - Returns hardware path for PCI devices&n; * dev: The device to return the path for&n; * output: Pointer to a previously-allocated array to place the path in.&n; *&n; * This function fills in the output array with a human-readable path&n; * to a PCI device.  This string is compatible with that used by PDC, and&n; * may be printed on the outside of the box.&n; */
DECL|function|print_pci_hwpath
r_char
op_star
id|print_pci_hwpath
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_char
op_star
id|output
)paren
(brace
r_struct
id|hardware_path
id|path
suffix:semicolon
id|get_pci_node_path
c_func
(paren
id|dev
comma
op_amp
id|path
)paren
suffix:semicolon
r_return
id|print_hwpath
c_func
(paren
op_amp
id|path
comma
id|output
)paren
suffix:semicolon
)brace
DECL|variable|print_pci_hwpath
id|EXPORT_SYMBOL
c_func
(paren
id|print_pci_hwpath
)paren
suffix:semicolon
macro_line|#endif /* defined(CONFIG_PCI) || defined(CONFIG_ISA) */
DECL|function|setup_bus_id
r_static
r_void
id|setup_bus_id
c_func
(paren
r_struct
id|parisc_device
op_star
id|padev
)paren
(brace
r_struct
id|hardware_path
id|path
suffix:semicolon
r_char
op_star
id|output
op_assign
id|padev-&gt;dev.bus_id
suffix:semicolon
r_int
id|i
suffix:semicolon
id|get_node_path
c_func
(paren
id|padev-&gt;dev.parent
comma
op_amp
id|path
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|path.bc
(braket
id|i
)braket
op_eq
op_minus
l_int|1
)paren
r_continue
suffix:semicolon
id|output
op_add_assign
id|sprintf
c_func
(paren
id|output
comma
l_string|&quot;%u:&quot;
comma
(paren
r_int
r_char
)paren
id|path.bc
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|output
comma
l_string|&quot;%u&quot;
comma
(paren
r_int
r_char
)paren
id|padev-&gt;hw_path
)paren
suffix:semicolon
)brace
DECL|function|create_tree_node
r_struct
id|parisc_device
op_star
id|create_tree_node
c_func
(paren
r_char
id|id
comma
r_struct
id|device
op_star
id|parent
)paren
(brace
r_struct
id|parisc_device
op_star
id|dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|dev
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|dev
)paren
)paren
suffix:semicolon
id|dev-&gt;hw_path
op_assign
id|id
suffix:semicolon
id|dev-&gt;id.hw_type
op_assign
id|HPHW_FAULTY
suffix:semicolon
id|dev-&gt;dev.parent
op_assign
id|parent
suffix:semicolon
id|setup_bus_id
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;dev.bus
op_assign
op_amp
id|parisc_bus_type
suffix:semicolon
id|dev-&gt;dma_mask
op_assign
l_int|0xffffffffUL
suffix:semicolon
multiline_comment|/* PARISC devices are 32-bit */
multiline_comment|/* make the generic dma mask a pointer to the parisc one */
id|dev-&gt;dev.dma_mask
op_assign
op_amp
id|dev-&gt;dma_mask
suffix:semicolon
id|dev-&gt;dev.coherent_dma_mask
op_assign
id|dev-&gt;dma_mask
suffix:semicolon
id|device_register
c_func
(paren
op_amp
id|dev-&gt;dev
)paren
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
multiline_comment|/**&n; * alloc_tree_node - returns a device entry in the iotree&n; * @parent: the parent node in the tree&n; * @id: the element of the module path for this entry&n; *&n; * Checks all the children of @parent for a matching @id.  If none&n; * found, it allocates a new device and returns it.&n; */
DECL|function|alloc_tree_node
r_static
r_struct
id|parisc_device
op_star
id|alloc_tree_node
c_func
(paren
r_struct
id|device
op_star
id|parent
comma
r_char
id|id
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|dev
comma
op_amp
id|parent-&gt;children
comma
id|node
)paren
(brace
r_struct
id|parisc_device
op_star
id|padev
op_assign
id|to_parisc_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|padev-&gt;hw_path
op_eq
id|id
)paren
r_return
id|padev
suffix:semicolon
)brace
r_return
id|create_tree_node
c_func
(paren
id|id
comma
id|parent
)paren
suffix:semicolon
)brace
DECL|function|create_parisc_device
r_static
r_struct
id|parisc_device
op_star
id|create_parisc_device
c_func
(paren
r_struct
id|hardware_path
op_star
id|modpath
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|device
op_star
id|parent
op_assign
op_amp
id|root
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|modpath-&gt;bc
(braket
id|i
)braket
op_eq
op_minus
l_int|1
)paren
r_continue
suffix:semicolon
id|parent
op_assign
op_amp
id|alloc_tree_node
c_func
(paren
id|parent
comma
id|modpath-&gt;bc
(braket
id|i
)braket
)paren
op_member_access_from_pointer
id|dev
suffix:semicolon
)brace
r_return
id|alloc_tree_node
c_func
(paren
id|parent
comma
id|modpath-&gt;mod
)paren
suffix:semicolon
)brace
r_struct
id|parisc_device
op_star
DECL|function|alloc_pa_dev
id|alloc_pa_dev
c_func
(paren
r_int
r_int
id|hpa
comma
r_struct
id|hardware_path
op_star
id|mod_path
)paren
(brace
r_int
id|status
suffix:semicolon
r_int
r_int
id|bytecnt
suffix:semicolon
id|u8
id|iodc_data
(braket
l_int|32
)braket
suffix:semicolon
r_struct
id|parisc_device
op_star
id|dev
suffix:semicolon
r_const
r_char
op_star
id|name
suffix:semicolon
multiline_comment|/* Check to make sure this device has not already been added - Ryan */
r_if
c_cond
(paren
id|find_device_by_addr
c_func
(paren
id|hpa
)paren
op_ne
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|status
op_assign
id|pdc_iodc_read
c_func
(paren
op_amp
id|bytecnt
comma
id|hpa
comma
l_int|0
comma
op_amp
id|iodc_data
comma
l_int|32
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|PDC_OK
)paren
r_return
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|create_parisc_device
c_func
(paren
id|mod_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;id.hw_type
op_ne
id|HPHW_FAULTY
)paren
(brace
r_char
id|p
(braket
l_int|64
)braket
suffix:semicolon
id|print_pa_hwpath
c_func
(paren
id|dev
comma
id|p
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Two devices have hardware path %s.  Please file a bug with HP.&bslash;n&quot;
l_string|&quot;In the meantime, you could try rearranging your cards.&bslash;n&quot;
comma
id|p
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|dev-&gt;id.hw_type
op_assign
id|iodc_data
(braket
l_int|3
)braket
op_amp
l_int|0x1f
suffix:semicolon
id|dev-&gt;id.hversion
op_assign
(paren
id|iodc_data
(braket
l_int|0
)braket
op_lshift
l_int|4
)paren
op_or
(paren
(paren
id|iodc_data
(braket
l_int|1
)braket
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
)paren
suffix:semicolon
id|dev-&gt;id.hversion_rev
op_assign
id|iodc_data
(braket
l_int|1
)braket
op_amp
l_int|0x0f
suffix:semicolon
id|dev-&gt;id.sversion
op_assign
(paren
(paren
id|iodc_data
(braket
l_int|4
)braket
op_amp
l_int|0x0f
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|iodc_data
(braket
l_int|5
)braket
op_lshift
l_int|8
)paren
op_or
id|iodc_data
(braket
l_int|6
)braket
suffix:semicolon
id|dev-&gt;hpa
op_assign
id|hpa
suffix:semicolon
id|name
op_assign
id|parisc_hardware_description
c_func
(paren
op_amp
id|dev-&gt;id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name
)paren
(brace
id|strlcpy
c_func
(paren
id|dev-&gt;name
comma
id|name
comma
r_sizeof
(paren
id|dev-&gt;name
)paren
)paren
suffix:semicolon
)brace
r_return
id|dev
suffix:semicolon
)brace
DECL|function|parisc_generic_match
r_static
r_int
id|parisc_generic_match
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|device_driver
op_star
id|drv
)paren
(brace
r_return
id|match_device
c_func
(paren
id|to_parisc_driver
c_func
(paren
id|drv
)paren
comma
id|to_parisc_device
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
)brace
DECL|macro|pa_dev_attr
mdefine_line|#define pa_dev_attr(name, field, format_string)&t;&t;&t;&t;&bslash;&n;static ssize_t name##_show(struct device *dev, char *buf)&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;struct parisc_device *padev = to_parisc_device(dev);&t;&t;&bslash;&n;&t;return sprintf(buf, format_string, padev-&gt;field);&t;&t;&bslash;&n;}
DECL|macro|pa_dev_attr_id
mdefine_line|#define pa_dev_attr_id(field, format) pa_dev_attr(field, id.field, format)
id|pa_dev_attr
c_func
(paren
id|irq
comma
id|irq
comma
l_string|&quot;%u&bslash;n&quot;
)paren
suffix:semicolon
id|pa_dev_attr_id
c_func
(paren
id|hw_type
comma
l_string|&quot;0x%02x&bslash;n&quot;
)paren
suffix:semicolon
id|pa_dev_attr
c_func
(paren
id|rev
comma
id|id.hversion_rev
comma
l_string|&quot;0x%x&bslash;n&quot;
)paren
suffix:semicolon
id|pa_dev_attr_id
c_func
(paren
id|hversion
comma
l_string|&quot;0x%03x&bslash;n&quot;
)paren
suffix:semicolon
id|pa_dev_attr_id
c_func
(paren
id|sversion
comma
l_string|&quot;0x%05x&bslash;n&quot;
)paren
suffix:semicolon
DECL|variable|parisc_device_attrs
r_static
r_struct
id|device_attribute
id|parisc_device_attrs
(braket
)braket
op_assign
(brace
id|__ATTR_RO
c_func
(paren
id|irq
)paren
comma
id|__ATTR_RO
c_func
(paren
id|hw_type
)paren
comma
id|__ATTR_RO
c_func
(paren
id|rev
)paren
comma
id|__ATTR_RO
c_func
(paren
id|hversion
)paren
comma
id|__ATTR_RO
c_func
(paren
id|sversion
)paren
comma
id|__ATTR_NULL
comma
)brace
suffix:semicolon
DECL|variable|parisc_bus_type
r_struct
id|bus_type
id|parisc_bus_type
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;parisc&quot;
comma
dot
id|match
op_assign
id|parisc_generic_match
comma
dot
id|dev_attrs
op_assign
id|parisc_device_attrs
comma
)brace
suffix:semicolon
multiline_comment|/**&n; * register_parisc_device - Locate a driver to manage this device.&n; * @dev: The parisc device.&n; *&n; * Search the driver list for a driver that is willing to manage&n; * this device.&n; */
DECL|function|register_parisc_device
r_int
id|register_parisc_device
c_func
(paren
r_struct
id|parisc_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;driver
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * match_pci_device - Matches a pci device against a given hardware path&n; * entry.&n; * @dev: the generic device (known to be contained by a pci_dev).&n; * @index: the current BC index&n; * @modpath: the hardware path.&n; * @return: true if the device matches the hardware path.&n; */
DECL|function|match_pci_device
r_static
r_int
id|match_pci_device
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|index
comma
r_struct
id|hardware_path
op_star
id|modpath
)paren
(brace
r_struct
id|pci_dev
op_star
id|pdev
op_assign
id|to_pci_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|id
suffix:semicolon
r_if
c_cond
(paren
id|index
op_eq
l_int|5
)paren
(brace
multiline_comment|/* we are at the end of the path, and on the actual device */
r_int
r_int
id|devfn
op_assign
id|pdev-&gt;devfn
suffix:semicolon
r_return
(paren
(paren
id|modpath-&gt;bc
(braket
l_int|5
)braket
op_eq
id|PCI_SLOT
c_func
(paren
id|devfn
)paren
)paren
op_logical_and
(paren
id|modpath-&gt;mod
op_eq
id|PCI_FUNC
c_func
(paren
id|devfn
)paren
)paren
)paren
suffix:semicolon
)brace
id|id
op_assign
id|PCI_SLOT
c_func
(paren
id|pdev-&gt;devfn
)paren
op_or
(paren
id|PCI_FUNC
c_func
(paren
id|pdev-&gt;devfn
)paren
op_lshift
l_int|5
)paren
suffix:semicolon
r_return
(paren
id|modpath-&gt;bc
(braket
id|index
)braket
op_eq
id|id
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * match_parisc_device - Matches a parisc device against a given hardware&n; * path entry.&n; * @dev: the generic device (known to be contained by a parisc_device).&n; * @index: the current BC index&n; * @modpath: the hardware path.&n; * @return: true if the device matches the hardware path.&n; */
DECL|function|match_parisc_device
r_static
r_int
id|match_parisc_device
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|index
comma
r_struct
id|hardware_path
op_star
id|modpath
)paren
(brace
r_struct
id|parisc_device
op_star
id|curr
op_assign
id|to_parisc_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_char
id|id
op_assign
(paren
id|index
op_eq
l_int|6
)paren
ques
c_cond
id|modpath-&gt;mod
suffix:colon
id|modpath-&gt;bc
(braket
id|index
)braket
suffix:semicolon
r_return
(paren
id|curr-&gt;hw_path
op_eq
id|id
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * parse_tree_node - returns a device entry in the iotree&n; * @parent: the parent node in the tree&n; * @index: the current BC index&n; * @modpath: the hardware_path struct to match a device against&n; * @return: The corresponding device if found, NULL otherwise.&n; *&n; * Checks all the children of @parent for a matching @id.  If none&n; * found, it returns NULL.&n; */
r_static
r_struct
id|device
op_star
DECL|function|parse_tree_node
id|parse_tree_node
c_func
(paren
r_struct
id|device
op_star
id|parent
comma
r_int
id|index
comma
r_struct
id|hardware_path
op_star
id|modpath
)paren
(brace
r_struct
id|device
op_star
id|device
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|device
comma
op_amp
id|parent-&gt;children
comma
id|node
)paren
(brace
r_if
c_cond
(paren
id|device-&gt;bus
op_eq
op_amp
id|parisc_bus_type
)paren
(brace
r_if
c_cond
(paren
id|match_parisc_device
c_func
(paren
id|device
comma
id|index
comma
id|modpath
)paren
)paren
r_return
id|device
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|is_pci_dev
c_func
(paren
id|device
)paren
)paren
(brace
r_if
c_cond
(paren
id|match_pci_device
c_func
(paren
id|device
comma
id|index
comma
id|modpath
)paren
)paren
r_return
id|device
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|device-&gt;bus
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* we are on a bus bridge */
r_struct
id|device
op_star
r_new
op_assign
id|parse_tree_node
c_func
(paren
id|device
comma
id|index
comma
id|modpath
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
)paren
r_return
r_new
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * hwpath_to_device - Finds the generic device corresponding to a given hardware path.&n; * @modpath: the hardware path.&n; * @return: The target device, NULL if not found.&n; */
DECL|function|hwpath_to_device
r_struct
id|device
op_star
id|hwpath_to_device
c_func
(paren
r_struct
id|hardware_path
op_star
id|modpath
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|device
op_star
id|parent
op_assign
op_amp
id|root
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|modpath-&gt;bc
(braket
id|i
)braket
op_eq
op_minus
l_int|1
)paren
r_continue
suffix:semicolon
id|parent
op_assign
id|parse_tree_node
c_func
(paren
id|parent
comma
id|i
comma
id|modpath
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_pci_dev
c_func
(paren
id|parent
)paren
)paren
multiline_comment|/* pci devices already parse MOD */
r_return
id|parent
suffix:semicolon
r_else
r_return
id|parse_tree_node
c_func
(paren
id|parent
comma
l_int|6
comma
id|modpath
)paren
suffix:semicolon
)brace
DECL|variable|hwpath_to_device
id|EXPORT_SYMBOL
c_func
(paren
id|hwpath_to_device
)paren
suffix:semicolon
DECL|macro|BC_PORT_MASK
mdefine_line|#define BC_PORT_MASK 0x8
DECL|macro|BC_LOWER_PORT
mdefine_line|#define BC_LOWER_PORT 0x8
DECL|macro|BUS_CONVERTER
mdefine_line|#define BUS_CONVERTER(dev) &bslash;&n;        ((dev-&gt;id.hw_type == HPHW_IOA) || (dev-&gt;id.hw_type == HPHW_BCPORT))
DECL|macro|IS_LOWER_PORT
mdefine_line|#define IS_LOWER_PORT(dev) &bslash;&n;        ((gsc_readl(dev-&gt;hpa + offsetof(struct bc_module, io_status)) &bslash;&n;                &amp; BC_PORT_MASK) == BC_LOWER_PORT)
DECL|macro|MAX_NATIVE_DEVICES
mdefine_line|#define MAX_NATIVE_DEVICES 64
DECL|macro|NATIVE_DEVICE_OFFSET
mdefine_line|#define NATIVE_DEVICE_OFFSET 0x1000
DECL|macro|FLEX_MASK
mdefine_line|#define FLEX_MASK &t;F_EXTEND(0xfffc0000)
DECL|macro|IO_IO_LOW
mdefine_line|#define IO_IO_LOW&t;offsetof(struct bc_module, io_io_low)
DECL|macro|IO_IO_HIGH
mdefine_line|#define IO_IO_HIGH&t;offsetof(struct bc_module, io_io_high)
DECL|macro|READ_IO_IO_LOW
mdefine_line|#define READ_IO_IO_LOW(dev)  (unsigned long)(signed int)gsc_readl(dev-&gt;hpa + IO_IO_LOW)
DECL|macro|READ_IO_IO_HIGH
mdefine_line|#define READ_IO_IO_HIGH(dev) (unsigned long)(signed int)gsc_readl(dev-&gt;hpa + IO_IO_HIGH)
r_static
r_void
id|walk_native_bus
c_func
(paren
r_int
r_int
id|io_io_low
comma
r_int
r_int
id|io_io_high
comma
r_struct
id|device
op_star
id|parent
)paren
suffix:semicolon
DECL|function|walk_lower_bus
r_void
id|walk_lower_bus
c_func
(paren
r_struct
id|parisc_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|io_io_low
comma
id|io_io_high
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|BUS_CONVERTER
c_func
(paren
id|dev
)paren
op_logical_or
id|IS_LOWER_PORT
c_func
(paren
id|dev
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;id.hw_type
op_eq
id|HPHW_IOA
)paren
(brace
id|io_io_low
op_assign
(paren
r_int
r_int
)paren
(paren
r_int
r_int
)paren
(paren
id|READ_IO_IO_LOW
c_func
(paren
id|dev
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
id|io_io_high
op_assign
id|io_io_low
op_plus
id|MAX_NATIVE_DEVICES
op_star
id|NATIVE_DEVICE_OFFSET
suffix:semicolon
)brace
r_else
(brace
id|io_io_low
op_assign
(paren
id|READ_IO_IO_LOW
c_func
(paren
id|dev
)paren
op_plus
op_complement
id|FLEX_MASK
)paren
op_amp
id|FLEX_MASK
suffix:semicolon
id|io_io_high
op_assign
(paren
id|READ_IO_IO_HIGH
c_func
(paren
id|dev
)paren
op_plus
op_complement
id|FLEX_MASK
)paren
op_amp
id|FLEX_MASK
suffix:semicolon
)brace
id|walk_native_bus
c_func
(paren
id|io_io_low
comma
id|io_io_high
comma
op_amp
id|dev-&gt;dev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * walk_native_bus -- Probe a bus for devices&n; * @io_io_low: Base address of this bus.&n; * @io_io_high: Last address of this bus.&n; * @parent: The parent bus device.&n; * &n; * A native bus (eg Runway or GSC) may have up to 64 devices on it,&n; * spaced at intervals of 0x1000 bytes.  PDC may not inform us of these&n; * devices, so we have to probe for them.  Unfortunately, we may find&n; * devices which are not physically connected (such as extra serial &amp;&n; * keyboard ports).  This problem is not yet solved.&n; */
DECL|function|walk_native_bus
r_static
r_void
id|walk_native_bus
c_func
(paren
r_int
r_int
id|io_io_low
comma
r_int
r_int
id|io_io_high
comma
r_struct
id|device
op_star
id|parent
)paren
(brace
r_int
id|i
comma
id|devices_found
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|hpa
op_assign
id|io_io_low
suffix:semicolon
r_struct
id|hardware_path
id|path
suffix:semicolon
id|get_node_path
c_func
(paren
id|parent
comma
op_amp
id|path
)paren
suffix:semicolon
r_do
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NATIVE_DEVICES
suffix:semicolon
id|i
op_increment
comma
id|hpa
op_add_assign
id|NATIVE_DEVICE_OFFSET
)paren
(brace
r_struct
id|parisc_device
op_star
id|dev
suffix:semicolon
multiline_comment|/* Was the device already added by Firmware? */
id|dev
op_assign
id|find_device_by_addr
c_func
(paren
id|hpa
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|path.mod
op_assign
id|i
suffix:semicolon
id|dev
op_assign
id|alloc_pa_dev
c_func
(paren
id|hpa
comma
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_continue
suffix:semicolon
id|register_parisc_device
c_func
(paren
id|dev
)paren
suffix:semicolon
id|devices_found
op_increment
suffix:semicolon
)brace
id|walk_lower_bus
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
id|devices_found
op_logical_and
id|hpa
OL
id|io_io_high
)paren
(brace
suffix:semicolon
)brace
)brace
DECL|macro|CENTRAL_BUS_ADDR
mdefine_line|#define CENTRAL_BUS_ADDR F_EXTEND(0xfff80000)
multiline_comment|/**&n; * walk_central_bus - Find devices attached to the central bus&n; *&n; * PDC doesn&squot;t tell us about all devices in the system.  This routine&n; * finds devices connected to the central bus.&n; */
DECL|function|walk_central_bus
r_void
id|walk_central_bus
c_func
(paren
r_void
)paren
(brace
id|walk_native_bus
c_func
(paren
id|CENTRAL_BUS_ADDR
comma
id|CENTRAL_BUS_ADDR
op_plus
(paren
id|MAX_NATIVE_DEVICES
op_star
id|NATIVE_DEVICE_OFFSET
)paren
comma
op_amp
id|root
)paren
suffix:semicolon
)brace
DECL|function|print_parisc_device
r_static
r_void
id|print_parisc_device
c_func
(paren
r_struct
id|parisc_device
op_star
id|dev
)paren
(brace
r_char
id|hw_path
(braket
l_int|64
)braket
suffix:semicolon
r_static
r_int
id|count
suffix:semicolon
id|print_pa_hwpath
c_func
(paren
id|dev
comma
id|hw_path
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%d. %s at 0x%lx [%s] { %d, 0x%x, 0x%.3x, 0x%.5x }&quot;
comma
op_increment
id|count
comma
id|dev-&gt;name
comma
id|dev-&gt;hpa
comma
id|hw_path
comma
id|dev-&gt;id.hw_type
comma
id|dev-&gt;id.hversion_rev
comma
id|dev-&gt;id.hversion
comma
id|dev-&gt;id.sversion
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;num_addrs
)paren
(brace
r_int
id|k
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;,  additional addresses: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|dev-&gt;num_addrs
suffix:semicolon
id|k
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;0x%lx &quot;
comma
id|dev-&gt;addr
(braket
id|k
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * init_parisc_bus - Some preparation to be done before inventory&n; */
DECL|function|init_parisc_bus
r_void
id|init_parisc_bus
c_func
(paren
r_void
)paren
(brace
id|bus_register
c_func
(paren
op_amp
id|parisc_bus_type
)paren
suffix:semicolon
id|device_register
c_func
(paren
op_amp
id|root
)paren
suffix:semicolon
id|get_device
c_func
(paren
op_amp
id|root
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * print_parisc_devices - Print out a list of devices found in this system&n; */
DECL|function|print_parisc_devices
r_void
id|print_parisc_devices
c_func
(paren
r_void
)paren
(brace
r_struct
id|parisc_device
op_star
id|dev
suffix:semicolon
id|for_each_padev
c_func
(paren
id|dev
)paren
(brace
id|print_parisc_device
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
eof
