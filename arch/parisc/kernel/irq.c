multiline_comment|/* &n; * Code to handle x86 style IRQs plus some generic interrupt stuff.&n; *&n; * Copyright (C) 1992 Linus Torvalds&n; * Copyright (C) 1994, 1995, 1996, 1997, 1998 Ralf Baechle&n; * Copyright (C) 1999 SuSE GmbH (Philipp Rumpf, prumpf@tux.org)&n; * Copyright (C) 1999-2000 Grant Grundler&n; *&n; *    This program is free software; you can redistribute it and/or modify&n; *    it under the terms of the GNU General Public License as published by&n; *    the Free Software Foundation; either version 2, or (at your option)&n; *    any later version.&n; *&n; *    This program is distributed in the hope that it will be useful,&n; *    but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *    GNU General Public License for more details.&n; *&n; *    You should have received a copy of the GNU General Public License&n; *    along with this program; if not, write to the Free Software&n; *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;asm/pdc.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/cache.h&gt;
DECL|macro|DEBUG_IRQ
macro_line|#undef DEBUG_IRQ
DECL|macro|PARISC_IRQ_CR16_COUNTS
macro_line|#undef PARISC_IRQ_CR16_COUNTS
r_extern
id|irqreturn_t
id|timer_interrupt
c_func
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_extern
id|irqreturn_t
id|ipi_interrupt
c_func
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_IRQ
DECL|macro|DBG_IRQ
mdefine_line|#define DBG_IRQ(irq, x)&t;if ((irq) != TIMER_IRQ) printk x
macro_line|#else /* DEBUG_IRQ */
DECL|macro|DBG_IRQ
mdefine_line|#define DBG_IRQ(irq, x)&t;do { } while (0)
macro_line|#endif /* DEBUG_IRQ */
DECL|macro|EIEM_MASK
mdefine_line|#define EIEM_MASK(irq)       (1UL&lt;&lt;(MAX_CPU_IRQ-IRQ_OFFSET(irq)))
multiline_comment|/* Bits in EIEM correlate with cpu_irq_action[].&n;** Numbered *Big Endian*! (ie bit 0 is MSB)&n;*/
DECL|variable|cpu_eiem
r_static
r_volatile
r_int
r_int
id|cpu_eiem
op_assign
l_int|0
suffix:semicolon
DECL|variable|irq_lock
r_static
id|spinlock_t
id|irq_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* protect IRQ regions */
DECL|function|cpu_set_eiem
r_static
r_void
id|cpu_set_eiem
c_func
(paren
r_void
op_star
id|info
)paren
(brace
id|set_eiem
c_func
(paren
(paren
r_int
r_int
)paren
id|info
)paren
suffix:semicolon
)brace
DECL|function|disable_cpu_irq
r_static
r_inline
r_void
id|disable_cpu_irq
c_func
(paren
r_void
op_star
id|unused
comma
r_int
id|irq
)paren
(brace
r_int
r_int
id|eirr_bit
op_assign
id|EIEM_MASK
c_func
(paren
id|irq
)paren
suffix:semicolon
id|cpu_eiem
op_and_assign
op_complement
id|eirr_bit
suffix:semicolon
id|on_each_cpu
c_func
(paren
id|cpu_set_eiem
comma
(paren
r_void
op_star
)paren
id|cpu_eiem
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|enable_cpu_irq
r_static
r_void
id|enable_cpu_irq
c_func
(paren
r_void
op_star
id|unused
comma
r_int
id|irq
)paren
(brace
r_int
r_int
id|eirr_bit
op_assign
id|EIEM_MASK
c_func
(paren
id|irq
)paren
suffix:semicolon
id|mtctl
c_func
(paren
id|eirr_bit
comma
l_int|23
)paren
suffix:semicolon
multiline_comment|/* clear EIRR bit before unmasking */
id|cpu_eiem
op_or_assign
id|eirr_bit
suffix:semicolon
id|on_each_cpu
c_func
(paren
id|cpu_set_eiem
comma
(paren
r_void
op_star
)paren
id|cpu_eiem
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* mask and disable are the same at the CPU level&n;** Difference is enable clears pending interrupts&n;*/
DECL|macro|mask_cpu_irq
mdefine_line|#define mask_cpu_irq&t;disable_cpu_irq
DECL|function|unmask_cpu_irq
r_static
r_inline
r_void
id|unmask_cpu_irq
c_func
(paren
r_void
op_star
id|unused
comma
r_int
id|irq
)paren
(brace
r_int
r_int
id|eirr_bit
op_assign
id|EIEM_MASK
c_func
(paren
id|irq
)paren
suffix:semicolon
id|cpu_eiem
op_or_assign
id|eirr_bit
suffix:semicolon
multiline_comment|/* NOTE: sending an IPI will cause do_cpu_irq_mask() to&n;&t;** handle *any* unmasked pending interrupts.&n;&t;** ie We don&squot;t need to check for pending interrupts here.&n;&t;*/
id|on_each_cpu
c_func
(paren
id|cpu_set_eiem
comma
(paren
r_void
op_star
)paren
id|cpu_eiem
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * XXX cpu_irq_actions[] will become 2 dimensional for per CPU EIR support.&n; * correspond changes needed in:&n; * &t;processor_probe()&t;initialize additional action arrays&n; * &t;request_irq()&t;&t;handle CPU IRQ region specially&n; * &t;do_cpu_irq_mask()&t;index into the matching irq_action array.&n; */
DECL|variable|cpu_irq_actions
r_struct
id|irqaction
id|cpu_irq_actions
(braket
id|IRQ_PER_REGION
)braket
op_assign
(brace
(braket
id|IRQ_OFFSET
c_func
(paren
id|TIMER_IRQ
)paren
)braket
op_assign
(brace
dot
id|handler
op_assign
id|timer_interrupt
comma
dot
id|name
op_assign
l_string|&quot;timer&quot;
comma
)brace
comma
macro_line|#ifdef CONFIG_SMP
(braket
id|IRQ_OFFSET
c_func
(paren
id|IPI_IRQ
)paren
)braket
op_assign
(brace
dot
id|handler
op_assign
id|ipi_interrupt
comma
dot
id|name
op_assign
l_string|&quot;IPI&quot;
comma
)brace
comma
macro_line|#endif
)brace
suffix:semicolon
DECL|variable|cpu_irq_ops
r_struct
id|irq_region_ops
id|cpu_irq_ops
op_assign
(brace
dot
id|disable_irq
op_assign
id|disable_cpu_irq
comma
dot
id|enable_irq
op_assign
id|enable_cpu_irq
comma
dot
id|mask_irq
op_assign
id|unmask_cpu_irq
comma
dot
id|unmask_irq
op_assign
id|unmask_cpu_irq
)brace
suffix:semicolon
DECL|variable|cpu0_irq_region
r_struct
id|irq_region
id|cpu0_irq_region
op_assign
(brace
dot
id|ops
op_assign
(brace
dot
id|disable_irq
op_assign
id|disable_cpu_irq
comma
dot
id|enable_irq
op_assign
id|enable_cpu_irq
comma
dot
id|mask_irq
op_assign
id|unmask_cpu_irq
comma
dot
id|unmask_irq
op_assign
id|unmask_cpu_irq
)brace
comma
dot
id|data
op_assign
(brace
dot
id|dev
op_assign
op_amp
id|cpu_data
(braket
l_int|0
)braket
comma
dot
id|name
op_assign
l_string|&quot;PARISC-CPU&quot;
comma
dot
id|irqbase
op_assign
id|IRQ_FROM_REGION
c_func
(paren
id|CPU_IRQ_REGION
)paren
comma
)brace
comma
dot
id|action
op_assign
id|cpu_irq_actions
comma
)brace
suffix:semicolon
DECL|variable|irq_region
r_struct
id|irq_region
op_star
id|irq_region
(braket
id|NR_IRQ_REGS
)braket
op_assign
(brace
(braket
l_int|0
)braket
op_assign
l_int|NULL
comma
multiline_comment|/* reserved for EISA, else causes data page fault (aka code 15) */
(braket
id|CPU_IRQ_REGION
)braket
op_assign
op_amp
id|cpu0_irq_region
comma
)brace
suffix:semicolon
multiline_comment|/*&n;** Generic interfaces that device drivers can use:&n;**    mask_irq()&t;block IRQ&n;**    unmask_irq()&t;re-enable IRQ and trigger if IRQ is pending&n;**    disable_irq()&t;block IRQ&n;**    enable_irq()&t;clear pending and re-enable IRQ&n;*/
DECL|function|mask_irq
r_void
id|mask_irq
c_func
(paren
r_int
id|irq
)paren
(brace
r_struct
id|irq_region
op_star
id|region
suffix:semicolon
id|DBG_IRQ
c_func
(paren
id|irq
comma
(paren
l_string|&quot;mask_irq(%d) %d+%d eiem 0x%lx&bslash;n&quot;
comma
id|irq
comma
id|IRQ_REGION
c_func
(paren
id|irq
)paren
comma
id|IRQ_OFFSET
c_func
(paren
id|irq
)paren
comma
id|cpu_eiem
)paren
)paren
suffix:semicolon
id|irq
op_assign
id|irq_canonicalize
c_func
(paren
id|irq
)paren
suffix:semicolon
id|region
op_assign
id|irq_region
(braket
id|IRQ_REGION
c_func
(paren
id|irq
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|region-&gt;ops.mask_irq
)paren
id|region-&gt;ops
dot
id|mask_irq
c_func
(paren
id|region-&gt;data.dev
comma
id|IRQ_OFFSET
c_func
(paren
id|irq
)paren
)paren
suffix:semicolon
)brace
DECL|function|unmask_irq
r_void
id|unmask_irq
c_func
(paren
r_int
id|irq
)paren
(brace
r_struct
id|irq_region
op_star
id|region
suffix:semicolon
id|DBG_IRQ
c_func
(paren
id|irq
comma
(paren
l_string|&quot;unmask_irq(%d) %d+%d eiem 0x%lx&bslash;n&quot;
comma
id|irq
comma
id|IRQ_REGION
c_func
(paren
id|irq
)paren
comma
id|IRQ_OFFSET
c_func
(paren
id|irq
)paren
comma
id|cpu_eiem
)paren
)paren
suffix:semicolon
id|irq
op_assign
id|irq_canonicalize
c_func
(paren
id|irq
)paren
suffix:semicolon
id|region
op_assign
id|irq_region
(braket
id|IRQ_REGION
c_func
(paren
id|irq
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|region-&gt;ops.unmask_irq
)paren
id|region-&gt;ops
dot
id|unmask_irq
c_func
(paren
id|region-&gt;data.dev
comma
id|IRQ_OFFSET
c_func
(paren
id|irq
)paren
)paren
suffix:semicolon
)brace
DECL|function|disable_irq
r_void
id|disable_irq
c_func
(paren
r_int
id|irq
)paren
(brace
r_struct
id|irq_region
op_star
id|region
suffix:semicolon
id|DBG_IRQ
c_func
(paren
id|irq
comma
(paren
l_string|&quot;disable_irq(%d) %d+%d eiem 0x%lx&bslash;n&quot;
comma
id|irq
comma
id|IRQ_REGION
c_func
(paren
id|irq
)paren
comma
id|IRQ_OFFSET
c_func
(paren
id|irq
)paren
comma
id|cpu_eiem
)paren
)paren
suffix:semicolon
id|irq
op_assign
id|irq_canonicalize
c_func
(paren
id|irq
)paren
suffix:semicolon
id|region
op_assign
id|irq_region
(braket
id|IRQ_REGION
c_func
(paren
id|irq
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|region-&gt;ops.disable_irq
)paren
id|region-&gt;ops
dot
id|disable_irq
c_func
(paren
id|region-&gt;data.dev
comma
id|IRQ_OFFSET
c_func
(paren
id|irq
)paren
)paren
suffix:semicolon
r_else
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|enable_irq
r_void
id|enable_irq
c_func
(paren
r_int
id|irq
)paren
(brace
r_struct
id|irq_region
op_star
id|region
suffix:semicolon
id|DBG_IRQ
c_func
(paren
id|irq
comma
(paren
l_string|&quot;enable_irq(%d) %d+%d eiem 0x%lx&bslash;n&quot;
comma
id|irq
comma
id|IRQ_REGION
c_func
(paren
id|irq
)paren
comma
id|IRQ_OFFSET
c_func
(paren
id|irq
)paren
comma
id|cpu_eiem
)paren
)paren
suffix:semicolon
id|irq
op_assign
id|irq_canonicalize
c_func
(paren
id|irq
)paren
suffix:semicolon
id|region
op_assign
id|irq_region
(braket
id|IRQ_REGION
c_func
(paren
id|irq
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|region-&gt;ops.enable_irq
)paren
id|region-&gt;ops
dot
id|enable_irq
c_func
(paren
id|region-&gt;data.dev
comma
id|IRQ_OFFSET
c_func
(paren
id|irq
)paren
)paren
suffix:semicolon
r_else
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|show_interrupts
r_int
id|show_interrupts
c_func
(paren
r_struct
id|seq_file
op_star
id|p
comma
r_void
op_star
id|v
)paren
(brace
macro_line|#ifdef CONFIG_PROC_FS
r_int
r_int
id|regnr
op_assign
l_int|0
suffix:semicolon
id|seq_puts
c_func
(paren
id|p
comma
l_string|&quot;     &quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_for
c_loop
(paren
id|regnr
op_assign
l_int|0
suffix:semicolon
id|regnr
OL
id|NR_CPUS
suffix:semicolon
id|regnr
op_increment
)paren
macro_line|#endif
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;      CPU%02d &quot;
comma
id|regnr
)paren
suffix:semicolon
macro_line|#ifdef PARISC_IRQ_CR16_COUNTS
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;[min/avg/max] (CPU cycle counts)&quot;
)paren
suffix:semicolon
macro_line|#endif
id|seq_putc
c_func
(paren
id|p
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t need *irqsave lock variants since this is&n;&t;** only allowed to change while in the base context.&n;&t;*/
id|spin_lock
c_func
(paren
op_amp
id|irq_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|regnr
op_assign
l_int|0
suffix:semicolon
id|regnr
OL
id|NR_IRQ_REGS
suffix:semicolon
id|regnr
op_increment
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_struct
id|irq_region
op_star
id|region
op_assign
id|irq_region
(braket
id|regnr
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|region
op_logical_or
op_logical_neg
id|region-&gt;action
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|MAX_CPU_IRQ
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|irqaction
op_star
id|action
op_assign
op_amp
id|region-&gt;action
(braket
id|i
)braket
suffix:semicolon
r_int
r_int
id|irq_no
op_assign
id|IRQ_FROM_REGION
c_func
(paren
id|regnr
)paren
op_plus
id|i
suffix:semicolon
r_int
id|j
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|action-&gt;handler
)paren
r_continue
suffix:semicolon
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;%3d: &quot;
comma
id|irq_no
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_for
c_loop
(paren
suffix:semicolon
id|j
OL
id|NR_CPUS
suffix:semicolon
id|j
op_increment
)paren
macro_line|#endif
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;%10u &quot;
comma
id|kstat_cpu
c_func
(paren
id|j
)paren
dot
id|irqs
(braket
id|irq_no
)braket
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot; %14s&quot;
comma
id|region-&gt;data.name
ques
c_cond
id|region-&gt;data.name
suffix:colon
l_string|&quot;N/A&quot;
)paren
suffix:semicolon
macro_line|#ifndef PARISC_IRQ_CR16_COUNTS
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;  %s&quot;
comma
id|action-&gt;name
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|action
op_assign
id|action-&gt;next
)paren
)paren
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot;, %s&quot;
comma
id|action-&gt;name
)paren
suffix:semicolon
macro_line|#else
r_for
c_loop
(paren
suffix:semicolon
id|action
suffix:semicolon
id|action
op_assign
id|action-&gt;next
)paren
(brace
r_int
r_int
id|k
comma
id|avg
comma
id|min
comma
id|max
suffix:semicolon
id|min
op_assign
id|max
op_assign
id|action-&gt;cr16_hist
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|avg
op_assign
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|PARISC_CR16_HIST_SIZE
suffix:semicolon
id|k
op_increment
)paren
(brace
r_int
id|hist
op_assign
id|action-&gt;cr16_hist
(braket
id|k
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hist
)paren
(brace
id|avg
op_add_assign
id|hist
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
r_if
c_cond
(paren
id|hist
OG
id|max
)paren
id|max
op_assign
id|hist
suffix:semicolon
r_if
c_cond
(paren
id|hist
OL
id|min
)paren
id|min
op_assign
id|hist
suffix:semicolon
)brace
id|avg
op_div_assign
id|k
suffix:semicolon
id|seq_printf
c_func
(paren
id|p
comma
l_string|&quot; %s[%d/%d/%d]&quot;
comma
id|action-&gt;name
comma
id|min
comma
id|avg
comma
id|max
)paren
suffix:semicolon
)brace
macro_line|#endif
id|seq_putc
c_func
(paren
id|p
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|irq_lock
)paren
suffix:semicolon
id|seq_putc
c_func
(paren
id|p
comma
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
macro_line|#endif&t;/* CONFIG_PROC_FS */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** The following form a &quot;set&quot;: Virtual IRQ, Transaction Address, Trans Data.&n;** Respectively, these map to IRQ region+EIRR, Processor HPA, EIRR bit.&n;**&n;** To use txn_XXX() interfaces, get a Virtual IRQ first.&n;** Then use that to get the Transaction address and data.&n;*/
r_int
DECL|function|txn_alloc_irq
id|txn_alloc_irq
c_func
(paren
r_void
)paren
(brace
r_int
id|irq
suffix:semicolon
multiline_comment|/* never return irq 0 cause that&squot;s the interval timer */
r_for
c_loop
(paren
id|irq
op_assign
l_int|1
suffix:semicolon
id|irq
op_le
id|MAX_CPU_IRQ
suffix:semicolon
id|irq
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_irq_actions
(braket
id|irq
)braket
dot
id|handler
op_eq
l_int|NULL
)paren
(brace
r_return
(paren
id|IRQ_FROM_REGION
c_func
(paren
id|CPU_IRQ_REGION
)paren
op_plus
id|irq
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* unlikely, but be prepared */
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|txn_claim_irq
id|txn_claim_irq
c_func
(paren
r_int
id|irq
)paren
(brace
r_if
c_cond
(paren
id|irq_region
(braket
id|IRQ_REGION
c_func
(paren
id|irq
)paren
)braket
op_member_access_from_pointer
id|action
(braket
id|IRQ_OFFSET
c_func
(paren
id|irq
)paren
)braket
dot
id|handler
op_eq
l_int|NULL
)paren
r_return
id|irq
suffix:semicolon
multiline_comment|/* unlikely, but be prepared */
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_int
r_int
DECL|function|txn_alloc_addr
id|txn_alloc_addr
c_func
(paren
r_int
id|virt_irq
)paren
(brace
r_static
r_int
id|next_cpu
op_assign
op_minus
l_int|1
suffix:semicolon
id|next_cpu
op_increment
suffix:semicolon
multiline_comment|/* assign to &quot;next&quot; CPU we want this bugger on */
multiline_comment|/* validate entry */
r_while
c_loop
(paren
(paren
id|next_cpu
OL
id|NR_CPUS
)paren
op_logical_and
op_logical_neg
id|cpu_data
(braket
id|next_cpu
)braket
dot
id|txn_addr
)paren
id|next_cpu
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|next_cpu
op_ge
id|NR_CPUS
)paren
id|next_cpu
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* nothing else, assign monarch */
r_return
id|cpu_data
(braket
id|next_cpu
)braket
dot
id|txn_addr
suffix:semicolon
)brace
multiline_comment|/*&n;** The alloc process needs to accept a parameter to accommodate limitations&n;** of the HW/SW which use these bits:&n;** Legacy PA I/O (GSC/NIO): 5 bits (architected EIM register)&n;** V-class (EPIC):          6 bits&n;** N/L-class/A500:          8 bits (iosapic)&n;** PCI 2.2 MSI:             16 bits (I think)&n;** Existing PCI devices:    32-bits (all Symbios SCSI/ATM/HyperFabric)&n;**&n;** On the service provider side:&n;** o PA 1.1 (and PA2.0 narrow mode)     5-bits (width of EIR register)&n;** o PA 2.0 wide mode                   6-bits (per processor)&n;** o IA64                               8-bits (0-256 total)&n;**&n;** So a Legacy PA I/O device on a PA 2.0 box can&squot;t use all&n;** the bits supported by the processor...and the N/L-class&n;** I/O subsystem supports more bits than PA2.0 has. The first&n;** case is the problem.&n;*/
r_int
r_int
DECL|function|txn_alloc_data
id|txn_alloc_data
c_func
(paren
r_int
id|virt_irq
comma
r_int
r_int
id|bits_wide
)paren
(brace
multiline_comment|/* XXX FIXME : bits_wide indicates how wide the transaction&n;&t;** data is allowed to be...we may need a different virt_irq&n;&t;** if this one won&squot;t work. Another reason to index virtual&n;&t;** irq&squot;s into a table which can manage CPU/IRQ bit separately.&n;&t;*/
r_if
c_cond
(paren
id|IRQ_OFFSET
c_func
(paren
id|virt_irq
)paren
OG
(paren
l_int|1
op_lshift
(paren
id|bits_wide
op_minus
l_int|1
)paren
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Sorry -- didn&squot;t allocate valid IRQ for this device&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
(paren
id|IRQ_OFFSET
c_func
(paren
id|virt_irq
)paren
)paren
suffix:semicolon
)brace
DECL|function|do_irq
r_void
id|do_irq
c_func
(paren
r_struct
id|irqaction
op_star
id|action
comma
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|irq_enter
c_func
(paren
)paren
suffix:semicolon
op_increment
id|kstat_cpu
c_func
(paren
id|cpu
)paren
dot
id|irqs
(braket
id|irq
)braket
suffix:semicolon
id|DBG_IRQ
c_func
(paren
id|irq
comma
(paren
l_string|&quot;do_irq(%d) %d+%d&bslash;n&quot;
comma
id|irq
comma
id|IRQ_REGION
c_func
(paren
id|irq
)paren
comma
id|IRQ_OFFSET
c_func
(paren
id|irq
)paren
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|action
suffix:semicolon
id|action
op_assign
id|action-&gt;next
)paren
(brace
macro_line|#ifdef PARISC_IRQ_CR16_COUNTS
r_int
r_int
id|cr_start
op_assign
id|mfctl
c_func
(paren
l_int|16
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|action-&gt;handler
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|IRQ_REGION
c_func
(paren
id|irq
)paren
op_eq
id|EISA_IRQ_REGION
op_logical_and
id|irq_region
(braket
id|EISA_IRQ_REGION
)braket
)paren
(brace
multiline_comment|/* were we called due to autodetecting (E)ISA irqs ? */
r_int
r_int
op_star
id|status
suffix:semicolon
id|status
op_assign
op_amp
id|irq_region
(braket
id|EISA_IRQ_REGION
)braket
op_member_access_from_pointer
id|data.status
(braket
id|IRQ_OFFSET
c_func
(paren
id|irq
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
op_star
id|status
op_amp
id|IRQ_AUTODETECT
)paren
(brace
op_star
id|status
op_and_assign
op_complement
id|IRQ_WAITING
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;IRQ:  CPU:%d No handler for IRQ %d !&bslash;n&quot;
comma
id|cpu
comma
id|irq
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|action
op_member_access_from_pointer
id|handler
c_func
(paren
id|irq
comma
id|action-&gt;dev_id
comma
id|regs
)paren
suffix:semicolon
macro_line|#ifdef PARISC_IRQ_CR16_COUNTS
(brace
r_int
r_int
id|cr_end
op_assign
id|mfctl
c_func
(paren
l_int|16
)paren
suffix:semicolon
r_int
r_int
id|tmp
op_assign
id|cr_end
op_minus
id|cr_start
suffix:semicolon
multiline_comment|/* check for roll over */
id|cr_start
op_assign
(paren
id|cr_end
OL
id|cr_start
)paren
ques
c_cond
op_minus
(paren
id|tmp
)paren
suffix:colon
(paren
id|tmp
)paren
suffix:semicolon
)brace
id|action-&gt;cr16_hist
(braket
id|action-&gt;cr16_idx
op_increment
)braket
op_assign
(paren
r_int
)paren
id|cr_start
suffix:semicolon
id|action-&gt;cr16_idx
op_and_assign
id|PARISC_CR16_HIST_SIZE
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
)brace
id|irq_exit
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* ONLY called from entry.S:intr_extint() */
DECL|function|do_cpu_irq_mask
r_void
id|do_cpu_irq_mask
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|eirr_val
suffix:semicolon
r_int
r_int
id|i
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* limit time in interrupt context */
multiline_comment|/*&n;&t; * PSW_I or EIEM bits cannot be enabled until after the&n;&t; * interrupts are processed.&n;&t; * timer_interrupt() assumes it won&squot;t get interrupted when it&n;&t; * holds the xtime_lock...an unmasked interrupt source could&n;&t; * interrupt and deadlock by trying to grab xtime_lock too.&n;&t; * Keeping PSW_I and EIEM disabled avoids this.&n;&t; */
id|set_eiem
c_func
(paren
l_int|0UL
)paren
suffix:semicolon
multiline_comment|/* disable all extr interrupt for now */
multiline_comment|/* 1) only process IRQs that are enabled/unmasked (cpu_eiem)&n;&t; * 2) We loop here on EIRR contents in order to avoid&n;&t; *    nested interrupts or having to take another interrupt&n;&t; *    when we could have just handled it right away.&n;&t; * 3) Limit the number of times we loop to make sure other&n;&t; *    processing can occur.&n;&t; */
r_while
c_loop
(paren
(paren
id|eirr_val
op_assign
(paren
id|mfctl
c_func
(paren
l_int|23
)paren
op_amp
id|cpu_eiem
)paren
)paren
op_logical_and
op_decrement
id|i
)paren
(brace
r_int
r_int
id|bit
op_assign
(paren
l_int|1UL
op_lshift
id|MAX_CPU_IRQ
)paren
suffix:semicolon
r_int
r_int
id|irq
suffix:semicolon
id|mtctl
c_func
(paren
id|eirr_val
comma
l_int|23
)paren
suffix:semicolon
multiline_comment|/* reset bits we are going to process */
macro_line|#ifdef DEBUG_IRQ
r_if
c_cond
(paren
id|eirr_val
op_ne
(paren
l_int|1UL
op_lshift
id|MAX_CPU_IRQ
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;do_cpu_irq_mask  %x&bslash;n&quot;
comma
id|eirr_val
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Work our way from MSb to LSb...same order we alloc EIRs */
r_for
c_loop
(paren
id|irq
op_assign
l_int|0
suffix:semicolon
id|eirr_val
op_logical_and
id|bit
suffix:semicolon
id|bit
op_rshift_assign
l_int|1
comma
id|irq
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|bit
op_amp
id|eirr_val
op_amp
id|cpu_eiem
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* clear bit in mask - can exit loop sooner */
id|eirr_val
op_and_assign
op_complement
id|bit
suffix:semicolon
id|do_irq
c_func
(paren
op_amp
id|cpu_irq_actions
(braket
id|irq
)braket
comma
id|TIMER_IRQ
op_plus
id|irq
comma
id|regs
)paren
suffix:semicolon
)brace
)brace
id|set_eiem
c_func
(paren
id|cpu_eiem
)paren
suffix:semicolon
)brace
multiline_comment|/* Called from second level IRQ regions: eg dino or iosapic. */
DECL|function|do_irq_mask
r_void
id|do_irq_mask
c_func
(paren
r_int
r_int
id|mask
comma
r_struct
id|irq_region
op_star
id|region
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|bit
suffix:semicolon
r_int
r_int
id|irq
suffix:semicolon
macro_line|#ifdef DEBUG_IRQ
r_if
c_cond
(paren
id|mask
op_ne
(paren
l_int|1L
op_lshift
id|MAX_CPU_IRQ
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;do_irq_mask %08lx %p %p&bslash;n&quot;
comma
id|mask
comma
id|region
comma
id|regs
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|bit
op_assign
(paren
l_int|1L
op_lshift
id|MAX_CPU_IRQ
)paren
comma
id|irq
op_assign
l_int|0
suffix:semicolon
id|mask
op_logical_and
id|bit
suffix:semicolon
id|bit
op_rshift_assign
l_int|1
comma
id|irq
op_increment
)paren
(brace
r_int
r_int
id|irq_num
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bit
op_amp
id|mask
)paren
)paren
r_continue
suffix:semicolon
id|mask
op_and_assign
op_complement
id|bit
suffix:semicolon
multiline_comment|/* clear bit in mask - can exit loop sooner */
id|irq_num
op_assign
id|region-&gt;data.irqbase
op_plus
id|irq
suffix:semicolon
id|mask_irq
c_func
(paren
id|irq_num
)paren
suffix:semicolon
id|do_irq
c_func
(paren
op_amp
id|region-&gt;action
(braket
id|irq
)braket
comma
id|irq_num
comma
id|regs
)paren
suffix:semicolon
id|unmask_irq
c_func
(paren
id|irq_num
)paren
suffix:semicolon
)brace
)brace
DECL|function|find_free_region
r_static
r_inline
r_int
id|find_free_region
c_func
(paren
r_void
)paren
(brace
r_int
id|irqreg
suffix:semicolon
r_for
c_loop
(paren
id|irqreg
op_assign
l_int|1
suffix:semicolon
id|irqreg
op_le
(paren
id|NR_IRQ_REGS
)paren
suffix:semicolon
id|irqreg
op_increment
)paren
(brace
r_if
c_cond
(paren
id|irq_region
(braket
id|irqreg
)braket
op_eq
l_int|NULL
)paren
r_return
id|irqreg
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****&n; * alloc_irq_region - allocate/init a new IRQ region&n; * @count: number of IRQs in this region.&n; * @ops: function table with request/release/mask/unmask/etc.. entries.&n; * @name: name of region owner for /proc/interrupts output.&n; * @dev: private data to associate with the new IRQ region.&n; *&n; * Every IRQ must become a MMIO write to the CPU&squot;s EIRR in&n; * order to get CPU service. The IRQ region represents the&n; * number of unique events the region handler can (or must)&n; * identify. For PARISC CPU, that&squot;s the width of the EIR Register.&n; * IRQ regions virtualize IRQs (eg EISA or PCI host bus controllers)&n; * for line based devices.&n; */
DECL|function|alloc_irq_region
r_struct
id|irq_region
op_star
id|alloc_irq_region
c_func
(paren
r_int
id|count
comma
r_struct
id|irq_region_ops
op_star
id|ops
comma
r_const
r_char
op_star
id|name
comma
r_void
op_star
id|dev
)paren
(brace
r_struct
id|irq_region
op_star
id|region
suffix:semicolon
r_int
id|index
suffix:semicolon
id|index
op_assign
id|find_free_region
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Maximum number of irq regions exceeded. Increase NR_IRQ_REGS!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|IRQ_REGION
c_func
(paren
id|count
op_minus
l_int|1
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
id|IRQ_PER_REGION
)paren
(brace
id|DBG_IRQ
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;alloc_irq_region() using minimum of %d irq lines for %s (%d)&bslash;n&quot;
comma
id|IRQ_PER_REGION
comma
id|name
comma
id|count
)paren
)paren
suffix:semicolon
id|count
op_assign
id|IRQ_PER_REGION
suffix:semicolon
)brace
multiline_comment|/* if either mask *or* unmask is set, both have to be set. */
r_if
c_cond
(paren
(paren
id|ops-&gt;mask_irq
op_logical_or
id|ops-&gt;unmask_irq
)paren
op_logical_and
op_logical_neg
(paren
id|ops-&gt;mask_irq
op_logical_and
id|ops-&gt;unmask_irq
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* ditto for enable/disable */
r_if
c_cond
(paren
(paren
id|ops-&gt;disable_irq
op_logical_or
id|ops-&gt;enable_irq
)paren
op_logical_and
op_logical_neg
(paren
id|ops-&gt;disable_irq
op_logical_and
id|ops-&gt;enable_irq
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|region
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|region
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|region
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|region
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|region
)paren
)paren
suffix:semicolon
id|region-&gt;action
op_assign
id|kmalloc
c_func
(paren
id|count
op_star
r_sizeof
(paren
op_star
id|region-&gt;action
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|region-&gt;action
)paren
(brace
id|kfree
c_func
(paren
id|region
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|region-&gt;action
comma
l_int|0
comma
id|count
op_star
r_sizeof
(paren
op_star
id|region-&gt;action
)paren
)paren
suffix:semicolon
id|region-&gt;ops
op_assign
op_star
id|ops
suffix:semicolon
id|region-&gt;data.irqbase
op_assign
id|IRQ_FROM_REGION
c_func
(paren
id|index
)paren
suffix:semicolon
id|region-&gt;data.name
op_assign
id|name
suffix:semicolon
id|region-&gt;data.dev
op_assign
id|dev
suffix:semicolon
id|irq_region
(braket
id|index
)braket
op_assign
id|region
suffix:semicolon
r_return
id|irq_region
(braket
id|index
)braket
suffix:semicolon
)brace
multiline_comment|/* FIXME: SMP, flags, bottom halves, rest */
DECL|function|request_irq
r_int
id|request_irq
c_func
(paren
r_int
r_int
id|irq
comma
id|irqreturn_t
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
id|irqflags
comma
r_const
r_char
op_star
id|devname
comma
r_void
op_star
id|dev_id
)paren
(brace
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;request_irq(%d, %p, 0x%lx, %s, %p)&bslash;n&quot;
comma
id|irq
comma
id|handler
comma
id|irqflags
comma
id|devname
comma
id|dev_id
)paren
suffix:semicolon
macro_line|#endif
id|irq
op_assign
id|irq_canonicalize
c_func
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/* request_irq()/free_irq() may not be called from interrupt context. */
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handler
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;request_irq(%d,...): Augh! No handler for irq!&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irq_region
(braket
id|IRQ_REGION
c_func
(paren
id|irq
)paren
)braket
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t;** Bug catcher for drivers which use &quot;char&quot; or u8 for&n;&t;&t;** the IRQ number. They lose the region number which&n;&t;&t;** is in pcidev-&gt;irq (an int).&n;&t;&t;*/
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%p (%s?) called request_irq with an invalid irq %d&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
comma
id|devname
comma
id|irq
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|irq_lock
)paren
suffix:semicolon
id|action
op_assign
op_amp
(paren
id|irq_region
(braket
id|IRQ_REGION
c_func
(paren
id|irq
)paren
)braket
op_member_access_from_pointer
id|action
(braket
id|IRQ_OFFSET
c_func
(paren
id|irq
)paren
)braket
)paren
suffix:semicolon
multiline_comment|/* First one is preallocated. */
r_if
c_cond
(paren
id|action-&gt;handler
)paren
(brace
multiline_comment|/* But it&squot;s in use...find the tail and allocate a new one */
r_while
c_loop
(paren
id|action-&gt;next
)paren
id|action
op_assign
id|action-&gt;next
suffix:semicolon
id|action-&gt;next
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|action
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
id|memset
c_func
(paren
id|action-&gt;next
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|action
)paren
)paren
suffix:semicolon
id|action
op_assign
id|action-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|irq_lock
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;request_irq(): Augh! No action!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|action-&gt;handler
op_assign
id|handler
suffix:semicolon
id|action-&gt;flags
op_assign
id|irqflags
suffix:semicolon
id|action-&gt;mask
op_assign
l_int|0
suffix:semicolon
id|action-&gt;name
op_assign
id|devname
suffix:semicolon
id|action-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|action-&gt;dev_id
op_assign
id|dev_id
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|irq_lock
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|free_irq
r_void
id|free_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
op_star
id|dev_id
)paren
(brace
r_struct
id|irqaction
op_star
id|action
comma
op_star
op_star
id|p
suffix:semicolon
multiline_comment|/* See comments in request_irq() about interrupt context */
id|irq
op_assign
id|irq_canonicalize
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|irq_lock
)paren
suffix:semicolon
id|action
op_assign
op_amp
id|irq_region
(braket
id|IRQ_REGION
c_func
(paren
id|irq
)paren
)braket
op_member_access_from_pointer
id|action
(braket
id|IRQ_OFFSET
c_func
(paren
id|irq
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|action-&gt;dev_id
op_eq
id|dev_id
)paren
(brace
r_if
c_cond
(paren
id|action-&gt;next
op_eq
l_int|NULL
)paren
(brace
id|action-&gt;handler
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|action
comma
id|action-&gt;next
comma
r_sizeof
(paren
op_star
id|action
)paren
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|irq_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|p
op_assign
op_amp
id|action-&gt;next
suffix:semicolon
id|action
op_assign
id|action-&gt;next
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
(paren
id|action
op_assign
op_star
id|p
)paren
op_ne
l_int|NULL
suffix:semicolon
id|p
op_assign
op_amp
id|action-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|action-&gt;dev_id
op_ne
id|dev_id
)paren
r_continue
suffix:semicolon
multiline_comment|/* Found it - now free it */
op_star
id|p
op_assign
id|action-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|action
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|irq_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|irq_lock
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Trying to free free IRQ%d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
DECL|function|synchronize_irq
r_void
id|synchronize_irq
c_func
(paren
r_int
r_int
id|irqnum
)paren
(brace
r_while
c_loop
(paren
id|in_irq
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * IRQ autodetection code..&n; *&n; * This depends on the fact that any interrupt that&n; * comes in on to an unassigned handler will get stuck&n; * with &quot;IRQ_WAITING&quot; cleared and the interrupt&n; * disabled.&n; */
r_static
id|DECLARE_MUTEX
c_func
(paren
id|probe_sem
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;probe_irq_on&t;- begin an interrupt autodetect&n; *&n; *&t;Commence probing for an interrupt. The interrupts are scanned&n; *&t;and a mask of potential interrupt lines is returned.&n; *&n; */
multiline_comment|/* TODO: spin_lock_irq(desc-&gt;lock -&gt; irq_lock) */
DECL|function|probe_irq_on
r_int
r_int
id|probe_irq_on
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
r_int
r_int
id|delay
suffix:semicolon
r_struct
id|irq_region
op_star
id|region
suffix:semicolon
multiline_comment|/* support for irq autoprobing is limited to EISA (irq region 0) */
id|region
op_assign
id|irq_region
(braket
id|EISA_IRQ_REGION
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|EISA_bus
op_logical_or
op_logical_neg
id|region
)paren
r_return
l_int|0
suffix:semicolon
id|down
c_func
(paren
op_amp
id|probe_sem
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * enable any unassigned irqs&n;&t; * (we must startup again here because if a longstanding irq&n;&t; * happened in the previous stage, it may have masked itself)&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|EISA_MAX_IRQS
op_minus
l_int|1
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|irq_lock
)paren
suffix:semicolon
id|action
op_assign
id|region-&gt;action
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|action-&gt;handler
)paren
(brace
id|region-&gt;data.status
(braket
id|i
)braket
op_or_assign
id|IRQ_AUTODETECT
op_or
id|IRQ_WAITING
suffix:semicolon
id|region-&gt;ops
dot
id|enable_irq
c_func
(paren
id|region-&gt;data.dev
comma
id|i
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|irq_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Wait for spurious interrupts to trigger&n;&t; */
r_for
c_loop
(paren
id|delay
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|10
suffix:semicolon
id|time_after
c_func
(paren
id|delay
comma
id|jiffies
)paren
suffix:semicolon
)paren
multiline_comment|/* about 100ms delay */
id|barrier
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now filter out any obviously spurious interrupts&n;&t; */
id|val
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|EISA_MAX_IRQS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|status
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|irq_lock
)paren
suffix:semicolon
id|status
op_assign
id|region-&gt;data.status
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|IRQ_AUTODETECT
)paren
(brace
multiline_comment|/* It triggered already - consider it spurious. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|IRQ_WAITING
)paren
)paren
(brace
id|region-&gt;data.status
(braket
id|i
)braket
op_assign
id|status
op_amp
op_complement
id|IRQ_AUTODETECT
suffix:semicolon
id|region-&gt;ops
dot
id|disable_irq
c_func
(paren
id|region-&gt;data.dev
comma
id|i
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|i
OL
id|BITS_PER_LONG
)paren
id|val
op_or_assign
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|irq_lock
)paren
suffix:semicolon
)brace
r_return
id|val
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the one interrupt that triggered (this can&n; * handle any interrupt source).&n; */
multiline_comment|/**&n; *&t;probe_irq_off&t;- end an interrupt autodetect&n; *&t;@val: mask of potential interrupts (unused)&n; *&n; *&t;Scans the unused interrupt lines and returns the line which&n; *&t;appears to have triggered the interrupt. If no interrupt was&n; *&t;found then zero is returned. If more than one interrupt is&n; *&t;found then minus the first candidate is returned to indicate&n; *&t;their is doubt.&n; *&n; *&t;The interrupt probe logic state is returned to its previous&n; *&t;value.&n; *&n; *&t;BUGS: When used in a module (which arguably shouldnt happen)&n; *&t;nothing prevents two IRQ probe callers from overlapping. The&n; *&t;results of this are non-optimal.&n; */
DECL|function|probe_irq_off
r_int
id|probe_irq_off
c_func
(paren
r_int
r_int
id|val
)paren
(brace
r_struct
id|irq_region
op_star
id|region
suffix:semicolon
r_int
id|i
comma
id|irq_found
comma
id|nr_irqs
suffix:semicolon
multiline_comment|/* support for irq autoprobing is limited to EISA (irq region 0) */
id|region
op_assign
id|irq_region
(braket
id|EISA_IRQ_REGION
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|EISA_bus
op_logical_or
op_logical_neg
id|region
)paren
r_return
l_int|0
suffix:semicolon
id|nr_irqs
op_assign
l_int|0
suffix:semicolon
id|irq_found
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|EISA_MAX_IRQS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|status
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|irq_lock
)paren
suffix:semicolon
id|status
op_assign
id|region-&gt;data.status
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|IRQ_AUTODETECT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|IRQ_WAITING
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|nr_irqs
)paren
id|irq_found
op_assign
id|i
suffix:semicolon
id|nr_irqs
op_increment
suffix:semicolon
)brace
id|region-&gt;ops
dot
id|disable_irq
c_func
(paren
id|region-&gt;data.dev
comma
id|i
)paren
suffix:semicolon
id|region-&gt;data.status
(braket
id|i
)braket
op_assign
id|status
op_amp
op_complement
id|IRQ_AUTODETECT
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|irq_lock
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|probe_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_irqs
OG
l_int|1
)paren
id|irq_found
op_assign
op_minus
id|irq_found
suffix:semicolon
r_return
id|irq_found
suffix:semicolon
)brace
DECL|function|init_IRQ
r_void
id|__init
id|init_IRQ
c_func
(paren
r_void
)paren
(brace
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* PARANOID - should already be disabled */
id|mtctl
c_func
(paren
op_minus
l_int|1L
comma
l_int|23
)paren
suffix:semicolon
multiline_comment|/* EIRR : clear all pending external intr */
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
op_logical_neg
id|cpu_eiem
)paren
id|cpu_eiem
op_assign
id|EIEM_MASK
c_func
(paren
id|IPI_IRQ
)paren
op_or
id|EIEM_MASK
c_func
(paren
id|TIMER_IRQ
)paren
suffix:semicolon
macro_line|#else
id|cpu_eiem
op_assign
id|EIEM_MASK
c_func
(paren
id|TIMER_IRQ
)paren
suffix:semicolon
macro_line|#endif
id|set_eiem
c_func
(paren
id|cpu_eiem
)paren
suffix:semicolon
multiline_comment|/* EIEM : enable all external intr */
)brace
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/* called from kernel/sysctl.c:sysctl_init() */
DECL|function|init_irq_proc
r_void
id|__init
id|init_irq_proc
c_func
(paren
r_void
)paren
(brace
)brace
macro_line|#endif
eof
