multiline_comment|/*&n; * arch/parisc/kernel/firmware.c  - safe PDC access routines&n; *&n; *&t;PDC == Processor Dependent Code&n; *&n; * See http://www.parisc-linux.org/documentation/index.html&n; * for documentation describing the entry points and calling&n; * conventions defined below.&n; *&n; * Copyright 1999 SuSE GmbH Nuernberg (Philipp Rumpf, prumpf@tux.org)&n; * Copyright 1999 The Puffin Group, (Alex deVries, David Kennedy)&n; * Copyright 2003 Grant Grundler &lt;grundler parisc-linux org&gt;&n; * Copyright 2003,2004 Ryan Bradetich &lt;rbrad@parisc-linux.org&gt;&n; * Copyright 2004 Thibaut VARENE &lt;varenet@parisc-linux.org&gt;&n; *&n; *    This program is free software; you can redistribute it and/or modify&n; *    it under the terms of the GNU General Public License as published by&n; *    the Free Software Foundation; either version 2 of the License, or&n; *    (at your option) any later version.&n; *&n; */
multiline_comment|/*&t;I think it would be in everyone&squot;s best interest to follow this&n; *&t;guidelines when writing PDC wrappers:&n; *&n; *&t; - the name of the pdc wrapper should match one of the macros&n; *&t;   used for the first two arguments&n; *&t; - don&squot;t use caps for random parts of the name&n; *&t; - use the static PDC result buffers and &quot;copyout&quot; to structs&n; *&t;   supplied by the caller to encapsulate alignment restrictions&n; *&t; - hold pdc_lock while in PDC or using static result buffers&n; *&t; - use __pa() to convert virtual (kernel) pointers to physical&n; *&t;   ones.&n; *&t; - the name of the struct used for pdc return values should equal&n; *&t;   one of the macros used for the first two arguments to the&n; *&t;   corresponding PDC call&n; *&t; - keep the order of arguments&n; *&t; - don&squot;t be smart (setting trailing NUL bytes for strings, return&n; *&t;   something useful even if the call failed) unless you are sure&n; *&t;   it&squot;s not going to affect functionality or performance&n; *&n; *&t;Example:&n; *&t;int pdc_cache_info(struct pdc_cache_info *cache_info )&n; *&t;{&n; *&t;&t;int retval;&n; *&n; *&t;&t;spin_lock_irq(&amp;pdc_lock);&n; *&t;&t;retval = mem_pdc_call(PDC_CACHE,PDC_CACHE_INFO,__pa(cache_info),0);&n; *&t;&t;convert_to_wide(pdc_result);&n; *&t;&t;memcpy(cache_info, pdc_result, sizeof(*cache_info));&n; *&t;&t;spin_unlock_irq(&amp;pdc_lock);&n; *&n; *&t;&t;return retval;&n; *&t;}&n; *&t;&t;&t;&t;&t;prumpf&t;991016&t;&n; */
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pdc.h&gt;
macro_line|#include &lt;asm/pdcpat.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/processor.h&gt;&t;/* for boot_cpu_data */
DECL|variable|pdc_lock
r_static
id|spinlock_t
id|pdc_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|pdc_result
r_static
r_int
r_int
id|pdc_result
(braket
l_int|32
)braket
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|8
)paren
)paren
)paren
suffix:semicolon
DECL|variable|pdc_result2
r_static
r_int
r_int
id|pdc_result2
(braket
l_int|32
)braket
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|8
)paren
)paren
)paren
suffix:semicolon
macro_line|#ifdef __LP64__
DECL|macro|WIDE_FIRMWARE
mdefine_line|#define WIDE_FIRMWARE 0x1
DECL|macro|NARROW_FIRMWARE
mdefine_line|#define NARROW_FIRMWARE 0x2
multiline_comment|/* Firmware needs to be initially set to narrow to determine the &n; * actual firmware width. */
DECL|variable|parisc_narrow_firmware
r_int
id|parisc_narrow_firmware
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
multiline_comment|/* on all currently-supported platforms, IODC I/O calls are always&n; * 32-bit calls, and MEM_PDC calls are always the same width as the OS.&n; * This means Cxxx boxes can&squot;t run wide kernels right now. -PB&n; *&n; * CONFIG_PDC_NARROW has been added to allow 64-bit kernels to run on&n; * systems with 32-bit MEM_PDC calls. This will allow wide kernels to&n; * run on Cxxx boxes now. -RB&n; *&n; * Note that some PAT boxes may have 64-bit IODC I/O...&n; */
macro_line|#ifdef __LP64__
r_int
id|real64_call
c_func
(paren
r_int
r_int
id|function
comma
dot
dot
dot
)paren
suffix:semicolon
macro_line|#endif
r_int
id|real32_call
c_func
(paren
r_int
r_int
id|function
comma
dot
dot
dot
)paren
suffix:semicolon
macro_line|#ifdef __LP64__
DECL|macro|MEM_PDC
macro_line|#   define MEM_PDC (unsigned long)(PAGE0-&gt;mem_pdc_hi) &lt;&lt; 32 | PAGE0-&gt;mem_pdc
DECL|macro|mem_pdc_call
macro_line|#   define mem_pdc_call(args...) unlikely(parisc_narrow_firmware) ? real32_call(MEM_PDC, args) : real64_call(MEM_PDC, args)
macro_line|#else
DECL|macro|MEM_PDC
macro_line|#   define MEM_PDC (unsigned long)PAGE0-&gt;mem_pdc
DECL|macro|mem_pdc_call
macro_line|#   define mem_pdc_call(args...) real32_call(MEM_PDC, args)
macro_line|#endif
multiline_comment|/**&n; * f_extend - Convert PDC addresses to kernel addresses.&n; * @address: Address returned from PDC.&n; *&n; * This function is used to convert PDC addresses into kernel addresses&n; * when the PDC address size and kernel address size are different.&n; */
DECL|function|f_extend
r_static
r_int
r_int
id|f_extend
c_func
(paren
r_int
r_int
id|address
)paren
(brace
macro_line|#ifdef __LP64__
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|parisc_narrow_firmware
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|address
op_amp
l_int|0xff000000
)paren
op_eq
l_int|0xf0000000
)paren
(brace
r_return
l_int|0xf0f0f0f000000000
op_or
(paren
id|u32
)paren
id|address
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|address
op_amp
l_int|0xf0000000
)paren
op_eq
l_int|0xf0000000
)paren
(brace
r_return
l_int|0xffffffff00000000
op_or
(paren
id|u32
)paren
id|address
suffix:semicolon
)brace
)brace
macro_line|#endif
r_return
id|address
suffix:semicolon
)brace
multiline_comment|/**&n; * convert_to_wide - Convert the return buffer addresses into kernel addresses.&n; * @address: The return buffer from PDC.&n; *&n; * This function is used to convert the return buffer addresses retrieved from PDC&n; * into kernel addresses when the PDC address size and kernel address size are&n; * different.&n; */
DECL|function|convert_to_wide
r_static
r_void
id|convert_to_wide
c_func
(paren
r_int
r_int
op_star
id|addr
)paren
(brace
macro_line|#ifdef __LP64__
r_int
id|i
suffix:semicolon
r_int
r_int
op_star
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|parisc_narrow_firmware
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|31
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
op_decrement
id|i
)paren
(brace
id|addr
(braket
id|i
)braket
op_assign
id|p
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
multiline_comment|/**&n; * set_firmware_width - Determine if the firmware is wide or narrow.&n; * &n; * This function must be called before any pdc_* function that uses the convert_to_wide&n; * function.&n; */
DECL|function|set_firmware_width
r_void
id|__init
id|set_firmware_width
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef __LP64__
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_MODEL
comma
id|PDC_MODEL_CAPABILITIES
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
l_int|0
)paren
suffix:semicolon
id|convert_to_wide
c_func
(paren
id|pdc_result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pdc_result
(braket
l_int|0
)braket
op_ne
id|NARROW_FIRMWARE
)paren
(brace
id|parisc_narrow_firmware
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/**&n; * pdc_emergency_unlock - Unlock the linux pdc lock&n; *&n; * This call unlocks the linux pdc lock in case we need some PDC functions&n; * (like pdc_add_valid) during kernel stack dump.&n; */
DECL|function|pdc_emergency_unlock
r_void
id|pdc_emergency_unlock
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Spinlock DEBUG code freaks out if we unconditionally unlock */
r_if
c_cond
(paren
id|spin_is_locked
c_func
(paren
op_amp
id|pdc_lock
)paren
)paren
id|spin_unlock
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * pdc_add_valid - Verify address can be accessed without causing a HPMC.&n; * @address: Address to be verified.&n; *&n; * This PDC call attempts to read from the specified address and verifies&n; * if the address is valid.&n; * &n; * The return value is PDC_OK (0) in case accessing this address is valid.&n; */
DECL|function|pdc_add_valid
r_int
id|pdc_add_valid
c_func
(paren
r_int
r_int
id|address
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_ADD_VALID
comma
id|PDC_ADD_VALID_VERIFY
comma
id|address
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|pdc_add_valid
id|EXPORT_SYMBOL
c_func
(paren
id|pdc_add_valid
)paren
suffix:semicolon
multiline_comment|/**&n; * pdc_chassis_info - Return chassis information.&n; * @result: The return buffer.&n; * @chassis_info: The memory buffer address.&n; * @len: The size of the memory buffer address.&n; *&n; * An HVERSION dependent call for returning the chassis information.&n; */
DECL|function|pdc_chassis_info
r_int
id|__init
id|pdc_chassis_info
c_func
(paren
r_struct
id|pdc_chassis_info
op_star
id|chassis_info
comma
r_void
op_star
id|led_info
comma
r_int
r_int
id|len
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|pdc_result
comma
id|chassis_info
comma
r_sizeof
(paren
op_star
id|chassis_info
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|pdc_result2
comma
id|led_info
comma
id|len
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_CHASSIS
comma
id|PDC_RETURN_CHASSIS_INFO
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
id|__pa
c_func
(paren
id|pdc_result2
)paren
comma
id|len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|chassis_info
comma
id|pdc_result
comma
r_sizeof
(paren
op_star
id|chassis_info
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|led_info
comma
id|pdc_result2
comma
id|len
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; * pdc_pat_chassis_send_log - Sends a PDC PAT CHASSIS log message.&n; * @retval: -1 on error, 0 on success. Other value are PDC errors&n; * &n; * Must be correctly formatted or expect system crash&n; */
macro_line|#ifdef __LP64__
DECL|function|pdc_pat_chassis_send_log
r_int
id|pdc_pat_chassis_send_log
c_func
(paren
r_int
r_int
id|state
comma
r_int
r_int
id|data
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_pdc_pat
c_func
(paren
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_PAT_CHASSIS_LOG
comma
id|PDC_PAT_CHASSIS_WRITE_LOG
comma
id|__pa
c_func
(paren
op_amp
id|state
)paren
comma
id|__pa
c_func
(paren
op_amp
id|data
)paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**&n; * pdc_chassis_disp - Updates display&n; * @retval: -1 on error, 0 on success&n; *&n; * Works on old PDC only (E class, others?)&n; */
DECL|function|pdc_chassis_disp
r_int
id|pdc_chassis_disp
c_func
(paren
r_int
r_int
id|disp
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_CHASSIS
comma
id|PDC_CHASSIS_DISP
comma
id|disp
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; * pdc_coproc_cfg - To identify coprocessors attached to the processor.&n; * @pdc_coproc_info: Return buffer address.&n; *&n; * This PDC call returns the presence and status of all the coprocessors&n; * attached to the processor.&n; */
DECL|function|pdc_coproc_cfg
r_int
id|__init
id|pdc_coproc_cfg
c_func
(paren
r_struct
id|pdc_coproc_cfg
op_star
id|pdc_coproc_info
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_COPROC
comma
id|PDC_COPROC_CFG
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
)paren
suffix:semicolon
id|convert_to_wide
c_func
(paren
id|pdc_result
)paren
suffix:semicolon
id|pdc_coproc_info-&gt;ccr_functional
op_assign
id|pdc_result
(braket
l_int|0
)braket
suffix:semicolon
id|pdc_coproc_info-&gt;ccr_present
op_assign
id|pdc_result
(braket
l_int|1
)braket
suffix:semicolon
id|pdc_coproc_info-&gt;revision
op_assign
id|pdc_result
(braket
l_int|17
)braket
suffix:semicolon
id|pdc_coproc_info-&gt;model
op_assign
id|pdc_result
(braket
l_int|18
)braket
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; * pdc_iodc_read - Read data from the modules IODC.&n; * @actcnt: The actual number of bytes.&n; * @hpa: The HPA of the module for the iodc read.&n; * @index: The iodc entry point.&n; * @iodc_data: A buffer memory for the iodc options.&n; * @iodc_data_size: Size of the memory buffer.&n; *&n; * This PDC call reads from the IODC of the module specified by the hpa&n; * argument.&n; */
DECL|function|pdc_iodc_read
r_int
id|pdc_iodc_read
c_func
(paren
r_int
r_int
op_star
id|actcnt
comma
r_int
r_int
id|hpa
comma
r_int
r_int
id|index
comma
r_void
op_star
id|iodc_data
comma
r_int
r_int
id|iodc_data_size
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_IODC
comma
id|PDC_IODC_READ
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
id|hpa
comma
id|index
comma
id|__pa
c_func
(paren
id|pdc_result2
)paren
comma
id|iodc_data_size
)paren
suffix:semicolon
id|convert_to_wide
c_func
(paren
id|pdc_result
)paren
suffix:semicolon
op_star
id|actcnt
op_assign
id|pdc_result
(braket
l_int|0
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|iodc_data
comma
id|pdc_result2
comma
id|iodc_data_size
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|pdc_iodc_read
id|EXPORT_SYMBOL
c_func
(paren
id|pdc_iodc_read
)paren
suffix:semicolon
multiline_comment|/**&n; * pdc_system_map_find_mods - Locate unarchitected modules.&n; * @pdc_mod_info: Return buffer address.&n; * @mod_path: pointer to dev path structure.&n; * @mod_index: fixed address module index.&n; *&n; * To locate and identify modules which reside at fixed I/O addresses, which&n; * do not self-identify via architected bus walks.&n; */
DECL|function|pdc_system_map_find_mods
r_int
id|pdc_system_map_find_mods
c_func
(paren
r_struct
id|pdc_system_map_mod_info
op_star
id|pdc_mod_info
comma
r_struct
id|pdc_module_path
op_star
id|mod_path
comma
r_int
id|mod_index
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_SYSTEM_MAP
comma
id|PDC_FIND_MODULE
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
id|__pa
c_func
(paren
id|pdc_result2
)paren
comma
id|mod_index
)paren
suffix:semicolon
id|convert_to_wide
c_func
(paren
id|pdc_result
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|pdc_mod_info
comma
id|pdc_result
comma
r_sizeof
(paren
op_star
id|pdc_mod_info
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|mod_path
comma
id|pdc_result2
comma
r_sizeof
(paren
op_star
id|mod_path
)paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|pdc_mod_info-&gt;mod_addr
op_assign
id|f_extend
c_func
(paren
id|pdc_mod_info-&gt;mod_addr
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; * pdc_system_map_find_addrs - Retrieve additional address ranges.&n; * @pdc_addr_info: Return buffer address.&n; * @mod_index: Fixed address module index.&n; * @addr_index: Address range index.&n; * &n; * Retrieve additional information about subsequent address ranges for modules&n; * with multiple address ranges.  &n; */
DECL|function|pdc_system_map_find_addrs
r_int
id|pdc_system_map_find_addrs
c_func
(paren
r_struct
id|pdc_system_map_addr_info
op_star
id|pdc_addr_info
comma
r_int
id|mod_index
comma
r_int
id|addr_index
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_SYSTEM_MAP
comma
id|PDC_FIND_ADDRESS
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
id|mod_index
comma
id|addr_index
)paren
suffix:semicolon
id|convert_to_wide
c_func
(paren
id|pdc_result
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|pdc_addr_info
comma
id|pdc_result
comma
r_sizeof
(paren
op_star
id|pdc_addr_info
)paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|pdc_addr_info-&gt;mod_addr
op_assign
id|f_extend
c_func
(paren
id|pdc_addr_info-&gt;mod_addr
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; * pdc_model_info - Return model information about the processor.&n; * @model: The return buffer.&n; *&n; * Returns the version numbers, identifiers, and capabilities from the processor module.&n; */
DECL|function|pdc_model_info
r_int
id|pdc_model_info
c_func
(paren
r_struct
id|pdc_model
op_star
id|model
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_MODEL
comma
id|PDC_MODEL_INFO
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
l_int|0
)paren
suffix:semicolon
id|convert_to_wide
c_func
(paren
id|pdc_result
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|model
comma
id|pdc_result
comma
r_sizeof
(paren
op_star
id|model
)paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; * pdc_model_sysmodel - Get the system model name.&n; * @name: A char array of at least 81 characters.&n; *&n; * Get system model name from PDC ROM (e.g. 9000/715 or 9000/778/B160L)&n; */
DECL|function|pdc_model_sysmodel
r_int
id|pdc_model_sysmodel
c_func
(paren
r_char
op_star
id|name
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_MODEL
comma
id|PDC_MODEL_SYSMODEL
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
id|OS_ID_HPUX
comma
id|__pa
c_func
(paren
id|name
)paren
)paren
suffix:semicolon
id|convert_to_wide
c_func
(paren
id|pdc_result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|PDC_OK
)paren
(brace
id|name
(braket
id|pdc_result
(braket
l_int|0
)braket
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* add trailing &squot;&bslash;0&squot; */
)brace
r_else
(brace
id|name
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; * pdc_model_versions - Identify the version number of each processor.&n; * @cpu_id: The return buffer.&n; * @id: The id of the processor to check.&n; *&n; * Returns the version number for each processor component.&n; *&n; * This comment was here before, but I do not know what it means :( -RB&n; * id: 0 = cpu revision, 1 = boot-rom-version&n; */
DECL|function|pdc_model_versions
r_int
id|pdc_model_versions
c_func
(paren
r_int
r_int
op_star
id|versions
comma
r_int
id|id
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_MODEL
comma
id|PDC_MODEL_VERSIONS
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
id|id
)paren
suffix:semicolon
id|convert_to_wide
c_func
(paren
id|pdc_result
)paren
suffix:semicolon
op_star
id|versions
op_assign
id|pdc_result
(braket
l_int|0
)braket
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; * pdc_model_cpuid - Returns the CPU_ID.&n; * @cpu_id: The return buffer.&n; *&n; * Returns the CPU_ID value which uniquely identifies the cpu portion of&n; * the processor module.&n; */
DECL|function|pdc_model_cpuid
r_int
id|pdc_model_cpuid
c_func
(paren
r_int
r_int
op_star
id|cpu_id
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|pdc_result
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* preset zero (call may not be implemented!) */
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_MODEL
comma
id|PDC_MODEL_CPU_ID
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
l_int|0
)paren
suffix:semicolon
id|convert_to_wide
c_func
(paren
id|pdc_result
)paren
suffix:semicolon
op_star
id|cpu_id
op_assign
id|pdc_result
(braket
l_int|0
)braket
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; * pdc_model_capabilities - Returns the platform capabilities.&n; * @capabilities: The return buffer.&n; *&n; * Returns information about platform support for 32- and/or 64-bit&n; * OSes, IO-PDIR coherency, and virtual aliasing.&n; */
DECL|function|pdc_model_capabilities
r_int
id|pdc_model_capabilities
c_func
(paren
r_int
r_int
op_star
id|capabilities
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|pdc_result
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* preset zero (call may not be implemented!) */
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_MODEL
comma
id|PDC_MODEL_CAPABILITIES
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
l_int|0
)paren
suffix:semicolon
id|convert_to_wide
c_func
(paren
id|pdc_result
)paren
suffix:semicolon
op_star
id|capabilities
op_assign
id|pdc_result
(braket
l_int|0
)braket
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; * pdc_cache_info - Return cache and TLB information.&n; * @cache_info: The return buffer.&n; *&n; * Returns information about the processor&squot;s cache and TLB.&n; */
DECL|function|pdc_cache_info
r_int
id|pdc_cache_info
c_func
(paren
r_struct
id|pdc_cache_info
op_star
id|cache_info
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_CACHE
comma
id|PDC_CACHE_INFO
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
l_int|0
)paren
suffix:semicolon
id|convert_to_wide
c_func
(paren
id|pdc_result
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|cache_info
comma
id|pdc_result
comma
r_sizeof
(paren
op_star
id|cache_info
)paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_PA20
multiline_comment|/**&n; * pdc_btlb_info - Return block TLB information.&n; * @btlb: The return buffer.&n; *&n; * Returns information about the hardware Block TLB.&n; */
DECL|function|pdc_btlb_info
r_int
id|pdc_btlb_info
c_func
(paren
r_struct
id|pdc_btlb_info
op_star
id|btlb
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_BLOCK_TLB
comma
id|PDC_BTLB_INFO
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
l_int|0
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|btlb
comma
id|pdc_result
comma
r_sizeof
(paren
op_star
id|btlb
)paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
id|btlb-&gt;max_size
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; * pdc_mem_map_hpa - Find fixed module information.  &n; * @address: The return buffer&n; * @mod_path: pointer to dev path structure.&n; *&n; * This call was developed for S700 workstations to allow the kernel to find&n; * the I/O devices (Core I/O). In the future (Kittyhawk and beyond) this&n; * call will be replaced (on workstations) by the architected PDC_SYSTEM_MAP&n; * call.&n; *&n; * This call is supported by all existing S700 workstations (up to  Gecko).&n; */
DECL|function|pdc_mem_map_hpa
r_int
id|pdc_mem_map_hpa
c_func
(paren
r_struct
id|pdc_memory_map
op_star
id|address
comma
r_struct
id|pdc_module_path
op_star
id|mod_path
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|pdc_result2
comma
id|mod_path
comma
r_sizeof
(paren
op_star
id|mod_path
)paren
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_MEM_MAP
comma
id|PDC_MEM_MAP_HPA
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
id|__pa
c_func
(paren
id|pdc_result2
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|address
comma
id|pdc_result
comma
r_sizeof
(paren
op_star
id|address
)paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
macro_line|#endif&t;/* !CONFIG_PA20 */
multiline_comment|/**&n; * pdc_lan_station_id - Get the LAN address.&n; * @lan_addr: The return buffer.&n; * @hpa: The network device HPA.&n; *&n; * Get the LAN station address when it is not directly available from the LAN hardware.&n; */
DECL|function|pdc_lan_station_id
r_int
id|pdc_lan_station_id
c_func
(paren
r_char
op_star
id|lan_addr
comma
r_int
r_int
id|hpa
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_LAN_STATION_ID
comma
id|PDC_LAN_STATION_ID_READ
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
id|hpa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
multiline_comment|/* FIXME: else read MAC from NVRAM */
id|memset
c_func
(paren
id|lan_addr
comma
l_int|0
comma
id|PDC_LAN_STATION_ID_SIZE
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|lan_addr
comma
id|pdc_result
comma
id|PDC_LAN_STATION_ID_SIZE
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|pdc_lan_station_id
id|EXPORT_SYMBOL
c_func
(paren
id|pdc_lan_station_id
)paren
suffix:semicolon
multiline_comment|/**&n; * pdc_stable_read - Read data from Stable Storage.&n; * @staddr: Stable Storage address to access.&n; * @memaddr: The memory address where Stable Storage data shall be copied.&n; * @count: number of bytes to transfert. count is multiple of 4.&n; *&n; * This PDC call reads from the Stable Storage address supplied in staddr&n; * and copies count bytes to the memory address memaddr.&n; * The call will fail if staddr+count &gt; PDC_STABLE size.&n; */
DECL|function|pdc_stable_read
r_int
id|pdc_stable_read
c_func
(paren
r_int
r_int
id|staddr
comma
r_void
op_star
id|memaddr
comma
r_int
r_int
id|count
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_STABLE
comma
id|PDC_STABLE_READ
comma
id|staddr
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
id|count
)paren
suffix:semicolon
id|convert_to_wide
c_func
(paren
id|pdc_result
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|memaddr
comma
id|pdc_result
comma
id|count
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|pdc_stable_read
id|EXPORT_SYMBOL
c_func
(paren
id|pdc_stable_read
)paren
suffix:semicolon
multiline_comment|/**&n; * pdc_stable_write - Write data to Stable Storage.&n; * @staddr: Stable Storage address to access.&n; * @memaddr: The memory address where Stable Storage data shall be read from.&n; * @count: number of bytes to transfert. count is multiple of 4.&n; *&n; * This PDC call reads count bytes from the supplied memaddr address,&n; * and copies count bytes to the Stable Storage address staddr.&n; * The call will fail if staddr+count &gt; PDC_STABLE size.&n; */
DECL|function|pdc_stable_write
r_int
id|pdc_stable_write
c_func
(paren
r_int
r_int
id|staddr
comma
r_void
op_star
id|memaddr
comma
r_int
r_int
id|count
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|pdc_result
comma
id|memaddr
comma
id|count
)paren
suffix:semicolon
id|convert_to_wide
c_func
(paren
id|pdc_result
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_STABLE
comma
id|PDC_STABLE_WRITE
comma
id|staddr
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
id|count
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|pdc_stable_write
id|EXPORT_SYMBOL
c_func
(paren
id|pdc_stable_write
)paren
suffix:semicolon
multiline_comment|/**&n; * pdc_stable_get_size - Get Stable Storage size in bytes.&n; * @size: pointer where the size will be stored.&n; *&n; * This PDC call returns the number of bytes in the processor&squot;s Stable&n; * Storage, which is the number of contiguous bytes implemented in Stable&n; * Storage starting from staddr=0. size in an unsigned 64-bit integer&n; * which is a multiple of four.&n; */
DECL|function|pdc_stable_get_size
r_int
id|pdc_stable_get_size
c_func
(paren
r_int
r_int
op_star
id|size
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_STABLE
comma
id|PDC_STABLE_RETURN_SIZE
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
)paren
suffix:semicolon
op_star
id|size
op_assign
id|pdc_result
(braket
l_int|0
)braket
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|pdc_stable_get_size
id|EXPORT_SYMBOL
c_func
(paren
id|pdc_stable_get_size
)paren
suffix:semicolon
multiline_comment|/**&n; * pdc_stable_verify_contents - Checks that Stable Storage contents are valid.&n; *&n; * This PDC call is meant to be used to check the integrity of the current&n; * contents of Stable Storage.&n; */
DECL|function|pdc_stable_verify_contents
r_int
id|pdc_stable_verify_contents
c_func
(paren
r_void
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_STABLE
comma
id|PDC_STABLE_VERIFY_CONTENTS
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|pdc_stable_verify_contents
id|EXPORT_SYMBOL
c_func
(paren
id|pdc_stable_verify_contents
)paren
suffix:semicolon
multiline_comment|/**&n; * pdc_stable_initialize - Sets Stable Storage contents to zero and initialize&n; * the validity indicator.&n; *&n; * This PDC call will erase all contents of Stable Storage. Use with care!&n; */
DECL|function|pdc_stable_initialize
r_int
id|pdc_stable_initialize
c_func
(paren
r_void
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_STABLE
comma
id|PDC_STABLE_INITIALIZE
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|pdc_stable_initialize
id|EXPORT_SYMBOL
c_func
(paren
id|pdc_stable_initialize
)paren
suffix:semicolon
multiline_comment|/**&n; * pdc_get_initiator - Get the SCSI Interface Card params (SCSI ID, SDTR, SE or LVD)&n; * @hwpath: fully bc.mod style path to the device.&n; * @initiator: the array to return the result into&n; *&n; * Get the SCSI operational parameters from PDC.&n; * Needed since HPUX never used BIOS or symbios card NVRAM.&n; * Most ncr/sym cards won&squot;t have an entry and just use whatever&n; * capabilities of the card are (eg Ultra, LVD). But there are&n; * several cases where it&squot;s useful:&n; *    o set SCSI id for Multi-initiator clusters,&n; *    o cable too long (ie SE scsi 10Mhz won&squot;t support 6m length),&n; *    o bus width exported is less than what the interface chip supports.&n; */
DECL|function|pdc_get_initiator
r_int
id|pdc_get_initiator
c_func
(paren
r_struct
id|hardware_path
op_star
id|hwpath
comma
r_struct
id|pdc_initiator
op_star
id|initiator
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
multiline_comment|/* BCJ-XXXX series boxes. E.G. &quot;9000/785/C3000&quot; */
DECL|macro|IS_SPROCKETS
mdefine_line|#define IS_SPROCKETS() (strlen(boot_cpu_data.pdc.sys_model_name) == 14 &amp;&amp; &bslash;&n;&t;strncmp(boot_cpu_data.pdc.sys_model_name, &quot;9000/785&quot;, 8) == 0)
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_INITIATOR
comma
id|PDC_GET_INITIATOR
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
id|__pa
c_func
(paren
id|hwpath
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
id|PDC_OK
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|pdc_result
(braket
l_int|0
)braket
OL
l_int|16
)paren
(brace
id|initiator-&gt;host_id
op_assign
id|pdc_result
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_else
(brace
id|initiator-&gt;host_id
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Sprockets and Piranha return 20 or 40 (MT/s).  Prelude returns&n;&t; * 1, 2, 5 or 10 for 5, 10, 20 or 40 MT/s, respectively&n;&t; */
r_switch
c_cond
(paren
id|pdc_result
(braket
l_int|1
)braket
)paren
(brace
r_case
l_int|1
suffix:colon
id|initiator-&gt;factor
op_assign
l_int|50
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|initiator-&gt;factor
op_assign
l_int|25
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|initiator-&gt;factor
op_assign
l_int|12
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|25
suffix:colon
id|initiator-&gt;factor
op_assign
l_int|10
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|20
suffix:colon
id|initiator-&gt;factor
op_assign
l_int|12
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|40
suffix:colon
id|initiator-&gt;factor
op_assign
l_int|10
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|initiator-&gt;factor
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_SPROCKETS
c_func
(paren
)paren
)paren
(brace
id|initiator-&gt;width
op_assign
id|pdc_result
(braket
l_int|4
)braket
suffix:semicolon
id|initiator-&gt;mode
op_assign
id|pdc_result
(braket
l_int|5
)braket
suffix:semicolon
)brace
r_else
(brace
id|initiator-&gt;width
op_assign
op_minus
l_int|1
suffix:semicolon
id|initiator-&gt;mode
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|out
suffix:colon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
(paren
id|retval
op_ge
id|PDC_OK
)paren
suffix:semicolon
)brace
DECL|variable|pdc_get_initiator
id|EXPORT_SYMBOL
c_func
(paren
id|pdc_get_initiator
)paren
suffix:semicolon
multiline_comment|/**&n; * pdc_pci_irt_size - Get the number of entries in the interrupt routing table.&n; * @num_entries: The return value.&n; * @hpa: The HPA for the device.&n; *&n; * This PDC function returns the number of entries in the specified cell&squot;s&n; * interrupt table.&n; * Similar to PDC_PAT stuff - but added for Forte/Allegro boxes&n; */
DECL|function|pdc_pci_irt_size
r_int
id|pdc_pci_irt_size
c_func
(paren
r_int
r_int
op_star
id|num_entries
comma
r_int
r_int
id|hpa
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_PCI_INDEX
comma
id|PDC_PCI_GET_INT_TBL_SIZE
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
id|hpa
)paren
suffix:semicolon
id|convert_to_wide
c_func
(paren
id|pdc_result
)paren
suffix:semicolon
op_star
id|num_entries
op_assign
id|pdc_result
(braket
l_int|0
)braket
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/** &n; * pdc_pci_irt - Get the PCI interrupt routing table.&n; * @num_entries: The number of entries in the table.&n; * @hpa: The Hard Physical Address of the device.&n; * @tbl: &n; *&n; * Get the PCI interrupt routing table for the device at the given HPA.&n; * Similar to PDC_PAT stuff - but added for Forte/Allegro boxes&n; */
DECL|function|pdc_pci_irt
r_int
id|pdc_pci_irt
c_func
(paren
r_int
r_int
id|num_entries
comma
r_int
r_int
id|hpa
comma
r_void
op_star
id|tbl
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|pdc_result
(braket
l_int|0
)braket
op_assign
id|num_entries
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_PCI_INDEX
comma
id|PDC_PCI_GET_INT_TBL
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
id|hpa
comma
id|__pa
c_func
(paren
id|tbl
)paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
macro_line|#if 0&t;/* UNTEST CODE - left here in case someone needs it */
multiline_comment|/** &n; * pdc_pci_config_read - read PCI config space.&n; * @hpa&t;&t;token from PDC to indicate which PCI device&n; * @pci_addr&t;configuration space address to read from&n; *&n; * Read PCI Configuration space *before* linux PCI subsystem is running.&n; */
r_int
r_int
id|pdc_pci_config_read
c_func
(paren
r_void
op_star
id|hpa
comma
r_int
r_int
id|cfg_addr
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|pdc_result
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|pdc_result
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_PCI_INDEX
comma
id|PDC_PCI_READ_CONFIG
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
id|hpa
comma
id|cfg_addr
op_amp
op_complement
l_int|3UL
comma
l_int|4UL
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
ques
c_cond
op_complement
l_int|0
suffix:colon
(paren
r_int
r_int
)paren
id|pdc_result
(braket
l_int|0
)braket
suffix:semicolon
)brace
multiline_comment|/** &n; * pdc_pci_config_write - read PCI config space.&n; * @hpa&t;&t;token from PDC to indicate which PCI device&n; * @pci_addr&t;configuration space address to write&n; * @val&t;&t;value we want in the 32-bit register&n; *&n; * Write PCI Configuration space *before* linux PCI subsystem is running.&n; */
r_void
id|pdc_pci_config_write
c_func
(paren
r_void
op_star
id|hpa
comma
r_int
r_int
id|cfg_addr
comma
r_int
r_int
id|val
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|pdc_result
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_PCI_INDEX
comma
id|PDC_PCI_WRITE_CONFIG
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
id|hpa
comma
id|cfg_addr
op_amp
op_complement
l_int|3UL
comma
l_int|4UL
comma
(paren
r_int
r_int
)paren
id|val
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
macro_line|#endif /* UNTESTED CODE */
multiline_comment|/**&n; * pdc_tod_read - Read the Time-Of-Day clock.&n; * @tod: The return buffer:&n; *&n; * Read the Time-Of-Day clock&n; */
DECL|function|pdc_tod_read
r_int
id|pdc_tod_read
c_func
(paren
r_struct
id|pdc_tod
op_star
id|tod
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_TOD
comma
id|PDC_TOD_READ
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
l_int|0
)paren
suffix:semicolon
id|convert_to_wide
c_func
(paren
id|pdc_result
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tod
comma
id|pdc_result
comma
r_sizeof
(paren
op_star
id|tod
)paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|pdc_tod_read
id|EXPORT_SYMBOL
c_func
(paren
id|pdc_tod_read
)paren
suffix:semicolon
multiline_comment|/**&n; * pdc_tod_set - Set the Time-Of-Day clock.&n; * @sec: The number of seconds since epoch.&n; * @usec: The number of micro seconds.&n; *&n; * Set the Time-Of-Day clock.&n; */
DECL|function|pdc_tod_set
r_int
id|pdc_tod_set
c_func
(paren
r_int
r_int
id|sec
comma
r_int
r_int
id|usec
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_TOD
comma
id|PDC_TOD_WRITE
comma
id|sec
comma
id|usec
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|pdc_tod_set
id|EXPORT_SYMBOL
c_func
(paren
id|pdc_tod_set
)paren
suffix:semicolon
macro_line|#ifdef __LP64__
DECL|function|pdc_mem_mem_table
r_int
id|pdc_mem_mem_table
c_func
(paren
r_struct
id|pdc_memory_table_raddr
op_star
id|r_addr
comma
r_struct
id|pdc_memory_table
op_star
id|tbl
comma
r_int
r_int
id|entries
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_MEM
comma
id|PDC_MEM_TABLE
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
id|__pa
c_func
(paren
id|pdc_result2
)paren
comma
id|entries
)paren
suffix:semicolon
id|convert_to_wide
c_func
(paren
id|pdc_result
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|r_addr
comma
id|pdc_result
comma
r_sizeof
(paren
op_star
id|r_addr
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tbl
comma
id|pdc_result2
comma
id|entries
op_star
r_sizeof
(paren
op_star
id|tbl
)paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
macro_line|#endif /* __LP64__ */
multiline_comment|/* FIXME: Is this pdc used?  I could not find type reference to ftc_bitmap&n; * so I guessed at unsigned long.  Someone who knows what this does, can fix&n; * it later. :)&n; */
DECL|function|pdc_do_firm_test_reset
r_int
id|pdc_do_firm_test_reset
c_func
(paren
r_int
r_int
id|ftc_bitmap
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_BROADCAST_RESET
comma
id|PDC_DO_FIRM_TEST_RESET
comma
id|PDC_FIRM_TEST_MAGIC
comma
id|ftc_bitmap
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * pdc_do_reset - Reset the system.&n; *&n; * Reset the system.&n; */
DECL|function|pdc_do_reset
r_int
id|pdc_do_reset
c_func
(paren
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_BROADCAST_RESET
comma
id|PDC_DO_RESET
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * pdc_soft_power_info - Enable soft power switch.&n; * @power_reg: address of soft power register&n; *&n; * Return the absolute address of the soft power switch register&n; */
DECL|function|pdc_soft_power_info
r_int
id|__init
id|pdc_soft_power_info
c_func
(paren
r_int
r_int
op_star
id|power_reg
)paren
(brace
r_int
id|retval
suffix:semicolon
op_star
id|power_reg
op_assign
(paren
r_int
r_int
)paren
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_SOFT_POWER
comma
id|PDC_SOFT_POWER_INFO
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|PDC_OK
)paren
(brace
id|convert_to_wide
c_func
(paren
id|pdc_result
)paren
suffix:semicolon
op_star
id|power_reg
op_assign
id|f_extend
c_func
(paren
id|pdc_result
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * pdc_soft_power_button - Control the soft power button behaviour&n; * @sw_control: 0 for hardware control, 1 for software control &n; *&n; *&n; * This PDC function places the soft power button under software or&n; * hardware control.&n; * Under software control the OS may control to when to allow to shut &n; * down the system. Under hardware control pressing the power button &n; * powers off the system immediately.&n; */
DECL|function|pdc_soft_power_button
r_int
id|pdc_soft_power_button
c_func
(paren
r_int
id|sw_control
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_SOFT_POWER
comma
id|PDC_SOFT_POWER_ENABLE
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
id|sw_control
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * pdc_io_reset - Hack to avoid overlapping range registers of Bridges devices.&n; * Primarily a problem on T600 (which parisc-linux doesn&squot;t support) but&n; * who knows what other platform firmware might do with this OS &quot;hook&quot;.&n; */
DECL|function|pdc_io_reset
r_void
id|pdc_io_reset
c_func
(paren
r_void
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|mem_pdc_call
c_func
(paren
id|PDC_IO
comma
id|PDC_IO_RESET
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pdc_io_reset_devices - Hack to Stop USB controller&n; *&n; * If PDC used the usb controller, the usb controller&n; * is still running and will crash the machines during iommu &n; * setup, because of still running DMA. This PDC call&n; * stops the USB controller.&n; * Normally called after calling pdc_io_reset().&n; */
DECL|function|pdc_io_reset_devices
r_void
id|pdc_io_reset_devices
c_func
(paren
r_void
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|mem_pdc_call
c_func
(paren
id|PDC_IO
comma
id|PDC_IO_RESET_DEVICES
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * pdc_iodc_putc - Console character print using IODC.&n; * @c: the character to output.&n; *&n; * Note that only these special chars are architected for console IODC io:&n; * BEL, BS, CR, and LF. Others are passed through.&n; * Since the HP console requires CR+LF to perform a &squot;newline&squot;, we translate&n; * &quot;&bslash;n&quot; to &quot;&bslash;r&bslash;n&quot;.&n; */
DECL|function|pdc_iodc_putc
r_void
id|pdc_iodc_putc
c_func
(paren
r_int
r_char
id|c
)paren
(brace
multiline_comment|/* XXX Should we spinlock posx usage */
r_static
r_int
id|posx
suffix:semicolon
multiline_comment|/* for simple TAB-Simulation... */
r_static
r_int
id|__attribute__
c_func
(paren
(paren
id|aligned
c_func
(paren
l_int|8
)paren
)paren
)paren
id|iodc_retbuf
(braket
l_int|32
)braket
suffix:semicolon
r_static
r_char
id|__attribute__
c_func
(paren
(paren
id|aligned
c_func
(paren
l_int|64
)paren
)paren
)paren
id|iodc_dbuf
(braket
l_int|4096
)braket
suffix:semicolon
r_int
r_int
id|n
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;&bslash;n&squot;
suffix:colon
id|iodc_dbuf
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;r&squot;
suffix:semicolon
id|iodc_dbuf
(braket
l_int|1
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|n
op_assign
l_int|2
suffix:semicolon
id|posx
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;t&squot;
suffix:colon
id|pdc_iodc_putc
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|posx
op_amp
l_int|7
)paren
multiline_comment|/* expand TAB */
id|pdc_iodc_putc
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* return since IODC can&squot;t handle this */
r_case
l_char|&squot;&bslash;b&squot;
suffix:colon
id|posx
op_sub_assign
l_int|2
suffix:semicolon
multiline_comment|/* BS */
r_default
suffix:colon
id|iodc_dbuf
(braket
l_int|0
)braket
op_assign
id|c
suffix:semicolon
id|n
op_assign
l_int|1
suffix:semicolon
id|posx
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pdc_lock
comma
id|flags
)paren
suffix:semicolon
id|real32_call
c_func
(paren
id|PAGE0-&gt;mem_cons.iodc_io
comma
(paren
r_int
r_int
)paren
id|PAGE0-&gt;mem_cons.hpa
comma
id|ENTRY_IO_COUT
comma
id|PAGE0-&gt;mem_cons.spa
comma
id|__pa
c_func
(paren
id|PAGE0-&gt;mem_cons.dp.layers
)paren
comma
id|__pa
c_func
(paren
id|iodc_retbuf
)paren
comma
l_int|0
comma
id|__pa
c_func
(paren
id|iodc_dbuf
)paren
comma
id|n
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pdc_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * pdc_iodc_outc - Console character print using IODC (without conversions).&n; * @c: the character to output.&n; *&n; * Write the character directly to the IODC console.&n; */
DECL|function|pdc_iodc_outc
r_void
id|pdc_iodc_outc
c_func
(paren
r_int
r_char
id|c
)paren
(brace
r_int
r_int
id|n
comma
id|flags
suffix:semicolon
multiline_comment|/* fill buffer with one caracter and print it */
r_static
r_int
id|__attribute__
c_func
(paren
(paren
id|aligned
c_func
(paren
l_int|8
)paren
)paren
)paren
id|iodc_retbuf
(braket
l_int|32
)braket
suffix:semicolon
r_static
r_char
id|__attribute__
c_func
(paren
(paren
id|aligned
c_func
(paren
l_int|64
)paren
)paren
)paren
id|iodc_dbuf
(braket
l_int|4096
)braket
suffix:semicolon
id|n
op_assign
l_int|1
suffix:semicolon
id|iodc_dbuf
(braket
l_int|0
)braket
op_assign
id|c
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pdc_lock
comma
id|flags
)paren
suffix:semicolon
id|real32_call
c_func
(paren
id|PAGE0-&gt;mem_cons.iodc_io
comma
(paren
r_int
r_int
)paren
id|PAGE0-&gt;mem_cons.hpa
comma
id|ENTRY_IO_COUT
comma
id|PAGE0-&gt;mem_cons.spa
comma
id|__pa
c_func
(paren
id|PAGE0-&gt;mem_cons.dp.layers
)paren
comma
id|__pa
c_func
(paren
id|iodc_retbuf
)paren
comma
l_int|0
comma
id|__pa
c_func
(paren
id|iodc_dbuf
)paren
comma
id|n
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pdc_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * pdc_iodc_getc - Read a character (non-blocking) from the PDC console.&n; *&n; * Read a character (non-blocking) from the PDC console, returns -1 if&n; * key is not present.&n; */
DECL|function|pdc_iodc_getc
r_int
id|pdc_iodc_getc
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_static
r_int
id|__attribute__
c_func
(paren
(paren
id|aligned
c_func
(paren
l_int|8
)paren
)paren
)paren
id|iodc_retbuf
(braket
l_int|32
)braket
suffix:semicolon
r_static
r_char
id|__attribute__
c_func
(paren
(paren
id|aligned
c_func
(paren
l_int|64
)paren
)paren
)paren
id|iodc_dbuf
(braket
l_int|4096
)braket
suffix:semicolon
r_int
id|ch
suffix:semicolon
r_int
id|status
suffix:semicolon
multiline_comment|/* Bail if no console input device. */
r_if
c_cond
(paren
op_logical_neg
id|PAGE0-&gt;mem_kbd.iodc_io
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* wait for a keyboard (rs232)-input */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pdc_lock
comma
id|flags
)paren
suffix:semicolon
id|real32_call
c_func
(paren
id|PAGE0-&gt;mem_kbd.iodc_io
comma
(paren
r_int
r_int
)paren
id|PAGE0-&gt;mem_kbd.hpa
comma
id|ENTRY_IO_CIN
comma
id|PAGE0-&gt;mem_kbd.spa
comma
id|__pa
c_func
(paren
id|PAGE0-&gt;mem_kbd.dp.layers
)paren
comma
id|__pa
c_func
(paren
id|iodc_retbuf
)paren
comma
l_int|0
comma
id|__pa
c_func
(paren
id|iodc_dbuf
)paren
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|ch
op_assign
op_star
id|iodc_dbuf
suffix:semicolon
id|status
op_assign
op_star
id|iodc_retbuf
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pdc_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
id|ch
suffix:semicolon
)brace
DECL|function|pdc_sti_call
r_int
id|pdc_sti_call
c_func
(paren
r_int
r_int
id|func
comma
r_int
r_int
id|flags
comma
r_int
r_int
id|inptr
comma
r_int
r_int
id|outputr
comma
r_int
r_int
id|glob_cfg
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|real32_call
c_func
(paren
id|func
comma
id|flags
comma
id|inptr
comma
id|outputr
comma
id|glob_cfg
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|pdc_sti_call
id|EXPORT_SYMBOL
c_func
(paren
id|pdc_sti_call
)paren
suffix:semicolon
macro_line|#ifdef __LP64__
multiline_comment|/**&n; * pdc_pat_cell_get_number - Returns the cell number.&n; * @cell_info: The return buffer.&n; *&n; * This PDC call returns the cell number of the cell from which the call&n; * is made.&n; */
DECL|function|pdc_pat_cell_get_number
r_int
id|pdc_pat_cell_get_number
c_func
(paren
r_struct
id|pdc_pat_cell_num
op_star
id|cell_info
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_PAT_CELL
comma
id|PDC_PAT_CELL_GET_NUMBER
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|cell_info
comma
id|pdc_result
comma
r_sizeof
(paren
op_star
id|cell_info
)paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; * pdc_pat_cell_module - Retrieve the cell&squot;s module information.&n; * @actcnt: The number of bytes written to mem_addr.&n; * @ploc: The physical location.&n; * @mod: The module index.&n; * @view_type: The view of the address type.&n; * @mem_addr: The return buffer.&n; *&n; * This PDC call returns information about each module attached to the cell&n; * at the specified location.&n; */
DECL|function|pdc_pat_cell_module
r_int
id|pdc_pat_cell_module
c_func
(paren
r_int
r_int
op_star
id|actcnt
comma
r_int
r_int
id|ploc
comma
r_int
r_int
id|mod
comma
r_int
r_int
id|view_type
comma
r_void
op_star
id|mem_addr
)paren
(brace
r_int
id|retval
suffix:semicolon
r_static
r_struct
id|pdc_pat_cell_mod_maddr_block
id|result
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|8
)paren
)paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_PAT_CELL
comma
id|PDC_PAT_CELL_MODULE
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
id|ploc
comma
id|mod
comma
id|view_type
comma
id|__pa
c_func
(paren
op_amp
id|result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
(brace
op_star
id|actcnt
op_assign
id|pdc_result
(braket
l_int|0
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|mem_addr
comma
op_amp
id|result
comma
op_star
id|actcnt
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; * pdc_pat_cpu_get_number - Retrieve the cpu number.&n; * @cpu_info: The return buffer.&n; * @hpa: The Hard Physical Address of the CPU.&n; *&n; * Retrieve the cpu number for the cpu at the specified HPA.&n; */
DECL|function|pdc_pat_cpu_get_number
r_int
id|pdc_pat_cpu_get_number
c_func
(paren
r_struct
id|pdc_pat_cpu_num
op_star
id|cpu_info
comma
r_void
op_star
id|hpa
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_PAT_CPU
comma
id|PDC_PAT_CPU_GET_NUMBER
comma
id|__pa
c_func
(paren
op_amp
id|pdc_result
)paren
comma
id|hpa
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|cpu_info
comma
id|pdc_result
comma
r_sizeof
(paren
op_star
id|cpu_info
)paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; * pdc_pat_get_irt_size - Retrieve the number of entries in the cell&squot;s interrupt table.&n; * @num_entries: The return value.&n; * @cell_num: The target cell.&n; *&n; * This PDC function returns the number of entries in the specified cell&squot;s&n; * interrupt table.&n; */
DECL|function|pdc_pat_get_irt_size
r_int
id|pdc_pat_get_irt_size
c_func
(paren
r_int
r_int
op_star
id|num_entries
comma
r_int
r_int
id|cell_num
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_PAT_IO
comma
id|PDC_PAT_IO_GET_PCI_ROUTING_TABLE_SIZE
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
id|cell_num
)paren
suffix:semicolon
op_star
id|num_entries
op_assign
id|pdc_result
(braket
l_int|0
)braket
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; * pdc_pat_get_irt - Retrieve the cell&squot;s interrupt table.&n; * @r_addr: The return buffer.&n; * @cell_num: The target cell.&n; *&n; * This PDC function returns the actual interrupt table for the specified cell.&n; */
DECL|function|pdc_pat_get_irt
r_int
id|pdc_pat_get_irt
c_func
(paren
r_void
op_star
id|r_addr
comma
r_int
r_int
id|cell_num
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_PAT_IO
comma
id|PDC_PAT_IO_GET_PCI_ROUTING_TABLE
comma
id|__pa
c_func
(paren
id|r_addr
)paren
comma
id|cell_num
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; * pdc_pat_pd_get_addr_map - Retrieve information about memory address ranges.&n; * @actlen: The return buffer.&n; * @mem_addr: Pointer to the memory buffer.&n; * @count: The number of bytes to read from the buffer.&n; * @offset: The offset with respect to the beginning of the buffer.&n; *&n; */
DECL|function|pdc_pat_pd_get_addr_map
r_int
id|pdc_pat_pd_get_addr_map
c_func
(paren
r_int
r_int
op_star
id|actual_len
comma
r_void
op_star
id|mem_addr
comma
r_int
r_int
id|count
comma
r_int
r_int
id|offset
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_PAT_PD
comma
id|PDC_PAT_PD_GET_ADDR_MAP
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
id|__pa
c_func
(paren
id|pdc_result2
)paren
comma
id|count
comma
id|offset
)paren
suffix:semicolon
op_star
id|actual_len
op_assign
id|pdc_result
(braket
l_int|0
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|mem_addr
comma
id|pdc_result2
comma
op_star
id|actual_len
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; * pdc_pat_io_pci_cfg_read - Read PCI configuration space.&n; * @pci_addr: PCI configuration space address for which the read request is being made.&n; * @pci_size: Size of read in bytes. Valid values are 1, 2, and 4. &n; * @mem_addr: Pointer to return memory buffer.&n; *&n; */
DECL|function|pdc_pat_io_pci_cfg_read
r_int
id|pdc_pat_io_pci_cfg_read
c_func
(paren
r_int
r_int
id|pci_addr
comma
r_int
id|pci_size
comma
id|u32
op_star
id|mem_addr
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_PAT_IO
comma
id|PDC_PAT_IO_PCI_CONFIG_READ
comma
id|__pa
c_func
(paren
id|pdc_result
)paren
comma
id|pci_addr
comma
id|pci_size
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|pci_size
)paren
(brace
r_case
l_int|1
suffix:colon
op_star
(paren
id|u8
op_star
)paren
id|mem_addr
op_assign
(paren
id|u8
)paren
id|pdc_result
(braket
l_int|0
)braket
suffix:semicolon
r_case
l_int|2
suffix:colon
op_star
(paren
id|u16
op_star
)paren
id|mem_addr
op_assign
(paren
id|u16
)paren
id|pdc_result
(braket
l_int|0
)braket
suffix:semicolon
r_case
l_int|4
suffix:colon
op_star
(paren
id|u32
op_star
)paren
id|mem_addr
op_assign
(paren
id|u32
)paren
id|pdc_result
(braket
l_int|0
)braket
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; * pdc_pat_io_pci_cfg_write - Retrieve information about memory address ranges.&n; * @pci_addr: PCI configuration space address for which the write  request is being made.&n; * @pci_size: Size of write in bytes. Valid values are 1, 2, and 4. &n; * @value: Pointer to 1, 2, or 4 byte value in low order end of argument to be &n; *         written to PCI Config space.&n; *&n; */
DECL|function|pdc_pat_io_pci_cfg_write
r_int
id|pdc_pat_io_pci_cfg_write
c_func
(paren
r_int
r_int
id|pci_addr
comma
r_int
id|pci_size
comma
id|u32
id|val
)paren
(brace
r_int
id|retval
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
id|retval
op_assign
id|mem_pdc_call
c_func
(paren
id|PDC_PAT_IO
comma
id|PDC_PAT_IO_PCI_CONFIG_WRITE
comma
id|pci_addr
comma
id|pci_size
comma
id|val
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pdc_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
macro_line|#endif /* __LP64__ */
multiline_comment|/***************** 32-bit real-mode calls ***********/
multiline_comment|/* The struct below is used&n; * to overlay real_stack (real2.S), preparing a 32-bit call frame.&n; * real32_call_asm() then uses this stack in narrow real mode&n; */
DECL|struct|narrow_stack
r_struct
id|narrow_stack
(brace
multiline_comment|/* use int, not long which is 64 bits */
DECL|member|arg13
r_int
r_int
id|arg13
suffix:semicolon
DECL|member|arg12
r_int
r_int
id|arg12
suffix:semicolon
DECL|member|arg11
r_int
r_int
id|arg11
suffix:semicolon
DECL|member|arg10
r_int
r_int
id|arg10
suffix:semicolon
DECL|member|arg9
r_int
r_int
id|arg9
suffix:semicolon
DECL|member|arg8
r_int
r_int
id|arg8
suffix:semicolon
DECL|member|arg7
r_int
r_int
id|arg7
suffix:semicolon
DECL|member|arg6
r_int
r_int
id|arg6
suffix:semicolon
DECL|member|arg5
r_int
r_int
id|arg5
suffix:semicolon
DECL|member|arg4
r_int
r_int
id|arg4
suffix:semicolon
DECL|member|arg3
r_int
r_int
id|arg3
suffix:semicolon
DECL|member|arg2
r_int
r_int
id|arg2
suffix:semicolon
DECL|member|arg1
r_int
r_int
id|arg1
suffix:semicolon
DECL|member|arg0
r_int
r_int
id|arg0
suffix:semicolon
DECL|member|frame_marker
r_int
r_int
id|frame_marker
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|sp
r_int
r_int
id|sp
suffix:semicolon
multiline_comment|/* in reality, there&squot;s nearly 8k of stack after this */
)brace
suffix:semicolon
DECL|function|real32_call
r_int
id|real32_call
c_func
(paren
r_int
r_int
id|fn
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_extern
r_struct
id|narrow_stack
id|real_stack
suffix:semicolon
r_extern
r_int
r_int
id|real32_call_asm
c_func
(paren
r_int
r_int
op_star
comma
r_int
r_int
op_star
comma
r_int
r_int
)paren
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fn
)paren
suffix:semicolon
id|real_stack.arg0
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real_stack.arg1
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real_stack.arg2
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real_stack.arg3
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real_stack.arg4
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real_stack.arg5
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real_stack.arg6
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real_stack.arg7
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real_stack.arg8
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real_stack.arg9
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real_stack.arg10
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real_stack.arg11
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real_stack.arg12
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real_stack.arg13
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
r_return
id|real32_call_asm
c_func
(paren
op_amp
id|real_stack.sp
comma
op_amp
id|real_stack.arg0
comma
id|fn
)paren
suffix:semicolon
)brace
macro_line|#ifdef __LP64__
multiline_comment|/***************** 64-bit real-mode calls ***********/
DECL|struct|wide_stack
r_struct
id|wide_stack
(brace
DECL|member|arg0
r_int
r_int
id|arg0
suffix:semicolon
DECL|member|arg1
r_int
r_int
id|arg1
suffix:semicolon
DECL|member|arg2
r_int
r_int
id|arg2
suffix:semicolon
DECL|member|arg3
r_int
r_int
id|arg3
suffix:semicolon
DECL|member|arg4
r_int
r_int
id|arg4
suffix:semicolon
DECL|member|arg5
r_int
r_int
id|arg5
suffix:semicolon
DECL|member|arg6
r_int
r_int
id|arg6
suffix:semicolon
DECL|member|arg7
r_int
r_int
id|arg7
suffix:semicolon
DECL|member|arg8
r_int
r_int
id|arg8
suffix:semicolon
DECL|member|arg9
r_int
r_int
id|arg9
suffix:semicolon
DECL|member|arg10
r_int
r_int
id|arg10
suffix:semicolon
DECL|member|arg11
r_int
r_int
id|arg11
suffix:semicolon
DECL|member|arg12
r_int
r_int
id|arg12
suffix:semicolon
DECL|member|arg13
r_int
r_int
id|arg13
suffix:semicolon
DECL|member|frame_marker
r_int
r_int
id|frame_marker
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* rp, previous sp */
DECL|member|sp
r_int
r_int
id|sp
suffix:semicolon
multiline_comment|/* in reality, there&squot;s nearly 8k of stack after this */
)brace
suffix:semicolon
DECL|function|real64_call
r_int
id|real64_call
c_func
(paren
r_int
r_int
id|fn
comma
dot
dot
dot
)paren
(brace
id|va_list
id|args
suffix:semicolon
r_extern
r_struct
id|wide_stack
id|real64_stack
suffix:semicolon
r_extern
r_int
r_int
id|real64_call_asm
c_func
(paren
r_int
r_int
op_star
comma
r_int
r_int
op_star
comma
r_int
r_int
)paren
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fn
)paren
suffix:semicolon
id|real64_stack.arg0
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real64_stack.arg1
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real64_stack.arg2
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real64_stack.arg3
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real64_stack.arg4
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real64_stack.arg5
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real64_stack.arg6
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real64_stack.arg7
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real64_stack.arg8
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real64_stack.arg9
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real64_stack.arg10
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real64_stack.arg11
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real64_stack.arg12
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|real64_stack.arg13
op_assign
id|va_arg
c_func
(paren
id|args
comma
r_int
r_int
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
r_return
id|real64_call_asm
c_func
(paren
op_amp
id|real64_stack.sp
comma
op_amp
id|real64_stack.arg0
comma
id|fn
)paren
suffix:semicolon
)brace
macro_line|#endif /* __LP64__ */
eof
