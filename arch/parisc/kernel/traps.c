multiline_comment|/*&n; *  linux/arch/parisc/traps.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; *  Copyright (C) 1999, 2000  Philipp Rumpf &lt;prumpf@tux.org&gt;&n; */
multiline_comment|/*&n; * &squot;Traps.c&squot; handles hardware traps and faults after we have saved some&n; * state in &squot;asm.s&squot;.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;linux/kallsyms.h&gt;
macro_line|#include &lt;asm/assembly.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/traps.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/pdc.h&gt;
macro_line|#include &lt;asm/pdc_chassis.h&gt;
macro_line|#include &lt;asm/unwind.h&gt;
macro_line|#include &quot;../math-emu/math-emu.h&quot;&t;/* for handle_fpe() */
DECL|macro|PRINT_USER_FAULTS
mdefine_line|#define PRINT_USER_FAULTS /* (turn this on if you want user faults to be */
multiline_comment|/*  dumped to the console via printk)          */
macro_line|#if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)
DECL|variable|pa_dbit_lock
id|DEFINE_SPINLOCK
c_func
(paren
id|pa_dbit_lock
)paren
suffix:semicolon
macro_line|#endif
DECL|function|printbinary
r_int
id|printbinary
c_func
(paren
r_char
op_star
id|buf
comma
r_int
r_int
id|x
comma
r_int
id|nbits
)paren
(brace
r_int
r_int
id|mask
op_assign
l_int|1UL
op_lshift
(paren
id|nbits
op_minus
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|mask
op_ne
l_int|0
)paren
(brace
op_star
id|buf
op_increment
op_assign
(paren
id|mask
op_amp
id|x
ques
c_cond
l_char|&squot;1&squot;
suffix:colon
l_char|&squot;0&squot;
)paren
suffix:semicolon
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
op_star
id|buf
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
id|nbits
suffix:semicolon
)brace
macro_line|#ifdef __LP64__
DECL|macro|RFMT
mdefine_line|#define RFMT &quot;%016lx&quot;
macro_line|#else
DECL|macro|RFMT
mdefine_line|#define RFMT &quot;%08lx&quot;
macro_line|#endif
DECL|function|show_regs
r_void
id|show_regs
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
id|buf
(braket
l_int|128
)braket
comma
op_star
id|p
suffix:semicolon
r_char
op_star
id|level
suffix:semicolon
r_int
r_int
id|cr30
suffix:semicolon
r_int
r_int
id|cr31
suffix:semicolon
id|level
op_assign
id|user_mode
c_func
(paren
id|regs
)paren
ques
c_cond
id|KERN_DEBUG
suffix:colon
id|KERN_CRIT
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|level
)paren
suffix:semicolon
multiline_comment|/* don&squot;t want to have that pretty register dump messed up */
id|printk
c_func
(paren
l_string|&quot;%s     YZrvWESTHLNXBCVMcbcbcbcbOGFRQPDI&bslash;n&quot;
comma
id|level
)paren
suffix:semicolon
id|printbinary
c_func
(paren
id|buf
comma
id|regs-&gt;gr
(braket
l_int|0
)braket
comma
l_int|32
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%sPSW: %s %s&bslash;n&quot;
comma
id|level
comma
id|buf
comma
id|print_tainted
c_func
(paren
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_add_assign
l_int|4
)paren
(brace
r_int
id|j
suffix:semicolon
id|p
op_assign
id|buf
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%sr%02d-%02d &quot;
comma
id|level
comma
id|i
comma
id|i
op_plus
l_int|3
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|4
suffix:semicolon
id|j
op_increment
)paren
(brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot; &quot;
id|RFMT
comma
(paren
id|i
op_plus
id|j
)paren
op_eq
l_int|0
ques
c_cond
l_int|0
suffix:colon
id|regs-&gt;gr
(braket
id|i
op_plus
id|j
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_add_assign
l_int|4
)paren
(brace
r_int
id|j
suffix:semicolon
id|p
op_assign
id|buf
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%ssr%d-%d  &quot;
comma
id|level
comma
id|i
comma
id|i
op_plus
l_int|3
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|4
suffix:semicolon
id|j
op_increment
)paren
(brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot; &quot;
id|RFMT
comma
id|regs-&gt;sr
(braket
id|i
op_plus
id|j
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
)brace
macro_line|#if RIDICULOUSLY_VERBOSE
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot;%sFR%02d : %016lx  FR%2d : %016lx&quot;
comma
id|level
comma
id|i
comma
id|regs-&gt;fr
(braket
id|i
)braket
comma
id|i
op_plus
l_int|1
comma
id|regs-&gt;fr
(braket
id|i
op_plus
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
id|cr30
op_assign
id|mfctl
c_func
(paren
l_int|30
)paren
suffix:semicolon
id|cr31
op_assign
id|mfctl
c_func
(paren
l_int|31
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|level
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%sIASQ: &quot;
id|RFMT
l_string|&quot; &quot;
id|RFMT
l_string|&quot; IAOQ: &quot;
id|RFMT
l_string|&quot; &quot;
id|RFMT
l_string|&quot;&bslash;n&quot;
comma
id|level
comma
id|regs-&gt;iasq
(braket
l_int|0
)braket
comma
id|regs-&gt;iasq
(braket
l_int|1
)braket
comma
id|regs-&gt;iaoq
(braket
l_int|0
)braket
comma
id|regs-&gt;iaoq
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s IIR: %08lx    ISR: &quot;
id|RFMT
l_string|&quot;  IOR: &quot;
id|RFMT
l_string|&quot;&bslash;n&quot;
comma
id|level
comma
id|regs-&gt;iir
comma
id|regs-&gt;isr
comma
id|regs-&gt;ior
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s CPU: %8d   CR30: &quot;
id|RFMT
l_string|&quot; CR31: &quot;
id|RFMT
l_string|&quot;&bslash;n&quot;
comma
id|level
comma
id|current_thread_info
c_func
(paren
)paren
op_member_access_from_pointer
id|cpu
comma
id|cr30
comma
id|cr31
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s ORIG_R28: &quot;
id|RFMT
l_string|&quot;&bslash;n&quot;
comma
id|level
comma
id|regs-&gt;orig_r28
)paren
suffix:semicolon
id|printk
c_func
(paren
id|level
)paren
suffix:semicolon
id|print_symbol
c_func
(paren
l_string|&quot; IAOQ[0]: %s&bslash;n&quot;
comma
id|regs-&gt;iaoq
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
id|level
)paren
suffix:semicolon
id|print_symbol
c_func
(paren
l_string|&quot; IAOQ[1]: %s&bslash;n&quot;
comma
id|regs-&gt;iaoq
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
id|level
)paren
suffix:semicolon
id|print_symbol
c_func
(paren
l_string|&quot; RP(r2): %s&bslash;n&quot;
comma
id|regs-&gt;gr
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
DECL|function|dump_stack
r_void
id|dump_stack
c_func
(paren
r_void
)paren
(brace
id|show_stack
c_func
(paren
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|variable|dump_stack
id|EXPORT_SYMBOL
c_func
(paren
id|dump_stack
)paren
suffix:semicolon
DECL|function|do_show_stack
r_static
r_void
id|do_show_stack
c_func
(paren
r_struct
id|unwind_frame_info
op_star
id|info
)paren
(brace
r_int
id|i
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Backtrace:&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|i
op_le
l_int|16
)paren
(brace
r_if
c_cond
(paren
id|unwind_once
c_func
(paren
id|info
)paren
OL
l_int|0
op_logical_or
id|info-&gt;ip
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|__kernel_text_address
c_func
(paren
id|info-&gt;ip
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; [&lt;&quot;
id|RFMT
l_string|&quot;&gt;] &quot;
comma
id|info-&gt;ip
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_KALLSYMS
id|print_symbol
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|info-&gt;ip
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
(paren
id|i
op_amp
l_int|0x03
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|i
op_increment
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|show_stack
r_void
id|show_stack
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
r_int
op_star
id|s
)paren
(brace
r_struct
id|unwind_frame_info
id|info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|task
)paren
(brace
r_int
r_int
id|sp
comma
id|ip
comma
id|rp
suffix:semicolon
id|HERE
suffix:colon
id|asm
r_volatile
(paren
l_string|&quot;copy %%r30, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|sp
)paren
)paren
suffix:semicolon
id|ip
op_assign
(paren
r_int
r_int
)paren
op_logical_and
id|HERE
suffix:semicolon
id|rp
op_assign
(paren
r_int
r_int
)paren
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|unwind_frame_init
c_func
(paren
op_amp
id|info
comma
id|current
comma
id|sp
comma
id|ip
comma
id|rp
)paren
suffix:semicolon
)brace
r_else
(brace
id|unwind_frame_init_from_blocked_task
c_func
(paren
op_amp
id|info
comma
id|task
)paren
suffix:semicolon
)brace
id|do_show_stack
c_func
(paren
op_amp
id|info
)paren
suffix:semicolon
)brace
DECL|function|die_if_kernel
r_void
id|die_if_kernel
c_func
(paren
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
r_if
c_cond
(paren
id|err
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* STFU */
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s (pid %d): %s (code %ld) at &quot;
id|RFMT
l_string|&quot;&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
id|str
comma
id|err
comma
id|regs-&gt;iaoq
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#ifdef PRINT_USER_FAULTS
multiline_comment|/* XXX for debugging only */
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
id|oops_in_progress
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Amuse the user in a SPARC fashion */
id|printk
c_func
(paren
l_string|&quot;      _______________________________ &bslash;n&quot;
l_string|&quot;     &lt; Your System ate a SPARC! Gah! &gt;&bslash;n&quot;
l_string|&quot;      ------------------------------- &bslash;n&quot;
l_string|&quot;             &bslash;&bslash;   ^__^&bslash;n&quot;
l_string|&quot;              &bslash;&bslash;  (xx)&bslash;&bslash;_______&bslash;n&quot;
l_string|&quot;                 (__)&bslash;&bslash;       )&bslash;&bslash;/&bslash;&bslash;&bslash;n&quot;
l_string|&quot;                  U  ||----w |&bslash;n&quot;
l_string|&quot;                     ||     ||&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* unlock the pdc lock if necessary */
id|pdc_emergency_unlock
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* maybe the kernel hasn&squot;t booted very far yet and hasn&squot;t been able &n;&t; * to initialize the serial or STI console. In that case we should &n;&t; * re-enable the pdc console, so that the user will be able to &n;&t; * identify the problem. */
r_if
c_cond
(paren
op_logical_neg
id|console_drivers
)paren
id|pdc_console_restart
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s (pid %d): %s (code %ld)&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
id|str
comma
id|err
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
multiline_comment|/* Wot&squot;s wrong wif bein&squot; racy? */
r_if
c_cond
(paren
id|current-&gt;thread.flags
op_amp
id|PARISC_KERNEL_DEATH
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s() recursion detected.&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|current-&gt;thread.flags
op_or_assign
id|PARISC_KERNEL_DEATH
suffix:semicolon
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
)brace
DECL|function|syscall_ipi
r_int
id|syscall_ipi
c_func
(paren
r_int
(paren
op_star
id|syscall
)paren
(paren
r_struct
id|pt_regs
op_star
)paren
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_return
id|syscall
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/* gdb uses break 4,8 */
DECL|macro|GDB_BREAK_INSN
mdefine_line|#define GDB_BREAK_INSN 0x10004
DECL|function|handle_gdb_break
r_void
id|handle_gdb_break
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|wot
)paren
(brace
r_struct
id|siginfo
id|si
suffix:semicolon
id|si.si_code
op_assign
id|wot
suffix:semicolon
id|si.si_addr
op_assign
(paren
r_void
op_star
)paren
(paren
id|regs-&gt;iaoq
(braket
l_int|0
)braket
op_amp
op_complement
l_int|3
)paren
suffix:semicolon
id|si.si_signo
op_assign
id|SIGTRAP
suffix:semicolon
id|si.si_errno
op_assign
l_int|0
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGTRAP
comma
op_amp
id|si
comma
id|current
)paren
suffix:semicolon
)brace
DECL|function|handle_break
r_void
id|handle_break
c_func
(paren
r_int
id|iir
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|siginfo
id|si
suffix:semicolon
r_switch
c_cond
(paren
id|iir
)paren
(brace
r_case
l_int|0x00
suffix:colon
macro_line|#ifdef PRINT_USER_FAULTS
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;break 0,0: pid=%d command=&squot;%s&squot;&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|current-&gt;comm
)paren
suffix:semicolon
macro_line|#endif
id|die_if_kernel
c_func
(paren
l_string|&quot;Breakpoint&quot;
comma
id|regs
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef PRINT_USER_FAULTS
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
macro_line|#endif
id|si.si_code
op_assign
id|TRAP_BRKPT
suffix:semicolon
id|si.si_addr
op_assign
(paren
r_void
op_star
)paren
(paren
id|regs-&gt;iaoq
(braket
l_int|0
)braket
op_amp
op_complement
l_int|3
)paren
suffix:semicolon
id|si.si_signo
op_assign
id|SIGTRAP
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGTRAP
comma
op_amp
id|si
comma
id|current
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GDB_BREAK_INSN
suffix:colon
id|die_if_kernel
c_func
(paren
l_string|&quot;Breakpoint&quot;
comma
id|regs
comma
l_int|0
)paren
suffix:semicolon
id|handle_gdb_break
c_func
(paren
id|regs
comma
id|TRAP_BRKPT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
macro_line|#ifdef PRINT_USER_FAULTS
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;break %#08x: pid=%d command=&squot;%s&squot;&bslash;n&quot;
comma
id|iir
comma
id|current-&gt;pid
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
macro_line|#endif
id|si.si_signo
op_assign
id|SIGTRAP
suffix:semicolon
id|si.si_code
op_assign
id|TRAP_BRKPT
suffix:semicolon
id|si.si_addr
op_assign
(paren
r_void
op_star
)paren
(paren
id|regs-&gt;iaoq
(braket
l_int|0
)braket
op_amp
op_complement
l_int|3
)paren
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGTRAP
comma
op_amp
id|si
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
DECL|function|handle_toc
r_int
id|handle_toc
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;TOC call.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|default_trap
r_static
r_void
id|default_trap
c_func
(paren
r_int
id|code
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Trap %d on CPU %d&bslash;n&quot;
comma
id|code
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
DECL|variable|cpu_lpmc
r_void
(paren
op_star
id|cpu_lpmc
)paren
(paren
r_int
id|code
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
op_assign
id|default_trap
suffix:semicolon
DECL|function|transfer_pim_to_trap_frame
r_void
id|transfer_pim_to_trap_frame
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_register
r_int
id|i
suffix:semicolon
r_extern
r_int
r_int
id|hpmc_pim_data
(braket
)braket
suffix:semicolon
r_struct
id|pdc_hpmc_pim_11
op_star
id|pim_narrow
suffix:semicolon
r_struct
id|pdc_hpmc_pim_20
op_star
id|pim_wide
suffix:semicolon
r_if
c_cond
(paren
id|boot_cpu_data.cpu_type
op_ge
id|pcxu
)paren
(brace
id|pim_wide
op_assign
(paren
r_struct
id|pdc_hpmc_pim_20
op_star
)paren
id|hpmc_pim_data
suffix:semicolon
multiline_comment|/*&n;&t; * Note: The following code will probably generate a&n;&t; * bunch of truncation error warnings from the compiler.&n;&t; * Could be handled with an ifdef, but perhaps there&n;&t; * is a better way.&n;&t; */
id|regs-&gt;gr
(braket
l_int|0
)braket
op_assign
id|pim_wide-&gt;cr
(braket
l_int|22
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
id|regs-&gt;gr
(braket
id|i
)braket
op_assign
id|pim_wide-&gt;gr
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
id|regs-&gt;fr
(braket
id|i
)braket
op_assign
id|pim_wide-&gt;fr
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|regs-&gt;sr
(braket
id|i
)braket
op_assign
id|pim_wide-&gt;sr
(braket
id|i
)braket
suffix:semicolon
id|regs-&gt;iasq
(braket
l_int|0
)braket
op_assign
id|pim_wide-&gt;cr
(braket
l_int|17
)braket
suffix:semicolon
id|regs-&gt;iasq
(braket
l_int|1
)braket
op_assign
id|pim_wide-&gt;iasq_back
suffix:semicolon
id|regs-&gt;iaoq
(braket
l_int|0
)braket
op_assign
id|pim_wide-&gt;cr
(braket
l_int|18
)braket
suffix:semicolon
id|regs-&gt;iaoq
(braket
l_int|1
)braket
op_assign
id|pim_wide-&gt;iaoq_back
suffix:semicolon
id|regs-&gt;sar
op_assign
id|pim_wide-&gt;cr
(braket
l_int|11
)braket
suffix:semicolon
id|regs-&gt;iir
op_assign
id|pim_wide-&gt;cr
(braket
l_int|19
)braket
suffix:semicolon
id|regs-&gt;isr
op_assign
id|pim_wide-&gt;cr
(braket
l_int|20
)braket
suffix:semicolon
id|regs-&gt;ior
op_assign
id|pim_wide-&gt;cr
(braket
l_int|21
)braket
suffix:semicolon
)brace
r_else
(brace
id|pim_narrow
op_assign
(paren
r_struct
id|pdc_hpmc_pim_11
op_star
)paren
id|hpmc_pim_data
suffix:semicolon
id|regs-&gt;gr
(braket
l_int|0
)braket
op_assign
id|pim_narrow-&gt;cr
(braket
l_int|22
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
id|regs-&gt;gr
(braket
id|i
)braket
op_assign
id|pim_narrow-&gt;gr
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
id|regs-&gt;fr
(braket
id|i
)braket
op_assign
id|pim_narrow-&gt;fr
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|regs-&gt;sr
(braket
id|i
)braket
op_assign
id|pim_narrow-&gt;sr
(braket
id|i
)braket
suffix:semicolon
id|regs-&gt;iasq
(braket
l_int|0
)braket
op_assign
id|pim_narrow-&gt;cr
(braket
l_int|17
)braket
suffix:semicolon
id|regs-&gt;iasq
(braket
l_int|1
)braket
op_assign
id|pim_narrow-&gt;iasq_back
suffix:semicolon
id|regs-&gt;iaoq
(braket
l_int|0
)braket
op_assign
id|pim_narrow-&gt;cr
(braket
l_int|18
)braket
suffix:semicolon
id|regs-&gt;iaoq
(braket
l_int|1
)braket
op_assign
id|pim_narrow-&gt;iaoq_back
suffix:semicolon
id|regs-&gt;sar
op_assign
id|pim_narrow-&gt;cr
(braket
l_int|11
)braket
suffix:semicolon
id|regs-&gt;iir
op_assign
id|pim_narrow-&gt;cr
(braket
l_int|19
)braket
suffix:semicolon
id|regs-&gt;isr
op_assign
id|pim_narrow-&gt;cr
(braket
l_int|20
)braket
suffix:semicolon
id|regs-&gt;ior
op_assign
id|pim_narrow-&gt;cr
(braket
l_int|21
)braket
suffix:semicolon
)brace
multiline_comment|/*&n;     * The following fields only have meaning if we came through&n;     * another path. So just zero them here.&n;     */
id|regs-&gt;ksp
op_assign
l_int|0
suffix:semicolon
id|regs-&gt;kpc
op_assign
l_int|0
suffix:semicolon
id|regs-&gt;orig_r28
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called as a last resort when everything else&n; * has gone clearly wrong. We get called for faults in kernel space,&n; * and HPMC&squot;s.&n; */
DECL|function|parisc_terminate
r_void
id|parisc_terminate
c_func
(paren
r_char
op_star
id|msg
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|code
comma
r_int
r_int
id|offset
)paren
(brace
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|terminate_lock
)paren
suffix:semicolon
id|oops_in_progress
op_assign
l_int|1
suffix:semicolon
id|set_eiem
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|terminate_lock
)paren
suffix:semicolon
multiline_comment|/* unlock the pdc lock if necessary */
id|pdc_emergency_unlock
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* restart pdc console if necessary */
r_if
c_cond
(paren
op_logical_neg
id|console_drivers
)paren
id|pdc_console_restart
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Not all paths will gutter the processor... */
r_switch
c_cond
(paren
id|code
)paren
(brace
r_case
l_int|1
suffix:colon
id|transfer_pim_to_trap_frame
c_func
(paren
id|regs
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Fall through */
r_break
suffix:semicolon
)brace
(brace
multiline_comment|/* show_stack(NULL, (unsigned long *)regs-&gt;gr[30]); */
r_struct
id|unwind_frame_info
id|info
suffix:semicolon
id|unwind_frame_init
c_func
(paren
op_amp
id|info
comma
id|current
comma
id|regs-&gt;gr
(braket
l_int|30
)braket
comma
id|regs-&gt;iaoq
(braket
l_int|0
)braket
comma
id|regs-&gt;gr
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|do_show_stack
c_func
(paren
op_amp
id|info
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s: Code=%d regs=%p (Addr=&quot;
id|RFMT
l_string|&quot;)&bslash;n&quot;
comma
id|msg
comma
id|code
comma
id|regs
comma
id|offset
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|terminate_lock
)paren
suffix:semicolon
multiline_comment|/* put soft power button back under hardware control;&n;&t; * if the user had pressed it once at any time, the &n;&t; * system will shut down immediately right here. */
id|pdc_soft_power_button
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Call kernel panic() so reboot timeouts work properly &n;&t; * FIXME: This function should be on the list of&n;&t; * panic notifiers, and we should call panic&n;&t; * directly from the location that we wish. &n;&t; * e.g. We should not call panic from&n;&t; * parisc_terminate, but rather the oter way around.&n;&t; * This hack works, prints the panic message twice,&n;&t; * and it enables reboot timers!&n;&t; */
id|panic
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
DECL|function|handle_interruption
r_void
id|handle_interruption
c_func
(paren
r_int
id|code
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|fault_address
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|fault_space
op_assign
l_int|0
suffix:semicolon
r_struct
id|siginfo
id|si
suffix:semicolon
r_if
c_cond
(paren
id|code
op_eq
l_int|1
)paren
id|pdc_console_restart
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* switch back to pdc if HPMC */
r_else
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Security check:&n;&t; * If the priority level is still user, and the&n;&t; * faulting space is not equal to the active space&n;&t; * then the user is attempting something in a space&n;&t; * that does not belong to them. Kill the process.&n;&t; *&n;&t; * This is normally the situation when the user&n;&t; * attempts to jump into the kernel space at the&n;&t; * wrong offset, be it at the gateway page or a&n;&t; * random location.&n;&t; *&n;&t; * We cannot normally signal the process because it&n;&t; * could *be* on the gateway page, and processes&n;&t; * executing on the gateway page can&squot;t have signals&n;&t; * delivered.&n;&t; * &n;&t; * We merely readjust the address into the users&n;&t; * space, at a destination address of zero, and&n;&t; * allow processing to continue.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|regs-&gt;iaoq
(braket
l_int|0
)braket
op_amp
l_int|3
)paren
op_logical_and
(paren
(paren
r_int
r_int
)paren
id|regs-&gt;iasq
(braket
l_int|0
)braket
op_ne
(paren
r_int
r_int
)paren
id|regs-&gt;sr
(braket
l_int|7
)braket
)paren
)paren
(brace
multiline_comment|/* Kill the user process later */
id|regs-&gt;iaoq
(braket
l_int|0
)braket
op_assign
l_int|0
op_or
l_int|3
suffix:semicolon
id|regs-&gt;iaoq
(braket
l_int|1
)braket
op_assign
id|regs-&gt;iaoq
(braket
l_int|0
)braket
op_plus
l_int|4
suffix:semicolon
id|regs-&gt;iasq
(braket
l_int|0
)braket
op_assign
id|regs-&gt;iasq
(braket
l_int|0
)braket
op_assign
id|regs-&gt;sr
(braket
l_int|7
)braket
suffix:semicolon
id|regs-&gt;gr
(braket
l_int|0
)braket
op_and_assign
op_complement
id|PSW_B
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Interruption # %d&bslash;n&quot;
comma
id|code
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|code
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* High-priority machine check (HPMC) */
multiline_comment|/* set up a new led state on systems shipped with a LED State panel */
id|pdc_chassis_send_status
c_func
(paren
id|PDC_CHASSIS_DIRECT_HPMC
)paren
suffix:semicolon
id|parisc_terminate
c_func
(paren
l_string|&quot;High Priority Machine Check (HPMC)&quot;
comma
id|regs
comma
id|code
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* NOT REACHED */
r_case
l_int|2
suffix:colon
multiline_comment|/* Power failure interrupt */
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Power failure interrupt !&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* Recovery counter trap */
id|regs-&gt;gr
(braket
l_int|0
)braket
op_and_assign
op_complement
id|PSW_R
suffix:semicolon
r_if
c_cond
(paren
id|user_space
c_func
(paren
id|regs
)paren
)paren
id|handle_gdb_break
c_func
(paren
id|regs
comma
id|TRAP_TRACE
)paren
suffix:semicolon
multiline_comment|/* else this must be the start of a syscall - just let it run */
r_return
suffix:semicolon
r_case
l_int|5
suffix:colon
multiline_comment|/* Low-priority machine check */
id|pdc_chassis_send_status
c_func
(paren
id|PDC_CHASSIS_DIRECT_LPMC
)paren
suffix:semicolon
id|flush_all_caches
c_func
(paren
)paren
suffix:semicolon
id|cpu_lpmc
c_func
(paren
l_int|5
comma
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|6
suffix:colon
multiline_comment|/* Instruction TLB miss fault/Instruction page fault */
id|fault_address
op_assign
id|regs-&gt;iaoq
(braket
l_int|0
)braket
suffix:semicolon
id|fault_space
op_assign
id|regs-&gt;iasq
(braket
l_int|0
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
multiline_comment|/* Illegal instruction trap */
id|die_if_kernel
c_func
(paren
l_string|&quot;Illegal instruction&quot;
comma
id|regs
comma
id|code
)paren
suffix:semicolon
id|si.si_code
op_assign
id|ILL_ILLOPC
suffix:semicolon
r_goto
id|give_sigill
suffix:semicolon
r_case
l_int|9
suffix:colon
multiline_comment|/* Break instruction trap */
id|handle_break
c_func
(paren
id|regs-&gt;iir
comma
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|10
suffix:colon
multiline_comment|/* Privileged operation trap */
id|die_if_kernel
c_func
(paren
l_string|&quot;Privileged operation&quot;
comma
id|regs
comma
id|code
)paren
suffix:semicolon
id|si.si_code
op_assign
id|ILL_PRVOPC
suffix:semicolon
r_goto
id|give_sigill
suffix:semicolon
r_case
l_int|11
suffix:colon
multiline_comment|/* Privileged register trap */
r_if
c_cond
(paren
(paren
id|regs-&gt;iir
op_amp
l_int|0xffdfffe0
)paren
op_eq
l_int|0x034008a0
)paren
(brace
multiline_comment|/* This is a MFCTL cr26/cr27 to gr instruction.&n;&t;&t;&t; * PCXS traps on this, so we need to emulate it.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|regs-&gt;iir
op_amp
l_int|0x00200000
)paren
id|regs-&gt;gr
(braket
id|regs-&gt;iir
op_amp
l_int|0x1f
)braket
op_assign
id|mfctl
c_func
(paren
l_int|27
)paren
suffix:semicolon
r_else
id|regs-&gt;gr
(braket
id|regs-&gt;iir
op_amp
l_int|0x1f
)braket
op_assign
id|mfctl
c_func
(paren
l_int|26
)paren
suffix:semicolon
id|regs-&gt;iaoq
(braket
l_int|0
)braket
op_assign
id|regs-&gt;iaoq
(braket
l_int|1
)braket
suffix:semicolon
id|regs-&gt;iaoq
(braket
l_int|1
)braket
op_add_assign
l_int|4
suffix:semicolon
id|regs-&gt;iasq
(braket
l_int|0
)braket
op_assign
id|regs-&gt;iasq
(braket
l_int|1
)braket
suffix:semicolon
r_return
suffix:semicolon
)brace
id|die_if_kernel
c_func
(paren
l_string|&quot;Privileged register usage&quot;
comma
id|regs
comma
id|code
)paren
suffix:semicolon
id|si.si_code
op_assign
id|ILL_PRVREG
suffix:semicolon
id|give_sigill
suffix:colon
id|si.si_signo
op_assign
id|SIGILL
suffix:semicolon
id|si.si_errno
op_assign
l_int|0
suffix:semicolon
id|si.si_addr
op_assign
(paren
r_void
op_star
)paren
id|regs-&gt;iaoq
(braket
l_int|0
)braket
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGILL
comma
op_amp
id|si
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|12
suffix:colon
multiline_comment|/* Overflow Trap, let the userland signal handler do the cleanup */
id|si.si_signo
op_assign
id|SIGFPE
suffix:semicolon
id|si.si_code
op_assign
id|FPE_INTOVF
suffix:semicolon
id|si.si_addr
op_assign
(paren
r_void
op_star
)paren
id|regs-&gt;iaoq
(braket
l_int|0
)braket
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGFPE
comma
op_amp
id|si
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|13
suffix:colon
multiline_comment|/* Conditional Trap&n;&t;&t;   The condition succees in an instruction which traps &n;&t;&t;   on condition  */
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
id|si.si_signo
op_assign
id|SIGFPE
suffix:semicolon
multiline_comment|/* Set to zero, and let the userspace app figure it out from&n;&t;&t;   &t;   the insn pointed to by si_addr */
id|si.si_code
op_assign
l_int|0
suffix:semicolon
id|si.si_addr
op_assign
(paren
r_void
id|__user
op_star
)paren
id|regs-&gt;iaoq
(braket
l_int|0
)braket
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGFPE
comma
op_amp
id|si
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* The kernel doesn&squot;t want to handle condition codes */
r_break
suffix:semicolon
r_case
l_int|14
suffix:colon
multiline_comment|/* Assist Exception Trap, i.e. floating point exception. */
id|die_if_kernel
c_func
(paren
l_string|&quot;Floating point exception&quot;
comma
id|regs
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* quiet */
id|handle_fpe
c_func
(paren
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|15
suffix:colon
multiline_comment|/* Data TLB miss fault/Data page fault */
multiline_comment|/* Fall through */
r_case
l_int|16
suffix:colon
multiline_comment|/* Non-access instruction TLB miss fault */
multiline_comment|/* The instruction TLB entry needed for the target address of the FIC&n;&t;&t;   is absent, and hardware can&squot;t find it, so we get to cleanup */
multiline_comment|/* Fall through */
r_case
l_int|17
suffix:colon
multiline_comment|/* Non-access data TLB miss fault/Non-access data page fault */
multiline_comment|/* FIXME: &n;&t;&t; &t; Still need to add slow path emulation code here!&n;&t;&t;         If the insn used a non-shadow register, then the tlb&n;&t;&t;&t; handlers could not have their side-effect (e.g. probe&n;&t;&t;&t; writing to a target register) emulated since rfir would&n;&t;&t;&t; erase the changes to said register. Instead we have to&n;&t;&t;&t; setup everything, call this function we are in, and emulate&n;&t;&t;&t; by hand. Technically we need to emulate:&n;&t;&t;&t; fdc,fdce,pdc,&quot;fic,4f&quot;,prober,probeir,probew, probeiw&n;&t;&t;*/
id|fault_address
op_assign
id|regs-&gt;ior
suffix:semicolon
id|fault_space
op_assign
id|regs-&gt;isr
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|18
suffix:colon
multiline_comment|/* PCXS only -- later cpu&squot;s split this into types 26,27 &amp; 28 */
multiline_comment|/* Check for unaligned access */
r_if
c_cond
(paren
id|check_unaligned
c_func
(paren
id|regs
)paren
)paren
(brace
id|handle_unaligned
c_func
(paren
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Fall Through */
r_case
l_int|26
suffix:colon
multiline_comment|/* PCXL: Data memory access rights trap */
id|fault_address
op_assign
id|regs-&gt;ior
suffix:semicolon
id|fault_space
op_assign
id|regs-&gt;isr
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|19
suffix:colon
multiline_comment|/* Data memory break trap */
id|regs-&gt;gr
(braket
l_int|0
)braket
op_or_assign
id|PSW_X
suffix:semicolon
multiline_comment|/* So we can single-step over the trap */
multiline_comment|/* fall thru */
r_case
l_int|21
suffix:colon
multiline_comment|/* Page reference trap */
id|handle_gdb_break
c_func
(paren
id|regs
comma
id|TRAP_HWBKPT
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|25
suffix:colon
multiline_comment|/* Taken branch trap */
id|regs-&gt;gr
(braket
l_int|0
)braket
op_and_assign
op_complement
id|PSW_T
suffix:semicolon
r_if
c_cond
(paren
id|user_space
c_func
(paren
id|regs
)paren
)paren
id|handle_gdb_break
c_func
(paren
id|regs
comma
id|TRAP_BRANCH
)paren
suffix:semicolon
multiline_comment|/* else this must be the start of a syscall - just let it&n;&t;&t; * run.&n;&t;&t; */
r_return
suffix:semicolon
r_case
l_int|7
suffix:colon
multiline_comment|/* Instruction access rights */
multiline_comment|/* PCXL: Instruction memory protection trap */
multiline_comment|/*&n;&t;&t; * This could be caused by either: 1) a process attempting&n;&t;&t; * to execute within a vma that does not have execute&n;&t;&t; * permission, or 2) an access rights violation caused by a&n;&t;&t; * flush only translation set up by ptep_get_and_clear().&n;&t;&t; * So we check the vma permissions to differentiate the two.&n;&t;&t; * If the vma indicates we have execute permission, then&n;&t;&t; * the cause is the latter one. In this case, we need to&n;&t;&t; * call do_page_fault() to fix the problem.&n;&t;&t; */
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|vma
op_assign
id|find_vma
c_func
(paren
id|current-&gt;mm
comma
id|regs-&gt;iaoq
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vma
op_logical_and
(paren
id|regs-&gt;iaoq
(braket
l_int|0
)braket
op_ge
id|vma-&gt;vm_start
)paren
op_logical_and
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
)paren
)paren
(brace
id|fault_address
op_assign
id|regs-&gt;iaoq
(braket
l_int|0
)braket
suffix:semicolon
id|fault_space
op_assign
id|regs-&gt;iasq
(braket
l_int|0
)braket
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* call do_page_fault() */
)brace
id|up_read
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
)brace
multiline_comment|/* Fall Through */
r_case
l_int|27
suffix:colon
multiline_comment|/* Data memory protection ID trap */
id|die_if_kernel
c_func
(paren
l_string|&quot;Protection id trap&quot;
comma
id|regs
comma
id|code
)paren
suffix:semicolon
id|si.si_code
op_assign
id|SEGV_MAPERR
suffix:semicolon
id|si.si_signo
op_assign
id|SIGSEGV
suffix:semicolon
id|si.si_errno
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|code
op_eq
l_int|7
)paren
id|si.si_addr
op_assign
(paren
r_void
op_star
)paren
id|regs-&gt;iaoq
(braket
l_int|0
)braket
suffix:semicolon
r_else
id|si.si_addr
op_assign
(paren
r_void
op_star
)paren
id|regs-&gt;ior
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGSEGV
comma
op_amp
id|si
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|28
suffix:colon
multiline_comment|/* Unaligned data reference trap */
id|handle_unaligned
c_func
(paren
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
macro_line|#ifdef PRINT_USER_FAULTS
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;nhandle_interruption() pid=%d command=&squot;%s&squot;&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* SIGBUS, for lack of a better one. */
id|si.si_signo
op_assign
id|SIGBUS
suffix:semicolon
id|si.si_code
op_assign
id|BUS_OBJERR
suffix:semicolon
id|si.si_errno
op_assign
l_int|0
suffix:semicolon
id|si.si_addr
op_assign
(paren
r_void
op_star
)paren
id|regs-&gt;ior
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGBUS
comma
op_amp
id|si
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pdc_chassis_send_status
c_func
(paren
id|PDC_CHASSIS_DIRECT_PANIC
)paren
suffix:semicolon
id|parisc_terminate
c_func
(paren
l_string|&quot;Unexpected interruption&quot;
comma
id|regs
comma
id|code
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* NOT REACHED */
)brace
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|fault_space
op_rshift
id|SPACEID_SHIFT
)paren
op_ne
(paren
id|regs-&gt;sr
(braket
l_int|7
)braket
op_rshift
id|SPACEID_SHIFT
)paren
)paren
(brace
macro_line|#ifdef PRINT_USER_FAULTS
r_if
c_cond
(paren
id|fault_space
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;User Fault on Kernel Space &quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;User Fault (long pointer) (fault %d) &quot;
comma
id|code
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pid=%d command=&squot;%s&squot;&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
macro_line|#endif
id|si.si_signo
op_assign
id|SIGSEGV
suffix:semicolon
id|si.si_errno
op_assign
l_int|0
suffix:semicolon
id|si.si_code
op_assign
id|SEGV_MAPERR
suffix:semicolon
id|si.si_addr
op_assign
(paren
r_void
op_star
)paren
id|regs-&gt;ior
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGSEGV
comma
op_amp
id|si
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;     * The kernel should never fault on its own address space.&n;&t;     */
r_if
c_cond
(paren
id|fault_space
op_eq
l_int|0
)paren
(brace
id|pdc_chassis_send_status
c_func
(paren
id|PDC_CHASSIS_DIRECT_PANIC
)paren
suffix:semicolon
id|parisc_terminate
c_func
(paren
l_string|&quot;Kernel Fault&quot;
comma
id|regs
comma
id|code
comma
id|fault_address
)paren
suffix:semicolon
)brace
)brace
id|do_page_fault
c_func
(paren
id|regs
comma
id|code
comma
id|fault_address
)paren
suffix:semicolon
)brace
DECL|function|check_ivt
r_int
id|__init
id|check_ivt
c_func
(paren
r_void
op_star
id|iva
)paren
(brace
r_int
id|i
suffix:semicolon
id|u32
id|check
op_assign
l_int|0
suffix:semicolon
id|u32
op_star
id|ivap
suffix:semicolon
id|u32
op_star
id|hpmcp
suffix:semicolon
id|u32
id|length
suffix:semicolon
r_extern
r_void
id|os_hpmc
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|os_hpmc_end
c_func
(paren
r_void
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
(paren
r_char
op_star
)paren
id|iva
comma
l_string|&quot;cows can fly&quot;
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|ivap
op_assign
(paren
id|u32
op_star
)paren
id|iva
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
op_star
id|ivap
op_increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Compute Checksum for HPMC handler */
id|length
op_assign
(paren
id|u32
)paren
(paren
(paren
r_int
r_int
)paren
id|os_hpmc_end
op_minus
(paren
r_int
r_int
)paren
id|os_hpmc
)paren
suffix:semicolon
id|ivap
(braket
l_int|7
)braket
op_assign
id|length
suffix:semicolon
id|hpmcp
op_assign
(paren
id|u32
op_star
)paren
id|os_hpmc
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|length
op_div
l_int|4
suffix:semicolon
id|i
op_increment
)paren
id|check
op_add_assign
op_star
id|hpmcp
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|check
op_add_assign
id|ivap
(braket
id|i
)braket
suffix:semicolon
id|ivap
(braket
l_int|5
)braket
op_assign
op_minus
id|check
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifndef __LP64__
r_extern
r_const
r_void
id|fault_vector_11
suffix:semicolon
macro_line|#endif
r_extern
r_const
r_void
id|fault_vector_20
suffix:semicolon
DECL|function|trap_init
r_void
id|__init
id|trap_init
c_func
(paren
r_void
)paren
(brace
r_void
op_star
id|iva
suffix:semicolon
r_if
c_cond
(paren
id|boot_cpu_data.cpu_type
op_ge
id|pcxu
)paren
id|iva
op_assign
(paren
r_void
op_star
)paren
op_amp
id|fault_vector_20
suffix:semicolon
r_else
macro_line|#ifdef __LP64__
id|panic
c_func
(paren
l_string|&quot;Can&squot;t boot 64-bit OS on PA1.1 processor!&quot;
)paren
suffix:semicolon
macro_line|#else
id|iva
op_assign
(paren
r_void
op_star
)paren
op_amp
id|fault_vector_11
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|check_ivt
c_func
(paren
id|iva
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;IVT invalid&quot;
)paren
suffix:semicolon
)brace
eof
