multiline_comment|/*&n; *  linux/arch/parisc/mm/init.c&n; *&n; *  Copyright (C) 1995&t;Linus Torvalds&n; *  Copyright 1999 SuSE GmbH&n; *    changed by Philipp Rumpf&n; *  Copyright 1999 Philipp Rumpf (prumpf@tux.org)&n; *  Copyright 2004 Randolph Chung (tausq@debian.org)&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/pci.h&gt;&t;&t;/* for hppa_dma_ops and pcxl_dma_ops */
macro_line|#include &lt;linux/initrd.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/tlb.h&gt;
macro_line|#include &lt;asm/pdc_chassis.h&gt;
macro_line|#include &lt;asm/mmzone.h&gt;
id|DEFINE_PER_CPU
c_func
(paren
r_struct
id|mmu_gather
comma
id|mmu_gathers
)paren
suffix:semicolon
r_extern
r_char
id|_text
suffix:semicolon
multiline_comment|/* start of kernel code, defined by linker */
r_extern
r_int
id|data_start
suffix:semicolon
r_extern
r_char
id|_end
suffix:semicolon
multiline_comment|/* end of BSS, defined by linker */
r_extern
r_char
id|__init_begin
comma
id|__init_end
suffix:semicolon
macro_line|#ifdef CONFIG_DISCONTIGMEM
DECL|variable|node_data
r_struct
id|node_map_data
id|node_data
(braket
id|MAX_NUMNODES
)braket
suffix:semicolon
DECL|variable|bmem_data
id|bootmem_data_t
id|bmem_data
(braket
id|MAX_NUMNODES
)braket
suffix:semicolon
DECL|variable|pfnnid_map
r_int
r_char
id|pfnnid_map
(braket
id|PFNNID_MAP_MAX
)braket
suffix:semicolon
macro_line|#endif
DECL|variable|data_resource
r_static
r_struct
id|resource
id|data_resource
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;Kernel data&quot;
comma
dot
id|flags
op_assign
id|IORESOURCE_BUSY
op_or
id|IORESOURCE_MEM
comma
)brace
suffix:semicolon
DECL|variable|code_resource
r_static
r_struct
id|resource
id|code_resource
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;Kernel code&quot;
comma
dot
id|flags
op_assign
id|IORESOURCE_BUSY
op_or
id|IORESOURCE_MEM
comma
)brace
suffix:semicolon
DECL|variable|pdcdata_resource
r_static
r_struct
id|resource
id|pdcdata_resource
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;PDC data (Page Zero)&quot;
comma
dot
id|start
op_assign
l_int|0
comma
dot
id|end
op_assign
l_int|0x9ff
comma
dot
id|flags
op_assign
id|IORESOURCE_BUSY
op_or
id|IORESOURCE_MEM
comma
)brace
suffix:semicolon
DECL|variable|sysram_resources
r_static
r_struct
id|resource
id|sysram_resources
(braket
id|MAX_PHYSMEM_RANGES
)braket
suffix:semicolon
DECL|variable|max_pfn
r_static
r_int
r_int
id|max_pfn
suffix:semicolon
multiline_comment|/* The following array is initialized from the firmware specific&n; * information retrieved in kernel/inventory.c.&n; */
DECL|variable|pmem_ranges
id|physmem_range_t
id|pmem_ranges
(braket
id|MAX_PHYSMEM_RANGES
)braket
suffix:semicolon
DECL|variable|npmem_ranges
r_int
id|npmem_ranges
suffix:semicolon
macro_line|#ifdef __LP64__
DECL|macro|MAX_MEM
mdefine_line|#define MAX_MEM         (~0UL)
macro_line|#else /* !__LP64__ */
DECL|macro|MAX_MEM
mdefine_line|#define MAX_MEM         (3584U*1024U*1024U)
macro_line|#endif /* !__LP64__ */
DECL|variable|mem_limit
r_static
r_int
r_int
id|mem_limit
op_assign
id|MAX_MEM
suffix:semicolon
DECL|function|mem_limit_func
r_static
r_void
id|__init
id|mem_limit_func
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|cp
comma
op_star
id|end
suffix:semicolon
r_int
r_int
id|limit
suffix:semicolon
r_extern
r_char
id|saved_command_line
(braket
)braket
suffix:semicolon
multiline_comment|/* We need this before __setup() functions are called */
id|limit
op_assign
id|MAX_MEM
suffix:semicolon
r_for
c_loop
(paren
id|cp
op_assign
id|saved_command_line
suffix:semicolon
op_star
id|cp
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|cp
comma
l_string|&quot;mem=&quot;
comma
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
id|cp
op_add_assign
l_int|4
suffix:semicolon
id|limit
op_assign
id|memparse
c_func
(paren
id|cp
comma
op_amp
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
op_ne
id|cp
)paren
r_break
suffix:semicolon
id|cp
op_assign
id|end
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
op_star
id|cp
op_ne
l_char|&squot; &squot;
op_logical_and
op_star
id|cp
)paren
op_increment
id|cp
suffix:semicolon
r_while
c_loop
(paren
op_star
id|cp
op_eq
l_char|&squot; &squot;
)paren
op_increment
id|cp
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|limit
OL
id|mem_limit
)paren
id|mem_limit
op_assign
id|limit
suffix:semicolon
)brace
DECL|macro|MAX_GAP
mdefine_line|#define MAX_GAP (0x40000000UL &gt;&gt; PAGE_SHIFT)
DECL|function|setup_bootmem
r_static
r_void
id|__init
id|setup_bootmem
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|bootmap_size
suffix:semicolon
r_int
r_int
id|mem_max
suffix:semicolon
r_int
r_int
id|bootmap_pages
suffix:semicolon
r_int
r_int
id|bootmap_start_pfn
suffix:semicolon
r_int
r_int
id|bootmap_pfn
suffix:semicolon
macro_line|#ifndef CONFIG_DISCONTIGMEM
id|physmem_range_t
id|pmem_holes
(braket
id|MAX_PHYSMEM_RANGES
op_minus
l_int|1
)braket
suffix:semicolon
r_int
id|npmem_holes
suffix:semicolon
macro_line|#endif
r_int
id|i
comma
id|sysram_resource_count
suffix:semicolon
id|disable_sr_hashing
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Turn off space register hashing */
multiline_comment|/*&n;&t; * Sort the ranges. Since the number of ranges is typically&n;&t; * small, and performance is not an issue here, just do&n;&t; * a simple insertion sort.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|npmem_ranges
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|i
suffix:semicolon
id|j
OG
l_int|0
suffix:semicolon
id|j
op_decrement
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|pmem_ranges
(braket
id|j
op_minus
l_int|1
)braket
dot
id|start_pfn
OL
id|pmem_ranges
(braket
id|j
)braket
dot
id|start_pfn
)paren
(brace
r_break
suffix:semicolon
)brace
id|tmp
op_assign
id|pmem_ranges
(braket
id|j
op_minus
l_int|1
)braket
dot
id|start_pfn
suffix:semicolon
id|pmem_ranges
(braket
id|j
op_minus
l_int|1
)braket
dot
id|start_pfn
op_assign
id|pmem_ranges
(braket
id|j
)braket
dot
id|start_pfn
suffix:semicolon
id|pmem_ranges
(braket
id|j
)braket
dot
id|start_pfn
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
id|pmem_ranges
(braket
id|j
op_minus
l_int|1
)braket
dot
id|pages
suffix:semicolon
id|pmem_ranges
(braket
id|j
op_minus
l_int|1
)braket
dot
id|pages
op_assign
id|pmem_ranges
(braket
id|j
)braket
dot
id|pages
suffix:semicolon
id|pmem_ranges
(braket
id|j
)braket
dot
id|pages
op_assign
id|tmp
suffix:semicolon
)brace
)brace
macro_line|#ifndef CONFIG_DISCONTIGMEM
multiline_comment|/*&n;&t; * Throw out ranges that are too far apart (controlled by&n;&t; * MAX_GAP).&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|npmem_ranges
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pmem_ranges
(braket
id|i
)braket
dot
id|start_pfn
op_minus
(paren
id|pmem_ranges
(braket
id|i
op_minus
l_int|1
)braket
dot
id|start_pfn
op_plus
id|pmem_ranges
(braket
id|i
op_minus
l_int|1
)braket
dot
id|pages
)paren
OG
id|MAX_GAP
)paren
(brace
id|npmem_ranges
op_assign
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Large gap in memory detected (%ld pages). &quot;
l_string|&quot;Consider turning on CONFIG_DISCONTIGMEM&bslash;n&quot;
comma
id|pmem_ranges
(braket
id|i
)braket
dot
id|start_pfn
op_minus
(paren
id|pmem_ranges
(braket
id|i
op_minus
l_int|1
)braket
dot
id|start_pfn
op_plus
id|pmem_ranges
(braket
id|i
op_minus
l_int|1
)braket
dot
id|pages
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|npmem_ranges
OG
l_int|1
)paren
(brace
multiline_comment|/* Print the memory ranges */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Memory Ranges:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|npmem_ranges
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|start
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
id|size
op_assign
(paren
id|pmem_ranges
(braket
id|i
)braket
dot
id|pages
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|start
op_assign
(paren
id|pmem_ranges
(braket
id|i
)braket
dot
id|start_pfn
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%2d) Start 0x%016lx End 0x%016lx Size %6ld Mb&bslash;n&quot;
comma
id|i
comma
id|start
comma
id|start
op_plus
(paren
id|size
op_minus
l_int|1
)paren
comma
id|size
op_rshift
l_int|20
)paren
suffix:semicolon
)brace
)brace
id|sysram_resource_count
op_assign
id|npmem_ranges
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sysram_resource_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|resource
op_star
id|res
op_assign
op_amp
id|sysram_resources
(braket
id|i
)braket
suffix:semicolon
id|res-&gt;name
op_assign
l_string|&quot;System RAM&quot;
suffix:semicolon
id|res-&gt;start
op_assign
id|pmem_ranges
(braket
id|i
)braket
dot
id|start_pfn
op_lshift
id|PAGE_SHIFT
suffix:semicolon
id|res-&gt;end
op_assign
id|res-&gt;start
op_plus
(paren
id|pmem_ranges
(braket
id|i
)braket
dot
id|pages
op_lshift
id|PAGE_SHIFT
)paren
op_minus
l_int|1
suffix:semicolon
id|res-&gt;flags
op_assign
id|IORESOURCE_MEM
op_or
id|IORESOURCE_BUSY
suffix:semicolon
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
id|res
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * For 32 bit kernels we limit the amount of memory we can&n;&t; * support, in order to preserve enough kernel address space&n;&t; * for other purposes. For 64 bit kernels we don&squot;t normally&n;&t; * limit the memory, but this mechanism can be used to&n;&t; * artificially limit the amount of memory (and it is written&n;&t; * to work with multiple memory ranges).&n;&t; */
id|mem_limit_func
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* check for &quot;mem=&quot; argument */
id|mem_max
op_assign
l_int|0
suffix:semicolon
id|num_physpages
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|npmem_ranges
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|rsize
suffix:semicolon
id|rsize
op_assign
id|pmem_ranges
(braket
id|i
)braket
dot
id|pages
op_lshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mem_max
op_plus
id|rsize
)paren
OG
id|mem_limit
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Memory truncated to %ld Mb&bslash;n&quot;
comma
id|mem_limit
op_rshift
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mem_max
op_eq
id|mem_limit
)paren
id|npmem_ranges
op_assign
id|i
suffix:semicolon
r_else
(brace
id|pmem_ranges
(braket
id|i
)braket
dot
id|pages
op_assign
(paren
id|mem_limit
op_rshift
id|PAGE_SHIFT
)paren
op_minus
(paren
id|mem_max
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|npmem_ranges
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
id|mem_max
op_assign
id|mem_limit
suffix:semicolon
)brace
id|num_physpages
op_add_assign
id|pmem_ranges
(braket
id|i
)braket
dot
id|pages
suffix:semicolon
r_break
suffix:semicolon
)brace
id|num_physpages
op_add_assign
id|pmem_ranges
(braket
id|i
)braket
dot
id|pages
suffix:semicolon
id|mem_max
op_add_assign
id|rsize
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Total Memory: %ld Mb&bslash;n&quot;
comma
id|mem_max
op_rshift
l_int|20
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_DISCONTIGMEM
multiline_comment|/* Merge the ranges, keeping track of the holes */
(brace
r_int
r_int
id|end_pfn
suffix:semicolon
r_int
r_int
id|hole_pages
suffix:semicolon
id|npmem_holes
op_assign
l_int|0
suffix:semicolon
id|end_pfn
op_assign
id|pmem_ranges
(braket
l_int|0
)braket
dot
id|start_pfn
op_plus
id|pmem_ranges
(braket
l_int|0
)braket
dot
id|pages
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|npmem_ranges
suffix:semicolon
id|i
op_increment
)paren
(brace
id|hole_pages
op_assign
id|pmem_ranges
(braket
id|i
)braket
dot
id|start_pfn
op_minus
id|end_pfn
suffix:semicolon
r_if
c_cond
(paren
id|hole_pages
)paren
(brace
id|pmem_holes
(braket
id|npmem_holes
)braket
dot
id|start_pfn
op_assign
id|end_pfn
suffix:semicolon
id|pmem_holes
(braket
id|npmem_holes
op_increment
)braket
dot
id|pages
op_assign
id|hole_pages
suffix:semicolon
id|end_pfn
op_add_assign
id|hole_pages
suffix:semicolon
)brace
id|end_pfn
op_add_assign
id|pmem_ranges
(braket
id|i
)braket
dot
id|pages
suffix:semicolon
)brace
id|pmem_ranges
(braket
l_int|0
)braket
dot
id|pages
op_assign
id|end_pfn
op_minus
id|pmem_ranges
(braket
l_int|0
)braket
dot
id|start_pfn
suffix:semicolon
id|npmem_ranges
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif
id|bootmap_pages
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|npmem_ranges
suffix:semicolon
id|i
op_increment
)paren
id|bootmap_pages
op_add_assign
id|bootmem_bootmap_pages
c_func
(paren
id|pmem_ranges
(braket
id|i
)braket
dot
id|pages
)paren
suffix:semicolon
id|bootmap_start_pfn
op_assign
id|PAGE_ALIGN
c_func
(paren
id|__pa
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|_end
)paren
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
macro_line|#ifdef CONFIG_DISCONTIGMEM
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_PHYSMEM_RANGES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|memset
c_func
(paren
id|NODE_DATA
c_func
(paren
id|i
)paren
comma
l_int|0
comma
r_sizeof
(paren
id|pg_data_t
)paren
)paren
suffix:semicolon
id|NODE_DATA
c_func
(paren
id|i
)paren
op_member_access_from_pointer
id|bdata
op_assign
op_amp
id|bmem_data
(braket
id|i
)braket
suffix:semicolon
)brace
id|memset
c_func
(paren
id|pfnnid_map
comma
l_int|0xff
comma
r_sizeof
(paren
id|pfnnid_map
)paren
)paren
suffix:semicolon
id|numnodes
op_assign
id|npmem_ranges
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|npmem_ranges
suffix:semicolon
id|i
op_increment
)paren
id|node_set_online
c_func
(paren
id|i
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Initialize and free the full range of memory in each range.&n;&t; * Note that the only writing these routines do are to the bootmap,&n;&t; * and we&squot;ve made sure to locate the bootmap properly so that they&n;&t; * won&squot;t be writing over anything important.&n;&t; */
id|bootmap_pfn
op_assign
id|bootmap_start_pfn
suffix:semicolon
id|max_pfn
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|npmem_ranges
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|start_pfn
suffix:semicolon
r_int
r_int
id|npages
suffix:semicolon
id|start_pfn
op_assign
id|pmem_ranges
(braket
id|i
)braket
dot
id|start_pfn
suffix:semicolon
id|npages
op_assign
id|pmem_ranges
(braket
id|i
)braket
dot
id|pages
suffix:semicolon
id|bootmap_size
op_assign
id|init_bootmem_node
c_func
(paren
id|NODE_DATA
c_func
(paren
id|i
)paren
comma
id|bootmap_pfn
comma
id|start_pfn
comma
(paren
id|start_pfn
op_plus
id|npages
)paren
)paren
suffix:semicolon
id|free_bootmem_node
c_func
(paren
id|NODE_DATA
c_func
(paren
id|i
)paren
comma
(paren
id|start_pfn
op_lshift
id|PAGE_SHIFT
)paren
comma
(paren
id|npages
op_lshift
id|PAGE_SHIFT
)paren
)paren
suffix:semicolon
id|bootmap_pfn
op_add_assign
(paren
id|bootmap_size
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|start_pfn
op_plus
id|npages
)paren
OG
id|max_pfn
)paren
id|max_pfn
op_assign
id|start_pfn
op_plus
id|npages
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bootmap_pfn
op_minus
id|bootmap_start_pfn
)paren
op_ne
id|bootmap_pages
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;WARNING! bootmap sizing is messed up!&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* reserve PAGE0 pdc memory, kernel text/data/bss &amp; bootmap */
DECL|macro|PDC_CONSOLE_IO_IODC_SIZE
mdefine_line|#define PDC_CONSOLE_IO_IODC_SIZE 32768
id|reserve_bootmem_node
c_func
(paren
id|NODE_DATA
c_func
(paren
l_int|0
)paren
comma
l_int|0UL
comma
(paren
r_int
r_int
)paren
(paren
id|PAGE0-&gt;mem_free
op_plus
id|PDC_CONSOLE_IO_IODC_SIZE
)paren
)paren
suffix:semicolon
id|reserve_bootmem_node
c_func
(paren
id|NODE_DATA
c_func
(paren
l_int|0
)paren
comma
id|__pa
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|_text
)paren
comma
(paren
r_int
r_int
)paren
(paren
op_amp
id|_end
op_minus
op_amp
id|_text
)paren
)paren
suffix:semicolon
id|reserve_bootmem_node
c_func
(paren
id|NODE_DATA
c_func
(paren
l_int|0
)paren
comma
(paren
id|bootmap_start_pfn
op_lshift
id|PAGE_SHIFT
)paren
comma
(paren
(paren
id|bootmap_pfn
op_minus
id|bootmap_start_pfn
)paren
op_lshift
id|PAGE_SHIFT
)paren
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_DISCONTIGMEM
multiline_comment|/* reserve the holes */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|npmem_holes
suffix:semicolon
id|i
op_increment
)paren
(brace
id|reserve_bootmem_node
c_func
(paren
id|NODE_DATA
c_func
(paren
l_int|0
)paren
comma
(paren
id|pmem_holes
(braket
id|i
)braket
dot
id|start_pfn
op_lshift
id|PAGE_SHIFT
)paren
comma
(paren
id|pmem_holes
(braket
id|i
)braket
dot
id|pages
op_lshift
id|PAGE_SHIFT
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_if
c_cond
(paren
id|initrd_start
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;initrd: %08lx-%08lx&bslash;n&quot;
comma
id|initrd_start
comma
id|initrd_end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__pa
c_func
(paren
id|initrd_start
)paren
OL
id|mem_max
)paren
(brace
r_int
r_int
id|initrd_reserve
suffix:semicolon
r_if
c_cond
(paren
id|__pa
c_func
(paren
id|initrd_end
)paren
OG
id|mem_max
)paren
(brace
id|initrd_reserve
op_assign
id|mem_max
op_minus
id|__pa
c_func
(paren
id|initrd_start
)paren
suffix:semicolon
)brace
r_else
(brace
id|initrd_reserve
op_assign
id|initrd_end
op_minus
id|initrd_start
suffix:semicolon
)brace
id|initrd_below_start_ok
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;initrd: reserving %08lx-%08lx (mem_max %08lx)&bslash;n&quot;
comma
id|__pa
c_func
(paren
id|initrd_start
)paren
comma
id|__pa
c_func
(paren
id|initrd_start
)paren
op_plus
id|initrd_reserve
comma
id|mem_max
)paren
suffix:semicolon
id|reserve_bootmem_node
c_func
(paren
id|NODE_DATA
c_func
(paren
l_int|0
)paren
comma
id|__pa
c_func
(paren
id|initrd_start
)paren
comma
id|initrd_reserve
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
id|data_resource.start
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|data_start
)paren
suffix:semicolon
id|data_resource.end
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|_end
)paren
op_minus
l_int|1
suffix:semicolon
id|code_resource.start
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|_text
)paren
suffix:semicolon
id|code_resource.end
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|data_start
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* We don&squot;t know which region the kernel will be in, so try&n;&t; * all of them.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sysram_resource_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|resource
op_star
id|res
op_assign
op_amp
id|sysram_resources
(braket
id|i
)braket
suffix:semicolon
id|request_resource
c_func
(paren
id|res
comma
op_amp
id|code_resource
)paren
suffix:semicolon
id|request_resource
c_func
(paren
id|res
comma
op_amp
id|data_resource
)paren
suffix:semicolon
)brace
id|request_resource
c_func
(paren
op_amp
id|sysram_resources
(braket
l_int|0
)braket
comma
op_amp
id|pdcdata_resource
)paren
suffix:semicolon
)brace
DECL|function|free_initmem
r_void
id|free_initmem
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* FIXME: */
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;NOT FREEING INITMEM (%dk)&bslash;n&quot;
comma
(paren
op_amp
id|__init_end
op_minus
op_amp
id|__init_begin
)paren
op_rshift
l_int|10
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#else
r_int
r_int
id|addr
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Freeing unused kernel memory: &quot;
)paren
suffix:semicolon
macro_line|#if 1
multiline_comment|/* Attempt to catch anyone trying to execute code here&n;&t; * by filling the page with BRK insns.&n;&t; * &n;&t; * If we disable interrupts for all CPUs, then IPI stops working.&n;&t; * Kinda breaks the global cache flushing.&n;&t; */
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|__init_begin
comma
l_int|0x00
comma
(paren
r_int
r_int
)paren
op_amp
id|__init_end
op_minus
(paren
r_int
r_int
)paren
op_amp
id|__init_begin
)paren
suffix:semicolon
id|flush_data_cache
c_func
(paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;sync&quot;
suffix:colon
suffix:colon
)paren
suffix:semicolon
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|__init_begin
comma
(paren
r_int
r_int
)paren
op_amp
id|__init_end
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;sync&quot;
suffix:colon
suffix:colon
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|addr
op_assign
(paren
r_int
r_int
)paren
(paren
op_amp
id|__init_begin
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|addr
OL
(paren
r_int
r_int
)paren
(paren
op_amp
id|__init_end
)paren
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
)paren
(brace
id|ClearPageReserved
c_func
(paren
id|virt_to_page
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
id|set_page_count
c_func
(paren
id|virt_to_page
c_func
(paren
id|addr
)paren
comma
l_int|1
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|addr
)paren
suffix:semicolon
id|num_physpages
op_increment
suffix:semicolon
id|totalram_pages
op_increment
suffix:semicolon
)brace
multiline_comment|/* set up a new led state on systems shipped LED State panel */
id|pdc_chassis_send_status
c_func
(paren
id|PDC_CHASSIS_DIRECT_BCOMPLETE
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%luk freed&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
(paren
op_amp
id|__init_end
op_minus
op_amp
id|__init_begin
)paren
op_rshift
l_int|10
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Just an arbitrary offset to serve as a &quot;hole&quot; between mapping areas&n; * (between top of physical memory and a potential pcxl dma mapping&n; * area, and below the vmalloc mapping area).&n; *&n; * The current 32K value just means that there will be a 32K &quot;hole&quot;&n; * between mapping areas. That means that  any out-of-bounds memory&n; * accesses will hopefully be caught. The vmalloc() routines leaves&n; * a hole of 4kB between each vmalloced area for the same reason.&n; */
multiline_comment|/* Leave room for gateway page expansion */
macro_line|#if KERNEL_MAP_START &lt; GATEWAY_PAGE_SIZE
macro_line|#error KERNEL_MAP_START is in gateway reserved region
macro_line|#endif
DECL|macro|MAP_START
mdefine_line|#define MAP_START (KERNEL_MAP_START)
DECL|macro|VM_MAP_OFFSET
mdefine_line|#define VM_MAP_OFFSET  (32*1024)
DECL|macro|SET_MAP_OFFSET
mdefine_line|#define SET_MAP_OFFSET(x) ((void *)(((unsigned long)(x) + VM_MAP_OFFSET) &bslash;&n;&t;&t;&t;&t;     &amp; ~(VM_MAP_OFFSET-1)))
DECL|variable|vmalloc_start
r_void
op_star
id|vmalloc_start
suffix:semicolon
DECL|variable|vmalloc_start
id|EXPORT_SYMBOL
c_func
(paren
id|vmalloc_start
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PA11
DECL|variable|pcxl_dma_start
r_int
r_int
id|pcxl_dma_start
suffix:semicolon
macro_line|#endif
DECL|function|mem_init
r_void
id|__init
id|mem_init
c_func
(paren
r_void
)paren
(brace
id|high_memory
op_assign
id|__va
c_func
(paren
(paren
id|max_pfn
op_lshift
id|PAGE_SHIFT
)paren
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_DISCONTIGMEM
id|max_mapnr
op_assign
id|page_to_pfn
c_func
(paren
id|virt_to_page
c_func
(paren
id|high_memory
op_minus
l_int|1
)paren
)paren
op_plus
l_int|1
suffix:semicolon
id|mem_map
op_assign
id|zone_table
(braket
id|ZONE_DMA
)braket
op_member_access_from_pointer
id|zone_mem_map
suffix:semicolon
id|totalram_pages
op_add_assign
id|free_all_bootmem
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|npmem_ranges
suffix:semicolon
id|i
op_increment
)paren
id|totalram_pages
op_add_assign
id|free_all_bootmem_node
c_func
(paren
id|NODE_DATA
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Memory: %luk available&bslash;n&quot;
comma
id|num_physpages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PA11
r_if
c_cond
(paren
id|hppa_dma_ops
op_eq
op_amp
id|pcxl_dma_ops
)paren
(brace
id|pcxl_dma_start
op_assign
(paren
r_int
r_int
)paren
id|SET_MAP_OFFSET
c_func
(paren
id|MAP_START
)paren
suffix:semicolon
id|vmalloc_start
op_assign
id|SET_MAP_OFFSET
c_func
(paren
id|pcxl_dma_start
op_plus
id|PCXL_DMA_MAP_SIZE
)paren
suffix:semicolon
)brace
r_else
(brace
id|pcxl_dma_start
op_assign
l_int|0
suffix:semicolon
id|vmalloc_start
op_assign
id|SET_MAP_OFFSET
c_func
(paren
id|MAP_START
)paren
suffix:semicolon
)brace
macro_line|#else
id|vmalloc_start
op_assign
id|SET_MAP_OFFSET
c_func
(paren
id|MAP_START
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|do_check_pgt_cache
r_int
id|do_check_pgt_cache
c_func
(paren
r_int
id|low
comma
r_int
id|high
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|empty_zero_page
r_int
r_int
op_star
id|empty_zero_page
suffix:semicolon
DECL|function|show_mem
r_void
id|show_mem
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|free
op_assign
l_int|0
comma
id|total
op_assign
l_int|0
comma
id|reserved
op_assign
l_int|0
suffix:semicolon
r_int
id|shared
op_assign
l_int|0
comma
id|cached
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Mem-info:&bslash;n&quot;
)paren
suffix:semicolon
id|show_free_areas
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Free swap:&t; %6ldkB&bslash;n&quot;
comma
id|nr_swap_pages
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_DISCONTIGMEM
id|i
op_assign
id|max_mapnr
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
OG
l_int|0
)paren
(brace
id|total
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|mem_map
op_plus
id|i
)paren
)paren
id|reserved
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|mem_map
op_plus
id|i
)paren
)paren
id|cached
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|page_count
c_func
(paren
op_amp
id|mem_map
(braket
id|i
)braket
)paren
)paren
id|free
op_increment
suffix:semicolon
r_else
id|shared
op_add_assign
id|page_count
c_func
(paren
op_amp
id|mem_map
(braket
id|i
)braket
)paren
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#else
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|npmem_ranges
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|node_start_pfn
c_func
(paren
id|i
)paren
suffix:semicolon
id|j
OL
id|node_end_pfn
c_func
(paren
id|i
)paren
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|page
op_star
id|p
suffix:semicolon
id|p
op_assign
id|node_mem_map
c_func
(paren
id|i
)paren
op_plus
id|j
op_minus
id|node_start_pfn
c_func
(paren
id|i
)paren
suffix:semicolon
id|total
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|p
)paren
)paren
id|reserved
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|p
)paren
)paren
id|cached
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|page_count
c_func
(paren
id|p
)paren
)paren
id|free
op_increment
suffix:semicolon
r_else
id|shared
op_add_assign
id|page_count
c_func
(paren
id|p
)paren
op_minus
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%d pages of RAM&bslash;n&quot;
comma
id|total
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%d reserved pages&bslash;n&quot;
comma
id|reserved
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%d pages shared&bslash;n&quot;
comma
id|shared
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%d pages swap cached&bslash;n&quot;
comma
id|cached
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DISCONTIGMEM
(brace
r_struct
id|zonelist
op_star
id|zl
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|k
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|npmem_ranges
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|MAX_NR_ZONES
suffix:semicolon
id|j
op_increment
)paren
(brace
id|zl
op_assign
id|NODE_DATA
c_func
(paren
id|i
)paren
op_member_access_from_pointer
id|node_zonelists
op_plus
id|j
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Zone list for zone %d on node %d: &quot;
comma
id|j
comma
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|zl-&gt;zones
(braket
id|k
)braket
op_ne
l_int|NULL
suffix:semicolon
id|k
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;[%d/%s] &quot;
comma
id|zl-&gt;zones
(braket
id|k
)braket
op_member_access_from_pointer
id|zone_pgdat-&gt;node_id
comma
id|zl-&gt;zones
(braket
id|k
)braket
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
)brace
DECL|function|map_pages
r_static
r_void
id|__init
id|map_pages
c_func
(paren
r_int
r_int
id|start_vaddr
comma
r_int
r_int
id|start_paddr
comma
r_int
r_int
id|size
comma
id|pgprot_t
id|pgprot
)paren
(brace
id|pgd_t
op_star
id|pg_dir
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pg_table
suffix:semicolon
r_int
r_int
id|end_paddr
suffix:semicolon
r_int
r_int
id|start_pmd
suffix:semicolon
r_int
r_int
id|start_pte
suffix:semicolon
r_int
r_int
id|tmp1
suffix:semicolon
r_int
r_int
id|tmp2
suffix:semicolon
r_int
r_int
id|address
suffix:semicolon
r_int
r_int
id|ro_start
suffix:semicolon
r_int
r_int
id|ro_end
suffix:semicolon
r_int
r_int
id|fv_addr
suffix:semicolon
r_int
r_int
id|gw_addr
suffix:semicolon
r_extern
r_const
r_int
r_int
id|fault_vector_20
suffix:semicolon
r_extern
r_void
op_star
r_const
id|linux_gateway_page
suffix:semicolon
id|ro_start
op_assign
id|__pa
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|_text
)paren
suffix:semicolon
id|ro_end
op_assign
id|__pa
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|data_start
)paren
suffix:semicolon
id|fv_addr
op_assign
id|__pa
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|fault_vector_20
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
id|gw_addr
op_assign
id|__pa
c_func
(paren
(paren
r_int
r_int
)paren
op_amp
id|linux_gateway_page
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
id|end_paddr
op_assign
id|start_paddr
op_plus
id|size
suffix:semicolon
id|pg_dir
op_assign
id|pgd_offset_k
c_func
(paren
id|start_vaddr
)paren
suffix:semicolon
macro_line|#if PTRS_PER_PMD == 1
id|start_pmd
op_assign
l_int|0
suffix:semicolon
macro_line|#else
id|start_pmd
op_assign
(paren
(paren
id|start_vaddr
op_rshift
id|PMD_SHIFT
)paren
op_amp
(paren
id|PTRS_PER_PMD
op_minus
l_int|1
)paren
)paren
suffix:semicolon
macro_line|#endif
id|start_pte
op_assign
(paren
(paren
id|start_vaddr
op_rshift
id|PAGE_SHIFT
)paren
op_amp
(paren
id|PTRS_PER_PTE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|address
op_assign
id|start_paddr
suffix:semicolon
r_while
c_loop
(paren
id|address
OL
id|end_paddr
)paren
(brace
macro_line|#if PTRS_PER_PMD == 1
id|pmd
op_assign
(paren
id|pmd_t
op_star
)paren
id|__pa
c_func
(paren
id|pg_dir
)paren
suffix:semicolon
macro_line|#else
id|pmd
op_assign
(paren
id|pmd_t
op_star
)paren
id|pgd_address
c_func
(paren
op_star
id|pg_dir
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * pmd is physical at this point&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|pmd
)paren
(brace
id|pmd
op_assign
(paren
id|pmd_t
op_star
)paren
id|alloc_bootmem_low_pages_node
c_func
(paren
id|NODE_DATA
c_func
(paren
l_int|0
)paren
comma
id|PAGE_SIZE
op_lshift
id|PMD_ORDER
)paren
suffix:semicolon
id|pmd
op_assign
(paren
id|pmd_t
op_star
)paren
id|__pa
c_func
(paren
id|pmd
)paren
suffix:semicolon
)brace
id|pgd_populate
c_func
(paren
l_int|NULL
comma
id|pg_dir
comma
id|__va
c_func
(paren
id|pmd
)paren
)paren
suffix:semicolon
macro_line|#endif
id|pg_dir
op_increment
suffix:semicolon
multiline_comment|/* now change pmd to kernel virtual addresses */
id|pmd
op_assign
(paren
id|pmd_t
op_star
)paren
id|__va
c_func
(paren
id|pmd
)paren
op_plus
id|start_pmd
suffix:semicolon
r_for
c_loop
(paren
id|tmp1
op_assign
id|start_pmd
suffix:semicolon
id|tmp1
OL
id|PTRS_PER_PMD
suffix:semicolon
id|tmp1
op_increment
comma
id|pmd
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * pg_table is physical at this point&n;&t;&t;&t; */
id|pg_table
op_assign
(paren
id|pte_t
op_star
)paren
id|pmd_address
c_func
(paren
op_star
id|pmd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pg_table
)paren
(brace
id|pg_table
op_assign
(paren
id|pte_t
op_star
)paren
id|alloc_bootmem_low_pages_node
c_func
(paren
id|NODE_DATA
c_func
(paren
l_int|0
)paren
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|pg_table
op_assign
(paren
id|pte_t
op_star
)paren
id|__pa
c_func
(paren
id|pg_table
)paren
suffix:semicolon
)brace
id|pmd_populate_kernel
c_func
(paren
l_int|NULL
comma
id|pmd
comma
id|__va
c_func
(paren
id|pg_table
)paren
)paren
suffix:semicolon
multiline_comment|/* now change pg_table to kernel virtual addresses */
id|pg_table
op_assign
(paren
id|pte_t
op_star
)paren
id|__va
c_func
(paren
id|pg_table
)paren
op_plus
id|start_pte
suffix:semicolon
r_for
c_loop
(paren
id|tmp2
op_assign
id|start_pte
suffix:semicolon
id|tmp2
OL
id|PTRS_PER_PTE
suffix:semicolon
id|tmp2
op_increment
comma
id|pg_table
op_increment
)paren
(brace
id|pte_t
id|pte
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Map the fault vector writable so we can&n;&t;&t;&t;&t; * write the HPMC checksum.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|address
op_ge
id|ro_start
op_logical_and
id|address
OL
id|ro_end
op_logical_and
id|address
op_ne
id|fv_addr
op_logical_and
id|address
op_ne
id|gw_addr
)paren
id|pte
op_assign
id|__mk_pte
c_func
(paren
id|address
comma
id|PAGE_KERNEL_RO
)paren
suffix:semicolon
r_else
id|pte
op_assign
id|__mk_pte
c_func
(paren
id|address
comma
id|pgprot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|address
op_ge
id|end_paddr
)paren
id|pte_val
c_func
(paren
id|pte
)paren
op_assign
l_int|0
suffix:semicolon
id|set_pte
c_func
(paren
id|pg_table
comma
id|pte
)paren
suffix:semicolon
id|address
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|start_pte
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|address
op_ge
id|end_paddr
)paren
r_break
suffix:semicolon
)brace
id|start_pmd
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * pagetable_init() sets up the page tables&n; *&n; * Note that gateway_init() places the Linux gateway page at page 0.&n; * Since gateway pages cannot be dereferenced this has the desirable&n; * side effect of trapping those pesky NULL-reference errors in the&n; * kernel.&n; */
DECL|function|pagetable_init
r_static
r_void
id|__init
id|pagetable_init
c_func
(paren
r_void
)paren
(brace
r_int
id|range
suffix:semicolon
multiline_comment|/* Map each physical memory range to its kernel vaddr */
r_for
c_loop
(paren
id|range
op_assign
l_int|0
suffix:semicolon
id|range
OL
id|npmem_ranges
suffix:semicolon
id|range
op_increment
)paren
(brace
r_int
r_int
id|start_paddr
suffix:semicolon
r_int
r_int
id|end_paddr
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
id|start_paddr
op_assign
id|pmem_ranges
(braket
id|range
)braket
dot
id|start_pfn
op_lshift
id|PAGE_SHIFT
suffix:semicolon
id|end_paddr
op_assign
id|start_paddr
op_plus
(paren
id|pmem_ranges
(braket
id|range
)braket
dot
id|pages
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|size
op_assign
id|pmem_ranges
(braket
id|range
)braket
dot
id|pages
op_lshift
id|PAGE_SHIFT
suffix:semicolon
id|map_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|__va
c_func
(paren
id|start_paddr
)paren
comma
id|start_paddr
comma
id|size
comma
id|PAGE_KERNEL
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_if
c_cond
(paren
id|initrd_end
op_logical_and
id|initrd_end
OG
id|mem_limit
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;initrd: mapping %08lx-%08lx&bslash;n&quot;
comma
id|initrd_start
comma
id|initrd_end
)paren
suffix:semicolon
id|map_pages
c_func
(paren
id|initrd_start
comma
id|__pa
c_func
(paren
id|initrd_start
)paren
comma
id|initrd_end
op_minus
id|initrd_start
comma
id|PAGE_KERNEL
)paren
suffix:semicolon
)brace
macro_line|#endif
id|empty_zero_page
op_assign
id|alloc_bootmem_pages
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
id|memset
c_func
(paren
id|empty_zero_page
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
DECL|function|gateway_init
r_static
r_void
id|__init
id|gateway_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|linux_gateway_page_addr
suffix:semicolon
multiline_comment|/* FIXME: This is &squot;const&squot; in order to trick the compiler&n;&t;   into not treating it as DP-relative data. */
r_extern
r_void
op_star
r_const
id|linux_gateway_page
suffix:semicolon
id|linux_gateway_page_addr
op_assign
id|LINUX_GATEWAY_ADDR
op_amp
id|PAGE_MASK
suffix:semicolon
multiline_comment|/*&n;&t; * Setup Linux Gateway page.&n;&t; *&n;&t; * The Linux gateway page will reside in kernel space (on virtual&n;&t; * page 0), so it doesn&squot;t need to be aliased into user space.&n;&t; */
id|map_pages
c_func
(paren
id|linux_gateway_page_addr
comma
id|__pa
c_func
(paren
op_amp
id|linux_gateway_page
)paren
comma
id|PAGE_SIZE
comma
id|PAGE_GATEWAY
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_HPUX
r_void
DECL|function|map_hpux_gateway_page
id|map_hpux_gateway_page
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
id|pgd_t
op_star
id|pg_dir
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pg_table
suffix:semicolon
r_int
r_int
id|start_pmd
suffix:semicolon
r_int
r_int
id|start_pte
suffix:semicolon
r_int
r_int
id|address
suffix:semicolon
r_int
r_int
id|hpux_gw_page_addr
suffix:semicolon
multiline_comment|/* FIXME: This is &squot;const&squot; in order to trick the compiler&n;&t;   into not treating it as DP-relative data. */
r_extern
r_void
op_star
r_const
id|hpux_gateway_page
suffix:semicolon
id|hpux_gw_page_addr
op_assign
id|HPUX_GATEWAY_ADDR
op_amp
id|PAGE_MASK
suffix:semicolon
multiline_comment|/*&n;&t; * Setup HP-UX Gateway page.&n;&t; *&n;&t; * The HP-UX gateway page resides in the user address space,&n;&t; * so it needs to be aliased into each process.&n;&t; */
id|pg_dir
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|hpux_gw_page_addr
)paren
suffix:semicolon
macro_line|#if PTRS_PER_PMD == 1
id|start_pmd
op_assign
l_int|0
suffix:semicolon
macro_line|#else
id|start_pmd
op_assign
(paren
(paren
id|hpux_gw_page_addr
op_rshift
id|PMD_SHIFT
)paren
op_amp
(paren
id|PTRS_PER_PMD
op_minus
l_int|1
)paren
)paren
suffix:semicolon
macro_line|#endif
id|start_pte
op_assign
(paren
(paren
id|hpux_gw_page_addr
op_rshift
id|PAGE_SHIFT
)paren
op_amp
(paren
id|PTRS_PER_PTE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|address
op_assign
id|__pa
c_func
(paren
op_amp
id|hpux_gateway_page
)paren
suffix:semicolon
macro_line|#if PTRS_PER_PMD == 1
id|pmd
op_assign
(paren
id|pmd_t
op_star
)paren
id|__pa
c_func
(paren
id|pg_dir
)paren
suffix:semicolon
macro_line|#else
id|pmd
op_assign
(paren
id|pmd_t
op_star
)paren
id|pgd_address
c_func
(paren
op_star
id|pg_dir
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * pmd is physical at this point&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|pmd
)paren
(brace
id|pmd
op_assign
(paren
id|pmd_t
op_star
)paren
id|get_zeroed_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
id|pmd
op_assign
(paren
id|pmd_t
op_star
)paren
id|__pa
c_func
(paren
id|pmd
)paren
suffix:semicolon
)brace
id|__pgd_val_set
c_func
(paren
op_star
id|pg_dir
comma
id|PxD_FLAG_PRESENT
op_or
id|PxD_FLAG_VALID
op_or
(paren
r_int
r_int
)paren
id|pmd
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* now change pmd to kernel virtual addresses */
id|pmd
op_assign
(paren
id|pmd_t
op_star
)paren
id|__va
c_func
(paren
id|pmd
)paren
op_plus
id|start_pmd
suffix:semicolon
multiline_comment|/*&n;&t; * pg_table is physical at this point&n;&t; */
id|pg_table
op_assign
(paren
id|pte_t
op_star
)paren
id|pmd_address
c_func
(paren
op_star
id|pmd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pg_table
)paren
id|pg_table
op_assign
(paren
id|pte_t
op_star
)paren
id|__pa
c_func
(paren
id|get_zeroed_page
c_func
(paren
id|GFP_KERNEL
)paren
)paren
suffix:semicolon
id|__pmd_val_set
c_func
(paren
op_star
id|pmd
comma
id|PxD_FLAG_PRESENT
op_or
id|PxD_FLAG_VALID
op_or
(paren
r_int
r_int
)paren
id|pg_table
)paren
suffix:semicolon
multiline_comment|/* now change pg_table to kernel virtual addresses */
id|pg_table
op_assign
(paren
id|pte_t
op_star
)paren
id|__va
c_func
(paren
id|pg_table
)paren
op_plus
id|start_pte
suffix:semicolon
id|set_pte
c_func
(paren
id|pg_table
comma
id|__mk_pte
c_func
(paren
id|address
comma
id|PAGE_GATEWAY
)paren
)paren
suffix:semicolon
)brace
DECL|variable|map_hpux_gateway_page
id|EXPORT_SYMBOL
c_func
(paren
id|map_hpux_gateway_page
)paren
suffix:semicolon
macro_line|#endif
r_extern
r_void
id|flush_tlb_all_local
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|paging_init
r_void
id|__init
id|paging_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|setup_bootmem
c_func
(paren
)paren
suffix:semicolon
id|pagetable_init
c_func
(paren
)paren
suffix:semicolon
id|gateway_init
c_func
(paren
)paren
suffix:semicolon
id|flush_cache_all_local
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* start with known state */
id|flush_tlb_all_local
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|npmem_ranges
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|zones_size
(braket
id|MAX_NR_ZONES
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* We have an IOMMU, so all memory can go into a single&n;&t;&t;   ZONE_DMA zone. */
id|zones_size
(braket
id|ZONE_DMA
)braket
op_assign
id|pmem_ranges
(braket
id|i
)braket
dot
id|pages
suffix:semicolon
id|free_area_init_node
c_func
(paren
id|i
comma
id|NODE_DATA
c_func
(paren
id|i
)paren
comma
id|zones_size
comma
id|pmem_ranges
(braket
id|i
)braket
dot
id|start_pfn
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DISCONTIGMEM
(brace
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
(paren
id|node_start_pfn
c_func
(paren
id|i
)paren
op_rshift
id|PFNNID_SHIFT
)paren
suffix:semicolon
id|j
op_le
(paren
id|node_end_pfn
c_func
(paren
id|i
)paren
op_rshift
id|PFNNID_SHIFT
)paren
suffix:semicolon
id|j
op_increment
)paren
(brace
id|pfnnid_map
(braket
id|j
)braket
op_assign
id|i
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
)brace
macro_line|#ifdef CONFIG_PA20
multiline_comment|/*&n; * Currently, all PA20 chips have 18 bit protection id&squot;s, which is the&n; * limiting factor (space ids are 32 bits).&n; */
DECL|macro|NR_SPACE_IDS
mdefine_line|#define NR_SPACE_IDS 262144
macro_line|#else
multiline_comment|/*&n; * Currently we have a one-to-one relationship between space id&squot;s and&n; * protection id&squot;s. Older parisc chips (PCXS, PCXT, PCXL, PCXL2) only&n; * support 15 bit protection id&squot;s, so that is the limiting factor.&n; * PCXT&squot; has 18 bit protection id&squot;s, but only 16 bit spaceids, so it&squot;s&n; * probably not worth the effort for a special case here.&n; */
DECL|macro|NR_SPACE_IDS
mdefine_line|#define NR_SPACE_IDS 32768
macro_line|#endif  /* !CONFIG_PA20 */
DECL|macro|RECYCLE_THRESHOLD
mdefine_line|#define RECYCLE_THRESHOLD (NR_SPACE_IDS / 2)
DECL|macro|SID_ARRAY_SIZE
mdefine_line|#define SID_ARRAY_SIZE  (NR_SPACE_IDS / (8 * sizeof(long)))
DECL|variable|space_id
r_static
r_int
r_int
id|space_id
(braket
id|SID_ARRAY_SIZE
)braket
op_assign
(brace
l_int|1
)brace
suffix:semicolon
multiline_comment|/* disallow space 0 */
DECL|variable|dirty_space_id
r_static
r_int
r_int
id|dirty_space_id
(braket
id|SID_ARRAY_SIZE
)braket
suffix:semicolon
DECL|variable|space_id_index
r_static
r_int
r_int
id|space_id_index
suffix:semicolon
DECL|variable|free_space_ids
r_static
r_int
r_int
id|free_space_ids
op_assign
id|NR_SPACE_IDS
op_minus
l_int|1
suffix:semicolon
DECL|variable|dirty_space_ids
r_static
r_int
r_int
id|dirty_space_ids
op_assign
l_int|0
suffix:semicolon
DECL|variable|sid_lock
r_static
id|spinlock_t
id|sid_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|alloc_sid
r_int
r_int
id|alloc_sid
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|index
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sid_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|free_space_ids
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|dirty_space_ids
op_ne
l_int|0
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|sid_lock
)paren
suffix:semicolon
id|flush_tlb_all
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* flush_tlb_all() calls recycle_sids() */
id|spin_lock
c_func
(paren
op_amp
id|sid_lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|free_space_ids
op_eq
l_int|0
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|free_space_ids
op_decrement
suffix:semicolon
id|index
op_assign
id|find_next_zero_bit
c_func
(paren
id|space_id
comma
id|NR_SPACE_IDS
comma
id|space_id_index
)paren
suffix:semicolon
id|space_id
(braket
id|index
op_rshift
id|SHIFT_PER_LONG
)braket
op_or_assign
(paren
l_int|1L
op_lshift
(paren
id|index
op_amp
(paren
id|BITS_PER_LONG
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
id|space_id_index
op_assign
id|index
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|sid_lock
)paren
suffix:semicolon
r_return
id|index
op_lshift
id|SPACEID_SHIFT
suffix:semicolon
)brace
DECL|function|free_sid
r_void
id|free_sid
c_func
(paren
r_int
r_int
id|spaceid
)paren
(brace
r_int
r_int
id|index
op_assign
id|spaceid
op_rshift
id|SPACEID_SHIFT
suffix:semicolon
r_int
r_int
op_star
id|dirty_space_offset
suffix:semicolon
id|dirty_space_offset
op_assign
id|dirty_space_id
op_plus
(paren
id|index
op_rshift
id|SHIFT_PER_LONG
)paren
suffix:semicolon
id|index
op_and_assign
(paren
id|BITS_PER_LONG
op_minus
l_int|1
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sid_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|dirty_space_offset
op_amp
(paren
l_int|1L
op_lshift
id|index
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* attempt to free space id twice */
op_star
id|dirty_space_offset
op_or_assign
(paren
l_int|1L
op_lshift
id|index
)paren
suffix:semicolon
id|dirty_space_ids
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|sid_lock
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
DECL|function|get_dirty_sids
r_static
r_void
id|get_dirty_sids
c_func
(paren
r_int
r_int
op_star
id|ndirtyptr
comma
r_int
r_int
op_star
id|dirty_array
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* NOTE: sid_lock must be held upon entry */
op_star
id|ndirtyptr
op_assign
id|dirty_space_ids
suffix:semicolon
r_if
c_cond
(paren
id|dirty_space_ids
op_ne
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SID_ARRAY_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dirty_array
(braket
id|i
)braket
op_assign
id|dirty_space_id
(braket
id|i
)braket
suffix:semicolon
id|dirty_space_id
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|dirty_space_ids
op_assign
l_int|0
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|recycle_sids
r_static
r_void
id|recycle_sids
c_func
(paren
r_int
r_int
id|ndirty
comma
r_int
r_int
op_star
id|dirty_array
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* NOTE: sid_lock must be held upon entry */
r_if
c_cond
(paren
id|ndirty
op_ne
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SID_ARRAY_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|space_id
(braket
id|i
)braket
op_xor_assign
id|dirty_array
(braket
id|i
)braket
suffix:semicolon
)brace
id|free_space_ids
op_add_assign
id|ndirty
suffix:semicolon
id|space_id_index
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#else /* CONFIG_SMP */
DECL|function|recycle_sids
r_static
r_void
id|recycle_sids
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* NOTE: sid_lock must be held upon entry */
r_if
c_cond
(paren
id|dirty_space_ids
op_ne
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SID_ARRAY_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|space_id
(braket
id|i
)braket
op_xor_assign
id|dirty_space_id
(braket
id|i
)braket
suffix:semicolon
id|dirty_space_id
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|free_space_ids
op_add_assign
id|dirty_space_ids
suffix:semicolon
id|dirty_space_ids
op_assign
l_int|0
suffix:semicolon
id|space_id_index
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n; * flush_tlb_all() calls recycle_sids(), since whenever the entire tlb is&n; * purged, we can safely reuse the space ids that were released but&n; * not flushed from the tlb.&n; */
macro_line|#ifdef CONFIG_SMP
DECL|variable|recycle_ndirty
r_static
r_int
r_int
id|recycle_ndirty
suffix:semicolon
DECL|variable|recycle_dirty_array
r_static
r_int
r_int
id|recycle_dirty_array
(braket
id|SID_ARRAY_SIZE
)braket
suffix:semicolon
DECL|variable|recycle_inuse
r_static
r_int
r_int
id|recycle_inuse
op_assign
l_int|0
suffix:semicolon
DECL|function|flush_tlb_all
r_void
id|flush_tlb_all
c_func
(paren
r_void
)paren
(brace
r_int
id|do_recycle
suffix:semicolon
id|do_recycle
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sid_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dirty_space_ids
OG
id|RECYCLE_THRESHOLD
)paren
(brace
r_if
c_cond
(paren
id|recycle_inuse
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* FIXME: Use a semaphore/wait queue here */
)brace
id|get_dirty_sids
c_func
(paren
op_amp
id|recycle_ndirty
comma
id|recycle_dirty_array
)paren
suffix:semicolon
id|recycle_inuse
op_increment
suffix:semicolon
id|do_recycle
op_increment
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|sid_lock
)paren
suffix:semicolon
id|on_each_cpu
c_func
(paren
(paren
r_void
(paren
op_star
)paren
(paren
r_void
op_star
)paren
)paren
id|flush_tlb_all_local
comma
l_int|NULL
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_recycle
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|sid_lock
)paren
suffix:semicolon
id|recycle_sids
c_func
(paren
id|recycle_ndirty
comma
id|recycle_dirty_array
)paren
suffix:semicolon
id|recycle_inuse
op_assign
l_int|0
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|sid_lock
)paren
suffix:semicolon
)brace
)brace
macro_line|#else
DECL|function|flush_tlb_all
r_void
id|flush_tlb_all
c_func
(paren
r_void
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|sid_lock
)paren
suffix:semicolon
id|flush_tlb_all_local
c_func
(paren
)paren
suffix:semicolon
id|recycle_sids
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|sid_lock
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
DECL|function|free_initrd_mem
r_void
id|free_initrd_mem
c_func
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
macro_line|#if 0
r_if
c_cond
(paren
id|start
OL
id|end
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Freeing initrd memory: %ldk freed&bslash;n&quot;
comma
(paren
id|end
op_minus
id|start
)paren
op_rshift
l_int|10
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|start
OL
id|end
suffix:semicolon
id|start
op_add_assign
id|PAGE_SIZE
)paren
(brace
id|ClearPageReserved
c_func
(paren
id|virt_to_page
c_func
(paren
id|start
)paren
)paren
suffix:semicolon
id|set_page_count
c_func
(paren
id|virt_to_page
c_func
(paren
id|start
)paren
comma
l_int|1
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|start
)paren
suffix:semicolon
id|num_physpages
op_increment
suffix:semicolon
id|totalram_pages
op_increment
suffix:semicolon
)brace
macro_line|#endif
)brace
macro_line|#endif
eof
