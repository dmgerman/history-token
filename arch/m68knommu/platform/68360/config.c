multiline_comment|/*&n; *  linux/arch/m68knommu/platform/68360/config.c&n; *&n; *  Copyright (c) 2000 Michael Leslie &lt;mleslie@lineo.com&gt;&n; *  Copyright (C) 1993 Hamish Macdonald&n; *  Copyright (C) 1999 D. Jeff Dionne &lt;jeff@uclinux.org&gt;&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file COPYING in the main directory of this archive&n; * for more details.&n; */
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/m68360.h&gt;
macro_line|#ifdef CONFIG_UCQUICC
macro_line|#include &lt;asm/bootstd.h&gt;
macro_line|#endif
r_extern
r_void
id|m360_cpm_reset
c_func
(paren
r_void
)paren
suffix:semicolon
singleline_comment|// Mask to select if the PLL prescaler is enabled.
DECL|macro|MCU_PREEN
mdefine_line|#define MCU_PREEN   ((unsigned short)(0x0001 &lt;&lt; 13))
macro_line|#if defined(CONFIG_UCQUICC)
DECL|macro|OSCILLATOR
mdefine_line|#define OSCILLATOR  (unsigned long int)33000000
macro_line|#endif
DECL|variable|system_clock
r_int
r_int
r_int
id|system_clock
suffix:semicolon
r_void
id|M68360_init_IRQ
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|QUICC
op_star
id|pquicc
suffix:semicolon
multiline_comment|/* TODO  DON&quot;T Hard Code this */
multiline_comment|/* calculate properly using the right PLL and prescaller */
singleline_comment|// unsigned int system_clock = 33000000l;
r_extern
r_int
r_int
r_int
id|system_clock
suffix:semicolon
singleline_comment|//In kernel setup.c
r_extern
r_void
id|config_M68360_irq
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|BSP_sched_init
r_void
id|BSP_sched_init
c_func
(paren
r_void
(paren
op_star
id|timer_routine
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
)paren
(brace
r_int
r_char
id|prescaler
suffix:semicolon
r_int
r_int
id|tgcr_save
suffix:semicolon
r_int
id|return_value
suffix:semicolon
macro_line|#if 0
multiline_comment|/* Restart mode, Enable int, 32KHz, Enable timer */
id|TCTL
op_assign
id|TCTL_OM
op_or
id|TCTL_IRQEN
op_or
id|TCTL_CLKSOURCE_32KHZ
op_or
id|TCTL_TEN
suffix:semicolon
multiline_comment|/* Set prescaler (Divide 32KHz by 32)*/
id|TPRER
op_assign
l_int|31
suffix:semicolon
multiline_comment|/* Set compare register  32Khz / 32 / 10 = 100 */
id|TCMP
op_assign
l_int|10
suffix:semicolon
id|request_irq
c_func
(paren
id|IRQ_MACHSPEC
op_or
l_int|1
comma
id|timer_routine
comma
id|IRQ_FLG_LOCK
comma
l_string|&quot;timer&quot;
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* General purpose quicc timers: MC68360UM p7-20 */
multiline_comment|/* Set up timer 1 (in [1..4]) to do 100Hz */
id|tgcr_save
op_assign
id|pquicc-&gt;timer_tgcr
op_amp
l_int|0xfff0
suffix:semicolon
id|pquicc-&gt;timer_tgcr
op_assign
id|tgcr_save
suffix:semicolon
multiline_comment|/* stop and reset timer 1 */
multiline_comment|/* pquicc-&gt;timer_tgcr |= 0x4444; */
multiline_comment|/* halt timers when FREEZE (ie bdm freeze) */
id|prescaler
op_assign
l_int|8
suffix:semicolon
id|pquicc-&gt;timer_tmr1
op_assign
l_int|0x001a
op_or
multiline_comment|/* or=1, frr=1, iclk=01b */
(paren
r_int
r_int
)paren
(paren
(paren
id|prescaler
op_minus
l_int|1
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|pquicc-&gt;timer_tcn1
op_assign
l_int|0x0000
suffix:semicolon
multiline_comment|/* initial count */
multiline_comment|/* calculate interval for 100Hz based on the _system_clock: */
id|pquicc-&gt;timer_trr1
op_assign
(paren
id|system_clock
op_div
id|prescaler
)paren
op_div
id|HZ
suffix:semicolon
multiline_comment|/* reference count */
id|pquicc-&gt;timer_ter1
op_assign
l_int|0x0003
suffix:semicolon
multiline_comment|/* clear timer events */
multiline_comment|/* enable timer 1 interrupt in CIMR */
singleline_comment|//  request_irq(IRQ_MACHSPEC | CPMVEC_TIMER1, timer_routine, IRQ_FLG_LOCK, &quot;timer&quot;, NULL);
singleline_comment|//return_value = request_irq( CPMVEC_TIMER1, timer_routine, IRQ_FLG_LOCK, &quot;timer&quot;, NULL);
id|return_value
op_assign
id|request_irq
c_func
(paren
id|CPMVEC_TIMER1
comma
id|timer_routine
comma
id|IRQ_FLG_LOCK
comma
l_string|&quot;Timer&quot;
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Start timer 1: */
id|tgcr_save
op_assign
(paren
id|pquicc-&gt;timer_tgcr
op_amp
l_int|0xfff0
)paren
op_or
l_int|0x0001
suffix:semicolon
id|pquicc-&gt;timer_tgcr
op_assign
id|tgcr_save
suffix:semicolon
)brace
DECL|function|BSP_tick
r_void
id|BSP_tick
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Reset Timer1 */
multiline_comment|/* TSTAT &amp;= 0; */
id|pquicc-&gt;timer_ter1
op_assign
l_int|0x0002
suffix:semicolon
multiline_comment|/* clear timer event */
)brace
DECL|function|BSP_gettimeoffset
r_int
r_int
id|BSP_gettimeoffset
(paren
r_void
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|BSP_gettod
r_void
id|BSP_gettod
(paren
r_int
op_star
id|yearp
comma
r_int
op_star
id|monp
comma
r_int
op_star
id|dayp
comma
r_int
op_star
id|hourp
comma
r_int
op_star
id|minp
comma
r_int
op_star
id|secp
)paren
(brace
)brace
DECL|function|BSP_hwclk
r_int
id|BSP_hwclk
c_func
(paren
r_int
id|op
comma
r_struct
id|hwclk_time
op_star
id|t
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|op
)paren
(brace
multiline_comment|/* read */
)brace
r_else
(brace
multiline_comment|/* write */
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|BSP_set_clock_mmss
r_int
id|BSP_set_clock_mmss
(paren
r_int
r_int
id|nowtime
)paren
(brace
macro_line|#if 0
r_int
id|real_seconds
op_assign
id|nowtime
op_mod
l_int|60
comma
id|real_minutes
op_assign
(paren
id|nowtime
op_div
l_int|60
)paren
op_mod
l_int|60
suffix:semicolon
id|tod-&gt;second1
op_assign
id|real_seconds
op_div
l_int|10
suffix:semicolon
id|tod-&gt;second2
op_assign
id|real_seconds
op_mod
l_int|10
suffix:semicolon
id|tod-&gt;minute1
op_assign
id|real_minutes
op_div
l_int|10
suffix:semicolon
id|tod-&gt;minute2
op_assign
id|real_minutes
op_mod
l_int|10
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|BSP_reset
r_void
id|BSP_reset
(paren
r_void
)paren
(brace
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
"&quot;"
id|moveal
macro_line|#_start, %a0;
id|moveb
macro_line|#0, 0xFFFFF300;
id|moveal
l_int|0
(paren
op_mod
id|a0
)paren
comma
op_mod
id|sp
suffix:semicolon
id|moveal
l_int|4
(paren
op_mod
id|a0
)paren
comma
op_mod
id|a0
suffix:semicolon
id|jmp
(paren
op_mod
id|a0
)paren
suffix:semicolon
"&quot;"
)paren
suffix:semicolon
)brace
DECL|variable|scc1_hwaddr
r_int
r_char
op_star
id|scc1_hwaddr
suffix:semicolon
DECL|variable|errno
r_static
r_int
id|errno
suffix:semicolon
macro_line|#if defined (CONFIG_UCQUICC)
id|_bsc0
c_func
(paren
r_char
op_star
comma
id|getserialnum
)paren
id|_bsc1
c_func
(paren
r_int
r_char
op_star
comma
id|gethwaddr
comma
r_int
comma
id|a
)paren
id|_bsc1
c_func
(paren
r_char
op_star
comma
id|getbenv
comma
r_char
op_star
comma
id|a
)paren
macro_line|#endif
DECL|function|config_BSP
r_void
id|config_BSP
c_func
(paren
r_char
op_star
id|command
comma
r_int
id|len
)paren
(brace
r_int
r_char
op_star
id|p
suffix:semicolon
id|m360_cpm_reset
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Calculate the real system clock value. */
(brace
r_int
r_int
id|local_pllcr
op_assign
(paren
r_int
r_int
)paren
(paren
id|pquicc-&gt;sim_pllcr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|local_pllcr
op_amp
id|MCU_PREEN
)paren
singleline_comment|// If the prescaler is dividing by 128
(brace
r_int
id|mf
op_assign
(paren
r_int
)paren
(paren
id|pquicc-&gt;sim_pllcr
op_amp
l_int|0x0fff
)paren
suffix:semicolon
id|system_clock
op_assign
(paren
id|OSCILLATOR
op_div
l_int|128
)paren
op_star
(paren
id|mf
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|mf
op_assign
(paren
r_int
)paren
(paren
id|pquicc-&gt;sim_pllcr
op_amp
l_int|0x0fff
)paren
suffix:semicolon
id|system_clock
op_assign
(paren
id|OSCILLATOR
)paren
op_star
(paren
id|mf
op_plus
l_int|1
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n68360 QUICC support (C) 2000 Lineo Inc.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_UCQUICC) &amp;&amp; 0
id|printk
c_func
(paren
l_string|&quot;uCquicc serial string [%s]&bslash;n&quot;
comma
id|getserialnum
c_func
(paren
)paren
)paren
suffix:semicolon
id|p
op_assign
id|scc1_hwaddr
op_assign
id|gethwaddr
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;uCquicc hwaddr %.2x:%.2x:%.2x:%.2x:%.2x:%.2x&bslash;n&quot;
comma
id|p
(braket
l_int|0
)braket
comma
id|p
(braket
l_int|1
)braket
comma
id|p
(braket
l_int|2
)braket
comma
id|p
(braket
l_int|3
)braket
comma
id|p
(braket
l_int|4
)braket
comma
id|p
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|p
op_assign
id|getbenv
c_func
(paren
l_string|&quot;APPEND&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|strcpy
c_func
(paren
id|p
comma
id|command
)paren
suffix:semicolon
r_else
id|command
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#else
id|scc1_hwaddr
op_assign
l_string|&quot;&bslash;00&bslash;01&bslash;02&bslash;03&bslash;04&bslash;05&quot;
suffix:semicolon
macro_line|#endif
id|mach_sched_init
op_assign
id|BSP_sched_init
suffix:semicolon
id|mach_tick
op_assign
id|BSP_tick
suffix:semicolon
id|mach_gettimeoffset
op_assign
id|BSP_gettimeoffset
suffix:semicolon
id|mach_gettod
op_assign
id|BSP_gettod
suffix:semicolon
id|mach_hwclk
op_assign
l_int|NULL
suffix:semicolon
id|mach_set_clock_mmss
op_assign
l_int|NULL
suffix:semicolon
id|mach_reset
op_assign
id|BSP_reset
suffix:semicolon
)brace
eof
