multiline_comment|/*&n; *  linux/arch/m68knommu/mm/init.c&n; *&n; *  Copyright (C) 1998  D. Jeff Dionne &lt;jeff@lineo.ca&gt;,&n; *                      Kenneth Albanowski &lt;kjahds@kjahds.com&gt;,&n; *  Copyright (C) 2000  Lineo, Inc.  (www.lineo.com) &n; *&n; *  Based on:&n; *&n; *  linux/arch/m68k/mm/init.c&n; *&n; *  Copyright (C) 1995  Hamish Macdonald&n; *&n; *  JAN/1999 -- hacked to support ColdFire (gerg@snapgear.com)&n; *  DEC/2000 -- linux 2.4 support &lt;davidm@snapgear.com&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/shglcore.h&gt;
DECL|macro|DEBUG
macro_line|#undef DEBUG
r_extern
r_void
id|die_if_kernel
c_func
(paren
r_char
op_star
comma
r_struct
id|pt_regs
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_void
id|free_initmem
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * BAD_PAGE is the page that is used for page faults when linux&n; * is out-of-memory. Older versions of linux just did a&n; * do_exit(), but using this instead means there is less risk&n; * for a process dying in kernel mode, possibly leaving a inode&n; * unused etc..&n; *&n; * BAD_PAGETABLE is the accompanying page-table: it is initialized&n; * to point to BAD_PAGE entries.&n; *&n; * ZERO_PAGE is a special page that is used for zero-initialized&n; * data and COW.&n; */
DECL|variable|empty_bad_page_table
r_static
r_int
r_int
id|empty_bad_page_table
suffix:semicolon
DECL|variable|empty_bad_page
r_static
r_int
r_int
id|empty_bad_page
suffix:semicolon
DECL|variable|empty_zero_page
r_int
r_int
id|empty_zero_page
suffix:semicolon
r_extern
r_int
r_int
id|rom_length
suffix:semicolon
DECL|function|show_mem
r_void
id|show_mem
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
id|free
op_assign
l_int|0
comma
id|total
op_assign
l_int|0
comma
id|reserved
op_assign
l_int|0
comma
id|shared
op_assign
l_int|0
suffix:semicolon
r_int
id|cached
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;&bslash;nMem-info:&bslash;n&quot;
)paren
suffix:semicolon
id|show_free_areas
c_func
(paren
)paren
suffix:semicolon
id|i
op_assign
id|max_mapnr
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
OG
l_int|0
)paren
(brace
id|total
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|PageReserved
c_func
(paren
id|mem_map
op_plus
id|i
)paren
)paren
id|reserved
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|PageSwapCache
c_func
(paren
id|mem_map
op_plus
id|i
)paren
)paren
id|cached
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|page_count
c_func
(paren
id|mem_map
op_plus
id|i
)paren
)paren
id|free
op_increment
suffix:semicolon
r_else
id|shared
op_add_assign
id|page_count
c_func
(paren
id|mem_map
op_plus
id|i
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%d pages of RAM&bslash;n&quot;
comma
id|total
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%d free pages&bslash;n&quot;
comma
id|free
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%d reserved pages&bslash;n&quot;
comma
id|reserved
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%d pages shared&bslash;n&quot;
comma
id|shared
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%d pages swap cached&bslash;n&quot;
comma
id|cached
)paren
suffix:semicolon
)brace
r_extern
r_int
r_int
id|memory_start
suffix:semicolon
r_extern
r_int
r_int
id|memory_end
suffix:semicolon
multiline_comment|/*&n; * paging_init() continues the virtual memory environment setup which&n; * was begun by the code in arch/head.S.&n; * The parameters are pointers to where to stick the starting and ending&n; * addresses of available kernel virtual memory.&n; */
DECL|function|paging_init
r_void
id|paging_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * Make sure start_mem is page aligned, otherwise bootmem and&n;&t; * page_alloc get different views of the world.&n;&t; */
macro_line|#ifdef DEBUG
r_int
r_int
id|start_mem
op_assign
id|PAGE_ALIGN
c_func
(paren
id|memory_start
)paren
suffix:semicolon
macro_line|#endif
r_int
r_int
id|end_mem
op_assign
id|memory_end
op_amp
id|PAGE_MASK
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;start_mem is %#lx&bslash;nvirtual_end is %#lx&bslash;n&quot;
comma
id|start_mem
comma
id|end_mem
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Initialize the bad page table and bad page to point&n;&t; * to a couple of allocated pages.&n;&t; */
id|empty_bad_page_table
op_assign
(paren
r_int
r_int
)paren
id|alloc_bootmem_pages
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
id|empty_bad_page
op_assign
(paren
r_int
r_int
)paren
id|alloc_bootmem_pages
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
id|empty_zero_page
op_assign
(paren
r_int
r_int
)paren
id|alloc_bootmem_pages
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|empty_zero_page
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set up SFC/DFC registers (user data space).&n;&t; */
id|set_fs
(paren
id|USER_DS
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;before free_area_init&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;free_area_init -&gt; start_mem is %#lx&bslash;nvirtual_end is %#lx&bslash;n&quot;
comma
id|start_mem
comma
id|end_mem
)paren
suffix:semicolon
macro_line|#endif
(brace
r_int
r_int
id|zones_size
(braket
id|MAX_NR_ZONES
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|zones_size
(braket
id|ZONE_DMA
)braket
op_assign
l_int|0
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|zones_size
(braket
id|ZONE_NORMAL
)braket
op_assign
(paren
id|end_mem
op_minus
id|PAGE_OFFSET
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
macro_line|#ifdef CONFIG_HIGHMEM
id|zones_size
(braket
id|ZONE_HIGHMEM
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|free_area_init
c_func
(paren
id|zones_size
)paren
suffix:semicolon
)brace
)brace
DECL|function|mem_init
r_void
id|mem_init
c_func
(paren
r_void
)paren
(brace
r_int
id|codek
op_assign
l_int|0
comma
id|datak
op_assign
l_int|0
comma
id|initk
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
r_extern
r_char
id|_etext
comma
id|_stext
comma
id|_sdata
comma
id|_ebss
comma
id|__init_begin
comma
id|__init_end
suffix:semicolon
r_extern
r_int
r_int
id|_ramend
comma
id|_rambase
suffix:semicolon
r_int
r_int
id|len
op_assign
id|_ramend
op_minus
id|_rambase
suffix:semicolon
r_int
r_int
id|start_mem
op_assign
id|memory_start
suffix:semicolon
multiline_comment|/* DAVIDM - these must start at end of kernel */
r_int
r_int
id|end_mem
op_assign
id|memory_end
suffix:semicolon
multiline_comment|/* DAVIDM - this must not include kernel stack at top */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Mem_init: start=%lx, end=%lx&bslash;n&quot;
comma
id|start_mem
comma
id|end_mem
)paren
suffix:semicolon
macro_line|#endif
id|end_mem
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|high_memory
op_assign
(paren
r_void
op_star
)paren
id|end_mem
suffix:semicolon
id|start_mem
op_assign
id|PAGE_ALIGN
c_func
(paren
id|start_mem
)paren
suffix:semicolon
id|max_mapnr
op_assign
id|num_physpages
op_assign
id|MAP_NR
c_func
(paren
id|high_memory
)paren
suffix:semicolon
multiline_comment|/* this will put all memory onto the freelists */
id|totalram_pages
op_assign
id|free_all_bootmem
c_func
(paren
)paren
suffix:semicolon
id|codek
op_assign
(paren
op_amp
id|_etext
op_minus
op_amp
id|_stext
)paren
op_rshift
l_int|10
suffix:semicolon
id|datak
op_assign
(paren
op_amp
id|_ebss
op_minus
op_amp
id|_sdata
)paren
op_rshift
l_int|10
suffix:semicolon
id|initk
op_assign
(paren
op_amp
id|__init_begin
op_minus
op_amp
id|__init_end
)paren
op_rshift
l_int|10
suffix:semicolon
id|tmp
op_assign
id|nr_free_pages
c_func
(paren
)paren
op_lshift
id|PAGE_SHIFT
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Memory available: %luk/%luk RAM, %luk/%luk ROM (%dk kernel code, %dk data)&bslash;n&quot;
comma
id|tmp
op_rshift
l_int|10
comma
id|len
op_rshift
l_int|10
comma
(paren
id|rom_length
OG
l_int|0
)paren
ques
c_cond
(paren
(paren
id|rom_length
op_rshift
l_int|10
)paren
op_minus
id|codek
)paren
suffix:colon
l_int|0
comma
id|rom_length
op_rshift
l_int|10
comma
id|codek
comma
id|datak
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
DECL|function|free_initrd_mem
r_void
id|free_initrd_mem
c_func
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_int
id|pages
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|start
OL
id|end
suffix:semicolon
id|start
op_add_assign
id|PAGE_SIZE
)paren
(brace
id|ClearPageReserved
c_func
(paren
id|virt_to_page
c_func
(paren
id|start
)paren
)paren
suffix:semicolon
id|set_page_count
c_func
(paren
id|virt_to_page
c_func
(paren
id|start
)paren
comma
l_int|1
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|start
)paren
suffix:semicolon
id|totalram_pages
op_increment
suffix:semicolon
id|pages
op_increment
suffix:semicolon
)brace
id|printk
(paren
id|KERN_NOTICE
l_string|&quot;Freeing initrd memory: %dk freed&bslash;n&quot;
comma
id|pages
)paren
suffix:semicolon
)brace
macro_line|#endif
r_void
DECL|function|free_initmem
id|free_initmem
c_func
(paren
)paren
(brace
macro_line|#ifdef CONFIG_RAMKERNEL
r_int
r_int
id|addr
suffix:semicolon
r_extern
r_char
id|__init_begin
comma
id|__init_end
suffix:semicolon
multiline_comment|/*&n;&t; * The following code should be cool even if these sections&n;&t; * are not page aligned.&n;&t; */
id|addr
op_assign
id|PAGE_ALIGN
c_func
(paren
(paren
r_int
r_int
)paren
(paren
op_amp
id|__init_begin
)paren
)paren
suffix:semicolon
multiline_comment|/* next to check that the page we free is not a partial page */
r_for
c_loop
(paren
suffix:semicolon
id|addr
op_plus
id|PAGE_SIZE
OL
(paren
r_int
r_int
)paren
(paren
op_amp
id|__init_end
)paren
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
)paren
(brace
id|ClearPageReserved
c_func
(paren
id|virt_to_page
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
id|set_page_count
c_func
(paren
id|virt_to_page
c_func
(paren
id|addr
)paren
comma
l_int|1
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|addr
)paren
suffix:semicolon
id|totalram_pages
op_increment
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Freeing unused kernel memory: %ldk freed (0x%x - 0x%x)&bslash;n&quot;
comma
(paren
id|addr
op_minus
id|PAGE_ALIGN
c_func
(paren
(paren
r_int
)paren
op_amp
id|__init_begin
)paren
)paren
op_rshift
l_int|10
comma
(paren
r_int
)paren
(paren
id|PAGE_ALIGN
c_func
(paren
(paren
r_int
r_int
)paren
(paren
op_amp
id|__init_begin
)paren
)paren
)paren
comma
(paren
r_int
)paren
(paren
id|addr
op_minus
id|PAGE_SIZE
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
eof
