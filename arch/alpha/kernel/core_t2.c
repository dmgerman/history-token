multiline_comment|/*&n; *&t;linux/arch/alpha/kernel/core_t2.c&n; *&n; * Written by Jay A Estabrook (jestabro@amt.tay1.dec.com).&n; * December 1996.&n; *&n; * based on CIA code by David A Rusling (david.rusling@reo.mts.dec.com)&n; *&n; * Code common to all T2 core logic chips.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
DECL|macro|__EXTERN_INLINE
mdefine_line|#define __EXTERN_INLINE
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/core_t2.h&gt;
DECL|macro|__EXTERN_INLINE
macro_line|#undef __EXTERN_INLINE
macro_line|#include &quot;proto.h&quot;
macro_line|#include &quot;pci_impl.h&quot;
multiline_comment|/* For dumping initial DMA window settings. */
DECL|macro|DEBUG_PRINT_INITIAL_SETTINGS
mdefine_line|#define DEBUG_PRINT_INITIAL_SETTINGS 0
multiline_comment|/* For dumping final DMA window settings. */
DECL|macro|DEBUG_PRINT_FINAL_SETTINGS
mdefine_line|#define DEBUG_PRINT_FINAL_SETTINGS 0
multiline_comment|/*&n; * By default, we direct-map starting at 2GB, in order to allow the&n; * maximum size direct-map window (2GB) to match the maximum amount of&n; * memory (2GB) that can be present on SABLEs. But that limits the&n; * floppy to DMA only via the scatter/gather window set up for 8MB&n; * ISA DMA, since the maximum ISA DMA address is 2GB-1.&n; *&n; * For now, this seems a reasonable trade-off: even though most SABLEs&n; * have less than 1GB of memory, floppy usage/performance will not&n; * really be affected by forcing it to go via scatter/gather...&n; */
DECL|macro|T2_DIRECTMAP_2G
mdefine_line|#define T2_DIRECTMAP_2G 1
macro_line|#if T2_DIRECTMAP_2G
DECL|macro|T2_DIRECTMAP_START
macro_line|# define T2_DIRECTMAP_START&t;0x80000000UL
DECL|macro|T2_DIRECTMAP_LENGTH
macro_line|# define T2_DIRECTMAP_LENGTH&t;0x80000000UL
macro_line|#else
DECL|macro|T2_DIRECTMAP_START
macro_line|# define T2_DIRECTMAP_START&t;0x40000000UL
DECL|macro|T2_DIRECTMAP_LENGTH
macro_line|# define T2_DIRECTMAP_LENGTH&t;0x40000000UL
macro_line|#endif
multiline_comment|/* The ISA scatter/gather window settings. */
DECL|macro|T2_ISA_SG_START
mdefine_line|#define T2_ISA_SG_START&t;&t;0x00800000UL
DECL|macro|T2_ISA_SG_LENGTH
mdefine_line|#define T2_ISA_SG_LENGTH&t;0x00800000UL
multiline_comment|/*&n; * NOTE: Herein lie back-to-back mb instructions.  They are magic. &n; * One plausible explanation is that the i/o controller does not properly&n; * handle the system transaction.  Another involves timing.  Ho hum.&n; */
multiline_comment|/*&n; * BIOS32-style PCI interface:&n; */
DECL|macro|DEBUG_CONFIG
mdefine_line|#define DEBUG_CONFIG 0
macro_line|#if DEBUG_CONFIG
DECL|macro|DBG
macro_line|# define DBG(args)&t;printk args
macro_line|#else
DECL|macro|DBG
macro_line|# define DBG(args)
macro_line|#endif
DECL|variable|t2_mcheck_any_expected
r_static
r_volatile
r_int
r_int
id|t2_mcheck_any_expected
suffix:semicolon
DECL|variable|t2_mcheck_last_taken
r_static
r_volatile
r_int
r_int
id|t2_mcheck_last_taken
suffix:semicolon
multiline_comment|/* Place to save the DMA Window registers as set up by SRM&n;   for restoration during shutdown. */
r_static
r_struct
(brace
r_struct
(brace
DECL|member|wbase
r_int
r_int
id|wbase
suffix:semicolon
DECL|member|wmask
r_int
r_int
id|wmask
suffix:semicolon
DECL|member|tbase
r_int
r_int
id|tbase
suffix:semicolon
DECL|member|window
)brace
id|window
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|hae_1
r_int
r_int
id|hae_1
suffix:semicolon
DECL|member|hae_2
r_int
r_int
id|hae_2
suffix:semicolon
DECL|member|hae_3
r_int
r_int
id|hae_3
suffix:semicolon
DECL|member|hae_4
r_int
r_int
id|hae_4
suffix:semicolon
DECL|member|hbase
r_int
r_int
id|hbase
suffix:semicolon
)brace
id|t2_saved_config
id|__attribute
c_func
(paren
(paren
id|common
)paren
)paren
suffix:semicolon
multiline_comment|/*&n; * Given a bus, device, and function number, compute resulting&n; * configuration space address and setup the T2_HAXR2 register&n; * accordingly.  It is therefore not safe to have concurrent&n; * invocations to configuration space access routines, but there&n; * really shouldn&squot;t be any need for this.&n; *&n; * Type 0:&n; *&n; *  3 3|3 3 2 2|2 2 2 2|2 2 2 2|1 1 1 1|1 1 1 1|1 1 &n; *  3 2|1 0 9 8|7 6 5 4|3 2 1 0|9 8 7 6|5 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0&n; * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&n; * | | |D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|D|F|F|F|R|R|R|R|R|R|0|0|&n; * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&n; *&n; *&t;31:11&t;Device select bit.&n; * &t;10:8&t;Function number&n; * &t; 7:2&t;Register number&n; *&n; * Type 1:&n; *&n; *  3 3|3 3 2 2|2 2 2 2|2 2 2 2|1 1 1 1|1 1 1 1|1 1 &n; *  3 2|1 0 9 8|7 6 5 4|3 2 1 0|9 8 7 6|5 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0&n; * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&n; * | | | | | | | | | | |B|B|B|B|B|B|B|B|D|D|D|D|D|F|F|F|R|R|R|R|R|R|0|1|&n; * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&n; *&n; *&t;31:24&t;reserved&n; *&t;23:16&t;bus number (8 bits = 128 possible buses)&n; *&t;15:11&t;Device number (5 bits)&n; *&t;10:8&t;function number&n; *&t; 7:2&t;register number&n; *  &n; * Notes:&n; *&t;The function number selects which function of a multi-function device &n; *&t;(e.g., SCSI and Ethernet).&n; * &n; *&t;The register selects a DWORD (32 bit) register offset.  Hence it&n; *&t;doesn&squot;t get shifted by 2 bits as we want to &quot;drop&quot; the bottom two&n; *&t;bits.&n; */
r_static
r_int
DECL|function|mk_conf_addr
id|mk_conf_addr
c_func
(paren
r_struct
id|pci_bus
op_star
id|pbus
comma
r_int
r_int
id|device_fn
comma
r_int
id|where
comma
r_int
r_int
op_star
id|pci_addr
comma
r_int
r_char
op_star
id|type1
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
id|u8
id|bus
op_assign
id|pbus-&gt;number
suffix:semicolon
id|DBG
c_func
(paren
(paren
l_string|&quot;mk_conf_addr(bus=%d, dfn=0x%x, where=0x%x,&quot;
l_string|&quot; addr=0x%lx, type1=0x%x)&bslash;n&quot;
comma
id|bus
comma
id|device_fn
comma
id|where
comma
id|pci_addr
comma
id|type1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_eq
l_int|0
)paren
(brace
r_int
id|device
op_assign
id|device_fn
op_rshift
l_int|3
suffix:semicolon
multiline_comment|/* Type 0 configuration cycle.  */
r_if
c_cond
(paren
id|device
OG
l_int|8
)paren
(brace
id|DBG
c_func
(paren
(paren
l_string|&quot;mk_conf_addr: device (%d)&gt;20, returning -1&bslash;n&quot;
comma
id|device
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
op_star
id|type1
op_assign
l_int|0
suffix:semicolon
id|addr
op_assign
(paren
l_int|0x0800L
op_lshift
id|device
)paren
op_or
(paren
(paren
id|device_fn
op_amp
l_int|7
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|where
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Type 1 configuration cycle.  */
op_star
id|type1
op_assign
l_int|1
suffix:semicolon
id|addr
op_assign
(paren
id|bus
op_lshift
l_int|16
)paren
op_or
(paren
id|device_fn
op_lshift
l_int|8
)paren
op_or
(paren
id|where
)paren
suffix:semicolon
)brace
op_star
id|pci_addr
op_assign
id|addr
suffix:semicolon
id|DBG
c_func
(paren
(paren
l_string|&quot;mk_conf_addr: returning pci_addr 0x%lx&bslash;n&quot;
comma
id|addr
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * NOTE: both conf_read() and conf_write() may set HAE_3 when needing&n; *       to do type1 access. This is protected by the use of spinlock IRQ&n; *       primitives in the wrapper functions pci_{read,write}_config_*()&n; *       defined in drivers/pci/pci.c.&n; */
r_static
r_int
r_int
DECL|function|conf_read
id|conf_read
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_char
id|type1
)paren
(brace
r_int
r_int
id|value
comma
id|cpu
comma
id|taken
suffix:semicolon
r_int
r_int
id|t2_cfg
op_assign
l_int|0
suffix:semicolon
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
(paren
l_string|&quot;conf_read(addr=0x%lx, type1=%d)&bslash;n&quot;
comma
id|addr
comma
id|type1
)paren
)paren
suffix:semicolon
multiline_comment|/* If Type1 access, must set T2 CFG.  */
r_if
c_cond
(paren
id|type1
)paren
(brace
id|t2_cfg
op_assign
op_star
(paren
id|vulp
)paren
id|T2_HAE_3
op_amp
op_complement
l_int|0xc0000000UL
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_HAE_3
op_assign
l_int|0x40000000UL
op_or
id|t2_cfg
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
id|mb
c_func
(paren
)paren
suffix:semicolon
id|draina
c_func
(paren
)paren
suffix:semicolon
id|mcheck_expected
c_func
(paren
id|cpu
)paren
op_assign
l_int|1
suffix:semicolon
id|mcheck_taken
c_func
(paren
id|cpu
)paren
op_assign
l_int|0
suffix:semicolon
id|t2_mcheck_any_expected
op_or_assign
(paren
l_int|1
op_lshift
id|cpu
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Access configuration space. */
id|value
op_assign
op_star
(paren
id|vuip
)paren
id|addr
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* magic */
multiline_comment|/* Wait for possible mcheck. Also, this lets other CPUs clear&n;&t;   their mchecks as well, as they can reliably tell when&n;&t;   another CPU is in the midst of handling a real mcheck via&n;&t;   the &quot;taken&quot; function. */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|taken
op_assign
id|mcheck_taken
c_func
(paren
id|cpu
)paren
)paren
)paren
(brace
id|mcheck_taken
c_func
(paren
id|cpu
)paren
op_assign
l_int|0
suffix:semicolon
id|t2_mcheck_last_taken
op_or_assign
(paren
l_int|1
op_lshift
id|cpu
)paren
suffix:semicolon
id|value
op_assign
l_int|0xffffffffU
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
id|mcheck_expected
c_func
(paren
id|cpu
)paren
op_assign
l_int|0
suffix:semicolon
id|t2_mcheck_any_expected
op_assign
l_int|0
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If Type1 access, must reset T2 CFG so normal IO space ops work.  */
r_if
c_cond
(paren
id|type1
)paren
(brace
op_star
(paren
id|vulp
)paren
id|T2_HAE_3
op_assign
id|t2_cfg
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|value
suffix:semicolon
)brace
r_static
r_void
DECL|function|conf_write
id|conf_write
c_func
(paren
r_int
r_int
id|addr
comma
r_int
r_int
id|value
comma
r_int
r_char
id|type1
)paren
(brace
r_int
r_int
id|cpu
comma
id|taken
suffix:semicolon
r_int
r_int
id|t2_cfg
op_assign
l_int|0
suffix:semicolon
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If Type1 access, must set T2 CFG.  */
r_if
c_cond
(paren
id|type1
)paren
(brace
id|t2_cfg
op_assign
op_star
(paren
id|vulp
)paren
id|T2_HAE_3
op_amp
op_complement
l_int|0xc0000000UL
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_HAE_3
op_assign
id|t2_cfg
op_or
l_int|0x40000000UL
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
id|mb
c_func
(paren
)paren
suffix:semicolon
id|draina
c_func
(paren
)paren
suffix:semicolon
id|mcheck_expected
c_func
(paren
id|cpu
)paren
op_assign
l_int|1
suffix:semicolon
id|mcheck_taken
c_func
(paren
id|cpu
)paren
op_assign
l_int|0
suffix:semicolon
id|t2_mcheck_any_expected
op_or_assign
(paren
l_int|1
op_lshift
id|cpu
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Access configuration space.  */
op_star
(paren
id|vuip
)paren
id|addr
op_assign
id|value
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* magic */
multiline_comment|/* Wait for possible mcheck. Also, this lets other CPUs clear&n;&t;   their mchecks as well, as they can reliably tell when&n;&t;   this CPU is in the midst of handling a real mcheck via&n;&t;   the &quot;taken&quot; function. */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|taken
op_assign
id|mcheck_taken
c_func
(paren
id|cpu
)paren
)paren
)paren
(brace
id|mcheck_taken
c_func
(paren
id|cpu
)paren
op_assign
l_int|0
suffix:semicolon
id|t2_mcheck_last_taken
op_or_assign
(paren
l_int|1
op_lshift
id|cpu
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
id|mcheck_expected
c_func
(paren
id|cpu
)paren
op_assign
l_int|0
suffix:semicolon
id|t2_mcheck_any_expected
op_assign
l_int|0
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If Type1 access, must reset T2 CFG so normal IO space ops work.  */
r_if
c_cond
(paren
id|type1
)paren
(brace
op_star
(paren
id|vulp
)paren
id|T2_HAE_3
op_assign
id|t2_cfg
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|t2_read_config
id|t2_read_config
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
comma
r_int
r_int
id|devfn
comma
r_int
id|where
comma
r_int
id|size
comma
id|u32
op_star
id|value
)paren
(brace
r_int
r_int
id|addr
comma
id|pci_addr
suffix:semicolon
r_int
r_char
id|type1
suffix:semicolon
r_int
id|shift
suffix:semicolon
r_int
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|mk_conf_addr
c_func
(paren
id|bus
comma
id|devfn
comma
id|where
comma
op_amp
id|pci_addr
comma
op_amp
id|type1
)paren
)paren
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
id|mask
op_assign
(paren
id|size
op_minus
l_int|1
)paren
op_star
l_int|8
suffix:semicolon
id|shift
op_assign
(paren
id|where
op_amp
l_int|3
)paren
op_star
l_int|8
suffix:semicolon
id|addr
op_assign
(paren
id|pci_addr
op_lshift
l_int|5
)paren
op_plus
id|mask
op_plus
id|T2_CONF
suffix:semicolon
op_star
id|value
op_assign
id|conf_read
c_func
(paren
id|addr
comma
id|type1
)paren
op_rshift
(paren
id|shift
)paren
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
r_static
r_int
DECL|function|t2_write_config
id|t2_write_config
c_func
(paren
r_struct
id|pci_bus
op_star
id|bus
comma
r_int
r_int
id|devfn
comma
r_int
id|where
comma
r_int
id|size
comma
id|u32
id|value
)paren
(brace
r_int
r_int
id|addr
comma
id|pci_addr
suffix:semicolon
r_int
r_char
id|type1
suffix:semicolon
r_int
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|mk_conf_addr
c_func
(paren
id|bus
comma
id|devfn
comma
id|where
comma
op_amp
id|pci_addr
comma
op_amp
id|type1
)paren
)paren
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
id|mask
op_assign
(paren
id|size
op_minus
l_int|1
)paren
op_star
l_int|8
suffix:semicolon
id|addr
op_assign
(paren
id|pci_addr
op_lshift
l_int|5
)paren
op_plus
id|mask
op_plus
id|T2_CONF
suffix:semicolon
id|conf_write
c_func
(paren
id|addr
comma
id|value
op_lshift
(paren
(paren
id|where
op_amp
l_int|3
)paren
op_star
l_int|8
)paren
comma
id|type1
)paren
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|variable|t2_pci_ops
r_struct
id|pci_ops
id|t2_pci_ops
op_assign
(brace
dot
id|read
op_assign
id|t2_read_config
comma
dot
id|write
op_assign
id|t2_write_config
comma
)brace
suffix:semicolon
"&f;"
r_static
r_void
id|__init
DECL|function|t2_direct_map_window1
id|t2_direct_map_window1
c_func
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|length
)paren
(brace
r_int
r_int
id|temp
suffix:semicolon
id|__direct_map_base
op_assign
id|base
suffix:semicolon
id|__direct_map_size
op_assign
id|length
suffix:semicolon
id|temp
op_assign
(paren
id|base
op_amp
l_int|0xfff00000UL
)paren
op_or
(paren
(paren
id|base
op_plus
id|length
op_minus
l_int|1
)paren
op_rshift
l_int|20
)paren
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_WBASE1
op_assign
id|temp
op_or
l_int|0x80000UL
suffix:semicolon
multiline_comment|/* OR in ENABLE bit */
id|temp
op_assign
(paren
id|length
op_minus
l_int|1
)paren
op_amp
l_int|0xfff00000UL
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_WMASK1
op_assign
id|temp
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_TBASE1
op_assign
l_int|0
suffix:semicolon
macro_line|#if DEBUG_PRINT_FINAL_SETTINGS
id|printk
c_func
(paren
l_string|&quot;%s: setting WBASE1=0x%lx WMASK1=0x%lx TBASE1=0x%lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
op_star
(paren
id|vulp
)paren
id|T2_WBASE1
comma
op_star
(paren
id|vulp
)paren
id|T2_WMASK1
comma
op_star
(paren
id|vulp
)paren
id|T2_TBASE1
)paren
suffix:semicolon
macro_line|#endif
)brace
r_static
r_void
id|__init
DECL|function|t2_sg_map_window2
id|t2_sg_map_window2
c_func
(paren
r_struct
id|pci_controller
op_star
id|hose
comma
r_int
r_int
id|base
comma
r_int
r_int
id|length
)paren
(brace
r_int
r_int
id|temp
suffix:semicolon
multiline_comment|/* Note we can only do 1 SG window, as the other is for direct, so&n;&t;   do an ISA SG area, especially for the floppy. */
id|hose-&gt;sg_isa
op_assign
id|iommu_arena_new
c_func
(paren
id|hose
comma
id|base
comma
id|length
comma
l_int|0
)paren
suffix:semicolon
id|hose-&gt;sg_pci
op_assign
l_int|NULL
suffix:semicolon
id|temp
op_assign
(paren
id|base
op_amp
l_int|0xfff00000UL
)paren
op_or
(paren
(paren
id|base
op_plus
id|length
op_minus
l_int|1
)paren
op_rshift
l_int|20
)paren
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_WBASE2
op_assign
id|temp
op_or
l_int|0xc0000UL
suffix:semicolon
multiline_comment|/* OR in ENABLE/SG bits */
id|temp
op_assign
(paren
id|length
op_minus
l_int|1
)paren
op_amp
l_int|0xfff00000UL
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_WMASK2
op_assign
id|temp
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_TBASE2
op_assign
id|virt_to_phys
c_func
(paren
id|hose-&gt;sg_isa-&gt;ptes
)paren
op_rshift
l_int|1
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|t2_pci_tbi
c_func
(paren
id|hose
comma
l_int|0
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* flush TLB all */
macro_line|#if DEBUG_PRINT_FINAL_SETTINGS
id|printk
c_func
(paren
l_string|&quot;%s: setting WBASE2=0x%lx WMASK2=0x%lx TBASE2=0x%lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
op_star
(paren
id|vulp
)paren
id|T2_WBASE2
comma
op_star
(paren
id|vulp
)paren
id|T2_WMASK2
comma
op_star
(paren
id|vulp
)paren
id|T2_TBASE2
)paren
suffix:semicolon
macro_line|#endif
)brace
r_static
r_void
id|__init
DECL|function|t2_save_configuration
id|t2_save_configuration
c_func
(paren
r_void
)paren
(brace
macro_line|#if DEBUG_PRINT_INITIAL_SETTINGS
id|printk
c_func
(paren
l_string|&quot;%s: HAE_1 was 0x%lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|srm_hae
)paren
suffix:semicolon
multiline_comment|/* HW is 0 */
id|printk
c_func
(paren
l_string|&quot;%s: HAE_2 was 0x%lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
op_star
(paren
id|vulp
)paren
id|T2_HAE_2
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: HAE_3 was 0x%lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
op_star
(paren
id|vulp
)paren
id|T2_HAE_3
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: HAE_4 was 0x%lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
op_star
(paren
id|vulp
)paren
id|T2_HAE_4
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: HBASE was 0x%lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
op_star
(paren
id|vulp
)paren
id|T2_HBASE
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: WBASE1=0x%lx WMASK1=0x%lx TBASE1=0x%lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
op_star
(paren
id|vulp
)paren
id|T2_WBASE1
comma
op_star
(paren
id|vulp
)paren
id|T2_WMASK1
comma
op_star
(paren
id|vulp
)paren
id|T2_TBASE1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: WBASE2=0x%lx WMASK2=0x%lx TBASE2=0x%lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
op_star
(paren
id|vulp
)paren
id|T2_WBASE2
comma
op_star
(paren
id|vulp
)paren
id|T2_WMASK2
comma
op_star
(paren
id|vulp
)paren
id|T2_TBASE2
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Save the DMA Window registers.&n;&t; */
id|t2_saved_config.window
(braket
l_int|0
)braket
dot
id|wbase
op_assign
op_star
(paren
id|vulp
)paren
id|T2_WBASE1
suffix:semicolon
id|t2_saved_config.window
(braket
l_int|0
)braket
dot
id|wmask
op_assign
op_star
(paren
id|vulp
)paren
id|T2_WMASK1
suffix:semicolon
id|t2_saved_config.window
(braket
l_int|0
)braket
dot
id|tbase
op_assign
op_star
(paren
id|vulp
)paren
id|T2_TBASE1
suffix:semicolon
id|t2_saved_config.window
(braket
l_int|1
)braket
dot
id|wbase
op_assign
op_star
(paren
id|vulp
)paren
id|T2_WBASE2
suffix:semicolon
id|t2_saved_config.window
(braket
l_int|1
)braket
dot
id|wmask
op_assign
op_star
(paren
id|vulp
)paren
id|T2_WMASK2
suffix:semicolon
id|t2_saved_config.window
(braket
l_int|1
)braket
dot
id|tbase
op_assign
op_star
(paren
id|vulp
)paren
id|T2_TBASE2
suffix:semicolon
id|t2_saved_config.hae_1
op_assign
id|srm_hae
suffix:semicolon
multiline_comment|/* HW is already set to 0 */
id|t2_saved_config.hae_2
op_assign
op_star
(paren
id|vulp
)paren
id|T2_HAE_2
suffix:semicolon
id|t2_saved_config.hae_3
op_assign
op_star
(paren
id|vulp
)paren
id|T2_HAE_3
suffix:semicolon
id|t2_saved_config.hae_4
op_assign
op_star
(paren
id|vulp
)paren
id|T2_HAE_4
suffix:semicolon
id|t2_saved_config.hbase
op_assign
op_star
(paren
id|vulp
)paren
id|T2_HBASE
suffix:semicolon
)brace
r_void
id|__init
DECL|function|t2_init_arch
id|t2_init_arch
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_controller
op_star
id|hose
suffix:semicolon
r_int
r_int
id|temp
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mcheck_expected
c_func
(paren
id|i
)paren
op_assign
l_int|0
suffix:semicolon
id|mcheck_taken
c_func
(paren
id|i
)paren
op_assign
l_int|0
suffix:semicolon
)brace
id|t2_mcheck_any_expected
op_assign
l_int|0
suffix:semicolon
id|t2_mcheck_last_taken
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Enable scatter/gather TLB use.  */
id|temp
op_assign
op_star
(paren
id|vulp
)paren
id|T2_IOCSR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|temp
op_amp
(paren
l_int|0x1UL
op_lshift
l_int|26
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;t2_init_arch: enabling SG TLB, IOCSR was 0x%lx&bslash;n&quot;
comma
id|temp
)paren
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_IOCSR
op_assign
id|temp
op_or
(paren
l_int|0x1UL
op_lshift
l_int|26
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_IOCSR
suffix:semicolon
multiline_comment|/* read it back to make sure */
)brace
id|t2_save_configuration
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Create our single hose.&n;&t; */
id|pci_isa_hose
op_assign
id|hose
op_assign
id|alloc_pci_controller
c_func
(paren
)paren
suffix:semicolon
id|hose-&gt;io_space
op_assign
op_amp
id|ioport_resource
suffix:semicolon
id|hose-&gt;mem_space
op_assign
op_amp
id|iomem_resource
suffix:semicolon
id|hose-&gt;index
op_assign
l_int|0
suffix:semicolon
id|hose-&gt;sparse_mem_base
op_assign
id|T2_SPARSE_MEM
op_minus
id|IDENT_ADDR
suffix:semicolon
id|hose-&gt;dense_mem_base
op_assign
id|T2_DENSE_MEM
op_minus
id|IDENT_ADDR
suffix:semicolon
id|hose-&gt;sparse_io_base
op_assign
id|T2_IO
op_minus
id|IDENT_ADDR
suffix:semicolon
id|hose-&gt;dense_io_base
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Set up the PCI-&gt;physical memory translation windows.&n;&t; *&n;&t; * Window 1 is direct mapped.&n;&t; * Window 2 is scatter/gather (for ISA).&n;&t; */
id|t2_direct_map_window1
c_func
(paren
id|T2_DIRECTMAP_START
comma
id|T2_DIRECTMAP_LENGTH
)paren
suffix:semicolon
multiline_comment|/* Always make an ISA DMA window. */
id|t2_sg_map_window2
c_func
(paren
id|hose
comma
id|T2_ISA_SG_START
comma
id|T2_ISA_SG_LENGTH
)paren
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_HBASE
op_assign
l_int|0x0
suffix:semicolon
multiline_comment|/* Disable HOLES. */
multiline_comment|/* Zero HAE.  */
op_star
(paren
id|vulp
)paren
id|T2_HAE_1
op_assign
l_int|0
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Sparse MEM HAE */
op_star
(paren
id|vulp
)paren
id|T2_HAE_2
op_assign
l_int|0
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Sparse I/O HAE */
op_star
(paren
id|vulp
)paren
id|T2_HAE_3
op_assign
l_int|0
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Config Space HAE */
multiline_comment|/*&n;&t; * We also now zero out HAE_4, the dense memory HAE, so that&n;&t; * we need not account for its &quot;offset&quot; when accessing dense&n;&t; * memory resources which we allocated in our normal way. This&n;&t; * HAE would need to stay untouched were we to keep the SRM&n;&t; * resource settings.&n;&t; *&n;&t; * Thus we can now run standard X servers on SABLE/LYNX. :-)&n;&t; */
op_star
(paren
id|vulp
)paren
id|T2_HAE_4
op_assign
l_int|0
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|t2_kill_arch
id|t2_kill_arch
c_func
(paren
r_int
id|mode
)paren
(brace
multiline_comment|/*&n;&t; * Restore the DMA Window registers.&n;&t; */
op_star
(paren
id|vulp
)paren
id|T2_WBASE1
op_assign
id|t2_saved_config.window
(braket
l_int|0
)braket
dot
id|wbase
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_WMASK1
op_assign
id|t2_saved_config.window
(braket
l_int|0
)braket
dot
id|wmask
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_TBASE1
op_assign
id|t2_saved_config.window
(braket
l_int|0
)braket
dot
id|tbase
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_WBASE2
op_assign
id|t2_saved_config.window
(braket
l_int|1
)braket
dot
id|wbase
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_WMASK2
op_assign
id|t2_saved_config.window
(braket
l_int|1
)braket
dot
id|wmask
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_TBASE2
op_assign
id|t2_saved_config.window
(braket
l_int|1
)braket
dot
id|tbase
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_HAE_1
op_assign
id|srm_hae
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_HAE_2
op_assign
id|t2_saved_config.hae_2
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_HAE_3
op_assign
id|t2_saved_config.hae_3
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_HAE_4
op_assign
id|t2_saved_config.hae_4
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_HBASE
op_assign
id|t2_saved_config.hbase
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_HBASE
suffix:semicolon
multiline_comment|/* READ it back to ensure WRITE occurred. */
)brace
r_void
DECL|function|t2_pci_tbi
id|t2_pci_tbi
c_func
(paren
r_struct
id|pci_controller
op_star
id|hose
comma
id|dma_addr_t
id|start
comma
id|dma_addr_t
id|end
)paren
(brace
r_int
r_int
id|t2_iocsr
suffix:semicolon
id|t2_iocsr
op_assign
op_star
(paren
id|vulp
)paren
id|T2_IOCSR
suffix:semicolon
multiline_comment|/* set the TLB Clear bit */
op_star
(paren
id|vulp
)paren
id|T2_IOCSR
op_assign
id|t2_iocsr
op_or
(paren
l_int|0x1UL
op_lshift
l_int|28
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_IOCSR
suffix:semicolon
multiline_comment|/* read it back to make sure */
multiline_comment|/* clear the TLB Clear bit */
op_star
(paren
id|vulp
)paren
id|T2_IOCSR
op_assign
id|t2_iocsr
op_amp
op_complement
(paren
l_int|0x1UL
op_lshift
l_int|28
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_IOCSR
suffix:semicolon
multiline_comment|/* read it back to make sure */
)brace
DECL|macro|SIC_SEIC
mdefine_line|#define SIC_SEIC (1UL &lt;&lt; 33)    /* System Event Clear */
r_static
r_void
DECL|function|t2_clear_errors
id|t2_clear_errors
c_func
(paren
r_int
id|cpu
)paren
(brace
r_struct
id|sable_cpu_csr
op_star
id|cpu_regs
suffix:semicolon
id|cpu_regs
op_assign
(paren
r_struct
id|sable_cpu_csr
op_star
)paren
id|T2_CPUn_BASE
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|cpu_regs-&gt;sic
op_and_assign
op_complement
id|SIC_SEIC
suffix:semicolon
multiline_comment|/* Clear CPU errors.  */
id|cpu_regs-&gt;bcce
op_or_assign
id|cpu_regs-&gt;bcce
suffix:semicolon
id|cpu_regs-&gt;cbe
op_or_assign
id|cpu_regs-&gt;cbe
suffix:semicolon
id|cpu_regs-&gt;bcue
op_or_assign
id|cpu_regs-&gt;bcue
suffix:semicolon
id|cpu_regs-&gt;dter
op_or_assign
id|cpu_regs-&gt;dter
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_CERR1
op_or_assign
op_star
(paren
id|vulp
)paren
id|T2_CERR1
suffix:semicolon
op_star
(paren
id|vulp
)paren
id|T2_PERR1
op_or_assign
op_star
(paren
id|vulp
)paren
id|T2_PERR1
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* magic */
)brace
multiline_comment|/*&n; * SABLE seems to have a &quot;broadcast&quot; style machine check, in that all&n; * CPUs receive it. And, the issuing CPU, in the case of PCI Config&n; * space read/write faults, will also receive a second mcheck, upon&n; * lowering IPL during completion processing in pci_read_config_byte()&n; * et al.&n; *&n; * Hence all the taken/expected/any_expected/last_taken stuff...&n; */
r_void
DECL|function|t2_machine_check
id|t2_machine_check
c_func
(paren
r_int
r_int
id|vector
comma
r_int
r_int
id|la_ptr
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
macro_line|#if DEBUG_MCHECK &gt; 0
r_struct
id|el_common
op_star
id|mchk_header
op_assign
(paren
r_struct
id|el_common
op_star
)paren
id|la_ptr
suffix:semicolon
macro_line|#endif /* DEBUG_MCHECK */
multiline_comment|/* Clear the error before any reporting.  */
id|mb
c_func
(paren
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* magic */
id|draina
c_func
(paren
)paren
suffix:semicolon
id|t2_clear_errors
c_func
(paren
id|cpu
)paren
suffix:semicolon
multiline_comment|/* This should not actually be done until the logout frame is&n;&t;   examined, but, since we don&squot;t do that, go on and do this... */
id|wrmces
c_func
(paren
l_int|0x7
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Now, do testing for the anomalous conditions. */
r_if
c_cond
(paren
op_logical_neg
id|mcheck_expected
c_func
(paren
id|cpu
)paren
op_logical_and
id|t2_mcheck_any_expected
)paren
(brace
multiline_comment|/*&n;&t;&t; * FUNKY: Received mcheck on a CPU and not&n;&t;&t; * expecting it, but another CPU is expecting one.&n;&t;&t; *&n;&t;&t; * Just dismiss it for now on this CPU...&n;&t;&t; */
macro_line|#if DEBUG_MCHECK &gt; 0
id|printk
c_func
(paren
l_string|&quot;t2_machine_check(cpu%d): any_expected 0x%x -&quot;
l_string|&quot; (assumed) spurious -&quot;
l_string|&quot; code 0x%x&bslash;n&quot;
comma
id|cpu
comma
id|t2_mcheck_any_expected
comma
(paren
r_int
r_int
)paren
id|mchk_header-&gt;code
)paren
suffix:semicolon
macro_line|#endif /* DEBUG_MCHECK */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mcheck_expected
c_func
(paren
id|cpu
)paren
op_logical_and
op_logical_neg
id|t2_mcheck_any_expected
)paren
(brace
r_if
c_cond
(paren
id|t2_mcheck_last_taken
op_amp
(paren
l_int|1
op_lshift
id|cpu
)paren
)paren
(brace
macro_line|#if DEBUG_MCHECK &gt; 0
id|printk
c_func
(paren
l_string|&quot;t2_machine_check(cpu%d): last_taken 0x%x - &quot;
l_string|&quot;unexpected mcheck - code 0x%x&bslash;n&quot;
comma
id|cpu
comma
id|t2_mcheck_last_taken
comma
(paren
r_int
r_int
)paren
id|mchk_header-&gt;code
)paren
suffix:semicolon
macro_line|#endif /* DEBUG_MCHECK */
id|t2_mcheck_last_taken
op_assign
l_int|0
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|t2_mcheck_last_taken
op_assign
l_int|0
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#if DEBUG_MCHECK &gt; 0
id|printk
c_func
(paren
l_string|&quot;%s t2_mcheck(cpu%d): last_taken 0x%x - &quot;
l_string|&quot;any_expected 0x%x - code 0x%x&bslash;n&quot;
comma
(paren
id|mcheck_expected
c_func
(paren
id|cpu
)paren
ques
c_cond
l_string|&quot;EX&quot;
suffix:colon
l_string|&quot;UN&quot;
)paren
comma
id|cpu
comma
id|t2_mcheck_last_taken
comma
id|t2_mcheck_any_expected
comma
(paren
r_int
r_int
)paren
id|mchk_header-&gt;code
)paren
suffix:semicolon
macro_line|#endif /* DEBUG_MCHECK */
id|process_mcheck_info
c_func
(paren
id|vector
comma
id|la_ptr
comma
id|regs
comma
l_string|&quot;T2&quot;
comma
id|mcheck_expected
c_func
(paren
id|cpu
)paren
)paren
suffix:semicolon
)brace
eof
