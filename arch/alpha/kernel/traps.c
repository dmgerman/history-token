multiline_comment|/*&n; * arch/alpha/kernel/traps.c&n; *&n; * (C) Copyright 1994 Linus Torvalds&n; */
multiline_comment|/*&n; * This file initializes the trap entry points&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kallsyms.h&gt;
macro_line|#include &lt;asm/gentrap.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
macro_line|#include &lt;asm/sysinfo.h&gt;
macro_line|#include &lt;asm/hwrpb.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &quot;proto.h&quot;
multiline_comment|/* Work-around for some SRMs which mishandle opDEC faults.  */
DECL|variable|opDEC_fix
r_static
r_int
id|opDEC_fix
suffix:semicolon
r_static
r_void
id|__init
DECL|function|opDEC_check
id|opDEC_check
c_func
(paren
r_void
)paren
(brace
id|__asm__
id|__volatile__
(paren
multiline_comment|/* Load the address of... */
l_string|&quot;&t;br&t;$16, 1f&bslash;n&quot;
multiline_comment|/* A stub instruction fault handler.  Just add 4 to the&n;&t;   pc and continue.  */
l_string|&quot;&t;ldq&t;$16, 8($sp)&bslash;n&quot;
l_string|&quot;&t;addq&t;$16, 4, $16&bslash;n&quot;
l_string|&quot;&t;stq&t;$16, 8($sp)&bslash;n&quot;
l_string|&quot;&t;call_pal %[rti]&bslash;n&quot;
multiline_comment|/* Install the instruction fault handler.  */
l_string|&quot;1:&t;lda&t;$17, 3&bslash;n&quot;
l_string|&quot;&t;call_pal %[wrent]&bslash;n&quot;
multiline_comment|/* With that in place, the fault from the round-to-minf fp&n;&t;   insn will arrive either at the &quot;lda 4&quot; insn (bad) or one&n;&t;   past that (good).  This places the correct fixup in %0.  */
l_string|&quot;&t;lda %[fix], 0&bslash;n&quot;
l_string|&quot;&t;cvttq/svm $f31,$f31&bslash;n&quot;
l_string|&quot;&t;lda %[fix], 4&quot;
suffix:colon
(braket
id|fix
)braket
l_string|&quot;=r&quot;
(paren
id|opDEC_fix
)paren
suffix:colon
(braket
id|rti
)braket
l_string|&quot;n&quot;
(paren
id|PAL_rti
)paren
comma
(braket
id|wrent
)braket
l_string|&quot;n&quot;
(paren
id|PAL_wrent
)paren
suffix:colon
l_string|&quot;$0&quot;
comma
l_string|&quot;$1&quot;
comma
l_string|&quot;$16&quot;
comma
l_string|&quot;$17&quot;
comma
l_string|&quot;$22&quot;
comma
l_string|&quot;$23&quot;
comma
l_string|&quot;$24&quot;
comma
l_string|&quot;$25&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opDEC_fix
)paren
id|printk
c_func
(paren
l_string|&quot;opDEC fixup enabled.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_void
DECL|function|dik_show_regs
id|dik_show_regs
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
op_star
id|r9_15
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pc = [&lt;%016lx&gt;]  ra = [&lt;%016lx&gt;]  ps = %04lx    %s&bslash;n&quot;
comma
id|regs-&gt;pc
comma
id|regs-&gt;r26
comma
id|regs-&gt;ps
comma
id|print_tainted
c_func
(paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;v0 = %016lx  t0 = %016lx  t1 = %016lx&bslash;n&quot;
comma
id|regs-&gt;r0
comma
id|regs-&gt;r1
comma
id|regs-&gt;r2
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;t2 = %016lx  t3 = %016lx  t4 = %016lx&bslash;n&quot;
comma
id|regs-&gt;r3
comma
id|regs-&gt;r4
comma
id|regs-&gt;r5
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;t5 = %016lx  t6 = %016lx  t7 = %016lx&bslash;n&quot;
comma
id|regs-&gt;r6
comma
id|regs-&gt;r7
comma
id|regs-&gt;r8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r9_15
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;s0 = %016lx  s1 = %016lx  s2 = %016lx&bslash;n&quot;
comma
id|r9_15
(braket
l_int|9
)braket
comma
id|r9_15
(braket
l_int|10
)braket
comma
id|r9_15
(braket
l_int|11
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;s3 = %016lx  s4 = %016lx  s5 = %016lx&bslash;n&quot;
comma
id|r9_15
(braket
l_int|12
)braket
comma
id|r9_15
(braket
l_int|13
)braket
comma
id|r9_15
(braket
l_int|14
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;s6 = %016lx&bslash;n&quot;
comma
id|r9_15
(braket
l_int|15
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;a0 = %016lx  a1 = %016lx  a2 = %016lx&bslash;n&quot;
comma
id|regs-&gt;r16
comma
id|regs-&gt;r17
comma
id|regs-&gt;r18
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;a3 = %016lx  a4 = %016lx  a5 = %016lx&bslash;n&quot;
comma
id|regs-&gt;r19
comma
id|regs-&gt;r20
comma
id|regs-&gt;r21
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;t8 = %016lx  t9 = %016lx  t10= %016lx&bslash;n&quot;
comma
id|regs-&gt;r22
comma
id|regs-&gt;r23
comma
id|regs-&gt;r24
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;t11= %016lx  pv = %016lx  at = %016lx&bslash;n&quot;
comma
id|regs-&gt;r25
comma
id|regs-&gt;r27
comma
id|regs-&gt;r28
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;gp = %016lx  sp = %p&bslash;n&quot;
comma
id|regs-&gt;gp
comma
id|regs
op_plus
l_int|1
)paren
suffix:semicolon
macro_line|#if 0
id|__halt
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#if 0
r_static
r_char
op_star
id|ireg_name
(braket
)braket
op_assign
(brace
l_string|&quot;v0&quot;
comma
l_string|&quot;t0&quot;
comma
l_string|&quot;t1&quot;
comma
l_string|&quot;t2&quot;
comma
l_string|&quot;t3&quot;
comma
l_string|&quot;t4&quot;
comma
l_string|&quot;t5&quot;
comma
l_string|&quot;t6&quot;
comma
l_string|&quot;t7&quot;
comma
l_string|&quot;s0&quot;
comma
l_string|&quot;s1&quot;
comma
l_string|&quot;s2&quot;
comma
l_string|&quot;s3&quot;
comma
l_string|&quot;s4&quot;
comma
l_string|&quot;s5&quot;
comma
l_string|&quot;s6&quot;
comma
l_string|&quot;a0&quot;
comma
l_string|&quot;a1&quot;
comma
l_string|&quot;a2&quot;
comma
l_string|&quot;a3&quot;
comma
l_string|&quot;a4&quot;
comma
l_string|&quot;a5&quot;
comma
l_string|&quot;t8&quot;
comma
l_string|&quot;t9&quot;
comma
l_string|&quot;t10&quot;
comma
l_string|&quot;t11&quot;
comma
l_string|&quot;ra&quot;
comma
l_string|&quot;pv&quot;
comma
l_string|&quot;at&quot;
comma
l_string|&quot;gp&quot;
comma
l_string|&quot;sp&quot;
comma
l_string|&quot;zero&quot;
)brace
suffix:semicolon
macro_line|#endif
r_static
r_void
DECL|function|dik_show_code
id|dik_show_code
c_func
(paren
r_int
r_int
op_star
id|pc
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Code:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
op_minus
l_int|6
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|insn
suffix:semicolon
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|insn
comma
id|pc
op_plus
id|i
)paren
)paren
r_break
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%c%08x%c&quot;
comma
id|i
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;&lt;&squot;
comma
id|insn
comma
id|i
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;&gt;&squot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|dik_show_trace
id|dik_show_trace
c_func
(paren
r_int
r_int
op_star
id|sp
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Trace:&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|0x1ff8
op_amp
(paren
r_int
r_int
)paren
id|sp
)paren
(brace
r_extern
r_char
id|_stext
(braket
)braket
comma
id|_etext
(braket
)braket
suffix:semicolon
r_int
r_int
id|tmp
op_assign
op_star
id|sp
suffix:semicolon
id|sp
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
(paren
r_int
r_int
)paren
op_amp
id|_stext
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_ge
(paren
r_int
r_int
)paren
op_amp
id|_etext
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;[&lt;%lx&gt;]&quot;
comma
id|tmp
)paren
suffix:semicolon
id|print_symbol
c_func
(paren
l_string|&quot; %s&quot;
comma
id|tmp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|40
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; ...&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|kstack_depth_to_print
r_static
r_int
id|kstack_depth_to_print
op_assign
l_int|24
suffix:semicolon
DECL|function|show_stack
r_void
id|show_stack
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
r_int
op_star
id|sp
)paren
(brace
r_int
r_int
op_star
id|stack
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * debugging aid: &quot;show_stack(NULL);&quot; prints the&n;&t; * back trace for this cpu.&n;&t; */
r_if
c_cond
(paren
id|sp
op_eq
l_int|NULL
)paren
(brace
id|sp
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
id|sp
suffix:semicolon
)brace
id|stack
op_assign
id|sp
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|kstack_depth_to_print
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|stack
op_amp
(paren
id|THREAD_SIZE
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_logical_and
(paren
(paren
id|i
op_mod
l_int|4
)paren
op_eq
l_int|0
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n       &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%016lx &quot;
comma
op_star
id|stack
op_increment
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|dik_show_trace
c_func
(paren
id|sp
)paren
suffix:semicolon
)brace
DECL|function|dump_stack
r_void
id|dump_stack
c_func
(paren
r_void
)paren
(brace
id|show_stack
c_func
(paren
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|variable|dump_stack
id|EXPORT_SYMBOL
c_func
(paren
id|dump_stack
)paren
suffix:semicolon
r_void
DECL|function|die_if_kernel
id|die_if_kernel
c_func
(paren
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
comma
r_int
r_int
op_star
id|r9_15
)paren
(brace
r_if
c_cond
(paren
id|regs-&gt;ps
op_amp
l_int|8
)paren
r_return
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|printk
c_func
(paren
l_string|&quot;CPU %d &quot;
comma
id|hard_smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;%s(%d): %s %ld&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
id|str
comma
id|err
)paren
suffix:semicolon
id|dik_show_regs
c_func
(paren
id|regs
comma
id|r9_15
)paren
suffix:semicolon
id|dik_show_trace
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|regs
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|dik_show_code
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|regs-&gt;pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_thread_flag
(paren
id|TIF_DIE_IF_KERNEL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;die_if_kernel recursion detected.&bslash;n&quot;
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_MATHEMU
DECL|function|dummy_emul
r_static
r_int
id|dummy_emul
c_func
(paren
r_void
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|alpha_fp_emul_imprecise
r_int
(paren
op_star
id|alpha_fp_emul_imprecise
)paren
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|writemask
)paren
op_assign
(paren
r_void
op_star
)paren
id|dummy_emul
suffix:semicolon
DECL|variable|alpha_fp_emul
r_int
(paren
op_star
id|alpha_fp_emul
)paren
(paren
r_int
r_int
id|pc
)paren
op_assign
(paren
r_void
op_star
)paren
id|dummy_emul
suffix:semicolon
macro_line|#else
r_int
id|alpha_fp_emul_imprecise
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|writemask
)paren
suffix:semicolon
r_int
id|alpha_fp_emul
(paren
r_int
r_int
id|pc
)paren
suffix:semicolon
macro_line|#endif
id|asmlinkage
r_void
DECL|function|do_entArith
id|do_entArith
c_func
(paren
r_int
r_int
id|summary
comma
r_int
r_int
id|write_mask
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|si_code
op_assign
id|FPE_FLTINV
suffix:semicolon
id|siginfo_t
id|info
suffix:semicolon
r_if
c_cond
(paren
id|summary
op_amp
l_int|1
)paren
(brace
multiline_comment|/* Software-completion summary bit is set, so try to&n;&t;&t;   emulate the instruction.  If the processor supports&n;&t;&t;   precise exceptions, we don&squot;t have to search.  */
r_if
c_cond
(paren
op_logical_neg
id|amask
c_func
(paren
id|AMASK_PRECISE_TRAP
)paren
)paren
id|si_code
op_assign
id|alpha_fp_emul
c_func
(paren
id|regs-&gt;pc
op_minus
l_int|4
)paren
suffix:semicolon
r_else
id|si_code
op_assign
id|alpha_fp_emul_imprecise
c_func
(paren
id|regs
comma
id|write_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|si_code
op_eq
l_int|0
)paren
r_return
suffix:semicolon
)brace
id|die_if_kernel
c_func
(paren
l_string|&quot;Arithmetic fault&quot;
comma
id|regs
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|info.si_signo
op_assign
id|SIGFPE
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
id|info.si_code
op_assign
id|si_code
suffix:semicolon
id|info.si_addr
op_assign
(paren
r_void
op_star
)paren
id|regs-&gt;pc
suffix:semicolon
id|send_sig_info
c_func
(paren
id|SIGFPE
comma
op_amp
id|info
comma
id|current
)paren
suffix:semicolon
)brace
id|asmlinkage
r_void
DECL|function|do_entIF
id|do_entIF
c_func
(paren
r_int
r_int
id|type
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|siginfo_t
id|info
suffix:semicolon
r_int
id|signo
comma
id|code
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;ps
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|type
op_eq
l_int|1
)paren
(brace
r_const
r_int
r_int
op_star
id|data
op_assign
(paren
r_const
r_int
r_int
op_star
)paren
id|regs-&gt;pc
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Kernel bug at %s:%d&bslash;n&quot;
comma
(paren
r_const
r_char
op_star
)paren
(paren
id|data
(braket
l_int|1
)braket
op_or
(paren
r_int
)paren
id|data
(braket
l_int|2
)braket
op_lshift
l_int|32
)paren
comma
id|data
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
id|die_if_kernel
c_func
(paren
(paren
id|type
op_eq
l_int|1
ques
c_cond
l_string|&quot;Kernel Bug&quot;
suffix:colon
l_string|&quot;Instruction fault&quot;
)paren
comma
id|regs
comma
id|type
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* breakpoint */
id|info.si_signo
op_assign
id|SIGTRAP
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
id|info.si_code
op_assign
id|TRAP_BRKPT
suffix:semicolon
id|info.si_trapno
op_assign
l_int|0
suffix:semicolon
id|info.si_addr
op_assign
(paren
r_void
op_star
)paren
id|regs-&gt;pc
suffix:semicolon
r_if
c_cond
(paren
id|ptrace_cancel_bpt
c_func
(paren
id|current
)paren
)paren
(brace
id|regs-&gt;pc
op_sub_assign
l_int|4
suffix:semicolon
multiline_comment|/* make pc point to former bpt */
)brace
id|send_sig_info
c_func
(paren
id|SIGTRAP
comma
op_amp
id|info
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* bugcheck */
id|info.si_signo
op_assign
id|SIGTRAP
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
id|info.si_code
op_assign
id|__SI_FAULT
suffix:semicolon
id|info.si_addr
op_assign
(paren
r_void
op_star
)paren
id|regs-&gt;pc
suffix:semicolon
id|info.si_trapno
op_assign
l_int|0
suffix:semicolon
id|send_sig_info
c_func
(paren
id|SIGTRAP
comma
op_amp
id|info
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* gentrap */
id|info.si_addr
op_assign
(paren
r_void
op_star
)paren
id|regs-&gt;pc
suffix:semicolon
id|info.si_trapno
op_assign
id|regs-&gt;r16
suffix:semicolon
r_switch
c_cond
(paren
(paren
r_int
)paren
id|regs-&gt;r16
)paren
(brace
r_case
id|GEN_INTOVF
suffix:colon
id|signo
op_assign
id|SIGFPE
suffix:semicolon
id|code
op_assign
id|FPE_INTOVF
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GEN_INTDIV
suffix:colon
id|signo
op_assign
id|SIGFPE
suffix:semicolon
id|code
op_assign
id|FPE_INTDIV
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GEN_FLTOVF
suffix:colon
id|signo
op_assign
id|SIGFPE
suffix:semicolon
id|code
op_assign
id|FPE_FLTOVF
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GEN_FLTDIV
suffix:colon
id|signo
op_assign
id|SIGFPE
suffix:semicolon
id|code
op_assign
id|FPE_FLTDIV
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GEN_FLTUND
suffix:colon
id|signo
op_assign
id|SIGFPE
suffix:semicolon
id|code
op_assign
id|FPE_FLTUND
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GEN_FLTINV
suffix:colon
id|signo
op_assign
id|SIGFPE
suffix:semicolon
id|code
op_assign
id|FPE_FLTINV
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GEN_FLTINE
suffix:colon
id|signo
op_assign
id|SIGFPE
suffix:semicolon
id|code
op_assign
id|FPE_FLTRES
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GEN_ROPRAND
suffix:colon
id|signo
op_assign
id|SIGFPE
suffix:semicolon
id|code
op_assign
id|__SI_FAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GEN_DECOVF
suffix:colon
r_case
id|GEN_DECDIV
suffix:colon
r_case
id|GEN_DECINV
suffix:colon
r_case
id|GEN_ASSERTERR
suffix:colon
r_case
id|GEN_NULPTRERR
suffix:colon
r_case
id|GEN_STKOVF
suffix:colon
r_case
id|GEN_STRLENERR
suffix:colon
r_case
id|GEN_SUBSTRERR
suffix:colon
r_case
id|GEN_RANGERR
suffix:colon
r_case
id|GEN_SUBRNG
suffix:colon
r_case
id|GEN_SUBRNG1
suffix:colon
r_case
id|GEN_SUBRNG2
suffix:colon
r_case
id|GEN_SUBRNG3
suffix:colon
r_case
id|GEN_SUBRNG4
suffix:colon
r_case
id|GEN_SUBRNG5
suffix:colon
r_case
id|GEN_SUBRNG6
suffix:colon
r_case
id|GEN_SUBRNG7
suffix:colon
r_default
suffix:colon
id|signo
op_assign
id|SIGTRAP
suffix:semicolon
id|code
op_assign
id|__SI_FAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|info.si_signo
op_assign
id|signo
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
id|info.si_code
op_assign
id|code
suffix:semicolon
id|info.si_addr
op_assign
(paren
r_void
op_star
)paren
id|regs-&gt;pc
suffix:semicolon
id|send_sig_info
c_func
(paren
id|signo
comma
op_amp
id|info
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|4
suffix:colon
multiline_comment|/* opDEC */
r_if
c_cond
(paren
id|implver
c_func
(paren
)paren
op_eq
id|IMPLVER_EV4
)paren
(brace
r_int
id|si_code
suffix:semicolon
multiline_comment|/* The some versions of SRM do not handle&n;&t;&t;&t;   the opDEC properly - they return the PC of the&n;&t;&t;&t;   opDEC fault, not the instruction after as the&n;&t;&t;&t;   Alpha architecture requires.  Here we fix it up.&n;&t;&t;&t;   We do this by intentionally causing an opDEC&n;&t;&t;&t;   fault during the boot sequence and testing if&n;&t;&t;&t;   we get the correct PC.  If not, we set a flag&n;&t;&t;&t;   to correct it every time through.  */
id|regs-&gt;pc
op_add_assign
id|opDEC_fix
suffix:semicolon
multiline_comment|/* EV4 does not implement anything except normal&n;&t;&t;&t;   rounding.  Everything else will come here as&n;&t;&t;&t;   an illegal instruction.  Emulate them.  */
id|si_code
op_assign
id|alpha_fp_emul
c_func
(paren
id|regs-&gt;pc
op_minus
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|si_code
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|si_code
OG
l_int|0
)paren
(brace
id|info.si_signo
op_assign
id|SIGFPE
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
id|info.si_code
op_assign
id|si_code
suffix:semicolon
id|info.si_addr
op_assign
(paren
r_void
op_star
)paren
id|regs-&gt;pc
suffix:semicolon
id|send_sig_info
c_func
(paren
id|SIGFPE
comma
op_amp
id|info
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* FEN fault */
multiline_comment|/* Irritating users can call PAL_clrfen to disable the&n;&t;&t;   FPU for the process.  The kernel will then trap in&n;&t;&t;   do_switch_stack and undo_switch_stack when we try&n;&t;&t;   to save and restore the FP registers.&n;&n;&t;&t;   Given that GCC by default generates code that uses the&n;&t;&t;   FP registers, PAL_clrfen is not useful except for DoS&n;&t;&t;   attacks.  So turn the bleeding FPU back on and be done&n;&t;&t;   with it.  */
id|current_thread_info
c_func
(paren
)paren
op_member_access_from_pointer
id|pcb.flags
op_or_assign
l_int|1
suffix:semicolon
id|__reload_thread
c_func
(paren
op_amp
id|current_thread_info
c_func
(paren
)paren
op_member_access_from_pointer
id|pcb
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|5
suffix:colon
multiline_comment|/* illoc */
r_default
suffix:colon
multiline_comment|/* unexpected instruction-fault type */
suffix:semicolon
)brace
id|info.si_signo
op_assign
id|SIGILL
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
id|info.si_code
op_assign
id|ILL_ILLOPC
suffix:semicolon
id|info.si_addr
op_assign
(paren
r_void
op_star
)paren
id|regs-&gt;pc
suffix:semicolon
id|send_sig_info
c_func
(paren
id|SIGILL
comma
op_amp
id|info
comma
id|current
)paren
suffix:semicolon
)brace
multiline_comment|/* There is an ifdef in the PALcode in MILO that enables a &n;   &quot;kernel debugging entry point&quot; as an unprivileged call_pal.&n;&n;   We don&squot;t want to have anything to do with it, but unfortunately&n;   several versions of MILO included in distributions have it enabled,&n;   and if we don&squot;t put something on the entry point we&squot;ll oops.  */
id|asmlinkage
r_void
DECL|function|do_entDbg
id|do_entDbg
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|siginfo_t
id|info
suffix:semicolon
id|die_if_kernel
c_func
(paren
l_string|&quot;Instruction fault&quot;
comma
id|regs
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|info.si_signo
op_assign
id|SIGILL
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
id|info.si_code
op_assign
id|ILL_ILLOPC
suffix:semicolon
id|info.si_addr
op_assign
(paren
r_void
op_star
)paren
id|regs-&gt;pc
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGILL
comma
op_amp
id|info
comma
id|current
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * entUna has a different register layout to be reasonably simple. It&n; * needs access to all the integer registers (the kernel doesn&squot;t use&n; * fp-regs), and it needs to have them in order for simpler access.&n; *&n; * Due to the non-standard register layout (and because we don&squot;t want&n; * to handle floating-point regs), user-mode unaligned accesses are&n; * handled separately by do_entUnaUser below.&n; *&n; * Oh, btw, we don&squot;t handle the &quot;gp&quot; register correctly, but if we fault&n; * on a gp-register unaligned load/store, something is _very_ wrong&n; * in the kernel anyway..&n; */
DECL|struct|allregs
r_struct
id|allregs
(brace
DECL|member|regs
r_int
r_int
id|regs
(braket
l_int|32
)braket
suffix:semicolon
DECL|member|ps
DECL|member|pc
DECL|member|gp
DECL|member|a0
DECL|member|a1
DECL|member|a2
r_int
r_int
id|ps
comma
id|pc
comma
id|gp
comma
id|a0
comma
id|a1
comma
id|a2
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|unaligned_stat
r_struct
id|unaligned_stat
(brace
DECL|member|count
DECL|member|va
DECL|member|pc
r_int
r_int
id|count
comma
id|va
comma
id|pc
suffix:semicolon
DECL|variable|unaligned
)brace
id|unaligned
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Macro for exception fixup code to access integer registers.  */
DECL|macro|una_reg
mdefine_line|#define una_reg(r)  (regs.regs[(r) &gt;= 16 &amp;&amp; (r) &lt;= 18 ? (r)+19 : (r)])
id|asmlinkage
r_void
DECL|function|do_entUna
id|do_entUna
c_func
(paren
r_void
op_star
id|va
comma
r_int
r_int
id|opcode
comma
r_int
r_int
id|reg
comma
r_int
r_int
id|a3
comma
r_int
r_int
id|a4
comma
r_int
r_int
id|a5
comma
r_struct
id|allregs
id|regs
)paren
(brace
r_int
id|error
comma
id|tmp1
comma
id|tmp2
comma
id|tmp3
comma
id|tmp4
suffix:semicolon
r_int
r_int
id|pc
op_assign
id|regs.pc
op_minus
l_int|4
suffix:semicolon
r_const
r_struct
id|exception_table_entry
op_star
id|fixup
suffix:semicolon
id|unaligned
(braket
l_int|0
)braket
dot
id|count
op_increment
suffix:semicolon
id|unaligned
(braket
l_int|0
)braket
dot
id|va
op_assign
(paren
r_int
r_int
)paren
id|va
suffix:semicolon
id|unaligned
(braket
l_int|0
)braket
dot
id|pc
op_assign
id|pc
suffix:semicolon
multiline_comment|/* We don&squot;t want to use the generic get/put unaligned macros as&n;&t;   we want to trap exceptions.  Only if we actually get an&n;&t;   exception will we decide whether we should have caught it.  */
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
l_int|0x0c
suffix:colon
multiline_comment|/* ldwu */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %1,0(%3)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %2,1(%3)&bslash;n&quot;
l_string|&quot;&t;extwl %1,%3,%1&bslash;n&quot;
l_string|&quot;&t;extwh %2,%3,%2&bslash;n&quot;
l_string|&quot;3:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.long 1b - .&bslash;n&quot;
l_string|&quot;&t;lda %1,3b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 2b - .&bslash;n&quot;
l_string|&quot;&t;lda %2,3b-2b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|got_exception
suffix:semicolon
id|una_reg
c_func
(paren
id|reg
)paren
op_assign
id|tmp1
op_or
id|tmp2
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|0x28
suffix:colon
multiline_comment|/* ldl */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %1,0(%3)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %2,3(%3)&bslash;n&quot;
l_string|&quot;&t;extll %1,%3,%1&bslash;n&quot;
l_string|&quot;&t;extlh %2,%3,%2&bslash;n&quot;
l_string|&quot;3:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.long 1b - .&bslash;n&quot;
l_string|&quot;&t;lda %1,3b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 2b - .&bslash;n&quot;
l_string|&quot;&t;lda %2,3b-2b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|got_exception
suffix:semicolon
id|una_reg
c_func
(paren
id|reg
)paren
op_assign
(paren
r_int
)paren
(paren
id|tmp1
op_or
id|tmp2
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|0x29
suffix:colon
multiline_comment|/* ldq */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %1,0(%3)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %2,7(%3)&bslash;n&quot;
l_string|&quot;&t;extql %1,%3,%1&bslash;n&quot;
l_string|&quot;&t;extqh %2,%3,%2&bslash;n&quot;
l_string|&quot;3:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.long 1b - .&bslash;n&quot;
l_string|&quot;&t;lda %1,3b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 2b - .&bslash;n&quot;
l_string|&quot;&t;lda %2,3b-2b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|got_exception
suffix:semicolon
id|una_reg
c_func
(paren
id|reg
)paren
op_assign
id|tmp1
op_or
id|tmp2
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* Note that the store sequences do not indicate that they change&n;&t;   memory because it _should_ be affecting nothing in this context.&n;&t;   (Otherwise we have other, much larger, problems.)  */
r_case
l_int|0x0d
suffix:colon
multiline_comment|/* stw */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %2,1(%5)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;&t;inswh %6,%5,%4&bslash;n&quot;
l_string|&quot;&t;inswl %6,%5,%3&bslash;n&quot;
l_string|&quot;&t;mskwh %2,%5,%2&bslash;n&quot;
l_string|&quot;&t;mskwl %1,%5,%1&bslash;n&quot;
l_string|&quot;&t;or %2,%4,%2&bslash;n&quot;
l_string|&quot;&t;or %1,%3,%1&bslash;n&quot;
l_string|&quot;3:&t;stq_u %2,1(%5)&bslash;n&quot;
l_string|&quot;4:&t;stq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;5:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.long 1b - .&bslash;n&quot;
l_string|&quot;&t;lda %2,5b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 2b - .&bslash;n&quot;
l_string|&quot;&t;lda %1,5b-2b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 3b - .&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-3b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 4b - .&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-4b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp3
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp4
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;r&quot;
(paren
id|una_reg
c_func
(paren
id|reg
)paren
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|got_exception
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|0x2c
suffix:colon
multiline_comment|/* stl */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %2,3(%5)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;&t;inslh %6,%5,%4&bslash;n&quot;
l_string|&quot;&t;insll %6,%5,%3&bslash;n&quot;
l_string|&quot;&t;msklh %2,%5,%2&bslash;n&quot;
l_string|&quot;&t;mskll %1,%5,%1&bslash;n&quot;
l_string|&quot;&t;or %2,%4,%2&bslash;n&quot;
l_string|&quot;&t;or %1,%3,%1&bslash;n&quot;
l_string|&quot;3:&t;stq_u %2,3(%5)&bslash;n&quot;
l_string|&quot;4:&t;stq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;5:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.long 1b - .&bslash;n&quot;
l_string|&quot;&t;lda %2,5b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 2b - .&bslash;n&quot;
l_string|&quot;&t;lda %1,5b-2b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 3b - .&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-3b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 4b - .&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-4b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp3
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp4
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;r&quot;
(paren
id|una_reg
c_func
(paren
id|reg
)paren
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|got_exception
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|0x2d
suffix:colon
multiline_comment|/* stq */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %2,7(%5)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;&t;insqh %6,%5,%4&bslash;n&quot;
l_string|&quot;&t;insql %6,%5,%3&bslash;n&quot;
l_string|&quot;&t;mskqh %2,%5,%2&bslash;n&quot;
l_string|&quot;&t;mskql %1,%5,%1&bslash;n&quot;
l_string|&quot;&t;or %2,%4,%2&bslash;n&quot;
l_string|&quot;&t;or %1,%3,%1&bslash;n&quot;
l_string|&quot;3:&t;stq_u %2,7(%5)&bslash;n&quot;
l_string|&quot;4:&t;stq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;5:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&bslash;t&quot;
l_string|&quot;&t;.long 1b - .&bslash;n&quot;
l_string|&quot;&t;lda %2,5b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 2b - .&bslash;n&quot;
l_string|&quot;&t;lda %1,5b-2b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 3b - .&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-3b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 4b - .&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-4b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp3
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp4
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;r&quot;
(paren
id|una_reg
c_func
(paren
id|reg
)paren
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|got_exception
suffix:semicolon
r_return
suffix:semicolon
)brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Bad unaligned kernel access at %016lx: %p %lx %ld&bslash;n&quot;
comma
id|pc
comma
id|va
comma
id|opcode
comma
id|reg
)paren
suffix:semicolon
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
id|got_exception
suffix:colon
multiline_comment|/* Ok, we caught the exception, but we don&squot;t want it.  Is there&n;&t;   someone to pass it along to?  */
r_if
c_cond
(paren
(paren
id|fixup
op_assign
id|search_exception_tables
c_func
(paren
id|pc
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_int
r_int
id|newpc
suffix:semicolon
id|newpc
op_assign
id|fixup_exception
c_func
(paren
id|una_reg
comma
id|fixup
comma
id|pc
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Forwarding unaligned exception at %lx (%lx)&bslash;n&quot;
comma
id|pc
comma
id|newpc
)paren
suffix:semicolon
(paren
op_amp
id|regs
)paren
op_member_access_from_pointer
id|pc
op_assign
id|newpc
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Yikes!  No one to forward the exception to.&n;&t; * Since the registers are in a weird format, dump them ourselves.&n; &t; */
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s(%d): unhandled unaligned exception&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pc = [&lt;%016lx&gt;]  ra = [&lt;%016lx&gt;]  ps = %04lx&bslash;n&quot;
comma
id|pc
comma
id|una_reg
c_func
(paren
l_int|26
)paren
comma
id|regs.ps
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r0 = %016lx  r1 = %016lx  r2 = %016lx&bslash;n&quot;
comma
id|una_reg
c_func
(paren
l_int|0
)paren
comma
id|una_reg
c_func
(paren
l_int|1
)paren
comma
id|una_reg
c_func
(paren
l_int|2
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r3 = %016lx  r4 = %016lx  r5 = %016lx&bslash;n&quot;
comma
id|una_reg
c_func
(paren
l_int|3
)paren
comma
id|una_reg
c_func
(paren
l_int|4
)paren
comma
id|una_reg
c_func
(paren
l_int|5
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r6 = %016lx  r7 = %016lx  r8 = %016lx&bslash;n&quot;
comma
id|una_reg
c_func
(paren
l_int|6
)paren
comma
id|una_reg
c_func
(paren
l_int|7
)paren
comma
id|una_reg
c_func
(paren
l_int|8
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r9 = %016lx  r10= %016lx  r11= %016lx&bslash;n&quot;
comma
id|una_reg
c_func
(paren
l_int|9
)paren
comma
id|una_reg
c_func
(paren
l_int|10
)paren
comma
id|una_reg
c_func
(paren
l_int|11
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r12= %016lx  r13= %016lx  r14= %016lx&bslash;n&quot;
comma
id|una_reg
c_func
(paren
l_int|12
)paren
comma
id|una_reg
c_func
(paren
l_int|13
)paren
comma
id|una_reg
c_func
(paren
l_int|14
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r15= %016lx&bslash;n&quot;
comma
id|una_reg
c_func
(paren
l_int|15
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r16= %016lx  r17= %016lx  r18= %016lx&bslash;n&quot;
comma
id|una_reg
c_func
(paren
l_int|16
)paren
comma
id|una_reg
c_func
(paren
l_int|17
)paren
comma
id|una_reg
c_func
(paren
l_int|18
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r19= %016lx  r20= %016lx  r21= %016lx&bslash;n&quot;
comma
id|una_reg
c_func
(paren
l_int|19
)paren
comma
id|una_reg
c_func
(paren
l_int|20
)paren
comma
id|una_reg
c_func
(paren
l_int|21
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r22= %016lx  r23= %016lx  r24= %016lx&bslash;n&quot;
comma
id|una_reg
c_func
(paren
l_int|22
)paren
comma
id|una_reg
c_func
(paren
l_int|23
)paren
comma
id|una_reg
c_func
(paren
l_int|24
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;r25= %016lx  r27= %016lx  r28= %016lx&bslash;n&quot;
comma
id|una_reg
c_func
(paren
l_int|25
)paren
comma
id|una_reg
c_func
(paren
l_int|27
)paren
comma
id|una_reg
c_func
(paren
l_int|28
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;gp = %016lx  sp = %p&bslash;n&quot;
comma
id|regs.gp
comma
op_amp
id|regs
op_plus
l_int|1
)paren
suffix:semicolon
id|dik_show_code
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|pc
)paren
suffix:semicolon
id|dik_show_trace
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
op_amp
id|regs
op_plus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_thread_flag
(paren
id|TIF_DIE_IF_KERNEL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;die_if_kernel recursion detected.&bslash;n&quot;
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert an s-floating point value in memory format to the&n; * corresponding value in register format.  The exponent&n; * needs to be remapped to preserve non-finite values&n; * (infinities, not-a-numbers, denormals).&n; */
r_static
r_inline
r_int
r_int
DECL|function|s_mem_to_reg
id|s_mem_to_reg
(paren
r_int
r_int
id|s_mem
)paren
(brace
r_int
r_int
id|frac
op_assign
(paren
id|s_mem
op_rshift
l_int|0
)paren
op_amp
l_int|0x7fffff
suffix:semicolon
r_int
r_int
id|sign
op_assign
(paren
id|s_mem
op_rshift
l_int|31
)paren
op_amp
l_int|0x1
suffix:semicolon
r_int
r_int
id|exp_msb
op_assign
(paren
id|s_mem
op_rshift
l_int|30
)paren
op_amp
l_int|0x1
suffix:semicolon
r_int
r_int
id|exp_low
op_assign
(paren
id|s_mem
op_rshift
l_int|23
)paren
op_amp
l_int|0x7f
suffix:semicolon
r_int
r_int
id|exp
suffix:semicolon
id|exp
op_assign
(paren
id|exp_msb
op_lshift
l_int|10
)paren
op_or
id|exp_low
suffix:semicolon
multiline_comment|/* common case */
r_if
c_cond
(paren
id|exp_msb
)paren
(brace
r_if
c_cond
(paren
id|exp_low
op_eq
l_int|0x7f
)paren
(brace
id|exp
op_assign
l_int|0x7ff
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|exp_low
op_eq
l_int|0x00
)paren
(brace
id|exp
op_assign
l_int|0x000
suffix:semicolon
)brace
r_else
(brace
id|exp
op_or_assign
(paren
l_int|0x7
op_lshift
l_int|7
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
id|sign
op_lshift
l_int|63
)paren
op_or
(paren
id|exp
op_lshift
l_int|52
)paren
op_or
(paren
id|frac
op_lshift
l_int|29
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert an s-floating point value in register format to the&n; * corresponding value in memory format.&n; */
r_static
r_inline
r_int
r_int
DECL|function|s_reg_to_mem
id|s_reg_to_mem
(paren
r_int
r_int
id|s_reg
)paren
(brace
r_return
(paren
(paren
id|s_reg
op_rshift
l_int|62
)paren
op_lshift
l_int|30
)paren
op_or
(paren
(paren
id|s_reg
op_lshift
l_int|5
)paren
op_rshift
l_int|34
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle user-level unaligned fault.  Handling user-level unaligned&n; * faults is *extremely* slow and produces nasty messages.  A user&n; * program *should* fix unaligned faults ASAP.&n; *&n; * Notice that we have (almost) the regular kernel stack layout here,&n; * so finding the appropriate registers is a little more difficult&n; * than in the kernel case.&n; *&n; * Finally, we handle regular integer load/stores only.  In&n; * particular, load-linked/store-conditionally and floating point&n; * load/stores are not supported.  The former make no sense with&n; * unaligned faults (they are guaranteed to fail) and I don&squot;t think&n; * the latter will occur in any decent program.&n; *&n; * Sigh. We *do* have to handle some FP operations, because GCC will&n; * uses them as temporary storage for integer memory to memory copies.&n; * However, we need to deal with stt/ldt and sts/lds only.&n; */
DECL|macro|OP_INT_MASK
mdefine_line|#define OP_INT_MASK&t;( 1L &lt;&lt; 0x28 | 1L &lt;&lt; 0x2c   /* ldl stl */&t;&bslash;&n;&t;&t;&t;| 1L &lt;&lt; 0x29 | 1L &lt;&lt; 0x2d   /* ldq stq */&t;&bslash;&n;&t;&t;&t;| 1L &lt;&lt; 0x0c | 1L &lt;&lt; 0x0d   /* ldwu stw */&t;&bslash;&n;&t;&t;&t;| 1L &lt;&lt; 0x0a | 1L &lt;&lt; 0x0e ) /* ldbu stb */
DECL|macro|OP_WRITE_MASK
mdefine_line|#define OP_WRITE_MASK&t;( 1L &lt;&lt; 0x26 | 1L &lt;&lt; 0x27   /* sts stt */&t;&bslash;&n;&t;&t;&t;| 1L &lt;&lt; 0x2c | 1L &lt;&lt; 0x2d   /* stl stq */&t;&bslash;&n;&t;&t;&t;| 1L &lt;&lt; 0x0d | 1L &lt;&lt; 0x0e ) /* stw stb */
DECL|macro|R
mdefine_line|#define R(x)&t;((size_t) &amp;((struct pt_regs *)0)-&gt;x)
DECL|variable|unauser_reg_offsets
r_static
r_int
id|unauser_reg_offsets
(braket
l_int|32
)braket
op_assign
(brace
id|R
c_func
(paren
id|r0
)paren
comma
id|R
c_func
(paren
id|r1
)paren
comma
id|R
c_func
(paren
id|r2
)paren
comma
id|R
c_func
(paren
id|r3
)paren
comma
id|R
c_func
(paren
id|r4
)paren
comma
id|R
c_func
(paren
id|r5
)paren
comma
id|R
c_func
(paren
id|r6
)paren
comma
id|R
c_func
(paren
id|r7
)paren
comma
id|R
c_func
(paren
id|r8
)paren
comma
multiline_comment|/* r9 ... r15 are stored in front of regs.  */
op_minus
l_int|56
comma
op_minus
l_int|48
comma
op_minus
l_int|40
comma
op_minus
l_int|32
comma
op_minus
l_int|24
comma
op_minus
l_int|16
comma
op_minus
l_int|8
comma
id|R
c_func
(paren
id|r16
)paren
comma
id|R
c_func
(paren
id|r17
)paren
comma
id|R
c_func
(paren
id|r18
)paren
comma
id|R
c_func
(paren
id|r19
)paren
comma
id|R
c_func
(paren
id|r20
)paren
comma
id|R
c_func
(paren
id|r21
)paren
comma
id|R
c_func
(paren
id|r22
)paren
comma
id|R
c_func
(paren
id|r23
)paren
comma
id|R
c_func
(paren
id|r24
)paren
comma
id|R
c_func
(paren
id|r25
)paren
comma
id|R
c_func
(paren
id|r26
)paren
comma
id|R
c_func
(paren
id|r27
)paren
comma
id|R
c_func
(paren
id|r28
)paren
comma
id|R
c_func
(paren
id|gp
)paren
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|macro|R
macro_line|#undef R
id|asmlinkage
r_void
DECL|function|do_entUnaUser
id|do_entUnaUser
c_func
(paren
r_void
op_star
id|va
comma
r_int
r_int
id|opcode
comma
r_int
r_int
id|reg
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_static
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|last_time
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|tmp1
comma
id|tmp2
comma
id|tmp3
comma
id|tmp4
suffix:semicolon
r_int
r_int
id|fake_reg
comma
op_star
id|reg_addr
op_assign
op_amp
id|fake_reg
suffix:semicolon
id|siginfo_t
id|info
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/* Check the UAC bits to decide what the user wants us to do&n;&t;   with the unaliged access.  */
r_if
c_cond
(paren
op_logical_neg
id|test_thread_flag
(paren
id|TIF_UAC_NOPRINT
)paren
)paren
(brace
r_if
c_cond
(paren
id|cnt
op_ge
l_int|5
op_logical_and
id|jiffies
op_minus
id|last_time
OG
l_int|5
op_star
id|HZ
)paren
(brace
id|cnt
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|cnt
OL
l_int|5
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s(%d): unaligned trap at %016lx: %p %lx %ld&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
id|regs-&gt;pc
op_minus
l_int|4
comma
id|va
comma
id|opcode
comma
id|reg
)paren
suffix:semicolon
)brace
id|last_time
op_assign
id|jiffies
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_thread_flag
(paren
id|TIF_UAC_SIGBUS
)paren
)paren
r_goto
id|give_sigbus
suffix:semicolon
multiline_comment|/* Not sure why you&squot;d want to use this, but... */
r_if
c_cond
(paren
id|test_thread_flag
(paren
id|TIF_UAC_NOFIX
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Don&squot;t bother reading ds in the access check since we already&n;&t;   know that this came from the user.  Also rely on the fact that&n;&t;   the page at TASK_SIZE is unmapped and so can&squot;t be touched anyway. */
r_if
c_cond
(paren
op_logical_neg
id|__access_ok
c_func
(paren
(paren
r_int
r_int
)paren
id|va
comma
l_int|0
comma
id|USER_DS
)paren
)paren
r_goto
id|give_sigsegv
suffix:semicolon
op_increment
id|unaligned
(braket
l_int|1
)braket
dot
id|count
suffix:semicolon
id|unaligned
(braket
l_int|1
)braket
dot
id|va
op_assign
(paren
r_int
r_int
)paren
id|va
suffix:semicolon
id|unaligned
(braket
l_int|1
)braket
dot
id|pc
op_assign
id|regs-&gt;pc
op_minus
l_int|4
suffix:semicolon
r_if
c_cond
(paren
(paren
l_int|1L
op_lshift
id|opcode
)paren
op_amp
id|OP_INT_MASK
)paren
(brace
multiline_comment|/* it&squot;s an integer load/store */
r_if
c_cond
(paren
id|reg
OL
l_int|30
)paren
(brace
id|reg_addr
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|regs
op_plus
id|unauser_reg_offsets
(braket
id|reg
)braket
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|reg
op_eq
l_int|30
)paren
(brace
multiline_comment|/* usp in PAL regs */
id|fake_reg
op_assign
id|rdusp
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* zero &quot;register&quot; */
id|fake_reg
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* We don&squot;t want to use the generic get/put unaligned macros as&n;&t;   we want to trap exceptions.  Only if we actually get an&n;&t;   exception will we decide whether we should have caught it.  */
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
l_int|0x0c
suffix:colon
multiline_comment|/* ldwu */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %1,0(%3)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %2,1(%3)&bslash;n&quot;
l_string|&quot;&t;extwl %1,%3,%1&bslash;n&quot;
l_string|&quot;&t;extwh %2,%3,%2&bslash;n&quot;
l_string|&quot;3:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.long 1b - .&bslash;n&quot;
l_string|&quot;&t;lda %1,3b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 2b - .&bslash;n&quot;
l_string|&quot;&t;lda %2,3b-2b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|give_sigsegv
suffix:semicolon
op_star
id|reg_addr
op_assign
id|tmp1
op_or
id|tmp2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x22
suffix:colon
multiline_comment|/* lds */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %1,0(%3)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %2,3(%3)&bslash;n&quot;
l_string|&quot;&t;extll %1,%3,%1&bslash;n&quot;
l_string|&quot;&t;extlh %2,%3,%2&bslash;n&quot;
l_string|&quot;3:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.long 1b - .&bslash;n&quot;
l_string|&quot;&t;lda %1,3b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 2b - .&bslash;n&quot;
l_string|&quot;&t;lda %2,3b-2b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|give_sigsegv
suffix:semicolon
id|alpha_write_fp_reg
c_func
(paren
id|reg
comma
id|s_mem_to_reg
c_func
(paren
(paren
r_int
)paren
(paren
id|tmp1
op_or
id|tmp2
)paren
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|0x23
suffix:colon
multiline_comment|/* ldt */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %1,0(%3)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %2,7(%3)&bslash;n&quot;
l_string|&quot;&t;extql %1,%3,%1&bslash;n&quot;
l_string|&quot;&t;extqh %2,%3,%2&bslash;n&quot;
l_string|&quot;3:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.long 1b - .&bslash;n&quot;
l_string|&quot;&t;lda %1,3b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 2b - .&bslash;n&quot;
l_string|&quot;&t;lda %2,3b-2b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|give_sigsegv
suffix:semicolon
id|alpha_write_fp_reg
c_func
(paren
id|reg
comma
id|tmp1
op_or
id|tmp2
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|0x28
suffix:colon
multiline_comment|/* ldl */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %1,0(%3)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %2,3(%3)&bslash;n&quot;
l_string|&quot;&t;extll %1,%3,%1&bslash;n&quot;
l_string|&quot;&t;extlh %2,%3,%2&bslash;n&quot;
l_string|&quot;3:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.long 1b - .&bslash;n&quot;
l_string|&quot;&t;lda %1,3b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 2b - .&bslash;n&quot;
l_string|&quot;&t;lda %2,3b-2b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|give_sigsegv
suffix:semicolon
op_star
id|reg_addr
op_assign
(paren
r_int
)paren
(paren
id|tmp1
op_or
id|tmp2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x29
suffix:colon
multiline_comment|/* ldq */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %1,0(%3)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %2,7(%3)&bslash;n&quot;
l_string|&quot;&t;extql %1,%3,%1&bslash;n&quot;
l_string|&quot;&t;extqh %2,%3,%2&bslash;n&quot;
l_string|&quot;3:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.long 1b - .&bslash;n&quot;
l_string|&quot;&t;lda %1,3b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 2b - .&bslash;n&quot;
l_string|&quot;&t;lda %2,3b-2b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|give_sigsegv
suffix:semicolon
op_star
id|reg_addr
op_assign
id|tmp1
op_or
id|tmp2
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Note that the store sequences do not indicate that they change&n;&t;   memory because it _should_ be affecting nothing in this context.&n;&t;   (Otherwise we have other, much larger, problems.)  */
r_case
l_int|0x0d
suffix:colon
multiline_comment|/* stw */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %2,1(%5)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;&t;inswh %6,%5,%4&bslash;n&quot;
l_string|&quot;&t;inswl %6,%5,%3&bslash;n&quot;
l_string|&quot;&t;mskwh %2,%5,%2&bslash;n&quot;
l_string|&quot;&t;mskwl %1,%5,%1&bslash;n&quot;
l_string|&quot;&t;or %2,%4,%2&bslash;n&quot;
l_string|&quot;&t;or %1,%3,%1&bslash;n&quot;
l_string|&quot;3:&t;stq_u %2,1(%5)&bslash;n&quot;
l_string|&quot;4:&t;stq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;5:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.long 1b - .&bslash;n&quot;
l_string|&quot;&t;lda %2,5b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 2b - .&bslash;n&quot;
l_string|&quot;&t;lda %1,5b-2b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 3b - .&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-3b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 4b - .&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-4b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp3
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp4
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;r&quot;
(paren
op_star
id|reg_addr
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|give_sigsegv
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|0x26
suffix:colon
multiline_comment|/* sts */
id|fake_reg
op_assign
id|s_reg_to_mem
c_func
(paren
id|alpha_read_fp_reg
c_func
(paren
id|reg
)paren
)paren
suffix:semicolon
multiline_comment|/* FALLTHRU */
r_case
l_int|0x2c
suffix:colon
multiline_comment|/* stl */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %2,3(%5)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;&t;inslh %6,%5,%4&bslash;n&quot;
l_string|&quot;&t;insll %6,%5,%3&bslash;n&quot;
l_string|&quot;&t;msklh %2,%5,%2&bslash;n&quot;
l_string|&quot;&t;mskll %1,%5,%1&bslash;n&quot;
l_string|&quot;&t;or %2,%4,%2&bslash;n&quot;
l_string|&quot;&t;or %1,%3,%1&bslash;n&quot;
l_string|&quot;3:&t;stq_u %2,3(%5)&bslash;n&quot;
l_string|&quot;4:&t;stq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;5:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&quot;
l_string|&quot;&t;.long 1b - .&bslash;n&quot;
l_string|&quot;&t;lda %2,5b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 2b - .&bslash;n&quot;
l_string|&quot;&t;lda %1,5b-2b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 3b - .&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-3b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 4b - .&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-4b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp3
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp4
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;r&quot;
(paren
op_star
id|reg_addr
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|give_sigsegv
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|0x27
suffix:colon
multiline_comment|/* stt */
id|fake_reg
op_assign
id|alpha_read_fp_reg
c_func
(paren
id|reg
)paren
suffix:semicolon
multiline_comment|/* FALLTHRU */
r_case
l_int|0x2d
suffix:colon
multiline_comment|/* stq */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_u %2,7(%5)&bslash;n&quot;
l_string|&quot;2:&t;ldq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;&t;insqh %6,%5,%4&bslash;n&quot;
l_string|&quot;&t;insql %6,%5,%3&bslash;n&quot;
l_string|&quot;&t;mskqh %2,%5,%2&bslash;n&quot;
l_string|&quot;&t;mskql %1,%5,%1&bslash;n&quot;
l_string|&quot;&t;or %2,%4,%2&bslash;n&quot;
l_string|&quot;&t;or %1,%3,%1&bslash;n&quot;
l_string|&quot;3:&t;stq_u %2,7(%5)&bslash;n&quot;
l_string|&quot;4:&t;stq_u %1,0(%5)&bslash;n&quot;
l_string|&quot;5:&bslash;n&quot;
l_string|&quot;.section __ex_table,&bslash;&quot;a&bslash;&quot;&bslash;n&bslash;t&quot;
l_string|&quot;&t;.long 1b - .&bslash;n&quot;
l_string|&quot;&t;lda %2,5b-1b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 2b - .&bslash;n&quot;
l_string|&quot;&t;lda %1,5b-2b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 3b - .&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-3b(%0)&bslash;n&quot;
l_string|&quot;&t;.long 4b - .&bslash;n&quot;
l_string|&quot;&t;lda $31,5b-4b(%0)&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|error
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp3
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp4
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|va
)paren
comma
l_string|&quot;r&quot;
(paren
op_star
id|reg_addr
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|give_sigsegv
suffix:semicolon
r_return
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* What instruction were you trying to use, exactly?  */
r_goto
id|give_sigbus
suffix:semicolon
)brace
multiline_comment|/* Only integer loads should get here; everyone else returns early. */
r_if
c_cond
(paren
id|reg
op_eq
l_int|30
)paren
id|wrusp
c_func
(paren
id|fake_reg
)paren
suffix:semicolon
r_return
suffix:semicolon
id|give_sigsegv
suffix:colon
id|regs-&gt;pc
op_sub_assign
l_int|4
suffix:semicolon
multiline_comment|/* make pc point to faulting insn */
id|info.si_signo
op_assign
id|SIGSEGV
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We need to replicate some of the logic in mm/fault.c,&n;&t;   since we don&squot;t have access to the fault code in the&n;&t;   exception handling return path.  */
r_if
c_cond
(paren
op_logical_neg
id|__access_ok
c_func
(paren
(paren
r_int
r_int
)paren
id|va
comma
l_int|0
comma
id|USER_DS
)paren
)paren
id|info.si_code
op_assign
id|SEGV_ACCERR
suffix:semicolon
r_else
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|find_vma
c_func
(paren
id|mm
comma
(paren
r_int
r_int
)paren
id|va
)paren
)paren
id|info.si_code
op_assign
id|SEGV_ACCERR
suffix:semicolon
r_else
id|info.si_code
op_assign
id|SEGV_MAPERR
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
)brace
id|info.si_addr
op_assign
id|va
suffix:semicolon
id|send_sig_info
c_func
(paren
id|SIGSEGV
comma
op_amp
id|info
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
id|give_sigbus
suffix:colon
id|regs-&gt;pc
op_sub_assign
l_int|4
suffix:semicolon
id|info.si_signo
op_assign
id|SIGBUS
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
id|info.si_code
op_assign
id|BUS_ADRALN
suffix:semicolon
id|info.si_addr
op_assign
id|va
suffix:semicolon
id|send_sig_info
c_func
(paren
id|SIGBUS
comma
op_amp
id|info
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_void
id|__init
DECL|function|trap_init
id|trap_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Tell PAL-code what global pointer we want in the kernel.  */
r_register
r_int
r_int
id|gptr
id|__asm__
c_func
(paren
l_string|&quot;$29&quot;
)paren
suffix:semicolon
id|wrkgp
c_func
(paren
id|gptr
)paren
suffix:semicolon
multiline_comment|/* Hack for Multia (UDB) and JENSEN: some of their SRMs have&n;&t;   a bug in the handling of the opDEC fault.  Fix it up if so.  */
r_if
c_cond
(paren
id|implver
c_func
(paren
)paren
op_eq
id|IMPLVER_EV4
)paren
id|opDEC_check
c_func
(paren
)paren
suffix:semicolon
id|wrent
c_func
(paren
id|entArith
comma
l_int|1
)paren
suffix:semicolon
id|wrent
c_func
(paren
id|entMM
comma
l_int|2
)paren
suffix:semicolon
id|wrent
c_func
(paren
id|entIF
comma
l_int|3
)paren
suffix:semicolon
id|wrent
c_func
(paren
id|entUna
comma
l_int|4
)paren
suffix:semicolon
id|wrent
c_func
(paren
id|entSys
comma
l_int|5
)paren
suffix:semicolon
id|wrent
c_func
(paren
id|entDbg
comma
l_int|6
)paren
suffix:semicolon
)brace
eof
