multiline_comment|/**&n; * @file arch/alpha/oprofile/op_model_ev5.c&n; *&n; * @remark Copyright 2002 OProfile authors&n; * @remark Read the file COPYING&n; *&n; * @author Richard Henderson &lt;rth@twiddle.net&gt;&n; */
macro_line|#include &lt;linux/oprofile.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &quot;op_impl.h&quot;
multiline_comment|/* Compute all of the registers in preparation for enabling profiling.&n;&n;   The 21164 (EV5) and 21164PC (PCA65) vary in the bit placement and&n;   meaning of the &quot;CBOX&quot; events.  Given that we don&squot;t care about meaning&n;   at this point, arrange for the difference in bit placement to be&n;   handled by common code.  */
r_static
r_void
DECL|function|common_reg_setup
id|common_reg_setup
c_func
(paren
r_struct
id|op_register_config
op_star
id|reg
comma
r_struct
id|op_counter_config
op_star
id|ctr
comma
r_struct
id|op_system_config
op_star
id|sys
comma
r_int
id|cbox1_ofs
comma
r_int
id|cbox2_ofs
)paren
(brace
r_int
id|i
comma
id|ctl
comma
id|reset
comma
id|need_reset
suffix:semicolon
multiline_comment|/* Select desired events.  The event numbers are selected such&n;&t;   that they map directly into the event selection fields:&n;&n;&t;&t;PCSEL0:&t;0, 1&n;&t;&t;PCSEL1:&t;24-39&n;&t;&t; CBOX1: 40-47&n;&t;&t;PCSEL2: 48-63&n;&t;&t; CBOX2: 64-71&n;&n;&t;   There are two special cases, in that CYCLES can be measured&n;&t;   on PCSEL[02], and SCACHE_WRITE can be measured on CBOX[12].&n;&t;   These event numbers are canonicalizes to their first appearance.  */
id|ctl
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
op_increment
id|i
)paren
(brace
r_int
r_int
id|event
op_assign
id|ctr
(braket
id|i
)braket
dot
id|event
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctr
(braket
id|i
)braket
dot
id|enabled
)paren
r_continue
suffix:semicolon
multiline_comment|/* Remap the duplicate events, as described above.  */
r_if
c_cond
(paren
id|i
op_eq
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|event
op_eq
l_int|0
)paren
id|event
op_assign
l_int|12
op_plus
l_int|48
suffix:semicolon
r_else
r_if
c_cond
(paren
id|event
op_eq
l_int|2
op_plus
l_int|41
)paren
id|event
op_assign
l_int|4
op_plus
l_int|65
suffix:semicolon
)brace
multiline_comment|/* Convert the event numbers onto mux_select bit mask.  */
r_if
c_cond
(paren
id|event
OL
l_int|2
)paren
id|ctl
op_or_assign
id|event
op_lshift
l_int|31
suffix:semicolon
r_else
r_if
c_cond
(paren
id|event
OL
l_int|24
)paren
multiline_comment|/* error */
suffix:semicolon
r_else
r_if
c_cond
(paren
id|event
OL
l_int|40
)paren
id|ctl
op_or_assign
(paren
id|event
op_minus
l_int|24
)paren
op_lshift
l_int|4
suffix:semicolon
r_else
r_if
c_cond
(paren
id|event
OL
l_int|48
)paren
id|ctl
op_or_assign
(paren
id|event
op_minus
l_int|40
)paren
op_lshift
id|cbox1_ofs
op_or
l_int|15
op_lshift
l_int|4
suffix:semicolon
r_else
r_if
c_cond
(paren
id|event
OL
l_int|64
)paren
id|ctl
op_or_assign
id|event
op_minus
l_int|48
suffix:semicolon
r_else
r_if
c_cond
(paren
id|event
OL
l_int|72
)paren
id|ctl
op_or_assign
(paren
id|event
op_minus
l_int|64
)paren
op_lshift
id|cbox2_ofs
op_or
l_int|15
suffix:semicolon
)brace
id|reg-&gt;mux_select
op_assign
id|ctl
suffix:semicolon
multiline_comment|/* Select processor mode.  */
multiline_comment|/* ??? Need to come up with some mechanism to trace only selected&n;&t;   processes.  For now select from pal, kernel and user mode.  */
id|ctl
op_assign
l_int|0
suffix:semicolon
id|ctl
op_or_assign
op_logical_neg
id|sys-&gt;enable_pal
op_lshift
l_int|9
suffix:semicolon
id|ctl
op_or_assign
op_logical_neg
id|sys-&gt;enable_kernel
op_lshift
l_int|8
suffix:semicolon
id|ctl
op_or_assign
op_logical_neg
id|sys-&gt;enable_user
op_lshift
l_int|30
suffix:semicolon
id|reg-&gt;proc_mode
op_assign
id|ctl
suffix:semicolon
multiline_comment|/* Select interrupt frequencies.  Take the interrupt count selected&n;&t;   by the user, and map it onto one of the possible counter widths.&n;&t;   If the user value is in between, compute a value to which the&n;&t;   counter is reset at each interrupt.  */
id|ctl
op_assign
id|reset
op_assign
id|need_reset
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
op_increment
id|i
)paren
(brace
r_int
r_int
id|max
comma
id|hilo
comma
id|count
op_assign
id|ctr
(braket
id|i
)braket
dot
id|count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctr
(braket
id|i
)braket
dot
id|enabled
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|count
op_le
l_int|256
)paren
id|count
op_assign
l_int|256
comma
id|hilo
op_assign
l_int|3
comma
id|max
op_assign
l_int|256
suffix:semicolon
r_else
(brace
id|max
op_assign
(paren
id|i
op_eq
l_int|2
ques
c_cond
l_int|16384
suffix:colon
l_int|65536
)paren
suffix:semicolon
id|hilo
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|max
)paren
id|count
op_assign
id|max
suffix:semicolon
)brace
id|ctr
(braket
id|i
)braket
dot
id|count
op_assign
id|count
suffix:semicolon
id|ctl
op_or_assign
id|hilo
op_lshift
(paren
l_int|8
op_minus
id|i
op_star
l_int|2
)paren
suffix:semicolon
id|reset
op_or_assign
(paren
id|max
op_minus
id|count
)paren
op_lshift
(paren
l_int|48
op_minus
l_int|16
op_star
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ne
id|max
)paren
id|need_reset
op_or_assign
l_int|1
op_lshift
id|i
suffix:semicolon
)brace
id|reg-&gt;freq
op_assign
id|ctl
suffix:semicolon
id|reg-&gt;reset_values
op_assign
id|reset
suffix:semicolon
id|reg-&gt;need_reset
op_assign
id|need_reset
suffix:semicolon
)brace
r_static
r_void
DECL|function|ev5_reg_setup
id|ev5_reg_setup
c_func
(paren
r_struct
id|op_register_config
op_star
id|reg
comma
r_struct
id|op_counter_config
op_star
id|ctr
comma
r_struct
id|op_system_config
op_star
id|sys
)paren
(brace
id|common_reg_setup
c_func
(paren
id|reg
comma
id|ctr
comma
id|sys
comma
l_int|19
comma
l_int|22
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|pca56_reg_setup
id|pca56_reg_setup
c_func
(paren
r_struct
id|op_register_config
op_star
id|reg
comma
r_struct
id|op_counter_config
op_star
id|ctr
comma
r_struct
id|op_system_config
op_star
id|sys
)paren
(brace
id|common_reg_setup
c_func
(paren
id|reg
comma
id|ctr
comma
id|sys
comma
l_int|8
comma
l_int|11
)paren
suffix:semicolon
)brace
multiline_comment|/* Program all of the registers in preparation for enabling profiling.  */
r_static
r_void
DECL|function|ev5_cpu_setup
id|ev5_cpu_setup
(paren
r_void
op_star
id|x
)paren
(brace
r_struct
id|op_register_config
op_star
id|reg
op_assign
id|x
suffix:semicolon
id|wrperfmon
c_func
(paren
l_int|2
comma
id|reg-&gt;mux_select
)paren
suffix:semicolon
id|wrperfmon
c_func
(paren
l_int|3
comma
id|reg-&gt;proc_mode
)paren
suffix:semicolon
id|wrperfmon
c_func
(paren
l_int|4
comma
id|reg-&gt;freq
)paren
suffix:semicolon
id|wrperfmon
c_func
(paren
l_int|6
comma
id|reg-&gt;reset_values
)paren
suffix:semicolon
)brace
multiline_comment|/* CTR is a counter for which the user has requested an interrupt count&n;   in between one of the widths selectable in hardware.  Reset the count&n;   for CTR to the value stored in REG-&gt;RESET_VALUES.&n;&n;   For EV5, this means disabling profiling, reading the current values,&n;   masking in the value for the desired register, writing, then turning&n;   profiling back on.&n;&n;   This can be streamlined if profiling is only enabled for user mode.&n;   In that case we know that the counters are not currently incrementing&n;   (due to being in kernel mode).  */
r_static
r_void
DECL|function|ev5_reset_ctr
id|ev5_reset_ctr
c_func
(paren
r_struct
id|op_register_config
op_star
id|reg
comma
r_int
r_int
id|ctr
)paren
(brace
r_int
r_int
id|values
comma
id|mask
comma
id|not_pk
comma
id|reset_values
suffix:semicolon
id|mask
op_assign
(paren
id|ctr
op_eq
l_int|0
ques
c_cond
l_int|0xfffful
op_lshift
l_int|48
suffix:colon
id|ctr
op_eq
l_int|1
ques
c_cond
l_int|0xfffful
op_lshift
l_int|32
suffix:colon
l_int|0x3fff
op_lshift
l_int|16
)paren
suffix:semicolon
id|not_pk
op_assign
l_int|1
op_lshift
l_int|9
op_or
l_int|1
op_lshift
l_int|8
suffix:semicolon
id|reset_values
op_assign
id|reg-&gt;reset_values
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reg-&gt;proc_mode
op_amp
id|not_pk
)paren
op_eq
id|not_pk
)paren
(brace
id|values
op_assign
id|wrperfmon
c_func
(paren
l_int|5
comma
l_int|0
)paren
suffix:semicolon
id|values
op_assign
(paren
id|reset_values
op_amp
id|mask
)paren
op_or
(paren
id|values
op_amp
op_complement
id|mask
op_amp
op_minus
l_int|2
)paren
suffix:semicolon
id|wrperfmon
c_func
(paren
l_int|6
comma
id|values
)paren
suffix:semicolon
)brace
r_else
(brace
id|wrperfmon
c_func
(paren
l_int|0
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|values
op_assign
id|wrperfmon
c_func
(paren
l_int|5
comma
l_int|0
)paren
suffix:semicolon
id|values
op_assign
(paren
id|reset_values
op_amp
id|mask
)paren
op_or
(paren
id|values
op_amp
op_complement
id|mask
op_amp
op_minus
l_int|2
)paren
suffix:semicolon
id|wrperfmon
c_func
(paren
l_int|6
comma
id|values
)paren
suffix:semicolon
id|wrperfmon
c_func
(paren
l_int|1
comma
id|reg-&gt;enable
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|ev5_handle_interrupt
id|ev5_handle_interrupt
c_func
(paren
r_int
r_int
id|which
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_struct
id|op_counter_config
op_star
id|ctr
)paren
(brace
multiline_comment|/* Record the sample.  */
id|oprofile_add_sample
c_func
(paren
id|regs-&gt;pc
comma
id|which
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
DECL|variable|op_model_ev5
r_struct
id|op_axp_model
id|op_model_ev5
op_assign
(brace
dot
id|reg_setup
op_assign
id|ev5_reg_setup
comma
dot
id|cpu_setup
op_assign
id|ev5_cpu_setup
comma
dot
id|reset_ctr
op_assign
id|ev5_reset_ctr
comma
dot
id|handle_interrupt
op_assign
id|ev5_handle_interrupt
comma
dot
id|cpu
op_assign
l_string|&quot;alpha/ev5&quot;
comma
dot
id|num_counters
op_assign
l_int|3
comma
dot
id|can_set_proc_mode
op_assign
l_int|1
comma
)brace
suffix:semicolon
DECL|variable|op_model_pca56
r_struct
id|op_axp_model
id|op_model_pca56
op_assign
(brace
dot
id|reg_setup
op_assign
id|pca56_reg_setup
comma
dot
id|cpu_setup
op_assign
id|ev5_cpu_setup
comma
dot
id|reset_ctr
op_assign
id|ev5_reset_ctr
comma
dot
id|handle_interrupt
op_assign
id|ev5_handle_interrupt
comma
dot
id|cpu
op_assign
l_string|&quot;alpha/pca56&quot;
comma
dot
id|num_counters
op_assign
l_int|3
comma
dot
id|can_set_proc_mode
op_assign
l_int|1
comma
)brace
suffix:semicolon
eof
