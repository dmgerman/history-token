multiline_comment|/**&n; * @file arch/alpha/oprofile/op_model_ev67.c&n; *&n; * @remark Copyright 2002 OProfile authors&n; * @remark Read the file COPYING&n; *&n; * @author Richard Henderson &lt;rth@twiddle.net&gt;&n; * @author Falk Hueffner &lt;falk@debian.org&gt;&n; */
macro_line|#include &lt;linux/oprofile.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &quot;op_impl.h&quot;
multiline_comment|/* Compute all of the registers in preparation for enabling profiling.  */
r_static
r_void
DECL|function|ev67_reg_setup
id|ev67_reg_setup
c_func
(paren
r_struct
id|op_register_config
op_star
id|reg
comma
r_struct
id|op_counter_config
op_star
id|ctr
comma
r_struct
id|op_system_config
op_star
id|sys
)paren
(brace
r_int
r_int
id|ctl
comma
id|reset
comma
id|need_reset
comma
id|i
suffix:semicolon
multiline_comment|/* Select desired events.  */
id|ctl
op_assign
l_int|1UL
op_lshift
l_int|4
suffix:semicolon
multiline_comment|/* Enable ProfileMe mode. */
multiline_comment|/* The event numbers are chosen so we can use them directly if&n;&t;   PCTR1 is enabled.  */
r_if
c_cond
(paren
id|ctr
(braket
l_int|1
)braket
dot
id|enabled
)paren
(brace
id|ctl
op_or_assign
(paren
id|ctr
(braket
l_int|1
)braket
dot
id|event
op_amp
l_int|3
)paren
op_lshift
l_int|2
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ctr
(braket
l_int|0
)braket
dot
id|event
op_eq
l_int|0
)paren
multiline_comment|/* cycles */
id|ctl
op_or_assign
l_int|1UL
op_lshift
l_int|2
suffix:semicolon
)brace
id|reg-&gt;mux_select
op_assign
id|ctl
suffix:semicolon
multiline_comment|/* Select logging options.  */
multiline_comment|/* ??? Need to come up with some mechanism to trace only&n;&t;   selected processes.  EV67 does not have a mechanism to&n;&t;   select kernel or user mode only.  For now, enable always.  */
id|reg-&gt;proc_mode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* EV67 cannot change the width of the counters as with the&n;&t;   other implementations.  But fortunately, we can write to&n;&t;   the counters and set the value such that it will overflow&n;&t;   at the right time.  */
id|reset
op_assign
id|need_reset
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
op_increment
id|i
)paren
(brace
r_int
r_int
id|count
op_assign
id|ctr
(braket
id|i
)braket
dot
id|count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctr
(braket
id|i
)braket
dot
id|enabled
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|0x100000
)paren
id|count
op_assign
l_int|0x100000
suffix:semicolon
id|ctr
(braket
id|i
)braket
dot
id|count
op_assign
id|count
suffix:semicolon
id|reset
op_or_assign
(paren
l_int|0x100000
op_minus
id|count
)paren
op_lshift
(paren
id|i
ques
c_cond
l_int|6
suffix:colon
l_int|28
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ne
l_int|0x100000
)paren
id|need_reset
op_or_assign
l_int|1
op_lshift
id|i
suffix:semicolon
)brace
id|reg-&gt;reset_values
op_assign
id|reset
suffix:semicolon
id|reg-&gt;need_reset
op_assign
id|need_reset
suffix:semicolon
)brace
multiline_comment|/* Program all of the registers in preparation for enabling profiling.  */
r_static
r_void
DECL|function|ev67_cpu_setup
id|ev67_cpu_setup
(paren
r_void
op_star
id|x
)paren
(brace
r_struct
id|op_register_config
op_star
id|reg
op_assign
id|x
suffix:semicolon
id|wrperfmon
c_func
(paren
l_int|2
comma
id|reg-&gt;mux_select
)paren
suffix:semicolon
id|wrperfmon
c_func
(paren
l_int|3
comma
id|reg-&gt;proc_mode
)paren
suffix:semicolon
id|wrperfmon
c_func
(paren
l_int|6
comma
id|reg-&gt;reset_values
op_or
l_int|3
)paren
suffix:semicolon
)brace
multiline_comment|/* CTR is a counter for which the user has requested an interrupt count&n;   in between one of the widths selectable in hardware.  Reset the count&n;   for CTR to the value stored in REG-&gt;RESET_VALUES.  */
r_static
r_void
DECL|function|ev67_reset_ctr
id|ev67_reset_ctr
c_func
(paren
r_struct
id|op_register_config
op_star
id|reg
comma
r_int
r_int
id|ctr
)paren
(brace
id|wrperfmon
c_func
(paren
l_int|6
comma
id|reg-&gt;reset_values
op_or
(paren
l_int|1
op_lshift
id|ctr
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* ProfileMe conditions which will show up as counters. We can also&n;   detect the following, but it seems unlikely that anybody is&n;   interested in counting them:&n;    * Reset&n;    * MT_FPCR (write to floating point control register)&n;    * Arithmetic trap&n;    * Dstream Fault&n;    * Machine Check (ECC fault, etc.)&n;    * OPCDEC (illegal opcode)&n;    * Floating point disabled&n;    * Differentiate between DTB single/double misses and 3 or 4 level&n;      page tables&n;    * Istream access violation&n;    * Interrupt&n;    * Icache Parity Error.&n;    * Instruction killed (nop, trapb)&n;&n;   Unfortunately, there seems to be no way to detect Dcache and Bcache&n;   misses; the latter could be approximated by making the counter&n;   count Bcache misses, but that is not precise.&n;&n;   We model this as 20 counters:&n;    * PCTR0&n;    * PCTR1&n;    * 9 ProfileMe events, induced by PCTR0&n;    * 9 ProfileMe events, induced by PCTR1&n;*/
DECL|enum|profileme_counters
r_enum
id|profileme_counters
(brace
DECL|enumerator|PM_STALLED
id|PM_STALLED
comma
multiline_comment|/* Stalled for at least one cycle&n;&t;&t;&t;&t;   between the fetch and map stages  */
DECL|enumerator|PM_TAKEN
id|PM_TAKEN
comma
multiline_comment|/* Conditional branch taken */
DECL|enumerator|PM_MISPREDICT
id|PM_MISPREDICT
comma
multiline_comment|/* Branch caused mispredict trap */
DECL|enumerator|PM_ITB_MISS
id|PM_ITB_MISS
comma
multiline_comment|/* ITB miss */
DECL|enumerator|PM_DTB_MISS
id|PM_DTB_MISS
comma
multiline_comment|/* DTB miss */
DECL|enumerator|PM_REPLAY
id|PM_REPLAY
comma
multiline_comment|/* Replay trap */
DECL|enumerator|PM_LOAD_STORE
id|PM_LOAD_STORE
comma
multiline_comment|/* Load-store order trap */
DECL|enumerator|PM_ICACHE_MISS
id|PM_ICACHE_MISS
comma
multiline_comment|/* Icache miss */
DECL|enumerator|PM_UNALIGNED
id|PM_UNALIGNED
comma
multiline_comment|/* Unaligned Load/Store */
DECL|enumerator|PM_NUM_COUNTERS
id|PM_NUM_COUNTERS
)brace
suffix:semicolon
r_static
r_inline
r_void
DECL|function|op_add_pm
id|op_add_pm
c_func
(paren
r_int
r_int
id|pc
comma
r_int
id|kern
comma
r_int
r_int
id|counter
comma
r_struct
id|op_counter_config
op_star
id|ctr
comma
r_int
r_int
id|event
)paren
(brace
r_int
r_int
id|fake_counter
op_assign
l_int|2
op_plus
id|event
suffix:semicolon
r_if
c_cond
(paren
id|counter
op_eq
l_int|1
)paren
id|fake_counter
op_add_assign
id|PM_NUM_COUNTERS
suffix:semicolon
r_if
c_cond
(paren
id|ctr
(braket
id|fake_counter
)braket
dot
id|enabled
)paren
id|oprofile_add_pc
c_func
(paren
id|pc
comma
id|kern
comma
id|fake_counter
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ev67_handle_interrupt
id|ev67_handle_interrupt
c_func
(paren
r_int
r_int
id|which
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_struct
id|op_counter_config
op_star
id|ctr
)paren
(brace
r_int
r_int
id|pmpc
comma
id|pctr_ctl
suffix:semicolon
r_int
id|kern
op_assign
op_logical_neg
id|user_mode
c_func
(paren
id|regs
)paren
suffix:semicolon
r_int
id|mispredict
op_assign
l_int|0
suffix:semicolon
r_union
(brace
r_int
r_int
id|v
suffix:semicolon
r_struct
(brace
r_int
id|reserved
suffix:colon
l_int|30
suffix:semicolon
multiline_comment|/*  0-29 */
r_int
id|overcount
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* 30-32 */
r_int
id|icache_miss
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/*    33 */
r_int
id|trap_type
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* 34-37 */
r_int
id|load_store
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/*    38 */
r_int
id|trap
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/*    39 */
r_int
id|mispredict
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/*    40 */
)brace
id|fields
suffix:semicolon
)brace
id|i_stat
suffix:semicolon
r_enum
id|trap_types
(brace
id|TRAP_REPLAY
comma
id|TRAP_INVALID0
comma
id|TRAP_DTB_DOUBLE_MISS_3
comma
id|TRAP_DTB_DOUBLE_MISS_4
comma
id|TRAP_FP_DISABLED
comma
id|TRAP_UNALIGNED
comma
id|TRAP_DTB_SINGLE_MISS
comma
id|TRAP_DSTREAM_FAULT
comma
id|TRAP_OPCDEC
comma
id|TRAP_INVALID1
comma
id|TRAP_MACHINE_CHECK
comma
id|TRAP_INVALID2
comma
id|TRAP_ARITHMETIC
comma
id|TRAP_INVALID3
comma
id|TRAP_MT_FPCR
comma
id|TRAP_RESET
)brace
suffix:semicolon
id|pmpc
op_assign
id|wrperfmon
c_func
(paren
l_int|9
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* ??? Don&squot;t know how to handle physical-mode PALcode address.  */
r_if
c_cond
(paren
id|pmpc
op_amp
l_int|1
)paren
r_return
suffix:semicolon
id|pmpc
op_and_assign
op_complement
l_int|2
suffix:semicolon
multiline_comment|/* clear reserved bit */
id|i_stat.v
op_assign
id|wrperfmon
c_func
(paren
l_int|8
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i_stat.fields.trap
)paren
(brace
r_switch
c_cond
(paren
id|i_stat.fields.trap_type
)paren
(brace
r_case
id|TRAP_INVALID1
suffix:colon
r_case
id|TRAP_INVALID2
suffix:colon
r_case
id|TRAP_INVALID3
suffix:colon
multiline_comment|/* Pipeline redirection ocurred. PMPC points&n;&t;&t;&t;   to PALcode. Recognize ITB miss by PALcode&n;&t;&t;&t;   offset address, and get actual PC from&n;&t;&t;&t;   EXC_ADDR.  */
id|oprofile_add_pc
c_func
(paren
id|regs-&gt;pc
comma
id|kern
comma
id|which
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pmpc
op_amp
(paren
(paren
l_int|1
op_lshift
l_int|15
)paren
op_minus
l_int|1
)paren
)paren
op_eq
l_int|581
)paren
id|op_add_pm
c_func
(paren
id|regs-&gt;pc
comma
id|kern
comma
id|which
comma
id|ctr
comma
id|PM_ITB_MISS
)paren
suffix:semicolon
multiline_comment|/* Most other bit and counter values will be&n;&t;&t;&t;   those for the first instruction in the&n;&t;&t;&t;   fault handler, so we&squot;re done.  */
r_return
suffix:semicolon
r_case
id|TRAP_REPLAY
suffix:colon
id|op_add_pm
c_func
(paren
id|pmpc
comma
id|kern
comma
id|which
comma
id|ctr
comma
(paren
id|i_stat.fields.load_store
ques
c_cond
id|PM_LOAD_STORE
suffix:colon
id|PM_REPLAY
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TRAP_DTB_DOUBLE_MISS_3
suffix:colon
r_case
id|TRAP_DTB_DOUBLE_MISS_4
suffix:colon
r_case
id|TRAP_DTB_SINGLE_MISS
suffix:colon
id|op_add_pm
c_func
(paren
id|pmpc
comma
id|kern
comma
id|which
comma
id|ctr
comma
id|PM_DTB_MISS
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TRAP_UNALIGNED
suffix:colon
id|op_add_pm
c_func
(paren
id|pmpc
comma
id|kern
comma
id|which
comma
id|ctr
comma
id|PM_UNALIGNED
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TRAP_INVALID0
suffix:colon
r_case
id|TRAP_FP_DISABLED
suffix:colon
r_case
id|TRAP_DSTREAM_FAULT
suffix:colon
r_case
id|TRAP_OPCDEC
suffix:colon
r_case
id|TRAP_MACHINE_CHECK
suffix:colon
r_case
id|TRAP_ARITHMETIC
suffix:colon
r_case
id|TRAP_MT_FPCR
suffix:colon
r_case
id|TRAP_RESET
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/* ??? JSR/JMP/RET/COR or HW_JSR/HW_JMP/HW_RET/HW_COR&n;&t;&t;   mispredicts do not set this bit but can be&n;&t;&t;   recognized by the presence of one of these&n;&t;&t;   instructions at the PMPC location with bit 39&n;&t;&t;   set.  */
r_if
c_cond
(paren
id|i_stat.fields.mispredict
)paren
(brace
id|mispredict
op_assign
l_int|1
suffix:semicolon
id|op_add_pm
c_func
(paren
id|pmpc
comma
id|kern
comma
id|which
comma
id|ctr
comma
id|PM_MISPREDICT
)paren
suffix:semicolon
)brace
)brace
id|oprofile_add_pc
c_func
(paren
id|pmpc
comma
id|kern
comma
id|which
)paren
suffix:semicolon
id|pctr_ctl
op_assign
id|wrperfmon
c_func
(paren
l_int|5
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pctr_ctl
op_amp
(paren
l_int|1UL
op_lshift
l_int|27
)paren
)paren
id|op_add_pm
c_func
(paren
id|pmpc
comma
id|kern
comma
id|which
comma
id|ctr
comma
id|PM_STALLED
)paren
suffix:semicolon
multiline_comment|/* Unfortunately, TAK is undefined on mispredicted branches.&n;&t;   ??? It is also undefined for non-cbranch insns, should&n;&t;   check that.  */
r_if
c_cond
(paren
op_logical_neg
id|mispredict
op_logical_and
id|pctr_ctl
op_amp
(paren
l_int|1UL
op_lshift
l_int|0
)paren
)paren
id|op_add_pm
c_func
(paren
id|pmpc
comma
id|kern
comma
id|which
comma
id|ctr
comma
id|PM_TAKEN
)paren
suffix:semicolon
)brace
DECL|variable|op_model_ev67
r_struct
id|op_axp_model
id|op_model_ev67
op_assign
(brace
dot
id|reg_setup
op_assign
id|ev67_reg_setup
comma
dot
id|cpu_setup
op_assign
id|ev67_cpu_setup
comma
dot
id|reset_ctr
op_assign
id|ev67_reset_ctr
comma
dot
id|handle_interrupt
op_assign
id|ev67_handle_interrupt
comma
dot
id|cpu_type
op_assign
l_string|&quot;alpha/ev67&quot;
comma
dot
id|num_counters
op_assign
l_int|20
comma
dot
id|can_set_proc_mode
op_assign
l_int|0
comma
)brace
suffix:semicolon
eof
