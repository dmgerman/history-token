multiline_comment|/*&n; * File...........: arch/s390/mm/dcss.c&n; * Author(s)......: Steven Shultz &lt;shultzss@us.ibm.com&gt;&n; *                  Carsten Otte &lt;cotte@de.ibm.com&gt;&n; * Bugreports.to..: &lt;Linux390@de.ibm.com&gt;&n; * thanks to Rob M van der Heij&n; * - he wrote the diag64 function&n; * (C) IBM Corporation 2002&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/ebcdic.h&gt;
macro_line|#include &lt;asm/errno.h&gt;
macro_line|#include &lt;asm/extmem.h&gt;
macro_line|#include &lt;asm/cpcmd.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
DECL|macro|DCSS_DEBUG
mdefine_line|#define DCSS_DEBUG&t;/* Debug messages on/off */
DECL|macro|DCSS_NAME
mdefine_line|#define DCSS_NAME &quot;extmem&quot;
macro_line|#ifdef DCSS_DEBUG
DECL|macro|PRINT_DEBUG
mdefine_line|#define PRINT_DEBUG(x...)&t;printk(KERN_DEBUG DCSS_NAME &quot; debug:&quot; x)
macro_line|#else
DECL|macro|PRINT_DEBUG
mdefine_line|#define PRINT_DEBUG(x...)   do {} while (0)
macro_line|#endif
DECL|macro|PRINT_INFO
mdefine_line|#define PRINT_INFO(x...)&t;printk(KERN_INFO DCSS_NAME &quot; info:&quot; x)
DECL|macro|PRINT_WARN
mdefine_line|#define PRINT_WARN(x...)&t;printk(KERN_WARNING DCSS_NAME &quot; warning:&quot; x)
DECL|macro|PRINT_ERR
mdefine_line|#define PRINT_ERR(x...)&t;&t;printk(KERN_ERR DCSS_NAME &quot; error:&quot; x)
DECL|macro|DCSS_LOADSHR
mdefine_line|#define DCSS_LOADSHR    0x00
DECL|macro|DCSS_LOADNSR
mdefine_line|#define DCSS_LOADNSR    0x04
DECL|macro|DCSS_PURGESEG
mdefine_line|#define DCSS_PURGESEG   0x08
DECL|macro|DCSS_FINDSEG
mdefine_line|#define DCSS_FINDSEG    0x0c
DECL|macro|DCSS_LOADNOLY
mdefine_line|#define DCSS_LOADNOLY   0x10
DECL|macro|DCSS_SEGEXT
mdefine_line|#define DCSS_SEGEXT     0x18
DECL|macro|DCSS_QACTV
mdefine_line|#define DCSS_QACTV      0x0c
DECL|struct|dcss_segment
r_struct
id|dcss_segment
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|dcss_name
r_char
id|dcss_name
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|start_addr
r_int
r_int
id|start_addr
suffix:semicolon
DECL|member|end
r_int
r_int
id|end
suffix:semicolon
DECL|member|ref_count
id|atomic_t
id|ref_count
suffix:semicolon
DECL|member|dcss_attr
r_int
id|dcss_attr
suffix:semicolon
DECL|member|shared_attr
r_int
id|shared_attr
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|dcss_lock
r_static
id|spinlock_t
id|dcss_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|dcss_list
r_static
r_struct
id|list_head
id|dcss_list
op_assign
id|LIST_HEAD_INIT
c_func
(paren
id|dcss_list
)paren
suffix:semicolon
DECL|member|addr
DECL|member|size
DECL|member|type
r_extern
r_struct
(brace
r_int
r_int
id|addr
comma
id|size
comma
id|type
suffix:semicolon
)brace
id|memory_chunk
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/*&n; * Create the 8 bytes, ebcdic VM segment name from&n; * an ascii name.&n; */
DECL|function|dcss_mkname
r_static
r_void
r_inline
id|dcss_mkname
c_func
(paren
r_char
op_star
id|name
comma
r_char
op_star
id|dcss_name
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|name
(braket
id|i
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_break
suffix:semicolon
id|dcss_name
(braket
id|i
)braket
op_assign
id|toupper
c_func
(paren
id|name
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
op_le
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|dcss_name
(braket
id|i
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
id|ASCEBC
c_func
(paren
id|dcss_name
comma
l_int|8
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Perform a function on a dcss segment.&n; */
r_static
r_inline
r_int
DECL|function|dcss_diag
id|dcss_diag
(paren
id|__u8
id|func
comma
r_void
op_star
id|parameter
comma
r_int
r_int
op_star
id|ret1
comma
r_int
r_int
op_star
id|ret2
)paren
(brace
r_int
r_int
id|rx
comma
id|ry
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|rx
op_assign
(paren
r_int
r_int
)paren
id|parameter
suffix:semicolon
id|ry
op_assign
(paren
r_int
r_int
)paren
id|func
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
macro_line|#ifdef CONFIG_ARCH_S390X
l_string|&quot;   sam31&bslash;n&quot;
singleline_comment|// switch to 31 bit
l_string|&quot;   diag    %0,%1,0x64&bslash;n&quot;
l_string|&quot;   sam64&bslash;n&quot;
singleline_comment|// switch back to 64 bit
macro_line|#else
l_string|&quot;   diag    %0,%1,0x64&bslash;n&quot;
macro_line|#endif
l_string|&quot;   ipm     %2&bslash;n&quot;
l_string|&quot;   srl     %2,28&bslash;n&quot;
suffix:colon
l_string|&quot;+d&quot;
(paren
id|rx
)paren
comma
l_string|&quot;+d&quot;
(paren
id|ry
)paren
comma
l_string|&quot;=d&quot;
(paren
id|rc
)paren
suffix:colon
suffix:colon
l_string|&quot;cc&quot;
)paren
suffix:semicolon
op_star
id|ret1
op_assign
id|rx
suffix:semicolon
op_star
id|ret2
op_assign
id|ry
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* use to issue &quot;extended&quot; dcss query */
r_static
r_inline
r_int
DECL|function|dcss_diag_query
id|dcss_diag_query
c_func
(paren
r_char
op_star
id|name
comma
r_int
op_star
id|rwattr
comma
r_int
op_star
id|shattr
comma
r_int
r_int
op_star
id|segstart
comma
r_int
r_int
op_star
id|segend
)paren
(brace
r_int
id|i
comma
id|j
comma
id|rc
suffix:semicolon
r_int
r_int
id|rx
comma
id|ry
suffix:semicolon
r_typedef
r_struct
id|segentry
(brace
r_char
id|thisseg
(braket
l_int|8
)braket
suffix:semicolon
)brace
id|segentry
suffix:semicolon
r_struct
id|qout64
(brace
r_int
id|segstart
suffix:semicolon
r_int
id|segend
suffix:semicolon
r_int
id|segcnt
suffix:semicolon
r_int
id|segrcnt
suffix:semicolon
id|segentry
id|segout
(braket
l_int|6
)braket
suffix:semicolon
)brace
suffix:semicolon
r_struct
id|qin64
(brace
r_char
id|qopcode
suffix:semicolon
r_char
id|rsrv1
(braket
l_int|3
)braket
suffix:semicolon
r_char
id|qrcode
suffix:semicolon
r_char
id|rsrv2
(braket
l_int|3
)braket
suffix:semicolon
r_char
id|qname
(braket
l_int|8
)braket
suffix:semicolon
r_int
r_int
id|qoutptr
suffix:semicolon
r_int
r_int
id|qoutlen
suffix:semicolon
)brace
suffix:semicolon
r_struct
id|qin64
op_star
id|qinarea
suffix:semicolon
r_struct
id|qout64
op_star
id|qoutarea
suffix:semicolon
id|qinarea
op_assign
(paren
r_struct
id|qin64
op_star
)paren
id|get_zeroed_page
(paren
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qinarea
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|qoutarea
op_assign
(paren
r_struct
id|qout64
op_star
)paren
id|get_zeroed_page
(paren
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qoutarea
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|free_page
(paren
(paren
r_int
r_int
)paren
id|qinarea
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|memset
(paren
id|qinarea
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|memset
(paren
id|qoutarea
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|qinarea-&gt;qopcode
op_assign
id|DCSS_QACTV
suffix:semicolon
multiline_comment|/* do a query for active&n;                                          segments */
id|qinarea-&gt;qoutptr
op_assign
(paren
r_int
r_int
)paren
id|qoutarea
suffix:semicolon
id|qinarea-&gt;qoutlen
op_assign
r_sizeof
(paren
r_struct
id|qout64
)paren
suffix:semicolon
multiline_comment|/* Move segment name into double word aligned&n;           field and pad with blanks to 8 long.&n;         */
r_for
c_loop
(paren
id|i
op_assign
id|j
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|qinarea-&gt;qname
(braket
id|i
)braket
op_assign
(paren
id|name
(braket
id|j
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
ques
c_cond
l_char|&squot; &squot;
suffix:colon
id|name
(braket
id|j
op_increment
)braket
suffix:semicolon
)brace
multiline_comment|/* name already in EBCDIC */
multiline_comment|/* ASCEBC ((void *)&amp;qinarea.qname, 8); */
multiline_comment|/* set the assembler variables */
id|rx
op_assign
(paren
r_int
r_int
)paren
id|qinarea
suffix:semicolon
id|ry
op_assign
id|DCSS_SEGEXT
suffix:semicolon
multiline_comment|/* this is extended function */
multiline_comment|/* issue diagnose x&squot;64&squot; */
id|__asm__
id|__volatile__
c_func
(paren
macro_line|#ifdef CONFIG_ARCH_S390X
l_string|&quot;   sam31&bslash;n&quot;
singleline_comment|// switch to 31 bit
l_string|&quot;   diag    %0,%1,0x64&bslash;n&quot;
l_string|&quot;   sam64&bslash;n&quot;
singleline_comment|// switch back to 64 bit
macro_line|#else
l_string|&quot;   diag    %0,%1,0x64&bslash;n&quot;
macro_line|#endif
l_string|&quot;   ipm     %2&bslash;n&quot;
l_string|&quot;   srl     %2,28&bslash;n&quot;
suffix:colon
l_string|&quot;+d&quot;
(paren
id|rx
)paren
comma
l_string|&quot;+d&quot;
(paren
id|ry
)paren
comma
l_string|&quot;=d&quot;
(paren
id|rc
)paren
suffix:colon
suffix:colon
l_string|&quot;cc&quot;
)paren
suffix:semicolon
multiline_comment|/* parse the query output area */
op_star
id|segstart
op_assign
id|qoutarea-&gt;segstart
suffix:semicolon
op_star
id|segend
op_assign
id|qoutarea-&gt;segend
suffix:semicolon
r_if
c_cond
(paren
id|rc
OG
l_int|1
)paren
(brace
op_star
id|rwattr
op_assign
l_int|2
suffix:semicolon
op_star
id|shattr
op_assign
l_int|2
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_goto
id|free
suffix:semicolon
)brace
r_if
c_cond
(paren
id|qoutarea-&gt;segcnt
OG
l_int|6
)paren
(brace
op_star
id|rwattr
op_assign
l_int|3
suffix:semicolon
op_star
id|shattr
op_assign
l_int|3
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_goto
id|free
suffix:semicolon
)brace
op_star
id|rwattr
op_assign
l_int|1
suffix:semicolon
op_star
id|shattr
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|qoutarea-&gt;segrcnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|qoutarea-&gt;segout
(braket
id|i
)braket
dot
id|thisseg
(braket
l_int|3
)braket
op_eq
l_int|2
op_logical_or
id|qoutarea-&gt;segout
(braket
id|i
)braket
dot
id|thisseg
(braket
l_int|3
)braket
op_eq
l_int|3
op_logical_or
id|qoutarea-&gt;segout
(braket
id|i
)braket
dot
id|thisseg
(braket
l_int|3
)braket
op_eq
l_int|6
)paren
op_star
id|rwattr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|qoutarea-&gt;segout
(braket
id|i
)braket
dot
id|thisseg
(braket
l_int|3
)braket
op_eq
l_int|1
op_logical_or
id|qoutarea-&gt;segout
(braket
id|i
)braket
dot
id|thisseg
(braket
l_int|3
)braket
op_eq
l_int|3
op_logical_or
id|qoutarea-&gt;segout
(braket
id|i
)braket
dot
id|thisseg
(braket
l_int|3
)braket
op_eq
l_int|5
)paren
op_star
id|shattr
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end of for statement */
id|rc
op_assign
l_int|0
suffix:semicolon
id|free
suffix:colon
id|free_page
(paren
(paren
r_int
r_int
)paren
id|qoutarea
)paren
suffix:semicolon
id|free_page
(paren
(paren
r_int
r_int
)paren
id|qinarea
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Load a DCSS segment via the diag 0x64.&n; */
DECL|function|segment_load
r_int
id|segment_load
c_func
(paren
r_char
op_star
id|name
comma
r_int
id|segtype
comma
r_int
r_int
op_star
id|addr
comma
r_int
r_int
op_star
id|end
)paren
(brace
r_char
id|dcss_name
(braket
l_int|8
)braket
suffix:semicolon
r_struct
id|list_head
op_star
id|l
suffix:semicolon
r_struct
id|dcss_segment
op_star
id|seg
comma
op_star
id|tmp
suffix:semicolon
r_int
r_int
id|dummy
suffix:semicolon
r_int
r_int
id|segstart
comma
id|segend
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
comma
id|i
suffix:semicolon
r_int
id|rwattr
comma
id|shattr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MACHINE_IS_VM
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
id|dcss_mkname
c_func
(paren
id|name
comma
id|dcss_name
)paren
suffix:semicolon
multiline_comment|/* search for the dcss in list of currently loaded segments */
id|spin_lock
c_func
(paren
op_amp
id|dcss_lock
)paren
suffix:semicolon
id|seg
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|dcss_list
)paren
(brace
id|tmp
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|dcss_segment
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|tmp-&gt;dcss_name
comma
id|dcss_name
comma
l_int|8
)paren
op_eq
l_int|0
)paren
(brace
id|seg
op_assign
id|tmp
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|seg
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* find out the attributes of this&n;                   shared segment */
id|dcss_diag_query
c_func
(paren
id|dcss_name
comma
op_amp
id|rwattr
comma
op_amp
id|shattr
comma
op_amp
id|segstart
comma
op_amp
id|segend
)paren
suffix:semicolon
multiline_comment|/* does segment collide with main memory? */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|memory_chunk
(braket
id|i
)braket
dot
id|type
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|memory_chunk
(braket
id|i
)braket
dot
id|addr
OG
id|segend
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|memory_chunk
(braket
id|i
)braket
dot
id|addr
op_plus
id|memory_chunk
(braket
id|i
)braket
dot
id|size
op_le
id|segstart
)paren
r_continue
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcss_lock
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
multiline_comment|/* or does it collide with other (loaded) segments? */
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|dcss_list
)paren
(brace
id|tmp
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|dcss_segment
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|segstart
op_le
id|tmp-&gt;end
op_logical_and
id|segstart
op_ge
id|tmp-&gt;start_addr
)paren
op_logical_or
(paren
id|segend
op_le
id|tmp-&gt;end
op_logical_and
id|segend
op_ge
id|tmp-&gt;start_addr
)paren
op_logical_or
(paren
id|segstart
op_le
id|tmp-&gt;start_addr
op_logical_and
id|segend
op_ge
id|tmp-&gt;end
)paren
)paren
(brace
id|PRINT_ERR
c_func
(paren
l_string|&quot;Segment Overlap!&bslash;n&quot;
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcss_lock
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
)brace
multiline_comment|/* do case statement on segtype */
multiline_comment|/* if asking for shared ro,&n;                   shared rw works */
multiline_comment|/* if asking for exclusive ro,&n;                   exclusive rw works */
r_switch
c_cond
(paren
id|segtype
)paren
(brace
r_case
id|SEGMENT_SHARED_RO
suffix:colon
r_if
c_cond
(paren
id|shattr
OG
l_int|1
op_logical_or
id|rwattr
OG
l_int|1
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|dcss_lock
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|shattr
op_eq
l_int|0
op_logical_and
id|rwattr
op_eq
l_int|0
)paren
id|rc
op_assign
id|SEGMENT_EXCLUSIVE_RO
suffix:semicolon
r_if
c_cond
(paren
id|shattr
op_eq
l_int|0
op_logical_and
id|rwattr
op_eq
l_int|1
)paren
id|rc
op_assign
id|SEGMENT_EXCLUSIVE_RW
suffix:semicolon
r_if
c_cond
(paren
id|shattr
op_eq
l_int|1
op_logical_and
id|rwattr
op_eq
l_int|0
)paren
id|rc
op_assign
id|SEGMENT_SHARED_RO
suffix:semicolon
r_if
c_cond
(paren
id|shattr
op_eq
l_int|1
op_logical_and
id|rwattr
op_eq
l_int|1
)paren
id|rc
op_assign
id|SEGMENT_SHARED_RW
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SEGMENT_SHARED_RW
suffix:colon
r_if
c_cond
(paren
id|shattr
OG
l_int|1
op_logical_or
id|rwattr
op_ne
l_int|1
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|dcss_lock
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|shattr
op_eq
l_int|0
)paren
id|rc
op_assign
id|SEGMENT_EXCLUSIVE_RW
suffix:semicolon
r_if
c_cond
(paren
id|shattr
op_eq
l_int|1
)paren
id|rc
op_assign
id|SEGMENT_SHARED_RW
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SEGMENT_EXCLUSIVE_RO
suffix:colon
r_if
c_cond
(paren
id|shattr
OG
l_int|0
op_logical_or
id|rwattr
OG
l_int|1
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|dcss_lock
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|rwattr
op_eq
l_int|0
)paren
id|rc
op_assign
id|SEGMENT_EXCLUSIVE_RO
suffix:semicolon
r_if
c_cond
(paren
id|rwattr
op_eq
l_int|1
)paren
id|rc
op_assign
id|SEGMENT_EXCLUSIVE_RW
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SEGMENT_EXCLUSIVE_RW
suffix:colon
multiline_comment|/*                        if (shattr != 0 || rwattr != 1) {&n;                                spin_unlock(&amp;dcss_lock);&n;                                return -ENOENT;&n;                        } else {&n;*/
id|rc
op_assign
id|SEGMENT_EXCLUSIVE_RW
suffix:semicolon
singleline_comment|//                        }
r_break
suffix:semicolon
r_default
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|dcss_lock
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
multiline_comment|/* end switch */
id|seg
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|dcss_segment
)paren
comma
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|seg
op_ne
l_int|NULL
)paren
(brace
id|memcpy
c_func
(paren
id|seg-&gt;dcss_name
comma
id|dcss_name
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
id|SEGMENT_EXCLUSIVE_RW
)paren
(brace
r_if
c_cond
(paren
id|dcss_diag
c_func
(paren
id|DCSS_LOADNSR
comma
id|seg-&gt;dcss_name
comma
op_amp
id|seg-&gt;start_addr
comma
op_amp
id|seg-&gt;end
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|seg-&gt;end
OL
id|max_low_pfn
op_star
id|PAGE_SIZE
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|seg-&gt;ref_count
comma
l_int|1
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|seg-&gt;list
comma
op_amp
id|dcss_list
)paren
suffix:semicolon
op_star
id|addr
op_assign
id|seg-&gt;start_addr
suffix:semicolon
op_star
id|end
op_assign
id|seg-&gt;end
suffix:semicolon
id|seg-&gt;dcss_attr
op_assign
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|shattr
op_eq
l_int|1
op_logical_and
id|rwattr
op_eq
l_int|1
)paren
id|seg-&gt;shared_attr
op_assign
id|SEGMENT_SHARED_RW
suffix:semicolon
r_else
r_if
c_cond
(paren
id|shattr
op_eq
l_int|1
op_logical_and
id|rwattr
op_eq
l_int|0
)paren
id|seg-&gt;shared_attr
op_assign
id|SEGMENT_SHARED_RO
suffix:semicolon
r_else
id|seg-&gt;shared_attr
op_assign
id|SEGMENT_EXCLUSIVE_RW
suffix:semicolon
)brace
r_else
(brace
id|dcss_diag
c_func
(paren
id|DCSS_PURGESEG
comma
id|seg-&gt;dcss_name
comma
op_amp
id|dummy
comma
op_amp
id|dummy
)paren
suffix:semicolon
id|kfree
(paren
id|seg
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOENT
suffix:semicolon
)brace
)brace
r_else
(brace
id|kfree
c_func
(paren
id|seg
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOENT
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dcss_diag
c_func
(paren
id|DCSS_LOADNOLY
comma
id|seg-&gt;dcss_name
comma
op_amp
id|seg-&gt;start_addr
comma
op_amp
id|seg-&gt;end
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|seg-&gt;end
OL
id|max_low_pfn
op_star
id|PAGE_SIZE
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|seg-&gt;ref_count
comma
l_int|1
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|seg-&gt;list
comma
op_amp
id|dcss_list
)paren
suffix:semicolon
op_star
id|addr
op_assign
id|seg-&gt;start_addr
suffix:semicolon
op_star
id|end
op_assign
id|seg-&gt;end
suffix:semicolon
id|seg-&gt;dcss_attr
op_assign
id|rc
suffix:semicolon
id|seg-&gt;shared_attr
op_assign
id|rc
suffix:semicolon
)brace
r_else
(brace
id|dcss_diag
c_func
(paren
id|DCSS_PURGESEG
comma
id|seg-&gt;dcss_name
comma
op_amp
id|dummy
comma
op_amp
id|dummy
)paren
suffix:semicolon
id|kfree
(paren
id|seg
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOENT
suffix:semicolon
)brace
)brace
r_else
(brace
id|kfree
c_func
(paren
id|seg
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENOENT
suffix:semicolon
)brace
)brace
r_else
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* found */
r_if
c_cond
(paren
(paren
id|segtype
op_eq
id|SEGMENT_EXCLUSIVE_RW
)paren
op_logical_and
(paren
id|seg-&gt;dcss_attr
op_ne
id|SEGMENT_EXCLUSIVE_RW
)paren
)paren
(brace
id|PRINT_ERR
c_func
(paren
l_string|&quot;Segment already loaded in other mode than EXCLUSIVE_RW!&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
id|out
suffix:semicolon
multiline_comment|/* reload segment in exclusive mode */
multiline_comment|/*&t;&t;&t;dcss_diag(DCSS_LOADNSR, seg-&gt;dcss_name,&n;&t;&t;&t;&t;  &amp;seg-&gt;start_addr, &amp;seg-&gt;end);&n;&t;&t;&t;seg-&gt;dcss_attr = SEGMENT_EXCLUSIVE_RW;*/
)brace
r_if
c_cond
(paren
(paren
id|segtype
op_ne
id|SEGMENT_EXCLUSIVE_RW
)paren
op_logical_and
(paren
id|seg-&gt;dcss_attr
op_eq
id|SEGMENT_EXCLUSIVE_RW
)paren
)paren
(brace
id|PRINT_ERR
c_func
(paren
l_string|&quot;Segment already loaded in EXCLUSIVE_RW mode!&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
id|seg-&gt;ref_count
)paren
suffix:semicolon
op_star
id|addr
op_assign
id|seg-&gt;start_addr
suffix:semicolon
op_star
id|end
op_assign
id|seg-&gt;end
suffix:semicolon
id|rc
op_assign
id|seg-&gt;dcss_attr
suffix:semicolon
)brace
id|out
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|dcss_lock
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Decrease the use count of a DCSS segment and remove&n; * it from the address space if nobody is using it&n; * any longer.&n; */
DECL|function|segment_unload
r_void
id|segment_unload
c_func
(paren
r_char
op_star
id|name
)paren
(brace
r_char
id|dcss_name
(braket
l_int|8
)braket
suffix:semicolon
r_int
r_int
id|dummy
suffix:semicolon
r_struct
id|list_head
op_star
id|l
comma
op_star
id|l_tmp
suffix:semicolon
r_struct
id|dcss_segment
op_star
id|seg
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MACHINE_IS_VM
)paren
r_return
suffix:semicolon
id|dcss_mkname
c_func
(paren
id|name
comma
id|dcss_name
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcss_lock
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|l
comma
id|l_tmp
comma
op_amp
id|dcss_list
)paren
(brace
id|seg
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|dcss_segment
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|seg-&gt;dcss_name
comma
id|dcss_name
comma
l_int|8
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_return
c_func
(paren
op_amp
id|seg-&gt;ref_count
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Last user of the segment is&n;                                   gone. */
id|list_del
c_func
(paren
op_amp
id|seg-&gt;list
)paren
suffix:semicolon
id|dcss_diag
c_func
(paren
id|DCSS_PURGESEG
comma
id|seg-&gt;dcss_name
comma
op_amp
id|dummy
comma
op_amp
id|dummy
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|seg
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dcss_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Replace an existing DCSS segment, so that machines&n; * that load it anew will see the new version.&n; */
DECL|function|segment_replace
r_void
id|segment_replace
c_func
(paren
r_char
op_star
id|name
)paren
(brace
r_char
id|dcss_name
(braket
l_int|8
)braket
suffix:semicolon
r_struct
id|list_head
op_star
id|l
suffix:semicolon
r_struct
id|dcss_segment
op_star
id|seg
suffix:semicolon
r_int
id|mybeg
op_assign
l_int|0
suffix:semicolon
r_int
id|myend
op_assign
l_int|0
suffix:semicolon
r_char
id|mybuff1
(braket
l_int|80
)braket
suffix:semicolon
r_char
id|mybuff2
(braket
l_int|80
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MACHINE_IS_VM
)paren
r_return
suffix:semicolon
id|dcss_mkname
c_func
(paren
id|name
comma
id|dcss_name
)paren
suffix:semicolon
id|memset
(paren
id|mybuff1
comma
l_int|0
comma
r_sizeof
(paren
id|mybuff1
)paren
)paren
suffix:semicolon
id|memset
(paren
id|mybuff2
comma
l_int|0
comma
r_sizeof
(paren
id|mybuff2
)paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcss_lock
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|l
comma
op_amp
id|dcss_list
)paren
(brace
id|seg
op_assign
id|list_entry
c_func
(paren
id|l
comma
r_struct
id|dcss_segment
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|seg-&gt;dcss_name
comma
id|dcss_name
comma
l_int|8
)paren
op_eq
l_int|0
)paren
(brace
id|mybeg
op_assign
id|seg-&gt;start_addr
op_rshift
l_int|12
suffix:semicolon
id|myend
op_assign
(paren
id|seg-&gt;end
)paren
op_rshift
l_int|12
suffix:semicolon
r_if
c_cond
(paren
id|seg-&gt;shared_attr
op_eq
id|SEGMENT_EXCLUSIVE_RW
)paren
id|sprintf
c_func
(paren
id|mybuff1
comma
l_string|&quot;DEFSEG %s %X-%X EW&quot;
comma
id|name
comma
id|mybeg
comma
id|myend
)paren
suffix:semicolon
r_if
c_cond
(paren
id|seg-&gt;shared_attr
op_eq
id|SEGMENT_EXCLUSIVE_RO
)paren
id|sprintf
c_func
(paren
id|mybuff1
comma
l_string|&quot;DEFSEG %s %X-%X RO&quot;
comma
id|name
comma
id|mybeg
comma
id|myend
)paren
suffix:semicolon
r_if
c_cond
(paren
id|seg-&gt;shared_attr
op_eq
id|SEGMENT_SHARED_RW
)paren
id|sprintf
c_func
(paren
id|mybuff1
comma
l_string|&quot;DEFSEG %s %X-%X SW&quot;
comma
id|name
comma
id|mybeg
comma
id|myend
)paren
suffix:semicolon
r_if
c_cond
(paren
id|seg-&gt;shared_attr
op_eq
id|SEGMENT_SHARED_RO
)paren
id|sprintf
c_func
(paren
id|mybuff1
comma
l_string|&quot;DEFSEG %s %X-%X SR&quot;
comma
id|name
comma
id|mybeg
comma
id|myend
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcss_lock
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|mybuff2
comma
l_string|&quot;SAVESEG %s&quot;
comma
id|name
)paren
suffix:semicolon
id|cpcmd
c_func
(paren
id|mybuff1
comma
l_int|NULL
comma
l_int|80
)paren
suffix:semicolon
id|cpcmd
c_func
(paren
id|mybuff2
comma
l_int|NULL
comma
l_int|80
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|myend
op_eq
l_int|0
)paren
id|spin_unlock
c_func
(paren
op_amp
id|dcss_lock
)paren
suffix:semicolon
)brace
DECL|variable|segment_load
id|EXPORT_SYMBOL
c_func
(paren
id|segment_load
)paren
suffix:semicolon
DECL|variable|segment_unload
id|EXPORT_SYMBOL
c_func
(paren
id|segment_unload
)paren
suffix:semicolon
DECL|variable|segment_replace
id|EXPORT_SYMBOL
c_func
(paren
id|segment_replace
)paren
suffix:semicolon
eof
