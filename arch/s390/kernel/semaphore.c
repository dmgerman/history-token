multiline_comment|/*&n; *  linux/arch/s390/kernel/semaphore.c&n; *&n; *  S390 version&n; *    Copyright (C) 1998-2000 IBM Corporation&n; *    Author(s): Martin Schwidefsky&n; *&n; *  Derived from &quot;linux/arch/i386/kernel/semaphore.c&n; *    Copyright (C) 1999, Linus Torvalds&n; *&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
multiline_comment|/*&n; * Atomically update sem-&gt;count. Equivalent to:&n; *   old_val = sem-&gt;count.counter;&n; *   new_val = ((old_val &gt;= 0) ? old_val : 0) + incr;&n; *   sem-&gt;count.counter = new_val;&n; *   return old_val;&n; */
DECL|function|__sem_update_count
r_static
r_inline
r_int
id|__sem_update_count
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
comma
r_int
id|incr
)paren
(brace
r_int
id|old_val
comma
id|new_val
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;   l     %0,0(%3)&bslash;n&quot;
l_string|&quot;0: ltr   %1,%0&bslash;n&quot;
l_string|&quot;   jhe   1f&bslash;n&quot;
l_string|&quot;   lhi   %1,0&bslash;n&quot;
l_string|&quot;1: ar    %1,%4&bslash;n&quot;
l_string|&quot;   cs    %0,%1,0(%3)&bslash;n&quot;
l_string|&quot;   jl    0b&bslash;n&quot;
suffix:colon
l_string|&quot;=&amp;d&quot;
(paren
id|old_val
)paren
comma
l_string|&quot;=&amp;d&quot;
(paren
id|new_val
)paren
comma
l_string|&quot;=m&quot;
(paren
id|sem-&gt;count
)paren
suffix:colon
l_string|&quot;a&quot;
(paren
op_amp
id|sem-&gt;count
)paren
comma
l_string|&quot;d&quot;
(paren
id|incr
)paren
comma
l_string|&quot;m&quot;
(paren
id|sem-&gt;count
)paren
suffix:colon
l_string|&quot;cc&quot;
)paren
suffix:semicolon
r_return
id|old_val
suffix:semicolon
)brace
multiline_comment|/*&n; * The inline function up() incremented count but the result&n; * was &lt;= 0. This indicates that some process is waiting on&n; * the semaphore. The semaphore is free and we&squot;ll wake the&n; * first sleeping process, so we set count to 1 unless some&n; * other cpu has called up in the meantime in which case&n; * we just increment count by 1.&n; */
DECL|function|__up
r_void
id|__up
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
id|__sem_update_count
c_func
(paren
id|sem
comma
l_int|1
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The inline function down() decremented count and the result&n; * was &lt; 0. The wait loop will atomically test and update the&n; * semaphore counter following the rules:&n; *   count &gt; 0: decrement count, wake up queue and exit.&n; *   count &lt;= 0: set count to -1, go to sleep.&n; */
DECL|function|__down
r_void
id|__down
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
id|__set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
id|__sem_update_count
c_func
(paren
id|sem
comma
op_minus
l_int|1
)paren
op_le
l_int|0
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|__set_task_state
c_func
(paren
id|tsk
comma
id|TASK_RUNNING
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Same as __down() with an additional test for signals.&n; * If a signal is pending the count is updated as follows:&n; *   count &gt; 0: wake up queue and exit.&n; *   count &lt;= 0: set count to 0, wake up queue and exit.&n; */
DECL|function|__down_interruptible
r_int
id|__down_interruptible
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
id|__set_task_state
c_func
(paren
id|tsk
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
id|__sem_update_count
c_func
(paren
id|sem
comma
op_minus
l_int|1
)paren
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|__sem_update_count
c_func
(paren
id|sem
comma
l_int|0
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|__set_task_state
c_func
(paren
id|tsk
comma
id|TASK_RUNNING
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
eof
