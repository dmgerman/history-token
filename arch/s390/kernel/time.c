multiline_comment|/*&n; *  arch/s390/kernel/time.c&n; *&n; *  S390 version&n; *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation&n; *    Author(s): Hartmut Penner (hp@de.ibm.com),&n; *               Martin Schwidefsky (schwidefsky@de.ibm.com),&n; *               Denis Joseph Barrow (djbarrow@de.ibm.com,barrow_dj@yahoo.com)&n; *&n; *  Derived from &quot;arch/i386/kernel/time.c&quot;&n; *    Copyright (C) 1991, 1992, 1995  Linus Torvalds&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/param.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
macro_line|#include &lt;asm/s390_ext.h&gt;
macro_line|#include &lt;asm/div64.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#ifdef CONFIG_VIRT_TIMER
macro_line|#include &lt;asm/timer.h&gt;
macro_line|#endif
multiline_comment|/* change this if you have some constant time drift */
DECL|macro|USECS_PER_JIFFY
mdefine_line|#define USECS_PER_JIFFY     ((unsigned long) 1000000/HZ)
DECL|macro|CLK_TICKS_PER_JIFFY
mdefine_line|#define CLK_TICKS_PER_JIFFY ((unsigned long) USECS_PER_JIFFY &lt;&lt; 12)
multiline_comment|/*&n; * Create a small time difference between the timer interrupts&n; * on the different cpus to avoid lock contention.&n; */
DECL|macro|CPU_DEVIATION
mdefine_line|#define CPU_DEVIATION       (smp_processor_id() &lt;&lt; 12)
DECL|macro|TICK_SIZE
mdefine_line|#define TICK_SIZE tick
DECL|variable|jiffies_64
id|u64
id|jiffies_64
op_assign
id|INITIAL_JIFFIES
suffix:semicolon
DECL|variable|jiffies_64
id|EXPORT_SYMBOL
c_func
(paren
id|jiffies_64
)paren
suffix:semicolon
DECL|variable|ext_int_info_cc
r_static
id|ext_int_info_t
id|ext_int_info_cc
suffix:semicolon
DECL|variable|init_timer_cc
r_static
id|u64
id|init_timer_cc
suffix:semicolon
DECL|variable|jiffies_timer_cc
r_static
id|u64
id|jiffies_timer_cc
suffix:semicolon
DECL|variable|xtime_cc
r_static
id|u64
id|xtime_cc
suffix:semicolon
r_extern
r_int
r_int
id|wall_jiffies
suffix:semicolon
macro_line|#ifdef CONFIG_VIRT_TIMER
DECL|macro|VTIMER_MAGIC
mdefine_line|#define VTIMER_MAGIC (0x4b87ad6e + 1)
DECL|variable|ext_int_info_timer
r_static
id|ext_int_info_t
id|ext_int_info_timer
suffix:semicolon
id|DEFINE_PER_CPU
c_func
(paren
r_struct
id|vtimer_queue
comma
id|virt_cpu_timer
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Scheduler clock - returns current time in nanosec units.&n; */
DECL|function|sched_clock
r_int
r_int
r_int
id|sched_clock
c_func
(paren
r_void
)paren
(brace
r_return
(paren
(paren
id|get_clock
c_func
(paren
)paren
op_minus
id|jiffies_timer_cc
)paren
op_star
l_int|1000
)paren
op_rshift
l_int|12
suffix:semicolon
)brace
DECL|function|tod_to_timeval
r_void
id|tod_to_timeval
c_func
(paren
id|__u64
id|todval
comma
r_struct
id|timespec
op_star
id|xtime
)paren
(brace
r_int
r_int
r_int
id|sec
suffix:semicolon
id|sec
op_assign
id|todval
op_rshift
l_int|12
suffix:semicolon
id|do_div
c_func
(paren
id|sec
comma
l_int|1000000
)paren
suffix:semicolon
id|xtime-&gt;tv_sec
op_assign
id|sec
suffix:semicolon
id|todval
op_sub_assign
(paren
id|sec
op_star
l_int|1000000
)paren
op_lshift
l_int|12
suffix:semicolon
id|xtime-&gt;tv_nsec
op_assign
(paren
(paren
id|todval
op_star
l_int|1000
)paren
op_rshift
l_int|12
)paren
suffix:semicolon
)brace
DECL|function|do_gettimeoffset
r_static
r_inline
r_int
r_int
id|do_gettimeoffset
c_func
(paren
r_void
)paren
(brace
id|__u64
id|now
suffix:semicolon
id|now
op_assign
(paren
id|get_clock
c_func
(paren
)paren
op_minus
id|jiffies_timer_cc
)paren
op_rshift
l_int|12
suffix:semicolon
multiline_comment|/* We require the offset from the latest update of xtime */
id|now
op_sub_assign
(paren
id|__u64
)paren
id|wall_jiffies
op_star
id|USECS_PER_JIFFY
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
id|now
suffix:semicolon
)brace
multiline_comment|/*&n; * This version of gettimeofday has microsecond resolution.&n; */
DECL|function|do_gettimeofday
r_void
id|do_gettimeofday
c_func
(paren
r_struct
id|timeval
op_star
id|tv
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|seq
suffix:semicolon
r_int
r_int
id|usec
comma
id|sec
suffix:semicolon
r_do
(brace
id|seq
op_assign
id|read_seqbegin_irqsave
c_func
(paren
op_amp
id|xtime_lock
comma
id|flags
)paren
suffix:semicolon
id|sec
op_assign
id|xtime.tv_sec
suffix:semicolon
id|usec
op_assign
id|xtime.tv_nsec
op_div
l_int|1000
op_plus
id|do_gettimeoffset
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|read_seqretry_irqrestore
c_func
(paren
op_amp
id|xtime_lock
comma
id|seq
comma
id|flags
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|usec
op_ge
l_int|1000000
)paren
(brace
id|usec
op_sub_assign
l_int|1000000
suffix:semicolon
id|sec
op_increment
suffix:semicolon
)brace
id|tv-&gt;tv_sec
op_assign
id|sec
suffix:semicolon
id|tv-&gt;tv_usec
op_assign
id|usec
suffix:semicolon
)brace
DECL|variable|do_gettimeofday
id|EXPORT_SYMBOL
c_func
(paren
id|do_gettimeofday
)paren
suffix:semicolon
DECL|function|do_settimeofday
r_int
id|do_settimeofday
c_func
(paren
r_struct
id|timespec
op_star
id|tv
)paren
(brace
id|time_t
id|wtm_sec
comma
id|sec
op_assign
id|tv-&gt;tv_sec
suffix:semicolon
r_int
id|wtm_nsec
comma
id|nsec
op_assign
id|tv-&gt;tv_nsec
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|tv-&gt;tv_nsec
op_ge
id|NSEC_PER_SEC
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|write_seqlock_irq
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
multiline_comment|/* This is revolting. We need to set the xtime.tv_nsec&n;&t; * correctly. However, the value in this location is&n;&t; * is value at the last tick.&n;&t; * Discover what correction gettimeofday&n;&t; * would have done, and then undo it!&n;&t; */
id|nsec
op_sub_assign
id|do_gettimeoffset
c_func
(paren
)paren
op_star
l_int|1000
suffix:semicolon
id|wtm_sec
op_assign
id|wall_to_monotonic.tv_sec
op_plus
(paren
id|xtime.tv_sec
op_minus
id|sec
)paren
suffix:semicolon
id|wtm_nsec
op_assign
id|wall_to_monotonic.tv_nsec
op_plus
(paren
id|xtime.tv_nsec
op_minus
id|nsec
)paren
suffix:semicolon
id|set_normalized_timespec
c_func
(paren
op_amp
id|xtime
comma
id|sec
comma
id|nsec
)paren
suffix:semicolon
id|set_normalized_timespec
c_func
(paren
op_amp
id|wall_to_monotonic
comma
id|wtm_sec
comma
id|wtm_nsec
)paren
suffix:semicolon
id|time_adjust
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* stop active adjtime() */
id|time_status
op_or_assign
id|STA_UNSYNC
suffix:semicolon
id|time_maxerror
op_assign
id|NTP_PHASE_LIMIT
suffix:semicolon
id|time_esterror
op_assign
id|NTP_PHASE_LIMIT
suffix:semicolon
id|write_sequnlock_irq
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
id|clock_was_set
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|do_settimeofday
id|EXPORT_SYMBOL
c_func
(paren
id|do_settimeofday
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_ARCH_S390X
r_static
r_inline
id|__u32
DECL|function|__calculate_ticks
id|__calculate_ticks
c_func
(paren
id|__u64
id|elapsed
)paren
(brace
id|register_pair
id|rp
suffix:semicolon
id|rp.pair
op_assign
id|elapsed
op_rshift
l_int|1
suffix:semicolon
id|asm
(paren
l_string|&quot;dr %0,%1&quot;
suffix:colon
l_string|&quot;+d&quot;
(paren
id|rp
)paren
suffix:colon
l_string|&quot;d&quot;
(paren
id|CLK_TICKS_PER_JIFFY
op_rshift
l_int|1
)paren
)paren
suffix:semicolon
r_return
id|rp.subreg.odd
suffix:semicolon
)brace
macro_line|#else /* CONFIG_ARCH_S390X */
r_static
r_inline
id|__u32
DECL|function|__calculate_ticks
id|__calculate_ticks
c_func
(paren
id|__u64
id|elapsed
)paren
(brace
r_return
id|elapsed
op_div
id|CLK_TICKS_PER_JIFFY
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_ARCH_S390X */
multiline_comment|/*&n; * timer_interrupt() needs to keep up the real-time clock,&n; * as well as call the &quot;do_timer()&quot; routine every clocktick&n; */
DECL|function|account_ticks
r_void
id|account_ticks
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|__u64
id|tmp
suffix:semicolon
id|__u32
id|ticks
suffix:semicolon
multiline_comment|/* Calculate how many ticks have passed. */
id|tmp
op_assign
id|S390_lowcore.int_clock
op_minus
id|S390_lowcore.jiffy_timer
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_ge
l_int|2
op_star
id|CLK_TICKS_PER_JIFFY
)paren
(brace
multiline_comment|/* more than two ticks ? */
id|ticks
op_assign
id|__calculate_ticks
c_func
(paren
id|tmp
)paren
op_plus
l_int|1
suffix:semicolon
id|S390_lowcore.jiffy_timer
op_add_assign
id|CLK_TICKS_PER_JIFFY
op_star
(paren
id|__u64
)paren
id|ticks
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tmp
op_ge
id|CLK_TICKS_PER_JIFFY
)paren
(brace
id|ticks
op_assign
l_int|2
suffix:semicolon
id|S390_lowcore.jiffy_timer
op_add_assign
l_int|2
op_star
id|CLK_TICKS_PER_JIFFY
suffix:semicolon
)brace
r_else
(brace
id|ticks
op_assign
l_int|1
suffix:semicolon
id|S390_lowcore.jiffy_timer
op_add_assign
id|CLK_TICKS_PER_JIFFY
suffix:semicolon
)brace
multiline_comment|/* set clock comparator for next tick */
id|tmp
op_assign
id|S390_lowcore.jiffy_timer
op_plus
id|CPU_DEVIATION
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;SCKC %0&quot;
suffix:colon
suffix:colon
l_string|&quot;m&quot;
(paren
id|tmp
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n;&t; * Do not rely on the boot cpu to do the calls to do_timer.&n;&t; * Spread it over all cpus instead.&n;&t; */
id|write_seqlock
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S390_lowcore.jiffy_timer
OG
id|xtime_cc
)paren
(brace
id|__u32
id|xticks
suffix:semicolon
id|tmp
op_assign
id|S390_lowcore.jiffy_timer
op_minus
id|xtime_cc
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_ge
l_int|2
op_star
id|CLK_TICKS_PER_JIFFY
)paren
(brace
id|xticks
op_assign
id|__calculate_ticks
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|xtime_cc
op_add_assign
(paren
id|__u64
)paren
id|xticks
op_star
id|CLK_TICKS_PER_JIFFY
suffix:semicolon
)brace
r_else
(brace
id|xticks
op_assign
l_int|1
suffix:semicolon
id|xtime_cc
op_add_assign
id|CLK_TICKS_PER_JIFFY
suffix:semicolon
)brace
r_while
c_loop
(paren
id|xticks
op_decrement
)paren
id|do_timer
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
id|write_sequnlock
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ticks
op_decrement
)paren
id|update_process_times
c_func
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
suffix:semicolon
macro_line|#else
r_while
c_loop
(paren
id|ticks
op_decrement
)paren
id|do_timer
c_func
(paren
id|regs
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef CONFIG_VIRT_TIMER
DECL|function|start_cpu_timer
r_void
id|start_cpu_timer
c_func
(paren
r_void
)paren
(brace
r_struct
id|vtimer_queue
op_star
id|vt_list
suffix:semicolon
id|vt_list
op_assign
op_amp
id|per_cpu
c_func
(paren
id|virt_cpu_timer
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|set_vtimer
c_func
(paren
id|vt_list-&gt;idle
)paren
suffix:semicolon
)brace
DECL|function|stop_cpu_timer
r_int
id|stop_cpu_timer
c_func
(paren
r_void
)paren
(brace
id|__u64
id|done
suffix:semicolon
r_struct
id|vtimer_queue
op_star
id|vt_list
suffix:semicolon
id|vt_list
op_assign
op_amp
id|per_cpu
c_func
(paren
id|virt_cpu_timer
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* nothing to do */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|vt_list-&gt;list
)paren
)paren
(brace
id|vt_list-&gt;idle
op_assign
id|VTIMER_MAX_SLICE
suffix:semicolon
r_goto
id|fire
suffix:semicolon
)brace
multiline_comment|/* store progress */
id|asm
r_volatile
(paren
l_string|&quot;STPT %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|done
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If done is negative we do not stop the CPU timer&n;&t; * because we will get instantly an interrupt that&n;&t; * will start the CPU timer again.&n;&t; */
r_if
c_cond
(paren
id|done
op_amp
l_int|1LL
op_lshift
l_int|63
)paren
r_return
l_int|1
suffix:semicolon
r_else
id|vt_list-&gt;offset
op_add_assign
id|vt_list-&gt;to_expire
op_minus
id|done
suffix:semicolon
multiline_comment|/* save the actual expire value */
id|vt_list-&gt;idle
op_assign
id|done
suffix:semicolon
multiline_comment|/*&n;&t; * We cannot halt the CPU timer, we just write a value that&n;&t; * nearly never expires (only after 71 years) and re-write&n;&t; * the stored expire value if we continue the timer&n;&t; */
id|fire
suffix:colon
id|set_vtimer
c_func
(paren
id|VTIMER_MAX_SLICE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|set_vtimer
r_void
id|set_vtimer
c_func
(paren
id|__u64
id|expires
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;SPT %0&quot;
suffix:colon
suffix:colon
l_string|&quot;m&quot;
(paren
id|expires
)paren
)paren
suffix:semicolon
multiline_comment|/* store expire time for this CPU timer */
id|per_cpu
c_func
(paren
id|virt_cpu_timer
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
dot
id|to_expire
op_assign
id|expires
suffix:semicolon
)brace
multiline_comment|/*&n; * Sorted add to a list. List is linear searched until first bigger&n; * element is found.&n; */
DECL|function|list_add_sorted
r_void
id|list_add_sorted
c_func
(paren
r_struct
id|vtimer_list
op_star
id|timer
comma
r_struct
id|list_head
op_star
id|head
)paren
(brace
r_struct
id|vtimer_list
op_star
id|event
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|event
comma
id|head
comma
id|entry
)paren
(brace
r_if
c_cond
(paren
id|event-&gt;expires
OG
id|timer-&gt;expires
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|timer-&gt;entry
comma
op_amp
id|event-&gt;entry
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|list_add_tail
c_func
(paren
op_amp
id|timer-&gt;entry
comma
id|head
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Do the callback functions of expired vtimer events.&n; * Called from within the interrupt handler.&n; */
DECL|function|do_callbacks
r_static
r_void
id|do_callbacks
c_func
(paren
r_struct
id|list_head
op_star
id|cb_list
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|vtimer_queue
op_star
id|vt_list
suffix:semicolon
r_struct
id|vtimer_list
op_star
id|event
comma
op_star
id|tmp
suffix:semicolon
r_void
(paren
op_star
id|fn
)paren
(paren
r_int
r_int
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_int
r_int
id|data
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
id|cb_list
)paren
)paren
r_return
suffix:semicolon
id|vt_list
op_assign
op_amp
id|per_cpu
c_func
(paren
id|virt_cpu_timer
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|event
comma
id|tmp
comma
id|cb_list
comma
id|entry
)paren
(brace
id|fn
op_assign
id|event-&gt;function
suffix:semicolon
id|data
op_assign
id|event-&gt;data
suffix:semicolon
id|fn
c_func
(paren
id|data
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|event-&gt;interval
)paren
multiline_comment|/* delete one shot timer */
id|list_del_init
c_func
(paren
op_amp
id|event-&gt;entry
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* move interval timer back to list */
id|spin_lock
c_func
(paren
op_amp
id|vt_list-&gt;lock
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|event-&gt;entry
)paren
suffix:semicolon
id|list_add_sorted
c_func
(paren
id|event
comma
op_amp
id|vt_list-&gt;list
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|vt_list-&gt;lock
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Handler for the virtual CPU timer.&n; */
DECL|function|do_cpu_timer_interrupt
r_static
r_void
id|do_cpu_timer_interrupt
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
id|__u16
id|error_code
)paren
(brace
r_int
id|cpu
suffix:semicolon
id|__u64
id|next
comma
id|delta
suffix:semicolon
r_struct
id|vtimer_queue
op_star
id|vt_list
suffix:semicolon
r_struct
id|vtimer_list
op_star
id|event
comma
op_star
id|tmp
suffix:semicolon
r_struct
id|list_head
op_star
id|ptr
suffix:semicolon
multiline_comment|/* the callback queue */
r_struct
id|list_head
id|cb_list
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cb_list
)paren
suffix:semicolon
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|vt_list
op_assign
op_amp
id|per_cpu
c_func
(paren
id|virt_cpu_timer
comma
id|cpu
)paren
suffix:semicolon
multiline_comment|/* walk timer list, fire all expired events */
id|spin_lock
c_func
(paren
op_amp
id|vt_list-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vt_list-&gt;to_expire
OL
id|VTIMER_MAX_SLICE
)paren
id|vt_list-&gt;offset
op_add_assign
id|vt_list-&gt;to_expire
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|event
comma
id|tmp
comma
op_amp
id|vt_list-&gt;list
comma
id|entry
)paren
(brace
r_if
c_cond
(paren
id|event-&gt;expires
OG
id|vt_list-&gt;offset
)paren
multiline_comment|/* found first unexpired event, leave */
r_break
suffix:semicolon
multiline_comment|/* re-charge interval timer, we have to add the offset */
r_if
c_cond
(paren
id|event-&gt;interval
)paren
id|event-&gt;expires
op_assign
id|event-&gt;interval
op_plus
id|vt_list-&gt;offset
suffix:semicolon
multiline_comment|/* move expired timer to the callback queue */
id|list_move_tail
c_func
(paren
op_amp
id|event-&gt;entry
comma
op_amp
id|cb_list
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|vt_list-&gt;lock
)paren
suffix:semicolon
id|do_callbacks
c_func
(paren
op_amp
id|cb_list
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/* next event is first in list */
id|spin_lock
c_func
(paren
op_amp
id|vt_list-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|vt_list-&gt;list
)paren
)paren
(brace
id|ptr
op_assign
id|vt_list-&gt;list.next
suffix:semicolon
id|event
op_assign
id|list_entry
c_func
(paren
id|ptr
comma
r_struct
id|vtimer_list
comma
id|entry
)paren
suffix:semicolon
id|next
op_assign
id|event-&gt;expires
op_minus
id|vt_list-&gt;offset
suffix:semicolon
multiline_comment|/* add the expired time from this interrupt handler&n;&t;&t; * and the callback functions&n;&t;&t; */
id|asm
r_volatile
(paren
l_string|&quot;STPT %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|delta
)paren
)paren
suffix:semicolon
id|delta
op_assign
l_int|0xffffffffffffffffLL
op_minus
id|delta
op_plus
l_int|1
suffix:semicolon
id|vt_list-&gt;offset
op_add_assign
id|delta
suffix:semicolon
id|next
op_sub_assign
id|delta
suffix:semicolon
)brace
r_else
(brace
id|vt_list-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|next
op_assign
id|VTIMER_MAX_SLICE
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|vt_list-&gt;lock
)paren
suffix:semicolon
id|set_vtimer
c_func
(paren
id|next
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_NO_IDLE_HZ
macro_line|#ifdef CONFIG_NO_IDLE_HZ_INIT
DECL|variable|sysctl_hz_timer
r_int
id|sysctl_hz_timer
op_assign
l_int|0
suffix:semicolon
macro_line|#else
DECL|variable|sysctl_hz_timer
r_int
id|sysctl_hz_timer
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Start the HZ tick on the current CPU.&n; * Only cpu_idle may call this function.&n; */
DECL|function|start_hz_timer
r_void
id|start_hz_timer
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|__u64
id|tmp
suffix:semicolon
id|__u32
id|ticks
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_isset
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
comma
id|idle_cpu_mask
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Calculate how many ticks have passed */
id|asm
r_volatile
(paren
l_string|&quot;STCK 0(%0)&quot;
suffix:colon
suffix:colon
l_string|&quot;a&quot;
(paren
op_amp
id|tmp
)paren
suffix:colon
l_string|&quot;memory&quot;
comma
l_string|&quot;cc&quot;
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp
op_plus
id|CLK_TICKS_PER_JIFFY
op_minus
id|S390_lowcore.jiffy_timer
suffix:semicolon
id|ticks
op_assign
id|__calculate_ticks
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|S390_lowcore.jiffy_timer
op_add_assign
id|CLK_TICKS_PER_JIFFY
op_star
(paren
id|__u64
)paren
id|ticks
suffix:semicolon
multiline_comment|/* Set the clock comparator to the next tick. */
id|tmp
op_assign
id|S390_lowcore.jiffy_timer
op_plus
id|CPU_DEVIATION
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;SCKC %0&quot;
suffix:colon
suffix:colon
l_string|&quot;m&quot;
(paren
id|tmp
)paren
)paren
suffix:semicolon
multiline_comment|/* Charge the ticks. */
r_if
c_cond
(paren
id|ticks
OG
l_int|0
)paren
(brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n;&t;&t; * Do not rely on the boot cpu to do the calls to do_timer.&n;&t;&t; * Spread it over all cpus instead.&n;&t;&t; */
id|write_seqlock
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S390_lowcore.jiffy_timer
OG
id|xtime_cc
)paren
(brace
id|__u32
id|xticks
suffix:semicolon
id|tmp
op_assign
id|S390_lowcore.jiffy_timer
op_minus
id|xtime_cc
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_ge
l_int|2
op_star
id|CLK_TICKS_PER_JIFFY
)paren
(brace
id|xticks
op_assign
id|__calculate_ticks
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|xtime_cc
op_add_assign
(paren
id|__u64
)paren
id|xticks
op_star
id|CLK_TICKS_PER_JIFFY
suffix:semicolon
)brace
r_else
(brace
id|xticks
op_assign
l_int|1
suffix:semicolon
id|xtime_cc
op_add_assign
id|CLK_TICKS_PER_JIFFY
suffix:semicolon
)brace
r_while
c_loop
(paren
id|xticks
op_decrement
)paren
id|do_timer
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
id|write_sequnlock
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ticks
op_decrement
)paren
id|update_process_times
c_func
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
suffix:semicolon
macro_line|#else
r_while
c_loop
(paren
id|ticks
op_decrement
)paren
id|do_timer
c_func
(paren
id|regs
)paren
suffix:semicolon
macro_line|#endif
)brace
id|cpu_clear
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
comma
id|idle_cpu_mask
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Stop the HZ tick on the current CPU.&n; * Only cpu_idle may call this function.&n; */
DECL|function|stop_hz_timer
r_int
id|stop_hz_timer
c_func
(paren
r_void
)paren
(brace
id|__u64
id|timer
suffix:semicolon
r_if
c_cond
(paren
id|sysctl_hz_timer
op_ne
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Leave the clock comparator set up for the next timer&n;&t; * tick if either rcu or a softirq is pending.&n;&t; */
r_if
c_cond
(paren
id|rcu_pending
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
)paren
op_logical_or
id|local_softirq_pending
c_func
(paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * This cpu is going really idle. Set up the clock comparator&n;&t; * for the next event.&n;&t; */
id|cpu_set
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
comma
id|idle_cpu_mask
)paren
suffix:semicolon
id|timer
op_assign
(paren
id|__u64
)paren
(paren
id|next_timer_interrupt
c_func
(paren
)paren
op_minus
id|jiffies
)paren
op_plus
id|jiffies_64
suffix:semicolon
id|timer
op_assign
id|jiffies_timer_cc
op_plus
id|timer
op_star
id|CLK_TICKS_PER_JIFFY
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;SCKC %0&quot;
suffix:colon
suffix:colon
l_string|&quot;m&quot;
(paren
id|timer
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if defined(CONFIG_VIRT_TIMER) || defined(CONFIG_NO_IDLE_HZ)
DECL|function|do_monitor_call
r_void
id|do_monitor_call
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|interruption_code
)paren
(brace
multiline_comment|/* disable monitor call class 0 */
id|__ctl_clear_bit
c_func
(paren
l_int|8
comma
l_int|15
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_VIRT_TIMER
id|start_cpu_timer
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NO_IDLE_HZ
id|start_hz_timer
c_func
(paren
id|regs
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * called from cpu_idle to stop any timers&n; * returns 1 if CPU should not be stopped&n; */
DECL|function|stop_timers
r_int
id|stop_timers
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_VIRT_TIMER
r_if
c_cond
(paren
id|stop_cpu_timer
c_func
(paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NO_IDLE_HZ
r_if
c_cond
(paren
id|stop_hz_timer
c_func
(paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
macro_line|#endif
multiline_comment|/* enable monitor call class 0 */
id|__ctl_set_bit
c_func
(paren
l_int|8
comma
l_int|15
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Start the clock comparator and the virtual CPU timer&n; * on the current CPU.&n; */
DECL|function|init_cpu_timer
r_void
id|init_cpu_timer
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|cr0
suffix:semicolon
id|__u64
id|timer
suffix:semicolon
macro_line|#ifdef CONFIG_VIRT_TIMER
r_struct
id|vtimer_queue
op_star
id|vt_list
suffix:semicolon
macro_line|#endif
id|timer
op_assign
id|jiffies_timer_cc
op_plus
id|jiffies_64
op_star
id|CLK_TICKS_PER_JIFFY
suffix:semicolon
id|S390_lowcore.jiffy_timer
op_assign
id|timer
op_plus
id|CLK_TICKS_PER_JIFFY
suffix:semicolon
id|timer
op_add_assign
id|CLK_TICKS_PER_JIFFY
op_plus
id|CPU_DEVIATION
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;SCKC %0&quot;
suffix:colon
suffix:colon
l_string|&quot;m&quot;
(paren
id|timer
)paren
)paren
suffix:semicolon
multiline_comment|/* allow clock comparator timer interrupt */
id|__ctl_store
c_func
(paren
id|cr0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|cr0
op_or_assign
l_int|0x800
suffix:semicolon
id|__ctl_load
c_func
(paren
id|cr0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_VIRT_TIMER
multiline_comment|/* kick the virtual timer */
id|timer
op_assign
id|VTIMER_MAX_SLICE
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;SPT %0&quot;
suffix:colon
suffix:colon
l_string|&quot;m&quot;
(paren
id|timer
)paren
)paren
suffix:semicolon
id|__ctl_store
c_func
(paren
id|cr0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|cr0
op_or_assign
l_int|0x400
suffix:semicolon
id|__ctl_load
c_func
(paren
id|cr0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|vt_list
op_assign
op_amp
id|per_cpu
c_func
(paren
id|virt_cpu_timer
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|vt_list-&gt;list
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|vt_list-&gt;lock
)paren
suffix:semicolon
id|vt_list-&gt;to_expire
op_assign
l_int|0
suffix:semicolon
id|vt_list-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|vt_list-&gt;idle
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Initialize the TOD clock and the CPU timer of&n; * the boot cpu.&n; */
DECL|function|time_init
r_void
id|__init
id|time_init
c_func
(paren
r_void
)paren
(brace
id|__u64
id|set_time_cc
suffix:semicolon
r_int
id|cc
suffix:semicolon
multiline_comment|/* kick the TOD clock */
id|asm
r_volatile
(paren
l_string|&quot;STCK 0(%1)&bslash;n&bslash;t&quot;
l_string|&quot;IPM  %0&bslash;n&bslash;t&quot;
l_string|&quot;SRL  %0,28&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|cc
)paren
suffix:colon
l_string|&quot;a&quot;
(paren
op_amp
id|init_timer_cc
)paren
suffix:colon
l_string|&quot;memory&quot;
comma
l_string|&quot;cc&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cc
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* clock in set state: all is fine */
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* clock in non-set state: FIXME */
id|printk
c_func
(paren
l_string|&quot;time_init: TOD clock in non-set state&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* clock in error state: FIXME */
id|printk
c_func
(paren
l_string|&quot;time_init: TOD clock in error state&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* clock in stopped or not-operational state: FIXME */
id|printk
c_func
(paren
l_string|&quot;time_init: TOD clock stopped/non-operational&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|jiffies_timer_cc
op_assign
id|init_timer_cc
op_minus
id|jiffies_64
op_star
id|CLK_TICKS_PER_JIFFY
suffix:semicolon
multiline_comment|/* set xtime */
id|xtime_cc
op_assign
id|init_timer_cc
op_plus
id|CLK_TICKS_PER_JIFFY
suffix:semicolon
id|set_time_cc
op_assign
id|init_timer_cc
op_minus
l_int|0x8126d60e46000000LL
op_plus
(paren
l_int|0x3c26700LL
op_star
l_int|1000000
op_star
l_int|4096
)paren
suffix:semicolon
id|tod_to_timeval
c_func
(paren
id|set_time_cc
comma
op_amp
id|xtime
)paren
suffix:semicolon
id|set_normalized_timespec
c_func
(paren
op_amp
id|wall_to_monotonic
comma
op_minus
id|xtime.tv_sec
comma
op_minus
id|xtime.tv_nsec
)paren
suffix:semicolon
multiline_comment|/* request the clock comparator external interrupt */
r_if
c_cond
(paren
id|register_early_external_interrupt
c_func
(paren
l_int|0x1004
comma
l_int|0
comma
op_amp
id|ext_int_info_cc
)paren
op_ne
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Couldn&squot;t request external interrupt 0x1004&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_VIRT_TIMER
multiline_comment|/* request the cpu timer external interrupt */
r_if
c_cond
(paren
id|register_early_external_interrupt
c_func
(paren
l_int|0x1005
comma
id|do_cpu_timer_interrupt
comma
op_amp
id|ext_int_info_timer
)paren
op_ne
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Couldn&squot;t request external interrupt 0x1005&quot;
)paren
suffix:semicolon
macro_line|#endif
id|init_cpu_timer
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_VIRT_TIMER
DECL|function|init_virt_timer
r_void
id|init_virt_timer
c_func
(paren
r_struct
id|vtimer_list
op_star
id|timer
)paren
(brace
id|timer-&gt;magic
op_assign
id|VTIMER_MAGIC
suffix:semicolon
id|timer-&gt;function
op_assign
l_int|NULL
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|timer-&gt;entry
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|timer-&gt;lock
)paren
suffix:semicolon
)brace
DECL|function|check_vtimer
r_static
r_inline
r_int
id|check_vtimer
c_func
(paren
r_struct
id|vtimer_list
op_star
id|timer
)paren
(brace
r_if
c_cond
(paren
id|timer-&gt;magic
op_ne
id|VTIMER_MAGIC
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|vtimer_pending
r_static
r_inline
r_int
id|vtimer_pending
c_func
(paren
r_struct
id|vtimer_list
op_star
id|timer
)paren
(brace
r_return
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|timer-&gt;entry
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * this function should only run on the specified CPU&n; */
DECL|function|internal_add_vtimer
r_static
r_void
id|internal_add_vtimer
c_func
(paren
r_struct
id|vtimer_list
op_star
id|timer
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|__u64
id|done
suffix:semicolon
r_struct
id|vtimer_list
op_star
id|event
suffix:semicolon
r_struct
id|vtimer_queue
op_star
id|vt_list
suffix:semicolon
id|vt_list
op_assign
op_amp
id|per_cpu
c_func
(paren
id|virt_cpu_timer
comma
id|timer-&gt;cpu
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|vt_list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer-&gt;cpu
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;internal_add_vtimer: BUG, running on wrong CPU&quot;
)paren
suffix:semicolon
multiline_comment|/* if list is empty we only have to set the timer */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|vt_list-&gt;list
)paren
)paren
(brace
multiline_comment|/* reset the offset, this may happen if the last timer was&n;&t;&t; * just deleted by mod_virt_timer and the interrupt&n;&t;&t; * didn&squot;t happen until here&n;&t;&t; */
id|vt_list-&gt;offset
op_assign
l_int|0
suffix:semicolon
r_goto
id|fire
suffix:semicolon
)brace
multiline_comment|/* save progress */
id|asm
r_volatile
(paren
l_string|&quot;STPT %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|done
)paren
)paren
suffix:semicolon
multiline_comment|/* calculate completed work */
id|done
op_assign
id|vt_list-&gt;to_expire
op_minus
id|done
op_plus
id|vt_list-&gt;offset
suffix:semicolon
id|vt_list-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|event
comma
op_amp
id|vt_list-&gt;list
comma
id|entry
)paren
id|event-&gt;expires
op_sub_assign
id|done
suffix:semicolon
id|fire
suffix:colon
id|list_add_sorted
c_func
(paren
id|timer
comma
op_amp
id|vt_list-&gt;list
)paren
suffix:semicolon
multiline_comment|/* get first element, which is the next vtimer slice */
id|event
op_assign
id|list_entry
c_func
(paren
id|vt_list-&gt;list.next
comma
r_struct
id|vtimer_list
comma
id|entry
)paren
suffix:semicolon
id|set_vtimer
c_func
(paren
id|event-&gt;expires
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|vt_list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* release CPU aquired in prepare_vtimer or mod_virt_timer() */
id|put_cpu
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|prepare_vtimer
r_static
r_inline
r_int
id|prepare_vtimer
c_func
(paren
r_struct
id|vtimer_list
op_star
id|timer
)paren
(brace
r_if
c_cond
(paren
id|check_vtimer
c_func
(paren
id|timer
)paren
op_logical_or
op_logical_neg
id|timer-&gt;function
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;add_virt_timer: uninitialized timer&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|timer-&gt;expires
op_logical_or
id|timer-&gt;expires
OG
id|VTIMER_MAX_SLICE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;add_virt_timer: invalid timer expire value!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vtimer_pending
c_func
(paren
id|timer
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;add_virt_timer: timer pending&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|timer-&gt;cpu
op_assign
id|get_cpu
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * add_virt_timer - add an oneshot virtual CPU timer&n; */
DECL|function|add_virt_timer
r_void
id|add_virt_timer
c_func
(paren
r_void
op_star
r_new
)paren
(brace
r_struct
id|vtimer_list
op_star
id|timer
suffix:semicolon
id|timer
op_assign
(paren
r_struct
id|vtimer_list
op_star
)paren
r_new
suffix:semicolon
r_if
c_cond
(paren
id|prepare_vtimer
c_func
(paren
id|timer
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
id|timer-&gt;interval
op_assign
l_int|0
suffix:semicolon
id|internal_add_vtimer
c_func
(paren
id|timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * add_virt_timer_int - add an interval virtual CPU timer&n; */
DECL|function|add_virt_timer_periodic
r_void
id|add_virt_timer_periodic
c_func
(paren
r_void
op_star
r_new
)paren
(brace
r_struct
id|vtimer_list
op_star
id|timer
suffix:semicolon
id|timer
op_assign
(paren
r_struct
id|vtimer_list
op_star
)paren
r_new
suffix:semicolon
r_if
c_cond
(paren
id|prepare_vtimer
c_func
(paren
id|timer
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
id|timer-&gt;interval
op_assign
id|timer-&gt;expires
suffix:semicolon
id|internal_add_vtimer
c_func
(paren
id|timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * If we change a pending timer the function must be called on the CPU&n; * where the timer is running on, e.g. by smp_call_function_on()&n; *&n; * The original mod_timer adds the timer if it is not pending. For compatibility&n; * we do the same. The timer will be added on the current CPU as a oneshot timer.&n; *&n; * returns whether it has modified a pending timer (1) or not (0)&n; */
DECL|function|mod_virt_timer
r_int
id|mod_virt_timer
c_func
(paren
r_struct
id|vtimer_list
op_star
id|timer
comma
id|__u64
id|expires
)paren
(brace
r_struct
id|vtimer_queue
op_star
id|vt_list
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|cpu
suffix:semicolon
r_if
c_cond
(paren
id|check_vtimer
c_func
(paren
id|timer
)paren
op_logical_or
op_logical_neg
id|timer-&gt;function
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mod_virt_timer: uninitialized timer&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|expires
op_logical_or
id|expires
OG
id|VTIMER_MAX_SLICE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mod_virt_timer: invalid expire range&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This is a common optimization triggered by the&n;&t; * networking code - if the timer is re-modified&n;&t; * to be the same thing then just return:&n;&t; */
r_if
c_cond
(paren
id|timer-&gt;expires
op_eq
id|expires
op_logical_and
id|vtimer_pending
c_func
(paren
id|timer
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|cpu
op_assign
id|get_cpu
c_func
(paren
)paren
suffix:semicolon
id|vt_list
op_assign
op_amp
id|per_cpu
c_func
(paren
id|virt_cpu_timer
comma
id|cpu
)paren
suffix:semicolon
multiline_comment|/* disable interrupts before test if timer is pending */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|vt_list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* if timer isn&squot;t pending add it on the current CPU */
r_if
c_cond
(paren
op_logical_neg
id|vtimer_pending
c_func
(paren
id|timer
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|vt_list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* we do not activate an interval timer with mod_virt_timer */
id|timer-&gt;interval
op_assign
l_int|0
suffix:semicolon
id|timer-&gt;expires
op_assign
id|expires
suffix:semicolon
id|timer-&gt;cpu
op_assign
id|cpu
suffix:semicolon
id|internal_add_vtimer
c_func
(paren
id|timer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* check if we run on the right CPU */
r_if
c_cond
(paren
id|timer-&gt;cpu
op_ne
id|cpu
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mod_virt_timer: running on wrong CPU, check your code&bslash;n&quot;
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|vt_list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|put_cpu
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|list_del_init
c_func
(paren
op_amp
id|timer-&gt;entry
)paren
suffix:semicolon
id|timer-&gt;expires
op_assign
id|expires
suffix:semicolon
multiline_comment|/* also change the interval if we have an interval timer */
r_if
c_cond
(paren
id|timer-&gt;interval
)paren
id|timer-&gt;interval
op_assign
id|expires
suffix:semicolon
multiline_comment|/* the timer can&squot;t expire anymore so we can release the lock */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|vt_list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|internal_add_vtimer
c_func
(paren
id|timer
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * delete a virtual timer&n; *&n; * returns whether the deleted timer was pending (1) or not (0)&n; */
DECL|function|del_virt_timer
r_int
id|del_virt_timer
c_func
(paren
r_struct
id|vtimer_list
op_star
id|timer
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|vtimer_queue
op_star
id|vt_list
suffix:semicolon
r_if
c_cond
(paren
id|check_vtimer
c_func
(paren
id|timer
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;del_virt_timer: timer not initialized&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* check if timer is pending */
r_if
c_cond
(paren
op_logical_neg
id|vtimer_pending
c_func
(paren
id|timer
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_online
c_func
(paren
id|timer-&gt;cpu
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;del_virt_timer: CPU not present!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|vt_list
op_assign
op_amp
id|per_cpu
c_func
(paren
id|virt_cpu_timer
comma
id|timer-&gt;cpu
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|vt_list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* we don&squot;t interrupt a running timer, just let it expire! */
id|list_del_init
c_func
(paren
op_amp
id|timer-&gt;entry
)paren
suffix:semicolon
multiline_comment|/* last timer removed */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|vt_list-&gt;list
)paren
)paren
(brace
id|vt_list-&gt;to_expire
op_assign
l_int|0
suffix:semicolon
id|vt_list-&gt;offset
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|vt_list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
eof
