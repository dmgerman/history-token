multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * arch/sh64/kernel/traps.c&n; *&n; * Copyright (C) 2000, 2001  Paolo Alberelli&n; * Copyright (C) 2003, 2004  Paul Mundt&n; * Copyright (C) 2003, 2004  Richard Curnow&n; *&n; */
multiline_comment|/*&n; * &squot;Traps.c&squot; handles hardware traps and faults after we have saved some&n; * state in &squot;entry.S&squot;.&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/kallsyms.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
DECL|macro|DEBUG_EXCEPTION
macro_line|#undef DEBUG_EXCEPTION
macro_line|#ifdef DEBUG_EXCEPTION
multiline_comment|/* implemented in ../lib/dbg.c */
r_extern
r_void
id|show_excp_regs
c_func
(paren
r_char
op_star
id|fname
comma
r_int
id|trapnr
comma
r_int
id|signr
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
macro_line|#else
DECL|macro|show_excp_regs
mdefine_line|#define show_excp_regs(a, b, c, d)
macro_line|#endif
r_static
r_void
id|do_unhandled_exception
c_func
(paren
r_int
id|trapnr
comma
r_int
id|signr
comma
r_char
op_star
id|str
comma
r_char
op_star
id|fn_name
comma
r_int
r_int
id|error_code
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_struct
id|task_struct
op_star
id|tsk
)paren
suffix:semicolon
DECL|macro|DO_ERROR
mdefine_line|#define DO_ERROR(trapnr, signr, str, name, tsk) &bslash;&n;asmlinkage void do_##name(unsigned long error_code, struct pt_regs *regs) &bslash;&n;{ &bslash;&n;&t;do_unhandled_exception(trapnr, signr, str, __stringify(name), error_code, regs, current); &bslash;&n;}
DECL|variable|die_lock
id|spinlock_t
id|die_lock
suffix:semicolon
DECL|function|die
r_void
id|die
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
id|console_verbose
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|die_lock
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %lx&bslash;n&quot;
comma
id|str
comma
(paren
id|err
op_amp
l_int|0xffffff
)paren
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|die_lock
)paren
suffix:semicolon
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
)brace
DECL|function|die_if_kernel
r_static
r_inline
r_void
id|die_if_kernel
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|user_mode
c_func
(paren
id|regs
)paren
)paren
id|die
c_func
(paren
id|str
comma
id|regs
comma
id|err
)paren
suffix:semicolon
)brace
DECL|function|die_if_no_fixup
r_static
r_void
id|die_if_no_fixup
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
r_const
r_struct
id|exception_table_entry
op_star
id|fixup
suffix:semicolon
id|fixup
op_assign
id|search_exception_tables
c_func
(paren
id|regs-&gt;pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fixup
)paren
(brace
id|regs-&gt;pc
op_assign
id|fixup-&gt;fixup
suffix:semicolon
r_return
suffix:semicolon
)brace
id|die
c_func
(paren
id|str
comma
id|regs
comma
id|err
)paren
suffix:semicolon
)brace
)brace
id|DO_ERROR
c_func
(paren
l_int|13
comma
id|SIGILL
comma
l_string|&quot;illegal slot instruction&quot;
comma
id|illegal_slot_inst
comma
id|current
)paren
id|DO_ERROR
c_func
(paren
l_int|87
comma
id|SIGSEGV
comma
l_string|&quot;address error (exec)&quot;
comma
id|address_error_exec
comma
id|current
)paren
multiline_comment|/* Implement misaligned load/store handling for kernel (and optionally for user&n;   mode too).  Limitation : only SHmedia mode code is handled - there is no&n;   handling at all for misaligned accesses occurring in SHcompact code yet. */
r_static
r_int
id|misaligned_fixup
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|function|do_address_error_load
id|asmlinkage
r_void
id|do_address_error_load
c_func
(paren
r_int
r_int
id|error_code
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|misaligned_fixup
c_func
(paren
id|regs
)paren
OL
l_int|0
)paren
(brace
id|do_unhandled_exception
c_func
(paren
l_int|7
comma
id|SIGSEGV
comma
l_string|&quot;address error(load)&quot;
comma
l_string|&quot;do_address_error_load&quot;
comma
id|error_code
comma
id|regs
comma
id|current
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|do_address_error_store
id|asmlinkage
r_void
id|do_address_error_store
c_func
(paren
r_int
r_int
id|error_code
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|misaligned_fixup
c_func
(paren
id|regs
)paren
OL
l_int|0
)paren
(brace
id|do_unhandled_exception
c_func
(paren
l_int|8
comma
id|SIGSEGV
comma
l_string|&quot;address error(store)&quot;
comma
l_string|&quot;do_address_error_store&quot;
comma
id|error_code
comma
id|regs
comma
id|current
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_SH64_ID2815_WORKAROUND)
DECL|macro|OPCODE_INVALID
mdefine_line|#define OPCODE_INVALID      0
DECL|macro|OPCODE_USER_VALID
mdefine_line|#define OPCODE_USER_VALID   1
DECL|macro|OPCODE_PRIV_VALID
mdefine_line|#define OPCODE_PRIV_VALID   2
multiline_comment|/* getcon/putcon - requires checking which control register is referenced. */
DECL|macro|OPCODE_CTRL_REG
mdefine_line|#define OPCODE_CTRL_REG     3
multiline_comment|/* Table of valid opcodes for SHmedia mode.&n;   Form a 10-bit value by concatenating the major/minor opcodes i.e.&n;   opcode[31:26,20:16].  The 6 MSBs of this value index into the following&n;   array.  The 4 LSBs select the bit-pair in the entry (bits 1:0 correspond to&n;   LSBs==4&squot;b0000 etc). */
DECL|variable|shmedia_opcode_table
r_static
r_int
r_int
id|shmedia_opcode_table
(braket
l_int|64
)braket
op_assign
(brace
l_int|0x55554044
comma
l_int|0x54445055
comma
l_int|0x15141514
comma
l_int|0x14541414
comma
l_int|0x00000000
comma
l_int|0x10001000
comma
l_int|0x01110055
comma
l_int|0x04050015
comma
l_int|0x00000444
comma
l_int|0xc0000000
comma
l_int|0x44545515
comma
l_int|0x40405555
comma
l_int|0x55550015
comma
l_int|0x10005555
comma
l_int|0x55555505
comma
l_int|0x04050000
comma
l_int|0x00000555
comma
l_int|0x00000404
comma
l_int|0x00040445
comma
l_int|0x15151414
comma
l_int|0x00000000
comma
l_int|0x00000000
comma
l_int|0x00000000
comma
l_int|0x00000000
comma
l_int|0x00000055
comma
l_int|0x40404444
comma
l_int|0x00000404
comma
l_int|0xc0009495
comma
l_int|0x00000000
comma
l_int|0x00000000
comma
l_int|0x00000000
comma
l_int|0x00000000
comma
l_int|0x55555555
comma
l_int|0x55555555
comma
l_int|0x55555555
comma
l_int|0x55555555
comma
l_int|0x55555555
comma
l_int|0x55555555
comma
l_int|0x55555555
comma
l_int|0x55555555
comma
l_int|0x55555555
comma
l_int|0x55555555
comma
l_int|0x55555555
comma
l_int|0x55555555
comma
l_int|0x55555555
comma
l_int|0x55555555
comma
l_int|0x55555555
comma
l_int|0x55555555
comma
l_int|0x80005050
comma
l_int|0x04005055
comma
l_int|0x55555555
comma
l_int|0x55555555
comma
l_int|0x55555555
comma
l_int|0x55555555
comma
l_int|0x55555555
comma
l_int|0x55555555
comma
l_int|0x81055554
comma
l_int|0x00000404
comma
l_int|0x55555555
comma
l_int|0x55555555
comma
l_int|0x00000000
comma
l_int|0x00000000
comma
l_int|0x00000000
comma
l_int|0x00000000
)brace
suffix:semicolon
DECL|function|do_reserved_inst
r_void
id|do_reserved_inst
c_func
(paren
r_int
r_int
id|error_code
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* Workaround SH5-101 cut2 silicon defect #2815 :&n;&t;   in some situations, inter-mode branches from SHcompact -&gt; SHmedia&n;&t;   which should take ITLBMISS or EXECPROT exceptions at the target&n;&t;   falsely take RESINST at the target instead. */
r_int
r_int
id|opcode
op_assign
l_int|0x6ff4fff0
suffix:semicolon
multiline_comment|/* guaranteed reserved opcode */
r_int
r_int
id|pc
comma
id|aligned_pc
suffix:semicolon
r_int
id|get_user_error
suffix:semicolon
r_int
id|trapnr
op_assign
l_int|12
suffix:semicolon
r_int
id|signr
op_assign
id|SIGILL
suffix:semicolon
r_char
op_star
id|exception_name
op_assign
l_string|&quot;reserved_instruction&quot;
suffix:semicolon
id|pc
op_assign
id|regs-&gt;pc
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pc
op_amp
l_int|3
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* SHmedia : check for defect.  This requires executable vmas&n;&t;&t;   to be readable too. */
id|aligned_pc
op_assign
id|pc
op_amp
op_complement
l_int|3
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|aligned_pc
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
(brace
id|get_user_error
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_else
(brace
id|get_user_error
op_assign
id|__get_user
c_func
(paren
id|opcode
comma
(paren
r_int
r_int
op_star
)paren
id|aligned_pc
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_user_error
op_ge
l_int|0
)paren
(brace
r_int
r_int
id|index
comma
id|shift
suffix:semicolon
r_int
r_int
id|major
comma
id|minor
comma
id|combined
suffix:semicolon
r_int
r_int
id|reserved_field
suffix:semicolon
id|reserved_field
op_assign
id|opcode
op_amp
l_int|0xf
suffix:semicolon
multiline_comment|/* These bits are currently reserved as zero in all valid opcodes */
id|major
op_assign
(paren
id|opcode
op_rshift
l_int|26
)paren
op_amp
l_int|0x3f
suffix:semicolon
id|minor
op_assign
(paren
id|opcode
op_rshift
l_int|16
)paren
op_amp
l_int|0xf
suffix:semicolon
id|combined
op_assign
(paren
id|major
op_lshift
l_int|4
)paren
op_or
id|minor
suffix:semicolon
id|index
op_assign
id|major
suffix:semicolon
id|shift
op_assign
id|minor
op_lshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|reserved_field
op_eq
l_int|0
)paren
(brace
r_int
id|opcode_state
op_assign
(paren
id|shmedia_opcode_table
(braket
id|index
)braket
op_rshift
id|shift
)paren
op_amp
l_int|0x3
suffix:semicolon
r_switch
c_cond
(paren
id|opcode_state
)paren
(brace
r_case
id|OPCODE_INVALID
suffix:colon
multiline_comment|/* Trap. */
r_break
suffix:semicolon
r_case
id|OPCODE_USER_VALID
suffix:colon
multiline_comment|/* Restart the instruction : the branch to the instruction will now be from an RTE&n;&t;&t;&t;&t;&t;&t;   not from SHcompact so the silicon defect won&squot;t be triggered. */
r_return
suffix:semicolon
r_case
id|OPCODE_PRIV_VALID
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
multiline_comment|/* Should only ever get here if a module has&n;&t;&t;&t;&t;&t;&t;&t;   SHcompact code inside it.  If so, the same fix up is needed. */
r_return
suffix:semicolon
multiline_comment|/* same reason */
)brace
multiline_comment|/* Otherwise, user mode trying to execute a privileged instruction -&n;&t;&t;&t;&t;&t;&t;   fall through to trap. */
r_break
suffix:semicolon
r_case
id|OPCODE_CTRL_REG
suffix:colon
multiline_comment|/* If in privileged mode, return as above. */
r_if
c_cond
(paren
op_logical_neg
id|user_mode
c_func
(paren
id|regs
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* In user mode ... */
r_if
c_cond
(paren
id|combined
op_eq
l_int|0x9f
)paren
(brace
multiline_comment|/* GETCON */
r_int
r_int
id|regno
op_assign
(paren
id|opcode
op_rshift
l_int|20
)paren
op_amp
l_int|0x3f
suffix:semicolon
r_if
c_cond
(paren
id|regno
op_ge
l_int|62
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Otherwise, reserved or privileged control register, =&gt; trap */
)brace
r_else
r_if
c_cond
(paren
id|combined
op_eq
l_int|0x1bf
)paren
(brace
multiline_comment|/* PUTCON */
r_int
r_int
id|regno
op_assign
(paren
id|opcode
op_rshift
l_int|4
)paren
op_amp
l_int|0x3f
suffix:semicolon
r_if
c_cond
(paren
id|regno
op_ge
l_int|62
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Otherwise, reserved or privileged control register, =&gt; trap */
)brace
r_else
(brace
multiline_comment|/* Trap */
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Fall through to trap. */
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* fall through to normal resinst processing */
)brace
r_else
(brace
multiline_comment|/* Error trying to read opcode.  This typically means a&n;&t;&t;&t;   real fault, not a RESINST any more.  So change the&n;&t;&t;&t;   codes. */
id|trapnr
op_assign
l_int|87
suffix:semicolon
id|exception_name
op_assign
l_string|&quot;address error (exec)&quot;
suffix:semicolon
id|signr
op_assign
id|SIGSEGV
suffix:semicolon
)brace
)brace
id|do_unhandled_exception
c_func
(paren
id|trapnr
comma
id|signr
comma
id|exception_name
comma
l_string|&quot;do_reserved_inst&quot;
comma
id|error_code
comma
id|regs
comma
id|current
)paren
suffix:semicolon
)brace
macro_line|#else /* CONFIG_SH64_ID2815_WORKAROUND */
multiline_comment|/* If the workaround isn&squot;t needed, this is just a straightforward reserved&n;   instruction */
id|DO_ERROR
c_func
(paren
l_int|12
comma
id|SIGILL
comma
l_string|&quot;reserved instruction&quot;
comma
id|reserved_inst
comma
id|current
)paren
macro_line|#endif /* CONFIG_SH64_ID2815_WORKAROUND */
macro_line|#include &lt;asm/system.h&gt;
multiline_comment|/* Called with interrupts disabled */
DECL|function|do_exception_error
id|asmlinkage
r_void
id|do_exception_error
c_func
(paren
r_int
r_int
id|ex
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|PLS
c_func
(paren
)paren
suffix:semicolon
id|show_excp_regs
c_func
(paren
id|__FUNCTION__
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|regs
)paren
suffix:semicolon
id|die_if_kernel
c_func
(paren
l_string|&quot;exception&quot;
comma
id|regs
comma
id|ex
)paren
suffix:semicolon
)brace
DECL|function|do_unknown_trapa
r_int
id|do_unknown_trapa
c_func
(paren
r_int
r_int
id|scId
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* Syscall debug */
id|printk
c_func
(paren
l_string|&quot;System call ID error: [0x1#args:8 #syscall:16  0x%lx]&bslash;n&quot;
comma
id|scId
)paren
suffix:semicolon
id|die_if_kernel
c_func
(paren
l_string|&quot;unknown trapa&quot;
comma
id|regs
comma
id|scId
)paren
suffix:semicolon
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
DECL|function|show_stack
r_void
id|show_stack
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
r_int
op_star
id|sp
)paren
(brace
macro_line|#ifdef CONFIG_KALLSYMS
r_extern
r_void
id|sh64_unwind
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_struct
id|pt_regs
op_star
id|regs
suffix:semicolon
id|regs
op_assign
id|tsk
ques
c_cond
id|tsk-&gt;thread.kregs
suffix:colon
l_int|NULL
suffix:semicolon
id|sh64_unwind
c_func
(paren
id|regs
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Can&squot;t backtrace on sh64 without CONFIG_KALLSYMS&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|show_task
r_void
id|show_task
c_func
(paren
r_int
r_int
op_star
id|sp
)paren
(brace
id|show_stack
c_func
(paren
l_int|NULL
comma
id|sp
)paren
suffix:semicolon
)brace
DECL|function|dump_stack
r_void
id|dump_stack
c_func
(paren
r_void
)paren
(brace
id|show_task
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* Needed by any user of WARN_ON in view of the defn in include/asm-sh/bug.h */
DECL|variable|dump_stack
id|EXPORT_SYMBOL
c_func
(paren
id|dump_stack
)paren
suffix:semicolon
DECL|function|do_unhandled_exception
r_static
r_void
id|do_unhandled_exception
c_func
(paren
r_int
id|trapnr
comma
r_int
id|signr
comma
r_char
op_star
id|str
comma
r_char
op_star
id|fn_name
comma
r_int
r_int
id|error_code
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
id|show_excp_regs
c_func
(paren
id|fn_name
comma
id|trapnr
comma
id|signr
comma
id|regs
)paren
suffix:semicolon
id|tsk-&gt;thread.error_code
op_assign
id|error_code
suffix:semicolon
id|tsk-&gt;thread.trap_no
op_assign
id|trapnr
suffix:semicolon
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
id|force_sig
c_func
(paren
id|signr
comma
id|tsk
)paren
suffix:semicolon
id|die_if_no_fixup
c_func
(paren
id|str
comma
id|regs
comma
id|error_code
)paren
suffix:semicolon
)brace
DECL|function|read_opcode
r_static
r_int
id|read_opcode
c_func
(paren
r_int
r_int
r_int
id|pc
comma
r_int
r_int
op_star
id|result_opcode
comma
r_int
id|from_user_mode
)paren
(brace
r_int
id|get_user_error
suffix:semicolon
r_int
r_int
id|aligned_pc
suffix:semicolon
r_int
r_int
id|opcode
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pc
op_amp
l_int|3
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* SHmedia */
id|aligned_pc
op_assign
id|pc
op_amp
op_complement
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|from_user_mode
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|aligned_pc
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
(brace
id|get_user_error
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_else
(brace
id|get_user_error
op_assign
id|__get_user
c_func
(paren
id|opcode
comma
(paren
r_int
r_int
op_star
)paren
id|aligned_pc
)paren
suffix:semicolon
op_star
id|result_opcode
op_assign
id|opcode
suffix:semicolon
)brace
r_return
id|get_user_error
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If the fault was in the kernel, we can either read&n;&t;&t;&t; * this directly, or if not, we fault.&n;&t;&t;&t;*/
op_star
id|result_opcode
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|aligned_pc
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|pc
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* SHcompact */
multiline_comment|/* TODO : provide handling for this.  We don&squot;t really support&n;&t;&t;   user-mode SHcompact yet, and for a kernel fault, this would&n;&t;&t;   have to come from a module built for SHcompact.  */
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* misaligned */
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
DECL|function|address_is_sign_extended
r_static
r_int
id|address_is_sign_extended
c_func
(paren
id|__u64
id|a
)paren
(brace
id|__u64
id|b
suffix:semicolon
macro_line|#if (NEFF == 32)
id|b
op_assign
(paren
id|__u64
)paren
(paren
id|__s64
)paren
(paren
id|__s32
)paren
(paren
id|a
op_amp
l_int|0xffffffffUL
)paren
suffix:semicolon
r_return
(paren
id|b
op_eq
id|a
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
macro_line|#else
macro_line|#error &quot;Sign extend check only works for NEFF==32&quot;
macro_line|#endif
)brace
DECL|function|generate_and_check_address
r_static
r_int
id|generate_and_check_address
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
id|__u32
id|opcode
comma
r_int
id|displacement_not_indexed
comma
r_int
id|width_shift
comma
id|__u64
op_star
id|address
)paren
(brace
multiline_comment|/* return -1 for fault, 0 for OK */
id|__u64
id|base_address
comma
id|addr
suffix:semicolon
r_int
id|basereg
suffix:semicolon
id|basereg
op_assign
(paren
id|opcode
op_rshift
l_int|20
)paren
op_amp
l_int|0x3f
suffix:semicolon
id|base_address
op_assign
id|regs-&gt;regs
(braket
id|basereg
)braket
suffix:semicolon
r_if
c_cond
(paren
id|displacement_not_indexed
)paren
(brace
id|__s64
id|displacement
suffix:semicolon
id|displacement
op_assign
(paren
id|opcode
op_rshift
l_int|10
)paren
op_amp
l_int|0x3ff
suffix:semicolon
id|displacement
op_assign
(paren
(paren
id|displacement
op_lshift
l_int|54
)paren
op_rshift
l_int|54
)paren
suffix:semicolon
multiline_comment|/* sign extend */
id|addr
op_assign
(paren
id|__u64
)paren
(paren
(paren
id|__s64
)paren
id|base_address
op_plus
(paren
id|displacement
op_lshift
id|width_shift
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|__u64
id|offset
suffix:semicolon
r_int
id|offsetreg
suffix:semicolon
id|offsetreg
op_assign
(paren
id|opcode
op_rshift
l_int|10
)paren
op_amp
l_int|0x3f
suffix:semicolon
id|offset
op_assign
id|regs-&gt;regs
(braket
id|offsetreg
)braket
suffix:semicolon
id|addr
op_assign
id|base_address
op_plus
id|offset
suffix:semicolon
)brace
multiline_comment|/* Check sign extended */
r_if
c_cond
(paren
op_logical_neg
id|address_is_sign_extended
c_func
(paren
id|addr
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_SH64_USER_MISALIGNED_FIXUP)
multiline_comment|/* Check accessible.  For misaligned access in the kernel, assume the&n;&t;   address is always accessible (and if not, just fault when the&n;&t;   load/store gets done.) */
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
r_if
c_cond
(paren
id|addr
op_ge
id|TASK_SIZE
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Do access_ok check later - it depends on whether it&squot;s a load or a store. */
)brace
macro_line|#endif
op_star
id|address
op_assign
id|addr
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Default value as for sh */
macro_line|#if defined(CONFIG_SH64_USER_MISALIGNED_FIXUP)
DECL|variable|user_mode_unaligned_fixup_count
r_static
r_int
id|user_mode_unaligned_fixup_count
op_assign
l_int|10
suffix:semicolon
DECL|variable|user_mode_unaligned_fixup_enable
r_static
r_int
id|user_mode_unaligned_fixup_enable
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
DECL|variable|kernel_mode_unaligned_fixup_count
r_static
r_int
id|kernel_mode_unaligned_fixup_count
op_assign
l_int|32
suffix:semicolon
DECL|function|misaligned_kernel_word_load
r_static
r_void
id|misaligned_kernel_word_load
c_func
(paren
id|__u64
id|address
comma
r_int
id|do_sign_extend
comma
id|__u64
op_star
id|result
)paren
(brace
r_int
r_int
id|x
suffix:semicolon
r_int
r_char
op_star
id|p
comma
op_star
id|q
suffix:semicolon
id|p
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
r_int
)paren
id|address
suffix:semicolon
id|q
op_assign
(paren
r_int
r_char
op_star
)paren
op_amp
id|x
suffix:semicolon
id|q
(braket
l_int|0
)braket
op_assign
id|p
(braket
l_int|0
)braket
suffix:semicolon
id|q
(braket
l_int|1
)braket
op_assign
id|p
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|do_sign_extend
)paren
(brace
op_star
id|result
op_assign
(paren
id|__u64
)paren
(paren
id|__s64
)paren
op_star
(paren
r_int
op_star
)paren
op_amp
id|x
suffix:semicolon
)brace
r_else
(brace
op_star
id|result
op_assign
(paren
id|__u64
)paren
id|x
suffix:semicolon
)brace
)brace
DECL|function|misaligned_kernel_word_store
r_static
r_void
id|misaligned_kernel_word_store
c_func
(paren
id|__u64
id|address
comma
id|__u64
id|value
)paren
(brace
r_int
r_int
id|x
suffix:semicolon
r_int
r_char
op_star
id|p
comma
op_star
id|q
suffix:semicolon
id|p
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
r_int
)paren
id|address
suffix:semicolon
id|q
op_assign
(paren
r_int
r_char
op_star
)paren
op_amp
id|x
suffix:semicolon
id|x
op_assign
(paren
id|__u16
)paren
id|value
suffix:semicolon
id|p
(braket
l_int|0
)braket
op_assign
id|q
(braket
l_int|0
)braket
suffix:semicolon
id|p
(braket
l_int|1
)braket
op_assign
id|q
(braket
l_int|1
)braket
suffix:semicolon
)brace
DECL|function|misaligned_load
r_static
r_int
id|misaligned_load
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
id|__u32
id|opcode
comma
r_int
id|displacement_not_indexed
comma
r_int
id|width_shift
comma
r_int
id|do_sign_extend
)paren
(brace
multiline_comment|/* Return -1 for a fault, 0 for OK */
r_int
id|error
suffix:semicolon
r_int
id|destreg
suffix:semicolon
id|__u64
id|address
suffix:semicolon
id|error
op_assign
id|generate_and_check_address
c_func
(paren
id|regs
comma
id|opcode
comma
id|displacement_not_indexed
comma
id|width_shift
comma
op_amp
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|destreg
op_assign
(paren
id|opcode
op_rshift
l_int|4
)paren
op_amp
l_int|0x3f
suffix:semicolon
macro_line|#if defined(CONFIG_SH64_USER_MISALIGNED_FIXUP)
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
id|__u64
id|buffer
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
(paren
r_int
r_int
)paren
id|address
comma
l_int|1UL
op_lshift
id|width_shift
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|__copy_user
c_func
(paren
op_amp
id|buffer
comma
(paren
r_const
r_void
op_star
)paren
(paren
r_int
)paren
id|address
comma
(paren
l_int|1
op_lshift
id|width_shift
)paren
)paren
OG
l_int|0
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* fault */
)brace
r_switch
c_cond
(paren
id|width_shift
)paren
(brace
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|do_sign_extend
)paren
(brace
id|regs-&gt;regs
(braket
id|destreg
)braket
op_assign
(paren
id|__u64
)paren
(paren
id|__s64
)paren
op_star
(paren
id|__s16
op_star
)paren
op_amp
id|buffer
suffix:semicolon
)brace
r_else
(brace
id|regs-&gt;regs
(braket
id|destreg
)braket
op_assign
(paren
id|__u64
)paren
op_star
(paren
id|__u16
op_star
)paren
op_amp
id|buffer
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|regs-&gt;regs
(braket
id|destreg
)braket
op_assign
(paren
id|__u64
)paren
(paren
id|__s64
)paren
op_star
(paren
id|__s32
op_star
)paren
op_amp
id|buffer
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|regs-&gt;regs
(braket
id|destreg
)braket
op_assign
id|buffer
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Unexpected width_shift %d in misaligned_load, PC=%08lx&bslash;n&quot;
comma
id|width_shift
comma
(paren
r_int
r_int
)paren
id|regs-&gt;pc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
macro_line|#endif
(brace
multiline_comment|/* kernel mode - we can take short cuts since if we fault, it&squot;s a genuine bug */
id|__u64
id|lo
comma
id|hi
suffix:semicolon
r_switch
c_cond
(paren
id|width_shift
)paren
(brace
r_case
l_int|1
suffix:colon
id|misaligned_kernel_word_load
c_func
(paren
id|address
comma
id|do_sign_extend
comma
op_amp
id|regs-&gt;regs
(braket
id|destreg
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|asm
(paren
l_string|&quot;ldlo.l %1, 0, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|lo
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|address
)paren
)paren
suffix:semicolon
id|asm
(paren
l_string|&quot;ldhi.l %1, 3, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|hi
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|address
)paren
)paren
suffix:semicolon
id|regs-&gt;regs
(braket
id|destreg
)braket
op_assign
id|lo
op_or
id|hi
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|asm
(paren
l_string|&quot;ldlo.q %1, 0, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|lo
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|address
)paren
)paren
suffix:semicolon
id|asm
(paren
l_string|&quot;ldhi.q %1, 7, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|hi
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|address
)paren
)paren
suffix:semicolon
id|regs-&gt;regs
(braket
id|destreg
)braket
op_assign
id|lo
op_or
id|hi
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Unexpected width_shift %d in misaligned_load, PC=%08lx&bslash;n&quot;
comma
id|width_shift
comma
(paren
r_int
r_int
)paren
id|regs-&gt;pc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|misaligned_store
r_static
r_int
id|misaligned_store
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
id|__u32
id|opcode
comma
r_int
id|displacement_not_indexed
comma
r_int
id|width_shift
)paren
(brace
multiline_comment|/* Return -1 for a fault, 0 for OK */
r_int
id|error
suffix:semicolon
r_int
id|srcreg
suffix:semicolon
id|__u64
id|address
suffix:semicolon
id|error
op_assign
id|generate_and_check_address
c_func
(paren
id|regs
comma
id|opcode
comma
id|displacement_not_indexed
comma
id|width_shift
comma
op_amp
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|srcreg
op_assign
(paren
id|opcode
op_rshift
l_int|4
)paren
op_amp
l_int|0x3f
suffix:semicolon
macro_line|#if defined(CONFIG_SH64_USER_MISALIGNED_FIXUP)
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
id|__u64
id|buffer
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_int
r_int
)paren
id|address
comma
l_int|1UL
op_lshift
id|width_shift
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|width_shift
)paren
(brace
r_case
l_int|1
suffix:colon
op_star
(paren
id|__u16
op_star
)paren
op_amp
id|buffer
op_assign
(paren
id|__u16
)paren
id|regs-&gt;regs
(braket
id|srcreg
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
op_star
(paren
id|__u32
op_star
)paren
op_amp
id|buffer
op_assign
(paren
id|__u32
)paren
id|regs-&gt;regs
(braket
id|srcreg
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|buffer
op_assign
id|regs-&gt;regs
(braket
id|srcreg
)braket
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Unexpected width_shift %d in misaligned_store, PC=%08lx&bslash;n&quot;
comma
id|width_shift
comma
(paren
r_int
r_int
)paren
id|regs-&gt;pc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|__copy_user
c_func
(paren
(paren
r_void
op_star
)paren
(paren
r_int
)paren
id|address
comma
op_amp
id|buffer
comma
(paren
l_int|1
op_lshift
id|width_shift
)paren
)paren
OG
l_int|0
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* fault */
)brace
)brace
r_else
macro_line|#endif
(brace
multiline_comment|/* kernel mode - we can take short cuts since if we fault, it&squot;s a genuine bug */
id|__u64
id|val
op_assign
id|regs-&gt;regs
(braket
id|srcreg
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|width_shift
)paren
(brace
r_case
l_int|1
suffix:colon
id|misaligned_kernel_word_store
c_func
(paren
id|address
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|asm
(paren
l_string|&quot;stlo.l %1, 0, %0&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|val
)paren
comma
l_string|&quot;r&quot;
(paren
id|address
)paren
)paren
suffix:semicolon
id|asm
(paren
l_string|&quot;sthi.l %1, 3, %0&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|val
)paren
comma
l_string|&quot;r&quot;
(paren
id|address
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|asm
(paren
l_string|&quot;stlo.q %1, 0, %0&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|val
)paren
comma
l_string|&quot;r&quot;
(paren
id|address
)paren
)paren
suffix:semicolon
id|asm
(paren
l_string|&quot;sthi.q %1, 7, %0&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|val
)paren
comma
l_string|&quot;r&quot;
(paren
id|address
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Unexpected width_shift %d in misaligned_store, PC=%08lx&bslash;n&quot;
comma
id|width_shift
comma
(paren
r_int
r_int
)paren
id|regs-&gt;pc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_SH64_USER_MISALIGNED_FIXUP)
multiline_comment|/* Never need to fix up misaligned FPU accesses within the kernel since that&squot;s a real&n;   error. */
DECL|function|misaligned_fpu_load
r_static
r_int
id|misaligned_fpu_load
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
id|__u32
id|opcode
comma
r_int
id|displacement_not_indexed
comma
r_int
id|width_shift
comma
r_int
id|do_paired_load
)paren
(brace
multiline_comment|/* Return -1 for a fault, 0 for OK */
r_int
id|error
suffix:semicolon
r_int
id|destreg
suffix:semicolon
id|__u64
id|address
suffix:semicolon
id|error
op_assign
id|generate_and_check_address
c_func
(paren
id|regs
comma
id|opcode
comma
id|displacement_not_indexed
comma
id|width_shift
comma
op_amp
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|destreg
op_assign
(paren
id|opcode
op_rshift
l_int|4
)paren
op_amp
l_int|0x3f
suffix:semicolon
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
id|__u64
id|buffer
suffix:semicolon
id|__u32
id|buflo
comma
id|bufhi
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
(paren
r_int
r_int
)paren
id|address
comma
l_int|1UL
op_lshift
id|width_shift
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|__copy_user
c_func
(paren
op_amp
id|buffer
comma
(paren
r_const
r_void
op_star
)paren
(paren
r_int
)paren
id|address
comma
(paren
l_int|1
op_lshift
id|width_shift
)paren
)paren
OG
l_int|0
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* fault */
)brace
multiline_comment|/* &squot;current&squot; may be the current owner of the FPU state, so&n;&t;&t;   context switch the registers into memory so they can be&n;&t;&t;   indexed by register number. */
r_if
c_cond
(paren
id|last_task_used_math
op_eq
id|current
)paren
(brace
id|grab_fpu
c_func
(paren
)paren
suffix:semicolon
id|fpsave
c_func
(paren
op_amp
id|current-&gt;thread.fpu.hard
)paren
suffix:semicolon
id|release_fpu
c_func
(paren
)paren
suffix:semicolon
id|last_task_used_math
op_assign
l_int|NULL
suffix:semicolon
id|regs-&gt;sr
op_or_assign
id|SR_FD
suffix:semicolon
)brace
id|buflo
op_assign
op_star
(paren
id|__u32
op_star
)paren
op_amp
id|buffer
suffix:semicolon
id|bufhi
op_assign
op_star
(paren
l_int|1
op_plus
(paren
id|__u32
op_star
)paren
op_amp
id|buffer
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|width_shift
)paren
(brace
r_case
l_int|2
suffix:colon
id|current-&gt;thread.fpu.hard.fp_regs
(braket
id|destreg
)braket
op_assign
id|buflo
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
id|do_paired_load
)paren
(brace
id|current-&gt;thread.fpu.hard.fp_regs
(braket
id|destreg
)braket
op_assign
id|buflo
suffix:semicolon
id|current-&gt;thread.fpu.hard.fp_regs
(braket
id|destreg
op_plus
l_int|1
)braket
op_assign
id|bufhi
suffix:semicolon
)brace
r_else
(brace
macro_line|#if defined(CONFIG_LITTLE_ENDIAN)
id|current-&gt;thread.fpu.hard.fp_regs
(braket
id|destreg
)braket
op_assign
id|bufhi
suffix:semicolon
id|current-&gt;thread.fpu.hard.fp_regs
(braket
id|destreg
op_plus
l_int|1
)braket
op_assign
id|buflo
suffix:semicolon
macro_line|#else
id|current-&gt;thread.fpu.hard.fp_regs
(braket
id|destreg
)braket
op_assign
id|buflo
suffix:semicolon
id|current-&gt;thread.fpu.hard.fp_regs
(braket
id|destreg
op_plus
l_int|1
)braket
op_assign
id|bufhi
suffix:semicolon
macro_line|#endif
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Unexpected width_shift %d in misaligned_fpu_load, PC=%08lx&bslash;n&quot;
comma
id|width_shift
comma
(paren
r_int
r_int
)paren
id|regs-&gt;pc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|die
(paren
l_string|&quot;Misaligned FPU load inside kernel&quot;
comma
id|regs
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|misaligned_fpu_store
r_static
r_int
id|misaligned_fpu_store
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
id|__u32
id|opcode
comma
r_int
id|displacement_not_indexed
comma
r_int
id|width_shift
comma
r_int
id|do_paired_load
)paren
(brace
multiline_comment|/* Return -1 for a fault, 0 for OK */
r_int
id|error
suffix:semicolon
r_int
id|srcreg
suffix:semicolon
id|__u64
id|address
suffix:semicolon
id|error
op_assign
id|generate_and_check_address
c_func
(paren
id|regs
comma
id|opcode
comma
id|displacement_not_indexed
comma
id|width_shift
comma
op_amp
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|srcreg
op_assign
(paren
id|opcode
op_rshift
l_int|4
)paren
op_amp
l_int|0x3f
suffix:semicolon
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
id|__u64
id|buffer
suffix:semicolon
multiline_comment|/* Initialise these to NaNs. */
id|__u32
id|buflo
op_assign
l_int|0xffffffffUL
comma
id|bufhi
op_assign
l_int|0xffffffffUL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_int
r_int
)paren
id|address
comma
l_int|1UL
op_lshift
id|width_shift
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &squot;current&squot; may be the current owner of the FPU state, so&n;&t;&t;   context switch the registers into memory so they can be&n;&t;&t;   indexed by register number. */
r_if
c_cond
(paren
id|last_task_used_math
op_eq
id|current
)paren
(brace
id|grab_fpu
c_func
(paren
)paren
suffix:semicolon
id|fpsave
c_func
(paren
op_amp
id|current-&gt;thread.fpu.hard
)paren
suffix:semicolon
id|release_fpu
c_func
(paren
)paren
suffix:semicolon
id|last_task_used_math
op_assign
l_int|NULL
suffix:semicolon
id|regs-&gt;sr
op_or_assign
id|SR_FD
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|width_shift
)paren
(brace
r_case
l_int|2
suffix:colon
id|buflo
op_assign
id|current-&gt;thread.fpu.hard.fp_regs
(braket
id|srcreg
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
id|do_paired_load
)paren
(brace
id|buflo
op_assign
id|current-&gt;thread.fpu.hard.fp_regs
(braket
id|srcreg
)braket
suffix:semicolon
id|bufhi
op_assign
id|current-&gt;thread.fpu.hard.fp_regs
(braket
id|srcreg
op_plus
l_int|1
)braket
suffix:semicolon
)brace
r_else
(brace
macro_line|#if defined(CONFIG_LITTLE_ENDIAN)
id|bufhi
op_assign
id|current-&gt;thread.fpu.hard.fp_regs
(braket
id|srcreg
)braket
suffix:semicolon
id|buflo
op_assign
id|current-&gt;thread.fpu.hard.fp_regs
(braket
id|srcreg
op_plus
l_int|1
)braket
suffix:semicolon
macro_line|#else
id|buflo
op_assign
id|current-&gt;thread.fpu.hard.fp_regs
(braket
id|srcreg
)braket
suffix:semicolon
id|bufhi
op_assign
id|current-&gt;thread.fpu.hard.fp_regs
(braket
id|srcreg
op_plus
l_int|1
)braket
suffix:semicolon
macro_line|#endif
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Unexpected width_shift %d in misaligned_fpu_store, PC=%08lx&bslash;n&quot;
comma
id|width_shift
comma
(paren
r_int
r_int
)paren
id|regs-&gt;pc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
op_star
(paren
id|__u32
op_star
)paren
op_amp
id|buffer
op_assign
id|buflo
suffix:semicolon
op_star
(paren
l_int|1
op_plus
(paren
id|__u32
op_star
)paren
op_amp
id|buffer
)paren
op_assign
id|bufhi
suffix:semicolon
r_if
c_cond
(paren
id|__copy_user
c_func
(paren
(paren
r_void
op_star
)paren
(paren
r_int
)paren
id|address
comma
op_amp
id|buffer
comma
(paren
l_int|1
op_lshift
id|width_shift
)paren
)paren
OG
l_int|0
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* fault */
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|die
(paren
l_string|&quot;Misaligned FPU load inside kernel&quot;
comma
id|regs
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#endif
DECL|function|misaligned_fixup
r_static
r_int
id|misaligned_fixup
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|opcode
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|major
comma
id|minor
suffix:semicolon
macro_line|#if !defined(CONFIG_SH64_USER_MISALIGNED_FIXUP)
multiline_comment|/* Never fixup user mode misaligned accesses without this option enabled. */
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
id|user_mode_unaligned_fixup_enable
)paren
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
id|error
op_assign
id|read_opcode
c_func
(paren
id|regs-&gt;pc
comma
op_amp
id|opcode
comma
id|user_mode
c_func
(paren
id|regs
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|major
op_assign
(paren
id|opcode
op_rshift
l_int|26
)paren
op_amp
l_int|0x3f
suffix:semicolon
id|minor
op_assign
(paren
id|opcode
op_rshift
l_int|16
)paren
op_amp
l_int|0xf
suffix:semicolon
macro_line|#if defined(CONFIG_SH64_USER_MISALIGNED_FIXUP)
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
op_logical_and
(paren
id|user_mode_unaligned_fixup_count
OG
l_int|0
)paren
)paren
(brace
op_decrement
id|user_mode_unaligned_fixup_count
suffix:semicolon
multiline_comment|/* Only do &squot;count&squot; worth of these reports, to remove a potential DoS against syslog */
id|printk
c_func
(paren
l_string|&quot;Fixing up unaligned userspace access in &bslash;&quot;%s&bslash;&quot; pid=%d pc=0x%08x ins=0x%08lx&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
(paren
id|__u32
)paren
id|regs-&gt;pc
comma
id|opcode
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|user_mode
c_func
(paren
id|regs
)paren
op_logical_and
(paren
id|kernel_mode_unaligned_fixup_count
OG
l_int|0
)paren
)paren
(brace
op_decrement
id|kernel_mode_unaligned_fixup_count
suffix:semicolon
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Fixing up unaligned kernelspace access in interrupt pc=0x%08x ins=0x%08lx&bslash;n&quot;
comma
(paren
id|__u32
)paren
id|regs-&gt;pc
comma
id|opcode
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Fixing up unaligned kernelspace access in &bslash;&quot;%s&bslash;&quot; pid=%d pc=0x%08x ins=0x%08lx&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
(paren
id|__u32
)paren
id|regs-&gt;pc
comma
id|opcode
)paren
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|major
)paren
(brace
r_case
(paren
l_int|0x84
op_rshift
l_int|2
)paren
suffix:colon
multiline_comment|/* LD.W */
id|error
op_assign
id|misaligned_load
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|1
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
(paren
l_int|0xb0
op_rshift
l_int|2
)paren
suffix:colon
multiline_comment|/* LD.UW */
id|error
op_assign
id|misaligned_load
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|1
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
(paren
l_int|0x88
op_rshift
l_int|2
)paren
suffix:colon
multiline_comment|/* LD.L */
id|error
op_assign
id|misaligned_load
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|1
comma
l_int|2
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
(paren
l_int|0x8c
op_rshift
l_int|2
)paren
suffix:colon
multiline_comment|/* LD.Q */
id|error
op_assign
id|misaligned_load
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|1
comma
l_int|3
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
(paren
l_int|0xa4
op_rshift
l_int|2
)paren
suffix:colon
multiline_comment|/* ST.W */
id|error
op_assign
id|misaligned_store
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
(paren
l_int|0xa8
op_rshift
l_int|2
)paren
suffix:colon
multiline_comment|/* ST.L */
id|error
op_assign
id|misaligned_store
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|1
comma
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
(paren
l_int|0xac
op_rshift
l_int|2
)paren
suffix:colon
multiline_comment|/* ST.Q */
id|error
op_assign
id|misaligned_store
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|1
comma
l_int|3
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
(paren
l_int|0x40
op_rshift
l_int|2
)paren
suffix:colon
multiline_comment|/* indexed loads */
r_switch
c_cond
(paren
id|minor
)paren
(brace
r_case
l_int|0x1
suffix:colon
multiline_comment|/* LDX.W */
id|error
op_assign
id|misaligned_load
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|0
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x5
suffix:colon
multiline_comment|/* LDX.UW */
id|error
op_assign
id|misaligned_load
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|0
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x2
suffix:colon
multiline_comment|/* LDX.L */
id|error
op_assign
id|misaligned_load
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|0
comma
l_int|2
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x3
suffix:colon
multiline_comment|/* LDX.Q */
id|error
op_assign
id|misaligned_load
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|0
comma
l_int|3
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
(paren
l_int|0x60
op_rshift
l_int|2
)paren
suffix:colon
multiline_comment|/* indexed stores */
r_switch
c_cond
(paren
id|minor
)paren
(brace
r_case
l_int|0x1
suffix:colon
multiline_comment|/* STX.W */
id|error
op_assign
id|misaligned_store
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x2
suffix:colon
multiline_comment|/* STX.L */
id|error
op_assign
id|misaligned_store
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|0
comma
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x3
suffix:colon
multiline_comment|/* STX.Q */
id|error
op_assign
id|misaligned_store
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|0
comma
l_int|3
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#if defined(CONFIG_SH64_USER_MISALIGNED_FIXUP)
r_case
(paren
l_int|0x94
op_rshift
l_int|2
)paren
suffix:colon
multiline_comment|/* FLD.S */
id|error
op_assign
id|misaligned_fpu_load
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|1
comma
l_int|2
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
(paren
l_int|0x98
op_rshift
l_int|2
)paren
suffix:colon
multiline_comment|/* FLD.P */
id|error
op_assign
id|misaligned_fpu_load
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|1
comma
l_int|3
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
(paren
l_int|0x9c
op_rshift
l_int|2
)paren
suffix:colon
multiline_comment|/* FLD.D */
id|error
op_assign
id|misaligned_fpu_load
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|1
comma
l_int|3
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
(paren
l_int|0x1c
op_rshift
l_int|2
)paren
suffix:colon
multiline_comment|/* floating indexed loads */
r_switch
c_cond
(paren
id|minor
)paren
(brace
r_case
l_int|0x8
suffix:colon
multiline_comment|/* FLDX.S */
id|error
op_assign
id|misaligned_fpu_load
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|0
comma
l_int|2
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xd
suffix:colon
multiline_comment|/* FLDX.P */
id|error
op_assign
id|misaligned_fpu_load
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|0
comma
l_int|3
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x9
suffix:colon
multiline_comment|/* FLDX.D */
id|error
op_assign
id|misaligned_fpu_load
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|0
comma
l_int|3
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
(paren
l_int|0xb4
op_rshift
l_int|2
)paren
suffix:colon
multiline_comment|/* FLD.S */
id|error
op_assign
id|misaligned_fpu_store
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|1
comma
l_int|2
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
(paren
l_int|0xb8
op_rshift
l_int|2
)paren
suffix:colon
multiline_comment|/* FLD.P */
id|error
op_assign
id|misaligned_fpu_store
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|1
comma
l_int|3
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
(paren
l_int|0xbc
op_rshift
l_int|2
)paren
suffix:colon
multiline_comment|/* FLD.D */
id|error
op_assign
id|misaligned_fpu_store
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|1
comma
l_int|3
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
(paren
l_int|0x3c
op_rshift
l_int|2
)paren
suffix:colon
multiline_comment|/* floating indexed stores */
r_switch
c_cond
(paren
id|minor
)paren
(brace
r_case
l_int|0x8
suffix:colon
multiline_comment|/* FSTX.S */
id|error
op_assign
id|misaligned_fpu_store
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|0
comma
l_int|2
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xd
suffix:colon
multiline_comment|/* FSTX.P */
id|error
op_assign
id|misaligned_fpu_store
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|0
comma
l_int|3
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x9
suffix:colon
multiline_comment|/* FSTX.D */
id|error
op_assign
id|misaligned_fpu_store
c_func
(paren
id|regs
comma
id|opcode
comma
l_int|0
comma
l_int|3
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
multiline_comment|/* Fault */
id|error
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
r_else
(brace
id|regs-&gt;pc
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/* Skip the instruction that&squot;s just been emulated */
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|variable|unaligned_table
r_static
id|ctl_table
id|unaligned_table
(braket
)braket
op_assign
(brace
(brace
l_int|1
comma
l_string|&quot;kernel_reports&quot;
comma
op_amp
id|kernel_mode_unaligned_fixup_count
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_dointvec
)brace
comma
macro_line|#if defined(CONFIG_SH64_USER_MISALIGNED_FIXUP)
(brace
l_int|2
comma
l_string|&quot;user_reports&quot;
comma
op_amp
id|user_mode_unaligned_fixup_count
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_dointvec
)brace
comma
(brace
l_int|3
comma
l_string|&quot;user_enable&quot;
comma
op_amp
id|user_mode_unaligned_fixup_enable
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_dointvec
)brace
comma
macro_line|#endif
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|unaligned_root
r_static
id|ctl_table
id|unaligned_root
(braket
)braket
op_assign
(brace
(brace
l_int|1
comma
l_string|&quot;unaligned_fixup&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0555
comma
id|unaligned_table
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|sh64_root
r_static
id|ctl_table
id|sh64_root
(braket
)braket
op_assign
(brace
(brace
l_int|1
comma
l_string|&quot;sh64&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0555
comma
id|unaligned_root
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|sysctl_header
r_static
r_struct
id|ctl_table_header
op_star
id|sysctl_header
suffix:semicolon
DECL|function|init_sysctl
r_static
r_int
id|__init
id|init_sysctl
c_func
(paren
r_void
)paren
(brace
id|sysctl_header
op_assign
id|register_sysctl_table
c_func
(paren
id|sh64_root
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|init_sysctl
id|__initcall
c_func
(paren
id|init_sysctl
)paren
suffix:semicolon
DECL|function|do_debug_interrupt
id|asmlinkage
r_void
id|do_debug_interrupt
c_func
(paren
r_int
r_int
id|code
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|u64
id|peek_real_address_q
c_func
(paren
id|u64
id|addr
)paren
suffix:semicolon
id|u64
id|poke_real_address_q
c_func
(paren
id|u64
id|addr
comma
id|u64
id|val
)paren
suffix:semicolon
r_int
r_int
r_int
id|DM_EXP_CAUSE_PHY
op_assign
l_int|0x0c100010
suffix:semicolon
r_int
r_int
r_int
id|exp_cause
suffix:semicolon
multiline_comment|/* It&squot;s not worth ioremapping the debug module registers for the amount&n;&t;   of access we make to them - just go direct to their physical&n;&t;   addresses. */
id|exp_cause
op_assign
id|peek_real_address_q
c_func
(paren
id|DM_EXP_CAUSE_PHY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exp_cause
op_amp
op_complement
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DM.EXP_CAUSE had unexpected bits set (=%08lx)&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
(paren
id|exp_cause
op_amp
l_int|0xffffffff
)paren
)paren
suffix:semicolon
)brace
id|show_state
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Clear all DEBUGINT causes */
id|poke_real_address_q
c_func
(paren
id|DM_EXP_CAUSE_PHY
comma
l_int|0x0
)paren
suffix:semicolon
)brace
eof
