multiline_comment|/*&n; * arch/sh64/kernel/unwind.c&n; *&n; * Copyright (C) 2004  Paul Mundt&n; * Copyright (C) 2004  Richard Curnow&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; */
macro_line|#include &lt;linux/kallsyms.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/io.h&gt;
DECL|variable|regcache
r_static
id|u8
id|regcache
(braket
l_int|63
)braket
suffix:semicolon
multiline_comment|/*&n; * Finding the previous stack frame isn&squot;t horribly straightforward as it is&n; * on some other platforms. In the sh64 case, we don&squot;t have &quot;linked&quot; stack&n; * frames, so we need to do a bit of work to determine the previous frame,&n; * and in turn, the previous r14/r18 pair.&n; *&n; * There are generally a few cases which determine where we can find out&n; * the r14/r18 values. In the general case, this can be determined by poking&n; * around the prologue of the symbol PC is in (note that we absolutely must&n; * have frame pointer support as well as the kernel symbol table mapped,&n; * otherwise we can&squot;t even get this far).&n; *&n; * In other cases, such as the interrupt/exception path, we can poke around&n; * the sp/fp.&n; *&n; * Notably, this entire approach is somewhat error prone, and in the event&n; * that the previous frame cannot be determined, that&squot;s all we can do.&n; * Either way, this still leaves us with a more correct backtrace then what&n; * we would be able to come up with by walking the stack (which is garbage&n; * for anything beyond the first frame).&n; *&t;&t;&t;&t;&t;&t;-- PFM.&n; */
DECL|function|lookup_prev_stack_frame
r_static
r_int
id|lookup_prev_stack_frame
c_func
(paren
r_int
r_int
id|fp
comma
r_int
r_int
id|pc
comma
r_int
r_int
op_star
id|pprev_fp
comma
r_int
r_int
op_star
id|pprev_pc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_const
r_char
op_star
id|sym
suffix:semicolon
r_char
op_star
id|modname
comma
id|namebuf
(braket
l_int|128
)braket
suffix:semicolon
r_int
r_int
id|offset
comma
id|size
suffix:semicolon
r_int
r_int
id|prologue
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|fp_displacement
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|fp_prev
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|offset_r14
op_assign
l_int|0
comma
id|offset_r18
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|found_prologue_end
op_assign
l_int|0
suffix:semicolon
id|sym
op_assign
id|kallsyms_lookup
c_func
(paren
id|pc
comma
op_amp
id|size
comma
op_amp
id|offset
comma
op_amp
id|modname
comma
id|namebuf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sym
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|prologue
op_assign
id|pc
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prologue
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Validate fp, to avoid risk of dereferencing a bad pointer later.&n;&t;   Assume 128Mb since that&squot;s the amount of RAM on a Cayman.  Modify&n;&t;   when there is an SH-5 board with more. */
r_if
c_cond
(paren
(paren
id|fp
OL
(paren
r_int
r_int
)paren
id|phys_to_virt
c_func
(paren
id|__MEMORY_START
)paren
)paren
op_logical_or
(paren
id|fp
op_ge
(paren
r_int
r_int
)paren
(paren
id|phys_to_virt
c_func
(paren
id|__MEMORY_START
)paren
)paren
op_plus
l_int|128
op_star
l_int|1024
op_star
l_int|1024
)paren
op_logical_or
(paren
(paren
id|fp
op_amp
l_int|7
)paren
op_ne
l_int|0
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Depth to walk, depth is completely arbitrary.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
comma
id|prologue
op_add_assign
r_sizeof
(paren
r_int
r_int
)paren
)paren
(brace
r_int
r_int
id|op
suffix:semicolon
id|u8
id|major
comma
id|minor
suffix:semicolon
id|u8
id|src
comma
id|dest
comma
id|disp
suffix:semicolon
id|op
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|prologue
suffix:semicolon
id|major
op_assign
(paren
id|op
op_rshift
l_int|26
)paren
op_amp
l_int|0x3f
suffix:semicolon
id|src
op_assign
(paren
id|op
op_rshift
l_int|20
)paren
op_amp
l_int|0x3f
suffix:semicolon
id|minor
op_assign
(paren
id|op
op_rshift
l_int|16
)paren
op_amp
l_int|0xf
suffix:semicolon
id|disp
op_assign
(paren
id|op
op_rshift
l_int|10
)paren
op_amp
l_int|0x3f
suffix:semicolon
id|dest
op_assign
(paren
id|op
op_rshift
l_int|4
)paren
op_amp
l_int|0x3f
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Stack frame creation happens in a number of ways.. in the&n;&t;&t; * general case when the stack frame is less than 511 bytes,&n;&t;&t; * it&squot;s generally created by an addi or addi.l:&n;&t;&t; *&n;&t;&t; *&t;addi/addi.l r15, -FRAME_SIZE, r15&n;&t;&t; *&n;&t;&t; * in the event that the frame size is bigger than this, it&squot;s&n;&t;&t; * typically created using a movi/sub pair as follows:&n;&t;&t; *&n;&t;&t; *&t;movi&t;FRAME_SIZE, rX&n;&t;&t; *&t;sub&t;r15, rX, r15&n;&t;&t; */
r_switch
c_cond
(paren
id|major
)paren
(brace
r_case
(paren
l_int|0x00
op_rshift
l_int|2
)paren
suffix:colon
r_switch
c_cond
(paren
id|minor
)paren
(brace
r_case
l_int|0x8
suffix:colon
multiline_comment|/* add.l */
r_case
l_int|0x9
suffix:colon
multiline_comment|/* add */
multiline_comment|/* Look for r15, r63, r14 */
r_if
c_cond
(paren
id|src
op_eq
l_int|15
op_logical_and
id|disp
op_eq
l_int|63
op_logical_and
id|dest
op_eq
l_int|14
)paren
id|found_prologue_end
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xa
suffix:colon
multiline_comment|/* sub.l */
r_case
l_int|0xb
suffix:colon
multiline_comment|/* sub */
r_if
c_cond
(paren
id|src
op_ne
l_int|15
op_logical_or
id|dest
op_ne
l_int|15
)paren
r_continue
suffix:semicolon
id|fp_displacement
op_sub_assign
id|regcache
(braket
id|disp
)braket
suffix:semicolon
id|fp_prev
op_assign
id|fp
op_minus
id|fp_displacement
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
(paren
l_int|0xa8
op_rshift
l_int|2
)paren
suffix:colon
multiline_comment|/* st.l */
r_if
c_cond
(paren
id|src
op_ne
l_int|15
)paren
r_continue
suffix:semicolon
r_switch
c_cond
(paren
id|dest
)paren
(brace
r_case
l_int|14
suffix:colon
r_if
c_cond
(paren
id|offset_r14
op_logical_or
id|fp_displacement
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|offset_r14
op_assign
(paren
id|u64
)paren
(paren
(paren
(paren
(paren
(paren
id|s64
)paren
id|op
op_rshift
l_int|10
)paren
op_amp
l_int|0x3ff
)paren
op_lshift
l_int|54
)paren
op_rshift
l_int|54
)paren
suffix:semicolon
id|offset_r14
op_mul_assign
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|offset_r14
op_add_assign
id|fp_displacement
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|18
suffix:colon
r_if
c_cond
(paren
id|offset_r18
op_logical_or
id|fp_displacement
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|offset_r18
op_assign
(paren
id|u64
)paren
(paren
(paren
(paren
(paren
(paren
id|s64
)paren
id|op
op_rshift
l_int|10
)paren
op_amp
l_int|0x3ff
)paren
op_lshift
l_int|54
)paren
op_rshift
l_int|54
)paren
suffix:semicolon
id|offset_r18
op_mul_assign
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|offset_r18
op_add_assign
id|fp_displacement
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
(paren
l_int|0xcc
op_rshift
l_int|2
)paren
suffix:colon
multiline_comment|/* movi */
r_if
c_cond
(paren
id|dest
op_ge
l_int|63
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: Invalid dest reg %d &quot;
l_string|&quot;specified in movi handler. Failed &quot;
l_string|&quot;opcode was 0x%lx: &quot;
comma
id|__FUNCTION__
comma
id|dest
comma
id|op
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Sign extend */
id|regcache
(braket
id|dest
)braket
op_assign
(paren
(paren
(paren
(paren
id|s64
)paren
(paren
id|u64
)paren
id|op
op_rshift
l_int|10
)paren
op_amp
l_int|0xffff
)paren
op_lshift
l_int|54
)paren
op_rshift
l_int|54
suffix:semicolon
r_break
suffix:semicolon
r_case
(paren
l_int|0xd0
op_rshift
l_int|2
)paren
suffix:colon
multiline_comment|/* addi */
r_case
(paren
l_int|0xd4
op_rshift
l_int|2
)paren
suffix:colon
multiline_comment|/* addi.l */
multiline_comment|/* Look for r15, -FRAME_SIZE, r15 */
r_if
c_cond
(paren
id|src
op_ne
l_int|15
op_logical_or
id|dest
op_ne
l_int|15
)paren
r_continue
suffix:semicolon
multiline_comment|/* Sign extended frame size.. */
id|fp_displacement
op_add_assign
(paren
id|u64
)paren
(paren
(paren
(paren
(paren
(paren
id|s64
)paren
id|op
op_rshift
l_int|10
)paren
op_amp
l_int|0x3ff
)paren
op_lshift
l_int|54
)paren
op_rshift
l_int|54
)paren
suffix:semicolon
id|fp_prev
op_assign
id|fp
op_minus
id|fp_displacement
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|found_prologue_end
op_logical_and
id|offset_r14
op_logical_and
(paren
id|offset_r18
op_logical_or
op_star
id|pprev_pc
)paren
op_logical_and
id|fp_prev
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offset_r14
op_eq
l_int|0
op_logical_or
id|fp_prev
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|offset_r14
)paren
id|pr_debug
c_func
(paren
l_string|&quot;Unable to find r14 offset&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fp_prev
)paren
id|pr_debug
c_func
(paren
l_string|&quot;Unable to find previous fp&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* For innermost leaf function, there might not be a offset_r18 */
r_if
c_cond
(paren
op_logical_neg
op_star
id|pprev_pc
op_logical_and
(paren
id|offset_r18
op_eq
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
op_star
id|pprev_fp
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
(paren
id|fp_prev
op_plus
id|offset_r14
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset_r18
)paren
op_star
id|pprev_pc
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
(paren
id|fp_prev
op_plus
id|offset_r18
)paren
suffix:semicolon
op_star
id|pprev_pc
op_and_assign
op_complement
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t put this on the stack since we&squot;ll want to call sh64_unwind&n; * when we&squot;re close to underflowing the stack anyway. */
DECL|variable|here_regs
r_static
r_struct
id|pt_regs
id|here_regs
suffix:semicolon
r_extern
r_const
r_char
id|syscall_ret
suffix:semicolon
r_extern
r_const
r_char
id|ret_from_syscall
suffix:semicolon
r_extern
r_const
r_char
id|ret_from_exception
suffix:semicolon
r_extern
r_const
r_char
id|ret_from_irq
suffix:semicolon
r_static
r_void
id|sh64_unwind_inner
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|function|unwind_nested
r_static
r_void
id|unwind_nested
(paren
r_int
r_int
id|pc
comma
r_int
r_int
id|fp
)paren
(brace
r_if
c_cond
(paren
(paren
id|fp
op_ge
id|__MEMORY_START
)paren
op_logical_and
(paren
(paren
id|fp
op_amp
l_int|7
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|sh64_unwind_inner
c_func
(paren
(paren
r_struct
id|pt_regs
op_star
)paren
id|fp
)paren
suffix:semicolon
)brace
)brace
DECL|function|sh64_unwind_inner
r_static
r_void
id|sh64_unwind_inner
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|pc
comma
id|fp
suffix:semicolon
r_int
id|ofs
op_assign
l_int|0
suffix:semicolon
r_int
id|first_pass
suffix:semicolon
id|pc
op_assign
id|regs-&gt;pc
op_amp
op_complement
l_int|1
suffix:semicolon
id|fp
op_assign
id|regs-&gt;regs
(braket
l_int|14
)braket
suffix:semicolon
id|first_pass
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|cond
suffix:semicolon
r_int
r_int
id|next_fp
comma
id|next_pc
suffix:semicolon
r_if
c_cond
(paren
id|pc
op_eq
(paren
(paren
r_int
r_int
)paren
op_amp
id|syscall_ret
op_amp
op_complement
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SYSCALL&bslash;n&quot;
)paren
suffix:semicolon
id|unwind_nested
c_func
(paren
id|pc
comma
id|fp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pc
op_eq
(paren
(paren
r_int
r_int
)paren
op_amp
id|ret_from_syscall
op_amp
op_complement
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SYSCALL (PREEMPTED)&bslash;n&quot;
)paren
suffix:semicolon
id|unwind_nested
c_func
(paren
id|pc
comma
id|fp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* In this case, the PC is discovered by lookup_prev_stack_frame but&n;&t;&t;   it has 4 taken off it to look like the &squot;caller&squot; */
r_if
c_cond
(paren
id|pc
op_eq
(paren
(paren
r_int
r_int
)paren
op_amp
id|ret_from_exception
op_amp
op_complement
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;EXCEPTION&bslash;n&quot;
)paren
suffix:semicolon
id|unwind_nested
c_func
(paren
id|pc
comma
id|fp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pc
op_eq
(paren
(paren
r_int
r_int
)paren
op_amp
id|ret_from_irq
op_amp
op_complement
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IRQ&bslash;n&quot;
)paren
suffix:semicolon
id|unwind_nested
c_func
(paren
id|pc
comma
id|fp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|cond
op_assign
(paren
(paren
id|pc
op_ge
id|__MEMORY_START
)paren
op_logical_and
(paren
id|fp
op_ge
id|__MEMORY_START
)paren
op_logical_and
(paren
(paren
id|pc
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|fp
op_amp
l_int|7
)paren
op_eq
l_int|0
)paren
)paren
suffix:semicolon
id|pc
op_sub_assign
id|ofs
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;[&lt;%08lx&gt;] &quot;
comma
id|pc
)paren
suffix:semicolon
id|print_symbol
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first_pass
)paren
(brace
multiline_comment|/* If the innermost frame is a leaf function, it&squot;s&n;&t;&t;&t; * possible that r18 is never saved out to the stack.&n;&t;&t;&t; */
id|next_pc
op_assign
id|regs-&gt;regs
(braket
l_int|18
)braket
suffix:semicolon
)brace
r_else
(brace
id|next_pc
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lookup_prev_stack_frame
c_func
(paren
id|fp
comma
id|pc
comma
op_amp
id|next_fp
comma
op_amp
id|next_pc
comma
id|regs
)paren
op_eq
l_int|0
)paren
(brace
id|ofs
op_assign
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|pc
op_assign
id|next_pc
op_amp
op_complement
l_int|1
suffix:semicolon
id|fp
op_assign
id|next_fp
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to lookup previous stack frame&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|first_pass
op_assign
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|sh64_unwind
r_void
id|sh64_unwind
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|regs
)paren
(brace
multiline_comment|/*&n;&t;&t; * Fetch current regs if we have no other saved state to back&n;&t;&t; * trace from.&n;&t;&t; */
id|regs
op_assign
op_amp
id|here_regs
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;ori r14, 0, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|regs-&gt;regs
(braket
l_int|14
)braket
)paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;ori r15, 0, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|regs-&gt;regs
(braket
l_int|15
)braket
)paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;ori r18, 0, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|regs-&gt;regs
(braket
l_int|18
)braket
)paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;gettr tr0, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|regs-&gt;tregs
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;gettr tr1, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|regs-&gt;tregs
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;gettr tr2, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|regs-&gt;tregs
(braket
l_int|2
)braket
)paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;gettr tr3, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|regs-&gt;tregs
(braket
l_int|3
)braket
)paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;gettr tr4, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|regs-&gt;tregs
(braket
l_int|4
)braket
)paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;gettr tr5, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|regs-&gt;tregs
(braket
l_int|5
)braket
)paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;gettr tr6, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|regs-&gt;tregs
(braket
l_int|6
)braket
)paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;gettr tr7, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|regs-&gt;tregs
(braket
l_int|7
)braket
)paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;pta 0f, tr0&bslash;n&bslash;t&quot;
l_string|&quot;blink tr0, %0&bslash;n&bslash;t&quot;
l_string|&quot;0: nop&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|regs-&gt;pc
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nCall Trace:&bslash;n&quot;
)paren
suffix:semicolon
id|sh64_unwind_inner
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
eof
