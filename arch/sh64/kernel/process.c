multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * arch/sh64/kernel/process.c&n; *&n; * Copyright (C) 2000, 2001  Paolo Alberelli&n; * Copyright (C) 2003  Paul Mundt&n; * Copyright (C) 2003, 2004 Richard Curnow&n; *&n; * Started from SH3/4 version:&n; *   Copyright (C) 1999, 2000  Niibe Yutaka &amp; Kaz Kojima&n; *&n; *   In turn started from i386 version:&n; *     Copyright (C) 1995  Linus Torvalds&n; *&n; */
multiline_comment|/*&n; * This file handles the architecture-dependent parts of process handling..&n; */
multiline_comment|/* Temporary flags/tests. All to be removed/undefined. BEGIN */
DECL|macro|IDLE_TRACE
mdefine_line|#define IDLE_TRACE
DECL|macro|VM_SHOW_TABLES
mdefine_line|#define VM_SHOW_TABLES
DECL|macro|VM_TEST_FAULT
mdefine_line|#define VM_TEST_FAULT
DECL|macro|VM_TEST_RTLBMISS
mdefine_line|#define VM_TEST_RTLBMISS
DECL|macro|VM_TEST_WTLBMISS
mdefine_line|#define VM_TEST_WTLBMISS
DECL|macro|VM_SHOW_TABLES
macro_line|#undef VM_SHOW_TABLES
DECL|macro|IDLE_TRACE
macro_line|#undef IDLE_TRACE
multiline_comment|/* Temporary flags/tests. All to be removed/undefined. END */
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/rwsem.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/user.h&gt;
macro_line|#include &lt;linux/a.out.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/processor.h&gt;&t;&t;/* includes also &lt;asm/registers.h&gt; */
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/elf.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
DECL|variable|last_task_used_math
r_struct
id|task_struct
op_star
id|last_task_used_math
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef IDLE_TRACE
macro_line|#ifdef VM_SHOW_TABLES
multiline_comment|/* For testing */
DECL|function|print_PTE
r_static
r_void
id|print_PTE
c_func
(paren
r_int
id|base
)paren
(brace
r_int
id|i
comma
id|skip
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|x
comma
id|y
comma
op_star
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
id|base
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|512
suffix:semicolon
id|i
op_increment
comma
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
op_star
id|p
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|skip
)paren
(brace
id|skip
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;(0s) &quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|skip
op_assign
l_int|0
suffix:semicolon
id|x
op_assign
(paren
op_star
id|p
)paren
op_rshift
l_int|32
suffix:semicolon
id|y
op_assign
(paren
op_star
id|p
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%08Lx%08Lx &quot;
comma
id|x
comma
id|y
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|i
op_plus
l_int|1
)paren
op_amp
l_int|0x3
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* For testing */
DECL|function|print_DIR
r_static
r_void
id|print_DIR
c_func
(paren
r_int
id|base
)paren
(brace
r_int
id|i
comma
id|skip
op_assign
l_int|0
suffix:semicolon
r_int
op_star
id|p
op_assign
(paren
r_int
op_star
)paren
id|base
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|512
suffix:semicolon
id|i
op_increment
comma
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
op_star
id|p
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|skip
)paren
(brace
id|skip
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;(0s) &quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|skip
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%08lx &quot;
comma
op_star
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|i
op_plus
l_int|1
)paren
op_amp
l_int|0x7
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* For testing */
DECL|function|print_vmalloc_first_tables
r_static
r_void
id|print_vmalloc_first_tables
c_func
(paren
r_void
)paren
(brace
DECL|macro|PRESENT
mdefine_line|#define PRESENT&t;0x800&t;/* Bit 11 */
multiline_comment|/*&n;&t; * Do it really dirty by looking at raw addresses,&n;         * raw offsets, no types. If we used pgtable/pgalloc&n;&t; * macros/definitions we could hide potential bugs.&n;&t; *&n;&t; * Note that pointers are 32-bit for CDC.&n;&t; */
r_int
id|pgdt
comma
id|pmdt
comma
id|ptet
suffix:semicolon
id|pgdt
op_assign
(paren
r_int
)paren
op_amp
id|swapper_pg_dir
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;--&gt;PGD (0x%08lx):&bslash;n&quot;
comma
id|pgdt
)paren
suffix:semicolon
id|print_DIR
c_func
(paren
id|pgdt
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* VMALLOC pool is mapped at 0xc0000000, second (pointer) entry in PGD */
id|pgdt
op_add_assign
l_int|4
suffix:semicolon
id|pmdt
op_assign
(paren
r_int
)paren
(paren
op_star
(paren
r_int
op_star
)paren
id|pgdt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pmdt
op_amp
id|PRESENT
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;No PMD&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
id|pmdt
op_and_assign
l_int|0xfffff000
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;--&gt;PMD (0x%08lx):&bslash;n&quot;
comma
id|pmdt
)paren
suffix:semicolon
id|print_DIR
c_func
(paren
id|pmdt
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Get the pmdt displacement for 0xc0000000 */
id|pmdt
op_add_assign
l_int|2048
suffix:semicolon
multiline_comment|/* just look at first two address ranges ... */
multiline_comment|/* ... 0xc0000000 ... */
id|ptet
op_assign
(paren
r_int
)paren
(paren
op_star
(paren
r_int
op_star
)paren
id|pmdt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ptet
op_amp
id|PRESENT
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;No PTE0&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
id|ptet
op_and_assign
l_int|0xfffff000
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;--&gt;PTE0 (0x%08lx):&bslash;n&quot;
comma
id|ptet
)paren
suffix:semicolon
id|print_PTE
c_func
(paren
id|ptet
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* ... 0xc0001000 ... */
id|ptet
op_add_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ptet
op_amp
id|PRESENT
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;No PTE1&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
id|ptet
op_and_assign
l_int|0xfffff000
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;--&gt;PTE1 (0x%08lx):&bslash;n&quot;
comma
id|ptet
)paren
suffix:semicolon
id|print_PTE
c_func
(paren
id|ptet
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|print_vmalloc_first_tables
mdefine_line|#define print_vmalloc_first_tables()
macro_line|#endif&t;/* VM_SHOW_TABLES */
DECL|function|test_VM
r_static
r_void
id|test_VM
c_func
(paren
r_void
)paren
(brace
r_void
op_star
id|a
comma
op_star
id|b
comma
op_star
id|c
suffix:semicolon
macro_line|#ifdef VM_SHOW_TABLES
id|printk
c_func
(paren
l_string|&quot;Initial PGD/PMD/PTE&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|print_vmalloc_first_tables
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Allocating 2 bytes&bslash;n&quot;
)paren
suffix:semicolon
id|a
op_assign
id|vmalloc
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|print_vmalloc_first_tables
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Allocating 4100 bytes&bslash;n&quot;
)paren
suffix:semicolon
id|b
op_assign
id|vmalloc
c_func
(paren
l_int|4100
)paren
suffix:semicolon
id|print_vmalloc_first_tables
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Allocating 20234 bytes&bslash;n&quot;
)paren
suffix:semicolon
id|c
op_assign
id|vmalloc
c_func
(paren
l_int|20234
)paren
suffix:semicolon
id|print_vmalloc_first_tables
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef VM_TEST_FAULT
multiline_comment|/* Here you may want to fault ! */
macro_line|#ifdef VM_TEST_RTLBMISS
id|printk
c_func
(paren
l_string|&quot;Ready to fault upon read.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
r_char
op_star
)paren
id|a
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RTLBMISSed on area a !&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;RTLBMISSed on area a !&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef VM_TEST_WTLBMISS
id|printk
c_func
(paren
l_string|&quot;Ready to fault upon write.&bslash;n&quot;
)paren
suffix:semicolon
op_star
(paren
(paren
r_char
op_star
)paren
id|b
)paren
op_assign
l_char|&squot;L&squot;
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;WTLBMISSed on area b !&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif&t;/* VM_TEST_FAULT */
id|printk
c_func
(paren
l_string|&quot;Deallocating the 4100 byte chunk&bslash;n&quot;
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|b
)paren
suffix:semicolon
id|print_vmalloc_first_tables
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Deallocating the 2 byte chunk&bslash;n&quot;
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|a
)paren
suffix:semicolon
id|print_vmalloc_first_tables
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Deallocating the last chunk&bslash;n&quot;
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|c
)paren
suffix:semicolon
id|print_vmalloc_first_tables
c_func
(paren
)paren
suffix:semicolon
)brace
r_extern
r_int
r_int
r_volatile
id|jiffies
suffix:semicolon
DECL|variable|once
r_int
id|once
op_assign
l_int|0
suffix:semicolon
DECL|variable|old_jiffies
r_int
r_int
id|old_jiffies
suffix:semicolon
DECL|variable|pid
DECL|variable|pgid
r_int
id|pid
op_assign
op_minus
l_int|1
comma
id|pgid
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|function|idle_trace
r_void
id|idle_trace
c_func
(paren
r_void
)paren
(brace
id|_syscall0
c_func
(paren
r_int
comma
id|getpid
)paren
id|_syscall1
c_func
(paren
r_int
comma
id|getpgid
comma
r_int
comma
id|pid
)paren
r_if
c_cond
(paren
op_logical_neg
id|once
)paren
(brace
multiline_comment|/* VM allocation/deallocation simple test */
id|test_VM
c_func
(paren
)paren
suffix:semicolon
id|pid
op_assign
id|getpid
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Got all through to Idle !!&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;I&squot;m now going to loop forever ...&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Any ! below is a timer tick.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Any . below is a getpgid system call from pid = %d.&bslash;n&quot;
comma
id|pid
)paren
suffix:semicolon
id|old_jiffies
op_assign
id|jiffies
suffix:semicolon
id|once
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old_jiffies
op_ne
id|jiffies
)paren
(brace
id|old_jiffies
op_assign
id|jiffies
op_minus
id|old_jiffies
suffix:semicolon
r_switch
c_cond
(paren
id|old_jiffies
)paren
(brace
r_case
l_int|1
suffix:colon
id|printk
c_func
(paren
l_string|&quot;!&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|printk
c_func
(paren
l_string|&quot;!!&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|printk
c_func
(paren
l_string|&quot;!!!&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|printk
c_func
(paren
l_string|&quot;!!!!&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;(%d!)&quot;
comma
(paren
r_int
)paren
id|old_jiffies
)paren
suffix:semicolon
)brace
id|old_jiffies
op_assign
id|jiffies
suffix:semicolon
)brace
id|pgid
op_assign
id|getpgid
c_func
(paren
id|pid
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|idle_trace
mdefine_line|#define idle_trace()&t;do { } while (0)
macro_line|#endif&t;/* IDLE_TRACE */
DECL|variable|hlt_counter
r_static
r_int
id|hlt_counter
op_assign
l_int|1
suffix:semicolon
DECL|macro|HARD_IDLE_TIMEOUT
mdefine_line|#define HARD_IDLE_TIMEOUT (HZ / 3)
DECL|function|disable_hlt
r_void
id|disable_hlt
c_func
(paren
r_void
)paren
(brace
id|hlt_counter
op_increment
suffix:semicolon
)brace
DECL|function|enable_hlt
r_void
id|enable_hlt
c_func
(paren
r_void
)paren
(brace
id|hlt_counter
op_decrement
suffix:semicolon
)brace
DECL|function|nohlt_setup
r_static
r_int
id|__init
id|nohlt_setup
c_func
(paren
r_char
op_star
id|__unused
)paren
(brace
id|hlt_counter
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|hlt_setup
r_static
r_int
id|__init
id|hlt_setup
c_func
(paren
r_char
op_star
id|__unused
)paren
(brace
id|hlt_counter
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;nohlt&quot;
comma
id|nohlt_setup
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;hlt&quot;
comma
id|hlt_setup
)paren
suffix:semicolon
DECL|function|hlt
r_static
r_inline
r_void
id|hlt
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|hlt_counter
)paren
r_return
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;sleep&quot;
suffix:colon
suffix:colon
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The idle loop on a uniprocessor SH..&n; */
DECL|function|default_idle
r_void
id|default_idle
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* endless idle loop with no priority at all */
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|hlt_counter
)paren
(brace
r_while
c_loop
(paren
l_int|1
)paren
r_if
c_cond
(paren
id|need_resched
c_func
(paren
)paren
)paren
r_break
suffix:semicolon
)brace
r_else
(brace
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|need_resched
c_func
(paren
)paren
)paren
(brace
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
id|idle_trace
c_func
(paren
)paren
suffix:semicolon
id|hlt
c_func
(paren
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
)brace
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|cpu_idle
r_void
id|cpu_idle
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
id|default_idle
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|machine_restart
r_void
id|machine_restart
c_func
(paren
r_char
op_star
id|__unused
)paren
(brace
r_extern
r_void
id|phys_stext
c_func
(paren
r_void
)paren
suffix:semicolon
id|phys_stext
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|machine_halt
r_void
id|machine_halt
c_func
(paren
r_void
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
suffix:semicolon
)brace
DECL|function|machine_power_off
r_void
id|machine_power_off
c_func
(paren
r_void
)paren
(brace
r_extern
r_void
id|enter_deep_standby
c_func
(paren
r_void
)paren
suffix:semicolon
id|enter_deep_standby
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|show_regs
r_void
id|show_regs
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
r_int
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ah
op_assign
(paren
id|regs-&gt;pc
)paren
op_rshift
l_int|32
suffix:semicolon
id|al
op_assign
(paren
id|regs-&gt;pc
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|bh
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|18
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|bl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|18
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|ch
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|15
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|cl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|15
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PC  : %08Lx%08Lx LINK: %08Lx%08Lx SP  : %08Lx%08Lx&bslash;n&quot;
comma
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
)paren
suffix:semicolon
id|ah
op_assign
(paren
id|regs-&gt;sr
)paren
op_rshift
l_int|32
suffix:semicolon
id|al
op_assign
(paren
id|regs-&gt;sr
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;getcon   &quot;
id|__TEA
l_string|&quot;, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|bh
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;getcon   &quot;
id|__TEA
l_string|&quot;, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|bl
)paren
)paren
suffix:semicolon
id|bh
op_assign
(paren
id|bh
)paren
op_rshift
l_int|32
suffix:semicolon
id|bl
op_assign
(paren
id|bl
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;getcon   &quot;
id|__KCR0
l_string|&quot;, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ch
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;getcon   &quot;
id|__KCR0
l_string|&quot;, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|cl
)paren
)paren
suffix:semicolon
id|ch
op_assign
(paren
id|ch
)paren
op_rshift
l_int|32
suffix:semicolon
id|cl
op_assign
(paren
id|cl
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SR  : %08Lx%08Lx TEA : %08Lx%08Lx KCR0: %08Lx%08Lx&bslash;n&quot;
comma
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
)paren
suffix:semicolon
id|ah
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|0
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|al
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|0
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|bh
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|1
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|bl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|1
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|ch
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|2
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|cl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|2
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R0  : %08Lx%08Lx R1  : %08Lx%08Lx R2  : %08Lx%08Lx&bslash;n&quot;
comma
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
)paren
suffix:semicolon
id|ah
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|3
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|al
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|3
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|bh
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|4
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|bl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|4
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|ch
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|5
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|cl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|5
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R3  : %08Lx%08Lx R4  : %08Lx%08Lx R5  : %08Lx%08Lx&bslash;n&quot;
comma
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
)paren
suffix:semicolon
id|ah
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|6
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|al
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|6
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|bh
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|7
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|bl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|7
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|ch
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|8
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|cl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|8
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R6  : %08Lx%08Lx R7  : %08Lx%08Lx R8  : %08Lx%08Lx&bslash;n&quot;
comma
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
)paren
suffix:semicolon
id|ah
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|9
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|al
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|9
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|bh
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|10
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|bl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|10
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|ch
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|11
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|cl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|11
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R9  : %08Lx%08Lx R10 : %08Lx%08Lx R11 : %08Lx%08Lx&bslash;n&quot;
comma
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
)paren
suffix:semicolon
id|ah
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|12
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|al
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|12
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|bh
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|13
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|bl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|13
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|ch
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|14
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|cl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|14
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R12 : %08Lx%08Lx R13 : %08Lx%08Lx R14 : %08Lx%08Lx&bslash;n&quot;
comma
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
)paren
suffix:semicolon
id|ah
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|16
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|al
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|16
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|bh
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|17
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|bl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|17
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|ch
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|19
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|cl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|19
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R16 : %08Lx%08Lx R17 : %08Lx%08Lx R19 : %08Lx%08Lx&bslash;n&quot;
comma
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
)paren
suffix:semicolon
id|ah
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|20
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|al
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|20
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|bh
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|21
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|bl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|21
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|ch
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|22
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|cl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|22
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R20 : %08Lx%08Lx R21 : %08Lx%08Lx R22 : %08Lx%08Lx&bslash;n&quot;
comma
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
)paren
suffix:semicolon
id|ah
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|23
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|al
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|23
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|bh
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|24
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|bl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|24
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|ch
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|25
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|cl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|25
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R23 : %08Lx%08Lx R24 : %08Lx%08Lx R25 : %08Lx%08Lx&bslash;n&quot;
comma
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
)paren
suffix:semicolon
id|ah
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|26
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|al
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|26
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|bh
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|27
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|bl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|27
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|ch
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|28
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|cl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|28
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R26 : %08Lx%08Lx R27 : %08Lx%08Lx R28 : %08Lx%08Lx&bslash;n&quot;
comma
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
)paren
suffix:semicolon
id|ah
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|29
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|al
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|29
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|bh
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|30
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|bl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|30
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|ch
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|31
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|cl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|31
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R29 : %08Lx%08Lx R30 : %08Lx%08Lx R31 : %08Lx%08Lx&bslash;n&quot;
comma
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
)paren
suffix:semicolon
id|ah
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|32
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|al
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|32
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|bh
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|33
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|bl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|33
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|ch
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|34
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|cl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|34
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R32 : %08Lx%08Lx R33 : %08Lx%08Lx R34 : %08Lx%08Lx&bslash;n&quot;
comma
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
)paren
suffix:semicolon
id|ah
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|35
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|al
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|35
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|bh
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|36
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|bl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|36
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|ch
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|37
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|cl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|37
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R35 : %08Lx%08Lx R36 : %08Lx%08Lx R37 : %08Lx%08Lx&bslash;n&quot;
comma
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
)paren
suffix:semicolon
id|ah
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|38
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|al
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|38
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|bh
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|39
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|bl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|39
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|ch
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|40
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|cl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|40
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R38 : %08Lx%08Lx R39 : %08Lx%08Lx R40 : %08Lx%08Lx&bslash;n&quot;
comma
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
)paren
suffix:semicolon
id|ah
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|41
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|al
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|41
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|bh
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|42
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|bl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|42
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|ch
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|43
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|cl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|43
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R41 : %08Lx%08Lx R42 : %08Lx%08Lx R43 : %08Lx%08Lx&bslash;n&quot;
comma
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
)paren
suffix:semicolon
id|ah
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|44
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|al
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|44
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|bh
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|45
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|bl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|45
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|ch
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|46
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|cl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|46
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R44 : %08Lx%08Lx R45 : %08Lx%08Lx R46 : %08Lx%08Lx&bslash;n&quot;
comma
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
)paren
suffix:semicolon
id|ah
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|47
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|al
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|47
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|bh
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|48
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|bl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|48
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|ch
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|49
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|cl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|49
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R47 : %08Lx%08Lx R48 : %08Lx%08Lx R49 : %08Lx%08Lx&bslash;n&quot;
comma
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
)paren
suffix:semicolon
id|ah
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|50
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|al
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|50
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|bh
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|51
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|bl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|51
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|ch
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|52
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|cl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|52
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R50 : %08Lx%08Lx R51 : %08Lx%08Lx R52 : %08Lx%08Lx&bslash;n&quot;
comma
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
)paren
suffix:semicolon
id|ah
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|53
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|al
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|53
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|bh
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|54
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|bl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|54
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|ch
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|55
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|cl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|55
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R53 : %08Lx%08Lx R54 : %08Lx%08Lx R55 : %08Lx%08Lx&bslash;n&quot;
comma
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
)paren
suffix:semicolon
id|ah
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|56
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|al
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|56
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|bh
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|57
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|bl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|57
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|ch
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|58
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|cl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|58
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R56 : %08Lx%08Lx R57 : %08Lx%08Lx R58 : %08Lx%08Lx&bslash;n&quot;
comma
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
)paren
suffix:semicolon
id|ah
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|59
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|al
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|59
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|bh
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|60
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|bl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|60
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|ch
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|61
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|cl
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|61
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R59 : %08Lx%08Lx R60 : %08Lx%08Lx R61 : %08Lx%08Lx&bslash;n&quot;
comma
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
)paren
suffix:semicolon
id|ah
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|62
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|al
op_assign
(paren
id|regs-&gt;regs
(braket
l_int|62
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|bh
op_assign
(paren
id|regs-&gt;tregs
(braket
l_int|0
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|bl
op_assign
(paren
id|regs-&gt;tregs
(braket
l_int|0
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|ch
op_assign
(paren
id|regs-&gt;tregs
(braket
l_int|1
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|cl
op_assign
(paren
id|regs-&gt;tregs
(braket
l_int|1
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;R62 : %08Lx%08Lx T0  : %08Lx%08Lx T1  : %08Lx%08Lx&bslash;n&quot;
comma
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
)paren
suffix:semicolon
id|ah
op_assign
(paren
id|regs-&gt;tregs
(braket
l_int|2
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|al
op_assign
(paren
id|regs-&gt;tregs
(braket
l_int|2
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|bh
op_assign
(paren
id|regs-&gt;tregs
(braket
l_int|3
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|bl
op_assign
(paren
id|regs-&gt;tregs
(braket
l_int|3
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|ch
op_assign
(paren
id|regs-&gt;tregs
(braket
l_int|4
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|cl
op_assign
(paren
id|regs-&gt;tregs
(braket
l_int|4
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;T2  : %08Lx%08Lx T3  : %08Lx%08Lx T4  : %08Lx%08Lx&bslash;n&quot;
comma
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
)paren
suffix:semicolon
id|ah
op_assign
(paren
id|regs-&gt;tregs
(braket
l_int|5
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|al
op_assign
(paren
id|regs-&gt;tregs
(braket
l_int|5
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|bh
op_assign
(paren
id|regs-&gt;tregs
(braket
l_int|6
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|bl
op_assign
(paren
id|regs-&gt;tregs
(braket
l_int|6
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|ch
op_assign
(paren
id|regs-&gt;tregs
(braket
l_int|7
)braket
)paren
op_rshift
l_int|32
suffix:semicolon
id|cl
op_assign
(paren
id|regs-&gt;tregs
(braket
l_int|7
)braket
)paren
op_amp
l_int|0xffffffff
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;T5  : %08Lx%08Lx T6  : %08Lx%08Lx T7  : %08Lx%08Lx&bslash;n&quot;
comma
id|ah
comma
id|al
comma
id|bh
comma
id|bl
comma
id|ch
comma
id|cl
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re in kernel mode, dump the stack too..&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
r_void
id|show_stack
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
r_int
op_star
id|sp
)paren
suffix:semicolon
r_int
r_int
id|sp
op_assign
id|regs-&gt;regs
(braket
l_int|15
)braket
op_amp
l_int|0xffffffff
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|get_current
c_func
(paren
)paren
suffix:semicolon
id|tsk-&gt;thread.kregs
op_assign
id|regs
suffix:semicolon
id|show_stack
c_func
(paren
id|tsk
comma
(paren
r_int
r_int
op_star
)paren
id|sp
)paren
suffix:semicolon
)brace
)brace
DECL|function|alloc_task_struct
r_struct
id|task_struct
op_star
id|alloc_task_struct
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Get task descriptor pages */
r_return
(paren
r_struct
id|task_struct
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
comma
id|get_order
c_func
(paren
id|THREAD_SIZE
)paren
)paren
suffix:semicolon
)brace
DECL|function|free_task_struct
r_void
id|free_task_struct
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|p
comma
id|get_order
c_func
(paren
id|THREAD_SIZE
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a kernel thread&n; */
multiline_comment|/*&n; * This is the mechanism for creating a new kernel thread.&n; *&n; * NOTE! Only a kernel-only process(ie the swapper or direct descendants&n; * who haven&squot;t done an &quot;execve()&quot;) should use this: it will work within&n; * a system call from a &quot;real&quot; process, but the process memory space will&n; * not be free&squot;d until both the parent and the child have exited.&n; */
DECL|function|kernel_thread
r_int
id|kernel_thread
c_func
(paren
r_int
(paren
op_star
id|fn
)paren
(paren
r_void
op_star
)paren
comma
r_void
op_star
id|arg
comma
r_int
r_int
id|flags
)paren
(brace
multiline_comment|/* A bit less processor dependent than older sh ... */
r_int
r_int
id|reply
suffix:semicolon
r_static
id|__inline__
id|_syscall2
c_func
(paren
r_int
comma
id|clone
comma
r_int
r_int
comma
id|flags
comma
r_int
r_int
comma
id|newsp
)paren
r_static
id|__inline__
id|_syscall1
c_func
(paren
r_int
comma
m_exit
comma
r_int
comma
id|ret
)paren
id|reply
op_assign
id|clone
c_func
(paren
id|flags
op_or
id|CLONE_VM
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reply
)paren
(brace
multiline_comment|/* Child */
id|reply
op_assign
m_exit
(paren
id|fn
c_func
(paren
id|arg
)paren
)paren
suffix:semicolon
)brace
r_return
id|reply
suffix:semicolon
)brace
multiline_comment|/*&n; * Free current thread data structures etc..&n; */
DECL|function|exit_thread
r_void
id|exit_thread
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* See arch/sparc/kernel/process.c for the precedent for doing this -- RPC.&n;&n;&t;   The SH-5 FPU save/restore approach relies on last_task_used_math&n;&t;   pointing to a live task_struct.  When another task tries to use the&n;&t;   FPU for the 1st time, the FPUDIS trap handling (see&n;&t;   arch/sh64/kernel/fpu.c) will save the existing FPU state to the&n;&t;   FP regs field within last_task_used_math before re-loading the new&n;&t;   task&squot;s FPU state (or initialising it if the FPU has been used&n;&t;   before).  So if last_task_used_math is stale, and its page has already been&n;&t;   re-allocated for another use, the consequences are rather grim. Unless we&n;&t;   null it here, there is no other path through which it would get safely&n;&t;   nulled. */
macro_line|#ifndef CONFIG_NOFPU_SUPPORT
r_if
c_cond
(paren
id|last_task_used_math
op_eq
id|current
)paren
(brace
id|last_task_used_math
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif
)brace
DECL|function|flush_thread
r_void
id|flush_thread
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Called by fs/exec.c (flush_old_exec) to remove traces of a&n;&t; * previously running executable. */
macro_line|#ifndef CONFIG_NOFPU_SUPPORT
r_if
c_cond
(paren
id|last_task_used_math
op_eq
id|current
)paren
(brace
id|last_task_used_math
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Force FPU state to be reinitialised after exec */
id|current-&gt;used_math
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* if we are a kernel thread, about to change to user thread,&n;         * update kreg&n;         */
r_if
c_cond
(paren
id|current-&gt;thread.kregs
op_eq
op_amp
id|fake_swapper_regs
)paren
(brace
id|current-&gt;thread.kregs
op_assign
(paren
(paren
r_struct
id|pt_regs
op_star
)paren
(paren
id|THREAD_SIZE
op_plus
(paren
r_int
r_int
)paren
id|current
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|current-&gt;thread.uregs
op_assign
id|current-&gt;thread.kregs
suffix:semicolon
)brace
)brace
DECL|function|release_thread
r_void
id|release_thread
c_func
(paren
r_struct
id|task_struct
op_star
id|dead_task
)paren
(brace
multiline_comment|/* do nothing */
)brace
multiline_comment|/* Fill in the fpu structure for a core dump.. */
DECL|function|dump_fpu
r_int
id|dump_fpu
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
id|elf_fpregset_t
op_star
id|fpu
)paren
(brace
macro_line|#ifndef CONFIG_NOFPU_SUPPORT
r_int
id|fpvalid
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|fpvalid
op_assign
id|tsk-&gt;used_math
suffix:semicolon
r_if
c_cond
(paren
id|fpvalid
)paren
(brace
r_if
c_cond
(paren
id|current
op_eq
id|last_task_used_math
)paren
(brace
id|grab_fpu
c_func
(paren
)paren
suffix:semicolon
id|fpsave
c_func
(paren
op_amp
id|tsk-&gt;thread.fpu.hard
)paren
suffix:semicolon
id|release_fpu
c_func
(paren
)paren
suffix:semicolon
id|last_task_used_math
op_assign
l_int|0
suffix:semicolon
id|regs-&gt;sr
op_or_assign
id|SR_FD
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|fpu
comma
op_amp
id|tsk-&gt;thread.fpu.hard
comma
r_sizeof
(paren
op_star
id|fpu
)paren
)paren
suffix:semicolon
)brace
r_return
id|fpvalid
suffix:semicolon
macro_line|#else
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Task didn&squot;t use the fpu at all. */
macro_line|#endif
)brace
id|asmlinkage
r_void
id|ret_from_fork
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|copy_thread
r_int
id|copy_thread
c_func
(paren
r_int
id|nr
comma
r_int
r_int
id|clone_flags
comma
r_int
r_int
id|usp
comma
r_int
r_int
id|unused
comma
r_struct
id|task_struct
op_star
id|p
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|pt_regs
op_star
id|childregs
suffix:semicolon
r_int
r_int
r_int
id|se
suffix:semicolon
multiline_comment|/* Sign extension */
macro_line|#ifndef CONFIG_NOFPU_SUPPORT
r_if
c_cond
(paren
id|last_task_used_math
op_eq
id|current
)paren
(brace
id|grab_fpu
c_func
(paren
)paren
suffix:semicolon
id|fpsave
c_func
(paren
op_amp
id|current-&gt;thread.fpu.hard
)paren
suffix:semicolon
id|release_fpu
c_func
(paren
)paren
suffix:semicolon
id|last_task_used_math
op_assign
l_int|NULL
suffix:semicolon
id|regs-&gt;sr
op_or_assign
id|SR_FD
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Copy from sh version */
id|childregs
op_assign
(paren
(paren
r_struct
id|pt_regs
op_star
)paren
(paren
id|THREAD_SIZE
op_plus
(paren
r_int
r_int
)paren
id|p-&gt;thread_info
)paren
)paren
op_minus
l_int|1
suffix:semicolon
op_star
id|childregs
op_assign
op_star
id|regs
suffix:semicolon
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
id|childregs-&gt;regs
(braket
l_int|15
)braket
op_assign
id|usp
suffix:semicolon
id|p-&gt;thread.uregs
op_assign
id|childregs
suffix:semicolon
)brace
r_else
(brace
id|childregs-&gt;regs
(braket
l_int|15
)braket
op_assign
(paren
r_int
r_int
)paren
id|p-&gt;thread_info
op_plus
id|THREAD_SIZE
suffix:semicolon
)brace
id|childregs-&gt;regs
(braket
l_int|9
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set return value for child */
id|childregs-&gt;sr
op_or_assign
id|SR_FD
suffix:semicolon
multiline_comment|/* Invalidate FPU flag */
multiline_comment|/* From sh */
id|p-&gt;set_child_tid
op_assign
id|p-&gt;clear_child_tid
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;thread.sp
op_assign
(paren
r_int
r_int
)paren
id|childregs
suffix:semicolon
id|p-&gt;thread.pc
op_assign
(paren
r_int
r_int
)paren
id|ret_from_fork
suffix:semicolon
multiline_comment|/*&n;&t; * Sign extend the edited stack.&n;         * Note that thread.pc and thread.pc will stay&n;&t; * 32-bit wide and context switch must take care&n;&t; * of NEFF sign extension.&n;&t; */
id|se
op_assign
id|childregs-&gt;regs
(braket
l_int|15
)braket
suffix:semicolon
id|se
op_assign
(paren
id|se
op_amp
id|NEFF_SIGN
)paren
ques
c_cond
(paren
id|se
op_or
id|NEFF_MASK
)paren
suffix:colon
id|se
suffix:semicolon
id|childregs-&gt;regs
(braket
l_int|15
)braket
op_assign
id|se
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * fill in the user structure for a core dump..&n; */
DECL|function|dump_thread
r_void
id|dump_thread
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_struct
id|user
op_star
id|dump
)paren
(brace
id|dump-&gt;magic
op_assign
id|CMAGIC
suffix:semicolon
id|dump-&gt;start_code
op_assign
id|current-&gt;mm-&gt;start_code
suffix:semicolon
id|dump-&gt;start_data
op_assign
id|current-&gt;mm-&gt;start_data
suffix:semicolon
id|dump-&gt;start_stack
op_assign
id|regs-&gt;regs
(braket
l_int|15
)braket
op_amp
op_complement
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|dump-&gt;u_tsize
op_assign
(paren
id|current-&gt;mm-&gt;end_code
op_minus
id|dump-&gt;start_code
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|dump-&gt;u_dsize
op_assign
(paren
id|current-&gt;mm-&gt;brk
op_plus
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_minus
id|dump-&gt;start_data
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|dump-&gt;u_ssize
op_assign
(paren
id|current-&gt;mm-&gt;start_stack
op_minus
id|dump-&gt;start_stack
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/* Debug registers will come here. */
id|dump-&gt;regs
op_assign
op_star
id|regs
suffix:semicolon
id|dump-&gt;u_fpvalid
op_assign
id|dump_fpu
c_func
(paren
id|regs
comma
op_amp
id|dump-&gt;fpu
)paren
suffix:semicolon
)brace
DECL|function|sys_fork
id|asmlinkage
r_int
id|sys_fork
c_func
(paren
r_int
r_int
id|r2
comma
r_int
r_int
id|r3
comma
r_int
r_int
id|r4
comma
r_int
r_int
id|r5
comma
r_int
r_int
id|r6
comma
r_int
r_int
id|r7
comma
r_struct
id|pt_regs
op_star
id|pregs
)paren
(brace
r_return
id|do_fork
c_func
(paren
id|SIGCHLD
comma
id|pregs-&gt;regs
(braket
l_int|15
)braket
comma
id|pregs
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|sys_clone
id|asmlinkage
r_int
id|sys_clone
c_func
(paren
r_int
r_int
id|clone_flags
comma
r_int
r_int
id|newsp
comma
r_int
r_int
id|r4
comma
r_int
r_int
id|r5
comma
r_int
r_int
id|r6
comma
r_int
r_int
id|r7
comma
r_struct
id|pt_regs
op_star
id|pregs
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|newsp
)paren
id|newsp
op_assign
id|pregs-&gt;regs
(braket
l_int|15
)braket
suffix:semicolon
r_return
id|do_fork
c_func
(paren
id|clone_flags
comma
id|newsp
comma
id|pregs
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is trivial, and on the face of it looks like it&n; * could equally well be done in user mode.&n; *&n; * Not so, for quite unobvious reasons - register pressure.&n; * In user mode vfork() cannot have a stack frame, and if&n; * done by calling the &quot;clone()&quot; system call directly, you&n; * do not have enough call-clobbered registers to hold all&n; * the information you need.&n; */
DECL|function|sys_vfork
id|asmlinkage
r_int
id|sys_vfork
c_func
(paren
r_int
r_int
id|r2
comma
r_int
r_int
id|r3
comma
r_int
r_int
id|r4
comma
r_int
r_int
id|r5
comma
r_int
r_int
id|r6
comma
r_int
r_int
id|r7
comma
r_struct
id|pt_regs
op_star
id|pregs
)paren
(brace
r_return
id|do_fork
c_func
(paren
id|CLONE_VFORK
op_or
id|CLONE_VM
op_or
id|SIGCHLD
comma
id|pregs-&gt;regs
(braket
l_int|15
)braket
comma
id|pregs
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sys_execve() executes a new program.&n; */
DECL|function|sys_execve
id|asmlinkage
r_int
id|sys_execve
c_func
(paren
r_char
op_star
id|ufilename
comma
r_char
op_star
op_star
id|uargv
comma
r_char
op_star
op_star
id|uenvp
comma
r_int
r_int
id|r5
comma
r_int
r_int
id|r6
comma
r_int
r_int
id|r7
comma
r_struct
id|pt_regs
op_star
id|pregs
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|filename
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|filename
op_assign
id|getname
c_func
(paren
(paren
r_char
id|__user
op_star
)paren
id|ufilename
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|filename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|filename
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|do_execve
c_func
(paren
id|filename
comma
(paren
r_char
id|__user
op_star
id|__user
op_star
)paren
id|uargv
comma
(paren
r_char
id|__user
op_star
id|__user
op_star
)paren
id|uenvp
comma
id|pregs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
l_int|0
)paren
(brace
id|task_lock
c_func
(paren
id|current
)paren
suffix:semicolon
id|current-&gt;ptrace
op_and_assign
op_complement
id|PT_DTRACE
suffix:semicolon
id|task_unlock
c_func
(paren
id|current
)paren
suffix:semicolon
)brace
id|putname
c_func
(paren
id|filename
)paren
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * These bracket the sleeping functions..&n; */
r_extern
r_void
id|interruptible_sleep_on
c_func
(paren
id|wait_queue_head_t
op_star
id|q
)paren
suffix:semicolon
DECL|macro|mid_sched
mdefine_line|#define mid_sched&t;((unsigned long) interruptible_sleep_on)
DECL|function|in_sh64_switch_to
r_static
r_int
id|in_sh64_switch_to
c_func
(paren
r_int
r_int
id|pc
)paren
(brace
r_extern
r_char
id|__sh64_switch_to_end
suffix:semicolon
multiline_comment|/* For a sleeping task, the PC is somewhere in the middle of the function,&n;&t;   so we don&squot;t have to worry about masking the LSB off */
r_return
(paren
id|pc
op_ge
(paren
r_int
r_int
)paren
id|sh64_switch_to
)paren
op_logical_and
(paren
id|pc
OL
(paren
r_int
r_int
)paren
op_amp
id|__sh64_switch_to_end
)paren
suffix:semicolon
)brace
DECL|function|get_wchan
r_int
r_int
id|get_wchan
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_int
r_int
id|schedule_fp
suffix:semicolon
r_int
r_int
id|sh64_switch_to_fp
suffix:semicolon
r_int
r_int
id|schedule_caller_pc
suffix:semicolon
r_int
r_int
id|pc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
op_logical_or
id|p
op_eq
id|current
op_logical_or
id|p-&gt;state
op_eq
id|TASK_RUNNING
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * The same comment as on the Alpha applies here, too ...&n;&t; */
id|pc
op_assign
id|thread_saved_pc
c_func
(paren
id|p
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_FRAME_POINTER
r_if
c_cond
(paren
id|in_sh64_switch_to
c_func
(paren
id|pc
)paren
)paren
(brace
id|sh64_switch_to_fp
op_assign
(paren
r_int
)paren
id|p-&gt;thread.sp
suffix:semicolon
multiline_comment|/* r14 is saved at offset 4 in the sh64_switch_to frame */
id|schedule_fp
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
(paren
r_int
)paren
(paren
id|sh64_switch_to_fp
op_plus
l_int|4
)paren
suffix:semicolon
multiline_comment|/* and the caller of &squot;schedule&squot; is (currently!) saved at offset 24&n;&t;&t;   in the frame of schedule (from disasm) */
id|schedule_caller_pc
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
(paren
r_int
)paren
(paren
id|schedule_fp
op_plus
l_int|24
)paren
suffix:semicolon
r_return
id|schedule_caller_pc
suffix:semicolon
)brace
macro_line|#endif
r_return
id|pc
suffix:semicolon
)brace
multiline_comment|/* Provide a /proc/asids file that lists out the&n;   ASIDs currently associated with the processes.  (If the DM.PC register is&n;   examined through the debug link, this shows ASID + PC.  To make use of this,&n;   the PID-&gt;ASID relationship needs to be known.  This is primarily for&n;   debugging.)&n;   */
macro_line|#if defined(CONFIG_SH64_PROC_ASIDS)
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
r_static
r_int
DECL|function|asids_proc_info
id|asids_proc_info
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|fpos
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
(brace
r_int
id|pid
op_assign
id|p-&gt;pid
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pid
)paren
r_continue
suffix:semicolon
id|mm
op_assign
id|p-&gt;mm
suffix:semicolon
r_if
c_cond
(paren
id|mm
)paren
(brace
r_int
r_int
id|asid
comma
id|context
suffix:semicolon
id|context
op_assign
id|mm-&gt;context
suffix:semicolon
id|asid
op_assign
(paren
id|context
op_amp
l_int|0xff
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%5d : %02x&bslash;n&quot;
comma
id|pid
comma
id|asid
)paren
suffix:semicolon
)brace
r_else
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;%5d : (none)&bslash;n&quot;
comma
id|pid
)paren
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|register_proc_asids
r_static
r_int
id|__init
id|register_proc_asids
c_func
(paren
r_void
)paren
(brace
id|create_proc_read_entry
c_func
(paren
l_string|&quot;asids&quot;
comma
l_int|0
comma
l_int|NULL
comma
id|asids_proc_info
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|register_proc_asids
id|__initcall
c_func
(paren
id|register_proc_asids
)paren
suffix:semicolon
macro_line|#endif
eof
