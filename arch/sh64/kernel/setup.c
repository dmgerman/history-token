multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * arch/sh64/kernel/setup.c&n; *&n; * sh64 Arch Support&n; *&n; * This file handles the architecture-dependent parts of initialization&n; *&n; * Copyright (C) 2000, 2001  Paolo Alberelli&n; * Copyright (C) 2003, 2004  Paul Mundt&n; *&n; * benedict.gaster@superh.com:   2nd May 2002&n; *    Modified to use the empty_zero_page to pass command line arguments.&n; *&n; * benedict.gaster@superh.com:&t; 3rd May 2002&n; *    Added support for ramdisk, removing statically linked romfs at the same time.&n; *&n; * lethal@linux-sh.org:          15th May 2003&n; *    Added generic procfs cpuinfo reporting. Make boards just export their name.&n; *&n; * lethal@linux-sh.org:          25th May 2003&n; *    Added generic get_cpu_subtype() for subtype reporting from cpu_data-&gt;type.&n; *&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/rwsem.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/user.h&gt;
macro_line|#include &lt;linux/a.out.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;linux/root_dev.h&gt;
macro_line|#include &lt;linux/cpu.h&gt;
macro_line|#include &lt;linux/initrd.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/platform.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/sections.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#ifdef CONFIG_VT
macro_line|#include &lt;linux/console.h&gt;
macro_line|#endif
DECL|variable|screen_info
r_struct
id|screen_info
id|screen_info
suffix:semicolon
multiline_comment|/* On a PC this would be initialised as a result of the BIOS detecting the&n; * mouse. */
DECL|variable|aux_device_present
r_int
r_char
id|aux_device_present
op_assign
l_int|0xaa
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_RAM
r_extern
r_int
id|rd_doload
suffix:semicolon
multiline_comment|/* 1 = load ramdisk, 0 = don&squot;t load */
r_extern
r_int
id|rd_prompt
suffix:semicolon
multiline_comment|/* 1 = prompt for ramdisk, 0 = don&squot;t prompt */
r_extern
r_int
id|rd_image_start
suffix:semicolon
multiline_comment|/* starting block # of image */
macro_line|#endif
r_extern
r_int
id|root_mountflags
suffix:semicolon
r_extern
r_char
op_star
id|get_system_type
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|platform_setup
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|platform_monitor
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|platform_reserve
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|sh64_cache_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|sh64_tlb_init
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|RAMDISK_IMAGE_START_MASK
mdefine_line|#define RAMDISK_IMAGE_START_MASK&t;0x07FF
DECL|macro|RAMDISK_PROMPT_FLAG
mdefine_line|#define RAMDISK_PROMPT_FLAG&t;&t;0x8000
DECL|macro|RAMDISK_LOAD_FLAG
mdefine_line|#define RAMDISK_LOAD_FLAG&t;&t;0x4000
DECL|variable|command_line
r_static
r_char
id|command_line
(braket
id|COMMAND_LINE_SIZE
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|memory_start
r_int
r_int
r_int
id|memory_start
op_assign
id|CONFIG_MEMORY_START
suffix:semicolon
DECL|variable|memory_end
r_int
r_int
r_int
id|memory_end
op_assign
id|CONFIG_MEMORY_START
op_plus
(paren
id|CONFIG_MEMORY_SIZE_IN_MB
op_star
l_int|1024
op_star
l_int|1024
)paren
suffix:semicolon
DECL|variable|boot_cpu_data
r_struct
id|sh_cpuinfo
id|boot_cpu_data
suffix:semicolon
DECL|function|parse_mem_cmdline
r_static
r_inline
r_void
id|parse_mem_cmdline
(paren
r_char
op_star
op_star
id|cmdline_p
)paren
(brace
r_char
id|c
op_assign
l_char|&squot; &squot;
comma
op_star
id|to
op_assign
id|command_line
comma
op_star
id|from
op_assign
id|COMMAND_LINE
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Save unparsed command line copy for /proc/cmdline */
id|memcpy
c_func
(paren
id|saved_command_line
comma
id|COMMAND_LINE
comma
id|COMMAND_LINE_SIZE
)paren
suffix:semicolon
id|saved_command_line
(braket
id|COMMAND_LINE_SIZE
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/*&n;&t;   * &quot;mem=XXX[kKmM]&quot; defines a size of memory.&n;&t;   */
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot; &squot;
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|from
comma
l_string|&quot;mem=&quot;
comma
l_int|4
)paren
)paren
(brace
r_if
c_cond
(paren
id|to
op_ne
id|command_line
)paren
id|to
op_decrement
suffix:semicolon
(brace
r_int
r_int
id|mem_size
suffix:semicolon
id|mem_size
op_assign
id|memparse
c_func
(paren
id|from
op_plus
l_int|4
comma
op_amp
id|from
)paren
suffix:semicolon
id|memory_end
op_assign
id|memory_start
op_plus
id|mem_size
suffix:semicolon
)brace
)brace
id|c
op_assign
op_star
(paren
id|from
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|COMMAND_LINE_SIZE
op_le
op_increment
id|len
)paren
r_break
suffix:semicolon
op_star
(paren
id|to
op_increment
)paren
op_assign
id|c
suffix:semicolon
)brace
op_star
id|to
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
op_star
id|cmdline_p
op_assign
id|command_line
suffix:semicolon
)brace
DECL|function|sh64_cpu_type_detect
r_static
r_void
id|__init
id|sh64_cpu_type_detect
c_func
(paren
r_void
)paren
(brace
r_extern
r_int
r_int
r_int
id|peek_real_address_q
c_func
(paren
r_int
r_int
r_int
id|addr
)paren
suffix:semicolon
r_int
r_int
r_int
id|cir
suffix:semicolon
multiline_comment|/* Do peeks in real mode to avoid having to set up a mapping for the&n;&t;   WPC registers.  On SH5-101 cut2, such a mapping would be exposed to&n;&t;   an address translation erratum which would make it hard to set up&n;&t;   correctly. */
id|cir
op_assign
id|peek_real_address_q
c_func
(paren
l_int|0x0d000008
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cir
op_amp
l_int|0xffff
)paren
op_eq
l_int|0x5103
)paren
(brace
id|boot_cpu_data.type
op_assign
id|CPU_SH5_103
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|cir
op_rshift
l_int|32
)paren
op_amp
l_int|0xffff
)paren
op_eq
l_int|0x51e2
)paren
(brace
multiline_comment|/* CPU.VCR aliased at CIR address on SH5-101 */
id|boot_cpu_data.type
op_assign
id|CPU_SH5_101
suffix:semicolon
)brace
r_else
(brace
id|boot_cpu_data.type
op_assign
id|CPU_SH_NONE
suffix:semicolon
)brace
)brace
DECL|function|setup_arch
r_void
id|__init
id|setup_arch
c_func
(paren
r_char
op_star
op_star
id|cmdline_p
)paren
(brace
r_int
r_int
id|bootmap_size
comma
id|i
suffix:semicolon
r_int
r_int
id|first_pfn
comma
id|start_pfn
comma
id|last_pfn
comma
id|pages
suffix:semicolon
macro_line|#ifdef CONFIG_EARLY_PRINTK
r_extern
r_void
id|enable_early_printk
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Setup Early SCIF console&n;&t; */
id|enable_early_printk
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Setup TLB mappings&n;&t; */
id|sh64_tlb_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Caches are already initialized by the time we get here, so we just&n;&t; * fill in cpu_data info for the caches.&n;&t; */
id|sh64_cache_init
c_func
(paren
)paren
suffix:semicolon
id|platform_setup
c_func
(paren
)paren
suffix:semicolon
id|platform_monitor
c_func
(paren
)paren
suffix:semicolon
id|sh64_cpu_type_detect
c_func
(paren
)paren
suffix:semicolon
id|ROOT_DEV
op_assign
id|old_decode_dev
c_func
(paren
id|ORIG_ROOT_DEV
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_RAM
id|rd_image_start
op_assign
id|RAMDISK_FLAGS
op_amp
id|RAMDISK_IMAGE_START_MASK
suffix:semicolon
id|rd_prompt
op_assign
(paren
(paren
id|RAMDISK_FLAGS
op_amp
id|RAMDISK_PROMPT_FLAG
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|rd_doload
op_assign
(paren
(paren
id|RAMDISK_FLAGS
op_amp
id|RAMDISK_LOAD_FLAG
)paren
op_ne
l_int|0
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|MOUNT_ROOT_RDONLY
)paren
id|root_mountflags
op_and_assign
op_complement
id|MS_RDONLY
suffix:semicolon
id|init_mm.start_code
op_assign
(paren
r_int
r_int
)paren
id|_text
suffix:semicolon
id|init_mm.end_code
op_assign
(paren
r_int
r_int
)paren
id|_etext
suffix:semicolon
id|init_mm.end_data
op_assign
(paren
r_int
r_int
)paren
id|_edata
suffix:semicolon
id|init_mm.brk
op_assign
(paren
r_int
r_int
)paren
id|_end
suffix:semicolon
id|code_resource.start
op_assign
id|__pa
c_func
(paren
id|_text
)paren
suffix:semicolon
id|code_resource.end
op_assign
id|__pa
c_func
(paren
id|_etext
)paren
op_minus
l_int|1
suffix:semicolon
id|data_resource.start
op_assign
id|__pa
c_func
(paren
id|_etext
)paren
suffix:semicolon
id|data_resource.end
op_assign
id|__pa
c_func
(paren
id|_edata
)paren
op_minus
l_int|1
suffix:semicolon
id|parse_mem_cmdline
c_func
(paren
id|cmdline_p
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Find the lowest and highest page frame numbers we have available&n;&t; */
id|first_pfn
op_assign
id|PFN_DOWN
c_func
(paren
id|memory_start
)paren
suffix:semicolon
id|last_pfn
op_assign
id|PFN_DOWN
c_func
(paren
id|memory_end
)paren
suffix:semicolon
id|pages
op_assign
id|last_pfn
op_minus
id|first_pfn
suffix:semicolon
multiline_comment|/*&n;&t; * Partially used pages are not usable - thus&n;&t; * we are rounding upwards:&n;&t; */
id|start_pfn
op_assign
id|PFN_UP
c_func
(paren
id|__pa
c_func
(paren
id|_end
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Find a proper area for the bootmem bitmap. After this&n;&t; * bootstrap step all allocations (until the page allocator&n;&t; * is intact) must be done via bootmem_alloc().&n;&t; */
id|bootmap_size
op_assign
id|init_bootmem_node
c_func
(paren
id|NODE_DATA
c_func
(paren
l_int|0
)paren
comma
id|start_pfn
comma
id|first_pfn
comma
id|last_pfn
)paren
suffix:semicolon
multiline_comment|/*&n;         * Round it up.&n;         */
id|bootmap_size
op_assign
id|PFN_PHYS
c_func
(paren
id|PFN_UP
c_func
(paren
id|bootmap_size
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Register fully available RAM pages with the bootmem allocator.&n;&t; */
id|free_bootmem_node
c_func
(paren
id|NODE_DATA
c_func
(paren
l_int|0
)paren
comma
id|PFN_PHYS
c_func
(paren
id|first_pfn
)paren
comma
id|PFN_PHYS
c_func
(paren
id|pages
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reserve all kernel sections + bootmem bitmap + a guard page.&n;&t; */
id|reserve_bootmem_node
c_func
(paren
id|NODE_DATA
c_func
(paren
l_int|0
)paren
comma
id|PFN_PHYS
c_func
(paren
id|first_pfn
)paren
comma
(paren
id|PFN_PHYS
c_func
(paren
id|start_pfn
)paren
op_plus
id|bootmap_size
op_plus
id|PAGE_SIZE
)paren
op_minus
id|PFN_PHYS
c_func
(paren
id|first_pfn
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reserve platform dependent sections&n;&t; */
id|platform_reserve
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_if
c_cond
(paren
id|LOADER_TYPE
op_logical_and
id|INITRD_START
)paren
(brace
r_if
c_cond
(paren
id|INITRD_START
op_plus
id|INITRD_SIZE
op_le
(paren
id|PFN_PHYS
c_func
(paren
id|last_pfn
)paren
)paren
)paren
(brace
id|reserve_bootmem_node
c_func
(paren
id|NODE_DATA
c_func
(paren
l_int|0
)paren
comma
id|INITRD_START
op_plus
id|__MEMORY_START
comma
id|INITRD_SIZE
)paren
suffix:semicolon
id|initrd_start
op_assign
(paren
r_int
)paren
id|INITRD_START
ques
c_cond
id|INITRD_START
op_plus
id|PAGE_OFFSET
op_plus
id|__MEMORY_START
suffix:colon
l_int|0
suffix:semicolon
id|initrd_end
op_assign
id|initrd_start
op_plus
id|INITRD_SIZE
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;initrd extends beyond end of memory &quot;
l_string|&quot;(0x%08lx &gt; 0x%08lx)&bslash;ndisabling initrd&bslash;n&quot;
comma
(paren
r_int
)paren
id|INITRD_START
op_plus
id|INITRD_SIZE
comma
id|PFN_PHYS
c_func
(paren
id|last_pfn
)paren
)paren
suffix:semicolon
id|initrd_start
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Claim all RAM, ROM, and I/O resources.&n;&t; */
multiline_comment|/* Kernel RAM */
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
op_amp
id|code_resource
)paren
suffix:semicolon
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
op_amp
id|data_resource
)paren
suffix:semicolon
multiline_comment|/* Other KRAM space */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|STANDARD_KRAM_RESOURCES
op_minus
l_int|2
suffix:semicolon
id|i
op_increment
)paren
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
op_amp
id|platform_parms.kram_res_p
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* XRAM space */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|STANDARD_XRAM_RESOURCES
suffix:semicolon
id|i
op_increment
)paren
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
op_amp
id|platform_parms.xram_res_p
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* ROM space */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|STANDARD_ROM_RESOURCES
suffix:semicolon
id|i
op_increment
)paren
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
op_amp
id|platform_parms.rom_res_p
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* I/O space */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|STANDARD_IO_RESOURCES
suffix:semicolon
id|i
op_increment
)paren
id|request_resource
c_func
(paren
op_amp
id|ioport_resource
comma
op_amp
id|platform_parms.io_res_p
(braket
id|i
)braket
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_VT
macro_line|#if defined(CONFIG_VGA_CONSOLE)
id|conswitchp
op_assign
op_amp
id|vga_con
suffix:semicolon
macro_line|#elif defined(CONFIG_DUMMY_CONSOLE)
id|conswitchp
op_assign
op_amp
id|dummy_con
suffix:semicolon
macro_line|#endif
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;Hardware FPU: %s&bslash;n&quot;
comma
id|fpu_in_use
ques
c_cond
l_string|&quot;enabled&quot;
suffix:colon
l_string|&quot;disabled&quot;
)paren
suffix:semicolon
id|paging_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|__xchg_called_with_bad_pointer
r_void
id|__xchg_called_with_bad_pointer
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;xchg() called with bad pointer !&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|cpu
r_static
r_struct
id|cpu
id|cpu
(braket
l_int|1
)braket
suffix:semicolon
DECL|function|topology_init
r_static
r_int
id|__init
id|topology_init
c_func
(paren
r_void
)paren
(brace
r_return
id|register_cpu
c_func
(paren
id|cpu
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|variable|topology_init
id|subsys_initcall
c_func
(paren
id|topology_init
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Get CPU information&n; */
DECL|variable|cpu_name
r_static
r_const
r_char
op_star
id|cpu_name
(braket
)braket
op_assign
(brace
(braket
id|CPU_SH5_101
)braket
op_assign
l_string|&quot;SH5-101&quot;
comma
(braket
id|CPU_SH5_103
)braket
op_assign
l_string|&quot;SH5-103&quot;
comma
(braket
id|CPU_SH_NONE
)braket
op_assign
l_string|&quot;Unknown&quot;
comma
)brace
suffix:semicolon
DECL|function|get_cpu_subtype
r_const
r_char
op_star
id|get_cpu_subtype
c_func
(paren
r_void
)paren
(brace
r_return
id|cpu_name
(braket
id|boot_cpu_data.type
)braket
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|show_cpuinfo
r_static
r_int
id|show_cpuinfo
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|v
)paren
(brace
r_int
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu
)paren
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;machine&bslash;t&bslash;t: %s&bslash;n&quot;
comma
id|get_system_type
c_func
(paren
)paren
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;processor&bslash;t: %d&bslash;n&quot;
comma
id|cpu
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;cpu family&bslash;t: SH-5&bslash;n&quot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;cpu type&bslash;t: %s&bslash;n&quot;
comma
id|get_cpu_subtype
c_func
(paren
)paren
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;icache size&bslash;t: %dK-bytes&bslash;n&quot;
comma
(paren
id|boot_cpu_data.icache.ways
op_star
id|boot_cpu_data.icache.sets
op_star
id|boot_cpu_data.icache.linesz
)paren
op_rshift
l_int|10
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;dcache size&bslash;t: %dK-bytes&bslash;n&quot;
comma
(paren
id|boot_cpu_data.dcache.ways
op_star
id|boot_cpu_data.dcache.sets
op_star
id|boot_cpu_data.dcache.linesz
)paren
op_rshift
l_int|10
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;itlb entries&bslash;t: %d&bslash;n&quot;
comma
id|boot_cpu_data.itlb.entries
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;dtlb entries&bslash;t: %d&bslash;n&quot;
comma
id|boot_cpu_data.dtlb.entries
)paren
suffix:semicolon
DECL|macro|PRINT_CLOCK
mdefine_line|#define PRINT_CLOCK(name, value) &bslash;&n;&t;seq_printf(m, name &quot; clock&bslash;t: %d.%02dMHz&bslash;n&quot;, &bslash;&n;&t;&t;     ((value) / 1000000), ((value) % 1000000)/10000)
id|PRINT_CLOCK
c_func
(paren
l_string|&quot;cpu&quot;
comma
id|boot_cpu_data.cpu_clock
)paren
suffix:semicolon
id|PRINT_CLOCK
c_func
(paren
l_string|&quot;bus&quot;
comma
id|boot_cpu_data.bus_clock
)paren
suffix:semicolon
id|PRINT_CLOCK
c_func
(paren
l_string|&quot;module&quot;
comma
id|boot_cpu_data.module_clock
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;bogomips&bslash;t: %lu.%02lu&bslash;n&bslash;n&quot;
comma
(paren
id|loops_per_jiffy
op_star
id|HZ
op_plus
l_int|2500
)paren
op_div
l_int|500000
comma
(paren
(paren
id|loops_per_jiffy
op_star
id|HZ
op_plus
l_int|2500
)paren
op_div
l_int|5000
)paren
op_mod
l_int|100
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|c_start
r_static
r_void
op_star
id|c_start
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_return
(paren
r_void
op_star
)paren
(paren
op_star
id|pos
op_eq
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|c_next
r_static
r_void
op_star
id|c_next
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|v
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|c_stop
r_static
r_void
id|c_stop
c_func
(paren
r_struct
id|seq_file
op_star
id|m
comma
r_void
op_star
id|v
)paren
(brace
)brace
DECL|variable|cpuinfo_op
r_struct
id|seq_operations
id|cpuinfo_op
op_assign
(brace
dot
id|start
op_assign
id|c_start
comma
dot
id|next
op_assign
id|c_next
comma
dot
id|stop
op_assign
id|c_stop
comma
dot
id|show
op_assign
id|show_cpuinfo
comma
)brace
suffix:semicolon
macro_line|#endif /* CONFIG_PROC_FS */
eof
