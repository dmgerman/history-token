multiline_comment|/*&n; * arch/sh/lib/csum_parial.c&n; *&n; * This file contains network checksum routines that are better done&n; * in an architecture-specific manner due to speed..&n; */
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|function|from64to16
r_static
r_inline
r_int
r_int
id|from64to16
c_func
(paren
r_int
r_int
r_int
id|x
)paren
(brace
multiline_comment|/* add up 32-bit words for 33 bits */
id|x
op_assign
(paren
id|x
op_amp
l_int|0xffffffff
)paren
op_plus
(paren
id|x
op_rshift
l_int|32
)paren
suffix:semicolon
multiline_comment|/* add up 16-bit and 17-bit words for 17+c bits */
id|x
op_assign
(paren
id|x
op_amp
l_int|0xffff
)paren
op_plus
(paren
id|x
op_rshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/* add up 16-bit and 2-bit for 16+c bit */
id|x
op_assign
(paren
id|x
op_amp
l_int|0xffff
)paren
op_plus
(paren
id|x
op_rshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/* add up carry.. */
id|x
op_assign
(paren
id|x
op_amp
l_int|0xffff
)paren
op_plus
(paren
id|x
op_rshift
l_int|16
)paren
suffix:semicolon
r_return
id|x
suffix:semicolon
)brace
DECL|function|foldto16
r_static
r_inline
r_int
r_int
id|foldto16
c_func
(paren
r_int
r_int
id|x
)paren
(brace
multiline_comment|/* add up 16-bit for 17 bits */
id|x
op_assign
(paren
id|x
op_amp
l_int|0xffff
)paren
op_plus
(paren
id|x
op_rshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/* add up carry.. */
id|x
op_assign
(paren
id|x
op_amp
l_int|0xffff
)paren
op_plus
(paren
id|x
op_rshift
l_int|16
)paren
suffix:semicolon
r_return
id|x
suffix:semicolon
)brace
DECL|function|myfoldto16
r_static
r_inline
r_int
r_int
id|myfoldto16
c_func
(paren
r_int
r_int
r_int
id|x
)paren
(brace
multiline_comment|/* Fold down to 32-bits so we don&squot;t loose in the typedef-less&n;&t;   network stack.  */
multiline_comment|/* 64 to 33 */
id|x
op_assign
(paren
id|x
op_amp
l_int|0xffffffff
)paren
op_plus
(paren
id|x
op_rshift
l_int|32
)paren
suffix:semicolon
multiline_comment|/* 33 to 32 */
id|x
op_assign
(paren
id|x
op_amp
l_int|0xffffffff
)paren
op_plus
(paren
id|x
op_rshift
l_int|32
)paren
suffix:semicolon
multiline_comment|/* add up 16-bit for 17 bits */
id|x
op_assign
(paren
id|x
op_amp
l_int|0xffff
)paren
op_plus
(paren
id|x
op_rshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/* add up carry.. */
id|x
op_assign
(paren
id|x
op_amp
l_int|0xffff
)paren
op_plus
(paren
id|x
op_rshift
l_int|16
)paren
suffix:semicolon
r_return
id|x
suffix:semicolon
)brace
DECL|macro|odd
mdefine_line|#define odd(x) ((x)&amp;1)
DECL|macro|U16
mdefine_line|#define U16(x) ntohs(x)
DECL|function|do_csum
r_static
r_int
r_int
id|do_csum
c_func
(paren
r_const
r_int
r_char
op_star
id|buff
comma
r_int
id|len
)paren
(brace
r_int
id|odd
comma
id|count
suffix:semicolon
r_int
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;do_csum buff %p, len %d (0x%x)&bslash;n&quot;
comma
id|buff
comma
id|len
comma
id|len
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|26
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%02X &quot;
comma
id|buff
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|len
op_le
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|odd
op_assign
l_int|1
op_amp
(paren
r_int
r_int
)paren
id|buff
suffix:semicolon
r_if
c_cond
(paren
id|odd
)paren
(brace
id|result
op_assign
op_star
id|buff
op_lshift
l_int|8
suffix:semicolon
id|len
op_decrement
suffix:semicolon
id|buff
op_increment
suffix:semicolon
)brace
id|count
op_assign
id|len
op_rshift
l_int|1
suffix:semicolon
multiline_comment|/* nr of 16-bit words.. */
r_if
c_cond
(paren
id|count
)paren
(brace
r_if
c_cond
(paren
l_int|2
op_amp
(paren
r_int
r_int
)paren
id|buff
)paren
(brace
id|result
op_add_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|buff
suffix:semicolon
id|count
op_decrement
suffix:semicolon
id|len
op_sub_assign
l_int|2
suffix:semicolon
id|buff
op_add_assign
l_int|2
suffix:semicolon
)brace
id|count
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* nr of 32-bit words.. */
r_if
c_cond
(paren
id|count
)paren
(brace
r_int
r_int
id|carry
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_int
r_int
id|w
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|buff
suffix:semicolon
id|buff
op_add_assign
l_int|4
suffix:semicolon
id|count
op_decrement
suffix:semicolon
id|result
op_add_assign
id|carry
suffix:semicolon
id|result
op_add_assign
id|w
suffix:semicolon
id|carry
op_assign
(paren
id|w
OG
id|result
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
)paren
suffix:semicolon
id|result
op_add_assign
id|carry
suffix:semicolon
id|result
op_assign
(paren
id|result
op_amp
l_int|0xffff
)paren
op_plus
(paren
id|result
op_rshift
l_int|16
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
op_amp
l_int|2
)paren
(brace
id|result
op_add_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|buff
suffix:semicolon
id|buff
op_add_assign
l_int|2
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|len
op_amp
l_int|1
)paren
id|result
op_add_assign
op_star
id|buff
suffix:semicolon
id|result
op_assign
id|foldto16
c_func
(paren
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|odd
)paren
id|result
op_assign
(paren
(paren
id|result
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
op_or
(paren
(paren
id|result
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;&bslash;nCHECKSUM is 0x%x&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* computes the checksum of a memory block at buff, length len,&n;   and adds in &quot;sum&quot; (32-bit)  */
DECL|function|csum_partial
r_int
r_int
id|csum_partial
c_func
(paren
r_const
r_int
r_char
op_star
id|buff
comma
r_int
id|len
comma
r_int
r_int
id|sum
)paren
(brace
r_int
r_int
r_int
id|result
op_assign
id|do_csum
c_func
(paren
id|buff
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* add in old sum, and carry.. */
id|result
op_add_assign
id|sum
suffix:semicolon
multiline_comment|/* 32+c bits -&gt; 32 bits */
id|result
op_assign
(paren
id|result
op_amp
l_int|0xffffffff
)paren
op_plus
(paren
id|result
op_rshift
l_int|32
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;csum_partial, buff %p len %d sum 0x%x result=0x%016Lx&bslash;n&quot;
comma
id|buff
comma
id|len
comma
id|sum
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* Copy while checksumming, otherwise like csum_partial.  */
r_int
r_int
DECL|function|csum_partial_copy
id|csum_partial_copy
c_func
(paren
r_const
r_char
op_star
id|src
comma
r_char
op_star
id|dst
comma
r_int
id|len
comma
r_int
r_int
id|sum
)paren
(brace
id|sum
op_assign
id|csum_partial
c_func
(paren
id|src
comma
id|len
comma
id|sum
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|dst
comma
id|src
comma
id|len
)paren
suffix:semicolon
r_return
id|sum
suffix:semicolon
)brace
multiline_comment|/* Copy from userspace and compute checksum.  If we catch an exception&n;   then zero the rest of the buffer.  */
r_int
r_int
DECL|function|csum_partial_copy_from_user
id|csum_partial_copy_from_user
c_func
(paren
r_const
r_char
op_star
id|src
comma
r_char
op_star
id|dst
comma
r_int
id|len
comma
r_int
r_int
id|sum
comma
r_int
op_star
id|err_ptr
)paren
(brace
r_int
id|missing
suffix:semicolon
id|pr_debug
(paren
l_string|&quot;csum_partial_copy_from_user src %p, dest %p, len %d, sum %08x, err_ptr %p&bslash;n&quot;
comma
id|src
comma
id|dst
comma
id|len
comma
id|sum
comma
id|err_ptr
)paren
suffix:semicolon
id|missing
op_assign
id|copy_from_user
c_func
(paren
id|dst
comma
id|src
comma
id|len
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;  access_ok %d&bslash;n&quot;
comma
id|__access_ok
c_func
(paren
(paren
r_int
r_int
)paren
id|src
comma
id|len
)paren
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;  missing %d&bslash;n&quot;
comma
id|missing
)paren
suffix:semicolon
r_if
c_cond
(paren
id|missing
)paren
(brace
id|memset
c_func
(paren
id|dst
op_plus
id|len
op_minus
id|missing
comma
l_int|0
comma
id|missing
)paren
suffix:semicolon
op_star
id|err_ptr
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
id|csum_partial
c_func
(paren
id|dst
comma
id|len
comma
id|sum
)paren
suffix:semicolon
)brace
multiline_comment|/* Copy to userspace and compute checksum.  */
r_int
r_int
DECL|function|csum_partial_copy_to_user
id|csum_partial_copy_to_user
c_func
(paren
r_const
r_char
op_star
id|src
comma
r_char
op_star
id|dst
comma
r_int
id|len
comma
r_int
r_int
id|sum
comma
r_int
op_star
id|err_ptr
)paren
(brace
id|sum
op_assign
id|csum_partial
c_func
(paren
id|src
comma
id|len
comma
id|sum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|dst
comma
id|src
comma
id|len
)paren
)paren
op_star
id|err_ptr
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_return
id|sum
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is a version of ip_compute_csum() optimized for IP headers,&n; *&t;which always checksum on 4 octet boundaries.&n; */
DECL|function|ip_fast_csum
r_int
r_int
id|ip_fast_csum
c_func
(paren
r_int
r_char
op_star
id|iph
comma
r_int
r_int
id|ihl
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;ip_fast_csum %p,%d&bslash;n&quot;
comma
id|iph
comma
id|ihl
)paren
suffix:semicolon
r_return
op_complement
id|do_csum
c_func
(paren
id|iph
comma
id|ihl
op_star
l_int|4
)paren
suffix:semicolon
)brace
DECL|function|csum_tcpudp_nofold
r_int
r_int
id|csum_tcpudp_nofold
c_func
(paren
r_int
r_int
id|saddr
comma
r_int
r_int
id|daddr
comma
r_int
r_int
id|len
comma
r_int
r_int
id|proto
comma
r_int
r_int
id|sum
)paren
(brace
r_int
r_int
r_int
id|result
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;ntohs(0x%x)=0x%x&bslash;n&quot;
comma
l_int|0xdead
comma
id|ntohs
c_func
(paren
l_int|0xdead
)paren
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;htons(0x%x)=0x%x&bslash;n&quot;
comma
l_int|0xdead
comma
id|htons
c_func
(paren
l_int|0xdead
)paren
)paren
suffix:semicolon
id|result
op_assign
(paren
(paren
r_int
r_int
r_int
)paren
id|saddr
op_plus
(paren
r_int
r_int
r_int
)paren
id|daddr
op_plus
(paren
r_int
r_int
r_int
)paren
id|sum
op_plus
(paren
(paren
r_int
r_int
r_int
)paren
id|ntohs
c_func
(paren
id|len
)paren
op_lshift
l_int|16
)paren
op_plus
(paren
(paren
r_int
r_int
r_int
)paren
id|proto
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
multiline_comment|/* Fold down to 32-bits so we don&squot;t loose in the typedef-less&n;&t;   network stack.  */
multiline_comment|/* 64 to 33 */
id|result
op_assign
(paren
id|result
op_amp
l_int|0xffffffff
)paren
op_plus
(paren
id|result
op_rshift
l_int|32
)paren
suffix:semicolon
multiline_comment|/* 33 to 32 */
id|result
op_assign
(paren
id|result
op_amp
l_int|0xffffffff
)paren
op_plus
(paren
id|result
op_rshift
l_int|32
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;%s saddr %x daddr %x len %x proto %x sum %x result %08Lx&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|saddr
comma
id|daddr
comma
id|len
comma
id|proto
comma
id|sum
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
singleline_comment|// Post SIM:
r_int
r_int
DECL|function|csum_partial_copy_nocheck
id|csum_partial_copy_nocheck
c_func
(paren
r_const
r_char
op_star
id|src
comma
r_char
op_star
id|dst
comma
r_int
id|len
comma
r_int
r_int
id|sum
)paren
(brace
singleline_comment|//  unsigned dummy;
id|pr_debug
c_func
(paren
l_string|&quot;csum_partial_copy_nocheck src %p dst %p len %d&bslash;n&quot;
comma
id|src
comma
id|dst
comma
id|len
)paren
suffix:semicolon
r_return
id|csum_partial_copy
c_func
(paren
id|src
comma
id|dst
comma
id|len
comma
id|sum
)paren
suffix:semicolon
)brace
eof
