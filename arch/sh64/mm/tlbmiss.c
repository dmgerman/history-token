multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * arch/sh64/mm/tlbmiss.c&n; *&n; * Original code from fault.c&n; * Copyright (C) 2000, 2001  Paolo Alberelli&n; *&n; * Fast PTE-&gt;TLB refill path&n; * Copyright (C) 2003 Richard.Curnow@superh.com&n; *&n; * IMPORTANT NOTES :&n; * The do_fast_page_fault function is called from a context in entry.S where very few registers&n; * have been saved.  In particular, the code in this file must be compiled not to use ANY&n; * caller-save regiseters that are not part of the restricted save set.  Also, it means that&n; * code in this file must not make calls to functions elsewhere in the kernel, or else the&n; * excepting context will see corruption in its caller-save registers.  Plus, the entry.S save&n; * area is non-reentrant, so this code has to run with SR.BL==1, i.e. no interrupts taken inside&n; * it and panic on any exception.&n; *&n; */
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/tlb.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/registers.h&gt;&t;&t;/* required by inline asm statements */
multiline_comment|/* Callable from fault.c, so not static */
DECL|function|__do_tlb_refill
r_inline
r_void
id|__do_tlb_refill
c_func
(paren
r_int
r_int
id|address
comma
r_int
r_int
r_int
id|is_text_not_data
comma
id|pte_t
op_star
id|pte
)paren
(brace
r_int
r_int
r_int
id|ptel
suffix:semicolon
r_int
r_int
r_int
id|pteh
op_assign
l_int|0
suffix:semicolon
r_struct
id|tlb_info
op_star
id|tlbp
suffix:semicolon
r_int
r_int
r_int
id|next
suffix:semicolon
multiline_comment|/* Get PTEL first */
id|ptel
op_assign
id|pte_val
c_func
(paren
op_star
id|pte
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set PTEH register&n;&t; */
id|pteh
op_assign
id|address
op_amp
id|MMU_VPN_MASK
suffix:semicolon
multiline_comment|/* Sign extend based on neff. */
macro_line|#if (NEFF == 32)
multiline_comment|/* Faster sign extension */
id|pteh
op_assign
(paren
r_int
r_int
r_int
)paren
(paren
r_int
r_int
r_int
)paren
(paren
r_int
r_int
)paren
id|pteh
suffix:semicolon
macro_line|#else
multiline_comment|/* General case */
id|pteh
op_assign
(paren
id|pteh
op_amp
id|NEFF_SIGN
)paren
ques
c_cond
(paren
id|pteh
op_or
id|NEFF_MASK
)paren
suffix:colon
id|pteh
suffix:semicolon
macro_line|#endif
multiline_comment|/* Set the ASID. */
id|pteh
op_or_assign
id|get_asid
c_func
(paren
)paren
op_lshift
id|PTEH_ASID_SHIFT
suffix:semicolon
id|pteh
op_or_assign
id|PTEH_VALID
suffix:semicolon
multiline_comment|/* Set PTEL register, set_pte has performed the sign extension */
id|ptel
op_and_assign
id|_PAGE_FLAGS_HARDWARE_MASK
suffix:semicolon
multiline_comment|/* drop software flags */
id|tlbp
op_assign
id|is_text_not_data
ques
c_cond
op_amp
(paren
id|cpu_data-&gt;itlb
)paren
suffix:colon
op_amp
(paren
id|cpu_data-&gt;dtlb
)paren
suffix:semicolon
id|next
op_assign
id|tlbp-&gt;next
suffix:semicolon
id|__flush_tlb_slot
c_func
(paren
id|next
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;putcfg %0,1,%2&bslash;n&bslash;n&bslash;t&quot;
l_string|&quot;putcfg %0,0,%1&bslash;n&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|next
)paren
comma
l_string|&quot;r&quot;
(paren
id|pteh
)paren
comma
l_string|&quot;r&quot;
(paren
id|ptel
)paren
)paren
suffix:semicolon
id|next
op_add_assign
id|TLB_STEP
suffix:semicolon
r_if
c_cond
(paren
id|next
OG
id|tlbp-&gt;last
)paren
id|next
op_assign
id|tlbp-&gt;first
suffix:semicolon
id|tlbp-&gt;next
op_assign
id|next
suffix:semicolon
)brace
DECL|function|handle_vmalloc_fault
r_static
r_int
id|handle_vmalloc_fault
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|protection_flags
comma
r_int
r_int
r_int
id|textaccess
comma
r_int
r_int
id|address
)paren
(brace
id|pgd_t
op_star
id|dir
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
r_static
id|pte_t
op_star
id|pte
suffix:semicolon
id|pte_t
id|entry
suffix:semicolon
id|dir
op_assign
id|pgd_offset_k
c_func
(paren
id|address
)paren
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|dir
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pmd_bad
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|pmd_clear
c_func
(paren
id|pmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|pte
op_assign
id|pte_offset_kernel
c_func
(paren
id|pmd
comma
id|address
)paren
suffix:semicolon
id|entry
op_assign
op_star
id|pte
suffix:semicolon
r_if
c_cond
(paren
id|pte_none
c_func
(paren
id|entry
)paren
op_logical_or
op_logical_neg
id|pte_present
c_func
(paren
id|entry
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|pte_val
c_func
(paren
id|entry
)paren
op_amp
id|protection_flags
)paren
op_ne
id|protection_flags
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|__do_tlb_refill
c_func
(paren
id|address
comma
id|textaccess
comma
id|pte
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|handle_tlbmiss
r_static
r_int
id|handle_tlbmiss
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
r_int
id|protection_flags
comma
r_int
r_int
r_int
id|textaccess
comma
r_int
r_int
id|address
)paren
(brace
id|pgd_t
op_star
id|dir
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
id|pte_t
id|entry
suffix:semicolon
multiline_comment|/* NB. The PGD currently only contains a single entry - there is no&n;&t;   page table tree stored for the top half of the address space since&n;&t;   virtual pages in that region should never be mapped in user mode.&n;&t;   (In kernel mode, the only things in that region are the 512Mb super&n;&t;   page (locked in), and vmalloc (modules) +  I/O device pages (handled&n;&t;   by handle_vmalloc_fault), so no PGD for the upper half is required&n;&t;   by kernel mode either).&n;&n;&t;   See how mm-&gt;pgd is allocated and initialised in pgd_alloc to see why&n;&t;   the next test is necessary.  - RPC */
r_if
c_cond
(paren
id|address
op_ge
(paren
r_int
r_int
)paren
id|TASK_SIZE
)paren
(brace
multiline_comment|/* upper half - never has page table entries. */
r_return
l_int|0
suffix:semicolon
)brace
id|dir
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pgd_none
c_func
(paren
op_star
id|dir
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pgd_present
c_func
(paren
op_star
id|dir
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|dir
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pmd_present
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|pte
op_assign
id|pte_offset_kernel
c_func
(paren
id|pmd
comma
id|address
)paren
suffix:semicolon
id|entry
op_assign
op_star
id|pte
suffix:semicolon
r_if
c_cond
(paren
id|pte_none
c_func
(paren
id|entry
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pte_present
c_func
(paren
id|entry
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If the page doesn&squot;t have sufficient protection bits set to service the&n;&t;   kind of fault being handled, there&squot;s not much point doing the TLB refill.&n;&t;   Punt the fault to the general handler. */
r_if
c_cond
(paren
(paren
id|pte_val
c_func
(paren
id|entry
)paren
op_amp
id|protection_flags
)paren
op_ne
id|protection_flags
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|__do_tlb_refill
c_func
(paren
id|address
comma
id|textaccess
comma
id|pte
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Put all this information into one structure so that everything is just arithmetic&n;   relative to a single base address.  This reduces the number of movi/shori pairs needed&n;   just to load addresses of static data. */
DECL|struct|expevt_lookup
r_struct
id|expevt_lookup
(brace
DECL|member|protection_flags
r_int
r_int
id|protection_flags
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|is_text_access
r_int
r_char
id|is_text_access
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|is_write_access
r_int
r_char
id|is_write_access
(braket
l_int|8
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|PRU
mdefine_line|#define PRU (1&lt;&lt;9)
DECL|macro|PRW
mdefine_line|#define PRW (1&lt;&lt;8)
DECL|macro|PRX
mdefine_line|#define PRX (1&lt;&lt;7)
DECL|macro|PRR
mdefine_line|#define PRR (1&lt;&lt;6)
DECL|macro|DIRTY
mdefine_line|#define DIRTY (_PAGE_DIRTY | _PAGE_ACCESSED)
DECL|macro|YOUNG
mdefine_line|#define YOUNG (_PAGE_ACCESSED)
multiline_comment|/* Sized as 8 rather than 4 to allow checking the PTE&squot;s PRU bit against whether&n;   the fault happened in user mode or privileged mode. */
DECL|variable|expevt_lookup_table
r_static
r_struct
id|expevt_lookup
id|expevt_lookup_table
op_assign
(brace
dot
id|protection_flags
op_assign
(brace
id|PRX
comma
id|PRX
comma
l_int|0
comma
l_int|0
comma
id|PRR
comma
id|PRR
comma
id|PRW
comma
id|PRW
)brace
comma
dot
id|is_text_access
op_assign
(brace
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/*&n;   This routine handles page faults that can be serviced just by refilling a&n;   TLB entry from an existing page table entry.  (This case represents a very&n;   large majority of page faults.) Return 1 if the fault was successfully&n;   handled.  Return 0 if the fault could not be handled.  (This leads into the&n;   general fault handling in fault.c which deals with mapping file-backed&n;   pages, stack growth, segmentation faults, swapping etc etc)&n; */
DECL|function|do_fast_page_fault
id|asmlinkage
r_int
id|do_fast_page_fault
c_func
(paren
r_int
r_int
r_int
id|ssr_md
comma
r_int
r_int
r_int
id|expevt
comma
r_int
r_int
id|address
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
suffix:semicolon
r_int
r_int
r_int
id|textaccess
suffix:semicolon
r_int
r_int
r_int
id|protection_flags
suffix:semicolon
r_int
r_int
r_int
id|index
suffix:semicolon
r_int
r_int
r_int
id|expevt4
suffix:semicolon
multiline_comment|/* The next few lines implement a way of hashing EXPEVT into a small array index&n;&t;   which can be used to lookup parameters specific to the type of TLBMISS being&n;&t;   handled.  Note:&n;&t;   ITLBMISS has EXPEVT==0xa40&n;&t;   RTLBMISS has EXPEVT==0x040&n;&t;   WTLBMISS has EXPEVT==0x060&n;&t;*/
id|expevt4
op_assign
(paren
id|expevt
op_rshift
l_int|4
)paren
suffix:semicolon
multiline_comment|/* TODO : xor ssr_md into this expression too.  Then we can check that PRU is set&n;&t;   when it needs to be. */
id|index
op_assign
id|expevt4
op_xor
(paren
id|expevt4
op_rshift
l_int|5
)paren
suffix:semicolon
id|index
op_and_assign
l_int|7
suffix:semicolon
id|protection_flags
op_assign
id|expevt_lookup_table.protection_flags
(braket
id|index
)braket
suffix:semicolon
id|textaccess
op_assign
id|expevt_lookup_table.is_text_access
(braket
id|index
)braket
suffix:semicolon
macro_line|#ifdef CONFIG_SH64_PROC_TLB
op_increment
id|calls_to_do_fast_page_fault
suffix:semicolon
macro_line|#endif
multiline_comment|/* SIM&n;&t; * Note this is now called with interrupts still disabled&n;&t; * This is to cope with being called for a missing IO port&n;&t; * address with interupts disabled. This should be fixed as&n;&t; * soon as we have a better &squot;fast path&squot; miss handler.&n;&t; *&n;&t; * Plus take care how you try and debug this stuff.&n;&t; * For example, writing debug data to a port which you&n;&t; * have just faulted on is not going to work.&n;&t; */
id|tsk
op_assign
id|current
suffix:semicolon
id|mm
op_assign
id|tsk-&gt;mm
suffix:semicolon
r_if
c_cond
(paren
(paren
id|address
op_ge
id|VMALLOC_START
op_logical_and
id|address
OL
id|VMALLOC_END
)paren
op_logical_or
(paren
id|address
op_ge
id|IOBASE_VADDR
op_logical_and
id|address
OL
id|IOBASE_END
)paren
)paren
(brace
r_if
c_cond
(paren
id|ssr_md
)paren
(brace
multiline_comment|/* Process-contexts can never have this address range mapped */
r_if
c_cond
(paren
id|handle_vmalloc_fault
c_func
(paren
id|mm
comma
id|protection_flags
comma
id|textaccess
comma
id|address
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|in_interrupt
c_func
(paren
)paren
op_logical_and
id|mm
)paren
(brace
r_if
c_cond
(paren
id|handle_tlbmiss
c_func
(paren
id|mm
comma
id|protection_flags
comma
id|textaccess
comma
id|address
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
