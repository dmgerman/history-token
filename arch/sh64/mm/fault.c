multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * arch/sh64/mm/fault.c&n; *&n; * Copyright (C) 2000, 2001  Paolo Alberelli&n; * Copyright (C) 2003  Richard Curnow (/proc/tlb, bug fixes)&n; * Copyright (C) 2003  Paul Mundt&n; *&n; */
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/rwsem.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/tlb.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/registers.h&gt;&t;&t;/* required by inline asm statements */
macro_line|#if defined(CONFIG_SH64_PROC_TLB)
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
multiline_comment|/* Count numbers of tlb refills in each region */
DECL|variable|calls_to_update_mmu_cache
r_static
r_int
r_int
r_int
id|calls_to_update_mmu_cache
op_assign
l_int|0ULL
suffix:semicolon
DECL|variable|calls_to_flush_tlb_page
r_static
r_int
r_int
r_int
id|calls_to_flush_tlb_page
op_assign
l_int|0ULL
suffix:semicolon
DECL|variable|calls_to_flush_tlb_range
r_static
r_int
r_int
r_int
id|calls_to_flush_tlb_range
op_assign
l_int|0ULL
suffix:semicolon
DECL|variable|calls_to_flush_tlb_mm
r_static
r_int
r_int
r_int
id|calls_to_flush_tlb_mm
op_assign
l_int|0ULL
suffix:semicolon
DECL|variable|calls_to_flush_tlb_all
r_static
r_int
r_int
r_int
id|calls_to_flush_tlb_all
op_assign
l_int|0ULL
suffix:semicolon
DECL|variable|calls_to_do_slow_page_fault
r_int
r_int
r_int
id|calls_to_do_slow_page_fault
op_assign
l_int|0ULL
suffix:semicolon
DECL|variable|calls_to_do_fast_page_fault
r_int
r_int
r_int
id|calls_to_do_fast_page_fault
op_assign
l_int|0ULL
suffix:semicolon
multiline_comment|/* Count size of ranges for flush_tlb_range */
DECL|variable|flush_tlb_range_1
r_static
r_int
r_int
r_int
id|flush_tlb_range_1
op_assign
l_int|0ULL
suffix:semicolon
DECL|variable|flush_tlb_range_2
r_static
r_int
r_int
r_int
id|flush_tlb_range_2
op_assign
l_int|0ULL
suffix:semicolon
DECL|variable|flush_tlb_range_3_4
r_static
r_int
r_int
r_int
id|flush_tlb_range_3_4
op_assign
l_int|0ULL
suffix:semicolon
DECL|variable|flush_tlb_range_5_7
r_static
r_int
r_int
r_int
id|flush_tlb_range_5_7
op_assign
l_int|0ULL
suffix:semicolon
DECL|variable|flush_tlb_range_8_11
r_static
r_int
r_int
r_int
id|flush_tlb_range_8_11
op_assign
l_int|0ULL
suffix:semicolon
DECL|variable|flush_tlb_range_12_15
r_static
r_int
r_int
r_int
id|flush_tlb_range_12_15
op_assign
l_int|0ULL
suffix:semicolon
DECL|variable|flush_tlb_range_16_up
r_static
r_int
r_int
r_int
id|flush_tlb_range_16_up
op_assign
l_int|0ULL
suffix:semicolon
DECL|variable|page_not_present
r_static
r_int
r_int
r_int
id|page_not_present
op_assign
l_int|0ULL
suffix:semicolon
macro_line|#endif
r_extern
r_void
id|die
c_func
(paren
r_const
r_char
op_star
comma
r_struct
id|pt_regs
op_star
comma
r_int
)paren
suffix:semicolon
DECL|macro|PFLAG
mdefine_line|#define PFLAG(val,flag)   (( (val) &amp; (flag) ) ? #flag : &quot;&quot; )
DECL|macro|PPROT
mdefine_line|#define PPROT(flag) PFLAG(pgprot_val(prot),flag)
DECL|function|print_prots
r_static
r_inline
r_void
id|print_prots
c_func
(paren
id|pgprot_t
id|prot
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;prot is 0x%08lx&bslash;n&quot;
comma
id|pgprot_val
c_func
(paren
id|prot
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s %s %s %s %s&bslash;n&quot;
comma
id|PPROT
c_func
(paren
id|_PAGE_SHARED
)paren
comma
id|PPROT
c_func
(paren
id|_PAGE_READ
)paren
comma
id|PPROT
c_func
(paren
id|_PAGE_EXECUTE
)paren
comma
id|PPROT
c_func
(paren
id|_PAGE_WRITE
)paren
comma
id|PPROT
c_func
(paren
id|_PAGE_USER
)paren
)paren
suffix:semicolon
)brace
DECL|function|print_vma
r_static
r_inline
r_void
id|print_vma
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;vma start 0x%08lx&bslash;n&quot;
comma
id|vma-&gt;vm_start
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;vma end   0x%08lx&bslash;n&quot;
comma
id|vma-&gt;vm_end
)paren
suffix:semicolon
id|print_prots
c_func
(paren
id|vma-&gt;vm_page_prot
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;vm_flags 0x%08lx&bslash;n&quot;
comma
id|vma-&gt;vm_flags
)paren
suffix:semicolon
)brace
DECL|function|print_task
r_static
r_inline
r_void
id|print_task
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Task pid %d&bslash;n&quot;
comma
id|tsk-&gt;pid
)paren
suffix:semicolon
)brace
DECL|function|lookup_pte
r_static
id|pte_t
op_star
id|lookup_pte
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|address
)paren
(brace
id|pgd_t
op_star
id|dir
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
id|pte_t
id|entry
suffix:semicolon
id|dir
op_assign
id|pgd_offset
c_func
(paren
id|mm
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pgd_none
c_func
(paren
op_star
id|dir
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|dir
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|pte
op_assign
id|pte_offset_kernel
c_func
(paren
id|pmd
comma
id|address
)paren
suffix:semicolon
id|entry
op_assign
op_star
id|pte
suffix:semicolon
r_if
c_cond
(paren
id|pte_none
c_func
(paren
id|entry
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pte_present
c_func
(paren
id|entry
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|pte
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine handles page faults.  It determines the address,&n; * and the problem, and then passes it off to one of the appropriate&n; * routines.&n; */
DECL|function|do_page_fault
id|asmlinkage
r_void
id|do_page_fault
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|writeaccess
comma
r_int
r_int
id|textaccess
comma
r_int
r_int
id|address
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_const
r_struct
id|exception_table_entry
op_star
id|fixup
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
macro_line|#if defined(CONFIG_SH64_PROC_TLB)
op_increment
id|calls_to_do_slow_page_fault
suffix:semicolon
macro_line|#endif
multiline_comment|/* SIM&n;&t; * Note this is now called with interrupts still disabled&n;&t; * This is to cope with being called for a missing IO port&n;&t; * address with interupts disabled. This should be fixed as&n;&t; * soon as we have a better &squot;fast path&squot; miss handler.&n;&t; *&n;&t; * Plus take care how you try and debug this stuff.&n;&t; * For example, writing debug data to a port which you&n;&t; * have just faulted on is not going to work.&n;&t; */
id|tsk
op_assign
id|current
suffix:semicolon
id|mm
op_assign
id|tsk-&gt;mm
suffix:semicolon
multiline_comment|/* Not an IO address, so reenable interrupts */
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re in an interrupt or have no user&n;&t; * context, we must not take the fault..&n;&t; */
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
op_logical_or
op_logical_neg
id|mm
)paren
r_goto
id|no_context
suffix:semicolon
multiline_comment|/* TLB misses upon some cache flushes get done under cli() */
id|down_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
id|vma
op_assign
id|find_vma
c_func
(paren
id|mm
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vma
)paren
(brace
macro_line|#ifdef DEBUG_FAULT
id|print_task
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s:%d fault, address is 0x%08x PC %016Lx textaccess %d writeaccess %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|__LINE__
comma
id|address
comma
id|regs-&gt;pc
comma
id|textaccess
comma
id|writeaccess
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|bad_area
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vma-&gt;vm_start
op_le
id|address
)paren
(brace
r_goto
id|good_area
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_GROWSDOWN
)paren
)paren
(brace
macro_line|#ifdef DEBUG_FAULT
id|print_task
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s:%d fault, address is 0x%08x PC %016Lx textaccess %d writeaccess %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|__LINE__
comma
id|address
comma
id|regs-&gt;pc
comma
id|textaccess
comma
id|writeaccess
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
id|print_vma
c_func
(paren
id|vma
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|bad_area
suffix:semicolon
)brace
r_if
c_cond
(paren
id|expand_stack
c_func
(paren
id|vma
comma
id|address
)paren
)paren
(brace
macro_line|#ifdef DEBUG_FAULT
id|print_task
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s:%d fault, address is 0x%08x PC %016Lx textaccess %d writeaccess %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|__LINE__
comma
id|address
comma
id|regs-&gt;pc
comma
id|textaccess
comma
id|writeaccess
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|bad_area
suffix:semicolon
)brace
multiline_comment|/*&n; * Ok, we have a good vm_area for this memory access, so&n; * we can handle it..&n; */
id|good_area
suffix:colon
r_if
c_cond
(paren
id|writeaccess
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_WRITE
)paren
)paren
r_goto
id|bad_area
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|vma-&gt;vm_flags
op_amp
(paren
id|VM_READ
op_or
id|VM_EXEC
)paren
)paren
)paren
r_goto
id|bad_area
suffix:semicolon
)brace
r_if
c_cond
(paren
id|textaccess
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
)paren
)paren
r_goto
id|bad_area
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If for any reason at all we couldn&squot;t handle the fault,&n;&t; * make sure we exit gracefully rather than endlessly redo&n;&t; * the fault.&n;&t; */
id|survive
suffix:colon
r_switch
c_cond
(paren
id|handle_mm_fault
c_func
(paren
id|mm
comma
id|vma
comma
id|address
comma
id|writeaccess
)paren
)paren
(brace
r_case
l_int|1
suffix:colon
id|tsk-&gt;min_flt
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|tsk-&gt;maj_flt
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_goto
id|do_sigbus
suffix:semicolon
r_default
suffix:colon
r_goto
id|out_of_memory
suffix:semicolon
)brace
multiline_comment|/* If we get here, the page fault has been handled.  Do the TLB refill&n;&t;   now from the newly-setup PTE, to avoid having to fault again right&n;&t;   away on the same instruction. */
id|pte
op_assign
id|lookup_pte
(paren
id|mm
comma
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pte
)paren
(brace
multiline_comment|/* From empirical evidence, we can get here, due to&n;&t;&t;   !pte_present(pte).  (e.g. if a swap-in occurs, and the page&n;&t;&t;   is swapped back out again before the process that wanted it&n;&t;&t;   gets rescheduled?) */
r_goto
id|no_pte
suffix:semicolon
)brace
id|__do_tlb_refill
c_func
(paren
id|address
comma
id|textaccess
comma
id|pte
)paren
suffix:semicolon
id|no_pte
suffix:colon
id|up_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/*&n; * Something tried to access memory that isn&squot;t in our memory map..&n; * Fix it, but check if it&squot;s kernel or user first..&n; */
id|bad_area
suffix:colon
macro_line|#ifdef DEBUG_FAULT
id|printk
c_func
(paren
l_string|&quot;fault:bad area&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|up_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;user mode bad_area address=%08lx pid=%d (%s) pc=%08lx opcode=%08lx&bslash;n&quot;
comma
id|address
comma
id|current-&gt;pid
comma
id|current-&gt;comm
comma
(paren
r_int
r_int
)paren
id|regs-&gt;pc
comma
op_star
(paren
r_int
r_int
op_star
)paren
(paren
id|u32
)paren
(paren
id|regs-&gt;pc
op_amp
op_complement
l_int|3
)paren
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tsk-&gt;pid
op_eq
l_int|1
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;INIT had user mode bad_area&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|tsk-&gt;thread.address
op_assign
id|address
suffix:semicolon
id|tsk-&gt;thread.error_code
op_assign
id|writeaccess
suffix:semicolon
id|force_sig
c_func
(paren
id|SIGSEGV
comma
id|tsk
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|no_context
suffix:colon
macro_line|#ifdef DEBUG_FAULT
id|printk
c_func
(paren
l_string|&quot;fault:No context&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Are we prepared to handle this kernel fault?  */
id|fixup
op_assign
id|search_exception_tables
c_func
(paren
id|regs-&gt;pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fixup
)paren
(brace
id|regs-&gt;pc
op_assign
id|fixup-&gt;fixup
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Oops. The kernel tried to access some bad page. We&squot;ll have to&n; * terminate things with extreme prejudice.&n; *&n; */
r_if
c_cond
(paren
id|address
OL
id|PAGE_SIZE
)paren
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;Unable to handle kernel NULL pointer dereference&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;Unable to handle kernel paging request&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; at virtual address %08lx&bslash;n&quot;
comma
id|address
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;pc = %08Lx%08Lx&bslash;n&quot;
comma
id|regs-&gt;pc
op_rshift
l_int|32
comma
id|regs-&gt;pc
op_amp
l_int|0xffffffff
)paren
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;Oops&quot;
comma
id|regs
comma
id|writeaccess
)paren
suffix:semicolon
id|do_exit
c_func
(paren
id|SIGKILL
)paren
suffix:semicolon
multiline_comment|/*&n; * We ran out of memory, or some other thing happened to us that made&n; * us unable to handle the page fault gracefully.&n; */
id|out_of_memory
suffix:colon
r_if
c_cond
(paren
id|current-&gt;pid
op_eq
l_int|1
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;INIT out of memory&bslash;n&quot;
)paren
suffix:semicolon
id|yield
c_func
(paren
)paren
suffix:semicolon
r_goto
id|survive
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;fault:Out of memory&bslash;n&quot;
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;pid
op_eq
l_int|1
)paren
(brace
id|yield
c_func
(paren
)paren
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
r_goto
id|survive
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;VM: killing process %s&bslash;n&quot;
comma
id|tsk-&gt;comm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
id|do_exit
c_func
(paren
id|SIGKILL
)paren
suffix:semicolon
r_goto
id|no_context
suffix:semicolon
id|do_sigbus
suffix:colon
id|printk
c_func
(paren
l_string|&quot;fault:Do sigbus&bslash;n&quot;
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|mm-&gt;mmap_sem
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Send a sigbus, regardless of whether we were in kernel&n;&t; * or user mode.&n;&t; */
id|tsk-&gt;thread.address
op_assign
id|address
suffix:semicolon
id|tsk-&gt;thread.error_code
op_assign
id|writeaccess
suffix:semicolon
id|tsk-&gt;thread.trap_no
op_assign
l_int|14
suffix:semicolon
id|force_sig
c_func
(paren
id|SIGBUS
comma
id|tsk
)paren
suffix:semicolon
multiline_comment|/* Kernel mode? Handle exceptions or die */
r_if
c_cond
(paren
op_logical_neg
id|user_mode
c_func
(paren
id|regs
)paren
)paren
r_goto
id|no_context
suffix:semicolon
)brace
r_void
id|flush_tlb_all
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|update_mmu_cache
r_void
id|update_mmu_cache
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
id|pte_t
id|pte
)paren
(brace
macro_line|#if defined(CONFIG_SH64_PROC_TLB)
op_increment
id|calls_to_update_mmu_cache
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * This appears to get called once for every pte entry that gets&n;&t; * established =&gt; I don&squot;t think it&squot;s efficient to try refilling the&n;&t; * TLBs with the pages - some may not get accessed even.  Also, for&n;&t; * executable pages, it is impossible to determine reliably here which&n;&t; * TLB they should be mapped into (or both even).&n;&t; *&n;&t; * So, just do nothing here and handle faults on demand.  In the&n;&t; * TLBMISS handling case, the refill is now done anyway after the pte&n;&t; * has been fixed up, so that deals with most useful cases.&n;&t; */
)brace
DECL|function|__flush_tlb_page
r_static
r_void
id|__flush_tlb_page
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|page
)paren
(brace
r_int
r_int
r_int
id|match
comma
id|pteh
op_assign
l_int|0
comma
id|lpage
suffix:semicolon
r_int
r_int
id|tlb
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
suffix:semicolon
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
r_if
c_cond
(paren
id|mm-&gt;context
op_eq
id|NO_CONTEXT
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Sign-extend based on neff.&n;&t; */
id|lpage
op_assign
(paren
id|page
op_amp
id|NEFF_SIGN
)paren
ques
c_cond
(paren
id|page
op_or
id|NEFF_MASK
)paren
suffix:colon
id|page
suffix:semicolon
id|match
op_assign
(paren
(paren
id|mm-&gt;context
op_amp
id|MMU_CONTEXT_ASID_MASK
)paren
op_lshift
id|PTEH_ASID_SHIFT
)paren
op_or
id|PTEH_VALID
suffix:semicolon
id|match
op_or_assign
id|lpage
suffix:semicolon
multiline_comment|/* Do ITLB : don&squot;t bother for pages in non-exectutable VMAs */
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
)paren
(brace
id|for_each_itlb_entry
c_func
(paren
id|tlb
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;getcfg&t;%1, 0, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pteh
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|tlb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pteh
op_eq
id|match
)paren
(brace
id|__flush_tlb_slot
c_func
(paren
id|tlb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Do DTLB : any page could potentially be in here. */
id|for_each_dtlb_entry
c_func
(paren
id|tlb
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;getcfg&t;%1, 0, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pteh
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|tlb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pteh
op_eq
id|match
)paren
(brace
id|__flush_tlb_slot
c_func
(paren
id|tlb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
DECL|function|flush_tlb_page
r_void
id|flush_tlb_page
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|page
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if defined(CONFIG_SH64_PROC_TLB)
op_increment
id|calls_to_flush_tlb_page
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|vma-&gt;vm_mm
)paren
(brace
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__flush_tlb_page
c_func
(paren
id|vma
comma
id|page
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
DECL|function|flush_tlb_range
r_void
id|flush_tlb_range
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
r_int
id|match
comma
id|pteh
op_assign
l_int|0
comma
id|pteh_epn
comma
id|pteh_low
suffix:semicolon
r_int
r_int
id|tlb
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
suffix:semicolon
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
macro_line|#if defined(CONFIG_SH64_PROC_TLB)
op_increment
id|calls_to_flush_tlb_range
suffix:semicolon
(brace
r_int
r_int
id|size
op_assign
(paren
id|end
op_minus
l_int|1
)paren
op_minus
id|start
suffix:semicolon
id|size
op_rshift_assign
l_int|12
suffix:semicolon
multiline_comment|/* divide by PAGE_SIZE */
id|size
op_increment
suffix:semicolon
multiline_comment|/* end=start+4096 =&gt; 1 page */
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
l_int|1
suffix:colon
id|flush_tlb_range_1
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|flush_tlb_range_2
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
dot
dot
dot
l_int|4
suffix:colon
id|flush_tlb_range_3_4
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
dot
dot
dot
l_int|7
suffix:colon
id|flush_tlb_range_5_7
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
dot
dot
dot
l_int|11
suffix:colon
id|flush_tlb_range_8_11
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|12
dot
dot
dot
l_int|15
suffix:colon
id|flush_tlb_range_12_15
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|flush_tlb_range_16_up
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|mm-&gt;context
op_eq
id|NO_CONTEXT
)paren
r_return
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|start
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|end
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|match
op_assign
(paren
(paren
id|mm-&gt;context
op_amp
id|MMU_CONTEXT_ASID_MASK
)paren
op_lshift
id|PTEH_ASID_SHIFT
)paren
op_or
id|PTEH_VALID
suffix:semicolon
multiline_comment|/* Flush ITLB */
id|for_each_itlb_entry
c_func
(paren
id|tlb
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;getcfg&t;%1, 0, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pteh
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|tlb
)paren
)paren
suffix:semicolon
id|pteh_epn
op_assign
id|pteh
op_amp
id|PAGE_MASK
suffix:semicolon
id|pteh_low
op_assign
id|pteh
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|pteh_low
op_eq
id|match
op_logical_and
id|pteh_epn
op_ge
id|start
op_logical_and
id|pteh_epn
op_le
id|end
)paren
id|__flush_tlb_slot
c_func
(paren
id|tlb
)paren
suffix:semicolon
)brace
multiline_comment|/* Flush DTLB */
id|for_each_dtlb_entry
c_func
(paren
id|tlb
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;getcfg&t;%1, 0, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|pteh
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|tlb
)paren
)paren
suffix:semicolon
id|pteh_epn
op_assign
id|pteh
op_amp
id|PAGE_MASK
suffix:semicolon
id|pteh_low
op_assign
id|pteh
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|pteh_low
op_eq
id|match
op_logical_and
id|pteh_epn
op_ge
id|start
op_logical_and
id|pteh_epn
op_le
id|end
)paren
id|__flush_tlb_slot
c_func
(paren
id|tlb
)paren
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|flush_tlb_mm
r_void
id|flush_tlb_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if defined(CONFIG_SH64_PROC_TLB)
op_increment
id|calls_to_flush_tlb_mm
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|mm-&gt;context
op_eq
id|NO_CONTEXT
)paren
r_return
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|mm-&gt;context
op_assign
id|NO_CONTEXT
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_eq
id|current-&gt;mm
)paren
(brace
id|activate_context
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|flush_tlb_all
r_void
id|flush_tlb_all
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Invalidate all, including shared pages, excluding fixed TLBs */
r_int
r_int
id|flags
comma
id|tlb
suffix:semicolon
macro_line|#if defined(CONFIG_SH64_PROC_TLB)
op_increment
id|calls_to_flush_tlb_all
suffix:semicolon
macro_line|#endif
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Flush each ITLB entry */
id|for_each_itlb_entry
c_func
(paren
id|tlb
)paren
(brace
id|__flush_tlb_slot
c_func
(paren
id|tlb
)paren
suffix:semicolon
)brace
multiline_comment|/* Flush each DTLB entry */
id|for_each_dtlb_entry
c_func
(paren
id|tlb
)paren
(brace
id|__flush_tlb_slot
c_func
(paren
id|tlb
)paren
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|flush_tlb_kernel_range
r_void
id|flush_tlb_kernel_range
c_func
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
multiline_comment|/* FIXME: Optimize this later.. */
id|flush_tlb_all
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_SH64_PROC_TLB)
multiline_comment|/* Procfs interface to read the performance information */
r_static
r_int
DECL|function|tlb_proc_info
id|tlb_proc_info
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|fpos
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;do_fast_page_fault   called %12lld times&bslash;n&quot;
comma
id|calls_to_do_fast_page_fault
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;do_slow_page_fault   called %12lld times&bslash;n&quot;
comma
id|calls_to_do_slow_page_fault
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;update_mmu_cache     called %12lld times&bslash;n&quot;
comma
id|calls_to_update_mmu_cache
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;flush_tlb_page       called %12lld times&bslash;n&quot;
comma
id|calls_to_flush_tlb_page
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;flush_tlb_range      called %12lld times&bslash;n&quot;
comma
id|calls_to_flush_tlb_range
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;flush_tlb_mm         called %12lld times&bslash;n&quot;
comma
id|calls_to_flush_tlb_mm
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;flush_tlb_all        called %12lld times&bslash;n&quot;
comma
id|calls_to_flush_tlb_all
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;flush_tlb_range_sizes&bslash;n&quot;
l_string|&quot; 1      : %12lld&bslash;n&quot;
l_string|&quot; 2      : %12lld&bslash;n&quot;
l_string|&quot; 3 -  4 : %12lld&bslash;n&quot;
l_string|&quot; 5 -  7 : %12lld&bslash;n&quot;
l_string|&quot; 8 - 11 : %12lld&bslash;n&quot;
l_string|&quot;12 - 15 : %12lld&bslash;n&quot;
l_string|&quot;16+     : %12lld&bslash;n&quot;
comma
id|flush_tlb_range_1
comma
id|flush_tlb_range_2
comma
id|flush_tlb_range_3_4
comma
id|flush_tlb_range_5_7
comma
id|flush_tlb_range_8_11
comma
id|flush_tlb_range_12_15
comma
id|flush_tlb_range_16_up
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;page not present           %12lld times&bslash;n&quot;
comma
id|page_not_present
)paren
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|register_proc_tlb
r_static
r_int
id|__init
id|register_proc_tlb
c_func
(paren
r_void
)paren
(brace
id|create_proc_read_entry
c_func
(paren
l_string|&quot;tlb&quot;
comma
l_int|0
comma
l_int|NULL
comma
id|tlb_proc_info
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|register_proc_tlb
id|__initcall
c_func
(paren
id|register_proc_tlb
)paren
suffix:semicolon
macro_line|#endif
eof
