multiline_comment|/*&n; * cp1emu.c: a MIPS coprocessor 1 (fpu) instruction emulator&n; * &n; * MIPS floating point support&n; * Copyright (C) 1994-2000 Algorithmics Ltd.  All rights reserved.&n; * http://www.algor.co.uk&n; *&n; * ########################################################################&n; *&n; *  This program is free software; you can distribute it and/or modify it&n; *  under the terms of the GNU General Public License (Version 2) as&n; *  published by the Free Software Foundation.&n; *&n; *  This program is distributed in the hope it will be useful, but WITHOUT&n; *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or&n; *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License&n; *  for more details.&n; *&n; *  You should have received a copy of the GNU General Public License along&n; *  with this program; if not, write to the Free Software Foundation, Inc.,&n; *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * ########################################################################&n; *&n; * A complete emulator for MIPS coprocessor 1 instructions.  This is&n; * required for #float(switch) or #float(trap), where it catches all&n; * COP1 instructions via the &quot;CoProcessor Unusable&quot; exception.  &n; *&n; * More surprisingly it is also required for #float(ieee), to help out&n; * the hardware fpu at the boundaries of the IEEE-754 representation&n; * (denormalised values, infinities, underflow, etc).  It is made&n; * quite nasty because emulation of some non-COP1 instructions is&n; * required, e.g. in branch delay slots.&n; * &n; * Notes: &n; *  1) the IEEE754 library (-le) performs the actual arithmetic;&n; *  2) if you know that you won&squot;t have an fpu, then you&squot;ll get much &n; *     better performance by compiling with -msoft-float!  */
multiline_comment|/**************************************************************************&n; *  Nov 7, 2000&n; *  Massive changes to integrate with Linux kernel.&n; *&n; *  Replace use of kernel data area with use of user stack &n; *  for execution of instructions in branch delay slots.&n; *&n; *  Replace use of static kernel variables with thread_struct elements.&n; *&n; *  Kevin D. Kissell, kevink@mips.com and Carsten Langgaard, carstenl@mips.com&n; *  Copyright (C) 2000  MIPS Technologies, Inc.  All rights reserved.&n; *************************************************************************/
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/asm.h&gt;
macro_line|#include &lt;asm/branch.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/inst.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/mipsregs.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/fpu_emulator.h&gt;
macro_line|#include &quot;ieee754.h&quot;
multiline_comment|/* Strap kernel emulator for full MIPS IV emulation */
macro_line|#ifdef __mips
DECL|macro|__mips
macro_line|#undef __mips
macro_line|#endif
DECL|macro|__mips
mdefine_line|#define __mips 4
DECL|typedef|vaddr_t
r_typedef
r_void
op_star
id|vaddr_t
suffix:semicolon
multiline_comment|/* Function which emulates the instruction in a branch delay slot. */
r_static
r_int
id|mips_dsemul
c_func
(paren
r_struct
id|pt_regs
op_star
comma
id|mips_instruction
comma
id|vaddr_t
)paren
suffix:semicolon
multiline_comment|/* Function which emulates a floating point instruction. */
r_static
r_int
id|fpu_emu
c_func
(paren
r_struct
id|pt_regs
op_star
comma
r_struct
id|mips_fpu_soft_struct
op_star
comma
id|mips_instruction
)paren
suffix:semicolon
macro_line|#if __mips &gt;= 4 &amp;&amp; __mips != 32
r_static
r_int
id|fpux_emu
c_func
(paren
r_struct
id|pt_regs
op_star
comma
r_struct
id|mips_fpu_soft_struct
op_star
comma
id|mips_instruction
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Further private data for which no space exists in mips_fpu_soft_struct */
DECL|variable|fpuemuprivate
r_struct
id|mips_fpu_emulator_private
id|fpuemuprivate
suffix:semicolon
multiline_comment|/* Control registers */
DECL|macro|FPCREG_RID
mdefine_line|#define FPCREG_RID&t;0&t;/* $0  = revision id */
DECL|macro|FPCREG_CSR
mdefine_line|#define FPCREG_CSR&t;31&t;/* $31 = csr */
multiline_comment|/* Convert Mips rounding mode (0..3) to IEEE library modes. */
DECL|variable|ieee_rm
r_static
r_const
r_int
r_char
id|ieee_rm
(braket
l_int|4
)braket
op_assign
(brace
id|IEEE754_RN
comma
id|IEEE754_RZ
comma
id|IEEE754_RU
comma
id|IEEE754_RD
)brace
suffix:semicolon
macro_line|#if __mips &gt;= 4
multiline_comment|/* convert condition code register number to csr bit */
DECL|variable|fpucondbit
r_static
r_const
r_int
r_int
id|fpucondbit
(braket
l_int|8
)braket
op_assign
(brace
id|FPU_CSR_COND0
comma
id|FPU_CSR_COND1
comma
id|FPU_CSR_COND2
comma
id|FPU_CSR_COND3
comma
id|FPU_CSR_COND4
comma
id|FPU_CSR_COND5
comma
id|FPU_CSR_COND6
comma
id|FPU_CSR_COND7
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n; * Redundant with logic already in kernel/branch.c,&n; * embedded in compute_return_epc.  At some point,&n; * a single subroutine should be used across both&n; * modules.&n; */
DECL|function|isBranchInstr
r_static
r_int
id|isBranchInstr
c_func
(paren
id|mips_instruction
op_star
id|i
)paren
(brace
r_switch
c_cond
(paren
id|MIPSInst_OPCODE
c_func
(paren
op_star
id|i
)paren
)paren
(brace
r_case
id|spec_op
suffix:colon
r_switch
c_cond
(paren
id|MIPSInst_FUNC
c_func
(paren
op_star
id|i
)paren
)paren
(brace
r_case
id|jalr_op
suffix:colon
r_case
id|jr_op
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|bcond_op
suffix:colon
r_switch
c_cond
(paren
id|MIPSInst_RT
c_func
(paren
op_star
id|i
)paren
)paren
(brace
r_case
id|bltz_op
suffix:colon
r_case
id|bgez_op
suffix:colon
r_case
id|bltzl_op
suffix:colon
r_case
id|bgezl_op
suffix:colon
r_case
id|bltzal_op
suffix:colon
r_case
id|bgezal_op
suffix:colon
r_case
id|bltzall_op
suffix:colon
r_case
id|bgezall_op
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|j_op
suffix:colon
r_case
id|jal_op
suffix:colon
r_case
id|jalx_op
suffix:colon
r_case
id|beq_op
suffix:colon
r_case
id|bne_op
suffix:colon
r_case
id|blez_op
suffix:colon
r_case
id|bgtz_op
suffix:colon
r_case
id|beql_op
suffix:colon
r_case
id|bnel_op
suffix:colon
r_case
id|blezl_op
suffix:colon
r_case
id|bgtzl_op
suffix:colon
r_return
l_int|1
suffix:semicolon
r_case
id|cop0_op
suffix:colon
r_case
id|cop1_op
suffix:colon
r_case
id|cop2_op
suffix:colon
r_case
id|cop1x_op
suffix:colon
r_if
c_cond
(paren
id|MIPSInst_RS
c_func
(paren
op_star
id|i
)paren
op_eq
id|bc_op
)paren
r_return
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|REG_TO_VA
mdefine_line|#define REG_TO_VA (vaddr_t)
DECL|macro|VA_TO_REG
mdefine_line|#define VA_TO_REG (unsigned long)
r_static
r_int
r_int
DECL|function|mips_get_word
id|mips_get_word
c_func
(paren
r_struct
id|pt_regs
op_star
id|xcp
comma
r_void
op_star
id|va
comma
r_int
op_star
id|perr
)paren
(brace
r_int
r_int
id|temp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|user_mode
c_func
(paren
id|xcp
)paren
)paren
(brace
op_star
id|perr
op_assign
l_int|0
suffix:semicolon
r_return
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|va
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Use kernel get_user() macro */
op_star
id|perr
op_assign
(paren
r_int
)paren
id|get_user
c_func
(paren
id|temp
comma
(paren
r_int
r_int
op_star
)paren
id|va
)paren
suffix:semicolon
r_return
id|temp
suffix:semicolon
)brace
)brace
r_static
r_int
r_int
r_int
DECL|function|mips_get_dword
id|mips_get_dword
c_func
(paren
r_struct
id|pt_regs
op_star
id|xcp
comma
r_void
op_star
id|va
comma
r_int
op_star
id|perr
)paren
(brace
r_int
r_int
r_int
id|temp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|user_mode
c_func
(paren
id|xcp
)paren
)paren
(brace
op_star
id|perr
op_assign
l_int|0
suffix:semicolon
r_return
(paren
op_star
(paren
r_int
r_int
r_int
op_star
)paren
id|va
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Use kernel get_user() macro */
op_star
id|perr
op_assign
(paren
r_int
)paren
id|get_user
c_func
(paren
id|temp
comma
(paren
r_int
r_int
r_int
op_star
)paren
id|va
)paren
suffix:semicolon
r_return
id|temp
suffix:semicolon
)brace
)brace
DECL|function|mips_put_word
r_static
r_int
id|mips_put_word
c_func
(paren
r_struct
id|pt_regs
op_star
id|xcp
comma
r_void
op_star
id|va
comma
r_int
r_int
id|val
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|user_mode
c_func
(paren
id|xcp
)paren
)paren
(brace
op_star
(paren
r_int
r_int
op_star
)paren
id|va
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Use kernel get_user() macro */
r_return
(paren
r_int
)paren
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
r_int
op_star
)paren
id|va
)paren
suffix:semicolon
)brace
)brace
DECL|function|mips_put_dword
r_static
r_int
id|mips_put_dword
c_func
(paren
r_struct
id|pt_regs
op_star
id|xcp
comma
r_void
op_star
id|va
comma
r_int
r_int
id|val
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|user_mode
c_func
(paren
id|xcp
)paren
)paren
(brace
op_star
(paren
r_int
r_int
r_int
op_star
)paren
id|va
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Use kernel get_user() macro */
r_return
(paren
r_int
)paren
id|put_user
c_func
(paren
id|val
comma
(paren
r_int
r_int
r_int
op_star
)paren
id|va
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * In the Linux kernel, we support selection of FPR format on the&n; * basis of the Status.FR bit.  This does imply that, if a full 32&n; * FPRs are desired, there needs to be a flip-flop that can be written&n; * to one at that bit position.  In any case, normal MIPS ABI uses&n; * only the even FPRs (Status.FR = 0).&n; */
DECL|macro|CP0_STATUS_FR_SUPPORT
mdefine_line|#define CP0_STATUS_FR_SUPPORT
multiline_comment|/*&n; * Emulate the single floating point instruction pointed at by EPC.&n; * Two instructions if the instruction is in a branch delay slot.&n; */
r_static
r_int
DECL|function|cop1Emulate
id|cop1Emulate
c_func
(paren
r_int
id|xcptno
comma
r_struct
id|pt_regs
op_star
id|xcp
comma
r_struct
id|mips_fpu_soft_struct
op_star
id|ctx
)paren
(brace
id|mips_instruction
id|ir
suffix:semicolon
id|vaddr_t
id|emulpc
suffix:semicolon
id|vaddr_t
id|contpc
suffix:semicolon
r_int
r_int
id|cond
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|ir
op_assign
id|mips_get_word
c_func
(paren
id|xcp
comma
id|REG_TO_VA
id|xcp-&gt;cp0_epc
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|fpuemuprivate.stats.errors
op_increment
suffix:semicolon
r_return
id|SIGBUS
suffix:semicolon
)brace
multiline_comment|/* XXX NEC Vr54xx bug workaround */
r_if
c_cond
(paren
(paren
id|xcp-&gt;cp0_cause
op_amp
id|CAUSEF_BD
)paren
op_logical_and
op_logical_neg
id|isBranchInstr
c_func
(paren
op_amp
id|ir
)paren
)paren
id|xcp-&gt;cp0_cause
op_and_assign
op_complement
id|CAUSEF_BD
suffix:semicolon
r_if
c_cond
(paren
id|xcp-&gt;cp0_cause
op_amp
id|CAUSEF_BD
)paren
(brace
multiline_comment|/*&n;&t;&t; * The instruction to be emulated is in a branch delay slot&n;&t;&t; * which means that we have to  emulate the branch instruction&n;&t;&t; * BEFORE we do the cop1 instruction. &n;&t;&t; *&n;&t;&t; * This branch could be a COP1 branch, but in that case we&n;&t;&t; * would have had a trap for that instruction, and would not&n;&t;&t; * come through this route.&n;&t;&t; *&n;&t;&t; * Linux MIPS branch emulator operates on context, updating the&n;&t;&t; * cp0_epc.&n;&t;&t; */
id|emulpc
op_assign
id|REG_TO_VA
c_func
(paren
id|xcp-&gt;cp0_epc
op_plus
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Snapshot emulation target */
r_if
c_cond
(paren
id|__compute_return_epc
c_func
(paren
id|xcp
)paren
)paren
(brace
macro_line|#ifdef CP1DBG
id|printk
c_func
(paren
l_string|&quot;failed to emulate branch at %p&bslash;n&quot;
comma
id|REG_TO_VA
c_func
(paren
id|xcp-&gt;cp0_epc
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
id|SIGILL
suffix:semicolon
suffix:semicolon
)brace
id|ir
op_assign
id|mips_get_word
c_func
(paren
id|xcp
comma
id|emulpc
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|fpuemuprivate.stats.errors
op_increment
suffix:semicolon
r_return
id|SIGBUS
suffix:semicolon
)brace
id|contpc
op_assign
id|REG_TO_VA
id|xcp-&gt;cp0_epc
suffix:semicolon
)brace
r_else
(brace
id|emulpc
op_assign
id|REG_TO_VA
id|xcp-&gt;cp0_epc
suffix:semicolon
id|contpc
op_assign
id|REG_TO_VA
id|xcp-&gt;cp0_epc
op_plus
l_int|4
suffix:semicolon
)brace
id|emul
suffix:colon
id|fpuemuprivate.stats.emulated
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|MIPSInst_OPCODE
c_func
(paren
id|ir
)paren
)paren
(brace
macro_line|#ifdef CP0_STATUS_FR_SUPPORT
multiline_comment|/* R4000+ 64-bit fpu registers */
macro_line|#ifndef SINGLE_ONLY_FPU
r_case
id|ldc1_op
suffix:colon
(brace
r_void
op_star
id|va
op_assign
id|REG_TO_VA
c_func
(paren
id|xcp-&gt;regs
(braket
id|MIPSInst_RS
c_func
(paren
id|ir
)paren
)braket
)paren
op_plus
id|MIPSInst_SIMM
c_func
(paren
id|ir
)paren
suffix:semicolon
r_int
id|ft
op_assign
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|xcp-&gt;cp0_status
op_amp
id|ST0_FR
)paren
)paren
id|ft
op_and_assign
op_complement
l_int|1
suffix:semicolon
id|ctx-&gt;regs
(braket
id|ft
)braket
op_assign
id|mips_get_dword
c_func
(paren
id|xcp
comma
id|va
comma
op_amp
id|err
)paren
suffix:semicolon
id|fpuemuprivate.stats.loads
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|fpuemuprivate.stats.errors
op_increment
suffix:semicolon
r_return
id|SIGBUS
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|sdc1_op
suffix:colon
(brace
r_void
op_star
id|va
op_assign
id|REG_TO_VA
c_func
(paren
id|xcp-&gt;regs
(braket
id|MIPSInst_RS
c_func
(paren
id|ir
)paren
)braket
)paren
op_plus
id|MIPSInst_SIMM
c_func
(paren
id|ir
)paren
suffix:semicolon
r_int
id|ft
op_assign
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|xcp-&gt;cp0_status
op_amp
id|ST0_FR
)paren
)paren
id|ft
op_and_assign
op_complement
l_int|1
suffix:semicolon
id|fpuemuprivate.stats.stores
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|mips_put_dword
c_func
(paren
id|xcp
comma
id|va
comma
id|ctx-&gt;regs
(braket
id|ft
)braket
)paren
)paren
(brace
id|fpuemuprivate.stats.errors
op_increment
suffix:semicolon
r_return
id|SIGBUS
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
macro_line|#endif
r_case
id|lwc1_op
suffix:colon
(brace
r_void
op_star
id|va
op_assign
id|REG_TO_VA
c_func
(paren
id|xcp-&gt;regs
(braket
id|MIPSInst_RS
c_func
(paren
id|ir
)paren
)braket
)paren
op_plus
id|MIPSInst_SIMM
c_func
(paren
id|ir
)paren
suffix:semicolon
id|fpureg_t
id|val
suffix:semicolon
r_int
id|ft
op_assign
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
suffix:semicolon
id|fpuemuprivate.stats.loads
op_increment
suffix:semicolon
id|val
op_assign
id|mips_get_word
c_func
(paren
id|xcp
comma
id|va
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|fpuemuprivate.stats.errors
op_increment
suffix:semicolon
r_return
id|SIGBUS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xcp-&gt;cp0_status
op_amp
id|ST0_FR
)paren
(brace
multiline_comment|/* load whole register */
id|ctx-&gt;regs
(braket
id|ft
)braket
op_assign
id|val
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ft
op_amp
l_int|1
)paren
(brace
multiline_comment|/* load to m.s. 32 bits */
macro_line|#ifdef SINGLE_ONLY_FPU
multiline_comment|/* illegal register in single-float mode */
r_return
id|SIGILL
suffix:semicolon
macro_line|#else
id|ctx-&gt;regs
(braket
(paren
id|ft
op_amp
op_complement
l_int|1
)paren
)braket
op_and_assign
l_int|0xffffffff
suffix:semicolon
id|ctx-&gt;regs
(braket
(paren
id|ft
op_amp
op_complement
l_int|1
)paren
)braket
op_or_assign
id|val
op_lshift
l_int|32
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/* load to l.s. 32 bits */
id|ctx-&gt;regs
(braket
id|ft
)braket
op_and_assign
op_complement
l_int|0xffffffffLL
suffix:semicolon
id|ctx-&gt;regs
(braket
id|ft
)braket
op_or_assign
id|val
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|swc1_op
suffix:colon
(brace
r_void
op_star
id|va
op_assign
id|REG_TO_VA
c_func
(paren
id|xcp-&gt;regs
(braket
id|MIPSInst_RS
c_func
(paren
id|ir
)paren
)braket
)paren
op_plus
id|MIPSInst_SIMM
c_func
(paren
id|ir
)paren
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
r_int
id|ft
op_assign
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
suffix:semicolon
id|fpuemuprivate.stats.stores
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|xcp-&gt;cp0_status
op_amp
id|ST0_FR
)paren
(brace
multiline_comment|/* store whole register */
id|val
op_assign
id|ctx-&gt;regs
(braket
id|ft
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ft
op_amp
l_int|1
)paren
(brace
macro_line|#ifdef SINGLE_ONLY_FPU
multiline_comment|/* illegal register in single-float mode */
r_return
id|SIGILL
suffix:semicolon
macro_line|#else
multiline_comment|/* store from m.s. 32 bits */
id|val
op_assign
id|ctx-&gt;regs
(braket
(paren
id|ft
op_amp
op_complement
l_int|1
)paren
)braket
op_rshift
l_int|32
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/* store from l.s. 32 bits */
id|val
op_assign
id|ctx-&gt;regs
(braket
id|ft
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mips_put_word
c_func
(paren
id|xcp
comma
id|va
comma
id|val
)paren
)paren
(brace
id|fpuemuprivate.stats.errors
op_increment
suffix:semicolon
r_return
id|SIGBUS
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
macro_line|#else&t;&t;&t;&t;/* old 32-bit fpu registers */
r_case
id|lwc1_op
suffix:colon
(brace
r_void
op_star
id|va
op_assign
id|REG_TO_VA
c_func
(paren
id|xcp-&gt;regs
(braket
id|MIPSInst_RS
c_func
(paren
id|ir
)paren
)braket
)paren
op_plus
id|MIPSInst_SIMM
c_func
(paren
id|ir
)paren
suffix:semicolon
id|ctx-&gt;regs
(braket
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
)braket
op_assign
id|mips_get_word
c_func
(paren
id|xcp
comma
id|va
comma
op_amp
id|err
)paren
suffix:semicolon
id|fpuemuprivate.stats.loads
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|fpuemuprivate.stats.errors
op_increment
suffix:semicolon
r_return
id|SIGBUS
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|swc1_op
suffix:colon
(brace
r_void
op_star
id|va
op_assign
id|REG_TO_VA
c_func
(paren
id|xcp-&gt;regs
(braket
id|MIPSInst_RS
c_func
(paren
id|ir
)paren
)braket
)paren
op_plus
id|MIPSInst_SIMM
c_func
(paren
id|ir
)paren
suffix:semicolon
id|fpuemuprivate.stats.stores
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|mips_put_word
(paren
id|xcp
comma
id|va
comma
id|ctx-&gt;regs
(braket
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
)braket
)paren
)paren
(brace
id|fpuemuprivate.stats.errors
op_increment
suffix:semicolon
r_return
id|SIGBUS
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|ldc1_op
suffix:colon
(brace
r_void
op_star
id|va
op_assign
id|REG_TO_VA
c_func
(paren
id|xcp-&gt;regs
(braket
id|MIPSInst_RS
c_func
(paren
id|ir
)paren
)braket
)paren
op_plus
id|MIPSInst_SIMM
c_func
(paren
id|ir
)paren
suffix:semicolon
r_int
r_int
id|rt
op_assign
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
op_amp
op_complement
l_int|1
suffix:semicolon
r_int
id|errs
op_assign
l_int|0
suffix:semicolon
id|fpuemuprivate.stats.loads
op_increment
suffix:semicolon
macro_line|#if (defined(BYTE_ORDER) &amp;&amp; BYTE_ORDER == BIG_ENDIAN) || defined(__MIPSEB__)
id|ctx-&gt;regs
(braket
id|rt
op_plus
l_int|1
)braket
op_assign
id|mips_get_word
c_func
(paren
id|xcp
comma
id|va
op_plus
l_int|0
comma
op_amp
id|err
)paren
suffix:semicolon
id|errs
op_add_assign
id|err
suffix:semicolon
id|ctx-&gt;regs
(braket
id|rt
op_plus
l_int|0
)braket
op_assign
id|mips_get_word
c_func
(paren
id|xcp
comma
id|va
op_plus
l_int|4
comma
op_amp
id|err
)paren
suffix:semicolon
id|errs
op_add_assign
id|err
suffix:semicolon
macro_line|#else
id|ctx-&gt;regs
(braket
id|rt
op_plus
l_int|0
)braket
op_assign
id|mips_get_word
c_func
(paren
id|xcp
comma
id|va
op_plus
l_int|0
comma
op_amp
id|err
)paren
suffix:semicolon
id|errs
op_add_assign
id|err
suffix:semicolon
id|ctx-&gt;regs
(braket
id|rt
op_plus
l_int|1
)braket
op_assign
id|mips_get_word
c_func
(paren
id|xcp
comma
id|va
op_plus
l_int|4
comma
op_amp
id|err
)paren
suffix:semicolon
id|errs
op_add_assign
id|err
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|err
)paren
r_return
id|SIGBUS
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|sdc1_op
suffix:colon
(brace
r_void
op_star
id|va
op_assign
id|REG_TO_VA
c_func
(paren
id|xcp-&gt;regs
(braket
id|MIPSInst_RS
c_func
(paren
id|ir
)paren
)braket
)paren
op_plus
id|MIPSInst_SIMM
c_func
(paren
id|ir
)paren
suffix:semicolon
r_int
r_int
id|rt
op_assign
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
op_amp
op_complement
l_int|1
suffix:semicolon
id|fpuemuprivate.stats.stores
op_increment
suffix:semicolon
macro_line|#if (defined(BYTE_ORDER) &amp;&amp; BYTE_ORDER == BIG_ENDIAN) || defined(__MIPSEB__)
r_if
c_cond
(paren
id|mips_put_word
c_func
(paren
id|xcp
comma
id|va
op_plus
l_int|0
comma
id|ctx-&gt;regs
(braket
id|rt
op_plus
l_int|1
)braket
)paren
)paren
r_return
id|SIGBUS
suffix:semicolon
r_if
c_cond
(paren
id|mips_put_word
c_func
(paren
id|xcp
comma
id|va
op_plus
l_int|4
comma
id|ctx-&gt;regs
(braket
id|rt
op_plus
l_int|0
)braket
)paren
)paren
r_return
id|SIGBUS
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|mips_put_word
c_func
(paren
id|xcp
comma
id|va
op_plus
l_int|0
comma
id|ctx-&gt;regs
(braket
id|rt
op_plus
l_int|0
)braket
)paren
)paren
r_return
id|SIGBUS
suffix:semicolon
r_if
c_cond
(paren
id|mips_put_word
c_func
(paren
id|xcp
comma
id|va
op_plus
l_int|4
comma
id|ctx-&gt;regs
(braket
id|rt
op_plus
l_int|1
)braket
)paren
)paren
r_return
id|SIGBUS
suffix:semicolon
macro_line|#endif
)brace
r_break
suffix:semicolon
macro_line|#endif
r_case
id|cop1_op
suffix:colon
r_switch
c_cond
(paren
id|MIPSInst_RS
c_func
(paren
id|ir
)paren
)paren
(brace
macro_line|#ifdef CP0_STATUS_FR_SUPPORT
macro_line|#if __mips64 &amp;&amp; !defined(SINGLE_ONLY_FPU)
r_case
id|dmfc_op
suffix:colon
multiline_comment|/* copregister fs -&gt; gpr[rt] */
r_if
c_cond
(paren
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|fs
op_assign
id|MIPSInst_RD
c_func
(paren
id|ir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|xcp-&gt;cp0_status
op_amp
id|ST0_FR
)paren
)paren
id|fs
op_and_assign
op_complement
l_int|1
suffix:semicolon
id|xcp-&gt;regs
(braket
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
)braket
op_assign
id|ctx-&gt;regs
(braket
id|fs
)braket
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|dmtc_op
suffix:colon
multiline_comment|/* copregister fs &lt;- rt */
(brace
id|fpureg_t
id|value
suffix:semicolon
r_int
id|fs
op_assign
id|MIPSInst_RD
c_func
(paren
id|ir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|xcp-&gt;cp0_status
op_amp
id|ST0_FR
)paren
)paren
id|fs
op_and_assign
op_complement
l_int|1
suffix:semicolon
id|value
op_assign
(paren
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
id|xcp-&gt;regs
(braket
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
)braket
suffix:semicolon
id|ctx-&gt;regs
(braket
id|fs
)braket
op_assign
id|value
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#endif
r_case
id|mfc_op
suffix:colon
multiline_comment|/* copregister rd -&gt; gpr[rt] */
r_if
c_cond
(paren
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* default value from l.s. 32 bits */
r_int
id|value
op_assign
id|ctx-&gt;regs
(braket
id|MIPSInst_RD
c_func
(paren
id|ir
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|MIPSInst_RD
c_func
(paren
id|ir
)paren
op_amp
l_int|1
)paren
(brace
macro_line|#ifdef SINGLE_ONLY_FPU
multiline_comment|/* illegal register in single-float mode */
r_return
id|SIGILL
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
(paren
id|xcp-&gt;cp0_status
op_amp
id|ST0_FR
)paren
)paren
(brace
multiline_comment|/* move from m.s. 32 bits */
id|value
op_assign
id|ctx
op_member_access_from_pointer
id|regs
(braket
id|MIPSInst_RD
c_func
(paren
id|ir
)paren
op_amp
op_complement
l_int|1
)braket
op_rshift
l_int|32
suffix:semicolon
)brace
macro_line|#endif
)brace
id|xcp-&gt;regs
(braket
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
)braket
op_assign
id|value
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|mtc_op
suffix:colon
multiline_comment|/* copregister rd &lt;- rt */
(brace
id|fpureg_t
id|value
suffix:semicolon
r_if
c_cond
(paren
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
op_eq
l_int|0
)paren
id|value
op_assign
l_int|0
suffix:semicolon
r_else
id|value
op_assign
(paren
r_int
r_int
)paren
id|xcp
op_member_access_from_pointer
id|regs
(braket
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|MIPSInst_RD
c_func
(paren
id|ir
)paren
op_amp
l_int|1
)paren
(brace
macro_line|#ifdef SINGLE_ONLY_FPU
multiline_comment|/* illegal register in single-float mode */
r_return
id|SIGILL
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
(paren
id|xcp-&gt;cp0_status
op_amp
id|ST0_FR
)paren
)paren
(brace
multiline_comment|/* move to m.s. 32 bits */
id|ctx
op_member_access_from_pointer
id|regs
(braket
(paren
id|MIPSInst_RD
c_func
(paren
id|ir
)paren
op_amp
op_complement
l_int|1
)paren
)braket
op_and_assign
l_int|0xffffffff
suffix:semicolon
id|ctx
op_member_access_from_pointer
id|regs
(braket
(paren
id|MIPSInst_RD
c_func
(paren
id|ir
)paren
op_amp
op_complement
l_int|1
)paren
)braket
op_or_assign
id|value
op_lshift
l_int|32
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/* move to l.s. 32 bits */
id|ctx-&gt;regs
(braket
id|MIPSInst_RD
c_func
(paren
id|ir
)paren
)braket
op_and_assign
op_complement
l_int|0xffffffffLL
suffix:semicolon
id|ctx-&gt;regs
(braket
id|MIPSInst_RD
c_func
(paren
id|ir
)paren
)braket
op_or_assign
id|value
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#else
r_case
id|mfc_op
suffix:colon
multiline_comment|/* copregister rd -&gt; gpr[rt] */
r_if
c_cond
(paren
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|value
op_assign
id|ctx-&gt;regs
(braket
id|MIPSInst_RD
c_func
(paren
id|ir
)paren
)braket
suffix:semicolon
id|xcp-&gt;regs
(braket
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
)braket
op_assign
id|value
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|mtc_op
suffix:colon
multiline_comment|/* copregister rd &lt;- rt */
(brace
r_int
id|value
suffix:semicolon
id|value
op_assign
(paren
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
id|xcp-&gt;regs
(braket
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
)braket
suffix:semicolon
id|ctx-&gt;regs
(braket
id|MIPSInst_RD
c_func
(paren
id|ir
)paren
)braket
op_assign
id|value
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#endif
r_case
id|cfc_op
suffix:colon
multiline_comment|/* cop control register rd -&gt; gpr[rt] */
(brace
r_int
id|value
suffix:semicolon
r_if
c_cond
(paren
id|MIPSInst_RD
c_func
(paren
id|ir
)paren
op_eq
id|FPCREG_CSR
)paren
(brace
id|value
op_assign
id|ctx-&gt;sr
suffix:semicolon
macro_line|#ifdef CSRTRACE
id|printk
(paren
l_string|&quot;%p gpr[%d]&lt;-csr=%08x&bslash;n&quot;
comma
id|REG_TO_VA
c_func
(paren
id|xcp-&gt;cp0_epc
)paren
comma
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
comma
id|value
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
id|MIPSInst_RD
c_func
(paren
id|ir
)paren
op_eq
id|FPCREG_RID
)paren
id|value
op_assign
l_int|0
suffix:semicolon
r_else
id|value
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
)paren
id|xcp-&gt;regs
(braket
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
)braket
op_assign
id|value
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ctc_op
suffix:colon
multiline_comment|/* copregister rd &lt;- rt */
(brace
r_int
id|value
suffix:semicolon
r_if
c_cond
(paren
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
op_eq
l_int|0
)paren
id|value
op_assign
l_int|0
suffix:semicolon
r_else
id|value
op_assign
id|xcp-&gt;regs
(braket
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
)braket
suffix:semicolon
multiline_comment|/* we only have one writable control reg&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|MIPSInst_RD
c_func
(paren
id|ir
)paren
op_eq
id|FPCREG_CSR
)paren
(brace
macro_line|#ifdef CSRTRACE
id|printk
(paren
l_string|&quot;%p gpr[%d]-&gt;csr=%08x&bslash;n&quot;
comma
id|REG_TO_VA
c_func
(paren
id|xcp-&gt;cp0_epc
)paren
comma
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
comma
id|value
)paren
suffix:semicolon
macro_line|#endif
id|ctx-&gt;sr
op_assign
id|value
suffix:semicolon
multiline_comment|/* copy new rounding mode to ieee library state! */
id|ieee754_csr.rm
op_assign
id|ieee_rm
(braket
id|value
op_amp
l_int|0x3
)braket
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|bc_op
suffix:colon
r_if
c_cond
(paren
id|xcp-&gt;cp0_cause
op_amp
id|CAUSEF_BD
)paren
(brace
r_return
id|SIGILL
suffix:semicolon
)brace
(brace
r_int
id|likely
op_assign
l_int|0
suffix:semicolon
macro_line|#if __mips &gt;= 4
id|cond
op_assign
id|ctx
op_member_access_from_pointer
id|sr
op_amp
id|fpucondbit
(braket
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
op_rshift
l_int|2
)braket
suffix:semicolon
macro_line|#else
id|cond
op_assign
id|ctx-&gt;sr
op_amp
id|FPU_CSR_COND
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
op_amp
l_int|3
)paren
(brace
r_case
id|bcfl_op
suffix:colon
id|likely
op_assign
l_int|1
suffix:semicolon
r_case
id|bcf_op
suffix:colon
id|cond
op_assign
op_logical_neg
id|cond
suffix:semicolon
r_break
suffix:semicolon
r_case
id|bctl_op
suffix:colon
id|likely
op_assign
l_int|1
suffix:semicolon
r_case
id|bct_op
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* thats an illegal instruction */
r_return
id|SIGILL
suffix:semicolon
)brace
id|xcp-&gt;cp0_cause
op_or_assign
id|CAUSEF_BD
suffix:semicolon
r_if
c_cond
(paren
id|cond
)paren
(brace
multiline_comment|/* branch taken: emulate dslot instruction */
id|xcp-&gt;cp0_epc
op_add_assign
l_int|4
suffix:semicolon
id|contpc
op_assign
id|REG_TO_VA
id|xcp-&gt;cp0_epc
op_plus
(paren
id|MIPSInst_SIMM
c_func
(paren
id|ir
)paren
op_lshift
l_int|2
)paren
suffix:semicolon
id|ir
op_assign
id|mips_get_word
c_func
(paren
id|xcp
comma
id|REG_TO_VA
c_func
(paren
id|xcp
op_member_access_from_pointer
id|cp0_epc
)paren
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|fpuemuprivate.stats
dot
id|errors
op_increment
suffix:semicolon
r_return
id|SIGBUS
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|MIPSInst_OPCODE
c_func
(paren
id|ir
)paren
)paren
(brace
r_case
id|lwc1_op
suffix:colon
r_case
id|swc1_op
suffix:colon
macro_line|#if (__mips &gt;= 2 || __mips64) &amp;&amp; !defined(SINGLE_ONLY_FPU)
r_case
id|ldc1_op
suffix:colon
r_case
id|sdc1_op
suffix:colon
macro_line|#endif
r_case
id|cop1_op
suffix:colon
macro_line|#if __mips &gt;= 4 &amp;&amp; __mips != 32
r_case
id|cop1x_op
suffix:colon
macro_line|#endif
multiline_comment|/* its one of ours */
r_goto
id|emul
suffix:semicolon
macro_line|#if __mips &gt;= 4
r_case
id|spec_op
suffix:colon
r_if
c_cond
(paren
id|MIPSInst_FUNC
c_func
(paren
id|ir
)paren
op_eq
id|movc_op
)paren
r_goto
id|emul
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* single step the non-cp1 instruction in the dslot */
r_return
id|mips_dsemul
c_func
(paren
id|xcp
comma
id|ir
comma
id|contpc
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* branch not taken */
r_if
c_cond
(paren
id|likely
)paren
multiline_comment|/* branch likely nullifies dslot if not taken */
id|xcp-&gt;cp0_epc
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/* else continue &amp; execute dslot as normal insn */
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|MIPSInst_RS
c_func
(paren
id|ir
)paren
op_amp
l_int|0x10
)paren
)paren
(brace
r_return
id|SIGILL
suffix:semicolon
)brace
multiline_comment|/* a real fpu computation instruction */
(brace
r_int
id|sig
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sig
op_assign
id|fpu_emu
c_func
(paren
id|xcp
comma
id|ctx
comma
id|ir
)paren
)paren
)paren
r_return
id|sig
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
macro_line|#if __mips &gt;= 4 &amp;&amp; __mips != 32
r_case
id|cop1x_op
suffix:colon
(brace
r_int
id|sig
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sig
op_assign
id|fpux_emu
c_func
(paren
id|xcp
comma
id|ctx
comma
id|ir
)paren
)paren
)paren
r_return
id|sig
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#endif
macro_line|#if __mips &gt;= 4
r_case
id|spec_op
suffix:colon
r_if
c_cond
(paren
id|MIPSInst_FUNC
c_func
(paren
id|ir
)paren
op_ne
id|movc_op
)paren
r_return
id|SIGILL
suffix:semicolon
id|cond
op_assign
id|fpucondbit
(braket
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
op_rshift
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|ctx-&gt;sr
op_amp
id|cond
)paren
op_ne
l_int|0
)paren
op_ne
(paren
(paren
id|MIPSInst_RT
c_func
(paren
id|ir
)paren
op_amp
l_int|1
)paren
op_ne
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|xcp-&gt;regs
(braket
id|MIPSInst_RD
c_func
(paren
id|ir
)paren
)braket
op_assign
id|xcp-&gt;regs
(braket
id|MIPSInst_RS
c_func
(paren
id|ir
)paren
)braket
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
r_return
id|SIGILL
suffix:semicolon
)brace
multiline_comment|/* we did it !! */
id|xcp-&gt;cp0_epc
op_assign
id|VA_TO_REG
c_func
(paren
id|contpc
)paren
suffix:semicolon
id|xcp-&gt;cp0_cause
op_and_assign
op_complement
id|CAUSEF_BD
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Emulate the arbritrary instruction ir at xcp-&gt;cp0_epc.  Required when&n; * we have to emulate the instruction in a COP1 branch delay slot.  Do&n; * not change cp0_epc due to the instruction&n; *&n; * According to the spec:&n; * 1) it shouldnt be a branch :-)&n; * 2) it can be a COP instruction :-(&n; * 3) if we are tring to run a protected memory space we must take&n; *    special care on memory access instructions :-(&n; */
multiline_comment|/*&n; * &quot;Trampoline&quot; return routine to catch exception following&n; *  execution of delay-slot instruction execution.&n; */
DECL|function|do_dsemulret
r_int
id|do_dsemulret
c_func
(paren
r_struct
id|pt_regs
op_star
id|xcp
)paren
(brace
macro_line|#ifdef DSEMUL_TRACE
id|printk
c_func
(paren
l_string|&quot;desemulret&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Set EPC to return to post-branch instruction */
id|xcp-&gt;cp0_epc
op_assign
id|current-&gt;thread.dsemul_epc
suffix:semicolon
multiline_comment|/*&n;&t; * Clear the state that got us here.&n;&t; */
id|current-&gt;thread.dsemul_aerpc
op_assign
(paren
r_int
r_int
)paren
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|AdELOAD
mdefine_line|#define AdELOAD 0x8c000001&t;/* lw $0,1($0) */
r_static
r_int
DECL|function|mips_dsemul
id|mips_dsemul
c_func
(paren
r_struct
id|pt_regs
op_star
id|xcp
comma
id|mips_instruction
id|ir
comma
id|vaddr_t
id|cpc
)paren
(brace
id|mips_instruction
op_star
id|dsemul_insns
suffix:semicolon
id|mips_instruction
id|forcetrap
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|handle_dsemulret
c_func
(paren
r_void
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ir
op_eq
l_int|0
)paren
(brace
multiline_comment|/* a nop is easy */
id|xcp-&gt;cp0_epc
op_assign
id|VA_TO_REG
c_func
(paren
id|cpc
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef DSEMUL_TRACE
id|printk
c_func
(paren
l_string|&quot;desemul %p %p&bslash;n&quot;
comma
id|REG_TO_VA
c_func
(paren
id|xcp-&gt;cp0_epc
)paren
comma
id|cpc
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &n;&t; * The strategy is to push the instruction onto the user stack &n;&t; * and put a trap after it which we can catch and jump to &n;&t; * the required address any alternative apart from full &n;&t; * instruction emulation!!.&n;&t; */
id|dsemul_insns
op_assign
(paren
id|mips_instruction
op_star
)paren
(paren
id|xcp-&gt;regs
(braket
l_int|29
)braket
op_amp
op_complement
l_int|3
)paren
suffix:semicolon
id|dsemul_insns
op_sub_assign
l_int|3
suffix:semicolon
multiline_comment|/* Two instructions, plus one for luck ;-) */
multiline_comment|/* Verify that the stack pointer is not competely insane */
r_if
c_cond
(paren
id|verify_area
(paren
id|VERIFY_WRITE
comma
id|dsemul_insns
comma
r_sizeof
(paren
id|mips_instruction
)paren
op_star
l_int|2
)paren
)paren
r_return
id|SIGBUS
suffix:semicolon
r_if
c_cond
(paren
id|mips_put_word
c_func
(paren
id|xcp
comma
op_amp
id|dsemul_insns
(braket
l_int|0
)braket
comma
id|ir
)paren
)paren
(brace
id|fpuemuprivate.stats.errors
op_increment
suffix:semicolon
r_return
(paren
id|SIGBUS
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * Algorithmics used a system call instruction, and&n;&t; * borrowed that vector.  MIPS/Linux version is a bit&n;&t; * more heavyweight in the interests of portability and&n;&t; * multiprocessor support.  We flag the thread for special&n;&t; * handling in the unaligned access handler and force an&n;&t; * address error excpetion.&n;&t; */
multiline_comment|/* If one is *really* paranoid, one tests for a bad stack pointer */
r_if
c_cond
(paren
(paren
id|xcp-&gt;regs
(braket
l_int|29
)braket
op_amp
l_int|0x3
)paren
op_eq
l_int|0x3
)paren
id|forcetrap
op_assign
id|AdELOAD
op_minus
l_int|1
suffix:semicolon
r_else
id|forcetrap
op_assign
id|AdELOAD
suffix:semicolon
r_if
c_cond
(paren
id|mips_put_word
c_func
(paren
id|xcp
comma
op_amp
id|dsemul_insns
(braket
l_int|1
)braket
comma
id|forcetrap
)paren
)paren
(brace
id|fpuemuprivate.stats.errors
op_increment
suffix:semicolon
r_return
(paren
id|SIGBUS
)paren
suffix:semicolon
)brace
multiline_comment|/* Set thread state to catch and handle the exception */
id|current-&gt;thread.dsemul_epc
op_assign
(paren
r_int
r_int
)paren
id|cpc
suffix:semicolon
id|current-&gt;thread.dsemul_aerpc
op_assign
(paren
r_int
r_int
)paren
op_amp
id|dsemul_insns
(braket
l_int|1
)braket
suffix:semicolon
id|xcp-&gt;cp0_epc
op_assign
id|VA_TO_REG
op_amp
id|dsemul_insns
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* What we&squot;d really like to do is just flush the line(s) of the */
multiline_comment|/* icache containing the dsemulret instructions, but there&squot;s no */
multiline_comment|/* mechanism to do this yet...  */
id|flush_cache_all
c_func
(paren
)paren
suffix:semicolon
r_return
id|SIGILL
suffix:semicolon
multiline_comment|/* force out of emulation loop */
)brace
multiline_comment|/* &n; * Conversion table from MIPS compare ops 48-63&n; * cond = ieee754dp_cmp(x,y,IEEE754_UN);&n; */
DECL|variable|cmptab
r_static
r_const
r_int
r_char
id|cmptab
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
multiline_comment|/* cmp_0 (sig) cmp_sf */
id|IEEE754_CUN
comma
multiline_comment|/* cmp_un (sig) cmp_ngle */
id|IEEE754_CEQ
comma
multiline_comment|/* cmp_eq (sig) cmp_seq */
id|IEEE754_CEQ
op_or
id|IEEE754_CUN
comma
multiline_comment|/* cmp_ueq (sig) cmp_ngl  */
id|IEEE754_CLT
comma
multiline_comment|/* cmp_olt (sig) cmp_lt */
id|IEEE754_CLT
op_or
id|IEEE754_CUN
comma
multiline_comment|/* cmp_ult (sig) cmp_nge */
id|IEEE754_CLT
op_or
id|IEEE754_CEQ
comma
multiline_comment|/* cmp_ole (sig) cmp_le */
id|IEEE754_CLT
op_or
id|IEEE754_CEQ
op_or
id|IEEE754_CUN
comma
multiline_comment|/* cmp_ule (sig) cmp_ngt */
)brace
suffix:semicolon
DECL|macro|SIFROMREG
mdefine_line|#define SIFROMREG(si,x)&t;((si) = ctx-&gt;regs[x])
DECL|macro|SITOREG
mdefine_line|#define SITOREG(si,x)&t;(ctx-&gt;regs[x] = (int)(si))
macro_line|#if __mips64 &amp;&amp; !defined(SINGLE_ONLY_FPU)
DECL|macro|DIFROMREG
mdefine_line|#define DIFROMREG(di,x)&t;((di) = ctx-&gt;regs[x])
DECL|macro|DITOREG
mdefine_line|#define DITOREG(di,x)&t;(ctx-&gt;regs[x] = (di))
macro_line|#endif
DECL|macro|SPFROMREG
mdefine_line|#define SPFROMREG(sp,x)&t;((sp).bits = ctx-&gt;regs[x])
DECL|macro|SPTOREG
mdefine_line|#define SPTOREG(sp,x)&t;(ctx-&gt;regs[x] = (sp).bits)
macro_line|#ifdef CP0_STATUS_FR_SUPPORT
DECL|macro|DPFROMREG
mdefine_line|#define DPFROMREG(dp,x)&t;((dp).bits = &bslash;&n;&t;&t;&t;ctx-&gt;regs[(xcp-&gt;cp0_status &amp; ST0_FR) ? x : (x &amp; ~1)])
DECL|macro|DPTOREG
mdefine_line|#define DPTOREG(dp,x)&t;(ctx-&gt;regs[(xcp-&gt;cp0_status &amp; ST0_FR) ? x : (x &amp; ~1)]&bslash;&n;&t;&t;&t;= (dp).bits)
macro_line|#else
multiline_comment|/* Beware: MIPS COP1 doubles are always little_word endian in registers */
DECL|macro|DPFROMREG
mdefine_line|#define DPFROMREG(dp,x)&t;&bslash;&n;  ((dp).bits = ((unsigned long long)ctx-&gt;regs[(x)+1] &lt;&lt; 32) | ctx-&gt;regs[x])
DECL|macro|DPTOREG
mdefine_line|#define DPTOREG(dp,x) &bslash;&n;  (ctx-&gt;regs[x] = (dp).bits, ctx-&gt;regs[(x)+1] = (dp).bits &gt;&gt; 32)
macro_line|#endif
macro_line|#if __mips &gt;= 4 &amp;&amp; __mips != 32
multiline_comment|/*&n; * Additional MIPS4 instructions&n; */
DECL|function|fpemu_dp_recip
r_static
id|ieee754dp
id|fpemu_dp_recip
c_func
(paren
id|ieee754dp
id|d
)paren
(brace
r_return
id|ieee754dp_div
c_func
(paren
id|ieee754dp_one
c_func
(paren
l_int|0
)paren
comma
id|d
)paren
suffix:semicolon
)brace
DECL|function|fpemu_dp_rsqrt
r_static
id|ieee754dp
id|fpemu_dp_rsqrt
c_func
(paren
id|ieee754dp
id|d
)paren
(brace
r_return
id|ieee754dp_div
c_func
(paren
id|ieee754dp_one
c_func
(paren
l_int|0
)paren
comma
id|ieee754dp_sqrt
c_func
(paren
id|d
)paren
)paren
suffix:semicolon
)brace
DECL|function|fpemu_sp_recip
r_static
id|ieee754sp
id|fpemu_sp_recip
c_func
(paren
id|ieee754sp
id|s
)paren
(brace
r_return
id|ieee754sp_div
c_func
(paren
id|ieee754sp_one
c_func
(paren
l_int|0
)paren
comma
id|s
)paren
suffix:semicolon
)brace
DECL|function|fpemu_sp_rsqrt
r_static
id|ieee754sp
id|fpemu_sp_rsqrt
c_func
(paren
id|ieee754sp
id|s
)paren
(brace
r_return
id|ieee754sp_div
c_func
(paren
id|ieee754sp_one
c_func
(paren
l_int|0
)paren
comma
id|ieee754sp_sqrt
c_func
(paren
id|s
)paren
)paren
suffix:semicolon
)brace
DECL|function|fpemu_dp_madd
r_static
id|ieee754dp
id|fpemu_dp_madd
c_func
(paren
id|ieee754dp
id|r
comma
id|ieee754dp
id|s
comma
id|ieee754dp
id|t
)paren
(brace
r_return
id|ieee754dp_add
c_func
(paren
id|ieee754dp_mul
c_func
(paren
id|s
comma
id|t
)paren
comma
id|r
)paren
suffix:semicolon
)brace
DECL|function|fpemu_dp_msub
r_static
id|ieee754dp
id|fpemu_dp_msub
c_func
(paren
id|ieee754dp
id|r
comma
id|ieee754dp
id|s
comma
id|ieee754dp
id|t
)paren
(brace
r_return
id|ieee754dp_sub
c_func
(paren
id|ieee754dp_mul
c_func
(paren
id|s
comma
id|t
)paren
comma
id|r
)paren
suffix:semicolon
)brace
DECL|function|fpemu_dp_nmadd
r_static
id|ieee754dp
id|fpemu_dp_nmadd
c_func
(paren
id|ieee754dp
id|r
comma
id|ieee754dp
id|s
comma
id|ieee754dp
id|t
)paren
(brace
r_return
id|ieee754dp_neg
c_func
(paren
id|ieee754dp_add
c_func
(paren
id|ieee754dp_mul
c_func
(paren
id|s
comma
id|t
)paren
comma
id|r
)paren
)paren
suffix:semicolon
)brace
DECL|function|fpemu_dp_nmsub
r_static
id|ieee754dp
id|fpemu_dp_nmsub
c_func
(paren
id|ieee754dp
id|r
comma
id|ieee754dp
id|s
comma
id|ieee754dp
id|t
)paren
(brace
r_return
id|ieee754dp_neg
c_func
(paren
id|ieee754dp_sub
c_func
(paren
id|ieee754dp_mul
c_func
(paren
id|s
comma
id|t
)paren
comma
id|r
)paren
)paren
suffix:semicolon
)brace
DECL|function|fpemu_sp_madd
r_static
id|ieee754sp
id|fpemu_sp_madd
c_func
(paren
id|ieee754sp
id|r
comma
id|ieee754sp
id|s
comma
id|ieee754sp
id|t
)paren
(brace
r_return
id|ieee754sp_add
c_func
(paren
id|ieee754sp_mul
c_func
(paren
id|s
comma
id|t
)paren
comma
id|r
)paren
suffix:semicolon
)brace
DECL|function|fpemu_sp_msub
r_static
id|ieee754sp
id|fpemu_sp_msub
c_func
(paren
id|ieee754sp
id|r
comma
id|ieee754sp
id|s
comma
id|ieee754sp
id|t
)paren
(brace
r_return
id|ieee754sp_sub
c_func
(paren
id|ieee754sp_mul
c_func
(paren
id|s
comma
id|t
)paren
comma
id|r
)paren
suffix:semicolon
)brace
DECL|function|fpemu_sp_nmadd
r_static
id|ieee754sp
id|fpemu_sp_nmadd
c_func
(paren
id|ieee754sp
id|r
comma
id|ieee754sp
id|s
comma
id|ieee754sp
id|t
)paren
(brace
r_return
id|ieee754sp_neg
c_func
(paren
id|ieee754sp_add
c_func
(paren
id|ieee754sp_mul
c_func
(paren
id|s
comma
id|t
)paren
comma
id|r
)paren
)paren
suffix:semicolon
)brace
DECL|function|fpemu_sp_nmsub
r_static
id|ieee754sp
id|fpemu_sp_nmsub
c_func
(paren
id|ieee754sp
id|r
comma
id|ieee754sp
id|s
comma
id|ieee754sp
id|t
)paren
(brace
r_return
id|ieee754sp_neg
c_func
(paren
id|ieee754sp_sub
c_func
(paren
id|ieee754sp_mul
c_func
(paren
id|s
comma
id|t
)paren
comma
id|r
)paren
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|fpux_emu
id|fpux_emu
c_func
(paren
r_struct
id|pt_regs
op_star
id|xcp
comma
r_struct
id|mips_fpu_soft_struct
op_star
id|ctx
comma
id|mips_instruction
id|ir
)paren
(brace
r_int
id|rcsr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* resulting csr */
id|fpuemuprivate.stats.cp1xops
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|MIPSInst_FMA_FFMT
c_func
(paren
id|ir
)paren
)paren
(brace
r_case
id|s_fmt
suffix:colon
multiline_comment|/* 0 */
(brace
id|ieee754sp
c_func
(paren
op_star
id|handler
)paren
(paren
id|ieee754sp
comma
id|ieee754sp
comma
id|ieee754sp
)paren
suffix:semicolon
id|ieee754sp
id|fd
comma
id|fr
comma
id|fs
comma
id|ft
suffix:semicolon
r_switch
c_cond
(paren
id|MIPSInst_FUNC
c_func
(paren
id|ir
)paren
)paren
(brace
r_case
id|lwxc1_op
suffix:colon
(brace
r_void
op_star
id|va
op_assign
id|REG_TO_VA
c_func
(paren
id|xcp
op_member_access_from_pointer
id|regs
(braket
id|MIPSInst_FR
c_func
(paren
id|ir
)paren
)braket
op_plus
id|xcp
op_member_access_from_pointer
id|regs
(braket
id|MIPSInst_FT
(paren
id|ir
)paren
)braket
)paren
suffix:semicolon
id|fpureg_t
id|val
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|val
op_assign
id|mips_get_word
c_func
(paren
id|xcp
comma
id|va
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|fpuemuprivate.stats
dot
id|errors
op_increment
suffix:semicolon
r_return
id|SIGBUS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xcp-&gt;cp0_status
op_amp
id|ST0_FR
)paren
(brace
multiline_comment|/* load whole register */
id|ctx
op_member_access_from_pointer
id|regs
(braket
id|MIPSInst_FD
c_func
(paren
id|ir
)paren
)braket
op_assign
id|val
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|MIPSInst_FD
c_func
(paren
id|ir
)paren
op_amp
l_int|1
)paren
(brace
multiline_comment|/* load to m.s. 32 bits */
macro_line|#if defined(SINGLE_ONLY_FPU)
multiline_comment|/* illegal register in single-float mode */
r_return
id|SIGILL
suffix:semicolon
macro_line|#else
id|ctx
op_member_access_from_pointer
id|regs
(braket
(paren
id|MIPSInst_FD
c_func
(paren
id|ir
)paren
op_amp
op_complement
l_int|1
)paren
)braket
op_and_assign
l_int|0xffffffff
suffix:semicolon
id|ctx
op_member_access_from_pointer
id|regs
(braket
(paren
id|MIPSInst_FD
c_func
(paren
id|ir
)paren
op_amp
op_complement
l_int|1
)paren
)braket
op_or_assign
id|val
op_lshift
l_int|32
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/* load to l.s. 32 bits */
id|ctx
op_member_access_from_pointer
id|regs
(braket
id|MIPSInst_FD
c_func
(paren
id|ir
)paren
)braket
op_and_assign
op_complement
l_int|0xffffffffLL
suffix:semicolon
id|ctx
op_member_access_from_pointer
id|regs
(braket
id|MIPSInst_FD
c_func
(paren
id|ir
)paren
)braket
op_or_assign
id|val
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|swxc1_op
suffix:colon
(brace
r_void
op_star
id|va
op_assign
id|REG_TO_VA
c_func
(paren
id|xcp
op_member_access_from_pointer
id|regs
(braket
id|MIPSInst_FR
c_func
(paren
id|ir
)paren
)braket
op_plus
id|xcp
op_member_access_from_pointer
id|regs
(braket
id|MIPSInst_FT
(paren
id|ir
)paren
)braket
)paren
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
r_if
c_cond
(paren
id|xcp-&gt;cp0_status
op_amp
id|ST0_FR
)paren
(brace
multiline_comment|/* store whole register */
id|val
op_assign
id|ctx
op_member_access_from_pointer
id|regs
(braket
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
op_amp
l_int|1
)paren
(brace
macro_line|#if defined(SINGLE_ONLY_FPU)
multiline_comment|/* illegal register in single-float mode */
r_return
id|SIGILL
suffix:semicolon
macro_line|#else
multiline_comment|/* store from m.s. 32 bits */
id|val
op_assign
id|ctx
op_member_access_from_pointer
id|regs
(braket
(paren
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
op_amp
op_complement
l_int|1
)paren
)braket
op_rshift
l_int|32
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/* store from l.s. 32 bits */
id|val
op_assign
id|ctx
op_member_access_from_pointer
id|regs
(braket
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mips_put_word
c_func
(paren
id|xcp
comma
id|va
comma
id|val
)paren
)paren
(brace
id|fpuemuprivate.stats
dot
id|errors
op_increment
suffix:semicolon
r_return
id|SIGBUS
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|madd_s_op
suffix:colon
id|handler
op_assign
id|fpemu_sp_madd
suffix:semicolon
r_goto
id|scoptop
suffix:semicolon
r_case
id|msub_s_op
suffix:colon
id|handler
op_assign
id|fpemu_sp_msub
suffix:semicolon
r_goto
id|scoptop
suffix:semicolon
r_case
id|nmadd_s_op
suffix:colon
id|handler
op_assign
id|fpemu_sp_nmadd
suffix:semicolon
r_goto
id|scoptop
suffix:semicolon
r_case
id|nmsub_s_op
suffix:colon
id|handler
op_assign
id|fpemu_sp_nmsub
suffix:semicolon
r_goto
id|scoptop
suffix:semicolon
id|scoptop
suffix:colon
id|SPFROMREG
c_func
(paren
id|fr
comma
id|MIPSInst_FR
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|SPFROMREG
c_func
(paren
id|fs
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|SPFROMREG
c_func
(paren
id|ft
comma
id|MIPSInst_FT
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|fd
op_assign
(paren
op_star
id|handler
)paren
(paren
id|fr
comma
id|fs
comma
id|ft
)paren
suffix:semicolon
id|SPTOREG
c_func
(paren
id|fd
comma
id|MIPSInst_FD
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|copcsr
suffix:colon
r_if
c_cond
(paren
id|ieee754_cxtest
c_func
(paren
id|IEEE754_INEXACT
)paren
)paren
id|rcsr
op_or_assign
id|FPU_CSR_INE_X
op_or
id|FPU_CSR_INE_S
suffix:semicolon
r_if
c_cond
(paren
id|ieee754_cxtest
c_func
(paren
id|IEEE754_UNDERFLOW
)paren
)paren
id|rcsr
op_or_assign
id|FPU_CSR_UDF_X
op_or
id|FPU_CSR_UDF_S
suffix:semicolon
r_if
c_cond
(paren
id|ieee754_cxtest
c_func
(paren
id|IEEE754_OVERFLOW
)paren
)paren
id|rcsr
op_or_assign
id|FPU_CSR_OVF_X
op_or
id|FPU_CSR_OVF_S
suffix:semicolon
r_if
c_cond
(paren
id|ieee754_cxtest
(paren
id|IEEE754_INVALID_OPERATION
)paren
)paren
id|rcsr
op_or_assign
id|FPU_CSR_INV_X
op_or
id|FPU_CSR_INV_S
suffix:semicolon
id|ctx-&gt;sr
op_assign
(paren
id|ctx-&gt;sr
op_amp
op_complement
id|FPU_CSR_ALL_X
)paren
op_or
id|rcsr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ctx-&gt;sr
op_rshift
l_int|5
)paren
op_amp
id|ctx
op_member_access_from_pointer
id|sr
op_amp
id|FPU_CSR_ALL_E
)paren
(brace
multiline_comment|/*printk (&quot;SIGFPE: fpu csr = %08x&bslash;n&quot;,ctx-&gt;sr); */
r_return
id|SIGFPE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_return
id|SIGILL
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
macro_line|#if !defined(SINGLE_ONLY_FPU)
r_case
id|d_fmt
suffix:colon
multiline_comment|/* 1 */
(brace
id|ieee754dp
c_func
(paren
op_star
id|handler
)paren
(paren
id|ieee754dp
comma
id|ieee754dp
comma
id|ieee754dp
)paren
suffix:semicolon
id|ieee754dp
id|fd
comma
id|fr
comma
id|fs
comma
id|ft
suffix:semicolon
r_switch
c_cond
(paren
id|MIPSInst_FUNC
c_func
(paren
id|ir
)paren
)paren
(brace
r_case
id|ldxc1_op
suffix:colon
(brace
r_void
op_star
id|va
op_assign
id|REG_TO_VA
c_func
(paren
id|xcp
op_member_access_from_pointer
id|regs
(braket
id|MIPSInst_FR
c_func
(paren
id|ir
)paren
)braket
op_plus
id|xcp
op_member_access_from_pointer
id|regs
(braket
id|MIPSInst_FT
(paren
id|ir
)paren
)braket
)paren
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|ctx-&gt;regs
(braket
id|MIPSInst_FD
c_func
(paren
id|ir
)paren
)braket
op_assign
id|mips_get_dword
c_func
(paren
id|xcp
comma
id|va
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|fpuemuprivate.stats
dot
id|errors
op_increment
suffix:semicolon
r_return
id|SIGBUS
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|sdxc1_op
suffix:colon
(brace
r_void
op_star
id|va
op_assign
id|REG_TO_VA
c_func
(paren
id|xcp
op_member_access_from_pointer
id|regs
(braket
id|MIPSInst_FR
c_func
(paren
id|ir
)paren
)braket
op_plus
id|xcp
op_member_access_from_pointer
id|regs
(braket
id|MIPSInst_FT
(paren
id|ir
)paren
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mips_put_dword
(paren
id|xcp
comma
id|va
comma
id|ctx-&gt;regs
(braket
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)braket
)paren
)paren
(brace
id|fpuemuprivate.stats
dot
id|errors
op_increment
suffix:semicolon
r_return
id|SIGBUS
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|madd_d_op
suffix:colon
id|handler
op_assign
id|fpemu_dp_madd
suffix:semicolon
r_goto
id|dcoptop
suffix:semicolon
r_case
id|msub_d_op
suffix:colon
id|handler
op_assign
id|fpemu_dp_msub
suffix:semicolon
r_goto
id|dcoptop
suffix:semicolon
r_case
id|nmadd_d_op
suffix:colon
id|handler
op_assign
id|fpemu_dp_nmadd
suffix:semicolon
r_goto
id|dcoptop
suffix:semicolon
r_case
id|nmsub_d_op
suffix:colon
id|handler
op_assign
id|fpemu_dp_nmsub
suffix:semicolon
r_goto
id|dcoptop
suffix:semicolon
id|dcoptop
suffix:colon
id|DPFROMREG
c_func
(paren
id|fr
comma
id|MIPSInst_FR
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|DPFROMREG
c_func
(paren
id|fs
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|DPFROMREG
c_func
(paren
id|ft
comma
id|MIPSInst_FT
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|fd
op_assign
(paren
op_star
id|handler
)paren
(paren
id|fr
comma
id|fs
comma
id|ft
)paren
suffix:semicolon
id|DPTOREG
c_func
(paren
id|fd
comma
id|MIPSInst_FD
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
r_goto
id|copcsr
suffix:semicolon
r_default
suffix:colon
r_return
id|SIGILL
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
macro_line|#endif
r_case
l_int|0x7
suffix:colon
multiline_comment|/* 7 */
(brace
r_if
c_cond
(paren
id|MIPSInst_FUNC
c_func
(paren
id|ir
)paren
op_ne
id|pfetch_op
)paren
(brace
r_return
id|SIGILL
suffix:semicolon
)brace
multiline_comment|/* ignore prefx operation */
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_return
id|SIGILL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Emulate a single COP1 arithmetic instruction.&n; */
r_static
r_int
DECL|function|fpu_emu
id|fpu_emu
c_func
(paren
r_struct
id|pt_regs
op_star
id|xcp
comma
r_struct
id|mips_fpu_soft_struct
op_star
id|ctx
comma
id|mips_instruction
id|ir
)paren
(brace
r_int
id|rfmt
suffix:semicolon
multiline_comment|/* resulting format */
r_int
id|rcsr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* resulting csr */
r_int
id|cond
suffix:semicolon
r_union
(brace
id|ieee754dp
id|d
suffix:semicolon
id|ieee754sp
id|s
suffix:semicolon
r_int
id|w
suffix:semicolon
macro_line|#if __mips64
r_int
r_int
id|l
suffix:semicolon
macro_line|#endif
)brace
id|rv
suffix:semicolon
multiline_comment|/* resulting value */
id|fpuemuprivate.stats.cp1ops
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|rfmt
op_assign
(paren
id|MIPSInst_FFMT
c_func
(paren
id|ir
)paren
op_amp
l_int|0xf
)paren
)paren
(brace
r_case
id|s_fmt
suffix:colon
(brace
multiline_comment|/* 0 */
id|ieee754sp
c_func
(paren
op_star
id|handler
)paren
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|MIPSInst_FUNC
c_func
(paren
id|ir
)paren
)paren
(brace
multiline_comment|/* binary ops */
r_case
id|fadd_op
suffix:colon
id|handler
op_assign
id|ieee754sp_add
suffix:semicolon
r_goto
id|scopbop
suffix:semicolon
r_case
id|fsub_op
suffix:colon
id|handler
op_assign
id|ieee754sp_sub
suffix:semicolon
r_goto
id|scopbop
suffix:semicolon
r_case
id|fmul_op
suffix:colon
id|handler
op_assign
id|ieee754sp_mul
suffix:semicolon
r_goto
id|scopbop
suffix:semicolon
r_case
id|fdiv_op
suffix:colon
id|handler
op_assign
id|ieee754sp_div
suffix:semicolon
r_goto
id|scopbop
suffix:semicolon
multiline_comment|/* unary  ops */
macro_line|#if __mips &gt;= 2 || __mips64
r_case
id|fsqrt_op
suffix:colon
id|handler
op_assign
id|ieee754sp_sqrt
suffix:semicolon
r_goto
id|scopuop
suffix:semicolon
macro_line|#endif
macro_line|#if __mips &gt;= 4 &amp;&amp; __mips != 32
r_case
id|frsqrt_op
suffix:colon
id|handler
op_assign
id|fpemu_sp_rsqrt
suffix:semicolon
r_goto
id|scopuop
suffix:semicolon
r_case
id|frecip_op
suffix:colon
id|handler
op_assign
id|fpemu_sp_recip
suffix:semicolon
r_goto
id|scopuop
suffix:semicolon
macro_line|#endif
macro_line|#if __mips &gt;= 4
r_case
id|fmovc_op
suffix:colon
id|cond
op_assign
id|fpucondbit
(braket
id|MIPSInst_FT
c_func
(paren
id|ir
)paren
op_rshift
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|ctx-&gt;sr
op_amp
id|cond
)paren
op_ne
l_int|0
)paren
op_ne
(paren
(paren
id|MIPSInst_FT
c_func
(paren
id|ir
)paren
op_amp
l_int|1
)paren
op_ne
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|SPFROMREG
c_func
(paren
id|rv.s
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|fmovz_op
suffix:colon
r_if
c_cond
(paren
id|xcp-&gt;regs
(braket
id|MIPSInst_FT
c_func
(paren
id|ir
)paren
)braket
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|SPFROMREG
c_func
(paren
id|rv.s
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|fmovn_op
suffix:colon
r_if
c_cond
(paren
id|xcp-&gt;regs
(braket
id|MIPSInst_FT
c_func
(paren
id|ir
)paren
)braket
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|SPFROMREG
c_func
(paren
id|rv.s
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
id|fabs_op
suffix:colon
id|handler
op_assign
id|ieee754sp_abs
suffix:semicolon
r_goto
id|scopuop
suffix:semicolon
r_case
id|fneg_op
suffix:colon
id|handler
op_assign
id|ieee754sp_neg
suffix:semicolon
r_goto
id|scopuop
suffix:semicolon
r_case
id|fmov_op
suffix:colon
multiline_comment|/* an easy one */
id|SPFROMREG
c_func
(paren
id|rv.s
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* binary op on handler */
id|scopbop
suffix:colon
(brace
id|ieee754sp
id|fs
comma
id|ft
suffix:semicolon
id|SPFROMREG
c_func
(paren
id|fs
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|SPFROMREG
c_func
(paren
id|ft
comma
id|MIPSInst_FT
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|rv.s
op_assign
(paren
op_star
id|handler
)paren
(paren
id|fs
comma
id|ft
)paren
suffix:semicolon
r_goto
id|copcsr
suffix:semicolon
)brace
id|scopuop
suffix:colon
(brace
id|ieee754sp
id|fs
suffix:semicolon
id|SPFROMREG
c_func
(paren
id|fs
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|rv.s
op_assign
(paren
op_star
id|handler
)paren
(paren
id|fs
)paren
suffix:semicolon
r_goto
id|copcsr
suffix:semicolon
)brace
id|copcsr
suffix:colon
r_if
c_cond
(paren
id|ieee754_cxtest
c_func
(paren
id|IEEE754_INEXACT
)paren
)paren
id|rcsr
op_or_assign
id|FPU_CSR_INE_X
op_or
id|FPU_CSR_INE_S
suffix:semicolon
r_if
c_cond
(paren
id|ieee754_cxtest
c_func
(paren
id|IEEE754_UNDERFLOW
)paren
)paren
id|rcsr
op_or_assign
id|FPU_CSR_UDF_X
op_or
id|FPU_CSR_UDF_S
suffix:semicolon
r_if
c_cond
(paren
id|ieee754_cxtest
c_func
(paren
id|IEEE754_OVERFLOW
)paren
)paren
id|rcsr
op_or_assign
id|FPU_CSR_OVF_X
op_or
id|FPU_CSR_OVF_S
suffix:semicolon
r_if
c_cond
(paren
id|ieee754_cxtest
c_func
(paren
id|IEEE754_ZERO_DIVIDE
)paren
)paren
id|rcsr
op_or_assign
id|FPU_CSR_DIV_X
op_or
id|FPU_CSR_DIV_S
suffix:semicolon
r_if
c_cond
(paren
id|ieee754_cxtest
(paren
id|IEEE754_INVALID_OPERATION
)paren
)paren
id|rcsr
op_or_assign
id|FPU_CSR_INV_X
op_or
id|FPU_CSR_INV_S
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* unary conv ops */
r_case
id|fcvts_op
suffix:colon
r_return
id|SIGILL
suffix:semicolon
multiline_comment|/* not defined */
r_case
id|fcvtd_op
suffix:colon
macro_line|#if defined(SINGLE_ONLY_FPU)
r_return
id|SIGILL
suffix:semicolon
multiline_comment|/* not defined */
macro_line|#else
(brace
id|ieee754sp
id|fs
suffix:semicolon
id|SPFROMREG
c_func
(paren
id|fs
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|rv.d
op_assign
id|ieee754dp_fsp
c_func
(paren
id|fs
)paren
suffix:semicolon
id|rfmt
op_assign
id|d_fmt
suffix:semicolon
r_goto
id|copcsr
suffix:semicolon
)brace
macro_line|#endif
r_case
id|fcvtw_op
suffix:colon
(brace
id|ieee754sp
id|fs
suffix:semicolon
id|SPFROMREG
c_func
(paren
id|fs
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|rv.w
op_assign
id|ieee754sp_tint
c_func
(paren
id|fs
)paren
suffix:semicolon
id|rfmt
op_assign
id|w_fmt
suffix:semicolon
r_goto
id|copcsr
suffix:semicolon
)brace
macro_line|#if __mips &gt;= 2 || __mips64
r_case
id|fround_op
suffix:colon
r_case
id|ftrunc_op
suffix:colon
r_case
id|fceil_op
suffix:colon
r_case
id|ffloor_op
suffix:colon
(brace
r_int
r_int
id|oldrm
op_assign
id|ieee754_csr.rm
suffix:semicolon
id|ieee754sp
id|fs
suffix:semicolon
id|SPFROMREG
c_func
(paren
id|fs
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|ieee754_csr.rm
op_assign
id|ieee_rm
(braket
id|MIPSInst_FUNC
c_func
(paren
id|ir
)paren
op_amp
l_int|0x3
)braket
suffix:semicolon
id|rv.w
op_assign
id|ieee754sp_tint
c_func
(paren
id|fs
)paren
suffix:semicolon
id|ieee754_csr.rm
op_assign
id|oldrm
suffix:semicolon
id|rfmt
op_assign
id|w_fmt
suffix:semicolon
r_goto
id|copcsr
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;/* __mips &gt;= 2 */
macro_line|#if __mips64 &amp;&amp; !defined(SINGLE_ONLY_FPU)
r_case
id|fcvtl_op
suffix:colon
(brace
id|ieee754sp
id|fs
suffix:semicolon
id|SPFROMREG
c_func
(paren
id|fs
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|rv.l
op_assign
id|ieee754sp_tlong
c_func
(paren
id|fs
)paren
suffix:semicolon
id|rfmt
op_assign
id|l_fmt
suffix:semicolon
r_goto
id|copcsr
suffix:semicolon
)brace
r_case
id|froundl_op
suffix:colon
r_case
id|ftruncl_op
suffix:colon
r_case
id|fceill_op
suffix:colon
r_case
id|ffloorl_op
suffix:colon
(brace
r_int
r_int
id|oldrm
op_assign
id|ieee754_csr.rm
suffix:semicolon
id|ieee754sp
id|fs
suffix:semicolon
id|SPFROMREG
c_func
(paren
id|fs
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|ieee754_csr.rm
op_assign
id|ieee_rm
(braket
id|MIPSInst_FUNC
c_func
(paren
id|ir
)paren
op_amp
l_int|0x3
)braket
suffix:semicolon
id|rv.l
op_assign
id|ieee754sp_tlong
c_func
(paren
id|fs
)paren
suffix:semicolon
id|ieee754_csr.rm
op_assign
id|oldrm
suffix:semicolon
id|rfmt
op_assign
id|l_fmt
suffix:semicolon
r_goto
id|copcsr
suffix:semicolon
)brace
macro_line|#endif /* __mips64 &amp;&amp; !fpu(single) */
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|MIPSInst_FUNC
c_func
(paren
id|ir
)paren
op_ge
id|fcmp_op
)paren
(brace
r_int
id|cmpop
op_assign
id|MIPSInst_FUNC
c_func
(paren
id|ir
)paren
op_minus
id|fcmp_op
suffix:semicolon
id|ieee754sp
id|fs
comma
id|ft
suffix:semicolon
id|SPFROMREG
c_func
(paren
id|fs
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|SPFROMREG
c_func
(paren
id|ft
comma
id|MIPSInst_FT
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|rv.w
op_assign
id|ieee754sp_cmp
c_func
(paren
id|fs
comma
id|ft
comma
id|cmptab
(braket
id|cmpop
op_amp
l_int|0x7
)braket
)paren
suffix:semicolon
id|rfmt
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmpop
op_amp
l_int|0x8
)paren
op_logical_and
id|ieee754_cxtest
c_func
(paren
id|IEEE754_INVALID_OPERATION
)paren
)paren
id|rcsr
op_assign
id|FPU_CSR_INV_X
op_or
id|FPU_CSR_INV_S
suffix:semicolon
)brace
r_else
(brace
r_return
id|SIGILL
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
macro_line|#if !defined(SINGLE_ONLY_FPU)
r_case
id|d_fmt
suffix:colon
(brace
id|ieee754dp
c_func
(paren
op_star
id|handler
)paren
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|MIPSInst_FUNC
c_func
(paren
id|ir
)paren
)paren
(brace
multiline_comment|/* binary ops */
r_case
id|fadd_op
suffix:colon
id|handler
op_assign
id|ieee754dp_add
suffix:semicolon
r_goto
id|dcopbop
suffix:semicolon
r_case
id|fsub_op
suffix:colon
id|handler
op_assign
id|ieee754dp_sub
suffix:semicolon
r_goto
id|dcopbop
suffix:semicolon
r_case
id|fmul_op
suffix:colon
id|handler
op_assign
id|ieee754dp_mul
suffix:semicolon
r_goto
id|dcopbop
suffix:semicolon
r_case
id|fdiv_op
suffix:colon
id|handler
op_assign
id|ieee754dp_div
suffix:semicolon
r_goto
id|dcopbop
suffix:semicolon
multiline_comment|/* unary  ops */
macro_line|#if __mips &gt;= 2 || __mips64
r_case
id|fsqrt_op
suffix:colon
id|handler
op_assign
id|ieee754dp_sqrt
suffix:semicolon
r_goto
id|dcopuop
suffix:semicolon
macro_line|#endif
macro_line|#if __mips &gt;= 4 &amp;&amp; __mips != 32
r_case
id|frsqrt_op
suffix:colon
id|handler
op_assign
id|fpemu_dp_rsqrt
suffix:semicolon
r_goto
id|dcopuop
suffix:semicolon
r_case
id|frecip_op
suffix:colon
id|handler
op_assign
id|fpemu_dp_recip
suffix:semicolon
r_goto
id|dcopuop
suffix:semicolon
macro_line|#endif
macro_line|#if __mips &gt;= 4
r_case
id|fmovc_op
suffix:colon
id|cond
op_assign
id|fpucondbit
(braket
id|MIPSInst_FT
c_func
(paren
id|ir
)paren
op_rshift
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|ctx-&gt;sr
op_amp
id|cond
)paren
op_ne
l_int|0
)paren
op_ne
(paren
(paren
id|MIPSInst_FT
c_func
(paren
id|ir
)paren
op_amp
l_int|1
)paren
op_ne
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|DPFROMREG
c_func
(paren
id|rv.d
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|fmovz_op
suffix:colon
r_if
c_cond
(paren
id|xcp-&gt;regs
(braket
id|MIPSInst_FT
c_func
(paren
id|ir
)paren
)braket
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|DPFROMREG
c_func
(paren
id|rv.d
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|fmovn_op
suffix:colon
r_if
c_cond
(paren
id|xcp-&gt;regs
(braket
id|MIPSInst_FT
c_func
(paren
id|ir
)paren
)braket
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|DPFROMREG
c_func
(paren
id|rv.d
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
id|fabs_op
suffix:colon
id|handler
op_assign
id|ieee754dp_abs
suffix:semicolon
r_goto
id|dcopuop
suffix:semicolon
r_case
id|fneg_op
suffix:colon
id|handler
op_assign
id|ieee754dp_neg
suffix:semicolon
r_goto
id|dcopuop
suffix:semicolon
r_case
id|fmov_op
suffix:colon
multiline_comment|/* an easy one */
id|DPFROMREG
c_func
(paren
id|rv.d
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* binary op on handler */
id|dcopbop
suffix:colon
(brace
id|ieee754dp
id|fs
comma
id|ft
suffix:semicolon
id|DPFROMREG
c_func
(paren
id|fs
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|DPFROMREG
c_func
(paren
id|ft
comma
id|MIPSInst_FT
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|rv.d
op_assign
(paren
op_star
id|handler
)paren
(paren
id|fs
comma
id|ft
)paren
suffix:semicolon
r_goto
id|copcsr
suffix:semicolon
)brace
id|dcopuop
suffix:colon
(brace
id|ieee754dp
id|fs
suffix:semicolon
id|DPFROMREG
c_func
(paren
id|fs
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|rv.d
op_assign
(paren
op_star
id|handler
)paren
(paren
id|fs
)paren
suffix:semicolon
r_goto
id|copcsr
suffix:semicolon
)brace
multiline_comment|/* unary conv ops */
r_case
id|fcvts_op
suffix:colon
(brace
id|ieee754dp
id|fs
suffix:semicolon
id|DPFROMREG
c_func
(paren
id|fs
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|rv.s
op_assign
id|ieee754sp_fdp
c_func
(paren
id|fs
)paren
suffix:semicolon
id|rfmt
op_assign
id|s_fmt
suffix:semicolon
r_goto
id|copcsr
suffix:semicolon
)brace
r_case
id|fcvtd_op
suffix:colon
r_return
id|SIGILL
suffix:semicolon
multiline_comment|/* not defined */
r_case
id|fcvtw_op
suffix:colon
(brace
id|ieee754dp
id|fs
suffix:semicolon
id|DPFROMREG
c_func
(paren
id|fs
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|rv.w
op_assign
id|ieee754dp_tint
c_func
(paren
id|fs
)paren
suffix:semicolon
multiline_comment|/* wrong */
id|rfmt
op_assign
id|w_fmt
suffix:semicolon
r_goto
id|copcsr
suffix:semicolon
)brace
macro_line|#if __mips &gt;= 2 || __mips64
r_case
id|fround_op
suffix:colon
r_case
id|ftrunc_op
suffix:colon
r_case
id|fceil_op
suffix:colon
r_case
id|ffloor_op
suffix:colon
(brace
r_int
r_int
id|oldrm
op_assign
id|ieee754_csr.rm
suffix:semicolon
id|ieee754dp
id|fs
suffix:semicolon
id|DPFROMREG
c_func
(paren
id|fs
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|ieee754_csr.rm
op_assign
id|ieee_rm
(braket
id|MIPSInst_FUNC
c_func
(paren
id|ir
)paren
op_amp
l_int|0x3
)braket
suffix:semicolon
id|rv.w
op_assign
id|ieee754dp_tint
c_func
(paren
id|fs
)paren
suffix:semicolon
id|ieee754_csr.rm
op_assign
id|oldrm
suffix:semicolon
id|rfmt
op_assign
id|w_fmt
suffix:semicolon
r_goto
id|copcsr
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if __mips64 &amp;&amp; !defined(SINGLE_ONLY_FPU)
r_case
id|fcvtl_op
suffix:colon
(brace
id|ieee754dp
id|fs
suffix:semicolon
id|DPFROMREG
c_func
(paren
id|fs
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|rv.l
op_assign
id|ieee754dp_tlong
c_func
(paren
id|fs
)paren
suffix:semicolon
id|rfmt
op_assign
id|l_fmt
suffix:semicolon
r_goto
id|copcsr
suffix:semicolon
)brace
r_case
id|froundl_op
suffix:colon
r_case
id|ftruncl_op
suffix:colon
r_case
id|fceill_op
suffix:colon
r_case
id|ffloorl_op
suffix:colon
(brace
r_int
r_int
id|oldrm
op_assign
id|ieee754_csr.rm
suffix:semicolon
id|ieee754dp
id|fs
suffix:semicolon
id|DPFROMREG
c_func
(paren
id|fs
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|ieee754_csr.rm
op_assign
id|ieee_rm
(braket
id|MIPSInst_FUNC
c_func
(paren
id|ir
)paren
op_amp
l_int|0x3
)braket
suffix:semicolon
id|rv.l
op_assign
id|ieee754dp_tlong
c_func
(paren
id|fs
)paren
suffix:semicolon
id|ieee754_csr.rm
op_assign
id|oldrm
suffix:semicolon
id|rfmt
op_assign
id|l_fmt
suffix:semicolon
r_goto
id|copcsr
suffix:semicolon
)brace
macro_line|#endif /* __mips &gt;= 3 &amp;&amp; !fpu(single) */
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|MIPSInst_FUNC
c_func
(paren
id|ir
)paren
op_ge
id|fcmp_op
)paren
(brace
r_int
id|cmpop
op_assign
id|MIPSInst_FUNC
c_func
(paren
id|ir
)paren
op_minus
id|fcmp_op
suffix:semicolon
id|ieee754dp
id|fs
comma
id|ft
suffix:semicolon
id|DPFROMREG
c_func
(paren
id|fs
comma
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|DPFROMREG
c_func
(paren
id|ft
comma
id|MIPSInst_FT
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
id|rv.w
op_assign
id|ieee754dp_cmp
c_func
(paren
id|fs
comma
id|ft
comma
id|cmptab
(braket
id|cmpop
op_amp
l_int|0x7
)braket
)paren
suffix:semicolon
id|rfmt
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmpop
op_amp
l_int|0x8
)paren
op_logical_and
id|ieee754_cxtest
(paren
id|IEEE754_INVALID_OPERATION
)paren
)paren
id|rcsr
op_assign
id|FPU_CSR_INV_X
op_or
id|FPU_CSR_INV_S
suffix:semicolon
)brace
r_else
(brace
r_return
id|SIGILL
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* !defined(SINGLE_ONLY_FPU) */
r_case
id|w_fmt
suffix:colon
(brace
r_switch
c_cond
(paren
id|MIPSInst_FUNC
c_func
(paren
id|ir
)paren
)paren
(brace
r_case
id|fcvts_op
suffix:colon
multiline_comment|/* convert word to single precision real */
id|rv.s
op_assign
id|ieee754sp_fint
c_func
(paren
id|ctx
op_member_access_from_pointer
id|regs
(braket
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)braket
)paren
suffix:semicolon
id|rfmt
op_assign
id|s_fmt
suffix:semicolon
r_goto
id|copcsr
suffix:semicolon
macro_line|#if !defined(SINGLE_ONLY_FPU)
r_case
id|fcvtd_op
suffix:colon
multiline_comment|/* convert word to double precision real */
id|rv.d
op_assign
id|ieee754dp_fint
c_func
(paren
id|ctx
op_member_access_from_pointer
id|regs
(braket
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)braket
)paren
suffix:semicolon
id|rfmt
op_assign
id|d_fmt
suffix:semicolon
r_goto
id|copcsr
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
r_return
id|SIGILL
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
macro_line|#if __mips64 &amp;&amp; !defined(SINGLE_ONLY_FPU)
r_case
id|l_fmt
suffix:colon
(brace
r_switch
c_cond
(paren
id|MIPSInst_FUNC
c_func
(paren
id|ir
)paren
)paren
(brace
r_case
id|fcvts_op
suffix:colon
multiline_comment|/* convert long to single precision real */
id|rv.s
op_assign
id|ieee754sp_flong
c_func
(paren
id|ctx
op_member_access_from_pointer
id|regs
(braket
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)braket
)paren
suffix:semicolon
id|rfmt
op_assign
id|s_fmt
suffix:semicolon
r_goto
id|copcsr
suffix:semicolon
r_case
id|fcvtd_op
suffix:colon
multiline_comment|/* convert long to double precision real */
id|rv.d
op_assign
id|ieee754dp_flong
c_func
(paren
id|ctx
op_member_access_from_pointer
id|regs
(braket
id|MIPSInst_FS
c_func
(paren
id|ir
)paren
)braket
)paren
suffix:semicolon
id|rfmt
op_assign
id|d_fmt
suffix:semicolon
r_goto
id|copcsr
suffix:semicolon
r_default
suffix:colon
r_return
id|SIGILL
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
macro_line|#endif
r_default
suffix:colon
r_return
id|SIGILL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Update the fpu CSR register for this operation.&n;&t; * If an exception is required, generate a tidy SIGFPE exception,&n;&t; * without updating the result register.&n;&t; * Note: cause exception bits do not accumulate, they are rewritten&n;&t; * for each op; only the flag/sticky bits accumulate.&n;&t; */
id|ctx-&gt;sr
op_assign
(paren
id|ctx-&gt;sr
op_amp
op_complement
id|FPU_CSR_ALL_X
)paren
op_or
id|rcsr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ctx-&gt;sr
op_rshift
l_int|5
)paren
op_amp
id|ctx-&gt;sr
op_amp
id|FPU_CSR_ALL_E
)paren
(brace
multiline_comment|/*printk (&quot;SIGFPE: fpu csr = %08x&bslash;n&quot;,ctx-&gt;sr); */
r_return
id|SIGFPE
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * Now we can safely write the result back to the register file.&n;&t; */
r_switch
c_cond
(paren
id|rfmt
)paren
(brace
r_case
op_minus
l_int|1
suffix:colon
(brace
macro_line|#if __mips &gt;= 4
id|cond
op_assign
id|fpucondbit
(braket
id|MIPSInst_FD
c_func
(paren
id|ir
)paren
op_rshift
l_int|2
)braket
suffix:semicolon
macro_line|#else
id|cond
op_assign
id|FPU_CSR_COND
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|rv.w
)paren
id|ctx-&gt;sr
op_or_assign
id|cond
suffix:semicolon
r_else
id|ctx-&gt;sr
op_and_assign
op_complement
id|cond
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#if !defined(SINGLE_ONLY_FPU)
r_case
id|d_fmt
suffix:colon
id|DPTOREG
c_func
(paren
id|rv.d
comma
id|MIPSInst_FD
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
id|s_fmt
suffix:colon
id|SPTOREG
c_func
(paren
id|rv.s
comma
id|MIPSInst_FD
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|w_fmt
suffix:colon
id|SITOREG
c_func
(paren
id|rv.w
comma
id|MIPSInst_FD
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#if __mips64 &amp;&amp; !defined(SINGLE_ONLY_FPU)
r_case
id|l_fmt
suffix:colon
id|DITOREG
c_func
(paren
id|rv.l
comma
id|MIPSInst_FD
c_func
(paren
id|ir
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
r_return
id|SIGILL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Emulate the floating point instruction at EPC, and continue&n; * to run until we hit a non-fp instruction, or a backward&n; * branch.  This cuts down dramatically on the per instruction &n; * exception overhead.&n; */
DECL|function|fpu_emulator_cop1Handler
r_int
id|fpu_emulator_cop1Handler
c_func
(paren
r_int
id|xcptno
comma
r_struct
id|pt_regs
op_star
id|xcp
)paren
(brace
r_struct
id|mips_fpu_soft_struct
op_star
id|ctx
op_assign
op_amp
id|current-&gt;thread.fpu.soft
suffix:semicolon
r_int
r_int
id|oldepc
comma
id|prevepc
suffix:semicolon
r_int
r_int
id|insn
suffix:semicolon
r_int
id|sig
op_assign
l_int|0
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|oldepc
op_assign
id|xcp-&gt;cp0_epc
suffix:semicolon
r_do
(brace
id|prevepc
op_assign
id|xcp-&gt;cp0_epc
suffix:semicolon
id|insn
op_assign
id|mips_get_word
c_func
(paren
id|xcp
comma
id|REG_TO_VA
c_func
(paren
id|xcp-&gt;cp0_epc
)paren
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|fpuemuprivate.stats.errors
op_increment
suffix:semicolon
r_return
id|SIGBUS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|insn
op_ne
l_int|0
)paren
id|sig
op_assign
id|cop1Emulate
c_func
(paren
id|xcptno
comma
id|xcp
comma
id|ctx
)paren
suffix:semicolon
r_else
id|xcp-&gt;cp0_epc
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/* skip nops */
)brace
r_while
c_loop
(paren
id|xcp-&gt;cp0_epc
OG
id|prevepc
op_logical_and
id|sig
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* SIGILL indicates a non-fpu instruction */
r_if
c_cond
(paren
id|sig
op_eq
id|SIGILL
op_logical_and
id|xcp-&gt;cp0_epc
op_ne
id|oldepc
)paren
multiline_comment|/* but if epc has advanced, then ignore it */
id|sig
op_assign
l_int|0
suffix:semicolon
r_return
id|sig
suffix:semicolon
)brace
macro_line|#ifdef NOTDEF
multiline_comment|/*&n; * Patch up the hardware fpu state when an f.p. exception occurs.  &n; */
DECL|function|cop1Patcher
r_static
r_int
id|cop1Patcher
c_func
(paren
r_int
id|xcptno
comma
r_struct
id|pt_regs
op_star
id|xcp
)paren
(brace
r_struct
id|mips_fpu_soft_struct
op_star
id|ctx
op_assign
op_amp
id|current-&gt;thread.fpu.soft
suffix:semicolon
r_int
id|sr
suffix:semicolon
r_int
id|sig
suffix:semicolon
multiline_comment|/* reenable Cp1, else fpe_save() will get nested exception */
id|sr
op_assign
id|mips_bissr
c_func
(paren
id|ST0_CU1
)paren
suffix:semicolon
multiline_comment|/* get fpu registers and status, then clear pending exceptions */
id|fpe_save
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|fpe_setsr
c_func
(paren
id|ctx-&gt;sr
op_and_assign
op_complement
id|FPU_CSR_ALL_X
)paren
suffix:semicolon
multiline_comment|/* get current rounding mode for IEEE library, and emulate insn */
id|ieee754_csr.rm
op_assign
id|ieee_rm
(braket
id|ctx-&gt;sr
op_amp
l_int|0x3
)braket
suffix:semicolon
id|sig
op_assign
id|cop1Emulate
c_func
(paren
id|xcptno
comma
id|xcp
comma
id|ctx
)paren
suffix:semicolon
multiline_comment|/* don&squot;t return with f.p. exceptions pending */
id|ctx-&gt;sr
op_and_assign
op_complement
id|FPU_CSR_ALL_X
suffix:semicolon
id|fpe_restore
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|mips_setsr
c_func
(paren
id|sr
)paren
suffix:semicolon
r_return
id|sig
suffix:semicolon
)brace
DECL|function|_cop1_init
r_void
id|_cop1_init
c_func
(paren
r_int
id|emulate
)paren
(brace
r_extern
r_int
id|_nofpu
suffix:semicolon
r_if
c_cond
(paren
id|emulate
)paren
(brace
multiline_comment|/* &n;&t;&t; * Install cop1 emulator to handle &quot;coprocessor unusable&quot; exception&n;&t;&t; */
id|xcption
c_func
(paren
id|XCPTCPU
comma
id|cop1Handler
)paren
suffix:semicolon
id|fpuemuactive
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* tell dbg.c that we are in charge */
id|_nofpu
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* tell setjmp() it &quot;has&quot; an fpu */
)brace
r_else
(brace
multiline_comment|/* &n;&t;&t; * Install cop1 emulator for floating point exceptions only,&n;&t;&t; * i.e. denormalised results, underflow, overflow etc, which&n;&t;&t; * must be emulated in s/w.&n;&t;&t; */
macro_line|#ifdef 1
multiline_comment|/* r4000 or above use dedicate exception */
id|xcption
c_func
(paren
id|XCPTFPE
comma
id|cop1Patcher
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* r3000 et al use interrupt */
r_extern
r_int
id|_sbd_getfpuintr
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|intno
op_assign
id|_sbd_getfpuintr
c_func
(paren
)paren
suffix:semicolon
id|intrupt
c_func
(paren
id|intno
comma
id|cop1Patcher
comma
l_int|0
)paren
suffix:semicolon
id|mips_bissr
c_func
(paren
id|SR_IM0
op_lshift
id|intno
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if (#cpu(r4640) || #cpu(r4650)) &amp;&amp; !defined(SINGLE_ONLY_FPU)
multiline_comment|/* For R4640/R4650 compiled *without* the -msingle-float flag,&n;&t;&t;   then we share responsibility: the h/w handles the single&n;&t;&t;   precision operations, and the trap emulator handles the&n;&t;&t;   double precision. We set fpuemuactive so that dbg.c first&n;&t;&t;   fetches the s/w state before saving the h/w state. */
id|fpuemuactive
op_assign
l_int|1
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* initialise the unused d.p high order words to be NaN */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
id|current-&gt;thread.fpu.soft.regs
(braket
id|i
)braket
op_assign
l_int|0x7ff80bad00000000LL
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* (r4640 || r4650) &amp;&amp; !fpu(single) */
)brace
)brace
macro_line|#endif
eof
