multiline_comment|/*&n; * IRQ vector handles&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1995, 1996, 1997 by Ralf Baechle&n; * Copyright (C) 2001 by Liam Davies (ldavies@agile.tv)&n; *&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt;
macro_line|#include &lt;asm/i8259.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/mipsregs.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/cobalt/cobalt.h&gt;
multiline_comment|/* Cobalt Exception handler */
r_extern
r_void
id|cobalt_handle_int
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* Via masking routines */
r_extern
r_void
id|unmask_irq
c_func
(paren
r_int
r_int
id|irqr
)paren
suffix:semicolon
r_extern
r_void
id|mask_irq
c_func
(paren
r_int
r_int
id|irq
)paren
suffix:semicolon
multiline_comment|/*&n; * We have two types of interrupts that we handle, ones that come&n; *  in through the CPU interrupt lines, and ones that come in on&n; *  the via chip. The CPU mappings are:&n; *    0,1 - S/W (ignored)&n; *    2   - Galileo chip (timer)&n; *    3   - Tulip 0 + NCR SCSI&n; *    4   - Tulip 1&n; *    5   - 16550 UART&n; *    6   - VIA southbridge PIC&n; *    7   - unused&n; *&n; * The VIA chip is a master/slave 8259 setup and has the&n; *  following interrupts&n; *    8   - RTC&n; *    9   - PCI&n; *    14  - IDE0&n; *    15  - IDE1&n; *&n; * In the table we use a 1 to indicate that we use a VIA interrupt&n; *  line, and IE_IRQx to indicate that we use a CPU interrupt line&n; *&n; * We map all of these onto linux IRQ #s 0-15 and forget the rest&n; */
DECL|macro|NOINT_LINE
mdefine_line|#define NOINT_LINE&t;0
DECL|macro|CPUINT_LINE
mdefine_line|#define CPUINT_LINE(x)&t;IE_IRQ##x
DECL|macro|VIAINT_LINE
mdefine_line|#define VIAINT_LINE&t;1
DECL|macro|COBALT_IRQS
mdefine_line|#define COBALT_IRQS&t;16
DECL|variable|irqnr_to_type
r_static
r_int
r_int
id|irqnr_to_type
(braket
id|COBALT_IRQS
)braket
op_assign
(brace
id|CPUINT_LINE
c_func
(paren
l_int|0
)paren
comma
id|NOINT_LINE
comma
id|VIAINT_LINE
comma
id|NOINT_LINE
comma
id|CPUINT_LINE
c_func
(paren
l_int|1
)paren
comma
id|NOINT_LINE
comma
id|NOINT_LINE
comma
id|CPUINT_LINE
c_func
(paren
l_int|3
)paren
comma
id|VIAINT_LINE
comma
id|VIAINT_LINE
comma
id|NOINT_LINE
comma
id|NOINT_LINE
comma
id|NOINT_LINE
comma
id|CPUINT_LINE
c_func
(paren
l_int|2
)paren
comma
id|VIAINT_LINE
comma
id|VIAINT_LINE
)brace
suffix:semicolon
multiline_comment|/*&n; * Cobalt CPU irq&n; */
DECL|function|enable_cpu_irq
r_static
r_void
id|enable_cpu_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|change_c0_status
c_func
(paren
id|irqnr_to_type
(braket
id|irq
)braket
comma
id|irqnr_to_type
(braket
id|irq
)braket
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|startup_cpu_irq
r_static
r_int
id|startup_cpu_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
id|enable_cpu_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|disable_cpu_irq
r_static
r_void
id|disable_cpu_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|change_c0_status
c_func
(paren
id|irqnr_to_type
(braket
id|irq
)braket
comma
op_complement
(paren
id|irqnr_to_type
(braket
id|irq
)braket
)paren
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|macro|shutdown_cpu_irq
mdefine_line|#define shutdown_cpu_irq&t;disable_cpu_irq
DECL|macro|mask_and_ack_cpu_irq
mdefine_line|#define mask_and_ack_cpu_irq&t;disable_cpu_irq
DECL|function|end_cpu_irq
r_static
r_void
id|end_cpu_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|irq_desc
(braket
id|irq
)braket
dot
id|status
op_amp
(paren
id|IRQ_DISABLED
op_or
id|IRQ_INPROGRESS
)paren
)paren
)paren
id|enable_cpu_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
DECL|variable|cobalt_cpu_irq_type
r_static
r_struct
id|hw_interrupt_type
id|cobalt_cpu_irq_type
op_assign
(brace
l_string|&quot;Cobalt CPU&quot;
comma
id|startup_cpu_irq
comma
id|shutdown_cpu_irq
comma
id|enable_cpu_irq
comma
id|disable_cpu_irq
comma
id|mask_and_ack_cpu_irq
comma
id|end_cpu_irq
comma
l_int|NULL
)brace
suffix:semicolon
DECL|function|init_IRQ
r_void
id|__init
id|init_IRQ
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Initialise all of the IRQ descriptors */
id|init_i8259_irqs
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Map the irqnr to the type int we have */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|COBALT_IRQS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|irqnr_to_type
(braket
id|i
)braket
op_ge
id|CPUINT_LINE
c_func
(paren
l_int|0
)paren
)paren
multiline_comment|/* cobalt_cpu_irq_type */
id|irq_desc
(braket
id|i
)braket
dot
id|handler
op_assign
op_amp
id|cobalt_cpu_irq_type
suffix:semicolon
)brace
multiline_comment|/* Mask all cpu interrupts&n;&t;    (except IE4, we already masked those at VIA level) */
id|clear_c0_status
c_func
(paren
id|ST0_IM
)paren
suffix:semicolon
id|set_c0_status
c_func
(paren
id|IE_IRQ4
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|set_except_vector
c_func
(paren
l_int|0
comma
id|cobalt_handle_int
)paren
suffix:semicolon
)brace
eof
