multiline_comment|/*&n; * Copyright 2001 MontaVista Software Inc.&n; * Author: jsun@mvista.com or jsun@junsun.net&n; *&n; * rtc and time ops for vr4181.&t; Part of code is drived from&n; * linux-vr, originally written&t; by Bradley D. LaRonde &amp; Michael Klar.&n; *&n; * This program is free software; you can redistribute&t;it and/or modify it&n; * under  the terms of&t;the GNU General&t; Public License as published by the&n; * Free Software Foundation;  either version 2 of the  License, or (at your&n; * option) any later version.&n; *&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/param.h&gt;&t;&t;&t;/* for HZ */
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/time.h&gt;
macro_line|#include &lt;asm/vr4181/vr4181.h&gt;
DECL|macro|COUNTS_PER_JIFFY
mdefine_line|#define COUNTS_PER_JIFFY ((32768 + HZ/2) / HZ)
multiline_comment|/*&n; * RTC ops&n; */
DECL|variable|rtc_lock
id|DEFINE_SPINLOCK
c_func
(paren
id|rtc_lock
)paren
suffix:semicolon
multiline_comment|/* per VR41xx docs, bad data can be read if between 2 counts */
r_static
r_inline
r_int
r_int
DECL|function|read_time_reg
id|read_time_reg
c_func
(paren
r_volatile
r_int
r_int
op_star
id|reg
)paren
(brace
r_int
r_int
id|value
suffix:semicolon
r_do
(brace
id|value
op_assign
op_star
id|reg
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|value
op_ne
op_star
id|reg
)paren
suffix:semicolon
r_return
id|value
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|vr4181_rtc_get_time
id|vr4181_rtc_get_time
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|regh
comma
id|regm
comma
id|regl
suffix:semicolon
singleline_comment|// why this crazy order, you ask?  to guarantee that neither m
singleline_comment|// nor l wrap before all 3 read
r_do
(brace
id|regm
op_assign
id|read_time_reg
c_func
(paren
id|VR4181_ETIMEMREG
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|regh
op_assign
id|read_time_reg
c_func
(paren
id|VR4181_ETIMEHREG
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|regl
op_assign
id|read_time_reg
c_func
(paren
id|VR4181_ETIMELREG
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|regm
op_ne
id|read_time_reg
c_func
(paren
id|VR4181_ETIMEMREG
)paren
)paren
suffix:semicolon
r_return
(paren
(paren
id|regh
op_lshift
l_int|17
)paren
op_or
(paren
id|regm
op_lshift
l_int|1
)paren
op_or
(paren
id|regl
op_rshift
l_int|15
)paren
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|vr4181_rtc_set_time
id|vr4181_rtc_set_time
c_func
(paren
r_int
r_int
id|timeval
)paren
(brace
r_int
r_int
id|intreg
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|rtc_lock
comma
id|flags
)paren
suffix:semicolon
id|intreg
op_assign
op_star
id|VR4181_RTCINTREG
op_amp
l_int|0x05
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
op_star
id|VR4181_ETIMELREG
op_assign
id|timeval
op_lshift
l_int|15
suffix:semicolon
op_star
id|VR4181_ETIMEMREG
op_assign
id|timeval
op_rshift
l_int|1
suffix:semicolon
op_star
id|VR4181_ETIMEHREG
op_assign
id|timeval
op_rshift
l_int|17
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// assume that any ints that just triggered are invalid, since the
singleline_comment|// time value is written non-atomically in 3 separate regs
op_star
id|VR4181_RTCINTREG
op_assign
l_int|0x05
op_xor
id|intreg
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|rtc_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * timer interrupt routine (wrapper)&n; *&n; * we need our own interrupt routine because we need to clear&n; * RTC1 interrupt.&n; */
r_static
r_void
DECL|function|vr4181_timer_interrupt
id|vr4181_timer_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* Clear the interrupt. */
op_star
id|VR4181_RTCINTREG
op_assign
l_int|0x2
suffix:semicolon
multiline_comment|/* call the generic one */
id|timer_interrupt
c_func
(paren
id|irq
comma
id|dev_id
comma
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * vr4181_time_init:&n; *&n; * We pick the following choices:&n; *   . we use elapsed timer as the RTC.&t; We set some reasonable init data since&n; *     it does not persist across reset&n; *   . we use RTC1 as the system timer interrupt source.&n; *   . we use CPU counter for fast_gettimeoffset and we calivrate the cpu&n; *     frequency.  In other words, we use calibrate_div64_gettimeoffset().&n; *   . we use our own timer interrupt routine which clears the interrupt&n; *     and then calls the generic high-level timer interrupt routine.&n; *&n; */
r_extern
r_int
id|setup_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_struct
id|irqaction
op_star
id|irqaction
)paren
suffix:semicolon
r_static
r_void
DECL|function|vr4181_timer_setup
id|vr4181_timer_setup
c_func
(paren
r_struct
id|irqaction
op_star
id|irq
)paren
(brace
multiline_comment|/* over-write the handler to be our own one */
id|irq-&gt;handler
op_assign
id|vr4181_timer_interrupt
suffix:semicolon
multiline_comment|/* sets up the frequency */
op_star
id|VR4181_RTCL1LREG
op_assign
id|COUNTS_PER_JIFFY
suffix:semicolon
op_star
id|VR4181_RTCL1HREG
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* and ack any pending ints */
op_star
id|VR4181_RTCINTREG
op_assign
l_int|0x2
suffix:semicolon
multiline_comment|/* setup irqaction */
id|setup_irq
c_func
(paren
id|VR4181_IRQ_INT1
comma
id|irq
)paren
suffix:semicolon
)brace
r_void
DECL|function|vr4181_init_time
id|vr4181_init_time
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* setup hookup functions */
id|rtc_get_time
op_assign
id|vr4181_rtc_get_time
suffix:semicolon
id|rtc_set_time
op_assign
id|vr4181_rtc_set_time
suffix:semicolon
id|board_timer_setup
op_assign
id|vr4181_timer_setup
suffix:semicolon
)brace
eof
