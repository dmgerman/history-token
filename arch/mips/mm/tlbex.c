multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Synthesize TLB refill handlers at runtime.&n; *&n; * Copyright (C) 2004,2005 by Thiemo Seufer&n; */
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/cacheflush.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/inst.h&gt;
macro_line|#include &lt;asm/elf.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/war.h&gt;
multiline_comment|/* #define DEBUG_TLB */
DECL|function|r45k_bvahwbug
r_static
id|__init
r_int
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
id|r45k_bvahwbug
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* XXX: We should probe for the presence of this bug, but we don&squot;t. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|r4k_250MHZhwbug
r_static
id|__init
r_int
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
id|r4k_250MHZhwbug
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* XXX: We should probe for the presence of this bug, but we don&squot;t. */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bcm1250_m3_war
r_static
id|__init
r_int
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
id|bcm1250_m3_war
c_func
(paren
r_void
)paren
(brace
r_return
id|BCM1250_M3_WAR
suffix:semicolon
)brace
DECL|function|r10000_llsc_war
r_static
id|__init
r_int
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
id|r10000_llsc_war
c_func
(paren
r_void
)paren
(brace
r_return
id|R10000_LLSC_WAR
suffix:semicolon
)brace
multiline_comment|/*&n; * A little micro-assembler, intended for TLB refill handler&n; * synthesizing. It is intentionally kept simple, does only support&n; * a subset of instructions, and does not try to hide pipeline effects&n; * like branch delay slots.&n; */
DECL|enum|fields
r_enum
id|fields
(brace
DECL|enumerator|RS
id|RS
op_assign
l_int|0x001
comma
DECL|enumerator|RT
id|RT
op_assign
l_int|0x002
comma
DECL|enumerator|RD
id|RD
op_assign
l_int|0x004
comma
DECL|enumerator|RE
id|RE
op_assign
l_int|0x008
comma
DECL|enumerator|SIMM
id|SIMM
op_assign
l_int|0x010
comma
DECL|enumerator|UIMM
id|UIMM
op_assign
l_int|0x020
comma
DECL|enumerator|BIMM
id|BIMM
op_assign
l_int|0x040
comma
DECL|enumerator|JIMM
id|JIMM
op_assign
l_int|0x080
comma
DECL|enumerator|FUNC
id|FUNC
op_assign
l_int|0x100
comma
)brace
suffix:semicolon
DECL|macro|OP_MASK
mdefine_line|#define OP_MASK&t;&t;0x2f
DECL|macro|OP_SH
mdefine_line|#define OP_SH&t;&t;26
DECL|macro|RS_MASK
mdefine_line|#define RS_MASK&t;&t;0x1f
DECL|macro|RS_SH
mdefine_line|#define RS_SH&t;&t;21
DECL|macro|RT_MASK
mdefine_line|#define RT_MASK&t;&t;0x1f
DECL|macro|RT_SH
mdefine_line|#define RT_SH&t;&t;16
DECL|macro|RD_MASK
mdefine_line|#define RD_MASK&t;&t;0x1f
DECL|macro|RD_SH
mdefine_line|#define RD_SH&t;&t;11
DECL|macro|RE_MASK
mdefine_line|#define RE_MASK&t;&t;0x1f
DECL|macro|RE_SH
mdefine_line|#define RE_SH&t;&t;6
DECL|macro|IMM_MASK
mdefine_line|#define IMM_MASK&t;0xffff
DECL|macro|IMM_SH
mdefine_line|#define IMM_SH&t;&t;0
DECL|macro|JIMM_MASK
mdefine_line|#define JIMM_MASK&t;0x3ffffff
DECL|macro|JIMM_SH
mdefine_line|#define JIMM_SH&t;&t;0
DECL|macro|FUNC_MASK
mdefine_line|#define FUNC_MASK&t;0x2f
DECL|macro|FUNC_SH
mdefine_line|#define FUNC_SH&t;&t;0
DECL|enum|opcode
r_enum
id|opcode
(brace
DECL|enumerator|insn_invalid
id|insn_invalid
comma
DECL|enumerator|insn_addu
DECL|enumerator|insn_addiu
DECL|enumerator|insn_and
DECL|enumerator|insn_andi
DECL|enumerator|insn_beq
id|insn_addu
comma
id|insn_addiu
comma
id|insn_and
comma
id|insn_andi
comma
id|insn_beq
comma
DECL|enumerator|insn_beql
DECL|enumerator|insn_bgez
DECL|enumerator|insn_bgezl
DECL|enumerator|insn_bltz
DECL|enumerator|insn_bltzl
id|insn_beql
comma
id|insn_bgez
comma
id|insn_bgezl
comma
id|insn_bltz
comma
id|insn_bltzl
comma
DECL|enumerator|insn_bne
DECL|enumerator|insn_daddu
DECL|enumerator|insn_daddiu
DECL|enumerator|insn_dmfc0
DECL|enumerator|insn_dmtc0
id|insn_bne
comma
id|insn_daddu
comma
id|insn_daddiu
comma
id|insn_dmfc0
comma
id|insn_dmtc0
comma
DECL|enumerator|insn_dsll
DECL|enumerator|insn_dsll32
DECL|enumerator|insn_dsra
DECL|enumerator|insn_dsrl
DECL|enumerator|insn_dsrl32
id|insn_dsll
comma
id|insn_dsll32
comma
id|insn_dsra
comma
id|insn_dsrl
comma
id|insn_dsrl32
comma
DECL|enumerator|insn_dsubu
DECL|enumerator|insn_eret
DECL|enumerator|insn_j
DECL|enumerator|insn_jal
DECL|enumerator|insn_jr
DECL|enumerator|insn_ld
id|insn_dsubu
comma
id|insn_eret
comma
id|insn_j
comma
id|insn_jal
comma
id|insn_jr
comma
id|insn_ld
comma
DECL|enumerator|insn_ll
DECL|enumerator|insn_lld
DECL|enumerator|insn_lui
DECL|enumerator|insn_lw
DECL|enumerator|insn_mfc0
DECL|enumerator|insn_mtc0
id|insn_ll
comma
id|insn_lld
comma
id|insn_lui
comma
id|insn_lw
comma
id|insn_mfc0
comma
id|insn_mtc0
comma
DECL|enumerator|insn_ori
DECL|enumerator|insn_rfe
DECL|enumerator|insn_sc
DECL|enumerator|insn_scd
DECL|enumerator|insn_sd
DECL|enumerator|insn_sll
id|insn_ori
comma
id|insn_rfe
comma
id|insn_sc
comma
id|insn_scd
comma
id|insn_sd
comma
id|insn_sll
comma
DECL|enumerator|insn_sra
DECL|enumerator|insn_srl
DECL|enumerator|insn_subu
DECL|enumerator|insn_sw
DECL|enumerator|insn_tlbp
DECL|enumerator|insn_tlbwi
id|insn_sra
comma
id|insn_srl
comma
id|insn_subu
comma
id|insn_sw
comma
id|insn_tlbp
comma
id|insn_tlbwi
comma
DECL|enumerator|insn_tlbwr
DECL|enumerator|insn_xor
DECL|enumerator|insn_xori
id|insn_tlbwr
comma
id|insn_xor
comma
id|insn_xori
)brace
suffix:semicolon
DECL|struct|insn
r_struct
id|insn
(brace
DECL|member|opcode
r_enum
id|opcode
id|opcode
suffix:semicolon
DECL|member|match
id|u32
id|match
suffix:semicolon
DECL|member|fields
r_enum
id|fields
id|fields
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* This macro sets the non-variable bits of an instruction. */
DECL|macro|M
mdefine_line|#define M(a, b, c, d, e, f)&t;&t;&t;&t;&t;&bslash;&n;&t;((a) &lt;&lt; OP_SH&t;&t;&t;&t;&t;&t;&bslash;&n;&t; | (b) &lt;&lt; RS_SH&t;&t;&t;&t;&t;&t;&bslash;&n;&t; | (c) &lt;&lt; RT_SH&t;&t;&t;&t;&t;&t;&bslash;&n;&t; | (d) &lt;&lt; RD_SH&t;&t;&t;&t;&t;&t;&bslash;&n;&t; | (e) &lt;&lt; RE_SH&t;&t;&t;&t;&t;&t;&bslash;&n;&t; | (f) &lt;&lt; FUNC_SH)
DECL|variable|insn_table
r_static
id|__initdata
r_struct
id|insn
id|insn_table
(braket
)braket
op_assign
(brace
(brace
id|insn_addiu
comma
id|M
c_func
(paren
id|addiu_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|RS
op_or
id|RT
op_or
id|SIMM
)brace
comma
(brace
id|insn_addu
comma
id|M
c_func
(paren
id|spec_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|addu_op
)paren
comma
id|RS
op_or
id|RT
op_or
id|RD
)brace
comma
(brace
id|insn_and
comma
id|M
c_func
(paren
id|spec_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|and_op
)paren
comma
id|RS
op_or
id|RT
op_or
id|RD
)brace
comma
(brace
id|insn_andi
comma
id|M
c_func
(paren
id|andi_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|RS
op_or
id|RT
op_or
id|UIMM
)brace
comma
(brace
id|insn_beq
comma
id|M
c_func
(paren
id|beq_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|RS
op_or
id|RT
op_or
id|BIMM
)brace
comma
(brace
id|insn_beql
comma
id|M
c_func
(paren
id|beql_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|RS
op_or
id|RT
op_or
id|BIMM
)brace
comma
(brace
id|insn_bgez
comma
id|M
c_func
(paren
id|bcond_op
comma
l_int|0
comma
id|bgez_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|RS
op_or
id|BIMM
)brace
comma
(brace
id|insn_bgezl
comma
id|M
c_func
(paren
id|bcond_op
comma
l_int|0
comma
id|bgezl_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|RS
op_or
id|BIMM
)brace
comma
(brace
id|insn_bltz
comma
id|M
c_func
(paren
id|bcond_op
comma
l_int|0
comma
id|bltz_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|RS
op_or
id|BIMM
)brace
comma
(brace
id|insn_bltzl
comma
id|M
c_func
(paren
id|bcond_op
comma
l_int|0
comma
id|bltzl_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|RS
op_or
id|BIMM
)brace
comma
(brace
id|insn_bne
comma
id|M
c_func
(paren
id|bne_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|RS
op_or
id|RT
op_or
id|BIMM
)brace
comma
(brace
id|insn_daddiu
comma
id|M
c_func
(paren
id|daddiu_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|RS
op_or
id|RT
op_or
id|SIMM
)brace
comma
(brace
id|insn_daddu
comma
id|M
c_func
(paren
id|spec_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|daddu_op
)paren
comma
id|RS
op_or
id|RT
op_or
id|RD
)brace
comma
(brace
id|insn_dmfc0
comma
id|M
c_func
(paren
id|cop0_op
comma
id|dmfc_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|RT
op_or
id|RD
)brace
comma
(brace
id|insn_dmtc0
comma
id|M
c_func
(paren
id|cop0_op
comma
id|dmtc_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|RT
op_or
id|RD
)brace
comma
(brace
id|insn_dsll
comma
id|M
c_func
(paren
id|spec_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|dsll_op
)paren
comma
id|RT
op_or
id|RD
op_or
id|RE
)brace
comma
(brace
id|insn_dsll32
comma
id|M
c_func
(paren
id|spec_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|dsll32_op
)paren
comma
id|RT
op_or
id|RD
op_or
id|RE
)brace
comma
(brace
id|insn_dsra
comma
id|M
c_func
(paren
id|spec_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|dsra_op
)paren
comma
id|RT
op_or
id|RD
op_or
id|RE
)brace
comma
(brace
id|insn_dsrl
comma
id|M
c_func
(paren
id|spec_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|dsrl_op
)paren
comma
id|RT
op_or
id|RD
op_or
id|RE
)brace
comma
(brace
id|insn_dsrl32
comma
id|M
c_func
(paren
id|spec_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|dsrl32_op
)paren
comma
id|RT
op_or
id|RD
op_or
id|RE
)brace
comma
(brace
id|insn_dsubu
comma
id|M
c_func
(paren
id|spec_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|dsubu_op
)paren
comma
id|RS
op_or
id|RT
op_or
id|RD
)brace
comma
(brace
id|insn_eret
comma
id|M
c_func
(paren
id|cop0_op
comma
id|cop_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|eret_op
)paren
comma
l_int|0
)brace
comma
(brace
id|insn_j
comma
id|M
c_func
(paren
id|j_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|JIMM
)brace
comma
(brace
id|insn_jal
comma
id|M
c_func
(paren
id|jal_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|JIMM
)brace
comma
(brace
id|insn_jr
comma
id|M
c_func
(paren
id|spec_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|jr_op
)paren
comma
id|RS
)brace
comma
(brace
id|insn_ld
comma
id|M
c_func
(paren
id|ld_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|RS
op_or
id|RT
op_or
id|SIMM
)brace
comma
(brace
id|insn_ll
comma
id|M
c_func
(paren
id|ll_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|RS
op_or
id|RT
op_or
id|SIMM
)brace
comma
(brace
id|insn_lld
comma
id|M
c_func
(paren
id|lld_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|RS
op_or
id|RT
op_or
id|SIMM
)brace
comma
(brace
id|insn_lui
comma
id|M
c_func
(paren
id|lui_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|RT
op_or
id|SIMM
)brace
comma
(brace
id|insn_lw
comma
id|M
c_func
(paren
id|lw_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|RS
op_or
id|RT
op_or
id|SIMM
)brace
comma
(brace
id|insn_mfc0
comma
id|M
c_func
(paren
id|cop0_op
comma
id|mfc_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|RT
op_or
id|RD
)brace
comma
(brace
id|insn_mtc0
comma
id|M
c_func
(paren
id|cop0_op
comma
id|mtc_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|RT
op_or
id|RD
)brace
comma
(brace
id|insn_ori
comma
id|M
c_func
(paren
id|ori_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|RS
op_or
id|RT
op_or
id|UIMM
)brace
comma
(brace
id|insn_rfe
comma
id|M
c_func
(paren
id|cop0_op
comma
id|cop_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|rfe_op
)paren
comma
l_int|0
)brace
comma
(brace
id|insn_sc
comma
id|M
c_func
(paren
id|sc_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|RS
op_or
id|RT
op_or
id|SIMM
)brace
comma
(brace
id|insn_scd
comma
id|M
c_func
(paren
id|scd_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|RS
op_or
id|RT
op_or
id|SIMM
)brace
comma
(brace
id|insn_sd
comma
id|M
c_func
(paren
id|sd_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|RS
op_or
id|RT
op_or
id|SIMM
)brace
comma
(brace
id|insn_sll
comma
id|M
c_func
(paren
id|spec_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|sll_op
)paren
comma
id|RT
op_or
id|RD
op_or
id|RE
)brace
comma
(brace
id|insn_sra
comma
id|M
c_func
(paren
id|spec_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|sra_op
)paren
comma
id|RT
op_or
id|RD
op_or
id|RE
)brace
comma
(brace
id|insn_srl
comma
id|M
c_func
(paren
id|spec_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|srl_op
)paren
comma
id|RT
op_or
id|RD
op_or
id|RE
)brace
comma
(brace
id|insn_subu
comma
id|M
c_func
(paren
id|spec_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|subu_op
)paren
comma
id|RS
op_or
id|RT
op_or
id|RD
)brace
comma
(brace
id|insn_sw
comma
id|M
c_func
(paren
id|sw_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|RS
op_or
id|RT
op_or
id|SIMM
)brace
comma
(brace
id|insn_tlbp
comma
id|M
c_func
(paren
id|cop0_op
comma
id|cop_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|tlbp_op
)paren
comma
l_int|0
)brace
comma
(brace
id|insn_tlbwi
comma
id|M
c_func
(paren
id|cop0_op
comma
id|cop_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|tlbwi_op
)paren
comma
l_int|0
)brace
comma
(brace
id|insn_tlbwr
comma
id|M
c_func
(paren
id|cop0_op
comma
id|cop_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|tlbwr_op
)paren
comma
l_int|0
)brace
comma
(brace
id|insn_xor
comma
id|M
c_func
(paren
id|spec_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|xor_op
)paren
comma
id|RS
op_or
id|RT
op_or
id|RD
)brace
comma
(brace
id|insn_xori
comma
id|M
c_func
(paren
id|xori_op
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
comma
id|RS
op_or
id|RT
op_or
id|UIMM
)brace
comma
(brace
id|insn_invalid
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|macro|M
macro_line|#undef M
DECL|function|build_rs
r_static
id|__init
id|u32
id|build_rs
c_func
(paren
id|u32
id|arg
)paren
(brace
r_if
c_cond
(paren
id|arg
op_amp
op_complement
id|RS_MASK
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;TLB synthesizer field overflow&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|arg
op_amp
id|RS_MASK
)paren
op_lshift
id|RS_SH
suffix:semicolon
)brace
DECL|function|build_rt
r_static
id|__init
id|u32
id|build_rt
c_func
(paren
id|u32
id|arg
)paren
(brace
r_if
c_cond
(paren
id|arg
op_amp
op_complement
id|RT_MASK
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;TLB synthesizer field overflow&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|arg
op_amp
id|RT_MASK
)paren
op_lshift
id|RT_SH
suffix:semicolon
)brace
DECL|function|build_rd
r_static
id|__init
id|u32
id|build_rd
c_func
(paren
id|u32
id|arg
)paren
(brace
r_if
c_cond
(paren
id|arg
op_amp
op_complement
id|RD_MASK
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;TLB synthesizer field overflow&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|arg
op_amp
id|RD_MASK
)paren
op_lshift
id|RD_SH
suffix:semicolon
)brace
DECL|function|build_re
r_static
id|__init
id|u32
id|build_re
c_func
(paren
id|u32
id|arg
)paren
(brace
r_if
c_cond
(paren
id|arg
op_amp
op_complement
id|RE_MASK
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;TLB synthesizer field overflow&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|arg
op_amp
id|RE_MASK
)paren
op_lshift
id|RE_SH
suffix:semicolon
)brace
DECL|function|build_simm
r_static
id|__init
id|u32
id|build_simm
c_func
(paren
id|s32
id|arg
)paren
(brace
r_if
c_cond
(paren
id|arg
OG
l_int|0x7fff
op_logical_or
id|arg
OL
op_minus
l_int|0x8000
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;TLB synthesizer field overflow&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|arg
op_amp
l_int|0xffff
suffix:semicolon
)brace
DECL|function|build_uimm
r_static
id|__init
id|u32
id|build_uimm
c_func
(paren
id|u32
id|arg
)paren
(brace
r_if
c_cond
(paren
id|arg
op_amp
op_complement
id|IMM_MASK
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;TLB synthesizer field overflow&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|arg
op_amp
id|IMM_MASK
suffix:semicolon
)brace
DECL|function|build_bimm
r_static
id|__init
id|u32
id|build_bimm
c_func
(paren
id|s32
id|arg
)paren
(brace
r_if
c_cond
(paren
id|arg
OG
l_int|0x1ffff
op_logical_or
id|arg
OL
op_minus
l_int|0x20000
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;TLB synthesizer field overflow&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_amp
l_int|0x3
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Invalid TLB synthesizer branch target&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
(paren
id|arg
OL
l_int|0
)paren
ques
c_cond
(paren
l_int|1
op_lshift
l_int|15
)paren
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|arg
op_rshift
l_int|2
)paren
op_amp
l_int|0x7fff
)paren
suffix:semicolon
)brace
DECL|function|build_jimm
r_static
id|__init
id|u32
id|build_jimm
c_func
(paren
id|u32
id|arg
)paren
(brace
r_if
c_cond
(paren
id|arg
op_amp
op_complement
(paren
(paren
id|JIMM_MASK
)paren
op_lshift
l_int|2
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;TLB synthesizer field overflow&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|arg
op_rshift
l_int|2
)paren
op_amp
id|JIMM_MASK
suffix:semicolon
)brace
DECL|function|build_func
r_static
id|__init
id|u32
id|build_func
c_func
(paren
id|u32
id|arg
)paren
(brace
r_if
c_cond
(paren
id|arg
op_amp
op_complement
id|FUNC_MASK
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;TLB synthesizer field overflow&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|arg
op_amp
id|FUNC_MASK
suffix:semicolon
)brace
multiline_comment|/*&n; * The order of opcode arguments is implicitly left to right,&n; * starting with RS and ending with FUNC or IMM.&n; */
DECL|function|build_insn
r_static
r_void
id|__init
id|build_insn
c_func
(paren
id|u32
op_star
op_star
id|buf
comma
r_enum
id|opcode
id|opc
comma
dot
dot
dot
)paren
(brace
r_struct
id|insn
op_star
id|ip
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|va_list
id|ap
suffix:semicolon
id|u32
id|op
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|insn_table
(braket
id|i
)braket
dot
id|opcode
op_ne
id|insn_invalid
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|insn_table
(braket
id|i
)braket
dot
id|opcode
op_eq
id|opc
)paren
(brace
id|ip
op_assign
op_amp
id|insn_table
(braket
id|i
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ip
)paren
id|panic
c_func
(paren
l_string|&quot;Unsupported TLB synthesizer instruction %d&quot;
comma
id|opc
)paren
suffix:semicolon
id|op
op_assign
id|ip-&gt;match
suffix:semicolon
id|va_start
c_func
(paren
id|ap
comma
id|opc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;fields
op_amp
id|RS
)paren
id|op
op_or_assign
id|build_rs
c_func
(paren
id|va_arg
c_func
(paren
id|ap
comma
id|u32
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;fields
op_amp
id|RT
)paren
id|op
op_or_assign
id|build_rt
c_func
(paren
id|va_arg
c_func
(paren
id|ap
comma
id|u32
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;fields
op_amp
id|RD
)paren
id|op
op_or_assign
id|build_rd
c_func
(paren
id|va_arg
c_func
(paren
id|ap
comma
id|u32
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;fields
op_amp
id|RE
)paren
id|op
op_or_assign
id|build_re
c_func
(paren
id|va_arg
c_func
(paren
id|ap
comma
id|u32
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;fields
op_amp
id|SIMM
)paren
id|op
op_or_assign
id|build_simm
c_func
(paren
id|va_arg
c_func
(paren
id|ap
comma
id|s32
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;fields
op_amp
id|UIMM
)paren
id|op
op_or_assign
id|build_uimm
c_func
(paren
id|va_arg
c_func
(paren
id|ap
comma
id|u32
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;fields
op_amp
id|BIMM
)paren
id|op
op_or_assign
id|build_bimm
c_func
(paren
id|va_arg
c_func
(paren
id|ap
comma
id|s32
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;fields
op_amp
id|JIMM
)paren
id|op
op_or_assign
id|build_jimm
c_func
(paren
id|va_arg
c_func
(paren
id|ap
comma
id|u32
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;fields
op_amp
id|FUNC
)paren
id|op
op_or_assign
id|build_func
c_func
(paren
id|va_arg
c_func
(paren
id|ap
comma
id|u32
)paren
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|ap
)paren
suffix:semicolon
op_star
op_star
id|buf
op_assign
id|op
suffix:semicolon
(paren
op_star
id|buf
)paren
op_increment
suffix:semicolon
)brace
DECL|macro|I_u1u2u3
mdefine_line|#define I_u1u2u3(op)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;static inline void i##op(u32 **buf, unsigned int a,&t;&bslash;&n;&t; &t;unsigned int b, unsigned int c)&t;&t;&t;&bslash;&n;&t;{&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;build_insn(buf, insn##op, a, b, c);&t;&t;&bslash;&n;&t;}
DECL|macro|I_u2u1u3
mdefine_line|#define I_u2u1u3(op)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;static inline void i##op(u32 **buf, unsigned int a,&t;&bslash;&n;&t; &t;unsigned int b, unsigned int c)&t;&t;&t;&bslash;&n;&t;{&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;build_insn(buf, insn##op, b, a, c);&t;&t;&bslash;&n;&t;}
DECL|macro|I_u3u1u2
mdefine_line|#define I_u3u1u2(op)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;static inline void i##op(u32 **buf, unsigned int a,&t;&bslash;&n;&t; &t;unsigned int b, unsigned int c)&t;&t;&t;&bslash;&n;&t;{&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;build_insn(buf, insn##op, b, c, a);&t;&t;&bslash;&n;&t;}
DECL|macro|I_u1u2s3
mdefine_line|#define I_u1u2s3(op)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;static inline void i##op(u32 **buf, unsigned int a,&t;&bslash;&n;&t; &t;unsigned int b, signed int c)&t;&t;&t;&bslash;&n;&t;{&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;build_insn(buf, insn##op, a, b, c);&t;&t;&bslash;&n;&t;}
DECL|macro|I_u2s3u1
mdefine_line|#define I_u2s3u1(op)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;static inline void i##op(u32 **buf, unsigned int a,&t;&bslash;&n;&t; &t;signed int b, unsigned int c)&t;&t;&t;&bslash;&n;&t;{&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;build_insn(buf, insn##op, c, a, b);&t;&t;&bslash;&n;&t;}
DECL|macro|I_u2u1s3
mdefine_line|#define I_u2u1s3(op)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;static inline void i##op(u32 **buf, unsigned int a,&t;&bslash;&n;&t; &t;unsigned int b, signed int c)&t;&t;&t;&bslash;&n;&t;{&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;build_insn(buf, insn##op, b, a, c);&t;&t;&bslash;&n;&t;}
DECL|macro|I_u1u2
mdefine_line|#define I_u1u2(op)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;static inline void i##op(u32 **buf, unsigned int a,&t;&bslash;&n;&t; &t;unsigned int b)&t;&t;&t;&t;&t;&bslash;&n;&t;{&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;build_insn(buf, insn##op, a, b);&t;&t;&bslash;&n;&t;}
DECL|macro|I_u1s2
mdefine_line|#define I_u1s2(op)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;static inline void i##op(u32 **buf, unsigned int a,&t;&bslash;&n;&t; &t;signed int b)&t;&t;&t;&t;&t;&bslash;&n;&t;{&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;build_insn(buf, insn##op, a, b);&t;&t;&bslash;&n;&t;}
DECL|macro|I_u1
mdefine_line|#define I_u1(op)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;static inline void i##op(u32 **buf, unsigned int a)&t;&bslash;&n;&t;{&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;build_insn(buf, insn##op, a);&t;&t;&t;&bslash;&n;&t;}
DECL|macro|I_0
mdefine_line|#define I_0(op)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;static inline void i##op(u32 **buf)&t;&t;&t;&bslash;&n;&t;{&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;build_insn(buf, insn##op);&t;&t;&t;&bslash;&n;&t;}
DECL|variable|_addiu
id|I_u2u1s3
c_func
(paren
id|_addiu
)paren
suffix:semicolon
DECL|variable|_addu
id|I_u3u1u2
c_func
(paren
id|_addu
)paren
suffix:semicolon
DECL|variable|_andi
id|I_u2u1u3
c_func
(paren
id|_andi
)paren
suffix:semicolon
DECL|variable|_and
id|I_u3u1u2
c_func
(paren
id|_and
)paren
suffix:semicolon
DECL|variable|_beq
id|I_u1u2s3
c_func
(paren
id|_beq
)paren
suffix:semicolon
DECL|variable|_beql
id|I_u1u2s3
c_func
(paren
id|_beql
)paren
suffix:semicolon
DECL|variable|_bgez
id|I_u1s2
c_func
(paren
id|_bgez
)paren
suffix:semicolon
DECL|variable|_bgezl
id|I_u1s2
c_func
(paren
id|_bgezl
)paren
suffix:semicolon
DECL|variable|_bltz
id|I_u1s2
c_func
(paren
id|_bltz
)paren
suffix:semicolon
DECL|variable|_bltzl
id|I_u1s2
c_func
(paren
id|_bltzl
)paren
suffix:semicolon
DECL|variable|_bne
id|I_u1u2s3
c_func
(paren
id|_bne
)paren
suffix:semicolon
DECL|variable|_dmfc0
id|I_u1u2
c_func
(paren
id|_dmfc0
)paren
suffix:semicolon
DECL|variable|_dmtc0
id|I_u1u2
c_func
(paren
id|_dmtc0
)paren
suffix:semicolon
DECL|variable|_daddiu
id|I_u2u1s3
c_func
(paren
id|_daddiu
)paren
suffix:semicolon
DECL|variable|_daddu
id|I_u3u1u2
c_func
(paren
id|_daddu
)paren
suffix:semicolon
DECL|variable|_dsll
id|I_u2u1u3
c_func
(paren
id|_dsll
)paren
suffix:semicolon
DECL|variable|_dsll32
id|I_u2u1u3
c_func
(paren
id|_dsll32
)paren
suffix:semicolon
DECL|variable|_dsra
id|I_u2u1u3
c_func
(paren
id|_dsra
)paren
suffix:semicolon
DECL|variable|_dsrl
id|I_u2u1u3
c_func
(paren
id|_dsrl
)paren
suffix:semicolon
DECL|variable|_dsrl32
id|I_u2u1u3
c_func
(paren
id|_dsrl32
)paren
suffix:semicolon
DECL|variable|_dsubu
id|I_u3u1u2
c_func
(paren
id|_dsubu
)paren
suffix:semicolon
DECL|variable|_eret
id|I_0
c_func
(paren
id|_eret
)paren
suffix:semicolon
DECL|variable|_j
id|I_u1
c_func
(paren
id|_j
)paren
suffix:semicolon
DECL|variable|_jal
id|I_u1
c_func
(paren
id|_jal
)paren
suffix:semicolon
DECL|variable|_jr
id|I_u1
c_func
(paren
id|_jr
)paren
suffix:semicolon
DECL|variable|_ld
id|I_u2s3u1
c_func
(paren
id|_ld
)paren
suffix:semicolon
DECL|variable|_ll
id|I_u2s3u1
c_func
(paren
id|_ll
)paren
suffix:semicolon
DECL|variable|_lld
id|I_u2s3u1
c_func
(paren
id|_lld
)paren
suffix:semicolon
DECL|variable|_lui
id|I_u1s2
c_func
(paren
id|_lui
)paren
suffix:semicolon
DECL|variable|_lw
id|I_u2s3u1
c_func
(paren
id|_lw
)paren
suffix:semicolon
DECL|variable|_mfc0
id|I_u1u2
c_func
(paren
id|_mfc0
)paren
suffix:semicolon
DECL|variable|_mtc0
id|I_u1u2
c_func
(paren
id|_mtc0
)paren
suffix:semicolon
DECL|variable|_ori
id|I_u2u1u3
c_func
(paren
id|_ori
)paren
suffix:semicolon
DECL|variable|_rfe
id|I_0
c_func
(paren
id|_rfe
)paren
suffix:semicolon
DECL|variable|_sc
id|I_u2s3u1
c_func
(paren
id|_sc
)paren
suffix:semicolon
DECL|variable|_scd
id|I_u2s3u1
c_func
(paren
id|_scd
)paren
suffix:semicolon
DECL|variable|_sd
id|I_u2s3u1
c_func
(paren
id|_sd
)paren
suffix:semicolon
DECL|variable|_sll
id|I_u2u1u3
c_func
(paren
id|_sll
)paren
suffix:semicolon
DECL|variable|_sra
id|I_u2u1u3
c_func
(paren
id|_sra
)paren
suffix:semicolon
DECL|variable|_srl
id|I_u2u1u3
c_func
(paren
id|_srl
)paren
suffix:semicolon
DECL|variable|_subu
id|I_u3u1u2
c_func
(paren
id|_subu
)paren
suffix:semicolon
DECL|variable|_sw
id|I_u2s3u1
c_func
(paren
id|_sw
)paren
suffix:semicolon
DECL|variable|_tlbp
id|I_0
c_func
(paren
id|_tlbp
)paren
suffix:semicolon
DECL|variable|_tlbwi
id|I_0
c_func
(paren
id|_tlbwi
)paren
suffix:semicolon
DECL|variable|_tlbwr
id|I_0
c_func
(paren
id|_tlbwr
)paren
suffix:semicolon
id|I_u3u1u2
c_func
(paren
id|_xor
)paren
id|I_u2u1u3
c_func
(paren
id|_xori
)paren
suffix:semicolon
multiline_comment|/*&n; * handling labels&n; */
DECL|enum|label_id
r_enum
id|label_id
(brace
DECL|enumerator|label_invalid
id|label_invalid
comma
DECL|enumerator|label_second_part
id|label_second_part
comma
DECL|enumerator|label_leave
id|label_leave
comma
DECL|enumerator|label_vmalloc
id|label_vmalloc
comma
DECL|enumerator|label_vmalloc_done
id|label_vmalloc_done
comma
DECL|enumerator|label_tlbw_hazard
id|label_tlbw_hazard
comma
DECL|enumerator|label_split
id|label_split
comma
DECL|enumerator|label_nopage_tlbl
id|label_nopage_tlbl
comma
DECL|enumerator|label_nopage_tlbs
id|label_nopage_tlbs
comma
DECL|enumerator|label_nopage_tlbm
id|label_nopage_tlbm
comma
DECL|enumerator|label_smp_pgtable_change
id|label_smp_pgtable_change
comma
DECL|enumerator|label_r3000_write_probe_fail
id|label_r3000_write_probe_fail
comma
DECL|enumerator|label_r3000_write_probe_ok
id|label_r3000_write_probe_ok
)brace
suffix:semicolon
DECL|struct|label
r_struct
id|label
(brace
DECL|member|addr
id|u32
op_star
id|addr
suffix:semicolon
DECL|member|lab
r_enum
id|label_id
id|lab
suffix:semicolon
)brace
suffix:semicolon
DECL|function|build_label
r_static
id|__init
r_void
id|build_label
c_func
(paren
r_struct
id|label
op_star
op_star
id|lab
comma
id|u32
op_star
id|addr
comma
r_enum
id|label_id
id|l
)paren
(brace
(paren
op_star
id|lab
)paren
op_member_access_from_pointer
id|addr
op_assign
id|addr
suffix:semicolon
(paren
op_star
id|lab
)paren
op_member_access_from_pointer
id|lab
op_assign
id|l
suffix:semicolon
(paren
op_star
id|lab
)paren
op_increment
suffix:semicolon
)brace
DECL|macro|L_LA
mdefine_line|#define L_LA(lb)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;static inline void l##lb(struct label **lab, u32 *addr) &bslash;&n;&t;{&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;build_label(lab, addr, label##lb);&t;&t;&bslash;&n;&t;}
id|L_LA
c_func
(paren
id|_second_part
)paren
id|L_LA
c_func
(paren
id|_leave
)paren
id|L_LA
c_func
(paren
id|_vmalloc
)paren
id|L_LA
c_func
(paren
id|_vmalloc_done
)paren
id|L_LA
c_func
(paren
id|_tlbw_hazard
)paren
id|L_LA
c_func
(paren
id|_split
)paren
id|L_LA
c_func
(paren
id|_nopage_tlbl
)paren
id|L_LA
c_func
(paren
id|_nopage_tlbs
)paren
id|L_LA
c_func
(paren
id|_nopage_tlbm
)paren
id|L_LA
c_func
(paren
id|_smp_pgtable_change
)paren
id|L_LA
c_func
(paren
id|_r3000_write_probe_fail
)paren
id|L_LA
c_func
(paren
id|_r3000_write_probe_ok
)paren
multiline_comment|/* convenience macros for instructions */
macro_line|#ifdef CONFIG_MIPS64
DECL|macro|i_LW
macro_line|# define i_LW(buf, rs, rt, off) i_ld(buf, rs, rt, off)
DECL|macro|i_SW
macro_line|# define i_SW(buf, rs, rt, off) i_sd(buf, rs, rt, off)
DECL|macro|i_SLL
macro_line|# define i_SLL(buf, rs, rt, sh) i_dsll(buf, rs, rt, sh)
DECL|macro|i_SRA
macro_line|# define i_SRA(buf, rs, rt, sh) i_dsra(buf, rs, rt, sh)
DECL|macro|i_SRL
macro_line|# define i_SRL(buf, rs, rt, sh) i_dsrl(buf, rs, rt, sh)
DECL|macro|i_MFC0
macro_line|# define i_MFC0(buf, rt, rd) i_dmfc0(buf, rt, rd)
DECL|macro|i_MTC0
macro_line|# define i_MTC0(buf, rt, rd) i_dmtc0(buf, rt, rd)
DECL|macro|i_ADDIU
macro_line|# define i_ADDIU(buf, rs, rt, val) i_daddiu(buf, rs, rt, val)
DECL|macro|i_ADDU
macro_line|# define i_ADDU(buf, rs, rt, rd) i_daddu(buf, rs, rt, rd)
DECL|macro|i_SUBU
macro_line|# define i_SUBU(buf, rs, rt, rd) i_dsubu(buf, rs, rt, rd)
DECL|macro|i_LL
macro_line|# define i_LL(buf, rs, rt, off) i_lld(buf, rs, rt, off)
DECL|macro|i_SC
macro_line|# define i_SC(buf, rs, rt, off) i_scd(buf, rs, rt, off)
macro_line|#else
macro_line|# define i_LW(buf, rs, rt, off) i_lw(buf, rs, rt, off)
macro_line|# define i_SW(buf, rs, rt, off) i_sw(buf, rs, rt, off)
macro_line|# define i_SLL(buf, rs, rt, sh) i_sll(buf, rs, rt, sh)
macro_line|# define i_SRA(buf, rs, rt, sh) i_sra(buf, rs, rt, sh)
macro_line|# define i_SRL(buf, rs, rt, sh) i_srl(buf, rs, rt, sh)
macro_line|# define i_MFC0(buf, rt, rd) i_mfc0(buf, rt, rd)
macro_line|# define i_MTC0(buf, rt, rd) i_mtc0(buf, rt, rd)
macro_line|# define i_ADDIU(buf, rs, rt, val) i_addiu(buf, rs, rt, val)
macro_line|# define i_ADDU(buf, rs, rt, rd) i_addu(buf, rs, rt, rd)
macro_line|# define i_SUBU(buf, rs, rt, rd) i_subu(buf, rs, rt, rd)
macro_line|# define i_LL(buf, rs, rt, off) i_ll(buf, rs, rt, off)
macro_line|# define i_SC(buf, rs, rt, off) i_sc(buf, rs, rt, off)
macro_line|#endif
DECL|macro|i_b
mdefine_line|#define i_b(buf, off) i_beq(buf, 0, 0, off)
DECL|macro|i_beqz
mdefine_line|#define i_beqz(buf, rs, off) i_beq(buf, rs, 0, off)
DECL|macro|i_beqzl
mdefine_line|#define i_beqzl(buf, rs, off) i_beql(buf, rs, 0, off)
DECL|macro|i_bnez
mdefine_line|#define i_bnez(buf, rs, off) i_bne(buf, rs, 0, off)
DECL|macro|i_bnezl
mdefine_line|#define i_bnezl(buf, rs, off) i_bnel(buf, rs, 0, off)
DECL|macro|i_move
mdefine_line|#define i_move(buf, a, b) i_ADDU(buf, a, 0, b)
DECL|macro|i_nop
mdefine_line|#define i_nop(buf) i_sll(buf, 0, 0, 0)
DECL|macro|i_ssnop
mdefine_line|#define i_ssnop(buf) i_sll(buf, 0, 0, 1)
DECL|macro|i_ehb
mdefine_line|#define i_ehb(buf) i_sll(buf, 0, 0, 3)
macro_line|#ifdef CONFIG_MIPS64
DECL|function|in_compat_space_p
r_static
id|__init
r_int
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
id|in_compat_space_p
c_func
(paren
r_int
id|addr
)paren
(brace
multiline_comment|/* Is this address in 32bit compat space? */
r_return
(paren
(paren
(paren
id|addr
)paren
op_amp
l_int|0xffffffff00000000
)paren
op_eq
l_int|0xffffffff00000000
)paren
suffix:semicolon
)brace
DECL|function|rel_highest
r_static
id|__init
r_int
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
id|rel_highest
c_func
(paren
r_int
id|val
)paren
(brace
r_return
(paren
(paren
(paren
(paren
id|val
op_plus
l_int|0x800080008000L
)paren
op_rshift
l_int|48
)paren
op_amp
l_int|0xffff
)paren
op_xor
l_int|0x8000
)paren
op_minus
l_int|0x8000
suffix:semicolon
)brace
DECL|function|rel_higher
r_static
id|__init
r_int
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
id|rel_higher
c_func
(paren
r_int
id|val
)paren
(brace
r_return
(paren
(paren
(paren
(paren
id|val
op_plus
l_int|0x80008000L
)paren
op_rshift
l_int|32
)paren
op_amp
l_int|0xffff
)paren
op_xor
l_int|0x8000
)paren
op_minus
l_int|0x8000
suffix:semicolon
)brace
macro_line|#endif
DECL|function|rel_hi
r_static
id|__init
r_int
id|rel_hi
c_func
(paren
r_int
id|val
)paren
(brace
r_return
(paren
(paren
(paren
(paren
id|val
op_plus
l_int|0x8000L
)paren
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
)paren
op_xor
l_int|0x8000
)paren
op_minus
l_int|0x8000
suffix:semicolon
)brace
DECL|function|rel_lo
r_static
id|__init
r_int
id|rel_lo
c_func
(paren
r_int
id|val
)paren
(brace
r_return
(paren
(paren
id|val
op_amp
l_int|0xffff
)paren
op_xor
l_int|0x8000
)paren
op_minus
l_int|0x8000
suffix:semicolon
)brace
DECL|function|i_LA_mostly
r_static
id|__init
r_void
id|i_LA_mostly
c_func
(paren
id|u32
op_star
op_star
id|buf
comma
r_int
r_int
id|rs
comma
r_int
id|addr
)paren
(brace
macro_line|#if CONFIG_MIPS64
r_if
c_cond
(paren
op_logical_neg
id|in_compat_space_p
c_func
(paren
id|addr
)paren
)paren
(brace
id|i_lui
c_func
(paren
id|buf
comma
id|rs
comma
id|rel_highest
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rel_higher
c_func
(paren
id|addr
)paren
)paren
id|i_daddiu
c_func
(paren
id|buf
comma
id|rs
comma
id|rs
comma
id|rel_higher
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rel_hi
c_func
(paren
id|addr
)paren
)paren
(brace
id|i_dsll
c_func
(paren
id|buf
comma
id|rs
comma
id|rs
comma
l_int|16
)paren
suffix:semicolon
id|i_daddiu
c_func
(paren
id|buf
comma
id|rs
comma
id|rs
comma
id|rel_hi
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
id|i_dsll
c_func
(paren
id|buf
comma
id|rs
comma
id|rs
comma
l_int|16
)paren
suffix:semicolon
)brace
r_else
id|i_dsll32
c_func
(paren
id|buf
comma
id|rs
comma
id|rs
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
id|i_lui
c_func
(paren
id|buf
comma
id|rs
comma
id|rel_hi
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
)brace
DECL|function|i_LA
r_static
id|__init
r_void
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
id|i_LA
c_func
(paren
id|u32
op_star
op_star
id|buf
comma
r_int
r_int
id|rs
comma
r_int
id|addr
)paren
(brace
id|i_LA_mostly
c_func
(paren
id|buf
comma
id|rs
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rel_lo
c_func
(paren
id|addr
)paren
)paren
id|i_ADDIU
c_func
(paren
id|buf
comma
id|rs
comma
id|rs
comma
id|rel_lo
c_func
(paren
id|addr
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * handle relocations&n; */
DECL|struct|reloc
r_struct
id|reloc
(brace
DECL|member|addr
id|u32
op_star
id|addr
suffix:semicolon
DECL|member|type
r_int
r_int
id|type
suffix:semicolon
DECL|member|lab
r_enum
id|label_id
id|lab
suffix:semicolon
)brace
suffix:semicolon
DECL|function|r_mips_pc16
r_static
id|__init
r_void
id|r_mips_pc16
c_func
(paren
r_struct
id|reloc
op_star
op_star
id|rel
comma
id|u32
op_star
id|addr
comma
r_enum
id|label_id
id|l
)paren
(brace
(paren
op_star
id|rel
)paren
op_member_access_from_pointer
id|addr
op_assign
id|addr
suffix:semicolon
(paren
op_star
id|rel
)paren
op_member_access_from_pointer
id|type
op_assign
id|R_MIPS_PC16
suffix:semicolon
(paren
op_star
id|rel
)paren
op_member_access_from_pointer
id|lab
op_assign
id|l
suffix:semicolon
(paren
op_star
id|rel
)paren
op_increment
suffix:semicolon
)brace
DECL|function|__resolve_relocs
r_static
r_inline
r_void
id|__resolve_relocs
c_func
(paren
r_struct
id|reloc
op_star
id|rel
comma
r_struct
id|label
op_star
id|lab
)paren
(brace
r_int
id|laddr
op_assign
(paren
r_int
)paren
id|lab-&gt;addr
suffix:semicolon
r_int
id|raddr
op_assign
(paren
r_int
)paren
id|rel-&gt;addr
suffix:semicolon
r_switch
c_cond
(paren
id|rel-&gt;type
)paren
(brace
r_case
id|R_MIPS_PC16
suffix:colon
op_star
id|rel-&gt;addr
op_or_assign
id|build_bimm
c_func
(paren
id|laddr
op_minus
(paren
id|raddr
op_plus
l_int|4
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;Unsupported TLB synthesizer relocation %d&quot;
comma
id|rel-&gt;type
)paren
suffix:semicolon
)brace
)brace
DECL|function|resolve_relocs
r_static
id|__init
r_void
id|resolve_relocs
c_func
(paren
r_struct
id|reloc
op_star
id|rel
comma
r_struct
id|label
op_star
id|lab
)paren
(brace
r_struct
id|label
op_star
id|l
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|rel-&gt;lab
op_ne
id|label_invalid
suffix:semicolon
id|rel
op_increment
)paren
r_for
c_loop
(paren
id|l
op_assign
id|lab
suffix:semicolon
id|l-&gt;lab
op_ne
id|label_invalid
suffix:semicolon
id|l
op_increment
)paren
r_if
c_cond
(paren
id|rel-&gt;lab
op_eq
id|l-&gt;lab
)paren
id|__resolve_relocs
c_func
(paren
id|rel
comma
id|l
)paren
suffix:semicolon
)brace
DECL|function|move_relocs
r_static
id|__init
r_void
id|move_relocs
c_func
(paren
r_struct
id|reloc
op_star
id|rel
comma
id|u32
op_star
id|first
comma
id|u32
op_star
id|end
comma
r_int
id|off
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|rel-&gt;lab
op_ne
id|label_invalid
suffix:semicolon
id|rel
op_increment
)paren
r_if
c_cond
(paren
id|rel-&gt;addr
op_ge
id|first
op_logical_and
id|rel-&gt;addr
OL
id|end
)paren
id|rel-&gt;addr
op_add_assign
id|off
suffix:semicolon
)brace
DECL|function|move_labels
r_static
id|__init
r_void
id|move_labels
c_func
(paren
r_struct
id|label
op_star
id|lab
comma
id|u32
op_star
id|first
comma
id|u32
op_star
id|end
comma
r_int
id|off
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|lab-&gt;lab
op_ne
id|label_invalid
suffix:semicolon
id|lab
op_increment
)paren
r_if
c_cond
(paren
id|lab-&gt;addr
op_ge
id|first
op_logical_and
id|lab-&gt;addr
OL
id|end
)paren
id|lab-&gt;addr
op_add_assign
id|off
suffix:semicolon
)brace
DECL|function|copy_handler
r_static
id|__init
r_void
id|copy_handler
c_func
(paren
r_struct
id|reloc
op_star
id|rel
comma
r_struct
id|label
op_star
id|lab
comma
id|u32
op_star
id|first
comma
id|u32
op_star
id|end
comma
id|u32
op_star
id|target
)paren
(brace
r_int
id|off
op_assign
(paren
r_int
)paren
(paren
id|target
op_minus
id|first
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|target
comma
id|first
comma
(paren
id|end
op_minus
id|first
)paren
op_star
r_sizeof
(paren
id|u32
)paren
)paren
suffix:semicolon
id|move_relocs
c_func
(paren
id|rel
comma
id|first
comma
id|end
comma
id|off
)paren
suffix:semicolon
id|move_labels
c_func
(paren
id|lab
comma
id|first
comma
id|end
comma
id|off
)paren
suffix:semicolon
)brace
DECL|function|insn_has_bdelay
r_static
id|__init
r_int
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
id|insn_has_bdelay
c_func
(paren
r_struct
id|reloc
op_star
id|rel
comma
id|u32
op_star
id|addr
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|rel-&gt;lab
op_ne
id|label_invalid
suffix:semicolon
id|rel
op_increment
)paren
(brace
r_if
c_cond
(paren
id|rel-&gt;addr
op_eq
id|addr
op_logical_and
(paren
id|rel-&gt;type
op_eq
id|R_MIPS_PC16
op_logical_or
id|rel-&gt;type
op_eq
id|R_MIPS_26
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* convenience functions for labeled branches */
DECL|function|il_bltz
r_static
r_void
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
id|il_bltz
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_struct
id|reloc
op_star
op_star
id|r
comma
r_int
r_int
id|reg
comma
r_enum
id|label_id
id|l
)paren
(brace
id|r_mips_pc16
c_func
(paren
id|r
comma
op_star
id|p
comma
id|l
)paren
suffix:semicolon
id|i_bltz
c_func
(paren
id|p
comma
id|reg
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|il_b
r_static
r_void
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
id|il_b
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_struct
id|reloc
op_star
op_star
id|r
comma
r_enum
id|label_id
id|l
)paren
(brace
id|r_mips_pc16
c_func
(paren
id|r
comma
op_star
id|p
comma
id|l
)paren
suffix:semicolon
id|i_b
c_func
(paren
id|p
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|il_beqz
r_static
r_void
id|il_beqz
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_struct
id|reloc
op_star
op_star
id|r
comma
r_int
r_int
id|reg
comma
r_enum
id|label_id
id|l
)paren
(brace
id|r_mips_pc16
c_func
(paren
id|r
comma
op_star
id|p
comma
id|l
)paren
suffix:semicolon
id|i_beqz
c_func
(paren
id|p
comma
id|reg
comma
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_void
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
DECL|function|il_beqzl
id|il_beqzl
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_struct
id|reloc
op_star
op_star
id|r
comma
r_int
r_int
id|reg
comma
r_enum
id|label_id
id|l
)paren
(brace
id|r_mips_pc16
c_func
(paren
id|r
comma
op_star
id|p
comma
id|l
)paren
suffix:semicolon
id|i_beqzl
c_func
(paren
id|p
comma
id|reg
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|il_bnez
r_static
r_void
id|il_bnez
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_struct
id|reloc
op_star
op_star
id|r
comma
r_int
r_int
id|reg
comma
r_enum
id|label_id
id|l
)paren
(brace
id|r_mips_pc16
c_func
(paren
id|r
comma
op_star
id|p
comma
id|l
)paren
suffix:semicolon
id|i_bnez
c_func
(paren
id|p
comma
id|reg
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|il_bgezl
r_static
r_void
id|il_bgezl
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_struct
id|reloc
op_star
op_star
id|r
comma
r_int
r_int
id|reg
comma
r_enum
id|label_id
id|l
)paren
(brace
id|r_mips_pc16
c_func
(paren
id|r
comma
op_star
id|p
comma
id|l
)paren
suffix:semicolon
id|i_bgezl
c_func
(paren
id|p
comma
id|reg
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* The only general purpose registers allowed in TLB handlers. */
DECL|macro|K0
mdefine_line|#define K0&t;&t;26
DECL|macro|K1
mdefine_line|#define K1&t;&t;27
multiline_comment|/* Some CP0 registers */
DECL|macro|C0_INDEX
mdefine_line|#define C0_INDEX&t;0
DECL|macro|C0_ENTRYLO0
mdefine_line|#define C0_ENTRYLO0&t;2
DECL|macro|C0_ENTRYLO1
mdefine_line|#define C0_ENTRYLO1&t;3
DECL|macro|C0_CONTEXT
mdefine_line|#define C0_CONTEXT&t;4
DECL|macro|C0_BADVADDR
mdefine_line|#define C0_BADVADDR&t;8
DECL|macro|C0_ENTRYHI
mdefine_line|#define C0_ENTRYHI&t;10
DECL|macro|C0_EPC
mdefine_line|#define C0_EPC&t;&t;14
DECL|macro|C0_XCONTEXT
mdefine_line|#define C0_XCONTEXT&t;20
macro_line|#ifdef CONFIG_MIPS64
DECL|macro|GET_CONTEXT
macro_line|# define GET_CONTEXT(buf, reg) i_MFC0(buf, reg, C0_XCONTEXT)
macro_line|#else
DECL|macro|GET_CONTEXT
macro_line|# define GET_CONTEXT(buf, reg) i_MFC0(buf, reg, C0_CONTEXT)
macro_line|#endif
multiline_comment|/* The worst case length of the handler is around 18 instructions for&n; * R3000-style TLBs and up to 63 instructions for R4000-style TLBs.&n; * Maximum space available is 32 instructions for R3000 and 64&n; * instructions for R4000.&n; *&n; * We deliberately chose a buffer size of 128, so we won&squot;t scribble&n; * over anything important on overflow before we panic.&n; */
DECL|variable|tlb_handler
r_static
id|__initdata
id|u32
id|tlb_handler
(braket
l_int|128
)braket
suffix:semicolon
multiline_comment|/* simply assume worst case size for labels and relocs */
DECL|variable|labels
r_static
id|__initdata
r_struct
id|label
id|labels
(braket
l_int|128
)braket
suffix:semicolon
DECL|variable|relocs
r_static
id|__initdata
r_struct
id|reloc
id|relocs
(braket
l_int|128
)braket
suffix:semicolon
multiline_comment|/*&n; * The R3000 TLB handler is simple.&n; */
DECL|function|build_r3000_tlb_refill_handler
r_static
r_void
id|__init
id|build_r3000_tlb_refill_handler
c_func
(paren
r_void
)paren
(brace
r_int
id|pgdc
op_assign
(paren
r_int
)paren
id|pgd_current
suffix:semicolon
id|u32
op_star
id|p
suffix:semicolon
id|memset
c_func
(paren
id|tlb_handler
comma
l_int|0
comma
r_sizeof
(paren
id|tlb_handler
)paren
)paren
suffix:semicolon
id|p
op_assign
id|tlb_handler
suffix:semicolon
id|i_mfc0
c_func
(paren
op_amp
id|p
comma
id|K0
comma
id|C0_BADVADDR
)paren
suffix:semicolon
id|i_lui
c_func
(paren
op_amp
id|p
comma
id|K1
comma
id|rel_hi
c_func
(paren
id|pgdc
)paren
)paren
suffix:semicolon
multiline_comment|/* cp0 delay */
id|i_lw
c_func
(paren
op_amp
id|p
comma
id|K1
comma
id|rel_lo
c_func
(paren
id|pgdc
)paren
comma
id|K1
)paren
suffix:semicolon
id|i_srl
c_func
(paren
op_amp
id|p
comma
id|K0
comma
id|K0
comma
l_int|22
)paren
suffix:semicolon
multiline_comment|/* load delay */
id|i_sll
c_func
(paren
op_amp
id|p
comma
id|K0
comma
id|K0
comma
l_int|2
)paren
suffix:semicolon
id|i_addu
c_func
(paren
op_amp
id|p
comma
id|K1
comma
id|K1
comma
id|K0
)paren
suffix:semicolon
id|i_mfc0
c_func
(paren
op_amp
id|p
comma
id|K0
comma
id|C0_CONTEXT
)paren
suffix:semicolon
id|i_lw
c_func
(paren
op_amp
id|p
comma
id|K1
comma
l_int|0
comma
id|K1
)paren
suffix:semicolon
multiline_comment|/* cp0 delay */
id|i_andi
c_func
(paren
op_amp
id|p
comma
id|K0
comma
id|K0
comma
l_int|0xffc
)paren
suffix:semicolon
multiline_comment|/* load delay */
id|i_addu
c_func
(paren
op_amp
id|p
comma
id|K1
comma
id|K1
comma
id|K0
)paren
suffix:semicolon
id|i_lw
c_func
(paren
op_amp
id|p
comma
id|K0
comma
l_int|0
comma
id|K1
)paren
suffix:semicolon
id|i_nop
c_func
(paren
op_amp
id|p
)paren
suffix:semicolon
multiline_comment|/* load delay */
id|i_mtc0
c_func
(paren
op_amp
id|p
comma
id|K0
comma
id|C0_ENTRYLO0
)paren
suffix:semicolon
id|i_mfc0
c_func
(paren
op_amp
id|p
comma
id|K1
comma
id|C0_EPC
)paren
suffix:semicolon
multiline_comment|/* cp0 delay */
id|i_tlbwr
c_func
(paren
op_amp
id|p
)paren
suffix:semicolon
multiline_comment|/* cp0 delay */
id|i_jr
c_func
(paren
op_amp
id|p
comma
id|K1
)paren
suffix:semicolon
id|i_rfe
c_func
(paren
op_amp
id|p
)paren
suffix:semicolon
multiline_comment|/* branch delay */
r_if
c_cond
(paren
id|p
OG
id|tlb_handler
op_plus
l_int|32
)paren
id|panic
c_func
(paren
l_string|&quot;TLB refill handler space exceeded&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Synthesized TLB handler (%u instructions).&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
(paren
id|p
op_minus
id|tlb_handler
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TLB
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|p
op_minus
id|tlb_handler
)paren
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%08x&bslash;n&quot;
comma
id|tlb_handler
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|CAC_BASE
comma
id|tlb_handler
comma
l_int|0x80
)paren
suffix:semicolon
id|flush_icache_range
c_func
(paren
id|CAC_BASE
comma
id|CAC_BASE
op_plus
l_int|0x80
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The R4000 TLB handler is much more complicated. We have two&n; * consecutive handler areas with 32 instructions space each.&n; * Since they aren&squot;t used at the same time, we can overflow in the&n; * other one.To keep things simple, we first assume linear space,&n; * then we relocate it to the final handler layout as needed.&n; */
DECL|variable|final_handler
r_static
id|__initdata
id|u32
id|final_handler
(braket
l_int|64
)braket
suffix:semicolon
multiline_comment|/*&n; * Hazards&n; *&n; * From the IDT errata for the QED RM5230 (Nevada), processor revision 1.0:&n; * 2. A timing hazard exists for the TLBP instruction.&n; *&n; *      stalling_instruction&n; *      TLBP&n; *&n; * The JTLB is being read for the TLBP throughout the stall generated by the&n; * previous instruction. This is not really correct as the stalling instruction&n; * can modify the address used to access the JTLB.  The failure symptom is that&n; * the TLBP instruction will use an address created for the stalling instruction&n; * and not the address held in C0_ENHI and thus report the wrong results.&n; *&n; * The software work-around is to not allow the instruction preceding the TLBP&n; * to stall - make it an NOP or some other instruction guaranteed not to stall.&n; *&n; * Errata 2 will not be fixed.  This errata is also on the R5000.&n; *&n; * As if we MIPS hackers wouldn&squot;t know how to nop pipelines happy ...&n; */
DECL|function|build_tlb_probe_entry
r_static
id|__init
r_void
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
id|build_tlb_probe_entry
c_func
(paren
id|u32
op_star
op_star
id|p
)paren
(brace
r_switch
c_cond
(paren
id|current_cpu_data.cputype
)paren
(brace
r_case
id|CPU_R5000
suffix:colon
r_case
id|CPU_R5000A
suffix:colon
r_case
id|CPU_NEVADA
suffix:colon
id|i_nop
c_func
(paren
id|p
)paren
suffix:semicolon
id|i_tlbp
c_func
(paren
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|i_tlbp
c_func
(paren
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Write random or indexed TLB entry, and care about the hazards from&n; * the preceeding mtc0 and for the following eret.&n; */
DECL|enum|tlb_write_entry
DECL|enumerator|tlb_random
DECL|enumerator|tlb_indexed
r_enum
id|tlb_write_entry
(brace
id|tlb_random
comma
id|tlb_indexed
)brace
suffix:semicolon
DECL|function|build_tlb_write_entry
r_static
id|__init
r_void
id|build_tlb_write_entry
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_struct
id|label
op_star
op_star
id|l
comma
r_struct
id|reloc
op_star
op_star
id|r
comma
r_enum
id|tlb_write_entry
id|wmode
)paren
(brace
r_void
(paren
op_star
id|tlbw
)paren
(paren
id|u32
op_star
op_star
)paren
op_assign
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|wmode
)paren
(brace
r_case
id|tlb_random
suffix:colon
id|tlbw
op_assign
id|i_tlbwr
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tlb_indexed
suffix:colon
id|tlbw
op_assign
id|i_tlbwi
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|current_cpu_data.cputype
)paren
(brace
r_case
id|CPU_R4000PC
suffix:colon
r_case
id|CPU_R4000SC
suffix:colon
r_case
id|CPU_R4000MC
suffix:colon
r_case
id|CPU_R4400PC
suffix:colon
r_case
id|CPU_R4400SC
suffix:colon
r_case
id|CPU_R4400MC
suffix:colon
multiline_comment|/*&n;&t;&t; * This branch uses up a mtc0 hazard nop slot and saves&n;&t;&t; * two nops after the tlbw instruction.&n;&t;&t; */
id|il_bgezl
c_func
(paren
id|p
comma
id|r
comma
l_int|0
comma
id|label_tlbw_hazard
)paren
suffix:semicolon
id|tlbw
c_func
(paren
id|p
)paren
suffix:semicolon
id|l_tlbw_hazard
c_func
(paren
id|l
comma
op_star
id|p
)paren
suffix:semicolon
id|i_nop
c_func
(paren
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPU_R4600
suffix:colon
r_case
id|CPU_R4700
suffix:colon
r_case
id|CPU_R5000
suffix:colon
r_case
id|CPU_R5000A
suffix:colon
r_case
id|CPU_5KC
suffix:colon
r_case
id|CPU_TX49XX
suffix:colon
r_case
id|CPU_AU1000
suffix:colon
r_case
id|CPU_AU1100
suffix:colon
r_case
id|CPU_AU1500
suffix:colon
r_case
id|CPU_AU1550
suffix:colon
id|i_nop
c_func
(paren
id|p
)paren
suffix:semicolon
id|tlbw
c_func
(paren
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPU_R10000
suffix:colon
r_case
id|CPU_R12000
suffix:colon
r_case
id|CPU_4KC
suffix:colon
r_case
id|CPU_SB1
suffix:colon
r_case
id|CPU_4KSC
suffix:colon
r_case
id|CPU_20KC
suffix:colon
r_case
id|CPU_25KF
suffix:colon
id|tlbw
c_func
(paren
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPU_NEVADA
suffix:colon
id|i_nop
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/* QED specifies 2 nops hazard */
multiline_comment|/*&n;&t;&t; * This branch uses up a mtc0 hazard nop slot and saves&n;&t;&t; * a nop after the tlbw instruction.&n;&t;&t; */
id|il_bgezl
c_func
(paren
id|p
comma
id|r
comma
l_int|0
comma
id|label_tlbw_hazard
)paren
suffix:semicolon
id|tlbw
c_func
(paren
id|p
)paren
suffix:semicolon
id|l_tlbw_hazard
c_func
(paren
id|l
comma
op_star
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPU_RM7000
suffix:colon
id|i_nop
c_func
(paren
id|p
)paren
suffix:semicolon
id|i_nop
c_func
(paren
id|p
)paren
suffix:semicolon
id|i_nop
c_func
(paren
id|p
)paren
suffix:semicolon
id|i_nop
c_func
(paren
id|p
)paren
suffix:semicolon
id|tlbw
c_func
(paren
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPU_4KEC
suffix:colon
r_case
id|CPU_24K
suffix:colon
id|i_ehb
c_func
(paren
id|p
)paren
suffix:semicolon
id|tlbw
c_func
(paren
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPU_RM9000
suffix:colon
multiline_comment|/*&n;&t;&t; * When the JTLB is updated by tlbwi or tlbwr, a subsequent&n;&t;&t; * use of the JTLB for instructions should not occur for 4&n;&t;&t; * cpu cycles and use for data translations should not occur&n;&t;&t; * for 3 cpu cycles.&n;&t;&t; */
id|i_ssnop
c_func
(paren
id|p
)paren
suffix:semicolon
id|i_ssnop
c_func
(paren
id|p
)paren
suffix:semicolon
id|i_ssnop
c_func
(paren
id|p
)paren
suffix:semicolon
id|i_ssnop
c_func
(paren
id|p
)paren
suffix:semicolon
id|tlbw
c_func
(paren
id|p
)paren
suffix:semicolon
id|i_ssnop
c_func
(paren
id|p
)paren
suffix:semicolon
id|i_ssnop
c_func
(paren
id|p
)paren
suffix:semicolon
id|i_ssnop
c_func
(paren
id|p
)paren
suffix:semicolon
id|i_ssnop
c_func
(paren
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPU_VR4111
suffix:colon
r_case
id|CPU_VR4121
suffix:colon
r_case
id|CPU_VR4122
suffix:colon
r_case
id|CPU_VR4181
suffix:colon
r_case
id|CPU_VR4181A
suffix:colon
id|i_nop
c_func
(paren
id|p
)paren
suffix:semicolon
id|i_nop
c_func
(paren
id|p
)paren
suffix:semicolon
id|tlbw
c_func
(paren
id|p
)paren
suffix:semicolon
id|i_nop
c_func
(paren
id|p
)paren
suffix:semicolon
id|i_nop
c_func
(paren
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPU_VR4131
suffix:colon
r_case
id|CPU_VR4133
suffix:colon
id|i_nop
c_func
(paren
id|p
)paren
suffix:semicolon
id|i_nop
c_func
(paren
id|p
)paren
suffix:semicolon
id|tlbw
c_func
(paren
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;No TLB refill handler yet (CPU type: %d)&quot;
comma
id|current_cpu_data.cputype
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_MIPS64
multiline_comment|/*&n; * TMP and PTR are scratch.&n; * TMP will be clobbered, PTR will hold the pmd entry.&n; */
r_static
id|__init
r_void
DECL|function|build_get_pmde64
id|build_get_pmde64
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_struct
id|label
op_star
op_star
id|l
comma
r_struct
id|reloc
op_star
op_star
id|r
comma
r_int
r_int
id|tmp
comma
r_int
r_int
id|ptr
)paren
(brace
r_int
id|pgdc
op_assign
(paren
r_int
)paren
id|pgd_current
suffix:semicolon
multiline_comment|/*&n;&t; * The vmalloc handling is not in the hotpath.&n;&t; */
id|i_dmfc0
c_func
(paren
id|p
comma
id|tmp
comma
id|C0_BADVADDR
)paren
suffix:semicolon
id|il_bltz
c_func
(paren
id|p
comma
id|r
comma
id|tmp
comma
id|label_vmalloc
)paren
suffix:semicolon
multiline_comment|/* No i_nop needed here, since the next insn doesn&squot;t touch TMP. */
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n;&t; * 64 bit SMP has the lower part of &amp;pgd_current[smp_processor_id()]&n;&t; * stored in CONTEXT.&n;&t; */
r_if
c_cond
(paren
id|in_compat_space_p
c_func
(paren
id|pgdc
)paren
)paren
(brace
id|i_dmfc0
c_func
(paren
id|p
comma
id|ptr
comma
id|C0_CONTEXT
)paren
suffix:semicolon
id|i_dsra
c_func
(paren
id|p
comma
id|ptr
comma
id|ptr
comma
l_int|23
)paren
suffix:semicolon
id|i_ld
c_func
(paren
id|p
comma
id|ptr
comma
l_int|0
comma
id|ptr
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef CONFIG_BUILD_ELF64
id|i_dmfc0
c_func
(paren
id|p
comma
id|ptr
comma
id|C0_CONTEXT
)paren
suffix:semicolon
id|i_dsrl
c_func
(paren
id|p
comma
id|ptr
comma
id|ptr
comma
l_int|23
)paren
suffix:semicolon
id|i_dsll
c_func
(paren
id|p
comma
id|ptr
comma
id|ptr
comma
l_int|3
)paren
suffix:semicolon
id|i_LA_mostly
c_func
(paren
id|p
comma
id|tmp
comma
id|pgdc
)paren
suffix:semicolon
id|i_daddu
c_func
(paren
id|p
comma
id|ptr
comma
id|ptr
comma
id|tmp
)paren
suffix:semicolon
id|i_dmfc0
c_func
(paren
id|p
comma
id|tmp
comma
id|C0_BADVADDR
)paren
suffix:semicolon
id|i_ld
c_func
(paren
id|p
comma
id|ptr
comma
id|rel_lo
c_func
(paren
id|pgdc
)paren
comma
id|ptr
)paren
suffix:semicolon
macro_line|#else
id|i_dmfc0
c_func
(paren
id|p
comma
id|ptr
comma
id|C0_CONTEXT
)paren
suffix:semicolon
id|i_lui
c_func
(paren
id|p
comma
id|tmp
comma
id|rel_highest
c_func
(paren
id|pgdc
)paren
)paren
suffix:semicolon
id|i_dsll
c_func
(paren
id|p
comma
id|ptr
comma
id|ptr
comma
l_int|9
)paren
suffix:semicolon
id|i_daddiu
c_func
(paren
id|p
comma
id|tmp
comma
id|tmp
comma
id|rel_higher
c_func
(paren
id|pgdc
)paren
)paren
suffix:semicolon
id|i_dsrl32
c_func
(paren
id|p
comma
id|ptr
comma
id|ptr
comma
l_int|0
)paren
suffix:semicolon
id|i_and
c_func
(paren
id|p
comma
id|ptr
comma
id|ptr
comma
id|tmp
)paren
suffix:semicolon
id|i_dmfc0
c_func
(paren
id|p
comma
id|tmp
comma
id|C0_BADVADDR
)paren
suffix:semicolon
id|i_ld
c_func
(paren
id|p
comma
id|ptr
comma
l_int|0
comma
id|ptr
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#else
id|i_LA_mostly
c_func
(paren
id|p
comma
id|ptr
comma
id|pgdc
)paren
suffix:semicolon
id|i_ld
c_func
(paren
id|p
comma
id|ptr
comma
id|rel_lo
c_func
(paren
id|pgdc
)paren
comma
id|ptr
)paren
suffix:semicolon
macro_line|#endif
id|l_vmalloc_done
c_func
(paren
id|l
comma
op_star
id|p
)paren
suffix:semicolon
id|i_dsrl
c_func
(paren
id|p
comma
id|tmp
comma
id|tmp
comma
id|PGDIR_SHIFT
op_minus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* get pgd offset in bytes */
id|i_andi
c_func
(paren
id|p
comma
id|tmp
comma
id|tmp
comma
(paren
id|PTRS_PER_PGD
op_minus
l_int|1
)paren
op_lshift
l_int|3
)paren
suffix:semicolon
id|i_daddu
c_func
(paren
id|p
comma
id|ptr
comma
id|ptr
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/* add in pgd offset */
id|i_dmfc0
c_func
(paren
id|p
comma
id|tmp
comma
id|C0_BADVADDR
)paren
suffix:semicolon
multiline_comment|/* get faulting address */
id|i_ld
c_func
(paren
id|p
comma
id|ptr
comma
l_int|0
comma
id|ptr
)paren
suffix:semicolon
multiline_comment|/* get pmd pointer */
id|i_dsrl
c_func
(paren
id|p
comma
id|tmp
comma
id|tmp
comma
id|PMD_SHIFT
op_minus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* get pmd offset in bytes */
id|i_andi
c_func
(paren
id|p
comma
id|tmp
comma
id|tmp
comma
(paren
id|PTRS_PER_PMD
op_minus
l_int|1
)paren
op_lshift
l_int|3
)paren
suffix:semicolon
id|i_daddu
c_func
(paren
id|p
comma
id|ptr
comma
id|ptr
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/* add in pmd offset */
)brace
multiline_comment|/*&n; * BVADDR is the faulting address, PTR is scratch.&n; * PTR will hold the pgd for vmalloc.&n; */
r_static
id|__init
r_void
DECL|function|build_get_pgd_vmalloc64
id|build_get_pgd_vmalloc64
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_struct
id|label
op_star
op_star
id|l
comma
r_struct
id|reloc
op_star
op_star
id|r
comma
r_int
r_int
id|bvaddr
comma
r_int
r_int
id|ptr
)paren
(brace
r_int
id|swpd
op_assign
(paren
r_int
)paren
id|swapper_pg_dir
suffix:semicolon
id|l_vmalloc
c_func
(paren
id|l
comma
op_star
id|p
)paren
suffix:semicolon
id|i_LA
c_func
(paren
id|p
comma
id|ptr
comma
id|VMALLOC_START
)paren
suffix:semicolon
id|i_dsubu
c_func
(paren
id|p
comma
id|bvaddr
comma
id|bvaddr
comma
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_compat_space_p
c_func
(paren
id|swpd
)paren
op_logical_and
op_logical_neg
id|rel_lo
c_func
(paren
id|swpd
)paren
)paren
(brace
id|il_b
c_func
(paren
id|p
comma
id|r
comma
id|label_vmalloc_done
)paren
suffix:semicolon
id|i_lui
c_func
(paren
id|p
comma
id|ptr
comma
id|rel_hi
c_func
(paren
id|swpd
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|i_LA_mostly
c_func
(paren
id|p
comma
id|ptr
comma
id|swpd
)paren
suffix:semicolon
id|il_b
c_func
(paren
id|p
comma
id|r
comma
id|label_vmalloc_done
)paren
suffix:semicolon
id|i_daddiu
c_func
(paren
id|p
comma
id|ptr
comma
id|ptr
comma
id|rel_lo
c_func
(paren
id|swpd
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#else /* !CONFIG_MIPS64 */
multiline_comment|/*&n; * TMP and PTR are scratch.&n; * TMP will be clobbered, PTR will hold the pgd entry.&n; */
r_static
id|__init
r_void
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
DECL|function|build_get_pgde32
id|build_get_pgde32
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_int
r_int
id|tmp
comma
r_int
r_int
id|ptr
)paren
(brace
r_int
id|pgdc
op_assign
(paren
r_int
)paren
id|pgd_current
suffix:semicolon
multiline_comment|/* 32 bit SMP has smp_processor_id() stored in CONTEXT. */
macro_line|#ifdef CONFIG_SMP
id|i_mfc0
c_func
(paren
id|p
comma
id|ptr
comma
id|C0_CONTEXT
)paren
suffix:semicolon
id|i_LA_mostly
c_func
(paren
id|p
comma
id|tmp
comma
id|pgdc
)paren
suffix:semicolon
id|i_srl
c_func
(paren
id|p
comma
id|ptr
comma
id|ptr
comma
l_int|23
)paren
suffix:semicolon
id|i_sll
c_func
(paren
id|p
comma
id|ptr
comma
id|ptr
comma
l_int|2
)paren
suffix:semicolon
id|i_addu
c_func
(paren
id|p
comma
id|ptr
comma
id|tmp
comma
id|ptr
)paren
suffix:semicolon
macro_line|#else
id|i_LA_mostly
c_func
(paren
id|p
comma
id|ptr
comma
id|pgdc
)paren
suffix:semicolon
macro_line|#endif
id|i_mfc0
c_func
(paren
id|p
comma
id|tmp
comma
id|C0_BADVADDR
)paren
suffix:semicolon
multiline_comment|/* get faulting address */
id|i_lw
c_func
(paren
id|p
comma
id|ptr
comma
id|rel_lo
c_func
(paren
id|pgdc
)paren
comma
id|ptr
)paren
suffix:semicolon
id|i_srl
c_func
(paren
id|p
comma
id|tmp
comma
id|tmp
comma
id|PGDIR_SHIFT
)paren
suffix:semicolon
multiline_comment|/* get pgd only bits */
id|i_sll
c_func
(paren
id|p
comma
id|tmp
comma
id|tmp
comma
id|PGD_T_LOG2
)paren
suffix:semicolon
id|i_addu
c_func
(paren
id|p
comma
id|ptr
comma
id|ptr
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/* add in pgd offset */
)brace
macro_line|#endif /* !CONFIG_MIPS64 */
DECL|function|build_adjust_context
r_static
id|__init
r_void
id|build_adjust_context
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_int
r_int
id|ctx
)paren
(brace
r_int
r_int
id|shift
op_assign
l_int|4
op_minus
(paren
id|PTE_T_LOG2
op_plus
l_int|1
)paren
suffix:semicolon
r_int
r_int
id|mask
op_assign
(paren
id|PTRS_PER_PTE
op_div
l_int|2
op_minus
l_int|1
)paren
op_lshift
(paren
id|PTE_T_LOG2
op_plus
l_int|1
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|current_cpu_data.cputype
)paren
(brace
r_case
id|CPU_VR41XX
suffix:colon
r_case
id|CPU_VR4111
suffix:colon
r_case
id|CPU_VR4121
suffix:colon
r_case
id|CPU_VR4122
suffix:colon
r_case
id|CPU_VR4131
suffix:colon
r_case
id|CPU_VR4181
suffix:colon
r_case
id|CPU_VR4181A
suffix:colon
r_case
id|CPU_VR4133
suffix:colon
id|shift
op_add_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|shift
)paren
id|i_SRL
c_func
(paren
id|p
comma
id|ctx
comma
id|ctx
comma
id|shift
)paren
suffix:semicolon
id|i_andi
c_func
(paren
id|p
comma
id|ctx
comma
id|ctx
comma
id|mask
)paren
suffix:semicolon
)brace
DECL|function|build_get_ptep
r_static
id|__init
r_void
id|build_get_ptep
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_int
r_int
id|tmp
comma
r_int
r_int
id|ptr
)paren
(brace
multiline_comment|/*&n;&t; * Bug workaround for the Nevada. It seems as if under certain&n;&t; * circumstances the move from cp0_context might produce a&n;&t; * bogus result when the mfc0 instruction and its consumer are&n;&t; * in a different cacheline or a load instruction, probably any&n;&t; * memory reference, is between them.&n;&t; */
r_switch
c_cond
(paren
id|current_cpu_data.cputype
)paren
(brace
r_case
id|CPU_NEVADA
suffix:colon
id|i_LW
c_func
(paren
id|p
comma
id|ptr
comma
l_int|0
comma
id|ptr
)paren
suffix:semicolon
id|GET_CONTEXT
c_func
(paren
id|p
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/* get context reg */
r_break
suffix:semicolon
r_default
suffix:colon
id|GET_CONTEXT
c_func
(paren
id|p
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/* get context reg */
id|i_LW
c_func
(paren
id|p
comma
id|ptr
comma
l_int|0
comma
id|ptr
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|build_adjust_context
c_func
(paren
id|p
comma
id|tmp
)paren
suffix:semicolon
id|i_ADDU
c_func
(paren
id|p
comma
id|ptr
comma
id|ptr
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/* add in offset */
)brace
DECL|function|build_update_entries
r_static
id|__init
r_void
id|build_update_entries
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_int
r_int
id|tmp
comma
r_int
r_int
id|ptep
)paren
(brace
multiline_comment|/*&n;&t; * 64bit address support (36bit on a 32bit CPU) in a 32bit&n;&t; * Kernel is a special case. Only a few CPUs use it.&n;&t; */
macro_line|#ifdef CONFIG_64BIT_PHYS_ADDR
r_if
c_cond
(paren
id|cpu_has_64bits
)paren
(brace
id|i_ld
c_func
(paren
id|p
comma
id|tmp
comma
l_int|0
comma
id|ptep
)paren
suffix:semicolon
multiline_comment|/* get even pte */
id|i_ld
c_func
(paren
id|p
comma
id|ptep
comma
r_sizeof
(paren
id|pte_t
)paren
comma
id|ptep
)paren
suffix:semicolon
multiline_comment|/* get odd pte */
id|i_dsrl
c_func
(paren
id|p
comma
id|tmp
comma
id|tmp
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/* convert to entrylo0 */
id|i_mtc0
c_func
(paren
id|p
comma
id|tmp
comma
id|C0_ENTRYLO0
)paren
suffix:semicolon
multiline_comment|/* load it */
id|i_dsrl
c_func
(paren
id|p
comma
id|ptep
comma
id|ptep
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/* convert to entrylo1 */
id|i_mtc0
c_func
(paren
id|p
comma
id|ptep
comma
id|C0_ENTRYLO1
)paren
suffix:semicolon
multiline_comment|/* load it */
)brace
r_else
(brace
r_int
id|pte_off_even
op_assign
r_sizeof
(paren
id|pte_t
)paren
op_div
l_int|2
suffix:semicolon
r_int
id|pte_off_odd
op_assign
id|pte_off_even
op_plus
r_sizeof
(paren
id|pte_t
)paren
suffix:semicolon
multiline_comment|/* The pte entries are pre-shifted */
id|i_lw
c_func
(paren
id|p
comma
id|tmp
comma
id|pte_off_even
comma
id|ptep
)paren
suffix:semicolon
multiline_comment|/* get even pte */
id|i_mtc0
c_func
(paren
id|p
comma
id|tmp
comma
id|C0_ENTRYLO0
)paren
suffix:semicolon
multiline_comment|/* load it */
id|i_lw
c_func
(paren
id|p
comma
id|ptep
comma
id|pte_off_odd
comma
id|ptep
)paren
suffix:semicolon
multiline_comment|/* get odd pte */
id|i_mtc0
c_func
(paren
id|p
comma
id|ptep
comma
id|C0_ENTRYLO1
)paren
suffix:semicolon
multiline_comment|/* load it */
)brace
macro_line|#else
id|i_LW
c_func
(paren
id|p
comma
id|tmp
comma
l_int|0
comma
id|ptep
)paren
suffix:semicolon
multiline_comment|/* get even pte */
id|i_LW
c_func
(paren
id|p
comma
id|ptep
comma
r_sizeof
(paren
id|pte_t
)paren
comma
id|ptep
)paren
suffix:semicolon
multiline_comment|/* get odd pte */
r_if
c_cond
(paren
id|r45k_bvahwbug
c_func
(paren
)paren
)paren
id|build_tlb_probe_entry
c_func
(paren
id|p
)paren
suffix:semicolon
id|i_SRL
c_func
(paren
id|p
comma
id|tmp
comma
id|tmp
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/* convert to entrylo0 */
r_if
c_cond
(paren
id|r4k_250MHZhwbug
c_func
(paren
)paren
)paren
id|i_mtc0
c_func
(paren
id|p
comma
l_int|0
comma
id|C0_ENTRYLO0
)paren
suffix:semicolon
id|i_mtc0
c_func
(paren
id|p
comma
id|tmp
comma
id|C0_ENTRYLO0
)paren
suffix:semicolon
multiline_comment|/* load it */
id|i_SRL
c_func
(paren
id|p
comma
id|ptep
comma
id|ptep
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/* convert to entrylo1 */
r_if
c_cond
(paren
id|r45k_bvahwbug
c_func
(paren
)paren
)paren
id|i_mfc0
c_func
(paren
id|p
comma
id|tmp
comma
id|C0_INDEX
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r4k_250MHZhwbug
c_func
(paren
)paren
)paren
id|i_mtc0
c_func
(paren
id|p
comma
l_int|0
comma
id|C0_ENTRYLO1
)paren
suffix:semicolon
id|i_mtc0
c_func
(paren
id|p
comma
id|ptep
comma
id|C0_ENTRYLO1
)paren
suffix:semicolon
multiline_comment|/* load it */
macro_line|#endif
)brace
DECL|function|build_r4000_tlb_refill_handler
r_static
r_void
id|__init
id|build_r4000_tlb_refill_handler
c_func
(paren
r_void
)paren
(brace
id|u32
op_star
id|p
op_assign
id|tlb_handler
suffix:semicolon
r_struct
id|label
op_star
id|l
op_assign
id|labels
suffix:semicolon
r_struct
id|reloc
op_star
id|r
op_assign
id|relocs
suffix:semicolon
id|u32
op_star
id|f
suffix:semicolon
r_int
r_int
id|final_len
suffix:semicolon
id|memset
c_func
(paren
id|tlb_handler
comma
l_int|0
comma
r_sizeof
(paren
id|tlb_handler
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|labels
comma
l_int|0
comma
r_sizeof
(paren
id|labels
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|relocs
comma
l_int|0
comma
r_sizeof
(paren
id|relocs
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|final_handler
comma
l_int|0
comma
r_sizeof
(paren
id|final_handler
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * create the plain linear handler&n;&t; */
r_if
c_cond
(paren
id|bcm1250_m3_war
c_func
(paren
)paren
)paren
(brace
id|i_MFC0
c_func
(paren
op_amp
id|p
comma
id|K0
comma
id|C0_BADVADDR
)paren
suffix:semicolon
id|i_MFC0
c_func
(paren
op_amp
id|p
comma
id|K1
comma
id|C0_ENTRYHI
)paren
suffix:semicolon
id|i_xor
c_func
(paren
op_amp
id|p
comma
id|K0
comma
id|K0
comma
id|K1
)paren
suffix:semicolon
id|i_SRL
c_func
(paren
op_amp
id|p
comma
id|K0
comma
id|K0
comma
id|PAGE_SHIFT
op_plus
l_int|1
)paren
suffix:semicolon
id|il_bnez
c_func
(paren
op_amp
id|p
comma
op_amp
id|r
comma
id|K0
comma
id|label_leave
)paren
suffix:semicolon
multiline_comment|/* No need for i_nop */
)brace
macro_line|#ifdef CONFIG_MIPS64
id|build_get_pmde64
c_func
(paren
op_amp
id|p
comma
op_amp
id|l
comma
op_amp
id|r
comma
id|K0
comma
id|K1
)paren
suffix:semicolon
multiline_comment|/* get pmd in K1 */
macro_line|#else
id|build_get_pgde32
c_func
(paren
op_amp
id|p
comma
id|K0
comma
id|K1
)paren
suffix:semicolon
multiline_comment|/* get pgd in K1 */
macro_line|#endif
id|build_get_ptep
c_func
(paren
op_amp
id|p
comma
id|K0
comma
id|K1
)paren
suffix:semicolon
id|build_update_entries
c_func
(paren
op_amp
id|p
comma
id|K0
comma
id|K1
)paren
suffix:semicolon
id|build_tlb_write_entry
c_func
(paren
op_amp
id|p
comma
op_amp
id|l
comma
op_amp
id|r
comma
id|tlb_random
)paren
suffix:semicolon
id|l_leave
c_func
(paren
op_amp
id|l
comma
id|p
)paren
suffix:semicolon
id|i_eret
c_func
(paren
op_amp
id|p
)paren
suffix:semicolon
multiline_comment|/* return from trap */
macro_line|#ifdef CONFIG_MIPS64
id|build_get_pgd_vmalloc64
c_func
(paren
op_amp
id|p
comma
op_amp
id|l
comma
op_amp
id|r
comma
id|K0
comma
id|K1
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Overflow check: For the 64bit handler, we need at least one&n;&t; * free instruction slot for the wrap-around branch. In worst&n;&t; * case, if the intended insertion point is a delay slot, we&n;&t; * need three, with the the second nop&squot;ed and the third being&n;&t; * unused.&n;&t; */
macro_line|#ifdef CONFIG_MIPS32
r_if
c_cond
(paren
(paren
id|p
op_minus
id|tlb_handler
)paren
OG
l_int|64
)paren
id|panic
c_func
(paren
l_string|&quot;TLB refill handler space exceeded&quot;
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
(paren
(paren
id|p
op_minus
id|tlb_handler
)paren
OG
l_int|63
)paren
op_logical_or
(paren
(paren
(paren
id|p
op_minus
id|tlb_handler
)paren
OG
l_int|61
)paren
op_logical_and
id|insn_has_bdelay
c_func
(paren
id|relocs
comma
id|tlb_handler
op_plus
l_int|29
)paren
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;TLB refill handler space exceeded&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Now fold the handler in the TLB refill handler space.&n;&t; */
macro_line|#ifdef CONFIG_MIPS32
id|f
op_assign
id|final_handler
suffix:semicolon
multiline_comment|/* Simplest case, just copy the handler. */
id|copy_handler
c_func
(paren
id|relocs
comma
id|labels
comma
id|tlb_handler
comma
id|p
comma
id|f
)paren
suffix:semicolon
id|final_len
op_assign
id|p
op_minus
id|tlb_handler
suffix:semicolon
macro_line|#else /* CONFIG_MIPS64 */
id|f
op_assign
id|final_handler
op_plus
l_int|32
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p
op_minus
id|tlb_handler
)paren
op_le
l_int|32
)paren
(brace
multiline_comment|/* Just copy the handler. */
id|copy_handler
c_func
(paren
id|relocs
comma
id|labels
comma
id|tlb_handler
comma
id|p
comma
id|f
)paren
suffix:semicolon
id|final_len
op_assign
id|p
op_minus
id|tlb_handler
suffix:semicolon
)brace
r_else
(brace
id|u32
op_star
id|split
op_assign
id|tlb_handler
op_plus
l_int|30
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Find the split point.&n;&t;&t; */
r_if
c_cond
(paren
id|insn_has_bdelay
c_func
(paren
id|relocs
comma
id|split
op_minus
l_int|1
)paren
)paren
id|split
op_decrement
suffix:semicolon
multiline_comment|/* Copy first part of the handler. */
id|copy_handler
c_func
(paren
id|relocs
comma
id|labels
comma
id|tlb_handler
comma
id|split
comma
id|f
)paren
suffix:semicolon
id|f
op_add_assign
id|split
op_minus
id|tlb_handler
suffix:semicolon
multiline_comment|/* Insert branch. */
id|l_split
c_func
(paren
op_amp
id|l
comma
id|final_handler
)paren
suffix:semicolon
id|il_b
c_func
(paren
op_amp
id|f
comma
op_amp
id|r
comma
id|label_split
)paren
suffix:semicolon
r_if
c_cond
(paren
id|insn_has_bdelay
c_func
(paren
id|relocs
comma
id|split
)paren
)paren
id|i_nop
c_func
(paren
op_amp
id|f
)paren
suffix:semicolon
r_else
(brace
id|copy_handler
c_func
(paren
id|relocs
comma
id|labels
comma
id|split
comma
id|split
op_plus
l_int|1
comma
id|f
)paren
suffix:semicolon
id|move_labels
c_func
(paren
id|labels
comma
id|f
comma
id|f
op_plus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|f
op_increment
suffix:semicolon
id|split
op_increment
suffix:semicolon
)brace
multiline_comment|/* Copy the rest of the handler. */
id|copy_handler
c_func
(paren
id|relocs
comma
id|labels
comma
id|split
comma
id|p
comma
id|final_handler
)paren
suffix:semicolon
id|final_len
op_assign
(paren
id|f
op_minus
(paren
id|final_handler
op_plus
l_int|32
)paren
)paren
op_plus
(paren
id|p
op_minus
id|split
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_MIPS64 */
id|resolve_relocs
c_func
(paren
id|relocs
comma
id|labels
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Synthesized TLB refill handler (%u instructions).&bslash;n&quot;
comma
id|final_len
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TLB
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%08x&bslash;n&quot;
comma
id|final_handler
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|CAC_BASE
comma
id|final_handler
comma
l_int|0x100
)paren
suffix:semicolon
id|flush_icache_range
c_func
(paren
id|CAC_BASE
comma
id|CAC_BASE
op_plus
l_int|0x100
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * TLB load/store/modify handlers.&n; *&n; * Only the fastpath gets synthesized at runtime, the slowpath for&n; * do_page_fault remains normal asm.&n; */
r_extern
r_void
id|tlb_do_page_fault_0
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|tlb_do_page_fault_1
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|__tlb_handler_align
mdefine_line|#define __tlb_handler_align &bslash;&n;&t;__attribute__((__aligned__(1 &lt;&lt; CONFIG_MIPS_L1_CACHE_SHIFT)))
multiline_comment|/*&n; * 128 instructions for the fastpath handler is generous and should&n; * never be exceeded.&n; */
DECL|macro|FASTPATH_SIZE
mdefine_line|#define FASTPATH_SIZE 128
DECL|variable|handle_tlbl
id|u32
id|__tlb_handler_align
id|handle_tlbl
(braket
id|FASTPATH_SIZE
)braket
suffix:semicolon
DECL|variable|handle_tlbs
id|u32
id|__tlb_handler_align
id|handle_tlbs
(braket
id|FASTPATH_SIZE
)braket
suffix:semicolon
DECL|variable|handle_tlbm
id|u32
id|__tlb_handler_align
id|handle_tlbm
(braket
id|FASTPATH_SIZE
)braket
suffix:semicolon
r_static
r_void
id|__init
DECL|function|iPTE_LW
id|iPTE_LW
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_struct
id|label
op_star
op_star
id|l
comma
r_int
r_int
id|pte
comma
r_int
id|offset
comma
r_int
r_int
id|ptr
)paren
(brace
macro_line|#ifdef CONFIG_SMP
macro_line|# ifdef CONFIG_64BIT_PHYS_ADDR
r_if
c_cond
(paren
id|cpu_has_64bits
)paren
id|i_lld
c_func
(paren
id|p
comma
id|pte
comma
id|offset
comma
id|ptr
)paren
suffix:semicolon
r_else
macro_line|# endif
id|i_LL
c_func
(paren
id|p
comma
id|pte
comma
id|offset
comma
id|ptr
)paren
suffix:semicolon
macro_line|#else
macro_line|# ifdef CONFIG_64BIT_PHYS_ADDR
r_if
c_cond
(paren
id|cpu_has_64bits
)paren
id|i_ld
c_func
(paren
id|p
comma
id|pte
comma
id|offset
comma
id|ptr
)paren
suffix:semicolon
r_else
macro_line|# endif
id|i_LW
c_func
(paren
id|p
comma
id|pte
comma
id|offset
comma
id|ptr
)paren
suffix:semicolon
macro_line|#endif
)brace
r_static
r_void
id|__init
DECL|function|iPTE_SW
id|iPTE_SW
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_struct
id|reloc
op_star
op_star
id|r
comma
r_int
r_int
id|pte
comma
r_int
id|offset
comma
r_int
r_int
id|ptr
)paren
(brace
macro_line|#ifdef CONFIG_SMP
macro_line|# ifdef CONFIG_64BIT_PHYS_ADDR
r_if
c_cond
(paren
id|cpu_has_64bits
)paren
id|i_scd
c_func
(paren
id|p
comma
id|pte
comma
id|offset
comma
id|ptr
)paren
suffix:semicolon
r_else
macro_line|# endif
id|i_SC
c_func
(paren
id|p
comma
id|pte
comma
id|offset
comma
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r10000_llsc_war
c_func
(paren
)paren
)paren
id|il_beqzl
c_func
(paren
id|p
comma
id|r
comma
id|pte
comma
id|label_smp_pgtable_change
)paren
suffix:semicolon
r_else
id|il_beqz
c_func
(paren
id|p
comma
id|r
comma
id|pte
comma
id|label_smp_pgtable_change
)paren
suffix:semicolon
macro_line|# ifdef CONFIG_64BIT_PHYS_ADDR
r_if
c_cond
(paren
op_logical_neg
id|cpu_has_64bits
)paren
(brace
multiline_comment|/* no i_nop needed */
id|i_ll
c_func
(paren
id|p
comma
id|pte
comma
r_sizeof
(paren
id|pte_t
)paren
op_div
l_int|2
comma
id|ptr
)paren
suffix:semicolon
id|i_ori
c_func
(paren
id|p
comma
id|pte
comma
id|pte
comma
id|_PAGE_VALID
)paren
suffix:semicolon
id|i_sc
c_func
(paren
id|p
comma
id|pte
comma
r_sizeof
(paren
id|pte_t
)paren
op_div
l_int|2
comma
id|ptr
)paren
suffix:semicolon
id|il_beqz
c_func
(paren
id|p
comma
id|r
comma
id|pte
comma
id|label_smp_pgtable_change
)paren
suffix:semicolon
multiline_comment|/* no i_nop needed */
id|i_lw
c_func
(paren
id|p
comma
id|pte
comma
l_int|0
comma
id|ptr
)paren
suffix:semicolon
)brace
r_else
id|i_nop
c_func
(paren
id|p
)paren
suffix:semicolon
macro_line|# else
id|i_nop
c_func
(paren
id|p
)paren
suffix:semicolon
macro_line|# endif
macro_line|#else
macro_line|# ifdef CONFIG_64BIT_PHYS_ADDR
r_if
c_cond
(paren
id|cpu_has_64bits
)paren
id|i_sd
c_func
(paren
id|p
comma
id|pte
comma
id|offset
comma
id|ptr
)paren
suffix:semicolon
r_else
macro_line|# endif
id|i_SW
c_func
(paren
id|p
comma
id|pte
comma
id|offset
comma
id|ptr
)paren
suffix:semicolon
macro_line|# ifdef CONFIG_64BIT_PHYS_ADDR
r_if
c_cond
(paren
op_logical_neg
id|cpu_has_64bits
)paren
(brace
id|i_lw
c_func
(paren
id|p
comma
id|pte
comma
r_sizeof
(paren
id|pte_t
)paren
op_div
l_int|2
comma
id|ptr
)paren
suffix:semicolon
id|i_ori
c_func
(paren
id|p
comma
id|pte
comma
id|pte
comma
id|_PAGE_VALID
)paren
suffix:semicolon
id|i_sw
c_func
(paren
id|p
comma
id|pte
comma
r_sizeof
(paren
id|pte_t
)paren
op_div
l_int|2
comma
id|ptr
)paren
suffix:semicolon
id|i_lw
c_func
(paren
id|p
comma
id|pte
comma
l_int|0
comma
id|ptr
)paren
suffix:semicolon
)brace
macro_line|# endif
macro_line|#endif
)brace
multiline_comment|/*&n; * Check if PTE is present, if not then jump to LABEL. PTR points to&n; * the page table where this PTE is located, PTE will be re-loaded&n; * with it&squot;s original value.&n; */
r_static
r_void
id|__init
DECL|function|build_pte_present
id|build_pte_present
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_struct
id|label
op_star
op_star
id|l
comma
r_struct
id|reloc
op_star
op_star
id|r
comma
r_int
r_int
id|pte
comma
r_int
r_int
id|ptr
comma
r_enum
id|label_id
id|lid
)paren
(brace
id|i_andi
c_func
(paren
id|p
comma
id|pte
comma
id|pte
comma
id|_PAGE_PRESENT
op_or
id|_PAGE_READ
)paren
suffix:semicolon
id|i_xori
c_func
(paren
id|p
comma
id|pte
comma
id|pte
comma
id|_PAGE_PRESENT
op_or
id|_PAGE_READ
)paren
suffix:semicolon
id|il_bnez
c_func
(paren
id|p
comma
id|r
comma
id|pte
comma
id|lid
)paren
suffix:semicolon
id|iPTE_LW
c_func
(paren
id|p
comma
id|l
comma
id|pte
comma
l_int|0
comma
id|ptr
)paren
suffix:semicolon
)brace
multiline_comment|/* Make PTE valid, store result in PTR. */
r_static
r_void
id|__init
DECL|function|build_make_valid
id|build_make_valid
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_struct
id|reloc
op_star
op_star
id|r
comma
r_int
r_int
id|pte
comma
r_int
r_int
id|ptr
)paren
(brace
id|i_ori
c_func
(paren
id|p
comma
id|pte
comma
id|pte
comma
id|_PAGE_VALID
op_or
id|_PAGE_ACCESSED
)paren
suffix:semicolon
id|iPTE_SW
c_func
(paren
id|p
comma
id|r
comma
id|pte
comma
l_int|0
comma
id|ptr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Check if PTE can be written to, if not branch to LABEL. Regardless&n; * restore PTE with value from PTR when done.&n; */
r_static
r_void
id|__init
DECL|function|build_pte_writable
id|build_pte_writable
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_struct
id|label
op_star
op_star
id|l
comma
r_struct
id|reloc
op_star
op_star
id|r
comma
r_int
r_int
id|pte
comma
r_int
r_int
id|ptr
comma
r_enum
id|label_id
id|lid
)paren
(brace
id|i_andi
c_func
(paren
id|p
comma
id|pte
comma
id|pte
comma
id|_PAGE_PRESENT
op_or
id|_PAGE_WRITE
)paren
suffix:semicolon
id|i_xori
c_func
(paren
id|p
comma
id|pte
comma
id|pte
comma
id|_PAGE_PRESENT
op_or
id|_PAGE_WRITE
)paren
suffix:semicolon
id|il_bnez
c_func
(paren
id|p
comma
id|r
comma
id|pte
comma
id|lid
)paren
suffix:semicolon
id|iPTE_LW
c_func
(paren
id|p
comma
id|l
comma
id|pte
comma
l_int|0
comma
id|ptr
)paren
suffix:semicolon
)brace
multiline_comment|/* Make PTE writable, update software status bits as well, then store&n; * at PTR.&n; */
r_static
r_void
id|__init
DECL|function|build_make_write
id|build_make_write
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_struct
id|reloc
op_star
op_star
id|r
comma
r_int
r_int
id|pte
comma
r_int
r_int
id|ptr
)paren
(brace
id|i_ori
c_func
(paren
id|p
comma
id|pte
comma
id|pte
comma
id|_PAGE_ACCESSED
op_or
id|_PAGE_MODIFIED
op_or
id|_PAGE_VALID
op_or
id|_PAGE_DIRTY
)paren
suffix:semicolon
id|iPTE_SW
c_func
(paren
id|p
comma
id|r
comma
id|pte
comma
l_int|0
comma
id|ptr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Check if PTE can be modified, if not branch to LABEL. Regardless&n; * restore PTE with value from PTR when done.&n; */
r_static
r_void
id|__init
DECL|function|build_pte_modifiable
id|build_pte_modifiable
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_struct
id|label
op_star
op_star
id|l
comma
r_struct
id|reloc
op_star
op_star
id|r
comma
r_int
r_int
id|pte
comma
r_int
r_int
id|ptr
comma
r_enum
id|label_id
id|lid
)paren
(brace
id|i_andi
c_func
(paren
id|p
comma
id|pte
comma
id|pte
comma
id|_PAGE_WRITE
)paren
suffix:semicolon
id|il_beqz
c_func
(paren
id|p
comma
id|r
comma
id|pte
comma
id|lid
)paren
suffix:semicolon
id|iPTE_LW
c_func
(paren
id|p
comma
id|l
comma
id|pte
comma
l_int|0
comma
id|ptr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * R3000 style TLB load/store/modify handlers.&n; */
multiline_comment|/* This places the pte in the page table at PTR into ENTRYLO0. */
r_static
r_void
id|__init
DECL|function|build_r3000_pte_reload
id|build_r3000_pte_reload
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_int
r_int
id|ptr
)paren
(brace
id|i_lw
c_func
(paren
id|p
comma
id|ptr
comma
l_int|0
comma
id|ptr
)paren
suffix:semicolon
id|i_nop
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/* load delay */
id|i_mtc0
c_func
(paren
id|p
comma
id|ptr
comma
id|C0_ENTRYLO0
)paren
suffix:semicolon
id|i_nop
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/* cp0 delay */
)brace
multiline_comment|/*&n; * The index register may have the probe fail bit set,&n; * because we would trap on access kseg2, i.e. without refill.&n; */
r_static
r_void
id|__init
DECL|function|build_r3000_tlb_write
id|build_r3000_tlb_write
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_struct
id|label
op_star
op_star
id|l
comma
r_struct
id|reloc
op_star
op_star
id|r
comma
r_int
r_int
id|tmp
)paren
(brace
id|i_mfc0
c_func
(paren
id|p
comma
id|tmp
comma
id|C0_INDEX
)paren
suffix:semicolon
id|i_nop
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/* cp0 delay */
id|il_bltz
c_func
(paren
id|p
comma
id|r
comma
id|tmp
comma
id|label_r3000_write_probe_fail
)paren
suffix:semicolon
id|i_nop
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/* branch delay */
id|i_tlbwi
c_func
(paren
id|p
)paren
suffix:semicolon
id|il_b
c_func
(paren
id|p
comma
id|r
comma
id|label_r3000_write_probe_ok
)paren
suffix:semicolon
id|i_nop
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/* branch delay */
id|l_r3000_write_probe_fail
c_func
(paren
id|l
comma
op_star
id|p
)paren
suffix:semicolon
id|i_tlbwr
c_func
(paren
id|p
)paren
suffix:semicolon
id|l_r3000_write_probe_ok
c_func
(paren
id|l
comma
op_star
id|p
)paren
suffix:semicolon
)brace
r_static
r_void
id|__init
DECL|function|build_r3000_tlbchange_handler_head
id|build_r3000_tlbchange_handler_head
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_int
r_int
id|pte
comma
r_int
r_int
id|ptr
)paren
(brace
r_int
id|pgdc
op_assign
(paren
r_int
)paren
id|pgd_current
suffix:semicolon
id|i_mfc0
c_func
(paren
id|p
comma
id|pte
comma
id|C0_BADVADDR
)paren
suffix:semicolon
id|i_lui
c_func
(paren
id|p
comma
id|ptr
comma
id|rel_hi
c_func
(paren
id|pgdc
)paren
)paren
suffix:semicolon
multiline_comment|/* cp0 delay */
id|i_lw
c_func
(paren
id|p
comma
id|ptr
comma
id|rel_lo
c_func
(paren
id|pgdc
)paren
comma
id|ptr
)paren
suffix:semicolon
id|i_srl
c_func
(paren
id|p
comma
id|pte
comma
id|pte
comma
l_int|22
)paren
suffix:semicolon
multiline_comment|/* load delay */
id|i_sll
c_func
(paren
id|p
comma
id|pte
comma
id|pte
comma
l_int|2
)paren
suffix:semicolon
id|i_addu
c_func
(paren
id|p
comma
id|ptr
comma
id|ptr
comma
id|pte
)paren
suffix:semicolon
id|i_mfc0
c_func
(paren
id|p
comma
id|pte
comma
id|C0_CONTEXT
)paren
suffix:semicolon
id|i_lw
c_func
(paren
id|p
comma
id|ptr
comma
l_int|0
comma
id|ptr
)paren
suffix:semicolon
multiline_comment|/* cp0 delay */
id|i_andi
c_func
(paren
id|p
comma
id|pte
comma
id|pte
comma
l_int|0xffc
)paren
suffix:semicolon
multiline_comment|/* load delay */
id|i_addu
c_func
(paren
id|p
comma
id|ptr
comma
id|ptr
comma
id|pte
)paren
suffix:semicolon
id|i_lw
c_func
(paren
id|p
comma
id|pte
comma
l_int|0
comma
id|ptr
)paren
suffix:semicolon
id|i_nop
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/* load delay */
id|i_tlbp
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_static
r_void
id|__init
DECL|function|build_r3000_tlbchange_handler_tail
id|build_r3000_tlbchange_handler_tail
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_int
r_int
id|tmp
)paren
(brace
id|i_mfc0
c_func
(paren
id|p
comma
id|tmp
comma
id|C0_EPC
)paren
suffix:semicolon
id|i_nop
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/* cp0 delay */
id|i_jr
c_func
(paren
id|p
comma
id|tmp
)paren
suffix:semicolon
id|i_rfe
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/* branch delay */
)brace
DECL|function|build_r3000_tlb_load_handler
r_static
r_void
id|__init
id|build_r3000_tlb_load_handler
c_func
(paren
r_void
)paren
(brace
id|u32
op_star
id|p
op_assign
id|handle_tlbl
suffix:semicolon
r_struct
id|label
op_star
id|l
op_assign
id|labels
suffix:semicolon
r_struct
id|reloc
op_star
id|r
op_assign
id|relocs
suffix:semicolon
id|memset
c_func
(paren
id|handle_tlbl
comma
l_int|0
comma
r_sizeof
(paren
id|handle_tlbl
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|labels
comma
l_int|0
comma
r_sizeof
(paren
id|labels
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|relocs
comma
l_int|0
comma
r_sizeof
(paren
id|relocs
)paren
)paren
suffix:semicolon
id|build_r3000_tlbchange_handler_head
c_func
(paren
op_amp
id|p
comma
id|K0
comma
id|K1
)paren
suffix:semicolon
id|build_pte_present
c_func
(paren
op_amp
id|p
comma
op_amp
id|l
comma
op_amp
id|r
comma
id|K0
comma
id|K1
comma
id|label_nopage_tlbl
)paren
suffix:semicolon
id|build_make_valid
c_func
(paren
op_amp
id|p
comma
op_amp
id|r
comma
id|K0
comma
id|K1
)paren
suffix:semicolon
id|build_r3000_pte_reload
c_func
(paren
op_amp
id|p
comma
id|K1
)paren
suffix:semicolon
id|build_r3000_tlb_write
c_func
(paren
op_amp
id|p
comma
op_amp
id|l
comma
op_amp
id|r
comma
id|K0
)paren
suffix:semicolon
id|build_r3000_tlbchange_handler_tail
c_func
(paren
op_amp
id|p
comma
id|K0
)paren
suffix:semicolon
id|l_nopage_tlbl
c_func
(paren
op_amp
id|l
comma
id|p
)paren
suffix:semicolon
id|i_j
c_func
(paren
op_amp
id|p
comma
(paren
r_int
r_int
)paren
id|tlb_do_page_fault_0
op_amp
l_int|0x0fffffff
)paren
suffix:semicolon
id|i_nop
c_func
(paren
op_amp
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p
op_minus
id|handle_tlbl
)paren
OG
id|FASTPATH_SIZE
)paren
id|panic
c_func
(paren
l_string|&quot;TLB load handler fastpath space exceeded&quot;
)paren
suffix:semicolon
id|resolve_relocs
c_func
(paren
id|relocs
comma
id|labels
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Synthesized TLB load handler fastpath (%u instructions).&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
(paren
id|p
op_minus
id|handle_tlbl
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TLB
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FASTPATH_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%08x&bslash;n&quot;
comma
id|handle_tlbl
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
id|handle_tlbl
comma
(paren
r_int
r_int
)paren
id|handle_tlbl
op_plus
id|FASTPATH_SIZE
op_star
r_sizeof
(paren
id|u32
)paren
)paren
suffix:semicolon
)brace
DECL|function|build_r3000_tlb_store_handler
r_static
r_void
id|__init
id|build_r3000_tlb_store_handler
c_func
(paren
r_void
)paren
(brace
id|u32
op_star
id|p
op_assign
id|handle_tlbs
suffix:semicolon
r_struct
id|label
op_star
id|l
op_assign
id|labels
suffix:semicolon
r_struct
id|reloc
op_star
id|r
op_assign
id|relocs
suffix:semicolon
id|memset
c_func
(paren
id|handle_tlbs
comma
l_int|0
comma
r_sizeof
(paren
id|handle_tlbs
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|labels
comma
l_int|0
comma
r_sizeof
(paren
id|labels
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|relocs
comma
l_int|0
comma
r_sizeof
(paren
id|relocs
)paren
)paren
suffix:semicolon
id|build_r3000_tlbchange_handler_head
c_func
(paren
op_amp
id|p
comma
id|K0
comma
id|K1
)paren
suffix:semicolon
id|build_pte_writable
c_func
(paren
op_amp
id|p
comma
op_amp
id|l
comma
op_amp
id|r
comma
id|K0
comma
id|K1
comma
id|label_nopage_tlbs
)paren
suffix:semicolon
id|build_make_write
c_func
(paren
op_amp
id|p
comma
op_amp
id|r
comma
id|K0
comma
id|K1
)paren
suffix:semicolon
id|build_r3000_pte_reload
c_func
(paren
op_amp
id|p
comma
id|K1
)paren
suffix:semicolon
id|build_r3000_tlb_write
c_func
(paren
op_amp
id|p
comma
op_amp
id|l
comma
op_amp
id|r
comma
id|K0
)paren
suffix:semicolon
id|build_r3000_tlbchange_handler_tail
c_func
(paren
op_amp
id|p
comma
id|K0
)paren
suffix:semicolon
id|l_nopage_tlbs
c_func
(paren
op_amp
id|l
comma
id|p
)paren
suffix:semicolon
id|i_j
c_func
(paren
op_amp
id|p
comma
(paren
r_int
r_int
)paren
id|tlb_do_page_fault_1
op_amp
l_int|0x0fffffff
)paren
suffix:semicolon
id|i_nop
c_func
(paren
op_amp
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p
op_minus
id|handle_tlbs
)paren
OG
id|FASTPATH_SIZE
)paren
id|panic
c_func
(paren
l_string|&quot;TLB store handler fastpath space exceeded&quot;
)paren
suffix:semicolon
id|resolve_relocs
c_func
(paren
id|relocs
comma
id|labels
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Synthesized TLB store handler fastpath (%u instructions).&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
(paren
id|p
op_minus
id|handle_tlbs
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TLB
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FASTPATH_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%08x&bslash;n&quot;
comma
id|handle_tlbs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
id|handle_tlbs
comma
(paren
r_int
r_int
)paren
id|handle_tlbs
op_plus
id|FASTPATH_SIZE
op_star
r_sizeof
(paren
id|u32
)paren
)paren
suffix:semicolon
)brace
DECL|function|build_r3000_tlb_modify_handler
r_static
r_void
id|__init
id|build_r3000_tlb_modify_handler
c_func
(paren
r_void
)paren
(brace
id|u32
op_star
id|p
op_assign
id|handle_tlbm
suffix:semicolon
r_struct
id|label
op_star
id|l
op_assign
id|labels
suffix:semicolon
r_struct
id|reloc
op_star
id|r
op_assign
id|relocs
suffix:semicolon
id|memset
c_func
(paren
id|handle_tlbm
comma
l_int|0
comma
r_sizeof
(paren
id|handle_tlbm
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|labels
comma
l_int|0
comma
r_sizeof
(paren
id|labels
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|relocs
comma
l_int|0
comma
r_sizeof
(paren
id|relocs
)paren
)paren
suffix:semicolon
id|build_r3000_tlbchange_handler_head
c_func
(paren
op_amp
id|p
comma
id|K0
comma
id|K1
)paren
suffix:semicolon
id|build_pte_modifiable
c_func
(paren
op_amp
id|p
comma
op_amp
id|l
comma
op_amp
id|r
comma
id|K0
comma
id|K1
comma
id|label_nopage_tlbm
)paren
suffix:semicolon
id|build_make_write
c_func
(paren
op_amp
id|p
comma
op_amp
id|r
comma
id|K0
comma
id|K1
)paren
suffix:semicolon
id|build_r3000_pte_reload
c_func
(paren
op_amp
id|p
comma
id|K1
)paren
suffix:semicolon
id|i_tlbwi
c_func
(paren
op_amp
id|p
)paren
suffix:semicolon
id|build_r3000_tlbchange_handler_tail
c_func
(paren
op_amp
id|p
comma
id|K0
)paren
suffix:semicolon
id|l_nopage_tlbm
c_func
(paren
op_amp
id|l
comma
id|p
)paren
suffix:semicolon
id|i_j
c_func
(paren
op_amp
id|p
comma
(paren
r_int
r_int
)paren
id|tlb_do_page_fault_1
op_amp
l_int|0x0fffffff
)paren
suffix:semicolon
id|i_nop
c_func
(paren
op_amp
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p
op_minus
id|handle_tlbm
)paren
OG
id|FASTPATH_SIZE
)paren
id|panic
c_func
(paren
l_string|&quot;TLB modify handler fastpath space exceeded&quot;
)paren
suffix:semicolon
id|resolve_relocs
c_func
(paren
id|relocs
comma
id|labels
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Synthesized TLB modify handler fastpath (%u instructions).&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
(paren
id|p
op_minus
id|handle_tlbm
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TLB
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FASTPATH_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%08x&bslash;n&quot;
comma
id|handle_tlbm
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
id|handle_tlbm
comma
(paren
r_int
r_int
)paren
id|handle_tlbm
op_plus
id|FASTPATH_SIZE
op_star
r_sizeof
(paren
id|u32
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * R4000 style TLB load/store/modify handlers.&n; */
r_static
r_void
id|__init
DECL|function|build_r4000_tlbchange_handler_head
id|build_r4000_tlbchange_handler_head
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_struct
id|label
op_star
op_star
id|l
comma
r_struct
id|reloc
op_star
op_star
id|r
comma
r_int
r_int
id|pte
comma
r_int
r_int
id|ptr
)paren
(brace
macro_line|#ifdef CONFIG_MIPS64
id|build_get_pmde64
c_func
(paren
id|p
comma
id|l
comma
id|r
comma
id|pte
comma
id|ptr
)paren
suffix:semicolon
multiline_comment|/* get pmd in ptr */
macro_line|#else
id|build_get_pgde32
c_func
(paren
id|p
comma
id|pte
comma
id|ptr
)paren
suffix:semicolon
multiline_comment|/* get pgd in ptr */
macro_line|#endif
id|i_MFC0
c_func
(paren
id|p
comma
id|pte
comma
id|C0_BADVADDR
)paren
suffix:semicolon
id|i_LW
c_func
(paren
id|p
comma
id|ptr
comma
l_int|0
comma
id|ptr
)paren
suffix:semicolon
id|i_SRL
c_func
(paren
id|p
comma
id|pte
comma
id|pte
comma
id|PAGE_SHIFT
op_plus
id|PTE_ORDER
op_minus
id|PTE_T_LOG2
)paren
suffix:semicolon
id|i_andi
c_func
(paren
id|p
comma
id|pte
comma
id|pte
comma
(paren
id|PTRS_PER_PTE
op_minus
l_int|1
)paren
op_lshift
id|PTE_T_LOG2
)paren
suffix:semicolon
id|i_ADDU
c_func
(paren
id|p
comma
id|ptr
comma
id|ptr
comma
id|pte
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|l_smp_pgtable_change
c_func
(paren
id|l
comma
op_star
id|p
)paren
suffix:semicolon
macro_line|# endif
id|iPTE_LW
c_func
(paren
id|p
comma
id|l
comma
id|pte
comma
l_int|0
comma
id|ptr
)paren
suffix:semicolon
multiline_comment|/* get even pte */
id|build_tlb_probe_entry
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_static
r_void
id|__init
DECL|function|build_r4000_tlbchange_handler_tail
id|build_r4000_tlbchange_handler_tail
c_func
(paren
id|u32
op_star
op_star
id|p
comma
r_struct
id|label
op_star
op_star
id|l
comma
r_struct
id|reloc
op_star
op_star
id|r
comma
r_int
r_int
id|tmp
comma
r_int
r_int
id|ptr
)paren
(brace
id|i_ori
c_func
(paren
id|p
comma
id|ptr
comma
id|ptr
comma
r_sizeof
(paren
id|pte_t
)paren
)paren
suffix:semicolon
id|i_xori
c_func
(paren
id|p
comma
id|ptr
comma
id|ptr
comma
r_sizeof
(paren
id|pte_t
)paren
)paren
suffix:semicolon
id|build_update_entries
c_func
(paren
id|p
comma
id|tmp
comma
id|ptr
)paren
suffix:semicolon
id|build_tlb_write_entry
c_func
(paren
id|p
comma
id|l
comma
id|r
comma
id|tlb_indexed
)paren
suffix:semicolon
id|l_leave
c_func
(paren
id|l
comma
op_star
id|p
)paren
suffix:semicolon
id|i_eret
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/* return from trap */
macro_line|#ifdef CONFIG_MIPS64
id|build_get_pgd_vmalloc64
c_func
(paren
id|p
comma
id|l
comma
id|r
comma
id|tmp
comma
id|ptr
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|build_r4000_tlb_load_handler
r_static
r_void
id|__init
id|build_r4000_tlb_load_handler
c_func
(paren
r_void
)paren
(brace
id|u32
op_star
id|p
op_assign
id|handle_tlbl
suffix:semicolon
r_struct
id|label
op_star
id|l
op_assign
id|labels
suffix:semicolon
r_struct
id|reloc
op_star
id|r
op_assign
id|relocs
suffix:semicolon
id|memset
c_func
(paren
id|handle_tlbl
comma
l_int|0
comma
r_sizeof
(paren
id|handle_tlbl
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|labels
comma
l_int|0
comma
r_sizeof
(paren
id|labels
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|relocs
comma
l_int|0
comma
r_sizeof
(paren
id|relocs
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bcm1250_m3_war
c_func
(paren
)paren
)paren
(brace
id|i_MFC0
c_func
(paren
op_amp
id|p
comma
id|K0
comma
id|C0_BADVADDR
)paren
suffix:semicolon
id|i_MFC0
c_func
(paren
op_amp
id|p
comma
id|K1
comma
id|C0_ENTRYHI
)paren
suffix:semicolon
id|i_xor
c_func
(paren
op_amp
id|p
comma
id|K0
comma
id|K0
comma
id|K1
)paren
suffix:semicolon
id|i_SRL
c_func
(paren
op_amp
id|p
comma
id|K0
comma
id|K0
comma
id|PAGE_SHIFT
op_plus
l_int|1
)paren
suffix:semicolon
id|il_bnez
c_func
(paren
op_amp
id|p
comma
op_amp
id|r
comma
id|K0
comma
id|label_leave
)paren
suffix:semicolon
multiline_comment|/* No need for i_nop */
)brace
id|build_r4000_tlbchange_handler_head
c_func
(paren
op_amp
id|p
comma
op_amp
id|l
comma
op_amp
id|r
comma
id|K0
comma
id|K1
)paren
suffix:semicolon
id|build_pte_present
c_func
(paren
op_amp
id|p
comma
op_amp
id|l
comma
op_amp
id|r
comma
id|K0
comma
id|K1
comma
id|label_nopage_tlbl
)paren
suffix:semicolon
id|build_make_valid
c_func
(paren
op_amp
id|p
comma
op_amp
id|r
comma
id|K0
comma
id|K1
)paren
suffix:semicolon
id|build_r4000_tlbchange_handler_tail
c_func
(paren
op_amp
id|p
comma
op_amp
id|l
comma
op_amp
id|r
comma
id|K0
comma
id|K1
)paren
suffix:semicolon
id|l_nopage_tlbl
c_func
(paren
op_amp
id|l
comma
id|p
)paren
suffix:semicolon
id|i_j
c_func
(paren
op_amp
id|p
comma
(paren
r_int
r_int
)paren
id|tlb_do_page_fault_0
op_amp
l_int|0x0fffffff
)paren
suffix:semicolon
id|i_nop
c_func
(paren
op_amp
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p
op_minus
id|handle_tlbl
)paren
OG
id|FASTPATH_SIZE
)paren
id|panic
c_func
(paren
l_string|&quot;TLB load handler fastpath space exceeded&quot;
)paren
suffix:semicolon
id|resolve_relocs
c_func
(paren
id|relocs
comma
id|labels
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Synthesized TLB load handler fastpath (%u instructions).&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
(paren
id|p
op_minus
id|handle_tlbl
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TLB
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FASTPATH_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%08x&bslash;n&quot;
comma
id|handle_tlbl
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
id|handle_tlbl
comma
(paren
r_int
r_int
)paren
id|handle_tlbl
op_plus
id|FASTPATH_SIZE
op_star
r_sizeof
(paren
id|u32
)paren
)paren
suffix:semicolon
)brace
DECL|function|build_r4000_tlb_store_handler
r_static
r_void
id|__init
id|build_r4000_tlb_store_handler
c_func
(paren
r_void
)paren
(brace
id|u32
op_star
id|p
op_assign
id|handle_tlbs
suffix:semicolon
r_struct
id|label
op_star
id|l
op_assign
id|labels
suffix:semicolon
r_struct
id|reloc
op_star
id|r
op_assign
id|relocs
suffix:semicolon
id|memset
c_func
(paren
id|handle_tlbs
comma
l_int|0
comma
r_sizeof
(paren
id|handle_tlbs
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|labels
comma
l_int|0
comma
r_sizeof
(paren
id|labels
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|relocs
comma
l_int|0
comma
r_sizeof
(paren
id|relocs
)paren
)paren
suffix:semicolon
id|build_r4000_tlbchange_handler_head
c_func
(paren
op_amp
id|p
comma
op_amp
id|l
comma
op_amp
id|r
comma
id|K0
comma
id|K1
)paren
suffix:semicolon
id|build_pte_writable
c_func
(paren
op_amp
id|p
comma
op_amp
id|l
comma
op_amp
id|r
comma
id|K0
comma
id|K1
comma
id|label_nopage_tlbs
)paren
suffix:semicolon
id|build_make_write
c_func
(paren
op_amp
id|p
comma
op_amp
id|r
comma
id|K0
comma
id|K1
)paren
suffix:semicolon
id|build_r4000_tlbchange_handler_tail
c_func
(paren
op_amp
id|p
comma
op_amp
id|l
comma
op_amp
id|r
comma
id|K0
comma
id|K1
)paren
suffix:semicolon
id|l_nopage_tlbs
c_func
(paren
op_amp
id|l
comma
id|p
)paren
suffix:semicolon
id|i_j
c_func
(paren
op_amp
id|p
comma
(paren
r_int
r_int
)paren
id|tlb_do_page_fault_1
op_amp
l_int|0x0fffffff
)paren
suffix:semicolon
id|i_nop
c_func
(paren
op_amp
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p
op_minus
id|handle_tlbs
)paren
OG
id|FASTPATH_SIZE
)paren
id|panic
c_func
(paren
l_string|&quot;TLB store handler fastpath space exceeded&quot;
)paren
suffix:semicolon
id|resolve_relocs
c_func
(paren
id|relocs
comma
id|labels
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Synthesized TLB store handler fastpath (%u instructions).&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
(paren
id|p
op_minus
id|handle_tlbs
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TLB
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FASTPATH_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%08x&bslash;n&quot;
comma
id|handle_tlbs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
id|handle_tlbs
comma
(paren
r_int
r_int
)paren
id|handle_tlbs
op_plus
id|FASTPATH_SIZE
op_star
r_sizeof
(paren
id|u32
)paren
)paren
suffix:semicolon
)brace
DECL|function|build_r4000_tlb_modify_handler
r_static
r_void
id|__init
id|build_r4000_tlb_modify_handler
c_func
(paren
r_void
)paren
(brace
id|u32
op_star
id|p
op_assign
id|handle_tlbm
suffix:semicolon
r_struct
id|label
op_star
id|l
op_assign
id|labels
suffix:semicolon
r_struct
id|reloc
op_star
id|r
op_assign
id|relocs
suffix:semicolon
id|memset
c_func
(paren
id|handle_tlbm
comma
l_int|0
comma
r_sizeof
(paren
id|handle_tlbm
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|labels
comma
l_int|0
comma
r_sizeof
(paren
id|labels
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|relocs
comma
l_int|0
comma
r_sizeof
(paren
id|relocs
)paren
)paren
suffix:semicolon
id|build_r4000_tlbchange_handler_head
c_func
(paren
op_amp
id|p
comma
op_amp
id|l
comma
op_amp
id|r
comma
id|K0
comma
id|K1
)paren
suffix:semicolon
id|build_pte_modifiable
c_func
(paren
op_amp
id|p
comma
op_amp
id|l
comma
op_amp
id|r
comma
id|K0
comma
id|K1
comma
id|label_nopage_tlbm
)paren
suffix:semicolon
multiline_comment|/* Present and writable bits set, set accessed and dirty bits. */
id|build_make_write
c_func
(paren
op_amp
id|p
comma
op_amp
id|r
comma
id|K0
comma
id|K1
)paren
suffix:semicolon
id|build_r4000_tlbchange_handler_tail
c_func
(paren
op_amp
id|p
comma
op_amp
id|l
comma
op_amp
id|r
comma
id|K0
comma
id|K1
)paren
suffix:semicolon
id|l_nopage_tlbm
c_func
(paren
op_amp
id|l
comma
id|p
)paren
suffix:semicolon
id|i_j
c_func
(paren
op_amp
id|p
comma
(paren
r_int
r_int
)paren
id|tlb_do_page_fault_1
op_amp
l_int|0x0fffffff
)paren
suffix:semicolon
id|i_nop
c_func
(paren
op_amp
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p
op_minus
id|handle_tlbm
)paren
OG
id|FASTPATH_SIZE
)paren
id|panic
c_func
(paren
l_string|&quot;TLB modify handler fastpath space exceeded&quot;
)paren
suffix:semicolon
id|resolve_relocs
c_func
(paren
id|relocs
comma
id|labels
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Synthesized TLB modify handler fastpath (%u instructions).&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
(paren
id|p
op_minus
id|handle_tlbm
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TLB
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FASTPATH_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%08x&bslash;n&quot;
comma
id|handle_tlbm
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
id|handle_tlbm
comma
(paren
r_int
r_int
)paren
id|handle_tlbm
op_plus
id|FASTPATH_SIZE
op_star
r_sizeof
(paren
id|u32
)paren
)paren
suffix:semicolon
)brace
DECL|function|build_tlb_refill_handler
r_void
id|__init
id|build_tlb_refill_handler
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * The refill handler is generated per-CPU, multi-node systems&n;&t; * may have local storage for it. The other handlers are only&n;&t; * needed once.&n;&t; */
r_static
r_int
id|run_once
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|current_cpu_data.cputype
)paren
(brace
r_case
id|CPU_R2000
suffix:colon
r_case
id|CPU_R3000
suffix:colon
r_case
id|CPU_R3000A
suffix:colon
r_case
id|CPU_R3081E
suffix:colon
r_case
id|CPU_TX3912
suffix:colon
r_case
id|CPU_TX3922
suffix:colon
r_case
id|CPU_TX3927
suffix:colon
id|build_r3000_tlb_refill_handler
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|run_once
)paren
(brace
id|build_r3000_tlb_load_handler
c_func
(paren
)paren
suffix:semicolon
id|build_r3000_tlb_store_handler
c_func
(paren
)paren
suffix:semicolon
id|build_r3000_tlb_modify_handler
c_func
(paren
)paren
suffix:semicolon
id|run_once
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CPU_R6000
suffix:colon
r_case
id|CPU_R6000A
suffix:colon
id|panic
c_func
(paren
l_string|&quot;No R6000 TLB refill handler yet&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPU_R8000
suffix:colon
id|panic
c_func
(paren
l_string|&quot;No R8000 TLB refill handler yet&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|build_r4000_tlb_refill_handler
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|run_once
)paren
(brace
id|build_r4000_tlb_load_handler
c_func
(paren
)paren
suffix:semicolon
id|build_r4000_tlb_store_handler
c_func
(paren
)paren
suffix:semicolon
id|build_r4000_tlb_modify_handler
c_func
(paren
)paren
suffix:semicolon
id|run_once
op_increment
suffix:semicolon
)brace
)brace
)brace
eof
