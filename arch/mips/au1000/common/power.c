multiline_comment|/*&n; * BRIEF MODULE DESCRIPTION&n; *&t;Au1000 Power Management routines.&n; *&n; * Copyright 2001 MontaVista Software Inc.&n; * Author: MontaVista Software, Inc.&n; *&t;&t;ppopov@mvista.com or source@mvista.com&n; *&n; *  Some of the routines are right out of init/main.c, whose&n; *  copyrights apply here.&n; *&n; *  This program is free software; you can redistribute&t; it and/or modify it&n; *  under  the terms of&t; the GNU General  Public License as published by the&n; *  Free Software Foundation;  either version 2 of the&t;License, or (at your&n; *  option) any later version.&n; *&n; *  THIS  SOFTWARE  IS PROVIDED&t;  ``AS&t;IS&squot;&squot; AND   ANY&t;EXPRESS OR IMPLIED&n; *  WARRANTIES,&t;  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF&n; *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN&n; *  NO&t;EVENT  SHALL   THE AUTHOR  BE&t; LIABLE FOR ANY&t;  DIRECT, INDIRECT,&n; *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT&n; *  NOT LIMITED&t;  TO, PROCUREMENT OF  SUBSTITUTE GOODS&t;OR SERVICES; LOSS OF&n; *  USE, DATA,&t;OR PROFITS; OR&t;BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON&n; *  ANY THEORY OF LIABILITY, WHETHER IN&t; CONTRACT, STRICT LIABILITY, OR TORT&n; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF&n; *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; *&n; *  You should have received a copy of the  GNU General Public License along&n; *  with this program; if not, write  to the Free Software Foundation, Inc.,&n; *  675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/pm.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;asm/string.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/au1000.h&gt;
DECL|macro|DEBUG
mdefine_line|#define DEBUG 1
macro_line|#ifdef DEBUG
DECL|macro|DPRINTK
macro_line|#  define DPRINTK(fmt, args...)&t;printk(&quot;%s: &quot; fmt, __FUNCTION__ , ## args)
macro_line|#else
DECL|macro|DPRINTK
macro_line|#  define DPRINTK(fmt, args...)
macro_line|#endif
r_extern
r_void
id|au1k_wait
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|calibrate_delay
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|set_au1000_speed
c_func
(paren
r_int
r_int
id|new_freq
)paren
suffix:semicolon
r_extern
r_int
r_int
id|get_au1000_speed
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
r_int
id|get_au1000_uart_baud_base
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|set_au1000_uart_baud_base
c_func
(paren
r_int
r_int
id|new_baud_base
)paren
suffix:semicolon
r_extern
r_int
r_int
id|save_local_and_disable
c_func
(paren
r_int
id|controller
)paren
suffix:semicolon
r_extern
r_void
id|restore_local_and_enable
c_func
(paren
r_int
id|controller
comma
r_int
r_int
id|mask
)paren
suffix:semicolon
r_extern
r_void
id|local_enable_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
suffix:semicolon
multiline_comment|/* Quick acpi hack. This will have to change! */
DECL|macro|CTL_ACPI
mdefine_line|#define&t;CTL_ACPI 9999
DECL|macro|ACPI_S1_SLP_TYP
mdefine_line|#define&t;ACPI_S1_SLP_TYP 19
DECL|macro|ACPI_SLEEP
mdefine_line|#define&t;ACPI_SLEEP 21
macro_line|#ifdef CONFIG_PM
DECL|variable|pm_lock
r_static
id|spinlock_t
id|pm_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|suspend_mode
r_int
r_int
id|suspend_mode
suffix:semicolon
DECL|function|wakeup_from_suspend
r_void
id|wakeup_from_suspend
c_func
(paren
r_void
)paren
(brace
id|suspend_mode
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|au_sleep
r_int
id|au_sleep
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|wakeup
comma
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pm_lock
comma
id|flags
)paren
suffix:semicolon
id|flush_cache_all
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* pin 6 is gpio */
id|au_writel
c_func
(paren
id|au_readl
c_func
(paren
id|SYS_PINSTATERD
)paren
op_amp
op_complement
(paren
l_int|1
op_lshift
l_int|11
)paren
comma
id|SYS_PINSTATERD
)paren
suffix:semicolon
multiline_comment|/* gpio 6 can cause a wake up event */
id|wakeup
op_assign
id|au_readl
c_func
(paren
id|SYS_WAKEMSK
)paren
suffix:semicolon
id|wakeup
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* turn off match20 wakeup */
id|wakeup
op_or_assign
l_int|1
op_lshift
l_int|6
suffix:semicolon
multiline_comment|/* turn on gpio 6 wakeup   */
id|au_writel
c_func
(paren
id|wakeup
comma
id|SYS_WAKEMSK
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
comma
id|SYS_WAKESRC
)paren
suffix:semicolon
multiline_comment|/* clear cause */
id|au_writel
c_func
(paren
l_int|1
comma
id|SYS_SLPPWR
)paren
suffix:semicolon
multiline_comment|/* prepare to sleep */
id|__asm__
c_func
(paren
l_string|&quot;la $4, 1f&bslash;n&bslash;t&quot;
l_string|&quot;lui $5, 0xb190&bslash;n&bslash;t&quot;
l_string|&quot;ori $5, 0x18&bslash;n&bslash;t&quot;
l_string|&quot;sw $4, 0($5)&bslash;n&bslash;t&quot;
l_string|&quot;li $4, 1&bslash;n&bslash;t&quot;
l_string|&quot;lui $5, 0xb190&bslash;n&bslash;t&quot;
l_string|&quot;ori $5, 0x7c&bslash;n&bslash;t&quot;
l_string|&quot;sw $4, 0($5)&bslash;n&bslash;t&quot;
l_string|&quot;sync&bslash;n&bslash;t&quot;
l_string|&quot;1:&bslash;t&bslash;n&bslash;t&quot;
l_string|&quot;nop&bslash;n&bslash;t&quot;
)paren
suffix:semicolon
multiline_comment|/* after a wakeup, the cpu vectors back to 0x1fc00000 so&n;&t; * it&squot;s up to the boot code to get us back here.&n;&t; */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pm_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pm_do_sleep
r_static
r_int
id|pm_do_sleep
c_func
(paren
id|ctl_table
op_star
id|ctl
comma
r_int
id|write
comma
r_struct
id|file
op_star
id|file
comma
r_void
op_star
id|buffer
comma
r_int
op_star
id|len
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|write
)paren
(brace
op_star
id|len
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
id|pm_send_all
c_func
(paren
id|PM_SUSPEND
comma
(paren
r_void
op_star
)paren
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|au_sleep
c_func
(paren
)paren
suffix:semicolon
id|retval
op_assign
id|pm_send_all
c_func
(paren
id|PM_RESUME
comma
(paren
r_void
op_star
)paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|pm_do_suspend
r_static
r_int
id|pm_do_suspend
c_func
(paren
id|ctl_table
op_star
id|ctl
comma
r_int
id|write
comma
r_struct
id|file
op_star
id|file
comma
r_void
op_star
id|buffer
comma
r_int
op_star
id|len
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|write
)paren
(brace
op_star
id|len
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
id|pm_send_all
c_func
(paren
id|PM_SUSPEND
comma
(paren
r_void
op_star
)paren
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|suspend_mode
op_assign
l_int|1
suffix:semicolon
id|au1k_wait
c_func
(paren
)paren
suffix:semicolon
id|retval
op_assign
id|pm_send_all
c_func
(paren
id|PM_RESUME
comma
(paren
r_void
op_star
)paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|pm_do_freq
r_static
r_int
id|pm_do_freq
c_func
(paren
id|ctl_table
op_star
id|ctl
comma
r_int
id|write
comma
r_struct
id|file
op_star
id|file
comma
r_void
op_star
id|buffer
comma
r_int
op_star
id|len
)paren
(brace
r_int
id|retval
op_assign
l_int|0
comma
id|i
suffix:semicolon
r_int
r_int
id|val
comma
id|pll
suffix:semicolon
DECL|macro|TMPBUFLEN
mdefine_line|#define TMPBUFLEN 64
DECL|macro|MAX_CPU_FREQ
mdefine_line|#define MAX_CPU_FREQ 396
r_char
id|buf
(braket
l_int|8
)braket
comma
op_star
id|p
suffix:semicolon
r_int
r_int
id|flags
comma
id|intc0_mask
comma
id|intc1_mask
suffix:semicolon
r_int
r_int
id|old_baud_base
comma
id|old_cpu_freq
comma
id|baud_rate
comma
id|old_clk
comma
id|old_refresh
suffix:semicolon
r_int
r_int
id|new_baud_base
comma
id|new_cpu_freq
comma
id|new_clk
comma
id|new_refresh
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pm_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|write
)paren
(brace
op_star
id|len
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Parse the new frequency */
r_if
c_cond
(paren
op_star
id|len
OG
id|TMPBUFLEN
op_minus
l_int|1
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pm_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|buf
comma
id|buffer
comma
op_star
id|len
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pm_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|buf
(braket
op_star
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|p
op_assign
id|buf
suffix:semicolon
id|val
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
OG
id|MAX_CPU_FREQ
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pm_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|pll
op_assign
id|val
op_div
l_int|12
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pll
OG
l_int|33
)paren
op_logical_or
(paren
id|pll
OL
l_int|7
)paren
)paren
(brace
multiline_comment|/* 396 MHz max, 84 MHz min */
multiline_comment|/* revisit this for higher speed cpus */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pm_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|old_baud_base
op_assign
id|get_au1000_uart_baud_base
c_func
(paren
)paren
suffix:semicolon
id|old_cpu_freq
op_assign
id|get_au1000_speed
c_func
(paren
)paren
suffix:semicolon
id|new_cpu_freq
op_assign
id|pll
op_star
l_int|12
op_star
l_int|1000000
suffix:semicolon
id|new_baud_base
op_assign
(paren
id|new_cpu_freq
op_div
l_int|4
)paren
op_div
l_int|16
suffix:semicolon
id|set_au1000_speed
c_func
(paren
id|new_cpu_freq
)paren
suffix:semicolon
id|set_au1000_uart_baud_base
c_func
(paren
id|new_baud_base
)paren
suffix:semicolon
id|old_refresh
op_assign
id|au_readl
c_func
(paren
id|MEM_SDREFCFG
)paren
op_amp
l_int|0x1ffffff
suffix:semicolon
id|new_refresh
op_assign
(paren
(paren
id|old_refresh
op_star
id|new_cpu_freq
)paren
op_div
id|old_cpu_freq
)paren
op_or
(paren
id|au_readl
c_func
(paren
id|MEM_SDREFCFG
)paren
op_amp
op_complement
l_int|0x1ffffff
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|pll
comma
id|SYS_CPUPLL
)paren
suffix:semicolon
id|au_sync_delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|new_refresh
comma
id|MEM_SDREFCFG
)paren
suffix:semicolon
id|au_sync_delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|au_readl
(paren
id|UART_BASE
op_plus
id|UART_MOD_CNTRL
op_plus
id|i
op_star
l_int|0x00100000
)paren
op_eq
l_int|3
)paren
(brace
id|old_clk
op_assign
id|au_readl
c_func
(paren
id|UART_BASE
op_plus
id|UART_CLK
op_plus
id|i
op_star
l_int|0x00100000
)paren
suffix:semicolon
singleline_comment|// baud_rate = baud_base/clk
id|baud_rate
op_assign
id|old_baud_base
op_div
id|old_clk
suffix:semicolon
multiline_comment|/* we won&squot;t get an exact baud rate and the error&n;&t;&t;&t;&t; * could be significant enough that our new&n;&t;&t;&t;&t; * calculation will result in a clock that will&n;&t;&t;&t;&t; * give us a baud rate that&squot;s too far off from&n;&t;&t;&t;&t; * what we really want.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|baud_rate
OG
l_int|100000
)paren
id|baud_rate
op_assign
l_int|115200
suffix:semicolon
r_else
r_if
c_cond
(paren
id|baud_rate
OG
l_int|50000
)paren
id|baud_rate
op_assign
l_int|57600
suffix:semicolon
r_else
r_if
c_cond
(paren
id|baud_rate
OG
l_int|30000
)paren
id|baud_rate
op_assign
l_int|38400
suffix:semicolon
r_else
r_if
c_cond
(paren
id|baud_rate
OG
l_int|17000
)paren
id|baud_rate
op_assign
l_int|19200
suffix:semicolon
r_else
(paren
id|baud_rate
op_assign
l_int|9600
)paren
suffix:semicolon
singleline_comment|// new_clk = new_baud_base/baud_rate
id|new_clk
op_assign
id|new_baud_base
op_div
id|baud_rate
suffix:semicolon
id|au_writel
c_func
(paren
id|new_clk
comma
id|UART_BASE
op_plus
id|UART_CLK
op_plus
id|i
op_star
l_int|0x00100000
)paren
suffix:semicolon
id|au_sync_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* We don&squot;t want _any_ interrupts other than&n;&t; * match20. Otherwise our calibrate_delay()&n;&t; * calculation will be off, potentially a lot.&n;&t; */
id|intc0_mask
op_assign
id|save_local_and_disable
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|intc1_mask
op_assign
id|save_local_and_disable
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|local_enable_irq
c_func
(paren
id|AU1000_TOY_MATCH2_INT
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pm_lock
comma
id|flags
)paren
suffix:semicolon
id|calibrate_delay
c_func
(paren
)paren
suffix:semicolon
id|restore_local_and_enable
c_func
(paren
l_int|0
comma
id|intc0_mask
)paren
suffix:semicolon
id|restore_local_and_enable
c_func
(paren
l_int|1
comma
id|intc1_mask
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|pm_table
r_static
r_struct
id|ctl_table
id|pm_table
(braket
)braket
op_assign
(brace
(brace
id|ACPI_S1_SLP_TYP
comma
l_string|&quot;suspend&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0600
comma
l_int|NULL
comma
op_amp
id|pm_do_suspend
)brace
comma
(brace
id|ACPI_SLEEP
comma
l_string|&quot;sleep&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0600
comma
l_int|NULL
comma
op_amp
id|pm_do_sleep
)brace
comma
(brace
id|CTL_ACPI
comma
l_string|&quot;freq&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0600
comma
l_int|NULL
comma
op_amp
id|pm_do_freq
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|pm_dir_table
r_static
r_struct
id|ctl_table
id|pm_dir_table
(braket
)braket
op_assign
(brace
(brace
id|CTL_ACPI
comma
l_string|&quot;pm&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0555
comma
id|pm_table
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * Initialize power interface&n; */
DECL|function|pm_init
r_static
r_int
id|__init
id|pm_init
c_func
(paren
r_void
)paren
(brace
id|register_sysctl_table
c_func
(paren
id|pm_dir_table
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|pm_init
id|__initcall
c_func
(paren
id|pm_init
)paren
suffix:semicolon
multiline_comment|/*&n; * This is right out of init/main.c&n; */
multiline_comment|/* This is the number of bits of precision for the loops_per_jiffy.  Each&n;   bit takes on average 1.5/HZ seconds.  This (like the original) is a little&n;   better than 1% */
DECL|macro|LPS_PREC
mdefine_line|#define LPS_PREC 8
DECL|function|calibrate_delay
r_static
r_void
id|calibrate_delay
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|ticks
comma
id|loopbit
suffix:semicolon
r_int
id|lps_precision
op_assign
id|LPS_PREC
suffix:semicolon
id|loops_per_jiffy
op_assign
(paren
l_int|1
op_lshift
l_int|12
)paren
suffix:semicolon
r_while
c_loop
(paren
id|loops_per_jiffy
op_lshift_assign
l_int|1
)paren
(brace
multiline_comment|/* wait for &quot;start of&quot; clock tick */
id|ticks
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
id|ticks
op_eq
id|jiffies
)paren
multiline_comment|/* nothing */
suffix:semicolon
multiline_comment|/* Go .. */
id|ticks
op_assign
id|jiffies
suffix:semicolon
id|__delay
c_func
(paren
id|loops_per_jiffy
)paren
suffix:semicolon
id|ticks
op_assign
id|jiffies
op_minus
id|ticks
suffix:semicolon
r_if
c_cond
(paren
id|ticks
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Do a binary approximation to get loops_per_jiffy set to equal one clock&n;   (up to lps_precision bits) */
id|loops_per_jiffy
op_rshift_assign
l_int|1
suffix:semicolon
id|loopbit
op_assign
id|loops_per_jiffy
suffix:semicolon
r_while
c_loop
(paren
id|lps_precision
op_decrement
op_logical_and
(paren
id|loopbit
op_rshift_assign
l_int|1
)paren
)paren
(brace
id|loops_per_jiffy
op_or_assign
id|loopbit
suffix:semicolon
id|ticks
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
id|ticks
op_eq
id|jiffies
)paren
suffix:semicolon
id|ticks
op_assign
id|jiffies
suffix:semicolon
id|__delay
c_func
(paren
id|loops_per_jiffy
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jiffies
op_ne
id|ticks
)paren
multiline_comment|/* longer than 1 tick */
id|loops_per_jiffy
op_and_assign
op_complement
id|loopbit
suffix:semicolon
)brace
)brace
DECL|function|au1k_wait
r_void
id|au1k_wait
c_func
(paren
r_void
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;nop&bslash;n&bslash;t&quot;
l_string|&quot;nop&bslash;n&bslash;t&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* CONFIG_PM */
eof
