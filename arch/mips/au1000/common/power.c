multiline_comment|/*&n; * BRIEF MODULE DESCRIPTION&n; *&t;Au1000 Power Management routines.&n; *&n; * Copyright 2001 MontaVista Software Inc.&n; * Author: MontaVista Software, Inc.&n; *&t;&t;ppopov@mvista.com or source@mvista.com&n; *&n; *  Some of the routines are right out of init/main.c, whose&n; *  copyrights apply here.&n; *&n; *  This program is free software; you can redistribute&t; it and/or modify it&n; *  under  the terms of&t; the GNU General  Public License as published by the&n; *  Free Software Foundation;  either version 2 of the&t;License, or (at your&n; *  option) any later version.&n; *&n; *  THIS  SOFTWARE  IS PROVIDED&t;  ``AS&t;IS&squot;&squot; AND   ANY&t;EXPRESS OR IMPLIED&n; *  WARRANTIES,&t;  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF&n; *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN&n; *  NO&t;EVENT  SHALL   THE AUTHOR  BE&t; LIABLE FOR ANY&t;  DIRECT, INDIRECT,&n; *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT&n; *  NOT LIMITED&t;  TO, PROCUREMENT OF  SUBSTITUTE GOODS&t;OR SERVICES; LOSS OF&n; *  USE, DATA,&t;OR PROFITS; OR&t;BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON&n; *  ANY THEORY OF LIABILITY, WHETHER IN&t; CONTRACT, STRICT LIABILITY, OR TORT&n; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF&n; *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; *&n; *  You should have received a copy of the  GNU General Public License along&n; *  with this program; if not, write  to the Free Software Foundation, Inc.,&n; *  675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/pm.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;asm/string.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/mach-au1x00/au1000.h&gt;
macro_line|#ifdef CONFIG_PM
DECL|macro|DEBUG
mdefine_line|#define DEBUG 1
macro_line|#ifdef DEBUG
DECL|macro|DPRINTK
macro_line|#  define DPRINTK(fmt, args...)&t;printk(&quot;%s: &quot; fmt, __FUNCTION__ , ## args)
macro_line|#else
DECL|macro|DPRINTK
macro_line|#  define DPRINTK(fmt, args...)
macro_line|#endif
r_static
r_void
id|calibrate_delay
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|set_au1x00_speed
c_func
(paren
r_int
r_int
id|new_freq
)paren
suffix:semicolon
r_extern
r_int
r_int
id|get_au1x00_speed
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
r_int
id|get_au1x00_uart_baud_base
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|set_au1x00_uart_baud_base
c_func
(paren
r_int
r_int
id|new_baud_base
)paren
suffix:semicolon
r_extern
r_int
r_int
id|save_local_and_disable
c_func
(paren
r_int
id|controller
)paren
suffix:semicolon
r_extern
r_void
id|restore_local_and_enable
c_func
(paren
r_int
id|controller
comma
r_int
r_int
id|mask
)paren
suffix:semicolon
r_extern
r_void
id|local_enable_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
suffix:semicolon
multiline_comment|/* Quick acpi hack. This will have to change! */
DECL|macro|CTL_ACPI
mdefine_line|#define&t;CTL_ACPI 9999
DECL|macro|ACPI_S1_SLP_TYP
mdefine_line|#define&t;ACPI_S1_SLP_TYP 19
DECL|macro|ACPI_SLEEP
mdefine_line|#define&t;ACPI_SLEEP 21
DECL|variable|pm_lock
r_static
id|spinlock_t
id|pm_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* We need to save/restore a bunch of core registers that are&n; * either volatile or reset to some state across a processor sleep.&n; * If reading a register doesn&squot;t provide a proper result for a&n; * later restore, we have to provide a function for loading that&n; * register and save a copy.&n; *&n; * We only have to save/restore registers that aren&squot;t otherwise&n; * done as part of a driver pm_* function.&n; */
DECL|variable|sleep_aux_pll_cntrl
r_static
id|uint
id|sleep_aux_pll_cntrl
suffix:semicolon
DECL|variable|sleep_cpu_pll_cntrl
r_static
id|uint
id|sleep_cpu_pll_cntrl
suffix:semicolon
DECL|variable|sleep_pin_function
r_static
id|uint
id|sleep_pin_function
suffix:semicolon
DECL|variable|sleep_uart0_inten
r_static
id|uint
id|sleep_uart0_inten
suffix:semicolon
DECL|variable|sleep_uart0_fifoctl
r_static
id|uint
id|sleep_uart0_fifoctl
suffix:semicolon
DECL|variable|sleep_uart0_linectl
r_static
id|uint
id|sleep_uart0_linectl
suffix:semicolon
DECL|variable|sleep_uart0_clkdiv
r_static
id|uint
id|sleep_uart0_clkdiv
suffix:semicolon
DECL|variable|sleep_uart0_enable
r_static
id|uint
id|sleep_uart0_enable
suffix:semicolon
DECL|variable|sleep_usbhost_enable
r_static
id|uint
id|sleep_usbhost_enable
suffix:semicolon
DECL|variable|sleep_usbdev_enable
r_static
id|uint
id|sleep_usbdev_enable
suffix:semicolon
DECL|variable|sleep_static_memctlr
r_static
id|uint
id|sleep_static_memctlr
(braket
l_int|4
)braket
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Define this to cause the value you write to /proc/sys/pm/sleep to&n; * set the TOY timer for the amount of time you want to sleep.&n; * This is done mainly for testing, but may be useful in other cases.&n; * The value is number of 32KHz ticks to sleep.&n; */
DECL|macro|SLEEP_TEST_TIMEOUT
mdefine_line|#define SLEEP_TEST_TIMEOUT 1
macro_line|#ifdef SLEEP_TEST_TIMEOUT
DECL|variable|sleep_ticks
r_static
r_int
id|sleep_ticks
suffix:semicolon
r_void
id|wakeup_counter0_set
c_func
(paren
r_int
id|ticks
)paren
suffix:semicolon
macro_line|#endif
r_static
r_void
DECL|function|save_core_regs
id|save_core_regs
c_func
(paren
r_void
)paren
(brace
r_extern
r_void
id|save_au1xxx_intctl
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|pm_eth0_shutdown
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* Do the serial ports.....these really should be a pm_*&n;&t; * registered function by the driver......but of course the&n;&t; * standard serial driver doesn&squot;t understand our Au1xxx&n;&t; * unique registers.&n;&t; */
id|sleep_uart0_inten
op_assign
id|au_readl
c_func
(paren
id|UART0_ADDR
op_plus
id|UART_IER
)paren
suffix:semicolon
id|sleep_uart0_fifoctl
op_assign
id|au_readl
c_func
(paren
id|UART0_ADDR
op_plus
id|UART_FCR
)paren
suffix:semicolon
id|sleep_uart0_linectl
op_assign
id|au_readl
c_func
(paren
id|UART0_ADDR
op_plus
id|UART_LCR
)paren
suffix:semicolon
id|sleep_uart0_clkdiv
op_assign
id|au_readl
c_func
(paren
id|UART0_ADDR
op_plus
id|UART_CLK
)paren
suffix:semicolon
id|sleep_uart0_enable
op_assign
id|au_readl
c_func
(paren
id|UART0_ADDR
op_plus
id|UART_MOD_CNTRL
)paren
suffix:semicolon
multiline_comment|/* Shutdown USB host/device.&n;&t;*/
id|sleep_usbhost_enable
op_assign
id|au_readl
c_func
(paren
id|USB_HOST_CONFIG
)paren
suffix:semicolon
multiline_comment|/* There appears to be some undocumented reset register....&n;&t;*/
id|au_writel
c_func
(paren
l_int|0
comma
l_int|0xb0100004
)paren
suffix:semicolon
id|au_sync
c_func
(paren
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|0
comma
id|USB_HOST_CONFIG
)paren
suffix:semicolon
id|au_sync
c_func
(paren
)paren
suffix:semicolon
id|sleep_usbdev_enable
op_assign
id|au_readl
c_func
(paren
id|USBD_ENABLE
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|0
comma
id|USBD_ENABLE
)paren
suffix:semicolon
id|au_sync
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Save interrupt controller state.&n;&t;*/
id|save_au1xxx_intctl
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Clocks and PLLs.&n;&t;*/
id|sleep_aux_pll_cntrl
op_assign
id|au_readl
c_func
(paren
id|SYS_AUXPLL
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t really need to do this one, but unless we&n;&t; * write it again it won&squot;t have a valid value if we&n;&t; * happen to read it.&n;&t; */
id|sleep_cpu_pll_cntrl
op_assign
id|au_readl
c_func
(paren
id|SYS_CPUPLL
)paren
suffix:semicolon
id|sleep_pin_function
op_assign
id|au_readl
c_func
(paren
id|SYS_PINFUNC
)paren
suffix:semicolon
multiline_comment|/* Save the static memory controller configuration.&n;&t;*/
id|sleep_static_memctlr
(braket
l_int|0
)braket
(braket
l_int|0
)braket
op_assign
id|au_readl
c_func
(paren
id|MEM_STCFG0
)paren
suffix:semicolon
id|sleep_static_memctlr
(braket
l_int|0
)braket
(braket
l_int|1
)braket
op_assign
id|au_readl
c_func
(paren
id|MEM_STTIME0
)paren
suffix:semicolon
id|sleep_static_memctlr
(braket
l_int|0
)braket
(braket
l_int|2
)braket
op_assign
id|au_readl
c_func
(paren
id|MEM_STADDR0
)paren
suffix:semicolon
id|sleep_static_memctlr
(braket
l_int|1
)braket
(braket
l_int|0
)braket
op_assign
id|au_readl
c_func
(paren
id|MEM_STCFG1
)paren
suffix:semicolon
id|sleep_static_memctlr
(braket
l_int|1
)braket
(braket
l_int|1
)braket
op_assign
id|au_readl
c_func
(paren
id|MEM_STTIME1
)paren
suffix:semicolon
id|sleep_static_memctlr
(braket
l_int|1
)braket
(braket
l_int|2
)braket
op_assign
id|au_readl
c_func
(paren
id|MEM_STADDR1
)paren
suffix:semicolon
id|sleep_static_memctlr
(braket
l_int|2
)braket
(braket
l_int|0
)braket
op_assign
id|au_readl
c_func
(paren
id|MEM_STCFG2
)paren
suffix:semicolon
id|sleep_static_memctlr
(braket
l_int|2
)braket
(braket
l_int|1
)braket
op_assign
id|au_readl
c_func
(paren
id|MEM_STTIME2
)paren
suffix:semicolon
id|sleep_static_memctlr
(braket
l_int|2
)braket
(braket
l_int|2
)braket
op_assign
id|au_readl
c_func
(paren
id|MEM_STADDR2
)paren
suffix:semicolon
id|sleep_static_memctlr
(braket
l_int|3
)braket
(braket
l_int|0
)braket
op_assign
id|au_readl
c_func
(paren
id|MEM_STCFG3
)paren
suffix:semicolon
id|sleep_static_memctlr
(braket
l_int|3
)braket
(braket
l_int|1
)braket
op_assign
id|au_readl
c_func
(paren
id|MEM_STTIME3
)paren
suffix:semicolon
id|sleep_static_memctlr
(braket
l_int|3
)braket
(braket
l_int|2
)braket
op_assign
id|au_readl
c_func
(paren
id|MEM_STADDR3
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|restore_core_regs
id|restore_core_regs
c_func
(paren
r_void
)paren
(brace
r_extern
r_void
id|restore_au1xxx_intctl
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|wakeup_counter0_adjust
c_func
(paren
r_void
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|sleep_aux_pll_cntrl
comma
id|SYS_AUXPLL
)paren
suffix:semicolon
id|au_sync
c_func
(paren
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|sleep_cpu_pll_cntrl
comma
id|SYS_CPUPLL
)paren
suffix:semicolon
id|au_sync
c_func
(paren
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|sleep_pin_function
comma
id|SYS_PINFUNC
)paren
suffix:semicolon
id|au_sync
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Restore the static memory controller configuration.&n;&t;*/
id|au_writel
c_func
(paren
id|sleep_static_memctlr
(braket
l_int|0
)braket
(braket
l_int|0
)braket
comma
id|MEM_STCFG0
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|sleep_static_memctlr
(braket
l_int|0
)braket
(braket
l_int|1
)braket
comma
id|MEM_STTIME0
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|sleep_static_memctlr
(braket
l_int|0
)braket
(braket
l_int|2
)braket
comma
id|MEM_STADDR0
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|sleep_static_memctlr
(braket
l_int|1
)braket
(braket
l_int|0
)braket
comma
id|MEM_STCFG1
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|sleep_static_memctlr
(braket
l_int|1
)braket
(braket
l_int|1
)braket
comma
id|MEM_STTIME1
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|sleep_static_memctlr
(braket
l_int|1
)braket
(braket
l_int|2
)braket
comma
id|MEM_STADDR1
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|sleep_static_memctlr
(braket
l_int|2
)braket
(braket
l_int|0
)braket
comma
id|MEM_STCFG2
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|sleep_static_memctlr
(braket
l_int|2
)braket
(braket
l_int|1
)braket
comma
id|MEM_STTIME2
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|sleep_static_memctlr
(braket
l_int|2
)braket
(braket
l_int|2
)braket
comma
id|MEM_STADDR2
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|sleep_static_memctlr
(braket
l_int|3
)braket
(braket
l_int|0
)braket
comma
id|MEM_STCFG3
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|sleep_static_memctlr
(braket
l_int|3
)braket
(braket
l_int|1
)braket
comma
id|MEM_STTIME3
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|sleep_static_memctlr
(braket
l_int|3
)braket
(braket
l_int|2
)braket
comma
id|MEM_STADDR3
)paren
suffix:semicolon
multiline_comment|/* Enable the UART if it was enabled before sleep.&n;&t; * I guess I should define module control bits........&n;&t; */
r_if
c_cond
(paren
id|sleep_uart0_enable
op_amp
l_int|0x02
)paren
(brace
id|au_writel
c_func
(paren
l_int|0
comma
id|UART0_ADDR
op_plus
id|UART_MOD_CNTRL
)paren
suffix:semicolon
id|au_sync
c_func
(paren
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
comma
id|UART0_ADDR
op_plus
id|UART_MOD_CNTRL
)paren
suffix:semicolon
id|au_sync
c_func
(paren
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|3
comma
id|UART0_ADDR
op_plus
id|UART_MOD_CNTRL
)paren
suffix:semicolon
id|au_sync
c_func
(paren
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|sleep_uart0_inten
comma
id|UART0_ADDR
op_plus
id|UART_IER
)paren
suffix:semicolon
id|au_sync
c_func
(paren
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|sleep_uart0_fifoctl
comma
id|UART0_ADDR
op_plus
id|UART_FCR
)paren
suffix:semicolon
id|au_sync
c_func
(paren
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|sleep_uart0_linectl
comma
id|UART0_ADDR
op_plus
id|UART_LCR
)paren
suffix:semicolon
id|au_sync
c_func
(paren
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|sleep_uart0_clkdiv
comma
id|UART0_ADDR
op_plus
id|UART_CLK
)paren
suffix:semicolon
id|au_sync
c_func
(paren
)paren
suffix:semicolon
)brace
id|restore_au1xxx_intctl
c_func
(paren
)paren
suffix:semicolon
id|wakeup_counter0_adjust
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|suspend_mode
r_int
r_int
id|suspend_mode
suffix:semicolon
DECL|function|wakeup_from_suspend
r_void
id|wakeup_from_suspend
c_func
(paren
r_void
)paren
(brace
id|suspend_mode
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|au_sleep
r_int
id|au_sleep
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|wakeup
comma
id|flags
suffix:semicolon
r_extern
r_void
id|save_and_sleep
c_func
(paren
r_void
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pm_lock
comma
id|flags
)paren
suffix:semicolon
id|save_core_regs
c_func
(paren
)paren
suffix:semicolon
id|flush_cache_all
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/** The code below is all system dependent and we should probably&n;&t; ** have a function call out of here to set this up.  You need&n;&t; ** to configure the GPIO or timer interrupts that will bring&n;&t; ** you out of sleep.&n;&t; ** For testing, the TOY counter wakeup is useful.&n;&t; **/
macro_line|#if 0
id|au_writel
c_func
(paren
id|au_readl
c_func
(paren
id|SYS_PINSTATERD
)paren
op_amp
op_complement
(paren
l_int|1
op_lshift
l_int|11
)paren
comma
id|SYS_PINSTATERD
)paren
suffix:semicolon
multiline_comment|/* gpio 6 can cause a wake up event */
id|wakeup
op_assign
id|au_readl
c_func
(paren
id|SYS_WAKEMSK
)paren
suffix:semicolon
id|wakeup
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* turn off match20 wakeup */
id|wakeup
op_or_assign
l_int|1
op_lshift
l_int|6
suffix:semicolon
multiline_comment|/* turn on gpio 6 wakeup   */
macro_line|#else
multiline_comment|/* For testing, allow match20 to wake us up.&n;&t;*/
macro_line|#ifdef SLEEP_TEST_TIMEOUT
id|wakeup_counter0_set
c_func
(paren
id|sleep_ticks
)paren
suffix:semicolon
macro_line|#endif
id|wakeup
op_assign
l_int|1
op_lshift
l_int|8
suffix:semicolon
multiline_comment|/* turn on match20 wakeup   */
id|wakeup
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|au_writel
c_func
(paren
l_int|1
comma
id|SYS_WAKESRC
)paren
suffix:semicolon
multiline_comment|/* clear cause */
id|au_sync
c_func
(paren
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|wakeup
comma
id|SYS_WAKEMSK
)paren
suffix:semicolon
id|au_sync
c_func
(paren
)paren
suffix:semicolon
id|save_and_sleep
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* after a wakeup, the cpu vectors back to 0x1fc00000 so&n;&t; * it&squot;s up to the boot code to get us back here.&n;&t; */
id|restore_core_regs
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pm_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pm_do_sleep
r_static
r_int
id|pm_do_sleep
c_func
(paren
id|ctl_table
op_star
id|ctl
comma
r_int
id|write
comma
r_struct
id|file
op_star
id|file
comma
r_void
op_star
id|buffer
comma
r_int
op_star
id|len
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SLEEP_TEST_TIMEOUT
DECL|macro|TMPBUFLEN2
mdefine_line|#define TMPBUFLEN2 16
r_char
id|buf
(braket
id|TMPBUFLEN2
)braket
comma
op_star
id|p
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|write
)paren
(brace
op_star
id|len
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef SLEEP_TEST_TIMEOUT
r_if
c_cond
(paren
op_star
id|len
OG
id|TMPBUFLEN2
op_minus
l_int|1
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|buf
comma
id|buffer
comma
op_star
id|len
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|buf
(braket
op_star
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|p
op_assign
id|buf
suffix:semicolon
id|sleep_ticks
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|retval
op_assign
id|pm_send_all
c_func
(paren
id|PM_SUSPEND
comma
(paren
r_void
op_star
)paren
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|au_sleep
c_func
(paren
)paren
suffix:semicolon
id|retval
op_assign
id|pm_send_all
c_func
(paren
id|PM_RESUME
comma
(paren
r_void
op_star
)paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|pm_do_suspend
r_static
r_int
id|pm_do_suspend
c_func
(paren
id|ctl_table
op_star
id|ctl
comma
r_int
id|write
comma
r_struct
id|file
op_star
id|file
comma
r_void
op_star
id|buffer
comma
r_int
op_star
id|len
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_void
id|au1k_wait
c_func
(paren
r_void
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|write
)paren
(brace
op_star
id|len
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
id|pm_send_all
c_func
(paren
id|PM_SUSPEND
comma
(paren
r_void
op_star
)paren
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|suspend_mode
op_assign
l_int|1
suffix:semicolon
id|au1k_wait
c_func
(paren
)paren
suffix:semicolon
id|retval
op_assign
id|pm_send_all
c_func
(paren
id|PM_RESUME
comma
(paren
r_void
op_star
)paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|pm_do_freq
r_static
r_int
id|pm_do_freq
c_func
(paren
id|ctl_table
op_star
id|ctl
comma
r_int
id|write
comma
r_struct
id|file
op_star
id|file
comma
r_void
op_star
id|buffer
comma
r_int
op_star
id|len
)paren
(brace
r_int
id|retval
op_assign
l_int|0
comma
id|i
suffix:semicolon
r_int
r_int
id|val
comma
id|pll
suffix:semicolon
DECL|macro|TMPBUFLEN
mdefine_line|#define TMPBUFLEN 64
DECL|macro|MAX_CPU_FREQ
mdefine_line|#define MAX_CPU_FREQ 396
r_char
id|buf
(braket
l_int|8
)braket
comma
op_star
id|p
suffix:semicolon
r_int
r_int
id|flags
comma
id|intc0_mask
comma
id|intc1_mask
suffix:semicolon
r_int
r_int
id|old_baud_base
comma
id|old_cpu_freq
comma
id|baud_rate
comma
id|old_clk
comma
id|old_refresh
suffix:semicolon
r_int
r_int
id|new_baud_base
comma
id|new_cpu_freq
comma
id|new_clk
comma
id|new_refresh
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pm_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|write
)paren
(brace
op_star
id|len
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Parse the new frequency */
r_if
c_cond
(paren
op_star
id|len
OG
id|TMPBUFLEN
op_minus
l_int|1
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pm_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|buf
comma
id|buffer
comma
op_star
id|len
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pm_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|buf
(braket
op_star
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|p
op_assign
id|buf
suffix:semicolon
id|val
op_assign
id|simple_strtoul
c_func
(paren
id|p
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
OG
id|MAX_CPU_FREQ
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pm_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|pll
op_assign
id|val
op_div
l_int|12
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pll
OG
l_int|33
)paren
op_logical_or
(paren
id|pll
OL
l_int|7
)paren
)paren
(brace
multiline_comment|/* 396 MHz max, 84 MHz min */
multiline_comment|/* revisit this for higher speed cpus */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pm_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|old_baud_base
op_assign
id|get_au1x00_uart_baud_base
c_func
(paren
)paren
suffix:semicolon
id|old_cpu_freq
op_assign
id|get_au1x00_speed
c_func
(paren
)paren
suffix:semicolon
id|new_cpu_freq
op_assign
id|pll
op_star
l_int|12
op_star
l_int|1000000
suffix:semicolon
id|new_baud_base
op_assign
(paren
id|new_cpu_freq
op_div
l_int|4
)paren
op_div
l_int|16
suffix:semicolon
id|set_au1x00_speed
c_func
(paren
id|new_cpu_freq
)paren
suffix:semicolon
id|set_au1x00_uart_baud_base
c_func
(paren
id|new_baud_base
)paren
suffix:semicolon
id|old_refresh
op_assign
id|au_readl
c_func
(paren
id|MEM_SDREFCFG
)paren
op_amp
l_int|0x1ffffff
suffix:semicolon
id|new_refresh
op_assign
(paren
(paren
id|old_refresh
op_star
id|new_cpu_freq
)paren
op_div
id|old_cpu_freq
)paren
op_or
(paren
id|au_readl
c_func
(paren
id|MEM_SDREFCFG
)paren
op_amp
op_complement
l_int|0x1ffffff
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|pll
comma
id|SYS_CPUPLL
)paren
suffix:semicolon
id|au_sync_delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|new_refresh
comma
id|MEM_SDREFCFG
)paren
suffix:semicolon
id|au_sync_delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|au_readl
(paren
id|UART_BASE
op_plus
id|UART_MOD_CNTRL
op_plus
id|i
op_star
l_int|0x00100000
)paren
op_eq
l_int|3
)paren
(brace
id|old_clk
op_assign
id|au_readl
c_func
(paren
id|UART_BASE
op_plus
id|UART_CLK
op_plus
id|i
op_star
l_int|0x00100000
)paren
suffix:semicolon
singleline_comment|// baud_rate = baud_base/clk
id|baud_rate
op_assign
id|old_baud_base
op_div
id|old_clk
suffix:semicolon
multiline_comment|/* we won&squot;t get an exact baud rate and the error&n;&t;&t;&t;&t; * could be significant enough that our new&n;&t;&t;&t;&t; * calculation will result in a clock that will&n;&t;&t;&t;&t; * give us a baud rate that&squot;s too far off from&n;&t;&t;&t;&t; * what we really want.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|baud_rate
OG
l_int|100000
)paren
id|baud_rate
op_assign
l_int|115200
suffix:semicolon
r_else
r_if
c_cond
(paren
id|baud_rate
OG
l_int|50000
)paren
id|baud_rate
op_assign
l_int|57600
suffix:semicolon
r_else
r_if
c_cond
(paren
id|baud_rate
OG
l_int|30000
)paren
id|baud_rate
op_assign
l_int|38400
suffix:semicolon
r_else
r_if
c_cond
(paren
id|baud_rate
OG
l_int|17000
)paren
id|baud_rate
op_assign
l_int|19200
suffix:semicolon
r_else
(paren
id|baud_rate
op_assign
l_int|9600
)paren
suffix:semicolon
singleline_comment|// new_clk = new_baud_base/baud_rate
id|new_clk
op_assign
id|new_baud_base
op_div
id|baud_rate
suffix:semicolon
id|au_writel
c_func
(paren
id|new_clk
comma
id|UART_BASE
op_plus
id|UART_CLK
op_plus
id|i
op_star
l_int|0x00100000
)paren
suffix:semicolon
id|au_sync_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* We don&squot;t want _any_ interrupts other than&n;&t; * match20. Otherwise our calibrate_delay()&n;&t; * calculation will be off, potentially a lot.&n;&t; */
id|intc0_mask
op_assign
id|save_local_and_disable
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|intc1_mask
op_assign
id|save_local_and_disable
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|local_enable_irq
c_func
(paren
id|AU1000_TOY_MATCH2_INT
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pm_lock
comma
id|flags
)paren
suffix:semicolon
id|calibrate_delay
c_func
(paren
)paren
suffix:semicolon
id|restore_local_and_enable
c_func
(paren
l_int|0
comma
id|intc0_mask
)paren
suffix:semicolon
id|restore_local_and_enable
c_func
(paren
l_int|1
comma
id|intc1_mask
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|pm_table
r_static
r_struct
id|ctl_table
id|pm_table
(braket
)braket
op_assign
(brace
(brace
id|ACPI_S1_SLP_TYP
comma
l_string|&quot;suspend&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0600
comma
l_int|NULL
comma
op_amp
id|pm_do_suspend
)brace
comma
(brace
id|ACPI_SLEEP
comma
l_string|&quot;sleep&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0600
comma
l_int|NULL
comma
op_amp
id|pm_do_sleep
)brace
comma
(brace
id|CTL_ACPI
comma
l_string|&quot;freq&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0600
comma
l_int|NULL
comma
op_amp
id|pm_do_freq
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|pm_dir_table
r_static
r_struct
id|ctl_table
id|pm_dir_table
(braket
)braket
op_assign
(brace
(brace
id|CTL_ACPI
comma
l_string|&quot;pm&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0555
comma
id|pm_table
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * Initialize power interface&n; */
DECL|function|pm_init
r_static
r_int
id|__init
id|pm_init
c_func
(paren
r_void
)paren
(brace
id|register_sysctl_table
c_func
(paren
id|pm_dir_table
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|pm_init
id|__initcall
c_func
(paren
id|pm_init
)paren
suffix:semicolon
multiline_comment|/*&n; * This is right out of init/main.c&n; */
multiline_comment|/* This is the number of bits of precision for the loops_per_jiffy.  Each&n;   bit takes on average 1.5/HZ seconds.  This (like the original) is a little&n;   better than 1% */
DECL|macro|LPS_PREC
mdefine_line|#define LPS_PREC 8
DECL|function|calibrate_delay
r_static
r_void
id|calibrate_delay
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|ticks
comma
id|loopbit
suffix:semicolon
r_int
id|lps_precision
op_assign
id|LPS_PREC
suffix:semicolon
id|loops_per_jiffy
op_assign
(paren
l_int|1
op_lshift
l_int|12
)paren
suffix:semicolon
r_while
c_loop
(paren
id|loops_per_jiffy
op_lshift_assign
l_int|1
)paren
(brace
multiline_comment|/* wait for &quot;start of&quot; clock tick */
id|ticks
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
id|ticks
op_eq
id|jiffies
)paren
multiline_comment|/* nothing */
suffix:semicolon
multiline_comment|/* Go .. */
id|ticks
op_assign
id|jiffies
suffix:semicolon
id|__delay
c_func
(paren
id|loops_per_jiffy
)paren
suffix:semicolon
id|ticks
op_assign
id|jiffies
op_minus
id|ticks
suffix:semicolon
r_if
c_cond
(paren
id|ticks
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Do a binary approximation to get loops_per_jiffy set to equal one clock&n;   (up to lps_precision bits) */
id|loops_per_jiffy
op_rshift_assign
l_int|1
suffix:semicolon
id|loopbit
op_assign
id|loops_per_jiffy
suffix:semicolon
r_while
c_loop
(paren
id|lps_precision
op_decrement
op_logical_and
(paren
id|loopbit
op_rshift_assign
l_int|1
)paren
)paren
(brace
id|loops_per_jiffy
op_or_assign
id|loopbit
suffix:semicolon
id|ticks
op_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
id|ticks
op_eq
id|jiffies
)paren
suffix:semicolon
id|ticks
op_assign
id|jiffies
suffix:semicolon
id|__delay
c_func
(paren
id|loops_per_jiffy
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jiffies
op_ne
id|ticks
)paren
multiline_comment|/* longer than 1 tick */
id|loops_per_jiffy
op_and_assign
op_complement
id|loopbit
suffix:semicolon
)brace
)brace
macro_line|#endif&t;&t;&t;&t;/* CONFIG_PM */
eof
