multiline_comment|/*&n; *&n; * BRIEF MODULE DESCRIPTION&n; *      The Descriptor Based DMA channel manager that first appeared&n; *&t;on the Au1550.  I started with dma.c, but I think all that is&n; *&t;left is this initial comment :-)&n; *&n; * Copyright 2004 Embedded Edge, LLC&n; *&t;dan@embeddededge.com&n; *&n; *  This program is free software; you can redistribute  it and/or modify it&n; *  under  the terms of  the GNU General  Public License as published by the&n; *  Free Software Foundation;  either version 2 of the  License, or (at your&n; *  option) any later version.&n; *&n; *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS&squot;&squot; AND   ANY  EXPRESS OR IMPLIED&n; *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF&n; *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN&n; *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,&n; *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT&n; *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF&n; *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON&n; *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT&n; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF&n; *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; *&n; *  You should have received a copy of the  GNU General Public License along&n; *  with this program; if not, write  to the Free Software Foundation, Inc.,&n; *  675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/mach-au1x00/au1000.h&gt;
macro_line|#include &lt;asm/mach-au1x00/au1xxx_dbdma.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#if defined(CONFIG_SOC_AU1550) || defined(CONFIG_SOC_AU1200)
multiline_comment|/*&n; * The Descriptor Based DMA supports up to 16 channels.&n; *&n; * There are 32 devices defined. We keep an internal structure&n; * of devices using these channels, along with additional&n; * information.&n; *&n; * We allocate the descriptors and allow access to them through various&n; * functions.  The drivers allocate the data buffers and assign them&n; * to the descriptors.&n; */
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|au1xxx_dbdma_spin_lock
)paren
suffix:semicolon
multiline_comment|/* I couldn&squot;t find a macro that did this......&n;*/
DECL|macro|ALIGN_ADDR
mdefine_line|#define ALIGN_ADDR(x, a)&t;((((u32)(x)) + (a-1)) &amp; ~(a-1))
DECL|variable|dbdma_gptr
r_static
r_volatile
id|dbdma_global_t
op_star
id|dbdma_gptr
op_assign
(paren
id|dbdma_global_t
op_star
)paren
id|DDMA_GLOBAL_BASE
suffix:semicolon
DECL|variable|dbdma_initialized
r_static
r_int
id|dbdma_initialized
suffix:semicolon
r_static
r_void
id|au1xxx_dbdma_init
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|struct|dbdma_device_table
r_typedef
r_struct
id|dbdma_device_table
(brace
DECL|member|dev_id
id|u32
id|dev_id
suffix:semicolon
DECL|member|dev_flags
id|u32
id|dev_flags
suffix:semicolon
DECL|member|dev_tsize
id|u32
id|dev_tsize
suffix:semicolon
DECL|member|dev_devwidth
id|u32
id|dev_devwidth
suffix:semicolon
DECL|member|dev_physaddr
id|u32
id|dev_physaddr
suffix:semicolon
multiline_comment|/* If FIFO */
DECL|member|dev_intlevel
id|u32
id|dev_intlevel
suffix:semicolon
DECL|member|dev_intpolarity
id|u32
id|dev_intpolarity
suffix:semicolon
DECL|typedef|dbdev_tab_t
)brace
id|dbdev_tab_t
suffix:semicolon
DECL|struct|dbdma_chan_config
r_typedef
r_struct
id|dbdma_chan_config
(brace
DECL|member|chan_flags
id|u32
id|chan_flags
suffix:semicolon
DECL|member|chan_index
id|u32
id|chan_index
suffix:semicolon
DECL|member|chan_src
id|dbdev_tab_t
op_star
id|chan_src
suffix:semicolon
DECL|member|chan_dest
id|dbdev_tab_t
op_star
id|chan_dest
suffix:semicolon
DECL|member|chan_ptr
id|au1x_dma_chan_t
op_star
id|chan_ptr
suffix:semicolon
DECL|member|chan_desc_base
id|au1x_ddma_desc_t
op_star
id|chan_desc_base
suffix:semicolon
DECL|member|get_ptr
DECL|member|put_ptr
DECL|member|cur_ptr
id|au1x_ddma_desc_t
op_star
id|get_ptr
comma
op_star
id|put_ptr
comma
op_star
id|cur_ptr
suffix:semicolon
DECL|member|chan_callparam
r_void
op_star
id|chan_callparam
suffix:semicolon
DECL|member|chan_callback
r_void
(paren
op_star
id|chan_callback
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
DECL|typedef|chan_tab_t
)brace
id|chan_tab_t
suffix:semicolon
DECL|macro|DEV_FLAGS_INUSE
mdefine_line|#define&t;DEV_FLAGS_INUSE&t;&t;(1 &lt;&lt; 0)
DECL|macro|DEV_FLAGS_ANYUSE
mdefine_line|#define&t;DEV_FLAGS_ANYUSE&t;(1 &lt;&lt; 1)
DECL|macro|DEV_FLAGS_OUT
mdefine_line|#define DEV_FLAGS_OUT&t;&t;(1 &lt;&lt; 2)
DECL|macro|DEV_FLAGS_IN
mdefine_line|#define DEV_FLAGS_IN&t;&t;(1 &lt;&lt; 3)
DECL|variable|dbdev_tab
r_static
id|dbdev_tab_t
id|dbdev_tab
(braket
)braket
op_assign
(brace
macro_line|#ifdef CONFIG_SOC_AU1550
multiline_comment|/* UARTS */
(brace
id|DSCR_CMD0_UART0_TX
comma
id|DEV_FLAGS_OUT
comma
l_int|0
comma
l_int|8
comma
l_int|0x11100004
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_UART0_RX
comma
id|DEV_FLAGS_IN
comma
l_int|0
comma
l_int|8
comma
l_int|0x11100000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_UART3_TX
comma
id|DEV_FLAGS_OUT
comma
l_int|0
comma
l_int|8
comma
l_int|0x11400004
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_UART3_RX
comma
id|DEV_FLAGS_IN
comma
l_int|0
comma
l_int|8
comma
l_int|0x11400000
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* EXT DMA */
(brace
id|DSCR_CMD0_DMA_REQ0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_DMA_REQ1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_DMA_REQ2
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_DMA_REQ3
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* USB DEV */
(brace
id|DSCR_CMD0_USBDEV_RX0
comma
id|DEV_FLAGS_IN
comma
l_int|4
comma
l_int|8
comma
l_int|0x10200000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_USBDEV_TX0
comma
id|DEV_FLAGS_OUT
comma
l_int|4
comma
l_int|8
comma
l_int|0x10200004
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_USBDEV_TX1
comma
id|DEV_FLAGS_OUT
comma
l_int|4
comma
l_int|8
comma
l_int|0x10200008
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_USBDEV_TX2
comma
id|DEV_FLAGS_OUT
comma
l_int|4
comma
l_int|8
comma
l_int|0x1020000c
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_USBDEV_RX3
comma
id|DEV_FLAGS_IN
comma
l_int|4
comma
l_int|8
comma
l_int|0x10200010
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_USBDEV_RX4
comma
id|DEV_FLAGS_IN
comma
l_int|4
comma
l_int|8
comma
l_int|0x10200014
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* PSC 0 */
(brace
id|DSCR_CMD0_PSC0_TX
comma
id|DEV_FLAGS_OUT
comma
l_int|0
comma
l_int|0
comma
l_int|0x11a0001c
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_PSC0_RX
comma
id|DEV_FLAGS_IN
comma
l_int|0
comma
l_int|0
comma
l_int|0x11a0001c
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* PSC 1 */
(brace
id|DSCR_CMD0_PSC1_TX
comma
id|DEV_FLAGS_OUT
comma
l_int|0
comma
l_int|0
comma
l_int|0x11b0001c
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_PSC1_RX
comma
id|DEV_FLAGS_IN
comma
l_int|0
comma
l_int|0
comma
l_int|0x11b0001c
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* PSC 2 */
(brace
id|DSCR_CMD0_PSC2_TX
comma
id|DEV_FLAGS_OUT
comma
l_int|0
comma
l_int|0
comma
l_int|0x10a0001c
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_PSC2_RX
comma
id|DEV_FLAGS_IN
comma
l_int|0
comma
l_int|0
comma
l_int|0x10a0001c
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* PSC 3 */
(brace
id|DSCR_CMD0_PSC3_TX
comma
id|DEV_FLAGS_OUT
comma
l_int|0
comma
l_int|0
comma
l_int|0x10b0001c
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_PSC3_RX
comma
id|DEV_FLAGS_IN
comma
l_int|0
comma
l_int|0
comma
l_int|0x10b0001c
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_PCI_WRITE
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* PCI */
(brace
id|DSCR_CMD0_NAND_FLASH
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* NAND */
multiline_comment|/* MAC 0 */
(brace
id|DSCR_CMD0_MAC0_RX
comma
id|DEV_FLAGS_IN
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_MAC0_TX
comma
id|DEV_FLAGS_OUT
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* MAC 1 */
(brace
id|DSCR_CMD0_MAC1_RX
comma
id|DEV_FLAGS_IN
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_MAC1_TX
comma
id|DEV_FLAGS_OUT
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
macro_line|#endif /* CONFIG_SOC_AU1550 */
macro_line|#ifdef CONFIG_SOC_AU1200
(brace
id|DSCR_CMD0_UART0_TX
comma
id|DEV_FLAGS_OUT
comma
l_int|0
comma
l_int|8
comma
l_int|0x11100004
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_UART0_RX
comma
id|DEV_FLAGS_IN
comma
l_int|0
comma
l_int|8
comma
l_int|0x11100000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_UART1_TX
comma
id|DEV_FLAGS_OUT
comma
l_int|0
comma
l_int|8
comma
l_int|0x11200004
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_UART1_RX
comma
id|DEV_FLAGS_IN
comma
l_int|0
comma
l_int|8
comma
l_int|0x11200000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_DMA_REQ0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_DMA_REQ1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_MAE_BE
comma
id|DEV_FLAGS_ANYUSE
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_MAE_FE
comma
id|DEV_FLAGS_ANYUSE
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_MAE_BOTH
comma
id|DEV_FLAGS_ANYUSE
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_LCD
comma
id|DEV_FLAGS_ANYUSE
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_SDMS_TX0
comma
id|DEV_FLAGS_OUT
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_SDMS_RX0
comma
id|DEV_FLAGS_IN
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_SDMS_TX1
comma
id|DEV_FLAGS_OUT
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_SDMS_RX1
comma
id|DEV_FLAGS_IN
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_AES_TX
comma
id|DEV_FLAGS_OUT
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_AES_RX
comma
id|DEV_FLAGS_IN
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_PSC0_TX
comma
id|DEV_FLAGS_OUT
comma
l_int|0
comma
l_int|0
comma
l_int|0x11a0001c
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_PSC0_RX
comma
id|DEV_FLAGS_IN
comma
l_int|0
comma
l_int|0
comma
l_int|0x11a0001c
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_PSC0_SYNC
comma
id|DEV_FLAGS_ANYUSE
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_PSC1_TX
comma
id|DEV_FLAGS_OUT
comma
l_int|0
comma
l_int|0
comma
l_int|0x11b0001c
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_PSC1_RX
comma
id|DEV_FLAGS_IN
comma
l_int|0
comma
l_int|0
comma
l_int|0x11b0001c
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_PSC1_SYNC
comma
id|DEV_FLAGS_ANYUSE
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_CIM_RXA
comma
id|DEV_FLAGS_IN
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_CIM_RXB
comma
id|DEV_FLAGS_IN
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_CIM_RXC
comma
id|DEV_FLAGS_IN
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_CIM_SYNC
comma
id|DEV_FLAGS_ANYUSE
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_NAND_FLASH
comma
id|DEV_FLAGS_IN
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
macro_line|#endif 
singleline_comment|// CONFIG_SOC_AU1200
(brace
id|DSCR_CMD0_THROTTLE
comma
id|DEV_FLAGS_ANYUSE
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DSCR_CMD0_ALWAYS
comma
id|DEV_FLAGS_ANYUSE
comma
l_int|0
comma
l_int|0
comma
l_int|0x00000000
comma
l_int|0
comma
l_int|0
)brace
comma
)brace
suffix:semicolon
DECL|macro|DBDEV_TAB_SIZE
mdefine_line|#define DBDEV_TAB_SIZE (sizeof(dbdev_tab) / sizeof(dbdev_tab_t))
DECL|variable|chan_tab_ptr
r_static
id|chan_tab_t
op_star
id|chan_tab_ptr
(braket
id|NUM_DBDMA_CHANS
)braket
suffix:semicolon
r_static
id|dbdev_tab_t
op_star
DECL|function|find_dbdev_id
id|find_dbdev_id
(paren
id|u32
id|id
)paren
(brace
r_int
id|i
suffix:semicolon
id|dbdev_tab_t
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DBDEV_TAB_SIZE
suffix:semicolon
op_increment
id|i
)paren
(brace
id|p
op_assign
op_amp
id|dbdev_tab
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;dev_id
op_eq
id|id
)paren
r_return
id|p
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Allocate a channel and return a non-zero descriptor if successful.&n;*/
id|u32
DECL|function|au1xxx_dbdma_chan_alloc
id|au1xxx_dbdma_chan_alloc
c_func
(paren
id|u32
id|srcid
comma
id|u32
id|destid
comma
r_void
(paren
op_star
id|callback
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_void
op_star
id|callparam
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|u32
id|used
comma
id|chan
comma
id|rv
suffix:semicolon
id|u32
id|dcp
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dbdev_tab_t
op_star
id|stp
comma
op_star
id|dtp
suffix:semicolon
id|chan_tab_t
op_star
id|ctp
suffix:semicolon
r_volatile
id|au1x_dma_chan_t
op_star
id|cp
suffix:semicolon
multiline_comment|/* We do the intialization on the first channel allocation.&n;&t; * We have to wait because of the interrupt handler initialization&n;&t; * which can&squot;t be done successfully during board set up.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|dbdma_initialized
)paren
id|au1xxx_dbdma_init
c_func
(paren
)paren
suffix:semicolon
id|dbdma_initialized
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|srcid
OG
id|DSCR_NDEV_IDS
)paren
op_logical_or
(paren
id|destid
OG
id|DSCR_NDEV_IDS
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stp
op_assign
id|find_dbdev_id
c_func
(paren
id|srcid
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dtp
op_assign
id|find_dbdev_id
c_func
(paren
id|destid
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|used
op_assign
l_int|0
suffix:semicolon
id|rv
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Check to see if we can get both channels.&n;&t;*/
id|spin_lock_irqsave
c_func
(paren
op_amp
id|au1xxx_dbdma_spin_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|stp-&gt;dev_flags
op_amp
id|DEV_FLAGS_INUSE
)paren
op_logical_or
(paren
id|stp-&gt;dev_flags
op_amp
id|DEV_FLAGS_ANYUSE
)paren
)paren
(brace
multiline_comment|/* Got source */
id|stp-&gt;dev_flags
op_or_assign
id|DEV_FLAGS_INUSE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dtp-&gt;dev_flags
op_amp
id|DEV_FLAGS_INUSE
)paren
op_logical_or
(paren
id|dtp-&gt;dev_flags
op_amp
id|DEV_FLAGS_ANYUSE
)paren
)paren
(brace
multiline_comment|/* Got destination */
id|dtp-&gt;dev_flags
op_or_assign
id|DEV_FLAGS_INUSE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Can&squot;t get dest.  Release src.&n;&t;&t;&t;*/
id|stp-&gt;dev_flags
op_and_assign
op_complement
id|DEV_FLAGS_INUSE
suffix:semicolon
id|used
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
id|used
op_increment
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|au1xxx_dbdma_spin_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|used
)paren
(brace
multiline_comment|/* Let&squot;s see if we can allocate a channel for it.&n;&t;&t;*/
id|ctp
op_assign
l_int|NULL
suffix:semicolon
id|chan
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|au1xxx_dbdma_spin_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_DBDMA_CHANS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|chan_tab_ptr
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* If kmalloc fails, it is caught below same&n;&t;&t;&t;&t; * as a channel not available.&n;&t;&t;&t;&t; */
id|ctp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|chan_tab_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|chan_tab_ptr
(braket
id|i
)braket
op_assign
id|ctp
suffix:semicolon
id|ctp-&gt;chan_index
op_assign
id|chan
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|au1xxx_dbdma_spin_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctp
op_ne
l_int|NULL
)paren
(brace
id|memset
c_func
(paren
id|ctp
comma
l_int|0
comma
r_sizeof
(paren
id|chan_tab_t
)paren
)paren
suffix:semicolon
id|dcp
op_assign
id|DDMA_CHANNEL_BASE
suffix:semicolon
id|dcp
op_add_assign
(paren
l_int|0x0100
op_star
id|chan
)paren
suffix:semicolon
id|ctp-&gt;chan_ptr
op_assign
(paren
id|au1x_dma_chan_t
op_star
)paren
id|dcp
suffix:semicolon
id|cp
op_assign
(paren
r_volatile
id|au1x_dma_chan_t
op_star
)paren
id|dcp
suffix:semicolon
id|ctp-&gt;chan_src
op_assign
id|stp
suffix:semicolon
id|ctp-&gt;chan_dest
op_assign
id|dtp
suffix:semicolon
id|ctp-&gt;chan_callback
op_assign
id|callback
suffix:semicolon
id|ctp-&gt;chan_callparam
op_assign
id|callparam
suffix:semicolon
multiline_comment|/* Initialize channel configuration.&n;&t;&t;&t;*/
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|stp-&gt;dev_intlevel
)paren
id|i
op_or_assign
id|DDMA_CFG_SED
suffix:semicolon
r_if
c_cond
(paren
id|stp-&gt;dev_intpolarity
)paren
id|i
op_or_assign
id|DDMA_CFG_SP
suffix:semicolon
r_if
c_cond
(paren
id|dtp-&gt;dev_intlevel
)paren
id|i
op_or_assign
id|DDMA_CFG_DED
suffix:semicolon
r_if
c_cond
(paren
id|dtp-&gt;dev_intpolarity
)paren
id|i
op_or_assign
id|DDMA_CFG_DP
suffix:semicolon
id|cp-&gt;ddma_cfg
op_assign
id|i
suffix:semicolon
id|au_sync
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Return a non-zero value that can be used to&n;&t;&t;&t; * find the channel information in subsequent&n;&t;&t;&t; * operations.&n;&t;&t;&t; */
id|rv
op_assign
(paren
id|u32
)paren
(paren
op_amp
id|chan_tab_ptr
(braket
id|chan
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Release devices.&n;&t;&t;&t;*/
id|stp-&gt;dev_flags
op_and_assign
op_complement
id|DEV_FLAGS_INUSE
suffix:semicolon
id|dtp-&gt;dev_flags
op_and_assign
op_complement
id|DEV_FLAGS_INUSE
suffix:semicolon
)brace
)brace
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/* Set the device width if source or destination is a FIFO.&n; * Should be 8, 16, or 32 bits.&n; */
id|u32
DECL|function|au1xxx_dbdma_set_devwidth
id|au1xxx_dbdma_set_devwidth
c_func
(paren
id|u32
id|chanid
comma
r_int
id|bits
)paren
(brace
id|u32
id|rv
suffix:semicolon
id|chan_tab_t
op_star
id|ctp
suffix:semicolon
id|dbdev_tab_t
op_star
id|stp
comma
op_star
id|dtp
suffix:semicolon
id|ctp
op_assign
op_star
(paren
(paren
id|chan_tab_t
op_star
op_star
)paren
id|chanid
)paren
suffix:semicolon
id|stp
op_assign
id|ctp-&gt;chan_src
suffix:semicolon
id|dtp
op_assign
id|ctp-&gt;chan_dest
suffix:semicolon
id|rv
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|stp-&gt;dev_flags
op_amp
id|DEV_FLAGS_IN
)paren
(brace
multiline_comment|/* Source in fifo */
id|rv
op_assign
id|stp-&gt;dev_devwidth
suffix:semicolon
id|stp-&gt;dev_devwidth
op_assign
id|bits
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dtp-&gt;dev_flags
op_amp
id|DEV_FLAGS_OUT
)paren
(brace
multiline_comment|/* Destination out fifo */
id|rv
op_assign
id|dtp-&gt;dev_devwidth
suffix:semicolon
id|dtp-&gt;dev_devwidth
op_assign
id|bits
suffix:semicolon
)brace
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/* Allocate a descriptor ring, initializing as much as possible.&n;*/
id|u32
DECL|function|au1xxx_dbdma_ring_alloc
id|au1xxx_dbdma_ring_alloc
c_func
(paren
id|u32
id|chanid
comma
r_int
id|entries
)paren
(brace
r_int
id|i
suffix:semicolon
id|u32
id|desc_base
comma
id|srcid
comma
id|destid
suffix:semicolon
id|u32
id|cmd0
comma
id|cmd1
comma
id|src1
comma
id|dest1
suffix:semicolon
id|u32
id|src0
comma
id|dest0
suffix:semicolon
id|chan_tab_t
op_star
id|ctp
suffix:semicolon
id|dbdev_tab_t
op_star
id|stp
comma
op_star
id|dtp
suffix:semicolon
id|au1x_ddma_desc_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* I guess we could check this to be within the&n;&t; * range of the table......&n;&t; */
id|ctp
op_assign
op_star
(paren
(paren
id|chan_tab_t
op_star
op_star
)paren
id|chanid
)paren
suffix:semicolon
id|stp
op_assign
id|ctp-&gt;chan_src
suffix:semicolon
id|dtp
op_assign
id|ctp-&gt;chan_dest
suffix:semicolon
multiline_comment|/* The descriptors must be 32-byte aligned.  There is a&n;&t; * possibility the allocation will give us such an address,&n;&t; * and if we try that first we are likely to not waste larger&n;&t; * slabs of memory.&n;&t; */
id|desc_base
op_assign
(paren
id|u32
)paren
id|kmalloc
c_func
(paren
id|entries
op_star
r_sizeof
(paren
id|au1x_ddma_desc_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|desc_base
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|desc_base
op_amp
l_int|0x1f
)paren
(brace
multiline_comment|/* Lost....do it again, allocate extra, and round&n;&t;&t; * the address base.&n;&t;&t; */
id|kfree
c_func
(paren
(paren
r_const
r_void
op_star
)paren
id|desc_base
)paren
suffix:semicolon
id|i
op_assign
id|entries
op_star
r_sizeof
(paren
id|au1x_ddma_desc_t
)paren
suffix:semicolon
id|i
op_add_assign
(paren
r_sizeof
(paren
id|au1x_ddma_desc_t
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|desc_base
op_assign
(paren
id|u32
)paren
id|kmalloc
c_func
(paren
id|i
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|desc_base
op_assign
id|ALIGN_ADDR
c_func
(paren
id|desc_base
comma
r_sizeof
(paren
id|au1x_ddma_desc_t
)paren
)paren
suffix:semicolon
)brace
id|dp
op_assign
(paren
id|au1x_ddma_desc_t
op_star
)paren
id|desc_base
suffix:semicolon
multiline_comment|/* Keep track of the base descriptor.&n;&t;*/
id|ctp-&gt;chan_desc_base
op_assign
id|dp
suffix:semicolon
multiline_comment|/* Initialize the rings with as much information as we know.&n;&t; */
id|srcid
op_assign
id|stp-&gt;dev_id
suffix:semicolon
id|destid
op_assign
id|dtp-&gt;dev_id
suffix:semicolon
id|cmd0
op_assign
id|cmd1
op_assign
id|src1
op_assign
id|dest1
op_assign
l_int|0
suffix:semicolon
id|src0
op_assign
id|dest0
op_assign
l_int|0
suffix:semicolon
id|cmd0
op_or_assign
id|DSCR_CMD0_SID
c_func
(paren
id|srcid
)paren
suffix:semicolon
id|cmd0
op_or_assign
id|DSCR_CMD0_DID
c_func
(paren
id|destid
)paren
suffix:semicolon
id|cmd0
op_or_assign
id|DSCR_CMD0_IE
op_or
id|DSCR_CMD0_CV
suffix:semicolon
id|cmd0
op_or_assign
id|DSCR_CMD0_ST
c_func
(paren
id|DSCR_CMD0_ST_CURRENT
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|stp-&gt;dev_devwidth
)paren
(brace
r_case
l_int|8
suffix:colon
id|cmd0
op_or_assign
id|DSCR_CMD0_SW
c_func
(paren
id|DSCR_CMD0_BYTE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|16
suffix:colon
id|cmd0
op_or_assign
id|DSCR_CMD0_SW
c_func
(paren
id|DSCR_CMD0_HALFWORD
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|32
suffix:colon
r_default
suffix:colon
id|cmd0
op_or_assign
id|DSCR_CMD0_SW
c_func
(paren
id|DSCR_CMD0_WORD
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|dtp-&gt;dev_devwidth
)paren
(brace
r_case
l_int|8
suffix:colon
id|cmd0
op_or_assign
id|DSCR_CMD0_DW
c_func
(paren
id|DSCR_CMD0_BYTE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|16
suffix:colon
id|cmd0
op_or_assign
id|DSCR_CMD0_DW
c_func
(paren
id|DSCR_CMD0_HALFWORD
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|32
suffix:colon
r_default
suffix:colon
id|cmd0
op_or_assign
id|DSCR_CMD0_DW
c_func
(paren
id|DSCR_CMD0_WORD
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* If the device is marked as an in/out FIFO, ensure it is&n;&t; * set non-coherent.&n;&t; */
r_if
c_cond
(paren
id|stp-&gt;dev_flags
op_amp
id|DEV_FLAGS_IN
)paren
id|cmd0
op_or_assign
id|DSCR_CMD0_SN
suffix:semicolon
multiline_comment|/* Source in fifo */
r_if
c_cond
(paren
id|dtp-&gt;dev_flags
op_amp
id|DEV_FLAGS_OUT
)paren
id|cmd0
op_or_assign
id|DSCR_CMD0_DN
suffix:semicolon
multiline_comment|/* Destination out fifo */
multiline_comment|/* Set up source1.  For now, assume no stride and increment.&n;&t; * A channel attribute update can change this later.&n;&t; */
r_switch
c_cond
(paren
id|stp-&gt;dev_tsize
)paren
(brace
r_case
l_int|1
suffix:colon
id|src1
op_or_assign
id|DSCR_SRC1_STS
c_func
(paren
id|DSCR_xTS_SIZE1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|src1
op_or_assign
id|DSCR_SRC1_STS
c_func
(paren
id|DSCR_xTS_SIZE2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|src1
op_or_assign
id|DSCR_SRC1_STS
c_func
(paren
id|DSCR_xTS_SIZE4
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
r_default
suffix:colon
id|src1
op_or_assign
id|DSCR_SRC1_STS
c_func
(paren
id|DSCR_xTS_SIZE8
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* If source input is fifo, set static address.&n;&t;*/
r_if
c_cond
(paren
id|stp-&gt;dev_flags
op_amp
id|DEV_FLAGS_IN
)paren
(brace
id|src0
op_assign
id|stp-&gt;dev_physaddr
suffix:semicolon
id|src1
op_or_assign
id|DSCR_SRC1_SAM
c_func
(paren
id|DSCR_xAM_STATIC
)paren
suffix:semicolon
)brace
multiline_comment|/* Set up dest1.  For now, assume no stride and increment.&n;&t; * A channel attribute update can change this later.&n;&t; */
r_switch
c_cond
(paren
id|dtp-&gt;dev_tsize
)paren
(brace
r_case
l_int|1
suffix:colon
id|dest1
op_or_assign
id|DSCR_DEST1_DTS
c_func
(paren
id|DSCR_xTS_SIZE1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|dest1
op_or_assign
id|DSCR_DEST1_DTS
c_func
(paren
id|DSCR_xTS_SIZE2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|dest1
op_or_assign
id|DSCR_DEST1_DTS
c_func
(paren
id|DSCR_xTS_SIZE4
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
r_default
suffix:colon
id|dest1
op_or_assign
id|DSCR_DEST1_DTS
c_func
(paren
id|DSCR_xTS_SIZE8
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* If destination output is fifo, set static address.&n;&t;*/
r_if
c_cond
(paren
id|dtp-&gt;dev_flags
op_amp
id|DEV_FLAGS_OUT
)paren
(brace
id|dest0
op_assign
id|dtp-&gt;dev_physaddr
suffix:semicolon
id|dest1
op_or_assign
id|DSCR_DEST1_DAM
c_func
(paren
id|DSCR_xAM_STATIC
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|entries
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dp-&gt;dscr_cmd0
op_assign
id|cmd0
suffix:semicolon
id|dp-&gt;dscr_cmd1
op_assign
id|cmd1
suffix:semicolon
id|dp-&gt;dscr_source0
op_assign
id|src0
suffix:semicolon
id|dp-&gt;dscr_source1
op_assign
id|src1
suffix:semicolon
id|dp-&gt;dscr_dest0
op_assign
id|dest0
suffix:semicolon
id|dp-&gt;dscr_dest1
op_assign
id|dest1
suffix:semicolon
id|dp-&gt;dscr_stat
op_assign
l_int|0
suffix:semicolon
id|dp-&gt;dscr_nxtptr
op_assign
id|DSCR_NXTPTR
c_func
(paren
id|virt_to_phys
c_func
(paren
id|dp
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|dp
op_increment
suffix:semicolon
)brace
multiline_comment|/* Make last descrptor point to the first.&n;&t;*/
id|dp
op_decrement
suffix:semicolon
id|dp-&gt;dscr_nxtptr
op_assign
id|DSCR_NXTPTR
c_func
(paren
id|virt_to_phys
c_func
(paren
id|ctp-&gt;chan_desc_base
)paren
)paren
suffix:semicolon
id|ctp-&gt;get_ptr
op_assign
id|ctp-&gt;put_ptr
op_assign
id|ctp-&gt;cur_ptr
op_assign
id|ctp-&gt;chan_desc_base
suffix:semicolon
r_return
(paren
id|u32
)paren
(paren
id|ctp-&gt;chan_desc_base
)paren
suffix:semicolon
)brace
multiline_comment|/* Put a source buffer into the DMA ring.&n; * This updates the source pointer and byte count.  Normally used&n; * for memory to fifo transfers.&n; */
id|u32
DECL|function|au1xxx_dbdma_put_source
id|au1xxx_dbdma_put_source
c_func
(paren
id|u32
id|chanid
comma
r_void
op_star
id|buf
comma
r_int
id|nbytes
)paren
(brace
id|chan_tab_t
op_star
id|ctp
suffix:semicolon
id|au1x_ddma_desc_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* I guess we could check this to be within the&n;&t; * range of the table......&n;&t; */
id|ctp
op_assign
op_star
(paren
(paren
id|chan_tab_t
op_star
op_star
)paren
id|chanid
)paren
suffix:semicolon
multiline_comment|/* We should have multiple callers for a particular channel,&n;&t; * an interrupt doesn&squot;t affect this pointer nor the descriptor,&n;&t; * so no locking should be needed.&n;&t; */
id|dp
op_assign
id|ctp-&gt;put_ptr
suffix:semicolon
multiline_comment|/* If the descriptor is valid, we are way ahead of the DMA&n;&t; * engine, so just return an error condition.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;dscr_cmd0
op_amp
id|DSCR_CMD0_V
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Load up buffer address and byte count.&n;&t;*/
id|dp-&gt;dscr_source0
op_assign
id|virt_to_phys
c_func
(paren
id|buf
)paren
suffix:semicolon
id|dp-&gt;dscr_cmd1
op_assign
id|nbytes
suffix:semicolon
id|dp-&gt;dscr_cmd0
op_or_assign
id|DSCR_CMD0_V
suffix:semicolon
multiline_comment|/* Let it rip */
id|ctp-&gt;chan_ptr-&gt;ddma_dbell
op_assign
l_int|0xffffffff
suffix:semicolon
multiline_comment|/* Make it go */
multiline_comment|/* Get next descriptor pointer.&n;&t;*/
id|ctp-&gt;put_ptr
op_assign
id|phys_to_virt
c_func
(paren
id|DSCR_GET_NXTPTR
c_func
(paren
id|dp-&gt;dscr_nxtptr
)paren
)paren
suffix:semicolon
multiline_comment|/* return something not zero.&n;&t;*/
r_return
id|nbytes
suffix:semicolon
)brace
multiline_comment|/* Put a destination buffer into the DMA ring.&n; * This updates the destination pointer and byte count.  Normally used&n; * to place an empty buffer into the ring for fifo to memory transfers.&n; */
id|u32
DECL|function|au1xxx_dbdma_put_dest
id|au1xxx_dbdma_put_dest
c_func
(paren
id|u32
id|chanid
comma
r_void
op_star
id|buf
comma
r_int
id|nbytes
)paren
(brace
id|chan_tab_t
op_star
id|ctp
suffix:semicolon
id|au1x_ddma_desc_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* I guess we could check this to be within the&n;&t; * range of the table......&n;&t; */
id|ctp
op_assign
op_star
(paren
(paren
id|chan_tab_t
op_star
op_star
)paren
id|chanid
)paren
suffix:semicolon
multiline_comment|/* We should have multiple callers for a particular channel,&n;&t; * an interrupt doesn&squot;t affect this pointer nor the descriptor,&n;&t; * so no locking should be needed.&n;&t; */
id|dp
op_assign
id|ctp-&gt;put_ptr
suffix:semicolon
multiline_comment|/* If the descriptor is valid, we are way ahead of the DMA&n;&t; * engine, so just return an error condition.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;dscr_cmd0
op_amp
id|DSCR_CMD0_V
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Load up buffer address and byte count.&n;&t;*/
id|dp-&gt;dscr_dest0
op_assign
id|virt_to_phys
c_func
(paren
id|buf
)paren
suffix:semicolon
id|dp-&gt;dscr_cmd1
op_assign
id|nbytes
suffix:semicolon
id|dp-&gt;dscr_cmd0
op_or_assign
id|DSCR_CMD0_V
suffix:semicolon
multiline_comment|/* Let it rip */
multiline_comment|/* Get next descriptor pointer.&n;&t;*/
id|ctp-&gt;put_ptr
op_assign
id|phys_to_virt
c_func
(paren
id|DSCR_GET_NXTPTR
c_func
(paren
id|dp-&gt;dscr_nxtptr
)paren
)paren
suffix:semicolon
multiline_comment|/* return something not zero.&n;&t;*/
r_return
id|nbytes
suffix:semicolon
)brace
multiline_comment|/* Get a destination buffer into the DMA ring.&n; * Normally used to get a full buffer from the ring during fifo&n; * to memory transfers.  This does not set the valid bit, you will&n; * have to put another destination buffer to keep the DMA going.&n; */
id|u32
DECL|function|au1xxx_dbdma_get_dest
id|au1xxx_dbdma_get_dest
c_func
(paren
id|u32
id|chanid
comma
r_void
op_star
op_star
id|buf
comma
r_int
op_star
id|nbytes
)paren
(brace
id|chan_tab_t
op_star
id|ctp
suffix:semicolon
id|au1x_ddma_desc_t
op_star
id|dp
suffix:semicolon
id|u32
id|rv
suffix:semicolon
multiline_comment|/* I guess we could check this to be within the&n;&t; * range of the table......&n;&t; */
id|ctp
op_assign
op_star
(paren
(paren
id|chan_tab_t
op_star
op_star
)paren
id|chanid
)paren
suffix:semicolon
multiline_comment|/* We should have multiple callers for a particular channel,&n;&t; * an interrupt doesn&squot;t affect this pointer nor the descriptor,&n;&t; * so no locking should be needed.&n;&t; */
id|dp
op_assign
id|ctp-&gt;get_ptr
suffix:semicolon
multiline_comment|/* If the descriptor is valid, we are way ahead of the DMA&n;&t; * engine, so just return an error condition.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;dscr_cmd0
op_amp
id|DSCR_CMD0_V
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Return buffer address and byte count.&n;&t;*/
op_star
id|buf
op_assign
(paren
r_void
op_star
)paren
(paren
id|phys_to_virt
c_func
(paren
id|dp-&gt;dscr_dest0
)paren
)paren
suffix:semicolon
op_star
id|nbytes
op_assign
id|dp-&gt;dscr_cmd1
suffix:semicolon
id|rv
op_assign
id|dp-&gt;dscr_stat
suffix:semicolon
multiline_comment|/* Get next descriptor pointer.&n;&t;*/
id|ctp-&gt;get_ptr
op_assign
id|phys_to_virt
c_func
(paren
id|DSCR_GET_NXTPTR
c_func
(paren
id|dp-&gt;dscr_nxtptr
)paren
)paren
suffix:semicolon
multiline_comment|/* return something not zero.&n;&t;*/
r_return
id|rv
suffix:semicolon
)brace
r_void
DECL|function|au1xxx_dbdma_stop
id|au1xxx_dbdma_stop
c_func
(paren
id|u32
id|chanid
)paren
(brace
id|chan_tab_t
op_star
id|ctp
suffix:semicolon
r_volatile
id|au1x_dma_chan_t
op_star
id|cp
suffix:semicolon
r_int
id|halt_timeout
op_assign
l_int|0
suffix:semicolon
id|ctp
op_assign
op_star
(paren
(paren
id|chan_tab_t
op_star
op_star
)paren
id|chanid
)paren
suffix:semicolon
id|cp
op_assign
id|ctp-&gt;chan_ptr
suffix:semicolon
id|cp-&gt;ddma_cfg
op_and_assign
op_complement
id|DDMA_CFG_EN
suffix:semicolon
multiline_comment|/* Disable channel */
id|au_sync
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|cp-&gt;ddma_stat
op_amp
id|DDMA_STAT_H
)paren
)paren
(brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|halt_timeout
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|halt_timeout
OG
l_int|100
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;warning: DMA channel won&squot;t halt&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* clear current desc valid and doorbell */
id|cp-&gt;ddma_stat
op_or_assign
(paren
id|DDMA_STAT_DB
op_or
id|DDMA_STAT_V
)paren
suffix:semicolon
id|au_sync
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Start using the current descriptor pointer.  If the dbdma encounters&n; * a not valid descriptor, it will stop.  In this case, we can just&n; * continue by adding a buffer to the list and starting again.&n; */
r_void
DECL|function|au1xxx_dbdma_start
id|au1xxx_dbdma_start
c_func
(paren
id|u32
id|chanid
)paren
(brace
id|chan_tab_t
op_star
id|ctp
suffix:semicolon
r_volatile
id|au1x_dma_chan_t
op_star
id|cp
suffix:semicolon
id|ctp
op_assign
op_star
(paren
(paren
id|chan_tab_t
op_star
op_star
)paren
id|chanid
)paren
suffix:semicolon
id|cp
op_assign
id|ctp-&gt;chan_ptr
suffix:semicolon
id|cp-&gt;ddma_desptr
op_assign
id|virt_to_phys
c_func
(paren
id|ctp-&gt;cur_ptr
)paren
suffix:semicolon
id|cp-&gt;ddma_cfg
op_or_assign
id|DDMA_CFG_EN
suffix:semicolon
multiline_comment|/* Enable channel */
id|au_sync
c_func
(paren
)paren
suffix:semicolon
id|cp-&gt;ddma_dbell
op_assign
l_int|0xffffffff
suffix:semicolon
multiline_comment|/* Make it go */
id|au_sync
c_func
(paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|au1xxx_dbdma_reset
id|au1xxx_dbdma_reset
c_func
(paren
id|u32
id|chanid
)paren
(brace
id|chan_tab_t
op_star
id|ctp
suffix:semicolon
id|au1x_ddma_desc_t
op_star
id|dp
suffix:semicolon
id|au1xxx_dbdma_stop
c_func
(paren
id|chanid
)paren
suffix:semicolon
id|ctp
op_assign
op_star
(paren
(paren
id|chan_tab_t
op_star
op_star
)paren
id|chanid
)paren
suffix:semicolon
id|ctp-&gt;get_ptr
op_assign
id|ctp-&gt;put_ptr
op_assign
id|ctp-&gt;cur_ptr
op_assign
id|ctp-&gt;chan_desc_base
suffix:semicolon
multiline_comment|/* Run through the descriptors and reset the valid indicator.&n;&t;*/
id|dp
op_assign
id|ctp-&gt;chan_desc_base
suffix:semicolon
r_do
(brace
id|dp-&gt;dscr_cmd0
op_and_assign
op_complement
id|DSCR_CMD0_V
suffix:semicolon
id|dp
op_assign
id|phys_to_virt
c_func
(paren
id|DSCR_GET_NXTPTR
c_func
(paren
id|dp-&gt;dscr_nxtptr
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dp
op_ne
id|ctp-&gt;chan_desc_base
)paren
suffix:semicolon
)brace
id|u32
DECL|function|au1xxx_get_dma_residue
id|au1xxx_get_dma_residue
c_func
(paren
id|u32
id|chanid
)paren
(brace
id|chan_tab_t
op_star
id|ctp
suffix:semicolon
r_volatile
id|au1x_dma_chan_t
op_star
id|cp
suffix:semicolon
id|u32
id|rv
suffix:semicolon
id|ctp
op_assign
op_star
(paren
(paren
id|chan_tab_t
op_star
op_star
)paren
id|chanid
)paren
suffix:semicolon
id|cp
op_assign
id|ctp-&gt;chan_ptr
suffix:semicolon
multiline_comment|/* This is only valid if the channel is stopped.&n;&t;*/
id|rv
op_assign
id|cp-&gt;ddma_bytecnt
suffix:semicolon
id|au_sync
c_func
(paren
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
r_void
DECL|function|au1xxx_dbdma_chan_free
id|au1xxx_dbdma_chan_free
c_func
(paren
id|u32
id|chanid
)paren
(brace
id|chan_tab_t
op_star
id|ctp
suffix:semicolon
id|dbdev_tab_t
op_star
id|stp
comma
op_star
id|dtp
suffix:semicolon
id|ctp
op_assign
op_star
(paren
(paren
id|chan_tab_t
op_star
op_star
)paren
id|chanid
)paren
suffix:semicolon
id|stp
op_assign
id|ctp-&gt;chan_src
suffix:semicolon
id|dtp
op_assign
id|ctp-&gt;chan_dest
suffix:semicolon
id|au1xxx_dbdma_stop
c_func
(paren
id|chanid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctp-&gt;chan_desc_base
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|ctp-&gt;chan_desc_base
)paren
suffix:semicolon
id|stp-&gt;dev_flags
op_and_assign
op_complement
id|DEV_FLAGS_INUSE
suffix:semicolon
id|dtp-&gt;dev_flags
op_and_assign
op_complement
id|DEV_FLAGS_INUSE
suffix:semicolon
id|chan_tab_ptr
(braket
id|ctp-&gt;chan_index
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|ctp
)paren
suffix:semicolon
)brace
r_static
id|irqreturn_t
DECL|function|dbdma_interrupt
id|dbdma_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|u32
id|intstat
suffix:semicolon
id|u32
id|chan_index
suffix:semicolon
id|chan_tab_t
op_star
id|ctp
suffix:semicolon
id|au1x_ddma_desc_t
op_star
id|dp
suffix:semicolon
r_volatile
id|au1x_dma_chan_t
op_star
id|cp
suffix:semicolon
id|intstat
op_assign
id|dbdma_gptr-&gt;ddma_intstat
suffix:semicolon
id|au_sync
c_func
(paren
)paren
suffix:semicolon
id|chan_index
op_assign
id|au_ffs
c_func
(paren
id|intstat
)paren
op_minus
l_int|1
suffix:semicolon
id|ctp
op_assign
id|chan_tab_ptr
(braket
id|chan_index
)braket
suffix:semicolon
id|cp
op_assign
id|ctp-&gt;chan_ptr
suffix:semicolon
id|dp
op_assign
id|ctp-&gt;cur_ptr
suffix:semicolon
multiline_comment|/* Reset interrupt.&n;&t;*/
id|cp-&gt;ddma_irq
op_assign
l_int|0
suffix:semicolon
id|au_sync
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctp-&gt;chan_callback
)paren
(paren
id|ctp-&gt;chan_callback
)paren
(paren
id|irq
comma
id|ctp-&gt;chan_callparam
comma
id|regs
)paren
suffix:semicolon
id|ctp-&gt;cur_ptr
op_assign
id|phys_to_virt
c_func
(paren
id|DSCR_GET_NXTPTR
c_func
(paren
id|dp-&gt;dscr_nxtptr
)paren
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
r_static
r_void
DECL|function|au1xxx_dbdma_init
id|au1xxx_dbdma_init
c_func
(paren
r_void
)paren
(brace
id|dbdma_gptr-&gt;ddma_config
op_assign
l_int|0
suffix:semicolon
id|dbdma_gptr-&gt;ddma_throttle
op_assign
l_int|0
suffix:semicolon
id|dbdma_gptr-&gt;ddma_inten
op_assign
l_int|0xffff
suffix:semicolon
id|au_sync
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|AU1550_DDMA_INT
comma
id|dbdma_interrupt
comma
id|SA_INTERRUPT
comma
l_string|&quot;Au1xxx dbdma&quot;
comma
(paren
r_void
op_star
)paren
id|dbdma_gptr
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;Can&squot;t get 1550 dbdma irq&quot;
)paren
suffix:semicolon
)brace
r_void
DECL|function|au1xxx_dbdma_dump
id|au1xxx_dbdma_dump
c_func
(paren
id|u32
id|chanid
)paren
(brace
id|chan_tab_t
op_star
id|ctp
suffix:semicolon
id|au1x_ddma_desc_t
op_star
id|dp
suffix:semicolon
id|dbdev_tab_t
op_star
id|stp
comma
op_star
id|dtp
suffix:semicolon
r_volatile
id|au1x_dma_chan_t
op_star
id|cp
suffix:semicolon
id|ctp
op_assign
op_star
(paren
(paren
id|chan_tab_t
op_star
op_star
)paren
id|chanid
)paren
suffix:semicolon
id|stp
op_assign
id|ctp-&gt;chan_src
suffix:semicolon
id|dtp
op_assign
id|ctp-&gt;chan_dest
suffix:semicolon
id|cp
op_assign
id|ctp-&gt;chan_ptr
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Chan %x, stp %x (dev %d)  dtp %x (dev %d) &bslash;n&quot;
comma
(paren
id|u32
)paren
id|ctp
comma
(paren
id|u32
)paren
id|stp
comma
id|stp
op_minus
id|dbdev_tab
comma
(paren
id|u32
)paren
id|dtp
comma
id|dtp
op_minus
id|dbdev_tab
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;desc base %x, get %x, put %x, cur %x&bslash;n&quot;
comma
(paren
id|u32
)paren
(paren
id|ctp-&gt;chan_desc_base
)paren
comma
(paren
id|u32
)paren
(paren
id|ctp-&gt;get_ptr
)paren
comma
(paren
id|u32
)paren
(paren
id|ctp-&gt;put_ptr
)paren
comma
(paren
id|u32
)paren
(paren
id|ctp-&gt;cur_ptr
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;dbdma chan %x&bslash;n&quot;
comma
(paren
id|u32
)paren
id|cp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cfg %08x, desptr %08x, statptr %08x&bslash;n&quot;
comma
id|cp-&gt;ddma_cfg
comma
id|cp-&gt;ddma_desptr
comma
id|cp-&gt;ddma_statptr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;dbell %08x, irq %08x, stat %08x, bytecnt %08x&bslash;n&quot;
comma
id|cp-&gt;ddma_dbell
comma
id|cp-&gt;ddma_irq
comma
id|cp-&gt;ddma_stat
comma
id|cp-&gt;ddma_bytecnt
)paren
suffix:semicolon
multiline_comment|/* Run through the descriptors&n;&t;*/
id|dp
op_assign
id|ctp-&gt;chan_desc_base
suffix:semicolon
r_do
(brace
id|printk
c_func
(paren
l_string|&quot;dp %08x, cmd0 %08x, cmd1 %08x&bslash;n&quot;
comma
(paren
id|u32
)paren
id|dp
comma
id|dp-&gt;dscr_cmd0
comma
id|dp-&gt;dscr_cmd1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;src0 %08x, src1 %08x, dest0 %08x&bslash;n&quot;
comma
id|dp-&gt;dscr_source0
comma
id|dp-&gt;dscr_source1
comma
id|dp-&gt;dscr_dest0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;dest1 %08x, stat %08x, nxtptr %08x&bslash;n&quot;
comma
id|dp-&gt;dscr_dest1
comma
id|dp-&gt;dscr_stat
comma
id|dp-&gt;dscr_nxtptr
)paren
suffix:semicolon
id|dp
op_assign
id|phys_to_virt
c_func
(paren
id|DSCR_GET_NXTPTR
c_func
(paren
id|dp-&gt;dscr_nxtptr
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dp
op_ne
id|ctp-&gt;chan_desc_base
)paren
suffix:semicolon
)brace
macro_line|#endif /* defined(CONFIG_SOC_AU1550) || defined(CONFIG_SOC_AU1200) */
eof
