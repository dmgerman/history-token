multiline_comment|/*&n; * BRIEF MODULE DESCRIPTION&n; *&t;Au1000 USB Device-Side (device layer)&n; *&n; * Copyright 2001-2002 MontaVista Software Inc.&n; * Author: MontaVista Software, Inc.&n; *&t;&t;stevel@mvista.com or source@mvista.com&n; *&n; *  This program is free software; you can redistribute&t; it and/or modify it&n; *  under  the terms of&t; the GNU General  Public License as published by the&n; *  Free Software Foundation;  either version 2 of the&t;License, or (at your&n; *  option) any later version.&n; *&n; *  THIS  SOFTWARE  IS PROVIDED&t;  ``AS&t;IS&squot;&squot; AND   ANY&t;EXPRESS OR IMPLIED&n; *  WARRANTIES,&t;  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF&n; *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN&n; *  NO&t;EVENT  SHALL   THE AUTHOR  BE&t; LIABLE FOR ANY&t;  DIRECT, INDIRECT,&n; *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT&n; *  NOT LIMITED&t;  TO, PROCUREMENT OF  SUBSTITUTE GOODS&t;OR SERVICES; LOSS OF&n; *  USE, DATA,&t;OR PROFITS; OR&t;BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON&n; *  ANY THEORY OF LIABILITY, WHETHER IN&t; CONTRACT, STRICT LIABILITY, OR TORT&n; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF&n; *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; *&n; *  You should have received a copy of the  GNU General Public License along&n; *  with this program; if not, write  to the Free Software Foundation, Inc.,&n; *  675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
DECL|macro|DEBUG
mdefine_line|#define DEBUG
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/mipsregs.h&gt;
macro_line|#include &lt;asm/au1000.h&gt;
macro_line|#include &lt;asm/au1000_dma.h&gt;
macro_line|#include &lt;asm/au1000_usbdev.h&gt;
macro_line|#ifdef DEBUG
DECL|macro|VDEBUG
macro_line|#undef VDEBUG
macro_line|#ifdef VDEBUG
DECL|macro|vdbg
mdefine_line|#define vdbg(fmt, arg...) printk(KERN_DEBUG __FILE__ &quot;: &quot; fmt &quot;&bslash;n&quot; , ## arg)
macro_line|#else
DECL|macro|vdbg
mdefine_line|#define vdbg(fmt, arg...) do {} while (0)
macro_line|#endif
macro_line|#else
DECL|macro|vdbg
mdefine_line|#define vdbg(fmt, arg...) do {} while (0)
macro_line|#endif
DECL|macro|ALLOC_FLAGS
mdefine_line|#define ALLOC_FLAGS (in_interrupt () ? GFP_ATOMIC : GFP_KERNEL)
DECL|macro|EP_FIFO_DEPTH
mdefine_line|#define EP_FIFO_DEPTH 8
r_typedef
r_enum
(brace
DECL|enumerator|SETUP_STAGE
id|SETUP_STAGE
op_assign
l_int|0
comma
DECL|enumerator|DATA_STAGE
id|DATA_STAGE
comma
DECL|enumerator|STATUS_STAGE
id|STATUS_STAGE
DECL|typedef|ep0_stage_t
)brace
id|ep0_stage_t
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|read_fifo
r_int
id|read_fifo
suffix:semicolon
DECL|member|write_fifo
r_int
id|write_fifo
suffix:semicolon
DECL|member|ctrl_stat
r_int
id|ctrl_stat
suffix:semicolon
DECL|member|read_fifo_status
r_int
id|read_fifo_status
suffix:semicolon
DECL|member|write_fifo_status
r_int
id|write_fifo_status
suffix:semicolon
DECL|typedef|endpoint_reg_t
)brace
id|endpoint_reg_t
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|head
id|usbdev_pkt_t
op_star
id|head
suffix:semicolon
DECL|member|tail
id|usbdev_pkt_t
op_star
id|tail
suffix:semicolon
DECL|member|count
r_int
id|count
suffix:semicolon
DECL|typedef|pkt_list_t
)brace
id|pkt_list_t
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|active
r_int
id|active
suffix:semicolon
DECL|member|desc
r_struct
id|usb_endpoint_descriptor
op_star
id|desc
suffix:semicolon
DECL|member|reg
id|endpoint_reg_t
op_star
id|reg
suffix:semicolon
multiline_comment|/* Only one of these are used, unless this is the control ep */
DECL|member|inlist
id|pkt_list_t
id|inlist
suffix:semicolon
DECL|member|outlist
id|pkt_list_t
id|outlist
suffix:semicolon
DECL|member|indma
DECL|member|outdma
r_int
r_int
id|indma
comma
id|outdma
suffix:semicolon
multiline_comment|/* DMA channel numbers for IN, OUT */
multiline_comment|/* following are extracted from endpoint descriptor for easy access */
DECL|member|max_pkt_size
r_int
id|max_pkt_size
suffix:semicolon
DECL|member|type
r_int
id|type
suffix:semicolon
DECL|member|direction
r_int
id|direction
suffix:semicolon
multiline_comment|/* WE assign endpoint addresses! */
DECL|member|address
r_int
id|address
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|typedef|endpoint_t
)brace
id|endpoint_t
suffix:semicolon
DECL|struct|usb_dev
r_static
r_struct
id|usb_dev
(brace
DECL|member|ep
id|endpoint_t
id|ep
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|ep0_stage
id|ep0_stage_t
id|ep0_stage
suffix:semicolon
DECL|member|dev_desc
r_struct
id|usb_device_descriptor
op_star
id|dev_desc
suffix:semicolon
DECL|member|if_desc
r_struct
id|usb_interface_descriptor
op_star
id|if_desc
suffix:semicolon
DECL|member|conf_desc
r_struct
id|usb_config_descriptor
op_star
id|conf_desc
suffix:semicolon
DECL|member|full_conf_desc
id|u8
op_star
id|full_conf_desc
suffix:semicolon
DECL|member|str_desc
r_struct
id|usb_string_descriptor
op_star
id|str_desc
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/* callback to function layer */
DECL|member|func_cb
r_void
(paren
op_star
id|func_cb
)paren
(paren
id|usbdev_cb_type_t
id|type
comma
r_int
r_int
id|arg
comma
r_void
op_star
id|cb_data
)paren
suffix:semicolon
DECL|member|cb_data
r_void
op_star
id|cb_data
suffix:semicolon
DECL|member|state
id|usbdev_state_t
id|state
suffix:semicolon
singleline_comment|// device state
DECL|member|suspended
r_int
id|suspended
suffix:semicolon
singleline_comment|// suspended flag
DECL|member|address
r_int
id|address
suffix:semicolon
singleline_comment|// device address
DECL|member|interface
r_int
id|interface
suffix:semicolon
DECL|member|num_ep
r_int
id|num_ep
suffix:semicolon
DECL|member|alternate_setting
id|u8
id|alternate_setting
suffix:semicolon
DECL|member|configuration
id|u8
id|configuration
suffix:semicolon
singleline_comment|// configuration value
DECL|member|remote_wakeup_en
r_int
id|remote_wakeup_en
suffix:semicolon
DECL|variable|usbdev
)brace
id|usbdev
suffix:semicolon
DECL|variable|ep_reg
r_static
id|endpoint_reg_t
id|ep_reg
(braket
)braket
op_assign
(brace
singleline_comment|// FIFO&squot;s 0 and 1 are EP0 default control
(brace
id|USBD_EP0RD
comma
id|USBD_EP0WR
comma
id|USBD_EP0CS
comma
id|USBD_EP0RDSTAT
comma
id|USBD_EP0WRSTAT
)brace
comma
(brace
l_int|0
)brace
comma
singleline_comment|// FIFO 2 is EP2, IN
(brace
op_minus
l_int|1
comma
id|USBD_EP2WR
comma
id|USBD_EP2CS
comma
op_minus
l_int|1
comma
id|USBD_EP2WRSTAT
)brace
comma
singleline_comment|// FIFO 3 is EP3, IN
(brace
op_minus
l_int|1
comma
id|USBD_EP3WR
comma
id|USBD_EP3CS
comma
op_minus
l_int|1
comma
id|USBD_EP3WRSTAT
)brace
comma
singleline_comment|// FIFO 4 is EP4, OUT
(brace
id|USBD_EP4RD
comma
op_minus
l_int|1
comma
id|USBD_EP4CS
comma
id|USBD_EP4RDSTAT
comma
op_minus
l_int|1
)brace
comma
singleline_comment|// FIFO 5 is EP5, OUT
(brace
id|USBD_EP5RD
comma
op_minus
l_int|1
comma
id|USBD_EP5CS
comma
id|USBD_EP5RDSTAT
comma
op_minus
l_int|1
)brace
)brace
suffix:semicolon
r_static
r_struct
(brace
DECL|member|id
r_int
r_int
id|id
suffix:semicolon
DECL|member|str
r_const
r_char
op_star
id|str
suffix:semicolon
DECL|variable|ep_dma_id
)brace
id|ep_dma_id
(braket
)braket
op_assign
(brace
(brace
id|DMA_ID_USBDEV_EP0_TX
comma
l_string|&quot;USBDev EP0 IN&quot;
)brace
comma
(brace
id|DMA_ID_USBDEV_EP0_RX
comma
l_string|&quot;USBDev EP0 OUT&quot;
)brace
comma
(brace
id|DMA_ID_USBDEV_EP2_TX
comma
l_string|&quot;USBDev EP2 IN&quot;
)brace
comma
(brace
id|DMA_ID_USBDEV_EP3_TX
comma
l_string|&quot;USBDev EP3 IN&quot;
)brace
comma
(brace
id|DMA_ID_USBDEV_EP4_RX
comma
l_string|&quot;USBDev EP4 OUT&quot;
)brace
comma
(brace
id|DMA_ID_USBDEV_EP5_RX
comma
l_string|&quot;USBDev EP5 OUT&quot;
)brace
)brace
suffix:semicolon
DECL|macro|DIR_OUT
mdefine_line|#define DIR_OUT 0
DECL|macro|DIR_IN
mdefine_line|#define DIR_IN  (1&lt;&lt;3)
DECL|macro|CONTROL_EP
mdefine_line|#define CONTROL_EP USB_ENDPOINT_XFER_CONTROL
DECL|macro|BULK_EP
mdefine_line|#define BULK_EP    USB_ENDPOINT_XFER_BULK
r_static
r_inline
id|endpoint_t
op_star
DECL|function|epaddr_to_ep
id|epaddr_to_ep
c_func
(paren
r_struct
id|usb_dev
op_star
id|dev
comma
r_int
id|ep_addr
)paren
(brace
r_if
c_cond
(paren
id|ep_addr
op_ge
l_int|0
op_logical_and
id|ep_addr
OL
l_int|2
)paren
r_return
op_amp
id|dev-&gt;ep
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ep_addr
OL
l_int|6
)paren
r_return
op_amp
id|dev-&gt;ep
(braket
id|ep_addr
)braket
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|variable|std_req_name
r_static
r_const
r_char
op_star
id|std_req_name
(braket
)braket
op_assign
(brace
l_string|&quot;GET_STATUS&quot;
comma
l_string|&quot;CLEAR_FEATURE&quot;
comma
l_string|&quot;RESERVED&quot;
comma
l_string|&quot;SET_FEATURE&quot;
comma
l_string|&quot;RESERVED&quot;
comma
l_string|&quot;SET_ADDRESS&quot;
comma
l_string|&quot;GET_DESCRIPTOR&quot;
comma
l_string|&quot;SET_DESCRIPTOR&quot;
comma
l_string|&quot;GET_CONFIGURATION&quot;
comma
l_string|&quot;SET_CONFIGURATION&quot;
comma
l_string|&quot;GET_INTERFACE&quot;
comma
l_string|&quot;SET_INTERFACE&quot;
comma
l_string|&quot;SYNCH_FRAME&quot;
)brace
suffix:semicolon
r_static
r_inline
r_const
r_char
op_star
DECL|function|get_std_req_name
id|get_std_req_name
c_func
(paren
r_int
id|req
)paren
(brace
r_return
(paren
id|req
op_ge
l_int|0
op_logical_and
id|req
op_le
l_int|12
)paren
ques
c_cond
id|std_req_name
(braket
id|req
)braket
suffix:colon
l_string|&quot;UNKNOWN&quot;
suffix:semicolon
)brace
macro_line|#if 0
r_static
r_void
id|dump_setup
c_func
(paren
r_struct
id|usb_ctrlrequest
op_star
id|s
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s: requesttype=%d&quot;
comma
id|__FUNCTION__
comma
id|s-&gt;requesttype
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: request=%d %s&quot;
comma
id|__FUNCTION__
comma
id|s-&gt;request
comma
id|get_std_req_name
c_func
(paren
id|s-&gt;request
)paren
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: value=0x%04x&quot;
comma
id|__FUNCTION__
comma
id|s-&gt;wValue
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: index=%d&quot;
comma
id|__FUNCTION__
comma
id|s-&gt;index
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: length=%d&quot;
comma
id|__FUNCTION__
comma
id|s-&gt;length
)paren
suffix:semicolon
)brace
macro_line|#endif
r_static
r_inline
id|usbdev_pkt_t
op_star
DECL|function|alloc_packet
id|alloc_packet
c_func
(paren
id|endpoint_t
op_star
id|ep
comma
r_int
id|data_size
comma
r_void
op_star
id|data
)paren
(brace
id|usbdev_pkt_t
op_star
id|pkt
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|usbdev_pkt_t
)paren
op_plus
id|data_size
comma
id|ALLOC_FLAGS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pkt
)paren
r_return
l_int|NULL
suffix:semicolon
id|pkt-&gt;ep_addr
op_assign
id|ep-&gt;address
suffix:semicolon
id|pkt-&gt;size
op_assign
id|data_size
suffix:semicolon
id|pkt-&gt;status
op_assign
l_int|0
suffix:semicolon
id|pkt-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|data
)paren
id|memcpy
c_func
(paren
id|pkt-&gt;payload
comma
id|data
comma
id|data_size
)paren
suffix:semicolon
r_return
id|pkt
suffix:semicolon
)brace
multiline_comment|/*&n; * Link a packet to the tail of the enpoint&squot;s packet list.&n; * EP spinlock must be held when calling.&n; */
r_static
r_void
DECL|function|link_tail
id|link_tail
c_func
(paren
id|endpoint_t
op_star
id|ep
comma
id|pkt_list_t
op_star
id|list
comma
id|usbdev_pkt_t
op_star
id|pkt
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|list-&gt;tail
)paren
(brace
id|list-&gt;head
op_assign
id|list-&gt;tail
op_assign
id|pkt
suffix:semicolon
id|list-&gt;count
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|list-&gt;tail-&gt;next
op_assign
id|pkt
suffix:semicolon
id|list-&gt;tail
op_assign
id|pkt
suffix:semicolon
id|list-&gt;count
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Unlink and return a packet from the head of the given packet&n; * list. It is the responsibility of the caller to free the packet.&n; * EP spinlock must be held when calling.&n; */
r_static
id|usbdev_pkt_t
op_star
DECL|function|unlink_head
id|unlink_head
c_func
(paren
id|pkt_list_t
op_star
id|list
)paren
(brace
id|usbdev_pkt_t
op_star
id|pkt
suffix:semicolon
id|pkt
op_assign
id|list-&gt;head
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pkt
op_logical_or
op_logical_neg
id|list-&gt;count
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|list-&gt;head
op_assign
id|pkt-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list-&gt;head
)paren
(brace
id|list-&gt;head
op_assign
id|list-&gt;tail
op_assign
l_int|NULL
suffix:semicolon
id|list-&gt;count
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|list-&gt;count
op_decrement
suffix:semicolon
r_return
id|pkt
suffix:semicolon
)brace
multiline_comment|/*&n; * Create and attach a new packet to the tail of the enpoint&squot;s&n; * packet list. EP spinlock must be held when calling.&n; */
r_static
id|usbdev_pkt_t
op_star
DECL|function|add_packet
id|add_packet
c_func
(paren
id|endpoint_t
op_star
id|ep
comma
id|pkt_list_t
op_star
id|list
comma
r_int
id|size
)paren
(brace
id|usbdev_pkt_t
op_star
id|pkt
op_assign
id|alloc_packet
c_func
(paren
id|ep
comma
id|size
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pkt
)paren
r_return
l_int|NULL
suffix:semicolon
id|link_tail
c_func
(paren
id|ep
comma
id|list
comma
id|pkt
)paren
suffix:semicolon
r_return
id|pkt
suffix:semicolon
)brace
multiline_comment|/*&n; * Unlink and free a packet from the head of the enpoint&squot;s&n; * packet list. EP spinlock must be held when calling.&n; */
r_static
r_inline
r_void
DECL|function|free_packet
id|free_packet
c_func
(paren
id|pkt_list_t
op_star
id|list
)paren
(brace
id|kfree
c_func
(paren
id|unlink_head
c_func
(paren
id|list
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* EP spinlock must be held when calling. */
r_static
r_inline
r_void
DECL|function|flush_pkt_list
id|flush_pkt_list
c_func
(paren
id|pkt_list_t
op_star
id|list
)paren
(brace
r_while
c_loop
(paren
id|list-&gt;count
)paren
id|free_packet
c_func
(paren
id|list
)paren
suffix:semicolon
)brace
multiline_comment|/* EP spinlock must be held when calling */
r_static
r_inline
r_void
DECL|function|flush_write_fifo
id|flush_write_fifo
c_func
(paren
id|endpoint_t
op_star
id|ep
)paren
(brace
r_if
c_cond
(paren
id|ep-&gt;reg-&gt;write_fifo_status
op_ge
l_int|0
)paren
(brace
id|au_writel
c_func
(paren
id|USBDEV_FSTAT_FLUSH
op_or
id|USBDEV_FSTAT_UF
op_or
id|USBDEV_FSTAT_OF
comma
id|ep-&gt;reg-&gt;write_fifo_status
)paren
suffix:semicolon
singleline_comment|//udelay(100);
singleline_comment|//au_writel(USBDEV_FSTAT_UF | USBDEV_FSTAT_OF,
singleline_comment|//&t;  ep-&gt;reg-&gt;write_fifo_status);
)brace
)brace
multiline_comment|/* EP spinlock must be held when calling */
r_static
r_inline
r_void
DECL|function|flush_read_fifo
id|flush_read_fifo
c_func
(paren
id|endpoint_t
op_star
id|ep
)paren
(brace
r_if
c_cond
(paren
id|ep-&gt;reg-&gt;read_fifo_status
op_ge
l_int|0
)paren
(brace
id|au_writel
c_func
(paren
id|USBDEV_FSTAT_FLUSH
op_or
id|USBDEV_FSTAT_UF
op_or
id|USBDEV_FSTAT_OF
comma
id|ep-&gt;reg-&gt;read_fifo_status
)paren
suffix:semicolon
singleline_comment|//udelay(100);
singleline_comment|//au_writel(USBDEV_FSTAT_UF | USBDEV_FSTAT_OF,
singleline_comment|//&t;  ep-&gt;reg-&gt;read_fifo_status);
)brace
)brace
multiline_comment|/* EP spinlock must be held when calling. */
r_static
r_void
DECL|function|endpoint_flush
id|endpoint_flush
c_func
(paren
id|endpoint_t
op_star
id|ep
)paren
(brace
singleline_comment|// First, flush all packets
id|flush_pkt_list
c_func
(paren
op_amp
id|ep-&gt;inlist
)paren
suffix:semicolon
id|flush_pkt_list
c_func
(paren
op_amp
id|ep-&gt;outlist
)paren
suffix:semicolon
singleline_comment|// Now flush the endpoint&squot;s h/w FIFO(s)
id|flush_write_fifo
c_func
(paren
id|ep
)paren
suffix:semicolon
id|flush_read_fifo
c_func
(paren
id|ep
)paren
suffix:semicolon
)brace
multiline_comment|/* EP spinlock must be held when calling. */
r_static
r_void
DECL|function|endpoint_stall
id|endpoint_stall
c_func
(paren
id|endpoint_t
op_star
id|ep
)paren
(brace
id|u32
id|cs
suffix:semicolon
id|warn
c_func
(paren
id|__FUNCTION__
)paren
suffix:semicolon
id|cs
op_assign
id|au_readl
c_func
(paren
id|ep-&gt;reg-&gt;ctrl_stat
)paren
op_or
id|USBDEV_CS_STALL
suffix:semicolon
id|au_writel
c_func
(paren
id|cs
comma
id|ep-&gt;reg-&gt;ctrl_stat
)paren
suffix:semicolon
)brace
multiline_comment|/* EP spinlock must be held when calling. */
r_static
r_void
DECL|function|endpoint_unstall
id|endpoint_unstall
c_func
(paren
id|endpoint_t
op_star
id|ep
)paren
(brace
id|u32
id|cs
suffix:semicolon
id|warn
c_func
(paren
id|__FUNCTION__
)paren
suffix:semicolon
id|cs
op_assign
id|au_readl
c_func
(paren
id|ep-&gt;reg-&gt;ctrl_stat
)paren
op_amp
op_complement
id|USBDEV_CS_STALL
suffix:semicolon
id|au_writel
c_func
(paren
id|cs
comma
id|ep-&gt;reg-&gt;ctrl_stat
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|endpoint_reset_datatoggle
id|endpoint_reset_datatoggle
c_func
(paren
id|endpoint_t
op_star
id|ep
)paren
(brace
singleline_comment|// FIXME: is this possible?
)brace
multiline_comment|/* EP spinlock must be held when calling. */
r_static
r_int
DECL|function|endpoint_fifo_read
id|endpoint_fifo_read
c_func
(paren
id|endpoint_t
op_star
id|ep
)paren
(brace
r_int
id|read_count
op_assign
l_int|0
suffix:semicolon
id|u8
op_star
id|bufptr
suffix:semicolon
id|usbdev_pkt_t
op_star
id|pkt
op_assign
id|ep-&gt;outlist.tail
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pkt
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|bufptr
op_assign
op_amp
id|pkt-&gt;payload
(braket
id|pkt-&gt;size
)braket
suffix:semicolon
r_while
c_loop
(paren
id|au_readl
c_func
(paren
id|ep-&gt;reg-&gt;read_fifo_status
)paren
op_amp
id|USBDEV_FSTAT_FCNT_MASK
)paren
(brace
op_star
id|bufptr
op_increment
op_assign
id|au_readl
c_func
(paren
id|ep-&gt;reg-&gt;read_fifo
)paren
op_amp
l_int|0xff
suffix:semicolon
id|read_count
op_increment
suffix:semicolon
id|pkt-&gt;size
op_increment
suffix:semicolon
)brace
r_return
id|read_count
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* EP spinlock must be held when calling. */
r_static
r_int
id|endpoint_fifo_write
c_func
(paren
id|endpoint_t
op_star
id|ep
comma
r_int
id|index
)paren
(brace
r_int
id|write_count
op_assign
l_int|0
suffix:semicolon
id|u8
op_star
id|bufptr
suffix:semicolon
id|usbdev_pkt_t
op_star
id|pkt
op_assign
id|ep-&gt;inlist.head
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pkt
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|bufptr
op_assign
op_amp
id|pkt-&gt;payload
(braket
id|index
)braket
suffix:semicolon
r_while
c_loop
(paren
(paren
id|au_readl
c_func
(paren
id|ep-&gt;reg-&gt;write_fifo_status
)paren
op_amp
id|USBDEV_FSTAT_FCNT_MASK
)paren
OL
id|EP_FIFO_DEPTH
)paren
(brace
r_if
c_cond
(paren
id|bufptr
OL
id|pkt-&gt;payload
op_plus
id|pkt-&gt;size
)paren
(brace
id|au_writel
c_func
(paren
op_star
id|bufptr
op_increment
comma
id|ep-&gt;reg-&gt;write_fifo
)paren
suffix:semicolon
id|write_count
op_increment
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
r_return
id|write_count
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * This routine is called to restart transmission of a packet.&n; * The endpoint&squot;s TSIZE must be set to the new packet&squot;s size,&n; * and DMA to the write FIFO needs to be restarted.&n; * EP spinlock must be held when calling.&n; */
r_static
r_void
DECL|function|kickstart_send_packet
id|kickstart_send_packet
c_func
(paren
id|endpoint_t
op_star
id|ep
)paren
(brace
id|u32
id|cs
suffix:semicolon
id|usbdev_pkt_t
op_star
id|pkt
op_assign
id|ep-&gt;inlist.head
suffix:semicolon
id|vdbg
c_func
(paren
l_string|&quot;%s: ep%d, pkt=%p&quot;
comma
id|__FUNCTION__
comma
id|ep-&gt;address
comma
id|pkt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pkt
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: head=NULL! list-&gt;count=%d&quot;
comma
id|__FUNCTION__
comma
id|ep-&gt;inlist.count
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dma_cache_wback_inv
c_func
(paren
(paren
r_int
r_int
)paren
id|pkt-&gt;payload
comma
id|pkt-&gt;size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * make sure FIFO is empty&n;&t; */
id|flush_write_fifo
c_func
(paren
id|ep
)paren
suffix:semicolon
id|cs
op_assign
id|au_readl
c_func
(paren
id|ep-&gt;reg-&gt;ctrl_stat
)paren
op_amp
id|USBDEV_CS_STALL
suffix:semicolon
id|cs
op_or_assign
(paren
id|pkt-&gt;size
op_lshift
id|USBDEV_CS_TSIZE_BIT
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|cs
comma
id|ep-&gt;reg-&gt;ctrl_stat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_dma_active_buffer
c_func
(paren
id|ep-&gt;indma
)paren
op_eq
l_int|1
)paren
(brace
id|set_dma_count1
c_func
(paren
id|ep-&gt;indma
comma
id|pkt-&gt;size
)paren
suffix:semicolon
id|set_dma_addr1
c_func
(paren
id|ep-&gt;indma
comma
id|virt_to_phys
c_func
(paren
id|pkt-&gt;payload
)paren
)paren
suffix:semicolon
id|enable_dma_buffer1
c_func
(paren
id|ep-&gt;indma
)paren
suffix:semicolon
singleline_comment|// reenable
)brace
r_else
(brace
id|set_dma_count0
c_func
(paren
id|ep-&gt;indma
comma
id|pkt-&gt;size
)paren
suffix:semicolon
id|set_dma_addr0
c_func
(paren
id|ep-&gt;indma
comma
id|virt_to_phys
c_func
(paren
id|pkt-&gt;payload
)paren
)paren
suffix:semicolon
id|enable_dma_buffer0
c_func
(paren
id|ep-&gt;indma
)paren
suffix:semicolon
singleline_comment|// reenable
)brace
r_if
c_cond
(paren
id|dma_halted
c_func
(paren
id|ep-&gt;indma
)paren
)paren
id|start_dma
c_func
(paren
id|ep-&gt;indma
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called when a packet in the inlist has been&n; * completed. Frees the completed packet and starts sending the&n; * next. EP spinlock must be held when calling.&n; */
r_static
id|usbdev_pkt_t
op_star
DECL|function|send_packet_complete
id|send_packet_complete
c_func
(paren
id|endpoint_t
op_star
id|ep
)paren
(brace
id|usbdev_pkt_t
op_star
id|pkt
op_assign
id|unlink_head
c_func
(paren
op_amp
id|ep-&gt;inlist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt
)paren
(brace
id|pkt-&gt;status
op_assign
(paren
id|au_readl
c_func
(paren
id|ep-&gt;reg-&gt;ctrl_stat
)paren
op_amp
id|USBDEV_CS_NAK
)paren
ques
c_cond
id|PKT_STATUS_NAK
suffix:colon
id|PKT_STATUS_ACK
suffix:semicolon
id|vdbg
c_func
(paren
l_string|&quot;%s: ep%d, %s pkt=%p, list count=%d&quot;
comma
id|__FUNCTION__
comma
id|ep-&gt;address
comma
(paren
id|pkt-&gt;status
op_amp
id|PKT_STATUS_NAK
)paren
ques
c_cond
l_string|&quot;NAK&quot;
suffix:colon
l_string|&quot;ACK&quot;
comma
id|pkt
comma
id|ep-&gt;inlist.count
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The write fifo should already be drained if things are&n;&t; * working right, but flush it anyway just in case.&n;&t; */
id|flush_write_fifo
c_func
(paren
id|ep
)paren
suffix:semicolon
singleline_comment|// begin transmitting next packet in the inlist
r_if
c_cond
(paren
id|ep-&gt;inlist.count
)paren
(brace
id|kickstart_send_packet
c_func
(paren
id|ep
)paren
suffix:semicolon
)brace
r_return
id|pkt
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a new packet to the tail of the given ep&squot;s packet&n; * inlist. The transmit complete interrupt frees packets from&n; * the head of this list. EP spinlock must be held when calling.&n; */
r_static
r_int
DECL|function|send_packet
id|send_packet
c_func
(paren
r_struct
id|usb_dev
op_star
id|dev
comma
id|usbdev_pkt_t
op_star
id|pkt
comma
r_int
id|async
)paren
(brace
id|pkt_list_t
op_star
id|list
suffix:semicolon
id|endpoint_t
op_star
id|ep
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pkt
op_logical_or
op_logical_neg
(paren
id|ep
op_assign
id|epaddr_to_ep
c_func
(paren
id|dev
comma
id|pkt-&gt;ep_addr
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pkt-&gt;size
)paren
r_return
l_int|0
suffix:semicolon
id|list
op_assign
op_amp
id|ep-&gt;inlist
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|async
op_logical_and
id|list-&gt;count
)paren
(brace
id|halt_dma
c_func
(paren
id|ep-&gt;indma
)paren
suffix:semicolon
id|flush_pkt_list
c_func
(paren
id|list
)paren
suffix:semicolon
)brace
id|link_tail
c_func
(paren
id|ep
comma
id|list
comma
id|pkt
)paren
suffix:semicolon
id|vdbg
c_func
(paren
l_string|&quot;%s: ep%d, pkt=%p, size=%d, list count=%d&quot;
comma
id|__FUNCTION__
comma
id|ep-&gt;address
comma
id|pkt
comma
id|pkt-&gt;size
comma
id|list-&gt;count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list-&gt;count
op_eq
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * if the packet count is one, it means the list was empty,&n;&t;&t; * and no more data will go out this ep until we kick-start&n;&t;&t; * it again.&n;&t;&t; */
id|kickstart_send_packet
c_func
(paren
id|ep
)paren
suffix:semicolon
)brace
r_return
id|pkt-&gt;size
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called to restart reception of a packet.&n; * EP spinlock must be held when calling.&n; */
r_static
r_void
DECL|function|kickstart_receive_packet
id|kickstart_receive_packet
c_func
(paren
id|endpoint_t
op_star
id|ep
)paren
(brace
id|usbdev_pkt_t
op_star
id|pkt
suffix:semicolon
singleline_comment|// get and link a new packet for next reception
r_if
c_cond
(paren
op_logical_neg
(paren
id|pkt
op_assign
id|add_packet
c_func
(paren
id|ep
comma
op_amp
id|ep-&gt;outlist
comma
id|ep-&gt;max_pkt_size
)paren
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: could not alloc new packet&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_dma_active_buffer
c_func
(paren
id|ep-&gt;outdma
)paren
op_eq
l_int|1
)paren
(brace
id|clear_dma_done1
c_func
(paren
id|ep-&gt;outdma
)paren
suffix:semicolon
id|set_dma_count1
c_func
(paren
id|ep-&gt;outdma
comma
id|ep-&gt;max_pkt_size
)paren
suffix:semicolon
id|set_dma_count0
c_func
(paren
id|ep-&gt;outdma
comma
l_int|0
)paren
suffix:semicolon
id|set_dma_addr1
c_func
(paren
id|ep-&gt;outdma
comma
id|virt_to_phys
c_func
(paren
id|pkt-&gt;payload
)paren
)paren
suffix:semicolon
id|enable_dma_buffer1
c_func
(paren
id|ep-&gt;outdma
)paren
suffix:semicolon
singleline_comment|// reenable
)brace
r_else
(brace
id|clear_dma_done0
c_func
(paren
id|ep-&gt;outdma
)paren
suffix:semicolon
id|set_dma_count0
c_func
(paren
id|ep-&gt;outdma
comma
id|ep-&gt;max_pkt_size
)paren
suffix:semicolon
id|set_dma_count1
c_func
(paren
id|ep-&gt;outdma
comma
l_int|0
)paren
suffix:semicolon
id|set_dma_addr0
c_func
(paren
id|ep-&gt;outdma
comma
id|virt_to_phys
c_func
(paren
id|pkt-&gt;payload
)paren
)paren
suffix:semicolon
id|enable_dma_buffer0
c_func
(paren
id|ep-&gt;outdma
)paren
suffix:semicolon
singleline_comment|// reenable
)brace
r_if
c_cond
(paren
id|dma_halted
c_func
(paren
id|ep-&gt;outdma
)paren
)paren
id|start_dma
c_func
(paren
id|ep-&gt;outdma
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called when a packet in the outlist has been&n; * completed (received) and we need to prepare for a new packet&n; * to be received. Halts DMA and computes the packet size from the&n; * remaining DMA counter. Then prepares a new packet for reception&n; * and restarts DMA. FIXME: what if another packet comes in&n; * on top of the completed packet? Counter would be wrong.&n; * EP spinlock must be held when calling.&n; */
r_static
id|usbdev_pkt_t
op_star
DECL|function|receive_packet_complete
id|receive_packet_complete
c_func
(paren
id|endpoint_t
op_star
id|ep
)paren
(brace
id|usbdev_pkt_t
op_star
id|pkt
op_assign
id|ep-&gt;outlist.tail
suffix:semicolon
id|u32
id|cs
suffix:semicolon
id|halt_dma
c_func
(paren
id|ep-&gt;outdma
)paren
suffix:semicolon
id|cs
op_assign
id|au_readl
c_func
(paren
id|ep-&gt;reg-&gt;ctrl_stat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pkt
)paren
r_return
l_int|NULL
suffix:semicolon
id|pkt-&gt;size
op_assign
id|ep-&gt;max_pkt_size
op_minus
id|get_dma_residue
c_func
(paren
id|ep-&gt;outdma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt-&gt;size
)paren
id|dma_cache_inv
c_func
(paren
(paren
r_int
r_int
)paren
id|pkt-&gt;payload
comma
id|pkt-&gt;size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * need to pull out any remaining bytes in the FIFO.&n;&t; */
id|endpoint_fifo_read
c_func
(paren
id|ep
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * should be drained now, but flush anyway just in case.&n;&t; */
id|flush_read_fifo
c_func
(paren
id|ep
)paren
suffix:semicolon
id|pkt-&gt;status
op_assign
(paren
id|cs
op_amp
id|USBDEV_CS_NAK
)paren
ques
c_cond
id|PKT_STATUS_NAK
suffix:colon
id|PKT_STATUS_ACK
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;address
op_eq
l_int|0
op_logical_and
(paren
id|cs
op_amp
id|USBDEV_CS_SU
)paren
)paren
id|pkt-&gt;status
op_or_assign
id|PKT_STATUS_SU
suffix:semicolon
id|vdbg
c_func
(paren
l_string|&quot;%s: ep%d, %s pkt=%p, size=%d&quot;
comma
id|__FUNCTION__
comma
id|ep-&gt;address
comma
(paren
id|pkt-&gt;status
op_amp
id|PKT_STATUS_NAK
)paren
ques
c_cond
l_string|&quot;NAK&quot;
suffix:colon
l_string|&quot;ACK&quot;
comma
id|pkt
comma
id|pkt-&gt;size
)paren
suffix:semicolon
id|kickstart_receive_packet
c_func
(paren
id|ep
)paren
suffix:semicolon
r_return
id|pkt
suffix:semicolon
)brace
multiline_comment|/*&n; ****************************************************************************&n; * Here starts the standard device request handlers. They are&n; * all called by do_setup() via a table of function pointers.&n; ****************************************************************************&n; */
r_static
id|ep0_stage_t
DECL|function|do_get_status
id|do_get_status
c_func
(paren
r_struct
id|usb_dev
op_star
id|dev
comma
r_struct
id|usb_ctrlrequest
op_star
id|setup
)paren
(brace
r_switch
c_cond
(paren
id|setup-&gt;bRequestType
)paren
(brace
r_case
l_int|0x80
suffix:colon
singleline_comment|// Device
singleline_comment|// FIXME: send device status
r_break
suffix:semicolon
r_case
l_int|0x81
suffix:colon
singleline_comment|// Interface
singleline_comment|// FIXME: send interface status
r_break
suffix:semicolon
r_case
l_int|0x82
suffix:colon
singleline_comment|// End Point
singleline_comment|// FIXME: send endpoint status
r_break
suffix:semicolon
r_default
suffix:colon
singleline_comment|// Invalid Command
id|endpoint_stall
c_func
(paren
op_amp
id|dev-&gt;ep
(braket
l_int|0
)braket
)paren
suffix:semicolon
singleline_comment|// Stall End Point 0
r_break
suffix:semicolon
)brace
r_return
id|STATUS_STAGE
suffix:semicolon
)brace
r_static
id|ep0_stage_t
DECL|function|do_clear_feature
id|do_clear_feature
c_func
(paren
r_struct
id|usb_dev
op_star
id|dev
comma
r_struct
id|usb_ctrlrequest
op_star
id|setup
)paren
(brace
r_switch
c_cond
(paren
id|setup-&gt;bRequestType
)paren
(brace
r_case
l_int|0x00
suffix:colon
singleline_comment|// Device
r_if
c_cond
(paren
(paren
id|le16_to_cpu
c_func
(paren
id|setup-&gt;wValue
)paren
op_amp
l_int|0xff
)paren
op_eq
l_int|1
)paren
id|dev-&gt;remote_wakeup_en
op_assign
l_int|0
suffix:semicolon
r_else
id|endpoint_stall
c_func
(paren
op_amp
id|dev-&gt;ep
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x02
suffix:colon
singleline_comment|// End Point
r_if
c_cond
(paren
(paren
id|le16_to_cpu
c_func
(paren
id|setup-&gt;wValue
)paren
op_amp
l_int|0xff
)paren
op_eq
l_int|0
)paren
(brace
id|endpoint_t
op_star
id|ep
op_assign
id|epaddr_to_ep
c_func
(paren
id|dev
comma
id|le16_to_cpu
c_func
(paren
id|setup-&gt;wIndex
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|endpoint_unstall
c_func
(paren
id|ep
)paren
suffix:semicolon
id|endpoint_reset_datatoggle
c_func
(paren
id|ep
)paren
suffix:semicolon
)brace
r_else
id|endpoint_stall
c_func
(paren
op_amp
id|dev-&gt;ep
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|SETUP_STAGE
suffix:semicolon
)brace
r_static
id|ep0_stage_t
DECL|function|do_reserved
id|do_reserved
c_func
(paren
r_struct
id|usb_dev
op_star
id|dev
comma
r_struct
id|usb_ctrlrequest
op_star
id|setup
)paren
(brace
singleline_comment|// Invalid request, stall End Point 0
id|endpoint_stall
c_func
(paren
op_amp
id|dev-&gt;ep
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
id|SETUP_STAGE
suffix:semicolon
)brace
r_static
id|ep0_stage_t
DECL|function|do_set_feature
id|do_set_feature
c_func
(paren
r_struct
id|usb_dev
op_star
id|dev
comma
r_struct
id|usb_ctrlrequest
op_star
id|setup
)paren
(brace
r_switch
c_cond
(paren
id|setup-&gt;bRequestType
)paren
(brace
r_case
l_int|0x00
suffix:colon
singleline_comment|// Device
r_if
c_cond
(paren
(paren
id|le16_to_cpu
c_func
(paren
id|setup-&gt;wValue
)paren
op_amp
l_int|0xff
)paren
op_eq
l_int|1
)paren
id|dev-&gt;remote_wakeup_en
op_assign
l_int|1
suffix:semicolon
r_else
id|endpoint_stall
c_func
(paren
op_amp
id|dev-&gt;ep
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x02
suffix:colon
singleline_comment|// End Point
r_if
c_cond
(paren
(paren
id|le16_to_cpu
c_func
(paren
id|setup-&gt;wValue
)paren
op_amp
l_int|0xff
)paren
op_eq
l_int|0
)paren
(brace
id|endpoint_t
op_star
id|ep
op_assign
id|epaddr_to_ep
c_func
(paren
id|dev
comma
id|le16_to_cpu
c_func
(paren
id|setup-&gt;wIndex
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|endpoint_stall
c_func
(paren
id|ep
)paren
suffix:semicolon
)brace
r_else
id|endpoint_stall
c_func
(paren
op_amp
id|dev-&gt;ep
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|SETUP_STAGE
suffix:semicolon
)brace
r_static
id|ep0_stage_t
DECL|function|do_set_address
id|do_set_address
c_func
(paren
r_struct
id|usb_dev
op_star
id|dev
comma
r_struct
id|usb_ctrlrequest
op_star
id|setup
)paren
(brace
r_int
id|new_state
op_assign
id|dev-&gt;state
suffix:semicolon
r_int
id|new_addr
op_assign
id|le16_to_cpu
c_func
(paren
id|setup-&gt;wValue
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: our address=%d&quot;
comma
id|__FUNCTION__
comma
id|new_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_addr
OG
l_int|127
)paren
(brace
singleline_comment|// usb spec doesn&squot;t tell us what to do, so just go to
singleline_comment|// default state
id|new_state
op_assign
id|DEFAULT
suffix:semicolon
id|dev-&gt;address
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;address
op_ne
id|new_addr
)paren
(brace
id|dev-&gt;address
op_assign
id|new_addr
suffix:semicolon
id|new_state
op_assign
id|ADDRESS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;state
op_ne
id|new_state
)paren
(brace
id|dev-&gt;state
op_assign
id|new_state
suffix:semicolon
multiline_comment|/* inform function layer of usbdev state change */
id|dev
op_member_access_from_pointer
id|func_cb
c_func
(paren
id|CB_NEW_STATE
comma
id|dev-&gt;state
comma
id|dev-&gt;cb_data
)paren
suffix:semicolon
)brace
r_return
id|SETUP_STAGE
suffix:semicolon
)brace
r_static
id|ep0_stage_t
DECL|function|do_get_descriptor
id|do_get_descriptor
c_func
(paren
r_struct
id|usb_dev
op_star
id|dev
comma
r_struct
id|usb_ctrlrequest
op_star
id|setup
)paren
(brace
r_int
id|strnum
comma
id|desc_len
op_assign
id|le16_to_cpu
c_func
(paren
id|setup-&gt;wLength
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|setup-&gt;wValue
)paren
op_rshift
l_int|8
)paren
(brace
r_case
id|USB_DT_DEVICE
suffix:colon
singleline_comment|// send device descriptor!
id|desc_len
op_assign
id|desc_len
OG
id|dev-&gt;dev_desc-&gt;bLength
ques
c_cond
id|dev-&gt;dev_desc-&gt;bLength
suffix:colon
id|desc_len
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;sending device desc, size=%d&quot;
comma
id|desc_len
)paren
suffix:semicolon
id|send_packet
c_func
(paren
id|dev
comma
id|alloc_packet
c_func
(paren
op_amp
id|dev-&gt;ep
(braket
l_int|0
)braket
comma
id|desc_len
comma
id|dev-&gt;dev_desc
)paren
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_DT_CONFIG
suffix:colon
singleline_comment|// If the config descr index in low-byte of
singleline_comment|// setup-&gt;wValue&t;is valid, send config descr,
singleline_comment|// otherwise stall ep0.
r_if
c_cond
(paren
(paren
id|le16_to_cpu
c_func
(paren
id|setup-&gt;wValue
)paren
op_amp
l_int|0xff
)paren
op_eq
l_int|0
)paren
(brace
singleline_comment|// send config descriptor!
r_if
c_cond
(paren
id|desc_len
op_le
id|USB_DT_CONFIG_SIZE
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;sending partial config desc, size=%d&quot;
comma
id|desc_len
)paren
suffix:semicolon
id|send_packet
c_func
(paren
id|dev
comma
id|alloc_packet
c_func
(paren
op_amp
id|dev-&gt;ep
(braket
l_int|0
)braket
comma
id|desc_len
comma
id|dev-&gt;conf_desc
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|len
op_assign
id|le16_to_cpu
c_func
(paren
id|dev-&gt;conf_desc-&gt;wTotalLength
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;sending whole config desc,&quot;
l_string|&quot; size=%d, our size=%d&quot;
comma
id|desc_len
comma
id|len
)paren
suffix:semicolon
id|desc_len
op_assign
id|desc_len
OG
id|len
ques
c_cond
id|len
suffix:colon
id|desc_len
suffix:semicolon
id|send_packet
c_func
(paren
id|dev
comma
id|alloc_packet
c_func
(paren
op_amp
id|dev-&gt;ep
(braket
l_int|0
)braket
comma
id|desc_len
comma
id|dev-&gt;full_conf_desc
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_else
id|endpoint_stall
c_func
(paren
op_amp
id|dev-&gt;ep
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_DT_STRING
suffix:colon
singleline_comment|// If the string descr index in low-byte of setup-&gt;wValue
singleline_comment|// is valid, send string descr, otherwise stall ep0.
id|strnum
op_assign
id|le16_to_cpu
c_func
(paren
id|setup-&gt;wValue
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|strnum
op_ge
l_int|0
op_logical_and
id|strnum
OL
l_int|6
)paren
(brace
r_struct
id|usb_string_descriptor
op_star
id|desc
op_assign
id|dev-&gt;str_desc
(braket
id|strnum
)braket
suffix:semicolon
id|desc_len
op_assign
id|desc_len
OG
id|desc-&gt;bLength
ques
c_cond
id|desc-&gt;bLength
suffix:colon
id|desc_len
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;sending string desc %d&quot;
comma
id|strnum
)paren
suffix:semicolon
id|send_packet
c_func
(paren
id|dev
comma
id|alloc_packet
c_func
(paren
op_amp
id|dev-&gt;ep
(braket
l_int|0
)braket
comma
id|desc_len
comma
id|desc
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
id|endpoint_stall
c_func
(paren
op_amp
id|dev-&gt;ep
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
singleline_comment|// Invalid request
id|err
c_func
(paren
l_string|&quot;invalid get desc=%d, stalled&quot;
comma
id|le16_to_cpu
c_func
(paren
id|setup-&gt;wValue
)paren
op_rshift
l_int|8
)paren
suffix:semicolon
id|endpoint_stall
c_func
(paren
op_amp
id|dev-&gt;ep
(braket
l_int|0
)braket
)paren
suffix:semicolon
singleline_comment|// Stall endpoint 0
r_break
suffix:semicolon
)brace
r_return
id|STATUS_STAGE
suffix:semicolon
)brace
r_static
id|ep0_stage_t
DECL|function|do_set_descriptor
id|do_set_descriptor
c_func
(paren
r_struct
id|usb_dev
op_star
id|dev
comma
r_struct
id|usb_ctrlrequest
op_star
id|setup
)paren
(brace
singleline_comment|// TODO: implement
singleline_comment|// there will be an OUT data stage (the descriptor to set)
r_return
id|DATA_STAGE
suffix:semicolon
)brace
r_static
id|ep0_stage_t
DECL|function|do_get_configuration
id|do_get_configuration
c_func
(paren
r_struct
id|usb_dev
op_star
id|dev
comma
r_struct
id|usb_ctrlrequest
op_star
id|setup
)paren
(brace
singleline_comment|// send dev-&gt;configuration
id|dbg
c_func
(paren
l_string|&quot;sending config&quot;
)paren
suffix:semicolon
id|send_packet
c_func
(paren
id|dev
comma
id|alloc_packet
c_func
(paren
op_amp
id|dev-&gt;ep
(braket
l_int|0
)braket
comma
l_int|1
comma
op_amp
id|dev-&gt;configuration
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
id|STATUS_STAGE
suffix:semicolon
)brace
r_static
id|ep0_stage_t
DECL|function|do_set_configuration
id|do_set_configuration
c_func
(paren
r_struct
id|usb_dev
op_star
id|dev
comma
r_struct
id|usb_ctrlrequest
op_star
id|setup
)paren
(brace
singleline_comment|// set active config to low-byte of setup-&gt;wValue
id|dev-&gt;configuration
op_assign
id|le16_to_cpu
c_func
(paren
id|setup-&gt;wValue
)paren
op_amp
l_int|0xff
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;set config, config=%d&quot;
comma
id|dev-&gt;configuration
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;configuration
op_logical_and
id|dev-&gt;state
OG
id|DEFAULT
)paren
(brace
id|dev-&gt;state
op_assign
id|ADDRESS
suffix:semicolon
multiline_comment|/* inform function layer of usbdev state change */
id|dev
op_member_access_from_pointer
id|func_cb
c_func
(paren
id|CB_NEW_STATE
comma
id|dev-&gt;state
comma
id|dev-&gt;cb_data
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;configuration
op_eq
l_int|1
)paren
(brace
id|dev-&gt;state
op_assign
id|CONFIGURED
suffix:semicolon
multiline_comment|/* inform function layer of usbdev state change */
id|dev
op_member_access_from_pointer
id|func_cb
c_func
(paren
id|CB_NEW_STATE
comma
id|dev-&gt;state
comma
id|dev-&gt;cb_data
)paren
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// FIXME: &quot;respond with request error&quot; - how?
)brace
r_return
id|SETUP_STAGE
suffix:semicolon
)brace
r_static
id|ep0_stage_t
DECL|function|do_get_interface
id|do_get_interface
c_func
(paren
r_struct
id|usb_dev
op_star
id|dev
comma
r_struct
id|usb_ctrlrequest
op_star
id|setup
)paren
(brace
singleline_comment|// interface must be zero.
r_if
c_cond
(paren
(paren
id|le16_to_cpu
c_func
(paren
id|setup-&gt;wIndex
)paren
op_amp
l_int|0xff
)paren
op_logical_or
id|dev-&gt;state
op_eq
id|ADDRESS
)paren
(brace
singleline_comment|// FIXME: respond with &quot;request error&quot;. how?
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;state
op_eq
id|CONFIGURED
)paren
(brace
singleline_comment|// send dev-&gt;alternate_setting
id|dbg
c_func
(paren
l_string|&quot;sending alt setting&quot;
)paren
suffix:semicolon
id|send_packet
c_func
(paren
id|dev
comma
id|alloc_packet
c_func
(paren
op_amp
id|dev-&gt;ep
(braket
l_int|0
)braket
comma
l_int|1
comma
op_amp
id|dev-&gt;alternate_setting
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|STATUS_STAGE
suffix:semicolon
)brace
r_static
id|ep0_stage_t
DECL|function|do_set_interface
id|do_set_interface
c_func
(paren
r_struct
id|usb_dev
op_star
id|dev
comma
r_struct
id|usb_ctrlrequest
op_star
id|setup
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;state
op_eq
id|ADDRESS
)paren
(brace
singleline_comment|// FIXME: respond with &quot;request error&quot;. how?
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;state
op_eq
id|CONFIGURED
)paren
(brace
id|dev-&gt;interface
op_assign
id|le16_to_cpu
c_func
(paren
id|setup-&gt;wIndex
)paren
op_amp
l_int|0xff
suffix:semicolon
id|dev-&gt;alternate_setting
op_assign
id|le16_to_cpu
c_func
(paren
id|setup-&gt;wValue
)paren
op_amp
l_int|0xff
suffix:semicolon
singleline_comment|// interface and alternate_setting must be zero
r_if
c_cond
(paren
id|dev-&gt;interface
op_logical_or
id|dev-&gt;alternate_setting
)paren
(brace
singleline_comment|// FIXME: respond with &quot;request error&quot;. how?
)brace
)brace
r_return
id|SETUP_STAGE
suffix:semicolon
)brace
r_static
id|ep0_stage_t
DECL|function|do_synch_frame
id|do_synch_frame
c_func
(paren
r_struct
id|usb_dev
op_star
id|dev
comma
r_struct
id|usb_ctrlrequest
op_star
id|setup
)paren
(brace
singleline_comment|// TODO
r_return
id|SETUP_STAGE
suffix:semicolon
)brace
DECL|typedef|req_method_t
r_typedef
id|ep0_stage_t
(paren
op_star
id|req_method_t
)paren
(paren
r_struct
id|usb_dev
op_star
id|dev
comma
r_struct
id|usb_ctrlrequest
op_star
id|setup
)paren
suffix:semicolon
multiline_comment|/* Table of the standard device request handlers */
DECL|variable|req_method
r_static
r_const
id|req_method_t
id|req_method
(braket
)braket
op_assign
(brace
id|do_get_status
comma
id|do_clear_feature
comma
id|do_reserved
comma
id|do_set_feature
comma
id|do_reserved
comma
id|do_set_address
comma
id|do_get_descriptor
comma
id|do_set_descriptor
comma
id|do_get_configuration
comma
id|do_set_configuration
comma
id|do_get_interface
comma
id|do_set_interface
comma
id|do_synch_frame
)brace
suffix:semicolon
singleline_comment|// SETUP packet request dispatcher
r_static
r_void
DECL|function|do_setup
id|do_setup
(paren
r_struct
id|usb_dev
op_star
id|dev
comma
r_struct
id|usb_ctrlrequest
op_star
id|setup
)paren
(brace
id|req_method_t
id|m
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: req %d %s&quot;
comma
id|__FUNCTION__
comma
id|setup-&gt;bRequestType
comma
id|get_std_req_name
c_func
(paren
id|setup-&gt;bRequestType
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|setup-&gt;bRequestType
op_amp
id|USB_TYPE_MASK
)paren
op_ne
id|USB_TYPE_STANDARD
op_logical_or
(paren
id|setup-&gt;bRequestType
op_amp
id|USB_RECIP_MASK
)paren
op_ne
id|USB_RECIP_DEVICE
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: invalid requesttype 0x%02x&quot;
comma
id|__FUNCTION__
comma
id|setup-&gt;bRequestType
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|setup-&gt;bRequestType
op_amp
l_int|0x80
)paren
op_eq
id|USB_DIR_OUT
op_logical_and
id|setup-&gt;wLength
)paren
id|dbg
c_func
(paren
l_string|&quot;%s: OUT phase! length=%d&quot;
comma
id|__FUNCTION__
comma
id|setup-&gt;wLength
)paren
suffix:semicolon
r_if
c_cond
(paren
id|setup-&gt;bRequestType
OL
r_sizeof
(paren
id|req_method
)paren
op_div
r_sizeof
(paren
id|req_method_t
)paren
)paren
id|m
op_assign
id|req_method
(braket
id|setup-&gt;bRequestType
)braket
suffix:semicolon
r_else
id|m
op_assign
id|do_reserved
suffix:semicolon
id|dev-&gt;ep0_stage
op_assign
(paren
op_star
id|m
)paren
(paren
id|dev
comma
id|setup
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * A SETUP, DATA0, or DATA1 packet has been received&n; * on the default control endpoint&squot;s fifo.&n; */
r_static
r_void
DECL|function|process_ep0_receive
id|process_ep0_receive
(paren
r_struct
id|usb_dev
op_star
id|dev
)paren
(brace
id|endpoint_t
op_star
id|ep0
op_assign
op_amp
id|dev-&gt;ep
(braket
l_int|0
)braket
suffix:semicolon
id|usbdev_pkt_t
op_star
id|pkt
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|ep0-&gt;lock
)paren
suffix:semicolon
singleline_comment|// complete packet and prepare a new packet
id|pkt
op_assign
id|receive_packet_complete
c_func
(paren
id|ep0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pkt
)paren
(brace
singleline_comment|// FIXME: should  put a warn/err here.
id|spin_unlock
c_func
(paren
op_amp
id|ep0-&gt;lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
singleline_comment|// unlink immediately from endpoint.
id|unlink_head
c_func
(paren
op_amp
id|ep0-&gt;outlist
)paren
suffix:semicolon
singleline_comment|// override current stage if h/w says it&squot;s a setup packet
r_if
c_cond
(paren
id|pkt-&gt;status
op_amp
id|PKT_STATUS_SU
)paren
id|dev-&gt;ep0_stage
op_assign
id|SETUP_STAGE
suffix:semicolon
r_switch
c_cond
(paren
id|dev-&gt;ep0_stage
)paren
(brace
r_case
id|SETUP_STAGE
suffix:colon
id|vdbg
c_func
(paren
l_string|&quot;SU bit is %s in setup stage&quot;
comma
(paren
id|pkt-&gt;status
op_amp
id|PKT_STATUS_SU
)paren
ques
c_cond
l_string|&quot;set&quot;
suffix:colon
l_string|&quot;not set&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt-&gt;size
op_eq
r_sizeof
(paren
r_struct
id|usb_ctrlrequest
)paren
)paren
(brace
macro_line|#ifdef VDEBUG
r_if
c_cond
(paren
id|pkt-&gt;status
op_amp
id|PKT_STATUS_ACK
)paren
id|vdbg
c_func
(paren
l_string|&quot;received SETUP&quot;
)paren
suffix:semicolon
r_else
id|vdbg
c_func
(paren
l_string|&quot;received NAK SETUP&quot;
)paren
suffix:semicolon
macro_line|#endif
id|do_setup
c_func
(paren
id|dev
comma
(paren
r_struct
id|usb_ctrlrequest
op_star
)paren
id|pkt-&gt;payload
)paren
suffix:semicolon
)brace
r_else
id|err
c_func
(paren
l_string|&quot;%s: wrong size SETUP received&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DATA_STAGE
suffix:colon
multiline_comment|/*&n;&t;&t; * this setup has an OUT data stage. Of the standard&n;&t;&t; * device requests, only set_descriptor has this stage,&n;&t;&t; * so this packet is that descriptor. TODO: drop it for&n;&t;&t; * now, set_descriptor not implemented.&n;&t;&t; *&n;&t;&t; * Need to place a byte in the write FIFO here, to prepare&n;&t;&t; * to send a zero-length DATA ack packet to the host in the&n;&t;&t; * STATUS stage.&n;&t;&t; */
id|au_writel
c_func
(paren
l_int|0
comma
id|ep0-&gt;reg-&gt;write_fifo
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;received OUT stage DATAx on EP0, size=%d&quot;
comma
id|pkt-&gt;size
)paren
suffix:semicolon
id|dev-&gt;ep0_stage
op_assign
id|SETUP_STAGE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STATUS_STAGE
suffix:colon
singleline_comment|// this setup had an IN data stage, and host is ACK&squot;ing
singleline_comment|// the packet we sent during that stage.
r_if
c_cond
(paren
id|pkt-&gt;size
op_ne
l_int|0
)paren
id|warn
c_func
(paren
l_string|&quot;received non-zero ACK on EP0??&quot;
)paren
suffix:semicolon
macro_line|#ifdef VDEBUG
r_else
id|vdbg
c_func
(paren
l_string|&quot;received ACK on EP0&quot;
)paren
suffix:semicolon
macro_line|#endif
id|dev-&gt;ep0_stage
op_assign
id|SETUP_STAGE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|ep0-&gt;lock
)paren
suffix:semicolon
singleline_comment|// we&squot;re done processing the packet, free it
id|kfree
c_func
(paren
id|pkt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * A DATA0/1 packet has been received on one of the OUT endpoints (4 or 5)&n; */
r_static
r_void
DECL|function|process_ep_receive
id|process_ep_receive
(paren
r_struct
id|usb_dev
op_star
id|dev
comma
id|endpoint_t
op_star
id|ep
)paren
(brace
id|usbdev_pkt_t
op_star
id|pkt
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|ep-&gt;lock
)paren
suffix:semicolon
id|pkt
op_assign
id|receive_packet_complete
c_func
(paren
id|ep
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ep-&gt;lock
)paren
suffix:semicolon
id|dev
op_member_access_from_pointer
id|func_cb
c_func
(paren
id|CB_PKT_COMPLETE
comma
(paren
r_int
r_int
)paren
id|pkt
comma
id|dev-&gt;cb_data
)paren
suffix:semicolon
)brace
multiline_comment|/* This ISR handles the receive complete and suspend events */
r_static
r_void
DECL|function|req_sus_intr
id|req_sus_intr
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|usb_dev
op_star
id|dev
op_assign
(paren
r_struct
id|usb_dev
op_star
)paren
id|dev_id
suffix:semicolon
id|u32
id|status
suffix:semicolon
id|status
op_assign
id|au_readl
c_func
(paren
id|USBD_INTSTAT
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|status
comma
id|USBD_INTSTAT
)paren
suffix:semicolon
singleline_comment|// ack&squot;em
r_if
c_cond
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
l_int|0
)paren
)paren
id|process_ep0_receive
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
l_int|4
)paren
)paren
id|process_ep_receive
c_func
(paren
id|dev
comma
op_amp
id|dev-&gt;ep
(braket
l_int|4
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
l_int|5
)paren
)paren
id|process_ep_receive
c_func
(paren
id|dev
comma
op_amp
id|dev-&gt;ep
(braket
l_int|5
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* This ISR handles the DMA done events on EP0 */
r_static
r_void
DECL|function|dma_done_ep0_intr
id|dma_done_ep0_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|usb_dev
op_star
id|dev
op_assign
(paren
r_struct
id|usb_dev
op_star
)paren
id|dev_id
suffix:semicolon
id|usbdev_pkt_t
op_star
id|pkt
suffix:semicolon
id|endpoint_t
op_star
id|ep0
op_assign
op_amp
id|dev-&gt;ep
(braket
l_int|0
)braket
suffix:semicolon
id|u32
id|cs0
comma
id|buff_done
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|ep0-&gt;lock
)paren
suffix:semicolon
id|cs0
op_assign
id|au_readl
c_func
(paren
id|ep0-&gt;reg-&gt;ctrl_stat
)paren
suffix:semicolon
singleline_comment|// first check packet transmit done
r_if
c_cond
(paren
(paren
id|buff_done
op_assign
id|get_dma_buffer_done
c_func
(paren
id|ep0-&gt;indma
)paren
)paren
op_ne
l_int|0
)paren
(brace
singleline_comment|// transmitted a DATAx packet during DATA stage
singleline_comment|// on control endpoint 0
singleline_comment|// clear DMA done bit
r_if
c_cond
(paren
id|buff_done
op_amp
id|DMA_D0
)paren
id|clear_dma_done0
c_func
(paren
id|ep0-&gt;indma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff_done
op_amp
id|DMA_D1
)paren
id|clear_dma_done1
c_func
(paren
id|ep0-&gt;indma
)paren
suffix:semicolon
id|pkt
op_assign
id|send_packet_complete
c_func
(paren
id|ep0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt
)paren
id|kfree
c_func
(paren
id|pkt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now check packet receive done. Shouldn&squot;t get these,&n;&t; * the receive packet complete intr should happen&n;&t; * before the DMA done intr occurs.&n;&t; */
r_if
c_cond
(paren
(paren
id|buff_done
op_assign
id|get_dma_buffer_done
c_func
(paren
id|ep0-&gt;outdma
)paren
)paren
op_ne
l_int|0
)paren
(brace
singleline_comment|// clear DMA done bit
r_if
c_cond
(paren
id|buff_done
op_amp
id|DMA_D0
)paren
id|clear_dma_done0
c_func
(paren
id|ep0-&gt;outdma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff_done
op_amp
id|DMA_D1
)paren
id|clear_dma_done1
c_func
(paren
id|ep0-&gt;outdma
)paren
suffix:semicolon
singleline_comment|//process_ep0_receive(dev);
)brace
id|spin_unlock
c_func
(paren
op_amp
id|ep0-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/* This ISR handles the DMA done events on endpoints 2,3,4,5 */
r_static
r_void
DECL|function|dma_done_ep_intr
id|dma_done_ep_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|usb_dev
op_star
id|dev
op_assign
(paren
r_struct
id|usb_dev
op_star
)paren
id|dev_id
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|2
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|u32
id|buff_done
suffix:semicolon
id|usbdev_pkt_t
op_star
id|pkt
suffix:semicolon
id|endpoint_t
op_star
id|ep
op_assign
op_amp
id|dev-&gt;ep
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;active
)paren
r_continue
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|ep-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;direction
op_eq
id|USB_DIR_IN
)paren
(brace
id|buff_done
op_assign
id|get_dma_buffer_done
c_func
(paren
id|ep-&gt;indma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff_done
op_ne
l_int|0
)paren
(brace
singleline_comment|// transmitted a DATAx pkt on the IN ep
singleline_comment|// clear DMA done bit
r_if
c_cond
(paren
id|buff_done
op_amp
id|DMA_D0
)paren
id|clear_dma_done0
c_func
(paren
id|ep-&gt;indma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff_done
op_amp
id|DMA_D1
)paren
id|clear_dma_done1
c_func
(paren
id|ep-&gt;indma
)paren
suffix:semicolon
id|pkt
op_assign
id|send_packet_complete
c_func
(paren
id|ep
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ep-&gt;lock
)paren
suffix:semicolon
id|dev
op_member_access_from_pointer
id|func_cb
c_func
(paren
id|CB_PKT_COMPLETE
comma
(paren
r_int
r_int
)paren
id|pkt
comma
id|dev-&gt;cb_data
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|ep-&gt;lock
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Check packet receive done (OUT ep). Shouldn&squot;t get&n;&t;&t;&t; * these, the rx packet complete intr should happen&n;&t; * before the DMA done intr occurs.&n;&t; */
id|buff_done
op_assign
id|get_dma_buffer_done
c_func
(paren
id|ep-&gt;outdma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff_done
op_ne
l_int|0
)paren
(brace
singleline_comment|// received a DATAx pkt on the OUT ep
singleline_comment|// clear DMA done bit
r_if
c_cond
(paren
id|buff_done
op_amp
id|DMA_D0
)paren
id|clear_dma_done0
c_func
(paren
id|ep-&gt;outdma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff_done
op_amp
id|DMA_D1
)paren
id|clear_dma_done1
c_func
(paren
id|ep-&gt;outdma
)paren
suffix:semicolon
singleline_comment|//process_ep_receive(dev, ep);
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|ep-&gt;lock
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/***************************************************************************&n; * Here begins the external interface functions&n; ***************************************************************************&n; */
multiline_comment|/*&n; * allocate a new packet&n; */
r_int
DECL|function|usbdev_alloc_packet
id|usbdev_alloc_packet
c_func
(paren
r_int
id|ep_addr
comma
r_int
id|data_size
comma
id|usbdev_pkt_t
op_star
op_star
id|pkt
)paren
(brace
id|endpoint_t
op_star
id|ep
op_assign
id|epaddr_to_ep
c_func
(paren
op_amp
id|usbdev
comma
id|ep_addr
)paren
suffix:semicolon
id|usbdev_pkt_t
op_star
id|lpkt
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
op_logical_or
op_logical_neg
id|ep-&gt;active
op_logical_or
id|ep-&gt;address
OL
l_int|2
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|data_size
OG
id|ep-&gt;max_pkt_size
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|lpkt
op_assign
op_star
id|pkt
op_assign
id|alloc_packet
c_func
(paren
id|ep
comma
id|data_size
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lpkt
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * packet send&n; */
r_int
DECL|function|usbdev_send_packet
id|usbdev_send_packet
c_func
(paren
r_int
id|ep_addr
comma
id|usbdev_pkt_t
op_star
id|pkt
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|count
suffix:semicolon
id|endpoint_t
op_star
id|ep
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pkt
op_logical_or
op_logical_neg
(paren
id|ep
op_assign
id|epaddr_to_ep
c_func
(paren
op_amp
id|usbdev
comma
id|pkt-&gt;ep_addr
)paren
)paren
op_logical_or
op_logical_neg
id|ep-&gt;active
op_logical_or
id|ep-&gt;address
OL
l_int|2
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;direction
op_ne
id|USB_DIR_IN
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|count
op_assign
id|send_packet
c_func
(paren
op_amp
id|usbdev
comma
id|pkt
comma
l_int|1
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*&n; * packet receive&n; */
r_int
DECL|function|usbdev_receive_packet
id|usbdev_receive_packet
c_func
(paren
r_int
id|ep_addr
comma
id|usbdev_pkt_t
op_star
op_star
id|pkt
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|usbdev_pkt_t
op_star
id|lpkt
op_assign
l_int|NULL
suffix:semicolon
id|endpoint_t
op_star
id|ep
op_assign
id|epaddr_to_ep
c_func
(paren
op_amp
id|usbdev
comma
id|ep_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
op_logical_or
op_logical_neg
id|ep-&gt;active
op_logical_or
id|ep-&gt;address
OL
l_int|2
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;direction
op_ne
id|USB_DIR_OUT
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;outlist.count
OG
l_int|1
)paren
id|lpkt
op_assign
id|unlink_head
c_func
(paren
op_amp
id|ep-&gt;outlist
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lpkt
)paren
(brace
multiline_comment|/* no packet available */
op_star
id|pkt
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ENODATA
suffix:semicolon
)brace
op_star
id|pkt
op_assign
id|lpkt
suffix:semicolon
r_return
id|lpkt-&gt;size
suffix:semicolon
)brace
multiline_comment|/*&n; * return total queued byte count on the endpoint.&n; */
r_int
DECL|function|usbdev_get_byte_count
id|usbdev_get_byte_count
c_func
(paren
r_int
id|ep_addr
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|pkt_list_t
op_star
id|list
suffix:semicolon
id|usbdev_pkt_t
op_star
id|scan
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|endpoint_t
op_star
id|ep
op_assign
id|epaddr_to_ep
c_func
(paren
op_amp
id|usbdev
comma
id|ep_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
op_logical_or
op_logical_neg
id|ep-&gt;active
op_logical_or
id|ep-&gt;address
OL
l_int|2
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;direction
op_eq
id|USB_DIR_IN
)paren
(brace
id|list
op_assign
op_amp
id|ep-&gt;inlist
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|scan
op_assign
id|list-&gt;head
suffix:semicolon
id|scan
suffix:semicolon
id|scan
op_assign
id|scan-&gt;next
)paren
id|count
op_add_assign
id|scan-&gt;size
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|list
op_assign
op_amp
id|ep-&gt;outlist
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list-&gt;count
OG
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|scan
op_assign
id|list-&gt;head
suffix:semicolon
id|scan
op_ne
id|list-&gt;tail
suffix:semicolon
id|scan
op_assign
id|scan-&gt;next
)paren
id|count
op_add_assign
id|scan-&gt;size
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
r_void
DECL|function|usbdev_exit
id|usbdev_exit
c_func
(paren
r_void
)paren
(brace
id|endpoint_t
op_star
id|ep
suffix:semicolon
r_int
id|i
suffix:semicolon
id|au_writel
c_func
(paren
l_int|0
comma
id|USBD_INTEN
)paren
suffix:semicolon
singleline_comment|// disable usb dev ints
id|au_writel
c_func
(paren
l_int|0
comma
id|USBD_ENABLE
)paren
suffix:semicolon
singleline_comment|// disable usb dev
id|free_irq
c_func
(paren
id|AU1000_USB_DEV_REQ_INT
comma
op_amp
id|usbdev
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|AU1000_USB_DEV_SUS_INT
comma
op_amp
id|usbdev
)paren
suffix:semicolon
singleline_comment|// free all control endpoint resources
id|ep
op_assign
op_amp
id|usbdev.ep
(braket
l_int|0
)braket
suffix:semicolon
id|free_au1000_dma
c_func
(paren
id|ep-&gt;indma
)paren
suffix:semicolon
id|free_au1000_dma
c_func
(paren
id|ep-&gt;outdma
)paren
suffix:semicolon
id|endpoint_flush
c_func
(paren
id|ep
)paren
suffix:semicolon
singleline_comment|// free ep resources
r_for
c_loop
(paren
id|i
op_assign
l_int|2
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ep
op_assign
op_amp
id|usbdev.ep
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;active
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;direction
op_eq
id|USB_DIR_IN
)paren
(brace
id|free_au1000_dma
c_func
(paren
id|ep-&gt;indma
)paren
suffix:semicolon
)brace
r_else
(brace
id|free_au1000_dma
c_func
(paren
id|ep-&gt;outdma
)paren
suffix:semicolon
)brace
id|endpoint_flush
c_func
(paren
id|ep
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usbdev.full_conf_desc
)paren
id|kfree
c_func
(paren
id|usbdev.full_conf_desc
)paren
suffix:semicolon
)brace
r_int
DECL|function|usbdev_init
id|usbdev_init
c_func
(paren
r_struct
id|usb_device_descriptor
op_star
id|dev_desc
comma
r_struct
id|usb_config_descriptor
op_star
id|config_desc
comma
r_struct
id|usb_interface_descriptor
op_star
id|if_desc
comma
r_struct
id|usb_endpoint_descriptor
op_star
id|ep_desc
comma
r_struct
id|usb_string_descriptor
op_star
id|str_desc
(braket
)braket
comma
r_void
(paren
op_star
id|cb
)paren
(paren
id|usbdev_cb_type_t
comma
r_int
r_int
comma
r_void
op_star
)paren
comma
r_void
op_star
id|cb_data
)paren
(brace
id|endpoint_t
op_star
id|ep0
suffix:semicolon
r_int
id|i
comma
id|ret
op_assign
l_int|0
suffix:semicolon
id|u8
op_star
id|fcd
suffix:semicolon
r_if
c_cond
(paren
id|dev_desc-&gt;bNumConfigurations
OG
l_int|1
op_logical_or
id|config_desc-&gt;bNumInterfaces
OG
l_int|1
op_logical_or
id|if_desc-&gt;bNumEndpoints
OG
l_int|4
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Only one config, one i/f, and no more &quot;
l_string|&quot;than 4 ep&squot;s allowed&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cb
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Function-layer callback required&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev_desc-&gt;bMaxPacketSize0
op_ne
id|USBDEV_EP0_MAX_PACKET_SIZE
)paren
(brace
id|warn
c_func
(paren
l_string|&quot;EP0 Max Packet size must be %d&quot;
comma
id|USBDEV_EP0_MAX_PACKET_SIZE
)paren
suffix:semicolon
id|dev_desc-&gt;bMaxPacketSize0
op_assign
id|USBDEV_EP0_MAX_PACKET_SIZE
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|usbdev
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|usb_dev
)paren
)paren
suffix:semicolon
id|usbdev.state
op_assign
id|DEFAULT
suffix:semicolon
id|usbdev.dev_desc
op_assign
id|dev_desc
suffix:semicolon
id|usbdev.if_desc
op_assign
id|if_desc
suffix:semicolon
id|usbdev.conf_desc
op_assign
id|config_desc
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|usbdev.str_desc
(braket
id|i
)braket
op_assign
id|str_desc
(braket
id|i
)braket
suffix:semicolon
id|usbdev.func_cb
op_assign
id|cb
suffix:semicolon
id|usbdev.cb_data
op_assign
id|cb_data
suffix:semicolon
multiline_comment|/* Initialize default control endpoint */
id|ep0
op_assign
op_amp
id|usbdev.ep
(braket
l_int|0
)braket
suffix:semicolon
id|ep0-&gt;active
op_assign
l_int|1
suffix:semicolon
id|ep0-&gt;type
op_assign
id|CONTROL_EP
suffix:semicolon
id|ep0-&gt;max_pkt_size
op_assign
id|USBDEV_EP0_MAX_PACKET_SIZE
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|ep0-&gt;lock
)paren
suffix:semicolon
id|ep0-&gt;desc
op_assign
l_int|NULL
suffix:semicolon
singleline_comment|// ep0 has no descriptor
id|ep0-&gt;address
op_assign
l_int|0
suffix:semicolon
id|ep0-&gt;direction
op_assign
l_int|0
suffix:semicolon
id|ep0-&gt;reg
op_assign
op_amp
id|ep_reg
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Initialize the other requested endpoints */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|if_desc-&gt;bNumEndpoints
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|usb_endpoint_descriptor
op_star
id|epd
op_assign
op_amp
id|ep_desc
(braket
id|i
)braket
suffix:semicolon
id|endpoint_t
op_star
id|ep
suffix:semicolon
r_if
c_cond
(paren
(paren
id|epd-&gt;bEndpointAddress
op_amp
l_int|0x80
)paren
op_eq
id|USB_DIR_IN
)paren
(brace
id|ep
op_assign
op_amp
id|usbdev.ep
(braket
l_int|2
)braket
suffix:semicolon
id|ep-&gt;address
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;active
)paren
(brace
id|ep
op_assign
op_amp
id|usbdev.ep
(braket
l_int|3
)braket
suffix:semicolon
id|ep-&gt;address
op_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;active
)paren
(brace
id|err
c_func
(paren
l_string|&quot;too many IN ep&squot;s requested&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|ep
op_assign
op_amp
id|usbdev.ep
(braket
l_int|4
)braket
suffix:semicolon
id|ep-&gt;address
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;active
)paren
(brace
id|ep
op_assign
op_amp
id|usbdev.ep
(braket
l_int|5
)braket
suffix:semicolon
id|ep-&gt;address
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;active
)paren
(brace
id|err
c_func
(paren
l_string|&quot;too many OUT ep&squot;s requested&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
)brace
id|ep-&gt;active
op_assign
l_int|1
suffix:semicolon
id|epd-&gt;bEndpointAddress
op_and_assign
op_complement
l_int|0x0f
suffix:semicolon
id|epd-&gt;bEndpointAddress
op_or_assign
(paren
id|u8
)paren
id|ep-&gt;address
suffix:semicolon
id|ep-&gt;direction
op_assign
id|epd-&gt;bEndpointAddress
op_amp
l_int|0x80
suffix:semicolon
id|ep-&gt;type
op_assign
id|epd-&gt;bmAttributes
op_amp
l_int|0x03
suffix:semicolon
id|ep-&gt;max_pkt_size
op_assign
id|epd-&gt;wMaxPacketSize
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|ep-&gt;lock
)paren
suffix:semicolon
id|ep-&gt;desc
op_assign
id|epd
suffix:semicolon
id|ep-&gt;reg
op_assign
op_amp
id|ep_reg
(braket
id|ep-&gt;address
)braket
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * initialize the full config descriptor&n;&t; */
id|usbdev.full_conf_desc
op_assign
id|fcd
op_assign
id|kmalloc
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|config_desc-&gt;wTotalLength
)paren
comma
id|ALLOC_FLAGS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fcd
)paren
(brace
id|err
c_func
(paren
l_string|&quot;failed to alloc full config descriptor&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|fcd
comma
id|config_desc
comma
id|USB_DT_CONFIG_SIZE
)paren
suffix:semicolon
id|fcd
op_add_assign
id|USB_DT_CONFIG_SIZE
suffix:semicolon
id|memcpy
c_func
(paren
id|fcd
comma
id|if_desc
comma
id|USB_DT_INTERFACE_SIZE
)paren
suffix:semicolon
id|fcd
op_add_assign
id|USB_DT_INTERFACE_SIZE
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|if_desc-&gt;bNumEndpoints
suffix:semicolon
id|i
op_increment
)paren
(brace
id|memcpy
c_func
(paren
id|fcd
comma
op_amp
id|ep_desc
(braket
id|i
)braket
comma
id|USB_DT_ENDPOINT_SIZE
)paren
suffix:semicolon
id|fcd
op_add_assign
id|USB_DT_ENDPOINT_SIZE
suffix:semicolon
)brace
multiline_comment|/* Now we&squot;re ready to enable the controller */
id|au_writel
c_func
(paren
l_int|0x0002
comma
id|USBD_ENABLE
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|0x0003
comma
id|USBD_ENABLE
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* build and send config table based on ep descriptors */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|endpoint_t
op_star
id|ep
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|1
)paren
r_continue
suffix:semicolon
singleline_comment|// skip dummy ep
id|ep
op_assign
op_amp
id|usbdev.ep
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;active
)paren
(brace
id|au_writel
c_func
(paren
(paren
id|ep-&gt;address
op_lshift
l_int|4
)paren
op_or
l_int|0x04
comma
id|USBD_CONFIG
)paren
suffix:semicolon
id|au_writel
c_func
(paren
(paren
(paren
id|ep-&gt;max_pkt_size
op_amp
l_int|0x380
)paren
op_rshift
l_int|7
)paren
op_or
(paren
id|ep-&gt;direction
op_rshift
l_int|4
)paren
op_or
(paren
id|ep-&gt;type
op_lshift
l_int|4
)paren
comma
id|USBD_CONFIG
)paren
suffix:semicolon
id|au_writel
c_func
(paren
(paren
id|ep-&gt;max_pkt_size
op_amp
l_int|0x7f
)paren
op_lshift
l_int|1
comma
id|USBD_CONFIG
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|0x00
comma
id|USBD_CONFIG
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|ep-&gt;address
comma
id|USBD_CONFIG
)paren
suffix:semicolon
)brace
r_else
(brace
id|u8
id|dir
op_assign
(paren
id|i
op_eq
l_int|2
op_logical_or
id|i
op_eq
l_int|3
)paren
ques
c_cond
id|DIR_IN
suffix:colon
id|DIR_OUT
suffix:semicolon
id|au_writel
c_func
(paren
(paren
id|i
op_lshift
l_int|4
)paren
op_or
l_int|0x04
comma
id|USBD_CONFIG
)paren
suffix:semicolon
id|au_writel
c_func
(paren
(paren
(paren
l_int|16
op_amp
l_int|0x380
)paren
op_rshift
l_int|7
)paren
op_or
id|dir
op_or
(paren
id|BULK_EP
op_lshift
l_int|4
)paren
comma
id|USBD_CONFIG
)paren
suffix:semicolon
id|au_writel
c_func
(paren
(paren
l_int|16
op_amp
l_int|0x7f
)paren
op_lshift
l_int|1
comma
id|USBD_CONFIG
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|0x00
comma
id|USBD_CONFIG
)paren
suffix:semicolon
id|au_writel
c_func
(paren
id|i
comma
id|USBD_CONFIG
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Enable Receive FIFO Complete interrupts only. Transmit&n;&t; * complete is being handled by the DMA done interrupts.&n;&t; */
id|au_writel
c_func
(paren
l_int|0x31
comma
id|USBD_INTEN
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Controller is now enabled, request DMA and IRQ&n;&t; * resources.&n;&t; */
multiline_comment|/* request the USB device transfer complete interrupt */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|AU1000_USB_DEV_REQ_INT
comma
id|req_sus_intr
comma
id|SA_INTERRUPT
comma
l_string|&quot;USBdev req&quot;
comma
op_amp
id|usbdev
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Can&squot;t get device request intr&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* request the USB device suspend interrupt */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|AU1000_USB_DEV_SUS_INT
comma
id|req_sus_intr
comma
id|SA_INTERRUPT
comma
l_string|&quot;USBdev sus&quot;
comma
op_amp
id|usbdev
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Can&squot;t get device suspend intr&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Request EP0 DMA and IRQ */
r_if
c_cond
(paren
(paren
id|ep0-&gt;indma
op_assign
id|request_au1000_dma
c_func
(paren
id|ep_dma_id
(braket
l_int|0
)braket
dot
id|id
comma
id|ep_dma_id
(braket
l_int|0
)braket
dot
id|str
comma
id|dma_done_ep0_intr
comma
id|SA_INTERRUPT
comma
op_amp
id|usbdev
)paren
)paren
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Can&squot;t get %s DMA&quot;
comma
id|ep_dma_id
(braket
l_int|0
)braket
dot
id|str
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ep0-&gt;outdma
op_assign
id|request_au1000_dma
c_func
(paren
id|ep_dma_id
(braket
l_int|1
)braket
dot
id|id
comma
id|ep_dma_id
(braket
l_int|1
)braket
dot
id|str
comma
l_int|NULL
comma
l_int|0
comma
l_int|NULL
)paren
)paren
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Can&squot;t get %s DMA&quot;
comma
id|ep_dma_id
(braket
l_int|1
)braket
dot
id|str
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
singleline_comment|// Flush the ep0 buffers and FIFOs
id|endpoint_flush
c_func
(paren
id|ep0
)paren
suffix:semicolon
singleline_comment|// start packet reception on ep0
id|kickstart_receive_packet
c_func
(paren
id|ep0
)paren
suffix:semicolon
multiline_comment|/* Request DMA and IRQ for the other endpoints */
r_for
c_loop
(paren
id|i
op_assign
l_int|2
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|endpoint_t
op_star
id|ep
op_assign
op_amp
id|usbdev.ep
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;active
)paren
r_continue
suffix:semicolon
singleline_comment|// Flush the endpoint buffers and FIFOs
id|endpoint_flush
c_func
(paren
id|ep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;direction
op_eq
id|USB_DIR_IN
)paren
(brace
id|ep-&gt;indma
op_assign
id|request_au1000_dma
c_func
(paren
id|ep_dma_id
(braket
id|ep-&gt;address
)braket
dot
id|id
comma
id|ep_dma_id
(braket
id|ep-&gt;address
)braket
dot
id|str
comma
id|dma_done_ep_intr
comma
id|SA_INTERRUPT
comma
op_amp
id|usbdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;indma
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Can&squot;t get %s DMA&quot;
comma
id|ep_dma_id
(braket
id|ep-&gt;address
)braket
dot
id|str
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
(brace
id|ep-&gt;outdma
op_assign
id|request_au1000_dma
c_func
(paren
id|ep_dma_id
(braket
id|ep-&gt;address
)braket
dot
id|id
comma
id|ep_dma_id
(braket
id|ep-&gt;address
)braket
dot
id|str
comma
l_int|NULL
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;outdma
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Can&squot;t get %s DMA&quot;
comma
id|ep_dma_id
(braket
id|ep-&gt;address
)braket
dot
id|str
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
singleline_comment|// start packet reception on OUT endpoint
id|kickstart_receive_packet
c_func
(paren
id|ep
)paren
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_if
c_cond
(paren
id|ret
)paren
id|usbdev_exit
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|usbdev_init
id|EXPORT_SYMBOL
c_func
(paren
id|usbdev_init
)paren
suffix:semicolon
DECL|variable|usbdev_exit
id|EXPORT_SYMBOL
c_func
(paren
id|usbdev_exit
)paren
suffix:semicolon
DECL|variable|usbdev_alloc_packet
id|EXPORT_SYMBOL
c_func
(paren
id|usbdev_alloc_packet
)paren
suffix:semicolon
DECL|variable|usbdev_receive_packet
id|EXPORT_SYMBOL
c_func
(paren
id|usbdev_receive_packet
)paren
suffix:semicolon
DECL|variable|usbdev_send_packet
id|EXPORT_SYMBOL
c_func
(paren
id|usbdev_send_packet
)paren
suffix:semicolon
DECL|variable|usbdev_get_byte_count
id|EXPORT_SYMBOL
c_func
(paren
id|usbdev_get_byte_count
)paren
suffix:semicolon
eof
