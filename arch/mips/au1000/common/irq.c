multiline_comment|/*&n; * BRIEF MODULE DESCRIPTION&n; *&t;Au1000 interrupt routines.&n; *&n; * Copyright 2001 MontaVista Software Inc.&n; * Author: MontaVista Software, Inc.&n; *&t;&t;ppopov@mvista.com or source@mvista.com&n; *&n; *  This program is free software; you can redistribute&t; it and/or modify it&n; *  under  the terms of&t; the GNU General  Public License as published by the&n; *  Free Software Foundation;  either version 2 of the&t;License, or (at your&n; *  option) any later version.&n; *&n; *  THIS  SOFTWARE  IS PROVIDED&t;  ``AS&t;IS&squot;&squot; AND   ANY&t;EXPRESS OR IMPLIED&n; *  WARRANTIES,&t;  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF&n; *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN&n; *  NO&t;EVENT  SHALL   THE AUTHOR  BE&t; LIABLE FOR ANY&t;  DIRECT, INDIRECT,&n; *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT&n; *  NOT LIMITED&t;  TO, PROCUREMENT OF  SUBSTITUTE GOODS&t;OR SERVICES; LOSS OF&n; *  USE, DATA,&t;OR PROFITS; OR&t;BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON&n; *  ANY THEORY OF LIABILITY, WHETHER IN&t; CONTRACT, STRICT LIABILITY, OR TORT&n; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF&n; *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; *&n; *  You should have received a copy of the  GNU General Public License along&n; *  with this program; if not, write  to the Free Software Foundation, Inc.,&n; *  675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/mipsregs.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/au1000.h&gt;
macro_line|#if defined(CONFIG_MIPS_PB1000)
macro_line|#include &lt;asm/pb1000.h&gt;
macro_line|#elif defined(CONFIG_MIPS_PB1500)
macro_line|#include &lt;asm/pb1500.h&gt;
macro_line|#elif defined(CONFIG_MIPS_PB1100)
macro_line|#include &lt;asm/pb1100.h&gt;
macro_line|#elif defined(CONFIG_MIPS_DB1000)
macro_line|#include &lt;asm/db1x00.h&gt;
macro_line|#elif defined(CONFIG_MIPS_DB1100)
macro_line|#include &lt;asm/db1x00.h&gt;
macro_line|#elif defined(CONFIG_MIPS_DB1500)
macro_line|#include &lt;asm/db1x00.h&gt;
macro_line|#else
macro_line|#error unsupported Alchemy board
macro_line|#endif
DECL|macro|DEBUG_IRQ
macro_line|#undef DEBUG_IRQ
macro_line|#ifdef DEBUG_IRQ
multiline_comment|/* note: prints function name for you */
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(fmt, args...) printk(&quot;%s: &quot; fmt, __FUNCTION__ , ## args)
macro_line|#else
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(fmt, args...)
macro_line|#endif
DECL|macro|EXT_INTC0_REQ0
mdefine_line|#define EXT_INTC0_REQ0 2 /* IP 2 */
DECL|macro|EXT_INTC0_REQ1
mdefine_line|#define EXT_INTC0_REQ1 3 /* IP 3 */
DECL|macro|EXT_INTC1_REQ0
mdefine_line|#define EXT_INTC1_REQ0 4 /* IP 4 */
DECL|macro|EXT_INTC1_REQ1
mdefine_line|#define EXT_INTC1_REQ1 5 /* IP 5 */
DECL|macro|MIPS_TIMER_IP
mdefine_line|#define MIPS_TIMER_IP  7 /* IP 7 */
macro_line|#ifdef CONFIG_KGDB
r_extern
r_void
id|breakpoint
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
r_extern
id|asmlinkage
r_void
id|au1000_IRQ
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|set_debug_traps
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|irq_cpustat_t
id|irq_stat
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|variable|local_bh_count
r_int
r_int
id|local_bh_count
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|variable|local_irq_count
r_int
r_int
id|local_irq_count
(braket
id|NR_CPUS
)braket
suffix:semicolon
r_static
r_void
id|setup_local_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_int
id|type
comma
r_int
id|int_req
)paren
suffix:semicolon
r_static
r_int
r_int
id|startup_irq
c_func
(paren
r_int
r_int
id|irq
)paren
suffix:semicolon
r_static
r_void
id|end_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
suffix:semicolon
r_static
r_inline
r_void
id|mask_and_ack_level_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
suffix:semicolon
r_static
r_inline
r_void
id|mask_and_ack_rise_edge_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
suffix:semicolon
r_static
r_inline
r_void
id|mask_and_ack_fall_edge_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
suffix:semicolon
r_inline
r_void
id|local_enable_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
suffix:semicolon
r_inline
r_void
id|local_disable_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
suffix:semicolon
r_extern
r_void
id|__init
id|init_generic_irq
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PM
r_extern
r_void
id|counter0_irq
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|irq_lock
r_static
id|spinlock_t
id|irq_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|setup_local_irq
r_static
r_void
id|setup_local_irq
c_func
(paren
r_int
r_int
id|irq_nr
comma
r_int
id|type
comma
r_int
id|int_req
)paren
(brace
r_if
c_cond
(paren
id|irq_nr
OG
id|AU1000_MAX_INTR
)paren
r_return
suffix:semicolon
multiline_comment|/* Config2[n], Config1[n], Config0[n] */
r_if
c_cond
(paren
id|irq_nr
OG
id|AU1000_LAST_INTC0_INT
)paren
(brace
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|INTC_INT_RISE_EDGE
suffix:colon
multiline_comment|/* 0:0:1 */
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_CFG2CLR
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_CFG1CLR
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_CFG0SET
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INTC_INT_FALL_EDGE
suffix:colon
multiline_comment|/* 0:1:0 */
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_CFG2CLR
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_CFG1SET
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_CFG0CLR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INTC_INT_HIGH_LEVEL
suffix:colon
multiline_comment|/* 1:0:1 */
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_CFG2SET
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_CFG1CLR
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_CFG0SET
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INTC_INT_LOW_LEVEL
suffix:colon
multiline_comment|/* 1:1:0 */
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_CFG2SET
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_CFG1SET
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_CFG0CLR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INTC_INT_DISABLED
suffix:colon
multiline_comment|/* 0:0:0 */
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_CFG0CLR
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_CFG1CLR
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_CFG2CLR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* disable the interrupt */
id|printk
c_func
(paren
l_string|&quot;unexpected int type %d (irq %d)&bslash;n&quot;
comma
id|type
comma
id|irq_nr
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_CFG0CLR
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_CFG1CLR
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_CFG2CLR
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|int_req
)paren
multiline_comment|/* assign to interrupt request 1 */
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_ASSIGNCLR
)paren
suffix:semicolon
r_else
multiline_comment|/* assign to interrupt request 0 */
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_ASSIGNSET
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_SRCSET
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_MASKCLR
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_WAKECLR
)paren
suffix:semicolon
)brace
r_else
(brace
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|INTC_INT_RISE_EDGE
suffix:colon
multiline_comment|/* 0:0:1 */
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_CFG2CLR
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_CFG1CLR
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_CFG0SET
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INTC_INT_FALL_EDGE
suffix:colon
multiline_comment|/* 0:1:0 */
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_CFG2CLR
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_CFG1SET
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_CFG0CLR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INTC_INT_HIGH_LEVEL
suffix:colon
multiline_comment|/* 1:0:1 */
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_CFG2SET
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_CFG1CLR
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_CFG0SET
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INTC_INT_LOW_LEVEL
suffix:colon
multiline_comment|/* 1:1:0 */
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_CFG2SET
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_CFG1SET
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_CFG0CLR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INTC_INT_DISABLED
suffix:colon
multiline_comment|/* 0:0:0 */
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_CFG0CLR
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_CFG1CLR
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_CFG2CLR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* disable the interrupt */
id|printk
c_func
(paren
l_string|&quot;unexpected int type %d (irq %d)&bslash;n&quot;
comma
id|type
comma
id|irq_nr
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_CFG0CLR
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_CFG1CLR
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_CFG2CLR
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|int_req
)paren
multiline_comment|/* assign to interrupt request 1 */
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_ASSIGNCLR
)paren
suffix:semicolon
r_else
multiline_comment|/* assign to interrupt request 0 */
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_ASSIGNSET
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_SRCSET
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_MASKCLR
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_WAKECLR
)paren
suffix:semicolon
)brace
id|au_sync
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|startup_irq
r_static
r_int
r_int
id|startup_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
(brace
id|local_enable_irq
c_func
(paren
id|irq_nr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|shutdown_irq
r_static
r_void
id|shutdown_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
(brace
id|local_disable_irq
c_func
(paren
id|irq_nr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|local_enable_irq
r_inline
r_void
id|local_enable_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
(brace
r_if
c_cond
(paren
id|irq_nr
OG
id|AU1000_LAST_INTC0_INT
)paren
(brace
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_MASKSET
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_WAKESET
)paren
suffix:semicolon
)brace
r_else
(brace
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_MASKSET
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_WAKESET
)paren
suffix:semicolon
)brace
id|au_sync
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|local_disable_irq
r_inline
r_void
id|local_disable_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
(brace
r_if
c_cond
(paren
id|irq_nr
OG
id|AU1000_LAST_INTC0_INT
)paren
(brace
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_MASKCLR
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_WAKECLR
)paren
suffix:semicolon
)brace
r_else
(brace
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_MASKCLR
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_WAKECLR
)paren
suffix:semicolon
)brace
id|au_sync
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|mask_and_ack_rise_edge_irq
r_static
r_inline
r_void
id|mask_and_ack_rise_edge_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
(brace
r_if
c_cond
(paren
id|irq_nr
OG
id|AU1000_LAST_INTC0_INT
)paren
(brace
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_RISINGCLR
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_MASKCLR
)paren
suffix:semicolon
)brace
r_else
(brace
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_RISINGCLR
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_MASKCLR
)paren
suffix:semicolon
)brace
id|au_sync
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|mask_and_ack_fall_edge_irq
r_static
r_inline
r_void
id|mask_and_ack_fall_edge_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
(brace
r_if
c_cond
(paren
id|irq_nr
OG
id|AU1000_LAST_INTC0_INT
)paren
(brace
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_FALLINGCLR
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
(paren
id|irq_nr
op_minus
l_int|32
)paren
comma
id|IC1_MASKCLR
)paren
suffix:semicolon
)brace
r_else
(brace
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_FALLINGCLR
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|1
op_lshift
id|irq_nr
comma
id|IC0_MASKCLR
)paren
suffix:semicolon
)brace
id|au_sync
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|mask_and_ack_level_irq
r_static
r_inline
r_void
id|mask_and_ack_level_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
(brace
id|local_disable_irq
c_func
(paren
id|irq_nr
)paren
suffix:semicolon
id|au_sync
c_func
(paren
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_MIPS_PB1000)
r_if
c_cond
(paren
id|irq_nr
op_eq
id|AU1000_GPIO_15
)paren
(brace
id|au_writel
c_func
(paren
l_int|0x8000
comma
id|PB1000_MDR
)paren
suffix:semicolon
multiline_comment|/* ack int */
id|au_sync
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
suffix:semicolon
)brace
DECL|function|end_irq
r_static
r_void
id|end_irq
c_func
(paren
r_int
r_int
id|irq_nr
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|irq_desc
(braket
id|irq_nr
)braket
dot
id|status
op_amp
(paren
id|IRQ_DISABLED
op_or
id|IRQ_INPROGRESS
)paren
)paren
)paren
(brace
id|local_enable_irq
c_func
(paren
id|irq_nr
)paren
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_MIPS_PB1000)
r_if
c_cond
(paren
id|irq_nr
op_eq
id|AU1000_GPIO_15
)paren
(brace
id|au_writel
c_func
(paren
l_int|0x4000
comma
id|PB1000_MDR
)paren
suffix:semicolon
multiline_comment|/* enable int */
id|au_sync
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
DECL|function|save_local_and_disable
r_int
r_int
id|save_local_and_disable
c_func
(paren
r_int
id|controller
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
comma
id|mask
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|irq_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|controller
)paren
(brace
id|mask
op_assign
id|au_readl
c_func
(paren
id|IC1_MASKSET
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|32
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
)paren
(brace
id|local_disable_irq
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|mask
op_assign
id|au_readl
c_func
(paren
id|IC0_MASKSET
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|local_disable_irq
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irq_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
DECL|function|restore_local_and_enable
r_void
id|restore_local_and_enable
c_func
(paren
r_int
id|controller
comma
r_int
r_int
id|mask
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
comma
id|new_mask
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|irq_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
r_if
c_cond
(paren
id|controller
)paren
id|local_enable_irq
c_func
(paren
id|i
op_plus
l_int|32
)paren
suffix:semicolon
r_else
id|local_enable_irq
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|controller
)paren
id|new_mask
op_assign
id|au_readl
c_func
(paren
id|IC1_MASKSET
)paren
suffix:semicolon
r_else
id|new_mask
op_assign
id|au_readl
c_func
(paren
id|IC0_MASKSET
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|irq_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|rise_edge_irq_type
r_static
r_struct
id|hw_interrupt_type
id|rise_edge_irq_type
op_assign
(brace
l_string|&quot;Au1000 Rise Edge&quot;
comma
id|startup_irq
comma
id|shutdown_irq
comma
id|local_enable_irq
comma
id|local_disable_irq
comma
id|mask_and_ack_rise_edge_irq
comma
id|end_irq
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/*&n;static struct hw_interrupt_type fall_edge_irq_type = {&n;&t;&quot;Au1000 Fall Edge&quot;,&n;&t;startup_irq,&n;&t;shutdown_irq,&n;&t;local_enable_irq,&n;&t;local_disable_irq,&n;&t;mask_and_ack_fall_edge_irq,&n;&t;end_irq,&n;&t;NULL&n;};&n;*/
DECL|variable|level_irq_type
r_static
r_struct
id|hw_interrupt_type
id|level_irq_type
op_assign
(brace
l_string|&quot;Au1000 Level&quot;
comma
id|startup_irq
comma
id|shutdown_irq
comma
id|local_enable_irq
comma
id|local_disable_irq
comma
id|mask_and_ack_level_irq
comma
id|end_irq
comma
l_int|NULL
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_PM
DECL|function|startup_match20_interrupt
r_void
id|startup_match20_interrupt
c_func
(paren
r_void
)paren
(brace
id|local_enable_irq
c_func
(paren
id|AU1000_TOY_MATCH2_INT
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|init_IRQ
r_void
id|__init
id|init_IRQ
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|cp0_status
suffix:semicolon
id|cp0_status
op_assign
id|read_c0_status
c_func
(paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|irq_desc
comma
l_int|0
comma
r_sizeof
(paren
id|irq_desc
)paren
)paren
suffix:semicolon
id|set_except_vector
c_func
(paren
l_int|0
comma
id|au1000_IRQ
)paren
suffix:semicolon
id|init_generic_irq
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|AU1000_MAX_INTR
suffix:semicolon
id|i
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|i
)paren
(brace
r_case
id|AU1000_UART0_INT
suffix:colon
r_case
id|AU1000_UART3_INT
suffix:colon
macro_line|#ifdef CONFIG_MIPS_PB1000
r_case
id|AU1000_UART1_INT
suffix:colon
r_case
id|AU1000_UART2_INT
suffix:colon
r_case
id|AU1000_SSI0_INT
suffix:colon
r_case
id|AU1000_SSI1_INT
suffix:colon
macro_line|#endif
macro_line|#ifdef CONFIG_MIPS_PB1100
r_case
id|AU1000_UART1_INT
suffix:colon
r_case
id|AU1000_SSI0_INT
suffix:colon
r_case
id|AU1000_SSI1_INT
suffix:colon
macro_line|#endif
r_case
id|AU1000_DMA_INT_BASE
suffix:colon
r_case
id|AU1000_DMA_INT_BASE
op_plus
l_int|1
suffix:colon
r_case
id|AU1000_DMA_INT_BASE
op_plus
l_int|2
suffix:colon
r_case
id|AU1000_DMA_INT_BASE
op_plus
l_int|3
suffix:colon
r_case
id|AU1000_DMA_INT_BASE
op_plus
l_int|4
suffix:colon
r_case
id|AU1000_DMA_INT_BASE
op_plus
l_int|5
suffix:colon
r_case
id|AU1000_DMA_INT_BASE
op_plus
l_int|6
suffix:colon
r_case
id|AU1000_DMA_INT_BASE
op_plus
l_int|7
suffix:colon
r_case
id|AU1000_IRDA_TX_INT
suffix:colon
r_case
id|AU1000_IRDA_RX_INT
suffix:colon
r_case
id|AU1000_MAC0_DMA_INT
suffix:colon
macro_line|#if defined(CONFIG_MIPS_PB1000) || defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_PB1500) || defined(CONFIG_MIPS_DB1500)
r_case
id|AU1000_MAC1_DMA_INT
suffix:colon
macro_line|#endif
r_case
id|AU1500_GPIO_204
suffix:colon
id|setup_local_irq
c_func
(paren
id|i
comma
id|INTC_INT_HIGH_LEVEL
comma
l_int|0
)paren
suffix:semicolon
id|irq_desc
(braket
id|i
)braket
dot
id|handler
op_assign
op_amp
id|level_irq_type
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_MIPS_PB1000
r_case
id|AU1000_GPIO_15
suffix:colon
macro_line|#endif
r_case
id|AU1000_USB_HOST_INT
suffix:colon
macro_line|#if defined(CONFIG_MIPS_PB1500) || defined(CONFIG_MIPS_DB1500)
r_case
id|AU1000_PCI_INTA
suffix:colon
r_case
id|AU1000_PCI_INTB
suffix:colon
r_case
id|AU1000_PCI_INTC
suffix:colon
r_case
id|AU1000_PCI_INTD
suffix:colon
r_case
id|AU1500_GPIO_201
suffix:colon
r_case
id|AU1500_GPIO_202
suffix:colon
r_case
id|AU1500_GPIO_203
suffix:colon
r_case
id|AU1500_GPIO_205
suffix:colon
r_case
id|AU1500_GPIO_207
suffix:colon
macro_line|#endif
macro_line|#ifdef CONFIG_MIPS_PB1100
r_case
id|AU1000_GPIO_9
suffix:colon
singleline_comment|// PCMCIA Card Fully_Interted#
r_case
id|AU1000_GPIO_10
suffix:colon
singleline_comment|// PCMCIA_STSCHG#
r_case
id|AU1000_GPIO_11
suffix:colon
singleline_comment|// PCMCIA_IRQ#
r_case
id|AU1000_GPIO_13
suffix:colon
singleline_comment|// DC_IRQ#
r_case
id|AU1000_GPIO_23
suffix:colon
singleline_comment|// 2-wire SCL
macro_line|#endif
macro_line|#if defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100) || defined(CONFIG_MIPS_DB1500)
r_case
id|AU1000_GPIO_0
suffix:colon
singleline_comment|// PCMCIA Card 0 Fully_Interted#
r_case
id|AU1000_GPIO_1
suffix:colon
singleline_comment|// PCMCIA Card 0 STSCHG#
r_case
id|AU1000_GPIO_2
suffix:colon
singleline_comment|// PCMCIA Card 0 IRQ#
r_case
id|AU1000_GPIO_3
suffix:colon
singleline_comment|// PCMCIA Card 1 Fully_Interted#
r_case
id|AU1000_GPIO_4
suffix:colon
singleline_comment|// PCMCIA Card 1 STSCHG#
r_case
id|AU1000_GPIO_5
suffix:colon
singleline_comment|// PCMCIA Card 1 IRQ#
macro_line|#endif
id|setup_local_irq
c_func
(paren
id|i
comma
id|INTC_INT_LOW_LEVEL
comma
l_int|0
)paren
suffix:semicolon
id|irq_desc
(braket
id|i
)braket
dot
id|handler
op_assign
op_amp
id|level_irq_type
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AU1000_ACSYNC_INT
suffix:colon
r_case
id|AU1000_AC97C_INT
suffix:colon
r_case
id|AU1000_TOY_INT
suffix:colon
r_case
id|AU1000_TOY_MATCH0_INT
suffix:colon
r_case
id|AU1000_TOY_MATCH1_INT
suffix:colon
r_case
id|AU1000_USB_DEV_SUS_INT
suffix:colon
r_case
id|AU1000_USB_DEV_REQ_INT
suffix:colon
r_case
id|AU1000_RTC_INT
suffix:colon
r_case
id|AU1000_RTC_MATCH0_INT
suffix:colon
r_case
id|AU1000_RTC_MATCH1_INT
suffix:colon
r_case
id|AU1000_RTC_MATCH2_INT
suffix:colon
id|setup_local_irq
c_func
(paren
id|i
comma
id|INTC_INT_RISE_EDGE
comma
l_int|0
)paren
suffix:semicolon
id|irq_desc
(braket
id|i
)braket
dot
id|handler
op_assign
op_amp
id|rise_edge_irq_type
suffix:semicolon
r_break
suffix:semicolon
singleline_comment|// Careful if you change match 2 request!
singleline_comment|// The interrupt handler is called directly
singleline_comment|// from the low level dispatch code.
r_case
id|AU1000_TOY_MATCH2_INT
suffix:colon
id|setup_local_irq
c_func
(paren
id|i
comma
id|INTC_INT_RISE_EDGE
comma
l_int|1
)paren
suffix:semicolon
id|irq_desc
(braket
id|i
)braket
dot
id|handler
op_assign
op_amp
id|rise_edge_irq_type
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* active high, level interrupt */
id|setup_local_irq
c_func
(paren
id|i
comma
id|INTC_INT_HIGH_LEVEL
comma
l_int|0
)paren
suffix:semicolon
id|irq_desc
(braket
id|i
)braket
dot
id|handler
op_assign
op_amp
id|level_irq_type
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|set_c0_status
c_func
(paren
id|ALLINTS
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_KGDB
multiline_comment|/* If local serial I/O used for debug port, enter kgdb at once */
id|puts
c_func
(paren
l_string|&quot;Waiting for kgdb to connect...&quot;
)paren
suffix:semicolon
id|set_debug_traps
c_func
(paren
)paren
suffix:semicolon
id|breakpoint
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Interrupts are nested. Even if an interrupt handler is registered&n; * as &quot;fast&quot;, we might get another interrupt before we return from&n; * intcX_reqX_irqdispatch().&n; */
DECL|function|intc0_req0_irqdispatch
r_void
id|intc0_req0_irqdispatch
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|irq
op_assign
l_int|0
comma
id|i
suffix:semicolon
r_static
r_int
r_int
id|intc0_req0
op_assign
l_int|0
suffix:semicolon
id|intc0_req0
op_or_assign
id|au_readl
c_func
(paren
id|IC0_REQ0INT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|intc0_req0
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Because of the tight timing of SETUP token to reply&n;&t; * transactions, the USB devices-side packet complete&n;&t; * interrupt needs the highest priority.&n;&t; */
r_if
c_cond
(paren
(paren
id|intc0_req0
op_amp
(paren
l_int|1
op_lshift
id|AU1000_USB_DEV_REQ_INT
)paren
)paren
)paren
(brace
id|intc0_req0
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|AU1000_USB_DEV_REQ_INT
)paren
suffix:semicolon
id|do_IRQ
c_func
(paren
id|AU1000_USB_DEV_REQ_INT
comma
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|intc0_req0
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
)paren
(brace
id|intc0_req0
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
id|do_IRQ
c_func
(paren
id|irq
comma
id|regs
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|irq
op_increment
suffix:semicolon
)brace
)brace
DECL|function|intc0_req1_irqdispatch
r_void
id|intc0_req1_irqdispatch
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|irq
op_assign
l_int|0
comma
id|i
suffix:semicolon
r_static
r_int
r_int
id|intc0_req1
op_assign
l_int|0
suffix:semicolon
id|intc0_req1
op_assign
id|au_readl
c_func
(paren
id|IC0_REQ1INT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|intc0_req1
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|intc0_req1
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
)paren
(brace
id|intc0_req1
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PM
r_if
c_cond
(paren
id|i
op_eq
id|AU1000_TOY_MATCH2_INT
)paren
(brace
id|mask_and_ack_rise_edge_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
id|counter0_irq
c_func
(paren
id|irq
comma
l_int|NULL
comma
id|regs
)paren
suffix:semicolon
id|local_enable_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
id|do_IRQ
c_func
(paren
id|irq
comma
id|regs
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|irq
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Interrupt Controller 1:&n; * interrupts 32 - 63&n; */
DECL|function|intc1_req0_irqdispatch
r_void
id|intc1_req0_irqdispatch
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|irq
op_assign
l_int|0
comma
id|i
suffix:semicolon
r_static
r_int
r_int
id|intc1_req0
op_assign
l_int|0
suffix:semicolon
id|intc1_req0
op_or_assign
id|au_readl
c_func
(paren
id|IC1_REQ0INT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|intc1_req0
)paren
r_return
suffix:semicolon
macro_line|#if defined(CONFIG_MIPS_PB1000) &amp;&amp; defined(DEBUG_IRQ)
id|au_writel
c_func
(paren
l_int|1
comma
id|CPLD_AUX0
)paren
suffix:semicolon
multiline_comment|/* debug led 0 */
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|intc1_req0
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
)paren
(brace
id|intc1_req0
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_MIPS_PB1000) &amp;&amp; defined(DEBUG_IRQ)
id|au_writel
c_func
(paren
l_int|2
comma
id|CPLD_AUX0
)paren
suffix:semicolon
multiline_comment|/* turn on debug led 1  */
id|do_IRQ
c_func
(paren
id|irq
op_plus
l_int|32
comma
id|regs
)paren
suffix:semicolon
id|au_writel
c_func
(paren
l_int|0
comma
id|CPLD_AUX0
)paren
suffix:semicolon
multiline_comment|/* turn off debug led 1 */
macro_line|#else
id|do_IRQ
c_func
(paren
id|irq
op_plus
l_int|32
comma
id|regs
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
id|irq
op_increment
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_MIPS_PB1000) &amp;&amp; defined(DEBUG_IRQ)
id|au_writel
c_func
(paren
l_int|0
comma
id|CPLD_AUX0
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|intc1_req1_irqdispatch
r_void
id|intc1_req1_irqdispatch
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|irq
op_assign
l_int|0
comma
id|i
suffix:semicolon
r_static
r_int
r_int
id|intc1_req1
op_assign
l_int|0
suffix:semicolon
id|intc1_req1
op_or_assign
id|au_readl
c_func
(paren
id|IC1_REQ1INT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|intc1_req1
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|intc1_req1
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
)paren
(brace
id|intc1_req1
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
id|do_IRQ
c_func
(paren
id|irq
op_plus
l_int|32
comma
id|regs
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|irq
op_increment
suffix:semicolon
)brace
)brace
eof
