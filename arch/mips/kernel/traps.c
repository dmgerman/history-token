multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1994 - 1999, 2000, 01 Ralf Baechle&n; * Copyright (C) 1995, 1996 Paul M. Antoine&n; * Copyright (C) 1998 Ulf Carlsson&n; * Copyright (C) 1999 Silicon Graphics, Inc.&n; * Kevin D. Kissell, kevink@mips.com and Carsten Langgaard, carstenl@mips.com&n; * Copyright (C) 2000, 01 MIPS Technologies, Inc.&n; * Copyright (C) 2002, 2003, 2004  Maciej W. Rozycki&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/kallsyms.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt;
macro_line|#include &lt;asm/branch.h&gt;
macro_line|#include &lt;asm/break.h&gt;
macro_line|#include &lt;asm/cpu.h&gt;
macro_line|#include &lt;asm/fpu.h&gt;
macro_line|#include &lt;asm/module.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/sections.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/tlbdebug.h&gt;
macro_line|#include &lt;asm/traps.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/watch.h&gt;
macro_line|#include &lt;asm/types.h&gt;
r_extern
id|asmlinkage
r_void
id|handle_mod
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|handle_tlbl
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|handle_tlbs
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|__xtlb_mod
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|__xtlb_tlbl
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|__xtlb_tlbs
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|handle_adel
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|handle_ades
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|handle_ibe
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|handle_dbe
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|handle_sys
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|handle_bp
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|handle_ri
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|handle_cpu
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|handle_ov
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|handle_tr
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|handle_fpe
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|handle_mdmx
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|handle_watch
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|handle_mcheck
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_void
id|handle_reserved
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|fpu_emulator_cop1Handler
c_func
(paren
r_int
id|xcptno
comma
r_struct
id|pt_regs
op_star
id|xcp
comma
r_struct
id|mips_fpu_soft_struct
op_star
id|ctx
)paren
suffix:semicolon
DECL|variable|board_be_init
r_void
(paren
op_star
id|board_be_init
)paren
(paren
r_void
)paren
suffix:semicolon
DECL|variable|board_be_handler
r_int
(paren
op_star
id|board_be_handler
)paren
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|is_fixup
)paren
suffix:semicolon
multiline_comment|/*&n; * These constant is for searching for possible module text segments.&n; * MODULE_RANGE is a guess of how much space is likely to be vmalloced.&n; */
DECL|macro|MODULE_RANGE
mdefine_line|#define MODULE_RANGE (8*1024*1024)
multiline_comment|/*&n; * This routine abuses get_user()/put_user() to reference pointers&n; * with at least a bit of error checking ...&n; */
DECL|function|show_stack
r_void
id|show_stack
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
r_int
op_star
id|sp
)paren
(brace
r_const
r_int
id|field
op_assign
l_int|2
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
r_int
id|stackdata
suffix:semicolon
r_int
id|i
suffix:semicolon
id|sp
op_assign
id|sp
ques
c_cond
id|sp
suffix:colon
(paren
r_int
r_int
op_star
)paren
op_amp
id|sp
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Stack :&quot;
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
r_int
r_int
)paren
id|sp
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|i
op_logical_and
(paren
(paren
id|i
op_mod
(paren
l_int|64
op_div
id|field
)paren
)paren
op_eq
l_int|0
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n       &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|39
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; ...&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|stackdata
comma
id|sp
op_increment
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; (Bad stack address)&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; %0*lx&quot;
comma
id|field
comma
id|stackdata
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|show_trace
r_void
id|show_trace
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_int
r_int
op_star
id|stack
)paren
(brace
r_const
r_int
id|field
op_assign
l_int|2
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
r_int
r_int
id|addr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stack
)paren
id|stack
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
id|stack
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Call Trace:&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_KALLSYMS
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
op_logical_neg
id|kstack_end
c_func
(paren
id|stack
)paren
)paren
(brace
id|addr
op_assign
op_star
id|stack
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|__kernel_text_address
c_func
(paren
id|addr
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; [&lt;%0*lx&gt;] &quot;
comma
id|field
comma
id|addr
)paren
suffix:semicolon
id|print_symbol
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|addr
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The architecture-independent dump_stack generator&n; */
DECL|function|dump_stack
r_void
id|dump_stack
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|stack
suffix:semicolon
id|show_trace
c_func
(paren
id|current
comma
op_amp
id|stack
)paren
suffix:semicolon
)brace
DECL|variable|dump_stack
id|EXPORT_SYMBOL
c_func
(paren
id|dump_stack
)paren
suffix:semicolon
DECL|function|show_code
r_void
id|show_code
c_func
(paren
r_int
r_int
op_star
id|pc
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nCode:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
op_minus
l_int|3
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|insn
suffix:semicolon
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|insn
comma
id|pc
op_plus
id|i
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; (Bad address in epc)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%c%08x%c&quot;
comma
(paren
id|i
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;&lt;&squot;
)paren
comma
id|insn
comma
(paren
id|i
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;&gt;&squot;
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|show_regs
r_void
id|show_regs
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_const
r_int
id|field
op_assign
l_int|2
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
r_int
r_int
id|cause
op_assign
id|regs-&gt;cp0_cause
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Cpu %d&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Saved main processor registers&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|4
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;$%2d   :&quot;
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot; %0*lx&quot;
comma
id|field
comma
l_int|0UL
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|i
op_eq
l_int|26
op_logical_or
id|i
op_eq
l_int|27
)paren
id|printk
c_func
(paren
l_string|&quot; %*s&quot;
comma
id|field
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; %0*lx&quot;
comma
id|field
comma
id|regs-&gt;regs
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|4
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Hi    : %0*lx&bslash;n&quot;
comma
id|field
comma
id|regs-&gt;hi
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Lo    : %0*lx&bslash;n&quot;
comma
id|field
comma
id|regs-&gt;lo
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Saved cp0 registers&n;&t; */
id|printk
c_func
(paren
l_string|&quot;epc   : %0*lx &quot;
comma
id|field
comma
id|regs-&gt;cp0_epc
)paren
suffix:semicolon
id|print_symbol
c_func
(paren
l_string|&quot;%s &quot;
comma
id|regs-&gt;cp0_epc
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;    %s&bslash;n&quot;
comma
id|print_tainted
c_func
(paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ra    : %0*lx &quot;
comma
id|field
comma
id|regs-&gt;regs
(braket
l_int|31
)braket
)paren
suffix:semicolon
id|print_symbol
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|regs-&gt;regs
(braket
l_int|31
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Status: %08x    &quot;
comma
(paren
r_uint32
)paren
id|regs-&gt;cp0_status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;cp0_status
op_amp
id|ST0_KX
)paren
id|printk
c_func
(paren
l_string|&quot;KX &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;cp0_status
op_amp
id|ST0_SX
)paren
id|printk
c_func
(paren
l_string|&quot;SX &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;cp0_status
op_amp
id|ST0_UX
)paren
id|printk
c_func
(paren
l_string|&quot;UX &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|regs-&gt;cp0_status
op_amp
id|ST0_KSU
)paren
(brace
r_case
id|KSU_USER
suffix:colon
id|printk
c_func
(paren
l_string|&quot;USER &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KSU_SUPERVISOR
suffix:colon
id|printk
c_func
(paren
l_string|&quot;SUPERVISOR &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KSU_KERNEL
suffix:colon
id|printk
c_func
(paren
l_string|&quot;KERNEL &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;BAD_MODE &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|regs-&gt;cp0_status
op_amp
id|ST0_ERL
)paren
id|printk
c_func
(paren
l_string|&quot;ERL &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;cp0_status
op_amp
id|ST0_EXL
)paren
id|printk
c_func
(paren
l_string|&quot;EXL &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;cp0_status
op_amp
id|ST0_IE
)paren
id|printk
c_func
(paren
l_string|&quot;IE &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Cause : %08x&bslash;n&quot;
comma
id|cause
)paren
suffix:semicolon
id|cause
op_assign
(paren
id|cause
op_amp
id|CAUSEF_EXCCODE
)paren
op_rshift
id|CAUSEB_EXCCODE
suffix:semicolon
r_if
c_cond
(paren
l_int|1
op_le
id|cause
op_logical_and
id|cause
op_le
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;BadVA : %0*lx&bslash;n&quot;
comma
id|field
comma
id|regs-&gt;cp0_badvaddr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PrId  : %08x&bslash;n&quot;
comma
id|read_c0_prid
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|show_registers
r_void
id|show_registers
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
id|print_modules
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Process %s (pid: %d, threadinfo=%p, task=%p)&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
id|current_thread_info
c_func
(paren
)paren
comma
id|current
)paren
suffix:semicolon
id|show_stack
c_func
(paren
id|current
comma
(paren
r_int
op_star
)paren
id|regs-&gt;regs
(braket
l_int|29
)braket
)paren
suffix:semicolon
id|show_trace
c_func
(paren
id|current
comma
(paren
r_int
op_star
)paren
id|regs-&gt;regs
(braket
l_int|29
)braket
)paren
suffix:semicolon
id|show_code
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|regs-&gt;cp0_epc
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|die_lock
r_static
id|spinlock_t
id|die_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|__die
id|NORET_TYPE
r_void
id|__die
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_const
r_char
op_star
id|file
comma
r_const
r_char
op_star
id|func
comma
r_int
r_int
id|line
)paren
(brace
r_static
r_int
id|die_counter
suffix:semicolon
id|console_verbose
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|die_lock
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|str
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file
op_logical_and
id|func
)paren
id|printk
c_func
(paren
l_string|&quot; in %s:%s, line %ld&quot;
comma
id|file
comma
id|func
comma
id|line
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;[#%d]:&bslash;n&quot;
comma
op_increment
id|die_counter
)paren
suffix:semicolon
id|show_registers
c_func
(paren
id|regs
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|die_lock
)paren
suffix:semicolon
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
)brace
DECL|function|__die_if_kernel
r_void
id|__die_if_kernel
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_const
r_char
op_star
id|file
comma
r_const
r_char
op_star
id|func
comma
r_int
r_int
id|line
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|user_mode
c_func
(paren
id|regs
)paren
)paren
id|__die
c_func
(paren
id|str
comma
id|regs
comma
id|file
comma
id|func
comma
id|line
)paren
suffix:semicolon
)brace
r_extern
r_const
r_struct
id|exception_table_entry
id|__start___dbe_table
(braket
)braket
suffix:semicolon
r_extern
r_const
r_struct
id|exception_table_entry
id|__stop___dbe_table
(braket
)braket
suffix:semicolon
DECL|function|__declare_dbe_table
r_void
id|__declare_dbe_table
c_func
(paren
r_void
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;.section&bslash;t__dbe_table,&bslash;&quot;a&bslash;&quot;&bslash;n&bslash;t&quot;
l_string|&quot;.previous&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Given an address, look for it in the exception tables. */
DECL|function|search_dbe_tables
r_static
r_const
r_struct
id|exception_table_entry
op_star
id|search_dbe_tables
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_const
r_struct
id|exception_table_entry
op_star
id|e
suffix:semicolon
id|e
op_assign
id|search_extable
c_func
(paren
id|__start___dbe_table
comma
id|__stop___dbe_table
op_minus
l_int|1
comma
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e
)paren
id|e
op_assign
id|search_module_dbetables
c_func
(paren
id|addr
)paren
suffix:semicolon
r_return
id|e
suffix:semicolon
)brace
DECL|function|do_be
id|asmlinkage
r_void
id|do_be
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_const
r_int
id|field
op_assign
l_int|2
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
r_const
r_struct
id|exception_table_entry
op_star
id|fixup
op_assign
l_int|NULL
suffix:semicolon
r_int
id|data
op_assign
id|regs-&gt;cp0_cause
op_amp
l_int|4
suffix:semicolon
r_int
id|action
op_assign
id|MIPS_BE_FATAL
suffix:semicolon
multiline_comment|/* XXX For now.  Fixme, this searches the wrong table ...  */
r_if
c_cond
(paren
id|data
op_logical_and
op_logical_neg
id|user_mode
c_func
(paren
id|regs
)paren
)paren
id|fixup
op_assign
id|search_dbe_tables
c_func
(paren
id|exception_epc
c_func
(paren
id|regs
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fixup
)paren
id|action
op_assign
id|MIPS_BE_FIXUP
suffix:semicolon
r_if
c_cond
(paren
id|board_be_handler
)paren
id|action
op_assign
id|board_be_handler
c_func
(paren
id|regs
comma
id|fixup
op_ne
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|action
)paren
(brace
r_case
id|MIPS_BE_DISCARD
suffix:colon
r_return
suffix:semicolon
r_case
id|MIPS_BE_FIXUP
suffix:colon
r_if
c_cond
(paren
id|fixup
)paren
(brace
id|regs-&gt;cp0_epc
op_assign
id|fixup-&gt;nextinsn
suffix:semicolon
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Assume it would be too dangerous to continue ...&n;&t; */
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;%s bus error, epc == %0*lx, ra == %0*lx&bslash;n&quot;
comma
id|data
ques
c_cond
l_string|&quot;Data&quot;
suffix:colon
l_string|&quot;Instruction&quot;
comma
id|field
comma
id|regs-&gt;cp0_epc
comma
id|field
comma
id|regs-&gt;regs
(braket
l_int|31
)braket
)paren
suffix:semicolon
id|die_if_kernel
c_func
(paren
l_string|&quot;Oops&quot;
comma
id|regs
)paren
suffix:semicolon
id|force_sig
c_func
(paren
id|SIGBUS
comma
id|current
)paren
suffix:semicolon
)brace
DECL|function|get_insn_opcode
r_static
r_inline
r_int
id|get_insn_opcode
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
op_star
id|opcode
)paren
(brace
r_int
r_int
op_star
id|epc
suffix:semicolon
id|epc
op_assign
(paren
r_int
r_int
op_star
)paren
id|regs-&gt;cp0_epc
op_plus
(paren
(paren
id|regs-&gt;cp0_cause
op_amp
id|CAUSEF_BD
)paren
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_user
c_func
(paren
op_star
id|opcode
comma
id|epc
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|force_sig
c_func
(paren
id|SIGSEGV
comma
id|current
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * ll/sc emulation&n; */
DECL|macro|OPCODE
mdefine_line|#define OPCODE 0xfc000000
DECL|macro|BASE
mdefine_line|#define BASE   0x03e00000
DECL|macro|RT
mdefine_line|#define RT     0x001f0000
DECL|macro|OFFSET
mdefine_line|#define OFFSET 0x0000ffff
DECL|macro|LL
mdefine_line|#define LL     0xc0000000
DECL|macro|SC
mdefine_line|#define SC     0xe0000000
multiline_comment|/*&n; * The ll_bit is cleared by r*_switch.S&n; */
DECL|variable|ll_bit
r_int
r_int
id|ll_bit
suffix:semicolon
DECL|variable|ll_task
r_static
r_struct
id|task_struct
op_star
id|ll_task
op_assign
l_int|NULL
suffix:semicolon
DECL|function|simulate_ll
r_static
r_inline
r_void
id|simulate_ll
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|opcode
)paren
(brace
r_int
r_int
id|value
comma
op_star
id|vaddr
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_int
id|signal
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * analyse the ll instruction that just caused a ri exception&n;&t; * and put the referenced address to addr.&n;&t; */
multiline_comment|/* sign extend offset */
id|offset
op_assign
id|opcode
op_amp
id|OFFSET
suffix:semicolon
id|offset
op_lshift_assign
l_int|16
suffix:semicolon
id|offset
op_rshift_assign
l_int|16
suffix:semicolon
id|vaddr
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
(paren
r_int
)paren
(paren
id|regs-&gt;regs
(braket
(paren
id|opcode
op_amp
id|BASE
)paren
op_rshift
l_int|21
)braket
)paren
op_plus
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|vaddr
op_amp
l_int|3
)paren
(brace
id|signal
op_assign
id|SIGBUS
suffix:semicolon
r_goto
id|sig
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|value
comma
id|vaddr
)paren
)paren
(brace
id|signal
op_assign
id|SIGSEGV
suffix:semicolon
r_goto
id|sig
suffix:semicolon
)brace
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ll_task
op_eq
l_int|NULL
op_logical_or
id|ll_task
op_eq
id|current
)paren
(brace
id|ll_bit
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|ll_bit
op_assign
l_int|0
suffix:semicolon
)brace
id|ll_task
op_assign
id|current
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
id|regs-&gt;regs
(braket
(paren
id|opcode
op_amp
id|RT
)paren
op_rshift
l_int|16
)braket
op_assign
id|value
suffix:semicolon
id|compute_return_epc
c_func
(paren
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
id|sig
suffix:colon
id|force_sig
c_func
(paren
id|signal
comma
id|current
)paren
suffix:semicolon
)brace
DECL|function|simulate_sc
r_static
r_inline
r_void
id|simulate_sc
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|opcode
)paren
(brace
r_int
r_int
op_star
id|vaddr
comma
id|reg
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_int
id|signal
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * analyse the sc instruction that just caused a ri exception&n;&t; * and put the referenced address to addr.&n;&t; */
multiline_comment|/* sign extend offset */
id|offset
op_assign
id|opcode
op_amp
id|OFFSET
suffix:semicolon
id|offset
op_lshift_assign
l_int|16
suffix:semicolon
id|offset
op_rshift_assign
l_int|16
suffix:semicolon
id|vaddr
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
(paren
r_int
)paren
(paren
id|regs-&gt;regs
(braket
(paren
id|opcode
op_amp
id|BASE
)paren
op_rshift
l_int|21
)braket
)paren
op_plus
id|offset
)paren
suffix:semicolon
id|reg
op_assign
(paren
id|opcode
op_amp
id|RT
)paren
op_rshift
l_int|16
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|vaddr
op_amp
l_int|3
)paren
(brace
id|signal
op_assign
id|SIGBUS
suffix:semicolon
r_goto
id|sig
suffix:semicolon
)brace
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ll_bit
op_eq
l_int|0
op_logical_or
id|ll_task
op_ne
id|current
)paren
(brace
id|regs-&gt;regs
(braket
id|reg
)braket
op_assign
l_int|0
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
id|compute_return_epc
c_func
(paren
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|regs-&gt;regs
(braket
id|reg
)braket
comma
id|vaddr
)paren
)paren
(brace
id|signal
op_assign
id|SIGSEGV
suffix:semicolon
r_goto
id|sig
suffix:semicolon
)brace
id|regs-&gt;regs
(braket
id|reg
)braket
op_assign
l_int|1
suffix:semicolon
id|compute_return_epc
c_func
(paren
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
id|sig
suffix:colon
id|force_sig
c_func
(paren
id|signal
comma
id|current
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ll uses the opcode of lwc0 and sc uses the opcode of swc0.  That is both&n; * opcodes are supposed to result in coprocessor unusable exceptions if&n; * executed on ll/sc-less processors.  That&squot;s the theory.  In practice a&n; * few processors such as NEC&squot;s VR4100 throw reserved instruction exceptions&n; * instead, so we&squot;re doing the emulation thing in both exception handlers.&n; */
DECL|function|simulate_llsc
r_static
r_inline
r_int
id|simulate_llsc
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|opcode
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|get_insn_opcode
c_func
(paren
id|regs
comma
op_amp
id|opcode
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|opcode
op_amp
id|OPCODE
)paren
op_eq
id|LL
)paren
(brace
id|simulate_ll
c_func
(paren
id|regs
comma
id|opcode
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|opcode
op_amp
id|OPCODE
)paren
op_eq
id|SC
)paren
(brace
id|simulate_sc
c_func
(paren
id|regs
comma
id|opcode
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Strange things going on ... */
)brace
DECL|function|do_ov
id|asmlinkage
r_void
id|do_ov
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|siginfo_t
id|info
suffix:semicolon
id|info.si_code
op_assign
id|FPE_INTOVF
suffix:semicolon
id|info.si_signo
op_assign
id|SIGFPE
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
id|info.si_addr
op_assign
(paren
r_void
op_star
)paren
id|regs-&gt;cp0_epc
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGFPE
comma
op_amp
id|info
comma
id|current
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * XXX Delayed fp exceptions when doing a lazy ctx switch XXX&n; */
DECL|function|do_fpe
id|asmlinkage
r_void
id|do_fpe
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|fcr31
)paren
(brace
r_if
c_cond
(paren
id|fcr31
op_amp
id|FPU_CSR_UNI_X
)paren
(brace
r_int
id|sig
suffix:semicolon
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; &t; * Unimplemented operation exception.  If we&squot;ve got the full&n;&t;&t; * software emulator on-board, let&squot;s use it...&n;&t;&t; *&n;&t;&t; * Force FPU to dump state into task/thread context.  We&squot;re&n;&t;&t; * moving a lot of data here for what is probably a single&n;&t;&t; * instruction, but the alternative is to pre-decode the FP&n;&t;&t; * register operands before invoking the emulator, which seems&n;&t;&t; * a bit extreme for what should be an infrequent event.&n;&t;&t; */
id|save_fp
c_func
(paren
id|current
)paren
suffix:semicolon
multiline_comment|/* Run the emulator */
id|sig
op_assign
id|fpu_emulator_cop1Handler
(paren
l_int|0
comma
id|regs
comma
op_amp
id|current-&gt;thread.fpu.soft
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We can&squot;t allow the emulated instruction to leave any of&n;&t;&t; * the cause bit set in $fcr31.&n;&t;&t; */
id|current-&gt;thread.fpu.soft.fcr31
op_and_assign
op_complement
id|FPU_CSR_ALL_X
suffix:semicolon
multiline_comment|/* Restore the hardware register state */
id|restore_fp
c_func
(paren
id|current
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If something went wrong, signal */
r_if
c_cond
(paren
id|sig
)paren
id|force_sig
c_func
(paren
id|sig
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|force_sig
c_func
(paren
id|SIGFPE
comma
id|current
)paren
suffix:semicolon
)brace
DECL|function|do_bp
id|asmlinkage
r_void
id|do_bp
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|opcode
comma
id|bcode
suffix:semicolon
id|siginfo_t
id|info
suffix:semicolon
id|die_if_kernel
c_func
(paren
l_string|&quot;Break instruction in kernel code&quot;
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_insn_opcode
c_func
(paren
id|regs
comma
op_amp
id|opcode
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * There is the ancient bug in the MIPS assemblers that the break&n;&t; * code starts left to bit 16 instead to bit 6 in the opcode.&n;&t; * Gas is bug-compatible, but not always, grrr...&n;&t; * We handle both cases with a simple heuristics.  --macro&n;&t; */
id|bcode
op_assign
(paren
(paren
id|opcode
op_rshift
l_int|6
)paren
op_amp
(paren
(paren
l_int|1
op_lshift
l_int|20
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bcode
OL
(paren
l_int|1
op_lshift
l_int|10
)paren
)paren
id|bcode
op_lshift_assign
l_int|10
suffix:semicolon
multiline_comment|/*&n;&t; * (A short test says that IRIX 5.3 sends SIGTRAP for all break&n;&t; * insns, even for break codes that indicate arithmetic failures.&n;&t; * Weird ...)&n;&t; * But should we continue the brokenness???  --macro&n;&t; */
r_switch
c_cond
(paren
id|bcode
)paren
(brace
r_case
id|BRK_OVERFLOW
op_lshift
l_int|10
suffix:colon
r_case
id|BRK_DIVZERO
op_lshift
l_int|10
suffix:colon
r_if
c_cond
(paren
id|bcode
op_eq
(paren
id|BRK_DIVZERO
op_lshift
l_int|10
)paren
)paren
id|info.si_code
op_assign
id|FPE_INTDIV
suffix:semicolon
r_else
id|info.si_code
op_assign
id|FPE_INTOVF
suffix:semicolon
id|info.si_signo
op_assign
id|SIGFPE
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
id|info.si_addr
op_assign
(paren
r_void
op_star
)paren
id|regs-&gt;cp0_epc
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGFPE
comma
op_amp
id|info
comma
id|current
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|force_sig
c_func
(paren
id|SIGTRAP
comma
id|current
)paren
suffix:semicolon
)brace
)brace
DECL|function|do_tr
id|asmlinkage
r_void
id|do_tr
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|opcode
comma
id|tcode
op_assign
l_int|0
suffix:semicolon
id|siginfo_t
id|info
suffix:semicolon
id|die_if_kernel
c_func
(paren
l_string|&quot;Trap instruction in kernel code&quot;
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_insn_opcode
c_func
(paren
id|regs
comma
op_amp
id|opcode
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Immediate versions don&squot;t provide a code.  */
r_if
c_cond
(paren
op_logical_neg
(paren
id|opcode
op_amp
id|OPCODE
)paren
)paren
id|tcode
op_assign
(paren
(paren
id|opcode
op_rshift
l_int|6
)paren
op_amp
(paren
(paren
l_int|1
op_lshift
l_int|10
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * (A short test says that IRIX 5.3 sends SIGTRAP for all trap&n;&t; * insns, even for trap codes that indicate arithmetic failures.&n;&t; * Weird ...)&n;&t; * But should we continue the brokenness???  --macro&n;&t; */
r_switch
c_cond
(paren
id|tcode
)paren
(brace
r_case
id|BRK_OVERFLOW
suffix:colon
r_case
id|BRK_DIVZERO
suffix:colon
r_if
c_cond
(paren
id|tcode
op_eq
id|BRK_DIVZERO
)paren
id|info.si_code
op_assign
id|FPE_INTDIV
suffix:semicolon
r_else
id|info.si_code
op_assign
id|FPE_INTOVF
suffix:semicolon
id|info.si_signo
op_assign
id|SIGFPE
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
id|info.si_addr
op_assign
(paren
r_void
op_star
)paren
id|regs-&gt;cp0_epc
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGFPE
comma
op_amp
id|info
comma
id|current
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|force_sig
c_func
(paren
id|SIGTRAP
comma
id|current
)paren
suffix:semicolon
)brace
)brace
DECL|function|do_ri
id|asmlinkage
r_void
id|do_ri
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|die_if_kernel
c_func
(paren
l_string|&quot;Reserved instruction in kernel code&quot;
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_has_llsc
)paren
r_if
c_cond
(paren
op_logical_neg
id|simulate_llsc
c_func
(paren
id|regs
)paren
)paren
r_return
suffix:semicolon
id|force_sig
c_func
(paren
id|SIGILL
comma
id|current
)paren
suffix:semicolon
)brace
DECL|function|do_cpu
id|asmlinkage
r_void
id|do_cpu
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|cpid
suffix:semicolon
id|die_if_kernel
c_func
(paren
l_string|&quot;do_cpu invoked from kernel context!&quot;
comma
id|regs
)paren
suffix:semicolon
id|cpid
op_assign
(paren
id|regs-&gt;cp0_cause
op_rshift
id|CAUSEB_CE
)paren
op_amp
l_int|3
suffix:semicolon
r_switch
c_cond
(paren
id|cpid
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|cpu_has_llsc
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|simulate_llsc
c_func
(paren
id|regs
)paren
)paren
r_return
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
id|own_fpu
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|used_math
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* Using the FPU again.  */
id|restore_fp
c_func
(paren
id|current
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* First time FPU user.  */
id|init_fpu
c_func
(paren
)paren
suffix:semicolon
id|set_used_math
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cpu_has_fpu
)paren
(brace
r_int
id|sig
op_assign
id|fpu_emulator_cop1Handler
c_func
(paren
l_int|0
comma
id|regs
comma
op_amp
id|current-&gt;thread.fpu.soft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sig
)paren
id|force_sig
c_func
(paren
id|sig
comma
id|current
)paren
suffix:semicolon
)brace
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|2
suffix:colon
r_case
l_int|3
suffix:colon
r_break
suffix:semicolon
)brace
id|force_sig
c_func
(paren
id|SIGILL
comma
id|current
)paren
suffix:semicolon
)brace
DECL|function|do_mdmx
id|asmlinkage
r_void
id|do_mdmx
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|force_sig
c_func
(paren
id|SIGILL
comma
id|current
)paren
suffix:semicolon
)brace
DECL|function|do_watch
id|asmlinkage
r_void
id|do_watch
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/*&n;&t; * We use the watch exception where available to detect stack&n;&t; * overflows.&n;&t; */
id|dump_tlb_all
c_func
(paren
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Caught WATCH exception - probably caused by stack overflow.&quot;
)paren
suffix:semicolon
)brace
DECL|function|do_mcheck
id|asmlinkage
r_void
id|do_mcheck
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
id|dump_tlb_all
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Some chips may have other causes of machine check (e.g. SB1&n;&t; * graduation timer)&n;&t; */
id|panic
c_func
(paren
l_string|&quot;Caught Machine Check exception - %scaused by multiple &quot;
l_string|&quot;matching entries in the TLB.&quot;
comma
(paren
id|regs-&gt;cp0_status
op_amp
id|ST0_TS
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;not &quot;
)paren
suffix:semicolon
)brace
DECL|function|do_reserved
id|asmlinkage
r_void
id|do_reserved
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/*&n;&t; * Game over - no way to handle this if it ever occurs.  Most probably&n;&t; * caused by a new unknown cpu type or after another deadly&n;&t; * hard/software error.&n;&t; */
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Caught reserved exception %ld - should not happen.&quot;
comma
(paren
id|regs-&gt;cp0_cause
op_amp
l_int|0x7f
)paren
op_rshift
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Some MIPS CPUs can enable/disable for cache parity detection, but do&n; * it different ways.&n; */
DECL|function|parity_protection_init
r_static
r_inline
r_void
id|parity_protection_init
c_func
(paren
r_void
)paren
(brace
r_switch
c_cond
(paren
id|current_cpu_data.cputype
)paren
(brace
r_case
id|CPU_24K
suffix:colon
multiline_comment|/* 24K cache parity not currently implemented in FPGA */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Disable cache parity protection for &quot;
l_string|&quot;MIPS 24K CPU.&bslash;n&quot;
)paren
suffix:semicolon
id|write_c0_ecc
c_func
(paren
id|read_c0_ecc
c_func
(paren
)paren
op_amp
op_complement
l_int|0x80000000
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPU_5KC
suffix:colon
multiline_comment|/* Set the PE bit (bit 31) in the c0_ecc register. */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Enable cache parity protection for &quot;
l_string|&quot;MIPS 5KC/24K CPUs.&bslash;n&quot;
)paren
suffix:semicolon
id|write_c0_ecc
c_func
(paren
id|read_c0_ecc
c_func
(paren
)paren
op_or
l_int|0x80000000
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPU_20KC
suffix:colon
r_case
id|CPU_25KF
suffix:colon
multiline_comment|/* Clear the DE bit (bit 16) in the c0_status register. */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Enable cache parity protection for &quot;
l_string|&quot;MIPS 20KC/25KF CPUs.&bslash;n&quot;
)paren
suffix:semicolon
id|clear_c0_status
c_func
(paren
id|ST0_DE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
DECL|function|cache_parity_error
id|asmlinkage
r_void
id|cache_parity_error
c_func
(paren
r_void
)paren
(brace
r_const
r_int
id|field
op_assign
l_int|2
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
r_int
r_int
id|reg_val
suffix:semicolon
multiline_comment|/* For the moment, report the problem and hang. */
id|printk
c_func
(paren
l_string|&quot;Cache error exception:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cp0_errorepc == %0*lx&bslash;n&quot;
comma
id|field
comma
id|read_c0_errorepc
c_func
(paren
)paren
)paren
suffix:semicolon
id|reg_val
op_assign
id|read_c0_cacheerr
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;c0_cacheerr == %08x&bslash;n&quot;
comma
id|reg_val
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Decoded c0_cacheerr: %s cache fault in %s reference.&bslash;n&quot;
comma
id|reg_val
op_amp
(paren
l_int|1
op_lshift
l_int|30
)paren
ques
c_cond
l_string|&quot;secondary&quot;
suffix:colon
l_string|&quot;primary&quot;
comma
id|reg_val
op_amp
(paren
l_int|1
op_lshift
l_int|31
)paren
ques
c_cond
l_string|&quot;data&quot;
suffix:colon
l_string|&quot;insn&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Error bits: %s%s%s%s%s%s%s&bslash;n&quot;
comma
id|reg_val
op_amp
(paren
l_int|1
op_lshift
l_int|29
)paren
ques
c_cond
l_string|&quot;ED &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|reg_val
op_amp
(paren
l_int|1
op_lshift
l_int|28
)paren
ques
c_cond
l_string|&quot;ET &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|reg_val
op_amp
(paren
l_int|1
op_lshift
l_int|26
)paren
ques
c_cond
l_string|&quot;EE &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|reg_val
op_amp
(paren
l_int|1
op_lshift
l_int|25
)paren
ques
c_cond
l_string|&quot;EB &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|reg_val
op_amp
(paren
l_int|1
op_lshift
l_int|24
)paren
ques
c_cond
l_string|&quot;EI &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|reg_val
op_amp
(paren
l_int|1
op_lshift
l_int|23
)paren
ques
c_cond
l_string|&quot;E1 &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|reg_val
op_amp
(paren
l_int|1
op_lshift
l_int|22
)paren
ques
c_cond
l_string|&quot;E0 &quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;IDX: 0x%08x&bslash;n&quot;
comma
id|reg_val
op_amp
(paren
(paren
l_int|1
op_lshift
l_int|22
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_CPU_MIPS32) || defined (CONFIG_CPU_MIPS64)
r_if
c_cond
(paren
id|reg_val
op_amp
(paren
l_int|1
op_lshift
l_int|22
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;DErrAddr0: 0x%0*lx&bslash;n&quot;
comma
id|field
comma
id|read_c0_derraddr0
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg_val
op_amp
(paren
l_int|1
op_lshift
l_int|23
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;DErrAddr1: 0x%0*lx&bslash;n&quot;
comma
id|field
comma
id|read_c0_derraddr1
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif
id|panic
c_func
(paren
l_string|&quot;Can&squot;t handle the cache error!&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * SDBBP EJTAG debug exception handler.&n; * We skip the instruction and return to the next instruction.&n; */
DECL|function|ejtag_exception_handler
r_void
id|ejtag_exception_handler
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_const
r_int
id|field
op_assign
l_int|2
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
r_int
r_int
id|depc
comma
id|old_epc
suffix:semicolon
r_int
r_int
id|debug
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SDBBP EJTAG debug exception - not handled yet, just ignored!&bslash;n&quot;
)paren
suffix:semicolon
id|depc
op_assign
id|read_c0_depc
c_func
(paren
)paren
suffix:semicolon
id|debug
op_assign
id|read_c0_debug
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;c0_depc = %0*lx, DEBUG = %08x&bslash;n&quot;
comma
id|field
comma
id|depc
comma
id|debug
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_amp
l_int|0x80000000
)paren
(brace
multiline_comment|/*&n;&t;&t; * In branch delay slot.&n;&t;&t; * We cheat a little bit here and use EPC to calculate the&n;&t;&t; * debug return address (DEPC). EPC is restored after the&n;&t;&t; * calculation.&n;&t;&t; */
id|old_epc
op_assign
id|regs-&gt;cp0_epc
suffix:semicolon
id|regs-&gt;cp0_epc
op_assign
id|depc
suffix:semicolon
id|__compute_return_epc
c_func
(paren
id|regs
)paren
suffix:semicolon
id|depc
op_assign
id|regs-&gt;cp0_epc
suffix:semicolon
id|regs-&gt;cp0_epc
op_assign
id|old_epc
suffix:semicolon
)brace
r_else
id|depc
op_add_assign
l_int|4
suffix:semicolon
id|write_c0_depc
c_func
(paren
id|depc
)paren
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;&bslash;n&bslash;n----- Enable EJTAG single stepping ----&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|write_c0_debug
c_func
(paren
id|debug
op_or
l_int|0x100
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * NMI exception handler.&n; */
DECL|function|nmi_exception_handler
r_void
id|nmi_exception_handler
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NMI taken!!!!&bslash;n&quot;
)paren
suffix:semicolon
id|die
c_func
(paren
l_string|&quot;NMI&quot;
comma
id|regs
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
suffix:semicolon
)brace
)brace
DECL|variable|exception_handlers
r_int
r_int
id|exception_handlers
(braket
l_int|32
)braket
suffix:semicolon
multiline_comment|/*&n; * As a side effect of the way this is implemented we&squot;re limited&n; * to interrupt handlers in the address range from&n; * KSEG0 &lt;= x &lt; KSEG0 + 256mb on the Nevada.  Oh well ...&n; */
DECL|function|set_except_vector
r_void
op_star
id|set_except_vector
c_func
(paren
r_int
id|n
comma
r_void
op_star
id|addr
)paren
(brace
r_int
r_int
id|handler
op_assign
(paren
r_int
r_int
)paren
id|addr
suffix:semicolon
r_int
r_int
id|old_handler
op_assign
id|exception_handlers
(braket
id|n
)braket
suffix:semicolon
id|exception_handlers
(braket
id|n
)braket
op_assign
id|handler
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|0
op_logical_and
id|cpu_has_divec
)paren
(brace
op_star
(paren
r_volatile
id|u32
op_star
)paren
(paren
id|CAC_BASE
op_plus
l_int|0x200
)paren
op_assign
l_int|0x08000000
op_or
(paren
l_int|0x03ffffff
op_amp
(paren
id|handler
op_rshift
l_int|2
)paren
)paren
suffix:semicolon
id|flush_icache_range
c_func
(paren
id|CAC_BASE
op_plus
l_int|0x200
comma
id|CAC_BASE
op_plus
l_int|0x204
)paren
suffix:semicolon
)brace
r_return
(paren
r_void
op_star
)paren
id|old_handler
suffix:semicolon
)brace
multiline_comment|/*&n; * This is used by native signal handling&n; */
DECL|variable|save_fp_context
id|asmlinkage
r_int
(paren
op_star
id|save_fp_context
)paren
(paren
r_struct
id|sigcontext
op_star
id|sc
)paren
suffix:semicolon
DECL|variable|restore_fp_context
id|asmlinkage
r_int
(paren
op_star
id|restore_fp_context
)paren
(paren
r_struct
id|sigcontext
op_star
id|sc
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_int
id|_save_fp_context
c_func
(paren
r_struct
id|sigcontext
op_star
id|sc
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_int
id|_restore_fp_context
c_func
(paren
r_struct
id|sigcontext
op_star
id|sc
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_int
id|fpu_emulator_save_context
c_func
(paren
r_struct
id|sigcontext
op_star
id|sc
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_int
id|fpu_emulator_restore_context
c_func
(paren
r_struct
id|sigcontext
op_star
id|sc
)paren
suffix:semicolon
DECL|function|signal_init
r_static
r_inline
r_void
id|signal_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|cpu_has_fpu
)paren
(brace
id|save_fp_context
op_assign
id|_save_fp_context
suffix:semicolon
id|restore_fp_context
op_assign
id|_restore_fp_context
suffix:semicolon
)brace
r_else
(brace
id|save_fp_context
op_assign
id|fpu_emulator_save_context
suffix:semicolon
id|restore_fp_context
op_assign
id|fpu_emulator_restore_context
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_MIPS32_COMPAT
multiline_comment|/*&n; * This is used by 32-bit signal stuff on the 64-bit kernel&n; */
DECL|variable|save_fp_context32
id|asmlinkage
r_int
(paren
op_star
id|save_fp_context32
)paren
(paren
r_struct
id|sigcontext32
op_star
id|sc
)paren
suffix:semicolon
DECL|variable|restore_fp_context32
id|asmlinkage
r_int
(paren
op_star
id|restore_fp_context32
)paren
(paren
r_struct
id|sigcontext32
op_star
id|sc
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_int
id|_save_fp_context32
c_func
(paren
r_struct
id|sigcontext32
op_star
id|sc
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_int
id|_restore_fp_context32
c_func
(paren
r_struct
id|sigcontext32
op_star
id|sc
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_int
id|fpu_emulator_save_context32
c_func
(paren
r_struct
id|sigcontext32
op_star
id|sc
)paren
suffix:semicolon
r_extern
id|asmlinkage
r_int
id|fpu_emulator_restore_context32
c_func
(paren
r_struct
id|sigcontext32
op_star
id|sc
)paren
suffix:semicolon
DECL|function|signal32_init
r_static
r_inline
r_void
id|signal32_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|cpu_has_fpu
)paren
(brace
id|save_fp_context32
op_assign
id|_save_fp_context32
suffix:semicolon
id|restore_fp_context32
op_assign
id|_restore_fp_context32
suffix:semicolon
)brace
r_else
(brace
id|save_fp_context32
op_assign
id|fpu_emulator_save_context32
suffix:semicolon
id|restore_fp_context32
op_assign
id|fpu_emulator_restore_context32
suffix:semicolon
)brace
)brace
macro_line|#endif
r_extern
r_void
id|cpu_cache_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|tlb_init
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|per_cpu_trap_init
r_void
id|__init
id|per_cpu_trap_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|status_set
op_assign
id|ST0_CU0
suffix:semicolon
multiline_comment|/*&n;&t; * Disable coprocessors and select 32-bit or 64-bit addressing&n;&t; * and the 16/32 or 32/32 FPR register model.  Reset the BEV&n;&t; * flag that some firmware may have left set and the TS bit (for&n;&t; * IP27).  Set XX for ISA IV code to work.&n;&t; */
macro_line|#ifdef CONFIG_MIPS64
id|status_set
op_or_assign
id|ST0_FR
op_or
id|ST0_KX
op_or
id|ST0_SX
op_or
id|ST0_UX
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|current_cpu_data.isa_level
op_eq
id|MIPS_CPU_ISA_IV
)paren
id|status_set
op_or_assign
id|ST0_XX
suffix:semicolon
id|change_c0_status
c_func
(paren
id|ST0_CU
op_or
id|ST0_FR
op_or
id|ST0_BEV
op_or
id|ST0_TS
op_or
id|ST0_KX
op_or
id|ST0_SX
op_or
id|ST0_UX
comma
id|status_set
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Some MIPS CPUs have a dedicated interrupt vector which reduces the&n;&t; * interrupt processing overhead.  Use it where available.&n;&t; */
r_if
c_cond
(paren
id|cpu_has_divec
)paren
id|set_c0_cause
c_func
(paren
id|CAUSEF_IV
)paren
suffix:semicolon
id|cpu_data
(braket
id|cpu
)braket
dot
id|asid_cache
op_assign
id|ASID_FIRST_VERSION
suffix:semicolon
id|TLBMISS_HANDLER_SETUP
c_func
(paren
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|init_mm.mm_count
)paren
suffix:semicolon
id|current-&gt;active_mm
op_assign
op_amp
id|init_mm
suffix:semicolon
id|BUG_ON
c_func
(paren
id|current-&gt;mm
)paren
suffix:semicolon
id|enter_lazy_tlb
c_func
(paren
op_amp
id|init_mm
comma
id|current
)paren
suffix:semicolon
id|cpu_cache_init
c_func
(paren
)paren
suffix:semicolon
id|tlb_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|trap_init
r_void
id|__init
id|trap_init
c_func
(paren
r_void
)paren
(brace
r_extern
r_char
id|except_vec3_generic
comma
id|except_vec3_r4000
suffix:semicolon
r_extern
r_char
id|except_vec_ejtag_debug
suffix:semicolon
r_extern
r_char
id|except_vec4
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|per_cpu_trap_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the generic exception handlers to their final destination.&n;&t; * This will be overriden later as suitable for a particular&n;&t; * configuration.&n;&t; */
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|CAC_BASE
op_plus
l_int|0x180
)paren
comma
op_amp
id|except_vec3_generic
comma
l_int|0x80
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Setup default vectors&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
l_int|31
suffix:semicolon
id|i
op_increment
)paren
id|set_except_vector
c_func
(paren
id|i
comma
id|handle_reserved
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the EJTAG debug exception vector handler code to it&squot;s final&n;&t; * destination.&n;&t; */
r_if
c_cond
(paren
id|cpu_has_ejtag
)paren
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|CAC_BASE
op_plus
l_int|0x300
)paren
comma
op_amp
id|except_vec_ejtag_debug
comma
l_int|0x80
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Only some CPUs have the watch exceptions.&n;&t; */
r_if
c_cond
(paren
id|cpu_has_watch
)paren
id|set_except_vector
c_func
(paren
l_int|23
comma
id|handle_watch
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Some MIPS CPUs have a dedicated interrupt vector which reduces the&n;&t; * interrupt processing overhead.  Use it where available.&n;&t; */
r_if
c_cond
(paren
id|cpu_has_divec
)paren
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|CAC_BASE
op_plus
l_int|0x200
)paren
comma
op_amp
id|except_vec4
comma
l_int|0x8
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Some CPUs can enable/disable for cache parity detection, but does&n;&t; * it different ways.&n;&t; */
id|parity_protection_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The Data Bus Errors / Instruction Bus Errors are signaled&n;&t; * by external hardware.  Therefore these two exceptions&n;&t; * may have board specific handlers.&n;&t; */
r_if
c_cond
(paren
id|board_be_init
)paren
id|board_be_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MIPS32
id|set_except_vector
c_func
(paren
l_int|1
comma
id|handle_mod
)paren
suffix:semicolon
id|set_except_vector
c_func
(paren
l_int|2
comma
id|handle_tlbl
)paren
suffix:semicolon
id|set_except_vector
c_func
(paren
l_int|3
comma
id|handle_tlbs
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_MIPS64
id|set_except_vector
c_func
(paren
l_int|1
comma
id|__xtlb_mod
)paren
suffix:semicolon
id|set_except_vector
c_func
(paren
l_int|2
comma
id|__xtlb_tlbl
)paren
suffix:semicolon
id|set_except_vector
c_func
(paren
l_int|3
comma
id|__xtlb_tlbs
)paren
suffix:semicolon
macro_line|#endif
id|set_except_vector
c_func
(paren
l_int|4
comma
id|handle_adel
)paren
suffix:semicolon
id|set_except_vector
c_func
(paren
l_int|5
comma
id|handle_ades
)paren
suffix:semicolon
id|set_except_vector
c_func
(paren
l_int|6
comma
id|handle_ibe
)paren
suffix:semicolon
id|set_except_vector
c_func
(paren
l_int|7
comma
id|handle_dbe
)paren
suffix:semicolon
id|set_except_vector
c_func
(paren
l_int|8
comma
id|handle_sys
)paren
suffix:semicolon
id|set_except_vector
c_func
(paren
l_int|9
comma
id|handle_bp
)paren
suffix:semicolon
id|set_except_vector
c_func
(paren
l_int|10
comma
id|handle_ri
)paren
suffix:semicolon
id|set_except_vector
c_func
(paren
l_int|11
comma
id|handle_cpu
)paren
suffix:semicolon
id|set_except_vector
c_func
(paren
l_int|12
comma
id|handle_ov
)paren
suffix:semicolon
id|set_except_vector
c_func
(paren
l_int|13
comma
id|handle_tr
)paren
suffix:semicolon
id|set_except_vector
c_func
(paren
l_int|22
comma
id|handle_mdmx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu_has_fpu
op_logical_and
op_logical_neg
id|cpu_has_nofpuex
)paren
id|set_except_vector
c_func
(paren
l_int|15
comma
id|handle_fpe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu_has_mcheck
)paren
id|set_except_vector
c_func
(paren
l_int|24
comma
id|handle_mcheck
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu_has_vce
)paren
multiline_comment|/* Special exception: R4[04]00 uses also the divec space. */
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|CAC_BASE
op_plus
l_int|0x180
)paren
comma
op_amp
id|except_vec3_r4000
comma
l_int|0x100
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cpu_has_4kex
)paren
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|CAC_BASE
op_plus
l_int|0x180
)paren
comma
op_amp
id|except_vec3_generic
comma
l_int|0x80
)paren
suffix:semicolon
r_else
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|CAC_BASE
op_plus
l_int|0x080
)paren
comma
op_amp
id|except_vec3_generic
comma
l_int|0x80
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current_cpu_data.cputype
op_eq
id|CPU_R6000
op_logical_or
id|current_cpu_data.cputype
op_eq
id|CPU_R6000A
)paren
(brace
multiline_comment|/*&n;&t;&t; * The R6000 is the only R-series CPU that features a machine&n;&t;&t; * check exception (similar to the R4000 cache error) and&n;&t;&t; * unaligned ldc1/sdc1 exception.  The handlers have not been&n;&t;&t; * written yet.  Well, anyway there is no R6000 machine on the&n;&t;&t; * current list of targets for Linux/MIPS.&n;&t;&t; * (Duh, crap, there is someone with a tripple R6k machine)&n;&t;&t; */
singleline_comment|//set_except_vector(14, handle_mc);
singleline_comment|//set_except_vector(15, handle_ndc);
)brace
id|signal_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MIPS32_COMPAT
id|signal32_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|flush_icache_range
c_func
(paren
id|CAC_BASE
comma
id|CAC_BASE
op_plus
l_int|0x400
)paren
suffix:semicolon
)brace
eof
