multiline_comment|/*&n; *  arch/mips/kernel/gdb-stub.c&n; *&n; *  Originally written by Glenn Engel, Lake Stevens Instrument Division&n; *&n; *  Contributed by HP Systems&n; *&n; *  Modified for SPARC by Stu Grossman, Cygnus Support.&n; *&n; *  Modified for Linux/MIPS (and MIPS in general) by Andreas Busse&n; *  Send complaints, suggestions etc. to &lt;andy@waldorf-gmbh.de&gt;&n; *&n; *  Copyright (C) 1995 Andreas Busse&n; *&n; *  Copyright (C) 2003 MontaVista Software Inc.&n; *  Author: Jun Sun, jsun@mvista.com or jsun@junsun.net&n; */
multiline_comment|/*&n; *  To enable debugger support, two things need to happen.  One, a&n; *  call to set_debug_traps() is necessary in order to allow any breakpoints&n; *  or error conditions to be properly intercepted and reported to gdb.&n; *  Two, a breakpoint needs to be generated to begin communication.  This&n; *  is most easily accomplished by a call to breakpoint().  Breakpoint()&n; *  simulates a breakpoint by executing a BREAK instruction.&n; *&n; *&n; *    The following gdb commands are supported:&n; *&n; * command          function                               Return value&n; *&n; *    g             return the value of the CPU registers  hex data or ENN&n; *    G             set the value of the CPU registers     OK or ENN&n; *&n; *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA      hex data or ENN&n; *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA      OK or ENN&n; *&n; *    c             Resume at current address              SNN   ( signal NN)&n; *    cAA..AA       Continue at address AA..AA             SNN&n; *&n; *    s             Step one instruction                   SNN&n; *    sAA..AA       Step one instruction from AA..AA       SNN&n; *&n; *    k             kill&n; *&n; *    ?             What was the last sigval ?             SNN   (signal NN)&n; *&n; *    bBB..BB&t;    Set baud rate to BB..BB&t;&t;   OK or BNN, then sets&n; *&t;&t;&t;&t;&t;&t;&t;   baud rate&n; *&n; * All commands and responses are sent with a packet which includes a&n; * checksum.  A packet consists of&n; *&n; * $&lt;packet info&gt;#&lt;checksum&gt;.&n; *&n; * where&n; * &lt;packet info&gt; :: &lt;characters representing the command or response&gt;&n; * &lt;checksum&gt;    :: &lt; two hex digits computed as modulo 256 sum of &lt;packetinfo&gt;&gt;&n; *&n; * When a packet is received, it is first acknowledged with either &squot;+&squot; or &squot;-&squot;.&n; * &squot;+&squot; indicates a successful transfer.  &squot;-&squot; indicates a failed transfer.&n; *&n; * Example:&n; *&n; * Host:                  Reply:&n; * $m0,10#2a               +$00010203040506070809101112131415#42&n; *&n; *&n; *  ==============&n; *  MORE EXAMPLES:&n; *  ==============&n; *&n; *  For reference -- the following are the steps that one&n; *  company took (RidgeRun Inc) to get remote gdb debugging&n; *  going. In this scenario the host machine was a PC and the&n; *  target platform was a Galileo EVB64120A MIPS evaluation&n; *  board.&n; *&n; *  Step 1:&n; *  First download gdb-5.0.tar.gz from the internet.&n; *  and then build/install the package.&n; *&n; *  Example:&n; *    $ tar zxf gdb-5.0.tar.gz&n; *    $ cd gdb-5.0&n; *    $ ./configure --target=mips-linux-elf&n; *    $ make&n; *    $ install&n; *    $ which mips-linux-elf-gdb&n; *    /usr/local/bin/mips-linux-elf-gdb&n; *&n; *  Step 2:&n; *  Configure linux for remote debugging and build it.&n; *&n; *  Example:&n; *    $ cd ~/linux&n; *    $ make menuconfig &lt;go to &quot;Kernel Hacking&quot; and turn on remote debugging&gt;&n; *    $ make&n; *&n; *  Step 3:&n; *  Download the kernel to the remote target and start&n; *  the kernel running. It will promptly halt and wait&n; *  for the host gdb session to connect. It does this&n; *  since the &quot;Kernel Hacking&quot; option has defined&n; *  CONFIG_KGDB which in turn enables your calls&n; *  to:&n; *     set_debug_traps();&n; *     breakpoint();&n; *&n; *  Step 4:&n; *  Start the gdb session on the host.&n; *&n; *  Example:&n; *    $ mips-linux-elf-gdb vmlinux&n; *    (gdb) set remotebaud 115200&n; *    (gdb) target remote /dev/ttyS1&n; *    ...at this point you are connected to&n; *       the remote target and can use gdb&n; *       in the normal fasion. Setting&n; *       breakpoints, single stepping,&n; *       printing variables, etc.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;asm/asm.h&gt;
macro_line|#include &lt;asm/cacheflush.h&gt;
macro_line|#include &lt;asm/mipsregs.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/gdb-stub.h&gt;
macro_line|#include &lt;asm/inst.h&gt;
multiline_comment|/*&n; * external low-level support routines&n; */
r_extern
r_int
id|putDebugChar
c_func
(paren
r_char
id|c
)paren
suffix:semicolon
multiline_comment|/* write a single character      */
r_extern
r_char
id|getDebugChar
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* read and return a single char */
r_extern
r_void
id|trap_low
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * breakpoint and test functions&n; */
r_extern
r_void
id|breakpoint
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|breakinst
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|async_breakpoint
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|async_breakinst
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|adel
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * local prototypes&n; */
r_static
r_void
id|getpacket
c_func
(paren
r_char
op_star
id|buffer
)paren
suffix:semicolon
r_static
r_void
id|putpacket
c_func
(paren
r_char
op_star
id|buffer
)paren
suffix:semicolon
r_static
r_int
id|computeSignal
c_func
(paren
r_int
id|tt
)paren
suffix:semicolon
r_static
r_int
id|hex
c_func
(paren
r_int
r_char
id|ch
)paren
suffix:semicolon
r_static
r_int
id|hexToInt
c_func
(paren
r_char
op_star
op_star
id|ptr
comma
r_int
op_star
id|intValue
)paren
suffix:semicolon
r_static
r_int
id|hexToLong
c_func
(paren
r_char
op_star
op_star
id|ptr
comma
r_int
op_star
id|longValue
)paren
suffix:semicolon
r_static
r_int
r_char
op_star
id|mem2hex
c_func
(paren
r_char
op_star
id|mem
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
r_int
id|may_fault
)paren
suffix:semicolon
r_void
id|handle_exception
c_func
(paren
r_struct
id|gdb_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|variable|kgdb_enabled
r_int
id|kgdb_enabled
suffix:semicolon
multiline_comment|/*&n; * spin locks for smp case&n; */
DECL|variable|kgdb_lock
r_static
id|spinlock_t
id|kgdb_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|kgdb_cpulock
r_static
id|spinlock_t
id|kgdb_cpulock
(braket
id|NR_CPUS
)braket
op_assign
(brace
(braket
l_int|0
dot
dot
dot
id|NR_CPUS
op_minus
l_int|1
)braket
op_assign
id|SPIN_LOCK_UNLOCKED
)brace
suffix:semicolon
multiline_comment|/*&n; * BUFMAX defines the maximum number of characters in inbound/outbound buffers&n; * at least NUMREGBYTES*2 are needed for register packets&n; */
DECL|macro|BUFMAX
mdefine_line|#define BUFMAX 2048
DECL|variable|input_buffer
r_static
r_char
id|input_buffer
(braket
id|BUFMAX
)braket
suffix:semicolon
DECL|variable|output_buffer
r_static
r_char
id|output_buffer
(braket
id|BUFMAX
)braket
suffix:semicolon
DECL|variable|initialized
r_static
r_int
id|initialized
suffix:semicolon
multiline_comment|/* !0 means we&squot;ve been initialized */
DECL|variable|kgdb_started
r_static
r_int
id|kgdb_started
suffix:semicolon
DECL|variable|hexchars
r_static
r_const
r_char
id|hexchars
(braket
)braket
op_assign
l_string|&quot;0123456789abcdef&quot;
suffix:semicolon
multiline_comment|/* Used to prevent crashes in memory access.  Note that they&squot;ll crash anyway if&n;   we haven&squot;t set up fault handlers yet... */
r_int
id|kgdb_read_byte
c_func
(paren
r_int
r_char
op_star
id|address
comma
r_int
r_char
op_star
id|dest
)paren
suffix:semicolon
r_int
id|kgdb_write_byte
c_func
(paren
r_int
r_char
id|val
comma
r_int
r_char
op_star
id|dest
)paren
suffix:semicolon
multiline_comment|/*&n; * Convert ch from a hex digit to an int&n; */
DECL|function|hex
r_static
r_int
id|hex
c_func
(paren
r_int
r_char
id|ch
)paren
(brace
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;a&squot;
op_logical_and
id|ch
op_le
l_char|&squot;f&squot;
)paren
r_return
id|ch
op_minus
l_char|&squot;a&squot;
op_plus
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;0&squot;
op_logical_and
id|ch
op_le
l_char|&squot;9&squot;
)paren
r_return
id|ch
op_minus
l_char|&squot;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;A&squot;
op_logical_and
id|ch
op_le
l_char|&squot;F&squot;
)paren
r_return
id|ch
op_minus
l_char|&squot;A&squot;
op_plus
l_int|10
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * scan for the sequence $&lt;data&gt;#&lt;checksum&gt;&n; */
DECL|function|getpacket
r_static
r_void
id|getpacket
c_func
(paren
r_char
op_star
id|buffer
)paren
(brace
r_int
r_char
id|checksum
suffix:semicolon
r_int
r_char
id|xmitcsum
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; * wait around for the start character,&n;&t;&t; * ignore all other characters&n;&t;&t; */
r_while
c_loop
(paren
(paren
id|ch
op_assign
(paren
id|getDebugChar
c_func
(paren
)paren
op_amp
l_int|0x7f
)paren
)paren
op_ne
l_char|&squot;$&squot;
)paren
suffix:semicolon
id|checksum
op_assign
l_int|0
suffix:semicolon
id|xmitcsum
op_assign
op_minus
l_int|1
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * now, read until a # or end of buffer is found&n;&t;&t; */
r_while
c_loop
(paren
id|count
OL
id|BUFMAX
)paren
(brace
id|ch
op_assign
id|getDebugChar
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;#&squot;
)paren
r_break
suffix:semicolon
id|checksum
op_assign
id|checksum
op_plus
id|ch
suffix:semicolon
id|buffer
(braket
id|count
)braket
op_assign
id|ch
suffix:semicolon
id|count
op_assign
id|count
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_ge
id|BUFMAX
)paren
r_continue
suffix:semicolon
id|buffer
(braket
id|count
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;#&squot;
)paren
(brace
id|xmitcsum
op_assign
id|hex
c_func
(paren
id|getDebugChar
c_func
(paren
)paren
op_amp
l_int|0x7f
)paren
op_lshift
l_int|4
suffix:semicolon
id|xmitcsum
op_or_assign
id|hex
c_func
(paren
id|getDebugChar
c_func
(paren
)paren
op_amp
l_int|0x7f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|checksum
op_ne
id|xmitcsum
)paren
id|putDebugChar
c_func
(paren
l_char|&squot;-&squot;
)paren
suffix:semicolon
multiline_comment|/* failed checksum */
r_else
(brace
id|putDebugChar
c_func
(paren
l_char|&squot;+&squot;
)paren
suffix:semicolon
multiline_comment|/* successful transfer */
multiline_comment|/*&n;&t;&t;&t;&t; * if a sequence char is present,&n;&t;&t;&t;&t; * reply the sequence ID&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|buffer
(braket
l_int|2
)braket
op_eq
l_char|&squot;:&squot;
)paren
(brace
id|putDebugChar
c_func
(paren
id|buffer
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|putDebugChar
c_func
(paren
id|buffer
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * remove sequence chars from buffer&n;&t;&t;&t;&t;&t; */
id|count
op_assign
id|strlen
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|3
suffix:semicolon
id|i
op_le
id|count
suffix:semicolon
id|i
op_increment
)paren
id|buffer
(braket
id|i
op_minus
l_int|3
)braket
op_assign
id|buffer
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
)brace
)brace
r_while
c_loop
(paren
id|checksum
op_ne
id|xmitcsum
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * send the packet in buffer.&n; */
DECL|function|putpacket
r_static
r_void
id|putpacket
c_func
(paren
r_char
op_star
id|buffer
)paren
(brace
r_int
r_char
id|checksum
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
multiline_comment|/*&n;&t; * $&lt;packet info&gt;#&lt;checksum&gt;.&n;&t; */
r_do
(brace
id|putDebugChar
c_func
(paren
l_char|&squot;$&squot;
)paren
suffix:semicolon
id|checksum
op_assign
l_int|0
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ch
op_assign
id|buffer
(braket
id|count
)braket
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|putDebugChar
c_func
(paren
id|ch
)paren
)paren
)paren
r_return
suffix:semicolon
id|checksum
op_add_assign
id|ch
suffix:semicolon
id|count
op_add_assign
l_int|1
suffix:semicolon
)brace
id|putDebugChar
c_func
(paren
l_char|&squot;#&squot;
)paren
suffix:semicolon
id|putDebugChar
c_func
(paren
id|hexchars
(braket
id|checksum
op_rshift
l_int|4
)braket
)paren
suffix:semicolon
id|putDebugChar
c_func
(paren
id|hexchars
(braket
id|checksum
op_amp
l_int|0xf
)braket
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|getDebugChar
c_func
(paren
)paren
op_amp
l_int|0x7f
)paren
op_ne
l_char|&squot;+&squot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert the memory pointed to by mem into hex, placing result in buf.&n; * Return a pointer to the last char put in buf (null), in case of mem fault,&n; * return 0.&n; * may_fault is non-zero if we are reading from arbitrary memory, but is currently&n; * not used.&n; */
DECL|function|mem2hex
r_static
r_int
r_char
op_star
id|mem2hex
c_func
(paren
r_char
op_star
id|mem
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
r_int
id|may_fault
)paren
(brace
r_int
r_char
id|ch
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|kgdb_read_byte
c_func
(paren
id|mem
op_increment
comma
op_amp
id|ch
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
op_amp
l_int|0xf
)braket
suffix:semicolon
)brace
op_star
id|buf
op_assign
l_int|0
suffix:semicolon
r_return
id|buf
suffix:semicolon
)brace
multiline_comment|/*&n; * convert the hex array pointed to by buf into binary to be placed in mem&n; * return a pointer to the character AFTER the last byte written&n; * may_fault is non-zero if we are reading from arbitrary memory, but is currently&n; * not used.&n; */
DECL|function|hex2mem
r_static
r_char
op_star
id|hex2mem
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
id|mem
comma
r_int
id|count
comma
r_int
id|binary
comma
r_int
id|may_fault
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|binary
)paren
(brace
id|ch
op_assign
op_star
id|buf
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_int|0x7d
)paren
id|ch
op_assign
l_int|0x20
op_xor
op_star
id|buf
op_increment
suffix:semicolon
)brace
r_else
(brace
id|ch
op_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
op_lshift
l_int|4
suffix:semicolon
id|ch
op_or_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kgdb_write_byte
c_func
(paren
id|ch
comma
id|mem
op_increment
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|mem
suffix:semicolon
)brace
multiline_comment|/*&n; * This table contains the mapping between SPARC hardware trap types, and&n; * signals, which are primarily what GDB understands.  It also indicates&n; * which hardware traps we need to commandeer when initializing the stub.&n; */
DECL|struct|hard_trap_info
r_static
r_struct
id|hard_trap_info
(brace
DECL|member|tt
r_int
r_char
id|tt
suffix:semicolon
multiline_comment|/* Trap type code for MIPS R3xxx and R4xxx */
DECL|member|signo
r_int
r_char
id|signo
suffix:semicolon
multiline_comment|/* Signal that we map this trap into */
DECL|variable|hard_trap_info
)brace
id|hard_trap_info
(braket
)braket
op_assign
(brace
(brace
l_int|6
comma
id|SIGBUS
)brace
comma
multiline_comment|/* instruction bus error */
(brace
l_int|7
comma
id|SIGBUS
)brace
comma
multiline_comment|/* data bus error */
(brace
l_int|9
comma
id|SIGTRAP
)brace
comma
multiline_comment|/* break */
(brace
l_int|10
comma
id|SIGILL
)brace
comma
multiline_comment|/* reserved instruction */
multiline_comment|/*&t;{ 11, SIGILL },&t;&t;*/
multiline_comment|/* CPU unusable */
(brace
l_int|12
comma
id|SIGFPE
)brace
comma
multiline_comment|/* overflow */
(brace
l_int|13
comma
id|SIGTRAP
)brace
comma
multiline_comment|/* trap */
(brace
l_int|14
comma
id|SIGSEGV
)brace
comma
multiline_comment|/* virtual instruction cache coherency */
(brace
l_int|15
comma
id|SIGFPE
)brace
comma
multiline_comment|/* floating point exception */
(brace
l_int|23
comma
id|SIGSEGV
)brace
comma
multiline_comment|/* watch */
(brace
l_int|31
comma
id|SIGSEGV
)brace
comma
multiline_comment|/* virtual data cache coherency */
(brace
l_int|0
comma
l_int|0
)brace
multiline_comment|/* Must be last */
)brace
suffix:semicolon
multiline_comment|/* Save the normal trap handlers for user-mode traps. */
DECL|variable|saved_vectors
r_void
op_star
id|saved_vectors
(braket
l_int|32
)braket
suffix:semicolon
multiline_comment|/*&n; * Set up exception handlers for tracing and breakpoints&n; */
DECL|function|set_debug_traps
r_void
id|set_debug_traps
c_func
(paren
r_void
)paren
(brace
r_struct
id|hard_trap_info
op_star
id|ht
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|c
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ht
op_assign
id|hard_trap_info
suffix:semicolon
id|ht-&gt;tt
op_logical_and
id|ht-&gt;signo
suffix:semicolon
id|ht
op_increment
)paren
id|saved_vectors
(braket
id|ht-&gt;tt
)braket
op_assign
id|set_except_vector
c_func
(paren
id|ht-&gt;tt
comma
id|trap_low
)paren
suffix:semicolon
id|putDebugChar
c_func
(paren
l_char|&squot;+&squot;
)paren
suffix:semicolon
multiline_comment|/* &squot;hello world&squot; */
multiline_comment|/*&n;&t; * In case GDB is started before us, ack any packets&n;&t; * (presumably &quot;$?#xx&quot;) sitting there.&n;&t; */
r_while
c_loop
(paren
(paren
id|c
op_assign
id|getDebugChar
c_func
(paren
)paren
)paren
op_ne
l_char|&squot;$&squot;
)paren
(brace
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|c
op_assign
id|getDebugChar
c_func
(paren
)paren
)paren
op_ne
l_char|&squot;#&squot;
)paren
(brace
suffix:semicolon
)brace
id|c
op_assign
id|getDebugChar
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* eat first csum byte */
id|c
op_assign
id|getDebugChar
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* eat second csum byte */
id|putDebugChar
c_func
(paren
l_char|&squot;+&squot;
)paren
suffix:semicolon
multiline_comment|/* ack it */
id|initialized
op_assign
l_int|1
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|restore_debug_traps
r_void
id|restore_debug_traps
c_func
(paren
r_void
)paren
(brace
r_struct
id|hard_trap_info
op_star
id|ht
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ht
op_assign
id|hard_trap_info
suffix:semicolon
id|ht-&gt;tt
op_logical_and
id|ht-&gt;signo
suffix:semicolon
id|ht
op_increment
)paren
id|set_except_vector
c_func
(paren
id|ht-&gt;tt
comma
id|saved_vectors
(braket
id|ht-&gt;tt
)braket
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert the MIPS hardware trap type code to a Unix signal number.&n; */
DECL|function|computeSignal
r_static
r_int
id|computeSignal
c_func
(paren
r_int
id|tt
)paren
(brace
r_struct
id|hard_trap_info
op_star
id|ht
suffix:semicolon
r_for
c_loop
(paren
id|ht
op_assign
id|hard_trap_info
suffix:semicolon
id|ht-&gt;tt
op_logical_and
id|ht-&gt;signo
suffix:semicolon
id|ht
op_increment
)paren
r_if
c_cond
(paren
id|ht-&gt;tt
op_eq
id|tt
)paren
r_return
id|ht-&gt;signo
suffix:semicolon
r_return
id|SIGHUP
suffix:semicolon
multiline_comment|/* default for things we don&squot;t know about */
)brace
multiline_comment|/*&n; * While we find nice hex chars, build an int.&n; * Return number of chars processed.&n; */
DECL|function|hexToInt
r_static
r_int
id|hexToInt
c_func
(paren
r_char
op_star
op_star
id|ptr
comma
r_int
op_star
id|intValue
)paren
(brace
r_int
id|numChars
op_assign
l_int|0
suffix:semicolon
r_int
id|hexValue
suffix:semicolon
op_star
id|intValue
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
op_star
id|ptr
)paren
(brace
id|hexValue
op_assign
id|hex
c_func
(paren
op_star
op_star
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hexValue
OL
l_int|0
)paren
r_break
suffix:semicolon
op_star
id|intValue
op_assign
(paren
op_star
id|intValue
op_lshift
l_int|4
)paren
op_or
id|hexValue
suffix:semicolon
id|numChars
op_increment
suffix:semicolon
(paren
op_star
id|ptr
)paren
op_increment
suffix:semicolon
)brace
r_return
(paren
id|numChars
)paren
suffix:semicolon
)brace
DECL|function|hexToLong
r_static
r_int
id|hexToLong
c_func
(paren
r_char
op_star
op_star
id|ptr
comma
r_int
op_star
id|longValue
)paren
(brace
r_int
id|numChars
op_assign
l_int|0
suffix:semicolon
r_int
id|hexValue
suffix:semicolon
op_star
id|longValue
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
op_star
id|ptr
)paren
(brace
id|hexValue
op_assign
id|hex
c_func
(paren
op_star
op_star
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hexValue
OL
l_int|0
)paren
r_break
suffix:semicolon
op_star
id|longValue
op_assign
(paren
op_star
id|longValue
op_lshift
l_int|4
)paren
op_or
id|hexValue
suffix:semicolon
id|numChars
op_increment
suffix:semicolon
(paren
op_star
id|ptr
)paren
op_increment
suffix:semicolon
)brace
r_return
id|numChars
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n; * Print registers (on target console)&n; * Used only to debug the stub...&n; */
r_void
id|show_gdbregs
c_func
(paren
r_struct
id|gdb_regs
op_star
id|regs
)paren
(brace
multiline_comment|/*&n;&t; * Saved main processor registers&n;&t; */
id|printk
c_func
(paren
l_string|&quot;$0 : %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx&bslash;n&quot;
comma
id|regs-&gt;reg0
comma
id|regs-&gt;reg1
comma
id|regs-&gt;reg2
comma
id|regs-&gt;reg3
comma
id|regs-&gt;reg4
comma
id|regs-&gt;reg5
comma
id|regs-&gt;reg6
comma
id|regs-&gt;reg7
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;$8 : %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx&bslash;n&quot;
comma
id|regs-&gt;reg8
comma
id|regs-&gt;reg9
comma
id|regs-&gt;reg10
comma
id|regs-&gt;reg11
comma
id|regs-&gt;reg12
comma
id|regs-&gt;reg13
comma
id|regs-&gt;reg14
comma
id|regs-&gt;reg15
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;$16: %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx&bslash;n&quot;
comma
id|regs-&gt;reg16
comma
id|regs-&gt;reg17
comma
id|regs-&gt;reg18
comma
id|regs-&gt;reg19
comma
id|regs-&gt;reg20
comma
id|regs-&gt;reg21
comma
id|regs-&gt;reg22
comma
id|regs-&gt;reg23
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;$24: %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx&bslash;n&quot;
comma
id|regs-&gt;reg24
comma
id|regs-&gt;reg25
comma
id|regs-&gt;reg26
comma
id|regs-&gt;reg27
comma
id|regs-&gt;reg28
comma
id|regs-&gt;reg29
comma
id|regs-&gt;reg30
comma
id|regs-&gt;reg31
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Saved cp0 registers&n;&t; */
id|printk
c_func
(paren
l_string|&quot;epc  : %08lx&bslash;nStatus: %08lx&bslash;nCause : %08lx&bslash;n&quot;
comma
id|regs-&gt;cp0_epc
comma
id|regs-&gt;cp0_status
comma
id|regs-&gt;cp0_cause
)paren
suffix:semicolon
)brace
macro_line|#endif /* dead code */
multiline_comment|/*&n; * We single-step by setting breakpoints. When an exception&n; * is handled, we need to restore the instructions hoisted&n; * when the breakpoints were set.&n; *&n; * This is where we save the original instructions.&n; */
DECL|struct|gdb_bp_save
r_static
r_struct
id|gdb_bp_save
(brace
DECL|member|addr
r_int
r_int
id|addr
suffix:semicolon
DECL|member|val
r_int
r_int
id|val
suffix:semicolon
DECL|variable|step_bp
)brace
id|step_bp
(braket
l_int|2
)braket
suffix:semicolon
DECL|macro|BP
mdefine_line|#define BP 0x0000000d  /* break opcode */
multiline_comment|/*&n; * Set breakpoint instructions for single stepping.&n; */
DECL|function|single_step
r_static
r_void
id|single_step
c_func
(paren
r_struct
id|gdb_regs
op_star
id|regs
)paren
(brace
r_union
id|mips_instruction
id|insn
suffix:semicolon
r_int
r_int
id|targ
suffix:semicolon
r_int
id|is_branch
comma
id|is_cond
comma
id|i
suffix:semicolon
id|targ
op_assign
id|regs-&gt;cp0_epc
suffix:semicolon
id|insn.word
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|targ
suffix:semicolon
id|is_branch
op_assign
id|is_cond
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|insn.i_format.opcode
)paren
(brace
multiline_comment|/*&n;&t; * jr and jalr are in r_format format.&n;&t; */
r_case
id|spec_op
suffix:colon
r_switch
c_cond
(paren
id|insn.r_format.func
)paren
(brace
r_case
id|jalr_op
suffix:colon
r_case
id|jr_op
suffix:colon
id|targ
op_assign
op_star
(paren
op_amp
id|regs-&gt;reg0
op_plus
id|insn.r_format.rs
)paren
suffix:semicolon
id|is_branch
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/*&n;&t; * This group contains:&n;&t; * bltz_op, bgez_op, bltzl_op, bgezl_op,&n;&t; * bltzal_op, bgezal_op, bltzall_op, bgezall_op.&n;&t; */
r_case
id|bcond_op
suffix:colon
id|is_branch
op_assign
id|is_cond
op_assign
l_int|1
suffix:semicolon
id|targ
op_add_assign
l_int|4
op_plus
(paren
id|insn.i_format.simmediate
op_lshift
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t; * These are unconditional and in j_format.&n;&t; */
r_case
id|jal_op
suffix:colon
r_case
id|j_op
suffix:colon
id|is_branch
op_assign
l_int|1
suffix:semicolon
id|targ
op_add_assign
l_int|4
suffix:semicolon
id|targ
op_rshift_assign
l_int|28
suffix:semicolon
id|targ
op_lshift_assign
l_int|28
suffix:semicolon
id|targ
op_or_assign
(paren
id|insn.j_format.target
op_lshift
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t; * These are conditional.&n;&t; */
r_case
id|beq_op
suffix:colon
r_case
id|beql_op
suffix:colon
r_case
id|bne_op
suffix:colon
r_case
id|bnel_op
suffix:colon
r_case
id|blez_op
suffix:colon
r_case
id|blezl_op
suffix:colon
r_case
id|bgtz_op
suffix:colon
r_case
id|bgtzl_op
suffix:colon
r_case
id|cop0_op
suffix:colon
r_case
id|cop1_op
suffix:colon
r_case
id|cop2_op
suffix:colon
r_case
id|cop1x_op
suffix:colon
id|is_branch
op_assign
id|is_cond
op_assign
l_int|1
suffix:semicolon
id|targ
op_add_assign
l_int|4
op_plus
(paren
id|insn.i_format.simmediate
op_lshift
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_branch
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|is_cond
op_logical_and
id|targ
op_ne
(paren
id|regs-&gt;cp0_epc
op_plus
l_int|8
)paren
)paren
(brace
id|step_bp
(braket
id|i
)braket
dot
id|addr
op_assign
id|regs-&gt;cp0_epc
op_plus
l_int|8
suffix:semicolon
id|step_bp
(braket
id|i
op_increment
)braket
dot
id|val
op_assign
op_star
(paren
r_int
op_star
)paren
(paren
id|regs-&gt;cp0_epc
op_plus
l_int|8
)paren
suffix:semicolon
op_star
(paren
r_int
op_star
)paren
(paren
id|regs-&gt;cp0_epc
op_plus
l_int|8
)paren
op_assign
id|BP
suffix:semicolon
)brace
id|step_bp
(braket
id|i
)braket
dot
id|addr
op_assign
id|targ
suffix:semicolon
id|step_bp
(braket
id|i
)braket
dot
id|val
op_assign
op_star
(paren
r_int
op_star
)paren
id|targ
suffix:semicolon
op_star
(paren
r_int
op_star
)paren
id|targ
op_assign
id|BP
suffix:semicolon
)brace
r_else
(brace
id|step_bp
(braket
l_int|0
)braket
dot
id|addr
op_assign
id|regs-&gt;cp0_epc
op_plus
l_int|4
suffix:semicolon
id|step_bp
(braket
l_int|0
)braket
dot
id|val
op_assign
op_star
(paren
r_int
op_star
)paren
(paren
id|regs-&gt;cp0_epc
op_plus
l_int|4
)paren
suffix:semicolon
op_star
(paren
r_int
op_star
)paren
(paren
id|regs-&gt;cp0_epc
op_plus
l_int|4
)paren
op_assign
id|BP
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *  If asynchronously interrupted by gdb, then we need to set a breakpoint&n; *  at the interrupted instruction so that we wind up stopped with a&n; *  reasonable stack frame.&n; */
DECL|variable|async_bp
r_static
r_struct
id|gdb_bp_save
id|async_bp
suffix:semicolon
multiline_comment|/*&n; * Swap the interrupted EPC with our asynchronous breakpoint routine.&n; * This is safer than stuffing the breakpoint in-place, since no cache&n; * flushes (or resulting smp_call_functions) are required.  The&n; * assumption is that only one CPU will be handling asynchronous bp&squot;s,&n; * and only one can be active at a time.&n; */
r_extern
id|spinlock_t
id|smp_call_lock
suffix:semicolon
DECL|function|set_async_breakpoint
r_void
id|set_async_breakpoint
c_func
(paren
r_int
r_int
op_star
id|epc
)paren
(brace
multiline_comment|/* skip breaking into userland */
r_if
c_cond
(paren
(paren
op_star
id|epc
op_amp
l_int|0x80000000
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* avoid deadlock if someone is make IPC */
r_if
c_cond
(paren
id|spin_is_locked
c_func
(paren
op_amp
id|smp_call_lock
)paren
)paren
r_return
suffix:semicolon
id|async_bp.addr
op_assign
op_star
id|epc
suffix:semicolon
op_star
id|epc
op_assign
(paren
r_int
r_int
)paren
id|async_breakpoint
suffix:semicolon
)brace
DECL|function|kgdb_wait
r_void
id|kgdb_wait
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
r_int
id|flags
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|kgdb_cpulock
(braket
id|cpu
)braket
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|kgdb_cpulock
(braket
id|cpu
)braket
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function does all command processing for interfacing to gdb.  It&n; * returns 1 if you should skip the instruction at the trap address, 0&n; * otherwise.&n; */
DECL|function|handle_exception
r_void
id|handle_exception
(paren
r_struct
id|gdb_regs
op_star
id|regs
)paren
(brace
r_int
id|trap
suffix:semicolon
multiline_comment|/* Trap type */
r_int
id|sigval
suffix:semicolon
r_int
id|addr
suffix:semicolon
r_int
id|length
suffix:semicolon
r_char
op_star
id|ptr
suffix:semicolon
r_int
r_int
op_star
id|stack
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|bflag
op_assign
l_int|0
suffix:semicolon
id|kgdb_started
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * acquire the big kgdb spinlock&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|spin_trylock
c_func
(paren
op_amp
id|kgdb_lock
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t; * some other CPU has the lock, we should go back to &n;&t;&t; * receive the gdb_wait IPC&n;&t;&t; */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we&squot;re in async_breakpoint(), restore the real EPC from&n;&t; * the breakpoint.&n;&t; */
r_if
c_cond
(paren
id|regs-&gt;cp0_epc
op_eq
(paren
r_int
r_int
)paren
id|async_breakinst
)paren
(brace
id|regs-&gt;cp0_epc
op_assign
id|async_bp.addr
suffix:semicolon
id|async_bp.addr
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * acquire the CPU spinlocks&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|num_online_cpus
c_func
(paren
)paren
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
r_if
c_cond
(paren
id|spin_trylock
c_func
(paren
op_amp
id|kgdb_cpulock
(braket
id|i
)braket
)paren
op_eq
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;kgdb: couldn&squot;t get cpulock %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * force other cpus to enter kgdb&n;&t; */
id|smp_call_function
c_func
(paren
id|kgdb_wait
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re in breakpoint() increment the PC&n;&t; */
id|trap
op_assign
(paren
id|regs-&gt;cp0_cause
op_amp
l_int|0x7c
)paren
op_rshift
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|trap
op_eq
l_int|9
op_logical_and
id|regs-&gt;cp0_epc
op_eq
(paren
r_int
r_int
)paren
id|breakinst
)paren
id|regs-&gt;cp0_epc
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/*&n;&t; * If we were single_stepping, restore the opcodes hoisted&n;&t; * for the breakpoint[s].&n;&t; */
r_if
c_cond
(paren
id|step_bp
(braket
l_int|0
)braket
dot
id|addr
)paren
(brace
op_star
(paren
r_int
op_star
)paren
id|step_bp
(braket
l_int|0
)braket
dot
id|addr
op_assign
id|step_bp
(braket
l_int|0
)braket
dot
id|val
suffix:semicolon
id|step_bp
(braket
l_int|0
)braket
dot
id|addr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|step_bp
(braket
l_int|1
)braket
dot
id|addr
)paren
(brace
op_star
(paren
r_int
op_star
)paren
id|step_bp
(braket
l_int|1
)braket
dot
id|addr
op_assign
id|step_bp
(braket
l_int|1
)braket
dot
id|val
suffix:semicolon
id|step_bp
(braket
l_int|1
)braket
dot
id|addr
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|stack
op_assign
(paren
r_int
op_star
)paren
id|regs-&gt;reg29
suffix:semicolon
multiline_comment|/* stack ptr */
id|sigval
op_assign
id|computeSignal
c_func
(paren
id|trap
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * reply to host that an exception has occurred&n;&t; */
id|ptr
op_assign
id|output_buffer
suffix:semicolon
multiline_comment|/*&n;&t; * Send trap type (converted to signal)&n;&t; */
op_star
id|ptr
op_increment
op_assign
l_char|&squot;T&squot;
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|sigval
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|sigval
op_amp
l_int|0xf
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Send Error PC&n;&t; */
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|REG_EPC
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|REG_EPC
op_amp
l_int|0xf
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;:&squot;
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;cp0_epc
comma
id|ptr
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;;&squot;
suffix:semicolon
multiline_comment|/*&n;&t; * Send frame pointer&n;&t; */
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|REG_FP
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|REG_FP
op_amp
l_int|0xf
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;:&squot;
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;reg30
comma
id|ptr
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;;&squot;
suffix:semicolon
multiline_comment|/*&n;&t; * Send stack pointer&n;&t; */
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|REG_SP
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|REG_SP
op_amp
l_int|0xf
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;:&squot;
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;reg29
comma
id|ptr
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_char|&squot;;&squot;
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_int|0
suffix:semicolon
id|putpacket
c_func
(paren
id|output_buffer
)paren
suffix:semicolon
multiline_comment|/* send it off... */
multiline_comment|/*&n;&t; * Wait for input from remote GDB&n;&t; */
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|output_buffer
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|getpacket
c_func
(paren
id|input_buffer
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|input_buffer
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;?&squot;
suffix:colon
id|output_buffer
(braket
l_int|0
)braket
op_assign
l_char|&squot;S&squot;
suffix:semicolon
id|output_buffer
(braket
l_int|1
)braket
op_assign
id|hexchars
(braket
id|sigval
op_rshift
l_int|4
)braket
suffix:semicolon
id|output_buffer
(braket
l_int|2
)braket
op_assign
id|hexchars
(braket
id|sigval
op_amp
l_int|0xf
)braket
suffix:semicolon
id|output_buffer
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Detach debugger; let CPU run&n;&t;&t; */
r_case
l_char|&squot;D&squot;
suffix:colon
id|putpacket
c_func
(paren
id|output_buffer
)paren
suffix:semicolon
r_goto
id|finish_kgdb
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;d&squot;
suffix:colon
multiline_comment|/* toggle debug flag */
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Return the value of the CPU registers&n;&t;&t; */
r_case
l_char|&squot;g&squot;
suffix:colon
id|ptr
op_assign
id|output_buffer
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;reg0
comma
id|ptr
comma
l_int|32
op_star
r_sizeof
(paren
r_int
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* r0...r31 */
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;cp0_status
comma
id|ptr
comma
l_int|6
op_star
r_sizeof
(paren
r_int
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* cp0 */
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;fpr0
comma
id|ptr
comma
l_int|32
op_star
r_sizeof
(paren
r_int
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* f0...31 */
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;cp1_fsr
comma
id|ptr
comma
l_int|2
op_star
r_sizeof
(paren
r_int
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* cp1 */
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;frame_ptr
comma
id|ptr
comma
l_int|2
op_star
r_sizeof
(paren
r_int
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* frp */
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;cp0_index
comma
id|ptr
comma
l_int|16
op_star
r_sizeof
(paren
r_int
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* cp0 */
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * set the value of the CPU registers - return OK&n;&t;&t; */
r_case
l_char|&squot;G&squot;
suffix:colon
(brace
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
id|hex2mem
c_func
(paren
id|ptr
comma
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;reg0
comma
l_int|32
op_star
r_sizeof
(paren
r_int
)paren
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ptr
op_add_assign
l_int|32
op_star
(paren
l_int|2
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|hex2mem
c_func
(paren
id|ptr
comma
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;cp0_status
comma
l_int|6
op_star
r_sizeof
(paren
r_int
)paren
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ptr
op_add_assign
l_int|6
op_star
(paren
l_int|2
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|hex2mem
c_func
(paren
id|ptr
comma
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;fpr0
comma
l_int|32
op_star
r_sizeof
(paren
r_int
)paren
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ptr
op_add_assign
l_int|32
op_star
(paren
l_int|2
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|hex2mem
c_func
(paren
id|ptr
comma
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;cp1_fsr
comma
l_int|2
op_star
r_sizeof
(paren
r_int
)paren
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ptr
op_add_assign
l_int|2
op_star
(paren
l_int|2
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|hex2mem
c_func
(paren
id|ptr
comma
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;frame_ptr
comma
l_int|2
op_star
r_sizeof
(paren
r_int
)paren
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ptr
op_add_assign
l_int|2
op_star
(paren
l_int|2
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|hex2mem
c_func
(paren
id|ptr
comma
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;cp0_index
comma
l_int|16
op_star
r_sizeof
(paren
r_int
)paren
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;OK&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * mAA..AA,LLLL  Read LLLL bytes at address AA..AA&n;&t;&t; */
r_case
l_char|&squot;m&squot;
suffix:colon
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hexToLong
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|addr
)paren
op_logical_and
op_star
id|ptr
op_increment
op_eq
l_char|&squot;,&squot;
op_logical_and
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|length
)paren
)paren
(brace
r_if
c_cond
(paren
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
id|addr
comma
id|output_buffer
comma
id|length
comma
l_int|1
)paren
)paren
r_break
suffix:semicolon
id|strcpy
(paren
id|output_buffer
comma
l_string|&quot;E03&quot;
)paren
suffix:semicolon
)brace
r_else
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E01&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * XAA..AA,LLLL: Write LLLL escaped binary bytes at address AA.AA&n;&t;&t; */
r_case
l_char|&squot;X&squot;
suffix:colon
id|bflag
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* fall through */
multiline_comment|/*&n;&t;&t; * MAA..AA,LLLL: Write LLLL bytes at address AA.AA return OK&n;&t;&t; */
r_case
l_char|&squot;M&squot;
suffix:colon
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hexToLong
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|addr
)paren
op_logical_and
op_star
id|ptr
op_increment
op_eq
l_char|&squot;,&squot;
op_logical_and
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|length
)paren
op_logical_and
op_star
id|ptr
op_increment
op_eq
l_char|&squot;:&squot;
)paren
(brace
r_if
c_cond
(paren
id|hex2mem
c_func
(paren
id|ptr
comma
(paren
r_char
op_star
)paren
id|addr
comma
id|length
comma
id|bflag
comma
l_int|1
)paren
)paren
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;OK&quot;
)paren
suffix:semicolon
r_else
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E03&quot;
)paren
suffix:semicolon
)brace
r_else
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E02&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * cAA..AA    Continue at address AA..AA(optional)&n;&t;&t; */
r_case
l_char|&squot;c&squot;
suffix:colon
multiline_comment|/* try to read optional parameter, pc unchanged if no parm */
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hexToLong
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|addr
)paren
)paren
id|regs-&gt;cp0_epc
op_assign
id|addr
suffix:semicolon
r_goto
id|exit_kgdb_exception
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * kill the program; let us try to restart the machine&n;&t;&t; * Reset the whole machine.&n;&t;&t; */
r_case
l_char|&squot;k&squot;
suffix:colon
r_case
l_char|&squot;r&squot;
suffix:colon
id|machine_restart
c_func
(paren
l_string|&quot;kgdb restarts machine&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Step to next instruction&n;&t;&t; */
r_case
l_char|&squot;s&squot;
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * There is no single step insn in the MIPS ISA, so we&n;&t;&t;&t; * use breakpoints and continue, instead.&n;&t;&t;&t; */
id|single_step
c_func
(paren
id|regs
)paren
suffix:semicolon
r_goto
id|exit_kgdb_exception
suffix:semicolon
multiline_comment|/* NOTREACHED */
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set baud rate (bBB)&n;&t;&t; * FIXME: Needs to be written&n;&t;&t; */
r_case
l_char|&squot;b&squot;
suffix:colon
(brace
macro_line|#if 0
r_int
id|baudrate
suffix:semicolon
r_extern
r_void
id|set_timer_3
c_func
(paren
)paren
suffix:semicolon
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|baudrate
)paren
)paren
(brace
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;B01&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Convert baud rate to uart clock divider */
r_switch
c_cond
(paren
id|baudrate
)paren
(brace
r_case
l_int|38400
suffix:colon
id|baudrate
op_assign
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|19200
suffix:colon
id|baudrate
op_assign
l_int|33
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9600
suffix:colon
id|baudrate
op_assign
l_int|65
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|baudrate
op_assign
l_int|0
suffix:semicolon
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;B02&quot;
)paren
suffix:semicolon
r_goto
id|x1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|baudrate
)paren
(brace
id|putpacket
c_func
(paren
l_string|&quot;OK&quot;
)paren
suffix:semicolon
multiline_comment|/* Ack before changing speed */
id|set_timer_3
c_func
(paren
id|baudrate
)paren
suffix:semicolon
multiline_comment|/* Set it */
)brace
macro_line|#endif
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* switch */
multiline_comment|/*&n;&t;&t; * reply to the request&n;&t;&t; */
id|putpacket
c_func
(paren
id|output_buffer
)paren
suffix:semicolon
)brace
multiline_comment|/* while */
r_return
suffix:semicolon
id|finish_kgdb
suffix:colon
id|restore_debug_traps
c_func
(paren
)paren
suffix:semicolon
id|exit_kgdb_exception
suffix:colon
multiline_comment|/* release locks so other CPUs can go */
r_for
c_loop
(paren
id|i
op_assign
id|num_online_cpus
c_func
(paren
)paren
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
id|spin_unlock
c_func
(paren
op_amp
id|kgdb_cpulock
(braket
id|i
)braket
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|kgdb_lock
)paren
suffix:semicolon
id|__flush_cache_all
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This function will generate a breakpoint exception.  It is used at the&n; * beginning of a program to sync up with a debugger and can be used&n; * otherwise as a quick means to stop program execution and &quot;break&quot; into&n; * the debugger.&n; */
DECL|function|breakpoint
r_void
id|breakpoint
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|initialized
)paren
r_return
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;.globl&t;breakinst&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tnoreorder&bslash;n&bslash;t&quot;
l_string|&quot;nop&bslash;n&quot;
l_string|&quot;breakinst:&bslash;tbreak&bslash;n&bslash;t&quot;
l_string|&quot;nop&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;treorder&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Nothing but the break; don&squot;t pollute any registers */
DECL|function|async_breakpoint
r_void
id|async_breakpoint
c_func
(paren
r_void
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;.globl&t;async_breakinst&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tnoreorder&bslash;n&bslash;t&quot;
l_string|&quot;nop&bslash;n&quot;
l_string|&quot;async_breakinst:&bslash;tbreak&bslash;n&bslash;t&quot;
l_string|&quot;nop&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;treorder&quot;
)paren
suffix:semicolon
)brace
DECL|function|adel
r_void
id|adel
c_func
(paren
r_void
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;.globl&bslash;tadel&bslash;n&bslash;t&quot;
l_string|&quot;lui&bslash;t$8,0x8000&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t$9,1($8)&bslash;n&bslash;t&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * malloc is needed by gdb client in &quot;call func()&quot;, even a private one&n; * will make gdb happy&n; */
DECL|function|malloc
r_static
r_void
op_star
id|malloc
c_func
(paren
r_int
id|size
)paren
(brace
r_return
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
)brace
DECL|function|free
r_static
r_void
id|free
c_func
(paren
r_void
op_star
id|where
)paren
(brace
id|kfree
c_func
(paren
id|where
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_GDB_CONSOLE
DECL|function|gdb_putsn
r_void
id|gdb_putsn
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_int
id|l
)paren
(brace
r_char
id|outbuf
(braket
l_int|18
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kgdb_started
)paren
r_return
suffix:semicolon
id|outbuf
(braket
l_int|0
)braket
op_assign
l_char|&squot;O&squot;
suffix:semicolon
r_while
c_loop
(paren
id|l
)paren
(brace
r_int
id|i
op_assign
(paren
id|l
OG
l_int|8
)paren
ques
c_cond
l_int|8
suffix:colon
id|l
suffix:semicolon
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
id|str
comma
op_amp
id|outbuf
(braket
l_int|1
)braket
comma
id|i
comma
l_int|0
)paren
suffix:semicolon
id|outbuf
(braket
(paren
id|i
op_star
l_int|2
)paren
op_plus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|putpacket
c_func
(paren
id|outbuf
)paren
suffix:semicolon
id|str
op_add_assign
id|i
suffix:semicolon
id|l
op_sub_assign
id|i
suffix:semicolon
)brace
)brace
DECL|function|gdb_console_write
r_static
r_void
id|gdb_console_write
c_func
(paren
r_struct
id|console
op_star
id|con
comma
r_const
r_char
op_star
id|s
comma
r_int
id|n
)paren
(brace
id|gdb_putsn
c_func
(paren
id|s
comma
id|n
)paren
suffix:semicolon
)brace
DECL|variable|gdb_console
r_static
r_struct
id|console
id|gdb_console
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;gdb&quot;
comma
dot
id|write
op_assign
id|gdb_console_write
comma
dot
id|flags
op_assign
id|CON_PRINTBUFFER
comma
dot
id|index
op_assign
op_minus
l_int|1
)brace
suffix:semicolon
DECL|function|register_gdb_console
r_static
r_int
id|__init
id|register_gdb_console
c_func
(paren
r_void
)paren
(brace
id|register_console
c_func
(paren
op_amp
id|gdb_console
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|register_gdb_console
id|console_initcall
c_func
(paren
id|register_gdb_console
)paren
suffix:semicolon
macro_line|#endif
eof
