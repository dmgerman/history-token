multiline_comment|/*&n; * MIPS-specific semaphore code.&n; *&n; * Copyright (C) 1999 Cort Dougan &lt;cort@cs.nmt.edu&gt;&n; * Copyright (C) 2004 Ralf Baechle &lt;ralf@linux-mips.org&gt;&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; *&n; * April 2001 - Reworked by Paul Mackerras &lt;paulus@samba.org&gt;&n; * to eliminate the SMP races in the old version between the updates&n; * of `count&squot; and `waking&squot;.  Now we use negative `count&squot; values to&n; * indicate that some process(es) are waiting for the semaphore.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/cpu-features.h&gt;
macro_line|#include &lt;asm/errno.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/war.h&gt;
multiline_comment|/*&n; * Atomically update sem-&gt;count.&n; * This does the equivalent of the following:&n; *&n; *&t;old_count = sem-&gt;count;&n; *&t;tmp = MAX(old_count, 0) + incr;&n; *&t;sem-&gt;count = tmp;&n; *&t;return old_count;&n; *&n; * On machines without lld/scd we need a spinlock to make the manipulation of&n; * sem-&gt;count and sem-&gt;waking atomic.  Scalability isn&squot;t an issue because&n; * this lock is used on UP only so it&squot;s just an empty variable.&n; */
DECL|function|__sem_update_count
r_static
r_inline
r_int
id|__sem_update_count
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
comma
r_int
id|incr
)paren
(brace
r_int
id|old_count
comma
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|cpu_has_llsc
op_logical_and
id|R10000_LLSC_WAR
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ll&t;%0, %2&t;&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;sra&t;%1, %0, 31&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;not&t;%1&t;&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;and&t;%1, %0, %1&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;add&t;%1, %1, %3&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;sc&t;%1, %2&t;&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;beqzl&t;%1, 1b&t;&t;&t;&t;&t;&bslash;n&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|old_count
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp
)paren
comma
l_string|&quot;=m&quot;
(paren
id|sem-&gt;count
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|incr
)paren
comma
l_string|&quot;m&quot;
(paren
id|sem-&gt;count
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cpu_has_llsc
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ll&t;%0, %2&t;&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;sra&t;%1, %0, 31&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;not&t;%1&t;&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;and&t;%1, %0, %1&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;add&t;%1, %1, %3&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;sc&t;%1, %2&t;&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;beqz&t;%1, 1b&t;&t;&t;&t;&t;&bslash;n&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|old_count
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp
)paren
comma
l_string|&quot;=m&quot;
(paren
id|sem-&gt;count
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|incr
)paren
comma
l_string|&quot;m&quot;
(paren
id|sem-&gt;count
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|semaphore_lock
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|semaphore_lock
comma
id|flags
)paren
suffix:semicolon
id|old_count
op_assign
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;count
)paren
suffix:semicolon
id|tmp
op_assign
id|max_t
c_func
(paren
r_int
comma
id|old_count
comma
l_int|0
)paren
op_plus
id|incr
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|sem-&gt;count
comma
id|tmp
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|semaphore_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|old_count
suffix:semicolon
)brace
DECL|function|__up
r_void
id|__up
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
multiline_comment|/*&n;&t; * Note that we incremented count in up() before we came here,&n;&t; * but that was ineffective since the result was &lt;= 0, and&n;&t; * any negative value of count is equivalent to 0.&n;&t; * This ends up setting count to 1, unless count is now &gt; 0&n;&t; * (i.e. because some other cpu has called up() in the meantime),&n;&t; * in which case we just increment count.&n;&t; */
id|__sem_update_count
c_func
(paren
id|sem
comma
l_int|1
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
)brace
DECL|variable|__up
id|EXPORT_SYMBOL
c_func
(paren
id|__up
)paren
suffix:semicolon
multiline_comment|/*&n; * Note that when we come in to __down or __down_interruptible,&n; * we have already decremented count, but that decrement was&n; * ineffective since the result was &lt; 0, and any negative value&n; * of count is equivalent to 0.&n; * Thus it is only when we decrement count from some value &gt; 0&n; * that we have actually got the semaphore.&n; */
DECL|function|__down
r_void
id|__sched
id|__down
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
id|__set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Try to get the semaphore.  If the count is &gt; 0, then we&squot;ve&n;&t; * got the semaphore; we decrement count and exit the loop.&n;&t; * If the count is 0 or negative, we set it to -1, indicating&n;&t; * that we are asleep, and then sleep.&n;&t; */
r_while
c_loop
(paren
id|__sem_update_count
c_func
(paren
id|sem
comma
op_minus
l_int|1
)paren
op_le
l_int|0
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|__set_task_state
c_func
(paren
id|tsk
comma
id|TASK_RUNNING
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If there are any more sleepers, wake one of them up so&n;&t; * that it can either get the semaphore, or set count to -1&n;&t; * indicating that there are still processes sleeping.&n;&t; */
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
)brace
DECL|variable|__down
id|EXPORT_SYMBOL
c_func
(paren
id|__down
)paren
suffix:semicolon
DECL|function|__down_interruptible
r_int
id|__sched
id|__down_interruptible
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
id|__set_task_state
c_func
(paren
id|tsk
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
id|__sem_update_count
c_func
(paren
id|sem
comma
op_minus
l_int|1
)paren
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * A signal is pending - give up trying.&n;&t;&t;&t; * Set sem-&gt;count to 0 if it is negative,&n;&t;&t;&t; * since we are no longer sleeping.&n;&t;&t;&t; */
id|__sem_update_count
c_func
(paren
id|sem
comma
l_int|0
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|__set_task_state
c_func
(paren
id|tsk
comma
id|TASK_RUNNING
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|__down_interruptible
id|EXPORT_SYMBOL
c_func
(paren
id|__down_interruptible
)paren
suffix:semicolon
eof
