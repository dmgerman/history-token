multiline_comment|/*&n; * Copyright (C) 1999, 2001, 02, 03 Ralf Baechle&n; *&n; * Heavily inspired by the Alpha implementation&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#ifdef CONFIG_CPU_HAS_LLDSCD
multiline_comment|/*&n; * On machines without lld/scd we need a spinlock to make the manipulation of&n; * sem-&gt;count and sem-&gt;waking atomic.  Scalability isn&squot;t an issue because&n; * this lock is used on UP only so it&squot;s just an empty variable.&n; */
DECL|variable|semaphore_lock
id|spinlock_t
id|semaphore_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|semaphore_lock
id|EXPORT_SYMBOL
c_func
(paren
id|semaphore_lock
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Semaphores are implemented using a two-way counter: The &quot;count&quot; variable is&n; * decremented for each process that tries to sleep, while the &quot;waking&quot; variable&n; * is incremented when the &quot;up()&quot; code goes to wake up waiting processes.&n; *&n; * Notably, the inline &quot;up()&quot; and &quot;down()&quot; functions can efficiently test if&n; * they need to do any extra work (up needs to do something only if count was&n; * negative before the increment operation.&n; *&n; * waking_non_zero() must execute atomically.&n; *&n; * When __up() is called, the count was negative before incrementing it, and we&n; * need to wake up somebody.&n; *&n; * This routine adds one to the count of processes that need to wake up and&n; * exit.  ALL waiting processes actually wake up but only the one that gets to&n; * the &quot;waking&quot; field first will gate through and acquire the semaphore.  The&n; * others will go back to sleep.&n; *&n; * Note that these functions are only called when there is contention on the&n; * lock, and as such all this is the &quot;non-critical&quot; part of the whole semaphore&n; * business. The critical part is the inline stuff in &lt;asm/semaphore.h&gt; where&n; * we want to avoid any extra jumps and calls.&n; */
DECL|function|__up_wakeup
r_void
id|__up_wakeup
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
)brace
DECL|variable|__up_wakeup
id|EXPORT_SYMBOL
c_func
(paren
id|__up_wakeup
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_CPU_HAS_LLSC
DECL|function|waking_non_zero
r_static
r_inline
r_int
id|waking_non_zero
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
id|ret
comma
id|tmp
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ll&t;%1, %2&t;&t;&t;# waking_non_zero&t;&bslash;n&quot;
l_string|&quot;&t;blez&t;%1, 2f&t;&t;&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;subu&t;%0, %1, 1&t;&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;sc&t;%0, %2&t;&t;&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;beqz&t;%0, 1b&t;&t;&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;2:&t;&t;&t;&t;&t;&t;&t;&t;&bslash;n&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ret
)paren
comma
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
comma
l_string|&quot;+m&quot;
(paren
id|sem-&gt;waking
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#else /* !CONFIG_CPU_HAS_LLSC */
DECL|function|waking_non_zero
r_static
r_inline
r_int
id|waking_non_zero
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|waking
comma
id|ret
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|semaphore_lock
comma
id|flags
)paren
suffix:semicolon
id|waking
op_assign
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;waking
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waking
OG
l_int|0
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|sem-&gt;waking
comma
id|waking
op_minus
l_int|1
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|semaphore_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif /* !CONFIG_CPU_HAS_LLSC */
multiline_comment|/*&n; * Perform the &quot;down&quot; function.  Return zero for semaphore acquired, return&n; * negative for signalled out of the function.&n; *&n; * If called from down, the return is ignored and the wait loop is not&n; * interruptible.  This means that a task waiting on a semaphore using &quot;down()&quot;&n; * cannot be killed until someone does an &quot;up()&quot; on the semaphore.&n; *&n; * If called from down_interruptible, the return value gets checked upon return.&n; * If the return value is negative then the task continues with the negative&n; * value in the return register (it can be tested by the caller).&n; *&n; * Either form may be used in conjunction with &quot;up()&quot;.&n; */
DECL|function|__down_failed
r_void
id|__sched
id|__down_failed
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|wait_queue_t
id|wait
suffix:semicolon
id|init_waitqueue_entry
c_func
(paren
op_amp
id|wait
comma
id|tsk
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, we&squot;re set up.  sem-&gt;count is known to be less than zero&n;&t; * so we must wait.&n;&t; *&n;&t; * We can let go the lock for purposes of waiting.&n;&t; * We re-acquire it after awaking so as to protect&n;&t; * all semaphore operations.&n;&t; *&n;&t; * If &quot;up()&quot; is called before we call waking_non_zero() then&n;&t; * we will catch it right away.  If it is called later then&n;&t; * we will have to go through a wakeup cycle to catch it.&n;&t; *&n;&t; * Multiple waiters contend for the semaphore lock to see&n;&t; * who gets to gate through and who has to wait some more.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|waking_non_zero
c_func
(paren
id|sem
)paren
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
)brace
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
)brace
DECL|variable|__down_failed
id|EXPORT_SYMBOL
c_func
(paren
id|__down_failed
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_CPU_HAS_LLDSCD
multiline_comment|/*&n; * waking_non_zero_interruptible:&n; *&t;1&t;got the lock&n; *&t;0&t;go to sleep&n; *&t;-EINTR&t;interrupted&n; *&n; * We must undo the sem-&gt;count down_interruptible decrement&n; * simultaneously and atomically with the sem-&gt;waking adjustment,&n; * otherwise we can race with wake_one_more.&n; *&n; * This is accomplished by doing a 64-bit lld/scd on the 2 32-bit words.&n; *&n; * This is crazy.  Normally it&squot;s strictly forbidden to use 64-bit operations&n; * in the 32-bit MIPS kernel.  In this case it&squot;s however ok because if an&n; * interrupt has destroyed the upper half of registers sc will fail.&n; * Note also that this will not work for MIPS32 CPUs!&n; *&n; * Pseudocode:&n; *&n; * If(sem-&gt;waking &gt; 0) {&n; *&t;Decrement(sem-&gt;waking)&n; *&t;Return(SUCCESS)&n; * } else If(signal_pending(tsk)) {&n; *&t;Increment(sem-&gt;count)&n; *&t;Return(-EINTR)&n; * } else {&n; *&t;Return(SLEEP)&n; * }&n; */
r_static
r_inline
r_int
DECL|function|waking_non_zero_interruptible
id|waking_non_zero_interruptible
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
comma
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_int
id|ret
comma
id|tmp
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;&t;.set&t;push&t;&t;# waking_non_zero_interruptible&t;&bslash;n&quot;
l_string|&quot;&t;.set&t;mips3&t;&t;&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;.set&t;noat&t;&t;&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;0:&t;lld&t;%1, %2&t;&t;&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;li&t;%0, 0&t;&t;&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;sll&t;$1, %1, 0&t;&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;blez&t;$1, 1f&t;&t;&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;daddiu&t;%1, %1, -1&t;&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;li&t;%0, 1&t;&t;&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;b&t;2f&t;&t;&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;1:&t;beqz&t;%3, 2f&t;&t;&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;li&t;%0, %4&t;&t;&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;dli&t;$1, 0x0000000100000000&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;daddu&t;%1, %1, $1&t;&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;2:&t;scd&t;%1, %2&t;&t;&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;beqz&t;%1, 0b&t;&t;&t;&t;&t;&t;&bslash;n&quot;
l_string|&quot;&t;.set&t;pop&t;&t;&t;&t;&t;&t;&bslash;n&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|ret
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp
)paren
comma
l_string|&quot;=m&quot;
(paren
op_star
id|sem
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|signal_pending
c_func
(paren
id|tsk
)paren
)paren
comma
l_string|&quot;i&quot;
(paren
op_minus
id|EINTR
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#else /* !CONFIG_CPU_HAS_LLDSCD */
DECL|function|waking_non_zero_interruptible
r_static
r_inline
r_int
id|waking_non_zero_interruptible
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
comma
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_int
id|waking
comma
id|pending
comma
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|pending
op_assign
id|signal_pending
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|semaphore_lock
comma
id|flags
)paren
suffix:semicolon
id|waking
op_assign
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;waking
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waking
OG
l_int|0
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|sem-&gt;waking
comma
id|waking
op_minus
l_int|1
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pending
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|sem-&gt;count
comma
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;count
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINTR
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|semaphore_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif /* !CONFIG_CPU_HAS_LLDSCD */
DECL|function|__down_failed_interruptible
r_int
id|__sched
id|__down_failed_interruptible
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|wait_queue_t
id|wait
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|init_waitqueue_entry
c_func
(paren
op_amp
id|wait
comma
id|tsk
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, we&squot;re set up.  sem-&gt;count is known to be less than zero&n;&t; * so we must wait.&n;&t; *&n;&t; * We can let go the lock for purposes of waiting.&n;&t; * We re-acquire it after awaking so as to protect&n;&t; * all semaphore operations.&n;&t; *&n;&t; * If &quot;up()&quot; is called before we call waking_non_zero() then&n;&t; * we will catch it right away.  If it is called later then&n;&t; * we will have to go through a wakeup cycle to catch it.&n;&t; *&n;&t; * Multiple waiters contend for the semaphore lock to see&n;&t; * who gets to gate through and who has to wait some more.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|ret
op_assign
id|waking_non_zero_interruptible
c_func
(paren
id|sem
comma
id|tsk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|1
)paren
multiline_comment|/* ret != 0 only if we get interrupted -arca */
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
)brace
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|__down_failed_interruptible
id|EXPORT_SYMBOL
c_func
(paren
id|__down_failed_interruptible
)paren
suffix:semicolon
eof
