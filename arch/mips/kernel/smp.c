multiline_comment|/*&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version 2&n; * of the License, or (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.&n; *&n; * Copyright (C) 2000, 2001 Kanoj Sarcar&n; * Copyright (C) 2000, 2001 Ralf Baechle&n; * Copyright (C) 2000, 2001 Silicon Graphics, Inc.&n; * Copyright (C) 2000, 2001, 2003 Broadcom Corporation&n; */
macro_line|#include &lt;linux/cache.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/threads.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/cpumask.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/cpu.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
DECL|variable|phys_cpu_present_map
id|cpumask_t
id|phys_cpu_present_map
suffix:semicolon
multiline_comment|/* Bitmask of available CPUs */
DECL|variable|cpu_callin_map
r_volatile
id|cpumask_t
id|cpu_callin_map
suffix:semicolon
multiline_comment|/* Bitmask of started secondaries */
DECL|variable|cpu_online_map
id|cpumask_t
id|cpu_online_map
suffix:semicolon
multiline_comment|/* Bitmask of currently online CPUs */
DECL|variable|__cpu_number_map
r_int
id|__cpu_number_map
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* Map physical to logical */
DECL|variable|__cpu_logical_map
r_int
id|__cpu_logical_map
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* Map logical to physical */
DECL|variable|phys_cpu_present_map
id|EXPORT_SYMBOL
c_func
(paren
id|phys_cpu_present_map
)paren
suffix:semicolon
DECL|variable|cpu_online_map
id|EXPORT_SYMBOL
c_func
(paren
id|cpu_online_map
)paren
suffix:semicolon
DECL|function|smp_tune_scheduling
r_static
r_void
id|smp_tune_scheduling
(paren
r_void
)paren
(brace
r_struct
id|cache_desc
op_star
id|cd
op_assign
op_amp
id|current_cpu_data.scache
suffix:semicolon
r_int
r_int
id|cachesize
suffix:semicolon
multiline_comment|/* kB   */
r_int
r_int
id|bandwidth
op_assign
l_int|350
suffix:semicolon
multiline_comment|/* MB/s */
r_int
r_int
id|cpu_khz
suffix:semicolon
multiline_comment|/*&n;&t; * Crude estimate until we actually meassure ...&n;&t; */
id|cpu_khz
op_assign
id|loops_per_jiffy
op_star
l_int|2
op_star
id|HZ
op_div
l_int|1000
suffix:semicolon
multiline_comment|/*&n;&t; * Rough estimation for SMP scheduling, this is the number of&n;&t; * cycles it takes for a fully memory-limited process to flush&n;&t; * the SMP-local cache.&n;&t; *&n;&t; * (For a P5 this pretty much means we will choose another idle&n;&t; *  CPU almost always at wakeup time (this is due to the small&n;&t; *  L1 cache), on PIIs it&squot;s around 50-100 usecs, depending on&n;&t; *  the cache size)&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|cpu_khz
)paren
r_return
suffix:semicolon
id|cachesize
op_assign
id|cd-&gt;linesz
op_star
id|cd-&gt;sets
op_star
id|cd-&gt;ways
suffix:semicolon
)brace
r_extern
r_void
id|__init
id|calibrate_delay
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|ATTRIB_NORET
r_void
id|cpu_idle
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * First C code run on the secondary CPUs after being started up by&n; * the master.&n; */
DECL|function|start_secondary
id|asmlinkage
r_void
id|start_secondary
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|cpu_probe
c_func
(paren
)paren
suffix:semicolon
id|cpu_report
c_func
(paren
)paren
suffix:semicolon
id|per_cpu_trap_init
c_func
(paren
)paren
suffix:semicolon
id|prom_init_secondary
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX parity protection should be folded in here when it&squot;s converted&n;&t; * to an option instead of something based on .cputype&n;&t; */
id|calibrate_delay
c_func
(paren
)paren
suffix:semicolon
id|cpu_data
(braket
id|cpu
)braket
dot
id|udelay_val
op_assign
id|loops_per_jiffy
suffix:semicolon
id|prom_smp_finish
c_func
(paren
)paren
suffix:semicolon
id|cpu_set
c_func
(paren
id|cpu
comma
id|cpu_callin_map
)paren
suffix:semicolon
id|cpu_idle
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|smp_call_lock
id|DEFINE_SPINLOCK
c_func
(paren
id|smp_call_lock
)paren
suffix:semicolon
DECL|variable|call_data
r_struct
id|call_data_struct
op_star
id|call_data
suffix:semicolon
multiline_comment|/*&n; * Run a function on all other CPUs.&n; *  &lt;func&gt;      The function to run. This must be fast and non-blocking.&n; *  &lt;info&gt;      An arbitrary pointer to pass to the function.&n; *  &lt;retry&gt;     If true, keep retrying until ready.&n; *  &lt;wait&gt;      If true, wait until function has completed on other CPUs.&n; *  [RETURNS]   0 on success, else a negative status code.&n; *&n; * Does not return until remote CPUs are nearly ready to execute &lt;func&gt;&n; * or are or have executed.&n; *&n; * You must not call this function with disabled interrupts or from a&n; * hardware interrupt handler or from a bottom half handler.&n; */
DECL|function|smp_call_function
r_int
id|smp_call_function
(paren
r_void
(paren
op_star
id|func
)paren
(paren
r_void
op_star
id|info
)paren
comma
r_void
op_star
id|info
comma
r_int
id|retry
comma
r_int
id|wait
)paren
(brace
r_struct
id|call_data_struct
id|data
suffix:semicolon
r_int
id|i
comma
id|cpus
op_assign
id|num_online_cpus
c_func
(paren
)paren
op_minus
l_int|1
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpus
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Can deadlock when called with interrupts disabled */
id|WARN_ON
c_func
(paren
id|irqs_disabled
c_func
(paren
)paren
)paren
suffix:semicolon
id|data.func
op_assign
id|func
suffix:semicolon
id|data.info
op_assign
id|info
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|data.started
comma
l_int|0
)paren
suffix:semicolon
id|data.wait
op_assign
id|wait
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
id|atomic_set
c_func
(paren
op_amp
id|data.finished
comma
l_int|0
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|smp_call_lock
)paren
suffix:semicolon
id|call_data
op_assign
op_amp
id|data
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Send a message to all other CPUs and wait for them to respond */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|cpu_online
c_func
(paren
id|i
)paren
op_logical_and
id|i
op_ne
id|cpu
)paren
id|core_send_ipi
c_func
(paren
id|i
comma
id|SMP_CALL_FUNCTION
)paren
suffix:semicolon
multiline_comment|/* Wait for response */
multiline_comment|/* FIXME: lock-up detection, backtrace on lock-up */
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|data.started
)paren
op_ne
id|cpus
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|data.finished
)paren
op_ne
id|cpus
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|smp_call_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|smp_call_function_interrupt
r_void
id|smp_call_function_interrupt
c_func
(paren
r_void
)paren
(brace
r_void
(paren
op_star
id|func
)paren
(paren
r_void
op_star
id|info
)paren
op_assign
id|call_data-&gt;func
suffix:semicolon
r_void
op_star
id|info
op_assign
id|call_data-&gt;info
suffix:semicolon
r_int
id|wait
op_assign
id|call_data-&gt;wait
suffix:semicolon
multiline_comment|/*&n;&t; * Notify initiating CPU that I&squot;ve grabbed the data and am&n;&t; * about to execute the function.&n;&t; */
id|mb
c_func
(paren
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|call_data-&gt;started
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * At this point the info structure may be out of scope unless wait==1.&n;&t; */
id|irq_enter
c_func
(paren
)paren
suffix:semicolon
(paren
op_star
id|func
)paren
(paren
id|info
)paren
suffix:semicolon
id|irq_exit
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
(brace
id|mb
c_func
(paren
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|call_data-&gt;finished
)paren
suffix:semicolon
)brace
)brace
DECL|function|stop_this_cpu
r_static
r_void
id|stop_this_cpu
c_func
(paren
r_void
op_star
id|dummy
)paren
(brace
multiline_comment|/*&n;&t; * Remove this CPU:&n;&t; */
id|cpu_clear
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
comma
id|cpu_online_map
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* May need to service _machine_restart IPI */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Wait if available. */
)brace
DECL|function|smp_send_stop
r_void
id|smp_send_stop
c_func
(paren
r_void
)paren
(brace
id|smp_call_function
c_func
(paren
id|stop_this_cpu
comma
l_int|NULL
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|smp_cpus_done
r_void
id|__init
id|smp_cpus_done
c_func
(paren
r_int
r_int
id|max_cpus
)paren
(brace
id|prom_cpus_done
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* called from main before smp_init() */
DECL|function|smp_prepare_cpus
r_void
id|__init
id|smp_prepare_cpus
c_func
(paren
r_int
r_int
id|max_cpus
)paren
(brace
id|cpu_data
(braket
l_int|0
)braket
dot
id|udelay_val
op_assign
id|loops_per_jiffy
suffix:semicolon
id|init_new_context
c_func
(paren
id|current
comma
op_amp
id|init_mm
)paren
suffix:semicolon
id|current_thread_info
c_func
(paren
)paren
op_member_access_from_pointer
id|cpu
op_assign
l_int|0
suffix:semicolon
id|smp_tune_scheduling
c_func
(paren
)paren
suffix:semicolon
id|prom_prepare_cpus
c_func
(paren
id|max_cpus
)paren
suffix:semicolon
)brace
multiline_comment|/* preload SMP state for boot cpu */
DECL|function|smp_prepare_boot_cpu
r_void
id|__devinit
id|smp_prepare_boot_cpu
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * This assumes that bootup is always handled by the processor&n;&t; * with the logic and physical number 0.&n;&t; */
id|__cpu_number_map
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|__cpu_logical_map
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|cpu_set
c_func
(paren
l_int|0
comma
id|phys_cpu_present_map
)paren
suffix:semicolon
id|cpu_set
c_func
(paren
l_int|0
comma
id|cpu_online_map
)paren
suffix:semicolon
id|cpu_set
c_func
(paren
l_int|0
comma
id|cpu_callin_map
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Startup the CPU with this logical number&n; */
DECL|function|do_boot_cpu
r_static
r_int
id|__init
id|do_boot_cpu
c_func
(paren
r_int
id|cpu
)paren
(brace
r_struct
id|task_struct
op_star
id|idle
suffix:semicolon
multiline_comment|/*&n;&t; * The following code is purely to make sure&n;&t; * Linux can schedule processes on this slave.&n;&t; */
id|idle
op_assign
id|fork_idle
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|idle
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;failed fork for CPU %d&bslash;n&quot;
comma
id|cpu
)paren
suffix:semicolon
id|prom_boot_secondary
c_func
(paren
id|cpu
comma
id|idle
)paren
suffix:semicolon
multiline_comment|/* XXXKW timeout */
r_while
c_loop
(paren
op_logical_neg
id|cpu_isset
c_func
(paren
id|cpu
comma
id|cpu_callin_map
)paren
)paren
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|cpu_set
c_func
(paren
id|cpu
comma
id|cpu_online_map
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Called once for each &quot;cpu_possible(cpu)&quot;.  Needs to spin up the cpu&n; * and keep control until &quot;cpu_online(cpu)&quot; is set.  Note: cpu is&n; * physical, not logical.&n; */
DECL|function|__cpu_up
r_int
id|__devinit
id|__cpu_up
c_func
(paren
r_int
r_int
id|cpu
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/* Processor goes to start_secondary(), sets online flag */
id|ret
op_assign
id|do_boot_cpu
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Not really SMP stuff ... */
DECL|function|setup_profiling_timer
r_int
id|setup_profiling_timer
c_func
(paren
r_int
r_int
id|multiplier
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|flush_tlb_all_ipi
r_static
r_void
id|flush_tlb_all_ipi
c_func
(paren
r_void
op_star
id|info
)paren
(brace
id|local_flush_tlb_all
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|flush_tlb_all
r_void
id|flush_tlb_all
c_func
(paren
r_void
)paren
(brace
id|on_each_cpu
c_func
(paren
id|flush_tlb_all_ipi
comma
l_int|0
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|flush_tlb_mm_ipi
r_static
r_void
id|flush_tlb_mm_ipi
c_func
(paren
r_void
op_star
id|mm
)paren
(brace
id|local_flush_tlb_mm
c_func
(paren
(paren
r_struct
id|mm_struct
op_star
)paren
id|mm
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The following tlb flush calls are invoked when old translations are&n; * being torn down, or pte attributes are changing. For single threaded&n; * address spaces, a new context is obtained on the current cpu, and tlb&n; * context on other cpus are invalidated to force a new context allocation&n; * at switch_mm time, should the mm ever be used on other cpus. For&n; * multithreaded address spaces, intercpu interrupts have to be sent.&n; * Another case where intercpu interrupts are required is when the target&n; * mm might be active on another cpu (eg debuggers doing the flushes on&n; * behalf of debugees, kswapd stealing pages from another process etc).&n; * Kanoj 07/00.&n; */
DECL|function|flush_tlb_mm
r_void
id|flush_tlb_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|atomic_read
c_func
(paren
op_amp
id|mm-&gt;mm_users
)paren
op_ne
l_int|1
)paren
op_logical_or
(paren
id|current-&gt;mm
op_ne
id|mm
)paren
)paren
(brace
id|smp_call_function
c_func
(paren
id|flush_tlb_mm_ipi
comma
(paren
r_void
op_star
)paren
id|mm
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_online_cpus
c_func
(paren
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|smp_processor_id
c_func
(paren
)paren
op_ne
id|i
)paren
id|cpu_context
c_func
(paren
id|i
comma
id|mm
)paren
op_assign
l_int|0
suffix:semicolon
)brace
id|local_flush_tlb_mm
c_func
(paren
id|mm
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|struct|flush_tlb_data
r_struct
id|flush_tlb_data
(brace
DECL|member|vma
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
DECL|member|addr1
r_int
r_int
id|addr1
suffix:semicolon
DECL|member|addr2
r_int
r_int
id|addr2
suffix:semicolon
)brace
suffix:semicolon
DECL|function|flush_tlb_range_ipi
r_static
r_void
id|flush_tlb_range_ipi
c_func
(paren
r_void
op_star
id|info
)paren
(brace
r_struct
id|flush_tlb_data
op_star
id|fd
op_assign
(paren
r_struct
id|flush_tlb_data
op_star
)paren
id|info
suffix:semicolon
id|local_flush_tlb_range
c_func
(paren
id|fd-&gt;vma
comma
id|fd-&gt;addr1
comma
id|fd-&gt;addr2
)paren
suffix:semicolon
)brace
DECL|function|flush_tlb_range
r_void
id|flush_tlb_range
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|atomic_read
c_func
(paren
op_amp
id|mm-&gt;mm_users
)paren
op_ne
l_int|1
)paren
op_logical_or
(paren
id|current-&gt;mm
op_ne
id|mm
)paren
)paren
(brace
r_struct
id|flush_tlb_data
id|fd
suffix:semicolon
id|fd.vma
op_assign
id|vma
suffix:semicolon
id|fd.addr1
op_assign
id|start
suffix:semicolon
id|fd.addr2
op_assign
id|end
suffix:semicolon
id|smp_call_function
c_func
(paren
id|flush_tlb_range_ipi
comma
(paren
r_void
op_star
)paren
op_amp
id|fd
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_online_cpus
c_func
(paren
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|smp_processor_id
c_func
(paren
)paren
op_ne
id|i
)paren
id|cpu_context
c_func
(paren
id|i
comma
id|mm
)paren
op_assign
l_int|0
suffix:semicolon
)brace
id|local_flush_tlb_range
c_func
(paren
id|vma
comma
id|start
comma
id|end
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|flush_tlb_kernel_range_ipi
r_static
r_void
id|flush_tlb_kernel_range_ipi
c_func
(paren
r_void
op_star
id|info
)paren
(brace
r_struct
id|flush_tlb_data
op_star
id|fd
op_assign
(paren
r_struct
id|flush_tlb_data
op_star
)paren
id|info
suffix:semicolon
id|local_flush_tlb_kernel_range
c_func
(paren
id|fd-&gt;addr1
comma
id|fd-&gt;addr2
)paren
suffix:semicolon
)brace
DECL|function|flush_tlb_kernel_range
r_void
id|flush_tlb_kernel_range
c_func
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_struct
id|flush_tlb_data
id|fd
suffix:semicolon
id|fd.addr1
op_assign
id|start
suffix:semicolon
id|fd.addr2
op_assign
id|end
suffix:semicolon
id|on_each_cpu
c_func
(paren
id|flush_tlb_kernel_range_ipi
comma
(paren
r_void
op_star
)paren
op_amp
id|fd
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|flush_tlb_page_ipi
r_static
r_void
id|flush_tlb_page_ipi
c_func
(paren
r_void
op_star
id|info
)paren
(brace
r_struct
id|flush_tlb_data
op_star
id|fd
op_assign
(paren
r_struct
id|flush_tlb_data
op_star
)paren
id|info
suffix:semicolon
id|local_flush_tlb_page
c_func
(paren
id|fd-&gt;vma
comma
id|fd-&gt;addr1
)paren
suffix:semicolon
)brace
DECL|function|flush_tlb_page
r_void
id|flush_tlb_page
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|page
)paren
(brace
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|atomic_read
c_func
(paren
op_amp
id|vma-&gt;vm_mm-&gt;mm_users
)paren
op_ne
l_int|1
)paren
op_logical_or
(paren
id|current-&gt;mm
op_ne
id|vma-&gt;vm_mm
)paren
)paren
(brace
r_struct
id|flush_tlb_data
id|fd
suffix:semicolon
id|fd.vma
op_assign
id|vma
suffix:semicolon
id|fd.addr1
op_assign
id|page
suffix:semicolon
id|smp_call_function
c_func
(paren
id|flush_tlb_page_ipi
comma
(paren
r_void
op_star
)paren
op_amp
id|fd
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_online_cpus
c_func
(paren
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|smp_processor_id
c_func
(paren
)paren
op_ne
id|i
)paren
id|cpu_context
c_func
(paren
id|i
comma
id|vma-&gt;vm_mm
)paren
op_assign
l_int|0
suffix:semicolon
)brace
id|local_flush_tlb_page
c_func
(paren
id|vma
comma
id|page
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|flush_tlb_one_ipi
r_static
r_void
id|flush_tlb_one_ipi
c_func
(paren
r_void
op_star
id|info
)paren
(brace
r_int
r_int
id|vaddr
op_assign
(paren
r_int
r_int
)paren
id|info
suffix:semicolon
id|local_flush_tlb_one
c_func
(paren
id|vaddr
)paren
suffix:semicolon
)brace
DECL|function|flush_tlb_one
r_void
id|flush_tlb_one
c_func
(paren
r_int
r_int
id|vaddr
)paren
(brace
id|smp_call_function
c_func
(paren
id|flush_tlb_one_ipi
comma
(paren
r_void
op_star
)paren
id|vaddr
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
id|local_flush_tlb_one
c_func
(paren
id|vaddr
)paren
suffix:semicolon
)brace
DECL|variable|flush_tlb_page
id|EXPORT_SYMBOL
c_func
(paren
id|flush_tlb_page
)paren
suffix:semicolon
DECL|variable|flush_tlb_one
id|EXPORT_SYMBOL
c_func
(paren
id|flush_tlb_one
)paren
suffix:semicolon
DECL|variable|cpu_data
id|EXPORT_SYMBOL
c_func
(paren
id|cpu_data
)paren
suffix:semicolon
DECL|variable|synchronize_irq
id|EXPORT_SYMBOL
c_func
(paren
id|synchronize_irq
)paren
suffix:semicolon
eof
