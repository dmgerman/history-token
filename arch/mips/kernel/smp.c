multiline_comment|/*&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version 2&n; * of the License, or (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.&n; *&n; * Copyright (C) 2000, 2001 Kanoj Sarcar&n; * Copyright (C) 2000, 2001 Ralf Baechle&n; * Copyright (C) 2000, 2001 Silicon Graphics, Inc.&n; * Copyright (C) 2000, 2001 Broadcom Corporation&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/cache.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/threads.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/cpu.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/hardirq.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
DECL|variable|smp_threads_ready
r_int
id|smp_threads_ready
suffix:semicolon
multiline_comment|/* Not used */
singleline_comment|// static atomic_t cpus_booted = ATOMIC_INIT(0);
DECL|variable|cpus_booted
id|atomic_t
id|cpus_booted
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|phys_cpu_present_map
id|cpumask_t
id|phys_cpu_present_map
suffix:semicolon
multiline_comment|/* Bitmask of physically CPUs */
DECL|variable|cpu_online_map
id|cpumask_t
id|cpu_online_map
suffix:semicolon
multiline_comment|/* Bitmask of currently online CPUs */
DECL|variable|__cpu_number_map
r_int
id|__cpu_number_map
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|variable|__cpu_logical_map
r_int
id|__cpu_logical_map
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* These are defined by the board-specific code. */
multiline_comment|/*&n; * Cause the function described by call_data to be executed on the passed&n; * cpu.  When the function has finished, increment the finished field of&n; * call_data.&n; */
r_void
id|core_send_ipi
c_func
(paren
r_int
id|cpu
comma
r_int
r_int
id|action
)paren
suffix:semicolon
multiline_comment|/*&n; * Clear all undefined state in the cpu, set up sp and gp to the passed&n; * values, and kick the cpu into smp_bootstrap();&n; */
r_void
id|prom_boot_secondary
c_func
(paren
r_int
id|cpu
comma
r_int
r_int
id|sp
comma
r_int
r_int
id|gp
)paren
suffix:semicolon
multiline_comment|/*&n; *  After we&squot;ve done initial boot, this function is called to allow the&n; *  board code to clean up state, if needed&n; */
r_void
id|prom_init_secondary
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|prom_smp_finish
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|cacheflush_time
id|cycles_t
id|cacheflush_time
suffix:semicolon
DECL|variable|cache_decay_ticks
r_int
r_int
id|cache_decay_ticks
suffix:semicolon
DECL|function|smp_tune_scheduling
r_void
id|smp_tune_scheduling
(paren
r_void
)paren
(brace
r_struct
id|cache_desc
op_star
id|cd
op_assign
op_amp
id|current_cpu_data.scache
suffix:semicolon
r_int
r_int
id|cachesize
suffix:semicolon
multiline_comment|/* kB   */
r_int
r_int
id|bandwidth
op_assign
l_int|350
suffix:semicolon
multiline_comment|/* MB/s */
r_int
r_int
id|cpu_khz
suffix:semicolon
multiline_comment|/*&n;&t; * Crude estimate until we actually meassure ...&n;&t; */
id|cpu_khz
op_assign
id|loops_per_jiffy
op_star
l_int|2
op_star
id|HZ
op_div
l_int|1000
suffix:semicolon
multiline_comment|/*&n;&t; * Rough estimation for SMP scheduling, this is the number of&n;&t; * cycles it takes for a fully memory-limited process to flush&n;&t; * the SMP-local cache.&n;&t; *&n;&t; * (For a P5 this pretty much means we will choose another idle&n;&t; *  CPU almost always at wakeup time (this is due to the small&n;&t; *  L1 cache), on PIIs it&squot;s around 50-100 usecs, depending on&n;&t; *  the cache size)&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|cpu_khz
)paren
(brace
multiline_comment|/*&n;&t;&t; * This basically disables processor-affinity scheduling on SMP&n;&t;&t; * without a cycle counter.  Currently all SMP capable MIPS&n;&t;&t; * processors have a cycle counter.&n;&t;&t; */
id|cacheflush_time
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|cachesize
op_assign
id|cd-&gt;linesz
op_star
id|cd-&gt;sets
op_star
id|cd-&gt;ways
suffix:semicolon
id|cacheflush_time
op_assign
(paren
id|cpu_khz
op_rshift
l_int|10
)paren
op_star
(paren
id|cachesize
op_lshift
l_int|10
)paren
op_div
id|bandwidth
suffix:semicolon
id|cache_decay_ticks
op_assign
(paren
r_int
)paren
id|cacheflush_time
op_div
id|cpu_khz
op_star
id|HZ
op_div
l_int|1000
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;per-CPU timeslice cutoff: %ld.%02ld usecs.&bslash;n&quot;
comma
(paren
r_int
)paren
id|cacheflush_time
op_div
(paren
id|cpu_khz
op_div
l_int|1000
)paren
comma
(paren
(paren
r_int
)paren
id|cacheflush_time
op_star
l_int|100
op_div
(paren
id|cpu_khz
op_div
l_int|1000
)paren
)paren
op_mod
l_int|100
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;task migration cache decay timeout: %ld msecs.&bslash;n&quot;
comma
(paren
id|cache_decay_ticks
op_plus
l_int|1
)paren
op_star
l_int|1000
op_div
id|HZ
)paren
suffix:semicolon
)brace
DECL|function|smp_callin
r_void
id|__init
id|smp_callin
c_func
(paren
r_void
)paren
(brace
macro_line|#if 0
id|calibrate_delay
c_func
(paren
)paren
suffix:semicolon
id|smp_store_cpu_info
c_func
(paren
id|cpuid
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifndef CONFIG_SGI_IP27
multiline_comment|/*&n; * Hook for doing final board-specific setup after the generic smp setup&n; * is done&n; */
DECL|function|start_secondary
id|asmlinkage
r_void
id|start_secondary
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|cpu_probe
c_func
(paren
)paren
suffix:semicolon
id|prom_init_secondary
c_func
(paren
)paren
suffix:semicolon
id|per_cpu_trap_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX parity protection should be folded in here when it&squot;s converted&n;&t; * to an option instead of something based on .cputype&n;&t; */
id|pgd_current
(braket
id|cpu
)braket
op_assign
id|init_mm.pgd
suffix:semicolon
id|cpu_data
(braket
id|cpu
)braket
dot
id|udelay_val
op_assign
id|loops_per_jiffy
suffix:semicolon
id|prom_smp_finish
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Slave cpu booted successfully&bslash;n&quot;
)paren
suffix:semicolon
id|CPUMASK_SETB
c_func
(paren
id|cpu_online_map
comma
id|cpu
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|cpus_booted
)paren
suffix:semicolon
id|cpu_idle
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SGI_IP27 */
multiline_comment|/*&n; * this function sends a &squot;reschedule&squot; IPI to another CPU.&n; * it goes straight through and wastes no time serializing&n; * anything. Worst case is that we lose a reschedule ...&n; */
DECL|function|smp_send_reschedule
r_void
id|smp_send_reschedule
c_func
(paren
r_int
id|cpu
)paren
(brace
id|core_send_ipi
c_func
(paren
id|cpu
comma
id|SMP_RESCHEDULE_YOURSELF
)paren
suffix:semicolon
)brace
DECL|variable|call_lock
r_static
id|spinlock_t
id|call_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|call_data
r_struct
id|call_data_struct
op_star
id|call_data
suffix:semicolon
multiline_comment|/*&n; * Run a function on all other CPUs.&n; *  &lt;func&gt;      The function to run. This must be fast and non-blocking.&n; *  &lt;info&gt;      An arbitrary pointer to pass to the function.&n; *  &lt;retry&gt;     If true, keep retrying until ready.&n; *  &lt;wait&gt;      If true, wait until function has completed on other CPUs.&n; *  [RETURNS]   0 on success, else a negative status code.&n; *&n; * Does not return until remote CPUs are nearly ready to execute &lt;func&gt;&n; * or are or have executed.&n; *&n; * You must not call this function with disabled interrupts or from a&n; * hardware interrupt handler or from a bottom half handler.&n; */
DECL|function|smp_call_function
r_int
id|smp_call_function
(paren
r_void
(paren
op_star
id|func
)paren
(paren
r_void
op_star
id|info
)paren
comma
r_void
op_star
id|info
comma
r_int
id|retry
comma
r_int
id|wait
)paren
(brace
r_struct
id|call_data_struct
id|data
suffix:semicolon
r_int
id|i
comma
id|cpus
op_assign
id|num_online_cpus
c_func
(paren
)paren
op_minus
l_int|1
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpus
)paren
r_return
l_int|0
suffix:semicolon
id|data.func
op_assign
id|func
suffix:semicolon
id|data.info
op_assign
id|info
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|data.started
comma
l_int|0
)paren
suffix:semicolon
id|data.wait
op_assign
id|wait
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
id|atomic_set
c_func
(paren
op_amp
id|data.finished
comma
l_int|0
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|call_lock
)paren
suffix:semicolon
id|call_data
op_assign
op_amp
id|data
suffix:semicolon
multiline_comment|/* Send a message to all other CPUs and wait for them to respond */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|cpu_online
c_func
(paren
id|cpu
)paren
op_logical_and
id|cpu
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
id|core_send_ipi
c_func
(paren
id|i
comma
id|SMP_CALL_FUNCTION
)paren
suffix:semicolon
multiline_comment|/* Wait for response */
multiline_comment|/* FIXME: lock-up detection, backtrace on lock-up */
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|data.started
)paren
op_ne
id|cpus
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|data.finished
)paren
op_ne
id|cpus
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|call_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|smp_call_function_interrupt
r_void
id|smp_call_function_interrupt
c_func
(paren
r_void
)paren
(brace
r_void
(paren
op_star
id|func
)paren
(paren
r_void
op_star
id|info
)paren
op_assign
id|call_data-&gt;func
suffix:semicolon
r_void
op_star
id|info
op_assign
id|call_data-&gt;info
suffix:semicolon
r_int
id|wait
op_assign
id|call_data-&gt;wait
suffix:semicolon
id|irq_enter
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Notify initiating CPU that I&squot;ve grabbed the data and am&n;&t; * about to execute the function.&n;&t; */
id|mb
c_func
(paren
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|call_data-&gt;started
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * At this point the info structure may be out of scope unless wait==1.&n;&t; */
id|irq_enter
c_func
(paren
)paren
suffix:semicolon
(paren
op_star
id|func
)paren
(paren
id|info
)paren
suffix:semicolon
id|irq_exit
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
(brace
id|mb
c_func
(paren
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|call_data-&gt;finished
)paren
suffix:semicolon
)brace
)brace
DECL|function|stop_this_cpu
r_static
r_void
id|stop_this_cpu
c_func
(paren
r_void
op_star
id|dummy
)paren
(brace
multiline_comment|/*&n;&t; * Remove this CPU:&n;&t; */
id|clear_bit
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
comma
op_amp
id|cpu_online_map
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* May need to service _machine_restart IPI */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
suffix:semicolon
multiline_comment|/* Wait if available. */
)brace
DECL|function|smp_send_stop
r_void
id|smp_send_stop
c_func
(paren
r_void
)paren
(brace
id|smp_call_function
c_func
(paren
id|stop_this_cpu
comma
l_int|NULL
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Not really SMP stuff ... */
DECL|function|setup_profiling_timer
r_int
id|setup_profiling_timer
c_func
(paren
r_int
r_int
id|multiplier
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|flush_tlb_all_ipi
r_static
r_void
id|flush_tlb_all_ipi
c_func
(paren
r_void
op_star
id|info
)paren
(brace
id|local_flush_tlb_all
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|flush_tlb_all
r_void
id|flush_tlb_all
c_func
(paren
r_void
)paren
(brace
id|on_each_cpu
c_func
(paren
id|flush_tlb_all_ipi
comma
l_int|0
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|flush_tlb_mm_ipi
r_static
r_void
id|flush_tlb_mm_ipi
c_func
(paren
r_void
op_star
id|mm
)paren
(brace
id|local_flush_tlb_mm
c_func
(paren
(paren
r_struct
id|mm_struct
op_star
)paren
id|mm
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The following tlb flush calls are invoked when old translations are&n; * being torn down, or pte attributes are changing. For single threaded&n; * address spaces, a new context is obtained on the current cpu, and tlb&n; * context on other cpus are invalidated to force a new context allocation&n; * at switch_mm time, should the mm ever be used on other cpus. For&n; * multithreaded address spaces, intercpu interrupts have to be sent.&n; * Another case where intercpu interrupts are required is when the target&n; * mm might be active on another cpu (eg debuggers doing the flushes on&n; * behalf of debugees, kswapd stealing pages from another process etc).&n; * Kanoj 07/00.&n; */
DECL|function|flush_tlb_mm
r_void
id|flush_tlb_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|atomic_read
c_func
(paren
op_amp
id|mm-&gt;mm_users
)paren
op_ne
l_int|1
)paren
op_logical_or
(paren
id|current-&gt;mm
op_ne
id|mm
)paren
)paren
(brace
id|smp_call_function
c_func
(paren
id|flush_tlb_mm_ipi
comma
(paren
r_void
op_star
)paren
id|mm
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_online_cpus
c_func
(paren
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|smp_processor_id
c_func
(paren
)paren
op_ne
id|i
)paren
id|cpu_context
c_func
(paren
id|i
comma
id|mm
)paren
op_assign
l_int|0
suffix:semicolon
)brace
id|local_flush_tlb_mm
c_func
(paren
id|mm
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|struct|flush_tlb_data
r_struct
id|flush_tlb_data
(brace
DECL|member|vma
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
DECL|member|addr1
r_int
r_int
id|addr1
suffix:semicolon
DECL|member|addr2
r_int
r_int
id|addr2
suffix:semicolon
)brace
suffix:semicolon
DECL|function|flush_tlb_range_ipi
r_static
r_void
id|flush_tlb_range_ipi
c_func
(paren
r_void
op_star
id|info
)paren
(brace
r_struct
id|flush_tlb_data
op_star
id|fd
op_assign
(paren
r_struct
id|flush_tlb_data
op_star
)paren
id|info
suffix:semicolon
id|local_flush_tlb_range
c_func
(paren
id|fd-&gt;vma
comma
id|fd-&gt;addr1
comma
id|fd-&gt;addr2
)paren
suffix:semicolon
)brace
DECL|function|flush_tlb_range
r_void
id|flush_tlb_range
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|vma-&gt;vm_mm
suffix:semicolon
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|atomic_read
c_func
(paren
op_amp
id|mm-&gt;mm_users
)paren
op_ne
l_int|1
)paren
op_logical_or
(paren
id|current-&gt;mm
op_ne
id|mm
)paren
)paren
(brace
r_struct
id|flush_tlb_data
id|fd
suffix:semicolon
id|fd.vma
op_assign
id|vma
suffix:semicolon
id|fd.addr1
op_assign
id|start
suffix:semicolon
id|fd.addr2
op_assign
id|end
suffix:semicolon
id|smp_call_function
c_func
(paren
id|flush_tlb_range_ipi
comma
(paren
r_void
op_star
)paren
op_amp
id|fd
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_online_cpus
c_func
(paren
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|smp_processor_id
c_func
(paren
)paren
op_ne
id|i
)paren
id|cpu_context
c_func
(paren
id|i
comma
id|mm
)paren
op_assign
l_int|0
suffix:semicolon
)brace
id|local_flush_tlb_range
c_func
(paren
id|vma
comma
id|start
comma
id|end
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|flush_tlb_kernel_range_ipi
r_static
r_void
id|flush_tlb_kernel_range_ipi
c_func
(paren
r_void
op_star
id|info
)paren
(brace
r_struct
id|flush_tlb_data
op_star
id|fd
op_assign
(paren
r_struct
id|flush_tlb_data
op_star
)paren
id|info
suffix:semicolon
id|local_flush_tlb_kernel_range
c_func
(paren
id|fd-&gt;addr1
comma
id|fd-&gt;addr2
)paren
suffix:semicolon
)brace
DECL|function|flush_tlb_kernel_range
r_void
id|flush_tlb_kernel_range
c_func
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
r_struct
id|flush_tlb_data
id|fd
suffix:semicolon
id|fd.addr1
op_assign
id|start
suffix:semicolon
id|fd.addr2
op_assign
id|end
suffix:semicolon
id|on_each_cpu
c_func
(paren
id|flush_tlb_kernel_range_ipi
comma
(paren
r_void
op_star
)paren
op_amp
id|fd
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|flush_tlb_page_ipi
r_static
r_void
id|flush_tlb_page_ipi
c_func
(paren
r_void
op_star
id|info
)paren
(brace
r_struct
id|flush_tlb_data
op_star
id|fd
op_assign
(paren
r_struct
id|flush_tlb_data
op_star
)paren
id|info
suffix:semicolon
id|local_flush_tlb_page
c_func
(paren
id|fd-&gt;vma
comma
id|fd-&gt;addr1
)paren
suffix:semicolon
)brace
DECL|function|flush_tlb_page
r_void
id|flush_tlb_page
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|page
)paren
(brace
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|atomic_read
c_func
(paren
op_amp
id|vma-&gt;vm_mm-&gt;mm_users
)paren
op_ne
l_int|1
)paren
op_logical_or
(paren
id|current-&gt;mm
op_ne
id|vma-&gt;vm_mm
)paren
)paren
(brace
r_struct
id|flush_tlb_data
id|fd
suffix:semicolon
id|fd.vma
op_assign
id|vma
suffix:semicolon
id|fd.addr1
op_assign
id|page
suffix:semicolon
id|smp_call_function
c_func
(paren
id|flush_tlb_page_ipi
comma
(paren
r_void
op_star
)paren
op_amp
id|fd
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_online_cpus
c_func
(paren
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|smp_processor_id
c_func
(paren
)paren
op_ne
id|i
)paren
id|cpu_context
c_func
(paren
id|i
comma
id|vma-&gt;vm_mm
)paren
op_assign
l_int|0
suffix:semicolon
)brace
id|local_flush_tlb_page
c_func
(paren
id|vma
comma
id|page
)paren
suffix:semicolon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|flush_tlb_one_ipi
r_static
r_void
id|flush_tlb_one_ipi
c_func
(paren
r_void
op_star
id|info
)paren
(brace
r_int
r_int
id|vaddr
op_assign
(paren
r_int
r_int
)paren
id|info
suffix:semicolon
id|local_flush_tlb_one
c_func
(paren
id|vaddr
)paren
suffix:semicolon
)brace
DECL|function|flush_tlb_one
r_void
id|flush_tlb_one
c_func
(paren
r_int
r_int
id|vaddr
)paren
(brace
id|smp_call_function
c_func
(paren
id|flush_tlb_one_ipi
comma
(paren
r_void
op_star
)paren
id|vaddr
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
id|local_flush_tlb_one
c_func
(paren
id|vaddr
)paren
suffix:semicolon
)brace
DECL|variable|flush_tlb_page
id|EXPORT_SYMBOL
c_func
(paren
id|flush_tlb_page
)paren
suffix:semicolon
DECL|variable|flush_tlb_one
id|EXPORT_SYMBOL
c_func
(paren
id|flush_tlb_one
)paren
suffix:semicolon
DECL|variable|cpu_data
id|EXPORT_SYMBOL
c_func
(paren
id|cpu_data
)paren
suffix:semicolon
DECL|variable|synchronize_irq
id|EXPORT_SYMBOL
c_func
(paren
id|synchronize_irq
)paren
suffix:semicolon
eof
