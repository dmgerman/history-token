multiline_comment|/*&n; *&n; *  arch/mips/kernel/smp.c&n; *&n; *  Copyright (C) 2000 Sibyte&n; * &n; *  Written by Justin Carlson (carlson@sibyte.com)&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version 2&n; * of the License, or (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; * &n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/threads.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/cache.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/hardirq.h&gt;
macro_line|#include &lt;asm/softirq.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
multiline_comment|/*&n; * This was written with the BRCM12500 MP SOC in mind, but tries to&n; * be generic.  It&squot;s modelled on the mips64 smp.c code, which is&n; * derived from Sparc, I&squot;m guessing, which is derived from...&n; * &n; * It&squot;s probably horribly designed for very large ccNUMA systems&n; * as it doesn&squot;t take any node clustering into account.  &n;*/
multiline_comment|/* Ze Big Kernel Lock! */
DECL|variable|__cacheline_aligned_in_smp
id|spinlock_t
id|kernel_flag
id|__cacheline_aligned_in_smp
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|smp_threads_ready
r_int
id|smp_threads_ready
suffix:semicolon
multiline_comment|/* Not used */
DECL|variable|smp_num_cpus
r_int
id|smp_num_cpus
suffix:semicolon
DECL|variable|global_irq_holder
r_int
id|global_irq_holder
op_assign
id|NO_PROC_ID
suffix:semicolon
DECL|variable|global_irq_lock
id|spinlock_t
id|global_irq_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|cpu_data
r_struct
id|mips_cpuinfo
id|cpu_data
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|variable|smp_fn_call
r_struct
id|smp_fn_call_struct
id|smp_fn_call
op_assign
(brace
id|SPIN_LOCK_UNLOCKED
comma
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|cpus_booted
r_static
id|atomic_t
id|cpus_booted
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* These are defined by the board-specific code. */
multiline_comment|/* Cause the function described by smp_fn_call &n;   to be executed on the passed cpu.  When the function&n;   has finished, increment the finished field of&n;   smp_fn_call. */
r_void
id|core_call_function
c_func
(paren
r_int
id|cpu
)paren
suffix:semicolon
multiline_comment|/*&n; * Clear all undefined state in the cpu, set up sp and gp to the passed&n; * values, and kick the cpu into smp_bootstrap(); &n; */
r_void
id|prom_boot_secondary
c_func
(paren
r_int
id|cpu
comma
r_int
r_int
id|sp
comma
r_int
r_int
id|gp
)paren
suffix:semicolon
multiline_comment|/*&n; *  After we&squot;ve done initial boot, this function is called to allow the&n; *  board code to clean up state, if needed &n; */
r_void
id|prom_init_secondary
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|cpu_idle
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* Do whatever setup needs to be done for SMP at the board level.  Return&n;   the number of cpus in the system, including this one */
r_int
id|prom_setup_smp
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|start_secondary
r_int
id|start_secondary
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
id|prom_init_secondary
c_func
(paren
)paren
suffix:semicolon
id|write_32bit_cp0_register
c_func
(paren
id|CP0_CONTEXT
comma
id|smp_processor_id
c_func
(paren
)paren
op_lshift
l_int|23
)paren
suffix:semicolon
id|current_pgd
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
op_assign
id|init_mm.pgd
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Slave cpu booted successfully&bslash;n&quot;
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|cpus_booted
)paren
suffix:semicolon
id|cpu_idle
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|smp_boot_cpus
r_void
id|__init
id|smp_boot_cpus
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|smp_num_cpus
op_assign
id|prom_setup_smp
c_func
(paren
)paren
suffix:semicolon
id|init_new_context
c_func
(paren
id|current
comma
op_amp
id|init_mm
)paren
suffix:semicolon
id|current-&gt;processor
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|cpus_booted
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Master CPU is already booted... */
id|init_idle
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|smp_num_cpus
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_struct
id|pt_regs
id|regs
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Starting CPU %d... &quot;
comma
id|i
)paren
suffix:semicolon
multiline_comment|/* Spawn a new process normally.  Grab a pointer to&n;&t;&t;   its task struct so we can mess with it */
id|do_fork
c_func
(paren
id|CLONE_VM
op_or
id|CLONE_PID
comma
l_int|0
comma
op_amp
id|regs
comma
l_int|0
)paren
suffix:semicolon
id|p
op_assign
id|prev_task
c_func
(paren
op_amp
id|init_task
)paren
suffix:semicolon
multiline_comment|/* Schedule the first task manually */
id|p-&gt;processor
op_assign
id|i
suffix:semicolon
id|p-&gt;cpus_runnable
op_assign
l_int|1
op_lshift
id|i
suffix:semicolon
multiline_comment|/* we schedule the first task manually */
multiline_comment|/* Attach to the address space of init_task. */
id|atomic_inc
c_func
(paren
op_amp
id|init_mm.mm_count
)paren
suffix:semicolon
id|p-&gt;active_mm
op_assign
op_amp
id|init_mm
suffix:semicolon
id|init_tasks
(braket
id|i
)braket
op_assign
id|p
suffix:semicolon
id|del_from_runqueue
c_func
(paren
id|p
)paren
suffix:semicolon
id|unhash_process
c_func
(paren
id|p
)paren
suffix:semicolon
id|prom_boot_secondary
c_func
(paren
id|i
comma
(paren
r_int
r_int
)paren
id|p
op_plus
id|KERNEL_STACK_SIZE
op_minus
l_int|32
comma
(paren
r_int
r_int
)paren
id|p
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* This is copied from the ip-27 code in the mips64 tree */
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The following code is purely to make sure&n;&t;&t; * Linux can schedule processes on this slave.&n;&t;&t; */
id|kernel_thread
c_func
(paren
l_int|0
comma
l_int|NULL
comma
id|CLONE_PID
)paren
suffix:semicolon
id|p
op_assign
id|prev_task
c_func
(paren
op_amp
id|init_task
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|p-&gt;comm
comma
l_string|&quot;%s%d&quot;
comma
l_string|&quot;Idle&quot;
comma
id|i
)paren
suffix:semicolon
id|init_tasks
(braket
id|i
)braket
op_assign
id|p
suffix:semicolon
id|p-&gt;processor
op_assign
id|i
suffix:semicolon
id|p-&gt;cpus_runnable
op_assign
l_int|1
op_lshift
id|i
suffix:semicolon
multiline_comment|/* we schedule the first task manually *&n;&t;&t;del_from_runqueue(p);&n;&t;&t;unhash_process(p);&n;&t;&t;/* Attach to the address space of init_task. */
id|atomic_inc
c_func
(paren
op_amp
id|init_mm.mm_count
)paren
suffix:semicolon
id|p-&gt;active_mm
op_assign
op_amp
id|init_mm
suffix:semicolon
id|prom_boot_secondary
c_func
(paren
id|i
comma
(paren
r_int
r_int
)paren
id|p
op_plus
id|KERNEL_STACK_SIZE
op_minus
l_int|32
comma
(paren
r_int
r_int
)paren
id|p
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Wait for everyone to come up */
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|cpus_booted
)paren
op_ne
id|smp_num_cpus
)paren
suffix:semicolon
)brace
DECL|function|smp_commence
r_void
id|__init
id|smp_commence
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Not sure what to do here yet */
)brace
DECL|function|reschedule_this_cpu
r_static
r_void
id|reschedule_this_cpu
c_func
(paren
r_void
op_star
id|dummy
)paren
(brace
id|current-&gt;work.need_resched
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|smp_send_reschedule
r_void
id|FASTCALL
c_func
(paren
id|smp_send_reschedule
c_func
(paren
r_int
id|cpu
)paren
)paren
(brace
id|smp_call_function
c_func
(paren
id|reschedule_this_cpu
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The caller of this wants the passed function to run on every cpu.  If wait&n; * is set, wait until all cpus have finished the function before returning.&n; * The lock is here to protect the call structure.&n; */
DECL|function|smp_call_function
r_int
id|smp_call_function
(paren
r_void
(paren
op_star
id|func
)paren
(paren
r_void
op_star
id|info
)paren
comma
r_void
op_star
id|info
comma
r_int
id|retry
comma
r_int
id|wait
)paren
(brace
r_int
id|cpus
op_assign
id|smp_num_cpus
op_minus
l_int|1
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|smp_num_cpus
OL
l_int|2
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|spin_lock_bh
c_func
(paren
op_amp
id|smp_fn_call.lock
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|smp_fn_call.finished
comma
l_int|0
)paren
suffix:semicolon
id|smp_fn_call.fn
op_assign
id|func
suffix:semicolon
id|smp_fn_call.data
op_assign
id|info
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|smp_num_cpus
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_ne
id|smp_processor_id
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* Call the board specific routine */
id|core_call_function
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|wait
)paren
(brace
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|smp_fn_call.finished
)paren
op_ne
id|cpus
)paren
(brace
)brace
)brace
id|spin_unlock_bh
c_func
(paren
op_amp
id|smp_fn_call.lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|synchronize_irq
r_void
id|synchronize_irq
c_func
(paren
r_void
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;synchronize_irq&quot;
)paren
suffix:semicolon
)brace
DECL|function|stop_this_cpu
r_static
r_void
id|stop_this_cpu
c_func
(paren
r_void
op_star
id|dummy
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Cpu stopping&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
suffix:semicolon
)brace
DECL|function|smp_send_stop
r_void
id|smp_send_stop
c_func
(paren
r_void
)paren
(brace
id|smp_call_function
c_func
(paren
id|stop_this_cpu
comma
l_int|NULL
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|smp_num_cpus
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Not really SMP stuff ... */
DECL|function|setup_profiling_timer
r_int
id|setup_profiling_timer
c_func
(paren
r_int
r_int
id|multiplier
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Most of this code is take from the mips64 tree (ip27-irq.c).  It&squot;s virtually&n; * identical to the i386 implentation in arh/i386/irq.c, with translations for&n; * the interrupt enable bit&n; */
DECL|macro|MAXCOUNT
mdefine_line|#define MAXCOUNT &t;&t;100000000
DECL|macro|SYNC_OTHER_CORES
mdefine_line|#define SYNC_OTHER_CORES(x)&t;udelay(x+1)
DECL|function|wait_on_irq
r_static
r_inline
r_void
id|wait_on_irq
c_func
(paren
r_int
id|cpu
)paren
(brace
r_int
id|count
op_assign
id|MAXCOUNT
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/*&n;&t;&t; * Wait until all interrupts are gone. Wait&n;&t;&t; * for bottom half handlers unless we&squot;re&n;&t;&t; * already executing in one..&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|irqs_running
c_func
(paren
)paren
)paren
r_if
c_cond
(paren
id|local_bh_count
c_func
(paren
id|cpu
)paren
op_logical_or
op_logical_neg
id|spin_is_locked
c_func
(paren
op_amp
id|global_bh_lock
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Duh, we have to loop. Release the lock to avoid deadlocks */
id|spin_unlock
c_func
(paren
op_amp
id|global_irq_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|count
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Count spun out.  Huh?&bslash;n&quot;
)paren
suffix:semicolon
id|count
op_assign
op_complement
l_int|0
suffix:semicolon
)brace
id|__sti
c_func
(paren
)paren
suffix:semicolon
id|SYNC_OTHER_CORES
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irqs_running
c_func
(paren
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|spin_is_locked
c_func
(paren
op_amp
id|global_irq_lock
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|local_bh_count
c_func
(paren
id|cpu
)paren
op_logical_and
id|spin_is_locked
c_func
(paren
op_amp
id|global_bh_lock
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|spin_trylock
c_func
(paren
op_amp
id|global_irq_lock
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
)brace
DECL|function|get_irqlock
r_static
r_inline
r_void
id|get_irqlock
c_func
(paren
r_int
id|cpu
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|spin_trylock
c_func
(paren
op_amp
id|global_irq_lock
)paren
)paren
(brace
multiline_comment|/* do we already hold the lock? */
r_if
c_cond
(paren
(paren
r_int
r_char
)paren
id|cpu
op_eq
id|global_irq_holder
)paren
r_return
suffix:semicolon
multiline_comment|/* Uhhuh.. Somebody else got it. Wait.. */
id|spin_lock
c_func
(paren
op_amp
id|global_irq_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We also to make sure that nobody else is running&n;&t; * in an interrupt context.&n;&t; */
id|wait_on_irq
c_func
(paren
id|cpu
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, finally..&n;&t; */
id|global_irq_holder
op_assign
id|cpu
suffix:semicolon
)brace
multiline_comment|/*&n; * A global &quot;cli()&quot; while in an interrupt context&n; * turns into just a local cli(). Interrupts&n; * should use spinlocks for the (very unlikely)&n; * case that they ever want to protect against&n; * each other.&n; *&n; * If we already have local interrupts disabled,&n; * this will not turn a local disable into a&n; * global one (problems with spinlocks: this makes&n; * save_flags+cli+sti usable inside a spinlock).&n; */
DECL|function|__global_cli
r_void
id|__global_cli
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|ST0_IE
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|local_irq_count
c_func
(paren
id|cpu
)paren
)paren
id|get_irqlock
c_func
(paren
id|cpu
)paren
suffix:semicolon
)brace
)brace
DECL|function|__global_sti
r_void
id|__global_sti
c_func
(paren
r_void
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|local_irq_count
c_func
(paren
id|cpu
)paren
)paren
id|release_irqlock
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|__sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * SMP flags value to restore to:&n; * 0 - global cli&n; * 1 - global sti&n; * 2 - local cli&n; * 3 - local sti&n; */
DECL|function|__global_save_flags
r_int
r_int
id|__global_save_flags
c_func
(paren
r_void
)paren
(brace
r_int
id|retval
suffix:semicolon
r_int
id|local_enabled
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|local_enabled
op_assign
(paren
id|flags
op_amp
id|ST0_IE
)paren
suffix:semicolon
multiline_comment|/* default to local */
id|retval
op_assign
l_int|2
op_plus
id|local_enabled
suffix:semicolon
multiline_comment|/* check for global flags if we&squot;re not in an interrupt */
r_if
c_cond
(paren
op_logical_neg
id|local_irq_count
c_func
(paren
id|cpu
)paren
)paren
(brace
r_if
c_cond
(paren
id|local_enabled
)paren
id|retval
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|global_irq_holder
op_eq
id|cpu
)paren
id|retval
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|__global_restore_flags
r_void
id|__global_restore_flags
c_func
(paren
r_int
r_int
id|flags
)paren
(brace
r_switch
c_cond
(paren
id|flags
)paren
(brace
r_case
l_int|0
suffix:colon
id|__global_cli
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|__global_sti
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|__cli
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|__sti
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;global_restore_flags: %08lx&bslash;n&quot;
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
eof
