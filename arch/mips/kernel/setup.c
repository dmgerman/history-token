multiline_comment|/*&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 1995 Linus Torvalds&n; * Copyright (C) 1995 Waldorf Electronics&n; * Copyright (C) 1994, 95, 96, 97, 98, 99, 2000, 01, 02, 03  Ralf Baechle&n; * Copyright (C) 1996 Stoned Elipot&n; * Copyright (C) 1999 Silicon Graphics, Inc.&n; * Copyright (C) 2000 2001, 2002  Maciej W. Rozycki&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/user.h&gt;
macro_line|#include &lt;linux/utsname.h&gt;
macro_line|#include &lt;linux/a.out.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/initrd.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/kdev_t.h&gt;
macro_line|#include &lt;linux/root_dev.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;asm/addrspace.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt;
macro_line|#include &lt;asm/cpu.h&gt;
macro_line|#include &lt;asm/sections.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/system.h&gt;
DECL|variable|cpu_data
r_struct
id|cpuinfo_mips
id|cpu_data
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|variable|cpu_data
id|EXPORT_SYMBOL
c_func
(paren
id|cpu_data
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_VT
DECL|variable|screen_info
r_struct
id|screen_info
id|screen_info
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Despite it&squot;s name this variable is even if we don&squot;t have PCI&n; */
DECL|variable|PCI_DMA_BUS_IS_PHYS
r_int
r_int
id|PCI_DMA_BUS_IS_PHYS
suffix:semicolon
DECL|variable|PCI_DMA_BUS_IS_PHYS
id|EXPORT_SYMBOL
c_func
(paren
id|PCI_DMA_BUS_IS_PHYS
)paren
suffix:semicolon
multiline_comment|/*&n; * Setup information&n; *&n; * These are initialized so they are in the .data section&n; */
DECL|variable|mips_machtype
r_int
r_int
id|mips_machtype
op_assign
id|MACH_UNKNOWN
suffix:semicolon
DECL|variable|mips_machgroup
r_int
r_int
id|mips_machgroup
op_assign
id|MACH_GROUP_UNKNOWN
suffix:semicolon
DECL|variable|mips_machtype
id|EXPORT_SYMBOL
c_func
(paren
id|mips_machtype
)paren
suffix:semicolon
DECL|variable|mips_machgroup
id|EXPORT_SYMBOL
c_func
(paren
id|mips_machgroup
)paren
suffix:semicolon
DECL|variable|boot_mem_map
r_struct
id|boot_mem_map
id|boot_mem_map
suffix:semicolon
DECL|variable|command_line
r_static
r_char
id|command_line
(braket
id|CL_SIZE
)braket
suffix:semicolon
DECL|variable|arcs_cmdline
r_char
id|arcs_cmdline
(braket
id|CL_SIZE
)braket
op_assign
id|CONFIG_CMDLINE
suffix:semicolon
multiline_comment|/*&n; * mips_io_port_base is the begin of the address space to which x86 style&n; * I/O ports are mapped.&n; */
DECL|variable|mips_io_port_base
r_const
r_int
r_int
id|mips_io_port_base
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|mips_io_port_base
id|EXPORT_SYMBOL
c_func
(paren
id|mips_io_port_base
)paren
suffix:semicolon
multiline_comment|/*&n; * isa_slot_offset is the address where E(ISA) busaddress 0 is mapped&n; * for the processor.&n; */
DECL|variable|isa_slot_offset
r_int
r_int
id|isa_slot_offset
suffix:semicolon
DECL|variable|isa_slot_offset
id|EXPORT_SYMBOL
c_func
(paren
id|isa_slot_offset
)paren
suffix:semicolon
DECL|variable|code_resource
r_static
r_struct
id|resource
id|code_resource
op_assign
(brace
l_string|&quot;Kernel code&quot;
)brace
suffix:semicolon
DECL|variable|data_resource
r_static
r_struct
id|resource
id|data_resource
op_assign
(brace
l_string|&quot;Kernel data&quot;
)brace
suffix:semicolon
DECL|function|add_memory_region
r_void
id|__init
id|add_memory_region
c_func
(paren
id|phys_t
id|start
comma
id|phys_t
id|size
comma
r_int
id|type
)paren
(brace
r_int
id|x
op_assign
id|boot_mem_map.nr_map
suffix:semicolon
r_struct
id|boot_mem_map_entry
op_star
id|prev
op_assign
id|boot_mem_map.map
op_plus
id|x
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Try to merge with previous entry if any.  This is far less than&n;&t; * perfect but is sufficient for most real world cases.&n;&t; */
r_if
c_cond
(paren
id|x
op_logical_and
id|prev-&gt;addr
op_plus
id|prev-&gt;size
op_eq
id|start
op_logical_and
id|prev-&gt;type
op_eq
id|type
)paren
(brace
id|prev-&gt;size
op_add_assign
id|size
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x
op_eq
id|BOOT_MEM_MAP_MAX
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Ooops! Too many entries in the memory map!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|boot_mem_map.map
(braket
id|x
)braket
dot
id|addr
op_assign
id|start
suffix:semicolon
id|boot_mem_map.map
(braket
id|x
)braket
dot
id|size
op_assign
id|size
suffix:semicolon
id|boot_mem_map.map
(braket
id|x
)braket
dot
id|type
op_assign
id|type
suffix:semicolon
id|boot_mem_map.nr_map
op_increment
suffix:semicolon
)brace
DECL|function|print_memory_map
r_static
r_void
id|__init
id|print_memory_map
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_const
r_int
id|field
op_assign
l_int|2
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|boot_mem_map.nr_map
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; memory: %0*Lx @ %0*Lx &quot;
comma
id|field
comma
(paren
r_int
r_int
r_int
)paren
id|boot_mem_map.map
(braket
id|i
)braket
dot
id|size
comma
id|field
comma
(paren
r_int
r_int
r_int
)paren
id|boot_mem_map.map
(braket
id|i
)braket
dot
id|addr
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|boot_mem_map.map
(braket
id|i
)braket
dot
id|type
)paren
(brace
r_case
id|BOOT_MEM_RAM
suffix:colon
id|printk
c_func
(paren
l_string|&quot;(usable)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOOT_MEM_ROM_DATA
suffix:colon
id|printk
c_func
(paren
l_string|&quot;(ROM data)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOOT_MEM_RESERVED
suffix:colon
id|printk
c_func
(paren
l_string|&quot;(reserved)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;type %lu&bslash;n&quot;
comma
id|boot_mem_map.map
(braket
id|i
)braket
dot
id|type
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
DECL|function|parse_cmdline_early
r_static
r_inline
r_void
id|parse_cmdline_early
c_func
(paren
r_void
)paren
(brace
r_char
id|c
op_assign
l_char|&squot; &squot;
comma
op_star
id|to
op_assign
id|command_line
comma
op_star
id|from
op_assign
id|saved_command_line
suffix:semicolon
r_int
r_int
id|start_at
comma
id|mem_size
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|usermem
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Determined physical RAM map:&bslash;n&quot;
)paren
suffix:semicolon
id|print_memory_map
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/*&n;&t;&t; * &quot;mem=XXX[kKmM]&quot; defines a memory region from&n;&t;&t; * 0 to &lt;XXX&gt;, overriding the determined size.&n;&t;&t; * &quot;mem=XXX[KkmM]@YYY[KkmM]&quot; defines a memory region from&n;&t;&t; * &lt;YYY&gt; to &lt;YYY&gt;+&lt;XXX&gt;, overriding the determined size.&n;&t;&t; */
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot; &squot;
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|from
comma
l_string|&quot;mem=&quot;
comma
l_int|4
)paren
)paren
(brace
r_if
c_cond
(paren
id|to
op_ne
id|command_line
)paren
id|to
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If a user specifies memory size, we&n;&t;&t;&t; * blow away any automatically generated&n;&t;&t;&t; * size.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|usermem
op_eq
l_int|0
)paren
(brace
id|boot_mem_map.nr_map
op_assign
l_int|0
suffix:semicolon
id|usermem
op_assign
l_int|1
suffix:semicolon
)brace
id|mem_size
op_assign
id|memparse
c_func
(paren
id|from
op_plus
l_int|4
comma
op_amp
id|from
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|from
op_eq
l_char|&squot;@&squot;
)paren
id|start_at
op_assign
id|memparse
c_func
(paren
id|from
op_plus
l_int|1
comma
op_amp
id|from
)paren
suffix:semicolon
r_else
id|start_at
op_assign
l_int|0
suffix:semicolon
id|add_memory_region
c_func
(paren
id|start_at
comma
id|mem_size
comma
id|BOOT_MEM_RAM
)paren
suffix:semicolon
)brace
id|c
op_assign
op_star
(paren
id|from
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|CL_SIZE
op_le
op_increment
id|len
)paren
r_break
suffix:semicolon
op_star
(paren
id|to
op_increment
)paren
op_assign
id|c
suffix:semicolon
)brace
op_star
id|to
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|usermem
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;User-defined physical RAM map:&bslash;n&quot;
)paren
suffix:semicolon
id|print_memory_map
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|parse_rd_cmdline
r_static
r_inline
r_int
id|parse_rd_cmdline
c_func
(paren
r_int
r_int
op_star
id|rd_start
comma
r_int
r_int
op_star
id|rd_end
)paren
(brace
multiline_comment|/*&n;&t; * &quot;rd_start=0xNNNNNNNN&quot; defines the memory address of an initrd&n;&t; * &quot;rd_size=0xNN&quot; it&squot;s size&n;&t; */
r_int
r_int
id|start
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|size
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
r_char
id|cmd_line
(braket
id|CL_SIZE
)braket
suffix:semicolon
r_char
op_star
id|start_str
suffix:semicolon
r_char
op_star
id|size_str
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
id|strcpy
c_func
(paren
id|cmd_line
comma
id|command_line
)paren
suffix:semicolon
op_star
id|command_line
op_assign
l_int|0
suffix:semicolon
id|tmp
op_assign
id|cmd_line
suffix:semicolon
multiline_comment|/* Ignore &quot;rd_start=&quot; strings in other parameters. */
id|start_str
op_assign
id|strstr
c_func
(paren
id|cmd_line
comma
l_string|&quot;rd_start=&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start_str
op_logical_and
id|start_str
op_ne
id|cmd_line
op_logical_and
op_star
(paren
id|start_str
op_minus
l_int|1
)paren
op_ne
l_char|&squot; &squot;
)paren
id|start_str
op_assign
id|strstr
c_func
(paren
id|start_str
comma
l_string|&quot; rd_start=&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|start_str
)paren
(brace
r_if
c_cond
(paren
id|start_str
op_ne
id|cmd_line
)paren
id|strncat
c_func
(paren
id|command_line
comma
id|tmp
comma
id|start_str
op_minus
id|tmp
)paren
suffix:semicolon
id|start
op_assign
id|memparse
c_func
(paren
id|start_str
op_plus
l_int|9
comma
op_amp
id|start_str
)paren
suffix:semicolon
id|tmp
op_assign
id|start_str
op_plus
l_int|1
suffix:semicolon
id|start_str
op_assign
id|strstr
c_func
(paren
id|start_str
comma
l_string|&quot; rd_start=&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|tmp
)paren
id|strcat
c_func
(paren
id|command_line
comma
id|tmp
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|cmd_line
comma
id|command_line
)paren
suffix:semicolon
op_star
id|command_line
op_assign
l_int|0
suffix:semicolon
id|tmp
op_assign
id|cmd_line
suffix:semicolon
multiline_comment|/* Ignore &quot;rd_size&quot; strings in other parameters. */
id|size_str
op_assign
id|strstr
c_func
(paren
id|cmd_line
comma
l_string|&quot;rd_size=&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size_str
op_logical_and
id|size_str
op_ne
id|cmd_line
op_logical_and
op_star
(paren
id|size_str
op_minus
l_int|1
)paren
op_ne
l_char|&squot; &squot;
)paren
id|size_str
op_assign
id|strstr
c_func
(paren
id|size_str
comma
l_string|&quot; rd_size=&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|size_str
)paren
(brace
r_if
c_cond
(paren
id|size_str
op_ne
id|cmd_line
)paren
id|strncat
c_func
(paren
id|command_line
comma
id|tmp
comma
id|size_str
op_minus
id|tmp
)paren
suffix:semicolon
id|size
op_assign
id|memparse
c_func
(paren
id|size_str
op_plus
l_int|8
comma
op_amp
id|size_str
)paren
suffix:semicolon
id|tmp
op_assign
id|size_str
op_plus
l_int|1
suffix:semicolon
id|size_str
op_assign
id|strstr
c_func
(paren
id|size_str
comma
l_string|&quot; rd_size=&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|tmp
)paren
id|strcat
c_func
(paren
id|command_line
comma
id|tmp
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MIPS64
multiline_comment|/* HACK: Guess if the sign extension was forgotten */
r_if
c_cond
(paren
id|start
OG
l_int|0x0000000080000000
op_logical_and
id|start
OL
l_int|0x00000000ffffffff
)paren
id|start
op_or_assign
l_int|0xffffffff00000000
suffix:semicolon
macro_line|#endif
id|end
op_assign
id|start
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|start
op_logical_and
id|end
)paren
(brace
op_star
id|rd_start
op_assign
id|start
suffix:semicolon
op_star
id|rd_end
op_assign
id|end
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|PFN_UP
mdefine_line|#define PFN_UP(x)&t;(((x) + PAGE_SIZE - 1) &gt;&gt; PAGE_SHIFT)
DECL|macro|PFN_DOWN
mdefine_line|#define PFN_DOWN(x)&t;((x) &gt;&gt; PAGE_SHIFT)
DECL|macro|PFN_PHYS
mdefine_line|#define PFN_PHYS(x)&t;((x) &lt;&lt; PAGE_SHIFT)
DECL|macro|MAXMEM
mdefine_line|#define MAXMEM&t;&t;HIGHMEM_START
DECL|macro|MAXMEM_PFN
mdefine_line|#define MAXMEM_PFN&t;PFN_DOWN(MAXMEM)
DECL|function|bootmem_init
r_static
r_inline
r_void
id|bootmem_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|start_pfn
suffix:semicolon
r_int
r_int
id|reserved_end
op_assign
(paren
r_int
r_int
)paren
op_amp
id|_end
suffix:semicolon
macro_line|#ifndef CONFIG_SGI_IP27
r_int
r_int
id|first_usable_pfn
suffix:semicolon
r_int
r_int
id|bootmap_size
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_int
id|initrd_reserve_bootmem
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Board specific code should have set up initrd_start and initrd_end */
id|ROOT_DEV
op_assign
id|Root_RAM0
suffix:semicolon
r_if
c_cond
(paren
id|parse_rd_cmdline
c_func
(paren
op_amp
id|initrd_start
comma
op_amp
id|initrd_end
)paren
)paren
(brace
id|reserved_end
op_assign
id|max
c_func
(paren
id|reserved_end
comma
id|initrd_end
)paren
suffix:semicolon
id|initrd_reserve_bootmem
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|tmp
suffix:semicolon
id|u32
op_star
id|initrd_header
suffix:semicolon
id|tmp
op_assign
(paren
(paren
id|reserved_end
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_amp
id|PAGE_MASK
)paren
op_minus
r_sizeof
(paren
id|u32
)paren
op_star
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
id|reserved_end
)paren
id|tmp
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|initrd_header
op_assign
(paren
id|u32
op_star
)paren
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|initrd_header
(braket
l_int|0
)braket
op_eq
l_int|0x494E5244
)paren
(brace
id|initrd_start
op_assign
(paren
r_int
r_int
)paren
op_amp
id|initrd_header
(braket
l_int|2
)braket
suffix:semicolon
id|initrd_end
op_assign
id|initrd_start
op_plus
id|initrd_header
(braket
l_int|1
)braket
suffix:semicolon
id|reserved_end
op_assign
id|max
c_func
(paren
id|reserved_end
comma
id|initrd_end
)paren
suffix:semicolon
id|initrd_reserve_bootmem
op_assign
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* CONFIG_BLK_DEV_INITRD */
multiline_comment|/*&n;&t; * Partially used pages are not usable - thus&n;&t; * we are rounding upwards.&n;&t; */
id|start_pfn
op_assign
id|PFN_UP
c_func
(paren
id|CPHYSADDR
c_func
(paren
id|reserved_end
)paren
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_SGI_IP27
multiline_comment|/* Find the highest page frame number we have available.  */
id|max_pfn
op_assign
l_int|0
suffix:semicolon
id|first_usable_pfn
op_assign
op_minus
l_int|1UL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|boot_mem_map.nr_map
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|start
comma
id|end
suffix:semicolon
r_if
c_cond
(paren
id|boot_mem_map.map
(braket
id|i
)braket
dot
id|type
op_ne
id|BOOT_MEM_RAM
)paren
r_continue
suffix:semicolon
id|start
op_assign
id|PFN_UP
c_func
(paren
id|boot_mem_map.map
(braket
id|i
)braket
dot
id|addr
)paren
suffix:semicolon
id|end
op_assign
id|PFN_DOWN
c_func
(paren
id|boot_mem_map.map
(braket
id|i
)braket
dot
id|addr
op_plus
id|boot_mem_map.map
(braket
id|i
)braket
dot
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start
op_ge
id|end
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|max_pfn
)paren
id|max_pfn
op_assign
id|end
suffix:semicolon
r_if
c_cond
(paren
id|start
OL
id|first_usable_pfn
)paren
(brace
r_if
c_cond
(paren
id|start
OG
id|start_pfn
)paren
(brace
id|first_usable_pfn
op_assign
id|start
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|end
OG
id|start_pfn
)paren
(brace
id|first_usable_pfn
op_assign
id|start_pfn
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Determine low and high memory ranges&n;&t; */
id|max_low_pfn
op_assign
id|max_pfn
suffix:semicolon
r_if
c_cond
(paren
id|max_low_pfn
OG
id|MAXMEM_PFN
)paren
(brace
id|max_low_pfn
op_assign
id|MAXMEM_PFN
suffix:semicolon
macro_line|#ifndef CONFIG_HIGHMEM
multiline_comment|/* Maximum memory usable is what is directly addressable */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Warning only %ldMB will be used.&bslash;n&quot;
comma
id|MAXMEM
op_rshift
l_int|20
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Use a HIGHMEM enabled kernel.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef CONFIG_HIGHMEM
multiline_comment|/*&n;&t; * Crude, we really should make a better attempt at detecting&n;&t; * highstart_pfn&n;&t; */
id|highstart_pfn
op_assign
id|highend_pfn
op_assign
id|max_pfn
suffix:semicolon
r_if
c_cond
(paren
id|max_pfn
OG
id|MAXMEM_PFN
)paren
(brace
id|highstart_pfn
op_assign
id|MAXMEM_PFN
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%ldMB HIGHMEM available.&bslash;n&quot;
comma
(paren
id|highend_pfn
op_minus
id|highstart_pfn
)paren
op_rshift
(paren
l_int|20
op_minus
id|PAGE_SHIFT
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Initialize the boot-time allocator with low memory only.  */
id|bootmap_size
op_assign
id|init_bootmem
c_func
(paren
id|first_usable_pfn
comma
id|max_low_pfn
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Register fully available low RAM pages with the bootmem allocator.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|boot_mem_map.nr_map
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|curr_pfn
comma
id|last_pfn
comma
id|size
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Reserve usable memory.&n;&t;&t; */
r_if
c_cond
(paren
id|boot_mem_map.map
(braket
id|i
)braket
dot
id|type
op_ne
id|BOOT_MEM_RAM
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We are rounding up the start address of usable memory:&n;&t;&t; */
id|curr_pfn
op_assign
id|PFN_UP
c_func
(paren
id|boot_mem_map.map
(braket
id|i
)braket
dot
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|curr_pfn
op_ge
id|max_low_pfn
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|curr_pfn
OL
id|start_pfn
)paren
id|curr_pfn
op_assign
id|start_pfn
suffix:semicolon
multiline_comment|/*&n;&t;&t; * ... and at the end of the usable range downwards:&n;&t;&t; */
id|last_pfn
op_assign
id|PFN_DOWN
c_func
(paren
id|boot_mem_map.map
(braket
id|i
)braket
dot
id|addr
op_plus
id|boot_mem_map.map
(braket
id|i
)braket
dot
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_pfn
OG
id|max_low_pfn
)paren
id|last_pfn
op_assign
id|max_low_pfn
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Only register lowmem part of lowmem segment with bootmem.&n;&t;&t; */
id|size
op_assign
id|last_pfn
op_minus
id|curr_pfn
suffix:semicolon
r_if
c_cond
(paren
id|curr_pfn
OG
id|PFN_DOWN
c_func
(paren
id|HIGHMEM_START
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|curr_pfn
op_plus
id|size
op_minus
l_int|1
OG
id|PFN_DOWN
c_func
(paren
id|HIGHMEM_START
)paren
)paren
id|size
op_assign
id|PFN_DOWN
c_func
(paren
id|HIGHMEM_START
)paren
op_minus
id|curr_pfn
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * ... finally, did all the rounding and playing&n;&t;&t; * around just make the area go away?&n;&t;&t; */
r_if
c_cond
(paren
id|last_pfn
op_le
id|curr_pfn
)paren
r_continue
suffix:semicolon
multiline_comment|/* Register lowmem ranges */
id|free_bootmem
c_func
(paren
id|PFN_PHYS
c_func
(paren
id|curr_pfn
)paren
comma
id|PFN_PHYS
c_func
(paren
id|size
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Reserve the bootmap memory.  */
id|reserve_bootmem
c_func
(paren
id|PFN_PHYS
c_func
(paren
id|first_usable_pfn
)paren
comma
id|bootmap_size
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SGI_IP27 */
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
id|initrd_below_start_ok
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|initrd_start
)paren
(brace
r_int
r_int
id|initrd_size
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|initrd_end
)paren
op_minus
(paren
(paren
r_int
r_char
op_star
)paren
id|initrd_start
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Initial ramdisk at: 0x%p (%lu bytes)&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|initrd_start
comma
id|initrd_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CPHYSADDR
c_func
(paren
id|initrd_end
)paren
OG
id|PFN_PHYS
c_func
(paren
id|max_low_pfn
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;initrd extends beyond end of memory &quot;
l_string|&quot;(0x%0*Lx &gt; 0x%0*Lx)&bslash;ndisabling initrd&bslash;n&quot;
comma
r_sizeof
(paren
r_int
)paren
op_star
l_int|2
comma
(paren
r_int
r_int
r_int
)paren
id|CPHYSADDR
c_func
(paren
id|initrd_end
)paren
comma
r_sizeof
(paren
r_int
)paren
op_star
l_int|2
comma
(paren
r_int
r_int
r_int
)paren
id|PFN_PHYS
c_func
(paren
id|max_low_pfn
)paren
)paren
suffix:semicolon
id|initrd_start
op_assign
id|initrd_end
op_assign
l_int|0
suffix:semicolon
id|initrd_reserve_bootmem
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|initrd_reserve_bootmem
)paren
id|reserve_bootmem
c_func
(paren
id|CPHYSADDR
c_func
(paren
id|initrd_start
)paren
comma
id|initrd_size
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_INITRD  */
)brace
DECL|function|resource_init
r_static
r_inline
r_void
id|resource_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
macro_line|#if defined(CONFIG_MIPS64) &amp;&amp; !defined(CONFIG_BUILD_ELF64)
multiline_comment|/*&n;&t; * The 64bit code in 32bit object format trick can&squot;t represent&n;&t; * 64bit wide relocations for linker script symbols.&n;&t; */
id|code_resource.start
op_assign
id|CPHYSADDR
c_func
(paren
op_amp
id|_text
)paren
suffix:semicolon
id|code_resource.end
op_assign
id|CPHYSADDR
c_func
(paren
op_amp
id|_etext
)paren
op_minus
l_int|1
suffix:semicolon
id|data_resource.start
op_assign
id|CPHYSADDR
c_func
(paren
op_amp
id|_etext
)paren
suffix:semicolon
id|data_resource.end
op_assign
id|CPHYSADDR
c_func
(paren
op_amp
id|_edata
)paren
op_minus
l_int|1
suffix:semicolon
macro_line|#else
id|code_resource.start
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|_text
)paren
suffix:semicolon
id|code_resource.end
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|_etext
)paren
op_minus
l_int|1
suffix:semicolon
id|data_resource.start
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|_etext
)paren
suffix:semicolon
id|data_resource.end
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|_edata
)paren
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Request address space for all standard RAM.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|boot_mem_map.nr_map
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|resource
op_star
id|res
suffix:semicolon
r_int
r_int
id|start
comma
id|end
suffix:semicolon
id|start
op_assign
id|boot_mem_map.map
(braket
id|i
)braket
dot
id|addr
suffix:semicolon
id|end
op_assign
id|boot_mem_map.map
(braket
id|i
)braket
dot
id|addr
op_plus
id|boot_mem_map.map
(braket
id|i
)braket
dot
id|size
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|start
op_ge
id|MAXMEM
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|end
op_ge
id|MAXMEM
)paren
id|end
op_assign
id|MAXMEM
op_minus
l_int|1
suffix:semicolon
id|res
op_assign
id|alloc_bootmem
c_func
(paren
r_sizeof
(paren
r_struct
id|resource
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|boot_mem_map.map
(braket
id|i
)braket
dot
id|type
)paren
(brace
r_case
id|BOOT_MEM_RAM
suffix:colon
r_case
id|BOOT_MEM_ROM_DATA
suffix:colon
id|res-&gt;name
op_assign
l_string|&quot;System RAM&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BOOT_MEM_RESERVED
suffix:colon
r_default
suffix:colon
id|res-&gt;name
op_assign
l_string|&quot;reserved&quot;
suffix:semicolon
)brace
id|res-&gt;start
op_assign
id|start
suffix:semicolon
id|res-&gt;end
op_assign
id|end
suffix:semicolon
id|res-&gt;flags
op_assign
id|IORESOURCE_MEM
op_or
id|IORESOURCE_BUSY
suffix:semicolon
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
id|res
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  We don&squot;t know which RAM region contains kernel data,&n;&t;&t; *  so we try it repeatedly and let the resource manager&n;&t;&t; *  test it.&n;&t;&t; */
id|request_resource
c_func
(paren
id|res
comma
op_amp
id|code_resource
)paren
suffix:semicolon
id|request_resource
c_func
(paren
id|res
comma
op_amp
id|data_resource
)paren
suffix:semicolon
)brace
)brace
DECL|macro|PFN_UP
macro_line|#undef PFN_UP
DECL|macro|PFN_DOWN
macro_line|#undef PFN_DOWN
DECL|macro|PFN_PHYS
macro_line|#undef PFN_PHYS
DECL|macro|MAXMEM
macro_line|#undef MAXMEM
DECL|macro|MAXMEM_PFN
macro_line|#undef MAXMEM_PFN
DECL|variable|earlyinit_debug
r_static
r_int
id|__initdata
id|earlyinit_debug
suffix:semicolon
DECL|function|earlyinit_debug_setup
r_static
r_int
id|__init
id|earlyinit_debug_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|earlyinit_debug
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;earlyinit_debug&quot;
comma
id|earlyinit_debug_setup
)paren
suffix:semicolon
r_extern
id|initcall_t
id|__earlyinitcall_start
comma
id|__earlyinitcall_end
suffix:semicolon
DECL|function|do_earlyinitcalls
r_static
r_void
id|__init
id|do_earlyinitcalls
c_func
(paren
r_void
)paren
(brace
id|initcall_t
op_star
id|call
comma
op_star
id|start
comma
op_star
id|end
suffix:semicolon
id|start
op_assign
op_amp
id|__earlyinitcall_start
suffix:semicolon
id|end
op_assign
op_amp
id|__earlyinitcall_end
suffix:semicolon
r_for
c_loop
(paren
id|call
op_assign
id|start
suffix:semicolon
id|call
OL
id|end
suffix:semicolon
id|call
op_increment
)paren
(brace
r_if
c_cond
(paren
id|earlyinit_debug
)paren
id|printk
c_func
(paren
l_string|&quot;calling earlyinitcall 0x%p&bslash;n&quot;
comma
op_star
id|call
)paren
suffix:semicolon
(paren
op_star
id|call
)paren
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|setup_arch
r_void
id|__init
id|setup_arch
c_func
(paren
r_char
op_star
op_star
id|cmdline_p
)paren
(brace
id|cpu_probe
c_func
(paren
)paren
suffix:semicolon
id|prom_init
c_func
(paren
)paren
suffix:semicolon
id|cpu_report
c_func
(paren
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_VT)
macro_line|#if defined(CONFIG_VGA_CONSOLE)
id|conswitchp
op_assign
op_amp
id|vga_con
suffix:semicolon
macro_line|#elif defined(CONFIG_DUMMY_CONSOLE)
id|conswitchp
op_assign
op_amp
id|dummy_con
suffix:semicolon
macro_line|#endif
macro_line|#endif
multiline_comment|/* call board setup routine */
id|do_earlyinitcalls
c_func
(paren
)paren
suffix:semicolon
id|strlcpy
c_func
(paren
id|command_line
comma
id|arcs_cmdline
comma
r_sizeof
(paren
id|command_line
)paren
)paren
suffix:semicolon
id|strlcpy
c_func
(paren
id|saved_command_line
comma
id|command_line
comma
id|COMMAND_LINE_SIZE
)paren
suffix:semicolon
op_star
id|cmdline_p
op_assign
id|command_line
suffix:semicolon
id|parse_cmdline_early
c_func
(paren
)paren
suffix:semicolon
id|bootmem_init
c_func
(paren
)paren
suffix:semicolon
id|paging_init
c_func
(paren
)paren
suffix:semicolon
id|resource_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|fpu_disable
r_int
id|__init
id|fpu_disable
c_func
(paren
r_char
op_star
id|s
)paren
(brace
id|cpu_data
(braket
l_int|0
)braket
dot
id|options
op_and_assign
op_complement
id|MIPS_CPU_FPU
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;nofpu&quot;
comma
id|fpu_disable
)paren
suffix:semicolon
eof
