multiline_comment|/*&n; * BRIEF MODULE DESCRIPTION&n; * Galileo Evaluation Boards PCI support.&n; *&n; * The general-purpose functions to read/write and configure the GT64120A&squot;s&n; * PCI registers (function names start with pci0 or pci1) are either direct&n; * copies of functions written by Galileo Technology, or are modifications&n; * of their functions to work with Linux 2.4 vs Linux 2.2.  These functions&n; * are Copyright - Galileo Technology.&n; *&n; * Other functions are derived from other MIPS PCI implementations, or were&n; * written by RidgeRun, Inc,  Copyright (C) 2000 RidgeRun, Inc.&n; *   glonnon@ridgerun.com, skranz@ridgerun.com, stevej@ridgerun.com&n; *&n; * Copyright 2001 MontaVista Software Inc.&n; * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net&n; *&n; *  This program is free software; you can redistribute  it and/or modify it&n; *  under  the terms of  the GNU General  Public License as published by the&n; *  Free Software Foundation;  either version 2 of the  License, or (at your&n; *  option) any later version.&n; *&n; *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS&squot;&squot; AND   ANY  EXPRESS OR IMPLIED&n; *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF&n; *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN&n; *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,&n; *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT&n; *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF&n; *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON&n; *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT&n; *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF&n; *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; *&n; *  You should have received a copy of the  GNU General Public License along&n; *  with this program; if not, write  to the Free Software Foundation, Inc.,&n; *  675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;asm/pci.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/gt64120/gt64120.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#ifdef CONFIG_PCI
DECL|macro|SELF
mdefine_line|#define SELF 0
multiline_comment|/*&n; * These functions and structures provide the BIOS scan and mapping of the PCI&n; * devices.&n; */
DECL|macro|MAX_PCI_DEVS
mdefine_line|#define MAX_PCI_DEVS 10
DECL|struct|pci_device
r_struct
id|pci_device
(brace
DECL|member|slot
id|u32
id|slot
suffix:semicolon
DECL|member|BARtype
id|u32
id|BARtype
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|BARsize
id|u32
id|BARsize
(braket
l_int|6
)braket
suffix:semicolon
)brace
suffix:semicolon
r_static
r_void
id|__init
id|scan_and_initialize_pci
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
id|u32
id|__init
id|scan_pci_bus
c_func
(paren
r_struct
id|pci_device
op_star
id|pci_devices
)paren
suffix:semicolon
r_static
r_void
id|__init
id|allocate_pci_space
c_func
(paren
r_struct
id|pci_device
op_star
id|pci_devices
)paren
suffix:semicolon
multiline_comment|/*&n; * The functions that actually read and write to the controller.&n; *&n; *  Copied from or modified from Galileo Technology code.&n; */
r_static
r_int
r_int
id|pci0ReadConfigReg
c_func
(paren
r_int
id|offset
comma
r_struct
id|pci_dev
op_star
id|device
)paren
suffix:semicolon
r_static
r_void
id|pci0WriteConfigReg
c_func
(paren
r_int
r_int
id|offset
comma
r_struct
id|pci_dev
op_star
id|device
comma
r_int
r_int
id|data
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci1ReadConfigReg
c_func
(paren
r_int
id|offset
comma
r_struct
id|pci_dev
op_star
id|device
)paren
suffix:semicolon
r_static
r_void
id|pci1WriteConfigReg
c_func
(paren
r_int
r_int
id|offset
comma
r_struct
id|pci_dev
op_star
id|device
comma
r_int
r_int
id|data
)paren
suffix:semicolon
r_static
r_void
id|pci0MapIOspace
c_func
(paren
r_int
r_int
id|pci0IoBase
comma
r_int
r_int
id|pci0IoLength
)paren
suffix:semicolon
r_static
r_void
id|pci1MapIOspace
c_func
(paren
r_int
r_int
id|pci1IoBase
comma
r_int
r_int
id|pci1IoLength
)paren
suffix:semicolon
r_static
r_void
id|pci0MapMemory0space
c_func
(paren
r_int
r_int
id|pci0Mem0Base
comma
r_int
r_int
id|pci0Mem0Length
)paren
suffix:semicolon
r_static
r_void
id|pci1MapMemory0space
c_func
(paren
r_int
r_int
id|pci1Mem0Base
comma
r_int
r_int
id|pci1Mem0Length
)paren
suffix:semicolon
r_static
r_void
id|pci0MapMemory1space
c_func
(paren
r_int
r_int
id|pci0Mem1Base
comma
r_int
r_int
id|pci0Mem1Length
)paren
suffix:semicolon
r_static
r_void
id|pci1MapMemory1space
c_func
(paren
r_int
r_int
id|pci1Mem1Base
comma
r_int
r_int
id|pci1Mem1Length
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci0GetIOspaceBase
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci0GetIOspaceSize
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci0GetMemory0Base
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci0GetMemory0Size
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci0GetMemory1Base
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci0GetMemory1Size
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci1GetIOspaceBase
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci1GetIOspaceSize
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci1GetMemory0Base
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci1GetMemory0Size
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci1GetMemory1Base
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
r_int
id|pci1GetMemory1Size
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*  Functions to implement &quot;pci ops&quot;  */
r_static
r_int
id|galileo_pcibios_read_config_word
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|offset
comma
id|u16
op_star
id|val
)paren
suffix:semicolon
r_static
r_int
id|galileo_pcibios_read_config_byte
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|offset
comma
id|u8
op_star
id|val
)paren
suffix:semicolon
r_static
r_int
id|galileo_pcibios_read_config_dword
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|offset
comma
id|u32
op_star
id|val
)paren
suffix:semicolon
r_static
r_int
id|galileo_pcibios_write_config_byte
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|offset
comma
id|u8
id|val
)paren
suffix:semicolon
r_static
r_int
id|galileo_pcibios_write_config_word
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|offset
comma
id|u16
id|val
)paren
suffix:semicolon
r_static
r_int
id|galileo_pcibios_write_config_dword
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_int
id|offset
comma
id|u32
id|val
)paren
suffix:semicolon
r_static
r_void
id|galileo_pcibios_set_master
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n; *  General-purpose PCI functions.&n; */
multiline_comment|/*&n; * pci0MapIOspace - Maps PCI0 IO space for the master.&n; * Inputs: base and length of pci0Io&n; */
DECL|function|pci0MapIOspace
r_static
r_void
id|pci0MapIOspace
c_func
(paren
r_int
r_int
id|pci0IoBase
comma
r_int
r_int
id|pci0IoLength
)paren
(brace
r_int
r_int
id|pci0IoTop
op_assign
(paren
r_int
r_int
)paren
(paren
id|pci0IoBase
op_plus
id|pci0IoLength
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci0IoLength
op_eq
l_int|0
)paren
id|pci0IoTop
op_increment
suffix:semicolon
id|pci0IoBase
op_assign
(paren
r_int
r_int
)paren
(paren
id|pci0IoBase
op_rshift
l_int|21
)paren
suffix:semicolon
id|pci0IoTop
op_assign
(paren
r_int
r_int
)paren
(paren
(paren
(paren
id|pci0IoTop
op_minus
l_int|1
)paren
op_amp
l_int|0x0fffffff
)paren
op_rshift
l_int|21
)paren
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI0IOLD_OFS
comma
id|pci0IoBase
)paren
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI0IOHD_OFS
comma
id|pci0IoTop
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci1MapIOspace - Maps PCI1 IO space for the master.&n; * Inputs: base and length of pci1Io&n; */
DECL|function|pci1MapIOspace
r_static
r_void
id|pci1MapIOspace
c_func
(paren
r_int
r_int
id|pci1IoBase
comma
r_int
r_int
id|pci1IoLength
)paren
(brace
r_int
r_int
id|pci1IoTop
op_assign
(paren
r_int
r_int
)paren
(paren
id|pci1IoBase
op_plus
id|pci1IoLength
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci1IoLength
op_eq
l_int|0
)paren
id|pci1IoTop
op_increment
suffix:semicolon
id|pci1IoBase
op_assign
(paren
r_int
r_int
)paren
(paren
id|pci1IoBase
op_rshift
l_int|21
)paren
suffix:semicolon
id|pci1IoTop
op_assign
(paren
r_int
r_int
)paren
(paren
(paren
(paren
id|pci1IoTop
op_minus
l_int|1
)paren
op_amp
l_int|0x0fffffff
)paren
op_rshift
l_int|21
)paren
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI1IOLD_OFS
comma
id|pci1IoBase
)paren
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI1IOHD_OFS
comma
id|pci1IoTop
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci0MapMemory0space - Maps PCI0 memory0 space for the master.&n; * Inputs: base and length of pci0Mem0&n; */
DECL|function|pci0MapMemory0space
r_static
r_void
id|pci0MapMemory0space
c_func
(paren
r_int
r_int
id|pci0Mem0Base
comma
r_int
r_int
id|pci0Mem0Length
)paren
(brace
r_int
r_int
id|pci0Mem0Top
op_assign
id|pci0Mem0Base
op_plus
id|pci0Mem0Length
suffix:semicolon
r_if
c_cond
(paren
id|pci0Mem0Length
op_eq
l_int|0
)paren
id|pci0Mem0Top
op_increment
suffix:semicolon
id|pci0Mem0Base
op_assign
id|pci0Mem0Base
op_rshift
l_int|21
suffix:semicolon
id|pci0Mem0Top
op_assign
(paren
(paren
id|pci0Mem0Top
op_minus
l_int|1
)paren
op_amp
l_int|0x0fffffff
)paren
op_rshift
l_int|21
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI0M0LD_OFS
comma
id|pci0Mem0Base
)paren
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI0M0HD_OFS
comma
id|pci0Mem0Top
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci1MapMemory0space - Maps PCI1 memory0 space for the master.&n; * Inputs: base and length of pci1Mem0&n; */
DECL|function|pci1MapMemory0space
r_static
r_void
id|pci1MapMemory0space
c_func
(paren
r_int
r_int
id|pci1Mem0Base
comma
r_int
r_int
id|pci1Mem0Length
)paren
(brace
r_int
r_int
id|pci1Mem0Top
op_assign
id|pci1Mem0Base
op_plus
id|pci1Mem0Length
suffix:semicolon
r_if
c_cond
(paren
id|pci1Mem0Length
op_eq
l_int|0
)paren
id|pci1Mem0Top
op_increment
suffix:semicolon
id|pci1Mem0Base
op_assign
id|pci1Mem0Base
op_rshift
l_int|21
suffix:semicolon
id|pci1Mem0Top
op_assign
(paren
(paren
id|pci1Mem0Top
op_minus
l_int|1
)paren
op_amp
l_int|0x0fffffff
)paren
op_rshift
l_int|21
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI1M0LD_OFS
comma
id|pci1Mem0Base
)paren
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI1M0HD_OFS
comma
id|pci1Mem0Top
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci0MapMemory1space - Maps PCI0 memory1 space for the master.&n; * Inputs: base and length of pci0Mem1&n; */
DECL|function|pci0MapMemory1space
r_static
r_void
id|pci0MapMemory1space
c_func
(paren
r_int
r_int
id|pci0Mem1Base
comma
r_int
r_int
id|pci0Mem1Length
)paren
(brace
r_int
r_int
id|pci0Mem1Top
op_assign
id|pci0Mem1Base
op_plus
id|pci0Mem1Length
suffix:semicolon
r_if
c_cond
(paren
id|pci0Mem1Length
op_eq
l_int|0
)paren
id|pci0Mem1Top
op_increment
suffix:semicolon
id|pci0Mem1Base
op_assign
id|pci0Mem1Base
op_rshift
l_int|21
suffix:semicolon
id|pci0Mem1Top
op_assign
(paren
(paren
id|pci0Mem1Top
op_minus
l_int|1
)paren
op_amp
l_int|0x0fffffff
)paren
op_rshift
l_int|21
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI0M1LD_OFS
comma
id|pci0Mem1Base
)paren
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI0M1HD_OFS
comma
id|pci0Mem1Top
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci1MapMemory1space - Maps PCI1 memory1 space for the master.&n; * Inputs: base and length of pci1Mem1&n; */
DECL|function|pci1MapMemory1space
r_static
r_void
id|pci1MapMemory1space
c_func
(paren
r_int
r_int
id|pci1Mem1Base
comma
r_int
r_int
id|pci1Mem1Length
)paren
(brace
r_int
r_int
id|pci1Mem1Top
op_assign
id|pci1Mem1Base
op_plus
id|pci1Mem1Length
suffix:semicolon
r_if
c_cond
(paren
id|pci1Mem1Length
op_eq
l_int|0
)paren
id|pci1Mem1Top
op_increment
suffix:semicolon
id|pci1Mem1Base
op_assign
id|pci1Mem1Base
op_rshift
l_int|21
suffix:semicolon
id|pci1Mem1Top
op_assign
(paren
(paren
id|pci1Mem1Top
op_minus
l_int|1
)paren
op_amp
l_int|0x0fffffff
)paren
op_rshift
l_int|21
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI1M1LD_OFS
comma
id|pci1Mem1Base
)paren
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI1M1HD_OFS
comma
id|pci1Mem1Top
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci0GetIOspaceBase - Return PCI0 IO Base Address.&n; * Inputs: N/A&n; * Returns: PCI0 IO Base Address.&n; */
DECL|function|pci0GetIOspaceBase
r_static
r_int
r_int
id|pci0GetIOspaceBase
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|base
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI0IOLD_OFS
comma
op_amp
id|base
)paren
suffix:semicolon
id|base
op_assign
id|base
op_lshift
l_int|21
suffix:semicolon
r_return
id|base
suffix:semicolon
)brace
multiline_comment|/*&n; * pci0GetIOspaceSize - Return PCI0 IO Bar Size.&n; * Inputs: N/A&n; * Returns: PCI0 IO Bar Size.&n; */
DECL|function|pci0GetIOspaceSize
r_static
r_int
r_int
id|pci0GetIOspaceSize
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|top
comma
id|base
comma
id|size
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI0IOLD_OFS
comma
op_amp
id|base
)paren
suffix:semicolon
id|base
op_assign
id|base
op_lshift
l_int|21
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI0IOHD_OFS
comma
op_amp
id|top
)paren
suffix:semicolon
id|top
op_assign
(paren
id|top
op_lshift
l_int|21
)paren
suffix:semicolon
id|size
op_assign
(paren
(paren
id|top
op_minus
id|base
)paren
op_amp
l_int|0xfffffff
)paren
suffix:semicolon
id|size
op_assign
id|size
op_or
l_int|0x1fffff
suffix:semicolon
r_return
(paren
id|size
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci0GetMemory0Base - Return PCI0 Memory 0 Base Address.&n; * Inputs: N/A&n; * Returns: PCI0 Memory 0 Base Address.&n; */
DECL|function|pci0GetMemory0Base
r_static
r_int
r_int
id|pci0GetMemory0Base
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|base
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI0M0LD_OFS
comma
op_amp
id|base
)paren
suffix:semicolon
id|base
op_assign
id|base
op_lshift
l_int|21
suffix:semicolon
r_return
id|base
suffix:semicolon
)brace
multiline_comment|/*&n; * pci0GetMemory0Size - Return PCI0 Memory 0 Bar Size.&n; * Inputs: N/A&n; * Returns: PCI0 Memory 0 Bar Size.&n; */
DECL|function|pci0GetMemory0Size
r_static
r_int
r_int
id|pci0GetMemory0Size
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|top
comma
id|base
comma
id|size
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI0M0LD_OFS
comma
op_amp
id|base
)paren
suffix:semicolon
id|base
op_assign
id|base
op_lshift
l_int|21
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI0M0HD_OFS
comma
op_amp
id|top
)paren
suffix:semicolon
id|top
op_assign
(paren
id|top
op_lshift
l_int|21
)paren
suffix:semicolon
id|size
op_assign
(paren
(paren
id|top
op_minus
id|base
)paren
op_amp
l_int|0xfffffff
)paren
suffix:semicolon
id|size
op_assign
id|size
op_or
l_int|0x1fffff
suffix:semicolon
r_return
(paren
id|size
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci0GetMemory1Base - Return PCI0 Memory 1 Base Address.&n; * Inputs: N/A&n; * Returns: PCI0 Memory 1 Base Address.&n; */
DECL|function|pci0GetMemory1Base
r_static
r_int
r_int
id|pci0GetMemory1Base
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|base
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI0M1LD_OFS
comma
op_amp
id|base
)paren
suffix:semicolon
id|base
op_assign
id|base
op_lshift
l_int|21
suffix:semicolon
r_return
id|base
suffix:semicolon
)brace
multiline_comment|/*&n; * pci0GetMemory1Size - Return PCI0 Memory 1 Bar Size.&n; * Inputs: N/A&n; * Returns: PCI0 Memory 1 Bar Size.&n; */
DECL|function|pci0GetMemory1Size
r_static
r_int
r_int
id|pci0GetMemory1Size
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|top
comma
id|base
comma
id|size
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI0M1LD_OFS
comma
op_amp
id|base
)paren
suffix:semicolon
id|base
op_assign
id|base
op_lshift
l_int|21
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI0M1HD_OFS
comma
op_amp
id|top
)paren
suffix:semicolon
id|top
op_assign
(paren
id|top
op_lshift
l_int|21
)paren
suffix:semicolon
id|size
op_assign
(paren
(paren
id|top
op_minus
id|base
)paren
op_amp
l_int|0xfffffff
)paren
suffix:semicolon
id|size
op_assign
id|size
op_or
l_int|0x1fffff
suffix:semicolon
r_return
(paren
id|size
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci1GetIOspaceBase - Return PCI1 IO Base Address.&n; * Inputs: N/A&n; * Returns: PCI1 IO Base Address.&n; */
DECL|function|pci1GetIOspaceBase
r_static
r_int
r_int
id|pci1GetIOspaceBase
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|base
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI1IOLD_OFS
comma
op_amp
id|base
)paren
suffix:semicolon
id|base
op_assign
id|base
op_lshift
l_int|21
suffix:semicolon
r_return
id|base
suffix:semicolon
)brace
multiline_comment|/*&n; * pci1GetIOspaceSize - Return PCI1 IO Bar Size.&n; * Inputs: N/A&n; * Returns: PCI1 IO Bar Size.&n; */
DECL|function|pci1GetIOspaceSize
r_static
r_int
r_int
id|pci1GetIOspaceSize
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|top
comma
id|base
comma
id|size
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI1IOLD_OFS
comma
op_amp
id|base
)paren
suffix:semicolon
id|base
op_assign
id|base
op_lshift
l_int|21
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI1IOHD_OFS
comma
op_amp
id|top
)paren
suffix:semicolon
id|top
op_assign
(paren
id|top
op_lshift
l_int|21
)paren
suffix:semicolon
id|size
op_assign
(paren
(paren
id|top
op_minus
id|base
)paren
op_amp
l_int|0xfffffff
)paren
suffix:semicolon
id|size
op_assign
id|size
op_or
l_int|0x1fffff
suffix:semicolon
r_return
(paren
id|size
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci1GetMemory0Base - Return PCI1 Memory 0 Base Address.&n; * Inputs: N/A&n; * Returns: PCI1 Memory 0 Base Address.&n; */
DECL|function|pci1GetMemory0Base
r_static
r_int
r_int
id|pci1GetMemory0Base
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|base
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI1M0LD_OFS
comma
op_amp
id|base
)paren
suffix:semicolon
id|base
op_assign
id|base
op_lshift
l_int|21
suffix:semicolon
r_return
id|base
suffix:semicolon
)brace
multiline_comment|/*&n; * pci1GetMemory0Size - Return PCI1 Memory 0 Bar Size.&n; * Inputs: N/A&n; * Returns: PCI1 Memory 0 Bar Size.&n; */
DECL|function|pci1GetMemory0Size
r_static
r_int
r_int
id|pci1GetMemory0Size
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|top
comma
id|base
comma
id|size
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI1M1LD_OFS
comma
op_amp
id|base
)paren
suffix:semicolon
id|base
op_assign
id|base
op_lshift
l_int|21
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI1M1HD_OFS
comma
op_amp
id|top
)paren
suffix:semicolon
id|top
op_assign
(paren
id|top
op_lshift
l_int|21
)paren
suffix:semicolon
id|size
op_assign
(paren
(paren
id|top
op_minus
id|base
)paren
op_amp
l_int|0xfffffff
)paren
suffix:semicolon
id|size
op_assign
id|size
op_or
l_int|0x1fffff
suffix:semicolon
r_return
(paren
id|size
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci1GetMemory1Base - Return PCI1 Memory 1 Base Address.&n; * Inputs: N/A&n; * Returns: PCI1 Memory 1 Base Address.&n; */
DECL|function|pci1GetMemory1Base
r_static
r_int
r_int
id|pci1GetMemory1Base
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|base
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI1M1LD_OFS
comma
op_amp
id|base
)paren
suffix:semicolon
id|base
op_assign
id|base
op_lshift
l_int|21
suffix:semicolon
r_return
id|base
suffix:semicolon
)brace
multiline_comment|/*&n; * pci1GetMemory1Size - Return PCI1 Memory 1 Bar Size.&n; * Inputs: N/A&n; * Returns: PCI1 Memory 1 Bar Size.&n; */
DECL|function|pci1GetMemory1Size
r_static
r_int
r_int
id|pci1GetMemory1Size
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|top
comma
id|base
comma
id|size
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI1M1LD_OFS
comma
op_amp
id|base
)paren
suffix:semicolon
id|base
op_assign
id|base
op_lshift
l_int|21
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI1M1HD_OFS
comma
op_amp
id|top
)paren
suffix:semicolon
id|top
op_assign
(paren
id|top
op_lshift
l_int|21
)paren
suffix:semicolon
id|size
op_assign
(paren
(paren
id|top
op_minus
id|base
)paren
op_amp
l_int|0xfffffff
)paren
suffix:semicolon
id|size
op_assign
id|size
op_or
l_int|0x1fffff
suffix:semicolon
r_return
(paren
id|size
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pci_range_ck -&n; *&n; * Check if the pci device that are trying to access does really exists&n; * on the evaluation board.  &n; *&n; * Inputs :&n; * bus - bus number (0 for PCI 0 ; 1 for PCI 1)&n; * dev - number of device on the specific pci bus&n; *&n; * Outpus :&n; * 0 - if OK , 1 - if failure&n; */
DECL|function|pci_range_ck
r_static
id|__inline__
r_int
id|pci_range_ck
c_func
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|dev
)paren
(brace
multiline_comment|/*&n;&t; * We don&squot;t even pretend to handle other busses than bus 0 correctly.&n;&t; * Accessing device 31 crashes the CP7000 for some reason.&n;&t; */
r_if
c_cond
(paren
(paren
id|bus
op_eq
l_int|0
)paren
op_logical_and
(paren
id|dev
op_ne
l_int|31
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * pciXReadConfigReg  - Read from a PCI configuration register&n; *                    - Make sure the GT is configured as a master before &n; *                      reading from another device on the PCI.&n; *                   - The function takes care of Big/Little endian conversion.&n; * INPUTS:   regOffset: The register offset as it apears in the GT spec (or PCI&n; *                        spec)&n; *           pciDevNum: The device number needs to be addressed.                &n; * RETURNS: data , if the data == 0xffffffff check the master abort bit in the &n; *                 cause register to make sure the data is valid&n; *&n; *  Configuration Address 0xCF8:&n; *&n; *       31 30    24 23  16 15  11 10     8 7      2  0     &lt;=bit Number&n; *  |congif|Reserved|  Bus |Device|Function|Register|00|&n; *  |Enable|        |Number|Number| Number | Number |  |    &lt;=field Name&n; *&n; */
DECL|function|pci0ReadConfigReg
r_static
r_int
r_int
id|pci0ReadConfigReg
c_func
(paren
r_int
id|offset
comma
r_struct
id|pci_dev
op_star
id|device
)paren
(brace
r_int
r_int
id|DataForRegCf8
suffix:semicolon
r_int
r_int
id|data
suffix:semicolon
id|DataForRegCf8
op_assign
(paren
(paren
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
op_lshift
l_int|11
)paren
op_or
(paren
id|PCI_FUNC
c_func
(paren
id|device-&gt;devfn
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|offset
op_amp
op_complement
l_int|0x3
)paren
)paren
op_or
l_int|0x80000000
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI0_CFGADDR_OFS
comma
id|DataForRegCf8
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The casual observer might wonder why the READ is duplicated here,&n;&t; * rather than immediately following the WRITE, and just have the swap&n;&t; * in the &quot;if&quot;.  That&squot;s because there is a latency problem with trying&n;&t; * to read immediately after setting up the address register.  The &quot;if&quot;&n;&t; * check gives enough time for the address to stabilize, so the READ&n;&t; * can work.&n;&t; */
r_if
c_cond
(paren
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
op_eq
id|SELF
)paren
(brace
multiline_comment|/* This board */
id|GT_READ
c_func
(paren
id|GT_PCI0_CFGDATA_OFS
comma
op_amp
id|data
)paren
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The PCI is working in LE Mode so swap the Data. */
id|GT_READ
c_func
(paren
id|GT_PCI0_CFGDATA_OFS
comma
op_amp
id|data
)paren
suffix:semicolon
r_return
id|cpu_to_le32
c_func
(paren
id|data
)paren
suffix:semicolon
)brace
)brace
DECL|function|pci1ReadConfigReg
r_static
r_int
r_int
id|pci1ReadConfigReg
c_func
(paren
r_int
id|offset
comma
r_struct
id|pci_dev
op_star
id|device
)paren
(brace
r_int
r_int
id|DataForRegCf8
suffix:semicolon
r_int
r_int
id|data
suffix:semicolon
id|DataForRegCf8
op_assign
(paren
(paren
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
op_lshift
l_int|11
)paren
op_or
(paren
id|PCI_FUNC
c_func
(paren
id|device-&gt;devfn
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|offset
op_amp
op_complement
l_int|0x3
)paren
)paren
op_or
l_int|0x80000000
suffix:semicolon
multiline_comment|/*&n;&t; * The casual observer might wonder why the READ is duplicated here,&n;&t; * rather than immediately following the WRITE, and just have the&n;&t; * swap in the &quot;if&quot;.  That&squot;s because there is a latency problem&n;&t; * with trying to read immediately after setting up the address&n;&t; * register.  The &quot;if&quot; check gives enough time for the address&n;&t; * to stabilize, so the READ can work.&n;&t; */
r_if
c_cond
(paren
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
op_eq
id|SELF
)paren
(brace
multiline_comment|/* This board */
multiline_comment|/* when configurating our own PCI 1 L-unit the access is through  &n;&t;&t;   the PCI 0 interface with reg number = reg number + 0x80 */
id|DataForRegCf8
op_or_assign
l_int|0x80
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI0_CFGADDR_OFS
comma
id|DataForRegCf8
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The PCI is working in LE Mode so swap the Data. */
id|GT_WRITE
c_func
(paren
id|GT_PCI1_CFGADDR_OFS
comma
id|DataForRegCf8
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
op_eq
id|SELF
)paren
(brace
multiline_comment|/* This board */
id|GT_READ
c_func
(paren
id|GT_PCI0_CFGDATA_OFS
comma
op_amp
id|data
)paren
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
r_else
(brace
id|GT_READ
c_func
(paren
id|GT_PCI1_CFGDATA_OFS
comma
op_amp
id|data
)paren
suffix:semicolon
r_return
id|cpu_to_le32
c_func
(paren
id|data
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * pciXWriteConfigReg - Write to a PCI configuration register&n; *                    - Make sure the GT is configured as a master before &n; *                      writingto another device on the PCI.&n; *                    - The function takes care of Big/Little endian conversion.&n; * Inputs:   unsigned int regOffset: The register offset as it apears in the&n; *           GT spec &n; *                   (or any other PCI device spec)&n; *           pciDevNum: The device number needs to be addressed.                &n; *&n; *  Configuration Address 0xCF8:&n; *&n; *       31 30    24 23  16 15  11 10     8 7      2  0     &lt;=bit Number&n; *  |congif|Reserved|  Bus |Device|Function|Register|00|&n; *  |Enable|        |Number|Number| Number | Number |  |    &lt;=field Name&n; *&n; */
DECL|function|pci0WriteConfigReg
r_static
r_void
id|pci0WriteConfigReg
c_func
(paren
r_int
r_int
id|offset
comma
r_struct
id|pci_dev
op_star
id|device
comma
r_int
r_int
id|data
)paren
(brace
r_int
r_int
id|DataForRegCf8
suffix:semicolon
id|DataForRegCf8
op_assign
(paren
(paren
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
op_lshift
l_int|11
)paren
op_or
(paren
id|PCI_FUNC
c_func
(paren
id|device-&gt;devfn
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|offset
op_amp
op_complement
l_int|0x3
)paren
)paren
op_or
l_int|0x80000000
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI0_CFGADDR_OFS
comma
id|DataForRegCf8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
op_eq
id|SELF
)paren
(brace
multiline_comment|/* This board */
id|GT_WRITE
c_func
(paren
id|GT_PCI0_CFGDATA_OFS
comma
id|data
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* configuration Transaction over the pci. */
multiline_comment|/* The PCI is working in LE Mode so swap the Data. */
id|GT_WRITE
c_func
(paren
id|GT_PCI0_CFGDATA_OFS
comma
id|le32_to_cpu
c_func
(paren
id|data
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|pci1WriteConfigReg
r_static
r_void
id|pci1WriteConfigReg
c_func
(paren
r_int
r_int
id|offset
comma
r_struct
id|pci_dev
op_star
id|device
comma
r_int
r_int
id|data
)paren
(brace
r_int
r_int
id|DataForRegCf8
suffix:semicolon
id|DataForRegCf8
op_assign
(paren
(paren
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
op_lshift
l_int|11
)paren
op_or
(paren
id|PCI_FUNC
c_func
(paren
id|device-&gt;devfn
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|offset
op_amp
op_complement
l_int|0x3
)paren
)paren
op_or
l_int|0x80000000
suffix:semicolon
multiline_comment|/*&n;&t; * There is a latency problem&n;&t; * with trying to read immediately after setting up the address&n;&t; * register.  The &quot;if&quot; check gives enough time for the address&n;&t; * to stabilize, so the WRITE can work.&n;&t; */
r_if
c_cond
(paren
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
op_eq
id|SELF
)paren
(brace
multiline_comment|/* This board */
multiline_comment|/*&n;&t;&t; * when configurating our own PCI 1 L-unit the access is through&n;&t;&t; * the PCI 0 interface with reg number = reg number + 0x80&n;&t;&t; */
id|DataForRegCf8
op_or_assign
l_int|0x80
suffix:semicolon
id|GT_WRITE
c_func
(paren
id|GT_PCI0_CFGADDR_OFS
comma
id|DataForRegCf8
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* configuration Transaction over the pci. */
multiline_comment|/* The PCI is working in LE Mode so swap the Data. */
id|GT_WRITE
c_func
(paren
id|GT_PCI1_CFGADDR_OFS
comma
id|DataForRegCf8
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
op_eq
id|SELF
)paren
(brace
multiline_comment|/* This board */
id|GT_WRITE
c_func
(paren
id|GT_PCI0_CFGDATA_OFS
comma
id|data
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* configuration Transaction over the pci. */
id|GT_WRITE
c_func
(paren
id|GT_PCI1_CFGADDR_OFS
comma
id|le32_to_cpu
c_func
(paren
id|data
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * galileo_pcibios_(read/write)_config_(dword/word/byte) -&n; *&n; * reads/write a dword/word/byte register from the configuration space&n; * of a device.&n; *&n; * Inputs :&n; * bus - bus number&n; * dev - device number&n; * offset - register offset in the configuration space&n; * val - value to be written / read&n; *&n; * Outputs :&n; * PCIBIOS_SUCCESSFUL when operation was succesfull&n; * PCIBIOS_DEVICE_NOT_FOUND when the bus or dev is errorneous&n; * PCIBIOS_BAD_REGISTER_NUMBER when accessing non aligned&n; */
DECL|function|galileo_pcibios_read_config_dword
r_static
r_int
id|galileo_pcibios_read_config_dword
c_func
(paren
r_struct
id|pci_dev
op_star
id|device
comma
r_int
id|offset
comma
id|u32
op_star
id|val
)paren
(brace
r_int
id|dev
comma
id|bus
suffix:semicolon
id|bus
op_assign
id|device-&gt;bus-&gt;number
suffix:semicolon
id|dev
op_assign
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_range_ck
c_func
(paren
id|bus
comma
id|dev
)paren
)paren
(brace
op_star
id|val
op_assign
l_int|0xffffffff
suffix:semicolon
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offset
op_amp
l_int|0x3
)paren
r_return
id|PCIBIOS_BAD_REGISTER_NUMBER
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_eq
l_int|0
)paren
op_star
id|val
op_assign
id|pci0ReadConfigReg
c_func
(paren
id|offset
comma
id|device
)paren
suffix:semicolon
multiline_comment|/*  This is so that the upper PCI layer will get the correct return value if&n;&t;   we&squot;re not attached to anything.  */
r_if
c_cond
(paren
(paren
id|offset
op_eq
l_int|0
)paren
op_logical_and
(paren
op_star
id|val
op_eq
l_int|0xffffffff
)paren
)paren
(brace
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
)brace
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|galileo_pcibios_read_config_word
r_static
r_int
id|galileo_pcibios_read_config_word
c_func
(paren
r_struct
id|pci_dev
op_star
id|device
comma
r_int
id|offset
comma
id|u16
op_star
id|val
)paren
(brace
r_int
id|dev
comma
id|bus
suffix:semicolon
id|bus
op_assign
id|device-&gt;bus-&gt;number
suffix:semicolon
id|dev
op_assign
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_range_ck
c_func
(paren
id|bus
comma
id|dev
)paren
)paren
(brace
op_star
id|val
op_assign
l_int|0xffff
suffix:semicolon
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offset
op_amp
l_int|0x1
)paren
r_return
id|PCIBIOS_BAD_REGISTER_NUMBER
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_eq
l_int|0
)paren
op_star
id|val
op_assign
(paren
r_int
r_int
)paren
(paren
id|pci0ReadConfigReg
c_func
(paren
id|offset
comma
id|device
)paren
op_rshift
(paren
(paren
id|offset
op_amp
op_complement
l_int|0x3
)paren
op_star
l_int|8
)paren
)paren
suffix:semicolon
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|galileo_pcibios_read_config_byte
r_static
r_int
id|galileo_pcibios_read_config_byte
c_func
(paren
r_struct
id|pci_dev
op_star
id|device
comma
r_int
id|offset
comma
id|u8
op_star
id|val
)paren
(brace
r_int
id|dev
comma
id|bus
suffix:semicolon
id|bus
op_assign
id|device-&gt;bus-&gt;number
suffix:semicolon
id|dev
op_assign
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_range_ck
c_func
(paren
id|bus
comma
id|dev
)paren
)paren
(brace
op_star
id|val
op_assign
l_int|0xff
suffix:semicolon
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bus
op_eq
l_int|0
)paren
op_star
id|val
op_assign
(paren
r_int
r_char
)paren
(paren
id|pci0ReadConfigReg
c_func
(paren
id|offset
comma
id|device
)paren
op_rshift
(paren
(paren
id|offset
op_amp
op_complement
l_int|0x3
)paren
op_star
l_int|8
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  This is so that the upper PCI layer will get the correct return&n;&t; * value if we&squot;re not attached to anything.&n;&t; */
r_if
c_cond
(paren
(paren
id|offset
op_eq
l_int|0xe
)paren
op_logical_and
(paren
op_star
id|val
op_eq
l_int|0xff
)paren
)paren
(brace
id|u32
id|MasterAbort
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_INTRCAUSE_OFS
comma
op_amp
id|MasterAbort
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MasterAbort
op_amp
l_int|0x40000
)paren
(brace
id|GT_WRITE
c_func
(paren
id|GT_INTRCAUSE_OFS
comma
(paren
id|MasterAbort
op_amp
l_int|0xfffbffff
)paren
)paren
suffix:semicolon
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
)brace
)brace
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|galileo_pcibios_write_config_dword
r_static
r_int
id|galileo_pcibios_write_config_dword
c_func
(paren
r_struct
id|pci_dev
op_star
id|device
comma
r_int
id|offset
comma
id|u32
id|val
)paren
(brace
r_int
id|dev
comma
id|bus
suffix:semicolon
id|bus
op_assign
id|device-&gt;bus-&gt;number
suffix:semicolon
id|dev
op_assign
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_range_ck
c_func
(paren
id|bus
comma
id|dev
)paren
)paren
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_amp
l_int|0x3
)paren
r_return
id|PCIBIOS_BAD_REGISTER_NUMBER
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_eq
l_int|0
)paren
id|pci0WriteConfigReg
c_func
(paren
id|offset
comma
id|device
comma
id|val
)paren
suffix:semicolon
singleline_comment|//  if (bus == 1) pci1WriteConfigReg (offset,device,val);
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|galileo_pcibios_write_config_word
r_static
r_int
id|galileo_pcibios_write_config_word
c_func
(paren
r_struct
id|pci_dev
op_star
id|device
comma
r_int
id|offset
comma
id|u16
id|val
)paren
(brace
r_int
id|dev
comma
id|bus
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
id|bus
op_assign
id|device-&gt;bus-&gt;number
suffix:semicolon
id|dev
op_assign
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_range_ck
c_func
(paren
id|bus
comma
id|dev
)paren
)paren
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_amp
l_int|0x1
)paren
r_return
id|PCIBIOS_BAD_REGISTER_NUMBER
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_eq
l_int|0
)paren
id|tmp
op_assign
id|pci0ReadConfigReg
c_func
(paren
id|offset
comma
id|device
)paren
suffix:semicolon
singleline_comment|//  if (bus == 1) tmp = pci1ReadConfigReg (offset,device);
r_if
c_cond
(paren
(paren
id|offset
op_mod
l_int|4
)paren
op_eq
l_int|0
)paren
id|tmp
op_assign
(paren
id|tmp
op_amp
l_int|0xffff0000
)paren
op_or
(paren
id|val
op_amp
l_int|0xffff
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|offset
op_mod
l_int|4
)paren
op_eq
l_int|2
)paren
id|tmp
op_assign
(paren
id|tmp
op_amp
l_int|0x0000ffff
)paren
op_or
(paren
(paren
id|val
op_amp
l_int|0xffff
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_eq
l_int|0
)paren
id|pci0WriteConfigReg
c_func
(paren
id|offset
comma
id|device
comma
id|tmp
)paren
suffix:semicolon
singleline_comment|//  if (bus == 1) pci1WriteConfigReg (offset,device,tmp);
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|galileo_pcibios_write_config_byte
r_static
r_int
id|galileo_pcibios_write_config_byte
c_func
(paren
r_struct
id|pci_dev
op_star
id|device
comma
r_int
id|offset
comma
id|u8
id|val
)paren
(brace
r_int
id|dev
comma
id|bus
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
id|bus
op_assign
id|device-&gt;bus-&gt;number
suffix:semicolon
id|dev
op_assign
id|PCI_SLOT
c_func
(paren
id|device-&gt;devfn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_range_ck
c_func
(paren
id|bus
comma
id|dev
)paren
)paren
r_return
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_eq
l_int|0
)paren
id|tmp
op_assign
id|pci0ReadConfigReg
c_func
(paren
id|offset
comma
id|device
)paren
suffix:semicolon
singleline_comment|//  if (bus == 1) tmp = pci1ReadConfigReg (offset,device);
r_if
c_cond
(paren
(paren
id|offset
op_mod
l_int|4
)paren
op_eq
l_int|0
)paren
id|tmp
op_assign
(paren
id|tmp
op_amp
l_int|0xffffff00
)paren
op_or
(paren
id|val
op_amp
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|offset
op_mod
l_int|4
)paren
op_eq
l_int|1
)paren
id|tmp
op_assign
(paren
id|tmp
op_amp
l_int|0xffff00ff
)paren
op_or
(paren
(paren
id|val
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|offset
op_mod
l_int|4
)paren
op_eq
l_int|2
)paren
id|tmp
op_assign
(paren
id|tmp
op_amp
l_int|0xff00ffff
)paren
op_or
(paren
(paren
id|val
op_amp
l_int|0xff
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|offset
op_mod
l_int|4
)paren
op_eq
l_int|3
)paren
id|tmp
op_assign
(paren
id|tmp
op_amp
l_int|0x00ffffff
)paren
op_or
(paren
(paren
id|val
op_amp
l_int|0xff
)paren
op_lshift
l_int|24
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_eq
l_int|0
)paren
id|pci0WriteConfigReg
c_func
(paren
id|offset
comma
id|device
comma
id|tmp
)paren
suffix:semicolon
singleline_comment|//  if (bus == 1) pci1WriteConfigReg (offset,device,tmp);
r_return
id|PCIBIOS_SUCCESSFUL
suffix:semicolon
)brace
DECL|function|galileo_pcibios_set_master
r_static
r_void
id|galileo_pcibios_set_master
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
id|u16
id|cmd
suffix:semicolon
id|galileo_pcibios_read_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|cmd
op_or_assign
id|PCI_COMMAND_MASTER
suffix:semicolon
id|galileo_pcibios_write_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*  Externally-expected functions.  Do not change function names  */
DECL|function|pcibios_enable_resources
r_int
id|pcibios_enable_resources
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
id|u16
id|cmd
comma
id|old_cmd
suffix:semicolon
id|u8
id|tmp1
suffix:semicolon
r_int
id|idx
suffix:semicolon
r_struct
id|resource
op_star
id|r
suffix:semicolon
id|galileo_pcibios_read_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|old_cmd
op_assign
id|cmd
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
l_int|6
suffix:semicolon
id|idx
op_increment
)paren
(brace
id|r
op_assign
op_amp
id|dev-&gt;resource
(braket
id|idx
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r-&gt;start
op_logical_and
id|r-&gt;end
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PCI: Device %s not available because of &quot;
l_string|&quot;resource collisions&bslash;n&quot;
comma
id|dev-&gt;slot_name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|r-&gt;flags
op_amp
id|IORESOURCE_IO
)paren
id|cmd
op_or_assign
id|PCI_COMMAND_IO
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;flags
op_amp
id|IORESOURCE_MEM
)paren
id|cmd
op_or_assign
id|PCI_COMMAND_MEMORY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_ne
id|old_cmd
)paren
(brace
id|galileo_pcibios_write_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Let&squot;s fix up the latency timer and cache line size here.  Cache&n;&t; * line size = 32 bytes / sizeof dword (4) = 8.&n;&t; * Latency timer must be &gt; 8.  32 is random but appears to work.&n;&t; */
id|galileo_pcibios_read_config_byte
c_func
(paren
id|dev
comma
id|PCI_CACHE_LINE_SIZE
comma
op_amp
id|tmp1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp1
op_ne
l_int|8
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;PCI setting cache line size to 8 from &quot;
l_string|&quot;%d&bslash;n&quot;
comma
id|tmp1
)paren
suffix:semicolon
id|galileo_pcibios_write_config_byte
c_func
(paren
id|dev
comma
id|PCI_CACHE_LINE_SIZE
comma
l_int|8
)paren
suffix:semicolon
)brace
id|galileo_pcibios_read_config_byte
c_func
(paren
id|dev
comma
id|PCI_LATENCY_TIMER
comma
op_amp
id|tmp1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp1
OL
l_int|32
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;PCI setting latency timer to 32 from %d&bslash;n&quot;
comma
id|tmp1
)paren
suffix:semicolon
id|galileo_pcibios_write_config_byte
c_func
(paren
id|dev
comma
id|PCI_LATENCY_TIMER
comma
l_int|32
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pcibios_enable_device
r_int
id|pcibios_enable_device
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_return
id|pcibios_enable_resources
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|function|pcibios_update_resource
r_void
id|pcibios_update_resource
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_struct
id|resource
op_star
id|root
comma
r_struct
id|resource
op_star
id|res
comma
r_int
id|resource
)paren
(brace
id|u32
r_new
comma
id|check
suffix:semicolon
r_int
id|reg
suffix:semicolon
r_return
suffix:semicolon
r_new
op_assign
id|res-&gt;start
op_or
(paren
id|res-&gt;flags
op_amp
id|PCI_REGION_FLAG_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|resource
OL
l_int|6
)paren
(brace
id|reg
op_assign
id|PCI_BASE_ADDRESS_0
op_plus
l_int|4
op_star
id|resource
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|resource
op_eq
id|PCI_ROM_RESOURCE
)paren
(brace
id|res-&gt;flags
op_or_assign
id|PCI_ROM_ADDRESS_ENABLE
suffix:semicolon
id|reg
op_assign
id|dev-&gt;rom_base_reg
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Somebody might have asked allocation of a non-standard&n;&t;&t; * resource&n;&t;&t; */
r_return
suffix:semicolon
)brace
id|pci_write_config_dword
c_func
(paren
id|dev
comma
id|reg
comma
r_new
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|reg
comma
op_amp
id|check
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_new
op_xor
id|check
)paren
op_amp
(paren
(paren
r_new
op_amp
id|PCI_BASE_ADDRESS_SPACE_IO
)paren
ques
c_cond
id|PCI_BASE_ADDRESS_IO_MASK
suffix:colon
id|PCI_BASE_ADDRESS_MEM_MASK
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PCI: Error while updating region &quot;
l_string|&quot;%s/%d (%08x != %08x)&bslash;n&quot;
comma
id|dev-&gt;slot_name
comma
id|resource
comma
r_new
comma
id|check
)paren
suffix:semicolon
)brace
)brace
DECL|function|pcibios_align_resource
r_void
id|pcibios_align_resource
c_func
(paren
r_void
op_star
id|data
comma
r_struct
id|resource
op_star
id|res
comma
r_int
r_int
id|size
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
op_assign
id|data
suffix:semicolon
r_if
c_cond
(paren
id|res-&gt;flags
op_amp
id|IORESOURCE_IO
)paren
(brace
r_int
r_int
id|start
op_assign
id|res-&gt;start
suffix:semicolon
multiline_comment|/* We need to avoid collisions with `mirrored&squot; VGA ports&n;&t;&t;   and other strange ISA hardware, so we always want the&n;&t;&t;   addresses kilobyte aligned.  */
r_if
c_cond
(paren
id|size
OG
l_int|0x100
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PCI: I/O Region %s/%d too large&quot;
l_string|&quot; (%ld bytes)&bslash;n&quot;
comma
id|dev-&gt;slot_name
comma
id|dev-&gt;resource
op_minus
id|res
comma
id|size
)paren
suffix:semicolon
)brace
id|start
op_assign
(paren
id|start
op_plus
l_int|1024
op_minus
l_int|1
)paren
op_amp
op_complement
(paren
l_int|1024
op_minus
l_int|1
)paren
suffix:semicolon
id|res-&gt;start
op_assign
id|start
suffix:semicolon
)brace
)brace
DECL|variable|galileo_pci_ops
r_struct
id|pci_ops
id|galileo_pci_ops
op_assign
(brace
id|galileo_pcibios_read_config_byte
comma
id|galileo_pcibios_read_config_word
comma
id|galileo_pcibios_read_config_dword
comma
id|galileo_pcibios_write_config_byte
comma
id|galileo_pcibios_write_config_word
comma
id|galileo_pcibios_write_config_dword
)brace
suffix:semicolon
DECL|variable|pcibios_fixups
r_struct
id|pci_fixup
id|pcibios_fixups
(braket
)braket
op_assign
(brace
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|function|pcibios_fixup_bus
r_void
id|__init
id|pcibios_fixup_bus
c_func
(paren
r_struct
id|pci_bus
op_star
id|c
)paren
(brace
id|gt64120_board_pcibios_fixup_bus
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This code was derived from Galileo Technology&squot;s example&n; * and significantly reworked.&n; *&n; * This is very simple.  It does not scan multiple function devices.  It does&n; * not scan behind bridges.  Those would be simple to implement, but we don&squot;t&n; * currently need this.&n; */
DECL|function|scan_and_initialize_pci
r_static
r_void
id|__init
id|scan_and_initialize_pci
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_device
id|pci_devices
(braket
id|MAX_PCI_DEVS
)braket
suffix:semicolon
r_if
c_cond
(paren
id|scan_pci_bus
c_func
(paren
id|pci_devices
)paren
)paren
(brace
id|allocate_pci_space
c_func
(paren
id|pci_devices
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is your basic PCI scan.  It goes through each slot and checks to&n; * see if there&squot;s something that responds.  If so, then get the size and&n; * type of each of the responding BARs.  Save them for later.&n; */
DECL|function|scan_pci_bus
r_static
id|u32
id|__init
id|scan_pci_bus
c_func
(paren
r_struct
id|pci_device
op_star
id|pci_devices
)paren
(brace
id|u32
id|arrayCounter
op_assign
l_int|0
suffix:semicolon
id|u32
id|memType
suffix:semicolon
id|u32
id|memSize
suffix:semicolon
id|u32
id|pci_slot
comma
id|bar
suffix:semicolon
id|u32
id|id
suffix:semicolon
id|u32
id|c18RegValue
suffix:semicolon
r_struct
id|pci_dev
id|device
suffix:semicolon
multiline_comment|/*&n;&t; * According to PCI REV 2.1 MAX agents on the bus are 21.&n;&t; * We don&squot;t bother scanning ourselves (slot 0).&n;&t; */
r_for
c_loop
(paren
id|pci_slot
op_assign
l_int|1
suffix:semicolon
id|pci_slot
OL
l_int|22
suffix:semicolon
id|pci_slot
op_increment
)paren
(brace
id|device.devfn
op_assign
id|PCI_DEVFN
c_func
(paren
id|pci_slot
comma
l_int|0
)paren
suffix:semicolon
id|id
op_assign
id|pci0ReadConfigReg
c_func
(paren
id|PCI_VENDOR_ID
comma
op_amp
id|device
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Check for a PCI Master Abort (nothing responds in the&n;&t;&t; * slot)&n;&t;&t; */
id|GT_READ
c_func
(paren
id|GT_INTRCAUSE_OFS
comma
op_amp
id|c18RegValue
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Clearing bit 18 of in the Cause Register 0xc18 by&n;&t;&t; * writting 0.&n;&t;&t; */
id|GT_WRITE
c_func
(paren
id|GT_INTRCAUSE_OFS
comma
(paren
id|c18RegValue
op_amp
l_int|0xfffbffff
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id
op_ne
l_int|0xffffffff
)paren
op_logical_and
op_logical_neg
(paren
id|c18RegValue
op_amp
l_int|0x40000
)paren
)paren
(brace
id|pci_devices
(braket
id|arrayCounter
)braket
dot
id|slot
op_assign
id|pci_slot
suffix:semicolon
r_for
c_loop
(paren
id|bar
op_assign
l_int|0
suffix:semicolon
id|bar
OL
l_int|6
suffix:semicolon
id|bar
op_increment
)paren
(brace
id|memType
op_assign
id|pci0ReadConfigReg
c_func
(paren
id|PCI_BASE_ADDRESS_0
op_plus
(paren
id|bar
op_star
l_int|4
)paren
comma
op_amp
id|device
)paren
suffix:semicolon
id|pci_devices
(braket
id|arrayCounter
)braket
dot
id|BARtype
(braket
id|bar
)braket
op_assign
id|memType
op_amp
l_int|1
suffix:semicolon
id|pci0WriteConfigReg
c_func
(paren
id|PCI_BASE_ADDRESS_0
op_plus
(paren
id|bar
op_star
l_int|4
)paren
comma
op_amp
id|device
comma
l_int|0xffffffff
)paren
suffix:semicolon
id|memSize
op_assign
id|pci0ReadConfigReg
c_func
(paren
id|PCI_BASE_ADDRESS_0
op_plus
(paren
id|bar
op_star
l_int|4
)paren
comma
op_amp
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memType
op_amp
l_int|1
)paren
(brace
multiline_comment|/*  IO space  */
id|pci_devices
(braket
id|arrayCounter
)braket
dot
id|BARsize
(braket
id|bar
)braket
op_assign
op_complement
(paren
id|memSize
op_amp
l_int|0xfffffffc
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*  memory space */
id|pci_devices
(braket
id|arrayCounter
)braket
dot
id|BARsize
(braket
id|bar
)braket
op_assign
op_complement
(paren
id|memSize
op_amp
l_int|0xfffffff0
)paren
op_plus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*  BAR counter  */
id|arrayCounter
op_increment
suffix:semicolon
)brace
multiline_comment|/*  found a device  */
)brace
multiline_comment|/*  slot counter  */
r_if
c_cond
(paren
id|arrayCounter
OL
id|MAX_PCI_DEVS
)paren
id|pci_devices
(braket
id|arrayCounter
)braket
dot
id|slot
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
id|arrayCounter
suffix:semicolon
)brace
DECL|macro|ALIGN
mdefine_line|#define ALIGN(val,align)        (((val) + ((align) - 1)) &amp; ~((align) - 1))
DECL|macro|MAX
mdefine_line|#define MAX(val1, val2) ((val1) &gt; (val2) ? (val1) : (val2))
multiline_comment|/*&n; * This function goes through the list of devices and allocates the BARs in&n; * either IO or MEM space.  It does it in order of size, which will limit the&n; * amount of fragmentation we have in the IO and MEM spaces.&n; */
DECL|function|allocate_pci_space
r_static
r_void
id|__init
id|allocate_pci_space
c_func
(paren
r_struct
id|pci_device
op_star
id|pci_devices
)paren
(brace
id|u32
id|count
comma
id|maxcount
comma
id|bar
suffix:semicolon
id|u32
id|maxSize
comma
id|maxDevice
comma
id|maxBAR
suffix:semicolon
id|u32
id|alignto
suffix:semicolon
id|u32
id|base
suffix:semicolon
id|u32
id|pci0_mem_base
op_assign
id|pci0GetMemory0Base
c_func
(paren
)paren
suffix:semicolon
id|u32
id|pci0_io_base
op_assign
id|pci0GetIOspaceBase
c_func
(paren
)paren
suffix:semicolon
r_struct
id|pci_dev
id|device
suffix:semicolon
multiline_comment|/*  How many PCI devices do we have?  */
id|maxcount
op_assign
id|MAX_PCI_DEVS
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|MAX_PCI_DEVS
suffix:semicolon
id|count
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pci_devices
(braket
id|count
)braket
dot
id|slot
op_eq
op_minus
l_int|1
)paren
(brace
id|maxcount
op_assign
id|count
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_do
(brace
multiline_comment|/*  Find the largest size BAR we need to allocate  */
id|maxSize
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|maxcount
suffix:semicolon
id|count
op_increment
)paren
(brace
r_for
c_loop
(paren
id|bar
op_assign
l_int|0
suffix:semicolon
id|bar
OL
l_int|6
suffix:semicolon
id|bar
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pci_devices
(braket
id|count
)braket
dot
id|BARsize
(braket
id|bar
)braket
OG
id|maxSize
)paren
(brace
id|maxSize
op_assign
id|pci_devices
(braket
id|count
)braket
dot
id|BARsize
(braket
id|bar
)braket
suffix:semicolon
id|maxDevice
op_assign
id|count
suffix:semicolon
id|maxBAR
op_assign
id|bar
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t; * We&squot;ve found the largest BAR.  Allocate it into IO or&n;&t;&t; * mem space.  We don&squot;t idiot check the bases to make&n;&t;&t; * sure they haven&squot;t overflowed the current size for that&n;&t;&t; * aperture.  &n;&t;&t; * Don&squot;t bother to enable the device&squot;s IO or MEM space here.&n;&t;&t; * That will be done in pci_enable_resources if the device is&n;&t;&t; * activated by a driver.&n;&t;&t; */
r_if
c_cond
(paren
id|maxSize
)paren
(brace
id|device.devfn
op_assign
id|PCI_DEVFN
c_func
(paren
id|pci_devices
(braket
id|maxDevice
)braket
dot
id|slot
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_devices
(braket
id|maxDevice
)braket
dot
id|BARtype
(braket
id|maxBAR
)braket
op_eq
l_int|1
)paren
(brace
id|alignto
op_assign
id|MAX
c_func
(paren
l_int|0x1000
comma
id|maxSize
)paren
suffix:semicolon
id|base
op_assign
id|ALIGN
c_func
(paren
id|pci0_io_base
comma
id|alignto
)paren
suffix:semicolon
id|pci0WriteConfigReg
c_func
(paren
id|PCI_BASE_ADDRESS_0
op_plus
(paren
id|maxBAR
op_star
l_int|4
)paren
comma
op_amp
id|device
comma
id|base
op_or
l_int|0x1
)paren
suffix:semicolon
id|pci0_io_base
op_assign
id|base
op_plus
id|alignto
suffix:semicolon
)brace
r_else
(brace
id|alignto
op_assign
id|MAX
c_func
(paren
l_int|0x1000
comma
id|maxSize
)paren
suffix:semicolon
id|base
op_assign
id|ALIGN
c_func
(paren
id|pci0_mem_base
comma
id|alignto
)paren
suffix:semicolon
id|pci0WriteConfigReg
c_func
(paren
id|PCI_BASE_ADDRESS_0
op_plus
(paren
id|maxBAR
op_star
l_int|4
)paren
comma
op_amp
id|device
comma
id|base
)paren
suffix:semicolon
id|pci0_mem_base
op_assign
id|base
op_plus
id|alignto
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * This entry is finished.  Remove it from the list&n;&t;&t;&t; * we&squot;ll scan.&n;&t;&t;&t; */
id|pci_devices
(braket
id|maxDevice
)braket
dot
id|BARsize
(braket
id|maxBAR
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|maxSize
)paren
suffix:semicolon
)brace
DECL|function|pcibios_init
r_void
id|__init
id|pcibios_init
c_func
(paren
r_void
)paren
(brace
id|u32
id|tmp
suffix:semicolon
r_struct
id|pci_dev
id|controller
suffix:semicolon
id|controller.devfn
op_assign
id|SELF
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI0_CMD_OFS
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|GT_READ
c_func
(paren
id|GT_PCI0_BARE_OFS
comma
op_amp
id|tmp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * You have to enable bus mastering to configure any other&n;&t; * card on the bus.&n;&t; */
id|tmp
op_assign
id|pci0ReadConfigReg
c_func
(paren
id|PCI_COMMAND
comma
op_amp
id|controller
)paren
suffix:semicolon
id|tmp
op_or_assign
id|PCI_COMMAND_MEMORY
op_or
id|PCI_COMMAND_MASTER
op_or
id|PCI_COMMAND_SERR
suffix:semicolon
id|pci0WriteConfigReg
c_func
(paren
id|PCI_COMMAND
comma
op_amp
id|controller
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/*  This scans the PCI bus and sets up initial values.  */
id|scan_and_initialize_pci
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Reset PCI I/O and PCI MEM values to ones supported by EVM.&n;&t; */
id|ioport_resource.start
op_assign
id|GT_PCI_IO_BASE
suffix:semicolon
id|ioport_resource.end
op_assign
id|GT_PCI_IO_BASE
op_plus
id|GT_PCI_IO_SIZE
op_minus
l_int|1
suffix:semicolon
id|iomem_resource.start
op_assign
id|GT_PCI_MEM_BASE
suffix:semicolon
id|iomem_resource.end
op_assign
id|GT_PCI_MEM_BASE
op_plus
id|GT_PCI_MEM_BASE
op_minus
l_int|1
suffix:semicolon
id|pci_scan_bus
c_func
(paren
l_int|0
comma
op_amp
id|galileo_pci_ops
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * for parsing &quot;pci=&quot; kernel boot arguments.&n; */
DECL|function|pcibios_setup
r_char
op_star
id|pcibios_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;rr: pcibios_setup&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Nothing to do for now.  */
r_return
id|str
suffix:semicolon
)brace
DECL|function|pcibios_assign_all_busses
r_int
id|__init
r_int
id|pcibios_assign_all_busses
c_func
(paren
r_void
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_PCI */
eof
